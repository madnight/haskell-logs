00:00:15 <wildtype> back to the basic grocery list example, is the State monad overkill compared to the tail rec. apporach? Or is it just preference?
00:00:53 <newsham> preference and depends on te situation..  having to pass around a list to a ton of intermediate functions can be a pain.. if its just one or two, its pretty managable
00:01:18 <newsham> one advantage to using a monad is that your code is less "brittle" to changes later.. you can swap in a more powerful or less powerful monad later if your needs change
00:02:15 <pjdelport> wildtype: Using State or not is kind orthogonal. Some code may just work with a grocery list directly, some might store it in State, or anything else. It's a bit like asking "Is the State monad overkill for working with lists?"
00:02:22 <newsham> Wadler's monad paper gives a good flavor of that flexibility:  http://dinhe.net/~aredridel/.notmine/PDFs/Monads%20for%20functional%20programming.pdf
00:03:14 <wildtype> Cool. Thanks for your thoughts, guys.
00:03:22 <newsham> my pleasure.  enjoy!
00:03:24 <wildtype> (gals?)
00:04:28 <Yuu_chan> :)
00:06:18 <Yuu_chan> osa1: But that's really horrifying! I can't believe that even unboxed arrays don't save space.
00:07:43 <osa1> Yuu_chan: what made you think unboxed arrays don't save space?
00:08:04 <Yuu_chan> I mean arrays of small ints.
00:09:45 <osa1> right. I once used Word8 arrays for some small toy VM and apparently I didn't work as I expected.
00:10:32 <osa1> it didn't work as I expected*
00:11:24 <Yuu_chan> Hm, if they represent internal storage as Ptr a or something, they can actually save space
00:17:50 <Ainieco> hello, why uninitialized record field isn't a compile time error?
00:19:27 <enthropy> Ainieco: you could possibly fill in the field later on with a value
00:19:59 <enthropy> if you want it to be a compile time error just compile with -Werror
00:20:25 <Ainieco> enthropy: ah, okay, thanks for clarification
00:21:57 <Yuu_chan> Has anybody used Bloodhound?
00:51:34 <dmwit> osa1, Yuu_chan: Er, did you verify that unboxed arrays don't use less space for smaller ints?
00:52:21 <dmwit> Just because Int8 uses 32 bits (or more) under the hood doesn't mean UArray ix Int8 uses 32 bits for each element.
00:55:25 <osa1> dmwit: I didn't verify anything, I'm just saying that Int8 is internally same as Int32, Word8 is same as Word32 etc.
00:55:33 <osa1> I don't know about UArray
00:55:38 <Yuu_chan> dmwit: I only wonder as well.
00:58:54 <dmwit> I just made an array with 100*1024*1024 Word8's in it.
00:58:59 <dmwit> My total memory usage jumped 200M.
00:59:12 <dmwit> So that seems pretty good evidence it's not actually using 400M for the unboxed array. =)
00:59:39 <Yuu_chan> UArray has some ByteArray# in its structure
01:00:00 <Yuu_chan> dmwit: but why not 100? :)
01:00:11 <dmwit> I'm not totally sure.
01:00:18 <dmwit> It's possible there was a fair bit of garbage collection.
01:00:29 <dmwit> Since the way you make an array is by reading a list.
01:01:00 <dmwit> So it wouldn't surprise me at all to find out there was 100M of garbage while traversing a 1e8-element list.
01:02:22 <dmwit> In fact, I would bet on significantly more. If you forced the whole list into memory at once, it should be over a gig.
01:03:40 <Yuu_chan> dmwit: does GHC apply some fusions or rewriting rules to effectively initialize an array?
01:04:08 <dmwit> I don't really know much about it.
01:04:59 <dmwit> If you really want to avoid traversing a list, you probably should write into the elements of a mutable array and freeze it after.
01:05:20 <dmwit> bedtime
01:06:31 <Yuu_chan> Good night :)
01:06:42 <sipa> good morning
01:06:45 * hackagebot enclosed-exceptions 1.0.0.2 - Catching all exceptions from within an enclosed computation  http://hackage.haskell.org/package/enclosed-exceptions-1.0.0.2 (jcristovao)
01:07:30 <code13> good aftr noon :)
01:10:34 <piezo> hi
01:11:13 <dmj`> hi
01:11:25 <piezo> I've generated a 'XMLParser MyType' with HaXml, how do I use it ?
01:12:11 <piezo> i look everywhere in Haddock, the type don't match...
01:13:07 <dmj`> piezo: by XMLParser do you mean XParser?
01:14:04 <piezo> no XMLParser, generated with XsdToHaskell
01:15:34 <piezo> so 'runParser elementMyType' :: [Content Posn] -> (Either String MyType, [Content Posn])
01:18:13 <piezo> the problem is to get a Content Posn, fReadXml produce a 'XmlContent a => a' but 'Content Posn' doesn't satisfy XmlContent...
01:20:15 <piezo> XsdToHaskell generated for me a nice topLevel 'XMLParser MyType', so there must be a simple way to use it
01:27:20 <code13> any one know about Insecure Direct Object Reference Vulnerability ?
01:28:53 <shachaf> You should ask your question if you have a question (and it has something to do with Haskell).
01:29:34 <code13> ok :/
01:41:49 * hackagebot free 4.8 - Monads for free  http://hackage.haskell.org/package/free-4.8 (EdwardKmett)
01:54:15 <edvo> is there a way to write the following better with lens: x & lens %~ M.mapMaybeWithKey f? Something like x & lens.foo %@~ f?
01:54:46 <edwardk> not sure
01:55:18 <tdammers> write (%@~) yourself, submit a patch?
01:55:33 <edvo> :t (%@~)
01:55:34 <lambdabot> AnIndexedSetter i s t a b -> (i -> a -> b) -> s -> t
01:56:46 <tdammers> right nm
01:57:35 <shachaf> Hmm, mapMaybeWithKey is interesting.
01:57:54 <shachaf> I guess the idea is that you can delete values?
01:58:08 <edvo> yes
01:58:23 <edvo> basically something along Lens a (Maybe b) -> Setter a b, which acts like mapMaybe (and a similar thing for indexed lenses) should work, but i don't know if that exists
01:58:27 <shachaf> What it "should" do is map over every element in the domain, even the ones that don't have values.
01:58:49 <shachaf> (k -> Maybe a -> Maybe b) -> Map k a -> Map k b
01:58:56 <shachaf> Except not really, of course.
01:59:50 <edvo> insertion of new elements is not needed, i just need to delete some
02:00:18 <shachaf> I don't understand your type.
02:00:57 <edvo> yeah, it's more like Traversal a (Maybe b) -> Setter a b
02:01:20 <edvo> well, maybe not
02:01:40 <Marquis> hello haskellers. Lets say i have a list looking like this: let a = [[1..10],[11..20],[21..30]...] and i want to extract several indices that i have in another List like the first, 7th and 9th element so i have the list : [[1,7,9],[11,17,19],...]], how could i do it? and i want to make them a vector. will it be more efficient to make them a vector first, itterate over the list of vectors and then make them vectors again, or just make
02:02:27 <shachaf> I still don't follow.
02:03:49 <bartavelle> Marquis, vector has a ton of fusion optimization rules, which might or might not fire, and might or might not make your code really efficient
02:04:04 <bartavelle> there are list fusion optimizations in GHC
02:04:20 <bartavelle> so I suppose the answer is "it depends" :)
02:04:25 <edvo> basically something, which does the same as mapMaybe. so that [1..10] %~ foo.f == mapMaybe f [1..10]
02:04:39 <edvo> except for Map and with index
02:05:02 <Marquis> okay then i will try the most easy sollution and hope it fits
02:05:08 <bartavelle> edvo : M.mapMaybe ?
02:05:11 <bartavelle> ah with index
02:05:15 <shachaf> I don't think that'll work with lens very well.
02:05:16 <bartavelle> M.mapMaybeWithKey
02:06:47 <edvo> ok, I guess I should just use mapMaybeWithKey
02:10:21 <pavonia> Is there a shorter way for converting a String into an UTF-8-encoded String than String -> Text -> ByteString -> String?
02:11:53 <edwardk> there can be no lenslike for mapMaybe
02:15:22 <shachaf> mapMaybe has trouble with e.g. the over l id = id law
02:15:32 <shachaf> a
02:15:45 <shachaf> Or whatever formulation you might end up with.
02:16:30 <edvo> i see
02:17:03 <pavonia> Man... what format does Cairo's showText expect? I get "user error (input string not valid UTF-8)"
02:17:48 <edvo> But it is already possible to delete elements from a Map with at. Could it not be possible to extend it to go over all keys in the Map?
02:17:58 <pavonia> Ah, never mind
02:19:57 <merijn> I forget, what is Chris Done's nick?
02:20:36 <alpounet> merijn: 'chrisdone'
02:21:22 <merijn> alpounet: That's what I thought, but freenode told me that name "There was no such nickname" when I tried /whowas, thaks :)
02:21:45 <alpounet> merijn: he's probably just not connected at the moment
02:21:50 <alpounet> but that's his nick, for sure :)
02:22:00 <merijn> alpounet: whowas generally also lists people that were online in the past
02:22:48 <alpounet> well it failed :P see http://ircbrowse.net/nick/chrisdone for example
02:23:05 <merijn> @tell chrisdone I like the Inkscape mockup, but I think the code sample should have a type signature as signature free top level code is not something encouraged by the community
02:23:05 <lambdabot> Consider it noted.
02:25:37 <matematikaadit> merijn: try "/WHOIS chrisdone" or "/msg NickServ INFO chrisdone"
02:26:56 * hackagebot metric 0.2.0 - Metric spaces.  http://hackage.haskell.org/package/metric-0.2.0 (vi)
02:27:30 <companion_cube> wow, now I can download metric spaces on the internet! :D
02:30:43 <shachaf> edvo: at is symmetrical -- you can either insert or delete -- so you get a real lens.
02:32:15 <edwardk> edvo: consider that with at you can read out a given key and get that it is present, then you can change that fact to false, then you can change it back to true!
02:32:24 <edwardk> edvo: try doing that with mapMaybe
02:32:43 <edwardk> edvo: once you 'remove' a key or entry you lose it forever!
02:32:54 <edwardk> there is no notion of a usable cursor to put it back
02:34:03 <edvo> ah, that makes sense
02:34:07 <edvo> thank you
02:39:34 <trap_exit> i'm swithcing from clojure to haskell
02:39:46 <trap_exit> what is the equiv of vector / map in haskell ?
02:41:57 * hackagebot htiled 0.1.1.2 - Import from the Tiled map editor.  http://hackage.haskell.org/package/htiled-0.1.1.2 (ChristianRoedliAmble)
02:43:40 <k00mi> trap_exit: what do vector/map do?
02:43:56 <trap_exit> vector can be just a list
02:44:03 <trap_exit> map supports assoc, dissoc, and get
02:45:40 <k00mi> a list is just [elem1,elem2...], for map have a look here: http://hackage.haskell.org/package/containers-0.5.5.1/docs/Data-Map-Lazy.html
02:45:53 <k00mi> you should probably read a book such as learn you a haskell
02:46:55 <trap_exit> how do I declare a type to say a list of strings
02:47:01 <trap_exit> i.e. "data Tag = Tag [String] " ?
02:47:17 <pjdelport> trap_exit: The Haskell equivalent of a vector would probably be Array (though Haskell Arrays have richer indexing semantics)
02:48:31 <buckmaster> pjdelport: because of laziness?
02:48:33 <k00mi> trap_exit: have a look at the vector package for a nice array library
02:48:48 <trap_exit> k00mi, pjdelport : thanks
02:48:53 <trap_exit> (and what difficu,t ot type usernames)
02:49:16 <k00mi> trap_exit: yes, that declares a type Tag that hase one constructor Tag that takes a list of Strings
02:49:44 <trap_exit> is there a way to say "String or NUmber" better than "data MyType = S String | N Double" ?
02:49:46 <pjdelport> buckmaster: No; Clojure's Vector is indexed by integers only (IINM), while Haskell has a generic Ix typeclass for indexes, which gives you quite a bit of power.
02:50:24 <frerich> trap_exit: Depending on the use case, 'Either String Double' might be a plausible choice, too.
02:50:30 <Pythonfant> Can I force a recompile even if nothing changed?
02:50:47 <k00mi> pjdelport: in most cases you should use Vector over Array
02:50:52 <pjdelport> buckmaster: It lets you index Arrays by tuples, Chars, etc.
02:50:53 <k00mi> Vector has awesome fusion
02:51:51 <Pythonfant> found it -fforce-recomp
02:52:12 <trap_exit> data Tag = Tag [String]  data Attrs = Map String String  data Doc = Doc Tag Attrs (Map String Doc)
02:52:24 <trap_exit> how do I say this ... a Doc consists of  Tag, an Attrs, and a Map mapping strings to Docs
02:54:38 <k00mi> trap_exit: read this: http://learnyouahaskell.com/making-our-own-types-and-typeclasses#algebraic-data-types
02:54:49 <trap_exit> k00mi: will do
02:55:51 <hubblebib> Hi, what's the preferred way of handling errors? Should I parameterize my function by a monad and call fail?
02:56:37 <k00mi> hubblebib: return Maybe or Either
02:57:07 <hubblebib> k00mi: ok, is that considered better than allowing an arbitrary typeclass?
02:57:24 <trap_exit> data Doc = Doc { tag :: Tag,                  attrs :: Map String String}
02:57:30 <trap_exit> why do I get an eror rabout Not in scope "Map"  ?
02:57:39 <k00mi> hubblebib: yes, I'd say that's an abuse of Monad
02:57:52 <hubblebib> k00mi: ok, thanks :)
02:57:54 <k00mi> trap_exit: did you import Data.Map?
02:58:00 <hubblebib> k00mi: what if I wanted to return an error message?
02:58:26 <k00mi> hubblebib: you return Either String ReturnType
02:58:55 <hubblebib> k00mi: right, that's what I thought, it just looked a little clumsy but I guess it's fine
02:59:28 <k00mi> that's exactly why Either exists
02:59:49 <k00mi> Functor, Applicative, Monad etc. make it less clumsy to work with such functions
02:59:57 <frerich> hubblebib: It's quite idiomatic to do it with 'Either String FooType' with 'FooType' being the 'right' type (right as in the side but also as in 'correct').
03:00:16 <hubblebib> frerich: heh :)
03:00:44 <hubblebib> k00mi: yes, fair enough, all right it starts to look better and better :)
03:00:50 <frerich> hubblebib: I.e. to avoid confusing people, I'd very much recommend that the first argument to 'Either' is the type for the error value, adn the second is the type of the success value - not the other way round :)
03:01:16 <hubblebib> frerich: yeah, I was going to start the other way around, thanks :)
03:08:02 <Pythonfant> I'm trying to find out why ghc gives me a warning that statusMessage, text and aspectIds are unused in this code http://lpaste.net/104849 . Obviously I use this in line 51
03:09:28 <trap_exit> https://gist.github.com/txrev319/c4f4e50228b363b13397 gives
03:09:28 <trap_exit>  ~/.cabal/bin/fay Hello.hs fay: could not find an import in the path: Data.Map,  searched in these places: /home/x/.cabal/share/fay-0.20.0.4/src/, /home/x/.cabal/share/fay-base-0.19.1.2/src, /home/x/.cabal/share/fay-base-0.19.1.2, .
03:09:30 <trap_exit> what's going on?
03:11:55 <k00mi> trap_exit: oh, you're using fay
03:12:03 <trap_exit> k00mi: yes
03:12:15 <k00mi> I'm not sure how that interacts with normal cabal packages
03:12:26 <trap_exit> doh
03:12:30 <trap_exit> I need cabal packages to get Map ?
03:12:33 <trap_exit> i.e. it's not a builtin ?
03:12:40 <k00mi> it's in the containers package
03:13:30 <frerich> Pythonfant: I don't see you using 'statusMessage' or 'text' (the field [i.e. functions!] which you define in lines 13 and 14 resp.) anywhere. In line 51, you just use the 'StatusMessage' data constructor and the 'text' function argument (from line 49).
03:13:54 <Pythonfant> frerich: well the toJson function uses them (at least I think so)
03:14:01 <Pythonfant> sry toJSON
03:14:07 <Pythonfant> and that should be called by encode
03:14:20 <k00mi> trap_exit: but fay is not haskell, so I don't think you can use packages installed via cabal in your fay code
03:14:45 <trap_exit> does Data.Map require type classes
03:14:51 <trap_exit> that appears to be only feature of haskell not supported by Fay
03:14:52 <frerich> Pythonfant: In 'PostData status aspects', that's not actually making use of the 'statusMessage' defined in line 14. For 'PostData status aspects' to work, you could have just defined 'data PostData = PostData StatusMessage !String'
03:15:04 <frerich> Pythonfant: I.e.plain fields without getter functions.
03:15:09 <Pythonfant> ah thanks
03:15:33 <frerich> Pythonfant: By writing 'data PostData = PostData { statusMessage :: StatusMessage ...' a function 'statusMessage :: PostData -> StatusMessage' is defined for you - and that's the one which is unused.
03:15:33 <k00mi> trap_exit: yes
03:15:48 <Pythonfant> frerich: yep I somehow forgot that
03:16:16 <k00mi> trap_exit: you could try GHCJS, that supports all of haskell (and even some extensions)
03:18:42 <trap_exit> k00mi: hmm, is it stable / usable?
03:19:29 <k00mi> it should be usable, but I don't think it's stable
03:19:38 <k00mi> all of these Haskell -> JS projects are still in flux
03:20:03 <k00mi> it might be wise to use normal GHC until you're more comfortable with haskell
03:25:31 <trap_exit> no no
03:25:33 <trap_exit> I have to write JS
03:25:37 <trap_exit> but I wnt somethign with types
03:26:25 <companion_cube> ocaml? :)
03:27:29 <trap_exit> is ocaml -> js stable ?
03:27:41 <companion_cube> pretty much, afaik
03:32:56 <trap_exit> hmm
03:32:58 <trap_exit> how is Haste ?
03:33:27 <companion_cube> you might also want to try haxe, I think
03:34:52 <trap_exit> http://www.reddit.com/r/haskell/comments/1ldqav/thoughts_on_uhc_vs_haste_vs_fay/
03:34:56 <trap_exit> ghcjs sounds expensive
03:37:04 * hackagebot trivial-constraint 0.1.0.0 - A class / constraint that any type fulfills  http://hackage.haskell.org/package/trivial-constraint-0.1.0.0 (leftaroundabout)
03:38:56 <trap_exit> okay
03:38:57 <trap_exit> i will try haste
03:40:00 <Maxdamantus> How long till ghcjs runs GHC?
03:40:30 <trap_exit> then we can compile ghc
03:40:34 <trap_exit> inside of chrome
03:41:03 <tdammers> next step: compile ghc inside chrome faster than the ghc guys release new versions
03:41:12 <buckmaster> haha
03:41:13 <t7> yey then we can get rid of everything other than javascript
03:41:45 <t7> i will not rest until the browser is the only rubbish operating system you can use
03:42:03 <dario> you guys know https://www.destroyallsoftware.com/talks/the-birth-and-death-of-javascript ?
03:42:19 <luite> Maxdamantus: i think it can already run the relevant parts but the problem is that it's not a cabal pacakage
03:42:48 * Maxdamantus has seen that.
03:43:24 <luite> i've compiled programs like fay, cabal-install and hscolour and they work, although there are still some issues with file io
03:43:36 <Maxdamantus> Nice.
03:44:29 <luite> (obviously this doesn't work in the browser, the programs use the node.js file and process api, the browser wouldn't have access to ghc-pkg of course)
03:46:07 <luite> anyway need to walk to the gate, flight starts boarding in a few mins. to everyone going to budhac, see you tonight/tomorrow :)
03:47:05 * hackagebot trivial-constraint 0.2.0.0 - A class / constraint that any type fulfills  http://hackage.haskell.org/package/trivial-constraint-0.2.0.0 (leftaroundabout)
03:49:47 <trap_exit> compiling haste
03:49:48 <trap_exit> man this is slow
03:50:54 <mirpa> Can I force Haddock to add prefix to names imported from qualified modules? import qualified A.B.C as C so prefix would be "C."
03:51:36 <Kaidelong> for /join @haskell-game
03:51:39 <Kaidelong> whoops
03:56:28 <obiwahn> Hi, are there projects written in haskell hat make use of massive distribution. From time to time i think about learning haskell (or some other functional language). Being able to write distributed with less overhead would seem to me a good use case. Yesterday i looked at scala and it seemed pretty cool. What do you think about that language? I guess it does not really do lazy evaluation and sometimes it is
03:56:30 <obiwahn> hard to see what has a state and what does not but i am not really skilled enough to judge.
03:59:23 <Axman6> obiwahn: we have the CloudHaskell project which seeks to implement distributed programming a la Erlang.
04:00:18 <obiwahn> http://www.haskell.org/haskellwiki/Applications_and_libraries/Concurrency_and_parallelism i had that page open
04:01:30 <obiwahn> Distributed programming is still mainly a research area. that was kind of discouraging ... i guess it is but still:P
04:05:14 <obiwahn> And how would i investigate issues that arise when i run out of memory?
04:05:54 <obiwahn> http://www.haskell.org/ghc/docs/7.0.4/html/users_guide/prof-heap.html :)
04:18:50 <akegalj> is anywhare defined "for = flip map" ?
04:21:05 <pavonia> akegalj: No
04:21:09 <remdezx> Hello! Is there any pretty way to append a value to a tuple? Maybe lens can do that?
04:21:46 <opqdonut> > let appendThird (a,b) c = (a,b,c) in appendThird (1,2) 'c'
04:21:48 <Iceland_jack> remdezx: Why would you need to do that? if it's a 2-tuple then you should just use
04:21:48 <Iceland_jack>     \val (a, b) -> (a, b, val)
04:21:48 <lambdabot>  (1,2,'c')
04:22:17 <opqdonut> remdezx: just do it. but keep in mind that each tuple length is a separate type
04:24:02 <remdezx> Iceland_jack: I'm building queries to with postgresql library and it use tuples to pass variables to a sql query. I though there are some magic tricks to concat tuples in lens or elsewhere ;p
04:24:23 <remdezx> opqdonut: I know it well, thanks! ;)
04:32:19 <danilo2> Hello! Is there in Haskell any library which allows for computations based on some metrics sytem and diffeerent coordinate systems?
04:33:31 <pjdelport> danilo2: Can you narrow that down?
04:35:37 <danilo2> pjdelport: Of course - I can expand something to my needs - if there is anything out there
04:36:53 <pjdelport> There are probably lots of different things. :)
04:39:45 <spion> is there a library that models a sequence of SQL queries that need to be executed within a single transaction as a monad? (or is there a better way to do it...)
04:55:32 <adamo0> which one holocaust was best one?
04:57:17 --- mode: ChanServ set +o copumpkin
04:57:22 --- mode: copumpkin set +b *!~adamo0@abkp235.neoplus.adsl.tpnet.pl
04:57:22 --- kick: adamo0 was kicked by copumpkin (no.)
04:57:24 --- mode: copumpkin set -o copumpkin
05:00:32 <trap_exit> damn ....
05:00:34 <trap_exit> haste is awesome
05:00:39 <trap_exit> what is the greatest weakness of haste?
05:23:52 <xpikab> is there a data type like data a = T a ?
05:24:06 <sshine> Identity?
05:24:57 <xpikab> sshine: thanks
05:29:49 <ddellacosta> is there a CSP implementation in Haskell that is in wide use?  Or do folks prefer some other async paradigm?
05:30:17 <Iceland_jack> ddellacosta: http://chimera.labs.oreilly.com/books/1230000000929 you'll want to check this book out
05:30:28 <Iceland_jack> the concurrency part of it
05:30:53 <ddellacosta> Iceland_jack: very cool, thanks. Other than that, can you recommend any resources on the web I could check out?
05:31:19 <Iceland_jack> for super simple asynchronous actions you'll want
05:31:20 <Iceland_jack> @hackage async
05:31:20 <lambdabot> http://hackage.haskell.org/package/async
05:31:32 <ddellacosta> Iceland_jack: reading the TOC, looks like MVars are a thing to check out?
05:31:44 <Iceland_jack> MVars are low-level primitives
05:31:46 <ddellacosta> Iceland_jack: great, thanks
05:32:01 <ddellacosta> Iceland_jack: okay, this should get me going. Thank you!
05:32:12 <Iceland_jack> if you're just interested in launching threads that don't need to communicate then you'll be fine with 'forkIO'
05:32:12 <Iceland_jack> @ty forkIO
05:32:13 <lambdabot> Not in scope: ‘forkIO’
05:32:22 <sshine> :t forkIO
05:32:23 <lambdabot> Not in scope: ‘forkIO’
05:32:35 <Iceland_jack>     forkIO :: IO () -> IO ThreadId
05:33:11 <sshine> I wonder, is there anything like the Java executor framework for threads in Haskell?
05:33:16 <ddellacosta> no, I'm specifically interested in (something like) CSP
05:34:24 <sshine> ddellacosta, a quick google search gave me http://www.cs.kent.ac.uk/projects/ofa/chp/ - I'm sure word-of-mouth on whether this is good stuff is what you're looking for, though. :)
05:34:28 <jmcarthur_mobile> ddellacosta: any particular reason?
05:34:39 <ddellacosta> wow, that book is free online, isn't it?  Awesome.  So many incredible Haskell resources available for free
05:34:45 <ddellacosta> sshine: thanks
05:35:13 <Iceland_jack> CSP is unneccesarily heavyweight for many purposes in Haskell I find
05:35:20 <ddellacosta> jmcarthur_mobile: well, I've used core.async a lot in Clojure and really like it, so I was curious what was idiomatic or widely used in Haskell
05:35:41 <bernalex> how do you see the thunks in ghci? I forget
05:35:47 <ddellacosta> and yeah, I'm just curious in general what folks in Haskell think of it, per what Iceland_jack just said
05:35:50 <jmcarthur_mobile> ddellacosta: but why the stipulation that it be like csp?
05:35:56 <jmcarthur_mobile> Ah
05:36:26 <Iceland_jack> ddellacosta: There are also
05:36:26 <Iceland_jack>     Control.Concurrent.{Chan,STM,TQueue,...}
05:36:26 <Iceland_jack> that break this functionality into nice pieces
05:36:32 <ddellacosta> jmcarthur_mobile: yeah, it's not that it needs to be like it, I just am ignorant of what concurrent paradigms are dominant in Haskell.  Sorry, should probably have stated that from the get-go
05:36:41 <jmcarthur_mobile> ddellacosta: it really just depends on what you are doing. There are a lot of interfaces available
05:36:43 <k00mi> bernalex: :print
05:36:49 <ddellacosta> Iceland_jack: ah, interesting
05:37:06 <ddellacosta> jmcarthur_mobile: fair enough
05:37:16 <bernalex> k00mi: ah. I knew it! my issue was that I did :p [0..], but that didn't work. if I used let it worked though.
05:37:39 <jmcarthur_mobile> ddellacosta: in addition to all these concurrency libraries, there's also a totally different set of libraries devoted to parallelism
05:37:58 <jmcarthur_mobile> Just FYI
05:38:02 <ddellacosta> jmcarthur_mobile: gotcha
05:38:12 <ddellacosta> alright, this gives me plenty to dig into.  Thanks Iceland_jack, sshine and jmcarthur_mobile!
05:38:21 <Iceland_jack> You're welcome, good luck ddellacosta
05:40:52 <Iceland_jack> ddellacosta: This might be interesting to you http://stackoverflow.com/questions/4522387/how-can-i-emulate-gos-channels-with-haskell
05:41:40 <ddellacosta> Iceland_jack: yes indeed. Control.Concurrent.Chan is (part of) what you mentioned above I guess
05:41:44 <Iceland_jack> yes
05:41:53 <Iceland_jack> a lot of the time something 'foolproof' like async is fine though, or sharing some values in TVars
05:42:11 <Iceland_jack> and accessing/modifying them transactionally from different threads
05:42:40 <ddellacosta> right, okay
05:43:28 <ddellacosta> all I have to compare it with is Clojure, but seems like the variety is greater (without dipping into the Java lib world as you would have to in Clojure)
05:45:25 <Iceland_jack> Channels are quite trivially implemented on top of MVars
05:46:28 <Iceland_jack> and TVars, for transactional channels
05:47:59 <ddellacosta> randomly, this just floated across my twitter feed... https://twitter.com/planet_haskell/status/454103079747473408  Synchronicity
05:54:05 <ReinH> I hope someone has mentioned Marlow's book :)
05:56:26 <ReinH> ddellacosta: just in case, http://chimera.labs.oreilly.com/books/1230000000929
05:56:45 <ddellacosta> ReinH: oh yeah, Iceland_jack clued me into that, but thanks
05:56:54 <ReinH> Great
06:07:05 <hseg> Hi. Is there a fold-filter fusion law? Something like: foldr f z . filter p = foldl f' z where f' (x y) = if p x then f x y else y
06:15:31 <mirpa> howto convert Float -> Double?
06:17:49 <mirpa> for some reason I don't have link to GHC.Float in Haddock...
06:18:54 <ion> mirpa: realToFrac
06:19:17 <mirpa> is it better than GHC.Float.float2Double?
06:21:22 <ion> Depends. It's polymorphic and portable, but might not be as efficient. Is the conversion in a performance-critical part of the code?
06:23:08 <ion> There might be a rewrite rule that makes it efficient anyway, i haven't looked.
06:23:53 <ion> Or the short answer: yes
06:25:24 <mirpa> ok, sometimes I find myself lost trying to do some silly conversion :-)
06:27:49 <ion> Conversion from integrals: fromIntegral, conversion from reals: realToFrac. That's pretty much it.
06:29:14 <ion> round or floor for most cases of real to integral conversion.
06:32:26 * hackagebot apiary 0.9.0.0 - Simple web framework inspired by scotty.  http://hackage.haskell.org/package/apiary-0.9.0.0 (HirotomoMoriwaki)
06:37:27 * hackagebot apiary-cookie 0.9.0.0 - Cookie support for apiary web framework.  http://hackage.haskell.org/package/apiary-cookie-0.9.0.0 (HirotomoMoriwaki)
06:37:28 * hackagebot apiary-clientsession 0.9.0.0 - clientsession support for apiary web framework.  http://hackage.haskell.org/package/apiary-clientsession-0.9.0.0 (HirotomoMoriwaki)
06:37:30 * hackagebot apiary-authenticate 0.9.0.0 - authenticate support for apiary web framework.  http://hackage.haskell.org/package/apiary-authenticate-0.9.0.0 (HirotomoMoriwaki)
06:37:33 * hackagebot apiary-logger 0.9.0.0 - fast-logger support for apiary web framework.  http://hackage.haskell.org/package/apiary-logger-0.9.0.0 (HirotomoMoriwaki)
06:37:35 * hackagebot apiary-persistent 0.9.0.0 - persistent support for apiary web framework.  http://hackage.haskell.org/package/apiary-persistent-0.9.0.0 (HirotomoMoriwaki)
06:37:49 <hseg> Hi. Is there a fold-filter fusion law? Something like: foldr f z . filter p = foldl f' z where f' (x y) = if p x then f x y else y
06:42:37 * hackagebot apiary-websockets 0.9.0.0 - websockets supper for apiary web framework.  http://hackage.haskell.org/package/apiary-websockets-0.9.0.0 (HirotomoMoriwaki)
06:48:55 <Pythonfant> I get this error when trying to build text http://pastie.org/9239599
06:51:37 <pilu> hi, how can i make to convert from infix notation to postfix notation?
06:53:50 <brycelane> basic haskell question: when doing the WAI/warp hello world, the function responseLBS takes a status, headers, and a ByteString. In the hello world example, what appears to be a String literal is passed and it compiles and runs. If you try to pass something of type String, it  cannot convert String to ByteString. How does that work?
06:54:21 <gauthier> brycelane: there is an OverloadedStrings language extension
06:54:38 <napping> Pythonfant: try checking the log it mentions
06:54:51 <brycelane> gauthier: is that like an implicit conversion between String and ByteString?
06:54:52 <gauthier> brycelane: I don't know the intrinsic, but with it string literals can be typed to something else than String type
06:55:05 <gauthier> brycelane: it happens at compile time
06:55:33 <brycelane> gauthier: thanks, that helps
06:57:22 <rwbarton> it works just the same way as the overloaded numeric literals that let you write things like sqrt 2
06:58:22 <gauthier> question: I'm trying to load some code in ghci (from histogram-fill repository), in the code there is #if !MIN_VERSION_base(4,7,0) which chokes when loading files in ghci or with emacs' flycheck, how can I fix that?
06:58:39 <brycelane> I'm pretty fresh to Haskell, thanks for the help all.
06:59:07 <Pythonfant> napping: nothing in there except [x of 43] compiling … However it only goes to [42 of 43]
06:59:24 <rwbarton> Pythonfant: what was the command you ran to get that output?
06:59:28 <rwbarton> is that the whole output?
06:59:30 <rwbarton> are you using cabal -j?
06:59:40 <Pythonfant> I ran cabal install text
06:59:46 <rwbarton> there doesn't appear to actually be an error message so we need more info
07:00:14 <Pythonfant> hm maybe the process is killed because it's taking up too much cpu (shared host)
07:00:23 <gauthier> I guess my question is also, where are those CPP macros defined? what should I do to have those defined in ghci / flycheck environments?
07:00:24 <rwbarton> yes probably, or too much ram
07:00:37 <Pythonfant> is there some way to limit cabal/ghc in this regard?
07:01:39 <rwbarton> gauthier: I think cabal defines them somehow
07:01:54 <dogmaT> brycelane: GHC has OverloadedStrings language extension that uses IsString class (defined in module Data.String). This language extension simply puts fromString in front of every string literal and then anything that has IsString instance can be expected in place of string literal.
07:02:23 <dogmaT> brycelane: It's similar to how numeric literals are handled.
07:03:20 <brycelane> thanks dogmaT. Seems I have some more reading to do.
07:04:11 <gauthier> rwbarton / brycelane: so it seems it's not that "compile time" thing, it has a runtime cost (implementation of fromString)
07:04:25 <rwbarton> Pythonfant: probably you should just not try to build things on the shared host
07:05:33 <Pythonfant> rwbarton: I tried building it locally but then it seems to link to some version of libgmp that isn't on the shared host.
07:06:09 <rwbarton> that's probably an easier problem to solve
07:06:20 <Pythonfant> ah one can link statically to libgmp
07:07:21 <napping> Can anyone here suggest a particular diff library?
07:07:30 * hackagebot wai-middleware-static 0.5.0.1 - WAI middleware that serves requests to static files.  http://hackage.haskell.org/package/wai-middleware-static-0.5.0.1 (AndrewFarmer)
07:08:26 <napping> I have some files where most of what shows up in the diffs comes from reflowing text, and I'd like to diff ignoring that
07:17:05 <napping> Not what I'm looking for, but gdiff looks interesting, and like it could benefit greatly from being updated to use GHC.Generics
07:17:40 <toonces> hey, can you tell me the difference between $ and . ?
07:17:45 <toonces> because I don't see any
07:18:00 <napping> compare print $ "Hello" and print . "Hello"
07:18:05 <Axman6> the difference is in the associativity
07:18:21 <napping> Axman6: that's not important
07:18:33 <Axman6> sure it is...
07:18:36 <napping> The right argument to $ is a value that will be passed to the function on the left
07:18:51 <napping> The right argument to . is another function that gets composed with the function to the left
07:18:54 <Iceland_jack> toonces: The types are completely different, (.) takes two functions and gives you a third function
07:19:12 <toonces> so . is a less generic $ ?
07:19:24 <napping> No, they are different
07:19:26 <Iceland_jack> no, they do different things
07:19:28 <napping> f . g = \x -> f (g x)
07:19:33 <napping> f $ x = f x
07:20:00 <Iceland_jack> like napping showed, if you have
07:20:00 <Iceland_jack>     show 5
07:20:00 <Iceland_jack> it's the same as
07:20:00 <Iceland_jack>     show $ 5
07:20:07 <napping> I think Axman6 was getting at the only reason you might confuse them
07:20:36 <napping> because (f . g . h) x = (f . g) (h x) = f (g (h x)), and because $ has lower precendence, you can equivalently write any of
07:20:53 <napping> f . g . h $ x  or f . g $ h $ x or f $ g $ h $ x
07:21:03 <toonces> ah I see
07:21:05 <toonces> thank you
07:21:15 <napping> but despite looking similar they parse into rather differently shaped trees
07:21:21 <Iceland_jack> @let plus = (+) :: Int -> Int -> Int
07:21:24 <lambdabot>  Defined.
07:21:25 <Iceland_jack> > plus 10 4
07:21:28 <lambdabot>  14
07:21:28 <Iceland_jack> > plus $ 10 $ 4
07:21:30 <lambdabot>  No instance for (GHC.Num.Num (s0 -> GHC.Types.Int))
07:21:30 <lambdabot>    arising from the literal ‘10’No instance for (GHC.Num.Num s0) arising from...
07:21:30 <lambdabot>  The type variable ‘s0’ is ambiguous
07:21:30 <lambdabot>  Note: there are several potential instances:
07:21:30 <lambdabot>    instance GHC.Num.Num GHC.Types.Double
07:21:34 <Iceland_jack> oops
07:21:43 <Iceland_jack> > (plus $ 10) $ 4
07:21:45 <lambdabot>  14
07:21:59 <Iceland_jack> nice display of the fixity I suppose :)
07:22:01 <napping> Overally . is actually does something useful and $ is just to save paraentheses
07:22:19 <Iceland_jack> yes, or if you're passing it to a higher-order function
07:22:31 <napping> id works just as well for that
07:22:43 <napping> well, slices of $ can be more useful
07:22:50 <Iceland_jack> napping: that's what I was talking about
07:23:06 <Iceland_jack> > map ($ 5) [succ, pred, id]
07:23:08 <lambdabot>  [6,4,5]
07:23:09 <napping> in particular the slice like ($ x)
07:23:54 <Iceland_jack> > map (\f -> f 5) [succ, pred, id] -- toonces: does this make sense?
07:23:56 <lambdabot>  [6,4,5]
07:24:10 <Iceland_jack> > map (\f -> f $ 5) [succ, pred, id] -- for completeness
07:24:12 <lambdabot>  [6,4,5]
07:24:39 <napping> Okay, I guess those are worth having (and lens gets away with a dozen or so type-restricted synonyms of id...)
07:24:51 <benzrf> napping: it does?
07:25:49 <napping> traverseOf, for one
07:26:11 <Iceland_jack> > (id <*> (const id)) (const succ) 4
07:26:14 <lambdabot>  5
07:26:46 <albeit> Is there a faster way to create string-types to eventually output to a file, which are composed of strings and numbers, other than printf?
07:27:16 <albeit> (Formatting is required)
07:27:36 <napping> how much formatting?
07:27:56 <albeit> Sample format string looks like "%s   Trade %4s    %7.2f %5d %11d"
07:30:06 <ReinH> byorgey: ping
07:34:38 <pmade> albeit: What about something like blaze-builder or the builder interface in bytestring or text?
07:35:39 <albeit> pmade: Haven't used them before, but are they significantly faster than printf with strings?
07:36:03 <Axman6> they're almost certainly faster than printf in Haskell
07:37:15 <albeit> Sounds good, thanks
07:37:50 <napping> you might still need printf for the numeric conversion
07:38:40 <sshine> hseg, you asked if there was a fold-filter fusion law earlier and nobody replied?
07:39:02 <albeit> Out of curiosity, is it faster to construct a string with printf, then hPutStrLn it to a file, or just directly hPrintf?
07:39:15 <sshine> hseg, I assume you ask if GHC supports it?
07:39:27 <Axman6> when you're using String, nothing is fast
07:39:38 <sshine> hseg, while I don't know that, I don't think it matters much due to laziness.
07:40:20 <rwbarton> in my experience String output is actually surprisingly efficient
07:40:51 <rwbarton> as in, not completely awful
07:42:31 <rwbarton> albeit: obviously the first one should not be faster, or hPrintf could be redefined to do just that
07:46:16 <haasn> I guess for String, “only an order of magnitude” would count as “surprisingly efficient”
07:48:53 <rwbarton> I think it was much better than that
07:49:17 <sshine> @pl \x -> (x, ())
07:49:17 <lambdabot> flip (,) ()
07:51:33 <sshine> @pl \f -> g (\e -> f e, ())
07:51:33 <lambdabot> g . flip (,) ()
07:51:51 <benzrf> n
07:57:35 * hackagebot altcomposition 0.2.1.0 - Alternative combinators for unorthodox function composition  http://hackage.haskell.org/package/altcomposition-0.2.1.0 (jcristovao)
07:57:37 * hackagebot data-easy 0.4 - Consistent set of utility functions for Maybe, Either, List, Monoids.  http://hackage.haskell.org/package/data-easy-0.4 (jcristovao)
07:57:39 * hackagebot transformers-convert 0.2.0.0 - Sensible conversions between some of the monad transformers  http://hackage.haskell.org/package/transformers-convert-0.2.0.0 (jcristovao)
08:02:36 * hackagebot system-lifted 0.2.0.1 - Lifted versions of System functions.  http://hackage.haskell.org/package/system-lifted-0.2.0.1 (jcristovao)
08:02:38 * hackagebot system-util 0.2 - Various system utils lifted to EitherT  http://hackage.haskell.org/package/system-util-0.2 (jcristovao)
08:03:47 <napping> albeit: it's almost certainly a bug if hPrintf is substantially slower that explicitly making a string and then calling hPutStr(Ln) yourself
08:04:19 <albeit> Okay, I haven't actually tested anything, I was just wondering
08:05:34 <napping> It's not necessarily any faster, but it really shouldn't be slower
08:07:36 * hackagebot stm-conduit 2.5.0 - Introduces conduits to channels, and promotes using  conduits concurrently.  http://hackage.haskell.org/package/stm-conduit-2.5.0 (ClarkGaebel)
08:09:12 <rwbarton> haasn: for instance, just comparing "main = mapM_ print [1..10000000]" to a C program using printf, it is already only ~5 times slower
08:10:00 <albeit> Why "already only"? Is that faster than you would expect?
08:10:02 <vanila> Why is haskell so slow?
08:10:18 <rwbarton> I am just responding to  <haasn> I guess for String, “only an order of magnitude” would count as “surprisingly efficient”
08:10:34 <mmachenry1> vanila: Maybe Haskell just woke up.
08:10:58 <Maior> vanila: do you just sit in channels to troll them? the Django stuff yesterday about the master/slave stuff was unsubtle
08:11:16 <Maior> (for a flexible value of yesterday that means "some days in the recent past")
08:11:41 <mmachenry> Maior: I guess I *was* born yesterday ;)
08:11:45 <napping> Is there an easy way to expand unicode ligature characters (I really just need "ff" and "ffi", guess I could hardcode them)
08:12:09 <Maior> mmachenry: :P
08:12:35 <napping> Data.Text.ICU.Normalize probably does it somehow
08:14:20 <absence> has it been decided when the applicative monad proposal will hit ghc head? anytime soon, or closer to 7.10 release?
08:15:40 <Maior> absence: ooh got a link handy?
08:15:51 <vanila> Maior: Since you're ignoring my PM I'll say it here: that was very rude and unfair of you
08:16:31 <Maior> vanila: I have PMs from non-friends disabled
08:16:31 <ion> {-# LANGUAGE ﬃ #-}
08:17:03 <Maior> vanila: meanwhile, I stand by it as a valid question from the data I have
08:17:29 <vanila> Maior, move discussion to PM
08:17:40 <Maior> I'll pass
08:19:20 <mmachenry> Maior: It's not really a valid question yet. I don't have your data and your question is underspecified. Unless I missed something which is possible, I lost network a moment ago.
08:19:27 <absence> Maior: http://www.haskell.org/haskellwiki/Functor-Applicative-Monad_Proposal
08:19:44 <ion> vanila: Pastebin your code and we can try to figure out why it’s too slow. Otherwise the question can only be answered with mu.
08:19:59 <rwbarton> absence: there is no scheduling of when things hit GHC HEAD in my experience. either someone gets around to it, or not
08:20:10 <Maior> absence: cheers
08:20:33 <rwbarton> absence: there's some recent discussion of how part of AMP (adding join to Monad) interacts with roles  https://ghc.haskell.org/trac/ghc/ticket/9123
08:21:04 <absence> rwbarton: interesting, thanks!
08:21:08 <Maior> mmachenry: I don't think you missed anything, fair point re data though (it's publicly logged, I'll have a look)
08:24:34 <mmachenry> vanila: According to the data I have (The programming languages benchmarks game, a reasonably popular site) Haskell is about #11, faster than Java, Perl, PHP, Python, Lisp, Ruby, and Scala, to name a few.
08:25:15 <mmachenry> vanila: If you're having trouble with a particular program we could help. But we simply can't answer "why is haskell so slow" because apparently it's not.
08:26:23 <napping> "NFKD"/"NFKC" seem to work on ligatures - only pulling them appart
08:27:39 * hackagebot data-concurrent-queue 0.1.0.0 - A Library for directional queues  http://hackage.haskell.org/package/data-concurrent-queue-0.1.0.0 (georgerogers42)
08:30:05 <absence> rwbarton: aw, sad news. i was looking forward to defining monad instances by implementing join instead of bind
08:32:39 * hackagebot data-concurrent-queue 0.1.1.0 - A Library for directional queues  http://hackage.haskell.org/package/data-concurrent-queue-0.1.1.0 (georgerogers42)
08:42:40 * hackagebot data-concurrent-queue 0.3.0.0 - A Library for directional queues  http://hackage.haskell.org/package/data-concurrent-queue-0.3.0.0 (georgerogers42)
08:47:41 * hackagebot format-status 0.1.0.2 - A utility for writing the date to dzen2.  http://hackage.haskell.org/package/format-status-0.1.0.2 (georgerogers42)
08:58:00 <tanmaig> Hi all. Is there a Yesod Persistent function to fetch multiple entities at once with their keys
08:58:23 <tanmaig> Something like a getList
08:58:23 <tanmaig> ?
09:00:24 <Flonk> Has anyone ever needed the generic list functions?
09:00:29 <Flonk> :t genericReplicate
09:00:30 <lambdabot> Integral i => i -> a -> [a]
09:02:13 <glguy> Flonk: It's pretty rare
09:02:42 * hackagebot format-status 0.1.2.3 - A utility for writing the date to dzen2.  http://hackage.haskell.org/package/format-status-0.1.2.3 (georgerogers42)
09:03:13 <glguy> Flonk: It could be useful if you're using lazy natural numbers or some other exotic type that benefits from the details of its implementation
09:04:36 <Flonk> glguy: hmm.. kind of weird to see them in the standard lib then
09:05:12 <l4u_c> Normally how much time does it take for recompiling a little change in an yesod hello world?
09:07:43 * hackagebot format-status 0.1.2.4 - A utility for writing the date to dzen2.  http://hackage.haskell.org/package/format-status-0.1.2.4 (georgerogers42)
09:07:43 <`^_^v> there is no normal time for compiling something
09:08:57 <bartavelle> am I not looking properly, or is network-address the only package that lets you define subnets and check if an IP is part of it ?
09:09:10 <l4u_c> It took 10s. Is there something wrong?
09:09:16 <bartavelle> because this package is unmaintained, and the mask is opposite of what is conventional
09:10:31 <l4u_c> It might be related to the outdated attoparsec package referenced in yesod platform?
09:11:08 <bartavelle> ah ther's network-ip
09:11:37 <toonces> alright I need a little bit of help here. Trying to list the first n primes. 'divides' check whether x devides (mod) any number in xs http://lpaste.net/8842879243424628736 . Where is the error?
09:13:22 <shapr> vanila: Seriously, be nice, or else
09:13:32 <vanila> http://pastebin.com/qx9d44rj
09:16:46 <vanila> byorgey, PM?
09:18:16 <ion> vanila: Private messaging random people is considered rude.
09:19:26 <vanila> is everyone just trying to make me feel as unwelcome and hated as possible today? :(
09:19:33 <hyPiRion> ion: Wouldn't that entirely depend on what you mean by "random" and what your intent is?
09:20:08 <shapr> vanila: I'd suggest a bunch of sleep, a bunch of exercise, and some really good food.
09:20:31 <ion> vanila: I asked you rather nicely to pastebin the code you’re having performance problems with.
09:20:48 <jfischoff> shapr: ?
09:22:18 <Maior> toonces: meanwhile, I can't really offer much direct help, beyond the suggestion that I find starting with easily verifiable long-form functions to be an incredibly useful technique
09:22:45 * hackagebot cartel 0.10.0.0 - Specify your Cabal files in Haskell  http://hackage.haskell.org/package/cartel-0.10.0.0 (OmariNorman)
09:23:44 <glguy> toonces: foldl can't return partial results
09:23:52 <Maior> toonces: so I <3 recursive solutions where I'd just be defining the base case (first prime, 2) then a function of type [Int] -> Int that takes a list of primes and gives the next prime
09:24:06 <Maior> toonces: which shouldn't be too hard to get right (famous last words)
09:24:09 <glguy> toonces: so it won't return until all the numbers are processed
09:24:23 <Maior> ...ok those are also good points
09:24:44 <glguy> toonces: Try rewriting your primes function as a right fold which produces values as early as possible
09:24:55 <glguy> toonces: rather than building up a large accumulator
09:24:55 <toonces> glguy: that might explain why it loaded my memory to 100% when I ran it
09:25:18 <jfischoff> vanila: I hope you do feel welcome here in the future :)
09:26:36 <Maior> toonces: apologies, I assumed the problem was correctness; fwiw in future it's generally good to include the exact problem you experience (foolish of me to assume "gives wrong answers" too, but yeah)
09:27:13 <toonces> well it _was_ correctness until I just for the fun of it removed the type restriction line
09:27:20 <toonces> it compiled but the result was awful
09:29:51 <toonces> i usually have no problems coming up with an idea for a solution to a problem, but the whole typing stuff regularly gives me headaches
09:30:41 <Maior> toonces: interesting, howso?
09:31:11 <Maior> toonces: my personal experience has been that the typing stuff catches my fail before I usually realise it, but obviously ymmv
09:31:43 <toonces> well I guess you can't have one without the other, but usually i write code that makes sense but then have to spend hours finding the type restrictions, the solution of which seems totally unintuitive to me
09:32:31 <toonces> i guess that's either a sign of bad code or a misunderstanding of the language
09:32:58 <cloudhead> is it possible to have cabal compile all my .hs files, even if they're not all imported in Main.hs?
09:33:02 <c_wraith> toonces: the thing is, about 99% of what haskell's type checker rejects would be bugs at runtime if it didn't reject them.
09:33:22 <c_wraith> toonces: Do you prefer chasing down bugs at runtime instead?
09:33:44 <toonces> c_wraith: it's not that i'm complaining ;) it's just that i have a hard time dealing with it
09:33:50 <TallerGhostWalt> anyone ran into "unknown symbol `pushCostCentre'"
09:34:19 <TallerGhostWalt> when profiling
09:34:38 <c_wraith> TallerGhostWalt: as output from your debugger, or as a crash from the program?
09:35:21 <TallerGhostWalt> c_wraith: during build
09:35:23 <glguy> toonces: If you're in the market for inefficient prime number generation, check out this one. ^_^ http://lpaste.net/8842879243424628736 This is a bit more explicit about how it lazily produces values
09:35:37 <TallerGhostWalt> ghc: dist/dist-sandbox-302f3dd8/build/alarmstate/alarmstate-tmp/AlarmState/LogConfig.o: unknown symbol `pushCostCentre'
09:35:48 <c_wraith> TallerGhostWalt: did you install GHC from debian or something?
09:35:55 <TallerGhostWalt> no
09:35:59 <pjdelport> toonces: There's also a whole bunch of stuff on http://www.haskell.org/haskellwiki/Prime_numbers
09:36:11 <TallerGhostWalt> i've profiled stuff before
09:36:28 <c_wraith> have you changed to a new version of GHC since then?
09:36:41 <TallerGhostWalt> no, 7.6.3
09:36:51 <c_wraith> That's baffling then.
09:37:02 <TallerGhostWalt> agreed
09:37:27 <TallerGhostWalt> well, how about seg faults in acid state? anyone have that (it's why I was installing prof libs)
09:37:46 <TallerGhostWalt> or alternate way of getting a stack trace?
09:38:12 <c_wraith> for segfaults, I've had some luck running a normal build in gdb, then getting a backtrace when it crashes
09:38:21 <c_wraith> that at least tells me if it's crashing in a native call or not
09:38:39 <TallerGhostWalt> yeah, that sounds like a plan
09:38:48 <TallerGhostWalt> so frustrating
09:38:55 <c_wraith> of course, if it's not crashing in a native call, all that tells you is *something* is corrupting memory, but not what
09:39:44 <TallerGhostWalt> right, I have been running strace
09:39:50 <TallerGhostWalt> it looks like an out of bounds
09:40:50 <c_wraith> well, those unsafe* functions for array/vector access are certainly capable of corrupting memory or directly segfaulting
09:41:26 <TallerGhostWalt> I did a search through the acid-state library and saw an unsafeCoerce and an unsafeAt
09:41:35 <TallerGhostWalt> that was it though (least with github search)
09:41:49 <c_wraith> unsafeAt can easily be an out of bounds index
09:41:55 <joelteon> what's the definition for strength, again?
09:42:12 <c_wraith> (a, f b) -> f (a, b), iirc
09:43:28 <int-e> @type uncurry (fmap . (,))
09:43:30 <lambdabot> Functor f => (a, f a1) -> f (a, a1)
09:43:46 <dino-> I need to parse some date strings that look like "May 29th, 2014" and I'm having problems with forming a pattern for Data.Time.Format.parseTime that can handle the th or nd or similar. Is there anyway to express "any two characters here" or something?
09:44:08 <Taneb> My copy of Parallel and Concurrent Haskell arrived :)
09:44:16 <Maior> nice
09:44:21 <dino-> Without, you know, pre-processing the strings to strip those out
09:44:30 <luite> anyone else in Budapest for BudHac?
09:44:39 <c_wraith> The unsafe* functions in vector are why I laughed when I saw claims that an SSL implementation in haskell wouldn't be vulnerable to something like heartbleed. An implementation focusing on performance would use the unsafe functions, and therefore be just as vulnerable.
09:45:53 <Maior> c_wraith: I've half a mind to try a safe implementation and see how it performs though...
09:46:17 <Maior> c_wraith: 'cause like, I'd prefer safe to fast...
09:46:25 <c_wraith> It'd be *slow*
09:46:41 <c_wraith> and probably vulnerable to a half-dozen timing attacks, too
09:47:12 <c_wraith> I think rust is a far better choice of language for something like that - or at least will be, when it's done.
09:48:06 <Maior> c_wraith: fair enough
09:48:21 <napping> c_wraith: there are other options for those sorts of checks, if someone was seriously trying
09:48:47 <c_wraith> like the liquid haskell thing that was just posted?
09:48:50 <shapr> luite: will you be at Hac Boston?
09:49:02 <napping> that, and other type level tricks that don't need a separate checker
09:49:09 <mirpa> data E = A | B | C deriving (Enum, Ord, Eq)... Is such kind of data type represented as simple integer after compilation?
09:49:14 <TallerGhostWalt> yeah safe, unsafe... right now I just want an error better than "Segmentation fault"
09:49:16 <TallerGhostWalt> lol
09:50:43 <napping> http://okmij.org/ftp/Haskell/types.html#branding
09:50:51 <luite> shapr: so far not very likely :)
09:51:36 <napping> and you certainly wouldn't use unsafe stuff for simply parsing weird protocol packets like ping, which is what gave you heartbleed
09:51:56 <napping> nothing in the core crypto, just using unsafe junk all over the place where the performance was probably pretty negligible
09:52:12 <shapr> luite: aw, too bad
09:52:41 <rwbarton> mirpa: no
09:52:48 * hackagebot ap-reflect 0.1.0.0 - Partial evaluation reflection a la simple-reflect.  http://hackage.haskell.org/package/ap-reflect-0.1.0.0 (NickolayKudasov)
09:52:51 <rwbarton> not in the way you might think
09:53:16 <napping> For simple memory safety, even something as simple as a newtype wrapper to guard construction of buffers of at least 256 bytes, paired with an unsafeIndex wrapper that only takes Word8 would go pretty far
09:54:05 <napping> but yes, rust looks like it should end up being quite suitable for lots of these sorts of things
09:54:53 <napping> The pointer branding stuff would probably go quite a lot more smoothly with type level integers and other fanciness that came about since that note
09:56:02 <rwbarton> mirpa: for one thing a value of type E might be a yet-to-be-evaluated expression
09:57:18 <mirpa> rwbarton: and if I make it strict/ubox it?
09:59:18 <hmax_> Can someone help me? I can't understand what :~/ or :~? mean here: https://github.com/supki/libjenkins/blob/5ce8edf01b94facfe5b18f828a8ce4efbbaafcec/src/Jenkins/Rest/Method.hs#L65
09:59:38 <Iceland_jack> hmax_: custom constructor probably
09:59:45 <Iceland_jack> yup
10:00:02 <hmax_> Iceland_jack, can you give me some keywords to read about that?
10:00:11 <rwbarton> mirpa, there are no unboxed sum types
10:00:15 <Iceland_jack> hmax_: It's exactly the same as 'Empty' and 'Text'
10:00:19 <Iceland_jack> only it's an operator
10:00:25 <hmax_> oh
10:00:32 <hmax_> you can do that
10:00:33 <Iceland_jack> think (:)
10:00:34 <Iceland_jack> yes
10:00:34 <hmax_> dammit
10:00:38 <Iceland_jack> if it starts with a colon
10:01:08 <Iceland_jack> you often see it like this
10:01:08 <Iceland_jack>     data Exp a where
10:01:08 <Iceland_jack>       Lit  :: Int                -> Exp Int
10:01:08 <Iceland_jack>       (:+) :: Exp Int -> Exp Int -> Exp Int
10:01:18 <Iceland_jack> then you can write
10:01:18 <Iceland_jack>     Lit 5 :+ Lit 10 :: Exp Int
10:01:51 <hmax_> is that somehow related to kinds or type families?
10:01:57 <Iceland_jack> no
10:01:57 <Iceland_jack> You could just as well name it
10:01:57 <Iceland_jack>     Add :: Exp Int -> Exp Int -> Exp Int
10:02:00 <Iceland_jack> and use it
10:02:04 <Iceland_jack>     Add (Lit 5) (Lit 10) :: Exp Int
10:02:25 <Iceland_jack> Or 'Lit 5 `Add` Lit 10 :: Exp Int', it's just a run-of-the-mill data constructor
10:02:43 <Iceland_jack> just like True, False, [], Just, ... only it's infix and binary
10:02:57 <hmax_> thanks
10:03:05 <Iceland_jack> no prob
10:03:47 <Iceland_jack> It might be clearer using non-GADT style declaration
10:03:48 <Iceland_jack>     data Exp = Lit Int | Exp :+ Exp | Exp :* Exp | …
10:05:31 <Iceland_jack> hmax_: Not to put too fine a point on it but you can see later in the source that they pattern match on it like you'd match on the pattern 'x:xs' or 'Just x'
10:05:31 <Iceland_jack>     render Empty     = ""
10:05:31 <Iceland_jack>     …
10:05:31 <Iceland_jack>     render (x :~? y) = render x `question` render y
10:05:52 <Iceland_jack> ⟨eof⟩
10:05:55 <hmax_> Iceland_jack, yeah, I didn't quite understood that either
10:05:58 <hmax_> but now it's clear
10:06:05 <hmax_> thanks to your explanation :)
10:06:23 <Iceland_jack> hope it helped!
10:06:23 <hmax_> though it's way too layered, i think
10:06:30 <Iceland_jack> the explanation?
10:06:39 <hmax_> no, source code
10:06:42 <hmax_> of the lib
10:06:45 <Iceland_jack> haha, that too
10:06:49 <Iceland_jack> I'm in a rambling mood
10:06:58 <hmax_> =)
10:17:05 <rwbarton> the vector source is dizzying
10:17:17 <rwbarton> where does it actually do the work of allocating a new mutable unboxed vector?
10:20:49 <rwbarton> oh I found it, in Data.Vector.Primitive.Mutable
10:27:06 <rwbarton> c_wraith: even worse, 'new' for unboxed mutable vectors hands you uninitialized memory
10:27:29 <rwbarton> without even claiming to be unsafe
10:35:36 <JokerDoomWork> What's the best lib for working with Strings in Haskell?
10:35:55 <JokerDoomWork> Is it ByteString and Lazy.ByteString?
10:36:28 <rwbarton> ByteString is for byte strings
10:36:29 <Iceland_jack> Data.Text for general string processing
10:36:30 <napping> Text is best for text
10:36:42 <Iceland_jack> ByteString is for byte (wait for it) strings :)
10:36:49 <napping> lots of things use String
10:36:51 <rwbarton> Iceland_jack: sorry, I didn't wait for it.
10:36:58 <Iceland_jack> bah!
10:37:36 <bitemyapp> JokerDoomWork: ByteString undecorated is strict, Lazy.ByteString is lazy.
10:37:42 <napping> For me Parsec isn't any faster working over Text than over a String read from a file, for example
10:37:47 <bitemyapp> JokerDoomWork: most stuff I've seen uses lazy bytestrings.
10:38:02 <bitemyapp> napping: I would love to know why that's the case.
10:38:21 <JokerDoomWork> bitemyapp, I ran into some crashes I couldn't figure out when I wrote a simple network server that accepted textual commands
10:38:30 <napping> Parsec's source interface is written around extracting the next Char /token anyway
10:38:38 <JokerDoomWork> When I wrote out the contents of a file to the client it would sometimes crash on certain files
10:38:52 <JokerDoomWork> When I switched to ByteString suddenly everything started working
10:39:02 <napping> And presumably the String you get from readFile is some unsafeInterleaveIO around peeking chars from nice buffers read from the OS
10:39:36 <JokerDoomWork> napping, are you presuming that that was what was causing my problems?
10:39:49 <bitemyapp> JokerDoomWork: switched to ByteString from String?
10:39:56 <geekosaur> actually I would guess encoding issues
10:39:58 <napping> no, why Parsec would be just as fast at parsing files whether you go through String or Text
10:40:14 <napping> JokerDoomWork: What kind of "crash"?
10:40:26 <JokerDoomWork> Here, I will show you the code
10:40:37 <JokerDoomWork> http://pastebin.com/5pWKPcF2
10:41:01 <JokerDoomWork> When I say crash I mean the connection would be suddenly lost, and I was unable to find anything out from eclipse
10:41:14 <JokerDoomWork> it was like a silent failure
10:41:30 <JokerDoomWork> In that pastebin, it was in the ShowFileContents
10:41:44 <JokerDoomWork> In the execution of that command that I encoutered the issue
10:41:55 <napping> Doesn't EclipseFP at least show you console output from the command?
10:42:11 <JokerDoomWork> napping, it does, but this wasn't showing anything
10:42:19 <bitemyapp> JokerDoomWork: a good guideline when you're starting out is to pause whenever you're using String and run for the hills when you're using lazy IO
10:43:03 <shelf> hello. without car / cdr, what is the haskell phrase to refer to a head and tail (x:xs)?
10:43:03 <rwbarton> I think the problem likely occurred when reading the file
10:43:10 <rwbarton> an encoding problem like geekosaur said
10:43:23 <JokerDoomWork> shelf, really?  see the head and tail commands
10:43:27 <JokerDoomWork> functions*
10:43:34 <shelf> i know how to access them. talking about the wording
10:43:40 <bitemyapp> > head [1, 2, 3]
10:43:42 <shelf> is it correct to just say head, tail
10:43:42 <lambdabot>  1
10:43:51 <shelf> or is there some cons:rest phrasing
10:43:53 <bitemyapp> shelf: I don't think anybody will misunderstand you if you say head and tail of a list.
10:44:00 <JokerDoomWork> shelf, oh yeah, they use the x:xs convention typically
10:44:02 <bitemyapp> shelf: cons is not the same thing as head.
10:44:08 <shelf> mm cons is the cell
10:44:17 <shelf> well, the constructor rather
10:44:25 <rwbarton> JokerDoomWork: readFile will assume the file it's reading is UTF-8 I think
10:44:36 <rwbarton> and decode it into a string
10:44:40 <shelf> fuck it, i'll go wtih head:tail (just bikeshedding a CFG)
10:44:42 <bitemyapp> shelf: cons is :, not head.
10:45:00 <bitemyapp> shelf: head & tail are fine, but x:xs is conventional for actual code.
10:45:04 <rwbarton> JokerDoomWork: (depending on locale and, I guess, OS)
10:45:14 <JokerDoomWork> rwbarton, it would print the contents
10:45:26 <JokerDoomWork> to the connected client, but then disconnect immediately afterwards
10:45:28 <rwbarton> if you tried to read a file that wasn't valid UTF-8 then readFile would raise an exception
10:45:31 <shelf> rather i'm just looking for a name for ListCar and ListCdr, made me realise i didn't have any equivalent to car/cdr
10:45:37 <napping> JokerDoomWork: I wouldn't be too surprised if "concat rest" gave you an invalid file name either
10:45:38 <rwbarton> oh hm
10:46:26 <napping> Overall, I suspect eclipse is swallowing some error, and you should run the program yourself from the command line or in ghci
10:46:28 <rwbarton> the whole contents?
10:46:37 <rwbarton> yes that part I agree heartily with
10:46:46 <JokerDoomWork> rwbarton, that's a good question, it seemed to be doing so, but I didn't verify
10:47:35 <napping> I'm also not sure what kind of default exception handler new threads get
10:48:04 <rwbarton> yeah, I just tested that in ghci, it works as expected there (I see the exception)
10:48:04 <napping> Can you reconnect if it stops working?
10:48:23 <JokerDoomWork> rwbarton, you tested the program?
10:48:31 <JokerDoomWork> napping, yes, new connections are still accepted
10:48:33 <JokerDoomWork> and work fine
10:48:37 <rwbarton> no I tested "forkIO undefined"
10:48:52 <rwbarton> to see whether it would print the exception message to stderr
10:48:55 <napping> ok, then you're doing something the raises an exception or otherwise crashes the handling thread
10:48:56 <rwbarton> (it did)
10:49:08 <napping> In forkIO $ body
10:49:15 <JokerDoomWork> ok, gotcha
10:49:24 <napping> try testing your body function without bothering with the server stuff
10:49:35 <napping> (promote it to top level from that where-clause first)
10:49:48 <napping> main = body stdin should do
10:50:13 <rwbarton> well printing to stdin won't go so well :)
10:50:20 <napping> oh, yeah
10:50:31 <rwbarton> can test execCmd though
10:51:16 <JokerDoomWork> I see what you are saying, run the problematic code by itself, outside of the networking context
10:51:42 <napping> It's clear the handling thread is dying somehow, without taking down the rest of the process
10:51:53 <napping> I thought the whole program died when you said "crash"
10:52:55 <JokerDoomWork> napping, sorry no, just the forked thread/process (I'm not sure of the correct term)
10:53:42 <cloudhead> is it possible to have cabal build build all source files even if they're not imported?
10:54:09 <napping> Doesn't it build all the modules you list?
11:00:02 <cloudhead> napping: the modules in build-depends?
11:00:14 <cloudhead> or is there another module list
11:00:33 <d3lxa> I'm wondering, what's this syntax: {-@ type MAValidO MA = {v:Nat | v <= (maLen MA)} @-}  first what's {-@ … @-}, does it have a special meaning for GHC? 2nd I don't understand { … | … }, a record with constraints, what's that?
11:00:44 <cloudhead> ah there's a "other-modules" key
11:00:45 <cloudhead> hmm
11:01:08 <napping> cloudhead: if you meant "exported" rather than "imported"
11:01:34 <bergmark> cloudhead: why build it if it isn't used?
11:01:47 <cloudhead> ah no I mean imported
11:01:55 <cloudhead> bergmark: because I'm the process of writing it
11:02:02 <cloudhead> I want to type-check it
11:02:09 <bitemyapp> shelf: cool.
11:02:25 <bergmark> ok, put it in other-modules or exposed-modules then
11:02:44 <napping> cloudhead: I meant exposed. If you just want to build it somehow, exposed-modules should work
11:02:50 <asmyers> d3lxa: Is that a LiquidHaskell annotation?
11:03:12 <d3lxa> asmyers: come from here http://goto.ucsd.edu/~rjhala/liquid/haskell/blog/blog/2014/05/28/pointers-gone-wild.lhs/ it's about LiquidHaskell yes
11:04:03 <asmyers> d3lxa: It's been a while since I looked at LiquidHaskell
11:04:12 <asmyers> GHC sees that as a comment {- -}
11:04:55 <cloudhead> hm exposed-modules isn't allowed under executable
11:05:02 <d3lxa> asmyers: okay, I understand now it's specific to LH, thx
11:05:18 <asmyers> d3lxa: I believe that is defining a type alias that Liquid Haskell sees
11:05:27 <napping> cloudhead: put them under a library, especially if you just want cabal to build everything somehow
11:06:01 <asmyers> d3lxa: So it's an alias that can be used in LH annotations in the same way a type Foo = Int would would be used in a Haskell type annotation.
11:06:39 <cloudhead> cool yea, that works, thanks
11:08:48 <albeit> I'm using attoparsec, and am wondering if there is anyway to make this function more efficient: http://lpaste.net/104867
11:09:17 <albeit> It works fine, but from profiling it is the slowest part of the program. It is called many many times... so any improvement would help
11:29:40 <bitemyapp> jle`: :)
11:31:26 <jle`> bitemyapp: yea, it was late and i was feeling confrontational v.v
11:31:45 <bitemyapp> jle`: I was smiling at your fav of my typography bragging. What are you referring to in this case?
11:31:53 <jle`> oh my monad rant
11:32:03 <bitemyapp> My memory is a sliding buffer and Twitter has a lot of throughput.
11:32:34 <jle`> top notch kerning tho
11:32:53 <jle`> a+ would read again
11:33:14 <bitemyapp> jle`: unaesthetic and unreadable type bothers me sometimes. A plan isn't necessarily what a monad is though.
11:33:22 <bitemyapp> "plan" would really be closer to free monads.
11:33:28 <bitemyapp> see how slippery this is?
11:33:29 <jle`> i said that it's not what it *is*
11:33:34 <bitemyapp> yeah
11:33:50 <jle`> but it can describe the semantics of most if not all monadic interfaces
11:33:51 <bitemyapp> the problem is, I wouldn't use plan for explaining anything about monads per se, I'd reserve it for Free.
11:34:01 <bitemyapp> because plan seperates execution/reduction from description.
11:34:12 <bitemyapp> but that separation exists more for Free than for Monad
11:34:24 <bitemyapp> jle`: all programs are plans.
11:34:39 <jle`> then m a is a reified plan representation
11:34:47 <bitemyapp> not all programs are monads.
11:35:06 <bitemyapp> you're being too general and not specific to monads nor describing their essence.
11:35:26 <bitemyapp> I know what you're getting at, but I don't think it's as effective as it could be.
11:35:36 <jle`> m a is a plan to produce an a; (>>=) :: m a -> (a -> m b) -> m b says "if i have a plan to produce an a, and if, given an a, i have a plan to produce a b, then i have a plan to produce a b"
11:35:51 <bitemyapp> m a doesn't ever necessarily produce a
11:36:01 <bitemyapp> does Nothing :: Maybe Int -- produce Int?
11:36:04 <bitemyapp> obviously not.
11:36:17 <bitemyapp> jle`: you may want to rethink your semantics here.
11:37:11 <bitemyapp> if you really want to entertain overly general and not very descriptive wording, you might consider "value manipulation pattern" instead of plan :)
11:37:23 <jle`> the "exeution" of the plan would be fromMaybe, or maybe
11:37:23 <bitemyapp> but when you think about what a VMP is, you'll just start thinking about the typeclassopedia.
11:37:26 <rwbarton> bitemyapp, and a plan does not always succeed
11:37:27 <bitemyapp> then you'll be back to the types.
11:37:31 <jle`> which does produce an a
11:37:38 <jle`> fromMaybe :: a -> Maybe a -> a
11:37:42 <bitemyapp> rwbarton: this is about pedagogy, not about kicking around semantics.
11:37:46 <bitemyapp> rwbarton: plan is bad pedagogy.
11:38:01 <bitemyapp> it won't communicate anything meaningful to a new person
11:38:12 <rwbarton> Meh. anyone can make whatever claims they like about pedagogy
11:38:27 <bitemyapp> for that matter, while being strictly correct, explaining it in terms of monoidal endofunctor without knowledge of functors and monoids won't either.
11:38:47 <bitemyapp> rwbarton: it's based on experience. I tried a similar explanation (plan) of monads before and it was a failure.
11:38:55 <bitemyapp> I tried multiple variations on the theme. It was bad.
11:39:25 <jle`> i still think that the plan view description provides one of the better views of the semantics behind most (>>=) implementations
11:39:38 <bitemyapp> I don't even like focusing on >>=
11:40:00 <bitemyapp> it complects things that are more specific to monads with things that are less specific to monads.
11:40:16 <bitemyapp> if they don't know what lifting is, you have to roll back to Functor anyway.
11:40:27 <bitemyapp> they don't know what return is, you have to roll back to Applicative.
11:40:34 <bitemyapp> if they don't know what a Monoid is, you have to roll back.
11:41:09 <bitemyapp> explanations that rely on a "magical >>=" where the learner can't derive >>= themselves are deeply flawed.
11:41:23 <jle`> in any case i do not believe that Monad is a concept that should be taught on its own
11:41:47 <jle`> i like seeing it as different types have an assortment of "utility functions" that make working with them easier
11:42:08 <jle`> some have (>>=) and return defined...yea, cool.  the fact that they are from Monad? who cares!
11:42:20 <jle`> except that they can use Control.Monad combinators on them
11:42:47 <jle`> (>>=) and return are useful for the specific types, and their usefulness is far beyond just the fact that they come from Monad
11:43:04 <jle`> why bother teaching what (>>=) and return "are" in general
11:43:28 <jle`> after using different types and using (>>=) and return and join etc. for different and unrelated types, at some point, it'll click on its own
11:43:31 <bitemyapp> the specific examples won't communicate the essence or rules of what they're working wth.
11:43:42 <bitemyapp> cargo-culting >>= isn't teaching, it's cargo-culting.
11:43:55 <jle`> but it's not teaching (>>=)
11:44:03 <jle`> it's teaching "this convenience function for this type"
11:45:01 <m09> if you try not to make monads special, explaining do notation gets weird for example
11:47:36 <jle`> i can use (>>=) for Maybe or for State or for Either (and even derive them on my own) without knowing what Monads are
11:47:45 <jle`> and be happily using it
11:48:22 <rwbarton> what do you mean by "derive"? what are you deriving it from?
11:48:43 <jle`> i mean i can write a Maybe a -> (a -> Maybe b) -> Maybe b function
11:48:48 <jle`> that would be useful for working with Maybe's
11:48:55 <jle`> not because it's (>>=), but just because it's useful.
11:49:14 <jle`> I can write an (s -> (a, s)) -> (a -> (s -> (b, s)) -> (s -> (b, s))
11:49:22 <jle`> not because it's (>>=), but because it's very useful
11:50:24 <bitemyapp> jle`: seen RWH's introduction to the topic
11:50:29 <bitemyapp> ...add a ? to the end of that.
11:50:47 <jle`> the end of the last line?
11:50:59 <jle`> oh
11:51:02 <jle`> yeah
11:51:35 <jle`> i just don't think that the "relation" between bindMaybe and bindState is an important thing at first, and you could be happily using both without understanding that they are linked
11:51:49 <jle`> eventually one day, you will. and at that point you are ready to read what (>>=) and return really "are"
11:51:52 <jle`> and it'll make sense
11:53:03 <_jrp_> @albeit how are you calling that function?
11:53:03 <lambdabot> Unknown command, try @list
11:55:06 <TallerGhostWalt> man I have a weird error
11:55:43 <TallerGhostWalt> file descriptor 1275 out of range for select (0--1024)
11:56:25 <geekosaur> hrm. what version of ghc is this? old enough and it'll be using an ancient I/O manager that has that problem
11:57:14 <geekosaur> newer ones should use epoll or platform equivalent (although some platforms may not have an equivalent)
12:01:30 <nadirs> hello
12:01:58 <TallerGhostWalt> 7.6.3
12:02:22 <TallerGhostWalt> it says using "threaded" fixes the problem
12:02:30 <TallerGhostWalt> when I turn that on it fixes it on 1 of the two machines
12:02:38 <TallerGhostWalt> and the other one generates a segmentation fault
12:02:45 <TallerGhostWalt> which makes me full of sadness
12:03:04 * hackagebot cartel 0.10.0.2 - Specify your Cabal files in Haskell  http://hackage.haskell.org/package/cartel-0.10.0.2 (OmariNorman)
12:03:42 <joelteon> how would I get the UTCTime that's exactly 8 weeks after a UTCTime value i already have?
12:05:33 <Rarrikins> joelteon: Probably add 8*7 to utctDay in the record (http://hackage.haskell.org/package/time-1.4.2/docs/src/Data-Time-Clock-UTC.html#UTCTime)
12:07:05 <kjanosz> is someone familiar with xmonad?
12:07:08 <kjanosz> http://lpaste.net/7298993402803126272 - what is wrong in this line? - I'm trying to summon specific app to current workspace
12:08:17 <johnw> I believe there is a #xmonad
12:08:20 <kjanosz> but unfortunately it doesn't work (does nothing - but I know that it's executed, because when I change  'ifWindow...' to 'raiseMaybe (l c) q' it works as should (switches current workspace to window's)
12:08:31 <kjanosz> yes, but I've asked question there
12:08:39 <kjanosz> and no answer :(
12:09:36 <nadirs> many of you probably heard and solved the Prisoners challenge on HackerRank (→https://www.hackerrank.com/contests/lambda-calculi-may14/challenges/prison-transport)
12:10:00 <nadirs> I've written a solution using Sets but it's got to have a terrible O complexity
12:10:31 <nadirs> because it can't even terminate in the last test (the 9th where there are 100000 inmates)
12:12:02 <nadirs> here it is, if anyone is willing to give some tips and pointing to the mistakes I've made: https://www.hackerrank.com/contests/lambda-calculi-may14/submissions/code/1548963 :)
12:13:05 * hackagebot wai-cors 0.1.3 - CORS for WAI  http://hackage.haskell.org/package/wai-cors-0.1.3 (larsk)
12:13:50 <Rarrikins> nadirs: It looks like you find the size of connected components and the cost is the sum of the ceiling square root of the component size.
12:13:52 <nadirs> (and yes: I didn't know about `partition` when I wrote `filterEither`)
12:14:47 <nadirs> Rarrikins: right
12:15:31 <davnils> just a note: Data.Graph does SCC
12:16:03 <nadirs> davnils: SCC?
12:16:32 <nadirs> ah, strongly connected component
12:17:04 <davnils> oh, and components as well
12:17:59 <davnils> don't know about efficiency/applicability but it might be useful
12:19:22 <nadirs> davnils: I definitely need to learn graphs better, as my data-structures skills are a bit limited to basically just lists, dicts and sets at the moment :(
12:19:29 <nadirs> davnils: thanks for the input
12:20:48 <Rarrikins> I'd either use the graph library or I'd use a Map Prisoner Set. For each edge, you make the union and go through and set the Prisoner's Set to the new one.
12:21:21 <bitemyapp> Rarrikins: fgl, containers, or graphs?
12:21:35 <Rarrikins> fgl
12:21:56 <shapr> bitemyapp: Do you use cassava for anything?
12:22:30 <bitemyapp> shapr: not at the moment but people have been moderately successful in the past at bribing me into doing boring things.
12:23:09 <nadirs> Rarrikins: I thought about maps+sets at first but the thing (I thought) I found out was that you needed to traverse the data twice at least
12:23:10 <shapr> I get to do boring CSV things in Python, but my workplace does not care how these boring things are completed. Thus I would rather use Haskell.
12:23:32 <bitemyapp> shapr: reasonable.
12:23:46 <Rarrikins> No, you traverse it once.
12:23:50 <bitemyapp> I wish I was in a similar situation.
12:23:51 <nadirs> ...because you might have had un-merged edges in the first traversal. I don't know if this makes sense
12:23:51 <jfischoff> I've used cassava, not a fan of the error messages, but otherwise it was fine
12:23:58 <joseph07> kjanosz: What exactly are you trying to do?
12:24:00 <bitemyapp> jfischoff: did you file a github issue?
12:24:19 <shapr> jfischoff: got any code lying around I could use to learn about cassava?
12:24:19 <bitemyapp> jfischoff: if not, would you? Or at least toss me a brief description/example if you have one handy?
12:24:31 <Rarrikins> nadirs: You merge the sets for the two neighbors to give a bigger component. Then, for each element in the new, bigger component, you set its Set to the new one.
12:24:32 <jfischoff> no, I just attoparsec things to have poor error messages
12:25:10 <Rarrikins> nadirs: Only one pass through the connections, though it has passes through the data as it merges components, so it's O(n^2).
12:25:11 <nadirs> Rarrikins: ah, makes a lot of sense, now!
12:25:12 <shapr> I'm tempted to start up a cassava-utils package with a bunch of FromField instances I'm slowly building.
12:25:12 <jfischoff> I have a answer on line somewhere that uses it, but the code I've used it for is closed source...one sec
12:25:29 <jfischoff> oh yeah then I have feeling I won't be much
12:25:32 <oisin640> I have a (somewhat subjective) question about learning Haskell: In my inexperience, it feels as though Haskell is incredibly simple to write basic things - but the more advanced topics (GADTs, type families, etc.) seem very complex. What level of proficiency does one have to meet to be considered an "average" Haskell programmer?
12:25:33 <Rarrikins> nadirs: Optimizations like checking whether the sets are equal and not merging are nice, too.
12:26:10 <bitemyapp> oisin640: I've met a lot of people who were productive in Haskell but barely understood anything beyond bare-bones basics.
12:26:18 <shapr> bitemyapp: like me!
12:26:30 <bitemyapp> oisin640: GADTs and type families aren't that bad but they can come off as a bit alien/weird if you haven't encountered the *need* for them.
12:26:33 <benbangert> oisin640: it prolly depends on what you need/want to do. I was able to get quite a ways before really even understanding monads (but could figure out how to use them)
12:26:36 <nadirs> Rarrikins: how did you get to O(n^2), though? Union is O(n logn) according to the docs
12:26:45 <absence> when a syntax tree's monad instance does variable substitution, does it follow that Data.Foldable.toList must return a list of variables?
12:26:54 <shapr> oisin640: bitemyapp hacked up a neat meta-tutorial for Haskell, one thing it says is "don't worry about the stuff you don't understand yet".
12:27:02 <nadirs> Rarrikins: plus I guess O(1) twice for the map lookups
12:27:12 <oisin640> shapr: I would love a link for that, if you have it handy!
12:27:16 <bitemyapp> oisin640: taking the first as an example, you'll probably start wanting GADTs if you have a sum type of interrelated constructors that correspond to operations and you want more type-safety, so you hide the value constructors and expose functions that have more specific types.
12:27:20 <monochrom> I was pretty productive in haskell this morning under lack of sleep all-nighter. more productive than in java under the same condition.
12:27:24 <jfischoff> absence: yes AST a -> [a]
12:27:25 <bitemyapp> oisin640: https://github.com/bitemyapp/learnhaskell
12:27:32 <shapr> oisin640: yeah, that one!
12:27:38 <bitemyapp> oisin640: learning any subject of any depth means accepting that you aren't going to know everything.
12:27:43 <bitemyapp> oisin640: this applies to history, Haskell, math, etc.
12:27:48 <shapr> I've handed that link to several people recently, it's working for at least one newbie.
12:28:03 <bitemyapp> oisin640: you just have to be at peace with that and discover for yourself what's valuable to you about Haskell and mine that for value.
12:28:04 <Rarrikins> nadirs: Ahh, maybe O(n^2 log n) then.
12:28:21 <bitemyapp> shapr: please get them to relay feedback/problems/sticking-points to me!
12:28:25 <bitemyapp> shapr: I need data   *_*
12:28:29 <kjanosz> joseph07: find (first) specific app window (using class/appName) and summon it to my active workspace
12:28:41 <oisin640> bitemyapp: To me it's easier with things like history and math, because the topics seem far more segregated. Haskell seems like an umbrella for a whole bunch of strange topics.
12:29:05 <shapr> bitemyapp: Ok, I'll ask 'em. One of them is a coworker from my other job. I'll even try to get him to show up here.
12:29:23 <bitemyapp> oisin640: it's important to remember that these topics weren't really pulled in artificially. It came from doing things in Haskell and seeing patterns, wanting more power/faculties, etc.
12:29:28 <bitemyapp> shapr: cheers, thanks :)
12:30:04 <nadirs> Rarrikins: ah, maybe n^2 is due to the n of the pass through the original list? So "data size" (i.e. n) times "union's complexity" (i.e. nlogn)?
12:30:06 <bitemyapp> oisin640: you can go through the same process yourself - manually, accelerate it by learning from others' experience, or not bother at all and just be in your own happy Haskell universe. There's a base set of knowledge that is very attainable for anybody to be productive.
12:30:44 <absence> jfischoff: so none of the typeclasses can touch e.g. constants, there has to be specific syntax tree functions for that
12:30:48 <Rarrikins> nadirs: Yes. It's more like e v log v
12:30:48 <bitemyapp> oisin640: consider: how many people are using Scala that understand existential types? See? It doesn't matter.
12:31:04 <Rarrikins> nadirs: e for edges, v for vertices.
12:31:14 <bitemyapp> oisin640: Haskell isn't unique in this regard, it's just that using Haskell means being saturated with people that love learning.
12:31:32 <Rarrikins> nadirs: Your outer loop is for edges. The inner loop is for vertices.
12:31:41 <jfischoff> absense: well none of the type classes that operate on type variables.
12:31:47 <monochrom> speaking of which, OOP is full of type-level fixed points. most OOP users don't even realize it.
12:32:28 <nadirs> Rarrikins: Thanks a lot for the help, I'm going to try your Map+Set solution and to study graph in parallel so I can try using Graph too :D
12:32:41 <Rarrikins> nadirs: No problem.
12:32:43 <jfischoff> absense: There are bunch of different typeclasses for more generic traversals, e.g. syb, (uni | multi | lens) plates, etc
12:32:52 <oisin640> bitemyapp: That's a good point and something I've noticed more in this community. I'm going to go through your link and see if I can't patch up some areas of knowledge. Thanks!
12:32:55 <monochrom> see OCaml to get some of those fixed points spelled out to you so you know you have been an advanced mathematician all along
12:33:52 <shapr> oisin640: and ask lots of questions here!
12:33:53 <johnw> Haskell rewards the interested
12:33:55 <shapr> truly
12:34:02 <shapr> Man, I tried to get johnw to learn Haskell for YEARS!
12:34:17 <shapr> Now he has a Haskell job!
12:34:19 <johnw> yeah, true
12:34:43 <johnw> starting in 2006 I think; it took 6 years to happen
12:34:48 <bitemyapp> oisin640: ping me if you get stuck or dislike anything, or even if you dropout. I want to know what causes problems for learners, please!
12:34:55 <bitemyapp> oisin640: I can help you if it's desired as well.
12:35:08 <oisin640> bitemyapp: will do
12:35:11 <bitemyapp> johnw: got a minute?
12:35:16 <johnw> bitemyapp: sure!
12:35:27 <monochrom> generally, learning rewards the interested, no?
12:35:45 <johnw> monochrom: some fields of knowledge are less deeply rewarding than others
12:35:54 <absence> jfischoff: i see! is this the "normal"/ideomatic monad instance for syntax trees, or are there other alternatives (besides not having a type parameter or monad instance at all)?
12:35:55 <johnw> all the arcana I know about C++ doesn't feel me with the glowing spirit of joy in the same way
12:36:30 <monochrom> I mean, much as I speak of java as a second-class language, when I learned it with interest, I learned something new, too
12:36:32 <shapr> I like idiomonatic code.
12:36:50 <shapr> Maybe that should be idiomonadic code?
12:37:08 <monochrom> what is idiomonatic?
12:37:44 <monochrom> oh did you see: http://www.vex.net/~trebla/tmp/moo-nad.txt
12:38:02 <shapr> monochrom: idiomatic monadic code!
12:38:08 <sx> Hi, I'm trying to implement the sobel operator in Haskell. I used accelerate to implement it, but for some reason it is very slow (like 10 seconds, where the C code needs about 300ms), does anyone have experience with it, or am I doing something wrong (maybe with ByteString)? http://codepad.org/FYkeFj6k
12:39:39 <johnw> sx: whenever tuples are involved, you have to watch out for thunk buildup
12:39:50 <johnw> turn on BangPatterns, and pattern match on ( (!a, !b, !c)... etc.
12:40:13 <johnw> although I could be wrong here, I'm not familiar with Accelerate
12:40:21 <jfischoff> absence: So people use data AST a = Var a | ... Some don't. Choices about how to deal with variable hygiene affect which way you go
12:40:46 <jfischoff> among probably other things like personal preference
12:42:23 <kjanosz> joseph07: http://lpaste.net/7298993402803126272 - I've updated code to include App ADT - other pattern matches works as expected, but I can't manage to summon app with last line
12:43:06 <kjanosz> and I have no idea how to fix it, because if I've read xmonad doc's correctly it should work (I mean doc of IfWindow and doF function)
12:43:09 <davnils> sx: try forcing all inputs before invoking the accelerate computation. then benchmark (1) setup (2) GPU computation.
12:43:50 <sx> davnils: what do you mean by "forcing"?
12:44:26 <absence> jfischoff: ok. thanks!
12:44:33 <jfischoff> np
12:44:49 <davnils> sx: dividing the program into two parts in order to evaluate the time required for both. forcing as in making sure that no thunks are left unevaluated from step (1).
12:45:10 <davnils> sx: using bangpatterns and Control.DeepSeq.force
12:45:20 <TallerGhostWalt> asked this earlier but maybe someone else has an idea :  unknown symbol `pushCostCentre'
12:45:31 <sx> davnils, alright, i'll try that, thanks
12:45:32 <TallerGhostWalt> anyone see something like that doing profiling
12:48:24 <davnils> sx: btw, I'm not sure if strictness affects the accelerate part ('sobel'). internally it builds up an AST which is transformed into C code, so probably not.
12:49:03 <davnils> (assuming that this construction is negligible)
12:49:13 <Cale> TallerGhostWalt: Out of interest, which platform are you on?
12:49:16 <h_noob> wups, back, lost my connection for a sec
12:49:23 <sx> davnils: yes, very unlikely, but i'm not sure whether lazy bytestrings could be a problem
12:49:25 <Cale> TallerGhostWalt: You've been having strange issues
12:49:39 <Cale> (at least, I haven't seen them)
12:52:29 <TallerGhostWalt> 12.04
12:52:43 <TallerGhostWalt> ubuntu
12:53:02 <TallerGhostWalt> doing a lot of system calls
12:53:05 <Cale> Okay, so it's not like you're on ARM or something
12:53:12 <TallerGhostWalt> no, not at all
12:53:12 * hackagebot yst 0.4.1 - Builds a static website from templates and data in YAML or  CSV files.  http://hackage.haskell.org/package/yst-0.4.1 (JohnMacFarlane)
12:53:31 <mateioprea> hello, can i overload (+ 5) in Haskell/
12:53:38 <mateioprea> :t (+ 5)
12:53:39 <lambdabot> Num a => a -> a
12:53:44 <ion> to do what?
12:53:46 <Cale> You can write a new instance of Num
12:53:51 <geekosaur> what do you mean by overload?
12:54:05 <mateioprea> if i make map ( + 5 ) [1,2,3]
12:54:27 <albeit> _jrp_: Ah just saw your response in regards to http://lpaste.net/104867. I'm calling it in a Parser computation, and inserting the (k,v) pair into an IntMap, and repeatedly doing that until k== a certain value
12:54:33 <mateioprea> it should write out the result of (+7) [1,2,3]
12:54:43 <mateioprea> for example
12:54:44 <TallerGhostWalt> it woudl be a lot more fun if it was something weird
12:54:47 <ion> Make a Num instance in which 1 + 5 = 8
12:55:19 <m09> in hxt, I can use hasAttr "someattr" to test for the presence of an attr. How can I test for this attr _not_ being present?
12:56:12 <kazagistar> mateioprea: first, there is no reason to do that, and second, sure you can. But seriously, you dont want to.
12:56:18 <Cale> mateioprea: It's doable by having the numbers be values of a new data type and defining addition and/or 5 strangely, but I don't know why you'd go to the trouble of having arithmetic
12:56:23 <Cale> behave poorly
12:56:26 <tsani> > let (+2) = (*2) in map (+2) [1..10]
12:56:27 <lambdabot>  <hint>:1:6: Parse error in pattern: + 2
12:56:42 <tsani> hm.
12:56:56 <mateioprea> i'm just testing things out.
12:57:18 <mateioprea> :D
12:57:27 <Cale> > let x + y = if y == 5 then x + 7 else x + y in map (+ 5) [1..10]
12:57:31 <lambdabot>  mueval-core: Time limit exceeded
12:57:36 <Cale> lol, right
12:57:45 <Cale> > let x + y = if y == 5 then x Prelude.+ 7 else x Prelude.+ y in map (+ 5) [1..10]
12:57:47 <lambdabot>  [8,9,10,11,12,13,14,15,16,17]
12:57:48 <tsani> > let 2 + 2 = 5 in 2 + 2
12:57:49 <lambdabot>  5
12:57:51 <tsani> :)
12:57:52 <mateioprea> cool
12:57:57 <mateioprea> thanks
12:58:09 <ion> To be precise, that’s not overloading of (+), that’s shadowing of (+).
12:58:15 <Cale> You can obviously just locally redefine (+), but you have to be careful if you want to use Prelude's (+)
12:58:34 <mateioprea> oh, thanks for the tip.
12:58:35 <Cale> (My first definition took forever because it was recursive)
12:58:48 <ion> “took forever” is a fun expression.
12:59:32 <kazagistar> thats why we use "returned _|_ instead" :P
12:59:51 <Cale> hehe
13:00:14 <mateioprea> thanks guys
13:00:14 <mateioprea> :D
13:01:51 <mateioprea> mmaruseacph2: nevermind that question on fb. these guys helped me out :D
13:02:38 <napping> Cale: did it take forever like ($ putStrLn "Hello World") usefully takes forever?
13:03:27 <bitemyapp> http://kukuruku.co/hub/haskell/haskell-testing-a-multithread-application
13:04:20 <quchen> napping: How does that take forever?
13:04:25 <efg> wtf http://en.wikipedia.org/wiki/Why_the_lucky_stiff
13:04:27 <Cale> quchen: as an argument
13:05:51 <napping> ($ putStrLn "Hello World") forever
13:05:51 <napping> ha
13:06:08 <quchen> Oh, I see.
13:06:36 <tac_> Is there a way in cabal to error on unused variables?
13:06:39 <tac_> error or warn I guess
13:07:03 <quchen> tac_: -Wall warns on unused variables, -Werror errors on warnings.
13:07:14 <tac_> that just goes in my blah.cabal file?
13:07:37 <TallerGhostWalt> going to try upgrading to 7.8.2 and 14.04
13:07:41 <quchen> There's a "ghc-options" field where you can specify things like these, yes.
13:07:45 <TallerGhostWalt> see if that solves all this craziness
13:07:47 <tac_> ty
13:12:38 <kazagistar> so I found a "Common Lisp" book on a shelf today, open it up to a random page (cause there might be cool functional stuff to be learned!) and the first thing I see is a section "prog", and how to use it to write gotos in your code :/
13:12:50 <bitemyapp> kazagistar: CL isn't functional
13:12:57 <_jrp_> albeit: gotcha, was wondering if you were one of the 'many' combinators
13:13:11 <bitemyapp> kazagistar: they rely prolifically on impossible-to-understand macros to try to overcome that limitation.
13:13:19 <bitemyapp> kazagistar: just look at Let Over Lambda to see what I mean.
13:13:23 <theGreat> In search of someone who can make an aimbot for an easy indie 2d game. Will pay well pm me.
13:14:29 <_jrp_> albeit: not sure if it's faster but I tried '((,) <$> (decimal <* char '=') <*> takeWhile (/= '\SOH')) `sepBy` char '\SOH'
13:14:32 <albeit> _jrp_: Nope... I basically have an 8GB file composed of those pairs, and I'm just trying to read each line of pairs into its own IntMap.
13:14:50 <albeit> _jrp_: I'll give it a shot!
13:15:01 <_jrp_> that generates a list of pairs though
13:15:17 <kazagistar> bitemyapp: are you casually suggest I read a ~50 chapter programming (text)book to see what you mean? :P
13:15:58 <monochrom> lisp people were more interested in "everything is a list!" than in functional programming
13:16:38 <quchen_> "Accidentially functional" should be a new programming paradigm.
13:17:19 <bitemyapp> kazagistar: no, don't waste your time with arrogant CL crap
13:17:24 <bitemyapp> kazagistar: just look at the chapter listing
13:17:30 <bitemyapp> kazagistar: you'll notice how most of it is about macros.
13:17:46 <bitemyapp> which is hilarious partly because it's a limited toolkit
13:18:15 <albeit> _jrp_: Yeah I need to stop gathering them when I hit a certain key, so getting them as a batch won't work.
13:18:36 <kazagistar> monochrom: these days lists (as opposed to iteratorors) are pretty terrible for hardware reasons...
13:19:01 <sveit> is there a de-facto linear algebra library? do people use repa or hmatrix for example? (I'm not afraid of possibly having to duplicate LAPACK code)
13:19:48 <sveit> on a related note, is there a good performance resource that explains in detail boxed vs unboxed types/arrays?
13:20:11 <lwm> bitemyapp: What you class CL as then? Surely you cant
13:20:21 <lwm> say it isn't a functional language ...
13:20:36 <lwm> or sorry, 'functional'
13:21:00 <davnils> sveit: check out https://github.com/wellposed
13:21:05 <bitemyapp> lwm: It's a Lisp, it has imperative/impure/mutable semantics.
13:21:14 <bitemyapp> lwm: it has a macro language. it's untyped.
13:21:36 <bitemyapp> lwm: I'm an ex-CL (and Clojure) user.
13:22:14 <monochrom> I say that CL is not functional. high-level sure. not functional. I'm measuring it against John Backus's vision.
13:22:42 <lwm> bitemyapp: gotcha, I used Clojure for a while but never made it past the teething period ...
13:23:03 <kazagistar> bitemyapp: it does have first class functions at least, right? I can tolarate mutability in my definition of functional
13:24:22 <sveit> davnils: this doesn't seem quite as mature as I would like for my own use
13:24:35 <kazagistar> but it did look from the examples that the normal method of using CL was as an imperative language with parens and neat AST-manipulating macros
13:24:42 <monochrom> John Backus's vision is a way to restrict author's cavalier power so as to regain reader's predictive power. I see Lisp as a way to add back author's cavalier power so as to lose reader's predictive power.
13:24:52 <joseph07> kjanosz: http://lpaste.net/104870
13:25:46 <joseph07> kjanosz: not beautiful but I believe that does what you want
13:26:48 <lwm> monochrom: interesting point, however I don't see that as a way to disqualify CL as not being functional
13:27:27 <tac_> I think the lens library will ultimately be the thing that turns people off from Haskell. Not because it's obtuse. But because of the huge hit in productivity when you realize some stupid dependency of yours relies on it.
13:27:31 <monochrom> what's wrong with disqualifying it as functional? I've already agreed that it's high-level.
13:27:35 <tac_> And you have to compile it for the next half hour >____>
13:27:45 <lwm> it provides functional and imperative ways of doing things
13:28:02 <kjanosz> joseph07: thank you
13:28:11 <monochrom> if you like, I can call it ultra-high-level. I can agree to that too.
13:28:43 <bitemyapp> kazagistar: function objects don't lead to equational reasoning by themselves.
13:28:53 <bitemyapp> kazagistar: no equational reasoning, no principles - no FP.
13:29:12 <tac_> The fact it's based on lambda calculus makes it functional in a very weak sense.
13:29:18 <bitemyapp> kazagistar: you could relabel the shallow "first class functions" as just Java "IExecutable" classes and nobody would know the difference.
13:29:21 <tac_> But it's a dinosaur of a language and probably is best discussed in #lisp
13:29:37 <monochrom> landin showed that even Algol 60 could be given a lambda calculus definition
13:29:49 <bitemyapp> tac_: lambda calc is lambda calc. The goalpost has moved on what makes FP back in the 70s.
13:30:39 <edwardk> tac_: funny. i've mostly heard the opposite result in terms of net productivity gain with lens
13:30:57 <edwardk> tac_: ymmv
13:31:05 <tac_> >____>
13:31:13 <monochrom> pay me money to build lens for you
13:31:31 <tac_> Part of it is probably cabal, too.
13:31:33 <glguy> Computers that take 30 minutes to compile it are already on the edge of obsolescence, so we need only wait a few weeks and that will resolve itself.
13:31:40 <kazagistar> I see functional as a scale, and a lot of it has to do with culture (how a language is used in practice) rather then direct featuresets, but my ymmv, haha
13:31:47 <bitemyapp> tac_: use lens-family-core, grump-ass.
13:32:02 <tac_> bitemyapp: I'm using whatever cabal-install wanted me to use
13:32:08 <davnils> sveit: right. I guess hblas is quite useful though. make sure to hang around in #numerical-haskell for expertise (carter and others), might be lost in the noise here.
13:32:13 <lwm> ultra high level !
13:32:13 <bitemyapp> tac_: what library pulled in lens?
13:32:20 <nisstyre> monochrom: were you talking about FP (the language)?
13:32:35 <nisstyre> way I see it Haskell is descended from languages like ISWIM and FP
13:32:38 <monochrom> I was talking about what John Backus wanted
13:32:56 <tac_> it also looks like ghc-options isn't being recognized. I wonder if cabal errors on a misplaced directive
13:34:00 <tac_> yeah, it's still ignoring my ghc-options
13:35:14 <kjanosz> joseph07: unfortunatelly, it doesn't work
13:35:26 <joseph07> kjanosz: In what sense?
13:35:27 <tac_> Does an unused monadic binding count as an unused variable for the purposes of Werror?
13:35:41 <tac_> like do x <- foo; bar;
13:35:42 <kjanosz> joseph07: no summoning
13:35:50 <monochrom> no, I think it fall under another unused category
13:36:19 <joseph07> kjanosz: Were you able to recompile successfully?
13:36:35 <kjanosz> joseph07: basically it did nothing - app was spawned eariler
13:36:37 <monochrom> it's probably under -fwarn-unused-do-bind
13:36:38 <kjanosz> yes
13:36:53 <tac_> ah ty
13:36:55 <joseph07> kjanosz: How did you invoke the function?
13:37:29 <tac_> monochrom: that's the one. Thanks again
13:37:30 <kjanosz> well, for testing purposes i've just do: run (App c l Summon q _ _ _)  = summonApp "Gnome-system-monitor"
13:37:43 <kjanosz> with gnome-system-monitor spawned earlier
13:38:23 <kjanosz> and it ofc has got 'Summon' AppType
13:39:07 <sveit> how does one decide between using a typeclass vs a new type in haskell when you have a choice?
13:39:18 <bitemyapp> sveit: newtype or new data type?
13:39:24 <sveit> new data type
13:39:26 <bitemyapp> sveit: also, they are generally orthogonal.
13:39:32 <bitemyapp> sveit: can you be more specific?
13:39:37 <joseph07> kjanosz: what is run?
13:39:37 <ion> sveit: If you’re not sure, probably not a type class.
13:39:46 <bitemyapp> sveit: also, what ion said.
13:40:03 <kjanosz> joseph07: function that is invoke when I spawn something with my own XPrompt
13:40:10 <kjanosz> that is invoked*
13:40:19 <monochrom> do you ever have a choice?
13:40:22 <sveit> sure. suppose I was trying to define points. I could have data Point = PointType1 Int | PointType2 Int, and then implement functions that pattern match
13:40:52 <sveit> or I could define a typeclass point that implements the relevant functions without pattern matching but instead by declaring something as an instance
13:40:56 <kjanosz> joseph07: ah, my fault
13:40:58 <monochrom> after you've invented a type class, now you have to invent actual instances. that means inventing types.
13:41:10 <kjanosz> I've taked wrong string from `xprop | grep WM_CLASS`
13:41:16 <kjanosz> I've taken*
13:41:26 <tac_> -fno-warn-unused-do-bind is much more aggressive than I thought it would be.
13:41:42 <kjanosz> joseph07: so, it works :) thanks again
13:41:45 <joseph07> kjanosz: ah. You know you might want to make a prompt that shows all the hint names and then summons the one you select
13:41:45 <tac_> @hoogle Monad m => m a -> m ()
13:41:47 <lambdabot> Control.Monad replicateM_ :: Monad m => Int -> m a -> m ()
13:41:47 <lambdabot> Control.Monad forever :: Monad m => m a -> m b
13:41:47 <lambdabot> Prelude sequence_ :: Monad m => [m a] -> m ()
13:41:51 <joseph07> kjanosz: yeah no problem!
13:41:54 <monochrom> it wants you to write like "_ <- getLine"
13:42:03 <tac_> monochrom: Yes, it very much does
13:42:16 <n96424> who am I?
13:42:17 <tac_> Is there a combinator that throws away the result?
13:42:22 <tac_> I think for applicative, it's void, right?
13:42:25 <tac_> @type void
13:42:27 <lambdabot> Functor f => f a -> f ()
13:42:30 <monochrom> yeah
13:42:33 <tac_> oh, that should work just fine
13:42:52 <monochrom> "_ <- getLine" is still shorter than "void getLine" :)
13:42:58 <kazagistar> typeclasses just secretly add an extra parameter that takes a record full of the instance implementation, right?
13:43:07 <johnw> kazagistar: pretty much
13:43:32 <hiptobecubic> can't you just type getline? What am I missing here
13:43:52 <joseph07> kjanosz: I made a second version which uses className ?= . It's actually a little longer but probably more idiomatic. 6 one way. http://lpaste.net/104870
13:44:11 <kjanosz> joseph07: I've rather thought about prompt that run/jumps/or summons applications taking into account their settings (spawn if not listed, otherwise jump/summon) - so one prompt to rule them all
13:44:21 <kjanosz> joseph07: thanks!
13:44:49 <davnils> hiptobecubic: GHC will warn (at least with -Wall) if you don't discard the result explicitly.
13:45:02 <geekosaur> hiptobecubic, ghc likes to warn these days about unused results
13:45:20 * geekosaur are slow
13:45:21 <hiptobecubic> in do notation? Really?
13:45:24 <geekosaur> yes
13:45:59 <Cale> Yeah -Wall turns on all sorts of silly warnings :(
13:46:24 <geekosaur> -fwarn-unused-do-bind
13:46:28 <monochrom> not as bad as hlint
13:46:46 <davnils> void is nice for uniformity though, I never use "_ <- ..."
13:46:48 <Cale> We need something like -Wsome which turns on important warnings while leaving out the ones that are probably just noise.
13:47:01 <Cale> Or just better defaults.
13:47:04 <sveit> i've made my question more specific. In the code here: http://lpaste.net/7330713441386102784 is alternative 1 (type) or alternative 2 (typeclass) better?
13:47:09 <sveit> for some value of better?
13:47:30 <hiptobecubic> What is the standard anyway? Is there a 'pep8' for haskell?
13:47:37 <monochrom> see how you have not escaped inventing your own types
13:47:51 <sveit> monochrom: I understand. I want to know which one I should do
13:48:02 <johnw> i've always found it strange that incomplete pattern matching coverage is only a warning
13:48:10 <sveit> monochrom: i am sorry for my first question being inspecific
13:48:13 <Cale> sveit: That depends on how you're going to be using these values. It's hard to imagine cases where you'd really want the first Point type.
13:48:23 <Cale> But maybe?
13:48:35 <monochrom> only you know. do you allow a list like [Point1D 3, Point2D 1 4]?
13:48:59 <Cale> If you really are conceptually working with the disjoint union of a line and a plane, then that first point type is appropriate.
13:49:18 <tac_> sweet
13:49:20 <tac_> it worked
13:49:51 <sveit> monochrom, Cale: this is of course a contrived example, my actual code is with matrices; i have things like banded matrices, diagonal matrices, etc. and I want to define optimized operations on each kind of matrix
13:50:07 <sveit> i am confused because fundamentally they are all matrices, but I also could see myself making a typeclass for them
13:50:32 <sveit> furthermore, it seems like I would be able to separate out the code better if i used typeclasses (i.e. each matrix type in its own file), but that seems like a bad reason to make a decision
13:51:06 <Cale> sveit: There are also things like type/data families
13:51:21 <Cale> Which seem appropriate to a case like that
13:52:14 <lwm> dammit, I am now questioning what I thougt a functional programming language was ...
13:52:35 <johnw> lwm: I think that a functional programming language is any language based on the lambda calculus
13:52:51 <tac_> lwm: It's whatever you want it to mean. No one, to my knowledge, has been declared king of vocabulary.
13:53:04 <sveit> Cale: but without using the GHC extensions, which do you think is the "right" choice? also considering possibly the performance impact
13:53:22 <tac_> There are tendencies for certain languages to be labeled 'functional', but it's going to be up to whoever's talking.
13:53:22 * johnw declares himself to be the King of Vocabulary
13:53:29 <Cale> sveit: Probably separate data types and a type class for operations.
13:53:38 <sveit> I am unsure because there are operations that you would /only/ do on matrices, so it seems like a typeclass is too "general" of an object?
13:53:58 <Cale> sveit: You probably want to define new classes for each of your operations.
13:54:27 <Cale> Or at least related sets of operations.
13:55:09 <sveit> Cale: so (let me know if you are not familiar with the language) does that mean I should have a separate typeclass for eigenvalue operations vs transposition/matrix addition, for example?
13:55:22 <Cale> sveit: Yeah, probably
13:55:48 <sveit> Cale: do you know how many typeclassed operations like this would affect performance?
13:55:52 <lwm> johnw tac_ : well, thatll do so, I need to form my own opinion :)
13:55:59 <Cale> sveit: They behave like additional function parameters
13:56:02 <zwer> lwm you will find that most #lips folk will agree that CL isn't functional
13:56:25 <Cale> sveit: (Foo a) => ... gets translated to FooDict a -> ...
13:56:46 <Cale> sveit: Where FooDict is a record of the typeclass operations
13:56:55 <sveit> Cale: thank you! just wondering, for my own learning, why did you decide typeclass vs new data types? so that I can apply the thinking to future problems :)
13:57:14 <zwer> it has some functional idioms but most don't consider it to be a functional programming language
13:57:44 <Cale> sveit: Well, you're probably going to want specialised algorithms which apply to specific matrix representations
13:58:12 <lwm> zwer: yes, I see from searching around the web ... news to me!
13:58:13 <Cale> sveit: It's probably going to be a lot nicer to specify those separately than to pattern match on every possible combination of types of matrix.
13:58:21 <davnils> yeah, the SPECIALIZE pragma is useful on polymorphic methods.
13:58:43 <davnils> (in addition, sorry I misread)
13:59:32 <davnils> this sounds very much like what carter is playing around with.
13:59:45 <sveit> Cale: practically that makes sense. is there also a conceptual reason that the new type is less desirable/fitting in this particular example? are these matrices not really what is thought of as a single "type"? because to me they are, so i think i am confused about types if this is not the case
14:00:22 <sveit> davnils: i will probably ask some more specific questions on numeric-haskell, but I am still learning the general language so I don't want to bother the numerics geniuses quite yet :)
14:01:05 <dino-> huh, postgresql-simple API docs not generated on Hackage
14:01:57 <Cale> sveit: Well, when you have many cases in your data declaration, it's like you're forming a disjoint union of a bunch of things. So in this case, you'd be creating a type which has many values for representing the "same" matrix.
14:02:15 <geekosaur> if hackage doesn't have libraries needed for FFI bindings installed it will fail to generate documentation
14:03:04 <Cale> sveit: Any algorithm which treats the same matrix represented in two different ways differently by accident is incorrect.
14:04:01 <Cale> While you can still have those problems when keeping the values in separate types, perhaps it's a little easier to get things right when you only have one representation to worry about at a time.
14:05:04 <_jrp_> dino_: I noticed that last week too, 4.2.1 has docs if you need it
14:05:37 <_jrp_> dino_: I mean 0.4.2.1
14:05:42 <dino-> _jrp_: Thank you. I ended up going to the source code.
14:05:58 <dino-> Turns out, formatted nicely in there as well
14:07:21 <sveit> Cale: ok, so a good heuristic is many alternatives <=> probably better as a typeclass?
14:07:43 <sveit> Cale: but conceptually the views might be compatible
14:07:44 <Cale> sveit: There's actually one more option
14:08:35 <Cale> This probably isn't so appropriate here, but you could decide on a fixed interface for matrices, and define a matrix to be the implementations of those operations.
14:09:14 <Cale> Then the matter of how matrices are stored becomes a concern for whatever function builds the record of operations
14:09:49 <Cale> It often doesn't work out so well for cases where you want to deal with pairs of things though.
14:09:55 <Cale> (like multiplication)
14:10:52 <Cale> But that is a really good way to go when you have many alternatives, and expect to have more in the future
14:12:41 <masak> how do I ask "is this Day a Friday" in Haskell? I find nothing about it in http://www.haskell.org/ghc/docs/latest/html/libraries/time/Data-Time-Calendar.html
14:13:49 <johnw> masak: Data.Time.Calendar.WeekDate
14:15:26 <masak> johnw: wow, how come I didn't find that one here: http://www.haskell.org/ghc/docs/latest/html/libraries/time/Data-Time.html ?
14:15:47 <masak> oh, it's here: http://www.haskell.org/ghc/docs/latest/html/libraries/time/index.html
14:15:50 <johnw> it's just not re-exported
14:15:51 <masak> nevermind :)
14:16:24 <davnils> the time package is a mess.. but time is complex, I guess.
14:16:38 <sveit> Cale, davnils : thanks for all the advice!
14:16:58 <jfischoff> does anyone else async for Async () computations, just to deal with exceptions better?
14:17:05 <johnw> jfischoff: yes
14:17:11 <johnw> jfischoff: in fact, that's what enclosed-exceptions is all about
14:17:21 <davnils> there's a blog post on that somewhere
14:17:26 <davnils> like the proper solution for exceptions
14:17:31 <kazagistar> time is easy, our way of counting it is just unneccesarily complex
14:18:11 <jfischoff> johnw: do every use them for several processing loops? If so how do you manage clean in the face of exceptions
14:18:47 <jfischoff> I ask because a made a package to manage those types of async actions, but I'm not sure if I missed a easy built way
14:27:38 <johnw> "manage clean"?
14:27:47 <johnw> ah
14:27:51 <johnw> oops, wrong window
14:30:03 <johnw> jfischoff: I don't follow yet
14:30:52 <jfischoff> johnw: my explaination or my code ... or both
14:30:57 <johnw> both
14:31:08 <johnw> "how do you manage clean in the face of exceptions"
14:31:10 <johnw> I couldn't parse that
14:31:23 <jfischoff> oh because it is a typo
14:32:28 <jfischoff> as I understand it, all of the `with` async functions let you manage a tree of threads, such that if the parent dies, the children are cleaned up
14:32:54 <johnw> right
14:33:11 <johnw> "link" can be used to establish a link between two asyncs that were created without "with"
14:33:20 <jfischoff> However, those functions themselves only return when the enclosed computations return
14:34:05 <jfischoff> ah so I guess link is the way to go
14:34:11 <johnw> :)
14:34:14 <johnw> like how I read your mind there?
14:34:15 <jfischoff> if you can't use with
14:34:21 <masak> ok. oh hai. so I'm looking for constructive criticism on this small Haskell program: https://gist.github.com/masak/abc315b79968dea31096
14:34:31 <dino-> Pipes question, I'm very green with pipes, but: I have function that's a Pipe and in the do block I tried to do a  x <- f `fmap` someMaybeValue
14:34:37 <jfischoff> oddly I saw link but I don't know why I thought it would work for my purposes
14:34:40 <masak> specifically, I'm an almost-total beginner, and I'm looking for ways to make that program more elegant.
14:34:47 <dino-> And got a lot of errors, so had to fall back for the moment on using the maybe function.
14:35:13 <johnw> masak: that's a perfectly respectable program
14:35:40 <johnw> you could use let to avoid repeating the fromGregorian call
14:35:47 <masak> oh yes.
14:36:22 <johnw> also, this is just style, but I'd write: when (weekDay == 5) putStrLn $ showGregorian (fromGregorian year month 13)
14:36:36 <johnw> also, this is just style, but I'd write: when (weekDay == 5) $ do
14:36:36 <johnw>     putStrLn $ showGregorian (fromGregorian year month 13)
14:36:46 <johnw> or maybe just delete the "do", but keep the return
14:37:02 <johnw> so that "when" blocks read a bit like they would in an imperative program
14:37:04 <johnw> totally up to you though
14:37:31 <masak> sounds like a good idea.
14:37:40 <masak> updated for your first suggestion: https://gist.github.com/masak/abc315b79968dea31096
14:37:44 <masak> already much better :)
14:37:58 <johnw> you can collapse the two lets together
14:38:03 <johnw> just s/let /    / in the second case
14:38:14 <masak> oh yes.
14:38:16 <davnils> dino-: hm.. your do-block is in an additional monad-layer. if someMaybeValue isn't monadic you should be using let. mind clarifying with types?
14:38:29 <johnw> and the outermost forM_ doesn't need the keyword "do"
14:38:32 <masak> johnw: would you align the equals signs?
14:38:50 <glguy> masak: http://lpaste.net/104875 You could try to do more in pure code
14:38:57 <johnw> sometimes I align them, depends on the moon phase
14:38:57 <glguy> only dropping into IO at the end
14:39:09 <kazagistar> separate the list and IO monad bits I think, and keep list more pure
14:39:13 <johnw> yeah, you are using forM_ here basically because you are calling putStrLn
14:39:19 <johnw> you could instead generate your list of things to print purely
14:39:24 <dino-> davnils: Well, someMaybeValue :: Maybe LocalTime so I thought cool, I can lift something..
14:39:25 <masak> glguy: nice!
14:39:40 <masak> glguy: yes, I was pondering something like that, but not really sure how to express it.
14:39:52 <jfischoff> johnw: I think the thing I am struggling with, is I want some Async's that will be created in my first `IO ()` to depend on the result of calling async with that first action. I'll add code with that doesn't make sense.
14:40:26 <jfischoff> I sort of want async version of the `with` functions I guess
14:40:28 <masak> johnw, glguy: thank you both.
14:41:11 <dino-> davnils: But yeah, I don't get what's happening yet with the Pipe do expression that this code is in
14:41:27 <jfischoff> withAsync' :: IO a -> (Async a -> IO b) -> Async b , or something like that
14:41:39 <davnils> dino-: then you're probably looking for let x = fmap f someMaybeValue
14:41:45 <jfischoff> no not that
14:41:48 <jfischoff> :p
14:41:59 <johnw> masak: here's another way to write it: https://gist.github.com/562268e473a665eb144c
14:42:10 <stephenjudkins> does this look like something yall would be into? https://github.com/Jell/method_not_missing
14:42:11 <davnils> dino-: recall that pipes add a monadic layer on your existing stack (which might be Identitity).
14:42:12 <stephenjudkins> [ducks]
14:42:31 <dino-> davnils: You did it. What a silly mistake!
14:42:42 <dino-> I needed to leave it in Maybe monad.
14:42:47 <dino-> Not pull it out with <-
14:42:59 <dino-> davnils: thank you
14:43:13 <masak> johnw: ooh.
14:43:33 <masak> johnw: I'm now working on a version where I extract that last condition into its own function.
14:43:59 <johnw> that would be cool too.  isFriday
14:44:32 <masak> currently calling it hasFridayThirteenth :: Int -> Int -> Bool
14:44:53 <johnw> ah, I see what you mean
14:46:51 <davnils> stephenjudkins: cool concept! I guess a combination with djinn-style inference would be really useful.
14:47:50 <davnils> @djinn (a,b) -> a
14:47:51 <lambdabot> f (a, _) = a
14:48:37 <kazagistar> MonadPlus do notation version friday 13: http://lpaste.net/8376977576454782976
14:48:38 <masak> hm, no, going with isFriday :)
14:48:43 <stephenjudkins> davnils: haha, i was just appalled and hoping other people would enjoy the link. in seriousness, the "fill in the blanks" idris-mode is the closest i've seen to something like that
14:48:47 <stephenjudkins> never heard of djinn before
14:48:54 <masak> (because I need date in the comprehension)
14:49:05 <johnw> kazagistar: isn't that just the list comprehension laid out in do-notation?
14:49:30 <johnw> i think the two desugared should even be identical
14:49:36 <kazagistar> johnw: it is, but I just learned how that works, and I think it is really cool, so... um yeah
14:49:43 <johnw> :)
14:50:03 <bitemyapp> kazagistar: next, figure out what parts of list comprehension work with just applicative and which need monad.
14:51:25 <wormmd> If I do map (+1) [1..5], am I just currying the (+) operator with 1 and each number in the list?
14:51:42 <johnw> you're partially applying the (+) operator with 1
14:51:44 <wormmd> So I partially apply 1 to (+), and map finishes the partial application for me?
14:52:01 <kazagistar> bitemyapp: well, guard does not even work with Monad and requires MonadPlus, right? but yeah, I am just looking into Alternative and whatnot :P
14:52:26 <bitemyapp> kazagistar: *nod*
14:52:51 <jfischoff> johnw: you inspired me to find a better solution: RecursiveDo + link2
14:53:21 <wormmd> :t >
14:53:26 <lambdabot> parse error on input ‘>’
14:53:27 <jfischoff> I was struggling with how to feed the parent Async back to the function I pass to async ;P
14:53:29 <wormmd> :t (>)
14:53:32 <lambdabot> Ord a => a -> a -> Bool
14:53:52 <jfischoff> let me hpaste and you can see if there is a simplier way
14:54:17 <prinsen> Im trying to use MaybeT, how do I convert a IO (Maybe Int) to MaybeT IO Int?
14:54:19 <bitemyapp> kazagistar: properly it's MonadPlus, I think it was fail originally. *Should* be zero tho.
14:54:41 <wormmd> @let posi = filter (>0) xs
14:54:42 <lambdabot>  .L.hs:158:21:
14:54:42 <lambdabot>      Not in scope: ‘xs’
14:54:42 <lambdabot>      Perhaps you meant one of these:
14:54:42 <lambdabot>        ‘x’ (imported from Debug.SimpleReflect),
14:54:42 <lambdabot>        ‘s’ (imported from Debug.SimpleReflect)
14:55:04 <johnw> prinsen: just wrap it in the MaybeT constructro
14:55:07 <davnils> :t MaybeT
14:55:09 <lambdabot> Not in scope: data constructor ‘MaybeT’
14:55:14 <davnils> yep
14:55:18 <johnw> prinsen: MaybeT ioActionReturningMaybe
14:55:25 <wormmd> let xs = [-2..2] in filter (>0) xs
14:55:37 <wormmd> >let xs = [-2..2] in filter (>0) xs
14:55:44 <davnils> :t Control.Trans.Maybe.MaybeT
14:55:45 <lambdabot>     Not in scope: data constructor ‘Control.Trans.Maybe.MaybeT’
14:56:04 <wormmd> @define posi = filter (>0) xs
14:56:05 <lambdabot>  .L.hs:158:21:
14:56:05 <lambdabot>      Not in scope: ‘xs’
14:56:05 <lambdabot>      Perhaps you meant one of these:
14:56:05 <lambdabot>        ‘x’ (imported from Debug.SimpleReflect),
14:56:05 <lambdabot>        ‘s’ (imported from Debug.SimpleReflect)
14:56:11 <wormmd> !define posi = filter (>0) xs
14:56:24 <wormmd> Bah, never mind :)
14:57:37 <l0cust> hey, weird problem with haskell mode. When I try to load a module into inferior-haskell-mode, emacs seems to go into some sort of trance. C-g gets me out
14:57:41 <l0cust> This is only when I run M-x inferior-haskell-load-file. It works just fine if I use :l in the haskell buffer
14:57:52 <jfischoff> johnw: is this idiomatic? http://lpaste.net/104876
14:59:14 <davnils> stephenjudkins: idris seems interesting from the code-generation perspective. djinn is fairly limited (no support for recursive constructs afaik). still waiting for this in haskell, really a killer feature.
14:59:55 <johnw> jfischoff: you are throwing away the Async () on links 10 and 11
15:00:05 <johnw> meaning the exceptions will just get swallowed
15:00:17 <bitemyapp> @djinn [a] -> a
15:00:18 <lambdabot> Error: Undefined type []
15:00:19 <johnw> you should at least: link =<< async (link parent >> ...)
15:00:37 * bitemyapp looks around uneasily
15:00:45 <bitemyapp> @djinn f :: [a] -> a
15:00:46 <lambdabot> Cannot parse command
15:00:46 <johnw> hmm
15:00:48 <bitemyapp> ...
15:00:55 <bitemyapp> @djinn a -> a
15:00:55 <lambdabot> f a = a
15:00:56 <davnils> cons etc isn't defined
15:00:57 <johnw> i wonder if that will result in an infinite loop or not
15:00:59 <jfischoff> johnw: well if I kill the parent the children die
15:01:02 <davnils> @djinn a
15:01:02 <lambdabot> -- f cannot be realized.
15:01:02 <l0cust> I get this when debug-on-quit is enabled http://pastebin.com/5kgMqu53
15:01:05 <jfischoff> I think
15:01:11 <jfischoff> err no wait
15:01:12 <bitemyapp> @djinn a -> a -> a
15:01:12 <lambdabot> f _ a = a
15:01:14 <johnw> jfischoff: and if the children die, what do you want to have happen?
15:01:20 <bitemyapp> hahahaha, what a smart-ass answer.
15:01:23 <jfischoff> ha
15:01:27 <bitemyapp> @djinn Monoid a => a -> a -> a
15:01:27 <lambdabot> Error: Class not found: Monoid
15:01:48 <jfischoff> yeah they do, but the code doesn't really prove it
15:02:17 <johnw> in general, ignoring the return value of async means you shouldn't be using async but just forkIO
15:02:28 <jfischoff> okay I updated the code with somethat shows the children will die
15:02:33 <johnw> unless you want just exception swallowing
15:02:41 <jfischoff> I realized that
15:03:06 <jfischoff> I what was struggling with was how to link something, to a Async that didn't exist yet
15:03:12 <jfischoff> and then mdo occured to me
15:03:22 <johnw> right
15:03:22 <jfischoff> which works AFAICT
15:03:33 <johnw> that's a clever way to tie the knot here
15:03:53 <jfischoff> and ... completely invalidates my little library AFAICT :)
15:04:09 <jfischoff> since that was what I was trying to overcome
15:05:13 <davnils> stephenjudkins: btw, do you know idris gives you all candidate realisations/implementations? is it only capable of handling the unique case? (I'm new to idris).
15:06:10 <stephenjudkins> davnils: i only dabble, and can't remember exactly. for the things that djinn can do, i think it does basically the same thing
15:06:28 <jfischoff> ultimately for my purposes I don't care about the actual exception, I just want to make sure I never have zombie threads
15:06:36 <davnils> ah, right. thanks!
15:07:09 <stephenjudkins> the unique thing it offers is filling in the types/proofs that are missing to make something work
15:07:57 <stephenjudkins> example I saw, the guy was trying to zip together two vectors that were equal length
15:08:44 <stephenjudkins> he needed to add a couple steps to prove that this was the case, and the tab completion popped up the exact signature that was necessary to do so.
15:11:18 <kazagistar> well, here is the video I saw in Idris where he verifies monoid laws, and it does some pretty neat magic: https://www.youtube.com/watch?v=P82dqVrS8ik
15:13:53 <gauthier> any clue about this WinMain compile issue: http://lpaste.net/104878 ? I'm installing postgre-simple on windows machine
15:14:30 <pilu> hi, i can't figure out how to make a parser of an expression like (2+3)*5
15:14:52 <acowley> Trying to convince the type checker about equality constraints is so painful
15:15:57 <davnils> pilu: depends on your parser. use precedence and associativity to handle + and *.
15:16:49 <davnils> pilu: easy to handle if you're using happy for example (%left '+' \n %left '*')
15:17:14 <davnils> pilu: you can also modify your grammar to incorporate these modifications.
15:18:29 * hackagebot xmonad-contrib-gpl 0.12.1 - Third party extensions for xmonad  http://hackage.haskell.org/package/xmonad-contrib-gpl-0.12.1 (DmitryBogatov)
15:18:36 <davnils> pilu: concrete example in "Introduction to automata theory[..]" hopcroft et al page 211
15:19:03 <pilu> davnils: ok, i'll check it
15:20:17 <acowley> pilu: Have you looked at parsec?
15:20:24 <acowley> pilu: Or attoparsec?
15:20:47 <pilu> i can't use libraries, it must be only haskell
15:21:05 <monochrom> what have you been taught?
15:22:18 <acowley> Yes, monochrom's question is the most important one at this juncture
15:23:27 <kmspriyatham> I wish to upgrade ghc from 7.6.3 (from the haskell platform) to 7.8.2, how do I do that without breaking things?
15:24:00 <monochrom> you can put it in a different directory like /usr/local/ghc-7.8.2 and play with PATH
15:24:16 <johnw> kmspriyatham: hsenv will let you sandbox 7.8.2 until you're sure it works
15:24:19 <acowley> I like to use to brew to juggle versions of GHC
15:24:26 <johnw> I use Nix to juggle GHCs
15:24:40 <monochrom> I use a shell function to play with PATH
15:24:45 <benzrf> i can juggle 10 ghs at once B)
15:24:47 <peddie> I use GNU stow
15:24:56 <bitemyapp> kmspriyatham: you can install the binary distribution into your home and only add it to path to a particular shell.
15:25:00 <johnw> edsko uses stow too I think
15:25:11 <bitemyapp> kmspriyatham: then delete if you decide you don't like you. hs-env can use the bindist.
15:28:04 <kmspriyatham> can I use yesod with hsenv? @johnw
15:28:30 <johnw> indeed you can
15:28:39 <johnw> in fact, that's what the yesod author does :)
15:29:58 <kmspriyatham> @johnw thanks :)
15:29:59 <lambdabot> Not enough privileges
15:30:14 <johnw> am I @johnw?
15:30:16 <johnw> do I have ops on?
15:30:32 <Clint> you do not
15:30:51 <acowley> you look authoritative
15:30:54 --- mode: ChanServ set +o johnw
15:30:56 <monochrom> you're on twitter @johnw
15:30:57 <johnw> RAWR!!!!!!
15:31:01 --- mode: johnw set -o johnw
15:31:16 <johnw> on twitter I'm @jwiegley
15:31:22 <johnw> johnw is a hard nick to get
15:31:28 <bitemyapp> gasp. We know your whole name now.
15:31:33 <johnw> actually, in my family, jwiegley is hard to get too
15:31:41 <johnw> I have to compete with Jenny, Janice and Jeff
15:31:42 <bitemyapp> if we say it three times do you turn into a pile of category theory papers?
15:31:53 <acowley> I'm going to append #haskell to everything I say here just to confuse/clarify
15:31:53 <monochrom> yikes :)
15:32:15 <monochrom> I ♥ haskell @#haskell
15:32:25 <acowley> So @jwiegley is like the family account?
15:32:33 <johnw> no, it just means I got to twitter first
15:32:40 <johnw> if you ever see jwwiegley talking to you, it means I was too slow on that service
15:32:48 <acowley> I can't find the +1 button next to your post @monochrom
15:33:06 <monochrom> hehe
15:34:49 <ion> kazagistar: That was a nice video, thanks.
15:42:35 <ik_> Hi, I'm just reading about applicative functors. Would I be right in thinking that the only use for them is when there are functions inside a functor and there is a need to map those functions over another functor?
15:42:48 <ik_> just want to get my thinking verified
15:42:59 <johnw> avoid the term "inside a functor"
15:43:01 <johnw> functors are not values
15:43:55 <johnw> if you have [f] and [x], you can apply the f to x as [f x] using <*>
15:43:59 <johnw> for the case of lists
15:44:23 <ik_> ok thanks
15:44:38 <johnw> what's interesting about this: if you are using some custom functor F, you get to examine F(f) and F(x) before you decide what application means
15:44:41 <jfischoff> although you will probably expect ZipList functionality
15:44:45 <c_wraith> I'm starting to think that "natural transformation" might really be the best way to describe fmap.  "it changes that type variable. Whatever that means depends on the type"
15:44:52 <[swift]> johnw: as an aside, what is a more correct way to phrase "inside a functor"?
15:45:23 <[swift]> i understand your comment but i realized i don't actually know the right terminology (or at least i can't bring it to mind right now)
15:45:31 <ik_> me too
15:45:40 <hpc> there's not really a good term for it
15:45:41 <ik_> i would like to know how to phrase it properly
15:45:42 <absence> hm, seems cabal init guesses build-depends based on imports in existing code. is it possible to make it update that guess when i've added more imports to the source?
15:45:42 <acowley> I don't actually think there is a good way of saying that
15:45:44 <quchen> "fmap over a functorial value", where a functorial value is defined as "something you can fmap over". Or something like that.
15:45:48 <c_wraith> There isn't a good way.
15:45:55 <johnw> [swift]: I'd probably say "an embedded value", where the type of that value is an instance of Applicative
15:46:01 <jfischoff> absence: not with cabal as it is today
15:46:03 <acowley> absence: No
15:46:11 <[swift]> johnw: thanks, that sounds good
15:47:06 <absence> ah, too bad
15:47:13 <jfischoff> I wish there was something more light weight then the reader monad for configuration data
15:47:29 <johnw> jfischoff: depends on how principled you want to be
15:47:36 <jfischoff> not that much
15:47:38 <johnw> io-storage is very lightweight, but relies on unsafePerformIO
15:48:04 <johnw> (in order to store it's value dictionary in a "global")
15:48:11 <jfischoff> yeah
15:49:22 <acowley> jfischoff: Yeah, it's a pain point. I tend to have a bunch of regular functions that take their configuration as regular parameters, then call those functions from a higher-level piece that has a Reader-like configuration type.
15:49:59 <jfischoff> I have a deep call stack of functions that are threading config to the children right now
15:50:05 <ik_> I'm a bit confused over the type of this fmap, can someone break it down for me please: :t fmap (\x y z -> x + y / z) [3,4,5,6]
15:50:18 <ik_> the type sig is : fmap (\x y z -> x + y / z) [3,4,5,6] :: (Fractional a) => [a -> a -> a]
15:50:20 <jfischoff> but the transition is annoying, bleh ReaderT it is
15:50:33 <quchen> ik_: What's the type of (\x y z -> x + y / z)?
15:50:43 <quchen> What's the type of [3,4,5,6]?
15:50:56 <quchen> What's the type of fmap? :-)
15:51:38 <quchen> (It might help to mention that Fractional is a subclass of Num.)
15:52:03 <alphonse23> does anyone know what a multiplex-demultiplex object streams is?
15:53:38 <alphonse23> I guess not..
15:54:34 <cin> jfischoff, there's also implicitparams with constraint kinds
15:54:53 <jfischoff> what would that look like?
15:55:00 <acowley> danger
15:55:08 <jfischoff> :)
15:55:40 <jfischoff> I gave up on the `reflection` approach. Didn't seem any better
15:55:49 <cin> http://www.reddit.com/r/haskell/comments/1pa00v/pattern_for_native_library_initialization/cd0jzzb?context=3
15:55:50 <jfischoff> If you are in a monad that is
15:56:17 <johnw> reflection mainly has one really compelling use case
15:56:21 <linman24> hi, haskell-mode-hook is not working in emacs. everytime i return in emacs, it calls the help
15:56:37 <jfischoff> johnw: oh?
15:56:38 <johnw> passing environment data into an instance definition when you don't have Monad
15:56:41 <linman24> anyone ever ahd that issue?
15:56:57 <jfischoff> oh right, yeah no monad, I can see that
15:57:15 <johnw> if you have monad, or you can sneak an argument in somehow, then you can get your environment in there
15:57:34 <johnw> the classic example is modulus arithmetic
15:57:37 <acowley> linman24: I think I've seen that when I didn't an indent mode set
15:57:40 <johnw> where you want to get the modulus into Num
15:57:46 * jfischoff nods
15:58:03 <jfischoff> the original example from the oleg paper
15:58:26 <johnw> yeah, and there's one other optimization case to be made for reflection, where you use it to avoid turning pure code into monadic code solely to introduce Reader
15:58:42 <linman24> acowley: this is in my .emacs (add-hook 'haskell-mode-hook 'turn-on-haskell-indentation)
15:58:47 <johnw> because reflection doesn't turn everything into function calls the way that Reader does
15:59:06 <johnw> but other than that, especially if your use of Reader is really ReaderT, reflection buys you nothing and costs you simplicity
15:59:16 <jfischoff> acowley: what would be the downside of using chris's implicit params approach?
15:59:32 <johnw> I think oleg's paper covers the badnesses of implicit params
15:59:32 <jfischoff> johnw: that's what I noticed
15:59:39 <linman24> acowley: that is where it should go and how to fix, correct?
15:59:59 <acowley> jfischoff: I don't know, but when you say "implicit parameter" I hear "danger zone"
16:00:06 <jfischoff> right
16:00:13 <cin> this seems to  be the only case implicit params should be useful for
16:00:25 <acowley> linman24: I think so, I use 'turn-on-haskell-indent but I guess what you have would be fine
16:00:28 <cin> if not this, implicit params has generally failed as a feature
16:00:42 <enthropy> jfischoff:   class (?x :: Int) => C a -- is banned, but the equivalent with reflection isn't
16:00:44 <acowley> linman24: I know I've seen just that problem, but I can't remember how I fixed it. On some occasions I've just reinstalled haskell-mode, tbh
16:01:02 <jfischoff> yeah I'm trying to undestand how it can cause a problem in this instance
16:03:53 <johnw> I keep trying to figure out why "inside a functor" makes so much sense and yet is so wrong.  To be accurate it would be "inside a value of a type constructed by a type constructor which is a functor".  the type (Maybe :: * -> *) is the Functor, not Maybe Int :: * or the value Just 10.
16:04:25 <johnw> and yet, we all know what we mean :)
16:04:38 <jfischoff> johnw: It makes sense in terms of the syntax
16:05:04 <jfischoff> In F a , a is child node of F
16:05:12 <jfischoff> syntically
16:05:15 <johnw> I've switched how I read fmap f [1,2,3] from "maps f over [1,2,3]" to "maps f to a function over lists, then applies that to [1,2,3]"
16:05:16 <jfischoff> err :p
16:05:17 <cin> johnw, similar to "the X monad"
16:05:55 <acowley> Also visually if you draw your categories with discrete objects
16:06:02 <glguy> Part of the issue is that "F a" need not contain or even be able to contain values of type "a" at all
16:06:12 <johnw> right
16:06:18 <glguy> so when you talk about the values "a" /inside the functor/
16:06:25 <jfischoff> cin: I can't see a problem with the implicit parameter approach for what I am doing, but I fear no one will understand my code
16:06:26 <glguy> you're only talking about a subset of them
16:06:40 <acowley> johnw: I internally say the same thing about lifting, but not the second part
16:06:54 <acowley> johnw: The important part is "Maps f to a function over lists"
16:06:59 <johnw> right
16:07:02 <acowley> What you do with that is not part of the functor
16:07:06 <johnw> (fmap f) $ [1,2,3]
16:07:07 <johnw> exactly
16:07:09 <acowley> Yeah
16:07:18 <cin> jfischoff, the  downside to implicit params seems to be that i haven't seen them used anywhere in any library of note or hear about anyone using them. do they know something we don't?
16:07:27 <acowley> Writing the right-associated parentheses on the type of fmap is the most helpful thing
16:07:39 <trap_exit> is there a channel here dedicated to #haste ?
16:07:44 <johnw> functors map types and morphisms; anything after that just looks like it is an action of the Functor
16:08:02 <trap_exit> i'm referring to https://github.com/valderman/haste-compiler
16:08:32 <acowley> The specialization of fmap to map probably causes some of the trouble
16:08:37 <acowley> It's so concrete in our minds
16:08:38 <cin> jfischoff, i'd like your code if it was as convenient and type-safe as that, though... what's your package btw (curious)?
16:09:59 <cin> acowley, what's the canonical functor example where no value is actually contained?
16:10:14 <johnw> the Const functor?
16:10:35 <cin> that's the only one i can think of, but seems pretty obscure
16:10:56 <cin> spj had to take some time to explain it
16:10:57 <glguy> State, Reader
16:11:00 <johnw> Contravariant functors don't "contain" anything
16:11:08 <enthropy> Proxy
16:11:35 <jfischoff> cin: Its a internal project. Kafka batch thing
16:14:00 <cin> glguy, State and Reader both contain values which the fmap transforms. how are those an example of a functors with no contained value?
16:14:39 <glguy> cin: No, they contain functions
16:15:29 <glguy> and those functions can return things that mention 'a', but the State doesn't "contain" any "a" values
16:16:07 <quchen> The "contain" thing is an analogy, and analogies are always "not right", but that doesn't make them wrong.
16:16:10 <startling> @quote shachaf ls
16:16:11 <lambdabot> shachaf says: <dmwit> CReal is the computable reals. <shachaf> Just like CInt is the computable integers!
16:16:17 <startling> @quote shachaf /bin/ls
16:16:17 <lambdabot> shachaf says: getLine :: IO String contains a String in the same way that /bin/ls contains a list of files
16:18:19 <cin> i think that's a narrowing of ‘contains’ outside the scope of normal discourse
16:18:30 <jfischoff> glguy: I don't see why an collection of ordered pairs or (e, a) does not contains a's
16:18:31 <acowley> The Strings are *in* the getLine?
16:18:38 <jfischoff> s/or/of
16:18:39 <cin> IO is a special case because it's the only type for whom that analogy actually fits
16:19:09 <Iceland_jack> “They're _in_ the monad?” --Zoolander
16:19:11 <glguy> jfischoff: A tuple (e,a) actually does contain a value of type e and a
16:20:12 <jfischoff> Isn't a function just ordered pairs like that tuple?
16:20:31 <acowley> I went to the Derek Zoolander School for Programmers Who Don't Type So Good and Want to Learn Haskell
16:20:32 <Iceland_jack> A set of ordered pairs with some further restructions
16:20:34 <johnw> not necessarily
16:20:46 <quchen> If you think of (a ->) as a container that is indexed by keys of type `a`, then the analogy works pretty well. The Functor/Monad then picks out one of the contained things based on a single key (the environment) for all actions.
16:20:52 <johnw> the set of ordered pairs that expresses a function is left-adjoint to the function
16:20:53 <Iceland_jack> What is this, a core language for _ANTS_?!
16:20:56 <johnw> it's not isomorphic
16:21:00 <acowley> hahahaa
16:21:21 <johnw> in that the function "forgets" what the argument value are
16:21:25 <johnw> acowley: was that directed at me? :)
16:21:53 <acowley> No that was for Iceland_jack, to you I say, classic johnw
16:21:59 <johnw> (acowley and I have been known to muse over adjunctions in the past)
16:22:38 <startling> cin: do functions 'contain' their output?
16:22:41 <cin> evalState (fmap (++"!") get) "Hello" == "Hello!", here `ge'` "contains" Hello just as in fmap (++"!") ("World","Hello") the tuple "contains" Hello. both are expressions which will yield a value to fmap, which is the operation whose perspective we're looking from
16:22:42 <startling> jfischoff: not quite.
16:24:55 <cin> startling, if i make a list structure from lambdas as in simple untyped lambda-calculus, does it not contain any values because i did it with functions?
16:25:42 <startling> cin, I don't think 'contains' makes sense in a simple untyped lambda-calculus, except perhaps as it pertains to the base types.
16:25:47 <startling> (if there are any)
16:26:07 <cin> http://en.wikipedia.org/wiki/Church_encoding#Church_pairs
16:26:25 <johnw> jfischoff: actually, If you look at that adjunction, namely ((,) a) -| ((->) a), the Monad that arises from it is the State monad. :)
16:26:40 <cin> i think you really have to cling to a strange and restrictive notion of "containing" to doubt that "first (pair a b) == a" doesn't demonstrate that "pair a b" contains a
16:27:08 <cin> but for some reason agree that (a,b) contains a
16:27:28 <acowley> johnw is laying down some good knowledge. I never think about things that way but it's a great way to tie a ribbon on things
16:27:53 <startling> cin: I think the takeaway should be "'contains' is not a good way to describe these things".
16:28:13 <cin> startling, that was a given from the outset, yes
16:29:45 <cin> startling, (my point was rather "if you're going to use 'contains', it applies equally well to tuples as functions, there's no specific accurate use of 'containing'")
16:30:16 <h_noob> "user error (Cannot create OS thread.)" what is that about?
16:30:16 <johnw> acowley: it's one of the few meaningful adjunctions you can implement in Haskell; edwardk has the code for it here: http://hackage.haskell.org/package/adjunctions-4.0.3/docs/Data-Functor-Adjunction.html
16:30:17 <startling> I don't know. datatypes are very different from functions in Haskell.
16:30:32 <startling> I think it's reasonable to say "x contains a y" -> "x has a field of type y"
16:30:32 <johnw> instance Adjunction ((,) e) ((->) e)
16:30:35 <trap_exit> what, if any, is the main weakness / shortcoming of haste ?
16:31:04 <edwardk> actually that is te only adjunction from Hask -> Hask. the others are between other categories, and just have Hask one one end
16:31:23 <johnw> Cont isn't Hask -> Hask, being self-adjoint?
16:31:23 <edwardk> all other f -| g : Hask -> Hask adjunctions are isomorphic to that one
16:31:49 <edwardk> (_ -> r) -| (_ -> r) : Hask^op -> Hask
16:31:54 <johnw> ah
16:32:07 <acowley> I can't decide how interesting that fact is
16:32:23 <acowley> Which I guess makes it good category theory
16:32:26 <edwardk> acowley: it means that 'Adjunction' is a boring class in some sense, when restricted to Functor.
16:32:26 <johnw> then decide that is _very_ interesting
16:32:28 <jfischoff> what about currying/uncurrying?
16:32:50 <edwardk> acowley: it means you can always get by with Representable and that all right adjoints in Hask behave like (->) e for some e.
16:32:57 <edwardk> and all left adjoints look like (,) e
16:33:12 <acowley> huh
16:33:12 <edwardk> (in hask) so they have a single value associated and some stuff
16:33:38 <acowley> edwardk: You are a font of wonderful tricks
16:33:44 <acowley> edwardk: So I have a challenge fo ryou
16:33:55 <edwardk> ... he says right as i'm about to fall asleep
16:33:57 <johnw> curry/uncurry is (_,a) -| ((->) a)
16:34:09 <acowley> edwardk: I have a type "f t" and I want to be polymorphic in f, so I say (forall f. f t)
16:34:09 <johnw> see http://www.cs.ox.ac.uk/ralf.hinze/SSGIP10/AdjointFolds.pdf, page 17
16:34:14 <edwardk> flip/flip is (-> r) -| (-> r)
16:34:21 <acowley> edwardk: But my "t" here may involve a type function applied to "f"
16:34:27 <jfischoff> oh right
16:34:44 <acowley> edwardk: But I want to write something like (forall f. f t) -> Fun t
16:34:58 <acowley> But instead, I have to write, (forall f t. f (Unfun t)) -> t
16:34:59 <edwardk> acowley: that is a strange beast
16:35:03 <acowley> Which works
16:35:09 <acowley> but it leaves "t" too free
16:35:24 <acowley> when I really want it to be pinned down by my "f t" value
16:35:33 <acowley> edwardk: You'll enjoy the reason for it
16:35:37 <edwardk> i don't see how t can involve f given the quantifier you want
16:36:08 <acowley> edwardk: It's a consequence of finally tagless relying on representation polymorphism to implicitly support a "var" type constructor
16:36:39 <acowley> edwardk: So, with finally tagless, you might have (forall repr. repr Int) -> ConcreteType
16:36:51 <edwardk> sure
16:36:52 <acowley> edwardk: and the forall is important to prevent funny business with functions
16:37:11 <acowley> edwardk: But once you want to vary types based on the representation you hit this sticky patch
16:37:14 <edwardk> so why does the type of the arg have to care about the choice of repr?
16:37:50 <acowley> edwardk: In my case, I have things like Array types where a code generator just has a Proxy-like value, while the Haskell interpretation is a Vector
16:38:15 <edwardk> you can make class Repr repr t | repr -> t where bah :: repr Int -> t -- of course
16:38:50 <acowley> I haven't tried that!
16:38:54 <acowley> I never reach for fundeps
16:39:11 <johnw> I was just about to suggest fundeps, but deleted my words thinking it was too obvious :)
16:39:30 <acowley> I think years ago I decided I preferred TF and became set in my ways
16:39:32 <edwardk> but you're going to get something that depends on 'f' again, so you'll need to ork with it entirely CPSd
16:39:59 <edwardk> just like you would before with an appropriate TF
16:39:59 <acowley> Yeah, that won't do me any good
16:40:33 <edwardk>  you _have_ to turn your thinking inside out and CPS here
16:40:43 <edwardk> lest you wind up with naked existential types, etc.
16:41:05 <acowley> Yes, my coding of late has been positively scandalous
16:41:23 <acowley> I've gotten it quite far along while maintaining decency
16:41:31 <dolio> Perhaps it would be helpful to think about how you would do this with a data type representation, because "finally tagless" is just Church encoding of indexed types (i.e. GADTs).
16:41:39 <edwardk> dolio++
16:42:16 <acowley> So, if I were doing this with a data type, I'd be doing this PHOAS and have an extra parameter for variable references
16:42:17 <dolio> In which case, it sounds like you'll find it doesnt' make any sense, because it doesn't make much sense for the data type to have pieces "depending" on some arbitrary other type you'll eliminate into.
16:42:17 <edwardk> ignoring finally tagless and writing out what it looks like as a data type is great advice
16:42:31 <acowley> I have that, too
16:44:01 <dolio> Or, something about the syntax tree needs to change or something.
16:44:04 <acowley> The only pesky inference problem I have is that I generate these functions whose return type is m (), but when I use them I need to be explicit about the ()
16:46:58 <acowley> I guess I may not have explained it well, as it does work as it is. I'll just see about getting the code presentable with the current design.
16:47:56 * enthropy doesn't think fundeps really win until you have more than one ->
16:48:48 <h_noob> hmmm why would I be unable to forkOS?  I think I have the right ghc options
16:49:02 <h_noob> I get "Cannot create OS thread."
16:49:03 <dolio> acowley: Is the problem that some expressions have types like 'Expr (Vector a)', and you want a haskInterpreter that, when called with that, yields a Vector a, but compiler yields VectorMachineCode a or something?
16:49:30 <acowley> dolio: Yes, I think so
16:49:32 <dolio> 'compiler' being the name of a function that 'interprets' the expression tree into compiled code.
16:50:24 <dolio> And the problem is that you can't do 'type family Compiler a = ...' and then make Compiler an instance of Repr?
16:51:02 <dolio> type instance Compiler (Vector a) = VectorMachineCode a
16:51:04 <dolio> Something like that.
16:51:27 <acowley> Yes, that is what I do
16:51:33 <acowley> That part is fine
16:51:51 <dolio> I guess I still don't understand the not-fine part. :)
16:52:13 <acowley> But now if I want to yield the VectorMachineCode using that overloading of compiler
16:52:54 <acowley> Okay, I'll try again
16:53:04 <acowley> I'm doing a terrible job here
16:53:24 <acowley> What I would write generically would have a type like, expr (Vector expr a)
16:53:38 <acowley> where Vector in this case is a data family indexed by the representation type
16:53:45 <acowley> let's not call it Vector
16:53:47 <acowley> Vec
16:54:04 <acowley> so I have a program whose type is expr (Vec expr a)
16:54:04 <kmspriyatham> the haskell platform webpage gives a script to patch ghc to use gcc instead of clang, how do I do the same thing in hsenv?
16:54:19 <acowley> Now I want to provide a compiler overload to produce machine code
16:54:38 <acowley> I could write, compileMachineCode :: MachineCode (Vec MachineCode a)
16:55:10 <acowley> oh dammit this example is too easy actually
16:55:36 <acowley> dolio: I need to write up a more useful example :/
16:55:44 <dolio> Heh.
16:56:47 <dolio> I don't see why Vec would take expr as a parameter. I'd probably need to see something written up all at once.
16:57:20 <acowley> dolio: So, for the MachineCode representation of things, Vec MachineCode would just have some other types that guide code generation
16:57:35 <acowley> dolio: For a Haskell representation, Vec Haskell would be an actual Vector
16:57:59 <acowley> dolio: So that when I have a function in this language, I can run it in Haskell or spit out code for it
16:59:03 <dolio> Why is that handled in the expressions, instead of the result of the interpreter or something?
16:59:41 <dolio> Result type.
16:59:55 <acowley> There is no interpreter for the finally tagless version
17:00:39 <dolio> You said earlier you needed '(forall f. f (U t)) -> t' instead of '(forall f. f t) -> F t'. Why?
17:01:15 <dolio> I assume that's actually something like '(forall f. f (U f t)) -> t' ?
17:01:16 <acowley> Because t mentions f, I can't have F t outside the forall
17:02:01 <acowley> Well, the U there actually knows about a particular f so doesn't take it as a parameter
17:02:15 <dolio> So that U Haskell t = Vector t, and U MachineCode t = something else?
17:03:09 <acowley> dolio: Yes
17:03:14 <acowley> dolio: That is, you are right
17:03:36 <kmspriyatham> when installing yesod in hsenv, I get this error "ld: library not found for -lHStext-1.1.1.3-ghc7.8.2". How can I fix it? I use mavericks
17:03:41 <acowley> dolio: U takes t that has been specialized, and "re-specializes" it using f
17:04:35 <dolio> I guess another question is... Are there expressions that can only be used to generate machine code, and not Haskell values?
17:04:39 <dolio> Is that the intention?
17:04:42 <acowley> type instance U f (Vec MachineCode a) = Vec f a
17:04:47 <acowley> something like that
17:04:50 <acowley> dolio: No
17:05:15 <acowley> dolio: for now the overlap is total
17:06:21 <dolio> Then I don't really understand why you can't do without indexing your expression tree by things that don't involve the representation, and just interpret into something that specializes the representation of certain types.
17:08:41 <oisin640> I'm having some trouble converting Exercise 1, Question 2 in the following assignment: http://www.seas.upenn.edu/~cis194/hw/04-higher-order.pdf I think that I should make an infinite list with iterate - but I'm not quite sure how to fold over that list?
17:10:35 <bitemyapp> oisin640: why are you using an infinite list?
17:10:45 <bitemyapp> oh, the hint.
17:10:51 <oisin640> ^
17:10:53 <dolio> I think I double negated there.
17:11:01 <bitemyapp> oisin640: do the simple thing first.
17:11:07 <bitemyapp> oisin640: rewrite it into a fold.
17:12:16 <bitemyapp> oisin640: err, sorry.
17:12:31 <bitemyapp> oisin640: I was looking at Q1. I'm being useless today. I'll leave you alone until I've eaten :P
17:12:43 <oisin640> bitemyapp: No problems :D
17:14:29 <jle`> boycott ($)
17:14:32 <jle`> never again
17:14:43 <bitemyapp> jle`: hahahahaha, why?
17:14:58 <jle`> except with do notation on the right hand
17:15:06 <jle`> because it just looks ugly :/
17:15:10 <jle`> and is hardly ever necessary
17:15:17 <quchen> bracket foo bar $ \h -> …
17:15:23 <jle`> ok fine
17:15:26 <acowley> dolio: Okay, so if we have an array indexing feature, then we'd have a class with a method like index :: expr (Vec a) -> expr Int -> expr a. If the language also has functions, this can become expr (Vec a -> Int -> a). So you're saying that something like the Haskell implementation of expr should be something like Haskell a = Haskell (ToHaskTypes a)
17:15:26 <quchen> Add that to your exceptions list ;-)
17:15:27 <Iceland_jack> · would be nicer, and more in line with what's sed in Principia M.
17:15:29 <acowley> dolio: is that right?
17:15:50 <Iceland_jack>     putStrLn · "Hello," ++ " " ++ "World!" -- :)
17:15:53 <jle`> $ inspires flashbacks from perl and even assembly
17:15:57 <Iceland_jack> *what's used
17:16:33 <jle`> even those pipe-like stuff might be better
17:16:34 <dolio> acowley: Yes, I think. Although usually the way people write things, Haskell would just be identity.
17:16:37 <jle`> <| or |>
17:16:43 <sx> quchen, jle`: i wonder why $ is necessary at all in such expressions? shouldn't this be not ambiguous: bracket foo bar \h -> ...
17:17:03 <Iceland_jack> sx: It could be like that
17:17:11 <acowley> dolio: Identity is what I have now, but then the type expr (Vec a -> Int -> a) is the problem
17:17:14 <dolio> And MachineCode would be something else where MachineCode (Vector a) doesn't actually involve a Haskell vector.
17:17:47 <acowley> dolio: Yeah, okay
17:17:48 <jle`> sx: it's just the way it was decided
17:18:07 <jle`> same for things like flip runState s0 $ do ...
17:18:33 <sx> but i see no advantage in doing it like this
17:19:05 <jle`> :/
17:19:12 <jle`> :(
17:19:20 <Iceland_jack> I think Idris has the right idea with having a thin veil of syntactic sugar over those things
17:19:35 <acowley> dolio: I end up wanting to use non-standard Haskell types so I can tag more information to the types
17:19:52 <Iceland_jack> compared to things like
17:19:53 <Iceland_jack>     for x in xs:
17:19:53 <Iceland_jack> which I find far more pleasant
17:20:04 <acowley> dolio: I will give this a shot, thanks for the patience!
17:20:18 <dolio> No problem. I feel like I didn't help much.
17:20:50 <acowley> dolio: Either way, you were patient! :)
17:21:00 <dolio> Heh.
17:21:06 <acowley> dolio: And I'll see if I can unstupid my code
17:27:04 <benzrf> acowley: good luck w/ that m8
17:27:44 <acowley> benzrf: It's actually just some elisp I trigger with M-x chat-with-dolio-and-unstupid-my-stuff
17:40:22 <pavonia> @djinn [a -> b] -> a -> [b]
17:40:24 <lambdabot> Error: Undefined type []
17:40:53 <Guest36262> ihi
17:41:25 <spott> when I define a type to be "a" in a type signature, then "a" means "any type", right?  unless I have defined a type named "a" somewhere else?
17:41:49 <Rarrikins> spott: Unless you've constrained it.
17:42:07 <Rarrikins> spott: For example (Num a) => a -> a constrains it to be in the Num typeclass.
17:43:14 <spott> ok.  => can be read as "in the following expression" right?  so if I have a type signature with an a in it, but no "=>", then it isn't constrained?
17:43:32 <spott> Couldn't match expected type `a' with actual type `LispVal'
17:43:33 <spott>       `a' is a rigid type variable bound by
17:43:33 <spott>           the type signature for
17:43:34 <spott> for example:
17:43:42 <spott> *s/://g
17:44:12 <benzrf> spott: whoa you picked the same type name as me
17:44:34 <spott> benzrf: LispVal?  I didn't pick it
17:44:36 <benzrf> oh
17:44:42 <Rarrikins> Is there some contest going on?
17:44:43 <benzrf> spott: what is thia from?
17:44:45 <benzrf> *this
17:44:57 <spott> I'm running through the "write a scheme in 48 hours"
17:45:00 <benzrf> oh
17:45:09 <benzrf> i guess it has the same type name as i picked d:
17:45:25 <benzrf> spott: but yes, type vars are implicitly forall'd
17:45:26 <spott> it makes sense :)
17:46:01 <spott> so how am I getting that error?
17:46:06 <sx> spott: small types are type variables, it does not mean they are arbitrary, it just means the function is available for every type a (parametric polymorphism)
17:46:33 <sx> spott: if you could show a little more of your source code, that would help
17:46:49 <spott> I'm mostly confused because that error doesn't seem like it should be able to happen... "a" should be able to be "LispVal"
17:46:59 <benzrf> spott: it's too general
17:47:08 <benzrf> spott: whats the exact type youre using
17:47:18 <spott> readOrThrow :: Parser a -> String -> ThrowsError LispVal
17:47:19 <spott> readOrThrow parser input = case parse parser "lisp" input of
17:47:19 <spott>     Left err -> throwError $ Parser err
17:47:20 <spott>     Right val -> return val
17:47:26 <spott> that is the function that is throwing the error
17:47:32 <benzrf> spott: ok
17:47:34 <spott> specifically on the "return val" part
17:47:36 <benzrf> your problem is this:
17:47:46 <benzrf> haskell implicitly quantifies 'a' with 'forall'
17:47:48 <benzrf> like so:
17:47:59 <benzrf> readOrThrow :: forall a. Parser a -> String -> ThrowsError LispVal
17:48:17 <spott> ok
17:48:40 <benzrf> but you are using the result of the parser in somethign that requires a LispVal
17:48:47 <benzrf> so it's not actually as general as you are claiming
17:49:03 <benzrf> you want:
17:49:10 <benzrf> readOrThrow :: Parser LispVal -> String -> ThrowsError LispVal
17:50:06 <benzrf> spott: here's the key bit
17:50:16 <sx> spott: i think the error comes from parse, you expect it to be constained to: parse :: Parser a -> String -> Either .. LispVal
17:50:18 <benzrf> spott: take "foo"
17:50:30 <benzrf> spott: *the value "foo"
17:50:34 <benzrf> :t id
17:50:44 <lambdabot> a -> a
17:50:46 <benzrf> spott: the 'a' in id can be unified with String
17:50:52 <benzrf> spott: but the type of "foo" is *not* 'a'
17:51:07 <benzrf> > "foo" :: a
17:51:11 <lambdabot>  mueval-core: Time limit exceeded
17:51:15 <benzrf> yo what
17:51:17 <benzrf> > "foo" :: a
17:51:23 <lambdabot>  mueval-core: Time limit exceeded
17:51:23 <lambdabot>  mueval: ExitFailure 1
17:51:25 <benzrf> ....
17:51:28 <benzrf> > "foo" :: a
17:51:34 <lambdabot>  mueval-core: Time limit exceeded
17:51:34 <benzrf> spott: ok nvm
17:51:47 <benzrf> spott: think of it like this
17:52:01 <benzrf> spott: if i say 'func arg = something', then i can put any value in
17:52:06 <benzrf> spott: but the value that i put in is not 'arg'
17:52:11 <benzrf> it's an actual value
17:52:23 <benzrf> spott: similarly, the 'a' in id's type can become any type
17:52:26 <spott> benzrf: that makes sense.  the problem is that Parser a can be Parser LispVal or Parser [LispVal]
17:52:44 <benzrf> but things that can be the a are not actually 'a'
17:52:51 <benzrf> spott: how?
17:53:01 <benzrf> spott: what operations can you perform on both a LispVal and a [LispVal]
17:53:25 <benzrf> spott: oic
17:53:29 <spott> benzrf: the two calling functions pass either a Parser LispVal or a Parser [LispVal] to readOrThrow
17:53:29 <benzrf> spott: you are passing the value verbatim?
17:53:59 <benzrf> spott: ok, you're artificially constraining what the input Parser type can be by declaring that its output must be a LispVal
17:54:06 <benzrf> spott: basically you're contradicting yourself
17:54:08 <benzrf> readOrThrow :: Parser a -> String -> ThrowsError LispVal
17:54:19 <benzrf> spott: you're returning the result of the parse
17:54:29 <benzrf> spott: therefore, haskell infers that the parser must result in a LispVal
17:54:37 <spott> yea... I found the error
17:54:41 <benzrf> spott: ok :-)
17:55:07 <spott> I shouldn't be returning a "ThrowsError LispVal", I should be returning a "ThrowsError a"
17:55:13 <benzrf> spott: correct :-)
17:55:42 <spott> thanks for the help
17:55:44 <benzrf> np
17:56:09 <benzrf> > "foo"
17:56:15 <lambdabot>  mueval-core: Time limit exceeded
17:56:19 <benzrf> lambdabot: restart
17:56:34 <sx> it's interesting that many haskell beginners confuse parametric polymorphism with dynamic typing
17:57:12 <Iceland_jack> I haven't really noticed that confusion
17:57:17 <bitemyapp> me either.
17:57:34 <bitemyapp> sx: are you thinking perhaps of adhoc polymorphism?
17:57:36 <Iceland_jack> If anything the ad-hoc polymorphism would be closer
17:57:38 <bitemyapp> or sum types?
17:59:30 <sx> well, many of my fellow students did this, when first learning haskell, maybe because most of them had scheme before :)
18:00:22 <fread2282> @pl \i -> runSupplyM (f $ a i) (i + 1)
18:00:22 <lambdabot> ap (runSupplyM . f . a) (1 +)
18:00:34 <benzrf> :t runSupplyM
18:00:36 <lambdabot> Not in scope: ‘runSupplyM’
18:00:54 <benzrf> fread2282: just write a function in a where clause
18:00:55 <benzrf> :u
18:01:20 <fread2282> benzrf: ?
18:02:15 <benzrf> fread2282: whatever where helper i = runSupplyM (f $ a i) (i + 1)
18:07:17 <spott> sx: by dynamic typing, do you mean duck typing?
18:34:43 <fread2282> @pl showSrc s a ++ " : " ++ showTy s b
18:34:43 <lambdabot> showSrc s a ++ " : " ++ showTy s b
18:42:11 <geekosaur> fread2282, you need to specify the points to remove: \s a b -> whatever (if those are the ones)
18:42:27 <geekosaur> ...note that the result may suggest that you'd do better with a different ordering
18:43:02 <geekosaur> but in general if you want to remove more than 2 points you're better off dropping the idea, and even 2 gets dicey if used muliple times
18:43:20 <geekosaur> in this case needing to use the s twice suggests you're in trouble
18:53:28 <acowley> Is there a reason there isn't a Monoid instance for IO ()?
18:54:02 <benzrf> acowley: why should there be
18:54:10 <benzrf> oh i see what you mean interesting
18:54:14 <acowley> benzrf: Because it's unambiguous
18:54:17 <acowley> and useful
18:54:23 <benzrf> hmm
18:54:27 <acowley> I've newtyped one in several code bases at this point
18:54:36 <acowley> and keep hoping it'll appear in base
18:54:54 <benzrf> @let newtype MonadMonoid m = MonadMonoid {getMobit :: m ()}
18:54:57 <lambdabot>  Defined.
18:55:40 <benzrf> @let instance Monoid (MonadMonoid m) where mempty = return (); mappend = (>>)
18:55:42 <lambdabot>  .L.hs:162:18:
18:55:42 <lambdabot>      Couldn't match type ‘m’ with ‘()’
18:55:42 <lambdabot>        ‘m’ is a rigid type variable bound by
18:55:42 <lambdabot>            the instance declaration at .L.hs:161:10
18:55:42 <lambdabot>      Expected type: MonadMonoid m
18:55:59 <benzrf> hmmmmmmmm
18:56:34 <pjdelport> acowley: Have you seen http://www.haskell.org/pipermail/libraries/2007-March/006997.html ?
18:57:02 <acowley> pjdelport: I guess nobody responded?
18:57:12 <pjdelport> Looks like it, yeah.
18:57:27 <acowley> It stinks because it's too risk of an orphan
18:57:32 <acowley> risky
18:57:50 <pjdelport> Might be work chatting with Conal Elliott, though.
18:59:05 <benzrf> @let instance Monoid (MonadMonoid m) where mempty = MonadMonoid (return ()); mappend = (>>)
18:59:06 <lambdabot>  .L.hs:162:31:
18:59:07 <lambdabot>      No instance for (Monad m) arising from a use of ‘return’
18:59:07 <lambdabot>      Possible fix:
18:59:07 <lambdabot>        add (Monad m) to the context of the instance declaration
18:59:07 <lambdabot>      In the first argument of ‘MonadMonoid’, namely ‘(return ())’
18:59:08 <benzrf> wait shit
18:59:40 <benzrf> @let instance Monoid (MonadMonoid m) where mempty = MonadMonoid (return ()); mappend (MonadMonoid m1) (MonadMonoid m2) = MonadMonoid (m1 >> m2)
18:59:41 <lambdabot>  .L.hs:162:31:
18:59:41 <lambdabot>      No instance for (Monad m) arising from a use of ‘return’
18:59:41 <lambdabot>      Possible fix:
18:59:41 <lambdabot>        add (Monad m) to the context of the instance declaration
18:59:41 <lambdabot>      In the first argument of ‘MonadMonoid’, namely ‘(return ())’
18:59:48 * benzrf facepalms
18:59:58 <benzrf> @let instance Monad m => Monoid (MonadMonoid m) where mempty = MonadMonoid (return ()); mappend (MonadMonoid m1) (MonadMonoid m2) = MonadMonoid (m1 >> m2)
19:00:01 <lambdabot>  Defined.
19:00:02 <benzrf> cool
19:02:14 <haskellbeginner> Hey everyone, I'm somewhat new to Haskell, and was wondering if someone could give me some advice for implementing something
19:02:57 <pjdelport> haskellbeginner: Fire away.
19:04:17 <benzrf> with MonadMonoid mconcat becomes sequence_ !!!
19:04:45 <benzrf> :t mconcat `asAppliedTo` [MonadMonoid (putStrLn "kek")]
19:04:46 <lambdabot> [MonadMonoid IO] -> MonadMonoid IO
19:04:59 <benzrf> :t sequence_ `asAppliedTo` (putStrLn "kek")
19:05:00 <lambdabot>     Couldn't match expected type ‘[m a]’ with actual type ‘IO ()’
19:05:00 <lambdabot>     In the second argument of ‘asAppliedTo’, namely ‘(putStrLn "kek")’
19:05:00 <lambdabot>     In the expression: sequence_ `asAppliedTo` (putStrLn "kek")
19:05:01 <benzrf> :t sequence_ `asAppliedTo` [(putStrLn "kek")]
19:05:03 <lambdabot> [IO ()] -> IO ()
19:05:05 <benzrf> cool
19:05:15 <haskellbeginner> I'm looking to write a function that given a list and two predicates (a begin predicate, beginP and end predicate, endP), returns a list of the sublists starting at the first element that satisfies beginP and ends at the first element that satisfied endP
19:05:27 <benzrf> haskellbeginner: use break twice!
19:05:30 <benzrf> :t break
19:05:31 <haskellbeginner> The type of the function is (a -> Bool) -> (a -> Bool) -> [a] -> [[a]]
19:05:31 <lambdabot> (a -> Bool) -> [a] -> ([a], [a])
19:05:49 <benzrf> haskellbeginner: brotip use a tuple for your output
19:05:58 <benzrf> haskellbeginner: you will always return 3 so make that clear from the type
19:06:06 <benzrf> oh wait derp
19:06:08 <benzrf> nvm ignore me
19:06:23 <Maxdamantus> > (id `asAppliedTo` 4) 5
19:06:25 <lambdabot>  5
19:06:34 <Maxdamantus> Cool function.
19:06:40 <benzrf> yep :=)
19:07:02 <haskellbeginner> Example: groupByDelimiters (==1) (==5) [2,1,4,3,1,3,5,6,7,7,1,2,3,4,3,5,6,7]
19:07:02 <haskellbeginner> [[1,2,3,4,3],[1,4,3,1,3]]
19:07:02 <haskellbeginner> Example:  groupByDelimiters (==1) (==5) [2,1,4,3,1,3,5,6,7,7,1,2,3,4,3,5,6,7]
19:07:02 <haskellbeginner> [[1,2,3,4,3],[1,4,3,1,3]]
19:07:02 <haskellbeginner> groupByDelimiters (==1) (==5) [2,1,4,3,1,3,5,6,7,7,1,2,3,4,3,5,6,7]
19:07:02 <haskellbeginner> groupByDelimiters (==1) (==5) [2,1,4,3,1,3,5,6,7,7,1,2,3,4,3,5,6,7]
19:07:03 <haskellbeginner> groupByDelimiters (==1) (==5) [2,1,4,3,1,3,5,6,7,7,1,2,3,4,3,5,6,7]
19:07:03 <haskellbeginner> groupByDelimiters (==1) (==5) [2,1,4,3,1,3,5,6,7,7,1,2,3,4,3,5,6,7]
19:07:04 <haskellbeginner> groupByDelimiters (==1) (==5) [2,1,4,3,1,3,5,6,7,7,1,2,3,4,3,5,6,7]
19:07:04 <haskellbeginner> groupByDelimiters (==1) (==5) [2,1,4,3,1,3,5,6,7,7,1,2,3,4,3,5,6,7]
19:07:05 <haskellbeginner> groupByDelimiters (==1) (==5) [2,1,4,3,1,3,5,6,7,7,1,2,3,4,3,5,6,7]
19:07:05 <haskellbeginner> Example: groupByDelimiters (==1) (==5) [2,1,4,3,1,3,5,6,7,7,1,2,3,4,3,5,6,7]
19:07:12 <haskellbeginner> Woah, not sure what happened there
19:07:41 <Maxdamantus> @let (a ~> b) c = (a `asTypeOf` c) `seq` b; (int, double) = undefined :: (Int, Double)
19:07:42 <bitemyapp> haskellbeginner: easy there killer.
19:07:45 <lambdabot>  Defined.
19:07:46 <vanila> haskellbeginner, if open was '(' and close was ')', what result do you want for "(())"?
19:08:12 <Maxdamantus> :t ([int] ~> double)
19:08:13 <lambdabot>     Ambiguous occurrence ‘int’
19:08:13 <lambdabot>     It could refer to either ‘L.int’,
19:08:13 <lambdabot>                              defined at /home/lambda/.lambdabot/State/L.hs:164:2
19:08:20 <Maxdamantus> Bleh.
19:08:24 <benzrf> lol.
19:08:25 <Maxdamantus> :t ([L.int] ~> L.double)
19:08:26 <lambdabot> [Int] -> Double
19:08:45 <glguy> Do the random lambdabot experimentation in /msg so that it doesn't scroll the q/a out of sight
19:08:58 <benzrf> Maxdamantus: nice.
19:09:00 <haskellbeginner> The result would be: [[1,2,3,4,3],[1,4,3,1,3]]
19:09:00 <haskellbeginner> vanila, what do you mean?
19:09:38 <vanila> haskellbeginner, I mean do you want to consider nested matches?
19:10:08 <vanila> or would it just return ["(()"]
19:10:15 <geardev> I just tried `cabal install snap` from the command line, I'd like to now use the snap package from within ghci
19:10:16 <haskellbeginner> Umm, I envisioned it as greedy from left to right
19:10:46 <geardev> import Snap causes an error "Could not find module `Snap'"
19:10:53 <haskellbeginner> So yes, ["(()"] would be the result
19:10:57 <vanila> okay well
19:11:10 <vanila> this is a sort of state machine, with a couple different states
19:11:19 <geardev> I am using hsenv, is there something I need to do to make the packages within this environment discoverable?
19:11:34 <vanila> the first is discarding list elements one by one until you reach a beginP
19:11:49 <vanila> once you have that, you move into a different state of collecting up until you reach an endP
19:12:01 <vanila> and then you can use recursion to get the rest of the results too
19:12:04 <haskellbeginner> I have an implementation (hand written tail recursive function), but it's really ugly :/
19:12:10 <benzrf> haskellbeginner: juse use break!!
19:12:12 <benzrf> :t break
19:12:12 <vanila> why don't you paste it?
19:12:13 <lambdabot> (a -> Bool) -> [a] -> ([a], [a])
19:12:25 <benzrf> > break (==3) [1, 5, 3, 2, 6]
19:12:27 <lambdabot>  ([1,5],[3,2,6])
19:12:46 <benzrf> something along the lines of
19:13:11 <vanila> haskellbeginner, to lpaste.net
19:13:18 <benzrf> urFunc bp ep = fst . break ep . snd . break bp
19:13:31 <haskellbeginner> break sounds like a good direction
19:13:32 <benzrf> @let haskellbeginner bp ep = fst . break ep . snd . break bp
19:13:35 <lambdabot>  Defined.
19:13:38 <benzrf> :t haskellbeginner
19:13:40 <lambdabot> (a -> Bool) -> (a -> Bool) -> [a] -> [a]
19:13:42 <haskellbeginner> http://lpaste.net/104880
19:14:10 <vanila> haskellbeginner, should I show you the state machine way I was describing?
19:14:25 <benzrf> > haskellbeginner (=='(') (==')') "(())"
19:14:27 <lambdabot>  "(("
19:14:29 <dsturnbull> can anyone take a look at https://gist.github.com/dsturnbull/153fa722ccfdd3b10ae4 and help me make a better separation of IO and pure code?
19:15:02 <haskellbeginner> Sure, I understand state machines, I would just need an explanation of the best way of doing it in Haskell
19:15:19 <vanila> haskellbeginner, you make one function for each state
19:15:40 <vanila> so you can have groupByDelimiters and collectByDelimiters, mutually recursive
19:15:41 <haskellbeginner> benzrf: The version that I pasted doesn't keep the end delimiter, but that's a simple change
19:16:02 <trap_exit> is here a way to say : any time a *.hs file changes, execute: hastec --with-js=helpers.js Main.hs?
19:17:04 <benzrf> haskellbeginner: ok
19:17:38 <haskellbeginner> vanila: That makes sense, I'll try that out, thanks. I'll write one using break as well, didn't know about that function
19:17:59 <vanila> haskellbeginner, I annotated your paste if you want to see after you try it out
19:18:11 <geardev> oh
19:18:12 <geardev> aeson-0.7.0.3 failed during the building phase. The exception was:
19:18:12 <geardev> ExitFailure 1
19:18:13 <geardev> heist-0.13.1.1 depends on aeson-0.7.0.3 which failed to install.
19:18:13 <geardev> lens-4.1.2.1 depends on aeson-0.7.0.3 which failed to install.
19:18:15 <geardev> snap-0.13.2.6 depends on aeson-0.7.0.3 which failed to install.
19:18:39 <trap_exit> yo
19:18:57 <trap_exit> how do I say: any time emacs saves a *.hs file in this directory, this other program fires off a ghc compile
19:21:28 <geardev> [ 9 of 12] Compiling Data.Aeson.Encode ( Data/Aeson/Encode.hs, dist/build/Data/Aeson/Encode.o )
19:21:31 <geardev> Data/Aeson/Encode.hs:37:66: Module `Data.Scientific' does not export `scientificBuilder'
19:21:34 <geardev> Failed to install aeson-0.7.0.3
19:21:42 <geardev> How does `cabal report` work? Maybe I should report this
19:21:56 <geardev> If I can't use snap tonight, atleast I can do is report it
19:23:30 <bitemyapp> geardev: are you building in a sandbox? Can you lpaste your cabal file?
19:24:13 <haskellbeginner> vanila: I should also mention that there must be a closing delimiter for the sublist to be included. For example: "(((((" => []
19:24:36 <geardev> bitemyapp: Yes, I'm building in a sandbox
19:24:46 <vanila> yeah, if you use states like I described that will work
19:25:15 <vanila> one thing to note about this is productiveness: You will not receive any characters from a single group until they are all parsed
19:25:33 <geardev> bitemyapp: https://pastee.org/seg4x
19:26:07 <bitemyapp> geardev: wut
19:26:41 <bitemyapp> geardev: https://github.com/bitemyapp/bloodhound/blob/master/bloodhound.cabal
19:28:22 <geardev> bitemyapp: Oh, I don't have one
19:28:29 <geardev> I just did `cabal install snap`
19:28:57 <glguy> haskellbeginner, I didn't read enough to see if something like this was covered, but this might be interesting: http://lpaste.net/104882
19:29:27 <bitemyapp> geardev: I see. Absent a cabal to define your deps, you'd have to fix package versions manually in the cabal install command that installs Snap
19:29:41 <bitemyapp> geardev: whose instructions are you following?
19:30:33 <bitemyapp> geardev: this? http://snapframework.com/download
19:30:37 <enthropy> so Data.Type.Equality.== is not as powerful as the version you can write with overlapping instances
19:30:44 <orzo> how fast is Data.Map?  I want something low cost but faster than a simple binary search.  With only Eq and Ord requirements, should I assume Data.Map is essentially the same as a binary search?
19:30:49 <haskellbeginner> glguy: time to head over to Hoogle to see what this unfoldr business is :P
19:31:41 <haskellbeginner> I like that
19:31:53 <bitemyapp> orzo: sadly, I can answer your question more precisely if you were asking about unordered-containers.
19:32:30 <orzo> well hackage tells me Map is based on size balanced binary trees
19:32:45 <geardev> bitemyapp: I'm not following anyone's instructions
19:32:55 <geardev> I did do what's on the page you linked
19:33:06 <orzo> binary seems a little slow sounding
19:33:11 <orzo> heh
19:33:12 <bitemyapp> geardev: try fixing a different version of Aeson in the same line as the snap install, something newer.
19:33:19 <bitemyapp> orzo: log n is slow?
19:33:27 <orzo> depends of course
19:33:49 <haskellbeginner> Second attempt: http://lpaste.net/104884
19:33:56 <orzo> what are your go-to lookup structures?
19:34:04 <pjdelport> haskellbeginner: foldr and unfoldr are two of the universal swiss army knives of working with lists; they're very much worth knowing well.
19:34:10 <bitemyapp> orzo: Data.Map, IntMap, and unordered-containers.
19:34:12 <haskellbeginner> Seems like unfoldr is the abstraction of exactly what my loop is doing
19:34:27 <orzo> i'll likely be keying on bytestrings
19:34:34 <pjdelport> haskellbeginner: You might learn later about catamorphisms and anamorphisms; that's what foldr and unfoldr are for lists.
19:34:42 <orzo> that makes IntMap inconvenient
19:34:58 <geardev> I wonder which version of Aeson would be ideal to use with Snap
19:35:53 <bitemyapp> geardev: trust the build, just ask for a newer version.
19:36:13 <orzo> i think Data.Map is a simple binary lookup and unordered-containers is a full hash table using mutation.  I figured there'd be a decent middle ground
19:36:39 <vanila> haskellbeginner, did you see http://lpaste.net/104880
19:36:51 <bitemyapp> orzo: well, you're wrong.
19:37:13 <orzo> a trie maybe
19:37:20 <bitemyapp> orzo: ever heard of Phil Bagwell?
19:37:42 <orzo> no
19:37:46 <bitemyapp> orzo: if you're that obsessed with performance and are an FP lang user, you have a paper to read.
19:38:06 <bitemyapp> orzo: http://infoscience.epfl.ch/record/64398/files/idealhashtrees.pdf
19:38:47 <orzo> is data.map based on his rec?
19:39:25 <bitemyapp> orzo: no
19:39:29 <haskellbeginner> vanila, yup, it's definitely nicer than my original
19:40:17 <haskellbeginner> pjdelport, I'm pretty familiar with foldr, had no clue that unfoldr existed though :P
19:40:31 <bitemyapp> orzo: how closely did you look at unordered-containers?
19:40:35 <vanila> haskellbeginner, it encodes the states of the state machine as functions
19:40:46 <haskellbeginner> And I'll keep your comment about (cata|ana)morphisms in mind
19:40:54 <vanila> haskellbeginner, one thing to note is that when you use parser combinators, this is the sort of thing that "generates"
19:41:08 <vanila> but we're doing it directly/manually here
19:41:08 <haskellbeginner> vanila, I'll keep that in mind, thanks
19:41:23 <bitemyapp> orzo: what is it you want exactly? And don't say "fast"
19:41:34 <bitemyapp> orzo: how much read vs. write will you be doing? What are the access patterns like?
19:41:37 <orzo> hm, i think i want unordered-containers, that is not a mutation-based hashtable like i thought
19:42:03 <geardev> bitemyapp: do you mean, `cabal update && cabal install snap`?
19:42:32 <bitemyapp> geardev: I mean, add arguments to the second command to fix the Aeson package version to something newer.
19:42:41 <bitemyapp> geardev: what version of GHC are you running?
19:44:56 <heatsink> I did a little Coq... I think it fried my brain.
19:46:57 <orzo> bitemyapp: well, i have probably less than 20 objects that need to be ordered, eqch object has a symbolic name for the one that should come next.  Occasionally objects will have the same name and i need to try both.  I implemented an n^2 algorithm thinking 20 wasnt much, but that will lead to 200 extra iterations in practice and instances o fthe whole problem may occur pretty frequently
19:47:35 <bitemyapp> orzo: you have 20 objects and you're worried about performance?
19:47:38 <geardev> bitemyapp: 7.6.3
19:48:02 <orzo> bitemyapp: say 1000 sets of 20 objects each
19:48:47 <Ralith> how many times per second?
19:48:53 <oisin640> Can someone gently explain why Haskell doesn't use an operator like instanceof in Java for checking types at runtime?
19:49:10 <orzo> i'm not super worried, but hash tables rae typically used in the other guys software
19:49:49 <Ralith> oisin640: https://en.wikipedia.org/wiki/Parametricity
19:50:03 <bitemyapp> oisin640: it's an awful idea :)
19:50:13 <orzo> my n^2 algorithm was based on an ordering relation rather than data.map or any lookup at all, probably i should at least do Data.Map
19:50:19 <oisin640> Ah, thanks :D
19:50:33 <armlesshobo> oisin640: because it's unnecessary
19:50:33 <heatsink> oisin640: In Haskell, if your code requires a particular type to work, the compiler will verify that it gets only that type.
19:50:45 <bitemyapp> oisin640: this is how I prefer to explain parametricity: https://github.com/bitemyapp/learnhaskell#ad-hoc--parametric-polymorphism-free-theorems
19:50:47 <heatsink> oisin640: So there's no need to check anything dynamically.
19:51:01 <orzo> bitemyapp: would you just leave it n^2 ?
19:51:34 <bitemyapp> orzo: is it making something measurably slow?
19:52:39 <trap_exit> what's a good example of how to use Data.Map in haskell?
19:52:44 <trap_exit> looking for just sample code
19:52:46 <orzo> well, this is a library tool, if i use a relation, then i'll be baking in an n^2 algorithm into my interface
19:53:03 <bitemyapp> trap_exit: it's pretty easy to use. Trivial even. http://hackage.haskell.org/package/containers-0.5.5.1/docs/Data-Map.html
19:53:11 <armlesshobo> trap_exit: perhaps as a quick way to refer to configuration values
19:53:22 <bitemyapp> trap_exit: are you not accustomed to Hackage pages?
19:53:46 <benzrf> orzo: don't you know the 3 rules of evaluation
19:54:01 <trap_exit> in clojure, I can just write shit like {:a 20, :b 30, :c "hello world"}
19:54:02 <benzrf> *optimization ugh
19:54:10 <trap_exit> in Haskell, is it not possible to write a map "in place" ?
19:54:28 <heatsink> trap_exit: fromList [("a", 20), ("b", 30), ("c", 40)]
19:54:29 <benzrf> trap_exit: [('a', 20), ('b', 30)]
19:54:44 <heatsink> Map.fromList builds a map from the list
19:54:46 <bitemyapp> trap_exit: fromList is a common constructor in Haskell, but you don't use Maps nearly as often in Haskell as you do in Clojure.
19:55:09 <bitemyapp> trap_exit: for example, you don't model domain-specific data in terms of Data.Map, you use records. Which are type-safe and have nice syntax.
19:55:24 <bitemyapp> trap_exit: so your problem might not be syntax for Data.Map, but that you're reaching for the wrong type.
19:55:31 <benzrf> bitemyapp++
19:55:32 <heatsink> I have a feeling trap_exit's example is an extensible record type
19:55:34 <bitemyapp> trap_exit: how have you been learning Haskell so far?
19:55:53 <trap_exit> bitemyapp: by starting with clojure
19:55:55 <trap_exit> realigizing I want types
19:55:59 <trap_exit> trying clojure.core.typed
19:56:01 <trap_exit> finding it too slow
19:56:02 <bitemyapp> trap_exit: okay, well I have good news.
19:56:06 <trap_exit> wait wait
19:56:07 <bitemyapp> trap_exit: I went through the same thing.
19:56:10 <trap_exit> don't interrupt me
19:56:15 <trap_exit> well, starting with clojurescript
19:56:20 <trap_exit> then clojure.core.typed for ytped javascript
19:56:21 <trap_exit> finding it slow
19:56:23 <trap_exit> then installing fay
19:56:27 <trap_exit> and finding it not useful
19:56:30 <trap_exit> and now I'm using Haste
19:56:32 <trap_exit> done
19:56:35 <trap_exit> bitemyapp: go ahead
19:56:35 <bitemyapp> okay.
19:56:37 <trap_exit> tell me your good news
19:56:39 <bitemyapp> so a few things
19:57:15 <bitemyapp> trap_exit: 1. I'm an ex-Clojurian too, you may have even used something I worked on. 2. I didn't like Fay either 3. I didn't like core.typed or cljs either.
19:57:15 <trap_exit> are you typing on a 28.8k connection?
19:57:28 <trap_exit> well; I like cljs more than js
19:57:29 <bitemyapp> trap_exit: I'm about to help you out, are you going to be nice?
19:57:37 <trap_exit> :-)
19:58:57 <trap_exit> bitemyapp: ?
19:59:07 <bitemyapp> trap_exit: you know IRC is public right?
19:59:09 <vanila> trap_exit, GHC is the best haskell compiler if you can afford it
19:59:27 <bitemyapp> vanila: they're probably doing frontend, best would be irrelevant there.
19:59:28 <trap_exit> bitemyapp: yes IRC is public -- what about it?
19:59:45 <vanila> front end ??
19:59:53 <bitemyapp> trap_exit: you set off a few warning bells and I checked logs, you don't seem like a very nice person. Which is saying something, because I'm very not-nice person.
19:59:53 <benzrf> ick
20:00:04 <benzrf> web frontend gross!
20:00:19 <bitemyapp> trap_exit: I think you're going to have to find a better person than I to help you out, sorry.
20:00:33 <bitemyapp> I'm open to being convinced otherwise, but keep it out of the channel.
20:00:36 <vanila> trap_exit, what were you asking about?
20:00:57 <trap_exit> vanila: I'm actually not sure.
20:01:00 <vanila> oh okay
20:01:03 <vanila> sorry about all this
20:01:07 <vanila> #haskell is normally much nicer
20:01:09 <trap_exit> This transitioned into a discussion of ex-clojure -> haskell.
20:02:28 <benzrf> trap_exit: just say no to Data.Map
20:02:49 <vanila> Data.Map is fine when you want logarithmic insertion and lookup :)
20:03:23 <vanila> but yeah, it's inappropriate for the whole "json paradigm"
20:10:15 <geardev> hi
20:10:42 <bitemyapp> geardev: hi
20:10:55 <Maxdamantus> @let a `bleh` c :: (Any a, Any b, Any c) => (b -> c) -> (a -> b) -> (a -> c); (a `bleh` c) d = a (c d)
20:10:55 <geardev> I've given up on building a snap app tonight
20:10:55 <lambdabot>  Parse failed: Left-hand side of type signature is not a variable: a `bleh` c
20:11:01 <geardev> I've instead just started playing with ghci
20:11:09 <geardev> I just did `import Data.List`
20:11:22 <geardev> I'm wanting to see what cool things I can do with the functions from this module :)
20:11:28 <geardev> I'm sure there's stuff I could learn from this
20:11:33 <geardev> ...at least I hope so
20:11:39 <benzrf> geardev: :-D
20:11:40 <Robster[UPN]> add     :: Int -> Int -> Int
20:11:40 <Robster[UPN]> add x y = x + y
20:11:40 <Robster[UPN]> addOne = add 1
20:11:52 <Robster[UPN]> Is that an example of partial application AND a higher order function?
20:11:55 <bitemyapp> geardev: :browse Data.List
20:12:09 <benzrf> Maxdamantus: what's the Any class
20:12:13 <benzrf> no methods?
20:12:23 <geardev> What's the difference between Data.List<tab> and :browse Data.List?
20:12:37 <vanila> Robster[UPN], technically it is a higher order function, the type is: Int -> (Int -> Int)
20:12:37 <bitemyapp> geardev: try it
20:12:48 <Maxdamantus> benzrf: meant to write Forall
20:12:51 <Maxdamantus> benzrf: but yes.
20:12:53 <Maxdamantus> > let bleh :: (Forall a, Forall b, Forall c) => (b -> c) -> (a -> b) -> (a -> c); (a `bleh` c) d = a (c d) in (succ `bleh` (5*)) 4
20:12:55 <lambdabot>  21
20:12:59 <vanila> Robster[UPN], but it's equivalent in some sense to the first order function: (Int,Int) -> Int
20:13:00 <geardev> bitemyapp: I did and I can't tell, that's why I ask :)
20:13:17 <bitemyapp> geardev: well, in my ghci, :browse shows the types
20:13:31 <Maxdamantus> @let bleh :: (Forall a, Forall b, Forall c) => (b -> c) -> (a -> b) -> (a -> c); (a `bleh` c) d = a (c d)
20:13:33 <lambdabot>  Defined.
20:13:38 <vanila> Robster[UPN], unlike a function like (a -> a) -> a which is genuinely higher order
20:13:39 <geardev> bitemyapp: does tabbing not show the types as well?
20:14:06 <ryantrinkle> i'm using "SPECIALIZE instance", and i'm getting a lot of these: match_co: needs more cases
20:14:11 <ryantrinkle> is there any way to avoid that?
20:14:11 <Robster[UPN]> How would you define a higher order function in english and then partial applicatin in words too?
20:14:30 <Robster[UPN]> Partial application involved passing less than the full number f arguments to a function that takes multiple arugments
20:14:31 <trap_exit> I want to understand a good example of storing "recursive" data inside of a haskell object.
20:14:42 <trap_exit> Imagine I have a document, where a node = "tag + attrs + map of <string, node> "
20:14:48 <bitemyapp> geardev: eh, not for me.
20:14:50 <trap_exit> how should I model this in haskell ?
20:15:01 <Robster[UPN]> And higher order functions are ones take functions as arguments or return them as definitions?
20:15:07 <vanila> trap_exit, data Node = Node Tag Attrs (Map String Node)
20:15:21 <pjdelport> Robster[UPN]: There's some fuzziness there, depending on what level you consider implicitly curried functions.
20:15:25 <trap_exit> vanila : is this "Map" also Data.Map, or is it something else?
20:15:43 <vanila> trap_exit, yeah - or any other container you like
20:16:14 <pjdelport> Robster[UPN]: You can think of "f a b = ..." as both a function of two arguments, or as a function of one argument returning a function of the next argument, due to to the implicit currying in Haskell.
20:16:16 <trap_exit> great; one more question along this line
20:16:40 <trap_exit> in clojure, I can say Node = "tag + attrs + map <Anything, Node>" -- in Haskell, can I say this? that the key can be anything? (i.e. string, number, vector of strings/numbers)
20:16:48 <trap_exit> or do I have to explcity define all allowable types for the Key ?
20:16:57 <vanila> trap_exit, you can't do that in haskell
20:17:14 <Robster[UPN]> Thanks guys
20:17:16 <vanila> trap_exit, yeah, youd have to make a type like  data Anything = StringThing String | NumberThing Int | ...
20:17:24 <vanila> and it would be fixed to just those
20:17:28 <trap_exit> understood
20:17:29 <trap_exit> thanks :-)
20:17:30 <pjdelport> Robster[UPN]: So in the same way you can think of "addOne = add 1" as both partial application, or as normal application of the curried "add".
20:17:44 <vanila> trap_exit, but, haskell also has typeclasses as well as data types
20:17:55 <benzrf> Robster[UPN]: currying is interesting!
20:17:58 <vanila> trap_exit, data types are "closed world" in that once they are defined that's it
20:18:01 <pjdelport> Robster[UPN]: So in general, you'll have to define your viewpoint first.
20:18:13 <vanila> trap_exit, but type-classes are "open world" because anyone can define new instance for them
20:18:15 <benzrf> Robster[UPN]: in some cases, there is a blurred line about whether something is 'fully applied'
20:18:31 <benzrf> Robster[UPN]: for example,
20:18:33 <benzrf> :t (.)
20:18:34 <lambdabot> (b -> c) -> (a -> b) -> a -> c
20:18:58 <benzrf> Robster[UPN]: you can see (.) as either 2 functions to another, or 2 functions and an arg to a result!
20:19:21 <benzrf> and in haskell, the difference between those two things is meaningless
20:22:49 <Maxdamantus> except syntactically, where it works as a binary operator.
20:25:16 <pjdelport> Haskell doesn't have a problem using unary functions as binary operators.
20:25:26 <Maxdamantus> bitemyapp: your github thing links to http://swizec.com/blog/week-20-making-ad-hoc-polymorphism-less-ad-hoc/swizec/6564 which looks slightly wrong.
20:25:28 <pjdelport> > print `id` 5
20:25:30 <lambdabot>  <IO ()>
20:25:44 <Maxdamantus> under "Translating to Hindley-Milner", data NumD a = NumDict (a -> a -> a) (a -> a -> a) (a -> a)
20:25:52 <Maxdamantus> those should probably all have foralls in them.
20:26:08 <pjdelport> > negate `id` 5
20:26:10 <lambdabot>  -5
20:26:14 <Maxdamantus> (assuming the Rank2Types meaning of inner forall)
20:26:17 <pjdelport> :t id
20:26:19 <lambdabot> a -> a
20:27:23 <carter> ryantrinkle: theres some limits to specialize
20:27:33 <trap_exit> data Id = Either String Double \n data Doc X = { tag :: X, order :: List ID, childs :: Map Id (Doc X) }
20:27:42 <Maxdamantus> pjdelport: that's not unary when it's (a -> IO ()) -> a -> IO ()
20:27:43 <carter> heck, i hit some bugs in specialize in 7.8 that wont get fixed till 7.10
20:27:45 <trap_exit> how do I define "Doc" to not be a single type
20:27:45 <Maxdamantus> for some a
20:27:54 <carter> well, i mean the fix is in HEAD
20:27:58 <trap_exit> but c alss of types, where Doc FooNode = a doc of Foo's, and Doc BarNode = a Doc of Bar's
20:27:59 <carter> but not gonna get into 7.8.
20:28:15 <johnw> trap_exit: you need to use GADTs and express it through the constructor
20:28:35 <johnw> data Doc a where barNode :: Bar -> Doc Bar; fooNode :: Foo -> Doc Foo
20:29:03 <ryantrinkle> carter: that's unfortunate
20:29:15 <carter> ryantrinkle: assume you're hitting a limit of specalize
20:29:16 <Robster[UPN]> Is an overloaded function simply one that uses a type class constraint?
20:29:18 <carter> and report a ghc ticket
20:29:20 <Maxdamantus> Oh wait, nvm, `a` is part of the type class.
20:29:31 <carter> whats the example?
20:29:33 <Robster[UPN]> i.e (Eq a) => a -> a -> a
20:29:48 <carter> ryantrinkle: like, do you have a single module example that can tirp it
20:31:18 <pjdelport> Maxdamantus: Right, right; I'm just saying that even operators like (.) don't have to be syntactically binary, either.
20:31:32 <pjdelport> > let (.) = 5 in (.) + (.)
20:31:34 <lambdabot>  10
20:32:43 <carter> let (+) = \ a b c d e f h -> h in (+) 1 2 3 4 5 6 7
20:32:53 <carter> > let (+) = \ a b c d e f h -> h in (+) 1 2 3 4 5 6 7
20:32:55 <lambdabot>  7
20:33:30 <Maxdamantus> > let (+) = \ a b c d e f h -> h in (1 + 2) 3 4 5 6 7
20:33:32 <lambdabot>  7
20:33:46 <carter> lol
20:33:48 <carter> good point!
20:33:50 <glguy`> Johnw: is trap asking about gadts or just how parameterized data types work? Seems like he has a simpler question but on this phone this was a lot to type
20:34:43 <johnw> I'm not sure
20:35:50 <mzero> any Sydney FP'ers here?
20:36:20 <carter> mzero: try #haskell.au :)
20:37:58 <mzero> who knew we were big enough to have country specific channels!!!
20:38:21 <bitemyapp> glguy`: could've been parameterized type, typeclass, GADTs, or custom constructors.
20:40:05 <monochrom> we even have #haskell.tw for Taiwan
20:40:31 <monochrom> french, russian, spanish, etc are also standard fare
20:43:14 <Maxdamantus> > let (+) = 5 in () + ()
20:43:16 <lambdabot>  5
20:44:34 <carter> wat
20:44:57 <Maxdamantus> > let (+) = 5; (*) = () + (); (.) = () * () in () . ()
20:44:59 <lambdabot>  5
20:46:01 <Maxdamantus> > (\() () () () () () -> 6) * (\() () () () () () -> 10) $ () () () () () ()
20:46:03 <lambdabot>  Couldn't match expected type ‘() -> () -> () -> () -> () -> ()’
20:46:03 <lambdabot>              with actual type ‘()’
20:47:10 <carter> i feel like i'm being trolled
20:47:55 <Maxdamantus> > ((\() () () () () () -> 6) * (\() () () () () () -> 10)) () () () () () ()
20:47:57 <lambdabot>  60
20:48:47 <Maxdamantus> > ((\() () () () () () -> 6) * (\() () () () () () -> 10)) () () () () () () () () () () () () () () () ()
20:48:49 <lambdabot>  60
20:49:35 <carter> :t ((\() () () () () () -> 6) * (\() () () () () () -> 10))
20:49:36 <lambdabot> Num a => () -> () -> () -> () -> () -> () -> a
20:49:42 <carter> kk
20:49:43 <carter> huh
20:50:04 <carter> i'm confused
20:50:53 <carter> Prelude> :t ((\() () () () () () -> 6) * (\() () () () () () -> 10))
20:50:53 <carter> ((\() () () () () () -> 6) * (\() () () () () () -> 10))
20:50:54 <Maxdamantus> > 5 () ()
20:50:54 <carter>   :: (Num (() -> () -> () -> () -> () -> () -> a), Num a) =>
20:50:55 <carter>      () -> () -> () -> () -> () -> () -> a
20:50:56 <lambdabot>  5
20:51:19 <carter> lambda bot has some extra instances!
20:54:08 <qrada> quick q.. anyone have an idea of what's going on when I cabal install.. (.data+0x90): undefined reference to `Watchquezm0zi1zi0zi0_SystemziWatchqueziResque_runResque1_closure'.. I get a ton of those. It seems like soe kind of .so issue when the code is building. I've wiped my .cabal-sandbox and dist directories, hasn't help.
20:55:08 <Maxdamantus> Seems odd that you can't write () `5` () though.
20:55:31 <heatsink> That happens during cabal install?
20:56:25 <qrada> ya
20:57:05 <heatsink> Probably means a library is missing, but it's installed according to the package database
20:57:19 <heatsink> Does ghc-pkg check report errors?
20:58:06 <qrada> no errors, but im also using a sandbox so.. ghc-pkg doesnt check in .cabal-sandbox i think
20:58:37 <carter> qrada: are you listing ALL your modules in your cabal file?
20:58:44 <qrada> ya it's odd.. it was compiling prior to re-arranging a few of the imports
20:58:55 <qrada> the exposed-modules? nope.. should I be?
20:59:08 * hackagebot async-extras 0.1.0.0 - Extra Utilities for the Async Library  http://hackage.haskell.org/package/async-extras-0.1.0.0 (JonathanFischoff)
20:59:26 <carter> qrada: every single module needs to be in exposed or other modules
20:59:40 <qrada> ah
21:00:49 <carter> > 5 "hello"
21:00:51 <lambdabot>  No instance for (GHC.Show.Show a0)
21:00:51 <lambdabot>    arising from a use of ‘M20334595647512484429665.show_M20334595647512484429...
21:00:51 <lambdabot>  The type variable ‘a0’ is ambiguous
21:00:51 <lambdabot>  Note: there are several potential instances:
21:00:51 <lambdabot>    instance [safe] GHC.Show.Show
21:02:37 <carter> > (5) "hello"
21:02:39 <lambdabot>  No instance for (GHC.Show.Show a0)
21:02:39 <lambdabot>    arising from a use of ‘M691070530304292136029696.show_M6910705303042921360...
21:02:39 <lambdabot>  The type variable ‘a0’ is ambiguous
21:02:39 <lambdabot>  Note: there are several potential instances:
21:02:39 <lambdabot>    instance [safe] GHC.Show.Show
21:02:43 <carter> > (5) "hello"  :: int
21:02:45 <lambdabot>  No instance for (GHC.Num.Num ([GHC.Types.Char] -> int1))
21:02:45 <lambdabot>    arising from the literal ‘5’
21:02:46 <carter> > (5) "hello"  :: Int
21:02:47 <lambdabot>  No instance for (GHC.Num.Num ([GHC.Types.Char] -> GHC.Types.Int))
21:02:48 <lambdabot>    arising from the literal ‘5’
21:02:54 <vanila> it's not really necessary
21:03:07 <carter> > (5) () :: Int
21:03:09 <lambdabot>  No instance for (GHC.Num.Num (() -> GHC.Types.Int))
21:03:09 <lambdabot>    arising from the literal ‘5’
21:03:21 <carter> oh well;l
21:04:14 <Maxdamantus> > putStrLn "hello" >>= fmap 5 (putStrLn "world") >>= print
21:04:16 <lambdabot>  Couldn't match expected type ‘() -> GHC.Types.IO a0’
21:04:16 <lambdabot>              with actual type ‘GHC.Types.IO b0’
21:08:41 <qrada> thanks folks, issue fixed.. carter: it was exactly like you said, had to declare all of the modules in exposed-modules.
21:08:59 <carter> qrada: they don't neeed to be in exposed
21:09:02 <carter> they can be in other modules
21:09:06 <qrada> otherwise all of those undefined symbol errors would occur on cabal install
21:09:23 <qrada> ya that's how I had it.. but I must be missing one
21:09:24 <carter> is it hidden-modules or other-modules?
21:09:26 <qrada> because I'm able to cabal repl
21:09:37 <carter> ls -r
21:09:38 <carter> :)
21:09:42 <carter> or whatever
21:10:36 <qrada> ya i know.. I have say, src/System/Watchque.hs which imports some modules in src/System/Watchque/* ... but not all of them.. that's probably the issue.. i need to import all of them from that first Watchque.hs module
21:10:38 <carter> soo #haskell.es has literally 3 people
21:10:50 <carter> qrada: no, just list em
21:10:54 <carter> in the exposed modules
21:11:00 <carter> or hidden or internal or whatever
21:11:03 <carter> one of the modules list
21:11:19 <qrada> o, lemme check how someone else does it
21:11:20 <qrada> thanks
21:12:44 <qrada> im looking at ekmett's nats library.. i never realized he 'exposes' his Internal module.. by default I figured that wouldn't have been in his .cabal file
21:12:48 <bitemyapp> snap
21:12:53 <qrada> so a misunderstanding there for sure
21:13:13 <carter> yeah, he exposes em so that power users can do shit
21:13:23 <qrada> gotcha
21:13:40 <carter> but if you have a good reason to keep em private
21:13:48 <carter> i'll respect your private types
21:13:59 <carter> or whatever
21:17:02 <trap_exit> how do I read a field of a record?
21:17:10 <trap_exit> data Node = SvgRect { x :: Double, y :: Double, width :: Double, height :: Double,                       strokeWidth :: Double, fill :: String, stroke :: String } <--
21:17:15 <trap_exit> how do I read out the field called strokeWidth ?
21:18:07 <qrada> strokeWidth something
21:18:24 <tsani> Defining a record automatically makes projection functions with the names of the fields
21:18:37 <qrada> ie, something = SvgRec { x = .., y = .. width = .., height = .., strokeWidth = .. }
21:18:41 <qrada> strokeWidth something
21:18:57 <jle`> strokeWidth :: SvgRect -> Double
21:20:07 <tsani> > let 5 = 2 in 5 + 5
21:20:08 <lambdabot>  10
21:20:12 <tsani> Why not 4 ?
21:20:35 <benzrf> tsani: you cannot bind constants
21:20:36 <trap_exit> grada, tsani, jle`: noted, thanks
21:20:44 <benzrf> tsani: that was parsed as a pattern match
21:20:54 <benzrf> but thanks to laziness the match wasnt done
21:21:22 <tsani> Ah
21:22:17 <Robster[UPN]> The expression Branch (Tip 1) (Tip 2) is a value of the datatype:
21:22:17 <Robster[UPN]> i)
21:22:17 <Robster[UPN]> data Tree = Tip Int | Branch
21:22:17 <Robster[UPN]> ii)
21:22:17 <Robster[UPN]> data Tree = Tip Int | Branch Int Int
21:22:24 <Robster[UPN]> iii)
21:22:24 <Robster[UPN]> data Tree = Tip Tree | Branch Int Int
21:22:25 <Robster[UPN]> iv)
21:22:25 <Robster[UPN]> data Tree = Tip Tree | Branch Tree Tree
21:22:26 <Robster[UPN]> v)
21:22:26 <Robster[UPN]> data Tree = Tip Int | Branch Tree Tree
21:22:27 <Robster[UPN]> Oops sorry for the weird copy and paste.
21:22:40 <Robster[UPN]> Revising for my exam and stuck on this question from the past papers. Can anyone help?
21:23:04 <trap_exit> does haskell have a prefernce of foo_bar vs fooBar ?
21:23:07 <glguy> Robster[UPN], What do you think the answer is?
21:23:09 <benzrf> trap_exit: the latter
21:24:22 <Robster[UPN]> I would of went for iii
21:24:25 <benzrf> Robster[UPN]: given your code sample, what is the necessary type of Tip
21:24:34 <benzrf> Robster[UPN]: and of Branch
21:24:43 <Robster[UPN]> But I haven't covered branch/trees, so stumped with it
21:24:54 <benzrf> Robster[UPN]: stop
21:25:01 <benzrf> Robster[UPN]: Branch (Tip 1) (Tip 2)
21:25:06 <benzrf> Robster[UPN]: what is the type of Tip?
21:25:14 <Robster[UPN]> Int
21:25:27 <benzrf> Tip :: Int
21:25:36 <benzrf> Robster[UPN]: so 'Tip 1' is an error?
21:25:42 <benzrf> you can't apply Ints, they aren't functions
21:25:50 <Maxdamantus> What's Tip * Tip?
21:26:20 <benzrf> Robster[UPN]: Tip is being applied as a function
21:26:26 <benzrf> Robster[UPN]: so it must have an arrow in its type
21:26:48 <Robster[UPN]> Well this exam doesn't show it
21:27:18 <benzrf> Robster[UPN]: ...
21:27:19 <benzrf> Robster[UPN]: Branch (Tip 1) (Tip 2)
21:27:26 <benzrf> Robster[UPN]:          ^
21:27:28 <benzrf> right there
21:27:29 <benzrf> Tip 1
21:27:32 <benzrf> it's being applied
21:27:35 * benzrf whacks Robster[UPN] 
21:28:02 <benzrf> Robster[UPN]: do you know how data declarations worj?
21:28:03 <benzrf> *work
21:28:30 <Robster[UPN]> lol No. I didn't think this was even on the curriculum.
21:28:35 <Robster[UPN]> It's an intro to Haskell course.
21:28:59 <benzrf> Robster[UPN]: do you understand the type Maybe
21:29:31 <Robster[UPN]> I understand types in general. But I don't know what Branch/Tips/Tree's are, so can't relate the two.
21:30:04 <benzrf> Robster[UPN]: no, i mean are you specifically familiar with the Maybe type
21:30:09 <Robster[UPN]> oh rofl, no
21:30:14 <benzrf> ok.
21:30:20 <benzrf> Robster[UPN]: do you understand the concept of a sum type?
21:30:29 <Maxdamantus> I think the idea is that you understand how data declarations work so you can figure out what the data declarations you're given mean.
21:30:42 <Robster[UPN]> No. Only know of the sum function.
21:30:48 <Maxdamantus> rather than some specific `Tree` type.
21:30:52 <benzrf> Robster[UPN]: eeh
21:30:58 <benzrf> Robster[UPN]: do you know C/
21:31:05 <Robster[UPN]> I guess i'll just move onto another question, won't be able to learn it in another couple of hours :v
21:31:17 <Robster[UPN]> Again I am a first year, and only did an intro on C. So very basic.
21:31:34 <benzrf> Robster[UPN]: do you know structs?
21:31:54 <Robster[UPN]> No :v
21:32:05 <benzrf> :I
21:32:08 <Robster[UPN]> I need to quit IRC, it's not great for motivation pre exam :v
21:32:13 <benzrf> k
21:32:20 <Robster[UPN]> Thanks :)
21:32:44 * haxx0r slaps Robster[UPN] around a bit with a large trout
21:32:46 <haxx0r> hey
21:33:03 <hcaulfield57> Does anyone know why substitution doesn't work in HDBC when creating tables, i.e. -> http://lpaste.net/104885
21:33:15 <Robster[UPN]> Hey haxx0r
22:04:51 <Robster[UPN]> All recursive functions need a base case right?
22:06:24 <glguy> They would in a strict language, at least
22:07:03 <glguy> > let f x = x : f (x+1) in f 0
22:07:05 <lambdabot>  [0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,2...
22:07:13 <glguy> > let f x = x : f (x+1) in take 10 (f 0)
22:07:15 <lambdabot>  [0,1,2,3,4,5,6,7,8,9]
22:08:31 <npcomp> let f x = x : f (x+1) in take 10 (f 0)
22:08:49 <npcomp> > let f x = x : f (x+1) in take 10 (f 0)
22:08:49 <trap_exit> https://gist.github.com/anonymous/09291fc72e709d15b634 <-- how do I define "==" for my type ?
22:08:51 <lambdabot>  [0,1,2,3,4,5,6,7,8,9]
22:09:35 <Axman6> trap_exit: add deriving (Eq) to the end of the definition
22:10:14 <trap_exit> Axman6: resolved it, thanks!
22:10:34 <ReinH> trap_exit: Strongly recommend that you don't use record syntax in combination with sum types.
22:10:39 <ReinH> It is unsafe.
22:10:56 <trap_exit> ReinH: I understand the words, but not the sentence.
22:11:16 <ReinH> trap_exit: x1 (SvgRect 0 0 0 0) typechecks and throws a runtime error.
22:11:25 <trap_exit> shit
22:11:28 <trap_exit> how do I avoid this problem?
22:11:32 <ReinH> Don't use record syntax directly in combination with |
22:11:35 <Axman6> don't use record syntax
22:11:37 <ReinH> Wrap your records in a type constructor
22:11:48 <trap_exit> but then I have to remember the name of the arguments
22:11:54 <ReinH> data Node = NRect SvgRect | NLine SvgLine | NGroup SvgGroup
22:12:01 <ReinH> and define SvgRect, SvgLine, and SvgGroup separately
22:12:24 <ReinH> Not a type constructor. A data constructor.
22:12:29 <trap_exit> *thinking*
22:12:38 <trap_exit> do I get clashes on strokeWidth and stroke ?
22:12:58 <ReinH> Yes, which you can resolve with another record type or a typeclass
22:14:07 <ReinH> data SvgRect = SvgRect { x :: Double, y :: Double, dimensions :: Dimensions }; data Dimensions = Dimensions ( width :: Double, height :: Double }
22:14:27 <ReinH> or class HasDimensions where width :: Double; height :: Double
22:14:53 <ReinH> data SvgRect = SvgRect { rectWidth :: Double, rectHeight :: Height }; instance HasDimensions SvgRect where width = rectWidth; height = rectHeight
22:14:58 <ReinH> either will work
22:15:51 <ReinH> This might also be a good time to introduce yourself to lens
22:16:22 <ReinH> since updating either of these will be a pain.
22:44:57 <tadworthington> Anybody got time for a total noob question?
22:45:36 <tadworthington> Working my way through Graham Hutton’s “Programming in Haskell”.
22:45:45 <tadworthington> Working on an exercise to define (++) recursively.
22:45:48 <tadworthington> Came up with: http://pastebin.com/kEPzxduk
22:45:57 <tadworthington> I get errors, though.
22:46:07 <tadworthington> Can any experts on here take a look and give me some clues?
22:50:35 <aavogt> tadworthington: you're actually trying to do (!!)?
22:50:42 <johnw> what do I do when bin-package-db requires an older version of Cabal than the one I want to build against?
22:50:58 <johnw> namely: https://gist.github.com/7a5a9b8e57120e8a3e9f
22:51:03 <tadworthington> aavogt - yeah, it’s an exercise in the book.  Chapter on recursion.
22:51:58 <enthropy> tadworthington: well what you pasted is the same as (!!)
22:52:05 <enthropy> and it seems to work just fine
22:52:34 <tadworthington> Really, enthropy?!  I’m a bit surprised.  Let me try again.
22:53:30 <tadworthington> Ok, my face is a nice shade of crimson.  I was calling hslSelect 3 [1,2,3,4] instead of hslSelect [1,2,3,4] 3.
22:53:37 <tadworthington> *smacks forehead*
22:53:52 <tadworthington> Gotta learn to read the error messages :-D
22:55:23 <Maxdamantus> > let hslSelect = (!!) in hslSelect [1,2,3,4] 3
22:55:25 <lambdabot>  4
23:11:11 <johnw> n/m, found my answer
23:13:14 <trap_exit> http://www.haskell.org/ghc/docs/6.12.1/html/libraries/containers-0.3.0.0/Data-Map.html <-- where is Data.Map 's get ? i.e. Map -> Key -> value
23:13:32 <trap_exit> ah, it's lookup
23:13:55 <Cale> trap_exit: You're also looking at rather old documentation there
23:14:02 <trap_exit> how do I go from "Maybe a" to "a" via Nothing => exception
23:14:30 <Cale> http://hackage.haskell.org/package/containers-0.5.5.1/docs/Data-Map.html
23:14:41 <Cale> http://hackage.haskell.org/package/containers-0.5.5.1/docs/Data-Map-Lazy.html
23:14:44 <Cale> (sorry)
23:14:57 <Cale> (!) :: Ord k => Map k a -> k -> a
23:15:14 <Cale> findWithDefault :: Ord k => a -> k -> Map k a -> a
23:15:28 <johnw> I always forget that findWithDefault exists
23:15:52 <Cale> You could also use fromJust, but in this case, you're probably just looking for one of those two
23:16:00 <ReinH> trap_exit: fromJust or pattern match, but you probably don't want to do that unless you can guarantee that the value will never be Nothing in some other way.
23:16:09 <Cale> Or a case expression, of course
23:16:09 <ReinH> But if you can do that, you might want to ask if you can get the type system to do it for you.
23:16:39 <trap_exit> I don't like default value
23:16:42 <trap_exit> can I get a run time exception instead?
23:17:46 <ReinH> Maybe is a way to *avoid* runtime exceptions.
23:18:08 <trap_exit> I like erlang's philosophy of fail eartly
23:18:17 <trap_exit> I'm doing a lookup, the key is supported to be in the map
23:18:21 <trap_exit> and if it's not in there, I don't want a default value
23:18:26 <trap_exit> I want an error so i can debug it
23:18:48 <ReinH> Choosing the right definition of "fail" is orthogonal to failing early
23:19:11 <ReinH> Maybe *is* a Haskell idiom for failing early.
23:21:06 <ReinH> Either is a Haskell idiom for failing with some sort of failure message or information.
23:21:17 <ReinH> runtime exceptions are not a Haskell idiom for failing, early or late.
23:21:36 <ReinH> Haskell does not provide good tooling for handling or debugging runtime exceptions.
23:21:47 <ReinH> Because they are not fit for the purpose.
23:22:11 <ReinH> Runtime exceptions are what happen when you fail to fail in a reasonable way.
23:27:02 <Cale> Yeah, exceptions from evaluation are for the cases where you just want the entire program to die and not handle the error (presumably because it means your program is wrong enough that you don't want it to be running)
23:27:37 <johnw> Either moves error handling into the domain of values and evaluation; exceptions handle errors in the domain of the runtime systems and execution of IO
23:27:51 <johnw> they each have their place
23:29:12 <enthropy> trap_exit: there's a Map.!
23:29:57 <enthropy> if you want a sensible exception you're better off doing   let Just v = Map.lookup k m
23:31:02 <johnw> or fromJust (error $ "Could not find " ++ show k) (Map.lookup k m)
23:31:10 <johnw> and then stick that in lookup' or something
23:31:14 <johnw> err, fromMaybe
