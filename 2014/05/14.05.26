00:00:05 <warpy> thats what i went with, but it is not a meta package
00:00:22 <warpy> i have to add every subjects source in every other sub project
00:00:34 <warpy> and in correct order, myself
00:00:56 <warpy> subjects -> sub projects
00:01:59 <warpy> carter: also, you cant mention add-source in the cabal file itself
00:02:20 <warpy> so i'll need to ship a script which does this configuration
00:02:45 <warpy> am i missing something?
00:03:41 <carter> warpy: why do you need a meta package?
00:03:50 <carter> you could just do
00:04:03 <carter> cabal install ./folder1 ./folder2 .... ./foldern
00:04:17 <warpy> i can do that?
00:04:24 <warpy> wow
00:04:52 <warpy> that would solve my problem
00:04:59 <warpy> glad i asked here
00:05:30 <carter> heck, it works with URLS pointing to tarballs too :)
00:05:44 <warpy> i didnt know that
00:05:59 <warpy> i dont remember any tutorials mentioning that
00:06:16 <carter> you should write one :)
00:09:19 <warpy> carter: i tried it. cabal install ./folder1 ./folder2 .... ./foldern works but cabal clean ./folder1 ./folder2 .... ./foldern doesnt
00:09:33 <carter> warpy: :)
00:09:46 <carter> thats a legit feature request :)
00:09:55 <jle`> 1/b 14
00:10:05 <jle`> oops, sorry
00:10:13 <warpy> carter: where do i raise the request
00:10:27 <carter> github.com/haskell/cabal/issues
00:10:32 <carter> or you can write a build script :)
00:10:52 <warpy> that is exactly what i want to avoid
00:11:07 <warpy> cabal is a build tool. why should i write build scripts over it
00:11:15 <warpy> it should do everything to do with build
00:14:35 <Tjr> Can I overload operators in haskell?
00:14:35 <Tjr> For example, !! returns the n-th element of a list, can I make it take out a specified part of some custom datatype?
00:14:47 <warpy> but i guess that what i'll end up doing
00:14:53 <jle`> Tjr: operators are just norml functions in haskell
00:15:03 <opqdonut> Tjr: you can only overload operators (functions) that are part of some type class
00:15:12 <warpy> Tjr: yes you can.
00:15:15 <opqdonut> e.g. the arithmetic operators
00:15:16 <warpy> what opqdonut said ^
00:15:34 * Tjr reads up on typeclass.
00:15:36 <opqdonut> !! is not part of a type class so you can't overload it
00:15:37 <jle`> > let x !~> y = x + y * x in 7 !~> 5
00:15:39 <lambdabot>  42
00:15:42 <opqdonut> you could redefine it though
00:15:46 <opqdonut> if you really want
00:15:55 <jle`> that being said, it'll follow the same rules as normal functions
00:15:57 <opqdonut> > let x !! y = x + y in 3 !! 2
00:16:01 <lambdabot>  5
00:16:02 <jle`> you normally can't give two functions the same name
00:16:04 <warpy> or you could make up your own operator, like ~!
00:16:16 <jle`> so you can't give two operator-functions the same operator-name/symbols
00:16:37 <jle`> but haskell has an "overloading" faculty called typeclass that lets you generalize functions to work on muiltiple types
00:16:59 <Tjr> so I can do "f :: Customtype -> Int" and "f :: BinTree -> Int" at the same time?
00:16:59 <carter> warpy: whats your use case?
00:17:09 <jle`> Tjr: you can't
00:17:13 <carter> and why can't it be one big single cabalized project?
00:17:18 <Tjr> bummer :-(
00:17:21 <jle`> but you can do f :: MyClass a => a -> Int
00:17:25 <carter> OR: host your own private copy of hackage
00:17:29 <jle`> and have both Customtype and BinTree be instances of MyClass
00:18:10 <jle`> but this really is in general not encouraged --- making your own typeclasses and stuff to do tricks like this
00:18:30 <Tjr> This is the first time I find something that C++ can do but Haskell can't.
00:18:43 <carter> ‘whcih?
00:18:44 <opqdonut> no, if f has the same "meaning" in both cases making a type class for it is correct
00:18:46 <Tjr> or Mathematica, for that matter.
00:19:04 <jle`> Tjr: have two functions with the same name?
00:19:05 <carter> jle`: Tjr  SPECIALIZE pragma
00:19:08 <carter> and type classes
00:19:10 <opqdonut> Tjr: if you want type-based dispatch, i.e. overloading, you want type classes
00:19:15 <jle`> why would that be a good thing? :P
00:19:22 <carter> :P
00:19:26 <carter> night all
00:19:52 <kazagistar> how is classy prelude?
00:20:18 <carter> not so classy :)
00:20:19 <carter> night all
00:20:25 <jle`> Tjr: the (+) function is "overloaded" to all number types
00:20:27 <Tjr> Mainly because functions that do similar things between different categories are usually denoted with the same symbol in mathematics.
00:20:37 <jle`> which means that it is of type (+) :: Num a => a -> a -> a
00:20:55 <jle`> so any type that is a part of the Num typeclass can use (+)
00:21:23 <Tjr> for example, frac{\partial}{ \partial x} is defined in \R^n, on manifolds, as Gateau derivative, and so on.
00:21:29 <Tjr> GAteaux
00:21:36 <jle`> if you open up ghci, you can type :i Num
00:21:42 <jle`> and see all types that are Num in scope
00:21:51 <jle`> and all types that (+) is "overloaded" on
00:22:10 <jle`> if there was a derivative function, it would presumably be "overloaded" on differentiaable things as well
00:22:11 <Tjr> neat
00:22:12 <kazagistar> it just happens that !! is not really useful very often at all, but the lack of a typeclass is a little annoying for me
00:22:14 <jle`> using typeclasses
00:22:20 * Tjr feels like a baby, discovering new things all day.
00:22:37 <jle`> it's just that in this sense, it is a more disciplined "ad-hoc polymorphism"
00:23:09 <jle`> if you write a function like f x y = x + y, ghc will infer the type as "Num a => a -> a -> a"
00:23:27 <jle`> because it knows that because you used (+), you must be passing in "(+)-abble things"
00:23:40 <jle`> you know that f x y takes two things that can be (+)'d
00:23:55 <jle`> which translates to, two things in the Num a type class
00:23:57 <kazagistar> Tjr: a big advantage of typeclasses is that implementations can be separate of the of the data declaration, and that functions can dispatch based on multiple parameters
00:24:32 <jle`> if you could define (+) on anything, what would something like f x y = x + y infer to?
00:24:41 <jle`> f :: um...anything goes
00:24:41 <Tjr> So how do you "look" into the code?
00:24:56 <jle`> but because we have typeclasses, we have a disciplined way of saying "things that are (+)-abble"
00:25:04 <jle`> but in that sense (+) is "owned" by the Num typeclass
00:25:08 <Tjr> For example, in Mathematica, I can extract the first part of an< expression with [[1]], not just of lists
00:25:36 <jle`> look into the code?
00:25:45 <Tjr> so if I want to see the first summand to a symbolic sum, I can just do (foo + bar + baz)[[1]] and it will return bar
00:26:04 <jle`> well, haskell isn't a symbolic math language
00:26:22 <jle`> also, being able to inspect the definition of a function miight break referential transparency
00:26:23 <Tjr> Of course, sums aren't always useful to dissect, but Lisp macros are based on the same idea.
00:26:29 <jle`> according to some
00:26:49 <Tjr> so the question really is: how do you write something like Lisp-style macros in haskell?
00:27:27 <sjy> Tjr: http://www.haskell.org/haskellwiki/Template_Haskell ?
00:27:33 <jle`> you can't directly inspect the AST of haskell code (meta programming style), per se.  there are extra-haskell features like Template Haskell that allow you to do this, but
00:27:44 <jle`> haskell's power usually means that metaprogramming is unecessary
00:27:47 <kazagistar> Tjr: usually, you don't. if you have a specific use case for macros, haskell tends to have a strongly typed way around it, though template haskell helps with boilerplate automation
00:28:08 <jle`> we usually use higher order functions and laziness and a strong type system to do what lisp needs to do with metaprogramming
00:28:20 <dmj`> haskell doesn't need macros: http://neilmitchell.blogspot.com/2007/01/does-haskell-need-macros.html
00:29:07 <Tjr> That's an interesting thought. I'll keep it in mind and see how things wil turn out.
00:29:07 <hmax_> doesn't haskell have TH instead of macros?
00:29:26 <jle`> GHC offers Template Haskell for some limited metaprogramming capabilities
00:29:34 <dmj`> hmax_: TH is only at compile time, not runtime
00:29:45 <hmax_> oh, runtime macros
00:29:51 <hmax_> that's some scary stuff right there
00:29:57 <Ralith> lisp macros are compiletime too...
00:30:17 <dmj`> hmax_: you can hot swap code and perform type safe conversions
00:30:58 <Ralith> TH is pretty much the obvious analog of lisp macros
00:31:03 <Tjr> Lisp has both programmer-sitting-at-the-desk-time macros and rewrite-the-code-while-it's-being-executed-time macros
00:31:26 <Tjr> I've found the ability to inspect the syntax tree quite useful in mathematica.
00:31:37 * Ralith wonders what lisp Tjr is thinking of
00:32:11 <jle`> Tjr: useful in mathematica, but you won't be writing haskell the same way you write mathematica :)  and the uses you have had it for in mathematica might be done much easier and much more elegantly using haskell idioms
00:32:27 <jle`> this is why people say that knowing other languages before learning haskell usually hinders you
00:32:46 <jle`> haskell is easy, as long as you don't have any existing knowledge to bring in :)
00:33:09 <DaveS> I dunno about that. If you don't know what's going on under the hood in haskell you can get in a lot of trouble
00:33:19 <Tjr> To be fair, knowing other languages is what made me recognize that the functional programming concepts of Haskell have value.
00:33:45 <Tjr> s/have value/are valueable/
00:33:46 <jle`> Tjr: mhm. but to actually learn haskell...
00:33:52 <jle`> enough to write it
00:35:48 <jle`> basically, the idea is that you try to bring in 'useful things' from other languages, or worry about why concepts you have learned from other languages don't fit in
00:36:04 <startling> DaveS: I don't know. "a lot of trouble" is generally "your code works, but ..."
00:36:06 <jle`> there is a strong sense of vertigo when you first realize 'i can't do ___?  but then...how will i ever do ___ or ___ or ___?"
00:36:30 <startling> strictly better than the other thing.
00:37:17 <Tjr> As an aside, I've been meaning to write a tutorial "how to do everything the C++ tutorial teaches you, in Mathematica, without pulling your hair"
00:37:33 <hmax_> Mathematica is pretty weird
00:37:38 <Tjr> (I guess the same applies to "in Haskell")
00:37:48 <hmax_> though it can do lots of awesome stuff
00:37:54 <kazagistar> Tjr: i'd be interested in seeing it when its done
00:37:57 <hmax_> but still, programming in it is pretty weird
00:38:08 <hmax_> even after exposure to functional programming
00:38:12 <Tjr> Things aren't always obvious in Mathematica, but the premature conclusions like "Matehmatica doesn't have object oriented programming" are just nonsense.
00:38:18 <kazagistar> how does mathematica do on performance?
00:38:37 <hmax_> it's an interpreted language
00:38:42 <Tjr> But those conclusions are a very real hindrance to people adopting new languanges, be it Mathematica or haskell.
00:38:43 <hmax_> without JIT, as far as i can tell
00:38:56 <Tjr> kazagistar: I've never really looked into that aspect.
00:38:57 <hmax_> but there is an extension, that allows you to convert mathematica's code to C
00:39:24 <hmax_> http://reference.wolfram.com/mathematica/CCodeGenerator/tutorial/Overview.html - there it is
00:40:15 <xxx-man> hmax_: any program written in mathematica can one convert into C?
00:40:42 <hmax_> xxx-man, I kinda doubt that
00:40:49 <xxx-man> hmax_: usualy, to write program in matheamtica is easy
00:41:07 <xxx-man> and if tehr eis such faccilieties is great
00:41:37 <DaveS> Best thing about mathematica is all the data sets and structures they have collected
00:42:03 <hmax_> my problem with mathematica is amount of memory it likes to hog :(
00:42:17 <Tjr> ok, back to the point of depart.
00:42:29 <Tjr> Is there some easy way to inspect the syntax/parse tree in haskell?
00:42:49 <hmax_> i've tried doing some kaggle stuff with it, it took 6G+ of ram and left my pc wondering
00:43:17 <kazagistar> Tjr: not at runtime, and the problem is likely solved better in another way
00:43:19 <DaveS> making mathematica performant is tough
00:43:26 <Tjr> kazagistar: thanks
00:43:55 <DaveS> the obvious way is almost always bad
00:44:44 <dmj`> Tjr: why would you need to inspect the "parse tree"? What is the goal?
00:45:05 <Tjr> I'd like to know where I f%&/ed up and why the compiler is complaining.
00:45:18 <Tjr> Generally speaking.
00:45:35 <kazagistar> does the pagelong compiler message not help enough? :P
00:45:39 <dmj`> Tjr: oh ghc will tell you when it's not happy before you ever get to compiling
00:46:02 <DaveS> kazagistar: You'd think, ironically it just makes people angry lol
00:46:13 <Tjr> I can understand that :-)
00:46:13 <hmax_> if you don't use some shady stuff that delays type errors until runtime
00:46:46 <hmax_> honestly, I have a feeling that there is some ghc-extension or way to do what Tjr is trying to do
00:46:50 <tdammers> Main.hs:1:1: Error: I don't like your face.
00:46:57 <hmax_> but this is not a haskell way
00:46:58 <kazagistar> DaveS: I used to get angry, now I just laugh and start reading the love essay ghc wrote for me
00:47:27 <Tjr> tdammers:  :-)
00:47:39 <dmj`> if you hit a runtime error that's like an accomplishment
00:47:39 <dmj`>  
00:47:54 <kazagistar> > undefined
00:47:56 <lambdabot>  *Exception: Prelude.undefined
00:48:03 <kazagistar> I am accomplished!
00:48:03 <Tjr> dmj`: I've done that within 2 days, so it can't be that big an accomplishment
00:48:14 <dmj`> Tjr: what was it?
00:48:22 <kazagistar> > head [] -- mad skillz
00:48:24 <lambdabot>  *Exception: Prelude.head: empty list
00:48:40 <Tjr> I don't quite remember. Something very dumb.
00:48:56 <dmj`> like taking the head of an empty list
00:48:59 <Tjr> err, I defined a function recursively but forgot to add one case.
00:49:15 <kazagistar> > (Just x -> show x) Nothing -- I can do this all day
00:49:17 <lambdabot>  Pattern syntax in expression context: Just x -> show x
00:49:25 <kazagistar> errrrr
00:49:50 <dmj`> Tjr: the compiler will warn you if the patterns are not exhaustive
00:49:51 <kazagistar> > (\(Just x) -> show x) Nothing
00:49:53 <lambdabot>  "*Exception: <interactive>:3:2-20: Non-exhaustive patterns in lambda
00:50:13 <Tjr> that forgotten case triggered a "non exhaustive" warning, but only after I tried to execute it in ghci
00:57:01 <Tjr> What are rank-2 types?
00:57:03 <Tjr> http://neilmitchell.blogspot.de/2007/01/does-haskell-need-macros.html
00:57:34 <shachaf> What sort of answer are you hoping for?
00:58:27 <DaveS> > sum (map Data.Char.digitToInt (show (666^51)))
00:58:28 <Tjr> easy, but descriptive enough so I can imagine what the blog post is talking about.
00:58:29 <lambdabot>  666
00:58:35 <shachaf> @google What are rank-2 types?
00:58:36 <lambdabot> http://www.haskell.org/haskellwiki/Rank-N_types
00:58:36 <lambdabot> Title: Rank-N types - HaskellWiki
00:58:51 <Tjr> thanks
00:58:57 <Tjr> Sorry I didn't try that first.
01:00:32 <DaveS> > sum (map Data.Char.digitToInt (show (666^47)))
01:00:34 <lambdabot>  666
01:01:01 <kazagistar> what is this witchcraft?
01:01:09 <DaveS> Demonumerology
01:02:31 <shachaf> > filter (\x -> (sum . map digitToInt . show) (666^x) == 666) [0..100]
01:02:33 <lambdabot>  [47,51]
01:03:04 <FreeFull> > filter (\x -> (sum . map digitToInt . show) (666^x) == 666) [0..1000]
01:03:06 <lambdabot>  [47,51]
01:03:13 <FreeFull> Are those the only two numbers?
01:03:13 <DaveS> I think thats all of them lol
01:03:29 <DaveS> well no
01:03:33 <DaveS> 1111111111111....
01:03:44 <DaveS> no wait
01:03:46 <DaveS> haha
01:03:52 <DaveS> that's it
01:05:11 <DaveS> > 6^3 + 6^3 + 6^3 + 6 + 6 +6
01:05:13 <lambdabot>  666
01:11:03 <u-ou> > let i = 1; v = 5; x = 10; l = 50; c = 100; d = 500; in sum [i,v,x,l,c,d] -- I am in all numbers.
01:11:05 <lambdabot>  666
01:12:55 <FreeFull> u-ou: doesn't have m though =P
01:13:15 <u-ou> that was invented later :P
01:13:26 <u-ou> iirc
01:57:42 <akegalj> i have [(a,b)] and [(a,c)] which aren't of same size. I need to get [(a,b,c)]. I have couple ideas but they are not elegant :/  speed is not issue, list lnegths will be less then 50
01:58:37 <mmmm> what are your ideas
01:59:46 <akegalj> mmmm: i would do some kind of mapping through first list and finding key a inside second list, then composing tripple
02:00:36 <mmmm> how about you try sorting each list first
02:01:15 <akegalj> mmmm: zipping is out couse they are of different length
02:01:32 <akegalj> mmmm: if you were to purpose that
02:01:40 <mmmm> so what do you do when one key doesn't exist in the other list?
02:02:03 <frerich> Given a standard parser type like 'type Parser a = String -> [(a, String)]', is there a good way to enforce the invariant that the length of the second tuple elements (the 'unparsed input') is never longer than the given input? Or would this need dependant types?
02:03:01 <mmmm> akegalj: or another way would be to use a data structure like data.map, dump the first list in there and then query by items in the second list to construct your answer
02:04:13 <merijn> frerich: That needs dependent types, yes. You could probably somewhat fake it using GHC extensions, but it'll be ugly and likely not worth the effort
02:05:57 <merijn> mmmm: Ooooorrr...
02:06:05 <merijn> :t M.intersectionWith
02:06:07 <lambdabot> Ord k => (a -> b -> c) -> M.Map k a -> M.Map k b -> M.Map k c
02:06:17 <merijn> eh
02:06:23 <merijn> I guess that needs
02:06:26 <merijn> :t M.intersectionWithKey
02:06:27 <lambdabot> Ord k => (k -> a -> b -> c) -> M.Map k a -> M.Map k b -> M.Map k c
02:06:31 <akegalj> mmmm: yes, data.map would be ok maybe
02:07:20 <k00mi> frerich: we can't really say anything about the length of Strings at the type level
02:07:31 <merijn> :t M.intersectionWith (\a b c -> (a, b, c))
02:07:33 <lambdabot> Ord k => M.Map k t -> M.Map k t1 -> M.Map k (t2 -> (t, t1, t2))
02:07:38 <merijn> hmmm
02:07:45 <frerich> k00mi: Sure, but I only wanted to express that the second string is never longer than the first, irrespective of the particular value.
02:07:49 <merijn> :t M.intersectionWithKey (\a b c -> (a, b, c))
02:07:50 <lambdabot> Ord t => M.Map t t1 -> M.Map t t2 -> M.Map t (t, t1, t2)
02:08:13 <frerich> k00mi: I suppose a simplified case might be 'safeTail' where a similiar assertion should hold.
02:08:17 <bjornars> merijn: that lambda being equivalent to (,,)?
02:08:53 <merijn> bjornars: Ah, true
02:08:59 <akegalj> merijn: yes, that seems usefull too
02:09:46 <k00mi> frerich: I understand, but we can't say *anything* about the length of a String, not even relative
02:13:35 <frerich> k00mi: Pity! :-) Something like 'safeTail :: (x :: [a]) -> (x' :: [a]) |  (length x' <= length x)' would be funky (I hope that fake syntax makes sense...). My primary interest would not so much in getting better type checking (that'd be a nice plus though) but rather in  making the type more descrpitive. If the compiler implicitely generates code for asserting that the invariant alwaays holds, that'd be fine -
02:13:35 <frerich>  i.e. I could live with run-time checking instead of compile-time checking.
02:16:31 <kazagistar> frerich: wrapping things in a newtype, and wrapping the constructor/accessors in verification code, is a common way to use the type system to enforce otherwise difficult invariants
02:16:44 <rtpg> also dependent types ;)
02:17:42 <frerich> kazagistar: sure, but how would that help in the 'safeTail' example I just sketched?
02:20:10 <merijn> frerich: Define a newtype and only allow operations that shorten the String on said type?
02:21:03 <frerich> merijn: ouch ;-)
02:22:46 <merijn> frerich: And this is *much* less painful than the "fake DT in haskell" approach, so imagine that
02:33:33 <yitz> frerich: it's possible to represent pairs of lists (x,y) where y is not longer than x by the type ([(a,b)],[a]), where the two original lists are given by the map (ps,qs) -> (map fs ps ++ qs, map snd ps)
02:36:17 * hackagebot HTTP 4000.2.16 - A library for client-side HTTP  http://hackage.haskell.org/package/HTTP-4000.2.16 (GaneshSittampalam)
02:36:19 * hackagebot HTTP 4000.2.17 - A library for client-side HTTP  http://hackage.haskell.org/package/HTTP-4000.2.17 (GaneshSittampalam)
02:36:55 <kini> yitz: s/fs/fst/ I guess?
02:37:10 <|akh|> Hello. When using Crypto.Hash, shouldn't digestToHexByteString (hash "something" :: Digest MD5), or show . hash, give the same hash as running "echo something | md5sum" in bash?
02:37:26 <shachaf> echo probably includes a newline.
02:37:32 <yitz> kini: right sorry
02:37:48 <kini> you might try `echo -n` ("do not output the trailing newline")
02:39:02 <warpy> why is the HTTP library versioned 4000.. ?
02:39:04 <|akh|> shachaf: kini: Thank you, that was the "problem".
02:40:09 <merijn> warpy: No particular reason, afaict?
02:42:12 <warpy> i find it funny
02:43:34 <BoR0> how can one pass the same list between forked IO's? I want a list of clients visible to all clients. I'm writing a small chat application and I want to be able to broadcast a message
02:43:58 <merijn> BoR0: Look into the stuff under Control.Concurrent?
02:44:03 <warpy> BoR0: use a channel
02:44:08 <merijn> BoR0: i.e. IORef, Chan, MVar, STM
02:44:24 <BoR0> I see
02:44:29 <BoR0> ok. thanks
02:44:39 <merijn> BoR0: Lots of built-in primitives in GHC :)
02:45:05 <BoR0> would it be possible to do it without Control.Concurrent.Chan?
02:45:13 <kini> frerich: btw, a type like that in, say, Coq, would look like "safeTail (a : Set) (x : list a) : exists x' : list a, length x' <= length x"
02:45:22 <BoR0> I mean, is there a way to pass a variable through forkIO other than using Control.Concurrent
02:46:03 <kini> well, probably {a : Set} rather than (a : Set) (making the type parameter implicit)
02:46:15 <yitz> warpy: i think it was something like this: at some point there was a complete rewrite of the library. they bumped the major version to a multiple of 1000 to emphasize that it was completely new. since then, the major version has been kept at multiples of 1000.
02:46:55 <frerich> kini: Interesting! That's surprisingly close to what I had in mind :)
02:47:06 <warpy> BoR0: sure, it should work
02:47:13 <BoR0> warpy, how?
02:47:24 <kini> frerich: btw, I proved that theorem as follows: "exists x. auto. Qed." :P
02:47:51 <warpy> for a simple value (not a variable), the code in fork can refer it safely
02:47:57 <warpy> because it is immutable
02:48:13 <kini> proof-irrelevant mathematics, code-irrelevant programming ;)
02:48:25 <warpy> if you want to share mutable variables between threads, use MVar or TVar
02:49:14 <BoR0> warpy, what's MVar and TVar? how is it implemented?
02:49:14 <warpy> yitz: that is strange, isnt it?
02:49:42 <warpy> MVar -> Mutable Variable, TVar -> Transactional Variable
02:50:18 <warpy> BoR0: read this http://chimera.labs.oreilly.com/books/1230000000929/ch07.html
02:50:20 <yitz> warpy: iirc the first x1000 version was 2000, a commonly used number to represent "something completely new" just after the turn of the millenium.
02:50:39 <yitz> warpy: this library has been around for a while
02:50:56 <warpy> yitz: so v4000 is from future?
02:51:48 <yitz> warpy: i guess. they just stuck with multiples of 1000 once they had 2000.
02:53:29 <warpy> i suppose ghc of future has amazing backward compatibility
02:53:53 <yitz> @google beautiful concurrency
02:53:55 <lambdabot> http://www.cmi.ac.in/~madhavan/courses/pl2009/reading-material/spj-beautiful-code.pdf
02:53:55 <lambdabot> Title: Beautiful concurrency
02:54:04 <yitz> BoR0: ^^
02:54:10 <BoR0> warpy, yitz, thanks
03:01:20 * hackagebot learn-physics 0.4.1 - Haskell code for learning physics  http://hackage.haskell.org/package/learn-physics-0.4.1 (ScottWalck)
03:16:22 * hackagebot learn-physics 0.4.2 - Haskell code for learning physics  http://hackage.haskell.org/package/learn-physics-0.4.2 (ScottWalck)
03:20:15 <Tjr> Why does LYAH advise to use "null xs" instead of "xs == []"?
03:21:28 <Twey> Tjr: ‘null xs’ also works when xs doesn't have an Eq instance.
03:21:43 <Tjr> thanks
03:22:15 <Twey> > [(+ 1), id] == []
03:22:17 <lambdabot>  No instance for (GHC.Num.Num a0) arising from a use of ‘GHC.Num.+’
03:22:17 <lambdabot>  The type variable ‘a0’ is ambiguous
03:22:17 <lambdabot>  Note: there are several potential instances:
03:22:17 <lambdabot>    instance GHC.Num.Num GHC.Types.Double
03:22:17 <lambdabot>      -- Defined in ‘base:GHC.Float’
03:22:20 <frerich> Tjr: E.g. 'null [sum]' type checks but '[sum] == []' doesn't.
03:22:22 <Twey> > null [(+ 1), id]
03:22:24 <lambdabot>  False
03:24:06 <Tjr> Is there a way to force haskell to compare elements (and return false if they are only "apparently" different, e.g. nut fully simplified), such as === in Mathematica?
03:24:17 <yitz> @type (== [])
03:24:18 <lambdabot> Eq t => [t] -> Bool
03:24:21 <yitz> @type null
03:24:22 <lambdabot> [a] -> Bool
03:25:20 <yitz> Tjr: in Haskell, the notion of equality for any type you define is determined entirely by you.
03:25:51 <Tjr> In Mathematica, === tests for equality of the syntax tree of both expressions
03:26:14 <k00mi> Tjr: no, haskell doesn't have anything like that
03:26:17 <Tjr> ok
03:26:34 <yitz> Tjr: you can define a type representing syntax trees of expressions, and define equality for that type.
03:27:02 <yitz> Tjr: but that is not how every value in haskell is defined by default.
03:27:36 <Tjr> I guess that's right next to "where are macros in haskell?", right?
03:27:49 <k00mi> Tjr: GHC has Template Haskell
03:28:05 <k00mi> that's as close to macros as it gets
03:28:37 <yitz> Tjr: right. you can take a feature from some other language and find that haskell, being a different language, doesn't work that way.
03:28:47 <k00mi> I don't think there is any information about the syntax tree at runtime
03:29:11 <quchen> Well you can write a DSL and work the syntax tree manually.
03:29:12 <yitz> Tjr: but a more interesting question is: how would you do in haskell the kinds of things you use that feature for in that other language
03:29:24 <Tjr> :-)
03:29:38 <Tjr> I sometimes inspect the syntax tree to find out what I did wrong.
03:29:58 <Tjr> I guess learning haskell also means learning a different way to think
03:30:34 <tdammers> It means you actually have to think
03:30:35 <yitz> Tjr: i must admit that answering those kinds of questions about mathematica features is much more fun than answering them about OO features, which are more commonly asked about.
03:30:36 <tdammers> :D
03:31:01 <Tjr> tdammers: that can be an advantage or a disadantage :-)
03:31:45 <Tjr> yitz: I like the way you think :-)
03:32:11 <tdammers> Tjr: I enjoy thinking. It baffles me how many people don't, though.
03:32:38 <yitz> tdammers: that's something to think about
03:33:10 <tdammers> yitz: if that's your thing... :x
03:33:15 <Tjr> [off-topic] what I dread most about interview-type situations is the social norm that you have to hide that you think or are creative. Unfortunately, it freaks out most people.
03:49:54 <osfameron> Tjr: oh?  I must be applying for the wrong jobs :-)
03:51:43 <Tjr> osfameron: entry level job interviews, smalltalk with new people in the gym / club / social circle, meeting non-technical people at parties, academic conferences which aren't quite about your own area of research, ...
03:52:19 <Tjr> ... chit-chat in (natural) language classes, ...
03:54:26 * eikke__ really likes chrisdone's haskell.org mockup
03:55:41 <osfameron> yeah, I see what you mean in other areas.  I guess I'm some way past entry-level job apps, thankfully
03:56:08 <Omneh> I'm trying to use the SDL2 bindings, and I'm having a bit of trouble understanding how to setup an unallocated foreign pointer as an out value, (because that's an impure sideeffect and introducing state, etc.)  I'm sure I'm doing something horribly wrong, this is my first haskell project.
03:56:42 <Omneh> The reason why I think I need this is I'm trying to run createWindowAndRenderer, which takes a Window Ptr and Renderer Ptr in.
04:00:44 <exicer_> On the two most recent versions of Snap on hackage, I can't view the documentation. Why is this ?
04:01:56 <merijn> exicer_: Documentation hasn't build/wasn't uploaded yet?
04:03:52 <exicer_> One of them is like 20 days old, it seems a bit strange that it isn't built yet no ?
04:04:16 <k00mi> the build might have failed
04:04:18 <exicer_> admittedly I don't really know how hackage works
04:04:43 <merijn> exicer_: hackage just has a batch process that attempts to build haddocks, if the build of a package doesn't function haddock can't build documentation
04:05:16 <merijn> So if a package has broken dependencies or uses some C library that is missing the documentation will never build
04:05:26 <merijn> exicer_: But why not just use local documentation?
04:05:35 <exicer_> merijn: I have never done this.
04:05:46 <exicer_> merijn: How do I do so with a sandbox ?
04:06:08 <merijn> exicer_: You just add "documentation: True" to your ~/.cabal/config and cabal will build and install documentation for everything you install
04:06:25 <merijn> With a sandbox I assume that it just puts the docs inside the sandbox directory
04:07:22 <exicer_> merijn: Huh, useful. Okay, I will try that
04:07:40 <exicer_> merijn: Do you know of any document integration into emacs ?
04:08:34 <merijn> Nope, I don't use emacs
04:08:41 <exicer_> merijn: Fair enough :)
04:09:18 <merijn> exicer_: For global install it just build a HTML index in ~/.ghc or ~/.cabal which has an index.html list of installed packages that have documentation that you can browse
04:19:23 <Tjr> This works: 1 + ( sum $ [1..10]  )
04:19:23 <Tjr> This doesn't:  1 + $ sum $ [1..10]
04:19:23 <Tjr> I thought $ is the same as parentheses. What's going on?
04:20:14 <flux> @type ($)
04:20:15 <lambdabot> (a -> b) -> a -> b
04:20:15 <zwer_h> it isn't, it is a function
04:20:19 <zwer_h> > (1+) $ sum $ [1..10]
04:20:21 <lambdabot>  56
04:21:15 <zwer_h> @src ($)
04:21:15 <lambdabot> f $ x = f x
04:21:41 <zwer_h> <function> $ <argument>
04:22:01 <Tjr> So you're saying I have to put $ to the right of some function?
04:22:10 <zwer_h> yes
04:22:27 <Omneh> Tjr, $ is not exactly the same as a space
04:22:31 <pavonia> 1 + ( sum $ [1..10] ) == 1 + sum [1..10], btw
04:22:36 <Tjr> And + isn't a function because the parser doesn't yet see it's  "1 + foo" when it's evaluating "$"?
04:22:45 <yitz> @type (+)
04:22:46 <lambdabot> Num a => a -> a -> a
04:22:56 <Tjr> pavonia: the real example is a bit more complicated ...
04:23:06 <yitz> Tjr: + has higher precedence than $
04:23:13 <adas> :t ($)
04:23:14 <merijn> Tjr: Haskell distinguishes between operator functions and non-operator functions
04:23:14 <lambdabot> (a -> b) -> a -> b
04:23:34 <Raydiation> what is confluence, cant find it on google, so much company ads etc
04:23:34 <Omneh> Tjr, $ is simply very low precedence function application
04:24:10 <merijn> Raydiation: https://en.wikipedia.org/wiki/Confluence_(abstract_rewriting)
04:24:14 <humanoyd> Tjr: (+) 1 $ 2
04:24:14 <Raydiation> merijn: ty
04:24:37 <merijn> Raydiation: Confluence basically means "eventually converges to a single result"
04:24:37 <Tjr> thank you everybody
04:25:13 <Raydiation> merijn: makes sense, thanks :)
04:25:45 <merijn> Raydiation: For example, the simply typed lambda calculus has confluence as any possible reduction implementation will always converge to the same end result, regardless of which route and how many steps that route has
04:26:01 <yitz> Tjr: when you define an infix function, it gets a precedence between 1 and 9, where 9 is lowest precedence. prefix function application has precedence 0, record notation has precedence -1, and type annotation :: has precedence 10.
04:26:19 <merijn> yitz: I think you mean the reverse
04:26:35 <merijn> :: has -1, prefix application 10 and record syntax 11
04:26:38 <Tjr> what is record notation?
04:27:00 <yitz> merijn: oops right. reverse [1..9].
04:28:00 <yitz> also i see that $ has precedence 0, so that can also be assigned. so type annotation is -1, function application 10, and record notation 11. did i get it right now?
04:28:29 <frerich> yitz: The higher the number, the lower the precedence. I.e. the other way round.
04:28:41 <frerich> er
04:28:46 <frerich> dammit I repeated what you wrote
04:28:52 <frerich> The higher the number, the *higher* the precedence :)
04:28:55 <yitz> frerich: yeah it's actually logical - higher number is higher precedence.
04:30:43 <yitz> in some other popular languages, like C, it is traditional to number precedence the other way around. my brain has been poisoned.
04:33:39 <Raydiation> why is operator associativity not the same as confluence? if terms are evaluated in a different order and the operators of
04:33:48 <Raydiation> + are not associative its not confluent right?
04:34:27 <Raydiation> or is the difference simply that operator associativity can be a reason why a system is not confluent
04:35:03 <Raydiation> (as in addition of floats depends on the order of execution)
04:36:37 <merijn> Raydiation: Your use of associative appears to be confused?
04:37:26 <merijn> Raydiation: Associativity is "a + (b + c) = (a + b) + c", afaict you seem to be thinking of associativity + commutativity, commutativity being "a + b = b + a"
04:38:08 <Raydiation> merijn: float addition is not associative
04:38:09 <Tjr> Is there some way to delete definitions from ghci? Say I want to define f again and delete the original definition to make sure it doesn't "leak"
04:38:13 <merijn> Raydiation: I know
04:38:38 <Raydiation> so my system would not be confluent right?
04:38:47 <Raydiation> if i rewrite a float addition
04:38:49 <frerich> Tjr: I always just overwrite definitions, i.e. use 'let f = 1' and later 'let f = 2'
04:38:52 <merijn> Raydiation: Right
04:39:22 <Tjr> frerich: can that cause problems in any corner case? E.g. if the new f as different types?
04:39:27 <Raydiation> ok, so basically the difference is that operator associativity can influence confluence
04:39:35 <Raydiation> but confluence is not operator associativity
04:39:46 <awestroke> Is there anything like ruby's Guard for haskell? (Read config file, watch files/folders according to config rules, perform commands from config file on file update)
04:39:58 <FireFly> What is the definition of confluency?
04:40:13 <frerich> Tjr: I didn't notice any problems, no.
04:40:16 <merijn> Raydiation: Correct
04:40:26 <k00mi> Tjr: no, but note previous definitions that use the old f are not affected
04:40:28 <yitz> Tjr: it overwrites the previous definition.
04:40:42 <Tjr> k00mi: good point
04:41:16 <yitz> Tjr: k00mi is right. it does not overwrite the previous definition; it shadows it.
04:41:19 <k00mi> yitz: it doesn't overwrite, it shadows
04:41:23 <k00mi> heh
04:41:39 <Raydiation> merijn: thanks :)
04:42:06 <Tjr> I guess scoping at its finest :-)
04:42:11 <yitz> k00mi: however, if the old definition is not used in any other existing definition, the old value is garbage collected.
04:42:49 <yitz> so effectively, it is overwritten in that case.
04:42:52 <Tjr> Is there a way to find out which other thing is using the old defintion?
04:42:53 <hyPiRion> yitz: or reused, if the inliner + SSA detects it
04:43:10 <yitz> hyPiRion: i don't think inlining happens in ghci, does it?
04:43:37 <awestroke> Can I get a list of packages depending on package x on haskell?
04:43:40 <awestroke> hackage*
04:43:44 <hyPiRion> yitz: yeah, probably not in the ghci. I was talking about shadowing in general
04:44:07 <frerich> awestroke: Maybe you mean http://packdeps.haskellers.com/reverse ?
04:44:15 <yitz> @google packdeps
04:44:16 <lambdabot> http://packdeps.haskellers.com/
04:44:16 <lambdabot> Title: Hackage dependency monitor
04:46:27 <awestroke> frerich: great, thanks
04:50:24 <Tjr> Why is this a parse error?
04:50:24 <Tjr> let var = 1 ; print var
04:50:36 <Tjr> (in GHCi)
04:52:37 <geekosaur> because ; *also* separates bindings in let
04:52:51 <awestroke> Tjr: let var = 1 in print var
04:53:01 <Tjr> neat, thank you
04:53:02 <geekosaur> let { var = 1 }; print var -- but no guarantees here either as ghci parsing is a bit wonky
04:53:33 <Tjr> in awestroke's example, the variable var isn't available outside the print, right?
04:53:37 <geekosaur> point being let  a = 5; b = "foo" -- is legal Haskell
04:54:21 <awestroke> "let x = y in expr" <- x is only defined in expr. try it in ghci, and try to access x afterwards
04:55:16 <awestroke> > + (let x = 4 in x*2) (x + 3)
04:55:18 <lambdabot>  <hint>:1:1: parse error on input ‘+’
04:55:21 <Raydiation> hm, whats an example that does not depend on operator associativity and is not confluent?
04:55:25 <awestroke> > (+) (let x = 4 in x*2) (x + 3)
04:55:26 <lambdabot>  4 * 2 + (x + 3)
04:55:34 <awestroke> argh
04:55:43 <awestroke> > (+) (let var = 4 in var*2) (var + 3)
04:55:44 <lambdabot>  No instance for (GHC.Num.Num
04:55:44 <lambdabot>                     (GHC.Base.String -> Debug.SimpleReflect.Expr.Expr))
04:55:44 <lambdabot>    arising from a use of ‘GHC.Num.+’
04:55:47 <Raydiation> i thought of writing to a file but that is not associative in the first place
04:56:00 <awestroke> -_-
04:58:52 <merijn> Raydiation: Untyped lambda calculus
04:59:52 <merijn> Raydiation: Some reduction methods (for example, call-by-value) don't always converge
05:00:32 <opqdonut> there are expressions for which no reduction methods converge
05:00:37 <awestroke> :t var
05:00:39 <lambdabot> String -> Expr
05:00:46 <awestroke> :t xyz
05:00:47 <merijn> opqdonut: That too
05:00:47 <lambdabot> Not in scope: ‘xyz’
05:00:54 <awestroke> :t num
05:00:55 <lambdabot>     Not in scope: ‘num’
05:00:55 <lambdabot>     Perhaps you meant one of these:
05:00:55 <lambdabot>       ‘sum’ (imported from Data.List),
05:01:08 <opqdonut> (well, no reasonable/well-known reduction methods :)
05:01:26 <awestroke> > (let num = 4 in num*2) + (num + 3) -- Tjr
05:01:28 <lambdabot>  Not in scope: ‘num’
05:01:28 <lambdabot>  Perhaps you meant one of these:
05:01:28 <lambdabot>    ‘sum’ (imported from Data.List),
05:01:28 <lambdabot>    ‘F.sum’ (imported from Data.Foldable),
05:01:28 <lambdabot>    ‘enum’ (imported from Control.Lens)
05:02:19 <Raydiation> merijn: i see, thanks
05:02:30 <Tjr> awestroke: too bad it can't just return "num + 11"
05:03:42 <awestroke> Tjr: I was trying to demonstrate let scoping ;P
05:05:22 <Tjr> Is it possible to modify "fst :: (a, b) -> a " to operate on arbitrary tuples of unknown but finite length?
05:06:08 <opqdonut> Tjr: not simply, but there are some solutions
05:06:28 <Tjr> Can you give me a pointer, please?
05:07:02 <opqdonut> HList is one solution
05:07:37 <opqdonut> making a type class with a functional dependency is another: "class Fst a b | a -> b where fst :: a -> b"
05:07:38 * Tjr googles
05:07:48 <mmmm> If you want to do that then tuples are probably not the right thing
05:07:49 <opqdonut> but generally people don't do that in haskell
05:08:50 <opqdonut> tuples of different lengths are different types, so you don't really end up in the situation where a value x might be a 2-tuple or a 5-tuple
05:08:58 * Tjr likes playing with things to find out what's possible.
05:09:39 <Tjr> ... or reasonable, for that matter.
05:09:46 <MagneticDuck> anything is possible
05:12:04 <MagneticDuck> (as long as you can describe it)
05:12:25 <MagneticDuck> ...usually
05:12:47 <MagneticDuck> "anything you can do is possible"
05:12:57 <Tjr> "All standard Haskell types except for IO and functions are a part of the Eq typeclass." Is there some reasonable way to see if two functions are the same? (For example, you're building a hash of functions supplied form somewhere else and want to check if you've got the function already...)
05:12:58 <MagneticDuck> that's actually as far as I can get without making false assumptions
05:13:19 <MagneticDuck> Tjr: no.
05:13:24 <Tjr> In C-like languages, I'd compare funciton pointers.
05:13:32 <Tjr> In MAthematica, I'd use the === symbol.
05:13:40 <MagneticDuck> but you could try to make a data type isomorphic to a certain subset of functions you want to talk about
05:13:44 <MagneticDuck> oh, what kind of equality?
05:13:55 <opqdonut> yeah function equality is an elusive concept
05:14:00 <Tjr> If you can't compare things, how do you make a hash in haskell?
05:14:01 <opqdonut> especially in the presence of partial application
05:14:07 <MagneticDuck> Tjr: ?
05:14:18 <MagneticDuck> brb lunch
05:14:19 <merijn> Tjr: You can compare things, just not by identity
05:14:25 <opqdonut> Tjr: you use hashmaps for things that are hashable
05:14:39 <merijn> Tjr: In C functions and variables have an "identity" i.e. where they are stored in memory
05:14:44 <opqdonut> but mostly haskell code prefers sorted maps
05:14:47 <opqdonut> e.g. Map, IntMap
05:15:09 <merijn> Tjr: Haskell does not specify how haskell code translates to machine code, so there is no way to map functions/values to an address
05:15:12 <Tjr> so you put all the difficult problems that arise with functions (busy beaver,NP, ...) into the typeclass?
05:15:19 <merijn> Tjr: i.e. all haskell value are "identity"-less
05:16:11 <merijn> Tjr: So in haskell we compare equality by value. But deciding whether two functions "have the same value" basically means "verifying they return the same outputs for every input", which is clearly undoable
05:16:49 <Raydiation> fold takes a starting value, a list and a function and returns a single value right?
05:16:50 <eikke__> I've been looking into the packages Twitter open-sourced for 'big data' things. Most of it is Scala, but it'd be so nice to have a similar chain using Haskell
05:16:53 <Tjr> merijn: Ok, I was suspecting something like that by now.
05:16:54 <Raydiation> can the single value also be a list?
05:16:57 <tdammers> you could, theoretically, perform some dirty magic to confirm whether to functions are trivially identical
05:17:03 <Raydiation> as in the result
05:17:11 <tdammers> but that wouldn't be very useful, really
05:17:31 <Raydiation> can i implement map by using fold?
05:17:31 <zwer_h> Raydiation it can be anything. it can even be a function!
05:20:35 <Tjr> "The most used function that deals with the Show typeclass is show." Whoever wrote LYAH must have had a lot of fun.
05:21:48 <merijn> :t foldr (.) id -- indeed, fold can even take functions as "start" value
05:21:50 <lambdabot> [b -> b] -> b -> b
05:22:11 <merijn> Raydiation: Yes, it's fairly easy to implement map as a fold
05:24:34 <Raydiation> its nice how easy functions can be used to do all sorts of things :)
05:26:37 * hackagebot list-fusion-probe 0.1 - testing list fusion for success  http://hackage.haskell.org/package/list-fusion-probe-0.1 (JoachimBreitner)
05:29:02 <danilo2> Hello! :) I've got a question connected to control flow in Hasjkell. Basically I want to implement a dataflow image processing library, which allows to control the flow of data very precisely using mechanism called "timeShift". I've just posted a detailed question on SO. Would you be so nice and help me solve the problem? :) http://stackoverflow.com/questions/23869547/precise-flow-control-in-haskell
05:33:20 <kstt> Hi. The segment functions operates over a [ Maybe a ] to extract series of consecutive 'Just a' : http://lpaste.net/104643
05:34:05 <kstt> It works, but I'm baffled with this implementation. It looks very very verbose for what it does, I am sure it could be much more clever.
05:34:30 <kstt> What do you think ?
05:36:02 <frerich> kstt: I would try something with 'groupBy' and 'isJust'
05:36:36 <frerich> kstt: I.e. 'groupBy ((==) `on` isJust) l1` would return [[Nothing], [Just 1,Just 2,Just 3], [Nothing,Nothing], [Just 11,Just 12], [Nothing]]
05:36:55 <frerich> kstt: Then you'd just need to filter out the list elements whose head is 'Nothing'
05:38:36 <Raydiation> im currently trying to understand what the scan algorithm does (scanl in haskell iirc) and why its faster for parallel computation. Can I think of scan like merge sort? e.g. for summing up numbers, i partition the list until i have the same amount of lists as threads, then calculate the sum of each list and put it in a new list, partition again until one result is left?
05:39:05 <frerich> kstt: I think you could also define 'segments' as 'map (map fromJust) . filter (\(x:_) -> x /= Nothing) . groupBy ((==) `on` isJust)'
05:39:49 <kstt> > :t (map (map fromJust) . filter (\(x:_) -> x /= Nothing) . groupBy ((==) `on` isJust))
05:39:50 <lambdabot>  <hint>:1:1: parse error on input ‘:’
05:40:10 <kstt> hmph ... :)
05:40:17 <awestroke> :t \xs -> filter (not . null) . map catMaybes . groupBy (\a b -> isJust a == isJust b) xs
05:40:19 <lambdabot>     Couldn't match expected type ‘a -> [[Maybe a1]]’
05:40:19 <lambdabot>                 with actual type ‘[[Maybe a2]]’
05:40:19 <lambdabot>     Relevant bindings include
05:40:26 <kstt> thank you awestroke
05:40:45 <jesyspa> kstt: Alternatively, it looks like a fold where the accumulator is ([a], [[a]]) and op (Just x) (xs, res) = (x:xs, res); op Nothing (xs, res) = ([], xs:res)
05:40:54 <eizo> > map (map fromJust) $ wordsBy (== Nothing) [Just 1, Just 2, Nothing, Nothing, Just 3, Just 4, Just 5, Nothing]
05:40:55 <lambdabot>  [[1,2],[3,4,5]]
05:41:02 <awestroke> :t wordsBy
05:41:04 <lambdabot> (a -> Bool) -> [a] -> [[a]]
05:41:12 <jesyspa> (Perhaps with some extra logic to remove empty lists when you have consecutive cases.
05:41:17 <Raydiation> so basically: is scanl divide and conquer?
05:41:22 <jesyspa> s/cases/Nothings/
05:41:27 <kstt> nice trick eizo
05:41:30 <eizo> wordsBy takes care of empty segments
05:41:32 <awestroke> that's elegant, eizo
05:41:52 <eizo> thanks
05:41:59 <eizo> i found it here: http://hackage.haskell.org/package/split-0.2.2/docs/Data-List-Split.html
05:42:49 <frerich> eize: That's really neat, it didn't occur to me to use 'wordsBy' like that :-)
05:43:33 <eizo> :)
05:43:44 <kstt> ah, wordsBy if from this package
05:43:53 <kstt> is
05:44:54 <kstt> This will cause problems with my dependencyphobia
05:44:58 <kstt> ;)
05:45:18 <eizo> yes sorry
05:46:34 <m09> just a quick ad for a SO question that has had no love (about how to parse an external document during an XHT parse): https://stackoverflow.com/questions/23862417
05:47:42 <Raydiation> what is the benefit for using scanl over foldl? isnt the last element of scanl the return value of foldl?
05:48:10 <merijn> Raydiation: scans and folds do fundamentally different things
05:48:37 <merijn> Raydiation: You question is akin to "What is the benefit of pineapples over grapes?"
05:48:42 <awestroke> kstt: just steal the wodsBy definition from the package
05:48:44 <merijn> :t scanl
05:48:45 <lambdabot> (b -> a -> b) -> b -> [a] -> [b]
05:48:51 <merijn> :t foldl
05:48:52 <lambdabot> (b -> a -> b) -> b -> [a] -> b
05:49:08 <Raydiation> well, the difference is that you get a list instead of a single element
05:49:09 <merijn> Raydiation: Folds are for collapsing structures (lists) into a single result
05:49:23 <merijn> Raydiation: scans are for building structures (lists)
05:49:36 <merijn> The fact that you can collapse a list to a list is coincidental
05:49:43 <awestroke> > foldl1 (+) [a,b,c,d,e]
05:49:45 <lambdabot>  a + b + c + d + e
05:49:52 <awestroke> hmpf
05:49:59 <awestroke> > foldr1 (+) [a,b,c,d,e]
05:50:01 <lambdabot>  a + (b + (c + (d + e)))
05:50:17 <merijn> > scanl1 (+) [a,b,c,d,e]
05:50:19 <lambdabot>  [a,a + b,a + b + c,a + b + c + d,a + b + c + d + e]
05:50:32 <Raydiation> merijn: exactly
05:50:47 <Raydiation> i dont get why this can be faster if parallelized
05:50:51 <Raydiation> in terms of sums
05:51:05 <Iceland_jack> Raydiation: Because addition is associative
05:51:06 <Raydiation> because it needs to be computed in serial
05:51:07 <danilo2> Hello merijn! :) You've got always a bunch of great ideas - I would like to ask you If you could look at a problem I'm trying to solve for a very long time. Could I send you a link to it? (I've just posted it on Stack Overflow)
05:51:19 <Iceland_jack> Raydiation: it doesn't, but that's how scan does it
05:51:31 <Raydiation> as in list[1] depends on list[0]
05:51:49 <Iceland_jack> Search for 'parallel prefix scan'
05:52:12 <Iceland_jack> *sum
05:52:17 <merijn> danilo2: For dataflow type stuff like that you probably wanna look into netwire
05:52:29 <Raydiation> Iceland_jack: yes, thats what ive found http://en.wikipedia.org/wiki/Prefix_sum#Parallel_algorithm
05:52:35 <Twey> Raydiation: You can build a binary tree and perform only log n additions
05:52:41 <Raydiation> looks like divide and conquer to me
05:52:44 <Twey> (and in parallel, too)
05:53:24 <Tjr> How does the numerical conditioning work out if you're adding lots of floats?
05:53:38 <Tjr> I'd imaing you would want to start with chunks of approximately equal numbers
05:54:06 <Tjr> and put enough of them into each chunk so that the sum of each chunk is approximately the same order
05:54:07 <Iceland_jack> Tjr: Yes you'd have to take special precautions when working with non-associative operations
05:54:30 <danilo2> merijn: ok, thank you! I'm going to read about it right now
05:54:53 <Tjr> Do people do that? Does it make sense? Because when I raised that concern in school, I got brushed off.
05:55:15 <Iceland_jack> Sorting floating point numbers before adding them makes sense
05:55:56 <Iceland_jack> in ascending order
05:56:00 <tdammers> nothing makes sense with floating point "numbers"
05:56:02 <tdammers> :D
05:56:24 <Iceland_jack> As far as there is any sense, that makes sense
05:56:28 <Maior> heh
05:56:49 * Tjr swallows yet another pun.
05:57:25 <Iceland_jack> focusing on addition, adding two numbers of a similar magnitude is preferable to adding two numbers of different magnitude: there are pathological cases where this can really matter
05:57:44 <Hodapp> There are non-pathological cases where it can matter too.
05:57:58 <awestroke> Iceland_jack: floating point* numbers
05:58:46 <Iceland_jack> Tjr: there is a special algorithm called the Kahan algorithm for summation that deals with reducing errors with summation
05:59:20 <merijn> Tjr: People do that yes, in scientific computing it's really important to know exactly what precision your results have and how your algorithm affects them
05:59:46 <merijn> Tjr: If you mean "does the average working programmer do this?" the answer is "no, they don't even realise float addition is non-associative"
06:00:15 <Hodapp> merijn: It should be good enough for dollar amounts, right?
06:00:17 * Hodapp ducks
06:00:27 <Tjr> average working programmer = java people who don't know floats exists </sarcasm>
06:00:44 <hpc> java people all just use BigDecimal
06:00:45 <Hodapp> Tjr: they know enough about floats to be dangerous.
06:00:49 <Iceland_jack> No need to rip on Java people :)
06:00:58 <hpc> unless they need performance, then they use the 'float' primitive
06:01:34 <Ginto8> merijn: I guess I'm one of those programmers... I knew float addition is non-distributive, is it really non-associative too?
06:01:44 <hpc> 23 binary digits of precision is enough for anyone!
06:01:53 <awestroke> In game physics, you should aim to maximize the rounding errors and catastrophic cancellations, as unpredictability is fun
06:02:04 <merijn> Ginto8: As far as I remember, yes
06:02:07 <Ginto8> hpc: I have never seen Java code use float. It's doubles. Everywhere. C tends to use floats
06:02:22 <hpc> > (2 ** 50) - (2 ** 50 + 1)
06:02:23 <lambdabot>  -1.0
06:02:29 <Ginto8> merijn: wait, I might have my definition of associative wrong
06:02:31 <hpc> > (2 ** 50 - 2 ** 50) + 1
06:02:33 <lambdabot>  1.0
06:02:42 <hpc> er
06:02:48 <merijn> Ginto8: Associative = "a + (b + c) = (a + b) + c"
06:02:53 <hpc> that should be with addition and negative 2**50
06:03:04 <Tjr> wow, the kahan algo is really simple and ingenious.
06:03:04 <hpc> and the answers are 0, 1 because you lose precision at high exponents
06:03:22 <Ginto8> ohhh yup, I was thinking commutative :/ Though, since it isn't associative, it can't be commutative in all cases anyway
06:03:27 <hpc> Ginto8: associativity is (a + b) + c = a + (b + c)
06:03:39 <merijn> Ginto8: Right, they're definitely not commutative
06:03:59 <Tjr> what?
06:04:06 <Tjr> addition not commutative?
06:04:07 <hpc> merijn: what breaks commutativity?
06:04:27 <hpc> i expect it's something NaN-y
06:04:27 <Iceland_jack> it is commutative
06:04:46 <Hodapp> awestroke: I think the game Stunts on DOS had some interesting numerical issues
06:04:49 <merijn> hpc: Infinities, iirc
06:04:53 <Ginto8> yeah, I know floating point error first hand and painfully. They made my 3D renderer look like shit when I didn't handle them
06:04:58 <Hodapp> awestroke: if you hit certain things just right, your car would fly up in the air extremely high
06:04:59 <merijn> Tjr: *floating point* addition is not
06:05:24 <tdammers> merijn: it's not? I thought it was commutative, just not associative
06:05:25 <merijn> hpc: If we're going to admit NaN pretty much every guarantee disappears anyway
06:05:27 <awestroke> Hodapp: hah, that sounds like more than floating point errors
06:05:35 <Iceland_jack> ghci> (\a b c -> a + b + c == a + (b + c)) 1 (10^99 ∷ Double) (-10^99)
06:05:35 <Iceland_jack> False
06:05:39 <merijn> tdammers: I'm not 100% sure, I try to avoid floats :)
06:05:41 * frerich 's first contact with rounding errors was when his wireframe cube would eventually morph to something else after a couple of rotations... looks pretty funky!
06:06:03 <tdammers> merijn: yeah, that should be a given... I just don't see how float errors have to break commutativity
06:06:11 <Ginto8> hpc: adding things of wildly different magnitude, the precision of the result can depend the order of computation
06:06:13 <tdammers> you'd just prioritize them, and that's that
06:06:26 <Ginto8> since commutativity isn't guaranteed
06:06:37 <j`ey> frerich: that sounds cool
06:06:41 * hackagebot courier 0.1.0.14 - A message-passing library for simplifying network applications  http://hackage.haskell.org/package/courier-0.1.0.14 (PhilHargett)
06:08:17 <merijn> tdammers: Oh, addition is indeed commutative (barring NaN != NaN shenanigans)
06:08:58 <tdammers> so basically, you can assume that a + b == b + a
06:09:08 <tdammers> but not (a + b) + c == a + (b + c)
06:09:16 <merijn> IFF neither 'a' nor 'b' are NaN, yes
06:09:19 <tdammers> and that makes sense in the face of rounding errors
06:09:32 <tdammers> merijn: if either is NaN, you still get "some" NaN, right?
06:09:40 <tdammers> just not necessarily the *same* NaN
06:09:43 <merijn> tdammers: Yes, but NaN is never equal to NaN
06:09:52 <tdammers> ah, yeah... point taken
06:10:31 <Tjr> Again, in theory things are different. In measure theory, every positive infinity is the same.
06:10:36 <awestroke> :t NaN
06:10:37 <lambdabot> Not in scope: data constructor ‘NaN’
06:10:50 <awestroke> > 1.0 / 0.0
06:10:51 <lambdabot>  Infinity
06:11:06 <FireFly> > let nan = 0.0 / 0.0 in nan == nan
06:11:08 <lambdabot>  False
06:11:17 <awestroke> > 0.0 / 0.0
06:11:19 <lambdabot>  NaN
06:11:21 <merijn> Tjr: Well, IEEE754 specifies that there is only one positive infinity and only one negative infinity, so you can compare those for equality
06:11:23 <tdammers> Tjr: infinity is not a number, and allowing a number variable to hold something that is not a number is conceptually wrong
06:11:29 <awestroke> so what is NaN?
06:11:31 <awestroke> :k NaN
06:11:32 <lambdabot> Not in scope: type constructor or class ‘NaN’
06:11:38 <merijn> awestroke: NaN is Not-a-Number
06:11:46 <tdammers> 1.0 / 0.0 shouldn't evaluate to anything: it shouldn't evaluate AT ALL
06:11:47 <FireFly> awestroke: what `show` yields for the NaN value
06:11:55 <awestroke> merijn: yes I know, but how to I touch it with my haskell hands
06:12:01 <merijn> awestroke: You shouldn't
06:12:13 <tdammers> introducing non-values like NaN and infinities is kind of a concession to the reality of engineering
06:12:16 <merijn> awestroke: Also, the show instance doesn't distinguish the fact that there are multiple different NaN's
06:12:26 <keko_> > 1/0 == 1/0
06:12:28 <lambdabot>  True
06:12:38 <Ginto8> Tjr: Infinities and signed zero are pretty sensible in IEEE. Ordering and equality both work
06:12:42 <merijn> awestroke: If you want to know the gory details, read IEEE754
06:12:45 <Ginto8> Tjr: NaN is where it breaks down
06:12:50 <Tjr> Since we're discussing floating point issues: Is the built-in Haskell "==" comparison operator transitive?
06:12:55 <awestroke> merijn: so is NaN a special case of the type system that doesn't follow the same rules as other types?
06:13:07 <merijn> Tjr: For lawful implementation of Eq, yes.
06:13:24 <merijn> awestroke: What does that mean?
06:13:33 <merijn> awestroke: NaN has nothing to do with the type system
06:13:35 <Tjr> Some numerical libraries say (x == y ) if |x -y| is smaller than some epsilon.
06:13:54 <FireFly> I think they're confused about the lack of a data constructor for NaN
06:14:14 <awestroke> merijn: oh, now I get it... So Show Float just does something like if x != x then "NaN" else asd
06:14:20 <frerich> Tjr: I hope those numerical libraries don't use a fixed value for 'some epsilon' :-]
06:14:30 <Tjr> Some do
06:14:34 <Iceland_jack> @ty isNan
06:14:36 <lambdabot>     Not in scope: ‘isNan’
06:14:36 <Iceland_jack> @ty isNaN
06:14:36 <lambdabot>     Perhaps you meant ‘isNaN’ (imported from Prelude)
06:14:37 <lambdabot> RealFloat a => a -> Bool
06:14:43 <merijn> awestroke: Not really, it just uses bit level definition of the value of NaN to check for NaN
06:14:45 <Iceland_jack> > isNaN (0/0)
06:14:47 <lambdabot>  True
06:14:53 <Tjr> something like "equal except for the last 3 bits of the mantisse"
06:15:16 <Ginto8> Tjr: I don't believe Haskell uses tolerant comparisons in any of the default Eq implementations
06:15:22 <merijn> awestroke: Internally GHC just uses the hardware primitives for Float/Double operations, these include operations like checking for NaN, etc.
06:27:06 <Profpatsch> What would that pipe mean in class Monad m => Stream s m t | s -> t where ?
06:27:47 <Tjr> Profpatsch: guards
06:27:50 <Lethalman> Profpatsch, functional dependency
06:28:02 <Tjr> Profpatsch: sorry
06:28:13 <Lethalman> Profpatsch, http://www.haskell.org/haskellwiki/Functional_dependencies
06:28:19 <jml> I'm trying to run 'yesod devel', and getting this message: cabal: Cannot find the program 'ghc' at 'yesod-ghc-wrapper' or on the path
06:28:34 <jml> however, ghc does seem to be on the path
06:28:37 <Profpatsch> Ok, thanks.
06:28:50 <jml> I'm running on OS X
06:29:00 <geekosaur> Profpatsch, more specifically it means that the type s determines the type t; that is, if the compiler knows s, it knows there can be exactly one type t that goes with it
06:30:26 <pi3r> @twisla: j'ai un problme  l'installation de ruby-devel sur une machine  jour (centos 6.5  jour)
06:30:27 <lambdabot> Unknown command, try @list
06:30:40 <pi3r> Voici l'erreur: [root@puppetmaster alhazen]# yum install ruby-devel
06:30:41 <pi3r> Loaded plugins: changelog, fastestmirror, security
06:30:41 <pi3r> Loading mirror speeds from cached hostfile
06:30:41 <pi3r> Setting up Install Process
06:30:41 <pi3r> Resolving Dependencies
06:30:52 <Profpatsch> geekosaur: So more information that can show the programmer errors?
06:31:15 <Phlogistique> pi8028: je crois que tu t'es trompé de chan
06:31:21 <Phlogistique> oops
06:31:24 <Phlogistique> pi3r: ^
06:31:39 <Phlogistique> pi3r: ici c'est un chan sur Haskell, et on y parle anglais
06:32:04 <pi3r> sorry wrong channel. Forget my post ...
06:32:15 <geekosaur> Profpatsch, you can't in general infer types when a multiparameter type class is in use; fundeps give the compiler enough information to infer types properly. otherwise you'd need to explicitly type pretty much every use of the class
06:32:47 <geekosaur> or instances thereof
06:33:14 <Profpatsch> Ah, I see. But I might need some weeks to grok. :P
06:34:53 <werdna> hi, can I use the type argument to a data constructor as the type signature of a function?
06:35:18 <merijn> werdna: What do you mean?
06:35:54 <werdna> I have a type Formula, which has the following constructor: Forall ::[a] -> (Term a -> Formula as) -> Formula (a, as)
06:36:08 <werdna> and then a function which I define like so: satisfiableValues :: Formula ts -> [a]
06:36:31 <jml> explicitly providing a path to the .cabal-sandbox/bin/ seems to fix the problem
06:36:33 <werdna> buut I get a type error, because ghc can't prove that the [a] in satisfiableValues is the same as the [a] in the Formula constructor.
06:36:43 <werdna> at least, that's the way I interpret it
06:37:20 <merijn> werdna: How about "satisfiableValues :: Formula (a, as) -> [a]"?
06:38:45 <werdna> merijn: does the trick, thank you!
06:38:49 <danking> I've been having troubles with cabal test lately. It seems that the teststub executable that is generated is given bad input and it fails with "cabal: Prelude.read no parse". I'm not sure how to debug further. Any advice?
06:38:53 <werdna> now to see if my list comprehensions are doing the trick
06:39:48 <werdna> list comprehensions did the trick!
06:39:55 <werdna> haskell makes me happy when I understand it :p
06:39:59 <merijn> werdna: Basically, type variables are scoped with a single type annotation, so it can't determine that '[a]' refers to the [a] you applied to Forall, as those two a's are completely unrelated
06:40:19 <werdna> merijn: yeah, I figured that out. Just forgot that the Formula type was already indexed with the a, so I could use that :D
06:40:22 <werdna> solutions (Forall domain lambda) = [ (thisSolution, otherValues) | thisSolution <- (satisfiableValues (Forall domain lambda)), otherValues <- solutions (lambda (Con thisSolution)) ]
06:40:31 <werdna> list comprehensions are pretty neat
06:40:53 <merijn> werdna: If they become very long you can write them as do notation, too
06:41:13 <Profpatsch> One general question about reading Haskell documentation: When there is no docstring for a function/other thing, is it not deemed necessary for the use of the library or is it assumed that the user can derive the purpose of the function from the name and the Type?
06:41:14 <merijn> werdna: Since the monad instance for lists is effectively just a list comprehension
06:41:33 <merijn> Profpatsch: I would assume "the author couldn't be arsed to write it"
06:42:06 <werdna> merijn: as in do thisSolution <- whatever; otherValues <- whatever; return (thisSolution, otherValues)
06:42:08 <Profpatsch> merijn: I’m looking at the Parsec doc, so I assume that is a fairly documented library.
06:42:37 <merijn> Profpatsch: Ah, yeah, Parsec mostly relies on people just looking at the types. Which functions are you referring too?
06:42:42 <merijn> werdna: Yeah
06:43:05 <geekosaur> In many cases, you can figure out what a function does just from its type and the restrictions implied by that type.
06:43:14 <geekosaur> This does assume that you understand how types work in Haskell
06:43:24 <Profpatsch> merijn: Just in general. I was curious if I need to bother with them or if they are internals I don’t need to use.
06:43:24 <merijn> werdna: In reality list comprehensions aren't implemented using the monad operators, but they trivially could be
06:43:57 <werdna> merijn++
06:44:02 <werdna> thanks, that's awesome
06:44:33 <merijn> Profpatsch: Might be both, in case of Parsec, since it's such an old library it predates the rise of applicative functors and a lot of it's functions are just parsec specific versions of Applicative operators (which, tbh, is kinda annoying since all the names clash!)
06:44:45 <merijn> werdna: do-notation is awesomely flexible with things like this :)
06:45:09 <Profpatsch> merijn: Oh, I see. Makes sense, since they also use the old do{} notation.
06:45:21 <werdna> merijn: the more I learn about Haskell, the less frustrating it becomes and the more awesome it becomes
06:45:21 <Profpatsch> And Appl. came after Monads.
06:46:49 <merijn> werdna: It's one of the reasons haskellers get annoyed when people claim that "do notation and monads are just a hack for imperative code", they have tons of applications like this which have little to do with either. You just don't see that until you get more comfortable dealing with types and functional style
06:49:06 <Hodapp> When I try to solve the wrong problems badly in Haskell and the resultant code is ugly, that is obviously Haskell's fault.
06:50:31 <Tjr> LYAH refers to the Num typeclass quite often.
06:50:59 <Tjr> Is this a timless set, or can I add for example my own implementation of quaternionic numbers to the Num typeclass?
06:51:18 <skilpat> Can anyone point me to an example use case of a module that (transitively) imports two conflicting orphan instances? Something akin to https://gist.github.com/23Skidoo/3854294, but actually useful and not bad ;)
06:51:20 <merijn> Tjr: Num is just a typeclass so you can specify as many new instances as you like
06:51:53 <Tjr> What is Num precisely? A ring with + and *?
06:52:06 <Tjr> Or does it have to have more algebraic structure?
06:52:06 <merijn> Tjr: I'm not familiar with quaternionic numbers, so whether you could implement that using Num depends.
06:52:31 <merijn> Tjr: Num doesn't have a particularly elegant mathematical background. This is grounds for much complaining
06:52:52 <geekosaur> there's at least one quaternion implementation already on Hackage, I think
06:53:08 <merijn> Tjr: It's *, +, -, abs, signum and fromInteger
06:53:38 <Tjr> merijn: so it's an ordered ring with a unit. Got it :-)
06:53:43 <yitz> bulat has reappeared on the cafe, after an absence of 5 years!
06:53:43 <merijn> So for example an implementation of the Naturals does not quite fit (unless you want to produce an error on subtraction)
06:53:54 <geekosaur> Num is not defined rigorously in standard Haskell although there are alternative Preludes that provide a more sound basis. On the one hand, that means Num is "floppy" enough to support a lot of things; on the other, there aren't a whole lot of useful laws
06:54:27 <geekosaur> (so on the one hand you can do quaternions, but on the other you can do Acme.PHP....)
06:54:40 <merijn> <3 Acme.PHP
06:54:40 <Tjr> what's acme.php?
06:54:45 <merijn> @hackage acme-php
06:54:45 <lambdabot> http://hackage.haskell.org/package/acme-php
06:54:50 * Tjr knows about acne, painfully.
06:54:55 <merijn> Tjr: A joke package filled with hilariously terrible ideas
06:55:14 <geekosaur> a joke package that tries to act like PHP's rather cavalier approach to typing
06:55:35 <srhb> Heh, cavalier. That's a very diplomatic wording. :-)
06:56:19 <merijn> In the words of the docs: "At last, a module that combines the dynamic flexibility of Haskell with the strong design principles of PHP!"
06:56:23 <geekosaur> ("acme" there is a joke borrowed from Perl, which in turn borrowed it from the Roadrunner-Wile E. Coyote cartoons --- note the brand name on all the Rube Goldberg stuff Coyote tries to use)
06:57:03 <Tjr> presumably you guys don't like php.
06:57:16 <Profpatsch> What’s to like.
06:57:30 * Tjr has no idea of php
06:57:42 <geekosaur> php is an overgrown web templating language
06:57:50 <j`ey> why is ":t pi" pi :: Floating a => a?
06:57:58 <hpc> the only thing i ever learned from php is the hebrew word for "double colon"
06:58:09 <j`ey> oh wait.. can I use "pi" as a float or a double?
06:58:14 <alpounet> j`ey: yes
06:58:16 <merijn> hpc: Isn't that finish?
06:58:17 <j`ey> depending on the type needed..
06:58:18 <j`ey> I see
06:58:19 <hpc> j`ey: and many other things
06:58:24 <geekosaur> or as any other type that implements Floating
06:58:41 <geekosaur> (which by default is Float and Double but you can find other instances if you look around)
06:58:41 <j`ey> how can I write something like that?
06:58:44 <alpounet> j`ey: both define a "value for pi" in their representation, and so do other floating point types
06:58:46 <hpc> http://lampload.com/bookmarks/234--PHP-Error-Double-Colon.html
06:58:59 <yitz> Tjr: www.reddit.com/r/lolphp
06:59:04 <alpounet> j`ey: you have to write an instance of the Floating typeclass
06:59:12 <hpc> yitz: it makes me so happy that this subreddit is a thing
06:59:23 <kstt> is there a idiomatic way to map over the second element of a couple ?
07:00:06 <j`ey> alpounet: I mean, what does the definition of "pi" look like
07:00:07 <hpc> "define() has an optional third argument that specifies if the constant should be case-insensitive; it has the undocumented side-effect of allowing constants to be redefined, but only if they have at least one capital letter"
07:00:29 <yitz> hpc: it actually makes me a little uneasy - it can insult people and cause flame wars. but... php really is funny.
07:01:33 <merijn> I'd rather people invest more time into making Haskell funnies
07:01:39 <merijn> Like acme-realworld :)
07:02:39 <merijn> Or http://hackage.haskell.org/package/acme-lookofdisapproval-0.1/docs/Acme-LookOfDisapproval.html
07:02:39 <hpc> or acme-microwave
07:02:49 <yitz> @type second -- kstt
07:02:50 <lambdabot> Arrow a => a b c -> a (d, b) (d, c)
07:02:53 <hpc> schoenfinkel is my favorite though
07:03:04 <hpc> hasslich = unschoen is just too good
07:03:10 <alpounet> instance  Floating Float  where
07:03:10 <alpounet>     pi                  =  3.141592653589793238 — j`ey
07:03:20 <yitz> kstt: where you should think of "a b c" as being "b -> c"
07:03:39 <j`ey> alpounet: oh..
07:03:39 <alpounet> j`ey: I can see Double specifies the same value actually :)
07:04:05 <yitz> hpc: the magritte one is pretty funny too.
07:04:10 <merijn> hpc: acme-don't :)
07:04:20 <alpounet> j`ey: but there are more precise alternatives. they may provide a different value for pi
07:04:37 <alpounet> (one with a better precision, I mean)
07:04:49 <frerich> kstt: What I like to do in such cases is to ask lambdabot for the point-free version of something, i.e. by sending something like '@pl \(a, b) -> (a, f b)` to it (in which case it seems to suggest 'second f')
07:04:57 <yitz> merijn: i've always advocated don't as a synonym for return (), but people just don't go for it. :)
07:06:55 <hpc> it's fun to look through /r/lolphp and see all the eval.in links throw a 500
07:07:48 <tdammers>  /r/lolphp gets old quick though
07:08:11 <tdammers> like kicking a hiv-positive retarded baby in both of its mutant faces
07:11:03 <Tjr> Everybody seems to implement quicksort in haskell (http://learnyouahaskell.com/recursion) -- but the implementation uses twice as many comparisons as needed. I'm wondering if the optimal solution can be expressed beautifully.
07:11:50 <hpc> http://i.imgur.com/kuWuk.png -- an ordering graph of php values
07:12:26 <merijn> Tjr: Personally I hate the standard quicksort example anyway, there are way more efficient sorts in Haskell
07:12:42 <merijn> Tjr: GHC's standard sort is an optimised mergesort
07:12:48 <Sculptor> hi
07:12:52 <Tjr> I though you couldn't get below n log n complexity?
07:13:01 <hpc> merijn: i think you mean, "there are way more efficient sorts"
07:13:34 <merijn> hpc: quicksort is pretty efficient in non-haskell languages
07:14:00 <merijn> Tjr: Right, but the default haskell quicksort is not n log n (hence why I don't believe it should be called quicksort)
07:14:01 <hpc> surely the choice of language doesn't make a difference here
07:14:09 <Freundlich> From a purely theoretical standpoint, quicksort is actually not that good.
07:14:25 <merijn> Tjr: The GHC has a lot of documentation discussing different historical sorts that were tried plus benchmarks: http://hackage.haskell.org/package/base-4.7.0.0/docs/src/Data-List.html#sort
07:14:30 <tdammers> hpc: implementing *actual* quicksort in haskell is kind of nontrivial
07:14:37 <hpc> quicksort is merely "convenient" in other language, which have access to a source of randomness wherever they want
07:14:57 <hpc> tdammers: but you can still write it efficiently if you duplicate what other languages do
07:15:04 <hpc> (mutation and IO randomness)
07:15:10 <merijn> Sure, but that means mutation
07:15:33 <Pythonfant> When I try to run my program I get a: <<loop>> what does this mean?
07:15:34 <merijn> What I meant is that a pure mergesort is much faster than the silly "naive" quicksort example people pull out
07:15:36 <hpc> if you restrict yourself to pure sorts, quicksort is awful in all languages
07:15:38 <mangaba_leitosa> how does quicksort use randomness?
07:15:40 <tdammers> hpc: yes, but that's not what a naive/textbook implementation would do
07:15:44 <companion_cube> to choose the pivot
07:15:44 <tdammers> mangaba_leitosa: pivot selection
07:16:01 <merijn> Pythonfant: There is an infinite recursion that GHC has detected and thus crashed your program to avoid wasting time
07:16:16 <Pythonfant> merijn: hm k
07:16:41 <merijn> Pythonfant: You may want to look at the Debug.Trace module when you're looking for the source
07:17:05 <Pythonfant> thx
07:18:21 <merijn> (Which, as should be obvious, is horrifically unsafe for production use and is just for debugging)
07:21:22 <mangaba_leitosa> tdammers: hmm, it turns out that I only knew quicksort with leftmost pivot so far :-)
07:22:13 <tdammers> merijn: using Debug.Trace for production purposes is something only PHP folks would think of, I think
07:42:25 <KorriX_> Hello. I'm trying to use delimited continuations from Control.Monad.Trans.Cont - Are they working at all?
07:43:30 <KorriX_> I don't understand why stuff wrapped in reset $ do ... are not getting executed
07:44:01 <KorriX_> and how to get "outer" continuation into shift function
07:46:35 <KorriX_> My code is: http://lpaste.net/104650
07:49:28 <Pythonfant> I tried to use memoization and took a look at http://www.haskell.org/haskellwiki/Memoization . It got faster than before but it's still slower than I would expect it to be. Also trace shows that the function gets called multiple times with the same value. Any idea what I'm doing wrong? http://lpaste.net/104651
07:50:53 <mlen> @tell etrepum Regarding GHC.app: path_helper can be usefull for adding ghc to path by just creating /etc/paths.d/ghc file, relevant docs here: https://developer.apple.com/library/mac/documentation/Darwin/Reference/Manpages/man8/path_helper.8.html
07:50:53 <lambdabot> Consider it noted.
07:53:06 <j`ey> can you dump LLVM IR from ghci?
07:56:24 <yitz> mlen: hey that's useful to know (not just for that). thanks!
08:01:35 <etrepum> mlen: I considered that but it's system wide and will not work if the user has completely customized their PATH
08:03:16 <etrepum> mlen: I want to avoid anything that requires admin
08:04:07 <yitz> mlen, etrepum: the default .bash_profile on modern darwin does not seem to use path_helper. probably because of potential security issues. so you would anyway need to have the user add that.
08:04:22 <mlen> etrepum: I'd say that such user can manage ghc by himself
08:04:33 <mlen> yitz: path_helper is used before .bash_profile is loaded :)
08:04:40 <fizruk> hpc: and that php ordering is not transitive ?
08:04:57 <yitz> mlen: oh i see it's in /etc/profile
08:05:24 <yitz> mlen: on my mac there is nothing in either /etc/paths.d or /etc/manpaths.d. doesn't seem to be a popular option.
08:05:47 <mlen> yitz: it is used by X11 and TeX (if you use them)
08:05:52 <yitz> ok
08:05:55 <etrepum> mlen: they can but why should they have to. it's really the admin/system wide issue that is the problem.
08:05:58 <mlen> yitz: also default paths are stored in /etc/paths :)
08:06:09 <merijn> yitz: MacGPG and MacTeX seem to use it
08:06:33 <mlen> etrepum: yes, I agree that admin requirement may be an issue
08:06:55 <etrepum> which are all things that are not great Mac citizens and use an installer pkg
08:06:56 <yitz> mlen: sounds like you wouldn't want to mess with /etc/paths though.
08:07:03 <yitz> merijn: ok good to know
08:07:52 <mlen> yitz: normally you shouldn't touch it. I did that so vim installed in /usr/local/bin is used instead of the one in /usr/bin :)
08:08:21 <bennofs> Is it possible to have haskell-mode automatically reload the source file in GHCi when you save it?
08:08:23 <yitz> etrepum: are you saying that an using an installer package is not being a good mac citizen?
08:08:50 <etrepum> yitz: absolutely
08:09:14 <yitz> etrepum: why? my mac experience has been that almost all software for mac os x uses an installer.
08:09:59 <etrepum> yitz: Almost all sloppy ports of unix software use one, actual Mac software does not.
08:10:08 <sleepynate> the non-installer approach really only works for application bundles installed in the mac-level userland
08:10:52 <Tjr> sloppy or no,
08:11:08 <yitz> etrepum: not in my exerience. i think the reason is probably that just a drag into Applications doesn't give you a chance to force the user to agree to a license.
08:11:13 <Tjr> on my mac, the non-apple software that goes without an installer is in the clear minority.
08:11:56 <Tjr> yitz: microsoft office, itunes (and a few others) get around this by showing a licence when first run. Mind you, they still use an installer.
08:12:07 <mlen> Tjr: why would anyone need relocatable GHC when you have to use the installer anyway :)
08:12:19 <Tjr> no idea
08:12:22 <etrepum> Tjr: this channel is going to be awfully biased towards that experience :)
08:12:31 <Tjr> I'm just chiming in on whether mac software uses an instealler
08:12:51 <j`ey> does ghci use LLVM? or is it just ghc?
08:13:40 <etrepum> Xcode is just an app bundle, requires a license on first run, there are ways to do that.
08:14:07 <yitz> etrepum: many people here are linux users, so their bias will be towards neither of those two experiences.
08:15:01 <infinitone> i just saw this: https://gist.github.com/quchen/5280339
08:15:05 <infinitone> and was compelled
08:15:14 <yitz> etrepum: truth is that Apple is moving towards favoring the App store experience, which is yet another way.
08:15:44 <etrepum> yitz: the population of people who don't care at all about Mac are irrelevant, I don't know why that's worth mentioning
08:16:49 <etrepum> yitz: yes, and being self-contained, relocatable, and not requiring admin is a prerequisite for App Store (so is sandboxing, which might make it too hard)
08:16:52 <yitz> etrepum: not everyone whose primary platform is something else don't care at all about Mac
08:16:56 * hackagebot rest-gen 0.13 - Documentation and client generation from rest definition.  http://hackage.haskell.org/package/rest-gen-0.13 (AdamBergmark)
08:17:24 <yitz> etrepum: yeah the app store sandboxing requirement is reputed to be a real pain
08:18:06 <etrepum> yitz: please don't bother with that point, the bias is still there even though it doesn't apply to 100% of the population
08:18:07 <sleepynate> you can't sandbox a compiler...
08:20:00 <j`ey> hm, is there a way to get around the fact that you can't do pattern matching in ghci?
08:20:00 <etrepum> sleepynate: you could if you gave it permission to write to a folder, and I'm not sure what the policy is for binaries that ship inside the bundle that are designed to be used separately with the terminal. App Store is a very very low priority
08:20:18 <j`ey> like "let lucky 7 = ..." then "let lucky x = ...."
08:20:36 <yitz> j`ey: sure you can
08:20:50 <yitz> j`ey: put them all in the same let, separated by semicolons
08:20:50 <sleepynate> you can't read or write outside of the user's directories, which means no linking against things in the system folders unless you do it through a provided apple API
08:21:13 <j`ey> yitz: thanks! :)
08:21:22 <sleepynate> etrepum: there's a summary here: http://lacquer.fi/pauli/blog/2011/11/why-the-mac-app-sandbox-makes-me-sad/
08:21:55 <kstt> yitz: frerich: I'm late, but thank you for the 'second' tip.
08:24:33 <mlen> j`ey: or use {: multiline code here :}
08:25:04 <yitz> mlen: right, multiline comes in handy for that. but you still need to put them all in the same let.
08:25:37 <mlen> yitz: true
08:25:52 <j`ey> yitz: do you know if I can dump LLVM IR from ghci?
08:27:26 <yitz> j`ey: i don't know, i haven't played with llvm ir.
08:27:47 <j`ey> yitz: ok
08:27:49 <j`ey> thanks
08:30:00 <bennofs> j`ey: -ddump-llvm
08:31:15 <j`ey> bennofs: for ghci?
08:31:42 <bennofs> j`ey: hmm, maybe if you use that as an argument to ghci?
08:31:54 <j`ey> didn't seem to do anything
08:32:17 <j`ey> Ill play with ghc later
08:32:44 <bennofs> Hmm, I think GHCi probably doesn't use llvm at all
08:33:21 <bennofs> j`ey: for example, -ddump-simpl also works in GHCi
08:33:32 <j`ey> ah, possibly
08:33:45 <j`ey> i guess it doesnt need LLVM for a REPL..
08:39:22 <geekosaur> ghci uses a custom bytecode backend, and never generates LLVM code
08:39:55 <j`ey> whats the current default for OSX?
08:39:57 <j`ey> LLVM?
08:40:17 <alpounet> j`ey: nope
08:40:22 <mlen> etrepum: I think all "universal" methods besides ~/.launchd.conf and ~/.MacOSX/environment.plist or appending to some shell config file in $HOME, require admin.
08:40:26 <j`ey> alpounet: oh
08:40:52 <Tjr> Are you talking about mac, as in desktop, or also about iphone apps?
08:40:55 <alpounet> it's ghc's native code generator like everywhere else. but you can ask ghc to build with llvm by passing ghc (or 'cabal') -fllvm
08:41:13 <etrepum> mlen: which is why I'll be doing one of those
08:41:13 <j`ey> alpounet: (again) thanks
08:42:06 <mlen> j`ey: osx doesn't ship with LLVM toolkit by default
08:42:07 <geekosaur> j`ey: OS X / Xcode doesn't include enough of LLVM for the backend to work properly; you need to install a full LLVM from elsewhere
08:42:25 <j`ey> so I need to build haskell myself?
08:42:36 <geekosaur> no, but you need an LLVM from somewhere else
08:42:42 <j`ey> I have LLVM already
08:42:46 <geekosaur> the usual symptom of this is compiles fail looking for "opt"
08:42:52 <etrepum> mlen: the shell config option sucks but might be the only one that doesn't require logout. will have to look into it, I'm not at my computer right now (or even currently working on this)
08:42:56 <j`ey> oh, it calls opt directly?
08:43:04 <mlen> j`ey: when you use homebrew it won't link llvm by default
08:43:33 <mlen> j`ey: and linking it may break something (anecdotal evidence)
08:44:06 <geekosaur> ghc can;t just give you llvm bytecode and let you link it, because linking packages with ghc is somewhat nasty and it's best to let ghc handle it itself
08:44:12 <mlen> j`ey: but w/o linking it ghc won't be able to find the binaries :) (I ended up compiling 7.8.2 myself)
09:02:07 <chrisdone> here's the past month of #haskell activity by nick http://jsfiddle.net/DhTD8/embedded/result/ if your browser can handle it =)
09:02:29 <humanoyd> Is it possible to have a nested "<|>" operator? I want "(Just [] <|> Just [1]) == Just [1]"
09:03:05 <djahandarie> chrisdone, wow, that's neat.
09:03:07 <vanila> humanoyd, Just x <|> Just y = Just (x ++ y)  ?
09:03:35 <djahandarie> chrisdone, being able to filter out some of the lower-area ones would be nice perhaps.
09:03:38 <zomg> chrisdone: is it purposefully colored like bacon?
09:03:49 <chrisdone> mmm bacon
09:03:50 <humanoyd> vanila: Yes, but I would like it to work for all monads m, n
09:03:55 <vanila> you can define it this way
09:03:56 <vanila> x <|> y = do a <- x ; b <- y ; return (a ++ b)
09:04:08 <vanila> and this is the same as (<|>) = liftM2 (++)
09:04:13 <chrisdone> zomg: the colors come from here http://bl.ocks.org/WillTurman/4631136
09:04:22 <chrisdone> djahandarie: yeah let me try that
09:04:40 <vanila> > liftM2 (++) (Just [1,2,3]) (Just [4,5])
09:04:41 <lambdabot>  Just [1,2,3,4,5]
09:07:20 <dario> > fmap (++) (Just [1,2,3]) (Just [4,5])
09:07:20 <humanoyd> vanila: Sorry, my example wasn't clear enough... I don't want to mappend the inner values but have the monoid characteristics of the inner monad
09:07:21 <lambdabot>  Couldn't match expected type ‘Data.Maybe.Maybe [t0] -> t’
09:07:21 <lambdabot>              with actual type ‘Data.Maybe.Maybe ([a0] -> [a0])’
09:07:39 <humanoyd> something like "(Just Nothing) <|> (Just Nothing) == Nothing"
09:08:19 <teneen> does "cabal install -O2" use "ghc -O2" ?
09:08:34 <vanila> humanoyd, I think that there's no way to do that
09:08:39 <vanila> it's not really a meaningful operation
09:09:21 <vanila> well, can you write the type of the function?
09:11:47 <humanoyd> something like (<|>) :: m (n a) -> m (n a) -> m (n a), I guess
09:12:00 <humanoyd> m, n are monads
09:12:55 <ReinH> liftA2 mappend then
09:13:04 <vanila> Is there a function Monad n => n a -> n a -> m a
09:13:06 <vanila> oops
09:13:08 <vanila> Is there a function Monad n => n a -> n a -> n a
09:13:15 <hpc> :t (>>)
09:13:15 <chrisdone> people who said more than 100 lines in a day: http://jsfiddle.net/DhTD8/1/embedded/result/
09:13:16 <lambdabot> Monad m => m a -> m b -> m b
09:13:39 <vanila> humanoyd, there is no function Monad n => n a -> n a -> n a
09:13:57 <ReinH> Sure there is, it just won't do what he wants
09:13:58 <vanila> you need a different structure than monad
09:15:10 <vanila> You could use Monad m, MonadPlus n or Monoid n or something
09:16:09 <flebron> there's const, there's flip const, ... :)
09:16:38 <ReinH> @djinn a -> a -> a
09:16:38 <lambdabot> f _ a = a
09:16:44 <vanila> I think you guys are missing the point
09:16:56 <flebron> We're both joking.
09:16:59 <chrisdone> reinh: that one is interesting
09:17:08 <chrisdone> reinh: it could choose either implementation but picked one
09:17:10 <ReinH> I'm not.
09:17:21 <hpc> i am hpc
09:17:22 <chrisdone> why'd it pick that one?
09:17:39 <Munksgaard_> I'm getting a lot of warnings (with -Wall) about defaulting constraints to my Integers, arising from the use of '^', among others. Is that something I should be worried about, and if so, how do I fix it?
09:17:43 <chrisdone> why not: f a _ = a
09:18:08 <ReinH> chrisdone: an artifact of its search direction?
09:18:53 <ReinH> I understand the point. I don't think it needs to be supported with false statements.
09:19:00 <geekosaur> Munksgaard_, it's not necessarily a problem, just something to be aware of because changing an equation somewhere could possibly change its inferred type
09:19:20 <chrisdone> right, maybe because (->) is right-associative and it ends up with `id'
09:20:05 <chrisdone> honestly i'd kind of expect djinn to not generate implementations that aren't 100% unambiguous from the type
09:20:12 <ReinH> There can't be a function with the behavior they want because Monad doesn't provide a way to combine the a's
09:20:26 * chrisdone tries to summon augustsson
09:20:29 <Munksgaard_> geekosaur: Fair enough. Is there an easy way to get rid of the warnings (the function is fully type annotated), or should I rather get rid of -Wall ?
09:20:32 <hexagoxel> Munksgaard_: you can fix it by annotating your integral literals like (42::Int) or (42::Integer)
09:20:36 * chrisdone squints with effort
09:20:46 <ReinH> chrisdone: it's just a theorem prover, it doesn't care if the proof is unique
09:21:03 <geekosaur> as hexagonel said, or I think there's a specific warning option
09:21:12 <geekosaur> lemme dig a moment
09:21:17 <hexagoxel> depends on what you need.. (or any other Integral type, dunno which others there are)
09:21:22 <bennofs> -fno-warn-type-defaults I think
09:21:22 <ReinH> It
09:21:33 <Munksgaard_> hexagoxel: Thank you :)
09:21:43 <chrisdone> reinh: true, as a theorem prover it's valid. as a program generator as it's used here, a bit sketchy
09:22:04 <Munksgaard_> bennofs: That seems to work also, thanks!
09:22:16 <geekosaur> -fno-warn-type-defaults
09:22:45 <geekosaur> most probably as: {-# OPTIONS_GHC -fno-warn-type-defaults #-} at the top of the source file
09:24:11 <humanoyd> ReinH: liftA2 mappend is not really what I want...basically I want "<|>" from Alternative but when both outer monads return a "non-empty-ish" value, I'd like to continue with <|> in the inner monad
09:25:07 <ReinH> chrisdone: I'm using it here as a theorem prover. :p
09:25:33 <ReinH> Then liftA2 (<|>)
09:26:33 <chrisdone> reinh: what you proving?
09:27:03 <ReinH> chrisdone: that Monad m => m a -> m a -> m a is inhabited
09:27:20 <ReinH> (By something other than bottom)
09:27:51 <ReinH> I just don't need the monad constraint to prove it :)
09:28:00 <humanoyd> ReinH: "(liftA2 (<|>)) (Nothing) (Just []) == Nothing", but in that case it should be (Just [])
09:28:01 <chrisdone> how?
09:28:25 <ReinH> chrisdone: by exhibiting a value that unifies with the type?
09:28:39 <ReinH> humanoyd: oh I see
09:29:02 <chrisdone> djinn doesn't know about type-classes
09:29:02 <ReinH> A values whose type unifies with the type
09:29:08 <ReinH> It doesn't need to
09:29:23 <chrisdone> ergo
09:29:23 <chrisdone> <ReinH> chrisdone: that Monad m => m a -> m a -> m a is inhabited
09:29:24 <chrisdone> <chrisdone> how?
09:29:25 <chrisdone> =)
09:29:29 <ReinH> If it's true for all a then it's true for Monad m => m a
09:29:36 <chrisdone> explain ya doings and idearings
09:29:55 <ReinH> Since the latter is an instance of the former
09:30:13 <chrisdone> does anyone else know what he's talking about?
09:30:18 <ReinH> What
09:30:40 <ReinH> Monad m => m a unifies with a
09:31:08 <chrisdone> sure
09:31:11 <ReinH> Anything that is true forall a is true for any a
09:31:21 <chrisdone> mhm
09:31:35 <chrisdone> so where's the interesting part?
09:31:36 <vanila> that would not unify because of the occurs check, but I know what you mean
09:31:49 <ReinH> vanila: right sorry
09:31:52 * dwcook mumbles something about alpha renaming
09:32:31 <ReinH> chrisdone: I already got to the interesting part: that if a -> a -> a is inhabited for all a then it is inhabited for Monad m => m a -> m a -> m a
09:32:32 <chrisdone> @djinn a -> a -> a -- is a proof that m a -> m a -> m a is inhabited?
09:32:33 <lambdabot> Cannot parse command
09:32:45 <chrisdone> djinn: lern2comment
09:33:05 * chrisdone frowns
09:33:10 <chrisdone> interesting?
09:33:17 <chrisdone> i guess =p
09:33:49 <ReinH> It served a purpose, since it was claimed to be uninhabited
09:34:04 <chrisdone> oh, huh
09:34:18 <chrisdone> odd claim
09:34:26 <ReinH> I guess you missed that part
09:34:33 <chrisdone> sorry :3
09:34:42 <ReinH> :p
09:35:25 <ReinH> Someone said I was joking. I was not. I was literally resolving an existential crisis.
09:35:35 <ReinH> That was a joke.
09:35:55 <chrisdone> these things must be dealt with
09:35:59 * chrisdone nods sagely
09:36:07 <ReinH> For justice.
09:36:49 <ReinH> dwcook: right alpha equivalence is what I meant
09:37:17 <chrisdone> @djinn (a -> r -> r) -> r -> [a] -> r
09:37:18 <lambdabot> Error: Undefined type []
09:37:30 <chrisdone> oh yeah i forget djinn can't do []
09:37:36 <ReinH> Djinn doesn't like recursive types :(
09:37:37 <chrisdone> no recursive types
09:38:11 <vanila> would that be undecidable?
09:38:56 <chrisdone> don't know
09:39:30 <chrisdone> given that list has a base case it wouldn't necessarily have to be, i think
09:39:42 <chrisdone> a -> [a] is easy to solve for
09:40:16 <chrisdone> and Either a b -> [a] should also be, i think
09:40:33 <chrisdone> or [a] -> Maybe a
09:40:54 <Heffalump> @djinn Either a a -> a
09:40:54 <lambdabot> f a =
09:40:55 <lambdabot>     case a of
09:40:55 <lambdabot>     Left b -> b
09:40:55 <lambdabot>     Right c -> c
09:40:55 <chrisdone> but none of those are recursive. i guess the leap is to get to a fold?
09:41:07 <Heffalump> @djinn a -> Maybe a
09:41:08 <lambdabot> f = Just
09:41:21 <Heffalump> @djinn a -> Either a a
09:41:21 <lambdabot> f = Left
09:41:50 <Heffalump> hmm, why did it choose Just a for the a -> Maybe a but Left a for a -> Either a a ? (it could have chosen Nothing in the former case)
09:41:50 <chrisdone> @src foldr
09:41:50 <lambdabot> foldr f z []     = z
09:41:51 <lambdabot> foldr f z (x:xs) = f x (foldr f z xs)
09:41:52 <copumpkin> bernalex: what would functions do to the types they took and returned?
09:41:59 <yitz> @djinn (a -> r -> r) -> r -> (nat -> a) -> r
09:41:59 <lambdabot> f _ a _ = a
09:42:31 <chrisdone> Heffalump: is that not just choosing the first constructor that matches?
09:42:39 <chrisdone> @src Maybe
09:42:39 <lambdabot> data Maybe a = Nothing | Just a
09:42:42 <chrisdone> hmm, nope
09:42:45 <chrisdone> wait
09:42:54 <chrisdone> oh, it's defined like that in djinn, too
09:42:56 <vanila> @djinn (forall a. (a -> a) -> a) -> (b -> b) -> b
09:42:56 <lambdabot> -- f cannot be realized.
09:42:59 <chrisdone>         ("Either", (["a","b"], HTUnion [("Left", [a]), ("Right", [b])],     undefined)),
09:43:00 <chrisdone>         ("Maybe",  (["a"],     HTUnion [("Nothing", []), ("Just", [a])],    undefined)),
09:43:13 <Heffalump> I have a feeling it might be biased towards using inputs
09:43:15 <yitz> chrisdone: Nat -> a is *almost* [a]. but there nat is a polymorpic type variable. anyway, you can see the disappointing trivial result djinn would have given you if it did support [a]. :)
09:43:39 <copumpkin> bernalex: Agda/Idris can write functions that return types and take them
09:43:50 <Heffalump> yitz: does it actually know what nat is?
09:43:54 <bernalex> copumpkin: I don't know much about it myself.
09:43:59 <chrisdone> no, nat's just a tyvar there
09:44:03 <Heffalump> if not, it would have been unable to use that function argument so it would have had to do what you suggested
09:44:06 <bernalex> copumpkin: yes, I know they can. they are dependently typed languages.
09:44:08 <yitz> Heffalump: no that is a type parameter
09:44:37 <Heffalump> yitz: right, but without a 'nat' available it couldn't have used the list at all, whereas with a real list (or a concrete Nat type) that would have been possible
09:44:46 <Heffalump> so the two aren't quite the same
09:44:55 <yitz> Heffalump: but we can see that even if djinn knew about [a], it would have crapped out as usual with a trivial id function.
09:45:15 <chrisdone> yitz: yeah, i suppose one could make djinn try harder in the search space and yield more than one proof
09:45:17 <ReinH> chrisdone: there are an infinite number of proofs of a -> [a] :p
09:45:17 <bernalex> copumpkin: which I can see is sometimes useful. I could have a Vector type in a game that permitted 2D and 3D vectors, and make sure that 2D vectors were never used as 3D vectors without having two different data types. so that's an example.
09:45:26 <dwcook> Wait, in (a -> r -> r) -> r -> (nat -> a) -> r, where are you supposing we're getting a nat from?
09:45:30 <copumpkin> sure, but you could also make two top-level types for that
09:45:34 <copumpkin> and still not confuse them
09:45:36 <Heffalump> yitz: I don't think that's necessarily the case - that's what I was trying to demonstrate with my a -> Maybe a example.
09:45:39 <dwcook> Oh, you mentioned that
09:45:40 <chrisdone> yitz: so it'd give you the boring foldr _ _ [] = [] case, but also perhaps more interesting ones
09:45:44 <Heffalump> Even though it could ignore the argument and generate Nothing, it doesn't
09:45:45 <copumpkin> bernalex: and we can still achieve similar effects without DTs
09:45:54 * dwcook accidentally skipped parts of the scrollback
09:46:01 <chrisdone> reinh: sure, but it could yield them incrementally =)
09:46:09 <bernalex> copumpkin: sure. but that's not an argument against them. we could just do everything in assembly, after all.
09:46:22 <copumpkin> sure
09:46:30 <copumpkin> so is the question why Haskell doesn't have DTs?
09:46:42 <yitz> chrisdone: sounds good. i'll bet augustuss would accept your patch :)
09:46:57 <bernalex> copumpkin: a mix of that + what would be bad about it if it did
09:46:58 <copumpkin> bernalex: if not, you can already write "functions" at the type level using type families
09:47:06 <chrisdone> Lennart Awesomeson
09:47:07 * hackagebot code-builder 0.1.3 - Simple system for generating code.  http://hackage.haskell.org/package/code-builder-0.1.3 (AdamBergmark)
09:47:22 <bernalex> copumpkin: yes I'we seen some SPJ lectures about it
09:47:30 <chrisdone> bergmark: oh, neat
09:47:34 <bernalex> copumpkin: I also quite like contracts
09:47:44 <bergmark> chrisdone: :-o
09:47:52 <chrisdone> yitz: that would be a fun exercise to learn 'bout djinn
09:48:08 <Heffalump> I guess you can generate multiple results incrementally by adding in the negative of the existing results
09:48:33 <chrisdone> heffalump: the negative?
09:49:34 <Heffalump> chrisdone: in first-order logic, if you're looking for multiple solutions for a proposition, you can find one solution, then find another by taking the conjunction of the original proposition with not (variables = first solution)
09:49:35 <bernalex> copumpkin: in any event I don't know enough about dependent types to have an opinion on them. from the few papers I have read they seem mostly neat, if you can omit their required verbosity often -- like you can with type inference.
09:49:44 <copumpkin> sure
09:49:49 <copumpkin> it's just a completely different type system
09:50:16 <copumpkin> and not a strictly superior one
09:50:25 <bernalex> copumpkin: I'm reading a paper right now where it seems like dependent types may be used for database programming, which is very interesting.
09:50:39 <copumpkin> things like type families can do things you couldn't do with the equivalent in DTs
09:50:52 <bernalex> copumpkin: do you have some examples?
09:51:03 <copumpkin> they pattern match on types :)
09:51:11 <copumpkin> you can't do that with DTs, and shouldn't be able to
09:51:18 <bernalex> I do hope (and think) that contracts can give us some of the nice things DTs can do
09:51:28 <copumpkin> if you keep the type/value distinction, you don't lose parametricity by allowing that
09:51:33 <copumpkin> if you lose the distinction, you lose parametricity
09:51:35 <bernalex> at least we could have a contract to make head and friends not error on []
09:51:41 <chrisdone> copumpkin: can't you pattern match on types in idris?
09:51:43 <bernalex> I see
09:51:46 <copumpkin> chrisdone: I hope not!
09:51:54 <copumpkin> chrisdone: I vaguely remember them considering that
09:52:04 <dwcook> copumpkin: I don't understand how that would be bad.
09:52:26 <copumpkin> how pattern matching on types is bad?
09:52:32 <dwcook> Well, for example, what does "parametricity" mean?
09:52:38 <copumpkin> id :: forall a. a -> a
09:52:41 <copumpkin> id Int x = x + 3
09:52:43 <copumpkin> id _ x = x
09:53:03 <dwcook> Okay, so you could no longer assume it works uniformly on all types?
09:53:06 <copumpkin> yes
09:53:07 <chrisdone> copumpkin: hmm, it seems there's an intermediate step: convert type to an ADT value, then pattern match on that
09:53:16 <copumpkin> yeah, that's fairly common
09:53:17 <copumpkin> called universes
09:53:22 <copumpkin> but they're necessarily "closed"
09:53:30 <copumpkin> whereas type families are open
09:53:49 <bernalex> could you elaborate on that?
09:54:01 <yitz> copumpkin: now they can be either open or closed
09:54:10 <copumpkin> yitz: that's something else
09:54:16 <Arnob> Hi all
09:54:17 <copumpkin> data IntOrBool = IsInt | IsBool
09:54:19 <chrisdone> hmm, no, i was thinking of something else
09:54:24 <copumpkin> interpret :: IntOrBool -> Set
09:54:27 <copumpkin> interpret IsInt = Int
09:54:30 <copumpkin> interpret IsBool = Bool
09:54:45 <copumpkin> chrisdone: oh?
09:54:49 <chrisdone> right… that's do-able with type-families. i don't know how to do that in idris
09:55:04 <chrisdone> yeah, sorry, i was thinking of going from values to types
09:55:07 <chrisdone> =)
09:55:25 <chrisdone> rather than types to types
09:55:33 <copumpkin> yeah, you can't do much if you take a type in
09:55:42 <bernalex> I'm going to set aside a little time this summer to do something more substantial in idris, so I get an intuition for this myself.
09:55:42 <copumpkin> other than pass it to a type constructor or pass it through unchanged
09:55:57 <chrisdone> hmm what if you have something like
09:56:09 <Arnob> question regarding Yesod.Persistent. I am trying to create a connection pool using the CreateMongoDBPool function
09:56:15 <Arnob> but I cannot get the types to match up
09:56:23 <chrisdone> foo : (t : Type) -> Int
09:56:23 <Arnob> sample code here: http://lpaste.net/104655
09:56:24 <chrisdone> foo Int = 0
09:56:24 <chrisdone> foo String = 1
09:56:24 <chrisdone> -- is this not possible?
09:57:10 <chrisdone> hmm i guess not. even thought all the cases are of type Type, there's a reason i'm not aware of that this probably doesn't work
09:57:11 <Arnob> I should say persistent-mongoDB rather than yesod-persistent
09:57:38 <dwcook> chrisdone: well you're missing cases
09:57:48 <chrisdone> dwcook: right, is that why? because it's non-total?
09:58:05 <chrisdone> foo : (t : Type) -> Int
09:58:06 <chrisdone> foo Int = 0; foo String = 1; foo _ = -1
09:58:07 <dwcook> chrisdone: I don't know if that's why. I haven't played enough with those languages yet.
09:58:08 <chrisdone> how about that?
09:58:17 <copumpkin> chrisdone: yeah, it's not possible
09:58:21 <chrisdone> idris says: x.idr:2:1:warning - Unreachable case: foo String
09:58:35 <dwcook> Well that's interesting.
09:58:36 <yitz> Arnob: i see two immediate problems
09:58:43 <copumpkin> the issue is that pattern matching is justified by deeper knowledge of the structure of the thing you're pattern matching on
09:58:49 <copumpkin> and Type simply doesn't have that structure
09:59:02 <chrisdone> ah
09:59:22 <copumpkin> so the notion of data being defined by a fold, or its scott encoding, or whatever
09:59:24 <dwcook> In other words we can only pattern match on closed types but Type is not closed?
09:59:25 <Arnob> besides password being "password" :-)
09:59:26 <chrisdone> so it's sort of like how an unboxed type has a different kind to boxed types in haskell, so you can't do the same fundamental things
09:59:28 <copumpkin> that's what you can pattern match
09:59:34 <yitz> Arnob: you wrote pool :: ConnectionPool but it should be IO ConnectionPool
09:59:35 <copumpkin> yeah
09:59:50 <vanila> types shouldn't exist at runtime
09:59:51 <copumpkin> so conceptually Int has a bunch of constructors
09:59:56 <dwcook> Why shouldn't you be able to pattern match on open types?
09:59:57 <copumpkin> Bool has two of them
10:00:00 <copumpkin> list has two of them
10:00:08 <copumpkin> those are all things that can be matched on
10:00:14 <chrisdone> right
10:00:19 <vanila> so your program shouldn't be able to make a choice based on types, for this reason
10:00:22 <copumpkin> Type has no predetermined set
10:00:31 <chrisdone> ah, that's true
10:00:46 <Arnob> ah ok... I am trying to use the connection pool for the runMongoDBPoolDef function
10:00:47 <chrisdone> type-erasure would make runtime code unable to work
10:00:58 <chrisdone> oh, that's truer
10:00:58 <Arnob> but I see it accepts a connectionpool and not a IO connectionpool...
10:01:08 <yitz> Arnob: the other is that your connection will drop very quickly - you're only giving it 30 secs.
10:01:15 <copumpkin> yeah, although if you wanted that kind of behavior you could make it work (by introducing some runtime type info)
10:01:30 <chrisdone> copumpkin: so types are an open set and values are a closed set?
10:01:32 <copumpkin> it's just that it has no real theory behind it, and introduces unpleasant reasonability effects
10:01:38 * chrisdone feels in the dark a bit
10:01:58 <copumpkin> chrisdone: well, you can pattern match on plenty of infinite things, but they all have some sort of pleasant structure, and types don't
10:02:07 <copumpkin> not sure I'd talk about sets really
10:02:09 * hackagebot rest-gen 0.13.1 - Documentation and client generation from rest definition.  http://hackage.haskell.org/package/rest-gen-0.13.1 (AdamBergmark)
10:02:15 <chrisdone> hmm
10:02:29 <chrisdone> so how to type-families get around this?
10:02:36 <Arnob> yitz: yes, I was having a problem with too many connections staying open exhausting the network resources. So I try to close the connection quickly
10:02:40 <yitz> Arnob: ok. so you need to create the pool inside an IO do block, bind the result to a variable, and then you can pass that to a pure function within the same do block.
10:02:44 <chrisdone> because that is indeed an ordered pattern match
10:02:58 <chrisdone> i don't remember any particular constraints on the types
10:03:16 <chrisdone> maybe because it's just compile-time?
10:03:27 <joebobjoe> I just had a realization... Is the applicative monad to support curried mappings?
10:03:42 <yitz> Arnob: oh. well, you're creating 10*10 = 100 connections. maybe start with less than that and see how it goes.
10:03:43 <chrisdone> and they're not really… proper functions… although you can do recursion with them. hum
10:03:56 <copumpkin> chrisdone: it isn't ordered unless it's closed
10:03:58 <dwcook> copumpkin: what makes a structure "pleasant"?
10:04:53 <dwcook> joebobjoe: you'll need to clarify "applicative monad" (do you mean "applicative functor"?) an "curried mappings".
10:05:11 <chrisdone> copumpkin: what does that mean? ISTR that the order you write your instance declarations will determine what order they're checked, like a pattern match
10:05:32 <copumpkin> chrisdone: nah, you can define instances all over the place, even in different modules (unless it's closed)
10:05:46 <copumpkin> chrisdone: which is what you can do if you want to define your own Vector instances, for example
10:06:03 <copumpkin> dwcook: being the fixed point of some functor
10:06:10 <copumpkin>  / initial algebra
10:06:19 <chrisdone> hmmm
10:06:19 <joebobjoe> dwcook: Yes, I meant applicative functor, sorry.
10:06:34 <chrisdone> let me check the paper, it must be something else
10:06:37 <copumpkin> chrisdone: if you make a type family closed ,then you can do ordered matches (and fallthrough)
10:07:04 <chrisdone> right
10:07:09 <chrisdone> i just don't know what “closed” means
10:07:10 * hackagebot groundhog 0.5.1 - Type-safe datatype-database mapping library.  http://hackage.haskell.org/package/groundhog-0.5.1 (BorisLykah)
10:07:11 <ReinH> joebobjoe: have you read the original paper on applicative functors?
10:07:13 <chrisdone> hey! http://research.microsoft.com/en-us/um/people/simonpj/papers/assoc-types/fun-with-type-funs/typefun.pdf
10:07:18 * chrisdone slaps microsoft
10:07:22 <ReinH> It does a good job of motivating them
10:07:23 <chrisdone> good URLs don't change!
10:07:26 <copumpkin> boo
10:07:44 <chrisdone> http://research.microsoft.com/en-us/um/people/simonpj
10:07:47 <chrisdone> where is spj's stuff?
10:07:49 <joebobjoe> dwcook: Like how do I map a function that takes multiple input types to a Functor? The solution is Applicative functor, right?
10:08:01 <chrisdone> D:
10:08:18 <joebobjoe> ReinH: No.
10:08:27 <copumpkin> chrisdone: the domain says "maintenance in progress"
10:08:27 <jmcarthur> joebobjoe: your question confuses me, to be honest
10:08:31 <copumpkin> http://research.microsoft.com/
10:08:34 <dwcook> joebobjoe: well, every function only takes one argument, so I'm not quite sure in what sense you mean by "takes multiple input types".
10:08:41 <dwcook> s/by //
10:08:46 <yitz> chrisdone: http://research.microsoft.com/en-us/people/simonpj/
10:08:48 <copumpkin> sounds like MSR gets web right :)
10:08:50 <Arnob> yitz : If I am trying to make a "save" function that saves things to the database, would it look like this?
10:08:50 <Arnob> http://lpaste.net/104656
10:08:56 <dwcook> joebobjoe: try giving an example maybe?
10:08:58 <benzrf> rate my code pls http://bpaste.net/show/299049/
10:09:07 <copumpkin> maintaining website? make all links 404 in the mean time
10:09:07 <chrisdone> yitz: thanks
10:09:08 <copumpkin> amirite
10:09:15 <chrisdone> copumpkin: urite
10:09:34 <chrisdone> cool, got a valid link (fwiw) http://research.microsoft.com/~simonpj/papers/assoc-types/fun-with-type-funs/typefun.pdf
10:09:52 <dwcook> joebobjoe: for example you can easily have a functorial value containing a function. How about fmap const x?
10:10:01 <copumpkin> chrisdone: still b0rked for me
10:10:13 <yitz> copumpkin: and soe too. google searches for titles for spj papers now come up with other sites where the papers are hosted.
10:10:21 <chrisdone> copumpkin: ah, seems intermittant
10:10:21 <joebobjoe> dwcook: That makes sense. But how do I map a "thingo" of type Int -> Int -> Int to an Option[Int]? Sorry, not a Haskeller so not using the right syntax.
10:10:27 <copumpkin> oh well
10:10:30 <Arnob> yitz : Sorry that should be runMongoPoolDef rather than runMongoPool
10:10:34 <Arnob> I have updated the code
10:10:35 <ReinH> joebobjoe: http://strictlypositive.org/IdiomLite.pdf
10:10:42 <jmcarthur> joebobjoe: what type should it return?
10:10:44 <chrisdone> copumpkin: so you mean if i don't export my class then it can be an ordered match?
10:10:44 <dwcook> joebobjoe: next you can even apply that function without going beyond the Functor constraint. fmap (($ 10) . const) x
10:11:04 <copumpkin> chrisdone: nope, you need to explicitly use the closed type families syntax if you want ordering
10:11:11 <dwcook> (For some value of "apply")
10:11:20 <copumpkin> can't remember what the syntax is though :(
10:11:53 <joebobjoe> ReinH: What prior knowledge do I need to know to read that paper?
10:12:06 <jmcarthur> joebobjoe: or rather, what is the type of the function you are looking for?
10:12:09 <dwcook> joebobjoe: So then what Applicative allows is the combination of functorial values. You can take an f a and an f b and get an f (a, b).
10:12:13 * hackagebot groundhog-sqlite 0.5.1 - Sqlite3 backend for the groundhog library  http://hackage.haskell.org/package/groundhog-sqlite-0.5.1 (BorisLykah)
10:12:15 * hackagebot groundhog-postgresql 0.5.1 - PostgreSQL backend for the groundhog library.  http://hackage.haskell.org/package/groundhog-postgresql-0.5.1 (BorisLykah)
10:12:15 <ReinH> Not much at all
10:12:16 <yitz> Arnob: looks ok to me. let's see what ghc says though :)
10:12:17 * hackagebot groundhog-mysql 0.5.1 - MySQL backend for the groundhog library.  http://hackage.haskell.org/package/groundhog-mysql-0.5.1 (BorisLykah)
10:12:19 * hackagebot groundhog-th 0.5.1 - Type-safe datatype-database mapping library.  http://hackage.haskell.org/package/groundhog-th-0.5.1 (BorisLykah)
10:12:46 <chrisdone> hackagebot should ratelimit its messages
10:13:04 <benzrf> joebobjoe: the canonical way for this to work is to take an 'f (a -> b)' and an 'f a' and get an 'f b'
10:13:10 <benzrf> but this is not always the most useful way to use it
10:13:12 <chrisdone> copumpkin: right, i have a case demonstrating the non-orderedness:
10:13:13 <chrisdone> type family NAdd x y
10:13:13 <chrisdone> type instance NAdd Z y = y
10:13:13 <chrisdone> type instance NAdd (S x) y = S (NAdd x y)
10:13:27 <chrisdone> if i add type instance NAdd x y = S (NAdd x y) then it'll say ambiguous
10:13:34 <chrisdone> conflicting instances, etc
10:13:40 <benzrf> joebobjoe: the main use of applicatives is usually to map a higher-arity function over multiple functorial values
10:13:47 <benzrf> joebobjoe: i.e.
10:13:59 <benzrf> > liftA2 (+) (Just 1) (Just 2)
10:14:01 <lambdabot>  Just 3
10:14:06 <dwcook> joebobjoe: when you think of taking a value "Int -> Int -> Int" onto a value Maybe Int, the first thing to recognize is that you're asking for a function (Int -> Int -> Int) -> Maybe Int. Anyway, there are several implementations of this, so I'm not sure which one you'd like.
10:14:13 <mister_integer> Are there any special rules for defining type classes instances for type synonyms?
10:14:26 <benzrf>    
10:14:30 <chrisdone> mister_integer: special rules?
10:14:31 <benzrf> mister_integer: you can't do that
10:14:33 <ReinH> joebobjoe: think of <*> as an abstraction of function application
10:14:36 <Arnob_> yitz: Heh... I see the problem
10:14:48 <chrisdone> benzrf: you can with extensions, e.g. instance Foo String
10:14:51 <benzrf> joebobjoe: <*> is like $ if both args were in functorial values
10:14:55 <mister_integer> well there's a language extension -XTypeSynonymInstances
10:14:59 <benzrf> chrisdone: that sounds like a bad idea
10:15:03 <Arnob_> I should be passing myPool rather than pool to runMongoDBPoolDef
10:15:09 <Tjr> nub in Data.List is defined for types that support Eq. However, once types support Ord, it becomes possible to implement it more efficiently (n log n rather than n ^2).
10:15:10 <Tjr> How does haskell handle this type of situation?
10:15:14 <dwcook> > Identity (+1) <*> Identity 1
10:15:16 <chrisdone> benzrf: type aliases in general are a bad idea =)
10:15:16 <lambdabot>  can't find file: L.hs
10:15:28 <mister_integer> chrisdone: why's that?
10:15:52 <Tjr> I.e. what happens if you want different implementations, depending on how much structure you can use?
10:15:54 <benzrf> chrisdone: naaah
10:16:02 <benzrf> type synonyms are gr8!!
10:16:03 <chrisdone> mister_integer: i'm speaking half-joking. i don't personally like them. they are rarely helpful to me
10:16:04 <joebobjoe> Okay, thanks everyone. I'll just have to go read.
10:16:14 <benzrf> joebobjoe: don't read, do
10:16:28 <benzrf> screwing around is the only way to get an intuition for this stuff
10:16:34 <chrisdone> i tend to assume types are real things, either data types or newtypes
10:16:36 <ReinH> Also read.
10:16:51 <chrisdone> and i really prefer to read e.g. (Request -> IO Response) than Application
10:17:17 <mister_integer> At the moment they seem useful to me because I'd rather apply e.g. array functions directly to a Board than have to mediate that with another function
10:17:37 <joebobjoe> I'm not a Haskell programmer, but when I saw applicative functor I immediately thought that it was some generalization of currying for functors.
10:17:49 <joebobjoe> If not then ok
10:18:08 <joebobjoe> Should I learn Lisp before I learn Haskell?
10:18:22 <awestroke> joebobjoe: no, learn haskell now
10:18:22 <chrisdone> joebobjoe: yes
10:18:23 <benzrf> joebobjoe: no
10:18:29 <chrisdone> if you learn haskell now you'll never learn lisp
10:18:38 <carter> hey !
10:18:39 <chrisdone> so you should learn lisp first to get a wider breadth of knowledge
10:18:46 <tremon> joebobjoe: should you learn Latin before learning French?
10:18:48 <benzrf> joebobjoe: applicatives are just a way of combining functorial values in some way
10:18:49 <chrisdone> hey carter
10:18:50 <yitz> joebobjoe: it's a generalization of applying functions inside a functor. but yeah, currying is part of that too.
10:18:55 <carter> chrisdone: i generally suggest folks start with Racket lang
10:19:01 <carter> just because its its sooooo easy to install
10:19:08 <carter> and its really a well made system
10:19:12 <benzrf> joebobjoe: the best way to think about it imo is that applicatives let you have 'f a -> f b -> f (a, b)'
10:19:16 <chrisdone> yeah, PLT was great back when it was called PLT and i was scheming
10:19:18 <benzrf> joebobjoe: and from there you can figure out the rest of the capabilities
10:19:44 <carter> if GHC weren't a thing, and cabal still sucked like it did 5-10 years ago, i'd probably be a racketeer
10:19:47 <chrisdone> i wrote an ant colony simulation with it, had graphics and everything and i didn't have to install any third-party lib
10:19:50 <Philonous> It's annoying that about half the packages use lazy byte strings by default while the other half uses strict ones.
10:20:00 <carter> Philonous: sometimes thats for a godo reason
10:20:02 <chrisdone> philonous++
10:20:02 <benzrf> joebobjoe: i.e. combine two values like that and then fmap a function that takes a tuple
10:20:05 <carter> sometimes its because they were lazy
10:20:05 <benzrf> joebobjoe: etc
10:20:10 <carter> *why not both*
10:20:11 <chrisdone> carter: key being 'sometimes' =p
10:20:23 <dcoutts_> carter: I'd have to double check if cabal existed 10 years ago...
10:20:32 <carter> dcoutts_: :)
10:20:33 <mister_integer> There's a syntax to set a GHC compiler flag at the top of a file, right?
10:20:41 <mister_integer> Something like {-# ... #-}
10:20:44 <Philonous> carter, The worst part is that you can't tell by looking at the haddocks
10:20:51 <dcoutts_> mister_integer: right, OPTIONS_GHC
10:21:07 <chrisdone> carter: i actually came to haskell from scheme, before that CL. scheme's impl. and libs just *worked* unlike CL which is patience-testing
10:21:11 <yitz> Philonous: hover your mouse over it. but, yeah.
10:21:11 <mister_integer> dcoutts_: that looks like an environment variable
10:21:28 <dcoutts_> mister_integer: all pragmas ARE SHOUTY UPPER CASE!!!
10:21:37 <mister_integer> oh, lol
10:21:41 <dcoutts_> ;-)
10:21:48 <carter> dcoutts_: the git commits go back to at least 2005
10:21:54 <Philonous> chrisdone, Wait, are you back from you self-imposed internet ban?
10:22:10 <Philonous> your*
10:22:12 <chrisdone> worse is when you're using n different libraries with n different string types in one expression
10:22:16 <carter> Author: ijones <ijones@syntaxpolice.org>
10:22:16 <carter> Date: April 26, 2004 at 12:28:22 PM EDT
10:22:17 <carter> initial Package and Use config import
10:22:21 <benzrf> \o/
10:22:21 <carter> dcoutts_: who is ijones/
10:22:23 <mister_integer> dcoutts_: thanks!
10:22:30 <carter> ?
10:22:31 <dcoutts_> carter: Isaac
10:22:44 <carter> .... do i need to google who this iss?]
10:22:52 <wcaleb> haskell n00b here, writing a parser to check a Mutt alias file and comment out invalid aliases https://github.com/wcaleb/muttells/blob/master/aliascheck.hs
10:22:58 <dcoutts_> carter: seems that you do :-)
10:23:12 <wcaleb> question: if I want to read from and write to same file (as in link), should i always create a temp file?
10:23:23 <carter> chrisdone: btw, erin, the lass who's helping mzero with the site redesign for HP, would like to borrow the design ideas form your haskell-lang site, OR collab with you on iterating on those ideas
10:23:38 <carter> chrisdone: which would you prefer? I can email intro y'lll
10:23:55 <wcaleb> i got the solution i'm using from here, but concerned it may not be safest route http://stackoverflow.com/questions/2527271/in-haskell-i-want-to-read-a-file-and-then-write-to-it-do-i-need-strictness-ann
10:23:59 <yitz> wcaleb: first of all, cool idea for an app
10:24:05 <carter> I think she's interested in helping push improving the design of the officail haskell sites forward generally
10:24:10 <carter> and doing the leg work to make it so
10:24:25 <chrisdone> carter: sounds good, wouldn't mind getting a CC on that
10:24:37 <carter> CC or TO :)
10:24:52 <chrisdone> philonous: just a brief interlude =)
10:24:56 <carter> i don't have your  email.... ?
10:25:05 <chrisdone> carter: chrisdone@gmail.com
10:25:18 <yitz> wcaleb: if it's a unix shell app, the standard thing would be to allow specifying input and output file, defaulting to stdin and stdout, and then let the user use the shell to take care of in-place stuff.
10:25:22 <Philonous> chrisdone, Awwww :(
10:26:24 <chrisdone> philonous: <3
10:26:28 <wcaleb> yitz: that was my initial instinct; in that case, maybe just use "interact" and not provide input/output file arg handling at all?
10:26:48 <wcaleb> yitz; since output piping could also be handled by the shell?
10:27:17 <benzrf> ultimately, only accepting stdin is more convenient than only accepting filenames
10:27:24 <benzrf> but that doesnt mean you should only pick on
10:27:26 <benzrf> *one
10:27:45 <yitz> wcaleb: less friendly, but easier.
10:28:12 <wcaleb> benzrf: thanks, good point
10:28:16 <carter> chrisdone: DONE
10:28:36 <yitz>  suggection: use Data.Text.Lazy.IO.interact instead of interact from the Prelude
10:28:47 <carter> o/ yitz  :)
10:28:54 <chrisdone> carter: YATTA!
10:29:02 <carter> chrisdone: you watched heros too?
10:29:06 <wcaleb> yitz: ok
10:29:14 <carter> *heroes
10:29:33 <bajtek> hey! Is there a known bug in GHC that produces awful linker errors when a module is removed from exposed-modules, or is it me doing something wrong?
10:29:35 <wcaleb> another n00b question: after compiling a source hs file, why can't i import that file in GHCi?
10:29:42 <yitz> wcaleb: another approach would be to read the entire file into memory (make sure not to get bitten by laziness), do your work, then write it out to the same file.
10:29:43 <chrisdone> carter: omg finally someone else
10:29:55 <carter> it got shitty after the writers strick
10:29:58 <carter> *strike
10:30:03 <chrisdone> i think i stopped caring after series 1
10:30:09 <carter> thank got for type checking, my typoes would suck more otherwise
10:30:13 <bajtek> :wcaleb define "can't". What have you tried to do it?
10:30:17 <carter> hah
10:30:21 <wcaleb> yitz: so use strictness? maybe so
10:30:52 <Philonous> chrisdone, I wrote a small elisp code snippet to add import statements (because I find it breaks my flow when I jump around in the code) that handles abbreviations. I was wondering whether that might be generally useful / worth being expanded upon
10:30:52 <yitz> wcaleb: yes. if you go that route, use Data.Text.IO.readFile.
10:31:01 <Philonous> chrisdone, see https://gist.github.com/Philonous/f51e27913a7f0d6baa7c
10:31:20 <carter> chrisdone: so when are you or johnw gonna write ghcEL
10:31:28 <wcaleb> bajtek: well, i thought i couldn't … never mind, just tried it again and it worked
10:31:31 <carter> GHC-EL
10:31:34 <yitz> wcaleb: if you want to be friendly, you could write a backup copy of the original like the way editors do. but you could always add that later.
10:32:07 <wcaleb> yitz: good idea; i would imagine most people using it would want to overwrite existing file
10:32:43 <bajtek> weird. One would think that cabal would link the module even if it's not on the exports list, right?
10:32:49 <yitz> wcaleb: yeah. and a muttrc probably never gets *that* big, given the amount of memory available on modern computers.
10:32:52 <wcaleb> yitz: my idea would be to run program whenever mutt launches, before sourcing alias file, so you're guaranteed good alias autocomplete
10:33:03 <carter> bajtek: weird linker errors?
10:33:15 <chrisdone> philonous: nice idea. there's some potential complement with existing support. do you use haskell-interactive-mode?
10:33:28 <Philonous> chrisdone, Yes
10:33:30 <dcoutts_> bajtek: list them in other-modules, you have to list them all in exported- or other-
10:33:48 <chrisdone> carter: johnw looked into it and got mirred in design space, i think and demotivated because only us three would use it =p
10:34:05 <carter> who'd be the 3rd person/
10:34:21 <chrisdone> carter: you?
10:34:59 <bajtek> :dcoutts_ Oh, that's great, thanks! Solved the problem.
10:35:00 <chrisdone> philonous: so you're aware of the functionality where you type import SPC and it gives ido-mode completion and when GHC has "not in scope" that it hoogles and prompts with an import line?
10:35:17 <chrisdone> philonous: because in both cases it could maybe use these abbreviations and expansions
10:35:25 <bajtek> :carter I got unresolved externals because I assumed all modules got build; I didn't know about other-modules.
10:35:32 <carter> now you do!
10:35:36 <bajtek> aha!
10:35:49 <bajtek> almost ready to deploy to hackage, ha ha (not).
10:35:51 <chrisdone> bajtek: are you a lisper?
10:36:13 <bajtek> no, I tried Lisp in my youth but it never really sucked me in.
10:36:14 <carter> bajtek: cabal check
10:36:15 <carter> is a good lint
10:36:50 <Philonous> chrisdone, Ah, yes, I disabled it because I don't like electric space
10:37:02 <Philonous> Maybe those can be integrated, indeed
10:37:27 <bajtek> :carter Oh, interesting. A lint for deployment, as it would seem. The library is really very poor in functionality, though, so it's probably not going to happen anytime soon.
10:37:34 <chrisdone> e.g. when it prompts "import Data.Map", i'd prefer for it to prompt importing Data.Map qualified and Map the type unqualified
10:38:32 <yitz> wcaleb: oh well if it's going to run automatically when you start up mutt, you had better warn the user that you are munging up their muttrc. not sure what the right interface is then.
10:38:43 <wcaleb> bajtek: yitz: would basic approach to allowing both be to check for args, and if it's an empty list, do interact?
10:38:54 <Philonous> chrisdone, Also: https://gist.github.com/Philonous/8db4eb9fdcd8198f7045
10:39:01 <wcaleb> yitz: well, that's what i would do it with it, but it would be up to the user to set that up
10:39:12 <yitz> wcaleb: true
10:39:36 <chrisdone> philonous: although it would be cool to have a general solution so that you can type "c.c" and get "Control.Concurrent" or "d.t.l" and get Data.Text.Lazy. i could implement such a completor
10:40:11 <chrisdone> philonous: that feature's available in structured-haskell-mode, too. C-c C-q
10:40:26 <yitz> wcaleb: personally i would want some kind of warning about it. tell me what it's doing. maybe leave in the originals commented-out so i can easily undo it later.
10:40:54 <yitz> wcaleb: anyway, gotta run. gl, sounds fun!
10:40:56 <wcaleb> yitz: maybe best option would be write to stdout by default, but provide an option flag for overwriting in place
10:40:59 <chrisdone> philonous: are you still using structured-haskell-mode? :3
10:41:02 <wcaleb> yitz: ok, thanks!
10:41:03 <Philonous> chrisdone, You mean you type the initials, press some key and emacs checks all known modules and inserts one that has matching intials?
10:41:11 <chrisdone> philonous: yeah
10:41:16 <Philonous> chrisdone, Errr, no :(. It cramps my style :D
10:41:37 <chrisdone> well, rather a version of ido-mode that completes as you type i was thinking
10:41:52 <chrisdone> but a dabbrev-expand is another option
10:42:22 <chrisdone> philonous: missing out dude
10:43:40 <chrisdone> philonous: it even works in the repl now
10:43:54 <chrisdone> not even lispers got structured editing in their repl
10:43:57 * chrisdone pouts
10:43:57 <Philonous> Well, the reason I wrote this function was that I often write some code, realize that I need to import ByteStrings and don't want to lose my thread of thought. "C-c i BS<Enter>" is minimal obtrusive and does what I want.
10:44:34 <chrisdone> philonous: yeah, that's short and sweet
10:45:56 <Philonous> chrisdone, I'll definitely give shm another spin. I just keep postponing it because I'd have to un-learn so many bad habits :>
10:46:15 <Philonous> chrisdone, Also, it is (or at least used to be) rather sluggish
10:46:53 <chrisdone> philonous: it's definitely sluggish on big functions
10:46:58 <chrisdone> i feel it when i work on other people's code >_>
10:47:51 <Philonous> I want liskell. Then we could have proper sexp handling :)
10:47:53 <chrisdone> philonous: hmm. C-c i, you say?
10:48:09 <chrisdone> philonous: i'll use that, too
10:48:16 <Philonous> That's what haskell-add-import-line is at for me, yes
10:48:50 <fizruk> @pl \f (x, y) -> (f x, f y)
10:48:50 <lambdabot> (`ap` snd) . (. fst) . (flip =<< (((.) . (,)) .))
10:48:58 <fizruk> :t bimap
10:48:59 <lambdabot> Bifunctor p => (a -> b) -> (c -> d) -> p a c -> p b d
10:49:09 <fizruk> :t \f -> bimap f f
10:49:11 <lambdabot> Bifunctor p => (c -> d) -> p c c -> p d d
10:49:15 <fizruk> :t join bimap
10:49:16 <lambdabot> Bifunctor p => (a -> b) -> p a a -> p b b
10:49:44 <chrisdone> philonous: hmm, i don't know why i never setup a key to import before
10:50:00 <cschneid> :t join
10:50:01 <lambdabot> Monad m => m (m a) -> m a
10:50:35 <cschneid> is bifunctor a monad then? what's its definition
10:50:45 <fizruk> cschneid: it’s ((->) e) monad
10:51:01 <johnw> cschneid: specialized for ((->) r), join is (r -> r -> a) -> (r -> a)
10:51:12 <fizruk> :t join :: (e -> (e -> a)) -> (e -> a)
10:51:13 <lambdabot> (e -> e -> a) -> e -> a
10:51:26 <cschneid> cool
10:51:49 <chrisdone> philonous: at the moment if i type check and ghc says "not in scope" i get this prompt: http://chrisdone.com/out.ogv
10:51:52 <cschneid> the (->)r  monad is still tricky for me to see. :)
10:52:00 <matheus23> How do I create an stdin input prompt in Haskell? (Something like "Input? Type here: ") The problem with my code currently (do putStr "Input? Type here: "; input <- readLn :: IO Input) is that it outputs "Input? Type here: " lazily... That means, after I have entered the input...
10:52:49 <glguy> matheus23, That's a buffering issue. You can either turn off buffering on stdout or manually hFlush stdout
10:52:49 <Feuerbach> matheus23: it's buffering, not laziness
10:52:56 <fizruk> matheus23: hFlush stdout
10:53:01 <matheus23> wow
10:53:04 <glguy> matheus23, normal buffering behavior for stdout is to buffer each line, but you used putStr
10:53:06 <matheus23> thanks! :D
10:53:12 <matheus23> okay
10:53:12 <chrisdone> philonous: obviously it's not as fast as what you've pasted above, but it is fast in the general case of "any random module from any library". this is why i was thinking if it would let me complete d.b as Data.ByteString instead of ido-mode's normal thing, it'd be generally efficient
10:53:13 <Philonous> chrisdone, Heh, but you have to manually type in "qualified" ?
10:53:17 <fizruk> matheus23: you would need System.IO, I think
10:53:29 <matheus23> fizruk: have that because of readLn anyways ^^
10:54:48 <Philonous> chrisdone, Hmm, I hate focus stealing. Maybe it's possible to modify it so it will only prompt on a key-sequence
10:55:21 <chrisdone> philonous: possibly it could collect suggestions in a buffer and only prompt when demanded
10:55:37 <Philonous> chrisdone, That's what I was thinking
10:56:42 <chrisdone> philonous: generally it doesn't get in my way, so i'd always have it enabled. i'll merge a patch tho
10:57:26 <chrisdone> philonous: but you do have to have your hoogle setup properly
10:57:34 <chrisdone> which is amusingly non-straight-forward
10:58:24 <Philonous> chrisdone, Same goes for Language Pragmas btw. ATM I have the insert suggestions disabled because they annoy me more than having to enter pragmas by hand (which could be di
10:58:41 <Philonous> done with a similar function haskell-insert-language-pragma  or something
10:59:38 <chrisdone> philonous: yeah, shm has a pragma thing. {-# RET ov RET produces {-# LANGUAGE OverloadedStrings #-}
10:59:56 <Philonous> neat
10:59:59 <chrisdone> philonous: {-# by itself produces {-# #-} and then ido prompts a list of pragmas
11:00:02 <johnw> cschneid: you can visualize the function's argument as its "monadic context", and the operation of join as replicating that context (i.e., join g x = g x x) so as to satisfy the type
11:00:21 <chrisdone> philonous: that code might be movable to haskell-mode actually
11:00:28 <cschneid> johnw: yeah, I'm adding it to my todo list to go study that type more. Seems to come up fairly regularly.
11:00:44 <johnw> cschneid: it's the same thing as Reader, minus the type-wrapper
11:01:03 <cschneid> yeah, and I haven't grokked how reader really works :) gotta go spend the time to figure it out
11:01:19 <cschneid> (can somebody pay me to do that please? It'll go a lot faster if I have more time).
11:02:31 * copumpkin om nom 
11:02:53 <chrisdone> pumpkin pie? ^_^
11:02:58 <copumpkin> beef jerky :)
11:03:05 <chrisdone> manly
11:03:14 <chrisdone> is it spicey?
11:03:15 <copumpkin> that's the first time anyone's said that about me
11:03:19 <chrisdone> haha
11:03:20 <copumpkin> nah
11:03:40 <copumpkin> teriyaki flavor
11:03:44 <copumpkin> with haskell spices
11:03:48 <copumpkin> (lest I be off-topic)
11:03:57 <chrisdone> :o
11:04:50 <chrisdone> philonous: i'll bring this import stuff into haskell-mode
11:05:03 <Philonous> chrisdone, Nice, thanks
11:05:09 <chrisdone> philonous: i've wanted a defcustom for "name" -> "import Name as MyStuff" mapping for a while
11:05:44 * chrisdone adds one more function to haskell-mode
11:05:48 <chrisdone> fwuhahaha, the ever growing file
11:05:59 <dreams> is runhaskell dated?
11:06:25 <chrisdone> philonous: did you know: (defvar x "hi") C-M-x will update the value if you change "hi" to something else
11:06:41 <chrisdone> dreams: i still use it…
11:07:04 <Philonous> Isn't runhaskell just a wrapper around ghc --interactive ?
11:07:05 <chrisdone> philonous: i'm guessing not because i used to do defvar followed by setq before i disoverred that
11:07:32 <dreams> chrisdone: I'm getting "Could not find module ‘Setup’" from runhaskell Setup configure
11:07:34 <Philonous> chrisdone, Oh, it actually had that. But it didn't update the value. So I changed it.
11:08:08 <bennofs> chrisdone: is there anything in haskell mode to automatically reload the file in GHCi when I save it?
11:08:24 <chrisdone> bennofs: nope but that's easily doable, squire
11:08:42 <chrisdone> bennofs: with a hook, anyway. do you want to be able to turn it on and off again at will?
11:08:57 <bernalex> is there something in haskell that already does this:
11:09:07 <bernalex> (f (-), f (+)) where f o = factor * 10 ** (e `o` uncertainty)
11:09:09 <Philonous> bennofs, You could advice ghc-save-buffer
11:09:11 <chrisdone> bennofs: alternatively, C-c C-l will save the file before loading it. i tend to just use that rather than saving a file
11:09:42 <augur> bernalex: try hoogle!
11:10:15 <bennofs> chrisdone: hmm that would work too. I thought I might try to use GHCi like a syntax checker, so I don't need hdevtools / ghc-modi
11:10:44 <chrisdone> bennofs: that's pretty much how i use it
11:11:02 <bernalex> augur: hoogle did not return anything very interesting for "(f -> b) -> f -> (b, b)".
11:11:03 <chrisdone> i write some code, when i'm ready for it to be checked i hit f5 (my rebinding of C-c C-l)
11:11:16 <bernalex> augur: and, no, IDK why I wrote b instead of a :-P
11:11:20 <chrisdone> bennofs: are you using inf-haskell or haskell-interactive-mode?
11:11:28 <bernalex> augur: oh that's not even right!
11:11:52 <chrisdone> :t (***) -- might be of interest
11:11:53 <lambdabot> Arrow a => a b c -> a b' c' -> a (b, b') (c, c')
11:11:58 <bennofs> chrisdone: I'm not using ghci in emacs very much at the moment, but I think it's haskell-interactive-mode
11:12:23 <chrisdone> bennofs: what does it say in your REPL's modeline?
11:12:26 <augur> Num a => (a -> a -> a) -> a -> a -> a
11:12:32 <augur> maybe?
11:12:35 <augur> @hoogle Num a => (a -> a -> a) -> a -> a -> a
11:12:38 <lambdabot> Data.ByteString.Lazy foldlChunks :: (a -> ByteString -> a) -> a -> ByteString -> a
11:12:38 <lambdabot> Data.ByteString.Lazy foldrChunks :: (ByteString -> a -> a) -> a -> ByteString -> a
11:12:38 <lambdabot> Data.Text.Lazy.Internal foldlChunks :: (a -> Text -> a) -> a -> Text -> a
11:12:47 <bernalex> augur: what I'd really want is something "worse". like ((a -> a) -> a) -> (a -> a) -> (a, a). or even ((a -> b) -> (a -> b) -> (b, b) -- heh.
11:12:48 <bennofs> chrisdone: Interactive-Haskell
11:13:03 <chrisdone> bennofs: cool. then C-c C-l will save and load the file
11:13:21 <Philonous> chrisdone, Is it possible to check whether the current haskell process can accept input? I'd like to use :comple for auto-completion, but I'm afraid it would block because the processs is dead / it's busy
11:14:07 <chrisdone> philonous: there might a handy func in there, let me check
11:14:18 <bennofs> chrisdone: also, interactive haskell doesn't seem to support input currenlty (getLine at the prompt doesn't work). Is that right or am I missing something?
11:14:33 <chrisdone> bennofs: i think you need to update as i added support for that recently
11:14:35 <Philonous> bennofs, Try the git-version of haskell-mode
11:15:50 <chrisdone> philonous: perhaps haskell-process-queue-flushed-p
11:15:57 <bennofs> chrisdone: oh, that's nice :) I'll see if it works, thanks
11:16:49 <Philonous> chrisdone, Ah, that might do the trick. Is there also a function to check whether the process is alive?
11:16:58 <Philonous> chrisdone, Ah, enver mind, I'll just read the code
11:17:55 <chrisdone> philonous: not right now, but this might be handy if you abstract it into a function: https://github.com/haskell/haskell-mode/blob/master/haskell-process.el#L1196..L1197
11:18:10 <Philonous> chrisdone, Thanks!
11:18:30 <chrisdone> welcome =)
11:20:31 <hcaulfield57> I uninstalled the current version of the haskell platform, compiled a new ghc-7.8.2 (because the current platform doesn't compile some things on Mavericks), I'm trying to compile cabal-install to get more libraries, but it wants haddock, but haddock complains about missing ghc-paths and xhtml, I don't know how to fix it.
11:20:40 <hcaulfield57> I've intalled ghc into /opt/ghc-7.8.2
11:21:02 <johnw> i want to abstract chrisdone into a function
11:21:04 <chrisdone> did you add /opt/ghc-7.8.2/bin to your PATH?
11:21:22 <chrisdone> johnw :3
11:21:33 <johnw> chrisdone :: Awesomesauce a => r -> a
11:21:46 <hcaulfield57> chrisdone: No, I've symlinked /usr/bin/ghc and other executables to the proper paths in /opt
11:22:19 <chrisdone> hcaulfield57: perhaps try temporarily export PATH=/opt/ghc-7.8.2/bin:$PATH
11:22:40 <chrisdone> hcaulfield57: to confirm that it's not just a path problem that you maybe missed a symlink in /usr/bin
11:23:50 <chrisdone> johnw :: MonadCont m => m a -> m a
11:23:55 <chrisdone> run if you dare =p
11:24:01 <johnw> haha
11:24:37 <hcaulfield57> chrisdone: That doesn't seem to work.
11:24:40 <Philonous> @type id id id id id id id id id id
11:24:41 <lambdabot> a -> a
11:26:03 <chrisdone> hcaulfield57: no luck?
11:26:32 <hcaulfield57> chrisdone: Nope
11:26:40 <chrisdone> @type fmap fmap fmap fmap fmap fmap fmap fmap
11:26:41 <lambdabot> (Functor f2, Functor f1, Functor f) => (a -> b) -> f (f1 (f2 a)) -> f (f1 (f2 b))
11:26:50 <hcaulfield57> chrisdone: I dunno enough about cabal to figure out how to fix it.
11:27:11 <chrisdone> hcaulfield57: how about clearing everything and starting from scratch?
11:27:33 <dreams> is hmake still used?
11:27:37 <hcaulfield57> chrisdone: removing /opt/ghc-7.8.2 and then reinstalling haskell platform?
11:27:42 <chrisdone> i use cabal with 4 major ghc versions
11:28:01 <Iceland_jack> :t let { f1 = (,); f2 = (,) f1 f1; f3 = (,) f2 f2; f4 = (,) f3 f3; f5 = (,) f4 f4 } in (,) f5 f5
11:28:02 <lambdabot> (((((a -> b -> (a, b), a1 -> b1 -> (a1, b1)), (a2 -> b2 -> (a2, b2), a3 -> b3 -> (a3, b3))), ((a4 -> b4 -> (a4, b4), a5 -> b5 -> (a5, b5)), (a6 -> b6 -> (a6, b6), a7 -> b7 -> (a7, b7)))), (((a8 -> b8 -> (a8, b8), a9 -> b9 -> (a9, b9)), (a10 -> b10 -> (a10, b10), a11 -> b11 -> (a11, b11))), ((a12 -> b12 -> (a12, b12), a13 -> b13 -> (a13, b13)), (
11:28:03 <lambdabot> a14 -> b14 -> (a14, b14), a15 -> b15 -> (a15, b15))))), ((((a16 -> b16 -> (a16, b16), a17 -> b17 -> (a17, b17)), (a18 -> b18 -> (a18, b18), a19 -> b19 -> (a19, b19))), ((a20 -> b20 -> (a20, b20), a21 -> b21 -> (a21, b21)), (a22 -> b22 -> (a22, b22), a23 -> b23 -> (a23, b23)))), (((a24 -> b24 -> (a24, b24), a25 -> b25 -> (a25, b25)), (a26 -> b26 ->
11:28:03 <lambdabot>  (a26, b26), a27 -> b27 -> (a27, b27))), ((a28 -> b28 -> (a28, b28), a29 -> b29 -> (a29, b29)), (a30 -> b30 -> (a30, b30), a31 -> b31 -> (a31, b31))))))
11:28:23 <bernalex> Iceland_jack: lol
11:28:31 <hcaulfield57> installing things into /opt is kind of a pain, but for things like compilers it seems better than putting it all over /usr
11:28:37 <chrisdone> hcaulfield57: well, i mean perhaps remove your ~/.ghc and your ~/.cabal and start a-fresh
11:28:56 <chrisdone> hcaulfield57: i have all my ghcs thus, too
11:28:56 <chrisdone> $ ls /opt/ghc
11:28:56 <chrisdone> 7.2.2  7.4.2  7.6.3  7.8.2
11:29:24 <chrisdone> to switch between i just do export PATH=/opt/ghc/7.6.3:$PATH and cabal configure
11:30:26 <hcaulfield57> chrisdone: Do you have cabal install as user or as global? Also can you compile ghc without haskell platform?
11:30:46 <hcaulfield57> See gtk is broken on current versions of haskell-platform
11:30:52 <hcaulfield57> for mavericks at least
11:30:53 <chrisdone> hcaulfield57: i have it as a user
11:31:13 <chrisdone> hcaulfield57: i do this "Advanced Setup" http://haskell-lang.org/downloads#
11:31:14 <hcaulfield57> chrisdone: Oh, and cabal doesn't mix versions
11:32:45 <hcaulfield57> chrisdone: Cabal doesn't mix different versions of installed packages compiled by different versions of ghc?
11:33:30 <chrisdone> hcaulfield57: correct
11:33:54 <chrisdone> hcaulfield57: when you switch your PATH cabal will ask you to run cabal configure again with the new GHC you're using
11:34:07 <hcaulfield57> chrisdone: Okay, I'll just do that. I didn't realize there were binaries for OS X :/ It took like 5 hours to compile ghc on this computer haha
11:34:17 <chrisdone> haha
11:34:44 <hcaulfield57> chrisdone: thanks :)
11:36:12 <deni> if i have set -XOverloadedStrings in my .ghci config file and at the top of my .hs file....i can't do reverse "Hello"...i get this: http://dpaste.com/1JWQ7H9/
11:36:27 <deni> can anyone explain what's going on?
11:37:01 <jxv> It doesn't know the type of the "Hello"
11:37:11 <jxv> try, reverse ("Hello" :: String)
11:37:27 <jxv> or, let str = "Hello" :: String; reverse str
11:37:44 <deni> jxv: i have, that works....but i guess i thought OverloadedStrings was supposed to "fix" things not confuse them
11:37:59 <ReinH> jxv: but why can't it unify IsString [a] with [Char]?
11:38:10 <deni> jxv: i was given to understand that it's kinda commond practite to drop that at the top of every source file
11:38:11 <benzrf> 'unify'?
11:38:22 <deni> polymorf?
11:38:42 <Philonous> chrisdone, btw. do you have haskell-process-restart bound to a key?
11:38:51 <tdammers> deni: do you understand what OverloadedStrings does?
11:38:51 <ReinH> infer [Char] for IsString [a]
11:39:26 <jxv> deni and ReinH, It only ambiguates them to a typeclass.
11:39:46 <tdammers> without it, string literals are of type [Char]; with it, string literals are of type IsString a => a
11:39:46 <deni> tdammers: it introduces a new typeclass IsString. and allowds you to write String and Text?
11:40:03 <tdammers> it changes the type of string literals
11:40:21 <tdammers> so they are no longer of type String, but of type IsString a => a
11:40:39 <deni> and reverse doens't know how to handle IsString?
11:40:45 <deni> *doesn't
11:40:48 <tdammers> reverse only works on lists
11:40:57 <tdammers> but IsString a => a doesn't force it to be a list
11:40:57 <deni> well yeah string is a list
11:41:24 <Philonous> deni, Since you could have IsString instances for all sorts of lists it doesn't know which type to use.
11:41:28 <deni> how is one to solve that problem then? i mean i don't wan a runtime error when someone passes a string to my function
11:41:42 <jxv> ReinH, I think the better question is to ask, 'why does it infer String without -XOverloadedStrings?'
11:41:42 <rgtbctltpx> add constraint, which allows reverse
11:41:52 <tdammers> either you do it without IsString, or you force the string literal to type String
11:42:03 <chrisdone> philonous: i should, i do it often enough
11:42:16 <bakibour> Greetings
11:42:17 <deni> tdammers: yeah i can do that if it's my code...but say i'm writing a lib
11:42:24 <ReinH> jxv: Er, it infers [Char]
11:42:31 <deni> and the user passes in an IsString...the whole thing blows up in runtime
11:42:54 <tdammers> deni: no, it doesn't
11:42:55 <deni> right?
11:43:01 <deni> hmm
11:43:03 <bakibour> How can i repetitivly feed a function result to itself in a do block?
11:43:04 <ReinH> tdammers: It's a compile-time error
11:43:08 <Philonous> chrisdone, Well, I have (lambda () (interactive) (haskell-process-restart) (haskell-process-load-file)) bound to C-c r
11:43:19 <deni> ReinH: tdammers okay my bad...you're right
11:43:25 <deni> it's a compile time error
11:43:26 <tdammers> ReinH: yes, that's what I'm getting at
11:43:27 <WarzoneCommand> hmm question regarding strictness. I have two functions, say f and g, and f is nothing more than something like f x = g x 1. I want to force the evaluation of g in the call of f. So now I have f x = id $! g x 1. That works, but I dout it is the canonical way of solving this
11:43:43 <ReinH> tdammers: heh I meant to direct that to deni, sorry
11:43:51 <tdammers> ReinH: np :D
11:43:55 <carter> WarzoneCommand: that looks wrong
11:44:09 <carter> id $! g x 1 is no more strict that g x 1
11:44:28 <ReinH> bakibour: can you use iterate?
11:44:39 <WarzoneCommand> hmm strange
11:44:40 <tdammers> deni: the compiler is pretty picky about these things, but it does usually pay off in the form of guarantees - basically if you write impossible code, it will not compile
11:44:42 <ReinH> @src ($!)
11:44:42 <lambdabot> f $! x = x `seq` f x
11:44:46 <chrisdone> philonous: i usually restart after installing a package. why do you restart?
11:44:47 <WarzoneCommand> I am seeing different behaviour
11:44:52 <tdammers> you can't accidentally put a round thing into a square hole
11:44:54 <carter> WarzoneCommand: how different
11:45:15 <carter> and what -On level?
11:45:22 <tdammers> unlike other languages, where anything that quacks can be forced into a duck-shaped hole
11:45:30 <deni> tdammers: just wondering how to solve this then....i mean i bumped into this thinkg while doing the 99 problems...by writing the isPalindrome function
11:45:38 <carter> and ghc what version
11:45:41 <ReinH> tdammers: lol
11:45:41 <carter> and whats the real code?
11:45:42 <deni> tdammers: i used a type class constraint of Eq a
11:45:52 <ReinH> deni: give your function an explicit type
11:45:53 <bakibour> ReinH: No idea :)
11:46:00 <bakibour> I had a look at that but was not able to apply it
11:46:04 <tdammers> deni: well, either you force your value to be a list (e.g. [Char], a.k.a. String), or don't use OverloadedStrings
11:46:04 <Philonous> chrisdone, Various reasons. Sometimes ghci juts glitches out, sometimes it uses ridiculous amounts of RAM, I restart ghci when I change the cabal file and when I install packages.
11:46:04 <deni> ReinH: tdammers isPalindrome :: (Eq a) => [a] -> Bool
11:46:06 <deni> this was the type
11:46:12 <bakibour> Let me paste the code sec.
11:46:15 <deni> but it blows up on strings, as you know
11:46:18 <WarzoneCommand> sec, let me make a pastebin or so with the real code
11:46:31 <carter> @lpaste
11:46:31 <lambdabot> Haskell pastebin: http://lpaste.net/
11:46:36 <ReinH> deni: It blows up on things of type IsString a. It works just fine on strings.
11:46:38 <carter> use lpaste :)
11:46:48 <deni> ReinH: sorry that's what i meant
11:46:56 <bakibour> http://lpaste.net/104659
11:46:58 <tdammers> deni: you have a string literal, which guarantees IsString, and you have a function that takes a list of "something"
11:47:03 <tomejaguar> Does anyone understand GADTs and know why this doesn't work: http://lpaste.net/104660
11:47:11 <ReinH> deni: Then either get rid of OverloadedStrings or give an explicit type for your string literals
11:47:14 <tdammers> the compiler wants to *unify* these, that is, find exactly one type that matches all the constraints
11:47:22 <chrisdone> philonous: are you using -fobject-code?
11:47:25 <Welkin> why doesn't lpaste have auto-indentation?
11:47:33 <bakibour> I would like to call expand n times and later until some condition is met.
11:47:36 <chrisdone> welkin: auto-indentation?
11:47:39 <ReinH> Welkin: because it's just a textarea?
11:47:43 <Welkin> like in a text edictor
11:47:51 <tdammers> but the thing is, it is impossible to guarantee that String will be the only type to ever meet these two criteria
11:47:51 <Welkin> editor*
11:47:56 <bakibour> Is there maybe an implementation of a general search?
11:48:00 <chrisdone> why not just use a text editor?
11:48:05 <ReinH> tdammers: ah
11:48:08 <deni> ReinH: tdammers but then i basically have to annotate every string....kinda defeats the whole the compiler can infer types thing
11:48:23 <tdammers> and in fact, it's pretty trivial to introduce another instance declaration that meets both constraints (IsString and list)
11:48:40 <tdammers> you don't have to annotate all the strings
11:48:44 <deni> tdammers: okay now we're talking
11:48:49 <carter> tomejaguar: because your  Pure :: a -> State m i i a is wrong looking
11:49:00 <carter> where do the i's com frome?
11:49:10 <tdammers> usually, when you use OverloadedStrings, you're dealing with functions that take a unified type already - usually String or some flavor of Text
11:49:58 <tdammers> if you pass a string literal into a function of type Text -> Int, for example, there is nothing to unify - Text is already a type, and the only thing left for the compiler is matching it against IsString a => a, which is trivial, because Text implements IsString
11:50:07 <tomejaguar> carter: They don't come from anywhere.  A pure value won't change the index.
11:50:28 <tdammers> and because Text is already unified, there cannot be another type that satisfies the constraints (IsString a and a ~ Text)
11:50:29 <carter> also why sin't the index mentioned in your instance? instance ApplicativeIx (State m) where
11:50:35 <Philonous> chrisdone, not that I know of
11:50:53 <chrisdone> philonous: might be of interest http://chrisdone.com/posts/making-ghci-fast
11:51:01 <ReinH> bakibour: can you show some code for what you've tried so far?
11:51:02 <tomejaguar> carter: Because it's the class of indexed monads.
11:51:04 <tdammers> most of the string-like-object-handling functions are like that, so you only run into this problem when you use more general functions that happen to work on String
11:51:11 <tomejaguar> carter: Or Applicatives
11:51:11 <tdammers> (usually these are list functions)
11:51:25 <bakibour> ReinH: Let me post the whole code so far
11:51:34 <carter> tomejaguar: humor me
11:51:35 <carter> :)
11:51:35 <tdammers> does that make sense?
11:52:00 <tomejaguar> It says "Could not deduce (i'' ~ (s'0, u'0))" but I don't see why it can't deduce that.
11:52:09 <tomejaguar> Seems like that condition holds
11:52:15 <Philonous> chrisdone, Ah, that must have been before I had your blog in my RSS reader :)
11:52:43 <WarzoneCommand> http://lpaste.net/104662
11:52:44 <deni> tdammers: yes it does. thank you. so my best bet is to implement a instance for this scenario....
11:53:03 <deni> tdammers: err an Instance that will match both scenarios
11:53:08 <carter> WarzoneCommand: whats the difference in strictness?
11:53:14 <bakibour> ReinH: http://lpaste.net/104659
11:53:23 <tdammers> no.. you just have to force the type to String in strategic places
11:53:28 <bakibour> I guess i need to lift iterate so it works in IO?
11:53:33 <carter> g2g
11:53:41 <deni> tdammers: one other thing.....you said if you pass String to Text -> Int it will work....but the other way around doesn't hold right?
11:53:45 <bakibour> And then use take for the n'th iteration?
11:54:13 <tdammers> no no no... IsString a => a, not String
11:54:14 <WarzoneCommand> carter: without the  '$!' it will run the 'rename' action in getFile' *before* adding lp to the list of ignored things (i.e. before the body of the 'withTemporarilyIgnored'' function )
11:54:21 <tdammers> that is, you pass a string literal
11:54:23 <tdammers> not a String
11:54:44 <WarzoneCommand> running ghc 7.6.3 on OS X btw
11:54:44 <tdammers> the string literal will become Text, too, because of type inference
11:54:58 <deni> tdammers: or that yes. ok this has been very helpfull..thank you all (cc ReinH jxv Philonous )
11:55:32 <tdammers> another way of thinking about it is if you look at the single method in IsString
11:55:34 <ReinH> bakibour: ok, so you want to iterate the expand function
11:55:36 <tdammers> fromString, that is
11:56:02 <tdammers> OverloadedStrings is exactly as if every string literal were prefixed with fromString
11:56:03 <deni> tdammers: ah ok string literal got it.
11:56:07 <bakibour> ReinH: Yes
11:56:13 <Philonous> is there a workaround for cabal repl just quitting when there are type errors?
11:56:21 <ReinH> Well, there's iterateM, but it won't do what you want
11:56:25 <tdammers> so whenever you write "foobar", OverloadedStrings turns it into (fromString "foobar") behind the scenes
11:56:30 <bakibour> I would like to iterate it until the goal function is met, but first i would like to call it n times.
11:56:36 <ReinH> since you want to be able to halt the iteration
11:56:54 <deni> tdammers: that makes perfect sense. awesome.
11:56:57 <bakibour> ReinH: I thought i could call iterateM then and use take to get the nth iteration.
11:57:13 <ReinH> bakibour: iterateM provides an m [a]
11:57:19 <ReinH> You can't "get to" the [a] to take it
11:57:44 <ReinH> bakibour: you're going to need to write your own function that's similar to iterateM but takes a count
11:57:53 <bakibour> Hm
11:58:04 <bakibour> Ok i think i can do that.
11:58:15 <WarzoneCommand> hmm
11:58:16 <bakibour> Just wanted to know if there is a more generic way.
11:58:22 <WarzoneCommand> maybe I'm just screwing up somewhere else
11:58:36 <bakibour> Is there any generic search implemented in some library?
11:58:51 <ReinH> bakibour: what do you mean by generic search?
11:59:02 <bakibour> I would like to perform a breadth first search with excluding paths that have the same node.
11:59:19 <bakibour> Well eg you can implement breadth first search like i did.
11:59:31 <bakibour> Appending new expanded nodes to the end of the list you search.
11:59:40 <bakibour> And in the front so you have depth first.
12:00:00 <bakibour> Then you can have stuff like A* that takes cost into consideration.
12:00:18 <ReinH> so you have some function expand :: a -> m [a], and you want to traverse the graph that this generates breadth-first
12:00:33 <bakibour> Or with other strategies, but yes thats what i want to do.
12:00:56 <bakibour> I mean i can most likely roll everything of that my own id just like to see how it is done the haskellish way.
12:01:53 <Rarrikins> Is there some neat way of having algebraic expressions under Num? I think there probably isn't due to things like (^) not being in a typeclass.
12:06:22 <bakibour> Will there ever be anything comparable to the fpcomplete IDE but for free?
12:08:20 <chrisdone> you mean web-based?
12:08:30 <ziman> :t (**)
12:08:31 <lambdabot> Floating a => a -> a -> a
12:08:34 <ReinH> bakibour: So the same algorithm can implement both BFS and DFS if you choose between a queue and a stack to store the nodes to be processed.
12:09:18 <ReinH> bakibour: So one option would be to use StateT to store the queue or stack
12:09:31 <ReinH> another would be to implement it recursively
12:10:09 <mornfall> ReinH: it only works that way for trees, doesn't it?
12:10:32 <ReinH> Sure, but a generating function a -> [a] (or, a -> m [a]) generates a tree
12:11:00 <mornfall> I only caught the bit about traversing a graph, sorry. :)
12:11:02 <Noldorin> what's the point of Reader? doesn't seem to do anything interesting as far as I can tell
12:11:06 <Noldorin> it's basically just like a function :P
12:11:11 <mornfall> I wouldn't say that traversing a tree using StateT makes much sense though.
12:11:14 <ReinH> Noldorin: yes it is
12:12:19 <Philonous> Noldorin, That's the Zen of Haskell.
12:12:38 <Noldorin> Philonous, hah. sounds like anti-Zen to me.
12:12:40 <ReinH> mornfall: it's a way to implement typical iterative bfs
12:12:44 <bakibour> ReinH: Thanks sounds like a good idea :)
12:14:51 <dwcook> Noldorin: Reader a b is basically just a -> b, yeah. I'd say Reader would be nice in situations where I wanted to compose them without having to explicitly mention the parameter.
12:15:06 <dwcook> Of course you can often do that anyway.
12:15:16 <Philonous> Noldorin, Anyway, usually you wouldn't use Reader as is. It gets more interesting when you use ReaderT and build a Monad stack. It's still not magic, only functions, but it gives you a nice set of combinators to make working with them very convenient
12:15:56 <dwcook> ReaderT a m b is just a -> m b
12:16:14 <dwcook> @type runReaderT
12:16:14 <lambdabot> ReaderT r m a -> r -> m a
12:16:37 <Noldorin> dwcook, heh true... I see your point I think. that style of composition doesn't really save code though, does it? it just looks parameter-free syntactically
12:16:38 <Noldorin> hm
12:17:07 <dwcook> Noldorin: saving code isn't always the point.
12:18:01 <Pythonfant> How do I react to failed IO in haskell? as I understood it a failed io action calls fail in the monad so all chained monads will also fail, but what if I don't want everything to just fail in this case but instead do something else
12:18:51 <joelteon> fail in the IO monad throws an exception, right?
12:19:00 <bergmark> Pythonfant: you can catch IO exceptions with Control.Exception.catch
12:19:21 <Pythonfant> mechairoi: ok
12:19:44 <Pythonfant> I thought I could just pattern match it or something like that
12:20:29 <joelteon> Pythonfant: by "failed IO", do you mean exceptions, or the use of 'fail' in the IO monad?
12:21:18 <ReinH> Cale: ping
12:21:40 <Noldorin> dwcook, what would be the point then?
12:21:57 <Noldorin> dwcook, it certainly doesn't add to clarity either
12:22:02 <bergmark> Pythonfant: you pattern match on it in the catch handler
12:22:24 <Pythonfant> joelteon: I guess I don't really know (still a newbie). What I want to achieve is, is to avoid crashes so wrap every action that could fail somehow
12:22:31 <Pythonfant> bergmark: alright
12:22:35 <dwcook> Noldorin: It's got some compositional advantages. Honestly they seem pretty minor to me but others have found it useful.
12:23:12 <joelteon> Pythonfant: Give me an example of an action that could fail
12:23:27 <Pythonfant> I have http requests using http-conduit
12:24:21 <joelteon> Ok, what's one example of a failure you'd like to handle?
12:24:25 <dwcook> Noldorin: I get the feeling that they end up being more useful in transformer stacks.
12:24:28 <Noldorin> dwcook: yeah. I struggle to see how they're anything more than a gimmick too...
12:24:32 <Noldorin> dwcook, I see.
12:24:49 <Noldorin> transformers seem very ugly to me so far too :/
12:24:59 <Pythonfant> joelteon: server does not respond
12:25:17 <Pythonfant> or no network connection on my side
12:25:48 <dwcook> Noldorin: I wouldn't discount transformers. They have quite varied uses.
12:26:00 <Cale> ReinH: pong
12:26:28 <dwcook> For example, I've implemented a limited command set for communicating over a network using a newtype of RWST over IO.
12:26:31 <Noldorin> dwcook, they seem necessary if you want to use more than one monad simeultaneously, but they also seem to horribly pollute the type signature of things, and generally make code hard to reason about
12:26:40 <ReinH> Cale: I have a question that you might be able to answer :)
12:26:41 <dwcook> Although I later ended up using a Free Monad for that.
12:26:41 <Noldorin> hm
12:26:47 <Cale> okay
12:26:59 <dwcook> (Plus an interpreter)
12:27:00 <joelteon> Pythonfant: Did you see the third code block here? http://hackage.haskell.org/package/http-conduit-2.1.2/docs/Network-HTTP-Conduit.html
12:27:07 <joelteon> There's an example at the bottom of exception handling.
12:27:35 <Pythonfant> thx, that's what I'm looking for
12:27:42 <joelteon> That's how you'd catch an error; for the errors that http-conduit might throw, you can look at http://hackage.haskell.org/package/http-conduit-2.1.2/docs/Network-HTTP-Conduit.html#t:HttpException
12:27:55 <ReinH> Cale: Is there a general term for "translating" a function to operate "under" some isomorphism / inversion? I can think of lots of examples.
12:28:05 <dwcook> Noldorin: as I just hinted at though, you don't need to "pollute the type signature". You can use a newtype and newtype deriving.
12:28:23 <ReinH> Using the rubik's cube symmetry group to operate on the cube using the basic transformations in any orientation
12:28:25 <Cale> ReinH: conjugating by the isomorphism
12:28:34 <ReinH> Cale: conjugating, right. I thought it might be.
12:28:35 <dwcook> Noldorin: or a type alias for that matter.
12:28:36 <ReinH> Cale: thanks
12:28:42 <Noldorin> dwcook, true but it kind of is anyway... and for each combination of monads, you need a newtype, as far as I understand
12:28:49 <ReinH> Cale: I was looking at rotors and stuff o_O should have kept it simple
12:29:01 <Cale> ReinH: In a more practical functional programming setting, it's often referred to as the worker/wrapper transformation :)
12:29:07 <ReinH> Cale: yep :)
12:29:18 <ReinH> Cale: tyvm
12:29:26 <dwcook> Noldorin: well I think a newtype tends to be the most useful when you have a fixed stack. Honestly I haven't run into the uglier parts of working with transformers.
12:29:32 <rwbarton> or you can call it "transport" if you want to be trendy
12:30:52 <ReinH> Cale: Anyway I'm writing a thing on using group morphisms to reason about code that uses that sort of conjugation
12:30:59 <DaveS> is there a reason why you can't have two variables with the same name and different types?
12:31:27 <ReinH> You can if one is shadowing the other, but that's generally unwise.
12:31:37 <Cale> DaveS: Well, it screws up type inference by being ambiguous in a way which is unpleasant.
12:31:48 <Cale> DaveS: This is what type classes are for
12:31:49 <dwcook> DaveS: imagine what would happen if the types were unifiable.
12:32:35 <dwcook> (Though you can have OverlappingInstances, they're still principled.)
12:32:45 <dwcook> (And that requires an extension.)
12:33:00 <Cale> You don't even need OverlappingInstances necessarily
12:33:12 <Cale> You just need... regular instances :)
12:33:24 <rwbarton> x :: String, x :: Int, print x
12:33:49 <dwcook> Yeah, I was just pointing out that having two bindings of the same name with different but unifiable types in scope isn't necessarily a game breaker.
12:33:50 <DaveS> like say you have var x = 10; var x = "blah"; and then f = x + 5;
12:34:04 <DaveS> there is only one variable that is possible to use in that instance
12:34:16 <dwcook> DaveS: Well actually…
12:34:26 <Cale> DaveS: There *could* be an instance of Num for String
12:34:27 <dwcook> DaveS: Did you know you can define instance Num String?
12:35:06 <dwcook> A better example would be f = x ++ []
12:35:09 <dwcook> Wait no
12:35:14 <dwcook> Forget about numeric literals
12:35:33 <Cale> In which case, both would typecheck. As a matter of principle, the compiler never assumes that there won't be an instance of a type class present when deciding which instance to select, because future modules might define one, resulting in inconsistency.
12:35:38 <dwcook> let x = 'a' ; x = [x] ; y = x ++ []
12:35:52 <Cale> But you can do this:
12:35:59 <Cale> class X a where
12:36:01 <Cale>   x :: a
12:36:10 <Cale> instance X Integer where x = 10
12:36:16 <Cale> instance X String where x = "blah"
12:36:50 <Cale> and then f :: (Num a, X a) => a
12:37:16 * dwcook wonders (if there is / why there isn't) a closed analog of typeclasses.
12:37:28 <rwbarton> anyways you could come up with a situation where it was actually unambiguous which x to use
12:37:56 <Cale> dwcook: http://www.haskell.org/ghc/docs/7.8.1-rc1/html/users_guide/type-families.html#closed-type-families
12:38:11 <Cale> There is that at least
12:39:01 <Cale> oh, that's the rc documentation
12:39:02 <dwcook> Hmm, but that's for type-associated types, not type-associated values.
12:39:12 <Cale> damnit google ;)
12:39:20 <Cale> dwcook: right
12:40:06 <Tjr> How do you typically deal with the situation that you want to transparently choose one implementation for a function if the types satisfy certain requirements, and another implementation if not?
12:40:07 <Tjr> For example, the nub function makes things unique if they support Eq. The set Data.Map functions are much faster on things that support Ord.
12:40:07 <Tjr> Now I'd want to choose Data.Map if possible, but nub otherwise - without the user knowing.
12:40:17 <DaveS> I'm working with this functional web programming language that has tags and styles as part of the language and it causes conflicts. :\
12:40:39 <DaveS> like if you have a style named 'h1' and a tag named 'h1' it causes issues
12:40:56 <DaveS> but you don't want to have to say 'Bootstrap.h1' in the code cause that sucks :\
12:41:07 <Cale> DaveS: h1tag h1style?
12:41:20 <Cale> If they're unrelated things, they shouldn't be named the same
12:41:26 <DaveS> Cale: Think of the bootstrap library, you want the tag names to stay the same
12:41:32 <rwbarton> Tjr: you can use a RULE for that I think
12:41:34 <DaveS> err the style names
12:41:43 <Cale> I'm not sure I understand
12:41:49 <rwbarton> Tjr: though maybe it's best to just let the user pick the most appropriate function
12:42:04 <Cale> It shouldn't matter what the names are, so long as they're unique and reasonably identifiable?
12:42:13 <Tjr> rwbarton: This thing? http://www.haskell.org/haskellwiki/GHC/Using_rules
12:42:21 <DaveS> Cale: In theory yes
12:42:32 <rwbarton> Tjr: yes
12:42:41 <rwbarton> also see http://www.haskell.org/ghc/docs/7.8.2/html/users_guide/rewrite-rules.html
12:42:56 <DaveS> in practice having to figure out what the program name for a bootstrap css style is.. sucks
12:43:34 <Hasky> Hey there
12:43:41 <Tjr> rwbarton: thank you
12:43:46 <Hasky> I am a newbie, doing 99 haskell problems
12:43:58 <moarrr_bitcoins> i got 99problems haskell aint one
12:43:58 <moarrr_bitcoins> ;)
12:44:13 <Hasky> i have a little problem with problem 9, which is compress
12:44:15 <Taneb> Hasky, hi, do you have a question?
12:44:20 <Hasky> sure
12:44:25 <koala_man> Tjr: have you looked at type families?
12:44:38 <Iceland_jack> Hasky: What have you go so far?
12:44:47 <Hasky> compress removes duplicates
12:44:48 <Tjr> koala_man: I just started 2 days ago, so I'm not familiar with a lot of things.
12:44:54 <Hasky> hre it is my solution
12:44:54 <Tjr> What are type families?
12:45:07 <Hasky> compress:: [a]->[a]
12:45:07 <Hasky> compress [] = []
12:45:07 <Hasky> compress [x] = [x]
12:45:07 <Hasky> compress [x:y:zs] = if x==y then compress (x:zs) else x:(compress y:zs)
12:45:11 <Iceland_jack> Hasky: please use lpaste
12:45:16 <Iceland_jack> @where lpaste
12:45:17 <lambdabot> http://lpaste.net/new/haskell
12:45:28 <Iceland_jack> also you can see that the type is wrong
12:45:30 <Hasky> ok
12:45:38 <Hasky> what do you think?
12:45:43 <Hasky> it does not compile,,,
12:45:51 <Iceland_jack> right, you also lack an Eq constraint and some other things
12:46:04 <Hasky> it says conflicting x
12:46:25 <Iceland_jack> so first of all, let's cover
12:46:25 <Iceland_jack>     [x:y:ys]
12:46:30 <Hasky> ok
12:46:33 <Iceland_jack> that pattern probably doesn't do what you want it to do
12:46:40 <Iceland_jack> It _only_ matches lists of length 3
12:47:01 <Hasky> i suppose 1:2:[] matches
12:47:03 <dwcook> Not even that, it matches lists of one list of at least two elements
12:47:24 <Iceland_jack> ah yes, good catch
12:47:46 <Hasky> so i thought it could work
12:47:56 <dwcook> Hasky: the (:) constructor already means list, if you add the [ brackets ] then that means you're matching yet another list
12:48:03 <dwcook> so you want ( parens ) instead
12:48:08 <dwcook> (x:y:zs)
12:48:09 <Iceland_jack> Hasky: Can you tell me what the input of the function is?
12:48:15 <Iceland_jack> of ‘pack’
12:48:24 <Hasky> argh!!!
12:48:32 <Hasky> now i see!!
12:48:41 <Hasky> I've been so wrong!
12:48:47 <Hasky> thanks for spotting that
12:50:04 <dwcook> Hasky: note how you wrote (x:zs) and not [x:zs]. Patterns are intentionally given syntax to mirror that.
12:50:51 <Hasky> dwcook: Hey guys, thanks for all, lemme see if it works...
12:54:10 <Hasky> it works!!
12:54:19 <dwcook> \o/
12:54:20 <Hasky> and i didn't even use head or group!!
12:54:25 <dwcook> Good :)
12:54:56 <Hasky> night!
12:55:14 <merijn> Tjr: Type families are type level functions
12:55:21 <dwcook> Take care.
12:56:59 <hpc> is it just me, or is Acme.Omitted actually incredibly useful?
12:57:20 <merijn> hpc: Isn't it just spoon?
12:57:33 <merijn> i.e. deepseq + exception catching
12:57:36 <hpc> well, not the spoon parts
12:57:46 <hpc> just omitted and (...)
12:57:51 <hpc> are handy notational tricks
12:57:58 <merijn> hpc: That seems like an inferior TypedHoles
12:58:13 <merijn> hpc: Especially given that TypedHoles is on by default
12:58:51 <hpc> oh right, forgot about that
12:58:57 <hpc> still on 7.4.1 so no holes for me
12:59:26 <dwcook> hpc: That's actually kind of brilliant
13:00:02 <bennofs> hpc: note that (...) is a lens operator :)
13:00:10 <hpc> of course it is
13:00:18 <bennofs> :t (...)
13:00:20 <lambdabot> (Plated c, Applicative f) => LensLike f s t c c -> Over p f c c a b -> Over p f s t a b
13:00:43 <hpc> i tried to say that type signature out loud and came up with "pppppfsh"
13:00:49 <bennofs> So you might get name clashes if you use that in a project together with lens
13:01:05 <dwcook> I've heard there's a lens operator spelled with the unicode symbol representing the old ones and the eventual demise of the world
13:01:29 <rwbarton> there are a lot of lens identifiers that look like holes too :)
13:02:02 <FireFly> :t (^@..)
13:02:03 <lambdabot> s -> IndexedGetting i (Endo [(i, a)]) s a -> [(i, a)]
13:02:07 <FireFly> it's the snail operator
13:02:46 <benzrf> edwardk: why do u do this to us
13:03:02 * geekosaur trying to find a certain short story...
13:03:14 <merijn> dwcook: Switch to 7.6 and use TypedHoles instead!
13:03:33 <dwcook> merijn: My default GHC is 7.8.2 :)
13:03:46 <merijn> dwcook: Good, I actually meant to type 7.8 :p
13:03:55 <merijn> dwcook: So, use TypedHoles! They're on by default!
13:04:14 <dwcook> Instead of writing undefined you mean?
13:04:20 <merijn> Yes
13:04:24 <dwcook> Neat.
13:05:38 <geekosaur> (there's a story I once read which posited a "Gödel image" that caused insanity on sight. nonsense, but also fodder for proposed lens operators :p )
13:05:54 <dwcook> :D
13:06:05 <rwbarton> (in fact there is nothing called "TypedHoles")
13:06:25 <dwcook> Why do the GHC minor versions increment by two at a time on the releases listed on https://www.haskell.org/ghc/ ?
13:07:15 <geekosaur> the odd numbered ones are development versions
13:07:36 <geekosaur> so, 7.8 being released, the devel branch is 7.9 and 7.10 release branch will eventually be cut from it
13:07:37 <dwcook> That's an interesting scheme.
13:07:47 <geekosaur> roughly the same scheme the Linux kernel uses
13:07:51 <merijn> Just use a random underscore-prefixed identifier that is out of scope and it will print an error that lists the source line + type of the identifier when you compile
13:08:23 <geekosaur> or used to in 2.x at least
13:08:46 <merijn> rwbarton: ok, so it has a space in there, whatever!
13:32:07 <Nik05> hello. Some of the prelude classes have a minimal complete definition. Is this only possible for the classes that are in the prelude or can you also do this for your own classes?
13:32:37 * hackagebot learn-physics 0.4.3 - Haskell code for learning physics  http://hackage.haskell.org/package/learn-physics-0.4.3 (ScottWalck)
13:32:38 <Nik05> And the same holds for the "deriving" from a class?
13:32:39 * hackagebot learn-physics-examples 0.3 - examples for learn-physics  http://hackage.haskell.org/package/learn-physics-examples-0.3 (ScottWalck)
13:34:19 <Philonous> Nik05, You can add default values for the class members
13:34:34 <Philonous> Nik05, Those default values can refer to other members of the class
13:36:33 <Philonous> Nik05, Say you have (class Foo a where foo :: Int -> a -> a; bar :: a -> a; bar  = foo 0 ) now you only need to defined foo when declaring an instance (though you can still define bar if you want)
13:36:47 <Nik05> ah ok thank you
13:37:02 <dwcook> Can they reference methods of other classes?
13:37:47 <Nik05> but wait the Ord class has a comment Minimal complete definition (<=) or compare, how can there be two minimal complete definitions?
13:38:09 <Nik05> oh wait i get it
13:38:09 <Philonous> Nik05, deriving is indeed special, that is, only a select few classes can be derived automatically.
13:38:13 <dwcook> Nik05: It's your choice which to implement. The defaults are in terms of each other.
13:38:49 <Nik05> ok thank you Philonous and dwcook
13:39:16 <merijn> dwcook: Yes, but only if GHC knows the other class is available
13:39:37 <merijn> dwcook: i.e. defaults of Applicative can use fmap, because Functor is a superclass (and fmap must thus be implemented)
13:39:45 <dwcook> merijn: you mean if it's in scope?
13:40:05 <dwcook> Oh. But I can't default fmap = liftA?
13:40:37 <rwbarton> it won't type check
13:40:38 <merijn> dwcook: Right, because then "fmap" would need a "Applicative f => (a -> b) -> f a -> f b" type
13:41:06 <merijn> dwcook: You can partially get away with this by using the DefaultSignatures extension.
13:41:29 <merijn> Which will allow default implementations whose types are more specific than the actual type of the function
13:41:58 <literon> Hello - what is the pipes channel's name?
13:42:09 <dwcook> Sure, it's just that I often find myself writing the exact same Functor and Applicative instances for something that I know has a Monad instance. There's no reasonable way for them to be written for me?
13:42:13 <merijn> dwcook: i.e. "class PrettyPrint a where pretty :: a -> String" can use DefaultSignatures to define a default implementation with the type "Show a => a -> String"
13:42:28 <merijn> dwcook: No, although you could use WrappedMonad?
13:42:29 <dwcook> instance Applicative Foo where { pure = return ; (<*>) = ap }
13:42:55 <Crowds> hello guys
13:43:00 <merijn> dwcook: WrappedMonad is a newtype wrapper for monads which has a Functor/Applicative instance
13:43:07 <merijn> literon: I don't believe there is one?
13:43:21 <Crowds> I have a question: is there a library/module for haskell similar to python's scrapy?
13:43:32 <literon> merijn: oh, ok. Somehow assumed.
13:44:05 <dwcook> DefaultSignatures seems to be exactly what I'm talking about.
13:44:27 <merijn> literon: The mailing list is very active
13:44:35 <dwcook> merijn: the problem isn't that I have something with just a Monad instance and want it to be Applicative and Functor as well, it's that I don't want to repeat myself while defining all three for the same type.
13:44:51 <merijn> dwcook: That doesn't help for Functor/Applicative, though. Only for classes you define yourself
13:45:18 <dwcook> merijn: It could help if Functor and Applicative were changed to use it. Though how realistic that is is another question.
13:45:27 <merijn> dwcook: Just implement Monad using Applicative?
13:45:43 <dwcook> How would you do that? Monad's more powerful than Applicative.
13:46:13 <merijn> dwcook: "return = pure", "ap = (<*>)"?
13:46:25 <rwbarton> dwcook: using DefaultSignatures in Functor like that also wouldn't really be "right", after all you might be defining something else like a Comonad
13:46:28 <merijn> I guess you'd still need to implement >>=, but you need to do that anyway
13:46:50 <dwcook> merijn: exactly. If I can get away with defining just return and (>>=), I'd be happy.
13:47:18 <rwbarton> I mean it would be kind of arbitrary to just pick one superclass of Functor
13:47:30 <dwcook> rwbarton: subclass you mean? And yeah, I see your point.
13:47:34 <rwbarton> er yes
13:47:39 * hackagebot learn-physics-examples 0.3.1 - examples for learn-physics  http://hackage.haskell.org/package/learn-physics-examples-0.3.1 (ScottWalck)
13:48:18 <merijn> dwcook: Well, either works. Monad is a subclass of Functor in the sense that all monads are functors. But Monad is a superclass of Functor in the sense that a Monad is a functor PLUS some extra power
13:49:11 <dwcook> merijn: I'm not sure the latter is coherent.
13:49:23 <dwcook> Anyway it'd go against established terminology.
13:49:30 <rwbarton> that was the thought process by which I produced "superclass"
13:50:06 <merijn> dwcook: How is it not coherent? Any Monad can do everything Functor can plus some more
13:50:37 <dwcook> merijn: yes but a superclass is "bigger" than the class under discussion. There are "more" Functors than Monads since every Monad is a Functor but not vice versa.
13:50:41 <rwbarton> anyways for Functor there's no issue, since you can derive it, and for Applicative, picking the default from Monad by convention would be reasonable
13:51:02 <merijn> dwcook: I agree that established convention says that superclass in Haskell == class required to instantiate
13:51:40 <kazagistar> the existance of both pure and return seems silly
13:52:11 <hpc> kazagistar: they exist for hysterical raisins
13:52:31 <Guest41930> can you implement fmap using applicative without using <$>?
13:52:33 <hpc> Monad predates Applicative, so it had a bunch of stuff that should come from lower classes
13:52:50 <merijn> kazagistar: The notion of Applicative functors was invented after Monads were
13:52:57 <jle`> Guest41930: pure and (<*>)
13:52:58 <dwcook> @src liftA
13:52:59 <lambdabot> liftA f a = pure f <*> a
13:53:03 <dwcook> Guest41930: that
13:53:17 <kazagistar> hpc: I know, I am just patiently waiting for it to be fixed :D
13:53:25 <kazagistar> I feel like I might wait a long time
13:53:32 <jle`> kazagistar: 7.10 :)
13:53:36 <hpc> i heard a rumor that we were actually...
13:53:36 <jle`> apparently.
13:53:37 <hpc> yeah, that
13:53:43 <merijn> kazagistar: 7.10 will make Applicative a superclass of Monad
13:54:02 <hpc> that's going to be awesome for those of us who write all our instances
13:54:03 <merijn> There were plans to move "join" into the Monad typeclass too, but those might die due to a conflict with roles
13:54:14 <hpc> roles?
13:54:19 <dwcook> jle`: Are you sure they're fixing _that_ in 7.10? I know that's when they add Applicative as superclass of Monad.
13:54:27 <jle`> having both pure and return?
13:54:31 <jle`> yeah, i guess not exaxctly
13:54:33 <jle`> darn
13:54:35 <merijn> hpc: They're a new thing in 7.8 to make typesafe coercion of newtypes possible
13:54:39 <dwcook> jle`: Also join as method of Monad, if I recall.
13:54:51 <rwbarton> well it's not like we will ever just remove return entirely
13:54:52 <merijn> dwcook: As I just mentioned, that might be dropped
13:55:00 <hpc> nifty
13:55:02 <dwcook> Oh well.
13:55:16 <hpc> i need to catch up on my ghc features
13:57:56 <jle`> pure is almost as loaded a word as return though
13:58:09 <dwcook> How about "lift"? :)
13:58:12 <jle`> i say we just call it mu
13:58:18 <jle`> er
13:58:20 <jle`> nu
13:58:25 <Welkin> loaded?
13:58:27 <hpc> no no, mu is perfect
13:58:28 <jle`> eta
13:58:29 <Welkin> in what way?
13:58:30 <hpc> ;)
13:58:40 <Welkin> for those coming from a background in imperative languages?
13:59:01 <jle`> Welkin: yes
13:59:04 <jle`> well, return is
13:59:10 <jle`> pure is too
13:59:12 <Welkin> it doesn't matter
13:59:18 <hpc> change the name to 'static'
13:59:23 <dwcook> Actually "lift" is almost perfect: We'd have lift0, lift1, lift2, …
13:59:23 <hpc> so that it is equally confusing to all parties
13:59:25 <Welkin> all words have many meanings
13:59:29 <hexagoxel> is eclipseFP compatible with ghc 7.8.2?
13:59:40 <Welkin> same with human languages
14:00:05 <jle`> is monoid loaded?
14:00:10 <kazagistar> what is pure loaded with?
14:00:24 <jle`> the whole impure/pure thing
14:00:32 <dwcook> kazagistar: "immutable", "referentially transparent", etc.
14:00:36 <Welkin> hexagoxel, why would you use eclipse with haskell?
14:00:43 <kazagistar> gotcha
14:01:21 <jle`> yeah, let's call it eta
14:01:26 <kazagistar> I put my vote in for "lift0"
14:01:52 <jle`> or we can go full agda and call it 
14:02:04 <jle`> η
14:02:08 <dwcook> jle`: What character is that? My font won't render it.
14:02:09 <Welkin> jle`, that character does not display on my system
14:02:16 <dwcook> Ah, eta.
14:02:18 <Welkin> oh, I see it
14:02:19 <hexagoxel> Welkin: because i frequently get more than a few screenful of errors in my terminal while programming, and i am annoyed by the necessity to scroll up, basically
14:02:49 <Welkin> hexagoxel, you know there is a haskell editor written in haskell?
14:03:00 <hexagoxel> tried to install leksah ealier
14:03:05 <Welkin> http://www.haskell.org/haskellwiki/Editors
14:03:10 <DaveS> is there a haskell compiler written in haskell?
14:03:12 <hexagoxel> *earlier, did not compile
14:03:17 <jle`> DaveS: yes
14:03:24 <jle`> it's called GHC
14:03:37 <Welkin> DaveS, I can't tell if that was a joke or a serious question
14:03:42 <geekosaur> actualy at least two, since jhc is written in Haskell as well
14:03:43 <hexagoxel> problem was some gkt stuff, i may try that again..
14:03:43 <dwcook> GHC compiles with GHC Haskell
14:03:44 <DaveS> half joking lol
14:03:50 <geekosaur> (although not self-hosting like ghc)
14:04:20 <DaveS> so how was haskell originally written?
14:04:33 <DaveS> err rather ghc
14:04:40 <dwcook> You mean what language was GHC's predecessor written in?
14:04:43 <DaveS> yeah
14:04:44 <Welkin> bootstrapping
14:04:44 <geekosaur> the first version of ghc was written in a now dead language called Lazy ML
14:04:45 <Cale> I believe Lennart wrote HBC in LML?
14:05:14 <Cale> Yeah
14:05:25 <jle`> i think someone went back in time with a compiled GHC, and gave it to the original GHC implementors
14:05:29 <jle`> closing some sort of causality loop
14:05:33 <bergmark> wow
14:05:45 <dwcook> jle`: But the jerks didn't offer the source
14:05:52 <dwcook> GHC could be full of backdoors
14:05:55 <geekosaur> heh
14:05:57 <dwcook> (Just kidding it probably isn't)
14:06:17 <hexagoxel> Welkin: just to be sure: your recommendation would be leksah?
14:06:39 <Welkin> I just use emacs
14:06:57 <jle`> i always wondered if the gcc binary on my computer had backdoors
14:08:04 <hexagoxel> a backdoor that detects when you are compiling a compiler, inserting itself
14:08:06 <Allison18>  Hi! I give you some videos. I hope you like! http://bitly.com/1hryamV
14:08:23 <Philonous> dwcook, Even with the source you could never be sure because GHC might inject it during (self-)compilation
14:08:29 <Welkin> I haven't seen so much spam on a network in years
14:08:48 <Welkin> I wonder where the spam is coming from
14:09:08 <jle`> well, freenode is probably the most popular irc server, and #haskell is among the most popular channels on freenode
14:11:42 <dwcook> Philonous: even better, what if our hardware was doing it?
14:12:02 <dwcook> Of course that would imply a different party
14:12:05 <Welkin> there was a discussion of this I read several months ago
14:12:41 <Welkin> build your own hardware
14:13:10 <dwcook> Time to learn circuits
14:13:39 <akurilin> Question: I have a bunch of Persistent entity definitions that I want to isolate into their own library so that I can use them across all of the applications that need to talk to that specific DB schema
14:14:00 <akurilin> Do I just make a separate cabal library project for it?
14:14:08 <akurilin> And if so, how do I include that as a local dependency?
14:14:17 <dwcook> akurilin: sounds reasonable
14:15:09 <dwcook> I couldn't answer the second question but a search proved fruitful https://stackoverflow.com/questions/19622809/depending-on-a-local-package-in-cabal
14:17:39 <randptr> You can use the Y combinator to express Curry's paradox which makes lambda calculus unsound as a deductive system. Wouldn't that make it unsound as the basis for programming as well? If not, why not?
14:18:11 <dwcook> randptr: a programming language doesn't need to be usable for deduction to be useful.
14:18:16 <int-e> randptr: the Y combinator leads to nontermination.
14:18:26 <dwcook> In fact what breaks deduction in Haskell is undefined :: forall a. a
14:18:38 <dwcook> Every type ("proposition") is inhabited ("provable").
14:18:43 <int-e> randptr: and that's about the worst that it does, since lambda calculus is confluent, hence has unique normal forms
14:20:12 <dwcook> You'll often see people reasoning in Haskell "up to bottom", that is, ignoring its existence. This can often be done while still obtaining meaningful results.
14:26:16 <randptr> is there some axiom of choice type solution (it is a bit of a hack isn't it) for lambda calculus?
14:27:15 <dolio> Solution to what?
14:27:49 <dwcook> Wouldn't the existence of bottom make the "axiom of choice" trivially true?
14:28:35 <randptr> existence of bottom?
14:28:52 <dwcook> The undefined :: forall a. a I mentioned above is also called "bottom".
14:29:06 <dwcook> Or _|_, or written with the symbol resembling that.
14:29:16 <dwcook> (that that resembles, really)
14:29:21 <Welkin> contradiction in FOL?
14:29:24 <randptr> I hope that's not a finger to me.
14:29:40 <dolio> That is the symbol for bottom.
14:29:42 <dolio> ⊥
14:29:51 <geekosaur> crude ASCII approximation of an upside down T, representing the least defined value
14:30:55 <kazagistar1> dwcook: bottom does not make for a useful axiom of choice, and is not used in set formulations afaik
14:32:02 <dwcook> kazagistar1: What I mean is that of course you can choose something from every type, and it can be bottom. Perhaps I'm not putting things together correctly. Although I don't think Haskell types can be considered sets.
14:33:48 <kazagistar1> dwcook: yeah, its that last sentece. types are not sets
14:34:18 <dolio> They can be in some type theories; but not all.
14:34:39 <coppro> is there a handy data structure for an ordered set? That is, that maintains the insert order of elements, but does not allow duplicates?
14:34:41 <dwcook> dolio: wouldn't it depend on which set theory you use, rather than which type theory?
14:34:47 <coppro> as opposed to just going by Ord
14:34:57 <dwcook> coppro: what happens if you try to insert a duplicate?
14:35:11 <dolio> It might depend some on which set theory you use.
14:35:24 <dolio> But you'd have to be using a weird set theory for some of the type theories.
14:35:37 <coppro> dwcook: ideally, fails
14:35:46 <dwcook> coppro: fails how? Nothing? Bottom?
14:35:51 <dolio> There are other type theories with set theoretic models that would not be considered weird set theories.
14:36:05 <coppro> dwcook: identity operation on the data structure
14:36:35 <dwcook> coppro: my thinking is you could use lists or a newtype thereof and expose only operations that check for existence.
14:36:44 <coppro> dwcook: seems sensible
14:37:05 <teneen> how can "cabal install --force-reinstalls" break some packages?
14:37:10 <Welkin> so there is not a "set" data primitive?
14:37:14 <Tjr_>  hi, how do I get the library Math.Combinatorics.Exact.Binomial?
14:37:18 <kazagistar1> coppro: you could probably use a finger tree and get fairly optimial time complexity
14:37:23 <dwcook> Welkin: there's a Set but it's not primitive. It's in containers.
14:37:25 <Tjr_> It doesn't load with the usual commands.
14:37:54 <rwbarton> have you installed whatever package it's in?
14:38:31 <Tjr_> rwbarton: probably not. How do I do that? I've got GHCi, version 6.12.3 because more recent version don't run on my computer.
14:38:31 <dwcook> Welkin: Also it's not really a set. It's a BST.
14:38:49 <rwbarton> uh, well
14:38:53 <rwbarton> figure out what package it's from first
14:39:06 <coppro> kazagistar1: thanks
14:39:19 <rwbarton> google suggests "exact-combinatorics"
14:39:21 <Welkin> dwcook, nice to know
14:39:27 <rwbarton> then, uh
14:39:31 * rwbarton enters a time machine to 4 years ago
14:39:53 <Tjr_> It's right here: http://hackage.haskell.org/package/exact-combinatorics-0.2.0/docs/Math-Combinatorics-Exact-Binomial.html
14:40:04 <rwbarton> do you have the 'cabal' command-line program?
14:41:02 <Tjr_> 1.8.0.6 of the Cabal library
14:41:16 <rwbarton> ok, try   cabal install exact-combinatorics
14:41:25 <Tjr_> root, or normal user?
14:41:48 <kazagistar1> coppro: it might be easier to just use 2 collections, one to maintain order and one for uniqueness
14:42:06 <rwbarton> normal user will install it in your per-user package database which is almost certainly what you want
14:42:47 <Tjr_> "Downloading the latest package list from hackage.haskell.org" >> those will likely not run on my system either, right?
14:43:34 <rwbarton> some packages may work
14:44:16 <akurilin> Cabal sandbox question: is it normal for me to get a "the following packages are likely to be broken by the reinstalls" when running cabal install --only-dependencies on a brand-new sandboxed project?
14:44:34 <akurilin> I expected it to have to redownload every single package from scratch without worrying about breaking anything
14:45:00 <Tjr> rwbarton: done, it seems to have worked. Now I get a different error from ghci :-)
14:45:08 <rwbarton> hurrah
14:45:26 <bergey> akurilin: which packages are likely to be broken?  GHC?
14:45:52 <jle`> i wonder how bad it would be to use a modified pandoc in production
14:46:24 <coppro> kazagistar1: one is probably easier given the particular application, but yeah, that would be an option too
14:46:44 <jle`> i've reached a point where i can't do what i want to do without either modifying the source/library to my own custom needs, or being very hacky
14:46:47 <akurilin> bergey: process, haskell98, ghc, cabal, bin-package-db, hpc
14:46:55 <akurilin> bergey: not sure what's going on there
14:48:06 <rwbarton> akurilin: it would help to see the old output but it sounds like your project has a dependency on an old version of a package that comes with ghc, like containers or something
14:48:08 <bergey> Yep.  cabal sandboxing doesn't sandbox ghc (obviously you wouldn't want it to).  So you can get that message if you try to install something that requires a newer version of something GHC itself depends on.
14:48:17 <rwbarton> older than the version that came with the version of ghc you're using
14:49:15 <kazagistar1> coppro: finger trees require some careful and somewhat complex customization to be useful
14:49:25 <akurilin> I'm using 7.8.2 and cabal 1.20, and it's at least suggesting I downgrade to cabal-1.18
14:50:34 <dwcook> Is there some way to generate the shape of the free monoid from the monoid laws? Does that coincide with the standard Haskell formulation of lists? Can something similar be done for the free monad?
14:50:51 <coppro> kazagistar1: thankfully there's Data.Sequence
14:50:54 <ReinH> dwcook: the shape of?
14:51:07 <dwcook> For example, data Free f a = Pure a | Free (f (Free f a)). Can that be derived from the monad laws?
14:51:32 <akurilin> rwbarton: ah let me check, that's a good point
14:51:35 <rwbarton> dwcook, not entirely mechanically
14:51:50 <dwcook> rwbarton: why not? And how would it be done?
14:52:02 <coppro> dwcook: in a sense, yes. The UMPs of the free algebras make them unique, and there's a categorial-theoretic generalization called an adjoint functor.
14:52:07 <coppro> if my memory serves
14:52:14 <mister_integer> Is it possible to use the dot operator to compose functions with arity greater than 1?
14:52:24 <ReinH> coppro: that's correct
14:52:34 <ReinH> A free functor is left-adjoint to a forgetful functor
14:52:39 <akurilin> rwbarton: http://lpaste.net/2494477972854013952 - this has the output
14:52:50 <dwcook> mister_integer: sure. Just the one's input has to be the same type as the other's output.
14:52:52 <dwcook> @type (.)
14:52:53 <lambdabot> (b -> c) -> (a -> b) -> a -> c
14:52:55 <rwbarton> right so that gives you a description (for the free monoid) as certain trees modulo equivalence relations that come from the laws
14:52:59 <mister_integer> in particular, let f = (+), let g = (==0), then (f . g) fails with a compile error
14:53:01 <ReinH> mister_integer: Compositions of (.) can do that, but it doesn't make it much better than explicitly writing it out
14:53:02 <dwcook> mister_integer: remember that all functions actually have only one parameter.
14:53:09 <mister_integer> wait, that's the wrong order
14:53:10 <mister_integer> lol
14:53:30 <mister_integer> No, it doesn't work with (g . f) either
14:53:57 <rwbarton> akurilin: oh hm I saw this recently. Try cabal install --only-dependencies --constraint 'bytestring ==0.10.4.0'
14:54:28 <ReinH> dwcook: there is a mechanical transformation one can do from the laws to a data type that "encodes" the laws
14:54:30 <cdsmith> mister_integer: strictly speaking, all Haskell functions have an arity of 1.  (.) composes those low level arity-1 functions.  It won't work out of the box for the higher-arity function that exists in your mind. :)
14:54:34 <ReinH> dwcook: consider a very simple example, the free magma
14:54:38 <akurilin> rwbarton: oh that worked
14:54:39 <dwcook> ReinH: great, that's exactly what I'm asking for.
14:54:44 <rwbarton> dwcook: if you want to get from that trees-modulo-equivalence description to the data [a] = [] | a : [a] description you need the "insight" that you can reassociate to the right to get normal forms
14:54:50 <mister_integer> dwcook: okay, so I have two functions f and g: :t f = Int -> Int -> Int, and :t g = Int -> Bool
14:55:03 <mister_integer> the expression (g . f) blows up
14:55:07 <cdsmith> mister_integer: But, try (== 0) . uncurry (+)
14:55:09 <ReinH> data Magma a = Val a | Magma a `Plus` Magma a
14:55:14 <akurilin> rwbarton: so basically I was defaulting to a 7.6.x versino of bytestring?
14:55:35 <ReinH> dwcook: it's not entirely mechanical, but it's relatively easy to see how to construct this encoding
14:55:51 <rwbarton> akurilin: I actually have no idea what the cause is
14:56:01 <rwbarton> some infelicity of the solver
14:56:01 <dwcook> ReinH: see, I was inclined to write data FreeMonoid a = Empty | FreeMonoid a `Append` FreeMonoid a, but that's clearly wrong. But I couldn't figure out what I missed, since it seemed to encode the identity and the operation.
14:56:23 <ReinH> dwcook: This is a free magma, not a free monoid
14:56:28 <akurilin> rwbarton: hah ok fair enough, I better pin that version to >= in the cabal file
14:56:33 <rwbarton> akurilin: yep
14:56:45 <ReinH> dwcook: consider the free semigroup.
14:56:47 <akurilin> rwbarton: thank you so much for solving that!
14:56:54 <mister_integer> cdsmith: it's weird that you have to uncurry a function to compose it with something
14:56:57 <ReinH> dwcook: Note that the free magma data type is isomorphic to a binary tree
14:57:16 <cdsmith> mister_integer: uncurrying makes it a unary function (whose parameter is a tuple)
14:57:21 <ReinH> dwcook: In order to make it a free semigroup, we need some way of encoding the associativity law
14:57:44 <mister_integer> cdsmith: Yeah, which is the opposite of what everyone else has been saying, which is that all haskell functions are "unary"
14:57:46 * hackagebot docopt 0.6.0 - A command-line interface description language and parser that will make you smile  http://hackage.haskell.org/package/docopt-0.6.0 (ryanartecona)
14:58:10 <dwcook> ReinH: okay, so I definitely missed encoding associativity.
14:58:11 <cdsmith> mister_integer: It's true that all functions are unary.  It's just a matter of what's the parameter, and what's the result.
14:58:19 <dwcook> ReinH: how do you go about doing that mechanically?
14:58:29 <mister_integer> Like, since it knows that g :: Int -> Bool, why can't it figure out that the "result" is the Int part?
14:58:30 <mister_integer> huh
14:58:40 <ReinH> dwcook: one way is to pick an either left- or right-biased tree
14:58:50 <mister_integer> I guess it seems really easy in this simple case but maybe it's actually a really difficult problem in general
14:59:27 <ReinH> dwcook: in other words, a tree where each left child must be a leaf
14:59:36 <rwbarton> this is the non-mechanical part
14:59:43 <dwcook> rwbarton: That's what I was thinking.
14:59:44 <cdsmith> mister_integer: (+) :: Int -> Int -> Int, is a unary functon that takes an Int as a parameter, and returns a function from Int to Int.  That's messy to compose.  But uncurry (+) takes a (Int, Int) and returns Int.  That composes nicely
15:00:01 <ReinH> dwcook: can you see how that forces the structure to be associative?
15:00:13 <dwcook> ReinH: not exactly. I believe it but haven't connected everything.
15:00:19 <mister_integer> cdsmith: ah yeah, it makes more sense now
15:00:21 <ReinH> dwcook: let's write that data structure
15:00:23 <mister_integer> thanks!
15:01:04 <cdsmith> mister_integer: np.  There are tricks for using (.) with curried higher order functions, too.  There are many permutations of things that accomp[lish your goal... but they aren't as simple as you were looking for.
15:01:04 <mister_integer> solution: curry (g . (uncurry f))
15:01:06 <mister_integer> haha
15:02:39 <cdsmith> mister_integer: another one: fmap g . f
15:02:47 <ReinH> dwcook: data FreeMonoid a = Var a `Plus` (FreeMonoid a) -- only allows adding to the tree on the right
15:03:09 <dwcook> ReinH: there should be an Empty case too, right?
15:03:17 <ReinH> oh am I doing monoids?
15:03:21 <ReinH> yes, this is a free semigroup
15:03:22 <ReinH> sorry
15:03:26 <dwcook> Okay, continue
15:03:28 <mister_integer> cdsmith: you're blowing my mind right now
15:04:00 <ReinH> a free monoid would be: data FreeMonoid a = Empty | a `Plus` FreeMonoid a
15:04:07 <ReinH> dwcook: now, notice something about this type?
15:04:36 <dwcook> I notice many things about it but I'm not sure what I should be looking at.
15:04:51 <ReinH> dwcook: does it look similar to a type you already know?
15:05:06 <dwcook> Well, yes. I already remarked that I know free monoids are lists.
15:05:16 <dwcook> In fact I feel like the only reason it's obviously correct to me is _because_ I know lists.
15:05:22 <ReinH> Right, so this type, which we have arrived at constructively, is iso to the free list
15:05:39 <ReinH> dwcook: Ok, look at it this way
15:06:13 <ReinH> In a magma, (ab)c != a(bc)
15:06:34 <dwcook> I still don't understand how associativity told us we should have a case a `Plus` Free[Semigroup|Monoid] a
15:06:46 <ReinH> The FreeMagma representation would be: (Val 'a' `Tree` Val 'b') `Tree` Val 'c'
15:06:47 <ReinH> right?
15:07:03 <ReinH> of (ab)c
15:07:05 <dwcook> Hold on, let me write down the relevant laws here real quick.
15:07:18 <ReinH> and a(bc) would be Val 'a' `Tree` (Val 'b' `Tree` Val 'c')
15:07:24 <ReinH> you can see that these are not the same shape
15:07:56 <ReinH> Now try constructing (ab)c and a(bc) using the free semigroup, data FreeSemigroup a = a `Plus` FreeSemigroup a
15:08:12 <dwcook> I'm not sure I grasp the free magma since magmas don't have much structure as such.
15:08:25 <ReinH> They do!
15:08:30 <ReinH> They have tree structure :)
15:09:08 <ReinH> With a free semigroup I am forced into a right-associative construction: a `Plus` (b `Plus` c)
15:09:14 <ReinH> forced by the way the data structure is defined
15:09:18 <ReinH> for both a(bc) and (ab)c
15:09:31 <ReinH> so the data type is associative by construction
15:09:52 <mister_integer> cdsmith: okay, thinking about this some more, there must be a Functor instance for functions of type (a -> a -> b)
15:09:58 <mister_integer> is that approximately correct?
15:10:07 <dwcook> So a magma is (S : Set, * : S → S → S). The free magma should have S as a parameter. So can you explain how we go from that to encoding its structure?
15:10:11 <ReinH> the left hand side has to be a single value, so you can't construct any tree other than the one where left children are always leaves
15:10:14 <ReinH> leafs
15:10:26 <dwcook> Hmm, wait…
15:10:32 <dwcook> Those are exactly its constructors.
15:10:35 <ReinH> dwcook: * : (SxS) -> S
15:10:43 <ReinH> the x becomes a data constructor
15:10:45 <dwcook> Yeah, that's what I meant. Was thinking in Haskell.
15:10:48 <ReinH> call it Tree
15:11:32 <ReinH> the elements of the set need to be represented, so we just wrap them in a constructor, Val a
15:12:10 <dwcook> Okay, so I think I understand how the free magma is encoded, but not the general method behind it. I want to look at free semigroups again.
15:12:47 <dwcook> A semigroup is (S : Set, * : S × S → S) with the additional law a * (b * c) = (a * b) * c.
15:13:03 <dwcook> So what I don't get, it seems, is how to encode that law.
15:13:15 <ReinH> dwcook: ok, think about (ab)c and a(bc) as defining trees
15:13:20 <ReinH> right?
15:13:23 <dwcook> Okay.
15:13:24 <dwcook> brb
15:13:26 <fizruk> dwcook: to choose how to associate i think
15:13:26 <dreams> I have hatPath <- findExecutable "HatMake", hatPath is of type findExecutable :: String -> IO (Maybe FilePath). I am trying to print out hatPath with putStrLn but its says that hatPath is not of type String. In the docs FilePath is defined as type FiePath = String. I can't tell how to convert it to string so that putStrLn would work. Any suggestions?
15:13:53 <ReinH> One way of looking at (ab)c = a(bc) is that you can choose one as a canonical representation and convert the other into it
15:14:04 <cdsmith> dreams: hatPath has type Maybe FilePath
15:14:09 <ReinH> so with right-binding that means any (ab)c is converted into a(bc)
15:14:19 <dolio> dwcook: You choose one direction of the equality to be a rewrite rule, and then represent the normal forms.
15:14:29 <ReinH> s/canonical/normal, yes
15:14:43 <dreams> cdsmith: yes, and it has the path to an executable, how do I convert it to string so I can print it?
15:14:45 <cdsmith> dreams: So you can say: case hatPath of Left _ -> handleError ; Right path -> putStrLn path
15:14:47 <ReinH> So the FreeSemigroup encodes this normal form
15:14:51 <joebobjoe> what's easier to understand for a beginner? classical or intuitionistic logic?
15:15:01 <ReinH> and forces you encoding values into normal form by construction
15:15:07 <dolio> Or you do an arbitrary decision for each tree size, but still represent normal forms.
15:15:49 <cdsmith> dreams: or: either handleErrorWith putStrLn hatPath
15:15:51 <dolio> Or, exactly one of each size.
15:16:58 <dwcook> Back, reading the scrollback…
15:17:38 <cdsmith> dreams: where handleError and handleErrorWith say what to do if it's a Left instead
15:17:42 <dwcook> ReinH: okay, sort of makes sense.
15:18:07 <dwcook> ReinH: I see that the shape of that constructor represents one side of the equation, but not how the other side of the equation is encoded in there.
15:18:26 <dwcook> @type (:)
15:18:27 <dreams> cdsmith: hmm, I don't get how error handling is going to solve the typing mismatch?
15:18:27 <lambdabot> a -> [a] -> [a]
15:18:31 <ReinH> dwcook: the other side isn't encoded in there, it's rewritten into the normal form encoded by the data type
15:18:51 <dwcook> ReinH: What does that mean?
15:18:53 <ReinH> dwcook: think of it as taking the tree representing a free magma and rewriting it into the normal form
15:19:03 <ReinH> so ((ab)c(de)) becomes a(b(c(de)))
15:19:19 <dwcook> Hmm, okay.
15:19:26 <rwbarton> you don't actually encode the law in any real sense
15:19:28 <ReinH> and a(bc)(de) becomes a(b(c(de)))
15:19:38 <rwbarton> if that's what's confusing
15:19:39 <cdsmith> dreams: Oops, I seem to be thinking wrong today... I read Maybe and thought Either
15:19:46 <dwcook> rwbarton: I think that is what I'm getting stuck on, yeah.
15:19:50 <rwbarton> you think about the law and cook up this notion of normal forms
15:19:56 <rwbarton> then you encode those instead
15:19:56 <ReinH> Right
15:20:03 <ReinH> that's why it isn't a direct mechanical translation
15:20:07 <dwcook> Aha.
15:20:08 <ReinH> you have to do a *little* thinking
15:20:13 <cdsmith> dreams: So I meant: case hatPath of Nothing -> handleError ; Just path -> putStrLn path
15:20:28 <cdsmith> dreams: or maybe handleError putStrLn hatPath
15:20:31 <rwbarton> if I gave you some stupid made-up law like a((bb)c) = (ac)(cb) then you wouldn't know how to proceed
15:20:46 <cdsmith> dreams: Sorry about the confusion
15:21:16 <dreams> cdsmith: no worries, I will give it a try. Thanks :)
15:21:24 <ReinH> dwcook: but the law does guide you into defining this normal form. You pick one side of the equation and call it the normal form, then rewrite any other forms into it.
15:21:42 <rwbarton> now in math, you can really construct the free algebras mechanically by forming a quotient
15:21:46 <rwbarton> at least for certain values of "construct"
15:22:00 <fizruk> quotients...
15:22:12 <dwcook> fizruk: what is the last character in that message?
15:22:49 * hackagebot docopt 0.6.0.1 - A command-line interface parser that will make you smile  http://hackage.haskell.org/package/docopt-0.6.0.1 (ryanartecona)
15:22:51 <geekosaur> a typo
15:23:04 <geekosaur> (ASCII FS, a control character)
15:23:07 <fizruk> dwcook: my IRC client is weird, I typed “quotients...”
15:23:17 <dwcook> Heh. Okay.
15:23:31 <geekosaur> > ord '\FS'
15:23:33 <lambdabot>  28
15:24:14 * geekosaur 's IRC client is configured to make stray control characters (that aren't mIRC mode/color) visible
15:24:25 <fizruk> i guess I pressed Enter in the middle of converting ... to …
15:24:40 <dolio> There are constructive type theories with quotients, too.
15:24:42 <fizruk> geekosaur: what’s your client?
15:24:49 <dwcook> ReinH: okay, I want to try to tackle the free monad now. So the Pure case seems obvious, it's just return. But the other one I'm not sure about.
15:24:54 <ReinH> dwcook: so it doesn't give you a "free" construction, but it does make a lot of it mechanical at least.
15:24:54 <geekosaur> xchat2, with some custom perl hooks
15:25:10 <ReinH> dwcook: So do this: transform the elements of the structure into data constructors like we did before
15:25:21 <ReinH> data FreeMonad a = Return a | Bind ???
15:25:34 <ReinH> dwcook: then figure out how to do so in a way that the laws are enforced by construction
15:25:36 <geekosaur> (at some point I need to poke at hexchat since apparently xchat is moribund)
15:25:40 <dwcook> Could we use join instead? That might be easier.
15:25:43 <dwcook> Or maybe not.
15:25:49 <ReinH> dwcook: sure
15:26:04 <monochrom> I like moribund software. they are stable :)
15:26:11 <benzrf> bind :: m a -> (a -> m b) -> m b
15:26:31 <geekosaur> sure but that means things like RTL will never be fixed
15:26:43 <benzrf> Bind :: FreeMonad a0 -> (a0 -> FreeMonad a) -> FreeMonad a
15:26:44 <benzrf> ??
15:26:48 <geekosaur> (that particular one *is* apparently fixed in hexchat)
15:26:52 <ReinH> dwcook: If I can spoil it for you, what you end up with isn't the usual Free construction, it's the ProgramT construction from operational :)
15:26:58 <monochrom> actually, I like moribund software because they are not bloatware
15:27:03 <dwcook> ReinH: are they equivalent?
15:27:16 <ReinH> They are isomorphic I believe
15:27:40 <dwcook> So the Free from free took a little bit of extra thought to formulate, I guess?
15:27:54 <benzrf> data FreeMonad a = Return a | forall a0. Bind (FreeMonad a0) (a0 -> FreeMonad a)
15:27:58 <benzrf> ^is this correct?
15:28:10 <fizruk> benzrf: yes
15:28:14 <benzrf> sweet
15:28:33 <monochrom> every time I ditch moribund software for actively "maintained" software, I find that "maintain" means adding more features I won't use, and the ratio is I-use : I-don't-use :: 1 : 10
15:28:50 <benzrf> i really need to learn about free objects p:
15:29:06 <dwcook> monochrom: Did you get caught in the GNOME 2 to GNOME 3 upgrade? That's what made me jump ship to awesome.
15:29:20 <monochrom> I don't know. I simply use ubuntu.
15:29:51 <dwcook> benzrf: fizruk: How is that a free monad? Wouldn't a free monad have to have a type :: * -> * as the underlying type?
15:30:20 <ReinH> benzrf: it's a bit nicer with GADTs though ;)
15:30:24 <fizruk> dwcook: nice catch, thats a free monad over Identity functor
15:30:30 <benzrf> ReinH: so i'd imagine
15:31:15 <fizruk> data FreeMonad f a = Return a | forall a0. Bind (f a0) (a0 -> FreeMonad a)
15:31:23 <dolio> No, it's not a free monad.
15:31:50 <fizruk> why?
15:31:53 <dwcook> I think I'm partly confusing terminology actually.
15:32:22 <dolio> Well, presuming you use (>>=) = Bind, you can observe the binds you do.
15:32:53 <ReinH> monochrom: not moribund, top in some lattice of software changes ;)
15:33:12 <ReinH> no need to keep developing if there's nothing left to develop
15:33:50 <monochrom> yeah, it's why I refuse to respect "actively 'maintained'" as a metric of quality at all.
15:34:23 <fizruk> dolio: but changing constructor to `Bind a0 (a0 -> FreeMonad a)` makes it free monad?
15:34:31 <dwcook> My brain is tired. I'll try to derive the free monad construction again later. I appreciate your help, ReinH and the rest.
15:34:39 <dolio> Yes.
15:35:06 <fizruk> i see
15:35:12 <fizruk> thanks!
15:35:36 <RyanGlScott> I'm trying to use a blocking call from a .dll file (made with Visual Studio) in Haskell. When I run the Haskell program in cmd.exe/PowerShell, I can't issue Ctrl-C or Break to cancel it.
15:36:17 <RyanGlScott> I can use Ctrl-C properly if I run it in Cygwin, or if I run the original code in Visual Studio, so it seems to be a Haskell issue.
15:36:52 <ReinH> dwcook: yw! I hope I didn't get too much wrong ;)
15:37:35 <ReinH> monochrom: once you reach the top you can't keep climbing, you can only go back down.
15:37:51 * hackagebot shadower 0.1.0.2 - An automated way to run doctests in files that are changing  http://hackage.haskell.org/package/shadower-0.1.0.2 (karun012)
15:39:45 <fread2283> @pl p >>! act = p >> write act
15:39:45 <lambdabot> (line 1, column 12):
15:39:45 <lambdabot> unexpected " "
15:40:15 <fread2283> @pl t p act = p >> write act
15:40:15 <lambdabot> t = (. write) . (>>)
15:40:24 <Fuuzetsu> don't put that in ;)
15:55:27 <McManiaC> hey, i'm trying to install cabal-install on freebsd, and it fails with a linker error: http://npaste.de/p/BUz/
15:55:49 <McManiaC> i dont know why it even wants to use clang there, i specified CC=gcc
15:56:37 <j`ey> are you on osx McManiaC ?
15:56:43 <McManiaC> freebsd
15:56:59 <j`ey> and you have gcc?
15:57:04 <j`ey> aka gcc --version is gcc?
15:57:10 <McManiaC> 4.7.3
15:57:15 <j`ey> ok
15:57:16 <McManiaC> yes
15:57:19 <McManiaC> installed it by hand
15:57:21 <j`ey> just making sure
15:57:43 <geekosaur> freebsd 10 defaults to clang
15:58:04 <rwbarton> what does "ghc --info" say about "C compiler command"
15:58:11 <geekosaur> (which means yes, there is the potential for the same clang issues... although if you install ghc from ports, it should be forcing gcc there)
15:58:24 <McManiaC> uh, says clang rwbarton
15:58:48 <rwbarton> ok so that answers the "why is it broken"
15:59:05 <McManiaC> now how to fix :)
15:59:56 <McManiaC> do i have to reconfigure/install ghc?
16:02:19 <rwbarton> you might even have to rebuild it, not sure
16:02:30 <rwbarton> that will certainly work
16:02:54 <rwbarton> if you tell it to build with gcc
16:06:25 <McManiaC> rwbarton: i think it works
16:07:00 <halvorg> *** Error in `bin/AO2D': free(): invalid next size (fast): 0x0000000003300f50 ***, I get this error when using OpenGL bindings. Any ideas on how to diagnose?
16:07:31 <halvorg> I read that it happens when you free an already freed pointer, but I'm not doing that manually.
16:08:36 <akurilin> Is there a user friendly way of removing a certain specific package from the sandbox to have it reinstalled?
16:09:12 <geekosaur> cabal hc-pkg unregister $package ?
16:09:21 <geekosaur> (guessing)
16:10:02 <geekosaur> er, cabal sandbox hc-pkg ...
16:10:18 <akurilin> hm ok let me try, thank you
16:13:35 <akurilin> geekosaur: ok perfect that worked, thank you sir
16:14:38 <geekosaur> there may be better ways to do it; I'm still waiting for the netx platform to come out before I upgrade my poor put-upon Mac from the stone age >.>
16:16:18 <akurilin> New version of cabal just out btw?
16:16:28 <McManiaC> rwbarton: worked, thanks :)
16:37:57 * hackagebot HCodecs 0.4 - A library to read, write and manipulate MIDI, WAVE, and SoundFont2 files.  http://hackage.haskell.org/package/HCodecs-0.4 (GeorgeGiorgidze)
16:41:04 <Arnob> hey guys
16:41:15 <Arnob> question for you regarding Data Types
16:41:23 <Arnob> are type constructors also functions?
16:41:46 <dolio> Not necessarily.
16:42:12 <Arnob> sorry, I should have said Data constructors
16:42:26 <dolio> Same answer.
16:42:41 <Arnob> for example, if I have a data constructor "MyConstructor String"
16:42:54 <k00mi> Arnob: iff it takes an argument, it's a function
16:42:58 <Arnob> can I map MyConstructor to a list of strings to get a list of "MyConstructors"?
16:43:06 <shachaf> A function is a thing that has type "a -> b" for some a and b.
16:43:13 <shachaf> You can ask ghci for the type of MyConstructor.
16:43:28 <shachaf> In this case it's indeed a function.
16:43:51 <shachaf> You can also ask ghci to "map MyConstructor" and see what happens.
16:47:59 * hackagebot HCodecs 0.4.1 - A library to read, write and manipulate MIDI, WAVE, and SoundFont2 files.  http://hackage.haskell.org/package/HCodecs-0.4.1 (GeorgeGiorgidze)
16:50:01 <dwcook> Arnob: In "data Bool = False | True", neither data constructor is a function.
16:50:21 <dwcook> In "Maybe a = Nothing | Just a", one is and the other is not.
16:51:05 <dwcook> +data
16:55:30 <edwardk> dwcook: the AMP includes the Applicative/Functor default signatures IIRC
16:56:20 <benzrf> AMP?
16:56:54 <dwcook> edwardk: what are the default signatures?
16:57:18 <lennartj> do you folks know of a way to make cabal not care about ghc versions?
16:57:21 <lennartj> for instance, http://pastebin.com/hGyJz9L0
17:01:50 <Fuuzetsu> lennartj: I'd imagine ‘ghc’ version bound is set in the .cabal file
17:02:23 <Fuuzetsu> however if it's there then I imagine you'll have a very hard time trying to use GHCJS &c
17:06:13 <lennartj> hm, I don't see anything in my project's .cabal file resembling a ghc version bound
17:07:59 <Fuuzetsu> and none of the dependencies have the bound?
17:08:12 <Fuuzetsu> maybe cabal itself imposes something
17:09:24 <ReinH> dwcook: they can be considered nullary functions </pedantic>
17:09:47 <ReinH> Depending on your definition of function
17:09:59 <Fuuzetsu> oh, are we having the ‘everything is a function’ discussion again?
17:10:04 <ReinH> No one really does this though, except those few people that like to claim that "every value is a function"
17:10:36 <schell> hi all
17:10:55 <Fuuzetsu> hello
17:11:09 <dwcook> ReinH: I'd call that colloquial rather than pedantic.
17:11:18 <schell> is there anywhere else after http://hub.darcs.net/ertes/netwire to get a good tutorial/example on the latest netwire release?
17:11:21 <ReinH> dwcook: well, there's a formal way that it is true
17:12:35 <ReinH> a unary operation N -> N can be considered a function from N^1 -> N, binary N^2, ternary N^3, etc. A nullary function N^0 would be a function from 1 -> N.
17:12:37 <dwcook> ReinH: perhaps, although when discussing Haskell I'd rather limit myself to calling Haskell functions functions, unless the context were clear.
17:13:17 <Hodapp> EVERYTHING IS AN OBJECT.
17:13:21 <ReinH> dwcook: sure
17:13:21 * Hodapp shoots gun in the air
17:14:00 <dwcook> It's kind of like how I call C functions functions even though I believe it'd be more accurate to call them procedures. :)
17:14:26 <ReinH> dwcook: but it helps show the equivalence between the unit operation for a monad and the unit operation for its associated monoid ;)
17:14:45 <ReinH> both are nullary operators in that sense
17:14:51 <dwcook> By all means, continue with your mathematical analogies. :)
17:14:56 <ReinH> dwcook: :p
17:14:58 <ReinH> Ok I'm done now
17:15:32 <dwcook> Oh I didn't mean that sarcastically to shush you, I just mean I don't take issue with the analogies but rather would prefer clarification of context if we were going to use terms in a way contrary to how Haskell uses them.
17:15:46 <ReinH> dwcook: sure
17:19:21 <ReinH> dwcook: I just bring it up because algebraic structures are often defined in terms of an underlying set equipped with some (finitary) operations and, in context, Nothing is the unit operations of the (Maybe, Nothing, <>) monoid. It only makes sense as an operation if it is considered as a nullary one.
17:19:29 <enthropy> is there a way to use cabal install --allow-newer that doesn't get messed up by people that have a section for base < 0.3?
17:20:18 <enthropy> as in, --allow-newer makes cabal completely disregard upper bounds that let it pick the right value for their small_base or split_base flag
17:20:35 <bergmark> enthropy: you can pass arguments to allow-newer to only pick newers for some packages
17:21:19 <bergmark> and you can specify which flags to use with --constraint="foo +bar"
17:21:50 <enthropy> does that + syntax work in cabal files?
17:21:57 * enthropy hasn't seen that before
17:22:25 <bergmark> i'm not sure actually
17:23:20 <enthropy> johnw: "cabal install these --allow-newer=semigroups" works. I have semigroups-0.14
17:23:32 <halvorg> Anyone successfully implemented shadow mapping in OpenGL > 3.3, I've found some examples for older versions, but they aren't exactly applicable.
17:24:21 <enthropy> thanks bergmark
17:25:04 <bergmark> np!
17:29:31 <Ginto8> halvorg: does the 3.3 API support shadows? Or are you calculating the shadow volumes yourself?
17:30:12 <halvorg> I'm "rendering" depth data to a separate framebuffer
17:30:25 <Ginto8> for each light?
17:30:34 <halvorg> yes, but only 1
17:30:39 <Ginto8> ah ok
17:31:09 <halvorg> free(): invalid next size (fast): <memory address>
17:31:14 <halvorg> I get this error + a stacktrace
17:31:31 <halvorg> when calling drawElements
17:33:30 <Ginto8> can I see some code around the error? I do a lot of C work so I trace that kind of bug a lot
17:34:11 <halvorg> Yes, sec.
17:34:45 <halvorg> https://github.com/halvorgb/AO2D/blob/shadowmapping/src/Engine/Graphics/Render.hs#L228 that line(228) crashes the program.
17:35:55 <Ginto8> well I'm a little surprised it gave you a free() error instead of a segmentation fault, you're passing in a null array
17:36:15 <halvorg> the nullPtr? thats an offset
17:36:55 <Ginto8> oh woops, forgot my API there
17:37:56 <Ginto8> actually, no I don't think I did
17:38:09 <Ginto8> https://www.khronos.org/opengles/sdk/docs/man/xhtml/glDrawElements.xml
17:38:17 <Ginto8> last param is "indices", not offset
17:39:05 <Ginto8> if you have everything bound, use drawArrays instead of drawElements
17:39:46 <halvorg> If you look at line 106, i use a GLUtil function called drawIndexedTris. Defined here: http://hackage.haskell.org/package/GLUtil-0.7.4/docs/src/Graphics-GLUtil-Drawing.html#drawIndexedTris
17:40:00 <halvorg> that works. (that's the "old" code w/o shadows"
17:40:02 <halvorg> )*
17:40:33 <halvorg> (with nullPtr as offset aswell)
17:40:37 <halvorg> so I dont think that's the issue
17:43:07 <Ginto8> well I honestly have no clue how that code you just linked to doesn't crash when you give it an n other than 0
17:43:30 <Ginto8> drawArrays should fix your problem though
17:43:52 <halvorg> Same crash with drawArrays : (
17:44:16 <Ginto8> hm
17:44:34 <Ginto8> it sounds like a double-free, but since Haskell is GC'd that seems difficult to trace
17:45:14 <halvorg> yeah
17:45:41 <halvorg> munmap_chunk(): invalid_pointer pops up now and then aswell
17:46:04 <halvorg> I'm sure I did something wrong when setting up the depth framebuffer, i'll look over it again
17:55:28 <heatsink> I have a question about terminology.  Is Repa's loop fusion an instance of shortcut fusion?
17:59:49 <platz> reading Parallel and Concurrent Programming in Haskell.  Do folks actually use MVars and TVars, or do they just reach for libraries that abstract over this stuff like conduit or pipes?
18:00:28 <platz> i.e. use them as application developers, not library developers
18:04:40 <djahandarie> platz, I regularly use STM without any further abstraction on top of it.
18:04:54 <djahandarie> Non-STM concurrency stuff much less frequently.
18:04:55 <dolio> Do conduits and pipes abstract over concurrency at all?
18:05:08 <dwcook> platz: I've directly used TVars for networking code. By the way, pipes has nothing to do with MVars or TVars, although pipes-concurrency deals with STM a bit.
18:05:19 <dwcook> Can't speak for conduits, but pipes has nothing to do with concurrency at its core.
18:05:24 <platz> dolio: maybe not, but I assume some problems could be solved
18:05:55 <enthropy> I think "async" is pretty popular
18:06:21 <platz> enthropy: async is basically explained in the book ;)
18:06:38 <dwcook> Async is nice but not always called for. Though I've used race_ multiple times.
18:07:40 <platz> good stuff, enjoying it so far.  thanks for the thoughts
18:07:53 <djahandarie> Async is quite a nice interface, but I feel like it's basically part of STM (even though it isn't technically).
18:10:01 <djahandarie> In that, it has nothing to do with baking concurrency into some other application, it's still just purely an interface for doing concurrent things
18:13:17 <monochrom> my view: async : stm :: algol :: asm
18:18:57 <akurilin> Quick question: how do I pass build flags to cabal build? Trying to use an "if flag()" in my .cabal. I'm passing them right after "cabal build" and it doesn't seem to be quibte what I want.
18:19:43 <monochrom> you have to set them at "cabal configure" time
18:20:06 <monochrom> "cabal configure --help" then look for "flags"
18:21:20 <akurilin> monochrom: awesome, that helped, thank you
18:46:01 <benzrf> hey
18:46:36 <benzrf> i do not understand how (a -> b) is b^a
18:47:10 <carter> benzrf: how many function [1...n] -> [1 ... m ] are there?
18:47:17 <benzrf> oic
18:47:26 <carter> :_
18:47:26 <benzrf> derp i was thinking the wrong way >.<
18:47:27 <carter> :)
18:47:33 <carter> combinatorics is your friend
18:47:37 <benzrf> r-right
18:47:47 <carter> :P
18:47:52 <carter> it is
18:47:56 <carter> that was just combinatorics
18:47:59 <carter> the most concrete of maths
18:48:17 <benzrf> i was thinking of 'a value of type (a -> b) is b^a'
18:48:21 <benzrf> instead of 'the type itself is'
18:48:26 <benzrf> derp
18:49:07 <carter> :)
18:49:27 <enthropy> yet another reason to think we should use <- not ->
18:49:59 <carter> ?
18:52:28 <kurt21> why does this super simple function not work: http://lpaste.net/104678
18:53:02 <kurt21> According to the docs, the Num typeclass inherits Show… Yet I can’t do show n (where n is constrained to a Num type class)
18:53:07 <geekosaur> because to use "shw" you must specify in the type that it is an indstance of Show
18:53:14 <geekosaur> you have old docs, then
18:53:36 <geekosaur> the Show prerequisite for Num went away
18:53:40 <kurt21> http://www.haskell.org/hoogle/?hoogle=Num
18:53:43 <kurt21> that is outdated?
18:53:45 <benzrf> hmmm
18:53:53 <benzrf> b^a is only for total functions, yeah?
18:53:58 <haasn> kurt21: Unfortunately it seems so; click on the link
18:54:07 <haasn> Note: hoogle is based on a really old and limited database
18:54:13 <haasn> Try hayoo for a more comprehensive and updated alternative
18:54:13 <enthropy> carter: Bird & de Moor "Algebra Of Programming" uses <- and there are some arguments in there. Anyways (b <- a) has less flipping to get to (b^a)
18:54:37 <carter> b <- a rathr than a -> b?
18:54:40 <geekosaur> there is also a more up to date hoogle hosted by fpcomplete
18:54:41 <carter> ahhh
18:54:43 <enthropy> yes
18:55:29 <monochrom> I am not fond of "b^a". I don't like superscripts, they become too small for subformulas. however, I like b<-a
18:55:50 <haasn> (b <- a) seems to fit the order of (f a) more closely
18:55:52 <geekosaur> hm, also I can see another reason it might do that, just due to confusion. because the haskell98 and haskell2010 packages *do* still have that
18:55:55 <geekosaur> but base does not
18:56:11 <benzrf> 09:52 < benzrf> b^a is only for total functions, yeah?
18:56:18 <monochrom> superscripts don't scale :)
18:56:24 <geekosaur> (the next official haskell standard will probably have it removed as well)
18:56:41 <geekosaur> note that you need to specify a language level to ghc to get those packages
18:56:45 <haasn> unfortunately, f :: C <- B <- A and (f a b) do not match
18:56:51 <haasn> So that's a big downside to using <- everywhere, it seems
18:56:52 <geekosaur> -XHaskell98 or -XHaskell2010
19:03:30 <dwcook> haasn: keeping in mind (->) is right-associative while application is left-.
19:04:30 <dwcook> Actually I'm not sure it'd help to change associativity…
19:05:51 <dwcook> f :: C ? A ? B ; f a b -- Which (?) should we use and with what associativity? Looks hopeless…
19:06:07 <haasn> dwcook: In my example I took <- to be left-associative
19:06:17 <benzrf> haasn: that makes more sense to me
19:07:03 <dwcook> haasn: you know what? How about postfix application?
19:07:51 <dwcook> Actually no, that's also a no-go.
19:08:18 <dwcook> Looks like we'll have to cope with function syntax another way. :P
19:08:31 <blackdog> what's a good way to do streaming json production? I can see that Aeson can make its output be a Builder, but i don't think that helps me if i need to have the Value in memory all at once
19:09:03 <blackdog> (each element of my big json list is created by a separate IO statement, which makes it hard to just make the structure lazy (unless i'm missing something obvious))
19:11:59 <haasn> dwcook: f :: x <- (a,b,c);  f (a,b,c) -- CLEARLY
19:12:14 <dwcook> haasn: But but currying :(
19:13:17 <dwcook> blackdog: at a glance, it's not obvious to me aeson is set up to allow that
19:14:21 <enthropy> f (a,b) could stand for   \c  -> f (a,b,c)
19:14:54 <ion> haasn: g :: (a -> b) -> (a <- b)
19:15:29 <benzrf> ion: that's an impossible type
19:15:45 <dwcook> g :: (a -> b) -> b -> a
19:15:50 <ion> benzrf: Gee, really?
19:16:21 <carter> :t (undefined :: (a->b)-> b -> a)
19:16:22 <lambdabot> (a -> b) -> b -> a
19:16:26 <carter> see, you lie
19:16:28 <carter> :)
19:16:32 <enthropy> there's a <- in there
19:16:34 <carter> OR, maybe a==b
19:16:45 <blackdog> dwcook: hm. that's unfortunate.
19:16:48 <benzrf> carter: but forall a b. is implied
19:16:49 <benzrf> ;)
19:16:56 <carter> :P
19:17:05 <benzrf> @djinn (a->b)-> b -> a
19:17:05 <lambdabot> -- f cannot be realized.
19:17:08 <benzrf> fun!
19:17:22 <dwcook> blackdog: this might be crazy, but perhaps you could manually do the '[' and ',' and ']' and have each IO action contribute its own Value that will be decoded in sequence.
19:17:40 <blackdog> dwcook: oooh, elegant :)
19:18:09 <blackdog> so then i need to fiddle with scotty to get it to do the json serving manually too :/
19:18:17 <dwcook> I wouldn't call it that but it's probably not terrible :P
19:18:44 <dwcook> Also try talking to the aeson author about maybe accomodating streaming
19:19:40 <blackdog> dwcook: bos is a busy man but i guess it can't hurt to ask what the story is
19:20:37 <rwbarton> I guess the IO is really the problem
19:20:56 <rwbarton> possibly the streaming would work automagically with a lazily-generated structure
19:22:02 <benzrf> hey
19:22:14 <dwcook> Yeah but naïve solutions like mapM won't work
19:22:27 <benzrf> wait nvm
19:22:43 <rwbarton> how about the even more naive solution: unsafeInterleaveIO ;)
19:22:52 <dwcook> Oh joy
19:23:03 <benzrf> what are we tryna do
19:23:18 <haasn> ion: g :: (a -> b) <- (a <- b)
19:23:49 <carter> oh
19:23:51 <carter> that could work
19:23:56 <carter> or die horribly
19:24:41 <ion> haasn: hah
19:24:45 <ion> haasn: g'
19:26:31 <benzrf> hmm
19:26:44 <rwbarton> g' = g g
19:27:00 <haasn> g' = g
19:27:20 <benzrf> uX.typeExpr is roughly equivalent to Y \X.typeExpr right
19:27:32 <haasn> therefore g = g g
19:27:35 <haasn> I think we broke something
19:27:40 <rwbarton> there was a mathematician who wrote his diagrams without arrowheads
19:27:47 <rwbarton> just lines  A -- B
19:27:50 <haasn> and thus invented duality?
19:29:39 <ion> return :: a ─ IO a
19:30:11 <benzrf> @djinn a ─ IO a
19:30:11 <lambdabot> Cannot parse command
19:31:03 <monochrom> I guess that the mathematician is just being a newbie in tikz and don't know how to get arrowheads.
19:31:13 <rwbarton> this was on a blackboard
19:31:27 <rwbarton> I think it was to save time or something, you were just supposed to know which way the arrowheads went
19:31:39 <monochrom> oops
19:32:24 <rwbarton> Well, most of the time they go down or to the right anyways
19:32:39 <monochrom> perhaps I should omit arrowheads in my http://www.vex.net/~trebla/photo/unorganized/IO-String.png too :)
19:33:17 * hackagebot smtps-gmail 1.2.1 - Gmail SMTP Client  http://hackage.haskell.org/package/smtps-gmail-1.2.1 (EnzoHaussecker)
19:36:52 <ion> Next up: writing M and H like N to save time. You’re just supposed to know which was meant. Writing Q like O. etc.
19:37:32 <rwbarton> doctors are way ahead of you
19:38:46 <ion> We should breed doctors with mathematicians.
19:41:47 <monochrom> we already had. doctors in mathematics.
19:43:50 <carter> my ex (well not so ex ex) is a very nice doctor lady
19:45:57 <benzrf> monochrom: what the heck is this diagram
19:48:33 <enthropy> @quote "IO.*String"
19:48:33 <lambdabot> No quotes match. Sorry about this, I know it's a bit silly.
19:49:03 <enthropy> @quote IO.*String
19:49:03 <lambdabot> uninverted says: Moving from lisp to haskell with respect to functions is like moving from c to perl with respect to strings.
20:34:02 <felix89> hi!
20:34:24 <felix89> how can I run an IO () action inside the the shelly monad?
20:34:46 <felix89> http://hackage.haskell.org/package/shelly-0.9.2/docs/Shelly.html
20:35:46 <felix89> liftIO
20:40:11 <gamegoblin> > splitAt 5 [1,2,3,4,5]
20:40:12 <lambdabot>  ([1,2,3,4,5],[])
20:40:35 <gamegoblin> > splitAt 0 [1,2,3,4,5]
20:40:37 <lambdabot>  ([],[1,2,3,4,5])
20:41:13 <gamegoblin> So I have something like “foldl1 f (replicate a b)” Something feels smelly about folding over a replicated list. Is there a better way to do it?
20:42:36 <felix89> what's smelly about it?
20:43:19 <gamegoblin> I don’t know. It just seems weird to me to make a list just to immediately fold it up. And I know that’s not really what happens due to laziness, but still.
20:44:17 <gamegoblin> @pl \a b -> foldl f (replicate a b)
20:44:17 <lambdabot> (foldl f .) . replicate
20:44:35 <gamegoblin> Worth a try
20:58:12 <dwcook> felix89: were you answering your own question or did you need clarification?
20:59:47 <felix89> dwcook: thanks, i was ansering my own question
21:08:33 <felix89> how can I run a command that is not in PATH with shelly?
21:17:31 <mmachenry> Hello #haskell.
21:19:44 <jle`> hello mmachenry
21:19:57 <jle`> felix89: a command?  do you mean...execute a binary?
21:22:56 <bitemyapp> mmachenry: hi
21:28:44 <platz> any votes for these colors?  Kind of not bad for simply inverting the PDF default http://i.imgur.com/5dbT7NR.png
21:29:26 <platz> de-empahasizes operators, good or bad depending on coding style i'd think
21:35:42 <joelteon> really don't like when uninteresting text like variable names is in a non-grayscale color
21:36:30 <minikomi> Hi.. I’m pretty stuck on an exercism.io problem (robot-name). Mainly dealing with System.Random! Not sure how I should be storing a random value..
21:36:31 <gamegoblin> If I have `length “hello world”` in some code, can the compiler optimize that to the constant 11?
21:37:34 <shachaf> It can but it won't if it's GHC.
21:38:18 <shachaf> Well. That's a syntax error anyway -- you'd have to write "hello world", not “hello world”.
21:38:32 <minikomi> here’s the test which is expected to pass.. http://lpaste.net/104681 ..
21:38:44 <minikomi> not looking for a complete answer, just a nudge in the right direction!
21:39:43 <gamegoblin> shachaf: Whatever IRC client I am using did the quotes :P
21:40:01 <shachaf> A nudge in what direction?
21:40:14 <shachaf> Do you understand what you're trying to do? Where are you stuck?
21:40:20 <shachaf> I don't believe Robot is in base.
21:40:58 <platz> minikomi: You can generate a random robot name, but it will have type IO String
21:41:24 <jle`> gamegoblin: choosing what is worth it/possible to optimize is a problem that is deeper than you might think at first
21:41:36 <shachaf> Something of type IO String is not a random robot name.
21:41:41 <platz> minikomi: because the way the test is written, you need to use a mutable variable such as IORef, MVar, or TVar to store this
21:41:47 <minikomi> I guess, how to generate a new, unique name is giving me trouble.
21:41:58 <shachaf> A robot name would presumably have type String.
21:42:10 <minikomi> and then keep it.. using newStdGen in mkRobot is giving me a new name each time I try to read it
21:42:33 <gamegoblin> jle`: what complexities are there to optimizing the length of a constant list?
21:43:15 <shachaf> length is not built-in GHC magic. It's just a regular function.
21:43:43 <gamegoblin> I know, but one could imagine GHC could optimize some standard prelude functions if it wanted?
21:43:48 <ReinH> minikomi: Random seeds are designed to be deterministic. If you use the same seed, you will always get the same values.
21:44:05 <ReinH> minikomi: So rather than creating a new seed in your tests, use a pre-defined one.
21:44:05 <mzarella> class Functor f where
21:44:07 <mzarella>   fmap :: (a -> b) -> f a -> f b
21:44:14 <mzarella> Functor is exported by the Prelude, so no special imports are needed to use it.
21:44:14 <mzarella> First, the f a and f b in the type signature for fmap tell us that f isn’t just a type; it is a type constructor which takes another type as a parameter. (A more precise way to say this is that the kind of f must be * -> *.) For example, Maybe is such a type constructor: Maybe is not a type in and of itself, but requires another type as a parameter, like Maybe Integer. So it would not make sense to say instance Functor Integer, but it could make sense
21:44:32 <ReinH> minikomi: You might need to refactor your code to allow you to generate the seed separately, but this refactoring will probably improve the quality of your code anyway
21:44:32 <mzarella> I'm confused on this last part
21:44:33 <platz> ReinH: he's not building this from scratch, it has to pass an existing test suite, that relies on mutation
21:44:45 <minikomi> the robot should just hold a seeded generator, and generate the name when asked?
21:44:55 <minikomi> yes, the test suite is from the site..
21:44:58 <ReinH> platz: if the test suite is generating a random seed then it is bad
21:45:03 <shachaf> mzarella: Please link or use hpaste.org rather than pasting more than a couple of lines of tex in the channel.
21:45:10 <shachaf> Which part is confusing?
21:45:12 <ReinH> the test suite should be using a predefined seed
21:45:12 <EvanR> mzarella: the last part was cut off
21:45:43 <mzarella> isn't instance Functor Integer equivalent to `instance type type`
21:46:02 <EvanR> Integer has the wrong kind
21:46:02 <ReinH> instance Functor Integer is a kind error
21:46:03 <platz> ReinH: the way the tests are written, it forces the whole thing to be run in an IO monad
21:46:04 <mzarella> http://www.haskell.org/haskellwiki/Typeclassopedia
21:46:16 <ReinH> platz: Well that's stupid.
21:46:25 <mzarella> search for "it would not make sense to say instance Functor Integer"
21:47:06 <minikomi> I was thinking that it would make life easier if mkRobot took a StdGen or a seed at least..
21:47:18 <ReinH> minikomi: right
21:47:35 <ReinH> so you can generate a seed in main in the application but use a predefined seed in tests
21:49:09 <ReinH> mzarella: Functor is a typeclass
21:50:02 <mzarella> and Maybe is a type constructor right?
21:50:06 <ReinH> mzarella: You can only make types of kind * -> * an instance of Functor
21:50:09 <mzarella> of the Monad type class
21:50:10 <ReinH> :k Integer
21:50:11 <lambdabot> *
21:50:16 <ReinH> :k Maybe
21:50:17 <lambdabot> * -> *
21:50:24 <minikomi> hmm..
21:50:26 <ReinH> mzarella: Maybe is a type constructor of the Maybe type
21:50:50 <mmachenry> What parsing libraries do people recommend for parsing a programming in Haskell. I'm mostly used to lex/yacc style parser libraries but I know Haskell has Parsec which is very different.
21:51:24 <Polarina> mmachenry, take a look at happy and alex, those are similar to flex/bison.
21:51:43 <ReinH> mmachenry: parsec is good for parsing things generated by humans. It has better error handling. atto-parsec is good for parsing things generated by computers. It has worse error-handling but is usually faster.
21:52:04 <ReinH> Neither are lex/yacc style parser generators though
21:52:23 <EvanR> mzarella: Maybe is a type constructor, aka type with kind * -> *, it constructs Maybe foo types. Maybe is an instance of Functor and Monad and other things but i wouldnt say its a constructor of any class
21:52:24 <mmachenry> ReinH: Ah error handling is very hard to do. It's be nice to have good support for it.
21:53:51 <ReinH> mmachenry: it doesn't make sense to say that Maybe is a constructor of any type class. Type constructors construct types.
21:53:59 <ReinH> Not type classes.
21:54:22 <mmachenry> ReinH: Not sure you meant that to be directed at me.
21:54:33 <ReinH> heh sorry
21:54:36 <ReinH> mzarella: ^
21:54:44 <ReinH> mmachenry: just thought you might like to know...
21:55:06 <dwcook> The way the report uses "type constructor" it refers to things like Maybe, Int, Char, Either, and [], not just things :: * -> *.
21:55:13 <mmachenry> ReinH: :)
21:55:24 <mzarella> Thanks ReinH, EvanR
21:55:54 <EvanR> yeah constructor is weird anyway, Maybe is a type
21:55:56 <ReinH> dwcook: I'm fine with nullary type constructors, as you might expect ;)
21:56:12 <dwcook> Maybe I'd call a type, a type constructor, and a type function.
21:56:39 <dwcook> Bool is just those first two.
21:56:47 <ReinH> It's a nullary type function
21:56:49 * ReinH ducks
21:56:55 <dwcook> Maybe String is just the first one.
21:57:18 <dwcook> ReinH: Yeah yeah I've heard your opinion about that :P
21:57:18 <ReinH> It's a fully saturated type function
21:57:20 * ReinH ducks
21:57:34 <ReinH> dwcook: ok I'll stop giving you a hard time now :p
21:57:48 <ReinH> I basically agree with you
21:58:13 <dwcook> Oh I wasn't interpreting what you were saying as disagreement :P
21:58:48 <ReinH> Right.
21:59:03 <vlads> is there a possibility to perform eta reduction to get rid more than of one variable as elegantly, as from one? I' ve got
21:59:03 <vlads> g :: A -> A
21:59:03 <vlads> h :: B -> C -> D -> A
21:59:03 <vlads> and want to have `f b c d = g $ h b c d' but without need to repeat vars; lambdabot recommends something like `f = ((g .) .) . h' but that's not very elegant.
21:59:56 <ReinH> vlads: Nope.
22:00:24 <ReinH> Eta reduction is only of the form \x -> f x => f
22:02:19 <ReinH> It can be applied multiple times, so \x -> \y -> f x y => \x -> f x => f by reducing y and then x, but that doesn't help here.
22:03:01 <kazagistar> sometimes named parameters are OK...
22:03:25 <ReinH> Indeed.
22:03:37 <ReinH> Sometimes points have a point.
22:07:47 <vlads> ReinH: thanks. I agree that parameters are ok, it just seems not ok when all of them are just passed over to another function as-is
22:08:03 <minikomi> sorry, still pretty stuck…. I think I need a way to “capture” the state of a StdGen.. can’t help but feel I want to rewrite the test haha
22:08:21 <ReinH> vlads: Think of it as a price you pay for having a function with so many arguments ;)
22:09:06 <nisstyre> you could use the reader monad or implicit params
22:09:06 <ReinH> If you use those arguments together a lot you might turn them into a type of their own
22:09:52 <Nahiyan> I'm having a problem
22:10:40 <Nahiyan> I can't seem to do: map (** (1/501) triangulars
22:10:53 <Nahiyan> where triangulars = scanl1 (+) [1..]
22:11:04 <platz> minikomi: don't use a StdGen, just use randomRIO and IORef, and realize this is a a terrible way to write a haskell program
22:11:11 <Nahiyan> sorry missed a bracket here
22:11:18 <Nahiyan> but the problem still stands
22:11:37 <Nahiyan> >let triangulars = scanl1 (+) [1..]
22:11:42 <minikomi> thanks, I’ll give it a try.
22:12:05 <Nahiyan> >take 10 . map (** (1/501)) triangulars
22:12:09 <ReinH> > 1/501
22:12:11 <lambdabot>  1.996007984031936e-3
22:12:17 <Nahiyan> hmm
22:12:18 <enthropy> > let triangulars = scanl1 (+) [1..] in map (** (1/501)) triangulars
22:12:20 <lambdabot>  [1.0,1.0021952449291138,1.0035827690343415,1.0046065559362338,1.005419924758...
22:12:35 <Nahiyan> oh hmm
22:12:36 <ReinH> Nahiyan: you need a space after the >
22:12:36 <Nahiyan> :p
22:12:44 <Nahiyan> ah okay
22:12:50 <enthropy> maybe you defined triangulars in a separate module or line in ghci?
22:13:00 <Nahiyan> seperate line yes
22:13:04 <enthropy> and then the type got defaulted to [Integer]
22:13:11 <Nahiyan> :o
22:13:21 <Nahiyan> okay thank you
22:14:08 <enthropy> ghc-7.8 has -XNoMonomorphismRestriction on by default in ghci, which would also make that "problem" go away
22:14:51 <Nahiyan> I have ghc 7.6 due to me not updating my system for for a year..
22:15:47 <enthropy> @where dmr
22:15:47 <lambdabot> http://www.haskell.org/haskellwiki/Monomorphism_restriction
22:29:33 <carter> ReinH: i thought trifecta was the new parser combinator hotness
22:29:51 <ReinH> carter:  maybe it is
22:30:03 <ReinH> but there are more tutorials and such for parsec and atto-parsec :p
22:30:33 <Polarina> Clang-style colored diagnostics? Really?
22:30:44 * Polarina cabalizes trifecta.
22:31:18 <carter> ReinH: sounds like you need to wwrite one :)
22:31:27 <carter> or Polarina  does after (s)he gets it working
22:33:58 <ReinH> carter: no it does not :p
22:34:06 <carter> ReinH: yah, you be busy
22:36:14 <enthropy> it's not that much different
22:37:22 <carter> true
22:37:25 <carter> its pretty much the same
22:43:40 <ReinH> Also there's http://hackage.haskell.org/package/parsers
22:50:12 <carter> i think trifecta is one of its instances
22:54:01 <ReinH> yep
23:09:09 <Polarina> Does the act of updating data structures using the syntax "defaultWindow { windowOpenGL = True }" have a name?
23:09:47 <ReinH> record update syntax
23:10:06 <Polarina> ReinH, thanks.
23:11:07 <vlads> anybody here uses reactive-banana?
23:11:23 <jle`> vlads: just ask the question :)
23:14:31 <vlads> that's kind of a vague question... from the look of FRP I suppose, it should be possible to more or less restore state of a program from past without too much trouble. I want to implement a simple undo, but not sure if it's that easy.
23:17:01 <opqdonut> FRP frameworks try really hard to not hang on to history
23:17:07 <opqdonut> because it's usually a space leak
23:17:26 <Polarina> vlads, I'm not familiar with reactive-banana's terminology, so I'll use netwire and hope that helps. You have a Wire that you step repeatedly with some time delta. You can keep copies of some older Wires for your undo history.
23:17:38 <opqdonut> but you should be able to just hang onto a delayed copy of a signal
23:18:25 <vlads> hm, that perfectly makes sense, thank you.
23:19:00 <lennartj> I have a types/instances question: say I have `data Foo a b = FooC b`. Is it possible to define instances on Foo that are heterogenous in the `a` parameter?
23:19:18 <vlads> opqdonut: I kind of forgot about that it will become a leak when uncontrolled
23:19:19 <lennartj> for example, something to the effect of `instance Monad (forall a. Foo a)`
23:19:37 <Cale> lennartj: instance Monad (Foo a) where ...
23:20:01 <lennartj> but what if I'd like to allow binding between Foo values with different parametrizations of a?
23:20:11 <Cale> Then you define Foo with the parameters the other way around
23:20:32 <opqdonut> lennartj: also with flexible instances you can declare "instance Monad (Foo Int)" "instance Monad (Foo Char)" that are different
23:20:48 <opqdonut> (actually, it might be some other extension)
23:21:23 <opqdonut> lennartj: if you want to stay haskell2010, you need a "newtype FooChar b = FooChar (Foo Char b)" etc.
23:21:41 <Polarina> I like how GHC tells you which extension you need when you try to do something that's otherwise not allowed.
23:21:45 <Cale> lennartj: Something can only be a Functor/Monad in its last type parameter
23:21:59 <lennartj> hm, this is difficult to explain... I will type up a longer statement in a paste
23:22:45 <lennartj> Cale: I'd like the type to be monadic in the last parameter as normal, but carry around phantom type tags that influence how bind works on particular values
23:22:58 <Cale> ah, then you need a typeclass which isn't Monad
23:23:11 <Cale> Or just to define your own bind operation which isn't (>>=)
23:24:53 <lennartj> Cale: aw, darn, I was really hoping use do notation
23:26:07 <opqdonut> lennartj: you can still do it, you just can't change the tag inside one "do"
23:26:21 <Polarina> lennartj, you could use the NoImplicitPrelude extension, then the do notation will use whichever (>>=) is in scope.
23:27:10 <lennartj> opqdonut: the API I'm imagining requires binding together values with different tags
23:28:13 <lennartj> Polariny: interesting idea, but is this not considered dangerous for a library API?
23:28:38 <Polarina> lennartj, I never said it was a sane idea. :)
23:28:51 * hackagebot kmeans-par 1.5.0 - Sequential and parallel implementations of Lloyd's algorithm.  http://hackage.haskell.org/package/kmeans-par-1.5.0 (vi)
23:29:18 <opqdonut> lennartj: ok then you can't really use Monad as is
23:30:30 <jle`> Polarina: you mean RebindableSyntax, right?
23:31:06 <huza> lisp
23:31:09 <johnw> lennartj: actually, I think you can do what you are imagining
23:31:51 <opqdonut> (in case someone wants to see it, https://gist.github.com/anonymous/4947d1395b91fa35c647 is what you can do with FlexibleInstances)
23:31:53 <johnw> lennartj: Reifies (x -> m y) a => instance Monad (Foo a)
23:32:10 <johnw> this will allow you to extract your bind function based on the chosen a
23:32:13 <Polarina> jle`, that one should work as well.
23:32:53 <lennartj> @hoogle Reifies
23:32:55 <opqdonut> johnw: hoe does that work?
23:32:57 <lambdabot> No results found
23:33:17 <johnw> opqdonut: it works by stuffing a piece of data into the instance dictionary that can be retrieved within the Monad instance
23:33:49 <opqdonut> johnw: how do x, m and y get bound?
23:34:05 <johnw> by calling the function "reify"
23:34:07 <LordBrain> i'd like to see an example of htis
23:34:14 <johnw> probably the type needs to be something different than x -> m y
23:34:17 <johnw> here, let me try
23:34:20 <opqdonut> yay
23:35:01 <lennartj> johnw: this looks like dark wizardry, but I guess I expected that's what I would have needed to get into?
23:35:32 <johnw> a paper from Oleg on Implicit Configurations
23:35:43 <johnw> see http://hackage.haskell.org/package/reflection-1.4/docs/Data-Reflection.html
23:35:53 <johnw> I'll make sure this actually works for you real quick
23:36:33 <enthropy> ghc-7.6 allowed implicit params in the context
23:36:46 <johnw> yeah, this is just a better way of doing implicit params
23:36:46 <enthropy> instance (?bind :: Int) => Monad M where
23:56:03 <johnw> ok, here you go: https://gist.github.com/39d6b4cd824a4482b4dc
23:56:22 <johnw> now the phantom type selects a family of bind functions
23:58:06 <lennartj> johnw: this is so cool
23:58:53 <lennartj> thanks for taking some time to help me figure this out! I'm reading through the Implicit Configurations paper now
23:59:26 <halvorg> Using the Linear package, is htere a function V3 a -> a -> V4 a?
23:59:27 <halvorg> cant find one
