00:09:18 <skypers> hey, if I call modifyState (parsec) in a parser
00:09:25 <skypers> and call that parser with many1
00:09:36 <skypers> will it call many times the modifyState?
00:09:45 <skypers> it seems not to and that bothers me
00:13:56 <cnphil> anyone using yesod?
00:14:54 <skypers> nope, happstack
00:14:57 <cnphil> i’m new to yesod. but i find out that simply scaffolding a yesod site very frustrating.
00:15:38 <cnphil> ‘cabal sandbox init && cabal install yesod-platform’ will create a 500MB+ project
00:15:44 <shachaf> @where yesod might know more than this channel.
00:15:44 <lambdabot> #yesod - http://yesodweb.com/
00:15:51 <skypers> runParser (many1 (modifyState fcycle >> string "hi") >> getState) "salut" "" "hihihihihihihihi"
00:15:55 <skypers> Right "utsal"
00:15:56 <skypers> ok, I guess it actually does…
00:15:59 <cnphil> thanks
00:22:21 <tdammers> cnphil: yesod *is* pretty big
00:22:36 <tdammers> cnphil: if you're looking for something less massive, try happstack or scotty
00:24:43 <cnphil> i’ll try happstack :) btw i just don’t get the idea of `cabal sandbox`, which recompiles a lot packages for every project, wasting a lot of time…
00:25:01 <adas> is there some sort of cabal cheat sheet?
00:27:19 <adas> all the info about cabal is spread over 10s of places
00:32:28 <tdammers> cabal help # not working for you?
00:36:27 <sarva`> cnphil: 'cabal install' installs packages in the
00:36:28 <sarva`>               $HOME/.cabal/ directory
00:38:56 <sarva`> cnphil: Sometimes packages have conflicting dependencies which cannot be satisfied globally. 'cabal sandbox' is a solution to that. It creates a private package repository for a particular project.
00:43:35 <cnphil> sarva`: so shouldn’t sandboxes be used *only* when i can’t resolve the dependencies?
00:44:45 <sarva`> cnphil: Yes. If installing yesod-platform works without a sandbox, then you wouldn't need the sandbox.
00:45:30 <cnphil> sarva`: got it, thanks :)
00:45:39 <tdammers> sandbox is always a good idea
00:46:28 <tdammers> if you install yesod without a sandbox, and it works, great, but it could cause other package installs to break later
00:47:49 <sarva`> tdammers: You are right. But can we sandbox the packages with fewer dependencies?
00:48:46 <sarva`> tdammers: yesod has a ton of dependencies. So if I am doing a lot of throw-away yesod sites, then sandboxing each one will take a lot of time.
00:50:58 <tdammers> sarva`: yes, that's the price you're paying
00:51:08 <tdammers> AFAIK, sandboxes do not cascade
00:51:30 <tdammers> if I were to do a lot of yesod work, I'd consider creating a dedicated OS user for that :P
00:51:35 * hackagebot string-convert 1.0.0 - Provide universal string conversions between any two string-like types  http://hackage.haskell.org/package/string-convert-1.0.0 (TobiasDammers)
00:51:46 <alpounet> sarva`: you can just use the same sandbox for your yesod projects
00:51:50 <alpounet> see the --sandbox option
00:52:05 <alpounet> just create one with yesod, persistent and what not
00:52:40 <alpounet> and build all your yesod projects in that sandbox
00:52:51 <sarva`> cnphil
00:52:53 <alpounet> by using --sandbox=/path/to/sandbox
00:52:59 <tdammers> ah, right, yes
00:53:17 <sarva`> cnphil: alpounet's advice seems better than the brute force I gave earlier
00:53:48 <alpounet> oh, that was for cnphil, sorry
00:55:35 <cnphil> thanks for the advices guys :)
00:55:51 <rhaps0dy> 1`
00:55:57 <rhaps0dy> oops, sorry
01:01:36 * hackagebot string-convert 2.0.0 - Provide universal string conversions between any two string-like types  http://hackage.haskell.org/package/string-convert-2.0.0 (TobiasDammers)
01:01:38 * hackagebot crypto-random-effect 0.2.0.2 - A random effect using crypto-random  http://hackage.haskell.org/package/crypto-random-effect-0.2.0.2 (ibotty)
01:11:37 * hackagebot cprng-aes-effect 0.1.0.1 - Run random effect using cprng-aes, a crypto pseudo number generator.  http://hackage.haskell.org/package/cprng-aes-effect-0.1.0.1 (ibotty)
01:34:31 <sopvop> So, what's the difference between ExceptT and EitherT ?
01:34:41 <FrankTominc> > map(/0) [1..]
01:34:43 <lambdabot>  [Infinity,Infinity,Infinity,Infinity,Infinity,Infinity,Infinity,Infinity,Inf...
01:38:03 <bergmark_> sopvop: good question
01:40:05 <fizruk> how to make ghci expand type synonyms on :t ?
01:40:17 <sopvop> Even instances are same.
01:41:31 <fizruk>  :kind! is cool, but I have a value
01:44:39 <louisjb> hi, I'm trying leksah out and I'm finding the cursor in the editor is invisible (I'm on OSX) - is this a known issue, anyone else using it?
01:46:23 <sopvop> So, ExceptT is just a name bikeshedding. sad panda.
01:46:33 <hamishmack_> louisjb: If you have an MBP with Retina display then you may need to download a 0.13 build of leksah from http://leksah.org/packages/
01:47:09 <awestroke> how do I avoid very long string compositions (with many many ++ applications) in haskell? TF sprintf?
01:47:15 <awestroke> TH*
01:48:19 <tdammers> awestroke: there are a few ways
01:48:30 <merijn> awestroke: You mean when you have strings that span multiple lines?
01:49:05 <awestroke> merijn: no, but the definitions do, and it's hard to parse the string format with all the " ++ show x ++ "
01:49:39 <merijn> ah
01:50:18 <merijn> awestroke: Use "shows"?
01:50:26 <merijn> :t shows
01:50:28 <lambdabot> Show a => a -> ShowS
01:50:38 <merijn> "type ShowS = String -> String"
01:51:00 <louisjb> hamishmack_ ah ok thanks. I do, it's a 15 MBP retina quadcore. I'll check what version of leksah I have currently
01:51:24 <awestroke> something like       "%#{x} = alloca #{type}*"       rather than       "%" ++ show x ++ " = alloca " ++ show type ++ "*"       would be amazing
01:51:43 <louisjb> hamishmack_ yeah I'm using 0.12.0.3 - will try the update. Thank you
01:51:58 <merijn> awestroke: Well, there is printf, but it's not very typesafe
01:52:23 <merijn> awestroke: If you want anything fancier then you'll probably need to look around for more type safe printfs
01:53:24 <awestroke> merijn: Would quasiquotes be a solution?
01:53:57 <merijn> awestroke: That's similar to asking "is programming a solution?", the answer is "yes/no/maybe" :p
01:54:43 <merijn> awestroke: QuasiQuoters are just convenient ways to embed "String -> Q <type>" conversions (where <type> is one of TH types) into a piece of code
01:55:21 <merijn> So, yes, you could write a typesafe printf quasiquoter. And probably someone already has, but I don't know in which package(s)
01:56:01 <awestroke> can I define any syntax with quasiquotes? then I could turn [format| a #{x} b |] into "a " ++ x ++ " b"
01:56:16 <merijn> awestroke: Anything you can write a parser from String for, yes
01:56:25 <awestroke> cool
01:56:28 <merijn> awestroke: QuasiQuoters let you embed completely arbitrary parsers
01:57:26 <awestroke> oooh.. http://hackage.haskell.org/package/interpolatedstring-qq-0.2/docs/Text-InterpolatedString-QQ.html
02:12:26 <jrk> hi, quick question: i have two functions `foo :: ReaderT a m ()` and `bar :: ReaderT a (WriterT b m) ()`. Is it acceptable or good practice to call `runWriterT (ask >>= bar)` within foo?
02:12:43 <jrk> or should i avoid it?
02:17:24 <merijn> jrk: I think that's a type error?
02:17:55 <quchen> runWriterT isn't a readerT action, no
02:18:07 <merijn> jrk: "ask >>= bar" will have type "ReaderT a (WriterT b m) ()", so you can' runWriterT it
02:18:34 <merijn> jrk: You probably want to look at the mmorph package and it's "hoist" function
02:19:40 <merijn> jrk: Also, incidentally, neither foo nor bar are functions in your example :)
02:21:43 <jrk> ok, one moment
02:24:07 <jrk> http://lpaste.net/104347
02:24:13 <jrk> that's what i have
02:24:18 <jrk> and it type-checks for me
02:25:46 <merijn> jrk: Right, but you left out the runReaderT in your sample here :)
02:26:00 <jrk> oh, sorry!
02:26:18 <jrk> I should have used hpaste from the start
02:26:26 <jrk> my bad :/
02:27:11 <merijn> jrk: Anyway, yes, that works, whether it's appropriate depends on context
02:27:58 <jrk> merijn: how could i find out if it's appropriate?
02:28:15 <merijn> jrk: Go with whatever's most readable :p
02:28:42 <jrk> i see
02:28:46 <merijn> hoist lets you map/transform under/inside another transformer, so that could also work
02:29:17 <merijn> jrk: For example, why can bar be "WriterT [String] m", but not foo ?
02:29:22 <jrk> the alternative would be to pass through `Setup` as extra parameter `foo :: Monad m => Setup -> m ()`
02:30:01 <merijn> jrk: Well, why not "foo :: ReaderT Setup (WriterT [String] m) ()"?
02:30:28 <jrk> merijn: the reason is, that I'm using the WriterT for log messages and I want to print the log whenever my event loop finishes an iteration
02:30:46 <merijn> You could even just write "type AppConfig m = ReaderT Setup (WriterT [String] m) ()" to hide the ugly details of the signature
02:31:27 <jrk> so i figured i can cram all the stuff that's necessary to run the event loop into my Reader and execute the writer for each iteration seperately
02:33:00 <jrk> merijn: yup, the typedef is next, but for developing the model/idea I'm using more explicit types now. :)
02:36:43 * hackagebot transformers-abort 0.5 - A better error monad transformer  http://hackage.haskell.org/package/transformers-abort-0.5 (MikhailVorozhtsov)
02:36:45 * hackagebot rest-stringmap 0.2 - Maps with stringy keys that can be transcoded to JSON and XML.  http://hackage.haskell.org/package/rest-stringmap-0.2 (AdamBergmark)
02:36:47 * hackagebot rest-types 1.10.0.2 - Silk Rest Framework Types  http://hackage.haskell.org/package/rest-types-1.10.0.2 (AdamBergmark)
02:36:49 * hackagebot rest-core 0.30.0.2 - Rest API library.  http://hackage.haskell.org/package/rest-core-0.30.0.2 (AdamBergmark)
02:38:42 <merijn> jrk: Personally I prefer just writing a type alias immediately, because then you won't have to replace the type everywhere later
02:39:12 <merijn> jrk: As for having the type explicit, ghci has the ":kind!" command which will expand type aliases for you
02:40:09 <merijn> jrk: Like so: http://lpaste.net/104349
02:43:54 <jrk> merijn: ah, that `:kind!` trick is neat
02:44:14 <jrk> merijn: i hope i can remember it, thanks! :)
03:14:24 <Algebr> How can I get something to this effect?  thing <- Creator (param0 <- someNumMaker) param1 param2
03:16:05 <Algebr> aka, how can avoid having to use a separate line just to execute the param0 <- someNumMaker?
03:16:19 <sopvop> thing <- Creator <*> someNumMaker <*> pure param1 <*> pure param2
03:16:27 <sopvop> oh
03:16:33 <sopvop> thing <- Creator <$> someNumMaker <*> pure param1 <*> pure param2
03:17:38 <Algebr> :t (<*>)
03:17:40 <lambdabot> Applicative f => f (a -> b) -> f a -> f b
03:18:18 <Algebr> :t pure
03:18:19 <lambdabot> Applicative f => a -> f a
03:19:37 <Algebr> Nice, thanks!
03:21:22 <quchen> The long monadic way of doing this would be "thing <- someNumMaker >>= \param0 -> return Creator param0 param1 param2". But sopvop's Applicative version is much clearer, and knowing about Applicatives is useful in general. You can try transforming the monadic version into the applicative one as an exercise if you want.
03:22:03 <quchen> (Actually I'm not sure how easy this is to do by hand. Might take a couple of lines.)
03:23:29 <Algebr> hmm, but I still get an IO tagged object even after the <-, I remember there was somethign that could turn IO (IO Thing) into just IO Thing
03:23:34 <awestroke> anyone know an example of a functor or applicative that is not also a monad?
03:26:03 <supki> awestroke: Const e, ZipList, Validation e
03:26:47 * hackagebot regex-genex 0.6.1 - From a regex, generate all possible strings it can match  http://hackage.haskell.org/package/regex-genex-0.6.1 (AudreyTang)
03:29:31 <supki> awestroke: Map is a Functor that's not an Applicative
03:30:30 <awestroke> supki: Data.Map?
03:30:34 <supki> yes
03:33:28 <awestroke> nice one, I can see why that can't be applicative
03:42:27 <quchen> Async is also not a Monad
03:42:51 <quchen> (Or Applicative)
03:43:18 <quchen> … which means Asyncs don't combine, and you have to step out into IO do do so
03:46:45 <vise890> hi all. say i wanted to have a look at the source code for Prelude or some other module. where do i go?
03:46:58 <hpc> hackage
03:47:03 <hpc> @hackage base
03:47:03 <lambdabot> http://hackage.haskell.org/package/base
03:47:06 <alpounet> and Concurrently, which can be viewed as some kind of "helper type" to spawn several concurrent computations easily and elegantly, is an applicative
03:48:23 <vise890> hpc: thanks
03:48:53 <quchen> alpounet: Right, Concurrently is the "automatically parallal IO" type.
03:49:38 <hpc> vise890: oh, also if you don't know what module something is in, you can find it with hoogle or hayoo
03:49:41 <hpc> @where hoogle
03:49:41 <lambdabot> http://haskell.org/hoogle – See also Hayoo, which searches more packages: http://holumbus.fh-wedel.de/hayoo/hayoo.html
03:50:13 <quchen> Can ?free generate the free theorem for fmap? I can't get it to work
03:50:27 <vise890> hpc: didn't know about hayoo, will have a look
03:50:29 <vise890> cheers
03:51:10 <Kinnison> hayoo doesn't seem to support non-javascript :-(
03:51:34 <quchen> Then enable Javascript.
03:51:41 <greg`> whats the hottest thing in haskell at the moment?
03:52:11 <bergmark_> greg`: extensible effects are kewl
03:52:29 <int-e> @free fmap :: (a -> b) -> ([a] -> [b])
03:52:29 <lambdabot> g . h = k . f => $map g . fmap h = fmap k . $map f
03:52:49 <greg`> bergmark_: link please!
03:53:04 <bergmark_> @google extensible effects
03:53:05 <lambdabot> http://hackage.haskell.org/package/extensible-effects
03:53:05 <lambdabot> Title: Hackage: extensible-effects: An Alternative to Monad Transformers
03:53:15 <greg`> and i know this is an age old question but theres no difference between fmap and liftm is there?
03:53:33 <greg`> oooh an alternative to monad transformers ooooh
03:54:04 <int-e> quchen: that looks close enough to me
03:54:06 <quchen> Right now there is a difference, but it'll mostly be gone soon, rendering liftM redundant except in very rare cases.
03:55:05 <quchen> int-e: Yeah that's good enough (it also works for Maybe), but I was wondering whether I could get the actual fmap to work somehow
03:55:48 <int-e> quchen: as far as I know, no. I've never investigated what goes wrong with (a -> b) -> f a -> f b though
03:55:51 <greg`> quchen: thanks, thats cleared that up
03:56:27 <greg`> bergmark_: in your opinion is extensible effects > monad transformers?
03:56:35 <greg`> *are
03:56:36 <int-e> quchen: but I believe you would get the same free theorem, assuming 'f' is covariant (which may point to a possible cause for the failure)
03:56:54 <int-e> @free (a -> b) -> (a -> r) -> (b -> r)
03:56:54 <lambdabot> Pattern match failure in do expression at src/Lambdabot/Plugin/Haskell/Free/FreeTheorem.hs:54:21-35
03:57:16 <int-e> @free (a -> b) -> f a -> f b
03:57:16 <lambdabot> Pattern match failure in do expression at src/Lambdabot/Plugin/Haskell/Free/FreeTheorem.hs:54:21-35
03:57:45 <int-e> @free (a -> b) -> (b -> r) -> (a -> r)
03:57:45 <lambdabot> Pattern match failure in do expression at src/Lambdabot/Plugin/Haskell/Free/FreeTheorem.hs:54:21-35
03:57:49 <greg`> what are these strange runes? can we now ask lambdabot for free theorems?
03:57:50 <quchen> int-e: There's also the much more elaborate free theorem generator at http://www-ps.iai.uni-bonn.de/cgi-bin/free-theorems-webui.cgi but even using that I can't do fmap
03:58:06 <quchen> int-e: Maybe I should derive it by hand ;-)
03:58:36 <bergmark_> greg`: theoretically yes, i'm not sure how mature the implementation is though
03:58:38 <greg`> and how does the theorem prover know what you want proved?
03:59:06 <greg`> bergmark_: i need to get lambdabot working locally again
03:59:36 <bergmark_> greg`: i was referring to extensible effects, i have no clues about lambdabot :o
03:59:43 <quchen> greg`: It gives you a law based on the type of something. For example, the free theorem of "[a] -> [a]" tells you that functions of that type commute with maps.
03:59:47 <hastabukki> if i have foo:: Eq a => a -> .. foo = bar ... where bar :: a -> .. can i tell ghc that the a in bar must be the same as the a in foo so that it automatically hast the Eq constraint?
04:00:08 <quchen> ?free f :: [a] -> [a]
04:00:08 <lambdabot> $map g . f = f . $map g
04:00:28 <quchen> This means that "map g . reverse ≡ reverse . map g", for example.
04:00:40 <hpc> hastabukki: scoped type variables is what you need
04:00:59 <hpc> hastabukki: (which has the side effect of requiring you to add forall to every type)
04:01:13 <hastabukki> hpc: thank you i'll read about that
04:01:20 <hpc> is type inference not working for your definition, or is this just for readability?
04:01:49 <greg`> yes so it derives associativity(i think thats what its called?) for mapping functions
04:02:56 <quchen> No, that's something else. The above is a specialized commutativity law.
04:03:08 <hastabukki> hpc: ghc says Could not deduce (Eq a1) arising from a use of ‘lookup’     from the context (Eq a)
04:03:19 <greg`> quchen: thanks for the correction :)
04:04:14 <quchen> It's very specialized though, never assume (.) is commutative unless you know that in a certain example you can swap sides.
04:04:42 <greg`> quchen: but does that prove for all examples?
04:05:00 <hpc> hastabukki: yeah; your as are both different types, so ghc disambiguates them in the error message by changing one to a1
04:05:13 <hastabukki> hpc: by inserting Eq a => to the signatur of bar it works, so i thought i't be cool to say they have to be the smae as
04:05:25 <hpc> strictly speaking, bar :: forall a. a -> ...
04:05:47 <hpc> which is roughly "bring a type variable a into scope; bar is this type"
04:06:19 <hpc> with scoped type variables, you'll have to type that forall bit for every other type variable in your file
04:06:34 <hpc> but then when you do bar :: a -> ..., it will look for an a already in scope
04:06:41 <quchen> greg`: It proves that "(f :: [a] -> [a]) . map g = map g . f" for any f of that type, and nothing more.
04:06:41 <hpc> and see the one from foo and use that
04:06:51 * hackagebot kmeans-par 1.3.0 - Sequential and parallel implementations of Lloyd's algorithm.  http://hackage.haskell.org/package/kmeans-par-1.3.0 (vi)
04:07:26 <hastabukki> ok sounds like a nice thing to have although a bit tiresome
04:07:26 <hastabukki> thank you for explaining
04:08:47 <hpc> np; there's not really a nice way to do what you want, unfortunately
04:08:49 <greg`> quchen: thanks, thats incredibly useful to know there is a theorem prover, it will help me reason about what exactly my functions are
04:09:01 <bergmark_> on the upside you don't have to write class constraints more than once
04:10:13 <greg`> IMHO: the english language just doesnt have the flexibility to express the ideas behind the functions that we can create in a functional language, this is a problem
04:10:18 <quchen> greg`: Probably the most famous consequence of free theorems is that the second Functor law is redundant (in Haskell), https://github.com/quchen/articles/blob/master/second_functor_law.md
04:11:14 <quchen> Which luckily makes checking for valid Functor-ness a lot easier, since "id" is usually trivial to insert
04:13:06 <the_berserker> What is the prefix form of ': at the type level?
04:14:17 <greg`> quchen: thats crazy!
04:14:47 <greg`> the second functor law derived from id = fmap id
04:15:06 <greg`> its useful, it will save a lot of headscratching
04:15:26 <hpc> the_berserker: (':)?
04:15:38 <greg`> im concurrently learning scala for a new gig at the moment :-\
04:15:44 <greg`> pray for me
04:16:09 <the_berserker> hpc: It doesn't work on my GHC 7.6.3
04:16:27 <hpc> what about '(:)?
04:16:58 <the_berserker> hpc: It doesn't either
04:17:00 <Hodapp> greg`: it could be waaaaaaaaay worse.
04:18:41 <greg`> Hodapp: lol, its not too bad actually im working through the manning book , which is excellent for an newbie intermediate functional programmer
04:18:51 <hpc> the_berserker: hmm
04:19:05 <the_berserker> How to activate GHC extensions on lambdabot?
04:19:41 <hpc> you can't
04:20:02 <hpc> there's some extensions that enable unsafe code
04:20:39 <hpc> unless you mean in a local install, in which case check out... Eval.hs iirc?
04:20:44 <the_berserker> hpc: For which question? About the ': or GHC extensions on lambdabot?
04:20:56 <hpc> ghc extensions
04:21:18 <hpc> possibly about ': too, i am stumped on that
04:21:54 * hackagebot CTRex 0.5 - Open records using closed type families.  http://hackage.haskell.org/package/CTRex-0.5 (AtzeVanDerPloeg)
04:22:20 <ocharles> hey folks, having some weird multithreading behaviour... We've got some code that does: putStrLn "1" >> Async.cancel a >> putStrLn "2"
04:22:29 <ocharles> We're observing 1 being printed, but 2 never prints
04:22:50 <the_berserker> What are rank N types useful for?
04:22:52 <ocharles> Async.cancel is implemented as throwTo, and documentation there states that it blocks until the destination thread receives the exception
04:23:13 <ocharles> the only thing I can think of is that the destination thread is currently masking asynchronous exceptions, and hasn't called restore
04:23:15 <merijn> ocharles: Is your destination thread masking exceptions?
04:23:24 <hpc> the_berserker: they let you write "monomorphic polymorphic" functions, very roughly
04:23:41 <hpc> the_berserker: for instance, say you have
04:23:45 <ocharles> merijn: I can't see how, the thread in question is
04:23:47 <ocharles> https://www.irccloud.com/pastebin/vsmQptVN
04:23:54 <ocharles> But I'm trying to work out how Async.cancel could even block
04:23:57 <ocharles> I think masking is the only reason
04:23:59 <hpc> data Rounded = Rounded Double Int -- some hypothetical data type
04:24:17 <hpc> and you want to apply a piece of math to both the Double and the Int
04:24:37 <hpc> both of them are Num, but they aren't the same, so you need to take a polymorphic function to have it work on both
04:24:59 <hpc> but if you use plain old polymorphism like you are used to, it can accept stuff like (Int -> Int) which is wrong
04:25:02 <hpc> so you do
04:25:08 <merijn> ocharles: I'm not sure what happens to exceptions while blocked in an STM transaction
04:25:12 <hpc> apply :: (Num a => a -> a) -> Rounded -> Rounded
04:25:15 <the_berserker> Have you ever encountered a real life situation in which you have to use RNTs?
04:25:24 <hpc> apply f (Rounded d i) = Rounded (f d) (f i)
04:25:32 <merijn> the_berserker: Yes, regularly and now that I know them I keep using them more
04:25:46 <hpc> er, pretend i remembered to add a forall inside the parens
04:25:50 <ocharles> the_berserker: the ST monad is a classic example of higher-rank types being useful
04:28:57 <ocharles> merijn: I should note that I'm running this in GHCI, so maybe it's GHCI being weird
04:30:36 <sruz25> how does one choose an instance for `show' when it's in the middle of line?
04:31:10 <sruz25> or anything else for that matter, because this thing is ****** me off all the time
04:31:36 <sruz25> *or FOR anything else
04:32:02 <int-e> > (show :: Int -> String) . read $ "42"
04:32:03 <lambdabot>  "42"
04:32:17 <int-e> not very pretty
04:32:40 <sruz25> thanks
04:35:05 <ocharles> Also, `asTypeOf` can be useful
04:35:09 <ocharles> :t asTypeOf
04:35:10 <lambdabot> a -> a -> a
04:35:33 <ocharles> show . (`asTypeOf` (0 :: Int)) . read $ "42"
04:35:37 <ocharles> > show . (`asTypeOf` (0 :: Int)) . read $ "42"
04:35:38 <lambdabot>  "42"
04:35:55 <ocharles> That can be handy if you have a term of the right type lying around
04:37:08 <int-e> @let type Id a = a -> a
04:37:10 <lambdabot>  Defined.
04:37:21 <int-e> > show . (id :: Id Int) . read $ "42"
04:37:23 <lambdabot>  "42"
04:38:21 <int-e> and then there's
04:39:00 <int-e> (\x -> x :: Int), and so on
04:39:26 <int-e> @src Endo
04:39:26 <lambdabot> Source not found. Wrong!  You cheating scum!
04:39:56 <sruz25> hmm, might be handy too
04:45:42 <kqr> sruz25, the general idea is that you want to force the instance at some point. it doesn't matter very much where
04:46:08 <Aetherspawn> so, for the cont monad
04:46:12 <Aetherspawn> when you see it in do-notation form
04:46:27 <ocharles> Hopefully we will one day get Lennart's "partial type signatures" to help with this
04:46:34 <Aetherspawn> can you kind of imagine cont as meaning "all the remaining code fed as a continuation into this lambda"
04:46:55 <Aetherspawn> I find understanding cont kind of hard.
04:47:13 <merijn> Aetherspawn: I think the only way to understand it is "implement it"
04:47:29 <merijn> Aetherspawn: Although, having said that, I implemented it and still don't intuitively understand it :p
04:49:05 <Aetherspawn> its pretty awesome
04:49:23 <Aetherspawn> I want to be able to turn things into cont just because its confusing
05:06:57 * hackagebot quickcheck-regex 0.0.1 - QuickCheck instances for arbitrary regular expressions and regex-conforming strings  http://hackage.haskell.org/package/quickcheck-regex-0.0.1 (AudreyTang)
05:06:59 * hackagebot quickcheck-regex 0.0.2 - Generate regex-constrained strings for QuickCheck  http://hackage.haskell.org/package/quickcheck-regex-0.0.2 (AudreyTang)
05:31:53 <exfalso> hi, does anyone know what it means when cabal gives "cabal: Could not resolve dependencies:" but does not list any unresolved dependencies?
05:35:16 <sruz25> how do I change isEOF -> bool so that it returns the opposite value? I tried changing it on different levels but I'm constantly getting some errors
05:35:42 <sruz25> *isEOF -> IO bool I meant
05:36:08 <nclarke_> (not . isEOF)?
05:36:29 <nclarke_> Ah
05:37:07 <nclarke_> isEOF >>= liftM not
05:37:15 <Cale> fmap not isEOF
05:37:16 <augur> :t isEOF
05:37:19 <lambdabot> Not in scope: ‘isEOF’
05:37:24 <tdammers> not <$> isEOF
05:37:30 <augur> what is the type of isEOF
05:37:38 <Cale> I was assuming IO Bool
05:37:46 <tdammers> do { eof <- isEOF; return . not $ eof }
05:37:48 <tdammers> :P
05:37:49 <augur> perhaps we should find out first!
05:37:57 <augur> @hoogle isEOF
05:38:00 <lambdabot> System.IO isEOF :: IO Bool
05:38:00 <lambdabot> GHC.IO.Handle.FD isEOF :: IO Bool
05:38:00 <lambdabot> System.IO.Error isEOFError :: IOError -> Bool
05:38:26 <augur> there we go
05:38:46 <sruz25> tdammers: that's looks like what I'm looking for
05:39:05 <augur> sruz25: Cale's and tdammers's answers are the same, but with different notation
05:39:08 <augur> (<$>) = fmap
05:40:09 <sruz25> oh,I meant the latter answer
05:40:23 <augur> oh, the longer one?
05:40:31 <augur> thats just the same thing but verbosely
05:40:50 <tdammers> also, usually (<$>) = liftM = liftA
05:40:52 <augur> do { x <- mx ; return (f x) }   ==   fmap f mx
05:41:02 <augur> @src (<$>)
05:41:02 <lambdabot> f <$> a = fmap f a
05:41:06 <tdammers> the do notation thing boils down to the same
05:41:08 <sruz25> that's why I was able to see that it's what I'm looking for. I'm fairly new to Haskell
05:41:14 <tdammers> it desugars into the >>= version
05:41:24 <augur> sruz25: well then, what are you doing trying these fancy things?
05:41:47 <augur> tdammers: it better be that (<$>) = liftM = liftA, since these are all = fmap!
05:42:01 <sruz25> loading something from stdin to mutable array
05:42:07 <tdammers> augur: yes, but those definitions aren't in prelude
05:42:17 <tdammers> augur: so it depends what you have imported
05:42:27 <augur> sruz25: sounds like an awfully painful thing to do right now
05:42:41 <augur> tdammers: i import applicative just to get <$> all the time :x
05:42:50 <augur> i prefer <$> to fmap
05:43:47 <sruz25> well, I most pain is caused by the fact that I do not understand Haskell as I'd like atm
05:44:26 <augur> sruz25: it sounds like youre jumping into the deep end
05:44:37 <tdammers> augur: same here
05:44:44 <sruz25> kind of
05:44:47 <tdammers> foo <$> bar <*> baz
05:44:49 <tdammers> common idiom
05:44:51 <tdammers> love it
05:45:17 <augur> sruz25: try the shallow end first
05:45:29 <augur> sruz25: you dont want to get discouraged!
05:46:38 <benj_> jumping into the shallow end can be painful, too
05:46:46 <tdammers> even the shallow end is fairly deep
05:46:55 <augur> well yes, you shouldnt jump into the shallow end of the pool
05:47:06 <augur> you should take the steps
05:47:43 <augur> you know, i havent been in a pool in ages
05:47:45 <Yuu_chan> What's the easiest way to parse datetime in predefined format? I tried to install `timeparsers', but it is a little outdated and causes dependencies troubles.
05:48:07 <tdammers> Yuu_chan: honestly, I found rolling my own parser the easiest in the end
05:48:20 <benj_> o_O
05:48:41 <Yuu_chan> Ouch...
05:49:07 <benj_> datetime libraries seems to be the elephant in the room with Haskell
05:49:08 <sruz25> it's required lecture at uni, and yeah, I've been hearing legends, that if you get deep enough you discover the true magic of Haskell and you'll see why it's useful. I'm not sure if I have the time and patience for that
05:50:20 <tdammers> seriously, if all you need is one particular format, you can whip up a working parser in 10 minutes or so
05:50:50 <Aetherspawn> > liftA Just 3
05:50:50 <Yuu_chan> tdammers: I'll try, thanks
05:50:51 <lambdabot>  No instance for (GHC.Show.Show (f0 (Data.Maybe.Maybe a0)))
05:50:51 <lambdabot>    arising from a use of ‘M172230462921560763010225.show_M1722304629215607630...
05:50:51 <lambdabot>  The type variables ‘a0’, ‘f0’ are ambiguous
05:50:51 <lambdabot>  Note: there are several potential instances:
05:50:51 <lambdabot>    instance [safe] GHC.Show.Show a =>
05:50:56 <Aetherspawn> > liftA 3 Just
05:50:57 <lambdabot>  No instance for (Data.Typeable.Internal.Typeable a0)
05:50:58 <lambdabot>    arising from a use of ‘M172358292214260841110242.show_M1723582922142608411...
05:50:58 <lambdabot>  The type variable ‘a0’ is ambiguous
05:50:59 <lambdabot>  Note: there are several potential instances:
05:51:00 <Aetherspawn> lies.
05:51:01 <lambdabot>    instance Data.Typeable.Internal.Typeable Data.Dynamic.Dynamic
05:51:43 <Aetherspawn> goodnight lambdacolytes.
05:54:31 <benj_> is it not recommended to use DateTIme.parseTime ? It UTCTime much use?
05:57:01 * hackagebot learn-physics 0.4 - Haskell code for learning physics  http://hackage.haskell.org/package/learn-physics-0.4 (ScottWalck)
05:57:13 <Yuu_chan> Picoseconds o_O
06:00:20 <Yuu_chan> Yay!
06:00:20 <Yuu_chan> ghci> (read "2012-12-04 04:12:59") :: UTCTime
06:00:20 <Yuu_chan> 2012-12-04 04:12:59 UTC
06:02:58 <alpounet> Yuu_chan: parseTime works on several date/time types
06:03:38 <alpounet> e.g you can use it to parse a ZonedTime, which is time+date+timezone, which happens to be what we want, quite often
06:04:09 <Yuu_chan> alpounet: I saw that, but it requires TimeZone, format string and so on, and I currently don't want to deal with them
06:04:45 <alpounet> Yuu_chan: if you're just toying around, UTCTime will do then
06:05:07 <Yuu_chan> Er, seems I'll have to. My actual format has dots instead of hyphens -_-
06:06:34 <benj_> this looks like a handy guide: http://tab.snarc.org/posts/haskell/2011-12-16-date-in-haskell.html
06:09:14 <alpounet> benj_: well, he wrote a date/time library recently: http://tab.snarc.org/posts/haskell/2014-05-04-hourglass-simpler-time.html
06:11:56 <Yuu_chan> alpounet: looks really nice, thank you!
06:14:58 <Achylles> I know that it is a haskell channel, but I have tried to convert an epub book to a txt one with pandoc and I have searced the net, including pandoc website and have not get the help I want, because of an unicode error that I can't solve so far    "pandoc -o file.pdf file.epub > pandoc: Cannot decode byte '\x89': Data.Text.Encoding.Fusion.streamUtf8: Invalid UTF-8 stream > the same happens when trying to convert from "pdf" to "txt"   :(
06:17:15 <geekosaur> Achylles, the error means what it says. the book's encoding is probably an iso 8859 instead of utf-8
06:18:24 <Achylles> I mean "pandoc -o file.txt file.epub"
06:18:31 <geekosaur> but I don't know how you would convince pandoc to process it as such
06:19:07 <Achylles> geekosaur, this is the real problem
06:19:17 <nclarke_> Pandoc uses the UTF-8 character encoding for both input and output. If your local character encoding is not UTF-8, you should pipe input and output through iconv:
06:19:17 <nclarke_> iconv -t utf-8 input.txt | pandoc | iconv -f utf-8
06:19:25 <nclarke_> According to the pandoc user manual
06:19:29 <geekosaur> right, iconv not so helpful on a pdf
06:19:37 <nclarke_> Fair point
06:19:53 <geekosaur> or an epub, although it's possible to do it with some care
06:20:50 <geekosaur> (basically you need to unpack it --- it's a zip file --- and run iconv only on the textual content, then zip it back up. but it needs to be re-zipped in a particular order to be a valid epub. maybe try using calibre to convert it instead?)
06:21:52 <Achylles> nclarke_, but. the problem is the file.epub and not file.txt > should I do it? "iconv utf-8 input.epub| pandoc | ivonv -f utf-8  ?
06:22:13 <geekosaur> iconv won't work on an epub directly, as I just said
06:22:16 <nclarke_> Achylles: No, as geekosaur says, it's somewhat more complex
06:22:18 <geekosaur> it's a zip file
06:22:31 <geekosaur> just running iconv will destroy it as iconv only knows text
06:23:01 <sruz25> I have weird problem: "a <- readArray arr (0,1) ..newline.. (\(x,y) -> ..conversion to [Char]..) a" works, but when I try to omit the middle step, the readArray suddenly starts having problems with types
06:23:31 <Achylles> So, there is other tool to convert from epub to txt? In debian repos for example?
06:24:22 <Cale> sruz25: You mean if you use (x,y) <- readArray arr (0,1) ?
06:25:04 <sruz25> I'm using it as argument (\(x,y) -> ...) $ readArray...
06:25:15 <Cale> Well, readArray ... isn't a pair
06:25:26 <geekosaur> I think you could also use calibre to do an epub-to-epub conversion which should convert it to utf8, then pandoc that --- calibre's conversion to text is somewhat improved in recent releases but I can see why someone might prefer to use a different tool
06:25:27 <Cale> It's an IO action which might produce a pair if executed
06:26:01 <Cale> You can use fmap perhaps
06:26:04 <sruz25> oh, so unsafeWhatsitcalledIO should do?
06:26:11 <Cale> fmap (\(x,y) -> ...) (readArray ...)
06:26:29 <Cale> sruz25: no, that's never the right solution unless your first name is Simon
06:27:48 <sruz25> did I forgot to wipe that from settings again?
06:28:13 <Cale> hm? :)
06:30:17 <augur> Cale: lets be honest, even if your name is Simon you still shouldnt use unsafePerformIO
06:30:42 <Cale> That's mostly true as well :)
06:30:47 <augur> i say just ban the whole thing!
06:30:59 <augur> and eliminate partiality too
06:31:10 <augur> keep haskell pure!
06:31:41 <Cale> Well, to be honest, you *can* implement pure interfaces using unsafePerformIO if you know what you're doing and you understand what the compiler is going to do with things
06:31:45 <int-e> augur: Well, that's fine unless you ever want to run your code.
06:31:57 <augur> int-e: poppycock
06:32:00 <sruz25> now seriously, did XChat fuck up, or did you bother to google my nick?
06:32:03 <int-e> augur: I know, right?
06:32:14 <augur> sruz25: is your name actually Simon?
06:32:24 <augur> sruz25: it was a joke about two bigwig haskellers being named Simon
06:32:25 <sruz25> yup
06:32:27 <Cale> sruz25: I'm referring to Simon Marlow and Simon Peyton Jones
06:32:33 <Cale> haha
06:32:47 <augur> int-e: its totally poppycock. purity and execution are not incompatible
06:33:00 <Cale> augur: Look at Data.ByteString for example though
06:33:01 <augur> Cale: looks like unsafePerformIO might be the right solution after all :(
06:33:11 <merijn> sruz25: Clearly you're only solution now is to become a famous haskell hacker to live up to the Simon name ;)
06:33:16 <augur> Cale: i wonder what the chances were that he'd be named Simon
06:33:18 <augur> what irony
06:33:32 <Cale> unsafePerformIO can be really useful for those cases where you'd otherwise have to modify the compiler to add new primitives
06:33:33 <sruz25> what I need it for is to print whole 2d array of (Double,Double)
06:33:46 <Cale> But it should be treated with the same sort of gravity
06:34:13 <alpounet> sruz25: that should happen in IO anyway
06:34:29 <augur> Cale: what sort of new primitives?
06:34:32 <sruz25> and it's taking me quite long time, considering it's only for testing purposes
06:34:39 <Cale> augur: ByteString?
06:35:08 <augur> Cale: how does it let you treat ByteString like a new primitive?
06:35:43 <Cale> augur: Look at how ByteString is implemented. Lots of IO goes on under the covers when you use pure functions on ByteStrings
06:35:55 <augur> interesting
06:36:00 <merijn> augur: He means "abusing IO in ways that are safe, but not provably so to improve performance"
06:36:36 <Cale> do bs <- getBounds arr; forM (range bs) $ \i -> do v <- readArray arr i; print (i, v)
06:36:37 <int-e> augur: It's just that you have to implement almost all of ghc's runtime system (because of the way it interfaces with the libraries)
06:36:42 <Cale> sruz25: ^^ maybe something like that?
06:36:50 <augur> maybe haskell needs a nice little type for circumscribing things like this in a safe way
06:37:10 <merijn> augur: Sufficiently expressible types for that are an open problem
06:37:41 <sruz25> hmm, if you say so, it will take me a bit to read what it does
06:37:42 <merijn> augur: For example, should linking to C math functions require you to be in IO? Even if you know (but can't prove) they're pure
06:38:20 <augur> i'd say dont link to C math functions :P
06:38:44 <Cale> actually, that should be forM_
06:38:55 <Cale> (but it doesn't really matter very much)
06:39:17 <Cale> sruz25: It gets the bounds of the array, bs, which is a pair consisting of the lower and upper bound. It then loops over the list (range bs), which is a list of all the array indices
06:39:38 <Cale> and for each index i, it reads the array at position i, getting some result v, and then prints the pair (i,v)
06:40:42 <sruz25> that's far nicer and shorter that what I was plotting
06:40:46 <Cale> We could instead construct a function which builds a string consisting of all the array elements if you'd like
06:40:48 <sruz25> *than
06:41:31 <sruz25> it's "just" for testing purposes, this should do
06:42:01 <Cale> Oh, right, there's also getAssocs
06:42:24 <Cale> assocs <- getAssocs arr; mapM_ print assocs
06:42:27 <Cale> does the same thing
06:43:56 <Achylles> geekosaur, nclarke_   I have unziped the file and the book chapters are already divided in ".html" files and it is possible to covert them to txt using pandoc now  :)
06:44:49 <geekosaur> ah, goodm a sensible epub :)
06:45:07 <Ankhers> is `f . g` the same as `g >>> f`?
06:46:06 <quchen> Ankhers: When f and g are ordinary functions, then yes.
06:46:17 <Achylles> geekosaur, can I do the same with  a pdf? Is it a zipped file as well?
06:46:20 <quchen> In general, g >>> f is left-to-right arrow composition.
06:46:36 <geekosaur> they are often compressed, but they are not normal text, no
06:46:58 <Ankhers> quchen: Can you explain what you mean by "ordinary functions"?
06:47:05 <Cale> :t (>>>)
06:47:06 <geekosaur> pdf is a relative of postscript, the text strings are enclosed in parentheses and surrounded by pdf commands
06:47:07 <lambdabot> Category cat => cat a b -> cat b c -> cat a c
06:47:20 <Cale> Ankhers: It needn't be the case that cat = (->)
06:47:22 <geekosaur> and may have encoded binary content for images etc.
06:47:24 <quchen> Ankhers: Of type "a -> b", as opposed to "a -> m b" for example, which would be a Kleisli arrow, not an "ordinary function/(->) arrow".
06:48:51 <quchen> :t \f g -> (Kleisli f) >>> (Kleisli g) -- This would be an example use of >>> that doesn't involve (->) directly.
06:48:52 <lambdabot> Monad m => (a -> m b) -> (b -> m c) -> Kleisli m a c
06:48:52 <geekosaur> also I must note that PDF is a *terrible* input format, since it is essentially postscript (that is, printable / renderable output) without semantic content.
06:49:02 <geekosaur> any conversion involves a lot of guessing
06:50:20 <Cale> Yeah, there's no guarantee even that a PDF won't just represent all the letters as curves in such a way that you'd have to do something similar to OCR to recover the original text.
06:50:29 <Cale> Indeed, it might just consist of images of the pages.
06:50:42 <geekosaur> all too many PDFs are just png (or worse, tiff) bitmaps of pages
06:50:43 <geekosaur> yeh
06:50:44 <vanila> PDF is so bad
06:50:53 <Cale> I don't mind PDF for what it is
06:51:03 <dyu> complete newbie here. how do i do a mod in side a filter? fizzBuzz l = filter (mod 3 == 0) [1..100]  <-- this gives me: Couldn't match expected type `a0 -> Bool' with actual type `Bool'
06:51:04 <geekosaur> it's a fine final output format
06:51:06 <vanila> the page numbering though
06:51:10 <Hodapp> PDF can compress raster images reasonably well
06:51:14 <Hodapp> but it's rare for me to see this
06:51:15 <geekosaur> just don't expect to be able to convert it to anything else
06:51:40 <Cale> filter (\x -> x `mod` 3 == 0)
06:51:57 <Cale> > filter (\x -> x `mod` 3 == 0) [1..100]
06:51:59 <lambdabot>  [3,6,9,12,15,18,21,24,27,30,33,36,39,42,45,48,51,54,57,60,63,66,69,72,75,78,...
06:52:00 <Ankhers> quchen: Thanks.
06:53:01 <Cale> > [x | x <- [1..100], x `mod` 3 == 0]
06:53:02 <lambdabot>  [3,6,9,12,15,18,21,24,27,30,33,36,39,42,45,48,51,54,57,60,63,66,69,72,75,78,...
06:53:09 <dyu> what's the \x -> x part called?
06:53:15 <Cale> That's not a part
06:53:23 <Cale> \x -> (x `mod` 3 == 0)
06:53:37 <Cale> It's a lambda
06:53:43 <Cale> \ is ascii art for λ
06:54:01 <dyu> ahh. i understand lambda. thanks Cale
06:54:33 <dyu> i've read through some chapters of learn you a haskell and thought it's about time i try it
06:54:57 <Cale> Yeah, it definitely helps to play around in ghci as you go :)
06:55:28 <dyu> i like it(haskell and functional programming) but it hurts my brain and messes with my perception of reality
06:55:43 <saep> dyu: I thought that's the fun part.
06:55:59 <dyu> >___<
06:57:39 <albeit> If I have a module A that has a data Foo = Bar Baz, is there any way for a module that doesn't import A to match a Foo by something like _ Baz (any data constructor that takes a Baz as the first argument)?
06:57:46 <trampi> Dyu: I have the urge to tell this my lecturer. I am sitting in a Haskell lecture right now ;-)
06:58:05 <Gurkenglas> "mod 3 == 0" didnt work cause it wasnt a proper function with one variable. ( ((==0).(mod 3)) ("Concatenate the functions (mod 3) and (==0) by putting one's output into the other") is a representation of that function that I like more. )
06:59:11 <Gurkenglas> Oops, of course I mean ('mod' 3) there.
06:59:16 <Gurkenglas> (Lets make sure)
06:59:23 <merijn> Gurkenglas: Those are the wrong ticks
06:59:27 <Gurkenglas> :t (==0).('mod' 3)
06:59:28 <lambdabot>     Syntax error on 'mod'
06:59:28 <lambdabot>     Perhaps you intended to use TemplateHaskell
06:59:28 <lambdabot>     In the Template Haskell quotation 'mod'
06:59:48 <merijn> :t (==0).(`mod`3)
06:59:48 <lambdabot> Integral b => b -> Bool
07:00:06 <Gurkenglas> So that's why that didn't work the last time I tried that
07:01:18 <merijn> You need backticks instead of apostrophe
07:01:29 <Gurkenglas> Ya i saw
07:04:54 <albeit> In a do block, if I'm doing something like, "Foo num val; Bar num val; Baz num val", is there a clean way to apply "num val" to all three functions at once?
07:05:23 <albeit> Where order isn't important
07:06:15 <vanila> map (\c -> c num val) [Foo, Bar, Baz]
07:06:45 <vanila> mapM_
07:07:33 <albeit> vanila: Thanks
07:08:02 <dyu> if i wanted to use a where with filter, is it possible?
07:08:08 <vermeille> Hi, I'm looking for a very simple http framework just to have a web interface for my console apps. One to advise?
07:08:29 <alpounet> vermeille: "simple" and "scotty"
07:09:08 <dyu> woohoo. it works
07:11:08 <vise890> hi all. is there a way to see the implementation of a type class in ghci?
07:11:45 <vermeille> alpounet: thx! Scotty seems to be what I'm looking for!
07:37:12 <Sculptor> hi
07:37:14 * hackagebot http-test 0.2.0.1 - Test framework for HTTP APIs  http://hackage.haskell.org/package/http-test-0.2.0.1 (glutamate)
07:44:36 <yac> why is haskell using camel case to name things?
07:44:56 <tdammers> yac: idk, Microsoft heritage?
07:45:05 <tdammers> yac: it's pretty much an arbitrary choice
07:45:16 <yac> it's the one thing that annoys me there
07:45:34 <yac> it's harder to read
07:45:35 <tdammers> and frankly, while I prefer underscores in general, ALL_CAPS_WITH_UNDERSCORES is silly
07:45:48 <yac> wat
07:45:53 <yac> why all caps
07:46:00 <yac> nice strawman
07:46:06 <tdammers> not quite
07:46:23 <yac> put_str_ln
07:46:51 <tdammers> Haskell uses first-letter-case to distinguish type variables from types and functions/constants/methods from constructors
07:47:01 <tdammers> Maybe and maybe are two different things
07:47:05 <vanila> "nice strawman" really?
07:47:10 <yac> right
07:47:13 <tdammers> without camel-case, we'd be using MAYBE and maybe instead
07:47:26 <yac> still that doesn't conflict with underscores
07:47:32 <tdammers> not in this case
07:47:34 <yac> no, I have no problem with the firs letter
07:47:47 <yac> but things like lookupValue rather than lookup_value
07:48:08 <yac> vanila: ya rly
07:48:35 <vanila> it's almost like you only came to cause arguments
07:49:04 <yac> vanila: it's almost like you haven't presented even one yet
07:49:48 <sruz25> How do I load a value from isEOF in 'do' statement? d <- isEOF throws errors and let d = .... doesn't actually execute isEOF
07:50:48 <tdammers> yac: but what would you propose for names with an uppercase first letter then? Monad_plus?
07:50:54 <tdammers> MONAD_PLUS?
07:51:02 <tdammers> _monad_plus?
07:51:08 <tdammers> none of those looks pleasant
07:51:19 <davd> sruz25: do \n stop <- isEOF \n when stop (putStrLn "wohoo!")
07:51:33 <yac> tdammers: Monad_Plus looks less evil
07:52:08 <tdammers> does it?
07:52:12 <tdammers> maybe it does
07:52:20 <yac> tdammers: I also wouldn't mind keeping camelCase for types but underscores for functions
07:52:28 <tdammers> ugh
07:52:30 <tdammers> but anyway
07:52:45 <tdammers> matter of taste, highly debatable, unlikely to ever lead to a decisive consensus
07:52:50 <tdammers> thus, pointless
07:52:55 <yac> still, I wonder what is the real reason people had back then
07:53:01 <davd> sruz25: you need to be in an IO-block. for example main = do _ <- isEOF
07:53:09 <tdammers> they had to pick something. They picked something that made some sense.
07:53:15 <tdammers> that's pretty much all there is to it, I think
07:53:42 <monochrom> sruz25: read my http://www.vex.net/~trebla/haskell/IO.xhtml . close IRC and start reading immediately.
07:53:42 <sruz25> I have do ...doing something...\n l <- getLine \n d <- isEOF \n .....
07:53:49 <yac> tdammers: I don't think the fact that underscores are more readable then camelCase is debatable :)
07:54:03 <nclarke_> yac: I find camelCase more readable
07:54:17 <yac> stockholme syndrome?
07:54:31 <davd> sruz25: that should work.
07:54:35 <yac> oh well, nevermind.
07:54:37 <nclarke_> Also, fewer characters is a plus
07:55:01 <yac> nclarke_: write once, read many times argument beats that
07:55:22 <tdammers> yac: lowercase_with_underscores is more readable, but UPPERCASE_WITH_UNDERSCORES is worse, IIRC
07:55:40 <nclarke_> Yes, and I find it much easier to read shorter names
07:55:47 <exicer> I need a hash function, something like md5. Is there a preferred one to use ?
07:55:50 <tdammers> underscores add visual word separation, but all-caps removes any and all shape
07:55:50 <awestroke> why do I get "line-map.c: file "<command-line>" left but not entered" when I compile with ghc?
07:55:51 <yac> tdammers: what's up with you and ALL_CAPS ? :)
07:56:08 <tdammers> I like consistency
07:56:16 <tdammers> Monad_Plus doesn't seem consistent to me
07:56:35 <tdammers> if I have Foo_Bar, and a corresponding function
07:56:42 <tdammers> should that function be foo_bar, or foo_Bar?
07:57:02 <tdammers> anyhow, the choice has been made, better howl with the pack
07:57:09 <davd> sruz25: http://lpaste.net/104356 working example
07:57:15 * hackagebot http-test 0.2.0.2 - Test framework for HTTP APIs  http://hackage.haskell.org/package/http-test-0.2.0.2 (glutamate)
07:57:17 <yac> nclarke_: www.cs.kent.edu/~jmaletic/papers/ICPC2010-CamelCaseUnderScoreClouds.pdf
07:57:17 * hackagebot http-test 0.2.0.3 - Test framework for HTTP APIs  http://hackage.haskell.org/package/http-test-0.2.0.3 (glutamate)
07:57:25 <yac> science!
07:57:54 <yac> "While results indicate no difference in accuracy between the two styles, subjects recognize identifiers in the udnerscore style more quickly."
07:58:13 <monochrom> heh
07:58:16 <sruz25> The thing is, it does work in main, but not in functions...
07:58:40 <monochrom> well, I like spacing out. the underscore helps. ideally, I would use spaces, real spaces.
07:58:47 <nclarke_> One main difference is that subjects were trained
07:58:48 <nclarke_> mainly in the underscore style
07:59:03 <monochrom> sruz25, then you need to post verbatim unabridged actual code.
07:59:12 <davd> sruz25: your functions need to have type "something ... -> IO ret", where ret is something concrete, like an Int.
07:59:16 <nclarke_> Ah, sorry, that was talking about the other study
07:59:22 <vanila> monochrom that's radical...
07:59:38 <awestroke> how do I "Combine with" other lines in my code as hlint tells me to for "Reduce duplication" messages
08:00:59 <awestroke> (especially when it tells me to do this for lets and binds)
08:01:26 <sruz25> oh, yeah, that's it
08:01:36 <yac> nclarke_: "The subjects (who had programming experience) were mostly trained in the camel-case style."
08:01:56 <yac> nclarke_: camelCase took 13.5% longer with p<0.0001
08:01:57 <sruz25> didn't have "return" anywhere
08:02:03 <yac> nclarke_: pretty convincing to me
08:02:19 <tdammers> anyhoo, how about dashes? lisp-style? o)O
08:02:34 <vanila> doesn't really work if you have infix syntax
08:02:35 <athan> awestroke: Well, do syntax can be condensed, if that's what you're asking. Could I see the code?
08:02:47 <monochrom> nclarke_: all europeans are trained, by way of their native languages, to the space style. that is closer to underscore than to camel.
08:02:56 <yac> nclarke_: oh, that's from the study they replicate
08:03:05 <sruz25> I blame our lectures, they seem to want to teach us everything in half of semester
08:03:36 <sruz25> and thanks for your patience
08:08:09 <awestroke> athan: Sent in PM
08:12:20 <zerokarmaleft> tdammers: aka-kebab-style :D
08:12:41 <tdammers> kebab?
08:12:42 <tdammers> lol
08:16:28 <sruz25> welp, now that I managed to successfully load the thing, I can finally start working on the algorithm :P
08:22:54 <jesyspa> sruz25: If you don't mind me inquiring, why do you specifically need a mutable array?
08:23:53 <NickHu> Hi, I'm doing some haskell exercises and I'm wondering why this doesn't work:
08:23:54 <NickHu> http://lpaste.net/104358
08:23:57 <Marquis> hello haskellers. i got a quiestion. i want to use the kmeans algorithm for my data but it does not yet work because of the type. In the moment i get a fromList [1,2,3...] but i need a [[fromList[1], fromList[2],...]]
08:24:09 <Marquis> i tried map and fmap but they did not work (yet)
08:24:40 <latro`a> can you paste?
08:24:57 <alpounet> Marquis: you have to regroup your points in clusters yeah
08:24:57 <jesyspa> NickHu: Are you sure f Bool is Eq?
08:25:36 <sruz25> jesyspa: it's for edges for goldberg's maximum flow algorithm, where I need to change the flow through edges at random places rather often
08:26:37 <jesyspa> NickHu: Though I'd expect something more like (\b -> if b then (x:) else id) <$> f x <*> filtering f xs
08:26:38 <latro`a> NickHu, I'm not sure that Applicative is even strong enough to do what you want
08:26:42 <jesyspa> sruz25: Ah, I see, thanks.
08:26:53 <sruz25> also I'm loading the edges in rather random order
08:27:19 <latro`a> ah nvm, jesyspa is right
08:28:52 <NickHu> jesyspa: latro`a: I would have thought they would be because the signature is from the NICTA course, I just filled in the function body
08:42:25 <saml> how is using haskell full time ?
08:42:41 <saml> not as ph.d student but in typical web app agile shop
08:45:30 <shapr> saml: it's fast and efficient
08:46:03 <saml> how big is your team shapr ?
08:46:16 <saml> what's url of your product?
08:47:08 <shapr> saml: Our product is written in Python, but I've also done Haskell web dev, and the difference is huge.
08:47:32 <shapr> saml: our product is http://www.charitytracker.net/ where I do web dev every day.
08:47:33 <saml> difference as in throughput?
08:47:55 <shapr> saml: difference in speed of change once you have an actual codebase
08:48:05 <dbushenko> shapr: can you please tell about the difference?
08:48:19 <shapr> saml: I use python/django at work, it's not terrible and has lots of good points.
08:48:32 <Marquis> alpounet++
08:48:50 <shapr> But using scotty+persistent with blaze-html means I can trust my code more and make larger faster changes.
08:49:04 <alpounet> shapr: ah you guys are using scotty too, nice :)
08:49:10 <Lethalman> shapr, do you use TH?
08:49:12 <shapr> Somedays I find Python code that could not possibly have ever worked in our production code, it just hasn't crapped out yet.
08:49:49 <shapr> Lethalman: Yes, I do use Template Haskell, it cuts down on the code I have to write.
08:50:43 <shapr> Idiomatic Python code introduces more coupling between our modules. I get tired of it.
08:51:12 <shapr> My workplace would be fine with me writing some of our webapps in Haskell, but there's no one else here who knows Haskell, so it's not a good choice.
08:51:28 <BeardedCoder> shapr: What company?
08:51:50 <shapr> http://simonsolutions.com/ makers of charitytracker and oasisinsight
08:52:01 <shapr> We make case tracking software for charitable organizations.
08:52:30 <dbushenko> shapr: maybe its better to use haskell for DSLs or some othe problems where correctness matters? web-development seems to simple for haskell
08:52:41 <BeardedCoder> shapr: You gotta grow the community in your org and possibly even your city.
08:52:46 <shapr> dbushenko: In my opinion, correctness matters everywhere :-)
08:52:57 <shapr> BeardedCoder: I've done some stuff to grow the Haskell community :-)
08:53:12 <zomg> dbushenko: web development is hardly "simple" =)
08:53:44 <dbushenko> zomg: why
08:53:52 <zomg> on a certain level perhaps but there's a variety of annoying things in there when you start getting into it
08:54:06 <arj> zomg: e.g. javascript? ;-)
08:54:11 <shapr> dbushenko: I've seen lots of websites that were compromised through SQL injection and let out important company data. I think using Haskell would help with that, though of course bad code can be written in any language.
08:54:17 <zomg> generally you need to deal with at least four different languages
08:54:28 <zomg> then there's a variety of security issues that you need to be very careful about
08:54:34 <zomg> etc.
08:54:49 <dbushenko> shapr: I thought ORMs could help you making calls to DB more sequre
08:54:51 <shapr> Yeah, I deal with SQL, JavaScript, HTML, and Python
08:55:10 <zomg> There's a lot more security issues than just SQL
08:55:10 <shapr> dbushenko: Yes, I agree. That's one advantage of Python's Django and Haskell's Persistent.
08:55:22 <saml> zomg, you need http server, database, accessing 3rd party http service, ad tracking scheduling, personalization / dynamic content, analytics, reporting ... etc
08:55:28 <zomg> there's many ways to inject possibly dangerous data into the requests
08:55:34 <eacameron> so HashMap is O(log n) for lookups as opposed to O(1) for HashTable, but isn't O(1) actually O(key length)? So are there cases where HashMap is actually faster for lookups?
08:55:39 <zomg> you need to be careful to make sure you sanitize all inputs and all outputs
08:55:50 <zomg> then you also need to make sure you avoid issues like cross site request forgery etc.
08:55:52 <dbushenko> actually developing a webapp on a static typed langugagre reduces the speed of development comparing to the languages python/ruby
08:56:01 <shapr> dbushenko: I disagree
08:56:18 <zomg> dbushenko: depends on the language, I find haskell web development to be quite comparable in speed
08:56:30 <shapr> dbushenko: I think that if you were equally familiar with both Haskell and Ruby, you could build websites just as quickly with Haskell.
08:56:33 <zomg> obviously there's not as many packages available for doing a variety of web-dev tasks than say for Ruby
08:56:40 <zomg> but for things which do exist, it's pretty good
08:56:56 <shapr> dbushenko: and I believe the resulting Haskell websites will be easier to change and extend
08:57:11 <saml> dbushenko, you can get started easier with python. but in 3-5 years, you need to rewrite
08:57:20 * hackagebot buildwrapper 0.8.3 - A library and an executable that provide an easy API for a Haskell IDE  http://hackage.haskell.org/package/buildwrapper-0.8.3 (JeanPhilippeMoresmau)
08:57:39 <zomg> If you think about the getting started bit then sure if you don't know any Haskell there is a very large obstacle in your way
08:57:42 <zomg> =)
08:57:46 <shapr> I've been doing webdev almost as long as the web has been around, and I'd much rather use Haskell over Python for webapps.
08:57:57 <shapr> I've also been using Python almost as long as it's been around :-P
08:58:00 <zomg> in comparison, I picked up Ruby on Rails in about a week enough to be productive with it with zero Ruby experience
08:58:03 <saml> with scala at least, refactoring touches so many files. compiler does help you with refactoring.
08:58:07 <zomg> Doubt anyone can do that with Haskell :P
08:58:08 <jophish> Are GHC and UHC the only haskell compilers which cant target LLVM?
08:58:10 <dbushenko> saml: I think, most of the apps need to be rewrited in 3-5 years. if the lifecycle is longer then it should be build with enterprrise technologies
08:58:21 <saml> exactly dbushenko
08:58:37 <saml> at least in USA, life time of apps is really short in my experience
08:58:49 <saml> is haskell ready for enterprise?
08:58:55 <shapr> dbushenko: Have you tried developing webapps in both Haskell and Ruby? I'd like to hear the differences!
08:58:58 <zomg> We need Haskell Enterprise Edition
08:59:02 <BeardedCoder> ug
08:59:15 <zomg> and Haskell Enterprise Certified Engineer -certifications
08:59:17 <joelteon> zomg: hee hee
08:59:20 <zomg> =)
08:59:23 <dbushenko> shapr, well, I'm a haskell newbie. but I have experience in ruby/python/java/c# and clojure
08:59:37 <joelteon> I'll pay $50 USD to the first person that can come up with a Haskell Enterprise solution that spells "hegemony"
09:00:20 <dbushenko> I like clojure best for the speed of development, in my experience it is better comparing to ruby/python
09:00:24 <fragamus> just joined the channel for today.... what's that quip about "hegemony"
09:00:37 <joelteon> fragamus: we were talking about haskell enterprise solutions
09:00:37 <arj> what is the requirement for something beeing "enterprise"
09:00:43 <dbushenko> but I want to compare with haskell to
09:00:49 <joelteon> couldn't tell you, arj
09:00:54 <BeardedCoder> arj, just a name
09:00:59 <zomg> thousand layers
09:01:11 <saml> linkable libraries
09:01:23 <dbushenko> arj: something large, long lifecycle, developed with low qualified resources :-)
09:01:32 <saml> backward compatiblity (can link to libraries compiled with ghc6 ..)
09:02:06 <arj> is enterprise: good reliable, software? Is it ability for integration? is it sustainability?
09:02:12 <zomg> joelteon: Haskell Enterprise Gateway / Enterprise Middleware Organization Monadic... uhh something
09:02:14 <fragamus> I am using haskell at a publicly traded company    : )
09:02:18 <saml> tools  including profiler, monitoring, debugger.  with gui and graphs and charts
09:02:36 <fragamus> We love haskell
09:02:44 <dbushenko> arj: it is rarely good and reliable, but yes, it should have good integration with other enterprise tools and services
09:02:48 <saml> fragamus, is anything open source?
09:02:50 <joelteon> I'm using haskell at a private company right now, it's just not for my job
09:02:52 <arj> fragamus: what is a publicly traded company?
09:02:52 <saml> i want to take a look at it
09:02:53 <fragamus> no
09:03:08 <saml> can you accidentally leak your source. thanks
09:03:10 <saml> for science
09:04:14 <arj> dbushenko: I still wonder, what an 'enterprise business solution' actually is.
09:04:32 <arj> maybe we should talk with a software architect about this
09:05:01 <yac> can you recommend a library to read git configs?
09:05:21 <saml> isn't git config standard ini?
09:05:36 <arj> thought so, too
09:05:38 <dbushenko> arj: enterprise solution means exactly what it sounds: a solution for the needs of an enterprise. all its properties depend on the needs of the enterprise
09:05:45 <yac> it's similar a lot but I think there is some twist
09:05:57 <dbushenko> usually it means long lifecycle, good support, good integration with everything
09:06:20 <dbushenko> good support for instance means using old and stable technologies like java
09:06:21 <Eelis> with an enterprise price tag, no less!
09:06:23 <yac> well, I'm now reading it with Data.Ini but it's making problems as I need to state exactly key like "\tremote "
09:06:32 <hseg> Hi. Just noticed that certain constructions on lists have duals, and those duals can be constructed by reversing everything. e.g. a prefix of xs is a the reverse of a suffix of xs reversed.
09:06:54 <hseg> Is this well known? Can someone point me to references on this?
09:07:03 <hseg> If it isn't, why isn't this useful?
09:07:21 * hackagebot apiary 0.6.1.0 - Simple web framework inspired by scotty.  http://hackage.haskell.org/package/apiary-0.6.1.0 (HirotomoMoriwaki)
09:07:51 <yac> has it something to do with apiary.io ?
09:08:41 <carter> doubtful
09:09:15 <shapr> dbushenko: tell me how Haskell webdev works for you, I'm interested!
09:10:22 <dbushenko> yea, I'm interested too!
09:11:14 <HugoDaniel> what is the current state of functional reactive programming in haskell libs ?
09:11:51 <carter> hahhahahah :)
09:12:00 <carter> HugoDaniel: which definition of FRP are you talkin?
09:12:15 <yac> how do I cabal uninstall?
09:12:21 * hackagebot ffmpeg-light 0.7.1 - Minimal bindings to the FFmpeg library.  http://hackage.haskell.org/package/ffmpeg-light-0.7.1 (AnthonyCowley)
09:12:23 * hackagebot elm-server 0.11.0.1 - Server for developing Elm projects  http://hackage.haskell.org/package/elm-server-0.11.0.1 (EvanCzaplicki)
09:13:01 <saml> yac, ghc-pkg remove
09:13:24 <saml> yac, actually i'm wrong
09:13:29 <saml> there's no ghc-pkg remove
09:13:35 <HugoDaniel> carter: dont know, typical one ? signals, events, sampling, time being continuous and all that mambo jambo
09:13:40 <carter> ah
09:13:41 <carter> hrmm
09:13:42 <zerokarmaleft> saml: damn, what a tease
09:13:45 <carter> good question
09:13:51 <saml> maybe ghc-pkg unregister
09:13:58 <carter> i'm told that netwire and reactive-bananna and sodium are nearly there
09:14:02 <carter> they
09:14:07 <carter> they're tuned for different workloads
09:14:33 <saml> yac,  ghc-pkg unregister --force regex-compat-0.95.1
09:14:46 <carter> you don't need --force
09:14:48 <saml> http://hackage.haskell.org/package/cabal-uninstall
09:15:18 <saml> https://github.com/plancalculus/cabal-uninstall/blob/master/cabal-uninstall.hs#L163
09:15:19 <yac> thanks
09:15:21 <yac> that works
09:16:06 <saml> because haskell is fully CQRS, you need to use different programs when installing and uninstalling dependencies
09:17:11 <yac> hsini can't read git config
09:17:22 * hackagebot ffmpeg-light 0.7.1.1 - Minimal bindings to the FFmpeg library.  http://hackage.haskell.org/package/ffmpeg-light-0.7.1.1 (AnthonyCowley)
09:17:26 <yac> sigh
09:17:28 <saml> let's write a gitconfig parser together
09:17:33 <saml> so that i can learn haskell
09:17:43 <saml> there are some good parser library in haskell
09:17:54 <yac> too advanced for me
09:18:06 <saml> http://hackage.haskell.org/package/uu-parsinglib  this good
09:18:40 <saml> yac, why are you parsing gitconfig?
09:18:45 <saml> there might be a workaround
09:18:50 <yac> there isn't
09:19:14 <saml> like.. have python parse gitconfig and output json
09:19:20 <yac> LOL
09:19:28 <saml> because json is universal encoding format, haskell can read json
09:19:35 <saml> through restful api
09:19:55 <saml> python flask can easily create restful gitconfig api over http
09:20:15 <yac> I'm rewriting https://github.com/yaccz/git-yrp/blob/master/git-yrp to haskell because 1. I hate shell scripts and 2. I learn haskell
09:20:51 <BeardedCoder> gah, I'm so sick of (endpoint -> json) being considered rest. But, that argument is not for this channel =)
09:20:51 <yac> saml: yeah why don't serve it from an init system, that already has builtin http server too now!
09:21:20 <jophish> Given a whole program, is it possible to specialise every usage of every function, i.e. remove all universal quantifiers over type variables. (Excluding the usage of rankN types)
09:21:33 <jophish> I can't think of a counterexample off the top of my head
09:21:37 <saml> yac, let's write the parser together then. i want to learn haskell too
09:21:41 <companion_cube> why don't people put a Readme in their repo ;_;
09:21:51 <yac> saml: write your own parser
09:22:19 <companion_cube> jophish: recursion with GADTs?
09:22:21 <saml> companion_cube, just read code. code is documentation for a typical haskell
09:22:38 <n-dolio> jophish: No.
09:22:41 <companion_cube> here it's the 'yrp' thing linked by yac, so it's shell
09:22:50 <napping> jophish: what's that about rankN types? polymorphic recursion can happen
09:22:57 <companion_cube> and code shouldn't be the only documentation..
09:23:06 <napping> data Exp a = Var a | App (Exp a) (Exp a) | Lam (Exp (Maybe a))
09:24:13 <jophish> companion_cube: could you give me an example. I'm not overly familiar with what GADTs can do
09:24:30 <n-dolio> You don't need GADTs.
09:24:55 <companion_cube> n-dolio: where does polymorphic recursion kick in?
09:24:56 <jophish> napping: I'm not sure how the Exp datatype fits in here
09:25:11 <n-dolio> unbound :: Show a => Int -> a -> String ; unbound 0 a = show a ; unbound n a = unbound (n-1) (a,a)
09:25:25 <napping> jophish: any code working over that has to be prepared for arbitrarily deep binders, so you can't monomorphize it
09:25:28 <n-dolio> Maybe Integer should be used.
09:25:33 <companion_cube> hmmmm
09:25:39 <n-dolio> Since technically you can generate one copy of that function per Int.
09:25:51 <n-dolio> For each starting type.
09:26:13 <saml> yac, have you tried ConfigFile ?
09:26:22 <yac> trying just now
09:26:28 <jophish> Ah, May I add A restriction to the input Haskell then: No recursion
09:26:34 <saml> hackage.haskell.org/package/ConfigFile-1.1.2/docs/Data-ConfigFile.html#4   looks like whitespace trimmed
09:26:35 <jophish> (except perhaps tail recursion)
09:26:45 <n-dolio> My example is tail recursion.
09:27:05 <jophish> err, of course. no recursion at all then!
09:27:59 <companion_cube> haskell without recursion seems kind of weak :)
09:28:40 <jophish> companion_cube: I've written a compiler for a subset of Haskell
09:29:01 <yac> same issue
09:29:02 <jophish> one of the restriction is no recursive data types, and no recursion but tail recursion
09:29:13 <yac> I suppose that's where is the twist for git configs
09:29:19 <yac> it can have " in section names
09:29:24 <yac> everything blows up on this one
09:29:28 <yac> I hate everything
09:29:31 <companion_cube> no recursive data types :(
09:29:49 <jophish> It's somewhat restrictive, yeah
09:30:04 <jophish> I'm compiling it to GLSL
09:30:08 <hseg> I just noticed that certain duals of constructions on lists can be specified as the same construction under the isomorphism reverse . reverse = id. E.g. lastN n = reverse . takeN n . reverse
09:30:40 <hseg> Is this known? Where can I find stuff written on this if so? If it isn't useful, why isn't it useful?
09:31:42 <saml> yac, do you have working testcase and gitconfig input?
09:31:50 <yac> lol, not even git config can read it
09:32:14 <napping> hseg: anything under reverse like that can't be lazy
09:32:26 * hackagebot deka 0.6.0.0 - Decimal floating point arithmetic  http://hackage.haskell.org/package/deka-0.6.0.0 (OmariNorman)
09:32:45 <yac> saml: echo -e "[remote \"stable\"]\n\turl = foo" > gitconfig; read the url
09:32:48 <hseg> napping: Sure.
09:33:31 <saml> what's [remote "stable"] ?
09:33:38 <hseg> napping: That's obvious when talking about suffixes and stuff like that.
09:33:39 <yac> key
09:33:52 <yac> have you never seen a git config?
09:34:07 <napping> hseg: that's why I guess things are not usually explained that way
09:34:26 <saml> yah i've only seen [global] and stuff
09:35:21 <saml> let me write a python parser for you. should be easy
09:35:23 <hseg> napping: Aren't constructions on the end of a list useful?
09:35:53 <jophish> n-dolio: Thinking a little more about the unbound example; What would be a good term for a tail recursive function which doesn't change the type of its tail call. For example unbound here would fail that restriction, since 'unbound a' calls 'unbound (a,a)'
09:35:59 <napping> On the end of alist, maybe not
09:36:20 <napping> If you need to do things on the end of the list, then something like Seq that makes it more reasonably efficient might be better
09:36:22 <jophish> If only this same-type recursion is allowed, can one specialise everything. I'll give this a think myself
09:37:16 <hseg> Sure. This isn't restricted to lists. It works for any Foldable.
09:37:26 <HugoDaniel> i like elerea for frp, seems simpler than the other big alternatives
09:37:40 <hseg> Well, more or less. Any Foldable that can be constructed from a list.
09:37:48 <yac> hrm, I already used System.Process somewhere .. if I just remembered where
09:38:00 <hseg> So Seq, Vector, etc.
09:42:11 <Phillemann> Might be a stupid question, but: I have a function "generateElement :: RandomGen g => g -> a" and I want to formulate quickcheck properties of that function. How do I randomly generate a RandomGen?
09:42:26 <saml> yac, i give up. too hard
09:42:39 <yac> lol
09:43:11 <Cale> :t mkStdGen
09:43:12 <lambdabot> Int -> StdGen
09:43:19 <Cale> Phillemann: ^^ using that perhaps
09:43:30 <yac> saml: https://github.com/yaccz/jsmin-hs I wrote this, could be similar. Simple, no weird haskell stuff there but I don't want to write parser right now
09:43:32 <napping> or maybe splitting the generator in Gen, if it has one?
09:45:13 <benzrf> :t get
09:45:14 <lambdabot> MonadState s m => m s
09:46:13 <Phillemann> Ah yes, mkStdGen should work, thanks. :)
09:50:47 <benzrf> :t mkStdGen
09:50:47 <lambdabot> Int -> StdGen
09:50:55 <benzrf> > mkStdGen 394830989458793847593485739847598345
09:50:56 <lambdabot>  308035850 1
09:51:01 <benzrf> o_o
09:51:15 <benzrf> > read "308035850 1" :: StdGen
09:51:17 <lambdabot>  308035850 1
09:51:19 <benzrf> cool
09:51:21 <saml> yac, you code good haskell. you're hired
09:52:23 <yac> saml: for how much?
09:52:35 <saml> $500k industry standard
09:52:40 <yac> annual?
09:52:45 <saml> sadly, yes
09:52:55 <saml> can't pay more than that because of obamacare
09:53:51 <yac> saml: I'm located in europe
09:54:23 <saml> then learn to operate air craft since we give you free helicopters
09:54:40 <yac> lol sure
09:57:06 <napping> Phillemann: be careful how many different ints quickcheck will give you, you might not try too many generators
09:59:51 <hunt> is there a way to take an argument and apply a functio to it before any version of my function uses it?
10:00:18 <hunt> withouth changing the type of my function?
10:00:50 <hunt> like taking a fn f:: [String] -> a, and applying (map words) to the strings before theyre processed
10:00:50 <ReinH> hunt: I'm not quite sure what you mean
10:01:32 <hunt> i want something like f theStrings = let parsed = map words theStrings in _____
10:01:36 <hunt> withouth having to use let
10:01:46 <hunt> and possibly accross all versions of the function
10:01:53 <alpounet> :t \f -> f . map words
10:01:54 <lambdabot> ([[String]] -> c) -> [String] -> c
10:01:55 <hunt> er all patterns
10:02:11 <alpounet> the type necessarily changes though
10:02:20 <alpounet> unless you then want to flatten that back to a [String]
10:02:35 <alpounet> :t \f -> f . concatMap words
10:02:36 <lambdabot> ([String] -> c) -> [String] -> c
10:02:37 <jfhall> quit
10:02:45 <jfischoff> is there any way I can tell cabal to not install into the sandbox, without changing directories?
10:02:52 <hunt> so youre suggesting just passing different arguments
10:03:05 <Phillemann> Hmm, can I make quickcheck print values other than the generated property input parameters when a test fails?
10:03:24 <alpounet> hunt: yeah, I guess; the workflow is quite clear, with that
10:03:26 <carter> jfischoff: i bet theres a cabal help install falg
10:03:28 <carter> *flag
10:03:45 <alpounet> jfischoff: --user ?
10:04:26 <ReinH> hunt: sounds like a contravariant functor
10:04:46 <jfischoff> —user did not seem to work
10:05:35 <mietek> Has anyone ran into issues with Haddock and XPackageImports?
10:06:14 <hunt> how do i import only the Map type from Data.Map?
10:06:25 <ion> import Data.Map (Map)
10:06:51 <supki> jfischoff: cabal --ignore-sandbox
10:07:10 <ReinH> (that will also import instances, but there's no way to not do that)
10:07:40 <identity> C++ lambdas and other functional programming constructs make me sad :(
10:07:42 <jfischoff> supki: is that new? I don’t seem to have it on 1.18.0.3
10:08:13 <Phillemann> identity: How so?
10:08:32 <identity> They are rigid and awkward to use when you're used to Haskell
10:08:49 <ReinH> > lmap words length "hello world" -- hunt
10:08:51 <lambdabot>  2
10:09:13 <ReinH> an example of using a contravariant functor for what you want
10:09:51 <ReinH> :t contramap
10:09:52 <lambdabot> Contravariant f => (a -> b) -> f b -> f a
10:09:59 <ReinH> > contramap words length "hello world" -- hunt
10:10:00 <lambdabot>  Couldn't match type ‘[GHC.Base.String]’ with ‘GHC.Types.Int’
10:10:00 <lambdabot>  Expected type: [GHC.Types.Char] -> [GHC.Base.String]
10:10:00 <lambdabot>    Actual type: [GHC.Types.Char] -> GHC.Types.Int
10:10:25 <supki> jfischoff: yeah, I think it was added in 1.20
10:10:28 <ReinH> hmm
10:10:35 * jfischoff nods
10:10:38 <bennofs> ReinH: I think there is no instance for (->)
10:10:43 <ReinH> bennofs: ah
10:10:49 <bennofs> ReinH: Because you'd need "currying" at the type level
10:11:05 <ReinH> bennofs: ok :)
10:11:11 <benzrf> monads are just too cool
10:11:11 <ReinH> well you can use Profunctor
10:11:18 <ReinH> benzrf: confirm
10:11:23 <bennofs> you can have a Functor for (->) a (Reader), but not Contravariant (-> a)
10:11:31 <benzrf> bennofs: yep
10:11:46 <bennofs> > lmap words length "hello world"
10:11:47 <lambdabot>  2
10:11:52 <ReinH> bennofs: oh it's in the wrong position
10:11:54 <ReinH> bennofs: duh
10:12:07 <c_wraith> Profunctor puts it in the right position!
10:12:12 <ReinH> c_wraith: indeed :D
10:12:16 <benzrf> :k Flip
10:12:17 <lambdabot> Not in scope: type constructor or class ‘Flip’
10:12:19 <benzrf> lame
10:12:22 <ReinH> c_wraith: also nice pun :D
10:12:31 <c_wraith> yes.  I was hoping someone would notice. :)
10:12:45 <ReinH> c_wraith: I was positive that someone would
10:12:46 <yac> I have read bunch of things into Maybe String variables. Now how do I get Just values from it and build Config object or return Nothing?
10:12:50 <benzrf> @let FlipFunc a = (a -> r)
10:12:50 <lambdabot>  Parse failed: ViewPatterns is not enabled
10:12:57 <ReinH> c_wraith: do you see what I did there? :D
10:12:58 <benzrf> @let newtype FlipFunc a = (a -> r)
10:12:58 <lambdabot>  Parse failed: Illegal data/newtype declaration
10:13:13 <benzrf> @let newtype FlipFunc a = FlipFunc {applyFunc :: (a -> r)}
10:13:14 <lambdabot>  .L.hs:145:50: Not in scope: type variable ‘r’
10:13:17 <benzrf> pfft
10:13:29 <ReinH> yac: what's the type of the function you want?
10:13:45 <benzrf> @let newtype FlipFunc r a = FlipFunc {applyFunc :: (a -> r)}
10:13:47 <lambdabot>  Defined.
10:14:23 <bennofs> @ty Forget
10:14:24 <yac> ReinH: fn :: (Maybe String) -> (Maybe String) -> (Maybe String) -> YRPConfig
10:14:24 <lambdabot>     Not in scope: data constructor ‘Forget’
10:14:24 <lambdabot>     Perhaps you meant ‘Format’ (imported from Data.Char)
10:14:32 <yac> ReinH: fn :: (Maybe String) -> (Maybe String) -> (Maybe String) -> (Maybe YRPConfig)
10:14:38 <benzrf> @let instance Contravariant (FlipFunc r) where contramap = dimap applyFunc FlipFunc (.)
10:14:39 <lambdabot>  .L.hs:148:21:
10:14:39 <lambdabot>      Couldn't match type ‘FlipFunc r0 a0’ with ‘a -> b’
10:14:39 <lambdabot>      Expected type: (a -> b) -> FlipFunc r b -> FlipFunc r a
10:14:39 <lambdabot>        Actual type: FlipFunc r0 a0 -> FlipFunc (a1 -> r0) (a1 -> a0)
10:14:41 <lambdabot>      Relevant bindings include
10:14:45 <benzrf> @let instance Contravariant (FlipFunc r) where contramap = dimap FlipFunc applyFunc (.)
10:14:49 <lambdabot>  .L.hs:148:46:
10:14:51 <lambdabot>      Couldn't match type ‘FlipFunc b a’ with ‘b0 -> c0’
10:14:52 <benzrf> oops
10:14:53 <lambdabot>      Expected type: FlipFunc b a
10:14:55 <lambdabot>                     -> FlipFunc (FlipFunc r a) (FlipFunc r b)
10:14:57 <lambdabot>        Actual type: (b0 -> c0) -> (a0 -> b0) -> a0 -> c0
10:15:05 <ReinH> yac: how do you construct a YRPConfig?
10:15:13 <vermeille> I never wrote a library in Haskell. Now I want to use some project's code inside another, but have plenty of module paths errors (not found, mostly). What did I do wrong, or what is the way to workaround?
10:15:25 <benzrf> @let instance Contravariant (FlipFunc r) where contramap f (FlipFunc c) = FlipFunc (f . c)
10:15:26 <lambdabot>  .L.hs:148:46:
10:15:26 <lambdabot>      Couldn't match type ‘b’ with ‘r’
10:15:26 <lambdabot>        ‘b’ is a rigid type variable bound by
10:15:26 <lambdabot>            the type signature for
10:15:26 <lambdabot>              contramap :: (a -> b) -> FlipFunc r b -> FlipFunc r a
10:15:30 <benzrf> >:{
10:15:31 <yac> ReinH: what do you mean? I just do let c = YRPConfig x y c
10:15:42 <ReinH> yac: if YRPConfig :: String -> String -> String -> YRPConfig then YRPConfig <$> maybe1 <*> maybe3 <*> maybe3
10:15:54 <benzrf> @let instance Contravariant (FlipFunc r) where contramap f (FlipFunc c) = FlipFunc (c . f)
10:15:55 <lambdabot>  Defined.
10:15:58 <benzrf> sweet
10:16:28 <yac> ReinH: what if maybe3 is not a maybe? I have something hardcoded for now
10:16:36 <ReinH> yac: use pure
10:16:59 <yac> ReinH: not in scope
10:17:03 <ReinH> yac: import it
10:17:03 <yac> ReinH: <$>
10:17:10 <ReinH> from Control.Applicative
10:17:12 <yac> where from? I can't google it :)
10:17:14 <yac> ah
10:17:20 <ReinH> @hoogle (<$>)
10:17:22 <lambdabot> Data.Functor (<$>) :: Functor f => (a -> b) -> f a -> f b
10:17:23 <lambdabot> Control.Applicative (<$>) :: Functor f => (a -> b) -> f a -> f b
10:17:25 <ReinH> yac: use the hoogle
10:18:09 <bennofs> If searching for a function by name, I prefer hayoo because it searches more packages
10:18:28 <davd> vermeille: module names and paths in .cabal need to be correct. probably best to read up on some existing project's structure.
10:18:29 <ReinH> or that
10:19:32 <davd> https://www.fpcomplete.com/hoogle has pretty good coverage
10:21:55 <vermeille> davd: the pattern seems to be to always use `module Path.To.The.Module.Module where ...` right?
10:22:32 <vermeille> I was only writing `module Module where`
10:22:42 <c_wraith> vermeille: GHC looks for modules in a file path matcching the module name, yes
10:22:56 <yac> ReinH: cool, it seems to be working
10:23:11 <ReinH> yac: :)
10:23:13 <vermeille> c_wraith: what's wrong exactly in the second version?
10:23:55 <vermeille> (given that the module is in Path/To/The/Module/Module.hs)
10:23:56 <yac> ReinH: fuck yes it is
10:24:01 <ReinH> :t (<*>)
10:24:02 <lambdabot> Applicative f => f (a -> b) -> f a -> f b
10:24:21 <ReinH> yac: remember, Applicative abstracts the concept of function application to work on functors.
10:24:31 <ReinH> Take the f's away and you just have ($)
10:24:38 <yac> ReinH: you do realize, I have no idea what you just said, right?
10:24:42 <ReinH> yac: ok :)
10:24:47 <c_wraith> vermeille: seems right.  I was intending to reinforce what you were saying.  The module name and file *path* need to match.
10:25:39 <davd> vermeille: "hs-source-dirs: base-path-to-sources" tends to be useful as well
10:26:00 <benzrf> @hoogle [m Bool] -> Bool
10:26:00 <lambdabot> Data.Foldable and :: Foldable t => t Bool -> Bool
10:26:00 <lambdabot> Data.Foldable or :: Foldable t => t Bool -> Bool
10:26:00 <lambdabot> Prelude and :: [Bool] -> Bool
10:26:08 <benzrf> oh wait
10:26:20 <yac> ReinH: so Maybe is f here?
10:26:32 <benzrf> @hoogle (a -> Bool) -> [m a] -> Bool
10:26:33 <lambdabot> Data.Foldable all :: Foldable t => (a -> Bool) -> t a -> Bool
10:26:33 <lambdabot> Data.Foldable any :: Foldable t => (a -> Bool) -> t a -> Bool
10:26:33 <lambdabot> Prelude all :: (a -> Bool) -> [a] -> Bool
10:26:38 <benzrf> kk
10:26:41 <vermeille> davd: well okay, I will use cabal. I'm not using it since it's an overkill for such a little project, but yes, it makes things easier
10:26:42 <ReinH> yac: indeed :)
10:26:48 <yac> ok, cool
10:27:53 <ReinH> :t sequence (undefined :: [IO Bool]) -- benzrf
10:27:54 <lambdabot> IO [Bool]
10:28:12 <benzrf> which binds tighter, >>= or .
10:29:02 <Taneb> >>= is infixl 1, . is infixr 9
10:29:12 <benzrf> o-k
10:29:32 <benzrf> wait, higher number = less tight, right?
10:29:35 <hexagoxel> vermeille: i have never used it, but ghc has -i option that might be suitable. but ofc setting up cabal packages properly is probably better
10:29:53 <ReinH> bennofs: use a boolean monoid:
10:29:58 <ReinH> :t foldr (liftM2 (&&)) (return True) -- benzrf
10:29:59 <lambdabot> Monad m => [m Bool] -> m Bool
10:30:01 <ReinH> bennofs: sorry
10:30:17 <benzrf> :t And
10:30:18 <lambdabot>     Not in scope: data constructor ‘And’
10:30:18 <lambdabot>     Perhaps you meant ‘Any’ (imported from Data.Monoid)
10:30:20 <benzrf> o=
10:30:23 <benzrf> :t Any
10:30:24 <lambdabot> Bool -> Any
10:30:26 <benzrf> cool
10:30:34 <ReinH> or that sure
10:30:58 <benzrf> 01:28 < benzrf> wait, higher number = less tight, right?
10:32:12 <Cale> benzrf: No, the other way? ($) is level 0
10:32:23 <benzrf> oh
10:32:24 <benzrf> o_o
10:32:39 <Cale> x >>= f . g means x >>= (f . g)
10:32:47 <benzrf> ok
10:32:58 <benzrf> :t flip fmap
10:32:59 <lambdabot> Functor f => f a -> (a -> b) -> f b
10:33:10 <benzrf> @hoogle Functor f => f a -> (a -> b) -> f b
10:33:10 <lambdabot> Prelude fmap :: Functor f => (a -> b) -> f a -> f b
10:33:10 <lambdabot> Data.Functor fmap :: Functor f => (a -> b) -> f a -> f b
10:33:10 <lambdabot> Control.Monad fmap :: Functor f => (a -> b) -> f a -> f b
10:33:15 <benzrf> ok
10:33:37 <ReinH> benzrf: flip fmap is <&> in lens
10:34:08 <benzrf> oh neat
10:34:10 <yac> LOL and git config can't have underscores in keys
10:39:54 <benzrf> lens is coo
10:40:05 <benzrf> thx edwardk
10:40:15 <benzrf> hows it goin Mon_Ouie
10:41:58 <Mon_Ouie> I'm fine, thanks :)
10:43:03 <benzrf> Mon_Ouie: didnt know you did HS
10:43:04 <benzrf> :t T.traverse
10:43:05 <lambdabot> (Traversable t, Applicative f) => (a -> f b) -> t a -> f (t b)
10:47:32 * hackagebot zlib-enum 0.2.3.1 - Enumerator interface for zlib compression  http://hackage.haskell.org/package/zlib-enum-0.2.3.1 (MalteSommerkorn)
10:49:27 <vermeille> How do I refer to other modules which were not installed with a relative path in a cabal file?
10:49:52 <roconnor> what are the important differences between Attoparsec and Parsec?
10:50:37 <Reite> roconnor: Quality of errors vs speed
10:51:00 <roconnor> what makes attoparsec faster?
10:51:05 <Reite> This is really nice: http://stackoverflow.com/questions/19208231/attoparsec-or-parsec-in-haskell
10:51:35 <albeit> Is there a built in function to check if a list is at least a certain length? Int -> [a] -> Bool doesn't turn up anything, but that may not be accurate
10:52:13 <Reite> Unless you are actually asking about how they are implemented, if thats the case, I have no idea.
10:52:43 <quchen> albeit: null . drop n
10:53:08 <albeit> quchen: Ah makes sense, thanks
10:53:12 <napping> that's no more than a given length
10:53:38 <benzrf> :t null
10:53:39 <lambdabot> [a] -> Bool
10:53:51 <albeit> :t null . drop
10:53:52 <lambdabot>     Couldn't match type ‘[a1] -> [a1]’ with ‘[a0]’
10:53:52 <lambdabot>     Expected type: Int -> [a0]
10:53:52 <lambdabot>       Actual type: Int -> [a1] -> [a1]
10:54:02 <albeit> :t null . drop 5
10:54:03 <lambdabot> [a] -> Bool
10:57:49 <Marqin> when i have "ones = 1 : ones" why when I run "lenght ones" it just loops without taking whole memory? (and "sum ones" takes whole memory)
10:58:29 <benzrf> Marqin: tail recursion, i would expect
10:58:38 <benzrf> oh wait i see what you mean
10:58:41 <benzrf> interesting
10:58:53 <napping> because sum is pretty bad
10:58:54 <identity> then length must be stricter than sum
10:59:03 <quchen> Marqin: "sum" has a silly definition. Use foldl' (+) 0 instead.
10:59:05 <benzrf> i think it can probably continue to match the pattern without evaluating
10:59:33 <benzrf> ones never needs to be evaluated further than the second thunk
10:59:35 <benzrf> @src length
10:59:35 <lambdabot> Source not found. You speak an infinite deal of nothing.
10:59:38 <benzrf> lame
10:59:42 <roconnor> Reite++
10:59:49 <roconnor> Reite: that link was very helpful
11:00:31 <quchen> length = go 0 where go !l (_:xs) = go (l+1) xs; go l [] = l
11:00:43 <quchen> Conceptually, at least.
11:03:19 <Marqin> quchen: i used foldl and  I writen own sum
11:03:25 <Marqin> quchen: both take whole memory
11:03:31 <Marqin> quchen: length should also
11:03:41 <Marqin> but i'm asking why length is not
11:03:59 <identity> Marqin: Because length is strict(apparently)
11:05:42 <identity> Marqin: Every time a '1' is 'generated', 1 is added to the current total length, and then that '1' is discarded. It's not attempting to evaluate a list of infinite length
11:06:10 <shachaf> quchen: That definition will generate roughly the best code you can hope for, with CPR.
11:06:20 <Marqin> identity: but when he know when to discard?
11:06:26 <Marqin> *how he
11:06:27 <shachaf> The GHC definition uses unboxed Int#s but that is no longer necessary in modern GHC.
11:06:34 <Marqin> strange
11:06:45 <Marqin> i've writen own lenth like this one: http://hackage.haskell.org/package/base-4.6.0.1/docs/src/GHC-List.html#length
11:06:49 <Marqin> and it's taking whole memory
11:06:49 <vanila> shouldn't sum and length be the same
11:07:05 <Marqin> isn't this one the official length?
11:07:33 <dropdrive> [Hand-wavy newbie question] Is there a generalization of `scan` or `reduce` the way `fmap` generalizes `map`?
11:07:40 <shachaf> I don't know what it means to take whole memory.
11:07:58 <shachaf> What is the actual program that you're running and how are you measuring it?
11:08:06 <identity> dropdrive: You mean reduce = fold? There's Data.Foldable and such
11:08:16 <ReinH> dropdrive: look at Foldable
11:08:25 <napping> Marqin: using foldl the count is lazy, so it goes like foldl (+) 0 ones => foldl (+) (1+0) ones => foldl (+) (1+1+0) ones ....
11:09:43 <Marqin> napping: i'm not asking about sum now
11:09:45 <Guest10958> l/help
11:09:48 <Marqin> oh
11:09:54 <dropdrive> identity, ReinH: Thanks.  (I wonder what Data.Scannable would be?)
11:09:54 <Marqin> it may be something with those #?
11:09:59 <ReinH> foldl is written in such a way that the recursive calls to foldl are reduced by lazy evaluation. The folding function, in this case (+), is not immediately evaluated and builds up thunks. foldl' fixes this by forcing that evaluation.
11:10:02 <shachaf> dropdrive: Data.Foldable has folds. In theory Data.Traversable could have scanl1/scanr1, but it doesn't.
11:10:17 <Marqin> i have rewriten lenght without # and it's taking whole memory
11:10:18 <shachaf> dropdrive: lens has general-purpose scan[lr]1, though.
11:10:19 <identity> dropdrive: there you have it ;)
11:10:20 <Marqin> but with those #
11:10:36 <identity> Marqin: maybe you could start by posting some source-code
11:10:48 <shachaf> Marqin: If you don't give enough information for people to be able to reproduce your problem, they can't help you.
11:11:12 <shachaf> The problem is probably not where you think (as problems often are).
11:11:27 <Marqin> identity: i've posted
11:11:34 <dropdrive> shachaf: Thanks.  What is the name of the general-purpose lens scan[lr]1?
11:11:36 <shachaf> For example, when you used unboxed values, that's the "#"s you're talking about), you don't need strictness annotations.
11:11:39 <benzrf> llllllens
11:11:45 <shachaf> dropdrive: scanl1Of
11:11:48 <Marqin> identity: http://hackage.haskell.org/package/base-4.6.0.1/docs/src/GHC-List.html#length
11:11:50 <shachaf> And so on.
11:12:06 <identity> Marqin: I'm thinking your code.
11:12:09 <Marqin> shachaf: I'm asking why this implementation of length doesnt take whole memory and if it's something with #
11:12:33 <shachaf> No implementation of length "takes whole memory" until you actually apply it to something and run it.
11:12:50 <napping> Marqin: my answer goes for length too
11:12:51 <shachaf> So you need to post your actual, real code and the actual, real way that you're compiling and running it.
11:12:59 <identity> Marqin: Yes, it is. Because it's strict. It's not creating an infinite thunk of (0+1+1+1+1+1+...)
11:12:59 <napping> length just adds a 1 every time, instead of numbers from the list
11:13:02 <shachaf> But yes, there's something with # -- strictness.
11:13:17 <ReinH> and also the position of len in the recursive calls
11:13:18 <vanila> how is +1 different from +1
11:13:25 <ReinH> compare with genericLength
11:13:48 <identity> vanila: Hm?
11:13:52 <shachaf> genericLength is a whole different bucket of cans.
11:13:58 <vanila> length and sum should be the same
11:14:03 <lispy> > length [0.0,0.08..2*pi]
11:14:04 <shachaf> It is never the right answer.
11:14:05 <lambdabot>  80
11:14:16 <ReinH> shachaf: I'm not suggesting it as an answer
11:14:18 <shachaf> (Except with lazy naturals. It's the opposite of generic.)
11:14:49 <exicer> Has anyone made much use of persistent ?
11:14:55 <Pythonfant> How does precedence work in haskell? Looking at the code of $ I can't find anything that would make this have low, right-associative precedence
11:15:00 <jle`> exicer: i used it a bit about a while back
11:15:07 <exicer> It seems like a good idea, but it kinda looks like it might be a bit clunky
11:15:14 <jle`> how so?
11:15:20 <shachaf> Pythonfant: There's a top-level "infixr 0 $" declaration somewhere in the file that defines ($).
11:15:39 <ReinH> Pythonfant: generally it works using infixr and infixl declarations
11:15:42 <exicer> jle`: Well, can you do stuff like ON DELETE CASCADE etc ?
11:15:52 <Marqin> napping: sum also ads 1 for this list, and it's not my question
11:15:58 <exicer> Or do you end up doing more in the haskell, rather than the db ?
11:15:58 <Marqin> identity: http://pastebin.com/20jgWES3
11:16:03 <Pythonfant> ReinH, shachaf: Ah thank you, I missed that.
11:16:22 <Marqin> identity: it's neearly identycal but without those #
11:16:31 <Marqin> identity: and the pastebin one is taking whole memory
11:16:58 <napping> Marqin: the only reason it takes too much memory is because it acumulates unevaluated expressions
11:17:02 <identity> Marqin: Yep, it's not strict.
11:17:11 <identity> #+ is addition for unboxed Ints
11:17:12 <Marqin> but strict isn't accumulating?
11:17:19 <Marqin> like function stack
11:17:22 <identity> It's special ghc voodoo
11:17:29 <ReinH> Marqin: "strict isn't accumulating"?
11:17:34 <ReinH> I'm not sure what that means
11:17:39 <identity> no, it isn't. It's evaluating every addition immediately.
11:17:52 <vanila> Marqin, do you use ghc or ghci?
11:17:57 <Marqin> vanila: both
11:18:12 <shachaf> Marqin: You're not pasting whole code. :-(
11:18:32 <identity> Your version: len (..) 0 -> len .. (0 + 1) .. (0 + 1 + 1) .. (0 + 1 + 1 + 1..) to infinity. Unboxed, built-in version: 1 -> 2 -> 3 -> 4 -> 5 -> 6 -> ...
11:18:57 <vanila> Can GHC show the results of strictness analysis?
11:19:08 <Marqin> identity: so it should also rose
11:19:24 <shachaf> Anyway, multiple people, starting with quchen 20 minutes ago, have given you the right answer.
11:19:24 <ReinH> Marqin: "rose"?
11:19:25 <Marqin> identity: like when it needs another bit
11:19:26 <bennofs> vanila: I think the core includes annotations
11:19:29 <Marqin> ReinH: yeah
11:19:33 <Marqin> ReinH: rise
11:19:34 <napping> vanila: it's included in Core, dunno if there's anything nicer
11:19:35 <shachaf> Don't worry about unboxing. GHC will unbox this automatically. Worry about strictness.
11:19:36 <vanila> how do we see core?
11:19:42 <shachaf> ghc -ddump-simpl
11:20:22 <Marqin> shachaf: no they don't
11:20:41 <shachaf> 10:59 <quchen> length = go 0 where go !l (_:xs) = go (l+1) xs; go l [] = l
11:20:55 <shachaf> What you need to do: Add strictness (e.g., len [] !a = ...; len (_:xs) !a = ...)
11:21:05 <Marqin> shachaf: i don't want do add anything
11:21:05 <shachaf> Compile with optimizations (this may not be critical).
11:21:15 <Marqin> shachaf: i'm asking WHY not how change
11:21:32 <vanila> Marqin, http://pastebin.com/DjDbpHEg
11:21:36 <shachaf> And show your whole code.
11:21:39 <identity> Marqin: And we have explained why several times now.
11:21:46 <Marqin> shachaf: grep log, posted it
11:21:58 <shachaf> No, that definition isn't your whole code.
11:22:04 <Marqin> identity: no, you have said "Your version: len (..) 0 -> len .. (0 + 1) .. (0 + 1 + 1) .. (0 + 1 + 1 + 1..) to infinity. Unboxed, built-in version:  1 -> 2 -> 3 -> 4 -> 5 -> 6 -> ...
11:22:08 <Marqin> "
11:22:09 <shachaf> If I compile that program GHC complains that "main" isn't defined.
11:22:10 <Marqin> but
11:22:14 <Marqin> 1 -> ... ->
11:22:20 <Marqin> should also take whole mmemory
11:22:27 <identity> No. It can only be as big as an Int.
11:22:28 <Marqin> or haskell doesn't have bignumes?
11:22:34 <identity> It does, but Int isn't.
11:22:44 <napping> How many times do you have to add 1 to a bignum to take more than 64 bits of memory?
11:22:45 <Marqin> oh
11:22:47 <napping> Did you wait that long?
11:22:48 <napping> No
11:22:53 <ReinH> Marqin: the latter grows in the size of the result
11:22:53 <Marqin> identity: so Integer was bignum?
11:22:59 <identity> Marqin: Integer is bignum, yes.
11:23:02 <Marqin> oh
11:23:02 <ReinH> Marqin: the former grows in the number of computations required to produce the result
11:23:07 <Marqin> identity: thanks, than concludes all
11:23:07 <ReinH> Marqin: these are entirely different
11:23:13 <Marqin> *that
11:23:39 <ReinH> Int vs Integer is not relevant here.
11:23:53 <Marqin> ReinH: it's
11:24:14 <Marqin> ReinH: with Integer it would take whole memory one time
11:24:25 <napping> Marqin: try it
11:24:27 <ReinH> Marqin: Int vs Integer is not the reason your code uses more memory.
11:24:42 <Marqin> ReinH: I'm not asking why it uses more memory.
11:24:45 <Cale> Marqin: It'll take a very very very long time before it'll use more than a single 64 bit machine integer
11:24:47 <ReinH> ...
11:24:48 <Marqin> ReinH: this code is made to loop
11:24:54 <vanila> I don't understand
11:25:00 <ReinH> What are you asking then?
11:25:04 <vanila> I compared the Core output with and without bang patterns
11:25:06 <identity> ReinH: He understands that, I believe. He's simply saying that if there was no upper limit on the size of Int, it would grow to eventually use his whole RAM.
11:25:07 <vanila> and both looks the same
11:25:09 <Marqin> ReinH: i was asking why that one wasn't taking more memory, and it was because it was Int not Integer
11:25:16 <Marqin> ^ and that's is the answer, EOT
11:25:17 <vanila> how do you read the strictness analysis result from this?
11:25:23 <ReinH> Marqin: no, the difference is not Int vs. Integer.
11:25:31 <ReinH> The difference is strictness.
11:25:35 <vanila> Marqin, your code used Int
11:25:35 <napping> Marqin: that's not the reason at all. If they both used Integer, the one with strictness would still take much less
11:25:39 <identity> Marqin: You misunderstood me.
11:25:52 <ReinH> Int vs. Integer is irrelevant here.
11:25:56 * identity goes to do something else. 
11:26:04 <shachaf> ==identity
11:26:04 <vanila> http://pastebin.com/DjDbpHEg anyone?
11:26:07 <Cale> Marqin: Let's suppose that it takes 1 nanosecond to increment an integer. Then it'll take about 584 years before you can do enough increments to require that integer to be larger than 64 bits.
11:26:29 <ReinH> Marqin: it's literally impossible for Int vs Integer to matter at all.
11:26:42 <shachaf> vanila: What about it?
11:26:44 <ReinH> Because of what Cale said, and also just because of the type of length.
11:27:06 <napping> vanila: well, in Core the case is always strict. I think there are little letter flags somewhere about what is strict
11:27:10 <Cale> Marqin: and even then, it'll take ridiculously longer before the Integer will consume your entire memory
11:27:12 <int-e> @let newtype Codensity f x = Codensity (forall r. (x -> f r) -> f r) -- @let now parses higher order types
11:27:18 <lambdabot>  Defined.
11:27:21 <shachaf> int-e++
11:27:23 <ReinH> int-e: woo
11:27:28 <bennofs> :t Condensity
11:27:33 <Cale> Marqin: much much much longer than the age of the universe
11:27:36 <lambdabot>     Not in scope: data constructor ‘Condensity’
11:27:40 <bennofs> :t Codensity
11:27:42 <lambdabot>     Perhaps you meant ‘Codensity’ (line 143)
11:27:45 <shachaf> (I think those are "higher-rank", though.)
11:27:48 <lambdabot> (forall r. (x -> f r) -> f r) -> Codensity f x
11:28:25 <Cale> Marqin: (that's a ridiculous understatement as well)
11:29:25 <vanila> (GHC.Num.+ @ GHC.Types.Int GHC.Num.$fNumInt a1_apJ (GHC.Types.I# 1))
11:29:37 <int-e> shachaf: I meant "second order" (having variables that range over types), as in second-order lambda calculus (aka System F)
11:29:41 <vanila> so this will not be evaluated?
11:30:07 <int-e> shachaf: higher rank is correct, too.
11:30:14 <vanila> it's just building up +1 +1 +1 +1 ..
11:30:17 <vanila> is that right?
11:31:26 <Cale> Your available memory is probably a few gigabytes at least, let's say it's just 1 GiB we have available. Then to a good approximation we'll be able to count to 2^(8*2^30) = 2^8589934592
11:31:27 <benzrf> \\
11:31:43 <Cale> That will take an unimaginably vast amount of time
11:31:50 <napping> vanila: looks like it. That's extracting the + field from a Num dictionary
11:31:56 <vanila> hmm
11:32:10 <vanila> it's the same code with ! annotations, so how do I make it strict?
11:32:16 <napping> you'd have to look at the context to see if it's forced afterwards
11:32:23 <Cale> But yeah, if we leave the additions unevaluated, you run out of memory much more rapidly
11:32:38 <napping> The a1_apJ seems to be the other argument, maybe that gets forced on the way in?
11:33:18 <vanila> oh! I see it
11:33:37 <shachaf> Also if you compile with -O2 you'll get much better Core.
11:33:40 <napping> there may be some options to simplify the core output, but I don't remember them
11:33:54 <shachaf> -dsuppress-blah-blah will get rid of a bunch of junk
11:34:06 <shachaf> In particular -dsuppress-all
11:34:15 <napping> most strictness should become case statements
11:34:22 <napping> even something like case x of x -> ... forces x in core
11:34:24 <brbblnch> Hi
11:34:52 <Cale> pickiness: case expressions*
11:35:12 <monochrom> vanila: read my http://www.vex.net/~trebla/haskell/lazy.xhtml
11:36:57 <brbblnch> On planet.haskell.org and reddit.com/r/haskell , many talk about stuff like category theory and type theory and it seems that haskell is the most mathematically backed language out there. Why is it so ?
11:37:52 <benzrf> brbblnch: because it is
11:38:02 <monochrom> the language tells you about its designers
11:38:11 <benzrf> brbblnch: but i get haskell pretty ok and i dont know shit about what a functor is in cat theor
11:38:29 <benzrf> something to do with an isomorphism on categories that preserves arrows
11:38:33 <benzrf> or something along those lines
11:38:39 <Cale> Well, I don't know if you really could say it's the *most* mathematically backed language, given that things like Coq and Agda exist.
11:40:01 <Cale> But it's close, especially for practical work, it's sitting in a really nice position between mathematically nice properties and availability of useful libraries.
11:42:44 <vanila> does the memory problems with haskell not stop it being useful for real programming though?
11:43:31 <Cale> vanila: What problems?
11:43:47 <Cale> There can be space issues with specific programs, but that's true in any language.
11:44:21 <vanila> like memory usage going out of control
11:44:27 <vanila> becaus eif thunks building up
11:44:28 <brbblnch> (sorry, computer problem)
11:44:42 <Cale> vanila: Well, there are lots of tools for dealing with that.
11:45:18 <beanandgone> hi, could please somebody looks why this is not compiling: http://lpaste.net/104361 ?
11:46:00 <Cale> vanila: For the most part, you eventually just learn to see where there's danger of unevaluated expressions being accumulated, and throw in a pattern match or strictness annotation to fix the problem.
11:46:13 <brbblnch> But are those domains (type and category theory) along haskell, or is haskell just based on those ?
11:47:08 <rwbarton> beanandgone: GHC gives a good indication of why when it says "The type variable `b0' is ambiguous"
11:47:10 <Cale> brbblnch: Don't know exactly what you mean. Learning about category theory if your interest is just in using Haskell is an unnecessary distraction.
11:47:35 <Cale> beanandgone: It doesn't know which instance of T2 you want to use.
11:47:40 <ReinH> brbblnch: well, Haskell takes what I think is a very algebraic approach to functional programming, and Category Theory is an algebra of functions, so it makes sense that CT can be used to explain a lot of things in Haskell.
11:47:49 <rwbarton> beanandgone: there's no way for GHC to determine which type b to pick as the argument type of count / result type of newT2
11:47:51 <beanandgone> rwbarton: Cale: but why should it care?
11:47:55 <ReinH> brbblnch: but Haskell isn't founded on CT in any real way.
11:48:07 <ReinH> brbblnch: It's certainly founded on type theory though.
11:48:08 <rwbarton> beanandgone: because the result could depend on which type b you choose!
11:48:09 <Cale> beanandgone: Because the implementation of count might be completely different for different instances of T2
11:48:26 <n-dolio> Isn't ML impractical for real programming because it puts your lists into memory all at once even if it's not necessary?
11:48:38 <brbblnch> Ok, so those are real mathematical theory delelopped by themeselves. And haskell takes inspiration from then.
11:48:43 <brbblnch> *them
11:48:47 <ReinH> brbblnch: absolutely
11:48:58 <brbblnch> Nice, thanks
11:48:59 <Cale> Yeah, that's a good point, Haskell makes many programs practical which would be totally impractical under strict evaluation.
11:49:39 <Cale> brbblnch: Yeah, if you have a strong interest in mathematics, it can absolutely be worth learning category theory, but it's by no means required.
11:50:12 <Cale> (and in day-to-day programming, you probably won't get too much use out of it, but then, it'll also give you a particular way of looking at things which can sometimes be advantageous)
11:50:14 <beanandgone> Cale: rwbarton: I thought since I'm using only the result of "count" GHC can still compile this code
11:50:31 <Cale> beanandgone: But the result of *which* count?
11:50:43 <Cale> beanandgone: I might have:
11:50:48 <Cale> data A = A
11:50:53 <beanandgone> Cale: which ever newT2 created
11:50:55 <Cale> instance T2 A where count A = 0
11:51:00 <Cale> data B = B
11:51:06 <Cale> instance T2 B where count B = 1
11:51:29 <beanandgone> but newT2 will create specific T2
11:51:35 <Cale> no it won't
11:51:37 <beanandgone> i.e. B or A, i.e. it will be known later
11:51:38 <rwbarton> in fact in the snippet you posted you haven't defined any instances at all, so where is GHC supposed to get count from :)
11:51:46 <Cale> It'll produce *any* instance of T2 at all that you want
11:51:49 <beanandgone> from constraint
11:52:16 <brbblnch> Cale: good to know, thanks
11:52:21 <Cale> It must be prepared to produce a value of whatever instance of T2 its user requests
11:52:40 <Cale> In particular, I should be able to use newT2 p as both a value of type A and as a value of type B
11:52:45 <Cale> if I have those instances abover
11:52:48 <Cale> above*
11:53:04 <Cale> Right?
11:53:21 <Cale> Its full type is newT2 :: (T1 a, T2 b) => a -> b
11:53:24 <beanandgone> but newT2 is in T1 class
11:53:47 <Cale> So for any types a and b, if a is an instance of T1, and b is an instance of T2, it will take a value of type a and produce a value of type b.
11:54:23 <Cale> and the caller gets to decide what the types a and b are
11:54:48 <Cale> newT2 has no control over which type b is
11:55:04 <beanandgone> how can I accomplish this in correct way?
11:55:21 <Cale> Well, it's unclear what you're actually trying to accomplish with this code
11:55:47 <Cale> If you write some instances of T1 and T2, you can add a type annotation with one of those instances to specify what type you want the result of newT2 to have.
11:56:30 <beanandgone> I thought I can define instance of T1 which will provide newT2 that return specific instance of T2
11:56:34 <Cale> e.g. if you had:  instance T2 Int where count = id
11:56:41 <beanandgone> I expected then GHC to take count from this specific instance of T2
11:57:00 <Cale> Well, to be honest, it's very hard to write a decent instance of T1
11:57:08 <rwbarton> that's not what "class T1 a where newT2 :: (T2 b) => a -> b" means
11:58:04 <beanandgone> could you please elaborate on what it means then?
11:58:09 <Cale> Because T2 provides you with no operations for constructing values of an arbitrary instance of T2
11:58:26 <rwbarton> it means what Cale wrote earlier
11:58:57 <Cale> So really, the only thing which newT2 can be doing is producing an error or undefined.
11:59:04 <rwbarton> you have to write a function that can take a value of type a and produce a value of type b for any types a and b where a is an instance of T1 and b is an instance of T2
11:59:12 <deweyvm> concatenating a bunch of strings is causing a "Segmentation fault/access violation in generated code". does this sound familiar to anyone?
11:59:16 <rwbarton> well, where a is the type you're defining the instance for
11:59:31 <rwbarton> but b is under the caller's control
11:59:33 <Cale> deweyvm: When you say strings, do you mean values of type String?
11:59:38 <deweyvm> Cale: yes
11:59:42 <Cale> deweyvm: That should basically not happen
11:59:50 <deweyvm> Cale: er, or functions which return strings
11:59:53 <Cale> deweyvm: Segfaults are GHC bugs
12:00:04 <rwbarton> beanandgone: usually the first suggestion in this sort of situation is to avoid defining your own type classes
12:00:10 <Cale> Unless you're using FFI stuff or things explicitly marked as unsafe
12:00:34 <Cale> deweyvm: Can you put your program on lpaste?
12:00:56 <deweyvm> http://pastebin.com/Grp45wpg Cale
12:01:09 <deweyvm> it happens randomly, but most of the time
12:01:21 <deweyvm> if i change formatTimes to just return "" then i do not get a segfault
12:01:38 <deweyvm> could also be an issue in the file writing part of the code though
12:01:44 <Cale> There is no possible way that this code can segfault.
12:01:46 <napping> what if you change it to formatTimes (!user, !w, !x, !y, !z, !total, !message) = ""
12:02:04 <akuna> Does one can give me a reference where typing of terms are done using separeted type systems?
12:02:07 <Cale> Which input does it segfault on?
12:02:18 <deweyvm> napping: still segfault
12:02:18 <n-dolio> Your two possibilities are GHC bug or larger system malfunction (software or hardware).
12:02:22 <akuna> Cale: hi
12:02:26 <beanandgone> Cale: rwbarton: thanks a lot, I'll try to define instances and see where it goes
12:02:35 <rwbarton> deweyvm: most likely this code is triggering garbage collections which tickles some other bug
12:02:37 <napping> deweyvm: okay, then one of your arguemnts is some bogus thunk wrapping an unsafe operation that segfaults
12:02:46 <Cale> beanandgone: It might help to know more about what sort of program you're trying to write
12:02:56 <deweyvm> the values come from an sql database
12:02:59 <napping> deweyvm: like Cale says, what are the inputs?
12:03:14 <napping> try printing them right after you get them
12:03:36 <beanandgone> Cale: I wanted to abstract Data.Vector.Vector/MVector and Data.Packed.Vector/STVector from hmatrix
12:03:36 <Cale> You might also use something like:
12:03:51 <deweyvm> is there a way to flush stdout with type a -> a
12:03:52 <beanandgone> Cale: so I can switch between backends
12:03:53 <Cale> formatTimes t | trace (show t) False = undefined
12:04:02 <deweyvm> does trace flush?
12:04:15 <Cale> ^^ add that just before the current pattern match
12:04:23 <deweyvm> ("SomeName",6,38,51,4,6813,"why")
12:04:23 <Cale> This is using Debug.Trace.trace
12:04:28 <napping> deweyvm: I was thinking of adding a print in IO right after you do the query
12:04:34 <rwbarton> trace outputs to stderr which should have no buffering
12:04:35 <beanandgone> Cale: I tried to define Vec/MVec type classes but run into issues (something like in my simpler example)
12:04:38 <deweyvm> i can try that too
12:05:00 <beanandgone> Cale: I'll spend some more time and will create better example
12:05:05 <Cale> beanandgone: okay
12:05:12 <napping> a problem somewhere in the database binding is possible. Which are you using?
12:05:19 <deweyvm> HDBC with ODBC
12:05:21 <akuna> Cale: hi
12:05:27 <Cale> akuna: hi
12:05:43 <akuna> could u please see pm for a second?
12:05:45 <rwbarton> deweyvm: it's possible you are running into something like https://ghc.haskell.org/trac/ghc/ticket/9078 (where some library you're using uses makeStableName)
12:06:05 <akuna> Cale: could u please see pm for a second?
12:07:32 <Jenna18>  Hi! I give you some videos. I hope you like! http://bit.ly/Sfliu6
12:08:12 <deweyvm> interesting
12:08:35 <deweyvm> i filled my big do block with bangs and now its gone, looks like ill be able to isolate it pretty easily then
12:08:39 <oleo> don't give into, Jenna18 is an NSA spy!
12:08:40 <oleo> lol
12:09:12 <teknokratsevilla> hi
12:09:29 <oleo> she just wants you to surf porn sites in order to accuse you of it afterwards!
12:09:34 <oleo> lol
12:09:47 <bennofs> How can I get a TimeLocale for a given language? (I want to have german abbreviated names for weekdays, etc). Do I have to define it myself or is it already defined somewhere?
12:10:54 <oleo> if it were against child abuse i'd support her, tho it seems it's not!
12:11:46 <deweyvm> could laziness be ordering the execution of my sql statements in a way that the underlying c library considers undefined?
12:12:09 <napping> I really hope you're sql statements are not executed under an unsafePerformIO
12:12:12 <Cale> oleo: what are you even talking about?
12:12:15 <deweyvm> they are not
12:12:22 <deweyvm> not in my code anyway :P
12:12:27 <oleo> lol
12:12:30 <Cale> oleo: Maybe you're talking to the wrong channel?
12:12:36 <oleo> no
12:12:37 <Cale> This is #haskell
12:12:38 * hackagebot HListPP 0.1 - A preprocessor for HList labelable labels  http://hackage.haskell.org/package/HListPP-0.1 (AdamVogt)
12:12:41 <oleo> i know
12:12:58 <napping> don't reply to spammers
12:12:58 <bennofs> Cale: he was talking about the spam message by Jenna18
12:13:08 <napping> especially after they've already been banned
12:13:11 <oleo> i don't
12:13:28 <oleo> allright then
12:14:14 <Cale> Oh, I missed that
12:15:04 <deweyvm> now i can make the segfault happen based on whether or not a print a value haha
12:15:08 <deweyvm> even though they are all strict
12:15:27 <napping> that's pretty wierd. Full code?
12:16:26 <deweyvm> https://github.com/deweyvm/ircdb . generate in DB.hs now looks like http://pastebin.com/LmWdQtAi
12:16:41 <deweyvm> and if i comment out the print on line 8, it segfaults
12:16:47 <pavonia> bennofs: There are no implementations for languages other than English yet, AFAIK, I wanted to release a library for German at least
12:17:21 <deweyvm> nvm, i went ahead and pushed the changes
12:17:42 <deweyvm> https://github.com/deweyvm/ircdb/blob/master/src/IRCDB/DB.hs#L383
12:18:05 <deweyvm> i realize my password is in there, but its a local db :P
12:18:18 <napping> oh, if those are String you need more than !
12:18:25 <deweyvm> oh?
12:18:28 <napping> something like deepSeq or length
12:18:47 <napping> The ! just forces the first :
12:19:23 <deweyvm> that should be enough to rule out database race conditions though
12:19:25 <napping> If you can add deepseq, try using rnf
12:19:43 <napping> something is pretty broken here
12:20:44 <deweyvm> if i replace the print with return $ rnf (late, morning, evening, night)
12:20:47 <deweyvm> still segfaults
12:21:00 <napping> what?
12:21:05 <napping> that's just absurd
12:21:20 <napping> oh, you're ignoring the value from the return
12:21:24 <napping> so it's never forced
12:21:36 <deweyvm> ah
12:21:46 <napping> try (late, morning, evening, night) `deepSeq` (return ())
12:22:11 <deweyvm> that works, no segfault
12:22:16 <napping> huh
12:22:29 <napping> maybe somebody is being evil with unsafeInterleaveIO?
12:22:38 <napping> Or you're hitting that 7.8.2 bug?
12:22:49 <deweyvm> 7.6.3
12:23:16 <rwbarton> I didn't find any makeStableName in HDBC or HDBC-odbc anyways
12:23:24 <deweyvm> oh maybe im running it threaded and thats doing it?
12:23:31 <deweyvm> nvm im not
12:25:02 <deweyvm> https://github.com/hdbc/hdbc/search?q=unsafe&ref=cmdform
12:25:21 <napping> :(
12:25:28 <deweyvm> so its probably that?
12:25:51 <napping> that's a start at least, I'd hope the HDBC authors at least tried to use it safely
12:26:53 <rwbarton> it looks like this is intended for end-user use
12:27:04 <napping> there are a fair number of warnings in the docs
12:27:08 <napping> still a segfault is a bit much
12:27:19 <napping> if you're calling that, try fetchAllRows'
12:27:24 <deweyvm> just did
12:27:29 <deweyvm> still segfaults :(
12:27:55 <rwbarton> can you run your program under a debugger? that will at least tell you whether the segfault is in some C function
12:28:39 <n-dolio> You'd have to be doing something pretty weird to cause a segfault using unsafeInterleaveIO.
12:28:45 <n-dolio> Despite all the superstition about it.
12:29:19 <napping> n-dolio: yes, but calling out to database bindings that might be picky about what order you use their functions in is the sort of thing that might do it
12:29:34 <rwbarton> at this point I would suspect some assumption made by the underlying C library is being broken, yes
12:29:42 <deweyvm> heh, i get a compilation error if i try to run it in ghci
12:29:49 <deweyvm> probably to do with me using a sandbox
12:30:16 <rwbarton> like doing a query whose fields are strings, reading one row, then doing another query whose fields are ints, then trying to read a row from the first query
12:31:46 <deweyvm> that makes sense
12:31:58 <kakos> What is the best package for doing network stuff in Haskell?
12:32:07 <grache28> I tryed on hoogle already - but does anyone know if's there a function to remove exactly 1 ocurrence from a list? for example: remove 5 [5,1,5,2,] returns [1,5,2] ?
12:32:35 <n-dolio> > [5,1,5,2] // 5
12:32:35 <napping> grache28: Data.List.delete does that
12:32:36 <lambdabot>  Couldn't match expected type ‘GHC.Arr.Array i e’
12:32:36 <lambdabot>              with actual type ‘[t0]’
12:32:46 <grache28> tks napping
12:33:06 <napping> Data.List.\\ takes a list and deletes one of each thing in the list
12:34:13 <n-dolio> And (//) updates an array. Obviously.
12:35:19 <deweyvm> anyway, thansk for the help everyone :)
12:39:35 <funfunctor> hi
12:39:50 <vanila> hey :)
12:39:58 <Eduard_Munteanu> Hi.
12:40:01 <funfunctor> oh hey man
12:40:22 <funfunctor> vanila: I got that cryptol support merged btw for the syntax highlighting :)
12:40:29 <vanila> sweet
12:40:34 <vanila> well done
12:40:58 <funfunctor> coreboot has just been sucking up my time..
12:41:17 <vamega> Hi.
12:41:42 <vamega> I'm trying to install ghc-mod structured-haskell-mode and stylish-haskell inside a cabal sandbox
12:42:01 <vamega> But I seem unable to do so.
12:42:24 <vamega> It appears that haskell-src-exts-1.15.0.1 failed to install.
12:42:32 <funfunctor> So I have a question :p .. Suppose I am modelling some Linux command line software using Haskell, I want to come up with a EDSL for it embedded in Haskell. What is the best approch to deal with so many IO monads and nicely abstract them?
12:42:42 * hackagebot webdriver 0.5.4 - a Haskell client for the Selenium WebDriver protocol  http://hackage.haskell.org/package/webdriver-0.5.4 (AdamCurtis)
12:44:13 <vanila> have you seen http://www.haskell.org/haskellwiki/Simple_Unix_tools ?
12:44:21 <ReinH> funfunctor: free monads are a nice way to abstract monads
12:44:23 <vanila> it's quite nice but you might do more
12:45:09 <johnw> funfunctor: a library like operational or free-operational can make your life a bit easier
12:45:13 <funfunctor> vanila: hehe cute but yes I need to do much more
12:47:42 * hackagebot quickcheck-regex 0.0.3 - Generate regex-constrained strings for QuickCheck  http://hackage.haskell.org/package/quickcheck-regex-0.0.3 (AudreyTang)
12:48:18 <funfunctor> johnw: just reading on that now
12:52:53 <gamegoblin> Is it possible to use unsafePerformIO and some sort of mutable map to create a higher order function which takes a pure function and returns another pure function, but uses the mutable map inside some sort of closure to do result caching? Basically mutable memoization nonsense.
12:54:18 <Saizan> yep
12:54:37 <gamegoblin> What would that look like/idea what which structures and functions I’d use?
12:54:41 <Saizan> lennart augustsson's has some blog post about that
12:54:47 <gamegoblin> I’ll go look around
12:55:17 <gamegoblin> lol “Data.MemoUgly"
12:55:50 <gamegoblin> Exactly what I was looking for
12:56:22 <gamegoblin> I haven’t quite mastered MVars yet
12:56:44 <savanni> Hey, all.  I just put up a paste (http://lpaste.net/104365) in which I'd like some help with defining the error potion of my API.
12:57:28 <savanni> The code I put into the paste works so far as it goes, but I would like to make the two functions in my typeclass specific as to what errors they return.  Preferably while still allowing the benefits of EitherT.
12:58:00 <funfunctor> johnw: sorry this seems to help me with building the EDSL right?
12:58:17 <johnw> correct
12:59:03 <funfunctor> johnw: yes, ok thanks but the part I am more confused with is modeling a bunch of Linux admin commands in some 'nice way'
12:59:34 <johnw> I'm not sure what you mean
12:59:43 <johnw> can you sketch the interface you'd like to see?
12:59:51 <funfunctor> I can just think of writing a function lifted to a IO monad for which command but is there something nicer I could do?
13:00:59 <funfunctor> well suppose I was modelling the configuration of a NIC though the 'ip' command (new version of ifconfig it seems)
13:01:04 <johnw> I'm not sure what you mean by "model" here; maybe you just want Shelly?
13:01:21 <ReinH> funfunctor: (operational is (isomorphic to) a free monad)
13:01:44 <ReinH> but it's a bit nicer to write this sort of thing with operational
13:01:49 <funfunctor> ReinH: yes I noticed that, its what motivated the free-operational rewrite?
13:02:07 <funfunctor> thanks i'll keep that in mind
13:02:22 <ReinH> funfunctor: free-operational is an optimization (it's the codensity trick)
13:02:53 <ReinH> tl;dr it reassociates binds into a normal form that allows evaluation to operate more efficiently
13:03:43 <funfunctor> basically i'll give the idea of what I have.. I want to write a REPL loop that gives a console much like you would see on a cisco router but configures a Linux box
13:04:28 <funfunctor> the thing is I don't just want a CLI, I want a web gui also, and I expect to call certain functions in the controller component if that makes sense?
13:04:48 <ReinH> funfunctor: yep, sounds like a good use for operational
13:05:02 <shachaf> It's not the codensity trick, it's the coyoneda trick.
13:05:27 <ReinH> shachaf: right, codensity is too large
13:05:33 <funfunctor> ideally I kind of would like to see this design like a simple compiler of sort, different UI's as the frontend and a IR that pipes into the backend which retargets different command line toolings
13:05:34 <ReinH> shachaf: coyoneda is the Ran trick?
13:05:50 <funfunctor> am I making sense?
13:05:58 <halvorg> How do I do Double -> Float again?
13:06:08 <ReinH> funfunctor: I think so
13:06:19 <funfunctor> oh thats good :)
13:06:28 <johnw> funfunctor: yeah, makes sense to me
13:06:41 <funfunctor> sweet
13:07:05 <vanila> funfunctor, one way might be build the IR as a data type - and then have a monad instance that interprets it for the repl as well as compilers that work separately
13:07:10 <funfunctor> so I am kind of having issue on where/what to start on to get my teeth in
13:07:19 <gamegoblin> halvorg: import GHC.Float, use double2Float
13:07:23 <gamegoblin> :t double2Float
13:07:25 <lambdabot> Not in scope: ‘double2Float’
13:07:31 <johnw> funfunctor: describe the data type that will abstract your EDSL
13:07:41 <funfunctor> vanila: yea that sounds exactly what I was thinking a bunch of GADT's
13:07:41 <halvorg> thanks gamegoblin.
13:08:22 <vanila> funfunctor, yeah! Here's an example of that (data P and instance Monad P, don't need to look at the rest of the file) http://hackage.haskell.org/package/base-4.7.0.0/docs/src/Text-ParserCombinators-ReadP.html
13:08:24 <ReinH> funfunctor: you might enjoy http://www.haskellforall.com/2012/06/you-could-have-invented-free-monads.html
13:09:35 <funfunctor> ah perfect thanks, I think I need to play with a few examples before I can start thinking of a reasonable design you know..
13:09:46 <Rryy> Hi All, on Cabal, how do you create custom targets?
13:10:00 <Rryy> e.g.: cabal hlint
13:10:00 <benzrf> supki:
13:10:02 <benzrf> *up
13:10:04 <benzrf> **sup
13:10:07 <benzrf> >.<
13:10:10 <funfunctor> I always find its best to work on some motivating example but really not directly related just so I can understand
13:10:24 <ion> const char **sup
13:10:29 <benzrf> ion: haha
13:10:44 <Rryy> (I see there is an option, cabal run executable, to run a program of my own, but that would be included in the distribution)
13:11:22 <Rryy> There's this related issue on github: https://github.com/haskell/cabal/issues/1354
13:22:45 * hackagebot muon 0.1.0.6 - Static blog generator  http://hackage.haskell.org/package/muon-0.1.0.6 (kaashif)
13:30:59 <askalero> hey, i want to reinstall all packages with profiling and read about using cabal install --reinstall world, but it tells me that All the requested packages are already installed: Use --reinstall if you want to reinstall anyway.
13:34:03 <chrisseaton> askalero: i may be missing something, but I've never found success in trying to reinstall with profiling, I've always deleted my cabal directory and and started over again when I've needed it and didn't think ahead
13:34:10 <grache28> hi guys
13:34:37 <grache28> I'm getting this error: Inferred type is not general enough -
13:34:59 <grache28> *** Expected type : a -> Bool - *** Inferred type : ([a],b,c) -> Bool
13:35:22 <c_wraith> grache28: It means you put a very general type signature on something, and the code isn't that general
13:36:24 <RyanGlScott> Is there a way to define "partial" record syntax? For example, I have "data Foo = Foo { one :: Int, two :: Int}", but I only ever use two, so compiling the code with -Wall gives me an annoying "defined but not used" warning. Is there a way to omit the one accessor function?
13:36:54 <shachaf> RyanGlScott: You can start the name with _ to get rid of the warning.
13:37:12 <bennofs> Is it possible to view the hackage upload history (not just the current day)?
13:37:21 <RyanGlScott> Ah, that's clever.
13:37:43 <epta> Could someple please explain cabal error message "Cabal: Multiple cabal files found.". What is wrong with using multiple cabal files as a `cabal install` arguments?
13:37:44 <grache28> c_wraith: yea - the problem is I need it to be that specific, otherwise it will fail :/ -- i have to tie into a another define function that takes the function i'm writing as ( a -> Bool). That being the case, I guess I'll see what happens if I change that functions sig to MyType -> Bool
13:37:58 <epta> someone*
13:38:08 <pavonia> RyanGlScott: Why do you have one when you don't use it?
13:39:30 <RyanGlScott> pavonia: I'm using an algebraic data type to represent a C struct in some FFI-related code. I should probably just not peek or poke the fields that I don't need, now that I think about it.
13:39:33 <askalero> chrisseaton: ok, i got it with cabal install --reinstall --force-reinstall --upgrade-dependencies mtl random
13:39:59 <chrisseaton> askalero: ah great - I'll note that for next time, thanks
13:40:01 <askalero> chrisseaton: so it works for a set of pkgs but not for world
13:40:28 <chrisseaton> askalero: I think I saw recommended elsewhere getting it to print a list of installed packages and then sending that list to a similar command
13:43:12 <askalero> chrisseaton: i guess something along: ghc-pkg --user list and reinstalling them shoudl work, yeah
13:45:30 <sm> epta: it's fine to "cabal install PKG1 PKG2 ...", but "cabal install" expects to find only one FILE.cabal in the current directory
13:47:43 <benzrf> jjjjjj
13:47:47 <benzrf> oops
13:48:15 <epta> sm: it is `cabal install one/file.cabal another/file.cabal --flags third/file.cabal`
13:49:59 <sm> that seems to work here (cabal 1.20), though I would normally type cabal install ./one ./another ./third
13:57:28 <halvorg> :t sin
13:57:29 <lambdabot> Floating a => a -> a
13:57:34 <halvorg> Radians or degrees?
13:57:37 <halvorg> for sin/cos/tan
13:57:53 <geekosaur> radians
13:58:02 <shachaf> Easy enough to find out.
13:58:42 <shachaf> Admittedly it would be nice if the documentation mentioned it.
14:00:11 <bennofs> > sin pi
14:00:13 <lambdabot>  1.2246467991473532e-16
14:01:05 * geekosaur golf clap at failoating point
14:01:19 <halvorg> Yep shachaf, silly of me not to ghci it : ) totally forgot
14:02:08 <shachaf> > sin 90
14:02:10 <lambdabot>  0.8939966636005579
14:02:13 <shachaf> "close enough"
14:02:14 <joelteon> is there any way to get GHC to print more information about thrown exceptions from -xc? Exceptions can be shown, can't they?
14:02:35 <benzrf> joelteon: why are you using exceptions
14:02:46 <joelteon> I'm not.
14:02:53 <joelteon> That's why I want to get more information about why one is being thrown.
14:02:54 <ReinH> geekosaur: Close Enough(TM)
14:03:58 <joelteon> exceptions always have a Show instance, but of course I don't know how much metadata about the exception is available at runtime
14:05:10 <benzrf> what's the use of Choice
14:05:51 <bennofs> benzrf: profunctor Choice class?
14:06:21 <bennofs> benzrf: or what Choice do you mean?
14:06:35 <benzrf> the former, sorry
14:07:16 <bennofs> benzrf: in lens, it allows you to implement prisms
14:08:28 <bennofs> benzrf: it allows you to "lift" profunctors so that the "work" on a part of a Sum type
14:09:19 <benzrf> hmms
14:09:33 <benzrf> i dont understand o_O
14:09:37 <benzrf> oh wait
14:09:45 <benzrf> so on functions it adds an alternate path>
14:10:20 <benzrf> it makes them work as id on any type, or if you have the right type then themselves?
14:14:00 <vermeille> I have an haskell project with its cabal file (I'm writing my website) and in subdirectories, some others projects with their own cabal files. How do I make the top level cabal file reference the others? If that's not possible, how to refer to other packages that are not installed system-wide?
14:14:17 <benzrf> hmmmm
14:14:33 <benzrf> so choice is supposed to be for anything that's isomorphic to Either?
14:15:47 <uncleBlazer> Can anyone tell me if a functor has to be bijective?
14:16:20 <benzrf> uncleBlazer:  do you mean fmap or what
14:16:23 <shachaf> It does not.
14:17:02 <benzrf> shachaf: what kind of bijective
14:17:44 <uncleBlazer> I was just reading the definition of functor on wikipedia and wondered in general
14:18:37 <uncleBlazer> So not every object in C has to map to an object in D
14:18:40 <shachaf> Of course, before the question makes sense you have to say what it means for a functor to be bijective.
14:18:52 <shachaf> But for any interpretation I can think of the answer is no.
14:18:59 <beanandgone> Cale: are you still here? Could you please look at: http://lpaste.net/104368
14:19:19 <shachaf> Yes, a functor : C -> D maps every object in C to an object in D.
14:19:28 <shachaf> And more importantly, every arrow in C to an arrow in D.
14:19:37 <benzrf> uncleBlazer: that's not meaningful question in the context of haskell afaict
14:19:47 <benzrf> haskell functors only allow you to map arrows
14:19:58 <ReinH> uncleBlazer: this mapping is not one-to-one and onto.
14:20:04 <mmachenry> shachaf: But not necessarily every object in D is mapped to, right?
14:20:20 <benzrf> mmachenry: depends on the functor
14:20:31 <benzrf> Identity functor is certainly a bijection
14:20:40 <mmachenry> benzrf: Right, so therefor it's *not* bijective.
14:20:57 <benzrf> mmachenry: huh?
14:21:15 <mmachenry> benzrf: Isn't the question "Do functors have to be bijective?"
14:21:33 <ReinH> benzrf: type constructors like Maybe provide the object mapping
14:22:00 <shachaf> mmachenry: Not necessarily.
14:22:15 <shachaf> But focusing on objects usually misses the point. Talk about arrows.
14:22:31 <Dofgh> LOL
14:23:42 <shachaf> People hear about categories: "A category consists of objects and arrows". So they think objects are important, at least as important as arrows, if not more. And they sound nice and concrete and simple. People say "The category of monoids", where monoids are the objects of the category.
14:24:07 <benzrf> it's all about the arrows baby
14:26:28 <`Jake`> How can I take a Rational to the power of another Rational?
14:27:14 <Cale> beanandgone: I'm assuming that z was meant to be v?
14:27:19 <`Jake`> Also, why does the real typeclass require you to be able to convert your type to Rationals, even though most reals aren't rationals?
14:27:27 <Cale> `Jake`: By converting to floating point first
14:27:38 <`Jake`> Cale: Ah, that makes sense, thanks
14:27:50 <grache28> I have a function that calls a function that calculates a value (in polonomial time) - I'm having to pipe to other functions, so I'm using an if to see if it's an empty list, if so passing the next function an emply list. If not I'm having to recalculate and give the third attribute of that tuple to the next function. very wasteful since I just calculated it previous step.
14:28:01 <Hafydd> Obviously Rational is not closed under exponentiation, because 2^(1/2) is irrational.
14:28:02 <Cale> `Jake`: The Real typeclass is a bit awkwardly named
14:28:37 <ReinH> grache28: can you show us some code?
14:28:42 <`Jake`> Hafydd: That's true, although I technically didn't ask for it to have a Rational result
14:28:52 <grache28> In c: int x = func(); if (x == 0) return foo; else return x;
14:28:58 <grache28> ReinH: http://lpaste.net/104369
14:29:14 <Cale> `Jake`: The distinction was meant to be real as opposed to complex, and since we don't have a standard computable reals type, Rational got used instead.
14:29:21 <ReinH> grache28: use a let binding or equivalent
14:29:22 <`Jake`> Cale: Ah, I see, thanks
14:29:53 <grache28> ReinH: but will it be a local var that will change ever function call.. or?
14:30:51 <ReinH> grache28: let xs = bt isSol childNode x in case xs of [] -> ...; _ -> ...
14:31:14 <zenzike> I've just announced the ICFP Programming Contest 2014, at http://icfpcontest.org but I'm worried that the DNS might not have updated everywhere: can someone tell me if it's pointing to the 2014 site?
14:31:23 <awestroke> grache28: http://lpaste.net/104369
14:31:24 <ski>   case bt isSol childNode x of [] -> ...; xs -> ..xs..
14:31:38 <ReinH> ski: oh yes that would be better
14:31:54 <ReinH> ski: my brain was on an intermediary step ;)
14:32:19 <ReinH> zenzike: works from my machine
14:32:26 <beanandgone> Cale: I can put z = v
14:32:40 <beanandgone> Cale: this is not the issue I wanted to ask
14:32:46 <awestroke> grache28: hmm.. http://lpaste.net/revision/8910474710039396352
14:32:49 <znutar_> zenzike: yeah getting the 2014 site
14:32:51 <zenzike> ReinH: Excellent, thanks!
14:32:51 <dropdrive> Sorry, could someone give an example of @free w/ lambdabot?
14:32:55 <Cale> beanandgone: yeah, it's just if you make that replacement, your module will compile
14:32:56 <beanandgone> Cale: is there a way to remove first parameter from read function ?
14:32:58 <zenzike> znutar_: cheers :-)
14:33:10 <beanandgone> Cale: well - it compiles as is
14:33:11 <Cale> beanandgone: (there's a stray z which looks like it ought to have been v)
14:33:31 <Cale> Didn't compile for me anyway
14:33:43 <beanandgone> Cale: what GHC are you using?
14:33:49 <Cale> 7.8.2
14:33:58 <Cale> type MVecType z :: * -> *
14:34:00 <Cale> ^^ that z
14:34:03 <ReinH> zenzike: also yay IFCP comp!
14:34:18 <grache28> tks ReinH ski awestroke
14:34:36 <beanandgone> Cale: I'm using GHC 7.6.3 and it compiles...
14:34:43 <Cale> Interesting
14:35:01 <beanandgone> Cale: does it compiles if you set z = v ?
14:35:24 <beanandgone> Cale: i.e. type MVecType v :: * -> * ?
14:36:01 <Cale> yes
14:36:35 <beanandgone> Cale: so the question is - how can I remove first parameter from newMVec and read?
14:37:04 <beanandgone> Cale: I'm ignoring first parameter in instance declarations anyway. This was the only way to compile it
14:37:10 <Cale> You could change the class associated type to a class associated data, perhaps
14:37:39 <Cale> The problem is that class associated types are not necessarily injective -- more than one instance can define the type synonym to be the same thing.
14:37:48 <zenzike> ReinH: I hope you participate!
14:38:01 <Cale> So it may be impossible to infer which types v and a are only knowing that MVecType v a is.
14:38:05 <Cale> what*
14:38:06 <ReinH> zenzike: Last time I participated was 2010. Sounds like I'm due :)
14:38:14 <beanandgone> Cale: oh, I got it now
14:38:34 <zenzike> ReinH: Absolutely :-) We've put a lot of effort into making this one fun and challenging!
14:38:43 <ReinH> zenzike: awesome :)
14:40:01 <silasm> zenzike: what is this? Can I have a link?
14:40:12 <zenzike> http://icfpcontest.org
14:40:32 <silasm> thanks
14:40:34 <beanandgone> Cale: I have another question. Is it possible to return something from newMVec in a way that it is restricted by MVec constraint?
14:40:52 <beanandgone> Cale: I.e. instead of read switch to use mread?
14:41:25 <Cale> Not entirely sure what you mean
14:41:57 <beanandgone> Cale: I have Vec class. It has method "newMVec :: v a -> a -> (MVecType v) a"
14:42:20 <beanandgone> Cale: Vec class also has "read" method which I use in do_it2
14:42:34 <beanandgone> Cale: There is another class MVec which has mread method.
14:43:01 <beanandgone> Cale: Is it possible to returned something from newMVec, so instead of "read" in do_it2 I can use "mread" from MVec class?
14:43:46 <Cale> Well, if whichever type MVecType v is also happens to be an instance of MVec
14:44:25 <Cale> i.e. if you have an instance MVec (MVecType v)
14:44:57 <beanandgone> Cale: I have instances for MVec1, MVec2...
14:45:20 <Cale> I mean, try constraining the type of do_it2 with that
14:45:32 <beanandgone> ok, thanks, I'll try
14:45:34 <Cale> do_it2 :: (Vec v, MVec (MVecType v)) => ...
14:46:00 <Cale> I think you ought to be able to use mread on the result then...
14:46:20 <beanandgone> Could not deduce (MVec v) arising from a use of `mread' from the context (Vec v, MVec (MVecType v))
14:46:20 <beanandgone>  
14:46:56 <Cale> Oh, in that case, you need MVec v instead
14:47:10 <beanandgone> Cale, thanks, I need to leave for 10 mins now
14:48:48 <Kaidelong> I've run into a conundrum with netwire
14:49:17 <Kaidelong> I'm better off not using existential types wrt a particular data structure where I don't care about what inhibition monoid is being used
14:49:56 <Kaidelong> I can just expose functions that attach wires and transform e to () by basically doing something analogous to mapLeft ()
14:50:10 <unsymbol> noob question: i sometimes hear people refer to data types as functors but i'm unsure if the fmap function defined for that instance is the functor. is the fmap function the functor or is the data type itself the functor?
14:50:13 <Kaidelong> but netwire doesn't seem to have any facility to map over inhibition
14:50:37 <Cale> unsymbol: The type constructor
14:50:46 <Kaidelong> unsymbol: in haskell terms fmap is a method provided by the functor instance
14:50:55 <Kaidelong> so you can just call it a "functor method"
14:50:58 <Cale> unsymbol: Well, the type constructor along with the implementation of fmap
14:51:12 <ReinH> unsymbol: a functor is a mapping from objects to objects and arrows to arrows that preserves identity and composition. The object mapping is the type constructor, e.g. Maybe; the arrow mapping is a law-abiding implementation of fmap.
14:51:14 <Cale> e.g. you'd say that Maybe is a functor
14:51:36 <Cale> and implicitly, this means there's an implementation of fmap :: (a -> b) -> (Maybe a -> Maybe b)
14:51:41 <Kaidelong> if you actually want to define what a functor is, it becomes abstract nonsense (something about mapping one category to another)
14:51:58 <ReinH> Kaidelong: (a category homoorphism :)
14:52:17 <unsymbol> i like the abstract version, though! it just feels like the language is a little loose.
14:52:42 <Cale> Well, in the context of Haskell, a functor is a type constructor which has an implementation of fmap (an instance of the Functor class), such that fmap (f . g) = fmap f . fmap g and that fmap id = id
14:52:53 <grache28> this just makes me laugh :) http://lpaste.net/8910474710039396352
14:53:30 <Cale> grache28: why?
14:53:41 <unsymbol> Cale: but in the more general sense it is a mapping between categories i.e. a mapping between pure functions and monadic functions?
14:53:42 <Cale> grache28: There's an extra level of lists
14:53:48 <ReinH> grache28: they are different types :)
14:53:57 <ReinH> [Solucion] ~ [[(Int,Int)]]
14:54:02 <Cale> unsymbol: not i.e.
14:54:06 <Cale> Perhaps e.g.
14:54:12 <grache28> [Char] /= String?
14:54:16 <grache28> errp tks!
14:54:44 <Cale> unsymbol: Are you familiar with the definition of a category?
14:54:49 <unsymbol> Cale: sorry, i'm sloppy but thanks for your replies (and ReinH and Kaidelong).
14:55:05 <Cale> The definition of a functor is not that hard to state if you already know what a category is.
14:55:59 <Cale> If C and D are categories, then a functor F: C -> D consists of two things:
14:56:02 <Cale> 1) a mapping on objects, assigning to each object X in C, some object FX in D
14:56:18 <superH> Is there a function to apply x functions to a monad , something like : [(a->a)] -> m a -> ma
14:56:20 <Cale> 2) a mapping on arrows, assigning to each arrow a: X -> Y in C, some arrow Fa: FX -> FY in D
14:56:52 <ReinH> superH: can you convince ghci that the type you want is valid?
14:57:04 <ReinH> superH: it's a good exercise in non-fuzzy thinking :)
14:57:04 <Cale> such that for any composable arrows a and b, we have F(a . b) = (Fa) . (Fb), and such that for each X in C, we have F(id_X) = id_(FX)
14:58:00 <ReinH> superH: for instance, perhaps you want this:
14:58:02 <ReinH> :t undefined :: Monad m => [(a->a)] -> m a -> m a
14:58:03 <lambdabot> Monad m => [a -> a] -> m a -> m a
14:58:09 <Cale> superH: you mean to an action in some monad, not to the monad itself (which is m)
14:58:16 <ReinH> superH: (you'll notice that the parens are redundant)
14:58:25 <awestroke> :t mapM
14:58:26 <lambdabot> Monad m => (a -> m b) -> [a] -> m [b]
14:58:39 <ReinH> superH: now, notice the type of fmap is close:
14:58:42 <ReinH> :t fmap
14:58:43 <Cale> You probably want to compose the functions together using something like foldr (.) id
14:58:43 <lambdabot> Functor f => (a -> b) -> f a -> f b
14:58:44 <Kaidelong> does anyone with netwire experience know how to do Wire s e m a b -> Wire s () m a b?
14:58:49 <Cale> and then use fmap
14:58:52 <ReinH> superH: except that you have a single (a -> b) instead of a list
14:59:07 <Cale> :t \fs x -> fmap (foldr (.) id fs) x
14:59:08 <lambdabot> Functor f => [b -> b] -> f b -> f b
14:59:13 <ReinH> superH: then you might notice that you can combine functions of type a -> a together:
14:59:17 <Kaidelong> I need to write something that steps the fire, I don't care how it inhibits
14:59:20 <Cale> :t \fs -> fmap (foldr (.) id fs)
14:59:21 <lambdabot> Functor f => [b -> b] -> f b -> f b
14:59:21 <Kaidelong> wire*
14:59:30 <Cale> :t fmap . foldr (.) id
14:59:31 <lambdabot> Functor f => [b -> b] -> f b -> f b
14:59:56 <superH> yeah foldr (.) seem good
15:00:08 <ReinH> Cale: ok yeah you could just tell him to use the Endo monoid :p
15:00:13 <ReinH> I was trying to work up to it
15:00:26 <Kaidelong> foldr (.) is clearer and easier
15:00:29 <Cale> I'd just use foldr :)
15:00:42 <ReinH> Kaidelong: sure, I meant "the concept of an endomorphism monoid" rather than Endo
15:00:58 <awestroke> :t from
15:01:00 <lambdabot> (Profunctor p, Functor f) => AnIso s t a b -> p t (f s) -> p b (f a)
15:02:15 <ReinH> superH: anyway, functions a -> a form a monoid where empty is id and the product is (.), so foldr (.) id is a way to reduce [a -> a] into a -> a by using this monoidal property.
15:05:17 <ReinH> Also `ala' makes newtypes much easier to work with, maybe even easy enough to make `ala Endo foldMap' nicer than `foldr (.) id'.
15:05:37 * ReinH shrugs
15:06:07 <joseph07> :t ala
15:06:09 <lambdabot> (Rewrapped t s, Rewrapped s t) => (Unwrapped s -> s) -> ((Unwrapped t -> t) -> e -> s) -> e -> Unwrapped s
15:06:11 <ReinH> Cale: btw I'm finding Mac Lane's Algebra to be a great introduction to category theory!
15:06:39 <ReinH> joseph07: the type is not very elucidating if you aren't fluent in lens types :)
15:06:39 <Cale> I haven't read that one
15:07:30 <ReinH> Cale: basically his Algebra provides a lot of the maturity necessary to understand CTftWM.
15:07:55 <ReinH>  it's a nice way to get form sets to categories with some interesting pit stops in groups, fields, linear spaces, etc
15:07:58 <ReinH> *from
15:08:02 <Cale> Have you read Awodey's book?
15:08:16 <ReinH> Cale: I'm reading Awodey and CTftWM simultaneously
15:08:26 <ReinH> Cale: I'm actually reading about 8 books on Algebra and CT at the moment
15:08:29 <Cale> hehe
15:08:37 <benzrf> CTftWM?
15:08:45 <ReinH> Usually what happens is I read something in CTftWM that I don't understand and then I go find another book that explains it more simply
15:08:49 <Cale> Categories for the Working Mathematician
15:08:50 <ReinH> Category Theory for the Working Mathematician
15:08:53 <benzrf> oL
15:08:55 <ReinH> oh yes that's the actual title
15:08:58 <ReinH> sorr
15:09:00 <ReinH> y
15:09:07 <awestroke> what's the meaning of Co/Contra in Contravariant/Covariant? and variant for that matter
15:09:21 <Cale> awestroke: With regard to functors?
15:09:25 <awestroke> Cale: yes
15:09:38 <Cale> awestroke: A contravariant functor is just a functor from the opposite category
15:09:50 <Cale> i.e. a contravariant functor C -> D is just a functor C^op -> D
15:09:59 <Cale> or equivalently C -> D^op
15:10:03 <awestroke> ^op?
15:10:19 <Cale> C^op being the category obtained from C by reversing the direction of all the arrows
15:10:21 <ReinH> awestroke: the opposite category is a category with the arrows and order of composition "turned around".
15:10:58 <awestroke> where can I read more about this?
15:11:08 <ReinH> awestroke: the books that I've been mentioning :)
15:11:09 <Cale> A covariant functor is just the ordinary sort of functor, but with emphasis that you mean as opposed to contravariant
15:11:25 <Cale> Yeah, I recommend starting with Awodey's Category Theory
15:11:27 <awestroke> ReinH: Which one first?
15:11:44 <awestroke> Cale: alright thanks
15:11:48 <Cale> awestroke: Sent you a link in PM :)
15:12:00 <ReinH> awestroke: All of them :) Depends on how mathematically mature you are in other areas.
15:12:04 <ReinH> Cale: which link?
15:12:27 <ReinH> I like links about learning algebra and CT too :)
15:12:35 <ReinH> Cale: oh nice :)
15:12:51 <awestroke> ReinH: single variable calculus, discrete mathematics, statistics.. that enough?
15:13:23 <benzrf> man i keep being reminded that i dont actually have any appreciable knowledge of math
15:13:26 <benzrf> ;-;
15:14:08 <ReinH> Cale: ooh Survey of Modern Algebra for $9 http://www.amazon.com/Survey-Modern-Algebra-Revised-Edition/dp/B000XYR7EK/ref=sr_1_5?ie=UTF8&qid=1400623959&sr=8-5&keywords=Mac+Lane+Algebra
15:14:10 <ReinH> grabbing that
15:14:13 <zomg> benzrf: Math is for nerds!
15:14:56 <ReinH> zomg: we are nerds.
15:15:14 <zomg> Wait this is not #football ?
15:15:16 <zomg> ;)
15:15:33 <joseph07> Took algebraic structures in college but we only covered group
15:15:34 <ReinH> awestroke: I think this is now my favorite introduction to category theory. It just also happens to teach you abstract algebra at the same time. http://www.amazon.com/Algebra-Chelsea-Publishing-Saunders-Lane/dp/0821816462/ref=sr_1_1?ie=UTF8&qid=1400623959&sr=8-1&keywords=Mac+Lane+Algebra
15:15:41 <benzrf> jesus dick im tired
15:15:42 <Cale> As influential and famous as it is, CftWM is sort of an awkward book to learn from, sadly.
15:15:58 <Cale> It does cover a bit more ground than Awodey does though.
15:16:02 <benzrf> this is making it hard to concentrate
15:16:13 <djahandarie> ReinH, Survey is a little outdated btw. But that's not too much of an issue since it's mostly introductory.
15:16:24 <ReinH> Cale: My process of reading CftWM and then reading Awodey when I don't understand something has been very successful :)
15:17:07 <ReinH> djahandarie: That's fine :)
15:17:28 <ReinH> Mac Lane's Algebra is very gentle compared to CftWM
15:17:45 <ReinH> Cale: yeah, Awodey doesn't really cover monoidal cats for instance.
15:18:18 <hiptobecubic> ReinH, I don't blame him. Have you ever tried to append two cats?
15:18:21 <ReinH> These are cats that you can append to each other with an identity cat, of course. I don't suggest trying that on actual cats. And especially do not try to reassociate your cat chain.
15:18:29 <ReinH> hiptobecubic: great minds?
15:19:10 <awestroke> ReinH: thanks, grabbed Algebra
15:19:22 <ReinH> awestroke: win!
15:20:58 <ReinH> awestroke: the downside of introducing cats as an abstraction over sets is that this leads to the wrong intuition that all cats are conrete (have objects which are sets). He fixes that pretty quickly in CftWM though, and I think it's a pretty useful intuition for dealing with many cats even if it's wrong.
15:21:10 <ReinH> *concrete
15:22:39 <joseph07> searched "subject: Category Theory" for my local library. Solitary hit was Same Same (http://www.amazon.com/Same-Marthe-Jocelyn/dp/088776987X)
15:23:21 <askalero> Does anybody has an idea how to save memory? Using State.Strict is even worse. http://lpaste.net/4066861080398266368
15:26:09 <jfischoff> try forcing the evaluation of things like max' + 1
15:26:31 <Lethalman> :t max'
15:26:33 <lambdabot>     Not in scope: ‘max'’
15:26:33 <lambdabot>     Perhaps you meant ‘max’ (imported from Data.Ord)
15:26:38 <ReinH> askalero: Use a data type with strictness annotations instead of tuples of tuples
15:27:17 <jfischoff> askalero: you can also use bang patterns (!max’, !map)
15:27:53 <jfischoff> this will have the same effect as ReinH suggestion and will force the evaluation of max’
15:28:07 <ReinH> jfischoff: right, but I would prefer data Triple = Triple !a !b !c so you have no chance of forgetting ;)
15:28:19 <ReinH> (or something iso to same with a meaningful name)
15:28:41 <jfischoff> each to their own ;)
15:29:09 <jfischoff> also use a DList instead of map’ ++
15:29:11 <ReinH> jfischoff: I find tuples, and tuples of tuples especially, to be so difficult to get correctly wrt strictness that I try not to as much as possible.
15:29:37 <jfischoff> yeah if I have a tuple of tuples I’m probably doing it wrong
15:29:57 <jfischoff> or a tuple with element count > 2
15:29:59 <ReinH> jfischoff: I try to make things easy on my brain :)
15:30:09 * jfischoff nods
15:30:15 <askalero> ok i'll try thanks
15:30:39 <ReinH> I'm smart enough to know that my brain is dumb and compensate for it. Sometimes.
15:31:15 <jfischoff> Yes. I use Haskell because I am smart enough to know I’m too dumb for PHP
15:31:26 <ReinH> Also I'm not actually a dualist but blaming things on my brain (as if I am not actually my brain) helps preserve my ego ;)
15:32:30 <jfischoff> ha
15:32:59 <ReinH> Oh great Dock has completely shit the bed and I have to restart.
15:39:08 <luismaa> hi, somebody can tell me what is : in a constructor data definition?, for example.  data expr = Int :< Int
15:39:31 <jle`> luismaa: it's just an infix operator constructor
15:39:46 <jle`> it's the same as data Expr = (:<) Int Int
15:40:02 <luismaa> oh, thanks.
15:40:12 <jle`> the difference between constructor operators and normal operators is that constructor operators have to begin with a colon :
15:40:27 <jle`> like how normal constructions begin with a capital letter (Just), and normal functions begein with lowercase letters
15:41:01 <luismaa> but I can't use it before a letter, no?
15:41:17 <jle`> yeah, just like normal operator rules
15:41:21 <ReinH> luismaa: you can use it with chars that are valid as an operator, so no
15:41:21 <jle`> for normal functions
15:41:28 <ReinH> with symbols, basically.
15:41:46 <luismaa> data e = :Not Bool
15:41:55 <luismaa> is error?
15:42:06 <ReinH> luismaa: yes, for a number of reasons :)
15:42:12 <luismaa> ok
15:42:23 <luismaa> thanks
15:42:24 <jle`> just like you can
15:42:26 <jle`> 't do
15:42:45 <jle`> > let x <not> y = x+y in 7 <not> 8
15:42:46 <lambdabot>  <hint>:1:5: Parse error in pattern: x < not
15:42:59 <jle`> > let x <^> y = x+y in 7 <^> 8
15:43:01 <lambdabot>  15
15:43:10 <jle`> you can't use letters in operators
15:43:52 <jle`> unfortunate though because i've always wanted to do cute ascii stuff in my operators :/
15:44:34 <benzrf> hmm
15:44:46 <joelteon> :t (^_^)
15:44:47 <lambdabot> parse error on input ‘)’
15:44:53 <joelteon> oh right, you can't put _ in there either
15:45:07 <benzrf> l-lame
15:45:20 <benzrf> > (^-^)
15:45:22 <lambdabot>  Not in scope: ‘^-^’
15:45:22 <lambdabot>  Perhaps you meant ‘^^’ (imported from Prelude)
15:45:25 <jle`> heh
15:46:16 <benzrf> @let a \^-^/ b = a ++ " \^-^/ " ++ b
15:46:17 <lambdabot>  Parse failed: Illegal control character
15:46:19 <acowley> Anyone know if Robin Kay can be found in these parts?
15:46:26 <benzrf> oh crud
15:46:29 <benzrf> @let a `^-^/ b = a ++ " \^-^/ " ++ b
15:46:29 <lambdabot>  Parse failed: Parse error: ^-^/
15:46:33 <benzrf> @let a ^-^/ b = a ++ " \^-^/ " ++ b
15:46:33 <lambdabot>  Parse failed: Illegal control character
15:46:35 <benzrf> :{
15:46:42 <benzrf> oh wait duhh
15:46:47 <benzrf> @let a \^-^/ b = a ++ " \\^-^/ " ++ b
15:46:49 <lambdabot>  Defined.
15:46:51 <benzrf> ha
15:46:54 <jle`> > let (^-^) = True in if (^-^) then "Hooray!" else "Boo!"
15:46:56 <lambdabot>  "Hooray!"
15:47:04 <benzrf> > "hello!" \^-^/ "woohoo!"
15:47:06 <lambdabot>  "hello! \\^-^/ woohoo!"
15:47:14 <jle`> heh
15:49:22 <jle`> > let (^-^) = ("(^-^)"++).cycle.head in (^-^)"~>"
15:49:24 <lambdabot>  Couldn't match type ‘GHC.Types.Char’ with ‘[GHC.Types.Char]’
15:49:24 <lambdabot>  Expected type: [[GHC.Types.Char]]
15:49:24 <lambdabot>    Actual type: [GHC.Types.Char]
15:49:44 <jle`> > let (^-^) = ("(^-^)"++).repeat.head in (^-^)"~>"
15:49:46 <lambdabot>  "(^-^)~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~...
15:49:51 <benzrf> lol
15:50:02 <ReinH> jle`: stahp :p
15:50:08 <jle`> ok :|
15:50:16 <benzrf> dont listen to them ReinH
15:50:20 <benzrf> keep going!!!
15:50:30 <jle`> nah its cool
15:54:25 <pejo> Is the ghc-api the only option for getting immediate cpp support?
15:55:28 <pejo> There's an old ticket on the haskell-src-exts trac, but it hasn't been changed in 4 years. Haskell-src-exts obviously knows about the CPP extension, but I just get parse errors for any source using it.
15:55:43 <jfischoff> there is a package to help you
15:55:53 <jfischoff> I think it Haskell-src-exts-cpp
15:57:03 <jfischoff> pejo: http://hackage.haskell.org/package/hse-cpp-0.1/docs/Language-Haskell-Exts-Annotated-CPP.html
15:58:00 <benzrf> what the fuck is a Market
15:58:04 <benzrf> :k Market
15:58:05 <lambdabot> Not in scope: type constructor or class ‘Market’
15:59:11 <acowley> Has anyone here used hsqml?
16:00:10 <acowley> I think I'm going to stick to C++
16:00:42 <benzrf> awruef: dont do ThatOtherPerson
16:00:45 <benzrf> *that
16:00:46 <benzrf> wow
16:00:48 <benzrf> bad tabcomplete
16:00:52 <ThatOtherPerson> Yes, don't
16:00:57 <ThatOtherPerson> Bad idea
16:01:02 <ThatOtherPerson> Never do ThatOtherPerson
16:01:46 <ThatOtherPerson> awruef: You're going to stick to C++ for what?
16:03:10 <awruef> well i'm going to stick to c++ for misc system hacking and os / driver development
16:03:11 <pejo> jfischoff, ooo,  thank you. I was hoping I would find something called haskell-src-exts-something
16:03:18 <awruef> but i'm not sure what haskell really has to offer in that department
16:03:39 <bobajett> I have some dumb questions trying to understand numeric types. truncate :: (Integral b, RealFrac a) => a -> b. Does this mean that truncate returns a type "b", which since it has a class constraint of Integral, could only be either Int or Integer?
16:04:54 <jfischoff> bobajett: Those might be the only two instances in Prelude but there can other instances in other libraries
16:04:59 <jfischoff> in fact, there are
16:05:37 <jfischoff> ?info Integral
16:05:37 <lambdabot> Integral
16:05:40 <jfischoff> heh
16:05:59 <ReinH> bobajett: yes, that is: for all a such that a is an instance of RealFrac and for all b such that b is an instance of Integral
16:06:18 <bobajett> ok. Im trying to write a function: aboutHalf n = truncate ( n / 2)
16:06:24 <pejo> jfischoff, any experience using hse-cpp, or know if it "just works"?
16:06:50 <jfischoff> no experience, but the author’s author packages work well
16:07:06 <ReinH> bobajett: Haskell should be able to infer the type of aboutHalf
16:07:37 <ski> @instances Integral
16:07:38 <lambdabot> Int, Integer
16:07:45 <Cale> It'll have the same type as truncate deoes
16:07:47 <Cale> does*
16:08:04 <ski> @instances-importing Data.Int Integral
16:08:05 <lambdabot> Int, Int16, Int32, Int64, Int8, Integer
16:08:09 <bobajett> ReinH: but I would like to supply and get back only Ints, and I don't understand how to write that type signature. If I do aboutHalf :: Int -> Int. It doesn't like it.
16:08:15 <jfischoff> ski++
16:08:22 * ski winces
16:08:36 <ReinH> bobajett: why would the argument be an Int
16:08:42 <Cale> bobajett: You'll have to convert to some type on which (/) and truncate are defined first
16:09:03 <Cale> Note that (/) alone also doesn't work for Int
16:09:25 <ReinH> bobajett: you can instantiate it to aboutHalf :: RealFrac a => a -> Int
16:09:32 <darthdeus> guys what is the preferred indentation mode in emacs? I've tried all three provided by haskell-mode, but they seem to be all formatting differently than what i see online, and than the one in vim
16:09:38 <ReinH> bobajett: oh, supply *and* get back an Int
16:09:58 <bobajett> ReinH: :-) yes. arg is an Int, and return value should be an Int
16:10:00 <Cale> bobajett: You can convert an Int to some type which would be appropriate, such as Double
16:10:51 <ReinH> bobajett: note that div will already do this, so perhaps aboutHalf = (`div` 2)
16:11:50 <ReinH> darthdeus: indentation in vim is largely broken, I'm sorry to say as a vim user :/
16:12:06 <ReinH> so I wouldn't treat it as anything close to canonical
16:12:26 <darthdeus> ReinH: yeah I'm kinda doing it manually there, but thought it would be better in emacs ... but it doesn't seem to be
16:12:32 <Cale> Note however:
16:12:39 <Cale> > truncate (-5 / 2)
16:12:41 <lambdabot>  -2
16:12:46 <ReinH> Cale: ah good point
16:12:48 <Cale> > (-5) `div` 2
16:12:49 <lambdabot>  -3
16:12:52 <bobajett> ReinH: yup, Im aware of `div`, my confusion is about type signatures, specifically if truncate says its returning "Integral b", then why can't I say aboutHalf :: Int -> Int
16:12:59 * hackagebot ConstraintKinds 1.3.0 - Repackages standard type classes with the ConstraintKinds extension  http://hackage.haskell.org/package/ConstraintKinds-1.3.0 (MikeIzbicki)
16:13:05 <ReinH> bobajett: because Int isn't *also* a RealFrac
16:13:21 <Cale> bobajett: Because Int isn't an instance of RealFrac
16:13:29 <ReinH> bobajett: and you need an instance of RealFrac for the type replacing the sa
16:13:30 <ReinH> the a
16:13:32 <bobajett> ahhh!
16:13:56 <bobajett> Cale: (I wasn't ignoring you, I had a background thread trying to process your suggestions while responding to ReinH :-) )
16:14:24 <ReinH> bobajett: go fork yourself
16:14:57 <bobajett> Im pre-forked
16:16:02 <darthdeus> ReinH: btw I wanted to ask, in this video, what is the autocomplete plugin you're using? https://www.youtube.com/watch?v=6KkF5-_erns
16:16:13 <ReinH> darthdeus: neco-ghc iirc
16:16:24 <ReinH> Anyway that's what I'm using now
16:16:36 <darthdeus> with neocomplete.vim?
16:16:39 <ReinH> https://github.com/eagletmt/neco-ghc
16:16:41 <ReinH> Yep!
16:16:46 <darthdeus> or neocomplcache.vim? :)
16:16:57 <ReinH> Whichever one is the one he wrote to replace the previous one :)
16:16:59 <jfischoff> has anyone gotten hdevtools working for 7.8?
16:17:09 <darthdeus> hehe, i'll give it a try
16:17:14 <darthdeus> thanks
16:17:38 <jfischoff> I’m trying to enter catch up with all these modern Haskell users and their fancy tools
16:18:01 <darthdeus> jfischoff: there's a PR that works, but it doesn't work well with cabal
16:18:09 <jfischoff> I see
16:18:19 <darthdeus> https://github.com/bitc/hdevtools/pull/28
16:18:23 <ReinH> jfischoff: do you vim?
16:18:26 <darthdeus> i've built this locally and it works on 7.8
16:18:37 <jfischoff> ReinH: no I use TextMate
16:18:43 <ReinH> jfischoff: oh well there you go :p
16:18:44 <jfischoff> and that
16:18:48 <jfischoff> is it
16:18:48 <darthdeus> but then i switched to ghc-mod, since it can work with cabal ... but ghc-mod is slow with syntastic :(
16:19:01 <ReinH> I'm switching from macvim back to vim in tmux and enjoying it
16:19:05 <darthdeus> so now i'm writing a server mode for ghc-mod so that it's more usable in vim
16:19:18 <darthdeus> ReinH: do you use syntastic?
16:19:20 <ReinH> darthdeus: yeah, it's kind of a ghetto over there in vim flymake-like land :(
16:19:35 <ReinH> yeah, but unhappily
16:19:48 <ReinH> syntastic is great, ghc-mod and hdevtools both seem broken atm :/
16:19:58 <darthdeus> vim is what is broken1
16:19:59 <darthdeus> !
16:20:07 <ReinH> Eh, I don't actually think so.
16:20:24 <darthdeus> if it could do long running processes syntastic would be great :)
16:20:37 <ReinH> darthdeus: vim can do async
16:20:48 <darthdeus> only with hacks
16:20:51 <ReinH> A syntastic built on top of tpope's Dispatch would probably be good
16:20:58 <ReinH> since he's done the hard work for us
16:21:23 <[swift]> IMO neovim is the way to go there
16:21:38 <[swift]> i switched to emacs over this issue
16:21:39 <ReinH> [swift]: is neovim actually a thing you can use yet?
16:21:52 <[swift]> ReinH: yeah, but it doesn't have most of the new features yet
16:22:00 <darthdeus> sort of, it has YouCompleteMe and some other things ported, but it doesn't have it all
16:22:30 <[swift]> but really, neovim is obviously the right approach long term
16:22:37 <ReinH> I use a lot of vim so every vimlike thing I have ever tried always leaks in unacceptable ways for me :(
16:22:45 <ReinH> [swift]: I think I agree with that though.
16:22:55 <darthdeus> +1
16:22:56 <benzrf> neovim?
16:23:08 <[swift]> benzrf: https://github.com/neovim/neovim
16:23:09 <ReinH> [swift]: Honestly building dispatch and unite.vim in would be a huge step forward.
16:23:25 <darthdeus> actually it seems they've finished the job control async thingy if you look at the readme
16:23:30 <ReinH> cool
16:23:43 <hiptobecubic> ReinH, i'd rather not see them start internalizing plugins
16:24:02 <[swift]> especially not unite =)
16:24:06 <ReinH> hiptobecubic: generally I agree, but those plugins add very foundational capabilities
16:24:10 <ReinH> that are hard to do as plugins
16:24:22 <ReinH> you can implement about 20 other plugins trivially using unite.vim out of the box
16:24:28 <[swift]> it's great, i use the emacs equivalent all the time, but it seems like something that needs to evolve too fast to be built in
16:24:50 <[swift]> (the emacs equivalent being helm)
16:24:51 <hiptobecubic> and if anyone comes up with a great change to unite.vim, you're boned until the neovim team catches up
16:24:51 <darthdeus> btw when is the next haskellcast coming out? :)
16:25:13 <ReinH> darthdeus: we recorded last Sunday so this week or next.
16:25:43 <darthdeus> awesome! i've listened to the past episodes like 2-3 times each
16:25:51 <ReinH> hiptobecubic: I see what you're saying, but at least there is functionality that unite.vim his forced to hack into vim that ought to be available for plugins to use in neovim
16:26:02 <ReinH> s/his/is
16:26:22 <ReinH> darthdeus: awesome :)
16:27:46 <pejo> Is hdevtools as fast as the github page says? I find loading stuff in ghci terribly slow.
16:28:24 <jfischoff> pejo: is the slow down is template haskell?
16:28:44 <[swift]> ReinH: that sounds like the right approach - improve the vim platform so unite.vim doesn't need to hack around its deficiencies, but leave the user-facing unite stuff as a plugin
16:28:57 <ReinH> [swift]: yep
16:29:28 <pejo> jfischoff, hm, maybe a little. It's just a tiny project. Maybe I'm impatient
16:30:20 <jfischoff> I have ghci to be slow if I have a 2000+ line module of all types and tons of TH
16:30:38 <jfischoff> spliting out things to seperate files could help
16:31:03 <jfischoff> could make it worse I guess to
16:31:20 <pejo> jfischoff, oh, have around 100 files already. Haven't checked why it's slow though, but maybe I should look into it.
16:31:35 <jfischoff> It might be one file
16:32:05 <jfischoff> with that many files, the topology of dependencies can affect the loading time
16:32:09 <pejo> jfischoff, wouldn't the others load quickly one the slow file was loaded?
16:32:20 <darthdeus> pejo: i've found hdevtools to be much faster than ghc-mod unfortunately :\
16:32:28 <jfischoff> I would think so
16:32:58 <pejo> darthdeus, ok. ghc-mod is another thing that isn't working well for me.
16:33:08 <darthdeus> pejo: any particular issues with it?
16:34:10 <pejo> darthdeus, it underlines the entire buffer with squiggly red marks and takes forever to recover from it, for one thing.
16:36:34 <darthdeus> pejo: hmm :\ i wish i could use hdevtools but it doesn't seem to be loading extensions from .cabal files
16:38:52 <pejo> darthdeus, heh, that could be another showstopper, yeah.
16:40:44 <darthdeus> is it wise to pull conduit + conduit-extra for a tiny domain socket app?
16:52:55 <pejo> jfischoff, I got past the first (trivial) file with cpp, thanks!
16:53:12 <jfischoff> \o/
17:07:03 <CatpainHayasho> Anyone have any idea why cabal might say ‘cabal: Could not resolve dependencies:’, but give no dependencies?
17:07:23 <CatpainHayasho> (this being in a sandbox)
17:08:26 <acowley> Fresh sandbox?
17:08:31 <acowley> And what cabal command?
17:08:36 <td123> CatpainHayasho: are you running cabal install --only-dependencies?
17:08:41 <CatpainHayasho> yus.
17:08:49 <CatpainHayasho> inb4 that doesn't work =p
17:08:53 <td123> CatpainHayasho: did you try cabal --verbose?
17:09:03 <td123> it might tell you something more
17:09:34 <CatpainHayasho> aha
17:09:42 <CatpainHayasho> I just upgraded cabal, and now it's telling me something
17:10:46 <CatpainHayasho> HTTP was a bit broken =p
17:11:08 <CatpainHayasho> basically I tried to upgrade cabal in the first instance, but did so in the sandbox, which wasn't very effective
17:13:09 <CatpainHayasho> oh boy, now it's broken again >=D
17:17:05 <CatpainHayasho> td123: Turns out if I try to install recursion-schemes or free, it just goes utterly silent, not even --verbose gives me any information =/
17:18:17 <benzrf> Choice is like Arrow on sum types?
17:23:46 <CatpainHayasho> what the…
17:23:52 <CatpainHayasho> transformers-compat won't install =/
17:25:10 <glguy_> CatpainHayasho: cabal install -ftransformers3 transformers-compat
17:25:18 <glguy_> assuming your GHC comes with transformers-0.3.0.0
17:25:43 <CatpainHayasho> hmm, removing the sandbox works, but then I find out that after all this recursion-schemes won't compile on ghc7.8.2!
17:26:01 <CatpainHayasho> oh my days
17:27:37 <CatpainHayasho> at least there's a patch out on it
17:41:08 <colin_> Howdy, folks.
17:52:54 <halvorg> Hm, cabal update doesn't install the latest version of OpenGL on hackage. It's only two days old though, does it take a while for cabal to get up to speed?
17:53:23 <saml_> cabal update updates db
17:54:42 <halvorg> Oh, so I have to manually update to latest version by installing again?
17:54:58 <sm> no, just "cabal update"
17:56:32 <sm> or if you already did that, try specifying the version you want, perhaps it will tell more ("cabal install OpenGL-2.9.2.0")
17:57:20 <pavonia> Has anyone an example on how to call a function loaded by Win32's loadLibrary/getProcAddress? I have the Ptr a but I don't know what to do with it to get the function's result
18:04:34 <halvorg> http://lpaste.net/104375 so this means one of my libraries depend on a version of OpenGL that I no longer use yeah?
18:04:43 <halvorg> it doesn't matter that the types are equivalent?
18:05:58 <geekosaur> it doesn't matter, no, because the real problem is that you will have both versions linked into your program and. provided the program links at all, if you pass something created by one to the other you will probably get a core dump
18:06:44 <geekosaur> also ghc does cross-module inlining, meaning even trivial changes can break the binary interface enough to cause weird runtime errors
18:07:36 <geekosaur> (or worse, silently incorrect behavior)
18:07:42 <halvorg> I see, thanks
18:08:51 <halvorg> reinstalling the lib worked after unregistering my old version.
18:15:48 <Kaidelong> is there a newtype wrapper for getting the monoid morphism for an applicative functor?]
18:19:50 <Kaidelong> it doesn't look like it
18:25:51 <Kaidelong> http://lpaste.net/104382
18:26:11 <Kaidelong> attn djahandarie
18:28:26 <Kaidelong> that should be MonoidMorphism a t
18:28:28 <Kaidelong> but w/e
18:29:18 <Kaidelong> oh right lpaste lets me edit, fixed
18:30:04 <heatsink> Is it conventional to use 't' for monoids?
18:30:27 <Kaidelong> no
18:30:42 <Kaidelong> I just like using t, u, v for types
18:30:56 <heatsink> kay
18:34:28 <Kaidelong> oh Newtype should also probably be aware of TypeCompose
18:34:35 <Kaidelong> I'll add that in there while I'm at it then
18:34:45 <augur> jonsterling: did you manage to find what bob was talking about?
18:35:13 <heatsink> Huh, what is this Newtype class?
18:35:43 <Kaidelong> it's a very useful library that allows you do things like (let's see if lambdabot has this)
18:35:51 <Kaidelong> > ala Sum [1..10]
18:35:54 <lambdabot>  Couldn't match expected type ‘(Control.Lens.Wrapped.Unwrapped
18:35:54 <lambdabot>                                   (Data.Monoid.Sum b)
18:35:54 <lambdabot>                                 -> Data.Monoid.Sum b)
18:35:54 <lambdabot>                                -> e -> Data.Monoid.Sum b1’
18:35:54 <lambdabot>              with actual type ‘[t0]’
18:35:56 <Kaidelong> err
18:36:04 <Kaidelong> > ala Sum mappend [1..10]
18:36:05 <lambdabot>  Couldn't match type ‘Data.Monoid.Sum b1’
18:36:05 <lambdabot>                with ‘Control.Lens.Wrapped.Unwrapped (Data.Monoid.Sum b)
18:36:06 <lambdabot>                      -> Data.Monoid.Sum b’
18:36:06 <lambdabot>  Expected type: (Control.Lens.Wrapped.Unwrapped (Data.Monoid.Sum b)
18:36:06 <lambdabot>                  -> Data.Monoid.Sum b)
18:36:19 <heatsink> Do things like generate large error messages? ;)
18:36:44 <heatsink> :t ala
18:36:45 <lambdabot> (Rewrapped t s, Rewrapped s t) => (Unwrapped s -> s) -> ((Unwrapped t -> t) -> e -> s) -> e -> Unwrapped s
18:37:10 <Kaidelong> Okay it's importing a different ala from the one in Control.Newtype
18:37:17 <Kaidelong> http://hackage.haskell.org/package/newtype-0.2/docs/Control-Newtype.html
18:41:09 <Or1> Anyone interested? http://www.wired.com/2014/05/higgs-boson-contest/
18:41:45 <StoneCypher> not at $7,000
18:42:10 <Or1> was surprised at the price too.
18:42:24 <Or1> prize*
18:42:46 <StoneCypher> besides the netflix prize dataset is more fun to me
18:43:19 <Or1> how long ago was that?
18:43:25 <StoneCypher> like six years i think
18:43:39 <Or1> yea, I wasn't interested in programming then.
18:43:53 <StoneCypher> 2007 - 2009, says the internet
18:44:00 <StoneCypher> oh
18:44:01 <StoneCypher> 2006
18:44:02 <Or1> you win anything?
18:44:04 <StoneCypher> no
18:44:28 <Or1> did you use Haskell?
18:44:29 <StoneCypher> i did very well given my training in my opinion, but no, the prize went to a big ass team of professionals and professors
18:44:33 <StoneCypher> no, i barely speak haskell
18:44:43 <StoneCypher> i'm probably going to spend my first significant time on it next week
18:45:10 <Or1> haha, yea I remembered that too, teams merged towards the deadline
18:45:37 <jonsterling> augur: the part of his book he referenced did not satisfy my curiosity... I plan to email him to get more details.
18:46:56 <augur> jonsterling: im just going to tweet him for clarification. it really ought to be a public convo
18:47:07 <pavonia> When I include a header file from a .hsc file, hsc2hs complaines about the following: http://lpaste.net/104388 Any ideas what's the problem here?
18:47:31 <jonsterling> augur: he's a lot less helpful and constructive on twitter. Also hard to give good answers in 140 chars.
18:48:11 <augur> then he can write a tweetlonger or a blogpost
18:49:02 <jonsterling> Certainly he has a backlog of blogposts forthcoming. I'd like an answer sooner!
18:49:32 <Or1> augur: Whom are you guys talking about? I'd like to bookmark his/her stuff
18:50:01 <augur> who indeed
18:50:03 <augur> bob harper!
18:50:10 <augur> @existentialtype on twitter
18:50:10 <lambdabot> Unknown command, try @list
18:50:39 <Or1> cool, thanks :)
18:52:14 <RyanGlScott> Haskell has a Handle data type. There's also a HANDLE type in System.Win32.Types. Is there an easy way to convert a HANDLE to a Handle?
18:57:06 <RyanGlScott> Of from a Handle to a HANDLE, I suppose.
18:58:36 <StoneCypher> Or1: aaaaaaaaaaaaaaaaaaaaand now i want to make another annealer
18:59:42 * StoneCypher data-get
19:00:46 <pavonia> Any ideas about my hsc2hs problem?
19:02:15 <Or1> StoneCypher: What's that?
19:02:55 <StoneCypher> Or1: what i build isn't strictly an annealer, and i'm going to use a lot of words in ways that traditionally make haskell people go rahr, but
19:03:08 <StoneCypher> basically it's a cheap knockoff of breeding as hill climbing
19:03:14 * hackagebot linebreak 0.1.0.3 - breaks strings to fit width  http://hackage.haskell.org/package/linebreak-0.1.0.3 (fffaaa)
19:03:27 <StoneCypher> except also you let inferiors survive every so often to help get out of local maxima and other crap like that
19:03:37 <StoneCypher> it's all very d20
19:03:45 <StoneCypher> machine learning thac0
19:04:09 <heatsink> pavonia: As far as I can tell, it means that the header files defining BYTE and PVK_TO_BIT weren't included
19:04:11 <Or1> sounds absolutely complicated to me.  Would it be on github?
19:04:27 <StoneCypher> i guess i could write one and put it u
19:04:34 <StoneCypher> i mean it's really not complicated
19:04:36 <StoneCypher> like
19:04:43 <pavonia> heatsink: Oh, okay
19:04:51 <StoneCypher> suppose you want to make a chess game opponent without actually thinking about chess at all
19:04:58 <Or1> k
19:05:02 <StoneCypher> like maybe you're just allergic to giving a fuck about pawns or whatever (i def am)
19:05:19 <StoneCypher> and yet here's this big pile of cash if you can crank out a good chess playing alg
19:05:21 <StoneCypher> what do you do?
19:05:21 <StoneCypher> well
19:05:40 <StoneCypher> one thing you could do is just implement a black box around a function that returns a quality-of-this-board-state as a real
19:05:57 <StoneCypher> and then do a simple bounded tree search on what that function says, taking its value negatively for opponents' turns
19:05:59 <StoneCypher> does that make sense?
19:06:12 <Or1> a bit better now yes.
19:06:14 <StoneCypher> oh and you also need a function that returns all the legal next board states from this state
19:06:19 <StoneCypher> ok cool so
19:06:28 <StoneCypher> here's what i would do to magic together that black box function without even slightly thinking about it
19:06:40 <StoneCypher> 1) make a bunch of neural networks and wire them at random, let's say 256 of them
19:07:10 <StoneCypher> 2) make their input layer the chess board state's size, the output layer a single node, and put two hidden layers of a little larger than input layer size
19:07:19 <StoneCypher> 3) just totally fill them with lies and rand()
19:07:28 <Or1> k
19:07:30 <pavonia> heatsink: Thank you, that fixed it :)
19:07:35 <heatsink> yey
19:07:40 <StoneCypher> 4) actually put them to work evaluating chess states.  they're all going to be terrible, but because they're random, some will be slightly worse than others
19:07:46 <StoneCypher> 5) murder the bottom performing half
19:08:05 <StoneCypher> 6) "breed" the remainder by making a new one with two "parents" and coin flipping each connection by inheritance, with a very low rate of new values as "mutation"
19:08:16 <StoneCypher> 7) more fight to the death!
19:08:22 <StoneCypher> 8) go have a beer, smoke a bowl, go out to dinner
19:08:26 <StoneCypher> 9) come back, chess is done
19:08:29 <Or1> When are you going to finish this?
19:08:35 <StoneCypher> like
19:08:36 <Rarrikins> More!
19:08:37 <StoneCypher> i make these all the time
19:08:47 <Or1> ah!
19:08:59 <StoneCypher> if you want to pick a game for which the board state expander isn't a pain in the ass, we can go make an irc channel and make one together right now, if you want
19:08:59 <Or1> I'd love to see the code on github please.
19:09:02 <StoneCypher> takes like two ours
19:09:13 <StoneCypher> then we could put the results on github
19:09:14 <StoneCypher> oh wait
19:09:16 <StoneCypher> i do have one on github
19:09:35 <StoneCypher> the code is god-awful because 1) i was super drunk and answering the dare "you can't make one of these drunk" and 2) it's javascript
19:09:46 <Or1> I'm in, but dude I just started reading "Learn Haskell for the Greater Good"
19:09:53 <StoneCypher> yeah so let's not do it in haskell?
19:10:09 <StoneCypher> this is basically a mutability furnace
19:10:16 <StoneCypher> haskell is making the do not want sound as hard as it can
19:10:27 <Or1> your call.
19:10:35 <StoneCypher> also neither of us are good at haskell
19:10:44 <Rarrikins> But muh monads :(
19:10:48 <StoneCypher> /join #crapannealer
19:10:53 <Or1> ok.
19:11:26 <StoneCypher> Rarrikins: yeah i have not yet gotten a coherent explanation of monads which don't require me to 1) already know the rest of haskell, 2) accept meanings of words that don't fly anywhere else, 3) is built on tangible examples instead of random bs, and 4) isn't basically a math book
19:11:50 <StoneCypher> so i don't know what a monad is, all i know is every time i pick something at random and accuse it of being a monad i have around a 70% chance of being right
19:12:26 <StoneCypher> and it's like, you can show a haskell person how to explain something from another language, and it's like water off a duck's back
19:19:52 <roboguy_> StoneCypher: well, monads aren't really the best place to start learning
19:24:24 <Kaidelong> I'm not sure how useful it is to learn them in the first place
19:25:28 <ReinH> StoneCypher: Wadler's paper is actually pretty nice
19:25:29 <Kaidelong> what monads are about is essentially how list comprehensions are "deeply related" to do notation but when you're just starting you are best off just considering different monads to be unrelated and just accepting that they manage with just return and >>= magically
19:25:48 <coppro> especially the list monad
19:26:14 <coppro> I recommend not trying to understand the list monad until you are comfortable coding
19:26:19 <Kaidelong> (if you learned Prolog it's much easier to see how the list monad relates to things like IO)
19:26:31 <Welkin> "semi-colon in imperative languages is a monad!"
19:26:36 <Kaidelong> (cause prolog is basically programming inside of an improved list monad)
19:26:53 <Welkin> "monads are like unix pipes!"
19:26:58 <Welkin> I've heard plenty more
19:26:59 <roboguy_> coppro: the list monad is just (:[]) and concatMap though
19:27:01 <StoneCypher> yeah learning prolog involves travelling to r'lyeh
19:27:14 <Kaidelong> Prolog is an elegant language IMO
19:27:18 <Kaidelong> easy to learn, simple
19:27:21 <Kaidelong> consistent
19:27:24 <hsn> semi-colon is more akin to an associative operator, perhaps monoid <+>
19:27:26 <StoneCypher> like my favorite language is a prolog derivative and i still can barely cope with unification and cut
19:27:30 <StoneCypher> so very frenc
19:27:35 <StoneCypher> so very, very french
19:27:43 <StoneCypher> like
19:27:48 <StoneCypher> you can get toys working easily enough
19:27:54 <StoneCypher> but then you try using it on something large
19:27:59 <Kaidelong> and its evaluation strategy somewhat resembles haskell (I am sure there is some fundamental symmetry between backwards chaining and lazy evaluation, and another between forwards chaining and eager evaluation)
19:28:03 <StoneCypher> and all the cpu time ever goes straight into galactus' mouth
19:28:20 <StoneCypher> i would much rather just implement algorithm x myself
19:28:42 <heatsink> How about algorithm W?
19:29:13 <StoneCypher> there's actually something called algorithm x.
19:29:15 <Kaidelong> I am not sure if the difficulty really is any worse than something like haskell and lisp where expensive operations can "look" easy to the programmer
19:29:27 <StoneCypher> it's a solver for knuth's dancing links
19:29:35 <Kaidelong> I really wonder if most of the speed issues boils down to prolog being dynamically typed, interpreted, and poorly implemented
19:29:45 <StoneCypher> if you see something called dlx, it's usually a dancing links algorithm x machine
19:30:03 <StoneCypher> i think math people call it perfect coverage or something
19:30:20 <heatsink> I thought dancing links was the algorithm name
19:30:34 <StoneCypher> no, dancing links is the ridiculous datastructure
19:30:43 <Welkin> dancing links?
19:30:50 <Welkin> is this like C+=?
19:30:51 <StoneCypher> it's a thatch weave of circularly linked lists
19:31:06 <Welkin> that sounds not very useful...
19:31:07 <StoneCypher> where you use the columns to "raise" and "submerge" cells according to pointer games
19:31:16 <StoneCypher> and then read the rows to see if you have a fulfilling set of boolean constraints
19:31:24 <Kaidelong> (yes there is almost certainly something relating call-by-need to backwards chaining, they both are intuitively "depth first")
19:31:28 <StoneCypher> then it's a simple tree search with a good obvious heuristic
19:32:24 <Welkin> how many of you use haskell in your job?
19:32:45 <roboguy_> Kaidelong: wouldn't call by need be breadth first since it evaluates things outside-in?
19:32:59 <coppro> roboguy_: sure, but trying to reason about it is not the way to introduce it to people
19:34:15 <Kaidelong> roboguy_; in that sense but I think the more important detail is that if it reaches a "level" of the tree it will not explore all the areas below it neccessarily (all the arguments to a function)
19:34:26 <coppro> roboguy_: get them to understand monads containing a single value before you try to get more complicated :)
19:35:05 <Welkin> Kaidelong, like alpha-beta branch pruning?
19:35:57 <Kaidelong> mm, I guess
19:43:14 <cgag> I'm getting a 403 Forbidden trying to upload to hackage, though my user/pass worked for the package preview feature and the preview looks fine.  Anyone run into this?
19:58:18 * hackagebot kmeans-par 1.4.0 - Sequential and parallel implementations of Lloyd's algorithm.  http://hackage.haskell.org/package/kmeans-par-1.4.0 (vi)
20:02:04 <Polarina> cgag, do you have upload privileges? That is, have you applied for them?
20:03:14 <cgag> Polarina: no, it just said I need a username and password
20:05:03 <Polarina> cgag, you need to be added to the package uploaders group before you can publicise package.
20:05:48 <cgag> can you point me to any docs about that?
20:06:04 <cgag> or to where I can apply?
20:06:26 <Polarina> One moment, I am looking for them.
20:08:19 * hackagebot vector 0.10.9.2 - Efficient Arrays  http://hackage.haskell.org/package/vector-0.10.9.2 (DanDoel)
20:10:58 <Polarina> cgag, I can't seem to find the instructions, but you can send a mail to admin@hackage.haskell.org and ask them to add you to the package uploaders group.
20:30:19 <cgag> Polarina: will do, thanks
20:41:15 <augur> jonsterling: progress!
20:42:01 <jonsterling> augur: indeed! I'm still not entirely sure I understand the distinction he's making yet though. Do you know what he means yet when he says proof theory lacks recursive types?
20:42:26 <jonsterling> Augur: or that domain theory is inconsistent (note, I know almost nothing about domain theory)
20:44:12 <monochrom> hard to get any inconsistency if you lack recursive types, no?
20:49:28 <jonsterling> Augur: and does he really mean the natural numbers when he talks about recursive types? Or is he referring to something more frightening?
20:59:06 <dmwit> monochrom: fix :: (a -> a) -> a doesn't mention any recursive types
20:59:22 <dmwit> or: inconsistency is easy. Just add "a" as an axiom.
20:59:43 <monochrom> even then, the inconsistency does not happen in its domain theory
21:01:14 <dmwit> Well, I only have four sentences of context. So I should probably shut up.
21:01:25 <dmwit> I will probably never ever learn that lesson properly.
21:15:48 <augur> jonsterling: sorry about that. my computer was acting up
21:16:02 <augur> jonsterling: i dont fully understand what he's saying, but i do see where he's drawing the lines, at least
21:16:29 <augur> jonsterling: you should ask him in what ways general rec types fall outside of ITT/which principles of ITT preclude them
21:16:45 <osa1> can anyone help me, why is this happening? http://lpaste.net/104394 it was working just before I restart my computer, 5 mins ago. (the failure happens when I press C^c)
21:16:54 <cococo> Would it make sense to use Haskell to make a pastebin site? New to Haskell so I'm wondering if that would work for a learning project.
21:17:20 <augur> i get the sense that they do precisely because of non-termination, that is to say, ITT/proof theory must have normal-form proofs
21:17:28 <Cale> cococo: http://lpaste.net/ ;)
21:17:38 <Cale> cococo: (It would)
21:17:52 <augur> but i would argue that such a requirement is more about hygiene than about "being" a type theory. maybe not. i dont know
21:18:15 <cococo> Cale: lol thanks, great to see it's open source. That will be very helpful for learning :)
21:19:21 <jonsterling> Augur: Thanks for sparking that discussion tho. I'll probably ask him for more clarification later...
21:20:40 <pavonia> If you #peek into a struct Foo that has a field of a pointer to another struct Bar, how do you resolve the pointer to get the actual Bar object?
21:36:27 <ssbr> cabal install transformers gives me the following output: http://bpaste.net/show/BLYEDA9i3KJiDmpJCb1N/  . What gives / how do I install things?
21:36:54 <ssbr> I am on Ubuntu 13.10.
21:37:03 <gamegoblin> ssbr: maybe try sudo cabal install?
21:37:25 <gamegoblin> Always my first attempt :P
21:37:34 <augur> jonsterling: its an unfortunate fact that bob says a lot of whacky sounding things on twitter
21:37:37 <augur> jonsterling: gotta pressure him to clarify!
21:37:38 <ssbr> gamegoblin: same result.
21:37:40 <cococo> This must have been shared here before, but holy shit lol https://www.youtube.com/watch?v=RqvCNb7fKsg
21:38:00 <gamegoblin> cococo: Yes it’s amazing
21:38:12 <pavonia> Or do I have to explicitly state the result type of #peek? Like (#peek Foo, bar) :: Ptr Bar?
21:38:40 <pavonia> And then peek into that Ptr Bar again?
21:40:37 <ssbr> Is there a way to change what linker cabal uses? It clearly can't use my system's gold.
21:43:30 <cococo> Is there a standard name for the main script in a haskell program? (The one that executes first).
21:44:44 <pavonia> I usually use Main.hs
21:54:49 <DarkLinkXXXX> A project I'm trying to build in a Cabal sandbox has inconsistent dependencies. WTF should I do about this?
21:57:04 <ssbr> cabal install transformers gives me the following output: http://bpaste.net/show/BLYEDA9i3KJiDmpJCb1N/  . What gives / how do I install things? I am on Ubuntu 13.10.
21:58:29 * hackagebot kmeans-par 1.4.1 - Sequential and parallel implementations of Lloyd's algorithm.  http://hackage.haskell.org/package/kmeans-par-1.4.1 (vi)
22:08:30 * hackagebot kmeans-par 1.4.2 - Sequential and parallel implementations of Lloyd's algorithm.  http://hackage.haskell.org/package/kmeans-par-1.4.2 (vi)
22:22:30 <pavonia> If I have a Ptr () that represents a function loaded from a DLL file, how do I "run" that function to get a result from it?
22:33:20 <cococo> Is there ever a situation where you NEED to use a tuple in Haskell instead of a list?
22:33:28 <monochrom> Ptr is not enough. you need a FunPtr.
22:33:34 * hackagebot snap-loader-dynamic 0.10.0.2 - Snap: A Haskell Web Framework: dynamic loader  http://hackage.haskell.org/package/snap-loader-dynamic-0.10.0.2 (DougBeardsley)
22:34:55 <dmwit> cococo: Yes.
22:35:01 <dmwit> > ("like here", True)
22:35:02 <lambdabot>  ("like here",True)
22:35:10 <dmwit> > ["doesn't work", True]
22:35:11 <lambdabot>  Couldn't match expected type ‘[GHC.Types.Char]’
22:35:12 <lambdabot>              with actual type ‘GHC.Types.Bool’
22:35:19 <cococo> ah, thanks
22:35:44 <pavonia> monochrom: Can I just cast that Ptr to FunPtr?
22:36:37 <monochrom> there exists castPtrToFunPtr. I haven't tried. you may try.
22:38:31 <pavonia> But what to do next? I guess I need a foreign import but I don't know what it would look like
22:38:52 <monochrom> it is much cleaner to call it a FunPtr in the first place. FunPtr is a Storable instance; there should be no difficulty claiming "this field is FunPtr not Ptr" in the first place.
22:40:48 <monochrom> Foreign.Ptr doc says how. have you read it? have you also read Haskell 2010 chapter 8?
22:40:48 <pavonia> Well, the address of that function is a Ptr (), there's nothing I can do about that
22:41:27 <monochrom> who wrote it? that person should have his/her hands chopped
22:41:54 <pavonia> Whoever wrote the Win32 library
22:44:35 <pavonia> It makes sense, because when you're dynamically loading data from a dll you don't know if it's a function or plain data
22:45:39 <glguy> To work correctly the DLLs shouldn't be exporting functions, only structs with function pointers inside. But since common platforms represent function pointers and data pointers in the same size it just happens to work out
22:47:07 <glguy> I've done work targeting some of the AVR architectures where the program memory is in a 24-bit address space and data is a 16-bit address space and you can't just cast between the two
22:48:18 <cococo> Why is this returning a parse error on input '('? http://pastie.org/9194908 (following a tutorial from Apr 2 2013)
22:48:38 <cococo> > dropWhile` bool (x:xs) = if bool x then xs else (x:xs)
22:48:40 <lambdabot>  <hint>:1:17: parse error on input ‘(’
22:48:42 <glguy> change your ` to a '
22:48:55 <cococo> thanks :p
22:52:14 <pavonia> So when that C function's type is "KbdTables* KbdLayerDescriptor()", my Haskell call looks like "foreign import ccall "KbdLayerDescriptor" c_KbdLayerDescriptor :: FunPtr (IO (Ptr KbdTables))"?
22:52:36 <glguy> The Win32 package might have the wrong type on its System.Win32.getProcAddress as it returns a Ptr instead of a FunPtr where the windows GetProcAddress is defined to return a FARPROC which appears to be a typedef for a function pointer
22:54:01 <glguy> pavonia: If you're just writing a binding to a normal C library you'd use the type:   IO (Ptr KbdTables)
22:54:47 <glguy> If you want a pointer to that function you need to do "&c_KbdLayerDescriptor"
22:55:24 <pavonia> I need to conncect that Ptr () with this function somehow
23:01:01 <glguy> I think that the "right" way to do that today is to use Haskell's Win32's getProcAddress to get that Ptr, cast it to a FunPtr at the correct type
23:01:03 <glguy> and call that
23:01:52 <pavonia> And the correct type is FunPtr (IO (Ptr KbdTables))?
23:02:37 <glguy> I don't know, exactly. This is apparently an undocumented function you're pulling in
23:02:41 <glguy> so I don't know what the type is
23:03:58 <pavonia> The C type is KbdTables* KbdLayerDescriptor()
23:05:03 <pavonia> Oh well, do I even need a foreign import then?
23:05:08 <glguy> and you'll need a "dynamic" wrapper to call that funptr from haskell, or pass it out to C to call (again via the FFI, but at that point you could just do this whole process in C)
23:05:34 <glguy> The foreign import you're going to need is the dynamic wrapper to convert the funptr to a haskell function
23:06:01 <glguy> http://www.cse.unsw.edu.au/~chak/haskell/ffi/ffi/ffise4.html#x7-220004.2
23:06:45 <glguy> I haven't used Win32 with Haskell, so this is just my best guess based on what I'm reading
23:06:56 <glguy> If someone else knows better I'm hoping they'll speak up
23:07:12 <marko2> hey everyone; does anyone know how I can newtype wrap a HashMap and get it working with Lens (specifically, I want to use the `at` combinator without manually unwrapping first)
23:07:19 <marko2> (http://hackage.haskell.org/package/lens-4.1.2/docs/Control-Lens-At.html)
23:07:48 <glguy> marko2: (Eq k, Hashable k) => At (HashMap k a)
23:07:55 <glguy> Isn't that the instance you want?
23:08:02 <marko2> yes
23:08:17 <pavonia> glguy: Okay, thanks for the help, let's see how far I can get
23:08:26 <marko2> Could not deduce (Ixed (HashMap k v))
23:08:49 <glguy> marko2: Are you using a Lazy hashmap, perhaps?
23:09:02 <marko2> no, strict one
23:09:19 <marko2> GeneralizedNewtypeDeriving does not work either: deriving (Lens.Ixed, Lens.At) results in "Could not coerce from ‘k’ to ‘Index (HashMap k v)’"
23:10:38 <glguy> Do you have an example of some code you expected to work that didn't?
23:12:46 <marko2> glguy: yes, for example:      at 5 .~ Just 5 $ HashMap (Map.empty)
23:12:54 <marko2> glguy: No instance for (At (HashMap k0 v0)) arising from a use of ‘it’
23:13:26 <marko2> I have a wrapped HashMap in my state monad, and I would like to access it directly without the unwrapping part
23:16:34 <marko2> glguy: I suppose I could write a lens to wrap/unwrap the newtype, but I would prefer direct access in this instance, because the newtype does not exist for type safety, but only so I could write some non-orphan type class instances for HashMap.
23:16:40 <glguy> Oh, You aren't using the normal unordered-containers HashMap
23:16:45 <glguy> that's your own local newtype?
23:17:16 <marko2> glguy: yes, I am using a newtype-wrapped unordered-containers HashMap
23:17:21 <marko2> glguy: newtype HashMap k v = HashMap (Map.HashMap k v)
23:17:34 <ssbr> Where does cabal put binaries in linux?
23:17:36 <marko2> glguy: where Map is Data.HashMap.Strict
23:17:51 <glguy> marko2: OK. Just for fun, why are you newtyping it?
23:18:17 <glguy> and you can use lens package's "makeIso" function to generate that wrap/unwrap iso for you
23:18:20 <marko2> because I needed to write type-class instances for HashMap for an external library, and I was told that orphan instances are bad
23:18:31 <glguy> or you can write it yourself with the "iso" combinator
23:19:59 <pavonia> "Segmentation fault/access violation in generated code" \o/
23:20:59 <Kaidelong> probably unsafe typecasting or misuse of a foreign library
23:21:07 <Kaidelong> if not one of those probably a bug in GHC
23:21:17 <marko2> glguy: I suppose I can use iso's, but that makes my code more convoluted and this is still a form of manual newtype-unwrapping which I do not need. The best case would be if I could just write/generate the typeclass instances needed to operate directly on the wrapped hashmap
23:21:41 <Kaidelong> I see you were using the FFI though
23:21:55 <Kaidelong> so I guess congrats you're in the deep end?
23:22:05 <pavonia> Yeah, my Storable implementations are probably wrong
23:23:54 <glguy> marko2: the iso just makes the instance nicer: http://lpaste.net/104396
23:24:56 <marko2> glguy: wow, thanks. I was just missing this one: type instance Index   (HashMap k v) = k
23:25:30 <marko2> glguy: that should be enough to get me on my way! thanks a ton!
23:25:36 <glguy> cool, have fun
23:26:18 <marko2> thank you
23:30:23 <pavonia> Maybe the problem is I get a pointer to where the dll file is mapped to but can't read directly from that memory
23:39:36 <pavonia> Hhm, the function address delivered by getProcAddress is the same in my Haskell and C programs, but the pointers after executing the function are different
23:42:00 <edwardk> Hac Boston is official. http://www.meetup.com/Boston-Haskell/events/184294502/
23:42:22 <johnw> nice!
23:44:49 <edwardk> If anyone would be interested in helping sponsor / knows sponsors who would be interested in helping us out. I'd be happy to talk to them.
