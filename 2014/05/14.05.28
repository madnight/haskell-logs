00:00:00 <Kaidelong> @ty ask
00:00:01 <lambdabot> MonadReader r m => m r
00:00:37 <Kaidelong> @ty (ask >>=)
00:00:38 <lambdabot> MonadReader a m => (a -> m b) -> m b
00:01:03 <Kaidelong> so
00:01:09 <Kaidelong> ask is the reader for id?
00:01:17 <johnw> you may find asks simpler
00:01:19 <Kaidelong> @ty Reader id
00:01:20 <johnw> :t asks
00:01:20 <lambdabot>     Not in scope: data constructor ‘Reader’
00:01:20 <lambdabot>     Perhaps you meant ‘ReaderT’ (imported from Control.Monad.Reader)
00:01:22 <lambdabot> MonadReader r m => (r -> a) -> m a
00:01:31 <Kaidelong> @ty ReaderT id
00:01:32 <lambdabot> ReaderT (m a) m a
00:02:02 <Kaidelong> @ty ReaderT runIdentity
00:02:03 <lambdabot> ReaderT (Identity (m a)) m a
00:02:09 <Kaidelong> bah
00:02:12 <Kaidelong> @ty ReaderT
00:02:14 <lambdabot> (r -> m a) -> ReaderT r m a
00:02:16 <johnw> Kaidelong: what is the question?
00:02:26 <Kaidelong> I'm trying to figure out what ask actually does
00:02:30 <Kaidelong> I understand asks
00:02:35 <Kaidelong> but not ask
00:02:36 <johnw> ask returns the environment
00:02:49 <Kaidelong> so it's the identity reader?]
00:02:52 <johnw> for a Reader "r -> a", it returns r
00:03:12 <Tjr> There's "div" for integers, "/" for floats  and something else for Rationals - but how do I divide a general (Num,Ord) type?
00:03:13 <johnw> I don't know what you mean by "the identity reader"
00:03:32 <Kaidelong> @ty asks id --this thing
00:03:34 <lambdabot> MonadReader a m => m a
00:03:39 <johnw> yes
00:03:40 <johnw> ask = asks id
00:04:34 <Tjr> Like f:: (Num a, Ord a) => a->a->a ; f d n = d/n
00:04:36 <warpy> ask gives the env, asks f gives f(env)
00:05:03 <supki> :t [id, ask, asks]
00:05:04 <lambdabot> [(r -> a) -> r -> a]
00:05:26 <johnw> Tjr: there is no divide operation for Num
00:05:30 <warpy> Tjr: Num class doesnt define devision
00:05:45 <warpy> :t (/)
00:05:47 <lambdabot> Fractional a => a -> a -> a
00:06:01 <warpy> you are looking for Fractional
00:06:04 <Tjr> So how do I write a function that takes a Num typeclass, and needs to divide?
00:06:19 <johnw> you don't
00:07:14 <Tjr> Is there a good reason why haskell cannot divide?
00:07:35 <warpy> haskell doesnt believe in division
00:07:48 <johnw> Tjr: you've already stated that we have div and /
00:09:57 <warpy> :t \x y -> toRational x / toRational y
00:09:58 <lambdabot> (Real a1, Real a) => a -> a1 -> Rational
00:10:07 <warpy> Tjr: this should work ^
00:10:25 <warpy> :i Real
00:10:31 <Tjr> Fractional seems to contain only floating-point numbers
00:11:08 <Tjr> I'm trying to write something that handles probabilities, where the user should decide if the probabilities are Rationals (for precision) or floating-point (for speed)
00:13:05 <johnw> it looks like Num specifies a ring structure, what is the name of a structure which has inverses for both operations?
00:14:14 <Tjr> warpy: I'll have to use lots and lots of probabilities operations. Maybe toRational is slow?
00:15:31 <Kaidelong> johnw: commutative ring or abelian ring
00:15:42 <Kaidelong> oh
00:15:44 <Kaidelong> inverses
00:15:51 <Kaidelong> I think that's a field
00:15:53 <Tjr> johnw, Kaidelong in maths, it's field.
00:15:57 <johnw> cool, thanks
00:16:34 <Kaidelong> if you don't require commutativity and just the inverses, I think it's downgraded to a 'division ring'
00:16:53 <Tjr> probably archimedian fields, because you don't want those wonky finitary fields in there
00:18:53 <Tjr> Kaidelong: every finite "division ring" is a field, and the only division rings that are algebras over the reals are (1) reals, (2) complex, (3) quaterions. Note the octonions are excluded because they are not associative.
00:19:10 <Tjr> Kaidelong: however, that's "only" maths. Haskell might have a different opinion.
00:21:05 <Kaidelong> Tjr: doesn't a field require * to be commutative?
00:21:24 <Tjr> Kaidelong: yes.
00:22:12 <Kaidelong> I thought the distinction between a field and a division ring was that * didn't have to be commutative in a division ring. Or are you specifically talking about it being difficult to find any actual examples of division rings?
00:22:13 <Tjr> it's a theorem that finite skew-fields are commutative.
00:22:55 <Kaidelong> (that aren't also fields)
00:23:04 <Kaidelong> sounds like that's what you mean!
00:35:50 <Tjr> johnw, warpy, Kaidelong: Thank you, "Fractional" looks great. (I still don't understand why ghci thinks Rational is not an instance of Fractional, however.)
00:38:06 <Kaidelong> @ty sqrt
00:38:07 <lambdabot> Floating a => a -> a
00:38:19 <Kaidelong> mm, well I guess that's not the reason
00:38:32 <Tjr> @ty /
00:38:33 <lambdabot> parse error on input ‘/’
00:38:44 <Kaidelong> @ty (/)
00:38:45 <lambdabot> Fractional a => a -> a -> a
00:38:55 <Tjr> :i Rational
00:39:02 <Kaidelong> @instances-importing Fractional
00:39:03 <lambdabot> Double, Float
00:39:08 <Kaidelong> @info Rational
00:39:08 <lambdabot> Rational
00:39:24 <Kaidelong> I guess lambdabot doesn't support that
00:39:31 <Tjr> hmm
00:39:32 <Kaidelong> I wonder what info is corrected to
00:39:44 <Kaidelong> @info
00:39:44 <lambdabot> Error: expected a Haskell expression or declaration
00:40:08 <Kaidelong> @help info
00:40:08 <lambdabot> help <command>. Ask for help for <command>. Try 'list' for all commands
00:40:22 <Kaidelong> well neither of those helped
00:40:37 <warpy> @help @info
00:40:37 <lambdabot> help <command>. Ask for help for <command>. Try 'list' for all commands
00:48:42 <MartijnK> Hey!
00:51:38 <martijnK> Hey! I’ve been working on a big excell with all kinds of financial calculations (yes, deep sigh, not my choice). The excel is used by advisors in their work with customers. Why? Legacy + changing the excel is much much faster then doing frontend/backend stuff and making it pretty and responsive. I’d _love_ to do the calculations in haskell (with proper testing). But I dont want the hassle of making an interactive frontend. Anyone know a way to get a
00:51:38 <martijnK> “excell responsive type” frontend and haskell backend without spending thrice the hours? :<
00:53:24 <martijnK> (It’s back-office / mid-office. Need to be able to create and change it _fast_. It’s not customer facing…. Need to test calculations. Want to care less about the visuals….)
00:53:27 <warpy> martijnK: i dont understand. you want to make a spreadsheet program in haskell?
00:54:04 <martijnK> Nah, I want to do a financial model in haskell and create a view without doing all the angular/html/js/whatever
00:54:27 <warpy> so you want to call your haskell model from spreadsheet?
00:54:37 <Maior> martijnK: something a bit like iPython notebooks / workbooks?
00:54:40 <warpy> integrate excel with your haskell model server?
00:54:57 <Maior> https://gibiansky.github.io/IHaskell/ may be useful?
00:55:02 <martijnK> @warpy: or just throw the excell away, just need to make a fast frontend
00:55:02 <lambdabot> Unknown command, try @list
00:55:32 <warpy> IHaskell may work for you
00:56:08 <martijnK> hmmm; I can;’t really have advisors work with console
00:56:17 <martijnK> they have trouble opening their mail….
00:56:39 <martijnK> or am I missing the clue
00:56:58 <sjy> sounds like an interesting problem if you manage to solve it :)
00:57:30 <martijnK> @sjy: Things like Mendix make for _super fast_ frontend development, but it’s just graphic programming for the backend (and _really_ expensive)
00:57:31 <lambdabot> Unknown command, try @list
00:57:32 <warpy> well, i know a project which does exactly this thing except their backend models are in python
00:57:38 <warpy> and it is commercial
00:57:50 <martijnK> commercial is not a bad thing
00:57:58 <sjy> martingale: seems like web is the only real option for the UI though, right?
00:58:33 <warpy> they have written excel plugin in C# which calls their python model through HTTP
00:58:35 <sjy> i wonder if there's a project that does all the angular/html/css etc for you, and can be attached to a generic backend (local REST interface?)
00:58:42 <martijnK> iPython seems too complex =|
00:58:58 <warpy> and people can upload their own models to their website and use it from their own excel sheet
00:59:08 <warpy> maybe you can create something like that in haskell
00:59:12 <martijnK> sjy: prolly need some kind of language to define what needs to be shown (conditions, fields, etc)
01:00:03 <martijnK> warpy: calling functions (api) from excel is an option (just use excell as frontend and REST api as backend…?)
01:00:25 <warpy> martijnK: yes. that is what it does exactly
01:00:43 <martijnK> but looking at vbscript give me itches (I’m not a programmer btw….)
01:01:03 <warpy> you can programmer excel in c# too these days
01:01:09 <warpy> much better than vb
01:02:25 <martijnK> last time I tried calling a web service from excell it was loads of fun… Especially trying to do it from a Mac
01:02:34 <martijnK> I cried a little :(
01:03:02 <martijnK> nothing worked :)
01:03:28 <warpy> thats why it is a commercial product :)
01:04:05 <martijnK> Highly integrated into the Windows platform aswell; trying to do things on excell for mac was horrid, all kinds of missing libs
01:05:25 <martijnK> Having a proper way to replace excell files in organisations (FAST) by having a testable backend (haskell :)) and some kind of dynamic frontend - with the same flexibility/speed as creating excell....
01:05:51 <martijnK> That would make half the organisations in the world your customer for life
01:05:51 <warpy> seems like a great product idea!
01:06:01 <martijnK> yup!
01:06:04 <martijnK> Where to find the time ;)
01:06:40 <warpy> i wonder if you can call remote REST APIs from google spreadsheets
01:06:46 * hackagebot promise 0.1.0.0 - A monadic interface for async  http://hackage.haskell.org/package/promise-0.1.0.0 (JonathanFischoff)
01:07:22 <martijnK> http://dl.acm.org/citation.cfm?id=1194878
01:07:28 <martijnK> “The functional programming community has shown some interest in spreadsheets, but surprisingly no one seems to have considered making a standard spreadsheet, such as Excel, work with a standard functional programming language, such as Haskell. In this paper, we show one way that this can be done. Our hope is that by doing so, we might get spreadsheet programmers to give functional programming a try."
01:08:11 <frerich> Given that recent Excel versions can be programmed via .NET languages, F# might be a viable choice.
01:08:11 <Tjr> martijnK: I would probably need to load from standard excel, for those users who have trouble finding theirmail
01:08:13 <warpy> arent speedsheets classic example of FRP
01:08:28 <flux> tjr, doable, but it would probably also need to save standard excel and that would be a problem :-)
01:08:43 <alpounet> the guys at Standard Chartered have a Excel<->Haskell FFI, kinda
01:08:52 <ski> @where vital
01:08:53 <lambdabot> http://www.cs.kent.ac.uk/projects/vital/
01:09:01 <warpy> alpounet: how does it work
01:09:05 <alpounet> warpy: https://www.youtube.com/watch?v=hgOzYZDrXL0
01:09:11 <martijnK> warpy: excel has so many beautiful ways to spaghetti everything and keep it untested, it’s like magic
01:09:14 <alpounet> a talk by one of them :)
01:09:33 <martijnK> Tjr: afraid so, or a similar / easy frontend. But making that takes a lot of time
01:09:45 <alpounet> they call haskell code from excel, or even type it in directly
01:09:47 <alpounet> it's crazy
01:09:48 <flux> martijnk, I quoted you on that on the company intra-chat :-)
01:10:16 <martijnK> \o/
01:10:41 <warpy> but but .. i like spaghetti ..
01:11:13 <martijnK> just leave it standing for a minute, without sause and olive oil
01:11:22 <martijnK> and then try to get just a little bit from the pan
01:11:34 <ski> (Vital is sortof spreadsheet-like)
01:12:29 <martijnK> ski: images look fun, but very complex for financial advisors
01:13:17 <martijnK> (they basically know how to calculate stuff using a tool and to have a good conversation, but dont ask them [n * n | n <- [0 .. 100])
01:13:30 <martijnK> or the present value formula for that matter...
01:13:53 <warpy> solution is simple, you just need to teach them haskell
01:14:06 <warpy> and Monads ...
01:15:49 <martijnK> Still struggling those myself, ha! Can use them a bit, but not really have a firm grasp of monad composition (or where in my mind I should find things like co-algebra)
01:16:14 <martijnK> Not a natural thing yet… In time.
01:16:55 <warpy> i dont understand any of those co- things
01:18:57 <martijnK> I just google it, go to http://wwwhomes.doc.ic.ac.uk/~dirk/Publications/tcs2011.pdf and scroll to the bottom of page 10 and go, not today! (it has hearts in formulae though, which is probably good)
01:19:14 <hooplahoops> Hi, I've got this very simple stream program: https://gist.github.com/anonymous/f7b3856cea9e2543ea91 . There's a skolem/rigid type variable problem with the implicit 'state' variable in the GADT, what has happened here?
01:22:36 <haasn> hooplahoops: The inner ‘Yield’'s Stream a could contain a different ‘s’ for every single time
01:22:44 <haasn> Since it's existential
01:23:47 <hooplahoops> haasn: right, I see. How can I then fix this 's' to not vary for every stream? I suppose that's just what this use of the GADT means?
01:24:09 <hooplahoops> haasn: I'm guessing I need some sort of work-around, is this even possible at all?
01:24:10 <haasn> Try letting the outer s ~ (); Stream a is now ≅ a + Skip/Done
01:24:25 <haasn> hooplahoops: Can't you let the ‘s’ float outwards? ie. data Stream s a where
01:24:41 <hooplahoops> haasn: yeah, keep an explicit state
01:24:52 <hooplahoops> haasn: I tried that and that makes the flatten work, but it's very tedious
01:25:04 <hooplahoops> haasn: mainly because states get pretty commplicated
01:25:35 <hooplahoops> so e.g. if I have a function that calls something else, and it has a state say, [a], then that needs to appear as part of the state of the caller as well
01:26:32 <haasn> Maybe you could parametrize your ‘a’ (call it ‘f’) by ‘s’
01:26:42 <haasn> like Step s a = Yield (f s) s | Skip s | Done
01:26:56 <Tjr> How does haskell handle caching?
01:26:56 <Tjr> For example:  let f :: Int -> a -> a ; f n
01:27:01 <haasn> And then you can use an internal Stream' s a
01:27:04 <haasn> Hmm, I don't know any better
01:27:08 <Tjr> oops
01:27:22 <haasn> or Stream' a s, rather
01:27:31 <haasn> (and Const a for the other types of Stream)
01:27:51 <hooplahoops> haasn: ah, let me try that, thanks haasn!
01:28:17 <Tjr> How does haskell handle caching?
01:28:17 <Tjr> let power :: Num -> Int -> Num ; power expensive n = expensive * (power expensive $ n - 1 )
01:28:56 <Tjr> Can I rest assured that haskell computes the computationally expensive part only once?
01:28:56 <haasn> Maybe something else could be done to constrain the inner s ~ s' by passing in a constraint or something
01:29:09 <haasn> I don't know. hooplahoops: Do you think machines could be relevant?
01:29:13 <warpy> Tjr: there is library to do that
01:29:27 <haasn> http://hackage.haskell.org/package/machines-0.2.5/docs/Data-Machine-Type.html
01:29:28 <warpy> memo combinators i suppose
01:29:41 <Tjr> warpy: you mean memoization?
01:29:44 <warpy> ya
01:30:03 <hooplahoops> haasn: ah, let me explore that, never heard of those before :)
01:30:17 <Tjr> Memoization is a way to guarantee that you compute something only once over the lifetime of a program.
01:30:27 <c_wraith> hooplahoops: could you just use something like data Stream a = Yield a (Stream a) | Skip (Stream a) | Done ?
01:30:31 <pjdelport> Tjr: Strictly speaking (har) Haskell the language does not dictate any particular evaluation strategy, as long as it's non-strict in the required ways. In practice, Haskell implementations generally use lazy evaluations, which means that each shared expression will get evaluated only once, as needed.
01:30:33 <warpy> are you not talking about it?
01:30:58 <c_wraith> hooplahoops: that would appear to be the same type, with the existential factored into laziness
01:31:00 <Tjr> In the recursive example, it would already be happy if it's evaluated only once for all the recursions
01:31:11 <Tjr> pjdelport: ok, thanks, that answers my question.
01:31:33 <pjdelport> Tjr: If things share a binding, like your above example, you can be reasonably assured it will only be computed once.
01:31:37 <haasn> oh, c_wraith provides a good point; unless you want to turn the ‘s’ into something like ‘IO s’ to get lazy side effects
01:31:49 <haasn> (but you could still do IO (Stream a))
01:31:55 <hooplahoops> c_wraith: interesting, so this means the state is recursove?
01:31:58 <pjdelport> (under the hood, it will usually be a thunk, unless other program transformations occurred)
01:32:10 <warpy> pjdelport: doesnt it happen only if you compile with O2
01:32:19 <mietek> Failed to install text-1.1.1.3
01:32:21 <mietek> Anyone else?
01:32:48 <c_wraith> hooplahoops: it's a recursive data type yes, but laziness will make it a proper stream still
01:32:50 <pjdelport> warpy: No, thunks and lazy evaluation should work as expected with any optimization level. -O2 is more about turning on other optimizing transformations and passes.
01:33:10 <warpy> ah. i see
01:33:18 <pjdelport> (For example, -O2 might get that "power" function inlined in a bunch of places, where it wouldn't be without optimizations.)
01:33:54 <hooplahoops> c_wraith: ah, you mean you're still using guarded recursion?
01:34:01 <shachaf> Optimizations can do all sorts of things.
01:34:17 <shachaf> They can certainly change space usage asymptotically.
01:34:21 <c_wraith> hooplahoops: yes. Well, guarded corecursion. :)
01:34:32 <hooplahoops> c_wraith: ah, ok :)
01:36:04 <hooplahoops> c_wraith: I'm wondering if that will get me the deforestation effect
01:36:53 <c_wraith> hooplahoops: It won't avoid allocating, but your present version doesn't either. It still allocates just as much in the Step constructors
01:37:54 <hooplahoops> c_wraith: indeed, I was hoping that call pattern specialization / case elimination would avoid that after inlining
01:38:11 <hooplahoops> as of yet that hasn't really happened I think :)
01:41:35 <Tjr> latro`a_: How did you solve your graph connected-components problem?
01:41:37 <c_wraith> hooplahoops: you could always replace it with newtype Stream a = Stream (forall r. (a -> r) -> r -> r -> r), I suppose.  I don't think that's a win most of the time.
01:42:05 <c_wraith> err, newtype Stream a = Stream (forall r. (a -> r) -> (r -> r) -> r -> r)
01:42:17 <c_wraith> I knew that wasn't right the first time.
01:42:56 <c_wraith> I suppose it's a win if you can construct those without building up lots of complicated functions.
01:43:53 <c_wraith> ...  darn it, still not right.
01:44:17 <c_wraith> newtype Stream a = Stream (forall r. (a -> r -> r) -> (r -> r) -> r -> r), and I clearly need to stop talking because I'm too tired.
01:44:47 <hooplahoops> c_wraith: the 'r' is the state variable here? The first function is the stepper function and what's the second function?
01:44:51 <c_wraith> That finally looks right, though.  It's just foldr with an extra case.
01:45:04 <hooplahoops> c_wraith: no worries, streams are commplicated :)
01:45:05 <c_wraith> hooplahoops: that's the church encoding of the data type I proposed
01:45:42 <shachaf> @arr rr rr
01:45:43 <lambdabot> Swab the deck!
01:45:52 <shachaf> Oleg would call it a Boehm-Berarducci encoding or something.
01:46:38 <hooplahoops> c_wraith: ok, I'll need some time to grok that :)
01:46:58 <c_wraith> hooplahoops: It's an eliminator function.  The first argument is how to eliminate the first constructor.  The second argument is how to eliminate the second constructor.  The third...  Ok, you get the idea.
01:47:31 <hooplahoops> c_wraith: ah, I see
01:47:36 <c_wraith> hooplahoops: it's the same relationship as between [] and foldr
01:52:55 <newmayhem> hi guys, i'm new to haskell. i was wondering if anyone could help me try to answer a hw question i have regarding creating a mapping function for a binary tree that is explicitly concurrent? i've written this so far http://lpaste.net/4720602729741811712 but i'm having issues with the last line in compiling
01:57:50 <hexagoxel> newmayhem: problem is MVar a vs a? l' and r' are MVars..
01:59:39 <hexagoxel> and it would be easier if we knew the full code (BinaryTree?) and the exact error.. :)
02:01:12 <newmayhem> hexagoxel: i realised there's a type mismatch but i can't seem to figure out how to fix it :( i've updated the lpaste to include the full code: http://lpaste.net/4720602729741811712 i feel like i'm so close but missing something little!!!! :P
02:01:40 <newmayhem> the error is just the type mismatch as you pointed out
02:04:28 <merijn> newmayhem: You forgot to paste the error :)
02:04:48 <hexagoxel> :hoogle MVar a -> IO a
02:05:52 <newmayhem> merijn: oops sorry! http://lpaste.net/5868129540676517888
02:05:56 <hexagoxel> @hoogle MVar a -> IO a
02:05:58 <lambdabot> Control.Concurrent.MVar readMVar :: MVar a -> IO a
02:05:58 <lambdabot> Control.Concurrent.MVar takeMVar :: MVar a -> IO a
02:05:59 <lambdabot> Control.Concurrent.MVar swapMVar :: MVar a -> a -> IO a
02:05:59 <merijn> newmayhem: Oh, wait, it's obvious
02:06:29 <merijn> newmayhem: Branch takes two binary trees as arguments, but you're giving it two MVars one line 26
02:06:48 <merijn> newmayhem: That's what it's telling you
02:07:19 <newmayhem> hexagoel: i thought about using takeMVar but that would give me an IO a which would result in an error as well :(
02:07:29 <hexagoxel> newmayhem: also, when you putMVar, look at the exact type of what you put in
02:07:58 <merijn> newmayhem: So I wrote an annotation clarifying the types of your constructors: http://lpaste.net/4720602729741811712
02:08:53 <merijn> newmayhem: Now, on line 26 you're doing "Branch v' l' r'", BUT those three variables are values of type MVar. Branch does not take values of type MVar
02:09:36 <deni> what's the difference between mapM and mapM_? _ returns just unit right?
02:09:49 <deni> it there somekind of convention what _ functions are supposed to do?
02:10:08 <merijn> deni: mapM_ runs every action, but discards the result
02:10:22 <merijn> deni: for example, imagine wanting to map "print" over a list
02:10:26 <merijn> :t mapM print
02:10:27 <lambdabot> Show a => [a] -> IO [()]
02:10:32 <newmayhem> merijn: yep. and i want to take what's in the MVar and return it as part of the branch like i did in treeMap. am i right in thinking MVar is like a container?
02:10:57 <merijn> deni: That returns a [()], but you probably don't care about a list of () and if your [a] is very long, you're leaking a lot of memory!
02:11:23 <merijn> deni: So mapM_ does the exact same thing as mapM, but it throws away the result
02:11:27 <merijn> :t mapM_ print
02:11:29 <lambdabot> Show a => [a] -> IO ()
02:11:53 * hackagebot hsgnutls-yj 0.2.3.3 - Library wrapping the GnuTLS API.  http://hackage.haskell.org/package/hsgnutls-yj-0.2.3.3 (YoshikuniJujo)
02:12:04 <merijn> newmayhem: MVar's are "Mutable Variables", which, yes, are like containers (or like variables in non-pure languages)
02:12:06 <deni> merijn: so it's convention that someThing_ is more memory efficient? ie by throwing away the result?
02:12:21 <merijn> deni: In general the convention is that _ throws away results
02:12:23 <hexagoxel> newmayhem: note that newEmptyMVar :: IO (MVar a) and l' :: MVar a (in your case, at the moment, a==IO (BinaryTree b))
02:12:35 <deni> merijn: awesome. tnx.
02:13:04 <supki> deni: or inputs (e.g. bracket/bracket_)
02:13:08 <merijn> newmayhem: Note that while your current approach *can* work (module some significant rewriting of the code), it's probably not the approach you *want* to take
02:13:22 <merijn> newmayhem: The forkIO + MVar approach stuffs your code into IO
02:13:37 <merijn> newmayhem: But haskell already has pure methods of expressing parallel maps like this
02:14:07 <deni> supki: hmm what's the use case for throwing away input? O_o
02:14:08 <hexagoxel> but it is a neat little exercise :)
02:14:33 <merijn> newmayhem: You may want to look at Control.Parallel and Control.Paralle.Strategies
02:14:47 <merijn> :t bracket
02:14:48 <lambdabot> IO a -> (a -> IO b) -> (a -> IO c) -> IO c
02:14:50 <merijn> :t bracket_
02:14:51 <lambdabot> IO a -> IO b -> IO c -> IO c
02:15:20 <merijn> deni: You understand what bracket does, right? i.e. allocate a resource, run an action and free the resource
02:15:42 <newmayhem> hexagoxel: hmm i don't think i'm understanding the significance of that
02:15:52 <merijn> deni: Imagine that the "allocation" is an "IO ()" that creates a temp file and the other frees a temp file. Why would you care about the return value of the "IO ()"?
02:16:27 <newmayhem> merijn: actually this is hw, and the lecturer wants us to make an impure function explicitly concurrent so i think we're meant to do it like this haha
02:16:36 <merijn> newmayhem: Ah :)
02:17:12 <merijn> newmayhem: I think part of the problem you're having is that you're "doing too much" in one function and doing multiple things at the same time is messing with your mind
02:17:33 <BoR0> how can I catch "no parse" exception by read
02:18:19 <merijn> newmayhem: I recommend the following steps: 1) write a function "(a -> b) -> BinaryTree a -> IO (BinaryTree (MVar b))" and "BinaryTree (MVar b) -> IO (BinaryTree b)"
02:18:49 <merijn> BoR0: By not using read, use reads or Text.Read.readMaybe
02:19:16 <BoR0> thanks!
02:19:21 <newmayhem> merijn: haha yes i am quite confused. i think for the most part though i understand that i need to evaluate each branch and put it l' and r' MVars and i want to force the evaluation of these in the last line, but i can't figure out how to pull l' and r' out of their MVars
02:19:22 <merijn> newmayhem: Then your homework solution just becomes combining those two functions
02:19:45 <merijn> newmayhem: Right, which is why I recommend writing two separate functions, so you only have to think about one thing at a time
02:20:03 <newmayhem> merijn: OK i'll give that a go. thankyou!
02:20:27 <merijn> newmayhem: The first function starts all the concurrent computations and stores the MVar's in a tree and the second one takes a tree of MVars and tries to convert it back into a "normal" tree. That way you only have to think of a single problem at a time
02:21:16 <merijn> newmayhem: The golden rule of functional programming: If you don't know how to do what you want, try and split it into multiple simpler problems :)
02:27:03 <merijn> newmayhem: Here's how I would start assignments like this (plus, I included two differently written versions of treeMap with a "better" coding style, generally using where instead of let-in is preferred) http://lpaste.net/4720602729741811712
02:27:32 <merijn> newmayhem: Once you write down the types like this with undefined, you can immediately start loading code into ghci to see if everything typechecks
02:27:51 <merijn> And then you just incrementally replace "undefined" with actual code :)
02:28:06 <newmayhem> merijn: that's awesome, thankyou!
02:28:15 <pjdelport> (lazy evaluation, ta-da!)
02:28:41 <frerich> merijn: that's pretty much my personal approach, too. Do you know whether there's a conventional name for this "play lego with function signatures but let them all be 'undefined'" style of development?
02:28:52 * frerich hopes it's not something like "type-driven development..."
02:28:54 <merijn> frerich: Yes "haskell programming" :)
02:29:11 <frerich> merijn: Well it's not specific to haskell. In C, you could just leave functions empty ;-)
02:29:25 <merijn> frerich: I don't think it really has a name, also note that that GHC 7.8 makes this approach even more awesome
02:29:36 <Maior> merijn: it does? why?
02:29:37 <frerich> merijn: Oh, it does? How so?
02:30:07 <Maior> oh is that the partial-type-sig thing?
02:30:10 <merijn> 7.8 has typed holes, which means you can write any variable starting with a _ in your code and it will produce a compile error that prints out the type of said variables
02:30:28 <merijn> Maior: No, partial-type-sigs are a brilliant idea too, but typed holes is different
02:31:05 <merijn> So you write "foo :: Int -> Int; foo x = x + _num" and when you compile will tell you "found typed hole _num with type Int"
02:31:52 <merijn> The main problem with using undefined is that you could accidentally forget to remove an undefined. So typed holes are a compile error, but GHC will keep type checking so it can report whether your code is well-typed
02:32:17 <deni> merijn: yeah but were talking about input
02:32:20 <Maior> oh
02:32:21 <Maior> ohhhhhh
02:32:23 <Maior> that's cool
02:32:25 <deni> not output...output i get
02:32:26 <hexagoxel> newmayhem: for some mvar examples, see http://chimera.labs.oreilly.com/books/1230000000929/ch07.html
02:32:54 <deni> merijn: i also get bracket now. but i fail to see how that is discarding input
02:33:18 <merijn> deni: bracket isn't discarding input, but bracket_ is
02:33:37 <merijn> :t bracket
02:33:38 <lambdabot> IO a -> (a -> IO b) -> (a -> IO c) -> IO c
02:33:52 <merijn> deni: Note that the 2nd and 3rd arguments of bracket use the 'a' produced by the first
02:33:55 <merijn> :t bracket_
02:33:57 <lambdabot> IO a -> IO b -> IO c -> IO c
02:34:10 <merijn> deni: With bracket_ the 'a' is never used by any other the other arguments
02:36:02 <merijn> newmayhem: And if while writing the code of parallelStart you think "oh, I really need a function foo with type 'a -> b -> c'!" you just write down that type signature with undefined and keep implementing "parallelStart" and worry about actually implementing the code for "foo" later
02:39:02 <hexagoxel> unless the type is "IO a -> a" :D
02:40:18 <merijn> I can think of at least 2 functions with that type that don't involve unsafePerformIO :p
02:40:24 <killy9999> I have a question about Arrows
02:40:27 <killy9999> http://www.haskell.org/ghc/docs/7.8.2/html/users_guide/arrow-notation.html
02:40:48 <killy9999> what is the meaning of 0 and 10 superscripts in the syntax declarations?
02:40:56 <killy9999> e.g. exp^10
02:42:14 <merijn> killy9999: My blind guess is something fixity related?
02:42:28 <merijn> Although this seems more of a "GHC manual" question than an arrow question
02:42:42 <merijn> I don't think this is related to arrows specifically
02:42:56 <killy9999> I'll take a look at Paterson's "A New Notation for Arrows"
02:43:05 <killy9999> maybe it will clear things up
02:43:17 <killy9999> well, I'll try asking at #ghc
02:45:08 <ast__> I'm writing simple func that reads from the socket and dumps data to file when it gets a predefined value. What is the usual way to hold the data I've got so far?
02:45:33 <ast__> Currently I'm just passing the values recursively, but it uses lots of heap
02:45:37 <ast__> and cpi
02:45:38 <ast__> cpu
02:46:14 <merijn> ast__: Hard to say without seeing what you're doing? lpaste a small example of this recursive loop?
02:46:42 <deni> merijn: i see. tnx for the explanation
02:47:24 <ast__> merijn: lpaste.net/2024930106283130880
02:47:28 <ast__> thanks
02:54:12 <merijn> ast__: I have no clue what types values and value have, so I have no idea how much memory they would take
02:55:10 <bssstudio> hai! Not sure if there is a fix to this error: http://lpaste.net/104747
02:55:20 <ast__> merijn: these are just ints
02:55:36 <bssstudio> I can not build unix-compat, hGetContents says invalid argument
02:55:52 <bssstudio> I am building on debian 6 and GHC 7.6.3
02:56:40 <ast__> merijn: isn't it just i hold these values for each recursive call in memory? (lazy evaluation?)
02:57:51 <akegalj> i have list of Days from Date.Time.Calendar, i would like to group them into span of days like groupDaysIntoSpans [2014-05-14, 2014-05-15, 2014-05-17] == [[2014-05-14, 2014-05-15],[2014-05-17]]. I could solve this using fold but can i solve it with groupBy, splitOn or other solutions?
03:08:41 <mirpa> Can I make data type A in module A, import A.A into modules B, C and then import modules B, C into module D so that data type B.A and C.A are treated in module D as two different types (like with newtype)? Only namespace would be different so that I don't have to copy-paste implementation of A.A into B,C...
03:10:54 <alpounet> mirpa: that's not how types are distinguished
03:11:01 <Yuu_chan> > let s = [1, 2, 3, 5, 6, 8, 9, 10] in map (map fst) $ groupBy (\_ (_, y) -> y == 1) $ zip s (zipWith (-) s (0: s)) --akegalj
03:11:03 <lambdabot>  [[1,2,3],[5,6],[8,9,10]]
03:11:04 <alpounet> if it's the same type, they are the same
03:11:09 <Yuu_chan> But I'd prefer foldr.
03:11:34 <alpounet> mirpa: needing to distinguish them is clearly a sign that you want actually different types
03:11:49 <alpounet> maybe it can be the same with just a un-used type argument
03:11:54 <alpounet> that could serve as a "tag"
03:12:30 <mirpa> alpounet: they are identical but I want them as separate types
03:12:55 <mirpa> so that I can't put them into one list for instance
03:14:40 <alpounet> module A where data A tag = A { ... } ; module B where data BTag = BTag; module C where data CTag = CTag; module D where f_for_B :: A BTag -> IO () ; list :: [A CTag] ; blah :: A anytag -> Int
03:14:41 <akegalj> Yuu_chan: wau, thank you.. interesting solution... im trying tu figure out how it works. But cool :)
03:14:59 <alpounet> mirpa: here f_for_B will only accept values that are tagged with "BTag"
03:15:18 <mirpa> that tag is useless in my code
03:15:40 <mirpa> I have just newtype ... = ... Int as handle for various data type
03:15:45 <av_> hello everyone, I've got Haskell Platform installed on a Window$ 7 computer, is it possible to create a Haskell program (single file) that gets executed automatically on double-click in the fil broswer? Currently, a double-click just launches ghci.
03:15:51 <mirpa> s/type/types/
03:16:00 <av_> s/fil/file
03:16:05 <alpounet> mirpa: you'll never need to worry about it, it's just to use the type system to be precise about what should be accepted by what function
03:16:11 <Yuu_chan> av_: of course, just compile your sources
03:16:50 <alpounet> mirpa: you could actually just have "data BTag" and live it without an actual representation, it'll never exist in memory at anytime, it's purely for enforcing things via types
03:16:56 <av_> Yuu_chan: I want to do it without recompiling, if that's possible. Basically, I want runghc to run rather than ghci when I double-click
03:16:57 <alpounet> leave it*
03:17:45 <Yuu_chan> av_: well, change the file associations.
03:18:27 <mirpa> alpounet: ok, thanks
03:20:01 <alpounet> mirpa: basically, if you want a function to consider values associated to B, you just say "A BTag", for C it's "A CTag", and if you want to accept both, you just say "A anytag" or "A a" or whatever, basically leaving the tag as a type variable that can be anything
03:20:08 <Yuu_chan> av_: Control Panel → Default Programs → Set Associations
03:21:05 <av_> Yuu_chan: all right then, that'll do the job, though it would apply to ALL .hs files, which isn't nice, but I think I can live with that
03:21:12 <av_> Yuu_chan: thanks
03:21:18 <mathi> how to learn haskell
03:22:34 <mirpa> alpounet: I think I understand now, thank you.
03:22:42 <Yuu_chan> av_: otherwise you can simply right click → Open with
03:24:24 <Yuu_chan> mathi: with your brain
03:24:28 <mirpa> mathi: learnyouahaskell.com http://book.realworldhaskell.org/ haskell.org
03:37:41 <merijn> alpounet: And if you only want to accept BTag and CTag, but not DTag, then it's time to break out the 7.8 type family abuse :D
03:38:12 <alpounet> merijn: or you could use a system with a list of tags
03:38:16 <alpounet> but it's really getting ugly
03:38:17 <alpounet> :p
03:38:27 <tdammers> or you could use PHP and eval()
03:38:35 * tdammers ducks
03:38:44 <merijn> alpounet: You can actually do it pretty neatly: https://gist.github.com/merijn/6130082
03:40:03 <alpounet> merijn: right, that's exactly what I was thinking of
03:40:25 <alpounet> I think i've seen this a while back
03:41:33 <mirpa> alpounet: I have something like this: http://lpaste.net/104748
03:43:23 <merijn> alpounet: Probably, I keep linking it because I'm a narcist :p
03:44:06 <alpounet> mirpa: alright :)
03:44:18 <alpounet> merijn: hah, i admit this is a pretty sweet trick
04:12:07 * hackagebot iban 0.1.0.0 - Validate and generate IBANs  http://hackage.haskell.org/package/iban-0.1.0.0 (ibotty)
04:14:21 <ast__> I tried to do it without sockets and got the same
04:14:24 <ast__> lpaste.net/2024930106283130880
04:14:51 <ast__> any idea why it is using 100% cpu and lots of heap?
04:16:03 <int-e> ast__: it's computing the length of the whole list first, so if the list is very long that will all be kept in memory
04:17:02 <int-e> ast__: a lazy test for the length would be something like   if null (drop 6000 values) then {- we have at most 6000 elements, continue -} else {- we have more than 6000 elements, fail -}
04:17:34 <ast__> int-e: hmm, so it's the length that takes up time and not recursion?
04:17:45 <ast__> int-e: i mean space/time
04:18:45 <int-e> ast__: oh wait your list is not actually getting longer than 6000 elements.
04:18:57 <ast__> int-e: yep
04:18:59 <eikke__> edwardk: what's BDD?
04:19:00 <int-e> ast__: ok, so actually the 'last' is never evaluated, so all intermediate lists are kept in memory
04:19:08 <edwardk> binary decision diagrams
04:19:33 <edwardk> @google robdd binary decision diagrams
04:19:34 <lambdabot> http://en.wikipedia.org/wiki/Binary_decision_diagram
04:19:34 <lambdabot> Title: Binary decision diagram - Wikipedia, the free encyclopedia
04:20:33 <ast__> int-e: I see, so it is keeping it in memory for all recursive calls?
04:21:45 <eikke__> ty
04:22:11 <edwardk> knuth fascicle 1b is a good crash course on BDDs
04:22:47 <eikke__> despite those books being in my dad's library, I never got to read them :)
04:22:50 <edwardk> alternately something like the CUDD documentation for a low level technical view or bddbddb for a use in something bigger/more pragmatic
04:23:27 <edwardk> fascicle 1b is a pretty new addition to the books
04:23:36 <eikke__> oh
04:23:59 <edwardk> actually, not sure its even in print yet, let me see
04:24:23 <edwardk> try http://www-cs-faculty.stanford.edu/~uno/fasc1b.ps.gz
04:24:31 <int-e> ast__: let's say we start with vs0 = [0]. Then the first call produces vs0 ++ [last vs0 + 1]; the second call evaluates that to vs1 = [0, last vs0 + 1]. That becomes vs1 ++ [last vs1 + 1], and evaluates to [0, last vs0 + 1, last vs1 + 1]. Note that vs0 and vs1 are still referenced, because the values inside the list have not been requested yet, and therefore remain unevaluated. And it continues like that, producing [0, last...
04:24:37 <int-e> ...vs0 + 1, last vs1 + 1, last vs2 + 1, ..., last vs6000 + 1] in the end.
04:24:49 <edwardk> that is _just_ on this topic
04:25:38 <ast__> int-e: thanks for the explanation, i see now
04:25:45 <int-e> ast__: I suspect the example code is a bit too simple to give adivce on how to write it better. Ideas include prepending to the list rather than appending to it (avoiding reconstructing the whole initial part as a new list each time), an explicitely forcing the values inside the list.
04:25:52 <eikke__> heh, in the references in the wikipedia page one of my former professors is listed
04:26:31 <ast__> int-e: I tried to evaluate the value (by printing it), but still get the same, is it not enough?
04:27:42 <int-e> ast__: if you replace  testFunc (values ++ [(last values) + 1])  but   let next = last values + 1 in next `seq` (values ++ [next])  that should behave better in terms of memory. (You will still be paying for all those concatenations.)
04:27:49 <eikke__> oh, he's even one of the 'founders' of this stuff?!
04:28:00 <ast__> int-e: looks like it is the list concatenation is the main issue
04:28:15 <ast__> int-e: just newvalue:values is instant
04:28:39 <int-e> ast__: hmm. Or using bang patterns ({-# LANGUAGE BangPatterns #-}) which are more readable: let !next = last values + 1 in values ++ [next]
04:28:48 <int-e> ast__: yes, it should be
04:29:11 <ast__> int-e: thank you, i'll try to put it into my actual socket reading code.
04:29:35 <linduxed> so i'm curious about dependent typing: if i've understood the general idea it's that it would allow you to say that "the type of this is a list that has five strings in it", where the emphasis is on the fact that a number was specified (i'm sure you could constrain things in other ways than numbers)
04:29:36 <edwardk> eikke__: its always funny when a student realizes their professors actually did something considered important once ;)
04:30:16 <linduxed> so my question is first of all if this is something that haskell can't have, and secondly, why do i keep hearing lazy evaluation mentioned whenever dependent types are talked about?
04:30:21 <eikke__> edwardk: exactly what I was thinking but didnt dare to write here :P
04:30:37 <linduxed> i think someone said something like "we don't really need dependent types that much when we have lazy evaluation"
04:30:56 <edwardk> eikke__: you should learn all about it and start asking him detailed questions some time ;)
04:31:41 <edwardk> be sure to hit the new stuff... 'for cube covers, do you still think BDDs are the way to go, or should I look more seriously at zero-suppressed decision diagram?'
04:31:43 <eikke__> edwardk: well actually, I'm no longer at university for quite some years by now, and his subjects was one of those which made me give up :-/
04:31:49 <edwardk> eikke__: fair
04:34:20 <jmcarthur> linduxed: i am not aware of any relationship between laziness and dependent types that means laziness takes the place of dependent types
04:34:50 <linduxed> i've often heard it being mentioned in those conversations, that's all :-/
04:35:02 <jmcarthur> linduxed: for what it's worth, that example you gave can be expressed in haskell without gadts. nothing to do with laziness though
04:35:14 <jmcarthur> linduxed: sorry, without dependent types. *with* gadts
04:40:05 <ast__> int-e: looks like I still have unevaluated values, like if (fst v == 0) || (snd v == 1)
04:40:43 <yitz> edwardk: what does behavior driven development have to do with weak references?
04:40:45 <ast__> int-e: will it keep for example snd v unevaluated if first it true?
04:42:14 * yitz scrolls up the chat window
04:42:26 <jmcarthur> yitz: i'm guessing he means BDD = Binary Decision Diagram
04:42:41 <yitz> jmcarthur: yeah i see that now. :)
04:44:02 <int-e> ast__: yes it will.
04:46:35 <int-e> ast__: it's possible to have data constructors with strict arguments, which helps sometimes. http://hackage.haskell.org/package/strict-0.3.2/docs/Data-Strict-Tuple.html even provides a generic strict pair (with a wrong example at the top, tsk.)
04:47:26 <int-e> (the example is wrong because :*: should be :!:)
04:47:59 <edwardk> yitz: binary decision diagrams =P
04:48:06 <ast__> int-e: but why it keeps in memory if I don't need it anymore lpaste.net/2024930106283130880
04:49:11 <edwardk> yitz: i made only a weak reference to the right concept, so it doesn't surprise me that you grabbed the wrong one ;)
04:49:18 <yitz> edwardk: yeah i saw by scrolling up. sorry. :/
04:49:32 <edwardk> heh, np.
04:49:36 <yitz> edwardk: heh. neither one seems inherently related to weak refs.
04:50:09 <edwardk> ROBDDs need a cache of previously used sub-trees, hash-cons style
04:50:12 <edwardk> see it now?
04:50:16 <yitz> why is studying bdds any different than just sat?
04:51:07 <edwardk> ROBDDs have the benefit of a canonical form, you can check for function equality with structural equality given a variable order
04:51:26 <edwardk> and with hash-consing, that is reference equality
04:51:58 <mrmatttodd> Hi I just came across this function definition in some code and I dont understand what the return type is means. Any help would be appreciated. concTreeMap :: (a -> b) -> BinaryTree a -> IO (BinaryTree b)
04:52:00 <edwardk> ZDDs happen to line up with my use of wavelet trees to store indices in a nice way
04:52:00 <yitz> sats also have several cannonical forms.
04:52:28 <merijn> mrmatttodd: It means that it returns an IO action that produces a "BinaryTree b"
04:52:29 <edwardk> yes, but its a lot easier to sample a random satisfying model in ROBDD form.
04:53:05 <yitz> edwardk: ok, i'll take your word for it. ;)
04:53:18 <edwardk> ROBDD is a nice form for the conflict clauses you generate in a SAT solver actually.
04:53:19 <mrmatttodd> merijn: ah ok thanks
04:53:35 <yitz> merijn: actually it means "something is very wrong with this functor".
04:54:01 <merijn> yitz: Not really
04:54:13 <yitz> well, a functor combined with some kind of effect.
04:54:15 <edwardk> and you can use DPLL to pick nice variable orders for ROBDDs, so the relationship is somewhat incestuous
04:54:27 <merijn> yitz: I saw someone earlier today with the same type. It was homework to run the map concurrently using forkIO and MVars
04:54:42 <yitz> merijn: that would do it :)
04:55:41 <edwardk> in many ways the problems that CNF/DNF forms handle well and the ones handled well by ROBDDs are more or less complementary
04:55:53 <yitz> merijn: although maybe i was right in the first place. it can be done as a pure function using unamb.
04:56:27 <merijn> yitz: Yeah, or just using Control.Parallel.Strategies, but the instructor explicitly said to do it using MVar/forkIO, so
04:56:42 <yitz> merijn: ok, got it.
04:56:57 <merijn> It seems a reasonable enough homework exercise as-is, so
04:57:02 <yitz> yes
04:57:07 <edwardk> The ROBDD approach makes it much easier to count satisfying models
04:59:04 <edwardk> yitz: if i've not beaten it to death enough, Knuth has a whole section on them, which as always with Knuth, is an excellent read. http://www-cs-faculty.stanford.edu/~uno/fasc1b.ps.gz
04:59:38 <yitz> edwardk: thanks. yeah, it figures that knuth got there first as usual
05:00:13 <edwardk> I just found the Knuth fascicle the other day actually after I realized in talking with a couple of folks who do model checking in Germany that a lot of what I'm doing in succinct structures relates to more traditional but less space-efficient work in BDD-land.
05:00:43 <edwardk> and since I'd once played with BDDs that gave me a whole lot of desire to dust off code
05:03:15 <yitz> edwardk: once we were working on optimizing the code for Data.List.permutations. after a whole process of trial and error and improvement that seemed quite haskell-specific, we discovered that the entire conversation was just a paraphrase of a small part of a complete analysis in a knuth facicle
05:05:12 <edwardk> hah
05:05:59 <edwardk> that usually happens. if you can get yourself to read past the silly assembly code, then his work is amazing.
05:06:05 <yitz> edwardk: it was a conversation i had on the cafe with van Laarhoven
05:08:52 <yitz> edwardk: but in that case, knuth didn't get their first. the algorithm we finally settled on turned out to have been first invented by english church bell ringers in the 1600s.
05:09:02 <edwardk> heh
05:09:09 <yitz> *there
05:09:23 <edwardk> so of course its something he probably found out through his obsession with organ music, not CS ;)
05:09:52 <yitz> it's amazing how for some people everyting just comes together
05:14:49 <merijn> *Van Laarhoven
05:14:51 * merijn ducks
05:18:47 <yitz> merijn: dunno. he spelled it lower case in emails.
05:19:55 <yitz> is there some dutch spelling rule i'm getting wrong? i don't speak dutch. (but like any english speaker, can understand quite a bit of it)
05:20:09 <merijn> yitz: I'm on a pedantic mission to eliminate my pet peeve of people wrongly capitalising Dutch names, ask edwardk :p The "van" is only lowercase when in the middle of a name :)
05:20:45 <yitz> merijn: aha. ok then. thanks for the heads-up. :)
05:20:53 <merijn> yitz: Basically, the trumping rule for Dutch names is that first letters of names are *always* capitalised, so it's "Twan van Laarhoven" and "T. van Laarhoven", but "Van Laarhoven"
05:21:02 <edwardk> merijn: will you be at zurihack?
05:21:26 * pjdelport points to https://en.wikipedia.org/wiki/Van_(Dutch)#Collation_and_capitalisation
05:22:41 <pjdelport> The rule comparable to "Foo of Bar" vs. "Of Bar", for an English title of something.
05:23:09 <merijn> edwardk: No, June is already crazy busy for me (PLDI and Oregon PL summer school), so the timing of that being in the weekend before PLDI is just too much for me
05:23:30 <edwardk> merijn: fair nuff
05:23:43 <Eelis> merijn: hm, but then is it "Van Der Weegen" or "Van der Weegen" ?
05:24:00 <merijn> Eelis: The latter
05:24:05 <Eelis> ok, thanks
05:33:09 <poucet> Anyone know if Martijn van SteenBergen can be reached here?
05:37:39 <phaazon_> hi
05:37:42 <phaazon_> http://stackoverflow.com/questions/23911496/relation-between-object
05:37:42 <fragamus> edwardk: I was using cmath's cbrt and now I have had to modernize my GHC, leaving me without cbrt which depends on unsafePerformIO.    NOW.... I am thinking of using (**1/3) as an initial guess to newton's method and I stumbled across Numeric.AD.Newton
05:37:48 <phaazon_> if you’re interested in ;)
05:38:01 <fragamus> is there a cube root example for Numeric.AD.Newton
05:38:40 <edwardk> fragamus: not off hand, but feel free to add it. there is also numeric-extras
05:38:47 <fragamus> (**1/3) is not accurate
05:39:04 <bennofs> :t (** (1%3))
05:39:05 <lambdabot> (Integral a, Floating (Ratio a)) => Ratio a -> Ratio a
05:39:41 <phaazon_> edwardk: you might be interested by my SO link
05:39:56 <Maior> phaazon_: I'm afraid I agree with Aadit though
05:40:24 <phaazon_> Maior: what do you mean?
05:40:26 <phaazon_> no answer ?
05:40:46 <Maior> phaazon_: it doesn't fit SO question guidelines
05:41:21 <phaazon_> hm, ok, then where could I ask that?
05:41:26 <phaazon_> reddit haskell?
05:42:58 <Maior> phaazon_: that's probably a good place
05:43:03 <warpy> programmers.stackexchange.com
05:45:21 <phaazon_> but don’t you guys have an idea?
05:48:48 <merijn> There used to be a nice article by Cale on "Functional OO", but I don't have the link anymore
05:50:23 <phaazon_> merijn: hm
05:50:30 <phaazon_> so you think that relation between values is OO?
05:51:08 <pjdelport> phaazon_: What you're talking about sounds a bit like the semantic web and RDF
05:51:16 <edwardk> phaazon_: this sort of thing is why i use classy lenses
05:51:45 <pjdelport> phaazon_: In a programming context, something like a triplestore
05:52:07 <phaazon_> huhu
05:52:18 <phaazon_> I read about RDF and it’s similar indeed
05:52:33 <phaazon_> but it’s more about graphics in my case
05:52:48 <bennofs> phaazon_: To me, this sounds a lot like: http://en.wikipedia.org/wiki/Entity_component_system
05:53:06 <phaazon_> I really wonder how others do, for instance for lambdacube, or they don’t use entity semantics
05:53:12 <phaazon_> bennofs: I’m gonna read that, thank you
05:53:58 <merijn> Ugh, there's a 3D graphics library called lambdacube? :(
05:54:11 <merijn> Well, that's not confusing and ruining google rankings
05:54:11 <phaazon_> yes
05:54:16 <phaazon_> it’s not an engine though
05:54:22 <phaazon_> only a thin 3D EDSL
05:54:27 <phaazon_> oh bennofs
05:54:28 <phaazon_> Entity: The entity is a general purpose object. Usually, it only consists of a unique id.
05:54:33 <int-e> merijn: there's also a company called Galois connections, I don't know which is worse :P
05:54:34 <phaazon_> that’s _exactly_ how I do thing
05:54:37 <phaazon_> so yeah
05:54:43 <phaazon_> I might be representing ECS :)
05:55:36 <bennofs> merijn: why should it ruin google rankings?
05:56:20 <bennofs> ah, there is a lambda cube in maths too :|
05:56:34 <merijn> bennofs: The lambda cube is a very famous paper in type theory
05:57:14 <merijn> bennofs: It proposes three orthogonal axis upon which to extend the simply typed lambda calculus, effectively resulting in a conceptual cube of lambda calculus permutations
05:57:19 * hackagebot fay-builder 0.2 - Compile Fay code on cabal install, and ad-hoc recompile during development  http://hackage.haskell.org/package/fay-builder-0.2 (ErikHesselink)
05:57:20 <bennofs> merijn: lambdacube (the engine) is even ranked before the wikipedia article on the type-theory meaning on google
05:57:25 <bennofs> :o
05:57:39 <MagneticDuck> @type flip id . flip id
05:57:40 <lambdabot> a -> (((a -> c1) -> c1) -> c) -> c
05:57:42 <MagneticDuck> mmmm
05:58:13 <bennofs> :t flip ($) . flip ($)
05:58:14 <lambdabot> a -> (((a -> c1) -> c1) -> c) -> c
05:58:39 <MagneticDuck> id is better than ($)
05:58:46 <MagneticDuck> but yeah they're the same thing =P
05:59:08 <MagneticDuck> @type flip flip id
05:59:09 <lambdabot> (a -> (a1 -> a1) -> c) -> a -> c
05:59:26 <MagneticDuck> mmmmm
05:59:27 <bennofs> those types look crazy
05:59:32 <MagneticDuck> they are crazy
05:59:39 <MagneticDuck> @type flip flip
05:59:40 <lambdabot> b -> (a -> b -> c) -> a -> c
06:00:18 <MagneticDuck> type-foo
06:00:23 <bennofs> is flip flip flip
06:00:36 <MagneticDuck> @type flip flip flip flip flip flip
06:00:37 <lambdabot> (a1 -> ((a -> b -> c) -> b -> a -> c) -> c1) -> a1 -> c1
06:00:41 <MagneticDuck> I don't expect to understand it
06:00:43 <MagneticDuck> xD
06:00:47 <bennofs> are sequences of flips also equal to shorter sequences, like fmap?
06:00:58 * MagneticDuck investigates
06:01:19 <yitz> bennofs: doesn't look like it.
06:01:36 <MagneticDuck> haskell is full of suprises
06:01:38 <yitz> bennofs: there seems to be a clear pattern, and it grows.
06:01:46 <bennofs> @ty flip flip flip flip flip flip flip flip flip flip flip flip flip flip flip flip flip flip flip flip flip flip flip flip flip flip flip
06:01:47 <lambdabot> (a1 -> ((a -> b -> c) -> b -> a -> c) -> c1) -> a1 -> c1
06:01:50 <k00mi> MagneticDuck: so is C++ ;)
06:01:54 <bennofs> @type flip flip flip flip flip
06:01:55 <lambdabot> (a1 -> ((a -> b -> c) -> b -> a -> c) -> c1) -> a1 -> c1
06:01:58 <MagneticDuck> yeah but that's different :D
06:02:00 <yitz> hmm how about that
06:02:03 <bennofs> thos types are equal, aren't they?
06:02:04 <mno2> ewb
06:02:07 <MagneticDuck> yes
06:02:22 <jg_> hi all. i'm installing hakyll with cabal 1.20 and getting 'setup: The program 'alex' is required but it could not be found.' (on pandoc dependency install); though alex is installed and in path...; anyone seen this?
06:02:27 <MagneticDuck> after a sequence of flips has a type of "a -> b -> c", it just cycles between that and "b -> a -> c" from there on
06:02:35 <MagneticDuck> taa daa
06:02:42 <MagneticDuck> that was dissapointing
06:03:15 <MagneticDuck> uh.
06:03:19 <MagneticDuck> wait what
06:03:20 <bennofs> MagneticDuck: but wouldn't that only apply if it was flip $ flip $ flip $ ...
06:03:22 <bennofs> ?
06:03:22 <MagneticDuck> yeah
06:03:26 <MagneticDuck> >_<
06:03:35 <MagneticDuck> spoke too soon, now I look silly
06:03:38 <MagneticDuck> it's interesting after all
06:05:24 <merijn> jg_: Check whether it's the right version of alex?
06:05:40 <bennofs> Is there a function f which can be chained infinitely (like f f f f f f f f ...) and where longer sequences are not equal to shorter ones?
06:06:18 <merijn> bennofs: Define "not equal to"
06:06:20 <arj> bennofs: what do you mean by "longer sequences are not equal". the result?
06:06:32 <bennofs> merijn: don't have equal types (not like fmap or flip)
06:07:46 <jg_> merijn: turns out https://groups.google.com/forum/#!topic/pandoc-discuss/fFOY75v6_X0 contains the solution, had to remove the shell expansion from PATH
06:08:49 <djbeau> does anyone know the generally intended replacement strategy for the deprecated mtl-tf?
06:08:58 <fragamus> argh who is maintaining cmath
06:09:01 <bennofs> djbeau: use just mtl?
06:09:37 <djbeau> is that saying that using the functional dependencies is preferred over type families?
06:09:49 <djbeau> I thought type families were cool these days
06:10:03 <fragamus> dons@galois.com <--- stale email address for cmath maintainer
06:10:49 <bennofs> fragamus: try dons00 (at) gmail.com
06:10:58 <bennofs> fragamus: from http://donsbot.wordpress.com/about/
06:11:23 <merijn> djbeau: fundeps are considered "easier" to implement than type families, making mtl more portable to other compilers than mtl-tf
06:12:20 <yitz> MagneticDuck: looks to me like it begins repeating starting with 3 flips
06:13:46 <yitz> @. djin type flip flip flip
06:13:46 <lambdabot> Plugin `compose' failed with: Unknown command: "djin"
06:13:53 <yitz> @. djinn type flip flip flip
06:13:55 <lambdabot> f a b = a b (\ c d e -> c e d)
06:13:59 <yitz> @. djinn type flip flip flip flip
06:14:00 <lambdabot> f a b = a b (\ c d e -> c e d)
06:14:11 <yitz> @. djinn type flip flip flip flip flip
06:14:12 <lambdabot> f a b = a b (\ c d e -> c e d)
06:14:19 <yitz> etc.
06:14:40 <djbeau> merijn: ok, fair enough - so do type families still find good use cases where fundeps don't suffice?
06:16:19 <merijn> djbeau: Sure, especially with all the fancy DataKinds and closed type families stuff in new GHCs
06:16:31 <djbeau> merijn: although I don't personally don't think the implementation argument is strong enough to mark mtl-tf as "deprecated"
06:17:09 <djbeau> merijn: yeah, I have only read about those aspects briefly but haven't used it much yet
06:17:11 <merijn> djbeau: It's deprecated cause everyone's using mtl, which afaik does the exact same things as mtl-tf, but more portably
06:17:25 <MagneticDuck> yitz: yeah
06:17:26 <Clint> except for the two things that use monads-tf
06:18:05 <djbeau> merijn: I will certainly accept the lack-of-use argument :)
06:18:11 <merijn> djbeau: So the reason it's deprecated is to avoid more people using it over mtl, because mtl is better tested, etc.
06:19:23 <bennofs> and to avoid an ecosystem split so that not half the people use mtl-tf, the other half use mtl
06:19:49 <djbeau> ok, so I think what threw me off is that the I took the mere creation of mtl-tf as a gentle "push" towards using type families going forward, but it looks like most folks backed away from that
06:19:58 <djbeau> bennofs: right
06:20:13 <bennofs> @. djinn type const const
06:20:15 <lambdabot> f _ a _ = a
06:20:18 <bennofs> @. djinn type const const const
06:20:19 <lambdabot> f a _ = a
06:21:05 <djbeau> (at least backed away from using type families in monad transformer classes)
06:21:39 <merijn> djbeau: Right, it was a push in that direction, but the consensus was: 1) it doesn't really gain you anything 2) it's less portable to different compilers
06:22:09 <merijn> djbeau: Therefore, people went back to mtl. But that line of reasoning does not apply to type families in general
06:22:10 <bennofs> :t (>>=) (>>=)
06:22:11 <lambdabot> Monad m => (((a -> m b1) -> m b1) -> m a -> b) -> m a -> b
06:22:15 <bennofs> :t (>>=) (>>=) (>>=)
06:22:17 <lambdabot>     Occurs check: cannot construct the infinite type: m ~ (->) (m b)
06:22:17 <lambdabot>     Expected type: ((a -> m b) -> m b) -> m a -> (a -> m b) -> b1
06:22:17 <lambdabot>       Actual type: ((a -> m b) -> m b)
06:22:18 <bennofs> :o
06:23:13 <djbeau> merijn, bennofs: thx, you have provided a lot of interesting background
06:25:25 <yitz> MagneticDuck: because if f a b = a b x, then f flip b q = flip b x q = b q x = f b q
06:27:57 <yitz> bennofs: use (>=>) instead
06:28:03 <yitz> @type (>=>)
06:28:04 <lambdabot> Monad m => (a -> m b) -> (b -> m c) -> a -> m c
06:28:09 <bennofs> :t (>=>) (>=>) (>=>)
06:28:11 <lambdabot> Monad m => (a -> m b) -> (b -> m b) -> a -> m b
06:28:13 <yitz> @type (>=>) (>=>) (>=>) (>=>) (>=>) (>=>)
06:28:14 <lambdabot> Monad m => ((a -> m c) -> (b -> m c) -> a -> m c) -> (a -> m b) -> (b -> m c) -> a -> m c
06:28:16 <yitz> @type (>=>) (>=>) (>=>) (>=>) (>=>) (>=>) (>=>) (>=>) (>=>) (>=>)
06:28:18 <lambdabot> Monad m => ((a -> m c) -> (b -> m c) -> a -> m c) -> (a -> m b) -> (b -> m c) -> a -> m c
06:28:23 <bennofs> @type (>=>) (>=>) (>=>) (>=>) (>=>) (>=>) (>=>)
06:28:24 <lambdabot> Monad m => (a -> m b) -> (b -> m b) -> a -> m b
06:28:34 <bennofs> it "toggles" between two types after a treshold
06:29:27 <MagneticDuck> !
06:29:34 <bennofs> this feels alot like the sequences of numbers that are generated if you repeatly double a starting number and take it `mod` something
06:29:38 <MagneticDuck> types are interesting
06:29:39 <bennofs> s/alot/a lot
06:30:41 <bennofs> well, doubling is probably too simple, but do something else.
06:35:25 * Maxdamantus wonders if there'd be anything illogical with generalising `forall` to uses of some `Any` class.
06:36:11 <Maxdamantus> (.) :: (Any a, Any b, Any c) => (a -> b) -> (b -> c) -> (a -> c)
06:36:58 <hexagoxel> Maxdamantus: what about constraints?
06:37:14 <Maxdamantus> hexagoxel: what about what constraints?
06:37:16 <yitz> @type (.)
06:37:17 <lambdabot> (b -> c) -> (a -> b) -> a -> c
06:37:33 <yitz> oh they reverted the caleskell definition
06:37:45 <KorriX> Hi! Is there any good OpenGLRaw tutorial?
06:37:57 <Maxdamantus> er, yeah, I had the arguments backwards.
06:38:16 <Maxdamantus> s/^/flip /
06:40:43 <bergey> KorriX: I haven't seen one.  It's pretty close to C OpenGL; unlike the higher level stuff, you should do OK following C tutorials.  Just try to find a modern tutorial, without the glBegin / direct-mode stuff.  Modern OpenGL matches haskell much better.
06:41:03 <mikusp> Hi. I have a hard time understanding code involving foreign function call. Simplified version of my current code looks like this: http://lpaste.net/104753 . What is the reason for the output to appear reordered?
06:42:10 <KorriX> bergey: I'm trying to write completely windowless app and that seems not possible with OpenGLRaw binding...
06:42:24 * hackagebot Paraiso 0.3.1.3 - a code generator for partial differential equations solvers.  http://hackage.haskell.org/package/Paraiso-0.3.1.3 (TakayukiMuranushi)
06:42:45 <geekosaur> mikusp: because Haskell does not use C's stdio, so most likely its buffer only gets flushed when C stdio is finalized during program exit
06:43:09 <ion> mikusp: The GHC runtime and the C library do independent output buffering. Flush the output from both when appropriate to be sure.
06:43:14 <KorriX> bergey: I have found some thread on StackOverflow http://stackoverflow.com/questions/12482166/creating-opengl-context-without-window but there are no matching functions in OpenGLRaw
06:43:22 <awestroke> mikusp: you could try doing some flush of stdout in your c++ code
06:43:43 <mikusp> using which c/c++ function?
06:44:06 <ion> @google c flush stdout
06:44:07 <lambdabot> http://stackoverflow.com/questions/1716296/why-does-printf-not-flush-after-the-call-unless-a-newline-is-in-the-format-strin
06:44:07 <lambdabot> Title: c - Why does printf not flush after the call unless a newline is in the forma...
06:44:33 <geekosaur> you used printf, which is C, so you should use C's fflush
06:44:50 <geekosaur> and yes I am not ure why it didn't flush on newline, did you redirect output to a file?
06:44:57 <geekosaur> terminals are normally line buffered
06:45:24 <mikusp> actually in my code it didn't contain newline, I didn't think that it would matter
06:45:41 <mikusp> I'll see if fflush will help
06:46:35 <bergey> KorriX: That's interesting.  I haven't tried OpenGL without a window, so I'm not sure this will work.   The SO advice to create a window but make it invisible seems good.  GLFW-b for instance has WindowHint'Visible.  (I'm not familiar with GLUT or SDL.)  What are you using to create your context?
06:47:23 <KorriX> bergey: GLUT for now, but I'd like to not use it :)
06:47:35 <bergey> I've been happy with GLFW-b so far.
06:48:59 <KorriX> bergey: Can you push any example tying up GLFW with OpenGLRaw (I'd like to see how to handle framebuffers)
06:49:31 <bergey> I don't actually use OpenGLRaw for anything, so I can't quickly put together such an example.
06:49:33 <t7> i tried a while ago to create openGL context without running X, but it wasnt really possible outside of using mesa software driver
06:49:59 <t7> when EGL gets more acceptance it will be easy
06:50:18 <bergey> The examples I have are at https://github.com/bergey/haskell-OpenGL-examples  If you put together something with GLFW-b and OpenGLRaw, I'd love to add it.
06:50:54 <KorriX> bergey: Ok :). I really want to do quite simple thing - Just load jpg, apply two-pass blur [via GLSL shader] and save result into some other jpg
06:51:36 <bergey> OpenGL does seem to make easy things hard. :)
06:55:41 <mikusp> geekosaur, ion, awestroke: thanks, adding explicit flushing helped :)
06:59:56 <killy9999> what is the meaning of empty instance declarations like "instance Arrow Foo where", where Foo is a non-empty datatype?
07:00:12 <killy9999> what is the meaning of empty instance declarations like "instance Arrow Foo where", where Foo is a non-empty datatype?
07:00:36 <edwardk> killy9999: an empty instance declaration is taking default definitions for all the members
07:00:48 <edwardk> killy9999: if they exist. in the case of arrow, many do not have defaults
07:01:05 <edwardk> killy9999: so what happens is things like arr get set to errors
07:01:34 <killy9999> edwardk: thanks
07:01:49 <edwardk> @let data Foo = Foo
07:01:51 <lambdabot>  Defined.
07:02:05 <edwardk> @let instance Monoid Foo
07:02:06 <lambdabot>  .L.hs:156:10: Warning:
07:02:06 <lambdabot>      No explicit implementation for
07:02:06 <lambdabot>        ‘mempty’ and ‘mappend’
07:02:06 <lambdabot>      In the instance declaration for ‘Monoid Foo’
07:02:06 <lambdabot>  
07:02:16 <edwardk> > mempty :: Foo
07:02:17 <lambdabot>  No instance for (Data.Monoid.Monoid L.Foo)
07:02:17 <lambdabot>    arising from a use of ‘Data.Monoid.mempty’
07:02:25 <edwardk> hrmmph
07:02:26 * hackagebot carettah 0.3.0 - A presentation tool written with Haskell.  http://hackage.haskell.org/package/carettah-0.3.0 (KiwamuOkabe)
07:02:48 <edwardk> works in the repl ;)
07:06:05 <killy9999> BTW. do such instances have any practical use, aside maybe from some fancy type-level tricks?
07:06:59 <mornfall> edwardk: what does "works" in this context mean? :)
07:07:49 <edwardk> mornfall: runtime error not compile time error
07:08:08 <freezerburnv> Morning all
07:08:10 <edwardk> killy9999: yes, several classes can be defined entirely by Typeable or Generic constraints using default signatures.
07:08:44 <mornfall> oh
07:08:44 <edwardk> killy9999: other classes have similar sensible defaults using default signatures in terms of other classes as well
07:09:02 <mornfall> edwardk: sorry I misread, I somehow thought Foo was empty, not unit
07:09:09 <Sculptor> hello
07:09:19 <edwardk> mornfall: even there, same system works
07:09:37 <edwardk> mornfall: 'mempty' there is an error in both cases, since we didn't specify
07:10:02 <mornfall> edwardk: hmm, well, I guess it could be defined to undefined
07:10:10 <killy9999> edwardk: ah, poor-man's standalone deriving :-)
07:10:10 <edwardk> thats what you get
07:11:10 <edwardk> error in the mempty = error *** Exception: <interactive>:28:10-19: No instance nor default method for class operation Data.Monoid.mempty
07:11:44 <jdiez> hi guys, I'm just getting my feet wet with Haskell - I'm going to try to write a sudoku solver
07:11:56 <edwardk> jdiez: fun project
07:11:59 <jdiez> I'd like to constrict values to 1-9, can I do this with haskell's type system?
07:12:07 <jdiez> I've looked into smart constructors but they don't seem powerful enough
07:12:07 <jdiez> http://www.haskell.org/haskellwiki/Smart_constructors
07:12:17 <jdiez> and the peano arithmetic stuff is cute, but impractical
07:12:44 <jdiez> ideally I'd like to have types like:
07:12:50 <mornfall> jdiez: you can always data T = T1 | T2 | T3 ... | T9 :-)
07:13:03 <edwardk> jdiez: data Digit = D1 | D2 | D3 | D4 | D5 | D6 | D7 | D8 | D9 deriving (Eq,Ord,Show,Read)
07:13:20 * killy9999 was recently close to writing type-level sudoku solver
07:13:26 <jdiez> edwardk, mornfall: how can I Read that?
07:13:36 <edwardk> @let data Digit = D1 | D2 | D3 | D4 | D5 | D6 | D7 | D8 | D9 deriving (Eq,Ord,Show,Read)
07:13:39 <lambdabot>  Defined.
07:13:41 <jdiez> read "1" :: Digit <- will it work?
07:13:43 <awestroke> killy9999: did you run into any problem?
07:13:44 <edwardk> > read "D1" :: Digit
07:13:46 <lambdabot>  D1
07:13:49 <jdiez> ah :)
07:13:50 <jdiez> well
07:13:50 <mornfall> jdiez: you can either use the automatic instance or write one that uses 1, 2 ...
07:13:57 <edwardk> @undefine
07:13:58 <lambdabot> Undefined.
07:13:58 <killy9999> awestroke: yeah. I'm trying to recall what it was
07:14:10 <edwardk> @let data Digit = D1 | D2 | D3 | D4 | D5 | D6 | D7 | D8 | D9 deriving (Eq,Ord,Show,Read,Enum)
07:14:13 <lambdabot>  Defined.
07:14:18 <killy9999> I thing that at that point I didn't have type-level subtraction
07:14:23 <edwardk> > fromEnum 3 :: Digit
07:14:25 <lambdabot>  Couldn't match expected type ‘L.Digit’
07:14:25 <lambdabot>              with actual type ‘GHC.Types.Int’
07:14:28 <edwardk> > toEnum 3 :: Digit
07:14:30 <lambdabot>  D4
07:14:34 <edwardk> they start at 0
07:14:35 <killy9999> to be clear: it was a bit cheating since I was using singletons libraru
07:14:39 <jdiez> hmm, that's a bit better
07:14:41 <mornfall> edwardk: is the derived Ord instance defined to reflect the order of constructors in the definition?
07:14:48 <killy9999> to promote term-level code to type level
07:14:49 <edwardk> mornfall: yes
07:15:00 <edwardk> > D1 < D3
07:15:02 <lambdabot>  True
07:15:17 <armlesshobo> > fromEnum D4
07:15:18 <lambdabot>  3
07:15:19 <BoR0> > let f x = 'D':x in (read f "1" :: Digit)
07:15:20 <lambdabot>  Couldn't match type ‘[GHC.Types.Char] -> [GHC.Types.Char]’
07:15:21 <lambdabot>                with ‘[GHC.Types.Char]’
07:15:21 <lambdabot>  Expected type: GHC.Base.String
07:15:21 <lambdabot>    Actual type: [GHC.Types.Char] -> [GHC.Types.Char]
07:15:51 <Guest84455> hi, I need some help with REST POST queries,...please anybody?
07:15:51 <jdiez> @let sudokuDigit n = toEnum n-1 :: Digit
07:15:52 <edwardk> anyways with that and a little but of +/- 1 you can get the numbers you want and an intermediate data type you can cover all cases you want with
07:15:52 <lambdabot>  .L.hs:160:26:
07:15:52 <lambdabot>      No instance for (Num Digit) arising from a use of ‘-’
07:15:52 <lambdabot>      In the expression: toEnum n - 1 :: Digit
07:15:52 <lambdabot>      In an equation for ‘sudokuDigit’:
07:15:52 <lambdabot>          sudokuDigit n = toEnum n - 1 :: Digit
07:15:59 <jdiez> ah
07:16:01 <BoR0> > let f x = 'D':x in read (f "1") :: Digit
07:16:02 <lambdabot>  D1
07:16:04 <jdiez> @let sudokuDigit n = toEnum (n-1) :: Digit
07:16:06 <lambdabot>  Defined.
07:16:12 <jdiez> >sudokuDigit 1
07:16:17 <jdiez> > sudokuDigit 1
07:16:19 <lambdabot>  D1
07:16:23 <ReinH>  You don't actually need numbere for sudoku, just 9 distinct elements
07:16:42 <jdiez> BoR0: that's cool
07:16:55 <edwardk> ReinH: yeah i used 25 distinct IPA symbols once for a mega-sudoku
07:17:15 <jdiez> edwardk: okay, now imagine I want to restrict the space to 200-500
07:17:22 <jdiez> defining every possible input is impractical
07:17:28 <jdiez> is there a simple way to do this?
07:17:37 <jdiez> (no longer talking about sudokus)
07:17:46 <edwardk> jdiez: then don't, make up a data type, control admission to it by making some kind of smart constructor
07:17:55 <awestroke> data SudokuDigit = Orange | Apple | PHP | BugFix | Carpenter | BruceWillis | Death | Taxes deriving (Eq, Ord, Show, Read, Enum)
07:17:59 <mornfall> jdiez: what's too limited about smart constructors?
07:18:07 <jdiez> edwardk: but then it's no longer statically type-checked…
07:18:27 <mornfall> jdiez: it is...
07:18:28 <jdiez> mornfall: the fact that they don't provide static safety
07:18:34 <mornfall> jdiez: they do :-)
07:18:39 <jdiez> what? then I'm lost...
07:18:50 <mornfall> jdiez: well, you can't expose the normal constructor
07:18:55 <edwardk> newtype JDiez = JDiez { unjdiez :: Int }; check :: Int -> Maybe JDiez; check x | x >= 200 && x <= 500 = JDiez x | otherwise = Nothing -- now give noone access to the JDiez constructor
07:18:58 <mornfall> jdiez: need to hide the type and its operations in a module
07:19:09 <jdiez> oh, that's cool
07:19:10 <ReinH> Only if all operations on them are provably total
07:19:11 <edwardk> ust export the type JDiez nd he unjdiez function
07:19:11 <jdiez> using Maybe
07:19:21 <jdiez> I see
07:19:22 <jdiez> cool, cool
07:19:25 <ReinH> Er closed
07:19:33 <edwardk> er x >= 200 && <= 500 = Just (JDiez x)
07:19:37 <jdiez> all of this haskell stuff is severely mindblowing
07:20:26 <mornfall> ReinH: closedness is obvious from the types, no proving required
07:20:36 <mornfall> ReinH: but you can have projections out of the type too
07:20:41 <mornfall> not a big deal
07:20:49 <edwardk> jdiez: i've been writing haskell for several years now and get my mind blown by it regularly. the pace slows down a bit, but doesn't stop
07:20:49 <ReinH> mornfall: in this contrived instance, yes
07:21:14 <ReinH> Usually types let you do more than just construct them
07:21:23 <jdiez> edwardk: that gives me hope. I'm fairly young (19) but I'm getting pretty bored by programming already
07:21:42 <mornfall> ReinH: OK, what do you mean by closed?
07:21:59 <alpounet> jdiez: the same happened to me, when I was ~ your age
07:22:06 <alpounet> then I discovered Haskell
07:22:11 <alpounet> it's been 6 years now I think
07:22:20 <zerokarmaleft> jdiez: haskell is the most fun I've had programming yet
07:22:25 <ReinH> Operations that return that type should always return a valid value
07:22:59 <alpounet> jdiez: and i could spend all day talking about things I yet have to understand, you know some obscure blog posts that make my head hurt or a paper about something smart GHC is doing
07:23:00 <jdiez> zerokarmaleft, alpounet: yeah. I'm almost done reading LYAH and I haven't done anything significant in Haskell yet but I've looked at some code and marvelled at it
07:23:12 <mornfall> ReinH: Ok, I guess what you mean is that when I write foo : Closed -> Closed, foo actually gives you a Closed
07:23:22 <ReinH> Right
07:23:35 <ReinH> One that satisfies check
07:23:43 <alpounet> jdiez: yeah, well, if you like it so far, you'll probably stick around for a while :-)
07:23:50 <mornfall> ReinH: from the outside, it's closed by definition, but it may fail invariants yes
07:23:58 <mornfall> ReinH: since it's implemented in terms of some other types
07:24:13 <jdiez> alpounet: the novelty of quicksort hasn't worn off yet, either
07:24:34 <jdiez> alpounet: every now and then I fire up ghci and type it and see it work the first time, and feel excited about it
07:24:45 <ReinH> Well yes, the invariants are what matter here.
07:24:54 <proudlygeek> exit
07:25:45 <alpounet> jdiez: heh, the thing is: working your way through haskell and all the smart techniques/libraries we have etc makes you feel like this on a spectacularly regular basis
07:25:53 <ReinH> Smart constructors are nice for constructing such values but don't offer any assistance in working wit them. You have to maintain your own invariants.
07:26:40 <mornfall> ReinH: it does, it checks the invariant at runtime
07:26:59 <mornfall> ReinH: if you de-construct the operand(s), you have to re-construct the result
07:27:05 <mornfall> ReinH: not optimal, of course
07:27:19 <MagneticDuck> hmm... is there any sort of simple number theory library out there?
07:27:30 <mornfall> ReinH: the other option is to not offer deconstruction, and maintain a correct implementation within the type's module
07:27:54 <mornfall> ReinH: that implementation is however where you fail to get static guarantees
07:27:55 <ReinH> mornfall: I see what you're saying.
07:28:02 <MagneticDuck> like, fast factorization, the whole host of (hopefully optimized) routines, prime sieving, etc?
07:28:23 <MagneticDuck> I don't need anything complicated
07:28:39 <mornfall> MagneticDuck: famous last words :D
07:28:41 <MagneticDuck> just something so I don't have to write my own little library or constantly define the same functions (doing project euler)
07:28:43 <MagneticDuck> hehe yeah
07:28:47 <ReinH> What I'm taking about are any provided library functions that manipulate the type itself, yes
07:29:03 <monochrom> MagneticDuck: consider arith-moi
07:29:11 <jdiez> MagneticDuck: half of the fun in project euler is writing those routines yourself
07:29:16 <mornfall> ReinH: for the implementation part, you are possibly looking at a theorem prover, or at least a dependently typed language
07:29:16 <MagneticDuck> yeah
07:29:23 <jdiez> MagneticDuck: going from naive-prime-sieve to clever-prime-sieve
07:29:27 <ReinH> mornfall: yep
07:29:35 <MagneticDuck> well alright
07:30:07 <MagneticDuck> I mean.. some of the harder ones kind of assume you already know how to make a prime sieve =P
07:30:18 <ReinH> The Euler problems are designed to require problem-solving techniques, not library-using techniques :p
07:30:22 <MagneticDuck> yeah
07:30:24 <MagneticDuck> I understand that
07:30:33 <ReinH> MagneticDuck: then reuse the one you wrote earlier
07:30:46 <ReinH> Make your own library as you go
07:30:49 <MagneticDuck> I'll probably end up writing my own library
07:30:50 <MagneticDuck> yeah
07:30:53 <MagneticDuck> xD
07:33:46 <mornfall> ReinH: non, you didn't get it ... you are supposed to get libeuler from hackage and type in e1 as the solution the first exercise, e2 for the second and so on
07:33:55 <KorriX> Is there any way to convert Repa 2D array into OpenGL texture?
07:34:09 <MagneticDuck> mornfall: lol
07:34:18 <ReinH> mornfall: ah I see
07:34:20 <chrisdone> reinh: when's ollie gonna be on haskellcast?
07:34:28 <chrisdone> ocharles :3
07:34:38 <ReinH> Next :p
07:35:02 <klrr_> ReinH: what is the next one about ? :)
07:35:12 <ReinH> chrisdone
07:35:22 <chrisdone> > _>
07:35:23 <klrr_> oh cool
07:35:24 <lambdabot>  <hint>:1:3:
07:35:24 <lambdabot>      parse error (possibly incorrect indentation or mismatched brackets)
07:35:27 <mornfall> ReinH: that's how they do it in Java anyway and Java is the industry leader afterall
07:35:30 <ReinH> :)
07:35:37 <klrr_> like interview?
07:35:39 <chrisdone> reinh: check this (WIP) http://haskell-lang.org/
07:35:41 <klrr_> or some topic
07:36:06 <chrisdone> hm, can someone with windows please check that the site looks the same on IE as normal browsers?
07:36:31 <chrisdone> klrr_: just fay and emacs stuff =)
07:36:51 <klrr_> sounds interesting, im using emacs but i doubt i utilize its full power
07:37:08 <ReinH> Awesome
07:38:19 <bennofs> chrisdone: it's a bit confusing that if I click on "Downloads" on the main page, the "Downloads" link changes the position (after loading the new package, it's no longer under my cursor if i don't move it)
07:38:30 <bennofs> s/package/page
07:38:45 <bennofs> IMO
07:39:02 <ocharles> hi chrisdone :)
07:39:19 <chrisdone> ohaicharles
07:39:44 <shapr> hi chrisdone!
07:39:50 <solidus-river> 'mornin all
07:39:54 <klrr_> not that i dislike chrisdone or the other guy on reddit a few days ago's designs, they look quite good (especially chrisdone's), but what is exactly the problem with the current web page?
07:39:54 <luite> chrisdone: not bad :) (i don't have IE here though)
07:40:10 <solidus-river> can anyone give me a real world example of a co-algebra that works great alongside an algebra
07:40:22 <solidus-river> the best example of co-algebra's i've found is lens / store
07:40:47 <solidus-river> and those dont seem to really work well with anything in particular, they are just good constructs to work with
07:41:13 <solidus-river> but everything that talks about comonads talks about how its great how they interact with monads
07:41:16 <edwardk> solidus-river: play with anamorphisms
07:41:41 <edwardk> solidus-river: actually every interaction of a comonad and a monad in the style put forth by sigfpe or uustalu is quite terrible
07:41:58 <edwardk> they keep tryng to make it work, but both complain about how it blows up on them
07:42:09 <chrisdone> klrr_: maybe nothing's wrong with the current page, and these are just righter =)
07:42:22 <chrisdone> shapr ^_^
07:42:31 <edwardk> better to work with a comonad of the kleisili categoy of some monad (or less likely, a monad over the cokleisli category of some comonad)
07:42:37 <chrisdone> luite: i think not bad from luite is high praise =p
07:42:48 <edwardk> then you get sharing
07:43:18 <edwardk> as for coalgebras and algebras working together, hylomorphisms
07:43:35 <chrisdone> bennofs: i don't think that's a big deal. if you click downloads it's because you want to download something, not click all the menu buttons in sequence to test a design
07:43:44 <edwardk> or jeremy gibbons work on metamorphisms for streaming digits of pi
07:43:55 <edwardk> @where pi_10
07:43:55 <lambdabot> (!!3)<$>transpose[show$foldr(\k a->2*10^2^n+a*k`div`(2*k+1))0[1..2^n]|n<-[0..]]
07:43:58 <MagneticDuck> grr, is there anywhere (\f n -> foldl (.) id (replicate n f)) is defined?
07:44:03 <edwardk> > (!!3)<$>transpose[show$foldr(\k a->2*10^2^n+a*k`div`(2*k+1))0[1..2^n]|n<-[0..]]
07:44:04 <lambdabot>  can't find file: L.hs
07:44:09 <edwardk> bah
07:44:15 <shapr> Why does it do that?
07:44:18 <edwardk> @undefine
07:44:18 <solidus-river> edwardk: yeah, every thing i think up could be solved by either a monad or a comonad and one fits better than the other
07:44:18 <lambdabot> Undefined.
07:44:23 <edwardk> > (!!3)<$>transpose[show$foldr(\k a->2*10^2^n+a*k`div`(2*k+1))0[1..2^n]|n<-[0..]]
07:44:25 <lambdabot>  "314159265358979323846264338327950288419716939937510582097494459230781640628...
07:44:32 <ocharles> chrisdone: inb4 "OMG QUICKSORT IS A TERRIBAL EXAMPLE"
07:44:37 <solidus-river> but when i think about them interacting it just seems messy and needlessly complicated compared to just using one
07:44:49 <chrisdone> ocharles: yeah i intentionally avoided quicksort
07:44:50 <cschneid> edwardk: off by a power of 10 :)
07:44:57 <cschneid> err, by a decimal
07:45:04 <ocharles> chrisdone: a wise move :)
07:45:05 <edwardk> solidus-river: well often you have a structure m that is both, but which they are at least somewhat related. in Hask that happens with things like non-empty lists, etc.
07:45:10 <edwardk> or (,) e for e a Monoid
07:45:14 <chrisdone> ocharles: i was thinking it would be neat to archive cool haskell examples of short elegance in the wiki, and then randomly show a sample in the header. when you click it takes you to a page explaining it
07:45:25 <edwardk> solidus-river: in other categories we have interesting Hopf algebras
07:45:44 <MagneticDuck> ^ any ideas for my previous question?
07:45:51 <edwardk> solidus-river: e.g. vector spaces have lots of things where both the monad and comonad like structure are interesting
07:46:05 <MagneticDuck> @hoogle (Integral i) => i -> (a -> b) -> a -> b
07:46:07 <lambdabot> Prelude maybe :: b -> (a -> b) -> Maybe a -> b
07:46:08 <lambdabot> Data.Maybe maybe :: b -> (a -> b) -> Maybe a -> b
07:46:08 <lambdabot> Data.Data gmapQi :: Data a => Int -> (forall d. Data d => d -> u) -> a -> u
07:46:11 <MagneticDuck> nope
07:46:29 <MagneticDuck> .___. like seriously? I have to type "foldl (.) id" all the time and it drives me nuts ^^
07:46:33 <solidus-river> could an anamorphism be thought of as a filtered generator on a subset of a data structure?
07:46:37 <solidus-river> like looking at its type
07:46:46 <solidus-river> ana :: (b -> (a, b)) -> (b -> Bool) -> b -> [a]
07:46:51 <ocharles> MagneticDuck: that came up on the mailing list, and it was decided that we wouldn't add it to base
07:47:24 <solidus-river> that looks an awefull lot like a lens -> filter -> whole -> accumulation of subset that satisfied filter
07:47:32 * chrisdone → back to work
07:47:33 <ocharles> It's foldMap ala Endo or something, but even that is more typing than what you had before
07:47:34 <MagneticDuck> ocharles: :|
07:47:41 <bennofs> :t ala Endo foldMap
07:47:42 <MagneticDuck> yeah
07:47:43 <lambdabot> Foldable t => t (a -> a) -> Unwrapped (Endo a)
07:48:01 <MagneticDuck> x|
07:48:19 <edwardk> ana :: Functor f => (a -> f a) -> a -> Nu f -- is a bit more general
07:48:34 <MagneticDuck> just like "compose" or something
07:48:46 <MagneticDuck> real simple, nothing fancy or reliant on other modules
07:49:28 <fizruk> MagneticDuck: iterate f x !! n ?
07:49:59 <MagneticDuck> yeah but that's more writing xD
07:50:24 <solidus-river> edwardk: that makes much more sense then saying that the monad / comonad space interact well to me
07:50:47 <solidus-river> i can see wanting to focus on one or the other more easily than wanting to focus on the interaction of them
07:50:52 <edwardk> solidus-river: in the space of vector spaces there are tons of hopf algebras you can look up
07:51:23 <solidus-river> whats a good profiler you'd recommend for haskell?
07:51:32 <edwardk> solidus-river: there they really do interact nicey and they obey a law where basically return and join are both comonad coalgebras and extend/duplicate are both monad algebras
07:52:00 <edwardk> (you only have to prove one pair of those laws, the other follows)
07:52:09 <solidus-river> edwardk: aye, i'm going to read up on anamorphisms tonight, i started
07:52:13 <bennofs> solidus-river: GHC's integrated profiler? I don't think you have much of a choice here
07:52:36 <solidus-river> so knowing a law holds for a monad lets us observe it's comonad in the same way
07:52:46 <edwardk> solidus-river: no
07:52:54 <edwardk> solidus-river: only if you have that hopf structure
07:53:03 <edwardk> which is very very rare in set like categories
07:53:39 <edwardk> solidus-river: http://comonad.com/haskell/catamorphisms.html may give you some insight into the anamorphism thing (but its unrelated to my statement about hopf algebras)
07:53:48 <edwardk> you can have fun dualizing everything in that writeup to get anamorphisms
07:54:03 <klrr_> why is DataLensFamily a newtype and not Store in the "Mirrored Lenses" article? http://comonad.com/reader/2012/mirrored-lenses/
07:54:10 <edwardk> oh, https://www.fpcomplete.com/user/edwardk/recursion-schemes/catamorphisms here is a newer version
07:54:46 <edwardk> klrr_: Store has 2 parameters
07:54:58 <klrr_> oh
07:54:58 <edwardk> DataLensFamily has 1, a function
07:55:06 <klrr_> missed that, sorry and thanks :)
07:55:18 <solidus-river> oh, who came up with / initiated fpcomplete btw, tahts an awesome resource
07:55:51 <glosoli> Is there some way to pattern match list from the end of it, without using reverse or such ?
07:56:45 <edwardk> fpcomplete is aaron contorer's baby
07:57:44 <edwardk> they put up an open blogging platform that can run haskell code and a bunch of us started writing articles on it
07:58:13 <edwardk> you may find http://hackage.haskell.org/package/recursion-schemes useful as well
08:04:37 <solidus-river> i'm really impressed with haskell, either i've gotten smarter or more real world experience to seethe value or its gotten better
08:05:18 <solidus-river> but i tried it out in 2009-ish and it was just awkword, then i went and made things in python / ruby / java / coffeescript / c++ / Obj-C for a couple years
08:06:09 <solidus-river> dove back in like a year ago and it still suprises me with how flexible it is in paradigms it supports despite being "purely functional"
08:06:56 <solidus-river> might get flack for saying "purely functional" but doesn't ST / STM / Lens / IO all break the rules of being "pure", they just encapsulated the inpurity?
08:07:00 <solidus-river> or am i thinking about that wrong
08:07:34 * hackagebot pcre-utils 0.1.4 - Perl-like substitute and split for PCRE regexps.  http://hackage.haskell.org/package/pcre-utils-0.1.4 (SimonMarechal)
08:07:47 <monochrom> they uphold purity. see my http://www.vex.net/~trebla/haskell/IO.xhtml
08:10:19 <Ainieco> hello! are there any articles about creating elm-lang frontend for json api backend?
08:10:33 <awestroke> solidus-river: What does lens do that is impure?
08:11:20 <Okasu> awestroke: Hype.
08:11:38 <awestroke> @hoogle Hype
08:11:39 <lambdabot> package hyperdrive
08:11:39 <lambdabot> package hyperloglog
08:11:39 <lambdabot> package hyperpublic
08:12:45 <m09> Anyone has an idea of why this newArray call loops? http://lpaste.net/104758
08:14:07 <heatsink> Is a range of Coords supposed to be a rectangle?
08:14:34 <m09> yup
08:14:35 <heatsink> > (1, 500) >= (0, 0) && (1, 500) < (2, 2)
08:14:37 <lambdabot>  True
08:16:12 <ReinH> MagneticDuck: ala Endo foldMap (replicate n f)
08:17:42 <heatsink> > iterate (>> Nothing)  (Just 1)
08:17:44 <lambdabot>  [Just 1,Nothing,Nothing,Nothing,Nothing,Nothing,Nothing,Nothing,Nothing,Noth...
08:17:54 <tromp> that's not a rectangle
08:18:13 <heatsink> m09: iterate makes an infinite list
08:18:16 <m09> my inrange function is bad
08:18:26 <m09> heatsink: yup, but I use takeWhile
08:19:12 <benzrf> :t iterate
08:19:13 <lambdabot> (a -> a) -> a -> [a]
08:19:15 <solidus-river> is there a flow structure in haskell that allows one to let a computation for X seconds and then ask for its most recent result
08:19:19 <benzrf> :t while
08:19:20 <lambdabot> Not in scope: ‘while’
08:19:30 <benzrf> :t until
08:19:31 <lambdabot> (a -> Bool) -> (a -> a) -> a -> a
08:19:31 <solidus-river> or do you have to check time within the computatin and return once the limit has been reached
08:19:33 <benzrf> hmm
08:20:53 <bennofs> solidus-river: "most recent result"? Does your computation return a list of results?
08:21:23 <awestroke> solidus-river: you could probably implement something like that with MVars and forkIO
08:21:33 <ReinH> solidus-river: you can use a timeout and update some structure that can be shared concurrently
08:21:43 <ReinH> Like an MVar
08:22:02 <solidus-river> yeah, thats what i was thinking
08:22:19 <solidus-river> i know very little about what i'm saying
08:22:32 <solidus-river> but i got excited for a second about the idea of game engine design
08:23:23 <solidus-river> and makeing phsyics / ai / animation based on time / input and letting each of those three things run for a set number of seconds each frame / refine themselves
08:23:30 <kazagistar> m09, I am still figuring it out, but other parts of the code seem off, like using size - 1 in your Ix Coords instance directly
08:23:33 <solidus-river> and hwo that might be incredibly easy to form in haskell
08:23:58 <heatsink> m09: Your ix instance is also incomplete
08:24:21 <m09> my Ix instance is wrong for inRange but I thought it was complete
08:24:27 <m09> I read that the complete def was range + inRange
08:24:28 <heatsink> You should fix the problems in the instance and then see if the infinite loop is still there
08:24:34 <m09> yup I'm doing that
08:24:49 <bennofs> solidus-river: using the async library, you could implement it as: result <- newIORef Nothing; race (forM possibleResults $ writeIORef result . Just) (threadDelay $ X * 1000000)
08:25:00 <m09> sorry I asked before --- I didn't remember I had not finished inRange ;(
08:25:04 <bennofs> solidus-river: and the 'readIORef result :: IO (Maybe a)'
08:25:11 <bennofs> s/the/then
08:25:27 <heatsink> m09: index also has to be defined http://hackage.haskell.org/package/base-4.7.0.0/docs/Data-Ix.html
08:25:54 <m09> damn, I'm not sure how I skipped that :o
08:25:56 <m09> thanks
08:27:35 <benzrf> what's the name for (>>)
08:27:39 <benzrf> like bind
08:28:00 <bennofs> solidus-river: but note that this might get inaccurate if your doing an extreme amount of GC (I had a program that spent 50% in GC and it was +- 0.3s)
08:28:09 <heatsink> then
08:28:17 <benzrf> heatsink: thx
08:29:03 <kazagistar> m09: is your range supposed to be (0,0), (0, 1) (0, 2) (1, 2) (2, 2)? That is what it looks like it is doing to me, though I am not sure
08:29:25 <m09> yup range is correct I think. I'm fixing inRange and coding index right now
08:29:43 <m09> I'll report if it still loops --- sorry for having asked before fixing them :(
08:31:48 <solidus-river> bennofs: yeah, and my origonal modal isn't accurate, there would potentially need to be interaction between the parts during computation (ai, physics, animation, gamelogic) unless i constrained it all to be based on the state of the last frame rendered
08:32:10 <kazagistar> m09: are you skipping (1, 1)?
08:32:22 <mirpa> m09: Does your Ix instance satisfy Ix predicates?
08:33:37 <m09> kazagistar: no sorry I thought it had all the values from 0, 0 to 2, 2. It does in my GHCI
08:33:47 <m09> mirpa: I'll fix my instance and check :)
08:37:16 <m09> It does work now that I fixed the instance. Thanks for the help and sorry I didn't check the instance properly before ~~
08:38:52 <mirpa> m09: ghc does not fire some warning about incomplete instance?
08:39:38 <heatsink> mirpa: Apparently Ix doesn't have a MINIMAL pragma
08:39:48 <kazagistar> m09: also, I assume you are aware that tuples will make the exact same Ix as you made, and are doing it educational value :D
08:41:42 <m09> kazagistar: yup I am :]
08:42:15 <m09> mirpa: actually no, maybe because the minimal def is only inRange and range (and I had a wrong inRange)
08:42:35 <m09> I'm not sure what's the difference between minimal implementation (inRange, range and index) and minimal definition (inRange and range) btw
08:44:24 <mirpa> heatsink: Is absence of that pragma a bug?
08:47:39 <rwbarton> which  version of ghc is m09 using?
08:47:55 <m09> 7.6.3
08:48:12 <rwbarton> hmm, it looks like there is no MINIMAL pragma in 7.8 either though
08:48:19 <rwbarton> oh wait
08:48:39 <kazagistar> looking at the git version of GHC.Arr, There is no minimal pragma there either?
08:49:03 <rwbarton> I'm not sure I was looking at the correct version
08:49:14 <kazagistar> rwbarton: http://git.haskell.org/packages/base.git/blob/HEAD:/GHC/Arr.lhs
08:49:37 <kazagistar> index refers to unsafeIndex, and unsafeIndex refers to index
08:50:22 <guymann> hi
08:51:02 <m09> so should I file a bug so that index is required as part of the minimal definition?
08:57:58 <mirpa> m09: If you can, then yes.
09:01:32 <m09> huh, it's not possible to create a ticket with a fresh account :o
09:01:37 <m09> weird :(
09:02:17 <mirpa> m09: which issue tracker?
09:02:44 <m09> oh my bad, I didn't notice the email verification limitation. Damn, tonight isn't my night :')
09:05:11 <kazagistar> does this seem like the correct minimal pragma? {-# MINIMAL range, ( index | unsafeIndex ), inRange #-}
09:06:14 <mirpa> kazagistar: yes, according to: http://www.haskell.org/ghc/docs/7.8.1-rc1/html/users_guide/pragmas.html
09:06:46 <kazagistar> mirpa: ill submit the patch then and see if I can get my first GHC library push :P
09:07:09 <m09> kazagistar: then maybe it's better if I don't submit my ticket :)
09:07:15 <m09> I'll let you handle it!
09:07:15 <mirpa> kazagistar: lucky you :-)
09:16:15 <KSkrzet> is it possible right now to compile programs for Android using GHC?
09:22:10 <tv> poke
09:22:24 <tv> oops.. wrong channel^_^
09:29:55 <pjdelport> KSkrzet: Have you looked at http://www.haskell.org/haskellwiki/Android ?
09:30:19 <pjdelport> and https://github.com/neurocyte/ghc-android
09:34:52 <KSkrzet> pjdelport: well, it looks somewhat old, but thanks for the tip anyway. I somehow assumed that there will be some changes with GHC 7.8.2 released
09:35:04 <blackbeard> Is Haskell a good first functional language to learn?
09:35:18 <mada> it is
09:36:36 <davidthomas> blackbeard: Good, yes.  Best probably depends on where you are coming from and what your goals are.
09:37:26 <blackbeard> I come from C++, C and Python. I wanted to learn functional programming as I believe it enforces a different mode of thinking?
09:38:02 <napping> For just starting a typed functional language, Haskell or O'Caml should be pretty similar
09:38:40 <napping> I think PLT scheme is a pretty nice environment if you're going for that sort of thing, but I haven't used it in quite a while
09:40:19 <hodapp> Clojure is nice too, for a rather different form of functional language than Haskell.
09:40:48 <napping> Yeah, that's another decent option for lispy languages.
09:41:15 <napping> I'm not sure if it's so good for just starting out - PLT has stuff specifically designed for that, and there are good books like SICP
09:41:48 <hodapp> There is a project to do SICP in Clojure but I'm not sure how well it's progressed.
09:42:05 <hodapp> but I find Clojure tooling quite nice.
09:42:06 <mirpa> It is good to read some essays from Paul Graham to get intro for Lisp.
09:42:14 <oleo> yep
09:42:20 <hodapp> and to get 1,300 reasons why you should use Lisp, valid or not.
09:42:35 <oleo> mirpa: read first gentle introduction to common lisp by touretzky
09:42:41 <hodapp> And to get some wonderfully snarky reasons why OOP isn't a silver bullet.
09:43:01 <hodapp> "It generates a lot of what looks like work."
09:43:02 <oleo> mirpa: afterwards on-lisp and then LoL maybe and erm
09:43:13 <oleo> there was another one
09:43:18 <oleo> gigmonkeys
09:43:24 <mirpa> oleo: I liked article where he showed eval function for lisp on ~40 lines of code
09:43:27 <m09> practical common lisp
09:43:31 <oleo> ah yep
09:44:24 <kazagistar> blackbeard: if you just want functional, scheme or something is good. Haskell adds more then just functional (and does a good job of encouraging you to learn it properly), but imho it is worth it
09:44:36 <oleo> sicp is another good read
09:45:08 <oleo> tho it's more for scheme, you can get some of its code translated to cl when you google for ellie bendersky
09:45:19 <napping> For learning interesting things later on, I think Haskell is a bit better than O'Caml, for laziness and type level stuff
09:45:39 <oleo> hmm, yes haskell is lyah
09:45:42 <mirpa> hey, there were some good book about Scheme - Little Schemer... or something like that
09:45:44 <napping> O'Caml has a few nice things Haskell misses, like a nice ML-style module system, and polymorphic variants/extensible records
09:45:53 <oleo> tho you have to get some math background too
09:45:55 <napping> Little Schemer, SICP, How to Design Programs, etc.
09:46:04 <oleo> type theory stuff....
09:46:12 <napping> The lisps mostly miss out on algebraic data types
09:46:50 <mirpa> but they are still ... aaahh so small and simple that you can teach kid to use it
09:48:01 <napping> I wonder how small a self-interpreter for a dependently-typed language could be (if you fend off Goedel with an axiom)
09:48:44 <oleo> and DIKU for currying.....
09:49:01 <oleo> partial eval i.e. if you into compiler territory....
09:50:55 <joneshf-laptop> is there a standard combinator like `on` or the psi combinator but that takes two functions to apply rather than one? Looking for this type: (b -> b -> c) -> (a -> b) -> (a -> b) -> a -> c
09:51:02 <joneshf-laptop> or anything more general i suppose also
09:51:10 <joneshf-laptop> hoogle/hayoo didn't help
09:51:18 <joneshf-laptop> and i didnt see anything immediatly in aviary
09:51:26 <joneshf-laptop> but probably missed something
09:51:39 <jle`> looks like liftA2
09:52:19 <joneshf-laptop> oh, wow it is
09:53:01 <jle`> or roll your own using <$> and <*> ofc
09:53:30 <joneshf-laptop> right
09:53:30 <joneshf-laptop> thanks
10:04:51 <hunt> what kind of project is functional programming is good for
10:05:08 <zomg> hunt: mostly anything? =)
10:05:36 <hunt> sure but how can i demonstrate why you would use functional programming over imperative
10:05:49 <pjdelport> Who do you need to demonstrate it to?
10:05:54 <shapr> hunt: You can trust your values?
10:05:56 <hunt> some kid who doesnt believe in its beauty
10:06:19 <hunt> hes asking for a project that would let him figure out why he should use functional programming
10:06:48 <zomg> Personally I would just take whatever cool idea I have at the moment
10:06:49 <shapr> hunt: because recursion is a more basic concept than looping?
10:06:51 <zomg> and try implementing that
10:07:18 <m09> It's the second or third time that I write a function that zips a list of lists. Is there a way to do it with some standard library? I'm starting to have some doubts
10:07:21 <pjdelport> It's probably not up to the choice of a project. He should work through some tutorials, probably. If he still doesn't see the value of FP, it might be better to ask what his specific objections are.
10:07:38 <shapr> hunt: I agree with zomg. If your friend doesn't want to try Haskell, he doesn't have to. But if he does, he should try it!
10:07:47 * hackagebot exception-mtl 0.3.0.4 - Exception monad transformer instances for mtl2 classes.  http://hackage.haskell.org/package/exception-mtl-0.3.0.4 (GeoffreyMainland)
10:07:50 <hunt> yea i agree
10:07:57 <pjdelport> m09: zips a list of lists how?
10:08:00 <hunt> he doesnt have any ideas though
10:08:05 <shapr> hunt: For me, I would compare webdev with Python to webdev with Haskell. It's so much nicer to be able to have faith that my code will really work.
10:08:20 <m09> pjdelport: this time I came up with zipListsWith f acc = map (foldl f acc) . transpose
10:08:21 <pjdelport> m09: transpose?
10:10:02 <pjdelport> m09: That looks reasonable (though you probably want foldl')
10:10:35 <pjdelport> It's not quite the usual definition of zipping, though.
10:10:44 <zomg> shapr: it's unusual to be able to trust anything in web dev isn't it ;)
10:10:46 <m09> why is that?
10:11:13 <Yuu_chan> I spawn some threads in main, how to wait for all of them?
10:11:20 <shapr> zomg: I don't trust any code at all, but I trust Haskell code more.
10:11:24 <Yuu_chan> (with forkIO)
10:11:29 <zomg> shapr: heh
10:11:48 <hodapp> shapr: Do you trust code that's formally proven correct?
10:12:12 <shapr> hodapp: I might
10:12:21 <zomg> hodapp: I would like to see someone formally prove a web app to be correct :D
10:12:28 <johnw> hodapp: then he doesn't trust the prover
10:12:37 <shapr> johnw: That's what I was thinking :-)
10:13:10 <pjdelport> "Beware of bugs in the above code; I have only proved it correct, not tried it." —Donald Knuth
10:13:14 <StoneToad> zomg: the hard part isn't the proof, it's having assumptions that actually relate to real life
10:13:38 <tremon> hodapp: is ghc proven correct?
10:13:39 <StoneToad> ah knuth says it way better then I do :D
10:13:41 <acowley> You still see pretty nasty bugs in DT languages used as proof assistants
10:14:09 <acowley> Maybe one can measure one's faith in bitcoin https://proofmarket.org/problem/recent
10:18:34 <wwwvvvv> Could anyone help me to understand Cabal sandboxes?  Say, I want to install 'foo', which depends on 'bar' and 'baz'.  'bar' depends on 'qux-1.0'; 'baz' depends on 'qux-2.0'.  What commands should I run in order to build 'bar' and 'baz' in the sandboxes but make both available for building 'foo'?
10:18:59 <johnw> the question is which of bar and baz is flexible
10:19:07 <cwraith> wwwvvvv: are you building them from local sources, or off hackage?
10:19:11 <johnw> because they'll all have to agree on a version of qux
10:19:35 <wwwvvvv> c_wraith: off hackage
10:20:34 <wwwvvvv> johnw: I thought that's what the sandboxes are for.
10:20:51 <johnw> sandboxes don't have anything to do with making packages build using multiple versions of a dependency
10:21:19 <johnw> they allow a package in one sandbox to use one version of qux, and a package in *another* sandbox using a second version of qux
10:21:35 <johnw> but within the one sandbox, foo+bar+baz+qux must use one version of qux
10:22:16 <freezerburnv> I’m surprised there’s no way to get around that
10:22:16 <wwwvvvv> johnw: Yes, I understand this.  Perhaps my question is poorly written.
10:23:29 <wwwvvvv> johnw: I'd like to build 'bar' in one sandbox and 'baz' in the other one.  Can I make 'bar' and 'baz' available for building 'foo'?
10:24:10 <wwwvvvv> freezerburnv: There is a way, but it's not been implemented yet.
10:24:32 <johnw> wwwvvvv: you mean, have a third sandbox use build products from two other sandboxes?
10:24:42 <acowley> wwwvvvv: You can add-source bar and baz, but they will be rebuilt in the third
10:24:44 <freezerburnv> wwwvvvv: Ah, good to know. Hopefully that gets implemented in the near future then :)
10:25:31 <c_wraith> Well, it's got the inherent problem of being incoherent if anything from the interface of qux appears in the interfaces of bar *or* baz
10:25:40 <wwwvvvv> johnw: Yes.  'foo' only needs 'bar' and 'baz', not their dependencies.
10:25:59 <c_wraith> As in, allowing it would be a bug
10:26:05 <c_wraith> So fortunately, it's not allowed.
10:26:09 <johnw> I don't think cabal will do this; as far as I know, foo must transitively use one version of qux
10:26:27 <rwbarton> right
10:27:26 <acowley> Is anybody actively working on distinguishing internal deps from those that affect a package's public API? I've not heard anything in quite a while.
10:27:27 <c_wraith> johnw: cabal will do it, but I don't think it will do it in sandboxes.  You usually can identify it's happened outside a sandbox because you start getting type errors that list package versions
10:27:39 <c_wraith> acowley: I think the backpack work qualifies
10:28:01 <c_wraith> acowley: That work is ongoing, but it's currently quiet and low-priority, iiuc
10:28:33 <acowley> c_wraith: that seems more like a prototype design
10:29:31 <c_wraith> What was released was a prototype to get feedback and testing on, yes.  But work is progressing to refine the design based on that feedback, I think.  I've heard things that suggest that, at least.
10:29:58 <wwwvvvv> johnw: Then, I don't understand how people build thigs like yesod or hackage-server.  Could you explain?
10:30:04 <wwwvvvv> ... Or lens.
10:30:30 <johnw> cabal searches for a version of qux that can satisfy them all
10:30:32 <c_wraith> wwwvvvv: You tell cabal to build everything at once, and let it work out the dependencies.
10:30:43 <johnw> presumably, bar and baz don't fix on specific versions of qux, but on a range
10:30:46 <c_wraith> wwwvvvv: the important part is that you don't build piecemeal.
10:31:48 <acowley> c_wraith: Backpack is also somewhat invasive
10:32:05 <c_wraith> Related to this, sandboxes really need a clean command.  Sometimes I want to clear out everything that's been built for the sandbox, but not delete it.
10:32:05 <acowley> c_wraith: In that it requires (I think) developer support
10:32:32 <acowley> c_wraith: But you could imagine an automated tool for this public/private dep distinction that doesn't have aspirations to modularity
10:33:16 <wwwvvvv> I usually run 'cabal configure', look at the list of deps, then run 'cabal install deps' without specifying the versions of packages without upper bounds.  Is it the right way?
10:33:34 <c_wraith> wwwvvvv: cabal install --only-dependencies
10:33:38 <bennofs> wwwvvvv: cabal install --only-dep[endendencies]
10:33:49 <johnw> --only-dep works?  cool
10:34:00 <c_wraith> also, --dependencies-only works
10:34:06 <bennofs> johnw: idk which cabal version it is, but it works in 1.20 at least
10:34:10 <johnw> how about --just-the-dependencies-please?
10:34:11 <c_wraith> In case, like me, you can never remember
10:34:12 <acowley> I guess the most critical issue is that backpack doesn't do type classes, which means it is still over the horizon in terms of being shipping software
10:34:27 <bennofs> c_wraith: but --dep-only doesn't work :(
10:34:30 <acowley> johnw: bash-completion! I type --depTAB
10:34:51 <acowley> Actually --deTAB works
10:35:39 <acowley> I type --drTAB --depTAB rather a lot
10:36:01 <c_wraith> if you're doing a dry run, you really should throw in a -v also
10:36:15 <acowley> Why?
10:36:18 <c_wraith> Since that makes it tell you what kind of install it's doing for each package.
10:36:21 <acowley> I do it as a version sanity check
10:37:40 <wwwvvvv> c_wraith: Will it work if I just run 'cabal install' from the local source tree?  Will it pick up all the deps automagically?
10:37:41 <c_wraith> -v makes it list whether a package is new to the database, or just a new version.  The latter is usually a warning sign
10:37:50 * hackagebot HListPP 0.2 - A preprocessor for HList labelable labels  http://hackage.haskell.org/package/HListPP-0.2 (AdamVogt)
10:37:58 <acowley> I'd probably prefer there be a --bleed-just-to-know-im-alive flag that speaks up if the constraint solver picked something more than a version or two old.
10:39:04 <c_wraith> wwwvvvv: try it out!  cabal install --dependencies-only --dry-run  (the latter flag prevents it from actually making any changes)
10:39:24 <wwwvvvv> Okay, thanks all!
10:39:24 <c_wraith> also, you'll note that I really *can't* pick one order for that flag, so it's nice that both work
10:41:17 <jdiez> hiya, I'm trying to write my first "serious" haskell program, a sudoku solver
10:41:21 <jdiez> I'm struggling with a do block: https://gist.github.com/jdiez17/ffa24cb9fae0b2609b0b
10:41:37 <jdiez> my idea is to have checkDimensions return Nothing if the input matrix isn't square
10:41:53 <jdiez> however ghci is complaining that map returns [Int] instead of Maybe Int
10:42:17 <jdiez> not sure how to proceed
10:42:31 <pavonia> Because xss is of type [something]
10:42:48 <jdiez> it's [[something]]
10:43:11 <jdiez> that doesn't explain it though...
10:43:36 <pavonia> You state the result type is Maybe Int, so return :: Int -> Maybe Int
10:43:53 <pavonia> But you'Re not handing it an Int
10:44:05 <pjdelport> jdiez: Shouldn't that be "sum $ map length xss" or something?
10:44:22 <pavonia> Err, I misread :/
10:44:49 <jdiez> pjdelport: well, the approach I'm taking is to make sure each line has as many items as the whole matrix
10:44:53 <jdiez> i.e length(x) == length(y)
10:45:09 <rwbarton> line 24 doesn't make any sense to me
10:45:31 <jdiez> well, what I'd like to do is for checkDimensions to return Nothing if the input isn't square
10:45:34 <acowley> indeed
10:45:41 <jdiez> otherwise to continue the thing
10:45:52 <pavonia> YEah, map resturns a list but that doesn't match with the Monad type used (Maybe)
10:45:53 <acowley> line 24 is Jack Bauering your good times
10:45:56 <rwbarton> it looks like you think you're simultaneously in Maybe and [] monads
10:46:05 <jdiez> yep I agree, that seems to be what I'm doing
10:46:17 <rwbarton> I would just use 'all'
10:46:33 <rwbarton> guard $ all (\xs -> length xs == lengthOuter) xss
10:46:33 <acowley> ie all (== lengthOuter)
10:46:47 <jdiez> hmm
10:46:49 <jdiez> let me think about that
10:47:02 <acowley> if you map you get a list, so you can use all to crush it down to a Bool
10:47:18 <acowley> Or you can fuse the map and the crushing with all ((== lengthOuter) . length)
10:47:29 <jdiez> ok, sorry, I'm a bit lost
10:47:38 <jdiez> at this point I don't think checkDimensions has the best type signature
10:47:49 <jdiez> should it pass on the matrix wrapped in Maybe?
10:47:55 <jdiez> surely returning a Bool would be easier
10:48:01 <rwbarton> yes, that too
10:48:21 <jdiez> so checkDimensions :: [[Int]] -> Bool ?
10:48:29 <rwbarton> then move the 'guard' into mkSudoku
10:49:04 <jdiez> hmm
10:49:08 <jdiez> is Bool an instance of Monad?
10:49:32 <lennartj> jdiez: Bool has the wrong kind
10:49:56 <simukis_> jdiez: you can check those things with :info
10:50:16 <jdiez> ok, so Bool is not a monad... hmm...
10:50:29 <jdiez> I'd like to call off the whole thing if chedkDimensions returns False
10:50:35 <jdiez> which would happen with Maybe
10:50:56 <fizruk> :t guard
10:50:57 <lambdabot> MonadPlus m => Bool -> m ()
10:51:11 <fizruk> :t guard :: Bool -> Maybe ()
10:51:12 <lambdabot> Bool -> Maybe ()
10:51:40 <johnw> jdiez: the type "Maybe ()" is equivalent to Bool, and is a Monad
10:51:55 <fizruk> :t \f -> guard $ f [[1], [2, 3]]
10:51:56 <lambdabot> lexical error at character '\FS'
10:52:02 <johnw> sorry, it's not a Monad, Maybe is the monad
10:52:03 <jdiez> ok, so perhaps checkDimensions should be `[[Int]] -> Maybe ()` ?
10:52:12 <fizruk> argh
10:52:28 * fizruk hates Colloquy.
10:52:44 <kazagistar> why not just "if checkDimentions xss then buildSudoku else Nothing"?
10:52:50 <johnw> jdiez: it all depends on what you want to do; it sounds like using Bool would be clearer
10:52:52 <kazagistar> avoid the monads entirely
10:52:54 <m09> well, Maybe () isn't a monad, Maybe is
10:53:00 <rwbarton> I would just use Bool, and guard. or kazagistar's approach is also fine
10:53:17 <jdiez> ok, I think I'll use Bool and guard
10:53:18 <jdiez> thanks
10:53:47 <rwbarton> Also, checkDimensions would better be named isSquare or something
10:53:54 <jdiez> good point too
10:54:03 <kazagistar> it might be the python talking, but if my code reads like english I am happier
10:54:40 <rwbarton> (more so when it returns a Bool, rather than Maybe something)
11:00:49 <klrr_> all these setting and getting and Store is very confusing to read, if i understand the basic "type LensFamily a b c d = forall f. Functor f => (c -> f d) -> a -> f b" can i consider myself understanding lenses and start using them, or is there more to it?
11:01:57 <rwbarton> there will always be more to it
11:02:07 <klrr_> okey
11:02:16 <rwbarton> so, don't let that stop you from using them
11:02:21 <bennofs> klrr_: you can start using them, but there is a lot more (Prisms!)
11:02:31 <klrr_> meh, not understanding and using feels like cheating
11:02:50 <klrr_> besides, its quite fun to try understand this stuff :)
11:03:19 <lennartj> klrr: I found I only started to understand what was going on with lenses when I actually did try to sit down and write code with them
11:04:48 <klrr_> okey i will consider that
11:07:00 <kazagistar> when I sat down and starting to write code with lenses I got frustrated and procrastinated learning them
11:07:06 <bennofs> klrr_: traversals are just forall f. Applicative f => (a -> f b) -> s -> f t, so if you understand lenses, understand traversals should not be that difficult. Getters and setters should not be very different either. Prisms and Isos are based on a different concept though
11:07:56 <shachaf> Only moderately different.
11:08:11 <klrr_> i gonna try evaluate some lens code manually and try get it right
11:08:28 <glguy_> klrr_: There's no magic to lenses, so if you can wrap your head around   type Lens s t a b = forall (f :: * -> *). Functor f => (a -> f b) -> s -> f t     then the rest is just a couple of clever functor choices
11:08:57 <glguy_> There are other types to learn but you can build on that as you go
11:09:00 <shachaf> They're clever from one perspective and straightforward from another.
11:09:59 <klrr_> glguy_: so, the lens defined with Store is equaliviant to that one?
11:10:49 <glguy_> You can write functions to convert between the two
11:10:59 <klrr_> i dont quite understand the motivation of defining it with Store
11:11:01 <klrr_> yeah
11:11:16 <lennartj> bennofs: I personally can't really intuit what's going on with traversals thinking about the applicative constraint
11:11:42 <klrr_> but if they're equal, what is the benefit of Store, the motivation for Getting and Setting is said though
11:11:42 <glguy_> Depending on your implementation of Store you might not be able to support type changing updates
11:12:05 <lennartj> bennofs: but if someone says, traversals are like lenses except instead of focusing one subfield, you can focus zero, one, or many subfields, that makes more sense to me
11:12:42 <shachaf> A traversal is a function that's like mapM.
11:12:54 * hackagebot QuickCheck 2.7.4 - Automatic testing of Haskell programs  http://hackage.haskell.org/package/QuickCheck-2.7.4 (NickSmallbone)
11:13:38 <shachaf> If you understand mapM and Applicative, you can understand Traversal.
11:13:56 <bennofs> lennartj: right, that is to understand how you can use them. What I wanted to say that it's easier to understand how they "work" if you already know how lenses work
11:14:39 <matematikaadit> Hi all, Me and friends have started a local Indonesian haskell community this year. We already done about 6-7 meetups regularly. Currently, our discussion mainly happen in #haskell-id. Did someone know how to get our channel listed in http://www.haskell.org/haskellwiki/IRC_channel#Related_channels ??
11:15:38 <bennofs> klrr_: btw, there is a #haskell-lens channel :)
11:15:47 <klrr_> oh, joing it then :P
11:16:20 <lennartj> bennofs: ah, yes, certainly that's true!
11:18:42 <napping> matematikaadit: can you edit the page yourself?
11:20:33 <matematikaadit> napping: it says "You do not have permission to edit this page"
11:23:28 <rwbarton> are you logged in? it seems that I can edit the page
11:25:11 <rwbarton> matematikaadit: what description do you want?
11:26:19 <jdiez> quick question: if I have a list of type [[Maybe Digit]], is there an idiomatic way of checking if any of the elements is Nothing?
11:26:32 <jdiez> basically, I have a list like [[Maybe Digit]] and I want to return Maybe [[Digit]]
11:26:42 <jdiez> so if any of the elements is Nothing, the whole thing is Nothing
11:26:44 <jdiez> does that make sense?
11:26:58 <bennofs> @ty sequence
11:27:00 <lambdabot> Monad m => [m a] -> m [a]
11:27:18 <bennofs> :t sequence . map sequence
11:27:19 <lambdabot> Monad m => [[m a]] -> m [[a]]
11:27:26 <jdiez> sorry, I don't understand that
11:27:28 <bennofs> jdiez: ^^^ Maybe is a Monad
11:27:42 <bennofs> :t sequence . map sequence :: [[Maybe a]] -> Maybe [[a]]
11:27:43 <lambdabot> [[Maybe a]] -> Maybe [[a]]
11:27:54 <jdiez> I don't quite get how that works
11:27:58 <jdiez> what does sequence do?
11:28:10 <Maior> @src sequence
11:28:10 <lambdabot> sequence []     = return []
11:28:10 <lambdabot> sequence (x:xs) = do v <- x; vs <- sequence xs; return (v:vs)
11:28:10 <lambdabot> -- OR: sequence = foldr (liftM2 (:)) (return [])
11:28:36 <ion> @type (traverse . traverse) id `asAppliedTo` (undefined :: [[Maybe a]])
11:28:36 <jdiez> I'm a little dense today, could I get some english? :)
11:28:37 <lambdabot> [[Maybe b]] -> Maybe [[b]]
11:28:38 <bennofs> jdiez: sequence :: [Maybe a] -> Maybe [a]    -- returns Just [...] if every element of the original list is Just ..., otherwise, returns Nothing
11:28:44 <kazagistar> jdiez: for the future, you should get familiar with hoogle
11:28:52 <kazagistar> @hoogle [Maybe a] -> Maybe [a]
11:28:55 <lambdabot> Prelude sequence :: Monad m => [m a] -> m [a]
11:28:55 <lambdabot> Control.Monad sequence :: Monad m => [m a] -> m [a]
11:28:55 <lambdabot> Data.Maybe catMaybes :: [Maybe a] -> [a]
11:29:10 <matematikaadit> rwbarton: I don't have an account. Just "Indonesian speakers" is enough I think.
11:29:13 <Maior> jdiez: my favourite usage is giving it a [Maybe a] and getting Nothing if any item is Nothing, or Just [a] if they're all Justs
11:29:13 <glguy_> > traverse sequence [[Just True],[Just False,Just False]]
11:29:13 <bennofs> :t mapM sequence
11:29:14 <lambdabot> Monad m => [[m a]] -> m [[a]]
11:29:14 <lambdabot>  Just [[True],[False,False]]
11:29:29 <bennofs> glguy_: hah, I just got that idea too
11:29:33 <Maior> > sequence [Just 1, Nothing, Just 2]
11:29:34 <lambdabot>  can't find file: L.hs
11:29:37 <Maior> :s
11:29:38 <jdiez> right, sorry guys, but you're not really helping by throwing some haskell at me
11:29:43 <bennofs> > sequence [Just 1, Just 3, Just 5]
11:29:45 <lambdabot>  Just [1,3,5]
11:29:46 <jdiez> could I get an explanation in english of what sequence does?
11:29:50 <bennofs> > sequence [Just 1, Nothing, Just 5]
11:29:52 <lambdabot>  Nothing
11:29:59 <Maior> bennofs: what did I fail at?
11:30:04 <jdiez> right, I get the end result, but how does it work?
11:30:09 <Maior> aka "why did it work so nicely for you" :P
11:30:14 <rwbarton> it runs a bunch of actions and produces a list of the results
11:30:20 <glguy_> ?src sequence
11:30:20 <lambdabot> sequence []     = return []
11:30:20 <lambdabot> sequence (x:xs) = do v <- x; vs <- sequence xs; return (v:vs)
11:30:20 <lambdabot> -- OR: sequence = foldr (liftM2 (:)) (return [])
11:30:21 <klrr_> :t sequence
11:30:22 <lambdabot> Monad m => [m a] -> m [a]
11:30:23 <bennofs> jdiez: do you see how that works? return Nothing if anything is Nothing, otherwise, Just the list contents
11:30:32 <jdiez> bennofs: yes, I get that
11:30:36 <bennofs> Maior: race condition in lambdabot or something
11:30:46 <Maior> bennofs: ah kk
11:30:55 <bennofs> jdiez: do you know how the Maybe monad works?
11:30:59 <bennofs> > Nothing >> Just 3
11:31:00 <lambdabot>  Nothing
11:31:14 <jdiez> bennofs: yes
11:31:39 <kazagistar> @src sequence
11:31:40 <lambdabot> sequence []     = return []
11:31:40 <lambdabot> sequence (x:xs) = do v <- x; vs <- sequence xs; return (v:vs)
11:31:40 <lambdabot> -- OR: sequence = foldr (liftM2 (:)) (return [])
11:31:44 <Ainieco> hello
11:31:48 <jdiez> ahhh
11:31:50 <jdiez> okay, I see
11:31:55 <jdiez> herp, sorry guys, I'm a bit dense today
11:32:14 <bennofs> jdiez: so sequence [a,b,c] translates to do a' <- a; b' <- b; c' <- c; return [a',b',c'] in the Maybe monad (after expanding the recursion=
11:32:38 <Ainieco> i've created instance of Parsable(scotty package) for UUID(uuid package) and now i'm getting "orphan instance" warning, what can i do?
11:32:50 <jdiez> ok, I think I get it now
11:32:58 <jdiez> I don't get `sequence . map sequence` however
11:33:01 <Ainieco> i don't want to modify neither scotty nor uuid packages
11:33:02 <jdiez> oh wait, I do
11:33:04 <jdiez> nevermind
11:33:09 <napping> Ainieco: well, then you have an orphan instance.
11:33:41 <Ainieco> napping: is there good solution for such issue because i need that instance
11:33:42 <bennofs> jdiez: note that sequence . map f is the same as mapM f, so sequence . map sequence is the same as mapM sequence
11:33:58 <bennofs> @src mapM
11:33:58 <lambdabot> mapM f as = sequence (map f as)
11:34:06 <jdiez> noted
11:34:12 <jdiez> now, https://gist.github.com/jdiez17/8b0384e99ddfbaa09d95
11:34:27 <jdiez> how can I make buildSudoku not throw a runtime exception if the sudoku is malformed?
11:34:32 <napping> Ainieco: no, that's the definition of an orphan instance - unless it's in the module declaring the class or in the module declaring the type, and instance is an orphan. Sounds like you really want an orphan instance here.
11:35:31 <bennofs> jdiez: there is a runtime exception because the let (Just digits) = toDigits fails if toDigits is Nothing
11:35:36 <jdiez> yep I know
11:35:37 <blackbeard> Thanks for the recommendation. I will start learning FP with scheme and sicp before coming to Haskell!
11:35:57 <Ainieco> napping: yep, i can't think of anything better than orphan instance here because modifying scotty or uuid seems to be even worse than orphan instance :)
11:36:02 <glguy_> Ainieco: You probably don't have to use an instance to get the behavior you want
11:36:20 <pavonia> Ainieco: If you want to suppress the warning, there's -fno-warn-orphans
11:36:24 <glguy_> Ainieco: Assuming you are doing something like reading a UUID parameter you can just have a function for reading uuid parameters
11:36:26 <bennofs> jdiez: one way to solve this would be to `case` on toDigits like this: case toDigits of { Nothing -> Nothing; Just digits -> Just $ Sudoku digits }
11:36:32 <lennartj> jdiez: just fmap Sudoku toDigits
11:36:43 <bennofs> jdiez: but again, that is the same as fmap Sudoku toDigits!
11:36:54 <jdiez> hmm
11:36:57 <jdiez> let me think about that
11:37:16 <jdiez> that works because Maybe is a functor?
11:37:17 <Ainieco> glguy_: well, that will add some complexity but yeah - that's definitely an option
11:37:20 <bennofs> jdiez: yes
11:37:24 <bennofs> @src fmap Maybe
11:37:25 <lambdabot> Source not found. My brain just exploded
11:37:25 <glguy_> Ainieco: Or you can make your own newtype for UUIDs and write the instance for that if you must have the instance
11:37:33 <kazagistar> blackbeard: if you find sicp too dry, you can always change your mind and try lyah for a while
11:37:38 <bennofs> @src Maybe fmap
11:37:38 <lambdabot> fmap _ Nothing       = Nothing
11:37:39 <lambdabot> fmap f (Just a)      = Just (f a)
11:37:45 <jdiez> ohhhhhh okay
11:37:50 <jdiez> ok that makes sense
11:38:32 <Ainieco> pavonia, napping, glguy_: sorry for mass highlight, what are my risks if decide to go with warning supresion?
11:38:46 <jdiez> @src sequence
11:38:46 <lambdabot> sequence []     = return []
11:38:46 <lambdabot> sequence (x:xs) = do v <- x; vs <- sequence xs; return (v:vs)
11:38:46 <lambdabot> -- OR: sequence = foldr (liftM2 (:)) (return [])
11:39:21 <jdiez> ok
11:39:35 <glguy_> Ainieco: you'll be incompatible with other modules that made the same error
11:40:18 <jdiez> where does lambdabot get these sources from?
11:40:19 <glguy_> and you can get situations where the instance that is chosen depends on which modules you import
11:40:26 <jdiez> the ones on hackage are completely incomprehensible to me
11:40:37 <Ainieco> glguy_: scary, i'll try newtype then. thank you!
11:40:38 <bennofs> jdiez: it's a hardcoded database
11:40:43 <jdiez> @src mapM
11:40:44 <lambdabot> mapM f as = sequence (map f as)
11:41:45 <kazagistar> jdiez: note: you can pm lambdabot as well ;)
11:41:49 <jdiez> noted
11:42:55 <matematikaadit> rwbarton: I don't have an account. Just "Indonesian speakers" is enough I think.
11:42:56 <yepyep> Scala -- worth learning?
11:43:07 <glguy_> This is #haskell
11:43:29 <yepyep> yes, but i'm curious to hear other people's take on the language, especially with regard to scalaz
11:43:30 <bennofs> yepyep: probably better to ask this in #scala :)
11:43:39 <c_wraith> scala's worth learning
11:44:11 <c_wraith> Though the value might be in an area other than finding another language you'd like to use.
11:44:25 <yepyep> I love haskell, but it doesn't have the batteries i need for my domain at the present time (GIS/scientific programming)
11:44:53 <yepyep> nor do i have the chops to create the libraries with such functionality
11:45:19 <bernalex> I think scala is a terrible language. probably worth learning. not worth using though. :-]
11:45:37 <rwbarton> matematikaadit: ok, done
11:45:38 <lispy> yepyep: there is a third option. Make bindings to existing libraries that implement such functionality.
11:45:50 <rwbarton> matematikaadit: in theory you should be able to create an account, though
11:45:58 <c_wraith> scala in an excellent case study in how kitchen sink language design leads to chaos.
11:46:22 <kazagistar> man, @free seems seriously broken...
11:46:32 <bernalex> I think it's preferable to java and the other languages you have at your disposal for android
11:47:00 <chirpsalot> bernalex: I thought scala wasn't really supported for Android stuff?
11:47:21 <bernalex> chirpsalot: you get to choose. either it takes forever to compile, or everything takes forever at runtime. it's not great, but it works. ish.
11:47:41 <n-dolio> @free quux :: (a -> b) -> F a -> F b
11:47:41 <lambdabot> g . h = k . f => $map_F g . quux h = quux k . $map_F f
11:47:59 <chirpsalot> bernalex: rad choices :P
11:48:12 <bernalex> chirpsalot: note that my experiences stem from a year ago or so, so it might be a lot better now.
11:48:40 <chirpsalot> bernalex: true. I think the NDK is getting better as well, so maybe other options are springing up.
11:48:45 <rwbarton> I played around with scala for android a couple years ago, and I don't remember making a choice, but I do remember it taking forever to compile
11:48:47 <matematikaadit> thanks rwbarton. Well, I think I'll create one.
11:48:47 <kazagistar> @help free
11:48:48 <lambdabot> free <ident>. Generate theorems for free
11:48:52 <bernalex> chirpsalot: no haskell, no care. ;-)
11:49:01 <kazagistar> @free a . b
11:49:01 <lambdabot> Extra stuff at end of line
11:49:12 <kazagistar> @free (.).(.)
11:49:12 <lambdabot> Pattern match failure in do expression at src/Lambdabot/Plugin/Haskell/Free/FreeTheorem.hs:54:21-35
11:49:14 <chirpsalot> bernalex: wasn't there something with scala needing massive libraries or something, which was less than ideal for Android?
11:49:24 <n-dolio> You don't get to give @free arbitrary expressions.
11:49:45 <n-dolio> You give it a function whose type it can look up somewhere, or a function annotated with a type.
11:49:46 <bernalex> chirpsalot: oh yeah the binary's huuuge too
11:49:50 <kazagistar> or it gives me line numbers where errors occured?
11:49:52 <c_wraith> @free map
11:49:53 <lambdabot> g . h = k . f => $map g . map h = map k . $map f
11:50:01 <c_wraith> Seems to be working!
11:50:14 <chirpsalot> bernalex: awesome. I wish Android was a lot better...
11:50:50 <kazagistar> @free (%=)
11:50:50 <lambdabot> Pattern match failure in do expression at src/Lambdabot/Plugin/Haskell/Free/FreeTheorem.hs:54:21-35
11:50:57 <n-dolio> I think Scala could be worthwhile for Android, in that you can write Java-but-better code in it. However, you'd probably be advised to avoid a lot of its features.
11:51:00 <kazagistar> @free (+)
11:51:01 <lambdabot> Pattern match failure in do expression at src/Lambdabot/Plugin/Haskell/Free/FreeTheorem.hs:54:21-35
11:51:09 <kazagistar> @free +
11:51:09 <lambdabot> Pattern match failure in do expression at src/Lambdabot/Plugin/Haskell/Free/FreeTheorem.hs:54:21-35
11:51:27 <n-dolio> From what I've heard, you're even supposed to write odd-for-Java code for it, too, though.
11:51:59 <owlglass> are there Eq instances for lenses?
11:52:08 <bernalex> chirpsalot: the languages I remember being vaguely being able to run (without being ridiculously bad) were java, scala & clojure.
11:53:34 <chirpsalot> bernalex: so, just the big JVM languages? I guess that's expected.
11:53:59 <bennofs> owlglass: no. How should that work? Lenses can be constructed out of a getter function and a setter function only, so an Eq instance would have to compare *functions*
11:55:02 <chirpsalot> bernalex: there are some vague hints around that you could in theory use some Haskell with Android various ways, but it sounds like it will be a terrible idea because none of these suggestions actually show somebody doing it.
11:55:12 <chirpsalot> bernalex: http://www.haskell.org/haskellwiki/Android
11:55:29 <rwbarton> I actually wrote a toy android app in Haskell
11:55:52 <chirpsalot> rwbarton: how did that go?
11:56:08 <bernalex> chirpsalot: I don't have classes any more. I doubt I'll write something for android again. ;-)
11:56:17 <bernalex> but cool that it's possible
11:56:27 <rwbarton> well... I had to concoct all my Java method calls manually through JNI
11:57:15 <rwbarton> "If you thought Java was verbose ..."
11:57:49 <rwbarton> however, it did basically work
11:57:59 * hackagebot haskell-packages 0.2.4 - Haskell suite library for package management and integration with Cabal  http://hackage.haskell.org/package/haskell-packages-0.2.4 (RomanCheplyaka)
11:59:05 <bernalex> rwbarton: SLOC count?
11:59:41 <rwbarton> I don't have the project on this computer but on the order of 100 I'd guess
12:02:30 <kadoban> I keep checking every once in a while if anyone is working seriously on Haskell+Android, never seems to be much.  I did a toy or two in Scaloid/Scala + Android, which is pretty pleasant, if you're open to other languages.
12:03:42 <chirpsalot> rwbarton: haha, encouraging :P
12:05:54 <rwbarton> the JNI distinction between global and local references and the potentially small limit on local references seemed like the biggest potential blockers for serious work along these lines
12:06:45 <suppi> Hi
12:07:59 <suppi> I'm using a data type like this: data Tree a = Tree [(a, Tree a)]
12:09:02 <suppi> and I have a function that takes a type and returns IO Bool. I mapped this function on the Tree and got a container of type: Tree (Something, IO Bool)
12:09:37 <suppi> Is it possible to make this type of type IO (Tree (Something, Bool)) or something like that?
12:10:17 <suppi> to change it to*
12:11:43 <Ainieco> [ 1 of 22] Compiling Language.Haskell.Exts.Annotated.Syntax ( src/Language/Haskell/Exts/Annotated/Syntax.hs, dist/dist-sandbox-2293c58c/build/Language/Haskell/Exts/Annotated/Syntax.p_o )
12:11:48 <Ainieco> gcc: internal compiler error: Segmentation fault (program cc1)
12:11:50 <Ainieco> whoa
12:12:24 <rwbarton> https://ghc.haskell.org/trac/ghc/ticket/8768
12:13:38 <Ainieco> oh, thanks
12:23:02 * hackagebot QuickCheck 2.7.5 - Automatic testing of Haskell programs  http://hackage.haskell.org/package/QuickCheck-2.7.5 (NickSmallbone)
12:23:19 <Ainieco> is it possible to have colored output of "cabal test"?
12:35:51 <BeardedCoder> I'm compiling with -rtsopts and running with +RTS -T 2>&1 but don't see anything. What am I doing wrong?
12:36:41 <bennofs> BeardedCoder: try -S instead of -T
12:36:59 <BeardedCoder> cool, that spit something out
12:37:08 <bennofs> BeardedCoder: or if that's too much info (likely), use -s
12:37:45 <BeardedCoder> oh, i should of RTFM better. -T produces no output
12:37:53 <BeardedCoder> bennofs: ty
12:37:54 <bennofs> yeah :)
12:57:49 <Carnassial> I'm writing a program that uses lots of small lists (on average around 30 elements). I'm mostly using; map, length and intersection. Is it better to use Data.Vector / Data.Set or will the overhead be not worth it for the size of lists i'm dealing with?
13:03:05 <keith903> I'm trying to cabal install aeson-0.7.0.3 and I keep getting this error: http://lpaste.net/104515  .   How do I fix the error?
13:05:40 <MagneticDuck> Carnassial: define lots
13:05:42 <MagneticDuck> and fixed length?
13:06:52 <acowley> keith903: That looks like it might be missing upper bounds on the scientific dependency
13:07:00 <acowley> keith903: Look at aeson-7.0.4
13:07:13 <acowley> keith903: You can constraint scientific to 0.2.*
13:07:36 <keith903> acowley: thanks il take a look at that
13:07:42 <acowley> keith903: Something like "cabal install aeson-7.0.3 --constraint scientific==0.2.0.2"
13:07:46 <acowley> but I probably mangled that syntax
13:08:14 <acowley> keith903: If you can use a newer aeson, that might be preferable just in case it's more subtle
13:08:37 <Carnassial> MagneticDuck: I make alot of lists but they will never exceed 81 in length
13:08:52 <keith903> acowley: It's a dependency for snap
13:09:19 <acowley> keith903: okay, then adding your own manual constraints as I suggested is probably the least painful way to go
13:09:36 <keith903> acowley: ok thanks
13:09:43 <rwbarton> somehow I doubt snap really needs aeson-0.7.0.3 and not aeson-0.7.0.4
13:10:30 <acowley> rwbarton: Yeah, but that might require you arguing with the cabal file. My suggestion is just a way of refining its demands :P
13:12:36 <Polarina> Carnassial, there are typeclasses such as Foldable and Traversable that you can use to abstract over the real container, and thus switch easily. However, I highly recommend to profile your code and see if what you got is performant enough.
13:13:18 <rwbarton> you don't really need to profile your program to determine that, you can just run it
13:13:37 <Polarina> rwbarton, also known as poor-man's profiling.
13:16:11 <Carnassial> Polarina: Yea, I seem to be spending a ton of time doing intersections
13:16:32 <absence> what libraries are there for trees, other than the rose tree in containers?
13:17:11 <rwbarton> Carnassial: vector is probably a good bet for this use case, particularly if you can use unboxed ones
13:17:13 <absence> something like "data Tree a = Node [Tree a] | Leaf a" would be nice
13:17:57 <acowley> I would have gone with Set if I were doing a bunch of intersections
13:18:20 <acowley> Or a non-Ord-based tree if Ord isn't available
13:18:31 <Carnassial> rwbarton: Yes I can use unboxed ones :P. I'll try it!
13:19:02 <rwbarton> I guess I'm imagining sorted vectors
13:19:16 <rwbarton> don't know whether vector includes an intersection algorithm for those, I guess probably not
13:19:33 <tristanStrange> :w
13:19:51 <Carnassial> acowley: I'll try both Set and Vector and see how it goes then :)
13:20:01 <acowley> vector-algorithms can help with sorting
13:20:03 <tristanStrange> erm sorry... ignore me thought you guys were vim fro second
13:20:39 <rwbarton> oh, vector doesn't seem to include any intersection at all, odd
13:20:42 <acowley> tristanStrange: Are you writing a very specialized geeky screenplay in vim?
13:20:53 <n-dolio> I don't think that's very odd.
13:21:03 <klrr_> anyone know where i can get this paper? http://lambda-the-ultimate.org/node/2340 the pdf link is dead
13:21:20 <rwbarton> I thought it tried to replicate the Data.List API
13:22:17 <Welkin> klrr_, search with filetype:pdf
13:22:21 <Welkin> and the title
13:22:38 <klrr_> Welkin: google?
13:22:40 <Welkin> yes
13:22:42 <klrr_> okey
13:22:43 <Welkin> or ddg
13:22:51 <klrr_> same syntax? :)
13:23:10 <Welkin> yes
13:23:51 <klrr_> http://strictlypositive.org/Easy.pdf (in case someone is also interested)
13:24:10 <tyro> Hi, I need some software engineering advice and thought there might be some smart people here who could help (if it's the wrong place for this then please let me know or just ignore me :p)
13:24:20 <tyro> Here's my problem:
13:24:24 <tristanStrange> acowley: a screen play? just my disserattion sadly
13:24:29 <tyro> I have a group of types (product ADTs ~10-30 of them) and a set of objects whose types are in that group. All the ADTs share a common member A (of typeclass Ord), and I need to display a list of all the objects, ordered by A.
13:24:31 <n-dolio> I don't think it tries to implement all of Data.List. It implements the parts of Data.List that make sense for vector building, folding, slicing, etc.
13:24:42 <albeit> I'm using Map.adjust like "Map.adjust (+1) k map", but over hundreds of thousands of such calls, its building up thunks and using lots of memory. There is no strict version of adjust... how can I make it strict in values?
13:24:45 <keith903> acowley
13:24:45 <keith903> acowley
13:24:45 <keith903> acowley: I tried that command and got this. http://lpaste.net/104771 I'm not quite sure what it means.
13:24:57 <tyro> In a dynamic language, I would just bundle all the objects in a heterogeneous array but I'm unsure what a good typed solution would be.
13:25:06 <tyro> I guess I need some way to reduce the groups of types to one type so that I can store all the objects in an array - I could use a sum ADT but there are a lot of types so I'm unsure if that's the best way to go.
13:25:07 <tristanStrange> acowley: oh i get you! hah! I'm real slow sometimes
13:25:10 <rwbarton> well it has the pieces already, intersect x y = V.filter (`V.elem` y) x
13:25:16 <albeit> Ah nevermind there is a strict Map
13:25:49 <acowley> keith903: That looks like you already have a newer aeson?
13:25:59 <acowley> I'm not an expert at decoding cabal error messages, though
13:26:24 <keith903> acowley: Can you not have 2 versions of the same package installed?
13:26:45 <rwbarton> keith903: 0.7.0.3
13:27:01 <rwbarton> keith903: you told it to install 7.0.3
13:27:02 <acowley> ah!
13:27:58 <keith903> rwbarton: ah yeah that would be a problem
13:28:25 <n-dolio> I'm a little surprised it has V.elem, since 'use a vector as a set' is mostly just as bad an idea as 'use a list as a set'.
13:29:00 <rwbarton> certainly it doesn't have anything as complex as sort, so yeah it doesn't replicate all of Data.List
13:29:02 <n-dolio> Although you could fuse away generating a vector and testing for an element as your final computation.
13:29:12 <n-dolio> Which might make sense.
13:29:16 <rwbarton> it might be a pretty good idea if your set has around 8 elements
13:29:21 <rwbarton> say
13:29:24 <n-dolio> Intersect makes less sense in that regard.
13:30:13 <n-dolio> It's probably a better idea to make Set adapt appropriately.
13:30:47 <rwbarton> if you had unboxed Set too, then yeah probably
13:30:59 <Carnassial> Vector might end up speeding things up else where tho, it'd be nice to have indexing in O(1)
13:32:38 <n-dolio> Adaptive containers never really took off for some reason.
13:32:53 <agrif> hello! I'm looking for an applicative instance that works like the writer monad, but lets you get the written stuff without running the computation
13:32:57 <keith903> so that worked, thanks rwbarton and acowley
13:33:03 <agrif> and I was wondering if somebody has already written one
13:33:29 <shachaf> agrif: I'm not sure what "running the computation" means, but maybe you're looking for Control.Applicative.Const.
13:33:33 <acowley> Carnassial: after you're done inserting and intersecting, convert to vector for lookups!
13:33:43 <acowley> keith903: hooray!
13:33:44 <agrif> not quite, I want something that works on top of an existing applicative
13:34:32 <agrif> basically: (wa, a) <*> (wb, b) = (wa <> wb, a <*> b)
13:34:52 <Carnassial> acowley: I need the indexing before intersect, so i guess i'll do the opposite :P thanks
13:35:19 <ion> agrif: Perhaps use Free or Operational and write separate interpreters for getting the written stuff and “running the computation” (whatever that means).
13:35:46 <n-dolio> agrif: Compose (Writer w) f
13:37:29 <rien_> I have a generic question, more of a curiosity. is it possible to write a liftMymonad that cuts through arbitrarily many monad layers?
13:37:38 <rien_> like liftIO does?
13:37:40 <vandenoever> is there a nice way to use Haskell with Qt?
13:37:52 <acowley> ?hoogle hsqml
13:37:54 <lambdabot> package hsqml
13:37:54 <lambdabot> package hsqml-morris
13:38:12 <acowley> vandenoever: But the Qt 5.0 support is fairly new
13:38:14 <Carnassial> acowley++
13:38:24 <vandenoever> acowley: any nice example apps that use it?
13:38:28 <Carnassial> rwbarton++
13:38:39 <acowley> I'd really like to give hsqml a serious go, but ran into some trouble when I tried
13:38:46 <acowley> vandenoever: The repo has examples
13:39:51 <vandenoever> i'm considering what ui to use and my preference goes to qt or maybe html via a local yasod
13:40:26 <Carnassial> preflex: acowley++
13:40:44 <Carnassial> mmmm how do i give karma?
13:41:27 <acowley> vandenoever: Well I'd certainly like to see more people try to use hsqml as I think it has a ton of promise
13:41:47 <acowley> vandenoever: But I ended up doing my thing with C++ backing the QML
13:42:36 <hyg> how would you prettify this line: f $ TypeCons (read $ args !! 0) (read $ args !! 1) (read $ args !! 2) -- ?
13:45:16 <bennofs> chirpsalot: just
13:45:21 <bennofs> acowley++
13:45:27 <bennofs> @karma acowley
13:45:27 <lambdabot> acowley has a karma of 7
13:46:20 <hyg> where TypeConst is defined like this: data TypeConst = TypeConst { a :: Double, b :: Double, c :: Double } deriving (Show)
13:48:04 <agrif> n-dolio: that's the closest I've seen yet, thanks
13:48:12 * hackagebot shake 0.13.1 - Build system library, like Make, but more accurate dependencies.  http://hackage.haskell.org/package/shake-0.13.1 (NeilMitchell)
13:48:41 <agrif> I think I'll want to use (abuse?) it as an Alternative, though, so I guess I'll just add that myself
13:48:43 <acowley> hyg: let (a:b:c:_) = map read args in f $ TypeCons a b c
13:48:45 <hyg> i thought i could do something like: map read args :: TypeConst -- but it doesn't typecheck since map returns a list (i.e, i would like the list elements to be named, hence the records)
13:49:12 <n-dolio> Which part is Alternative?
13:49:15 <n-dolio> The f?
13:49:18 <agrif> the g
13:49:30 <agrif> well, the g in Compose f g
13:49:40 <n-dolio> What about WriterT, then?
13:50:08 <hyg> acowley: good catch!
13:50:42 <deweyvm> is there a way to use identifier substitution in HDBC prepared statements? rather than just ?'s
13:51:02 <n-dolio> Wait, that's backwards, isn't it?
13:51:13 <n-dolio> f (w, a)
13:51:47 <agrif> I want to access the written data without 'running' the underlying applicative
13:52:16 <agrif> so if I have a MyThingT w IO a, then I can get a w out of it without running the IO action
13:52:36 <agrif> WriterT won't do that, I don't think
13:52:42 <n-dolio> Right.
13:53:19 <agrif> Compose (Writer w) IO will, but then I don't get an alternative
13:53:32 <agrif> and I'm pretty sure the alternative instance is useful here
13:53:51 <madjestic> I've got a foo::IO followed by bar::IO inside a do.  There's a value of type myval::Int I would like to pass from foo::IO to bar::IO.  Is there a way to do it? (/am I doing a right thing?)
13:54:31 <acowley> If you want to keep the underlying value (e.g. something in IO) opaque, why not just use a Writer w (IO a)?
13:54:32 <n-dolio> Is what you want empty = Compose (pure empty) ; Compose l <|> Compose r = Compose $ liftA2 (<|>) l r?
13:54:44 <shapr> bergmark: Ever used cassava for parsing dates out of a csv file?
13:54:58 <agrif> n-dolio, yeah that looks right
13:55:18 <agrif> I'm suspicious though, because that's not an implementation for Compose :P
13:55:37 <n-dolio> Well, only one instance can be picked.
13:55:46 <n-dolio> And they picked the one where f is Alternative.
13:56:00 <agrif> bummer, then
13:56:03 <rwbarton> I would think you would want to use a different operator to combine the ws when (<|>)ing
13:56:34 <rwbarton> like keeping a list of all the possible w values, rather than smashing them all together in the Monoid
13:57:05 <agrif> using <> when <|>ing is useful at least in my specific case
13:57:20 <rwbarton> it would depend on the use case, yes
13:59:45 <agrif> well, thanks everyone
13:59:54 <agrif> I suppose I'll keep my own implementation around then
14:00:09 <rwbarton> but maybe you wanted Compose (Writer [w]) f
14:00:17 <rwbarton> er
14:00:49 <n-dolio> I think a lot of people would be unhappy that you're using the Alternative instance for IO.
14:00:53 <n-dolio> But do what you will.
14:00:58 <agrif> I'm not actually using IO
14:01:02 <agrif> it was just a handy example
14:01:09 <n-dolio> Oh.
14:01:11 <rwbarton> Compose (Writer (Alts w)) f where newtype Alts w = Alts [w]; Alts ws1 <> Alts ws2 = Alts (liftA2 (<>) ws1 ws2)
14:01:38 <agrif> realistically I'm using Error + Reader
14:01:59 <ion> rwbarton: Oh, we already have scoped types? :-P
14:02:06 <rwbarton> yes
14:02:09 <rwbarton> new #haskell feature
14:02:32 <joelteon> IO has an Alternative instance??
14:02:41 <n-dolio> Yes.
14:03:03 <ion> joelteon: Yes, it pulls back the missiles if the first action failed before falling back to the second one.
14:03:27 <joelteon> My GHCi says it doesn't
14:03:47 <joelteon> are you fibbing?
14:04:16 <n-dolio> Maybe it doesn't have Alternative. That'd be an anomaly, though, because it has a MonadPlus instance.
14:04:34 <ion> Hmm, perhaps your GHC is not compiled with causality violations.
14:04:55 <joelteon> It doesn't have a MonadPlus instance either, for me.
14:05:03 <n-dolio> Well, that's new, then.
14:06:07 <glguy_> Haddocks don't show MonadPlus IO  in base back as far as 4.0.0.0
14:06:12 <glguy_> (I stopped looking after that)
14:06:41 <joelteon> I can't understand what mplus for IO would be, other than 'const'.
14:06:53 <n-dolio> Handle exceptions.
14:07:00 <joelteon> really?
14:07:04 <n-dolio> Yes.
14:07:07 <napping> hmm
14:07:14 <joelteon> That's terrifying.
14:07:20 <napping> aren't there laws against that?
14:07:35 <napping> Unless you've got ion's CTC hardware
14:07:52 <ion> Nice, it’s an orphan instance in http://hackage.haskell.org/package/transformers-0.2.1.0/docs/src/Control-Monad-Trans-Error.html
14:07:55 <glguy_> MonadPlus has very few requirements: mzero >>= f  =  mzero   and v >> mzero   =  mzero   and mplus is associative
14:08:01 <napping> fireTheMissiles >> mzero = mzero
14:08:18 <rwbarton> the n-dolio Alternative (Compose (Writer w)) instance wouldn't satisfy the distributive law that is sometimes assumed
14:08:21 <n-dolio> That 'law' doesn't work for several other monads anyway.
14:08:40 <n-dolio> And distributivity doesn't always work, either.
14:08:48 <c_wraith> This is why there was the thing about right semi near rings
14:08:51 <rwbarton> sure, but sometimes you want it
14:09:04 <rwbarton> the instance I half specified is supposed to provide it
14:09:13 <rwbarton> if I did it right
14:09:33 <ion> Link to more recent package version, it still has it. Also, now with Alternative IO. :-P http://hackage.haskell.org/package/transformers-0.4.1.0/docs/src/Control-Monad-Trans-Error.html
14:10:04 <n-dolio> Okay. Things haven't changed that much, then.
14:11:49 <acowley> Technical term: snafu
14:13:41 <carter> ?
14:14:22 <napping> carter: transformers apparently contains an instance MonadPlus IO !
14:14:29 <carter> ewww
14:14:54 <carter> ihaha
14:15:00 <carter>   mzero       = ioError (userError "mzero")
14:15:07 <ion> naturally
14:15:20 <ion> Also, empty = ioError (userError "mzero")
14:16:53 <acowley> Don't you like the blame attribution? It's your fault for using this!
14:18:05 <ion> acowley: Fair enough, mplus _ _ = ioError (userError "mplus")
14:18:44 <acowley> ion: I want mzero = ioError (myBad ":(")
14:18:58 <acowley> or, to be more playful, mzero = ioError (gotcha ":D")
14:19:54 <albeit> I have a memory problem... I have a rapidly increasing number of objects in a void state (from biography profiling), and the cost center is a function that is often called. Specifically, insertLookup at this line: "(oldEdge, edges') = insertLookup k bestEdge' edges". insertLookup is just Map.insertLookupWithKey discarding the key. Any ideas on why so much is building up?
14:20:32 <c_wraith> albeit: probably laziness.
14:20:53 <acowley> what if you force the tuple?
14:20:58 <c_wraith> albeit: repeatedly modifying a structure is a case where laziness adds up to pain.
14:21:12 <albeit> c_wraith: Well I figured that... I just don't know where to make it strict.
14:21:20 <albeit> acowley: Doesn't do any good
14:21:33 <albeit> c_wraith: Is that a hint I should use a mutable structure?
14:21:35 <jfischoff> without looking at the code it is hard to say ... but
14:21:43 <c_wraith> albeit: first, what are you importing?
14:21:58 <acowley> albeit: And that's with a Strict Map?
14:21:58 <c_wraith> albeit: second, what is the type of the Map you're using?
14:22:00 <jfischoff> probably edges so (.., !edges) = ..
14:22:14 <acowley> jfischoff: That's what I was suggesting
14:22:20 <jfischoff> yes I know :)
14:22:22 <albeit> c_wraith, acowley: Importing/ysing Data.IntMap
14:22:49 <c_wraith> albeit: switch to Data.IntMap.Strict
14:22:52 <jfischoff> I just wanted to be more clear because it could also have been interpreted as !(x, y) which will not do anything
14:22:54 <c_wraith> albeit: and what's the type of the values?
14:23:43 <jfischoff> probably the right place for the strictness is on the input argument of a recursive functino
14:23:54 <albeit> "edges" are of type IntMap Edge, where Edge = Edge Int Int EdgeType
14:24:19 <c_wraith> albeit: EdgeType is a simple enumeration type?
14:24:23 <albeit> And EdgeType is just a sum type with no extra values (if that makes sense...)
14:24:28 <albeit> Ah enumeration type, thats what I meant
14:24:40 <bennofs> albeit: IMO, the heap profile by type (-hy) is often also very useful
14:25:19 <jfischoff> albeit: a paste of the code will help a lot too ;)
14:25:22 <c_wraith> albeit: In that case, the import change and changing the data definition to Edge !Int !Int !EdgeType is a good starting point
14:25:24 <jle`> MonadPlus for IO?
14:25:43 <jle`> what
14:25:55 <bennofs> jle`: exceptions i think
14:26:15 <ion> Sure, exceptions to the MonadPlus laws. :-P
14:26:29 <jfischoff> heh
14:26:30 <albeit> And voila, changing to strict imap worked!
14:27:05 <albeit> And I don't think I'm benefiting from the lazyness of that map anyways, so should be all good
14:27:09 <albeit> Thanks!
14:27:11 <c_wraith> albeit: the strict operations (the data type is the same, the difference is the operations), force the values insert to be evaluated at the same time the map is evaluated.
14:27:14 <jle`> ...
14:28:06 <c_wraith> albeit: If the values are calculated based on a previous version of the IntMap, you end up with that thunk holding on to the previous map
14:28:43 <albeit> c_wraith: Yep, values were based on old values (most of the time), so that must have been what was happening
14:28:55 <c_wraith> albeit: And so until that value is actually required, it builds up a big chain of thunks, each one holding on to the entire previous state
14:29:03 <jle`> heh you can use guard in IO then I guess
14:29:11 <jle`> no, this is all wrong and it shouldn't be there
14:29:16 * jle` flips tables or something
14:29:46 <c_wraith> albeit: as you can imagine, the memory use can add up quickly that way.
14:29:51 <napping> It's amazing how do putStrLn "Hello World!"; fireTheMissiles; threadDelay (10^100); mzero has exactly the same observable results as mzero ;)
14:31:19 <jle`> all bottoms are indistinguishable rite
14:31:34 <c_wraith> they have the same denotation
14:31:55 <jle`> i don't like
14:31:59 <jfischoff> you can catch some
14:32:07 <jle`> (fireMilles >> mzero) <|> foo
14:32:20 <jle`> that has to violate some MonadPlus/Alternative laws >_>
14:32:33 <jle`> also i really hate Milles, he deserves to be fired.
14:32:43 <jfischoff> :)
14:33:26 <jle`> actually I guess "MonadPlus/Alternative laws" isn't really a well defined thing
14:33:51 <jle`> but i'm sure that mzero <|> x should = x
14:33:53 <jle`> :/
14:34:29 <jle`> http://en.wikibooks.org/wiki/Haskell/MonadPlus#The_MonadPlus_laws
14:34:30 <c_wraith> jle`: right semi-nearring is a formalism that seems like an obvious minimal set of laws.  The current IO implementation seems to work with them
14:34:58 <c_wraith> jle`: http://winterkoninkje.dreamwidth.org/90905.html
14:36:09 <c_wraith> jle`: huh.  Guess IO doesn't work with it.
14:36:20 <jle`> the article seems to address >>, not mplus
14:38:33 <jle`> distributivity is a good point
14:39:04 <jle`> you can't say (x+y)*z = (x*z)+(y*z) if z has effects
14:39:20 <gauthier> is there a command in cabal (or something I can use aside) that would check a .cabal and tell me whenever a upper constraint of referenced packages is not matching with hackage packages?
14:39:59 <shelf> is there a list of events like BayHac and NYC Hac somewhere? I'm looking for forthcoming events
14:40:13 <glguy_> requiring distributivity would prevent this from being a monadplus, as well: http://lpaste.net/104774
14:40:30 <gauthier> shelf: http://haskellnews.org/grouped events section
14:40:54 <gauthier> shelf: nothing forthcoming though there
14:40:55 <shelf> gauthier: awesome! thanks
14:41:27 <ab9rf> wee!
14:41:35 <Kazagistar> If anyone has a few min, I would appreciate comments and criticism of this http://lpaste.net/104773
14:41:48 <ab9rf> i finally got my eclipsefp environment working again
14:41:56 <gauthier> shelf: I think you could join the various user groups on meetup to get updates from there
14:42:36 <shelf> yeah. I am free and able to travel the US over summer, so I don't have specific regions to monitor
14:42:42 <Kazagistar> it is a proposal for a Typeclass that would allow you to reverse the "getAssocs" function of MArray and the like
14:43:08 <jle`> ab9rf: congrats :)
14:44:23 <Arnob> Hi all
14:44:30 <ab9rf> my main problem turned out to be using Java 8 :)
14:44:44 <Arnob> I having some issues with persistent
14:44:48 <Arnob> getting types to match up
14:44:52 <Arnob> I have some sample code here
14:44:57 <Arnob> http://lpaste.net/104775
14:44:58 <Kazagistar> currently, using just Ix or Ord or whatnot, it is not possible to take a list of key-value pairs and create an array that will be guaranteed to fit them
14:45:02 <Arnob> when IU try to build my project
14:45:07 <Arnob> I get the error
14:45:21 <Arnob>   Couldn't match type `PersistEntityBackend Notice'                   with `MongoBackend'     Expected type: PersistEntityBackend Notice       Actual type: PersistMonadBackend (Action m)     In the first argument of `(.)', namely `insert'     In the first argument of `mapM_', namely `(insert . Notice)'     In the expression: mapM_ (insert . Notice) x
14:45:36 <mmachenry> What line?
14:45:59 <mmachenry> Oh I see, mapM_
14:46:25 <acowley> I really hate it when I can't construct a smaller example of a problem. It throws everything into uncertainty.
14:46:48 <Arnob> I think I have to specify the type for x? I am not sure
14:46:59 <mmachenry> I don't see runMongoDBPoolDef on hoogle.
14:47:00 <mmachenry> :t runMongoDBPoolDef
14:47:01 <lambdabot> Not in scope: ‘runMongoDBPoolDef’
14:47:07 <mmachenry> :hoogle runMongoDBPoolDef
14:47:16 <mmachenry> oops, I fail at lambda bot
14:48:53 <mmachenry> @hoogle runMongoDBPoolDef
14:48:55 <lambdabot> No results found
14:48:59 <mmachenry> There we go.
14:49:00 <bergmark> shapr: i have used cassava but not for dates
14:49:18 <Arnob> http://hackage.haskell.org/package/persistent-mongoDB-1.1.5.2/docs/Database-Persist-MongoDB.html
14:49:21 <mmachenry> Arnob: Where is that function defined?
14:49:32 <Arnob> runMongoDBPoolDef :: (MonadIO m, MonadBaseControl IO m) => Action m a -> ConnectionPool -> m a
14:50:34 <luke_wm> clear
14:52:20 <mmachenry> Arnob: That IO needs to be wrapped in an Action it looks like.
14:52:39 <mmachenry> I don't know this library and I don't see what insert is either.
14:52:41 <Arnob> mmachenry: I am sending this function "saveNotices x" a Map (i.e.: fromList [("myKey1", "myValue1")]
14:53:01 <mmachenry> But… I think you need to wrap save in an Action from that library to call runMongoDBPoolDef
14:53:24 <Arnob> so lift(x)?
14:53:36 <Arnob> I thought the type of insert was Action m?
14:53:57 <mmachenry> Not sure. Maybe.
14:55:29 <Kazagistar> Arnob: could you also post the type of insert, so we can check?
14:55:48 <Arnob> I am trying to find the function
14:59:40 <Arnob> I cannot find the documentation for insert anywhere
15:00:05 <mmachenry> Arnob: It'd be easiest to pastbin this with all the functions that you're using defined at the top with their exact types listed and "= undefined " so that it works stand alone and then a copy and paste of the whole entire error in a comment.
15:00:07 <Arnob> this is the package
15:00:08 <Arnob> http://hackage.haskell.org/package/yesod-persistent
15:00:33 <Kazagistar> Arnob: what is even more strange is I cannot find a way to create an Action at all, hmm
15:00:41 <Arnob> the insert function is from the yesod persistent library
15:00:55 <Arnob> but I cannot find it in the documentation for persistent...
15:02:40 <benzrf> mmachenry: hehehe
15:03:20 * hackagebot pandoc-lens 0.1.0.0 - Lenses for Pandoc documents  http://hackage.haskell.org/package/pandoc-lens-0.1.0.0 (BenGamari)
15:03:29 <mzarella> event driven programming -> message passing -> inter-process communication... http://hackage.haskell.org/package/hlibev-0.2.3/docs/Network-Libev.html
15:03:40 <Arnob> ah this is frustrating
15:03:42 <Kazagistar> (I wish library authors would provide example code for this reason...)
15:03:46 <mzarella> Where does this all sit in the list of concurrency models?
15:04:05 <mzarella> https://en.wikipedia.org/wiki/Concurrency_(computer_science)#Models
15:04:41 <Arnob> Ah! found it
15:04:41 <Arnob> http://hackage.haskell.org/package/persistent-1.3.1.1/docs/Database-Persist-Class.html
15:04:52 <Arnob> insert :: (PersistMonadBackend m ~ PersistEntityBackend val, PersistEntity val) => val -> m (Key val)
15:23:22 * hackagebot shelltestrunner 1.3.4 - A tool for testing command-line programs.  http://hackage.haskell.org/package/shelltestrunner-1.3.4 (SimonMichael)
15:24:26 <joehillen> anyone know conduits well? https://stackoverflow.com/questions/23922855/how-can-i-get-a-value-after-running-a-conduit
15:26:20 <agrif> is there a way to get values annotated with line numbers / other location data out of Aeson?
15:26:30 <agrif> or maybe some other library to do that with json?
15:28:01 <rekahsoft> hi all,,i just came across something that seems odd imho..specifically:
15:28:47 <rekahsoft> replicate (10^1000) 'a' == replicate (10^100) 'a'
15:28:56 <rekahsoft> this returns True?? why?
15:29:11 <Axman6> > (10^1000) :: Int == (10^100)
15:29:11 <sipa> > 10^100
15:29:12 <lambdabot>  <hint>:1:22: Illegal literal in type (use DataKinds to enable): 10
15:29:13 <lambdabot>  can't find file: L.hs
15:29:24 <Axman6> > (10^1000)== (10^100 :: Int)
15:29:26 <lambdabot>  True
15:29:34 <Axman6> > (10^100 :: Int)
15:29:35 <lambdabot>  can't find file: L.hs
15:29:43 <Axman6> lambdabot!
15:29:45 <Iceland_jack> > replicate (10^1000) 'a'
15:29:46 <rekahsoft> aweee..because its Int and not Integer
15:29:47 <lambdabot>  ""
15:29:50 <sipa> @forget
15:29:50 <lambdabot> Incorrect arguments to quote
15:29:55 <Iceland_jack> > replicate (10^100) 'a'
15:29:55 <sipa> @reset
15:29:55 <lambdabot> Say again?
15:29:56 <Axman6> > (10^100 :: Int)
15:29:57 <lambdabot>  ""
15:29:58 <lambdabot>  0
15:30:03 <sipa> @undef
15:30:03 <lambdabot> Undefined.
15:30:15 <sipa> > (10^100 :: Int)
15:30:16 <lambdabot>  0
15:30:26 <Axman6> > iterate (10*) 10
15:30:27 <lambdabot>  [10,100,1000,10000,100000,1000000,10000000,100000000,1000000000,10000000000,...
15:30:31 <Axman6> > iterate (10*) 10 :: Int
15:30:32 <lambdabot>  Couldn't match expected type ‘GHC.Types.Int’
15:30:32 <lambdabot>              with actual type ‘[a0]’
15:30:37 <Axman6> > iterate (10*) 10 :: [Int]
15:30:38 <lambdabot>  [10,100,1000,10000,100000,1000000,10000000,100000000,1000000000,10000000000,...
15:30:50 <Axman6> > drop 20 $ iterate (10*) 10 :: [Int]
15:30:51 <lambdabot>  [3875820019684212736,1864712049423024128,200376420520689664,2003764205206896...
15:31:00 <Axman6> > drop 10 $ iterate (10*) 10 :: [Int]
15:31:02 <lambdabot>  [100000000000,1000000000000,10000000000000,100000000000000,1000000000000000,...
15:31:08 <Axman6> > drop 15 $ iterate (10*) 10 :: [Int]
15:31:09 <lambdabot>  [10000000000000000,100000000000000000,1000000000000000000,-84467440737095516...
15:31:13 <Axman6> bam
15:31:37 <Arnob> ooh
15:31:42 <Arnob> what is this lambdabot thing
15:31:49 <Arnob> iterate (10*) 10
15:31:58 <Iceland_jack> Arnob: add '> '
15:32:01 <Iceland_jack> > 5 + 10
15:32:03 <lambdabot>  15
15:32:05 <Arnob> > iterate (10*) 10
15:32:07 <Kazagistar> feel free to message it with @help
15:32:07 <lambdabot>  [10,100,1000,10000,100000,1000000,10000000,100000000,1000000000,10000000000,...
15:32:08 <Axman6> a guy in China we pay to evaluate Haskell expressions. he's become very good
15:32:14 <Arnob> oh... that's so cool!
15:32:25 <rekahsoft> > True
15:32:26 <lambdabot>  True
15:32:34 <shelf> > fix not
15:32:38 <lambdabot>  mueval-core: Time limit exceeded
15:32:40 <rekahsoft> Iceland_jack: thats handy :)
15:32:43 <Arnob> does he only have acces to the prelude
15:32:45 <Iceland_jack> > this == "so cool"
15:32:47 <Arnob> or to all of hackage?
15:32:47 <lambdabot>  True
15:32:49 <Qer> guys, what does # mean in Haskell? e.x. in "timesInteger (S# 0#)     _         = S# 0#"
15:32:54 <deni> is there a shortcut for this: fmap (fmap (Map.lookup "apiKey.id")) myMap
15:33:14 <benzrf> Qer: just part of the name
15:33:15 <Axman6> @google haskell magichash
15:33:16 <lambdabot> http://www.haskell.org/ghc/docs/7.0.3/html/users_guide/syntax-extns.html
15:33:16 <lambdabot> Title: 7.3.�Syntactic extensions
15:33:23 <Axman6> Qer: ^
15:33:38 <Kazagistar> > drop 50 $ iterate (10*) 10 :: [Integer]
15:33:39 <lambdabot>  [1000000000000000000000000000000000000000000000000000,1000000000000000000000...
15:33:40 <Axman6> it's generally used for things internal to the compiler
15:33:42 <Qer> so 0# is just 0?
15:33:43 <Kazagistar> unbam
15:33:45 <Axman6> @src Int
15:33:45 <lambdabot> data Int = I# Int#
15:34:09 <Qer> because I am trying to figure out how haskell multiplies by 0
15:34:10 <Axman6> Qer: 0# is a machine Int# (ie, a C int)
15:34:12 <Qer> and why this is fast
15:34:33 <Axman6> special case for some types
15:34:55 <Axman6> @src (^)
15:34:55 <lambdabot> x ^ 0            =  1
15:34:55 <lambdabot> x ^ n | n > 0    =  f x (n-1) x
15:34:55 <lambdabot>   where f _ 0 y = y
15:34:55 <lambdabot>         f x n y = g x n
15:34:55 <lambdabot>           where g x n | even n  = g (x*x) (n `quot` 2)
15:34:57 <lambdabot>                       | otherwise = f x (n-1) (x*y)
15:34:59 <lambdabot> _ ^ _            = error "Prelude.^: negative exponent"
15:35:48 <Qer>  @src (*)
15:35:55 <Arnob> argh... so frustrated with my "program"
15:35:57 <Qer>  @src (*)
15:36:03 <Qer> it ignores me ;<
15:36:05 <Arnob> somehow I can get it to compile on my home PC
15:36:12 <Arnob> but not my work PC
15:36:17 <Iceland_jack> Qer: You're adding a space
15:36:17 <Axman6> (*) is part of the Num class and its source depends on the type of the arguments.
15:36:23 <Axman6> @src Integer (*)
15:36:23 <lambdabot> Source not found. Wrong!  You cheating scum!
15:36:24 <Arnob> just last night... I was happily saving text to a database
15:36:36 <Axman6> Qer: also you're putting a space before the @
15:36:43 <Qer> @src (*)
15:36:44 <lambdabot> Source not found. I can't hear you -- I'm using the scrambler.
15:36:50 <Qer> how, I did, didn't notice ;d
15:41:48 <Kazagistar> I quite like that lambdabot is a her
15:43:01 <Kazagistar> @slap Nothing
15:43:01 * lambdabot hits Nothing with a hammer, so they breaks into a thousand pieces
15:43:12 <Kazagistar> @slap Nothing
15:43:13 * lambdabot clobbers Nothing with an untyped language
15:43:20 <Axman6> D:
15:43:29 <Axman6> say it isn't so! that's so dangerous!
15:43:30 <Kazagistar> @slap Nothing
15:43:30 * lambdabot pokes Nothing in the eye
15:43:57 <ion> @slap herself
15:43:57 * lambdabot will count to five...
15:44:02 <ion> nice
15:45:14 <augur> @slap yourself
15:45:14 * lambdabot locks up lambdabot in a Monad
15:45:19 <augur> BAM
15:51:14 <joelteon> unsafePerformMonad
15:52:01 <Axman6> that doesn't make much sense...
15:53:25 <augur> Axman6: sure it does
15:53:34 <augur> unsafePerformMonad :: Monad m => m a -> a
15:53:44 <augur> :t unsafePerformIO
15:53:45 <lambdabot> Not in scope: ‘unsafePerformIO’
15:53:48 <augur> HAH
15:54:20 <augur> anyway, unsafePerformIO = unsafePerformMonad ideally
15:54:50 <glguy_> :t ideally
15:54:52 <lambdabot> Not in scope: ‘ideally’
15:54:59 <augur> glguy_: x3
15:58:19 <augur> anyone know what the RealWorld type for GHC's IO implementation consists of?
15:58:57 <luite> of nothing, at runtime at least, it has no representation
15:59:16 <augur> luite: huh. interesting. how does GHC implement IO then?
15:59:35 <copumpkin> impurely
15:59:39 <augur> copumpkin: :x
15:59:42 <augur> copumpkin: elaborate?
15:59:46 <copumpkin> RealWorld is just a sequencing marker
15:59:51 <augur> ?
15:59:54 <copumpkin> doesn't do anything at all
16:00:01 <augur> what do you mean a sequencing marker?
16:00:07 <copumpkin> it forces one thing to happen after another
16:00:12 <augur> how so?
16:00:29 <Polarina> augur, it's there to keep the type-system happy. It is actually implemented with deep magic in GHC that does some crazy stuff.
16:00:40 <augur> yes but what deep magic!
16:00:42 <augur> im curious
16:00:58 <augur> ive never liked the RealWorld conception, so im curious what evil it really consists of
16:00:59 <geekosaur> the typechecker sees a data dependency on RealWorld and uses it to enforce ordering. then the code generator sees that it's never actually used and removes it
16:01:05 <geekosaur> keeping the ordering
16:01:18 <geekosaur> it does nothing else
16:01:20 <augur> geekosaur: hmm.. example?
16:01:56 <augur> specifically of the ordering enforcement you mean, and also what the generated code is (in whatever pseudocode you want)
16:02:11 <copumpkin> well, the optimizer has no way of knowing that RealWorld isn't a real value
16:02:25 <copumpkin> so it needs to call the RW -> (RW, a) function before it can call the next IO action
16:02:31 <geekosaur> I'm not sure what you're looking for. IO is just a (modified) state monad, which makes sure that there are dependencies on the state (RealWorld) in IO computations. but since it's never actually used, it goes away during code generation
16:02:35 <copumpkin> that enforces ordering
16:02:37 <geekosaur> there is no magic involved anywhere
16:02:46 <Cale> augur: It's just making use of the fact that no evaluation is ever done underneath lambdas
16:02:47 <copumpkin> the only unusual thing is that it's a type with no runtime representation
16:03:19 <geekosaur> the name RealWorld is more a joke than anything else
16:03:27 <augur> if RW ~ Void, then how do you actually run the darn thing?
16:03:32 <geekosaur> because it doesnt represent anything at all, much less the state of the world
16:03:46 <geekosaur> by the fact that the entry point of a program is main :: IO a
16:03:56 <copumpkin> augur: it isn't void
16:04:08 <augur> copumpkin: but it has no runtime representations
16:04:14 <copumpkin> so? that's an implementation detail
16:04:29 <copumpkin> the point is it's a type whose contents are unknown, but that is effectively ()
16:04:46 <copumpkin> realWorld# :: RealWorld#
16:04:50 <copumpkin> that's how you get one
16:04:51 <geekosaur> Void has *more* representations than RealWorl, because Void can have bottom as a value. RealWorld doesn't even exist.
16:04:59 <augur> copumpkin: ahh ok. so it "has" representations but they're useless
16:05:02 <augur> hm.
16:05:19 <copumpkin> you need to start feeding the RW -> (RW, a) machine somewhere :P
16:05:21 <hexagoxel> does () have a runtime representation?
16:05:24 <augur> and youre not allowed to have them, i guess thats what it means, to say that it has no runtime representations??
16:05:45 <geekosaur> it's a type hack that goes away. just like ST has an existential "state" value that only exists in the mind of the typechecker
16:05:51 <augur> copumpkin: ie, RealWorld# does not export constructors/values, so they exist, but you dont get them?
16:06:05 <copumpkin> augur: it's like record Unit : Set in Agda. That doesn't need to be represented in any way at runtime
16:06:14 <copumpkin> because its only inhabitant is trivial
16:06:16 <augur> copumpkin: right ok
16:06:32 <copumpkin> however
16:06:33 <c_wraith> hexagoxel: there is one (evaluated) value of type () stored in memory and shared.  However, a value of type () may not yet bet evaluated, and if it's not evaluated, the thunk points to code.
16:06:36 <augur> not that i know how agda optimizes that away either :p
16:06:40 <copumpkin> it doesn't run :P
16:06:47 <copumpkin> more like data Unit : Set where tt : Unit
16:06:57 <copumpkin> since the whole point is for Haskell not to assume things about its inhabitants
16:07:01 <c_wraith> hexagoxel: the reason that matters is because of seq - evaluating a value with type () might result in evaluating something else.
16:07:11 <augur> copumpkin: it doesnt run?
16:07:18 <copumpkin> nobody runs Agda
16:07:23 <augur> oh well yes :p
16:07:34 <augur> i heard someone actually ran an agda program once!
16:07:46 <copumpkin> it probably produced the wrong answer
16:08:15 <augur> copumpkin: so basically IO a is just secretly (morally) State () a
16:08:21 <copumpkin> yup
16:08:25 <augur> iiii see
16:08:25 <augur> ok
16:08:28 <copumpkin> well
16:08:29 <copumpkin> immorally
16:08:30 <copumpkin> :P
16:08:37 <augur> lol
16:09:58 <alevy> any apple+linux users know how I can reproduce the ghc-clang-wrapper hack in linux?
16:11:04 <hexagoxel> c_wraith: are there legal (non-unsafePerformIO) means to retrieve expressions of type unit that can not be trivially simplified to the one shared (evaluated) value?
16:12:24 <Cale> alevy: Why would you need to?
16:12:30 <c_wraith> hexagoxel: All legal thunks of type () will be evaluated to the shared value.  However, they may do other things first.
16:12:52 <alevy> Cale: so i can reproduce a bug that's being hit in my library only with clang's preprocessor, not GCC's
16:13:01 <c_wraith> :t rnf -- hexagoxel
16:13:02 <lambdabot> Not in scope: ‘rnf’
16:13:06 <c_wraith> Boo!
16:13:11 <Cale> alevy: ah, hm
16:13:21 <augur> copumpkin: boy. im chasing IO functions around the source code. im now at withHandle' and falling 0_0
16:13:38 <copumpkin> why?
16:13:51 <augur> copumpkin: because im curious!
16:13:57 <c_wraith> hexagoxel: well, in any case, rnf :: NFData a => a -> ()
16:14:02 <hexagoxel> c_wraith: ah, yeah i see
16:14:07 <benzrf> augur: i believe some of them are hardcoded into ghc
16:14:10 <hexagoxel> yeah i know how to hoogle :)
16:14:18 <benzrf> and not defined in haskell
16:14:40 <hexagoxel> c_wraith: thanks
16:15:26 <augur> benzrf: im just like.. really curious how things like putStr bottom out
16:15:39 <augur> what _is_ putStr, really
16:16:16 <augur> the IO system is so complicated
16:16:40 <benzrf> augur: putStr is a wrapped impure function that takes an uninhabited type
16:16:49 <benzrf> next!
16:16:52 <augur> benzrf: :p
16:17:05 <augur> actually apparently its some complicated thing having to do with handles and junk
16:17:07 <Axman6> clearly it just calls puts
16:17:09 <Axman6> >_>
16:17:21 <augur> i bottomed out at mask :: ((forall a. IO a -> IO a) -> IO b) -> IO b
16:19:38 <benzrf> :t mask
16:19:39 <lambdabot> ((forall a. IO a -> IO a) -> IO b) -> IO b
16:19:41 <benzrf> o_o
16:19:43 <benzrf> @src mask
16:19:43 <lambdabot> Source not found. I feel much better now.
16:19:59 <c_wraith> mask prevents the thread from receiving async exceptions
16:20:14 <copumpkin> augur: I assume you've poked around GHC.Prim?
16:20:18 <augur> copumpkin: nope!
16:20:25 <copumpkin> well
16:20:30 <copumpkin> you're not going to find putStrLn's innards there
16:20:46 <copumpkin> but you'll find more core parts of GHC's runtime
16:21:05 <copumpkin> ultimately those IO functions just call lower level OS IO functions impurely through the FFI
16:21:20 <augur> copumpkin: ive given up. i was expecting it'd be a nice, elegant little thing, but its a mess, so phooey :p
16:21:32 <c_wraith> The way putStr works, it has to make a syscall for every output character.
16:21:43 <c_wraith> Don't use putStr for performance-critical code. :)
16:22:05 <copumpkin> on the plus side, you get incremental output on infinite strings and strings with bottoms in them
16:22:27 <c_wraith> yeah, it's not the wrong choice
16:22:36 <c_wraith> It's just not what you use for performance
16:26:03 <fragamus> OK... WHERE IN THE BLUE BLAZES is the haskell package that does convex optimization
16:26:36 <augur> c_wraith: sure. however it does it tho, its complicated!
16:26:45 <augur> c_wraith: what is the code that does the syscall?
16:27:19 <Welkin> is "blue blazes" a reference to "hell"?
16:27:40 <Welkin> why blue?
16:27:44 <fragamus> i dont know
16:27:58 <fragamus> it just came out of me like that
16:28:15 <Welkin> to know the etymology may be interesting
16:28:16 <augur> Welkin: http://en.wiktionary.org/wiki/blazes
16:28:32 <Welkin> the etymology of the term "log out" and "login" comes from shipping
16:28:36 <lennartj> http://www.word-detective.com/2011/03/blue-blazes/
16:28:49 <Welkin> where one would record the ship's speed in a "log book"
16:29:03 <Welkin> and would measure the speed in "knots" using a knotted rope attached to a log
16:30:31 <fragamus> http://www.word-detective.com/2011/03/convex-optimization-in-friggin-haskell/
16:30:39 <lennartj> I'm not sure if you guys are planning to jump on it on Saturday and kill it, or if you want to save it for a time when you're less busy with finals and such. I will be unable to work on PANDA on Saturday due to ARML... I might be able to look at it on Sunday on the bus if everyone else is planning to start right away, but I'm also happy saving it if you prefer to do that instead.
16:30:50 <lennartj> whoops sorry ignore
16:31:32 <Welkin> finals? most universities are already on holiday
16:32:31 <lennartj> quarter-system schools usually start and end summer holiday relatively late
16:33:04 <lennartj> since we have one 11-week quarter before Christmas and two afterward
16:43:48 <EvanR> i made a pattern language in ruby to describe intended structure of nested arrays and hashes. but i have a construction like pattern1 OR pattern2 OR pattern3, it works, but the error message to tell you where in the tree your data is messed up stops there instead of going any lower... instead of v[3][:a][2][:b] is not String, it would say v[3] is not A or B or huge pattern involving :a :(
16:44:16 <EvanR> since by its standards, you could have messed up in any of the branches
16:45:18 <ij> Do I need AUR to get cpphs on arch?
16:47:10 <EvanR> i guess the deepest the match went, the more likely thats what the user was trying to do
16:53:32 * hackagebot lio 0.11.5.0 - Labeled IO Information Flow Control Library  http://hackage.haskell.org/package/lio-0.11.5.0 (DeianStefan)
17:23:36 * hackagebot cartel 0.4.0.0 - Specify your Cabal files in Haskell  http://hackage.haskell.org/package/cartel-0.4.0.0 (OmariNorman)
17:48:38 * hackagebot cartel 0.6.0.0 - Specify your Cabal files in Haskell  http://hackage.haskell.org/package/cartel-0.6.0.0 (OmariNorman)
17:54:35 <ij> @pl simplify = until (\x -> simplify' x == x) simplify'
17:54:35 <lambdabot> simplify = until ((==) =<< simplify') simplify'
17:54:49 <ij> Why isn't it @pl'd until the very end? (There is one)
17:55:40 <ij> @pl simplify f = until (\x -> f x == x) f
17:55:41 <lambdabot> simplify = until =<< ((==) =<<)
17:56:15 <ij> Oh, it prefers not making lambdas. Okay.
17:56:18 <ij> Silly me.
17:58:39 * hackagebot lambda-placeholders 0.0.0.0 - A library to emulate laceholders similar to Scala.  http://hackage.haskell.org/package/lambda-placeholders-0.0.0.0 (MatthewMirman)
17:58:47 <ion> >laceholders
18:05:29 <ajcoppa> trying to do the StateT exercises in the NICTA course is blowing my mind a little bit
18:14:21 <johnw> ajcoppa: have any questions?
18:16:30 <dmj`> why do threads have the same threadId number whenever a process restarts? Just curious, starts at 13 everytime.
18:17:11 <hpc> dmj`: use the source, luke
18:17:13 <johnw> it's probably not true on all systems either
18:17:38 <hpc> it's probably not even true on all binaries
18:17:39 <johnw> you should consider it an arbitrary value anyways
18:17:49 <johnw> don't even assume ordering
18:18:02 <dmj`> they increment by 4 as well :)
18:18:20 <dmj`> hpc: the RTS source?
18:23:13 <ajcoppa> johnw: well, i've been looking at my State implementations to draw parallels and just realized one of those was wrong (but still correct enough to pass the doctest)
18:24:07 <ajcoppa> it seems hard to ask questions that won't spoil it too much for me :)
18:47:42 <eacameron> I can't get anywhere because aeson 0.7.0.3 fails to build; it looks like I'm not the only one? What's the workaround?
18:48:57 <quchen> eacameron: Does .2 build? You can manually specify constraints for Cabal, are you sure you need .3?
18:49:09 <bergey> eacameron: Why do you need that version in particular?  If you can't use 0.7.0.6, I like 0.7.04, or constrain to scientific < 0.3 yourself.
18:49:33 <eacameron> I'm not directly dependant on it
18:50:07 <eacameron> how do I change the constraints?
18:50:10 <quchen> cabal instal XXX --constraint=aeson<=0.7.0.3
18:50:14 <quchen> Or something like that
18:50:17 <eacameron> ahh
18:50:33 <quchen> (Does cabal-install support inequality?)
18:52:59 <eacameron> (you have to escape it)
18:53:40 <eacameron> --constraint aeson\>0.7.0.3 seems to work
18:54:07 <eacameron> it installe 0.7.0.4, why didn't it just do that to begin with?
18:58:20 <Nightson> hello everyone
18:58:29 <Nightson> i'm trying to do a parser in haskell using Happy
18:58:46 <Nightson> however i'm having some troubles using bool type
18:58:54 <Nightson> and I can't find anything on the web
18:58:59 <Nightson> can someone help me?
19:00:18 <pavonia> You need to be a bit more specific
19:00:22 <EvanR2> maybe ask a question or provide some code on hpaste
19:01:50 <Nightson> ok
19:02:05 <Nightson> i don't know if you're familiar with Happy
19:02:14 <Nightson> i defined a token for True and False
19:02:48 <genericpersona> hpaste it up
19:03:41 <krakrjak> I'm trying to work with some matlab code in haskell...  anyone have pointers?
19:04:03 <genericpersona> write haskell in haskell and matlab in matlab, maybe? ;)
19:04:30 <dmj`> krakrjak: what are you trying to do
19:04:36 <krakrjak> yeah so I'm doing that part...  I need to interchange data and there is an old hackage package that looks close to what I need.
19:04:37 <genericpersona> i don't want help with code, i just want to know if you'd recommend creating a web app in haskell and why?
19:05:13 <EvanR2> traditional web apps are a great application of functional programming
19:05:18 <krakrjak> I am rewriting an algorithm for speed and instead of just using the code generator or hand writing a bunch of C++ I'm trying to rewrite the matlab code in haskell.
19:05:31 <EvanR2> im still missing template language X which has first class functions
19:05:55 <krakrjak> at some point I have to recieve my input from matlab and return results to matlab for plotting/figure generation.
19:06:28 <EvanR2> krakrjak: i played around with hmatrix, seems to work
19:06:47 <dmj`> genericpersona: yes. why? Types ensure correctness, you can encode your business logic in the types enforcing invariants in a way no dynamic language allows. Also, speed. The haskell RTS is very mature. Also refactorability, making large sweeping code base changes is simple thanks to ghc's typechecker. In python or javascript large code base changes are really painful and error prone.
19:07:08 <krakrjak> EvanR2: it's not even fancy enough to need such power.
19:07:59 <krakrjak> My hurdle at this point is just passing data to and from matlab...  the matlab package on hackage doesn't work with the modern platform.
19:09:16 <Nightson> ok I could solve it on my own after all
19:09:19 <Nightson> thank you anyway :)
19:10:32 <krakrjak> EvanR2: maybe I'm missing something... does hmatrix give me a way to communicate with matlab?
19:10:38 <EvanR2> no
19:10:46 <krakrjak> :(
19:11:01 <EvanR2> matlab has serialization or networking, im sure
19:11:05 <EvanR2> and network*
19:11:46 <krakrjak> I would be fine using the C FFI.
19:12:06 <peddie> krakrjak: MATLAB and Haskell can both call out to C; you should be able to interface them that way
19:12:13 <krakrjak> I really don't need much.  This is not a large data set to transfer in either direction.
19:12:46 <krakrjak> peddie: thanks!  Yeah I'm headed in that direction.
19:12:47 <EvanR2> you could run a haskell program that processes lines of data from stdin and matlab writes to it
19:12:56 <EvanR2> through a pipe
19:12:59 <dmj`> genericpersona: the RTS is for concurrency, speed is due to ghc performing multiple optimization passes on Core, an intermediate language.
19:13:31 <peddie> krakrjak: I recommend going the FFI route . . . support for anything I/O related in MATLAB is uncomfortable at best, and the Haskell FFI is quite pleasant to use in my experience
19:14:03 <krakrjak> hrm...  that might actually be just fine if I can offload the data loading in a thread during precomputation.
19:14:11 <krakrjak> peddie: so do I need a c program shim too?
19:14:28 <peddie> krakrjak: you will, yeah
19:14:37 <genericpersona> dmj`: sorry, gotta catch up :)
19:14:54 <peddie> krakrjak: well, it might be possible to avoid it, but it's unlikely to be worth avoiding it
19:15:04 <krakrjak> peddie: ok, that's not too much different than what I've done before.  I was just hoping to avoid part of that complexity for using the fast path...
19:15:20 <peddie> :/
19:15:56 <genericpersona> dmj`: that's great to hear and much of what i expected
19:16:11 <genericpersona> so with haskell web apps do you compile first or you're running interpreted code?
19:16:52 <krakrjak> peddie: yeah, until recently the C shim approach was required for creating C interfaces that were CPP defined.  I guess I can use a similar pattern here.
19:17:27 <krakrjak> has anyone played with the matlab package on hackage?  I want to use that, but it only works for base < 4.
19:17:38 <dmj`> genericpersona: both snap and yesod let you reload code on the fly while you're developing. If a change is made it will auto-recompile
19:18:09 <genericpersona> that's awesome!
19:18:22 <krakrjak> genericpersona: I can say the yesod workflow feels almost like working through ghci.
19:18:26 <genericpersona> dmj`: is there a web framework you recommend most? i've only looked at happstack
19:18:35 <genericpersona> krakrjak: that's all i needed to hear :)
19:18:47 <genericpersona> ghci is one of--if not the--best interpreters out there
19:19:18 <EvanR2> julia repl is pretty cool
19:19:51 <krakrjak> the edit-play-edit-play workflow is fairly slick and ghci does it very well.
19:20:01 <dmj`> genericpersona: people have success with all of them. I'd pick whatever one interests you most.
19:20:09 <genericpersona> thanks!
19:20:21 <genericpersona> too much code to write, not enough time
19:32:52 <rekahsoft> hi all..was working on implementing DFA's and was wondering what i could improve..heres the code: https://github.com/rekahsoft/HS-FSM/blob/master/src/DFA.hs
19:35:22 <rekahsoft> the next thing i will do is write a regular expression parser that converts regxps -> my implementation of DFA's..just want to make sure everything is kosher before i continue :P
19:36:31 <rekahsoft> also i saw something i don't understand while perusing the docs..specifically here: http://www.haskell.org/ghc/docs/latest/html/libraries/base/src/Data-Monoid.html#mconcat
19:37:03 <rekahsoft> in the instance for Monoid (a -
19:37:16 <rekahsoft> (a -> b) **
19:37:41 <rekahsoft> the function mappend is defined with 3 arguments..where does the third come from?
19:37:50 <EvanR2> :t mappend
19:37:52 <lambdabot> Monoid a => a -> a -> a
19:37:52 <Polarina> rekahsoft, think of it as interspersing (`mappend`) or (<>) with the list.
19:38:10 <EvanR2> 1+1 arguments ;)
19:38:13 <Polarina> rekahsoft, mappend is two arguments, one result.
19:38:47 <rekahsoft> Polarina: yes i understand but in that link i sent it has this: "mappend f g x = f x `mappend` g x"
19:39:01 <rekahsoft> which i don't get because its three agruments
19:39:09 <rekahsoft> i know what a Monoid is from math
19:39:17 <benzrf> rekahsoft: it's the same in haskell
19:39:45 <ion> mappend f g = \x -> ...
19:39:46 <EvanR2> rekahsoft: well, in that instance, what is the type of f
19:40:12 <EvanR2> and the type of the result of mappend (the same answer)
19:40:42 <Polarina> rekahsoft, that's a Monoid over the type (a -> b)
19:41:08 <kewlkidkay> rekahsoft: it takes 2 arguments
19:41:28 <kewlkidkay> the 'Monoid a' just means that a has to implement Monoid
19:41:52 <kewlkidkay> it means a is a type that is an instance of Monoid
19:43:12 <rekahsoft> alright..i still don't get why in the definition of mappend for the (a -> b) instance of Monoid has f g and x as arguments..is it syntactic shorthand for: "mappend f g = \x -> f x `mappend` g x"
19:43:23 <EvanR2> yes
19:43:25 <Polarina> rekahsoft, yes.
19:43:41 <EvanR2> you can put all the variables on the right in a \
19:43:50 <rekahsoft> EvanR2, Polarina, kewlkidkay: thanks :)
19:43:57 <EvanR2> except for monomorphism restriction ;)
19:44:10 <ion> or in nested single-parameter lambdas
19:45:10 <rekahsoft> EvanR2: i never knew..it just looked really odd
19:45:23 <EvanR2> @src fix
19:45:23 <lambdabot> fix f = let x = f x in x
19:45:43 <EvanR2> hmm guess extra variables are not used in that one
19:45:57 <rekahsoft> ion: so an example would be: "f = \x -> \y -> \z -> ..." === "f x y z = ..."
19:47:28 <rekahsoft> ion: ?
19:47:39 <ion> Yeah, modulo the monomorphism restriction. If you additionally provide the type of turn of MR, they are the same.
19:47:49 <ion> off
19:47:56 <rekahsoft> ion: thanks :)
19:48:17 <jle`> (f <> g) x = f x <> g x
19:48:41 <ion> err. I should be more careful with mobile keyboards. or turn off
19:48:43 <jle`> (<>) = liftA2 (<>)
19:48:43 <EvanR2> so f = \x -> \y -> ... has a monomorphic type?
19:49:04 <roboguy_> EvanR2: no
19:49:30 <roboguy_> well, not necessarily anyway
19:50:17 <EvanR2> i guess if you use it in a function you can only use it one way?
19:50:31 <EvanR2> hrm no
19:51:12 <roboguy_> EvanR2: the monomorphism restriction has more to do with type class constraints. it does differentiate between (to a degree) between things like "f x y =" and "f = \x -> \y -> ..." though
19:51:42 <roboguy_> the mmr is turned off by default in ghc 7.8.2 though luckily (maybe)
19:51:47 <EvanR2> f x y = (x,y), vs f = \x -> \y -> (x,y)
19:51:51 <EvanR2> whoa
19:52:02 <EvanR2> not sure who is going to turn it on
19:52:06 <ion> @djinn (b -> b -> b) -> (a -> b) -> (a -> b) -> (a -> b)
19:52:06 <lambdabot> f a b c d = a (c d) (b d)
19:52:36 <jle`> neat
19:53:06 <Scriptoverloadz> hey all
19:53:29 <zcd> hi
19:53:34 <roboguy_> @let showIt = \x -> show x
19:53:36 <lambdabot>  Defined.
19:53:36 <jle`> @djinn (s -> (a, s)) -> (a -> (s -> (b, s))) -> (s -> (b, s))
19:53:36 <lambdabot> f a b c =
19:53:37 <lambdabot>     case a c of
19:53:37 <lambdabot>     (d, e) -> b d e
19:53:38 <roboguy_> :t showIt
19:53:39 <lambdabot> Show a => a -> String
19:53:40 <rekahsoft> hey hey
19:53:47 <Maxdamantus> @djinn Either (a -> c) (b -> c) -> a -> b -> c
19:53:48 <lambdabot> f a b c =
19:53:48 <lambdabot>     case a of
19:53:48 <lambdabot>     Left d -> d b
19:53:48 <lambdabot>     Right e -> e c
19:53:49 <roboguy_> huh, I guess lambdabot has it turned off too
19:53:53 <roboguy_> @undefine showIt
19:53:53 <lambdabot> There's currently no way to undefine just one thing.  Say @undefine (with no extra words) to undefine everything.
19:54:02 <EvanR2> goodbye mmr lol
19:54:22 <jle`> did djinn just derive the correct (>>=) for State?
19:54:29 <jle`> neat
19:54:51 <jle`> @djinn (s -> (a, s)) -> (s -> (b, s)) -> (s -> (b, s))
19:54:51 <lambdabot> f a b c =
19:54:51 <lambdabot>     case b c of
19:54:51 <lambdabot>     (d, _) -> case a c of
19:54:51 <lambdabot>               (_, e) -> (d, e)
19:55:05 <jle`> the wrong (>>) though.
19:55:07 <jle`> hah!
19:55:09 <prophile> it can do callCC as well, which is handy
19:55:15 <jle`> humankind wins again
19:55:32 <roboguy_> @djinn ((a -> r) -> r) -> (a -> ((b -> r) -> r)) -> (b -> r) -> r
19:55:32 <lambdabot> f a b c = a (\ d -> b d c)
19:55:43 <ion> jle: You should ask for your money back.
19:56:09 <jle`> i would not have expected (>>) to be "not parametric enough", while (>>=) to be so
19:59:15 <Scriptoverloadz> afc going to play sniper elite v2
20:16:53 <m09> I have a strange error (http://lpaste.net/104777) when compiling https://gist.github.com/m09/0400baaf5412af97569b, any idea how to properly lift this IO action into the Haskeline transformer?
20:31:29 <roboguy_> m09: where is Board defined?
20:31:39 <m09> type Board = IOArray Coords Cell
20:31:51 <m09> sorry, I removed too much of the file
20:33:05 <m09> The error has been fixed in GHC 7.8 it seems (the panic) and it usually happenned when people got transformer code very wrong it seems
20:33:28 <m09> but I'm not used to them so I don't where the mistake is
20:33:45 <Ocelot8> Hello guys
20:34:25 <m09> I don't see*
20:34:27 <roboguy_> m09: I would guess it has something to do with giving lift three arguments instead of one
20:34:49 <m09> roboguy_: yup, I corrected to v ← lift $ readArray board c
20:35:09 <m09> but even that tells me that InputT is not a MonadTrans instance
20:35:14 <m09> which I don't understand
20:36:17 <m09> (InputT comes from System.Console.Haskeline)
20:55:17 <roboguy_> m09: hmm, really? I see the MonadTrans instance on the hackage page
20:55:55 <roboguy_> unless there's something really weird going on, like it was linked with a different version of mtl than the one your using
21:02:25 <wormmd> Anyone use vim2hs and want to tell me how to turn off folding by default?
21:02:31 <wormmd> Pretty please?
21:08:16 <joelteon> set foldenable=no?
21:08:40 <dmj`> set nofoldenable
21:10:21 <wormmd> checking...
21:11:18 <wormmd> NICE.
21:11:23 <wormmd> Y'all are aweesome.
21:11:31 <wormmd> *awesome
21:12:54 <wormmd> I'm guessing that option isn't vim2hs specific...
21:18:50 <pjdelport> wormmd: All :set options are generic.
21:20:29 <wormmd> pjdelport: vim2hs was my first experience with folding
21:20:58 <pjdelport> wormmd: You can always press zE to just expand them all.
21:21:15 <pjdelport> If you don't want to disable them completely.
21:21:59 <wormmd> And to refold them all? Or an individual one?
21:22:12 <wormmd> I guess I could, you know, google that, actually...
21:22:15 <wormmd> Sorry :)
21:26:25 <wormmd> >> twice f x = f (f x)
21:26:49 <wormmd> Is there a compiler bot here?
21:26:58 <roboguy_> wormmd: use one >
21:27:17 <wormmd> > twice f x = f (f x)
21:27:19 <lambdabot>  <hint>:1:11: parse error on input ‘=’
21:27:21 <roboguy_> also, you need to either use @let or a let ... in ... expression
21:27:58 <wormmd> > @let twice f x = f (f x)
21:27:59 <lambdabot>  <hint>:1:1: parse error on input ‘@’
21:28:39 <roboguy_> @let twice f x = f (f x)
21:28:42 <lambdabot>  Defined.
21:28:51 <wormmd> > let > :t twice
21:28:52 <lambdabot>  <hint>:1:5: parse error on input ‘>’
21:28:57 <wormmd> > :t twice
21:28:58 <lambdabot>  <hint>:1:1: parse error on input ‘:’
21:29:07 <wormmd> > twice
21:29:08 <lambdabot>  No instance for (Data.Typeable.Internal.Typeable t0)
21:29:08 <lambdabot>    arising from a use of ‘M692013329529023814624065.show_M6920133295290238146...
21:29:08 <lambdabot>  The type variable ‘t0’ is ambiguous
21:29:08 <lambdabot>  Note: there are several potential instances:
21:29:08 <lambdabot>    instance Data.Typeable.Internal.Typeable Data.Dynamic.Dynamic
21:29:14 <roboguy_> :t twice
21:29:15 <lambdabot> (t -> t) -> t -> t
21:29:16 <benzrf> have nicenight
21:29:20 <wormmd> Heh :)
21:29:30 <wormmd> Anyway, now that we have that covered.
21:29:32 <benzrf> :t join (.)
21:29:33 <lambdabot> (c -> c) -> c -> c
21:30:49 <jle`> > join (.) (*2) 4
21:30:51 <lambdabot>  can't find file: L.hs
21:30:51 <wormmd> So I originally thought the type of twice would be a -> b (a -> (a -> b)).
21:30:55 <jle`> > join (.) (*2) 4
21:30:56 <lambdabot>  16
21:31:11 <wormmd> I realize part of my mistake, because twice has to return a value.
21:31:12 <jle`> wormmd: hm...that's not well-kinded
21:31:32 <jle`> you use b as a type constructor and then b as a type?
21:32:17 <wormmd> jle`: I don't understand what you mean, but I do understand part of what I got wrong.
21:32:37 <wormmd> I was trying to differentiate between the type of the function and it's argument, first off.
21:32:37 <roboguy_> wormmd: did you mean wormmd: did you mean a -> b -> (a -> (a -> b))?
21:32:50 <wormmd> roboguy_: yes.
21:32:53 <jle`> ah ok
21:33:01 <jle`> that does kind-check
21:33:59 <wormmd> Anyway, I got tripped up by trying to give f and x distinct types (a and b).
21:34:00 <roboguy_> wormmd: that's the same as wormmd: did you mean a -> b -> a -> a -> b
21:34:03 <roboguy_> oops
21:34:12 <roboguy_> I mean "that's the same as a -> b -> a -> a -> b"
21:34:32 <roboguy_> the parentheses for -> are right associative
21:34:58 <roboguy_> there's only one function of that type actually: f _ x _ _ = x
21:36:20 <wormmd> So the type of f x would be a -> a?
21:36:38 <roboguy_> what's x?
21:36:44 <wormmd> Yeah...
21:36:49 <wormmd> Hmm.
21:36:53 <roboguy_> I mean, what does f x mean?
21:37:32 <roboguy_> oh, you mean in twice
21:38:53 <wormmd> Yes, in twice, as it stands, if I weren't twicing f, f would be a function that maps an x to an x, based on the type of twice. But that doesn't make too much sense, because what if f converts x to some other type?
21:39:13 <wormmd> Or it probably makes perfect sense, just not to me :)
21:39:15 <wormmd> Yet!
21:39:38 <roboguy_> so you mean something like this?
21:39:41 <roboguy_> :t \f x -> f x
21:39:42 <lambdabot> (t1 -> t) -> t1 -> t
21:40:11 <wormmd> See, that's what I would expect. Or closer to what I thought I was expecting.
21:41:12 <bitemyapp> wormmd: they told you 'set nofoldenable' right?
21:41:19 <wormmd> bitemyapp: yup :)
21:42:15 <bitemyapp> just making sure, I was in and out for a bit.
21:43:04 <wormmd> So I guess my question boils down to why does twice not have a distinct type for the function and the value it applies the function to?
21:43:24 <wormmd> If functions can map values of one type to a different type?
21:43:30 <wormmd> That is to say.
21:45:37 <roboguy_> wormmd: the output of f comes out and then gets fed back into f as input, so the input and output types have to be the same
21:46:04 <wormmd> :t twice
21:46:05 <lambdabot> (t -> t) -> t -> t
21:46:20 <roboguy_> if they were different, you couldn't apply f to the result of f x
21:46:33 <wormmd> Ah, yes.
21:46:51 <wormmd> So that's a distinct behavior of some function like twice.
21:47:12 <dbelange> :t thrice
21:47:13 <lambdabot>     Not in scope: ‘thrice’
21:47:13 <lambdabot>     Perhaps you meant ‘twice’ (line 150)
21:47:51 <wormmd> So (t -> t) is the inner application of f, and (t -> t) -> t is the outer application of f, and the trailing -> t is the return.
21:48:05 <wormmd> dbelange: we defined the twice function ;)
21:48:25 <wormmd> @let thrice f x = f (f (f x))
21:48:27 <lambdabot>  Defined.
21:48:31 <wormmd> :t thrice
21:48:32 <lambdabot> (t -> t) -> t -> t
21:48:37 <wormmd> ...
21:48:49 <wormmd> Ok now I'm super confused.
21:48:50 <roboguy_> wormmd: no. (t -> t) is the type of f, t is the type of x
21:48:58 <roboguy_> the last t is the result type of twice
21:49:00 <johnw> another way of looking at the type is: (t -> t) -> (t -> t)
21:50:33 <wormmd> :t double
21:50:34 <lambdabot> Double -> Doc
21:51:04 <wormmd> @let double x = x * 2
21:51:06 <lambdabot>  Defined.
21:51:15 <wormmd> > twice double 2
21:51:17 <lambdabot>  Ambiguous occurrence ‘double’
21:51:17 <lambdabot>  It could refer to either ‘L.double’, defined at L.hs:150:1
21:51:17 <lambdabot>                        or ‘Text.PrettyPrint.HughesPJ.double’,
21:51:17 <lambdabot>                           imported from ‘Text.PrettyPrint.HughesPJ’ at L.hs:1...
21:51:25 <wormmd> > twice * 2
21:51:27 <lambdabot>  No instance for (Data.Typeable.Internal.Typeable t0)
21:51:27 <lambdabot>    arising from a use of ‘M458290601611816452724395.show_M4582906016118164527...
21:51:27 <lambdabot>  The type variable ‘t0’ is ambiguous
21:51:27 <lambdabot>  Note: there are several potential instances:
21:51:27 <lambdabot>    instance Data.Typeable.Internal.Typeable Data.Dynamic.Dynamic
21:51:39 <Cale> > twice (\x -> x*2) 2
21:51:41 <lambdabot>  8
21:51:55 <wormmd> > thrice (\x -> x*2) 2
21:51:57 <lambdabot>  16
21:53:02 <wormmd> Off-topic: do y'all ever undef all the silly things people define? :P
21:53:25 <johnw> :t allTheSillyThingsPeopleDefine
21:53:27 <lambdabot> Not in scope: ‘allTheSillyThingsPeopleDefine’
21:53:28 <roboguy_> wormmd: yeah, there's a command that clears everything (I think it's @undefine)
21:53:28 <Cale> @undefine
21:53:28 <lambdabot> Undefined.
21:53:31 <Cale> ^^ done
21:53:39 <jle`> wormmd: you can think of twice as a "function transformer"
21:53:43 <wormmd> Ohs noes!
21:53:55 <Cale> (You can only undefine everything, it's impossible to undefine one thing in particular)
21:53:58 <jle`> wormmd: it taks an (a -> a) function, and gives you a new (a -> a) function
21:54:10 * hackagebot reducers 3.10.2.1 - Semigroups, specialized containers and a general map/reduce framework  http://hackage.haskell.org/package/reducers-3.10.2.1 (EdwardKmett)
21:54:13 <jle`> @let twice = join (.)
21:54:14 <lambdabot>  Defined.
21:54:22 <jle`> :t twice (+2)
21:54:23 <lambdabot> Num c => c -> c
21:54:31 <jle`> if you give it (+2), it turns it into (+4)
21:54:39 <jle`> if you give it (*3), it turns it into (*9)
21:54:51 <jle`> if you give it (^2), it turns it into (^4)
21:55:05 <jle`> > (twice (*3)) 4
21:55:07 <lambdabot>  36
21:55:28 <wormmd> I'm still working through "(t -> t) is the type of f, t is the type of x" in my brain.
21:56:39 <wormmd> :t twice
21:56:40 <lambdabot> (c -> c) -> c -> c
21:57:00 <roboguy_> wormmd: have you seen the id and const functions?
21:57:08 <wormmd> :t id
21:57:09 <lambdabot> a -> a
21:57:11 <wormmd> :t const
21:57:12 <lambdabot> a -> b -> a
21:57:19 <dbelange> > thrice (\x -> twice x) 2
21:57:20 <lambdabot>  Not in scope: ‘thrice’
21:57:20 <lambdabot>  Perhaps you meant ‘twice’ (line 146)
21:57:34 <wormmd> > const 1 2
21:57:34 <roboguy_> wormmd: each of those functions has only one possible implementation
21:57:35 <lambdabot>  1
21:57:40 <roboguy_> (based on their types)
21:57:52 <roboguy_> that's not always the case though
21:57:55 <wormmd> > const 1 True
21:57:56 <lambdabot>  1
21:58:00 <dbelange> > const (const 3 2) 2
21:58:01 <lambdabot>  3
21:58:06 <roboguy_> const just ignores its second argument
21:58:13 <jle`> :t const 1
21:58:15 <lambdabot> Num a => b -> a
21:58:15 <wormmd> roboguy_: I think I follow thus far.
21:58:22 <jle`> > map (const 1) [1,2,3,4,5]
21:58:24 <lambdabot>  [1,1,1,1,1]
21:59:16 <wormmd> > const 1 2 3
21:59:17 <lambdabot>  Could not deduce (GHC.Num.Num (a0 -> t))
21:59:17 <lambdabot>    arising from the ambiguity check for ‘e_1123’
21:59:17 <lambdabot>  from the context (GHC.Num.Num (a -> t), GHC.Num.Num a)
21:59:17 <lambdabot>    bound by the inferred type for ‘e_1123’:
21:59:17 <lambdabot>               (GHC.Num.Num (a -> t), GHC.Num.Num a) => t
21:59:22 <roboguy_> in the type signature of const, the first argument has type "a" and the second has type "b" and the result is of type "a" (the same as the first argument)
21:59:37 <wormmd> roboguy_: right.
21:59:54 <jle`> oh i think what i am saying is unrelated ot what roboguy_ is saying so i'll back off
22:00:03 <roboguy_> maybe a more concrete example would help
22:00:20 <jle`> :t const
22:00:21 <lambdabot> a -> b -> a
22:00:25 <jle`> @djinn a -> b -> a
22:00:26 <lambdabot> f a _ = a
22:00:30 <jle`> :t id
22:00:31 <lambdabot> a -> a
22:00:32 <jle`> @djinn a -> a
22:00:33 <lambdabot> f a = a
22:00:49 <wormmd> Side-note: the twice example is from Hutton's Programming in Haskell, and it's not homework :)
22:01:27 <wormmd> It was several years ago, but now it's refresher in preparation for Elm (JavaScript) and Scala (Java).
22:03:07 <wormmd> what is @djinn?
22:03:12 <wormmd> @djinn
22:03:12 <lambdabot> Cannot parse command
22:03:14 <roboguy_> @let applyAndTimesTen f x = (f x) * (10 :: Int)
22:03:15 <lambdabot>  Defined.
22:03:24 <jle`> you give it a type signature and it tries to write a function that has that type signature
22:03:33 <roboguy_> (ignore the :: Int, that's just to make the types look a little nicer)
22:03:38 <wormmd> jle`: neat!
22:03:41 <wormmd> roboguy_: got it.
22:03:47 <roboguy_> :t applyAndTimesTen
22:03:48 <lambdabot> (t -> Int) -> t -> Int
22:03:57 <jle`> it was to demonstrate that for a function of type (a -> a), \a -> a is a definition that you could think up for it
22:04:11 <jle`> i'm not sure if it proves that \a -> a is the *only* definition of it
22:04:16 <jle`> only possible implementation of it
22:04:34 <jle`> @src id
22:04:34 <lambdabot> id x = x
22:04:38 <johnw> @djinn (a -> a) -> a -> a
22:04:38 <lambdabot> f a = a
22:04:43 <roboguy_> jle`: I think it still tries to come up with a possible implementation of something even if the type makes it ambiguous
22:04:44 <roboguy_> yeah
22:04:46 <johnw> and yet, f k a = k (k a) is also a valid definition
22:04:51 <johnw> eotc.
22:05:08 <jle`> (a -> a) -> (a -> a) has multiple implementations yeah
22:05:17 <jle`> even \x -> x . x . x . x
22:05:20 <jle`> er
22:05:22 <jle`> \f -> f . f . f . f
22:05:34 <roboguy_> alpha conversion
22:06:00 <jle`> i wonder if there is anything i can read that describes the limits of parametricity
22:06:24 <roboguy_> jle`: there's that free theorem paper
22:06:35 <jle`> right now i have to think of it case-by-case...but i wonder if it's possible to just look at a type signature and determine algorithmically if there is only one implementation for it
22:06:47 <wormmd> :t applyAndTimesTen
22:06:48 <lambdabot> (t -> Int) -> t -> Int
22:06:48 <jle`> roboguy_: oh yeah, i remember that
22:07:04 <roboguy_> jle`: I'm pretty sure it would be possible, but I'm not sure if anyone's done that yet
22:07:40 <wormmd> So this is saying that there's an f that takes some t and produces an Int, and some value of type t, and the result is an Int.
22:07:49 <roboguy_> wormmd: yep!
22:07:54 <jle`> well
22:08:01 <johnw> that's one way to see it
22:08:04 <wormmd> Doesn't matter what t is, f will turn it into an Int.
22:08:13 <johnw> it also says that it takes a function from t to Int, and returns a function from t to Int
22:08:16 <roboguy_> you could look at it as a sort of function transformer as well
22:08:48 <jle`> if i give applyAndTimesTen (\x -> x+5), it'll return (\x -> (x+5)*10)
22:09:01 <roboguy_> "(t -> Int) -> t -> Int" is the same thing as "(t -> Int) -> (t -> Int)"
22:09:08 <jle`> if i give it (\x -> x^2), it'll return (\x -> (x^2)*10)
22:09:12 * hackagebot kan-extensions 4.0.3 - Kan extensions, Kan lifts, various forms of the Yoneda lemma, and (co)density (co)monads  http://hackage.haskell.org/package/kan-extensions-4.0.3 (EdwardKmett)
22:09:22 <wormmd> roboguy_: yeah, I got that from earlier.
22:09:28 <jle`> > (applyAndTimesTen (\x -> x+5)) 10
22:09:29 <lambdabot>  150
22:09:36 <jle`> > (\x -> (x+5)*10) 10
22:09:37 <lambdabot>  150
22:10:28 <jle`> a function transformer you might be familiar with is map
22:10:36 <jle`> map :: (a -> b) -> ([a] -> [b])
22:10:45 <jle`> it takes an (a -> b) and turns it into an [a] -> [b]
22:10:48 <m09> roboguy_: sorry I've been away for an hour (about the transformer in Haskeline that wasn't working). Yeah it's weird. Could it be that when in runInputT the full stack is not considered?
22:10:51 <jle`> doing what the obvious implementation would do
22:11:35 <jle`> > let doubleInList = map (*2) in doubleInList [1,2,3]
22:11:37 <lambdabot>  [2,4,6]
22:12:20 <jle`> the difference in this cas efrom twice and applyAndTimesTen is that this one changes the types of the function
22:12:38 <roboguy_> m09: hmm, I'm not sure. could you paste the error message?
22:12:54 <wormmd> So I think I'm starting to like johnw's explanation of (t -> t) -> (t -> t) coupled with roboguy_'s observation that the application of the function has to return the same type because it's applying the same function on the value of the return from the first invocation.
22:12:57 <m09> sure, give me a sec I'll refactor the sample code into something clean
22:12:58 <wormmd> Does that make sense?
22:13:35 <wormmd> It seems that starting from the end (the result of the entire function application) gives hints to the types of its arguments along the way.
22:13:38 <johnw> wormmd: yes, in fact that concept has a name: an endofunction
22:14:13 * hackagebot keys 3.10.1 - Keyed functors and containers  http://hackage.haskell.org/package/keys-3.10.1 (EdwardKmett)
22:14:28 <wormmd> johnw: well what do you know, so it does.
22:14:52 <wormmd> That might have helped if Hutton had decided to print it but I suppose that was part of the exercise...
22:14:56 <johnw> and endofunctions have all kinds of neat properties, and special forms
22:15:28 <johnw> such as, an endofunctions is idempotent if: f .f = f
22:15:35 <johnw> and endofunctions are a form of monoid
22:15:35 <johnw> etc.
22:15:38 <johnw> math is great :)
22:16:47 <wormmd> So great. I'm just way better at its abstract practical application (computer science) than I am at its theory (you know, math 'n' stuff).
22:16:48 <roboguy_> johnw: not only that, if there's a retraction r for an endofunction f, then f . r is idempotent. I always thought that was kind of cool
22:18:36 <wormmd> Welp, I learned some important things about figuring out types tonight. I might end on a high note and call it quits for now :)
22:19:13 * hackagebot plot 0.2.3.1 - A plotting library, exportable as eps/pdf/svg/png or renderable with gtk  http://hackage.haskell.org/package/plot-0.2.3.1 (VivianMcPhail)
22:25:35 <johnw> roboguy_: huh, that's neat
22:26:39 <roboguy_> johnw: yep. you can prove it just with the definition of a retraction and the associativity of composition so actually it works on any endomorphism that has a retraction in any category
22:26:53 <sjy> what's the easiest way to pluck a random element out of a list? doesn't need to be secure
22:27:34 <sjy> i'm trying to generate a random list index from System.Random but it seems kinda cumbersome
22:29:16 <bitemyapp> http://lpaste.net/104779 parse error (possibly incorrect indentation or mismatched brackets)
22:29:26 <bitemyapp> anybody that's used Persistent + TH tell me what's going on?
22:30:51 <johnw> bitemyapp: I imagine you have QuasiQuotes enabled?
22:31:21 <bitemyapp> fack.
22:31:50 <bitemyapp> johnw: thank you.
22:37:49 <m09> roboguy_: I made some simple example that still has the problem: http://lpaste.net/104780
22:38:29 <m09> the loop function is not necessary actually it's just a left over of my previous file, sorry
22:39:16 <johnw> m09: it looks like InputT doesn't implement MonadTrans :)
22:39:50 <m09> johnw: hackage.haskell.org/package/haskeline-0.7.1.2/docs/System-Console-Haskeline.html but it also look like it does :(
22:39:57 <m09> I'm kinda lost
22:40:36 <johnw> huh
22:41:08 <roboguy_> m09: that's so strange. I get the same error
22:41:09 <johnw> try importing System.Console.Haskeline.InputT
22:41:26 <johnw> it looks like System.Console.Haskeline doesn't re-export the instance
22:42:39 <roboguy_> johnw: looks like that's hidden
22:42:44 <m09> yup
22:42:47 <m09> GHC yells at me :(
22:42:47 <johnw> sigh
22:42:56 <johnw> just copy the instance then
22:43:04 <johnw> and yell at the package author
22:43:30 <roboguy_> yeah, that should definitely be exported
22:44:46 <m09> hum, it seems the data constructor is not exported, so I have to copy an enormous bunch of stuff it seems :]
22:44:53 <m09> I think I'll just report the bug and use another lib
22:45:03 <m09> thanks for the help :)
22:51:26 <dmj`> anyone know why copyFile doesn't work on Windows?
22:51:43 <dmj`> copyFile from the directory package, keeps giving permission errors regardless of permission settings
22:52:37 <dmj`> works fine in ghci though, only when the module System.Directory is imported and the copyFile function invoked, o/w :l Main.hs and :main still give permission errors
22:53:46 <dmj`> irrespective of the console being used
22:57:20 <dmj`> I guess I could just use the shell...
23:13:22 <m09> is there a function similar to runState or runIdentity for Maybe? I'm quite sure it's there but I can't seem to spot it
23:14:19 * hackagebot semigroups 0.15 - Anything that associates  http://hackage.haskell.org/package/semigroups-0.15 (EdwardKmett)
23:14:23 <m09> fromMaybe seems fine actually, nvm :)
23:17:05 <jle`> m09: also maybe
23:17:23 <jle`> which is in Prelude iirc
23:17:34 <m09> yup, thanks :)
23:17:39 <jle`> fromJust is more parallel to runIdentity but it's partial
23:17:42 <jle`> :t runIdentity
23:17:43 <lambdabot> Identity a -> a
23:17:46 <jle`> :t fromJust
23:17:47 <lambdabot> Maybe a -> a
23:24:59 <Dacto> When compiling Haskell-Platform from source, early on during a make it fails on building `parallel-...`due to not having the dependency `array`. Is `array` supposed to be include or something?
23:31:15 <Ainieco> hello how to get colored output for "cabal test" exitcode tests?
23:35:03 <Cale> Dacto: ghc-pkg list array
23:35:34 <Cale> Dacto: Also, why are you building Platform from source?
23:35:40 <Ainieco> also, i have many executables in my cabal file and there is a lot of ghc-options duplications between them. how to eliminate that duplication?
23:36:06 <Ainieco> can i abstract it away in variable or something?
23:36:16 <Cale> Dacto: It's pretty much specifically designed for those who don't want to compile a bunch of the basic libraries from source.
23:39:42 <Cale> Ainieco: Not sure, looking at the documentation, I don't see a way
23:40:42 <Dacto> Cale: I'm building from source due to haskell-platform not avail in the arch-arm package repo
23:40:45 <Ainieco> Cale: oh, thank you for checking!
23:41:13 <Cale> Ainieco: (short of using something else to construct your .cabal file of course)
23:42:21 <Cale> Dacto: Which version of base?
23:42:44 <Cale> (actually, it's a bit hard to believe that you don't have an array package installed, doesn't that come with GHC?)
23:43:07 <Cale> yes, it does come with GHC
23:43:10 <Ainieco> Cale: yeah, discovered https://github.com/massysett/cartel today but it's a bit immature for adoption atm
23:43:38 <Dacto> Cale: base-4.7.0.0
23:43:53 <Cale> Dacto: So you should have array-0.5.0.0
23:44:11 <Dacto> Cale: Indeed ghc-pkg says I have array-0.5.0.0
23:44:19 <Cale> hmm
23:44:24 <Dacto> Cale: I wonder why it is failing then
23:44:40 <Cale> Which version of parallel is it trying to build?
23:44:44 <Dacto> Oh.
23:45:01 <Cale> It seems like you're using 7.8.x, while Haskell Platform is actually intended for 7.6.x
23:45:05 <Dacto> Parallel is requiring >=0.1 and <0.5
23:47:19 <Cale> yeah, so it's probably trying to build 3.2.0.3 rather than 3.2.0.4
23:47:19 <Dacto> Yeah, it is true that I am trying to build with 7.8.2
23:47:19 <Cale> You can either do what I'd do, which is just to install cabal-install and call it a day, or if your goal is to construct packages, downgrade your GHC to 7.6.3
23:47:38 <Dacto> GHC 7.6.x is not avail on arch-arm....would I have build it with GHC 7.8.2? But then would I run into the similar problems?
23:48:02 <Cale> Uh, in that case, just don't bother with Haskell Platform at all yet
23:48:24 <Cale> HP hasn't been updated for 7.8.x yet
23:48:29 <Cale> but eventually it will be
23:48:43 <Cale> until then, I would just install things from hackage using cabal-install as needed
23:48:47 <Cale> which is usually what I do anyway
23:49:01 <Dacto> cabal-install is from AUR I assume
23:49:29 <Cale> http://hackage.haskell.org/package/cabal-install -> http://hackage.haskell.org/package/cabal-install-1.20.0.2/cabal-install-1.20.0.2.tar.gz
23:49:54 <Cale> There's a bootstrap.sh script in that tarball which will get you going
23:50:12 <Cale> (Given that you have GHC and that packages which come with that installed)
23:50:28 <Dacto> Okay, I will give that a go
23:50:33 <Cale> and then you can just cabal install <packagename>
23:50:39 <Cale> and it'll install whatever it is that you need
23:50:43 <Dacto> Nice, then that should be fine
