00:06:11 <qrada> anyone familiar with hedis? After I'm connected to redis, I'm catching exceptions when the server goes down. The problem is, when I start the code with the redis-server not running.. No exceptions are thrown. Hedis is making an internal call to 'connectTo' form the network package, which is run in a connection pool from resource-pool package (createPool). Anyone know how I can figure out if the hedis connection failed to connect?
00:08:10 * hackagebot language-c-inline 0.6.0.0 - Inline C & Objective-C code in Haskell for language interoperability  http://hackage.haskell.org/package/language-c-inline-0.6.0.0 (ManuelChakravarty)
00:08:10 * hackagebot hoauth2 0.3.7 - hoauth2  http://hackage.haskell.org/package/hoauth2-0.3.7 (HaishengWu)
00:08:54 <pingu> qrada: not sure, I'd have gone with a timeout considering you can't guarantee an immediate exception
00:09:30 <pingu> Essentially that's what you're asking for anyway, it *could* just be a really slow server, see.
00:09:46 <qrada> ya i guess i'll have to implement a timeout
00:10:00 <qrada> I don't see any way to figure out if that initial connect is hung/failed
00:10:24 <pingu> It's a pretty low level issue. Which is going to be relying on internal timeouts itself.
00:11:04 <qrada> thanks alot
00:11:11 <qrada> trying now;f
00:23:48 <ski> ReinH : mhm ?
00:23:55 <ski> @ask Tekmo you were looking for a language ?
00:23:55 <lambdabot> Consider it noted.
00:24:11 <ski> ReinH : SYN ACK
00:26:52 <qrada> pingu, so, timeout fixed one of the problems but then another one emerged.. turns out, my thread is just dying so, changed forkIO to forkFinally and now it seems like I have everything caught
00:27:01 <qrada> thnx again
00:35:44 <warpy> @pl atomicModIORef state . second $ \online -> flip insertSet online . Nick . userNick $ user
00:35:45 <lambdabot> atomicModIORef state (second (flip (. (Nick . userNick)) user . flip insertSet))
00:37:06 <warpy> @pl \user -> atomicModIORef state . second $ \online -> flip insertSet online . Nick . userNick $ user
00:37:06 <lambdabot> atomicModIORef state . second . flip ((. (Nick . userNick)) . flip insertSet)
00:39:17 <rlp10> How do I define a type which is a Data.Map of Strings to values of any type?
00:40:47 <mirpa> Howto pass (read-only) ByteString (or Vector) to C FFI call without making a copy of it?
00:41:48 <jle`> rlp10: how are you planning to use this in a type safe manner?
00:41:57 <jle`> what type would your lookup function have?
00:43:35 <Axman6> rlp10: you probably can hack a way of doing it, but please don't; you don't want to do that
00:44:15 <rlp10> jle`: Good point. I guess i'm coming at this from an object-oriented point of view. Basically I wanted to model an object which might have various data held about it, without choosing those fields up front. Maybe I need to go back to the drawing board.
00:44:31 <Axman6> indeed
00:45:06 <rlp10> Axman6: Thanks for your thoughts too.
00:45:42 <jle`> rlp10: if you know what types would go into it, you can create a sum type
00:45:52 <jle`> like for example if you know you only are going to store Ints and Strings
00:45:55 <jle`> you can do something like
00:45:59 <rlp10> jle`: Is that like an Either but with more than two?
00:46:08 <jle`> data Val = StrVal String | IntVal Int
00:46:18 <jle`> type MyMap = Map String Val
00:46:28 <rlp10> jle`: Yeah, that makes sense.
00:46:41 <jle`> this is similar to how you might implement json using Map
00:47:08 <jle`> or how you might begin to
00:48:48 <rlp10> jle`: Thanks again. The algebraic data type is probably the way to go. I could then use guards in my functions to get the appropriate value out, right?
00:49:01 <jle`> um
00:49:17 <jle`> the appropriate mechanism in this case is pattern matching
00:49:48 <jle`> case lookup m "foo" of StrVal s -> ...; IntVal i -> ...
00:50:32 <rlp10> jle`: OK, I've got it. Thanks again again.
00:51:09 <jle`> np :)
01:38:16 * hackagebot flaccuraterip 0.3.1 - Verify FLAC files ripped form CD using AccurateRip"  http://hackage.haskell.org/package/flaccuraterip-0.3.1 (NicolaSquartini)
01:47:33 <hspanda> I suspect this is a "dll hell" problem; cairo (0.12.5.3) won't compile as a dependency of one of my own cabal projects.  I'm using sandboxes
01:50:46 <Adamax> Hi! I downloaded ghc-7.8.2 for windows and installed cabal; now when I'm trying to cabal install cabal-dev, it complains that it cannot find ghc; but I have ghc on the path. How do I fix this?
01:51:27 <Adamax> Here's log: http://lpaste.net/104578
01:58:01 <mirpa> Adamax: try cabal with sandboxes instead of cabal-dev
01:58:49 <Adamax> mirpa: same error with cabal sandbox init
01:59:58 <mmmm> Adamax: "type ghc" ?
02:00:14 <mirpa> can you run ghc on windows from command line? (I am on Linux)
02:00:41 <Adamax> mmmm: ghc is hashed (/c/bin/ghc-7.8.2/bin/ghc)
02:01:00 <Adamax> mirpa: I'm using mingw shell and I can run ghc there
02:01:30 <Sphaso> hey good people
02:02:46 <Sphaso> anyone up to help a noob in type hell?
02:02:58 <Jeanne-Kamikaze> hi
02:03:00 <mmmm> Adamax: I'm afraid I can e of no help
02:03:07 <mmmm> fire away Sphaso
02:03:10 <Sphaso> ok
02:03:15 <Sphaso> https://github.com/sphaso/BagOfTricks/blob/master/Strings/huffman.hs
02:03:18 <Sphaso> here's the code
02:03:38 <Sphaso> huffman.hs:21:45:
02:03:38 <Sphaso>     Couldn't match expected type ëIntí with actual type ë[a0] -> Intí
02:03:38 <Sphaso>     Probable cause: ëcountEqualsí is applied to too few arguments
02:03:38 <Sphaso>     In the expression: countEquals (x ccs)
02:03:38 <Sphaso>     In the first argument of ëLeafí, namely ë(x, countEquals (x ccs))í
02:03:44 <Sphaso> and that's the problem
02:03:51 <Sphaso> oh no wait
02:04:10 <Sphaso> huffman.hs:18:21:
02:04:10 <Sphaso>     Not in scope: type constructor or class ëLeafí
02:04:10 <Sphaso>     A data constructor of that name is in scope; did you mean DataKinds?
02:04:12 <Sphaso> that's it
02:04:22 <mmmm> Please use lpaste to paste errors
02:04:31 <Sphaso> sorry
02:04:43 <johnw> It would need to be [Char] -> [CodeTree]
02:04:52 <johnw> Leaf is a data constructor, not a type
02:05:46 <Sphaso> but I want to return only Leafs, not Forks
02:06:03 <Sphaso> ah well I see now
02:06:05 <Sphaso> nvm
02:06:26 <Sphaso> thanks, that was quick :)
02:13:20 * hackagebot hweblib 0.6.3 - Haskell Web Library  http://hackage.haskell.org/package/hweblib-0.6.3 (AycanIrican)
02:16:49 <Adamax> Fixed my problem by downloading 32bit ghc build
02:39:52 <identity> Heh, I just handed in a project where the task was to implement huffman trees
02:47:51 <mirpa> Adamax: what system do you have? 32/64-bit?
02:48:41 <Adamax> mirpa: 64bit; already solved it by downloading 32bit ghc
02:49:46 <mirpa> ...I am just wondering
03:11:52 <jtcwang> compiling my executable with -auto-all flag (for profiling), and did "cabal configure --enable-library-profiling --enable-executable-profiling". What do I need to do to profile deeper (it currently stops going deeper than external library calls)
03:13:03 <jtcwang> here's my SO question: http://stackoverflow.com/questions/23853592/optimizing-conduit-pipelines
03:13:14 <jtcwang> I'd like to profile conduit's sinkFile function
03:13:28 * hackagebot packed-dawg 0.2.0.4 - Generation and traversal of highly compressed directed acyclic word graphs.  http://hackage.haskell.org/package/packed-dawg-0.2.0.4 (AndrasKovacs)
03:28:30 * hackagebot tasty-ant-xml 1.0.0.8 - Render tasty output to XML for Jenkins  http://hackage.haskell.org/package/tasty-ant-xml-1.0.0.8 (OliverCharles)
03:45:03 <phaazon> god, all those IDs stuff in my 3D engine make me sick
03:45:11 <phaazon> it‚Äôs so ugly as concept
03:45:23 <phaazon> I just have no idea how to make it different
03:45:34 <phaazon> I feel like crap :(
03:45:46 <jtcwang> pat pat
04:04:43 <exicer_> Can anyone help me with this cabal problem? http://lpaste.net/104581
04:08:38 <mmmm> are you using sandboxes exicer_ ?
04:10:56 <exicer_> mmmm: yes
04:12:35 <lechip> hi all!, I am trying to understand the denotational semantics of haskell but I am not a mathematician, can somebody enlighten me to understand how does the fixed point and a least fixed point works?
04:13:44 <Qfwfq_> Have splice scoping rules changed with GHC 7.8? I can no longer build https://github.com/fmap/markov/blob/master/src/AI/Markov/HMM.lhs#L162-L163 owing to "‚ÄòHMM‚Äô is not in the type environment at a reify"
04:17:13 * Qfwfq_ reads https://ghc.haskell.org/trac/ghc/wiki/TemplateHaskell/BlogPostChanges
04:43:38 * hackagebot courier 0.1.0.13 - A message-passing library for simplifying network applications  http://hackage.haskell.org/package/courier-0.1.0.13 (PhilHargett)
04:50:33 <lechip> hi all!, I am trying to understand the denotational semantics of haskell but I am not a mathematician, can somebody enlighten me to understand how does the fixed point and a least fixed point works?
04:51:07 * Axman6 pokes edwardk towards lechip's question
04:53:34 <heatsink> I don't know denotational semantics well enough to explain it, but here's a chapter about it: http://fsl.cs.illinois.edu/images/4/45/CS522-Spring-2011-PL-book-denotational.pdf
04:55:07 <vanila> lechip, what do you want to know exactly?
04:56:12 <lechip> vanila: I do not understand what is the fixed point and why is impotant in defining the denotational semantics
04:56:27 <lechip> i have a notion but i still have a problem to wrap my head around it
04:56:35 <vanila> hmm couuld I see what you're reading?
04:57:55 <lechip> vanila: http://en.wikibooks.org/wiki/Haskell/Denotational_semantics The section Interpretation as Least Fixed Point
04:59:27 <vanila> oh
04:59:40 <vanila> well when you have a recursive function, f x = ... something that uses f (x-1) ...
05:00:18 <vanila> to assign meaning to this, you need to take the fixed point of the function that creates f given f
05:00:23 <hpc> lechip: http://blog.ezyang.com/2010/12/getting-a-fix-on-fixpoints/
05:00:58 <vanila> so if you started with a non-recursive definition: makeF f x = ... f (x-1) ...
05:01:12 <vanila> makeF (makeF (makeF ...)) x = f x
05:01:35 <vanila> which is good because you already know how to denote non-recursive definitions
05:01:59 <vanila> so now you can just say f is the sup of {makeF _|_, makeF (makeF _|_), makeF (makeF (makeF _|_)), ...}
05:02:43 <socksy> can you have multiline "where" statements in ghci?
05:02:55 <vanila> does that help at all?
05:03:33 <Axman6> socksy: to do multiline things in ghci, start by typing :{ and then the multiple lines, and finish with :}
05:04:08 <Axman6> aka, the moustach-to-creepy-face block
05:04:27 <lechip> what if i have an infinite sequence
05:04:32 <lechip> of more defined things?
05:04:36 <lechip> what would be my sup then?
05:04:40 <ski> socksy : separate declarations with `;
05:04:41 <ski> '
05:04:51 <ski> socksy : or use `:{' and `:}'
05:06:40 <socksy> aha, just going to use ; (couldn't work out the syntax with :{ :}, maybe because I have +m set already)
05:07:34 <mjburgess> does anyone know happstack? it's a haskell question, just about something going on in the HS source
05:08:30 <Axman6> mjburgess: you'd be better off to just ask the question
05:08:41 <mjburgess> (yeah, im in the process of phrasing it)
05:09:56 <mjburgess> so here's a program:  http://www.happstack.com/docs/crashcourse/src/RouteFilters/FromReqURI.hs
05:10:07 <mjburgess> here's the defintion of path :  http://pastebin.com/raw.php?i=ufd88t95
05:10:41 <mjburgess> the type declaration at the top is the signature path assumes in the context used in the program, ie. m = ServerPart
05:11:38 <mjburgess> basically, i dont understand how, in the defintion of path fromReqURI  is working
05:12:19 <mjburgess> the point of this example is that sayHello takes a Subject which somehow path is able to provide, by converting a string taken from the url
05:12:33 <heatsink> lechip: With an infinite sequence you have a limit.  The mathy part is showing that the suprema do converge to a limit.
05:12:37 <xxx-man> ski: hi
05:13:37 <mjburgess> the question is really: how is the right fromReqURI chosen? surely it should be  from a FromReqURI String  instance
05:14:50 <lechip> excellent, ill rad more then ty guys for the explanations
05:15:00 <tayacan> Does the connectTo function from Network do anything weird? I'm getting different responses from my server depending on whether I use ipython or ghci, despite the requests being identical.
05:15:32 <Maior> "different responses"?
05:15:35 <tayacan> ipython and ghci sessions: http://pastebin.com/D03FQMiu
05:16:46 <Maior> tayacan: you're deliberately not using an HTTP library and DIY-ing it?
05:16:52 <Maior> tayacan: tcpdump is your friend
05:17:03 <tayacan> Maior, it's for an assignment, I'm not allowed to...
05:18:09 <exicer_> Can anyone help me out with this cabal error?http://lpaste.net/104582
05:21:44 <kgadek> hi. Have anybody here read the article "Practical tyle inference for arbitrary-rank types"? I have a problem understanding the "subsumption", ie. "more polymorphic than"
05:22:32 <kgadek> actually I have a problem with one lemma there, so any help would be great
05:24:52 <l0cust> Hey, does anyone use shm with evil-mode?
05:25:05 <l0cust> nobody in #emacs or #evil-mode is of any help
05:25:58 <supki> exicer_: --max-backjumps=-1 may help
05:27:05 <exicer_> supki: Okay, that worked. Why ?
05:29:10 <supki> exicer_: cabal has given up on backtracking before it reached a valid build plan
05:30:40 <supki> exicer_: with --max-backjumps=-1 the search is exhaustive
05:31:32 <exicer_> supki: Ahh, okay.
05:44:02 <kgadek> (let's try again)
05:44:08 <kgadek> could anybody help me with this:
05:44:09 <kgadek> http://lpaste.net/104585
05:45:15 <kgadek> (to be precise: in the paper, œÉ stands for polymorphic of rank 1 or greater)
05:55:53 <ski> kgadek : i suspect the answer is simply that the extension of type inference described in the paper simply isn't implemented in GHC
05:57:03 <kgadek> yeah, this is a possibility
05:57:22 <kgadek> yet this should or should not typecheck?
05:57:31 <kgadek> I can't even read f'' / g'' aloud
05:57:52 <kgadek> and my mind exploded 15 mins ago
05:58:32 <ski> i think they could reasonably typecheck
06:01:27 <kgadek> what's the (speaked aloud) type of g'' then? is this something along: g'' takes a function that requires a function that could get any type and return an Int ?
06:01:51 <ski> ‚åúf' :: (Int -> Int) -> Int‚åù could reasonably be passed to ‚åúg'' :: ((forall a. a -> Int) -> Int) -> Int‚åù, assuming we first implicitly "specialize" it to ‚åúf' :: (forall a. a -> Int) -> Int‚åù
06:02:12 <ski> with erasure semantics, this should be an O(0) operation
06:02:16 <mjburgess> if i'm inside the IO monad ( in a do block)  and I want to extract a Maybe, what do i need to do (some kinda lifting?)
06:02:46 <mjburgess> eg.    main = do x <- fnReturnsJust  print x
06:03:03 <ski> with type-passing, we need to wrap like ‚åúg'' (\g -> f' (g Int))‚åù
06:03:22 <ski> (but ‚åúf'' g'‚åù has no hope of working)
06:03:56 * kgadek grabs a pencil
06:04:05 <hspanda> Hi, anyone familiar with deriving instance declarations?
06:04:31 <ski> (by "we need to wrap", i mean the implementation needs to do that, in case it uses type-passing. obviously the idea is to not require the programmer to wrap like that)
06:05:02 <heatsink> A deriving instance declaration uses the same syntax as a regular instance declaration, with no "where" clause
06:06:35 <ski> kgadek : intuitively, passing ‚åúf' :: (Int -> Int) -> Int‚åù to ‚åúg'' :: ((forall a. a -> Int) -> Int) -> Int‚åù works (let's think in terms of erasure, for simplicity's / argument's sake) because if the latter wants to use the former, then it will pass some argument ‚åúg :: forall a. a -> Int‚åù to it, but we can easily specialize this to the required ‚åúg :: Int -> Int‚åù
06:06:42 <ski> kgadek : ok ?
06:07:04 <kgadek> ski: give me a second
06:07:40 <ski> putting a type in the argument position of ‚åú->‚åù flips the roles of "caller" and "callee"
06:08:37 <ski> so since in ‚åú((forall a. a -> Int) -> Int) -> Int‚åù, the ‚åúforall‚åù occurs to the left (inside) of two ‚åú->‚åùs, we're back at the "top level" interpretation of "caller" and "callee"
06:08:59 <hspanda> heatsink: thanks.  Ok, so I'm trying to hack/fix around some package issues.  cairo isn't building
06:09:00 <ski> so just like we can specialize ‚åúforall a. a -> Int‚åù to ‚åúInt -> Int‚åù
06:09:26 <hspanda> It's giving me a "No instance for (Applicative (ReaderT Cairo IO))"
06:09:32 <hspanda> (full details at http://lpaste.net/104587
06:09:37 <ski> we can also specialize ‚åú((forall a. a -> Int) -> Int) -> Int‚åù to ‚åú((Int -> Int) -> Int) -> Int‚åù
06:09:58 <hspanda> so I tried doing as the compiler says. "deriving instance Applicative (ReaderT Cairo IO)"
06:10:15 <hspanda> but that gives me an "Illegal instance declaration for Applicative (ReaderT Cairo IO)"
06:11:03 <heatsink> I think that transformers should already have Applicative instances
06:11:59 <ski> on the other hand, we *can't* specialize ‚åú(forall a. a -> Int) -> Int‚åù to ‚åú(Int -> Int) -> Int‚åù, since it's not our's (the callers) choice to make what the type ‚åúa‚åù should be, here. it's the callee (the one implementing the function of this type) who can make that choice
06:13:03 <ski> but, we *can* "specialize" ‚åú(Int -> Int) -> Int‚åù to ‚åú(forall a. a -> Int) -> Int‚åù -- here in the latter, we have decided to always use ‚åúInt‚åù for ‚åúa‚åù
06:13:17 <heatsink> hspanda: Yeah, the instance is already defined in transformers.  What version of the transformers package do you have?
06:13:25 <ski> however, this doesn't fit directly what one usually means by "specialize", so some alternate term could be desired
06:13:31 <ski> kgadek : ok ?
06:13:57 <kgadek> ski: I'll need even more time to dig through that‚Ä¶ Yet the caller/callee makes sense to me so far, just need to read this few times to not only say "okay" but to understand.
06:14:06 * ski nods
06:14:09 <ski> take your time
06:14:22 <hspanda> heatsink: transformers-0.2.2.0 (in my sandbox)
06:14:50 <hspanda> Ah, which is ancient
06:15:10 <heatsink> It has the Applicative instance
06:15:45 <heatsink> So importing Control.Monad.Trans.Reader should give you the instance
06:15:54 * ski imagines a colorization of types which colors positive and negative portions of the type differently
06:16:25 <hspanda> Ok, so that's the screwed dep which is messing me up.
06:16:30 <hspanda> Or at least, one of them.
06:16:41 <heatsink> Looks like Control.Monad.Reader also exposes the instance
06:16:46 <kgadek> ski: just trying to get to this point :)
06:18:06 <heatsink> hspanda: It's defined in 0.2.2.0, you can check the hackage docs
06:18:51 <hspanda> heatsink: huh, do I have to import anything to enable it?
06:19:09 <ski> (perhaps green for positive/covariant/increasing/monotonic, red for negative/contravariant/decreasing/antitonic, dark blue for both (so no restriction, like with `Const'), and yellow for neither (so can't vary, like with `Endo' or `Cont'))
06:19:59 <heatsink> hspanda: cairo is using mtl.  Do you have mtl < 2 installed?
06:20:10 <ski> (maybe "both" and "neither" there aren't quite accurate, but i think the idea is clear)
06:20:25 <heatsink> Starting at version 2, mtl is an interface to transformers
06:20:31 <hspanda> Both 2.0.1.0 and 1.1.1.1
06:21:02 <heatsink> The instances will be missing if you build with 1.1.1.1.
06:21:35 <phaazon> hm, I‚Äôve been thinking for the whole day, but wouldn‚Äôt it be great to represent sharable relations bewteen objects by a connexe graph?
06:22:47 <hspanda> heatsink: ah, ok.  So I've got some deps that require 1.1.1.1 and some that want 2.
06:22:58 <hspanda> and this is in a cabal sandbox
06:26:21 <hspanda> heatsink: is there any way to tell cabal which version of mtl to build cairo with?
06:28:40 <heatsink> --constraint
06:29:03 <heatsink> I think the syntax is --constraint mtl>=2
06:29:34 <heatsink> Cabal uses those during configure to resolve package dependences
06:30:12 <hspanda> Ok, so do I specifically tell cabal to build cairo separately from the rest of the dependencies?
06:30:28 <hspanda> cabal sandbox install --constraint mtl>=2 cairo
06:30:44 <heatsink> I think so
06:33:43 <kgadek> ski: am I thinking right? g'' says: "I need to get ‚åú(forall a. a -> Int) -> Int)‚åù". This callee with such type thus says: "I get a function that takes anything and returns an int".
06:34:31 <kgadek> and because of this "takes anything" we can specialize it to ‚åúInt -> Int‚åù
06:35:08 <kgadek> *we can specialize ‚åúforall a. a -> Int‚åù to ‚åúInt -> Int‚åù
06:35:41 <hspanda> heatsink: Great! That made progress (cabal install, not cabal sandbox install, but otherwise exaclty what was needed)
06:36:02 <hspanda> is there any way to find the transitive dependencies on a package?
06:36:14 <hspanda> outside of trying to visually parse a large .dot file
06:36:29 <heatsink> I don't know how to do that
06:36:43 <rwbarton> I would just add mtl >= 2 as a dependency of your project in the .cabal file
06:37:00 <rwbarton> blow away your sandbox and start over and see where it goes wrong
06:37:22 <heatsink> This is in cairo, which I guess is a package that hspanda's project depends on
06:37:50 <rwbarton> right and if I read the backlog correctly, cairo actually depends on mtl >= 2 but doesn't state it in its cabal file?
06:38:13 <heatsink> yes
06:38:50 <hspanda> rwbarton: the dependency in cairo.cabal is just 'mtl', no version constraints
06:38:54 <rwbarton> right
06:39:05 <rwbarton> so you can work around that by putting a dependency on mtl in your own project
06:39:14 <NickHu> Can you put a let clause inside a where clause?
06:39:23 <rwbarton> and then you don't have to worry about remembering to build your project with --constraint mtl>=2
06:39:32 <hspanda> rwbarton: but other dependencies of my project seem to require 1.1.1.1
06:39:36 <rwbarton> sure
06:39:41 <rwbarton> you'll find out what they are soon :)
06:40:07 <hpc> NickHu: what have you tried?
06:40:13 <Axman6> NickHu: what for? where does basically the same thing as let
06:40:45 <Axman6> you can do where foo x = let y = x*x in (y,y*x) if you want
06:40:48 <hpc> the grammar is <defn> where <defns>, and definitions are <bindings> = <expr>, and the expression can have a let-in
06:40:53 <NickHu> Something like this: http://lpaste.net/104588
06:41:05 <NickHu> Seems to be wrong though
06:41:33 <Axman6> NickHu: the let is part of the definition of humanReadableMonth so it must be indented more than humanReadableMonth is
06:42:22 <Axman6> NickHu: http://lpaste.net/104588
06:42:25 <hpc> i thought you could have decreasing indentation by default?
06:42:48 <NickHu> But isn't it already indented two spaces?
06:43:35 <hpc> the indentation for humanReadableMonth starts at the h
06:43:36 <Axman6> it must be indented as much as humanReadableMonth; the l in let must be at least as far to the right as the h in humanReadableMonth
06:43:45 <hpc> your let is 4 spaces behind
06:43:54 <Axman6> hmm, I think "at least" there should be "more than"
06:43:54 <NickHu> I see
06:44:18 <NickHu> Also I think the compiler is telling me that month :: Int type signature bit is wrong
06:44:25 <rwbarton> keep in mind you could add a second binding to the where block, lined up below humanReadableMonth
06:45:08 <Axman6> NickHu: well, you're just splitting a string into two, and a String is not an Int
06:45:33 <NickHu> Yes, of course, I'm being silly
06:45:34 <NickHu> Got it
06:57:47 <ReinH> ski: reping :)
07:08:13 <augur> jonsterling: so did harper clarify those tweets? whats the answer!
07:23:58 * hackagebot parsec-extra 0.1.0.4 - Some miscellaneous basic string parsers.  http://hackage.haskell.org/package/parsec-extra-0.1.0.4 (AriePeterson)
07:28:59 * hackagebot console-program 0.3.1.3 - Interpret the command line and contents of a config file as commands and options  http://hackage.haskell.org/package/console-program-0.3.1.3 (AriePeterson)
07:43:32 <ski> hm, is there's a direct common example of a contravariant functor in the libs ?
07:43:56 <ski> i can't use `\a -> (a -> b)', since that includes a lambda
07:44:05 <ski> ReinH ?
07:45:08 <kgadek> ski: `flip map []` ?
07:45:24 <kgadek> > flip map []
07:45:26 <lambdabot>  No instance for (Data.Typeable.Internal.Typeable b0)
07:45:26 <lambdabot>    arising from a use of ‚ÄòM198672303338855526914381.show_M1986723033388555269...
07:45:26 <lambdabot>  The type variable ‚Äòb0‚Äô is ambiguous
07:45:26 <lambdabot>  Note: there are several potential instances:
07:45:26 <lambdabot>    instance Data.Typeable.Internal.Typeable Data.Dynamic.Dynamic
07:45:27 <augur> ski: use newtypes!
07:45:40 <augur> newtype Rra a b = Rra (b -> a)
07:45:47 <augur> Rra a is contravariant
07:46:23 <augur> kgadek: that wouldnt be a functor
07:47:00 <freeman42> hi, any recommendation for the best LINQ-like Haskell library?
07:47:04 <ski> augur : i was looking for some relatively wellknown, already defined, example
07:47:23 <augur> ski: i dont think there are any such things
07:47:24 <ski> i already have `Maybe',`Endo',`Const c' for the other three
07:47:38 <augur> ski: but the Rra example is just your \a -> (a -> b) thing
07:47:44 <ski> yes
07:47:59 <augur> so you can use it, just, not with a lambda!
07:48:44 <danking> Hi, how does one go about debugging "Undefined symbols for architecture x86_64" errors when compiling using cabal?
07:49:17 <danking> I have this cabal file: http://lpaste.net/104590
07:49:42 <jonsterling> augur: Still digesting! Gave me some food for thought about "second-class" modules, and sealing as a computational effect. And concluded with a nice rant on type classes.
07:50:16 <ski> kgadek : "am I thinking right?" -- yes
07:51:22 <kgadek> > :t flip map []
07:51:23 <lambdabot>  <hint>:1:1: parse error on input ‚Äò:‚Äô
07:51:58 <augur> jonsterling: did he clarify any of the stuff regarding recursive types in type theory?
07:52:19 <augur> jonsterling: also, how does he propose to have generativity and implicit class usage? thats the big draw for type classes
07:52:27 <jonsterling> augur: Ah, no! I forgot to ask him about that. This was just about his comments last night.
07:53:34 <jonsterling> augur: He's not that interested in the implicit aspect of TCs, but to the degree he admits it should exist, he is in favor of his Modular Type Classes.
07:53:40 <kgadek> ski: ok, I need to go now. I wanted to thank you very much, this helped *a lot*
07:54:16 <kgadek> (certainly I understand more; I think I need a sleep with this one to feel that)
07:54:52 <jonsterling> augur: I don't think generativity is a problem, since the equational properties you desire can be given with sharing constraints
07:55:04 <augur> jonsterling: i dont understand
07:58:03 <freeman42> can I assume there are no LINQ like libraries in Haskell? :)
07:58:29 <jonsterling> augur: In fact, rereading the MTCs paper, I actually suspect they might have intended the functors for TC instances to be applicative. (They insist that the body of instance functors be pure & total, which in a number of modules papers is given as a precondition for applicativity.) I'll ask him for clarification.
07:58:29 <Maior> what's LINQ?
07:59:29 <freeman42> Maior, uhm, from my pov it is writing statically typed functiona-like queries that can operate on difference type of datastores... ah, I should rephrase
07:59:53 <jonsterling> augur: Hm, never mind. I shall need to get clarification.
08:00:07 <freeman42> Maior, basically I am looking for the equivalent of LINQ to SQL or LINQ to NHibernate in Haskell
08:00:11 <augur> jonsterling: hm. well, i dont think you can achieve generativity+implicitness without the things he hates about type classes
08:00:22 <jonsterling> augur: Can you elaborate?
08:00:24 <augur> jonsterling: maybe generativity, but you need uniqueness
08:00:27 <jonsterling> augur: (No pun intended)
08:00:28 <freeman42> write queries in Haskell language and the library should generate the database specific SQL to run the querries
08:00:47 <jml> I'm trying to write an yesod hello world program. I'm getting this error message when I cabal install yesod-platform: yesod-1.2.5.2 depends on conduit-1.1.2.1 which failed to install.
08:01:26 <augur> jonsterling: without uniqueness, you have to explicitly state the type class in question, so no implicit solving. also, you would have to provide hints for the generative system
08:01:38 <jonsterling> augur: MTCs does indeed use uniqueness. It might be beneficial for you to read the paper: http://www.mpi-sws.org/~dreyer/papers/mtc/main-long.pdf
08:01:39 <jml> and when I try to install conduit itself, I'm told it has an invalid pre-processing directive
08:01:55 <augur> jonsterling: oh, well then how can he complain about uniqueness elsewhere? :|
08:02:33 <jonsterling> augur: Because he thinks it's a pretty terrible constraint. But I think everyone agrees it's necessary for *SAFE* implicit resolution of TC instances.
08:03:06 <geekosaur> jml: you're on OS X, right?
08:03:13 <jml> geekosaur: I am indeed.
08:03:16 <jonsterling> augur: Worth noting that in MTC, you still have to explicitly choose instances, but you only have to do it once, at the top (declaration) level.
08:03:24 <geekosaur> that's the xcode 5 issue, see the /topic
08:03:40 <augur> i really dont see why its terrible, honestly. i think the newtype thing is actually a very clean, sensible thing. something worth porting back to mathematical logic
08:04:03 <geekosaur> | XCode 5 issues? http://is.gd/H4sEub |
08:04:09 <jml> geekosaur: thanks.
08:04:26 <freeman42> aight, if Haskell has nothing like LINQ then I give up on Haskell xD no point in learning a language which would force the programmer to write magic strings when querying the database :(
08:04:56 <Maior> ah obvious trolling, always good to provoke answers
08:05:01 <jonsterling> augur: Oi, I can't say I agree. To be fair, I don't think that Bob really understands the kind of philosophical position that the Kmett-ites hold with regard to coherence, etc. From Bob's perspective, logic programming when you already have functional programming is highly distasteful.
08:05:22 <augur> jonsterling: that is to say, there is something important to, say, the various Ord instances that you can define for the reals -- |R with normal Ord vs |R with divisibility Ord are really two different things. they're really _not_ the same |R
08:05:25 <freeman42> Maior, yep :D ** have a cookie ** but I am really looking for an answer to this
08:05:41 <freeman42> Maior, and how is it trolling if it is true?
08:05:43 <jml> hmm. I thought I'd already done this.
08:06:36 <augur> jonsterling: or for instance, the two ways that lists can be applicative, as either normal or ziplists
08:06:48 <jml> apparently not.
08:06:55 <jml> geekosaur: that fixed it. thanks again.
08:06:59 <klrr_> what is the most efficient way to append a char to a text?
08:07:19 <ReinH> ski: I didn't get to mention the best part of that group thing
08:07:30 <jonsterling> augur: But they *ARE* the same |R. You can talk about two different mathematical objects (|R, normal Ord) and (|R, divisibility Ord).
08:07:55 <augur> maybe the newtype thing isnt the right way to solve that problem, but it highlights an important thing, namely that class instances are ways of looking at something, and maybe what we should recognize is that this means they really ARE different
08:08:37 <jonsterling> And in fact, this is consistent with common mathematical practice. We don't, for instance, reprove all our theorems on "one" |R for another |R. Nor do we even say, "And because |R with normal ordering and |R with divisibility ordering are morally the same structure, P applies here too."
08:09:15 <augur> jonsterling: no thats true, but we also dont think of |R as having an ordering at all
08:09:25 <augur> |R is unordered
08:09:43 <augur> its only in conjunction with some relation that we say we have an ordered set
08:09:55 <jonsterling> augur: wat? |R is the totally ordered field
08:10:00 <augur> no its not
08:10:02 <augur> |R is a set
08:10:09 <augur> (|R,....) is a totally ordered field
08:10:33 <jonsterling> augur: Fair, you got me :). For a moment, it seems as if we switched sides.
08:10:54 <augur> but thats my point, right -- we DO often think of |R, or |N, as having "natural" orderings
08:11:09 <augur> that is to say, when we think of |R or |N or [], we think-of-them-as
08:11:19 <augur> we dont merely think-of-them, we think-of-them-as
08:11:28 <danking> Any idea why I would get "cabal: Prelude.read: no parse" when running "cabal test" ? I'm using the detailed-0.9 test type and everything compiled and linked OK.
08:12:06 <augur> and while thats sort of what instances do -- tell us the as-ness -- i feel like it might be sensible to make the as-ness part of the intension
08:12:32 <jonsterling> augur: This may be done at the top level like this: `using CanonicalNatOrd in ...`
08:12:42 <augur> jonsterling: that is to say, we might want to take intensionality seriously, and introduce a Hesperus-Phosphorus distinction (which newtype tries to do)
08:13:43 <jonsterling> augur: Likewise, with canonical structures in Coq. I think it's important that all TC instance resolutions use whatever has been decided to be "canonical". We want the elaborator to *do no harm*. But we should also be able to say, "Now let us consider the reals ordered by divisibility"/
08:13:53 <ReinH> Frege in #haskell. Love it.
08:14:03 <augur> im not sure how you would do this, honestly, but i feel it would require that we separate out the representation from the thinking-of-it-as stuff, and using only the latter for type classes?
08:14:09 <augur> ReinH: :)
08:14:29 <augur> jonsterling: i dont think that canonicality is a good approach honestly
08:14:38 <ReinH> jonsterling: hi :)
08:14:42 <jonsterling> augur: I'm not sure how your what you want is distinct from canonical structures, etc.
08:14:53 <jonsterling> ReinH: Hello!
08:15:02 <augur> jonsterling: its different in that its not canonical structures!
08:15:14 <jonsterling> augur: How delightfully tautological.
08:15:18 <augur> :p
08:15:26 <augur> jonsterling: "Canonical" is maybe one way of thinking-of-it-as
08:15:41 <jonsterling> augur: Do you mean we should not privilege one as-ness?
08:16:13 <augur> jonsterling: more like, we should have names for each as-ness that captures higher-level similarities
08:16:14 <kotopies> Hi! I've got warning about defaulting to some constraints. Can somebody suggest a solution? http://git.io/AWK3IA
08:16:43 <yitz> klrr_: foo `T.append` bar is really the only way, but it copies the text.
08:16:59 <yitz> klrr_: so if you need to do that a lot, use a builder
08:17:05 <jonsterling> augur: Hm, that I'm not really convinced of. But its an interesting point. There certainly is something to be said for the fact that in Haskell, you cannot confuse a "real number which is intended to be compared in the normal way" for one which is intended to be compared in a weird way.
08:17:24 <ReinH> The diff list transform is so useful
08:17:39 <augur> jonsterling: for instance, instead of canonical applicatives for lists, we should explicitly say we're thinking of lists _as_ products, or whatever
08:17:56 <jonsterling> augur: I guess I see tools like the newtype as something very basic which should be used precisely when its exact semantics are desired. But not as the only thing.
08:18:02 <yitz> ReinH: now that text has builders built in to the library, you rarely need diff lists for text anymore.
08:18:10 <augur> jonsterling: instead of List and ZipList, instead think of ProductList and ZipList
08:18:27 <ReinH> yitz: but builder is a diff list transform for Text right?
08:18:47 <yitz> ReinH: basically, under the hood, yes, but you don't need to worry about that.
08:18:55 <rwbarton> kotopies: x^(2 :: Integer) -- or x*x :)
08:18:57 <augur> jonsterling: imagine if instead, every instance has to be declared for a newtype, so to speak, because we must always specify _how_ we're thinking of things, not merely what the structure is
08:19:00 <ReinH> that's what I'm saying though :p
08:19:14 <yitz> ReinH: ok got it sry :)
08:20:03 <ReinH> It's also exactly the transform used to improve asymptotics of free monads :)
08:20:28 <jonsterling> augur: Right, this is very interesting. I think there's certainly a place for that kind of thinking. However, this is in general very anti-modular (with a lowercase `m`), since there are many computations which we wish to perform which do not depend on which kind of thinking we are doing. Moreover, it does not compose, since there would be an exponential
08:20:28 <jonsterling> explosion of "conceptual views" like ProductList and ZipList.
08:21:18 <augur> jonsterling: im not entirely sure this is possible, because you'd have multiple class constraints on a single type, so you'd need a LOT more as-ness-es
08:21:32 <kotopies> rwbarton: Thanks :) But why was it wrong in the first place?
08:21:33 <jonsterling> augur: Precisely...
08:21:49 <jonsterling> augur And so we arrive at a place where it might actually make more sense (and be more manageable) to say, "When we're thinking of lists as products, it is all the product-like TC instances which are considered canonical". And then we have arrived at MTCs.
08:22:16 <ReinH> Also this isn't a flat space. It's a lattice.
08:22:17 <augur> jonsterling: i think possible the declaration of canonicity is maybe on the right track? like, we have to say up front -- "I'm thinking of lists like this"
08:22:38 <jonsterling> augur: Yeah, I think it might be the right direction, even if I agree it's not perfect.
08:22:42 <jonsterling> augur: Nice conversation! But I have to go. Feel free to email me, or catch me later if you want to discuss further!
08:22:43 <augur> i think maybe i like that solution then
08:22:48 <ReinH> |R's as-ness forms a lattice
08:22:51 <augur> jonsterling: k, see ya :)
08:23:04 <ReinH> monoid, group, ring, field, etc
08:23:11 <ReinH> multiple versions of each
08:23:27 <ReinH> so that adds complexity
08:23:55 <freeman42> "As yet there is, AFAIK, no production ready full blown LINQ-esque library in Haskell." case closed, moving along, nothing to see here ^^ http://www.reddit.com/r/haskell/comments/22x2zy/haskell_wheres_the_linq/
08:25:17 <ReinH> augur: this "as-ness" declaration could be scoped like a where! o_O
08:25:51 <bms1> I'm having dynamic linking issues with GHCi/Template Haskell on Mac OS X. Using GHC 7.8.2. I'm trying to install "vector" but it can't find libHSprimitive-0.5.3.0.dylib (from "primitive"). And I can't find that file either!
08:26:13 <augur> ReinH: ?
08:26:34 <freeman42> <trolling> 24 year old language... and still querying databases by writing magic strings :D </trolling>
08:26:35 <ReinH> Rather than top-level, it could be any-level
08:27:04 <augur> ReinH: oh, sure. could be tricky to do tho.
08:27:09 <augur> im going to go get food
08:27:33 <ReinH> augur: or maybe with ad hoc polymorphism
08:28:04 <ReinH> (fs :: ZipList) <*> xs
08:28:12 <ReinH> and defaulting
08:28:42 <augur> ReinH: well, in agda, you would tell <*> whats what
08:28:49 <ReinH> right
08:28:56 <augur> _<*>_ {ZipList} fs xs
08:29:05 <ReinH> gotcha
08:29:12 <ReinH> augur: ok bye
08:29:16 <augur> or {{ZipList}} rather, but both are bad solutions
08:29:17 <augur> anyway
08:35:34 <yitz> freeman42: definitely a troll. we're using persistent and it's great for us.
08:36:03 <freeman42> yitz, thanks, I will have a look at it
08:36:17 <yitz> freeman42: linq is not a good match for haskell, as edwardk points out in that thread. it has a lot of inherent weakness due to the nature of c#.
08:36:45 <yitz> freeman42: joins for persistent are in the esqueleto library.
08:36:50 <hpc> there's an extension that adds a linq-like syntax for list comprehensions
08:37:09 <hpc> it's not terribly useful, and not extensible either
08:37:15 <freeman42> yitz, "joins for persistent are in the esqueleto library" what do you mean?
08:37:35 <yitz> freeman42: some people knock it in the reddit thread. it's not totall complete or perfect. not as huge as linq. but it works great for us.
08:38:11 <yitz> freeman42: a common criticism of persistent from people who didn't look very hard at it is that it doesn't support joins.
08:38:22 <freeman42> yitz, are you talking about `Persistent` or `Esqueleto`?
08:38:45 <yitz> freeman42: it actually used to support some limited joins, but they were taken out. because now there is a separate library, esqueleto, that provides joins for persistent.
08:39:26 <freeman42> that is a little bit confusing. so, in the end you use Esqueleto all the time or a mix of it and Persistent?
08:39:42 <jonsterling> augur: For when you get back Derek Dreyer's slides on applicative functors has a section on how they are useful for MTCs. Not sure how Bob feels about that, but it seems sane. http://www.cs.ox.ac.uk/ralf.hinze/WG2.8/24/slides/derek.pdf
08:39:50 <yitz> freeman42: both. they work together. persistent provides the basic db connection pool, schema creation, migration, and basic inserts updates and queries. esqueleto adds joins.
08:40:06 <yitz> freeman42: a mix.
08:40:21 <yitz> freeman42: both at once. if you need joins.
08:40:51 <yitz> freeman42: you can think of it as one db library, broken into 2 smaller pieces on hackage.
08:40:58 <freeman42> yitz, thank you, this is really useful. for me and I hope other who are reading ^^ was worth the troll
08:41:06 <freeman42> ok, nice
08:41:17 <yitz> freeman42: :)
08:41:23 <freeman42> have you tried that HaskelDB libarary? they say it resembles LINQ the most
08:42:26 <yitz> freeman42: a while back. it had a lot of rought edges then. if people have been working on it, it's a nice concept and worth looking at.
08:42:59 <yitz> freeman42: i don't think it's nearly as automated as persistent though.
08:43:30 <freeman42> yitz, ignoring the weaknesses of C# (I am assuming you are speaking about holes in the type system) a LINQ for Haskell would be very useful, right?
08:44:44 <freeman42> I am reading RLH, just finished the DB chapter and all the database queries were given with magic strings and HDBC... that got me a little scared :)
08:44:48 <yitz> freeman42: http://www.reddit.com/r/haskell/comments/22x2zy/haskell_wheres_the_linq/cgs1bri
08:45:06 <yitz> freeman42: right there are many other options
08:45:29 <yitz> freeman42: rwh is starting to age now...
08:46:19 <freeman42> ah yeah, RWH ^^ I read LYAH before, and started reading RWH cause there were fewer books when I started reading it
08:46:23 <warpy> is there a way to load functions by name? like in java you can load a class by name if it is present in the classpath
08:46:37 <freeman42> I think a new Haskell book just published recently
08:47:13 <freeman42> warpy, in GHCI or where?
08:48:14 <warpy> freeman42: in my own code
08:48:29 <warpy> like a plugin kind of design
08:48:55 <freeman42> ah, like, loading them at runtime?
08:49:16 <warpy> i specify an interface, others write the code satisfying it, and my module can discver them automaictally
08:49:31 <warpy> fread2282: runtime or compile time, either is fine
08:49:58 <warpy> say, i specify a type signature as the interface
08:50:24 <warpy> then i automatically find all functions satisfying that sig
08:50:31 <warpy> and call them one by one
08:50:50 <freeman42> warpy, maybe http://hackage.haskell.org/package/plugins-1.5.1.4/docs/System-Plugins-Load.html
08:51:13 <warpy> i tried it. it doesnt work :(
08:51:20 <freeman42> warpy, what about this? http://codeutopia.net/blog/2011/08/20/adventures-in-haskell-dynamic-loading-and-compiling-of-modules/
08:51:23 <warpy> gives strange errors that i dont understand
08:51:51 <freeman42> warpy, ask a question on SO about them or ask here :)
08:51:58 <freeman42> *StackOverflow
08:52:16 <warpy> well, i am asking here ..
08:52:31 <glosoli> how does one make a comment like {- -} with keybinding in emacs haskell m doe ?
08:52:34 <glosoli> mode"
08:53:07 <freeman42> warpy, I was saying to ask about the errors you are getting
08:53:33 <Saizan> warpy: try hint
08:53:56 <warpy> oh. i looked around on internet and people said system-plugin package is broken now due to ghc internal changes
08:55:51 <warpy> Saizan: checking hint
08:56:10 <augur> Saizan: oi
08:56:26 <augur> Saizan: i have questions that only you know the answers to :|
08:59:32 <yitz> glosoli: no default binding to insert them. easy enough to add one if you want. it does support smart indentation of {- -} comments (try M-q inside a comment)
09:00:08 <yitz> glosoli: and it knows about haddock
09:00:18 <glosoli> yitz: ok sir, thanks, not that I use them a lot, just  was curious if there is some binding! :)
09:00:28 <augur> jonsterling: using the term "applicative" different there than usual
09:00:30 <glosoli> Though obviously {- is not much of a job to type
09:00:40 <jonsterling> augur: How do you mean?
09:00:51 <augur> jonsterling: well its not talking about Applicatives at all
09:01:20 <jonsterling> augur: Oh lol, but in the context of modules, applicative means "not generative" (i.e. projectable and comparable)
09:01:44 <augur> johnw: yeah, im sure its meaningful, its just confusing :)
09:01:48 <exicer_> Is there an easy way to upsert in persistent ?
09:02:04 <jonsterling> augur: I often use the word "Idiom" instead of "Applicative" to avoid confusion... Particularly since to top it off, there's the overloading of "functor" as well!
09:02:11 <allsystemsarego> hi all, how can I bring these functions in scope in ghci? https://www.haskell.org/ghc/docs/7.8.2/html/libraries/ghc-7.8.2/Util.html
09:02:44 <allsystemsarego> import Util doesn't work
09:02:50 <rwbarton> ghci -package ghc
09:03:01 <Cale> allsystemsarego: That's because usuallt ghc (as a library) is a hidden package
09:03:01 <allsystemsarego> oh, thanks
09:03:05 <Cale> usually*
09:03:29 <Cale> That stuff probably isn't for general use
09:03:42 <allsystemsarego> well, I need fstOf3
09:03:48 <Cale> I wouldn't rely on it staying consistent between versions of GHC
09:03:50 <allsystemsarego> and I hoogled for it
09:03:56 <allsystemsarego> oh, okay
09:04:00 <Cale> Why not just write (\(x,y,z) -> x)
09:04:01 <Cale> ?
09:04:17 <allsystemsarego> what about tuples of 4,5 etc?
09:04:29 <Cale> Who uses 4-tuples?
09:04:34 <allsystemsarego> rewrite the boilerplate every time?
09:04:40 <rwbarton> Well those aren't in Util anyways...?
09:04:41 <Cale> 3-tuples are rare enough as it is
09:04:41 <yitz> glosoli: yeah. you're probably thinking of things like C-c C-f in nxml-mode. i like that. {- -} isn't nearly as common, but would definitely be nice.
09:04:44 <allsystemsarego> hypothetically
09:04:53 <vanila> why does haskell have tuples>2
09:05:04 <vanila> it could just use (a,b,c) as shorthand for (a,(b,c))
09:05:07 <augur> vanila: to show off
09:05:12 <zomg> I had a 5 tuple!
09:05:18 <zomg> to carry over some state in an `iterate` loop
09:05:18 <zomg> :P
09:05:34 <Cale> Yeah, there's not much good reason to use larger tuples, you should probably define a data type
09:06:42 <Cale> (or use pairs)
09:06:46 <geekosaur> tuples are a cheap way to do things without defining an appropriate data type; for very quick stuff that's fine, but for anything significant you're losing the ability for types to help you avoid making mistakes and to guide you to better solutions
09:06:51 <allsystemsarego> well, then why does lens define _1 through _9 for tuples of varying lengths? just kidding
09:07:00 <Cale> lens does lots of stuff
09:07:44 <rwbarton> (the real reason is that lens is defining type class instances, not just functions)
09:08:24 <rwbarton> and there's a strong argument for defining all the type class instances that make sense alongside your type class definition
09:08:25 <eikke__> anyone ever used Apache Storm with Haskell?
09:09:50 <edwardk> lens is really 3 parts. its a bunch of tools for specifying optics for targeting stuff, its a bunch of tools for using them, and then it also has a bunch of these ad hoc classes that make it convenient to not have to use a ton of different names for the same kind of operation. the latter part which drives, at, each, ix, etc. makes me a bit queasy as it requires reasoning instance by instance for truly ad hoc reasons but it is quite
09:09:51 <edwardk>  effective
09:10:12 <augur> anyone know about the capabilities of Higher Order (Pattern) Unification?
09:10:14 <yitz> exicer_: there's repsert
09:11:25 <companion_cube> augur: the ones in lambda prolog?
09:11:36 <augur> companion_cube: maybe!
09:12:12 <yitz> exicer_: what is "upsert" supposed to do, anyway? an update doesn't mention all of the fields. make all the others null?
09:12:36 <companion_cube> augur: it's a limited form of higher order unification, that is decidable and unary
09:12:44 <companion_cube> (at most one most general unifier)
09:12:54 <augur> yes
09:13:51 <companion_cube> I don't recall the exact definition of those patterns though :s
09:14:07 <companion_cube> but the unification is efficient, since it's used as the basis of a logic language
09:14:22 <allsystemsarego> edwardk, "each" is for vectors?
09:14:24 <klrr_> anyone know a good way to debug attoparsec parsers?
09:14:38 <edwardk> each is very overloaded
09:15:12 <augur> companion_cube: i need to know if its possible in general to solve problems like this:   fine ?f : S -> T, ?x : S, s.t. ?f ?x = t : T
09:15:16 <augur> find*
09:15:17 <eikke__> klrr_: define 'debug'
09:15:37 <humanoyd> Some code I have has a "import Prelude hiding (catch)" statement and uses Control.Exception instead. Since base 4.6, Prelude doesn't export catch anymore which leads to a warning from ghc when compiling. Should I remove the import statement and bump the lower bound on "base" to >=4.6 or leave it there for older versions of base at the expense of ghc warning me every time I compile?
09:15:47 <edwardk> klrr_: by converting them to using parsers and then running the trifecta instance rather than the attoparsec instance when you get stuck so you can get an expected token set
09:15:48 <deweyvm> is there a way to have a heterogeneous list as a plain typeclass rather than a datatype wrapper?
09:15:54 <deweyvm> using a *
09:16:02 <companion_cube> augur: I'm not sure you can in this case
09:16:17 <deweyvm> not fond of the boilerplate conversions
09:16:26 <yitz> edwardk: tsk tsk
09:16:26 <companion_cube> patterns require functional variables to be bound by a lambda term, or something like this; in your case ?f doesn't meet this criterion
09:16:28 <eikke__> edwardk: trifecta should have more examples
09:16:46 <augur> companion_cube: im not sure what you mean
09:17:27 <edwardk> yitz: you can use the attoparsec instances for parsers. i'm not saying switch long term. merely that attoparsec _by design_ gives no debugging help
09:17:32 <yitz> edwardk: by converting them to uu-parsinglib and then you get a corrected parser
09:17:37 <companion_cube> \f -> f ?x   is a valid pattern, but i don't think  ?f ?x is
09:17:44 <eikke__> yitz: correcting
09:17:58 <edwardk> by converting to uu-parsing lib you get a parser that makes some kind of error correcting parser that makes corrections that make no sense  =P
09:18:24 <augur> companion_cube: i know that adam gundry and conor mcbride's tutorial implementation has things kind of like that
09:18:33 <edwardk> if the errors i made were transpositions in keywords all the time it'd be great
09:18:45 <augur> companion_cube: at least, they have examples of function variables, together with spec that seems to permit ?f ?x
09:19:34 <companion_cube> augur: if you have a tutorial at hand it'll be more helpful than me anyway
09:19:39 <Tjr> Dear experts, I'm toying around with the examples in http://learnyouahaskell.com/starting-out.
09:20:01 <yitz> edwardk: i've used attoparsec extensibly. the only time i had real trouble debugging was when the bug turned out to be a deep attoparsec library bug for lazy text.
09:20:02 <augur> companion_cube: tutorials are only good to a certain extent  :P
09:20:13 <Tjr> If I type this into ghci "doubleMeAgain x = 2 * x" , then I get a parse error.
09:20:22 <Tjr> but if I load the same thing for a file, it works.
09:20:23 <companion_cube> then there are papers which describe lambda prolog
09:20:26 <Tjr> Why? What's the difference?
09:20:27 <edwardk> yitz: what i meant was it give you no error reporting about expected tokens, etc.
09:20:34 <humanoyd> Tjr: use "let" in front of it
09:20:54 <Tjr> humanoyd: thanks. How do I know I need let?
09:20:59 <yitz> edwardk: right that's true.
09:21:01 <Tjr> (apart form asking here)
09:21:16 <edwardk> attoparsec is great for parsing machine generated text where parse errors just don't happen
09:21:18 <rwbarton> ideally, LYAH would have told you so :)
09:21:21 <edwardk> its amazing at that
09:21:30 <augur> companion_cube: its more that i need to figure out specific practical limits of the thing, and so papers arent much help
09:21:56 <yitz> edwardk: you're right, that's what i've mostly used it for :)
09:22:06 <humanoyd> Tjr: just use it in ghci for now...LYAH will tell you more about that in chapter 4
09:22:08 <kazagistar> Tjr: ghci is not the same as typing things into a file, yes. The differences are something you just kind of have to learn, but you will find the syntax of the interpreter similar to "do notation" which you will learn about later
09:22:35 <Tjr> ah, makes sense.
09:22:36 <Tjr> thank you.
09:22:37 <yitz> edwardk: parse error did happen though. machine generated output is not immune to murphy.
09:22:47 <deweyvm> i also dont see how to constrain the typeclass inside the wrapper. If i have a type (Ord a => Map Showable b), how do i constrain my showables to require them to also have Ord instances? Do i need a wrapper for every combination?
09:23:21 <edwardk> sure, but you mostly just care that 'hey this crap is broken' not precisely how for most 'hey i need to parse this wire format' attoparsec usecases
09:23:55 <ajcoppa> Tjr: welcome to haskell! enjoy LYAH and let us know if we can help
09:24:07 <klrr_> is attoparsec even worth it? parsec dont use Text but it is a hell easier to use
09:24:08 <Tjr> ajcoppa: thank you
09:24:39 <yitz> klrr_: attoparsec is much much faster
09:24:46 <Tjr> point of depart is https://news.ycombinator.com/item?id=6782911
09:25:29 <Tjr> I'm just backtracking because I have no idea why it doesn't compile (let alone why Farm isn't missing some arguments).
09:27:04 <klrr_> yitz: yeah but it is soo much hrader to use, its semantic dont make any sense if i write "try double <|> bar" doesnt even work since as long it starts with a number double pass
09:27:20 <Tjr> By the way, what's up with all those apostrophes in function names? I get it they don't mean anything special, but why is everybody else using them, too?
09:27:22 <rwbarton> deweyvm: Showable is an existential wrapper type for Show?
09:27:30 <deweyvm> rwbarton: right
09:27:36 <rwbarton> deweyvm: it looks like you're asking the wrong question already
09:27:42 <yitz> edwardk: i was parsing gigabytes of postscript generated from pdf. it had tons of junk in it that i didn't need. when weird things happened, i needed to know why.
09:27:42 <deweyvm> could be :)
09:27:54 <yitz> edwardk: in that case, attoparsec failed much faster than other libraries
09:27:57 <rwbarton> if you have two values a and b and you know the types of a and b are instances of Show then you have no way to compare a and b for order
09:27:57 <edwardk> yitz: fair
09:28:06 <rwbarton> even if the types are instances of Ord too
09:28:10 <rwbarton> because the types might be different
09:28:19 <yitz> edwardk: which allowed for much more efficient banging of head on wall
09:28:27 <rwbarton> (aside of course from comparing 'show a' vs 'show b')
09:28:35 <deweyvm> rwbarton: ahh so i could
09:28:39 <deweyvm> yeah that would work too
09:28:44 <rwbarton> in that case
09:28:49 <rwbarton> why not simplify everything and use a Map String
09:28:55 <edwardk> i keep trying to come up with a way to run a parser that can get somewhere near attoparsec speeds with better error reporting, but it seems shedding that weight is where attoparsec derives a lot of its speed
09:29:11 <bms1> Tjr: It comes from the convention in math, where if we have x, we might write x' to stand for something similar to x
09:29:25 <yitz> edwardk: two modes would be helpful
09:29:26 <deweyvm> rwbarton: basically just trying to `show` them at the last minute. i can see that its causing some headaches though
09:29:30 <deweyvm> no real reason to wait
09:29:42 <bms1> Tjr: We call the ' "prime". Also, sometimes the prime indicates that a function is strict, rather than lazy (like foldl vs foldl')
09:29:47 <yitz> klrr_: yes in attoparsec you need to refactor your grammar more
09:29:55 <edwardk> i'm working on switching trifecta off the rope model to get something that can do _some_ streaming anyways
09:29:59 <gdoteof> http://lpaste.net/104591   i am having a hard time figuring out how to parse a json with multiple constructors
09:30:02 <Tjr> bms1: ok, so it does really have a social meaning, to indicate strictness.
09:30:14 <Marqin> http://pastebin.com/QA9LrvSJ why do i get "parse error on input `<-'
09:30:16 <Marqin> "?
09:30:16 <rwbarton> deweyvm: especially if you are using them as keys in a Map, in which case you'll have to 'show' them many times when comparing keys while inserting or doing other Map operations
09:30:26 <bms1> Tjr: Only sometimes. Most of the time, it probably means a modified version of the original thing
09:30:35 <Tjr> ok
09:30:59 <deweyvm> rwbarton: i wanted them to be Defaultable too, which makes a bit more sense i think
09:31:05 <deweyvm> just types with a "default" value
09:33:47 <gdoteof> this is why i am trying to do that http://lpaste.net/104592
09:33:54 <kazagistar> Tjr: that code in the hackernews article compiles for me... are you confused about something in it specifically? it makes somewhat heavy use of syntax sugar in the form of do notation
09:38:26 --- topic: 'http://www.haskell.org/ | Paste code/errors: http://lpaste.net/new/haskell | Logs: http://tunes.org/~nef/logs/haskell/?C=M;O=D http://ircbrowse.net/day/haskell/today?mode=recent | Administrative issues: #haskell-ops | Hackage down? http://hdiff.luite.com | XCode 5 issues? http://is.gd/H4sEub | Need an op? Try: @where ops'
09:38:26 --- topic: set by johnw on [Mon Feb 17 18:32:10 2014]
09:38:26 --- names: list (clog_ lemao_ passiveo- Sculptor_ edsko_ anic_ Wuzzy AntiSpamMeta popx Kaini1123 zcourts_ tromp__ Vince__ kazagistar aostiles ambimorph eskatrem pavonia gdoteof mirpa Yoctogon Sebastien-L jml thalassarche averell kjnilsson mars-92 benj_ magri _Noether_ Shogun madjestic taruti Tjr Javran martinga_ triliyn Swizec bonobo123 deweyvm mjs2600 tazjin cognominal kgadek john_not_jenny humanoyd hoverbear allsystemsarego umib0zu Quashie_ maxcan nexx dwcook Takle)
09:38:26 --- names: list (twanvl_ free_beard dsabanin ixti zymurgy paullik codesoup Welkin conehead alpounet edwardk glguy bnitka bluesm latro`a jxv edsko oscar_toro r444 eikke__ Oxyd xcv_ razieliyo Kron luzie Eduard_Munteanu Teknokratsevilla esoto exicer_ davorb jeka sepp2k Icewing slomo gehmehgeh u_ klrr_ tsani klarh q66 perspectival meoblast001 zwer rcharles_ pkkm3 bms1 freeman42 samrat agamble kazimir42 artyomkazak telser hiptobecubic Janarto jmcarthur ritz4_5 ksf meandi__)
09:38:26 --- names: list (zcourts Sorella papermogwai hellwolf Zeitgeist_ croyd jumblerg sigma9141 mjburgess _ctc_ ArneL ulfdoz Akita yorick mhi^ mcstar edon- petanqk klaut sgregory goldkatze lucky lemao `bps knigitz mathmonkey socksy Gurkenglas myoriel tpsinnem seschwar vanila lopex sxn derdon l4u_c lechip silver hexagoxel pxqr Philonous alanz jophish Vince_Juicy OffTheRails ephemeron tremon thunderrd hashcat osa1 Someguy123 otterdam glosoli gienah catsup deJong jackneill roconnor_)
09:38:26 --- names: list (archblob Jeanne-Kamikaze BBShortcut DarkTiger MrWoohoo ktosiek nik_ ioanel yitz SCHAAP137 dmilith ZettaBlade SoupE ZioCrocifisso mforney plutoniix Zedrikov Reite amatsu slyfox darthdeus wlhlm shintah| amathew Kaini laar DanielDiaz FVG anick jesyspa phyrex1an ATuin pyon funfunctor eizo kirelagin Draggor rlp10 jefimenko simukis_ MoALTz hackagebot alemedeiros vili psychicist_ vertexclique tvorog MercurialAlchemi Guest87660 RchrdB xinming bergey` hvr yacks)
09:38:26 --- names: list (sakirious rschulman snoyberg sinclair|work enk0 pikhq jonathanj omefire tv effy boothead ThatOtherPerson chad___ apaku deevus smarter taktoa mjo norgaard xtsee neptunepink kakos sunnavy pgokeeffe c74d predator117 nominolo meretrix bocaneri ANR_ amueller LordBrain ormaaj otulp clog Derander Guest46448 Ginto8 migimunz louisjb kroogs tavelram_ mgaare araujo Rufflewind_ DexterLB centrinia danking Sonderblade timmot Shin-LaC DT` hmax_ shanse mikeplus64)
09:38:26 --- names: list (randomclown jrib thoradam Arkaniad|Laptop jcarpenter2_ demolithion Jaak boogie passiveobserver systematik Guest99711 juhp_away Guest76953 l4u yusukesuzuki-off pingu FireFly yac zq mindleyhilner ixian dgpratt_ Exio4 dogmaT tromp_ rien tb01110100 SparkySparkyBoom mmmm ts33kr Or1 peder OlegYch favonia monsieurp Sculptor popz hc annulus jibi jle` Wamanuz Rylee chasecaleb cdidd rray zeiris mavam tomboy64 SHODAN gandr Marqin lyxia hammi nakal_ supki biscarch)
09:38:26 --- names: list (photex ryantrinkle djapo eguim Lacriatch joeyh dagle ew0000 enolan ValicekB madmonkey otto_s dgvncsz0` qrada jeffberhow selator croys borrelnoot9 ceii dolio vlad003 dosequis pfurla c909 mgomezch emma SegFaultAX haasn Nahra milessabin xeno_ dino- bytbox julmac Atrumx yubrew augur semberal noddy ryanakca nemesit|znc blastrock Ralith teeteewhy rmunroe iulian Dodek AncientPC sm c_wraith Artpicre jaimef morolin jrslepak FreeFull xenomachina Kabaka HugoDaniel)
09:38:26 --- names: list (jin_jin asjo hbar drdo Lindrian noam_ niklasl jcsims bbloom dougia MagneticDuck _flow_ Smilex vendethiel Maior martingale MindfulMonk drbean sjy tippenein Figueroa chaptastic fabjan rejuvyesh[away] Burton wjt _46bit_ seliopou ivanm syrioforel eazar001 tessier gniourf erikd thetallguy Nivim xye jchee isomorphic AtnNn dreixel sclv lieven_ fran ivan\ theanine chirpsalot Boney Nanar sprang iota_ mononofu kardboardb Will|- honkfest1val zpconn_______ savanni)
09:38:26 --- names: list (acharles Khisanth egisatoshi_away theorbtwo TDJACR joar superjudge_ kfish akurilin arun b_jonas relrod ahf regtools ljhms Chousuke dixie_ kylcarte stass jakutis ClaudiusMaximus Plasmastar wolverian dcoutts janne andrewsw hamarukusa ninegrid j`ey andyland shepheb jcurbo waterlaz andares tomprince blast_hardcheese davidthomas sellout dustinswan euphoriaa renzhi pieter__ lokydor AlainODea_ stephenmac7 __class__ CindyLinz mathu Xorlev akahn Gracenotes_ tmssgrdn)
09:38:26 --- names: list (pnielsen__ mayski willb1 xenocons aji machineslearn ft inarru froztbyte joneshf vsayer_ Sornaensis Kruppe chance aseidl everett dh go|dfish Enigmagic oconnore alinab aford Igloo george2 AshyIsMe xymox mgomes_ jlamothe turinturambar j0ni_ robbert Tordek_ Paks knyppeldynan gdsx_ yan_ atohs paz_ noteventime ernst kstuart_ onielfa1 `^_^v Krakarn-- bgamari XyMa ousado Gunni mxf pii ForNeVeR etabot katis helgikrs tgeeky nwf dumbhat flux Sagi ParahSailin Intensity)
09:38:26 --- names: list (brixen nicoo Th0mas djahandarie CosmicRay tekacs Phlogistique Tene ccasin lenstr delimax_ tomejaguar Rutger` hdevalence|away shutdown_-h_now kittenso1p yeltzooo kalz aelse sea-gull vamega LordDeath mno2 Polarina asm89 happy0 callumacrae pi8028 lpsmith zz_robj_ xplat edk pharaun mrb_bk fergusnoble greymalkin yhvh_ Boreeas Edoxile peddie bitraten sipa sykora inr helgar redtricy1le drone| majoh sa1 eagleflo NinjaPenguin Paprikachu_ phadej Svedrin fnordbert)
09:38:26 --- names: list (melter Cerise zomg defanor_ fall__ sohum liszt mimi_vx Reisen Nickeeh Wayneoween coppro andyo kwantam_ himikov wunki shennyg goldfire1 vermeille1 jmcc nispaur_ therealklanni anachron companion_cube bwe_ \q awruef KorriX_ kandinski avdi yeshuah Saizan tov_ liyang joseph07_ c9sloud Jaxan Blkt ahihi chas korpse______ leifw`` tero- nik_89 jodaro fakeezz stepcut hpc absence PierreM_ ndngvr elrancho_ jroesch_ lacrosse_ Turboknot13_ Iceland_jack stevejb` tromp)
09:38:26 --- names: list (amiller andreypopp tismith Rarrikins Cryovat davidfetter fikusz hyPiRion epta grache28 mmaruseacph2 cross Kobata MitchW cjwelborn skarn shintah eL_Bart0 Mon_Ouie dqd troydm dmwit Karethoth PatrickRobotham statusbot bjornars Bigcheese vinothkumar kipras`away bkolera bchar nsaje aupiff cdk cyphase canta BrianHV slasktask dlundy so rola posco_ dp_wiz gidogeek pjdelport dkua puzza007 uncleBlazer zz_flazz ReinH mbrcknl vera stevely ggherdov tobyp_ jtwitsch_)
09:38:26 --- names: list (johnw lambdabot Natch Nik05 idupree vital mattp_ bstrie obcode eurythmia RayNbow`TU tragicsans spacebug bergmark frawgie_ arch__ tabo jorj profmakx ckw bbee ekroon tumdedum mnemon Biohazard tim`` frms GGMethos Desoxy marsbot haroldwu Licenser Pythonfant Raynos Brando753 m09 dabradley sleepynate mokus kloplop321 gridaphobe felttrip AivarasK cynick strmpnk ttuegel jzelinskie Bwild rhodesd dropdrive stephe__ drmegahertz Kneiva nesqi horlicks Phillemann)
09:38:26 --- names: list (seanparsons zalami leifw mrkishi [swift] Martty billyiii [mth]_away nifty stvc FliPPeh fluffiey acomar Internet13 chrra mikecaruso solarus hamishmack_ pnielsen thirsteh ivan` Baughn Bootvis maoe shachaf japesinator Walther Axman6 zerokarmaleft guymann Adios nisstyre thoughtpolice phy1729 pgavin` kragniz brackets oubiwann BlastHardcheese saiam ec zxq9 ChongLi Klumben wollw_ gx^ bd__ amontez tlevine ocharles znutar_ jdiez dju solirc d3lxa vhz rootzlevel)
09:38:26 --- names: list (BeardedCoder osnr cjay xnyhps ziman bcoppens jaysonsantos papna hayashi saurik b2coutts tg wjlroe danneu rahul mangaba_leitosa yano myme sajith Sgoettschkes eiro deavidsedice Deewiant Sylarr anders0 gfontenot pfoetchen KaneTW Watcher7 DasIch mlen Kinnison ski kosmikus sofancy ejls confound ofan pp^ snowp slobo majackson prinsen spion mandu marienz sgray10 plhk rtl applybot ibid eyenx lulf lpaste opqdonut Vq jj2baile mr- Fuuzetsu spaceships kaol yam s4msung)
09:38:26 --- names: list (kxra JPohlmann Rembane theDon zenzike Olive` WarzoneCommand KitB burp warpy nurupo cow-orke1 wormphle1m javawizard brisbin ivoscc Hardolaf phryk terlar codeburg shapr swen boegel|work|afk gemelen td123 Hodapp martin joefiorini claudiyoh ciaranm adimit leroux lispy eyem Laney osfameron cmsd2 mero FreakyPe1guin itsmonkt1stic statusfailed k00mi maurer byorgey bens OrangeDuck int-e bind cpa_ mike2 `0660 Adeon bjobjo ByronJohnson felipe_ mshroyer aristid)
09:38:26 --- names: list (sordina2 musicalchair jackhill thorkilnaur srhb tsou sam_d Starfire Liskni_si kmicu comboy Gothmog_ schlumpi mortberg mmaruseacph2|umb iron_houzi koala_man indigo lusory notdan ido cschneid unsymbol integral suOya edwtjo xintron grohne jaspervdj cyrusdavid akshatj bartavelle pyrtsa heikkih davnils Dashkal jrp6 identity uzo karls finnrobi yriw felixn moop fyolnish totte sgronblo ion humppa frontendloader jlewis imalsogreg duairc simon earthy Maxdamantus)
09:38:26 --- names: list (Merovius dschoepe CaveJohnson joe_k mirsal @ChanServ JesuZ _1126 neektza ps-auxw dxld LeaChim apples bigos petterw bitemyapp Ke Arnar_ ZsoL bernalex stiell ephess prattmic M-ou-se Razz heudebeu gargawel valdyn Jei Eridius yggr RevJohnnyHealey aoh necroyeti Fubar^ afleck wting Guest11663 Taneb clementd bra phaer harski felixsch Gika xaimus hive-mind cods fussman bjorkintosh Belgarion0 dario SwashBuckla aninhumer pqmodn kshannon michaelpj zeptar Athas idoru)
09:38:26 --- names: list (Harbinger tamiko jrw gseitz copumpkin fractalcat Valodim albel727 h_chiro wagle stelleg stbuehler macron astroblaster raek NickHu xahry exicer mrowe_away jrm pfn ninzine BMeph adnap codygman mechairoi cwvh hegge jonke orbital Heffalump heath mrmonday nick1234abcd_ CARAM_ mankyKitty teehemkay docsis__ wizonesolutions steshaw eribeiro jonsterling SethTisue_______ MMuse_ kcherkashin__ wilfredh mads- Nimatek _tca joshsz jabbslad__ raphie JustAPerson Peekay)
09:38:26 --- names: list (Ornedan hamilyon MK_FG TheBrayn alexsdut1on dhrosa magicman MasseR Tehnix bxc Twey qz iteratee Eliel geal ggreg sdx23 mietek Jonno_FTW davean s_e Nshag Erstarrung kloeri Raynes Dtgr natte ederign deni vmeson jpierre03 sveit niko GaveUp tnks jasu0 shelf kcm1700 levi wchun agreif groth monochrom Na6hu7Ud Corey saep NobbZ `micro Eelis Lemmih Yawgmoth jlyndon qr42 mike4 mak` barrucadu Cale klugez keko_ XMunkki __main__ farn blindscreen peltchu audax333 joachifm)
09:38:26 --- names: list (numberten Bonesdog tomaw ilmig SLi chexxor dlackty_ bgyss si14 tdammers mrshoe gaze simon_ scopedTV capybara mendez anders^^ Spockz heaumer rieper xahry_ ehamberg jaffachief _d3f eyck hiredman tigrennatenn RogueShadow tych0 n-dolio jlouis petantik Tesseraction saarin nikola Clint phaazon rs0 luite Hafydd copton irssi_ jzl DustyDingo benbangert betawaffle Drezil dbelange jameseb dan64 lurker6 elgot myf Eagle_Erwin hongminhee adlan Freundlich coconnor_)
09:38:26 --- names: list (alcabrera|afk thirsteh_ ChewieBeardy koalallama jix iross srbaker Zariel zeroskillor TakSuyu linduxed liori cwc antoniy honza dv- Ptival qnikst stoned xpika flebron jayne bsmt n00dle gbarboza blenny evax lamilami StoneToad mixi DarkFox mornfall Imdsm jagtalon nkpart idnar etrepum DigitalKiwi kini geekosaur dyreshark acfoltzer tridactyla Cr8 wjm mikeizbicki carter vikraman u-ou Vbitz utkarsh Spacegoat aspidites ortmage ajcoppa rwbarton Fuco Ezku_ mrd_)
09:38:26 --- names: list (killy9999 FUZxxl bounb joelteon alang cin ircbrowse fryguybob werdna owlglass PHO_ _5kg SaBer bvad dilinger mami flori pcapriotti jmct)
09:38:35 <Tjr> hmm
09:39:11 <Tjr> it turns out apple-v pastes, too. So ghci uses a mixture of OSX and readline key bindings.
09:39:12 <pavonia> gdoteof: I see you're using the <$> and <*> function. These are functions of the Applicative type class. There's another class called Alternative that provides <|>
09:39:32 <Tjr> And two different paste buffers for OSX and readline commands :-(
09:40:01 <gdoteof> pavonia: ah i see
09:40:36 <allsystemsarego> on a mac you probably need cmd-v
09:40:47 <yitz> gdoteof: with pavonia's idea, you could have your parser return a Maybe (String, MyCommand), where the String is the name and you trust the subfield name of data to decide which MyCommand constructor to use.
09:40:48 <pavonia> gdoteof: Also, you probably want an FromJSON implementation for MyCommand. (Note that I'm not familiar with that JSON package)
09:41:08 <yitz> pavonia: presumably aeson
09:41:28 <gdoteof> pavonia: yeah i do, that is part of what i don't understand how to do
09:41:30 <gdoteof> yes i am using aeson
09:42:09 <pavonia> yitz: Can'T you do something like attoparsec does, i.e. matching on field names and going to the next if the match fails?
09:42:20 <pavonia> with aeson, that is
09:42:24 <gdoteof> yitz: bhy parser you mean change my WebSocketCommand types to Maybe (String, MyCommand)
09:42:47 <Tjr> How do you call a list in haskell?
09:43:09 <pavonia> "list"
09:43:11 <gdoteof> and yes, i want to trust that the command name for choosing which MyCommand constructor
09:43:20 <Tjr> I'm trying to build a function that takes a natural number, and returns its set theoretic equivalent.
09:43:24 <yitz> pavonia: the match is on the field label, not its value. there is no guard in Applicative, only in Monad.
09:43:47 <Tjr> Prelude> let setnum :: Num -> [ list ]
09:43:47 <Tjr> <interactive>:1:4:   The type signature for `setnum' lacks an accompanying binding
09:44:04 <pavonia> yitz: Ah, I understand the problem now
09:44:21 <gdoteof> hmm i wasn't htinking it on the label.    i could do {command_name: data} though
09:45:13 <pavonia> Tjr: You want to return a possibly infinitely nested list?
09:45:15 <gdoteof> i was doing {command_name: "foo", data: {foo_name: "thename"}}   but it would be fine to do {foo: {foo_name: "thename"}}
09:45:26 <allsystemsarego> > subsequences [1,2,3] -- Tjr this?
09:45:28 <lambdabot>  [[],[1],[2],[1,2],[3],[1,3],[2,3],[1,2,3]]
09:45:33 <Tjr> pavonia: each return value is a finite list.
09:45:53 <Tjr> pavonia: 0 == {}, 1 == {{}}, 2 == {{},{{}}}, etc.
09:46:07 <Tjr> pavonia: in short, a set theoretic number is a set whose elements are also subsets.
09:46:13 <Marqin> got network problems, have anyone answered my question?
09:46:30 <pavonia> Tjr: Yeah, you can't do that with standard lists
09:46:38 <kazagistar> Tjr: another limitation of ghci is that you cannot do multiline definitions very well, thought you can get around it using {} and ; but it is ugly
09:47:18 <Tjr> So how do you do it properly?
09:47:47 <gdoteof> Tjr: do it in a file
09:47:50 <teneen> what's are the advantages of Parsec over the built in Text.ParserCombinators?
09:48:37 <dwcook> Tjr: Fix [] could do it, where newtype Fix f = Fix (f (Fix f)), or a type equivalent to Fix [].
09:48:46 <geekosaur> Marqin, because <- is special syntax, not something you can combine with && like that
09:48:54 <dwcook> Tjr: the problem is that what you're proposing would be an infinite type, [[[‚Ä¶]]]
09:48:56 <kazagistar> Tjr: lists in haskell are well typed, meaning they can only hold a single type of thing. What you are trying to return is more like a tree then a list
09:49:02 <Marqin> geekosaur: so how can I do this?
09:49:18 <Marqin> i had too much logic programming
09:49:46 <Tjr> dwcook, kazagistar thanks. So Mathematica lists are not haskell lists?
09:49:46 <geekosaur> Marqin, maybe: [(i, j, d) :: Square | i <- [1..m], j <- [1..m], (corner (x, y, d) (i, j)) && (isOnBoard (i, j, d) m n) ]
09:49:54 <geekosaur> but I am not certain of that
09:50:07 <dwcook> Tjr: Haskell lists are not sets.
09:50:34 <Marqin> wooah
09:50:35 <dwcook> (For that matter Haskell Sets aren't sets.)
09:50:36 <teneen> Text.ParserCombinators.ReadP seems to share a lot with Text.Parsec, what's the main advantage of the parsec package?
09:50:38 <Marqin> geekosaur: thanks :)
09:51:19 <pavonia> teneen: Support for line/column counting, user states, monadic contexts and probably more
09:51:25 <eskatrem> Hey, I don't know much about type theory, but in Haskell is it possible to have a type for functions that have the same mathematical properties as the distance (d(A,B) == 0 if and only if A == B, d(A,B) >= 0, d(A,B) <= d(A,C) + d(C,B), d(A,B) == d(B,A) )?
09:51:36 <allsystemsarego> Haskell sets are BSTs, right?
09:51:46 <bms1> allsystemsarego: yep
09:52:07 <vanila> eskatrem, no
09:52:36 <Tjr> let data nestlist = [] | nestlist:nestlist | [nestlist]
09:52:36 <Tjr> What am I doing wrong?
09:52:47 <pavonia> teneen: Also, parsec provides backtracking, I don't know if ReadP does
09:52:51 <dwcook> Tjr: I don't know much about Mathematica, but in many languages you can nest lists arbitrarily because there is only one type, which includes lists and everything else. Haskell has a stricter type system.
09:52:53 <vanila> Tjr, you're not alloewd to use the [] syntax nad : is already taken
09:53:13 <ggnmkk> is it possible to define a type class A a such that if (Enum a) then (Num a) ? In other words, I want to define a type class that installs its type as a member of Num, in terms of toEnum and fromEnum as defined by the installation of that type into Enum
09:53:16 <vanila> data NestList = Nil | NestList :& NestList | ListOf [NestList]
09:53:17 <vanila> might work
09:53:17 <eskatrem> vanila: oh, too bad
09:53:20 <Tjr> vanila: isn't [ somthing, else] just a list?
09:53:25 <teneen> pavonia: good point
09:53:30 <Tjr> valdyn: and "." prepending something?
09:53:40 <bernalex> is there a function that can achieve this: apply a list of functions to a list of variables, one variable at the time. so if fs = [(+2), (+4)], and as = [1, 2], it should produce [7, 8].
09:53:43 <yitz> teneen: ReadP does expensive backtracking. it's still around mainly because it's convenient for easily writing Read instances.
09:53:46 <Tjr> err, ":" prepend something to a list`
09:54:10 <bernalex> so it's like <*> except the result shouldn't be the result of each function applied to each element, but each element with all functions applied to it.
09:54:24 <allsystemsarego> > [(+1),(*5)] <*> [7] -- bernalex
09:54:26 <lambdabot>  [8,35]
09:54:39 <kazagistar> Tjr: take a look at this: http://lpaste.net/104593
09:54:39 <bernalex> allsystemsarego: I just explained why I don't want that
09:54:44 <allsystemsarego> oh
09:54:48 <allsystemsarego> I was typing
09:55:03 <dwcook> bernalex: try a combination of map and foldr (.) id
09:56:45 <allsystemsarego> dwcook, or sequenceA and the function monad
09:56:54 <Tjr> kazagistar:  I get "<interactive>:1:4: parse error on input `data'"
09:57:24 <pavonia> > sequenceA [(+2), (+4)] [1, 2]
09:57:25 <lambdabot>  Not in scope: ‚ÄòsequenceA‚Äô
09:57:25 <lambdabot>  Perhaps you meant one of these:
09:57:25 <lambdabot>    ‚ÄòT.sequenceA‚Äô (imported from Data.Traversable),
09:57:25 <lambdabot>    ‚Äòsequence‚Äô (imported from Control.Monad.Writer),
09:57:25 <lambdabot>    ‚ÄòT.sequence‚Äô (imported from Data.Traversable)
09:57:29 <dwcook> Tjr: that's correct but that syntax is restricted to standard lists.
09:57:33 <pavonia> > T.sequenceA [(+2), (+4)] [1, 2]
09:57:35 <lambdabot>  No instance for (GHC.Show.Show t0)
09:57:35 <lambdabot>    arising from a use of ‚ÄòM448719269060259873116031.show_M4487192690602598731...
09:57:35 <lambdabot>  The type variable ‚Äòt0‚Äô is ambiguous
09:57:35 <lambdabot>  Note: there are several potential instances:
09:57:35 <lambdabot>    instance [safe] GHC.Show.Show
09:57:37 <allsystemsarego> @ty sequenceA [(+1),(*5)]
09:57:38 <lambdabot>     Not in scope: ‚ÄòsequenceA‚Äô
09:57:39 <lambdabot>     Perhaps you meant one of these:
09:57:41 <yitz> pavonia: traverse
09:57:41 <lambdabot>       ‚ÄòT.sequenceA‚Äô (imported from Data.Traversable),
09:57:52 <yitz> @type traverse
09:57:53 <lambdabot> (Traversable t, Applicative f) => (a -> f b) -> t a -> f (t b)
09:57:57 <kazagistar> Tjr: sorry, that was a file, not a interpreter
09:58:12 <Tjr> dwcook: thanks
09:59:15 <yitz> @type Data.Traversable.sequenceA
09:59:16 <lambdabot> (Traversable t, Applicative f) => t (f a) -> f (t a)
09:59:44 <Tjr> kazagistar: even this produces a parse error in ghci: "let data BTree a = [a]"
10:00:23 <glguy> Tjr: You don't use "let" with "data"
10:00:24 <dwcook> Tjr: you cannot use the bracket syntax in your own type definitions.
10:00:28 <dwcook> Also that.
10:00:38 <dwcook> Well, you can use it, but only if it means "list".
10:00:46 <dwcook> In other words you can't make a data constructor with them.
10:00:51 <glguy> building on dwcook's comment, you need: data BTree a = SomeConstructor [a]
10:01:02 <Tjr> ahh.
10:01:07 <geekosaur> or you meant type instead of data
10:01:11 <Tjr> ok, thanks, real life is calling
10:01:32 <Tjr> geekosaur: the tutorial said type only creates new names for the same types
10:01:42 <dwcook> BTree is an interesting name for a list alias :)
10:01:44 <bernalex> dwcook: thanks
10:01:53 <dwcook> Tjr: that's correct. To the type system, they are the same.
10:01:55 <bernalex> dwcook: foldr (.) id fs <$> as
10:02:10 <geekosaur> Tjr, exactly. you can;t use [] in your own types but you could create a type alias which turns into []
10:02:16 <geekosaur> (that is, you are aliasing a list type)
10:02:23 <dwcook> bernalex: yes, that works. (<$>) will end up specializing to map there given the type you gave.
10:02:39 <geekosaur> problem is, given just what you showed us, we don't really know what you were trying to do
10:02:51 <dwcook> Though what you gave has a more general type
10:03:10 <dwcook> geekosaur: they left.
10:04:25 <allsystemsarego> > let compose fs v = foldl (flip (.)) id fs $ v in compose [(+1),(*5)] 7
10:04:27 <lambdabot>  40
10:06:21 <kazagistar> damn, I just finished makeing TjrList work nicely: http://lpaste.net/104593
10:06:53 <Javran> > appEndo (mconcat (map Endo [ (*5),(+1) ])) 7
10:06:54 <lambdabot>  40
10:07:42 <allsystemsarego> @ty Endo
10:07:43 <lambdabot> (a -> a) -> Endo a
10:07:57 <allsystemsarego> @info Endo
10:07:57 <lambdabot> Endo
10:08:05 <allsystemsarego> ya thanks
10:08:49 <cococo> I keep getting "hGetContents: resource vanished (Connection reset by peer)" errors with Network.Whois... anyone know the problem? http://lpaste.net/4552375861554184192
10:09:24 <kazagistar> allsystemsarego: it stands for Endomorphism, or a function from a type to itself... it is just a simple newtype wrapper, and it has some nice typeclass instances
10:10:01 <newsham> ?ty Iso
10:10:02 <lambdabot> Iso s t a b -> ReifiedIso s t a b
10:10:26 <allsystemsarego> kazagistar, thanks
10:13:08 <Welkin> what is ?ty
10:13:24 <Welkin> :t Iso
10:13:25 <lambdabot> Iso s t a b -> ReifiedIso s t a b
10:13:39 <Welkin> a synonym for :t ?
10:14:14 <glguy> The ? prefixes a command that lambdabot responds to. ?ty is short for ?type, ?type checks the type of an expression, :t is an alias for the lambdabot command ?type
10:14:15 <dwcook> cococo: I don't see an application of hGetContents there, but you should know that hGetContents does lazy I/O. That is, it does I/O as a result of evaluating the resulting data. This has some problems such as that you might not receive all the data before the handle gets closed.
10:14:38 <allsystemsarego> :k Iso
10:14:39 <lambdabot> * -> * -> * -> * -> *
10:14:58 <cococo> dwcook: how can I receive all the data then?
10:15:20 <gdoteof> my next attempt at parsing the json: http://lpaste.net/104596  tried to take the monadic approach but i'm still missing a core piece of the puzzle
10:16:40 <dwcook> cococo: one way is to make your computation strict in the result of hGetContents. This can be done with strictness notation (!) or with seq, among other ways.
10:17:28 <dwcook> cococo: now, I'm not certain that's your problem. But it's something to be aware of.
10:17:42 <glguy> ReifiedIso is a newtyped Iso (which is a type synonym hiding some universally quantified type variables) Wrapping it in a newtype makes it appropriate for passing as an argument to a function or storing in data types
10:17:47 <monochrom> try not to use hGetContents
10:18:48 <dwcook> I'm actually not sure what the alternatives are without using a separate package
10:19:00 <dwcook> Or is that the idea? Use something not in base?
10:19:34 <gdoteof> yitz: pavonia ^^
10:21:09 <humanoyd_> Some code I have has a "import Prelude hiding (catch)" statement and uses Control.Exception instead. Since base 4.6, Prelude doesn't export catch anymore which leads to a warning from ghc when compiling. Should I remove the import statement and bump the lower bound on "base" to >=4.6 or leave it there for older versions of base at the expense of ghc warning me every time I compile?
10:22:15 <glguy> humanoyd_: That just depends on if you want to support old GHC or not
10:26:20 <carter> humanoyd_: OR you could do CPP
10:32:38 --- topic: 'http://www.haskell.org/ | Paste code/errors: http://lpaste.net/new/haskell | Logs: http://tunes.org/~nef/logs/haskell/?C=M;O=D http://ircbrowse.net/day/haskell/today?mode=recent | Administrative issues: #haskell-ops | Hackage down? http://hdiff.luite.com | XCode 5 issues? http://is.gd/H4sEub | Need an op? Try: @where ops'
10:32:38 --- topic: set by johnw on [Mon Feb 17 18:32:10 2014]
10:32:38 --- names: list (clog Lethalman dtruby tomboy64 petrus__ eikke__ kgadek l0cust ZioCrocifisso StoneCypher MindlessDrone maaku_ desheng artyomkazak xxx-man johann glguy Valodim_ Yoctogon Or1 joneshf-laptop dsantiago vanila edon- Betal khushildep cococo davorb zlatan MrGwen Enigmagic SimonB_ shintahW mars0000 Takle JagaJaga ifesdjeen edwardk danvet dapz fread2282 petermw Soft newsham haasn RchrdB xye twanvl__ tremon lemao umib0zu meoblast001 SegFaultAX demolithion pkkm3 Zedrikov)
10:32:38 --- names: list (bocaneri teneen drdo dogmaT mwc wlhlm centrinia borrelnoot9 Marqin semberal hc nemesit|- rien elfenlaid AleXoundOS Ulrar unkn kirelagin_ kroogs1 Noldorin otto_s_ Shozan darthdeu `bps_ emma ephemeron Oxyd_ oscar_toro1 humanoyd_ madmonke1 osa1_ passiveo- Sculptor edsko_ anic_ Wuzzy AntiSpamMeta popx Kaini1123 zcourts tromp__ Vince__ kazagistar ambimorph eskatrem pavonia gdoteof mirpa jml thalassarche averell kjnilsson mars-92 benj_ _Noether_ Shogun madjestic)
10:32:38 --- names: list (taruti triliyn bonobo123 deweyvm mjs2600 cognominal john_not_jenny hoverbear allsystemsarego maxcan dwcook free_beard dsabanin ixti zymurgy codesoup Welkin conehead bnitka bluesm latro`a jxv r444 xcv_ razieliyo Kron luzie Eduard_Munteanu Teknokratsevilla esoto exicer_ jeka sepp2k Icewing slomo gehmehgeh klrr_ tsani klarh q66 perspectival zwer rcharles_ bms1 freeman42 samrat agamble kazimir42 telser hiptobecubic Janarto ritz4_5 ksf meandi__ Sorella papermogwai)
10:32:38 --- names: list (hellwolf croyd jumblerg sigma9141 mjburgess _ctc_ ArneL ulfdoz Akita yorick mhi^ mcstar petanqk klaut sgregory goldkatze lucky knigitz mathmonkey socksy Gurkenglas myoriel tpsinnem seschwar lopex sxn derdon l4u_c silver hexagoxel pxqr Philonous alanz jophish OffTheRails thunderrd Someguy123 otterdam glosoli gienah catsup deJong jackneill roconnor_ archblob Jeanne-Kamikaze BBShortcut DarkTiger MrWoohoo ktosiek nik_ ioanel yitz SCHAAP137 dmilith SoupE plutoniix)
10:32:38 --- names: list (Reite amatsu slyfox shintah amathew laar DanielDiaz FVG jesyspa phyrex1an ATuin pyon funfunctor eizo Draggor rlp10 jefimenko simukis_ MoALTz hackagebot alemedeiros vili psychicist_ vertexclique tvorog MercurialAlchemi Guest87660 xinming bergey` hvr yacks sakirious rschulman snoyberg sinclair|work enk0 pikhq jonathanj omefire tv effy boothead ThatOtherPerson chad___ apaku deevus smarter taktoa mjo norgaard xtsee neptunepink kakos sunnavy pgokeeffe c74d)
10:32:38 --- names: list (predator117 nominolo meretrix ANR_ amueller LordBrain ormaaj otulp Derander Guest46448 Ginto8 migimunz louisjb tavelram_ mgaare araujo Rufflewind_ DexterLB danking Sonderblade timmot Shin-LaC DT` hmax_ shanse mikeplus64 randomclown jrib thoradam Arkaniad|Laptop jcarpenter2_ Jaak boogie systematik Guest99711 juhp_away Guest76953 l4u yusukesuzuki-off pingu FireFly yac zq mindleyhilner ixian dgpratt_ Exio4 tb01110100 SparkySparkyBoom mmmm ts33kr peder favonia)
10:32:38 --- names: list (monsieurp annulus jibi jle` Wamanuz Rylee chasecaleb cdidd rray zeiris mavam gandr lyxia hammi nakal_ supki biscarch photex ryantrinkle djapo eguim Lacriatch joeyh dagle ew0000 enolan ValicekB dgvncsz0` qrada jeffberhow selator croys ceii dolio vlad003 dosequis pfurla c909 mgomezch Nahra milessabin xeno_ dino- bytbox julmac Atrumx yubrew augur noddy ryanakca blastrock Ralith teeteewhy rmunroe iulian Dodek AncientPC sm c_wraith Artpicre jaimef morolin jrslepak)
10:32:38 --- names: list (FreeFull xenomachina Kabaka HugoDaniel jin_jin asjo hbar Lindrian noam_ niklasl jcsims bbloom dougia MagneticDuck _flow_ Smilex vendethiel Maior martingale MindfulMonk drbean sjy tippenein Figueroa chaptastic fabjan rejuvyesh Burton wjt _46bit_ seliopou ivanm syrioforel eazar001 tessier gniourf erikd thetallguy Nivim jchee isomorphic AtnNn dreixel sclv lieven_ fran ivan\ theanine chirpsalot Boney Nanar sprang iota_ mononofu kardboardb Will|- honkfest1val)
10:32:38 --- names: list (zpconn_______ savanni acharles Khisanth egisatoshi_away theorbtwo TDJACR joar superjudge_ kfish akurilin arun b_jonas relrod ahf regtools ljhms Chousuke dixie_ kylcarte stass jakutis ClaudiusMaximus Plasmastar wolverian dcoutts janne andrewsw hamarukusa ninegrid j`ey andyland shepheb jcurbo waterlaz andares tomprince blast_hardcheese davidthomas sellout dustinswan euphoriaa renzhi pieter__ lokydor AlainODea_ stephenmac7 __class__ CindyLinz mathu Xorlev akahn)
10:32:38 --- names: list (Gracenotes_ tmssgrdn pnielsen__ mayski willb1 xenocons aji machineslearn ft inarru froztbyte joneshf vsayer_ Sornaensis Kruppe chance aseidl everett dh go|dfish oconnore alinab aford Igloo george2 AshyIsMe xymox mgomes_ jlamothe turinturambar j0ni_ robbert Tordek_ Paks knyppeldynan gdsx_ yan_ atohs paz_ noteventime ernst kstuart_ onielfa1 `^_^v Krakarn-- bgamari XyMa ousado Gunni mxf pii ForNeVeR etabot katis helgikrs tgeeky nwf dumbhat flux Sagi ParahSailin)
10:32:38 --- names: list (Intensity brixen nicoo Th0mas djahandarie CosmicRay tekacs Phlogistique Tene ccasin lenstr delimax_ tomejaguar Rutger` hdevalence|away shutdown_-h_now kittenso1p yeltzooo kalz aelse sea-gull vamega LordDeath mno2 Polarina asm89 happy0 callumacrae pi8028 lpsmith zz_robj_ xplat edk pharaun mrb_bk fergusnoble greymalkin yhvh_ Boreeas Edoxile peddie bitraten sipa sykora inr helgar redtricy1le drone| majoh sa1 eagleflo NinjaPenguin Paprikachu_ phadej Svedrin)
10:32:38 --- names: list (fnordbert melter Cerise zomg defanor_ fall__ sohum liszt mimi_vx Reisen Nickeeh Wayneoween coppro andyo kwantam_ himikov wunki shennyg goldfire1 vermeille1 jmcc nispaur_ therealklanni anachron companion_cube bwe_ \q awruef KorriX_ kandinski avdi yeshuah Saizan tov_ liyang joseph07_ c9sloud Jaxan Blkt ahihi chas korpse______ leifw`` tero- nik_89 jodaro fakeezz stepcut hpc absence PierreM_ ndngvr elrancho_ jroesch_ lacrosse_ Turboknot13_ Iceland_jack stevejb`)
10:32:38 --- names: list (tromp amiller andreypopp tismith Rarrikins Cryovat davidfetter fikusz hyPiRion epta grache28 mmaruseacph2 cross Kobata MitchW cjwelborn skarn eL_Bart0 Mon_Ouie dqd troydm dmwit Karethoth PatrickRobotham statusbot bjornars Bigcheese vinothkumar kipras`away bkolera bchar nsaje aupiff cdk cyphase canta BrianHV slasktask dlundy so rola posco_ dp_wiz gidogeek pjdelport dkua puzza007 uncleBlazer zz_flazz ReinH mbrcknl vera stevely ggherdov tobyp_ jtwitsch_ johnw)
10:32:38 --- names: list (lambdabot Natch Nik05 idupree vital mattp_ bstrie obcode eurythmia RayNbow`TU tragicsans spacebug bergmark frawgie_ arch__ jorj profmakx ckw bbee ekroon tumdedum mnemon Biohazard tim`` frms GGMethos Desoxy marsbot haroldwu Licenser Pythonfant Raynos Brando753 m09 dabradley sleepynate mokus kloplop321 gridaphobe felttrip AivarasK cynick strmpnk ttuegel jzelinskie Bwild rhodesd dropdrive stephe__ drmegahertz Kneiva nesqi horlicks Phillemann seanparsons zalami)
10:32:38 --- names: list (leifw mrkishi [swift] Martty billyiii [mth]_away nifty stvc FliPPeh acomar Internet13 chrra mikecaruso solarus hamishmack_ pnielsen thirsteh ivan` Baughn Bootvis maoe shachaf japesinator Walther Axman6 zerokarmaleft guymann Adios nisstyre thoughtpolice phy1729 pgavin` kragniz brackets oubiwann BlastHardcheese saiam ec zxq9 ChongLi Klumben xpika flebron jayne bsmt n00dle gbarboza blenny evax lamilami StoneToad mixi DarkFox mornfall Imdsm jagtalon nkpart idnar)
10:32:38 --- names: list (etrepum DigitalKiwi kini geekosaur dyreshark acfoltzer tridactyla Cr8 wjm mikeizbicki carter vikraman u-ou Vbitz utkarsh Spacegoat aspidites ortmage ajcoppa rwbarton Fuco Ezku_ mrd_ killy9999 FUZxxl bounb joelteon alang cin ircbrowse fryguybob werdna owlglass PHO_ _5kg SaBer bvad dilinger mami flori pcapriotti jmct stoned qnikst Ptival dv- honza antoniy cwc liori linduxed TakSuyu zeroskillor Zariel srbaker iross jix koalallama ChewieBeardy thirsteh_)
10:32:38 --- names: list (alcabrera|afk coconnor_ Freundlich adlan hongminhee Eagle_Erwin myf elgot lurker6 dan64 jameseb dbelange Drezil betawaffle benbangert DustyDingo jzl irssi_ copton Hafydd luite rs0 phaazon Clint nikola saarin Tesseraction petantik jlouis n-dolio tych0 RogueShadow tigrennatenn hiredman eyck _d3f jaffachief ehamberg xahry_ rieper wollw_ gx^ heaumer Spockz anders^^ mendez capybara scopedTV simon_ gaze mrshoe tdammers si14 bgyss dlackty_ chexxor SLi ilmig tomaw)
10:32:38 --- names: list (Bonesdog numberten joachifm audax333 peltchu blindscreen farn __main__ XMunkki keko_ klugez Cale barrucadu mak` mike4 qr42 jlyndon Yawgmoth Lemmih Eelis `micro NobbZ Corey Na6hu7Ud monochrom groth agreif wchun levi kcm1700 shelf jasu0 tnks GaveUp niko sveit jpierre03 vmeson deni ederign natte Dtgr Raynes kloeri Erstarrung Nshag s_e davean Jonno_FTW sdx23 mietek ggreg geal Eliel iteratee qz magicman bxc Tehnix MasseR dhrosa Twey alexsdut1on TheBrayn MK_FG)
10:32:38 --- names: list (hamilyon Ornedan Peekay JustAPerson raphie jabbslad__ joshsz _tca Nimatek mads- wilfredh kcherkashin__ MMuse_ SethTisue_______ jonsterling eribeiro steshaw wizonesolutions docsis__ teehemkay mankyKitty CARAM_ nick1234abcd_ mrmonday heath Heffalump orbital jonke hegge cwvh mechairoi codygman adnap BMeph ninzine pfn jrm mrowe_away exicer xahry NickHu raek astroblaster macron stbuehler stelleg wagle h_chiro albel727 Valodim fractalcat copumpkin gseitz jrw tamiko)
10:32:38 --- names: list (Harbinger idoru Athas zeptar michaelpj kshannon pqmodn aninhumer SwashBuckla dario Belgarion0 bjorkintosh fussman cods hive-mind xaimus Gika felixsch harski phaer bra clementd Taneb Guest11663 wting afleck Fubar^ necroyeti aoh RevJohnnyHealey yggr Eridius Jei valdyn gargawel heudebeu Razz M-ou-se prattmic ephess stiell bernalex ZsoL Arnar_ Ke bitemyapp petterw bigos apples LeaChim dxld ps-auxw neektza _1126 JesuZ @ChanServ mirsal joe_k CaveJohnson dschoepe)
10:32:38 --- names: list (Merovius Maxdamantus earthy simon duairc imalsogreg jlewis frontendloader humppa ion sgronblo totte fyolnish moop felixn yriw finnrobi karls uzo identity jrp6 Dashkal davnils heikkih pyrtsa bartavelle akshatj cyrusdavid jaspervdj grohne xintron edwtjo suOya integral unsymbol cschneid ido notdan lusory indigo koala_man iron_houzi mmaruseacph2|umb mortberg schlumpi Gothmog_ comboy kmicu Liskni_si Starfire sam_d tsou srhb thorkilnaur jackhill musicalchair)
10:32:38 --- names: list (sordina2 aristid mshroyer felipe_ ByronJohnson bjobjo Adeon `0660 mike2 cpa_ bind int-e OrangeDuck bens byorgey maurer k00mi statusfailed itsmonkt1stic FreakyPe1guin bd__ amontez tlevine ocharles znutar_ jdiez dju solirc d3lxa vhz rootzlevel BeardedCoder osnr cjay xnyhps ziman bcoppens jaysonsantos papna hayashi saurik b2coutts tg wjlroe danneu rahul mangaba_leitosa yano myme sajith Sgoettschkes eiro deavidsedice Deewiant Sylarr anders0 gfontenot pfoetchen)
10:32:38 --- names: list (KaneTW Watcher7 DasIch mlen Kinnison ski kosmikus sofancy ejls confound ofan pp^ snowp slobo majackson prinsen spion mandu marienz sgray10 plhk rtl applybot ibid eyenx lpaste mero cmsd2 osfameron Laney eyem lispy leroux adimit ciaranm claudiyoh joefiorini martin Hodapp td123 gemelen boegel|work|afk swen shapr codeburg terlar phryk Hardolaf ivoscc brisbin javawizard wormphle1m cow-orke1 nurupo warpy burp KitB WarzoneCommand Olive` zenzike theDon Rembane)
10:32:38 --- names: list (JPohlmann kxra s4msung yam kaol spaceships Fuuzetsu mr- jj2baile Vq opqdonut lulf)
10:34:40 <humanoyd_> glguy: Personally, I'd be happy to bump the lower version bound on base but I'm not sure if that is the recommended approach within the community
10:34:57 <carter> humanoyd_: or use CPP
10:35:11 <carter> many libs in haskell use CPP to support a wider version range
10:36:15 <humanoyd_> carter: Thanks, I will look into that...haven't used it before
10:36:40 <carter> humanoyd_: read any of edwardk's libs to see some CPP in action
10:36:57 <Marqin> i have once more problem with parser '<-'
10:37:00 <Marqin> http://pastebin.com/M1rdyrdP this code
10:39:13 <gdoteof> Marqin: maybe you can't do <- in a where statement?  i'm not sure but that looks wrong to me
10:39:49 <geekosaur> it's wrong, it's trying (incorrectly) to do a list comprehension without the list comprehension
10:40:39 <Marqin> geekosaur: but can I in list comprehencion use funcion head tail ?
10:40:44 <Marqin> geekosaur: on acctual head and tail
10:41:14 <geekosaur> I don't think I even understand that question
10:42:00 <geekosaur> my point is [ expression | var <- list [, var <- list ...] , filter ] is specific to list comprehensions, you can't use it "bare" like that
10:42:08 <kazagistar> Marqin: I am not even sure what you are trying to do with that code
10:42:15 <geekosaur> nor am I
10:43:24 <monochrom> you can use whatever you want as long as it has no error
10:43:24 <kazagistar> for example, rt does not appear to be defined anywhere
10:43:30 * monochrom loves tautologies!
10:43:36 <Marqin> geekosaur: i'm conctructing a list, and when adding a new element to list i need to check it (filter) with the list, befor adding
10:43:44 <StoneCypher> monochrom: tautologies are tautological
10:44:09 <monochrom> I have more tautologies at http://www.vex.net/~trebla/haskell/tautologies.html
10:44:11 <gdoteof> json parsing in haskell is hard is tautological
10:44:38 <monochrom> json parsing is hard? last time I just used aeson and it was a breeze
10:44:43 <gdoteof> 404 monochrom on that
10:44:44 <geekosaur> Marqin, is there some reason you think that should work without the [ ] around it?
10:44:50 <monochrom> oh oops
10:44:55 <Marqin> geekosaur: what do you mean?
10:45:00 <monochrom> http://www.vex.net/~trebla/humour/tautologies.html
10:45:10 <gdoteof> monochrom: its been easy until i had complex(er) datatypes to parse
10:45:13 <geekosaur> it just looks like you;re throwing random syntax around without any understanding
10:45:25 <Marqin> i understand
10:45:28 <Marqin> but syntax doesn not
10:45:32 <gdoteof> http://lpaste.net/104591  <- my current attempt/failure
10:45:58 <geekosaur> I don't think you do understand
10:46:06 <monochrom> I wrote my own FromJSON instance code and never considered the "automatic derive". I think this is why it was easy to me.
10:46:07 <geekosaur> <- is meaningful in certain specific places, this is not one of them
10:46:14 <Marqin> oh
10:46:28 <Marqin> geekosaur: i'm translating code from Prolog, maybe it's because of that
10:46:42 <geekosaur> you are trying to "evoke" list comprehensions, but list comprehensions REQUIRE the format [ expr | binding <- expr , filter ]
10:46:46 <geekosaur> the brackets are not optiona;
10:47:07 <geekosaur> there are lots of differences between lists in Prolog and Haskell, yes
10:47:22 <gdoteof> monochrom: yeah.  that's what i've been doing.  what i am having problems with is writing the instance code for a type with multiple constructors
10:47:27 <geekosaur> although this is kinda the opposite kind of problem since Prolog requires the [ ] in *more* places than Haskell does
10:47:37 <Marqin> geekosaur: but how can I in list comprehencion get that list?
10:47:39 <geekosaur> like, [H|T] vs. (x:xs)
10:47:54 <Marqin> like
10:48:22 <Marqin> [ x | x <- something , function x this_list == True]
10:48:39 <Marqin> i dont want to do this on fully conctructed list
10:48:44 <glguy> > [ () | False ]
10:48:46 <lambdabot>  can't find file: L.hs
10:48:47 <Marqin> it will be longer
10:48:57 <monochrom> this is why I disdain prolog's [H|T] syntax
10:49:06 <geekosaur> I am not even sure what you are doing there so I'm not sure I can answer that properly
10:49:14 <Marqin> as i said
10:49:16 <Marqin> [ x | x <- something , function x this_list == True]
10:49:23 <Marqin> how to do that?
10:49:31 <mmmm> do you not just replace this_list with something?
10:49:32 <geekosaur> for example, I don't even know if sqrs is producing a list or a 3-tuple
10:49:40 <kazagistar> Marqin: why dont you just do what you wrote there?
10:49:44 <mmmm> what is this_list?
10:50:01 <Marqin> mmmm: it's [ [ x | x <- something , function x this_list == True]]
10:50:07 <Marqin> mmmm: but without the x
10:50:16 <monochrom> > [ x | x <- [0,1,2], (x<2) == True]
10:50:16 <Marqin> (the last x)
10:50:18 <lambdabot>  [0,1]
10:50:21 <monochrom> works for me
10:50:40 <ion> > [ x | x <- [0,1,2], (True == True) == True ]
10:50:42 <lambdabot>  [0,1,2]
10:50:51 <geekosaur> btw if you just want to filter on a list,
10:50:55 <geekosaur> :t filter
10:50:56 <lambdabot> (a -> Bool) -> [a] -> [a]
10:51:07 <Marqin> geekosaur: but i don't want to filter on complete list
10:51:14 <Marqin> it would be time consuming
10:51:42 <Marqin> monochrom: no
10:51:58 <geekosaur> so if you're working on a particular value and not a list then you do not want a filter, just a condition. but then what do you want to happen if the condition doesn't hold?
10:52:08 <Marqin> [ x | x <- something, function_taking_element_and_list x that_current_list]
10:52:23 <Marqin> geekosaur: then i don't want that item in list
10:52:34 <kazagistar> so, you want to filter...?
10:52:48 <geekosaur> actually I think they want a guard
10:52:49 <Marqin> yest, but i want to filter while constructing list
10:52:53 <monochrom> I don't understand. define "something". define "function_taking_element_and_list". etc.
10:53:17 <geekosaur> solve2' ... | condition = [result] | otherwise = []
10:53:22 <kazagistar> Marqin: I think you are missing how lazyness makes those things the same
10:53:23 <Marqin> monochrom: function_taking_element_and_list takes a square and list of squares and checks if it's not colliding
10:53:33 <monochrom> that is not a definition
10:53:36 <tremon> Marqin: all of Haskell is "constructing" lists, there are few places where a list is fully constructed
10:53:57 <geekosaur> and then solve2 concatenates those. or, probably more clearly in the end, accumulate a list and produce xs for condition fail and value:xs on succeed
10:53:59 <Marqin> i wan't to produce a list of squares that have certain conditions and are not colliding (that function)
10:54:23 <augur> geekosaur, monochrom: it sounds like marqin wants to incrementally build a list from another list
10:54:36 <geekosaur> yes, I'm getting that
10:54:39 <kazagistar> Marqin: why do you think filter will be more time consuming?
10:54:40 <augur> geekosaur, monochrom: and test something against the accumulated list before adding a new element
10:54:45 <geekosaur> I'm not getting enough details to suggest the right way to do it
10:55:02 <geekosaur> I just know list comps are not the right tool
10:55:25 <augur> geekosaur, monochrom: as in:   build x acc = if p x then goNext (x:acc) else goNext acc
10:55:29 <augur> or something, you know?
10:55:30 <geekosaur> unless it can be compressed into a single comprehension producing the whole list, not used on every potential item in it
10:55:44 <geekosaur> yes, that is what I meant when I suggested a guard
10:56:01 <augur> geekosaur: its not quite a guard since it needs to refer to the current accumulation
10:56:16 <monochrom> augur, since you have a solution for Marqin, why are you telling me but not Marqin?
10:56:33 <geekosaur> that too :)
10:58:11 <augur> monochrom: im not saying i have a solution, im just saying i think thats the intention :p
10:58:35 <augur> you were talking to Marqin longer and probably know the goals more so than i do, i was just trying to tease out one particular sticking point
10:59:26 * hackagebot shelltestrunner 1.3.3 - A tool for testing command-line programs.  http://hackage.haskell.org/package/shelltestrunner-1.3.3 (SimonMichael)
10:59:28 * hackagebot apiary 0.8.0.0 - Simple web framework inspired by scotty.  http://hackage.haskell.org/package/apiary-0.8.0.0 (HirotomoMoriwaki)
10:59:30 * hackagebot apiary-cookie 0.8.0.0 - Cookie support for apiary web framework.  http://hackage.haskell.org/package/apiary-cookie-0.8.0.0 (HirotomoMoriwaki)
10:59:32 * hackagebot apiary-clientsession 0.8.0.0 - clientsession support for apiary web framework.  http://hackage.haskell.org/package/apiary-clientsession-0.8.0.0 (HirotomoMoriwaki)
10:59:34 * hackagebot apiary-authenticate 0.8.0.0 - authenticate support for apiary web framework.  http://hackage.haskell.org/package/apiary-authenticate-0.8.0.0 (HirotomoMoriwaki)
10:59:48 <yitz> gdoteof: http://lpaste.net/104591
11:00:25 <monochrom> how do you know the intention?
11:00:47 <augur> Marqin: if your goal is to transform a list of numbers xs into a list sqrs of squares-without-certain-collisions
11:00:58 <augur> Marqin: then you might want to do something like this:
11:01:58 <augur> makeSqrs xs = go xs [] where go [] acc = acc ; go (x:xs) acc = if p x acc then go xs acc else go xs (sqr x : acc)
11:03:34 <Marqin> augur: thanks
11:03:35 <kazagistar> something vaugely like this, augur/Marqin? http://lpaste.net/104599
11:03:38 <Marqin> i'll like like in this
11:04:26 * hackagebot apiary-persistent 0.8.0.0 - persistent support for apiary web framework.  http://hackage.haskell.org/package/apiary-persistent-0.8.0.0 (HirotomoMoriwaki)
11:04:28 * hackagebot apiary-websockets 0.8.0.0 - websockets supper for apiary web framework.  http://hackage.haskell.org/package/apiary-websockets-0.8.0.0 (HirotomoMoriwaki)
11:04:30 * hackagebot apiary-logger 0.8.0.0 - fast-logger support for apiary web framework.  http://hackage.haskell.org/package/apiary-logger-0.8.0.0 (HirotomoMoriwaki)
11:04:31 <kazagistar> (oopsed the first line a bit, probably more)
11:04:48 <augur> Marqin: a simple example would be nub, which removes duplicates from a list
11:05:57 <augur> Marqin: nub [] = []   ;   nub (x:xs) = let  rec = nub xs  in  if elem x rec then rec else x:rec
11:07:43 <Marqin> kazagistar: sqrs gives list
11:07:52 <Marqin> but seems promising
11:08:39 <gdoteof> yitz: thanks.  fwiw, this is what i was trying.. http://lpaste.net/104604
11:08:52 <Marqin> hm
11:09:07 <Marqin> it's not
11:09:41 <joebobjoe> If I flatMap a trampoline value that represents a complete computation, should I just go ahead and apply the the flatMapped function in flatMap?
11:10:36 <Marqin> kazagistar, augur: http://lpaste.net/4826769648374513664 something like that, but what with "<-"?
11:10:43 <Marqin> i've seen <- outside [] and it was working
11:10:53 <joebobjoe> In Scala, why don't they just return `f(x)` here? https://github.com/scala/scala/blob/v2.11.1/src/library/scala/util/control/TailCalls.scala#L55
11:10:56 <augur> Marqin: no, that doesnt work
11:11:03 <monochrom> yes, but that <- is inside do.
11:11:14 <Marqin> oh
11:11:15 <augur> Marqin: i feel you're jumping ahead of yourself
11:11:23 <augur> Marqin: it sounds like you're not familiar with haskell
11:11:35 <augur> perhaps you should read LYAH first, before trying to do this?
11:11:43 <Marqin> i;ve read
11:12:04 <augur> Marqin: youve read, but you havent understood
11:12:12 <Marqin> i have also that book from Bird
11:14:27 * hackagebot heist 0.13.1.1 - An Haskell template system supporting both HTML5 and XML.  http://hackage.haskell.org/package/heist-0.13.1.1 (DougBeardsley)
11:19:28 * hackagebot Spock 0.5.0.0 - Another Haskell web framework for rapid development  http://hackage.haskell.org/package/Spock-0.5.0.0 (AlexanderThiemann)
11:19:30 * hackagebot Spock-auth 0.2.0.0 - Provides authentification helpers for Spock  http://hackage.haskell.org/package/Spock-auth-0.2.0.0 (AlexanderThiemann)
11:19:32 * hackagebot Spock-worker 0.1.0.4 - Background workers for Spock  http://hackage.haskell.org/package/Spock-worker-0.1.0.4 (AlexanderThiemann)
11:20:25 <pavonia> Say I have two big values of an AST type and want to find all places within the structres that differ from each other. Do you have any ideas how (or if) that could be done?
11:21:05 <mmmm> Do they have the same structure?
11:21:39 <pavonia> Well, mostly yes, but some subterms are different
11:22:08 <pavonia> The first problem here is how to represent the result of that comparison
11:23:57 <pavonia> Maybe zippers could be a help
11:24:23 <kazagistar> pavonia: I guess you would want some kind of differencing structure that mirrors the AST structure
11:25:58 <pavonia> Yeah, but ideally one that either can be generated easily or can be used for any type
11:27:31 <kazagistar> pavonia: not sure that is reasonable. however, if you AST's structure is simple enough, then the diff should be simple too
11:28:27 <pavonia> It consists of a lot of different data types
11:28:27 <gdoteof> yitz, that isn't type checking http://lpaste.net/104606
11:30:43 <kazagistar> pavonia: could you make it possible to translate the well-typed tree into a less-well-typed but simpler tree that is easier to manipulate programatically?
11:31:54 <pavonia> kazagistar: No, I don't want to touch the existing types. But defining another would be possible
11:33:24 <pavonia> Looking at gdiff now, which seems be do what I want
11:39:28 <gdoteof> pavonia: before you were suggesting <|> ... something like this: http://lpaste.net/104606 ?
11:39:30 * hackagebot libnotify 0.1.1.0 - Bindings to libnotify library  http://hackage.haskell.org/package/libnotify-0.1.1.0 (MatveyAksenov)
11:42:39 <pavonia> gdoteof: Whats the type of (o .:? "model_name")?
11:43:58 <gdoteof> Maybe String
11:44:48 <pavonia> Okay, you can't apply "parseCreateSession <$>" to a value then
11:46:32 <gdoteof> i'm confused.  CreateSession is applied to ( .:? "model_name")
11:47:17 <pavonia> Yes, but then you apply that value (which isn't a function) to o .: "new_session"
11:47:35 <pavonia> :t (<$>)
11:47:36 <lambdabot> Functor f => (a -> b) -> f a -> f b
11:48:11 <m09> I am unsure how to proceed to parse something with the HXT library. The existing function calls listA to gather children of an element and I'd like to augment this list if a certain attribute is present at some point (it indicates an external source that contains more children). Here it is the source element. Is there a way to do that so that all my elements are parsed in a consistent manner? Here is the
11:48:13 <m09> code http://lpaste.net/104607
11:54:13 <BeardedCoder> Would compiling with -threaded but without +RTS and -N cause an application to be unstable (OSX 7.6.3)? Trying to figure out why I'm getting segfaults and malloc errors. It appears stable if I remove -threaded or add +RTS and -N.
11:54:14 <gdoteof> pavonia: i tried to adapt what yitz suggested here: http://lpaste.net/104598  i see that i need to somehow pass an Object to the parseFunctions
11:55:26 <pavonia> parseFoo o
11:55:45 <pavonia> or rather parseFoo (Object o)
11:58:11 <gdoteof> yes but then how am I choosing parseFoo vs parseBar?
11:59:33 * hackagebot halberd 0.1.2.8 - A tool to generate missing import statements for Haskell modules.  http://hackage.haskell.org/package/halberd-0.1.2.8 (ErikHesselink)
12:00:13 <codygman-> Did my last question post and am I in #haskell? My irc client/connection is acting weird.
12:00:49 <BeardedCoder> codygman-: don't believe so
12:01:36 <pavonia> gdoteof: I don't know if there's something built-in, but you could check what fields exist in o and call the correct parser accordingly
12:04:33 * hackagebot arrow-list 0.6.1.5 - List arrows for Haskell.  http://hackage.haskell.org/package/arrow-list-0.6.1.5 (ErikHesselink)
12:08:52 <gdoteof> pavonia: what i was thinking yitz's solution was doing was attempting to do is look for the field "foo" and if found parse its value as a FooCommand
12:10:09 <pavonia> I don't think so
12:11:34 <benzrf> :t replicateM
12:11:35 <lambdabot> Monad m => Int -> m a -> m [a]
12:11:37 <benzrf> hmm
12:12:26 <benzrf> :t zoom
12:12:27 <lambdabot> (Zoom m n s t, Control.Lens.Internal.Zoom.Zoomed n ~ Control.Lens.Internal.Zoom.Zoomed m) => LensLike' (Control.Lens.Internal.Zoom.Zoomed m c) t s -> m c -> n c
12:12:43 <benzrf> woah
12:13:04 <kazagistar> ... lenses man o_O
12:13:27 <benzrf> :t execStateT
12:13:28 <lambdabot> Monad m => StateT s m a -> s -> m s
12:13:34 <enthropy> m09: I think hxt lets you use -<< instead of -<, which can let you refer to 'tsTileProperties' on the following line
12:13:47 <benzrf> @src execStateT
12:13:48 <lambdabot> Source not found. Are you on drugs?
12:13:52 <benzrf> -.-
12:13:58 <benzrf> :t runStateT
12:14:00 <lambdabot> StateT s m a -> s -> m (a, s)
12:14:03 <benzrf> oki cool
12:15:47 <m09> enthropy: I tried going on but am stuck in some other ways now. I think I'll have to learn some hxt before going on anyway. Thanks for helping.
12:28:10 <Ainieco> hello
12:29:00 <proxfox> anyone knows any memory efficient implementation of a Trie? I've tried Data.ListTrie (list-tries), Data.Trie (bytestring-trie) and all waste too much memory comparet to Data.Map. My data is a huge list of natural language words. I thought trie would waste less memory but it seems it doesn't...
12:29:00 <proxfox> Data.Trie explodes (stack space overflow).
12:29:01 <proxfox> Data.ListTrie wastes around 300MB more than Data.Map.
12:29:01 <Ainieco> is it possible to abstract ghc-options in cabal project? I mean i have duplication of ghc-options across my library and exectuables sections of cabal file which is not pleasant
12:29:36 * hackagebot snap 0.13.2.6 - Top-level package for the Snap Web Framework  http://hackage.haskell.org/package/snap-0.13.2.6 (DougBeardsley)
12:29:46 <proxfox> Data.Map uses around 400MB
12:31:21 <Tjr> Hi, I'm back.
12:31:36 <Tjr> How do I use the data command in ghci?
12:31:57 <Tjr> I always get a parse error, regardless if I say "data ..." or "let data ..."
12:32:37 <kazagistar> Tjr: the first should work, post your full line
12:32:54 <Tjr> Prelude> data ListSalad = Nested [ ListSalad ] | Atom []
12:32:54 <Tjr> <interactive>:1:0: parse error on input `data'
12:32:59 <glguy> If your GHC is old then "data' might not work in GHCi
12:33:06 <glguy> Which version are you using?
12:33:10 <Tjr> how do I find out?
12:33:25 <glguy> When you started it it said it on the first line of output
12:33:38 <Tjr> GHCi, version 6.12.3:
12:33:53 <benzrf> Tjr: dang thats old
12:33:59 <mmmm> the latest version is 7.8.2 ha
12:34:02 <glguy> That's about 4 years old
12:34:07 <Tjr> will it run on mac os x 10.5?
12:34:23 <benzrf> Tjr: also i dont think that your decl does what you think it does
12:34:41 <benzrf> Tjr: you probably just want Atom, not Atom []
12:34:49 <benzrf> [] is the wrong kind for a field
12:34:55 <allsystemsarego> Tjr, does this work? data ListSalad = Nested [ ListSalad ] | Atom [ Int ]
12:35:20 <Tjr> allsystemsarego: same parse error from ghci
12:35:37 <allsystemsarego> yeah, get a newer ghc
12:35:37 <kazagistar> Tjr: I suggest you use a file, and call GHCi with it, and use :r to reload your code when needed
12:35:49 <Tjr> I'm trying to generalize [] and  [[]] and  [[[]],[]] and so on
12:36:30 <rwbarton> you don't need the Atom constructor at all
12:37:12 <danimad> hello, I try to the Matrix.Simplex package (https://hackage.haskell.org/package/dsp-0.2.2/docs/src/Matrix-Simplex.html) but there are a couple of problem I can't figure out and wanted to ask if somebody could help me
12:37:20 <benzrf> rwbarton is right now that i think about it p:
12:37:24 <gabor> Tjr: not sure it works on 10.5
12:38:26 <gabor> Tjr: please check the release notes of GHC 7.4 (which might work on your system)
12:38:40 * Tjr is checking
12:41:39 <danimad> my first problem is that i want to take out the answer from the array but it has a Simplex (Array (Int, Int) Double) type and not a Array (Integer, Integer) a0 so i can't use the (!) function, does anybody know how i could apply the (!) function to the first type (Simplex ‚Ä¶)?
12:42:02 <Tjr> gabor: ghci 7.4 binaries require os x 10.7. Now I'm checking the next older release ...
12:43:08 <gabor> Tjr: I doubt those contain data definitions from the command line, though
12:44:12 <Tjr> ghci 7.0.1 is the most recent that will run on my system.
12:44:37 * hackagebot Spock 0.5.0.1 - Another Haskell web framework for rapid development  http://hackage.haskell.org/package/Spock-0.5.0.1 (AlexanderThiemann)
12:44:39 <augur> what is cabal and what is aeson?
12:44:47 <augur> and why are they the source of so many problems?
12:46:27 <benzrf> augur: cabal is the haskell project management tool
12:46:47 <benzrf> but it also has a subsection called 'cabal-install' which is a package manager
12:46:52 <benzrf> allegedly, anyway
12:46:59 <benzrf> aeson is a json de/serialization lib
12:47:00 <bennofs> @google cabal is not a package manager
12:47:02 <lambdabot> http://ivanmiljenovic.wordpress.com/2010/03/15/repeat-after-me-cabal-is-not-a-package-manager/
12:47:03 <lambdabot> Title: Repeat after me: ‚ÄúCabal is not a Package Manager‚Äù | ¬´Insert Name Here¬ª
12:47:06 <hpc> cabal is a build system
12:47:09 <hpc> ghc is the package manager
12:47:15 <benzrf> hpc: oh?
12:47:22 <hpc> ghc-pkg list
12:47:31 <benzrf> 03:45 < benzrf> augur: cabal is the haskell project management tool
12:47:31 <benzrf> 03:45 < benzrf> but it also has a subsection called 'cabal-install' which is a package manager
12:47:37 <benzrf> so should i say 'package installer'
12:48:00 <kazagistar> danimad: you might be able to implement IArray Simplex or something similar, or just write your own function?
12:48:23 <identity> if I wanted to take a copy of a mutable array(IOArray) before making changes to it, should I be using freeze / thaw?
12:48:28 <m09> Is there a way I can retrieve an XML element from an external file with HXC while in a do arrow block? My try (first lines, with ts') doesn't type check: http://lpaste.net/104608
12:48:45 <hpc> benzrf: read the link bennofs gave
12:48:51 <benzrf> ok
12:49:53 <augur> benzrf: indeed! hmm
12:51:37 <augur> benzrf: why does Cabal Hell exist?
12:51:51 * benzrf shrugs
12:52:18 <augur> o.o
12:52:27 <augur> what _is_ cabal hell, let me say that rather
12:52:42 <tac_> Cabal hell is dependency hell
12:52:54 <tac_> Instantiated for Cabal
12:52:55 <augur> what is dependency hell!
12:53:35 <tac_> augur: I think we just entered it together.
12:55:27 <augur> tac_: lol
12:55:42 <augur> tac_: so i take it dependency hell is an annoying regress of dependencies
12:55:44 <allsystemsarego> augur, http://en.wikipedia.org/wiki/Dependency_hell
12:56:40 <danimad> kazagistar: thanks, i will try that, i just started to learn haskell again, and wondered if there isn't somekind of inbuilt function for these kind of situations
12:56:51 <augur> ahh interesting
12:57:09 <imalsogreg> augur: Yep. Noone asked you yet if you're using sandboxes? Hell has gotten much easier to avoid due to them.
12:57:29 <augur> imalsogreg: i dont develop enough to have run into these problems
12:57:48 <augur> imalsogreg: im a casual haskeller, and what i do non-casually is mostly ground-up anyway
12:58:31 <joelteon> Does anyone here know whether you can specify a certificate bundle to TLS connections from the tls package?
12:58:38 <imalsogreg> augur: Ahh I see. Want a hand getting out of the quagmire?
12:58:49 <augur> imalsogreg: im not in a quagmire :p
12:59:00 <augur> i was just asking for clarification due to a twitter convo
12:59:39 <rwbarton> as far as I can tell "cabal hell" is any time you invoke cabal and it fails
12:59:45 <augur> so here's a possible solution to dependency hell which might be possible, thanks to dependent types and proper modules: instead of relying on versions, rely on affordances
12:59:56 <joelteon> cabal has two exit codes: 0 and cabal hell
13:00:25 <geekosaur> people keep blaming cabal for ghc
13:00:38 <geekosaur> yes, we'll all pretend cabal can somehow be changed to work around bloody ghc
13:00:41 <imalsogreg> augur: Sounds like the project called Backpack I think?
13:00:41 <allsystemsarego> ghc-pkg
13:00:57 <augur> imalsogreg: dont know backpack
13:01:01 <benzrf> hmmm
13:01:08 <benzrf> how are lenses related to comonads?
13:01:29 <augur> benzrf: they are related via the instance-of relation!
13:01:48 <benzrf> oh?
13:02:02 <kazagistar> augur: there have been attempts, but affordanes are hard to define properly
13:02:04 <augur> yes. lenses are a particular kind of comonad
13:02:12 <augur> kazagistar: not really
13:02:14 <imalsogreg> augur: I don't know much about it, but I think the idea is to get API information into the dependencies.
13:02:17 <imalsogreg> augur: http://plv.mpi-sws.org/backpack/
13:02:29 <imalsogreg> augur: Sounds like a nice idea.
13:03:34 <Tjr> Ok, so "baby.hs:1:55: Malformed instance header" means I need to capitalize "deriving(Show)".
13:03:56 <augur> imalsogreg: sounds maybe about right?
13:04:13 <augur> imalsogreg: all thats necessary is signatures, i would think
13:04:41 <augur> imalsogreg: tho probably we'd also want some specification of behavior that's expected, tho thats maybe asking a bit much
13:04:49 <kazagistar> augur: an API returns a sorted list incedentally, and another application writer notices and uses it in their implementation. Then the API author changes algorithms to one that does not result in sorted lists, and it breaks the other application. It is ugly and flawed, but such is the world we tend to live in
13:05:04 <allsystemsarego> Tjr, paste your code on lpaste
13:05:36 <Tjr> allsystemsarego: thanks, this time I found my error myself :-) I appreciate how helpful you all are.
13:05:37 <augur> kazagistar: yes, but that's not a package management error, that's a design error on the part of the application writer
13:07:21 <hcaulfield57> I need to parse some html and then print it to the console in a way that is good looking, should I use the pretty printing library included with the haskell platform, or would someone recommend a different one. I was hoping to be able to center certain parts of the text, and indent some as well, but not much beyond htat.
13:08:13 <kazagistar> augur: but if the package manager does not handle it, then users will end up with broken versions of software. Affordances do not correctly, in all cases, specify compatibility, so another mechanism is needed.
13:08:34 <kazagistar> auger: I will concede that using affordances would be a good first approximation
13:08:36 <augur> kazagistar: yes, users will end up with broken versions of software. as they should.
13:09:41 <augur> its the app designers responsibility to make sure that their program does what its supposed to do. they simply failed to do so. its not a package-manager-designer's responsibility to make up for sloppy coding
13:10:17 <Sawny> Hi, I need to convert a lot of strings to ints. How can I do this fast? Right now I'm using `read x :: Int`. Is there a faster way?
13:10:37 <kazagistar> augur: if the API software's version is used to determine dependancy, then the problem is resolved
13:10:56 <augur> kazagistar: the problem only appears to be resolved
13:11:02 <qahqah> Anyone using yesod from the freebsd hs-yesod-platform packages out there?
13:11:20 <augur> the design of the program is still wrong
13:13:02 <kazagistar> augur: I cannot fix people, nor can I force them to fix their packages, but I can make software that uses "flawed" software in a correct way anyways
13:13:15 <Teknokratsevilla> hmm
13:13:20 <augur> kazagistar: yes, but you shouldnt. :P
13:13:27 <Teknokratsevilla> best way should be the use of assertions
13:13:34 <Teknokratsevilla> preconditions
13:13:46 <Teknokratsevilla> when you import a module to check it thru
13:14:06 <kazagistar> Teknokratsevilla: maybe even... tests?
13:14:18 <augur> kazagistar: designing software to help bad programmers not seem as bad as they are is a bad idea
13:14:20 <Teknokratsevilla> not only tests
13:14:35 <augur> all you're doing is encouraging bad practices
13:14:35 <Teknokratsevilla> robustness is always better, I think
13:14:42 <Guest99711> Sawny, I'm not aware of any other method that is faster
13:15:01 <Teknokratsevilla> and it's not about bad programming
13:15:05 <Teknokratsevilla> just evolution
13:15:10 <Teknokratsevilla> all libraries evolve
13:15:15 <augur> now admittedly, what im advocating requires dependent types
13:15:18 <augur> but so be it!
13:15:37 <augur> well, dependent types or some other fancy system
13:16:48 <kazagistar> auger: even haskell has support for Dynamic and unsafePerformIO in places. If you wish to work in a perfect world with only perfect software, then you will be very lonely and get very little done
13:17:00 <augur> imalsogreg: im not sure what this thing is about ML modules not supporting separate compilation nicely
13:17:23 <augur> imalsogreg: nor the problem with recursive linking
13:17:36 <augur> kazagistar: yes, but it shouldnt
13:18:32 <augur> tho i understand the temporary necessity of such things, we dont encourage their usage
13:18:39 <augur> we actively DISCOURAGE it, in fact
13:19:46 <kazagistar> auger: thats fine. make the default method of dependancy resolution be affordances, with versioned fallback for when it inevitably fails
13:19:47 <imalsogreg> augur: Does ML do bad at separate compilation? I don't know.
13:19:48 <augur> whereas you're actively encouraging bad design practices by suggesting package management should be designed to make it easy for people to depend on incidental properties of other libraries
13:19:57 <kazagistar> *for those cases where it fails
13:20:08 <augur> imalsogreg: i dont know, but the backpack slides claims it does
13:20:44 <augur> kazagistar: but this is the point, right -- with affordances, version-reference is unnecessary
13:21:14 <augur> kazagistar: you can just pick the most recent version that satisfies the affordance spec
13:22:11 <kazagistar> auger: except in the cases where package developers make mistakes, and you need to have functioning software until the mistake is fixed
13:22:22 <augur> also i suspect there's probably some way to incorporate some nice versioning stuff from Sanella and Tarlecki to on-the-fly mix versions
13:22:47 <augur> kazagistar: make mistakes how?
13:25:41 <kazagistar> package A says it needs affordance B, but it really relies on implementation details of package C which implements B, but those details are not mentioned in B. Some package you have pulls A, and now, all of a sudden, because the author of C changed those details in a new version, you can't rebuild your software
13:26:23 <kazagistar> auger: you could wait for the author of package A to repair the software, but you also want to specify that you need to use the old version until then
13:26:57 <augur> i dont know what you mean by "it really relies on ..."
13:27:18 <augur> no, it doesnt really rely on. the whole point is that if you rely on X, that _is_ the affordance you rely on
13:28:11 <kazagistar> augur: as in the ordered vs unordered list case. Unless you force all software to be fully proven correct, an author can make invalid assuptions, that are true until they are false
13:29:16 <augur> kazagistar: "Unless you force all software to be fully proven correct"
13:29:17 <augur> yes.
13:29:53 <augur> but lets take the example of the sorted list thing, right
13:30:03 <kazagistar> auger: well good luck with that
13:30:20 <augur> the person writing the software expected that the library was providing sorted lists, but it didnt
13:30:34 <augur> what we could do is have as part of the signature of a module that such-and-such function yields a sorted list
13:30:46 <augur> and then if you depend on sortedness, you specify that dependency
13:31:12 <augur> and if the module doesnt tell you that the function yields a sorted list, it says no, sorry, you dont know that this list is sorted
13:31:15 <augur> so you have to ensure it yourself
13:31:45 <augur> of course thats the ideal to aim for, not the suggestion im making at present
13:31:56 <kazagistar> right, I assumed that would be possible. It is just as possible for a programmer to make an assumption incorrectly anyways, unless your entire reasoning is verified formally
13:32:27 <augur> yes, and an incorrect assumption should be fixed by the programmer who made it
13:32:57 <kazagistar> right, and until then, someone who uses that programmers package wants to be able to compile using the non-broken version
13:33:10 <augur> if the person's program relied on that function returning a sorted list, and a later version breaks this, then its THEIR responsibility to go in and add a sort
13:33:27 <augur> no, they shouldnt be allowed to.
13:33:38 <augur> they should have to fix their own broken junk
13:34:04 <jophish_> Why are all the classes in Numeric Prelude called C?
13:34:46 <augur> kazagistar: tho i guess if you're talking about yet a third person -- using the broken lib (which relies on the sortedness) -- then eh..
13:35:29 <kazagistar> auger: its not my junk though. Its his junk. He made the wrong assumption, and I am using his package. Do I have to change which package I am using (even though it was working until yesterday), and the package owner promised he will have the fix in a few weeks?
13:35:35 <augur> kazagistar: sure. in such situations i guess it makes sense. all the more reason to have verified properties :P
13:37:18 <kazagistar> auger: I prefer the softer approach of making it less pleasant, but not impossible, to do things wrong. Make people do the right thing through diplomacy instead of force
13:37:56 <augur> kazagistar: diplomacy in software design doesnt work
13:38:22 <kazagistar> haskell lets you do mutability, for example, but it is so much more pleasant to use immutable data
13:38:32 <augur> pleading for people to write better code and not be stupid doesnt work. we can either provide them with a language that lets them say what they mean, and do what they intend, or we provide them with a language that doesnt
13:38:42 <augur> and if we want to the the latter, we might as well abandon haskell and start using python
13:39:02 <augur> kazagistar: yes it lets you do mutability, but it makes you SAY that you're doing mutability
13:40:23 <kazagistar> "might as well" is a silly failure mode of reasoning. There is a sliding scale, not just extremes
13:41:52 <augur> kazagistar: theres clearly not a sliding scale here
13:42:34 <augur> the fact that dependency hell exists, and is an ever-enduring problem, is precisely the point: the diplomatic approach is a problem, not a solution
13:43:29 <monochrom> pleading for people to use better languages doesn't work either
13:43:39 <augur> monochrom: thats true, it doesnt
13:44:44 * hackagebot cabal-uninstall 0.1.5 - Uninstall cabal packages  http://hackage.haskell.org/package/cabal-uninstall-0.1.5 (JanChristiansen)
13:44:58 <imalsogreg> augur: If the enduring existence of dependency hell is a cornerstone of your argument, take a look at sandboxes :)
13:45:30 <monochrom> dependency hell does not exist in hugs
13:45:37 <kazagistar> auger: if you write a dependancy manager that has no versioning and requires code be proven correct to not break peoples software, then your dependancy manager will be unused. If you write one that provides a nice system for affordances but with a fallback path, it is much more likely to solve the cabal hell problem
13:46:12 <kazagistar> sandboxes are another excellent example of a working, partial solution
13:47:18 <augur> kazagistar: i dont think thats true, provided that its not hard to use
13:47:53 <Teknokratsevilla> it's true that there's a pythonic way of doing thing and a haskellish way of doing things....
13:47:57 <kazagistar> auger: feel free to prove me wrong
13:48:09 <glguy> jophish_: I don't know if anyone answered your question, but it's because the author of that library prefers a style where you use qualified imports for everything
13:48:12 <Teknokratsevilla> dependencies should be treated as a "function"
13:48:25 <augur> kazagistar: prove yourself right! :)
13:48:28 <Teknokratsevilla> and import not a mere bulk-loader
13:48:40 <jophish_> glguy: ah, thanks. A little weird nonetheless
13:49:02 <Teknokratsevilla> currently haskell import is exactly the same than in every other language
13:49:02 <Tjr> How do I make a "list" that doesn't require each element to be of the same type?
13:49:23 <monochrom> make a tuple
13:49:54 <kazagistar> auger: that isn't how our reality works, truth is emperical at best, not "proven" :)
13:50:03 <Tjr> how do I declare a type such that it can hold any finite n-tuple, where n is not known in advance?
13:50:03 <glguy> Tjr: make a tuple if the lists is of constant length. if it's not make a new type that can contain any of the types that you needed to add to the list and make it a list of that sum type
13:50:23 <Hodapp> kazagistar: If it's empirical, it's not really 'proven', it's just more of a good guess.
13:50:24 <augur> kazagistar: good, im sure you have a nice, published study you can provide me with to justify your modal claims :)
13:50:29 <Teknokratsevilla> kazagistar, true truth is proven or nothing  :-)
13:50:44 <glguy> Tjr: e.g. [Either Bool Int], a list that holds both Bools and Ints
13:50:58 <Tjr> hmm
13:51:08 <augur> glguy: actually its a list that holes Either Bool Int's
13:51:11 <augur> holds*
13:51:13 <augur> :P
13:51:20 <kazagistar> augur: naw, but I do have a lot of sufficiently working, existing software that most people here use all the time based on those principles
13:51:26 * Tjr thinks.
13:51:57 <augur> kazagistar: the claim you made is not a principle. you're making incoherent claimes.
13:51:58 <Teknokratsevilla> hmmm , what about [Either Anytype ] ?
13:52:26 <monochrom> please move prolonged metaphilosophy to pm
13:52:38 <Teknokratsevilla> is "import" defined as a function ?
13:52:43 <Teknokratsevilla> :t import
13:52:44 <lambdabot> parse error on input ‚Äòimport‚Äô
13:52:47 <Tjr> Teknokratsevilla: will look it up tomorrow
13:52:48 <augur> metaphilosophy!
13:52:48 <Tjr> bye
13:53:22 <Teknokratsevilla> I think haskell is able to simulate any kind of "paradigm"
13:53:37 <mjburgess> metaphilosophy?
13:53:38 <Teknokratsevilla> pretty much Lisp is able to make prolog systems
13:53:53 <kazagistar> philosophy is boring, i
13:53:58 <kazagistar> *im out
13:54:11 <Teknokratsevilla> well, best thing about philosophy is that you don't have to prove it
13:54:23 <Teknokratsevilla> but philosophy has some branches about logic
13:54:32 <Teknokratsevilla> and even "categories2
13:54:53 <Teknokratsevilla> philosophy is not only plato
13:55:37 <monochrom> [Either Anytype] does not kind-check
13:56:11 <augur> Teknokratsevilla: any language can simulate any paradigm
13:56:39 <Teknokratsevilla> I'm not telling which paradigm is better
13:56:45 <Teknokratsevilla> or the best
13:57:00 <Teknokratsevilla> but surely you can do pythonic things in haskell...
13:57:11 <Teknokratsevilla> even easier than the other way round
13:57:12 <Hodapp> You could implement Python in Haskell.
13:58:08 <Teknokratsevilla> one very nice feature that prolog has is the "dictionary" of declared functions...
13:58:15 <Hodapp> You can use any Turing-complete language to simulate any paradigm, yes. It's hardly a useful claim. It's probably one of the earliest things realized in the realm of computers... "HEY! We can PROGRAM THINGS, guys!"
13:58:47 <vanila> Hodapp, yeah, whether you can naturally embed other paradigms into a language is what's actually interesting
13:58:51 <monochrom> IMO paradigm discussions are barely better than metaphilosophical discussions
13:59:08 <Teknokratsevilla> they're quite useful indeed
13:59:12 <vanila> like you can naturally use effects, continuations and nondeterminism in haskell using monads
13:59:15 <Teknokratsevilla> since they help problems
13:59:38 <Teknokratsevilla> actually
13:59:59 <Teknokratsevilla> if a problem is not well resolved even in haskell, I wouldn't hesitate to mix several languages
14:00:10 <Teknokratsevilla> see go
14:00:13 <vanila> Teknokratsevilla, that is a cool way to do things too
14:00:23 <Teknokratsevilla> go apparently is very good for concurrency
14:00:51 <vanila> yeah it has nice concurrency primitives built in
14:01:03 <vanila> like channels
14:01:03 <Teknokratsevilla> you can either fight ( and get nothing) to try to get concurrent stuff in prolog
14:01:06 <Teknokratsevilla> or
14:01:22 <Teknokratsevilla> try to focus the concurrent part ( if possible) in some go external module
14:01:28 <vanila> I think that there are extensions to prolog which parallelize well though
14:01:34 <vanila> almost a different language, though
14:01:52 <kazagistar> ... prolog seems like it would not be too terrible to make concurrent? :P
14:05:36 <mm_freak> hi there
14:05:50 <mm_freak> i've written a bunch of interface examples for fuse:  http://lpaste.net/104609
14:07:26 <aspidites> mm_freak: not to be confused with System.Fuse? (userspae filesystem in linux)
14:07:50 <mm_freak> aspidites: no, it's a stream processing library i'm currently working on
14:08:13 <mm_freak> when you reduce pipes to Producer-only, you can do a few things much nicer than pipes, and that's basically fuse
14:08:30 <mm_freak> the code is here: http://hub.darcs.net/ertes/fuse/
14:10:04 <mmmm> could you not use OverloadedLists as well as OverloadedStrings?
14:10:14 <mm_freak> mmmm: i'm still on GHC 7.6
14:10:39 <aspidites> i didn't even know about OverloadedLists
14:10:56 <mm_freak> i want to support GHC 7.6 as long as 7.8 is not in the platform
14:11:42 <mmmm> right
14:11:52 <imalsogreg> mm_freak: On producer-only pipes doing nicer things - is there somewhere I can read more about this?
14:14:01 <mm_freak> imalsogreg: i haven't written a real tutorial yet‚Ä¶  the idea is that Producer with 'next' is all you'll ever need for stream processing
14:14:06 <aspidites> or a blog post motivating fuse? that is, something that says "by getting rid of consumers, you're able to do x, and thus fuse was born"
14:14:40 <mm_freak> but when you limit yourself to Producer, then 'Producer a m r' looks just like 'FreeT ((,) a) m r'
14:14:41 <aspidites> mm_freak: producer with next -- is that unlike iterators in java or generators in python?
14:15:24 <mm_freak> aspidites: producers are first class lists with effects, and 'next' acts like an uncons operator that potentially causes effects
14:15:51 <mm_freak> it's related to iterators/generators, but not quite the same
14:16:02 <aspidites> wow. that was very...eli5 -- very concise and easonable explanation. thansk
14:16:08 <aspidites> reasonable*
14:16:15 <aspidites> and thanks*
14:17:00 <mm_freak> the nice thing is:  once you establish the connection between Producer and FreeT, all you need is FreeT
14:17:39 <aspidites> and now those examples make more sense
14:18:01 <mm_freak> look at the effectB example‚Ä¶  this one is horrible to write with pipes/pipes-group
14:18:06 <aspidites> they aren't any less confusing -- i think they were clear to begin with, but having the why i'm looking at it differently now for some reason
14:18:21 <imalsogreg> mm_freak: All I'll ever need for stream processing - does that include the bidirectional stuff in Tekmo's tutorial - a caching pipe? Or is the idea that, this sort of thing is outside the scope of what you'd want from iterators? (I'm a casual pipes-user, but not a FreeT groker)
14:18:57 <mm_freak> imalsogreg: bidirectional works with fuse
14:19:09 <dwcook> kazagistar: regarding your comment about Prolog not being too hard to make parallel: Prolog has a defined order in which it tries clauses. That'd probably be the sticking point in my mind.
14:19:14 <carter> mm_freak: why's it not on hackage? :)
14:19:41 <dwcook> kazagistar: note that some predicates do I/O, so Prolog doesn't have nice separation of I/O analogous to Haskell's.
14:19:53 <mm_freak> carter: because it's incomplete and i'd like to get as much feedback as possible before i put it there =)
14:20:02 <carter> fair
14:20:27 <aspidites> mm_freak: my prediction - on reddit in less than an hour
14:21:16 <mm_freak> on bidirectional:  it's again just FreeT over a suitable functor
14:21:42 <mm_freak> newtype RequestResponse a b r = RequestResponse (a -> (b, r))
14:21:58 <aspidites> mm_freak: i'm NOT a pipes user, so what does effectB look like in pipes?
14:23:27 <mm_freak> aspidites: most of the code would be FreeT-related wrapping (effectB) and unwrapping (consumeC)
14:23:42 <carter> mm_freak: i've a use case where i can't / don't quite want stream fusion
14:23:49 <carter> i either want "splitable streams"
14:24:01 <carter> where i can say "give the the stream before position X and the stuff after"
14:24:07 <carter> or treat it in a more map like way
14:24:10 <benzrf> :t ix
14:24:12 <lambdabot> (Ixed m, Applicative f) => Index m -> (IxValue m -> f (IxValue m)) -> m -> f m
14:25:13 <mm_freak> carter: well, fast lookups are outside of the scope of stream fusion, but splitting a stream is a different operation
14:25:15 <benzrf> :t view
14:25:16 <lambdabot> MonadReader s m => Getting a s a -> m a
14:25:25 <mm_freak> carter: take :: (Functor f, Monad m) => Int -> List f m r -> List f m (List f m r)
14:25:40 <mm_freak> this acts more like splitAt than 'take'
14:26:19 <mm_freak> to look at the prefix, ignore the result‚Ä¶  to look at the suffix, skip to the result:  skip :: (Monad m) => ListOf a m (List g m r) -> List g m r
14:27:43 <mm_freak> in other words, this is the real 'take':  \n -> void . take n
14:27:50 <mm_freak> and this is drop:  \n -> skip . take n
14:30:04 <benzrf> :t maybe
14:30:05 <lambdabot> b -> (a -> b) -> Maybe a -> b
14:33:04 <imalsogreg> mm_freak: Thanks. It's interesting :)
14:36:51 <carter> mm_freak: in my use case, i reallly want a cheap split
14:37:02 <carter> well, a cheap  take
14:37:02 <carter> erm
14:37:03 <carter> whatever
14:37:11 <carter> grouping things into contiguous regions
14:37:26 <carter> mm_freak: think a hybrid of stream fusion + delay arrays a la repa
14:38:20 <mm_freak> carter: there are two cases to consider
14:38:36 <mm_freak> first case:  everything is in memory and is a single continuous, say, vector
14:38:43 <mm_freak> ListOf (Vector a) m r
14:39:05 <mm_freak> 'take' is O(n), where n is the number of chunks
14:39:14 <mm_freak> (that actually covers both cases)
14:41:12 <HaskellNewb> Hi guys, may you help me? I need help with generating a list of numbers
14:41:25 <HaskellNewb> more specifically, a list of lists, each containing numbers
14:41:26 <carter> > [1 ... 100]
14:41:27 <lambdabot>  Could not deduce (Control.Lens.Plated.Plated c0)
14:41:27 <lambdabot>    arising from the ambiguity check for ‚Äòe_11100‚Äô
14:41:28 <lambdabot>  from the context (Control.Lens.Plated.Plated c,
14:41:28 <lambdabot>                    Control.Applicative.Applicative f,
14:41:28 <lambdabot>                    GHC.Num.Num (Control.Lens.Type.LensLike f s t c c),
14:41:35 <carter> > [1 .. 100]
14:41:37 <ion> nice
14:41:37 <lambdabot>  [1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,...
14:41:49 <HaskellNewb> those lists have to have all the possible integers between 0-9
14:42:00 <mm_freak> > permutations [1..9]
14:42:02 <lambdabot>  [[1,2,3,4,5,6,7,8,9],[2,1,3,4,5,6,7,8,9],[3,2,1,4,5,6,7,8,9],[2,3,1,4,5,6,7,...
14:42:07 <HaskellNewb> ex. for length = 3: [0, 0, 0], [0, 0, 1], etc
14:42:13 <mm_freak> oh, forgot 0 =)
14:42:21 <carter> :t combinations
14:42:22 <lambdabot> Not in scope: ‚Äòcombinations‚Äô
14:42:24 <HaskellNewb> yeah but they can be repeated
14:42:24 <carter> :t combination
14:42:25 <lambdabot> Not in scope: ‚Äòcombination‚Äô
14:42:26 <mm_freak> > replicateM 3 [0..9]
14:42:28 <lambdabot>  [[0,0,0],[0,0,1],[0,0,2],[0,0,3],[0,0,4],[0,0,5],[0,0,6],[0,0,7],[0,0,8],[0,...
14:42:42 <mm_freak> carter: looking for subsequences?
14:42:55 <mm_freak> ah, no
14:43:01 <mm_freak> you're indeed looking for replicateM =)
14:43:03 <carter> mm_freak: my use case is i want cheap splitting on fusile compositions
14:43:19 <carter> repa does it via delayed arrays
14:43:37 <carter> which are like "order oblvious mondadic actions"
14:43:40 <carter> well, applicative i guess
14:44:17 <mm_freak> carter: if your regions are regular, then repa is the answer
14:44:28 <carter> mm_freak: welll, i'm not using repa, remember :)
14:44:33 <carter> @google numerical-core
14:44:34 <lambdabot> https://github.com/wellposed/numerical-core
14:44:35 <carter> :)
14:44:45 <mm_freak> ah
14:44:46 <carter> so i may copy ideas from there
14:44:56 <carter> but  i also allow mutable arrays and such fun
14:45:05 <carter> and nested array computations
14:45:18 <mm_freak> well, i always look at repa's delayed arrays is a store comonad without the store comonad =)
14:46:06 <mm_freak> this is a useful way to look at it, because you get both the O(1) mapping and very cheap splitting
14:46:39 <mm_freak> but this is not something that fuse was made for, because there is no stream in the usual sense
14:47:19 <mm_freak> in some cases, for example when you can't predict how many chunks of what size you'll end up with, fuse can still be useful, because then we're back to actual stream processing
14:47:45 <HaskellNewb>  okay, that replicateM is something good, but I also want the sequence to be ascending or equal... filter is one option, but not efficient
14:47:51 <carter> @google store comonad
14:47:52 <lambdabot> http://stackoverflow.com/questions/8766246/what-is-the-store-comonad
14:47:52 <lambdabot> Title: haskell - What is the Store comonad? - Stack Overflow
14:48:04 <HaskellNewb> and I wanted to do that with normal functions, not built-in :(
14:48:09 <HaskellNewb> and was looking for ideas how to do that
14:48:21 <HaskellNewb> i mean not libraries*
14:48:30 <carter> HaskellNewb: you could read the source :)
14:48:36 <mm_freak> carter: this is a delayed array:  type Array = (->)
14:48:37 <carter> or write a bigole list comprehension
14:48:51 <mm_freak> or wrapped:  data Array ix a = Array (ix -> a)
14:48:58 <carter> mm_freak: yeah
14:49:05 <mm_freak> and this is the family of store comonads:  data Store ix a = Store (ix -> a) ix
14:49:23 <carter> latter ix being a bound / shape?
14:49:30 <mm_freak> just an index
14:49:54 <mm_freak> my favorite example:  let Picture = Store (V2 Int)
14:49:59 <mm_freak> it's a picture with a cursor
14:51:00 <mm_freak> 'extract' gets the pixel at the cursor, and 'extend' turns a single-pixel operation (Picture a -> a) to a picture operation (Picture a -> Picture a)
14:51:59 <carter> i'll have to think about that
14:52:08 <mm_freak> let blur :: Picture RGB -> RGB  -- return the average color of a small neighbourhood of the pixel at the cursor
14:52:14 <mm_freak> extend blur  -- blur the whole image
14:53:16 <mm_freak> fuse uses a comonad, too, but a rather simple one =)
14:53:17 <carter> hrmmm
14:53:21 <mm_freak> data Pair a b = Pair !a b
14:53:34 <Profpatsch> Ohai. I just started my first Haskell project, it‚Äôs going to be a simple parser for onsong files.
14:53:36 <carter> whats the second arg for sthe store do?
14:53:41 <carter> notion of cursor?
14:53:49 <mm_freak> carter: the current position
14:53:53 <carter> ok
14:54:03 <mm_freak> example value:  Store myImage (V2 5 5)
14:54:12 <carter> ok
14:54:23 <mm_freak> it's the myImage function (picture) and the cursor is located at (5, 5)
14:54:25 <carter> so its a function with a nominal current positon
14:54:26 <carter> ok
14:54:50 <Profpatsch> So, first question (of many, I guess): type Chord = [ base :: <aRangefromAtoG> ]
14:54:56 <Profpatsch> s/[/{/
14:55:10 <carter> mm_freak: ... this actually is really really easy to support for my lib
14:55:13 <carter> sweet
14:55:16 <Profpatsch> How do I specify that base should be one of A,B,C,D,E,F,G?
14:55:55 <mm_freak> Profpatsch: you could use a type for base that allows exactly A..G
14:56:09 <mm_freak> data Note = A | B | C | D | E | F | G
14:56:14 <Omneh> hey there, I'm attempting to get syntastic working with haskell files, and hdevtools isn't searching my local sandboxed cabal for libraries it seems like.  How do I tell hdevtools to look there?
14:56:43 <Profpatsch> Hm, I‚Äôm still too much thinking badly typing languages terms I guess.
14:56:56 <Profpatsch> But of course.
14:57:14 <Omneh> also, hdevtools reports: "Use -v to see a list of the files searched for." and then "Unknown flag: -v" what's up with that?
14:58:23 <mm_freak> Profpatsch: that's fine, you're going to make the transition eventually =)
14:59:12 <geekosaur> hdevtools is passing on a message from ghc
14:59:37 <geekosaur> but hdevtools itself doesn't have that option (it may have an option to pass another option to ghc)
15:00:35 <phaazon> hey, do you know the name of the package that enables you te represent references as a graph?
15:00:40 <aspidites> sorry to be all lmgtfy like, but theres this -> http://lpaste.net/94999
15:01:12 <Omneh> I see geekosaur that makes sense.  So I guess the real question is, how do I tell hdevtools to tell ghc to search my local cabal sandbox, and perhaps also tell ghc to -v
15:01:27 <aspidites> ah...figured links gave titles. sorry. its a function to find the sandbox and pass appropriate ghc commands to hdevtools
15:01:29 <Omneh> aspidites, thanks so much
15:01:41 <Omneh> sorry for being a newb at this.
15:01:58 <mmmm> http://lpaste.net/94999
15:02:00 <aspidites> or this -> http://stackoverflow.com/questions/20391639/how-to-use-hdevtools-with-cabal-dev
15:02:02 <mmmm> Omneh: First google result
15:02:19 <aspidites> mmmm: thats the one i linked :P
15:02:19 <mm_freak> lmdtfy
15:02:21 <Omneh> mmmm, I was googling for the wrong thing.
15:02:21 <mmmm> woops aspidites got there first :)
15:02:37 <aspidites> and hince my lmgtfy reference lol
15:02:41 <mm_freak> @duckduckgo test
15:02:41 <lambdabot> Unknown command, try @list
15:02:59 <aspidites> to be fair though, i remembered seeing an issue related to that which is why i googled. that result isn't actually what i was looking for
15:03:07 <aspidites> @ddg test
15:03:07 <lambdabot> Maybe you meant: msg id do bug
15:03:59 <aspidites> found what i was looking for -> https://github.com/bitc/hdevtools/pull/30
15:04:08 <aspidites> in short, cabal support is coming to hdevtools
15:04:18 <aspidites> or you can manually patch it if you're impatient or dairing
15:04:32 <mm_freak> https://lmddgtfy.net/?q=test
15:04:34 <mm_freak> lol
15:04:48 <Omneh> I didn't know DDG had a version of that
15:05:15 <Omneh> I haven't used DDG in months, is it better than it was?
15:05:48 <Omneh> anyway, thanks for the help aspidites and mmmm
15:05:52 <mm_freak> Omneh: it's good for technical things, because it knows about different meanings of the same word and also understands official sites
15:06:37 <mmmm> does it direct you to the hackage page for the latest version?
15:07:45 <mm_freak> mmmm: i usually go to the hackage page directly using a parametric bookmark
15:08:12 <aspidites> mm_freak: lmddgtfy - my hero -- being a *secure* smart ass :P
15:08:23 <mm_freak> hehe
15:09:43 <aspidites> welcome Omneh
15:10:00 <aspidites> ddg did just get a facelift. i'll admit i can't really tell a difference (except on mobile)
15:10:01 <HaskellNewb> guys,  I have a list of lists, each containing numbers. I want to add something to the beginning of every list - a number between 0 and 99. and I also need all the possibilities, not just one ;<
15:10:22 <HaskellNewb> hm, I think I know how to do that, don't answer me ;D
15:19:58 <mcstar> well, if your value has the type [[Int]] then you cant unfortunately add an Int to the front of every list, since lists are homogenous
15:21:30 <benzrf> mcstar: wut?
15:21:35 <benzrf> map (1:) tehlist
15:22:10 <mcstar> benzrf: let lst = [[1,2],[3,4]] in 5 : lst -- does not work
15:22:21 <benzrf> mcstar: well of course not
15:22:33 <benzrf> > let lst = [[1,2],[3,4]] in map (5:) lst
15:22:34 <lambdabot>  [[5,1,2],[5,3,4]]
15:22:35 <mcstar> but he wanted to put an Int in front of every list
15:22:44 <benzrf> mcstar: yes, thats what i just did
15:22:47 <ion> mcstar: sigh
15:22:51 <zwer> > map ((66:)) [[1,2,3],[4,5,6]]
15:22:53 <lambdabot>  [[66,1,2,3],[66,4,5,6]]
15:23:06 <mcstar> ion gets it
15:23:16 <zwer> > map ((66,)) [[1,2,3],[4,5,6]]  - or maybe this
15:23:17 <lambdabot>  Not in scope: ‚Äòthis‚Äô
15:23:21 <zwer> > map ((66,)) [[1,2,3],[4,5,6]]  -- or maybe this
15:23:23 <lambdabot>  [(66,[1,2,3]),(66,[4,5,6])]
15:28:31 <shawn_> how to parse a floating point number based on locality (',' vs '.')
15:29:55 * hackagebot tidal 0.4 - Pattern language for improvised music  http://hackage.haskell.org/package/tidal-0.4 (AlexMcLean)
15:34:46 <aspidites> so in other words he doesn't want to prepend each list but index them instead
15:38:53 <HaskellNewb> guys, can I add a conditional with "do"?
15:39:06 <HaskellNewb> i have a "do" that has something like this: x <- [0..9]
15:39:12 <HaskellNewb> but i'd like to say that this x has to meet certain condition
15:39:51 <sipa> what will you do otherwise?
15:40:07 <HaskellNewb> ignore this x and go on to the next one
15:40:15 <sipa> filter it before binging it to x
15:40:30 <HaskellNewb> that's a very good idea :) thank you, sir
15:40:35 <pavonia> :t guard
15:40:37 <lambdabot> MonadPlus m => Bool -> m ()
15:41:03 <sipa> :t filter
15:41:04 <lambdabot> (a -> Bool) -> [a] -> [a]
15:41:22 <sipa> x <- filter (\x -> condition on x) [0..9]
15:41:33 <pavonia> > do { x <- [1..9]; guard (odd x); return x }
15:41:35 <lambdabot>  [1,3,5,7,9]
15:41:42 <sipa> or x <- [x <- [0..9] | condition on x]
15:41:46 <HaskellNewb> yeah yeah, thank you guys, I got it now ;)
15:43:14 <mcstar> sipa: the syntax is , not | right?
15:43:54 <pavonia> What?
15:44:04 <mcstar> , before the condition
15:44:12 <pavonia> Oh, no
15:44:32 <pavonia> comma is to separate conditions
15:44:34 <mcstar> > [x <- [0..9] | x > 0 ]
15:44:35 <lambdabot>  <hint>:1:4: parse error on input ‚Äò<-‚Äô
15:44:40 <mcstar> > [x | x <- [0..9] , x > 0 ]
15:44:42 <lambdabot>  [1,2,3,4,5,6,7,8,9]
15:44:57 <gdoteof> i am trying to profile a yesod app.  i need to reinstall libraries with profiling.  when i originally installed ghc and haskell platform, i didn't do anything profiling specific
15:45:09 <gdoteof> do i need to recompile / reinstall with profiling somehow?
15:45:09 <HaskellNewb> I'll just do the [0..9] list delivered by a function, because it will work better than a function
15:45:12 <HaskellNewb> than a filter*
15:45:20 <gdoteof> i fllowed these instructions: https://gist.github.com/wting/8498731
15:45:30 <gdoteof> (choice 1)
15:49:22 <awestroke> gdoteof: install haskell-platform-prof too
15:55:36 <jophish_> Are the sample types for fromInteger correct here: http://www.haskell.org/ghc/docs/7.8.2/html/users_guide/syntax-extns.html
15:55:54 <jophish_> Surely the 3rd one should be Num a => Integer -> a
15:57:11 <glguy> jophish_: That section is about rebindable syntax
15:57:33 <glguy> not the normal fromInteger
15:57:37 <jophish_> glguy: I'm not convinced that Num a => a -> Integer could be valid though
15:58:11 <shawn_> hiw to parse "10,2" to a Float? is there a built in function?
15:58:18 <Kaidelong> throwE x >>= \_ -> foo  will cause x to be thrown, right?
15:58:23 <Kaidelong> even though I'm ignoring the result
15:58:23 <hpc> > read "10.2" :: Double
15:58:25 <lambdabot>  10.2
15:58:36 <Kaidelong> that's how I hope it behaves anyway
15:58:53 <shawn_> hpc note the comma decimal separator
15:59:04 <Kaidelong> I'm using this to implement a "modifyInputBuffer" operation that fails on illegal input buffers
15:59:29 <Marqin> hmm, is there some mix function buildin haskell? like in this example: http://pastebin.com/raw.php?i=D9cmdxb7
15:59:38 <Marqin> or have it to write by myself
15:59:42 <Kaidelong> do { x <- readInputBuffer ib ; unsafeModifyInputBuffer (const writeMe) ib }
16:00:10 <hpc> shawn_: don't use a comma ;)
16:00:19 <Kaidelong> readInputBuffer should fail on an illegal/expired input buffer
16:00:29 <Kaidelong> unsafeModifyInputBuffer may not
16:00:39 <hpc> (either change your input, or just map over the string to change ',' to '.')
16:01:13 <Kaidelong> modifyInputBuffer/setInputBuffer should fail
16:01:41 <Kaidelong> but they're implemented in terms of unsafeSetInputBuffer
16:02:05 <Kaidelong> (not unsafeModify, typo)
16:02:13 <Kaidelong> this is using the ExceptT monad transformer btw
16:04:35 <HaskellNewb> haha guys, I did what I wanted :) I generate all possible sequences of digits that are ascending, and the last element is between 0-99
16:04:50 <HaskellNewb> functional programming blows your mind
16:05:36 <HaskellNewb> btw when I use the "do" notation and x<- [something], this function returns a list of every possibility?
16:06:18 <HaskellNewb> so it's like list comprehension?
16:06:44 <mm_freak> HaskellNewb: it /is/ list comprehension
16:06:53 <benzrf> well
16:06:57 <benzrf> it's more like vice versa
16:07:02 <benzrf> list comps are like do-notation
16:07:07 <HaskellNewb> okay guys. I'm just an ewb yet ;D
16:07:11 <HaskellNewb> newb*
16:07:50 <mm_freak> HaskellNewb: list comprehensions have a corresponding monadic (or MonadPlusic) form
16:08:02 <HaskellNewb> I don't know Monads yet
16:08:32 <benzrf> HaskellNewb: dw about it
16:08:37 <benzrf> HaskellNewb: do you know functors?
16:08:56 <HaskellNewb> well, like Prolog functors? :D
16:09:08 <mm_freak> HaskellNewb: list comprehensions have a corresponding monadic (or MonadPlusic) form
16:09:14 <zwer> HaskellNewb you already know how list monad works
16:09:25 <gdoteof> awestroke: where can i get that, i only see ubuntu packages
16:09:37 <mm_freak> [ x + y | x <- xs, y <- ys ] = do x <- xs; y <- ys; return (x + y)
16:09:54 <glguy> jophish_: http://lpaste.net/104618
16:09:55 <mm_freak> and every predicate becomes a guard
16:09:59 <zwer> > sequence [[1,2,3],[4,5,6]]
16:10:01 <lambdabot>  [[1,4],[1,5],[1,6],[2,4],[2,5],[2,6],[3,4],[3,5],[3,6]]
16:10:03 <HaskellNewb> but I know that there is a lot more in Monads than this...
16:10:07 <zwer> :t sequence
16:10:08 <lambdabot> Monad m => [m a] -> m [a]
16:10:53 <mm_freak> HaskellNewb: Monad is just an API with a bunch of laws
16:11:02 <mm_freak> do not think about monads too much
16:11:06 <HaskellNewb> some day I will be as pro as you guys, and I'll sit here and help the new people :D
16:11:22 <awestroke> gdoteof: haskell-platform-prof is an ubuntu package
16:11:27 <dwcook> HaskellNewb: would be interesting if you kept the same nick between now and then
16:11:30 <awestroke> gdoteof: sudo apt-get install haskell-platform-prof
16:11:47 <mm_freak> no, they'll transform into HaskellPro =)
16:11:49 <HaskellNewb> dwcook: some day I will have to change it :)
16:12:10 <HaskellNewb> thank you guys and good night ;)
16:12:19 <dwcook> I'm okay with misleading nicks, I'm not very good at cooking after all
16:12:31 <HaskellNewb> next time I'll use a normal nickname, sorry
16:12:36 <gdoteof> awestroke: i am not using the ubuntu haskell-platform
16:12:42 <dwcook> HaskellNewb: don't worry about it, I was just joking with you
16:12:47 <carter> "/nick $realnick"
16:13:23 <gdoteof> awestroke: i am using http://lambda.haskell.org/platform/download/2013.2.0.0/haskell-platform-2013.2.0.0.tar.gz
16:13:37 <Kaidelong> list monad is prolog
16:13:40 <gdoteof> with https://www.haskell.org/ghc/dist/7.6.3/ghc-7.6.3-x86_64-unknown-linux.tar.bz2
16:13:42 <benzrf> gdoteof: but it is 2013
16:13:44 <benzrf> *2014
16:13:50 <Kaidelong> so if you know prolog, you know the list monad
16:14:26 <gdoteof> benzrf: well.  i am open to upgrading my haskell-platform but that doesn't cure my core problem of not having haskell-platform-prof
16:14:27 <hpc> Kaidelong: what's cut in []?
16:14:55 <gdoteof> the ghc in haskell-platform from the ubuntu repos is too old
16:15:06 <shawn_> is it hard to write portable GUI programs in haskell?
16:15:17 <mm_freak> how about saying "list type" rather than "list monad"?
16:15:20 <hpc> shawn_: it's hard to write portable gui programs ;)
16:16:18 <gdoteof> benzrf: maybe you are trolling me :P  http://lambda.haskell.org/platform/download/
16:16:24 <Kaidelong> hpc: Prolog is more complicated than that, but I actually wonder if you can do something like cut with things like take and filter
16:16:31 <shawn_> is it harder in haskell than, say, java?
16:16:45 <Kaidelong> however my point was that if you are already used to prolog you know how the list monad works already
16:17:01 <geekosaur> gdoteof, the point is more than the platform release got massively delayed by ghc 7.8, needed to fix some OS X issues
16:17:05 <geekosaur> among other things
16:17:32 <geekosaur> supposed to come out later this month, at least I have not heard of any problems --- but I have also not seen prerelease packages up yet
16:18:13 <Kaidelong> @ty takeWhile . isJust
16:18:14 <lambdabot>     Couldn't match type ‚ÄòBool‚Äô with ‚Äòa -> Bool‚Äô
16:18:14 <lambdabot>     Expected type: Maybe a1 -> a -> Bool
16:18:14 <lambdabot>       Actual type: Maybe a1 -> Bool
16:18:18 <gdoteof> geekosaur: hmm.  i am not that worried about it.. i am just trying to figure out how to get "haskell-platform-prof" so i can profile this yesod app
16:18:29 <Kaidelong> @ty takeWhile
16:18:30 <lambdabot> (a -> Bool) -> [a] -> [a]
16:18:34 <geekosaur> that name sounds like someone's OS package
16:18:40 <Kaidelong> @ty isJust
16:18:41 <lambdabot> Maybe a -> Bool
16:18:52 <geekosaur> if you built via cabal, you probably have to rebuild everything after enabling profiling
16:19:10 <Kaidelong> why is that a type error? Maybe a -> Bool should unify with a -> Bool just fine?
16:19:15 <Kaidelong> oh
16:19:25 <gdoteof> geekosaur: that's what i am trying to do, but i can't.. next goal: base (user goal)
16:19:25 <Kaidelong> @ty takeWhile isJust
16:19:26 <lambdabot> [Maybe a] -> [Maybe a]
16:19:40 <awestroke> @ty catMaybes
16:19:40 <Kaidelong> hpc: you could probably implement cut using some variation of that ^
16:19:41 <lambdabot> [Maybe a] -> [a]
16:19:49 <gdoteof> er.. could not resolve dependencies base when i try `cabal install --reinstall world`
16:19:53 <Kaidelong> awestroke: not the right behavior
16:20:09 <awestroke> gdoteof: base is in ghc
16:20:24 <gdoteof> awestroke: i understand that
16:20:27 <geekosaur> er
16:20:36 <geekosaur> how did you install ghc?
16:20:58 <geekosaur> the official packages should include profiling; OS packages generally don't
16:21:10 <gdoteof> geekosaur: https://gist.github.com/wting/8498731 step 1
16:21:12 <gdoteof> er, option 1
16:21:21 <gdoteof> geekosaur: i didn't install from OS packages
16:21:48 <geekosaur> mrrr. I would expect that to have included profiling bootlibs
16:22:33 <awestroke> gdoteof: do you still have your cabal packages from the old ghc version?
16:23:05 <mm_freak> i think the term "list monad" is a horrible convention
16:23:08 <mm_freak> just like "IO monad"
16:23:20 <dwcook> I think it's acceptable when discussing the appropriate instance, otherwise not.
16:23:28 <mm_freak> yeah
16:23:46 <glguy> In that context they were specifically talking about the backtracking behavior
16:24:04 <mm_freak> but then [] has two conflicting Applicative instances, and i'm pretty sure that we can find an alternative monad instance
16:24:11 <mm_freak> so "the" list monad is just as wrong
16:24:42 <gdoteof> awestroke: mm i might/probably do?
16:24:44 <jophish_> glguy: Sorry, that was a valid sig. You were right I forgot that Integer was an instance of Num!
16:24:47 <gdoteof> http://lpaste.net/104619
16:24:48 <mm_freak> if anything we should probably say "the backtracking monad"
16:25:14 <ReinH> There is a lot more to monads. A lot more. and those learnings are available. They are not necessary to
16:25:17 <dwcook> Does ZipList even have a corresponding Monad instance that's different from []?
16:25:29 <ReinH> ... To use do notation.
16:25:30 <mm_freak> not only is it not the only possible Monad instance of [], [] is also not the only type that has backtracking
16:25:55 <mm_freak> so "list monad" could just as well refer to something other than []
16:25:59 <mm_freak> dwcook: yes
16:26:01 <awestroke> gdoteof: I don't know how do force cabal to reinstall everything, I'd just nuke cabal myself. Perhaps someone else in here have experience with taming cabal
16:26:29 <ReinH> Adjunctions are useful. you don't need to understand them either to use Haskell
16:26:39 <gdoteof> also: http://lpaste.net/104620
16:26:41 <mm_freak> dwcook: it's the zipping monad, but i'm not sure if [] is a valid instance of it‚Ä¶  it may only be allowed on infinite lists wrt laws
16:27:05 <mm_freak> (do x <- [1,2,3]; y <- [4,5,6]; return (x + y)) = [5,7,9]
16:27:35 <ReinH> mm_freak: how do you write join?
16:28:04 <mm_freak> ReinH: diagonalization
16:28:17 <gdoteof> awestroke: just kill ~/.cabal
16:28:18 <gdoteof> ?
16:28:22 <ReinH> mm_freak: ah
16:28:32 <mm_freak> join ["abc", "def", "ghi"] = "aei"
16:28:57 <awestroke> gdoteof: no
16:29:07 <Kaidelong> mm_freak: zipping doesn't form a monad IIRC
16:29:17 <Kaidelong> you can get applicative out of it but nothing further
16:29:18 <ReinH> mm_freak: yep. is that law abiding?
16:29:27 <mm_freak> Kaidelong: it does at least with the restriction if equal-length lists
16:29:31 <awestroke> gdoteof: kill ~/.cabal/lib and each directory in ~/.ghc/
16:29:35 <mm_freak> ReinH: for equal length lists yes
16:29:45 <ReinH> mm_freak: ah
16:30:01 <Kaidelong> mm_freak: well the haskell type system can't express that then so it's appropriate to not think about it as the "list monad" in haskell at least
16:30:15 <Kaidelong> (tuple monad?)
16:30:27 <mm_freak> Kaidelong: i agree, and i'm pretty sure that there is a simple counterproof
16:30:37 <ReinH> Neither can it express the laws
16:30:37 <mm_freak> Kaidelong: the vector zipping monad perhaps
16:30:49 <mm_freak> see the V type in 'linear'
16:31:01 <mm_freak> or any of the more specific types like V3
16:31:08 <mm_freak> they are instances of this zipping monad
16:31:25 <awestroke> tuple monad and tuple comprehension
16:31:30 <Kaidelong> ReinH: that's somewhat orthogonal, that's about incorrect code not triggering a type error, this is about correct code triggering one (or having no appropriate type)
16:31:33 <dwcook> mm_freak: maybe we should introduce codata to the language :)
16:31:46 <ReinH> Kaidelong: I see your point
16:31:47 <mm_freak> dwcook: all data is codata by default in haskell =)
16:32:00 <dwcook> Yes, I mean a distinction
16:32:33 <mm_freak> dwcook: making your fields strict is about as distinctive as you can get in haskell, without completely changing the language and all libraries
16:32:38 <ReinH> at least if the laws hold then they hold for all values
16:32:40 <Kaidelong> I think haskell 2010 can do it actually
16:32:45 <Kaidelong> because it has type level nats
16:32:54 <Kaidelong> but we'd probably call those vectors and not lists
16:33:55 <benzrf> codata?
16:34:19 <carter> awestroke: gdoteof  you never have to kill anything in ~/.cabal
16:34:20 <carter> EVER
16:34:25 <ReinH> the categorical dual of data. do try to keep up. ;)
16:34:59 <ReinH> benzrf: (I'm just joking)
16:36:29 <mm_freak> benzrf: in a total language recursion eats data and promises to always eat, corecursion produces codata and promises to always produce
16:36:52 <mm_freak> corecursive:  ones = 1 : ones
16:37:02 <mm_freak> not corecursive:  ones = ones ++ [1]
16:37:43 <benzrf> u-uh
16:37:48 <benzrf> o-ok
16:38:00 <dwcook> (The latter produces nothing at all. It diverges)
16:38:07 <benzrf> > let ones = ones ++ [1] in ones
16:38:10 <benzrf> i thot si
16:38:11 <benzrf> *so
16:38:11 <lambdabot>  mueval-core: Time limit exceeded
16:38:37 <mm_freak> benzrf: think about it this way:  if asking for the outermost constructor /provably/ /always/ gives an answer in finite time, you have corecursion
16:38:45 <mm_freak> for the whole structure that is
16:39:25 <dwcook> Na√Øve question stemming from that, does that mean we lose Turing completeness?
16:39:27 <mm_freak> the structure itself may be infinite like 'ones', but you can always go on eating it and you will never wait infinitely long for the next layer
16:39:32 <ReinH> some forms of foldr
16:39:33 <mm_freak> dwcook: yes
16:39:52 <dwcook> Is there anything valuable we'd like to express that we can't in that way?
16:40:07 <ReinH> Bottom? ;)
16:40:10 <benzrf> dwcook: yes
16:40:19 <benzrf> dwcook: oh i meant turing complete
16:40:31 <benzrf> dwcook: well, given the halting problem, that should be pretty obvious
16:40:31 <dwcook> Meh, I don't consider bottom valuable :P
16:40:34 <benzrf> shouldnt it?
16:40:48 <dwcook> benzrf: I was just making sure I was putting the pieces together correctly.
16:40:54 <carter> dwcook: mm_freak  what preclude turing completeness?
16:40:57 <benzrf> kk
16:41:18 <dwcook> So, in other words, operations over codata _must_ terminate?
16:41:31 <mm_freak> carter: well, i'm not actually sure we lose turing-completeness‚Ä¶  IO actions are first class after all
16:41:48 <carter> IO actions have nothing to do with turing completness
16:41:50 <dwcook> Hmm, that doesn't sound quite right actually‚Ä¶
16:41:59 <ReinH> dwcook: thus the ;)
16:42:13 <mm_freak> carter: they do in a sense‚Ä¶  our program is an IO action and we can translate turing machines into IO actions
16:42:29 <mm_freak> Auto is another codata type
16:42:30 <carter> .... io actions have nothing to do with turing completeness
16:42:31 <benzrf> jjjjjjjjjjjjjjjjjjj
16:42:33 <carter> they just make it easier
16:42:44 <mm_freak> carter: yes, i'm translating the problem =)
16:43:11 <dwcook> I'm not sure I need a translation of the problem so much as the theoretical basis of it
16:43:31 <mm_freak> "turing-complete" as in "every turing machine can be expressed"
16:43:39 <dwcook> Sure.
16:44:41 <dwcook> So the basic statement here is "corecursion cannot express every Turing machine"
16:44:43 <dwcook> Right?
16:45:01 <dwcook> Though I'm still confused even saying that
16:46:57 <mm_freak> well, i'm not sure exactly in what way we lose turing-completeness, since we can still express every computable program ‚Äî we just do it differently
16:47:18 <mm_freak> but IIRC turing-completeness and theorem proving don't work together, because we can prove false
16:47:34 <dwcook> It sounds like both of us are confused :)
16:47:51 <carter> dwcook: mm_freak  very smart people have explained to me that corecursive computatios can be turing complete
16:48:51 <ReinH> "I just smile and nod"
16:49:15 <calsaverini> hi
16:49:20 <carter> iterate a comonad
16:49:35 <ReinH> calsaverini: hi
16:49:40 <mm_freak> well, it's easy enough to see how turing-completeness allows a proof of false
16:49:50 <calsaverini> I'm having a problem to build an xmonad config on my notebook, can someone help?
16:49:55 <geekosaur> "but can the express co-Turing complete programs?" </babble>
16:50:13 <mm_freak> the coturing complete program express
16:50:23 <calsaverini> One of the libraries are not linking correctly
16:50:26 <mm_freak> oh, sorry
16:50:29 <mm_freak> the coturing mplete program express
16:51:06 <mm_freak> calsaverini: an error message would be useful
16:51:07 <geekosaur> calsaverini, there is #xmonad for such questions
16:51:17 <mm_freak> but yeah, #xmonad is probably a better choice
16:51:21 <geekosaur> but yes, some more information is needed
16:51:23 <calsaverini> geekosaur: nice to know, thanks!
16:51:28 <calsaverini> I'll go there
16:51:43 <calsaverini> But this seems really to be an error in my ghc installation
16:51:58 <geekosaur> so let's see the error
16:52:00 <geekosaur> @paste
16:52:00 <lambdabot> Haskell pastebin: http://lpaste.net/
16:55:48 <deweyvm> if i have a function with a constraint Convertible a b, is there a way to put in a custom function b->b in the case where b = String (or whatever)
17:05:36 <calsaverini> ghc-pkg list --global shows utf8-string-0.3.7 in the list
17:05:41 <calsaverini> ops
17:05:42 <calsaverini> sorru
17:05:50 <calsaverini> I meant to paste other text
17:06:32 <calsaverini> My error compiling xmonad.hs is described here: http://lpaste.net/104621
17:06:32 <calsaverini> It looks like an error in linking a library
17:06:34 <mm_freak> deweyvm: no straightforward way
17:07:18 <deweyvm> alright ill just make a different function for those cases, thanks
17:08:10 <pavonia> Should an Enum numbering be continuous?
17:09:42 <hcaulfield57> Does anyone know how to make buttons not expand as big as they can in gtk?
17:09:43 <carter> pavonia: no reason why it would be
17:10:05 <pavonia> Okay
17:10:29 <pavonia> hcaulfield57: It depends on the container you put them into
17:11:17 <hcaulfield57> pavonia: I have them in hbox and vbox respectively, but that doesn't seem to be looking good
17:11:30 <hcaulfield57> pavonia: What type of container *should* they be in?
17:11:49 <pavonia> You can set a requested size, but the surrounding layout container still can ignor eit
17:13:26 <pavonia> I'm looking for an example of hsc2hs' #enum command, any ideas?
17:14:11 <hcaulfield57> pavonia: How do you do that, sorry? widgetSizeRequest? I'm trying to see how to set it.
17:14:28 <hcaulfield57> Oh widgetSizeAllocate
17:14:34 <pavonia> No, widgetSizeRequest
17:14:52 <pavonia> size allocation shouldn't be done by th euser, IIRC
17:16:01 <pavonia> hcaulfield57: Sorry, it's widgetSetSizeRequest
17:18:56 <benzrf> :t while
17:18:58 <lambdabot> Not in scope: ‚Äòwhile‚Äô
17:18:59 <benzrf> :t whileM
17:19:00 <lambdabot> Not in scope: ‚ÄòwhileM‚Äô
17:19:03 <benzrf> hmm
17:20:15 <hcaulfield57> pavonia: Thanks, I'm trying to figure out how that works now haha
17:30:16 <benzrf> ughughugh
17:30:37 <augur> benzrf: hughughug
17:30:51 <benzrf> :-O
17:32:14 <benzrf> hmmmmmmmmm
17:32:27 <benzrf> is there a way to compose lenses like
17:32:50 <benzrf> the lens 'somefield' gives an index, then 'anotherfield' has an indexable
17:32:58 <benzrf> i want something liuke
17:33:08 <benzrf> 'anotherfield.ix somefield'
17:33:10 <benzrf> but actually working p:
17:37:05 <augur> benzrf: maybe ask in #haskell-lens!
17:47:12 <benzrf> :t lens
17:47:13 <lambdabot> Functor f => (s -> a) -> (s -> b -> t) -> (a -> f b) -> s -> f t
17:50:52 <sccrstud92> anyone know of any good SMS libraries?
17:54:21 <carter> sccrstud92: for texting ?
17:54:46 <sccrstud92> yeah
17:55:01 <sccrstud92> SMSlib looks good but its is for Java and .NET
17:55:10 <sccrstud92> and i didnt see any haskell bindings
17:55:22 <carter> bindings to what
17:55:35 <carter> http://smslib.org/
17:56:03 <carter> sccrstud92: .... haskell can ffi link to c codes, not jvm
17:56:17 <carter> (well, it could, but not in a way thats worht while)
17:56:26 <carter> isn't the actual sending dependent on having a gsm connection
17:56:27 <carter> ?
17:56:42 <darthdeus> guys let's say that I want to have two types, one that's      data A = B | C | D; and data E = B | C; ... and I'd like to make a function A -> E, but without having to duplicate all of the type constructors (B, C), which are shared ... can I do that somehow?
17:56:50 <sccrstud92> idk
17:56:55 <sccrstud92> idk enough about how it works
17:57:20 <byorgey> darthdeus: you can't have shared type constructors in the first place.
17:57:22 <carter> sccrstud92: so the thing is
17:57:26 <carter> theres two ways to view SMS
17:57:40 <carter> you'e running code on a device thats hooked into a telecom nework
17:57:43 <carter> *network
17:57:56 <carter> and you have device specific apis (eg ios or android mebe)
17:58:01 <carter> or you're using something like twillio
17:58:03 <carter> rihgt?
17:58:21 <byorgey> darthdeus: you could do something like   data SharedStuff = B | C;  data A = AShared SharedStuff | D;  data E = EShared SharedStuff
17:58:24 <darthdeus> byorgey: so basically if i have two structures that share some things, I should make those shared things as separate types, and put those in the type constructors?
17:58:25 <sccrstud92> carter: yeah
17:58:31 <byorgey> darthdeus: right
17:58:36 <carter> sccrstud92: whats your use case?
17:58:45 <darthdeus> that makes sense, thanks
17:59:48 <sccrstud92> cater: nothing specific yet. i just wanted to gauge capabilities. simplest case i can think of would be having a server listen for texts and display them as they arrive. the other would be to input a text and a number and have the program send it
18:00:07 <carter> sccrstud92: on your computer or on a phone
18:00:28 <sccrstud92> carter: program would run on a computer
18:00:38 <sccrstud92> carter: like a desktop or laptop
18:00:42 <carter> ok
18:00:50 <carter> so ... not a device that has builtin sms right?
18:01:16 <sccrstud92> i dont think it has that, correct
18:01:22 <carter> sccrstud92: because then i'd imagine the sms jvm lib wont' work either rihgt?
18:01:45 <sccrstud92> carter: i haven't used, and i haven't done extensive research into how it works
18:01:46 <carter> http://smslib.org/doc/v4/FAQ
18:01:49 <carter> hah
18:01:53 <carter> :)
18:02:44 <benzrf> isnt there a monadic looping func
18:03:19 <sccrstud92> carter: so the lesson is I need special hardware?
18:03:27 <carter> nah
18:03:27 <carter> https://www.twilio.com/
18:03:36 <carter> theres a bajillion companies like twillio
18:03:45 <carter> that give you a web / json based api for doing this
18:04:09 <carter> https://www.plivo.com/
18:04:13 <sccrstud92> but they charge right?
18:04:19 <sccrstud92> in additiona to the actual sms cost
18:04:26 <carter> idk
18:04:34 <carter> do some background reading
18:04:38 <carter> i think they're comparable
18:04:44 <carter> whats your use case
18:05:28 <sccrstud92> alright thanks for your help carter
18:05:56 <carter> for specific devices, there tends to be a c API
18:06:02 <carter> and its really easy to call c codes form haskell
18:06:37 <carter> sccrstud92: the faq for SMSlib has a lot of info http://smslib.org/doc/v4/FAQ
18:08:24 <pavonia> If I have an instance declatration "instance Foo Bar" where Bar is a type synonym, is there a way to resolve that to the base type without explicitly stating it?
18:10:20 <dwcook> pavonia: extension TypeSynonymInstances
18:11:04 <pavonia> But doesn't that define an instance for that type synonym and not for the base type?
18:11:46 <geekosaur> what?
18:11:49 <dwcook> pavonia: no, the type system still sees them as the same type.
18:12:05 <geekosaur> if that were so then it would not be a *synonym*, it would be a *wrapper*
18:12:21 <geekosaur> you have confused type with newtype, or something
18:12:57 <pavonia> Huh
18:13:07 <dwcook> pavonia: did you define Bar with type or with newtype?
18:13:16 <pavonia> with type
18:13:28 <dwcook> Okay, that's what I thought.
18:14:07 <pavonia> I'm pretty sure using that or similar extension was discouraged here because it actually defined difference instances
18:14:16 <geekosaur> no?
18:14:20 <dwcook> You might be thinking of something else.
18:14:51 <geekosaur> the opposite, I think, they are worried about people who are confused like you are and would think that instance Whatever String would be independent of instance Whatever [Char]
18:15:07 <benzrf> monadic looping how i do
18:15:09 <benzrf> :t while
18:15:10 <lambdabot> Not in scope: ‚Äòwhile‚Äô
18:15:15 <benzrf> :t untilM
18:15:16 <lambdabot>     Not in scope: ‚ÄòuntilM‚Äô
18:15:16 <lambdabot>     Perhaps you meant ‚Äòuntil‚Äô (imported from Prelude)
18:15:17 <benzrf> ?!?!?
18:15:17 <lambdabot> Unknown command, try @list
18:15:20 <benzrf> :t until
18:15:22 <lambdabot> (a -> Bool) -> (a -> a) -> a -> a
18:15:30 <dwcook> benzrf: what sort of "looping"?
18:16:24 <dwcook> Giving the type of the function you're looking for might help. For that matter Hoogle might provide it based on that.
18:16:29 <benzrf> oh right lol
18:16:43 <benzrf> @hoogle m Bool -> m a -> m a
18:16:46 <lambdabot> Control.Applicative (*>) :: Applicative f => f a -> f b -> f b
18:16:46 <lambdabot> Control.Applicative (<|>) :: Alternative f => f a -> f a -> f a
18:16:46 <lambdabot> Prelude (>>) :: Monad m => m a -> m b -> m b
18:16:53 <benzrf> hmm
18:17:06 <pavonia> geekosaur, dwcook: Please see the log here http://ircbrowse.net/browse/haskell?events_page=501227
18:17:59 <benzrf> :t inverse
18:18:00 <lambdabot>     Not in scope: ‚Äòinverse‚Äô
18:18:00 <lambdabot>     Perhaps you meant one of these:
18:18:01 <lambdabot>       ‚Äòreverse‚Äô (imported from Data.List),
18:18:04 <benzrf> o=
18:18:14 <dwcook> pavonia: I'm not convinced what's said there is correct. However, I would be willing to entertain the possibility that it is.
18:18:47 * rwbarton is not willing to entertain that possibility
18:19:41 <geekosaur> I do not understand Twey's comment there, if they are interchangeable then they do *not* change based on the name
18:20:00 <geekosaur> if they are *not* interchangeable then that might be true --- but then type synonyms would not work
18:20:08 <dwcook> rwbarton: well, I entertained it by doing a little test that came out the way I thought it was.
18:20:19 <dwcook> Namely GHC complains of "duplicate instance declarations".
18:20:46 <rwbarton> well, I guess there could always be a bug in GHC so it's good that there isn't :)
18:23:06 <dwcook> I find it odd that two experienced Haskellers would have had the same mistaken notion though.
18:23:35 <dwcook> Oh!
18:23:51 <dwcook> They're answering a different question than the one pavonia is talking about, I bet.
18:24:10 <dwcook> Namely they were addressing a misconception by the asker there.
18:24:27 <rwbarton> I think there is some game of telephone going on here, yes
18:24:43 <Welkin>  /r/haskell ?
18:24:46 <dwcook> Yes, that's a good way of putting it.
18:24:48 <monochrom> I solve the problem by avoiding type synonyms
18:25:05 <Welkin> is that actually useful?
18:25:12 <Welkin> it looked like people whining to me
18:25:30 <monochrom> I don't read /r/haskell . that also solves another problem.
18:26:07 <dwcook> benzrf: to answer your question, I'm not sure it makes sense to have a function m Bool -> m a -> m a. What would it do?
18:26:30 <pavonia> Maybe I misunderstood Twey's answer to my question, especially the comment in parentheses
18:26:37 <dwcook> benzrf: I could go with m Bool -> m a -> m () easily though.
18:27:29 <dwcook> benzrf: or even m Bool -> m a -> m (Maybe a)
18:27:55 <dwcook> (All with the Monad m constraint of course)
18:28:02 <benzrf> dwcook: hmm
18:28:04 <benzrf> something like
18:28:49 <benzrf> whileM cond body = do continue <- cond; if continue then body >> whileM cond body else return ()
18:28:52 <benzrf> oic
18:28:56 <benzrf> yeah you're right mb >.<
18:28:57 <benzrf> haha
18:29:18 <ReinH> dwcook: the former has to be rather silly due to parametricity.
18:29:32 <dwcook> ReinH: I don't understand.
18:29:42 <benzrf> @hoogle m Bool -> m a -> m ()
18:29:43 <ReinH> f :: m Bool -> m a -> m a
18:29:45 <lambdabot> Control.Applicative (*>) :: Applicative f => f a -> f b -> f b
18:29:45 <lambdabot> Prelude (>>) :: Monad m => m a -> m b -> m b
18:29:45 <lambdabot> Control.Monad (>>) :: Monad m => m a -> m b -> m b
18:29:49 <benzrf> lame!
18:29:52 <ReinH> f _ ma = ma
18:30:03 <dwcook> ReinH: ah of course.
18:30:09 <ReinH> you can't just construct an m a uniformly
18:30:14 <dwcook> ReinH: alternatively, f mbool ma = mbool >> ma
18:30:23 <ReinH> Sure
18:30:29 <augur> what are you people talking about
18:30:59 <dwcook> augur: did you join after the object of discussion? I have joins/parts mostly disabled.
18:31:14 <augur> no, im just confused by the back convo
18:31:30 <augur> are you trying to define m Bool -> m a -> m a ???
18:31:34 <gdoteof> i sent this to yesodweb group: but i am not entirely sure it's a yesod issue.  i'm getting huge performance hits and i can't find where
18:31:35 <dwcook> augur: try to construct a useful value :: (Monad m) => m Bool -> m a -> m a
18:31:36 <gdoteof> https://gist.github.com/gdoteof/fc326ed522eec38faf5e
18:31:49 <geekosaur> augur: someone asked why we don't have that, yes
18:32:10 <ReinH> Basically it can't so anything with the bool
18:32:14 <ReinH> *do
18:32:34 <augur> geekosaur: you want MonadPlus
18:32:37 <dwcook> It could, but not what you might expect
18:32:40 <geekosaur> *I* don't
18:32:52 <augur> mzero :: (MonadPlus m) => m a
18:32:54 <geekosaur> I was not part of that discussion
18:33:07 <augur> whoever.
18:33:07 <dwcook> f b x = do { b' <- b ; if b' then x >> x else x } -- :)
18:33:16 <ReinH> dwcook: ok :p
18:33:36 <dwcook> My point being there are possibilities but it's probably not the type that's wanted
18:33:40 <ReinH> it can't do anything other that use the m a :p
18:33:50 <dwcook> Agreed, it can't invent another m a
18:33:53 <augur> theThingYouWant mbool ma = do { bool <- mbool ; if bool then ma else mzero }
18:33:55 <ReinH> yep full ack
18:33:59 <dwcook> (Without using _|_ of course)
18:34:04 <augur> theThingYouWant :: MonadPlus m => m Bool -> m a -> m a
18:34:04 <dwcook> (but who wants _|_ ick)
18:34:45 <dwcook> Even more generally, (Monad m) => m Bool -> m a -> m a -> m a
18:34:54 <enthropy> @hoogle om
18:34:56 <lambdabot> package omaketex
18:34:56 <lambdabot> package omega
18:34:57 <lambdabot> package omnicodec
18:35:28 <ReinH> dwcook: sure
18:35:54 <augur> dwcook: for that you dont even need anything special
18:36:09 <dwcook> Yeah
18:36:31 <augur> liftM2 if'
18:37:24 <ReinH> Yep
18:37:50 <enthropy> that makes it a bit awkward to add the 3rd argument to if'
18:37:54 <benzrf> :t lookup
18:37:55 <lambdabot> Eq a => a -> [(a, b)] -> Maybe b
18:38:01 <benzrf> cool
18:38:05 <augur> enthropy: whoops :D
18:38:07 <enthropy> unless you define it with mzero?
18:38:09 <augur> liftM3 if'
18:38:12 <augur> :p
18:38:13 <enthropy> and then call it guard
18:38:25 <augur> liftM3 if' mbool ma mzero
18:38:32 <Twey> pavonia: What answer was that?
18:38:45 <augur> enthropy: you have to use mzero
18:38:48 <Twey> Oh, *reads*
18:39:04 <augur> enthropy: unless you want to reuse the ma argument, which seems somewhat beside the point
18:39:21 <ReinH> Yep that was my parametricity point :)
18:39:59 <augur> ReinH: ?
18:40:18 <Twey> geekosaur, pavonia: Type synonyms are interchangeable in that you can use one name for a type wherever you can use another
18:40:19 <ReinH> you can't just uniformly construct a value Monad m => m a
18:40:37 <augur> ReinH: im not sure why you'd use parametricity for that
18:40:50 <augur> ReinH: just give the identity monad as a counter example
18:40:58 <augur> and then pick a = Voi
18:40:59 <augur> d
18:41:21 <geekosaur> Twey: yes, that includes instances, why did the continuation of that claim then assert that that would somehow make it not true for instances?
18:41:22 <Twey> pavonia, geekosaur: TypeSynonymInstances is evil because it breaks the assumption that that means that the expression will behave the same regardless of what name you use to refer to its type
18:41:22 <ReinH> augur: a function Monad m => m Bool -> m a -> m a can only reuse the am
18:41:30 <geekosaur> what
18:41:35 <ReinH> the ma
18:41:56 <augur> ReinH: well, it can use it. it doesnt have to "reuse" it in any sense
18:42:04 <geekosaur> instance Whatever String <--- illegal without TypeSynonymInstances; *with* it, is *identical* to: instance Whatever [Char]
18:42:25 <ReinH> augur: it can't pick between the m a and another m a based on the Bool
18:42:30 <geekosaur> the instance does not follow the name; that would indeed be broken because then it's not a *synonym*
18:42:34 <ReinH> which can be shown by parametricity
18:42:54 <ReinH> since you can't act uniformly on the a
18:43:09 <benzrf> :t fromJust
18:43:10 <lambdabot> Maybe a -> a
18:43:11 <augur> ReinH: i guess. that just seems like a strange way to demonstrate it
18:43:13 <benzrf> ehamberg:
18:43:14 <benzrf> *eh
18:43:29 <ReinH> augur: ok, it doesn't seem strange to me :)
18:43:39 <ReinH> but it's ok if it seems strange to you.
18:43:44 <Twey> geekosaur: Hm, you're right
18:43:53 <Twey> I'm sure there used to be an extension that did that
18:43:59 <augur> ReinH: my explanation would go: if it doesnt use the m a, it has to make one up. but it cant do that, because suppose m = Identity and a = Void, then there is no value to make up
18:44:14 <geekosaur> I am recalling documentation saying that it does not and why it would be completely broken to do so
18:44:21 <augur> so it cant possibly be making up values
18:44:33 <ReinH> Right, but uniformity is a nice explanation for why it can't make one up :)
18:44:37 <benzrf> @src (<*)
18:44:37 <lambdabot> (<*) = liftA2 const
18:44:46 <benzrf> sweet
18:45:02 <ReinH> same as why f :: a -> b is uninhibited except for bottoms
18:45:11 <augur> ReinH: i dont think you really need an explanation tho, just a counter example
18:45:19 * hackagebot libmpd 0.8.0.4 - An MPD client library.  http://hackage.haskell.org/package/libmpd-0.8.0.4 (JoachimFasting)
18:45:27 <ReinH> And unsafeCoerce I guess
18:45:54 <augur> ReinH: well, i guess the polymorphism is how you can see "let m = Identity and a = Void", but beyond that
18:46:19 <ReinH> Right but it's *forall a*
18:46:24 <augur> yes
18:46:25 <Twey> pavonia: Yeah, I'm just wrong.  Carry on using TypeSynonymInstances :√æ
18:46:33 <ReinH> that's where the uniformity comes in
18:46:41 <augur> ReinH: it doesnt need to even be uniform tho
18:46:47 <augur> it doesnt matter whether its uniform or not
18:46:48 <pavonia> Twey: Heh, okay :)
18:46:56 <Twey> I have a recollection of some extension that did that
18:47:03 <ReinH> augur: ok :) I'm not quite sure what we're arguing about tbh :)
18:47:05 <Twey> But evidently it's not TypeSynonymInstances, if indeed it exists
18:47:07 <augur> the mere fact that it says it works for all a suffices
18:47:47 <augur> ReinH: i mean, suppose we had a new quantifier, "nonuniformForall", and i claimed to have   f :: nonuniformForall a. a
18:47:50 <ReinH> Ok so if you can find a counter example. I get it.
18:47:51 <augur> (for simplicity)
18:48:04 <ReinH> Then it can't be forall a
18:48:06 <ReinH> got it
18:48:22 <augur> then sure, ok, now i've got this f. but wait, i can now specify a to be Void and get f :: Void
18:48:30 <ReinH> I guess parametricity is just the hammer I prefer for such things :)
18:48:39 <augur> but we know that Void is uninhabited, so i cant have f to begin with
18:48:46 <ReinH> Yep understood
18:49:01 <augur> it ultimately doesnt matter whether the quantifier is uniform, just that its universal and lets you freely specify
18:49:30 <ReinH> but... uniformity is implied by universal quantification.
18:49:38 <augur> arguably you might even want to avoid parametricity, since its too small as a hammer: it cant prove that f :: nonuniformForall a. a is empty!
18:49:43 <augur> ReinH: no its not
18:50:02 <augur> uniformity is entailed by a specific universal quantification: the one we normally use
18:50:10 <ReinH> hmm
18:50:23 <augur> namely, the one with introduction rules for uniformity
18:50:31 <ReinH> I thought you just need parametric polymorphism
18:50:37 <ReinH> which just needs universals
18:51:00 <augur> G, a :: * !- M :: S   ===>   G !- /\a :: *. M :: forall a :: *. S
18:51:01 <ReinH> I'm just going by Wadler, etc
18:51:14 <ReinH> hmm
18:51:21 <augur> thats the standard universal quantifier
18:51:25 <augur> the one for parametric polymorphism
18:52:15 <augur> but you can perfectly well define type theories with non-parametric universal quantifiers
18:55:05 <augur> for instance, imagine we had type case, and could do this:   typecase a of { S -> ... ; T -> ... ; ... }
18:55:08 <augur> where a is a type
18:55:41 <augur> then we could write a program   /\a. typecase a of { S -> M ; T -> N ; otherwise -> default }   provided default :: forall a. a
18:56:05 <augur> then we would indeed have non-uniform universal quantification!
18:57:24 <augur> or rather instead of default use id, then M and N just have to be any endofunction
18:58:02 <augur>  /\a. typecase a of { Int -> (+1) ; String -> (++"foo") ; otherwise -> id }
18:58:18 <augur> a perfectly reasonable function with nonuniform universal polymorphism
18:58:26 <augur> for every type, it has a definition
18:58:40 <augur> it is undeniably universal, but clearly non-uniform
18:59:29 <augur> ReinH: so we definitely shouldnt rely on uniformity to prove that universal quantification prevents  `forall a. a` from being inhabited
18:59:48 <augur> instead we ought to rely on universality, which gives us the leverage to pick a case that we know wont work
19:10:22 * hackagebot hosc 0.14.1 - Haskell Open Sound Control  http://hackage.haskell.org/package/hosc-0.14.1 (RohanDrape)
19:13:58 <Qer> Hi guys. I want to use Maybe: I'm writing a function that is supposed to find an element in a list and return a list with this element removed
19:14:14 <Qer> but if this element is not present, it should give us a "False" or "Nothing" or something
19:14:56 <pavonia> What type would you give that function?
19:15:04 <Qer> my problem is that the input is not a Maybe instance
19:15:20 <pavonia> Why is that a problem?
19:15:22 <Qer> but to do it recursively, I have to return a Maybe... so in the next iteration, the input is a Maybe
19:15:48 <benzrf> Qer: recurse monadically!
19:15:55 <Qer> I'd like it to be [a] -> a -> Maybe [a] or something
19:16:11 <Qer> I don't know monads I am afraid, sir
19:16:24 <benzrf> oh wait i see what you are saying
19:16:25 <c_wraith> Qer: yes, that signature maps to what you want to do.
19:16:25 <benzrf> hm hm
19:16:50 <Qer> but I want to know if we succeded or not, not just remove this element
19:17:07 <glguy> Qer: What do you have so far?
19:17:53 <benzrf> r8 my code http://bpaste.net/show/299049/
19:17:57 <Qer> a simple recursive function that searches for the element
19:18:19 <Qer> I try to return "Nothing" when we fail the search, but then the types don't match
19:18:48 <benzrf> Qer: they do if you use it funtorially
19:18:53 <benzrf> *functorially
19:19:00 <glguy> qer: paste your code to http://lpaste.net/new/haskell ?
19:19:55 <Qer> http://lpaste.net/104624
19:20:06 <Qer> when I change the Nothing to an empty list, it works
19:20:29 <Qer> but I can't just return an empty list, because that's a potential proper answer this function might return
19:20:44 <benzrf> Qer: have you tried tail recursion
19:21:10 <Qer> guess I just can return a list containing a -1 in it, cause the numbers inside will be bigger than 0, but that's not elegant
19:21:52 <Qer> isn't it tail recursion I wrote?
19:22:41 <triliyn> Qer: do you know the functor instance of maybe?
19:22:50 <triliyn> You can change the conditional to
19:22:53 <glguy> before diving into various type classes
19:23:09 <triliyn> "if x == y then Just ys else fmap (x:) (delete x ys)"
19:23:12 <glguy> Qer: You need to inspect the return value of your delete function and branch accordingly
19:23:48 <triliyn> But yes, you need to do case analysis on the result of the recursive call instead of using it directly
19:24:03 <triliyn> If the recursive call is Nothing, you want to immediately return Nothing
19:24:12 <Qer> okay, thanks, I'll try it. I don't really know classes and types of Haskell very well
19:24:21 <glguy> You don't need them. Do you know about "case"?
19:24:28 <Qer> yeah I do
19:24:44 <glguy> You can use case on your recursive call
19:25:33 <halvorg> How do I make an int pointer? I'm trying to call a function with this type:
19:25:45 <halvorg> glGenFramebuffers :: GLsizei -> Ptr GLuint -> IO ()
19:26:34 <glguy> ?type Foreign.Marshal.with
19:26:35 <lambdabot> Foreign.Storable.Storable a => a -> (GHC.Ptr.Ptr a -> IO b) -> IO b
19:26:53 <Qer> triliyn: fmap is something like a type cast in Haskell?
19:27:08 <ion> no
19:27:23 <ion> > fmap (+ 42) [100..110]
19:27:25 <lambdabot>  [142,143,144,145,146,147,148,149,150,151,152]
19:27:31 <ion> > fmap (+ 42) (Just 100)
19:27:33 <lambdabot>  Just 142
19:27:39 <ion> It‚Äôs a generalization of map for lists.
19:27:47 <triliyn> > fmap (5:) (Just [4,3,2])
19:27:48 <lambdabot>  Just [5,4,3,2]
19:28:28 <c_wraith> I don't think fmap is useful at solving the original question
19:28:58 <c_wraith> The problem is that the base case is Nothing
19:29:10 <glguy> c_wraith: It works out
19:29:21 <glguy> He only wants to delete the first occurrence
19:29:44 <c_wraith> Ah, I see.
19:29:44 <Qer> yeah, fmaps does something strange to the beginning of the list, before the occurence
19:29:46 <dario> > fmap (5:) Nothing
19:29:48 <lambdabot>  Nothing
19:30:09 <glguy> c_wraith: Or I misunderstood and you're right :)
19:30:33 <c_wraith> glguy: well, the probability that one of us misunderstood is very high. :)
19:31:18 <Qer> guys, when I use this function (with fmap), it changes everything before the occurence to the thing I am looking for
19:31:25 <triliyn> qer: oh, I misread your function
19:31:28 <Qer> should I get to know functors and monads before using this?
19:31:33 <glguy> Nope
19:31:34 <ReinH> augur: one sec. I thought uniformity and universality were more similar. Let me find a reference.
19:31:42 <Qer> I don't feel comfortable using things I don't comprehend
19:31:48 <glguy> Qer: You should be able to do this *before* you bother with Functors or Monads
19:31:49 <triliyn> I would learn about functors before using fmap
19:32:19 <triliyn> Qer: I said (x:), but it should be (y:)
19:32:21 <glguy> Qer: Once you've done the same pattern a couple times you'll find yourself wanting to name it. once you've named that pattern a few times you'll be ready to think about fmap
19:32:52 <augur> ReinH: as i said, they're similar in that the typical definition of universal quantification is indeed the uniformity definition
19:32:57 <Qer> triliyn: jeez, I'm so dumb
19:33:19 <triliyn> It's an easy kind of mistake to make
19:33:30 <augur> ReinH: but with type-case you can define non-uniform but universal things
19:33:48 <Qer> okay guys, I'll spend some time figuring out what that fmap is before I move on :) thanks again for helping me
19:34:03 <ReinH> Ah. Uniformity iirc is a naturality condition
19:34:08 <augur> ReinH: thats the whole point about parametricity -- that it's inconsistent with type-case, not that its a requirement of universal quantification
19:34:11 <triliyn> Qer: you don't need to use fmap if you don't want to; someone else mentioned a way to get it without fmap
19:34:23 <triliyn> But if you'd like to learn it anyway, that's fine too :)
19:34:27 <augur> ReinH: well, uniformity is related to naturality
19:34:33 <augur> but thats very semanticy
19:35:01 <ReinH> Er, naturality corresponds to parametric polymorphism
19:35:19 <augur> ReinH: not quite!
19:36:16 <augur> ReinH: natural transformations have functors as domain and codomain. but not all parametrically polymorphic functions have functors as their dom/cod!
19:36:29 <augur> no functor, no natural transformation :)
19:36:39 <augur> i think the actual analysis is dinaturality?
19:36:49 <ReinH> Ah
19:37:31 <augur> i think in the cases where they do have functors, it coincides with naturality
19:38:02 <ReinH> augur: ah!
19:38:07 <Qer> what does it even mean? This "f a" and "f b"? I thought that it's supposed to be "f->a" and "f->b"
19:38:08 <Qer> :t fmap
19:38:09 <lambdabot> Functor f => (a -> b) -> f a -> f b
19:38:17 <augur> Qer: no
19:38:41 <augur> `f` in `f a` is a type operator
19:38:50 <augur> that is, `f` combines with a type to form another type
19:39:03 <triliyn> Like Maybe
19:39:07 <augur> right
19:39:10 <Qer> oh, okay
19:39:19 <augur> `Maybe` isnt a type, but you combine it with a type, as in `Maybe Int` to get a type
19:39:50 <ReinH> augur: the constructor I
19:39:52 <ReinH> Er
19:40:39 <ReinH> The constructor -> is contravariant in first position and covariant in second position
19:41:38 <enthropy> is it correct to say that instances of "class D a b => C a b where m :: a -> b" are less likely to be chosen than "class C a b where m :: D a b => a -> b"?
19:41:56 <ReinH> But f : X -> X is neither contravariant nor covariant
19:42:12 <ReinH> augur:  I remember a thing now. One sec.
19:42:54 <ReinH> augur: from Mac Lane...
19:42:58 <augur> ReinH: right. but then: what is   forall a. (a -> a) -> (a -> a) ??   cant be natural, since \x -> (x -> x) is not a functor!
19:43:20 <ReinH> Yep exactly
19:43:22 <augur> but: (->) _is_ a bifunctor, so it might be dinatural (it is)
19:43:36 <ReinH> Mac Lane treats this a bit
19:44:33 <ReinH> Diagonal naturality
19:44:50 <ReinH> Section IX.4
19:44:56 <augur> yes
19:44:59 <augur> http://ncatlab.org/nlab/show/dinatural+transformation
19:45:05 <ReinH> Ok I'm with you
19:45:16 <ReinH> Thanks
19:45:35 <augur> that page cites dan piponi! :D
19:45:44 <ReinH> Ha
19:45:56 <ReinH> Dan is a terminal object
19:46:16 <ReinH> Well really Mac Lane is. Or Eilenberg
19:46:27 <augur> sometimes unfortunately so :(
19:46:32 <ReinH> Hah
19:46:48 <ReinH> Oh look what I found
19:47:12 <ReinH> http://www.cs.bham.ac.uk/~udr/papers/logical-relations-and-parametricity.pdf#
19:47:19 <ReinH> Makes this exact argument
19:47:27 <ReinH> Yay for learning new things
19:48:30 <augur> :)
19:48:32 <ReinH> augur: btw I met Dan at BayHac and he didn't say no to coming on the Haskell Cast ;)
19:48:46 <augur> oh, you do Haskell Cast?
19:48:52 <ReinH> yeah
19:49:18 <meretrix> Is there an alternative definition of (.) that would make the following work?
19:49:22 <meretrix> :t abs . (undefined :: Char -> Char -> Int)
19:49:23 <lambdabot>     No instance for (Num (Char -> Int)) arising from a use of ‚Äòabs‚Äô
19:49:23 <lambdabot>     In the first argument of ‚Äò(.)‚Äô, namely ‚Äòabs‚Äô
19:49:23 <lambdabot>     In the expression: abs . (undefined :: Char -> Char -> Int)
19:49:49 <ReinH> What type do you want this (.) to have?
19:52:17 <meretrix> ReinH: Hmm.. I'm not sure. Intuitively, I would want (.) to just consider the type of the "return type" of the functions it's composing.
19:52:42 <benzrf> meretrix: it does
19:52:44 <sgronblo> ReinH: I've listened to all the haskell casts so far but as somebody who is not working with haskell and doesnt have as much free time as I would like to play with it, I find the topics a bit above my current level.
19:53:08 <benzrf> meretrix: the return type of 'Char -> Char -> Int' is 'Char -> integral '
19:53:09 <benzrf> *Int
19:53:10 <augur> meretrix: lets put it this way
19:53:18 <augur> what type do you want abs . whatever to have
19:53:43 <meretrix> augur: Char -> Char -> Int
19:53:52 <meretrix> From my example.
19:54:22 <Qer> o god, 15 min of debugging cause I didn't write an "else" block... hate errors in Haskell
19:54:26 <augur> ok. so you want to be able to compose at the very end of an n-ary function to produce another n-ary function, it sounds like
19:54:45 <meretrix> Yes, that sounds like what I want.
19:54:54 <augur> haskell does not have such a thing.
19:55:02 <meretrix> Ah darn.
19:55:38 <augur> meretrix: you can define new combinators tho, or use the funky "composition of composition" combinators
19:55:43 <augur> :t (.).(.)
19:55:44 <lambdabot> (b -> c) -> (a -> a1 -> b) -> a -> a1 -> c
19:55:48 <augur> :t (.).(.).(.)
19:55:49 <lambdabot> (b -> c) -> (a -> a1 -> a2 -> b) -> a -> a1 -> a2 -> c
19:55:52 <augur> etc
19:56:39 <augur> or just make it easy on yourself and your readers and define
19:56:58 <augur> (f .. g) x y = f (g x y)
19:57:07 <augur> (f .: g) x y z = f (g x y z)
19:57:07 <augur> etc
19:58:16 <ReinH> :(
19:58:43 <ReinH> I thought .: was bad but two different definitions of .: is worse!
19:58:46 <augur> whats wrong ReinH!
19:58:48 <augur> oh
19:58:49 <benzrf> w
19:58:58 <augur> what? :D
19:59:04 <augur> @src (.:)
19:59:05 <lambdabot> Source not found. I am sorry.
19:59:09 <augur> :t (.:)
19:59:10 <lambdabot>     Not in scope: ‚Äò.:‚Äô
19:59:10 <lambdabot>     Perhaps you meant one of these:
19:59:10 <lambdabot>       ‚Äò.‚Äô (imported from Data.Function),
19:59:14 <ReinH> I usually see .: = (.).(.) iirc
19:59:36 <augur> yeah, people do that. i was suggesting using the dot count in a uniform fashion tho
19:59:38 <benzrf> my brain cant parse (.).(.)
19:59:54 <glguy> Go easy on your readers and just write out what you mean. No need for a new operator
19:59:59 <augur> . = unary, .. = binary, .: = ternary, .:., .::, .::., .:::, ...
20:00:07 <ReinH> Noooooo
20:00:10 <augur> :)
20:00:27 <ReinH> augur: stahp :p
20:00:36 <augur> (.)..(.:).:.(.::)
20:00:40 <dwcook> augur: define an Acme package for it
20:00:40 <benzrf> eeeeek
20:00:41 <ReinH> Just use some points
20:00:41 * monochrom prefers: ?=unary, ??=binary, ???=tenary
20:00:56 <augur> all new brailskell!
20:01:05 <monochrom> the Riddler would be proud of my suggestion :)
20:01:10 <ReinH> Hah
20:01:30 <augur> but yeah, i'd say just write (\x y -> f (g x y))
20:02:03 <ReinH> Or \x -> f . g x can sometimes be nice
20:02:13 <augur> thats awful tho
20:02:19 <ReinH> Eh I dunno
20:02:33 <benzrf> augur++
20:02:37 <bitemyapp> ReinH: I PR'd that documentation bug in postgresql-simple that irritated me.
20:02:43 <ReinH> If g x obviously gives a function
20:02:47 <bitemyapp> drove me nuts.
20:02:48 <augur> avoid tacitness if possible
20:02:55 <augur> use it sparingly
20:03:07 <augur> and never for 2+-ary functions!
20:03:36 <ReinH> Says the person who wants to define .::::.
20:03:44 <Qer> guys, what do you use Haskell besides for academic reasons?
20:03:54 <Qer> what do you use Haskell for*
20:03:55 <augur> ReinH: well, want? no :p
20:03:55 <bitemyapp> Qer: I don't even have my undergrad degree
20:03:59 <bitemyapp> Qer: I use Haskell for work.
20:04:02 <ReinH> Qer: writing programs.
20:04:05 <augur> ReinH: i'd say use dependent types!
20:04:19 <augur> ‚àò[ 5 ] !
20:04:23 <Qer> bitemyapp: you think you do work faster in Haskell than in other languages?
20:04:28 <bitemyapp> Qer: not currently *at* work, but I'm working on changing that. I do mostly a mixture of OSS library stuff that people would use for their day to day work.
20:04:37 <bitemyapp> Qer: yes, I actually put together an article about this.
20:04:48 <augur> i cant imagine writing the stuff i write in a non-functional language
20:04:51 <Qer> may I read it? :)
20:04:53 <augur> it would be AWEFUL
20:04:54 <bitemyapp> Qer: I used to use untyped languages, Haskell was the typed lang to finally flip me: http://bitemyapp.com/posts/2014-04-29-meditations-on-learning-haskell.html
20:05:14 <bitemyapp> Qer: it includes the thoughts of others and concludes with my own experiences.
20:05:15 <augur> lack of ADTs alone makes me terrified
20:05:20 <benzrf> i still like untyped for non haskell
20:05:26 <ReinH> augur: yes.
20:05:30 * hackagebot tskiplist 1.0.0 - A Skip List Implementation in Software Transactional Memory (STM)  http://hackage.haskell.org/package/tskiplist-1.0.0 (PeterRobinson)
20:05:34 <augur> but then, most of what i do is implement variants of the LC so... =x
20:05:34 <bitemyapp> Qer: but to answer your question directly - I do work faster in Haskell. That *has* been my experience.
20:06:19 <Qer> isn't haskell very hard to debug by other people though? and to reuse the code?
20:06:29 <ReinH> augur: isn't that what we all do :p
20:06:44 <augur> ReinH: the real question is, how do you handle even more general composition like   \f g h x y z w -> f (g x y) (h z w)?
20:06:46 <ReinH> Qer: exactly the opposit
20:06:52 <augur> ReinH: whats the combinator for that!
20:07:05 <bitemyapp> Qer: that's all backwards, I'm afraid.
20:07:17 <bitemyapp> Qer: I realize it's intimidating when you don't know it, but once you've learned Haskell it's quite freeing.
20:07:36 <bitemyapp> Qer: I've been teaching Haskell lately, the guide is here: https://github.com/bitemyapp/learnhaskell
20:07:45 <ReinH> augur: you start by questioning your life choices.
20:07:50 <augur> ReinH: :)
20:08:07 <augur> ReinH: indeed. especially tacit style!
20:08:18 <ReinH> augur: zing
20:08:19 <augur> taciticity is evil, more or less
20:08:28 <Qer> bitemyapp: thanks, I'll read it ;)
20:10:46 <ReinH> Qer: might I suggest waiting to form opinions about Haskell until after you try it :)
20:11:42 <Qer> ReinH: I meant no offence and was mainly asking questions
20:12:09 <ReinH> I meant that in a friendly way :)
20:12:32 <bitemyapp> ReinH: I wish I could get away with that.
20:12:50 <ReinH> bitemyapp: try more smiley faces
20:13:27 <Qer> okay guys, gotta get some rest
20:13:33 <dwcook> Everything is friendly when it's ended with a smiley face, jerk :)
20:13:42 <Qer> 5 AM ain't the best time to figure out functional programming ;D good bye and thanks for everything!
20:13:50 <ReinH> dwcook: I hope you die =)
20:13:57 <Qer> I killed your dog :)
20:14:00 <dwcook> ReinH: aw, that's sweet
20:14:22 * Polarina plants the seed of friendship.
20:14:29 <ReinH> Yes it is.
20:14:38 <ReinH> It would be sweet indeed.
20:14:54 <ReinH> Your death I mean.
20:14:56 <ReinH> :)
20:15:16 <ReinH> Almost forgot the smiley face
20:15:37 <dwcook> Yeah, that would've been a massive faux paus.
20:15:47 <ReinH> Confirm
20:16:09 <ReinH> Glad I totally avoided that one
20:18:48 <Qer> oh guys one more thing! I want to make a function that returns some result that might in some place split into two branches, and after that both working independently
20:18:54 <Qer> like it is in Prolog
20:19:26 <Qer> the problem is that in Haskell, my only idea to do things is do do them recursively
20:21:18 <Qer> hm, let me get you an example: we look through a list of integers and until we see 42, we just return the list. but when we see it, we do 2 branches: one with 41 in place of the 42 we found, one with 43 in place of the 42 we found
20:22:02 <Qer> for example: input: [1, 2, 42, 3, 42], output: [[1, 2, 41, 3, 41], [1, 2, 41, 3, 42], [1, 2, 43, 3, 41], [1, 2, 43, 3, 43]]
20:22:28 <Qer> and as you see, when I begin to run this function, I don't know how many splits there will be
20:23:27 <Qer> my idea for things like this is to just do a recursive call for every element, but then when a 42 occurs, what to do?
20:23:42 <Welkin> divide by zero
20:23:43 <glguy> qer: That's just a function :: [Integer] -> [[Integer]]
20:23:56 <glguy> You should be able to write it directly
20:24:01 <Welkin> > 1/0
20:24:03 <lambdabot>  Infinity
20:24:11 <Welkin> > 1.0/0
20:24:12 <ReinH>  > sequence [[1],[1,2]]
20:24:13 <lambdabot>  Infinity
20:24:45 <ReinH> Replace 43 with a list of choices and other numbers with the singleton list
20:24:47 <Qer> glguy: what do you mean by "directly"? without recursion?
20:24:58 <glguy> no, with recursion, but without anything fancy
20:25:02 <ReinH> Er did I have a space?
20:25:22 <glguy> ?type mapM (\x -> if x == 42 then [41,43] else [x])
20:25:23 <lambdabot> (Num b, Eq b) => [b] -> [[b]]
20:25:24 <ReinH> > [[1],[1,2]]
20:25:26 <lambdabot>  [[1],[1,2]]
20:25:42 <Qer> hm, this was just an example. I just need to keep the previous part of the list the same and split into two branches when something occurs
20:25:44 <glguy> > mapM (\x -> if x == 42 then [41,43] else [x]) [1, 2, 42, 3, 42]
20:25:45 <lambdabot>  [[1,2,41,3,41],[1,2,41,3,43],[1,2,43,3,41],[1,2,43,3,43]]
20:25:46 <ReinH> > sequence [[1],[1,2]]
20:25:48 <lambdabot>  [[1,1],[1,2]]
20:25:54 <ReinH> Finally
20:26:04 <glguy> Qer: and once you're comfortable with things you'll know how write that (above)
20:26:18 <ReinH> Replace 42 with [41,43]
20:26:27 <ReinH> And other x with [x]
20:26:44 <t0rc> What is haskell really good for?
20:26:45 <Welkin> :t sequence
20:26:46 <lambdabot> Monad m => [m a] -> m [a]
20:27:17 <Qer> I just thought there is a function to do branches or something
20:27:17 <ReinH> Bird uses this exact thing in his Sudoku solution
20:27:31 <ReinH> Lists can represent choices
20:27:38 <ReinH> So we can use them for this
20:27:45 <t0rc> It seems to certainly lean towards rapid prototyping but what kind? web? GUI? It seems to me it's more like a good way to prototype the underlying solutions for things.
20:28:10 <glguy> qer: http://lpaste.net/104626
20:28:42 <Welkin> use a tree then
20:28:45 <Welkin> for branches
20:29:01 <ReinH> Qer: check this out you'll love it http://www.cs.nott.ac.uk/~gmh/sudoku.lhs
20:29:34 <ReinH> One of my favorite Haskell programs for learning
20:30:05 <Welkin> there is one for chess too
20:30:29 <ReinH> Welkin: which?
20:30:29 <Qer> Welkin: a tree may not be a stupid idea
20:30:36 <Qer> ReinH: Thanks!
20:30:53 <Welkin> http://www.haskell.org/haskellwiki/Learning_Haskell_with_Chess
20:31:30 <ReinH> Qer: he uses a function identical to sequence to take lists of choices into choices of lists
20:31:41 <ReinH> Which is what sequence does for lists
20:32:16 <ReinH> Or one way of looking at what sequence does to lists at leas
20:33:32 <orzo> Enum instances that cannot be derived are tedius.  Is there any ghc extensions not requiring template haskell that ameliorates that?
20:34:07 <orzo> for example, i have some symbols that should map to and from (-2), (-1), and 0
20:34:30 <orzo> it can *almost* be derived, but annoyingly i cant tell the compiler to just offset that derived mapping
20:35:46 <ReinH>  When you want to "split into two branches" you can instead have two lists, one to represent each choice
20:36:10 <ReinH> Each time you split you double the number of choices in total
20:36:53 <Qer> but how to keep everything from the beginning?
20:36:54 <ReinH> The list of lists thus represents all the ways you can make each choice
20:37:04 <Qer> yeah, that's my goal
20:37:40 <ReinH> This is why the list monad is sometimes considered a "choice" monad or "no determinism" monad
20:37:44 <Qer> but I don't know how to get all the previous choices before the choice we are dealing with now
20:38:17 <ReinH> Qer: they are present in the resulting lists
20:38:17 <Qer> I'd like to have two copies of them every time I make a binary choice
20:39:39 <ReinH> > sequence ["hH","e","l","l","o"]
20:39:41 <lambdabot>  ["hello","Hello"]
20:39:55 <Qer> hmm
20:40:06 <ReinH> First choose between 'h' and 'H'
20:40:16 <ReinH> Then choose 'e'
20:40:18 <ReinH> Etc
20:41:25 <Qer> wow, so I basically do a "sequence" of all the possible moves and just filter them for those that are against the rules of the game?
20:41:27 <ReinH> Sequence gives you all possible sequences of choices
20:41:37 <ReinH> That's an option
20:41:48 <ReinH> And exactly what Bird does to solve sudoku
20:41:49 <Qer> will that be lazy-calculated?
20:41:56 <ReinH> Check the prune function
20:41:57 <Qer> I need it to be efficient
20:42:15 <ReinH> Look at how efficient Bird's solution ends up being
20:42:21 <ReinH> Hint: very
20:42:27 <Qer> I received only the documentation of this project, I am afraid
20:42:38 <ReinH> It's literate Haskell
20:42:48 <ReinH> So the > lines are executable
20:42:58 <ReinH> It's both documentation and code
20:43:12 <Qer> what... that code is so tiny
20:43:18 <enthropy> orzo: can you split your data type into part that starts from 0?
20:43:19 <ReinH> GHC and ghci know how to parse it, just try!
20:43:27 <ReinH> Yes it is :)
20:43:55 <ReinH> I would call that exemplary Haskell code :)
20:44:17 <Qer> it's beautiful
20:44:23 <enthropy> alternatively you could have   data D_ = Fail1 | Fail2 | Ok1 | Ok2 deriving Enum; newtype D = D D_
20:44:25 <ReinH> It is!
20:44:46 <ReinH> And deeply so, at that
20:45:15 <ReinH> Since it uses an algebraic way of reasoning about algorithms to ensure correctness :)
20:45:26 <enthropy> which lets you write an    instance Enum D where fromEnum (D d) = fromEnum d - 2; toEnum n = D (toEnum (n+2))
20:45:32 <orzo> enthropy: i can do all ikinds of stuff, but i wish ghc would just work with me instead
20:45:36 <Qer> so basically do a sequence, and then filter the result
20:46:00 <ReinH> Yep! Read the stuff in the sudoku about how prune works :)
20:46:22 <ReinH> Prune is literally a filter
20:46:43 <ReinH> And does exactly what you suggest to reduce the sudoku search space
20:46:46 <Qer> this code is too tough for me ;d
20:46:59 <ReinH> Ask questions and we can help
20:47:06 <ReinH> Try things yourself, experiment
20:48:40 <ReinH> Qer: work carefully through each function definition. The answers are right at your fingertips and you'll be able to reach them soon!
20:49:14 <Qer> ReinH: I love how he switched boxes and columns into rows to prevent code redundancy
20:49:23 <ReinH> Yep
20:49:45 <ReinH> Btw this is an algebraic result from the group of symmetries of the square :)
20:50:06 <ReinH> The boxes one is a different symmetry group actually
20:50:59 <ReinH> Qer: are you familiar at all with graphics programming?
20:51:00 <Qer> I don't see square symetries there
20:51:02 <Qer> care to explain?
20:51:10 <Qer> not really
20:51:28 <ReinH> Flipping a square is symmetric: the square looks the same when you're done.
20:51:57 <ReinH> Transpose on a grid is a diagonal flip
20:52:19 <ReinH> It is self inverse: flipping and flipping again give you exactly the same square
20:52:24 <Qer> yeah
20:53:04 <ReinH> If you can transform the grid into a configuration you already know how to deal with
20:53:08 <ReinH> And then transform back
20:53:25 <ReinH> You just need to write the "operate on the grid" function once
20:53:51 <ReinH> And do it "under" these invertible transformations
20:54:06 <Qer> you mean the thing with columns and rows and boxes? that he switched them all to rows?
20:54:25 <ReinH> Yep. Rows are rows. That's the identity transform.
20:54:37 <ReinH> Columns can become rows. That's a diagonal flip.
20:54:43 <Qer> oh that's what you mean
20:54:46 <Qer> yeah i know that :D
20:54:51 <ReinH> Big are symmetries of the squar
20:54:57 <Qer> I once had to do a game I think, an assignment
20:55:13 <Qer> and I prefered to flip the whole board than to rewrite the function to work on a different axis :D
20:55:39 <ReinH> Boxes are something a bit different.
20:55:42 <Qer> or not flip, just turn by 90 degrees
20:55:51 <ReinH> Yep.
20:56:02 <ReinH> This is group theory, the algebra of groups.
20:56:05 <Qer> sorry, english is not my other language ;d
20:56:27 <ReinH> He is using it implicitly here to reason about these program transformations.
20:56:45 <ReinH> Rotations are another symmetry of the square :)
20:57:30 <ReinH> A similar concept is used in graphics programming, where linear transformations give a symmetry between different camera positions
20:58:01 <Qer> my problem is that I don't really see what he did there
20:58:13 <ReinH> Where?
20:58:33 <Qer> oh, split is chop
20:59:14 <ReinH> The boxes one is not obvious. Try drawing the boxes on paper and numbering them. And see what happens to the numbers.
21:00:24 <ReinH> Write each intermediate state of the grid down.
21:00:42 <Qer> I just see that before packing and after unpacking
21:00:44 <Qer> he has the same list
21:01:13 <ReinH> You can just take it on faith that the boxes transform does what he says ;
21:01:16 <ReinH> ;)
21:01:52 <ReinH> The fact that it's a self inverse is rather nice though and is worth working through
21:02:34 <ReinH> Qer: anyway the meat is in the solve functions.
21:02:40 <Qer> I know about the inverses, I had algebra, we had to do lots of those "is this subset a group? of a half-group?" etc
21:03:23 <ReinH> Btw the boxes symmetry is a group action on the set of coordinates of the grid :)
21:03:23 <Qer> I know that they symmetries are groups, so they have a neutral element etc
21:03:28 <Qer> I just don't know what he did there
21:03:42 <Qer> what was his purpose
21:03:50 <ReinH> Ah
21:04:06 <ReinH> Do you know the rules of sudoku?
21:04:13 <Qer> yea
21:04:27 <Qer> just tell me what he wanted to achieve with the boxes ;d
21:04:44 <ReinH> He wants to check if the numbers in each box are right
21:04:52 <ReinH> And he can only validate rows
21:04:56 <Qer> wait
21:04:57 <Qer> lol
21:05:01 <Qer> I just noticed that
21:05:06 <ReinH> So he has to turn boxes into rows
21:05:18 <Qer> the list changed from  [[1,2,3,4]... into  [[1,2,5,6]...
21:05:21 <ReinH> Rather than write a separate validation function for boxes
21:05:25 <ReinH> Yep
21:05:26 <Qer> I thought it remains unchanged
21:05:29 <Qer> wow, see
21:05:35 <Qer> I'm too dumb when it's 6 AM :D
21:05:43 <ReinH> Nope you're fine :)
21:06:43 <Qer> oh damn dude
21:06:49 <Qer> with the sequence thing, there's a problem
21:06:49 <ReinH> :)
21:06:52 <Qer> at least with my vision of it
21:06:56 <ReinH> Oh no
21:07:12 <Qer> because when we have a sequence and prune the first possibility
21:07:27 <Qer> we want the whole tree that starts there to go away
21:07:37 <ReinH> Ah
21:07:46 <Qer> whereas when using "sequence" function, we would have to deal with all the leaves of the tree seperately
21:07:50 <ReinH> Ok, maybe you do want a tree
21:07:58 <ReinH> And a tree pruning algo
21:07:58 <Qer> and this is exactly what we want to avoid
21:08:01 <Qer> but he did it somehow, right?
21:08:03 <ReinH> Yep
21:08:10 <Qer> with trees?
21:08:20 <ReinH> No he just prunes them all
21:08:56 <ReinH> The whole tree goes away in that each list with that prefix gets pruned
21:09:23 <ReinH> So there is some duplicate work
21:09:25 <Qer> but he has to iterate through the whole list?
21:09:31 <Qer> it sucks
21:09:37 <ReinH> Well, it might suck
21:09:52 <Qer> I think a tree is best for
21:09:52 <ReinH> But it was sufficient to write a pretty efficient sudoku solver
21:09:55 <Qer> for me*
21:09:56 <ReinH> Sure
21:10:27 <ReinH> Haskell has other tools for this. This is just the simplest one ;)
21:11:02 <Qer> well i gotta go
21:11:07 <Qer> thank you for everything mate :)
21:11:13 <Qer> you helped me a lot
21:11:15 <Qer> good bye ;)
21:11:19 <ReinH> Ofc please come back :)
21:18:45 <Qer> hey hey, not so fast!
21:18:47 <Qer> in this example: http://lpaste.net/104626
21:19:04 <Qer> why does (++) on the two branches copy the previous calculations?
21:19:46 <Qer> should't it just concat the two branches?
21:20:38 <glguy> Which alternative are you asking about?
21:21:33 <Qer> input: [1, 42, 3] output: [[1, 41, 3, 43, 3]]
21:22:35 <Qer> oh, there's a map... hmm lemme think about it
21:22:43 <ReinH> Qer: compare to: map (\x -> if x == 42 then [41,43] else [x])
21:22:59 <ReinH> You are recursing too much
21:23:11 <ReinH> You want to treat each element once
21:25:40 <Qer> where is that too much recursion?
21:26:37 <Qer>  oh I see
21:26:39 <ReinH> Work out what map is doing there :)
21:26:43 <Qer> how this works
21:26:48 <Qer> so no magic there
21:26:53 <ReinH> Replace it with its definition
21:27:00 <ReinH> @src map
21:27:01 <lambdabot> map _ []     = []
21:27:01 <lambdabot> map f (x:xs) = f x : map f xs
21:27:23 <Qer> I forgot it was working on a list of lists, not simply a list...
21:27:29 <ReinH> :)
21:29:50 <Qer> my problem is that I won't know how many possibilities there are
21:29:53 <Qer> not just 2
21:30:00 <Qer> there will be n, and not all will be valid...
21:30:06 <Qer> I think I should really go to bed now ;d
21:30:21 <Qer> with a fresh mind I'll do better
21:30:44 <Qer> it's just that it's so addictive
21:33:19 <ReinH> Read the rest of the sudoku solver. It handles these things.
21:33:25 <Qer> gnight ;D now for good
21:33:36 <ReinH> Bye
21:33:41 <Qer> ReinH
21:33:47 <Qer> my assigment is harder than sudoku ;<
21:33:59 <Qer> I wish it were sudoku ;d
21:34:03 <ReinH> Maybe
21:34:17 <Qer> well of course this guy did it beautifully
21:34:22 <ReinH> Anyway you can do more with lists of lists than you think :)
21:34:30 <Qer> and I won't do code like that in Haskell in the nearest time
21:34:41 <ReinH> So just check before you decide it won't work :)
21:34:48 <Qer> no no, it will work
21:34:55 <ReinH> Sudoku is too big to brute force too
21:35:51 <ReinH> The answer might be a "smarter" sequence that evaluated choices one at a time
21:35:59 <ReinH> Bird implements this ;)
21:36:28 <Qer> no no, I'll just do the lists of lists
21:36:34 <Qer> it will work good
21:36:36 <Qer> as I predict
21:36:38 <ReinH> This is still the list of lists!
21:36:39 <Qer> work well*
21:37:04 <ReinH> It's about how new choices are added
21:37:13 <ReinH> The tree is there, it's just implicit!
21:37:42 <ReinH> It's in the structure if the computation, not the data
21:37:49 <ReinH> *of
21:37:50 <Qer> a tree?
21:37:58 <Qer> oh, when computing
21:37:59 <Qer> yeah there is
21:38:02 <ReinH> That's the magic I wanted to show you :)
21:38:02 <Qer> I see the tree ;d
21:38:09 <nisstyre> tree recursion
21:38:11 <nisstyre> read SICP
21:38:19 <ReinH> Exactly
21:38:34 <ReinH> The pruning is there
21:38:51 <ReinH> It's all there! And it's amazing!
21:39:39 <ReinH> And it's all done in simple steps from the naive sequence solution
21:39:50 <Qer> where can I find it?
21:39:56 <ReinH> That sort of program transformation is a big part of the usefulness of Haskell
21:40:00 <nisstyre> understanding/grokking things like tree recursion will make a lot of things easier to program
21:40:11 <nisstyre> most of them are things people think are hard to write too
21:40:22 <ReinH> Read the section called "Making choices one at a time" in the sudoku solver
21:40:27 <ReinH> Really work through it
21:40:31 <nisstyre> usually because their idea of computation is too imperative
21:40:45 <ReinH> Consider how laziness is working here
21:43:44 <Qer> okay guys, im now seriously turning off the computer ;D
21:43:45 <Qer> bb
21:43:48 <Qer> see you around
21:44:29 <eazar001> ]= poor processor, turning off your computer is really bad.
21:44:44 <nisstyre> also bad for your hard drive
21:44:51 <eazar001> ]=
21:45:09 <Welkin> what about suspend?
21:45:15 <nisstyre> that's fine
21:45:23 <eazar001> really?
21:45:29 <nisstyre> although I have no swap partition
21:45:32 <eazar001> Does temperature drop occur for suspend?
21:45:40 <nisstyre> (which means you can't do some other things)
21:45:51 <nisstyre> eazar001: temperature is related to CPU usage mostly
21:46:09 <eazar001> oh so, youre basically saying it's okay for HDD, but no really for CPU
21:46:16 <eazar001> errrr
21:46:24 <nisstyre> most of the time your computer should be relatively cool/lukewarm
21:46:29 <nisstyre> if you're treating it right
21:46:38 <nisstyre> i.e. not putting a laptop on a blanket or something
21:46:45 <eazar001> i heard it was mainly the delta that hurts your cpu the most
21:46:47 <nisstyre> or compiling Firefox
21:47:42 <eazar001> oh well i'm going to manually compile all my system updates now [=
21:47:45 <nisstyre> eazar001: well I mean if it writes everything to the disk then that's writing to the disk every time
21:47:45 <eazar001> j/k
21:48:11 <nisstyre> but I have no swap just because I have no personal need for it
21:48:24 <eazar001> how much RAM do you have?
21:48:30 <nisstyre> 8 gigs on this computer
21:48:35 <eazar001> ooooh
21:48:37 <eazar001> higher roller
21:48:40 <nisstyre> my other ones have like 4 or something
21:48:45 <eazar001> i kinda of need it myself
21:48:48 <eazar001> 2 GB here
21:48:53 <eazar001> and its DDR2
21:49:46 <eazar001> there are actually some packages that i can't compile without my swap enabled
21:49:56 <eazar001> mlton compiler being one of them
21:52:21 <nisstyre> eazar001: compiling with swap is going to be slow as hell though
21:55:08 <platz> hrm looks like there is no casMVar found by hogle http://bit.ly/1oyjJTc
21:55:46 <platz> maybe casMVar isn't really useful
22:44:26 <orzo> i'm translating some C into haskell, and i thought I'd use StateT for some fo the c code's variables
22:44:37 <orzo> i'm not sure if i want lazy or strict StateT though
22:45:13 <orzo> the state will be a list or list-like structure accumulating contents to return
22:48:31 <Ralith> orzo: you probably want a writer instead, then...
22:48:58 <orzo> oh ok
22:51:22 <platz> only assuming the accumulation happens in a particular way
22:52:30 <platz> that doesn't depend on the previous values written
22:52:59 <orzo> hm, well the c code has a macro that will eitehr add a condition to a list to report, or fail immediately, depending on what the user requested
22:53:11 <orzo> and it uses that a bunch
22:54:27 <orzo> so my state is this accumulation of errors
22:55:35 <orzo> i think maybe i should make the macro be a typeclass method and make two different monad types that implement it
22:55:49 <orzo> that way you select the behavior by selecting the return type
22:55:55 <platz> well StateT is more general than WriterT, might give you more flexibility
22:56:46 <johnw> you could also use an update monad, to blend the two behaviors
22:57:03 <johnw> i.e. https://github.com/jwiegley/notes/blob/master/Update.hs
23:04:34 <orzo> johnw: will that take care of short circuiting if the user doesnt want the process to continue?
23:05:01 <johnw> for that you'll need EitherT on top of WriterT
23:05:13 <johnw> (or the other way around, if you want the errors up to the error)
23:30:54 * hackagebot cryptohash 0.11.5 - collection of crypto hashes, fast, pure and practical  http://hackage.haskell.org/package/cryptohash-0.11.5 (VincentHanquez)
23:31:32 <Tjr> Dear experts, I'd like to generate expressions such as [[],[[]],[[],[[]]]]. This code works and does almost what I want: http://lpaste.net/104630
23:31:59 <Tjr> It generates things such as Nested [ Nested [], Nested[ Nested[]], ... ].
23:32:10 <Tjr> Can I get rid fo the "Nested" constructor?
23:32:14 <carter> nope
23:32:30 <carter> welllllll
23:32:33 <carter> hrm
23:32:39 <Tjr> the frontend lets me type [[],[[]],[[],[[]]]]
23:32:41 <carter> :t [[],[[]],[[],[[]]]]
23:32:43 <lambdabot> [[[[t]]]]
23:32:52 <carter> Tjr: you need to pick your max amount of nesting
23:32:56 <carter> if you can pick that, sure
23:32:59 <carter> if you cant, nope
23:33:08 <Tjr> ok, so that clears it up.
23:33:28 <carter> :t "is your friend"
23:33:29 <lambdabot> [Char]
23:33:34 <carter> Tjr: try :t out
23:34:14 <Tjr> carter: excellent, that's what I wished existed.
23:34:22 <carter> Tjr: try it out
23:34:23 <carter> :)
23:34:27 <carter> it works in ghci too
23:34:35 <carter> have you seen stephens docks?
23:34:47 <carter> @google haskell tutorial 2.0 diehl
23:34:49 <lambdabot> http://dev.stephendiehl.com/hask/
23:34:49 <lambdabot> Title: What I Wish I Knew When Learning Haskell ( Stephen Diehl )
23:34:54 <Tjr> I'm not good at names, which ones are stephens?
23:34:54 <carter> read that :)
23:35:05 <carter> *documents
23:35:06 <carter> that one
23:35:12 <carter> http://dev.stephendiehl.com/hask/
23:36:48 <Tjr> I bet some hacker gave that tutorial to a newbie, and got asked Why does Haskell have Home Owner's Associations?
23:36:55 <Tjr> (HOAs)
23:37:59 <carter> hah
23:39:45 <Tjr> Yesterday there was this huge fight in this channel because cabal seemed to do a poor job of dependency resolution. Do people typically use cabal? What are the alternatives?
23:40:08 <carter> use cabal
23:40:10 <carter> or die
23:40:22 * Tjr dies a bit, just to try it out.
23:40:23 <carter> people just like bitching about stuff that sin't perfect
23:40:31 <Tjr> ok
23:40:33 <carter> no package management tool is perfect
23:40:40 <carter> cabal is nice and always getting better
23:41:19 <carter> use it :)
23:41:29 <carter> it never going to be perfect
23:41:31 <carter> but its pretty good
23:41:33 <Tjr> :-)
23:41:42 <carter> theres some quirks, as with anything thats not trivial
23:41:55 <carter> but when confused, holler for help and someone can probably help you
23:42:09 <carter> you'll know you're starting to be a power use when you write your first custom setup.hs file
23:42:16 <carter> which is scary as hell the first itme
23:55:42 <AfC> carter: how much of cabal is in the top level binary and how much of it is in the library? Any idea?
23:58:06 <warpy> carter: so i ran into a cabal limitation, it doesnt support meta packages
23:58:28 <carter> using CLOC
23:58:32 <carter>  55196 LOC for cabal
23:58:40 <carter> 19018 for caba-linstall
23:58:57 <warpy> like a parent cabal file in which you can indicate the sub projects' cabal files
23:59:09 <warpy> and it builds all the sub projects in correct order
23:59:17 <warpy> carter: any idea if this is possible
23:59:42 <carter> warpy: cabal sandbox add-source
