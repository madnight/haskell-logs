00:00:08 <MasterMastic> Count on it
00:00:09 <carter> the gui design space is a tricky one
00:00:16 <carter> you may wanna just do a different native gui per OS
00:00:16 <MasterMastic> Aye; tbh I loathe it hehe
00:00:40 <carter> or just embrace the terrible simplicity of somthing like threepenny and have protability
00:00:42 <carter> *portability
00:01:09 <MasterMastic> I'll give it a go, and if it won't work out I'll try to figure out again how I could build gtk or whatevs
00:01:15 <MasterMastic> Thanks again ^^
00:01:21 <carter> np
00:01:27 <carter> merry focus and happy hacking
00:01:37 <carter> 7.8 or 7.6?
00:01:37 <arj> what is the difference between WHNF and HNF?
00:01:51 <arj> or is there no difference?
00:01:58 <carter> theres no such thing as HNF, just whnf and nf
00:02:08 <carter> whnf is roughtly what lazy evaluation does
00:02:20 <carter> for the expresion f a
00:02:25 <carter> you need to evaluate f but not a
00:02:32 <carter> f being in head position
00:02:38 <arj> ok, because in the docs for seq it says: "Evaluates its first argument to head normal form, and then returns its second argument as the result."
00:02:48 <arj> thus, they mean whnf?
00:02:48 <carter> yup
00:02:54 <carter> yes
00:03:01 <arj> ok, thanks
00:03:03 <carter> well
00:03:03 <Iceland_jack> arj: HNF is a concept distinct from WHNF
00:03:04 <carter> hrmm
00:03:05 <Iceland_jack> but not in Haskell
00:03:15 <carter> i'm tired
00:03:18 <carter> ignore me
00:03:21 <carter> listen other people
00:03:22 <carter> ngith
00:03:42 <arj> hehe carter
00:03:48 <arj> n8
00:04:50 <Iceland_jack> WHNF is either HNF or a lambda abstraction
00:05:12 <arj> Iceland_jack: so, in HNF the body of the lambda exp must be reduced, too?
00:05:32 <Iceland_jack> no, it's just about top-level
00:06:00 <arj> so, this is in WHNF, correct \ x . ((\ y . y+x) 2)  ?
00:06:13 <Iceland_jack> yes
00:06:37 <arj> what would be the HNF equivalent? \x. 2+x ?
00:06:37 <rekahsoft> hi all..as i was refreshing my memory on error handling from the book "Real World Haskell" i found something funky. take a look: http://lpaste.net/104200
00:07:09 <Iceland_jack> arj: What do you mean ‘HNF equivalent’?
00:07:13 <blackbeard> hello. Hope I am not intruding. Is there a good haskell tutorial for a n00b like me? I want to learn FP...
00:07:22 <Iceland_jack> blackbeard: Learn You a Haskell
00:07:23 <Iceland_jack> @where lyah
00:07:23 <lambdabot> http://www.learnyouahaskell.com/
00:07:34 <Iceland_jack> You can also use lambdabot to evaluate expressions and query types
00:07:36 <arj> Iceland_jack: reducing the term until whe got a HNF (I assumed HNF is stricter than WHNF)
00:07:42 <Iceland_jack> > map toUpper "Hello, World!"
00:07:43 <lambdabot>  "HELLO, WORLD!"
00:07:59 <Iceland_jack> arj: You can't reduce that further since it's not a redex
00:08:13 <arj> well, maybe not in haskell
00:08:21 <arj> ok, but in Lambda calculus I can.
00:08:38 <skuggi> arj: no, you can't.
00:08:51 <arj> skuggi: why not?
00:09:05 <skuggi> arj: ok, tell me what you would reduce it to
00:09:31 <Iceland_jack> blackbeard: Good luck on your Haskell journey :)
00:09:47 <arj> well, \ x . ((\ y . y+x) 2)  --beta--> \x . 2 + x
00:10:34 <blackbeard> Iceland_jack: Thank you. I will be back on this channel after going through that site. I will ask for more advice then
00:10:37 <rekahsoft> oops the code didn't have the on purpose error
00:11:22 <arj> skuggi: or did I make a mistake?
00:12:44 <redtricycle> What function can help me convert a string to an http-safe string to put into a GET msg?
00:12:57 <rekahsoft> so in the paste ^ the divBy is right and the divBy' is wrong (because the RHS of the second line defining safeDiv isn't wrapped with Just..but GHC infers a type???
00:12:59 <redtricycle> i.e. all the spaces are escaped to %20, ampersands, and all that
00:16:20 <rekahsoft> anyone? why is ghc infering such a type (that is seemingly useless?)
00:16:20 <Iceland_jack> rekahsoft: Let me take a look
00:16:36 <rekahsoft> http://lpaste.net/104200
00:16:52 <rekahsoft> the first function is correct and the second function is intentionally wrong but typechecks
00:16:59 <rekahsoft> Iceland_jack: also thanks :)
00:17:01 <Iceland_jack> rekahsoft: Right, you're treating 'Maybe a' as a number
00:17:42 <rekahsoft> Iceland_jack: yes but it tupechecks and ghc infers the wierd type i give in a comment
00:17:53 <Iceland_jack> Yes, that you can tell from the type
00:18:02 <Iceland_jack>     Integral (Maybe b) ...
00:18:41 <Iceland_jack>     Integral X
00:18:41 <Iceland_jack> means that GHC thinks 'X' is an integral value (integer)
00:19:26 <Iceland_jack> rekahsoft: (it's because you're missing 'Just')
00:19:40 <rekahsoft> Iceland_jack: awe..but theres no instance Integral Maybe
00:19:45 <Iceland_jack> That's right :)
00:20:07 <rekahsoft> Iceland_jack: i know..the function above fixes the issue (i noticed the error in a code segment in "Real World Haskell"
00:20:28 <Iceland_jack> Okay so you want to understand why it happens or why it works?
00:22:31 <Iceland_jack> If you want to understand why it “works” look at
00:22:31 <Iceland_jack>     fux True  = Nothing
00:22:31 <Iceland_jack>     fux False = div 20 5
00:22:31 <Iceland_jack> in isolation
00:30:43 <Iceland_jack> and try to make sense of the resulting type
00:30:43 <rekahsoft> Iceland_jack: yes..wrap with Just of course..so that both RHS of safeDiv have type Integral a => a
00:30:43 <Iceland_jack> rekahsoft: You mean 'Integral a => Maybe a'
00:30:44 <rekahsoft> Iceland_jack: lol crap yes
00:30:44 <rekahsoft> Iceland_jack: srry typo..
00:30:44 <Iceland_jack> no worries!
00:30:44 <rekahsoft> Iceland_jack: the thing that gets me is that div has type 'Integral a => a -> a -> a'
00:30:45 <Iceland_jack> You can pretend it has type
00:30:45 <Iceland_jack>     div :: Integer -> Integer -> Integer
00:30:45 <Iceland_jack> or
00:30:45 <Iceland_jack>     div :: Int -> Int -> Int
00:30:45 <rekahsoft> Iceland_jack: yes 'parametric polymorphism' no?
00:30:45 <Iceland_jack> no, ad-hoc polymorphism
00:30:45 <Iceland_jack> parametric polymorphism is something like
00:30:45 <Iceland_jack>     length :: [a] -> Int
00:30:46 <Iceland_jack> noo, jin_jin
00:30:46 <Iceland_jack> If you think of Integral as a set of permissible types it would be
00:30:46 <Iceland_jack>     Integral = { Int, Integer, Word, Int8, Int16, ..., Word8, Word16, ... }a
00:30:47 <Iceland_jack> Ad-hoc polymorphism is when you do (potentially) _different_ things for an arbitrary set of types
00:30:47 <Iceland_jack> Parametric polymorphism is when a function does the same thing
00:30:48 <rekahsoft> Iceland_jack: function does the same thing?
00:30:48 <Iceland_jack> 'len' doesn't change it behaviour whether its argument is a list of Ints or a list of functions
00:30:48 <Iceland_jack>     len []     = 0
00:30:48 <Iceland_jack>     len (x:xs) = 1 + len xs
00:30:49 <Iceland_jack> but 'div'
00:30:49 <Iceland_jack>     div :: Int     -> Int     -> Int
00:30:49 <Iceland_jack>     div :: Integer -> Integer -> Integer
00:30:49 <Iceland_jack> are very different functions
00:30:49 <rekahsoft> Iceland_jack: oops..got mixed up..its late..other examples parametric polymorphic functions would be foldr, foldl, filter?
00:30:49 <Iceland_jack> yes
00:30:54 <Iceland_jack> or 'id'
00:30:55 <Iceland_jack>     id :: a -> a
00:30:55 <rekahsoft> Iceland_jack: also i reference the error in "Real World Haskell": http://book.realworldhaskell.org/read/error-handling.html
00:31:02 <rekahsoft> Iceland_jack: search for divBy
00:31:16 <rekahsoft> Iceland_jack: its the same thing as what i have in paste tho
00:31:26 <Iceland_jack> there are many different definitions of divBy in that link
00:32:22 <Iceland_jack> but yes, there is a mistake in that code
00:32:33 <rekahsoft> Iceland_jack: ones divBy and the other divBy'
00:33:20 <rekahsoft> Iceland_jack: so using type classes to restrict types is ad-hoc polymorphism and functions which allow function the same give any value are called parametriclly polymorphic?
00:33:33 <Iceland_jack> Essentially yes
00:33:46 <Iceland_jack> You might be interesting in this https://news.ycombinator.com/item?id=7674974
00:34:00 <Iceland_jack> which is covers Wadler's original paper
00:34:15 <Iceland_jack> *which covers
00:34:46 <Iceland_jack> jin_jin: You're here!
00:35:00 <rekahsoft> Iceland_jack: alright so i thing i understand why ghc infers the wierd type in the paste..bear with me..
00:35:06 <rekahsoft> Iceland_jack: also i'll give it a read :)
00:35:14 <Iceland_jack> Sure rekahsoft :)
00:35:28 <Iceland_jack> do you understand this?
00:35:34 <Iceland_jack> :t [Nothing, div 0 1]
00:35:35 <lambdabot> Integral (Maybe a) => [Maybe a]
00:37:08 <srhb> Uhh
00:37:54 <Iceland_jack> (here is a direct link: homepages.inf.ed.ac.uk/wadler/papers/class/class.ps) “How to make ad-hoc polymorphism less ad hoc)
00:37:55 <rekahsoft> Iceland_jack: div has type "Integral a => a -> a -> a" so the arguments to safeDiv must be a member of the typeclass Integral.
00:38:09 <Iceland_jack> well it's not the arguments
00:38:19 <Iceland_jack> :t [Nothing, div 0 1] -- just think about it in the context of this expression
00:38:19 <lambdabot> Integral (Maybe a) => [Maybe a]
00:38:42 <Iceland_jack> 'div 0 1' must have the type
00:38:42 <Iceland_jack>     div 0 1 :: Integral a => a
00:38:52 <Iceland_jack> and Nothing has the type
00:38:52 <Iceland_jack>     Nothing :: Maybe a
00:39:01 <Iceland_jack> And you need to unify those two
00:39:10 <Iceland_jack> since elements in a list must have the same type
00:41:05 <rekahsoft> Iceland_jack: hmm..that just seems wrong...there is no instance for "Integral Maybe" is there?
00:41:10 <Iceland_jack> No there isn't
00:41:19 <Iceland_jack> but that's the type is must have for it to make sense
00:41:25 <rekahsoft> Iceland_jack: no i don't think you're wrong..i just think it seems weird
00:41:39 <Iceland_jack> it is :)
00:41:41 <rekahsoft> Iceland_jack: makes sense tho..if you were to define the instance it would become usable
00:42:03 <rekahsoft> just wierd to see two RHS of a function look like they obviously wouldn't type check
00:42:15 <Iceland_jack> of course it's trivial to make an instance for Integral (Maybee a)
00:42:42 <rekahsoft> yes but you would have to restrict the type of 'a' to Integral no?
00:42:59 <Iceland_jack> for you have to do
00:42:59 <Iceland_jack>     instance Num a  => Num (Maybe a) where fromInteger = Just . fromInteger
00:42:59 <Iceland_jack>     instance Real a => Real (Maybe a)
00:42:59 <Iceland_jack>     instance Enum a => Enum (Maybe a)
00:43:15 <Iceland_jack> then you have to do
00:43:15 <Iceland_jack>     instance Integral a => Integral (Maybe a) where
00:43:15 <Iceland_jack>         div = liftM2 div
00:43:38 <Iceland_jack> and then you can do
00:43:38 <Iceland_jack>     ghci> [Nothing, div 24 4]
00:43:38 <Iceland_jack>     [Nothing, Just 6]
00:44:03 <Iceland_jack> you can then define 'div' in the Integral instance to be
00:44:03 <Iceland_jack>     div = safeDiv
00:44:42 <Iceland_jack> or
00:44:43 <Iceland_jack>     div n 0 = Nothing
00:44:43 <Iceland_jack>     div n m = liftM2 div n m
00:45:10 <Iceland_jack> and then you can do
00:45:11 <Iceland_jack>     ghci> [Nothing, div 24 3, div 24 0]
00:45:11 <Iceland_jack>     [Nothing, Just 8, Nothing]
00:45:15 <Iceland_jack> ((but you shouldn't))
00:46:26 <Iceland_jack> So GHC is not *wrong* in inferring that instance, since it may exist
00:47:17 <rekahsoft> Iceland_jack: in the instances you mentioned above obviously you'd have to fill in the required function (for eg according to the docs a minimal complete definition of Num is "(+), (*), abs, signum, fromInteger, (negate | (-))"
00:47:33 <Iceland_jack> rekahsoft: Normall yes, but not for the example I provided
00:47:40 <Iceland_jack> *Normally
00:47:57 <Iceland_jack> My example only used the 'fromInteger' and 'div' class methods
00:47:58 <rekahsoft> Iceland_jack: yes i understand now how ghc is not wrong because i may define an instance..the type can exist..theres just a missing instance
00:48:09 <Iceland_jack> Yes, you might even define it in some other module
00:48:14 <Iceland_jack> who knows
00:48:56 <rekahsoft> Iceland_jack: understandable :)
00:49:31 <Iceland_jack> you can also do
00:49:31 <Iceland_jack>     foo True  = Nothing
00:49:31 <Iceland_jack>     foo False = 5
00:49:46 <Iceland_jack> which gives you the type
00:49:46 <Iceland_jack>     foo :: Num (Maybe a) => Bool -> Maybe a
00:50:02 <qnikst> Iceland_jack: foo Falst = Just 5
00:50:13 <Iceland_jack> qnikst: no
00:50:16 <rekahsoft> Iceland_jack: lol and this is why toplevel type signatures are nice :P
00:50:22 <Iceland_jack> Indeed :)
00:50:49 <srhb> Overloaded number literals make things weird like this in general.
00:50:51 <rekahsoft> Iceland_jack: also very informative :) you're awesome :P lol
00:50:52 <Iceland_jack> qnikst: That was the entire point of this conversation
00:50:58 <srhb> The same happens with string literals if you overload those.
00:51:15 <Iceland_jack> srhb: Yes, overloading is a double-edged sword like that
00:51:21 <qnikst> Iceland_jack: ok I see
00:51:24 <srhb> Indeed.
00:51:36 <Iceland_jack> rekahsoft: Yes I went a bit overboard in spamming the channel
00:51:38 <srhb> I was just giving pointers to why one might see this
00:51:46 <srhb> Iceland_jack: It's fine, everyone's asleep :-)
00:51:56 <rekahsoft> Iceland_jack: well i appreciate it..
00:51:57 <Iceland_jack> hehe :) hopefully not because of me
00:52:04 <rekahsoft> srhb: sleep, o come on lol :P
00:52:37 <Iceland_jack> I should make quesadillas today
00:53:07 * hackagebot safecopy 0.8.3 - Binary serialization with version control.  http://hackage.haskell.org/package/safecopy-0.8.3 (DavidJohnson)
00:53:29 <Iceland_jack> there are quite a few errors in RWH though
00:54:16 <srhb> rekahsoft: What you said about top level signatures -- the same applies for fixing any one of the types inside the function definition, since that stops the literals from being overloaded in the sense of the definition
00:54:28 <srhb> rekahsoft: ie. foo True = Nothing; foo False = 1 :: Int
00:54:47 <rekahsoft> Iceland_jack: first one i've found but it was a good read overall..(i was just cruising the chapter on error handling)
00:54:48 <Iceland_jack> yes, I tend to write out type signatures of local definitions
00:55:01 <Iceland_jack> especially when they become trickier
00:55:19 <srhb> This is useful since you mostly never want to create an instance SomeNum a => Maybe a, etc.
00:55:22 <rekahsoft> srhb: yes i follow :P
00:55:42 <rekahsoft> Iceland_jack: do you need a language extension for local signatures (in where clauses)
00:55:48 <Iceland_jack> rekahsoft: no no
00:56:13 <rekahsoft> Iceland_jack: awesome :) using them from now on :P
00:56:23 <rekahsoft> don't know why i never thought of using them before
00:56:26 <srhb> Only if you want them to refer to type variables in the TLD
00:56:43 <Iceland_jack> Yes, you may need ScopedTypeVariables in that case
00:57:46 <rekahsoft> o alright
00:58:01 <Iceland_jack> but you should be fine without that for most uses
00:58:23 <rekahsoft> i understand..so if you want to use the tupe of the 'outer function - the one with the where clause'
00:58:27 <srhb> It can be useful for "hole driven development" but since we have real typed holes now it's less useful
00:58:41 <Iceland_jack> rekahsoft: yes
00:58:55 <Iceland_jack> it can also be useful if you're doing some existential magic
00:59:05 <wojtekM_> What does ~ in swap in https://hackage.haskell.org/package/base-4.7.0.0/docs/src/Control-Arrow.html mean?
00:59:21 <srhb> wojtekM_: It's a lazy pattern match
00:59:22 <Iceland_jack> wormphle1m: lazy pattern probably
00:59:24 <rekahsoft> i'm reading http://www.haskell.org/haskellwiki/Scoped_type_variables and see that it mentions the 'monomorphism restriction'
00:59:26 <srhb> Ie. it will always match
01:00:25 <srhb> > let foo ~1 = "This is fine!" in foo 42
01:00:26 <lambdabot>  "This is fine!"
01:01:08 <rekahsoft> srhb: what does '~1' mean in your let expression
01:01:11 <rekahsoft> ?*
01:01:11 <lambdabot> Maybe you meant: v @ ? .
01:01:21 <srhb> rekahsoft: It's a lazy pattern match. It simply always matches
01:01:31 <srhb> (ie. we don't evaluate the constructor)
01:02:12 <srhb> let foo ~x = "ok" in foo undefined --perhaps this is clearer
01:02:15 <Iceland_jack>     foo ~1 = 5
01:02:15 <Iceland_jack> will always evaluate to 5
01:02:15 <srhb> Er
01:02:25 <srhb> > let foo ~x = "ok" in foo undefined
01:02:26 <lambdabot>  "ok"
01:02:35 <Iceland_jack> > let foo ~1 = 5 in foor 1
01:02:36 <lambdabot>  Not in scope: ‘foor’
01:02:36 <lambdabot>  Perhaps you meant one of these:
01:02:36 <lambdabot>    ‘foo’ (line 1), ‘floor’ (imported from Prelude),
01:02:36 <lambdabot>    ‘T.for’ (imported from Data.Traversable)
01:02:36 <Iceland_jack> > let foo ~1 = 5 in foo 1
01:02:38 <lambdabot>  5
01:02:39 <Iceland_jack> > let foo ~1 = 5 in foo 5100
01:02:40 <Welkin> what is the ~?
01:02:41 <lambdabot>  5
01:02:50 <srhb> Welkin: It's juts syntax that means "this pattern is lazy"
01:03:11 <wojtekM_> okay, thanks, I will read about it
01:03:28 <awestroke> srhb: when are patterns not lazy?
01:03:40 <srhb> awestroke: When they're not preceded by ~
01:03:50 <srhb> let foo x = 5 in foo undefined
01:03:52 <rekahsoft> srhb: thats neat..if i use a strict patter (default) it would fail no?
01:03:53 <srhb> Gah
01:03:56 <srhb> > let foo x = 5 in foo undefined
01:03:57 <lambdabot>  5
01:03:59 <srhb> oh wait
01:04:02 <srhb> That wouldn't work
01:04:13 <srhb> > let foo 2 = 5 in foo undefined
01:04:15 <lambdabot>  *Exception: Prelude.undefined
01:04:32 <awestroke> > let foo ~2 = 5 in foo undefined
01:04:34 <lambdabot>  5
01:04:47 <awestroke> ????
01:04:47 <srhb> There, the pattern is evaluated, which causes an exception because the argument is undefined. Even "looking at it" for the pattern match causes the exception to fire.
01:04:51 <srhb> Hehe.
01:05:33 <awestroke> why is undefined matched to 2?
01:05:37 <pavonia> > let foo ~(Just x) b = if b then x else 0 in foo Nothing False
01:05:37 <srhb> It isn't
01:05:38 <lambdabot>  0
01:05:43 <pavonia> > let foo ~(Just x) b = if b then x else 0 in foo Nothing True
01:05:45 <lambdabot>  *Exception: <interactive>:3:5-40: Irrefutable pattern failed for pattern (Da...
01:05:46 <srhb> undefined is never evaluated.
01:05:47 <Welkin> so what is the difference between these two?
01:05:57 <Welkin> let foo ~x = 5 in foo undefined
01:06:03 <Welkin> let foo _ = 5 in foo undefined
01:06:11 <srhb> Welkin: None since you're never using x
01:06:29 <Iceland_jack> Lazy patterns are kind of a boring feature imo
01:06:32 <Welkin> when would it be beneficial to use ~?
01:06:51 <rekahsoft> Iceland_jack: i don't see much use for them either?
01:07:02 <rhaps0dy> what does the ~ mean ? (newbie here)
01:07:08 <Iceland_jack> rekahsoft: There are uses for them, there are a lot of references for them online
01:07:09 <awestroke> when you want confusing behaviour, it's great
01:07:11 <Iceland_jack> rhaps0dy: lazy patterns
01:07:18 <rhaps0dy> huh
01:07:22 <srhb> http://en.wikibooks.org/wiki/Haskell/Laziness#Lazy_pattern_matching
01:07:51 <Iceland_jack> Not trying to be snarky, online resources can explain this better than I can
01:08:07 <Welkin> well, there are always new things to learn in haskell
01:08:17 <Welkin> and I learn something new every time I look into this channel
01:08:28 <rhaps0dy> srhb: oh
01:08:31 <rhaps0dy> thanks
01:09:25 <srhb> It's often useful when doing tweaking to "when things are actually evaluated" particularly for recursive functions
01:09:27 <enthropy> > let extralazyId ~ ~ ~x = x in extralazyId undefined
01:09:28 <lambdabot>  *Exception: Prelude.undefined
01:09:30 <srhb> I'd say it's a semi-advanced topic though
01:10:05 <rhaps0dy> lazy pattern matching looks sloppy though
01:10:11 <rhaps0dy> as in it doesn't actually match your patterns
01:10:12 <merijn> Also, it's a topic where you'll realise you need when you do :)
01:10:19 <rhaps0dy> oh, okay
01:10:21 <rhaps0dy> then I'll leave it lol
01:10:42 <srhb> Now you know it's there, you might some day get an AHA! I need a lazy pattern! ;)
01:11:14 <enthropy> > let foo jx b = let Just x = jx in if b then x else 0 in foo Nothing False
01:11:16 <lambdabot>  0
01:11:44 <merijn> rhaps0dy: It's not so much sloppy as it is a way of telling the compiler "just trust me, allright?" because in some cases you can prove a certain condition holds, even though the compiler can't see it
01:11:50 <enthropy> > let foo jx b = let Just x = jx in if b then x else 0 in foo Nothing True
01:11:52 <lambdabot>  *Exception: <interactive>:3:20-30: Irrefutable pattern failed for pattern Da...
01:11:56 <merijn> rhaps0dy: And this can be the compiler shut up and stop complaining :)
01:12:01 <enthropy> to translate pavonia's example
01:12:04 <merijn> s/can be/can tell
01:13:13 <Iceland_jack>     addUp ~[a, b] = a + b
01:13:14 <Iceland_jack>     addUp  xs     = sum xs
01:13:14 <Iceland_jack> gives
01:13:14 <Iceland_jack>     ghci> addUp [1,2]
01:13:17 <Iceland_jack>     3
01:13:20 <Iceland_jack>     ghci> addUp [1,2,3]
01:13:23 <Iceland_jack>     *** Exception: ...
01:13:47 <enthropy> Iceland_jack: that doesn't seem useful at all
01:13:48 <srhb> I can't really think of a single multiline equation where lazy patterns make sense.
01:13:51 <rhaps0dy> merijn: as in you only pass that function values than hold
01:13:52 <rhaps0dy> the typical
01:13:54 <Iceland_jack> They don't :)
01:13:58 <merijn> rhaps0dy: Yeah
01:14:01 <rhaps0dy> if x==3
01:14:05 <rhaps0dy> to test if it has increased to 3
01:14:10 <rhaps0dy> you know it won't pass because you increase by one
01:14:14 <Iceland_jack> except as an example that the branch is always taken
01:14:17 <rhaps0dy> alright
01:14:18 <srhb> Yes, okay.
01:14:57 <Iceland_jack> there are also plenty of multiline functions where they make sense for multivalues arguments or for nested lazy patterns
01:15:05 <Iceland_jack> but that's probably not what you meant
01:15:20 <ghorn_> i'm surprised I can't find a "Storable a => a -> Bytestring" function, it seems pretty straightforward
01:15:49 <merijn> ghorn_: What would you do with such a function?
01:16:08 <ghorn_> i want to send C structs over UDP
01:16:13 <enthropy> there are easy pieces to make one up I think
01:16:20 <merijn> ghorn_: Right, so that's exactly why it doesn't exist
01:16:32 <merijn> ghorn_: What if the other machine has a different byte order?
01:16:37 <merijn> ghorn_: Different CInt size?
01:16:47 <merijn> ghorn_: How would the remote machine interpret the ByteString?
01:16:54 <arj> when calling seq (length [1..]) b are these the reduction steps for length [1..] --> 1 + length [2..] --> 1 + 1 + length [3..] -> 2 + length [3...]   ?
01:16:54 <ghorn_> that's a good point
01:17:04 <merijn> ghorn_: You want to look into Binary/Cereal
01:17:24 <merijn> ghorn_: Those packages do binary serialisation that's not implementation dependent
01:18:09 * hackagebot RefSerialize 0.3.1.3 - Write to and read from ByteStrings maintaining internal memory references  http://hackage.haskell.org/package/RefSerialize-0.3.1.3 (AlbertoCorona)
01:18:12 <srhb> arj: No, it's 0 + 1 ...
01:18:34 <srhb> arj: Furthermore it uses unboxed Ints as an accumulating parameter, so it's always reduced
01:18:54 <ghorn_> merijn: in my case I'm only sending between processes on one computer, I'm already using cereal and zeromq but I need to send from haskell to C
01:19:26 <arj> srhb: ah, I see. thanks
01:19:32 <merijn> ghorn_: You can manually write serialisations using cereal
01:19:56 <srhb> arj: http://hackage.haskell.org/package/base-4.7.0.0/docs/src/GHC-List.html#length
01:20:07 <ghorn_> merijn: the structs are defined in C headers - I have a c2hsc and hsc2hs workflow right now
01:20:35 <arj> srhb: so with a # you create unboxed ints?
01:20:38 <srhb> arj: genericLength looks like you expect
01:20:48 <ghorn_> merijn: but you totally answered the question, which is that it is dangerous to do this
01:23:03 <srhb> arj: Unboxed types in general use the magical #
01:23:04 <merijn> ghorn_: You can just write a simple serialisation/deserialisation, though
01:23:04 <merijn> ghorn_: Take a look at Data.Serialize.Put, for encoding, writing a C decoder for whatever format you pick should be trivial
01:23:38 <srhb> arj: Also note how it's specialized via rules to strictGenericLength for result types Int or Integer
01:24:16 <arj> srhb: I didn't actually get the meaning of the rules
01:24:41 <srhb> arj: It means that genericLength is rewritten to strictGenericLength if the result type is either Int or Integer
01:25:32 <arj> srhb: to prevent it from building up a large number of thunks?
01:25:45 <srhb> arj: Yes
01:25:48 <ghorn_> merijn: I'm sorry to be difficult; my original goal was to keep the type definitions in only one place and not hand-maintain a (de)serializer; maybe the only way to do that safely is to use something like protobufs or json
01:26:02 <arj> srhb: cool, thanks a lot!
01:26:07 <srhb> arj: Or more precisely a huge amount of unevaluated (+)'es
01:26:27 <arj> yeah sure: (((0+1) + 2) + 3) ...
01:26:58 <srhb> arj: Other way around though
01:27:15 <srhb> 1 + (1 + (1 + ...)
01:27:44 <arj> ehm, yeah just looked at the reduction of foldl (+) 0 [1..] ...
01:27:51 <Welkin> right-folded thunks?
01:28:56 <enthropy> ghorn_: you have found Data.ByteString.Unsafe?
01:29:00 <srhb> Yes, the unspecialized version of genericLength is right-foldy.
01:29:39 <srhb> Erm, nonsense
01:29:47 <srhb> Left-foldy :-)
01:29:55 <ghorn_> enthropy: yes I have, thank you
01:30:20 <enthropy> so there are conversions between Ptr () and ByteString
01:30:21 <srhb> > foldl (+) 0 [a,b,c,d,e]
01:30:22 <lambdabot>  0 + a + b + c + d + e
01:30:27 <srhb> > foldr (+) 0 [a,b,c,d,e]
01:30:28 <lambdabot>  a + (b + (c + (d + (e + 0))))
01:30:32 <srhb> (OK, I'm wrong)
01:31:02 <arj> so which length reduction is correct, then?
01:31:10 <CindyLinz> Why could the lambdabot do the symbol computation!?
01:31:21 <arj> the second isn't it?
01:31:21 <srhb> genericLength is like foldr
01:31:23 <Welkin> lambdabot is special
01:31:27 <srhb> strictGenericLength is like foldl
01:31:29 <arj> ok
01:31:30 <srhb> foldl' actually
01:31:38 <Welkin> :t genericLength
01:31:39 <lambdabot> Num i => [a] -> i
01:31:45 <jle`> @src genericLength
01:31:45 <lambdabot> genericLength []    = 0
01:31:45 <lambdabot> genericLength (_:l) = 1 + genericLength l
01:31:46 <arj> because it involves, seq.
01:31:59 <srhb> and length = strictGenericLength :: [a] -> Int
01:32:15 <arj> why is strictness within a parameter not represented in the types?
01:32:30 <srhb> arj: Because that would make a somewhat different language
01:33:02 <arj> srhb: but still you have to think about stuff being strict or not at the moment.
01:33:17 <srhb> arj: You still do with strict types, if we don't seq at it we're never actually evaluating it
01:33:20 <arj> so a type system's hint would be nice
01:33:28 <srhb> arj: This is why seq works at all
01:33:34 <Iceland_jack> arj: there are languages that do it the othher way around
01:33:46 <Iceland_jack> That are strict with lazy annotations in the types
01:33:47 <arj> Iceland_jack: ocaml?
01:33:51 <Iceland_jack> (Idris)
01:34:48 <ziggystar> I'm trying for hours to get any of the SAT solver packages working that interface with minisat. E.g. the minisat2 package (from github) installs without errors. But in ghci, when loading the package, ghc complains with a linker error: unknown symbol `_ZN7Minisat3vecINS_3LitEE8capacityEi'; I got such a name-mangled linker error for the other minisat package too. But MiniSat2 appears to include all the needed C sources.
01:35:23 <ziggystar> So I'm wondering whether somthing is wrong with my setup.
01:47:18 <aspidites> did something change with "cabal list" or am i just using it wrong?
01:47:38 <aspidites> i could have sworn that before 1.20 i could issue "cabal list" and see all packages available on hackage
01:48:07 <aspidites> now i get "cabal: No sandbox exists at ~/.cabal-sandbox"
01:48:39 <dcoutts> aspidites: oh, that'll be a bug, please report it
01:48:48 <aspidites> in fact...cabal install does that
01:48:59 <aspidites> i wonder if something in my config is wrong....
01:49:01 <dcoutts> oh
01:49:15 <aspidites> dcoutts: that is, any cabal command does that now...
01:49:23 <dcoutts> aspidites: do you have a ~/.cabal-sandbox directory?
01:49:43 * dcoutts wonders if it finds part of a sandbox and then falls over
01:49:49 <aspidites> dcoutts: i have several, but not where i'm issuing the command
01:50:11 <aspidites> i create sandboxes in my ~/projecs directory, but i'm issuing from ~/ which only has .cabal
01:50:27 <dcoutts> right
01:50:48 <aspidites> and up until now thats never been a problem. in fact, i thought i was doing it right
01:51:09 <dcoutts> aspidites: just for testing, make a backup of your ~/.cabal/config and then delete the ~/.cabal/config, and try any of those commands again (it'll create a default one)
01:51:12 <ghorn_> merijn: i think I'm just going to use protobufs, thanks for the warnings
01:51:39 <aspidites> dcoutts: step ahead of you. i have a git repo with the most relevant config options in it so that i can nuke config if ever i need to
01:52:26 <exicer> I'm working with wreq and lens-aeson. I get a responseBody from a server that is json with two entries - "msg" and "response". I can see that both of these are populated from the response body. When I do body ^. key "msg" . _String, the msg string is shown. When I do body ^. key "response" . _String, I get "". Any idea why ?
01:54:19 <supki> exicer: can you paste the json you get?
01:54:19 <aspidites> dcoutts: no dice. completely nuked .ghc AND .cabal and still get the same errors
01:54:38 <aspidites> that said, i don't think it's on cabal's side because the default cabal install is v 1.18 and i know for a fact that was working before
01:54:49 <exicer> supki: It is really long, but will give it a go
01:55:33 <supki> exicer: well, ok, is response a string?
01:55:50 <exicer> supki: It should be a json object
02:06:03 <exicer> but can't that just be treated as a string when it isn't decoded ?
02:06:03 <supki> then _String will fail
02:06:03 <exicer> How come ?
02:06:03 <exicer> At that point, how does anything know it isn't text or whatever ?
02:06:03 <supki> everything's already parsed to a aeson's Value
02:06:03 <supki> by the time you use  key
02:06:03 <wojtekM_> Is it somehow possible to copy a few bytes from one value to another? I have data W = W1 !Word64 | W2 !Word64 !Word64 | ... up to W64. And I don't want to write 64^2 cases for mplus. Word64 serves me only for storage, the amount of bytes I want to copy is arbitrary within boundaries of the storage.
02:06:03 <exicer> supki: Ohh.
02:06:04 <exicer> supki: So if I instead to something like (decode $ body ^. key "response") :: Maybe whatever that should work ?
02:06:04 <supki> well, I'm not sure how incremental aeson's parsing is, but anyway, _String works on Value
02:06:04 <supki> that doesn't look right
02:06:04 <exicer> ah no, you are right. decode is for bytestrings
02:06:04 <supki> body ^? key "response" :: Maybe Whatever  I think
02:06:05 <exicer> Incidentally, is there something like hoogle taht works on more packages ?
02:06:05 <aspidites> dcoutts: i completely uninstalled both ghc and cabal-install and reinstalled them... same errors
02:06:05 <supki> or  body ^. key "response" :: Whatever  if Whatever is Monoid and you're happy to get mempty in case of failure
02:06:05 <dcoutts> aspidites: very weird
02:06:05 <aspidites> actually, i think i know what's going on.
02:06:06 <exicer> supki: Hm, still not working, but now I'm getting lens erorrs that I don't quite understand.
02:06:06 <aspidites> nope. nevermind. fuck
02:06:06 <aspidites> compile from source i guess?
02:06:06 <merijn> aspidites: Are you on OSX?
02:06:06 <aspidites> merijn: linux
02:06:06 <aspidites> Arch Linux to be specific
02:06:06 <merijn> aspidites: ok, nvm then :) It just trips my OSX spidey sense when someone says "I nuked .ghc/.cabal and things are still broken" :)
02:06:06 <aspidites> lol
02:06:06 <merijn> The platform uses a different directory on OSX, hence that result
02:06:06 <dcoutts> aspidites: definitely no ~/.cabal-sandbox, no dangling symlink or anything weird?
02:06:07 <aspidites> dcoutts: no, but that did offer a big hint
02:06:07 <aspidites> ls -al | grep .cabal > cabal.sandbox.config
02:06:08 <aspidites> to be clearn the > in that context is pointing to the relevant result, not the bash redirection operator :P
02:06:08 <exicer> Hm, okay so I need some way to go from Value to my type. Is there a function that directly does this ?
02:06:10 <aspidites> i think i was messing around with profiling for a project and forgot to cd before issuing a touch
02:08:08 <awestroke> exicer: http://hackage.haskell.org/package/aeson-0.7.0.5/docs/Data-Aeson.html#t:Value check out parseJSON in particular
02:08:50 <awestroke> fromJSON*
02:09:00 <aspidites> so in my case: palm >>= face
02:09:25 <aspidites> or maybe palm >> face, since i clearly ignored the input...
02:09:32 <supki> exicer: what errors?
02:09:37 <merijn> Wouldn't "palm <> face" be more appropriate?
02:09:50 <supki> exicer: you can use _JSON to convert Value to your type
02:10:01 <aspidites> i was thinking "bind"
02:10:12 <aspidites> wouldn't be the first time someone reached for monads when monoids would do though ;-)
02:10:13 <exicer> supki: awestroke: So using fromJSON j, where j is the Value associated with my datatype, I get     Couldn't match expected type `[Product]'
02:10:21 <exicer> with actual type `Result a0'
02:10:54 <awestroke> exicer: parsing can always fail, so you need to unpack the value by pattern matching
02:11:42 <exicer> awestroke: How do you mean?
02:12:15 <exicer> supki: I don't understand the type signature of _JSON, could you explain how you might use it ?
02:13:14 <bartavelle> hello, I have a ADT describing an interaction with a user. Those interactions all result in a distinct "return type". I would like to write something like data Backend = Backend { ..... , _interact :: Interaction -> a
02:13:28 <bartavelle> except if I want to write that, I must forall. it, and it makes no sense
02:13:35 <awestroke> exicer: fromJSON x can give you either Error String or Success a.
02:13:46 <bartavelle> humm
02:13:55 <supki> exicer: body ^? key "response"._JSON
02:14:23 <supki> exicer: it's a prism so it composes with other optics
02:14:51 <bartavelle> I am not sure what my question should be :)
02:14:54 <awestroke> bartavelle: so every interaction has it's own return type?
02:15:01 <supki> exicer: in one direction it decodes the data (so it can fail), in the other direction it encodes the data
02:15:03 <bartavelle> awestroke, it should yes
02:15:27 <bartavelle> I store it in an interaction to "replay" it if the target disconnects or something
02:15:36 <exicer> supki: Ah okay. I was looking at the type signature in ghci, so there was no newtype wrapping it
02:15:47 <exicer> no, I mean synonym or whatever :p
02:16:13 <bartavelle> then I could certainly write a function in my backend for every "interaction kind", and that's probably what will happen
02:16:26 <awestroke> bartavelle: and what different return types did you have in mind?
02:16:50 <bartavelle> right now I have (PlayerAction, Message), Card and () :)
02:17:44 <awestroke> what does Card signify?
02:17:51 <awestroke> in an interaction
02:18:17 <bartavelle> data Interaction = AskCard [Card]
02:18:22 <bartavelle> the player must choose a card
02:19:13 <fizruk> data Interaction x where AskCard :: [Card] -> (Card -> x) -> Interaction x
02:19:46 <bartavelle> awestroke, this might make more sense : https://github.com/bartavelle/7startups/blob/master/Startups/Interpreter.hs#L13-L18
02:19:54 <fizruk> askCard :: [Card] -> Interaction Card ?
02:20:18 <bartavelle> I am writing a type for my "backends", which will be something like IRC, email, XMPP ...
02:20:33 <bartavelle> once of the features will be to switch backend, so I must store the "last interaction"
02:20:38 <bartavelle> to replay it on another medium
02:20:44 <awestroke> bartavelle: imagine:  data PlayerResponse = Action PlayerAction Message | ChooseCard Card | Pass
02:21:01 <awestroke> _interact :: Interaction -> PlayerResponse
02:21:44 <bartavelle> yeah that was my first idea, but I wondered if I could do something clever with a GADT
02:21:45 <bartavelle> like
02:22:00 <bartavelle> _interact :: Interaction a -> IO (TypeInstanceSomething a)
02:22:16 <bartavelle> except I can't because "Backend" isn't parametrized with a, so must have forall.
02:22:30 <bartavelle> I wondered if there was some trick I didn't know of
02:22:48 <Welkin> parameterize it
02:22:58 <bartavelle> I can't :)
02:22:58 <thevishy> /join #python
02:23:18 <bartavelle> Backend must support all interactions, not just one, it describes a kind of "driver"
02:23:19 <awestroke> bartavelle: the problem is, how do you type safely use the values once you have a list of differently typed Backends ?
02:23:36 <bartavelle> awestroke, I want them to all have the same type
02:23:42 <bartavelle> that is, "Backend"
02:23:56 <awestroke> but you have a type parameter on the right hand
02:24:17 <bartavelle> yes, that is my problem :)
02:24:20 <awestroke> which means it's different types depending on the type parameter
02:25:09 <bartavelle> I could typeclass, but that wouldn't work because I'd need a distinct implementation for each backend type *AND* each interaction type
02:25:18 <bartavelle> can I write multi parameters typeclasses like that ?
02:25:29 <bartavelle> I think I can
02:26:09 <bartavelle> got to run, thanks for the rubber ducking :)
02:26:32 <Welkin> dubber rucking
02:30:10 <SrPx> Are the arguments on this paper generally accepted? http://www.eis.mdx.ac.uk/staffpages/dat/sblp1.pdf Do people believe some of his ideas are indeed the future of FP?
02:31:16 <Iceland_jack> Do some people believe that? Sure
02:31:29 <Iceland_jack> Total functions are nice to work with, not doubt
02:31:40 <Iceland_jack> and there are plenty of reasearch languages that are total
02:31:51 <exicer> Is there an easy way to remove a package from a cabal sandbox ?
02:33:22 * hackagebot lensref 0.1.0.4 - References which can be joined and on which lenses can be applied  http://hackage.haskell.org/package/lensref-0.1.0.4 (PeterDivianszky)
02:33:24 * hackagebot ghc-imported-from 0.2.0.2 - Find the Haddock documentation for a symbol.  http://hackage.haskell.org/package/ghc-imported-from-0.2.0.2 (CarloHamalainen)
02:33:25 <SrPx> Iceland_jack: what is your position? Would you suggest some of those languages for me to read about?
02:33:57 <Iceland_jack> If you can avoid partial functions you should, you can check out Agda, Coq, Idris, …
02:34:15 <Iceland_jack> And you should be programming that way in Haskell and most languages anyhow
02:34:50 <Okasu> Iceland_jack: Well, Idris supports prtial functions as wel as total.
02:35:03 <Iceland_jack> yes and I didn't claim otherwise
02:35:20 <Iceland_jack> Idris is something SrPx should look into :)
02:35:59 <SrPx> oh ok you mean those
02:36:08 <Iceland_jack> You don't need to change a language just for that though
02:36:29 <SrPx> I guess I am looking for a simpler language that is still total. I have not finished that paper tho, brb ...
02:36:31 <SrPx> thanks (:
02:36:59 <Iceland_jack> Simply typed language calculus without fixed points
02:40:39 <xpika> how to i change the command "ghc" in shell from ghc-7.6.3 to ghc-7.8.2 ?
02:41:06 <Iceland_jack> xpika: Change your PATH?
02:41:22 <Iceland_jack> or replace the ghc binary with new symlinks
02:45:15 <xpika> Iceland_jack: Ok, that worked (changing path)
02:53:52 <quchen> Can someone explain the "committing" part of STM to me? I just read SPJ-et-al's paper on STM, but it doesn't go into detail of this stage. So an STM action builds up this log of mutations that, if consistent, is committed, i.e. does the actual modifications of the TVars involved. Why does this not require a global lock for the duration of that update?
02:54:18 <quchen> Telling from the paper, all the magic is contained in `STMCommit`, but I can't imagine how this might work without blocking somehow.
02:54:50 <quchen> (Paper link: http://research.microsoft.com/en-us/um/people/simonpj/papers/stm/stm.pdf)
02:56:56 <quchen> Or is there locking after all, just that there's no computation being done during that phase beyond pointing TVars to new contents (that have already been calculated)?
02:58:15 <merijn> quchen: It does
02:58:53 <merijn> quchen: You need to have a lock that stops concurrent transactions from simultaneously committing
02:59:42 <merijn> But as you point out, this lock is only needed for the duration it takes to update a bunch of TVars
03:00:00 <t7> you can't have partially applied type constructors in a sig, right?
03:00:40 <merijn> quchen: This is why STM is cheapest the lower the number of TVars/concurrent transactions using the same TVars
03:01:21 <merijn> quchen: The fewer simultaneous transactions/number of involved TVars, the fewer transactions are blocked and the shorter they are blocked
03:04:34 <srhb> t7: :k (->) says * -> * -> * -- I assume that those do not unify with (* -> *)
03:06:17 <SrPx> Iceland_jack: but simply typed lambda calculus without fixed points is terribly unexpressive and useless
03:06:36 <merijn> SrPx: Oh?
03:06:40 <merijn> SrPx: Says who?
03:06:43 <SrPx> Iceland_jack: just finished reading the paper, I'm glad I completely agree with everything said there
03:07:19 <SrPx> merijn: pardon? Isn't it inexpressive? You can't even code a sorting function on it... right?
03:07:55 * merijn missed the simply-typed part, although I still disagree STLC is "useless"
03:08:06 <merijn> But, now is lunch time
03:08:09 <SrPx> merijn: yea me too, I think the useless part was a little strong
03:08:15 <SrPx> bad wording
03:08:58 <Iceland_jack> SrPx: What ever your goals are seem very unclear to me
03:08:58 <srhb> Either you have strong normalization or you don't, I guess.
03:09:42 <SrPx> Iceland_jack: ah
03:10:20 <Iceland_jack> You want a total language, is this something you want to program in? If so something based on MLTT is probably the way to go but you don't think Agda is simple enough
03:11:06 <Iceland_jack> so unless you want to program directly in some calculus or in DSL that's about as simple as it gets
03:11:51 <srhb> Iceland_jack: MLTT?
03:12:05 <Iceland_jack> Martin-Löf type theory
03:12:12 <srhb> Ah, of course.
03:12:13 <TheBrayn> hi
03:12:22 <srhb> TheBrayn: o/
03:12:42 <Iceland_jack> There is a book on that written by one of my professors
03:12:43 <Iceland_jack> http://www.cse.chalmers.se/research/group/logic/book/
03:12:53 <Iceland_jack> former professor
03:13:19 <SrPx> Iceland_jack: ah maybe you are right, I haven't quite explored MLTT enough to determine how easy or not it is to program in it (yet comments from people on agda/idris etc say it is a little more difficult), but my actual problem with MLTT is that
03:13:43 <SrPx> Iceland_jack: we don't quite know how to compile it efficiently yet
03:13:58 <Iceland_jack> Right, but that was not part of your criteria :)
03:14:20 <Iceland_jack> It's easy to make a total language that is efficiently compilable
03:14:20 <SrPx> I was thinking something more in line of a STLC with structural recursion and pattern matching, which would probably be easy to compile today. I don't know...
03:14:45 <quchen> merijn: Ah, that cleared things up. I heard STM being called lock-free a couple of times so I was confused.
03:14:45 <SrPx> can I ask you a few questions, are you busy? Looks like you have some answers I need
03:15:10 <Iceland_jack> I'm making quesadillas but you can ask if you don't mind waiting SrPx :)
03:15:40 <SrPx> I don't mind waiting, just don't wanna bother/abuse...
03:15:53 <Iceland_jack> I am incapcable of being bothered :)
03:16:02 <srhb> quchen: I suppose that wording is because the locks are abstracted away?
03:16:48 <ivanm> does anyone know how to resolve a haddock problem of "Setup: dist/doc/html/tasty-golden/haddock-prolog30977.txt: invalid argument" ?
03:17:10 <TheBrayn> I'm trying to install ghc 7.8.2 on ubuntu 14.04 which by default ships with 7.6.3, I have tried to install ghc-7.8.2 from this ppa: https://launchpad.net/~hvr/+archive/ghc but it only adds another ghc-version and does not upgrade the old one
03:17:13 <SrPx> Iceland_jack: do you know what is the relationship between supercompilers, tree transducers and dependently typed languages? Seems completely unrelated, but I've read papers of people using supercompilers to create proofs and tree transducers to supercompile... so I'm trying to make the connection here
03:17:15 <Iceland_jack>     L ::= natural number | L + L
03:17:15 <Iceland_jack> is total and very easy to compile
03:17:20 <TheBrayn> which means that things like runhaskell do not work
03:17:40 <Iceland_jack> SrPx: So I'm guessing you've been asking those questions on r/haskell
03:17:52 <SrPx> Iceland_jack: yes, hope I'm not causing any trouble?
03:18:03 <SrPx> I always feel like I'm abusing the community...
03:18:13 <Iceland_jack> no not at all, it might help first to hear what you hope to achieve
03:18:28 * hackagebot lensref 0.1.0.5 - References which can be joined and on which lenses can be applied  http://hackage.haskell.org/package/lensref-0.1.0.5 (PeterDivianszky)
03:18:55 <Iceland_jack> Are you looking for a limited language that is easy to optimize
03:20:30 <SrPx> Iceland_jack: exactly that. I'm looking for a limited language/system where I can do things such as compiling functions that operate on big lists to run as arrays on the gpu... optimising things such as a recursive sum function into the n(n+1)/2 formula. Etc. I know that would be possible if I had some way to test functional extensionality
03:21:03 <Iceland_jack> Have you looked at REPA or Accelerate or Feldspar or stream fusion/deforestation in general?
03:21:20 <SrPx> yea have been looking a lot all those (:
03:22:16 <Iceland_jack> And are you doing this because you're solving a problem or do you just want to explore?
03:22:17 <SrPx> as far as my current understanding goes, both supercompilation and MTT composition can be used to the same effects of deforestation/stream fusion in more elegant ways
03:23:09 <SrPx> Iceland_jack: both... I have to create a programming platform for a startup project. I could go on and just make a platform for coding Elm/Haskell/Etc but I have some time so I'd like to learn more and see what I can do
03:23:14 <Iceland_jack> Stream fusion may be a nicer way to go than supercompilation
03:23:22 <SrPx> Why?
03:23:34 <Iceland_jack> well okay, do you know pull arrays?
03:23:44 <SrPx> no..
03:23:50 <chrisdone> if you find that you can't access lpaste, it may because i accidentally banned you. just email me with your IP to unban it. it's been being DDoS'd for the past day, so i've banned a large number of suspicious-looking IP addresses
03:24:12 <SrPx> ah I guess I know what they mean
03:24:20 <Iceland_jack> That's what Feldspar and Obsidian and REPA (kind of) use
03:25:26 <Iceland_jack> and they allow fusing operations easily
03:25:26 <SrPx> Iceland_jack: uh huh, I have read that some days ago and find it neat
03:25:27 <chrisdone> (about 500)
03:25:31 <Iceland_jack> I'm no expert on supercompilation or tree transducers but if you haven't found an obvious connection yet this may still be a research topic
03:26:06 <Iceland_jack> How familiar are you with stream fusion and recursion patterns?
03:27:14 <SrPx> Iceland_jack: I know what it is for and have kinda read how it works but not enough to implement it myself if someone asked from sudden
03:27:26 <Iceland_jack> And if you're talking about efficiently compiling this _functional_ language to a GPGPU then that's very much a research topic
03:28:09 <SrPx> No, the GPU problem is the least important of the requeriments. The main goal, I'd say, is having function extensionality
03:28:48 <fikusz> what should I use for storing large 2D bit arrays? I don't need anything mutable, but constant-time lookup would be nice...
03:28:49 <SrPx> Finding wether two functions are equal. Which I'm aware is undecidable for many systems, but I read some contradicting things around and that is what I am exploring
03:29:06 <SrPx> whether
03:29:19 <Iceland_jack> SrPx: Wait, wait: you're putting a lot of constraints here so it's maybe not surprising that you don't find something that fits all of them
03:29:29 <Iceland_jack> How would you use function extensionality in this hypothetical language?
03:30:19 <SrPx> Iceland_jack: I just want a language that is expressive enough for our daily practical algorithms, but weak enough so I can write a compiler that can tell me: is_equal(f,g) ?
03:30:41 <Iceland_jack> okay so what would your use for that predicate be?
03:31:01 <Iceland_jack> Would it be for the user or for the compiler writer for some optimization you have in mind
03:31:50 <Iceland_jack> With stream fusion you can already make the claim “it's correct” and “it's an optimization”
03:32:38 <SrPx> Iceland_jack: I actually think many, countless interesting things could be done with such a system... for example, if is_equal((λx.x*x), f): replace(f,pow2) <- that is, converting functions that multiply a number by itself with native pow2
03:33:32 <Iceland_jack> yes or you could do that with inlining and intelligent peephole optimizations
03:33:43 <SrPx> Iceland_jack: other uses including, checking if a function F coded by a user of my system is equal to other existing function, and giving him a free documentation of his own just-created functions
03:33:53 <Iceland_jack> functions extensionality seems a bit overkill
03:34:16 <Iceland_jack> That feature seems strange to me
03:34:52 <SrPx> Iceland_jack: or theorem proving,... or so many things that I guess what I want is probably impossible. But then, that is what I said, if so is the case, I want to at least understand why it seems like that is exactly what some guys are doing around there
03:35:12 <Iceland_jack> If I do
03:35:12 <Iceland_jack>     birthday x = x + 1
03:35:12 <Iceland_jack> and
03:35:12 <Iceland_jack>     createFile x = x + 1
03:35:15 <Iceland_jack> those are completely different functions in terms of documentation
03:35:49 <Iceland_jack> My immediate reaction is that you're being overly ambitious
03:36:48 <SrPx> Iceland_jack: ah maybe, but that is just an example
03:37:08 <Iceland_jack> think about the lambda calculus
03:37:17 <SrPx> Iceland_jack: eh I think you are right
03:37:19 <Iceland_jack>     λx.λy.x
03:37:19 <Iceland_jack> is zero
03:37:22 <Iceland_jack> but it's also false
03:37:49 <SrPx> Iceland_jack: fair enough
03:38:00 <Iceland_jack> function extensionality doesn't tell you much there, at least not vis a vis documentation
03:38:28 <Iceland_jack> Not to put you down though :) it's good to be ambitious
03:38:30 * hackagebot apiary 0.4.2.0 - Simple web framework inspired by scotty.  http://hackage.haskell.org/package/apiary-0.4.2.0 (HirotomoMoriwaki)
03:38:32 * hackagebot apiary-cookie 0.4.2.0 - Cookie support for apiary web framework.  http://hackage.haskell.org/package/apiary-cookie-0.4.2.0 (HirotomoMoriwaki)
03:38:34 * hackagebot apiary-websockets 0.4.2.0 - websockets supper for apiary web framework.  http://hackage.haskell.org/package/apiary-websockets-0.4.2.0 (HirotomoMoriwaki)
03:38:50 <SrPx> Iceland_jack: still it would make me somehow trust on the system itself because I do believe it is an awesome property to have... so I could go on and use it for the platform
03:38:57 <Iceland_jack> SrPx: Would something like this be relevant: http://cstheory.stackexchange.com/questions/10608/programming-languages-with-canonical-functions?rq=1
03:39:26 <SrPx> Iceland_jack: yes I have read that :P
03:39:39 <Iceland_jack> So what the answer tells you is that adding natural numbers makes it undeciable
03:39:44 <Iceland_jack> *undecidable
03:41:00 <Iceland_jack> Have you thought about adding things like arrays, maps and specialized folds as primitives?
03:42:36 <SrPx> Iceland_jack: yes that is exactly what my latter version did... it was not turing complete and I managed to compile it to really performant javascript with some fusion laws
03:42:53 <SrPx> Iceland_jack: (indeed it was faster than native haskell in some cases, I even posted that on the subreddit)
03:43:11 <Iceland_jack> What data structures did you use in Haskell?
03:43:35 <SrPx> Iceland_jack: but it had no types and having numbers and arrays as builtins felt really sketchy to me
03:43:40 <Iceland_jack> it is :)
03:43:46 <Iceland_jack> If you really want performant code you could just as well use an imperative language and leave the laziness and immutability behind
03:44:19 <SrPx> Iceland_jack: ah my code was pretty bad
03:44:40 <Iceland_jack> If you want a functional language + fusion + efficient compilation + functional extensionality + ........
03:45:03 <Iceland_jack> and presumably immutable data structures where you build computations up from composing smaller computations?
03:45:08 <SrPx> Iceland_jack: yes saying it like that... I guess you are right I want too much \:
03:46:24 <SrPx> Iceland_jack: ah actually I do but I did solve that already, I guess
03:47:03 <vise890> import System.Random
03:47:03 <vise890> randoms' :: *TYPE* a => *TYPE* -> StdGen -> [a]
03:47:03 <vise890> randoms' a gen = (int : randoms' ty newGen) :: [a]
03:47:05 <vise890>                  where (int, newGen) = random gen
03:47:11 <vise890> hi all. I'm trying to do something like the above..
03:47:26 <Iceland_jack> Hey vise890, for future reference use
03:47:26 <Iceland_jack> @where lpaste
03:47:26 <lambdabot> http://lpaste.net/new/haskell
03:47:56 <vise890> Iceland_jack: noted. cheers
03:48:05 <Iceland_jack> vise890: Do you want an infinite list of random numbers?
03:48:35 <vise890> yes
03:48:43 <vise890> or whatever type you pass it in
03:48:43 <Iceland_jack> are you aware of 'randoms'?
03:48:50 <Iceland_jack> @ty randoms
03:48:51 <lambdabot> (Random a, RandomGen g) => g -> [a]
03:48:57 * SrPx is struggling to understand what the hilbert 10th problem means and if it really does apply to the problem
03:48:58 <vise890> yea. I'm just trying to make my own
03:49:04 <Iceland_jack> I see
03:49:25 <Iceland_jack> vise890: what is *TYPE* supposed to be?
03:49:37 <Iceland_jack> It appears to be a constraint (which you cannot pass directly as an argument)
03:51:33 <vise890> Iceland_jack: so you're saying that it's not possible to write some fn that can be invoked like `randoms' Char (mkStdGen 42)`, `randoms' Int (mkStdGen 42)`, etc.?
03:51:49 <Iceland_jack> no, because types aren't first class values
03:51:50 <merijn> vise890: Why would you want that, Random is already a typeclass
03:52:04 <Iceland_jack> you can easily do the same thing with annotations
03:52:12 <merijn> :t randoms (mkStdGen 42)
03:52:13 <lambdabot> Random a => [a]
03:52:16 <Iceland_jack> > randoms (mkStdGen 42) :: [Bool]
03:52:17 <lambdabot>  [True,True,True,False,False,True,False,True,False,True,True,True,False,False...
03:52:17 <merijn> :t randoms (mkStdGen 42) :: [Int]
03:52:18 <lambdabot> [Int]
03:52:20 <merijn> :t randoms (mkStdGen 42) :: [Char]
03:52:21 <lambdabot> [Char]
03:52:41 <merijn> > randoms (mkStdGen 42) :: [Char]
03:52:42 <lambdabot>  "\41423\368463\206725\161530\914412\1094711\15230\345119\1035538\358835\8904...
03:52:42 <Iceland_jack> merijn: Did we just use the same generator seed?
03:52:44 <SrPx> Iceland_jack: ah for example of why things are so confusing - it says that system has extensional equality for functions. http://strictlypositive.org/ott.pdf That is from the creators of Idris. Now I don't know how to interpret that. Is that what I was talking about? Probably not, but if not, what it is?
03:52:44 <Iceland_jack> :)
03:52:57 <merijn> Iceland_jack: Yes, because I copied the one from vise890's example
03:53:07 <SrPx> Iceland_jack: (not actually asking)
03:53:09 <vise890> oooo ok
03:53:19 <vise890> nice.
03:53:21 <Iceland_jack> oh merijn, I didn't even read it
03:53:32 * SrPx wishes he had a professor
03:53:35 <vise890> Iceland_jack: merijn: thank you
03:53:36 <SrPx> ):
03:53:43 <Iceland_jack> SrPx: I was actually just abotu to mention OTT
03:53:49 <Iceland_jack> SrPx: wait a sec
03:53:56 <SrPx> (:
03:53:57 <Iceland_jack> vise890: Do you want to define 'randoms' yourself?
03:54:34 <Iceland_jack>     randoms' gen = let (a, gen') = random gen
03:54:34 <Iceland_jack>                     in a : randoms' gen'
03:54:40 <vise890> yea well, just a toy implementation, i'm not gonna actually use it. I'm just starting out
03:54:52 <Iceland_jack> vise890: Sure! You can try the one above
03:55:04 <Iceland_jack> SrPx: If you don't mind me asking, what is your background?
03:56:10 <pavonia> > text $ take 20 $ randoms (mkStdGen 42)
03:56:12 <lambdabot>  ꇏ񙽏𲞅𧛺󟏬􋐷㭾񔐟󼴒񗦳󙘥𘀓𮴔𴔆񹎸񳥡򺆷󻈧𯊁𳧈
03:56:24 <Iceland_jack> pavonia: Oh 'randoms' can produce Agda code :)
03:57:00 <Fuuzetsu> Eventually it will produce Agda code which proves interesting properties about ‘randoms’.
03:57:06 <Iceland_jack> haha
03:57:09 <Iceland_jack> circle is complete
03:57:41 <Iceland_jack> SrPx: Since the language you're proposing seems to be rather limited in scope, have you considered a language where you can prove equality for a subset of it?
03:57:57 <Fuuzetsu> What if the proof is about the fact that it can produce a proof that can prove that it can generate the proof? Meta proofs.
03:59:17 <vise890> this channel is fantastic btw. thanks guys
03:59:17 <SrPx> Iceland_jack: what do you mean with background?
03:59:24 <Iceland_jack> you're welcome vise890
03:59:30 <SrPx> Iceland_jack: ah maybe, depends which subset
03:59:43 <Iceland_jack> SrPx: What your educational background is for example
03:59:59 <Iceland_jack> if you're familiar with research then you could just make this into a reasearch topic
04:00:02 <SrPx> Iceland_jack: ah I am just a student, you?
04:00:11 <Iceland_jack> so am I
04:00:19 <SrPx> Iceland_jack: ah I wish I could but I'm still undergrad
04:00:25 <Iceland_jack> undergrads can write papers
04:00:28 <rhaps0dy> uhm
04:00:34 <Iceland_jack> you could separate the arithmetic and array parts
04:00:35 <rhaps0dy> How do I make a loop?
04:00:39 <Iceland_jack> rhaps0dy: in Haskell?
04:00:44 <rhaps0dy> yeah
04:00:54 <Iceland_jack> rhaps0dy: Here's an example of a loop in C
04:00:56 <rhaps0dy> I have a function that takes a state and gives  a new one
04:01:01 <rhaps0dy> and a state structure
04:01:04 <Iceland_jack> bah nvm
04:01:06 <rhaps0dy> and am trying to express the changing of state
04:01:22 <Iceland_jack> rhaps0dy: you can easily mimick state change by a new parameter
04:01:25 <rhaps0dy> it's fairly obvious I'm new
04:01:34 <rhaps0dy> Iceland_jack: but I already have a whole state structure
04:01:35 <Iceland_jack> without knowing more about the problem it's hard to give a more concrete answer
04:01:40 <rhaps0dy> uh
04:01:50 <rhaps0dy> I'm writing a CLI Hangman to get the hang of haskell
04:01:54 <Iceland_jack> change of state is expressed with State
04:02:04 <rhaps0dy> Yeah, mine is a ghetto State
04:02:16 <Iceland_jack> sure, you can do it manually which is not a bad idea
04:02:26 <SrPx> Iceland_jack: "bah nvm" haha
04:02:30 <rhaps0dy> I need to get a char of input and pass it to the state transition function
04:02:35 <rhaps0dy> this gives a new state
04:02:37 <rhaps0dy> then print that state
04:02:41 <rhaps0dy> rinse and repeat
04:02:47 <Iceland_jack> sure
04:02:55 <rhaps0dy> (I made my state an instance of Show)
04:03:13 <rhaps0dy> something along the lines of
04:03:24 <rhaps0dy> c <- getLine
04:03:35 <Iceland_jack>     foo oldState = do
04:03:35 <Iceland_jack>       c <- getChar
04:03:35 <Iceland_jack>       newState <- stateTransition oldState c
04:03:35 <Iceland_jack>       print newState
04:03:38 <rhaps0dy> let nextState = step curState (head c)
04:03:38 <Iceland_jack>       foo newState
04:03:45 <rhaps0dy> hm
04:05:03 <rhaps0dy> Iceland_jack: what is foo in your code?
04:05:06 <Iceland_jack> if you stateTransition function is pure you do
04:05:06 <Iceland_jack>     let newState = stateTransition oldState c
04:05:15 <rhaps0dy> it is
04:05:16 <Iceland_jack> rhaps0dy: 'foo' is the program you asked for
04:05:18 <Iceland_jack> :)
04:05:23 <Iceland_jack> see the first line of my code
04:05:32 <rhaps0dy> yes, foo oldState = do
04:05:37 <rhaps0dy> that's why I asked D:
04:05:47 <rhaps0dy> uh
04:06:32 <Iceland_jack> rhaps0dy: Would a program that accepts a number from the user and adds it to a running total but quits once it exceeds 100 be helpful?
04:06:42 <rhaps0dy> Iceland_jack: very
04:06:47 <SrPx> Iceland_jack: anyway what you wanted to say about OTT? And if you had freedom to chose any system to create a programming platform and you didn't care about the current infrastructure for that system, only cared about that system being the best possible, what would you chose?
04:07:00 <SrPx> better*?
04:07:05 * SrPx never knows
04:08:04 <Iceland_jack> okay
04:08:05 <Iceland_jack>     numberStuff :: Int -> IO ()
04:08:05 <Iceland_jack>     numberStuff total = do
04:08:05 <Iceland_jack>       number ← readLn
04:08:08 <Iceland_jack>       let newTotal = total + number
04:08:11 <Iceland_jack>       unless (newTotal > 100)
04:08:12 <merijn> rhaps0dy: tbh, in your case a simple recursive loop would work just as well
04:08:14 <Iceland_jack>         (numberStuff total)
04:08:43 <rhaps0dy> Iceland_jack: thank you very much
04:08:52 <rhaps0dy> merijn: yes, that's what Iceland's is right?
04:09:13 <Iceland_jack> SrPx: hmm it's hard to answer that question
04:10:05 <merijn> rhaps0dy: Yeah, looks that way
04:10:38 <Iceland_jack> So it seems like you're hyperfocusnig on functional extensionality and totality: as for your question you need to be more precise what the intended purpose of it is
04:10:50 <Iceland_jack> *hyperfocusing, sigh my spelling is getting worse
04:11:28 <Iceland_jack> in languages like Agda or Idris the user must sometimes provide their own proof that two values or functions are propositionally equal
04:11:38 <SrPx_> Iceland_jack: my computer crashed, did you say anything?
04:11:55 <Iceland_jack> SrPx: ah yes
04:11:58 <Iceland_jack> SrPx: hmm it's hard to answer that question
04:12:01 <Iceland_jack> So it seems like you're hyperfocusnig on functional extensionality and totality: as for your question you need to be more precise what the intended purpose of it is
04:12:03 <Iceland_jack> in languages like Agda or Idris the user must sometimes provide their own proof that two values or functions are propositionally equal
04:12:15 <zq_> has anyone successfully compiled 7.8.3 with llvm?
04:12:44 <SrPx> Iceland_jack: yes, but in OTT you can find equality automatically, right?
04:12:45 <zq_> i'm running into a 'strange closure' error repeatedly
04:13:09 <Iceland_jack> well so, closed terms have a canonical value
04:13:25 <Iceland_jack> but that is not guaranteed to be helpful for your case
04:13:36 <merijn> zq_: Well, for one there is no 7.8.3?
04:13:51 <merijn> zq_: Is there a specific reason you are not using a binary release of GHC?
04:14:29 <zq_> merijn: 7.8.2*; typing in tthe dark
04:14:40 <zq_> dll-split: internal error: evacuate(static): strange closure type -385875968 (GHC version 7.8.2 for x86_64_unknown_linux) Please report this as a GHC bug:  http://www.haskell.org/ghc/reportabug
04:14:44 <zq_> make[1]: *** [compiler/stage2/dll-split.stamp] Aborted
04:15:11 <zq_> this was attempted with llvm 3.4.2, if that matters
04:15:35 <SrPx> Iceland_jack: pardon what is canonical value and why is it not helpful for my case?
04:15:39 <merijn> zq_: Yes, but why are you trying to build from scratch? And where did you obtain sources from?
04:16:09 <Iceland_jack> Canonicity means that every closed term has a single canonical value it reduces to
04:16:38 <Iceland_jack> but it may not be nice to work with or efficient for specific use case
04:16:40 <SrPx> Iceland_jack: but what is canonical? Does it just mean it has a single normal form?
04:16:57 <zq_> merijn: sorry if i wasn't clear. building 7.8.2 from scratch with -fllvm using another 7.8.2 ghc that was compiled with -fasm
04:16:57 <Iceland_jack> shit brb
04:17:08 <SrPx> Iceland_jack: okay thanks!
04:17:29 <merijn> zq_: That's an explanation of "what", but not of "why"
04:18:41 <Iceland_jack> SrPx: back
04:18:55 <Iceland_jack> so a canonical form is a normal form, but not necessarily the other way 'round
04:19:30 <Iceland_jack> I was a bit imprecise before
04:19:58 <zq_> merijn: what do you mean why?
04:20:02 <Iceland_jack> in general you should make more use of how specialized the language you're planning is
04:20:19 <Iceland_jack> something like OTT is for a general langauge
04:21:36 <merijn> zq_: In general there should be no need to compile GHC from scratch as user, so depending on the reason why the answer can either be 1) don't do that, then or 2) you're trying to hack on GHC, need to update your sources and if trouble persists go to #ghc
04:22:24 <SrPx> but I don't get what is different from OTT's extensional equality from what I asked? Is not it possible to do something like `is_equal even (mulOf 2)` on it?
04:23:11 <SrPx> Iceland_jack: eh the system I am trying to do is general, in a sense... but I don't quite understand the boundary between a general and a non general language?
04:23:15 <Iceland_jack> SrPx: It's not necessarily different
04:23:38 <Iceland_jack> There is no clear-cut boundary, but you seem like you want to focus on vector operations
04:25:46 <SrPx> Iceland_jack: oh not at all, why did I make you think that? The GPU thing was just an example of what I think could be possible with function extensionality. (For example, if you can safely determine at compile time that a function maps over a large list, then you can throw it to the GPU because that is what GPU does well. I was just giving it as an example.)
04:26:20 <Iceland_jack> Wow okay..
04:26:45 <SrPx> Iceland_jack: what? ^^
04:26:56 <Iceland_jack> Ambitious
04:27:34 <Iceland_jack> So you can expand on stream fusion, there are still some issues there like concatMap
04:28:05 <quchen> What's the difference between `newtype N a = N a` and `data D a = D !a`? Possibly different runtime representations?
04:28:06 <Iceland_jack> but creating a total general purpose language that is easy to compile efficiently and submits to function extensionality
04:28:20 <merijn> SrPx: I don't mean this in a rude way, but I've seen you ask questions along similar lines in here quite frequently. What you are trying to accomplish are things that people lots of research groups all over the world are trying, I don't want to be discouraging, but it is highly unlikely that anyone here can help you a lot
04:28:25 <SrPx> But why that is so ambitious? You mean that in a bad sense? If it is I am fine with trying something else, I don't want to do anything too complex. It is just that, if the building blocks are there it seems kinda doable to me?
04:29:00 <Iceland_jack> Basically what merijn said, this is complex
04:30:05 <SrPx> merijn: ah that is why I asked if I could keep asking, I really don't want the abuse the channel in any way! Sorry.
04:30:13 <quchen> Would it be a valid optimization to turn all D into N (or vice versa)?
04:30:17 <Iceland_jack> quchen: these two differ
04:30:17 <Iceland_jack>     (\(N a) -> 5) ⊥
04:30:17 <Iceland_jack>     (\(D a) -> 5) ⊥
04:30:43 <merijn> SrPx: It's fine to try and play around with stuff like this, and you may actually invent/come up with some cool stuff, but you seem to be hoping people here have answers for you. Given the level of questions I fear there may not be a single person on this planet that knows the answer
04:30:49 <merijn> Iceland_jack: Both of those are bottom
04:30:58 <Iceland_jack> merijn: Are they?
04:30:59 <SrPx> I've been reading a lot of complicate papers and working on the subject, but I don't really have anyone in real life I can ask questions. It sucks to be in such a project without a professor or proper guidance...
04:31:08 <quchen> @let newtype N a = N a
04:31:09 <merijn> Iceland_jack: Pattern match in the lambda forces the bottom
04:31:10 <lambdabot>  Defined.
04:31:17 <Iceland_jack> merijn: not on my computer
04:31:17 <quchen> @let data D a = D !a
04:31:19 <lambdabot>  Defined.
04:31:21 <Iceland_jack> ghci> (\(N a) → 4) undefined
04:31:21 <Iceland_jack> 4
04:31:32 <quchen> > (\(N x) -> 5) undefined
04:31:33 <lambdabot>  5
04:31:35 <quchen> > (\(D x) -> 5) undefined
04:31:37 <lambdabot>  *Exception: Prelude.undefined
04:31:56 <SrPx> merijn: uh huh I agree with you
04:32:03 <merijn> heh
04:32:04 <quchen> Hmm. Presumably this has to do with the separate semantics for matching newtypes, I remember reading about that in the Report.
04:32:11 <Iceland_jack> So they're not both bottom?
04:32:26 <quchen> > (\ ~(D x) -> 5) undefined
04:32:28 <lambdabot>  5
04:32:31 <merijn> Iceland_jack: Newtype pattern matches apparently work differently from what I though
04:32:37 <quchen> Maybe newtype matching is implicitly irrefutable
04:32:49 <merijn> quchen: That's what I was thinking, but that's really confusing, IMO
04:33:07 <Iceland_jack> ⊥ is annoying :) let's use total languages!
04:33:52 <quchen> But I like my general recursion!
04:34:14 <Iceland_jack> You can model it for large enough iterations
04:34:17 <merijn> In "1.49872927" is there a name for the part after the . ?
04:34:51 <quchen> 49872927
04:34:57 <quchen> Badum-tsh ;-)
04:35:17 <Iceland_jack> no no, it's called 'snd . properFraction'
04:35:20 <awestroke> post-decimal-point-value
04:35:22 <Iceland_jack> > (snd . properFraction) 1.49872927
04:35:24 <lambdabot>  0.4987292699999999
04:35:55 <SrPx> merijn: still there are always some particular/specific questions that are answerable (even if maybe by few people) so it is still fine for me to ask them here, right? This is one of the only places on the internet I often actually get good answers
04:36:20 <Iceland_jack> > (read . tail . dropWhile (/= '.')) "1.49872927" ∷ Integer
04:36:21 <lambdabot>  49872927
04:36:23 <quchen> In German it's the "after-comma-locations". I don't think I've heard a name in English for it.
04:36:42 <merijn> SrPx: Sure, if you're interested in language design and related things you may want to check out LtU too
04:36:45 <merijn> @where ltu
04:36:46 <lambdabot> http://lambda-the-ultimate.org/
04:36:54 <quchen> merijn: Wikipedia: "A decimal mark is a symbol used to separate the integer part from the *fractional part* of a number written in decimal form."
04:37:02 <merijn> quchen: Right, same in Dutch
04:37:13 <merijn> I guess "fractional" will work for me
04:38:05 <Mathias___> yes fractional digits
04:39:28 <Iceland_jack> SrPx: Reading Duncan's thesis might be a good idea http://community.haskell.org/~duncan/thesis.pdf your current idea may be more useful to get you acquainted with new ideas
04:40:01 <Iceland_jack>     This thesis is about a technique for making beautiful programs run fast.
04:40:01 <Iceland_jack> quite nice isn't it? :)
04:40:11 <SrPx> merijn: I never actually thought of participating of ltu, that seems like a good idea, I'm reading the FAQ right now.
04:40:30 <SrPx> Iceland_jack: I'll read it next, thanks (: but I don't understand the english emaning of "your current idea may be more useful to get you acquainted with new ideas"
04:42:18 <SrPx> Iceland_jack: ah it is about shortcut function? I don't know, I kinda see MTT composition / Supercompilers as a next step to stream fusion, no? Most of those papers cite stream fusion as a subset of it
04:42:23 <SrPx> stream fusion*
04:42:32 <Iceland_jack> Sherlock Holmes said of Wattson “you may not be luminous but you're an excellent conductor of light”
04:42:38 <Iceland_jack> some ideas are like that
04:42:48 <rhaps0dy> Iceland_jack: Thank you very much http://lpaste.net/104211
04:42:51 <Iceland_jack> SrPx: You seem to be stuck in 'bigger = better'
04:43:13 <Iceland_jack> Just because something is subsumed by something else doesn't mean that it's better for all intents and purposes
04:43:53 <SrPx> Iceland_jack: but isn't it more natural to fuse arbitrary recursive functions than having to recode them using streams?
04:44:03 <Iceland_jack> rhaps0dy: Am I wrong that the 'Enter a character!' prompt doesn't appear for the first round?
04:44:27 <Iceland_jack> SrPx: What do you call natural?
04:44:32 <Iceland_jack> There are pros and cons
04:45:46 <SrPx> having to do the whole list->stream, stream->list conversion... and not being able to fuse algorithms on trees... instead of just letting the compiler fuse the traditional recursive definitions... seems less natural IMHO. But that is just my intuition and I could be absolutely wrong about that
04:46:05 <rhaps0dy> Iceland_jack: no you're not
04:46:13 <rhaps0dy> er
04:46:20 <rhaps0dy> I guess I kind of let the user gues
04:46:22 <rhaps0dy> gues
04:46:27 <Iceland_jack> so for example SrPx, there was a branch for supercompilation to GHC
04:46:28 <rhaps0dy> guess * >_>
04:46:46 <Iceland_jack> and it made compile times 1.5-8 times slower
04:47:57 <Iceland_jack> While for something like pull vectors you basically get fusion for free
04:48:12 <Iceland_jack> and for stream fusion you turn recursive functions into non-recursive stepping functions
04:48:25 <Iceland_jack> When optimizing: recursion = bad
04:48:38 <SrPx> ah I am actually surprised it was not worse, I guess super compiling algorithms are terribly inefficient by nature. That is one of the reasons I want to understand the relation between those and transducer composition as them seem to accomplish the same
04:48:39 <Iceland_jack> Inlining is the heart of optimization, especially in functional languages
04:49:17 <Iceland_jack> also do you care about the resulting binary size?
04:50:14 <SrPx> Iceland_jack: ah that is a good point but the same problem is true for any kind of inlining, in general
04:50:41 <Iceland_jack> yes but the thing abuot pull arrays and stream fusion is that you don't define things recursively
04:50:49 <Iceland_jack> that makes it easy to inline, easy to optmize further
04:51:00 <merijn> rhaps0dy: FYI, if you don't care about replacing your RandomGen later you could just specialise your functions to be "StdGen -> String" instead of "RandomGen g => g -> String"
04:51:00 <Iceland_jack> there is work for having stream fusion work with SIMD instructions
04:51:14 <SrPx> Iceland_jack: mind I'm not saying stream fusion is not awesome in any way, what it accomplishes blows my mind. I still wonder why it is not used on the standard list
04:51:16 <merijn> rhaps0dy: This would let you use "State StdGen ()", for example
04:51:43 <Iceland_jack> rhaps0dy: You may want to make 'HgState' into a record as well
04:52:21 <Iceland_jack>     data HgState = HgState { currentWord :: String, guessedChars :: [Char], wrongChars :: [Char], status :: Status }
04:52:31 <rhaps0dy> Iceland_jack: oh
04:52:37 <Iceland_jack> where
04:52:37 <Iceland_jack>     data Status = InProgress | Dead | Win
04:52:45 <Iceland_jack> rather than encoding those as Ints
04:52:45 <SrPx> Iceland_jack: but some thing you can't do with stream fusion and you can do with supercompilation is analysing the program to prove things about it, I guess?
04:52:49 <rhaps0dy> Oh, the last modification is better
04:53:02 <rhaps0dy> I'm not seeing a Record unless I make hangman considerably bigger
04:53:11 <SrPx> Iceland_jack: eg this typeless proof of addition commutability http://themonadreader.files.wordpress.com/2014/04/super-final.pdf
04:53:15 <rhaps0dy> though it could work
04:53:19 <rhaps0dy> alright, thanks
04:53:26 <SrPx> commutativity
04:53:52 <SrPx> on page 27
04:54:17 <Iceland_jack> there is a different between super{compilation,optimization} btw
04:54:35 <Iceland_jack> but I'm not familiar enough with this to comment with confidence SrPx
04:54:58 <SrPx> ah no probs
04:55:09 <Iceland_jack> All I know is that there is significant research behind each and every one of those properties
04:55:37 <Iceland_jack> of course, if you're interested in optmizing why not model every possible input
04:55:43 <SrPx> uh huh
04:55:47 <Iceland_jack> and create billions of binaries
04:56:04 <Iceland_jack> if it's a total language that satisfies everything you asked for
04:56:07 <SrPx> Iceland_jack: how would you recommend to keep track of current research?
04:56:20 <SrPx> me*
04:56:32 <Iceland_jack> just google around, check papers cited, ...
04:57:21 <SrPx> ah okay
04:57:23 <Iceland_jack> You seem to be doing a good job already, asking around is a good idea but you always seem disappointed when someone tells you that there isn't an amazing solution to a very hard problem
04:58:46 <merijn> Other than googling and checking papers the only thing you could really do is hang around academic conferences/workshops, but that may be pricey/difficult if you don't have the money to travel/no one to pay the travel cost
04:58:47 <Iceland_jack> Like in the paper you linked me, you can do powerful things if the language is simple enough
04:59:32 <Iceland_jack> SrPx: There are also STM solvers that can optimize expressions
04:59:58 <Iceland_jack> if you're willing to settle for simpler and more limited expressions you can optmize things better and better
05:00:14 <Iceland_jack> but Xor(HaveCake, EatCake)
05:00:51 <SrPx> ah that is just impression, I am not disappointed, I am mostly worried in not bothering by asking too much... I actually spend much more time reading and even waste hours googling for answers just not to ask. But even so, I still ask a lot so for who reads it may sometimes look like I'm just lazy
05:01:09 <SrPx> Iceland_jack: xor what
05:01:16 <Iceland_jack> No no, preparing and researching questions is very good :)
05:01:17 <SrPx> merijn: wish I could :/
05:01:24 <Iceland_jack> SrPx: You can't have your cake and eat it too
05:01:29 <Iceland_jack> 's what I'm saying
05:01:52 * SrPx is reactionless
05:02:02 <Iceland_jack> :)
05:02:45 <Iceland_jack> So one thing that Haskell does it that it limits functions to pure functions (with bottom), you can go further and limit them to total functions, you can go further and limit values to finite values and then limit yourself to primitive recursion or no recursion at all
05:02:53 <Iceland_jack> and *boom*, you can optimize!
05:03:18 <Iceland_jack> You can also hard-code certain arithmetic simplications into your language
05:03:41 <michi7x7> Iceland_jack: I guess the biggest plus are the pure functions, because they allow the compiler to rearrange everything as long as the result stays the same
05:04:24 <michi7x7> so, unlike strchr in C which returns something different everytime Haskell compilers can eliminate multiple calls
05:04:39 <Iceland_jack> Yes purity strikes a very nice balance between usability and power
05:05:15 <michi7x7> It also makes the code more readable, because you actually don't care about side-effects
05:05:17 <Iceland_jack> proving that two lists of statements in a language like C or C++ that may or may not allocate memory or free memory or modify memory is crazy
05:05:36 <Iceland_jack> *proving that ... are equal
05:05:44 <michi7x7> Iceland_jack: but that is what C++ compilers actually do to optimize the code
05:05:48 <Iceland_jack> It is
05:06:07 <Iceland_jack> It's still crazy, far more assumptions going on
05:06:50 <michi7x7> Iceland_jack: the biggest negative effect of this are the crazy efforts to make threading work :)
05:07:07 <michi7x7> see std::future, std::atomic, std::thread and the like
05:07:11 <Iceland_jack> yes
05:08:02 <michi7x7> Iceland_jack: contrary, a Haskell compiler is free to spawn multiple threads for a computation without any code input at all
05:08:19 <merijn> michi7x7: However, I don't think any haskell compiler does
05:09:05 <Iceland_jack> GHC should spawn at least 100 threads for
05:09:05 <Iceland_jack>     sum [1..100]
05:09:05 <Iceland_jack> imo
05:09:16 <rhaps0dy> eet doesn't work like this
05:09:22 <rhaps0dy> log 100 threads would be more accurate
05:09:45 <rhaps0dy> and threads don't always increase performance, because of context switch overhead
05:09:58 <michi7x7> Things like that really depend on how much overhead a thread injects
05:11:07 <rhaps0dy> michi7x7: the first one doesn't
05:11:16 <rhaps0dy> you can't sum 100 numbers in 100 threads
05:12:08 <michi7x7> rhaps0dy: well, you can if you see a function call as "one job" and multiple workers finish one job at a time
05:12:23 <rhaps0dy> ah, that would be better
05:12:32 <michi7x7> although for things like summing numbers, that wouldn't really make sense.
05:13:09 <michi7x7> context switches in a architecture like that are quite fast though, just a few instructions
05:14:34 <rhaps0dy> architecture like what ?
05:14:42 <rhaps0dy> still 1000 threads is generally a bad idea
05:14:46 <michi7x7> rhaps0dy: like HPX in C++
05:14:50 <rhaps0dy> (assuming x86 CPU)
05:14:56 <rhaps0dy> oh
05:14:57 <rhaps0dy> HPX
05:15:00 <rhaps0dy> idk then
05:15:27 <michi7x7> rhaps0dy: http://stellar-group.github.io/hpx/docs/html/hpx/tutorial/examples/fibonacci.html
05:15:31 <SrPx_> Iceland_jack: uh huh! Anyway thank you very much for all, I can't overstate how much that kind of support is important to someone that has an internet and nothing else
05:15:38 <merijn> Context switching on x86 is still quite expensive
05:15:59 <michi7x7> merijn: not within the same thread and process (with no scheduler involved)
05:16:05 <SrPx_> Iceland_jack: and you ran of the question of what system you would use if you were me but ok heh
05:16:08 <rhaps0dy> >boost::
05:16:11 <rhaps0dy> nopenopenopenopenope
05:16:55 <SrPx_> rhaps0dy: what is wrong with boost...?
05:17:00 <merijn> michi7x7: Then you're really just doing coroutines
05:17:27 <rhaps0dy> SrPx_: hard to debug, enormous dependencies
05:17:28 <michi7x7> merijn: yeah, I wasn't sure if I should use that term
05:17:34 <rhaps0dy> complex as fuck implementation
05:18:00 <michi7x7> rhaps0dy: then I have bad news for C++ and you
05:18:10 <rhaps0dy> yes
05:18:16 <rhaps0dy> I kind of dislike C++
05:18:20 <rhaps0dy> we already broke up
05:18:49 * SrPx_ remembers kid self trying to figure out boost.asio ... dark, dark times 
05:19:04 <michi7x7> SrPx_: asio is a mess
05:19:11 <rhaps0dy> s/asio/boost/
05:19:42 <michi7x7> I do like function, spirit, regex, maps and the math stuff
05:19:46 <SrPx_> michi7x7: tell that to kid me trying to create online games with C++. Damn Haskell *existed*. For all that time. That makes me really sad now that I think about it.
05:20:03 <SrPx_> I was actually trying to do many haskelly things on c++
05:20:23 <michi7x7> SrPx_: well, most C++'ers are. Without realizing
05:21:10 <rhaps0dy> SrPx_: tbh I think Haskell is not very suited for games, but that might be because I'm new
05:21:18 <rhaps0dy> they're very imperative-y
05:22:41 <michi7x7> I'm still a bit afraid of Haskell. I can understand most programs, but I still have a hard time trying to find a good design for Haskell programs
05:23:42 * hackagebot creatur 5.4.2 - Framework for artificial life experiments.  http://hackage.haskell.org/package/creatur-5.4.2 (AmyDeBuitleir)
05:23:52 <SrPx_> michi7x7: rhaps0dy I think FRP is a really, really awesome solution for that
05:24:01 <merijn> michi7x7: The solution is hack together the quickest/ugliest implementation you can and then refactor it into clean code :)
05:25:30 <michi7x7> SrPx_: oh, there are reactive solutions for everything and all lack something you would need in production and you have to hack it together
05:26:37 <mr-> michi7x7: is that experience or hear-say?
05:27:14 <SrPx_> michi7x7: huh?
05:27:22 <SrPx_> in what sense?
05:28:01 <michi7x7> mr-: maybe I tried the worst thing possible, but I tried to implement a reactive GUI. I thought it would be an easy task, since there are quite a few libraries available.
05:35:21 <merijn> michi7x7: FRP in general and GUIs in specific are still an active area of research
05:36:38 <michi7x7> merijn: yeah, and I'm still "just a library user". I don't really understand the implementations, and that's why I failed. I guess I still have a lot to learn.
05:37:01 <michi7x7> Naive me really thought it would be enough to understand Monad Transformers ^^
05:44:04 <TheBrayn> Transformers, Monads in disguise
05:58:46 * hackagebot sdl2-image 0.1.1.0 - Haskell binding to sdl2-image.  http://hackage.haskell.org/package/sdl2-image-0.1.1.0 (cailei)
06:00:55 <DEA7TH> Can Haskell be learned as a first language?
06:01:27 <raichoo> Sure. Take a look at "Learn you a Haskell".
06:02:16 <t7> ooo sdl2 bindings :)
06:03:16 * Kinnison often wishes he had learned haskell first
06:03:28 <ivanm> DEA7TH: you're usually assumed to have learnt a human language before a computer language
06:03:37 <seanparsons> I would recommend Real World Haskell over LYAH.
06:03:52 <ivanm> seanparsons: RWH does assume more of a programming background though
06:03:57 <raichoo> seanparsons: As a starting book? no
06:04:46 <seanparsons> I think LYAH causes people to end up with misconceptions about the concepts, I've seen it multiple times.
06:04:51 * Kinnison would have ended up with Miranda though, not haskell, since he started learning computer languages in 1985 or so
06:05:03 <merijn> seanparsons: Really? Which misconceptions?
06:05:13 <merijn> seanparsons: RWH skips over a lot of important details
06:05:36 <bennofs> seanparsons: there are some things that are a bit informal, but overall I think it is much less outdated as RWH is
06:05:55 <frawgie_> both books are worth reading, but i think LYAH is a better starting point
06:06:38 <seanparsons> Pretty much anything related to typeclasses, monads/applicatives/functors especially.
06:07:43 <sopvop> C library I use has a "store" for char* strings, you can put your char* in there, get back new pointer. then you can compare pointers for equality instead of strings. How to do something like this in haskell?
06:08:08 <sopvop> IORef?
06:08:09 <merijn> sopvop: MVar/IORef?
06:08:18 <sopvop> hm, do they have Eq?
06:08:19 <merijn> sopvop: IORef's are comparable for equality
06:08:22 <bennofs> sopvop: StablePtr?
06:08:27 <sopvop> Hm, right.
06:08:44 <merijn> bennofs: StablePtr's are really expensive
06:08:47 * hackagebot scientific 0.3.2.0 - Numbers represented using scientific notation  http://hackage.haskell.org/package/scientific-0.3.2.0 (BasVanDijk)
06:08:49 <merijn> IORef's are cheap
06:09:06 <bennofs> oh, didn't know that. What are stableptr's useful for then?
06:09:14 <ivanm> seanparsons: RWH's chapter on exceptions is also completely out of date
06:09:27 <merijn> bennofs: Stopping GHC from GCing things after you pass a pointer to said thing to C
06:09:47 <bennofs> merijn: I think that was what a ForeignPtr was for?
06:09:58 <merijn> bennofs: No, ForeignPtr calls finalizers, etc.
06:10:15 <merijn> bennofs: StablePtr mark some haskell value as "do not GC until explicitly freed"
06:11:17 <seanparsons> ivanm: Because understanding everything perfectly is the point?
06:11:29 <merijn> bennofs: Suppose I have a value Foo, and a C functions needs to pass me this haskell value during a callback. How do I stop Foo from being GCed after giving C a pointer to it? GHC doesn't know about the existence of the C pointer and thus thinks it can safely GC
06:11:41 <merijn> seanparsons: Which misconceptions about typeclass does LYAH produce?
06:11:48 <merijn> seanparsons: LYAH explains them much better than RWH
06:11:55 <merijn> I'm not even sure RWH explains them *at all*
06:12:12 <bennofs> merijn: ah, I see
06:13:10 <seanparsons> I know several people who worked through the whole thing and at the end pretty much had no idea about them, were asking how to instantiate them, that kind of thing.
06:16:24 <ArisFr> Hi! I'm trying to use mono-traversable (Data.Sequences.OrdSequence specifically) and I was wondering whether there is an easy way to find out the cumulative set of functions defined in a typeclass, especially useful in deep typeclass hierarchies
06:17:11 <ArisFr> cumulative: including "inherited" functions
06:21:01 <merijn> seanparsons: That sounds more like they did not read it properly, IMO
06:21:54 <merijn> seanparsons: It literally has an entire chapter dedicated to them and implementing your own instances
06:22:23 <Feuerbach_> ArisFr: other than following links in haddock, I don't know of any
06:22:28 <seanparsons> merijn: I'm talking several people, I'm not saying this isn't anecdotal, but it's still several people I directly know.
06:22:50 <seanparsons> merijn: That description is all well and good, but it doesn't mean they magically will understand them.
06:23:28 <bennofs> seanparsons: maybe typeclasses are just a difficult thing about haskell in general. I doubt that any book can fix that
06:23:30 <ArisFr> yeah, tha's what I've been doing, but sorting through a large hierarchy when starting to learn it can be very tedious. Oh well, couldn't hurt to ask...
06:25:10 <merijn> ArisFr: FYI, the ":info" (or ":i") command in ghci will print out all functions in a typeclass
06:25:21 <ArisFr> aha!
06:25:25 <merijn> ArisFr: It will also show the superclass
06:25:42 <ArisFr> that should prove very usefull
06:26:00 <ArisFr> I'll try it out. Thanks a bunch
06:26:02 <Feuerbach_> ArisFr: having a pencil and a sheet of paper handy usually helps, too ;)
06:26:11 <Feuerbach_> (seriously)
06:26:21 <ArisFr> Yeah, got plenty of that already :)
06:26:34 <merijn> ArisFr: It can print out a bunch of other things too, like the precedence of operators, constructors of a class, etc.
06:26:47 <merijn> ArisFr: It will also print all typeclass instances in scope
06:27:11 <ArisFr> So if I import everything I should be able to see all the relationships
06:28:04 <Feuerbach_> well, it still won't enumerate all methods recursively (which I thought was what you wanted)
06:30:01 <ArisFr> I figured as much
06:30:21 <ArisFr> But this is still better than having to wade through hackage
06:31:11 <ArisFr> I just need the function names and optionally the signatures, which sould allow me to quickly find out what is provides and what I have to add by myself
06:31:39 <merijn> ArisFr: You mean when defining your own instances?
06:33:02 <ArisFr> No, I want to create a dependent typeclass, but to do that I need to know what's already there. I don't want to reimplement, e.g. minimumBy, when it's already there
06:34:24 <ArisFr> or, if i want to create a new function, e,g. standardDeviation, I need to know that e.g.  foldl is or is not available in order to use it
06:34:48 <ArisFr> I'm creating a small DSL for data analysis from simulation results
06:37:02 <ArisFr> thanks merijn and Feuerbach_, you've been very helpful
06:38:51 * hackagebot ideas-math 1.1 - Interactive domain reasoner for logic and mathematics  http://hackage.haskell.org/package/ideas-math-1.1 (BastiaanHeeren)
06:38:53 * hackagebot diagrams-qrcode 1.1.1 - Draw QR codes to SVG, PNG, PDF or PS files.  http://hackage.haskell.org/package/diagrams-qrcode-1.1.1 (FelipeLessa)
06:41:48 <Iceland_jack> <Iceland_jack> GHC should spawn at least 100 threads for 	        [12:06]
06:41:48 <Iceland_jack> <Iceland_jack>     sum [1..100]
06:41:48 <Iceland_jack> <Iceland_jack> imo
06:41:48 <Iceland_jack> <rhaps0dy> eet doesn't work like this
06:41:51 <Iceland_jack> <rhaps0dy> log 100 threads would be more accurate
06:42:00 <Iceland_jack> that was a joke :)
06:42:10 <Iceland_jack> my Internet just died so sorry for missing the discussions
06:49:33 <davd> "./Data/Vector/Generic.hs:400 (slice): invalid slice (574,765,968)" <- am I stupid or why would it be invalid? the length is 968.
06:50:45 <bennofs> davd: the second argument to slice is the length of the slice, not the end position
06:50:47 <merijn> davd: 0 indexed?
06:51:19 <bennofs> From the docs: "O(1) Yield a slice of the vector without copying it. The vector must contain at least i+n elements."
06:51:20 <davd> shit. thanks!
06:51:20 <Iceland_jack> davd: 574 + 765 <= 968 must hold
06:51:41 <davd> of course I was doing slice idx1 idx2..
06:52:06 <Iceland_jack> davd: (I've never used it before, I just searched for the error message and found)
06:52:07 <Iceland_jack>     ... (i >= 0 && m >= 0 && i+m <= n)
06:52:07 <Iceland_jack> :)
06:52:24 <xplat> clearly that interface is not strongly-typed enough
06:52:40 <Iceland_jack> it needs more singleton types :)
06:53:27 <xplat> mostly it would help to distinguish length/offset from index
06:53:54 <c_wraith> that's an interface that can't be typed sanely without dependent types.  If you can do so with singleton types, I kinda don't want to use the result. :)
06:54:14 <Iceland_jack> c_wraith: I didn't say sanely
06:54:44 <xplat> nah, it would be fine if there were a NumTorsor class above Num
06:55:00 <xplat> my version, anyway
06:55:45 <toki78> heya
06:56:10 <albeit> If you have an MVar as a field in a record, say MVar (Map Int String) is it normal to call it mvFoo or mv_foo, or somehow name it so its clear it is an mvar?
06:56:56 <xplat> it's not usual.  i wouldn't go so far as to say it's not normal
06:56:58 <Iceland_jack> albeit: I've seen that done with MVars and IORefs (ref...) but I'm not sure I would do that personally
06:58:54 <Baughn> So, what's the story on securely distributing code? Does hackage use https now?
07:00:54 <luite> chrisdone has written a tool for signing packages, but it's not been integrated into cabal yet. (i think that's a better option since it goes much further than just the download connection to guarantee the authenticity of files, setting up mirrors would be easier)
07:01:35 <merijn> hmmm, it seems that the Applicative laws can be a pain to prove, is there a good way to check whether my instance is right? Other than asking someone here to double check...
07:01:53 <napping> You could prove them in Coq or Agda
07:02:10 <Baughn> luite: It is, but defence in depth. A lot of packages won't get updated in a timely manner, so unless we're going to delete everything and start over..
07:02:12 <merijn> napping: That is not less of a pain
07:02:31 <napping> Not less of a pain, but you get more of a guarantee you didn't make a mistake
07:02:34 <toki78> Hi
07:02:47 <toki78> is there graphics stuff for haskell ?
07:02:48 <luite> Baughn: you could run a script to sign all existing packages with a hackage key
07:02:49 <xplat> merijn: what kind of a type are you proving them for?
07:02:50 <napping> If you're not willing to write a proof, doesn't it all come down to asking people to take a look?
07:03:11 <napping> toki78: there's a few, what sort of things are you looking for?
07:03:14 <toki78> I want to write a RL agent with graphics
07:03:15 <Baughn> luite: I... suppose. Then cabal needs to recognise that and.. print a warning, or something.
07:03:21 <napping> What's RL?
07:03:27 <toki78> napping, renedering is enough
07:03:41 <toki78> napping, a fancy UI is not necessary
07:03:50 <luite> Baughn: sure it'd take a bit of time for cabal to support. does it (or the HTTP package) support https already?
07:03:54 <toki78> napping, reinforcement learning
07:04:12 <merijn> xplat: newtype for "Parser (a, ParseState)"
07:04:13 <napping> gloss is probably the simplest to get going
07:04:37 <Baughn> luite: Not to my knowledge, and I'd be deeply disturbed if the author tries to implement it. :)
07:05:05 <luite> i'd be happy to get https working for my hdiff mirror, but i don't have any guarantees for the authenticity of the files on my mirror atm
07:05:09 <xplat> merijn: ah, i see why it's a pain to prove
07:05:27 <Baughn> Security is a pain, but sadly necessary.
07:05:40 <xplat> merijn: unfortunately, seems like it would be a pain to test too
07:05:51 <toki78> napping, wanna catch mouse clicks, too
07:05:52 <Baughn> HTTPS has a lot of pitfalls, though. It's really best left to the experts, and even then I wouldn't trust a library less than a few years old.
07:06:04 <toki78> napping, might be impossible with gloss
07:06:06 <napping> toki78: yeah, gloss can do that.
07:06:10 <merijn> xplat: Basically, my parsestate is not quite a monoid, so it's not trivial to see that it's correct
07:06:22 <napping> It doesn't do pretty text, but it's easy top get going
07:06:48 <napping> toki78: check out the "Game" interface
07:06:48 <xplat> merijn: not quite a monoid?
07:07:40 <merijn> Oh wait
07:07:42 <merijn> Maybe it is
07:07:47 <napping> toki78: diagrams is pretty good if you want to make pretty diagrams, and there are also bindings for SDL, OpenGL, cairo/gtk, etc
07:07:47 <luite> Baughn: would it take less time for a haskell lib to gain enough trust, say compared to some C library that's so widely used that it's extremely unlikely to contain very serious information leak bugs? ;)
07:08:14 <toki78> napping, is all that possible in conjuction with gloss ?
07:08:15 <Baughn> luite: Of course.
07:08:26 <Maior> I'd be more likely to trust a Haskell implementation of SSL than a C one ;)
07:08:26 <Baughn> luite: But the fact remains that cryptography is hard.
07:08:49 <napping> toki78: not as far as I know, there might be some way to add custom openGL stuff into gloss. I was listing those as other libraries that are probably more powerful but harder to use
07:08:51 <merijn> Monoid laws are just "mappend mempty p == p", "mappend p mempty == p" and "mappend (mappend x y) z == mappend x (mappend y z)", no?
07:08:52 <Baughn> *Most* implementation bugs are memory errors of some kind, that's true. Not all of them.
07:08:55 <xplat> Baughn: unfortunately you can't go shopping until you do the cryptography ;)
07:09:03 <merijn> Lemme see if those hold
07:09:23 <napping> merijn: if those don't, you'll have a hard time getting an applicative
07:09:24 <luite> Maior: it'd be good if there was some effort for auditing packages like tls
07:09:45 <merijn> napping: Well, I was forgetting monoid doesn't have to be commutative :)
07:09:53 <napping> oh, yeah, that's way harder
07:10:19 <Baughn> luite: Although I don't think I'd trust a haskell library in the "No side-channel attacks" sense, because geez.
07:10:21 <toki78> napping, http://hackage.haskell.org/package/gloss-game is what I need...thanks !
07:10:24 <napping> well, stronger
07:10:42 <napping> toki78: oh, what's that do?
07:10:52 <xplat> Baughn: i wouldn't trust coq libraries in a 'No side-channel attacks' sense ...
07:11:13 <napping>  huh, looks like a pretty thin wrapper around the gloss game stuff, but it does bundle it up nicely
07:11:26 <napping> Baughn: I don't think side channels are as important for a client-side https librarty
07:11:36 <luite> Baughn: that's a harder problem, how do you go about proving immunity to them anyway, but arguably far less serious for a client program
07:11:53 <napping> xplat: you'd go for deeply embedding a language with predicatable typing
07:11:54 <luite> even for servers th attacks tend to be far less practical
07:12:00 <napping> predictable timing, I mean
07:12:14 <merijn> napping: Well, I don't think I can make it an Applicative anyway, but I might be able to make it a monoid, which would serve me too
07:12:18 <napping> luite: I wouldn't go that far, if you have secret keys to worry about leaking
07:12:39 <napping> merijn: why not? Aren't parsers usually at least applicative?
07:13:19 <napping> pure always succeeds with no input and an mempty ParserState, <*> runs the parsers in order and then applies together the results in the right way
07:13:23 <merijn> napping: I need one that allows partial success
07:13:25 <xplat> napping: yeah, but i'd still have to trust that the language compiles to something that actually respects the timing (and energy use, and heat production, and vibration symmetry, and ...) guarantees on my actual hardware
07:13:45 <merijn> napping: ParseState indicates whether the remaining parse should abort
07:13:52 <napping> xplat: sure, but why do you trust any random chunk of C or assembly does that?
07:13:53 <merijn> napping: But you can't do that with Applicative
07:14:04 <napping> merijn: why not?
07:14:09 <xplat> napping: i don't!
07:14:19 <xplat> napping: (and it doesn't)
07:14:21 <merijn> napping: Because if your "Parser (a -> b)" abort, how can you produce the needed "f b"?
07:14:38 <napping> just like Nothing :: Maybe (f b)
07:14:45 <merijn> napping: That's not the same
07:14:51 <merijn> :t (<*>)
07:14:52 <lambdabot> Applicative f => f (a -> b) -> f a -> f b
07:15:02 <napping> I presume if a Parser (a, ParseState) aborts, you don't actually end up with an a
07:15:15 <merijn> "Parser (a -> b) -> Parser a -> Parser b"
07:15:18 <toki78> gloss-game is awesome :)
07:15:36 <toki78> opengl is included, too
07:15:47 <napping> Ah, nice
07:16:11 <xplat> merijn: if your Parser (a -> b) aborts, you produce a Parser b that always aborts
07:16:20 <merijn> napping: If you have "foo, bar :: Parser (a, ParseState)" then "foo <> bar" can return the result of "foo" if bar aborts
07:16:32 <merijn> xplat: That's my point, I need *partial* parses
07:16:46 <merijn> attoparsec can already do aborting parsers
07:16:49 <napping> merijn: That's a monoid <> you wrote, not an applicative <*>
07:17:09 <merijn> napping: Right, that's why I said "I don't think I can make it an Applicative, but a Monoid should work"
07:17:09 <xplat> ah, yeah, you probably just want a monoid then
07:17:32 <napping> Well, is the monoid suppose to parse alternatives or what?
07:18:02 <dhaya_> Hello, I was trying to generate random capital ascii letters. Here's my attempt http://lpaste.net/104214
07:18:06 <toki78> napping, I will let you know, when my agent is finished
07:18:14 <xplat> napping: it's basically like First i think
07:18:16 <dhaya_> It seems to hang when I run it.
07:18:21 <albeit> Is there a method to take an MVar and immediately replace with the same value? I don't see anything in the docs, except doing take then put manually.
07:18:35 <luite> napping: hmm perhaps i'm not as well-informed, but have there been side-channel attacks (on just the ssl part of the connection) with as much impact as heartbleed?
07:18:36 <napping> albeit: readMVar does that
07:18:44 <luite> napping: or perhaps that's just a red herring if there aren't, and the real point is that there must be many times more side channel attack vectors than those high profile bugs, each with lower impact and less known, but more dangerous combined?
07:18:55 <xplat> napping: er, Last rather
07:19:04 <napping> luite: Well, if you leak your private key it's game over
07:19:24 <napping> I don't think anything has come out as bad as heartbleed, but it's still not a good idea
07:19:27 <merijn> napping: No, it supposed to parse 1 value, combined with (optionally, depending on the first value) a second value
07:19:48 <merijn> luite: OpenSSL is freaking doomed anyway
07:19:50 <napping> merijn: do your parsers all cary a default value for failure then?
07:19:56 <xplat> well, there was some attack i heard of where someone could steal a private key with a microphone
07:20:00 <edwardk> so are there any #haskellers in the LA area? Stuck with a 7-8 hour layover and nothing to do all morning
07:20:01 <merijn> napping: If 'a' is a monoid they do :)
07:20:15 <albeit> napping: Ah I thought it was just takeMVar modified, but guess not, thanks
07:20:18 <napping> merijn: sure, but then you can only combine things of the same type
07:20:25 <merijn> napping: But that's good enough
07:20:41 <napping> albeit: you might prefer to switch to TVar if you want to peek at things like that, I think readMVar is really just a take+put
07:20:50 <xplat> edwardk: there's a #haskeller who remembered to ping you about concurrent revisions
07:20:56 <merijn> luite: Some of my colleagues have succeeded in finding RSA keys by listening to the signature sound of cellphones running SSL code
07:21:01 <napping> and that can make bad things happen if there's a concurrent push or something
07:21:09 <Baughn> albeit: Caution, using take then put /would not work/; there'd be a race condition in there.
07:21:17 <albeit> napping: I don't need to do it often, just one small function where I'm checking if a key exists in an MVar Map
07:21:19 <edwardk> xplat: it is a lovely side-channel attack
07:21:21 <Baughn> albeit: readMVar does. Though if you do anything more complex, look into STM.
07:21:32 <napping> albeit: readMVar does *not* work!
07:21:34 <merijn> luite: So, they can passively get RSA keys from a side channel from any phone that uses SSL within like 20+ meters
07:21:48 <edwardk> ReinH: pong
07:21:54 <luite> napping: sure, but do you actually get the opportunity? if you have access to the local machine then many more attacks become practical, but the internet does add a fairly high noise floor
07:21:58 <napping> Baughn: readMVar is nothing more than take + push
07:22:00 <albeit> napping: What do you mean?
07:22:12 <Baughn> napping: It's specified to be atomic
07:22:19 <Baughn> It used to be take+push, but that was a while ago
07:22:20 <napping> oh, Is it now?
07:22:26 <merijn> napping: Yes, it was changed a while ago
07:22:36 <c_wraith> I don't think it was a while ago
07:22:41 <c_wraith> I think it was pretty recent
07:22:52 <Baughn> It says "Base 4.7", and we're on 7.6...
07:22:54 <merijn> c_wraith: "A while ago" to me means within the last 6 months
07:22:55 <luite> merijn: hmm, that's interesting, from smartphones using ssl to browse websites?
07:22:57 <zerokarmaleft> if I have some operator defined that's associative, what infix precedence level should I set?
07:23:08 <xplat> practically, you need a base constraint if you want to rely on readMVar being atomic
07:23:10 <merijn> luite: Well, using SSL for anything, but including browsing, yes
07:23:11 <c_wraith> merijn: that's only the most recent major version of GHC. :P
07:23:12 <napping> Baughn: We are on base 4.7
07:23:29 <c_wraith> Baughn: base and ghc don't have the same version number
07:23:31 <napping> Baughn: base numbers don't match GHC numbers. Actually, I think base 4.7 is only with GHC 7.8!
07:23:34 * Baughn blinks
07:23:38 <Baughn> I see..
07:23:40 <c_wraith> Baughn: base 4.7 is GHC 7.8
07:23:46 <Baughn> Right, then.
07:23:49 <napping> Isn't GHC 4.7 pre-IO?
07:23:51 <Baughn> albeit: Don't use readMVar. Use STM.
07:24:14 <albeit> Baughn: Say what now? Isn't it atomic now?
07:24:22 <napping> albeit: are you using GHC 7.8?
07:24:24 <Baughn> albeit: Apparently only on 7.8 and up
07:24:25 <xplat> merijn: are you sure you mean private keys?  client-side SSL doesn't normally even use one unless you're using a cert
07:24:27 <albeit> Yes on GHC 7.8
07:24:28 <napping> if so, I guess it just became atomic
07:24:45 <c_wraith> albeit: if you depend on that, be *very* certain to specify your code only works with base > 4.7
07:24:59 <c_wraith> Well, >= 4.7.0.0
07:25:00 <napping> luite: I'm thinking more that for client side you don't have anything more sensitive than a session key - and that gives a limited time to attack
07:25:25 <napping> luite: there was a paper where using strcmp to check passwords was successfully attacked across the country or something, so timing isn't *that* hard to see
07:25:27 <albeit> c_wraith: Will do
07:25:48 <toki78> napping, I will upload it to github
07:26:04 <c_wraith> napping: added latency is just a bit more noise to work around.  It makes the attack take longer, but it still works the same way.
07:26:07 <napping> albeit: better if you're sure you don't need it to be atomic, or if you just use STM - TMVar is basically MVar but everything is atomic and composable
07:26:24 <napping> c_wraith: exactly, luite was hoping for more
07:26:25 <xplat> zerokarmaleft: the only thing 'is associative' tells me about what precedence you should use is that whichever you use, you should set it with either infixl or infixr :)
07:26:49 <napping> c_wraith: jitter makes it harder
07:26:51 <toki78> anyone interested in an example for ersatz ?
07:26:55 <napping> c_wraith: well, non-constant latency
07:27:22 <napping> albeit: STM / TMVar doesn't offer as strong of guarantees on what gets woken, though. Depending just how tricky you are getting
07:27:24 <wankeler> anyone know whats happening with the haskell platform?
07:27:31 <c_wraith> napping: if it has a gaussian distribution, it doesn't make it harder at all.  If the jitter has some other distribution, then it gets slightly harder.
07:28:09 <napping> c_wraith: If you had perfectly fixed latency, you wouldn't need any more samples than with no latency
07:28:31 <napping> c_wraith: with even a nice gaussian jitter you need at least a few samples to approach confidence one thing is slightly faster than another
07:28:47 <napping> not really conceptually harder, but taking more time at least
07:28:53 <c_wraith> Only a little.
07:29:06 <c_wraith> You have to assume gaussian jitter in just about every timing attack anyway
07:29:10 <napping> depends how the variance compares to the difference you're looking for
07:29:22 <c_wraith> So adding more just slows the attack down - you don't need to code around.
07:29:36 <napping> Like a difference of a handfull of instructions / ns under maybe milliseconds of variance
07:29:39 <zerokarmaleft> xplat: ah, I was looking for the left and right associative versions...thanks
07:29:43 <luite> napping: hm do you have a source for that?
07:30:00 <napping> "Remote Timing Attacks are Practical"
07:30:05 <jophish> was the haskell98 report written in 1998, or 1999?
07:30:17 <c_wraith> jophish: why do you reject 1997?
07:30:28 <napping> perhaps see also "Remote Timing Attacks are Still Practical", but that's not the one I read
07:30:38 <xplat> c_wraith: when did a committee ever produce anything on time?  :)
07:30:44 <napping> google for "network timing attacks"
07:30:49 <c_wraith> jophish: mostly it's a rewrite of the earlier Haskell 1.4 specification.
07:31:05 <jophish> c_wraith: I can't believe that a report like that was out early! Just look at c++0x!
07:31:42 <c_wraith> jophish: See, I meant when it was actually written, not published.
07:31:44 <xplat> yeah, i don't think they were thinking c++0c or whatever it was
07:32:14 <c_wraith> Was '98 the one that was released on april fool's day?
07:32:17 <jophish> ah, I meant publication
07:32:18 <c_wraith> Or was that 1.0?
07:32:22 <jophish> for citing it as a reference
07:32:52 <c_wraith> jophish: https://research.microsoft.com/en-us/um/people/simonpj/papers/history-of-haskell/history.pdf probably answers your question.  Also, it has a clever title
07:33:11 <c_wraith> And it was version 1.0 that was released on April Fool's day
07:33:46 <c_wraith> jophish: indeed, it says that the Haskell 98 report was published in February 99
07:34:15 <luite> napping: can't find the strcmp thing though
07:34:50 <napping> luite: oh, that's either something older or I was remembering it wrong
07:35:16 <jophish> awesome, thanks, c_wraith
07:35:33 <luite> c_wraith: gaussian is an assuption though, are all the preconditions really met in practice? perhaps expected values change, or measurements aren't quite independent
07:35:35 <napping> luite: but maybe this is a different version: http://blog.astrumfutura.com/2010/10/nanosecond-scale-remote-timing-attacks-on-php-applications-time-to-take-them-seriously/
07:36:01 <napping> luite: the assumption is just that trying each a few times, maybe alternating, will tell you what's faster
07:36:49 <luite> napping: right, but that one (just pulled that up half a minuted ago) goes a lot closer than across the country. within the datacenter, or on the same physical machine when running cloud, would open so many more options
07:37:18 <osa1> what does "hash-consed" mean? (saw in the documentation of GHC FastString implementation)
07:37:45 <luite> osa1: that a new string with the same value as some existing object in memory will return a reference to the existing one
07:37:53 <bennofs> How can I define a CPP macro such that X(3) is x3 :: Int; x3 = undefined ?
07:38:11 <merijn> bennofs: For C or for Haskell?
07:38:18 <bennofs> merijn: haskell
07:38:20 <osa1> luite: so it's like "intern"ing
07:38:21 <osa1> ?
07:38:25 <merijn> bennofs: You're boned, I think
07:38:58 <merijn> bennofs: CPP has a concatenation operation, but I was not able to get it to work reliably with GHC
07:39:00 <luite> osa1: it can be runtime though, interning is compile time (or at least that's how i know it)
07:39:11 <bennofs> merijn: ok, I think I will just x3 too
07:39:39 <merijn> bennofs: Normally "#define CONCAT(a,b) a##b" would cause "CONCAT(x, 3)" to result in "x3"
07:39:59 <merijn> If you get it to work, lemme know how
07:42:03 <luite> osa1: ah right, so it's more like interning indeed (just saw that java strings have an explicit intern method), but at construction time
07:44:44 <osa1> luite: I think lisps also have that notion of interning/hash-consing (done to "symbols" instead of strings)
07:44:54 <Kinnison> bennofs: does it have to be CPP and not template-haskell?
07:45:13 <bennofs> Kinnison: it's easier to do in CPP than in TH in my case
07:46:02 <luite> osa1: right, that's what i thought of first, since those are compile time constants
07:46:46 <Kinnison> bennofs: fair enough
07:57:04 <exicer> Is it possible to insert values in multiple places in a query using postgres-simple ?
07:57:14 <xplat> luite: a lot of lisps can intern a string as a symbol at runtime.  elisp for one.
07:58:12 <xplat> by which i mean, 'intern' is a function
07:58:12 <exicer> e.g. insert into x  (a, b) VALUES (?,?) where not exists ( select 1 from x a = ? ) or something ?
07:59:02 <xplat> exicer: where you want the first and third ? to be the same value?
07:59:22 <c_wraith> aren't there things based on StableName that provide functionality like intern tables?
08:00:26 <Guest70071> If you are designing a library API, how do you decide whether the functions should return `Either <errortype> <returntype>` vs. `ErrorT <errotype> m <returntype>`?
08:01:12 <c_wraith> I can't think of any case in which I'd prefer the latter, as a library developer or as a user.
08:01:35 <bennofs> Guest11663: I think the error library even provides a function to lift from the former to the later
08:01:49 <bennofs> @ty hoistEither
08:01:50 <lambdabot> Not in scope: ‘hoistEither’
08:01:56 <bennofs> @hoogle hoistEither +errors
08:01:57 <lambdabot> Could not find some databases: errors
08:01:57 <lambdabot> Searching in:
08:01:57 <lambdabot>   .
08:02:06 <savanni> Why is that?  I've encountered this idea before but haven't written enough code to really decide on one or the other.  I rather like the ErrorT version so that I can easily bind library functions together.
08:02:16 <c_wraith> bennofs: you missed the name change. It's savanni now. :P
08:02:26 <savanni> Yeah, I didn't realize I wasn't logged in.
08:02:29 <quchen> (mmorph has a general API to do mangle things around between transformers.)
08:02:32 <Baughn> savanni: Not everyone uses ErrorT. If the library is only for your own use, feel free.
08:02:48 <bennofs> savanni: http://hackage.haskell.org/package/either-4.1.2/docs/Control-Monad-Trans-Either.html#v:hoistEither
08:03:08 <quchen> I'd say don't use transformers unless needed.
08:03:09 <savanni> Oh, are people really moving towards the either/error libraries?
08:03:45 <bennofs> Another idea would be to return Except e a from http://hackage.haskell.org/package/transformers-0.4.1.0/docs/Control-Monad-Trans-Except.html
08:04:03 <exicer> xplat: Yeah
08:04:05 <c_wraith> savanni: yeah, I don't like ErrorT at all.  That's another reason. :)
08:04:41 <savanni> I'm just wondering what I'm missing that makes it annoying.
08:05:17 <c_wraith> savanni: I don't like the integration with the Error class at all, and I don't think I'm alone on that.
08:05:36 <quchen> savanni: ErrorT requires its error type to be an Exception, which requires Show and Typeable, and those constraints have their pros and cons.
08:06:04 <bennofs> also, it requires that you can construct an error from a string message
08:06:06 <bennofs> iirc
08:06:40 <c_wraith> quchen: it depends on Error, not Exception
08:06:41 <quchen> Oh, it's not "Exception", it's the "Error" class.
08:06:48 <quchen> ^^ beat me to it :-)
08:06:52 <savanni> Yeah, I've avoided Exception because it's so complicated.
08:06:56 <c_wraith> yeah, I really dislike everything about the Error class
08:07:10 <c_wraith> And so I don't like ErrorT because of the integration with Error
08:07:36 <quchen> Well, take the Error class away and ErrorT is ExceptT, no?
08:08:08 <savanni> Okay, I'll read up on the Except and Either transformers.  I just hate the Either monad implementation.
08:08:14 <c_wraith> quchen: and http://hackage.haskell.org/package/either which I prefer over ExceptT
08:08:49 <bennofs> c_wraith: why is that?
08:08:59 <bennofs> c_wraith: (prefering either over except)
08:09:28 <c_wraith> bennofs: the author.  Things by edwardk get much more adoption, so it has an automatic network effect going for it.
08:09:47 <bennofs> c_wraith: exceptT is in transformers
08:09:55 <savanni> What about http://hackage.haskell.org/package/errors ?
08:10:20 <c_wraith> savanni: you'll note that depends on the either package. :)
08:10:56 <c_wraith> savanni: and you'll note that the either package has hoistEither :: Monad m => Either e a -> EitherT e m a
08:10:57 <sinelaw> acowley: hey
08:11:17 <quchen> c_wraith: I crashed, but your message was already in the logs. I should look into EitherT vs ExceptT.
08:12:27 <savanni> c_wraith: okay got it.  I'll see about standardizing on that.
08:12:27 <bennofs> I think the 'either' package could just type-alias EitherT to ExceptT if there is a new transformers available
08:12:39 <sinelaw> acowley: i'm looking at your fork of HOpenCV
08:13:07 <c_wraith> Huh, yeah.  The new version of transformers has a ton of stuff that's not in MTL
08:13:34 <xplat> c_wraith: more than meets the eye, indeed
08:13:35 <edwardk> bennofs: on reason ExceptT hasn't seen much adoption is it is brand new and you can't use transformers 0.4 for with much code yet.
08:13:53 <edwardk> bennofs: I've had the either package running around for a long time.
08:14:12 <edwardk> errors is a thin wrapper arund either.
08:14:16 <c_wraith> edwardk: you mentioned that mtl follows transformers..  Does that mean a big update is coming to work with transformers 0.4?
08:14:19 <bennofs> edwardk: but could 'either' be changed to type-alias EitherT to ExceptT? That way, for example the errors package could be used with new transformers
08:14:35 <edwardk> c_wraith: i shipped an updated mtl last week or so
08:14:40 <c_wraith> oh, huh
08:14:42 <bennofs> edwardk: (of course only if transformers is new enough)
08:15:19 <edwardk> bennofs: what i've done instead is updated transformers-compat to generate a transformers compatible ExceptT when linked against old transformers
08:15:58 <edwardk> bennofs: if you want to use most of the functionality of transformers 0.4 with older transformers/platforms you can require transformers >= 0.2 && <= 0.5, transformers-compat >= 0.3.1
08:16:44 <edwardk> then you get most of the transformers goodness (other than new class members i can't fake) even on old platforms and in situations where yu link with ghc / old template-haskell where upgrading transformers isn't allowed.
08:17:14 <bennofs> edwardk: hmm, so maybe errors should be updated to use that and ExceptT instead of EitherT?
08:17:39 <edwardk> bennofs: i'm waiting to see what the reception is for the transformers variant before doing anything that breaks literally every user
08:18:18 <edwardk> i have 2 dozen packages to update that sit on top of that between private/public projects
08:18:33 <Guest48175> I was addicted to watching pornography for 10 years, write me if you want to know more :)
08:18:35 <edwardk> and i have more pressing things to fix in the transformers 0.4 upgrade process
08:18:47 <bennofs> ah, I see
08:20:29 --- mode: ChanServ set +o edwardk
08:20:36 --- mode: edwardk set +b *!~some1@178.115.131.7.wireless.dyn.drei.com
08:20:38 --- kick: Guest48175 was kicked by edwardk (Your behavior is not conducive to the desired environment.)
08:20:50 --- mode: edwardk set -o edwardk
08:25:14 <edwardk> bennofs: anyways, http://packdeps.haskellers.com/reverse/either it has a lot of immediate revdeps, more if you count transitive ones through http://packdeps.haskellers.com/reverse/errors
08:25:28 <edwardk> bennofs: so i'm going to take API changes there very slowly.
08:25:46 <ziggystar> How would I find the generalization of concat for monads with hoogle? I tried "m m a -> m a" but didn't get something useful.
08:25:56 <Iceland_jack> :t join
08:25:57 <lambdabot> Monad m => m (m a) -> m a
08:26:00 <edwardk> with lens people at least sign up for the chaos to some degree ;)
08:26:08 <Iceland_jack> @hoogle m (m a) -> m a
08:26:08 <lambdabot> Control.Monad join :: Monad m => m (m a) -> m a
08:26:08 <lambdabot> Test.QuickCheck.Property joinRose :: Rose (Rose a) -> Rose a
08:26:09 <lambdabot> Prelude concat :: [[a]] -> [a]
08:26:16 <ziggystar> Ah,Yeah, I forgot the parens.
08:26:17 <ziggystar> Thanks.,
08:26:37 <bennofs> edwardk: it's unfortunate that it exports the EitherT constructor :( Otherwise, this change wouldn't have caused backwards compatibility to break, or am I missing something?
08:26:43 <ParahSailin> how do you tell cabal to build libraries only for a library+executable project
08:27:10 <edwardk> bennofs: the change would still be invasive. Typeable instances go away because Ross doesn't believe in them, etc.
08:27:33 <bennofs> oh, I didn't think about the instances
08:29:03 <ziggystar> So I'm slowly getting the hang of writing Haskell code with all the <$>, >>=, sequenceA, mapM and stuff. Will I be ever able to read something like this?
08:29:10 <Iceland_jack> sure ziggystar
08:29:18 <edwardk> Also, downgrading from prelude-extras to the transformers versions of the typeclasses I wrote hurts because I lose DefaultSignatures and all the names were bikeshedded at random
08:29:46 <edwardk> ziggystar: after a while it becomes second nature
08:29:48 <Iceland_jack> I personally try to minimize their use a bit, and hypothetical sugar would make some of those redunant
08:30:25 <ziggystar> It also appears to me that there are many different ways to write something. Take alone how you use '.' and '$' to get the function calls right. Or whether you use <$> of fmap.
08:30:42 <xplat> ziggystar: haskell isn't python, yeah
08:30:46 <Iceland_jack> Yes that's right
08:31:00 <Iceland_jack> there is also some fallback because of historical reasons
08:31:11 <ziggystar> So if you always use parens to make your funciton calls and someone else uses $ and .; then you won't be able to read the different code.
08:31:15 <Iceland_jack> notably that Applicative was not a superclass of monad
08:31:17 <quchen> ziggystar: We've all been there. It becomes remarkably clear sooner than you expect.
08:31:30 <ziggystar> Ok, I hope. :)
08:31:43 <xplat> ziggystar: just like with human languages, it's possible to learn to read things you wouldn't write
08:32:03 <Iceland_jack> xplat: In Haskell it's also possible to write things you don't understand :)
08:32:07 <ziggystar> At least having hlint suggest how to rewrite stuff appears to be very helpful.
08:32:29 <dmj`> If a package has no core api changes, but small fixes (i.e. 7.8 support, body of a function changed slightly w/o altering type signature) does it warrant a version bump?
08:33:12 <xplat> dmj`: to the third number, at least
08:33:18 <Iceland_jack> ziggystar: There is a possible syntax extension
08:33:18 <Iceland_jack>     [| x + y * y |]
08:33:18 <Iceland_jack> that could replace something like
08:33:18 <Iceland_jack>     (\a b -> a + b * b) <$> x <*> y
08:33:21 <Iceland_jack> or
08:33:26 <Iceland_jack>     liftA2 (\a b -> a + b * b) x y
08:33:29 <Iceland_jack> called “idiom brackets”
08:33:52 <ziggystar> @ice I'm redaing it up.
08:33:53 <lambdabot> unexpected "I": expecting number, "d" or "("
08:33:54 <Iceland_jack> It's not present in Haskell but you can simulate it using quasiquoters
08:34:12 <Iceland_jack> It exists in more recent languages like Idris
08:35:17 <xplat> edwardk: so, concurrent revisions--do you remember what state you left it in (and where?)
08:35:46 <Iceland_jack> Things that you'd write 'raw_input() + raw_input()' in Python could then be written
08:35:46 <Iceland_jack>     [| getLine ++ getLine |]
08:35:49 <edwardk> xplat: you at bay hac?
08:35:59 <quchen> The barrier to enter Haskell is pretty much "wait how can this be useful in practice" from the front. The back says "how can things be useful without having that".
08:36:01 <ziggystar> Btw. the worst about Haskell to me is: 1) problems with tooling (cabal hell, problems getting packages compiling, installing) and 2) the historic ballast.
08:36:12 <edwardk> i recall leaving it busted wide open while i switched out the guts to support record and to use the lca package
08:36:13 <xplat> edwardk: no :I
08:36:32 <edwardk> will you be at hac boston? =)
08:36:32 <Iceland_jack> ziggystar: The historic thing is not really that bad
08:36:41 <xplat> edwardk: maybe?
08:36:58 <ziggystar> I find it somehow wierd to have the Prelude be cluttered by string functions.
08:36:58 <edwardk> then if nothing else we can finish it up there ;)
08:36:58 <exicer> I can't work out a way to do an upsert with postgres-simple :S
08:37:17 <Iceland_jack> ziggystar: Why?
08:37:21 <quchen> ziggystar: Don't judge Haskell by the Prelude ;-)
08:37:22 <ziggystar> But it appears to be changed easily with the correct imports (exports).
08:37:47 <edwardk> exicer: does this fact make you upser^Ht?
08:38:07 <exicer> edwardk: :p
08:38:08 <xplat> exicer: you want to do your upserts as postgresql functions, normally
08:38:31 <exicer> xplat: Yeah, I'm unsure how to call them from postgres-simple
08:38:48 <quchen> ziggystar: The Prelude is historically grown like this, but very hard to change, since it's imported implicitly in every module (that doesn't explicitly not import it). Many (dare I say "most") functions from Prelude can be found in generalized versions in other modules.
08:39:51 <edwardk> quchen: with 7.10 we'll at least fix the worst of that
08:39:58 <xplat> exicer: just 'select myfunc(?,?,?,...)'
08:40:06 <quchen> edwardk: Oh? You're not talking about the base split here, are you?
08:40:19 <xplat> exicer: or 'execute' if you don't need the answer and you have new enough postgresql
08:40:23 <edwardk> quchen: AMP, Foldable/Traversable for Prelude, etc.
08:40:56 <Iceland_jack> edwardk: Oh I wasn't aware of Foldable and Traversable
08:40:59 <edwardk> tightening up the types on mapM, etc.
08:40:59 <quchen> Oh right, I forgot about the Foldable/Traversable plans, there was a thread on the lists a year ago or so
08:41:04 <edwardk> yeah
08:41:12 <edwardk> and we tabled it because 7.8 was happening 'any day now'
08:41:13 <exicer> xplat: I wanted to create the function via haskell, I mean (I have some kind of install script)
08:41:16 <quchen> edwardk: Are there plans on removing functions like sequenceA and mapM?
08:41:22 <dmj`> xplat: In the pvp it says only if new "bindings, types, classes, non-orphan instances, modules" were added A.B may remain the same, but C must be greater. Otherwise, A.B.C may remain the same (other version components may change)."
08:41:29 <quchen> (sequenceA -> sequence, mapM -> traverse)
08:41:36 <edwardk> the current plan is to promote them to use the better type but leave them as aliases
08:41:39 <xplat> exicer: oh, i couldn't tell you that offhand
08:41:52 <exicer> xplat: I guess I could just have some python script to do it
08:41:52 <quchen> Sounds reasonable.
08:42:07 <l4u> i got a newbie type error when using Data.Map https://gist.github.com/l4u/cfcd1be4a639e874b5f3  any clue?
08:42:13 <dmj`> xplat: and in this case none of those things were added
08:42:27 <edwardk> so they'd move out of the class necessarily, which will cause some import changes, but they'll be in Prelude so the stuff that is missed will be there, it should be about a wash
08:42:35 <Iceland_jack> l4u: delete is being applied to a set
08:42:36 <quchen> (Can making 'sequence' use Applicative even cause ambiguities or is the change trivial?)
08:42:45 <Iceland_jack> *map
08:42:45 <edwardk> we're talking about switching to traverse/sequence rather than traverse/sequenceA as well
08:42:55 <xplat> dmj`: well, you could use the fourth component or further down, i just didn't think that many people actually used them in practice
08:42:55 <l4u> Iceland_jack oh Thanks
08:42:58 <edwardk> it can cause problems if we leave it in the class
08:43:03 <l4u> Iceland_jack i've added back the M.  it works now
08:43:04 <quchen> Oh, you're even moving them out of the class. That's nice.
08:43:07 <Iceland_jack> l4u: good
08:43:07 <edwardk> because it breaks all existing instances that define it anyways
08:43:23 <edwardk> they are all written assuming a full Monad
08:43:40 <quchen> On the bright side, the compiler should be very helpful at fixing the errors that this change would produce.
08:43:46 <edwardk> yes
08:44:24 <edwardk> it'll be a bit noisy uring the transition, but if you just define your traversables with traverse like a good Haskell citizen then everything will just work
08:44:27 <edwardk> =)
08:44:28 <quchen> I was very surprised how few AMP warnings (non-GHC) standard packages actually issued. I hope that trend continues for Foldable.
08:45:34 <edwardk> we're having some pain with GND and the new Monad def though
08:45:36 <frms_>  
08:45:50 <Iceland_jack> edwardk: How come?
08:45:55 <edwardk> adding join to the class causes the new GND checks to fail
08:45:57 <quchen> edwardk: Yeah I've seen that. join will probably lose the battle
08:46:11 <edwardk> quchen: or we'll switch up to a better role mechanism
08:46:19 <edwardk> i'd prefer the better role mechanism
08:46:52 <quchen> edwardk: Is there a good reason for having join in Monad apart from beauty anyway?
08:47:06 <quchen> (I'm all for beauty by the way) :>
08:47:25 <Iceland_jack> Some things are easier to define using join
08:47:25 <Iceland_jack>     join f x = f x x
08:47:36 <edwardk> well, one reason for defining monad as the two function version with return and >>= was that you only had to write two things
08:47:54 <quchen> Iceland_jack: Sure, but you can still define "m >>= f = myJoin (fmap f m)".
08:47:57 <edwardk> Now you'll be defining the Functor anyways, so that 'its shorter and i already said it' excuse is kinda thin
08:48:08 <edwardk> quchen: yes, but its an ugly idiom
08:48:14 <Iceland_jack> quchen: That would be less efficient though?
08:48:18 <monochrom> when I learned free monads, I saw how to write join earlier than how to write bind.
08:48:23 <edwardk> nd we already put in the warning telling everyone to change because it was coming
08:48:31 <edwardk> _and_ this is indicative of a larger class of problems
08:48:42 <edwardk> so i'd rather figure out how to solve that class of problems
08:48:43 <monochrom> a complete education must learn both. order is personal preference.
08:48:47 <quchen> monochrom: I've never seen join for Free. Your remark sounds like I'll be shocked by how simple it is.
08:48:54 <edwardk> not just bandaid over it and pretend role inference is fine as it is
08:49:08 * hackagebot aeson 0.7.0.6 - Fast JSON parsing and encoding  http://hackage.haskell.org/package/aeson-0.7.0.6 (BryanOSullivan)
08:49:10 * hackagebot vcs-revision 0.0.2 - Facilities for accessing the version control revision of the current directory.  http://hackage.haskell.org/package/vcs-revision-0.0.2 (EugeneKirpichov)
08:49:13 <Iceland_jack> I think 'join'
08:49:17 <benzrf> edwardk: hey what do i need to know about to understand lens at a less superficial level
08:49:17 <edwardk> join for Free just grafts the tees of trees into a tree, removing the seam
08:49:23 <Iceland_jack> *I think 'join' is more intuitive for people in general than (>>=)
08:49:23 <benzrf> i have found out about profunctors and comonads
08:49:26 <monochrom> oh, bind was simple after I figured it out, too :)
08:49:26 <benzrf> whats next >->
08:49:34 <quchen> BRB, writing join for Free
08:49:52 <edwardk> benzrf: a vulcan mind meld with me, shachaf, glguy, or elliott seems to be the most foolproof way.
08:50:14 <quchen> join (Free x) = Free (fmap join x)?
08:50:16 <edwardk> benzrf: failing that? lots of time on #haskell-lens asking questions
08:50:32 <monochrom> yes, I think so
08:50:34 <edwardk> or gettig obsessed with pure profunctor lenses and building a dozen lens libraries to try out the design space.
08:50:44 <edwardk> that approach seems to have worked well for others
08:51:09 <benzrf> ;-;
08:51:16 <xplat> i can vouch for the approach of getting obsessed with profunctors in general :)
08:51:27 <edwardk> heh
08:51:40 <benzrf> isn't -> the only interesting confunctor besides maybe Const
08:51:44 <benzrf> *cofunctor
08:51:51 <benzrf> or am i missing a lot
08:51:52 <edwardk> cofunctor isn't a word
08:51:53 <Iceland_jack> cofunctor?
08:51:58 <benzrf> contravariant functor
08:52:01 <benzrf> cofunctor is shorter to write :p
08:52:10 <edwardk> co- means flip the arrows in the category. okay.
08:52:14 <Iceland_jack> well cofunctors are functors so
08:52:21 <monochrom> I don't really care what is intuitive. I care what is necessary and/or interesting.
08:52:26 <benzrf> i was under the impression that cofunctor is a synonym of contravariant functor?
08:52:37 <benzrf> i do not really know cat theory
08:52:49 <Iceland_jack> benzrf: Some type classes for contravariant functors have been called Cofunctor or CoFunctor
08:52:56 <benzrf> hmm
08:53:02 <Iceland_jack> but they should really be called something like ContraFunctor
08:53:09 <edwardk> fmap :: Functor f => (a -> b) |-> f a -> f b   -- cofmap :: Functor f => (a <- b) |-> (f a <- f b) = Functor f =>  (b -> a) -> f b -> f a
08:53:18 <Iceland_jack> monochrom: Don't dismiss intuitive :)
08:53:19 <edwardk> notice its just fmap alpha renamed
08:53:32 <edwardk> :t Data.Contravariant.contramap
08:53:33 <lambdabot> Not in scope: ‘Data.Contravariant.contramap’
08:53:38 <edwardk> :t Data.Functor.Contravariant.contramap
08:53:39 <lambdabot> Contravariant f => (a -> b) -> f b -> f a
08:53:53 <erikc> is there a way to statically link libgcc and libgmp on osx, -static doesn’t seem to work (im using ghc installed with brew, would the Haskell Platform be configured differently?)
08:54:04 <benzrf> hmm
08:54:09 * hackagebot splot 0.3.12 - A tool for visualizing the lifecycle of many concurrent multi-staged processes.  http://hackage.haskell.org/package/splot-0.3.12 (EugeneKirpichov)
08:54:11 * hackagebot timeplot 1.0.25 - A tool for visualizing time series from log files.  http://hackage.haskell.org/package/timeplot-1.0.25 (EugeneKirpichov)
08:54:18 <benzrf> is there a term for things like the Functor instance for Const
08:54:23 <benzrf> is 'vacuous' appropriate?
08:54:31 <xplat> 'boring'?
08:54:34 <benzrf> ha
08:54:39 <btcNeverSleeps> newbie question: I've got two different computers and don't know what I did wrong on one of them: Emacs's C-c C-l (inferior-haskell-load-file) launches hugs instead of ghci. What should I do to have ghci open up instead of hugs inside Emacs?
08:54:39 <edwardk> benzrf: the concern is covariance and contravariance are actually very very different, so cofunctor is not just backwards its wrong.
08:54:47 <benzrf> oh.
08:54:51 <benzrf> >.>
08:54:53 <benzrf> alright then
08:55:03 <benzrf> in any case.
08:55:08 <Iceland_jack> btcNeverSleeps: haskell-program-name
08:55:14 <Iceland_jack> (setq haskell-program-name "ghci")
08:55:18 <edwardk> benzrf: we have 4 kinds of variance we can have on an argument. covariance and contravariance are what you expect.
08:55:21 <xplat> just like invariance and nonvariance are completely different
08:55:27 <monochrom> how about an analogy! you're going to a 4-course dinner. do you eat the salad first or the dessert first? the dessert is more "intuitive" in that it's more sugar-coated, every child finds it more intuitive. but that's exactly the wrong order. if you eat the dessert first, you lose appetite for the salad, the vegetables you need. screw intuitive. do the correct thing.
08:55:31 <btcNeverSleeps> Iceland_jack: thx, trying it right away
08:55:47 <edwardk> the other two don't get standard names. Som folks use invariance for needing both (a -> b) and (b -> a) as an isomorphism to change the field
08:56:13 <benzrf> i dont know what you mean by 'change the field'
08:56:15 <benzrf> :[
08:56:16 <monochrom> screw intuitive. be an adult and do the correct thing.
08:56:20 <Iceland_jack> monochrom: Are you discussing with me?
08:56:27 <benzrf> i vaguely recall fields as being a kind of ring or something
08:56:31 <quchen> xplat: Const is certainly not a boring type! It's used by Lens to model Getters, for example.
08:56:31 <edwardk> and anyvariant for phantom arguments, where you can make it both a normal covariant Functor and a Contravariant functor.
08:56:35 <monochrom> I don't know. I'm denouncing intuitive.
08:56:40 <xplat> monochrom: i intuitively eat the salad before dessert
08:56:46 <edwardk> benzrf: field here was being used informally. just like 'type argument'
08:56:47 <benzrf> anyway, are there any interesting Contravariant instances besides ((->) r)?
08:56:50 <benzrf> oh
08:56:52 <benzrf> ha
08:57:01 <Iceland_jack> monochrom: It sounds like you're denouncing using intuition as the primary benchmark
08:57:06 <btcNeverSleeps> Iceland_jack: thx a lot
08:57:11 <Iceland_jack> You're welcome btcNeverSleeps
08:57:12 <xplat> quchen: it's not a boring type
08:57:37 <xplat> quchen: some of the implementations of its instances are boring though.
08:57:41 <benzrf> *or wrappers of some kind around ((->) r)
08:57:52 <quchen> xplat: That's true.
08:58:00 <edwardk> benzrf: In Haskell the first arg of (->) (or not using it at all) is the origin of all variance flipping.
08:58:39 <benzrf> edwardk: i thought so =o
08:58:58 <xplat> benzrf: this doesn't mean there's nothing else interesting though
08:59:00 <benzrf> so what are profunctors useful for, exactly?
08:59:09 <benzrf> xplat: well, anything else would have to be a phantom type wouldnt it
08:59:10 * hackagebot acid-state 0.12.2 - Add ACID guarantees to any serializable Haskell data structure.  http://hackage.haskell.org/package/acid-state-0.12.2 (DavidJohnson)
08:59:22 <mmachenry> benzrf: They are just like functors but they get paid for it.
08:59:27 <xplat> benzrf: it's just all the interesting things are built out of -> and other things.
08:59:31 <Iceland_jack> amateurfunctor
08:59:41 <has002> Hi, I just started. I am several sections into Learn You a Haskell. Is this book OK? (as in idiomatic code, etc)
08:59:48 <Iceland_jack> has002: sure
08:59:57 <ReinH> has002: yep
09:00:01 <benzrf> mmachenry: hehehee
09:00:04 <mmachenry> has002: Everyone loves that book.
09:00:04 <benzrf> hello has002
09:00:15 <benzrf> lyah is one of like 3 universally sanctioned books
09:00:16 <ReinH> benzrf: https://www.fpcomplete.com/school/to-infinity-and-beyond/pick-of-the-week/profunctors
09:00:25 <mmachenry> has002: It's eveyone's first recommendation for learning (you a) Haskell.
09:00:25 <benzrf> ReinH: i read that
09:00:30 <xplat> anyway asking 'what are profunctors useful for' is like asking 'what are monads useful for'
09:00:30 <ReinH> benzrf: ok :)
09:00:31 <benzrf> it's how i know what a Contravariant is
09:00:43 <has002> Cool beans. The paradigm is different to what I am used to, but i'm sort of doing OK as I was using listcomps etc in Python
09:00:45 <benzrf> xplat: ok, but you can still answer parts of that :p
09:01:01 <benzrf> xplat: i.e. you can say that one use of monads is composing functions with 'effects'
09:01:03 <xplat> i mean, someone could name you a lot of things, but you'd still be like 'where do profunctors come into that?'
09:01:11 <benzrf> fair enough :\
09:01:24 <xplat> or in some cases 'what the hell does that even mean?'
09:02:44 <edwardk> benzrf: yes but you can think of variance as a little lattice. class Invariant f where invmap :: (a -> b) -> (b -> a) -> f a -> f b; class Invariant f => Functor f where fmap :: (a -> b) -> f a -> f b; class Invariant f => Contravariant f where contramap :: (a -> b) -> f b -> f a; class (Functor f, Contravariant f) => Phantom f; instance (Functor f, Contravariant f) => Phantom f; coerce :: Phantom f => f a -> f b
09:03:28 <halvorg> I don't understand sinks, I think I have a conduit that produces strings. How do I make a sink that reads it all into a value?
09:03:28 <edwardk> in lens we use the pair of constraints Functor and Contravariant on the same argument to model a phantom type argument
09:03:32 <benzrf> edwardk: o=
09:03:46 <benzrf> edwardk: wait, what's with invariant
09:04:01 <benzrf> o i think i see?
09:04:04 <benzrf> i am not sure
09:04:16 <edwardk> benzrf: some approaches to this want that as a common superclass
09:04:29 <edwardk> because if you are a functor or a contravariant functor you can trivially be an instance of that.
09:04:40 <edwardk> just pass the correct arg to fmap or contramap
09:05:11 <edwardk> in practice? you can usually find that you can split the positive and negative occurences of the type variable... and get a profunctor
09:05:29 <benzrf> pos/neg occurences?
09:06:01 <edwardk> every time you go under the left of (->) in the fully parenthesized type, you flip sign. starting positive.
09:06:07 <shergill> edwardk: ooc, as someone who does a lot of type hackery, reasons for preference of haskell over, say, agda/idris?
09:06:11 <xplat> benzrf: pos = argument to a covariant functor, neg = argument to a contravariant functor
09:06:40 <xplat> benzrf: except accounting for nesting
09:06:46 <edwardk> shergill: I have 3 main reasons I prefer Haskell over Idris for getting stuff done. 2 are solid, the 3rd is a bit wishy washy
09:07:30 <quchen> edwardk: Oh, that's interesting, please continue!
09:07:32 <edwardk> The first is laziness. Lazy algorithms compose. Period.
09:07:41 <shergill> agreed
09:07:53 <edwardk> take 10 . sort has better asymptotics than its constituent parts
09:08:10 <edwardk> People keep saying that a strict language with explicit laziness can get this same benefit
09:08:14 <xplat> benzrf: so if you do (a -> b) -> c, then a is in a positive position in that expression, because the outer arrow 'unflips' it and makes the *whole thing* it's being fed into covariant.
09:08:33 <edwardk> But in practice _nobody_ has demonstrated sufficient will to exercise that discipline correctly in such a language
09:08:40 <shergill> only if people are mindful. which doesn't happen
09:08:44 <shergill> yep
09:08:45 <shergill> second?
09:08:55 <edwardk> Idris has explicit Lazy annotations, but its list calculations are strict, its && and || don't shortcut, etc.
09:09:17 <xplat> first rule of disciplined coding: there are no disciplined coders.
09:09:28 <edwardk> The difference when you have the termination checker on is nothing in theory, but in practice makes the difference between finishing in my lifetime or not
09:09:29 <quchen> (I think (&&) : Bool -> Lazy Bool -> Bool, but that's besides the point.)
09:09:47 <c_wraith> Heh.  (&&) : Bool -> Lazy Bool -> Bool.  It'd work, but..  They need to do that.  Every single time.
09:10:09 <edwardk> Second, I find that code in Haskell survives refactoring amazingly well.
09:10:26 <shergill> dependent types are too specific?
09:10:30 <edwardk> If I write something hairy, and decide I want a different API on it, I just thrash it around and compile.
09:11:10 <edwardk> Dependent types force you into a programming style where none of the proof artifacts you generate in agda/idris survive refactoring
09:11:15 <edwardk> sometimes the tactics in coq will.
09:11:18 <Cale> edwardk: I really want a dependently typed language which is lazy by default
09:11:19 <edwardk> but its more or less by accident
09:11:34 <athan> oh wow, I had no idea, thank you for the heads up lol
09:11:46 <athan> There's no way to make them composable?
09:11:50 <edwardk> And my forte / reason for being is code reuse in many ways.
09:12:01 <xplat> Cale: having looked into this one of the big problems is making a truly lazy partial evaluator
09:12:04 <edwardk> so losing code reuse because i have 50 different list types makes me sad
09:12:07 <edwardk> now
09:12:08 <shergill> well coq tactics make use of assumptions on internals which are not expressed (the way the goals are resolved etc), but yes
09:12:19 <edwardk> we can turn to ornamental algebras and algebraic ornaments
09:12:23 <edwardk> but that is some heavy machinery
09:12:42 <edwardk> and it isn't much good to me to have reusable code isn't re-readable.
09:12:48 <ampharmex> http://haroldbot.cloudapp.net/
09:13:12 <edwardk> What I like about Haskell types is that they sit at just the right level of abstraction for them to survive refactoring like a champ
09:13:25 <shergill> Cale: would you prefer that over a dependently typed language, which is neither by default and makes people pick strict/lazy on some granularity (expression, module level?)
09:13:26 <xplat> using ornaments in today's DTLs is like those first airplanes that you flew by pulling on strings
09:13:32 <Cale> Yeah, that's a pretty strong criticism against current dependently typed systems, is that for one, the proofs about things depend very much on the precise form of their definition, and secondly that the ability to typecheck the remainder of a module can depend on the precise form of definition of earlier functions when those functions are applied to expressions with free variables in types.
09:13:48 <edwardk> And if I write them with sufficiently parametric types then most of the properties I want to prove about them follow from parametricity / free theorems and a few doctests to check its inhabited.
09:13:55 <Cale> e.g. it can be important to know the order in which a function matches on its parameters
09:14:11 <Cale> shergill: I think lazy is the correct default
09:14:13 <earthy> methinks dependently typed languages are *great* for writing specs
09:14:34 <edwardk> e.g. people always want to sit around and prove the monad laws, but its pretty easy to write a monad correctly if you write the indexed monad rather than the normal one.
09:14:34 <xplat> Cale: yeah, that's another big thing, and i think it's a fundamental problem with partial evaluation per se
09:14:37 <earthy> not so good for writing optimized algorithms returning the same results
09:14:37 <Cale> shergill: Most of the benefits of laziness in terms of composability only happen when it's the easier way to write things.
09:14:49 <edwardk> by splitting positive/negative occurrences of the state variable you can't glue it together wrong
09:15:16 <Cale> But despite those downsides, I still think it's better than anything else we know about.
09:15:18 <shergill> Cale: well when it's not the harder way. not sure if it needs to be strictly easier
09:15:29 <Cale> (w.r.t. dependent typing)
09:15:30 <benzrf> you guys keep using these words i dont know
09:15:33 <benzrf> have some consideration ;-;
09:15:58 <lispy> benzrf: ask questions :)
09:16:01 <zerokarmaleft> benzrf: every time I poke my head in here, I come away with some reference to a paper I need to read
09:16:08 <earthy> my experience with laziness in a strict-by-default setting is that it gets really ugly really quickly once you let lesser programmers into your code base
09:16:16 <edwardk> So really I've hit my 3 points, lazy algorithms compose, Haskell refactors better than anything I know, and dependent types cuse me to explode the number of nearly-the-same things I have to talk about.
09:16:23 <athan> zerokarmaleft: Stole the words from my mouth
09:16:40 <ReinH> edwardk: are you on a plane atm?
09:16:40 <edwardk> I ding Idris on the fact that it uses implcits not typeclasses, so I can't bring myself to use them for anything
09:16:41 <benzrf> zerokarmaleft: right now im procrastinating on reading the clowns & jokers paper
09:16:46 <edwardk> but that is another issue
09:16:59 <shergill> edwardk: any further reference to the indexed monad trick (and/or the generalized approach?)
09:17:04 <edwardk> ReinH: i'm at LAX, waiting for 1:30 flight to san jose
09:17:10 <ReinH> edwardk: long layover :( :(
09:17:24 <edwardk> ReinH: yeah, i flew in at 6:40 am from Brisbane
09:17:29 <ReinH> o_O
09:17:34 <athan> I can't wait to dedicate time to topics like these
09:17:38 <Cale> I think there are some approaches to reducing the number of nearly-the-same things you have to talk about in a dependently typed language, at least.
09:17:40 <shergill> edwardk: regd. the nearly same things, what about a dependently typed language with typed macros? would that be sufficient?
09:17:41 <athan> literally!
09:17:52 <ReinH> edwardk: and LAX is a terrible airport. I'm so sorry.
09:17:53 <edwardk> ReinH: and before that i stayed the night in brisbane after flying down from Cairns ;)
09:18:06 <xplat> shergill: even typed macros in haskell are an open problem
09:18:13 <edwardk> shergill: tactics are basically a bunch of macros
09:18:23 <edwardk> i want something i can think in that can survive refactoring
09:18:34 <luite> i arrived home yesterday already, fortunately :) (from sydney, where i stopped for a few days after brisbane), no more flights for me!
09:18:41 <Cale> It's obvious that many types are merely natural numbers with some additional stuff going on at the type level.
09:18:44 <Iceland_jack> edwardk: So given your criticisms of dependently typed languages, how would you like to see Haskell evolve?
09:18:56 <luite> for just under two weeks that is :)
09:19:01 <athan> I've seen closed type families behave similar to dependent types
09:19:11 <edwardk> luite: nice! we went up to cairns and visited the reef / some rainforest. see you in a couple of weeks at zurihac.
09:19:30 <Cale> But I think Conor has an answer for that sort of thing, and similarly for cases where you have multiple types for expressions annotated in various ways.
09:19:35 <xplat> shergill: look at the language 'beluga' or oleg's pages on staged evaluation if you want to know what the latest type systems for typed macros are.
09:19:47 <luite> edwardk: i only saw sydney and brisbane, i guess i'll have to return some time to see actual non-city australia
09:20:11 <Cale> I haven't read his paper about it yet (Not even sure if it's out? It should be by now, he mentioned it in a talk quite some time ago.)
09:20:23 <shergill> edwardk: right, the problem being that they're not able to operate on all the things need to. but i guess the more important critera then is being able to survive refactoring (whether that's hurt because of having to specify things at too specific a level or not, is a less important)
09:20:43 <shergill> xplat: i have :)
09:20:48 <xplat> Cale: afaik ornaments have several papers out but they are still half-baked
09:21:01 <Cale> Ah, right, that's the name
09:21:05 <luite> edwardk: haven't seen kangaroos or koalas but the city did have some interesting critters, like http://hdiff.luite.com/tmp/b/kook.jpg
09:21:19 <Cale> xplat: I should have a closer look
09:21:22 <monochrom> this may be good fuel for my future article denouncing curry-howard and advertising refinement calculi
09:21:23 <lispy> edwardk: my objection to tactics is that they are very DWIM and not at all trasparent.
09:21:40 <darthdeus> how can I tell parsec to consume the whole input instead of backtracking to where it could and stop?
09:21:55 <monochrom> using refinement calculi, proofs are more re-usable.
09:21:58 <lispy> edwardk: it bugs me when books/tutorials about theorem proving languages start with tactics. Starting with the STLC and then developing tactics would suite the pedagogy much more.
09:22:01 <shergill> lispy: it ties in with them working 'almost by accident'
09:22:11 <xplat> monochrom: link me your article when it's done
09:22:17 <monochrom> or rather, proofs of refinements are more re-usable
09:22:35 <shergill> monochrom: why so?
09:22:54 <Cale> It might also just be a cultural/style thing
09:22:59 <Cale> to some extent
09:23:07 <monochrom> before I start, do you already know of "stepwise refinement"?
09:23:12 <edwardk> luite: the bed n breakfast we stayed at up in Cairns had a laughing kookaburra that had claimed the backyard as his own. He's pretty much an Australian rooster.
09:23:29 <xplat> monochrom: with refinement you're talking about the approach that starts with a relational specification?
09:23:29 <lispy> edwardk: heh
09:23:37 <shergill> monochrom: nope. i was hoping more for a reference, since i'm going to have to leave in a bit
09:23:49 <shergill> oh wait
09:23:50 <Cale> Designing libraries with proofs that are modular probably takes a certain degree of finesse. Maybe we can automate/force that finesse to happen, but I'm not sure we're fully aware of what the right things to do *are* yet.
09:23:51 <shergill> ok i see
09:23:55 <shergill> monochrom: nvm
09:24:19 <monochrom> not necessary relational specifications. but that's one choice. another choice is Dijkstra's predicate transformers.
09:24:33 <shergill> right
09:24:52 <edwardk> shergill: did that answer your question more or less?
09:24:59 <lispy> Cale: I think someone from NICTA gave a talk about that topic
09:25:08 <lispy> Cale: they do all that work in isabelle
09:25:19 <monochrom> I have a big problem X. I start by proving that X is refined (solved) by "Y; (if b then Z1 else Z2); U". Y, Z1, Z2, and U are smaller problems.
09:25:43 <monochrom> later, I think up and prove how Y can be refined (solved) by actual code.
09:25:45 <shergill> edwardk: yes. nothing surprising happening, but needed a sanity check (i've been toying with the semantics i'd like in my ideal language)
09:25:50 <shergill> thanks
09:25:52 <monochrom> similarly Z1, Z2, U.
09:26:15 <luite> edwardk: yeah they're noisy :) heard them in centennial park on saturday but only saw them a day later (this one was in the swamp forest, where all trees are full of flying foxes sleeping during the day)
09:26:16 <lispy> Cale: also, I guess this was a life long interest of Mac Lane. Have you read Mathematics: Form and Function?
09:26:25 <Cale> Part of the problem is that we frequently seem to be writing our proofs right down at the foundational bare metal in terms of matching and direct induction, rather than finding some small set of properties which uniquely characterise our structure and then proving everything in terms of those.
09:26:31 <monochrom> next, if I replace Y's implementation, then I only change the proof of Y's new refinement. the rest of the proofs (about X, about Z1, etc) stay.
09:26:33 <Cale> lispy: I've skimmed it
09:26:50 <edwardk> shergill: if you'll be at bayhac i can fill you in on an idea i had for a form of dependent types i want to play with, but its too half baked even for IRC ;)
09:26:55 <Cale> Well, I'm talking about computer scientists in particular, rather than mathematicians in general.
09:27:09 <Cale> Well the people proving things in these proof assistants :)
09:28:22 <shergill> edwardk: sadly not this time around (visa issues). how about a skype hangout?
09:28:57 <edwardk> shergill: sure. some time when i have downtime and wifi
09:29:26 <edwardk> i worked out the sketch of the idea at lambdajam
09:29:59 <edwardk> but i usually run these things by dolio before saying 'look i solved it!', since 95% of my ideas like that are trivially falsified ;)
09:30:07 <shergill> heh
09:30:38 <shergill> ok lunch time, afk
09:30:54 <lispy> edwardk: it's good to hear I'm not the only one like that
09:32:09 <xplat> dolio is pretty good at falsifying things :)
09:32:46 <ReinH> lispy: I have Mac Lane's Algebra in my bag right now :)
09:32:55 <ReinH> Just some light reading for the plane you know.
09:33:04 <edwardk> dolio is a meanie, but every once in a while he gets equally as excited as i do, and then i know what I have isn't obviously dumb ;)
09:33:54 <edwardk> most of the time he just sits there with a bemused expression on his face trying to figure out what it is i'm rambling about
09:34:00 <ttuhin> can anyone recommend a open source haskell project?
09:34:30 <xplat> what does it mean to be too half-baked for IRC?  requires hand gestures to be communicated?
09:35:11 <xplat> or is it primarily a matter of round-trip time?
09:35:16 <ReinH> ttuhin: there are literally thousands of them. Can you be more specific? :)
09:35:18 <edwardk> xplat: yes
09:35:29 <ReinH> ttuhin: why are you looking?
09:35:30 <edwardk> xplat: all of those
09:36:00 <ReinH> xplat: yes Edward struggles when people can't see him wave his hands.
09:36:26 <edwardk> ReinH recorded the video from the first Haskell Cast on a lark just to get the audio.
09:36:29 <aspidites> ReinH: evidenced by haskellcast #1
09:36:32 <edwardk> Posted it because my hands did half the talking
09:36:34 <ReinH> aspidites: :D
09:36:42 <ReinH> Exactly.
09:37:01 <monochrom> natural deduction is assembly code for proofs indeed. you wouldn't talk about modularising your proofs writting in natural deduction.
09:37:07 <ReinH> It's some sort of mathematical jedi mind trick.
09:37:16 <monochrom> s/writting/written/
09:37:26 <lispy> ReinH: it should be open in front of you :)
09:38:08 <edwardk> monochrom: well, in some sense that is what the admissabilty of cut is all about in logic. its the ability to form a lemma/function
09:39:17 <edwardk> monochrom: but the fact that all you want is to show it is admissable (by commuting everything through everything and getting the full ridiculous tree) shows they don't think in those terms ;)
09:39:33 <edwardk> its like saying oh, a lemma? that's cute kid. expand it!
09:39:38 <monochrom> natural deduction : calculational proofs :: machine code : haskell. you refactor haskell code, not GHC-generated machine code. you refactor calculational proofs, not natural deduction proofs.
09:40:25 <monochrom> natural deduction's cut is at the same level, approximately, as machine code's JSR. if my analogy is to be believed. :)
09:40:49 <xplat> edwardk: if you hate running programs that much i don't know why you don't hang out in #agda more ;)
09:40:55 <monochrom> (no one calls JSR "a mechanism for abstractions", right? :) )
09:41:21 <edwardk> xplat: =P
09:41:26 <xplat> monochrom: but cut is really more like haskell's ' ' (apply)
09:42:06 <edwardk> xplat: i like the conceit that someone _might_ want to run code based on my libraries some day. In Agda that requires rather more roleplaying than I am comfortable with. ;)
09:43:07 <monochrom> that is only what curry-howard says. curry-howard fails regarding how to map program modularity to proof modularity.
09:44:07 <exicer> Is there any function that does [Either a b] -> Either a [b] ?
09:44:36 <xplat> exicer: sequence for EitherT i think?
09:44:41 <Iceland_jack> exicer: there is 'rights'
09:44:43 <Iceland_jack> :t rights
09:44:44 <lambdabot> [Either a b] -> [b]
09:44:45 <aspidites> i wonder how edwardk does with tetris
09:45:46 <edwardk> :t sequence
09:45:47 <lambdabot> Monad m => [m a] -> m [a]
09:45:53 <edwardk> m = Either a
09:45:55 <ReinH> exicer: sequen... damn it edwardk
09:46:03 <c_wraith> xplat got it first, though
09:46:12 <ReinH> c_wraith: no he was wrong
09:46:25 <ReinH> :p
09:46:26 <c_wraith> Eh.  Well, he's right, just unnecessarily specific. :)
09:46:41 <c_wraith> Err.  Sort of.  Ok, I see what you mean.
09:46:57 <exicer> Thanks
09:47:00 <xplat> yeah, i said EitherT.  which was silly.  but almost right.
09:47:08 <aspidites> on a serious note, is that javascript compiler in javascript somewhere on your github exicer ?
09:47:12 <aspidites> edwardk: *
09:47:45 <xplat> javascript compiler in javascript?
09:47:49 <xplat> is it called jsjs?
09:47:54 <Thooms> jsception
09:48:08 <aspidites> Thooms: lol
09:48:12 <Javafant> Hi, I'm trying to install yesod-platform and yesod-bin but despite using a sandbox I get an error that it will break other packages (xmonad) http://sprunge.us/jPiE
09:48:14 <aspidites> i'd say brainfuck, but that's already taken
09:48:18 <Javafant> Is there a way to work around this?
09:48:20 <xplat> inscription
09:49:04 <Maior> xplat: yojs
09:49:20 <aspidites> Javafant: what's in your ~/.cabal/config ?
09:49:21 <edwardk> aspidites: not _exactly_. i wound up selling it, but had officially open sourced it first, but the repo i had that had the consistent copy of everything was held locally on a machine that died at the time i moved all my stuff off of patchtag.... anyways. i posted a bunch of javascript stuff up to comonad.com in a folder, but its grafted out of a dozen old repos
09:49:28 <xplat> Maior: :D
09:49:32 <edwardk> http://comonad.com/js/
09:49:39 <edwardk> there be dragons
09:50:01 <Javafant> aspidites: http://sprunge.us/Wefg
09:50:02 <edwardk> http://comonad.com/js/lang/Parser.js should parse ecmascript though
09:50:10 <Javafant> I don't think I ever changed something manually there
09:50:28 <lispy> Did news of the aeson parser exploit make it here?
09:50:40 <edwardk> pardon the style. i think that one ran through a stage-1 atomizer at one point to mangle the names
09:50:45 <lispy> tl;dr: upgrade to the latest aeson currently on hackage
09:50:55 <edwardk> lispy: oh my
09:50:56 <edwardk> lispy: what happened?
09:51:01 <lispy> otherwise you can be ddos'd with a large integer constant
09:51:24 <hiptobecubic> :D
09:51:33 <hiptobecubic> json has been the vector for a lot of malice lately
09:51:43 <eikke__> an allocation of network-received size?
09:51:51 <ReinH> hiptobecubic: no, shitty code around json has been the vector for a lot of malice :p
09:52:12 <aspidites> nothing  fishy Javafant . that is odd.
09:52:13 <ReinH> It's not like (say) YAML, which is inherently unsafe.
09:52:13 <hiptobecubic> ReinH, well sure. But json being the common theme. You can't blame the bits themselves :)
09:52:21 <edwardk> makes sense.
09:52:31 <xplat> when you turn the vectors around, malice becomes incompetence.
09:52:35 <aspidites> i'm curious now.
09:52:37 <Javafant> aspidites: not sure if it matters but xmonad is installed via pacman (archlinux package manager)
09:52:41 <hiptobecubic> What was that ruby one that was so hilarious? I think it was literally just running eval() more or less
09:52:42 <Javafant> not via cabal
09:52:44 * aspidites plays with yesod
09:52:45 <ReinH> xplat: are they dual, do you think? :p
09:52:49 <lispy> It looks like aeson-0.7.0.6 is a good version
09:53:16 <xplat> ReinH: YAML is *inherently* unsafe?
09:53:19 <ReinH> hiptobecubic: it was a bit more complicated, but yes. It was remote code execution by essentially eval-ing YAML.
09:53:55 <hiptobecubic> oh right, yaml,
09:54:06 <hiptobecubic> edwardk, that is some nasty looking regex you got there
09:54:07 <aspidites> Javafant: ok. i'm on arch myself so i can have a play
09:54:19 <Maior> the thing is, it was much more insidious than that
09:54:26 <xplat> hiptobecubic: the hilarious ruby one was allowing the instantiation of any class in your program without any checks
09:54:31 <edwardk> hiptobecubic: was faster than the alternatives
09:54:50 <ReinH> xplat: an obvious implementation of object type annotations in YAML is unsafe and it is *very* difficult to make it safe.
09:55:19 <xplat> combined with using a YAML parser that did this to parse JSON
09:55:44 <aspidites> i get the same issue, so i'm guessing sandboxes reuse global packages
09:55:51 <eikke__> lispy: got some more info?
09:55:55 <ReinH> xplat: I suppose "inherent" is the wrong word, but it's highly unsafe.
09:56:20 <geekosaur> yes, sandboxes override the local package database, do not affect the global one
09:56:47 <lispy> eikke__: I learned about it from IHG. I'm not sure how much I want to say at the moment. Give people a chance to upgrade before making the full details known :)
09:56:48 <xplat> ReinH: it contains constructs that are syntactically and semantically suggestive of an unsafe approach to deserialization?
09:56:51 <ReinH> The bug was actually a complex interaction between YAML and rails routes, because rails routing code did an eval-like thing in a way that a YAML object could spoof a Rails routing object and cause itself to be eval'd.
09:57:12 <ReinH> xplat: Any combination of YAML and any form of eval anywhere in your code is probably unsafe.
09:57:13 <lispy> eikke__: the exploit causes memory exhaustion. So at least it's not a leak or escalation.
09:57:25 <eikke__> lispy: looking at the aeson git repo, cant see anything too fishy, except some changes to 'scientific' versions
09:57:41 <Javafant> so if I install xmonad locally via cabal and not globally via pacman things will work?
09:57:41 <xplat> eikke__: oh, i see how it works ...
09:57:54 <ReinH> xplat: and Ruby's taint system is essentially useless here.
09:58:32 <eikke__> ah, there it is
09:59:27 <lispy> eikke__: https://github.com/bos/aeson/issues/198
09:59:41 <aspidites> i'd be surprised if there weren't a way to ignore the package db
09:59:50 <lispy> eikke__: since the details are all in that issue I don't feel bad about sharing them anymore.
10:00:12 <eikke__> yeah, that's what I found in the 0.7 tree as well
10:00:19 <xplat> aspidites: you can't actually ignore the package database entirely since you can't build base from source
10:00:48 <aspidites> xplat: oh damn.
10:00:49 <eikke__> > 1e1000000 :: Rational
10:00:54 <lambdabot>  mueval-core: Time limit exceeded
10:00:59 <Drogna> New to Haskell here. I notice many different ways of doing the same thing eg case expressions and function argument pattern matching. Which am I supposed to use?
10:01:10 <aspidites> ok, back to the "only install ghc and cabal install from repo" thoughts
10:01:11 <c_wraith> Drogna: whichever is more convenient.
10:01:23 <eikke__> Drogna: depends on personal style
10:01:26 <c_wraith> Drogna: if it makes you feel any better, they usually compile to the exact same thing.
10:02:08 <Drogna>  So the community doesn't in general prefer one over the other?
10:02:34 <lispy> Drogna: I think it's good to understand which ones are more "primitive" (in terms of the haskell report) and how the other ones are desugared into the more primitive ones. Everything else is almost completely stylistic.
10:03:21 <lispy> Drogna: in terms of style, there are two guides that I point people to: https://github.com/tibbe/haskell-style-guide/blob/master/haskell-style.md
10:03:27 <lispy> Drogna: http://urchin.earth.li/~ian/style/haskell.html
10:03:34 <eikke__> Drogna: fwiw, I (almost) always use 'case'. Dislike having multiple function definitions
10:03:36 <Drogna> bookmarked
10:04:03 <lispy> Drogna: the first one says to add lots of bangs (!), but I disagree with that. I think it's better to understand laziness and then introduce them during performance tuning.
10:04:59 <lispy> Drogna: as for case vs. equations, I've seen even experienced haskellers go back and forth as to which way they prefer.
10:05:25 <aspidites> there was a reddit thread but i'm not sure that a consensus was reached as arguments were made for both sides
10:05:33 <savanni> Drogna: I like to use a case expression for those cases where the logic would be less clear if I broke it into another function.  But I'll go ahead and break it into another function with a pattern match if the case gets too hard to follow.
10:05:56 <Methodius> Drogna: I'm still rather new to Haskell myself, but as for case or pattern matching, I usually use whichever reads the best and looks the simplest, depending on the context
10:05:58 <lispy> the argument for case is that due to the way you format it, you usually have to change the surrounding code less when refactoring. The argument in favor of equations that pattern match is that you can see each alternative in isolation better.
10:05:59 <savanni> In general, use whichever makes the logic easier to follow.
10:06:45 <savanni> You can also test a function in isolation, where you can't do that with a case.
10:08:07 <lispy> Drogna: a related remark: I'd rather use pattern matching on a list to get the first element than call head or take.
10:08:30 <lispy> Drogna: it forces you to think about the empty case and ghc has decent warnings about missing (or overlapping) patterns.
10:08:52 <Drogna> ok
10:08:57 <lispy> (and here, I really mean either a case or a pattern)
10:10:26 <lispy> Drogna: let vs. where: where feels more declarative and let feels more imperative. The one I use depends on what I want to emphasize. In practice, I prefer where.
10:11:13 <Drogna> At the moment I'm new to it and doing it inconsistently, which sucks.
10:11:29 <lispy> type synonyms: not my favorite. They don't increase type safety but they are on more thing you have to look up and remember when reading code. I admit there are times when it makes things easier to read or easier to refactor. It's good then.
10:12:25 <bennofs> IMO, when you're using type synonyms for better readabilty, it's almost always better to just newtype it instead.
10:12:34 <yaymukund> hi, I'm just learning haskell. why is my solution to Euler Problem 4 so much slower than the haskell wiki solution? https://gist.github.com/yaymukund/76bc4a22377c7181ec14
10:13:12 <halvorg> Anyone used Text.XML.Simple? I want to get to the values in an xml list as such "L":[{"att1":"v1", "att2":"v2"}, {"att1":"v3", "att2":"v4"}]
10:13:17 <halvorg> but I don't know where to start.
10:13:24 <ReinH> yaymukund: (++) is O(n) in the length of the first list. digit : digits rest would be faster.
10:14:45 <ReinH> since you're checking for reverse symmetry, it doesn't matter which way you build digits.
10:14:51 <yaymukund> interesting. I thought digit : digits rest would..
10:14:51 <yaymukund> OH
10:14:54 <yaymukund> right, duh
10:14:56 <yaymukund> hahaha
10:15:34 <yaymukund> though then the function doesn't do what it claims. but sure, I did taht but it's still quite a bit slower
10:15:36 <lispy> yaymukund: you can get the div and mod at the same time
10:15:42 <lispy> :t divMod
10:15:42 <lambdabot> Integral a => a -> a -> (a, a)
10:15:48 <lispy> yaymukund: that will save you some work
10:16:03 <ReinH> Hmm, digits here is going to be a pretty small list, so that probably isn't where the slow is.
10:16:07 <eikke__> wouldnt it make sense to go from 999 to 100 twice instead of 100 to 999, then take head of the list of palindromes?
10:16:10 <eikke__> hmh, no, never mind
10:17:05 <lispy> yaymukund: you're not sharing 'digits n' between the two calls but you could be
10:17:28 <lispy> isPalindrome n = s == reverse s where s = digits n
10:17:50 <ReinH> sometimes when you want to know why something is slow it's a good idea to profile it.
10:17:55 <ReinH> And by sometimes I mean all the time.
10:18:12 <ReinH> yaymukund: this is a good opportunity to learn about profiling in GHC.
10:18:19 <lispy> ReinH++
10:18:28 <yaymukund> fair!
10:18:39 <ReinH> Although it may be slow for reasons that profiling won't show, like not sufficiently restricting your domain.
10:18:58 <lispy> yaymukund: I think with those three changes: a) reverse the list, b) divMod, c) share the digits n. That you'll be very close to the performance of the wiki version.
10:19:19 * hackagebot zip-archive 0.2.3.2 - Library for creating and modifying zip archives.  http://hackage.haskell.org/package/zip-archive-0.2.3.2 (JohnMacFarlane)
10:19:21 * hackagebot fb 1.0.1 - Bindings to Facebook's API.  http://hackage.haskell.org/package/fb-1.0.1 (FelipeLessa)
10:19:41 <lispy> yaymukund: any additional speedup would be something clever that show is doing (but really, you have a more specialized problem so you should be able to go faster)
10:20:03 <yaymukund> lispy: sharing `digits n` between what and what?
10:20:11 <lispy> isPalindrome n = s == reverse s where s = digits n
10:20:16 <ReinH> I would write `isPalindrome xs = xs == reverse xs` and pass in (digits n).
10:20:30 <lispy> yaymukund: ghc doesn't do common sub expression elimination
10:20:32 <ReinH> but a let binding would work too
10:20:37 <Deewiant> yaymukund: Note that the wiki solution does y<-[100..999], z<-[y..999] whereas you take both from [100..999], doing approximately twice the amount of work
10:20:48 <lispy> Deewiant: oh good catch
10:21:05 <yaymukund> ohh, duh. that's not even a haskell thing. that's just looping. good catch
10:21:09 <ReinH> I would probably not write:
10:21:19 <ReinH> @pl isPalindrome xs = xs == reverse xs
10:21:20 <lambdabot> isPalindrome = ap (==) reverse
10:21:28 <Maior> :t ap
10:21:29 <lambdabot> Monad m => m (a -> b) -> m a -> m b
10:21:35 <bennofs> Using cabal, is it possible to only enable -fprof-auto for some specific modules?
10:21:38 <ReinH> ap is <*> with a Monad constraint
10:22:05 <yaymukund> Deewiant: fixing the loop halved my runtime
10:22:43 <ReinH> which makes sense given the whole "twice as much work" thing ;)
10:22:48 <yaymukund> right, haha
10:23:06 <lispy> yaymukund: I absolutely agree with ReinH's suggestion to learn the profiler and use this as a way to do that. Now, with that said, this example program is also simple enough that you can study the whole thing *and* how Haskell evaluation works. So I think it's also worth studying it sort of algebriacly. Apply the reductions by hand, on paper. See where you find redundancy.
10:23:22 <lispy> bennofs: you'd put a OPTIONS_GHC at the top of the file
10:23:29 <ReinH> lispy: Now, the profiler won't catch "your n is twice as large as it needs to be" ;)
10:23:35 <bennofs> lispy: oh, I hadn't thought of that. Thank you
10:23:35 <ReinH> But still. Profiling is good.
10:24:19 * hackagebot lens 4.1.2.1 - Lenses, Folds and Traversals  http://hackage.haskell.org/package/lens-4.1.2.1 (EricMertens)
10:24:36 <lispy> ReinH: yeah, this program is cool because you can study it both ways and learn a lot from both.
10:24:37 <Javafant> aspidites: I ended up installing xmobar and xmonad via hackage and only having ghc via pacman. Now everything seems to work
10:24:39 <Javafant> thx for your help
10:24:43 <ReinH> lispy: agree!
10:25:02 <ReinH> lispy: Euler problems are usually good for that.
10:25:27 <ReinH> I used to give them for interviews (pre-interview, really, over email)
10:25:41 <ReinH> The sum of fibs one is one of my favorites
10:25:42 <lispy> nice
10:25:49 <ReinH> As there are lots of interesting properties of fibs that you can use
10:25:49 <benzrf> :t on
10:25:50 <lambdabot> (b -> b -> c) -> (a -> b) -> a -> a -> c
10:25:52 <ReinH> sum of odd fibs or w/e
10:25:53 <benzrf> rite
10:26:11 <ReinH> @djinn (b -> b -> c) -> (a -> b) -> a -> a -> c
10:26:11 <lambdabot> f a b c _ = a (b c) (b c)
10:26:39 <lispy> ReinH: interview questions are tricky. It's easy to fall into the trap of trying to get the candidates to do 'clever' things on the spot. So I'm glad that you used the euler stuff over email to prescreen. Less chance of performance anxiety.
10:26:58 <ReinH> lispy: Exactly.
10:27:00 <yaymukund> I will definitely learn about perf when I have a bit more time
10:27:07 <yaymukund> this is my lunch break activity
10:27:17 <ReinH> lispy: I'm not interested in clever. Clever gets me into trouble.
10:27:20 <yaymukund> hmm
10:27:22 <lispy> yaymukund: chapter 23 of real-world haskell can get you started.
10:27:40 <lispy> yaymukund: sorry, 25
10:27:44 <lispy> I should have googled first
10:27:48 <ReinH> I'm interested in "has a robust collection of problem solving skills, especially including the skill of acquiring more skills"
10:27:55 <lispy> http://book.realworldhaskell.org/read/profiling-and-optimization.html
10:28:25 <yaymukund> cool
10:28:38 <LadyAurora> Why isn't NoMonomorphismRestriction the default yet?
10:28:51 <lispy> yaymukund: read that on a break or something and then on monday's lunch you can try it out :)
10:29:11 <lispy> LadyAurora: I think mostly because it can cause performance issues
10:29:30 <lispy> LadyAurora: If you go to the haskell' mailing list I'm sure you can find the debates about it.
10:30:24 <ReinH> LadyAurora: because it's not a very good default. :)
10:30:31 <lispy> https://ghc.haskell.org/trac/haskell-prime
10:39:50 <lispy> ReinH: I once failed the coding part of an interview and that really bugged me. So when I got home I code it up nicely and calmly and emailed it to manager that had interviewed me. I got the job and later found out it was because of that. They weren't going to hire me until they saw that code sample and that it was good, unlike the stuff I produced on the spot.
10:40:24 <lispy> ReinH: that experience really opened my eyes :)
10:40:29 <halvorg> Any function for [Maybe a] -> [a]?
10:40:38 <Maior> :t catMaybes
10:40:39 <lambdabot> [Maybe a] -> [a]
10:40:40 <Maior> :t sequence
10:40:41 <lambdabot> Monad m => [m a] -> m [a]
10:40:42 <halvorg> thanks
10:40:54 <mmachenry> :t map fromMaybe
10:40:55 <lambdabot> [a] -> [Maybe a -> a]
10:41:12 <mmachenry> Oops, that doesn't look right.
10:41:26 <LadyAurora> :t filter isJust
10:41:27 <lambdabot> [Maybe a] -> [Maybe a]
10:41:54 <Maior> :t \x -> map (fromMaybe x)
10:41:55 <lambdabot> b -> [Maybe b] -> [b]
10:42:06 <mmachenry> catMaybes is it. Which is probably "map fromJust $ filter isJust"
10:42:14 <ReinH> lispy: yep
10:42:18 <Maior> @src catMaybes
10:42:18 <lambdabot> catMaybes ls = [x | Just x <- ls]
10:43:08 <ReinH> lispy: If they think your ability to write code under pressure and unrealistic, arbitrary time constraints is important then maybe that tells you more about them than vice versa.
10:43:16 <LadyAurora> > sequence [Just 1, Just 2, Nothing, Just 3]
10:43:18 <lambdabot>  Nothing
10:43:48 <Maior> @src sequence
10:43:48 <lambdabot> sequence []     = return []
10:43:48 <lambdabot> sequence (x:xs) = do v <- x; vs <- sequence xs; return (v:vs)
10:43:48 <lambdabot> -- OR: sequence = foldr (liftM2 (:)) (return [])
10:44:18 <ReinH> sequence has the wrong type :)
10:45:53 <louisjb> hello
10:47:02 <didy_kithz> hello
10:47:21 <napping> Hello
10:47:44 <eizo> lispy: what was the task?
10:47:47 <louisjb> I'm kinda interested in a change, can anyone point me at companies using haskell that I might take a look at?
10:47:48 <lispy> ReinH: true
10:48:16 <louisjb> I realise that may seem lazy, just looking for some ideas as a starting poing
10:48:39 <lispy> eizo: This was like 5 years ago. I remember it was something low-level in C. Some bit twiddling or searching was involved. That's about all I remember now.
10:49:03 <lispy> louisjb: there is a page on the haskell wiki about haskell in industry
10:49:09 <eizo> ok i see
10:49:15 <lispy> http://www.haskell.org/haskellwiki/Haskell_in_industry
10:49:27 <louisjb> I've been doing Scala for years, I'd sort of like to get off of the JVM now :D Haskell, Idris and maybe F# all appeal
10:49:39 <ampharmex> http://haroldbot.cloudapp.net/
10:49:40 <louisjb> lispy - ok, thanks!
10:50:02 <lispy> louisjb: http://corp.galois.com/about-us/  (shameless plug, I work there :)
10:50:05 <louisjb> A change is as good as a rest as they say
10:50:23 <louisjb> Galois, the name is a good start!
10:50:27 <louisjb> thank you
10:52:03 <louisjb> lispy, that sounds wonderful, now where do I apply :) hehe
10:52:47 <lispy> louisjb: http://galois-inc.hiringthing.com/
10:54:08 <ampharmex> lispy, Do you do alot of crypto?
10:54:13 <louisjb> :) it might be a dream, but you've got to aim high, really does sound like a dream come true. I imagine you love it
10:55:15 <lispy> ampharmex: I don't. I've been working in the areas of static analysis, source to source translation, and systems security
10:55:29 <lispy> louisjb: I enjoy it a lot :)
10:55:40 <bvad> Hey, I'm coming from a Scala background and was wondering how ghc's compile times are compared to scalac?
10:55:55 <ampharmex> lispy, Oh nice :) But cryptographers work there aswell right?
10:56:36 <mmachenry> bvad: In a word… better. For more info http://benchmarksgame.alioth.debian.org/
10:56:38 <lispy> ampharmex: hmm...I don't think anyone on our staff would qualify as a cryptographer. We have some folks who know a fair bit about that area.
10:57:50 <bvad> mmachenry: can I see compile times there?
10:57:56 <louisjb> I worked in crypto for 5 years, loved it - super specialist though, ended up diversifying out of it for security
10:58:14 <lispy> ampharmex: maybe bruce schneier will apply one day :)
10:58:19 <louisjb> hah - no pun intended, I see what I just did there * face-palm *
10:58:21 <mmachenry> bvad: Oh, I'm sorry. Compile times. I gave you runtimes obviously.
10:58:30 <ReinH> lispy: you... just... er... released a crypto analysis tool open source...
10:58:31 <carter> louisjb: happily its pretyt easy to audit haskell codes
10:58:39 <ReinH> lispy: one can dream ;)
10:58:43 <lispy> ReinH: oh yeah, we work with domain experts :)
10:58:49 <ReinH> lispy: heh :)
10:58:54 <louisjb> carter, absolutely.
10:58:56 <carter> just grep for unsafe* or magichash
10:59:02 <bvad> mmachenry: Thanks anyway :) Scalaz is notoriously slow, so I was wondering how ghc was holding up
10:59:21 <Iceland_jack> carter: or compile with SafeHaskell :)
10:59:22 <ReinH> lispy: I gave a talk to some Rubyists about software security at RubyConf. You'd be amazed at how few developers realize it's actually their job to ship secure software. Or maybe you wouldn't.
10:59:26 <louisjb> It appears both Haskell and Idris could be my top two langs due to their reason-ability!
10:59:53 <carter> i'd  favor haskell if only for the slightly more stable core lang :)
10:59:58 <ReinH> So that was basically the gist of my talk: this is your responsibility. It's your job. Here's how you can learn more about how to do it.
11:00:18 <quchen> ReinH: Which other entities were in the race for "you should secure the program"?
11:00:24 <quchen> Usage manpages?
11:00:30 <lispy> ReinH: what amazes me is how low the ratio of doing-it-right to wow-that's-broken can be with respect to security.
11:00:31 <ReinH> quchen: good question!
11:00:43 <louisjb> even after Scala for so long, I liked it in the begining, I'm just not sure JVM is the long term way to go. Of course it can not be and furthermore Scala got messy and unweildy in places, bit of a hotch-potch sometimes
11:00:59 <ReinH> quchen: and yet how many teams include security review as a part of their normal code review, etc process?
11:01:02 <lispy> ReinH: it's just really easy to screw up.
11:01:12 <ReinH> lispy: it sure is! And the easiest way of all is by not even trying!
11:01:17 <louisjb> yearning from some purity again
11:01:58 <lispy> Interesting discussions today, but I need to go or I'll be here all day :)
11:03:35 <louisjb> ibid:
11:04:54 <c_wraith> The thing is, my observations show that secure software generally isn't worth it, economically.  It's better to write some terrible crap, get paid, and move on to the next thing well over 99% of the time.  Which is a sorry statement about the industry as a whole.
11:05:31 <ReinH> c_wraith: Well, the thing is, "secure software" is an impossibility.
11:05:35 <ReinH> So I don't think anyone is doing that.
11:05:42 <ReinH> As Schneier says, security is a process, not a product.
11:06:01 <ReinH> Any reasonable approach to security includes the concept of "secure enough".
11:06:02 <c_wraith> That only makes the statement more true.
11:06:10 <ReinH> It's a business decision.
11:06:25 <c_wraith> Because way more than 99% of the time, there's no security process.
11:06:32 <ReinH> That's what I'm saying.
11:06:41 <hexagoxel> could somebody enlighten me why test1 is ok, but test2 is not: http://ideone.com/Ol2hrk
11:06:54 <ReinH> They've made a business decision. I just don't think they were in possession of all the salient facts when they did so.
11:07:23 <hexagoxel> this is simplified from a more complex use-case, where i require the second form (test2)
11:08:28 <ReinH> hexagoxel: myComp takes a single argument. In test2 your are providing it with two.
11:08:30 <fizruk> hexagoxel: guess that mentioning g makes it monomorphic
11:08:40 <napping> it really shouldn't
11:08:54 <napping> make it monomorphic, that is
11:08:59 <ReinH> hexagoxel: wait, ignore me.
11:09:13 <c_wraith> If it's ever standard for security vulnerabilities to result in class-action lawsuits, maybe then businesses will consider security to be worth actually pursuing.
11:09:33 <ReinH> Yeah, is that DMR?
11:09:36 <c_wraith> But that's the opposite of the direction the state of industry is moving in.
11:09:38 <napping> Ah, the constraints are kind of strange
11:09:55 <napping> What is the (c m) doing?
11:10:00 <ReinH> c_wraith: I think the business impact of a security breach is *always* underestimated. Usually significantly.
11:10:32 <quchen> napping: The code runs in my GHCi, with or without DMR
11:10:37 <quchen> (GHC 7.8.2)
11:10:37 <hexagoxel> napping: yeah i know, i have tried many variations of how to write the contraints
11:10:47 <hexagoxel> *constraints
11:11:11 <quchen> Oh wait, silly me, hold on.
11:11:11 <fizruk> hexagoxel: if you remove c m constraint everywhere, does the error reproduce?
11:11:43 <fizruk> my guess - it would
11:12:38 <hexagoxel> http://ideone.com/aJDsTa
11:12:41 <hexagoxel> yeah it does
11:13:10 <hexagoxel> .. in the sense "yeah, that works"
11:13:28 <hexagoxel> so, no error without c
11:13:36 <ReinH> c_wraith: How many developers are even aware that there are regulations that require reporting of (some) security breaches written by the FCC, IRS, SEC, Patriot Act, UN Convention, etc?
11:13:44 <fizruk> hexagoxel: no, get the forall back :)
11:13:54 <fizruk> hexagoxel: but not (c m)
11:15:26 <hexagoxel> fizruk: http://ideone.com/aJDsTa
11:15:35 <klrr_> ?src undefined
11:15:36 <lambdabot> undefined =  error "Prelude.undefined"
11:15:50 <hexagoxel> same forall's, no (c m) constraint ---> no error
11:17:02 <hexagoxel> so.. maybe there is a better way to add the constraints, so that it works for the pointful version?
11:17:33 <napping> hexagoxel: yeah, I think the problem is that it's not sure how much of the constraint "c" on g is supposed to become the constraint "c" from myComp, and how much should be solved right away
11:18:16 <napping> If you define and use everywhere a newtype for (forall m . c m => m (a -> b)), then both compile
11:18:47 <t4nk743> @pl f g x = g x x
11:18:47 <lambdabot> f = join
11:20:03 <Iceland_jack> > map (join replicate) [1..10]
11:20:05 <lambdabot>  [[1],[2,2],[3,3,3],[4,4,4,4],[5,5,5,5,5],[6,6,6,6,6,6],[7,7,7,7,7,7,7],[8,8,...
11:22:21 <awestroke> :t join replicate
11:22:22 <lambdabot> Int -> [Int]
11:22:22 <Javafant> Can I tell ghc to use the cabal sandbox or use cabal to call ghc directly? I don't have a cabal file at the moment and ghc doesn't seem to pick it up automatically
11:22:34 <benzrf> > join replicate 3
11:22:35 <lambdabot>  [3,3,3]
11:22:56 <awestroke> :t join
11:22:56 <lambdabot> Monad m => m (m a) -> m a
11:23:09 <benzrf> awestroke: join is the REAL monad definition
11:23:14 <benzrf> bind is dumb
11:23:35 <awestroke> benzrf: I thought join used bind
11:23:51 <benzrf> it does
11:23:57 <benzrf> but it SHOULD be the other way around
11:24:28 <hexagoxel> napping: i guess i'll use a newtype Foo c x = forall m . (c m) => Foo (m x)
11:25:07 <hexagoxel> napping: thanks
11:37:55 <smog_alado> quick question: I want to install Haskell to a brand new Debian machine. Should I (1) install the haskell-platform package, (2) install just the ghc and cabal-install packages or (3) download ghc + cabal from haskell.org and install myself? Last time I installed the haskell-platform package but got bitten because it installed some bugged packages to /usr/bin and I couldn't upgrade them to the fixed version...
11:38:32 <napping> What's the difference between 2 and 3? I usually do one of those
11:38:46 <shachaf> smog_alado: If you want a recent version of GHC you should probably go with 3.
11:38:51 <bennofs> napping: if your GHC version in the repos is outdated ...
11:38:54 <shachaf> Otherwise I would go with 2.
11:39:04 <shachaf> But a recent version of GHC is nice to have.
11:39:10 <smog_alado> 2 is using the debian packages and instaling to the default places; 3 is downloading from haskell.org and potentially having to confidure stuff
11:39:11 <napping> Oh, 2 was from packages
11:39:18 <napping> I do 3 then , works fine
11:39:21 <smog_alado> their ghc is 7.6
11:39:22 <shachaf> Note that you can have multiple versions of GHC installed at the same time.
11:39:35 <napping> The only thing slightly tricky is maybe needing to run the bootstrap script to build cabal
11:53:12 <bobajett> I have a very basic question. Going through Graham Hutton's "Programming in Haskell"...
11:54:01 <bobajett> I understand "type Position = (Int, Int)" to mean that a new type "Position" is being declared that is made up of a tuple of two Ints.
11:54:22 <bobajett> but what does "type Parser a = String -> [(a, String)]" mean?
11:54:23 <dwcook> bobajett: it's actually not a new type, it's exactly the same as (Int, Int).
11:54:54 <dwcook> bobajett: that means that for any type a, Parser a stands for the type String -> [(a, String)].
11:55:09 <dwcook> So Parser Char is String -> [(Char, String)]
11:57:19 <dwcook> bobajett: did that clarify things?
11:57:23 <ziggystar> Hi, I'm trying to build the minisat haskell bindings from github. But I get some linker errors:  undefined reference to `asynczm2zi0zi1zi4_ControlziConcurrentziAsync_withAsync1_closure'
11:57:50 <bobajett> dwcook: still scratching my head. so if Position is exactly the same as (Int, Int). What does that mean? How do I make use of that?
11:57:51 <ziggystar> This appears to reference something from Haskell: Control.Concurrent.Async. Any ideas?
11:58:18 <dwcook> bobajett: you use it exactly as you'd use (Int, Int). It's just a convenient name for it, a type synonym.
11:58:49 <dwcook> In this case it's also probably used to clarify to the programmer what the (Int, Int) is for.
11:58:54 <chirpsalot> bobajett: do you know C or something similar? Heard of typedef?
11:59:05 <bobajett> dwcook: ok. so for example a function that doubles the position pair could be defined as: doubleIt :: Position; doubleIt (x,y) = (2*x, 2*y) ?
11:59:59 <chirpsalot> bobajett: function type is wrong.
12:00:05 <Eduard_Munteanu> Are there any helpers for Text.Regex to compile the regex at compile-time?
12:00:25 <Eduard_Munteanu> I'm using the TDFA implementation.
12:00:35 <bobajett> chirpsalot: why is the function type wrong?
12:00:46 <edisach> If you see (Int, Int) it could mean any sort of pair of ints - maybe representing a complex number, a position, a range or anything else that needs two numbers to define
12:01:01 <Fuuzetsu> ziggystar: That often means you haven't put some modules in your cabal file
12:01:10 <Fuuzetsu> at least from my experience
12:01:16 <edisach> Whereas if you see Position you know what it's meant to represent
12:01:18 <chirpsalot> bobajett: doubleIt :: Position means that doubleIt is just a Position, it's not a function that takes a Position and returns a new Position.
12:01:34 <chirpsalot> bobajett: doubleIt :: Position -> Position is what you want for the type.
12:01:40 <bobajett> chirpsalot: ok cool.
12:02:17 <bobajett> chirpsalot: ah ok that makes sense. So in that case, is "type Parser a = String -> [(a, String)]" simply saying that "Parser a" stands for a function? (that takes a string and returns a [(a, String)]?
12:03:19 <chirpsalot> bobajett: yep, where 'a' can be replaced with any type you want.
12:03:44 <xplat> bobajett: "Parser a" stands for the type of functions that take a string and return a list of pairs of an 'a' and a String
12:04:04 <xplat> bobajett: not for a particular such function
12:04:22 <bobajett> xplat: gotcha.
12:04:26 <chirpsalot> This is true.
12:04:36 <xplat> bobajett: (you might have meant that, but it helps to be clear about these things, especially when learning)
12:04:45 <ziggystar> @Fuuze The project doesn't have a cabal file. It is using make.
12:04:45 <lambdabot> Unknown command, try @list
12:05:15 <ziggystar> Oh, no it has one.
12:05:52 <ziggystar> Hmmm, inside the cabal file it lists async, which is the potentially missing dependency, I think.
12:06:09 <bobajett> xplat: cool, no I wasn't clear about that in my head either, so your making it explicit helped.
12:07:17 <smog_alado> @shachaf: forgot to say thanks, btw. I decided to install the default ghc packages
12:07:17 <lambdabot> Unknown command, try @list
12:09:18 <ziggystar> Wow, it works now. These packages should have better documentation for building them.
12:09:41 <Fuuzetsu> ziggystar: what was the problem?
12:09:56 <Fuuzetsu> why the way, don't use the @name style as lambdabot reacts to it ;)
12:10:48 <bobajett> @list
12:10:48 <lambdabot> What module?  Try @listmodules for some ideas.
12:11:12 <shachaf> smog_alado: Nothing stops you from also installing GHC from haskell.org in the future if you ever need to.
12:11:24 <shachaf> You can even use the same cabal-install etc.
12:11:55 <xplat> yeah, GHC is surprisingly cool about coexisting with different versions of itself
12:13:38 <xplat> holy crap, it's raining alsatians and pumas here
12:13:54 <ziggystar> Fuuze: Well, on calling make (as described in the docs), I got the linker errors. After that I ran 'cabal configure' and 'cabal build', 'cabal install' and it worked. An example is running. So calling minisat appears to work.
12:13:55 <xplat> oops, meant that for #-blah :(
12:14:06 <darthdeus> guys, anyone knows what's the name of the colorscheme that fpcomplete.com uses?
12:14:34 <ziggystar> I'll post an issue describing my problems. Maybe they need to update the installation instructions.
12:15:30 <Eduard_Munteanu> Hm, shouldn't there be some compiler magic to make instances of Lift from Language.TH.Syntax automatically?
12:16:05 <bennofs> Eduard_Munteanu: there is th-lift which allows deriving Lift instances via TH
12:16:21 <Eduard_Munteanu> Ah, thanks.
12:16:47 <Eduard_Munteanu> Is there a flavor involving Generic / Data, I wonder?
12:17:36 <bennofs> Eduard_Munteanu: hmm, idk.
12:25:59 <mu2l4k> Hi, how do you guys usually go about learning new Haskell API's?
12:26:23 <shergill> haskell api's?
12:26:41 <ion> Read the haddocks, look at example code, read some of the library source when appropriate
12:27:22 <mu2l4k> ion: of course, example code.
12:27:25 <shergill> why would the workflow be different than regular api's? the types help, but yeah other than that regular stuff
12:27:32 <Eduard_Munteanu> mu2l4k: usually I start by looking at the Haddock documentation, although examples are useful for denser ones.
12:27:34 <BacchanalianGeek> Hello everyone. I was here the other day getting some help on learning/running Haskell for the first time. A few chatters suggested a reinstall since the CreateDirectory method was being called each time I ran a basic program (doubleMe x=x*2). I found out that this was because anything that I'd save onto D drive faced the same problem. When i saved and ran programs off C drive, they worl.
12:27:38 <BacchanalianGeek> Wanted to say thank you
12:27:42 <BacchanalianGeek> *worked.
12:27:48 <Phillemann> Hmm, Random needs random to be complete. Isn't that kind of arbitrary?
12:28:12 <mu2l4k> cool. thanks.
12:28:20 <Iceland_jack> Arbitrary needs arbitrary to be complete. Isn't that kind of random? :)
12:28:49 <dwcook> That's so random!
12:28:52 <dwcook> (Cryptographically random!)
12:29:05 <Eduard_Munteanu> Cryptic indeed.
12:29:25 <dwcook> Phillemann: I think the idea is to provide the generalization as well as the default. One can't be deriveed from the other.
12:30:39 <dwcook> Well, maybe you could separate them out?
12:31:29 <dwcook> I guess all you'd really need would be a method :: (a, a).
12:31:43 <dwcook> I don't know why it doesn't do that.
12:33:58 <ibid> louisjb: ?
12:34:35 * hackagebot apiary-persistent 0.4.2.0 - persistent support for apiary web framework.  http://hackage.haskell.org/package/apiary-persistent-0.4.2.0 (HirotomoMoriwaki)
12:40:32 <Eduard_Munteanu> Bleh.. I'm looking for a way to generate an archive (not compressed) from a few data streams without intermediate files, but 'tar' and 'cpio' seem unable to take data from stdin or anything like that. Any ideas?
12:42:05 <kadoban> Eduard_Munteanu: tar can take from stdin, I've done it before
12:43:09 <Eduard_Munteanu> kadoban: it can only take names from stdin, but the actual data needs to be in files named such.
12:43:09 <harlanhaskins> @pl or' a b = not . butt a b where butt p q = not p && not q
12:43:09 <lambdabot> (line 1, column 42):
12:43:09 <lambdabot> unexpected " "
12:44:26 <c_wraith> Eduard_Munteanu: tar can certainly take data from stdin
12:44:27 <kadoban> Eduard_Munteanu: huh...sorry I guess I was thinking the other way, to stdout...ya that's different :-/
12:44:44 <Eduard_Munteanu> c_wraith: hm, any idea how?
12:45:44 <louisjb> what do you guys use these days for a Haskell editor, emacs is the best bet?
12:45:49 <c_wraith> oh, crap.  I really was thinking of the other half, same as kadoban.  tar is a weird thing to want to use with streaming input, since the whole point of it is archiving a directory tree.
12:45:50 <shergill> dolio: ooc, what do you do for work? do you work with edwardk? he was lauding your ability to find counter-examples and falsifying hypotheses
12:45:56 <dwcook> Maybe tar needs to seek and that's why it doesn't have that capability?
12:46:12 <Cale> louisjb: any text editor should do, so long as it can convert tabs to spaces and maybe do a little syntax highlighting
12:46:29 <harlanhaskins> @louisjb I'm part of the vim crowd. Big fan of vim. Syntastic will handle Haskell syntax really well.
12:46:29 <lambdabot> Unknown command, try @list
12:46:36 <kadoban> Well, I think the whole point of tar is to put a bunch of files/directories in one file, so maybe that's kinda why?  I'm not sure it makes sense to tar without named files or something.
12:46:39 <louisjb> syntax highlighting would be handy
12:46:40 <Eduard_Munteanu> c_wraith: actually I'm merely trying to combine two files into a single one
12:46:49 <jophish> I've got a bit of a weird problem, (this can rely on compiler magic as it's for my own compiler, but I'd like to have it run in GHC too): I need to class which is fillable with N bits of data, not necessarily the same type. N is decided by the instance
12:46:52 <awestroke> louisjb: sublime text 2
12:46:54 <jophish> It's tricky to describe
12:47:00 <kadoban> Eduard_Munteanu: cat file_one.txt file_two.txt > combined.txt  ?
12:47:16 <jophish> I suppose that it could be a sort of tuple type class
12:47:18 <louisjb> Syntastic is the vin syntax highlighting module? I get on with vim well
12:47:20 <Eduard_Munteanu> kadoban: in a way that I can get the parts back later
12:48:18 <kadoban> Hmmm...yeah I'm not sure how to do that except just tar or whatever :-/
12:48:20 <jophish> A transformation from a heterogenous list would probably do
12:48:26 <harlanhaskins> louisjb: Syntastic is a vim syntax checking module.
12:48:43 <Eduard_Munteanu> Maybe I should simply store the size of the first one in a custom format.
12:49:03 <harlanhaskins> louisjb: Vim has native support for highlighting.
12:51:25 <SrPx> Does anyone have an eli5 for this? http://tunes.org/~water/arrow/
12:53:17 <SrPx> http://tunes.org/~water/arrow/doc/ArrowTechnical.ps ah cmon. Is that some kind of joke?
12:55:22 <ziggystar> I've installed vim haskellmode. Type info (_t) works, but when trying the imports (_i) vim just goes into insert mode. Any ideas? I'm on a german keyboard, maybe this is the cause.
12:55:23 <awestroke> SrPx: foo
12:55:54 <kadoban> I could never get vim haskellmode to work right, I just gave up eventually.  It seemed unmaintained for a few years.
12:56:09 <dwcook> SrPx: I can't get anything but semantic fluff out of that first url
12:56:16 <SrPx> awestroke: foo you too \:
12:56:19 <ziggystar> What are you using?
12:56:36 <ziggystar> I think I've tried everything (except emacs). Nothing worked for me.
12:56:40 <kadoban> I ended up with just syntastic, ghc_mod, and neocomplete I believe.  Pretty good setup, but some doing.
12:56:50 <kadoban> but took some doing*
12:57:11 <ziggystar> Yeah, snytastic is a good start.
12:57:16 <SrPx> dwcook: yes, I lost 5 minutes on the philosophy paper trying to understand wtf the guy was trying to do... then I notice the existence of a technical paper and when I finally go to the content... foo.
12:57:26 <ziggystar> What does ghc_mod do? I think I have it installed, too.
12:57:37 <halvorg> Anyone here with some know how using OpenGL w/haskell?
12:57:42 <SrPx> I still want to know what he thinks he was doing though
12:57:53 <ziggystar> I somehow like to have type info and maybe some auto importing.
12:57:54 <kadoban> It works with syntastic I believe, pretty sure it's the part that does the actual syntaxt checking
12:57:56 <awestroke> halvorg: I've used the glut binding a little
12:58:21 <ziggystar> Yeah, Syntastic uses ghc_mod. Thought there is a dedicated ghc_mod plugin for vim.
12:58:40 <kadoban> Oh I use neosnippet too, that's kinda nice.  It does like templates for modules and functions and stuff easy.
12:58:48 <agreif> hi
12:58:52 <louisjb> i've set up vim pathogen and syntastic, will have a look at the Haskell syntax plugins
12:58:54 <halvorg> awestroke: I'm getting "GL error InvalidOperation (invalid operation)" on a $= call.
12:58:58 <halvorg> which I find really weird
12:59:02 <mmachenry> halvorg: Might as well ask. "don't ask to ask" is pretty much a universal IRC etiquette. :)
12:59:09 <croyd> ziggystar: there is a ghdmod plugin for vim, https://github.com/eagletmt/ghcmod-vim
12:59:16 <halvorg> only happens when I try use opengl 3.3, it works fine in 3.0
12:59:23 <napping> ziggystar: did you get that thing building?
12:59:31 <halvorg> mmachenry: Asked here before w/o any answer : )
13:00:12 <awestroke> halvorg: what's the exact line?
13:00:22 <ziggystar> napping: satchmo with minisat? Yes, I think it's working now. I have no idea why. Maybe it's not working anyway and just calling my installed minisat executable instead of the api.
13:00:43 <agreif> show "foo" returns "\"foo\""    Is there a way to get a string representation of a string without the inner paranthesis?
13:00:44 <ziggystar> But I could install the latest version of satchmo now.
13:00:50 <napping> that seems kind like a linker error if you are missing libraries, which would be a bit surprising if you're using cabal or something
13:00:51 <c_wraith> agreif: id
13:01:06 <halvorg> http://lpaste.net/104221 awestroke, that $=! call
13:01:12 <geekosaur> agreif: that question usually means youre trying to use show for something other than debugging or very simple serialization
13:01:13 <geekosaur> don't
13:01:14 <c_wraith> agreif: or maybe explain what you mean a bit better
13:02:41 <napping> agreif: id? putStrLn?
13:03:02 <ziggystar> This neco-ghc plugin also looks nice. But haskellmode has more features, I think. It also adds type declarations for functions, which I find particularly useful.
13:03:37 <kadoban> Yeah, I liked that feature...but it was one of the few features of haskellmode that actually worked right when I tried, so I gave up, haha.
13:03:48 <awestroke> halvorg: do you get the error as a string or as an Error ErrorCategory String ?
13:03:55 <ziggystar> Right. Few of the other features are working.
13:04:19 <ziggystar> I only got type info, general info, add type signature working, I think.
13:04:39 <halvorg> awestroke: not sure if I understand, how do I check?
13:04:44 <agreif> I want to us a generic function to return the string representation of the given argument. The argument an be String or Int or something. Currently I use "fooo" ++ value   In case of an Int it returns "fooo 123" but in case of a String it returns "fooo \"str\""
13:04:58 <awestroke> halvorg: how do you get the error? does it just appear in the logs?
13:05:03 <kadoban> IIRC my main issue was that every time I restarted vim, I'd have to wait for ages for it to rebuild some kind of cache whenever I used any features, and there didn't seem to be any way for it to actually save that between sessions.
13:05:14 <napping> agreif: isn't "\"abc\"" the string representation of "abc"?
13:05:15 <ziggystar> Hmm, but haskellmode doesn't look dead. Last commit on GH was 10 days ago.
13:05:17 <dwcook> agreif: so you want to special case String then?
13:05:20 <Eduard_Munteanu> agreif: you mean you're using show?
13:05:21 <napping> you'd like it to print foo "abc", right?
13:05:34 <Eduard_Munteanu> agreif: show isn't quite meant for that purpose.
13:05:48 <napping> agreif: or should yourFun "123" and yourFun 123 be indistinguishable?
13:05:53 <ziggystar> For me it's really fast. But maybe I only opened small projects.
13:06:08 <halvorg> awestroke: http://lpaste.net/104222 I manually check for errors (I found this func. somewhere), execution continues but I get a segfault when I try to draw using the shader that im activating attributes for.
13:06:32 <albeit> Is it possible to make a container composed of any object that of a specific typeclass? Something like "data Foo = (MyTypeClass a) => Set a"?
13:06:33 <Cale> agreif: I'm not entirely sure why you'd want such a thing -- why not just not apply show?
13:06:51 <Cale> agreif: You can of course invent some new typeclass for this
13:06:53 <kadoban> Maybe you found a better version of haskellmode than I did, or maybe it's been worked on since.  That'd be nice for next time I mess with my setup.
13:07:19 <Eduard_Munteanu> albeit: yes, that's an existential type, but you need a forall on 'a'.
13:07:45 <ziggystar> I think I didn't have to fiddle much with it. So I can recommend at least trying it out.
13:07:49 <dwcook> A type family might be a nicer solution but probably still overkill
13:08:03 <Eduard_Munteanu> albeit: {-# LANGUAGE ExistentialQuantification #-}    data Foo = forall a. MyTypeClass a => Foo a
13:08:42 <Mokosha> Hi, I'm having a little trouble parsing this case statement: http://hub.darcs.net/ertes/netwire/browse/Control/Wire/Switch.hs#53
13:09:10 <agreif> I am looking for a function that returns concatenates string with an int the same way as a string with another string. So that the result is for int: "foo 123" and for a string "foo str" instead of "foo \"str\""
13:09:28 <albeit> Eduard_Munteanu: thanks
13:09:47 <Lethalman> agreif, show?
13:09:49 <jorr> agreif: Does it only need to work for Int and String?
13:09:53 <Mokosha> mx has type 'Either e b', so it seems like the second case statement would never execute
13:10:00 <Eduard_Munteanu> agreif: there isn't one in the base libraries... there's printf or those pretty-printing combinators
13:10:07 <jorr> agreif: You could do an algebraic data type with all the types you care about, if it's only a few.
13:10:17 <agreif> the problem with show is that "foo " ++ show "str" returns "foo \"str\""
13:10:26 <Lethalman> agreif, right
13:10:34 <jorr> agreif: How many types do you need to use this function with?
13:11:06 <agreif> Only String, Int, Float.
13:11:13 <louisjb> installing ghc-mod via cabal, hope that's the best way
13:11:23 <geekosaur> Mokosha, it has a guard in it
13:11:46 <jorr> Then you can do an ADT, like data WhateverMakesSense = S String | I Int | F Float, or something like that
13:12:11 <jorr> and write a function :: WhateverMakesSense -> String
13:12:20 <agreif> jorr: and then pattern match on S I or F _
13:12:29 <jorr> agreif: yep :)
13:12:46 <geekosaur> Mokosha: so mx must look like Left <something>, and "running" mx' produces a Right <something>
13:12:53 <jorr> agreif: That's an option anyhow.  I'm not sure what your whole program is doing so hard to say if it's the *best* option
13:13:07 <ziggystar> Can I search a function in modules that are not loaded in ghci?
13:13:20 <ziggystar> Like :i without loading the module?
13:13:46 <geekosaur> not in ghci unless you can make work one of the mechanisms for hooking e.g. hoogle into ghci
13:13:55 <jorr> ziggystar: have you tried using the fully qualified names? I thought you can do this if the package is globally intalled.
13:14:06 <jorr> but maybe not per geekosaur
13:14:16 <ziggystar> The problem is that I don't know it. It's used in a file. And hoogle doesn't find it.
13:14:21 <geekosaur> full qualification may work, with some limitations
13:14:30 <jorr> yeah I think it's worked for me before
13:14:48 <jorr> ziggystar: what's the function do?
13:15:28 <ziggystar> It's from Satchmo. It's called notone.
13:16:07 <ziggystar> I can get the type info in vim. If haskellmode would be fully working, I'd know the full name. :(
13:16:30 <agreif> jorr: I am using the Data.Text.Template module where the Context is a list of tuples where the first is the key and the second is the value. The value can be of any type and I always want to convert the value into a String. With show everything works fine except fotr string.
13:16:32 <Mokosha> geekosaur: so if both produce a Left _, then it'll do the second in the case statement?
13:16:45 <geekosaur> yes
13:17:09 <geekosaur> or if mx is Right _ then it doesn't even run the action mx' to see what it produces, it just falls through
13:18:28 <ziggystar> D'uh. It's defined in the file. And it asserts the variable is not one (notone).
13:18:35 <ziggystar> I read "no tone".
13:21:44 <osa1> I have two modified versions of same program and I want to install them in separate sandboxes(they generate same executable files), is there a way to share all dependencies without manually installing to separate sandboxes and then add-sourceing all of them?
13:22:02 <napping> not easily
13:22:14 <osa1> too bad. does copying the sandbox folder work?
13:23:10 <bennofs> osa1: that should probably work
13:23:19 <bennofs> osa1: maybe just symlink it?
13:23:28 <osa1> bennofs: but then executables would be overridden
13:23:31 <osa1> overwritten*
13:23:52 <napping> Oh, yeah, copying the sandbox really should preserve whatever you've already built in it
13:24:13 <osa1> okay I'll try that once one sandbox finishes booting
13:25:12 <osa1> I hope that works because I got tired of rebooting sandboxes again and again -- I'm doing this all the time: I modify a program and  Ineed to keep old version too(for comparison etc.) so I'm creating two sandboxes...
13:25:42 <louisjb> boo, :GhcModType is not recognised
13:27:33 <osa1> and sometimes I'm compiling with profiling enabled which takes 2x more time.
13:27:45 <osa1> s/2x more time/2x time
13:27:51 <benzrf> ghcmodtype works for me
13:27:52 <benzrf> :-)
13:28:34 <benzrf> i have ^T in normal mode bound to putting the type of the currently-cursored expr in my statusbar
13:28:37 <benzrf> :-D
13:30:14 <louisjb> hmm some highlightin has come alive, I've set up pathogen, cabel install ghc-mod and vimproc so far, must have missed something
13:31:23 <napping> osa1: do you just need to keep the old binary?
13:32:09 <osa1> napping: yes and that's the problem
13:32:17 <osa1> btw, copying .cabal-sandbox folder worked.
13:33:13 <napping> you could also look into the options for sharing a sandbox like --sandbox-confix-file=...
13:33:25 <albeit> Is it possible to have existential types in the class constraint of a "type" definition? Otherwise, it seems verbose to make new separate datatype with a new data constructors for the existential type...
13:33:30 <agreif> BTW I solved my problem with    dropAround (\c -> c == '"') $ pack $ show <string or int>
13:33:57 <napping> If there's no library part at all, can you copy the binaries to different names to save them, and use git or something for source control?
13:34:00 <agreif> this returns the strings without the parenthesis
13:34:08 <albeit> Specifically, the ExecutableQuery part of this seems redundant: http://lpaste.net/104223
13:34:36 <agreif> maybe there is a better solution but I am in my 2. week of haskell... still
13:37:28 <hiptobecubic> that seems like something there would be some extension for if it's not directly possible..
13:41:05 <napping> agreif: That's a pretty funny type, don't you mean data ExecutableQuery = forall a. Executable a => a -> ExecutableQuery a?
13:41:48 <d3lxa> is Monad now Functor in ghc 7.8 or still waiting for 7.10?
13:41:54 <napping> agreif: the way you've written it, it just packs up some unknown type and an Executable instance for it, but no way to actually make values of that type
13:42:09 <napping> d3lxa: not yet
13:42:24 <quchen> 7.8 warns, 7.10 enforces.
13:42:34 <napping> agreif: and if you did include an a, the usual trick would be to pass a function (M.Connection -> IO Int64)
13:42:46 <d3lxa> napping: thx :)
13:43:07 <napping> because if you have a value of some unknown type, and all you know is that it's an instance of Executable, then all you can do is call execute on it
13:43:27 <napping> and then rather than tricks with existential types and stuff, maybe you'd rather just pass the pre-applied version
13:43:36 <Eduard_Munteanu> Hm, huh... tar might not even be appropriate, it seems limited to 1TiB-sized archive members.
13:44:19 <albeit> napping: Yeah, that's the goal. Just have a type DBQueue = Chan a, and be able to just write values of type a (Executable) to the channel.
13:44:59 <albeit> I just want the Chan to have values that can have execute called on them
13:45:11 <napping> albeit: so it might be simpler to make it Chan (M.Connection -> IO Int64)
13:45:18 <napping> and call (flip execute) on values before you put them in
13:45:19 <paolino> what is the main use for viewpatterns ?
13:45:57 <albeit> napping: But then the module that adds values to the Chan has to know about execute, which I want to avoid.
13:46:06 <Eduard_Munteanu> paolino: it's convenient in a few cases, one that easily comes to mind is using Data.Sequence conveniently...
13:46:30 <c_wraith> paolino: they aren't used all that much.  The main idea was that you could create a "view" data structure that's much simpler than the actual data structure, and provide conversion functions from the real structure to the simple view, a single layer at a time
13:46:50 <Eduard_Munteanu> paolino: you can write stuff like  foo :: Seq a -> ...; foo (viewl -> x <: xs) = ...
13:47:00 <c_wraith> paolino: it's possible they'll actually be used now that GHC 7.8 introduce pattern synonyms, which make them actually sane to use.
13:47:06 <Eduard_Munteanu> That is, apply a function to an argument and pattern-match the result.
13:47:10 <albeit> napping: Or I could just export a function like addQuery that hides the whole implemented of DBQueue!
13:47:16 <albeit> *implementation
13:47:18 <c_wraith> napping: yes, *that* is the answer
13:47:22 <c_wraith> err, albeit
13:47:41 <c_wraith> You write an add function that abstracts away all of those details.
13:47:46 <napping> albeit: for them to make "ExecutableQuery" they need to know about Executable
13:47:52 <paolino> I just moved a complex logic function to the left side of the definition, it looks more haskell
13:47:52 <napping> or you export something that abstracts it
13:48:00 <Eduard_Munteanu> A similar thing can be achieved with pattern guards: foo xss | x <: xs <- viewl xss = ...
13:48:12 <albeit> Ah fantastic, thanks
13:48:17 <napping> paolino: using view patterns along with pattern synonyms is really nice
13:48:48 <napping> you could do something like pattern ViewL x xs <- (viewl -> x :< xs)
13:48:58 <napping> and then just match on queues with foo (ViewL x xs)
13:49:27 <c_wraith> napping: sadly, it already used the *good* names for the patterns, which should have been like :< and :>
13:49:42 <c_wraith> (and something like Empty, of course)
13:49:52 <napping> c_wraith: import hiding?
13:50:10 <paolino> It seems they allow for more pattern matching in place of ifthenelse and Maybe case
13:50:54 <paolino> f (test -> True) = 0
13:51:21 <c_wraith> You can do that, but it's ugly.  guards are way better for that.
13:51:48 <paolino> f (test -> True) (test2 -> Just k) = k
13:52:37 <paolino> f (test -> True) (id &&& test2 -> (r,Just k)) = (r,k)
13:52:49 <ion> (r,Just kidding)
13:53:02 <paolino> :-)
13:53:12 <c_wraith> (arr, Just kidding)
13:54:43 <napping> Is there a nice inductive representation of graphs?
13:55:17 <napping> A tree with explicit backreferences would be nice, I think
13:55:35 <c_wraith> have you looked at FGL?
13:55:55 <c_wraith> @hackage fgl I think
13:55:55 <lambdabot> http://hackage.haskell.org/package/fgl I think
13:56:39 <napping> I think there was something clever with nested data types?
13:57:09 <vermeille> Is there a simple and stupid way to ask QuickCheck to generate ints in a specified range without writing an Arbitrary instance?
13:58:35 <ion> vermeille: choose
13:59:44 * hackagebot TimePiece 0.0.4 - A simple tile-based digital clock screen saver  http://hackage.haskell.org/package/TimePiece-0.0.4 (AudreyTang)
14:00:33 <c_wraith> ion: choose is kind of annoying for efficienty on a big range, but that *probably* won't matter
14:01:36 <napping> "Representing Cylic Structures as Nested Datatypes"
14:04:44 <napping> I see they only did references back to the ancestor
14:04:45 * hackagebot aeson-utils 0.2.2.0 - Utilities for working with Aeson.  http://hackage.haskell.org/package/aeson-utils-0.2.2.0 (AdamBergmark)
14:10:04 <Fuuzetsu> @hoogle String -> Text
14:10:06 <lambdabot> Data.Text.Lazy pack :: String -> Text
14:10:06 <lambdabot> Data.Text pack :: String -> Text
14:10:06 <lambdabot> Prelude read :: Read a => String -> a
14:24:23 <tinyghost> C'est quoi ce bordel que tu viens de dire putain de moi, petite salope ? Je vous fais remarquer que j'ai obtenu mon diplôme en haut de ma classe dans les Navy Seals , et j'ai été impliqué dans de nombreux raids secrets sur Al- Qaïda , et j'ai plus de 300 tués confirmés .
14:24:39 <tinyghost> oh whoops wrong channel
14:34:48 * hackagebot rest-gen 0.10.0.4 - Documentation and client generation from rest definition.  http://hackage.haskell.org/package/rest-gen-0.10.0.4 (AdamBergmark)
14:34:50 * hackagebot TimePiece 0.0.5 - A simple tile-based digital clock screen saver  http://hackage.haskell.org/package/TimePiece-0.0.5 (AudreyTang)
14:39:48 * hackagebot apiary 0.4.3.0 - Simple web framework inspired by scotty.  http://hackage.haskell.org/package/apiary-0.4.3.0 (HirotomoMoriwaki)
14:39:53 <louisjb> should I be able to launch a Haskell main from vi ?
14:40:31 <davidfetter>  /usr/ucb/vi ?!?
14:44:49 * hackagebot fclabels 2.0.1.1 - First class accessor labels implemented as lenses.  http://hackage.haskell.org/package/fclabels-2.0.1.1 (AdamBergmark)
14:49:12 <Fuuzetsu> tinyghost: i-is that the Navy Seal pasta in French?
14:49:55 <tinyghost> Fuuzetsu :<
14:54:50 * hackagebot app-settings 0.2.0.1 - A library to manage application settings (INI file-like)  http://hackage.haskell.org/package/app-settings-0.2.0.1 (EmmanuelTouzery)
14:59:51 * hackagebot wai-predicates 0.5 - WAI request predicates  http://hackage.haskell.org/package/wai-predicates-0.5 (ToralfWittner)
15:04:51 * hackagebot wai-routing 0.7 - Declarative routing for WAI.  http://hackage.haskell.org/package/wai-routing-0.7 (ToralfWittner)
15:10:14 <mtnviewmark> Aaaaaaand BayHac '14 has offically started!  Join us in Mtn. View, CA ... and in #bayhac
15:11:29 <jle`> woo hoo bay hac 14
15:28:18 <Fuuzetsu> mzero: Is there a list of projects you guys will be doing?
15:28:27 <ReinH> jle`: are you here? where?
15:32:25 <mzero> Fuuzetsu:  on the wiki...
15:32:46 <mzero> http://www.haskell.org/haskellwiki/BayHac2014
15:37:14 <Fuuzetsu> pretty cool logo
15:38:57 <Fuuzetsu> are the talks going to be recorded and uploaded somewhere?
15:42:02 <mzero> not sure yet
16:04:40 <quchen> This "is TDD dead" talk makes me think of "writing type sigs first is a good idea". I haven't heard of anyone in Haskell actually doing TDD (as opposed to TypeDD), am I living in a cave?
16:05:26 <shachaf> Sometimes we get questions in here from students who have a test coming up the next day.
16:05:26 <hpc> probably not
16:05:31 <shachaf> I call that "test-driven development".
16:05:38 <hpc> every TDD i have ever seen has been "statistical type system"
16:06:19 <monochrom> heh heh heh
16:06:57 <quchen> hpc: But dependently typed! :-D
16:09:01 <hiptobecubic_> :D
16:09:10 <silasm> I appreciate TDD when forced to write in Java. Haven't tried it in Haskell.
16:09:46 <c_wraith> I've written unit tests for haskell code.  But never before the code.
16:10:47 <Fuuzetsu> I'll write tests before the code if the test-suite has already been set up and has some other tests.
16:10:49 <quchen> Oh sure, testing is useful here as well. The development just isn't *driven* by it.
16:11:02 <WraithM> I've been having some trouble lately with neco-ghc. It is insanely slow... Anybody else been having trouble with it?
16:14:53 <WraithM> I think the trouble only happens when I'm in a sandbox
16:14:59 * hackagebot apiary 0.4.3.1 - Simple web framework inspired by scotty.  http://hackage.haskell.org/package/apiary-0.4.3.1 (HirotomoMoriwaki)
16:17:15 <Fuuzetsu> WraithM: making a GitHub issue is probably the best thing to do if you can gather some information
16:17:40 <WraithM> Okay! Thanks :) Yeah, just curious if I'm missing something obvious
16:19:59 * hackagebot apiary-websockets 0.4.3.1 - websockets supper for apiary web framework.  http://hackage.haskell.org/package/apiary-websockets-0.4.3.1 (HirotomoMoriwaki)
16:30:01 * hackagebot apiary-cookie 0.4.3.1 - Cookie support for apiary web framework.  http://hackage.haskell.org/package/apiary-cookie-0.4.3.1 (HirotomoMoriwaki)
16:30:03 * hackagebot apiary-persistent 0.4.3.1 - persistent support for apiary web framework.  http://hackage.haskell.org/package/apiary-persistent-0.4.3.1 (HirotomoMoriwaki)
16:34:21 <awestroke> how can a monad transformer based on StateT not be instance of MonadState?
16:35:04 <Eduard_Munteanu> awestroke: it could be a newtype
16:35:47 <awestroke> I don't know if I used the terminology correctly. I have type CheckM a = StateT A SomeMonad a    and it won't compile on a certain computer because of "use"
16:35:48 <Eduard_Munteanu> As opposed to a synonym.
16:36:24 <Eduard_Munteanu> awestroke: use? The one from 'lens'?
16:36:27 <Eduard_Munteanu> :t use
16:36:28 <lambdabot> MonadState s m => Getting a s a -> m a
16:36:33 <awestroke> Eduard_Munteanu: yes
16:36:43 <Eduard_Munteanu> awestroke: what's the error?
16:37:34 <Eduard_Munteanu> Also, you mean a monad or transformer stack based on StateT.
16:38:27 <dmj`> awestroke: newtype StateT s m a = StateT { runStateT :: s -> m (a,s) }, and then you could define, get, put modify outside of a typeclass
16:41:12 <awestroke> argh
16:41:19 <dmj`> awestroke: paste your code
17:00:13 <steven_> What is your preferred text editor/ide for haskell?
17:01:18 <bergmark> steven_: most people seem to use emacs or vim
17:01:41 <LordBrain> there is leksah
17:02:02 <LordBrain> i admit i am a vim user tho
17:02:10 <dmj`> emacs
17:02:30 <steven_> I downloaded leksah but idk I feel like im still just going to use vim
17:02:39 <LordBrain> yeah
17:03:12 <LordBrain> i have leksah installed, i figured it might be handy to do various kinds of searches or something sometimes.
17:03:34 <LordBrain> but i mostly use vim
17:08:07 <peddie> can anyone tell me what I'm doing wrong here?  http://lpaste.net/104227
17:08:34 <peddie> I'm trying to update a field of a structure by parsing its new value from a string
17:09:02 <shachaf> Writing your code too point-free to be easily readable, for one.
17:09:17 <peddie> well, sorry -- I'll make a new paste that's as pointed as possible
17:10:26 <peddie> heheh
17:10:31 <peddie> apparently it was too point-free for GHC as well
17:10:48 * peddie shrugs
17:11:10 <shachaf> OK.
17:11:17 <shachaf> Then I won't finish deciphering it.
17:12:39 <peddie> shachaf: thanks for the tip . . . I didn't have to change the type signature, but it started working
17:13:00 <shachaf> Now I'm confused, actually.
17:13:11 <shachaf> How did changing the point-freedom change anything?
17:13:17 <peddie> shachaf: right
17:15:59 <LordBrain> what version of ghc?
17:16:17 <LordBrain> hopefully your point-free is not actually equivalent, otherwise, you've found a bug
17:16:45 <peddie> LordBrain: I'm sure it's not
17:16:48 <peddie> I just don't understand how
17:16:57 <peddie> (rewriting to show both)
17:17:17 <shachaf> I'm not sure what peddie means to be doing or what peddie's code is doing, but I'm fairly sure they aren't the same thing.
17:18:27 <shachaf> For example:
17:19:12 <peddie> shachaf: I updated it to show the two versions side-by-side, along with their output:  http://lpaste.net/104227
17:19:13 <shachaf> > (readEither "22" :: Either String Int) >>= liftM (flip (_1 .~) (3,5))
17:19:14 <lambdabot>  Couldn't match type ‘Data.Either.Either GHC.Base.String a1’
17:19:15 <lambdabot>                with ‘GHC.Types.Int’
17:19:15 <lambdabot>  Expected type: GHC.Types.Int
17:19:15 <lambdabot>                 -> Data.Either.Either GHC.Base.String (a1, t)
17:19:15 <lambdabot>    Actual type: Data.Either.Either GHC.Base.String a1
17:19:22 <dmj`> does the HTTP library use lazy-io? Or is it safe to use...
17:19:59 <peddie> shachaf: the inferred types look the same to me
17:21:14 <quchen> Where did your liftM go? (>>= liftM foo) is not the same as (>>= return . foo).
17:22:37 <peddie> OH I see what I did
17:22:38 <peddie> oh man
17:22:51 <peddie> thanks quchen
17:23:06 * peddie facepalms
17:24:07 <shachaf> Over-@pled code makes it very hard to tell your intent.
17:24:22 <shachaf> I think people should err on the side of more named arguments.
17:24:30 <peddie> shachaf: I'll keep that in mind; thanks
17:24:36 <shachaf> If you ever write "flip" you've probably gone too far. :-)
17:24:48 <peddie> that sounds like an OK rule of thumb to me
17:25:40 <ReinH> shachaf: or probably (f .)
17:25:42 <quchen> shachaf: Speaking of named arguments, do they come at a cost? Does "m >>= \x -> f x" perform different than "m >>= f" at all?
17:25:43 <LordBrain> yeah, that's one thing hlint gets wrong imo
17:25:54 <shachaf> quchen: "maybe"
17:26:21 <shachaf> GHC does all sorts of inlining so it can be hard to answer a question like that locally.
17:26:36 <LordBrain> well there are those monomorphism restrictions
17:26:41 <peddie> shachaf: quchen: thanks again for the help
17:26:44 <shachaf> But in general the answer is yes, (\x -> f x) has different semantics from f and therefore can't be optimized to it.
17:27:03 <shachaf> In particular when f is _|_, (\x -> f x) isn't.
17:27:30 <shachaf> It's a bit of a scow that you can't do that.
17:27:50 <shachaf> On rare occasions this cost can become very significant.
17:28:21 <quchen> I remember edwardk mentioning repeated applications of fmap in lens suffered from this.
17:28:28 <quchen> I hope I remember correctly.
17:28:50 <shachaf> This is my favorite bug that results from over-eta-expansion: https://ghc.haskell.org/trac/ghc/ticket/7436
17:29:30 <quchen> I guess it's fair to think of "\x -> f x" as an explicit lambda that is probably optimized away, maybe.
17:31:32 <shachaf> It's probably not optimized away, though I bugged SPJ for a bit and he implemented a special case where if f is known to be non-_|_ then it is.
17:32:03 <shachaf> But it's probably not important enough to care that much about.
17:32:19 <shachaf> Except in cases like 7436. :-)
17:33:49 <quchen> Hm, that makes a nice example of when `seq` on a function is useful.
17:35:19 <shachaf> Well -- if seq on a function wasn't possible, GHC could just optimize (\x -> f x) to f always.
17:35:32 <shachaf> So this isn't a great justification for being able to do it.
17:36:44 <quchen> Why does Haskell not allow η reduction in general anyway? Is this a consequence of other useful design choices?
17:37:23 <Heffalump> quchen: it can change performance (space/time) dramatically
17:39:25 <edwardk> quchen: if f is _|_ when forced, it has different semantics than \x -> f x  isn't _|_ when forced
17:39:56 <oconnore> Hi, I'm reading http://www.haskell.org/ghc/docs/7.6.2/html/users_guide/loading-source-files.html , and when I load ghci 7.6.3, and :load <filename.hs>, I can't run any of the functions in that file (out of scope).
17:40:09 <oconnore> how do I :load something and get the functions into scope?
17:41:02 <hakujin> oconnore: prepend an asterisk on the filename
17:41:06 <hakujin> :load *test.hs
17:42:16 <oconnore> hakujin: cool, why did that work?
17:42:39 <hakujin> oconnore: because that's how you do it
17:42:46 <oconnore> oh, here http://www.haskell.org/ghc/docs/7.6.3/html/users_guide/interactive-evaluation.html#ghci-scope
17:42:49 <oconnore> got it
17:42:52 <oconnore> thanks
17:43:06 <quchen> edwardk: That's the current behaviour in Haskell, yes. But why was it designed this way? What undesirable behaviour would a Haskell with free η have?
17:43:08 <`Jake`> Do sections always desugar to lambdas?
17:43:26 <edwardk> quchen: ask dolio how to fix it. you'll cry ;)
17:43:51 <edwardk> he has a semantically correct fix
17:43:51 <quchen> I'd rather not :-x
17:44:04 <edwardk> it does nicely highlight the issue
17:44:28 <edwardk> I think in standard chartered's Mu they llow arbitrary eta reduction
17:44:45 <edwardk> but they don't pretend to be lazy _or_ strict
17:45:06 <ReinH> So this is how edwardk always seems to be in 2 places at once. Edward I know your secret now.
17:45:22 <quchen> edwardk: "_or_"? Is that an exclusive or, a "none of these options"?
17:45:22 <edwardk> what?
17:45:27 <wyager> In GHCI, why is `map (*2)` Integer -> Integer and not Num a => a -> a?
17:45:31 <ReinH> edwardk: always have irc open. Always.
17:45:34 <quchen> ReinH: Seen the Prestige? :-D
17:45:39 <ReinH> quchen: also that
17:45:41 <edwardk> quchen: they pretend it is both more or less ;)
17:45:45 <edwardk> ReinH: hah
17:45:56 <ReinH> conal: Hey! Are you at bayhac yet?
17:46:01 <edwardk> i also have twitter and a programming window open ;)
17:46:09 <wyager> Sorry, [Integer] -> [Integer] and not Num a => [a]->[a]
17:46:16 <conal> ReinH: yes.
17:46:31 <ReinH> conal: Awesome, will find you and say hi at some point.
17:46:37 <ReinH> conal: I'm looking forward to your talk!
17:46:42 <conal> ReinH: :)
17:46:57 <mietek> Unbelievable. yesod-platform-1.2.9.3 appears to conflict with itself.
17:47:16 <quchen> wyager: For me "map (*2) :: Num b => [b] -> [b]" when I enter ":t map (*2)".
17:47:18 <mietek> Full log: http://pastie.org/private/pktxj9r26rpg8w4uyllwjw
17:47:33 <wyager> quchen: Huh. Why would mine be [Integer] -> [Integer]?
17:47:43 <quchen> edwardk: "strictly lazy Haskell dialect"
17:47:45 <conal> ReinH: I just joined #bayhac
17:47:50 <ReinH> conal: good plan!
17:50:58 <zq_> is it possible to configure ghc to compile with -fllvm by default?
17:50:59 <quchen> `Jake`: Well, the report demands that "(`op` e) = \x -> x `op` e" and "(e `op`) = \x -> e `op` x".
17:51:17 <quchen> `Jake`: (When op is not ⊥)
17:51:19 <`Jake`> quchen: thanks
17:51:33 <benzrf> hmmmmm
17:51:47 <benzrf> > Cons
17:51:49 <lambdabot>  Cons
17:51:51 <benzrf> o_O
17:51:56 <benzrf> :t Cons
17:51:57 <lambdabot> Keyword
17:52:01 <benzrf> u-uh
17:52:30 <benzrf> @let data Jake = Jake String String
17:52:32 <lambdabot>  Defined.
17:52:41 <benzrf> > "pinging" `Jake` "hehe"
17:52:42 <lambdabot>  No instance for (GHC.Show.Show L.Jake)
17:52:43 <lambdabot>    arising from a use of ‘M495766621109893068730108.show_M4957666211098930687...
17:52:48 <`Jake`> heh
17:52:49 <benzrf> =[
17:53:06 <`Jake`> :t data
17:53:07 <lambdabot> parse error on input ‘data’
17:56:15 <mzero> 80 people in the room at #bayhac!!!!
17:56:46 <quchen> If I had known this was an IRC hackathon I would have joined as well ;-)
17:57:32 <wyager> What is #bayhac?
17:57:34 <`Jake`> benzrf: it works if you let lambdabot derive an instance for show
17:58:33 <benzrf> ik
17:59:23 <LowPotential> I am developing a suite a small programs that will share some functionallity and work in a unified way. I'd like to have a library "foo" and then programs "foo-a", "foo-b", "foo-c", etc that use features from the "foo" library. What's the best way to organize directories, cabal files, etc? Can I use a cabal sandbox for everything? How?
18:02:31 <tmobile> :t rpar
18:02:32 <lambdabot> Not in scope: ‘rpar’
18:02:37 <tmobile> :(
18:03:30 <DanielDiaz> LowPotential: you can describe that in a .cabal file
18:04:08 <DanielDiaz> LowPotential: http://www.haskell.org/cabal/users-guide/developing-packages.html#editing-the-.cabal-file
18:05:09 <wyager> quchen: I just updated Haskell and now `map (*2)` is Num b => [b]->[b]
18:05:13 * hackagebot treeviz 1.0.0 - Visualization of computation decomposition trees.  http://hackage.haskell.org/package/treeviz-1.0.0 (DavidBanas)
18:05:30 <wyager> oh wait
18:05:33 <wyager> OK, so if I do this
18:05:35 <wyager> let t2 = map (*2)
18:05:39 <wyager> :t t2 is
18:05:40 <lambdabot>     Not in scope: ‘t2’
18:05:40 <lambdabot>     Perhaps you meant one of these:
18:05:40 <lambdabot>       ‘to’ (imported from Control.Lens),
18:05:44 <wyager> t2 :: [Integer] -> [Integer]
18:05:58 <LordBrain> monomorphism restriction
18:05:59 <wyager> Why? Why wouldn’t it just be Num b => [b] -> [b]?
18:06:09 <LordBrain> wyager,
18:06:20 <LordBrain> write it without the point free
18:06:29 <LordBrain> t2 x = map (*2) x
18:06:43 <LordBrain> and it wont be restricted to be monomorphic
18:06:57 <wyager> huh
18:07:00 <wyager> that’s super annoying
18:07:03 <LordBrain> yeah...
18:07:04 <wyager> I’ll read about that
18:07:23 <LordBrain> its an ancient compromise
18:07:47 <wyager> yuck
18:07:49 <LordBrain> you could ddisable it with a flag
18:07:51 <wyager> Just like Java
18:07:56 <quchen> LowPotential: I think I'm doing what you want here: https://github.com/quchen/amoeba/blob/master/amoeba.cabal -- This has a library "amoeba", and then a couple of executables that depend only on that and base, in the same .cabal.
18:08:07 <wyager> (I kid)
18:08:47 <LordBrain> use {-# LANGUAGE NoMonomorphismRestriction #-}
18:09:13 <LordBrain> if you prefer
18:10:02 <LowPotential> quchen: Thanks! That looks perfect.
18:10:09 <LordBrain> i believe it was invented, to make haskell more conservative with regard to unnecessary duplication in memory
18:10:18 <LordBrain> if i recall correctly
18:10:26 <wyager> I would think the compiler would be smart enough to deal with something like that
18:12:00 <LordBrain> unnecessary duplication of code actually
18:13:00 <hakujin> recommendations on practical intro category theory books? I have an engineering math background but no further
18:13:12 <LordBrain> you see, the early haskellers wanted to be able to use bindings simply as a mneumonic for some value, and really we still do
18:13:26 <hakujin> how approachable is Steve Awodey's book?
18:14:28 <Eelis> hakujin: do you remember the rabbit scene from the holy grail?
18:14:37 <LordBrain> you don't live near central florida do you? I wouldnt mind being part of a category theory club or somethign like that.
18:15:01 <hakujin> Eelis: yes.. I hope I'm not a knight
18:15:19 <Eelis> :)
18:47:10 <edwardk> dolio: sigfpe just made a shout out to your many roads to free monads talk
18:49:02 <dolio> Just?
18:49:38 <gamegoblin> @pf \x -> (1, f x)
18:49:38 <lambdabot> Maybe you meant: pl bf
18:49:50 <gamegoblin> @pl \x -> (1, f x)
18:49:50 <lambdabot> (,) 1 . f
18:50:41 <spott> hey, I'm confused:  fromIntegral is Integral -> Num
18:50:55 <gamegoblin> :t fromIntegral
18:50:56 <lambdabot> (Num b, Integral a) => a -> b
18:51:02 <spott> so why does "div (fromIntegral a) b"
18:51:13 <spott> say: No instance for (Integral Double) arising from a use of `div'
18:51:23 <spott> >div (fromIntegral a) b
18:51:28 <gamegoblin> Because div only works on integer types
18:51:32 <gamegoblin> Which are Integer or Int
18:51:38 <spott> ah
18:51:38 <gamegoblin> Double is not Integer or Int
18:51:40 <spott> I see
18:52:04 <gamegoblin> What are you trying to divide?
18:52:21 <gamegoblin> div is the equivalent of integer division in other languages, e.g. 7/3 == 2
18:52:41 <spott> I'm writing a scheme compiler: (the "write yourself a scheme" tutorial)
18:52:55 <spott> and I'm attempting to add floating point types
18:53:18 <spott> :t div
18:53:18 <lambdabot> Integral a => a -> a -> a
18:53:28 <spott> I never did that... I should have done it earlier
18:53:34 <gamegoblin> ;)
18:53:50 <gamegoblin> :t (/)
18:53:51 <lambdabot> Fractional a => a -> a -> a
18:54:08 <spott> now I'm trying to figure out what I should do with 'mod'
18:54:19 <spott> modular arithmetic for Floats doesn't make a lot of sense
18:54:32 <gamegoblin> It’s defined a few different ways depending on the programming language
18:55:04 <gamegoblin> The most intuitive for me was “a % b” == keep subtracting b from a until you can’t subtract without going negative
18:55:25 <gamegoblin> Which is not very efficient, but you can implement the same result efficiently
18:56:04 <spott> hrm. I guess I COULD define mod for Floats...
18:56:16 <spott> still I think I would rather my compiler emit a type error...
18:56:36 <Eelis> is there a good extensible effects tutorial for haskell?
18:56:44 <Eelis> with practical examples of use
18:57:29 <skypers> edwardk: are you there?
18:58:07 <Eelis> ah, found the paper
18:58:44 <skypers> I think linear is column major
18:58:52 <skypers> where my stuff is row major
18:58:57 <skypers> or something like that
18:59:06 <skypers> I do mat * vec
18:59:09 <skypers> not vec * mat
18:59:35 <skypers> mkTransformation :: Quaternion Float -> V3 Float -> M44 Float
18:59:48 <skypers> that is quite column major to me
18:59:54 <skypers> qmat * tmat * v
19:00:00 <skypers> huhu, no
19:00:07 <skypers> v * tmat * qmat
19:01:20 <skypers> I’m at a demoparty, gonna take some rest, it’s 4 AM
19:01:22 <skypers> see you
19:04:55 <DryTear> yo wats up
19:30:54 <hakujin> Eelis: what about Conceptual Mathematics by Lawvere or An Introduction to Category Theory by Simmons?
19:37:58 <carter> gamegoblin: jus tdon't do mod for flats
19:38:01 <carter> floats
19:38:03 <carter> it dont make sense
19:38:53 <l4u> what should I use for Data.Map initial value for an accumulator?  With Data.Map.empty, I got an type error.
19:39:17 <carter> accumulating what?
19:39:24 <carter> use a monoid!
19:39:32 <l4u> accmulating a Data.map
19:39:39 <carter> just do a merge
19:39:40 <napping> Data.Map.empty should be right
19:39:47 <carter> yes napping  is correct
19:39:49 <napping> if it's a type error, you have something else wrong
19:39:56 <LordBrain> lpaste
19:43:31 <l4u> http://lpaste.net/104230
19:44:00 <Eelis> hakujin: no clue, sorry
19:48:15 <LordBrain> l4u, you left out the last parameter to insertWith
19:48:30 <LordBrain> in the definition of freq
19:48:58 <LordBrain> :t insertWith
19:48:59 <lambdabot>     Not in scope: ‘insertWith’
19:49:00 <lambdabot>     Perhaps you meant one of these:
19:49:00 <lambdabot>       ‘IM.insertWith’ (imported from Data.IntMap),
19:49:00 <l4u> LordBrain Thanks it works now
19:49:03 <LordBrain> hmm
19:49:27 <l4u> LordBrain any tips on preventing these newbie errors?
19:51:04 <LordBrain> well, don't fall in love with point-free
19:51:56 <LordBrain> on occasion it can make things more readable, but a lot of times it makes things less, in which case it is mostly pointless, pun not intended.
19:52:19 <LordBrain> ignore hlint warnings about point reduction, disable them.
19:52:48 <LordBrain> i dont know if that has anything to do with your bug tho
19:53:40 <LordBrain> except that it is possible to omit the acc_h parameter, if you had done a successful point-free, so this might have happened because you were half thinking of doing that?
19:55:18 <l4u> thanks let me read more about the right way to use point free style
19:55:52 <EvanR> looking for more ways to use types to my advantage, if i have maps from game entity ids to properties, how do i represent the id with a type that is guaranteed to have an entry in a given map
19:56:14 <EvanR> i find myself using error "bad id" when i know its in there
19:56:52 <EvanR> and looking gives Nothing
19:56:54 <EvanR> lookup
19:57:53 <bergmark> EvanR: only create a value of that type when an item is inserted into the map
19:58:19 <EvanR> right
19:59:27 <EvanR> i know how to guarantee Nothing never happens on lookup, but im wondering if theres a good way to avoid even checking that with the type system
19:59:30 <LordBrain> i'm not clear on the question, but i wouldn't use error "bad id", i'd try to use mplus, mfilter, etc.. inside perhaps the maybe monad or some error monad or whatever.. depending.
20:00:03 <EvanR> i dont want to handle a missing thing, i want missing things to be impossible
20:00:40 <EvanR> probably needs a different kind of Map, with a different kind of reference
20:00:59 <joelteon> I just read a comment on /r/haskell that says there are logic DSLs for languages, and that makes prolog obsolete. Does one exist for haskell?
20:01:34 <EvanR> MapDefinitelyHasKeyKtoX -> K -> X, not Maybe X
20:01:41 <LordBrain> oh
20:01:58 <LordBrain> if i understand you, you're looking for the power of dependent types there...
20:02:06 <LordBrain> hmm
20:02:12 <EvanR> i figured as much, what about haskell ;)
20:02:26 <joelteon> make the keys an ADT and pattern match?
20:02:27 <LordBrain> well, you could use some kind of hlist type foo
20:02:53 <joelteon> so speaking of logic, logict exists, but it really doesn't act much like prolog
20:03:10 <EvanR> hlist....
20:03:17 <monochrom> nevermind Map. even haskell f::Bool->Bool does not guarantee that f True has an answer.
20:03:50 <EvanR> ignoring bottoms ;)
20:04:23 <joelteon> or is the "logic DSL" for haskell just the type system?
20:06:21 <LordBrain> joelteon, i do not know, but since nobody else has answered you, i did some googling... is this possibly useful for you? https://hackage.haskell.org/package/hswip
20:06:37 <EvanR> im being blown away by the hlist package docs
20:06:48 <EvanR> oleg shit
20:06:57 <LordBrain> your first encounter?
20:07:34 <EvanR> ive heard of it
20:08:01 <joelteon> LordBrain: that's not really a prolog replacement, is it
20:08:37 <LordBrain> i dont know joelteon, i'd be interested tho if you find such a DSL. I don't know prolog, but i'm curious about logic programming
20:11:23 <LordBrain> ultimately, i think EvanR to get the gaurantee you want in the type system, you're going to have to do something clever.. you're not going to find a perfect fit rolled for you there i don't think.
20:12:38 <LordBrain> i suppose template haskell offers another alternative avenue to explore
20:12:53 <EvanR> grumble
20:13:58 <EvanR> i was thinking there could be a type for every combination of members
20:14:09 <EvanR> if thats not so many, it could be done manually
20:14:28 <EvanR> but it would be a huge number of cases, and not general
20:14:34 <LordBrain> you mean the key of the map?
20:14:42 <EvanR> the type of the map
20:15:01 <EvanR> ABC -> D -> ABCD
20:15:14 <EvanR> ABCD -> B -> ACD
20:17:52 <LordBrain> so you're doing something like an xor with the second parameter? :/ sorry if i am clueless
20:18:10 <EvanR> in the first one im inserting in the second one its a delete
20:18:49 <EvanR> i just feel like if i get a full program crash because a bug produced an invalid reference, im back to C and segfaults ;)
20:18:54 <SrPx> Is there an overview of typed systems and languages using them? For example, List&Cia are based on the ULC, Haskell/ML/Ocaml/etc are based on system F, Agda/Idris are based on MLTT, Coq is based on CoC (right?) and Epigram was based on OTT (?)... so I want a list/diagram/mind map or something connecting those and how they differ.
20:19:04 <SrPx> LIsp&Cia*
20:27:37 <roconnor> SrPx: yes CoC but now CiC.
20:30:51 <SrPx> roconnor: uh?
20:31:58 <carter> google CiC and Lambda cute
20:32:00 <carter> *cube
20:32:09 <carter> lambda cube isn't used in actual language
20:32:10 <carter> s
20:32:19 <carter> but gives a good vocab for the design space
20:32:37 <carter> not to be confused with time cube :)
20:33:23 <hiptobecubic_> time cube has the best vocab
20:33:33 <carter> the haskell lib or the crazy person website
20:34:22 <hiptobecubic_> i didn't know there was a haskell lib
20:34:37 <carter> @google alphaheavy timecube
20:34:37 <lambdabot> https://github.com/alphaHeavy/time-cube
20:34:41 <carter> :)
20:35:19 <hiptobecubic_> oh, it's a date time library?
20:35:54 <carter> yup
20:35:57 <carter> they were being silly :)
20:36:09 <roconnor> SrPx: I mean coq was originally based on CoC, but then it got inductive types.
20:37:04 <SrPx> roconnor: uh okay but I don't have a clear mental map of those systems );
20:42:05 <SrPx> How many rocks will be thrown at me if I define "iff a b c = if a then b else c"?
20:43:12 <u-ou> :t if'
20:43:13 <lambdabot>     Not in scope: ‘if'’
20:43:13 <lambdabot>     Perhaps you meant ‘f'’ (imported from Debug.SimpleReflect)
20:43:20 <geekosaur> sadly if' is not standard
20:43:25 <geekosaur> otoh it is defined a lot...
20:43:31 <SrPx> geekosaur: ah (=
20:44:15 <geekosaur> (I think any rocks would be about the name since "iff" has a specific meaning in math circles)
20:44:33 <u-ou> yar
20:46:20 <bms1> SrPx: I think that might be `bool` in Data.Bool
20:46:43 <bms1> :t Data.Bool.bool
20:46:44 <lambdabot> a -> a -> Bool -> a
20:56:32 <SrPx> bms1: ah okay, but bool?
20:57:06 <bms1> SrPx: It matches the eliminators maybe and either for their corresponding types
20:58:14 <carter> :t maybe
20:58:15 <lambdabot> b -> (a -> b) -> Maybe a -> b
20:58:19 <carter> :t Either
20:58:20 <lambdabot>     Not in scope: data constructor ‘Either’
20:58:20 <lambdabot>     Perhaps you meant ‘Other’ (imported from Lambdabot.Plugin.Haskell.Eval.Trusted)
20:58:25 <carter> :t either
20:58:26 <lambdabot> (a -> c) -> (b -> c) -> Either a b -> c
20:58:40 <carter> SrPx: soooo, Either is a sort of Generalized Bool :)
21:04:42 <dwcook> patter False = Left () ; pattern True = Right () -- I don't actually know the syntax for pattern synonyms
21:04:46 <dwcook> pattern*
21:05:03 <carter> i'm waiting a release cycle or two for them to be a bit more mature
21:43:37 <augur> carter: re dwcooks pattern synonyms for bools, that seems to be the direction Epigram 2 wouldve wanted to go
21:44:00 <carter> neat
21:44:09 <carter> i hope something like that does happen at some point
21:44:10 <carter> :)
21:44:26 <augur> probably not :(
21:44:42 <augur> epigram 2 was neat sounding -- first class data declarations, all sorts of fun stuff for free
21:44:48 <augur> alas tis no more :(
21:51:50 <carter> augur: solution, you need to get fabulously wealthy and bankroll epigram 2
21:52:09 <augur> ive actually mentioned this as a goal of mine before, carter =x
21:53:01 <carter> god speed
21:54:07 <glguy> ens
22:54:07 <kmspriyatham> I can't seem to use modules installed with cabal. I get something like "Could not find module ‘Test.QuickCheck’     Perhaps you haven't installed the "dyn" libraries for package ‘QuickCheck-2.7.3’?" Any help?
23:00:24 <pavonia> kmspriyatham: What does "ghc-pkg list QuickCheck" tell you?
23:01:04 <kmspriyatham> It gives me this "/Users/kmspriyatham/.ghc/x86_64-darwin-7.8.2/package.conf.d    QuickCheck-2.7.3"
23:02:11 <kmspriyatham> pavonia: This is what I got /Users/kmspriyatham/.ghc/x86_64-darwin-7.8.2/package.conf.d    QuickCheck-2.7.3
23:03:21 <pavonia> Hhm, I'm not sure what this "dyn libraries" is supposted to mean. Maybe it's expecting dynamic libraries but only finding static ones?
23:03:47 <pavonia> Do you use any special compiler flags for compilation?
23:04:00 <kmspriyatham> pavonia: no I don't
23:08:35 <fragamus> hi can somebody give me the elevator speech for why monoid formalism is a good thing
23:10:18 <startling> "monoid formalism"?
23:10:38 <fragamus> i mean monoids are everywhere but what is the big win for saying
23:10:38 <fragamus> hey here's a monoid
23:11:22 <startling> fragamus, There's a lot of types that are only Monads if they're parametrized by a Monoid.
23:11:36 <startling> e.g. Writer, and anything that's "tagged".
23:11:57 <fragamus> ah
23:12:06 <startling> fragamus, it's a natural formalism in a lot of ways. Associativity makes things interesting.
23:12:16 <c_wraith> fragamus: this will sound kind of dumb, but..  the big win is knowing that operations are associative, and that there's an identity element.
23:12:27 <fragamus> so its for interacting with other stuff that expects you to drop in a monoid of some kind
23:12:54 <c_wraith> the *reason* that sounds a little dumb is that it's more or less the definition of a monoid.
23:13:05 <fragamus> i get it
23:13:13 <c_wraith> But..  It turns out that both parts of that definition are really handy in practice!
23:13:21 <fragamus> i think I'll start trying to formalize my stuff
23:16:24 <c_wraith> fragamus: http://www.soi.city.ac.uk/~ross/papers/FingerTree.html is a reasonable read - it gives an example of how a data structure with operations parameterized over arbitrary monoids can do bunch of different things depending on your choice of monoid.
23:16:50 <c_wraith> (then the containers library implemented that data structure without the ability to choose the monoid you're using)
23:18:15 <kmspriyatham> pavonia: I found that cabal is not installing the packages in /usr/lib/ghc-7.8.2/package.conf.d but only in the path I told you above
23:18:40 <kmspriyatham> pavonia: Is there a way to force it install in /usr/.... too?
23:19:12 <startling> c_wraith: awesome. :(
23:19:37 <pavonia> kmspriyatham: There's a --global flag, I think
23:20:11 <c_wraith> I strongly recommend not using the --global flag.  You'll probably break your package database very badly.
23:20:41 <shachaf> Note that c_wraith's second statement isn't conditional.
23:21:11 <c_wraith> @where sicp
23:21:12 <lambdabot> http://mitpress.mit.edu/sicp/ | http://swiss.csail.mit.edu/classes/6.001/abelson-sussman-lectures/ | http://www.vex.net/~trebla/haskell/sicp.xhtml -- "Storage and Identification of Cabalized Packages"
23:21:12 <shachaf> You'll probably break it very badly. Given that, you might as well keep the damage to your own local package database.
23:21:30 <pavonia> What's the preferred way to install packages globally then?
23:23:32 <kmspriyatham> used --global now it has been installed there, but I still can't use the package. It can't find it.
23:32:46 <kmspriyatham_> ok, this is driving me mad. I can compile code using ghc that uses quickcheck, but I can't use it in ghci
23:35:21 <pavonia> kmspriyatham_: Do you have two different GHC versions installed, by chance?
23:36:51 <kmspriyatham_> May be, I had 7.6.3, but upgraded it to 7.8.2. But both ghci and ghc are using the same version
23:36:57 <enthropy> or maybe the ~/.cabal/config has something that disables the .dyn_o?
23:40:51 <agreif> test
23:46:39 <smiller2> How expensive is writeTVar?  At many times per second, I'm evaluating a giant record.  At the end of each evaluation, I'd like to store the giant record in a TVar, but since the 'TVar' will sometimes be ignored, I'm wondering whether writeTVar is expensive enough to warrent being more restrictive about when I write to to the TVar.
23:53:04 <redtricycle> How do I do this comparison?
23:53:18 <redtricycle> if (LB.unpack responseMsg) == "{status:sent}"
23:53:30 <redtricycle> import Data.ByteString.Lazy as LB
23:53:40 <redtricycle> er, import qualified that is
23:55:38 <redtricycle> http://lpaste.net/104234
23:55:52 * hackagebot jose 0.1.26.0 - Javascript Object Signing and Encryption  http://hackage.haskell.org/package/jose-0.1.26.0 (frasertweedale)
23:58:17 <pavonia> redtricycle: You have to decode the bytestring according to the text encoding it uses
23:58:56 <warpy> redtricycle: unpack :: ByteString -> [Word8]
23:59:12 <warpy> you'd have to convert [Word8] to Text or String
