00:04:10 <jle`> johnw: ah that's it. maybe i only read it recently
00:04:18 <jle`> would you say it's up to date?
00:05:34 <johnw> no, not really
00:05:56 <johnw> the exceptions library provides an abstract API for exception handling
00:06:09 <johnw> enclosed-exceptions provides a reasonable form of catchAny
00:06:31 <johnw> Marlow's book properly points out the important of handling async exceptions, which are ubiquitous
00:28:54 <augur> is there a haskell mode for emacs that lets me do things like automatic case splitting?
00:31:41 <mr-> augur: I think there is an ongoing GSoC-Project addressing that
00:31:50 <augur> mr-: :\
00:31:51 <augur> ok
00:32:34 <mr-> https://www.google-melange.com/gsoc/project/details/google/gsoc2014/serras/5651442522128384
00:32:51 <mr-> So I guess the answer is: Not now, maybe later this year :-)
00:54:55 <jle`> can we make instance Monoid e => MonadPlus (Either e)
00:55:09 <jle`> instance Monoid e => Alternative (Either e)
00:55:38 <jle`> so i can finally use mfilter and guard on Eithers :/
00:59:17 <supki> sure, if you do not care that it fails the laws
01:00:49 <Bynbo7> hpw is guard going to produce an e value when the boolean expressions is false?
01:00:54 <Fuuzetsu> augur: didn't structured Haskell mode get that?
01:01:10 <Fuuzetsu> (I have a package that lets you do this (very hackily) in Yi)
01:01:46 <supki> Bynbo7: Left mempty
01:01:58 <pyon> supki: How would that fail the laws?
01:02:45 <pyon> supki: Monoid e => Alternative (Either e) would combine all the error messages from the failed branches.
01:03:02 <Bynbo7> ah, missed Monoid, read it as Monad
01:03:02 <supki> Alternative is fine, I think
01:03:10 <mr-> pyon: what is Left mempty <> Right something ?
01:03:30 <supki> MonadPlus is problematic because of the  v >> mzero = mzero  law
01:03:37 <mr-> err.. Left mempty >>= Right something ?
01:03:46 <pyon> mr-: That does not even type check.
01:04:00 <mr-> and throw in a const..
01:04:07 <supki> e.g.  Left "foo" >> mzero /= mzero
01:04:37 <mr-> pyon: Yeah, sorry. I meant Left mempty >>= const (Right something)
01:05:08 <pyon> mr-: I haven't really thought this through for the MonadPlus case.
01:05:14 <pyon> Just for the Alternative case.
01:05:15 <pyon>  
01:05:55 <pyon> I am not sure what the MonadPlus laws are, or how MonadPlus is supposed to differ from Monad + Alternative.
01:06:44 <Bynbo7> Alternative ==> or, MonadPlus ==> and?
01:07:13 <pyon> MonadPlus looks very or-ish to me.
01:07:21 <pyon> Not and-ish at all.
01:07:51 <avoid3d> Hey, is this the haskell channel that everyone always says is so good?
01:08:05 <Bynbo7> yes
01:09:12 <Bynbo7> though if you listen to some people, some say it's not as good as it used to me
01:09:21 <augur> Fuuzetsu: no idea!
01:10:00 <mr-> pyon: actually, my case seems to be ok. The Left mempty >>= const (Left something) is not so fine, I think
01:10:09 <avoid3d> So I can't see your reply in my client (xchat) but I can see it if I go to the logs at  http://tunes.org/~nef/logs/haskell/?C=M;O=D. Any ideas?
01:10:10 <avoid3d> I'm on xchat on debian and I'm an IRC noob...
01:10:19 <pyon> mr-: Ah!
01:10:28 <Bynbo7> avoid3d_: that's very strange...
01:10:31 <Bynbo7> hello?
01:10:34 <Bynbo7> Can you hear me?
01:10:36 <Bynbo7> D:
01:10:46 <avoid3d_> So it turns out I'm pretty noob at this...
01:10:47 <jle`> supki: ah, so all mzero's/"absorbers" should be identical
01:11:19 <jle`> let's just move guard and mfilter to Alternative then
01:11:22 <jle`> problem solved :)
01:11:35 <avoid3d_> Bynbo7 I can only 'hear' you throught the logs
01:12:02 <Bynbo7> avoid3d_: that's awesome... I have no idea why that would be :P
01:12:33 <jle`> hm mfilter can't be in Alternative
01:12:37 <jle`> but guard can
01:12:43 <pyon> There is a MonadPlus IO instance? :-O
01:12:55 <pyon> What does MonadPlus even mean for IO?
01:13:12 <Fuuzetsu> augur: https://camo.githubusercontent.com/9ac5666ebfce015785f4d67a1873f2a83c9ebc35/687474703a2f2f6368726973646f6e652e636f6d2f737472756374757265642d6861736b656c6c2d6d6f64652f676966732d6e6f63616368652f636173652d73706c69742e676966
01:13:16 <sveit> when using attoparsec, is there a way to keep track of the line number?
01:13:29 <jle`> pyon: probably alternative worlds
01:13:33 <Bynbo7> holy URL batman!
01:13:51 <augur> Fuuzetsu: that looks awful
01:14:00 <jle`> io1 <|> io2
01:14:19 <pyon> jle`: That would make sense if IO were for running logic programs with backtracking.
01:14:20 <Fuuzetsu> augur: What does?
01:14:21 <Bynbo7> sveit: I'd be surprised if there's any way to do it with attoparsec directly, but you could pass around some state counting how many new lines you've seen... not ideal though
01:14:31 <augur> Fuuzetsu: that image
01:14:37 <augur> Fuuzetsu: what it depicts
01:14:46 <jle`> pyon: it would make sense if ghc could restore the state of the world
01:14:46 * hackagebot nats 0.2 - Natural numbers  http://hackage.haskell.org/package/nats-0.2 (EdwardKmett)
01:14:50 <Fuuzetsu> augur: for reference I made this months ago: http://fuuzetsu.co.uk/blog/images/case-split-s.gif
01:15:01 <Fuuzetsu> apologies for terrible quality
01:15:09 <jle`> io1 <|> io2, perform io1 and if it errors or destroys the world, reset the wrold and do io2
01:15:09 <pyon> jle`: Well, backtracking IO would require restoring the state of the world!
01:15:10 <pyon>  
01:15:29 <augur> Fuuzetsu: that ones better
01:15:32 <jle`> (implementation details left to the implementor)
01:15:38 <pyon> jle`: lol
01:16:06 <Fuuzetsu> augur: I agree that having to manually type out the type is a bit much
01:16:18 <sveit> Bynbo7: what if i had something easier; i have a single parser A that parses exactly one line, and call many A, and I want to track how many times A succeded
01:16:24 <avoid3d> grr
01:17:41 <Fuuzetsu> sveit: Wrap a counter around where you call A
01:17:44 <pyon> jle`: Broadly speaking, I see two large classes of MonadPlus instances: []-like and Maybe-like.
01:17:54 <pyon> (IO is neither!)
01:18:18 <Fuuzetsu> Guess that doesn't work, depends on your use-case
01:18:36 <sveit> Fuuzetsu: how exactly would I do that?
01:18:58 <avoid3d__> Okay, I joined online
01:19:06 <avoid3d__> maybe now I can see other peoples messages?
01:20:00 <pavonia> Yes, maybe
01:20:12 <avoid3d__> So is LYAH still the best way to get into hakell?
01:20:49 <johnw> the really depends on the person
01:20:53 <johnw> but many enjoy it
01:21:30 <Fuuzetsu> sveit: Do you have an actualy use-case? Maybe it's as simple as passing in an extra argument or maybe you have to use something like ReaderT to track it
01:21:33 <avoid3d__> I am in a CS 3rd year course and that's been advised to us.
01:21:33 <Fuuzetsu> actual*
01:21:47 <johnw> avoid3d__: I liked LYAH
01:22:05 <avoid3d__> that and one other resource which I am not a great fan of, which is a series of slides about xmonad
01:22:13 <rhaps0dy> it's very good, lyah
01:22:21 <rhaps0dy> I'm reading through it now
01:22:30 <avoid3d__> So I have gotten to type variables etc
01:22:38 <avoid3d__> and my mind is being a bit blown...
01:22:57 <avoid3d__> I much prefer this type of typing to the other typed languages I have used, c++ and java
01:23:14 <Fuuzetsu> Maybe a = Maybe<A>
01:23:46 <Fuuzetsu> although what you don't get in Java higher-kinded polymorphism
01:24:19 <avoid3d__> do you meen that higher-kinded polymorphism is present in java, or is present in haskell?
01:24:24 <sveit> Fuuzetsu: the use case is exactly i have a parser A that parses a single line. my main parser is just mainParser = many A. I'd like to count the A's
01:25:00 <pavonia> length <$> many A  :p
01:25:03 <avoid3d__> http://hydrocodedesign.com/2014/04/02/higher-kinded-types/ <- put in my TOREAD list
01:25:29 <Fuuzetsu> countedAs = many A >>= \s -> (length s, s)
01:25:52 <pavonia> sveit: Have you considered using Parsec instead? It makes things like column counting or maintaining a user state really easy
01:27:35 <sveit> pavonia: my file is gigantic, parsec would be too slow
01:27:35 <Fuuzetsu> avoid3d__: It's just an idea that you can abstract over things that are ‘leftmost’ of type variables: expressions like ‘m a’. In Java for example doing something like Functor<M> /* blah blah */ M<A> is not supported as far as I know
01:27:38 <sveit> i think
01:28:26 <Fuuzetsu> try and see, I hear Parsec is much friendlier
01:28:35 <Fuuzetsu> although I personally tend to always use Attoparsec anyway
01:29:41 <sveit> Fuuzetsu: I think i was unclear. I meant that at each step of the parse I want to have a running count of the calls to A
01:30:03 <sveit> i suspect I would no longer be able to use the applicative style in this case and would have to go back to a monadic style though
01:32:03 <Fuuzetsu> you'll probably have to use something to track user state
01:33:21 <Fuuzetsu> s/user //
01:35:03 <sveit> Fuuzetsu: should I put the state monad "inside" or "outside" the Parser?
01:35:32 <johnw> inside if you want a failed "try" to throw away state changes
01:35:57 <pavonia> How would you put it inside?
01:36:11 <Fuuzetsu> Parser is just an alias for ParserT
01:36:13 <johnw> ParsecT s u (StateT s2 m) a
01:36:42 <pavonia> We're talking about attoparsec, no?
01:37:16 <Fuuzetsu> apparently I was wrong here
01:37:27 <kqr> doesn't parsec already have a state keeping mechanism?
01:37:30 <johnw> attoparsec doesn't have a transformer
01:37:43 <pavonia> kqr: Yes
01:37:44 <johnw> kqr: yes, that's the first 's'
01:37:47 <Fuuzetsu> In Attoparsec you could have something like Parser (State a) instead of Parser a
01:37:54 <kqr> oh i see, attoparsec
01:40:31 <yitz> sveit: two additional ideas:
01:40:50 <kqr> johnw, the first s is the stream type, by the way
01:40:52 <kqr> johnw, the u is the state
01:41:04 <yitz> sveit: 1. if you're parsing line-by-line, sometimes you can start with T.lines and then parse each line separately.
01:41:35 <yitz> sveit: 2. can you get the count of A's after the parse is finished, from the result?
01:41:57 <sveit> yitz: i could, my next idea was basically to do a zip [1..] with my results
01:42:59 <yitz> sveit: it's usually best to limit parsers to actual parsing, which is what they're good at. trying to include other logic inside is always a big complication.
01:44:24 <krysmin> Hello
01:44:32 <krysmin> How are you all?
01:44:58 <yitz> hi krysmin
01:45:26 <krysmin> I will learn haskell :-)
01:46:07 <t7> thats the spirit
01:50:31 <krysmin> Where haskell is better than other languages?
01:50:56 <corgifex> type system
01:51:00 <corgifex> laziness
01:51:16 <corgifex> exploding brains
01:52:19 <krysmin> But what kinds of program? :-)
01:52:38 <nclarke> Good ones
01:52:58 <sjy> one of my favourite mature haskell programs is http://johnmacfarlane.net/pandoc
01:53:06 <nclarke> It's much harder to write really bad programs in Haskell. A lot of them refuse to compile
01:53:39 <sjy> actually, there seems to have been a lot of discussion about parsing in this channel lately
01:54:55 <haasn> Haskell is better at writing programs that won't crash and send back 64k of your server's memory
01:55:11 <sipa> unless you use OpenSSL, of course
01:55:30 <bezoka_> haasn: okay, thanks ;0
01:55:32 <bezoka_> :)*
01:57:04 <krysmin> brb
01:57:34 <merijn> haasn: To be fair, that applies to any language without manual memory management
01:57:51 <kqr> how do i define a parser that parses either the string "END" or EOF? (I tried with `string "END" <|> eof` but since `eof` is a Parser () and `string "END"` is a Parser String I can't combine them like that.) i'm not interested in what they parse, so basically i'm looking for a `skipString` parser (similar to the `skipMany` parser but for entire strings)
01:58:04 <haasn> heartBeat :: Request -> IO Response; heartBeat Req { data = d } = reply $ d ++ peekArray (64*1024) randomPtr -- just doesn't have the same sort of transparency
01:58:55 <haasn> kqr: void :: Parser a -> Parser ()
01:59:25 <kqr> haasn, ...i should have known! thanks a bunch
01:59:43 <haasn> you could also use (<$) :: a -> Parser b -> Parser a
01:59:53 <merijn> kqr: Or even just "string "END" <|> eof" ;)
01:59:53 <haasn> eg. () <$ string "END"  <|>  eof
01:59:55 <merijn> err
02:00:02 <corgifex> string "END" *> pure ()
02:00:06 <merijn> kqr: Or even just "(string "END" >> return ()) <|> eof" ;)
02:00:20 <haasn> corgifex: Yes, that's the same as (() <$) and void, except more verbose
02:00:49 <corgifex> well, you know haskell's motto: TMTOWTDI
02:01:15 <haasn> (and also the same as >> return (), except both of these are increasingly less general)
02:01:57 <krysmin> is possible to write for avr in haskell?
02:02:25 <pavonia> What is that?
02:02:39 <krysmin> microcontrollers
02:04:52 * hackagebot hakyll 4.5.3.0 - A static website compiler library  http://hackage.haskell.org/package/hakyll-4.5.3.0 (JasperVanDerJeugt)
02:04:54 * hackagebot mtl 2.0.1.1 - Monad classes, using functional dependencies  http://hackage.haskell.org/package/mtl-2.0.1.1 (HerbertValerioRiedel)
02:05:24 <yitz> corgifex: the last D stands for "Declare". That' more general. "Do" is only for monadic code.
02:07:35 <yitz> haasn: heartBeat :: Request -> Response; heartBeat Req { data = d } = reply $ d ++ unsafePerformIO (peekArray (64*1024) randomPtr)
02:09:52 * hackagebot contravariant 0.6 - Contravariant functors  http://hackage.haskell.org/package/contravariant-0.6 (EdwardKmett)
02:13:51 <merijn> argh
02:14:00 <merijn> A pox upon the brokenness of ImpredicativeTypes
02:16:53 <saeidw> Hello #haskell, I have a question about a mapping pattern and I can't find a function for it:
02:17:27 <saeidw> If I have Foo a b, and [Foo a b], I want to map over that list, extracting only the b parts into a [b]
02:17:48 <saeidw> Is that a common pattern that has a name?
02:17:58 <nclarke> map (\Foo _ b -> b)
02:18:18 <merijn> nclarke: No, not if Foo resembles Either
02:18:35 <merijn> saeidw: Either has lefts/right "lefts :: [Either a b] -> [a]"
02:18:51 <merijn> saeidw: I don't think there's a concrete name
02:19:12 <nclarke> merijn: Fair point, I was taking Foo as a data constructor. But true that doesn't fit with the notation
02:19:21 <jle`> saeidw: well, if you have record accessors for Foo, you can use those
02:20:10 <saeidw> thanks everyone, I guess I'll just define a [Foo a b] -> [b] for my types (I have several)
02:25:55 <Konlov> Hi #haskell, which visual debugger you can recommend (cross platform preferable)? ghci is not so friendly for newbie.
02:25:56 <jle`> merijn: well, you can i think
02:26:00 <jle`> saeidw:
02:26:22 <jle`> > [ x | Left x <- [Right 1, Left 'e', Right 4, Left 'c'] ]
02:26:23 <lambdabot>  "ec"
02:26:30 <xeno> on osx, the latest haskell distribution (2013.2) - but cabal seems broken. Any tips?
02:26:34 <jle`> not really a map i guess
02:26:50 <xeno> e.g. <command line>: cannot satisfy -package-id HTTP-4000.2.8-cdf033f9d7051824f52cd5101df67509
02:27:11 <nclarke> xeno: Have you done a cabal update?
02:27:16 <xeno> yes
02:27:25 <saeidw> jle`, that's pretty neat
02:27:27 <pyon> jle`: Whoa, nice, I did not know list comprehensions could filter stuff by pattern matching.
02:27:34 <xeno> it fails on cabal install cabal-install
02:27:51 <pyon> xeno: tried cabal install cabal-install --dry-run to see what the problem could be?
02:28:32 <xeno> pyon: it just says it would install cabal-install
02:29:58 <no-n> @pl \xs -> map (xs!!) . take (length xs) . nub . randomRs (0, length xs - 1)
02:29:58 <lambdabot> ap ((.) . map . (!!)) (ap ((.) . take . length) ((nub .) . randomRs . (,) 0 . subtract 1 . length))
02:30:04 <no-n> lol
02:31:19 <{AS}> Is is possible to get your own version of @pl
02:31:54 <xeno> additional info: this is on a macbook pro 2013 model, mavericks
02:32:13 <xeno> and it's not only cabal-install that fails
02:32:43 <pavonia`> @hackage pointfree -- {AS}
02:32:43 <lambdabot> http://hackage.haskell.org/package/pointfree -- {AS}
02:33:34 <mmmm> Can you paste the whole log somewhere xeno ?
02:33:47 <nclarke> xeno: I would try moving your ghc dir and trying with an empty one
02:34:09 <nclarke> E.g. mv ~/.ghc ~/.ghc-old; mv ~/.cabal ~/.cabal-old
02:34:17 <halvorg> What's the ghc command to compile a .hi?
02:34:19 <nclarke> cabal update; cabal install cabal-install
02:34:34 <xeno> mmmm: sure
02:34:47 <xeno> nclarke: trying now
02:34:55 * hackagebot HaTeX 3.11.0.1 - The Haskell LaTeX library.  http://hackage.haskell.org/package/HaTeX-3.11.0.1 (DanielDiaz)
02:35:12 <xeno> nclarke: I have none
02:35:16 <jle`> pyon: yeah it's one of the few cases where i use list comprehensions.  if you think of generalized monad comprehensions, it can be thought of as using `fail` for `[]`.
02:36:23 <xeno> http://pastebin.com/wgDMjUm2
02:37:19 <{AS}> pavonia: thanks
02:42:48 <aloiscochard> I had some cabal hell other the weekend, and from what I understand 'ghc' depend on 'Cabal' is that correct?
02:42:58 <aloiscochard> (I cannot find 'ghc' package in hackage.. so not easy to investigate)
02:44:46 <xeno> oh, and I ran the ghc-clang-wrapper workaround for Mavericks
02:49:46 <mmmm> xeno: I'm no expert but on line 56 it says it is using gcc
02:49:52 <xeno> nclarke: mmmm: I'm using the ghc-wrapper. Could also use xcode-gcc4.2, but when I try to install that with brew, I get "Error: No available formula for apple-gcc42"
02:50:13 <xeno> mmmm: apple has renamed clang as gcc
02:59:58 * hackagebot tianbar 0.4.4.0 - A desktop bar based on WebKit  http://hackage.haskell.org/package/tianbar-0.4.4.0 (AlexeyKotlyarov)
03:01:48 <xeno> mmmm: btw, here's the settings... looks suspicious, but I have no clue how it should be: http://pastebin.com/Xh1166yG
03:04:00 <mmmm> I have no idea either sorry
03:06:53 <xeno> it's one of the shitty things with OSX - so full of old crap, ancient versions of everything...  I think RMS is largely to blame though, with new GPL revisions
03:07:42 <corgifex> time to kill the messenger
03:09:03 <xeno> nclarke: I actually did have ~/.ghc and ~/.cabal - I just got tricked by being in the wrong home folder, and only showing last part of the path
03:09:09 <xeno> lets see now
03:10:08 <xeno> zzzz... takes forever...
03:10:36 <xeno> warnings seems different and fewer now...
03:12:20 <xeno> it went to hell
03:12:27 <xeno> and hell ain't a nice place to be
03:14:29 <xeno> meh, it uses /usr/bin/gcc
03:14:37 <krysmin> is on wikibooks good tutorial for haskell?
03:14:43 <krysmin> or you know better?
03:15:43 <mayski> have you read "learn you a haskell"?
03:15:59 <krysmin> mayski: not, I am beginner ;)
03:16:15 <mayski> krysmin: http://learnyouahaskell.com/
03:16:17 <krysmin> mayski: is it better than wikipedia?
03:16:20 <xeno> mayski: to be honest, learn you a haskell is a pretty good book, but not for learning practical haskell :)
03:16:21 <krysmin> wikibooks*
03:16:29 <mayski> heh
03:16:41 <rhaps0dy> xeno: not for learning practical haskell?
03:16:42 <rhaps0dy> why?
03:16:44 <xeno> there's this apress book out that works well
03:16:45 <mayski> well, that's what I use anyway :)
03:16:47 <rhaps0dy> I'm reading lyah D:
03:16:49 <warpy> krysmin: it is the best good for beginners
03:17:00 <warpy> krysmin: and you can read it online!
03:17:11 <krysmin> warpy: yeah I see it
03:17:21 <katana756> does haskell have good free matrix library (inv, pinv, eig, svd..)?
03:17:22 <warpy> er, best s/good/book/
03:17:33 <seye_1> the apress one, really needs a (better) editor
03:17:42 <xeno> rhaps0dy: I read it before learning haskell, and afterwards I knew more about monads and such, but I still couldn't write more than a few lines of haskell
03:17:54 <rhaps0dy> :|
03:18:05 <mayski> I think imma learn me a cryptol
03:18:13 <rshetty> Hey
03:18:15 <rhaps0dy> I think I can write a few lines and I haven't finished it yet
03:18:21 <rhaps0dy> xeno: did you know any language before?
03:18:26 <nclarke> katana756 There is hmatrix: http://hackage.haskell.org/package/hmatrix
03:18:34 <jdiez> one thing I've found about learning haskell is that the community is very forward with haskell's shortcomings
03:18:37 <jdiez> like bad function naming, etc
03:18:50 * xeno usually don't promote apress books (they tend to lack editing/polishing), but the haskell one - despite using eclipse - seems decent
03:18:57 <xeno> rhaps0dy: about 20 languages or so
03:18:57 <jdiez> this is very different to my experience with other programming languages, where the community tends to sweep the mistakes under the rug
03:19:00 <rhaps0dy> jdiez: because we are obsessed with the quality of our code
03:19:05 <xeno> rhaps0dy: depending on how you define know
03:19:10 <rshetty> I was going through haskell type system, and was wondering whether it is similar to kind of interfaces in java ? If not can I compare it to anything else to understand better ? :)
03:19:12 <jdiez> rhaps0dy: yeah, I can tell. I think it's a good thing btw
03:19:13 <xeno> somewhere around 15-30'ish
03:19:14 <rhaps0dy> xeno: more than me probably then
03:19:16 <rhaps0dy> weird
03:19:22 <jdiez> rshetty: classes are similar
03:19:30 <jdiez> and completely unlike java classes
03:19:33 <rhaps0dy> jdiez: yeah me too
03:19:37 <xeno> rhaps0dy: I read it quick then
03:19:42 <rhaps0dy> maybe
03:19:43 <narendraj9> What Haskell applications do people contribute to?
03:19:44 <rhaps0dy> I'm taking a long time
03:19:49 <rhaps0dy> narendraj9: xmonad
03:19:59 <rhaps0dy> maybe pandoc ?
03:20:17 <rshetty> jdiez: How unlikely to Java classes ?
03:20:22 <krysmin> "The channel #haskell on the freenode network is a great place to ask questions if you're feeling stuck. People there are extremely nice, patient and understanding to newbies. "
03:20:25 <krysmin> :D
03:20:36 <narendraj9> rhaps0dy: Okay. I knew about that one.
03:20:57 <narendraj9> rhaps0dy: yes. pandoc is nice.
03:21:22 <narendraj9> krysmin: It's one of the channels that never sleep. I am damn serious.
03:21:34 <jdiez> to be fair, most technical channels never sleep
03:21:48 <nclarke> narendraj9: I wrote a thing called Tabula (it records command line sessions): https://github.com/nc6/tabula
03:21:54 <narendraj9> jdiez: Where do you see this much of activity?
03:22:21 <jdiez> narendraj9: #python is pretty active, for example
03:22:42 <narendraj9> nclarke: Recording commandline sessions is cool. But how is it different from recordmydesktop, if it is?
03:22:57 <nclarke> I haven't heard of that. I'll take a look
03:23:19 <narendraj9> nclarke: recordmydesktop isn't in Haskell.
03:23:51 <narendraj9> nclarke: It records the whole desktop. I was just wondering how your application records commandline sessions.
03:24:02 <narendraj9> jdiez: Yes, python is pretty much active.
03:24:38 <nclarke> narendraj9: I see. Mine is more about capturing the data in a structured way for future analysis, rather than recording to replay
03:24:54 <jdiez> nclarke: I see you're using Data.Aeson.TH
03:25:01 <jdiez> any reason to use that instead DeriveGeneric?
03:25:19 <nclarke> jdiez: You'll notice I use DeriveGeneric in another file :-) So no, I think I just came across that first!
03:25:46 <jdiez> nclarke: ah, okay. I still haven't made my mind up as to which one to use
03:25:55 * jdiez hasn't written anything significant in haskell yet
03:26:02 <nclarke> https://github.com/nc6/tabula/blob/master/Tabula/Record/Environment.hs
03:26:07 <rhaps0dy> nclarke: this has to be godsend for sysadmin tutorials
03:26:09 <rhaps0dy> I see it
03:26:32 <nclarke> This was the first big thing I wrote by myself. I'd be very interested in criticism, if people have any!
03:27:20 <rhaps0dy>  I'm not good enough to criticise yet
03:27:50 <jdiez> I haven't written anything significant yet, but I feel like I've grown a lot, while learning haskell
03:28:02 <jdiez> I'll try my hand at some simple API wrappers soon
03:28:03 <warpy> grown fat?
03:28:19 <jdiez> warpy: wisdom-wise
03:29:03 <warpy> mmm. wisdom-fat
03:32:12 <narendraj9> I am still learning.
03:34:51 <FireFly> I haven't written anything significant in Haskell either :\
03:35:01 <FireFly> I mostly use it to play around with typeclasses and things
03:35:12 <jdiez> hey FireFly, we meet again.
03:35:19 <FireFly> :) so we do
03:35:26 <FireFly> Small network
03:35:30 <Taneb> FireFly, one of my friends has been writing an image board in Haskell
03:35:40 <jdiez> or converging interests :P
03:35:47 <FireFly> Or that
03:35:59 <Taneb> If you want ideas for things to do in the language
03:36:09 <FireFly> Freenode channels.. converging...
03:36:58 * xeno tries again, after linking /usr/bin/gcc to gcc-4.2 by hand... 
03:37:18 <xeno> I need to remember that next time I wanna do iOS development...
03:37:56 <FireFly> Taneb: hm, maybe I should do something web-server-y
03:38:09 <FireFly> maybe a wiki or something
03:39:04 <rhaps0dy> xeno: what do you think of obj-c ?
03:39:20 <rhaps0dy> I have only seen the surface and it looks very bad
03:39:43 <xeno> that it is horrible - it's like C (which is utterly horrible), crossed with smalltalk (which is bad)
03:40:02 <xeno> the tools are good though
03:40:53 <narendraj9> Taneb: What's an image board?
03:41:52 <warpy> narendraj9: a forum on which you can post images and then have discussions around them
03:42:44 <corgifex> 4chan
03:42:48 <xeno> rhaps0dy: it sorta works if you just ignore what you're really doing...
03:42:54 <narendraj9> xeno: I don't think C is horrible. Some people do like to know about the machine they code for. Why do you think C is horrible?
03:43:12 <corgifex> if you're programming in C, you're coding for C
03:43:26 <corgifex> if you think C is just a high-level assembler, you're part of the problem
03:45:38 <Taneb> narendraj9, something of 4chan's format
03:45:39 <xeno> narendraj9: I should have routine in this by now, but I'm still not sure how to summarize it... I think I'll do it like this: C solves 3 use cases: be compileable in 2k memory, cross compile a subset/variant of PDP11 assembly, and to delegate compiler tasks to the user (since user time was cheap compared to cpu time). None of those are valid anymore
03:46:15 <xeno> and meh... new error: "cabal-install-1.20.0.1 failed during the building phase. The exception was: ExitFailure 1"
03:49:18 <todaystomorrow> While haskell is great to program with for hobby projects... is there work with haskell?
03:49:31 <rhaps0dy> probably
03:49:38 <rhaps0dy> though there's more work with erlang I think
03:49:51 <todaystomorrow> hmm, any reason for erlang ?
03:50:17 <pyon> narendraj9: It is more like C really shows its age. (Though "old" does not necessarily imply bad, e.g., ML.) It is possible for a language to give you low-level control without depriving you of nice types (e.g. Rust).
03:50:17 <rhaps0dy> xeno: y-you don't like C
03:50:28 <xeno> rhaps0dy: no
03:50:36 <rhaps0dy> todaystomorrow: ericsson uses it. I don't really know the language so idk
03:50:36 <xeno> rhaps0dy: I think it's totally crap
03:50:43 <rhaps0dy> well shit
03:50:49 <rhaps0dy> I do love my c
03:50:58 <rhaps0dy> it can be very obscure, true
03:51:05 <xeno> rhaps0dy: it was a good workaround in 1972, should have been replaced by 1985
03:51:11 <rhaps0dy> but what else do you use when you need low level ?
03:51:40 <rhaps0dy> oh, rust
03:51:42 <warpy> todaystomorrow: https://www.quora.com/Haskell-in-Industry
03:51:46 <xeno> that's a hard question.. :/ - but the lack of competition does not make the language better
03:51:51 <rhaps0dy> pyon: is Rust as much of a mess as C++ ?
03:51:54 <xeno> bt there's ada and rust
03:52:09 <pyon> rhaps0dy: It is more of a mess than I would like, but significantly less than C++.
03:53:09 <pyon> xeno: No, not Ada. Sorry. For resource management, you need at the very least affine types.
03:53:41 <todaystomorrow> If C++ is such a mess why is it still used to heavily
03:54:08 <awruef> it meets everyones needs
03:54:23 <awruef> that is my perspective at least, as a practicing c++ programmer
03:54:28 <awruef> three important benefits
03:54:34 <narendraj9> I really want a lot of applications in Haskell. But when will there be is skeptical.
03:54:50 <xeno> todaystomorrow: you can ask that about most of the crap we use - I have no answer for you
03:54:58 <awruef> 1. lots of people "know" it 2. it is percieved as fast 3. it is perceieved as being easy to interoperate with the mass of existing c++ libraries that do everything
03:55:24 <todaystomorrow> but this isn't true awruef
03:55:32 <awruef> which one isn't true?
03:55:33 <corgifex> #1 is an interesting point
03:55:47 <corgifex> maybe I should look into working as a C++ programmer
03:55:54 <todaystomorrow> all of your points are misnomers people believe
03:55:55 <xeno> todaystomorrow: anyway, C/C++ is used heavily because of things like POSIX
03:55:56 <awruef> corgifex: no save yourself
03:56:06 <rhaps0dy> ^
03:56:11 <rhaps0dy> c++ is painful
03:56:17 <rhaps0dy> that said
03:56:22 <rhaps0dy> it's the language I use most
03:56:26 <awruef> me too :(
03:56:29 <todaystomorrow> yet c++ is what everyone is taught as a beginning language
03:56:38 <corgifex> that was Java
03:56:39 <awruef> really?
03:56:42 <xeno> todaystomorrow: it's so much invested in it, that it could be as crap as... well... even more crap than it is... and people would still not replace it...
03:56:44 <awruef> yeah that was java
03:57:06 <awruef> todaystomorrow: i mean if they're things people believe, that is kind of all that really matters
03:57:10 <DanielDiaz> rhaps0dy: why is C++ painful? (I have never used it)
03:57:12 <awruef> it's not an explanation of scientific truth
03:57:18 <rhaps0dy> DanielDiaz: 2manyfeatures
03:57:27 <corgifex> DanielDiaz: insane complexity, in my experience
03:57:29 <todaystomorrow> that's true awruef
03:57:31 <rhaps0dy> that is good and is bad
03:57:42 <xeno> todaystomorrow: C++ was used as an intro level language in market-oriented colleges 20+ years ago...  criminal, if you ask me...
03:57:42 <rhaps0dy> good because you can make it suit your needs in various ways
03:57:47 <corgifex> people like to complain about perl's syntax but I think C++ is worse
03:57:48 <rhaps0dy> bad because well, everybody uses a different subset
03:58:05 <todaystomorrow> xeno what do you mean by market-oriented colleges? (If I may go off topic)
03:58:13 <rhaps0dy> xeno: in  the engineering uni here they use c++ for everything
03:58:20 <todaystomorrow> that is, are there colleges that are not market-oriented
03:58:20 <rhaps0dy> in my uni they taught C tho
03:58:27 <todaystomorrow> ?
03:58:36 <awruef> todaystomorrow: some colleges care about producing people who think, not people that are ideal employees
03:58:59 * todaystomorrow is a highschool dropout irc
03:59:00 <xeno> some universities/colleges teach languages with the intent that it should be directly useable in your job, and that is a more important quality than the language actually being well suited for teaching...
03:59:01 <todaystomorrow> *irl
03:59:03 <rhaps0dy> xeno: what's your problem with C tho
03:59:22 <rhaps0dy> spaguetti ?
03:59:26 <xeno> no
03:59:40 <corgifex> full of traps for the unwary
03:59:42 <xeno> gotta go now, I'll be back later, can answer then
03:59:49 <rhaps0dy> aight
03:59:56 <rhaps0dy> me sort of gotta go too but I wanted to see the answer
03:59:57 <awruef> c makes you do so much work
03:59:59 <rhaps0dy> corgifex: gotchas ?
04:00:05 <corgifex> yes
04:00:15 <todaystomorrow> But while C++ is not perfect, it's still more widely used
04:00:18 <rhaps0dy> awruef: if you need the low level you need that work to be exposed
04:00:23 <todaystomorrow> than Rust or Haskell
04:00:24 <rhaps0dy> todaystomorrow: yes
04:00:25 <awruef> there is so much you just have to 'know' and get right and your failure is either cryptic compile errors or cryptic runtime errors
04:00:35 <corgifex> awruef: you're lucky if you get errors
04:00:38 <awruef> rhaps0dy: what is 'low level'?
04:00:42 <awruef> corgifex: oh true
04:00:43 <rhaps0dy> awruef: tbh I find haskell's compiler errors much more cryptic
04:00:44 <pyon> corgifex: The subset of C++ that is "good" (read: not too horrible) should be fairly obvious. Keep OO to the bare minimum possible, only use templates for parametric polymorphism (no specializations), and enforce const-correctness vigorously.
04:00:45 <awruef> on a good day you get a crash
04:00:47 <rhaps0dy> awruef: near assembler
04:00:49 <awruef> rhaps0dy: i agree with you
04:00:49 <corgifex> "cryptic compile errors" is the easist thing ever
04:00:50 <todaystomorrow> awruef sounds like haskell ahhaha
04:01:12 <corgifex> pyon: I don't think such a subset exists
04:01:15 <rhaps0dy> > < awruef> on a good day you get a crash
04:01:16 <lambdabot>  <hint>:1:1: parse error on input ‘<’
04:01:17 <rhaps0dy> this is awfully true
04:01:27 <rhaps0dy> like
04:01:32 <rhaps0dy> you WISH for the crashes
04:01:39 <awruef> clang with c++ and java i think score the best on 'least cryptic compile errors'
04:01:57 <rhaps0dy> er really
04:02:00 <awruef> clang will say "insert a '>' here"
04:02:04 <awruef> or "change this . to a ->"
04:02:07 <rhaps0dy> c++ is a bit more cryptic than C
04:02:13 <rhaps0dy> awruef: yes, these are so good
04:02:13 <corgifex> "a bit"
04:02:14 <rhaps0dy> but not much more
04:02:17 <rhaps0dy> corgifex: the errors
04:02:19 <rhaps0dy> in clang
04:02:28 <rhaps0dy> alright gottago
04:02:31 <rhaps0dy> later guys
04:02:36 <corgifex> C++ is the language where you can typo one character and get 2 MB of errors
04:02:39 <awruef> yes
04:02:44 <corgifex> it's very efficient :-)
04:02:45 <awruef> ugh so bad
04:02:57 <awruef> i feel bad picking on it this way though because i have nothing better to recommend
04:03:00 <awruef> in that regard
04:03:14 <awruef> the other language i use more is ocaml
04:03:29 <awruef> it definitely does not fare better in the cryptic errors department
04:03:46 <todaystomorrow> But C++ is still the language I would recommend to someone as a starter language
04:03:50 <todaystomorrow> that or Python
04:04:12 <awruef> cmu started teaching sml as intro
04:04:17 <tdammers> C++ is probably the worst possible starter language
04:04:20 <narendraj9> corgifex: Agree about the errors. :-D
04:04:23 <awruef> i am friends with some tas there, the experiment seems to be working
04:04:30 <awruef> that is exciting
04:04:31 <tdammers> OTOH, if you survive C++, you can tolerate anything
04:04:32 <todaystomorrow> tdammers> why so?
04:04:39 <todaystomorrow> OTOH ?
04:04:47 <tdammers> On The Other Hand
04:04:59 <companion_cube> awruef: apart from some syntax errors, OCaml messages are pretty ok
04:05:03 <tdammers> because C++ is by far the most complex beast of a programming language I've ever seen
04:05:21 <awruef> companion_cube: i guess it's more the nature of functional programming with type inference
04:05:29 <awruef> that leads you to stare at a file and ask "why"
04:05:39 <awruef> "what did i do wrong"
04:05:43 <todaystomorrow> tdammers> but C++ is what someone would have to endure to be a programmer like any other
04:05:53 <corgifex> todaystomorrow: strongly disagree
04:05:59 <awruef> http://cmubash.org/?4114
04:06:14 <todaystomorrow> corgifex> what would they be forced to learn ?
04:06:22 <tdammers> todaystomorrow: if you want to be a master programmer, then I guess some exposure to C++ is kind of required, but that doesn't make it a good first language
04:06:24 <corgifex> todaystomorrow: nothing
04:06:28 <corgifex> there is no good beginner language
04:06:41 <tdammers> there are lots of languages that work well enough
04:06:47 <todaystomorrow> python ?
04:06:52 <corgifex> todaystomorrow: hell no
04:06:56 <tdammers> shell, python, perl, C, javascript, pascal, whatever
04:06:57 <awruef> ugh no
04:06:58 <tdammers> they all suck
04:06:58 <todaystomorrow> hmm why not ?
04:07:02 <tdammers> but that's not the point
04:07:09 <tdammers> you need to learn more languages eventually
04:07:09 <lubuntu_> here, here, doesnt't matter what language you have, first time you are asked to write a recursive function, you're bamboozled regardless
04:07:15 <b_jonas> python or C++ would be my guess for a beginner
04:07:17 <corgifex> todaystomorrow: because I want a language that can find typos in variable names at compile time
04:07:19 <b_jonas> but I'm not sure
04:07:35 <todaystomorrow> corgifex isn't that for you ide to figure out ?
04:07:41 <awruef> clang does that
04:07:41 <tdammers> the point is that someone's first language should be one that sparks the flame without requiring excruciating amounts of work to do anything remotely productive
04:07:45 <corgifex> todaystomorrow: figure out how?
04:07:46 <awruef> it just doesn't fix them for you
04:07:46 <awruef> yet
04:08:02 <tdammers> something that invites exploring and tinkering and rewards people with tangible results
04:08:23 <awruef> time to get on the train
04:08:29 <corgifex> tdammers: "tangible results" can be surprisingly abstract in practice
04:08:43 <corgifex> depends on the student
04:08:47 <tdammers> corgifex: sure sure
04:09:07 <tdammers> but at the novice level, C++ simply requires more concepts and more brainpower than most other languages
04:09:20 <tdammers> imagine a "hello world" in C++, Python, and Haskell
04:09:31 <DanielDiaz> well, Haskell was my first language, and I found it easy to use to solve the problems I could think of in that moment.
04:09:32 <tdammers> explain everything the student sees
04:09:41 <tdammers> and how it relates to the task of printing "Hello, world!"
04:09:43 <corgifex> heh, yeah
04:10:05 <corgifex> that reminds me, I still don't fully understand what python's print actually does
04:10:08 <tdammers> In Python, you get away with string literals, function calls, and explaining how "print" is a built-in function
04:10:40 <tdammers> Haskell, only slightly more concepts - the IO type, mainly, but the student doesn't really have to *understand* monadic IO at this point
04:11:26 <tdammers> C++? #include, headers/source files, namespaces, the cout object, why the left-shift operator is overloaded, how iostreams magically convert types, ....
04:11:48 <corgifex> int main() { ::std::cout << "Hello, world!\n"; }
04:11:57 <tdammers> yes
04:12:03 <corgifex> nah, you wouldn't introduce << as left shift
04:12:25 <tdammers> the point is that << does stream output, but only for streams
04:12:29 <DanielDiaz> after all these years, I still don't see anything special about IO. When I was learning, for me Monad was just a typeclass with a fancy "do-notation" added...
04:12:31 <tdammers> it does left-shift for integers
04:12:42 <tdammers> DanielDiaz: and that's exactly what it is
04:13:07 <DanielDiaz> tdammers: exactly, but people still talk a lot about it, like if it were something more than that.
04:13:23 <tdammers> DanielDiaz: that's because other languages have made them expect magic
04:14:27 <tdammers> DanielDiaz: once your mind has dug its teeth into the idea that IO is inherently imperative, it's hard to convince it to think of IO actions as anything other than stateful statements
04:15:34 <corgifex> https://docs.python.org/2.7/reference/simple_stmts.html#the-print-statement now that's some semantics
04:16:56 <DanielDiaz> tdammers: I guess so. But maybe haskellers also help to this difficulty to continue, when IO is explained like something special. It is, somehow, but not in a way that I would find meaningful for someone learning the language.
04:18:59 <corgifex> > deriv
04:19:01 <lambdabot>  Not in scope: ‘deriv’
04:25:33 <tdammers> DanielDiaz: you're in a luxury position there
04:25:57 <tdammers> most non-Haskellers won't accept "it's not special, it's just what it is" for an explanation
04:26:46 <corgifex> nuk pu nuk
04:38:00 <vise890> hi all. I'm very new to haskell. I'm implementing this->[http://pastebin.com/P47rNpNd] function to remove todos from a list. But I don't know how to handle the case in which many todos to remove are found (I'd like to rise an error, but that causes a type error)
04:46:38 <tdammers> vise890: have you tried using `filter`?
04:47:16 <zgredzik> quick question: if I have a map from string to accelerate arrays, is it possible to make an accelerate array an instance of the Monoid class so that when I try to append a mempty element to the map, an array filled with zeroes is appended that has its size matching to any/all elements in the map?
04:47:21 <tdammers> also, if you want to report failure, there is more than one way - Maybe, Either, exceptions, ...
04:47:50 <tdammers> zgredzik: that would break monoid laws, wouldn't it?
04:48:26 <tdammers> (`mappend` mempty) is supposed a no-op
04:49:20 <vise890> tdammers: yea, but i don't want to traverse the list twice to compute the `removedTodo` and the `newTodoList`.
04:49:52 <zgredzik> tdammers: hmm, makes sense, let me think about it a bit more :D
04:51:20 <vise890> tdammers: and actually i just found that i was being an idiot. here's the updated version if you care http://pastebin.com/WsvSz4Ce
04:51:39 <vise890> tdammers: i was missing the `$` and that was my type error.. <_<
04:51:59 <vise890> tdammers: thanks tho!
04:52:01 <tdammers> eeep
04:52:05 <tdammers> shit happens
04:52:20 <ique> hey people! I’m trying to create some sort of EitherT-like type that allows me to accumulate errors.. has anyone done that before that I can get some help from? more info with sample code: http://stackoverflow.com/questions/23607190/accumulating-errors-with-eithert
04:52:33 <xm0d> Hey guys if i wanted to get into learning Haskell where do you reccomend me starting
04:52:34 <bartavelle> is there a well established type for "non empty list" ?
04:54:08 <tdammers> xm0d: LYAH, RWH... Write Yourself A Scheme if you're brave
04:54:12 <tdammers> @where lyah
04:54:12 <lambdabot> http://www.learnyouahaskell.com/
04:54:14 <tdammers> @where rwh
04:54:15 <lambdabot> http://www.realworldhaskell.org/blog/ http://book.realworldhaskell.org/read/
04:55:02 <Yaniel> is write yourself a scheme somehow like SICP?
04:55:12 <warpy> tdammers: how does lambdabot know about these
04:55:54 <alpounet> warpy: there's a @where+ <label> <content> command
04:55:56 <warpy> Yaniel: no
04:56:07 <warpy> alpounet: ah. nice
05:05:11 <xeno> rhaps0dy: back again
05:05:26 <xeno> rhaps0dy: in a workshop though, so limited opportunity to write stuff...
05:06:22 <xeno> rhaps0dy: but anyway, my problem with C starts with #include, then continues with int. Then I skip main, cause that's fine, int argc is repeated (same as before), then char **argv ... I could go on like that
05:06:47 <xeno> it's easier to list what I am not dissatisfied with
05:07:22 <awruef> i like the idea of listing things we like about C
05:07:35 <awruef> this should be a twitter hashtag campaign
05:08:02 <xeno> there's nothing with it I like, there's just some things here and there that aren't evil all by themselves
05:08:19 <merijn> People who like C don't understand C
05:08:39 <bartavelle> or they work in the security industry
05:08:41 <merijn> No one sane likes C, at best it's a necessary evil that ruins your sanity
05:08:44 <merijn> bartavelle: Even then
05:09:04 <xeno> bartavelle: you mean in the disaster management team, high paid overtime?
05:09:31 <bartavelle> I meant the security researchers, but this works too
05:09:41 <zgredzik> tdammers: if I implemented the mappend action for the Monoid instance as a function adding two accelerate arrays value by value (as in adding matrices together) it should not break the monoid laws, right?
05:09:43 <tdammers> I know a guy who likes C
05:09:50 <xeno> we all knows guys who like C
05:09:55 <xeno> I have no idea what is wrong with the
05:09:57 <xeno> *them
05:10:07 <tdammers> zgredzik: I'm not familiar with accelerate arrays, really
05:10:13 * hackagebot regex-pcre-builtin 0.94.4.8.8.35 - Replaces/Enhances Text.Regex  http://hackage.haskell.org/package/regex-pcre-builtin-0.94.4.8.8.35 (AudreyTang)
05:10:23 <zgredzik> tdammers: ok, ty anyways =)
05:10:50 <tdammers> well, this particular C person writes low-level code to fiddle with network communications at the network level
05:11:11 <danilo2> Hello! I've got a question connected to zgredziks one - Is it possible to define Monoid instance for Repa array? (mappend appends empty array (of zeros) to existing one)
05:12:11 <nclarke> Might get types a bit confused, since repa arrays are length-indexed
05:12:18 <tdammers> well, generally speaking I would say as long as x <> mempty == x holds, you're good
05:12:21 <nclarke> But there may be some clever way of getting around that
05:12:37 <nclarke> :t mappend
05:12:38 <lambdabot> Monoid a => a -> a -> a
05:12:58 <nclarke> tdammers: I'd have thought the problem is more likely to be with the sig
05:13:14 <tdammers> ah right yeah
05:13:37 <tdammers> if you have the length encoded at the type level, you can only have a monoid per individual length
05:13:49 <nclarke> Yeah
05:13:59 <nclarke> Although there may be some clever way of avoiding this :-)
05:14:02 <danilo2> nclarke, tdammers : exactly. I want just to create mempty, which will adjust dimensions to what I mappend
05:14:34 <tdammers> but if the dimensions are part of the type, you can't change them with mappend
05:14:44 <tdammers> a -> a -> a is kind of the essence of a monoid
05:14:46 <nclarke> danilo2: Not quite sure I understand
05:15:09 <nclarke> tdammers: Well, clearly Repa arrays *do* form a monoid
05:15:24 <nclarke> But the type sig for Monoid in Haskell may not be general enough to encompass it
05:15:38 <tdammers> or maybe they form a monoid at the type level
05:16:52 <danilo2> nclarke: I want just to be able to wite "let x = mempty; y=readImage; z = x`mappend`y" , where y has a dimension determined by the "readImage function and I just want it to work.
05:16:52 <ivanm> when using sandboxes with cabal-install, is there any way to run a script in that directory so that it can use the sandbox?
05:18:15 <nclarke> danilo2: Well, you could do that, but it's not a monoid if the only thing you can append is zeros
05:18:48 <_Vi> Can Haskell print each line of the code being executed as in "bash -x"? Like Debug.Trace.trace, but automatically inserted into each line of my source code?
05:20:01 <danilo2> nclarke: I can append another array - any array, but mempty should give zeros
05:20:03 <no-n> !help
05:20:06 <no-n> .help
05:20:14 <no-n> @help
05:20:14 <lambdabot> help <command>. Ask for help for <command>. Try 'list' for all commands
05:20:35 <nclarke> danilo2: How are you defining 'append' here?
05:21:25 <bernalex> trying to figure out the least painful way to refactor this, any ideas? I have a World with a Player and a Computer. I want to turn the Computer into either a Player or a Computer.
05:21:37 <nclarke> I'd forgotten that Repa is multi-dimensional, so it's not clear to me how you manage this (whereas it's clearly find for length-indexed 1d arrays)
05:22:10 <danilo2> nclarke: mappend will be defined something like "zipWith (+) arr1 arr2"
05:22:12 <bernalex> I think doing data Entity = Player | Computer is the simplest way of doing it, really.
05:23:16 <bernalex> but both that and using Either is a lot of refactoring
05:23:20 <nclarke> Ah, okay. Hmm
05:24:01 <bernalex> maybe a type class Entity is the least amount of hassle. hmm.
05:25:09 <danilo2> nclarke: brb
05:29:38 <xeno> tdammers: it's not the C abstraction level which is wrong, just the language
05:29:55 <xeno> tdammers: ..or, well...often the abstraction level is wrong too
05:31:28 <tdammers> if you treat it as a very thin abstraction layer for machine code, it's not that bad
05:32:21 <benzrf> wait
05:32:34 <benzrf> spj works for MS
05:32:35 <benzrf> ?
05:32:50 <timthelion> benzrf:  they all do!
05:33:07 <timthelion> benzrf: >50% of the core devs do
05:33:19 <timthelion> benzrf: which is ironic, given how well haskell works on windows
05:33:24 <benzrf> ;-;
05:33:51 <benzrf> >tfw when those you look up to betray you
05:33:59 <tdammers> MS research isn't really working together that closely with the Windows or Office teams, are they
05:34:17 <timthelion> benzrf: how is it a betrayal?
05:34:32 <benzrf> im being facetious d:
05:34:42 <quchen> tdammers: SPJ's work is directly pulled into the MS Outlook branch, yes.
05:34:58 <benzrf> i dislike ms, like many, but not so strongly that this is a betrayal
05:35:00 <tdammers> ah, that explains a thing or two
05:35:26 <timthelion> tdammers: SPJ is at microsoft in order to create a "culture of intelect and creativity"
05:35:53 <tdammers> timthelion: if they haven't succeeded in doing that by now, then that, too, would explain a thing or two
05:36:34 <nclarke> MRS is a pretty different org from the rest of Microsoft
05:36:38 <nclarke> They do a lot of cool stuff
05:36:46 * timthelion is honestly surprised by the existance of MSR.
05:37:02 <timthelion> nclarke: but how do they make moneyz?
05:37:09 <nclarke> Some of which goes on to be incorporated into MS stuff
05:37:31 <Maior> nodnod
05:37:36 <benzrf> i looked up https://research.microsoft.com/en-us/um/people/simonpj/papers/haskell-retrospective/HaskellRetrospective.pdf
05:37:36 <benzrf> and....comic sans
05:37:36 <benzrf> ¬_¬
05:37:37 <nclarke> For example, TrueSkill (XBox ranking algorithm), Kinect both came out of MSR
05:37:46 <Maior> nclarke: you nearby?
05:38:09 <nclarke> Not to mention the stuff that's come out of F# and gone into C#
05:38:15 <timthelion> nclarke: I'm always surprised though.  Like I thought that the "microsoft interactive table computers" were going to be like a product that they sold, but they just released some videos and a free development kit.
05:38:21 <nclarke> Maior: To MSR? Yeah, I live in Cambridge
05:40:49 <timthelion> nclarke: or the time of day changing wall papers, I thought that microsoft was getting into interier design, and that I would be able to go to the hardware store and get microsoft powered inteligent room lighting, but no, just some demo
05:43:33 <t7> now even your wallpaper can spy on you :D
05:44:16 <uotbw> Hey guys, I'm totally stuck with lens, simple example with Map String <mydata> gives me the error: No instance of At (Map.Map String <mydata>)) any help?
05:44:25 <tdammers> t7: it's not spying, they're just gathering information to enhance your customer experience
05:44:36 <tdammers> t7: and besides, you don't have anything to hide, do you? DO YOU?
05:44:39 <merijn> timthelion: They don't make money
05:44:52 <t7> nothing to hide, nothing to fear right guiz
05:45:02 <t7> ignore those pesky studies that say otherwise
05:45:04 <merijn> timthelion: MSR exists because Bill Gates believe(d/s) in the value of long term research
05:45:19 <supki> uotbw: check if you have multiple versions of containers package installed
05:45:28 <supki> uotbw: ghc-pkg list containers
05:45:36 <uotbw> ok, will try, just a moment
05:45:56 <merijn> timthelion: It's essentially just a MS subsidised high-end research lab and MS occasionally ends up picking up some cool stuff from within there
05:46:03 <tdammers> t7: studies? what studies? there are no studies. Your mind must be playing tricks on you. We've always been at war with Eurasia.
05:46:16 <uotbw> yes, I have to an 0.4.x and an 0.5.x
05:46:24 <uotbw> let me remove the old one
05:46:48 <supki> uotbw: you need to remove the one that didn't come with ghc
05:46:59 <uotbw> ok, understood
05:47:11 <uotbw> that is actually the new one
05:47:15 <uotbw> I remove it
05:47:47 <no-n> uhhh. what's a good name for ((==) `on` length) <*> nub
05:48:32 <supki> uotbw: next step would be to reinstall any packages that broke with --constraint='containers installed'
05:49:15 <vise890> so i'm trying to do something to the contents of a todo file, store the new contents in a temp file and then substitute the original file with the temp file. This is the code [ http://pastebin.com/YmGW2PFe ]. The 1st way works, but it seems ugly. The second doesn't. Anyone has a better way to do this?
05:49:25 <vise890> thanks!
05:49:56 * no-n just names it p
05:50:09 <uotbw> supki: unbelievable, this was about 2 hours and with containers fixed, it is working now, Thanks!
05:50:42 <quchen> no-n: Don't use nub. https://github.com/quchen/articles/blob/master/fbut.md#nub
05:51:12 <arj> can I somehow run something like map f (a,b) i.e. I am looking for a map over a tuple?
05:51:24 <no-n> thanks, quchen
05:51:28 <tdammers> arj: you can't
05:51:35 <arj> tdammers: why is that?
05:51:42 <tdammers> arj: tuple elements are not guaranteed to be of the same type
05:51:42 <quchen> arj: You can't easily map over both components of a tuple (when it has differently typed components).
05:52:12 <tdammers> let a :: Int, b :: String in map f (a, b) -- what should the type of f be?
05:52:30 <arj> Union type? ;-)
05:52:42 <arj> ehm intersection, sorry
05:52:45 <uotbw> supki: I already was about to quit with lens totally, but was a cabal hell issue, ok
05:52:49 <tdammers> arj: coming from Python by any chance?
05:52:53 <arj> nope
05:53:10 <no-n> @src Set.insert
05:53:10 <lambdabot> Source not found. I've seen penguins that can type better than that.
05:53:21 <tdammers> anyway... (a, b) is mostly comparable to Foobar a b
05:53:23 <supki> uotbw: should've asked earlier :)
05:53:33 <uotbw> Yes, you are right!
05:53:36 <tdammers> you can't map over constructor arguments either
05:53:50 <tdammers> if you write it as `(,) a b`, this should be a bit more obvious
05:54:13 <arj> tdammers: so I really have to write two maps even if the types are the same?
05:54:23 <arj> or a zip / map / unzip construct?
05:54:35 <tdammers> arj: pretty much, yes
05:54:41 <arj> ok, thank you!
05:54:49 <quchen> For heterogeneous tuples there's a silly way of mapping over it,
05:54:58 <quchen> > let mapTuple :: (forall a. a -> a) -> (a, b) -> (a, b); mapTuple f (x,y) = (f x, f y) in mapTuple id (1, "hello")
05:54:59 <lambdabot>  (1,"hello")
05:55:10 <quchen> But that allows only the identity as the mapping function.
05:55:35 <tdammers> ...or const undefined :x
05:55:53 <quchen> Go away ⊥ you have no power here
05:56:00 <tdammers> :D
05:56:17 <dwcook> Naming the inner and outer variable the same thing is probably misleading
05:56:49 <quchen> > let mapTuple :: (forall horse. horse -> horse) -> (cake, apple) -> (cake, apple); mapTuple f (x,y) = (f x, f y) in mapTuple id (1, "hello")
05:56:50 <lambdabot>  (1,"hello")
05:56:55 <dwcook> mapTuple :: (forall c. c -> c) -> (a, b) -> (a, b)
05:57:01 <dwcook> \o/
05:57:20 <quchen> O:-)
05:57:43 <dwcook> If I were to complain about these type signatures it would be that they introduce semantic noise for anyone who speaks English. :P
05:58:17 <quchen> let mapTuple :: (forall horse. c -> c) -> (cc, ccc) -> (cc, ccc); mapTuple f (x,y) = (f x, f y) in mapTuple id (1, "hello")
05:58:32 <quchen> We could play this for a long time, let's stop ;-)
05:58:43 <dwcook> Yeah. :P
05:58:48 <quchen> Oh, there's still horse in the last example.
05:59:27 <dwcook> Reminds me of the Functor-Applicative-Monad tutorial that gives them weird names.
05:59:44 <dwcook> Unfortunately I'm not sure it's searchable. :P
05:59:55 <warpy> cant get rid of the horse
06:00:18 <quchen> dwcook: Banana comes to mind. I think I've seen that one as well.
06:00:24 <dwcook> Ah, I think that's it.
06:00:58 <tdammers> > compare "apples" "oranges" -- comes to mind as well
06:00:59 <lambdabot>  LT
06:01:04 <dwcook> Though that still mostly brings up reactive-banana.
06:03:23 <bernalex> hm. I'm getting an odd parse error. I have this function:  ent (Left p)  = Left $ p { Player.Paddle   = p2' }
06:03:39 <bernalex> and just get a parse error on Player
06:04:07 <bernalex> omg
06:04:11 <bernalex> lowercase P in Paddle of course
06:05:04 <tdammers> lol
06:05:47 <xeno> tdammers: I disagree - it's still bad
06:16:34 <no-n> what precedence does `someFunction` have?
06:16:44 <danilo2> Hello! Sorry for asking the same question once again, but does anyone have an idea if is it possible to write Monoid instance for Repa / Accelerate array ?
06:17:11 <nclarke> danilo2: I am trying to write one
06:17:23 <nclarke> I'll post the partial solution I have and see whether anyone can complete it
06:17:36 <nclarke> Or suggest a better way
06:18:02 <supki> > let someFunction = undefined in (0$0 `someFunction`)
06:18:03 <lambdabot>  The operator ‘someFunction’ [infixl 9] of a section
06:18:03 <lambdabot>      must have lower precedence than that of the operand,
06:18:03 <nclarke> http://lpaste.net/104026
06:18:03 <lambdabot>        namely ‘GHC.Base.$’ [infixr 0]
06:18:03 <lambdabot>      in the section: ‘0 $ 0 `someFunction`’
06:18:06 <supki> no-n: ^
06:18:39 <no-n> thanks =)
06:18:48 <nclarke> danilo2: Trying to work out how to write the inductive definition for 'Empty'
06:19:12 <no-n> well, that makes sense as its just like function application with whitespace
06:21:52 <danilo2> nclarke: Thank you, I'll look into it right now! :)
06:22:45 <nclarke> danilo2: The problem is that 'mempty' needs to be polymorphic in its return type
06:25:21 * hackagebot hsdev 0.1.0.1 - Haskell development library and tool with support of autocompletion, symbol info, go to declaration, find references etc.  http://hackage.haskell.org/package/hsdev-0.1.0.1 (AlexandrRuchkin)
06:27:44 <danilo2> nclarke: So the problem in your solution is to write "instance Empty (DIM1 :. Int)"  ?
06:27:48 <osa1> so I was reading the discussion on Twitter about Haskell's Set not being a functor and is there a reason other than can't putting Ord contraint on function argument of fmap to not having Functor instance for Set?
06:28:13 <nclarke> danilo2: Yes
06:29:57 <danilo2> nclarke: I will ask on Accelerate github about it
06:30:49 <nclarke> Crucially, given a Shape b, how to get the size of that shape?
06:34:21 <Feuerbach> osa1: yes, it may violate associativity
06:35:16 <osa1> Feuerbach: I was thinking about an example of that but couldn't find any, do you have any examples in mind that violates associativity? also, how's a set is a functor in CT? do we have a different Functor definition in CT?
06:35:25 <Feuerbach> osa1: fmap ((`div` 2) . (*2)) isn't the same as fmap (`div` 2) . fmap (*2) if you use equality modulo 2
06:37:09 <Feuerbach> the difference between set theory and haskell is that in set theory equal objects must be identical
06:37:17 <Feuerbach> in haskell, you can define any Eq instance
06:37:47 <Feuerbach> there's a requirement for it to be an equivalence relation, but it's too weak
06:41:01 <danilo2> nclarke: https://github.com/AccelerateHS/accelerate/issues/169
06:41:02 <tdammers> it's kind of bad that compare a b == EQ <=> a == b is not enforced, IMO
06:41:02 <Feuerbach> osa1: that said, it *is* possible to create a set functor (and even a monad) in Haskell. See e.g. http://okmij.org/ftp/Haskell/set-monad.html
06:42:12 <Feuerbach> tdammers: that's not an issue here
06:45:35 <td123> I have ghc 7.8 which provides cabal 1.18. I also see that cabal-install came out with a new version that depends on cabal 1.20. Is there any issues with upgrading my cabal-install to 1.20?
06:46:11 <td123> I reallize that it's only a library and it would get statically linked
06:46:19 <nclarke> I would say the problem is modularity. In OCaml, for instance, one could parametrise a whole module over the notion of equality to be used within it. If this is working over a field of two elements, that would be fine, and everything would be hunky-dory.
06:47:54 <merijn> td123: Newer cabal-install work with older GHC just fine
06:49:17 <Feuerbach> nclarke: I don't see how modules can solve this. You still can have functions that are "more precise" than equality
06:49:43 <Feuerbach> assuming equality can be overriden
06:50:03 <td123> merijn: ok, thanks
06:51:28 <nclarke> Feuerbach: You need the module to hide the concrete implementation of the value. Then you can forcibly prevent external functions from being more precise than equality
06:55:27 <Feuerbach> nclarke: you're considering the wrong side of the problem. You can do the same in Haskell using modules or existentials. The point is, when defining the functor instance of Set, you cannot know that "bad" functions don't exist
06:55:45 <Feuerbach> or aren't visible
06:59:14 <aloiscochard> is there something like [Either a b] -> Either [a] [b] ?
07:00:16 <bergmark> aloiscochard: what would that function do if there are both lefts and rights?
07:00:46 <aloiscochard> bergmark: biased to prioritize on accumulating errors (lefts)
07:01:19 <bergmark> the closest thing i can think of is
07:01:25 <bergmark> @type lefts &&& rights
07:01:26 <lambdabot> [Either a b] -> ([a], [b])
07:02:34 <aloiscochard> bergmark: so how do you usually accumulate multipe Either used for error handling?
07:02:58 <aloiscochard> sounds like a common use case to me, maybe I doing it wrong
07:02:59 <nclarke> Feuerbach: In Haskell, a Functor instance is a global dictionary that applies to a type (potentially constrained), and can be added to any operation. The alternative is to have a 'Functor' module which wraps a type and prevents anything leaking
07:04:19 <bergmark> aloiscochard: it depends on what the error means, i guess i usually want to know what failed and what suceeded so i can retry only what i need
07:05:10 <aloiscochard> bergmark: actually that's right, I'm just changing my code because I want to know 'what' failed
07:05:24 <nclarke> Feuerback: But I admit my thoughts here are not fully thought out, so there may be errors in my thinking!
07:05:41 <aloiscochard> bergmark: so nm ;-) I'm surprised tehre is no fancy type class or something for describe such thing though
07:06:14 <Kinnison> aloiscochard: most of my error-producing processing steps are Either [ErrorType] result
07:06:29 <aloiscochard> Kinnison: ha! interesting
07:06:33 <Kinnison> aloiscochard: i.e. either one or more errors were encountered, or a result was produced
07:06:40 <aloiscochard> Kinnison: sure, same here
07:06:48 <Kinnison> never "some errors, and some results"
07:07:00 <bergmark> aloiscochard: you have multiple distinct errors and now you have to decide how you want to handle that case, I don't think there's one abstraction that can handle this
07:07:07 <aloiscochard> Kinnison: but now let say I do two different action, so I have two 'EIther [ErrorType] result' and I want to merge them
07:07:22 <aloiscochard> if result is a Monoid you could even accumulate it like that
07:07:31 <aloiscochard> I mean reduce it in some way
07:07:37 <aloiscochard> but that's probably very specific
07:07:59 <supki> aloiscochard: have you seen validation package?
07:08:07 <supki> sounds similar to what you describe
07:08:31 <aloiscochard> supki: yeah I know the author actually
07:08:36 <aloiscochard> supki: but I thought I would not need it
07:08:50 <aloiscochard> I'll ask Tony opinion directly
07:09:19 <ironChicken> anyone know of any good documents on using the FFI with C functions that return pointers to structs?
07:10:00 <Kinnison> aloiscochard: Looking at this code, I typically take my [Either [ErrorType] result] list and then play with null and lefts
07:10:06 <Kinnison> aloiscochard: The code isn't pretty though :-(
07:10:24 <aloiscochard> Kinnison: ah seen! you want it too ;-)
07:10:52 <Kinnison> ?
07:11:26 <aloiscochard> just a way to say that you would use that function I described
07:11:31 <aloiscochard> if it existed
07:12:02 <aloiscochard> Kinnison: I just check some scala code when I do that, and usually it's just because I can safely don't care about on which elem the error occured
07:12:39 <Kinnison> aloiscochard: Not sure I would use it per-se because of the code structure I had but I think it wouldn't be a bad thing to know how to knock up easily
07:12:52 <Kinnison> This code is full of things like:
07:12:52 <Kinnison>       if ((not . null) $ lefts all_parsed_nodes) then
07:12:53 <Kinnison>         return $ Left $ lefts all_parsed_nodes
07:12:53 <Kinnison>         else stageThree all_yaml_leaves all_parsed_nodes
07:13:10 <aloiscochard> Kinnison: oh I see, interesting
07:13:11 <Kinnison> and I have to say, I wrote it when I was very very new to haskell
07:13:31 <Kinnison> so it's neither good, nor clean, nor necessarily a good idea :-)
07:13:59 <aloiscochard> hehe, it's good to know... ty all, it looks like I should really try to avoid on "what" the error occured anyway
07:14:29 <Kinnison> :-)
07:14:40 <Kinnison> I had a very odd use case which demanded gathering multple errors up
07:14:47 <Kinnison> but it was fun
07:16:04 <Kinnison> http://git.gitano.org.uk/myrosinase.git/tree/lib/Myrosinase/Tree.hs if you want to see hte file in question.  nasty nasty code
07:17:24 <aloiscochard> Kinnison: might be interesting even if nasty, ty!
07:17:50 * Kinnison should rewrite myrosinase really
07:19:28 <Kinnison> If you do look at it, the template language was the fun bit IMO
07:19:40 <Kinnison> Although I'm sure it'll make haskellers shudder
07:19:51 <tdammers> the template language tends to always be the fun bit
07:20:02 <albeit> I need a function of the form (a -> m b) -> [a] -> [b], where the State (=== m b) is updated as it traverses the list. I'm fairly sure I want traverse, but I don't know how to structure the statement. Specifically, where do I provide the initial state?
07:20:16 <Kinnison> tdammers: I desperately didn't want to have to write one, but nothing I could find did what I wanted
07:20:34 <Kinnison> tdammers: namely runtime templates, where the template contained logic for controlling rendering, without depending on libghc
07:22:28 <tdammers> the logic being written in Haskell?
07:23:37 <Kinnison> tdammers: the logic being written in whatever it takes (Mine was a bastard imperative thing which wasn't pretty but was fairly easily understood by my users)
07:24:12 * Kinnison felt that requiring templaters to know haskell might be a bit much considering some of his users
07:24:43 <tdammers> right
07:25:07 <tdammers> I made something a while ago that could compile templates to PHP or JS, as well as run them on the fly
07:25:21 <tdammers> the syntax is a bit like jinja2, but not quite
07:25:37 <tdammers> never really found a use case though
07:26:39 <benzrf>  why do machines have `k t` and `t -> r` instead of `k r`
07:27:05 <Fuuzetsu> Can someone explain why this use of System.Process in so slow to read the data back: http://lpaste.net/104028
07:27:17 <Fuuzetsu> it's instant if I do this from the command line
07:27:39 <Fuuzetsu> the write also seems instant
07:27:49 <Kinnison> Fuuzetsu: Probably something to do with buffering?
07:27:58 * Kinnison is unsure how System.Process sets buffering on the handles it gives back
07:28:18 <benzrf> so does û == uu
07:29:20 <Fuuzetsu> > "û" == "uu"
07:29:22 <lambdabot>  False
07:29:37 <Fuuzetsu> Kinnison: probably, going to play with it a bit
07:29:45 <Kinnison> Fuuzetsu: good luck
07:30:01 <benzrf> Fuuzetsu: ha
07:30:26 <benzrf> Fuuzetsu: i just note that you use Fûzetsu on /g/ iirc
07:30:30 <benzrf> so is uu a replacement for û
07:30:41 <Fuuzetsu> You mean Fūzetsu?
07:30:47 <benzrf> ah.
07:30:51 <benzrf> oops d:
07:31:29 <ciaranm> that's just to tell you how to pronounce it
07:31:33 <Fuuzetsu> It's just a way to romanise ū
07:31:40 <benzrf> kk
07:32:12 <Fuuzetsu> (and yes it does mean a longer ‘u’)
07:32:16 <ciaranm> it's a long constipated uuuuoooooouuuuuuuu, rather than an uh
07:32:42 <ciaranm> disclaimer: my japanese teacher at school had a very strong irish accent
07:32:49 <FireFly> Haha
07:33:05 <FireFly> I want to hear irish japanese now
07:33:20 <ciaranm> also irish german and irish french...
07:33:42 <ciaranm> was hard enough understanding her english
07:33:59 <tdammers> righsh
07:40:05 <albeit> I need to insert a map with m new values, and I need to know if any of those new values improved the old values (based on f new old -> Bool). Right now I'm doing a lot of insertLookupWithKey, and it is the slowest part of the program. Is there a better way?
07:41:52 <albeit> (Or maybe a different data structure?)
07:42:48 <benzrf> oooooooohhhhhhhhhhhhhhhhhhhhhhhhhhhh
07:42:51 <benzrf> i get it!
07:43:12 <benzrf> k does not need to contain a t, it can be used just to restrain the type
07:43:17 <benzrf> or other weird trickery
07:46:24 <sykora> albeit: Perhaps a combination of `differenceWith` to find changes and `unionWith` to incorporate them?
07:48:23 <Maior> a
07:48:33 <albeit> sykora: Was looking at that, but it has performance O(n+m), whereas a bunch of insertLookups is O(log(n)*m). n ~ 60, m ~10
07:49:16 <sykora> You'll need 2(m + n), since you need one pass for the difference and another for the union.
07:49:43 <albeit> The map never changes size... and I need constant retrieval and insertion... hmm
07:52:26 <albeit> Looking through the containers package, but I can't find anything that has a constant retrieval and insertion. Does anything like that exist?
07:52:37 <benzrf> albeit: isn't that what a hash map is
07:52:42 <benzrf> [once amortized]
07:53:16 <benzrf> hmmm, has anybody written a type-level y combinator
07:53:17 <benzrf> :O
07:53:32 <benzrf> i see type synonyms used for recursive types and wonder o:
07:53:55 <corgifex> newtype Mu t = Mu (t (Mu t))
07:54:33 <sykora> albeit: Try the unordered-containers package.
07:54:33 <albeit> benzrf: HashMap.Map has lookups O(min(n, 32 or 64))... so I don't think it is better
07:54:34 <benzrf> hmmmmmm
07:54:45 <benzrf> albeit: how strange
07:54:52 <corgifex> that's O(1)
07:55:00 <benzrf> is there a c-implemented hashmap you can import
07:55:04 <benzrf> that works over ffi
07:55:25 <benzrf> type Mu t = t (Mu t), perhaps?
07:55:37 <benzrf> @let type Mu t = t (Mu t)
07:55:38 <lambdabot>  .L.hs:125:29:
07:55:38 <lambdabot>      Ambiguous occurrence ‘Mu’
07:55:38 <lambdabot>      It could refer to either ‘L.Mu’, defined at .L.hs:142:1
07:55:38 <lambdabot>                            or ‘Lambdabot.Plugin.Haskell.Eval.Trusted.Mu’,
07:55:38 <lambdabot>                               imported from ‘Lambdabot.Plugin.Haskell.Eval.Tr...
07:55:39 * hackagebot tamper 0.1.0.0 - An HTML templating system similar to Blaze, implemented as a monad transformer of sorts  http://hackage.haskell.org/package/tamper-0.1.0.0 (TobiasDammers)
07:55:40 <benzrf> o:
07:55:42 <benzrf> oops
07:55:45 <benzrf> -.-
07:56:05 <benzrf> > undefined :: L.Mu []
07:56:07 <lambdabot>  Not in scope: type constructor or class ‘L.Mu’
07:56:09 <benzrf> lame
07:56:16 <corgifex> > undefined :: Mu []
07:56:17 <lambdabot>  In {out = *Exception: Prelude.undefined
07:56:24 <benzrf> o:
07:57:15 <corgifex> there we go
07:57:25 <corgifex> > In []
07:57:26 <lambdabot>  In {out = []}
07:57:52 <c_wraith> albeit: there's no such thing as a key/value lookup with constant time lookup/insert in the real world - unless you bound the key set. And if you do that, nearly every data structure is trivially O(1)
07:57:54 <corgifex> :t In Nothing
07:57:55 <lambdabot> Mu Maybe
07:58:18 <benzrf> :t In
07:58:19 <lambdabot> f (Mu f) -> Mu f
07:58:24 <benzrf> wuh
07:58:27 <albeit> c_wraith: What does "bound the key set" mean? The size of the map, and the possible keys, is fixed in my instance.
07:58:45 <albeit> Thinking maybe IntMap or something based off that may be best.
07:58:48 <c_wraith> Heck, an association list is O(1) lookup for any bounded set of keys, assuming you don't insert duplicates.
07:58:49 <benzrf> > In [1]
07:58:50 <lambdabot>  No instance for (GHC.Num.Num
07:58:50 <lambdabot>                     (Lambdabot.Plugin.Haskell.Eval.Trusted.Mu []))
07:58:50 <lambdabot>    arising from the literal ‘1’
07:58:51 <benzrf> aha i see
07:59:00 <corgifex> newtype Mu f = In { out :: f (Mu f) }
07:59:01 <benzrf> so In can only hold 'empty' values
07:59:10 <benzrf> wait no
07:59:14 <corgifex> > In [In [], In []]
07:59:15 <lambdabot>  In {out = [In {out = []},In {out = []}]}
07:59:22 <benzrf> or rather
07:59:34 <benzrf> a Mu value can either be empty, or hold more Mu
07:59:47 <c_wraith> that's true of Mu Maybe
07:59:50 <corgifex> > fix (In . Identity)
07:59:52 <lambdabot>  In {out = Identity {runIdentity = In {out = Identity {runIdentity = In {out ...
07:59:54 <benzrf> o_O
07:59:58 <benzrf> well
08:00:10 <benzrf> that's still basically true d:
08:00:11 <c_wraith> consider Mu (Either a)
08:00:14 <benzrf> oh hm
08:00:22 <albeit> c_wraith: How do I bound the set of keys?
08:00:38 <benzrf> well it can only hold infinitely polymorphic types
08:00:40 * hackagebot postgresql-libpq 0.9.0.1 - low-level binding to libpq  http://hackage.haskell.org/package/postgresql-libpq-0.9.0.1 (LeonSmith)
08:00:42 * hackagebot web-browser-in-haskell 1.0 - Web Browser In Haskell  http://hackage.haskell.org/package/web-browser-in-haskell-1.0 (AkashJagdhane)
08:00:43 <benzrf> which for (* -> *) is empty, right?
08:00:58 <c_wraith> > In (Left 37)
08:00:59 <lambdabot>  In {out = Left 37}
08:01:19 <c_wraith> > In (Right (In (Left "hello")))
08:01:20 <lambdabot>  In {out = Right (In {out = Left "hello"})}
08:01:22 <corgifex> :t In (Left "hi")
08:01:23 <lambdabot> Mu (Either [Char])
08:01:40 <benzrf> given a value whose type's kind is (* -> *)
08:01:46 <corgifex> impossible
08:01:52 <benzrf> wait oop
08:01:53 <benzrf> >.<
08:02:00 <benzrf> whose type's constructor's kidn
08:02:00 <benzrf> :P
08:02:02 <benzrf> *kind
08:02:11 <corgifex> ?
08:02:13 <benzrf> if the type of that value is polymorphic, it must be empty, right?
08:02:17 <benzrf> i.e.
08:02:19 <c_wraith> Mu (Either a) is approximately isomorphic to (Nat, a)
08:02:22 <corgifex> @kind Either String
08:02:22 <lambdabot> * -> *
08:02:30 <benzrf> the type of Nothing is Maybe a
08:02:33 <benzrf> the constructor here is Maybe
08:02:35 <benzrf> which has kind * -> *
08:02:36 <cschneid> :t fix
08:02:37 <lambdabot> (a -> a) -> a
08:02:52 <corgifex> > () :: Const
08:02:54 <lambdabot>  Expecting two more arguments to ‘Control.Applicative.Const’
08:02:54 <lambdabot>  Expected a type,
08:02:54 <lambdabot>    but ‘Control.Applicative.Const’ has kind ‘* -> * -> *’
08:02:57 <corgifex> nice
08:03:04 <benzrf> anyway
08:03:07 <c_wraith> Which implies....  Mu (Either a) is approximately isomorphic to Free Maybe a
08:03:15 <benzrf> gluh
08:03:17 <benzrf> my brain is mush
08:03:19 <benzrf> >.
08:03:33 <benzrf> i am starting to understand machines, leave me be!
08:04:02 <Fuuzetsu> Kinnison: I have solved it by closing the in-handle followed by seq'ing the length of the output, see café if you're interested I guess.
08:04:05 <c_wraith> albeit: IntMap is a fine choice of data structure.  I was making a more technical point, which is that anyone who claims hash maps are O(1) is lying.
08:04:07 <corgifex> :t In (Const "hi")
08:04:08 <lambdabot> Mu (Const [Char])
08:04:14 <Kinnison> Fuuzetsu: :-)
08:05:06 * Fuuzetsu curses lazy IO
08:05:18 <c_wraith> Fuuzetsu: I thought it was already cursed.
08:05:27 <Fuuzetsu> I will triple curse it
08:05:38 <Fuuzetsu> when will I ever learn to just go straight for conduit or pipes or something
08:07:21 <yitz> c_wraith: what does "approximately isomorphic" mean?
08:07:29 <c_wraith> yitz: it means I'm ignoring bottoms
08:07:34 <yitz> oh ok
08:07:54 <yitz> @type In
08:07:55 <lambdabot> f (Mu f) -> Mu f
08:08:13 <yitz> @type Mu
08:08:14 <lambdabot> Not in scope: data constructor ‘Mu’
08:08:35 <corgifex> :t out
08:08:36 <lambdabot> Mu f -> f (Mu f)
08:10:41 * hackagebot data-lens-light 0.1.1 - Simple lenses, minimum dependencies  http://hackage.haskell.org/package/data-lens-light-0.1.1 (RomanCheplyaka)
08:26:50 <benzrf> hmmmmmm
08:26:53 <benzrf> im looking at machineslearn
08:26:55 <benzrf> *machines
08:27:02 <benzrf> and i understand the usage of the k type parameter
08:27:21 <benzrf> this is a little confusing to me tho...
08:27:33 <benzrf> if you make a Tee machineslearn
08:27:41 <benzrf> *machine
08:28:11 <benzrf> and you mismatch the type of the input-taker function with the L/R
08:28:17 <benzrf> it will show a type error.
08:28:21 <benzrf> but if you line it up right
08:28:39 <benzrf> it doesnt seem to figure out the more specific type of the function?
08:28:54 <benzrf> oh god ive been spamming like crazy, i need to kill this habit
08:30:44 * hackagebot uzbl-with-source 0.1.0.0 - Utility function for reading a source of loaded uzbl pages.  http://hackage.haskell.org/package/uzbl-with-source-0.1.0.0 (MateuszKowalczyk)
08:39:52 <Denommus> how does a type with kind * -> * -> * look like?
08:40:08 <shachaf> Either is an example.
08:40:26 <Fuuzetsu> data T a b = …
08:41:24 <nexx> btw is this called a type constructor constructor?
08:41:50 <Denommus> what about (* -> *) -> *?
08:42:01 <Denommus> (T a) b?
08:42:22 <corgifex> T a
08:42:28 <corgifex> where a :: * -> *
08:42:40 <Denommus> corgifex: oh, it makes sense
08:43:17 <Fuuzetsu> :k StateT
08:43:18 <lambdabot> * -> (* -> *) -> * -> *
08:43:50 <shachaf> You don't know what kind "data T a b = ..." has. Only that T :: k -> j -> *, for some kinds j and k.
08:44:29 <Fuuzetsu> Ah, of course, inaccuracy on my part
08:44:42 <corgifex> data T a = C (a Int)
08:44:50 <Denommus> shachaf: oh
08:46:31 <S3thc0n> Could anyone here point my to IRCs or mailing lists which deal with languages or type theory even closer to mathematics than Haskell, but which are still somewhat understandable for a dummie like me?
08:47:07 <jdiez> I'm confused by the Maybe's >>= function
08:47:09 <jdiez> Nothing >>= f = Nothing
08:47:09 <jdiez>     Just x >>= f  = f x
08:47:20 <nexx> S3thc0n which are not understandable by a dummie?
08:47:20 <jonsterling> augur: Alas, the weekend's over now and I don't have time to argue about Type Theory on IRC… But if you want to send me an email, we can try to talk about it asynchronously :) (jon [at] jonmsterling [dot] com)
08:47:21 <ssd> I have a question regarding purely functional data structures. How would they help with concurrent modification. If two threads simultaneously try to add a node to a purely functional red-black tree, two copies of the tree will be created. But how will this help? Each thread is going to see only their change and not the other thread's change.
08:47:25 <jdiez> I understand that the result of Nothing >>= f = Nothing
08:47:29 <jdiez> because Nothing is a constructor of Maybe
08:47:38 <jdiez> but how can it be that Just x >>= f = f x ?
08:47:43 <jdiez> shouldn't it be Just $ f x ?
08:47:51 <mmachenry> S3thc0n: If you're looking for an arguably more advanced type system chck out Agda.
08:48:02 <Denommus> jdiez: if the first paremeter is a nothing, it should eval to a nothing. If it isn't, it should eval the next function
08:48:10 <quchen> jdiez: What's the type of "f" in "Just x >>= f"?
08:48:19 <mmachenry> S3thc0n: It's a dependently typed language. Not sure what "closer to math" really means though.
08:48:22 <jdiez> quchen: (a -> m b)
08:48:23 <jdiez> oh
08:48:24 <jdiez> ..
08:48:25 <jdiez> I see
08:48:25 <nexx> jdiez what is the type of f?
08:48:25 <jdiez> thanks
08:48:28 <jdiez> got it
08:48:28 <quchen> jdiez: :-)
08:48:46 <S3thc0n> mmachenry: Thank you! I'm not really sure either^^
08:49:20 <vamega> Hi.
08:49:33 <benzrf> jdiez: don't confuse functors with monads :o
08:49:37 <benzrf> i did that a lot, starting out
08:49:43 <vamega> Is it possible to parallel install a version of GHC separate from the one that comes with my OS?
08:49:50 <benzrf> jdiez: it may be easier to think about Join
08:49:53 <benzrf> *join
08:49:57 <vamega> I'm using fedora 19, and it ships with GHC 7.4
08:49:59 <jdiez> benzrf: I don't think I did, I was just confused about the return type
08:50:10 <benzrf> jdiez: yes, you were thinking of fmap instead of bind
08:50:11 <benzrf> :)
08:50:14 <vamega> I'd like to move up to 7.8, but I'd prefer to not reinstall the rest of my OS just yet.
08:50:44 <jdiez> well, I wouldn't be surprised
08:50:49 <jdiez> there are so many concepts to learn :)
08:51:01 <benzrf> jdiez: wait, have you learned functors yet
08:51:05 <jdiez> yes
08:51:09 <benzrf> kk
08:51:15 <Denommus> jdiez: what about applicative functors?
08:51:21 <nexx> I wouldn't call that confusing functors with monads
08:51:22 <jdiez> I've learned about those too
08:51:27 <ssd> can someone please clarify my doubt?
08:51:34 <S3thc0n> ssd: That is a common point that comes up and I'm not 100% sure I have grasped it myself, but I think you usually avoid such constructs. Pure functions, as they are in Haskell, cannot have any data modified 'under their feet' by another thread.
08:51:40 <jdiez> tbh I don't think I was confusing bind with fmap
08:51:43 <benzrf> jdiez: i find that one useful way of thinking about it is
08:51:53 <jdiez> I just thought that maybe you could do 1 :: Maybe Int, but it's just that I didn't realise the type of f
08:52:15 <benzrf> jdiez: an applicative extends a functor with the ability to merge 2 functor values into 1
08:52:26 <benzrf> where the 'internal values' are combined somehow, while the structures are also merge
08:52:29 <benzrf> *merged
08:52:38 <Denommus> jdiez: you'll usually use "pure" or "return" to convert a type to a monadic type
08:53:04 <ssd> S3thc0n: But that would mean there is no concurrency then!!
08:53:16 <benzrf> on the other hand, a monad extends a functor with the ability to take a functor value whose 'internal value' is another functor value of the same type, and merge their structures together into a non-nested functor value
08:53:22 <Denommus> jdiez: (they're the same function, but "return" is more common because Monad is older than Applicative)
08:53:25 <jdiez> benzrf: I think I have a good intuition of applicatives and monads
08:53:30 <benzrf> kk
08:53:49 <benzrf> do you see why monads are more powerful than apps.
08:53:53 <benzrf> *app.s
08:53:57 <jdiez> app.s ?
08:54:05 <nclarke> app.hs ?
08:54:10 <Denommus> jdiez: applicatives
08:54:19 <benzrf> applicative -> app.
08:54:25 <benzrf> . for abbrev
08:54:33 <jdiez> yeah, because you can feed the previous result into an intermediate step
08:54:39 <jdiez> which you can't do with applicatives
08:54:44 <Denommus> every monad is an applicative, but with some additional operations
08:54:46 <jdiez> right?
08:55:17 <benzrf> jdiez: because with an applicative, you can only join two values you already have
08:55:28 <Denommus> (or, at least, it should be, once Monad is a subclass of Applicative)
08:55:33 <S3thc0n> ssd: Concurrency in the sense of execution interleaving and >affecting each other<, right. But there still is a lot you can do concurrently independently form each other. Imagine maybe a thread building an index and one doing searches. You would start the search anew with a different index every time I guess, instead of leaving the search thread running.
08:55:35 <benzrf> while with a monad, you can merge a value you don't have yet, that is inside the other one
08:55:47 * hackagebot irc 0.6.0.1 - A small library for parsing IRC messages.  http://hackage.haskell.org/package/irc-0.6.0.1 (TrevorElliott)
08:55:49 <jdiez> benzrf: yeah
08:55:56 <benzrf> you can even simulate app.s from monads by sticking the outer value into another one, then joining
08:56:00 <benzrf> but you can't do the reverse
08:56:45 <nexx> I wouldn't call that "simulate"
08:57:28 <S3thc0n> ssd: I'm a newcomer to purely functional programming myself, so what I say is absolutely not definite, and I do have a little bit of the same concerns as you do. If you want newly found entries to be found after the search as started, you might have a problem. (Of course everything could be modeled as mutable with IO, but I do not think that's the point of programming in Haskell ;))
08:59:26 <S3thc0n> Try asking again somewhat later, surely you'll get ahold of someone who can help you out there. You could also try posting somewhere. But don't give up ;D (And share your findings with me)
09:01:36 <srhb> ssd, S3thc0n: There are a lot of higher level constructs for synchronization, like TVars, say.
09:02:47 <srhb> ssd, S3thc0n: And we can still use "pure" functions, just like we can use length <$> IO String, etc.
09:02:49 <ssd> srhb: I am a new comer to Haskell. Are Tvars something like locks?
09:03:01 <srhb> ssd: It's basically a shared mutable state.
09:03:25 <carter> not really
09:03:26 <carter> transactional shared state
09:03:27 <carter> being a key detail
09:03:59 <srhb> Right, I suppose that makes the atomicity apparent.
09:04:03 <mmachenry> ssd: It's a box into which you can put any value and it can be locked and changed within a software transactional memory transaction (which Haskell models with the STM monad)
09:04:06 <S3thc0n> srhb: RIght, I remember running across those. Is that the currently agreed upon solution? Seems kind of like how Clojure approaches it.
09:04:20 <srhb> S3thc0n: There are a lot of different and interesting solutions for different use cases.
09:04:51 <srhb> S3thc0n: It's a question that's not easily answerable in the general state. Suffice to say we have a lot of tools at our disposal, and I personally think Haskell excells in this area more than almost anyone else.
09:05:22 <srhb> Or what I really want to say is: Trust me, purity is not causing problems here (quite the contrary)
09:05:25 <srhb> :)
09:05:41 <ReinH> Simon Marlowe wrote a great, free book about parallel and concurrent Haskell
09:05:49 <ReinH> Marlow
09:05:54 <carter> clojsure does it more confusingly
09:05:58 <ssd> srhb: Say I have a list or red black tree and I want keep adding to that from two threads. Are Tvars one of the ways to do this?
09:06:05 <srhb> @where Parallel and Concurrent Programming in Haskell
09:06:06 <lambdabot> http://www.haskell.org/haskellwiki/Parallel
09:06:10 <srhb> hrmf
09:06:12 <carter> ssd: dpeends
09:06:18 <carter> ssd: whats the actual goal
09:06:18 <srhb> http://chimera.labs.oreilly.com/books/1230000000929
09:06:27 <carter> SO a *key* thing when dealing with concurrenctly
09:06:29 <carter> *concurrency
09:06:33 <carter> is "whats the big picture"
09:06:37 <S3thc0n> srhb: I am aware and agree that Haskell is a very fine imperatiev language, too. I was just hoping for something feeling more functional ;D
09:06:43 <k00mi> ssd: yes, you can do that with TVars
09:06:50 <carter> you can't reason "locally" in a concurrent setting
09:06:56 <BeardedCoder> Anyone gotten ghc-mod and haskell-interactive-mode working together in Emacs?
09:07:06 <srhb> S3thc0n: Oh trust me, it can feel quite functional still. You might have a few imperative feeling bits dealing with locking etc.
09:07:39 <srhb> I think the issues are largely orthogonal though.
09:08:49 <ssd> carter: It is just a hypothetical question. I know how to do this in C#, Java. You take a lock or use a synchronized method and do whatever you want to. I was just wondering how this is done in Haskell
09:09:00 <carter> theres several ways
09:09:19 <carter> ssd: for anything centralized, if its high contention, you wind up wanting something like MVar
09:09:29 <carter> for decentralized, low contention, you probably want STM
09:09:35 <ReinH> Seriously, read the book :) it's free, it's written by the (former) maintainer of GHC's runtime system, it explains all of this stuff.
09:09:38 <carter> yes
09:09:45 <carter> ReinH: he's still writing some patches
09:09:46 <carter> :)
09:10:02 <joseph07> ReinH: Sorry latecomer, what book?
09:10:08 <ReinH> I know :) I did interview him remember :p
09:10:11 <ReinH> Juju
09:10:15 <carter> @google simon marlow parallle and concurrent haskell
09:10:16 <lambdabot> http://chimera.labs.oreilly.com/books/1230000000929
09:10:16 <lambdabot> Title: Parallel and Concurrent Programming in Haskell
09:10:17 <ReinH> Whoops
09:10:22 <carter> that gook
09:10:22 <carminemlt> Hi everyone! I've a problem with the code you may see at http://lpaste.net/104030
09:10:24 <carter> *book
09:10:25 <ReinH> That one
09:10:59 <carter> ReinH: i've leveled up, i've technically written \infinity distinct vector/mvector instances in the past month
09:11:08 <joseph07> carter, ReinH: thanks
09:11:26 <ReinH> carter: :p
09:11:28 <carter> joys of defining unboxed/storable vector instances for a type
09:11:34 <srhb> carminemlt: tell has which type?
09:11:37 <carter> that has static size
09:11:39 <ssd> So, is lambdabot written in Haskell :)? And if so is the source freely available?
09:11:45 <srhb> carminemlt: (Hint: Your then and else clauses don't have the same type)
09:11:46 <carminemlt> shrb: m ()
09:12:03 <quchen> ssd: https://github.com/mokus0/lambdabot/
09:12:43 <ssd> quchen: oh great. Thanks
09:13:01 <Redz> :i (.:)
09:13:33 <c_wraith> @version
09:13:33 <lambdabot> lambdabot 5.0-int-e
09:13:33 <lambdabot> git clone git://github.com/int-e/lambdabot.git
09:14:00 <c_wraith> in case there are any differences in that fork
09:14:04 <ReinH> Redz: it isn't standard but it's usually defined as (.).(.) or fmap fmap fmap
09:14:45 <carter> :t fmap fmap fmap
09:14:46 <lambdabot> (Functor f1, Functor f) => (a -> b) -> f (f1 a) -> f (f1 b)
09:14:56 <srhb> carminemlt: Ugh, didn't see your comment at the end. What do you expect mplus to do here?
09:16:07 <carminemlt> srhb: well what I would like to accomplish is to have the [[Int]] representing all possible paths between given edgese of the graph, stored in the Writer. I was trying to translate the code from the book which uses a simple Writer
09:16:18 <shachaf> If you're talking to someone who isn't specifically looking for something confusing and you say "fmap fmap fmap" (rather than, say, fmap . fmap), then it's difficult to conclude that you're trying to be helpful.
09:16:19 <Redz> thanks. i'm sure there is an package/module where its defined. because i dont want to carry an own lib of helper functions.
09:16:30 <carminemlt> srhb: mplus should concat the lists
09:16:49 <srhb> carminemlt: So you're asking how to have the recursive call return a list?
09:17:06 <srhb> carminemlt: You're not using Writer the right way, if this is what you're trying to do with it.
09:18:09 <carminemlt> srhb: surely you're right. I'm having quite an hard time trying to wrap my head around transformers
09:18:29 <srhb> carminemlt: I doubt that the transformer part is what is causing you trouble :)
09:18:55 <carminemlt> srhb: Oh! :)
09:20:00 <carminemlt> srhb: care to elaborate?
09:20:26 <srhb> carminemlt: Well your problem is about simple recursion right now, right? Ie. how to match the types such that you can construct the entire value with recursive calls.
09:20:49 * hackagebot hath 0.2.0 - Hath manipulates network blocks in CIDR notation.  http://hackage.haskell.org/package/hath-0.2.0 (MichaelOrlitzky)
09:21:12 <carminemlt> srhb: yes, I think it is
09:21:33 <srhb> carminemlt: and tell [start] `mplus` e_paths /= tell (start `mplus` e_paths)
09:22:05 <yesthisisuser> Is there, or would it be a bad idea to have a language extension which would make string representation format conversions (pack, unpack, encode, decode etc.) implicit?
09:22:26 <yesthisisuser> Beyond what OverloadedStrings is already doing, that is.
09:22:35 <carminemlt> srhb: precedence issue?
09:22:49 <srhb> carminemlt: Function application always binds tightest
09:23:31 <ReinH> yesthisisuser: Haskell doesn't do "implicit" coercions (aside from unsafeCooerce)
09:24:04 <yesthisisuser> Reinh: right, i guess that is what it would be
09:24:14 <carminemlt> srhb: if I remove the () I get another kind of mouthful from GHCI
09:24:22 <ReinH> So no :)
09:24:25 <srhb> carminemlt: It will probably be a more relevant mouthful.
09:25:17 <yesthisisuser> ReinH: but what is the long-term solution.. Text becoming standard String format
09:25:50 * hackagebot highlighting-kate 0.5.8 - Syntax highlighting  http://hackage.haskell.org/package/highlighting-kate-0.5.8 (JohnMacFarlane)
09:26:00 <ReinH> Which problem are you wanting a solution for?
09:26:15 <srhb> carminemlt: Basically drop your type signature and think really hard until you understand why the new, inferred signature works. :-)
09:26:26 <yesthisisuser> syntactic "clarity" .. :)
09:26:49 <yesthisisuser> or simplicity.. having a lot of different formats being used is confusing, at least
09:26:50 <ReinH> Hmmm. What is unclear?
09:28:12 <carminemlt> srhb: Imposing the constraint of MonadPlus over m, allows for the mplus to be possible, and this makes GHCI happy
09:28:27 <srhb> carminemlt: Indeed. :)
09:28:37 <carminemlt> srhb: The code, tough does not work :(
09:28:45 <yesthisisuser> i personally don't find it so confusing.. but it makes the code less "clean" i guess
09:28:48 <ironChicken> anyone know of any good documents on using the FFI with C functions that return pointers to structs?
09:29:03 <srhb> carminemlt: How so?
09:29:45 <carminemlt> srhb: if I call it via: execWriter (runReaderT (paths'' 2013 2058) graph1) where graph1 :: [(Int,Int)]
09:30:05 <ReinH> It being what again?
09:30:54 <carminemlt> srhb: I get a "couldn't match type [(Int,Int)] with (Int,Int) when using functional  dependencies to combine MonadReader r (ReaderT r m), ..."
09:32:38 <nclarke> ironChicken: http://www.haskell.org/haskellwiki/FFI_cook_book#Working_with_structs
09:33:01 <yesthisisuser> ReinH: i think what i am trying to say is that it would be nice to be able to write code in a way independent of which string representation form is being used..
09:33:57 <ReinH> I haven't used classy prelude but it might help with that
09:35:25 <srhb> carminemlt: If you want to take advantage of runReaderT and friends, you do need to use transformers instead.
09:36:52 <ironChicken> nclarke: ty, yes, i've seen that one. um, i think what i'm looking for is probably an example of a foreign function prototype that returns a pointer to a struct and an example of its use
09:37:41 <nclarke> ironChicken: Here's one from some of my code: https://github.com/nc6/tabula/blob/master/Tabula/TTY/Foreign.hsc
09:39:03 <enthropy> nclarke, ironChicken seems like that was written before hsc2hs got (#peek structName, fieldName)
09:39:29 <nclarke> enthropy: Quite possibly. Has hsc2hs got some new goodies? :-)
09:40:57 <carminemlt> srhb: Following what the book says, that code should be general enough to be used by transformers.
09:41:01 <ironChicken> nclarke: thanks
09:41:11 <srhb> carminemlt: hm, you're probably right.
09:41:43 <nclarke> ironChicken: This uses the ioctl package (http://hackage.haskell.org/package/ioctl)
09:42:27 <srhb> carminemlt: Oh, hang on, you're ask'ing for a tuple but the Reader info is a list of tuples, no?
09:42:39 <carminemlt> srhb: yes
09:42:52 <bos> i have a terribly hard time understanding the docs for type families.
09:43:02 <srhb> carminemlt: There you have it then. You need to figure out what you want to happen in the ask line
09:43:37 <carminemlt> srhb: I thought that line would use the list monad semantics and fetch each tuple from the list. Isn't that so?
09:44:01 <srhb> carminemlt: What is the type of e_paths again?
09:45:00 <carminemlt> srhb: m ()
09:51:42 <srhb> carminemlt: I'm lost, sorry. I'm not used to using MonadWriter and MonadReader directly like this
09:52:19 <carminemlt> srhb: No problems. I can only thank  you for your patience and kind help.
09:53:20 <albeit> Based on changing a single flag (onlyA), my program either uses tons of memory (when onlyA==True), or uses constant memory. How can one line do that... "best = if onlyA then (getSide groupA k) else (getBestSide (getSide groupA k) (getSide groupB k))"
09:53:39 <carminemlt> srhb: from what I know, ask should have returned the [(Int,Int)] and the "<-" in the do should have done the rest using the [] semantics. At least that's what the book has been leveraging up to that point.
09:53:44 <albeit> The "simpler clause" is even the one that consumes tons of memory
09:53:54 <srhb> carminemlt: Yes, I agree with you. Which is why I'm a bit lost. :)
09:55:22 <carminemlt> srhb: :) If I replace the MonadReader (Int,Int) with what I thought was the correct option [(Int,Int)] the code doesn't compile anymore, hinting at the "ask" line
09:55:50 <tremon> albeit: getBestSide looks like a filter, in the sense that it discards almost all of its input after processing?
09:56:23 <albeit> tremon: Yes it returns either of the two options, after comparing them.
09:56:49 <carminemlt> srhb: which I can understand because "m" should be the []
09:56:56 <srhb> carminemlt: Indeed.
09:58:13 <tremon> albeit: does it return its full argument or a subset of getSide [..]? I had expected it to return less than just the result of getSide
09:58:23 <srhb> carminemlt: I think it ends up being in the identity monad, which is confusing.
09:58:47 <srhb> carminemlt: Scratch that. I'm not sure. Someone smarter should look at this. :)
09:58:55 <albeit> It returns a full "side", edge in the real code. Here is that function: http://lpaste.net/104041
10:00:14 <ghorn_> is it possible for cabal install to check LD_LIBRARY_PATH  for C libraries? I'm getting the "missing C libraries" error but i expect my users to have libraries in a non-standard place, and I don't know if I should burden them with using a configuration option
10:00:29 <rwbarton> most likely the unevaluated (getSide groupA k) retains a reference to some large structure
10:01:19 <Javran> I want to write some HUnit tests for an executable cabal project, I want to place tests under "tests/" directory but still able to recognize module imports from "src/" directory, is this possible?
10:01:48 <ghorn_> Javran: yes it is, but you might have trouble getting ghci to play nicely
10:02:25 <carminemlt> srhb: maybe I should try contacting the book's author and see what's is thoughts are?
10:02:30 <ghorn_> Javran: I do it here https://github.com/ghorn/dynobud/blob/master/dynobud.cabal but maybe there are other, cleaner examples
10:02:31 <Javran> ghorn_: should I export modules from the executable to make it visible to tests?
10:02:48 <ghorn_> Javran, I'm sorry, i missed "executable"
10:02:55 <ghorn_> my answer is only for libraries
10:03:00 <srhb> carminemlt: Try looking for solutions online first perhaps, or ask around a bit more in the channel I'm sure someone else can handle the exact problem if you repaste with your current corrections and ask again
10:03:22 <rwbarton> albeit: or more precisely one of the unevaluated fields of the result of (getSide groupA k) retains such a reference
10:03:33 <carminemlt> srhb: good point
10:04:07 <Javran> ghorn_: I meant executable cabal target (not sure about the terminology)
10:04:11 <Eduard_Munteanu> Yay, I've been banned from #mysql. Cool.
10:04:48 <tremon> albeit: as rwbarton says, check that both variants evaluate to the same results. Also, your case reduces to |c1 <= c2  | s1 < s2 | otherwise
10:04:57 <ReinH> Eduard_Munteanu: achievement unlocked?
10:05:04 <Eduard_Munteanu> Something like that. :)
10:05:10 <albeit> rwbarton: Aha! I think groupB was remaining unevaluated, if I force it be evaluated when onlyA is true, memory is back to normal.
10:06:08 <albeit> Which was forced to be evaluated when onlyA was False
10:06:14 <tremon> scratch that last part, I read &&
10:06:27 <ghorn_> Javran: maybe you could have a library and an executable in 1 cabal file, and the executable and tests both depend on the library
10:06:53 <ghorn_> Javran: but then cabal installing your executable would also install the library as a side effect
10:07:09 <albeit> Thanks tremon and rwbarton!
10:07:41 <Javran> ghorn_: yep, that would work!
10:09:18 <carminemlt> Hi everyone, I need help making the code at http://lpaste.net/104042 work. In the lpast I have included what the code's goal is and the error I get back when running.
10:11:45 <ghorn_> carminemlt: could you paste enough code that I can run it, like your imports for example?
10:12:13 <corgifex> that looks pretty obvious to me
10:12:17 <tremon> carminemlt: MonadReader (Int, Int)?
10:12:27 <corgifex> your type signature says MonadReader (Int,Int) m
10:12:33 <rwbarton> carminemlt: what monad do you expect m to be in this call to paths''?
10:12:35 <carminemlt> ghorn_: sure, Just edited the paste
10:12:44 <corgifex> but then you're trying to pass it an [(Int, Int)]
10:12:44 <carminemlt> tremon: yes
10:12:51 <carminemlt> rwbarton: []
10:13:20 <corgifex> I don't think [] is an instance of Reader/Writer
10:13:32 <carminemlt> corgifex: if I try with MonadReader [(Int,Int)] the code won't compile
10:13:38 <srhb> Ah, yes, that's it of course
10:13:39 <corgifex> so?
10:14:19 <carminemlt> corgifex: it complains about the line with "ask"
10:14:29 <corgifex> ...
10:14:45 <Javran> another question: my ".ghci" files imports some libraries automatically at startup, how can I tell "cabal repl" not to load any settings from this file (or maybe specify another conf)?
10:14:48 <rwbarton> Reader [(Int,Int)] isn't an instance of MonadReader (Int,Int)
10:15:00 <rwbarton> nor MonadPlus
10:15:05 <rwbarton> nor MonadWriter :)
10:15:05 <carminemlt> corgifex: and I don't understand why.
10:15:16 <corgifex> carminemlt: because your code makes no sense
10:15:42 <carminemlt> rwbarton,corgifex: AKA "a failure all along the line"
10:16:33 <rwbarton> Also, the way paths'' uses ask doesn't really make sense, yes
10:17:05 <rwbarton> you probably want to 'ask' for the whole graph, and then use MonadPlus to pick one edge
10:17:27 <mizu_no_oto> How easy would it be to write a simple game in Haskell, compile it on OSX, and run it on a raspberry pi running raspbian?
10:18:13 <carminemlt> rwbarton: I believed that ask would indeed have fetched the whole [(Int,Int)] from the reader and used list monad semantics to pick each and every value from it
10:18:25 <mizu_no_oto> is it just a matter of making sure the Pi has gtk, etc. installed and copying over an executable?
10:20:50 <rwbarton> carminemlt: well, technically since ask is a type class method, it does whatever it is defined to do by the instance for the monad m that you pick
10:22:55 <carminemlt> rwbarton: ok, then if I write: MonadReader (Int,Int) m, it would be only a matter to force "m" to be []?
10:25:02 <rwbarton> carminemlt: well you can't use [] directly because you need some access to the graph
10:25:13 <rwbarton> the instance would look like   ask :: [(Int,Int)]
10:25:53 <carminemlt> rbarton: any constraint I can use on the signature?
10:25:54 <rwbarton> conceptually though it seems wrong anyways
10:26:44 <rwbarton> ask is supposed to just give you access to the read-only state--successive calls to ask shouldn't give you different answers
10:27:12 <ReinH> can't, unless you're doing something unsafe
10:28:09 <rwbarton> well you could define instance MonadReader Int [] where ask = [1,2,3]
10:28:16 <rwbarton> I'm saying this seems like a bad thing to do
10:28:53 <carminemlt> rwbarton: agreed. But being in a "do" the whole "(start,end) <- ask" shouldn't work as a generator the same way "do  x <- xs; y <- ys; return (x*y)" being xs and ys [Int] would do?
10:29:13 <ReinH> carminemlt: what do you mean by "work as a generator"?
10:29:26 <ReinH> carminemlt: the behavior of <- changes based on the monad.
10:29:35 <ReinH> I should say the behavior of >>=
10:29:46 <carminemlt> ReinH: Ok, and I think "m" is [].
10:29:59 <ReinH> carminemlt: what's the type?
10:30:30 <carminemlt> ReinH: I am not sure at this point. I haven't specified in the signature
10:30:59 <rwbarton> m clearly can't be [] because it's not an instance of MonadReader
10:31:19 <rwbarton> you probably want ReaderT [(Int,Int)] []
10:31:30 <rwbarton> + WriterT too for tell
10:32:06 <carminemlt> rwbarton: That sounds good. Then, how I can generalize the function so that it accepts any instance that supports MonadReader and MonadWriter?
10:32:26 <carminemlt> rwbarton: That was the whole point of the exercise 7.7 from the book "beginning haskell"
10:32:57 <rwbarton> once you figure out how to write it properly for ReaderT [(Int,Int)] [], that question will answer itself
10:34:05 <jamiehannaford> "When we do :t Just "Haha", the type inference engine figures it out to be of the type Maybe [Char], because if the a in the Just a is a string, then the a in Maybe a must also be a string."
10:34:24 <jamiehannaford> I don't understand why Maybe a is a string if Just a is...
10:34:35 <srhb> jamiehannaford: Maybe a is not a String
10:34:55 <srhb> jamiehannaford: But Maybe String is the type of Just "HaHa"
10:34:59 <carminemlt> rwbarton: You mean, starting from a function f :: ReaderT [(Int,Int)] (Writer [Int]) []?
10:35:32 <jamiehannaford> srhb So they're mutually referencing?
10:35:44 <corgifex> a = a
10:35:48 <srhb> jamiehannaford: Just "haha" is a value, Maybe String is a type. I don't know what you mean by referencing.
10:36:08 <corgifex> :t Just
10:36:09 <lambdabot> a -> Maybe a
10:36:11 <ReinH> carminemlt: that's a value, not a function. ;) Functions have arrows in the signature.
10:36:26 <ReinH> carminemlt: and is that actually a valid type signature?
10:36:35 <jamiehannaford> data Maybe a = Nothing | Just a
10:36:41 <carminemlt> ReinH: Sorry, I meant  Int -> Int -> ReaderT [(Int,Int)] (Writer [Int]) []
10:36:47 <srhb> jamiehannaford: Yes, those as are the same
10:36:48 <jamiehannaford> I don't understand how "Just a" can be defined as Maybe
10:36:54 <jamiehannaford> when Maybe is defined with Just
10:36:55 <rwbarton> carminemlt: needs the result too
10:37:01 <corgifex> jamiehannaford: what?
10:37:13 <enthropy> :k []
10:37:14 <lambdabot> * -> *
10:37:14 <srhb> jamiehannaford: It's a value constructor. Given an a, you can construct a value of type Maybe a using Just
10:37:18 <ReinH> :t Just
10:37:19 <lambdabot> a -> Maybe a
10:37:26 <rwbarton> Int -> Int -> ReaderT [(Int,Int)] (Writer [Int]) [] ()
10:37:27 <ReinH> jamiehannaford: Just is a constructor of Maybe values.
10:37:52 <carminemlt> ReinH: Int -> Int -> ReaderT [(Int,Int)] (Writer [Int]) [Int]
10:38:35 <jamiehannaford> ah okay
10:38:37 <carminemlt> ReinH: ah, ok
10:39:07 <jamiehannaford> so "Maybe a" is a custom type which can have either a Nothing value or a "Just a" value
10:39:22 <ReinH> jamiehannaford: right
10:39:26 <carminemlt> ReinH: ReaderT r m a where r is [(Int,Int)], m is (Writer [Int]) and a is []. Where does () pops out?
10:39:39 <ReinH> It isn't any more "custom" than any other type :)
10:39:44 <tremon> in the same way that "Bool" is a custom type that can be either True or False
10:39:48 <jamiehannaford> why do you need to include "Just" - why not have "a" by itself?
10:40:06 <ReinH> jamiehannaford: because `a' is of type `a'
10:40:10 <corgifex> jamiehannaford: to avoid ambiguity
10:40:13 <ReinH> And you want a value of type Maybe a
10:40:20 <corgifex> consider Just Nothing :: Maybe (Maybe Int)
10:40:49 <ReinH> er, `a' is the type `a'. And you want the type `Maybe a'
10:40:59 <jamiehannaford> so "Just" allows you to explicitly refer to the value of a ?
10:41:17 <ReinH> jamiehannaford: Just :: a -> Maybe a allows you to construct a value of type Maybe a from a value of type a
10:41:33 <tremon> jamiehannaford: "Just" is a constructor. Without it, you cannot create a value of type Maybe (fsvo cannot)
10:41:44 <bitemyapp> jamiehannaford: Just is a value constructor from the definition of Maybe, it looks like:
10:41:45 <corgifex> and pattern matching with Just allows you to extract a value from Maybe a
10:41:49 <bitemyapp> data Maybe a = Just a | Nothing
10:42:16 <bitemyapp> jamiehannaford: Nothing is a nullary (no arguments) constructor for creating Maybes, Just a  takes a parameter of any type.
10:42:32 <jamiehannaford> okay - so Just enables pattern matching to the `a' parameter's value?
10:42:40 <jamiehannaford> sorry for n00b questions :)
10:42:42 <srhb> jamiehannaford: Yes.
10:42:53 <corgifex> imagine a world where we have data Maybe a = Nothing | a
10:42:58 <corgifex> then consider a value 'x'
10:43:03 <srhb> > let f (Just x) = x in f (Just 3)
10:43:04 <lambdabot>  3
10:43:12 <bitemyapp> jamiehannaford: hum. I don't know if that's the exact wording I'd use, but it's close enough. I have a course for you, hold on.
10:43:18 <corgifex> is the type of 'x' Char, Maybe Char, Maybe (Maybe Char), Maybe (Maybe (Maybe Char)), ... ?
10:43:32 <bitemyapp> jamiehannaford: this is my guide for learning Haskell, in it is Yorgey's course https://gist.github.com/bitemyapp/8739525
10:43:39 <corgifex> if there is no explicit Just, we don't know
10:43:39 <bitemyapp> jamiehannaford: it will explain data and value constructors to you.
10:43:50 <srhb> bitemyapp: type and value, no?
10:43:55 <bitemyapp> sorry, yes.
10:43:59 <bitemyapp> type and value constructors.
10:44:02 <rwbarton> carminemlt: oh oops
10:44:09 * srhb thinks "data constructors" should be banned
10:44:15 <ReinH> bitemyapp: it might even explain how they are the same thing ;)
10:44:15 <bitemyapp> ditto
10:44:17 <jamiehannaford> thanks everyone
10:44:17 <rwbarton> I meant Int -> Int -> ReaderT [(Int,Int)] (WriterT [Int] []) ()
10:44:22 <ReinH> bitemyapp: *trollolol*
10:44:23 <bitemyapp> jamiehannaford: one rule of thumb to use is that the left of "=" in a data definition is type constructor, right of "=" is a value constructor.
10:44:24 <jamiehannaford> I'm doing the "learn you a haskell" course
10:44:36 <bitemyapp> jamiehannaford: my experience has been that Yorgey's course is better and faster.
10:44:39 <bitemyapp> jamiehannaford: but as thou wilt.
10:45:16 <jamiehannaford> bitemyapp thanks - i'll definitely check out yorgey too. As I'm getting into more complex areas the LYAH is a bit thin on details
10:45:16 <carminemlt> ReinH: Ok then. I'll try to work on that and see if I can come up with something.
10:45:42 <ReinH> carminemlt: step 1, figure out the type signature for the thing you want to do and get GHC to believe you :)
10:46:05 <shapr> I wish the hackage command would actually search hackage.
10:46:09 <shapr> I guess I could fix that.
10:46:17 <carminemlt> ReinH: I honestly tried to do that, at least based on my understanding of the book's examples
10:46:22 <bitemyapp> jamiehannaford: that's one of the more common complaints I've heard about LYAH, yeah.
10:46:23 <carminemlt> ReinH: :)
10:47:12 <ReinH> LYAH is pretty good if the concepts click naturally. It doesn't offer enough repetition and interaction for when they don't.
10:47:53 <bitemyapp> I think that's a good way to explain it.
10:48:06 <bitemyapp> Unfortunately, I'm a dumb-dumb and I needed different material/approach.
10:48:35 <ReinH> It needs exercises.
10:48:38 <bitemyapp> Precisely.
10:48:45 <ReinH> People don't learn things when you just tell them once.
10:48:48 <jamiehannaford> I need a lot of examples and repetition, too, since some of the concepts in Haskell are wildly unique and different from anything I've ever used
10:48:50 <bitemyapp> real ones, not shallow and spread out demonstrations.
10:49:04 <ReinH> Exercises are things you do, not things the book does. :p
10:49:12 <bitemyapp> jamiehannaford: well, I don't think they're unique (just ask Harper) but they're unfamiliar to people and the pedagogy isn't as hammered out as in other languages.
10:49:23 <bitemyapp> jamiehannaford: that said, I do think the education process has improved a lot just in the last year or two.
10:49:38 <rwbarton> @untml ReaderT [(Int,Int)] (WriterT [Int] []) ()
10:49:38 <lambdabot> Maybe you meant: unpl unmtl
10:49:44 <rwbarton> @unmtl ReaderT [(Int,Int)] (WriterT [Int] []) ()
10:49:44 <lambdabot> [(Int, Int)] -> (WriterT [Int] []) ()
10:49:47 <jamiehannaford> I actually think other languages could learn a lot from LYAH - it's a brilliant introduction
10:49:55 <jamiehannaford> not a complete guide, just a taster
10:50:12 <jamiehannaford> I also like the flippant tone in LYAH - I find it funny and engaging
10:50:34 <ReinH> rwbarton: It's a lot like Why's Poignant Guide to Ruby
10:50:44 <ReinH> and was patterned iirc on Learn You an Erlang
10:51:09 <ReinH> Learn You Some Erlang for Great Good
10:51:10 <bitemyapp> jamiehannaford: I think having something like LYAH is valuable, but I still think it needs to be condensed and then augmented with exercises
10:51:26 <albeit> Is there a way to see a graph of when my program is executing, and when it is paused for garbage collection?
10:51:27 <jesyspa> I think it was LYSE that was based on LYAH, not the other way around.
10:51:28 <bitemyapp> you could delete 30-40% of the text and lose fewer people.
10:51:33 <bitemyapp> jesyspa: correct.
10:51:47 <ReinH> bitemyapp: The first three chapters of LYAH would make a pretty good introduction to a more thorough course
10:51:58 * shapr hugs bitemyapp for having an awesome twitter feed
10:51:58 <ReinH> course/book
10:52:04 <ReinH> jesyspa: oh ok :)
10:52:23 <ReinH> albeit: look at Threadscope
10:52:34 <shapr> Aw, I missed the #haskell birthday party day :-(
10:52:40 <ReinH> shapr: oh noes
10:52:42 <shapr> It was april 30th!
10:52:50 <shapr> dang, I wanted to organize an IRC party
10:52:55 <albeit> ReinH: Perfect thanks, I remember seeing that in an article a while ago, couldn't remember the name
10:53:03 <johannes_> do IRC channels have birthdays
10:53:13 <shapr> johannes_: sure they do, try /msg chanserv info #haskell
10:53:39 <shapr> johannes_: finns oxa #haskell.se
10:54:16 <johannes_> shapr: ok. det visste jag inte/didn't know that
10:55:27 <quchen>  > founder: edwardk
10:55:42 <bitemyapp> quchen: ?
10:55:55 <quchen> That's what chanserv says about #haskell.
10:55:57 <magthe> where should I look to find some examples of how to use the low-level stuff found in GHC.Prim,in particular the writeWordNoffAddr# stuff?
10:56:18 <shapr> quchen: Yeah, was dons, and me before that
10:56:19 <bitemyapp> quchen: Huh. I thought it was shapr for some reason.
10:56:22 <bitemyapp> ohhhhh
10:56:27 <bitemyapp> current Founder. gotcha.
10:56:47 <shapr> bitemyapp: I started #haskell those many years ago, but passed off the founder-ness when I ran low on time.
10:56:59 <ReinH> I don't think that's how founding something works, Freenode.
10:57:15 <geekosaur> they kinda adapted it without renaming
10:57:18 * quchen goes offline to declare him his own dad now
10:57:21 <bitemyapp> ReinH: the flags system is a little broken.
10:58:28 <shapr> ReinH: founder-ness can be transferred
11:00:21 <ReinH> Right. That's why I don't think Freenode knows what a founder is. :)
11:00:44 <jmzcool> Debugging question, if anyone is up to it! I am trying to use GHCi to find a pattern match for which I have supplied "head" with an empty list. I say "ghci extractGrades.hs," ":set -fbreak-on-exception," ":set args <args>", then ":trace main." The exception is caught, but I have "no logged breakpoints" on ":back" and "No history, perhaps you forgot to use :trace?" -- any ideas?
11:01:10 <magthe> no takers?  I was hoping to be able to replace some C-via-FFI with low-level stuff from GHC.Prim, but am running into what I think is /really/ basic stuff
11:01:37 <jmzcool> relevant info: GHCi v7.6.3 on Mac OS X
11:02:10 <shachaf> jmzcool: I don't know much about using the ghci debugger, but maybe try this:
11:02:13 <shachaf> @where rts-xc
11:02:14 <lambdabot> ghc -prof -fprof-auto -rtsopts -osuf .p_o foo.hs && ./foo +RTS -xc # print stack traces on unhandled exceptions
11:05:03 <jmzcool> shachaf: wonderful, thanks!
11:06:12 <ReinH> jmzcool: If this isn't an exercise in learning how to debug exceptions, maybe you should could pattern match instead of using head? :)
11:06:52 <rwbarton> the "pattern match to get line number information" design pattern
11:07:59 <corgifex> $__LINE__
11:12:15 <ReinH> rwbarton: are line numbers what are wanted, or is not having a runtime exception what is wanted? :p
11:13:46 <rwbarton> ReinH: usually when you replace head by pattern matching the [] case looks like [] -> error "lolwut"
11:14:13 <rwbarton> (that is assuming you had any good reason to use head in the first place)
11:14:19 <ReinH> rwbarton: or maybe there's a better way to handle that case
11:14:19 <sm_> that's at least an improvement
11:14:39 <ReinH> it at least makes it more obvious that your function is partial
11:14:47 <rwbarton> the function ISN'T SUPPOSED to be partial
11:15:04 <ReinH> ...
11:15:10 <ReinH> I'm not sure what that means.
11:15:19 <rwbarton> you can use a partial function to implement a total function
11:15:32 <rwbarton> and often it's really useful to do so!
11:15:37 <ReinH> Absolutely.
11:15:43 <magthe> aarghh!  it's as if the powers that be doesn't want me to poke around in memory using Haskell!!!
11:15:48 <ReinH> But we're actually talking about a runtime exception caused by head here...
11:16:01 <ReinH> So it seems as if it is not being used to implement a total function.
11:16:03 <rwbarton> which means you did something wrong
11:16:06 <aupiff> hi there. reading typeclassopedia now and wondering about rewriting "pure (flip ($)) <*> x <*> pure f" as "pure f <*> x"
11:16:21 <rwbarton> the way to "handle the exception" is to go fix the code
11:16:25 <ReinH> perhaps that wrong thing is "using head".
11:16:31 <rwbarton> no
11:16:35 <aupiff> using interchange followed by homomorphism I get "pure ((flip ($)) ($ f)) <*> x"
11:16:36 <ReinH> Um.
11:16:37 <rwbarton> you passed head the wrong thing
11:16:39 <aupiff> and then I'm confused
11:16:46 <ReinH> Or maybe you shouldn't have used head.
11:17:18 <rwbarton> well sure you can use [] -> error "lolwut" instead, which is the design pattern I mentioned at the start
11:17:51 <rwbarton> the fact is we can't abstract this design pattern into a function for practical reasons
11:18:09 <sm> there's almost no reason to ever use head, headSafe is preferable
11:18:10 <ReinH> I'm not quite sure what you're saying.
11:18:13 <quchen> I think ReinH's point is that you should be able to prove safety of a partial function at the use site, or never ever to use that partial function in the first place.
11:18:21 <ReinH> Sometimes people use head without realizing that they are using a partial function that causes runtime errors.
11:18:32 <ReinH> And there are certainly cases where the best answer is "don't use head"
11:18:35 <rwbarton> but you can't or don't always want to prove it *to the compiler*
11:18:47 <ReinH> rwbarton: I feel like we're talking about different things
11:18:52 <ReinH> I understand that.
11:19:02 <ReinH> I don't think we have any reason to believe that's what is happening here.
11:19:12 <rwbarton> nextPowerOfTwo n = head $ filter (>= n) $ iterate (* 2) 1 -- etc.
11:19:43 <rwbarton> ReinH: that's true, we also don't have any reason to believe that it isn't
11:19:58 <ReinH> rwbarton: so why are you arguing as if it's true then?
11:20:12 <ReinH> You can prove things that the type system can't. That's fine. That isn't necessarily happening here.
11:20:29 <ReinH> Anyway I don't think it's worth arguing about. I'm not even sure why the original asker is using head. That's why my original suggestion was qualified.
11:21:08 * hackagebot casadi-bindings-core 1.9.0.2 - low level bindings to casadi-core  http://hackage.haskell.org/package/casadi-bindings-core-1.9.0.2 (GregHorn)
11:21:08 <ReinH> (Or that you don't want to prove in the type system in this case, at least.)
11:21:10 * hackagebot casadi-bindings-ipopt-interface 1.9.0.2 - low level bindings to casadi-ipopt_interface  http://hackage.haskell.org/package/casadi-bindings-ipopt-interface-1.9.0.2 (GregHorn)
11:21:12 * hackagebot casadi-bindings-snopt-interface 1.9.0.2 - low level bindings to casadi-snopt_interface  http://hackage.haskell.org/package/casadi-bindings-snopt-interface-1.9.0.2 (GregHorn)
11:21:14 * hackagebot casadi-bindings 1.9.0.2 - low level bindings to CasADi  http://hackage.haskell.org/package/casadi-bindings-1.9.0.2 (GregHorn)
11:21:17 <rwbarton> OK. It sounded more like a thinly-veiled "don't use head" to me.
11:21:27 <etrepum> With Data.Text, what's the canonical way to force compaction of the underlying array? Most of the functions in Data.Text will just reference an existing array (which may be very large) with different offset & lengths. What if you want copying because you know that you can free memory that way?
11:21:36 <ReinH> rwbarton: It was a thinly veiled "maybe you should consider not using head"
11:22:59 <jle`> I don't like head :/
11:23:29 <jle`> if anything it should be tucked away in Data.List, with tail :\
11:23:37 <jle`> *and also
11:23:47 <aupiff> my real question is I can't figure out how "(flip ($)) ($ f))" reduces to "f", the type of the thing I'm trying to rewrite is scary
11:24:33 <corgifex> :t (flip ($)) ($ ?f)
11:24:34 <lambdabot> (?f::a) => (((a -> b) -> b) -> c) -> c
11:25:19 <aupiff> this is because the interchange applicative law is stated as u <*> pure y = pure ($ y) <*> u
11:25:22 <ReinH> rwbarton: I don't think most uses of head are accompanied by a correctness proof :p
11:25:33 <aupiff> :t ($ ?f)
11:25:34 <lambdabot> (?f::a) => (a -> b) -> b
11:25:49 <ReinH> I think it's often used in an ad hoc way where pattern matching would be safer, or at least force the developer to confront the fact that they are writing a partial function
11:26:29 <ReinH> corgifex: I forgot lambdabot lets you use ?x
11:27:04 <aupiff> :t ((flip ($)) ($ (+3))
11:27:05 <lambdabot>     parse error (possibly incorrect indentation or mismatched brackets)
11:27:15 <aupiff> :t ((flip ($)) ($ (+3)))
11:27:16 <lambdabot> Num a => ((((a -> a) -> b) -> b) -> c) -> c
11:27:32 <aupiff> that last type sig is confusing to me...
11:27:40 <jle`> :t (flip id) (flip id ?x)
11:27:40 <lambdabot> (?x::b) => (((b -> c1) -> c1) -> c) -> c
11:28:11 <jle`> hm.
11:28:31 <jle`> :t ($ ($ ?f))
11:28:32 <lambdabot> (?f::a) => (((a -> b1) -> b1) -> b) -> b
11:30:08 <ReinH> I know I wrote a lot of partial functions when I was first learning Haskell without realizing the danger.
11:30:30 <jle`> also why is (!!) in Prelude
11:30:35 <jle`> I mean come on
11:30:43 <ReinH> That one is strange too.
11:31:10 <ReinH> "Lists are not really a data structure and should not be used for random access. Here's how you index into them."
11:31:22 <int-e> is there a GHC.Generics based memoization library on hackage?
11:32:30 <jle`> I was reviewing some code from a new person and someone did ((xs !! 0) + (xs !! 1)) : drop 2 xs
11:32:58 <jmzcool> Hey all, I think I'm misunderstanding "splitWhen" and "head". I am trying to perform a split on non-empty lines of a file, and I seem to get an error taking the head of a list that should be non-empty. I have a paste here: <http://pastebin.com/H79tY8TE>. I check the literal that I take the head of, and it appears to be a non-empty list. Any help is appreciated!
11:33:35 <ReinH> What was I saying again? ;)
11:33:54 <corgifex> @hoogle splitWhen
11:33:55 <lambdabot> No results found
11:34:12 <rwbarton> ReinH: in my experience most uses of head are actually in cases where it makes sense to use head (i.e. not map f xs = f (head xs) : map f (tail xs)), but then my population of Haskell code is mostly packages released on Hackage plus my own code
11:34:31 <Nephro> Does the Num type class not include the Ord type class in it?
11:34:51 <enthropy> Nephro: I believe it used to (ghc < 7.6)
11:34:52 <jle`> Nephro: it does not
11:34:58 <ReinH> rwbarton: right, I think there's some selection bias there ;)
11:35:09 <rwbarton> yes
11:35:11 <corgifex> enthropy: complex numbers
11:35:18 <jle`> I think it's so that Complex can be Num?
11:35:24 <ReinH> rwbarton: and I think I select in a different way :)
11:35:43 <enthropy> oh nevermind that was other superclass stuff (Eq and Show)
11:36:03 <jle`> still I had to commend the person for using drop 2 instead of tail . tail
11:36:06 <Nephro> how do I deal with a situation, where I need to add my arguments together and compare them? Doing "foo :: (Num a) => a -> a -> a -> String", but comparisons inside the body of foo require Ord
11:36:24 <ion> (Num a, Ord a)
11:36:31 <ReinH> jmzcool: what do you expect it to do on an empty line?
11:36:57 <Nephro> thank you io2
11:37:00 <Nephro> ion*
11:37:55 <ReinH> jmzcool: is the answer "throw a runtime exception"? :)
11:37:57 <glguy> jmzcool: I'd imagine that it's failing when there is no '=' in the line
11:38:04 <glguy> so it gets to the end trying to split things
11:38:14 <glguy> but I don't know what splitWhen actually does
11:38:20 <ReinH> glguy: I think it's splitting lines on lines that begin with '='
11:38:31 <ReinH> if that's the case, it's giving an error on empty lines
11:38:52 <glguy> My guess was that splitWhen goes along looking at the tails of the list of chars trying to find a tail that passes the predicate
11:39:39 <ReinH> would something like this be useful? `startsWith c [] = False; startsWith c (x:xs) | x == c = True | otherwise = False'
11:39:54 <glguy> ?type isPrefixOf
11:39:55 <lambdabot> Eq a => [a] -> [a] -> Bool
11:40:02 <corgifex> redundant True/False
11:40:07 <Nephro> Reading about the "where" clause for functions. The book says the where scope is only for the same function body. The book says the only solution is to use global vars, but my programming experience teaches me that global stuff is bad. Is this not true for haskell?
11:40:08 <corgifex> startsWith c (x : _) = c == x
11:40:18 <ReinH> corgifex: oh lol yes, I do keep doing that
11:40:24 <jmzcool> ReinH: I should have filtered empty lines out with a "filter(not.null)" -- see paste <http://pastebin.com/H79tY8TE>
11:40:25 <corgifex> Nephro: solution to what?
11:40:28 <glguy> Nephro: Global mutable variables are bad
11:40:31 <ReinH> startsWith c (x:xs) = x == c
11:41:07 <ReinH> jmzcool: I don't have enough context to know what you're doing with that let block. I can't see the in ;)
11:41:29 <ReinH> Nephro: which book?
11:41:43 <Nephro> ReinH, learn you a haskell for greater good
11:41:59 <rwbarton> jmzcool, are you sure this is the relevant use of head?
11:42:06 <ReinH> Nephro: global variables aren't really bad. Globally mutable state is bad. "Variables" in Haskell are immutable.
11:42:49 <dwcook> Nephro: "global" variables aren't really global either, they're module-global.
11:42:56 <ReinH> Also that.
11:43:09 <Denommus> another interesting approach for global variables are dynamically scoped global variables
11:44:57 <jmzcool> rwbarton: I have :set -fbreak-on-exception called, it breaks on exception, i hit :back, this is what I find.
11:45:21 <ReinH> jmzcool: replacing `head' with your own pattern match would allow you to give your own error message
11:45:26 <ReinH> Which would let you disambiguate
11:45:46 <jmzcool> ReinH: the entire function is given here: <http://pastebin.com/g0R7dHp3>, that's possibly what i'll have to do (add my own errors)
11:46:11 * hackagebot faceted 0.0.2.0 - Faceted computation for dynamic information flow security  http://hackage.haskell.org/package/faceted-0.0.2.0 (KennKnowles)
11:46:40 <dmwit> ReinH: [c] `isPrefixOf`
11:46:46 <ReinH> dmwit: yes.
11:47:09 <ReinH> dmwit: But I was trying to give an example of replacing a use of head with pattern matching.
11:47:25 <dmwit> Oh. I do tend to stick my nose in things without context.
11:47:27 <dmwit> Apologies.
11:47:36 <ReinH> dmwit: it's a valid suggestion, no worries
11:49:40 <ReinH> And I think "I don't know which head is causing my runtime errors" is a good example of a situation where maybe you would be better off not using head. :0
11:49:45 <Philonous> Is there a way to prevent cabal repl from sullying itself when the project's code contains errors?
11:49:59 <ReinH> Philonous: Um. Fix the errors? :)
11:50:20 <ReinH> Philonous: which is to say, no. I don't know of one.
11:50:36 <dmwit> ghc-options: -fdefer-type-errors will fix some, I guess
11:50:37 <ReinH> s/:0/:)
11:51:35 <Philonous> ReinH, That's what I'm trying to do. It's a bit silly that I need to fix my code before I can have an inferior haskell to aide me in fixing my errors.
11:52:03 <ReinH> Philonous: usually you want to fix type errors first.
11:52:37 <merijn> Whoo, spent all my time since friday trying to refactor my code into working, only to realise that my original design was the right one anyway
11:52:46 <jxv> If anyone is interested in haskell w/ robotics, there's now a #haskell-robotics .
11:53:15 <Philonous> ReinH, That's a novel idea. You IDE won't start until you fixed your code :>
11:53:28 <merijn> Oh
11:53:34 <merijn> That reminds me of a funny GHC bug :)
11:53:35 <ReinH> Philonous: Hmm, which "IDE" is this?
11:53:47 <ReinH> Having type errors happens a lot while you're writing Haskell.
11:53:56 <ReinH> Sounds like a broken IDE if it won't start in that condition
11:53:57 <dmwit> I'm pretty sure Philonous just said he uses emacs with inferior Haskell mode.
11:54:03 <Philonous> ReinH, Well, not an IDE, really, but haskell-mode in emacs.
11:54:06 <merijn> @quote Quite.sensible
11:54:06 <lambdabot> augustss says: ghc had a bug once where it deleted the source file if it had a type error.  Quite sensible, I think.
11:54:18 <ReinH> merijn: <3
11:55:51 <Philonous> merijn, That I could deal with. nothing a few lines of elisp couldn't fix.
11:56:16 <pavonia> Had there really been such a bug?
11:56:34 <bennofs> pavonia: afaik, yes
11:57:03 <pavonia> strange
11:57:15 <Philonous> pavonia, It's one of those mythological things. Nobody knows whether it's true, but it's a good story, so we all pretend it is ;)
11:57:45 <merijn> pavonia: Yes
11:57:51 <corgifex> on the other hand, augustss wrote the first haskell compiler so he's probably familiar with ghc 0.whatever
11:58:09 <merijn> Philonous: Eh, augustss retold that story during IFL as part of his "history of haskell" keynote
11:58:18 <pavonia> It's just I can't think of any situation where it would be useful to delete a source file
11:58:33 <pavonia> one that isn't auto-generated at least
11:59:01 <Punga> Hello
11:59:11 <merijn> Philonous: So I'm fairly certain that at least he and several others there actually recall that bug, so I'm pretty convinced it's true
11:59:17 <rwbarton> I always imagined that there was some code that was intended to remove the output file to clean up after an error but due to a bug it removed the input file instead
11:59:25 <rwbarton> it seems pretty plausible
11:59:43 * rwbarton checks snopes.com
11:59:54 <dmwit> I thought the story was that it opened the file in write mode by accident instead of read mode, truncating it to 0 bytes.
12:00:12 <dmwit> ...or something like that
12:01:38 <albeit> I'm using a module that "import GHC.TypeLits (KnownNat, natVal)", but GHC complains that TypeLits does not export KnownNat... and yet I can see it on hackage. What might be going on?
12:01:56 <dmwit> version mismatch?
12:02:28 <merijn> albeit: Which GHC version? :)
12:02:49 <albeit> GHC 7.6.3
12:02:49 <merijn> KnownNat is new in 7.8, afaik
12:03:18 <albeit> Ah. How can I check what version of the base module I'm using?
12:03:23 <jmzcool> well, thanks all for your input!
12:03:24 <dmwit> ghc-pkg list base
12:03:25 <jmzcool> i am off for now
12:03:29 <merijn> albeit: If you wanna mess around with DataKinds you probably want to use 7.8 anyway so you can get closed TypeFamilies
12:03:38 <merijn> albeit: base is non-upgradable, it ships with GHC
12:03:45 <merijn> albeit: You can't use newer base with 7.6
12:04:15 <corgifex> https://github.com/mozilla/rust/issues/950
12:04:19 <albeit> merijn: Okay. I'm not actually messing around with DataKinds, just one of the modules I'm hoping to build upon is. Guess I'm upgrading to 7.8!
12:04:20 <merijn> albeit: So the answer is, if you're using 7.6 then you have the wrong base :)
12:04:50 <merijn> albeit: You can just have both in parallel, GHC uses a per-version package databasee, so 7.8 won't interfere with your 7.6 environment
12:05:31 <johnw> kqr: ah, right, thanks
12:05:32 <corgifex> pavonia, Philonous: http://sourceforge.net/p/ghc/bugs/245/
12:05:50 <albeit> merijn: Okay, so I would just specify that I'm using GHC 7.8 when compiling? Do I need to reinstall any other modules I might need into the 7.8 package database?
12:06:12 <albeit> And how would cabal know which package database to install into?
12:06:32 <merijn> albeit: I just install the binary GHC release into ~/ghc and add ~/ghc/bin to my path if I wanna use 7.8
12:06:46 <merijn> albeit: cabal automatically uses the GHC that comes first in your path
12:06:52 <cwvh> albeit: I keep my GHC installs in ~/ghc/<version>, and then I can do ... what merijn said above.
12:07:09 <merijn> albeit: And yeah, you'll have to reinstall dependencies as your 7.8 will have nothing installed
12:08:00 <rwbarton> or if you think you will mostly want to use the new GHC, install it in ~/bin and use cabal -w ghc-7.6.3 if you want to use the old one
12:08:05 <hubblebub> Hello, I have a function that creates a UArray from a list, but when I add a signature it complains, I think because I cannot store polymorphic values in it: makeArray :: [a] -> UArray Int a
12:08:25 <hubblebub> Now I only want to use it with Int, Float, etc, how can I provide the right signature for it?
12:08:31 <pavonia> corgifex: Thanks. I like Simon's short comment, as if it were nothing strange :)
12:08:36 <merijn> hubblebub: UArray is unboxed, you can't have unboxed polymorphic values
12:08:48 <merijn> hubblebub: So in short, "you can't"
12:09:21 <merijn> Although I guess it should work if you just use said polymorphic function in a monomorphic context?
12:09:21 <rwbarton> hubblebub: the easy way is to ask ghci for the type of your function
12:09:26 <hubblebub> merijn: ok, could I still use the function with Ints and Floats without a signature? Or is that also impossible, i.e. whatever is first will "bind" that 'a'?
12:09:37 <albeit> I'm on Ubuntu, installed ghc and everythign through haskell-platform. If I reinstall the GHCs into seperate folders ~/ghc/{version}, I should be able to just modify my path to the version I want to use, yeah?
12:09:44 <rwbarton> :t array
12:09:44 <lambdabot> Ix i => (i, i) -> [(i, e)] -> Array i e
12:09:49 <merijn> albeit: Yeah
12:10:01 <rwbarton> erm
12:10:17 <albeit> (And somehow remove the reference to the old ghc in /bin...)
12:10:21 <hubblebub> rwbarton: so why is 'array' valid but 'makeArray' invalid?
12:10:30 <rwbarton> don't ask lambdabot apparently...
12:10:32 <rwbarton> Array is the boxed array
12:10:55 <rwbarton> apparently there are two different 'array' functions
12:10:58 <hubblebub> Data.Array.Unboxed has an array function returning a UArray
12:11:34 <rwbarton> array :: (IArray a e, Ix i) => (i, i) -> [(i, e)] -> a i e
12:11:44 <cwvh> albeit: You only need the "new" GHC path to appear before /usr/bin. For example:   PATH=~/ghc/bin:$PATH   would find your local GHC before the haskell-platform+ghc GHC.
12:12:04 <albeit> cwvh: Ah yes, okay.
12:12:22 <rwbarton> hubblebub: so if you ask ghci for the type then I expect it will tell you something like  makeArray :: IArray UArray a => [a] -> UArray Int a
12:12:58 <albeit> If I have GHC installed in ~/ghc/{version}, where would the packages installed from cabal go?
12:13:11 <merijn> albeit: ~/.cabal/ghc-<version number>
12:13:18 <merijn> On linux, at least
12:13:25 <rwbarton> ~/.ghc/{arch}-{version} regardless of where you installed GHC
12:13:30 <albeit> Ah okay so cabal has its own internal structure for the different versions
12:13:32 <merijn> or is it .ghc/whatever
12:13:47 <merijn> albeit: It queries GHC for the package information
12:14:29 <rwbarton> cabal will also keep its own per-version information separate
12:15:03 <monochrom> albeit: see my http://www.vex.net/~trebla/haskell/sicp.xhtml
12:15:07 <hubblebub> rwbarton: I see, so the typeclass contraint means the 'a' is constrained to "something compatible with UArray"?
12:15:35 <hubblebub> rwbarton: whereas I was saying "I'll take any a" which is a superset of that?
12:15:40 <rwbarton> yes
12:15:50 <hubblebub> Right, makes sense, thanks
12:15:51 <rwbarton> and you can see the list of instances here  http://hackage.haskell.org/package/array-0.5.0.0/docs/Data-Array-IArray.html
12:16:09 <rwbarton> the first instance means if you had a boxed Array, you could use any element type
12:16:58 <glosoli> Anyone knows if there is FP Complete IDE like theme under Emacs ?
12:17:11 <hubblebub> rwbarton: ah I see, it specializes these instances and you can range over those specializations
12:17:25 <rwbarton> hubblebub: yeah exactly
12:17:37 <hubblebub> rwbarton: pretty neat -- once you understand it at least :)
12:18:35 <rwbarton> (and in fact, you can add instances for your own types)
12:18:46 <michi7x7> hubblebub: many types are defined like this
12:19:08 <corgifex> :t (==)
12:19:09 <lambdabot> Eq a => a -> a -> Bool
12:21:40 <albeit> Hmm... if I reinstall a binary 7.6.3 into ~/ghc, and run ghc from there, will it still see packages installed for the old ghc 7.6.3 in /usr?
12:21:49 <albeit> (I'm guessing yes...)
12:22:05 <merijn> albeit: Yeah
12:24:51 <Punga> Hello, may I please ask what does "infixr" do?
12:25:12 <Philonous> Punga, It declares an infix operator to be right-associative
12:25:36 <bergmark> Punga: http://www.haskell.org/haskellwiki/Keywords#infix.2C_infixl.2C_infixr
12:25:52 <Philonous> Punga, Right associative means that a `op` b `op` c = a `op` (b `op` c)
12:25:53 <shachaf> Punga: You should also know about Hoogle, which can answer that sort of question: http://www.haskell.org/hoogle/
12:26:48 <rhaps0dy> hoogle is love
12:27:05 <shachaf> Google can too, for that matter.
12:27:40 <skypers> hi
12:27:48 <c_wraith> shachaf: isn't that one of the few questions hoogle can't answer?
12:27:52 <skypers> I’m looking for a way to turn a matrix (from Linear) into a flat list
12:27:56 <shachaf> c_wraith: It can answer keyword questions.
12:28:05 <skypers> I see two ways to do it: pattern matching, and Foldable
12:28:07 <shachaf> Even symbol keywords!
12:28:19 <skypers> I guess pattern matching is better because I won’t have to append to a list
12:28:24 <c_wraith> Huh.  I've only ever used it for library lookups
12:28:25 <skypers> what do you think?
12:28:28 <Punga> Thank you guys.
12:28:29 <Philonous> shachaf, "TIL"
12:28:55 <shachaf> I've hardly ever used it.
12:29:29 <skypers> something like flattenM44 :: M44 a -> [a]; flatten (V4 (V4 a b c d) (V4 e f g h) (V4 i j k l) (V4 m n o p)) = [a,b,c,d,e,f,g,h,i,j,k,l,m,n,o,p]
12:29:32 <skypers> or
12:30:51 <skypers> flattenM4' :: M44 a -> [a]; flattenM44' = concat . map (F.foldl (\a x -> a ++ [x]) [])
12:30:54 <skypers> what do you think?
12:31:09 <skypers> oh, concatMap*
12:31:18 <iamnot_> Hi Everybody, I have a short question: Is it possible to use pattern matching on the result of a function? I.e, ; i know a function gives back a tupel and i only want to use the first part of it.
12:31:43 <merijn> iamnot_: Well, first of all "fst :: (a, b) -> a" and secondly, yes. Just use case-of
12:31:44 <shachaf> case f x of (a, _) -> ...a...
12:32:02 <fizruk> hey guys! I guess I can throw my SO question in here and hope to get a bit more response? http://stackoverflow.com/questions/23596225/how-can-quotient-types-help-safely-expose-module-internals
12:32:05 <skypers> merijn: case of?
12:32:07 <shachaf> You can also use (fst . f) as merijn suggested.
12:32:17 <merijn> skypers: See shachaf's example
12:32:29 <skypers> merijn: I mean, one can do that in a let or where clause as well right?
12:32:40 <merijn> skypers: case is an expression, you can use it anywhere
12:32:44 <skypers> I’m use to doing some stuff like let Just a = b
12:33:27 <merijn> skypers: That crashes if b is Nothing (well, only if you try to use 'a', but still!)
12:33:34 <skypers> yep
12:33:36 <skypers> it’s an example
12:33:41 <skypers> better one:
12:34:08 <merijn> skypers: In practice I just go with whatever seems most readable
12:34:15 <skypers> @let foo :: (a,b) -> a; foo a = let (x,_) in x
12:34:15 <lambdabot>  Parse failed: Parse error: in
12:34:26 <skypers> @let foo :: (a,b) -> a; foo a = let (x,_) = ain x
12:34:26 <lambdabot>  Parse failed: Parse error: EOF
12:34:28 <skypers> @let foo :: (a,b) -> a; foo a = let (x,_) = a in x
12:34:31 <lambdabot>  Defined.
12:34:32 <skypers> something like that
12:34:34 <fizruk> :o
12:34:36 <skypers> but yeah, you’re right
12:34:44 <skypers> foo (x,_) = x is better
12:34:49 <merijn> skypers: Why not "foo (x, _) = x"?
12:34:51 <merijn> :)
12:35:06 <skypers> it was just to mention the fact that pattern patching is not always reduced to caseofs :)
12:35:13 <skypers> we can do that in lets or wheres
12:35:34 <fizruk> and lambdas
12:35:40 <skypers> yeah
12:35:40 <skypers> btw
12:35:46 <skypers> I don’t really understand why
12:36:06 <fizruk> lambda case is my favorite
12:36:07 <skypers> we can do it if there’s just one ctor, right?
12:36:14 <skypers> if we have two ctors, it will crash
12:36:27 <fizruk> skypers: just like your let Just a = b example
12:36:48 <skypers> you’re right
12:36:51 <skypers> :)
12:36:52 <fizruk> that’s why lambda case is cool
12:37:11 <skypers> I use lambda case for tuples
12:37:17 <skypers> or anything that won’t crash
12:37:25 <skypers> to unwrap types
12:37:27 <skypers> it’s coll :)
12:37:29 <skypers> cool*
12:40:45 <smiller2> In netwire, why do events need their own type?  Can't they be described as signals / wires that produces a value at discrete / single points in time by not inhibiting?
12:41:19 <hubblebub> hm, I'm now getting this: "Non type-variable argument in the constraint: IArray UArray a" for signature makeArray :: IArray UArray a => [a] -> UArray Int a
12:41:37 <merijn> hubblebub: Probably needs FlexibleContexts ?
12:41:45 <hubblebub> merijn: yes
12:41:56 <hubblebub> merijn: what is that, and why do I need it? :)
12:44:19 <rwbarton> you need it basically because the Haskell language standard made a very conservative assumption about the sorts of contexts that would be needed
12:44:30 <merijn> hubblebub: It's an extension that allows non-type variables in constraints "IArray UArray a =>" rather than "IArray arr a =>", and you need it because the haskell report is really conservative about what sort of constraints it allows
12:45:15 <hubblebub> merijn: oh the problem is that UArray is not a type variable and it doesn't like how I "specialize" it there?
12:45:28 <merijn> hubblebub: Yeah
12:45:41 <hubblebub> merijn: ah, all right. Cool, thanks :)
12:45:54 <merijn> hubblebub: Because the haskell standard doesn't allow that, GHC, however, does.
12:46:00 <rwbarton> It was an assumption that made sense at the time, sort of.
12:46:47 <merijn> hubblebub: GHC defaults to following the Haskell Report, unless you explicitly enable extensions like this. (Well, with 2 minor deviations from the report appearing by default)
12:47:56 <[1]sean> category theory.... interesting.... so everytime I run a piece of haskell I'm proving mathematics..
12:48:37 <michi7x7> alphonse23: nah, but many Haskellers like to believe that
12:48:51 <alphonse23> prove me wrong!
12:49:24 <merijn> michi7x7: I don't even think many Haskellers like to believe that
12:49:43 <merijn> Category theory is interesting, but pretty much entirely unrelated to what I do writing haskell
12:49:44 <mmachenry> [1]sean you are writing a proof that that program has that like. You're not "proving mathematics"
12:49:51 <michi7x7> alphonse23: you need years to understand category theory, but just a few month to understand haskell?
12:50:10 <alphonse23> I don't know.
12:50:23 <alphonse23> I just started finally getting around to trying to understand haskell
12:50:24 <vamega> I know no category theory.
12:50:35 <mmachenry> sean: look at the curry-howard correspondance. It's true of any static type system, in theory. Though some type systems are not sound.
12:50:39 <alphonse23> it all sounds so interesting, but so difficult
12:50:44 <vamega> And definitely wouldn't say my code is very much of a proof of anything.
12:51:13 <michi7x7> alphonse23: well, that's what everybody thinks first (and I still do, sometimes)
12:51:22 <alphonse23> mmachenry: yeah, that's what I just read about. Someone at a company called stackbuilders publish a little introduction to it. That's where I was getting this all from
12:51:45 <michi7x7> but Haskell allows you to write programs very much in iterative style, which makes starting easier
12:52:32 <mmachenry> alphonse23: We're just writing code. Due to the CHC we're writing proofs. But haskell is not special in that. Haskell is only special in that its users are more aware of the CHC.
12:52:54 <alphonse23> sounds so cool
12:53:02 <alphonse23> I wonder if all this stuff will help me with my job....
12:53:05 <alphonse23> probably not.
12:53:34 <mmachenry> alphonse23: It's very likely it will help you write better code.
12:53:53 <michi7x7> alphonse23: but it will help you to think differently about problems
12:53:54 <mmachenry> Just don't think of it in such an academic context. It's not that academic
12:54:26 <michi7x7> mmachenry: it probably wouldn't be used, if it were academic
12:54:31 <alphonse23> maybe. unfortanetly, my job is not to write good code. Just to ship shit fast, and the faster the better. Tell my boss about good code and haskell and he'll tell you -- "sure, sounds cool, whatever, but can you get it done in two weeks?"
12:54:33 <merijn> I don't think it makes sense to even say that "you're writing proofs", because that's only true in a very trivial and boring sense...
12:54:41 <benzrf> so what are comonads good for anyway o=
12:54:53 <smiller2> http://hackage.haskell.org/package/netwire-5.0.0/docs/Control-Wire-Unsafe-Event.html — Rather than requiring the user to import an Internal module to create events, why not wrap "Event :: a -> Event a" in a public module instead?
12:55:18 <merijn> smiller2: Well, because as the name implies it's not safe :)
12:55:51 <michi7x7> alphonse23: well, programming always comes down to problems, and it will definitely help you to see how Haskell libraries provide solutions
12:56:10 <michi7x7> because you will be surprised how different they are from e.g. C++ libraries
12:56:35 <mmachenry> merijn: True in a vey boring sense, but true in exactly the sense he was asking about.
12:56:35 <croyd> alphonse23: it depends on your perspective. There was an interesting talk recently making the case for haskell as a great language for being able to quickly get something working
12:56:41 <croyd> @google haskell in the newsroom
12:56:42 <lambdabot> http://www.infoq.com/presentations/haskell-newsroom-nyt
12:56:42 <lambdabot> Title: Haskell in the Newsroom
12:56:48 <croyd> ^
12:57:19 <alphonse23> no doubt, haskell has all these new symbols,  >>= . I wonder if anyone would be impressed, or would that just get pissed off and tell me I'm making things more complicated than they should be.
12:57:31 <mmachenry> merijn: It doesn't help to answer a question of "The curry-howard correspondence says I'm writing a proof when I write code. I don't it" with "It' a lie you're not writing a proof" because that is false.
12:58:23 <smiller2> merijn: Hmm.  Do you know why it's unsafe?
12:58:33 <Philonous> Is it unreasonable to say that rank 3 types need at least an example in the documentation to be comprehensible?
12:58:51 <merijn> smiller2: Not sure, tbh, I haven't played with netwire after version 3 and it changed rather a lot :)
12:59:00 <merijn> Philonous: Depends on the specific type? :)
12:59:33 <merijn> @hoogle Alternative f => f a -> f b -> f (Either a b)
12:59:34 <lambdabot> Data.ByteString.Builder.Prim eitherB :: BoundedPrim a -> BoundedPrim b -> BoundedPrim (Either a b)
12:59:34 <lambdabot> Text.ParserCombinators.Parsec.Prim runParser :: GenParser tok st a -> st -> SourceName -> [tok] -> Either ParseError a
12:59:34 <lambdabot> Text.Parsec.Prim runParserT :: Stream s m t => ParsecT s u m a -> u -> SourceName -> s -> m (Either ParseError a)
12:59:47 <michi7x7> alphonse23: you can avoid most of the operators, and usually they do exactly what they seem to do
13:00:04 <Philonous> merijn, I'm trying to figure out how MonadBaseControl works. Either I'm particularly dense today or the documentation is utterly unhelpful.
13:00:47 <merijn> Philonous: That's the "lifting exceptions" stuff, right?
13:01:02 <dmwit> Philonous: I've implemented MonadBaseControl once!
13:01:02 <Philonous> merijn, I don't even know what it means to run "a m computation on state[...]"
13:01:12 <dmwit> Philonous: I didn't understand the implementation even as I wrote it. =)
13:01:12 <merijn> Philonous: I think edwardk's "exceptions" library is now the preferred library for lifting exception handling
13:01:14 <dmwit> just followed the types
13:01:21 <Philonous> dmwit, I'm pretty sure implementing it is easy. Once you know what it's supposed to do
13:01:32 <dmwit> Philonous: I still don't know what it's supposed to do.
13:01:37 <dmwit> Philonous: Also, I found implementing it easy.
13:01:51 <dmwit> Philonous: So knowing what it's supposed to do may be a sufficient condition, but it definitely isn't necessary.
13:01:55 <merijn> Philonous: Which library?
13:02:09 <Philonous> merijn, So the explanation is "something with exceptions" That's actually more helpful than the documentation.
13:02:35 <merijn> Philonous: MonadBaseControl, afaik is to lift exception handling, I forgot which library it's from, though. So I'm not sure
13:02:54 <Philonous> It's from monad-conrol
13:03:28 <Philonous> merijn, Actually, what I want to do is lift monad-logger actions through forkIO.
13:03:36 <merijn> Philonous: "This package defines the type class MonadBaseControl, a subset of MonadBase into which generic control operations such as catch can be lifted from IO or any other base monad."
13:03:53 <merijn> Philonous: So yes, exception handling. Though I would recommend just using exceptions for that :)
13:04:17 <merijn> I don't see any rank 3 types, though
13:04:35 <merijn> Just rank 2 :)
13:04:39 <Philonous> merijn, liftBaseWith is rank 3
13:05:54 <merijn> Philonous: What would you expect lifting through forkIO to do?
13:07:43 <Philonous> merijn, LoggerT is just a specialised ReaderT. What I want is basically \m -> do{ st <- ask; liftIO ( forkIO $ runStateT m st) }
13:08:27 <Philonous> I guess I'll just implement it by hand. I thought one of the Classes allowed me to do that in a more principled way.
13:09:05 <merijn> Philonous: I think explicitly passing is the cleanest way to do this, tbh
13:09:43 <Philonous> s/runStateT/runReaderT *
13:11:20 * hackagebot tamper 0.1.0.1 - An HTML templating system similar to Blaze, implemented as a monad transformer of sorts  http://hackage.haskell.org/package/tamper-0.1.0.1 (TobiasDammers)
13:12:15 <Philonous> I I'll do that, then.
13:14:42 <Philonous> merijn, Ohhh, now I got it. MonadBaseControl does actually capture that pattern.
13:15:17 <rhaps0dy> uhm
13:15:21 <rhaps0dy> anyone here uses gentoo?
13:15:46 <rhaps0dy> I emerged cabal but it's not anywhere in the path
13:15:47 <Punga> >install gentoo
13:15:56 <Philonous> merijn, Well, not quite. But close enough.
13:15:58 <michi7x7> rhaps0dy: there is #gentoo-haskell
13:16:00 <rhaps0dy> nor I could see the binary in the installed objects list
13:16:03 <rhaps0dy> michi7x7: thanks
13:16:12 <Freundlich> rhaps0dy: You need cabal-install
13:16:21 * hackagebot tamper 0.1.0.2 - An HTML templating system similar to Blaze, implemented as a monad transformer of sorts  http://hackage.haskell.org/package/tamper-0.1.0.2 (TobiasDammers)
13:16:33 <rhaps0dy> Freundlich: thanks
13:16:45 <rhaps0dy> Punga: what's wrong with yopu
13:18:01 <Punga> rhaps0dy: Sorry, I just couldn't hold myself. You now, /g/ will get into your brain.. :D
13:18:25 <rhaps0dy> Punga: >yfw I installed gentoo because of /g/
13:18:29 <rhaps0dy> >yfw I don't regret it
13:18:38 <rhaps0dy> join #installgentoo @ irc.installgentoo.com and become cancer with us
13:18:58 <Punga> I wanted to become cancer with you.
13:19:10 <rhaps0dy> :)
13:19:13 <corgifex> http://ultronbrowser.info/
13:19:36 <rhaps0dy> heh
13:19:40 <Punga> But then I realised I can use all that brain power to learn Haskell.. So, that's why I am here. I also am gamer, which is not what cancer is good for.
13:19:58 <John_Ripper> "Ultron is scientifically proven to run up to 25% faster when run in pink. Use it in pink now!"
13:20:06 <John_Ripper> o.O
13:21:34 <rhaps0dy> Punga: yeah gen2 is a bitch to install the first time
13:21:46 <rhaps0dy> especially because the handbook is overcomplicated
13:22:32 <identity> I was planning on installing gentoo. got the kernel compiled, everything ready, for the most part. Just seems my wifi driver is functored. Think it's picking up the wrong one(nearly same device). Then suddenly school work.
13:23:02 <rhaps0dy> identity: you know you can continue it later D:
13:23:25 <identity> rhaps0dy: I was not aware of this.
13:23:46 <identity> rhaps0dy: Yes, it's on my other partition, waiting for me to tickle it.
13:24:10 <rhaps0dy> yummy
13:24:11 <identity> this is probably more #haskell-blah
13:24:16 <identity> though
13:24:21 <rhaps0dy> but there's nobody speaking anyways
13:24:33 <rhaps0dy> whatever, I'm honestly not happy with it but installing it is an experience
13:24:37 <identity> Do not test the Gods.
13:24:48 <rhaps0dy> lambdabot: lambda.. god ?
13:26:16 <Punga> rhaps0dy: Why are you not happy with it?
13:26:22 * hackagebot first-class-patterns 0.3.2.1 - First class patterns and pattern matching, using type families  http://hackage.haskell.org/package/first-class-patterns-0.3.2.1 (BrentYorgey)
13:27:07 <ReinH> identity: your wifi driver is has... become a mapping between categories that preserves identity and composition?
13:27:07 <rhaps0dy> Punga: because I don't like having to work for my system much
13:27:12 <rhaps0dy> and sometimes it borks
13:27:17 <rhaps0dy> nah, it's good really
13:27:19 <smiller2> merijn: I suspect the reason it's unsafe is that 1) deconstructing can violate continuity, since you can convert a discrete value as input from a wire to an output at a discrete point in time (conceptually equivalently as part of a list of time and value pairs), 2) constructing events will let you construct these discrete values in time from continuous values, each time the continuous wire is stepped.
13:27:20 <rhaps0dy> just, sometimes
13:27:46 <rhaps0dy> but that's what you get if you want the cool nvidia drivers
13:27:52 <rhaps0dy> and compatibility with other things
13:27:59 <smiller2> merijn: My two confusions then are 1) is it ever possible to guarantee that no events are missed / discarded? 2) since you can only use asSoonAs :: Wire … (Event a) a to convert discrete to continuous by always returning the last event (hence #1; it's just the last event), how would you handle things like storing user input from a keyboard somewhere, where you'd respond to each key press and append to a string storing the user's na
13:28:00 <Punga> go windox
13:28:00 <identity> ReinH: I got scolded for using the other f-word once by some dude in here, though it was not being used copiously, so I #haskell'd it.
13:28:10 <rhaps0dy> Punga: that's several orders of magnitude worse
13:28:12 <rhaps0dy> no thanks
13:28:34 <rhaps0dy> I only use windows to check if the assignments for one of my courses compile in msvc
13:28:52 <Punga> I use windows cause I'm just 16 and I have lot of friends who play games and they want to play with me.
13:29:06 <Punga> And I don't want to hurt them by getting leenox.
13:29:06 <rhaps0dy> Punga: good for you
13:29:25 <identity> Punga: They are not mutually exclusive, y'know.
13:29:32 <Dtgr> 16 was the age when I moved away from windows. Never looked back :)
13:29:55 <Philonous> You guys do realize this channel is for discussing the Haskell programming language?
13:30:13 <Punga> We discuss platform on which we can run haskell.
13:30:14 <rhaps0dy> Philonous: but nobody is discussing it, but alright we'll shut up unless it's haskell-related
13:30:18 * identity suggested #haskell-blah before
13:30:50 <Philonous> rhaps0dy, That's what #haskell-blah is for.
13:31:15 <Punga> See ya there guys.
13:31:48 <absence> does anyone know the status of the upcoming haskell platform release? i got the impression that it was all on hold waiting for ghc 7.8, but it's been quiet since its release
13:31:56 <hellen_haskeller> ##programming is pretty liberal
13:32:43 <identity> absence: As I understood it, it was set for sometime in may
13:32:50 <identity> so it should be sono
13:32:56 <identity> soon(TM)?
13:33:44 <absence> that's good to hear, thanks :)
13:36:44 <merijn> absence: I saw some noise on the mailing list to start the release process up again
13:36:54 <robde> hello, what kind of language class does Haskell belong to? Is it context-sensitive?
13:37:39 <johnw> robde: ?
13:37:52 <merijn> johnw: I think he's referring to the Chomsky hierarchy
13:38:12 <merijn> regular language, context-free, context-sensitive and whatever the 4th one was
13:38:24 <merijn> Pretty sure Haskell, like most languages, is context-sensitive
13:38:25 <quchen> recursively enumerable
13:38:47 <merijn> Right
13:38:56 <robde> c++ is not, apparently
13:38:58 <smiller2> onEventM :: Monad m => (a -> m b) -> Wire s e m (Event a) (Event b) "Each time the given event occurs, perform the given action with the value the event carries. The resulting event carries the result of the action. " — Uh, *that*'s in Unsafe.Event?  How does that violate continuous time semantics?
13:39:34 <robde> https://stackoverflow.com/questions/14589346/is-c-context-free-or-context-sensitive
13:40:40 <glosoli> How often are haskell-platform packages updated ?
13:41:10 <merijn> glosoli: Usually 3-4 times per year, but the next release has been stalled on the GHC 7.8 release
13:41:38 <glosoli> But Ghc 7.98 is considered stable atm ?
13:41:46 <glosoli> 7.8"
13:42:18 <benzrf> how are comonads useful?
13:42:24 <quchen> Yes. Even numbers after the first dot are stable releases, glosoli.
13:42:26 <merijn> glosoli: GHC 7.8 is stable (all even numbered GHC release are stable), but not all libraries have been updated yet, I guess
13:42:46 <merijn> benzrf: The opposite way that monads are useful? :>
13:43:00 <glosoli> merijn: so if I want GHC 7.8 on mac, I suppose I should wait for haskell platform update ?
13:43:39 <johnw> benzrf: that question is pretty much impossible to answer; what you want to ask is, are there any examples of useful types which implement Comonad?
13:43:42 <merijn> glosoli: Naah, I use 7.8 on OSX nor problem
13:43:49 <glosoli> merijn: may I ask you, how?
13:43:49 <benzrf> johnw: :P
13:43:50 <td123> glosoli: depends if you want to use 7.8
13:43:53 <benzrf> johnw: ok, can you answer that q?
13:43:53 <johnw> the Store comonad is useful
13:44:02 <quchen> Zippers too.
13:44:10 <benzrf> Store?
13:44:12 <merijn> glosoli: Well, if you are on OSX 10.9 you can just download the binary release
13:44:14 <benzrf> what type is that
13:44:26 <johnw> (s -> a, s), IIRC
13:44:27 <glosoli> merijn: would it conflict with the current ghc in haskell-plaftorm ?
13:44:41 <merijn> glosoli: It has install instructions, GHC uses a per-version database so different GHC versions don't conflict
13:44:52 <merijn> glosoli: Cabal will just use whichever is first on your path
13:44:59 <benzrf> Store s a = (s -> a, s)
13:45:06 <benzrf> :t duplicate
13:45:07 <lambdabot>     Not in scope: ‘duplicate’
13:45:07 <lambdabot>     Perhaps you meant one of these:
13:45:07 <lambdabot>       ‘replicate’ (imported from Data.List),
13:45:11 <benzrf> p:
13:45:14 <glosoli> merijn: Thanks sir
13:45:19 <merijn> glosoli: I just install too ~/ghc and add ~/ghc/bin to my PATH whenever I want to use 7.8
13:45:21 <quchen> duplicate :: Comonad w => w a -> w (w a)
13:45:26 <benzrf> Store s (Store s a)
13:45:43 <glosoli> merijn: makes sense I suppose, not that I need ghc atm, just was curious how complicated the process of getting it done is
13:45:45 <benzrf> duplicate :: (s -> a, s) -> (s -> (s -> a, s), s)
13:45:46 <benzrf> ?
13:46:06 <johnw> a Store has a "focus", and duplicate yields a Store whose focus is the original Store within a Stores-of-Stores
13:46:21 <benzrf> @_@
13:46:28 <benzrf> ooh.
13:46:43 <benzrf> so the function is being treated as a map?
13:46:54 <quchen> And the other foci are the previous stores focussed at the other elements iirc.
13:46:56 <johnw> it's like a map, just as >>= is like a map
13:47:00 <johnw> but with some additional smarts
13:47:00 <benzrf> kk
13:47:16 <johnw> in >>=, you get to modify the "context"; in =>> you can to reference the "context"
13:47:29 <benzrf> aha
13:47:46 <benzrf> not forming an intuition >.>
13:47:50 <benzrf> oh well, takes time i suppose
13:47:59 <johnw> yes, you need to first start with concrete examples
13:48:06 <johnw> the "classic" is that of pixel dithering, which is a great example
13:48:08 <benzrf> o=
13:48:17 <johnw> where you want to mutate a picture by blending each pixel with its surrounding neighbors
13:48:26 <johnw> Comonads can abstract that pattern beautifully
13:49:04 <johnw> in that case, the Store is the picture, and the focus is the pixel
13:49:53 <johnw> when you "duplicate", you create a meta-picture, whose every "meta-pixel" is the original picture focused on a different pixel
13:50:37 <johnw> when, as you blend each such picture down to a single pixel again (i.e., the blending process), your result is a new picture with each pixel blended into its original neighbors
13:52:31 <benzrf> o:
13:52:32 <Marquis> hey guys i got a problem with the k means vector algorith which you can find here on github: https://github.com/alpmestan/kmeans-vector
13:52:33 <benzrf> oooooh
13:52:55 <benzrf> so comonads are a solution to computations that modify part of a structure but rely on the rest
13:52:58 <benzrf> ?
13:53:07 <Marquis> i tried to compile the test module but i always get a type error that  Expected type: [Point a1]       Actual type: [V.Vector Double]
13:53:42 <Marquis> can somebody explain why i get that error and how i can fix it maybe?
13:54:00 <johnw> benzrf: they can modify a single point within the structure, while referring to the whole of the structure
13:54:02 <quchen> Marquis: What's the exact error?
13:54:06 <johnw> :t (=>>)
13:54:07 <lambdabot>     Not in scope: ‘=>>’
13:54:07 <lambdabot>     Perhaps you meant one of these:
13:54:07 <lambdabot>       ‘>>’ (imported from Control.Monad.Writer),
13:54:22 <quchen> (=>>) :: Comonad w => w a -> (w a -> b) -> w b
13:54:31 <johnw> thank you
13:54:41 <benzrf> cool.
13:54:50 <benzrf> sooooo
13:54:50 <johnw> benzrf: as you can see, the function being applied is passed the original "w a" as its argument
13:54:58 <benzrf> ok how about
13:55:03 <benzrf> on list...
13:55:05 <johnw> note that the *focus* of this w a, in the case of Store, will vary at each call
13:55:12 <benzrf> duplicate :: [a] -> [[a]]
13:55:15 <johnw> lists are not comonads
13:55:19 <benzrf> they arent?
13:55:21 <johnw> no
13:55:23 <benzrf> oh right ofc
13:55:26 <benzrf> durp
13:55:26 <johnw> define 'extract' for [] :)
13:55:36 <benzrf> yeah i thought that earlier then forgot
13:55:37 <benzrf> >.>
13:55:38 <johnw> now, infinite lists are
13:55:51 <johnw> and in fact, there are useful examples of comonads in the case of infinite lists
13:56:01 <johnw> benzrf: http://blog.sigfpe.com/2006/12/evaluating-cellular-automata-is.html
13:56:06 <quchen> Infinite lists are a special case of non-empty lists. :-)
13:56:31 <johnw> NonEmpty can be a Comonads, couldn't it
13:56:35 <johnw> could be a Comonad*
13:56:40 <quchen> It is, I think.
13:56:46 <quchen> I mean, it actually is :-)
13:56:54 <benzrf> thats what i thought :O
13:56:56 <johnw> duplicate :: NonEmpty a -> NonEmpty (NonEmpty a)
13:57:07 <benzrf> i was thinking something like
13:57:14 <benzrf> duplicate l = l <$ l
13:57:38 <quchen> extract = head, duplicate = tails
13:57:46 <n-dolio> NonEmpty = Cofree Maybe
13:57:50 <quchen> Or something like that.
13:57:56 <benzrf> :t tails
13:57:57 <lambdabot> [a] -> [[a]]
13:57:59 <benzrf> ah
13:58:04 <benzrf> > tails [1, 2, 3
13:58:05 <benzrf> > tails [1, 2, 3]
13:58:06 <lambdabot>  <hint>:1:15:
13:58:06 <lambdabot>      parse error (possibly incorrect indentation or mismatched brackets)
13:58:06 <quchen> > tails [1..5]
13:58:07 <lambdabot>  can't find file: L.hs
13:58:07 <lambdabot>  [[1,2,3],[2,3],[3],[]]
13:58:16 <prophile> http://hackage.haskell.org/package/comonad-4.2/docs/src/Control-Comonad.html#Comonad
13:58:19 <johnw> ah
13:58:22 <quchen> duplicate = "tails without nil at the end"
13:58:31 <benzrf> w8
13:58:32 <johnw> n-dolio: is extend over NonEmpty a paramorphism?
13:58:46 <benzrf> man i should beat myself over the head with the comonad lawd
13:58:47 <benzrf> *laws
13:58:48 <benzrf> >.<
13:59:00 <benzrf> but yes this is looking kind of zipper related
13:59:06 <benzrf> p:
13:59:24 <prophile> infinite lists are represented by the naturals, so iirc any monoid on the naturals gives you a comonad instance
13:59:38 <deni> what's the policy for tabs vs spaces with haskell?
13:59:48 <johnw> most everyone hates tabs
13:59:49 <n-dolio> johnw: I'm sure you could write it as a paramorphism.
13:59:53 <prophile> tabs are punishable by crushing
13:59:55 <johnw> the ones who don't, we take out back during ICFP
13:59:57 <Cale> deni: Spaces only
14:00:20 <ion> Spaces only unless you are joeyh
14:00:40 <johnw> if you want to use tabs, make them 1 character wide and use only tabs, everywhere.  then replace them by spaces
14:00:55 <n-dolio> You don't really need to, though. It just makes it easier.
14:01:14 <benzrf> deni: i use tabs in py & rb, but i use spaces in hs
14:01:23 <johnw> n-dolio: I was remarking to myself how much extend resembles a paramorphism; but in the NonEmpty case, it's just obvious
14:01:24 <Cale> It's possible to use tabs, but you need to be aware that 1) The compiler will treat them as aligning to the next multiple of 8 spaces so you should probably configure your editor to do the same, and 2) anyone who has to work on your code will hate you.
14:01:38 <benzrf> Cale++
14:01:54 <ion> benzrf: You don’t mind everyone in Python and Ruby communities hating you but you don’t want us to hate you?
14:02:00 <benzrf> :P
14:02:10 <benzrf> i think haskell is on another level wrt tabs
14:02:15 <benzrf> 1. indentation is non semantic in rb
14:02:29 <benzrf> 2. indentation in py, when semantic, only requires +1 step
14:02:47 <benzrf> 3. indentation in hs may vary by 1sp based on visual alignment
14:03:11 <benzrf> in py, any situation with visual alginment will not be semantically fucked if your tabs are not 8sp
14:03:19 <benzrf> in haskell, it wil
14:03:21 <benzrf> *will
14:03:54 <n-dolio> johnw: Paramorphism would be: (f (Mu f, r) -> r) -> Mu f -> r, though. extend is more limited.
14:04:01 <n-dolio> As a basic building block, at least.
14:04:03 <quchen> deni: I've written about this in my FBUT. https://github.com/quchen/articles/blob/master/fbut.md#tabs-vs-spaces
14:04:15 <johnw> n-dolio: ah, thank you
14:04:30 <johnw> the paramorphism "carries along" the accumulator
14:04:43 <johnw> but extend only lets you yield a 'b' for every 'w a'
14:04:55 <johnw> and it must result in a 'w b'
14:05:25 <n-dolio> Yeah.
14:05:55 <n-dolio> Paramorphisms give you the recursive results and the portion of the input used to compute that result.
14:06:54 <n-dolio> extend gives you some view of the input and asks you for a new local value based on that view.
14:06:58 <n-dolio> Or something like that.
14:07:14 <benzrf> so
14:07:31 <benzrf> monads let you modify the overall structure based on the inner value
14:07:42 <benzrf> comonads let you modify the inner value based on the overall structure
14:08:24 <aspidites> just read a blog post and i'm a bit confused about what I read. is it possible to create a type synonym for a typeclass rather than an ADT?
14:08:35 <benzrf> aspidites: i do not think so...
14:08:38 <benzrf> aspidites: what did you read?
14:08:41 <bennofs> aspidites: yes, with a GHC extension
14:08:45 <corgifex> depends on your language extensions
14:08:49 <aspidites> http://lpuppet.banquise.net/blog/2014/05/12/7-startups-part-2-game-rules-definition/
14:08:53 <bennofs> aspidites: it's called ConstraintKinds
14:09:03 <aspidites> or i guess rather a type synonym for a tuple of typeclasses
14:09:07 <johnw> benzrf: very roughly speaking, OK.  But noting that there may be no structure, nor any inner value.
14:09:08 <bennofs> :k Show
14:09:08 <lambdabot> * -> Constraint
14:09:22 <aspidites> specificaly  NonInteractive
14:09:27 <bennofs> @let type ShowAndRead a = (Show a, Read a)
14:09:28 <lambdabot>  .L.hs:144:1:
14:09:28 <lambdabot>      Illegal constraint synonym of kind: ‘Constraint’
14:09:28 <lambdabot>        (Use ConstraintKinds to permit this)
14:09:28 <lambdabot>      In the type declaration for ‘ShowAndRead’
14:09:40 <deni> ok everyone agrees i see...tabs it is! :D
14:09:47 <deni> jk....spaces forever
14:09:49 <rwbarton> what an odd message
14:09:56 <merijn> rwbarton: Why?
14:10:12 <aspidites> bennofs: NonInteractiv was specified in that code, not anything published to hackage
14:10:22 <rwbarton> the error isn't that the constraint synonym has kind Constraint
14:10:24 <merijn> rwbarton: That's completely valid if ConstraintKinds is active
14:10:26 <rwbarton> it's that it is a constraint synonym
14:10:32 <rwbarton> or that it is a type synonym of kind Constraint
14:10:52 <aspidites> ok, so next question, what benefit is there to constraintkinds in conjunction with type synonyms over a transformer stack?
14:10:54 <rwbarton> merijn: Yeah, I'm just quibbling over the wording of the message
14:11:16 <dmj`> is there an easy way to extract the numeric information from a threadId ?
14:11:22 <dmj`> right now I'm doing this: let [x,y] = words $ show a in fromJust (readMaybe y :: Maybe Int)
14:11:27 <merijn> aspidites: You can do really cool things with ConstraintKinds once you use TypeFamilies :)
14:11:41 <dmj`> where a :: ThreadId
14:12:00 <merijn> aspidites: tbh, the transformer stack is probably nicer as a constraint synonym requires all users to enable ConstraintKinds in their code
14:12:01 <benzrf>        
14:12:16 <aspidites> in particular, the author uses that NonInteractive synonym to impose constraints on a custom Game monad which defines askCard, tellPlayer, etc, which seems like Writer and Reader to me
14:12:31 <dmj`> I guess I should just use a different data structure and make ThreadId the key
14:12:59 <aspidites> merijn: its not a library so I doubt that was the author's concern.
14:14:16 <merijn> Oi, I feel ripped off
14:14:31 <merijn> Doesn't 7.8 have typedholes enabled by default?
14:14:45 <ion> It does
14:14:54 <merijn> Oh
14:15:01 <merijn> ghci doesn't do typedholes :\
14:15:18 <ion> It does
14:15:21 <rwbarton> hmm?
14:16:36 <merijn> ion: WHen I load a file with holes I get "54:10: Pattern syntax in expression context: _"
14:16:47 <merijn> ion: Or "50:23: Not in scope: ‘_x’"
14:17:18 <rwbarton> I don't
14:17:29 <rwbarton> Found hole ‘_’ with type: a -- etc.
14:17:34 <ion> rwbarton: ditto
14:18:02 <coppro> hey all, is there a good command-line interaction library? readline is good for just the commands, but is there something that makes it easy to parse arguments and stuff? or should I just run that through something like parsec?
14:19:11 <quchen> coppro: haskeline
14:19:28 <quchen> But that'll still require you to parse things. It's just the command line part.
14:21:29 * hackagebot safe-access 0.1.0.0 - A simple environment to control access to data  http://hackage.haskell.org/package/safe-access-0.1.0.0 (thoferon)
14:22:53 <yorick> hey, I want to take n elements that match a (monadic) predicate from a list, is there a nice way to do this?
14:24:16 <quchen> yorick: filterM?
14:24:26 <dwcook> yorick: take n . filterM p
14:24:39 <quchen> That won't typecheck
14:24:48 <dwcook> Oh sorry, I meant
14:24:49 <quchen> fmap (take n) . filterM p
14:24:50 <shachaf> Of course, take + filterM won't do what you want.
14:24:51 <yorick> hmm, that's not a bad idea
14:24:52 <dwcook> Yes, that
14:25:12 <yorick> shachaf: won't it?
14:25:22 <shachaf> Assuming what you want is to only look at the first n elements that match the predicate.
14:25:40 <quchen> That will do exactly the right thing according to how I read the question.
14:25:46 <dwcook> shachaf: are you talking about how filterM is too strict?
14:25:49 <yorick> no, when I have [1, 2, 3, 4] and my predicate is x /= 3, I want [1,2,4]
14:25:54 <shachaf> It doesn't have to do with strictness.
14:26:02 <merijn> yorick: Right, but what if your list is longer than n?
14:26:03 <yorick> but yeah, I'd preferably not iterate over everything first
14:26:18 <merijn> yorick: filterM *will* iterate over everything
14:26:21 <merijn> Consider:
14:26:24 <merijn> @hackage monad-loops
14:26:24 <lambdabot> http://hackage.haskell.org/package/monad-loops
14:26:32 <yorick> hm, that's ugly
14:26:46 <shachaf> > runWriter . fmap (take 3) . filterM (\x -> tell [x] >> return (even x)) $ [1..10]
14:26:47 <lambdabot>  ([2,4,6],[1,2,3,4,5,6,7,8,9,10])
14:26:57 <napping> compdata looks pretty cool. Does anyone know if they tried a Typeable implementation of their unions, like Oleg's extensible effects?
14:27:18 <napping> They showed some nice benchmark numbers, but they also only had a sum between two functors
14:27:20 <shachaf> You can see that the predicate is run for every element of the list.
14:27:58 <deni> quchen: tnx for the gist. much appreciated
14:28:10 <dwcook> I think Pipes.Prelude's take and filterM would do the trick, actually.
14:28:31 <td123> 15:37:01   barthalion | https://paste.xinu.at/Ab7G/ I guess                                                                                                   │21:12:26           merijn | Oh
14:28:45 <td123> sry
14:29:10 <merijn> dwcook: Sure, but that means learning Pipes first :)
14:29:14 <dwcook> Indeed.
14:29:18 <quchen> merijn: Win-win! :D
14:29:56 <shachaf> merijn: Moreover, it means using pipes.
14:30:29 <napping> merijn: I don't know if it changed recently or I just tried enough times, but I recently read the pipes tutorial again and it made a lot of sense
14:30:30 <shachaf> I'd rather rewrite a few non-composable functions by hand.
14:31:00 <merijn> shachaf: Right, well I kinda assumed that objection was "obvious"
14:31:28 <merijn> napping: It makes a lot of sense, but as shachaf points out using it for just 1 or 2 trivial functions seems rather overkill
14:32:17 <napping> I thought you were worried learning pipes would be hard. That's what I was talking about, not whether it makes sense to actually use it in your case
14:32:58 <napping> I /joined after you mentioned the problem anyway :)
14:33:17 <merijn> It wasn't even for me, I already understand pipes (well, sometimes I understand pipes...)
14:35:49 <quchen> merijn, the Tekmo of dirty Pipes solutions
14:36:22 <dwcook> Isn't Tekmo the Tekmo of dirty Pipes solutions?
14:38:29 <merijn> quchen: I spend 3 days since Friday trying to figure out how to fix my Pipes design, only to figure out my very first one could 1) do it and 2) was ridiculously simpler than everything else I tried >.>
14:38:54 <merijn> In other news, my productivity quadrupled since I stopped wanting dumb things
14:39:13 <coppro> merijn: like?
14:39:26 <quchen> In a year when pattern synonyms are changed entirely none of your code will work anyway ;-P
14:39:53 <merijn> quchen: Actually, this isn't working on that bit
14:39:57 <napping> I remember another question - is there any possibility of using something like the new safe coerce to change an unused type parameter in a GADT?
14:40:00 <merijn> quchen: That parser was like done in 40 minutes
14:40:17 <warpy> @pl \chan -> writeChan chan . Line
14:40:18 <lambdabot> (. Line) . writeChan
14:40:49 <quchen> napping: Learning pipes would maybe be hard if the following didn't exist, http://hackage.haskell.org/package/pipes-4.1.1/docs/Pipes-Tutorial.html
14:40:53 <napping> say, data Test :: Bool -> * -> * where NotVal :: Int -> Test False a; Val :: a -> Test True a  // want Test False a -> Test False b
14:41:28 <napping> quchen: yeah, that helped, and I vaguelly recall old implementations that had more types running around. Also less clear explanations of the upstream/downstream communicationm
14:41:30 <merijn> quchen: I'm now working on a streaming HPP (haskell preprocessor), i.e. full C11 CPP support (well, I'm dropping support for "#pragma" as that's useless in haskell), includign stringification and concat, but with haskell tokenisation and handling MagicHash without ugly hacks
14:42:42 <merijn> quchen: Only incompatibility I see with standard CPP is the inability to write concatenation like "#define CONCAT(a,b) a## b" or stringification like "#define STR(s) foo# s" as those collide with valid MagicHash haskell tokens
14:43:00 <merijn> Although that's easily solved with an option switch and/or warnings (plus not wanting stupid stuff)
14:43:50 <quchen> Those seem unnecessary for Haskell code anyway.
14:44:10 <quchen> You're going for "as CPP as possible while still useful to Haskell", I assume.
14:44:11 <merijn> Not really, stringify and concat are great in haskell code too
14:44:32 <merijn> I've actually desperately need stringify in haskell
14:44:33 <quchen> Hmm.
14:45:08 <merijn> You will just have to either 1) write it as "#define CONCAT(a,b) a ## b" (spaces solve MagicHash ambiguity) or 2) disable MagicHash support
14:45:19 <quchen> I often wonder whether a dedicated HaskellPP would be a better solution. CPP is always very makeshifty. Makeshiftier than necessary, I mean.
14:45:38 <merijn> quchen: I don't think CPP is that bad for what it does
14:46:16 <corgifex> "... tokenize C"
14:46:30 <quchen> It certainly isn't for C, but in Haskell you often have secial needs, different reserved symbols etc.
14:46:36 * hackagebot gray-code 0.3 - Gray code encoder/decoder.  http://hackage.haskell.org/package/gray-code-0.3 (SergeyAstanin)
14:46:45 <merijn> quchen: Right, hence why I said "with Haskell tokenisation"
14:46:59 <corgifex> and haskell stringification :-)
14:47:11 <merijn> coppro: What does haskell stringifcation mean?
14:47:52 <corgifex> not using octal escapes, for example
14:48:20 <merijn> I don't see how that relates to stringification?
14:48:25 <corgifex> C "\012" == Haskell "\10"
14:48:43 <merijn> corgifex: Right, how does that relates to stringification?
14:48:55 <corgifex> stringification produces string literals
14:49:14 <merijn> '#define STR(s) #s\nSTR(foo)' -> '"foo"'
14:49:15 <corgifex> if you produce strings according to C rules, you may get something different in Haskell
14:49:25 <merijn> corgifex: Stringifcation does not do escaping at all
14:49:37 <merijn> It just adds quotes around a token
14:49:44 <corgifex> that sounds rather wrong
14:49:47 <merijn> Why?
14:49:56 <corgifex> so I can inject code via STR(\) ?
14:50:43 <merijn> corgifex: No, because that's valid string literal
14:50:56 <corgifex> "\" ?
14:51:36 * hackagebot yesod-s3 0.1.1 - Simple Helper Library for using Amazon's Simple Storage Service (S3) with Yesod  http://hackage.haskell.org/package/yesod-s3-0.1.1 (TvH)
14:51:43 <zzzzzzzziiii> ifZero = \k -> get >>= \s -> if s == 0 then fst k else snd k -- how can i test it in ghci? like give it an initial state and a tuple like (print "A", print "B")
14:52:28 <merijn> corgifex: Funny, I just tested in clang and it actually handles it wrong
14:52:32 <merijn> corgifex: "Otherwise, the original spelling of each preprocessing token in the argument is retained in the character string literal, except for special handling for producing the spelling of string literals and character constants: a \ character is inserted before each " and \ character of a character constant or string literal (including the delimiting " characters), except that it is implementation-defined whether a \ character is inserted before the \ c
14:53:19 <corgifex> cut off at "is inserted before the \ c"
14:53:42 <merijn> "the \ character beginning a universal character name."
14:54:23 <corgifex> how does clang get it wrong?
14:55:05 <merijn> Actually, I'm not sure whether it's wrong now. "STR(\)" produces a warning "invalid string literal" and produces "" as result
14:55:53 <corgifex> that sounds correct
14:56:12 <corgifex> \ is definitely not a token in C (but it probably is a preprocessing token)
14:56:34 <napping> Roles are not polymorphic, are they?
14:56:52 <merijn> oh
14:56:55 <merijn> "If the replacement that results is not a valid character string literal, the behavior is undefined."
15:01:17 <corgifex> aww, trigraphs are already gone at this stage
15:02:41 <benzrf> good lord what are we talking about
15:04:16 <corgifex> the finer points of lexing C
15:04:54 <corgifex> so I think it would make sense to unconditionally escape \
15:05:50 <blaenk> how can I intercalate "." in a list only if the preceding item doesn't end in "z", so ["az", "bx", "cy"] becomes "azbx.cy" ?
15:06:33 <blaenk> or more generalized, interclate only if the preceding element satisfies a condition
15:07:30 <phooby> hi! in real world scenarios, how much code are you trying to keep out of io monad? let's say that i have a function which performs some validations on its inputs (returning either) and then performs an io operation on the data (add to db, save file or such). now, it'd be handy to just use eg. guards to do the validation but the problem is that now the validations are inside the io monad even though they are "pure". any thoughts about th
15:08:09 <blaenk> don't see why validations should have to be in io monad?
15:08:16 <napping> guard works fine in Either
15:08:32 <blaenk> any MonadPlus
15:09:29 <phooby> they don't have to be, but it seems a bit artificial to break the function into validateOperation + doOperation functions instead of using just guards and doing the operation
15:09:46 <phooby> that's why i'm asking, in real world scenarios, how are ppl doing it
15:09:50 <awestroke> blaenk: I want to say a fold
15:09:52 <blaenk> like that, breaking it up
15:09:58 <blaenk> thanks awestroke just now I realized that ;)
15:09:59 <Marquis> quchen++
15:10:18 <corgifex> :t let foo [] = []; foo [x] = x; foo (x : xs) = bar x (foo xs); bar "z" a = a; bar [] a = '.' : a; bar (x : xs) a = x : bar xs a in foo
15:10:19 <lambdabot> [[Char]] -> [Char]
15:10:29 <blaenk> corgifex: thanks!
15:11:41 <phooby> blaenk, hmm. ok. thanks :)
15:11:55 <blaenk> yeah, breaking it up is still beneficial because it lets you reason about that piece of code better
15:12:23 <Marquis> i got a data type Token and can now convert it to token vector which looks like this : x :: V.Vector Token.         Now i want to convert it to Vector Double. How can i do it?
15:12:47 <c_wraith> that's not converting it to any type
15:12:58 <phooby> it's true... i'm just wondering where ppl are generally drawing the line in real world (eg. when it's just too "trivial" to put the validation outside of the io monad func)
15:13:05 <c_wraith> oh, you mean you have some other expression that can do that conversion.
15:13:29 <c_wraith> Marquis: how do you convert a single Token to a Double?  Combine that with V.map
15:13:55 <napping> phooby: If you have some kind of (a -> Bool) you could used with guard, it sounds like the bulk of the validataion is already outside IO
15:14:15 <tremon> for what I'm writing now (small binary datafiles with checksum), I only do the read+checksum inside IO. Validation and binary parsing is done on ByteString
15:14:51 <napping> phooby: If I wanted to do something like gather multiple warnings from multiple validation failures I might use a different monad to help with that
15:16:50 <phooby> napping, ah. i think i misrepresented my question. i was trying to ask, when you put the validation logic outside the function that lives inside io monad and when you just toss the validation logic inside the function and forget about trying to keep as much code as possible out of io
15:16:51 <mgsloan> phooby: Personally, I don't think it should mather whether you include the validation in your IO function or not - just a matter of organization.
15:17:13 <napping> phooby: I don't think that really counts as keeping code out of IO
15:17:22 <mgsloan> phooby: Afterall, the parameter to guard is pure.
15:17:27 <napping> as long as a subexpression of a do block doesn't involve IO, it's still pure code
15:17:41 <phooby> hmm
15:17:42 <mgsloan> yup!
15:17:50 <guymann> hi
15:17:51 <napping> so do x <- getStuff; guard (bigComplicatedValidation x); return x
15:17:55 <napping> is still pure validation
15:18:38 <mgsloan> If you really want to make it obvious to the reader that it's a pure validation, it could be useful to put it in a where clause with a type sig, or as another function
15:18:57 <phooby> yeah... but keeping the validations in the io code affects eg. testability, right? if validations live in a pure function i can test those separately
15:19:22 <napping> If you split them out into a separate function that you call in guard, that's testable
15:19:37 <mgsloan> phooby: Right, that's a good point - if you need to use it multiple places, certainly split it out
15:19:56 <mgsloan> If you want to be able to call it from ghci when messing with the code, then that's another reason
15:20:49 <phooby> msg, ok :)
15:21:25 <phooby> so overall, however, it wouldn't be considered as bad haskell style to just use the guards if i don't need to reuse the validation logic?
15:21:37 <acowley> A type that doesn't admit hanky panky should be all the reason you need.
15:22:03 <phooby> (ie. keep code in the io monad)
15:22:35 <phooby> i'm writing a web server/processing app and so much of the functions just live in io monad. trying to find the balance. :)
15:22:38 <mgsloan> phooby: In my opinion and practice, yes!  I think this can make the code easier to follow, unless it makes the overall function too large
15:22:55 <andreipmbcn> Hi. Sorry for bothering everyone. Is there no way at all to remove a String from an IO String? Do I have to rewrite my functions so they take IO String arguments instead of String arguments?
15:23:28 <phooby> mgs, alright, thanks for the opinion! most appreciated. :) i'm trying to develop my sense of good style
15:23:53 <nexx> andreipmbcn why not (>>=)?
15:23:59 <quchen> andreipmbcn:  String is a chain of characters, "IO String" is the description of how to generate a string of characters. You can't get the cake out of a recipe.
15:24:49 <Javran> This is possible to make "cabal repl" ignore my .ghci file?
15:24:50 <andreipmbcn> nexx, I'll try that, though I'm not sure how to turn (map fnc IO_monad) into IO_monad >>= map fnc ...
15:25:35 <dcoutts> Javran: use --ghc-option=--no-dotghci or whatever the ghc flag is (there is one but I forget the exact name, check the ghc user guide)
15:25:57 <mgsloan> phooby: Welcome! I work on stuff like that myself, and admittedly most of the code ends up living in some MonadIO or another.  As SPJ said, Haskell is "the world's finest imperative programming language", so I don't feel too bad about most of my functions starting with a stateful "do"
15:26:16 <acowley> Luckily, Identity "cake" is a comonad.
15:26:38 <Javran> dcoutts: I see, thanks!
15:26:40 <nexx> andreipmbcn mapM?
15:26:43 <benzrf> andreipmbcn: i dont think you get the point of purity =p
15:27:09 <aspidites> what do you guys usually read once you're done reading whatever is new on reddit (assuming you go there at all)?
15:27:22 <andreipmbcn> nexx, thanks. I'll try that and read the documentation for further information.
15:27:27 <awestroke> hmm, can I define a Monad instance using only Applicative functions?
15:27:33 <quchen> No.
15:27:40 <benzrf> awestroke: try it
15:27:41 <acowley> aspidites: TAPL
15:27:48 <benzrf> awestroke: bind is equivalent to join and fmap
15:28:00 <benzrf> you can define ap in terms of join and fmap, but not vice versa
15:28:10 <quchen> Monads are more restrictive than Applicative. Not all Applicatives are Monads, so you cannot in general write Monad using only Applicative.
15:28:19 <andreipmbcn> benzrf, actually, I probably don't. I thought "purity" meant "not having side effects", and a function that extracts the value of a monad doesn't sound like it has side effects.
15:28:22 <aspidites> andreipmbcn: the book?
15:28:26 <bitemyapp> aspidites: https://gist.github.com/bitemyapp/8739525#type-and-category-theory-not-needed-to-actually-write-haskell-just-for-those-interested
15:28:33 <felixn> QUICK!  parsec or peggy?  I'm more familiar with PEG, but... I could just easily learn parsec
15:28:33 <benzrf> andreipmbcn: what?
15:28:39 <bitemyapp> felixn: parsec
15:28:42 <awestroke> benzrf: but I've read that you can do (<*>) = ap
15:28:45 <felixn> BOOM! there we have it
15:28:47 <benzrf> andreipmbcn: 'extracts the value of a monad' is a notion you must purge from your brain!
15:28:52 <felixn> bitemyapp: ty
15:28:57 <benzrf> andreipmbcn: monads MAY OR MAY NOT have a value in them
15:28:57 <phooby> mgs, cool to meet another appreciator of aesthetics ;)
15:29:02 <benzrf> andreipmbcn: or they may have multiple!
15:29:11 <benzrf> andreipmbcn: have you seen the monad instance on lists?
15:29:12 <benzrf> on maybe?
15:29:15 <benzrf> on functions?
15:29:19 <jle`> awestroke: ap requires Monad
15:29:26 <andreipmbcn> aspidites: the hoogle reference. http://hackage.haskell.org/package/base-4.7.0.0/docs/Control-Monad.html
15:29:30 <jle`> :t ap
15:29:31 <lambdabot> Monad m => m (a -> b) -> m a -> m b
15:29:34 <jle`> @src ap
15:29:34 <lambdabot> ap = liftM2 id
15:29:37 <aspidites> bitemyapp: sweet. bookmarked and reading
15:29:39 <benzrf> andreipmbcn: furthermore, 'IO String' represents an 'action' that, when run, results in a string
15:29:47 <benzrf> andreipmbcn: to get a String out, youd need to run the action
15:29:50 <benzrf> and that's effectful!
15:30:00 <benzrf> andreipmbcn: technically, there IS:
15:30:04 <awestroke> :t join.fmap
15:30:05 <lambdabot>     Occurs check: cannot construct the infinite type: f ~ (->) (f a)
15:30:05 <lambdabot>     Expected type: (a -> b) -> f a -> f a -> b
15:30:05 <lambdabot>       Actual type: (a -> b) -> f a -> f b
15:30:05 <benzrf> :t unsafePerformIO
15:30:06 <lambdabot> Not in scope: ‘unsafePerformIO’
15:30:10 <benzrf> but using it is a terrible, terrible idea
15:30:15 <benzrf> :t IO.Unsafe.unsafePerformIO
15:30:16 <lambdabot> Not in scope: ‘IO.Unsafe.unsafePerformIO’
15:30:18 <quchen> So is mentioning it to beginners.
15:30:18 <benzrf> hmm
15:30:20 <awestroke> :t join . flip fmap
15:30:21 <benzrf> :t System.Unsafe.unsafePerformIO
15:30:21 <lambdabot> ((a -> b) -> a) -> (a -> b) -> b
15:30:22 <lambdabot> Not in scope: ‘System.Unsafe.unsafePerformIO’
15:30:24 <jle`> unsafePerformIO doesn't really fit the semantic model of what IO is supposed to represent
15:30:30 <benzrf> shit, i dont remember where unsafe is
15:30:45 <guymann> watch your language
15:30:46 <sakirious> quchen: To be fair, unsafe is mentioned in the first or second link on Google
15:30:49 <jle`> so...i feel like it is a bit out of place
15:30:54 <aspidites> andreipmbcn: i think python spoiled me. i don't generally enjoy reading haddocks -- the pipes tutorial being an exception
15:30:56 <mgsloan> System.IO.Unsafe
15:31:04 <bitemyapp> aspidites: the pipes tutorial is fantastic.
15:31:24 <felixn> bitemyapp: one more thing... why is there parsec, parsec2, parsec3? >_<
15:31:31 <mgsloan> I guess it's a good sign to forget where unsafePerformIO is :)
15:31:34 <felixn> or, what should I choose
15:31:58 <mmachenry> aspidites: Which pipes tutorial?
15:32:03 <u-ou> :t unsafePerformIO
15:32:04 <lambdabot> Not in scope: ‘unsafePerformIO’
15:32:09 <quchen> Pipes.Tutorial module in the pipes package, mmachenry
15:32:19 <u-ou> @hoogle unsafePerfomIO
15:32:19 <lambdabot> No results found
15:32:23 <u-ou> @hoogle unsafePerformIO
15:32:24 <lambdabot> System.IO.Unsafe unsafePerformIO :: IO a -> a
15:32:24 <lambdabot> Foreign unsafePerformIO :: IO a -> a
15:32:34 <andreipmbcn> benzrf: On IO String being an action, that's great, which is why I want to eventually run the action and get a string out of it. Surely it would make sense to have a "getString :: IO String -> String" just as lists have a "head" etc. I can't see what's special about the IO monad.
15:32:58 <bitemyapp> andreipmbcn: you don't need what you want
15:32:58 <aspidites> i think this sums up why -> http://jacobian.org/writing/what-to-write/
15:33:03 <jle`> andreipmbcn: one way to think about it is that an IO Int is just any old data structure, that contains instructions for a cpu to compute a Int using its i/o and all that fun stuff.
15:33:24 <u-ou> when would you ever need or want IO a -> a
15:33:24 <aspidites> mmachenry: http://hackage.haskell.org/package/pipes-4.1.1/docs/Pipes-Tutorial.html
15:33:30 <benzrf> 06:27 < benzrf> andreipmbcn: to get a String out, youd need to run the action
15:33:30 <benzrf> 06:27 < benzrf> and that's effectful!
15:33:31 <jle`> technically, it would be possible to write an IO String -> String if you implemented a pure cpu emulator with simulated pure input/output
15:33:35 <benzrf> andreipmbcn: look
15:33:41 <benzrf> :t getLine
15:33:42 <lambdabot> IO String
15:33:47 <jle`> typically, we compile the IO object to assembly, and the actual computer executes it for us
15:33:56 <benzrf> getLine is a value that, if run, would result in a String
15:34:08 <benzrf> let's say i have a function 'runIO' of type 'IO a -> a
15:34:10 <andreipmbcn> u-ou: when I have a function that takes a String and returns a String. But I assume >>= would work here.
15:34:11 <benzrf> and i do
15:34:17 <benzrf> runIO getLine
15:34:17 <shachaf> andreipmbcn: It has nothing to do with being a monad.
15:34:20 <benzrf> that results in a line of input
15:34:23 <benzrf> and that's effectful
15:34:51 <u-ou> I really like the idea of actions as values
15:34:54 <jle`> IO String -> String doesn't make too much sense because IO String is just a normal inert data structure representing a computation that a computer can execute.  but haskell doesn't execute anything, it only evaluates.
15:34:55 <shachaf> There's no function :: IO a -> a because there's no such function. Knowing that it's a monad gives you more ability to do things with it, not less.
15:35:02 <aspidites> in otherwords, haskell modules tend to have plenty of reference documentation, but lack in topical guides and tutorials (as mentioned by a reddit discussion a while ago)
15:35:06 <andreipmbcn> benzrf I take your point.
15:35:20 <jle`> u-ou: it opens up a lot of worlds, statements as first-class objects
15:35:25 <shachaf> You "eventually" run the action with e.g. main = do { x <- yourAction; ... }
15:35:34 <u-ou> jle`: indeed
15:35:37 <jle`> it opens up new ways to look at parallelism
15:35:42 <jle`> concurrency
15:35:44 <jle`> etc.
15:36:31 <benzrf> andreipmbcn: to be precise
15:36:40 <benzrf> when you say 'runhaskell Foo.hs'
15:36:49 <benzrf> what happens is that it takes the IO value in the name 'main' and executes it
15:36:54 <jle`> andreipmbcn: when you compile your haskell program, the compiler looks at whatever IO object / whatever data structure representing computer instructions is named "main", and (after evaluationg it) compiles it to assembly, and asks the computer to please execute the instructions that you just specified.
15:37:02 <benzrf> this is the ONLY sanctioned way to get an IO value run!
15:37:17 <benzrf> so what you do is create an IO action that does multiple things, representing the effectful part of your program
15:37:22 <benzrf> said action may call into the pure parts
15:37:34 <sveit> does haskell provide some sort of convenience for type "unwrapping" by pattern matching? I have several layers of (non-trivial) types and it can be tedious to write accessors that go to arbitrary depth every time I need them
15:37:44 <benzrf> 'monad' is just a term for one api available for you to use in order to stick IO actions together
15:38:07 <aspidites> sveit: records
15:38:18 <aspidites> or more popular and practical lens
15:38:19 <Ginto8> sveit: records or lens
15:38:21 <quchen> sveit: No, that's why Lens was created.
15:39:06 <aspidites> if you only need attribute access, you could start with lens-family-core
15:39:09 <awestroke> I'm trying to construct a monad that, rather than stopping execution on errors, stores them in a list and continues... but then "fail" isn't possible, unless the a in ErrorM a is a monoid or something. napping, did you have anything existing in mind when you talked about a monad for this?
15:39:21 <benzrf> awestroke: fail is an ugly hack
15:39:22 <benzrf> ignore fail
15:39:27 <benzrf> awestroke: stick to bind and return
15:39:31 <benzrf> :-)
15:39:44 <Ginto8> fail is also a practical hack
15:40:05 <bitemyapp> Ginto8: your life's dream is to get eviscerated by a pack of rabid Haskell hackers eh?
15:40:10 <awestroke> benzrf: then what do I do with all the fails in the existing code where I want to use this monad?
15:40:14 <quchen> awestroke: Ignore 'fail'. It's not possible to write it for a large amount of monad instances, and largely considered a mistake as part of the Monad class.
15:40:20 <bitemyapp> Ginto8: keep saying nice things about fail.
15:40:21 <jle`> i usually leave the default implementation of fail in.
15:40:54 <quchen> awestroke: See also https://github.com/quchen/articles/blob/master/fbut.md#fail
15:41:05 <aspidites> is fail the new "n+1 pattern" ?
15:41:17 <jle`> trying to use fail to implement special functionality would probably make your code a bit inaccessible/unidiomatic.  but clever of course.
15:41:19 <benzrf> aspidites: worse!
15:41:22 <benzrf> ok not rly
15:42:12 <jle`> n+1 pattern is kind of weird; which (+) is it supposed to refer to? :/
15:42:39 <prophile> iirc it didn't refer to (+) at all
15:42:44 <prophile> actually to (-) and (==)
15:43:00 <awestroke> quchen: ooh, nice repo
15:43:09 <jle`> i frequently do take advantage of existing fail implementations though, because they are probably taken to be understood.  but i don't try to write my own for new monads.
15:43:11 <Ginto8> bitemyapp: I just appreciate practical solutions to thorny problems. Pattern matching failure in bind was one, and fail is a reasonable solution. Types like Maybe and ErrorT can keep their custom failure techniques, and for all else it throws a runtime exception anyway
15:43:35 <aspidites> jle`: http://www.dcs.gla.ac.uk/mail-www/haskell/msg01131.html
15:45:37 <awestroke> the argument works in general, but if I have a monad like "Either String a" and fail makes it a Left value, it fits perfectly. Should I then avoid "fail" for such monads and create my own "fiasco" function: fiasco str = Left str
15:46:30 <jle`> um. some people just expect bad pattern matches to error
15:46:33 <jle`> no matter what
15:46:34 <ReinH> awestroke: you can use the MonadError typeclass
15:46:41 <ReinH> iirc fail is going to be moved into a typeclass itself eventually
15:47:19 <katana756> what is the best haskell tutorial for experienced programmers?
15:47:20 <merijn> Ginto8: I prefer the idea of making partial pattern matches result in a MonadPlus constraint where pattern failure is mzero
15:47:24 <quchen> > "eventually" >>= replicate 3 -- ReinH
15:47:26 <lambdabot>  "eeevvveeennntttuuuaaallllllyyy"
15:47:28 <merijn> katana756: Learn You a Haskell
15:47:30 <jle`> if i do do { Left x <- return (Right 1); return x }
15:47:32 <ReinH> merijn: or that
15:47:44 <ReinH> merijn: I thought there was a MonadFail proposal
15:47:46 <jle`> i'd usually expect it to throw an exception, idk.
15:47:49 <pavonia> katana756: Real World Haskell
15:47:52 <ReinH> quchen: <3
15:47:52 <awestroke> katana756: you imply there could exists some objectively best anything
15:47:57 <quchen> Quchen's quality advice on starting Haskell, https://github.com/quchen/articles/blob/master/fbut.md#how-to-start-learning-haskell
15:48:12 <merijn> katana756: Unless you're already familiar with a functional language like OCaml/F#/SML you're better of not trying to rely on your existing programming background
15:48:29 <jle`> but really you shouldn't try to write anything dependent on the behavior of fail
15:48:43 <jle`> >_> in most cases
15:48:47 <merijn> quchen: Nit pick: "dito" should be "ditto"
15:49:13 <merijn> quchen: Since it's short for "idem ditto"
15:49:17 <jle`> katana756: forget everything you know about programming, it won't help you here :D
15:49:23 <quchen> merijn: Nitpick appreciated, had no idea.
15:49:43 <jle`> you might be able to take along your favorite text editor though
15:50:30 <merijn> ReinH: I won't my breath for MonadFail as long as AMP isn't even implemented yet :p
15:50:39 <merijn> +hold
15:50:47 <ReinH> merijn: not planning on it :)
15:51:38 <merijn> quchen: Also, an even more ridiculously pedantic nitpick :)
15:51:57 <katana756> jle~: :) yes i have tried haskell before.. (years ago)
15:52:17 <awestroke> jle`: yeah, it's not like haskell has functions and types and recursion just like every other language
15:52:19 <merijn> quchen: You mention that evaluating "seq (error "x") (error "y")" can "superficially allow inspection of the evaluation order of seq"
15:52:20 <peddie> katana756: try http://jonathan.tang.name/files/scheme_in_48/tutorial/overview.html
15:52:20 <awestroke> he better forget everything
15:52:37 <jle`> awestroke: functions, types, and recursion are probably different semantically than in most languages
15:52:51 <merijn> quchen: However, haskell allows returning 'error "y"' even IF 'error "x"' is evaluated first :)
15:52:52 <jle`> bringing in what you know about functions, types, and recursion might do more harm than good
15:52:56 <andreipmbcn> To clarify: if I want to "do mapM function [some IO Strings]", "function" must output a monad, so if I have a function that doesn't output to a monad, and want to use it, I must write "do mapM (return nonMonadFunction) [some IO Strings]", correct? This is the issue I was having.
15:53:18 <ReinH> :t mapM
15:53:19 <lambdabot> Monad m => (a -> m b) -> [a] -> m [b]
15:53:19 <awestroke> jle`: thanks for the new perspective
15:53:30 <andreipmbcn> I am wondering whether this is the most elegant way in which I can write this.
15:53:34 <ReinH> andreipmbcn: function must have the type (a -> m b) for some monad m
15:53:35 <merijn> quchen: More specifically, if a term produces an exception it is allowed to produce any arbitrary exception that could potentially result from the term
15:53:37 <ReinH> andreipmbcn: write what?
15:53:49 <quchen> merijn: Hmm. Well that wasn't the point I was trying to make anyway (which was "don't rely on seq evaluation order even if you think you know it"). Maybe I should rephrase it.
15:53:50 <jle`> andreipmbcn: first, if you have [IO String] and you want an IO [String], use sequence
15:54:04 <andreipmbcn> jle` I already did that, but thanks for mentioning it.
15:54:20 <jle`> then you can apply a function to all of those strings using (map . fmap)
15:54:25 <andreipmbcn> ReinH, write the mapping operation in Haskell code.
15:54:33 <merijn> quchen: I know, I'm just being very pedantic, because I think it's a funny piece of info that, e.g. 'case 1 of 1 -> error "foo"; _ -> error "bar"' can result in "error "bar"" :)
15:54:38 <ReinH> andreipmbcn: what do you want the mapping to do?
15:55:17 <awestroke> merijn: wat
15:55:49 <jle`> andreipmbcn: see if you can ask your question in types
15:55:52 <andreipmbcn> ReinH specifically, what the function "function" is? It's a regular expression search.
15:56:08 <awestroke> merijn: that seems extremely incorrect
15:56:10 <quchen> merijn: Wait, now I'm confused again.
15:56:18 <ReinH> andreipmbcn: what are your types?
15:56:29 <tremon> hmm, conceptual problem: I have a datafile consisting of an array of "id base specific" that's represented in Haskell as data C1 Base Spec | C2 Base Spec | ... -- but the datafile is markerless and the specific part is of variable width, so the reading of spec depends on id
15:56:34 <katana756> i have used some scheme and bit of ocaml..
15:57:03 <andreipmbcn> :t mapM
15:57:04 <lambdabot> Monad m => (a -> m b) -> [a] -> m [b]
15:57:17 <jle`> "i have an (String -> b) that i want to apply to every string in IO [String]" ... "so that means (String -> b) -> IO [String] -> IO [b]". or "i have a (String -> IO b) that i want to apply to every string in an IO [String], so that means (String -> IO b) -> IO [String] -> IO [b]
15:57:18 <merijn> awestroke: Actually, it makes sense if you know the reason
15:57:21 <ReinH> tremon: you need a monadic parser to use the value of id to determine how to parse spec
15:57:21 <quchen> merijn: I actually have no idea what the semantics of "error" are, beyond the obvious "break things".
15:57:23 <tremon> however, there are about 200 data id's that map to 4 data enums, so I'd rather not switch on id directly. I already have one 200>4 mapping and that's enough
15:57:52 <merijn> awestroke: The semantics of imprecise exceptions state the following: "When pure code can be shown to evaluate to a set of exceptional values (i.e. the value of  error or undefined, and explicitly not the kind of exceptions generated in IO), then the language permits any value of that set to be returned."
15:58:20 <andreipmbcn> jle` Yeah, I know what you mean. I have an [IO String] on which I want to map a function String -> Int.
15:58:34 <jle`> and you want to get IO [Int], i'm guessing?
15:58:40 <merijn> awestroke: The reason for this being that specifying *which* exception is returned would basically require you to specify an evaluation order for Haskell, which the report painstakingly avoids!
15:58:51 <ReinH> andreipmbcn: what are the types you are working with? What do you already have?
15:58:57 <ReinH> and what do you want to produce?
15:59:03 <tremon> what I'm doing now (more or less) is constructing C1 base empty, and pattern matching on that for parsing the spec part
15:59:10 <awestroke> merijn: so in 'case 1 of 1' , 'case 1 of' can evaluate to some error, which doesn't immediately crash the program but rather put the error in the place of 1?
15:59:14 <quchen> merijn: Do you know where the Report talks about this?
15:59:18 <ReinH> andreipmbcn: do you have an [IO String] and you want an [IO Int]?
15:59:19 <andreipmbcn> jle` I would have preferred an [Int] that I then reconverted to [IO Int], but you claim this is impossible, so I can settle for an [IO Int].
15:59:31 <quchen> merijn: A catchword would be enough
15:59:33 <tremon> that works, but it's not really elegant, so I'm looking for better solutions
15:59:34 <merijn> awestroke: For example, 'f (error "x") (error "y")', should this return the 'x' or the 'y' error? It depends on the order of evaluation, which is not specified
15:59:47 <andreipmbcn> ReinH Yes, that's what I have, that's close to what I wanted.
15:59:50 <jle`> [IO Int] is possible, but it is a little useless because you eventually want to pass a single IO action into main
15:59:54 <awestroke> merijn: but 1 is always 1
16:00:02 <jle`> you want a computation that will compute a list of Int, right?
16:00:09 <merijn> quchen: I don't believe the report deals with exceptions (I only said it doesn't specify evaluation order), for exceptions I think you want: https://research.microsoft.com/en-us/um/people/simonpj/papers/imprecise-exn.htm
16:00:23 <ReinH> :t let u = undefined :: [IO String] in fmap (fmap length) u
16:00:24 <lambdabot> [IO Int]
16:00:24 <tremon> ReinH: for now, the parser is manual code. Can you point me to some docs on monadic parsers?
16:00:39 <awestroke> @hoo parsec
16:00:39 <lambdabot> Maybe you meant: hoogle hoogle+ yow todo show do
16:00:43 <merijn> awestroke: Sure, the point however is that the semantics as given (i.e. any from the set is valid) allows for more optimisations
16:00:51 <andreipmbcn> jle` I can display a tuple of the actual list of ints, zipped with a list of strings that denote the files I was applying the regexp on.
16:00:51 <ReinH> andreipmbcn:  you have two functors so you need to fmap twice :)
16:01:08 <andreipmbcn> jle` so [IO Int] is presumably not useless at all.
16:01:26 <merijn> awestroke: Suppose we have 'case reallyExpensiveComputation of 1 -> error "foo"; _ -> error "bar"', the imprecise exception semantics allow us to optimise away the call to reallyExpensiveComputation
16:01:39 <ReinH> but you will then not have a list of ints, you will have a list of IO Int
16:01:44 <jle`> andreipmbcn: it sounds like you want to compute an (Int, String) in the end
16:01:44 <quchen> merijn: But then my statement about seq above is correct again, no?
16:01:52 <jle`> so that means you want IO [(Int,String)]
16:02:02 <quchen> merijn: The Report only seems to say "When an exception propagates outside the main program, the Haskell system prints the associated IOError value and exits the program."
16:02:11 <awestroke> merijn: huh. so which error is chosen in this example?
16:02:53 <andreipmbcn> jle` I want to PutStrLn $ show them, but I assume that's straightforward.
16:03:19 <awestroke> :t putStrLn . show
16:03:20 <lambdabot> Show a => a -> IO ()
16:03:20 <merijn> awestroke: I dunno, the point is that the definition of exceptions for Haskell doesn't require a specification of which
16:03:21 <awestroke> :t print
16:03:22 <lambdabot> Show a => a -> IO ()
16:03:27 <tremon> nvm, reading up on parsec and seeing if it will be easy to integrate
16:03:38 <Welkin> do you know of any tutorials for writing sudoku or chess in haskell?
16:03:38 <merijn> awestroke: Technically it'd still be correct if it randomly picked "foo" or "bar" at runtime
16:03:56 <Welkin> or some similar game
16:04:18 <merijn> awestroke: Mind you, this isn't very likely to occur frequently in real code anyway
16:04:21 <awestroke> merijn: are the semantics going to change in the foreseeable future? it seems flawed
16:04:25 <ReinH> Welkin: there are a bunch of implementatinon of Sudoku at http://www.haskell.org/haskellwiki/Sudoku
16:04:35 <ReinH> Welkin: my favorite by far is Richard Bird's
16:04:42 <jle`> andreipmbcn: the least complex way, conceptually, of doing this, i think, is using do notaiton.  do { xs <- sequence listofiostrings; let ints = map f xs; return (zip ints xs) }
16:04:42 <Welkin> is it commented?
16:04:48 <chrisdotcode> is there a built in function that does: `singleToList x = [x]`?
16:04:55 <jle`> chrisdotcode: return
16:04:56 <Welkin> most of the game's I have encountered lack comments and documentation
16:04:57 <jle`> or pure
16:05:00 <jle`> or (:[])
16:05:02 <Welkin> games*
16:05:08 <merijn> awestroke: Unlikely, I agree that the example seems really wrong. But in more complicated constructions it can't be clear what the right choice is
16:05:11 <jle`> robot monkey operator saves the day
16:05:15 <ReinH> I like wrapping x in [].
16:05:24 <ReinH> to provide [x]
16:05:27 <chrisdotcode> jle`: sweet, thanks. I always forget that the list monad exists (because I still haven't groked it yet)
16:05:45 <merijn> awestroke: Mind you, you really shouldn't be using exceptions in pure code anyway. You should use throwIO (or throwM from the exceptions package)
16:06:03 <augur> chrisdotcode: dont use monad stuff for non-monad-y contexts
16:06:11 <Welkin> thanks ReinH
16:06:14 <augur> chrisdotcode: return will work here, but you shouldnt use it
16:06:17 <chrisdotcode> augur: yeah, I'm not using a monadic context
16:06:30 <ReinH> Welkin: I started writing a chess engine at haskelllive.com but it's incomplete :(
16:06:41 * ReinH needs to work on that again
16:06:44 <augur> chrisdotcode: if you mean to say "make the singleton list" then just do that. either with (:[]) or with (\x -> [x]) or with just [x] where x is the element
16:06:45 <jle`> i usually use pure or (:[]).  return is a weird word
16:06:46 <Welkin> I am looking just for the game at the moment
16:06:52 <aspidites> ReinH: speaking of soon, lol
16:06:55 <Welkin> and the solver once that is done
16:06:55 <ReinH> Welkin: there are some chess engines on youtube
16:06:57 <ReinH> er
16:06:58 <ReinH> on github
16:07:00 <ReinH> wtf brain
16:07:02 <jle`> but yeah augur has a point
16:07:04 <augur> jle`: i would avoid pure in non-applicative contexts as well
16:07:05 <jle`> maybe i should reevaluate my life
16:07:10 <augur> jle`: you should
16:07:15 <chrisdotcode> augur: yeah, that's what I was going to do, but I was just wondering if there was a builtin
16:07:17 * jle` sets of on a quest
16:07:19 <jle`> off
16:07:24 <ReinH> jle`: I question your life choices
16:07:24 <aspidites> let soon = maximum [1..]
16:07:29 <DanBurton> Pinging people who have knowledge of Haskell exceptions, particularly, async exceptions. http://stackoverflow.com/questions/23603659/can-exceptions-sneak-between-restore-and-mask
16:07:41 <augur> chrisdotcode: why clutter a library with buildins when you have convenient, composable syntax?
16:07:43 <merijn> awestroke: Consider the following "return (error "foo") `catch` myErrorHandler" <- the exception isn't raised until you try to force the 'error "foo"' thunk, it maybe that the code has already escaped the "catch" handler before that happens, in which case your handler is useless
16:08:08 <chrisdotcode> augur: because haskell always has cool ways of doing things. for example, I didn't even think of using return (even though I'm not going to use it)
16:08:10 <quchen> merijn: Better? https://github.com/quchen/articles/blob/master/fbut.md#seq-does-not-specify-an-evaluation-order
16:08:22 <DanBurton> snoyberg is pretty sure that this issue happens, but I have doubts.
16:08:32 <augur> chrisdotcode: really, you shouldnt've thought about return anyway
16:08:36 <merijn> awestroke: throwIO and throwM *force* the throw to happen before the code can return from within any handlers, thus avoiding this issue. And incidentally, also avoiding the confusing imprecise behaviour, because that only applies to pure code
16:08:56 <chrisdotcode> augur: my solution was (\x -> [x]) :-)
16:09:16 <chrisdotcode> augur: I wanted to be points-free, though.
16:09:19 <quchen> merijn: Are "imprecise exceptions" the mechanism that allows throwing from pure code in general?
16:09:20 <chrisdotcode> (:[]) does that
16:09:21 <merijn> quchen: Yeah, although I don't think the original was very bad either
16:09:25 <merijn> quchen: Yes
16:09:28 <augur> chrisdotcode: why did you want to be points-free?
16:09:40 <chrisdotcode> augur: cause points-free is cool >_>
16:09:45 <augur> no, it's not
16:09:47 <quchen> merijn: Well, if I made it worse I might as well revert the commit :-x
16:10:06 <chrisdotcode> augur: why not?
16:10:15 <augur> chrisdotcode: its often obfuscatory
16:10:34 <chrisdotcode> but I've also seen some really clean stuff with it
16:10:45 <augur> some, yes
16:10:50 <augur> taking it too far will cause brain rot
16:11:00 <merijn> DanBurton: 1) I don't think that can happen and 2) I think you can actually avoid the entire question
16:11:15 <augur> (:[]) is the best way to write the thing you want to write because it is small, clean, and easily understood
16:11:28 <DanBurton> merijn: 2) how?
16:11:39 <augur> chrisdotcode: your primary job as a programmer is to write code that is easy to read. tacit programming destroys that
16:11:48 <merijn> DanBurton: Actually, there seems to be another bug in your code
16:11:51 <jle`> ReinH: sometimes i do too
16:11:55 <augur> chrisdotcode: what context are you using this in, btw?
16:12:07 <merijn> DanBurton: "(thing, releaseThing) <- restore clientAction" <- this runs outside of the `finally` handler
16:12:20 <aspidites> augur: some might argue -> https://www.thc.org/root/phun/unmaintain.html
16:12:25 <aspidites> job security, anyone?
16:12:47 <DanBurton> merijn: that's exactly the issue at hand. It can't possibly run inside the finally handler because the finally handler depends on that action.
16:12:57 <chrisdotcode> augur: I have a typeclass that returns a [a], and I'm making an instance for char. so the implementation is going to be what you posted.
16:13:06 <chrisdotcode> *a typeclass with a function that returns an [a]
16:14:09 <augur> chrisdotcode: do you have code you could show?
16:14:10 <merijn> DanBurton: But then you're boned anyway
16:14:28 <DanBurton> merijn: so it depends on the "client" to clean things up if problems arise inside, but the question is, can an exception happen between the "client" and "me"?
16:15:11 <DanBurton> merijn: I'm boned meaning... an exception can sneak in between "my code" and "client code"?
16:15:22 <merijn> DanBurton: I think you may just want to write your own version of bracketOnError and see if you can avoid the problem there
16:16:09 <merijn> DanBurton: Returning the 'b' from within the bracketOnError kills your safety wrt to freeing 'b' exception safely
16:16:36 <merijn> DanBurton: Why aren't you passing "doMoreStuff" as argument into clientAction?
16:17:04 <DanBurton> merijn: That's what I was trying to avoid. And indeed, that is snoyberg's solution to the problem.
16:17:18 <merijn> DanBurton: Why are you trying to avoid that?
16:17:27 <DanBurton> merijn: to simplify things for the client
16:17:44 <merijn> DanBurton: Well, you can basically choose, simple and wrong or correct and less simple
16:17:48 <DanBurton> merijn: so the client doesn't have to worry about when to call it and how many times to call it
16:18:14 <merijn> DanBurton: Why does the client need to know how many times to call it?
16:18:42 <DanBurton> merijn: the client should only call it once, but by handing them the callback, they have the freedom to call it zero times, or many times.
16:19:04 <merijn> You can just write a callback that can only be called once
16:19:12 <DanBurton> That's true
16:19:26 <DanBurton> but also, overhead
16:19:31 <merijn> Put the function in an MVar, upon invocation take it out and run it. If the MVar is empty, immediately return
16:20:44 <merijn> DanBurton: Well, you can rationalise for hours, but as soon as you expect to release *outside* of the bracket, you're screwed. So either you rationalise a few more hours, eventually give up and do it this way, or you do it this way immediately :)
16:20:49 <tsuraan> So, it turns out that I don't need what I thought I needed, but could somebody show how http://lpaste.net/104063 could be modified to compile using multi-param typeclasses or type families? I tried a bunch of random stuff, and couldn't get anything sensible to work, but it seems like what I'm trying to do should be fairly easy
16:20:56 <chrisdotcode> augur: yeah! I'm going to make a post on /r/haskell tomorrow, but for now, I just want to clean up the codebase :)
16:21:13 <merijn> Alternatively, you end up saying "sod correctness", do it this way and 2 months from now you'll have to debug a nasty async exception race condition :)
16:21:39 <augur> chrisdotcode: well but can you just show the class you're working with? :P
16:24:44 <merijn> DanBurton: FYI, I tried that last alternative once, I recommend against it :)
16:26:09 <chrisdotcode> augur: http://lpaste.net/104064
16:26:43 <DanBurton> merijn: :)
16:27:07 <chrisdotcode> guess I should have used map... that simplified a lot of the code...
16:27:10 <augur> chrisdotcode: i dont like that code
16:27:20 <augur> chrisdotcode: firstly, i wouldve just written toCell x = [x]
16:27:40 <chrisdotcode> augur: and I need to use map. didn't even see it when coding, but it certainly cleans up a lot
16:27:45 <augur> secondly, im not sure you should use read c :: Char as your function String -> Char
16:28:32 <augur> chrisdotcode: you should be more explicit in what its doing locally, rather than deferring to how read works to produce chars
16:29:03 <chrisdotcode> augur: yeah, read c :: Char seems really hacky to me, but I don't know of any Char -> String functions
16:29:09 <augur> thirdly, yes, use map. your go is just map
16:29:16 <DanBurton> merijn: FYI the subject matter is WAI. The "client" is an "app", and "my code" is the "server". So the use case here is that the client wants to release a resource after the server sends a response. Which is a bit nuts imo but w/e.
16:29:26 <augur> chrisdotcode: you're _defining_ one, you dont need to use some other one
16:29:37 <augur> chrisdotcode: fourthly, intercalate "" just is concat
16:29:39 <DanBurton> The way to accomplish this async-safely is with a callback.
16:29:51 <chrisdotcode> augur: oh, awesome! that also cleans up a lot of stuff, too :D
16:30:27 <augur> toCell xs = concat (map toCell xs)   or better yet, since tacitness wont hurt:   toCell = concat . map toCell
16:30:28 <gauthier> is there some function to fold a list of Bool (|| all or && all elements of the list) or should I use a fold function?
16:30:38 <augur> gauthier:
16:30:47 <augur> @hoogle [Bool] -> Bool
16:30:47 <lambdabot> Prelude and :: [Bool] -> Bool
16:30:48 <lambdabot> Data.List and :: [Bool] -> Bool
16:30:48 <lambdabot> Prelude or :: [Bool] -> Bool
16:30:53 <DanBurton> merijn: and the running example in the email thread is a client that hands the webserver a handle and says "stream the response from this handle"
16:31:10 <DanBurton> s/client/app
16:31:13 <chrisdotcode> augur: thanks :)
16:31:14 <gauthier> augur: thanks, I guess I should ask hoogle first :)
16:31:31 <augur> chrisdotcode: also, there's a more generic class you probably could use
16:31:53 <chrisdotcode> augur: I'm working on a CSV parser that makes haskell objects from rows, and crashes if the csv input file isn't "type-safe"
16:32:06 <augur> chrisdotcode: namely, something like
16:32:07 <chrisdotcode> so cell represents a single cell
16:32:18 <chrisdotcode> and I'm going to ask for feedback on /r/haskell tomorrow :)
16:32:29 <augur> class Iso a b where { to :: a -> b ; from :: b -> a }
16:32:41 <augur> or forward/backward
16:32:54 <augur> you'll need multiparam type classes tho
16:33:06 <augur> which should be default anyway
16:33:29 <chrisdotcode> hrm,, so what do I gain by the genericity?
16:33:54 <augur> chrisdotcode: what do you lose by it?
16:33:56 <augur> :)
16:34:28 <chrisdotcode> augur: explicitness? I had planned it to explicitly always give back a string-based format, to produce a resulting CSV
16:35:00 <augur> genericity future proofs you against having to back and change types in case you find another identical usage, modulo types
16:35:22 <chrisdotcode> augur: good point. I just really didn't think the future-proofing was worth it at this point
16:35:33 <augur> genericity is generally always worth it
16:35:50 <zzzzzzzziiii> what is the advantage of arrow calculus over classic arrows? "just" the reduced number of laws?
16:35:59 <augur> in this case tho, chrisdotcode, dont call it iso, cause its not an iso
16:36:13 <chrisdotcode> augur: right
16:36:43 <augur> chrisdotcode: also, having a type Cell and a class IsCell is confusing and misleading
16:36:50 <pdxleif> Do I try to support all GHC versions w/ stuff published on hackage?  Or do I just set upper limits on deps, and then publish new versions w/ appropriate lower limits?
16:37:07 <pdxleif> And if someone wants to use a newer version, tell 'em "upgrade your GHC"?
16:37:13 <chrisdotcode> augur: any naming suggestions?
16:38:42 <augur> chrisdotcode: probably you want some laws to hold of your thing, such as   to.from.to.from = to.from   and   from.to.from.to = from.to
16:38:47 <Cale> zzzzzzzziiii: I guess the fact that it's a sequent-style calculus makes it sort of a decent halfway point to developing a categorical interpretation
16:38:55 <acowley> Is there a pretty printing library out there that supports text and doesn't tread over common operator symbols?
16:39:12 <acowley> I'm trying to modernize some code that used pretty
16:39:21 <augur> chrisdotcode: to.from and from.to cant be identities because you're possibly losing informating, e.g. String -> Char  so round tripping wont land you back where you started
16:39:25 <acowley> so I tried wl-pprint-text, but it conflicts on <> and <$>
16:39:26 <Cale> zzzzzzzziiii: I don't think it ever really went anywhere beyond the one paper though
16:39:32 <acowley> which is lame
16:39:32 <augur> chrisdotcode: but probably you want a _double_ round trip to be the same as _one_ round trip
16:39:40 <chrisdotcode> augur: indeed
16:39:45 <augur> Cale: do you know of a name for this? it seems adjunctiony
16:39:49 <chrisdotcode> augur: so would I put these in the quickcheck tests?
16:39:51 <Cale> (if you're referring to the paper from 2008)
16:39:56 <augur> Cale: where f.g.f.g = f.g and g.f.g.f = g.f
16:40:06 <augur> chrisdotcode: no, just add comments with expected laws
16:40:33 <chrisdotcode> sounds good. thanks a lot, augur :)
16:40:33 <acowley> You do have an adjunction
16:40:42 <augur> Cale: actually i think that entails   f.g.f = f   g.f.g = g
16:40:48 <augur> acowley: yeah, it looks very adjunctiony
16:40:59 <augur> chrisdotcode: maybe just call it Adjunction!
16:41:05 <acowley> haha
16:41:14 <chrisdotcode> heh
16:41:25 <augur> no seriously
16:41:52 <acowley> If it's being specialized to Char and String, I would at most mention its adjunctiony flavor in a comment
16:42:12 <acowley> I try not to use the general name for a specialization
16:42:30 <acowley> But it's a matter of taste, and if you're not exporting it the namespace is yours to do with as you will!
16:42:42 <zzzzzzzziiii> Cale, yes this paper, from what i understood in the paper, all the things were possible with classic arrows too (and were done by paterson)
16:42:45 <augur> class Adjunction a b where { to :: a -> b ; from :: b -> a }  -- laws: to.from.to = to, from.to.from = from
16:43:09 <chrisdotcode> augur: I would, but I don't think 'Adjunction' would be a good name for CSV parsing :)
16:43:18 <augur> chrisdotcode: sure it is
16:43:47 <chrisdotcode> augur: you think?
16:43:51 <augur> yeah, definitely
16:44:07 <augur> just remember: the more mathy your code looks, the more likely you are to turn into edwardk
16:44:47 <Cale> Obviously a goal worth striving for
16:46:19 <u-ou> @hoogle AnyEvent
16:46:19 <lambdabot> No results found
16:46:31 <ReinH> acowley: adjoint functors really do arise everywhere ;)
16:46:42 <epta> What to do if there is a module X.Y which is imported in my module X.Y (the imported one is from other package)? How to avoid 'module imports itself' issue?
16:47:13 <chrisdotcode> augur: I would like to be edwardk as soon as possible
16:47:19 <acowley> ReinH: Almost too common!
16:47:34 <acowley> ReinH: The commonality makes it harder to get leverage in some ways
16:47:39 <ReinH> chrisdotcode: kill him and gain his powers? No, wrong universe.
16:47:58 <acowley> I guess we should start selling Be Like Mike style t-shirts, but with Ed instead of Mike
16:48:11 <acowley> Although that might be too old a reference
16:49:06 <ReinH> acowley: I got it
16:51:06 <chrisdotcode> ReinH: I'm sure he's a persistent data structure, so I'd just be a pointer to his knowledge :)
16:56:50 * hackagebot yesod-markdown 0.9.0 - Tools for using markdown in a yesod application  http://hackage.haskell.org/package/yesod-markdown-0.9.0 (PatrickBrisbin)
17:00:35 <carter> acowley: nah, thats still valid
17:03:37 <mmmm> Where can you set where ghci looks for modules?
17:07:03 <zzzzzzzziiii> mmmm, -i option
17:07:29 <mmmm> thanks I got it
17:10:28 <ironChicken> http://pastebin.com/tMzzzTDs gives me "Couldn't match type `Int' with `(a1 -> a1 -> a1) -> a2 -> a0'"
17:12:25 <benzrf> do most comonads fall under the intuition of 'structure with a singled-out item' or is that as misleading as 'wrapper around a value' is for functors?
17:16:37 <zzzzzzzziiii> ironChicken, u forgot `` around mod
17:17:43 <hpc> benzrf: it is; duplicate is where the interesting stuff happens
17:17:59 <hpc> similarly to join being the good stuff with Monad
17:19:07 <zzzzzzzziiii> ironChicken, and u propably don't want to use the tree recursion version of fibs
17:19:44 <zzzzzzzziiii> *probably
17:20:30 <benzrf> hpc: it is as misleading, you mean?
17:22:08 <ironChicken> zzzzzzzziiii: ty
17:23:30 <ironChicken> it's annoying the error didn't lead me to that
17:24:16 <Luke> is there something similar to "findBy" for lists?
17:24:29 <Luke> a "findBy" similar to "sortBy" that is
17:25:01 <benzrf> Luke: detect
17:25:20 <benzrf> >> %w/what the heck is this/.detect {|item| item.length == 2}
17:25:29 <shachaf> Which does what?
17:25:34 <benzrf> >> %w/what the heck is this/.detect {|item| item.length == 2}
17:25:34 <Luke> that looks like it's part of Text
17:25:39 <benzrf> oh fuck
17:25:42 <benzrf> i thought i was in #ruby
17:25:44 * benzrf facepalms
17:25:47 <Luke> haha
17:27:49 <hpc> quick, someone write an extension that makes that valid syntax!
17:27:55 <Luke> shachaf: are you asking what findBy would do?
17:28:18 <shachaf> Yes.
17:29:09 <Luke> shachaf: it would find something in the list using the "by" convention
17:29:48 <shachaf> What type would it have?
17:29:56 <shachaf> Or what's the "by" convention?
17:30:25 <carter> benzrf: we know your secret :)
17:30:41 <Luke> shachaf: http://hackage.haskell.org/package/base-4.6.0.1/docs/Data-List.html#g:23
17:31:02 <benzrf> i thought the camelcase was a bit suspect
17:31:10 <shachaf> s/Or/And optionally,/
17:31:12 <benzrf> but decided it was somebody from js being typo-y
17:31:47 <Luke> shachaf: basically it'd return the difference of "deleteBy" and the original list
17:32:06 <shachaf> :t find
17:32:07 <lambdabot> (a -> Bool) -> [a] -> Maybe a
17:32:35 <Luke> findBy :: (a -> a -> Bool) -> [a] -> Maybe a
17:32:55 <shachaf> No a argument?
17:33:27 <Luke> the usage would be like "findBy (compare `on` fst) xs"
17:33:51 <shachaf> You mean (==) `on` fst?
17:33:58 <shachaf> I'm still not sure what that would do.
17:34:00 <Luke> oh i'm sorry you're right. findBy :: (a -> a -> Bool) -> a -> [a] -> [a]
17:34:04 <Luke> yea
17:34:06 <shachaf> OK.
17:34:43 <Luke> again it would return the same thing as "deleteBy" difference with the original list
17:34:56 <shachaf> To one of the questions, I would say that the regular non-By version of this function -- with type Eq a => a -> [a] -> Maybe a -- isn't very useful, because it just gives you back what you gave it (modulo Eq equality).
17:35:11 <shachaf> So there's nothing to make a By version of. find is very different, and doesn't use Eq at all.
17:35:32 <shachaf> So first off you should have a different name.
17:35:56 <shachaf> I'd also suggest that this function is very specialized and therefore not generally useful enough to be in a standard library.
17:36:31 <shachaf> E.g. you can write find ((==x) . fst) or something instead of yourFunction ((==) `on` fst) x
17:36:44 <Luke> thats fine but I'm not asking that
17:36:47 <Luke> i'm asking if it already exists
17:36:49 <benzrf> :t on
17:36:50 <lambdabot> (b -> b -> c) -> (a -> b) -> a -> a -> c
17:36:51 <shachaf> It doesn't.
17:36:54 <Luke> in some other library I don't know of or something
17:37:10 <benzrf> @src on
17:37:10 <lambdabot> (*) `on` f = \x y -> f x * f y
17:37:13 <benzrf> hmmmmm
17:37:23 <benzrf> right
17:37:39 <benzrf> i feel like the arguments make more sense the other way around
17:37:42 <benzrf> m-maybe not
17:37:49 <Luke> shachaf: don't get caught up on me calling it "findBy" - that was for illustration purposes only
17:40:13 <Luke> shachaf: anyway thanks you've answered my question. I do agree with you about Eq etc but that's beyond the scope of my question
17:41:55 * hackagebot vacuum 2.2.0.0 - Graph representation of the GHC heap  http://hackage.haskell.org/package/vacuum-2.2.0.0 (JohnLato)
17:47:36 <benzrf> in general, though
17:47:57 <benzrf> is the primary purpose of comonads to perform computations on parts that depend on the whole?
17:49:11 <johnw> benzrf: that's thinking a bit too concretely
17:49:53 <johnw> benzrf: comonads have no purpose, they are simply something that arises from adjunction, dual to monads
17:50:49 <johnw> they can probably be applied to more things than anyone has even thought of yet, who knows
17:56:08 <spott> I have a question.  I'm working my way through "write yourself a scheme in 48 hours" (http://jonathan.tang.name/files/scheme_in_48/tutorial/evaluator1.html)
17:56:32 <spott> but I'm struggling to rewrite this:
17:56:35 <spott> parseNumber :: Parser LispVal
17:56:36 <spott> parseNumber = liftM ( Number . read ) $ many1 digit
17:56:47 <spott> using bind ">>=" notation
17:57:05 <mmmm> Do you know the definition of liftM?
17:57:18 <spott> my first guess:  parseNumber = return digit >>= many >>= liftM ( Number . read )
17:57:19 <spott> doesn't work
17:57:39 <spott> yea, it takes a function, and turns it into a function that operates on the value inside the monad
17:58:45 <mmmm> ok, write parseNumbe in do notation (without the liftM) and then you should be able to desugar that into (>>=)
17:58:45 <spott> I believe it is Monad m => (a -> b) (m a) (m b)
17:59:02 <monochrom> that description is not nearly rigorous enough for rewriting code
17:59:13 <spott> lol, do notation was the going to be the exercise after that
17:59:25 <spott> but I don't fully understand do notation either
17:59:41 <carter> mmmm: youre' doing gsoc right?
17:59:44 <spott> monochrom: which one?
17:59:44 <carter> hows that going?
17:59:47 <mmmm> yep
17:59:54 <carter> pandocing?
17:59:57 * carter forgets
17:59:57 <mmmm> yep
18:00:01 <monochrom> "it takes a function, and turns it into a function that operates on the value inside the monad"
18:00:02 <carter> hows that going?
18:00:23 <spott> monochrom: i know, that is why I followed it up with the type def
18:00:41 <monochrom> but you messed up the type, too
18:00:44 <mmmm> Well so far, nearly done with the embedded image part and working on some more API breaking changes whilst I'm at it
18:00:47 <spott> yea, I know
18:00:50 <carter> cool
18:00:59 <carter> mmmm: so pretty productive!
18:01:04 <monochrom> solution: Monad m => (a -> b) -> (m a -> m b)
18:01:06 <spott> I just checked it
18:01:17 <carter> so you can do some pretty ambitious / neat polishign stuff once the summers really started?
18:01:31 <mmmm> yes hopefully when I can fully concentrate on it
18:01:37 <carter> mmmm: props
18:02:04 <mmmm> just been trying to help out on the mailing list and big tracker as well to take some strain off john
18:02:07 <monochrom> after the rewrite, there should be no liftM left
18:02:17 <carter> mmmm: yay
18:02:27 <carter> mmmm: do you see why i was like "pandoc needs more help"
18:03:14 <acowley> Roles won't get in the way if I have newtype Foo phantom = Foo Concrete
18:03:16 <acowley> will it?
18:03:30 <acowley> In the way of GND based on Concrete that is
18:03:56 <carter> acowley: afaik nope
18:04:03 <spott> monochrom: which rewrite? to do notation?
18:04:11 <monochrom> to >>=
18:04:16 <aspidites> trying to get my wording correct. When explaining why "foo a b . bar c d" is equivalent to "(foo a b) . (bar c d)" is it correct to say it is because (.) binds tighter than regular functio application?
18:04:18 <carter> i forget what semantics was chosen for 7.8
18:05:04 <acowley> carter: thanks
18:05:09 <acowley> aspidites: Opposite
18:05:39 <aspidites> acowley: thanks
18:05:45 <spott> OH!!! >>= passes on "a", not "M a",
18:17:18 <spott> I'm still struggling with this... does the last value in a ">>=" string have to have a different typesignature?
18:17:45 <monochrom> what does 'the last value in a ">>=" string' mean?
18:18:49 <spott> the last function at the end of the bind:  a >>= b >>= c >>= d
18:19:08 <monochrom> then it does not have to have a different type
18:19:12 <spott> so d, in that case
18:19:58 <monochrom> liftM f x can be rewritten to use one single >>= and one single return.
18:20:44 <Ginto8> spott: the types are: (m a) >>= (a -> m b) >>= (b -> m c) >>= (c -> m d), and it evaluates to type m d
18:20:47 <monochrom> plus either one single lambda or one single function composition
18:21:18 <Ginto8> the types a, b, c and d can be anything (including the same type)
18:21:21 <spott> Ginto8: thanks
18:26:04 <spott> thanks guys, I got it
18:29:07 <spott> I really appreciate the help
18:30:24 <spott> liftM f x = x >>= return . f
18:30:37 <spott> right?
18:31:10 <prophile> @src liftM
18:31:10 <lambdabot> liftM f m1 = do { x1 <- m1; return (f x1) }
18:31:10 <DarkLinkXXXX> Is there a functional language with a VM/garbage collector that's trivial to implement, so that it can be reasonably implemented for a micro-controller?
18:31:33 <prophile> @undo { x1 <- m1; return (f x1) }
18:31:34 <lambdabot> <unknown>.hs: 1: 1:Parse error: {
18:31:36 <monochrom> yes
18:31:36 <prophile> bah
18:31:50 <monochrom> you're missing a "do" when you undo
18:31:55 <prophile> @undo do { x1 <- m1; return (f x1) }
18:31:55 <lambdabot> m1 >>= \ x1 -> return (f x1)
18:32:03 <prophile> @pl m1 >>= \ x1 -> return (f x1)
18:32:03 <lambdabot> f `fmap` m1
18:32:14 <spott> monochrom: thanks
18:32:25 <prophile> well, that's not quite the ideal demonstration
18:32:29 <prophile> but essentially "yes"
18:36:18 <XexonixXexillion> Is there any way to have a type in Haskell where ⊥ is not an element of that type?
18:37:32 <carter> not really
18:37:34 <Ginto8> DarkLinkXXXX: I don't know of any; for microcontrollers it's usually more practical to just compile down to C
18:37:35 <carter> but you can ignore bottom
18:48:01 <XexonixXexillion> carter: for what I'm doing, I can't ignore ⊥. It's not really an issue though, I'll just do it in Coq. I was just curious if it was possible; a lot of interesting extensions have been added to GHC to do with types since I last took a good look
18:48:15 <carter> whats your use case?
18:48:30 <carter> if you're doing a deep embedding, you can prevent bottom in the final AST
18:50:42 <mr_yogurt> I've been told that this irc is insanely tolerant to trolls.
18:51:09 <luite> mr_yogurt: don't push your luck ;)
18:52:11 <mr_yogurt> This is why: https://gist.github.com/quchen/5280339
18:53:06 <SrPx> What is the structure I should use to create a mapping between strings? Like you would with a JS object
18:53:36 <jxv> A function or Map from Data.Map
18:54:13 <joelteon> a Map has O(logn) lookup time while a function is linear
18:57:59 <XexonixXexillion> carter: it's not a program per se, it's just proving some properties over self balancing binary search trees. I just wanted to know if I could leverage the Haskell type system into checking my proofs.
18:58:00 <monochrom> Map or Hashmap will do fine. if you choose HashMap, choose the one in unordered-containers
18:58:12 <carter> XexonixXexillion: you can do some basic stuff
18:58:27 <carter> SrPx: fast access or good space
18:58:45 <monochrom> Haskell type system will not rid ⊥ for you.
19:00:01 <carter> yeah, if you wanna evade bottoms, coq/idris/agda or acl2
19:00:31 <monochrom> if you want to evade types also, acl2 :)
19:01:33 <carter> acl2 also automatee stuff
19:01:36 <carter> *automates
19:02:23 <monochrom> I am just not very fond of its treatment of existential statements
19:04:50 <carter> not saying its godo
19:04:51 <carter> good
19:05:11 <carter> i guess theres hol light and isabelle
19:05:18 <carter> but yeah, coq is probably the best way to go
19:05:24 <carter> XexonixXexillion: is it a pure data structure or not
19:05:25 <carter> ?
19:06:01 <SrPx> jxv: joelteon ok thanks
19:06:09 <monochrom> I bet it's pure. if it were mutable, separation logic would be the biggest worry :)
19:06:11 <XexonixXexillion> carter: It's pure, I'll probably just use coq. acl2 looks interesting, but I actually know how to write coq
19:06:13 <SrPx> carter: fast access, the structure is small
19:06:26 <carter> SrPx: hashmap
19:06:27 <carter> or hashtable
19:06:31 <carter> do you want pure or fast?
19:06:37 <carter> fast or pure and fast?
19:06:38 <SrPx> carter: easy
19:06:42 <carter> easy == hashmap
19:06:48 <SrPx> okay (:
19:06:56 <SrPx> hashmap/hashtable/map implement the same semantic?
19:07:00 <monochrom> easy == Data.Map. comes with GHC, you don't even have to cabal-install
19:07:13 <carter> not quite
19:07:17 <carter> Map uses ordering
19:07:25 <carter> Hashable uses a hash then equality chain
19:08:10 <carter> bu yeah
19:08:17 <carter> just use data.map untill benchmarks say otheries
19:09:31 <SrPx> okay (:
19:12:27 <carter> SrPx: what are the trends in wha ti say (whether i listen to myself is another question)
19:12:57 <SrPx> carter: pardon?
19:14:27 <monochrom> your trend seems to be that your average line has less than 22.473 characters :)
19:14:52 <carter> my githubs or my ircs :)
19:15:02 <carter> SrPx: i say the word benchmark often
19:15:08 <carter> but don't benchmark as much as I should msyelf
19:15:33 <monochrom> I have not analysed your sayings closely :)
19:19:29 <SrPx> carter: isn't benchmarking haskell pretty easy
19:19:35 <carter> yup
19:19:39 <carter> :)
19:19:43 <carter> criterion is great
19:19:44 <carter> monochrom: :)
19:19:46 <carter> its ok
19:21:11 <XrXr> why do I have to tell Haskell (Ord a, Num a) when Num already subclass Ord?
19:21:26 <XrXr> and Eq
19:21:56 <geekosaur> what?
19:22:17 <copumpkin> XrXr: because it doesn't
19:22:28 <copumpkin> Complex is a Num instance despite not being Ord
19:22:34 <geekosaur> Num does not require Ord (complex numbers have no total ordering), nor Ord Num (strings)
19:22:35 <copumpkin> and the Eq superclass constraint was killed a while ago
19:22:51 <XrXr> ah.. that makes more sense
19:22:54 <geekosaur> (strings and many other examples)
19:24:29 <aspidites> at what point should I decide that I've done TOO much composition?
19:24:42 <copumpkin> never
19:24:45 <copumpkin> :)
19:25:06 <aspidites> copumpkin: http://hastebin.com/xukopufuju.hs
19:25:22 <aspidites> i'm sure i could blame that primarily on pointfree abuse
19:25:44 <copumpkin> looks fine to me
19:25:52 <copumpkin> except for that intToDigit repetition
19:25:56 <sjy> geekosaur: there exists a total order for C (lexicographical), it's just not natural or particularly useful
19:26:15 <copumpkin> :t intToDigit . sequence [length, head]
19:26:16 <lambdabot>     Couldn't match type ‘Int’ with ‘[Int]’
19:26:16 <lambdabot>     Expected type: [Int] -> Int
19:26:16 <lambdabot>       Actual type: [Int] -> [Int]
19:26:22 <aspidites> duh
19:26:24 <copumpkin> :t map intToDigit . sequence [length, head]
19:26:26 <lambdabot> [Int] -> [Char]
19:26:32 <geekosaur> sjy, I considered noting that but decided it added nothing but confusion
19:26:34 <carter> XrXr: it used to have those i think...
19:26:37 <copumpkin> oh, not the same thing
19:26:45 <geekosaur> Num used to have Eq and Show
19:26:47 <geekosaur> not Ord
19:26:48 <carter> yup
19:26:50 <copumpkin> aspidites: I do that a bit differently
19:26:53 <carter> which meant lots of nice things werent possible
19:26:57 <XrXr> :info Real
19:27:26 <XrXr> D: lambdabot doesn't work with info?
19:27:32 <geekosaur> lambdabot has nothing like ghci's :info
19:27:38 <XrXr> aw
19:27:49 <XrXr> I can do Real a though to get what I want
19:27:51 <jmcarthur> aspidites: the only reason you might have "too much" composition is if you broke the problem down too far for you to easily understand, in which case all you have to do is extract some functions. since you decomposed it into such small pieces, it should be pretty easy to just put some parens around the part you want to extract and give it a name.
19:28:03 <jmcarthur> aspidites: key to this is the fact that composition is associative, of course :)
19:28:06 <geekosaur> (and people keep getting tripped up by that since @info is accepted... but is edit corrected to @undo)
19:28:30 <XrXr> What are some of the nice things that the current version of Num can do the older version can't?
19:28:41 <aspidites> ok, thansk copumpkin and jmcarthur
19:29:05 <aspidites> i started out with something a bit more verbose but the repetition bothered me
19:29:14 <jmcarthur> XrXr: you can define a Num instance for higher order representations really easily now that Eq isn't required, for example
19:29:18 <aspidites> and of course copumpkin fixed that last bit i didn't like
19:29:24 <copumpkin> not sure I did, did I?
19:29:37 <jmcarthur> XrXr: e.g.    newtype Foo a b = Foo (a -> b);   instance Num b => Num (Foo a b) where ...
19:29:58 <sjy> geekosaur: sorry for being pedantic :)
19:30:45 <aspidites> copumpkin: it type checks and gives the same results as the original, so i think so
19:31:00 <copumpkin> hm, I guess I'm better than I think :P
19:31:06 <XrXr> thanks jmcarthur
19:32:01 <aspidites> lol
19:32:56 <XrXr> hm.. hoogle still has the old version http://www.haskell.org/hoogle/?hoogle=Num
19:33:42 <aspidites> that said, how do you guys prefer to indent long lines? for instance, do you put ($) just before new lines? just after?
19:33:57 <zq_> break it up with let/where bindings
19:35:12 <aspidites> and when that doesn't get the line shorter than 79 chars?
19:36:32 <aspidites> so far, i've been sticking with aligning punctuation with (=) similar to the way i do with lists.
19:36:59 <zq_> use single character variables like ekmett
19:37:04 <zq_> lol
19:37:53 <roconnor> aspidites: $ and other puncutation just after the newline
19:38:10 <roconnor> aspidites: often in line with the =
19:38:22 <roconnor> hmm
19:38:30 <roconnor> actually I'm probably not consistent with that.
19:40:23 <benzrf> i thought of a bad pun
19:40:54 <benzrf> is there a such thing as a coprofunctor, or is that bullshit
19:40:57 <benzrf> :-D
19:41:07 <aspidites> roconnor: any particular case when you are not consistent? that is, that you are consistently inconsistent?
19:41:42 <roconnor> aspidites: for $ I might be tempted to put it at the end of a line, especially if the next word is "do"
19:42:03 <roconnor> for + . etc. I would try to begin the line with it.
19:42:11 <c_wraith> benzrf: My guess is that it'd be isomorphic to a profunctor.  If you reverse the arrows, you still have a profunctor, just.. the other way around.
19:42:22 <benzrf> c_wraith: 10:37 < benzrf> i thought of a bad pun
19:42:28 <roconnor> this placment policy is a bit new for me.
19:43:38 <benzrf> c_wraith: g-get it?
19:45:14 <aspidites> stupid ISP
19:45:33 <jmcarthur> i dont get it
19:45:44 <benzrf> jmcarthur: coprofunctor
19:45:48 <benzrf> :-D
19:45:51 <jmcarthur> i see that
19:45:59 <benzrf> hence, bullshit
19:45:59 <jmcarthur> but i don't get the pun
19:46:17 <benzrf> jmcarthur: https://www.google.com/search?client=ubuntu&channel=fs&q=copro&ie=utf-8&oe=utf-8
19:46:55 <jmcarthur> no bovine references though? i am disappointed
19:47:20 <benzrf> :[
19:47:25 <aspidites> oh
19:47:32 <aspidites> well i definitely googled it
19:47:33 <benzrf> cowprofunctor?
19:47:42 <aspidites> found an idris implementation...
19:48:17 <jmcarthur> sounds about right
19:48:17 <startling> "cowfunctor" is almost a good pun.
19:48:40 <Ralith> fmap milkingMachine
19:48:41 <benzrf> comonads use a w
19:48:54 <startling> what moos and maps contravariantly?
19:48:56 <benzrf> Ralith: shouldnt machines be composed with ~>
19:48:59 <jmcarthur> are you a butcher, cuz you sure know your cowproducts
19:49:02 <benzrf> :-D
19:49:16 <Ralith> benzrf: sure, but a cow isn't a machine
19:49:32 <benzrf> Ralith: true
19:49:59 <jmcarthur> a cowmonad tutorial has the worst analogies ever
19:50:08 <aspidites> so, is using the term pundit to desscribe a person good at creating puns a pun in of itself?
19:51:02 <startling> heh
19:51:27 <benzrf> i am so glad i decided to derail this discussion
19:51:59 <aspidites> describe* i make myself sad sometimes
19:52:27 <aspidites> benzrf: me too...brings a whole new meaning to the term "shooting the shit"
19:52:46 <aspidites> or phrase rather
19:53:00 <benzrf> @faq does this command still work?
19:53:00 <lambdabot> http://www.haskell.org/haskellwiki/FAQ
19:53:05 <benzrf> D:
19:53:09 <benzrf> somebody fix lambdabot
19:53:52 <aspidites> benzrf: is that a frequently asked question?
19:54:07 <benzrf> formerly the @faq command would always reply with
19:54:23 <benzrf> 'The answer is: Yes! Haskell can do that.'
19:56:56 <benzrf> :t maybe
19:56:57 <lambdabot> b -> (a -> b) -> Maybe a -> b
19:57:10 * hackagebot th-desugar 1.4.0 - Functions to desugar Template Haskell  http://hackage.haskell.org/package/th-desugar-1.4.0 (RichardEisenberg)
19:57:14 <benzrf> anyway bye
19:57:23 <benzrf> [spread my shitty pun]
19:58:56 <jmcarthur> i guess it was finally settled that the old @faq made us seem really full of ourselves
20:00:14 <aspidites> or maybe it was decided that, given the academic nature of the haskell community, that command should offer something more useful...educational even
20:00:49 <dolio> Fewer people come here and ask, "can Haskell do X" now.
20:02:11 * hackagebot hstorchat 0.1.0.0 - Distributed instant messaging over Tor  http://hackage.haskell.org/package/hstorchat-0.1.0.0 (ChristopherReichert)
20:03:24 <aspidites> ok. i'll fix that. Can Haskell NOT do...
20:04:46 <aspidites> nvm, couldn't come up with anything significant.
20:05:12 <aspidites> i'd ask about guis, but i think qtqml will fit the bill nicely there
20:16:26 <dmj`> can a ThreadId be serialized?
20:24:58 <parBuffer_overfl> Is this the right place to ask about parallel haskell using the eval monad?
20:25:40 <bms1> parBuffer_overfl: yes!
20:27:31 <sveit> I have a fairly deep class structure, some of which I have pasted here: http://lpaste.net/50227087021178880 . These correspond to lines in a data file, and since their respective ordering matters I put them in a single list with the trivial wrapper type RadFileLine (the last type in the declarations). the thing is that this structure seems very inelegant and is causing me to write lots of boiler-plate code
20:27:33 <sveit> just to get back to my data. are there any better ways to handle this? (i am pretty sure the list wrapper type is unavoidable, so I'd like solutions besides that, but am open to suggestions regardless)
20:27:50 <sveit> when I say "put" i mean after parsing
20:29:23 <parBuffer_overfl> Ok. I have written a basic ray-tracer and am trying to parellize it.. From reading Simon Marlows book and the Control.Strategies documentation it seemed like using parBuffer <int> rseq <lazy list of computation> would be the optimal way to do this because I have a lazy data structure (a list) and each computation in the list is quite expensive (tracing and coloring a pixel). However when I run the program the large majority of
20:30:09 <parBuffer_overfl> Using parListChunk eliminates the spark overflow problem, but I would like to understand why parBuffer did not work.
20:30:47 <johnw> your message was cut off
20:31:22 <bms1> parBuffer causes the entire list to be loaded into memory, while parListChunk only causes chunks at a time to be loaded into memory
20:32:08 <parBuffer_overfl> @bmsl so parBuffer sparks every element in the list. So because I had a lot of elements in the list the sparks overflowed the spark pool?
20:32:08 <lambdabot> Not enough privileges
20:33:26 <bms1> parBuffer_overfl: Yeah. I've never heard of a spark pool overflowing before! But for large lists you probably don't want to force the whole list at once
20:33:37 <bms1> parBuffer_overfl: What is the type of the elements in your list?
20:33:39 <ivanm> is there a way to have runhaskell recognise and work with sandboxes?
20:34:04 <ivanm> also, is it a good idea to add the sandbox config file to version control?
20:34:31 <parBuffer_overfl> (Int,Int) -> (Int,Int,Int).
20:34:55 <ivanm> (I'm guessing "no" because it hard-codes in the prefix rather than making it relative)
20:35:18 <parBuffer_overfl> so for a 800x600 pixel image I have a list of size 480000
20:36:20 <bms1> parBuffer_overfl: So your list has 480000 functions? I imagine you'd want to apply the functions *before* you do the parallel evaluation
20:37:14 * hackagebot singletons 1.0 - A framework for generating singleton types  http://hackage.haskell.org/package/singletons-1.0 (RichardEisenberg)
20:37:39 <bms1> What evaluation strategy did you use to evaluate the list? deepseq? In any event, the most normalized you can get with functions is weak-head normal form, and that's not guaranteed to have already computed the expensive things you have
20:39:07 <parBuffer_overfl> bmsl: I apologize I made a mistake. I do apply the function first: map (rayTrace refldepth world . getRays world) pixels `using` parListChunk 500 rseq
20:39:17 <bms1> sveit: Probably the best thing to do would be to not parse it into a list of lines in the first place
20:40:02 <bms1> sveit: Having a sum type is pretty weak, as you can see. I'd try separating out the stuff as you parse. It's no use putting your parsed lines *back* into a list
20:40:47 <bms1> parBuffer_overfl: So the elements of that list are (Int, Int, Int), right?
20:40:56 <parBuffer_overfl> Yes.
20:41:07 <bms1> parBuffer_overfl: You probably want to use rdeepseq instead of rseq then, instead
20:41:49 <bms1> parBuffer_overfl: rseq will only compute your elements until it finds out you indeed have a triple! rdeepseq will compute until it sees you have a triple, and then force each element of the triple as well
20:42:29 <parBuffer_overfl> bsml++ Thank you for answering my question.
20:42:47 <bms1> parBuffer_overfl: No problem!
20:52:01 <BlankVerse> is it possible for a forkIO thread to use more than 1 core simultaneously?
20:52:40 <BlankVerse> I have a simple haskell programing which does a forkIO and the program is executed using +RTN -N
20:57:17 * hackagebot units 2.0 - A domain-specific type system for dimensional analysis  http://hackage.haskell.org/package/units-2.0 (RichardEisenberg)
21:02:14 <ParahSailin> you might have to give a ghc option for threaded
21:02:58 <redtricycle> I have a list ["the","quick","brown","fox"].  How do I convert this to match a regex and return a list, and then also have a list of the index where it matched.  i.e. [False, True, False, False], and returns idx of [1] if the regex matched quick
21:03:21 <redtricycle> I think I need to "map" a boolean regex function to it
21:03:43 <redtricycle> map regexChecker myList
21:03:46 <redtricycle> anything built in that does this?
21:03:52 <ParahSailin> @ty findIndex
21:03:53 <jumper> What is the function that gives info about another function?
21:03:53 <lambdabot> (a -> Bool) -> [a] -> Maybe Int
21:06:14 <dmj`> jumper: what do you mean by info?
21:07:17 <ParahSailin> @ty findIndices
21:07:18 <lambdabot> (a -> Bool) -> [a] -> [Int]
21:07:18 * hackagebot units-defs 1.0 - Definitions for use with the units package  http://hackage.haskell.org/package/units-defs-1.0 (RichardEisenberg)
21:26:19 <mizu_no_oto> If you have a sandbox in an incosistent state ("Warning: This package indirectly depends on multiple versions of the same package. This is highly likely to cause a compile failure."), what's the right way to get it back into a consistent state?  Is there a --reinstall-all-with-consistent-dependencies flag?  Or would that be too convenient?
21:30:53 <carter> mizu_no_oto: wipe and build anew
21:31:36 <lispy> mizu_no_oto: I've found that cabal is very conservative. I don't remember when it said that and I had an actual problem
21:33:52 <mizu_no_oto> lispy:  I ran into the error "    No instance for (transformers-0.4.1.0:Control.Monad.IO.Class.MonadIO (transformers-0.3.0.0:Control.Monad.Trans.Reader.ReaderT (GHC.Ptr.Ptr EExpose) IO))"
21:35:06 <mizu_no_oto> Which seems to be a problem caused by having two different copies of transformers, noL
21:35:08 <mizu_no_oto> ?
21:37:31 <lispy> mizu_no_oto: looks like it. Did you already try nuke&repave?
21:37:40 <lispy> mizu_no_oto: eg., is this reproducible from a clean build?
21:38:17 <mizu_no_oto> Probably not - I added the dependency on transformers after I installed most things
21:38:33 <lispy> ah
21:38:37 <lispy> Yeah, that would do it
21:38:41 <mizu_no_oto> and I guess they had pulled old versions, for some reason
21:38:55 <lispy> mizu_no_oto: you could just unregister the old transformers and rebuild
21:39:24 <lispy> There might be shorter commands, but cabal sandbox hc-pkg unregister transformers-0.3.0.0
21:39:48 <mizu_no_oto> then cabal configure then cabal build?
21:39:50 <solidus-river> what are peoples thoughts on .lhs
21:40:03 <solidus-river> and is there a good place that explains how to go from .lhs to compilation?
21:40:11 <johnw> ghc foo.lhs
21:40:16 <johnw> this is that place
21:40:55 <lispy> mizu_no_oto: yeah
21:41:13 <lispy> solidus-river: I think .lhs is meant for blog posts and writing papers.
21:41:30 <lispy> solidus-river: I find that it is a poor substitute for real documentation in a program.
21:41:47 <lispy> solidus-river: I think having large literate sections makes the code more tedious to browse and harder to grep.
21:42:13 <lispy> Personally, I don't like to use .lhs for programs and libraries I'm writing.
21:43:21 <solidus-river> lol!
21:43:25 <solidus-river> <- actualy lol'd
21:43:33 <solidus-river> i googled lhs example and this is the first one that came up
21:43:36 <solidus-river> http://projects.haskell.org/operational/examples/WebSessionState.lhs.html
21:43:45 <solidus-river> GLAD THAT WAS .LHS
21:44:15 <solidus-river> oh wait, is { / } a way of telling lhs that thats the literate part?
21:44:22 <lispy> solidus-river: that might be the output after unlit?
21:44:53 <lispy> There are two types of literate
21:45:01 <lispy> one delimits code with \begin{code} \end{code}
21:45:10 <lispy> and another that uses lines prefixed by >
21:45:24 <lispy> solidus-river: http://www.haskell.org/haskellwiki/Literate_programming
21:49:57 <solidus-river> interesting, unfortunate that the literateprogramming website is hard to read
21:50:32 <carter> lispy: now tht github has fixed rendering, i do mostly .lhs
21:50:39 <carter> though tis mostly .hs style comments therein
21:50:48 <solidus-river> carter: link to an example?
21:51:05 <solidus-river> carter: i'm just curouse how it plays out to someone who doesn't know the codebase
21:52:01 <carter> solidus-river: my .lhs files look like a .hs file, with a \begin code on the first line, and an end code on the last
21:52:36 <carter> solidus-river: whats your math background, the code base is the crystalization of 2 years of "how to write good mathy array libs for haskell"
21:52:37 <lispy> solidus-river: poke around in this repo: https://github.com/ghc/ghc/blob/master/compiler/basicTypes/BasicTypes.lhs
21:53:24 <solidus-river> carter: done a decent amount of math but i was comp-sci major not mathmatics
21:53:30 <carter> cool
21:53:35 <carter> @google numerical-core haskell
21:53:35 <lambdabot> https://github.com/wellposed/numerical-core
21:53:38 <carter> :)
21:53:44 <carter> ask questions on #numerical-haskell
21:53:45 <carter> still WIP
21:53:54 <carter> and theres A LOT going on
21:54:37 <carter> solidus-river: please share what you do / dont understand
21:54:37 <carter> etc
21:54:42 <carter> if you take the time to read it
21:54:56 <carter> a more traditional latexy .lhs file set is by spacekitteh
21:54:58 <carter> @hackage clifford
21:54:59 <lambdabot> http://hackage.haskell.org/package/clifford
21:55:06 <carter> @google haskell spacekitteh  clifford
21:55:07 <lambdabot> https://github.com/spacekitteh/haskell-clifford
21:55:22 <carter> solidus-river: her lib being more latexy in authorship
21:55:28 <carter> but also a bit more deeply mathy
21:55:31 <carter> from the outset
21:56:11 <carter> solidus-river: sound good?
21:59:59 <juhp> anyone had any luck building pandoc with llvm?
22:00:06 <solidus-river> carter: aye
22:00:17 <juhp> for me it gets stuck on Pretty.hs
22:00:21 <carter> juhp: why
22:00:27 <carter> juhp: share you error message
22:00:29 <carter> what OS
22:00:30 <carter> what arch
22:00:32 <carter> what ghc versions
22:00:34 <carter> what llvm versions
22:00:41 <carter> solidus-river: yay
22:01:14 <juhp> carter, no error - it doesn't finish - until it runs out of VM I guess ;)
22:01:18 <carter> :)
22:01:25 <carter> juhp: make your swap file bigger
22:01:31 <carter> what ghc version
22:01:32 <carter> what os
22:01:35 <carter> what llvm version
22:01:38 <lispy> juhp: how much memory do you have?
22:01:41 <juhp> Fedora 20, all arches I think, ghc-7.6, llvm-4,3
22:01:49 <juhp> lispy, 16G
22:01:52 <lispy> ah
22:01:55 <lispy> that's more than enough
22:01:55 <juhp> hehe ;)
22:02:02 <carter> juhp: 3.4?
22:02:03 <juhp> maybe try ;-P
22:02:11 <solidus-river> i dont have too much time to read it now but I will, I read through the Applicative / Monad instances
22:02:16 <carter> :)
22:02:17 <carter> haha
22:02:21 <carter> my code is ugly
22:02:26 <carter> for Shape?
22:02:29 <carter> or whic modules?
22:02:36 <juhp> carter, yes sorry 3.4
22:02:40 <juhp> but this is not new
22:02:41 <solidus-river> the only thing so far thats over my head is do the definition of a block recursive algorithm, do you have a good source?
22:02:49 <lispy> juhp: And you're building the latest pandoc on hackage?
22:02:49 <juhp> this issue I mean
22:02:57 <carter> solidus-river: block recurisve?
22:02:59 <carter> oh
22:03:02 <juhp> see above :)
22:03:05 <carter> solidus-river: ooo, your'e reading all my comments :)
22:03:08 <juhp> lispy, right now 1.12.3.3
22:03:29 <juhp> last successful ARM build was 1.11??
22:03:35 <juhp> let me check
22:03:41 <carter> juhp: ohhh, are you using gold or gnu ld?
22:03:44 <juhp> anyway just wonder
22:03:50 <juhp> carter, gnu
22:03:54 <carter> juhp: try gold
22:04:02 <carter> juhp: try gold + 7.8 ghc
22:04:15 <carter> lots of arm things work better with 7.8 afaik
22:04:18 <juhp> carter, the process is opt though
22:04:22 <carter> i know
22:04:26 <juhp> ok
22:04:30 <juhp> I will thanks
22:04:42 <juhp> yeah I hope 7.8 might help
22:04:48 <juhp> not quite there yet
22:05:21 <juhp> carter, is it better to use gold only for all ghc building?
22:05:31 <carter> ?
22:05:46 <carter> all i know is bgamari  found that gold is the only thing that works well for arm
22:05:53 <juhp> ah right
22:06:03 <juhp> so maybe llvm+gold is better
22:06:05 <carter> solidus-river: so you know how you can pretend that a big square matrix is made out of 4 smaller matrix
22:06:10 <carter> ?
22:06:45 <lispy> juhp: I don't see anything obviously bad about that code
22:06:46 <juhp> (but I just reproduced on intel too)
22:07:09 <juhp> lispy, me neither - I only looked briefly - so kind of surprising nod
22:07:38 * juhp really wishes we had ARM NCG or all moved to llvm ;)
22:08:03 <juhp> too often a pain
22:08:05 <carter> juhp: someones working on arm ncg afaik
22:08:14 <juhp> awesome
22:08:22 <carter> but if that happens, probably would only be V7/V8 onwards
22:08:26 <carter> or arch 64 only
22:08:29 <juhp> ah
22:08:33 <juhp> I see
22:08:55 <juhp> ah v7 works for me :)
22:09:09 <carter> juhp: wanna help contrib to ghc?
22:09:12 <carter> its really easy :)
22:09:31 <carter> solidus-river: so one block recurisive alg is you pretend those 4 smaller matrices are numbers
22:09:41 <carter> and recursively define matrix mult using that view
22:10:11 <juhp> carter, well yes but I already spend a lot of my time on Haskell maintenance and packaging for Fedora :)
22:10:15 <carter> ok
22:10:16 <carter> fair
22:10:19 <carter> i can't argue with that
22:10:24 * carter alutes
22:10:27 <carter> *salutes
22:10:32 <juhp> thanks :)
22:10:38 <carter> what arch? or all of them
22:10:56 <juhp> but yes principle I would like to contribute to ghc a little
22:11:38 <carter> do you know how the linux perf stuff works?
22:11:45 <carter> @google linux perf tool
22:11:45 <lambdabot> https://perf.wiki.kernel.org/
22:11:49 <solidus-river> carter: interesting
22:12:04 <juhp> carter, we have 3 primary archs i686, x86_64 and armv7 and 4 active secondary asks ppc/ppc64 and s390/s390x
22:12:19 <carter> solidus-river: whic part?
22:12:26 * hackagebot thyme 0.3.4.0 - A faster time library  http://hackage.haskell.org/package/thyme-0.3.4.0 (LiyangHu)
22:12:37 <juhp> (asks=arch's)
22:12:42 <carter> neat
22:12:51 <carter> juhp: so one thing i think some people would love
22:12:58 <solidus-river> carter: so making data structures that have their data stored in a way that is blocked by the smallest recursive algorithm of a common function over the structure and restructuring other functions to fit that mapping?
22:13:06 <solidus-river> carter: or was that off, i took a big jump
22:13:10 <carter> solidus-river: kinda
22:13:48 <carter> solidus-river: you're thinking "recurisvely split into smaller contiguous chunks, and at the bottom have a snazzy tuned alg"
22:14:04 <juhp> I am not really familiar with perf
22:14:20 <carter> k
22:14:20 <solidus-river> carter: i guess you could also define a set of mappings from the base structure to smaller chuncks that fit different classes of tuned alg's
22:14:39 <carter> solidus-river: the goal really is just matrix math
22:15:03 <carter> its still a few more days of me managing to focus on it before i cut an alpha with working exmaples
22:15:08 <solidus-river> this sounds extremley usefull for gpgpu stuff
22:15:17 <carter> solidus-river: it iwll be
22:15:18 <carter> eventually
22:15:25 <carter> the intial relase wont work for gpu
22:15:29 <carter> just ghc compiling stuff
22:15:41 <carter> but i've some ideas for gpu that I hope to try later if i can cover the time
22:15:44 <juhp> carter, you were going to suggest building newer versions of ghc or ?
22:15:53 <carter> juhp: ghc 7.8 + use GOLD for arm
22:16:05 <juhp> ok
22:16:45 <solidus-river> carter: good luck :), its a juicy idea to increase performance
22:17:06 <carter> solidus-river: what i'm really excited about is i'll have sparse/structured matrix support from day 0
22:17:27 <carter> still in the middle of a bunch of refactors relating to that
22:20:09 <juhp> I will try to see if gold helps with this llvm problem (note it is not ARM specific)
22:20:41 <juhp> https://bugzilla.redhat.com/show_bug.cgi?id=992430
22:22:55 <carter> juhp: what gcc / clang version?
22:22:56 <lispy> juhp: You said ghc is hanging on compiling pandoc?
22:23:07 <lispy> juhp: have you tried adding -v3 to make the build verbose?
22:23:14 <carter> juhp: ooooo were you building at O2?
22:23:21 <juhp> carter, yes actually
22:23:25 <carter> THATD DO IT
22:23:32 <juhp> ah
22:23:40 <carter> try with O1
22:23:42 <carter> i bet it works
22:23:45 <juhp> okay I will try to turn it down
22:23:56 <juhp> I was wondering about that too but then forgot to try
22:23:59 <juhp> thanks guys!
22:24:17 <carter> juhp: or O2 + -fno-specconstr
22:24:22 <juhp> lispy, I think I tried long ago but it was just hanging on opt
22:24:24 <carter> or whatever the way no-spec-constr is pselled
22:24:27 <carter> *spelled
22:24:29 <felixn> https://gist.github.com/munro/11e4eecc196a746a7975 <-- hay, can I write this shorter?
22:24:49 <felixn> I didn't want to use a "do" to apply a maybe :/
22:25:13 <carter> try using aplicative
22:25:45 <lispy> juhp: looking at that bug log it looks like llvm is broken not ghc.
22:26:17 <juhp> lispy, quite likely - but probably easier to workaround on the ghc side perhaps
22:26:19 <carter> is this llvm 3.4 or 3.2
22:26:23 <juhp> 3.4
22:26:28 <pavonia> :t maybe id (:) chr str
22:26:29 <lambdabot> Not in scope: ‘str’
22:26:30 <carter> what Opt level for llvm?
22:27:00 <pavonia> > maybe id (:) (Just 'f') "oo"
22:27:02 <lambdabot>  "foo"
22:27:17 <pavonia> felixn: ^
22:27:28 <felixn> pavonia: that's some foo right there
22:27:35 <juhp> need to check - I assume llvm gets the -O from cabal
22:27:55 <juhp> gcc-4.8.2 fwiw
22:28:39 <carter> ohhhhh
22:28:42 <carter> ohhhhhhhh
22:28:45 <carter> ohhhhhhhhhhhhh
22:29:22 <juhp> ah yes -O1 seems to get through Pretty very easily
22:29:36 <carter> so GCC is being invoked as the assembler
22:29:37 <carter> oooooo
22:29:41 <carter> right?
22:29:53 <juhp> hmm i might still mention this to pandoc upstream
22:29:56 <carter> nah
22:30:03 <carter> ok
22:30:06 <carter> heres what you should try doing first
22:30:15 <carter> try building this on a system with gcc4.8
22:30:18 <carter> * 4.9
22:30:27 <carter> because theres a bug in gcc 4.8's asssembler
22:30:37 <carter> that dies on some asm patter
22:30:40 <carter> that GHC can tirp
22:30:41 <pavonia> felixn: Shouldn't it be "many1 digit", btw?
22:30:48 <carter> juhp: try that first
22:30:54 <felixn> pavonia: yippiee! intConstant = (maybe id (:)) <$> (optionMaybe (char '+' <|> char '-')) <*> (many digit)
22:30:57 <felixn> pavonia: HAY
22:31:01 <carter> you know how to edit your GHC settings file juhp ?
22:31:02 <felixn> I'm the programmer here
22:31:06 <felixn> just answer my questions!
22:31:10 * felixn changes it to many1
22:31:41 <juhp> carter, settings file?
22:31:47 <carter> juhp: :))))
22:31:48 <carter> ok
22:32:00 <carter> so, where is your ghc installed?
22:32:16 <carter>  /usr/local/lib/ghc-7.6.3 or something?
22:32:22 <juhp> yeah
22:32:24 <carter>  /usr/local/lib/ghc-7.6.3/settings
22:32:27 <carter> is a fie
22:32:28 <carter> file
22:32:35 <carter> it has a GCC field
22:32:49 <carter> you can change that field ot point to other GCC / CC choicdes
22:32:56 <carter> (nb, stick to real gcc for now)
22:33:28 <carter> i bet you that if you try to build pandoc with gcc-4.9 picked in that settings file
22:33:32 <carter> you'll succeed
22:33:34 <solidus-river> is there a way to convert from a type alias to its parent type?
22:33:39 <solidus-river> or, the type it is aliasing?
22:33:49 <lispy> carter: gcc doesn't have an assembler. Do you mean, the part that spits out .s files?
22:34:03 <carter> lispy: gcc invokes an assembler
22:34:12 <juhp> carter, I think not though gcc-4.9 is in Fedora Rawhide and it still hung there on ARM the other day
22:34:27 <lispy> carter: gnu as is part of binutils
22:34:30 <carter> ah
22:34:34 <carter> hrmm
22:34:35 <carter> ok
22:34:38 <carter> try building on O1
22:34:43 <carter> what rawhide?
22:34:44 <carter> *whats
22:35:03 <juhp> sorry - Fedora development tree (currently going toward Fedora 21)
22:35:17 <juhp> http://koji.fedoraproject.org/koji/packageinfo?packageID=40
22:35:52 <juhp> yes -O1 looks good so I guess I will just use -O1 on ARM to build pandoc for now
22:36:02 <juhp> and hopefully with ghc-7.8 things will be better
22:36:02 <carter> @ask dolio what was that GCC bug you tracked down?
22:36:03 <lambdabot> Consider it noted.
22:36:32 <carter> juhp: could you try O2 + -fno-spec-constr
22:36:38 <juhp> sure
22:36:54 <carter> that might still die, but it might now
22:37:47 <carter> *not
22:38:08 <juhp> just hang on - waiting for -O1 build to finish
22:38:14 <carter> kk
22:38:42 <juhp> should be fine though I guess: static done and prof nearly too - so probably I could just kill it
22:39:00 <dolio> carter: https://gcc.gnu.org/bugzilla/show_bug.cgi?id=60436
22:39:12 <juhp> but it takes ages on arm so quite nice to know
22:39:27 <carter> dolio: why was gcc running CPP on asm?
22:39:51 <dolio> GHC told it to.
22:39:54 <carter> ahh
22:40:00 <carter> .... why was it ?
22:40:05 <carter> why does GHC doe that?
22:40:11 <dolio> Dunno. There's no CPP in the file.
22:40:18 <carter> i guess that would fail loudlyrather than OOM
22:40:22 <dolio> But it still uses asm-with-cpp or something.
22:40:38 <lispy> dolio: oh yeah, that's a weird choice
22:40:41 <lispy> I think it's new in 7.8
22:40:42 <carter> dolio: was that the clang workaround?
22:40:49 <carter> lispy: thats for using clang on haskell source
22:40:54 <carter> for cpp
22:40:55 <carter> safaik
22:41:19 <dolio> It does run with -DTABLES_NEXT_TO_CODE, but that isn't in the file.
22:42:22 <dolio> Maybe it could be? I don't know.
22:42:52 <dmj`> how can I get ghci to dump derived instances?
22:43:19 <shachaf> You probably can't.
22:43:23 <shachaf> But you can get ghc to do it.
22:43:25 <carter> http://www.haskell.org/ghc/docs/7.4.1/html/users_guide/options-debugging.html
22:43:33 <carter> -ddump-deriv:
22:43:37 <carter> :set -ddump-deriv
22:43:38 <carter> mabye
22:43:41 <dmj`> yea, I know ghc can do it, but it'd be nice if ghci could too :)
22:43:47 <carter> dmj`: try that
22:43:57 <carter> you can :set -$ANYGHCFLAG
22:44:02 <carter> i learned this magic recently
22:44:22 <shachaf> Not any flag, but apparently it does work with this one.
22:44:34 <carter> the -d flags at least
22:44:39 <carter> when thenyamek sense
22:44:44 <shachaf> So the answer is the same as for ghc.
22:44:47 <shachaf> ghci -ddump-deriv
22:45:38 <shachaf> http://www.haskell.org/ghc/docs/7.6.3/html/users_guide/flag-reference.html says that -ddump-deriv is a dynamic flag.
22:45:53 <juhp> carter, -fno-spec-constr doesn't seem to help here
22:45:55 <shachaf> I think that was the distinction I was thinking about, though there are some others for ghci.
22:46:21 <dmj`> carter, shachaf: super nice thanks!
22:46:39 <juhp> anyway -O1 is great - finally we will have pandoc back on ARM again
22:47:00 <juhp> maybe I shouldn't use -O2 on ARM for now?
22:47:06 <carter> juhp: try with 7.8 :)
22:47:19 <carter> juhp: if you can find ways to break 7.8, pleas report
22:47:25 <juhp> okay
22:47:48 <carter> heck, just trying to break ghc on the funkier platforms is a great way to help :)
22:48:06 <carter> i don't know how much of the stuff like pandoc has been tested on arm :)
22:48:09 <juhp> will try now
22:48:13 <juhp> with cabal-install
22:48:14 <felixn> woah, haskell ARM, that sounds fun!
22:48:30 <carter> try wihch?
22:48:55 <juhp> felixn, hehe - it is until you bump into llvm ;O)
22:49:04 <juhp> carter, well building pandoc :)
22:49:15 <carter> with 7.6 to completion?
22:49:21 <juhp> -O1 finished
22:49:22 <carter> whats your build box btw?
22:49:46 <juhp> a lenovo laptop here ;)
22:49:57 <carter> juhp: qemu? or theres a lenovo arm?
22:50:14 <juhp> carter, ah no - I mean I will do a llvm build with ghc-7.8
22:50:20 <juhp> on intel
22:50:24 <carter> oh
22:50:28 <carter> yeah, that should be fine
22:50:30 <carter> but test it out
22:50:34 <carter> llvm 3.4 right?
22:50:37 <juhp> yep
22:50:42 <carter> if it breaks with O2 thats a bug
22:52:05 <juhp> while I am moaning - also really wish that llvm would decouple its graphics pipeline into a separate package so that we are not forced to update llvm so often ;)
22:52:13 <carter> ?
22:52:18 <carter> what about it?
22:52:30 <carter> i have a 2011 mbair so i miss out on fun gpu stuff currently
22:53:51 <juhp> I just have a intel graphics :)
22:54:04 <juhp> I thin mesa needs current llvm
22:54:06 <juhp> think
22:54:09 <carter> well, does intel opencl suport your gpu?
22:54:15 <carter> it doesn't support mine :(
22:54:20 <juhp> dunno :)
22:54:25 <redtricycle> How do I map a regex to a list? I want :: Text.Regex.Posix -> [String] -> [Bool]
22:54:29 <juhp> 2d works for me ;-P
22:55:41 <johnw> redtricycle: \re -> map (=~ re)
22:56:37 <rshetty> I was going through the concepts related to Functional Programming, Mainly Monoids and Monads. Could someone point me to some references which delineate the concepts such as Monads and its usage. Thanks
22:56:46 <malutskis> How would you perform "BCD additions" on the following pairs of hexadecimal numbers: 23267 49684 in Haskell?
22:56:50 <rshetty> And also some of the commonly used Monads in Haskell
22:57:04 <redtricycle> johnw: so something like, map re myStrings \re -> map (=~ "[a-z]*"]
22:57:05 <redtricycle> ?
22:57:20 <johnw> ah, no
22:57:26 <johnw> you were asking for a function with that type
22:57:37 <johnw> map (=~ "[a-z]*") myStrings
22:57:49 <johnw> probably you want filter though, I bet
22:57:53 <malutskis> Anyone?
22:58:06 <lispy> malutskis: we don't have a built in way. You'd have to make a bcd adder
22:58:08 <redtricycle> map (=~ "[a-z]*" :: Bool) myStrings
22:58:27 <malutskis> lispy: How would the bcd adder look?
22:58:38 <johnw> redtricycle: depending on how you use the result, the type can be inferred
22:59:06 <redtricycle> Hmm, it's bonking on me, asking for the type
22:59:12 <redtricycle> how do I specify the type?
22:59:33 <lispy> malutskis: very similar to a broken 1 byte adder :)
22:59:44 <lispy> malutskis: do you know how bcd works?
23:00:11 <malutskis> lispy: yes
23:00:13 <lispy> > 0x9 + 0x1
23:00:15 <lambdabot>  10
23:00:16 <redtricycle> I'm in IO, so
23:00:33 <redtricycle> print $ map (=~ "[a-z]*") myStrings :: [Bool]
23:00:42 <redtricycle> syntax isn't quite right...
23:00:42 <lispy> > showHex (0x9 + 0x1)
23:00:44 <lambdabot>  <[Char] -> [Char]>
23:01:08 <lispy> > showHex (0x9 + 0x1) "" -- this needs to print 0x10
23:01:09 <lambdabot>  "a"
23:01:59 <johnw> print (map (=~ "[a-z]*") myStrings :: [Bool])
23:02:08 <lispy> > let addr
23:02:10 <lambdabot>  <hint>:1:9:
23:02:10 <lambdabot>      parse error (possibly incorrect indentation or mismatched brackets)
23:02:10 <lispy> oops
23:02:57 <malutskis> > showHex (0x23267 + 0x49684) ""
23:02:59 <lambdabot>  "6c8eb"
23:03:21 <jle`> > showHex (0xdead0000 + 0x0000beef) ""
23:03:23 <lambdabot>  "deadbeef"
23:03:43 <lispy> > let addr x y | x + y < 10 = x + y; addr x y | x + y == 10 = 16; addr _ _ = error "sum too large!" in showHex (addr 0x9 0x1) ""
23:03:45 <lambdabot>  "10"
23:04:03 <lispy> malutskis: that gets you a bit of the way there. Now you need to incorporate carry.
23:04:31 <lispy> (and you can improve it by combining the first two guards into one case)
23:15:07 <redtricycle> johnw: thanks, that worked in ghci
23:17:36 * hackagebot magma 0.2.2.0 - magma is an algebraic structure consisting a set together with an binary operation.  http://hackage.haskell.org/package/magma-0.2.2.0 (KatsutoshiItoh)
23:18:21 <solidus-river> aaaaargh, i'm trying to extract a Float out of postgreSQL using Database.PostgreSQL.Simple and its a Pain in the bum
23:18:32 <solidus-river> Float is not an instance of FromRow
23:18:39 <solidus-river> and i don't get why
23:18:41 <solidus-river> it says it should be
23:19:28 <corgifex> missing import?
23:22:36 * hackagebot yesod-pnotify 0.4.4.0 - Yet another getMessage/setMessage using pnotify jquery plugins  http://hackage.haskell.org/package/yesod-pnotify-0.4.4.0 (KatsutoshiItoh)
23:23:56 <solidus-river> corgifex: ?
23:24:11 <solidus-river> corgifex: sorry the error was FromRow apparently Float is not an instance of FromRow
23:24:23 <corgifex> yes. maybe the instance is in a module you didn't import
23:24:39 <solidus-river> so i cant read a float out of a postgreSQL query result, but i'm not seeing any good documentation or examples of extracting a Float
23:26:23 <solidus-river> corgifex: how can i tell?
23:26:45 <solidus-river> grr its been almost 2 hours thinking about this error to no solution
23:26:52 <solidus-river> i need to extract a float
23:27:02 <supki> solidus-river: what's your code?
23:27:16 <solidus-river> I could try extracting a String and reading it but i have a feeling that will fail with a type error at runtime because it checks the type of the field i'm reading from for sanity
23:27:37 * hackagebot tasty-quickcheck 0.8.1 - QuickCheck support for the Tasty test framework.  http://hackage.haskell.org/package/tasty-quickcheck-0.8.1 (RomanCheplyaka)
23:28:13 <supki> solidus-river: can you extract anything that's not Float?
23:28:53 <malutskis> > let addr x y | x + y < 10 = x + y; addr x y | x + y == 10 = 16; addr _ _ = error "sum too large!" in showHex (addr 0x23267 0x49684) ""
23:28:54 <lambdabot>  "*Exception: sum too large!
23:30:13 <supki> solidus-river: assuming you're using postgresql-simple there's an example under Extracting results section
23:31:01 <supki> solidus-river: in case you only want to extract one value you'll need Only
23:31:13 <supki> (haskell does not have one-tuples)
23:31:23 <solidus-river> supki: http://lpaste.net/104071
23:31:25 <joshhartigan> When is it recommended to specify the type of a function? (e.g myFunc = Int -> Int)?
23:32:33 <pqmodn> joshhartigan: usually top-level functions should be annotated
23:32:56 <joshhartigan> Sorry, what's a top-level function?
23:33:12 <solidus-river> i'm lost at how the heck to get past that
23:33:13 <jle`> i sometimes use annotations to plan out functions i write
23:33:22 <solidus-river> i've pretty much written every other function for my program except main
23:33:36 <pqmodn> one that's not nested inside another function. here g is a nested function: f x = x + g 100 where g n = n
23:33:56 <solidus-river> never thought trying to get a Float out of postgres would be the sticking point :P
23:34:23 <joshhartigan> Right, thank you
23:34:56 <jle`> type signatures can also be considered a form of documentation
23:35:25 <solidus-river> is there a way to get ghci to tell me all instances of a class?
23:35:38 <pqmodn> not without importing them first
23:35:49 <pqmodn> :info Class will show the ones in scope
23:35:57 <solidus-river> pqmodn thats ok, i'm just trying to think of how the heck i'm supposed to get this float out
23:36:03 <solidus-river> it compiles if i dont tell it i want a float with a type of
23:36:21 <solidus-river> (Ord a, FromRow a) => Connection -> IO a
23:36:44 <solidus-river> so there must be some non Integer type that is fromRow or some helper function in the library somewhere
23:38:07 <solidus-river> interesting, it says nothing is an instance of it
23:38:09 <solidus-river> what?
23:39:44 <coppro> what's a good way to write "check condition, if false abort, check next condition, if false abort" in a sequence of IO actions?
23:40:31 <Yoctogon> what kind of abort?
23:40:35 <lispy> :t sequence_
23:40:36 <lambdabot> Monad m => [m a] -> m ()
23:40:48 <coppro> Yoctogon: do not perform the remaining actions
23:41:03 <coppro> or technically, in this case, output an error and do not perform the remaining actions
23:41:08 <Yoctogon> oh i think i see
23:41:14 <Yoctogon> uhh
23:41:16 <jle`> do you want to actually have an error
23:41:19 <dmj`> multiway-if
23:41:20 <jle`> or just skip the rest silently
23:41:30 <coppro> jle`: skip the rest silently
23:41:33 <jle`> also, is the check IO Bool
23:41:35 <jle`> or Bool?
23:41:40 <coppro> the latter
23:41:44 <jle`> oh
23:41:54 <jle`> um
23:42:00 <jle`> so where's the IO?
23:42:08 <jle`> :t when
23:42:09 <lambdabot> Monad m => Bool -> m () -> m ()
23:42:20 <coppro> in the result... I like dmj`'s suggestion
23:42:37 <jle`> when the condition is true, it executes the given IO action; when it is false, it skips it
23:42:58 <corgifex> when (and [c1, c2, c3, c4]) doStuff
23:44:45 <darthdeus> guys is there something for haskell-mode in emacs that makes C-c C-l use cabal repl instead of ghci repl?
23:44:57 <dmj`> coppro: I may have misread. If the first succeeds you want the second executed as well? If so, multi-way if will not be good for that.
23:46:30 <jle`> a/b 13
23:46:36 <jle`> er sorry
23:47:19 <dmj`> coppro: why can't you check both at the same time?
23:48:26 <coppro> dmj`: less expressive that way
23:48:48 <coppro> though I suppose if it was really complicated I could break it out into a predicate, this works well
23:49:35 <dmj`> > case all [True, True] of { True -> "yay"; False -> "boo" }
23:49:37 <lambdabot>  Couldn't match expected type ‘a0 -> GHC.Types.Bool’
23:49:37 <lambdabot>              with actual type ‘[GHC.Types.Bool]’Couldn't match expected type ...
23:49:37 <lambdabot>              with actual type ‘GHC.Types.Bool’Couldn't match expected type ‘[...
23:49:37 <lambdabot>              with actual type ‘GHC.Types.Bool’
23:49:51 <jle`> and
23:49:56 <dmj`> yea :P
23:50:01 <dmj`> > case and [True, True] of { True -> "yay"; False -> "boo" }
23:50:03 <lambdabot>  "yay"
23:50:21 <dmj`> darthdeus: yes, you have to rebind
23:50:30 <dmj`> darthdeus: this is what I do: http://lpaste.net/104072
23:50:43 <dmj`> see the "after-eval-load" part
23:50:53 <dmj`> "eval-after-load"
23:51:45 <solidus-river> well, the answer was Only, i really wish whoever documented that lib added an example of that use case
23:57:43 * hackagebot metadata 0.1.7.0 - metadata library for semantic web.  http://hackage.haskell.org/package/metadata-0.1.7.0 (KatsutoshiItoh)
