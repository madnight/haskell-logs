00:00:10 <hunt> best way to divide 2 ints to a float
00:00:12 <kazagistar> dunno, pavonia, that way of doing it is a lot less... beginner friendly
00:00:19 <hunt> ? should i use fromIntegral?
00:00:37 <kazagistar> * I meant the sequence example
00:00:41 <hunt> cococo: how far are you into it?
00:01:34 <cococo> hunt: I've read a few pages of "Learn You a Haskell" a week ago or so, but yesterday/today is really the first time(s) I've put time into actually learning
00:01:58 <cococo> woah, I wrote that badly. It's midnight though.
00:02:03 <coppro> hahhaa I thought hunt was aimed at me
00:02:09 <coppro> cococo: only midnight? hah
00:02:24 <cococo> Amateur, I know
00:02:39 <coppro> cococo: the most amazing thing about haskell is that somehow I can actually go back and understand what I wrote sometimes
00:02:49 <cococo> http://lpaste.net/4982037449178873856 <-- Why do I get an IO error when there is no IO? :(
00:03:06 <bergmark> :t sequence
00:03:08 <lambdabot> Monad m => [m a] -> m [a]
00:03:20 <coppro> cococo: Because main must have type IO ()
00:03:26 <cococo> coppro: I'm learning because it's like a drug. A while back I learned Python because that XKCD "it makes programming fun again" comic and now I need more.
00:03:57 <coppro> cococo: also [a] ++ [b] is better written as [a, b] :)
00:03:58 <cococo> oh wtf.. so when I rename it somethingNotMain it works
00:04:07 <cococo> good call, thanks
00:04:42 <coppro> cococo: you'll get to this as you read up more, but in Haskell, all IO must take place in the IO "monad" (don't worry about what a monad is for now)
02:06:58 --- topic: 'http://www.haskell.org/ | Paste code/errors: http://lpaste.net/new/haskell | Logs: http://tunes.org/~nef/logs/haskell/?C=M;O=D http://ircbrowse.net/day/haskell/today?mode=recent | Administrative issues: #haskell-ops | Hackage down? http://hdiff.luite.com | XCode 5 issues? http://is.gd/H4sEub | Need an op? Try: @where ops'
02:06:58 --- topic: set by johnw on [Mon Feb 17 18:32:10 2014]
02:36:14 <jtcwang> Hey guys, I'm working in a cabal sandbox atm, and when i do "cabal repl" to load some of my tests files under tests, it seems to use the configuration settings for the executable
02:36:18 <jtcwang> instead of the tests
02:36:37 <gaet> ciao
02:36:39 <gaet> !list
02:36:39 <monochrom> gaet: http://lpaste.net
02:36:57 <jtcwang> which means that it'll say the the module is hidden
02:37:17 <jtcwang> even though I've listed it under the test-suite section in .cabal file
02:37:39 <jtcwang> http://lpaste.net/104459
02:50:40 <archblob> anyone on 7.8 around ?
02:51:29 <archblob> is anyone is, can you help me and see if you can build fastcgi ?
02:51:34 <archblob> *if
02:52:06 <archblob> from the deprecation warnings I see with 7.6 you should not be able to
02:52:25 <archblob> just want to be sure :-P
02:54:00 <heudebeu_> cgi fails to install...
02:54:27 <heudebeu_> with 7.8.2
02:54:55 <archblob> heudebeu_, thank you!
02:55:11 <heudebeu_> no problem :)
02:55:26 <archblob> what does it say ?
02:59:04 <heudebeu_> http://lpaste.net/104460
03:00:38 <archblob> heudebeu_, thank you again!
03:01:04 <sopvop> hm, "use a standalone 'deriving instance' declaration so you can specify the instance context yourself" means I can specify role with deriving clause?
03:01:18 * hackagebot jsonrpc-conduit 0.2.5 - JSON-RPC 2.0 server over a Conduit.  http://hackage.haskell.org/package/jsonrpc-conduit-0.2.5 (GabrieleSales)
03:20:17 <Wayneoween> Anyone who wants a keybasi.io invite?
03:22:10 <NinjaPenguin> Wayneoween: What's that? Just asking out of curiosity.
03:22:52 <Wayneoween> NinjaPenguin: Its an addition to GPG-Keys
03:23:37 <NinjaPenguin> Oh cool.
03:23:45 <Wayneoween> Trying to get more users to encryption I guess. With it you can associate your twitter/github/homepage to your GPG Key to prove you are who say you are
03:37:01 <adas> Wayneoween: hi there. can i get one?
03:37:26 <Wayneoween> Well yes, I had a typo there, its keybase.io :o
03:41:12 <sjy> Wayneoween: if you've got spare invites, i'll take one :)
03:43:57 <awestroke> I've always wondered, you GPG people, what happens if you lose your private key?
03:44:21 <adas> i guess its all over
03:44:47 <sjy> you can't prove that you're the same person you used to be, or you can't decrypt anything you encrypted using that key
03:45:05 <dario> you pull out your revocation certificate that you safely stored somewhere safe safely when you created the key
03:45:12 <Wayneoween> awestroke: then you would have to dig out your revocation keys and revoke your key, create a new one.
03:45:22 <awestroke> adas: move to the wilderness and live your the rest of your days as a hermit?
03:45:45 <adas> awestroke: what are you alluding to?
03:46:06 <awestroke> "i guess its all over"
03:46:14 <awestroke> dario, Wayneoween: aha. did not know about revocation keys
03:46:23 * hackagebot rest-gen 0.11 - Documentation and client generation from rest definition.  http://hackage.haskell.org/package/rest-gen-0.11 (AdamBergmark)
03:47:57 <adas> awestroke: by its all over i meant that anyone who has your private key will be able to read all your encrypted info
03:48:14 <adas> awestroke: if you lost it and no one else found it either then all your encrypted info is gone for good
03:48:34 <LangeOortjes> adas: well, you should have encrypted your private key, so they'd need the passphrase of it as well
03:49:15 <awestroke> but if you use your GPG key for everything, you might lose your online identity
03:50:01 <awestroke> hm, I guess it depends on how your mail is set up, though
03:50:21 <adas> LangeOortjes: the passphrase will protect the key to an extent. but isn't it relatively easy to brute force the passphrase?
03:51:04 <sjy> not if it's a secure passphrase
03:53:32 <adas> again, helps .. to an extent
04:04:57 <fikusz> does anyone use the units package? I'd like to see some examples
04:06:06 <alpounet> fikusz: there are some here, but seem to be outdated according to Richard: https://github.com/goldfirere/units (scroll down in the readme)
04:06:14 <alpounet> that could help you get started though
04:06:48 <fikusz> alpounet: I've looked at those and I have trouble with them on version 2 of the library
04:07:58 <alpounet> fikusz: maybe https://hackage.haskell.org/package/units-defs could help?
04:08:10 <alpounet> it defines SI units
04:09:12 <fikusz> alpounet: thanks, I used that to define my own units, but I still have problems using them
04:09:49 <alpounet> fikusz: ah, well i'm not familiar enough to be able to help, maybe you should just shoot an email to the author
04:09:50 <fikusz> I'm getting long and confusing type errors even for a simple 1.0 % Meter
04:10:20 <tdammers> passphrase makes it so that if the key gets compromised, it takes a while to crack it, and in the meantime, you can issue a new key and re-encrypt your stuff
04:11:12 <tdammers> also, kind of almost-two-factor auth
04:12:18 <LangeOortjes> tdammers: do you know which algorithm is used to protect the private key?
04:16:09 <LangeOortjes> I can't imagine the GPG developers using an encryption scheme that's easily bypassed. When your private key is compromised, all data encrypted using your public key will become accessible. Encryption of your private key isn't a method of buying you some time, it prevents partial identity theft and access to encrypted data
04:20:07 <tdammers> same thing, really
04:20:15 <tdammers> all encryption ever does is buy you time
04:20:26 <tdammers> (billions of years, sometimes, but still)
04:22:09 <haasn> adas: No, brute forcing the passphrase can be made very difficult except in various very degenerate/bad password cases
04:22:26 <haasn> adas: On my machine, it would take a second or two per attempt
04:22:49 <haasn> And you can go even further, by plugging in scrypt or another password handling mechanism
04:24:07 <haasn> LangeOortjes: as for which algorithm, it's configurable. GnuPG will use SHA-1 by default. See --s2k-digest-algo
04:24:12 <tdammers> the biggest issue with brute-forcing is that it is inherently parallelizable
04:24:30 <haasn> LangeOortjes: And CAST5 for actually encrypting it with the derived passphrase, --s2k-cipher-algo
04:24:52 * Lethalman thought gpg used aes to encrypt the secret key
04:25:00 <haasn> Not by default, no
04:25:06 <Lethalman> or that was openssh with rsa
04:25:18 <tdammers> full-disk crypto tends to use aes
04:25:20 <tdammers> IIRC
04:25:29 <BoR0> what's the difference between getLine and readLn :: IO String?
04:25:39 <Lethalman> ah yes ssh-keygen uses AES, confused sorry :)
04:25:48 <BoR0> more specifically, why does readLn :: IO String fail on "no parse" if I don't put input quotes?
04:26:01 <BoR0> s/put//
04:26:18 <haasn> BoR0: readLn :: IO String is like fmap read getLine :: IO String
04:26:27 <haasn> BoR0: and read :: String -> String is *not* an identity
04:26:32 <yitz> @type readLn
04:26:33 <lambdabot> Read a => IO a
04:26:36 <haasn> Instead, it's more or less an isomorphism to show
04:26:46 <haasn> > show "hello, world"
04:26:47 <lambdabot>  "\"hello, world\""
04:26:53 <haasn> > read "\"hello, world\""
04:26:55 <lambdabot>  *Exception: Prelude.read: no parse
04:26:58 <haasn> > read "\"hello, world\"" :: String
04:26:59 <lambdabot>  "hello, world"
04:27:10 <yitz> > fix show
04:27:12 <lambdabot>  "\"\\\"\\\\\\\"\\\\\\\\\\\\\\\"\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"\\\\\\\\\\\\\...
04:27:32 <BoR0> so is there a way to read a string with readLn without having to input quotes?
04:27:38 <haasn> getLine
04:27:46 <BoR0> got it
04:27:56 <haasn> (It's possible, but not with the Read String instance)
04:28:06 <haasn> (And that is the wrong approach either way)
04:28:17 <haasn> (readLn is for when you want “read”-like behavior. If you only want to read in a string, you do not want to “read” it)
04:46:04 <wojtekM_> > data D = D1 { f1 :: Int } | D2 { f1, f1 :: Int } -- Should this compile?
04:46:05 <lambdabot>  <hint>:1:1: parse error on input ‘data’
04:46:30 * hackagebot pi-calculus 0.0.1 - Applied pi-calculus compiler  http://hackage.haskell.org/package/pi-calculus-0.0.1 (renzyq19)
04:46:41 <wojtekM_> It does compile (with duplicate field)
04:50:29 <BoR0> how can I handle read :: MyDataType "no parse" exception?
04:51:06 <haasn> wojtekM_: I don't know if it will, but I think it *shouldn't*
04:52:06 <BoR0> here's what I am making http://lpaste.net/5218746299590901760 and I want my program not to crash if the user inputs something other than Push Int | Pop | Reset
04:53:26 <haasn> Oh, EmptyDataDecls is allowed by default in Haskell 2010?
04:53:40 <BoR0> aha, readMaybe seems to work
04:53:42 <BoR0> @src readMaybe
04:53:42 <lambdabot> Source not found. My brain just exploded
04:55:43 <haasn> readMaybe s = case reads s of [(x,"")] -> Just x; _ -> Nothing
04:56:24 <BoR0> what's reads? can you show some examples?
04:56:35 <haasn> :t reads
04:56:36 <lambdabot> Read a => ReadS a
04:56:50 <haasn> ReadS a = String -> [(a, String)] -- iirc
04:57:22 <haasn> > reads "3" :: [(Int, String)]
04:57:23 <lambdabot>  [(3,"")]
04:57:26 <haasn> > reads "3.5" :: [(Int, String)]
04:57:27 <lambdabot>  []
04:57:32 <haasn> Ha, that one is tricky
04:57:35 <haasn> > reads "3,5" :: [(Int, String)]
04:57:37 <lambdabot>  [(3,",5")]
04:57:44 <BoR0> :)
04:57:51 <BoR0> ok, I see
04:57:52 <BoR0> @src reads
04:57:52 <lambdabot> reads = readsPrec minPrec
04:57:58 <haasn> It should probably have been [(3,".5")] in the middle case, but GHC's weird reads implementation for Int does that
04:59:05 <haasn> What I wonder though is if there's any example of a Read instance in base where reads can return *multiple* possible parses
05:02:13 <BoR0> how would you improve this? http://lpaste.net/5218746299590901760 elegance wise etc
05:06:02 <wojtekM_> haasn: It does compile under GHC 7.6.3
05:06:24 <fizruk> BoR0: readMaybe is already defined in Text.Read
05:07:29 <haasn> BoR0: line 18 can be written as “case readMaybe (capitalized x) of”, the parens and type annotation are unnecessary
05:07:30 <fizruk> BoR0: also I would break stackLook into parsing and interpreting
05:07:42 <fizruk> *stackLoop
05:07:48 <BoR0> aha, ok. will do that
05:08:29 <BoR0> fizruk, how would I start for that? write a separate function for each command?
05:08:36 <haasn> What is the Maybe Int for?
05:08:59 <BoR0> initially stack is [] with Nothing as current value
05:09:08 <BoR0> or if you try to do pop []
05:09:25 <NinjaPenguin> Will that not cause stack overflow if you use it enough?
05:09:49 <haasn> BoR0: stackLoop s = do print s; x <- getLine; case readMaybe (capitalized x) of Just c -> run c s; Nothing -> stackLoop s
05:10:04 <haasn> or perhaps
05:10:07 <haasn> stackLoop (run c s)
05:10:11 <BoR0> why should it cause stack overflow?
05:10:20 <haasn> that way command :: Command -> Stack -> Stack
05:10:35 <BoR0> neat!
05:10:48 <haasn> er, run ::
05:10:48 <NinjaPenguin> I come from imperative programming languages, so a function calling itself will eventually overflow stack.
05:10:50 <haasn> I forgot I renamed it
05:11:19 <haasn> NinjaPenguin: Haskell is neither imperative nor does it have function calls or call stacks
05:12:04 <haasn> BoR0: also, I would personally skip the Command ADT, capitalization logic and Read instance
05:12:09 <katla> hi
05:12:13 <haasn> It doesn't really strike me as elegant
05:12:23 <katla> how do you do graphs in haskell?
05:12:32 <katla> all I can define with 'data' is trees
05:12:50 <katla> but i want to implkement graph algorithms
05:12:59 <mayski> http://hackage.haskell.org/package/containers-0.2.0.1/docs/Data-Graph.html ?
05:13:22 <fizruk> mayski: your containers are out of date :p
05:13:39 <mayski> oh :#
05:13:41 <mayski> :3
05:13:51 <haasn> BoR0: Handling commands well is a very tricky business, but something simple could be: case words x of ["push", readMaybe -> Just i] -> push i; ["pop"] -> pop; ["reset"] -> reset
05:13:52 <mayski> just remember seeing that one time and googled it sorry
05:13:56 <srhb> katla: Graphs can be represented internally in all manner of ways.
05:14:00 <NinjaPenguin> haasn: Programming languages don't have call stacks, but programs do. That way the system knows where to return if a function returns.
05:14:32 <haasn> NinjaPenguin: Programs are just things written in programming languages
05:14:54 <NinjaPenguin> haasn: And what's your point?
05:15:35 <haasn> That Haskell programs don't have call stacks, they have declarations and definitions and expressions
05:16:15 <NinjaPenguin> So it's just one big loop in bytecode? Or does Haskell not compile to bytecode?
05:16:25 <haasn> Haskell compiles to whatever you want to compile it to
05:16:30 <haasn> it's a language
05:17:46 <NinjaPenguin> And x86 machines have call stack, so there will be a stack that can overflow if you have too many recursive calls.
05:18:02 <katla> is there a haskell way to do graphs and for testing generating random ones, and showing a picture of them
05:18:14 <haasn> Fortunately GHC does not compile to x86 in a way that makes his program overflow the call stack
05:19:00 <srhb> NinjaPenguin: You should read up one graph reduction engines. :)
05:19:16 <srhb> on*
05:19:32 <fizruk> katla: there’s Data.Graph to work with graphs
05:20:18 <fizruk> katla: there’s QuickCheck that allows you to test properties on random values (e.g random graphs)
05:20:49 <katla> i need to display them as an image though, it's not a property I can check automataically
05:21:00 <katla> well there is some, thta will be useful too
05:21:34 <BoR0> NinjaPenguin, I believe GHCi very well optimizes recursion, since it's the key to writing loops
05:21:56 <BoR0> it's probably not even recursion at machine level, just some while loops
05:22:23 <srhb> BoR0: Depends, some recursions will indeed be optimized into nice, tight loops, but not all
05:22:36 <geekosaur> actually ghci does no optimization
05:22:36 <NinjaPenguin> Machine code doesn't have while loops though, but goto loops. But yeah, I get your point.
05:22:40 <fizruk> katla: you can generate random graphs with Arbitrary instance http://hackage.haskell.org/package/QuickCheck-2.7.3/docs/Test-QuickCheck-Arbitrary.html
05:22:54 <katla> ok thanks a lot
05:23:04 <BoR0> NinjaPenguin, it doesn't even have goto loops then, because there are no labels. it has jumps to addresses :)
05:23:36 <fizruk> katla: though there is no Arbitrary Graph instance, you can make one (depending on kinds of Graph you want to generate)
05:24:36 <esoto> haskell has tail call recursion, which optimizes the loopz
05:24:47 <NinjaPenguin> BoR0: Yeah but jump loops sounds silly. I thought goto loops would be more fitting.
05:24:57 <fizruk> katla: I don’t know how to draw graph image with haskell, but I’m sure you can dump it into a file at feed it to a third party tool
05:25:02 <haasn> Haskell does not have tail call recursion because Haskell does not have tail calls
05:25:03 <katla> okay
05:25:16 <haasn> katla: It might help to ask byorgey or others in #diagram
05:25:18 <haasn> #diagrams sorry
05:25:26 <katla> oh thanks
05:26:24 <esoto> that is semantics
05:28:30 <srhb> esoto: What exactly do you mean by tail call recursion?
05:29:24 <awestroke> @pl \m f -> join . fmap f $ m
05:29:25 <lambdabot> (>>=)
05:30:12 <geekosaur> wrt tail calls, depending on how (and at what level) you look at it either there are no tail calls or everything is a tail call in ghc. It's just not a useful concept
05:30:49 <srhb> Someone ought to expand the guarded recursion page :)
05:30:50 <awestroke> can I make it more legible without just changing it to (>>=) ?
05:31:32 <merijn> awestroke: In what way?
05:31:45 <haasn> join $ fmap f m
05:31:53 <haasn> but that's just f =<< m
05:31:57 <fizruk> :t flip ((join .) . fmap)
05:31:58 <lambdabot> (Functor m, Monad m) => m a1 -> (a1 -> m a) -> m a
05:32:29 <merijn> join followed by fmap is just bind, so...
05:32:37 <awestroke> merijn: yes, I know that
05:33:00 <awestroke> I am creating a default implementation of >>= given join
05:33:40 <srhb> awestroke: Your version is fine, as is haasns. Everything else will just be more cluttered, like join . flip fmap etc
05:33:45 <fizruk> awestroke: m >>= f = join (fmap f m)  ?
05:34:40 <awestroke> :t join . flip fmap
05:34:41 <lambdabot> ((a -> b) -> a) -> (a -> b) -> b
05:34:47 <awestroke> oops
05:34:56 <awestroke> fizruk: that does look good
05:35:13 <fizruk> awestroke: keep it simple :p
05:35:39 <fizruk> :t (join .) . flip fmap
05:35:40 <lambdabot> (Functor m, Monad m) => m a1 -> (a1 -> m a) -> m a
05:36:37 <fizruk> :t tabulate
05:36:38 <lambdabot> Not in scope: ‘tabulate’
05:38:54 <BoR0> haasn, so I have runCommand :: Command -> Stack -> Stack right now. so everything is fine, I have pattern matched against runCommand Push, Pop, etc. now, how can I pattern match against "Save" (that will save the current stack into a file) with runCommand?
05:39:12 <randomclown> What's a good way to turn type inferenc into a programming competition problem?
05:39:37 <merijn> randomclown: What do you mean?
05:39:38 <randomclown> i.e. sherlock has a bunch of clues (type signatures) and somehow has to deduce the signature of the villian
05:39:51 <haasn> BoR0: In your system, by adding it to Command
05:40:04 <BoR0> I did that, but won't Save/Load make my runCommand impure?
05:40:08 <randomclown> merijn: create a problem where the a type inference algorithm is required to solve it
05:40:09 <BoR0> since it will involve IO
05:40:20 <merijn> randomclown: Type inference is done using unification, so just look at problems that involve unification
05:40:20 <haasn> Oh, good point. You could treat it separate; personally I would still go with the approach I described way back
05:40:37 <halvorg> Hm, how would  you go about building a linked list out of order? im thinking building a map then using the values, but that seems convoluted
05:40:47 <haasn> Or you could even do -> IO Stack
05:40:52 <haasn> But that's a bit unsatisfactory as well
05:41:18 <BoR0> I see
05:41:30 <haasn> halvorg: depends on the order
05:41:35 <randomclown> merijn: "implemnt a broken version of prolog"
05:41:38 <randomclown> haha
05:42:01 <fizruk> randomclown: constraint satisfaction/optimization problems would be even broader
05:42:06 <haasn> randomclown: UndecidableInstances
05:42:38 <haasn> That oughta keep the monkeys occupied for a while
05:42:44 <merijn> halvorg: What are you trying to do?
05:42:59 <merijn> halvorg: i.e. why do you need to build it out of order?
05:46:10 <halvorg> merijn: I have a list of indices (a) that are in the right order. I have another list of indices (b), that index a list (c). I want to reorder list c and output a list (d) such that d[a] = c[b]
05:48:53 <halvorg> http://lpaste.net/104461
05:48:55 <merijn> halvorg: I would just go through Map, yeah and then use toAscList or whatever
05:49:04 <halvorg> that's the code now, and it aint pretty
05:49:21 <halvorg> but it works
05:49:48 <merijn> halvorg: fyi the (!) operator already does "fromMapToJust"
05:49:53 <merijn> :t (M.!)
05:49:54 <lambdabot> Ord k => M.Map k a -> k -> a
05:50:41 <halvorg> oh ok, thanks
05:55:56 <`Jake`> http://lpaste.net/104462
05:56:42 <`Jake`> can someone tell me why product doesn't grow linear in the time it needs here?
05:56:50 <`Jake`> s/linearly/linear
05:56:59 <`Jake`> s/linear/linearly
05:57:14 <tdammers> s/recursion/recursion/
05:58:09 <`Jake`> the first substitution doesn't do anything though, so it's at least terminating
05:58:23 <`Jake`> If one doesn't execute it more than once
05:59:57 <phadej> `Jake`: multiplication of integers in that range is not O(1) operation
06:00:28 <`Jake`> phadej: I thought that it might not be, but I didn't expect it to be _that_ far away from it...
06:02:01 <`Jake`> phadej: And since the parallel function won't be able to run too many threads at once, I thought it would be quite noticable in that as well, if it is multiplication
06:02:56 <phadej> `Jake`: from http://en.wikipedia.org/wiki/Factorial fac 2M \approx 3e11733474, that's pretty huge for me
06:03:02 <phadej> try with `sum`
06:03:15 <`Jake`> phadej: That's a good idea, thanks
06:06:39 * hackagebot sign 0.4.0 - Arithmetic over signs and sets of signs  http://hackage.haskell.org/package/sign-0.4.0 (MasahiroSakai)
06:07:55 <`Jake`> okay, now the 2M ones need about a third of a second.
06:08:58 <`Jake`> Still not quite sure why the parallel factorial didn't need very long for 2M.
06:12:10 <`Jake`> I think I might be getting it now though; The threads which multiply the smaller numbers terminate very quickly, leaving only a few threads with very large numbers to be run
06:16:41 * hackagebot finite-field 0.8.0 - Finite Fields  http://hackage.haskell.org/package/finite-field-0.8.0 (MasahiroSakai)
06:22:40 <vova> Does anyone use Data.Time module? I can not find the function like diffClockTimes  from System.Time (old-time) module there.
06:25:29 <benzrf> > "aww" \^-^/ "yeah"
06:25:30 <lambdabot>  "aww \\^-^/ yeah"
06:25:42 <tayacan> vova, I think so - I use Data.Time.Format and Data.Time.LocalTime in a recent project.
06:27:16 <`Jake`> :t (\^-^/)
06:27:17 <lambdabot> [Char] -> [Char] -> [Char]
06:30:11 <BoR0> @src liftIO
06:30:11 <lambdabot> Source not found. You untyped fool!
06:30:21 <tdammers> burrrrrn!
06:30:46 <vova>  You're talking about NominalDiffTime? I do not like it.
06:31:08 <vova> diffUTCTime
06:34:26 <`Jake`> Now I don't get something else, though; A parallel function which calculates the same as sum [1..n] needs almost exactly the same time as the non-parallel version (parallel takes a few percent longer), even for n = 200 million
06:35:15 <Raydiation> hi, i was wondering if there was a nice way to transform this into functional programming https://dpaste.de/X8gv (src is javascript)
06:35:43 <Raydiation> reverse is an iterator that starts with the last element
06:35:51 <onielfa1> I have a question regarding escaping backslash in a String. Does anyone can help me?
06:36:12 <merijn> onielfa1: Depends on the question? :p
06:36:35 <onielfa1> an easy one I think :)
06:36:57 <onielfa1> I just want to escape backslash in a literal String
06:37:02 <onielfa1> something like
06:37:16 <onielfa1> folder = "\\path\folder"
06:37:27 <rwbarton> Raydiation: something like: when (any (\item -> top (position item) < 0) (take limit $ reverse items)) callback
06:37:40 <Raydiation> rwbarton: thanks
06:37:45 <onielfa1> obv, this does not work
06:38:03 <merijn> > "\\\\path\\folder" -- what's the problem?
06:38:04 <lambdabot>  "\\\\path\\folder"
06:38:08 <rwbarton> though note that linked lists are not intended to be traversed from the end, if it needs to be efficient then use a different data structure
06:38:15 <merijn> oh, right, silly Show instance of String
06:38:19 <Raydiation> right
06:38:39 <`Jake`> > putStr "\\\\path\\folder"
06:38:41 <lambdabot>  <IO ()>
06:38:49 <`Jake`> oh, right
06:39:09 <merijn> `Jake`: :p
06:39:25 <onielfa1> mm
06:39:32 <onielfa1> I don't follow you
06:39:41 <onielfa1> is it just a problem of the show instance?
06:40:00 <merijn> onielfa1: The Show instance produces a String that's valid haskell input
06:40:14 <merijn> onielfa1: If you try "putStrLn" on that in GHCI you'll see it's correct
06:40:31 <merijn> However, if you let ghci echo the String directly, ghci will use the show instance
06:40:33 <onielfa1> merijn: ah ok :9
06:40:41 <remdezx> Hello! If i got a funkction like this: "let f a = (1, a)", can I assume in production code, that "fst $ f undefined" always works?
06:41:19 <rwbarton> yes
06:41:44 <onielfa1> merijn: ok, so if I put in my code directly "\\\\path\\folder" and use it to do some IO on it, I will have no problem
06:41:55 <remdezx> rwbarton: is it guaranteed in Haskell standard?
06:42:07 <onielfa1> merijn: even if ghci shows otherwise
06:42:38 <rwbarton> remdezx: yes
06:42:49 <rwbarton> moreover, there is lots of existing code which relies on this sort of thing
06:42:55 <`Jake`> onielfa1: What does ghci show?
06:43:35 <onielfa1> `Jake`: Prelude> let folder = "\\\\folder\\folder" Prelude> folder "\\\\folder\\folder"
06:43:50 <`Jake`> onielfa1: what if you write putStrLn folder?
06:43:56 <remdezx> rwbarton: Can you find me such example? I always thought that undefined should never occur in production code
06:44:01 <`Jake`> er wait
06:44:16 <`Jake`> yes,putStrLn folder
06:44:18 <onielfa1> `Jake`: then it shows the correct one
06:44:26 <`Jake`> ok, then it should be correct
06:45:01 <onielfa1> `Jake`: yes, I should ignore what ghci shows when printing it
06:45:14 <onielfa1> merijn: `Jake`: Thanks :)
06:47:49 <rwbarton> remdezx: well I guess I'm not thinking of examples of undefined specifically, but more generally code that relies on values not being evaluated if they're not needed. things like tying-the-knot
06:47:57 <rwbarton> it's a quite fundamental property of the language
06:48:09 <Marquis> hello, i got a question. I want to use the kmeans vector algorithm and transformed my data so i can use it. in the terminal my input looks like it should be BUT i get following error: Couldn't match type `V.Vector Double' with `Data.Vector.Unboxed.Base.Vector Double'. I just used the Data.Vector module and am not sure where i unboxed the vector
06:49:26 <remdezx> rwbarton: thanks a lot!
06:49:32 <rwbarton> remdezx: of course, it's possible for the programmer to make a mistake and accidentally evaluate (in this example) the second component of the pair too, so in practice it's better to at least use error "some unique string" than simply undefined
06:50:00 <rwbarton> so that, in case you got it wrong, you find out immediately which undefined value got evaluated
06:51:19 <remdezx> rwbarton: you are right, I'll take care of it
06:51:29 <remdezx> rwbarton: thank you once again ;)
06:52:34 <cococo> Morning #haskell. How can I get a function to execute at the start of my script?
06:52:53 <cococo> (Naming it "main" causes some sort of IO error, but I'm a scrub so I don't know how to fix it)
06:53:16 <LangeOortjes> cococo: Haskell programs aren't really scripts. main is indeed the entry point but  its result should be an IO action
06:53:53 <Deewiant> Marquis: Possibly a library you're using requires Data.Vector.Unboxed, try using that module instead of Data.Vector
06:54:43 <cococo> LangeOortjes: Okay, so in this code I wrote last night (http://lpaste.net/104452) should I name the last function "name" and print the output in a "do" function?
06:54:49 <Deewiant> cococo: If you want to do the same thing as ghci does interactively, do "main = print (put your function call here)"
06:55:44 <LangeOortjes> cococo: what Deewiant said, you will want to do something with somethingNotMain, otherwise there would be no point in evaluating it
06:56:28 <eacameron> HashTable has lookup algorithms with O(1) performance, but I have heard it is actuall O(key length), is that true?
06:56:29 <cococo> Deewiant & LangeOortjes: Got it. Before I was just calling the somethingNotMain function in GHCI but I guess that wouldn't work once actually compiling the program
06:57:22 <LangeOortjes> Then you'll have to make sure that the function is evaluated, you will have to do something with the result of the function, for instance printing it
06:58:04 <geekosaur> eacameron, I think you can only get O(1) if you precompute the hash, otherwise you have O(key length) to compute the hash for the key and then O(1) to look it up?
07:00:06 <eacameron> geekosaur: That makes sense; that makes me wonder if O(log n) of HashMap is actually comparable to O(key length) for a certain range of n.
07:00:14 <cococo> What does it mean when a string has "Just" before it?
07:01:07 <geekosaur> it's a Maybe String, not a String
07:01:24 <halvorg> It means the type is Maye String, i.e. either a (Just) String or Nothing.
07:05:18 <cococo> Is there something like "isInfixOf" but for checking multiple substrings at once?
07:09:07 <Rembane> cococo: map (\x -> isInfixOf x "asdfasdfasdfasdf") ...
07:09:18 <Rembane> cococo: Or maybe filter instead of map
07:09:26 <byorgey> cococo: you can do   any (\sub -> (sub `isInfixOf` bigString)) ["some", "sub", "strings"]
07:09:43 <byorgey> if you just want a Bool.  Or use filter as Rembane suggests.
07:09:58 <cococo> Rembane & byorgey: Thanks, but I realised I also need to search case sensative. Is regex my best option?
07:10:11 <cococo> Rembane & byorgey: Whoops, I mean case IN-sensative
07:10:23 <byorgey> cococo: then just lowercase everything
07:10:33 <`Jake`> using toLower
07:10:37 <Deewiant> (Which doesn't work for all languages.)
07:11:01 <byorgey> if you care about proper support for all languages, then you should use Text instead of Strings
07:11:44 <`Jake`> Deewiant: do you mean there are natural languages which have upper and lowercase, but for which unicode doesn't recognize the characters as upper and lowercase?
07:12:18 <Deewiant> `Jake`: I mean that you might have two characters that are case-insensitively equal but don't have the same toLower result.
07:13:06 <`Jake`> Deewiant: Are both changed by toLower?
07:13:16 <Deewiant> `Jake`: Not necessarily, I guess.
07:13:27 <`Jake`> ok, thanks
07:13:32 <Deewiant> Re. the multi-string matching if you want to get fancy there are evidently some aho-corasick libraries on hackage, wasn't expecting that.
07:20:27 <remdezx> Please take look at that code snippet: http://lpaste.net/104467. "a" compiles fine, how can I make "b" compile too?
07:22:43 <cococo> How can I make my regex case insensative with Text.Regex.Posix? I can't figure out how to add flags like in other languages
07:27:33 <remdezx> Hello all! :) I've got a big problem right now and I would love to ask you for help. I'm trying to write a rankNTypes code, but I'm stuck and cannot progress - would you be so nice and look into the example?: http://lpaste.net/104467 . The "a" function compiles well, but it needs the "callback" to be passed before creating the list. I want to convert it to something like "b" function. Is it possible? :)
07:30:55 <cococo> How can I add flags to my haskell regex?
07:31:33 <Rembane> cococo: Why do you want to use regexes instead of Data.Text?
07:32:05 <cococo> Rembane: I don't know the advantages of each. I'm very new (today marks the third day) in Haskell so I was just going with what I'm normally comfortable with.
07:32:16 <cococo> *to Haskell
07:32:47 <jle`> regexes are actually pretty uncommonly used in haskell
07:33:04 <cococo> What's the Data.Text implimentation?
07:33:33 <bergmark> cococo: check the source
07:33:39 <bergmark> it's something like Array !Int !Int
07:33:41 <Rembane> cococo: Ah. Regexes are generally not the easiest way to do things in Haskell.
07:33:52 <jle`> Rembane: well, you can't do what you want to do without impredicative types
07:34:17 <jle`> er sorry, remdezx
07:35:01 <cococo> How would I check if a String contains any of a list of sub-Strings, case insensative?
07:35:05 <Rembane> jle`: No worries
07:35:06 <cococo> (with Data.Text)
07:35:17 <jle`> regexes are a bad idea in most languages as well...it's just that only haskell offers better solutions :)
07:37:01 <rwbarton> "any (\s -> s `T.isInfixOf` str) substrs" will handle the "check if a String contains any of a list of sub-Strings" part
07:37:14 <dwcook> cococo: Data.Text.isPrefixOf, Data.Text.toLower on all text involved, and Prelude.any
07:37:35 <Rembane> cococo: http://lpaste.net/104468
07:37:56 <Rembane> jle`: But they are much fun!
07:38:12 <cococo> Thanks dwcook & Ralith. Ralith: Will look at after I shower!
07:38:22 <cococo> Also jle`: Regex is better than people give it credit for ;)
07:38:31 <cococo> I blame the ol' "now you've got two problems" joke
07:38:37 <cococo> going afk
07:38:49 <dwcook> cococo: sorry, I was thinking isInfixOf but wrote isPrefixOf
07:39:37 <Rryy> Hello, can I have two versions of base installed via cabal?
07:40:13 <bennofs> Rryy: no
07:40:26 <bennofs> Rryy: the version of base is bound to the version of GHC that you're using
07:40:37 <Rryy> Oohh
07:40:40 <Rryy> thanks!
07:40:44 <dwcook> You can have multiple GHCs installed
07:41:20 <Rryy> ummm, that seems like an interesting option, I'll research on it.
07:42:03 <dwcook> Well suppose you want to use the latest GHC's features but not all the libraries you use have caught up yet. That's a fine use case right there
07:43:06 <dwcook> Anyway one way to do it is to install from binaries and supply the --prefix flag to the configure script. It'll be detailed in the INSTALL file inside the archive.
07:43:32 <dwcook> And here's where you download those http://www.haskell.org/ghc/download
07:45:40 <Rryy> wow!  thanks for the pointers!
07:49:08 <sm> cococo: agreed. I use regular expressions heavily, they are a highly compact DSL for parsing so why wouldn't I ?
07:49:34 <benzrf> sm: dont parse with REs
07:49:40 <sm> blah blah blah
07:49:46 <benzrf> every time you parse with REs a programmer cries
07:49:52 <sm> I can't hear you
07:49:52 <benzrf> REs are the devil
07:50:06 <tdammers> the reason why regexes are so popular is twofold:
07:50:11 <benzrf> REs are only suitable for quick scripts
07:50:18 <tdammers> one, building an actual parser is really really messy and cumbersome in most languages
07:50:24 <coppro> ^
07:50:24 <benzrf> and simple searching
07:50:31 <tdammers> and two, regular expressions are available, ubiquitous, and pragmatic
07:50:33 <benzrf> they are ABSOLUTELY NOT suitable for parsing
07:50:33 <coppro> haskell lends itself well to expressing parsers
07:50:34 <sm> cococo: if you want to use the familiar regex syntax, the regexpr library is best. Just know that it doesn't scale too well
07:51:05 <tdammers> regexes, as the name implies, can express regular parsers
07:51:12 <tdammers> but most grammars aren't regular
07:51:25 <tdammers> they're also limited to one input type - character data
07:51:35 <tdammers> and, needless to say, they are completely typeless beyond that
07:51:59 <dwcook> I think the biggest deal breakers with regexes as realized in most languages is that they aren't composable.
07:52:06 <dwcook> s/breakers/breaker/
07:52:16 <benzrf> dwcook++
07:52:52 * sm composes regexps
07:52:58 <benzrf> using regexes for parsing is like using MS Paint for image editing
07:53:27 * sm runs into the same problems with parsec parsers as with regexps
07:53:41 <merijn> tdammers: Also, most regex libraries use PCRE which are not regular expressions, they are stronger and can thus parse non-regular languages too
07:53:42 <bennofs> benzrf: There is regex-applicative
07:54:00 <dwcook> sm: how so? Parsec parsers are composable, you just use (>>=) and kindred.
07:54:18 <bennofs> dwcook: there is regex-applicative too
07:54:18 <dwcook> sm: To compose, say, JavaScript regexes, you'd need to do some string voodoo.
07:54:22 <tdammers> merijn: yes, I am aware of that - but the regular heritage is still at their core, and the non-regular stuff tends to be so obscure that you might as well write a real parser anyway
07:54:30 <tdammers> oh, and then there's the performance concern
07:55:12 <tdammers> in an interpreted language, a hand-rolled parser may easily be much slower than a single call into the regex library
07:55:12 <sm> parsec parsers are *more* easily than regexps, sure.
07:55:20 <sm> s/easily/composable/
07:55:43 <tdammers> not because regexes are so fast, but because the interpreted language is so slow and sucks at recursion and backtracking
07:56:11 <dwcook> Perhaps what I should have said, then, is that other regexes tend to be burdensome to compose. Either way, I know what I would prefer.
07:59:20 <robstewartuk> I'm looking for a nice monad or applicative combinator of type '(a -> a -> m a) -> m a -> m a -> m a', that binds the second and third argument and applies them to the first argument.
07:59:36 <robstewartuk> Is there a common notation for this?
07:59:37 <cococo> Rembane: Just read over your code, and it makes sense to me. Thanks!
08:00:14 <latro`a> @type liftM2
08:00:15 <lambdabot> Monad m => (a1 -> a2 -> r) -> m a1 -> m a2 -> m r
08:00:27 <latro`a> eh, not exactly right, hm
08:00:33 <dwcook> That's not quite the right type. It's less powerful
08:00:38 <latro`a> indeed
08:00:58 <bennofs> robstewartuk: you can write it as join $ f <$> a <*> b
08:01:09 * sm sometimes prefers a chainsaw, but doesn't insist a penknife has no value
08:01:11 <benzrf> int-e: hey u control lamdbabot right?
08:01:14 <bennofs> @ty \f a b -> join $ liftA2 f a b
08:01:15 <lambdabot> (Applicative m, Monad m) => (a1 -> b -> m a) -> m a1 -> m b -> m a
08:01:20 <bennofs> @ty \f a b -> join $ liftM#2 f a b
08:01:21 <lambdabot>     Not in scope: ‘liftM#’
08:01:21 <lambdabot>     Perhaps you meant one of these:
08:01:21 <lambdabot>       ‘liftM’ (imported from Control.Monad.Writer),
08:01:22 <bennofs> @ty \f a b -> join $ liftM2 f a b
08:01:23 * robstewartuk tries bennofs suggestion
08:01:23 <lambdabot> Monad m => (a1 -> a2 -> m a) -> m a1 -> m a2 -> m a
08:02:01 <dwcook> sm: This isn't chainsaw versus penknife, this is chainsaw versus rusty chainsaw
08:02:30 <dwcook> sm: Anyway, I'd prefer not to argue in metaphors.
08:02:45 <cococo> Does it make sense to add "where p = Data.Text.pack" and just use p everywhere?
08:03:00 <cococo> * add it to the end of my function
08:03:12 <armlesshobo> cococo: it makes sense to import it qualified
08:03:13 <Qfwfq> See GHC's OverloadedStrings extension, but why not.
08:03:39 <armlesshobo> import qualified Data.Text as T (pack)
08:03:47 <armlesshobo> cococo: and then refer it as T.pack
08:03:51 <Qfwfq> (That only works for literals, though.)
08:04:07 <Deewiant> cococo: Note that you can also use the any/isInfixOf/toLower solution without Text, but Text is generally recommended anyway
08:04:56 <cococo> Deewiant: so "T.pack" is totally redundant in this code? http://lpaste.net/104468
08:05:12 <danilo2> jle`: I was sure the remdezx's example should work without -XImpredictiveTypes flag - as an existential type - am I wrong? Anyway I'm sitting next to him and I was trying to solve it, but also without luck. the flag did not help
08:05:25 <nadirs> armlesshobo: what's the difference between `import qualified Data.Text as T (pack)` and `import qualified Data.Text as T`?
08:05:39 <armlesshobo> cococo: it's only redundant if there is no other module that has a definition of 'pack'
08:05:41 <haasn> cococo: OverloadedStrings could certainly help here
08:06:03 <armlesshobo> cococo: since in this case you are only importing Data.Text, importing it qualified isn't necessary
08:06:20 <remdezx> jle`: Thank you, that you took a look at it. It doesn't work with ImpredictiveTypes too. I pasted an error below http://lpaste.net/104467
08:06:25 <armlesshobo> nadirs: the first only imports that one function 'pack'
08:06:25 <haasn> nadirs: you might have another module imported as T
08:06:45 <Qfwfq> cococo: https://www.fpcomplete.com/school/to-infinity-and-beyond/pick-of-the-week/guide-to-ghc-extensions/basic-syntax-extensions#overloadedstrings
08:06:50 <haasn> But yes, I think it's a bit unnecessary to add selective imports when already qualifying
08:06:51 <nadirs> haasn: a-ha! I didn't know that :)
08:06:54 <cococo> haasn: I want to avoid syntax extensions before understanding the basics
08:07:21 <haasn> cococo: If you understand T.pack "abc" then you understand OverloadedStrings, because it's the same as having written (T.pack "abc") instead of "abc" for every string literal
08:07:40 <nadirs> (I mean, that you can import qualified different modules by the same alias)
08:07:41 <Deewiant> cococo: It might improve speed and memory usage to use Texts instead of Strings, but that's the only real difference there.
08:07:41 <Qfwfq> The OverloadedStrings extentions just desugars any occurence of "foo" with (fromString "foo"), where fromString is provided by the IsString typeclass.
08:07:47 <cococo> Unless I'm misunderstanding what overloadextensions is, it seems like learning jQuery before regular ol' JavaScript. Might be 100x easier, but it seems wrong.
08:07:54 <haasn> cococo: The only difference to your code would be that the list at the right would be [T.pack "adsf", T.pack "Asdf", T.pack "grawr"] instead of explicitly mapping
08:08:01 <Deewiant> cococo: Of course in that one-liner performance isn't likely a concern. :-P
08:08:05 <bennofs> haasn: it can give worse inference
08:08:32 <haasn> Yes, that is a valid concern; but not really applicable here. I meant in this scenario. In general, OverloadedStrings transforms "foobar" to (fromString "foobar")
08:08:56 <Qfwfq> Probably 'instance IsString Text where { fromString = pack }'.
08:08:57 <haasn> cococo: jQuery is a gigantic library with many pecularities and a different paradigm/programming style
08:09:07 <haasn> cococo: OverloadedStrings just places “fromString” in front of every string literal
08:09:31 <cococo> haasn: Why would you want that?
08:09:36 <xeno_> haasn: jQuery is also a horrible mess - but somehow it turns out well enough (given the circumstances) anyway :)
08:09:40 <haasn> cococo: to avoid having to write T.pack everywhere
08:09:55 <cococo> haasn: would there ever be a case when you wouldn't want that?
08:10:02 <cococo> as in it would break your code?
08:10:15 <Qfwfq> I don't think so. The String instance is id.
08:10:20 <Iceland_jack> cococo: It makes inference and the types trickier
08:10:30 <haasn> Yes, there are type inference issues if the typechecker can't figure out which string-like type you need
08:10:42 <haasn> For example, this works:
08:10:46 <haasn> > show "hello"
08:10:48 <Qfwfq> But if you're annotating your functions with signatures, is there ever an ambiguous case?
08:10:48 <lambdabot>  "\"hello\""
08:10:49 <haasn> but this does not:
08:10:49 <Iceland_jack> but it's an accepted and harmless extension
08:10:53 <haasn> > show (fromString "hello")
08:10:55 <lambdabot>  Not in scope: ‘fromString’
08:10:55 <lambdabot>  Perhaps you meant one of these:
08:10:55 <lambdabot>    ‘BSLC.fromStrict’ (imported from Data.ByteString.Lazy.Char8),
08:10:55 <lambdabot>    ‘showString’ (imported from Prelude),
08:10:55 <lambdabot>    ‘formatString’ (imported from Text.Printf)
08:11:04 <Qfwfq> Oh, I see.
08:11:11 <haasn> @let import Data.String (fromString)
08:11:14 <lambdabot>  Defined.
08:11:15 <haasn> > show (fromString "hello")
08:11:16 <lambdabot>  No instance for (GHC.Show.Show a0)
08:11:17 <lambdabot>    arising from a use of ‘GHC.Show.show’
08:11:17 <lambdabot>  The type variable ‘a0’ is ambiguous
08:11:17 <lambdabot>  Note: there are several potential instances:
08:11:17 <lambdabot>    instance [safe] GHC.Show.Show
08:11:43 <Qfwfq> > show (fromString "hello" :: BSL.ByteString)
08:11:44 <lambdabot>  "\"hello\""
08:11:45 <haasn> Ambiguous type, because it could be Text, String or something else
08:11:45 <Iceland_jack> You can also make numbers an instance of IsString
08:11:52 <Iceland_jack> "52" + (34 :: Int)
08:12:20 <Iceland_jack> where an improperly parsed number becomes (-1) ;)
08:12:48 <Qfwfq> Iceland_jack: That's neat.
08:12:58 <Iceland_jack> (no it isn't, it's a horrible idea!)
08:13:14 <Qfwfq> I should clarify: it's a neat hack.
08:13:18 <Iceland_jack> yes indeed
08:13:33 <merijn> Qfwfq: If you wanna see more neat but horrible hacks...
08:13:36 <rwbarton> haven't you ever used PHP?? improperly parsed numbers become 0
08:13:37 <merijn> @hackage acme-php
08:13:38 <lambdabot> http://hackage.haskell.org/package/acme-php
08:13:42 <cococo> Pattern syntax in expression context: x -> T.isInfixOf (T.toLower x) stuff
08:13:45 <cococo> ^ ?
08:14:00 <merijn> Actually, the entire package hierarchy in Acme is hilarious :p
08:14:10 <coppro> ^
08:14:10 <davnils> cococo: you need \x -> ...
08:14:13 <Iceland_jack> Idris may get structured string literals
08:14:17 <Iceland_jack> https://github.com/idris-lang/Idris-dev/wiki/Egg-%233%3A-Structured-String-Literals
08:14:28 <coppro> http://hackage.haskell.org/package/acme-realworld
08:15:07 <cococo> davnils: what does the slash mean/do?
08:15:16 <Iceland_jack> cococo: lambda/anonymous function
08:15:22 <cococo> Iceland_jack: ty
08:15:22 <Iceland_jack> > (\x -> x) 'a'
08:15:24 <lambdabot>  'a'
08:15:29 <Iceland_jack> > (\x -> x + x) 10
08:15:31 <lambdabot>  20
08:15:52 <cococo> > (\y -> y + y) 10
08:15:53 <lambdabot>  can't find file: L.hs
08:15:55 <Qfwfq> merijn: It's.. so.. beautiful.
08:16:03 <Iceland_jack> cococo: you need to prepend '> '
08:16:06 <Iceland_jack> > 5
08:16:08 <lambdabot>  5
08:16:38 <cococo> I am
08:16:40 <cococo> > (\y -> y + y) 10
08:16:42 <lambdabot>  20
08:16:44 <cococo> oh
08:16:47 <cococo> maybe I didn't
08:16:49 <cococo>  :p
08:16:57 <Iceland_jack> maybe :)
08:17:10 <Iceland_jack> You can get pretty much the same thing using 'let'
08:17:14 <Iceland_jack> > let y = 10 in y + y
08:17:16 <lambdabot>  20
08:17:39 <sipa> > let f x = x + x in f 10
08:17:41 <lambdabot>  20
08:18:04 <Iceland_jack> > let f = \x -> x + x in f 10
08:18:05 <lambdabot>  20
08:18:16 <dwcook> Lambdas tend to be more useful when passed to other functions. e.g., map (\x -> x *2 + 1) (though this is functionally the same as map ((+1) . (*2)))
08:20:21 <nadirs> <lambdabot>  can't find file: L.hs ← Why did lambdabot output that?
08:20:26 <dwcook> Though of course many functions don't have a readable pointless rendering, in which case, or in many cases, lambda away
08:20:33 <dwcook> s/pointless/pointfree/
08:20:59 <dwcook> nadirs: It wanted attention.
08:21:04 <nadirs> haha
08:21:05 <armlesshobo> nadirs: what was it that you sent it?
08:21:19 <dwcook> It was a response to cococo's input above
08:22:03 <nadirs> armlesshobo: if you look closely, given the exact same input lambdabot returned two different responses :P
08:22:30 <armlesshobo> haha
08:22:32 <armlesshobo> that's funny
08:24:59 <cococo> http://lpaste.net/104468 <- In this code only t1 get's changed to lower case, correct?
08:26:26 <quchen> In this code, there's a "\" missing.
08:26:36 <cococo> quchen: besides that :p
08:26:46 <quchen> And nothing is changed to lower case.
08:26:58 <cococo> quchen: T.tolower x
08:27:01 <cococo> quchen: someone else wrote it for me
08:27:11 <quchen> Sure, but that's part of the filtering predicate, it doesn't change the list's contents.
08:27:56 <cococo> nvm got it working, to lower case everything I had to also
08:28:02 <cococo> "toLower" line 3
08:28:21 <quchen> toLower won't change line 3, since everything in there is already lower case.
08:28:44 <cococo> quchen: in my code t1 is passed through as an argument
08:28:53 <quchen> You can save the "map T.pack" using the OverloadedStrings extension, by the way.
08:28:55 <cococo> but yeah, in that case you're right
08:29:33 <quchen> Like so: http://lpaste.net/104471
08:31:09 <Rembane> cococo: No worries. Good luck! :D
08:32:31 <Qfwfq> http://lpaste.net/104471 should work, too.
08:33:18 <cococo> Qfwfq: I didn't know you could import like that, that's very helpful. Thanks
08:33:42 <Qfwfq> Wait, 'update' overwrites existing pastes, with no authentication? That's.. probably bad design.
08:33:45 <Qfwfq> Sorry quchen.
08:34:30 <kazagistar> hah, the haskell pastebin is mutable
08:35:04 <savanni> It lives in IO ().
08:36:08 <quchen> All my lpastes are released under the WTFPL, so don't worry Qfwfq.
08:36:09 <exicer_> ocharles: Hi - I've been trying to use your CORS snap module. If I wanted to handle non-simple requests, would I have to explicitly add OPTIONS to the allowed methods ?
08:37:09 <ocharles> exicer_: hi! no, you shouldn't need to - that is about the Access-Control-Allow-Method header
08:37:27 <kazagistar> so, basically, now we just have to write a bot that listens for pastes and instantly updates them to some ascii art before anyone has a chance to click it <_<
08:37:40 <ocharles> exicer_: one gotcha is that you shouldn't do "method POST (applyCORS whatever)" - because then the OPTIONS request won't get through at all
08:37:45 <exicer_> ocharles: I must be doing something wrong then :(
08:37:50 <hexagoxel> you can review all revisions on lpaste
08:37:53 <ocharles> instead, do: applyCORS (method POST whatever)
08:38:09 <ocharles> exicer_: any code you can share?
08:38:18 <Qfwfq> (THCAN)INSWAN
08:38:19 <int-e> benzrf: yes
08:38:20 <exicer_> ocharles: One sec.
08:38:40 <Qfwfq> *(THC)ANSWAN
08:38:42 <benzrf> int-e: can you add something for looking up type syns
08:38:46 <benzrf> it helps in lens
08:38:59 <benzrf> i keep forgetting what Getting is and then i have to ssh and open ghci (im on a ARM device)
08:39:30 <Qfwfq> benzrf: https://github.com/mokus0/lambdabot I think.
08:39:34 <kazagistar> hmm... perhaps it should just add Zalgo the code, progressively more as you go
08:39:45 <exicer_> ocharles: http://lpaste.net/104474
08:40:29 <exicer_> ocharles: When the browser tries to do OPTIONS on the url, it gets the response 404 not found
08:40:38 <exicer_> ocharles: It works fine if I just use GET though.
08:42:07 <napping> Is there any way to turn off warnings in ghc-mod/haskell-mode flymake? Running the ghc-mod binary like ghc-mod check -g -fno-warn-unused-do-bind File.hs doesn't suppress the warning
08:43:37 <int-e> benzrf: hmm. I guess I could make @info/:i invoke :i(nfo) in ghci the same way that @type/:t and @kind/:k do for :t(ype) and :k(ind)
08:43:58 <benzrf> int-e: :_)
08:44:01 <int-e> (though I have to test what happens with type classes then)
08:44:04 <benzrf> nothing would make me happier
08:45:59 <int-e> benzrf: I made a note of it so I won't forget. I won't get around to it before the next weekend, or possibly even the one afterwards
08:46:11 <benzrf> int-e: =[
08:49:00 <ocharles> exicer_: how odd!
08:49:12 <exicer_> ocharles: Indeed :p
08:49:21 <ocharles> exicer_: and if you remove the method POST bit?
08:49:37 <Qfwfq> benzrf: This seems to be the relevant part of the source, if you want to throw together a patch? https://github.com/mokus0/lambdabot/blob/master/lambdabot-haskell-plugins/src/Lambdabot/Plugin/Haskell/Type.hs #FreeSoftware
08:50:42 <mmachenry> Last night I learned at a Haskell meet up that you can define a type "data Void" with no constructors. No values (other than bottom) can inhabit this type. Support for this was moved from a language extension into the main language. What is this useful for?
08:51:04 <katla> it's to define Void..
08:51:31 <mmachenry> katla: Thanks for the tautological answer. :)
08:52:07 <exicer_> ocharles:  One sec.
08:52:14 <napping> Void is a type for things that can't exist
08:52:23 <rwbarton> partly it's just the sort of thing that should be allowed for completeness
08:52:31 <napping> (at least if you pretend things are total)
08:52:38 <ocharles> mmachenry: One interpretation if that anything you can construct can be seen as some sort of truth, where the type is a logical statement
08:52:42 <dwcook> mmachenry: it's basically a type-level 0. It's useful for handing to type constructors, among other things.
08:52:50 <ocharles> mmachenry: in this idea, Void corresponds to False
08:53:06 <dwcook> mmachenry: for example, you know that IO Void cannot have a useful result so the right side of (>>=) will do nothing.
08:53:12 <c_wraith> mmachenry: it's useful for phantom type tags, among other things
08:53:13 <dwcook> (up to bottom)
08:53:26 <exicer_> ocharles: It seems to work fine, if I remove the method POST part.
08:53:30 <mmachenry> dwcook: Isn't that realy what Unit is for?
08:53:38 <dwcook> mmachenry: sorry, will do nothing _with the value_
08:53:42 <napping> no, things with unit can return
08:53:46 <ocharles> exicer_: ok that seems a bit weird. could you leave me a bug report on github?
08:53:52 <mmachenry> dwcook: Could you actually write code that produced IO Void and really ran?
08:53:54 <napping> you could say forever f = f >> forever f has type m a -> m Void
08:53:55 <Qfwfq> () inhabits ().
08:54:13 <exicer_> ocharles: Sure.
08:54:13 <dwcook> mmachenry: no, to continue the analogy, () is 1 where Void is 0. IO () can easily pass a () on.
08:54:17 <mmachenry> Wouldn't any result of your computation complain that whatever value you put into that IO were not of type Void?
08:54:17 <napping> and you might make an operation like tailCall :: IO Void -> IO a that prunes the whole stack or something
08:54:37 <napping> exactly - so only things like forever that never actually return can have that type
08:54:42 <napping> [Void] can only be the empty list, etc
08:55:01 <napping> Maybe more useful if you have something like Term a for terms with free variables of type a -- then Term Void is a type for closed terms
08:55:33 <mmachenry> napping: Ah, yes, forever could have that type.
08:55:41 <mmachenry> :t forever
08:55:42 <lambdabot> Monad m => m a -> m b
08:56:02 <dwcook> b ~ Void
08:56:15 <ntoastie> yes
08:56:17 <napping> it's better to declare it like that so you can use it in a position expecting any kind of result
08:56:52 <napping> but if you want to have some kind of function that only takes things that never return, you might ask for an argument of type IO Void
08:56:56 <rwbarton> right, though you can also define a Monad m => m Void -> m b
08:57:13 <rwbarton> since a monad is a functor and you can define Void -> b
08:57:19 <napping> oh, and I think it's generally safe to implement Functor f => f Void -> f a by unsafeCoerce
08:57:32 <dwcook> In fact the void package has those
08:57:35 <dwcook> @type absurd
08:57:36 <lambdabot> Not in scope: ‘absurd’
08:57:47 <c_wraith> absurd is Void -> a
08:57:51 <c_wraith> Not the same thing
08:58:11 <dwcook> c_wraith: I was referring to "you can define Void -> b"
08:58:22 <c_wraith> oh, whoops
08:58:23 <c_wraith> sorry.
08:58:24 <dwcook> http://hackage.haskell.org/package/void-0.6.1/docs/Data-Void.html
08:58:25 <napping> vacuous is Functor f => f Void -> f a
08:58:36 <katla> @let data Void
08:58:39 <lambdabot>  Defined.
08:58:49 <katla> :t \(v :: Void) -> case v of {}
08:58:50 <lambdabot>     Empty list of alternatives in case expression
08:58:50 <lambdabot>       Use EmptyCase to allow this
08:58:52 <dwcook> Note that the only reason vacuousM there exists is because the Applicative-Monad proposal hasn't yet come into effect
08:58:58 <napping> oh, Data.Void.Unsafe defines unsafeVacuous and warns about GADTs
08:59:40 <c_wraith> yeah, GADTs ruin so many potential functors.  Also, allow hilarious new functors like Coyoneda
08:59:47 <napping> I suppose if you have a constructor that only constructs F Void there will be trouble
09:00:05 <napping> what functors are ruined?
09:00:31 <c_wraith> data F a where X :: a -> F a ; Y -> F ()
09:00:34 <c_wraith> can't be a functor!
09:00:46 <dwcook> Can't GADTs in general not be Functor?
09:00:51 <c_wraith> correct
09:01:13 <haasn> What a weird definition of Data.Void.absurd
09:01:22 <rwbarton> some can, of course, those that aren't GADT-y in the last argument
09:01:29 <haasn> dwcook: It really depends on the GADT in question
09:01:39 <dwcook> Is it also the case that only types that have regular ADT formulations can be Functor?
09:01:46 <dwcook> (But not all of those)
09:02:00 <c_wraith> dwcook: if you consider existentials in the regular ADT formation, then...  I think so
09:02:11 <c_wraith> dwcook: but you have to allow existentials for things like Coyoneda
09:02:17 <haasn> Also things with weird constraints on them
09:02:23 <haasn> ie. data type contexts
09:02:26 <haasn> Not that those are awfully relevant
09:02:30 <napping> c_wraith: that's an example of some GADT type that's not a functor
09:03:11 <napping> If you say allowing GADTs ruins functors, I'd expect something parameterized over a type constructor that fails to be a functor only because you can instantiate the type argument to a GADT in a strange way
09:03:16 <haasn> I don't think existentials affect Functor
09:03:24 <napping> I suppose it's fmap id = id failing that's the problem?
09:03:43 <c_wraith> napping: it's a potential functor.  It has a type with the proper kind, and all values of that type appear in covariant position - but it can't be a functor anyway.  It's a ruined *potential* functor
09:03:43 <haasn> Oh, yes, they do
09:03:49 <c_wraith> napping: correct
09:04:16 <haasn> data Foo a = (() ~ a) => Foo a
09:04:18 <napping> okay, but only things that are actually GADTs fail to be functors
09:04:27 <haasn> Or replace (() ~ a) for (Weird a) in general
09:04:58 <napping> Hmm, can roles allow unsafeVacuous?
09:05:08 <dwcook> Oh yeah, I've been wondering how DeriveFunctor handles types like this one: data Foo a b = Foo (a -> b). I tried reading over the formula but didn't understand it.
09:06:07 <napping> yeah, GADT parameters become Nominal
09:06:27 <c_wraith> I really need to make an effort to understand roles.
09:06:37 <c_wraith> They're important, and I don't understand them yet.
09:06:37 <haasn> napping: I don't think that helps
09:06:38 <fizruk> dwcook: what’s unclear about that one?
09:06:57 <dwcook> fizruk: I know what the definition is, I just don't know how it arrives at it.
09:07:15 <haasn> c_wraith: The fundamental purpose of roles is to resolve Coercible a b constraints
09:07:25 <haasn> In a way that makes coerce :: Coercible a b => a -> b -- safe
09:07:37 <c_wraith> haasn: I know what they're for.  I need to understand the exact meaning of each role
09:08:06 <c_wraith> That is, I have the high-level view.  But not the low-level.
09:08:29 <napping> haasn: I think if your Functor f takes a representational (or phantom) argument, then implementing vacous by unsafeCoerce is safe
09:09:00 <napping> hmm, can you even have a lawful functor if the type parameter is inspected nominally?
09:09:06 <haasn> c_wraith: There are only three; Nominal, Representational and Phantom - Nominal is like (a ~ b), they have to be fundamentally the same type in the type system; Representational is for newtypes that can freely be coerced (but separate in the type system) and Phantom is for things like Tagged which can be coerced to absolutely anything
09:09:09 <fizruk> dwcook: it just uses a simple rule for (->)
09:09:29 <dwcook> fizruk: what rule is that?
09:09:48 <dwcook> Also, there was a 001C character at the beginning that my program couldn't figure out.
09:09:53 <fizruk> dwcook: t1 -> t2  ==>  fmap_<a, x -> y> f = \u -> fmap_<a, y> f . u . cofmap_<a, x> f
09:09:55 <dwcook> beginning of your message*
09:09:58 <napping> c_wraith: to put it another way, a Nominal parameter is compared for exact type equality by a ~ constraint or being used as a GADT-like parameter, Representational are used as normal values, and Phantom doesn't occur at all
09:10:07 <haasn> c_wraith: Of these, Phantom is the most literal - if you don't use a type parameter *at all* a parameter can be nominal
09:10:09 <haasn> liberal*
09:10:43 <haasn> c_wraith: If you use the parameter but only as a polymorphic value, you're using it representationally - and it can be coerced to a newtype safely
09:10:51 <dwcook> fizruk: what does that rule apply to though? I guess it would have to inspect the contents of the constructor to see it's a function?
09:11:00 <haasn> c_wraith: If you use a parameter as part of a GADT or constraint or something else which involves the type system like that, it has to be nominal
09:11:07 <fizruk> dwcook: Colloquy is strange IRC client, i just can’t handle it
09:11:09 <napping> oh, I guess it's not a higher-order system yet so you can't say Functor only applies to constructors that use their argument Representationally
09:11:29 <haasn> Sorry, I meant “a parameter can be phantom” in my first line
09:11:31 <fizruk> dwcook: sure, DeriveFunctor looks inside data definitions
09:11:32 <c_wraith> haasn: ah.  so nominal meaning "they must have the same name" and representational meaning "they must have the same representation"
09:11:37 <haasn> c_wraith: precisely
09:11:57 <fizruk> dwcook: just like deriving (Eq) would
09:12:09 <haasn> c_wraith: Since you're interested in the low level, there's another interesting detail/limitation:
09:12:45 <haasn> If you use a type parameter as argument to *another* type parameter, the former must be nominal; since the type you apply to it could be using it nominally (and we're polymorphic)
09:12:56 <haasn> eg. newtype (Apply f a) = Apply (f a)
09:12:59 <napping> haasn: that's what I was thinking about it being higher order
09:13:16 <dwcook> fizruk: so, this is just a guess, but does it basically search for all contents that make use of the last type parameter and pattern match against their types to figure out what to do?
09:13:17 <haasn> type role Apply representational nominal -- I think
09:13:33 <haasn> Yes, that is correct
09:13:50 <napping> if you could say something like type role Functor (representational -> _)
09:14:01 <c_wraith> haasn: and the compiler will reject explicit role annotations that are too liberal, but not ones that are stricter than needed?
09:14:02 <fizruk> dwcook: yes
09:14:15 <haasn> c_wraith: exactly
09:14:17 <jophish> Is there any library out there which uses type level naturals for explicitly sized arrays?
09:14:21 <haasn> This makes it impossible to write unsafeCoerce
09:14:27 <haasn> Even if you try really hard
09:14:39 <c_wraith> jophish: there are a bunch, depending on what your exact need is.
09:15:00 <fizruk> dwcook: in HEAD DeriveFunctor works also for GADTs (i.e. you can derive Functor for existentials and stuff)
09:15:03 <c_wraith> jophish: I have one that uses the type-level naturals solely for Storable instances.  There are others that are more ambitious.
09:15:04 <dwcook> fizruk: why can't it derive Foo a b = Foo (b -> a)? What's the difficulty?
09:15:13 <jophish> c_wraith: ah, I'd only seen ones which implement Peano numbers themselves
09:15:24 <fizruk> dwcook: b is in negative position
09:15:32 <jophish> c_wraith: have you got a link to that, it sounds interesting
09:15:34 <haasn> napping: It doesn't really work that way; roles only concern parameters to a concrete type - and classes parameters are *always* nominal because otherwise you could not write distinct instances for newtypes
09:15:56 <c_wraith> jophish: I think the current state is "working only on GHC 7.6" because I never finished the necessary changes for 7.8.
09:16:01 <haasn> 7.8 pretty much obsoletes type-level pianos :)
09:16:03 <dwcook> fizruk: wait, maybe I didn't think that one through – If I tried implementing it myself, would I find it to be impossible? I'm going to go ahead and try that.
09:16:15 <jophish> haasn: yeah, plenty of libraries are still using them though
09:16:32 <fizruk> dwcook: you can try :)
09:16:42 <c_wraith> haasn: not yet.  You still need unsafeCoerce to write some stuff using type-level nats in 7.8
09:17:09 <c_wraith> haasn: like the standard Vec n a example needs unsafeCoerce to write an Eq instance
09:17:21 <haasn> napping: Going back to void; the problem with coerce :: Coercible (f Void) (f a) :: f Void -> f a -- is that this will fail to resolve for any ‘a’ which is not representationally equal to ‘Void’ if f uses its first parameter representationally
09:17:24 <napping> haasn: I want to further restrict it, so you can only define an instance of the class for a concrete type constructor which uses it's own arguments in a particular way
09:17:25 <c_wraith> haasn: because GHC doesn't derive (m ~ n) from (m + 1) ~ (n + 1)
09:17:28 <haasn> napping: case in point, f :: [Void] -> [a] -- does not work
09:17:52 <haasn> [] is very much representational
09:17:55 <napping> haasn: I'm not talking about using coerce
09:17:58 <haasn> Oh?
09:18:04 <c_wraith> jophish: yeah, I didn't finish the stuff to make it work with GHC 7.8, but the 7.6 version is available at http://hackage.haskell.org/package/storable-static-array
09:18:11 <napping> haasn: but about using roles to describe the conditions under which using unsafeCoerce is actually safe
09:18:12 <haasn> c_wraith: Hmm, I thought it does that in 7.8
09:18:21 <jophish> c_wraith: thanks!
09:18:28 <napping> unsafeCoerce :: [Void] -> [a] is safe because [] uses the type at most representationally
09:18:38 <c_wraith> haasn: sadly, no. It's one of the first things I tried with the GHC 7.8 RCs. :)
09:18:39 <dwcook> fizruk: got it, so that gives rise to a Contravariant but not a Functor.
09:18:45 <napping> you just can't unsafeCoerce :: f Void -> f a if f uses the argument nominally
09:18:45 <fizruk> dwcook: correct
09:19:07 <jophish> c_wraith: is it on the roadmap to be able to derive (m~n) in that example?
09:19:19 <fizruk> dwcook: but still you can derive Functor for data Cont r a = Cont ((a -> r) -> r)
09:19:22 <napping> haasn: and I suspect you can't write a correct Functor instance of anything that uses the argument type nominally, so maybe Functor could already require that
09:19:33 <haasn> napping: I see what you mean; I don't think that's possible currently because there's no way to “leverage the roles system” like that
09:19:55 <haasn> napping: I see an alternative approach, though
09:20:12 <dwcook> fizruk: where could I read more about the implications of positivity versus negativity in the sense you mentioned it?
09:20:16 <c_wraith> jophish: yes, current plans are that GHC will include an SMT solver for working with type-level nats
09:20:16 <napping> in particular, fmap can't tell whether it's being used at type a -> a or a -> b, so any nominal use of a prevents fmap id = id, unless maybe you somehow have an unusable constructor
09:20:24 <haasn> napping: If we make Void# a compiler primitive and have it be representationally equal to any other type, we can safely c-- oh darn, that only works in one direction
09:20:28 <c_wraith> jophish: in 7.10, that is
09:20:34 <jophish> Cool beans
09:20:48 <haasn> My idea would let us write coerce :: [a] -> [Void] too
09:20:52 <napping> haasn: do you mean you could make it work in only one direction?
09:21:12 <napping> If you could make it considered representationally equal only in one direction that would work
09:21:20 <napping> Because that's more or less actually true
09:21:22 <haasn> No, I mean my idea is invalid; I thought we could do this by making Void representationally equal to every other type, allowing us to freely coerce from any other type to it, but sadly that works in the other direction too
09:21:29 <haasn> I mean, from it to any other type
09:21:35 <haasn> Yeah
09:21:37 <napping> and representational equivalence isn't actually symmetric in that way
09:21:43 <haasn> Hmm
09:21:49 <napping> every representation of Void is a valid representation of any other (lifted) typed
09:21:59 <napping> because the only representation is a thunk of bottom
09:22:15 <napping> Hmm
09:22:29 <napping> I wonder if row variable polymorphism could give less trivial instances of that
09:22:48 <napping> maybe you ought to be able to corece from a polymorphic variant into a polymorphic variant with more alternatives?
09:23:16 <c_wraith> haasn, napping: thanks for the quick info on the role system
09:23:18 <dwcook> fizruk: I'm not quite sure what to search – Is the term applied to type variables? Like "type variable in positive position"?
09:23:24 <haasn> c_wraith: It's all self-contained here: http://www.haskell.org/ghc/docs/7.8.1/html/users_guide/roles.html
09:23:29 <haasn> And not that long
09:23:47 <napping> and references a decent paper, if you want a nicer explanation
09:24:31 <c_wraith> I had trouble with the original paper, but I only tried to skim it once.  That's not the way to understand academic papers. :)
09:24:34 <fizruk> dwcook: should be more like “positive/negative argument”
09:24:57 <fizruk> dwcook: there’s also a close notion of covariant/contravariant type
09:25:49 <napping> c_wraith: if you want to understand something thoroughly, I think reading the academic paper (a little bit carefully at least) is usually the quickest way
09:26:12 <napping> well, at least if it's a good paper
09:26:15 <c_wraith> napping: depends.  *some* papers are terrible. :)
09:26:27 <napping> or has SPJ among the authors, at least
09:26:35 <c_wraith> Most papers related to type system stuff from haskell are pretty good, though
09:27:25 <napping> That's kind of the point of an academic paper, really - if you want to thoroughly understand what we've done, here's the best explanation we've come up with
09:27:35 <napping> and if it's well done, it does that job well
09:27:36 <c_wraith> SPJ has this amazing ability to make everything seem obvious.
09:29:31 <dwcook> c_wraith: well it's said that if you really understand something then you should be able to explain it to your grandmother. (However, no comment is made about your grandmother's attention span. :)
09:30:14 <napping> I'm having a bit of trouble figuring out how to write somthing with Par or Async or anything nice like that
09:30:39 <napping> I've basically got a function a -> IO ([a],b)
09:30:45 <c_wraith> napping: well, Par and Async are for entirely different things..  Which do you actually want?
09:31:05 <napping> think a = FilePath, and the function reads/parses one file, returning a list of imports and the parsed body of just this file
09:31:21 <napping> I'd like to parse everything in paralell
09:31:24 <rabipelais> hello people, what is the typeclass that abstracts `zipWith`, i.e. is there a class constraint C so that I can do:
09:32:14 <rabipelais> (C f) => zipWith :: (a -> b -> c) -> f a -> f b -> f c?
09:32:16 <c_wraith> napping: you *probably* want async, but that problem is hard to make concurrent in a useful way anyway.
09:32:23 <napping> hmm?
09:32:24 <bergmark> rabipelais: Zip in chunked-data
09:32:41 <rabipelais> or more generally (C f, C g, C h) => zipWith :: (a -> b -> c) -> f a -> g b -> h c?
09:32:52 <napping> It seems easy enough to make concurrent, but the threads are explicitly communicating through a cache of what files are already (being) parsed
09:32:54 <c_wraith> napping: parallel parsing?  Sounds tough to me!
09:33:10 <c_wraith> oh, you mean doing multiple files concurrently
09:33:10 <napping> Not parsing individual files in parallel, but chasing includes
09:33:12 <bergmark> there's a parallel parser on hackage
09:33:19 <bergmark> now what was it's name
09:33:25 <napping> like if foo.c includes a.h and b.h, we ought to be able to parse a.h and b.h in parallel
09:33:37 <napping> and more than that, the actual things I'm parsing has the includes as the start
09:33:39 <c_wraith> napping: ok, that's a task for async, rather than Par
09:34:22 <bergmark> ah right it's not a general parser, http://hackage.haskell.org/package/hPDB
09:34:30 <rabipelais> bergmark: thanks, I will look into it.
09:35:13 <bergmark> Michal had a presentation about it at the nl fp days a few months ago
09:36:04 <napping> does anyone know how to suppress warning in ghc-mod / haskell-mode?
09:36:52 <rabipelais> bergmark: it doesn't seem to handle the second use-case, when the two (or three) `lists` don't have the same type. Like if I want to zip a List and a Vector and get back a vector
09:38:24 <napping> Does async have anything like a mapConcurrently_?
09:39:10 <dwcook> What would mapConcurrently_ do differently from mapConcurrently?
09:40:37 <napping> just not bother to rebuild a data structure
09:40:43 <napping> while still failing early with the exception if any fail
09:40:55 <dwcook> So, sort of like a combination of map and waitAll (if that existed)?
09:41:06 <napping> yeah - waitAll existing would also do it
09:41:12 <ion> mapConcurrently f = runConcurrently . traverse (Concurrently . f)
09:41:17 <ion> Try that with traverse_
09:41:46 <napping> traverse_?
09:42:01 <c_wraith> I don't exactly understand the type signature for waitAny.  What's the Async it returns?
09:42:12 <napping> the one that made the result, I think
09:42:19 <c_wraith> Oh, I see
09:42:29 <napping> ion: I don't see an _ version of any of the Traversable functions
09:42:32 <c_wraith> Async values have Eq and Ord instances
09:42:59 <napping> oh, from foldable
09:47:44 <nexxx> hi
09:48:02 <jfischoff> hi nexxx
09:49:15 <nexxx> im relatively new to haskell. Is there a OSS porject with well written code, taht is worth to lock at just to  loock into some code?
09:49:49 <napping> ion: I'm actually trying with link - do acks <- mapM_ (async . f) l; mapM_ link f; _do other work_; mapM_ wait acks
09:49:56 <Iceland_jack> nexxx: reading libraries is generally a good place to start
09:50:01 <napping> or I suppose I could put the extra work into a separate Concurrently
09:50:10 <Iceland_jack> what's your current level?
09:50:12 <armlesshobo> nexxx: http://hub.darcs.net/computionist/noth-chat
09:50:19 <nexxx> iceland
09:50:36 <armlesshobo> nexxx: it's a work in progress, but it looks very promising.
09:50:49 <nexxx> Iceland_jack did work through learn you a haskell for great good
09:50:53 <armlesshobo> nexxx: if it's too much, then please feel free to ask for something better.
09:51:06 <Iceland_jack> nexxx: sure
09:51:09 <Iceland_jack> it's a good book
09:51:29 <armlesshobo> Real World Haskell is a good one to check out.
09:52:00 <Iceland_jack> I can hardly get through RWH for some stuff that I know well
09:52:30 <armlesshobo> Iceland_jack: yeah, if you know it, skip it and find stuff you don't know well.
09:52:45 <armlesshobo> i like the book because it has questions/problems to solve to exercise your new learning.
09:52:46 <Iceland_jack> armlesshobo: That's not my point, I'm beyond the level of RWH
09:52:55 <Iceland_jack> I don't like the way it's structured
09:53:03 <armlesshobo> k
09:53:29 <armlesshobo> nexxx: i recommend it
10:04:11 <LT1MH> @where ops
10:04:12 <lambdabot> arjanb bos byorgey Cale conal copumpkin dcoutts dibblego dmhouse dolio dons edwardk elliott geekosaur glguy Heffalump Igloo jmcarthur johnw kosmikus Lemmih monochrom nyc Philippa Pseudonym quicksilver roconnor Saizan shachaf shapr sjanssen ski sorear SyntaxPolice xerox
10:04:24 <LT1MH> There Ops!
10:05:01 <LT1MH> jutaro...u in Lithuania?
10:05:25 <jutaro> ???
10:05:26 <Cale> LT1MH: why did you just ping the ops?
10:05:34 <glguy> Please don't abuse that command
10:07:04 <Emi18>  Hi! I give you some videos. I hope you like! http://j.mp/RdXMfO
10:07:44 <monochrom> who is calling my name in vain?!
10:08:28 <savanni> Is there anyone available familiar with Control.Monad.Free?  I'm trying to understand why a particular bit of syntax works and can't quite work it out.
10:08:45 <ReinH> savanni: go ahead
10:09:21 <savanni> ReinH: I have a constructor of my own, IndexImage, which we should assume just takes the next parameter (data Action next = IndexImage next)...
10:09:36 <savanni> Why does `Free . IndexImage $ Pure` work?
10:09:51 <savanni> Because Pure requires a parameter, Free requires a parameter
10:10:15 <savanni> I'm just trying to figure out how the data types match up.
10:10:25 <LT1MH> lol...NO!
10:10:27 <savanni> (if there's not enough context, I can paste something more)
10:10:42 <Clint> how does control-monad-free differ from free?
10:10:53 <Cale> savanni: Is that F really uppercase?
10:10:57 <int-e> :t Control.Monad.Free.Free
10:10:59 <lambdabot> f (Control.Monad.Free.Free f a) -> Control.Monad.Free.Free f a
10:11:03 <savanni> Cale: yep.
10:11:16 <savanni> :t Control.Monad.Free.Pure
10:11:17 <lambdabot> a -> Control.Monad.Free.Free f a
10:11:17 <Cale> oh, right, there are multiple packages
10:11:26 <Cale> You're using free of course :)
10:11:53 <Cale> So, Free :: f (Free f a) -> Free f a
10:11:56 <ReinH> savanni: this is...
10:11:57 <roconnor> savanni: presumably IndexImage takes a function as its argument.
10:11:58 <ReinH> data Free f a = Pure a | Free (f (Free f a))
10:12:12 <ReinH> So what is Free . IndexImage?
10:12:12 <savanni> ReinH: yes
10:12:17 <Cale> and Pure :: a -> Free f a
10:12:40 <Cale> IndexImage :: t -> Action t
10:13:26 <Cale> So in order for the types to line up, f had better be Action
10:13:38 <Cale> and t had better be Free Action a
10:13:49 <savanni> just a minute...
10:14:08 <int-e> :t return return
10:14:09 <lambdabot> (Monad m1, Monad m) => m (a -> m1 a)
10:14:28 <ReinH> The most obvious thing we can do is:
10:14:32 <ReinH> @unpl Free . IndexImage $ Pure
10:14:32 <lambdabot> ((Free) ((IndexImage) (Pure)))
10:14:47 <ReinH> Remove some unnecessary braces
10:15:03 <ReinH> Free (IndexImage Pure)
10:15:51 <roconnor> @. pl unpl Free . IndexImage $ Pure
10:15:52 <lambdabot> Free (IndexImage Pure)
10:16:04 <ReinH> roconnor: huh
10:16:07 <savanni> Sorry, I tried asking here about a simplified version of my real code and now discovering that I can't make the simplified version compile.
10:16:38 <n-dolio> @pl f . g $ x
10:16:38 <lambdabot> f (g x)
10:17:08 <Cale> Yeah, it might be easier to see how the types work out by first applying IndexImage to Pure, and then worrying about what the type of Free applied to that is.
10:17:12 <roconnor> savanni: oh good.  It wasn't making much sense to me.
10:17:30 <roconnor> n-dolio: nice
10:17:31 <LT1MH> Oh...r we all programmers
10:17:33 <LT1MH> ?
10:18:18 <n-dolio> roconnor: pl has an unhealthy acceptance of parentheses, it seems.
10:18:30 <savanni> K.  I'll backtrack to the more complex thing and play with that before I ask again.  Sorry, I thought tht what I was asking about had the DSL + free monad without the extra parameters for the domain.
10:18:34 <LT1MH> ()()()()()()
10:19:42 <ReinH> n-dolio: I just know that it doesn't like ($) :)
10:20:01 <n-dolio> @pl ($)
10:20:01 <lambdabot> id
10:20:03 <n-dolio> Yeah.
10:20:34 <ReinH> savanni: have you read http://www.haskellforall.com/2012/06/you-could-have-invented-free-monads.html ?
10:20:54 <savanni> No, I haven't.  I suppose I should look at that, though I've spent too much time this week learning and not enough time actually producing code.
10:21:16 <savanni> I did a free monad implementation five months ago, but without Control.Monad.Free
10:22:16 <ReinH> savanni: maybe yours was closer to the operational monad?
10:22:53 <savanni> Maybe.  I've got a fragment of it posted on Stack Overflow... http://stackoverflow.com/questions/23766419/when-would-i-want-to-use-a-free-monad-interpreter-pattern
10:23:08 <savanni> (in that question, I was basically asking why to use the free monad and what justfies all the boilerplate)
10:23:17 <bernalex> if I have years, months, days, hours, minutes & days -- what is a nice way to get type safety without having to implement all operations? basically I want to make sure that a function that takes a Day will reject an Hour, but I still want to do Hour * 24.
10:23:30 <bernalex> i.e. a * 24 where a is an Hour.
10:24:26 <bernalex> essentially I want +-*/ for free, and have type safety in type signatures and when calling functions. implementing +-*/ for each would be silly
10:24:29 <savanni> bernalex: the dimensional library is fantastic for that
10:24:45 <savanni> https://hackage.haskell.org/package/dimensional
10:24:48 <ReinH> another alternative is http://hackage.haskell.org/package/lens-datetime
10:24:51 <bernalex> thanks
10:25:01 <LT1MH_> i like free things!
10:25:23 <savanni> Although I do sometimes find the dimensional library to be tricky to get the darned thing to output in the units I want.
10:26:24 <albeit> Looking for advice to tackle a problem... given a string of key value pairs "A=1 B=2 C=3", I need to extract values for a set of keys. Should I repeatedly parse the string looking for a key, or load the string into a Map?
10:27:10 <albeit> (Speed is the most important thing)
10:27:53 <rwbarton> in that case it isn't close, use a Map (or some even more efficient structure)
10:28:23 <rwbarton> unless I guess you are doing many many fewer queries than the length of your string
10:28:48 <albeit> rwbarton: Okay. Keys are integers, but in string format. Should I convert keys to Ints and use an IntMap, or just stick with the strings as keys in a Map?
10:29:01 <rwbarton> yes use an IntMap
10:30:22 <ReinH> Even if your keys are chars you can still use an intmap :)
10:30:40 <rwbarton> (or if your keys happen to be contiguous integers, even better to use an array of some kind)
10:30:54 <ReinH> Vector is nice for that
10:31:01 <ReinH> such data locality wow
10:31:05 <albeit> Yeah didn't make my sample very accurate... it would be more like "15=foo 269=bar 3=30.25"
10:31:09 <ReinH> very cache
10:31:22 <rwbarton> Array is the same
10:31:24 <albeit> So non-contiguous, and non-char keys
10:31:35 <rwbarton> but if they're non-contiguous, then never mind
10:32:43 <albeit> Great, thanks guys
10:33:20 <j`ey> can I fold with ">" ?
10:33:55 <fizruk> j`ey: sure
10:34:01 <fizruk> :t foldr (>)
10:34:02 <lambdabot> Bool -> [Bool] -> Bool
10:34:18 <bennofs> foldr (>) False [False, False, False]
10:34:20 <bennofs> > foldr (>) False [False, False, False]
10:34:21 <lambdabot>  False
10:34:26 <bennofs> > foldr (>) False [False, False, True, False]
10:34:27 <lambdabot>  False
10:34:39 <fizruk> j`ey: i only guess you expected something different :)
10:34:44 <j`ey> yes :)
10:35:21 <fizruk> :t zipWith (>) <*> tail
10:35:23 <lambdabot> Ord b => [b] -> [Bool]
10:35:36 <fizruk> :t all . (zipWith (>) <*> tail)
10:35:37 <lambdabot>     Couldn't match type ‘a -> Bool’ with ‘[Bool]’
10:35:38 <lambdabot>     Expected type: [b] -> [b] -> a -> Bool
10:35:38 <lambdabot>       Actual type: [b] -> [b] -> [Bool]
10:35:51 <fizruk> :t and . (zipWith (>) <*> tail)
10:35:53 <lambdabot> Ord b => [b] -> Bool
10:36:08 <LT1MH> =>
10:36:32 <bennofs> :t zipWith (>) <*> drop 1 -- doesn't crash on empty list
10:36:33 <lambdabot> Ord b => [b] -> [Bool]
10:36:36 <LT1MH> supposed to go to educreations.com ... friend goes to ed.gov :( dissapointment.
10:36:52 <bennofs> oh hmm, I always forget the laziness of zipWith, sorrx
10:36:54 <j`ey> Im trying to think of a good fold example, other than just + * etc
10:37:12 <fizruk> bennofs: :) tail is bad anyway
10:37:20 <bennofs> > foldr (:) [] [1,2,3,4,5,6,7]
10:37:22 <lambdabot>  [1,2,3,4,5,6,7]
10:37:31 <j`ey> nice
10:38:10 <bennofs> > foldl (flip (:)) [] [1,2,3,4,5,6,7,8]
10:38:11 <fizruk> :t foldr1 max
10:38:12 <lambdabot>  [8,7,6,5,4,3,2,1]
10:38:13 <lambdabot> Ord a => [a] -> a
10:38:25 <bennofs> :t foldr1 (&&)
10:38:26 <lambdabot> [Bool] -> Bool
10:38:40 <savanni> I figured out my free monad question.  The syntax suggested to me is... more arcane than necessary.
10:38:59 <Deewiant> > foldr id 0 [(+3), (*2), subtract 1]
10:39:01 <lambdabot>  1
10:39:08 <savanni> `Free . IndexImage undefined undefined $ Pure` simplifies nicely to `Free (IndexImage undefined undefined Pure)`
10:39:09 <j`ey> o_O
10:40:18 <ReinH> j`ey: the more general version is:
10:40:31 <ReinH> :t foldr (.) id [(+3), (*2)]
10:40:32 <lambdabot> Num b => b -> b
10:40:40 <ReinH> rather than producing a result, this produces a function
10:40:55 <ReinH> foldr (.) id [(+3), (*2), subtract 1] $ 0
10:41:00 <bennofs> :t foldr (>=>) return
10:41:00 <lambdabot> Monad m => [c -> m c] -> c -> m c
10:41:02 <ReinH> > foldr (.) id [(+3), (*2), subtract 1] $ 0
10:41:04 <lambdabot>  1
10:41:06 <LT1MH> bye every1!
10:41:26 <ReinH> That's the endomorphism monoid, bennofs is the endokleisli monoid
10:41:48 * bennofs wishes the endokleisli monoid was in base
10:42:14 <ReinH> bennofs: I suppose the analog to (.) id is actually (<=<) return, but whatever
10:43:29 <Deewiant> ReinH: Isn't  \x xs -> foldr id x xs  semantically equivalent to  \x xs -> foldr (.) id xs x
10:43:48 <ReinH> Deewiant: if you throw a $ in there, yes
10:44:18 <Deewiant> What $?
10:44:23 <ReinH> yours doesn't compiule
10:44:27 <ReinH> foldr doesn't take 4 arguments
10:44:29 <Deewiant> Sure it does?
10:44:40 <ReinH> > foldr (.) id [] 1
10:44:42 <lambdabot>  1
10:44:48 <ReinH> oh duh
10:44:52 <Deewiant> foldr takes one argument like every other curried function
10:44:59 <ReinH> ofc
10:45:25 <ReinH> Deewiant: but the endomorphism version allows you to provide a function rather than immediately applying it to the x
10:45:34 <ReinH> so there's an abstraction there
10:45:53 <ReinH> but it's also reasonable to talk about how many arguments a function needs to be fully saturated
10:46:04 <ReinH> and people do this quite often and no one is confused
10:48:08 <Deewiant> ReinH: Both versions can be used similarly, if you don't want to apply it immediately then just carry around a (\x -> foldr id x xs)
10:48:28 <ReinH> That's true, you can introduce... a lambda abstraction ;)
10:48:45 <ReinH> there are multiple ways of getting the same abstraction, sure.
10:48:56 <ReinH> but yours isn't a monoid
10:49:16 <ReinH> so they're not exactly semantically equivalent
10:50:12 <ReinH> I can't join two together using a monoidal product before applying to an x
10:50:44 <ReinH> unless I introduce a lambda abstraction to yours so it becomes of type a -> a
10:51:04 <monochrom> @type \x xs -> foldr id x xs
10:51:05 <lambdabot> b -> [b -> b] -> b
10:51:13 <monochrom> @type \x xs -> foldr (.) id xs x
10:51:14 <lambdabot> b -> [b -> b] -> b
10:54:50 <ReinH> monochrom: my point is that the fold itself is not monoidal. They can be certainly made equivalent by introducing a lambda abstraction.
10:55:08 <ReinH> @type \xs -> foldr (.) id xs
10:55:09 <lambdabot> [b -> b] -> b -> b
10:56:49 <ReinH> is further eta reducable to foldr (.) id
10:56:57 <ReinH> @type \xs -> \x -> foldr id x xs
10:56:58 <lambdabot> [b -> b] -> b -> b
10:57:06 <ReinH> eta reduces to \x -> foldr id x xs
10:57:13 <ReinH> which requires a lambda abstraction
10:57:27 <ReinH> foldr (.) id is a monoidal fold. That's all I'm saying.
10:57:45 <napping> Is there any documentation for ghc-mod? It seems to be leaving stuck flymake "processes" around
11:01:06 <bernalex> so I can have class Foo a where f :: Maybe a -> a, or whatever. what do I need to do if I want to have a class Bar a where a Int -> ...?
11:01:19 <albeit> \pl (\es ps -> es Seq.|> IMap.fromList ps)
11:01:25 <albeit> @pl (\es ps -> es Seq.|> IMap.fromList ps)
11:01:25 <lambdabot> (. IMap.fromList) . (|>) . ($ Seq.)
11:02:03 <bernalex> hmmm never mind
11:02:16 <albeit> @pl (\es ps -> es |> IMap.fromList ps)
11:02:16 <lambdabot> (. IMap.fromList) . (|>)
11:05:20 * _ren_ Free porn http://x.co/4giIQ <- Sorry the advertising, my intentions are good...
11:06:17 <monochrom> the road to hell is paved with good intentions
11:06:34 <bernalex> right so now I have class Foo a where f :: a Int -> Int, and that's well and nice. what do I need to do to *derive* it? I want to have data/newtype Bar Int deriving Foo.
11:06:54 <bernalex> the error I get is that Foo expects an argument of kind * -> *, so I can't derive it
11:07:29 <savanni> Your newtype would have to be `newtype Bar a = `
11:07:44 <savanni> As in, Bar itself has to require a parameter.  You wouldn't be able to hardcode it in.
11:08:06 <bernalex> oh of course! silly me. thanks.
11:08:33 <savanni> Although, looking at it, no Bar excetp for Bar Int would ever be a subclass of Foo.
11:11:50 <bernalex> savanni: I get "can't make derived instance of "Foo Bar", "Foo" is not a derivable class. =/ I do have {
11:12:05 <c_wraith> There's no Alternative -> Monoid wrapper newtype?
11:12:49 <savanni> bernalex: that's a new one.  Let me throw it into a file and play.
11:12:59 <savanni> (until someone else gives the right anwser)
11:14:53 <savanni> Strange...
11:15:19 <ReinH> c_wraith: yeah, weird huh
11:15:41 <bernalex> savanni: are you getting the same error, or strange because you're not getting an error? :-]
11:15:49 <savanni> bernalex: http://lpaste.net/104477
11:15:54 <savanni> I'm not getting an error
11:16:03 <savanni> I've got a few extensions turned on in my environment, though.
11:16:31 <savanni> TypeSynonymInstances, FlexibleInstances, GeneralizedNewtypeDeriving look like potential candidates
11:18:29 <bernalex> savanni: I annotated with the play code I have
11:18:31 <Deewiant> bernalex: Haskell doesn't allow deriving user-defined classes, you have to do compiler-specific stuff such as http://www.haskell.org/ghc/docs/latest/html/users_guide/generic-programming.html (which actually still doesn't let you do "deriving Foo" as such)
11:18:41 <bernalex> Deewiant: I have it activated, as mentioned
11:19:03 <Deewiant> "it"?
11:19:08 <savanni> *Oh*, you're doing automatic deriving
11:19:19 <bernalex> yes that's what I want
11:19:34 <bernalex> Deewiant: the generics flag. I 'll have a look at your link, thanks
11:19:58 <savanni> "Can't make a derived instance of 'Foo Bar' (even with cunning newtype deriving): cannot eta-reduce the representation type enough"
11:21:07 <savanni> bernalex: got it compiling
11:21:20 <bernalex> savanni: what was missing?
11:21:24 <savanni> not actually working, but compiling
11:21:26 <bernalex> I only have {-# LANGUAGE GeneralizedNewtypeDeriving #-}
11:21:28 <bernalex> oh
11:21:53 <savanni> I removed the first `Int` from `f :: a Int -> Int`.  It now reads `f :: a -> Int`.  However, I can't actually call f.
11:21:56 <savanni> :(
11:24:24 <bernalex> savanni: oh I'm doofus. the annotation should have been with newtype. that's what I'm using here.
11:24:36 <bernalex> and actually, yeah, I get the "cannot eta-reduce enough"
11:24:56 <savanni> More than that.  I just posted a new annotation that shows a working version.
11:25:10 <savanni> Because to do auto-deriving, your "internal" data type has to also have a derivation for your typeclass.
11:25:21 <savanni> So, instance Foo Bar
11:25:32 <savanni> To use a Bar Int, you have to also define `instance Foo Int`
11:26:01 <bernalex> savanni: yes I just saw on stack overflow
11:26:08 <savanni> *HAH*!
11:28:15 <bernalex> savanni: check out my new annotation. still no work!#
11:28:30 <bernalex> can't make a derived even with cunning blah blah.
11:29:21 <tac_> Nomenclature question: Where does the word 'nub' come from?
11:29:22 <tac_> @type nub
11:29:24 <lambdabot> Eq a => [a] -> [a]
11:29:54 <Deewiant> tac_: http://dictionary.reference.com/browse/nub
11:30:12 <bernalex> tac_: /isgd
11:30:21 <bernalex> uuups
11:30:37 <Cale> @wn nub
11:30:38 <lambdabot> *** "nub" wn "WordNet (r) 3.0 (2006)"
11:30:38 <lambdabot> nub
11:30:38 <lambdabot>     n 1: a small lump or protuberance [syn: {nub}, {nubble}]
11:30:38 <lambdabot>     2: a small piece; "a nub of coal"; "a stub of a pencil" [syn:
11:30:39 <lambdabot>        {nub}, {stub}]
11:30:41 <lambdabot> [7 @more lines]
11:30:43 <Cale> @more
11:30:43 <lambdabot>     3: the choicest or most essential or most vital part of some
11:30:45 <lambdabot>        idea or experience; "the gist of the prosecutor's argument";
11:30:47 <lambdabot>        "the heart and soul of the Republican Party"; "the nub of the
11:30:49 <lambdabot>        story" [syn: {kernel}, {substance}, {core}, {center},
11:30:51 <lambdabot>        {centre}, {essence}, {gist}, {heart}, {heart and soul},
11:30:53 <lambdabot>        {inwardness}, {marrow}, {meat}, {nub}, {pith}, {sum}, {nitty-
11:30:57 <lambdabot>        gritty}]
11:31:20 <tac_> That's not entirely enlightening :<
11:31:29 <Cale> It's from sense 3
11:31:34 <tac_> ah
11:32:11 <jle`> danilo2: you need impredicative types i think because you have an existential inside a parametric type/type constructor
11:32:47 <ReinH> Cale: I prefer to think that it's from sense 1 ;)
11:33:07 <jle`> danilo2: you need impredicative types for anything like Maybe (forall a. a -> a)
11:33:15 <jle`> the forall is "inside" the constructor
11:33:46 <savanni> bernalex: I've posted an annotation that "works" for me.  I don't know that it's what you want, but I also did not quite understand the `toDouble t v` syntax.
11:34:08 <bernalex> savanni: it just means to return the Int, kind of like Just for Maybe
11:34:36 <savanni> Actually, I don't think it does.  That syntax makes toDouble require two parameters, not one.
11:34:48 <savanni> I tried it as `toDouble (t v)`, but it can't actually do that since t isn't a real constructor.
11:35:10 <bernalex> ah
11:35:14 <bernalex> I was doing something wrong then
11:35:23 <bernalex> I want to have e.g. Year 5, and toDouble returns 5
11:35:25 <savanni> With my new annotation, I can say `toDouble (MkYear 15)` and get back 15.
11:35:27 <jle`> maybe one day we will have a nub-with-ord in base
11:35:30 <bernalex> awesome!
11:35:32 <bernalex> thanks
11:35:58 <savanni> Are you building a time module instead of using one of the recommended libraries?
11:36:32 <bernalex> savanni: it's not a time module, it's just a safe type thingy. I'm building it mostly to learn to work with classes of this kind.
11:36:54 <savanni> Ahhh.  Carry on and have fun!  Maybe play with a phantom type, too.
11:36:58 <bernalex> I thought it'd be fun to hack on something more complicated is all. and lo and behold, I learned something!
11:37:30 <bernalex> also why the ... have I named my toInt "toDouble"? WTF
11:37:36 <bernalex> that's an interesting slip
11:37:45 <savanni> Yeah, I noticed that... ;)
11:37:49 <tayacan> Question: I'm trying to write a super simple little client for a webserver, using the Network module. Right now I use connectTo to get a handle, hPutStr to send a request, and hGetContents to get the response - but I just get an empty string. If I send an identical request using the python socket library, everything works, so the request must be fine, and the server must be fine. So something must be wrong with my implementation, but
11:37:49 <tayacan> it's so simple I can't really see where it's going wrong, unless I'm misunderstanding one of the three functions I mentioned. Any ideas?
11:37:52 <hyPiRion> luckily we have types
11:39:53 <mmachenry1> tayacan: Can you check the exact string the Haskell and Python programs are sending to the server?
11:39:53 <ReinH> tayacan: what kind of web server?
11:40:12 <danilo2> jle`: Hmm, ok - I did not know this. Anyway this exampel does not work with the flag set on. Does it even have a chance to work ?
11:40:26 <ReinH> tayacan: you can use nc to debug your request
11:40:43 <ReinH> Just wondering if you can save time by using a library for whatever transport protocol you need
11:41:19 <tayacan> mmachenry, did that, they're identical
11:41:47 <savanni> tayacan: is it possible that through an unexpected laziness you are closing the connection before the value actually gets read?
11:42:05 <tayacan> ReinH, some sort of homemade HTTP server - I don't have the source.
11:42:21 <ReinH> tayacan: if it's http, you could use something like wreq
11:42:27 <ReinH> rather than implementing the HTTP stuff yourself
11:42:29 <mmachenry> tayacan: Is your code in a pastebin? Small as possible
11:42:30 <tayacan> I just tried using nc as the "server", and it recieves the request, but then the connection closes
11:42:41 <jle`> danilo2: it just looks like you have the wrong types?
11:42:50 <jle`> sorry, that doesn't sound very helpful
11:43:01 <ReinH> tayacan: nc will do that, yes. But you can have it pipe to a file
11:43:06 <ReinH> so you can compare between haskell and python
11:43:10 <jle`> but you're giving a string where it expects a function?
11:43:24 <jle`> and you're giving it the wrong Request type in the second error?
11:43:44 <ReinH> tayacan: in any event if it's an actual HTTP server I'd suggest using wreq rather than implementing your own HTTP handling
11:45:35 <danilo2> jle`: give me a second please
11:45:42 <tayacan> ReinH, it's for an assignment, I have no choice ;)
11:45:53 <ReinH> tayacan: ah, then yes implement your own http handling ;)
11:46:19 <ReinH> tayacan: if you can check that the server is receiving the same request as from the python client
11:46:41 <ReinH> tayacan: you can paste your code at lpaste.net and we can see if you're doing something obviously incorrect
11:46:44 <tayacan> ReinH, and the requests I have sent using haskell and python are identical, trust me, I have compared them thoroughly, including whitespace
11:47:13 <ReinH> tayacan: ok, then it's probably closing the connection too soon or something, although usually the problem with laziness is leaving connections open for too long.
11:47:20 <tayacan> ReinH, http://pastebin.com/QFHHq1Fr
11:47:46 <savanni> tayacan: definitely closing the connection before the result of hGetContents evaluates.
11:47:52 <bernalex> savanni: hm. a question. what would you do about my latest annotation? Int shouldn't implement toInteger and vice versa, but I don't want warnings!
11:48:24 <tayacan> savanni: How would I go about fixing it?
11:48:45 <danilo2> jle`: I just called a friend of mine (remdezx) and he told me he got this code locally (as a test) and did not push it anywhere so I cannot figure it out right now :( Anyway I will double check the types as fast as he comes back and I will write back to you If I can, ok? :)
11:48:49 <savanni> tayacan: others understand laziness better than I, but I would guess that right before you call sClose, you should say...
11:49:03 <savanni> length s' `seq` return ()
11:49:14 <savanni> Or something like that.  The point is to force s' to evaluate before the handle goes away.
11:49:22 <tayacan> savanni: I'll try that :D
11:49:48 <jle`> danilo2: np, if i'm not online i'm idling here :)
11:50:08 <danilo2> jle`: Great :) Thank you for your help! :)
11:50:20 <savanni> bernalex: I'm going to have to think about that one.  You are right, which kinda means the API needs to be rethought.
11:50:27 <jle`> danilo2: np :) fair warning, this is on the edge of my own understanding
11:50:39 <tayacan> savanni: It works! Hurray! Thank you :D
11:50:52 <danilo2> jle`: Ok, but If we both have a problem, maybe somebody will help us too :)
11:50:54 <bernalex> savanni: the main reason I'm doing it this way is of course to get toInt for free on all the newtypes
11:50:56 <tayacan> It also sort of makes sense.
11:50:59 <savanni> tayacan: that easily??? I expected compile errors at least!
11:51:11 <bernalex> I guess I could just have getVal
11:51:19 <tayacan> savanni: Nope! It worked at the first attempt :D
11:51:49 <bernalex> and then getVal :: (TimeUnit t, Num n) => t -> n
11:52:21 * hackagebot directory-layout 0.6.1.1 - Directory layout DSL  http://hackage.haskell.org/package/directory-layout-0.6.1.1 (MatveyAksenov)
11:54:09 <savanni> bernalex: I was thinking of that, but don't have it working.
11:56:32 <klrr_> does monad comprehensions originate from set theroy?
11:56:53 <klrr_> or list compresensions
11:57:00 <bernalex> savanni: me neither, I get deducing errors
11:57:02 <savanni> So, bernalex, I'm suddenly realizing that this is similar to a problem that I've had.  And there is no "nice" solution.
11:57:09 <tac_> set comprehensions were something from set theory
11:57:16 <savanni> Basically, to do the unwrapping, you really do have to handle all of the cases.
11:57:25 <bernalex> timeVal :: (TimeUnit t, Num n) => t -> n -- is kind of nice enough
11:57:44 <bernalex> but if it can't deduce instance TimeUnit Int where timeVal _ n = n, then ugh
11:57:59 <savanni> Yeah, you might have to write the unwrap code manually.
11:58:34 <cococo> How would I have multiple "where"
11:58:45 <cococo> multiple "where"s after a function?
11:58:57 <bernalex> oh wait that should be timeVal n = n. but it can't deduce that either, heh.
11:59:06 <savanni> Right
11:59:51 <cococo> nvm found the answer
11:59:59 <bernalex> the pragma list is evergrowing :-P
12:00:10 <savanni> Curiousity, though... why `newtype Year a = MkYear Integer` instead of `newtype Year = MkYear Integer` or `newtype Year a = MkYear a`?
12:01:15 <bernalex> savanni: because Year y
12:01:29 <bernalex> savanni: I want to be able to do both TimeUnit t => t -> blah, *and*, Year -> Day blah
12:02:11 <savanni> Well, I think that what you are trying probably goes beyond my skill at this point.
12:03:02 <bernalex> timeVal :: forall n. (TimeUnit Int, Num n) => Int -> n
12:03:05 <bernalex> timeVal n = n
12:03:34 <bernalex> IDK how to make it deduce that it's an int at this point heh
12:04:56 <bernalex> timeVal (n :: Int) = n with scoped type variables, it still doesn't understand it's an int :-P
12:08:04 <ReinH> bernalex: are you familiar with the units package?
12:08:20 <bernalex> ReinH: vaguely.
12:08:34 <bernalex> ReinH: again, I'm hacking here for fun not profit.
12:08:38 <ReinH> It provides comprehensive machinery for dealing with such things
12:08:52 <ReinH> And allows you to define your own units
12:09:06 <ReinH> http://www.cis.upenn.edu/~eir/packages/units/README.html
12:15:28 <cococo> I'm surprised I didn't find one when searching, but is there an easily accessable online Haskell Lint? I'm new to the language so it would help with spacing standards etc.
12:16:12 <geekosaur> lpaste has hlint built in, although it's not so much about spacing standards and such
12:17:24 * hackagebot buildwrapper 0.8.4 - A library and an executable that provide an easy API for a Haskell IDE  http://hackage.haskell.org/package/buildwrapper-0.8.4 (JeanPhilippeMoresmau)
12:24:30 <benbangert> where does cabal store packages 'in progress'?
12:24:47 <benbangert> ie, they were built, but because the configure failed, I can't seem to force them to re-build
12:24:53 <benbangert> now it just tries to Configure them anytime I retry
12:27:44 <RyanGlScott> I'm attempting some Windows FFI code, and I'm receiving some cryptic error messages. All of them relate to WSAQUERYSET (a data type I made for storing the WSAQUERYSET struct from Windows' Bluetooth API.)
12:27:48 <RyanGlScott> WTF.hsc:22:1: Unacceptable result type in foreign declaration: IO WSAQUERYSET; When checking declaration: foreign import ccall unsafe "static wsa_query_set" wsa_query_set :: IO WSAQUERYSET
12:28:48 <RyanGlScott> This GHC ticket (https://ghc.haskell.org/trac/ghc/ticket/5610) claims that error results from using a newtype argument in a foreign function that doesn't have its constructor visible.
12:29:06 <RyanGlScott> But that doesn't make any sense, since I define WSAQUERYSET in the file I'm trying to compile.
12:29:15 <rwbarton> you can't just make up arbitrary types and use them in FFI declarations
12:29:25 <rwbarton> what's the type of the C function?
12:29:45 <RyanGlScott> WSAQUERYSET wsa_query_set();
12:30:03 <RyanGlScott> The corresponding Haskell definition is data WSAQUERYSET = WSAQUERYSET DWORD LPWSTR LPGUID LPWSAVERSION LPWSTR DWORD LPGUID DWORD DWORD LPAFPROTOCOLS LPWSTR DWORD LPCSADDR_INFO DWORD LPBLOB deriving Show
12:30:09 <RyanGlScott> Yeah, it's ugly
12:30:11 <rwbarton> and is WSAQUERYSET a typedef for a pointer to a struct, or what
12:30:24 <RyanGlScott> It's a typedef to a struct (not a pointer)
12:30:30 <rwbarton> hrm
12:30:50 <RyanGlScott> Actually, it's a #define definition to WSAQUERYSETW, to be precise.
12:30:54 <johnw> hah, I love this statement on a web page about adjunctions: "One good way to motivate adjoint functors is to explain what problem they solve, and how they solve it.  That can only be done, in some sense, by what mathematicians call 'hand-waving'."
12:31:08 <rwbarton> I'm not sure whether the FFI supports returning non-basic types at all
12:31:11 <Cale> RyanGlScott: Why is that not a record type?
12:31:15 <rwbarton> you might need to write a C wrapper
12:31:35 <cococo> How would I get an array of "whois" values based on an array of domains? For example something like "map (s = whois s) domains"
12:31:40 <cococo> *list, not array
12:32:23 <RyanGlScott> Cale: I don't ever need to retrieve the contents of it. I just need to pass it to Haskell and use it with WsaRegisterService a couple of time, which requires it being Storable.
12:33:03 <RyanGlScott> What do you mean by a C wrapper?
12:33:33 <rwbarton> something like void hs_wsa_query_set(WSAQUERYSET *p) { *p = wsa_query_set(); }
12:33:44 <rwbarton> put that in a .c file
12:35:06 <RyanGlScott> Well, I was hoping to avoid using too many pointers, but I guess I don't have a choice.
12:38:09 <mmachenry> cococo: https://hackage.haskell.org/package/whois-1.1.2/docs/Network-Whois.html
12:40:02 <cococo> mmachenry: Yeah that's the library I'm using, but I'm wondering how to use it with map? For example here I map an exclemation point to every domain: http://lpaste.net/1417400200510570496
12:40:17 <cococo> mmachenry: How would I instead map the whois data?
12:41:31 <cococo> mmachenry: for example I couldn't change addTone to "addTone s = whois s"
12:42:13 <mmachenry> cococo: One sec typing
12:42:21 <cococo> sure thing thanks for the help
12:42:48 <zerokarmaleft> cococo: you want to use mapM
12:43:50 <zerokarmaleft> e.g. do results <- mapM whois ["example.com","google.com","haskell.org"]; mapM_ print results
12:44:57 <cococo> zerokarmaleft: thanks
12:45:11 <cococo> though mmachenry if you can expand on that, that would be great
12:45:27 <cococo> (in case you weren't sure if you should cancel your reply)
12:47:17 <zerokarmaleft> cococo: compare the types of map and mapM and mapM_ to understand why they work
12:47:22 <mmachenry> cococo: http://lpaste.net/104482
12:47:28 <mmachenry> Somethng like that, though I haven't run it.
12:48:04 <cococo> thanks zerokarmaleft & mmachenry, I'll be looking over your answer
12:48:07 <cococo> *answers
12:49:57 <dagle> Do gtk2hs look for pullrequests on github or is there a perfered channel?
12:53:50 <cococo> Why does Network.Whois return "Exception: getAddrInfo: does not exist (Name or service not known) for .org domains? (like "example.org" or "haskell.org")
12:54:50 <pavonia> dagle: What do you mean exactly?
13:05:47 <byorgey> dagle: see http://projects.haskell.org/gtk2hs/development/ .  Looks like they do look at pull requests.
13:08:43 <cococo> Can anyone take a look at my code? -> http://lpaste.net/3061758666353934336 <- It seems like requesting the whois info of every other domain returns some kind of exception and the program crashes. You can change "domains" to your own list of a few domains and see for yourself.
13:12:18 <cococo> > whois "example.org"
13:12:19 <lambdabot>  Not in scope: ‘whois’
13:12:33 <cococo> > import Network.Whois; whois "example.org"
13:12:35 <lambdabot>  <hint>:1:1: parse error on input ‘import’
13:12:44 <cococo> clearly I don't understand lambdabot
13:13:04 <roboguy_> cococo: usually lambdabot doesn't do any io
13:13:11 <roboguy_> > putStrLn "hello"
13:13:12 <lambdabot>  <IO ()>
13:13:52 <cococo> roboguy_: what I'm trying to demonstrate is whois returns all kinds of exceptions to the point of it being almost useless. (Please try running my code: http://lpaste.net/3061758666353934336). I'm wondering how to get around that.
13:15:26 <stephenjudkins> can anyone offer any examples or recommended reading about how and when to use arrows?
13:16:43 <MitchellSalad> stephenjudkins: i really don't use arrows much at all, the occasional &&& or ***. i may be in the minority, though
13:17:19 <cococo> sorry I timed out
13:17:33 <pmade> cococo: What sorts of exceptions are you getting?
13:17:34 <cococo> roboguy_: did you check out my code?
13:17:47 <cococo> pmade: *** Exception: getAddrInfo: does not exist (Name or service not known)
13:17:54 <cococo> ^ That's one of them, I'll paste a couple more
13:17:56 <roboguy_> cococo: not directly, but Network.Whois seems very nonresponsive to me
13:18:05 <cococo> *** Exception: <socket: 9>: hGetContents: resource vanished (Connection reset by peer)
13:18:07 <Timoteo> I'm using cassandra-cql and wondering how I would go about declaring this type as an instance of CasType: data Person = Person Text Text
13:18:23 <cococo> Actually those two might be it, I don't remember
13:18:27 <Timoteo> are there any good examples?
13:18:59 <pmade> cococo: Track down the name of a valid whois server for the TLDs you're using and provide that to whois1 directly.
13:19:02 <tremon> cococo: iiuc, you're querying 8000 domains simultaneously? Maybe the registrar isn't happy with you doing that?
13:19:03 <cococo> Have I been wrong to assume Haskell is an anything-purpose language?
13:19:21 <cococo> tremon: I've tried it on single domains too ;)
13:19:21 <roboguy_> cococo: no. did you try whois "..." by itself
13:19:28 <cococo> roboguy_: yes
13:19:33 <roboguy_> cococo: that works fine?
13:19:41 <cococo> pmade:  k i'll try that
13:19:55 <pmade> cococo: Also, you should pause between requests.
13:20:03 <roboguy_> I bet it's something to do with trying a few thousand queries at once, reconnecting each time
13:20:09 <rwbarton> if you do anything involving the internet 8000 times you're going to get some errors
13:20:10 <cococo> roboguy_: no, same error. Just "whois haskell.org" returns "*** Exception: getAddrInfo: does not exist (Name or service not known)"
13:20:42 <cococo> ----> I've tried checking one at a time, same thing. I can also run "whois example.org" in my terminal just fine
13:21:17 <cococo> pmade: yeah, I only ran that code that's on lpaste once before realizing I forgot to sleep it between requests
13:21:22 <pmade> cococo: We're trying to tell you that your mapM is going to make 8000 network connections, one right after the other.
13:21:31 <cococo> I know
13:21:34 <cococo> I'm saying
13:21:41 <cococo> I only ran that code once, and I'm aware of what it does
13:21:47 <cococo> Pretend you never saw that, same issue
13:22:00 <cococo> Try for yourself
13:22:02 <roboguy_> cococo: what does this say? whois1 "google.com" (WhoisServer {hostname = "com.whois-servers.net", port = 43, query = "domain "})
13:22:04 <pmade> Can you do the networking part yourself and make all the requests under a single connection?
13:22:46 <roboguy_> the strange thing is, whois seems to hang for me but seems fine and whois1 seems ok too
13:22:54 <roboguy_> *but serverFor
13:23:44 <cococo> roboguy_: that works fine, but I haven't had a problem with .com
13:24:19 <cococo> roboguy_: hmm, that's not returing any errors for .org either though, just 'Just "NOT FOUND\n"
13:24:29 <roboguy_> cococo: try whois1 "haskell.org" (WhoisServer {hostname = "org.whois-servers.net", port = 43, query = "domain "})
13:24:37 <roboguy_> (different whois server for .org)
13:24:49 <cococo> roboguy_: that's what i did
13:25:12 <roboguy_> cococo: you changed the hostname string? hmm that's weird it works ok for me
13:25:13 <cococo> roboguy_: returns: Just "NOT FOUND\n"
13:26:08 <cococo> I don't think I'm being punished for making too many consecutive requests 5 mins ago since I can run "whois haskell.org" in my terminal and get real ouput
13:26:44 <roboguy_> cococo: try serverFor "haskell.org"
13:27:02 <cococo> roboguy_: I get the correct server
13:27:07 <cococo> roboguy_: what's your output of
13:27:14 <cococo> "whois1 "haskell.org" (WhoisServer {hostname = "org.whois-servers.net", port = 43, query = "domain"})" ?
13:27:23 <cococo> whoops formatting issues
13:27:25 <cococo> but you know what I mean
13:27:36 <cococo> (code pasted weirdly)
13:29:45 <cococo> installing haskell on my remote server just to make sure I'm not temp-banned from their whois server...
13:31:54 <cococo> well i gtg, pm my any thoughts/help/answers
13:58:57 <joelteon> hey, anyone know of a way to determine whether a file probably contains text or binary data?
13:59:22 <Rembane> joelteon: Look for bytes that aren't readable characters.
14:00:58 <identity> joelteon: Yeah, what he said I guess? Number of isReadable vs total size?
14:01:12 <tremon> joelteon: what's "text"? you can determine ascii by testing if any bytes have their msb set, other than that, I don't think you can be certain
14:01:50 <tayacan> joelteon: isPrint in Data.Char is probably useful :)
14:07:46 <ReinH> joelteon: the naive way is to check for invalid utf-8 sequences. That's what google codesearch did.
14:08:17 <ReinH> But obv not all files are encoded utf-8, so it's quite naive
14:08:57 <joelteon> maybe I'll take tremon's advice
14:09:01 <joelteon> well, no
14:09:04 <joelteon> some of it will be utf-8
14:09:42 <tremon> the only really good advice is "if you don't know the encoding, it's binary" (or at least opaque)
14:10:45 <Chousuke> checking for invalid utf-8 is a pretty decent way unless you know you'll have a significant amount of non-utf-8 non-ascii text files
14:10:55 <Chousuke> since ascii is valid utf-8
14:11:24 <djbeau> does anyone know of a well-known way to do the following?  I would like to compose prisms together, any of which could "fail to match", and if so I would like to be able to tell which particular prism failed
14:11:26 <tremon> yeah, but base64-encoded data is also valid utf-8. Don't think many would consider that text
14:12:30 <benzrf> djbeau: you could try writing your own combinator, but i am not so well versed in lens to know if there's an existing solution
14:12:34 <benzrf> djbeau: you could ask #haskell-lens
14:12:38 <benzrf> but what exactly are you trying to do?
14:12:39 <Chousuke> well, since in reality there's no difference between text and binary data at all, you have to decide on some differentiator
14:13:50 <roboguy_> what about tayacan's suggestion of isPrint to see if it's binary?
14:14:34 <Kazagistar> does lens add a lot to binary size?
14:14:41 <tremon> does isPrint take a Word8 parameter?
14:14:48 <djbeau> benzrf: I am trying to perform operations on my own sum type, but each operation expects a particular variant of the sum type
14:14:49 <Chousuke> it takes a char
14:15:03 <benzrf> djbeau: but why do you need to know which lens failed
14:15:07 <djbeau> benzrf: if it get the wrong variant, I would like to get a descriptive error
14:15:12 <Chousuke> roboguy_: the problem is that text is just binary data unless you also specify an encoding.
14:15:18 <tremon> then you've already made an assumption about the data. Char != byte
14:15:20 <djbeau> because the type can be recursive in some cases
14:15:53 <Chousuke> roboguy_: so a non-printable character in one encoding could be a printable character in another.
14:16:03 <djbeau> benzrf: he is a pretty good analogy: processing JSON data (which can be recursive) and failing if it is not in the expected format
14:16:30 <djbeau> benzrf: (by recursive, I really mean JSON objects and arrays)
14:16:32 <roboguy_> djbeau: can't you put that into the error type?
14:18:08 <djbeau> roboguy_: do you mean like using an Either as the applicative instance?
14:18:24 <roboguy_> djbeau: yeah
14:19:39 <djbeau> roboguy_: that is what I was thinking, but the problem is that if I have a deeply nested data structure (I should have used the word "nested" instead of "recursive") then how can I know which level of my composed prism failed?
14:20:56 <djbeau> if I use the view combinator, for instance, failure implies that I get the empty monoid (I believe) of my error type
14:21:17 <dagle> byorgey: I guess I have to wait longer then. Soon 10 days and not a word.
14:21:24 <roboguy_> djbeau: you need to know a level number?
14:21:24 <djbeau> but I can only define one empty monoid for any type
14:21:29 <benzrf> djbeau: why do you need to know?
14:21:40 <benzrf> at which level it failed?
14:21:46 <djbeau> benzrf: because I want a descriptive error :)
14:21:53 <benzrf> djbeau: you're generating erros?
14:21:55 <benzrf> *errors
14:22:04 * djbeau trying to think of a more detailed example
14:22:08 <byorgey> dagle: yes, I guess so.  There are not many people actively working on it.
14:22:32 <djbeau> benzrf: yes - if my input is screwed up, I want to know *how*
14:23:27 <benzrf> djbeau: ask edwardk
14:23:38 <djbeau> benzrf: indeed :)
14:23:55 <benzrf> my first thought is to create a variant of preview that uses a functor supporting error messages or something
14:23:57 <benzrf> but i bet that already exists
14:24:07 <benzrf> or maybe some kind of error monoid p:
14:24:15 <benzrf> preview is just view forcing the First
14:24:21 <benzrf> monoid, then unwrapping it
14:24:53 <benzrf> *and wrapping it to start with
14:25:16 <benzrf> is Either a monoid?
14:25:25 <benzrf> is there a First  monoid for either?
14:26:40 <ntoastie> The IO type is an instance of something called a monad, which is a scary name for a not-so-scary
14:26:40 <ntoastie> concept. Basically, a monad is a way of saying “there’s some extra information attached to this value,
14:26:40 <ntoastie> which most functions don’t need to worry about”. In this example, the “extra information” is the fact
14:26:42 <ntoastie> that this action performs IO, and the basic value is nothing, represented as (). Monadic values are
14:26:44 <ntoastie> often called “actions”, because the easiest way to think about the IO monad is a sequencing of actions
14:26:46 <ntoastie> that each might aﬀect the outside world.
14:27:10 <djbeau> benzrf: I don't immediately know the answers to your questions, but I will try and spit out a concrete example
14:27:12 <roboguy_> ntoastie: ?
14:27:49 <monochrom> that is a wrong description.
14:28:06 <benzrf> that is absolutely a wrong description
14:28:37 <ntoastie> its from writing a scheme in 48 hours, sorry, i wanted to clarify
14:29:00 <monochrom> a correct description is my http://www.vex.net/~trebla/haskell/IO.xhtml and it does not require describing monads first.
14:31:25 <djbeau> my prism (from Data.Aeson.Lens): _Object . ix "key" . _String
14:32:10 <djbeau> is there a way to tell if the input was not an "Object" versus that it was an Object but did not contain a mapping for "key"?
14:32:31 <djbeau> s/tell if/tell the difference between/
14:33:05 <djbeau> I suppose I am really looking for a good combinator and/or applicative instance, but I have not been able to find it yet
14:34:59 <djbeau> or maybe I can create my own special prism creation function that wraps the appropriate error each time...
14:35:19 <djbeau> that is, for each component of the composition
14:36:41 <chrisdone> monochrom: i made an attempt at making the wiki prettier here: http://haskell-lang.org/wiki/A_brief_introduction_to_Haskell#io
14:37:14 <bitemyapp> chrisdone: very pretty!
14:37:19 <benzrf> :t _Left :: AGetter
14:37:20 <lambdabot>     Not in scope: type constructor or class ‘AGetter’
14:37:20 <lambdabot>     Perhaps you meant one of these:
14:37:20 <lambdabot>       ‘Getter’ (imported from Control.Lens),
14:37:23 <benzrf> :t _Left :: Getter
14:37:24 <lambdabot>     Expecting two more arguments to ‘Getter’
14:37:24 <lambdabot>     Expected a type, but ‘Getter’ has kind ‘* -> * -> *’
14:37:24 <lambdabot>     In an expression type signature: Getter
14:37:27 <benzrf> hmm
14:37:52 <chrisdone> bitemyapp: =3
14:38:07 <benzrf> :t _Left :: Getting (First Int) (Either Int String) Int
14:38:08 <lambdabot> Getting (First Int) (Either Int String) Int
14:38:10 <benzrf> sweet
14:38:14 <benzrf> :t _Left :: Getting Sum (Either Int String) Int
14:38:15 <lambdabot>     Expecting one more argument to ‘Sum’
14:38:15 <lambdabot>     The first argument of ‘Getting’ should have kind ‘*’,
14:38:15 <lambdabot>       but ‘Sum’ has kind ‘* -> *’
14:38:19 <chrisdone> it uses hscolour to pretty print, which should be fairly reliable
14:38:20 <benzrf> :t _Left :: Getting (Sum Int) (Either Int String) Int
14:38:21 <lambdabot> Getting (Sum Int) (Either Int String) Int
14:38:24 <benzrf> oh that works huh
14:39:03 <benzrf> djbeau: write a function that works like preview but uses First over Either instead of Maybe
14:39:49 <benzrf> djbeau: although then you run into the issue of mempty being nonspecific...
14:39:50 <benzrf> hmmmmmmm
14:40:31 <djbeau> benzrf: yes, that was the brick wall I was hitting with using a Getter
14:40:39 <benzrf> right right
14:41:13 <djbeau> benzrf: you have been very helpful and this helps me forward...unfortunately, I have to leave, but I will stay logged in
14:41:19 <chrisdone> i had similar complaints that my error handling article looks like ass on haskell.org http://www.haskell.org/haskellwiki/Handling_errors_in_Haskell compare with: http://haskell-lang.org/wiki/Handling_errors_in_Haskell
14:41:22 <bitemyapp> chrisdone: how open are you to having that CSS reused?
14:41:46 <chrisdone> bitemyapp: i'd welcome it
14:42:26 <sm> oh another chrisdone joint - awesome
14:43:24 <chrisdone> sm: <3
14:44:09 <chrisdone> bitemyapp: use for what btw?
14:45:04 <TheFuzzb_> So, if you have a function that doubles an int, like: double a = (*) a 2, and you use the point-free style: double = (*) 2, why can't I create a lambda of that function using point-free style?
14:45:25 <heatsink> You can
14:45:30 <heatsink> > ((*) 2) 10
14:45:32 <lambdabot>  20
14:45:49 <chrisdone> bitemyapp: i made another homepage design, but it's probably a little egregious http://chrisdone.com/comp.png
14:46:26 <TheFuzzb_> heatsink Oh, that's awesome! I was trying (\ -> (*) 2)
14:47:00 <sm> sweet! haskell goes fully web 2.0 ! :)
14:47:03 <j`ey> chrisdone: looks good
14:47:13 <TheFuzzb_> "Web 2.0"
14:47:48 <Guest25477> what are good haskell web app frameworks?
14:48:01 <TheFuzzb_> Snap?
14:48:09 <benzrf> :t preview
14:48:10 <lambdabot> MonadReader s m => Getting (First a) s a -> m (Maybe a)
14:48:11 <plosi> chrisdone: I really like that. I personally think that brighter colors should be used for the syntax highlighting though
14:48:13 <benzrf> p:
14:48:14 <chrisdone> i find haskell.org embarassing to link people to, it's so 90's and messy. i'd propose something to the committe but if i don't have the patience to make it through the stonewalling and bikesheds
14:48:16 <mm_freak> hi there
14:48:53 <benzrf> djbeau: how about make a Getter that explicitly works on the Const functor, and puts an error message instead of using pure?
14:49:01 <Guest25477> haskell.org isnt that bad, i'd put it at web 1.4
14:49:02 <mm_freak> is there a name for "contravariant" monoid morphisms?  like the 'reverse' function
14:49:02 <benzrf> djbeau: it seems like a bad idea to me :-)
14:49:06 <benzrf> djbeau: *Getting, also
14:49:11 <mm_freak> reverse (x <> y) = reverse y <> reverse x
14:49:20 <Guest25477> chrisdone's looks 10x better though
14:49:57 <roboguy_> mm_freak: probably just contravariant
14:50:15 <mirpa> How can I manage loading of (big) shared resources (with limited Ram)? Eg. texture in OpenGL. Do I simply create a Map which will hold shared data and reference count?
14:50:26 <mm_freak> roboguy_: yeah, sounds reasonable
14:50:33 <plosi> chrisdone: I think that the most appealing website for any programming language that I've run across recently is scala-lang.org
14:50:35 <chrisdone> guest25477:  thanks. yesod, snap, happstack are useful frameworks
14:50:45 <chrisdone> plosi: agreed
14:50:47 <heatsink> chrisdone: Pretty, but the high formatting-to-content ratio makes it taste like an autogenerated cybersquatting website.
14:50:48 <mm_freak> each such morphism is a contravariant functor after all
14:51:20 <monochrom> I don't care about eye candies. but I care about correct. including layout correct.
14:51:29 <mm_freak> mirpa: there are many approaches depending on what you're doing, but i haven't seen a generic memory caching library yet
14:51:37 <rwbarton> mm_freak: antihomomorphism
14:51:43 <heatsink> monochorm: layout correct?
14:51:43 <chrisdone> heatsink: maybe so, but such bikeshedding leads to what we have today
14:52:18 <chrisdone> everybody has a little criticism to make over something positive, so nothing is done and haskell.org looks worse than it did *in the 90's*, actually
14:52:20 <mirpa> mm_freak: game - dynamic loading of perhaps nested data which could be shared
14:52:32 <mm_freak> rwbarton: indeed, thanks
14:52:51 <plosi> monochrom: I agree that eye candy shouldn't be the primary focus, but it certainly doesn't hurt when applied correctly
14:53:07 <mm_freak> mirpa: i'm afraid you'll have to code that yourself, but i do use ResourceT in most of those cases as a helper
14:53:18 <monochrom> I also prefer that we attract more people who prioritize correctness and fewer people who prioritize candiness. because otherwise we would attract people who bicker about syntax and forget about semantics.
14:53:25 <chrisdone> eye candy is just like showering and wearing clothes, both make you palatable
14:53:35 <mm_freak> mirpa: that doesn't give you resource reuse, but at least it gives you predictable resource freeing
14:53:48 <benzrf> haskell.org looks fine to *me*
14:54:09 <chrisdone> benzrf: sure
14:54:17 <mm_freak> monochrom: i love eye candy, and i have to admit that it does attract me
14:55:33 <heatsink> point taken.
14:56:12 <chrisdone> such discussions are the kind that begin if you bring it up on the web site mailing lists
14:57:34 <heatsink> Making progress requires giving someone the final say on the design.  Someone who can judiciously take and ignore advice.
14:57:53 <chrisdone> scala, ruby, python are examples of that
14:58:15 <chrisdone> they look good, clean and tasteful because they gave the job to one person who professionally does that and then they came back with something nice
15:00:02 <benzrf> wrong channel soz
15:00:26 <monochrom> /mode +v benzrf
15:00:30 <benzrf> haha
15:00:42 <benzrf> a guy mistakenly set +m in another chan im in
15:01:11 <chrisdone> anyhoo, that's why i registered an alt. domain, so i can just link people to that and avoid having to say "ignore the mess, it's a clean and tidy language and community, i swear"
15:01:35 <benzrf> chrisdone: what domain?
15:01:39 <benzrf> and what mess :o)
15:01:47 <chrisdone> http://haskell-lang.org/wiki/Handling_errors_in_Haskell
15:01:50 <chrisdone> ^ see here
15:01:54 <monochrom> actually, in what sense is haskell.org messy?
15:02:37 <monochrom> I have my own sense of "haskell.org is a mess", but I want to hear yours too
15:02:58 <chrisdone> so, the messy parts are: usability, layout, coloring, audience-ambiguity, steps-to-goal ambiguity/no clear embraced path, and last of all: it's a wiki
15:03:25 <chrisdone> did i miss anything?
15:03:39 <monochrom> my sense is basically "it's a wiki"
15:03:57 <chrisdone> apart from the fact the layout itself is broken, not in a "i don't like it" sense, but i think something's broken and it needs maintenance
15:04:05 <sm> hold on, hold on.. "it's a wiki" isn't fair
15:04:25 <bitemyapp> chrisdone: use for what? Uhhhh...documentation for libraries. Anything really.
15:04:40 <bitemyapp> chrisdone: I really...really want that mock to be Haskell's landing page.
15:04:51 <geekosaur> cue "I can't find any damn thing" quote
15:04:53 <hpc> wikis are not webscale because two people cannot edit the same page at the same time ;)
15:05:10 <monochrom> hahaha
15:05:15 <hpc> wordpress is webscale
15:05:21 <hpc> two people can write posts at the same time
15:05:23 <chrisdone> bitemyapp: heh, thanks. it's just a mock, i've shuffled it around a bunch of times and i went a little overboard on the candy just to be audacious, but i do agree re the content i put on there
15:05:32 <hpc> because of concurrent semantics in the webbing
15:05:33 <davean> hpc: you can introduce operational semantics with a CRDT that allows it
15:05:50 <davean> hpc: You might just not like it as much
15:05:53 <hpc> it securely mediates the web2.0
15:05:59 <hpc> :P
15:06:04 <bitemyapp> chrisdone: I think it's great. If you're anathema to politicking, could I see about what it would take to make it the front page?
15:07:12 <hpc> davean: i did not know crdts were a thing, reading
15:08:06 <bitemyapp> chrisdone: only problem might be the try haskell bit in the middle.
15:08:16 <chrisdone> bitemyapp: mm i think it's more of a general organization issue. in my experience that politicking is a black hole of enthusiasm. i'd prefer to flesh out the idea on haskell-lang.org and if i get something nice i might propose it
15:08:27 <bitemyapp> chrisdone: reasonable.
15:08:36 <bitemyapp> chrisdone: regardless, I want us to present ourselves better.
15:08:44 <bitemyapp> chrisdone: thanks for all your work :)
15:08:44 <davean> hpc: there is a specific research paper on CRDTs for wikis explicitely
15:09:25 <chrisdone> bitemyapp: agreed =)
15:09:47 <monochrom> "it's a wiki" is totally fair and exactly right. actually make it "it's a wiki of free labour". logical consequence of a wiki of free labour: vocal over-excited minority. logic consequence of vocal over-excited minority: writers get carried away and give you information overload.
15:10:03 <bitemyapp> chrisdone: admittedly, I'm not helping by having a tutorial/course to learning Haskell in a github repo linked from a site using the default Hakyll template.
15:10:09 <bitemyapp> so uh. I have some work to do there too I guess.
15:10:12 <chrisdone> monochrom: indeed!
15:10:34 <monochrom> the thing is, excited information overload is exactly what an encyclopedia needs, this is why wiki works so well for wikipedia. but haskell.org is not encyclopedic.
15:11:27 <bitemyapp> does anybody know the name of that website that shows you the "prerequisite concepts" you have to learn in order to learn the concept described, such as linear regression, and shows you "hours to learn" for each component?
15:11:30 <chrisdone> right -- i would personally like the home page to simply be a few very clear pages: where do i download it, where do i learn it, where do i find human beings, where do i follow news. that's all i generally want from a language site. the wiki is cool, but it should be a wiki, not a clever hybrid
15:11:40 <yogurt_truck> I'd take information overload (haskell's wiki) over a hollow bunch of lies with a fashionable design (www.scala-lang.org), any day
15:11:47 <yogurt_truck> but of course that's a false dichotomy
15:11:54 <benzrf> yogurt_truck: hollow bunch of lies?
15:12:23 <yogurt_truck> you could have something serious, and useful, _and_ nicely designed, in addition to the existing haskell wiki
15:12:40 <chrisdone> here was an org file i wrote for myself when assessing the crop of language sites out there https://gist.github.com/chrisdone/79bab72187590d3159e3
15:12:49 <yogurt_truck> benzrf: yes. it makes scala look like something it isn't (a horrid mess)
15:13:08 <benzrf> yogurt_truck: it makes it look like a horrid mess?
15:13:16 <napping> yogurt_truck: or that it's not a horrid mess?
15:13:27 <benzrf> yogurt_truck: when talking to me, please keep in mind that i also use and enjoy ruby
15:13:30 <benzrf> ;)
15:13:33 <yogurt_truck> sorry, I mean anything but a horrid mess :D
15:14:00 <bitemyapp> benzrf: ?
15:14:24 <benzrf> bitemyapp: eh?
15:14:27 <bitemyapp> chrisdone: look on the bright side, at least we have up to date language/stdlib documentation.
15:14:39 <bitemyapp> chrisdone: the Clojurians *still* haven't updated their doc sites or docs for the language core lib in years.
15:14:46 <sm> I believe that whether a site is a "wiki" is orthogonal to its attractiveness. There are attractive wikis, mozilla's MDN for one
15:14:49 <chrisdone> i tried also to style the haskell2010 report, but that's a bit difficult as the output from latex is strange http://haskell-lang.org/report/2010/haskell.html
15:14:51 <bitemyapp> lang is on 1.6, docs have been stuck on 1.2/1.3 for ages.
15:14:53 <bitemyapp> pathetic.
15:15:29 <napping> chrisdone: linking the GHC users guide on the Documentation page would make haskell-lang.org about 90% more complete
15:15:30 <LT1MH> sup every1
15:15:35 <bitemyapp> sm: that's fine, but the landing page needs to be cleaner and explain what Haskell is better.
15:15:38 <benzrf> sup LT1MH
15:15:58 <sm> bitemyapp: I'm not debating that at all
15:16:06 <yogurt_truck> bitemyapp: any reason why they haven't?
15:16:08 <napping> chrisdone: in other words, that's the only link I use at all often from haskell.org that you don't already heave
15:16:11 <chrisdone> napping: that would be a good link, yeah. there're of course books and things i didn't mention there, but would
15:16:17 <bitemyapp> yogurt_truck: laziness, "I got mine"
15:16:25 <yogurt_truck> :(
15:17:30 <LT1MH> tehehe
15:18:28 <yogurt_truck> I only know that I would have loved to have a Scalawiki thing with in-depth information about the mess I was about to get into, when I first jumped into Scala :D
15:19:14 <LT1MH> napping of illinois u comp. lab has quit...he is leaving!
15:19:15 <yogurt_truck> "Even though its syntax is fairly conventional, Scala is also a full-blown functional language. " doesn't tell you about the billion things the language has that make FP incredibly painful and less robust than in a language like haskell
15:19:56 <LT1MH> haskell is a language!
15:20:11 <monochrom> on the bright side, most programmers don't want robust
15:20:52 <yogurt_truck> reliability is passé!
15:21:06 <LT1MH> BleeeeeeeeeeeeHHHHHHHHHHHHHHHHHHHH
15:21:45 <chrisdone> maybe the mockup theme is overly trendy or whatever, but the content i thought a bunch about, my reasoning is that i've a specific audience in mind, i.e. people who are new to haskell. i looked at languages i'm not familiar with, like rust or w/e.
15:21:45 <chrisdone> whenever i see a language site i want a bunch of things answered: what's the name? what is it in a one-liner nutshell? what does the code look like (this matters)? can i try it real quick? is there a community around it? no, really, are there human beings using this? what are the selling points? any events?
15:21:45 <chrisdone> if 50% of those are satisfying, then i think "okay, where do i learn more about this"
15:23:06 <monochrom> chrisdone, I support you.
15:23:38 <sm> agreed, please keep going chrisdone. Live sites are the best way to see what works
15:23:40 <chrisdone> monochrom: cool =)
15:24:12 <sm> just curious what's your plan for managing the content in future. Git ?
15:24:15 <chrisdone> alright, next time i update it i'll ping you guys
15:24:55 <hexagoxel> llvm.org still does not mention what llvm stands for :D
15:24:55 <rothbard> bitemyapp: the official clojure API docs are up to date. you're talking about a 3rd party site.
15:25:09 <chrisdone> sm: you mean for the site separate to the wiki? sure. a pull request or an emailed patch?
15:25:42 <benzrf> hexagoxel: it no longer stands for anythin g
15:25:46 <chrisdone> (it ought not to change that often, or if it is often it may better be automated)
15:25:55 <sm> so it'd be a git-based static front site, with the old wiki still there behind ? Got it
15:26:11 <jfischoff> chrisdone: I also support you ;)
15:26:12 <chrisdone> that was the plan so far
15:26:20 <chrisdone> \o/
15:26:32 <hexagoxel> benzrf: ah i didn't even know that, interesting :D
15:26:35 <ReinH> chrisdone: <3
15:26:51 <sm> we can move through this process much quicker on IRC eh :)
15:26:51 <chrisdone> hey rein =)
15:26:54 <monochrom> to a large extent, how to expand an acronym is unimportant. an acronym can be a first-class proper name too. the real-world thing it refers to, and what good it is for, are more important.
15:27:47 <monochrom> for example, the DVD consortium have long declared that "DVD" does not have an expansion. it is a first-class proper name already. and it suffices that you know it refers to those kind of optical discs.
15:27:57 <chrisdone> true
15:28:36 <chrisdone> SSD = solid state (disk|drive)
15:30:06 <hexagoxel> but still second sentence from llvm.org "Despite its name, LLVM has little to do with traditional virtual machines"
15:30:44 <hexagoxel> reader's thoughts: "wait, so vm stands for virtual machine.. i wonder what ll is for"
15:32:29 <tac_> low level
15:33:11 <hexagoxel> tac_: but only formerly, as i was informed
15:33:20 <chrisdone> hexagoxel: indeed,  the opening paragraph is like reading footprints of dancers in the sand
15:33:41 <tac_> hexagoxel: I think as the person interpreting the word, I get to decide what it stands for.
15:33:43 <chrisdone> The LLVM Project is a collection of modular and reusable compiler and toolchain technologies. Despite its name, LLVM has little to do with traditional virtual machines, though it does provide helpful libraries that can be used to build them. The name "LLVM" itself is not an acronym; it is the full name of the project.
15:33:43 <chrisdone> it's like three people wrote the paragraph in isolation and concat'd them together
15:34:21 <nicoo> chrisdone: concatMap's power
15:34:53 <ion> level is over 9000
15:34:54 <chrisdone> nicoo: give me (>>=) or give me death!
15:35:16 <nicoo> :]
15:35:49 <chrisdone> off to bed. ciao~
15:49:28 <ReinH> I'll take foldMap, thank you very much.
15:51:05 <Spark> are there any functional languages that will coerce on the == type, i.e. it's possible that a == b but a in fact cannot be substituted with b because it has subtley different behaviour before it is coerced?
15:51:23 <Spark> *on the == operator
15:51:50 <Fuuzetsu> Can you rephrase all that?
15:52:24 <Spark> well, in C, 3 == 3l
15:52:29 <Fuuzetsu> isn't that anything where a == b doesn't imply a ≡ b?
15:52:34 <Spark> but 3 cannot be substituted for 3l because sizeof(3) != sizeof(3l)
15:52:39 <Fuuzetsu> right
15:53:14 <Fuuzetsu> well, simple example in Haskell would be 0 and -0
15:53:20 <Fuuzetsu> they == but they don't ≡
15:53:22 <Spark> if a language has such an == operator, then you have to be careful to use a stronger == if you want to define referential transparency
15:53:30 <Spark> call it ===
15:53:37 <Spark> so 3===3 but not 3===3l
15:54:00 <Fuuzetsu> so in Haskell, (∀x y. x == y → f x == f y) certainly doesn't hold
15:57:44 <etrepum> bitemyapp: https://github.com/etrepum/ghc-dot-app is a start
15:58:19 <etrepum> bitemyapp: seems to build a relocatable ghc install with the right directory structure
15:58:56 <bitemyapp> etrepum: this is nice.
15:59:32 <bitemyapp> etrepum: very impressive. Do you want to shake it out or do you want more time?
16:00:10 <ReinH> etrepum: ooooh
16:00:22 <etrepum> bitemyapp: I should probably knock out at least the Info.plist and make it do something if you doubleclick on it, bare minimum open a browser to the README :)
16:01:34 <bitemyapp> etrepum: right-o. I don't think I have much expertise to contribute here, I work on a Mac but I've always been more of a Linux person. Don't know Mac app packaging conventions that well.
16:01:44 <bitemyapp> etrepum: if you want help to kick over a task let me know.
16:03:01 <etrepum> bitemyapp: will do, I don't think there's much to do that doesn't require Mac domain expertise other than just testing it out
16:03:03 <cococo> Why do I get an error when calling `whois "haskell.org"` with Network.Whois?
16:03:18 <cococo> It works with some TLDs, but with other TLDs (like .org) it gives exceptions every time
16:04:10 <hcaulfield57> As I'm trying to program more in Haskell, I'm trying to get a proper style down, could someone tell me what is preferred out of http://lpaste.net/104487 Or perhaps what is the more common style for Haskell code. What's the standard, or close to it?
16:06:05 <bitemyapp> etrepum: registering a domain for it.
16:06:44 <etrepum> bitemyapp: wouldn't it be better to just get it on haskell.org when it's ready?
16:07:11 <bitemyapp> etrepum: ehhh. it'd miff the Platform people.
16:07:15 <bitemyapp> etrepum: `whois ghcformacosx.com`
16:07:44 <bitemyapp> etrepum: we can put it on there, make our point, work backwards to haskell.org when they're ready to talk about why we're not using Platform.
16:07:54 <bitemyapp> I'm not waiting on them.
16:08:17 <etrepum> bitemyapp: well, the platform folks could use the same thing to package up platform for mac... it would just be this, with a bunch of things pre-installed
16:08:49 <bitemyapp> etrepum: part of the reason this intrigues me is precisely to avoid the pre-installed stuff in global package-db.
16:09:02 <bitemyapp> etrepum: how do we get Mac OS X to not label the .app as cancer?
16:09:10 <bitemyapp> is that the Info plist or a signature?
16:09:20 <etrepum> bitemyapp: both
16:09:33 <bitemyapp> etrepum: does the latter mean $100/year?
16:09:38 <etrepum> bitemyapp: yes
16:09:46 <etrepum> bitemyapp: I'm already paying that, so that's not a problem
16:09:51 * bitemyapp nods
16:10:02 <bitemyapp> it's not the money, it's the irritation.
16:11:12 <etrepum> well it would only affect people who are double-clicking the thing and expecting something to happen, you can download executables and run them from the terminal all you want
16:11:40 <bitemyapp> etrepum: Do you know community policy on using the Haskell name / logo?
16:11:50 <etrepum> bitemyapp: we can create a github org for it and use https://help.github.com/articles/setting-up-a-custom-domain-with-github-pages#subdomains
16:11:52 <etrepum> bitemyapp: I don't
16:12:37 <bitemyapp> hrm. going to assume it doesn't matter.
16:13:06 <etrepum> bitemyapp: I suspect not, if they were going to enforce anything I assume info would be here http://www.haskell.org/haskellwiki/Brand
16:13:28 <bitemyapp> etrepum: ding, thanks.
16:15:45 <benbangert> etrepum: why not 7.8.3?
16:16:21 <etrepum> benbangert: because there aren't binaries for that yet.
16:16:47 <benbangert> ah
16:17:02 <bitemyapp> I wasn't aware 7.8.3 was done.
16:17:22 <bitemyapp> mostly because of Windows  >:)
16:18:15 <benbangert> oh, guess I was thinking of 7.8.2
16:19:22 <bitemyapp> benbangert: get your wires crossed with 7.6.3 perhaps?
16:19:41 <benbangert> apparently
16:22:34 <usr> Hey, feel free to tell me if it would be inappropriate to this channel, but...
16:23:15 <usr> Anyone up to a semi-philosophical discussion about the equivalence and respective merits of OOP-style desing patterns vs. functional programming idioms?
16:23:21 <bitemyapp> usr: nope.
16:23:34 <bitemyapp> usr: there are poly-glot channels for that sort of thing.
16:23:54 <bitemyapp> usr: #polyhack comes to mind, but you won't more than a couple that know FP.
16:23:59 <usr> Do you have any suggestions or you trust my google-fu?
16:24:14 <bitemyapp> usr: you'd be better off learning FP so you could answer your questions and be able to read the papers.
16:24:36 <bitemyapp> usr: it just so happens...I have a guide for doing so: https://github.com/bitemyapp/learnhaskell
16:24:44 <bitemyapp> usr: ping me if you get stuck, need help, whatever.
16:24:58 <bitemyapp> usr: my advice? Avoid the comparative theology and learn things for yourself.
16:25:02 <usr> well yeah, the thing is that I am now pretty comfortable with functional idioms, but I work with people who think in OOP patterns.
16:25:10 <bitemyapp> usr: I see.
16:26:05 <usr> See just yesterday I was having a problem for which a good ol' sum type + case switch would have been perfect, and it really bugged me that OOP had no intuitive equivalent
16:26:25 <bitemyapp> usr: they don't have anything nice, no.
16:26:37 <benzrf> OOP is cool
16:26:38 <usr> And after a lot of research and discussion, it seems like the *visitor pattern* is what you would use
16:26:39 <benzrf> so is FP
16:26:44 <bitemyapp> usr: no, it's not.
16:26:47 <benzrf> y cant we just get along :(
16:27:05 <bitemyapp> usr: visitor pattern is a verb pattern, sum types are a noun.
16:27:21 <bitemyapp> usr: the equivalent to visitor is Functor. It sounds like you need to bone up on your FP.
16:27:25 <bitemyapp> usr: are you sure you don't want to reconsider my offer?
16:27:40 <bitemyapp> usr: it's pretty easy to translate and understand what you're trying to do right now if you understand FP thoroughly.
16:27:46 <usr> I know the equivalence is awkward, which was a bit my point.
16:28:31 <usr> Your suggestion of "learning things for myself" is kind of vague, given I have to adapt myself to OOP tools and people.
16:28:59 <bitemyapp> usr: we can waste hours talking past each other
16:29:02 <bitemyapp> usr: or I can help you learn
16:29:13 <usr> yeah, why not!
16:29:14 <zennist> Hello hackers, a great question here: how to sort file names sanely? e.g. file6.pdf should come before file10.pdf
16:29:15 <bitemyapp> usr: it's really not constructive to vaguely refer to things not all participants are firmly grounded in.
16:29:26 <usr> Mh, true.
16:29:42 <bitemyapp> usr: build yourself a better foundation in FP, types, etc. Then you can jump between ecosystems more easily.
16:29:50 <bitemyapp> usr: consider the course I linked. Really.
16:30:43 <usr> bitemyapp: could you re-link it? Still not comfortable with my irc client
16:31:04 <bitemyapp> usr: https://github.com/bitemyapp/learnhaskell
16:31:28 <bitemyapp> usr: I'm always on IRC unless a serious outage occurs. my email can be found via my github account.
16:31:32 <bitemyapp> usr: just ping me if you get stuck or need help.
16:33:08 <Welkin> today's OOP has nothing to do with the original vision for OOP set out by Alan Kay
16:33:20 <bitemyapp> doesn't matter / irrelevant to the conversation
16:33:20 <benzrf> Welkin: java's OOP mauybe
16:33:23 <usr> bitemyapp: ok, sorry, but I feel insulted: why do you assume I need to learn FP? I was under the impression that I knew too much FP to be comfortable *outside* of an FP environment, but now it seems like I don't know FP either, which implies that I know nothing.
16:33:28 <benzrf> Welkin: ruby's OOP is fairly close
16:33:29 <benzrf> :-)
16:33:39 <benzrf> Welkin: i am certainly not a fan of java
16:33:39 <bitemyapp> usr: do you know an FP language or do you know FP?
16:33:40 <usr> bitemyapp: it may be true, but yeah
16:33:41 <benzrf> but i do enjoy ruby
16:33:43 <tac_> OOP is a meaningless word nowadays
16:33:50 <tac_> OOP might as well mean "sufficiently Java-like"
16:34:05 <bitemyapp> usr: if you've read PL papers then you'll build a model that you can translate between languages and understand all of them at once in a more thorough manner.
16:34:11 <benzrf> tac_: java isnt OOP
16:34:14 <rwbarton> FP = "sufficiently Haskell-like"
16:34:15 <usr> I am getting efficient in Haskell, and I really enjoyed reading the SICP (and I code JavaScript as if it was a weird LISP)
16:34:32 <bitemyapp> usr: learning FP properly means learning types properly means learning PL properly means learning programming properly means understanding all languages better incrementally.
16:34:39 <tac_> benzrf: you tell that to someone on the street and they will cock their heads funny at you
16:34:42 <bitemyapp> usr: "getting efficient" isn't what I'm talking about.
16:34:44 <hpc> usr: javascript was originally going to be a scheme implementation, so you're doing it right :D
16:35:03 <bitemyapp> usr: you need to push yourself hard and deep before you're going to yield the kind of understanding I'm talking about.
16:35:14 <dolio> Too bad it's not a scheme implementation.
16:35:22 <bitemyapp> usr: I don't mean cargo-cult authorship of Haskell code that the compiler begrudgingly lets fly, I mean being able to read foundational papers in FP and PL.
16:35:33 <Welkin> bitemyapp, lambda calculus and category theory?
16:35:36 <bitemyapp> usr: here's a good metric, can you read old Wadler papers?
16:35:44 <bitemyapp> usr: if so, you're probably fine.
16:35:52 <benzrf> bitemyapp: link me one, i wanna see if i can
16:35:52 <benzrf> :-O
16:35:53 <bitemyapp> usr: theorems for free is a good target.
16:36:04 <bitemyapp> benzrf: http://ttic.uchicago.edu/~dreyer/course/papers/wadler.pdf
16:36:19 <yogurt_truck> maybe try Wadler and Bird's intro to FP
16:36:19 <usr> bitemyapp: kay I'm gonna read the one you linked but my gut tells me I already read it like 2 years ago
16:36:28 <bitemyapp> usr: ...and did you understand it?
16:36:50 <usr> bitemyapp: that's why I'l have to read it again ; )
16:36:57 <usr> not a bad thing either way!
16:37:26 <bitemyapp> If you can honestly say to yourself that you understand the paper and its implications for PL then you might be fine. Plenty of people benefit from parametricity without understanding it, though.
16:37:40 <bitemyapp> So being able to write Haskell is a metric that measures being able to write Haskell only.
16:37:41 <hcaulfield57> Could someone give me an opinion on which style is more common to the Haskell ecosystem. I'm not trying to start a war, I just see so many styles, but I can't chose one myself. http://lpaste.net/104487
16:38:37 <bitemyapp> hcaulfield57: sum type good, record of strings bad
16:38:42 <bitemyapp> hcaulfield57: derive Show for the sum type
16:38:45 <Enigmagic> hcaulfield57: the first one is probably more common, the second one is better for merging.
16:39:12 <hpc> you see all of those styles rather frequently
16:39:16 <cococo> what's the best way for my haskell program to "sleep" for x seconds? (in Python it's time.sleep())
16:39:19 <usr> To be honest I got a feel for the HM typing style via Scala, but I decided to do more haskell since it generally looks like a much better language, free of the influence of the JVM
16:39:36 <hpc> as well as commas at the end of each line, which is annoying for line manipulations
16:39:39 <bitemyapp> usr: Scala doesn't have anything to do with Damas Milner.
16:39:46 <bitemyapp> usr: Haskell itself is a bit departed from it as well.
16:40:05 <bitemyapp> usr: you seem to be investing in defending the idea that you "know FP" rather than learning.
16:40:11 <bitemyapp> usr: are you sure you don't want to reconsider?
16:40:17 <usr> bitemyapp: true ; )
16:40:43 <usr> bitemyapp: as I said it's frustrating, but it's probably true
16:40:50 <hexagoxel_> cococo: threadDelay
16:40:55 <bitemyapp> usr: do the guide I linked.
16:41:00 <bitemyapp> usr: https://github.com/bitemyapp/learnhaskell
16:41:02 <rwbarton> threadDelay (x * some_huge_power_of_10)
16:41:11 <bitemyapp> usr: stop wasting your time talking to people in IRC. do the guide, grab me if you need help.
16:41:11 <usr> Nah, I'l read the wadler first
16:41:12 <hcaulfield57> hpc: I used to find leading commas bizarre, but it's grown on me, at least for Haskell.
16:41:25 <bitemyapp> usr: can't do that and IRC at the same time.
16:41:29 <hcaulfield57> bitemyapp: The record wasn't a good example, I just meant the way it looked.
16:41:31 <hexagoxel_> microsecs->secs = 10^6
16:41:31 <hpc> i prefer the perl way, which is to allow superfluous trailing commas
16:41:34 <bitemyapp> hcaulfield57: ohhhhh
16:41:40 <hpc> (foo, bar, baz,)
16:41:41 <bitemyapp> hcaulfield57: I prefer leading commas myself.
16:42:04 <hpc> ridiculously convenient as you can arrange your lines to have every element syntactically identical, including both first and last elements
16:42:16 <hcaulfield57> bitemyapp: I do for Haskell, I think it looks odd in C-like languages.
16:43:12 <Welkin> bitemyapp, do you use haskell in your job?
16:43:19 <hcaulfield57> This seems like a good guide
16:43:21 <hcaulfield57> https://github.com/tibbe/haskell-style-guide/blob/master/haskell-style.md
16:43:34 <geekosaur> I've actually taken to using the Haskell leading-commas thing in perl
16:43:44 <hcaulfield57> Enigmagic: Yes, #1 seems more common, I just don't know how I feel about indenting code so much.
16:44:07 <Welkin> hcaulfield57, I just pick up formatting from reading tutorial examples and the source on hoogle
16:44:49 <hcaulfield57> Welkin: Yea, that's what I've been doing too, but kind of torn between what I think is better haha
16:44:51 <Enigmagic> hcaulfield57: i find it terrible, i prefer fixed indents. minimizes code movement when refactoring, merging, etc.
16:45:54 <Enigmagic> hcaulfield57: and helps reduce super wide lines
16:47:24 <roboguy_> geekosaur: that's probably not originally a haskell thing. I first saw it in an sql class
16:47:26 <hcaulfield57> Enigmagic: Yes, it's a little noisy too.
16:47:45 <roboguy_> it does seem especially popular in haskell though
16:48:08 <hcaulfield57> roboguy_: I've seen it in PL/SQL docs too, but it's probably most popular in Haskell from what I've seen.
16:51:03 <hcaulfield57> I think I'm going to do #2, I'm not too keen about all those spaces, but it's not dogma :)
16:51:13 <hcaulfield57> Thanks for the comments
16:51:25 <bitemyapp> hcaulfield57: cheers.
16:58:33 <dreams> bitemyapp: are you Untyped is unsane?
16:58:56 <cococo> What can I do about the Haskell error "Couldn't match expected type `WhosisServer' with actual type `Maybe WhoisServer'?
16:59:11 <tac_> cococo: Just-ify it.
16:59:26 <cococo> _tca: Noob here, can you expand on that?
16:59:49 <Edison18>  You can find funny videos here. http://bitly.com/1kukJH3
17:00:35 <xenomachina> Is this the right place for noob questions?
17:00:36 <bitemyapp> dreams: yep
17:00:53 <fread2282> can I use another class in MINIMAL pragmas?
17:00:55 <fread2282> like so: class Foo a where {foo :: a ; default foo :: Bar a => a; foo = bar {-# MINIMAL foo | Bar #-} }
17:00:57 <fread2282> but ghc wants Bar to be a method of Foo
17:06:11 <roboguy_> cococo: Just :: a -> Maybe a
17:06:57 <roboguy_> oh, you might actually want to go the other way
17:07:56 <roboguy_> in which case, it would probably be most clear to use a case-of. fmap would be another possibility
17:07:59 * hackagebot httpd-shed 0.4.0.2 - A simple web-server with an interact style API  http://hackage.haskell.org/package/httpd-shed-0.4.0.2 (AndyGill)
17:08:01 * hackagebot courier 0.1.0.12 - A message-passing library for simplifying network applications  http://hackage.haskell.org/package/courier-0.1.0.12 (PhilHargett)
17:08:22 <roboguy_> xenomachina: yeah
17:09:01 <cococo> roboguy_: How would you do that with the "getWhois" function? (line 13). http://lpaste.net/195948382412341248
17:09:40 <roboguy_> cococo: case serverFor s of Just whoisServer -> ...; Nothing -> ...
17:10:11 <xenomachina> roboguy_: Thanks. Why isn't it possible to define functions inside ghci?
17:10:21 <roboguy_> xenomachina: it is. you need a "let" before them though
17:10:40 <cococo> > let addOne n = n + 1
17:10:41 <lambdabot>  not an expression: ‘let addOne n = n + 1’
17:10:49 <cococo> something like that...
17:11:43 <cococo> roboguy_: I'm trying to understand your response but I don't understand it at all :/
17:11:59 <frontendloader> Vyndur: you can only see 500fps if you've got your Gunnars on
17:12:15 <Welkin> Gunnars?
17:13:23 <roboguy_> cococo: see if this annotation helps http://lpaste.net/195948382412341248
17:13:35 <benzrf> how can i take a type and convert it to how it would look as a certain synonym?
17:13:48 <cococo> roboguy_: thanks i'll read through that
17:13:58 <roboguy_> benzrf: what do you mean?
17:14:05 <xenomachina> roboguy_: Ah. Ok. LYAH says to put functions in a file and them :l to load them, which seems really inconvenient for trying out small things.
17:14:26 <Welkin> xenomachina, use :r to reload after making changes
17:14:36 <Welkin> there are ways you can automate this too
17:14:43 <cococo> roboguy_: can "resultingWhoisServer" be replaced with anything?
17:14:57 <roboguy_> cococo: yeah, that's just a name (well, "variable")
17:15:02 <cococo> thanks a bunch
17:15:03 <cococo> gtg afk now
17:15:33 <benzrf> roboguy_: i.e. take
17:15:35 <benzrf> wait
17:15:37 <roboguy_> cococo: pattern matching is pretty handy, this might be a good opportunity to read about it
17:15:49 <benzrf> given 'type FlippedFunc a b = b -> a'
17:16:08 <benzrf> how can i take 'Int -> String' and get 'FlippedFunc String Int'
17:16:10 <benzrf> textually, i mean
17:16:58 <roboguy_> benzrf: hmm, that sounds like it could be pretty complex
17:17:19 <benzrf> well, i know that i want a FlippedFunc
17:17:36 <benzrf> basically i want pattern matching on types :u
17:17:44 <xenomachina> Another question: what does "No instance for (Num Char) arising from the literal `5'" mean, in general? I know the error in my particular case (putting 5 in a list of Chars) but I would not have been able to figure that out from that error message.
17:18:16 <rwbarton> benzrf: textually? is this a parsing question?
17:18:55 <roboguy_> xenomachina: numeric literals are polymorphic in Haskell. this means that they can be any of several different types depending on how they are used. For instance, 1 could be a Float, an Int, etc. This is represented in types as a "type class". so we have:
17:18:58 <roboguy_> :t 1
17:19:00 <lambdabot> Num a => a
17:19:05 <rwbarton> xenomachina: it's one of the more infamous Haskell error messages
17:19:24 <roboguy_> xenomachina: this means that the type of 1 can be any "instance" of the Num type class (such as Int, etc)
17:19:33 <Welkin> :t '5'
17:19:35 <fread2282> > class Foo a where {foo :: a ; default foo :: Bar a => a; foo = bar; {-# MINIMAL foo | Bar #-} }
17:19:43 <LordBrain> xenomachina, I'm not sure i understand you... It seems clear unless you are new to haskell or something. Num is a type class, and there is no instance for Char,  It sees your list as  Num a => [a] because you put a 5 in and 5 has type Num a => a
17:19:44 <lambdabot> Char
17:19:44 <lambdabot>  <hint>:1:1: parse error on input ‘class’
17:20:25 <benzrf> rwbarton: i mean how do i get ghci to show me it -.-
17:20:38 <rwbarton> ah
17:20:39 <roboguy_> benzrf: I really doubt that's possible. that would be kind of nice for lens though
17:20:57 <rwbarton> yeah
17:21:25 <benzrf> roboguy_: what do you think i want it for"
17:21:27 <benzrf> =p
17:21:36 <roboguy_> benzrf: haha I had a feeling
17:21:47 <LordBrain> xenomachina, if you put a type signature on the list that it is supposed to be [Char], it would give you a different error.
17:22:32 <rwbarton> you'd still get a "No instance for (Num Char)" error
17:22:42 <LordBrain> xenomachina, the maybe strange thing to a newcomer to haskell is that the numeric literals are polymorphic.
17:22:56 <roboguy_> benzrf: you could write a program to do it, but I doubt anything exists already
17:23:00 <benzrf> man!
17:23:19 <roboguy_> benzrf: :i can help sometimes though
17:23:21 <LordBrain> ah, yes, you would, i spoke faster than i thought rwbarton
17:23:22 <benzrf> ik
17:23:22 <rwbarton> xenomachina: in practice you can read an error "No instance for (Num T)" as "Expected some numeric type, but the actual type was T instead"
17:23:25 <benzrf> idea
17:23:46 <benzrf> maybe i could do a simple transformation that defines ADTs for the types in the result
17:23:52 <benzrf> then pattern matches it out :o)
17:26:44 <LordBrain> xenomachina, if it knew the list is [Char], then it would try to satisfy both Num a and a ~ Char, where a is the type of 5 (which is a polymorphic literal)
17:27:05 <xenomachina> LordBrain: I am new. Yes, the polymorphic aspect of that is kind of strange to me. I also don't understand the usage of the word "instance" in this case.
17:27:08 <LordBrain> really it tries to statisfy that regardless of the order of type inference
17:27:51 <LordBrain> xenomachina, types can belong to type classes, if a type belongs to a particular type class it is called an instance of that type class.
17:28:03 <dwcook> xenomachina: a typeclass instance is a definition that says how some type or types are a part of some typeclass.
17:29:23 <dwcook> xenomachina: try reading this http://www.haskell.org/tutorial/classes.html
17:29:24 <LordBrain> xenomachina, basically anyone can write an instance for a defined type class, you just have to implement certain methods which would be the minimal complete definition for the class.
17:30:30 <dwcook> That's a convention – The compiler won't necessarily complain if you don't hit the minimal complete subset. But at runtime you might run into errors.
17:30:37 <xenomachina> So would it be correct to say Int is an instance of Num?
17:30:42 <dwcook> xenomachina: yes.
17:31:34 <fizbin> Though I'd say rather that "there is a Num instance for Int"
17:31:51 <xenomachina> So why doesn't it say "Char is not an instance of Num", rather than "No instance for (Num Char)"?
17:32:29 <fizbin> ... because what I say is more in line with what the compiler says.
17:32:37 <roboguy_> xenomachina: you can have multiparameter type classes
17:32:38 <dwcook> xenomachina: from the compiler's perspective, it has to find what instances are in scope. There are multiple possible instances for some types, as well.
17:32:46 <xenomachina> fizbin: wait, are you saying there can be more than one Num instance for a given type?
17:33:18 <dwcook> xenomachina: one reasonably well known case of multiple possible instances is Applicative [].
17:33:24 <fizbin> xenomachina: There can be, though you can only have one in scope at a time.
17:33:27 <roboguy_> xenomachina: sometimes there are multiple possible instances, but only one instance can exist for any type
17:33:46 <dwcook> On the one hand you have the "canonical" instance Applicative [], and then you have instance Applicative ZipList to cover the other one. ZipList is just a newtype of [].
17:33:48 <LordBrain> xenomachina, it is convenient that literals be polymorphic, xenomachina historically, type classes were invented specifically for this purpose, making the numeric operations polymorphic, so we can write things like 5 + 2, where the underlying implementations of the numbers and operations are not of concern really.  It keeps things pretty too, as other languages have things like +. which is a different operator than +, etc.
17:35:08 <sewa> Hello!, i was installing pandoc with (cabal install pandoc), i've installed as root, so my bin files are at /root/.cabal/bin, is there a way to safely move all the files to /usr/bin without reinstall everything?, thanks in advance!
17:35:12 <LordBrain> or for example in c, you have to specify 4.0 instead of 4, when you mean a floating type, and then you have to decorate it some more to specify non-default float types, etc.
17:35:53 <benzrf> is RWS just an rws stack or is there something different about it
17:36:06 <xenomachina> Yeah, I understand why they're polymorphic. The error message just seems very strangely worded. Part of this may stem from my inability to mentally parse Haskell.
17:36:24 <LordBrain> xenomachina, although that is the original motivation for type classes... they've become huge infecting everything in haskell really.
17:37:17 <dwcook> xenomachina: "Foo is an instance of Bar" is something we often say coloquially but it's an approximation of the actual language semantics.
17:37:47 <enthropy> benzrf: RWS r w s a is just a faster way to write ReaderT r (WriterT w (State s)) a
17:37:48 <roboguy_> it would be hard to have a general error message like "Int isn't an instance of Num" because of multiparameter type classes. So you might have a type class Foo with an instance that looks like "Foo Int Char"
17:37:59 <roboguy_> if Foo takes two parameters
17:38:30 <benzrf> enthropy: kk
17:39:07 <LordBrain> xenomachina, type classes are not as powerful as c++ templates, but they are similar in a way that they are the haskell way to write algorithms for types that may not even exist yet, etc.
17:39:28 <benzrf> enthropy: does that mean that to manually write a function to bind without using lift etc you'd need to write, like
17:39:51 <xenomachina> LordBrain: Yes, I know. I've read a bunch of random stuff about Haskell, and know typeclasses are used for monads and equality among other things. I still don't quite get how they work.
17:40:31 <xenomachina> I think I have other more basic stuff to learn before I can really grok typeclasses, however.
17:40:58 <benzrf> bindFunc a state env = (("write", v), "newstate)
17:40:59 <roboguy_> it's kind of like a logic programming predicate. Num a => ... means if 'a' satisfies Num, then the rest of the type signature (can) type check
17:40:59 <benzrf> or something
17:41:02 <LordBrain> xenomachina, do you do c++, they are kind of like virtual classes that provide interfaces
17:41:30 <sewa> Hello!, i was installing pandoc with (cabal install pandoc), i've installed as root, so my bin files are at /root/.cabal/bin, is there a way to safely move all the files to /usr/bin without reinstall everything?, thanks in advance!
17:41:57 <dwcook> LordBrain: would you mind explaining to me in #haskell-blah in what sense C++ templates are more powerful than Haskell typeclasses?
17:42:22 <roboguy_> dwcook: you can do any arbitrary compile time computations with C++ templates since they are Turing complete
17:42:37 <dwcook> Ah, fun stuff
17:42:44 <roboguy_> very ugly though
17:42:56 <dwcook> Yeah, I said "fun stuff" facetiously :P
17:43:16 <enthropy> you get the same with -XUndecidableInstances
17:44:05 <LordBrain> dwcook, there is a trade off, but technically c++ templates are 'more powerful' in the sense that they constitute a Turing complete language. You can can express programs which never terminate, for example. :)
17:44:13 <xenomachina> LordBrain: do you mean virtual methods in classes?
17:44:23 <LordBrain> xenomachina, yes
17:45:09 <xenomachina> LordBrain: I know typeclass methods are similar to class methods in other languages, but my understanding is that they are different enough that assuming they are the same can get you in trouble.
17:45:44 <benzrf> xenomachina: typeclasses are quite simple
17:45:50 <xenomachina> I also don't quite get where Haskell figures out which vtable it's supposed to be passing around.
17:45:57 <benzrf> they are just multiple-dispatch based on a particular set of arguments
17:46:03 <sewa> can i move safely /root/.cabal/ to /usr?
17:46:13 <benzrf> sewa: /usr/cabal?
17:46:36 <sewa> nope /usr/bin..
17:46:42 <sewa> .cabal contents i mean
17:46:43 <sewa> sorry
17:46:57 <sewa> i0ve installed pandoc entire as root (my fault)
17:49:54 <sedeki> hello all
17:50:05 <sedeki> how do I quit the interpreter?
17:50:11 <sm> :q
17:50:20 <sedeki> thanks
17:50:54 <LordBrain> xenomachina, the methods aren't attached to objects, if you use a method defined in a type class, haskell assumes that there should be an instance of that class for whatever type you used it on.  The instance would i suppose be the answer to the vtable question.
17:51:48 <xenomachina> benzrf: perhaps they are simple once you understand them, but I do not yet. I get that there's a vtable that's passed around, but I don't know where it comes from.
17:51:54 <ReinH> xenomachina: typeclasses are really just a way of sharing the same identifier for functions across multiple types
17:52:09 <benzrf> xenomachina: ignore vtables
17:54:10 <LordBrain> xenomachina, all methods will have a type signature with a constraint, ClassName a => ... where the type variable a occurs somewhere in the type of the method.. the constraint means a is any type which has an instance of ClassName defined.
17:54:14 <sewa> can i move safely /root/.cabal/{bin,lib,share} to /usr?
17:54:32 <geekosaur> sewa: no
17:54:41 <dwcook> sedeki: Ctrl+D while you've typed nothing on the current line is a virtually ubiquitous means of exiting a shell
17:54:50 <roboguy_> sewa: why would you want to? usually that stays in a .cabal directory
17:54:58 <dwcook> At least in Linux
17:54:59 <roboguy_> usually it's in ~/.cabal
17:55:18 <geekosaur> at the very least you would need to edit all the files in package.conf.d and then `ghc-pkg recache`. but there's no shortcut way to turn mis-installed user packages into global packages
17:55:34 <carter> sewa: you don't wanna run cabal in ROOT
17:55:44 <carter> you'll get sad
17:55:46 <sewa> learned the hardway
17:55:48 <sewa> =8
17:55:49 <xenomachina> LordBrain: I think the "for whatever type you used it on" is the bit tripping me up. I can't figure out how Haskell knows what types things can be, since typeclasses look at return types not just argument types.
17:56:00 <enthropy> cabal listens to some environment variables for where to find the stuff in share
17:56:03 <sewa> so what can i do, simply remove .config? then install pandoc as user?
17:56:17 <carter> sewa: first reinstall GHC
17:56:18 <LordBrain> xenomachina, haskell uses an algorithm to infer types, that's why you don't have to always specify them, and if you use a method from a class, you're telling the type inference engine that the type of a should be one which has an instance for ClassName.
17:56:28 <carter> as user
17:56:33 <carter> then invoke cabal install pandoc as user
17:56:44 <sewa> ahh ok
17:56:46 <carter> then have ~/.cabal/bin in your path
17:56:48 <sewa> thank you very much
17:56:50 <carter> soke
17:56:58 <carter> just do a reinstall
17:57:07 <carter> adjust your path
17:57:12 <carter> and move on in life :)
17:57:13 <LordBrain> xenomachina, it is the fact that type inference is happening it sounds like that is what is your hangup i think, not type classes.
17:57:28 <benzrf> xenomachina: it's fairly simple
17:57:30 <benzrf> let me show you:
17:57:38 <carter> xenomachina: the abstraction in haskell allow infromatino to Flow from and to use sites
17:57:47 <carter> so that its more like the oeprations canb e generic
17:57:49 <benzrf> class Foo f where wut :: a -> f
17:57:51 <carter> in different ways
17:57:57 <xenomachina> If I say "return 5" how does it know which instance of Monad to use?
17:58:06 <carter> xenomachina: flows from context
17:58:16 <benzrf> xenomachina: in this case, dispatch happens on the return type *because f is the argument to the typeclass declaration*
17:58:20 <carter> or it might be a polymorophic value
17:58:32 <carter> Monad m, Num n => m n
17:58:38 <carter> :t return 7
17:58:39 <lambdabot> (Num a, Monad m) => m a
17:58:41 <carter> see :)
17:58:42 <roboguy_> xenomachina: it's polymorphic in the way that the literal 5 is polymorphic
17:58:49 <carter> lambdabot agrees
17:58:50 <xenomachina> benzrf: what's f?
17:58:56 <carter> a bad example :)
17:58:59 <benzrf> notice i said 'class Foo f'
17:59:03 <carter> :t fmap
17:59:04 <lambdabot> Functor f => (a -> b) -> f a -> f b
17:59:06 <carter> is a better example
17:59:09 <carter> of a useful f
17:59:12 <benzrf> that binds the letter 'f' to 'whatever type is going to instance the class'
17:59:16 <benzrf> within the where
17:59:16 <LordBrain> xenomachina, technically, it doesn't necessarily know, but when it does it comes from the context as carter says.  If you turn on a lot of the wrong extensions the type inference might get weaker and there will be more instances where you have to put an explicit type signature in the code.
18:00:07 <carter> LordBrain: i turn on lots of right extentions :)
18:00:31 <carter> xenomachina: you're getting a lot of new information
18:00:31 <LordBrain> yeah, but i learn what is right and wrong from experience
18:00:35 <carter> and its a different style of htinking
18:00:40 <carter> but its a powerful one
18:00:49 <LordBrain> and i imagine others learn like me.. .but maybe that is myopic
18:00:54 <carter> xenomachina: for example, i try to write code so generic, I can forget how i implemented it :)
18:01:47 <xenomachina> LordBrain: I get type inference, though I find the "both directions" inference Haskell uses to be extremely hard to read, as a human. In (most) other languages I can start from the subexpressions and work my way out. It seems that Haskell expects you to understand the entire expression in one gulp.
18:02:08 <carter> no
18:02:12 <carter> its even better than that
18:02:21 <tac_> xenomachina: agreed
18:02:29 <carter> in most languages you *can't* work bottom up
18:02:34 <tac_> Hindley Milner is a curse.
18:02:38 <carter> you can totally work subexpression up
18:02:50 <tac_> It says "even a machine could figure this out". And the consequence is that you, as a person, now have to as well.
18:02:55 <LordBrain> what?
18:02:56 <roboguy_> tac_: HM doesn't have type classes does it?
18:03:07 <carter> yeah, it dont
18:03:08 <LordBrain> oh
18:03:09 <LordBrain> hahaha
18:03:20 <sewa> well gotta go thanks for the help carter and benzrf
18:03:31 <carter> sewa: where should i send my bill? :)
18:03:35 <carter> happy hacking
18:03:43 <sewa> u accept paypal? lol
18:03:46 <sewa> best regards!
18:03:48 <carter> thankee
18:03:58 <tac_> roboguy_: no. Typeclasses make it worse. Now you also have to do prolog in your head >___>
18:04:21 <c_wraith> tac_: only if you enable extensions
18:04:34 <benzrf> selator: i accept paypal yes
18:05:19 <carter> i prefer wire / bank transfer personally
18:05:29 <carter> benzrf: autocmplete trolled yah
18:05:33 <LordBrain> i think type inference is really nice personally...
18:05:42 <tac_> c_wraith: I hope you're not suggesting people write Haskell 2010 :P
18:06:03 <c_wraith> tac_: I... have.  Once or twice.
18:06:33 <LordBrain> it indeed does have the effect that on occasion you have to do prolog in your head
18:06:54 <carter> LordBrain: but you can usually choose a lib that doesn't have that style
18:06:58 <roboguy_> I find that thinking of type classes as predicates/type relations is pretty handy
18:07:10 <dwcook> roboguy_: that's what they mean by doing Prolog in your head
18:07:17 <roboguy_> dwcook: I know
18:07:26 <LordBrain> but i feel the boons are worth it, personally.  I tried idris for a while, but writing every type is painful because i am spoiled.
18:07:49 <dwcook> LordBrain: Surely Idris has some form of type inference
18:08:00 <carter> LordBrain: inference is magic
18:08:16 <roboguy_> dwcook: I hear it's weaker because of the dependent types
18:08:22 <roboguy_> (the inference that is)
18:08:26 <carter> well
18:08:48 <LordBrain> dwcook, Well... i guess, but it seems to me, idris tries to infer code from types, rather than the other way around.
18:08:49 <enthropy> in haskell type signatures in classes and instances don't get inferred
18:09:38 <roboguy_> LordBrain: hmm, that sounds ok to me
18:10:01 <xenomachina> Wouldn't you get 99% of the benefits of type inference with far less mental Prolog if it only went from the leaves of the expression tree upwards?
18:10:02 <LordBrain> roboguy_, it is definitely cool, but also tiresome when you are used to haskell power
18:10:21 <roboguy_> xenomachina: what do you mean?
18:10:48 <LordBrain> roboguy_, i think the ideal is actually something of a presently nonexistent blend of the approaches.
18:10:57 <carter> xenomachina: type inference works both ways
18:11:42 <xenomachina> carter: it does in Haskell, but I'm wondering why.
18:11:45 <roboguy_> LordBrain: well it kind of seems like haskell gets closer to the idris kind of stuff as time goes on
18:11:59 <carter> because its strong faster nicer friendlier more hlepful
18:12:05 <enthropy> xenomachina: would you like to use returnIO instead of return?
18:12:05 <carter> xenomachina: what type ifnerence have you seen before?
18:12:25 <tac_> Does anyone know a good paper on bidirectional type checking?
18:12:25 <benzrf> carter: might it be described as harder better faster stronger?
18:12:46 <carter> nah, easier, loving, alluring, DARK SIDE OF AWESOME
18:13:03 <carter> tac_: bidirectional type checking has a VERY SPECIFIC meaning
18:13:28 <tac_> carter: as I hope any technical words I use would have >_>
18:13:52 <tac_> I believe I have used the correct ones here
18:13:53 <xenomachina> roboguy_: I mean that in Haskell the type of a subexpression can depend on the context its embedded within. Something up at the root of the expression tree can change the inferred type of the leaves.
18:13:59 <carter> xenomachina: no
18:14:12 <carter> xenomachina: my i explain?
18:14:14 <xenomachina> enthropy: I probably wood.
18:14:20 <carter> *may
18:14:33 <carter> xenomachina: which is more generic
18:14:37 <carter> :t return "helllo"
18:14:39 <carter> or
18:14:40 <lambdabot> Monad m => m [Char]
18:14:50 <roboguy_> xenomachina: what about (at least) two sets of math operations depending on if you're adding Ints, Floats etc?
18:14:50 <carter> :t (return "hello" ) :: IO String
18:14:53 <lambdabot> IO String
18:15:01 <carter> which is more generic?
18:15:17 <carter> which can i substitute for the other?
18:16:29 <cococo> Can anyone ( roboguy_ ? ) review line 15? (Getting a "Couldn't match type `()' with `Maybe String'" error)
18:16:47 <roboguy_> cococo: of what?
18:17:07 <carter> xenomachina: which is more generic?
18:17:16 <cococo> roboguy_: lol sorry, link here: http://lpaste.net/4305754943882526720
18:17:20 <xenomachina> roboguy_: I don't see why inference from the return type is necessary there. You add two Ints you get an Int. You add two Floats you get a Float. The output depends on the inputs.
18:17:32 <carter> xenomachina: .... thats how haskell works
18:17:34 <carter> bottom up
18:17:39 <carter> what do you consider top down
18:17:47 <carter> give me a concrete code example
18:17:51 <Twey> xenomachina: Oho, but what if you're adding two (Num a ⇒ a)s?
18:18:47 <roboguy_> cococo: well, to start with, *always* give type signatures to top level definitions. errors can be crazy hard if you don't
18:19:05 <roboguy_> (this includes main by the way. I've run into some interesting problems)
18:19:37 <carter> because they become nonlocal
18:19:38 <Twey> tac_: I think http://itu.dk/people/drc/tutorials/bidirectional.pdf gives a nice introduction
18:19:45 <tac_> thanks
18:20:13 <roboguy_> cococo: ok, so there are two options: 1) throw an error in getWhois if you can't get the whois info 2) use Either or Maybe to represent an error in the return value of getWhois
18:20:20 <roboguy_> it's more idiomatic to do 2
18:20:27 <roboguy_> then give an error message in main
18:20:43 <joelteon> I forget how to make cabal build the Paths_ module
18:20:49 <joelteon> is it data-files?
18:22:27 <xenomachina> Twey: I think that's putting the cart before the horse. I don't know if you could have "Num a" the way Haskell defines it without top-down inference.
18:22:56 <Twey> xenomachina: You can have it without inference at all!
18:23:09 <Twey> Nothing's stopping you explicitly annotating it everywhere.
18:23:12 <LordBrain> xenomachina, it's the same use case for making your template functions in c++, for example, you might want to write code once, a sort function say, the algorithm doesn't say what is the types here it just needs that they be able to be compared, so you make some template compare function, and then a template sort function, and boom it works on any type for which instantiates the template.
18:23:39 <cococo> roboguy_: I replaced "print" with "error" and it works
18:23:40 <joelteon> does cabal repl not build the paths module?
18:23:40 <carter> xenomachina: no, thats bottom up
18:24:13 <roboguy_> cococo: well, that's definitely the dangerous, non-idiomatic way but it does (maybe) work
18:24:16 <xenomachina> Twey: that doesn't help with reading other people's code
18:24:36 <Twey> xenomachina: No, it's absolutely horrible ;)  But it can be done.
18:24:39 <roboguy_> xenomachina: you can always ask the compiler (in ghci for instance)
18:24:47 <cococo> roboguy_: what's bad about it? Also, can I have multiple lines with "Just serv"?
18:25:01 <carter> the secret is you can always ask ghc the type :t
18:25:02 <cococo> roboguy_: I mean like can I print "serv" and THEN do what I'm already doing?
18:25:03 <roboguy_> cococo: it means that getWhois is partial
18:25:05 <carter> :type 7
18:25:14 <carter> :t 7
18:25:15 <lambdabot> Num a => a
18:25:16 <roboguy_> cococo: not in that way. you can use do though
18:25:38 <roboguy_> cococo: all Just serv does is extract "serv" from the Just value (if it gets a Just value)
18:25:40 <carter> :t "all the things" ++ " everythign else"
18:25:42 <lambdabot> [Char]
18:25:49 <carter> :t mappend
18:25:52 <lambdabot> Monoid a => a -> a -> a
18:26:00 <carter> :t "all the things" `mappend`" everythign else"
18:26:01 <lambdabot> [Char]
18:26:07 <carter> > "all the things" `mappend`" everythign else"
18:26:09 <lambdabot>  "all the things everythign else"
18:26:23 <carter> xenomachina: try out some lambdabot examples
18:26:31 <carter> armchair is a hard way to learn :)
18:26:31 <roboguy_> cococo: ideally, functions shouldn't give errors like that. They should return a Maybe value or an Either value to represent the error state so that the calling function can handle it
18:26:35 <cococo> roboguy_: so could I assign a variable (or whatever you call variable-like functions) to serv?
18:26:45 <roboguy_> cococo: serv is a variable
18:26:53 <roboguy_> well, it doesn't vary, but you know what I mean
18:26:55 <xenomachina> LordBrain: can you give me an example of C++ where the type of a subexpression changes based on the expression it is embedded within?
18:27:09 <carter> xenomachina: ..... thats not how haskell works
18:27:27 <carter> xenomachina: you can always substittue a more general program when a specific one is expected
18:27:31 <cococo> roboguy_: but I couldn't access it outside of case, meaning my function can't continue further down?
18:27:31 <carter> True or False
18:27:50 <roboguy_> cococo: that's not really how haskell works. you can put a do block inside the case branch though
18:27:59 <roboguy_> and do multiple things that way
18:28:34 <cococo> roboguy_: Alright, I guess I still don't understand the functional mindset yet, but I don't see how I could do much _without_ using do after the arrow
18:28:38 <xenomachina> carter: what is not how Haskell works?
18:28:47 <carter> xenomachina: answer my specific question
18:28:52 <carter> i'm wearing my pedagogy hat
18:28:57 <roboguy_> cococo: you can do all kinds of things, but it will be hard to see that until you have more experience
18:29:00 <LordBrain> xenomachina, what's the type of printArray here? http://www.deitel.com/articles/cplusplus_tutorials/20060428/
18:29:05 <cococo> roboguy_: sry gtg afk (busy day), but I'll check any pings when i get pack
18:29:08 <cococo> *back
18:29:14 <carter> xenomachina: also can you give me an example ouf that "top down in haskell"
18:29:16 <carter> example?
18:29:23 <carter> because i can't figure out what you mean
18:29:29 <carter> and i .... write A LOT of haskel
18:29:33 <carter> *haskell
18:30:03 <LordBrain> xenomachina, actually, more to your point, suppose the template parameter is used in the return value of the function
18:30:14 <xenomachina> carter: which question?
18:30:40 <carter> xenomachina: generic vers specific programs
18:30:44 <roboguy_> carter: well this discussion was sparked by an error message from something like '3' + 5, so it's probably related to that
18:30:52 <carter> oh
18:30:57 <carter> thats just ..... wrong
18:31:06 <carter> not top down vs bottom up
18:31:17 <roboguy_> carter: we were talking about how the error message can be confusing at first
18:31:22 <carter> oh
18:31:26 <LordBrain> xenomachina, see the code in this SO question, http://stackoverflow.com/questions/15864928/c-template-return-value
18:31:26 <roboguy_> > '3' + 5
18:31:27 <lambdabot>  No instance for (GHC.Num.Num GHC.Types.Char)
18:31:27 <lambdabot>    arising from a use of ‘GHC.Num.+’
18:31:33 <xenomachina> Ugh. I have to go now, but in the C++ case I'm fairly certain that the type parameter must be explicit if it can't be inferred from the function's parameters (not return type).
18:32:23 <bms1> xenomachina: In Haskell, every expression has a "principal type" - a unique most general type that can be used for it
18:32:41 <carter> close enough to true
18:32:52 <carter> at least when you don't use the fancy stuff thats off by default
18:32:56 <bms1> carter: without RankNTypes or GADTS, happy?
18:32:58 <bms1> :)
18:33:02 <carter> :)
18:33:13 * carter salutes you and leaves you to your important work
18:35:10 <bms1> And so you do type inference from bottom up - the base pieces have obvious principal types, and then you use the principal types of the subexpressions to compute the principal type of the whole
18:38:04 <fread2282> @src ($)
18:38:04 <lambdabot> f $ x = f x
18:39:23 <roboguy_> fread2282: the main use of $ has to do with its fixity level of 0 (which unfortunately, lambdabot doesn't tell us)
18:39:34 <roboguy_> lambdabot really needs :i
18:45:34 <fread2282> is there a lens-based abstraction that is to monad as traversal is to traversable?
18:46:07 <fread2282> (or as traversal is to functor)
18:46:29 <napping> not in lens. Maybe ask in #haskell-lens?
18:46:54 <napping> edwardk hasn't seen any reasonable proposals for laws for lenses with monadic actions
18:48:08 <roboguy_> fread2282: you mean as traversal is to applicative?
18:48:35 <roboguy_> with something like forall m. Monad m => (a -> m b) -> s -> m t
18:48:40 <fread2282> roboguy_: no
18:49:39 <fread2282> but i don't what i was looking for is sensible
18:51:30 <roboguy_> fread2282: is this for something specific or just curiosity?
18:53:04 <fread2282> roboguy_: mostly curiosity of "how much can I generalize the prelude"
18:53:43 <roboguy_> fread2282: have you seen classy prelude?
18:53:51 <fread2282> roboguy_: yes
18:59:57 <LordBrain> i have an example for xenomachina to look at if he is still here.
19:01:09 <fread2282> can fail in RebindableSyntax have a (String -> a) sig or does it need a (String -> m a) one?
19:02:02 <roboguy_> fread2282: that seems like it could be dangerous
19:02:45 <napping> I don't think there are any type restrictions with RebindableSyntax
19:03:00 <napping> just as long as the desugaring typechecks with your functions
19:03:48 <roboguy_> I don't think parametricity would exist if you had a function String -> a
19:04:37 <napping> fail shouldn't be forall a . String -> a
19:04:52 <monochrom> perhaps it is not "a" but rather "MyType"
19:04:56 <napping> (I suppose it could be), but any type String -> ... should work
19:04:58 <roboguy_> that seems more like error
19:05:02 <napping> and even more if you have OverloadedStrings
19:12:32 <fread2282> roboguy_: using just a -> String seems to give strange error messages sometines but works fine
19:13:03 <napping> you can do pretty strange things with RebindableSyntax
19:13:07 <fread2282> or rather String -> a
19:16:06 <roboguy_> fread2282: why do you want that over error?
19:16:57 <benzrf> rebindablesyntax?
19:17:15 <roboguy_> benzrf: it let's you change how do works iirc
19:17:35 <jle`> it uses whatever (>>=) is in scope when it desguars do
19:17:42 <jle`> and fail too, apparently
19:17:46 <benzrf> o that one
19:18:16 <jle`> if you define a new (>>=) in the middle of a do block, it'll switch to the new one
19:18:20 <jle`> fun times
19:18:24 <benzrf> ooooooooh
19:18:31 <benzrf> now that's cute
19:18:39 <roboguy_> jle`: I've always wanted to try redefining >>= on every (or almost every) step and seeing what I can do
19:18:45 <benzrf> dang
19:18:57 <fread2282> roboguy_: huh?
19:19:21 <jle`> pun intended, roboguy_ ?
19:19:29 <roboguy_> jle`: haha yeah
19:19:58 <fread2282> roboguy_: because I'm redefining Monad
19:20:14 <roboguy_> fread2282: like do (>>=) <- return ...; (>>=) <- return ...; ...
19:20:21 <roboguy_> oh
19:20:44 <fread2282> roboguy_: answering your question from a few mins ago
19:21:16 <roboguy_> fread2282: well, what does fail :: String -> a give you? it has to be an error right?
19:22:44 <fread2282> roboguy_: fail "foo" :: Maybe Bool
19:23:06 <roboguy_> fread2282: but you were talking about giving fail the type String -> a though, weren't you?
19:23:52 <fread2282> roboguy_: yep, probably best to just go with String -> m a
19:26:20 <jle`> roboguy_: x <- return y is let x = y, btw
19:26:39 <roboguy_> jle`: yeah, but I wasn't sure if do still puts >> between the lets
19:27:25 <jle`> i don't think it does...it goes into the body of the lambda
19:27:30 <xenomachina> LordBrain: I am temporarily back. I don't see what you were getting at with that SO question.
19:27:57 <jle`> @undo do { a <- f; let x = y; b <- h; z }
19:27:57 <lambdabot> <unknown>.hs: 1: 27:Parse error: <-
19:28:15 <jle`> @undo do { a <- f; let {x = y}; b <- h; z }
19:28:15 <lambdabot> f >>= \ a -> let { x = y} in h >>= \ b -> z
19:28:41 <roboguy_> yeah, that's why I didn't do it that way. the new >>= bindings wouldn't do anything
19:29:23 <LordBrain> xenomachina, i was able to make an example somewhat equivalent in c++, but i wrote to the parameter type using a reference instead of making it the return type of the method.  c++ doesn't allow overloading based on return types, but that's a separate rule actually than the template foo. Some languages do allow such overloading.
19:30:55 <LordBrain> xenomachina, so with a tweak it would infer types from context, see http://stackoverflow.com/questions/442026/function-overloading-by-return-type
19:31:39 <xenomachina> bms1: but when you get to the top it seems you need you go back down to figure out the "real" type. For example, the real type of "return'x'" might be Maybe Char or IO Char or something else. "return 5" is even worse 'cause you know neither what kind of Monad it is nor what kind of Num it is.
19:32:43 <xenomachina> LordBrain: so you're saying Haskell has overloading by return type?
19:32:48 <LordBrain> yes
19:33:11 <bms1> xenomachina: Yeah, I agree
19:33:16 * hackagebot javav 0.1.0 - A utility to print the target version of Java class files.  http://hackage.haskell.org/package/javav-0.1.0 (TonyMorris)
19:33:33 <xenomachina> LordBrain: http://stackoverflow.com/questions/11420126/does-haskell-have-return-type-overloading
19:35:38 <roboguy_> xenomachina: the calling function decides what type it is. this is the same as when the polymorphism isn't in the return type
19:35:43 <bms1> xenomachina: Yeah, for typeclasses, once you have figured out the typeclasses in a bottom-up fashion, you then go through the code top-down and insert the appropriate typeclass dictionaries
19:37:46 <roboguy_> xenomachina: it actually isn't as hard to get used to as you might think, in my experience
19:37:57 <LordBrain> xenomachina, the responses did not give a clear cut "no" to that question.  I agree with the asker, the implementation details about having implicit dictionary parameters seem irrelevant to me, but there is some semantic ambiguity i suppose in what "return type overloading" means.
19:38:16 * hackagebot javav 0.1.1 - A utility to print the target version of Java class files.  http://hackage.haskell.org/package/javav-0.1.1 (TonyMorris)
19:39:18 <LordBrain> so some people would consider that technically haskell doesn't have it, due to some such detail that i personally consider irrelevant and confusing. I agree with the "yes" crowd, and so stand by my statement.
19:40:46 <roboguy_> xenomachina: I'd say return 5 is even *better*, because of how general it is. You can actually have proofs that *must* hold for certain types just because of how general they are
19:41:43 <roboguy_> *theorems
19:41:44 <saml_> your Monad instance doesn't have to obey monadic law
19:42:13 <saml_> but that kind of bugs can be easy to find
19:42:25 <roboguy_> saml_: that's not what I mean though
19:42:31 <saml_> by writing proofs
19:42:38 <saml_> which is same as writing programs lols
19:42:43 <LordBrain> on occasion it can be useful to have a non monad monad instance tho
19:42:58 <LordBrain> in truth
19:43:17 * hackagebot vty-ui 1.7 - An interactive terminal user interface library for Vty  http://hackage.haskell.org/package/vty-ui-1.7 (JonathanDaugherty)
19:43:23 <LordBrain> annoying infelicity tho
19:43:36 <saml_> so haskell is completely broken
19:43:54 <saml_> it just gives you false sense of safety
19:43:55 <roboguy_> I meant parametricity
19:45:22 <LordBrain> well, saml , the useful examples that i had in mind are sort of contingent monads... like using a monad transformer that actually might violate monad laws if the inner monad is not commutative.
19:46:24 <LordBrain> i think its been known for a while that the very abstraction of monad is not actually general enough.. hence arrows and categories and applicative functors and etc...
19:47:11 <ReinH> Has anyone mentioned Wadler's original paper on typeclasses to xenomachina? http://homepages.inf.ed.ac.uk/wadler/topics/type-classes.html
19:47:28 <roboguy_> well, applicative is less general (in the sense that it is less powerful). arrows always felt weird to me, but maybe I haven't seen a good use case yet
19:48:13 <ReinH> roboguy_: I've never found Arrow that useful either. It always struck me as the wrong abstraction.
19:49:05 <roboguy_> I reimplemented most of Arrow with edwardk libraries. I wonder if that is a good idea or not though
19:49:38 <ReinH> saml_: I suppose you can say that, but for me a value of Haskell is that it lets me get closer to the programs <=> algebras equivalence than anything else I have to work with
19:49:43 <LordBrain> i think similar to roboguy_ on that one, i kind of wonder if arrow isn't completely obsoleted by lens... but others say i just don't get arrow...
19:49:54 <ReinH> So yes, Haskell is the most completely broken language aside from all the other languages.
19:49:56 <roboguy_> arrow reimplemented -> http://lpaste.net/100875
19:50:05 <ReinH> roboguy_: interesting
19:51:45 <LordBrain> i'm surprised there is so much haskell bashing in here lately
19:52:13 <ReinH> It comes and goes
19:53:22 <roboguy_> I thought about doing that for a while, but I really started when someone asked if you could write arr for Category
19:53:51 <LordBrain> i agree with that ReinH, something is better out there, and we should continue to try to fix our current broken thing... but haskell at least hints at what that ideal would be, more so than any other language i know...
19:54:46 <Cale> LordBrain: What Haskell-bashing are you referring to?
19:54:51 <ReinH> "write arr for Category"?
19:55:40 <roboguy_> ReinH: the question was could you have something like arr :: (Category p) => (a -> b) -> p a b
19:55:54 <roboguy_> and if you couldn't, what would you need so that you could
19:56:22 <ReinH> Um, are they literally asking if categories have arrows? ;)
19:56:23 <LordBrain> Cale, saml just now, and tac_ earlier... saml complaining that we can write non monad law compliant monad instances, and tac_ complaining that hindly milner type inference is a bad thing, ...
19:56:47 <LordBrain> both complaints seem like nonissues to me really.
19:57:03 <Cale> LordBrain: Well, they are issues. There are even languages which solve these issues
19:57:28 <tac_> That barely counts as complaining on my end ;o
19:57:28 <Cale> It's easy enough in Idris to define a Monad typeclass which requires proofs of the monad laws.
19:58:01 <ReinH> No free lunch though
19:58:13 <ReinH> Idris isn't just Haskell++
19:58:25 <LordBrain> it would be nice to have some of the power of idris with depenent types and code inference etc... but i don't agree that we should always sacrifice type inference from code in favor of code inference from types....
19:58:28 <Cale> I didn't see tac_'s comment, but type inference is something that most dependently typed languages give up on to a certain extent at present.
19:58:44 <Cale> It would be nice to have both.
19:58:57 <AfC> edwardk: can I ask you a CUFP question?
19:58:59 <tac_> The type inference thing is a posterchild for a feature which comes with definite drawbacks that are typically entirely ignored by the community.
19:59:34 <Cale> I'd like to have inference as much as possible in both directions between types and terms.
19:59:34 <tac_> It's good to keep a good perspective, even when you try to hype your language.
20:00:22 <tac_> (and yeah, the non-monad monads are poison >____> )
20:00:23 <LordBrain> Cale, in haskell there are the different namespaces, for type names and data constructors, etc, i think that is a good thing.
20:00:23 <Cale> It's *really* convenient sometimes to not have to write top level types of things if you're just throwing something together quickly and not embarking on a huge project.
20:00:40 <ReinH> roboguy_: oh, they're asking if there's a way to lift functions into an explicit category?
20:01:15 <tac_> Cale: for sure. Bang-on-it-until-it-works coding is very very nice to have. I would hate to annotate everything when I just wanted to see if something was possible at all.
20:01:19 <Cale> However, it's also really nice to be able to know that you don't have the branches of an if-expression the wrong way around because the other way wouldn't type check.
20:01:22 <roboguy_> ReinH: into any instance of Category, yeah
20:01:26 <LordBrain> i actually wouldn't go so far as to say poison tac_, they are an infelicity, but on occasion they can be of practical value.
20:01:37 <tac_> You shouldn't call it a monad if it's not a monad.
20:02:31 <tac_> The mantra goes: If it walks like a duck and quacks like a duck, then it's a duck. But if you don't satisfy the monad laws, maybe you're just a functor. Or maybe just applicative, even.
20:02:54 <Cale> Apart from ListT applied to something noncommutative, are there any remotely popular bad instances of Monad hanging around?
20:03:00 <LordBrain> tac_, it might be unfortunate then, that we called the class Monad at all.
20:03:33 <LordBrain> Cale, i know of a TraversableT
20:03:41 <LordBrain> with a similar issue to ListT
20:03:42 <Cale> Well, it's not so unfortunate, it's just a limitation of Haskell that we can't insist that users prove things. It's similar to
20:03:49 <ReinH> roboguy_: aside from the obvious way they form a category?
20:03:56 <Cale> how Eq doesn't require proof that (==) gives an equivalence relation
20:04:04 <tac_> Monad is a perfectly suitable name for the class.
20:04:12 <Cale> but everything which relies on Eq to work will assume that the instance provides one
20:04:23 <tac_> They are over-emphasized in Haskell, though. They are just one tool.
20:04:33 <Cale> Similarly, things will fail horribly if you try to define (<=) in a way which isn't a total order
20:04:35 <Cale> for Ord
20:04:46 <Cale> You'll end up with malformed Data.Map values and so on
20:04:55 <ReinH> caveat implementor
20:04:56 <tac_> A language where >>= and return were only defined for IO wouldn't be a terrible language to use.
20:04:57 <LordBrain> I actually think all our names are bad actually.... because for example, a functor should be from a category to a category, it shouldn't require that the domain be hask, etc.... so we should call it HaskFunctor instead really.
20:05:23 <tac_> Monad surely is a monad of Hask, so it's aptly named there
20:05:23 <ReinH> Endofunctor
20:05:29 <Cale> Well, it's for endofunctors on Hask, yes, but we can't really talk about other categories very well
20:05:31 <LordBrain> alright Endofunctor
20:05:33 <ReinH> Monad implies endofunctor
20:05:51 <roboguy_> ReinH: I think we're talking about different things...
20:05:54 <ReinH> Some people prefer to say that a functor is from Hask to some subcategory materialized by the type constructor
20:05:58 <ReinH> but that's not a very useful subcategory
20:06:00 <LordBrain> hmmmm it doesn't imply a hask endofunctor
20:06:03 <LordBrain> mathematically
20:06:14 <Cale> LordBrain: It does, if you include the laws
20:06:15 <napping> Cale: between constraint kinds and polykinds it's looking pretty close
20:06:20 <ReinH> roboguy_: I didn't say a hask endofunctor
20:06:22 <roboguy_> I just mean can we have a Haskell function "arr :: (Category p) => (a -> b) -> p a b" and if not, what would we need
20:06:24 <ReinH> monads are endofunctors with structure
20:06:33 <tac_> whether or not it's precisely a functor in full generality, though, instances of Functor are _functorial_ in a more general sense
20:06:46 <roboguy_> ReinH: I'm specifically talking the Category typeclass
20:06:56 <LordBrain> no.... it does if you include the laws as presentlyl encoded. But they are encoded with the assumption that the category is hask
20:07:02 <ReinH> roboguy_: oh, two conversations. Difficult.
20:07:19 <ReinH> Well, so do the monoid laws
20:07:25 <tac_> Typeclasses are predicates on types.
20:07:31 <napping> Cale: If you could talk about implications between typeclasses, you could do some interesting things
20:07:44 <tac_> To make an instance of Monad or Functor or anything else, you're making the claim that your type satisfies that predicate.
20:07:51 <ReinH> roboguy_: to any arbitrary p
20:07:58 <LordBrain> the class is not parameterized on the domain category.   You could have an endofunctor which is subcategory of hask to subcategory of hask.
20:08:03 <roboguy_> ReinH: I think you also need Functor (p a)
20:08:15 <tac_> And to blatantly lie about that is.... just kinda pointless, and potentially harmful if you don't fix your mistakes by the time your code makes it to hackage.
20:08:19 * hackagebot handle-like 0.0.0.0 - HandleLike class  http://hackage.haskell.org/package/handle-like-0.0.0.0 (YoshikuniJujo)
20:08:21 <ReinH> tac_: you're also making a claim about the laws that can't be done in haskell per se
20:08:26 <LordBrain> i don't think multiparameter type classes existed when we made Monad
20:08:34 <LordBrain> what if they had?
20:08:41 <tac_> ReinH: Right. It's your responsibility to verify them.
20:09:11 <tac_> It's your moral duty to, in fact.
20:09:18 <ReinH> tac_: the type system can check the predicates
20:09:20 <LordBrain> and its not as if it wouldn't be useful
20:09:48 <LordBrain> monofunctor shows that it would be
20:10:10 <ReinH> Sure, but parametricity is useful in other ways
20:10:23 <tac_> as long as we're throwing around opinions, I'm going to break out the Num hatred ;P
20:10:31 <ReinH> tac_: works for me
20:10:41 <tac_> I think that's where the divide comes from
20:10:46 <tac_> Is that typeclasses are two things glued together
20:10:56 <ReinH> But Haskell doesn't have a facility for fine-grained, "multiple-inheritance" typeclasses
20:10:59 <LordBrain> go on tac
20:11:07 <ReinH> it's very hard to construct and work with such a lattice
20:11:10 <tac_> They are both predicates on types, and operator (and name) overloading.
20:11:31 <fread2282> we really need some way of fixing typeclasses without breaking backwards compat
20:11:33 <ReinH> edwardk was telling me about some things you could do if you disabled orphan instances that sound very nice
20:11:41 <ReinH> but I didn't understand it well enough to regurgitate it
20:11:47 <tac_> A programmer, not knowing a lick of CT might think "ah, I really want to have do-notation for my not-actually-a-monad". And he makes a broken instance.
20:11:48 <enthropy> type families with :: Constraint on the end fill the former
20:11:52 <roboguy_> tac_: well, if you want you can have just the first thing
20:11:54 <ReinH> Also this was at 2am so...
20:12:21 <fread2282> also, if you aren't in IO, avoiding do-notation might just be a good idea
20:12:34 <ReinH> tac_: right, buy the laws can be (and should be) expressed without CT
20:12:46 <ReinH> You don't need to know CT to use monads or to understand the laws
20:12:50 <tac_> right
20:12:56 <enthropy> which is the same as roboguy_'s suggestion of classes without methods
20:12:56 <ReinH> CT helps put them into perspective
20:12:56 <roboguy_> fread2282: hmm, I'm not sure about that. I use do notation quite a bit outside of IO
20:12:59 <tac_> The problem is though that people are going after the do-notation.
20:13:16 <tac_> They are hungry for syntax to soothe their aching fingers.
20:13:21 <LordBrain> its not that simple tac
20:13:31 <fread2282> roboguy_: a bit, but when I see bad haskell it's 80% do notation
20:13:32 <LordBrain> not when you take into account the use case of transformers
20:13:41 <ReinH> tac_: this is a communication problem
20:13:50 <roboguy_> fread2282: in my experience that is usually inside IO though
20:13:59 <LordBrain> the idea is composability, and you have no choice that your program use the IO monad.
20:14:00 <tac_> I don't really know so much about how monad transformers work, theoretically.
20:14:10 <ReinH> I see a fair amount of pointless pointfree haskell too...
20:14:25 <ReinH> it's a strange sort of composability though
20:14:35 <ReinH> orthogonal to what we usually think of as composability
20:16:14 <Cale> LordBrain: You do kind of have choice about that though, it's totally possible to build other abstractions over the IO type
20:16:36 <LordBrain> I don't think it is strange in a basic theoretical sense, to me it seems the type system is getting in the way of the power of abstractions, when you want to combine them.
20:17:36 <tac_> Type system getting in your way here?
20:17:47 <Cale> What?
20:17:51 <tac_> I'm not sure that's appropriate to say about monad transformers.
20:18:08 <Cale> There are a lot of inappropriate uses of monad transformers in the wile
20:18:10 <Cale> wild*
20:18:24 <LordBrain> the type system gets in the way a lot tac_, a lot of solutions that we have invented over the years can be phrased as solutions to problems where types were an obstacle.
20:18:46 <Cale> But they can be really good at what they do when used appropriately, and you *need* the type system for all that stuff to work.
20:19:27 <Cale> In fact, you pretty much need static typing and typeclasses for the monad abstraction itself to work well
20:19:54 <LordBrain> i think there is a reason that the type system is where a lot of the focus and research has been.
20:20:06 <tac_> the type system can and does get in the way of things. I'm not sure that monad transformers are an instance where this is true.
20:20:09 <Cale> You have to be doing some really fancy things before the Haskell type system gets in the way
20:20:51 <LordBrain> tac_, tranformers exist because combining monads (the haskell thing, not the math thing) is nontrivial
20:20:59 <Cale> Like, constructing and operating on typed heterogeneous graphs has some points in it where you're probably going to want to sidestep the type system because you know that two types are equal but it's hard to prove to the Haskell compiler.
20:21:14 <LordBrain> you get me wrong if you think i am saying we should abandon the type system
20:21:27 <Cale> I disagree
20:21:31 <Cale> about transformers
20:21:32 <tac_> Cale: JSON parsing is pretty hard to do in any well-typed way in Haskell.
20:22:04 <LordBrain> why would parsing json be hard?
20:22:13 <Cale> Transformers have nothing to do with combining monads. They're about constructing particular monads that you want to refine into whatever library you're trying to write.
20:22:23 <LordBrain> maybe you just aren't experienced enough tac_...
20:22:57 <Cale> I always make sure when using monad transformers that users of the library will not be able to tell that monad transformers were involved in the construction.
20:23:09 <tac_> You can know you have well-formed JSON, but that tells you absolutely nothing about the shape of the data you can expect to see.
20:23:12 <Cale> (and I recommend others do as well)
20:23:18 <LordBrain> uuuuuh yes...; they are for constructing monads by combining them
20:23:28 <Cale> Not by combining monads
20:23:36 <Cale> By transforming monads into other monads
20:23:41 <LordBrain> are you leaving out the "by combining them" for the sake of being argumentative?
20:23:52 <Cale> Maybe you're combining transformers
20:23:58 <jle`> LordBrain: that...sounds like some sort of faulty appeal (that the other person isn't experienced enough)
20:23:59 <LordBrain> transforming monads into other monads, by combining them
20:24:06 <Cale> But you're certainly not combining monads
20:24:21 * tac_ hasn't seen Cale act argumentatively in his entire IRC experience.
20:24:26 <LordBrain> jle`, uh... well i don't mean it as an attack... i just think parsing json wouldn't be so difficult
20:24:39 <Cale> tac_: People rarely disagree with me somehow ;)
20:26:07 <tac_> I've always felt that while monads are an interesting and useful abstraction, they don't quite capture what we're really after in most 'mundane' programs
20:26:20 <Cale> Well, they shouldn't
20:26:31 <Cale> Knowing that something happens to be a monad doesn't tell you very much at all
20:26:38 <LordBrain> Cale, you're combining transfomers in lieu of combining monads..... as is apparent from the names of the transformers. I think that's the motivation that drove their invention.
20:27:00 <tac_> the ability to suspend continuations or replay them multiple times isn't what I think of when I think of what Joe Programmer needs at his deskjob, y'know?
20:27:53 <Cale> tac_: That sounds more like an argument against Cont than an argument against the monad abstraction.
20:28:00 <tac_> well, List, too.
20:28:08 <tac_> And parsers and STM-like things all have the same feel to them.
20:28:18 <Cale> You don't think list comprehensions are practical?
20:28:23 <AfC> edwardk: It says you don't need to submit a paper to the CfP, but are papers expected by the time of ICFP itself, or is it present-only?
20:28:26 <tac_> I think they are all very useful
20:28:47 <tac_> But you wouldn't ever want an application's top-level monad to be defined as some kind of parsing, STM, or List-like monad, I don't think
20:29:00 <Cale> er, okay
20:29:06 <tac_> You'd want to use those judiciously inside your application.
20:29:10 <napping> LordBrain: combining monads are hard as the math things, unless you have nice coproducts or something
20:29:11 <Cale> Of course
20:29:24 <LordBrain> tac_, its not clear to me that you want that top level abstraction to be a monad in all cases either.
20:29:33 <tac_> But what you said is spot on, Cale. Being a monad doesn't tell you very much.
20:29:48 <Cale> There's something called a distributive law which can be used to turn the composite of two monads into a monad, but such structure rarely exists.
20:30:24 <tac_> I like the idea of using an effects system. But that requires dependent types or a fancy type system, and even then, many people like to mix in algebraic effects which give you continuations again.
20:30:26 <napping> or maybe it was pullbacks?
20:30:30 <Cale> tac_: It's just a nice shape which shows up often enough that it's worth recognising
20:30:33 <Cale> It's not a big deal
20:30:50 <napping> anyway, monad transformers are a thing because combining monads isn't easy
20:30:53 <Cale> The fact that IO happens to be a monad is much less important than the fact that it's a data type at all.
20:31:11 <Cale> Which is why I've all but entirely stopped saying "IO monad"
20:31:20 <LordBrain> napping, well.... technically, you don't create the mathematical monads, god does.... or they are existing really and you just proof it.. so there's no real analog there.
20:31:27 <tac_> IO isn't even just 'a' monad. It's one of those fun open types that doesn't have a meaning until you run cabal build
20:31:30 <napping> at least without working in a category with properties that are more or less impossible to provide in a programming language
20:32:00 <Cale> LordBrain: It's offensive to attribute the hard work of mathematicians to invisible deities that nobody can find any evidence for.
20:32:52 <tac_> (I thought the mathematicians were the invisible dieties...)
20:33:15 <napping> LordBrain: that's entirely irrelevant to the question of how you can combine monads.
20:33:22 <randomclown> > implying math is discovered
20:33:24 <lambdabot>  Not in scope: ‘implying’Not in scope: ‘math’
20:33:24 <lambdabot>  Perhaps you meant ‘path’ (imported from Data.Graph)Not in scope: ‘is’
20:33:24 <lambdabot>  Perhaps you meant one of these:
20:33:24 <lambdabot>    ‘id’ (imported from Data.Function),
20:33:24 <lambdabot>    ‘C.id’ (imported from Control.Category),
20:33:35 <LordBrain> Cale, the hard work of the mathematicians comes in recognizing that objects which exist in some universe generated by axioms are there and have said properties. You might argue that you create the idea of a monad, but certainly you discover the instance.
20:33:38 <Cale> I really really hate the Platonic point of view that mathematical objects somehow "exist" independently of human thought.
20:34:09 <Cale> There's no evidence of anything like this, and it's even hard to say what it even means.
20:34:23 <LordBrain> its not platonic here... the instances of the monads exist already, and we're talking about creating instances here
20:34:44 <dolio> Cale: IO is specifically a monad, though, instead of the more sensible closed (possibly infinite) tree describing a computation without arbitrary stuff at the leaves. :)
20:34:48 <tac_> I hope those instances obey all the necessary laws at least...
20:34:57 <napping> LordBrain: you were talking about combining monads, and implying that there are monad transformers because something broken in Haskell makes monads harder than necessary to combine
20:35:08 <LordBrain> I did not mean to step into your plato pet peeve, but it is irrelevant to my comment.
20:35:34 <Cale> Maybe I don't know what you're trying to say.
20:37:01 <Cale> dolio: There are certainly other abstractions or structures we could use when describing the input/output behaviour of our programs.
20:37:35 <LordBrain> napping, broken ... uh... well more like imperfect, i'm not implying that type systems suck, or that haskells type system isn't the best one out there. Imo, it is actually, tho some are superior in some way or another, i actually think haskell has the best trade offs... tho it surely can and will be improved much, and i believe it will be.
20:37:42 <Cale> If you use something like any of the FRP systems, then you'll quickly get away from using the IO type, and instead be working with a graph of behaviours and events.
20:38:18 <napping> LordBrain: sure, but let's say you have two monads F and G on some category C. How do you define a combined monad?
20:39:56 <Cale> Or you can even take a much less severe approach which nonetheless gets quickly away from using the monad operations on IO -- from what I understand of the structure of XMonad for instance, it has a nice separation of the window management model into pure, easily tested code, which can then be put to use by some driver which actually moves the windows around.
20:40:13 <napping> There's room to improve the type system. Building up monads using monad transformers is not a symptom of that.
20:40:54 <Cale> napping: I agree
20:41:31 <napping> free monads do compose nicely, for example
20:44:47 <LordBrain> no... i was saying transfomers were a solution to the problem of combining monads. I am not a category theorist, so i don't know what they have need of.. They might find it useful to define operators which act on monads and produce monads etc. But i don't think programmers are even doing motivated by that... they just want to get the most benefit, make the most reuse of their encoded abstractions.
20:44:51 <dolio> That's not necessarily true.
20:45:18 <dolio> You could have a category that had a free monad over F and a free monad over G, but not a free monad over F + G.
20:47:21 <LordBrain> napping, if you are describing a monad in english, you can say, it has this in common with such and such named monad, and you can list them off... as a mathematician, you're done.... but that doesn't even mean you can express the monad in whatever particular computer language you are using.
20:48:02 <napping> no, as a mathematician you'd have to go on and show it's actually possible or necessary for such an object to exist at all
20:48:24 * hackagebot xml-conduit 1.2.0.2 - Pure-Haskell utilities for dealing with XML with the conduit package.  http://hackage.haskell.org/package/xml-conduit-1.2.0.2 (MichaelSnoyman)
20:48:57 <LordBrain> well depending on the context yes, you might have to prove existence, and you certainly should prove the monad laws and such.
20:49:03 <ReinH> One way to compose monads is through adjunctions
20:49:18 <LordBrain> existence isn't necessary in all contexts
20:49:22 <napping> dolio: isn't that only in cases where you don't naturally have a free monad corresponding to every endofunctor
20:49:47 <dolio> Yes.
20:49:58 <napping> or I suppose, if you don't even necessarily have a coproduct F+G in the first place
20:50:11 <dolio> Yeah, I guess that could happen, too.
20:50:47 <napping> anyway, I should have said more specifically that free monads in Haskell compose more nicely. Or more generally, that composing free monads takes weaker conditions
20:50:57 <LordBrain> and depending on your axioms, you might be able to prove existence in a non-constructive manner too...
20:51:02 <napping> ReinH: that needs a distributive law, right?
20:51:27 <napping> LordBrain: sure, but it's not a given that an english description of a "combination" of two monads is non-contradictory
20:51:50 <ReinH> napping: adjoints compose in a natural fashion...
20:52:10 <napping> ReinH: sure, but how do you make a monad from the composition?
20:52:24 <ReinH> napping: er, all adjunctions give rise to a monad?
20:52:31 <napping> hmm
20:52:53 <LordBrain> napping, it might be a contradiction to say the combined thing is a monad, but that's not honestly the utmost concern from a programming perspective.
20:53:35 <LordBrain> you might say, i don't want a monad to be the top level abstraction for this program... and there's no reason why that makes you immoral.
20:54:03 <napping> ReinH: how does that go again?
20:54:14 <ReinH> napping: let me grab Mac Lane? :)
20:54:54 <dolio> F ⊣ U, FU is a monad.
20:55:03 <ReinH> napping: Oh right
20:55:04 <dolio> And UF is a comonad.
20:56:03 <napping> I think I remember where that got into trouble
20:56:04 <ReinH> napping: if F |- G then GF is a monad. return is GFGF, and since FG is an identity...
20:56:07 <dolio> Did I get that backwards?
20:56:11 <dolio> I did.
20:56:41 <napping> not all monads come from adjunctions Hask <=> Hask
20:57:02 <napping> and you can only compose them if the categories match up
20:57:20 <ReinH> Oh I wrote that backwards. F -| G
20:57:27 <napping> dolio: I always forget which way the arrows go
20:57:36 <ReinH> F is left-adjoint
20:57:48 <dolio> napping: I even tried to check in my head, but I did it wrong.
20:57:57 <napping> F -|  G : C => D has F from C to D?
20:58:17 <napping> oh, F goes back
20:58:19 <napping> okay
20:58:25 * hackagebot markdown 0.1.8 - Convert Markdown to HTML, with XSS protection  http://hackage.haskell.org/package/markdown-0.1.8 (MichaelSnoyman)
20:58:42 <jle`> didn't know that snoyman had a markdown library
20:58:44 <ReinH> F -| G has F : C -> D and G : D -> C
20:58:50 <ReinH> no no no
20:58:52 <ReinH> sorry
20:58:54 <ReinH> F : D
20:59:04 * ReinH writes it 100 times on the blackboard
20:59:04 <jle`> : D
20:59:26 <ReinH> napping: yes, F goes back. Sorry.
20:59:49 <napping> so anyway, to actually get a Haskell Functor out, you need to have F -| G from Hask to some category
20:59:50 <ReinH> I can't draw string diagrams on IRC :(
21:00:08 <napping> and the usual adjunctions induced by a monad go to some other category of monad algebras or whatever
21:00:20 <napping> and then those adjunctions don't have the right types to compose
21:00:22 <ReinH> The composition needs to be an endofunctor in Hask, yes
21:00:37 <napping> Right, and you can't get some important monads that way
21:01:37 <napping> http://stackoverflow.com/questions/4697320/monads-as-adjunctions
21:01:43 <ReinH> but you can get some interesting ones :)
21:01:51 <ReinH> Galois connections are adjunctions
21:02:44 <ReinH> Oh nice
21:04:39 <napping> anyway, that's why adjunctions are not a general answer to composing monads
21:04:54 <ReinH> napping: sure
21:05:10 <ReinH> napping: they can still be useful though
21:05:36 <ReinH> iirc the coyoneda trick is done via a composition of adjunctions through a right kan extension or something
21:05:50 <ReinH> I'm probably remembering that wrong
21:06:26 <napping> maybe if you could define a monad in a way that's more generic over the base category, then you could use adjunctions to compose it more freely
21:06:39 <ReinH> Anyway, now is a good time to watch some Catsters videos while I do the dishes :)
21:11:41 <ReinH> napping: lmao that's why I was confused! TheCasters adjunctions videos use F : C -> D and G : D -> C
21:12:20 <tac_> Isn't that the morally correct way to do it?
21:12:34 <tac_> Or was the morally correct way Hom(FX, Y) ~ Hom(X, GY)?
21:12:42 <ReinH> my brain is not very good at alpha conversion :(
21:13:13 <ReinH> tac_: I'm not sure which way would be "morally correct"
21:13:48 <tac_> If there's any reason lambda calculus and type theory fail to be the "One True Foundation" for mathematics, alpha conversion would be one of the main culprits
21:14:35 <tac_> How can you have a machine-checked proof where the machine is responsible for producing non-colliding names? That act requires human creativity and thought!
21:14:47 <ReinH> So um. Um. F : D -> C, G : C -> D, hom_C(FY, X) ~ hom_D(Y,GX)
21:15:14 <ReinH> Is one way.
21:15:44 <ReinH> Now I will finish the catsters videos and try to do the alpha conversion in my head
21:15:47 <syrioforel> that breaking of alphabetical ordering makes me sad :D
21:16:02 <ReinH> It's sometimes written F : C <- D
21:16:13 <ReinH> to make the adjunctioniness more clear
21:16:20 <ReinH> F : C <- D
21:16:23 <ReinH> G : C -> D
21:16:32 <syrioforel> I've typically seen/used F : C <-> D : G
21:16:58 <syrioforel> w/ hom_D(FX,Y) ~ hom_C(X,GY), but eh pickiness
21:17:11 <tac_> Pick any object in the one category, send it to the other and send it back. You should have an arrow between the thing you started with and the thing you ended with. That's the unit of the adjunction.
21:17:38 <LordBrain> are there comprehensions for Set?
21:17:57 <tac_> Comprehensions in what sense?
21:18:05 <jTT> hey, quick question: what’s the advantage here of using “Maybe Int” as opposed to [Int]? elemIndex :: (Eq a) => a -> [a] -> Maybe Int
21:18:05 <LordBrain> analogs to list comprehensions
21:18:19 <tac_> I guess my second question is, what kind of Set are we talking about?
21:18:25 <LordBrain> Data.Set
21:18:32 <tac_> I don't think so
21:18:34 <jTT> has MAybe got some intrinsic advantage I should be aware of?
21:18:40 <tac_> Data.Set isn't a monad, so it doesn't get the monad comprehension syntax
21:18:50 <syrioforel> @jTT if it returns [Int] do you mean for it to return all indices, or just a singleton of the first one?
21:18:50 <lambdabot> Unknown command, try @list
21:18:56 <tac_> You can just use a list comprehension and then run fromList or whatever on it
21:18:59 <ReinH> syrioforel: Hmm, I'm taking mine from Mac Lane
21:19:01 <tac_> @type Data.Set.fromList
21:19:02 <lambdabot> Ord a => [a] -> S.Set a
21:19:12 <jTT> @syrioforel : singular or empty
21:19:12 <LordBrain> its ironic tac_ since the syntax is obviously inspired from set notation
21:19:12 <lambdabot> Unknown command, try @list
21:19:30 <tac_> Maybe a little. But it's a very different context
21:19:45 <syrioforel> ReinH: that's a bit surprising. It's all the same in the end, of course
21:19:50 <tac_> A Data.Set is much weaker than Cantor's set. They are finite and require an ordering
21:19:52 <napping> tac_:  obviously type theory with DeBruijn indices is the one true foundation for mathematics.
21:20:03 <LordBrain> true
21:20:11 <tac_> the ordering is the killer here
21:20:22 <tac_> It implies Eq, I believe, right?
21:20:25 <LordBrain> the ordering, is basically necessary for having practical efficiency
21:20:35 <syrioforel> jTT: The data type of Maybe entails being singleton or empty. [Int] could have many things. Maybe Int is a more restrictive type that better describes what the function is doing
21:20:36 <tac_> and while equality is always decidable with Cantor sets, it's not with Haskell sets
21:20:40 <tac_> err
21:20:45 <tac_> with Haskell types*
21:20:57 <napping> tac_:
21:21:07 <napping> "decidable" is a funny word to use about equality of Cantor sets
21:21:07 <jTT> @syrioforel: thanks, that helped me understand
21:21:08 <lambdabot> Unknown command, try @list
21:22:22 <tac_> napping: It's appropriate though. You can take the intersection of two sets, even if they are functions.
21:22:40 <tac_> In Haskell, you can't take the intersection of two lists unless they are Eq-able things
21:23:07 <LordBrain> technically, Set is a monad, the problem is it is a restricted one, right?
21:23:18 <LordBrain> i mean, its not a monad on hask
21:23:19 <napping> not really
21:23:27 <tac_> The problem is the typeclass messes things up
21:23:29 <napping> fmap f . fmap g = fmap (f . g) fails
21:23:45 <LordBrain> oh
21:24:11 <LordBrain> wait
21:24:14 <ReinH> syrioforel: Let's see... Let A and X be categories. An adjunction from X to A is a triple <F, G, phi> : X -> A, where F and G are functors F : X -> A, G : X <- A, while phi is a function that assigns to each pair of objects x \in X, a \in A a bijection phi = phi_x.a : A(Fx,a) ~ X(x,Ga)
21:24:17 <LordBrain> can you demonstrate that napping ?
21:24:27 <napping> it depends on the Eq instances you have
21:25:01 <LordBrain> i still don't see it
21:25:04 <syrioforel> ReinH yeah that matches the ordering i have in mind, though X,A are weird names for categories!
21:25:12 <ReinH> syrioforel: indeed
21:25:34 <ReinH> They're the ones Mac Lane chose though
21:25:37 * ReinH shrugs
21:25:58 <napping> newtype Squash a = Squash {unSquash :: a} instance Eq (Squash a) where _ == _ = True, obvious Ord, then unSquash . Squash is id, but mapping Squash over a set does bad things
21:26:38 <ReinH> syrioforel: meanwhile, Awodey has: An adjunction between categories C and D consists of functors F : C <- D, U : C -> D, and a natural transformation unit : 1_C -> U . F
21:26:45 <ReinH> syrioforel: Argh.
21:27:08 <ReinH> syrioforel: which is particularly annoying because Awodey was a student of Mac Lane and just... decided to flip the arrows around?
21:27:12 <syrioforel> ReinH: That's how they often come up, with F being a "Free" object functor, and "U" the forgetful functor
21:27:30 <syrioforel> ReinH: Oh, I just noticed the bad alphabetization
21:27:32 <ReinH> syrioforel: indeed. I suppose that definition became because of Awodey, or at least after Mac Lane
21:27:48 <ReinH> syrioforel: F is coF?
21:27:53 <ReinH> that bad alphabetization?
21:27:55 <syrioforel> ReinH: There's no need to get too caught up on it though -- often you have concrete categories (Set, or Top, or something) that you're working with
21:28:08 <napping> or maybe you'd say that Set really should be a functor, but it's not enough to restrict it to all Haskell functions between types Ord, but you additionally need to restrict the functions you're allowed to fmap with in some way
21:28:09 <ReinH> syrioforel: oh I know. It's just hurting my brain to deal with both at the same time.
21:28:17 <syrioforel> ReinH: yeah i know the feeling ;D
21:28:41 <syrioforel> ReinH: I spent far too much time bashing my brain understanding model categories :)
21:28:53 <ReinH> syrioforel: heh I'll get there eventually I suppose :)
21:29:04 <syrioforel> ReinH: depends if you do topology or not
21:29:10 <ReinH> maybe not then
21:29:11 <syrioforel> ReinH: or algebraic geometry
21:29:13 <LordBrain> napping, i still don't see it... sorry to be thick. When is fmap unSquash . fmap Squash /= fmap (unSquash . Squash) ?
21:29:15 <ReinH> maybe then
21:29:25 <ReinH> syrioforel: Well, I get to do whatever interests me ;)
21:29:39 <syrioforel> ReinH: yep ;)
21:29:49 <napping> LordBrain: because Squash a defined Ord/Eq so everything is equal, and fmap Squash collapses the set down to one point
21:30:27 <ReinH> syrioforel: Ok going to go watch the catsters video again as an exercise in teaching my brain to alpha rename :)
21:30:36 <syrioforel> ReinH: go for it! :D
21:30:38 <LordBrain> oooh
21:30:41 <napping> so fmap (unSquash . Squash) = fmap id = id, while fmap unSquash . fmap Squash always returns a set with at most one element
21:31:12 <ReinH> syrioforel: I guess the switch might have been motivated by having F be a mnemonic for free?
21:31:22 <LordBrain> ty
21:31:23 <napping> If you prefer you can say Set is a functor on the category whose objects are haskell types with a well-behaved Ord instance and whose arrows are functions which are injective according to those Ord instances
21:31:34 <napping> but it's not quite as simple as just saying that it's a missing Ord constraint
21:31:49 <syrioforel> napping: they don't have to be injective, but they need to be well-defined up to the Eq equivalence
21:31:51 <napping> plus we can't really define injectivity like that without dependent types
21:32:33 <napping> yeah, I guess unSquash distinguishing == items could be considered the problem - still inexpressible without dependent types, I think
21:33:02 <syrioforel> you'd have to do something crazy complicated to get things to work
21:33:02 <LordBrain> well, i would go for that, except well behaved needs to be more thoroughly defined in my mind here.
21:33:15 <napping> just that Eq is actually an equivalence relation
21:33:24 <napping> and Ord a total order
21:33:32 <napping> exactly what you'll find in the Agda standard library
21:33:32 <LordBrain> ok
21:33:47 <syrioforel> well, and that morphisms respect that equivalence relation (ick)
21:34:30 <LordBrain> morphisms are functions on the type in this case right?
21:34:31 <napping> isn't that covered by "well-defined up to the Eq equivalence"?
21:34:40 <syrioforel> yeah^
21:35:11 <LordBrain> so if a == b then f a = f b for all f... yeah that is ick
21:35:20 <LordBrain> i mean
21:35:29 <LordBrain> well i guess its reasonable tho
21:35:36 <LordBrain> but its an additional requirement
21:35:38 <syrioforel> well, you restrict to f such that a == b => f a == f b
21:35:42 <tac_> In Univalence we Trust
21:35:56 <LordBrain> right
21:36:28 <LordBrain> but
21:36:36 <LordBrain> does total order take care of that?
21:37:11 <syrioforel> if the functions respect the ordering, sure
21:37:26 <napping> If your Eq/Ord is allowed to be any less specific that total identity of the values, some haskell function that can use the representation can violate it
21:37:29 <ReinH> Oh the Catsters use the unit/counit definition. Which actually makes sense this time. Yay.
21:37:43 <napping> I can remeber the Hom one
21:38:02 <napping> Did the catsters video explain it well, or you just saw it enough times?
21:38:04 <syrioforel> i always find unit/counit confusing because it reverses the usual "co" convention... kinda
21:38:31 <syrioforel> i flip them every time
21:38:32 <LordBrain> suppose = is they're both even, or both odd, and the odering is that even < odd...
21:39:16 <LordBrain> using something like newtype K = K Int,
21:39:34 <napping> LordBrain: as long as a function respects Eq, Set would be fine without requiring anything about how it respects the order
21:39:58 <LordBrain> the function mus be of type K-> K, right?
21:40:10 <napping> no
21:40:25 <napping> you could map a function K -> Int over a set of K fine
21:40:37 <LordBrain> oh, but that would break it
21:40:45 <napping> you'd just have to make sure that if K i == K j then f (K i) == f (K j)
21:40:55 <LordBrain> i get ya
21:40:56 <napping> so something like f (K x) = if isEven x then 0 else 112 would be okay
21:41:15 <syrioforel> if you've seen quotient objects it's the same constraint ^
21:41:53 <LordBrain> i suppose with dependent types we could actually express that restriction too
21:41:56 <napping> If you can define a type that only allows that sort of well-behaved function, then you can define a category on which Data.Set is a well-behaved functor
21:42:57 <LordBrain> i'm not sure actually
21:43:05 <LordBrain> is that doable/
21:44:02 <syrioforel> Not really sure, my math-fu greatly exceeds my haskell-fu
21:44:05 <napping> It's easy to do with dependent types, probably not easy to actually do anything with that definition
21:44:08 <LordBrain> i mean, if the the domain of the function is small, you could prove it with a quickcheck... but in general, it would seem like that approach would take forever
21:44:51 <mornfall> LordBrain: smallcheck is a better bet for exhaustive testing
21:44:56 <LordBrain> yeah, you could do it with dependent types, but the result might not compile within a reasonable time...
21:45:29 <LordBrain> okay, well an exhaustive check could be done in principle is all i am saying here, but thanks for the tip
21:46:23 <tac_> Do typeclasses appear in the haskell core?
21:46:29 <tac_> I want to say they don't...
21:46:38 <tac_> typeclasses and instances
21:46:40 <mornfall> tac_: they don't, they turn into explicit dictionaries
21:46:42 <napping> in Core?
21:46:55 <tac_> that's what I thought
21:47:07 <mornfall> would be kinda crazy you know
21:47:13 <tac_> what would?
21:47:20 <mornfall> having typeclasses in core
21:47:58 <tac_> I'm not so sure it would need to be all that crazy
21:48:38 <mornfall> it's supposed to be a sugarfree language
21:48:48 <mornfall> besides
21:48:55 <mornfall> typeclasses in ghc are pretty wild
21:49:06 <mornfall> and desugaring them to 98-style typeclasses doesn't sound very doable
21:49:59 <mornfall> easier to go all the way (you'd probably end up going all the way most of the time anyway)
21:50:24 <mornfall> (well, that's what I think anyway... but I'm sleep deprived :P bbl)
21:52:41 <napping> There's also the design decision that GHC tries to do as much typechecking as possible before desugaring, to give better error messages
21:58:32 * hackagebot wai 2.1.0.3 - Web Application Interface.  http://hackage.haskell.org/package/wai-2.1.0.3 (MichaelSnoyman)
21:58:34 * hackagebot wai-extra 2.1.1.2 - Provides some basic WAI handlers and middleware.  http://hackage.haskell.org/package/wai-extra-2.1.1.2 (MichaelSnoyman)
21:58:36 * hackagebot wai-handler-launch 2.0.1.3 - Launch a web app in the default browser.  http://hackage.haskell.org/package/wai-handler-launch-2.0.1.3 (MichaelSnoyman)
21:58:38 * hackagebot wai-test 2.0.1.3 - Unit test framework (built on HUnit) for WAI applications.  http://hackage.haskell.org/package/wai-test-2.0.1.3 (MichaelSnoyman)
21:58:40 * hackagebot wai-websockets 2.1.0.2 - Provide a bridge betweeen WAI and the websockets package.  http://hackage.haskell.org/package/wai-websockets-2.1.0.2 (MichaelSnoyman)
21:58:55 <solidus-river> hey all, i'm having trouble wrapping my head around classes
21:58:59 <solidus-river> http://lpaste.net/104495
21:59:04 <solidus-river> how come that doesn't work?
21:59:27 <solidus-river> i'm trying to abstract a data object that i can get a databaseHandle out of so i can interface it iwth another class of data to take actions on teh database
21:59:37 <tac_> what's the error?
21:59:43 <Cale> The type of closeConnection is silly
21:59:59 <solidus-river> Cale: the type of initializeMigrations is silly too
21:59:59 <Cale> The only thing which closeConnection could do with its second parameter is ignore it
22:00:04 <Cale> yes
22:00:07 <Cale> similarly
22:00:18 <solidus-river> so i'm clearly doing something wrong :P
22:00:25 <napping> what are b and c supposed to be?
22:00:38 <mornfall> solidus-river: a is bound by the type class, but b and c not
22:00:41 <Cale> also, the type of initializeConnection means that the only thing it could produce as a return value is an error or nonterminating value
22:01:09 <napping> you probably want to change b to something like handler, and make it a parameter of the type class, or an associated type or something like that
22:01:24 <solidus-river> b is supposed to be whatever the "connectionHandle" type class is for a data store (for Postgres its Database.PostgreSQL.Simple (Connection)
22:01:43 <solidus-river> well i'm trying to allow for use of DatabaseHandlers in my main logic without binding the logic to a specific data store
22:01:46 <napping> so that should be part of the constraint, or determined by the handle type
22:01:54 <solidus-river> so i dont want to bind it to Postgres or MySQL or anything
22:02:13 <napping> what you wrote means those functions have to be completely polymorphic in those arguments
22:02:22 <solidus-river> but i need a handle thats seperate from my migration data type in order to do the logic i want to with my main code
22:02:26 <napping> class DatabaseHandler handler where type Connection handler :: *; ....
22:02:38 <LordBrain> he could make it weakly typed
22:02:42 <Cale> solidus-river: The caller gets to choose b and c whenever any of those methods are used
22:03:13 <napping> or class DatabaseHandler handler connection | handler -> connection where ...
22:03:18 <LordBrain> seems to be how he is concieving it
22:03:42 * hackagebot warp 2.1.5.2 - A fast, light-weight web server for WAI applications.  http://hackage.haskell.org/package/warp-2.1.5.2 (MichaelSnoyman)
22:04:16 <solidus-river> parsing what you guys just said
22:04:45 <Cale> solidus-river: Yeah, when you use type variables in the types of your functions, it means that the *user* of those functions gets to determine what the type variables are, not that the implementation of the function does.
22:05:04 <napping> those two ways use the TypeFamilies or FunctionalDependencies extensions
22:05:24 <solidus-river> wait, i'm pretty lost
22:05:30 <Cale> So, for example, if I'm calling initializeConnection, I can insist that b = Integer, and it has to do something sensible
22:05:56 <solidus-river> ah, how do i make the type of B be non important
22:06:05 <Cale> Or for example, initializeMigrations, I can pass a value of literally any type as the third parameter
22:06:11 <solidus-river> but insist that its a valid thing to get back so i can use it other places in code
22:06:14 <napping> that's what I was suggesting
22:06:31 <napping> two ways to let the instances pick some particular type of b that the caller has to follow
22:06:40 <Cale> You need to be more precise about how the type is related to the type a
22:06:42 <LordBrain> what version of ghc are you using solidus-river ?
22:06:51 <Cale> Or perhaps choose some specific type
22:07:08 <napping> presumably different databases can use different connection types
22:07:20 <napping> though I suppose you could toss them all in Dynamic, if you really wanted to
22:07:38 <solidus-river> LordBrain: 7.6.3
22:08:01 <solidus-river> napping: thats exactly the problem i'm trying to solve, i'm just trying to understand what you said earlier
22:08:04 <Cale> Well, right. If you're going to be using external libraries for the various databases, they'll presumably define their own connection types which you'll want to use, and which hopefully you can determine from the type 'a'
22:08:11 <solidus-river> like i get that putting b and c in there is silly
22:08:12 <Cale> So, for example, you can write
22:08:20 <Cale> class DatabaseHandler a where
22:08:27 <Cale>   type Connection a
22:08:38 <Cale>   initializeConnection :: a -> IO (Connection a)
22:08:52 <Cale>   closeConnection :: a -> Connection a -> IO ()
22:08:53 <napping> if you add a line "type Connection a :: *" to the class declaration, change b into "Connection a" everywhere, and then in the instance add a line "type Connection Database = DatabaseConnection" (or whatever), then it should work
22:09:29 <Cale> (You don't even need the kind annotation)
22:09:44 <napping> oh, probably better to leave it off then
22:10:15 <Cale> You'll also want to do something similar with c
22:10:21 <LordBrain> i'm not sure i'd recommend type families to him... i havent tried that version of ghc, but on 7.4.1 i had better luck with multiparameter type clases and functional dependencies..
22:10:31 <Cale> Perhaps add something like  type Migrations a
22:10:47 <napping> or just make it return () instead
22:10:57 <napping> you don't provide any methods to let you do anything useful with the result anyway
22:11:01 <Cale> yeah, I don't know, it depends on what you need that to do
22:11:34 <napping> well, maybe for specific instances you'll know the migrations return is some specific type, but you can't do that in any code that's actually polymorphic over the backend
22:11:41 <Cale> right
22:11:46 <LordBrain> they just recently added those roles which make type families worth trying again on 7.8.2, but he's on 7.6
22:11:49 <napping> but maybe that's exactly what you want
22:12:01 <Cale> LordBrain: Type families worked fine in 7.6
22:12:13 <solidus-river> LordBrain: I can go to 7.8 easy
22:12:25 <LordBrain> probably worth it then solidus-river
22:12:38 <napping> the only problem in 7.6 is that GeneralizedNewtypeDeriving let you mess around with type families
22:12:49 <LordBrain> hmmmm
22:13:04 <Cale> Yeah, unless you're going out of your way to do something sneaky, you're quite unlikely to run into the bugs
22:13:05 <LordBrain> yeah, come to think of it, i had trouble in 7.4 that was unrelated to that
22:13:51 <solidus-river> napping: so what you said about type Connection a, what is that sying about the typeclass?
22:14:40 <LordBrain> i don't recall now, but i recall only having type families and functional dependencies turned on... and things that should have been inferred just werent any more, so i switched back to multiparam type classes with dependencies
22:15:07 <napping> That's saying that for any type T which is an instance of DatabaseHandler, there's some type which we can refer to by Connection T that's used/returned by some of the methods
22:15:25 <LordBrain> i was trying type families, because somewhere i read they obsoleted multiparam and fundep
22:15:36 <napping> like you could have a PostgresHandler and define the instance so Connection PostgresHandler = PostgresConnection
22:16:45 <solidus-river> ok for a second i'm going to take otu initializeMigrations from the picture and try iterating on what you guys said / generate a new paste when shit hits thie fan :P
22:16:48 <solidus-river> this is hard to wrap my head around
22:17:19 <Cale> solidus-river: Well, it's fancy, we're using type system extensions to try to make sense of what you want to do
22:17:38 <LordBrain> yeah, perhaps we should just tell him a more mundane approach
22:18:07 <napping> newtype Connection a = Connection Dynamic?
22:18:19 <Cale> One sensible approach is to define a data type which has the appropriate methods as record fields (and the types as parameters)
22:18:21 <LordBrain> like data DB = PostGres | Mysql
22:18:34 * hackagebot yaml 0.8.8.3 - Support for parsing and rendering YAML documents.  http://hackage.haskell.org/package/yaml-0.8.8.3 (MichaelSnoyman)
22:18:37 <Cale> and then have things take records of that type as a parameter
22:19:23 <napping> that tends toward the fundep approach
22:19:26 <Cale> right
22:19:38 <Cale> Though, it can also be done in Haskell 98
22:19:50 <LordBrain> oh well, we already said one thing, perhaps its best to let him chew on it for a while
22:20:06 <solidus-river> LordBrain: i thought about that and the problem i thought i'd run into is that it would make me modify my core code whenever anyone wanted to add a new datastore to the program
22:20:11 <napping> and we'd need to allow records containing types to simulate a fundep approach
22:21:13 <LordBrain> what extensions does that require napping ?
22:21:47 <Cale> napping: we would?
22:21:53 <Cale> Oh, well, I suppose
22:21:59 <Cale> I'm thinking of something simpler
22:22:08 <Cale> Just define a record type like this:
22:22:57 <LordBrain> Cale, you mean like just add methods to his Database type
22:23:09 <Cale> data DatabaseHandler a conn = DH { initializeConnection :: a -> IO conn; closeConnection :: a -> conn -> IO () }
22:23:27 <Cale> Yeah, that would also be possible
22:23:51 <napping> yeah, and data DatabaseHandler a = DH {con :: *; initializeConnection :: a -> IO conn; closeConnection :: a -> conn -> IO ()} isn't exactly Haskell
22:24:08 <Cale> Right, but you don't really need that
22:24:22 <Cale> Actually, you can do that with extensions too, using an existential
22:25:13 <napping> I guess that works, but maybe there are some issues around telling whether connections are compatible
22:25:41 <napping> on the other hand, maybe connections should never be usable with different types of handlers
22:25:51 <Cale> Only if you unpack the initializeConnection and closeConnection from distinct records
22:25:59 <Cale> yeah
22:26:05 <napping> so maybe I should have suggested a data family instead
22:26:18 <napping> well, this probably works well enough
22:26:28 <napping> and lets you directly re-use existing connection types
22:26:43 <Cale> But yeah, all of that's getting back to being fancy -- just having both types be parameters is a good way to avoid needing any fancy language extensions
22:27:17 <solidus-river> fancy is fun to try to understand though :)
22:27:39 <solidus-river> Cale so how does haskell reason about multiple types for b if i have it be a parameter
22:28:01 <napping> well, that's where the functional dependencies come in
22:28:02 <LordBrain> hmm i lost code in a hard drive crash :(
22:28:08 <napping> if you just wrote class DatabaseHandler a b where ...
22:28:25 <napping> then there's no way to know if you might have instances of several different connection types for the same handler
22:28:39 <LordBrain> i was gonna try to dig up my problems with type families, but i lost it
22:28:41 <napping> and you'll need a type annotation on every initializeConnection to tell it what kind of result
22:28:54 <napping> (or maybe enough extra context to figure it out)
22:29:03 <solidus-river> napping: that isn't too painfull
22:29:22 <napping> putting class DatabseHandler a b | a -> b where ... adds the "functional dependency" a -> b, saying for each a only one b is allowed
22:29:34 <LordBrain> perhaps connection should be the type class actually
22:29:35 <napping> and it makes a lot more things get inferred, and also checks that when you are defining instances
22:30:37 <LordBrain> for example, running an sql query can be a method of the connection class
22:31:20 <LordBrain> call it something like DBConnection
22:32:12 <solidus-river> LordBrain: then i loose the ability to use Transactions since not all databases that people would use with this have transactional queries / rollback functionality
22:32:50 <solidus-river> I was hoping to have all the migration logic in a seperate class called DatabaseAdapter
22:33:13 <solidus-river> and some of those functions would require a DatabaseHandler as a parameter
22:33:31 <LordBrain> ok
22:34:14 <solidus-river> but if thats crazy its crazy :P, this is the first time i've tried to write something complex in haskell
22:35:16 <solidus-river> would what napping was suggesting allow me to use that structure i just described?
22:35:38 <LordBrain> you mean the fundep?
22:35:39 <LordBrain> yes
22:36:08 <napping> either way
22:36:20 <LordBrain> why does closeConnection take two parameters?
22:36:36 <LordBrain> right, either way, multiparm+fundep, or type families
22:36:58 <napping> If you have a separate type describing connection operations, you can add that as a superclass like class (DBConnection (Connection h)) => DatabaseConnection h where ...
22:37:27 <napping> or class (DBConnection conn) => DatabaseHandler handler conn | handler -> con where ...
22:38:11 <solidus-river> would you recommend multiparm+fundep or type families
22:38:20 <solidus-river> is one better or are the just different was of framing the problem?
22:38:38 <LordBrain> solidus-river, in DatabaseHandler, why did you give closeConnection two inputs? i am not familiar with the bindings for postgres or whatever
22:38:54 <napping> they are pretty similar in power, at least for this sort of thing.
22:39:02 <napping> I think the type families look a bit cleaner
22:39:06 <solidus-river> LordBrain, i didn't want to, really closeConnection should only have one input and then generateMigration should only have 2 inputs
22:39:22 <solidus-river> but GHC complaned when i didn't mention a in the type signatures of the functions of the class
22:39:47 <napping> well, with any of the things we've been suggesting, nothing stops several handlers from having the same connection type
22:40:03 <LordBrain> solidus-river, um.... multiparam+fundep is the older way of doing things, it is not as powerful in general, but it is fine for this purpose... its actually easier to learn i think, but less powerful than type families.
22:40:30 <napping> It's more of a difference if you get really complicated constraints that start to nest things
22:41:01 <napping> (C (T1 (T2 a))) => ...  with type families might be (T2 a b, T1 b c, C c) => with fundeps
22:41:07 <napping> but you are not doing anything that tricky
22:41:53 <napping> but with fundeps you could also say class DatabaseHandler handler conn | handler -> conn, conn -> handler
22:42:01 <napping> then each determines the other, and close only needs to take the handler
22:43:04 <LordBrain> there's no way to express that determination with type families?
22:43:40 <napping> not directly, that really is a relational kind of property
22:44:08 <napping> a data family is injective
22:44:17 <solidus-river> so now i have this http://lpaste.net/104495
22:44:55 <solidus-river> is that more along the right track?
22:45:13 <solidus-river> i constrained th return type of initializeMigrations to make it easier to stumble through
22:45:13 <LordBrain> then i think that's the problem i had napping, when i was tryign type families, i was told by someone that they obsoleted multiparam+fundep, but i really wanted/needed to express that relation.
22:45:43 <napping> it should say DBConnection a everwhere in the class
22:46:54 <napping> and you probably should switch to fundeps if you want your close and migrate to work like that
22:47:30 <napping> or perhaps turn it around and make the parameters that initialize takes into a function of the conection
22:47:57 <LordBrain> solidus-river, you're going to probably want to use initializeConnection :: a -> IO (Either (DBErrorT a) (DBConnection a))
22:48:02 <napping> but if you want to use pre-existing types for both the "a" and the connection, you will have to use the fundep after all
22:48:29 <solidus-river> napping: why, do you see problems writting an AdapterClass that has functions that take DatabaseHandles and use the Connection a from them to do things?
22:48:31 <LordBrain> don't rely on exceptions if you don't have to, as a general rule of thumb.
22:48:40 * hackagebot bff-mono 0.2.2 - "Bidirectionalization for Free" for Monomorphic Transformations  http://hackage.haskell.org/package/bff-mono-0.2.2 (kztk)
22:48:42 <solidus-river> napping i'm making my own types for a
22:48:42 <edwardk> AfC: Presentation only. We don't do proceedings for CUFP
22:48:50 <solidus-river> only using pre-existing types for the connection
22:49:41 <napping> solidus-river: okay, then you should probably switch it around, make the parameter of the class be the connection, and have "data ConnectionParameters conn", then initializeConnection :: ConectionParameters conn -> IO conn
22:49:47 <solidus-river> LordBrain, aye, one of the thigns on the roadmap is to add in better error handling / reporting, but i wnated to cludge thorugh the initial design before refining that
22:49:48 <LordBrain> uh... i used T for type there, not transformer
22:50:06 <LordBrain> perhaps DBError is a better name for that
22:50:13 <napping> then instead of type DBConnection Database = SomeExistingType,
22:50:26 <napping> you'll write something like a data type declaration in the instance
22:50:47 <napping> data ConnectionParameters Connection = MyConnParameters {field1::String, password::String ...}
22:51:37 <ski> jTT : you could use `maybeToList' if you want to use the result in a list context (e.g. list comprehension or other list idiom/monad constructions)
22:51:38 <napping> on the other hand, if different databases take different parameters, you really can't make that part generic anyway
22:51:44 <ski> syrioforel,jTT : also, it's not IRC custom to prepend nicknames with `@' :)
22:52:12 <napping> what parts of the code should be independent of the database?
22:52:19 <LordBrain> he can just have a type function napping... and define it in the instance
22:53:03 <solidus-river> there are 4 main pieces to the code
22:53:30 <solidus-river> theres a set of yaml files on disk somewhere that define migrations and connection info / db type
22:53:33 <napping> You wouldn't need tricky stuff if only connection was mentioned in the type class, and you left initializeConnection to the DB-specific code
22:54:00 <solidus-river> a module that loads that into types
22:54:01 <napping> okay, so then maybe the method should be more like Yaml -> IO connection
22:54:18 <solidus-river> a module that takes that loaded config and initializes a connection to the database
22:54:31 <solidus-river> and thne a module that takes a connection to the dtabase and a set of Migration types and runs them
22:55:15 <solidus-river> maybe i'm trying ot modularize too much, the idea was to make it as easy as possible for someone later on to add a new adapter / database type for any data store
22:55:38 <pharaun> Is there a recommended way to deal with Random? I've found several libraries and approaches and i was wondering which was the most common/recommended approach?
22:56:40 <LordBrain> what is Q2? it appears after the definition of the DatabaseHandler class.
22:58:41 * hackagebot optparse-applicative 0.9.0 - Utilities and combinators for parsing command line options  http://hackage.haskell.org/package/optparse-applicative-0.9.0 (PaoloCapriotti)
22:58:55 <solidus-river> i think my heads starting to wrap around TypeFamilies
23:00:35 <napping> sounds like the parts are running a migration giving an existing connection and some backend-independent description of the migration
23:00:51 <napping> and opening a database connection using a file giving connection parameters
23:03:28 <solidus-river> napping: yes! thats pretty much it, i'm trying to make a database schema versioning system, initially targetting postgres that doesnt require a whole ORM or nasty dsl for the migrations
23:03:41 <solidus-river> just yaml fields with whatever language the data store recognizes inside
23:04:30 <napping> sounds like you're planning to end up with your own nast migration dsl
23:05:33 <solidus-river> napping: heh, i guess, but one i only have to use in the program, not one that anyone writing migrations will have to worry about
23:05:53 <napping> what do they write migrations in?
23:05:54 <solidus-river> and definitly not as overbearing as an ORM
23:06:17 <solidus-river> the migrations are just yaskl files with fileds for up / down that have a block of Text
23:06:34 <solidus-river> so for Postgres they write them in pSQL
23:06:37 <napping> if it's DB-specific code that you don't try to understand or check, you might as well just cat files to the database's repl
23:06:57 <solidus-river> napping: but then i wouldn't be learning haskell through the project
23:07:34 <solidus-river> the goal was to provide a "dumb" generic database cluster versioning system and learn some more in depth FP
23:08:42 * hackagebot io-streams 1.1.4.4 - Simple, composable, and easy-to-use stream I/O  http://hackage.haskell.org/package/io-streams-1.1.4.4 (GregoryCollins)
23:11:29 <solidus-river> how do i add class constraints to fields in a record type?
23:11:49 <solidus-river> (Class a) => a
23:11:52 <napping> fields that are functions?
23:13:33 <napping> usually you just don't
23:14:01 <napping> if the type variables are type parameters of the record, than any function taking the record that needs some constraints can ask for those constraints itself
23:14:30 <napping> if you mean functions inside, then you need RankNTypes, and can write data Record = Record {fun :: forall a . (Class a) => a -> a -> Int} or whatever
23:16:04 <solidus-river> napping, yeah i just enabled RankNTypes and things are working
23:16:30 <solidus-river> but now i've gone from skirting on the edge of oblivion to jumping off a cliff and am swiftly headed for pain
23:16:39 <solidus-river> i think its time i stop and read up more on type families
23:17:03 <napping> I think you can drop them entirely for your application
23:17:25 <napping> just specialize the argument to initialize to your yaml type, and for migration to your Text
23:29:42 <etrepum> bitemyapp: https://github.com/etrepum/ghc-dot-app/releases/tag/v7.8.2-r0 – I think that's signed, haven't tried it on another computer yet
23:32:07 <solidus-river> http://lpaste.net/104495
23:32:13 <solidus-river> hmm, i'm ia bit further
23:34:36 <solidus-river> oh actually i think that makes sense, it doesnt have enough information to deduce that type yet
23:48:47 * hackagebot fay 0.20.0.4 - A compiler for Fay, a Haskell subset that compiles to JavaScript.  http://hackage.haskell.org/package/fay-0.20.0.4 (AdamBergmark)
23:49:22 <solidus-river> thanks all for the help i'm out to recharge
