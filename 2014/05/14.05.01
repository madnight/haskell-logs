00:08:51 * hackagebot Elm 0.12.1.2 - The Elm language module.  http://hackage.haskell.org/package/Elm-0.12.1.2 (EvanCzaplicki)
00:08:51 * hackagebot Elm 0.12.1.3 - The Elm language module.  http://hackage.haskell.org/package/Elm-0.12.1.3 (EvanCzaplicki)
00:34:13 <l0cust> Hey, does anyone here know anything about semiring geometry?
00:34:38 <l0cust> I have a library I'm working on, and I've sort of gotten to the point where it's beyond my skill level
00:35:02 <magthe> I'm trying to rewrite a few shell scripts I use regularly using shelly... stumbling on how to deal with here documents (e.g. cat <<EOF\n...\nEOF)... any good ideas?
00:35:03 <l0cust> And really I just need other people's advice
00:40:11 <pavonia> magthe: What's the problem in particular?
00:41:49 <pavonia> l0cust: Are you asking for advice on the math or the Haskell part?
00:42:17 <l0cust> Both, really
00:42:52 <l0cust> pavonia: The trouble I'm having is mostly on deciding which functions I need to implement, and how to design said functions
00:43:11 <l0cust> pavonia: Like, do I need dinfty, infdinf, etc?
00:43:54 <pavonia> Oh well, I don't know anything about semiring geometry :p
00:44:12 <l0cust> pavonia: thanks anyway :)
00:45:50 <magthe> pavonia: just looking for a nice way to deal with temporary config files that in my shell scripts are generated with HEREDOCs
00:47:08 <pavonia> Do you need special temp files? There's a function to create simple temp files in the base libs
00:47:41 <ZNW> Guys, is there a short-circuit function for list ? like:  [] `or` [1] = [1] , [1] `or` [2]  = [1] ?
00:48:15 <l0cust> ZNW: I think you are looking for pattern guards
00:48:31 <magthe> pavonia: nope, dealing with tempfiles I've got covered already... it's the contents of those tempfiles
00:48:50 <pavonia> > [] <|> [1]
00:48:51 <lambdabot>  [1]
00:48:55 <pavonia> > [1] <|> [2]
00:48:57 <lambdabot>  [1,2]
00:49:03 <pavonia> :(
00:49:22 <ZNW> <|> will add to non-empty list
00:50:43 <pavonia> > (\x y -> maybeToList $ listToMaybe x <|> listToMaybe y) [] [1,2,3]
00:50:44 <lambdabot>  [1]
00:50:51 <pavonia> > (\x y -> maybeToList $ listToMaybe x <|> listToMaybe y) [4] [1,2,3]
00:50:52 <lambdabot>  [4]
00:51:10 <pavonia> @pl (\x y -> maybeToList $ listToMaybe x <|> listToMaybe y)
00:51:10 <lambdabot> (maybeToList .) . (. listToMaybe) . (<|>) . listToMaybe
00:56:24 <l0cust> It occurs to me that 2:00 AM is probably the worst time to ask for help on Reddit
00:56:34 <l0cust> @time pavonia
00:56:36 <lambdabot> Local time for pavonia is Donnerstag, 1. Mai 2014 09:55:05
00:56:52 <l0cust> @time l0cust
00:56:55 <lambdabot> Local time for l0cust is Thu May  1 01:54:58 2014
00:57:14 <pavonia> I'm in the future already \o/
00:57:34 <l0cust> Is that what you damn commies are calling europe now
00:57:53 <pavonia> What?
00:58:19 <l0cust> pavonia: In America, we refer to foreigners as "damn commies."
01:05:18 <Iceland_jack> johnw, identity: https://www.fpcomplete.com/user/icelandj/Pattern%20synonyms :) I wrote that introduction
01:22:03 <boothead> Hi folks, it looks like the internals of haskell-mode have changed recently, is there still a way to set command you want to run for interactive mode?
01:28:17 <Marquis_> good morning. may i ask a question?
01:30:54 <lyxia> Marquis_: Yes you can.
01:31:25 <Marquis_> i am currently writing my bachelor thesis. my task is to cluster a statefull graph
01:32:54 <Marquis_> so i wrote a lexer to get the informations i need looking like this : [[Int 3,Int 0,Atom "resrt",Int 4,S "'ROUTES'",Atom "resbl",Int 118,S "'BLOCKS'",Atom "rsrtbl",S "'OCC'",S "'TRK'",Atom "frm",S "'LBT'"], ["another similar list"]]
01:33:10 <Marquis_> the first integer is always the index of the state
01:33:47 <Marquis_> i am a little concerned about the runtime and am now wondering if it might help to use arrays, hash maps, dictonaries or just stick to the list of list structure
01:33:52 <Guthur> I want to find all the multiples of x below y, I try the code below which i think in theory should work but i get an ambiguous type error...
01:33:55 <Guthur> let foo x y = [a * x | a <- [0..floor((y - 1)/x)]]
01:34:07 <Guthur> any suggestions?
01:38:50 <lyxia> Marquis_: It depends a lot on what you plan to do with that data, algorithms you are going to use, etc.
01:39:34 <ClaudiusMaximus> Guthur: 'a' is an integral type because floor gives an integral result, while 'x' is forced to be fractional by (/), moreover (*) requires the same type for both arguments - probably you need more fromIntegral
01:40:21 <nclarke> Guthur: Or use `div` rather than (/)
01:40:25 <Marquis_> Guthur: multiples x y = [a * x | a <- [1..y]]
01:40:26 <nclarke> Which does integral division
01:40:43 <nclarke> Then you can drop the 'floor'
01:41:12 <nclarke> Marquis_ That does something different - gives you all the multiples up to 'xy' rather than up to y
01:41:43 <Marquis_> yeah i see... sorry
01:42:11 <nclarke> let foo x y = [a * x | a <- [0..(y - 1) `div` x]]
01:42:14 <nclarke> Should work
01:42:54 <nclarke> @let foo x y = [a * x | a <- [0..(y - 1) `div` x]]
01:42:55 <lambdabot>  Defined.
01:43:01 <nclarke> > foo 3 19
01:43:03 <lambdabot>  [0,3,6,9,12,15,18]
01:43:12 <nclarke> > foo 2 7
01:43:14 <lambdabot>  [0,2,4,6]
01:43:35 <nclarke> foo 2 (-9)
01:43:43 <nclarke> > foo 2 (-9)
01:43:44 <lambdabot>  []
01:43:58 <nclarke> > foo (-2) (-9)
01:44:00 <lambdabot>  [0,-2,-4,-6,-8,-10]
01:44:12 <nclarke> Okay, so it gets a bit confused with negatives...
01:46:22 <v-husobh> why is the base package and many other standard packages not installed with -O2 by default?
01:47:01 <Marquis_> lyxia: i want to use k means algorithm and later EM
01:55:11 <boothead> Is there an operation to collapse a list of arrows to a single arrow? I'm looking for foldr (<+>) <something> [Arrow a b] I think - but I don't know what to use for something...
01:56:18 <shachaf> With ArrowPlus, not e.g. composition?
01:57:08 <shachaf> Well, :i (<+>) tells me that it's a method of ArrowPlusus, which has superclass ArrowZero. :i ArrowZero tells me that it has method zeroArrow :: Arrow a => a b c
01:57:09 <boothead> Yeah I'm using HXT and I want to build an ArrowPlus from a list of selectors
01:57:36 <boothead> shachaf, that sounds promissing!
01:59:53 <merijn> shachaf: Is there any difference between ArrowPlus and Category?
02:00:00 <merijn> o
02:00:09 <merijn> I guess ArrowZero is not id
02:00:12 <shachaf> Is there much similarity?
02:00:14 <merijn> nevermind
02:00:31 <shachaf> I suppose you could say that ArrowPlus is a bit like Alternative where Category is a bit like Applicative.
02:16:56 <ngzhian> can a `where` only occur at the end of a function definition?
02:17:21 <shachaf> "where" is bound to "=" or "->"
02:17:30 <shachaf> It's not an expression of its own.
02:19:36 <pavonia> > case 1 of { 1 -> res } where res = 2
02:19:37 <lambdabot>  <hint>:1:24: parse error on input ‘where’
02:19:47 <pavonia> > case 1 of { 1 -> res where res = 2 }
02:19:48 <lambdabot>  2
02:19:55 <pavonia> oh
02:25:51 <merijn> Note that said = could be in another where or let, of course
02:29:29 <m09> I've a gtk program and I was wondering: what is the best way to store refs to widgets? I need to access them from many points in my codebase and yet it's quite oring to pass the refs around. Is there a better way?
02:31:41 <pavonia> m09: I don't know if there's a better way but that's what is usually done
02:32:22 <haskellephant> Here is a fun quiz: Does the following function always terminate "f n x = if x > n then 0 else f n (x+1)" . Simple enought but it took me a while (longer than I want to admit) to come up with the answer.
02:32:23 <m09> ok
02:32:53 <pavonia> That is storing all GUI element in a record and have a ref to this value
02:33:02 <seye> is it true that if you have  x = 3 + 4 (or any other expression with no parameters) as a top level binding, it will get evaluated at most once?
02:33:50 <m09> pavonia: I see. I'll use this approach, it'll already reduce signature impact :) thanks
02:34:03 <pavonia> np
02:34:10 <haskellephant> seye: no, there shouldn't be any such guarantee, but for your concrete example 3 + 4 should be evaluated at compiletime.
02:37:52 <merijn> haskellephant: That function doesn't always terminate, no
02:38:10 <haskellephant> merijn: Jupp, but what is the counterexample?
02:38:27 <seye> Ok, that makes sense, but if x was a more complicated expression (still with no inputs) that the compiler couldn't evaluate, and you had a list of them [x, x]. Would you have two thunks or two pointers to the same thunk?
02:38:28 <merijn> haskellephant: n == maxBound
02:38:40 <merijn> seye: Pointers to the same thunk
02:39:09 <merijn> seye: In general, GHC (not haskell) guarantees that every let/where-bound name is only evaluated once
02:39:10 <shachaf> Did you say x is an expression?
02:39:11 <seye> and when evaluted, would the indirection be removed or would it still be pointers to the result?
02:39:40 <shachaf> Oh, "x = [your expression]".
02:39:41 <seye> i was talking about a top level binding
02:40:00 <shachaf> Top level bindings can be special.
02:40:01 <merijn> seye: Right, so what happens is that GHC allocates a closure for "3 + 4" and "[x, x]" has two pointers to that closure (let's ignore the laziness of [x, x] for now)
02:40:16 <shachaf> Look up CAFs.
02:41:28 <merijn> seye: Once the closure of "3 + 4" is evaluated, the pointer "x" will point to the result (there may be an indirection, but this will be eliminated at the next GC)
02:42:30 <merijn> seye: btw, what I said applies to let/where bound names anywhere, not just top level. Top level behaves a little different, but afaik not that much
02:43:19 <seye> merijn: there will always be at least one level of indirection though?
02:44:02 <merijn> seye: Well, depends on what level of detail were talking about and compiler optimisations, etc.
02:44:52 <seye> fair enough :) - the main takeaway for me is that thunks do get shared (as seemd reasonable) - thanks
02:45:01 <merijn> seye: For example "data Foo = Foo Int" <- here a "Foo" closure will have a pointer to an Int (which will have an unboxed (i.e., machine) int inside)
02:46:14 <merijn> seye: However, it's possible to unpack datatypes so that instead of a pointer Foo would directly have the "Int" value inside, but this depends on stuff like the size of a pointer vs the size of Int and all sorts of low level details
02:48:12 <seye> clever stuff! - thanks
02:53:08 <Guthur> sorry i stepped out there
02:53:16 <Guthur> nclarke: div is a perfect solution
02:53:32 <Guthur> thanks all for the clarifications
02:56:10 <ngzhian> shachaf: thanks!
02:56:22 <Guthur> nclarke: i was not familiar with [0..(y - 1) `div` x] i used [0..div (y -1) x]
02:56:39 <Guthur> i assume the `div` is some infix syntactic sugar
02:58:04 <Guthur> i mostly use CL so div x y feels intutive enough
02:58:12 <merijn> Guthur: *any* prefix function can be used infix when quoted with backticks
02:58:15 <Kinnison> `foo` is applying foo in an infixy way yes
02:58:20 <merijn> > elem 1 [1..10]
02:58:21 <lambdabot>  True
02:58:26 <merijn> > 1 `elem` [1..10]
02:58:28 <lambdabot>  True
02:58:58 <merijn> Guthur: Similarly, any operator can be made prefix by surrounding with parenthesis
02:59:01 <merijn> > (+) 1 2
02:59:02 <lambdabot>  3
02:59:14 <merijn> > ((+) 1 2) -- look ma, I can write Lisp!
02:59:14 <Kinnison> > (+ 1 2)
02:59:15 <lambdabot>  can't find file: L.hs
02:59:15 <lambdabot>  3
02:59:24 <Guthur> ok, thanks for the clarification
02:59:32 <merijn> Kinnison: That's a syntax error :)
02:59:33 <bernalex> is there a [(a -> b)] -> a -> b? or a [(a -> a)] -> a -> a
02:59:36 <Kinnison> merijn: :-(
02:59:47 <merijn> bernalex: "foldr (.) id"?
02:59:57 <bernalex> so I could do e.g. fs = [(+1), (+2), (+3)] and apply those to a function
03:00:06 <merijn> :t foldr (.) id
03:00:06 <bernalex> s/function/value
03:00:07 <lambdabot> [b -> b] -> b -> b
03:00:14 <Kinnison> merijn: But I can do (+ 1) 2
03:00:22 <Kinnison> merijn: so partial application works?
03:00:26 <merijn> Kinnison: Right, because oeprator slicing is special
03:00:41 * Kinnison decides to not pretend to understand :-)
03:00:48 * Kinnison drinks tea and writes python :-(
03:00:57 <merijn> Kinnison: Basically, partial application like that is special cased
03:01:35 <merijn> Well, depends on what you mean by "special case", I guess. It's just that that was defined to work and (+ 1 2) was not :)
03:01:36 <bernalex> merijn: oh, I see. thanks!
03:01:50 <bernalex> so there's no built-in function to do this?
03:02:03 <bernalex> I don't think (foldr (.) id) fs a looks very nice
03:02:05 <ClaudiusMaximus> (+ 1 2) would be \x -> x + 1 2 which applies fromInteger 1 to fromInteger 2, so it might be made to work with crazy Num instances
03:02:28 <merijn> bernalex: So define a name "applyList = foldr (.) id"?
03:02:51 <bernalex> merijn: that's a waste for doing it one time only in a paper
03:03:19 <merijn> bernalex: Then I wouldn't bother and just use that
03:03:23 <nclarke> foldr1 (.) will do it as well
03:03:25 <bernalex> merijn: I agree
03:03:29 <nclarke> You can drop the 'id'
03:03:56 <ClaudiusMaximus> > foldr1 (.) [] 3
03:03:58 <lambdabot>  *Exception: Prelude.foldr1: empty list
03:04:14 <merijn> nclarke: Only if the list is nonempty
03:04:17 <nclarke> True
03:04:31 <merijn> I don't like writing broken code unless there's a good reason
03:04:32 * hackagebot mono-traversable 0.5.0 - Type classes for mapping, folding, and traversing monomorphic containers  http://hackage.haskell.org/package/mono-traversable-0.5.0 (MichaelSnoyman)
03:04:59 <supki> :t ala Endo foldMap
03:05:00 <lambdabot> Foldable t => t (a -> a) -> Unwrapped (Endo a)
03:05:09 <bernalex> right now I have "fs & foldr (.) id $ a".
03:05:23 <bernalex> however, the list is nonempty, I guess.
03:05:31 <bernalex> the emptylist is patternmatched away at this stage
03:05:46 <bernalex> so fs & foldr1 (.) $ a
03:06:08 <bernalex> still looks a bit black magic-y, but I'll add a comment rather than defining the function, heh.
03:06:13 <merijn> I think using both & and $ in the same line is a way bigger issue than the foldr (.) id is
03:06:26 <merijn> Why not just "foldr (.) id fs $ a"?
03:06:36 <bernalex> merijn: why is that an issue?
03:06:39 <nclarke> Actually, easiest would probably be `mconcat`
03:06:39 <merijn> Why not just "foldr (.) id fs a"?
03:06:54 <merijn> bernalex: Because it looks really confusing and unclear
03:07:05 <bernalex> at this stage I can just do foldr1 (.) fs a
03:07:15 <merijn> bernalex: What's the relative fixity of & and $? Especially for a paper & is not "standard" haskell
03:07:20 <bernalex> not that I think it's very confusing. but I'm not writing it for me only, so I can sure change it.
03:07:27 <bernalex> merijn: & is 1 more than $
03:07:30 <merijn> I would not assume any reader knows &
03:07:30 <nclarke> >mconcat [id, (*2)] $ 3
03:07:40 <merijn> bernalex: You know that, I do not and neither does your reader
03:07:43 <Maior> :t (&)
03:07:44 <lambdabot> a -> (a -> b) -> b
03:08:01 <bernalex> merijn: exactly. I already said I'll change it. relax. :-)
03:08:02 <merijn> Most importantly, & seems gratuitously unnecessary in that example
03:08:13 <merijn> bernalex: :)
03:09:02 <jle`> nclarke: the default monoid instance on functions isn't composition
03:09:11 <jle`> it is similar to an applicative instance
03:09:25 <jle`> there is a wrapper though that provides function composition as the monoidic operation
03:09:33 * hackagebot conduit-combinators 0.2.5.1 - Commonly used conduit functions, for both chunked and unchunked data  http://hackage.haskell.org/package/conduit-combinators-0.2.5.1 (MichaelSnoyman)
03:09:34 <nclarke> Oh, really. That's a bit annoying
03:09:43 <jle`> well, you can only pick one default instance
03:10:17 <jle`> and besides, not all functions form a monoid under composition, only endofunctions (a -> a)
03:10:32 <jle`> if you allow any (a -> b), you have a category woo hoo
03:11:11 <nclarke> I suppose that's a fair point. The current instance does allow consistency across all functoins
03:11:14 <nclarke> Fair enough
03:11:24 <jle`> > let f = foldMap Endo [id, (*3), (+4), (^2)] in appEndo f 7
03:11:25 <lambdabot>  159
03:11:44 <jle`> data Endo a = Endo { appEndo :: a -> a }
03:11:48 <jle`> er that should be a newtype
03:12:41 <jle`> the default instance is very much like the applicative instance for functions and it can be handy.  i can't say i remember the last time i've used it in real life tho
03:12:50 <jle`> but i use the applicative instance all the time so
03:14:32 <jle`> > let f = show; g = const "hello" in (f <> g) 7
03:14:34 <lambdabot>  "7hello"
03:14:35 * hackagebot classy-prelude 0.9.1 - A typeclass-based Prelude.  http://hackage.haskell.org/package/classy-prelude-0.9.1 (MichaelSnoyman)
03:14:37 * hackagebot classy-prelude-conduit 0.9.1 - conduit instances for classy-prelude  http://hackage.haskell.org/package/classy-prelude-conduit-0.9.1 (MichaelSnoyman)
03:14:39 * hackagebot classy-prelude-yesod 0.9.1 - Provide a classy prelude including common Yesod functionality.  http://hackage.haskell.org/package/classy-prelude-yesod-0.9.1 (MichaelSnoyman)
03:14:41 * hackagebot streaming-commons 0.1.2.1 - Common lower-level functions needed by various streaming data libraries  http://hackage.haskell.org/package/streaming-commons-0.1.2.1 (MichaelSnoyman)
03:14:43 * hackagebot conduit 1.1.1.1 - Streaming data processing library.  http://hackage.haskell.org/package/conduit-1.1.1.1 (MichaelSnoyman)
03:14:49 <jle`> > let f = show; g = const "hello" in (liftA2 (<>) f g) 7
03:14:50 <lambdabot>  "7hello"
03:16:14 <Jookia> Hey guys! Long time no see.
03:19:37 * hackagebot conduit-extra 1.1.0.3 - Batteries included conduit: adapters for common libraries.  http://hackage.haskell.org/package/conduit-extra-1.1.0.3 (MichaelSnoyman)
03:20:11 <fizruk> > show <> const "hello" $ 7
03:20:12 <lambdabot>  "7hello"
03:22:46 <Jookia> I have the signature 'liftMaybe :: Monad m => (a -> m b) -> Maybe a -> m (Maybe b)', and AFAIK it's identical to mapM
03:23:52 <merijn> Jookia: Looks like it, yes :)
03:24:10 <Jookia> merijn: Right, but if I replace 'liftMaybe f' in my code with 'mapM f', I get an error?
03:24:28 <merijn> Jookia: Probably because you have Prelude.mapM rather than Traversable.mapM
03:24:31 <merijn> :t mapM
03:24:32 <lambdabot> Monad m => (a -> m b) -> [a] -> m [b]
03:24:35 <merijn> :t T.mapM
03:24:36 <lambdabot> (Traversable t, Monad m) => (a -> m b) -> t a -> m (t b)
03:26:37 <Jookia> Yay
03:26:44 <Jookia> I almost had it by myself
03:28:09 <fizruk> :t traverse
03:28:10 <lambdabot> (Traversable t, Applicative f) => (a -> f b) -> t a -> f (t b)
03:29:05 <Jookia> Well that fixed a few of my problems :D
03:29:47 <Jookia> and solves the mystery of 'how do i map stuff inside monads'
03:31:04 <merijn> Jookia: I highly recommend taking a look at Data.Traversable and Data.Foldable for more generic versions of some stuff in prelude
03:32:07 <fizruk> :t extend
03:32:08 <lambdabot> Not in scope: ‘extend’
03:34:22 <bddy> Hello. What could be the problem? Arch linux. http://lpaste.net/103467
03:34:45 * hackagebot hcwiid 0.0.2 - Library to interface with the wiimote  http://hackage.haskell.org/package/hcwiid-0.0.2 (IvanPerez)
03:34:47 <bddy> which cabal says /usr/bin/cabal
03:35:12 <bddy> ah probably I need to run it from root or something
03:35:44 <nclarke> Ah, no
03:35:55 <nclarke> You need to prepend $HOME/.cabal/bin to your PATH
03:36:14 <nclarke> Which will let the cabal installed by cabal itself take precedence over the global one
03:36:19 <bddy> Aha, I forgot to fdo this, thanks
03:38:04 <eizo> could someone explain to me the yoneda lemma: Nat(h^A,F) = F(A), when F is the list functor and A is Int? we get that list of integers are isomorphic to "natural transformations" from functions over integers to lists; not sure i get it
03:40:18 <merijn> fizruk: Are you look for extend from the comonad package?
03:40:32 <merijn> fizruk: i.e. "extend :: Comonad m => m a -> m (m a)"?
03:40:44 <fizruk> :t Control.Comonad.extend
03:40:45 <lambdabot> Control.Comonad.Comonad w => (w a -> b) -> w a -> w b
03:40:53 <fizruk> :t Control.Comonad.duplicate
03:40:53 <bernalex> are typeclasses isomorphic to ungeneralisable Hindley-Milner?
03:40:54 <lambdabot> Control.Comonad.Comonad w => w a -> w (w a)
03:41:07 <merijn> oh, confusing extend and duplicate...
03:41:21 <merijn> Anyhoo
03:41:24 <fizruk> merijn: was checking whether lambdabot knows them :)
03:43:22 <bernalex> maybe s/typeclasses/the entirety of haskell's type system. I'm not sure what pwadler means.
03:53:23 <fizruk> eizo: i may be wrong, but… Nat(h^A, F) is essentially ∀B. (A -> B) -> F B ? so in case of lists: ∀X. (Int -> X) -> [X]
03:54:40 <fizruk> eizo: to go from [A] to Nat(h^A, []) we just can do “\f -> map f xs” for all xs :: [A]
03:55:23 <fizruk> eizo: to go backwards we do “\g -> g id” for any g :: Nat(h^A, [])
03:56:48 <fizruk> eizo: so Nat(h^A, []) is something like continuation-like list with “continuations” called for every element
03:58:20 <eizo> fizruk: i didn't get the backward part, g is of type ∀X. (Int -> X) -> [X], but id is Int -> Int
04:00:54 <eizo> fizruk: hm yes you're right in the end we want a [Int] so it makes sense
04:01:22 <eizo> not too familiar with continuations i'd have to look that up
04:02:16 <bddy> Is it possible to put ghc-options -Wall in setup.hs for my executable?
04:02:33 <bddy> Right now I typpe cabal build --ghc-options="-Wall"
04:03:02 <fizruk> eizo: it is forall B. that makes it possible for us to get whatever list we want
04:04:01 <eizo> right, and in particular [Int]
04:04:08 <bddy> Oh, I got it it's executable.ghc_options
04:24:52 * hackagebot ekg-core 0.1.0.0 - Tracking of system metrics  http://hackage.haskell.org/package/ekg-core-0.1.0.0 (JohanTibell)
04:25:02 <ghorn_> is it possible for cabal install to not redirect the build log to a file? i like seeing the progress
04:28:35 <srhb> Isn't that the default when not building in parallel?
04:28:55 <ghorn_> it is, but i'd like to keep building in parallel
04:29:17 <ghorn_> "cabal build" will do parallel builds and also show progress
04:29:53 * hackagebot ekg-statsd 0.1.0.0 - Push metrics to statsd  http://hackage.haskell.org/package/ekg-statsd-0.1.0.0 (JohanTibell)
04:33:01 <ghorn_> i know it's a lot of spew, but I don't have anything better to do that watch it roll by
04:34:54 * hackagebot ekg 0.4.0.0 - Remote monitoring of processes  http://hackage.haskell.org/package/ekg-0.4.0.0 (JohanTibell)
04:42:26 <tibbe> A couple of weeks of hacking and now ekg 0.4 is out! http://blog.johantibell.com/2014/05/ekg-04-released.html
04:44:30 <davean> tibbe: oh thanks tibbe! Was actually just discussing such a change a few days ago.
04:45:02 <tibbe> davean: :)
04:49:27 <hseg> Is there a term for a type constructor that's both a Monad and a Comonad? That is, an endofunctor T such that all T^n are naturally isomorphic?
04:52:34 <ivanm> how does one deal with error messages like "Setup: Error: Could not find module: Data.Vector.Unboxed.Deriving with any suffix: ["dyn_hi"] in the search path: ["dist/build"]" ?
04:54:58 <ghorn_> ivanm: there was a similar problem (maybe the same problem) if you ctrl-c during a build and then try to build again
04:55:24 <ghorn_> ivanm: if that's the case, cabal clean; cabal configure; cabal build should fix it
04:56:03 <ghorn_> ivanm: unless you're doing a clean cabal install, then it's something else
05:04:35 <quchen> hseg: Isn't that only the case for the identity?
05:05:13 <hseg> quchen: No. [] is both monadic and comonadic.
05:05:26 <hseg> quchen: Natural isomorphism /= isomorphism
05:05:56 <quchen> I see. (Although only non-empty lists are comonadic.)
05:06:10 <hseg> quchen: Oops. My mistake.
05:07:48 <hseg> Need to go. Oh well. Thanks!
05:08:12 <quchen> Glad to help! (With my wrong comment)
05:08:13 <quchen> ;-)
05:10:46 <absence> i have a sandboxed project that depends on a package. i needed to change the code of that package, so i downloaded the source, modified it, and used cabal sandbox add-source. how do i reinstall the modified package for use with my project?
05:14:58 * hackagebot language-lua 0.4.1 - Lua parser and pretty-printer  http://hackage.haskell.org/package/language-lua-0.4.1 (OmerAgacan)
05:15:32 <absence> ah, simply cabal install it again :D
05:17:14 <arrnas> parsing a string, count 2 digit gets a digit of lenght 2, how would i do something like count many digit?
05:19:18 <klrr_> i know there's no uninstall for cabal-install, but if you really *need* to uninstall something how would you do that safely? should i unregister package with ghc-pkg and then remove all files? (where are the files, so i dont miss one?)
05:20:48 <nschoe> klrr_, are you in a sandbox ?
05:21:54 <ivanm> not sure if this came through before: how does one deal with error messages like "Setup: Error: Could not find module: Data.Vector.Unboxed.Deriving with any suffix: ["dyn_hi"] in the search path: ["dist/build"]" ?
05:22:10 <quchen> arrnas: `many digit`?
05:22:22 <klrr_> nschoe: nope, but i think i fixed it, simply removed files and used ghc-pkg to unregister
05:24:04 <nschoe> klrr_, yeah that would be my guess too. But if you're in a sandbox, maybe simply delete the sandbox and re-create one (and cabal install --dependencies-only to get back the needed dependencies)
05:24:41 <arrnas> quchen: the string i want to parse can be "100 3" or "10 30" or any other combination, is it possible to count until char ' ' ?
05:25:20 <klrr_> nschoe: oh, not in a sandbox but that will probably be useful when i am, thanks
05:26:09 <nschoe> klrr_, no problem :-) (Although I suggest you switch to sandboxes : changed my life !)
05:26:28 <davd> why do we not have strictness semantics encoded on the type level?
05:26:34 <davd> given the recent discussion about how types guide the implementation this seems beneficial
05:28:48 <klrr_> nschoe: i usually use that but it wont make any difference atm i think, am just installing an executable
05:30:41 <nschoe> klrr_, well, your exe surely depends on libraries : when you install it, it is likely those libraries will be installed on your user db. Whereas if you build / install the exe inside a sandbox, your user db will stay clean (you can then move your executable to you /home/bin/ folder)
05:31:42 <jophish> I have a list of a sum type of various types and I wish to split this into a group of lists each with their own type.
05:31:48 <quchen> davd: Strict data types are standard Haskell, using "!" like "data Tuple a b = Tuple !a !b
05:31:54 <quchen> "
05:31:57 <jophish> What's the most idiomatic way of doing this, a set of filters?
05:32:45 <jophish> I experimented doing this with a writer monad, writing to ([T1], [T2], [T3])
05:33:06 <quchen> jophish: The fastest (input-wise) way would probably be "groupBy p . sort".
05:33:58 <jophish> quchen: really? That would be O(nlogn)
05:34:09 <jophish> but just iterating over them and bucketing them is linear
05:34:15 <quchen> I meant "input-wise" in the sense of typing the code.
05:34:23 <jophish> ah I see
05:34:46 <jophish> There isn't an ordering between them either, so sort wouldn't work
05:34:54 <ClaudiusMaximus> @src partitionEithers
05:34:54 <lambdabot> Source not found. Maybe you made a typo?
05:35:27 <quchen> You can always write that ordering for a sum type. Remember you don't need to truly sort it, just bring the constructors close together.
05:35:44 <quchen> "sortBy compareConstructors" style
05:36:33 <quchen> You could probably also solve the problem with some functions from Data.Map (the "accum" ones), but creating the Map of things is n*log(n) as well.
05:37:51 <jophish> ClaudiusMaximus: partitionEithers is closest to what I'm doing at the moment
05:38:37 <quchen> Problem is you would have to write that for each data type you use separately.
05:38:45 <quchen> But if you only need it once, copy partitionEithers.
05:39:30 <tdammers> grrrrr... why does System.Process use *String* for its stdin/stdout?
05:39:52 <jophish> yeah, it's just for this particular case, there are more cases than 2, but that's no problem
05:40:01 * hackagebot MFlow 0.4.5.2 - stateful, RESTful web framework  http://hackage.haskell.org/package/MFlow-0.4.5.2 (AlbertoCorona)
05:40:03 <jophish> Thanks, quchen, ClaudiusMaximus
05:42:01 <geekosaur> tdammers, because there's no right and portable answer
05:42:24 <tdammers> geekosaur: yeah, but why not ByteString?
05:42:41 <tdammers> geekosaur: the way it is, I can't pipe bytestrings into subprocesses directly
05:43:04 <Reite> I think you can with the createProcess function?
05:43:09 <nclarke> http://hackage.haskell.org/package/process-extras-0.2.0/docs/System-Process-ByteString.html
05:45:40 <geekosaur> that module doesn't address I/O, it requires you to set it up manually. (which is correct for a low level interface)
05:46:52 <geekosaur> again, there is no correct and portable answer; worse, the answer changes depending on exactly what program you are using as the subprocess, since some want ByteString and some want Text (and some are probably inconsistent and use different things at different times)
05:49:56 <tdammers> well, in my case, the subprocess is a Python script that wants raw bytes
05:50:24 <tdammers> nclarke: cool, that sounds about right
05:50:35 <tdammers> wonder why I hadn't found it before
06:01:26 <tdammers> yep, that works
06:01:28 <tdammers> nice
06:18:38 <exicer> Stupid question - what is the easiest way to convert an Int to a Text ?
06:19:22 <nclarke> pack . show would probably work
06:19:32 <nclarke> > Text.pack . show $ 5
06:19:34 <lambdabot>  Not in scope: ‘Text.pack’
06:20:14 <exicer> nclarke: Yup, that works. For some reason I forgot about show..
06:20:16 <exicer> Cheers.
06:24:49 <srhb> @hoogle Show a => a -> Text
06:24:50 <lambdabot> Data.Text.Lazy unfoldr :: (a -> Maybe (Char, a)) -> a -> Text
06:24:50 <lambdabot> Data.Text unfoldr :: (a -> Maybe (Char, a)) -> a -> Text
06:24:50 <lambdabot> Debug.Trace traceShow :: Show a => a -> b -> b
06:24:53 <srhb> Funny.
06:24:59 <srhb> pack . show it is
06:27:32 <k_bx> Can anybody help me with simple lens-question please? Why do I need to make that field type a monoid? http://lpaste.net/4851330066669371392
06:29:09 <k_bx> I mean, should always type of thing you're trying to get from ^. be a monoid?
06:29:44 <napping> no, not necessarily
06:29:49 <supki> k_bx: because the Applicative instance for Const needs the Monoid constraint
06:30:05 <supki> k_bx: basically you need Monoid if the optic can fail
06:30:17 <supki> or return multiple results
06:30:33 <k_bx> supki: but it's a field of a record. Am I using the wrong operator then?
06:30:37 <napping> It's something to do with having multiple constructors
06:31:07 <napping> Ah, because there's also the "UnknownLogRecord", there's no way to know you'll actually have any of those fields
06:31:22 <k_bx> napping: that makes sense! Thank you.
06:31:28 <dwcook> The magic here is likely in makeLenses
06:31:30 <napping> and the Monoid constraint would let it return mempty when you try to do a lookup into an UnnownLogRecord
06:31:50 <Cale> dwcook: Yeah, I think there's something weird taking place in makeLenses too
06:32:03 <Cale> Well, hmm
06:32:13 <napping> You might be able to use the "declare" version to see what's generated more easily
06:32:32 <supki> makeLenses generates traversals for partial accessors
06:32:56 <Cale> Yeah, the type of lrMessageStructure indicates that it's a traversal
06:32:58 <supki> k_bx: if you lookup with ^?/preview you'll get Maybe result
06:33:00 <k_bx> So, should I somehow generate a prism _LocRecord to be sure it's LogRecord constructur first?
06:33:33 <supki> no
06:33:57 <k_bx> In that piece of code I'm writing I'm only interested in LogRecord constructor case
06:34:01 <k_bx> That's why I'm suggesting it
06:34:02 <supki> well, you can, but you'll still get a traversal
06:34:08 <k_bx> I see
06:34:35 <Cale> What's the type of  get lrMessageStructure?
06:34:46 <Cale> er, view rather
06:35:08 <dwcook> @type view
06:35:09 <lambdabot> MonadReader s m => Getting a s a -> m a
06:35:14 <k_bx> Cale: it's in paste http://lpaste.net/4851330066669371392
06:35:20 <Cale> Yeah, I want to see how it specialises
06:35:32 <Cale> uh, it is?
06:35:53 <supki> k_bx: if you really sure it's always LogRecord you can use  singular  to convert a traversal into lens
06:36:40 <Cale> k_bx: Try simply: :t view lrMessageStructure  and see what type that has
06:37:04 <Cale> Do you get the same error?
06:37:04 <k_bx> Cale: gives "non monoid" error
06:37:06 <Cale> okay
06:38:06 <Cale> There must be an instance in scope which would let it unify Getting a s a with the type of lrMessageStructure when that monoid instance is present
06:39:40 <supki> Monoid e => Applicative (Const e)
06:40:10 <k_bx> supki: (undefined :: LogRecord) ^. (singular lrMessageStructure) worked! Thanks. I'm not sure it's always LogRecord, so would be better to skip other cases somehow, but I can work with this for now also.
06:40:52 <supki> k_bx: see ^?/preview
06:41:32 <k_bx> supki: ah, so ^? would work (return Nothing) if constructor is UnknownLogRecord?
06:41:36 <supki> yep
06:41:58 <k_bx> Cool. I thought it's why Prisms are for (go to constructors). Will read docs :)
06:42:09 <k_bx> s/why/what/
07:00:22 <vanila> Does House or any other haskell OS self host?
07:01:05 <haasn> self-host?
07:01:27 <vanila> well it should be able to compile all the source code, and then install itself onto another system
07:03:02 <haasn> I guess that depends mainly on whether GHC itself runs on House. I guess it should, perhaps not very easily
07:07:02 <napping> k_bx: a Prism would let you go from your LogRecord to a single-constructor type equivalent to the LogRecord case, and that would get lenses for all fields
07:07:36 <napping> Or, you could drop the "UnknownLogRecord" case and use (Either String LogRecord) for that?
07:08:28 <k_bx> napping: well I'm interested in "doing something if it's LogRecord constructor, and that field is Just MessageStructure", so I thought single-constructor type equivalent is what I want
07:10:19 <k_bx> napping: you're right regarding using Either, might be a good idea
07:21:05 <benzrf> is there a way in reactive-banana to actually make a behavior out of a function of time
07:21:11 <benzrf> i.e. something like
07:21:26 <benzrf> quadratic = fromFunction $ \time -> time^2
07:22:31 <lornaevo> Good Morning
07:22:46 <k_bx> napping: making it "Either" was also a good idea, since it would not let me use "^." with all those fields that do have a monoid instance (like strings), so now I first explicitly deconstruct Either before doing something
07:23:11 <benzrf> k_bx: explicit deconstruction???
07:23:13 <napping> you could also use the prisms for the either constructor
07:23:13 <benzrf> why not prisms
07:23:53 <napping> That should give you compositions no worse than the traversals you had been getting for the named fields
07:23:53 <k_bx> benzrf: I mean, I had two paths in code, one putting error-log saying "spotted unknown message", another doing something on "Right" value. Would use prism if I'd need only one of those. Right?
07:24:18 <napping> or the option to unwrap all the Either's at once, have just valid entries, and know you can use the lenses as lenses
07:24:21 <benzrf> k_bx: something like that
07:24:33 <benzrf> k_bx: to be precise, a prism comes with failure & review
07:24:37 <napping> If you have separate paths in the code, doing a case on the Either sounds find to me
07:24:43 <benzrf> napping++
07:35:19 <simon_> Is it possible to create a field named "type" in a Data declaration in Haskell? I understand that "type" is a keyword in haskell and therfore maybe not so good to use in a data declaration, but i use Aeson and Generics to convert json to Haskell data, and it have worked very well until i now try to parse a field in json named "type". Or if its possible to get Aeson to convert the json field "type" to some other name in Haskell without h
07:36:18 <tdammers> you can adjust the options you pass to deriveJSON, or you can provide custom ToJSON/FromJSON instances
07:36:41 <dwcook> simon_, you cut off at "without h"
07:36:49 <dwcook> Anyway, no, a field cannot be named type
07:37:19 <tdammers> one of the options you can pass to deriveJSON is a function that maps field names to JSON keys
07:39:33 <simon_> dwcook: the rest of the message: Haskell without having to scrap Generics for the rest of the fields? see code/error  here:http://lpaste.net/103469
07:40:22 <simon_> tdammers: i will take a look at deriveJSON and see if fits my needs
07:40:55 <benzrf> hey, how can i find out the mouse position
07:41:01 <benzrf> or register a handler for when it moves
07:44:38 <Maior> @hoogle String -> Double
07:44:39 <lambdabot> Prelude error :: [Char] -> a
07:44:39 <lambdabot> Debug.Trace trace :: String -> a -> a
07:44:39 <lambdabot> Network.BufferType buf_fromStr :: BufferOp a -> String -> a
07:44:58 <Maior> um, any tips on ^ please?
07:45:15 <vanila> > read "3.14159" :: Double
07:45:17 <lambdabot>  3.14159
07:46:18 <Maior> ...thank you!
07:46:29 <bddy> Why does this definition say parse error? f x:[]   = (1, [x]) I'm trying to return a tuple from a function
07:46:44 <park> brackets around the (x:[])?
07:46:46 <dwcook> bddy, (x:[])
07:46:56 <bddy> Ah, thanks!
07:46:57 <jophish> Would it be in any way surprising to use fmap in place of map, how about <$>?
07:47:15 <vanila> jophish, it's fine
07:47:28 <vanila> but try to be consistent
07:47:42 <jophish> vanila: It's that I find myself using map whenever I have functions dealing with lists
07:47:54 <dwcook> map is fine when you know you're constrained to lists
07:48:13 <jophish> and it seems a little odd that list has become a special case for pedagogical reasons
07:48:13 <dwcook> Just like concatMap is fine even when (>>=) is available
07:48:15 <park> i try to use fmap, since its defined in prelude and will sometimes make code you've written generalize better
07:49:01 <vanila> jophish, The problem is that the standard library defines map on lists, and fmap separately
07:49:06 <jophish> How about infix <$> though?
07:49:21 <vanila> jophish, It'd be better to only define fmap
07:49:22 <park> it's fine too, but you have to import it from Control.Applicative i think
07:49:31 <dwcook> vanila, there are arguments either way
07:49:37 <jophish> vanila: except for those new to Haskell
07:49:45 <vanila> If they're new to haskell they could use fmap
07:50:13 <fizbin> Because what you want is to confront people who've made their first type error with an error message involving Functor.
07:50:52 <fizbin> If you use map and keep the error message only to types they know (like []), how will newbies get the proper haskell experience?
07:53:27 <vise890> hi all, i'm a complete newcomer. I'm trying to get my head around IO. I thought the two implementations here (http://pastebin.com/RifkjLcx) were equivalent, but evidently they aren't. Can someone explain why?
07:54:00 <tdammers> vise890: lazy IO
07:54:00 <corgifex> the second version closes the file twice
07:54:27 <corgifex> short version: hGetContents is evil
07:54:41 <corgifex> it doesn't actually read the file immediately
07:54:45 <tdammers> hGetContents returns a thunk which, when read, will read things from the file
07:54:57 <vise890> but the file is already closed?
07:55:01 <tdammers> if you close the file before the data is used, it won't be able to read anymore
07:55:01 <tdammers> yes
07:55:06 <vise890> dammit
07:55:07 <tdammers> the file is closed after the withFile line
07:55:33 <corgifex> hGetContents fake-closes the handle for you. there's no need to use withFile here
07:55:34 <Adeon> stuff like this is why you don't want to use lazy IO
07:55:40 <corgifex> also, readFile
07:55:57 <davidthomas> Adeon: ... for anything complex
07:56:04 <corgifex> :t readFile "todo.txt" >>= putStr
07:56:05 <lambdabot> IO ()
07:56:49 <park> has anyone ever seen a datatype like data M m b = M m (b, M m b), where m is a monad? Like a monadic list. i'm trying to make a monadic mealy machine, like data M m a b = M (a -> m (b, M a b)), and was curious if it could be generalized further
07:56:51 <vise890> corgifex: thanks, but i still haven't gotten around monads
07:57:15 <corgifex> @redo readFile "todo.txt" >>= putStr
07:57:15 <lambdabot> Maybe you meant: undo todo do
07:57:20 <corgifex> @do readFile "todo.txt" >>= putStr
07:57:20 <lambdabot> do { a <- readFile "todo.txt"; putStr a}
07:57:31 <corgifex> this isn't monads, this is just syntax
07:57:34 <vise890> ok this explains things, thanks guys. I'll stick with openFile and closeFile
07:57:43 <vise890> >>= is not just syntax
07:57:54 <corgifex> vise890: how are you going to read from the file?
07:58:02 <tdammers> vise890: >>= is not even syntax. It's just an operator.
07:58:03 <davidthomas> ">>= vs do notation" is just syntax
07:58:36 <vise890> i thought ">>=" was a function for types in the Monad type class
07:58:39 <tdammers> syntax wise, there isn't any difference between `a + b` and `a >>= b`
07:58:49 <tdammers> semantically, there is though
07:58:53 <corgifex> vise890: that doesn't matter here
07:58:57 <Yaniel> :t >>=
07:58:58 <lambdabot> parse error on input ‘>>=’
07:59:05 <Yaniel> :t (>>=)
07:59:05 <tdammers> :t (>>=)
07:59:06 <geekosaur> :t (>>=)
07:59:06 <lambdabot> Monad m => m a -> (a -> m b) -> m b
07:59:06 <lambdabot> Monad m => m a -> (a -> m b) -> m b
07:59:07 <lambdabot> Monad m => m a -> (a -> m b) -> m b
07:59:10 <geekosaur> heh
07:59:11 <tdammers> :D
07:59:16 <Yaniel> whoa
07:59:21 <vise890> yea
07:59:26 <vise890> it's not syntax
07:59:34 <corgifex> vise890: you're missing the point
07:59:44 <corgifex> @do readFile "todo.txt" >>= putStr
07:59:45 <lambdabot> do { a <- readFile "todo.txt"; putStr a}
07:59:51 <corgifex> vise890: ^ do you understand this code?
08:00:03 <vise890> yea
08:00:37 <dwcook> park, reminds of Pipes.Producer though may not be exactly it
08:00:51 <vise890> so readFile just opens reads it and closes it
08:00:58 <corgifex> do-notation is syntactic sugar for calls to >>=
08:01:03 <vise890> looks easier
08:01:05 <corgifex> @src readFile
08:01:05 <lambdabot> readFile name = openFile name ReadMode >>= hGetContents
08:01:11 <vise890> riight
08:01:12 <vise890> ok
08:01:19 <corgifex> readFile opens and hGetContents it
08:01:24 <corgifex> hGetContents closes the file implicitly
08:01:32 <geekosaur> hGetContents has a rather nasty sting in its tail
08:01:49 <corgifex> @. do src readFile
08:01:49 <lambdabot> readFile name = do { a <- openFile name ReadMode; hGetContents a};
08:01:54 <corgifex> :-)
08:02:46 <corgifex> vise890: btw, you can ignore the whole monad business and pretend >>= has the type IO a -> (a -> IO b) -> IO b here
08:02:58 <corgifex> this may or may not make more sense to you
08:03:12 <vise890> it doesn't yet
08:03:36 <gilligan_> hm, does anyone know when the next haskell platform release will be ? http://trac.haskell.org/haskell-platform/wiki/ReleaseTimetable <-- according to this page there should have been a 2013.4.0.0 release in November 2013 - but 2013.2.0.0 is still the latest now
08:03:50 <geekosaur> sometime this month
08:04:16 <geekosaur> it got delayed because of ghc 7.8, which was released some 6 months later than originally planned and has a fix for OS X / Xcode 5 support
08:04:17 <vise890> corgifex: actually that kind of does make sense
08:04:40 <gilligan_> geekosaur, will it use ghc 7.8.2 then ?
08:04:45 <geekosaur> yes
08:05:14 <gilligan_> geekosaur, alright. thanks for the info!
08:05:31 <corgifex> vise890: do you know javascript?
08:05:41 <Yaniel> yeah substituting IO for Monad makes >>= a bit clearer for now
08:05:48 <geekosaur> you might want to subscribe to, or at least read recent archives of, libraries@haskell.org to follow the progress of haskell-platform releases
08:05:50 <vise890> \notice corgifex a little bit
08:05:59 <vise890> how do you mention people
08:06:05 <corgifex> by name
08:06:12 <geekosaur> just use their nick, the client sees it and notifies
08:06:13 <vise890> corgifex ok
08:06:16 <Yaniel> hey, I might even get a hang of this stuff
08:06:21 <corgifex> :-)
08:06:26 <vise890> worked?
08:06:26 <vise890> nice
08:06:46 <corgifex> I don't know what you're seeing in your client but it's all in your client's head
08:06:49 <vise890> corgifex: why do you ask about js
08:07:09 <corgifex> vise890: because js is big on the whole async/callback stuff
08:07:25 <corgifex> which is basically what >>= does, too
08:08:01 <Yaniel> hmm like async_call_a(callback=b) ?
08:08:26 <corgifex> m >>= f attaches a callback f to the operation m, returning a new operation that does the same thing as m but calls f with the results afterwards
08:08:31 <dwcook> I feel that's a weak metaphor since (>>=) doesn't actually perform any IO
08:08:47 <corgifex> yeah, it doesn't actually run it
08:09:12 <vise890> ok that's a nice way to look at it
08:09:17 <corgifex> still, it made sense to me when I learned about IO
08:10:15 <vise890> corgifex: this was definitely helful. thanks guys. i'll go back to n00bing around :)
08:11:40 <Yaniel> how good (or bad) is writing a web interface for a simple database using yesod as a haskell exercise?
08:11:56 <Maior> so um, I have an `IO [String]` (from getArgs) - what's the best way to combine that with (!!) to get an IO String?
08:12:08 <benzrf> Maior: fmap
08:12:10 <dwcook> Maior, fmap
08:12:13 <benzrf> fmap (!!0)
08:12:17 <benzrf> or <$>
08:12:26 <dwcook> But beware, (!!) is partial. You should check bounds yourself or use a safer function
08:12:43 <dwcook> I don't know what the recommended one is but there's atMay from the safe package
08:12:50 <Maior> dwcook: nodnod, am prototyping so happy with partiality a bit right now
08:12:51 <Maior> cheers
08:13:40 <Maior> is there a "common" typeclass like Read that's total btw?
08:13:49 <dwcook> Read is total
08:13:52 <dwcook> Just use reads instead of read
08:14:02 <dwcook> I think there's also a readMaybe defined somewhere
08:15:20 <zq> is there a built-in for something like,
08:15:23 <zq> :t \f n -> foldr (.) id $ replicate n f
08:15:24 <lambdabot> (b -> b) -> Int -> b -> b
08:16:15 <Maior> dwcook: ah ok, thanks
08:16:23 <corgifex> :t \f n x -> iterate f x !! n
08:16:23 <lambdabot> (a -> a) -> Int -> a -> a
08:16:25 <Maior> (readMaybe is really what I'm after)
08:16:35 <Maior> I guess I can define it in terms of reads without much effort
08:16:48 <c_wraith> zq: no, there's nothing like that.
08:17:13 <pranz> :t replicate
08:17:14 <lambdabot> Int -> a -> [a]
08:18:58 <c_wraith> zq: that approach is significantly better than (\f n x -> iterate f x !! n) by the way.  it lacks the space leak iterate has!
08:19:24 <zq> c_wraith: isn't ghc smart enough to see that only the nth is wanted?
08:19:33 <zq> surely there's a rewrite for that pattern
08:19:35 <c_wraith> zq: ghc isn't smart like that at all
08:20:08 <c_wraith> zq: the space leak is in the repeated applications of f, by the way - not the list elements
08:20:21 * hackagebot MFlow 0.4.5.3 - stateful, RESTful web framework  http://hackage.haskell.org/package/MFlow-0.4.5.3 (AlbertoCorona)
08:20:42 <c_wraith> zq: the right fold avoids that.  using iterate that way is more or less a left fold.
08:20:44 <zq> c_wraith: uh, foldr ... is less leaky than iterate ... ?
08:21:05 <zq> c_wraith: isn't the left fold strict?
08:21:26 <c_wraith> zq: do you see any strictness?
08:21:35 <zq> i thought foldl' became default
08:21:50 <zq> everyone knows foldl is useless
08:21:55 <c_wraith> No.  And iterate would need to be changed, anyway
08:22:01 <c_wraith> iterate's closest analog is scanl
08:22:17 <c_wraith> which can be properly lazy - but not if you just skip all the output
08:22:47 <zq> :t iterate'
08:22:48 <lambdabot>     Not in scope: ‘iterate'’
08:22:48 <lambdabot>     Perhaps you meant one of these:
08:22:48 <lambdabot>       ‘iterate’ (imported from Data.List),
08:22:59 <park> are monad transformers different than just composing two monads like m (n a))?
08:23:18 <c_wraith> park: yes.  Monad transformers allow you to augment what the >>= operator does
08:23:26 <corgifex> zq: foldl is used in reverse
08:23:48 <c_wraith> park: nesting them like that results in >>= being m's >>=, with n have no control over it
08:24:20 <Jaood> https://www.youtube.com/watch?v=Wkhh2w-cno4
08:25:16 <orion> Is it possible to transform a monad twice with the same transformer? I.e., one WriterT for logging and the other for writing to a socket?
08:25:45 <c_wraith> orion: yes, but..  It won't work like that.
08:26:10 <corgifex> c_wraith: why not?
08:26:13 <firebird1> hi
08:26:24 <c_wraith> orion: if you use WriterT twice, tell will send output only to the outer WriterT.  You'll need some combination of lifts and tell to send output to the inner WriterT
08:26:46 <c_wraith> orion: This is because they can have different types, and so will need to work independently
08:26:52 <Maior> @hoogle m a -> m b -> (a -> b -> m c) -> m c
08:26:53 <lambdabot> Control.Monad zipWithM :: Monad m => (a -> b -> m c) -> [a] -> [b] -> m [c]
08:26:53 <lambdabot> Control.Monad zipWithM_ :: Monad m => (a -> b -> m c) -> [a] -> [b] -> m ()
08:26:53 <lambdabot> Control.Monad foldM :: Monad m => (a -> b -> m a) -> a -> [b] -> m a
08:26:58 <corgifex> :t lift . tell
08:26:59 <lambdabot> (MonadWriter a m, MonadTrans t) => a -> t m ()
08:27:16 <c_wraith> orion: I suppose if your goal was to write different stuff to the two different things, it'll work, but it'd be a bit annoying.
08:27:26 <orion> I see.
08:27:33 <corgifex> c_wraith: you'd define custom tell functions
08:27:38 <sahadev> @pl f xs ys = (== 0) $ sum $ zipWith (*) xs ys
08:27:38 <lambdabot> f = (((0 ==) . sum) .) . zipWith (*)
08:27:53 <corgifex> :t \ma mb f -> ma >>= \a -> mb >>= \b -> f a b
08:27:54 <lambdabot> Monad m => m a -> m a1 -> (a -> a1 -> m b) -> m b
08:28:18 <c_wraith> corgifex: if you're doing that, it's easier to use a single WriterT layer over the compound monoid
08:28:35 <c_wraith> corgifex: and the overhead will be lower.
08:28:53 <corgifex> oh, yeah
08:28:59 <orion> I am trying to make a monad stack: newtype Server = ReaderT ServerConfig (StateT ServerState IO) -- xpecting one more argument to `StateT ServerState IO'
08:29:06 <orion> I am not sure what that other argument should be.
08:29:29 <corgifex> newtype Server a = ReaderT ServerConfig (StateT ServerState IO a)
08:29:45 <orion> Ah, RWH lied to me.
08:29:55 <corgifex>   deriving (Functor, Monad)
08:30:01 <c_wraith> you also need a constructor name
08:30:07 <c_wraith> newtype and type don't work anything alike
08:30:19 <orion> c_wraith: The constructor of a newtype must have exactly one field
08:30:31 <c_wraith> orion: and that newtype has exactly 0 constructors
08:30:40 <corgifex> depends on your point of view
08:30:41 <orion> Doh! I am using newtype when I should be using type
08:30:49 <corgifex> if you're a compiler, then it has 2
08:30:54 <corgifex> er
08:30:58 <corgifex> 1 constructor with 2 fields
08:31:19 <c_wraith> yes, but I prefer to point out the actual error, not what the compiler would think it is. :)
08:32:04 <corgifex> I don't understand the space leak with iterate, btw
08:32:16 <c_wraith> @src iterate
08:32:16 <lambdabot> iterate f x =  x : iterate f (f x)
08:32:42 <c_wraith> > iterate f x !! 10 :: Expr
08:32:43 <lambdabot>  f (f (f (f (f (f (f (f (f (f x)))))))))
08:33:18 <pranz> whoa, how does that ":: Expr" work?
08:33:22 <c_wraith> I suppose the foldr version doesn't get rid of the space leak on functions strict in the second argument
08:33:36 <Maior> @hoogle (a -> b -> m c) -> m a -> m b -> m c
08:33:37 <lambdabot> Control.Monad zipWithM :: Monad m => (a -> b -> m c) -> [a] -> [b] -> m [c]
08:33:37 <lambdabot> Control.Monad zipWithM_ :: Monad m => (a -> b -> m c) -> [a] -> [b] -> m ()
08:33:37 <lambdabot> Control.Monad foldM :: Monad m => (a -> b -> m a) -> a -> [b] -> m a
08:33:42 <c_wraith> pranz: lambdabot has a library called something like simple-reflect loaded
08:33:44 <Maior> oh, hoogle's sensible
08:33:51 <corgifex> pranz: Expr is normal type with an interesting Show instance
08:34:02 <c_wraith> pranz: http://hackage.haskell.org/package/simple-reflect
08:34:24 <pranz> c_wraith, corgifex: thanks
08:35:22 <c_wraith> corgifex: the issue is that !! doesn't examine the list elements it throws out.  It leaves them unevaluated
08:36:03 <c_wraith> corgifex: and so iterate f x !! n is going to result in a chain of n thunks
08:36:08 <dwcook> How about a strict version? (!!!) :P
08:36:09 <benzrf> > f
08:36:11 <lambdabot>  No instance for (GHC.Show.Show a0)
08:36:11 <lambdabot>    arising from a use of ‘M914098854727300338915869.show_M9140988547273003389...
08:36:11 <lambdabot>  The type variable ‘a0’ is ambiguous
08:36:11 <lambdabot>  Note: there are several potential instances:
08:36:11 <lambdabot>    instance [safe] GHC.Show.Show
08:36:14 <benzrf> o:
08:36:17 <benzrf> :t f
08:36:18 <lambdabot> FromExpr a => a
08:36:19 <c_wraith> dwcook: eww.  a strict iterate would be better. :P
08:36:21 <benzrf> huh.
08:36:25 <corgifex> c_wraith: what's different with foldr?
08:36:32 <dwcook> c_wraith, was just kidding, I just found the name funny
08:36:39 <c_wraith> corgifex: I was wrong..  Nothing's different in this case.
08:37:20 <vanila> Is there a very small self contained haskell to x86 compiler?
08:37:28 <c_wraith> > f :: Expr -> Expr
08:37:29 <lambdabot>  No instance for (Data.Typeable.Internal.Typeable
08:37:29 <lambdabot>                     Debug.SimpleReflect.Expr.Expr)
08:37:29 <lambdabot>    arising from a use of ‘M511093655057368466515906.show_M5110936550573684665...
08:38:04 <c_wraith> Heh.  Whoops
08:39:07 <c_wraith> vanila: UHC is probably your best bet.  It's not small, but it's designed for teaching
08:39:20 <vanila> thanks
08:40:00 <MagneticDuck> question: in what way is GHC not self-contained?
08:40:20 <vanila> MagneticDuck, perl
08:40:20 <c_wraith> it depends on the Cabal package.  sadly.
08:40:24 * hackagebot hledger-lib 0.23 - Core data types, parsers and utilities for the hledger accounting tool.  http://hackage.haskell.org/package/hledger-lib-0.23 (SimonMichael)
08:40:26 * hackagebot hledger 0.23 - The main command-line interface for the hledger accounting tool.  http://hackage.haskell.org/package/hledger-0.23 (SimonMichael)
08:40:28 * hackagebot hledger-web 0.23 - A web interface for the hledger accounting tool.  http://hackage.haskell.org/package/hledger-web-0.23 (SimonMichael)
08:40:40 <c_wraith> Does GHC still depend on perl?  I thought that finally got removed
08:41:30 <corgifex> I'm all for depending on perl, but the script they used ... holy crap
08:41:45 <c_wraith> there was a reason it was named "evil"
08:42:07 <corgifex> I thought it was called evil for what it did, not for how it was written
08:42:16 <ion> They ported the script into Perl 6 and bundled Pugs which is compiled with the host GHC first.
08:42:28 <geekosaur> wat
08:42:33 <vanila> lol
08:42:43 <ion> (I’m talking out of my ass.)
08:42:56 * dwcook wonders what would happen if every single GHC binary was somehow wiped out of existence
08:43:09 <corgifex> you can't really port code like that :-(
08:43:24 <geekosaur> someone would dig out a lazy ml compiler...
08:44:48 <corgifex> it's regex-based search/replace on asm code, written by someone who wasn't very good at perl and regexes
08:44:50 <merijn> c_wraith: Define "depend on"
08:45:01 <merijn> c_wraith: The evil mangler was only used for the via-C backend, afaik
08:45:15 <merijn> c_wraith: There's still a "perl boot" for the build system/repo though, I think
08:45:15 <c_wraith> merijn: and hasn't that backend been gone for a while?
08:45:18 <geekosaur> via-C is still secretly there, at least in 7.6.x
08:45:25 * hackagebot arithmoi 0.4.1.0 - Efficient basic number-theoretic functions.  Primes, powers, integer logarithms.  http://hackage.haskell.org/package/arithmoi-0.4.1.0 (DanielFischer)
08:45:25 <c_wraith> ah
08:45:28 <merijn> c_wraith: via-C is around but strongly deprecated
08:45:42 <merijn> Mostly in case of future porting endeavours to new architectures
08:45:56 <c_wraith> I thought there was the unregistered C backend for porting
08:46:10 <geekosaur> there was but it's been broken for a longish time
08:46:15 <merijn> c_wraith: I'm not sure entirely about the details
08:46:28 <YayMe> Is this a correct C# implementation of the Cont monad? https://gist.github.com/JimmyHoffa/388f2f350f135addf2fc
08:47:17 <geekosaur> so at the moment -fvia-C or -fllvm are the only real options, and I don't think ghc's -fllvm is really up to using it for general porting (although using it to cross compile to ARM probably helped bring it closer to that)
08:54:02 <haasn> dwcook: bootstrap it from history and Lazy ML ;)
08:56:33 <haasn> YayMe: Why do you have Return parametrized by NewA?
08:57:15 <haasn> YayMe: Also, I don't think you need any of “new Func<...>()” things, in my experience “a => b” just auto-infers to the correct Func type
08:58:43 <YayMe> haasn: iduno, I thought about that but I suspect the type checker would claim ambiguity, but perhaps not. I'll give it a shot. Also I guess i can remove the NewA and just use A, I wasn't sure how to do that return considering it's a static method
08:58:58 <YayMe> thanks for the review! I'll go tweak it as such
08:59:55 <haasn> YayMe: looks good otherwise
09:00:24 <haasn> YayMe: Return still lives inside ModelOperation<R,A> even if it's static, so you can use ModelOperation<R,A>.Return vs ModelOperation<R,NewA>.Return
09:00:35 <haasn> I guess this is off-topic
09:00:57 <haasn> Other than “yes, it looks like Haskell's Cont (>>=)”
09:01:06 <YayMe> haasn: if there was *anywhere* else I could ask about monads I would, but as it stands trying to do anything with monads in *any* language- this is the only place with people who can understand it
09:01:23 <haasn> I was merely suggesting taking it to #haskell-blah
09:01:26 <YayMe> or rather who can help, to my knowledge
09:01:34 <YayMe> haasn: is that a channel?
09:01:44 <haasn> Yes, it's for things that are not Haskell
09:01:57 <YayMe> cool, thanks
09:01:59 <haasn> (But populated by various members of the #haskell community)
09:02:46 <Refried__> what's the purpose of WrappedMonad?
09:03:08 <bvck> Hi folks, getting an error running 'hoogle data all'. The main error is "downloads/hoogle/reactive-glut/0.1.6/doc/html/reactive-glut.txt: hGetContents: invalid argument (invalid byte sequence)". Web search provides no help. Any hints?
09:03:34 <haasn> Refried__: providing an Applicative instance for any ‘m’ that is an instance of Monad
09:03:39 <haasn> Refried__: among some other instances, I think
09:03:45 <merijn> Refried__: Functor is (not yet) a superclass of monad, but logicall all monads are functors and applicatives
09:04:06 <merijn> Refried__: WrappedMonad is just a "turn Monad with missing Functor/Applicative instances into a Functor/Applicative for free"
09:04:25 <geekosaur> bvck: something has an unexpected encoding. beyond that I can't say
09:04:59 <bvck> No screw-up on my end then?
09:05:12 <Refried__> haasn / merijn: does it just exist because people are scared to make a Functor/Applicative instance for Monad, or is there some reason why a Wrapper is important?
09:05:45 <merijn> Refried__: Not scared, but imagine an upstream library forgot to provide them, this way you can use them immediately without needing to patch upstream
09:05:52 <geekosaur> probably not. might even be a bug in hoogle. I just helped someone decipher the same kind of bug in the very latest cabal-install
09:05:52 <haasn> Refried__: Because historically, some types might be floating around which *aren't* Functors/Applicatives, but are Monads
09:05:58 <haasn> Refried__: In reality, it should not matter much
09:06:06 <haasn> Because most real world monads are also functors/applicatives
09:06:19 <vanila> well monads are always functors aren't they?
09:06:22 <merijn> haasn: s/most /all
09:06:33 <merijn> vanila: Every law abiding monad is a functor and applicative, yes
09:06:35 <haasn> Refried__: But it can also help you cut down on a constraint or two, somewhere
09:06:45 <YayMe> God I wish I could work in an FPL instead of C#... I'd even take F#, but standard industry workers stare daggers at anything more abstract than a switch-case statement...
09:06:45 <benzrf> vanila: sadly, applicative is not a superclass of monad
09:06:47 <awestroke> should I avoid underscores in my variable names when coding haskell? Is there any consensus of camelCase vs under_score ?
09:06:53 <haasn> Refried__: eg. foo :: (Monad m, Functor m) => ... -- vs foo :: Monad m => ...
09:06:56 <benzrf> vanila: so the typechecker cannot deduce that a monadic value is necessarily a monad
09:07:01 <benzrf> *necessarily a functor
09:07:10 <haasn> awestroke: camelCase is the clear community favorite, but you're free to do what you want, I guess
09:07:12 <merijn> awestroke: camelCase is the common community style
09:07:16 <Refried__> merijn: i didn't understand about the library
09:07:16 <haasn> awestroke: Best adjust to the style of whatever you're writing
09:07:23 <haasn> awestroke: I think underscore_names are mainly used for C FFI stuff
09:07:24 <vanila> benzrf, would it be a kind of infinite loop thing, if it was automatic
09:07:25 <vanila> ?
09:07:28 <haasn> like imported C constants
09:07:54 <benzrf> vanila: no...
09:08:00 <YayMe> awestroke: I think you'll find more community acceptance of lisp-case over under_scores, but camelCase is definitely the majority favorite around Haskellers...
09:08:01 <benzrf> it just isnt because functors were added after monads
09:08:04 <vanila> hm i'm not sure what the problem is
09:08:06 <vanila> then
09:08:08 <benzrf> and nobody ever got around to chaning it
09:08:09 <benzrf> *changing
09:08:10 <haasn> vanila: No, it's just that Monad was included before the other two classes. It's a historical blight, and in fact GHC 7.10 will fix it
09:08:19 <Refried__> merijn: wherever the Monad m => Applicative (WrappedMonad m) instance was declared, could they have done Monad m => Applicative m instance?
09:08:24 <vanila> oh wow really, can I see this change?
09:08:26 <Refried__> haasn: yay.  that was my next question
09:08:27 <merijn> haasn: No, Functor and Monad were in the original, afaik
09:08:35 <haasn> Refried__: No, because that conflicts with every other Applicative instance
09:08:48 <haasn> Refried__: “Applicative m” is an instance head that matches every single type
09:08:59 <benzrf> vanila: http://ro-che.info/ccc/21
09:09:00 <merijn> haasn: The main reason not to make Functor a superclass of Monad was "Everyone would have to uselessly implement Functor if they just want a monadic API"
09:09:07 <haasn> That way, it would be impossible to write Applicative instances for things which are *not* monads, for example Applicative ZipList
09:09:11 <benzrf> merijn: that's dumb
09:09:19 <vanila> lol
09:09:19 <merijn> benzrf: In hindsight, yes
09:09:23 <haasn> merijn: Ah okay
09:09:31 <haasn> But now it's in Prelude anyway?
09:09:33 <vanila> but is there a .hs file defining Monad and Functor in this way?
09:09:34 <YayMe> merijn: Functor can be generalized over Monad anyway can't it?
09:09:38 <vanila> I'd just like to see how it's done
09:09:56 <haasn> vanila: it's really easy you just change “class Monad m where” to “class Applicative m => Monad m where”
09:10:04 <vanila> ohh okay!
09:10:04 <haasn> everything else is left as-is
09:10:07 <vanila> That's so cool!
09:10:13 <merijn> haasn: Functor was in Prelude too, it's just that people thought "meh, a missing Functor instance won't be so bad, you can just use the Monad instance"
09:10:21 <YayMe> merijn: is there no Functor implementation that works for any monad?
09:10:22 <awestroke> YayMe: lisp-case?
09:10:37 <YayMe> awestroke: lispers-use-dashes-and-lower-case
09:10:41 <haasn> YayMe: fmap = liftM
09:10:45 <Refried__> merijn: i thought when you declare the instance that says Monads are Functors, you could give the implementation to prove it, but is that not true, and everyone would have to implement functor too?
09:10:53 <haasn> this is a valid implementation of fmap for any valid Monad instance
09:10:55 <merijn> YayMe: Well "fmap f x = x >>= return . f", but that one stops you from implemeting ">>=" using fmap ;)
09:10:57 <Refried__> merijn: (i've never written a haskell program)
09:11:18 <benzrf> i like lisp case
09:11:22 <YayMe> merijn: ahh.. I see, you could end up with circular definitions
09:11:24 <benzrf> but most langs use infix -
09:11:27 <merijn> YayMe: Right :)
09:11:51 <YayMe> thus liftM
09:11:53 <haasn> Refried__: instance resolution in Haskell doesn't really work that way; you can't say “every Monad is also a Functor, by the way” without changing the definition of Monad itself. (Although there are language extensions proposed that could change that, they haven't seen the light of implementation)
09:12:01 <Refried__> oh
09:12:14 <awestroke> YayMe: dashes aren't legal in variable names
09:12:43 <Refried__> haasn: how is what they do with WrappedMonad different from that?
09:12:51 <dwcook> > let (—) = () in (—) -- That's a dash
09:12:52 <lambdabot>  ()
09:12:55 <YayMe> awestroke: ah. Well there ya go, then stick with camelCase
09:13:00 <haasn> Refried__: WrappedMonad is a separate type. You are, essentially, saying that “every WrappedMonad m is a Functor”
09:13:09 <haasn> (But only if m is a Monad)
09:13:10 <Refried__> Ah ok... and then... err
09:13:23 <haasn> Refried__: WrappedMonad m a and m a are distinct in the Haskell type system
09:13:46 <haasn> Refried__: so instance resolution treats it differently
09:13:52 <benzrf> what does wrappedmonad do?
09:13:57 <Refried__> Ok WrappedMonad is a new type that doesn't have any historical baggage,  and then given that you have a Monad m, how do you get from that to WrappedMonad?
09:14:10 <haasn> To use the instance, you actually have to resolve it to WrappedMonad m a, which means your values live inside WrapMonad, etc.
09:14:14 <merijn> Refried__: Explicitly wrapping it with a constructor
09:14:23 <haasn> Refried__: WrapMonad :: m a -> WrappedMonad m a
09:14:27 <Refried__> ahh
09:14:30 <haasn> Refried__: unwrapMonad :: WrappedMonad m a -> m a
09:14:46 <haasn> Note the definition of WrappedMonad which is newtype WrappedMonad m a = WrapMonad { unwrapMonad :: m a }
09:14:56 <haasn> (And also read up on Haskell record syntax)
09:15:14 <hseg> Why isn't there an analogue of Text's dropWhileEnd in Data.List?
09:16:34 <Refried__> haasn: so i can call WrapMonad, and then call fmap or something on the result
09:16:49 <haasn> Refried__: exactly
09:17:02 <corgifex> hseg: because you probably shouldn't use lists if you need that operation
09:17:04 <Refried__> haasn:  thanks :-)
09:17:07 <haasn> Refried__: because this is using the “fmap” from the Functor instance for WrappedMonad m
09:17:25 <Refried__> haasn: sorry for the newbie questions, i haven't actually ever written any haskell apart from a few lines in the interpreter
09:17:34 <merijn> hseg: The operation is going to be *very* inefficient
09:17:36 <haasn> Then you probably should :)
09:18:06 <merijn> Refried__: I second haasn, although you should probably just write in an editor and load the file into ghci, works better IMO ;)
09:18:11 <Refried__> haasn: so what are they doing differently 7.10?
09:18:30 <Refried__> merijn: yeah, true; i am doing that actually
09:18:31 <haasn> Refried__: changing the definition of the Monad class to “class Applicative m => Monad m where ...”
09:18:34 <corgifex> merijn: can't it be done in O(n)?
09:19:00 <haasn> Refried__: This means that to define a Monad instance, you must have an Applicative (and hence Functor) instance; and vice versa, GHC can automatically weaken a Monad constraint to an Applicative (and hence Functor) constraint
09:19:01 <hseg> corgifex: Why? It's really easy to write as a foldr: foldr (\x xs -> if p x && null xs then [] else x : xs) []
09:19:06 <pranz> :t Data.Text.dropWhileEnd
09:19:07 <lambdabot> (Char -> Bool) -> Data.Text.Internal.Text -> Data.Text.Internal.Text
09:19:17 <haasn> So you can just call “fmap :: (a -> b) -> m a -> m b” directly for any ‘m’ given only a Monad m constraint
09:19:25 <haasn> without having to go through WrappedMonad
09:19:50 <Refried__> haasn: does that make it a pain to define monads, like you said? although most people don't need to
09:20:14 <Refried__> LYAH also complains that length returns Int instead of Num ;-)  I wonder if they'll fix that too ;-)
09:20:16 <YayMe> Is the cont monad the formal derivation or simplest implementation? It's always struck me as confusing and seemed like it could be done more...plainly... but perhaps I'm wrong...
09:20:20 <merijn> corgifex: You need to recopy the head everytime you drop 1 element, so writing a function iterating from the end that doesn't regenerate the list every single time is really inefficient
09:20:38 <pranz> Refried__: ghc can derive instances for Functor, Applicative and Monad very well
09:20:50 <hseg> merijn: Are you talking to me?
09:21:08 <corgifex> merijn: reverse . dropWhile p . reverse
09:21:12 <haasn> Refried__: Not really: 1. as mentioned earlier in practice pretty much every type in existence which is an instance of Monad is also an instance of Functor/Applicative anyway, and 2. if you really don't want to do it manually, you can use the “liftM” and “ap” functions which satisfy all the requirements of “fmap” and “(<*>)” (from Applicative)
09:21:17 <corgifex> doesn't regenerate the list for each element
09:21:24 <merijn> Refried__: Well, the problem of returning Integral (not Num, lengths are always integrals) is that it might not be very efficient
09:21:28 <merijn> corgifex: Ah true, my bad
09:21:29 <ReinH> pranz: GHC can derive Monad?
09:21:33 <merijn> corgifex: Still not very efficient
09:21:40 <haasn> Refried__: So, in the very worst case, it's as simple as adding “instance Functor MyNewType where fmap = liftM” and “instance Applicative MyNewType where pure = return; (<*>) = ap”
09:21:41 <merijn> ReinH: Sometime
09:21:42 <Refried__> merijn: ah
09:21:48 <pranz> ReinH: for trivial types at least
09:21:51 <ReinH> merijn: aside from GeneralizedNewtypeDeriving?
09:21:54 <merijn> hseg: Well, you too, yes
09:21:57 <Refried__> haasn: ah :)
09:21:59 <ReinH> which can derive basically anything?
09:22:00 <pranz> ReinH: I don't know how well it does it, but I've seen some examples
09:22:09 <orion> If you are operating within a monad transformation stack and you find yourself doing liftIO over and over, is this an indication that you are doing something wrong?
09:22:13 <ReinH> hmm
09:22:22 <merijn> ReinH: GeneralizedNewtypeDeriving just "copies" instance through a newtype
09:22:27 <ReinH> merijn: yes
09:22:36 <merijn> ReinH: Functor derivation can derive Functors for arbitrary ADTs
09:22:38 <ReinH> merijn: it just performs the newtype wrapping and unwrapping, I know.
09:22:40 <merijn> Although it's not very smart
09:22:54 <hseg> corgifex: What's wrong with my foldr-based implementation?
09:22:55 <ReinH> I'm also familiar with Derive{Functor,Foldable,Traversable}
09:23:15 <ReinH> I didn't know GHC could derive monad instances
09:23:17 <corgifex> hseg: it's inefficient
09:23:26 <hseg> corgifex: Why?
09:23:36 <corgifex> any such function has to be O(n)
09:23:49 <corgifex> due to the way lists work, you have to make at least one copy
09:24:19 <corgifex> your null xs check effectively has to scan ahead to the next element that doesn't match p x
09:25:16 <hseg> corgifex: OK. So when p x is true, you do extra work. Why would this be a show-stopper?
09:25:24 <corgifex> that is, something like dropWhileEnd (== 'a') "aaaaaaaaaaaaaaaaaaaaaaaaaaaaaab" will have to examine the string up to 'b', just to determine that the first element of the result is 'a'
09:25:55 <corgifex> it also means you have to examine every element of the list. if your predicate is expensive, that's not so good
09:26:08 <corgifex> Text doesn't have to do that
09:27:01 <corgifex> hseg: what do you need this function for?
09:27:41 <hseg> corgifex: A) && is non-strict in its second parameter when its first parameter is false. Therefore if not (p x), then null xs will never be tested. B) The efficiency depends on the amount of times p x is true.
09:28:17 <corgifex> what is A) in response to?
09:28:45 <hseg> corgifex: corgifex | that is, something like dropWhileEnd (== 'a')
09:28:47 <hseg>          | "aaaaaaaaaaaaaaaaaaaaaaaaaaaaaab" will have to examine the
09:28:49 <hseg>          | string up to 'b', just to determine that the first element of
09:28:51 <hseg>          | the result is 'a'
09:29:09 <hseg> corgifex: But it is possible I'm solving my problem the wrong way.
09:29:10 <corgifex> what's your point?
09:30:25 <hseg> corgifex: What I'm trying to do is obtain a fused version of rotate . break p, where rotate (xs, (y:ys)) = (xs `snoc` y, ys)
09:30:44 <hseg> corgifex: However, I know that p is only true once
09:31:04 <corgifex> snoc xs y = xs ++ [y] ?
09:31:11 <hseg> Ugh. This is causing me to realize I'm writing this wrong.
09:31:13 <hseg> corgifex: Yes
09:31:29 <ReinH> Maybe you want a zipper?
09:31:53 <hseg> Well, that could work, but it feels like over-engineering
09:31:54 <enthropy> @src break
09:31:54 <lambdabot> break p =  span (not . p)
09:32:04 <enthropy> @src span
09:32:05 <lambdabot> span _ xs@[]                     =  (xs, xs)
09:32:05 <lambdabot> span p xs@(x:xs') | p x          =  let (ys,zs) = span p xs' in (x:ys,zs)
09:32:05 <lambdabot>                   | otherwise    =  ([],xs)
09:32:31 <corgifex> zipper code would look like: right (xs, y : ys) = (y : xs, ys)
09:32:39 <hseg> What I'm trying to do, precisely, is take the prefix of xs terminating in x
09:33:15 <corgifex> what if there is no x?
09:33:27 <enthropy> it's not just a question of changing the otherwise = ([x], xs')?
09:33:55 <hseg> Huh. Never considered that case.
09:34:25 <hseg> But, looking at my application, it's assuming that the result'd be [] in that case.
09:36:23 <corgifex> does it have to be a list?
09:39:01 <bvck> fg
09:39:45 <hseg> I'd rather it be a Haskell98 type. I'm writing it for a paper, and would rather not overcomplicate the code. What did you have in mind
09:39:47 <hseg> ?
09:40:02 <corgifex> nothing, just trying to get more context
09:42:22 <hseg> corgifex: Wait. Rereading my code, I have the invariant that x is always an element.
09:43:34 <Ainieco> hello
09:44:13 <Ainieco> http://www.reddit.com/r/haskell/comments/24ddu3/what_do_you_think_is_impeding_haskell_from/ch6pvlv how can i enable profiling and run my program with -Xc to get backtraces as described in link?
09:44:54 <hseg> corgifex: Basically, what I'm trying to do is the following. Given a list xs and some x, I construct the list cs of the possible ways to choose a single instance of x (that means that all elements of cs have x as an element). Now I'm trying to build the list sps = map f cs, where f splits each element of cs into the prefix terminating in x and the corresponding suffix. This is a necessary part of my
09:44:55 <hseg> derivation of a certain algorithm.
09:45:14 <merijn> Ainieco: Edit ~/.cabal/config, uncomment "library-profiling: False" and change False to True so you always build profiling versions of libraries
09:45:26 <jophish> Grr, Set not being in Functor
09:45:31 <merijn> Ainieco: (While you're at it, make sure you add "documentation: True")
09:46:01 <merijn> Ainieco: Then just compile with whatever profiling switches your program needs..
09:46:06 <corgifex> hseg: ok, so what's the problem with the rotate/break approach?
09:46:20 <Ainieco> merijn: got it, having documentation and profiling set to true in my cabal.config within sandbox
09:46:34 <Ainieco> merijn: what is that -Xc options?
09:46:54 <merijn> Ainieco: I would set those two to true globally
09:47:22 <merijn> Ainieco: No clue, I'd check the GHC manual section on profiling? The manual is quite detailed
09:47:22 <Ainieco> merijn: okay
09:47:37 <hseg> corgifex: Actually, now that you point it out, not that much. Only the lack of a descriptive name.
09:47:41 <merijn> Also, Real World Haskell has a profiling chapter
09:48:07 <Ainieco> merijn: hm, can't find anything about it in "man ghc".
09:48:15 <merijn> Ainieco: I meant the user manual
09:48:30 <merijn> http://www.haskell.org/ghc/docs/latest/html/users_guide/index.html
09:48:43 <zipper> Anyone know what I can read on testing and benchmarking code in haskell but for people who are new to testing code?
09:49:17 <hseg> corgifex: However, I can see another place where I'm using dropWhileEnd, where I'm trying to construct the minimal prefix containing all occurrences of x in xs.
09:49:38 <hseg> corgifex: And that is much better explained using dropWhileEnd.
09:49:47 <merijn> zipper: Testing: hunit/quickcheck benchmarking: criterion
09:49:49 <_d0t> hi. I wrote a small library with bindings to recvmsg/sendmsg functions (https://bitbucket.org/braindamaged/network-msg/). The problem is that sendMsg often fails with the invalid argument error, even if I use the same arguments over and over. What could be the problem?
09:49:57 <corgifex> hseg: so define it :-)
09:50:07 <zipper> merijn: I found this http://lambda.jstolarek.com/2012/10/code-testing-in-haskell/ but I wish the writer went into more detail.
09:50:20 <gilligan_> merijn, i think he probably meant actual articles/books/whatever
09:50:32 <zipper> merijn: Something I can read.
09:50:44 <Ainieco> merijn: http://www.haskell.org/ghc/docs/latest/html/users_guide/flag-reference.html can't find it here either
09:51:10 <Ainieco> probably that guy was mistaken
09:51:12 <merijn> Ainieco: http://www.haskell.org/ghc/docs/latest/html/users_guide/runtime-control.html#rts-profiling
09:51:19 <hseg> Yeah, I think that's probably the best solution.
09:51:21 <geekosaur> Ainieco, it's not a ghc compiler option, it's a runtime option
09:51:29 <geekosaur> +RTS -xc
09:51:56 <gilligan_> zipper, The book 'Real World Haskell' has some bits on Quickheck but not all that much
09:51:57 <Ainieco> ahh, thanks!
09:52:15 <Ainieco> how can i set it in my application's cabal file?
09:53:43 <awestroke> how do I catch a signal with installHandler (System.Posix.Signals) but then "re-raise" it so that the default action is executed anyway? If that makes sense
09:53:43 <Ainieco> -with-rtsopts=-xc ?
09:53:50 <zipper> gilligan_: I don't like that book. It's kinda outdated. Example code blows up in my face.
09:53:51 <Ainieco> into ghc-options section
09:54:05 <zipper> There is an FP complete tutorial on quickcheck
09:54:13 <zipper> but I meant on testing as a whole
09:54:26 <zipper> How to combine the various aspects
09:54:33 <zipper> Like http://lambda.jstolarek.com/2012/10/code-testing-in-haskell/
09:55:09 <gilligan_> zipper, true ;(
09:55:49 <gilligan_> zipper, 'Beginning Haskell' is more recent. Pretty sure it doesn't go into detail about Quickchek either though
09:56:21 <gilligan_> zipper, In fact 'Beginning Haskell' is probably the only Haskell book i have where all code works
09:56:26 <ReinH> zipper: Haskeller pedagogy historically has underemphasized testing
09:56:44 <ReinH> zipper: there's a point to be made that Haskell's type system is strong enough to make some forms of testing unnecessary. But not all forms.
09:56:47 <zipper> gilligan_: hmmm how about the whys and how of testing. The whys and how of benchmarking. How they fit together?
09:57:04 <ReinH> zipper: so while I don't have an answer for you I can at least acknowledge that there is a problem :)
09:57:05 <bitemyapp> god dammit.
09:57:12 <zipper> ReinH: So people don't focus on it?
09:57:20 <bitemyapp> New Techempower benchmark is using an old version of GHC: http://www.techempower.com/blog/2014/05/01/framework-benchmarks-round-9/
09:57:26 <zipper> ReinH: I have noticed.
09:57:32 <bitemyapp> is anybody following this? This is deeply disappointing.
09:57:36 <ReinH> zipper: Generally no, and I think it's a problem.
09:57:58 <ReinH> bitemyapp: there are three kinds of lies: lies, damned lies, and benchmarks
09:57:59 <gilligan_> zipper, that sounds very broad, not limited to Haskell
09:58:06 <zipper> ReinH: On another topic I can't wait for the next haskell cast :)
09:58:08 <bitemyapp> ReinH: I don't care
09:58:10 <ReinH> zipper: :)
09:58:16 <bitemyapp> ReinH: I don't want us to look worse than we need to.
09:58:18 <ReinH> bitemyapp: and I don't care about their benchmark :p
09:58:19 <bitemyapp> This is egregious.
09:58:24 <bitemyapp> ReinH: the marketing matters.
09:58:27 <bitemyapp> ReinH: it *matters*
09:58:35 <ReinH> I guess
09:58:39 <zipper> gilligan_: True it's not limited to haskell but I wish there was something with haskell centered written on it.
09:58:41 <bitemyapp> ReinH: they'll believe the techempower benchmark before they'll believe the MIO paper.
09:59:08 <zipper> gilligan_: Getting started with testing on rails was quite easy for me to do as a beginner.
09:59:17 <zipper> but all they were unit tests.
09:59:33 <zipper> Malformed sentence. :(
10:00:28 <zipper> So ignore benchmarks? "< ReinH> bitemyapp: there are three kinds of lies: lies, damned lies, and benchmarks"
10:00:43 <ReinH> zipper: treat benchmarks with a heavy dose of skepticism
10:00:46 <ReinH> including your own
10:00:57 <ReinH> because they often lie
10:01:27 <ReinH> still, they are sometimes necessary
10:03:16 <davean> bitemyapp: I'm happy with such people not being around me
10:04:15 <zipper> I shall ignore them 100% for the time because honestly I don't know why I need them.
10:11:37 <Ainieco> hm, -with-rtsopts=-xc in my cabal file doesn't enables backtraces
10:12:04 <Ainieco> exception is thrown in one of the dependencies of my app, probably this somehow related
10:12:21 <Ainieco> or not, i'm not sure
10:14:39 <tomboy65> how difficult is it to cross-compile windows binaries on linux?
10:15:33 <ReinH> zipper: in order to make slow things fast, you need to know why they are slow. In order to know why they are slow, you need to profile them. Benchmarking tools are often used for profiling.
10:16:11 <Ainieco> moved -with-rtsopts=-xc to  ghc-prof-options in cabal file but still no backtraces
10:16:34 <Ainieco> anyone?
10:19:49 <ReinH> zipper: benchmarks that compare one language, framework, etc to another are the least useful. Benchmarks that compare your code to your slightly different code are the most useful, as long as you understand what they are actually telling you.
10:21:28 <orion> What's the proper syntactic sugar for: x <- atomically $ newTMVar []; let initialState = ServerState x ?
10:24:26 <bitemyapp> davean: I just want a proper showing. Nothing more.
10:25:29 <pmade> tomboy65: I haven't seen anyone talking about a linux->windows cross-compiler.  I would imagine it would be fairly involved.  Wouldn't you need some basic DLLs from windows on your linux box?
10:25:33 <davean> bitemyapp: then you fix it, and I'll not thank you for it
10:26:12 <davean> pmade: its been done - via wine, and you need the headers
10:26:36 <bitemyapp> davean: I don't need thanks, better data is its own reward.
10:27:25 <bitemyapp> davean: also worth considering, if you didn't have anything positive to contribute you didn't have to say anything at all.
10:27:37 <bitemyapp> davean: maybe keep that option nearer at hand next time?
10:27:51 <davean> Why? I actively want you to NOT fix this
10:27:51 <pmade> davean, tomboy65: That sure would beat having to log into a windows computer for development ;)
10:28:09 <beardygreg> is there an echo in the room?
10:28:11 <bjorkintosh> pmade, virtual box!
10:28:16 <bjorkintosh> what's so hard about that?
10:28:22 <bjorkintosh> it'll be right. there.
10:28:51 <pmade> bjorkintosh: That's the next best option, as long as OpenSSL works correctly.
10:29:07 <Ainieco> http://lpaste.net/103472 How can i re-export functions from qualified module?
10:29:58 <zipper> ReinH: Thanks
10:30:15 <davean> bitemyapp: I mean, one pretty much never "has" to say anything at all
10:30:50 <gilligan_> anyone using https://github.com/dag/vim2hs ? Total performance killer here. Looking at why that is right now.
10:31:27 <davean> pmade: http://wiki.wxwidgets.org/Cross-Compiling_Under_Linux
10:31:48 <WraithM> I'm having trouble getting haskell-src-exts to install with GHC 7.8. It's this bug (https://ghc.haskell.org/trac/ghc/ticket/8768). I tried runnging: cabal install haskell-src-exts --gcc-option=-nostdinc and I got the same error.
10:31:58 <pmade> davean: Thanks!
10:32:06 <davean> pmade: your milage may vary a lot though, I'd consider it a fairly fragile process
10:32:11 <WraithM> gilligan_: Maybe ghcmod is giving you trouble?
10:32:27 <Ainieco> how can i reexport functions from other module?
10:32:30 <davean> pmade: I did once hear of someone getting visual studio running under some wine variant
10:32:32 <Cale> bitemyapp: The marketing doesn't really matter all that much does it? Haskell is gaining popularity slightly too quickly anyway :P
10:32:54 <pmade> davean: That sounds terrible though.  I'm not sure I want that crap on my clean workstation ;)
10:33:08 <davean> Cale: even that neglects the most important part of marketing - it isn't how many people you reach, but if you reach the right people.
10:33:25 <Ainieco> does what i'm asking make sense?
10:33:42 <Cale> Yeah, I think most of the right people also already know that Haskell is good
10:34:49 <bitemyapp> Cale: People can be improved *by* learning how to program properly, via Haskell or otherwise
10:35:02 <bitemyapp> Cale: so through exposure they become the kind of company you want to keep, even if it takes time/effort.
10:35:05 <clintm> Ainieco: Yes, the question makes sense.  I'm very rusty with haskell at the moment, so I'm reluctant to answer your question because I'm probably wrong.  Also, I'm resisting the temptation to say "You probably shouldn't do that."
10:35:28 <bitemyapp> Cale: I wasn't born knowing types are awesome. Being exposed to people that did and languages that showed me how nice they could be did.
10:35:43 <WraithM> Ainieco: Just like you would export any other internal function, I believe: module ModuleA (func) where import ModuleB (func). Certainly you could reexport the module too: module ModuleA (module C) where import ModuleB as C
10:35:55 <Cale> Sure, I don't want us to turn interested people away either.
10:36:09 <clintm> WraithM: I think the defining characteristic here is that they are imported qualified.
10:36:33 <clintm> Which, I guess shouldn't make much of a difference, now that I think about it.
10:37:04 <WraithM> With respect to my haskell-src-exts question above, I guess I'm curious if anybody has any insights? Am I using the wrong cabal command to get that gcc arg in there?
10:37:04 <Cale> Ainieco: Put them in the module's export list?
10:37:05 <clintm> *sniff* so much I used to know right offhand before I took that vacation to commonlispville.
10:37:17 <Ainieco> WraithM: yeah, actually that pseudocode i've posted is working, he-he http://lpaste.net/103472
10:37:43 <Ainieco> i haven't expected that i could use qualifications before actual mode import
10:37:54 <Ainieco> s/mode/module/
10:38:22 <Cale> It's too bad you can't export things with a specific qualification.
10:39:13 <jophish> Is there a neater way of saying: foo :: Foldable a => a b -> Set b; foo = foldr Set.insert Set.empty
10:39:15 <Cale> (the module doing the importing always has to say how they're qualified again)
10:39:28 <Ainieco> Cale: what do you mean by specific? "B.foo" works fine, isn't it specific?
10:40:23 <Cale> Ainieco: It exports foo, that's fine, but when you import the module, you refer to the imported thing as foo, rather than B.foo
10:40:47 <Cale> (unless you import the module qualified as B)
10:41:21 <Ainieco> Cale: ah, i see, thanks for explanation
10:42:23 <Cale> For instance, in a lot of the programs I've worked on, almost every module will have  import qualified Data.Set as S; import Data.Set (Set); import qualified Data.Map as M; import Data.Map (Map)
10:42:43 <Cale> and it would be nice to be able to do that once from some module that everything else in my project imports
10:44:03 <clintm> Cale: is import "qualified Data.Map as M; import Data.Map (Map)" used because of some syntactic reason or is it more of a style preference against referring to the Map type as M.Map?
10:44:20 <Cale> Mostly style preference
10:45:04 <hseg> jophish: You're missing the constraint Ord b. But what about foldMap insert ?
10:45:06 <Cale> I hate seeing qualified names in type signatures for some reason (actually I kind of dislike them anywhere, but in the case of Set and Map, they're pretty unavoidable)
10:46:09 <jophish> hseg: It's a shame it's not built in, I never know where to put functions like this
10:46:31 <jophish> at the moment I've got a less generic version in a particular file
10:48:41 <Bla31416> Hi out there!  What can i do when ghc is running out of memory during a cabal-install?
10:48:54 <hseg> jophish: The question is when you reach the Fairbairn threshold.
10:48:54 <edwardk> install ram?
10:49:18 <albeit> What is recommended to measure the time of a single function execution? Criterion?
10:49:28 <hseg> jophish: That being the point where it is easier to redefine the function instead of looking it up.
10:49:39 <jophish> hseg: yeah, just reading it now
10:49:44 <jophish> hseg: That's a good point
10:50:12 <jophish> hseg: I suppose I'll keep the less general version, and give it a descriptive name
10:50:35 <hseg> jophish: This sort of thing comes up in the Libraries mailing list often. People ask for functions that while useful, aren't complex enough to pote in core libraries.
10:50:49 <nh2> albeit: yes, use criterion
10:51:11 <jophish> hseg: well, fromList is in Set, usually there's a more general version floating around somewhere
10:51:21 <hseg> jophish: What is the less general version? Prelude.foldr Set.insert Set.empty
10:52:08 <jophish> hseg: in my file? I'm using a concrete element type
10:52:14 <davean>  /wi24
10:52:14 <hseg> jophish: Right. But you can drop the fromList and just write foldMap Set.singleton
10:52:36 <jophish> so you're saying that fromList is already below the threshold?
10:52:40 <hseg> jophish: Does it satisfy Ord?
10:52:53 <jophish> hseg: yeah, that's why I forgot Ord in my type earlier
10:53:03 <dwcook> What is this "fairbairn threshold" and why is it so hard to search?
10:53:17 <jophish> http://www.haskell.org/pipermail/libraries/2012-February/017548.html dwcook
10:53:28 <dwcook> Heh
10:53:28 <hseg> jophish: I don't know. It might have been grandfathered in. They might have been laxer when that was added. Or cosmic radiation.
10:53:39 <hseg> Or reasons.
10:54:02 <Bla31416>  http://www.haskell.org/pipermail/libraries/2012-February/017548.html ]  http://www.haskell.org/pipermail/libraries/2012-February/017548.html
10:54:03 <jophish> perhaps for the same reasons we have map and fmap
10:54:06 <Bla31416> sry
10:55:15 <hseg> jophish: Yup. Reasons. As well as the fact that a complete redesign with lessons learnt in mind is *hard* and hard to get adopted.
10:56:21 <jophish> yeah, I suppose so
10:56:30 <jophish> Thanks for the help, hseg
10:56:52 <hseg> jophish: My pleasure. It's been fun.
10:56:59 <pyon> What is the correct way to handle an implicit function application operator ("f x", as in Haskell or ML) using Parsec's buildExpressionParser?
10:59:16 <Ainieco> having haskell architecture question... I have completely wrap some library into my own mdule to be able substitute that wrapped library with other library painlesly
10:59:27 <Ainieco> s/have/want/
11:00:18 <Ainieco> with functions it's really easy, but types are leaking from wrapper.
11:00:35 <orion> In general, if you're writing a parser for a network protocol with attoparsec, should you make one data type, say, "Packet" which contains a value constructor for each type of packet, or should there be a separate data type for each type of packet?
11:01:28 <Ainieco> i see one options here -- wrap original type in my own newtype but i think it'll be hard to work with such newtype in wrapper
11:01:55 <Ainieco> is it correct approach to wrapping unreliable libraries in haskell?
11:02:59 <stelleg> i was wondering if people have some nice alternatives to something like (i++) in the state monad
11:03:15 <heatsink> orion: It depends on whether you would like to write separate functions to handle each type of packet.
11:03:27 <stelleg> i came up with plusplus = do {x <- get; modify succ; return x}, but that feels a bit clunky
11:03:44 <hseg> stelleg: what about 'modify (+1)'?
11:03:53 <monochrom> orion: it depends. if you can't decide, arbitrarily try multiple value constructors first
11:04:12 <stelleg> modify :: MonadState s m => (s -> s) -> m ()
11:04:17 <stelleg> so it won't return the value
11:04:23 <orion> Separate functions to parse each kind of packet would be nicer, probably.
11:04:47 <stelleg> but something along those lines
11:05:15 <stelleg> if there was a modifyAndReturn and modifyThenReturn
11:05:22 <stelleg> seems like those would be a common use case
11:06:11 <gamegoblin> @pl \xs -> take (length xs - 6) xs
11:06:11 <lambdabot> take =<< subtract 6 . length
11:06:48 <hseg> stelleg: If you don't mind using lenses, http://hackage.haskell.org/package/lens-4.1.2/docs/Control-Lens-Lens.html#v:-60--43--61- seems to be what you're looking for
11:07:06 <stelleg> hseg: thanks! thats exactly the kind of thing I was looking for
11:07:23 <stelleg> still trying to get more familiar with lenses
11:07:43 <edwardk> stelleg: note i <+= 1 acts like ++i  and i <<+= 1  acts like i++
11:07:57 <edwardk> the former returns the new value and << means 'old value' in lens
11:08:02 <ReinH> edwardk: do you have a trigger for "lens"?
11:08:04 <stelleg> edwardk: great, thanks for that clarification
11:08:07 <gamegoblin> :t subtract
11:08:08 <lambdabot> Num a => a -> a -> a
11:08:13 <edwardk> ReinH: i let them rotate ;)
11:08:20 <edwardk> ReinH: but currently, yes
11:08:33 <ReinH> gamegoblin: subtract exists because (-1) is parsed as a negative number
11:08:53 <DarthHayashi> heyo, I just got a 'ghc: panic! (the 'impossible' happened)' on ghc 7.8.2, 'Prelude.(!!): index too large', when trying to derive Foldable for 'newtype Program a = Program { programUnits :: [ TranslationUnit a ] }'
11:09:02 <DarthHayashi> I'm not entirely sure how I just broke GHC, but apparently I did >_>;;
11:09:04 <gamegoblin> ReinH: gotcha, I was confused there for a second
11:09:05 <albeit> How can I output debug information only if a condition is met? I have "debug = flip trace", and tried something like "!temp = if condition then 1 else (1 `debug1` "Message")"
11:09:10 <ReinH> gamegoblin: but I don't think the pointfree version using the Monad instance is actually better
11:09:23 <ReinH> it's obfuscating
11:09:32 <DarthHayashi> (using DeriveFoldable, of course)
11:09:47 <hseg> stelleg: Note that lens has <foo= for many prelude functions foo.
11:09:55 <srhb> albeit: That should work?
11:10:15 <albeit> It feel horribly ugly, is there a better way?
11:10:35 <monochrom> what is inside "condition"?
11:10:37 <srhb> albeit: Well, make it into a function
11:10:50 <Ainieco> how to export "type A = B" from module?
11:11:00 <albeit> monochrome: Checking if another variable is null
11:11:08 <ReinH> albeit: move the condition into the debug signature? debugP :: Bool -> String ->  a ?
11:11:30 <gamegoblin> Rein: I was just making it point free for a joke in a reddit comment http://www.reddit.com/r/programming/comments/24g6al/i_have_officially_failed_at_programming/ch70ooo?context=3
11:11:42 <gamegoblin> ReinH *
11:12:02 <stelleg> hseg: awesome, thanks. batteries included indeed :)
11:12:22 <ReinH> gamegoblin: you switched up drop and take :p
11:12:35 <gamegoblin> Oh whoops. Thanks.
11:12:41 <monochrom> Ainieco: export A
11:13:14 <ReinH> current status: code reviewing a troll comment on reddit
11:13:30 <awestroke> how do I tell ghc to treat src/ as the module root rather than ./ ?
11:13:39 <Ainieco> monochrom: excuse me?
11:13:42 <monochrom> please don't review a troll comment
11:13:54 <Ainieco> module Foo ( export A) where ... ?
11:14:05 <hexagoxel> module Foo (A) where
11:14:33 <monochrom> my "export A" was English. I thought you knew how to translate that to Haskell
11:14:42 <heatsink> awestroke: -i src
11:14:45 <hseg> stelleg: I'm willing to bet at least 25% of lens is just the batteries. edwardk, am I right?
11:14:45 <mzarella> What is the recommended method for changing a string of text to something different?
11:15:31 <heatsink> mzarella: Almost everything is different from a string of text, can you be more specific?
11:15:37 <srhb> mzarella: Depends what you're changing it into and how you want that. If you want to (unsafely) parse an integer, say, you can just use read
11:15:40 <Ainieco> monochrom: sorry, was confused by errors made by stylish haskell, i though that "module Foo (A) where" is wrong but error was in other piece of code
11:16:11 <mzarella> Simple rosalind problem, convert Cs to Gs and As to Ts
11:16:17 <awestroke> heatsink: "target `src' is not a module name or a source file"
11:16:20 <srhb> mzarella: Use map then
11:16:49 <edwardk> hseg: yeah but its surprising how much of lens is just 'general combinators you can use everywhere'
11:17:30 <merijn> edwardk: I had a question about a comment you made on reddit, you were saying Haskell had a power-to-weight ratio sweetspot compared to dependently typed languages
11:17:38 <edwardk> stuff we managed to distill as the essence from all the usecases people have trotted out on #haskell-lens over the last couple of years.
11:17:44 <edwardk> merijn: shoot
11:17:53 <merijn> edwardk: But what stops you from writing "haskell" in a dependently typed language?
11:17:59 <awestroke> heatsink: ah, -isrc did it. thanks!
11:18:35 <merijn> i.e. why can't you use them like haskell, but with the optional ability to drop some proper dependent types into your code?
11:18:43 <edwardk> merijn: typeclasses work better than the implicits we get in say, agda, the compiler can compile the knd f code i write in my lifetime, and really the libraries, infrastructure and user base aren't there to appreciate it
11:19:09 <srhb> > let f 'A' = 'C'; f 'G' = 'T'; f x = x in map f "AGX" -- mzarella
11:19:11 <lambdabot>  "CTX"
11:19:21 <srhb> Uh, I mixed them up
11:19:24 <srhb> But you get the point
11:19:37 <merijn> edwardk: And there's no way to have typeclasses in something agda-like?
11:19:42 <monochrom> the error message "you lack a proof of termination" stops me from writing "f 1 = 1; f n = 2 * f (div n 2)" in a dependently typed language.
11:20:39 <orion> Is attoparsec good for parsing binary data, or is there something better?
11:20:40 <merijn> edwardk: To be more concrete, I'm fiddling with implementing my own dependently typed language and I was just curious whether you were referring to a fundamental probelm that makes dependently typed languages more cumbersome than the equivalent haskell.
11:20:59 <srhb> mzarella: Did you catch that?
11:21:00 <merijn> edwardk: Or whether it is just that *currently popular* dependently typed languages are more cumbersome
11:21:38 <pavonia> orion: For serialization of data types you might want to have a look at the binary package
11:21:45 <merijn> monochrom: That only applies to total dependently typed languages
11:21:55 <orion> pavonia: What about parsing?
11:22:03 <merijn> monochrom: You could just as easily implement a non-total dependent language, no?
11:22:45 <edwardk> merijn: i think what it comes down to is that the instance resolution technique we use for typeclasses doesn't generalize cleanly to some of the spiffier things we can say in, say, Agda.
11:22:48 <monochrom> I don't know
11:22:51 <pavonia> orion: You can use attoparsec for this
11:23:08 <edwardk> so you could have a dependently typed language, but only offer typeclasses for a haskell-like fragment
11:23:12 <pavonia> orion: What data do you want to parse?
11:23:20 <merijn> edwardk: Would that not be good enough?
11:23:23 <orion> pavonia: binary network packets.
11:23:29 <edwardk> but such a language would be a strange beast. since you'd switch between vocabularies a lot
11:23:34 <merijn> edwardk: If 90% of the time haskell gets you as far as you go...
11:23:54 <merijn> edwardk: Maybe, but otoh the horrible singletons hacks in haskell are already like switching vocabularies
11:23:57 <edwardk> in agda you wind up with 'boolean blindness' whenever you write something with Bool rather than Dec that keeps you from ever using the shiny tools the language gives you
11:24:01 <milessabin> edwardk: Type classes fit into Idris quite smoothly.
11:24:18 <merijn> Except one of the vocabularies makes you speak in a drunken slurred tongue :p
11:25:18 <pavonia> orion: Not sure what's better suited here
11:25:23 <edwardk> milessabin: the elaborator for idris's typeclasses is search based in a form that permits you to pass explicit instances, isn't it?
11:25:36 <srhb> orion: attoparsec can definitely be used for this.
11:25:39 <milessabin> edwardk: yup
11:25:45 <DarthHayashi> nvm, I realised that deriving Foldable makes no sense whatsoever, as there's fundamentally a kind mismatch, derp
11:25:54 <edwardk> milessabin: so they are glorified implicits, not typeclasses
11:26:08 <milessabin> edwardk: if you say so ;-)
11:26:30 <edwardk> which means becaus provenance of them _can_ matter, i have to care about the provenance of them everywhere in my code.
11:26:32 <merijn> edwardk: I'll have to read up more on Agda first before I can judge, I guess
11:27:09 <edwardk> this means things like the way we handle Set in Haskell for hedge unions wouldn't be sound in Idris
11:27:13 <milessabin> edwardk: As you can imagine, I made my peace with that problem a long time ago.
11:27:35 <edwardk> milessabin: yes. i refuse to give it up, as it forms a large part of how I reason about code.
11:27:39 <pavonia> orion: In my impression binary is better for data that has a more or less fixed/linear layout, while attoparsec is better for parsing grammars with recursion and such
11:27:48 <heatsink> edwardk: Is there no way to do the equivalent of an overlapping instance check?
11:27:51 <milessabin> edwardk: understood.
11:28:12 <edwardk> Haskell moves most instances out to the use site, rather than carry them around inside of all of its data types. This permits fewer dumb data types to serve a wide array of purposes.
11:28:22 <edwardk> The correctness of that transformation is predicated on the coherence of instance resolution
11:29:07 <edwardk> This transformation is key to a lot of the code reuse I get out of Haskell, so ripping out its underpinnings while pretending it still works is pretty dubious to me ;)
11:29:54 <edwardk> I have to run for a bit
11:31:52 <orion> I am struggling a bit on how to call a function based on attoparsec pattern matching.
11:32:38 <orion> parsePacket = (string "HELLO" >> ???) <|> ...
11:32:41 <orion> parseHello = ...
11:33:32 <pavonia> That's not pattern matching, that's reading chars from the input stream
11:33:49 <orion> yes, you're right
11:33:57 <orion> I am not sure what the type of parseHello should be
11:34:40 <pavonia> What is the result of a HELLO packet?
11:34:41 <ocharles> Does anyone know how to construct (a ~ b) as a type in Template Haskell
11:34:42 <ocharles> ?
11:35:02 <ocharles> E.g., I want  Foo (a ~ b) a b  , where Foo (k :: Constraint) a b
11:35:16 <ocharles> (but I want to generate the first part with Template Haskell)
11:35:46 <ocharles> I'm not sure what to use for ~, looking at the definition of 'Type' in http://hackage.haskell.org/package/template-haskell-2.9.0.0/docs/Language-Haskell-TH.html
11:37:19 <monochrom> ocharles: the type is "Pred", the constructor is "EqualP"
11:37:32 <ocharles> monochrom: I can't put a Pred in a Type
11:37:43 <ocharles> other than Forall, which I don't think I want
11:38:00 <ocharles> that would be a ~ b => Foo ...
11:38:20 <orion> pavonia: http://lpaste.net/2109644328992243712
11:38:30 <monochrom> I see, I think there is still hope
11:38:39 <ocharles> Oh, I suppose I could dump something out and see what it is
11:38:42 <ocharles> And work backwards :)
11:40:19 <pavonia> orion: It's like in the IO monad: do { string "QvnQ5XlH"; hello <- parseHello; return $ HelloPacket hello }
11:41:28 <orion> pavonia: But what if the string isn't "QvnQ5XlH" and is instead "RL3aNMXK", which represents a different type of packet?
11:42:03 <pavonia> Then the first alternative fails and the second is tried
11:42:18 <orion> Oh, maybe I don't have a good grasp of Parser then.
11:42:28 <orion> Don't I need <|>?
11:42:54 <pavonia> Yes, that separates the alternative parsers
11:44:10 <ocharles> monochrom: it's AppT with GHC.Types.~
11:45:38 <ocharles> monochrom: which isn't exported...
11:46:23 <CindyLinz> ocharles: Is there a helper function appT ?
11:46:50 <ocharles> CindyLinz: Yea, but appT ''~ didn't seem to work
11:46:52 <ocharles> let me try again
11:47:02 <CindyLinz> orz..
11:47:33 <ocharles> Illegal type constructor or class name: `~'
11:47:35 <CindyLinz> the ~ is a binary operator, you might need two appT for each operand
11:47:48 <ocharles> But it does pick it up as GHC.Types.~ in -ddump-splices :/
11:47:49 <ocharles> I'm doing tilde <- conT ''(~)
11:48:07 <ocharles> oh, I wonder if I need extensions on in the thing using TH
11:48:32 <orion> pavonia: I guess what I'm not understanding is how to apply <|> to this.
11:48:36 <ocharles> hum, still doesn't splice with -XConstraintKinds on either
11:49:19 <CindyLinz> ocharles: Did you add the extension flag in the "user" code?
11:49:24 <ocharles> yea
11:49:39 <CindyLinz> ~_~
11:49:43 <pavonia> orion: You want something like (string "Q..."; ...) <|> (string "R..."; ...) <|> ...
11:49:58 <ocharles> CindyLinz: appropriate :)
11:50:33 <albeit> I'm trying to time a function, but folding over the same value 1000 times and collecting the results from the function and then printing the list of results. Am I timing what I think I'm timing, or is lazyness making it way quicker?
11:50:38 <albeit> *by folding over
11:50:49 <orion> hmm
11:50:50 <orion> ok
11:51:01 <pavonia> orion: If the first sub-parser succeeds the result of it is the result of the complete parser, if it fails the next sub-parser is tried and so on
11:51:18 <hseg> albeit: You're probably going to run into sharing optimizing the results for subsequent operations.
11:51:39 <pavonia> orion: I think RWH has a chapter on attoparsec, that may be a good start
11:51:44 <winsoff> How does inheritance work in Haskell?
11:51:51 <hseg> albeit: If I'm not mistaken, Criterion should be of use here. Have no experience with it, though.
11:51:54 <winsoff> Or do I have to define my own functions every single time?
11:51:56 <orion> pavonia: thank you
11:52:01 <albeit> hseg: Okay, thanks
11:52:11 <hseg> winsoff: Haskell has no concept of inheritance. You might be meaning something else.
11:52:12 <davidthomas> winsoff: Depends what you mean by inheritance, really
11:52:25 <winsoff> Yeah, I mean library usage, I supposed.
11:52:41 <winsoff> The ability to have functions like "quadratic solver" without implementing it myself every time.
11:53:13 <davidthomas> winsoff: Well, something like that, you can throw in a library somewhere...
11:53:37 <davidthomas> winsoff: possibly polymorphic, depending on what you need
11:54:03 <hseg> winsoff: Well, typeclasses give you something like interfaces from OO.
11:54:21 <winsoff> I am still misunderstanding the difference between types and objects.
11:54:25 <ocharles> CindyLinz: I have a feeling I'm hitting https://ghc.haskell.org/trac/ghc/ticket/7667 - so maybe GHC 7.8 fixes this
11:54:27 <winsoff> They seem to be pretty related.
11:54:46 <davidthomas> Classes are your way of creating a new type, in most OO langauges
11:54:51 <davidthomas> so they're related in that sense
11:55:06 <hseg> winsoff: Correct me if I'm wrong, but are you trying to say (in OO-speak) that if A implements an interface, B implements it too?
11:55:47 <TallerGhostWalt> is the working directory global to all running threads?
11:55:51 * hackagebot hledger-irr 0.1.1.4 - computes the internal rate of return of an investment  http://hackage.haskell.org/package/hledger-irr-0.1.1.4 (JoachimBreitner)
11:55:51 <winsoff> hseg: To what extent?
11:55:51 <monochrom> there is no inheritance, and yet you don't have to repeat code every time.
11:56:30 <Ainieco> is it possible to catch exception thrown by "Irrefutable pattern failed for pattern" ?
11:56:45 <bennofs> Ainieco: it is, but probably not a good idea
11:56:48 <hseg> winsoff: To the extent that, say, if I can define an ordering on A, then I can define an ordering on B. Basically, are you trying to say B "inherits" all of A's implementations of interfaces?
11:57:04 <bennofs> Ainieco: also only in the IO monad
11:57:20 <Ainieco> bennofs: i'm trying to fix library which is throwing excpetions from time to time and i'm not sure how to do it properly
11:57:32 <CindyLinz> ocharles: sounds hopeful ^^
11:57:43 <Ainieco> bennofs: unsafePerformIO should do the trick probably :)
11:57:53 <ocharles> CindyLinz: Well, I get a different error now, so I think it worked ;)
11:57:59 <bennofs> Ainieco: so you're already modifying the library?
11:58:33 <CindyLinz> ocharles: :D
11:59:12 <hseg> winsoff: i.e. If I have a function of type A -> Foo, then I should be able to write B -> Foo?
11:59:14 <Ainieco> bennofs: nope, writing wrapper for that library, it's not possible modify it because i need to change type of typeclass function to Maybe Something and to do that I basically need to rewrite it from scratch because of types
11:59:56 <bennofs> Ainieco: Why would you need to rewrite it from scratch? What library is that?
11:59:58 <winsoff> hseg: Right.
12:00:41 <Ainieco> bennofs: because if i change typeclass i need to change evcerythinh depenent on it and this means besically rewriting, it's FGL.
12:00:48 <hseg> winsoff: Well, first off, you probably have some function B -> A that projects values of type B to appropriate values of type A.
12:01:05 <winsoff> Interesting.
12:01:18 <hseg> winsoff: So you could probably use function composition.
12:01:35 <winsoff> So what if, instead of doing global variables like in OO, I just keep adding arguments to functions that "pass through" certain arguments without performing data on them for the final aggregation for output?
12:01:36 <bennofs> Ainieco: the exception you'd need to catch is PatternMatchFail. Still, I think this is a very bad idea (although I don't know how to do it in a better way)
12:02:17 <Ainieco> bennofs: well, better way is to dump/rewrite FGL but i don't have time for rewriting and there no alternative to it. :)
12:02:25 <Ainieco> bennofs: okay, got it, thanks!
12:02:41 <bennofs> Ainieco: what function would you need to change to return a Maybe a instead of an a?
12:02:46 <hseg> winsoff: That's an entirely different question. And I'm not sure I understand you perfectly.
12:03:02 <Ainieco> bennofs: insEdge
12:03:15 <Kaidelong> I'm having some trouble understanding how libraries like lambdacube can be agnostic as to the choice of glut, glfw, or glfw-b
12:03:23 <pavonia> Ainieco: Is that pattern match error expected? It sound like a bug to me
12:03:33 <Kaidelong> does the GL library itself define some type for GL surfaces?
12:03:48 <winsoff> hseg: Instead of having global variables, what if I pass all of my states through each function, only accessing them occasionally, but always passing them?
12:03:52 <winsoff> Is that functional?
12:04:29 <bennofs> Ainieco: How can inserting an edge fail? If the vertices of the edge don't exist?
12:04:37 <hseg> winsoff: Yes. Usually, you'd use a State monad to pass that state through.
12:04:41 <Ainieco> pavonia: what do you mean by expected? insEdges uses function whichreturns (Maybe, ...) and insEdge match only on (Just a, ...).
12:04:46 <winsoff> hseg: Weird.
12:04:48 <winsoff> Be back later!
12:04:50 <MagneticDuck> you can simulate pretty much any sort of language you want with haskell
12:04:50 <hseg> winsoff: Why?
12:04:54 <winsoff> Just curious.
12:04:56 <Ainieco> bennofs: yep
12:05:01 <davidthomas> hseg, winsoff: State if you're changing it, Reader if you're not
12:05:13 <bennofs> Ainieco: so maybe you could just check if both vertices exist before you insert?
12:05:18 <hseg> davidthomas: Yeah. Forgot about Reader there.
12:05:38 <davidthomas> hseg: no worries :-P
12:07:10 <TallerGhostWalt> is anyone else having trouble with the emacs repl since the cabal 20?
12:07:17 <bennofs> Ainieco: or maybe just don't try to insert edges that contain invalid nodes? :D
12:07:22 <Ainieco> bennofs: yeah, that probably way to go and in some ways it's better than exceptiond catching and in other ways it's worse because insEdges uses function which already checks for vertices
12:07:41 <monochrom> ideally, insEdge would have a dependent type. as it is, making its co-domain a Maybe is as annoying as tolerating a partial functions.
12:09:25 <Ainieco> so bascially check for existing vertices will be executed twice, once in my code and once in FGL which makes me sad. :)
12:10:14 <bennofs> Ainieco: or maybe just write a new insEdgeMaybe that you use you use in your code?
12:11:45 <monochrom> this is a similar issue as div :: Integer -> Integer -> Integer
12:12:10 <Ainieco> bennofs: agreed, that's probably a best way to solve it
12:12:32 <monochrom> you may say, let's write a wrapper, safediv :: Integer -> Integer -> Maybe Integer. many people have said that, you will not be alone. but no one actually does it and use it.
12:13:49 <monochrom> what people actually do, whenever they use div, is this: their programs provably do not pass in 0 as the 2nd parameter.
12:13:55 <napping> Are your vertices changing?
12:14:17 <monochrom> and they don't even check. the 2nd parameter is non-zero by construction. there is no need to check.
12:15:03 <Ainieco> napping: i'm inserting and deleting vertices if that counts as change.
12:16:02 <hseg> It's a pity there isn't a way to say: Given a proof that y is nonzero, div :: Int -> Int -> Int. Otherwise, div :: Int -> Int -> Maybe Int
12:16:21 <dwcook> I was just looking up whether Idris did that, actually
12:16:29 <dwcook> Agda surely has that capability as well
12:17:28 <hseg> Actually, this generalises. It's a pity that you can't pass any function that does case analysis a proof that a case is impossible, which would eliminate that term of the sum type from the result.
12:18:10 <hseg> Although this generalization might be too dangerous.
12:19:09 <heatsink> Wouldn't you just have two different div functions?
12:19:36 <monochrom> have two functions
12:20:02 <hseg> You could do that. It's just that if I could tell GHC that a case is impossible, I'd like for it to remove that case from consideration.
12:20:11 <monochrom> tight_div :: Int -> { x :: Int | x /= 0} -> Int
12:20:52 <heatsink> You can use GADTs to tell GHC to exclude constructors in pattern matching.
12:20:57 <monochrom> loose_div :: Int -> (d :: Int) -> { y :: Maybe Int | if d/=0 then y is a Just else y is Nothing }
12:21:16 <hseg> monochrom: And then some form of a rewrite loose_div -> tight_div when I know y /= 0 for a fact?
12:21:19 <dwcook> Still need DTs for that
12:21:23 <Iceland_jack> heatsink: GHC still can't prove the patterns are exhaustive
12:21:24 <monochrom> no rewrite
12:21:35 <heatsink> oh.
12:22:04 <ocharles> dreixel: capturing equality as a constraint doesn't seem to work, from my first attempt
12:22:05 <n-dolio> You could overload them. Possibly you could do that in Idris.
12:22:23 <hseg> n-dolio: "overload"
12:22:24 <hseg> ?
12:22:25 <n-dolio> class DivResult d where div :: Int -> Int -> d
12:22:42 <n-dolio> Except that's not good enough.
12:22:42 <monochrom> no, { x :: Int | x /= 0} is not Int
12:22:53 <n-dolio> monochrom: Uncurry.
12:22:59 <monochrom> you are thinking of Type Directed Name Resolution
12:23:17 <n-dolio> class DivResult d where div :: (m :: Int) -> (n :: Int) -> d m n
12:23:30 <n-dolio> instance DivResult (\_ _ -> Maybe Int) where ...
12:23:33 <monochrom> that is a horrible idea
12:23:36 <Iceland_jack> heatsink: For example if you have
12:23:36 <Iceland_jack>     DegC :: Int -> Deg C
12:23:36 <Iceland_jack>     DegF :: Int -> Deg F
12:23:47 <n-dolio> instance DivResult (\_ n -> n /= 0 -> Int) where ...
12:24:07 <Iceland_jack> If you write a function
12:24:07 <Iceland_jack>     add :: Deg a -> Deg a -> Deg a
12:24:07 <Iceland_jack> there should only be two cases: adding two DegC or two DegF
12:24:14 <n-dolio> Well, I agree that it's a bad idea.
12:24:21 <n-dolio> But if that's how you could do it.
12:24:44 <Iceland_jack> But GHC will complain about non-exhaustive patterns
12:24:44 <Iceland_jack>     Patterns not matched:
12:24:44 <Iceland_jack>         (DegC _) (DegF _)
12:24:44 <Iceland_jack>         (DegF _) (DegC _)
12:24:47 <Iceland_jack>  
12:24:51 <Iceland_jack> even though that would be a type error
12:25:14 <heatsink> I see.
12:25:46 <Iceland_jack> adding
12:25:46 <Iceland_jack>     add (DegF a) (DegC b) = …
12:25:46 <Iceland_jack> GHC complains
12:25:46 <Iceland_jack>     Couldn't match fype ‘'F’ with ‘'C’
12:25:54 <n-dolio> I assume that won't actually work in Idris, because you need to make instances for things that will reduce when fully applied, which doesn't make sense.
12:25:55 <Iceland_jack> Damned if you do, damned if you don't.
12:26:09 <Iceland_jack> The GHC type system doesn't have a notion for type inequality
12:26:47 <monochrom> let's fake type inequality in GHC
12:27:17 <monochrom> ((x ~ y) -> Void) would be a way to say "x not equal y"
12:27:52 <monochrom> I don't actually find type inequality important, but it may be somewhat doable like that
12:29:45 <binq> Is there an easy way to get the list of extensions my systems GHC supports from the command line?  I know you can do ":set -X\t" from ghci, but I need something that does the equivalent strait from the command line.
12:30:03 <n-dolio> ghc --supported-languages
12:30:16 <napping> Ainieco: if the vertices were fixed and just edges changesd, maybe some tricks could be used to allow only legal vertices - like Oleg's stuff on "branding"
12:30:34 <binq> thank you!
12:31:47 <TallerGhostWalt> and the answer to the question I asked earlier about changing the working directory in a thread... It is global
12:31:55 <Ainieco> napping: http://okmij.org/ftp/Haskell/eliminating-array-bound-check-followup.txt ?
12:32:25 <napping> Yeah
12:32:49 <monochrom> hmm, div is too long an example. too many parameters. recip :: Rational -> Rational is shorter
12:33:31 <monochrom> ConorT McBride is a monad transformer stack :)
12:33:46 <monochrom> @quote monochrom sirloin
12:33:46 <lambdabot> No quotes match. It can only be attributed to human error.
12:34:03 <monochrom> that's too bad. I had a joke about T-bone steaks and monad transformers
12:35:16 <monochrom> culinary monadology :)
12:35:38 <Clint> o_O
12:35:55 <int-e> huh. http://ircbrowse.net/browse/haskell?q=sirloin
12:36:07 <monochrom> hehe
12:37:18 <hseg> Question. I have a list of pairs that I'd like to filter based only on one component. Is there a simple way of doing this?
12:38:00 <Iceland_jack> hseg: Do you want both components in the final result?
12:38:26 <hseg> Basically, what I'm trying to do is take all subsequences of a list containing no duplicates and terminating in a certain character, along with the longest tail of the list not intersecting that subsequence.
12:38:28 <hseg> yes.
12:38:28 <Iceland_jack>     [ (a, b) | (a, b) <- xs, predicate b ]
12:38:28 <Iceland_jack> is one possibility
12:38:55 <Iceland_jack> so is
12:38:55 <Iceland_jack> :t filter (?predicate . snd)
12:38:56 <lambdabot> (?predicate::b -> Bool) => [(a, b)] -> [(a, b)]
12:39:19 <hseg> wait, what?! what's this ?predicate thing? how does it work?
12:39:35 <Iceland_jack> It's an implicit parameter
12:40:02 <Iceland_jack> I could have also done
12:40:02 <Iceland_jack> :t filter ((undefined :: b -> Bool) . snd)
12:40:03 <lambdabot> [(a, b)] -> [(a, b)]
12:40:53 <int-e> > let x = ?a in (let ?a = 42 in x, let ?a = 23 in x)
12:40:55 <lambdabot>  (42,23)
12:41:10 <albeit> Can I have a module Foo import some functions from module Bar, but both have a main function?
12:41:23 <monochrom> yes
12:41:51 <napping> There's nothing special about naming a function main in modules other than the main module of your program
12:42:06 <albeit> If at the top of Bar, I have "module Bar where", and I can compile it by itself, it doesn't generate an executable?
12:42:19 <napping> Nope. I think there's an option to override that
12:42:41 <monochrom> because you have called it Bar.
12:42:57 <monochrom> either call it Main, or ghc --main-is Bar
12:43:14 <arrnas> http://lpaste.net/103474 how would i go about using the list of lines that is returned by fileParser instead of printing out the result?
12:43:26 <monochrom> I have no checked the exact syntax for "ghc --main-is Bar". read the GHC user's guide.
12:46:24 <albeit> Great, it's "-main-is" officially. thank
12:46:26 <albeit> *thanks
12:48:50 <napping> Are these separate "main modules", or do other modules include them?
12:49:12 <napping> It sounds like recompilation has a bit of troulbe with --main-is
12:50:46 <pavonia> What is the rule on what characters are converted to a single character list when show is applied (not counting quotes)?
12:51:47 <albeit> They both have a main function, and Foo imports Bar, but never vice versa. Foo just needs access to some of Bar's functions. They ideally can both be run separately, doing different things.
12:53:07 <heatsink> pavonia: It's probably not a good idea to rely on exactly how characters are formatted.  Why do you want to know?
12:53:36 <napping> sounds like that's the case you need to be careful of, when you try to build with Bar as main after building with Foo as main
12:54:27 <pavonia> heatsink: Just wondering, I'm preparing a debugging function that prints chars and the coloumn formatting is off :p
12:55:14 <btcNeverSleeps> I just tried a "cabal install criterion" (ghc version 7.4.1, latest cabal, Debian Linux) and it failed with a: "The exception was: ExitFailure 1". Could this be because my ghc is too old?
12:55:44 <geekosaur> I think any time you need to depend on that, you want to handle it yourself. (But I will warn you now that that gets *scary* if you are expecting to do anything with characters outside the range \x20-\x7e)
12:56:05 <geekosaur> btcNeverSleeps, "ExitFailure 1" means precisely: something failed.
12:56:15 <geekosaur> in particular, it says nothing whatsoever about what failed, or why
12:56:16 <heatsink> In that range, I see only ' and " are escaped.
12:56:29 <heatsink> Oh, and \
12:56:57 <btcNeverSleeps> a little above that error message, there's a "Criterion/Analysis.hs:127:15: No instance for (Data.Vector.Generic.Base.Vector v0 Double)" msg
12:57:54 <btcNeverSleeps> and right after a: "Couldn't match type `primitive-0.5.2.1:Control.Monad.Primitive.PrimState m0".  But basically my question is: "Why did 'cabal install criterion' not went smoothly?"   Is this something common for a 'cabal install ...' to fail?
12:58:27 <pavonia> Okay, printing the character itself is not a solution either "*** Exception: <stdout>: hPutChar: invalid argument (character is not in the code page)"
12:58:54 <heatsink> If you're debugging, you probably should stick to ASCII printable characters
12:59:28 <hseg> Is there a way to do something like: [(i, t) | (is, t) <- zip (inits xs) (tails xs) | i <- subseqs is]
12:59:37 <heatsink> Maybe show the character as a hex number?
12:59:46 <btcNeverSleeps> shoot: just found this bug report from 7 days ago, but I don't understand what's going on: https://github.com/bos/criterion/issues/49
13:00:33 <heatsink> btcNeverSleeps: The bug report says that criterion's package dependences are too permissive, so it tries to build with incompatible package versions
13:00:59 <pavonia> heatsink: Yeah, I'm doing that but wanted an easy-to-read version too. I think I will use the Unicode description for higher value characters
13:01:26 <btcNeverSleeps> heatsink: thx, I'm new to Haskell so this is all very interesting to me. What does the person mean when he says: "This is exactly what we PVP-types are saying when we insist that omitting the upper bounds on your deps is user-hostile and guaranteed to cause spurious build failures."
13:01:28 <Heffalump> btcNeverSleeps: try cabal install --constraint 'criterion>=0.8.0.1'
13:01:40 <Heffalump> btcNeverSleeps: that's part of an ongoing debate with the Haskell community
13:01:52 <btcNeverSleeps> Heffalump: trying right away: do I need to clean something first seen that a previous install failed?
13:02:07 <Heffalump> the PVP is the thing that says "you should specify bounds that guarantee as far as possible that cabal install will never fail to compile something if it finds an install plan"
13:02:41 <Heffalump> and some people feel it's too onerous to comply with it and wastes people's time when it proves to be too conservative, and others feel that it's very important to comply to avoid this kind of problem
13:02:57 <Heffalump> btcNeverSleeps: I think it will probably be ok, but not certain
13:03:08 <srhb> Does something like Behave for Unity exist in Haskell?
13:03:34 <Heffalump> s/with the Haskell community/within the Haskell community/ above
13:04:08 <heatsink> > let xs = [1,2,3] in [(i, t) | (is, t) <- zip (inits xs) (tails xs) , i <- subseqs is]
13:04:10 <lambdabot>  Not in scope: ‘subseqs’
13:04:10 * btcNeverSleeps is gone eating b/c girlfriend is yelling and shall report later on : )
13:04:41 <lyxia> :t subsequences
13:04:42 <lambdabot> [a] -> [[a]]
13:04:49 <heatsink> > let xs = [1,2,3] in [(i, t) | (is, t) <- zip (inits xs) (tails xs) , i <- subsequences is]
13:04:51 <lambdabot>  [([],[1,2,3]),([],[2,3]),([1],[2,3]),([],[3]),([1],[3]),([2],[3]),([1,2],[3]...
13:04:58 <heatsink> hseg ^
13:05:16 <DarthHayashi> @pl \f g x y -> (f x) `g` (f y)
13:05:16 <lambdabot> flip =<< ((flip . ((.) .)) .) . flip (.)
13:05:20 <DarthHayashi> nothx
13:05:44 <heatsink> That looks like 'on'
13:05:53 <joneshf-laptop> DarthHayashi, isnt that `on`?
13:05:55 <hseg> Thanks
13:05:56 <joneshf-laptop> ah
13:05:57 <joneshf-laptop> :t on
13:05:58 <lambdabot> (b -> b -> c) -> (a -> b) -> a -> a -> c
13:06:30 <DarthHayashi> hmm
13:06:33 <DarthHayashi> so it is
13:06:41 <joneshf-laptop> :t   \f g x y -> (f x) `g` (f y)
13:06:42 <lambdabot> (t2 -> t1) -> (t1 -> t1 -> t) -> t2 -> t2 -> t
13:06:54 <joneshf-laptop> :t   \g f x y -> (f x) `g` (f y)
13:06:55 <lambdabot> (t1 -> t1 -> t) -> (t2 -> t1) -> t2 -> t2 -> t
13:07:17 <DarthHayashi> thanks =p
13:07:20 <hseg> oddly, djinn responds with:
13:07:27 <hseg> @djinn (b -> b -> c) -> (a -> b) -> a -> a -> c
13:07:27 <lambdabot> f a b c _ = a (b c) (b c)
13:07:56 <hseg> I thought djinn was supposed to maximize the amount of parameters it uses.
13:10:18 <pavonia> Is there a way to hardcode a Data.Map in a Haskell file? Using fromList for a huge list seems unnecessarily slow
13:11:49 <geekosaur> no, the constructors are hidden (deliberately and for very good reason)
13:12:19 <TallerGhostWalt> I hate it when I want to ask about an exception that was thrown, only to realize I wrote the thing
13:18:27 <Jei> :D
13:19:52 <davidthomas> geekosaur: For a very good reason that isn't invalidated by fromAscList?
13:20:19 <edwardk> pavonia: if you put that fromList into a CAF (top level definition) it'll get computed once and used from there on out.
13:20:55 <pavonia> Yes, that's the best we can get, I guess
13:21:37 <heatsink> If it's a performance critical read-only map, you'd be better off building a hash table
13:24:06 <quchen> Quickchecking with functions is not a lot of fun, is it? I'm trying to get a test for "myZipWith == Prelude.zipWith". Are there good ways for generating multi-argument functions?
13:25:15 <quchen> I tried using a curried version, but I'm swarmed by unhelpful type errors. And the documentation is awful. :-\ http://lpaste.net/103475
13:25:41 * enthropy would do myZipWith id == Prelude.zipWith id
13:26:17 <pavonia> heatsink: It's a read-only table, yes. What data type/package would I use for a hash table?
13:26:25 <fread2282> what's the web-based hp visualizer?
13:27:43 <n-dolio> @type uncurry
13:27:43 <lambdabot> (a -> b -> c) -> (a, b) -> c
13:27:53 <fread2282> found it: http://heap.ezyang.com/
13:28:37 <quchen> The easiest way is probably defining a Show instance for functions and be done with it. But there ought to be a better way to use functions in QuickCheck.
13:29:18 <n-dolio> Why not just use functions? There's an arbitrary instance for them.
13:29:55 <quchen> n-dolio: The problem is that functions don't have a Show instance, so the typechecker complains.
13:29:58 <heatsink> Unfortunately, all the hash table libraries I know are monad-based
13:30:09 <quchen> I'm not sure what the Arbitrary instance for functions is good for, to be honest.
13:30:14 <heatsink> Is there a library with pure, read-only hash tables?
13:30:42 <hseg> OK, gotta go. Thanks guys, see you!
13:31:25 <edwardk> heatsink: good question. i just realized one of my favorite toys (overmars and van leeuwen's dynamization technique) could be used for hash tabls.
13:31:33 <edwardk> maybe i should give it a shot
13:31:59 <edwardk> something like a version of a dynamized sorted linear hash table seems doable
13:32:37 <heatsink> Arrays have this nice freezing-based interface for mutable initialization.
13:32:54 <heatsink> I think we're lacking the same interface for mutable initialization of read-only hash tables.
13:33:37 * heatsink hasn't heard of dynamization before
13:33:50 <edwardk> heatsink: well, what i'm looking more towards is a technique that gives you a logarithmic time slowdown, but makes it so you on't pay more than a logarithmic cost in inserts despite allowing growing, with a different memory layout than the naive trees
13:34:33 <akurilin> Ok I asked this before but never quite got a to conclusion: I want to write a quick one-off "script" in haskell to parse/trim a giant text file. Can I just use runghc for this purpose or is there something betteR? I'm trying to avoid having to setup a cabal proejct and sandbox
13:34:33 <heatsink> edwardk: Is this article what you're referring to? "Some principles for dynamizing decomposable searching problems"
13:34:37 <n-dolio> quchen: Anyhow, the problem with your code was that you used uncurry instead of curry.
13:34:39 <n-dolio> From what I could tell.
13:35:27 <edwardk> heatsink: that should have the approach in it. i abuse a functional form of it i came up with in github.com/ekmett/structures
13:36:03 <edwardk> http://en.wikipedia.org/wiki/Dynamization gives the general idea
13:36:31 <edwardk> The decomposition section in the wikipedia article is naive though
13:37:05 <quchen> n-dolio: Oh, indeed. Thanks.
13:37:16 <quchen> Now I'm interested in testing larger function types anyway though :-D
13:41:34 <srhb> akurilin: runghc and cabal sandboxes are completely orthogonal
13:41:35 <edwardk> heatsink: http://compgeom.cs.uiuc.edu/~jeffe/teaching/datastructures/notes/01-statictodynamic.pdf is probably more accessible.
13:42:17 <edwardk> if you replace the structures of overmars and van leeuwen with a data structure based on a number system you get a zeroless binary number system with 2s and 3s for the digits
13:42:25 <srhb> akurilin: That is, you can use runghc on a sandboxed project or on a one-off haskell file.
13:42:40 <edwardk> and that is sufficient to implement their approach functionally for structures that don't need contiguous storage
13:43:01 <heatsink> I'll read over your link.  I think I have to do that before I understand what you want to do with hash tables.
13:43:07 <edwardk> and with my deamortized ST trick, we can implement their approach with a purely functional API even if some idempotent effects happen under the hood.
13:43:38 <edwardk> lets try to walk through a similar trick on a simpler data structure
13:43:50 <edwardk> lets say you wanted to build a Map.
13:43:51 <heatsink> I have to go though
13:44:03 <edwardk> fair =)
13:44:04 <hiptobecubic> edwardk, the rest of us are still listening!
13:44:23 <edwardk> hiptobecubic: hah. ok
13:44:29 <hiptobecubic> I missed some context, but it sounds good so far based on this paper :)
13:44:43 <hiptobecubic> everyone loves search problems
13:44:44 <edwardk> for a Map the simplest structure that can work is a flat array of key/value pairs
13:44:57 * heatsink writes down the time so I can find the chat log
13:44:58 <edwardk> it has some nice properties
13:45:13 <akurilin> srhb: fair enough, good point
13:45:27 <edwardk> it is cache oblivious, as no matter what caches you have eventually you'll get down within the cache line
13:45:36 <srhb> akurilin: I'm not sure what your question really is. :)
13:45:44 <edwardk> but modifying it sucks
13:45:53 <edwardk> this is where dynamization comes in
13:46:05 <edwardk> the simplest dynamization scheme is to use many structures
13:46:09 <srhb> akurilin: If you just want to write a simple haskell program and don't want to worry about packages etc. you can just write that single standalone file and use runghc/ghc on it.
13:46:10 <hexagoxel> yay "Couldn't match kind `*ghc: panic! (the 'impossible' happened)"
13:46:42 <edwardk> what we'd do is say, if you have n elements, break n down as a binary number, and if there is a 1 in the 2^i's place, then you have a structure of size 2^i.
13:46:44 <hexagoxel> now.. i need a nightly ghc or something..
13:47:03 <srhb> hexagoxel: You're in luck, nightly ghc builds were set up recently afair.
13:47:08 <edwardk> if we can glue together the answers from these smaller structures, we can now 'dynamically' work with our array.
13:47:15 <hiptobecubic> edwardk, hmm
13:47:24 <edwardk> by making a new singleton array and merging like the merge pass of a merge sort
13:47:29 <hiptobecubic> ok
13:47:33 <edwardk> until we get back to a legal configuration
13:47:56 <eizo> haskell takes one minute to generate let myPrimes = takeWhile (<= 25000000) primes with the Math.NumberTheory.Prime package, is there a faster way?
13:48:03 <edwardk> now we're doing log n searches, but inserts have an amortized logarithmic cost (divided through by the blocksize)
13:48:17 <edwardk> everything is amortized right now
13:48:27 <edwardk> to get _worst case_ bounds we need a better number system
13:48:32 <edwardk> binary won't cut it
13:48:48 <edwardk> also, the amortization s bad
13:48:51 <edwardk> er is bad
13:48:58 <edwardk> because it isn't a functional amortization
13:49:05 <edwardk> it presumes you only ever edit the latest version of the map
13:49:09 <hiptobecubic> what is a functional amortization
13:49:11 <hiptobecubic> oh
13:49:13 <hiptobecubic> Ok
13:49:24 <edwardk> but if you have 2^100-1 elements and insert 1, you rebuild the whole thing
13:49:43 <edwardk> but then if you go back to that 2^100 elements - 1 map, and insert again you pay all over again
13:49:52 <edwardk> the 'amortization' didn't stick
13:50:22 <edwardk> so we actually -have- to fix the worst case bounds in order to get correct asymptotics even in the average case.
13:50:39 <edwardk> that inspires me to look for other tools
13:50:46 <hiptobecubic> well you typically rebuild in such a way that you aren't right next to another failover state, no?
13:51:13 <edwardk> we need to make it so we only ever pay for a logarithmic amount of the rebuilding work at any given step
13:51:29 <corgifex> oh no, it's okasaki all over again
13:51:34 <hiptobecubic> ok but that's not amortized
13:51:42 <edwardk> corgifex: we need go further than okasaki
13:51:57 <hiptobecubic> we're talking now actual worst case bounds for any input?
13:52:37 <edwardk> hiptobecubic: i can hide it amortized behind a thunk that gets forced after a million steps, but we can actually get it 'worst case'
13:52:47 <edwardk> by abusing side-effects
13:53:14 <edwardk> so what i want is a form of ST, but where i can pause anywhere along the way
13:53:58 <edwardk> I can do this with creative abus of unsafeInterleaveST and the 'free completely iterative monad', but it actually works a bit better with some unsafePerformIO ;)
13:54:43 <corgifex> try to keep your unsafePerformIO/line ratio under 1
13:55:01 <edwardk> so what i want is to only ever do a logarithmic number of 'merge steps' at a time and to always do a logarithmic number of merge steps for every insert.
13:55:42 <edwardk> the number system i know of that can give me 'just enough lag' is to use 'zeroless binary' were the digits are worth 1, 2, 4, ...    but the digits themselves are all 0-3, and 0 an 1 only occur in leading position
13:56:21 <edwardk> so the numbers look like 0,1,2,3,12,13,22,23,32,33,122,123,132,133,222...
13:56:46 <hiptobecubic> hm
13:56:55 <hiptobecubic> but what are you gaining from this?
13:57:16 <edwardk> now, the time lag between having 2 in a column and needing 1 in the next column is exactly long enough that i can pay for one merge for every digit every time step
13:57:18 <hiptobecubic> it's not obvious to me how the "if there's a 1 in the ith place..."
13:57:22 <hiptobecubic> applies to this
13:57:27 <edwardk> lets look at code
13:58:01 <edwardk> https://github.com/ekmett/structures/blob/master/src/Data/Vector/Map.hs#L158
13:58:06 <edwardk> that is a bit dense
13:59:12 <edwardk> but at its heart what i'm doing is merging one entry for each of the log n digits i have. (technically i've batched them up into merges of 1000, because of constant factors, using Data.Map as a nursery)
13:59:41 <hiptobecubic> it's a *little* dense, yes
14:00:05 <hiptobecubic> unsafeDupablePerformIO? is that for idempotent IO?
14:00:09 <edwardk> focus on the data type for a sec: https://github.com/ekmett/structures/blob/master/src/Data/Vector/Map.hs#L79
14:00:11 <edwardk> yeah
14:00:32 <edwardk> here if we replayed a merge because of the same thunk racing itself, we'd just compute the same value and put it in the same place
14:01:14 <edwardk> the data type for LA k a matches the number system described
14:01:23 <DMcGill> I was looking at the source for the containers library http://hackage.haskell.org/package/containers-0.5.5.1/src/Data/Set/Base.hs
14:01:42 <edwardk> we can have a 0 or 1 array, or we can have 2 or 3 arrays as long as there is another more significant digit after it
14:01:48 <DMcGill> and the type sigs for balanceL and balanceR are "a -> Set a -> Set a -> Set a"
14:01:50 <edwardk> view it as a linked list from the right of the number
14:02:13 <edwardk> 132   is M2 ... (M3 ... (M1 ...))
14:02:18 <DMcGill> but the code is "balanceL x l r = case r of ... -> Bin 1 x Tip Tip"
14:02:21 <hiptobecubic> i see
14:02:26 <DMcGill> oh wait I'm an idiot
14:02:30 <DMcGill> sorry for the spam
14:02:35 <edwardk> an when we have 2 arrays of a given size we start merging them
14:02:59 <edwardk> but the timing for my number system is such that exactly when we need to start merging the next one we finish merging the current one
14:03:28 <edwardk> so it is okasaki/knuth style in that it uses a custom number system and models a data structure on arithmetic for that system
14:04:02 <edwardk> but it steps outside of okasaki by using ST (well, here IO) calculations to build up flat arrays in memory on a worst-case basis.
14:04:11 <hiptobecubic> is there something like this in okasaki?
14:04:28 <edwardk> okasaki doesn't do this, but he does do skew binary random access lists
14:04:44 <edwardk> skew binary isn't powerful enough for this case though
14:05:09 <edwardk> now, we could go further
14:05:32 <edwardk> i could go back and switch this to get only amortized performance using this same structure, but by drpping the MArrays
14:05:41 <edwardk> replace them with a lazy (Array k) (Array a) pair
14:05:49 <edwardk> and force it after we finally need it
14:06:13 <edwardk> now worst case performance is linear, but the whole structure becomes faster
14:06:44 <hiptobecubic> faster by a constant factor you mean?
14:06:47 <edwardk> an it retains the correct amortization, okasaki style
14:06:50 <edwardk> yeah
14:07:06 <edwardk> it gets about 2x faster in exchange for a drastically worse worst case
14:07:49 <edwardk> i need to package up that version as well
14:08:09 <edwardk> anyways this same scheme works for other structures
14:08:24 <edwardk> we can do, say, a snoc'able array that lets you read runs of it mostly cache-coherently
14:08:39 <edwardk> by just appending instead of riffling key/values together
14:09:05 <edwardk> i've been eyeballing that for working with succinct data structures as a backing store
14:09:24 <edwardk> as i can navigate the spine of that (which has log entries) in log-log time
14:10:28 <edwardk> anyways this is sort of the first structure i'm going to talk about next week at lambdajam. we'll see how the talk goes =)
14:10:37 <hiptobecubic> :) is it recorded?
14:10:59 <benzrf> building on a comment i made here earlier & one somebody replied with:
14:10:59 <benzrf> finn is eaten by a giant blue slime monster
14:11:00 <benzrf> a giant red one eats the giant blue one, then it diffuses and becomes 1 purple monster
14:11:03 <benzrf> finn slices his way out and yells
14:11:05 <benzrf> 'MONADIC'
14:11:13 <edwardk> they appear to have recorded last years, so i'll guess yes
14:23:58 <maxiepoo> so is that Mac Clang preproccesor issue solved with 7.8?
14:24:31 <maxiepoo> and if so does anyone know how to undo the changes that that clang wrapper script did
14:24:32 <maxiepoo> ?
14:26:41 <arrnas> can i put multiple functions in a function? like take a list, drop the first element then map it?
14:27:55 <gamegoblin> arrnas: why not? I could define “dropHeadThenMap xs f = map f (drop 1 xs)”
14:28:07 <gamegoblin> There are much cleaner ways to write it
14:28:34 <gamegoblin> dropHeadThenMap f = map f . tail
14:28:51 <dwcook> At the cost of partiality
14:29:51 <corgifex> :t fmap (flip fmap (drop 1)) fmap
14:29:52 <lambdabot> (a -> b) -> [a] -> [b]
14:30:23 <arrnas> gamegoblin: thanks, i just assigned the new list in a let .. in before the map any downsides to this?
14:30:42 <gamegoblin> arrnas: I doubt it. The compiler will probably produce the same code.
14:31:37 <arrnas> is there a function that merges two lists and removes duplicates? id need something like merge [1,2,3] [3,4,5] = [1,2,4,5]
14:32:01 <gamegoblin> No, but there is a function that merges two lists (++)
14:32:06 <gamegoblin> You can write one that removes duplicates
14:32:10 <gamegoblin> and then combine them
14:32:27 <gamegoblin> > [1,2,3] ++ [3,4,5]
14:32:29 <lambdabot>  [1,2,3,3,4,5]
14:32:38 <corgifex> well, the quick and dirty way is nub (xs ++ ys) but we can do much better if we know the lists are sorted
14:32:39 <dwcook> @type nub
14:32:40 <lambdabot> Eq a => [a] -> [a]
14:32:51 <dwcook> arrnas, a combination of nub and (++)
14:33:20 <corgifex> :t union
14:33:21 <lambdabot> Eq a => [a] -> [a] -> [a]
14:33:28 <gamegoblin> You can do it in O(nlgn) by converting to a set and back
14:33:40 <gamegoblin> But really nub is probably good enough for his purposes
14:34:04 <dwcook> Conversion to a set loses ordering information
14:34:15 <gamegoblin> Ah that’s true.
14:34:26 <dwcook> Oh, plus my suggestion of nub is wrong because I misread the example case
14:34:30 <albeit> Why does "Bin.encode . BS.length $ BS.pack "abcd"" return ""\NUL\NUL\NUL\NUL\NUL\NUL\NUL\EOT", where Bin = Data.Binary and BS = Data.ByteString.Lazy.Char8. Shouldn't it have 4 at the end instead of \EOT?
14:34:31 <quchen> The best way is probably writing your own nub function, but with a Set as the underlying cache.
14:34:49 <gamegoblin> Oh it deletes duplicates entirely
14:34:52 <monochrom> there is not an efficient function or combination of functions to merge two lists and remove duplicates. because by the time you do that, you have overdone the list meme.
14:35:24 <corgifex> let merge [] ys = ys; merge xs [] = xs; merge xs@(x : xs') ys@(y : ys') = case compare x y of LT -> x : merge xs' ys; GT -> y : merge xs ys'; EQ -> x : merge xs' ys'
14:35:28 <dwcook> arrnas, to clarify: you want a list whose elements are those elements of either of the starting lists that appear exactly once in exactly one or the other?
14:35:48 <corgifex> albeit: \EOT is 4
14:36:07 <gamegoblin> In that case you could do ` removeDup xs = map head (filter ((== 1) . length) (group xs))`
14:36:30 <albeit> corgifex: Ha, and so it is. I even looked at the table of the codes and it never clicked. Thanks
14:36:32 <arrnas> dwcook: yes, only the elements that are on one list or the other but not both
14:37:35 <ion> Please don’t do map head . filter ((== 1) . length)
14:38:01 <dwcook> group isn't right either because it only does adjacent
14:38:21 <gamegoblin> Oh I thought group got all elements that were Eq
14:38:36 <dwcook> The ones next to each other get grouped
14:38:41 <dwcook> > group "Mississippi"
14:38:42 <lambdabot>  ["M","i","ss","i","ss","i","pp","i"]
14:38:46 <gamegoblin> Aaah gotcha.
14:39:02 <StoneToad> just sort it first! :D
14:39:04 <dwcook> I can't think of a built-in function that removes *all* duplicates, rather than leaving one of each one
14:39:05 <corgifex> > chr 4
14:39:06 <lambdabot>  '\EOT'
14:39:23 <Yaniel> > chr 2622
14:39:24 <lambdabot>  '\2622'
14:39:25 <gamegoblin> I think this calls for a little 3 liner or something
14:39:26 <ion> FWIW, [ x | [x] <- something ] is more efficient than (map head . filter ((== 1) . length)) something
14:39:46 <StoneToad> isn't this the difference operator on sets?
14:39:47 <kgadek> is there an option in cabal to always install sources of packages? like "documentation: True" ?
14:39:52 <corgifex> concatMap (\xs -> case xs of [x] -> [x]; _ -> [])
14:41:10 * hackagebot Dung 1.0 - An implementation of the Dung argumentation frameworks.  http://hackage.haskell.org/package/Dung-1.0 (BasVanGijzel)
14:41:18 <arrnas> actually my list would have [[10..20],[15..25],[5..30]] etc.. would it be faster to make this a flat list then group elements and check the length of groups like 333 = 3 and 22 = nothing ?
14:41:36 <napping> faster?
14:42:16 <napping> If you care much about speed, are you sure a list is the right data structure?
14:42:22 <corgifex> > let merge [] ys = ys; merge xs [] = xs; merge xs@(x : xs') ys@(y : ys') = case compare x y of LT -> x : merge xs' ys; GT -> y : merge xs ys'; EQ -> x : merge xs' ys' in foldr merge [] [[10..20],[15..25],[5..30]]
14:42:24 <lambdabot>  [5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30]
14:43:19 <napping> It's a good idea anyway to avoid algorithmic badness like using "length" which walks the entire list just to check whether a list stops after the first item
14:43:46 <gamegoblin> arrnas: This will return a list without any duplicates, but it’s O(N^2) (as I think most solutions will be)
14:43:47 <gamegoblin> removeDup [] = []
14:43:48 <gamegoblin> removeDup (x:xs)
14:43:49 <gamegoblin>     | x `elem` xs = removeDup (filter (/= x) xs)
14:43:50 <gamegoblin>     | otherwise = x : removeDup xs
14:44:12 <osa1> annoying: http://lpaste.net/103481
14:44:25 <napping> Are you assuming the lists are sorted?
14:44:34 <napping> and sure you wouldn't rather just use Set?
14:44:38 <corgifex> gamegoblin: that's nub
14:44:50 <dwcook> It occurs to me that the compiler can't even be smart with things like (== 1) . length and just check the tail of the first cons because those two have different properties under laziness
14:45:10 <gamegoblin> corgifex: No it isn’t.
14:45:19 <napping> dwcook: Yeah. I saw a packaged somewhere that defined lazy peano numbers for things like that
14:45:20 <corgifex> gamegoblin: oh, I see
14:45:25 <gamegoblin> corgifex: It deletes all duplicates, rather than reducing them to just 1 copy of each
14:45:54 <napping> wait, the problem is to remove things that are duplicated, rather than just collapsing them to one copy?
14:46:06 <corgifex> napping: we don't know
14:46:09 <napping> That's sounding kind of weird
14:46:16 <gamegoblin> napping: his example was [1,2,3] ++ [3,4,5] goes to [1,2,4,5]
14:47:09 <napping> Is the point to come up with any not-gratuitously-inefficient solution, is it actually a bottleneck, or is it a more general question about how GHC optimizes stuff and what tends to be efficient?
14:48:00 <Ainieco> can't wait for OverloadedRecordFields, is it in master already?
14:48:33 <napping> I haven't gotten around to trying them yet, but PatternSynonyms sound pretty awesome already
14:48:47 <gamegoblin> Ainieco: Agreed
14:51:04 <arrnas> napping: i just need to remake my assignment in haskell, the problem is supposedly turning characters to italic, input is ranges like 10..20 and 15..30 and the output is supposed to be the number of chars that are still italic.. so far i'm reading the input to a list, creating a list of list, now i just need to merge all of the lists.
14:51:08 <Ainieco> https://ghc.haskell.org/trac/ghc/wiki/Records/OverloadedRecordFields says that plan was to merge it shortly after 7.8 release which was released more than a week ago
14:51:45 <tamiko> Well. Shortly after might as well be two weeks :->
14:51:56 <corgifex> that sounds more like pairwise canceling
14:52:06 <bitemyapp> so, what's the feeling on a withEnv function for System.Environment?
14:52:15 <bitemyapp> there's a withArgs but not a withEnv.
14:52:44 <napping> arrnas: How are numbers "italic"?
14:53:13 <monochrom> what is "italic" for this?
14:53:50 <arrnas> napping: they're not, the input is the amount of characters, then ranges that are "highlighted" and the italics button is hit...
14:54:14 <napping> Oh, that's a rather different question
14:54:19 <napping> Maybe Set and symmetric difference?
14:54:35 <napping> There's fancier stuff with things like interval trees that you probably don't care much about
14:55:42 <arrnas> yeah, i could've compared the input without creating these lists as in check if 15..20 fits inside 10..30 and create 10..15 and 20..30 out of that but i chose the easier way
14:56:39 <albeit> For a production program, is the recommended way to handle errors with (Monad m) => and fail?
14:57:01 <monochrom> no
14:57:14 <corgifex> > let merge [] ys = ys; merge xs [] = xs; merge xs@(x : xs') ys@(y : ys') = case compare x y of LT -> x : merge xs' ys; GT -> y : merge xs ys'; EQ -> merge xs' ys' in foldr merge [] [[10..20],[15..25],[5..30]]
14:57:15 <lambdabot>  [5,6,7,8,9,15,16,17,18,19,20,26,27,28,29,30]
14:57:37 <albeit> monochrome: What's better?
14:57:43 <albeit> *monochrom
14:57:50 <Algebr> Anyone happen to know if #gtk2hs is logged/
14:58:22 <monochrom> it depends on the actual kinds of errors.
14:58:50 <albeit> Non-fatal errors, that need to be checked by the parent of the function called.
14:59:36 <albeit> But errors, not just odd values. Something that causes the function to fail / short-circuit.
14:59:46 <monochrom> then the child function should use a Maybe type to begin with
15:00:22 <arrnas> corgifex: thanks for that, but i'm a bit confused on the xs@(x : xs') part, what does @ do?
15:00:29 <albeit> But doesn't using a Monad on the return value, and fail, allow it be use Maybe (and Either or other monads)?
15:00:38 <Rarrikins> arrnas: list@(head:tail)
15:00:48 <napping> Well, fail varies between instances, either returning a message sensibly in the monad as for Either e, or just throwing it like "error"
15:00:48 <monochrom> fail is not for this
15:01:00 <Rarrikins> arrnas: You have the whole thing given a name before @ and the decomposed thing after the @.
15:01:08 <arrnas> Rarrikins: thanks
15:01:21 <Rarrikins> arrnas: No problem.
15:02:18 <albeit> monochrom: Why Maybe over Either?
15:02:43 <napping> albeit: if you do want to return niceish errors, you should probably use something a bit more specific
15:03:14 <napping> either IO's exception handling system (or maybe something similar in a pure monad), so you can actually throw different types of informative exceptions rather than just UserError for everything
15:03:29 <napping> or maybe some more specialized error handling thing
15:04:20 <monochrom> if you want Either, use Either. I am just doubtful how much information you really have in the Left case.
15:04:23 <napping> I guess it's not clear if you mean "fail" as in failover and try something else (where MonadPlus or other monoid-type things are good), or more like report a nice error to the user
15:05:49 <albeit> More like failover and try something else. Reporting a message to the user/logs would be helpful, but the primary importance is being able to adapt once the error is detected.
15:06:24 <napping> So I guess it's rare enough for the first thing to fail that you might want to log it?
15:07:08 * quchen thinks a code example, some types, or a concrete problem description would be useful here.
15:07:12 <albeit> Yes, these should be very rare, but possible. They arise from parsing external data that is provided to the program in a specific format, but rarely something can go wrong with the format
15:07:29 <napping> and how do you recover?
15:07:42 <monochrom> the question is too broad.
15:08:09 <monochrom> may as well "how do I write a good program?"
15:08:35 <albeit> Hmm, concrete description, for one example error. Program reads in a message with a specified length. If the message is smaller that the required length, it needs to throw out the message.
15:08:58 <monochrom> that's a simple if-then-else
15:09:04 <albeit> The length is encoded at the beginning of the message
15:09:32 <monochrom> and you believe the message's own claim of its length?
15:09:45 <jfischoff> is there a package that exposes quickcheck instances for Aeson's types?
15:09:47 <monochrom> I just heard of a serious bug based on that two weeks ago or something
15:09:49 <quchen> monochrom: ;-)
15:10:25 <napping> monochrom: if it's possible for the message to be "smaller than the required length", the messages are probably coming from some kind of external thing that set the length
15:11:02 <albeit> Yes, but the message may be corrupted. If the length is encoded in the first eight bytes, there may even be eight bytes, or it may be smaller than the length it specifies.
15:11:10 <albeit> *may not even be eight bytes
15:11:26 <napping> how do you know where it ends? Are you getting it from a packet or something?
15:11:30 <monochrom> it's still a simple if-then-else
15:11:39 <albeit> Yes, a packet.
15:12:01 <napping> well, it sounds like you're already pretty close to IO if you want to log something on bad packets
15:12:15 <napping> and there's nothing the caller needs to know that a Maybe wouldn't tell them
15:12:17 <albeit> I was going to write a function that decodes the message into the provided size, and the rest of the message. If the message is not even eight byes, that will fail.
15:12:46 <napping> um, if there are multiple things in a packet and the lengths can get corrupted, that sounds kind of bad
15:13:26 <napping> And also sounds like the kind of parse failure your parsing library might handle better for you
15:14:12 <napping> Parse all items with one big Attoparsec parser or whatever
15:15:07 <albeit> I got a lot of reading to do about all this I think. Thanks
15:17:13 <napping> Ooh, does 7.8(.2) implement associated pattern synonyms?
15:17:15 <Ainieco> how can i read names from yaml file containing "names: [foo,bar]" into haskell [String]?
15:17:36 <Ainieco> looking at https://hackage.haskell.org/package/yaml-0.8.8.2/docs/Data-Yaml.html but it provides examples only for records
15:18:05 <jle`> Ainieco: what should the list contain?
15:18:07 <jle`> foo and bar?
15:18:49 <Ainieco> jle`: yup
15:18:51 <Ainieco> ["
15:18:58 <Ainieco> ["foo", "bar"]
15:19:00 <jle`> what have you tried?
15:19:22 <Ainieco> jle`: nothing yet, just trying to find examples of how can i do it
15:19:34 <jle`> ah
15:19:41 <jle`> well have to tried parsing the top level object yet?
15:19:45 <napping> Ainieco: that parses as an object with a names field
15:20:41 <Ainieco> oh, so i need to create data Names = Name { names :: [String] }?
15:21:06 <Ainieco> was thinking that creating record when you need just an array from one field from yml is a bit of overkill
15:21:11 <jle`> hm
15:21:14 * hackagebot CarneadesDSL 1.3 - An implementation and DSL for the Carneades argumentation model.  http://hackage.haskell.org/package/CarneadesDSL-1.3 (BasVanGijzel)
15:21:17 <jle`> you can create data but you can also just parse it manually
15:21:55 <Ainieco> yeah, i think creating record is an easiest way
15:23:01 <jle`> parseMaybe "names: [foo,bar]" :: Maybe (HashMap String (Vector String))
15:23:10 <jle`> that should give it to you i think
15:23:36 <jle`> and you can use the various methods from Data.HashMap and Data.Vector to get what you want
15:23:53 <Ainieco> ah, okay, thank you! Also what is the best way to access my yml file from cabal project, for example my yml is stored in the root of project and code that needs is stored in cabal_root/MyLib/Stuff.hs
15:25:51 <Ainieco> is it okay to use "../../stuff.yml"?
15:26:08 <jle`> hm. well.  i actually don't know.  you can load it as a fixed filepath if you know your user is going to be running it from the project root, or if it's a standalone executable you can let them specify
15:26:14 <jle`> no, it's relative to wherever you run the binary from
15:26:24 <jle`> your pwd
15:27:57 <Ainieco> got it
15:28:46 <jle`> if it's a config file for some sort of standalone executable the convention is to put it in ~/.your-project/config.yml or something and let the user customize
15:28:49 <jle`> i think
15:28:57 <jle`> depending on your OS
15:29:20 <jle`> but when you open a file in haskell, the filepath is relative to the directory you are currently in when you run the exe
15:29:22 <jle`> yeah
15:31:52 <Ainieco> yep, i understand now, thank you
15:32:14 <Rc43> Am I right that now it is possible to use standard cabal for sandboxes instead of cabal-dev?
15:32:44 <napping> Ainieco: it's a lot nicer if you use the decoding stuff
15:32:58 <napping> decode "names: [foo,bar]" >>= parseMonad getNames gives Just ["foo","bar"]
15:33:43 <napping> if you define getNames :: Value -> Parser String by getNames (Object o) = o .: "names"; getNames _ = mzero
15:33:48 <imalsogreg> Rc43: Yep. Since 1.18
15:35:45 <Rc43> imalsogreg, when was it released aproximately? August 2013?
15:36:35 <monochrom> hackage says Sep 2013
15:37:20 <imalsogreg> Rc43, monochrom: yep. And the 1.18 blog post was late august
15:39:10 <johann> hello room--haskell neophyte here!  i am having an issue with cabal trying to install text-1.1.1.1. the error i am getting is "fatal error: too many errors emitted, stopping now [-ferror-limit=] 29 warnings and 20 errors generated"
15:39:31 <johann> i created a gist of the error log here https://gist.github.com/jobez/914afbba0ef2b11bb41d advice would be much appreciated
15:42:28 <imalsogreg> johann: Yikes! :P   Are you on a mac?
15:42:35 <jfischoff> johann: looks like a clang CPP issue. Are you on OSX mavericks with ghc 7.6.*?
15:44:03 <johann> jfischoff: hello! yes that's my set up
15:44:52 <johann> imalsogreg: yes--mavericks. i found this old stack-overflow. still applicable? http://stackoverflow.com/questions/11700472/building-the-text-library-fails-on-os-x-mountain-lion
15:45:30 <jfischoff> johann: you have two options. Upgrade to 7.8.2, try a workaround like this one: http://www.haskell.org/pipermail/haskell-cafe/2013-October/111174.html
15:46:20 <jfischoff> johann: yeah that might also work.
15:47:55 <johann> jfischoff: is that the same shell script that's advised on the install page? i believe i ran it. must have not read the instructions careful enough. http://www.haskell.org/platform/ghc-clang-wrapper
15:49:04 <jfischoff> johann: same author as what I sent you, so probably the same
15:49:42 <johann> jfischoff: interesting! appreciate your help.
15:49:46 <jfischoff> yeah sometimes these workarounds work, and sometimes they don't. I don't know why. I think ghc 7.8.2 is the way forward
15:50:20 <johann> jfischoff: ya looking into updating the ghc right now. i would do that through cabal?
15:51:52 <jfischoff> johann: no, you would download the tarball and cd into it and run ./configure --prefix=/where/you/want/to/install && make install.
15:52:03 <jfischoff> err extract it and cd into it
15:52:08 <pyon> Is there any way to make a type class method that does not include any of the class' type parameters in its type signature?
15:52:30 <imalsogreg> johann: As jfischoff said. You can grab that tarball here I believe. https://www.haskell.org/ghc/download_ghc_7_8_2#binaries
15:52:54 <johann> should i uninstall my current version?
15:52:55 <jfischoff> pyon: you can use a proxy or undefined, but no.
15:52:57 <arrnas> Ambiguous occurrence `take' It could refer to either `Prelude.take', or `Data.Attoparsec.Char8.take'... any way to go around this?
15:53:46 <jfischoff> johann: you can have both, but seeing as you are new, I would
15:53:53 <imalsogreg> arrdem: import Prelude hiding (take)   or  s/take/Data.AttoParsec.Char8.take
15:54:21 <jfischoff> johann: otherwise you might use the ghc of one version but ghc-pkg or something to confuse yourself
15:54:29 <pyon> jfischoff: Proxy?
15:54:36 <imalsogreg> arrnas: (assuming you want the take from Attoparsec)
15:54:51 <arrnas> imalsogreg: other way round
15:55:04 <johann> jfischoff: yes simplicity is the beginners friend! one last question, do you have a suggested directory i install the ghc? is there a default?
15:55:14 <arrnas> imalsogreg: i need it from prelude but i'm also using attoParsec.Char8
15:55:23 <imalsogreg> arrnas: Oh, yep, then in your imports,  import Data.Attoparsec.Char8 hiding (take)
15:56:11 <jfischoff> johann: I think the default is /usr/local/bin maybe? I don't know. I have a directory with a few different versions, and I think a change a symlink to choose the one I want to use
15:56:42 <arrnas> imalsogreg: that helped, thanks
15:56:48 <jfischoff> its actually not a big deal to have a few ghcs going but probably best to start out with one
15:57:15 <jfischoff> the important thing is that the bin directory in the installed location is on the PATH
15:57:27 <imalsogreg> arrnas: no prob
15:58:37 <jfischoff> pyon: http://stackoverflow.com/questions/22116363/what-is-the-purpose-of-data-proxy
15:59:04 <johann> ya i have experienced some conundrums with PATH. so i basically need my hand held in making sure that its set up right if you don't mind
15:59:39 <imalsogreg> jfischoff, johann: I played with 7.8.2 a little bit and had almost no problems. One issue I ran into though was gloss. Can i ask what you're doing with Haskell? 7.8.2 is hot off the press, maybe we can tell you if any libraries you plan to use aren't quite ready yet.
16:00:39 <jfischoff> imalsogreg: good point, I suppose there are installation issues with both approaches, my thinking is that the ghc 7.8.2 will be addressed better going forward
16:01:09 <johann> imalsogreg: my main ambition right now is to learn the ropes. the reason why the text library came up is because im trying to use the live-eval feature for haskell in light table
16:01:20 <imalsogreg> jfischoff, johann: Oh, absolutely! Just trying to anticipate any problems, to avoid disappointment.
16:03:57 <jfischoff> I really do not understand the restrictive base deps that cabal init adds by default
16:04:54 <imalsogreg> johann: Oh good. For learning the ropes, you shouldn't have 7.8 problems.  For light table, I have no good guess, but let me know if it works.
16:06:43 <imalsogreg> jfischoff: I always thought of base as just-another-library. I heard the argument that since different versions of base can't work across different ghc's, there's no need to put restrictive bounds on it. But I actually don't understand that argument.
16:07:53 <Algebr> I'm thinking that my naive understanding of a functor as something that can be mapped over is lacking...because I'm having trouble understanding why IO is a Functor
16:08:02 <imalsogreg> jfischoff: The only experience I've had about this is with repa and gloss under 7.8.2 (base 4.7), where some the type of some function on primops changed between 4.6 and 4.7 - and cabal tried to compile, giving a type error.
16:08:19 <napping> Algebr: fmap f ioThingy = do x <- ioThingy; return (f x)
16:08:36 <Rc43> Am I right that the most important part of lens library is generation of lenses by data type definition?
16:08:38 <imalsogreg> jfischoff: (not caught by cabal, because the deps were base >= 4 && < 5)
16:08:38 <thinkpad20> anyone here familiar with Parsec? I've been stumped on something for a while. How can I guarantee that a piece of code runs, even if there's an exception that gets thrown?
16:08:46 <vanila> Algebr, well it's just that it's a monad, so it's a functor too - but IO isn't like a usual functor and wouldn't normally think of it as one
16:09:17 <quchen> IO is a perfectly normal Functor.
16:09:36 <Algebr> but is it then okay to keep thinking that an Functor is something that can be mapped over?
16:10:22 <napping> Algebr: that's probably the best way to think of it, you just have to accept that liftM is counts as mapping over IO
16:11:56 <quchen> "IO a" is a recipe to produce something of type "a". fmap allows the result of that recipe to be modified by a function.
16:12:48 <quchen> getLine is a recipe to produce a String, namely the contents of a line. "fmap length getLine" is a recipe to get the length of an entered line.
16:12:50 <johann> imalsogreg: so i have ghc installed. how do i add it to my path?
16:13:20 <Algebr> quchen: ahhhh, that's awesome, now I see why everyone loves fmap.
16:13:38 <benzrf> Algebr: you can think of IO as being a functor in the same way as a function
16:13:44 <zomg> Everyone loves fmap, starring Ray Romano
16:13:46 <Algebr> Are all the symbol functions always infix?
16:13:55 <Algebr> like <$>
16:13:55 <thinkpad20> yes
16:13:57 <benzrf> yes thats how the grammar works
16:14:18 <imalsogreg> johann: I can try. But every time I help a mac user set his path, their X11 apps stop working!
16:14:21 <napping> you can write them like (<$>) to apply them prefix, if you want.
16:14:40 <zomg> I was applying !! with <$> and <*> to stuff and it just somehow felt wrong
16:14:43 <johann> :o
16:14:47 <napping> and also alphanumeric functions infix with `, like 'x' `elem` "abc"
16:14:48 <zomg> but I dunno :P
16:15:01 <benzrf> napping: thats False
16:15:23 <imalsogreg> johann: Did you do the --prefix= thing during configure that jfischoff mentioned?
16:15:35 <zomg> I was converting some of my code to use a reader monad instead of passing around a big blob of data and then extracing random values out of it
16:15:40 <quchen> benzrf: "Functor in the same way as a function"?
16:15:42 <thinkpad20> benzrf how is that false
16:15:55 <quchen> > 'x' `elem` "abc"
16:15:56 <lambdabot>  False
16:15:58 <quchen> False.
16:15:58 <zomg> but it frankly seems like it's just making the code more complicated as a result, as you now have to hop around with all that monad nonsense when using the functions
16:16:00 <thinkpad20> hahahaha
16:16:04 <johann> imalsogreg: yeah its at /usr/local/bin/lib/ghc-7.8.2
16:16:07 <thinkpad20> oh I get it
16:17:09 <benzrf> quchen: the IO functor behaves in a similar manner to the ((->) r) functor
16:17:17 <benzrf> i.e. youre mapping over a 'deferred result'
16:17:46 <quchen> zomg: Using Reader alone is indeed often a bit useless, you have to lift everything manually instead of manually passing the environment around. As part of a transformer stack it becomes more useful though.
16:17:53 <thinkpad20> anyone have any thoughts on my question?
16:18:15 <zomg> quchen: yeah, I was experimenting whether it would make any sense to hide a state into a reader from a readert statet stack I had
16:18:16 <thinkpad20> I'm writing a parser and it's failing for reasons I don't know. I'm putting in logging but the program terminates before my error messages get written
16:18:32 <zomg> quchen: so as to make a certain set of functions not be able to modify the state and stuff like that
16:18:43 <zomg> but it just seems it might be complicating things for no reason =)
16:19:07 <Maior> so I have an IO a, an IO b, and a c, plus an a->b->c->IO d; how do I combine these nicely to get an IO d out?
16:19:31 <benzrf> Maior: applicatives?
16:20:31 <pavonia> Maior: You have an "a c" or an "IO c"?
16:20:53 <Maior> pavonia: and a `c`, sorry for ambiguity
16:20:55 <liftM> I think he just meant a "c"
16:21:00 <ReinH> f <$> a <*> b <*> pure c ?
16:21:05 <benzrf> ReinH++
16:21:07 <liftM> that should work
16:21:20 <imalsogreg> johann: Oh ok.  I googled and saw that you can set paths in the file /etc/paths   .. Try adding all that stuff before ghc-7.8.2 to that list?
16:21:30 <pavonia> Yes, that or liftA3
16:21:48 <quchen> Applicative is not enough to do this.
16:21:51 <Maior> :t (<*>)
16:21:52 <lambdabot> Applicative f => f (a -> b) -> f a -> f b
16:22:02 <Maior> ok, thanks very much
16:22:03 <imalsogreg> johann: But don't mess that file up too badly, or my successful OSX path setting record will fall from 0/3 to 0/4
16:22:08 <quchen> :t let u = undefined in  (u :: a -> b -> c -> IO d) <$> (u :: IO a) <*> (u :: IO b) <*> pure (u :: c)
16:22:09 <lambdabot> IO (IO d)
16:22:20 <benzrf> :t let f = undefined :: IO Int -> IO String -> IO Char -> IO Ordering; ioA = undefined :: IO Int; ioB = undefined :: IO String in <$> ioA <*> ioB
16:22:21 <lambdabot> parse error on input ‘<$>’
16:22:23 <benzrf> hmm
16:22:25 <Maior> so I've been avoiding the infix fmap because it doesn't quite come naturally
16:22:31 <Maior> (to me)
16:22:36 <benzrf> :t let f = undefined :: IO Int -> IO String -> IO Char -> IO Ordering; ioA = undefined :: IO Int; ioB = (undefined :: IO String) in <$> ioA <*> ioB
16:22:37 <lambdabot> parse error on input ‘<$>’
16:22:39 <quchen> It combines well with <*>.
16:22:40 <benzrf> u wut
16:22:41 <benzrf> oh
16:22:44 <benzrf> :t let f = undefined :: IO Int -> IO String -> IO Char -> IO Ordering; ioA = undefined :: IO Int; ioB = undefined :: IO String in f <$> ioA <*> ioB
16:22:45 <lambdabot>     Couldn't match type ‘Int’ with ‘IO Int’
16:22:45 <lambdabot>     Expected type: IO (IO Int)
16:22:45 <lambdabot>       Actual type: IO Int
16:22:46 <Maior> quchen: I can see that
16:22:48 <benzrf> o-o
16:23:19 <thinkpad20> wait what's the type you're trying to accomplish?
16:23:37 <thinkpad20> I was under the impression you wanted: foo :: IO a -> IO b -> c -> (a -> b -> c -> IO d) -> IO d
16:23:40 <benzrf> :t let f = undefined :: Int -> String -> Char -> IO Ordering; ioA = undefined :: IO Int; ioB = undefined :: IO String in f <$> ioA <*> ioB
16:23:41 <lambdabot> IO (Char -> IO Ordering)
16:23:44 <benzrf> hmmmm
16:23:48 <benzrf> yup
16:23:52 <benzrf> just as expected
16:23:55 <benzrf> :O
16:23:58 <thinkpad20> foo a b c f = f <$> a <*> b <*> pure c
16:24:01 <Maior> thinkpad20: I believe I do, yes
16:24:10 <pavonia> Right, you need a join at the end
16:24:15 <thinkpad20> that should do it then
16:24:22 <Maior> excellent, thanks
16:24:37 <johann> imalsogreg: a little confused by what you mean with 'adding all that stuff'
16:25:16 <pavonia> :t \a b c f -> f <$> a <*> b <*> pure c
16:25:17 <lambdabot> Applicative f => f a2 -> f a1 -> a -> (a2 -> a1 -> a -> b) -> f b
16:25:31 <imalsogreg> johann: Oh sorry. I meant "/usr/local/bin/lib"
16:25:35 <FreeFull> @pl \a b c f -> f <$> a <*> b <*> pure c
16:25:35 <lambdabot> ((flip (<$>) .) .) . flip flip pure . (((.) . (<*>)) .) . (<*>)
16:25:43 <Maior> yeef
16:25:49 <pavonia> :t \a b c f -> join $ f <$> a <*> b <*> pure c
16:25:50 <lambdabot> (Applicative m, Monad m) => m a3 -> m a2 -> a1 -> (a3 -> a2 -> a1 -> m a) -> m a
16:25:55 <FreeFull> @pl \f a b c -> f <$> a <*> b <*> pure c
16:25:55 <lambdabot> (. flip (flip . (((.) . (<*>)) .) . (<*>)) pure) . (.) . (.) . (<$>)
16:26:27 <thinkpad20> lol is that the point free version? yikes
16:26:42 <Maior> btw, this doesn't seem like a hugely uncommon scenario; my IO values are command line arguments, the non-IO ones are test constants
16:26:57 <Maior> I guess this probably means I can simplify the whole thing more
16:27:09 <johann> imalsogreg: added it and tried ghc and it didnt work. do i need to restart? appreciate your help :)
16:27:44 <thinkpad20> once you get used to applicatives they can simplify a lot
16:27:50 <imalsogreg> johann: No problem :) Em, I think that environment variables get set locally in each terminal window you open. So try closing & reopening the terminal.
16:28:56 <Egbert9e9> how come haskell ffi makes more sense than python's ctypes
16:29:29 <johann> imalsogreg: so i got it to work but it was necessary to put in the directory all the way up to the bin directory within the ghc directory
16:29:40 <Egbert9e9> i'm reading the wikibook https://en.wikibooks.org/wiki/Haskell/FFI and it all makes perfect sense
16:30:30 <imalsogreg> johann: Cool. So you have ghci available too?
16:30:52 <johann> imalsogreg: uhoh nope i do not
16:32:13 <imalsogreg> johann: Rut roh. Ok see if that binary is in the same directory w/ ghc-7.8.2, or nearby.
16:37:58 <johann> imalsogreg: don't see a ghci in the bin folder. also cabal is not working from the command line either
16:38:36 <imalsogreg> johann: Can you the steps you did to install up in a gist I could look at?
16:42:04 <johann> imalsogreg: wait wait sorry i tracked it down. ghci and cabal are now working haha
16:43:43 <Algebr> Does <*> have a name like <$> has fmap?
16:43:54 <imalsogreg> johann: Great! If light table doesn't work out, and you like emacs or vim, give ghc-mod a try. That really makes haskelling fun.
16:44:32 <apples> Algebr: well, there's ap, but that has a different constraint (for Monad rather than Applicative)
16:45:03 <benzrf> @src <$>
16:45:04 <lambdabot> f <$> a = fmap f a
16:45:10 <benzrf> not (<$>) = fmap?
16:45:33 <johann> imalsogreg: will do! thanks a lot :)
16:50:53 <augur> Algebr: sure, its name is (<*>)
16:50:54 <augur> :P
16:59:07 <Maior> @hoogle (a -> m b) -> m a -> m b
16:59:08 <lambdabot> Prelude (=<<) :: Monad m => (a -> m b) -> m a -> m b
16:59:08 <lambdabot> Control.Monad (=<<) :: Monad m => (a -> m b) -> m a -> m b
16:59:08 <lambdabot> Prelude (>>=) :: Monad m => m a -> (a -> m b) -> m b
17:11:11 <btcNeverSleeps> I did a quick test of Criterion and it's working fine (sweet), both when I use ghc (from a terminal) and when I use ghci (from Emacs). However under Emacs there's something weird: the import line is underlined in red: "Could not find module Criterion.main. Use -v to see a list of the files searched for." (in a popup)
17:11:44 <btcNeverSleeps> oops
17:12:05 <btcNeverSleeps> I saved the file and did C-c C-l again and how there's no error showing up anymore :-/
17:15:32 <Maior> @hoogle Double -> Int
17:15:33 <lambdabot> Foreign.Storable alignment :: Storable a => a -> Int
17:15:33 <lambdabot> Foreign.Storable sizeOf :: Storable a => a -> Int
17:15:33 <lambdabot> Data.Generics.Schemes gsize :: Data a => a -> Int
17:15:36 <Maior> :t floor
17:15:37 <lambdabot> (RealFrac a, Integral b) => a -> b
17:21:15 <napping> btcNeverSleeps: sounds like something in your emacs setup is looking at the file on disc to generate errors
17:21:51 <napping> I've got a reasonably nice ghc-mod setup, but I know the flymake part sometimes mentions dummy filenames, and other times hangs
17:26:43 <stolaruk> If I have a function that returns [[Int]], I noticed that I can, in the function body, return "[]". Is it considered better to return "[[]]" instead?
17:27:40 <pavonia> stolaruk: They are different
17:27:42 <Maior> stolaruk: those are different things
17:27:42 <imalsogreg> stolaruk: Hm.  length [[]] == 1, length [] == 0; does that matter?
17:27:43 <jle`> stolaruk: it's up to what you want?
17:27:58 <stolaruk> oh wow
17:27:59 <jle`> what are the semantics of your function?
17:28:16 <stolaruk> jle`: I'm not sure what you are asking
17:28:35 <jle`> one is [] and the other is []:[], fwiw
17:28:42 <stolaruk> yes I see
17:28:45 <stolaruk> ok
17:29:00 <jle`> I'm asking what your function is supposed to "do", high level wise
17:29:01 <jle`> like what it means
17:29:36 <stolaruk> jle`: It is actually a word wrapping function. It takes a list of Text and wraps each line if necessary
17:30:49 <jle`> that should be your guide as to what you want, because both typecheck.
17:31:13 <jle`> you have reached this odd corner where your tu
17:31:25 <jle`> types don't write your program for you anymore
17:31:32 <jle`> sorry, typing with one hand
17:31:45 <stolaruk> yes I understand now the difference between [[]] and []
17:33:45 <SwashBuckla> Hi there. I was reading in p75 of LYAH that right folds support infinite sequences, but not left folds. Why is this?
17:34:56 <jle`> SwashBuckla: I recommend you try manually applying the functions yourself to discover why
17:35:04 <jle`> @src foldl
17:35:04 <lambdabot> foldl f z []     = z
17:35:04 <lambdabot> foldl f z (x:xs) = foldl f (f z x) xs
17:35:08 <jle`> @src foldr
17:35:08 <lambdabot> foldr f z []     = z
17:35:08 <lambdabot> foldr f z (x:xs) = f x (foldr f z xs)
17:35:29 <jle`> @src (&&)
17:35:29 <lambdabot> True  && x = x
17:35:29 <lambdabot> False && _ = False
17:36:17 <jle`> try applying foldr (&&) True on a list of infinite Falses
17:36:28 <jle`> and the foldl (&&) True on the same
17:36:57 <jle`> and seeing which one expands to a terminating value :)
17:37:44 <jle`> remember that in Haskell, evaluation is simply substitution for the most part :)
17:38:59 <jle`> oh by applying I mean getting a pen and paper and manually expanding the function calls
17:51:08 <btcNeverSleeps> napping: are you using ghc-mod and flymake at the same time?
17:58:13 <napping> btcNeverSleeps: yeah, I followed the instructions from here: http://tim.dysinger.net/posts/2014-02-18-haskell-with-emacs.html
17:58:50 <napping> works great until something gets broken and either emacs hangs or something (flymake?) starts doing nothing but asking whether I want to restart ghc
18:01:06 <orion> hm
18:01:24 <mmachenry> Hey orion.
18:01:29 <orion> hi
18:01:30 <orion> How can I make my parser explicitly fail when it reads 64 bytes and all of them are NOT equal to zero?
18:01:34 <mmachenry> How'd that maybe IO stuff work out for you?
18:01:39 <napping> btcNeverSleeps: it breaks rarely enough I haven't looked to hard into fixing it
18:01:39 <orion> mmachenry: Well. :)
18:01:51 <mmachenry> Cool.
18:01:53 <orion> I have moved on to attoparsec now.
18:01:55 <orion> It's rough.
18:02:01 <mmachenry> Did you do Maybe or ErrorT?
18:02:07 <mmachenry> Oh
18:02:16 <mmachenry> For what?
18:02:30 <orion> Parsing network packets.
18:02:32 <napping> orion: how about MonadPlus? guard sounds right
18:03:27 <orion> hmm
18:05:00 <orion> napping: thank you
18:12:50 <akurilin> Ok quick question: I have a bunch of persistent type definitions that I need to you across a variety of different applications. What's the recommended way of sharing that code? Sounds like making a local library is the way to go.
18:14:02 <bitemyapp> akurilin: yep, that's pretty much it right there.
18:14:14 <bitemyapp> akurilin: you can cabal add-source it.
18:15:00 <akurilin> when I do add-source, does the source become part of the build of the depending project?
18:15:10 <akurilin> or am I to build the library separately first in order to use it?
18:15:50 <benzrf> ok i am looking at https://dl.dropboxusercontent.com/u/4588997/Machines.pdf
18:15:59 <benzrf> and i do not understand the Step type at all
18:17:27 <akurilin> whoa cabal detected which dependencies I need for the cabal file based on what files where in folder
18:17:30 <akurilin> same for extensions
18:17:32 <akurilin> trippy
18:17:42 <bitemyapp> akurilin: when you did what?
18:17:45 <bitemyapp> akurilin: cabal init?
18:17:51 <akurilin> yeah
18:17:55 <bitemyapp> wow.
18:17:59 <akurilin> I mean, I did both cabal init and cabal sandbox init
18:18:00 <bitemyapp> I didn't know it did that.
18:18:06 <bitemyapp> all the same.
18:18:10 <akurilin> looks like it went through the pragmas and the imports
18:18:16 <bitemyapp> awesome :)
18:18:36 <bitemyapp> I wish it was easier to repeat/share blocks of dependencies in Cabal. I might be doing it wrong.
18:18:47 <bitemyapp> I think you can't do it arbitrarily, but you can make things depend on "library"
18:21:02 <Platz> I've been hoping the 2nd part for this comes out http://blog.jle.im/entry/intro-to-machines-arrows-part-1-stream-and
18:21:26 <Platz> any good intro tutorials on autos and machines?
18:26:30 <Platz> ah, found some stuff on wikibooks, and also something by leonidas
18:26:55 <Platz> more related to arrows
18:36:39 * hackagebot xmonad-contrib 0.11.3 - Third party extensions for xmonad  http://hackage.haskell.org/package/xmonad-contrib-0.11.3 (AdamVogt)
18:49:37 <augur> catalyst: i can elaborate further if you want
18:49:48 <augur> or give you some examples or whatever
18:51:25 <napping> I'm looking through the machines slides
18:52:08 <Ginto8>  /help
18:56:30 <jle`> Platz: my bad :|
18:57:05 <jle`> Platz: I've rewritten part 2 several times because I couldn't get it to come out as anything other than just instances typeclass after typeclass
18:57:20 <jle`> instancing
18:57:53 <jle`> but there is good material out there :)
19:02:15 <Platz> jle`: Appreciate what you've done so far!  Definitely piqued my interest; it helps that your writing style is pretty clear too
19:03:43 <Platz> I think that's the LYAH philosophy - just provide enough help to get a 'foot in the door', so they do the rest of the research themselves
19:06:05 <orion> hmm, what does it mean when your program compiles fine but you get a linker error?
19:06:35 <orion> In this case, I call a function "newPacket" located in another module.
19:06:41 <enthropy> it means you or somebody made a mistake
19:06:48 <orion> I exported it, and it compiles/passes the type checking.
19:07:16 <orion> But the moment I try to evaluate newPacket, I get the linker error.
19:07:55 <enthropy> are you using ghci?
19:08:09 <orion> no
19:08:15 <orion> cabal + ghc 7.6
19:11:02 <enthropy> orion: did you list the module in the cabal file?
19:11:08 <orion> yes
19:11:54 <orion> oh, hmm
19:12:00 <orion> It wasn't listed, and now it compiles.
19:12:17 <orion> The thing is though, it's an internal module I don't want the end-user to be able to use.
19:12:31 <enthropy> there's an other-modules: list too
19:12:34 <orion> ah!
19:13:01 <orion> That did it, thank you.
19:13:57 <enthropy> cabal should probably have some kind of warning for such errors
19:20:54 <jle`> Platz: thanks!
19:21:51 <jle`> that's all i hope for :)
21:36:01 --- topic: 'http://www.haskell.org/ | Paste code/errors: http://lpaste.net/new/haskell | Logs: http://tunes.org/~nef/logs/haskell/?C=M;O=D http://ircbrowse.net/day/haskell/today?mode=recent | Administrative issues: #haskell-ops | Hackage down? http://hdiff.luite.com | XCode 5 issues? http://is.gd/H4sEub | Need an op? Try: @where ops'
21:36:01 --- topic: set by johnw on [Mon Feb 17 18:32:10 2014]
21:36:01 <enthropy> orion: but where did you bind those variables?
21:37:00 * hackagebot hspec 1.9.5 - Behavior-Driven Development for Haskell  http://hackage.haskell.org/package/hspec-1.9.5 (SimonHengel)
21:37:12 <orion> enthropy: What do you mean by "where"?
21:37:29 <enthropy> you can do stuff like      BS.concat $([  [| pull $(dyn n) |]  | n <- words "ce se sn box" ])
21:37:50 <enthropy> you can do stuff like      BS.concat $(listE [  [| pull $(dyn n) |]  | n <- words "ce se sn box" ])
21:38:20 <enthropy> but at this point template-haskell is as ugly (and harder to understand) than the thing it is replacing
21:38:32 <napping> that's probably about as good as you want to get
21:39:15 * nisstyre goes and writes some syntax-rules macros in Scheme
21:39:25 * nisstyre laughs at TH
21:39:25 <enthropy> (and you can run into the issue that all expression splices are typechecked together, if any of those variables is polymorphic)
21:40:27 <enthropy> I mean if any of the variables is polymorphic, then you can have odd type errors because of that limitation
21:40:31 <napping> You might be able to do some tricky HList type of thing if you really want
21:41:21 <napping> like strageMap pull (Hcons v1 (Hcons v2 (Hcons v3 HNil)))
21:41:25 <ajcoppa> has anyone here gone through the NICTA course, particularly the State implementation?
21:41:55 <enthropy> napping: no it's not that bad
21:42:00 * hackagebot hspec-meta 1.9.5 - A version of Hspec which is used to test Hspec itself  http://hackage.haskell.org/package/hspec-meta-1.9.5 (SimonHengel)
21:43:13 <orion> interesting
21:44:03 <ajcoppa> i got stuck while implementing "distinct" and looked at the answer from tonymorris's repo, but even that seems to return incorrect results (though they do pass the quickcheck props in the docs)
21:44:16 <enthropy> >hMapOut (Fun show :: Fun '[Show] String) $ hBuild "napping" 1 2 () 'a'
21:44:18 <ajcoppa> i wanted to make sure it's not something else i messed up along the way
22:01:06 <agibiansky> Hello! I have a question about combining transformer stacks. I hate two transformer stacks: StackA (on top of IO base monad) and StackB (on top of IO base monad). I'd like to keep these two semi-abstract somehow. How do people usually do this? Is there a nicer way than changing one of the stacks into a transformer where all the functions have some sort of MonadIO constraint?
22:02:32 <jle`> so much hate for transformers
22:02:44 <jle`> why can't we all just get along
22:03:03 <dmj`> jle`: haters gonna hate
22:03:12 <jle`> preach it, brother
22:03:19 <agibiansky> jle`:  No particular hate for transformers, mostly just wondering if its possible without changing all functions that use my stacks to MonadIO => ... :)
22:03:41 <jle`> sorry, was calling out your typo :)
22:03:50 <jle`> excuse me for being a slight jerk :)
22:04:21 <dmj`> agibiansky: do you have code?
22:05:07 <agibiansky> dmj`: Not in any minimal working sense, sorry
22:05:11 <bitemyapp> dmj`: obviously it's in their head and their brain is the Haskell compiler.
22:05:59 <jle`> agibiansky: your question is a little vague
22:06:14 <jle`> but typically the idiomatic philosophy for working with monad transformers is to keep all of your functions as polymorphic as possible
22:06:14 <agibiansky> Hrm yes you're right
22:06:25 <agibiansky> Ah, okay, I see
22:06:25 <dmj`> bitemyapp: some days I wish I had a repl in my head, would be really convenient
22:06:35 <jle`> so use things like (MonadIO m, MonadTrans m) => ...
22:06:45 <jle`> instead of explicitly StackA IO, whenever you can
22:06:45 <bitemyapp> dmj`: that would be sweet.
22:07:09 <agibiansky> jle`: Ah, okay. Sounds good, think that'll make things work.
22:07:10 <jle`> dmj`: i probably would never pay attention in class, and i would be an awful driver
22:07:22 <dmj`> jle`, bitemyapp: put ghci on google glass
22:07:28 <jle`> agibiansky: it's also a good way to prevent bugs :)
22:07:58 <jle`> if your function only knows you have a MonadTrans and a MonadIO, you can't do anything with it other than lift and liftio's
22:08:12 <jle`> and you can't, say, unwrap things dangerously or weirdly
22:08:47 <gyeh> hey does anyone know a good place to start learning monads?
22:08:58 <gyeh> I'm looking for a simple example, but haskell.org links for examples are broken
22:09:05 <jle`> :|
22:09:20 <jle`> how much haskell do you know?
22:09:44 <gyeh> i dont know, i'm fairly new i guess... implemented church encodings and a few sorting algorithms
22:09:58 <jle`> try reading through an introductory text like Learn You a Haskell :)
22:10:03 <dmj`> gyeh: do you know typeclasses?
22:10:18 <gyeh> dmj`: yeah i've used them before
22:10:23 <jle`> monads are one of those things that are notoriously difficult to understand and use practically in a vacuum
22:10:34 <jle`> but unfortunately i have lost all ability to understand why
22:11:12 <gyeh> jle`: yea, i've been reading learn you a haskell for great good. Does it have a good monad explanation? I thought it skimmed through details from what i heard
22:11:45 <gyeh> jle`: do yo u need to know category theory to fully appreciate/understand it?
22:11:48 <jle`> "learn monads" is kind of a weird thing
22:11:51 <jle`> and no you don't
22:12:00 <jle`> well
22:12:09 <jle`> not in the way you are probably asking
22:12:26 <gyeh> jle`: not to know how it works in haskell and/or to make your own right?
22:12:52 <jle`> the main problem people have when "learning monads" is that they think monads are something to learn
22:13:06 <dmj`> gyeh: monads in haskell are implemented via typeclasses and given special do { } syntax. Every valid monad has to obey the monad laws, but the laws aren't enforced by the compiler. Every monad is also a functor and an applicative functor.
22:13:14 <jle`> they attempt to attach some sort of...semantics to it
22:14:29 <jle`> gyeh: do you know about functors?
22:14:38 <jle`> Functors
22:15:04 <gyeh> dmj`: ah yeah, you implement bind and return right?
22:15:16 <gyeh> jle`: yeah a little bit, still feel like i need more to fully grasp it
22:15:49 <gyeh> are there any particular resources you guys used that helped the most for monads? or did you just take a little bit from here and there
22:16:00 <jle`> what's that..."you could have invented monads"...Wadler?
22:16:08 <jle`> LYAH was neat enough for me
22:16:10 <dmj`> monads in haskell are a way to model computation, the identity monad is the simplest, models a box, Maybe models computations w/ failure, Either is forking a computatin, [] is non-deterministic computations, and so on
22:16:49 <stevejb> hello, what would stop a data type from being able to derive Generic?
22:16:50 <numberten> typeclassopedia was a good resource imo
22:17:06 <numberten> gyeh: for learning monads that is
22:17:14 <dmj`> gyeh: you can further stack them on top of each other to have more sophisticated computations, like a stateful computation that performs IO, called transformers
22:17:25 <napping> Is there any way to extract the context from a function?
22:17:30 <napping> funProxy :: (forall a . ctx a => a -> r) -> Proxy ctx$
22:17:37 <napping> doesn't seem to work
22:17:40 <jle`> gyeh: if you have a function (a -> b), and you want to apply it to a Maybe a
22:17:51 <jle`> you can turn any (a -> b) into a (Maybe a -> Maybe b)
22:18:09 <jle`> you can turn your function into a function that works "inside a Maybe"
22:18:16 <gyeh> numberten: thanks, i'll check it out
22:18:20 <jle`> this function is called fmap
22:18:28 <numberten> http://www.haskell.org/haskellwiki/Typeclassopedia
22:18:29 <jle`> fmap :: (a -> b) -> (Maybe a -> Maybe b)
22:18:35 <jle`> only, it generalizes to all Functor f
22:18:40 <jle`> fmap :: (a -> b) -> (f a -> f b)
22:18:50 <gyeh> dmj`: nice, that's a helpful explanation. Yeah I was thinking of looking at the Monad implementation of Maybe and Either
22:18:52 <jle`> so a Functor is something that you can "apply a function inside"
22:19:01 <jle`> you can turn a function (a -> b) into a function (f a -> f b)
22:19:08 <gyeh> dmj`: Monad's basically apply a transformation to a data type right?
22:19:31 <jle`> what does it mean to apply something "inside a functor"?
22:19:43 <jle`> well...it can mean whatever the functor wants
22:19:51 <jle`> the semantics are up to the actual instance
22:19:58 <jle`> (it has to follow some laws though)
22:20:03 <numberten> gyeh: as jle` mentioned Wadler's paper is a good resource as well: http://homepages.inf.ed.ac.uk/wadler/papers/marktoberdorf/baastad.pdf
22:20:09 <ddere> fmap id == id
22:20:24 <ddere> fmap (f.  g) = fmap f . fmap g
22:20:39 <jle`> for Maybe, meaningful semantics are...fmapping a function onto Nothing just gives you Nothing. fmapping a function onto a Just x applies the function to x, and re-wraps in Just
22:20:57 <jle`> but these semantics/meanings are completely up to the Functor instance
22:21:08 <jle`> a functor can decide "what does it mean to apply a function inside me?"
22:21:23 <jle`> so we now have a way to turn any (a -> b) into (f a -> f b)
22:21:32 <jle`> but what if we had an (a -> f b) ?
22:22:05 <jle`> using functor, we can't turn an (a -> f b) into an (f a -> f b)
22:22:11 <jle`> so this is what Monads give you
22:22:24 <jle`> the ability to turn an (a -> f b) into an (f a -> f b)
22:22:31 <gyeh> jle`: ah ok, now I'm starting to see how it's more than just a functor
22:22:51 <dmj`> gyeh: Monads in haskell are a typeclass, so the usage of (>>=) is contingent on the context it's operating in. If it's in a context of non-determinism (ala [] "List"), then (>>=) means flip concatMap.
22:23:05 <dmj`> @typ flip concatMap
22:23:06 <lambdabot> [a] -> (a -> [b]) -> [b]
22:23:09 <dmj`> @typ (>>=)
22:23:09 <lambdabot> Monad m => m a -> (a -> m b) -> m b
22:23:23 <gyeh> jle`: thanks this is really helpful
22:23:30 <jle`> it's all a "game of lifting"
22:23:31 <jle`> :)
22:23:34 <dmj`> see how flip concatMap is a more specific type?
22:23:35 <jle`> you have a "domain of values"
22:23:36 <gyeh> numberten: thanks these links are helpful too
22:23:44 <jle`> let's say my entire computation is inside a Maybe
22:23:50 <jle`> that's no problem for me!
22:23:56 <jle`> i have fmap, so i can use normal functions!
22:24:10 <jle`> i can have my entire computation inside a Maybe, and use normal functions like they are Maybe functions
22:24:14 <jle`> thanks to fmap
22:24:32 <jle`> and i can use (a -> Maybe b) functions too, and stay inside Maybe the entire time
22:24:40 <jle`> by turning them into (Maybe a -> Maybe b) functions
22:24:49 <gyeh> lambdabot: wow that's super useful..
22:25:05 <jle`> the whole game is "i want to live inside the same thing for as long as possible, how can i make all my functions work on my domain/thing?"
22:25:19 <dmj`> ^
22:25:21 <jle`> (this is a new attempt at explaining this that i haven't used before >_> it might be an awful idea)
22:25:46 <jle`> so yeah, the whole thing lets you turn "normall functions" into "f a -> f b"/"functions inside"
22:25:58 <jle`> but yeah read the wadler paper
22:26:03 <jle`> it should be the only monad tutorial you ever need
22:26:49 <gyeh> @typ flip concatMap
22:26:50 <lambdabot> [a] -> (a -> [b]) -> [b]
22:26:56 <gyeh> dmj`: haha nice bot :)
22:27:05 <gyeh> jle`: thanks this was super helpful
22:27:26 <numberten> lambdabot has a lot of cool functionality
22:27:35 <numberten> you should send it a privmsg some time and play around with it
22:29:05 <dmj`> jle` is always super helpful :P
22:29:58 <gyeh> haskell people seem to be the least reluctant to help out of the languages i've been learning it seems
22:30:01 <gyeh> even on SO
22:30:12 <napping> It's kind of annoying that HList Fun can't get the context by unification
22:30:53 <enthropy> I think it's not a solveable problem
22:31:31 <enthropy> it's pretty much the same level as type inference for RankN types I think
22:31:46 <napping> I don't see how it's anywhere near that bad
22:32:43 <enthropy> at least it's called Fun
22:33:05 <enthropy> maybe it should have been called Defun?
22:35:34 <t4nk492> @pl h f g x = f (g x) == x
22:35:34 <lambdabot> h = flip flip id . (liftM2 (==) .) . (.)
22:37:02 <stevejb>  I am trying to use ToJSON from aeson according to this tutorial: https://www.fpcomplete.com/school/starting-with-haskell/libraries-and-frameworks/text-manipulation/json
22:37:20 <stevejb> however, in adding Generic to my deriving, I get  Illegal deriving item ‘Generic’
22:37:47 <stevejb> is there a general rule about what is or is not derivable as type Generic. The data types do not seem especially complicated
22:40:24 <napping> orion: the HList stuff looks kinda decent, except having to pull in HList
22:56:33 <jle`> stevejb: do you have DerivingGeneric on?
22:56:40 <jle`> (sorry, just checking)
22:57:10 <stevejb> jle`: I figured it out. I had Data.Generics and GHC.Generics mixed up
23:02:10 * hackagebot Rlang-QQ 0.2.1.0 - quasiquoter for inline-R code  http://hackage.haskell.org/package/Rlang-QQ-0.2.1.0 (AdamVogt)
23:26:18 <redtricycle> So, I read that people use cabal-install instead of makefiles
23:26:23 <redtricycle> Can I use cabal-install to manage my personal packages?
23:26:26 <redtricycle> without uploading?
23:26:29 <redtricycle> to hackage
23:29:00 <jle`> redtricycle: yes
23:29:28 <jle`> and sandboxes for local (only in project directory) install
23:29:36 <jle`>  / build
23:30:06 <enthropy> https://github.com/yesodweb/cabal-meta if you want to avoid sandboxes (they are rather wasteful of space/time)
23:34:16 <jle`> ty enthropy
23:34:21 <AaronFriel> wat
23:34:34 <AaronFriel> oh
23:34:41 <AaronFriel> I just joined the chat or the window popped up
23:36:15 <dmj`> enthropy: with the new cabal freeze your dep versions should be saved, avoiding future install woes
23:37:01 <enthropy> dmj`: what does that follow from?
23:37:49 <dmj`> enthropy: cabal-meta...
23:43:45 <enthropy> dmj`: seems useful, but not in a way that'll help you find versions that will work in the first place
23:44:05 <enthropy> or to include packages that are only on your computer
23:45:28 <jle`> who manages lambdabot these days?
23:46:50 <pavonia> Hosts or maintains?
23:46:59 <dmj`> enthropy: I just use cabal sandbox add-source for local packages and hardcode all my version numbers because I'm paranoid, no issues :P
23:47:26 <jle`> hosts
23:47:39 <pavonia> "int" ++ "-e"
23:48:53 <jle`> ty pavonia
23:49:04 <pavonia> np
