00:25:18 <wz1000> > map (+1) [1..100]
00:25:20 <lambdabot>  [2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29...
00:33:09 <wz1000> hi
00:39:23 <jle`> hi wz1000
00:42:24 * hackagebot non-negative 0.1.1 - Non-negative numbers  http://hackage.haskell.org/package/non-negative-0.1.1 (HenningThielemann)
00:50:17 <johnw> carter: is there a fast, 128-bit integer anywhere?
00:57:36 <nschoe> johnw, don't know if it's what you need, but "Integer" is unbounded,if that's the bounds that restrain you
00:59:07 <johnw> Integer is being used presently
00:59:13 <johnw> but the performance detriments are killing me
01:00:39 <nschoe> ah ok. Well I'm sorry I can't really help you, then :/
01:00:48 <johnw> FixedPoint-simple has what I need
01:00:57 <nschoe> johnw, maybe try to build your own 128-bit integer data type ?
01:01:00 <tomejaguar> Is there a netwire IRC channel?
01:03:41 <tomejaguar> ocharles: ^^
01:03:48 <grohne> how can I figure out why Language.Haskell.Interpreter.InterpreterT IO is no longer an instance of Control.Monad.CatchIO.MonadCatchIO?
01:04:31 <m09> look at the source, maybe the instance has been removed, or its export
01:06:10 <lfairy> wait, you can not export an instance?
01:06:11 <lfairy> creepy
01:07:22 <supki> instances are always exported
01:07:39 <corgifex> you can not import a module containing the instance
01:07:57 <uniquenick> is there a way to tell ghc (on windows) to embed a specific manifest.xml instead of the one it generates?
01:07:59 <wz1000> So I was trying to write a function that takes an integer(n) and returns a fuction that adds up n numbers, and I ran into some problems. Could anybody help me
01:08:28 <johnw> show us what you wrote, wz1000
01:08:40 <corgifex> wz1000: not with that little information
01:08:46 <wz1000> one sec
01:08:56 <gamegoblin> @pl \x -> f x x
01:08:56 <lambdabot> join f
01:09:41 <wz1000> http://pastebin.com/1PbWazsb
01:09:59 <corgifex> precedence error
01:10:01 <corgifex> add parens
01:10:20 <corgifex> also the type looks wrong
01:10:31 <wz1000> yes, it gives a type error
01:10:56 <corgifex> is addn supposed to take 3 or 4 arguments?
01:11:54 <corgifex> ... are you trying to define a varargs function?
01:12:01 <corgifex> if so, what would its type be?
01:12:02 <wz1000> one argument, and a returns a function that takes n args
01:12:23 <wz1000> addn :: Integer -> a
01:12:29 <wz1000> where a is a funtion
01:12:44 <corgifex> no, "a" is any type
01:12:46 <matematikaadit> :t join
01:12:47 <lambdabot> Monad m => m (m a) -> m a
01:12:49 <wz1000> *function
01:12:51 <corgifex> and "a function" is not a type
01:14:11 <wz1000> if you have a type a -> (b -> b), can you rewrite is as a -> c where c is (b ->b)
01:15:04 <corgifex> conceptually yes, in Haskell syntax no
01:15:19 <ski> wz1000 : no, unfortunately no local type declarations in types
01:15:19 <wz1000> so how would i do this?
01:15:31 <wz1000> ill give an example
01:15:31 <corgifex> you wouldn't
01:15:37 <corgifex> you'd use sum
01:15:39 <corgifex> :t sum
01:15:40 <lambdabot> Num a => [a] -> a
01:15:50 <wz1000> i know, i just wanted to experiment
01:16:11 <wz1000> @ let add3 = ((+) .) . (+)
01:16:18 <wz1000> > add3 1 2 3
01:16:20 <lambdabot>  Not in scope: ‘add3’
01:16:33 <wz1000> @let add3 = ((+) .) . (+)
01:16:35 <lambdabot>  Defined.
01:16:37 <wz1000> > add3 1 2 3
01:16:39 <lambdabot>  6
01:16:44 <corgifex> :t add3
01:16:45 <lambdabot> Num b => b -> b -> b -> b
01:17:05 <wz1000> @let add4 = (add3 .)  . (+)
01:17:07 <lambdabot>  Defined.
01:17:19 <wz1000> >add4 1 2 3 4
01:17:46 <wz1000> :t add4
01:17:47 <lambdabot> Num b => b -> b -> b -> b -> b
01:17:55 <wz1000> add4 1 2 3 4
01:18:29 <wz1000> so to extend this, how would you create an addn
01:18:43 <corgifex> you wouldn't. what would its type be?
01:19:07 <wz1000> could you do this using templata haskell
01:19:22 <corgifex> I wouldn't, but you could
01:19:30 <gamegoblin> @pl \x y -> f (x <* y)
01:19:30 <lambdabot> (f .) . (<*)
01:19:36 <corgifex> $(add 3) 1 2 3
01:21:21 <wz1000> > add4 1 2 3 4
01:21:23 <lambdabot>  10
01:22:05 <henk> How would I parseTime a date BC?
01:23:08 <henk> Jan. 1. 4714 BC to be concrete
01:24:27 <Maxdamantus> Is there a standard meaning for that?
01:24:28 <peddie> henk: read it directly to ModifiedJulianDate and use -2400000.5?
01:25:17 <Maxdamantus> Dates are weird. We haven't always used the same system.
01:25:28 <Maxdamantus> Try running `cal 9 1752`.
01:25:51 <henk> peddie: hm, hoogle doesn’t know about ModifiedJulianDate, do you know which package that is in?
01:26:00 <peddie> time, I believe
01:26:04 <peddie> it's the constructor for Day
01:26:13 <henk> Maxdamantus: lol nice
01:27:28 <henk> peddie: oh ok, I’ll take a look, thank you. How did you get the -2400000.5? I need to do that for other dates too, which are supplied by the programs user …
01:28:03 <peddie> henk: that's the adjustment from modified to standard Julian dates, but actually I was wrong
01:28:11 <peddie> 2399999.5
01:28:18 <peddie> Julian dates start in 4713 BC
01:28:50 <peddie> henk: it's probably not a good strategy if you have to do a lot of conversions; I'd play with parseTime more first
01:29:05 <peddie> I thought you just had to convert the beginning of the Julian calendar
01:29:53 <henk> peddie: The overall idea is to write a program that calculates sunrise and sunset times for any given date and place.
01:30:15 <henk> That sounds so easy …
01:30:19 <peddie> henk: I see
01:30:44 <peddie> henk: I don't think it's too easy
01:30:52 <peddie> you have to calculate a bunch of astronomical stuff
01:31:32 <t7> does cabal sandbox cache downloads?
01:31:56 <gamegoblin> @pl \a b -> f a b <* g a b
01:31:57 <lambdabot> ap (ap . ((<*) .) . f) g
01:32:17 <dcoutts_> t7: not within the sandbox, they're cached user-wide
01:32:27 <henk> peddie: Yeah, it is not … Which is probably the reason why there aren’t hundreds of programs doing that just for kicks.
01:32:34 <t7> ah cool
01:33:03 <peddie> henk: if you really need this, look at XEphem or PyEphem
01:33:22 <peddie> I have ported chunks to Haskell, but the source is not (yet) available . . .
01:33:25 <henk> peddie: No, I just thought it’d be a good idea for a program to learn haskell …
01:33:45 <peddie> henk: don't let me stop you, but if you want it to be accurate, it might take some doing
01:33:50 <peddie> :)
01:34:38 <henk> I should’ve known it wasn’t when I tried to start with getting lattitude/longitude for a city name from OSM and would have had to start parsing XML …
01:34:53 <peddie> henk: I suspect that's the least of your problems :P
01:35:11 <henk> peddie: Yeah, the formula is quite complex and its parts as well …
01:35:29 <henk> peddie: Might be the least, but it’s XML, so it’s still a problem (;
01:35:54 <peddie> henk: if I am ever able to release that astrodynamics code, I will hit you up again
01:36:40 * peddie is sad
01:37:21 <henk> peddie: Sounds good, thank you
01:49:59 <osfameron> morning
01:50:31 <osfameron> are there interesting and readable papers on implementing the jQuery collection model as a combinator over multiple zippers?
01:50:52 <osfameron> or similarly elucidating topics
01:50:54 <wz1000> So i found out that "a monad is a monoid in the category of endofunctors" from http://james-iry.blogspot.in/2009/05/brief-incomplete-and-mostly-wrong.html is an actual sentence in the haskell documentation
01:51:10 <sgronblo> cool sentence right?
01:51:39 <wz1000> i cant stop laughing
01:51:40 <sgronblo> if most people scratch their head and go wtf when they hear the word monad, imagine them hearing that sentence instead :)
01:51:59 <corgifex> what is "the haskell documentation"?
01:52:47 <wz1000> haskell wiki, sorry
01:53:54 <corgifex> @quote endofu
01:53:55 <lambdabot> mm_freak says: bruce schneier is an endofunctor that turns all automorphisms into identities
01:53:57 <wz1000> from here http://www.haskell.org/haskellwiki/What_a_Monad_is_not , point 8
01:54:00 <corgifex> @quote endofu
01:54:00 <lambdabot> wadler says: A monad is a monoid in the category of endofunctors, what's the problem?
01:54:22 <corgifex> @quote endofu
01:54:23 <lambdabot> elly says: I leave for five minutes and godel numbering of endofunctors is invokved as a potential proof that the universe is simulated. Thanks, #haskell :P
01:54:47 <corgifex> @quote endofu
01:54:48 <lambdabot> copumpkin says: a monad is just a lax functor from a terminal bicategory, duh. fuck that monoid in category of endofunctors shit
01:56:30 <corgifex> @quote endofu
01:56:30 <lambdabot> flebron says: <flebron> Monoidal objects in the monoidal category of endofunctors on a category. I took a small detour through tensor products to understand monoidal categories better, with one example of such a product. <mauke> I have no idea what you just said
01:58:54 <mikusp> Hi! Is it strictly necessary to specify C types as newtypes while importing foreign C function? I mean, should a C function int foo(int a, double b) be imported as CInt -> CDouble -> IO CInt or it's acceptable to import it as Int -> Double -> IO Int?
01:59:44 <corgifex> I don't know but seeing foreign imports with Haskell types makes me nervous
02:00:24 <ocharles> tomejaguar: this channel, really
02:00:34 <ocharles> tomejaguar: mm_freak hasn't been around for ages though
02:00:34 <shachaf> People like to be confusing about these kinds of things.
02:02:11 <jle`> ocharles: he hangs out in specific channels here though, in case you missed the memo
02:02:23 <ocharles> jle`: oh, he stopped idling in #haskell?
02:02:27 <jle`> he has foresworn #haskell
02:02:34 <ocharles> Oh, he's in #nixos with me :)
02:02:44 <jle`> #haskell-game too
02:07:33 * hackagebot websockets 0.8.2.4 - A sensible and clean way to write WebSocket-capable servers in Haskell.  http://hackage.haskell.org/package/websockets-0.8.2.4 (JasperVanDerJeugt)
02:09:04 <jle`> sometimes i feel like an endofunctor
02:15:26 <grohne> when I have an IO monad wrapped up in a few other monads, can I somehow use Control.Exception.catch to catch the errors therein?
02:15:47 <grohne> it appears as if I need the inverse of liftIO
02:24:17 <warpy> grohne: you need Control.Exception.Lifted
02:24:27 <grohne> thanks
02:24:37 <warpy> you can use Control.Exception.Lifted.catch in any MonadIO
02:27:58 <bennofs> warpy: not in any MonadIO, only in and MonadBaseControl IO
02:28:05 <bennofs> s/and/any
02:28:51 <bennofs> warpy: Btw, there is also another way: using the exceptions package. See http://www.yesodweb.com/blog/2014/06/exceptions-transformers
02:29:43 <warpy> hmm. time to read up
02:31:28 <warpy> bennofs: what is monadbasecontrol? i dont understand it
02:32:02 <warpy> there is also monadbase ..
02:33:01 <grohne> warpy: unfortunately other instances are missing then: No instance for (monad-control-0.3.3.0:Control.Monad.Trans.Control.MonadBaseControl IO (hint-0.4.2.0:Hint.InterpreterT.InterpreterT IO))
02:33:57 <warpy> uh, maybe write an instance for it?
02:34:18 <grohne> the pieces required for doing so are not exported
02:40:41 <bennofs> grohne: you can use the exceptions package
02:40:44 <bennofs> @hackage exceptions
02:40:44 <lambdabot> http://hackage.haskell.org/package/exceptions
02:40:58 <bennofs> InterpreterT has instances for it
02:42:28 <grohne> bennofs: that's what I was trying beforehand.
02:42:42 <bennofs> grohne: why didn't it work?
02:43:36 <grohne> Couldn't match type `IO' with `hint-0.4.2.0:Hint.InterpreterT.InterpreterT IO'
02:44:40 <grohne> in forceM (Language.Haskell.Interpreter.eval s) `Control.Exception.catch` handler where forceM a = a >>= (\x -> return $! x) and handler (SomeException e) = throwError . GhcException . show $ e
02:45:20 <bennofs> grohne: I don't mean `Control.Exception.catch`, but `Control.Monad.Catch.catch`, from the `exceptions` package on hackage
02:46:09 <grohne> that way it looks for the removed MonadError instance again
02:47:30 <grohne> instance MonadError InterpreterError (InterpreterT m) was removed in hint 0.4
02:50:16 <grohne> ah. no, it's the handler function which is wrong. :)
02:52:03 <grohne> bennofs: thanks for pointing to the reight direction!
02:54:34 <anon_555> module Main where
02:54:35 <anon_555> import System.IO
02:54:35 <anon_555> main = do
02:54:35 <anon_555> 	--putStrLn ("Hello World")
02:54:35 <anon_555> 	lucky 33
02:54:35 <anon_555> lucky :: (Integral a) => a -> String
02:54:37 <anon_555> lucky 7 = "Lucky Number Seven!"
02:54:39 <anon_555> lucky x = "Sorry, you're out of luck, pal!"
02:54:41 <anon_555> what is mistake here
02:55:41 <bennofs> anon_555: please use lpaste the next time when pasting more than 2 lines
02:55:42 <Clint> you're missing the putStrLn
02:55:44 <bennofs> ?lpaste
02:55:44 <lambdabot> Haskell pastebin: http://lpaste.net/
02:56:24 <alpounet> anon_555: lucky is a String, but where you're calling it, you should be doing something in IO. if you want to print out the result, do:  putStrLn (lucky 33)
02:56:28 <BoR0> this works though Prelude> let main = "Test"
02:56:38 <alpounet> the result of calling lucky*, sorry
02:57:00 <anon_555> oh my mistake
02:57:01 <frerich2> Thumbs up for not doing IO in 'lucky' though
02:57:09 <anon_555> such a stupid one thank you brothers
02:57:12 <anon_555> ..
02:57:26 <BoR0> why would main expect IO, but not from the REPL?
02:58:23 <jle`> how unportable does having my type have a generic instance make my library?
02:58:34 <frerich2> BoR0: When you use ghci, you are already "within" IO, i.e. you write code as if you were in main. That's why you have to write 'let x = 5' instead of 'x = 5', too.
02:58:47 <jle`> should i try to avoid having my things derive Generic
02:58:52 <jle`> if the rest of the library is completely 98 compatible
02:58:53 <BoR0> frerich2, ha, that's good to know. thanks
02:59:18 <frerich2> BoR0: I think hugs does it differently, this is just an ghci implementation decision.
03:01:36 <anon_555> hi guys what would be the function type definition if a function takes a input integral and produces no output,, it prints the output by the function itself
03:01:54 <Maior> anon_555: IO ()
03:02:58 <Maior> anon_555: er, sorry, `Int -> IO ()` depending on what you mean by "a input integral" and "by the function"
03:03:12 <Maior> anon_555: (that sounds like the composition of some function and putStrLn)
03:03:23 <anon_555> ok
03:03:33 <anon_555> thanks i will try
03:07:18 <LambdaDusk> I've made an empty class (no methods) to put some types together but the compiler doesn't let me do an instance of them
03:08:31 <corgifex> yes, it does
03:10:48 <LambdaDusk> corgifex: http://lpaste.net/105382
03:11:16 <corgifex> ... see the error message
03:11:25 <corgifex> it explains what's wrong and how to fix it
03:12:41 <LambdaDusk> it does
03:12:43 <LambdaDusk> man
03:12:46 <LambdaDusk> sorry to bother you
03:12:57 <corgifex> heh
03:13:26 <corgifex> I wrote http://ideone.com/h7i7RM for fun but that won't help
03:14:56 <corgifex> http://ideone.com/IBMdYO while I'm at it
03:17:30 <LambdaDusk> corgifex: Yeah I get it
03:17:35 <LambdaDusk> I'm stupid
03:18:53 <exicer> Using attoparsec, is it possible to have sepBy split on multiple different seperators ?
03:20:13 <corgifex> sepBy x (y1 <|> y2)?
03:20:36 <exicer> corgifex: I hoped that would work, but was not sure.
03:20:54 <corgifex> so did I
03:21:43 <exicer> I assume sepBy works with strings too ? eg sepBy x (string "and") ?
03:24:31 <exicer> http://lpaste.net/105383
03:24:47 <exicer> Is there some reason this shouldn't split the string ?
03:25:05 <corgifex> yes
03:25:12 <exicer> Could you explain ?
03:25:15 <corgifex> many anyChar will eat anything you give it
03:25:31 <exicer> corgifex: I thought that was applied after the seperation, though ?
03:25:34 <corgifex> no
03:25:40 <exicer> ah
03:26:04 <corgifex> sepBy will run the first parser, then try the separator to see if more elements are coming
03:26:12 <exicer> hmm
03:26:14 <corgifex> in your case the first parser eats everything
03:26:17 <alpounet> exicer: sepBy p (choice [string ",", string "|"]) ?
03:26:37 <alpounet> if using either ',' or '|' as a separator
03:26:47 <exicer> corgifex: How would you achieve getting whatver strings were seperated by 'and' ?
03:27:04 <exicer> alpounet: is choice [] the same as <|> ?
03:27:13 <alpounet> exicer: yeah except that it takes a list
03:27:20 <exicer> alpounet: Yeah, ok cool :)
03:27:33 <corgifex> if attoparsec has notFollowedBy, you could do something ugly like many (notFollowedBy (string " and ") >> anyChar)
03:27:49 <alpounet> exicer: not sure you need to have a list. if you just have 2 parsers for separators, use <|>, definitely
03:28:58 <exicer> corgifex: Hm, it looks like it doesn't have that function.
03:33:28 <anon_555> sumlist [(1,2),(3,4),(4,5)] how to define the type of this function
03:34:39 <anon_555> http://lpaste.net/105384
03:34:41 <anon_555> help
03:35:54 <frerich2> anon_555: 'sumlist a = [b+c | (b, c) <- a]' *is* a definition already.
03:36:07 <anon_555> i mean the type definition
03:36:10 <corgifex> as for the type, you can just ask ghci
03:36:23 <corgifex> :t let sumlist a = [b+c | (b, c) <- a] in sumlist
03:36:24 <lambdabot> Num t => [(t, t)] -> [t]
03:36:25 <frerich2> anon_555: You could ask ghci: just write 'let sumlist a = [b+c | (b, c) <- a]' in ghci and then enter ':t sumlist'
03:37:06 <anon_555> i will thank you brothers
03:37:19 <corgifex> "brothers"?
03:37:30 <BoR0> @pl (\x -> x /= ".")
03:37:30 <lambdabot> ("." /=)
03:37:34 <BoR0> @pl (\x -> x /= "." && x /= "..")
03:37:35 <lambdabot> liftM2 (&&) ("." /=) (".." /=)
03:38:23 <anon_555> corgifex are you sister
03:38:31 <frerich2> boR0: You could also use (`notElem` [".", ".."])
03:38:40 <corgifex> no
03:38:54 <anon_555> corgifex ok then why would you not like to take brother
03:39:00 <anon_555> corgifex why
03:39:03 <frerich2> bor0: ...which is arguably more expressive. :)
03:39:11 <corgifex> because I'm not your brother
03:39:12 <BoR0> frerich, thanks :) it indeed is
03:39:21 <anon_555> corgifex ok sir
03:39:26 <anon_555> corgifex how about sir
03:39:26 <grohne> is there a way to simulate typed holes on older ghc (7.6)?
03:43:12 <augur> the nonElem idiom is one i've noced in a lot of places recently
03:43:16 <augur> i think i first saw it in Ruby actually
03:43:30 <augur> ![".",".."].contains(x)
03:43:36 <augur> or whatever
03:49:00 <anon_555> why is this error
03:49:01 <anon_555> http://lpaste.net/105385
03:49:44 <anon_555> ..
03:49:47 <Maior> anon_555: it would be helpful to provide the error
03:50:00 <anon_555> customhead.hs:7:17: Parse error in pattern: head'
03:50:03 <anon_555> sir
03:50:33 <lwm> fanon_555: orgot to do (x:xs) ??
03:50:41 <lwm> anon_555**
03:51:00 <lwm> ahhh typing fail
03:51:06 <anon_555> line 7 there is x:xs
03:51:37 <nschoe> anon_555, put the parentheses around X:xs
03:51:47 <Maior> lwm: oh yes
03:52:11 <BoR0> what's a good way to write if x then y else (). I reckon something like "where" or such function existed
03:52:38 <BoR0> or was it "with"
03:52:39 <BoR0> @src with
03:52:40 <lambdabot> Source not found. This mission is too important for me to allow you to jeopardize it.
03:52:40 <nschoe> BoR0, It's "when"
03:52:42 <frerich> bor0: 'when'
03:52:44 <BoR0> ah, haha
03:52:49 <Maior> :t when
03:52:49 <BoR0> when. exactly. thanks!
03:52:50 <lambdabot> Monad m => Bool -> m () -> m ()
03:53:15 <lwm> anon_555: got it?
03:53:34 <frerich> anon_555: It seems you're doing examples from the 'Learn You A Haskell' book?
03:54:15 <frerich> anon_555: Note that in the examples given, the book also uses parentheses around the 'x:xs' part ;-)
03:57:16 <tremon> where could I look for more information on Persistent PrimaryDef constructs? It looks like the code is capable of handling composite primary keys, but I can't find how to use it
03:58:33 <bergmark> tremon: it's a pretty new feature, haven't seen it documented anywhere, you may want to ask on the yesod mailing list
04:00:41 <BoR0> @pl (\x -> doesDirectoryExist (dir ++ "\\" ++ x))
04:00:41 <lambdabot> doesDirectoryExist . (dir ++) . ('\\' :)
04:00:42 <tremon> thanks, I'll browse the archives first
04:01:05 <tomejaguar> What's the equivalent of reactive-banana's 'union' in netwire?
04:03:05 <frerich> bor0: You could also consider 'doesDirectoryExist (dir </> x)'
04:03:57 <bergmark> yes always use </> for directory concatenation
04:04:48 <tomejaguar> g
04:07:46 * hackagebot yesod-core 1.2.16.1 - Creation of type-safe, RESTful web applications.  http://hackage.haskell.org/package/yesod-core-1.2.16.1 (MichaelSnoyman)
04:07:48 * hackagebot yesod-websockets 0.1.1.1 - WebSockets support for Yesod  http://hackage.haskell.org/package/yesod-websockets-0.1.1.1 (MichaelSnoyman)
04:10:24 <exicer> I posted a question I have on stack overflow: https://stackoverflow.com/questions/24139018/using-sepby-string-in-attoparsec
04:10:42 <exicer> Would appreciate it if anyone oculd help!
04:12:24 <merijn_> exicer: the "<* space" eats the space in front of the "and"
04:13:22 <merijn_> "that and this", your "in between" parser eats "that" and then a space, then tries to match " and ", ", and" and ", ", all of which fail
04:14:24 <merijn_> Because the parser cursor is at ! in "that !and this", backtracking won't work, since your "takeWhile1" parser always eats all of "that" and "space" always eats the space
04:16:22 <augur> im watching this presentation on swift
04:16:34 <augur> and the guy shows how to chain optional method calls
04:16:43 <augur> so he writes
04:16:51 <augur> well, after a few minutes of discussion, he writes
04:17:15 <augur> if let addressNumber = paul.residence?.address?.buildingNumber?.toInt() { addToDatabase("Paul", addressNumber) }
04:17:24 <augur> and this gets a round of applause
04:17:28 <augur> 0_0
04:17:43 <merijn_> augur: Be happy
04:17:44 <augur> im beginning to think that the biggest problem with haskell really is syntactic not conceptual
04:17:54 <merijn_> augur: Apple is slowly tricking people into Haskell :p
04:18:00 <augur> merijn_: :p
04:18:59 <merijn> augur: tbh, e
04:19:15 <merijn> tbh, nested records like that aren't very pretty in haskell yet
04:19:26 <merijn> Lenses help, but they're still rather intimidating
04:19:36 <tomejaguar> They're not nested records, they're binds in Maybe
04:20:28 <augur> addtoDatabase "Paul" <$> paul $$ residence >>= address >>= buildingNumber >>= toInt
04:20:35 <augur> ($$) = flip ($)
04:21:09 <augur> tomejaguar: well, but they're also nested records
04:21:55 <augur> paul :: record { residence :: Maybe record { address :: Maybe record { buildingNumber :: Maybe String } } }
04:23:31 <augur> fortunately they said that the language is going to be evolving quite a lot before its official release
04:23:36 <augur> so we might get some better stuff :)
04:24:03 <vmgamer> Salam
04:24:12 <augur> oh hey they have laziness flags
04:24:14 <augur> thats really good!
04:25:45 <merijn> tomejaguar: To me it looks like dereferencing a bunch of nested optional members of a struct
04:27:33 <tdammers> augur: or we might get *worse* stuff
04:27:51 <tdammers> apple being apple, and considering all sorts of marketing agendas
04:27:51 <augur> tdammers: :(
04:28:22 <augur> tdammers: you're a horrible dream crusher
04:28:50 <tdammers> I happen to think that I do a pretty decent job at crushing dreams
04:29:17 <BoR0> :info </>
04:29:20 <BoR0> @nfo </>
04:29:21 <lambdabot> Maybe you meant: undo do bf
04:29:46 <BoR0> frerich, where is </> defined?
04:31:47 <frerich> @hoogle </>
04:31:47 <lambdabot> System.FilePath.Windows (</>) :: FilePath -> FilePath -> FilePath
04:31:47 <lambdabot> System.FilePath.Posix (</>) :: FilePath -> FilePath -> FilePath
04:32:37 <BoR0> ah, hoogle. that helps, because google isn't very friendly with such operators ;)
04:34:25 <tdammers> google isn't very friendly, period.
04:34:36 <tdammers> or maybe google is *too* friendly
04:35:20 <tdammers> you can't have a search engine that does a good job at answering random questions in natural language *and* provide good deterministic exact technical search functionality
04:36:04 <BoR0> understandable
04:37:22 <frerich> tdammers: I bet Google search engineers would comment that with "I think you can.".
04:39:24 <osfameron> google's got increasingly less good at the latter while it becomes better at the former
04:40:00 <eizo> sure you can, just add hoogle to google if the question seems about haskell symbols
04:46:36 <dramforever> Hello, I heard that in mtl 2 things changed a lot. What's the correct way to use the, for example, ReaderT Blah IO monad?
04:47:52 <Dodek> well, you just do some machine learning to distinguish regular search from technical search, and set up input interpretation appropriately
04:50:03 <dramforever> @unmtl ReaderT blah IO a
04:50:03 <lambdabot> blah -> IO a
04:53:31 <bennofs> dramforever: I think the major difference is that there don't exist separate non-transformer versions of the monads anymore. There is no data Reader = ..., but instead it's type Reader r = ReaderT r Identity now. So instead of using the Reader value constructor, you now need to write "reader ..."
04:54:11 <bennofs> dramforever: => The non-transformer versions are just represented as transformers over the Identity monad
04:55:10 <dramforever> bennofs, so it means if I use the transformed versions nothing changes? Do I use liftIO and runReaderT the same way?
04:55:17 <bennofs> dramforever: yes
04:57:44 <BoR0> what ways are there to beautify this? http://lpaste.net/5556220335512092672
04:57:59 <dramforever> Wow, I'm happy to hear that. Ha ha it's just another example why exporting constructors are bad - If you one day discover that the constructor is not useful you cannot do anything to it without breaking existing code. If it's a function you can just change it
05:00:19 <dramforever> BoR0, the foldingFunction can be changed to use fmap.
05:00:56 <BoR0> @hoogle fmap IO
05:00:59 <lambdabot> No results found
05:01:18 <BoR0> @hoogle Functor IO
05:01:19 <lambdabot> Did you mean: :: Functor (IO a)
05:01:19 <lambdabot> No results found
05:02:00 <dramforever> BoR0, IO is a functor.. all monads are functors..
05:02:20 <BoR0> I wanted to see instance Functor IO
05:03:08 <dramforever> f `fmap` m = m >>= (return . f)
05:03:18 <ion> Well, you could implement it in terms of the Monad instance.
05:03:57 <dramforever> ion, It's already in Prelude, just use fmap and all will be fine
05:04:50 <ion> dramforever: You just implemented it in terms of the Monad instance.
05:05:33 <dramforever> yes, I just meant that you don't have to write the instance in your code
05:05:42 <ion> Of course not
05:06:06 <BoR0> how can I rewrite do { y <- readFile f ; return (length (lines y) + s) } in terms of fmap? I can't see the pattern
05:06:35 <BoR0> foldingFunction s f = do { y <- readFile f ; return (length (lines y) + s) } that is
05:07:28 <Maior> BoR0: foldingFunction s f = (\y -> s + length $ lines y) `fmap` readFile f
05:07:56 <BoR0> ah, I wonder why I wanted to do premature optimization and simply didn't use lambda
05:08:19 <frerich> boR0: I think a good improvement would be to not implement the directory walking yourself. Instead, use System.FilePath.Find.fold
05:08:51 <frerich> bor0: Something like 'find always (acc f -> acc + linesInFile f) "."'
05:09:38 <Maior> BoR0: I bet you could drop the lambda, but it's a trivial 1st pass
05:11:21 <BoR0> @pl (\y -> s + length (lines y))
05:11:21 <lambdabot> (s +) . length . lines
05:11:43 <Maior> I've not yet intuitised (ahem) .
05:11:54 <BoR0> frerich, I thought such function existed, but I was gonna play around with IO and experiment stuff
05:12:54 * hackagebot blaze-builder-enumerator 0.2.0.6 - Enumeratees for the incremental conversion of builders to  bytestrings.  http://hackage.haskell.org/package/blaze-builder-enumerator-0.2.0.6 (SimonMeier)
05:16:00 <frerich> bor0: Ah, well - if you are more looking for 'coding style' commentary. The first few things which came to my head when reading your paste were 1. "Why use filterM instead of plain filter?", "dirs ++ ds" will be somewhat inefficient if 'dirs' is large and "foldingFunction" is not a terribly nice name for a function.
05:16:12 <frerich> Oh, I forgot to insert 2. and 3. I guess :)
05:17:03 <BoR0> ok, about 1, how can I use filter instead of filterM for a IO function like doesFileExist?
05:17:41 <frerich> bor0: You can't. That's just the first thought which crossed my mind. :)
05:18:07 <BoR0> ah, okay
05:18:12 <tdammers> you can, sort of, but you'll just end up rewriting filterM with other ...M functions
05:18:27 <frerich> bor0: I think it would be nice to separate this problem into three tasks: 1. Get a list of all files beneath some directory. 2. Getting the lines of text in a file. Then you could do something like "sum . map linesInFile . getFilesBenath $ someDir"
05:18:46 <frerich> bor0: I.e. not mangle it all into once.
05:19:17 <frerich> bor0: ...except that you'd use fmap or  instead of 'map' :)
05:19:19 <frerich> er
05:19:21 <augur> hmmm
05:19:29 <frerich> lower-than dollar greater-than
05:19:37 * frerich wodners why his IRC client won't let him send that...
05:19:39 <frerich> ()
05:19:39 <augur> is it possible to have conditional functionality in haskell?
05:19:41 <frerich> hm
05:20:40 <augur> something like   if instanceOf val typeClass then classMethod val else error "I'm sorry Dave..."
05:22:28 <augur> the type class interface seems reasonable to want, because of unified functionality, but type classes arent exactly something you can query at run type
05:22:32 <augur> nevermind type checking
05:24:32 <corgifex> how much would this break parametricity?
05:24:45 <BoR0> frerich, that's a good suggestion, I'll probably rewrite it that way
05:24:54 <Tjr> augur: I've been wondering that, too. For example, if you build your own container data structure, then the iselement funciton can be implemented more efficiently if you have an ordering, but more generally if you just assume typeclass Eq.
05:25:16 <augur> well thats not quite what i was thinking, Tjr but maybe
05:25:19 <bergmark> augur: i think you can do this with ConstraintKinds
05:25:27 <augur> bergmark: no, i dont think so
05:25:35 <bergmark> ok ;-(
05:25:50 <augur> we need the ability to specify in code, not type, that something has to satisfy some constraint
05:26:20 <augur> and more order, we have to be able to have the type checker know about this satisfaction so that its not lifted to the type level
05:27:11 <augur> so for instance, in the Advanced Swift talk, they're making a text adventure, and they have a command "pull" and the approach they have is to have a class Pullable with the functionality
05:27:31 <augur> and then they test for membership in that class. if the object is not a member, it responds "You aren't sure how to pull an X"
05:27:47 <benzrf> augur: yeah
05:28:08 <augur> so it seems like, by analogy, you'd want to have a Pullable class with whatever methods
05:28:11 <benzrf> augur: somewhat recently i wanted to be able to show something or else use "no Show instance"
05:28:13 <corgifex> id' :: a -> a; id' x = if instanceOf x Num then x * 2 else x
05:28:18 <augur> and somehow test for membership in that type class
05:28:21 <t7> it carries around that data at runtime then?
05:28:38 <benzrf> t7: ideally, we could have a 'default impl'
05:28:46 <augur> corgifex: right, that's the idea
05:28:48 <benzrf> wait no that's dumb p:
05:28:55 <benzrf> no hold on
05:28:56 <augur> corgifex: tho the type you mention raises an interesting problem
05:29:00 <benzrf> what if
05:29:01 <corgifex> yeah, so that breaks parametricity completely
05:29:03 <augur> parametricity
05:29:04 <augur> yeah
05:29:14 <benzrf> what if you could declare that all types without a specific instance will use a particular one
05:29:21 <benzrf> obv. that doesnt make sense for everything
05:29:25 <augur> so we'd need something else like..   id' :: Maybe (Num a) => a -> a
05:29:25 <benzrf> but for Pull or Show it may
05:29:53 <augur> then you dont break parametricity
05:30:27 <bergmark> what about OverlappingInstances and IncoherentInstances?
05:30:30 <augur> but you'd need some special term syntax add ons to make that work
05:30:38 <t7> augur: then u need to tag all your data?
05:30:44 <augur> t7: no, probably not
05:30:49 <PragCypher> is it possible to chain maybe's together to return the first 'just'?
05:31:00 <augur> PragCypher: what do you mean?
05:31:05 <augur> PragCypher: example?
05:31:07 <pqmodn> PragCypher: perhaps you mean Data.Monoid.First
05:31:22 <corgifex> > Just 1 `mplus` Just 2
05:31:23 <lambdabot>  Just 1
05:31:30 <PragCypher> awesome thanks
05:31:31 <corgifex> > Nothing `mplus` Just 2
05:31:33 <lambdabot>  Just 2
05:31:37 <augur> also sequence
05:31:38 <corgifex> sweet
05:31:43 <PragCypher> thats exactly what I was asking for
05:31:44 <augur> > sequence [Just 1, Just 2, Just 3]
05:31:45 <corgifex> sequence is the opposite
05:31:46 <lambdabot>  Just [1,2,3]
05:31:49 <augur> oh whoops :D
05:31:58 <augur> isnt there one for lists
05:31:59 <corgifex> > msum [Just 1, Just 2, Just 3]
05:32:00 <augur> im pretty sure there is
05:32:01 <lambdabot>  Just 1
05:32:03 <augur> oh thats the one
05:33:37 <dottedmag> augur: something like this? http://lpaste.net/105389
05:33:48 <dottedmag> Not sure it is allowed
05:35:08 <augur> dottedmag: no not really
05:35:12 <augur> also that wouldnt work
05:35:14 <augur> haskell will complain
05:35:29 <zwer> > msum []
05:35:31 <lambdabot>  No instance for (GHC.Show.Show (m0 a0))
05:35:31 <lambdabot>    arising from a use of ‘M298743250757072759210933.show_M2987432507570727592...
05:35:31 <lambdabot>  The type variables ‘m0’, ‘a0’ are ambiguous
05:35:31 <lambdabot>  Note: there are several potential instances:
05:35:31 <lambdabot>    instance [safe] GHC.Show.Show a =>
05:35:41 <zwer> > msum ([] :: Maybe Int)
05:35:43 <lambdabot>  Couldn't match expected type ‘Data.Maybe.Maybe GHC.Types.Int’
05:35:43 <lambdabot>              with actual type ‘[t0]’Couldn't match expected type ‘[m a]’
05:35:43 <lambdabot>              with actual type ‘Data.Maybe.Maybe GHC.Types.Int’
05:35:59 <benzrf> zwer: nice try ;)
05:36:00 <augur> zwer:
05:36:05 <augur> > msum ([] :: [Maybe Int])
05:36:07 <lambdabot>  Nothing
05:36:08 <zwer> > msum ([] :: [Maybe Int])
05:36:09 <lambdabot>  Nothing
05:36:27 <zwer> hmm.. I am getting exception in ghci
05:36:41 <zwer> "*** Exception: user error (mzero)"
05:36:45 <pqmodn> are you implicitly using the IO monad?
05:36:57 <zwer> ah
05:37:14 <zwer> still, why exception?
05:37:26 <zwer> no mzero for IO, or?
05:37:35 <pqmodn> i'm not certain, but mzero might be error
05:37:51 <exicer> merijn: Sorry, I was called away when you answerd my question (https://stackoverflow.com/questions/24139018/using-sepby-string-in-attoparsec). If I understand what you said correctly, changing the seperater to look for "and " rather than "and" should work?
05:38:20 <dottedmag> augur: Anyway, type of containter item is known at compile-time, why runtime check?
05:38:44 <augur> dottedmag: because the idea is that it might NOT be known at compile time
05:38:51 <pqmodn> zwer: i actually don't have a MonadPlus IO instance. i guess it depends on which instance you're actually using
05:38:59 <benzrf> containter :O
05:39:38 <dottedmag> augur: how so?
05:39:45 <augur> dottedmag: see the example i already gave
05:40:04 <christiaanb> hello, I have a specific question about the 'bound' libary (http://hackage.haskell.org/package/bound), what would be the best place to ask?
05:40:28 <augur> i think maybe the "right" solution in haskell is to make the class methods capable of failing boringly, and then implementing instances for everything, but that's awfully cumbersome if you have lots of different kinds of functionality
05:41:47 <augur> maybe the better way is to invert the structure so that its not classes defining functionality but rather you'd have different constructors and just look at thos
05:41:56 <augur> but that'll get painful eventually, probably
05:41:56 <augur> hmm
05:42:38 <Adeon> can I look inside module's non-exported stuff inside ghci?
05:43:00 <frerich> augur: I still don't really understand the problem, but my experience is that in 99% of the cases where you consider a type class to be part of the solution, it's actually part of the problem. And the solution is rather something like "Pass a function to use on the given value as the argument".
05:44:32 <augur> frerich: did you read the example i gave?
05:45:30 <frerich> augur: The 'pullable' example, you mean?
05:45:33 <augur> yes
05:46:21 <frerich> augur: I did, but you lost me on the next message: "so it seems like, by analogy, you'd want to have a Pullable class with whatever methods". Why would you "by analogy" have a Pullable class?
05:46:54 <augur> frerich: because type classes are the way you implement "one interface, multiple types" in haskell?
05:47:03 <corgifex> not really
05:47:10 <augur> pretty much
05:47:15 <corgifex> no
05:47:19 <augur> yes
05:47:24 <corgifex> you're fired
05:47:34 <augur> youre not the boss of me!
05:47:41 * augur fires corgifex instead
05:47:53 <tremon> augur: how would you write a signature for a function that returns "a Pullable or some other object"?
05:48:09 <augur> tremon: please read the conversation.
05:48:58 <tremon> I have. I'm interested in how you end up with a function of unelaborated type first
05:49:12 <tremon> s/function/object/
05:49:26 <augur> if you had read it, you'd realize that we already discussed this issue
05:50:18 <augur> you need something in the types in order for this to make sense
05:50:56 <frerich> augur: I don't think type classes are the way to implement "one interface, multiple types", but maybe I misunderstand what you mean by "interface". I can just say that I know a lot of people who incorrectly assume that type classes are equivalent to Java 'interfaces' or C++ public inheritance or so.
05:51:43 <augur> interface, as in, a collection of functions/values which are associated with a type, such that all instance types of that type class can be treated uniformly with a single interface
05:51:48 <xxx-man> does one knows a type system defined with help two ot more type derivation relation? like positive and negative type derivation in one framework where those derivation are recursive depending?
05:51:52 <dwcook> Typeclasses map a type (relation) onto values.
05:52:16 <dwcook> Is that concrete enough?
05:52:22 <augur> frerich: they're reasonably close to OO interfaces, but have important differences that aren't relevant here
05:52:53 <frerich> augur: I think what you describe is a plain data value with functions in Haskell. I suspect you may find http://lukepalmer.wordpress.com/2010/01/24/haskell-antipattern-existential-typeclass/ interesting
05:53:24 <augur> frerich: that blog post misses the whole point of type classes and doesn't address the problem at all
05:53:35 <tdammers> augur: the biggest difference however is that typeclasses implement compile-time polymorphism, while interfaces are for type-safe-ish runtime polymorphism
05:53:47 <augur> tdammers: yes thats true
05:54:10 <augur> tdammers: i would argue the biggerest difference is that type classes arent bound up with particular values :)
05:54:14 <augur> tho thats obviously related
05:54:54 <augur> tdammers: thats the question im trying to get at tho, right -- how do you have some kind of run-time-checkable functionality that has a uniform interface across multiple types
05:55:19 <frerich> augur: You use currying so that you end up with a uniform function signature
05:55:35 <augur> frerich: thats.. what? i dont know what you're even saying
05:55:40 <augur> thats got nothing to do with what we're talking about
05:56:09 <dottedmag> augur: Basically you don't, because types are assigned at compile time, so there is no way to pass through undecided 'a' type to runtime.
05:56:13 <augur> some day i should learn to write haskell extensions
05:56:14 <tdammers> you can close over the polymorphic value to wrap it in a non-polymorphic structure
05:56:35 <frerich> augur: Of course it does. You use "closures" via currying.
05:56:47 <augur> frerich: no, thats irrelevant.
05:56:58 <augur> dottedmag: there are ways you can make that work, actually. its not impossible
05:57:12 <frerich> augur: I.e. you can happily attempt to apply a function (say: "pull") on a range of different values like this.
05:57:16 <xxx-man> does one knows a type system defined with help two ot more type derivation relation? like positive and negative type derivation in one framework where those derivation are recursive depending?
05:57:19 <augur> tdammers: how were you thinking?
05:57:26 <augur> tdammers: you mean use some kind of existential?
05:57:29 <dottedmag> augur: it is relevant: you've got your object and you return a function which acts upon this object. Then the code later on can use it not caring about actual type.
05:57:57 <corgifex> xxx-man: spam
05:58:00 * hackagebot hs-carbon 0.0.0.2 - A Haskell framework for parallel monte carlo simulations  http://hackage.haskell.org/package/hs-carbon-0.0.0.2 (cholmgreen)
05:58:03 <augur> tdammers:   data MaybeClass c = forall a. Nil a | forall a. c a => Just a
05:58:11 <xxx-man> no spam
05:58:16 <xxx-man> question :)
05:58:21 <augur> tdammers: that would work actually. is that what you meant? hmm.
05:58:26 <corgifex> an exact copy of the same thing you asked before
05:58:30 <frerich> augur: It's exactly what I wrote...
05:58:43 <corgifex> including all the typos
05:59:02 <augur> frerich: you were prattling on about closures and currying. those have nothing to do with existentials and class constraints.
05:59:16 <xxx-man> corgifex: exactly :(, but noone gave me atention before
05:59:33 <dwcook> xxx-man: I would make an attempt at answering your question, but I can't parse it.
05:59:40 <tdammers> augur: it's the same approach, frerich just happened to highlight different aspects of it
05:59:41 <augur> tdammers: hm. yet another case where existentials and class constraints solve the problems of OO
05:59:59 <frerich> augur: The point is taht you don't use class constraints or classes in the first place.
06:00:19 <augur> tdammers: well i dont know what he was talking about. maybe what he said can make some sense of it, but he wasn't making it do so
06:00:45 <augur> i really should get a version of GHC with constraints kinds and play around with this stuff
06:00:52 <xxx-man> dwcook: I need a paper where is study of type system where type derivation is built using two or more type derivation relation
06:00:54 <frerich> augur: The approach is to have functions like "pullThis :: AThis -> Distance -> Bool" and "pullThat :: AThat -> Distance -> Bool". You can then pull 'AThis' and 'AThat' objects uniformly by applying either function to just one argument, i.e. you have a "pullThings :: [Distance -> Bool]" which lets you pull different kinds of objects in one go.
06:01:14 <frerich> augur: ...by dong something like "pullThing [pullThat myThat, pullThis myThis]"
06:01:18 <augur> uh
06:01:35 <augur> thats not at all solving the problem
06:01:43 <tdammers> the currying is more like an implementation detail, really
06:01:54 <frerich> tdammers: Of course. The "closing over" part is what matters.
06:02:07 <augur> frerich: all you're doing is uniformly pulling all those things, just using different techniques
06:02:14 <tdammers> for a real world example, look into HDBC's SqlValue
06:02:15 <augur> ofcourse there's no reason to not use a type class for that
06:02:24 <augur> but that's not the problem i was trying to solve
06:02:56 <xxx-man> dwcook: for example, if we consider simple typed lambda calculus and if app rule has a form    G |-^- M: tau->tau  G |-^+ N : tau  ==> G|-^+ MN : tau
06:03:01 * hackagebot hs-carbon 0.0.0.3 - A Haskell framework for parallel monte carlo simulations  http://hackage.haskell.org/package/hs-carbon-0.0.0.3 (cholmgreen)
06:03:39 <augur> tdammers: i think that would work but it would be tricky, because you'd need to have some way of making sure you only ever use that Just in the places where the type in question obviously has an appropriate instance
06:03:48 <xxx-man> dwcook: if we have positive and negative rules for type derivation in a system... if tehre is a study of such type system
06:04:05 <augur> that wouldnt scale well to more classes
06:04:10 <augur> this is an interesting problem
06:04:27 <dwcook> xxx-man: Hmm, sorry, don't know much about that. Others in here might but it's possible there's a more appropriate channel.
06:05:32 <xxx-man> dwcook: could you tell me please which channels?
06:06:03 <augur> xxx-man: if you're looking for a type theory channel
06:06:06 <dottedmag> augur: Do you mean https://hackage.haskell.org/package/base-4.7.0.0/docs/Data-Dynamic.html BTW?
06:06:08 <augur> try ##typetheory!
06:06:26 <dwcook> xxx-man: Well, if you wanted to ask among the Haskell crowd, there's #haskell-blah. I've also heard there's ##computerscience but I can't tell you how reliable it is.
06:06:29 <augur> dottedmag: no, obviously not..
06:06:34 <dwcook> Oh, didn't know about ##typetheory
06:07:21 <augur> dottedmag: i dont need dynamic typing
06:07:48 <augur> the question is about how to access an interface when it's there, and do something else when its not
06:08:07 <xxx-man> dwcook: thanks
06:08:14 <xxx-man> augur: thanks
06:10:21 <juhp_> is there anything better than darcs-to-git - or something that does import _darcs too?
06:10:27 <juhp_> doesN'T
06:10:56 <augur> function (x : Class) { if (c.isClass(Class')) { ... } else { ... } }
06:11:01 <augur> thats the analogous functionality
06:11:07 <juhp_> otherwise I guess I will just do it by hand again...
06:11:10 <augur> the question is how to get something like that
06:11:24 <dottedmag> augur: what would be the signature of this construct?
06:11:29 <augur> well, where Class is parametric
06:11:54 <augur> dottedmag: in haskell? it cant be done with type classes in haskell right now
06:12:11 <hexagoxel> augur: but would that not lead to inconsistent behaviour? if in one module there was no instance, but in another there is? (sorry if this was discussed, i might have missed it)
06:12:13 <augur> and probably would be hard to do without breaking parametricity
06:12:28 <augur> hexagoxel: yes, that's correct, it would
06:19:42 <frerich> augur: What would be a more realistic example of 'Class' and its sublcasses? I think the example, as it stands, wouldn't even get written in Haskell in the first place -- not because it's hard or easy to do, but because there is no need to. If you were writing an application with a known set of subclasses, you would have a single data type in Haskell, so you could use pattern matching. If you were writing a library,
06:19:42 <frerich>  with an 'open world' assumption, then the given function would actually be supplied by the caller.
06:20:04 <frerich> augur: I guess it would help if you could give a more concrete example, something involving avocados and chairs, for instance. :)
06:20:47 <augur> you can peel avocados but not chairs
06:20:53 <augur> but both should be household objects
06:20:54 <augur> happy?
06:22:02 <frerich> Ok so that means your function would be somethng like 'function peel( x: HouseholdObject) { if (x.isClass(Avocado) { ... } else { ... } }'?
06:22:14 <frerich> I.e. you "fail" for unsupported types?
06:22:15 <augur> class HouseholdObject {}    ;    interface Pealable { void peal(); }    ;    class Avocado : HouseholdObject implements Pealable {}    ;    class Chair : HouseholdObject {}
06:22:28 <benzrf> augur: *Peelable
06:22:30 <benzrf> ;)
06:22:33 <augur> frerich: sure, if you prefer
06:23:02 <augur> frerich: tho in some sense HouseholdObject might be abstractable
06:23:03 * hackagebot hs-carbon-examples 0.0.0.1 - Example Monte Carlo simulations implemented with Carbon  http://hackage.haskell.org/package/hs-carbon-examples-0.0.0.1 (cholmgreen)
06:23:30 <frerich> augur: How about 'data HouseholdObject = Avocado | Chair' with 'peel :: HouseholdObject -> Maybe Result' and 'peel Avocado = Just ...' and 'peel Char = Nothing'?
06:23:32 <augur> the point is not that, the point is the behavior pivots on whether or not certain functionality exists
06:23:51 <augur> frerich: yes, i think I already said that was an option like twice
06:24:11 <augur> it forces HouseholdObject to be specified -- you cant quantify over it
06:24:33 <augur> consider:
06:24:45 <augur> tryToShow :: ??? => a -> String
06:24:46 <frerich> augur: I.e. the concern is that the set of HouseholdObjects is fixed at the time 'peel' is compiled?
06:25:14 <augur> tryToShow x = if x `inClass` Show then show x else "I don't know how to show this value."
06:25:48 <augur> frerich: i.e. it would be nice if you could replace the concrete "HouseholdObject" type with a type var
06:26:04 <BoR0> @pl (\x -> doesFileExist (d </> x))
06:26:04 <lambdabot> doesFileExist . (d </>)
06:26:35 <augur> lol BoR0
06:26:44 <BoR0> what? :)
06:26:54 <augur> its obvious what that should be!
06:27:14 <BoR0> why is it obvious?
06:27:29 <augur> because its a single function application
06:27:37 <augur> the var is on the right edge
06:27:46 <augur> and it only occurs once
06:28:01 <BoR0> ah right, f(g(x)) = f.g
06:28:03 * hackagebot hs-carbon 0.0.1.0 - A Haskell framework for parallel monte carlo simulations  http://hackage.haskell.org/package/hs-carbon-0.0.1.0 (cholmgreen)
06:28:38 <frerich> augur: I see. You can abstract this though: Consider that the caller of 'peel' is 'consume' or so, and it first peels and then eats a fruit. If you want an open set of household objects, you'd consider something like 'consume :: HouseholdObject a => a -> Bool' plausible?
06:29:22 <augur> frerich: i dont know what you're talking about
06:29:51 <frerich> augur: Can you give an example for a caller of 'peel'?
06:29:52 <augur> oh yes, i think i see what you're getting at
06:30:09 <augur> sure, you'd like that, but now you're just making HouseholdObject into a type class
06:30:15 <augur> and with what functionality?
06:30:22 <augur> peel?
06:30:23 <frerich> Well my point is: do no tmake it a type class. I'm getting to that :)
06:30:34 <augur> im not considering anything plausible
06:30:40 <augur> you're the one who wrote that as a type class :P
06:30:51 <frerich> Yes, but only in the hope of you agreeing that it would be plausible :)
06:30:58 <augur> alas, i dont!
06:31:18 <f-a> hello people from haskell. I am reading a tutorial on Control.Monad.Cont. I tried to load an example which contains the constructor `Cont` but ghci complains that "Not in scope: data constructor `Cont'". But it is exported, as far as I can tell! hackage.haskell.org/package/mtl-1.1.0.2/docs/src/Control-Monad-Cont.html What is happening there?
06:31:38 <augur> i mean probably ultimately you'd have a top-level type class for all of the relevant types that youre considering in your program, but the tryShow example shows you dont want that necessarily
06:32:04 <rwbarton> f-a: first of all, mtl-1.1.0.2 is quite old, is that the version you're using?
06:32:22 <frerich> augur: The thing I was in the process of saying is that if you want an open set of types to be consumable (i.e.: peelable) you *can* use a type class, but I'd argue in favor of rather of doing something like ""consume :: a -> (a -> Bool) -> Bool" where the function argment is what 'consume' should be use for peeling.
06:32:33 <frerich> augur: I.e. you don't perform any type checking at all.
06:32:54 <augur> frerich: yes but how are you going to define this in a generic way
06:32:58 <f-a> mtl-2.1.1 <-- rwbarton , let me check if the constructor is exported there too
06:33:09 <rwbarton> f-a: it looks like there is no longer a Cont data constructor at all, in recent mtl
06:33:19 <f-a> indeed there is not
06:33:26 <augur> how are you going to make it say "Ok, peeled" when a is peelable, and "Uh oh, can't peel that!" when a is not peelable?
06:33:28 <mp> http://www.haskell.org/haskellwiki/Applications_and_libraries/Cryptography - "The Haskell Cryptographic Library" and "Implementations of MD5, SHA1 and DES" links are broken
06:33:32 <augur> frerich: thats the question, frerich
06:34:02 <frerich> augur: The function given by the caller does that. The 'peel' function (the second argument) is the function appropriate for peeling values of the first argument type.
06:34:34 <augur> frerich: but then you're saying you have to supply the correct function -- the function that says "ok!" or "oops!" -- by handle at the call site
06:34:48 <augur> frerich: but then there's no point in supplying it, since you already know the answer ahead of time
06:34:53 <f-a> rwbarton: indeed 'cont' is the way to go. Thanks
06:35:03 <augur> you know already that `a` is peelable or not, so why both?
06:35:14 <augur> frerich: implement the tryShow example
06:35:16 <augur> its nice and simple
06:35:17 <frerich> augur: You don't necessarily known that 'a' is peelable or not.
06:35:25 <augur> you show me what you mean using that.
06:36:44 <frerich> augur: Well what I'm saying is that you don't write a function "tryShow" :) You don't do (or need) runtime type checking :)
06:37:07 <augur> frerich: ok, so what you're saying is
06:37:09 <augur> this whole time
06:37:22 <augur> you've been arguing that the problem was the wrong problem to solve
06:37:28 <augur> not that you have a solution to the problem
06:38:05 <frerich> augur: I think this is an "XY" problem really. You think that in order to do X, you ened to do Y - and now you try to figure out how to do Y.
06:38:30 <augur> frerich: well i want to do X. you show me how to do X with Y, and how to do Y.
06:40:06 <frerich> augur: The original task given in your Swift talk was that depending on the type of an object, you want to execute different code (either you "pull" an object, or you issue an error message). And the talk implemented this by doing a type check at runtime. Right?
06:40:48 <augur> sure
06:40:56 <augur> more accurately, it's just doing what tryShow is doing
06:41:05 <augur> only not with show but with some other behavior
06:41:56 <frerich> Ok. So that's the "X". Now, you asserted that "by analogy", you'd want to have a "Pullable class". That's the "Y". And now you wonder how to implement "Y" by asking how to test whether a type implements some class or not.
06:42:23 <frerich> Still accurate?
06:42:24 <augur> frerich: no
06:42:40 <augur> i said the "obvious" analogistic translation was to do that, but that obviously wont work, so what is the right solution
06:43:05 * hackagebot hOpenPGP 1.2.1 - native Haskell implementation of OpenPGP (RFC4880)  http://hackage.haskell.org/package/hOpenPGP-1.2.1 (ClintAdams)
06:47:52 <frerich> augur: Given that you want the function which implements the "pull" action to work on an open set of types (i.e. you discarded the "data Object = This | That" idea, treating Swift types as Haskell values), the function which does it clearly needs to be polymorphic. Like "performPull :: a -> IO ()' or so. Sounds good?
06:48:02 <Darwin226> If I have a [IO (Maybe a)], how can I filter out the elements that are Nothing and get [IO a]?
06:48:44 <frerich> augur: Leaving type classes aside, "performPull" clearly knows nothing about 'a' so it *has to* be given a function which can allow it to implement the behaviour which is specific to the type 'a'.
06:50:12 <rwbarton> Darwin226, you can't. the question makes no sense
06:50:29 <rwbarton> Darwin226: none of the elements are Nothing, because they are IO actions instead
06:50:50 <augur> frerich: the problem is you can never give it such a function
06:50:56 <zwer> :t liftM catMaybes . sequence
06:50:57 <lambdabot> Monad m => [m (Maybe a)] -> m [a]
06:51:01 <augur> because if you could, then you could just implement the thing in question
06:51:08 <frerich> augur: Exactly, and that's what you do.
06:51:18 <augur> frerich: what
06:51:23 <augur> "and that's what you do"
06:51:24 <augur> what
06:51:30 <frerich> augur: Implement the thing in question.
06:51:32 <augur> i just said its impossible to do that
06:51:35 <augur> ...
06:51:46 <augur> frerich: why dont you just write the example code instead of saying "do this"
06:51:49 <augur> just write it, ok?
06:52:02 <frerich> augur: I wrote various example functions for pulling stuff already :)
06:52:08 <augur> no you didnt
06:52:09 <Darwin226> rwbarton: What I meant was that some of them are obviously IO Nothing (but this isn't correct either since IO isn't a constructor, right?)
06:52:11 <augur> you gave nothing
06:52:21 <augur> write something, put it on lpaste, and then we'll talk.
06:52:38 <frerich> augur: Ok I'm sorry, I guess I'm not able to get through to you, so let's just leave it at that and hope somebody else here is more able ;-)
06:52:43 <Darwin226> zwer: Seems like this does what I want.
06:52:49 <augur> frerich: you could get through to me with actual code
06:53:17 <rwbarton> Darwin226: there is no such thing as "IO Nothing" either, yes
06:53:18 <augur> frerich: show code, or stop claiming you have a solution
06:53:21 <frerich> augur: You *cannot* write code for the solution you have in mind (executing different code depending on the type of a value by checking the type at runtime) in Haskell.
06:53:24 <zwer> Darwin226 note that you are getting IO [a], not [IO a]
06:53:32 <augur> frerich: thats what i just frelling said
06:53:36 <zwer> which is probably what you meant
06:53:42 <augur> frerich: i literally just said you cant do that
06:53:51 <bennofs> Darwin226: note that this executes all IO actions
06:54:02 <frerich> augur: Well then what do you conclude from me saying the same? :)
06:54:16 <augur> frerich: that you havent been paying any attention to the conversation
06:54:22 <Darwin226> zwer: I THINK that's what I want. We'll see where problems occur. If I can't work it out I'll ask again with a more general question
06:54:45 <frerich> augur: Geuss that's one way to show appreciation for bothering to think about your problem, yeah ;->
06:56:13 <arj> is there a symbol for reverse application in Haskell?
06:56:43 <athan> :t (&)
06:56:44 <arj> i.e. something of type a -> (a -> b) -> b
06:56:44 <lambdabot> a -> (a -> b) -> b
06:56:46 <augur> frerich: from what i can tell, you havent been thinking about it at all
06:56:46 <bennofs> arj: no, not in base I think
06:56:49 <arj> ah :)
06:56:54 <athan> :)
06:56:58 <bennofs> arj: (&) is from 'lens' though
06:57:07 <augur> anyway, hopefully someone who isn't full of it has some idea if there's a solution in haskell
06:57:07 <arj> ah I see, is it well known?
06:57:12 <athan> ^ thanks bennofs
06:57:29 <pjdelport> It's basically flip id
06:57:49 <athan> arj: I think so, it might be `flip ($)` actually
06:57:54 <athan> :t flip ($)
06:57:55 <lambdabot> b -> (b -> c) -> c
06:58:05 <athan> im not sure though
06:58:06 <corgifex> augur: didn't you just say it's impossible?
06:58:18 <athan> there's probably something crazy complex somewhere that I'm missing xD
06:58:31 <arj> athan: sounds resonable for me ;) thx
06:58:38 <arj> *to
06:58:48 <bennofs> :t flip id
06:58:49 <lambdabot> b -> (b -> c) -> c
06:58:50 <athan> no prob!
06:59:02 <bennofs> :t ($) `asTypeOf` id
06:59:04 <lambdabot> (a -> b) -> a -> b
06:59:04 <athan> benoffs: *doh!*
06:59:06 <augur> corgifex: no, i said what he was describing was impossible
06:59:13 <athan> o.o
06:59:28 <corgifex> ah, still in XY land
06:59:32 <Darwin226> Ok, more problems. I think it might be better to say what I want to do so you guys can hopefully suggest a sane way of doing it. Basically, I want a function [FilePath] -> IO [Map String Picture] that makes a Map of filenames (not the same as the paths) to Pictures (from the Gloss library). I have a function FilePath -> IO (Maybe Picture) at my disposal.
07:00:10 <corgifex> Darwin226: what's a filename?
07:00:15 <augur> corgifex: as i said, i can see some ways of doing it for a limited collection of relevant types (which is almost fine) except you have to write a lot of "default" class instances
07:00:28 <Darwin226> corgifex: just an aliast for String
07:00:34 <Darwin226> alias*
07:00:35 <augur> corgifex: no real way to make it completely generic that way
07:00:41 <corgifex> Darwin226: so is FilePath
07:00:53 <corgifex> augur: still talking about classes?
07:01:14 <augur> corgifex: more or less classes, sort of
07:01:21 <Darwin226> corgifex: Oh sorry, misread the question. A filename is the name of the file without the path to it and it's extension. There's a function for it in System.FilePath.Windows (takeBaseName)
07:01:52 <corgifex> Darwin226: why is there a list in the result type?
07:02:18 <Darwin226> corgifex: Yeah, that shouldn't be there
07:02:43 <corgifex> Darwin226: how are you going to deal with collisions?
07:02:56 <corgifex> takeBaseName x == takeBaseName y
07:03:10 <Darwin226> corgifex: My use case isn't particularly general so those won't happen
07:03:21 <albeit> I have a sum type, and all the construcotrs are of the form "XYZ Int a".. such as "MyObj = Foo Int String | Bar Int Int | Baz Int Bool". Is there any way to match all those constructors, and extract the Int and the a? Sort of a "func (_ k v)"?
07:03:48 <albeit> And all the "a" types below to a specific typeclass
07:05:19 <Darwin226> Currently, I'm stuck at a point where I have a list of pairs [(String, IO (Maybe Picture))] and I want to make it into IO [(String, Picture)]
07:06:51 <Maior> Darwin226: sequence may be your friend
07:06:56 <corgifex> :t let foo :: String -> IO (Maybe picture); foo = undefined in mapM (\p -> fmap (fmap (,) p) (foo p))
07:06:57 <lambdabot>     Couldn't match expected type ‘Maybe picture0 -> b’
07:06:57 <lambdabot>                 with actual type ‘[b0 -> (Char, b0)]’
07:06:57 <lambdabot>     Possible cause: ‘fmap’ is applied to too many arguments
07:07:08 <corgifex> :t let foo :: String -> IO (Maybe picture); foo = undefined in mapM (\p -> fmap (fmap ((,) p)) (foo p))
07:07:09 <lambdabot> [String] -> IO [Maybe (String, a)]
07:07:43 <corgifex> :t let foo :: String -> IO (Maybe picture); foo = undefined in fmap catMaybes . mapM (\p -> fmap (fmap ((,) p)) (foo p))
07:07:44 <lambdabot> [String] -> IO [(String, a)]
07:08:15 <t7> @hoogle Int -> [a] -> [a]
07:08:18 <lambdabot> Prelude drop :: Int -> [a] -> [a]
07:08:18 <lambdabot> Data.List drop :: Int -> [a] -> [a]
07:08:18 <lambdabot> Prelude take :: Int -> [a] -> [a]
07:10:12 <Darwin226> corgifex: What... Do you mind explaining what's going on there? It looks very magic
07:11:16 <corgifex> :t let foo :: String -> IO (Maybe picture); foo = undefined in foo
07:11:17 <lambdabot> String -> IO (Maybe picture)
07:11:25 <corgifex> Darwin226: do you understand this part?
07:11:41 <Darwin226> corgifex: I don't know what undefined is/does
07:11:50 <corgifex> @src undefined
07:11:50 <lambdabot> undefined =  error "Prelude.undefined"
07:11:54 <corgifex> :t undefined
07:11:55 <lambdabot> a
07:12:10 <corgifex> it's just a placeholder here
07:12:22 <Darwin226> Oh, ok
07:12:38 <Darwin226> I see, I think I can work my way backwards
07:12:40 <Darwin226> Thank you
07:13:24 <arj> anyone aware of a quantitative analysis of the order of haskell programs? i.e. what is the highest-order, average order, and distribution of orders and such?
07:13:46 <arj> with order I mean function's order
07:14:58 <Tjr> arj: what's the order of the reverse function? First because "easy"? Second because it operates on a monade-made data type?
07:15:14 <Tjr> > reverse [1,2,3]
07:15:16 <lambdabot>  [3,2,1]
07:15:56 <arj> Tjr: I'd consider it to be first order.
07:16:09 <corgifex> @src join
07:16:09 <lambdabot> join x =  x >>= id
07:16:09 <arj> because this is a built in type
07:16:39 <benzrf> monade-made?
07:16:50 <tayacan> So I'm trying to generate haddock documentation for a model, and when I run cabal haddock --hyperlink-source, it tells me that I need hscolour version >= 1.8. However, cabal also says that I have hscolour-1.20.3. I'm guessing that this is too new? Where do I even start looking for a solution?
07:16:51 <Tjr> benzrf: a list is a monad
07:16:57 <corgifex> no, it's not
07:17:06 <benzrf> Tjr: it's not
07:17:32 <benzrf> my computer is a type of electronic device
07:17:38 <benzrf> oh wait
07:17:44 <benzrf> that's misinterpretable
07:17:51 <arj> well: instance Monad [] -- Defined in `GHC.Base'   ?
07:17:54 <Tjr> benzrf: see http://dev.stephendiehl.com/hask/#monads , scroll down to list monad
07:18:10 <corgifex> tayacan: what does HsColour -version say?
07:18:15 <benzrf> Tjr: [] is a monad
07:18:19 <benzrf> lists are not
07:18:24 * benzrf gains 1 level in pedantry
07:18:35 <arj> so you mean the constructor is a monad?
07:18:41 <corgifex> the type constructor, yes
07:18:46 <corgifex> not the data constructor
07:18:54 * Tjr can't pronounce []
07:18:56 <arj> I agree exactly.
07:19:10 <arj> "open square bracket"
07:19:29 <tayacan> corgifex, Uh, am I supposed to have hscolour as a program? Or am I supposed to type that in a ghci?
07:19:40 <corgifex> tayacan: it's a program
07:19:45 <arj> Tjr: still, you know of any quantitative analysis?
07:19:59 <benzrf> List
07:20:03 <dcoutts_> tayacan: is hscolour on your path?
07:20:05 <tayacan> corgifex, Then that's the problem - I have the haskell package, not the program
07:20:25 <corgifex> unlikely
07:20:41 <corgifex> tayacan: do you have a ~/.cabal/bin?
07:20:58 <tayacan> corgifex, yeah
07:21:01 <Tjr> arj: sorry, no. I was just trying to point out why I think such an analysis is very unlikely to exist: the concept isn't unambiguous.
07:21:18 <corgifex> tayacan: do you have a HsColour in there?
07:21:33 <tayacan> corgifex, yup - so it's just not on my path, then
07:21:40 <corgifex> right
07:21:49 <dfranke> So, I think I have Haskell row types up to a solid PoC: http://lpaste.net/105395
07:22:20 <arj> Tjr: I agree that one has to exactly state how to define the order, but you always have to define your stuff when doing a quantitative analyses
07:22:33 <arj> anyway, thx
07:22:49 <tayacan> corgifex, dcoutts_, Thanks, it works now :)
07:22:56 <dfranke> I've gotten rid of all the evil language exensions except for UndecidableInstances which is basically inevitable here.
07:23:18 <benzrf> what are row types anyway q.q
07:23:31 <benzrf> i think somebody linked me to a presentation or something but i was too tired to parse it
07:23:47 <dfranke> Well, I could probably make RowCons carry some sort of extra type evidence with it and then provide TH to generate the necessary proofs, but I wouldn't call that an improvement.
07:24:16 <dfranke> benzrf: https://www.cs.cmu.edu/~neelk/rows.pdf
07:24:50 <benzrf> i do not know type theory -.-
07:25:22 <dfranke> benzrf: essentially, it means you can write functions that are polymorphic over the fields of a record. So you can write a function that accepts any structure that has a field named 'foo' of type 'Bar'.
07:25:28 <benzrf> ooooh
07:25:37 <benzrf> like structural typing, you mean?
07:26:09 <dfranke> benzrf: structural typing is something subtly different...
07:26:16 <benzrf> how so?
07:26:41 <dfranke> benzrf: structural typing means data Foo x = Foo x | Bar is the same type as Maybe, rather than merely an isomorphic one.
07:27:03 <benzrf> oh?
07:27:12 <benzrf> i always thought it meant what you just described o=
07:27:22 <benzrf> in OOP, anyway
07:27:36 <benzrf> you state what methods you want and their types instead of a __class__
07:27:37 <benzrf> *class
07:27:45 <dfranke> benzrf: row types are sometimes called "static duck types"
07:27:58 <osfameron> sitting ducks?
07:28:07 <dfranke> ofan: hehe
07:28:23 <dfranke> s/ofan/osfameron /
07:30:24 <Black-Heaven> hi all
07:30:40 <dfranke> benzrf: structural typing + subtypes leads to being able to do much the same sort of thing as you can do with row polymorphism and no subtyping.
07:31:14 <Black-Heaven> Is there a way to do a zipWith ($) -like on two HList? Thanks by advance
07:31:43 <fread2282> why shouldn't I use recursion-schemes?
07:32:33 <Tjr> > zipWith ($) [ (+1), (+2)] [0,0]
07:32:35 <lambdabot>  [1,2]
07:32:43 <benzrf> Black-Heaven: why are you using hlists
07:33:15 <Black-Heaven> benzrf: I'm trying to chain Kleisli data types
07:34:10 <anon_555> hi
07:34:32 <anon_555> i am a begineer and now i want to see the sample project in haskell
07:34:47 <hunt> haskell, i cant continue using this language unless i can get profiling libraries :(
07:34:57 <anon_555> is there any simple projects on haskell by you guys
07:35:08 <hunt> i tried to cabal install world --reinstall, and ghc is seg faulting on ghc-mod
07:35:21 <hunt> because i changed Library-Profiling to True
07:35:26 <hunt> or whatever the flag is
07:35:33 <hunt> uin my ~/.cabal/config
07:35:39 <fread2282> I'm playing around with making my own haskell-like lang, and noticed that ekmett isn't using them in ermine
07:36:08 <guymann> hi
07:36:58 <anon_555> hello can you guys refer me the project for begineer
07:43:14 <palmrus> Sorry, couldn't find this on my list of haskell operators - what is $ ?
07:43:29 <dottedmag> anon_555: http://www.haskell.org/haskellwiki/H-99:_Ninety-Nine_Haskell_Problems ?
07:43:34 <fread2282> @src ($)
07:43:34 <lambdabot> f $ x = f x
07:43:46 <anon_555> dottedmag: thank you sir
07:43:56 <fread2282> palmrus: it's used to reduce parens
07:44:05 <palmrus> thanks fread2282
07:44:44 <Walther> foo $ bar baz = foo(bar(baz))
07:44:58 <bergmark> palmrus: (a b c) (d e f) = a b c $ d e f
07:45:34 <anon_555> dottedmag: i want to work actually in real world thing
07:45:57 <Maior> anon_555: I had much fun porting code
07:46:02 <Maior> from Python
07:46:17 <bergmark> anon_555: do you want to work on an existing project or start a new one?
07:47:57 <haasn> fread2282: recursion-schemes as in zygihistoprepro and stuff?
07:48:00 <haasn> zygo*
07:48:58 <haasn> I think the main reason edwardk abandoned the use of those is that while, yes, you can build any sort of recursion scheme using them as basic building blocks; in practice it is just too damn confusing once you start using more than the very simplest
07:49:26 <fread2282> haasn: no, just as in Fix and cata
07:49:47 <haasn> And you need to much sugar/newtype wrapping with stuff like Fix, Mu, Nu, etc.
07:50:09 <haasn> In general, it just seems easier to just write your own recursion than to re-use existing schemes
07:50:25 <`Jake`> Is there a standard library function to test whether a list xs is a subset of ys without using Data.Set?
07:50:53 <haasn> `Jake`: Do you care about order?
07:50:58 <`Jake`> haasn: no
07:52:09 <pjdelport> You could do ys \\ xs == []
07:52:35 <`Jake`> pjdelport: Thanks. Shouldn't it be xs \\ ys, though?
07:52:36 <haasn> That is probably the best you're going to get, it's O(n²) though
07:52:47 <haasn> `Jake`: Yes, xs \\ ys
07:52:54 <`Jake`> haasn:  I think O(n^2) is fine, it's only about 10 elements
07:52:55 <Maior> @src (\\)
07:52:55 <lambdabot> (\\) = foldl (flip delete)
07:53:01 <pjdelport> `Jake`: Right, sorry.
07:53:07 <`Jake`> alright, thanks guys
07:53:11 <Itkovian> or null $  xs \\ ys
07:53:11 <Maior> @src delete
07:53:12 <lambdabot> delete = deleteBy (==)
07:53:33 <haasn> null++
07:53:54 <haasn> But then again, if you're using \\ you already have an Eq constraint on the elements
07:54:12 <`Jake`> You obviously can't test for subsets without using Eq
07:54:25 <benzrf> :t (\\)
07:54:26 <lambdabot> Eq a => [a] -> [a] -> [a]
07:54:33 <benzrf> > [1, 2, 3, 4] // [5, 2]
07:54:34 <lambdabot>  Couldn't match expected type ‘GHC.Arr.Array i e’
07:54:35 <lambdabot>              with actual type ‘[t0]’
07:54:40 <benzrf> -.-
07:54:44 <Itkovian> oh well, I just prefer using null
07:54:46 <benzrf> oh
07:54:49 <benzrf> > [1, 2, 3, 4] \\ [5, 2]
07:54:50 <lambdabot>  [1,3,4]
07:54:52 <benzrf> :t (//)
07:54:53 <lambdabot> Ix i => Array i e -> [(i, e)] -> Array i e
07:55:00 <`Jake`> I think I do, too
07:55:00 <benzrf> :t (\/)
07:55:01 <lambdabot>     Not in scope: ‘\/’
07:55:01 <lambdabot>     Perhaps you meant one of these:
07:55:01 <lambdabot>       ‘/’ (imported from Prelude), ‘//’ (imported from Data.Array),
07:55:06 <benzrf> :t (/\)
07:55:07 <lambdabot>     Not in scope: ‘/\’
07:55:07 <lambdabot>     Perhaps you meant one of these:
07:55:07 <lambdabot>       ‘/’ (imported from Prelude), ‘/=’ (imported from Data.Eq),
07:57:27 <benzrf> :t (/\/)
07:57:29 <lambdabot> Please Stop Harassing Me Benzrf
07:57:33 <benzrf> :(
07:57:42 <fread2282> :t (/\/)
07:57:43 <lambdabot> Please Stop Harassing Me Benzrf
07:57:46 <benzrf> hehe
07:57:47 <fread2282> :o
07:57:48 <`Jake`> Wow
07:58:24 <`Jake`> lambdabot even does that in private msgs
07:58:33 <fread2282> :t id
07:58:34 <lambdabot> a -> a
07:58:34 <`Jake`> I don't know why I abbreviated that
07:58:45 <fread2282> @src (/\/)
07:58:46 <lambdabot> Source not found. You type like i drive.
07:59:03 <benzrf> `Jake`: that's because (/\/) :: Please Stop Harassing Me Benzrf
07:59:06 <benzrf> :^y
07:59:24 <osfameron> Benzrf?
07:59:36 <`Jake`> Oh, right, Lambdabot doesn't repeat the query like ghci does
07:59:55 <benzrf> > undefined :: Benzrf
07:59:56 <lambdabot>  No instance for (GHC.Show.Show L.Benzrf)
07:59:56 <lambdabot>    arising from a use of ‘M735970887647428859212865.show_M7359708876474288592...
08:00:07 <benzrf> i made a dumb joke :^D
08:00:14 <`Jake`> teehee
08:00:18 <osfameron> oh, hahaha, a) lambdabot capitalized the nick, and b) my brain didn't pattern match the capitalized version when scanning the nicks...
08:00:25 <fread2282> :i Please
08:00:55 <benzrf> fread2282: ldbot doesnt :i sadly
08:00:58 <bennofs> :k Please
08:01:00 <lambdabot> * -> * -> * -> * -> *
08:01:48 <`Jake`> What would :i's output be, anyway? Defined by benzrf at 14:55 UTC?
08:03:05 <benzrf> :3
08:05:47 <Black-Heaven> Maybe a simpler question, I have an error like: "Data constructor ‘Cons2’ cannot be GADT-like in its *kind* arguments
08:05:53 <Black-Heaven> "
08:06:24 <corgifex> how did you do that?
08:06:52 <Black-Heaven> http://bpaste.net/show/360681/ with this code http://bpaste.net/show/360680/ but I have done similare code and it doesn't fail
08:07:04 <Black-Heaven> have you got an idea where I'm wrong?
08:08:15 <`Jake`> tip: use lpaste next time, you'll be able to have everything in one link
08:08:19 * hackagebot scotty 0.8.0 - Haskell web framework inspired by Ruby's Sinatra, using WAI and Warp  http://hackage.haskell.org/package/scotty-0.8.0 (AndrewFarmer)
08:08:21 <`Jake`> @where lpaste
08:08:21 <lambdabot> http://lpaste.net/new/haskell
08:09:03 <Black-Heaven> `Jake`: ok, thanks
08:09:46 <Black-Heaven> (I'm lazy, I use wgetpaste)
08:10:12 <`Jake`> I see
08:23:21 * hackagebot wai-middleware-static 0.6.0 - WAI middleware that serves requests to static files.  http://hackage.haskell.org/package/wai-middleware-static-0.6.0 (AndrewFarmer)
08:25:11 <Black-Heaven> I think it's not a bug, but I haven't found any explanation :/ so, if you have one, I'm interested to know it, thanks by advance.
08:25:35 <f-a> Ok, I think I finally got Continuation Monad. Now, what are they useful for? (as in: somethin that can't be handled by other monads)
08:26:10 <klrr_> haskell cast :D
08:28:25 <rwbarton> Black-Heaven: why do you have that kind signature for HApL?
08:28:38 <rwbarton> Black-Heaven: the arguments to HApL should be lists of types
08:28:48 <rwbarton> as in concrete types, things of kind *
08:29:07 <rwbarton> in Cons2, a and b must have kind * because you form (a -> b)
08:29:33 <rwbarton> that means the Cons2 constructor can only produce HApL as bs where as, bs :: [*]
08:29:48 <rwbarton> in that sense Cons2 is GADT-like in the kind parameters of HApL
08:33:13 <frerich> Does anybody know whether quicksilver is still around sometimes?
08:33:16 <ski> f-a : advanced control effects, efficiency
08:33:54 <ski> frerich : "Last seen  : Apr 19 13:08:41 2014" apparently
08:36:46 <f-a> ski: I can see how using it for controls could be nice, but I can't imagine a situation where other haskell stuff (+ laziness) wouldn't cut it.
08:38:35 <ski> f-a : if you're already writing in CPS, then you may want to consider a continuation monad
08:38:46 <f-a> I see
08:38:47 <ski> f-a : also if you're writing in nqCPS
08:38:57 <f-a> thanks ski
08:39:01 <ski> (which happens now and then)
08:39:30 <ski> one can use continuations to implement a simple cooperative concurrency monads
08:39:36 <umib0zu> hey all. is there something like jsfiddle for haskell? an online editor and code runner to test some basic scripts?
08:39:48 <ski> one can use continuations to mix e.g. `IO' and backtracking
08:40:58 <{AS}> Hi, does anyone know when it is possible to validly derive a functor?
08:41:02 <f-a> couldn't I use Logic and IO for that, ski ?
08:41:12 <ski> f-a : sometimes, when you're generating some kind of data structure, you realize as you've already gotten a bit in that you'd want to insert an additional extra layer "a bit out" in the generated data structure. nqCPS can help doing this in a nice way
08:41:28 <benzrf> {AS}: i think theres an extn for that
08:41:31 <f-a> thanks thanks ski , much more clearer now
08:41:40 <{AS}> benzrf: Yeah :). I was just wondering the rules
08:41:40 <benzrf> for less interesting cases like trees
08:41:57 <ski> f-a : how do you think `LogicT' is implemented ?
08:41:59 <pjdelport> umib0zu: You can try https://www.fpcomplete.com/business/fp-haskell-center/
08:42:02 <pjdelport> It's an online IDE
08:42:56 <f-a> ohhhhhh, didn't know it ski :P
08:43:00 <ski> <https://hackage.haskell.org/package/logict-0.6.0.2/docs/src/Control-Monad-Logic.html> shows a standard two-level continuation approach
08:44:43 <ski> f-a : anyway, as i said, sometimes one can also use CPS for efficiency (a bit like using "difference lists" instead of appending lists, if you know what i mean)
09:02:05 <RedNifre> Hey there.
09:02:20 <RedNifre> Did anybode try Haskell on Android yet?
09:03:01 <chasecaleb> RedNifre: ooh. what now?
09:03:26 * hackagebot hourglass 0.2.1 - simple performant time related library  http://hackage.haskell.org/package/hourglass-0.2.1 (VincentHanquez)
09:04:26 <bennofs> Does cabal repl change PATH? :O
09:06:31 <RedNifre> chasecaleb Well, I started Haskell yesterday and it looks great. And I like Android, but judging from what I find on the web, running Haskell on Android is a bit hairy. Did you try it?
09:07:28 <chasecaleb> RedNifre: nope, but i never really looked into it past a quick app store search for giggles.
09:07:37 <chirpsalot> RedNifre: it's supposed to be pretty hairy.
09:07:53 <chasecaleb> if all else fails i'm sure you could install a chroot linux distro and run it like that, but... why?
09:08:20 <RedNifre> Oh no. I don't want to run or compile Haskell on Android. I want to write Android apps in Haskell.
09:09:06 <chasecaleb> RedNifre: ahh, i haven't really looked.
09:09:12 <RedNifre> Java is unpleasant, Ruby is fantastic, but too slow, Scala might be okay, but I don't know Scala, so I'm considering Haskell.
09:09:39 <chasecaleb> have you seen http://www.haskell.org/haskellwiki/Android ?
09:09:47 <osfameron> running haskell on a platform people have very little experience of running haskell on (android) doesn't seem immediately like the best beginner project, tbh
09:10:08 <osfameron> though I guess if you already know Android, that would be awesome
09:11:21 <RedNifre> Sure. It's just that I'm not really a PC person any more, the smartphone is my primary computer these days.
09:11:53 <Jello_Raptor> osfameron: on that same note I've been looking into haskell for some embedded tasks and I was wondering if there's any way to link haskell compiled with the LLVM backend with C code compiled with clang (too LLVM IR)
09:12:00 <RedNifre> But I'm only half through "Learn you a Haskell" anyways, so I'm not gonna write any serious apps any time soon.
09:12:04 <chasecaleb> there are some pretty good python wrappers for android that would let you avoid java and still use functional techniques.
09:13:21 <RedNifre> chasecaleb I know. I haven't looked at Python specifically, but Ruboto (JRuby on Android) is absolutely fantastic... except that your app takes 10 seconds to start and you can't start your app without installing RubotoCore from the Play Store first. (Same for Python, you need S4A or whatever it was called).
09:13:57 <RedNifre> Given that Haskell is compiled, a Haskell app might start fast enough and wouldn't require a special runtime app to be installed seperately, right?
09:14:00 <Jello_Raptor> RedNifre: i'm targeting an ARM backend myself, so if there's a good linking technique then it should be possible to use haskell for core application logic. (with a touch of C++ and Java for system interactions, and Java for UI and some IO)
09:14:14 <chasecaleb> RedNifre: i'm still half asleep and can't remember for sure, but i vaguely remember reading that you can bundle sl4a into your jar
09:14:57 <osfameron> https://play.google.com/store/apps/details?id=org.metasepi.ajhc.android.cube
09:15:20 <ski> RedNifre : languages aren't compiled
09:15:20 <RedNifre> Sounds interesting. But I don't plan on learning Python since I already know Ruby. Also, I'm busy learning Haskell and want to finish that before looking at another language.
09:16:22 <RedNifre> ski It makes me smile how much more corrections for imprecise language I get in this channel :)
09:17:58 <chasecaleb> this is where all the "wizards" hang out
09:18:45 <bennofs> RedNifre: finish learning haskell? that will never happen
09:19:42 <rwbarton> Android programming with GHC has been done, but it's painful for various reasons, and AFAIK no one has tried writing a large-scale app
09:20:04 <kuribas> Probably scala is easier for android?
09:20:37 <rwbarton> at the moment, certainly
09:20:57 <Jello_Raptor> kuribas: almost certainly
09:21:16 <klrr_> ReinH: its kinda hard to hear jekor in the podcast
09:21:27 <ski> RedNifre : well, i'm happy it's appreciated :)
09:23:29 * hackagebot hspec 1.10.0 - Behavior-Driven Development for Haskell  http://hackage.haskell.org/package/hspec-1.10.0 (SimonHengel)
09:24:22 <RedNifre> I don't know much about Scala, but I heard that it has a fair amount of functional programming available. If I learned more Haskell first and then only use the functional parts of Scala, could Scala then work as a "poor man's Haskell"? How close to Haskell can you get with Scala?
09:25:17 <piezoid> Archlinux ARM have ghc packages for armv7, if it helps, I've no tested it yet.
09:25:25 <YayMe> What is the name of that problem I find myself struggling with every so often where I'm trying to define a func that's a -> b, but I want b to be (b -> c) where c is more ? because I don't want to have to dictate the type of c until *after* a -> b is executed. Which is of course impossible, because I can't know what b is without knowing what b -> c is and thus what c is
09:25:26 <Church-> RedNifre, similar but not similar enough.
09:27:20 <YayMe> I run into this problem when I'm trying to define types to hold combinator compositions and such a lot, that for some reason I *want* to be able to define the end of the computation at the same time as the beginning... which can't be done in a way that allows the ending computation to be variant, and so I can't put a type on the output...
09:27:52 <YayMe> Frustrating problem, I should probably recognize it as something formal and well known so I can know how to reason about the problem, but I lack such training to do so. I just try to avoid the problem, not sure if that's the right approach.
09:28:18 <kuribas> I don't know so much scala, but it seems to be less pure, not lazy, and has a less advance type system.
09:28:41 <kuribas> But still a good bet for programming on android.
09:30:00 <RedNifre> Yeah, I guess Haskell is like Latin and Scala is like Spanish.
09:31:17 <albeit> I have a sum type like "MyObj = Foo Int String | Bar Int Int | Baz Int Bool". Is there any way to generically and extract the Int and the a (the second containted type)? Sort of a "func (_ k v)"?
09:31:19 <YayMe> Right now I'm trying to make a silly model about some actor stuff, but if an actor can only send messages, spawn actors, or decide how it's next behaviour will be, the last bit there makes me want to define actor as Actor a b = Actor (Msg a -> Actor b) but it needs the outputting actor to be like Actor b c so it knows the resulting computation of the next instance for the next message processor, but then I end up wi
09:31:19 <YayMe> th Actor a b c = Actor (Msg a -> Actor b c) which again has a type hole because to make the Actor b c I had to add a type parameter which is not missing
09:31:44 <yogurt_truck> kuribas: advanced or not, its type system is certainly a lot less useful as a tool for building correct software
09:31:59 <YayMe> I find myself continually bumping into trying to creat types like that which are impossible because they're predictive
09:32:07 <fread2282> will GHC specialize ![(UTCTime,a)] into the equivalent of data Foo a = Foo {-# UNPACK #-} !UTCTime a  in [Foo]?
09:33:14 <fread2282> YayMe: Actor a b = Actor (Msg a -> Actor a b)?
09:33:30 * hackagebot hspec-meta 1.10.0 - A version of Hspec which is used to test Hspec itself  http://hackage.haskell.org/package/hspec-meta-1.10.0 (SimonHengel)
09:33:57 <ski> YayMe : i haven't been following, but why not `newtype Actor a = MkActor (Msg a -> Actor a)' or `data Actor a b = Get (a -> Actor a b) | Put b (Actor a b)' or something like that ?
09:34:02 <YayMe> fread2282: it's not variant.
09:34:14 <anon_555> hi
09:34:23 <YayMe> ski: I don't know why not, I'll have to look at that and see if it solves this problem I constantly sumble into...
09:34:26 * ski stares hard at anon_555
09:34:34 <anon_555> http://lpaste.net/105404
09:34:41 <anon_555> any one here to fix this error
09:34:44 <YayMe> I know it's a general case problem because I've run into it working on multiple totally different types of things
09:34:46 <davnils> fread2282: -funbox-strict-fields
09:34:51 <anon_555> Problem002.hs:18:14: parse error on input `='
09:35:07 <kuribas> you forget let?
09:35:09 <ski>   let fibs = map fibonacci [0..4]
09:35:14 <rwbarton> fread2282, no it's wont. those are different
09:35:18 <ski>   mapM_ print fibs
09:35:35 <rwbarton> *it won't
09:35:49 <fread2282> rwbarton: rather with the first as [(!UTCTime,a)]
09:35:56 <fread2282> davnils: yes, but can I rely on it?
09:36:24 <rwbarton> fread2282: that would make some sense, but isn't legal
09:36:33 <anon_555> ski,  why i need to put let when i am using a file
09:36:38 <carter> johnw: theres no notion of a 128bit int on any cpu arch i'm aware of
09:36:45 <ski> anon_555 : no
09:36:46 <carter> johnw: thres a bigwords package
09:36:56 <piezoid> fread2282: no, only the head of the list is strict in ![UTCTime], but !UTCTime may be unpacked if you declare yout own list type
09:37:11 <ski> anon_555 : you need to use `let' if you want to bind variables to expressions in a `do' like that
09:37:11 <rwbarton> fread2282: the strictness annotation ! can only be applied directly to a field of a constructor, not arbitrarily nested inside a type
09:37:25 <piezoid> fread2282: you can't modify the data layout of [] unpacking something inside
09:37:28 <fread2282> right :(
09:37:45 <YayMe> ski: the tricky part I'm trying to model is the variance, this may not be doable so perhaps it's right that I've avoided it, but the variance goes like this: Actor takes an Int, sends a message to another actor with that int incremented, then returns a new Actor definition that takes a [Char] and returns a new actor definition that takes something else
09:38:33 <ski> YayMe : "Actor takes an Int" -- the type constructor or a possible data constructor ?
09:38:45 <YayMe> I think it's just simply not doable because the variance. I shouldn't be trying because the whole concept is based around runtime decisions which would be better done compile time...
09:39:15 <YayMe> ski: well type constructor because it's going to be variable....
09:39:20 <rwbarton> YayMe, sounds sort of like session types
09:39:43 <fread2282> YayMe: ActorF a m = (Msg m -> a)
09:39:52 <YayMe> though I guess I could create an indirection sum type that as a single type encapsulates the choices of input types...
09:40:38 <YayMe> rwbarton: ? elaborate?
09:41:12 <rwbarton> well, just google for articles about them
09:41:18 <YayMe> fread2282: that might work...
09:41:24 <rwbarton> I don't have a particular source in mind
09:41:24 <YayMe> rwbarton: Ok, thanks
09:41:30 <ski> YayMe : i would have expected the type constructor to take `Int', not *an* `Int'
09:42:01 <anon_555> ski,  thanks bro
09:42:03 <anon_555> sir
09:42:10 <ski> np
09:42:53 <fread2282> you should probably do Actor a m = (Msg m -> a) though
09:43:32 * hackagebot hspec-smallcheck 0.3.0 - SmallCheck support for the Hspec testing framework  http://hackage.haskell.org/package/hspec-smallcheck-0.3.0 (SimonHengel)
09:43:35 <ski> is `Msg' contravariant ?
09:43:36 <fread2282> what I just wrote that
09:43:37 <fread2282> nvm
09:43:59 <anon_555> ski where should i go to do more with haskell i just finished learn you a haskell for great good
09:44:07 <fread2282> you should probably do Actor m a = (Msg m -> a) though
09:44:07 <fread2282> there
09:47:16 <YayMe> fread2282: then something like mkActor f a = Msg (\x -> a) and composeActor :: ActorF a m1 -> (m2 -> c) -> ActorF a m2; composeActor (ActorF f) newF = ActorF f . newF
09:47:32 <YayMe> maybe...
09:47:46 <fread2282> has anyone done mmap-backed haskell allocation?
09:48:37 <benzrf> hmmmmmm
09:48:44 <YayMe> ski: right, type constructor would take Int but the initial actor will need to know at construction time what the next actor behaviour will be in that fashion, I want the variance that the initial state of an actor doesn't know what the next state of the actor will be
09:49:13 <YayMe> but again, that goes to runtime decision making I think which means I'm just approaching this wrong in my head...
09:49:26 <fread2282> YayMe: not sure... do you want the actors to be finite?
09:50:25 <ski> YayMe : i'm not quite sure what a "state of an actor" is in this context
09:51:00 <zomg> Coding world championships finals livestream just started if anyone is interested http://areena.yle.fi/tv/2295891
09:51:17 <zomg> I participated in the competition using Haskell but did not quite reach the top 8 :)
09:51:21 <anon_555> zomg thanks for dharing
09:51:33 <anon_555> zomg *sharing
09:51:42 <piezoid> YayMe: have you looked at continuation monads ?
09:52:18 <rwbarton> I kind of think you should not try to invent such abstractions, and just write things directly in terms of basic types, until you are far enough that either it is obvious to you what the appropriate abstraction is, or you obviously need to invent some abstraction to continue
09:52:36 <rwbarton> as we're not in either situation with respect to your code, it's hard to provide any useful feedback
09:55:00 <haasn> Hmm, it's still not possible to do anything useful with Symbol on the type level other than compare it to other Symbols, right?
09:55:24 <haasn> I really think there ought to be some way of pattern matching on Symbol like on String, so we can write stuff like PrintfType :: Symbol -> *
09:55:58 <haasn> And then we could actually go ahead and do printf (P :: P "%s world!") "hello"
10:08:15 <ReinH> woo new Haskell Cast
10:08:21 <bergmark> :OO
10:09:15 <willem> hello, i am using the sqlite-simple package and i am getting a strange error: "ConversionFailed {errSQLType = "FLOAT", errHaskellType = "Int", errMessage = "need an int"}". the attribute i am trying to retrieve from the database has been defined to be of "integer DEFAULT NULL" type, so i have annotated the "query_" function with the IO [[Maybe Int]] type signature. if i try to retrieve a different integer attribute,
10:09:16 <willem>  id, this strategy does work (defined as INTEGER DEFAULT NULL). i suspect that the problem may lie in the different letter cases...
10:10:03 <albeit> How can I do "type Foo = Map String a", where "a" must of typeclass "BarClass"?
10:11:03 <ski> albeit : `a' is unbound
10:11:20 <ski> perhaps you want to quantify, perhaps you want to parameterize
10:12:24 <albeit> Okay... if I want 'a' to be restricted to a typeclass, which would I want to do?
10:13:01 <monochrom> what is the name of the type class so I can use it in an example?
10:13:25 <albeit> monochrom: Let's call it "BarClass"
10:13:27 <dwcook> albeit: ski is hinting at that you might have meant either type Foo a = Map String a or type Foo = forall a. Map String a (in addition to the typeclass constraint)
10:13:35 * hackagebot haxl 0.1.0.0 - A Haskell library for efficient, concurrent,  and concise data access.  http://hackage.haskell.org/package/haxl-0.1.0.0 (SimonMarlow)
10:13:37 <monochrom> BarClass a => ...
10:13:37 * hackagebot haxl-facebook 0.1.0.0 - An example Haxl data source for accessing the  Facebook Graph API  http://hackage.haskell.org/package/haxl-facebook-0.1.0.0 (SimonMarlow)
10:13:58 <monochrom> however, trying to do it in a type synonym is futile
10:15:19 <jamie_h_> is there a way of defining multiple language extensions on 1 line? or do I need multiple {-# LANGUAGE foo #-} lines?
10:15:27 <dwcook> jamie_h_: separate by comma
10:15:32 <ski>   {-# LANGUAGE foo,bar #-}
10:15:34 <dwcook> {-# LANGUAGE Foo, Bar, Baz #-}
10:15:49 <jamie_h_> dwcook ski thanks!
10:15:55 <ReinH> ocharles: ping
10:16:02 <jamie_h_> running into this: http://stackoverflow.com/a/5941776/427992
10:17:56 <jfischoff> jamie_h: did you turn on those extensions?
10:22:26 <shapr> yay! https://code.facebook.com/projects/854888367872565/haxl/
10:23:33 <jfischoff> https://github.com/facebook/Haxl
10:23:50 <shapr> jfischoff: bah, so much easier
10:24:00 <jfischoff> heh
10:27:31 <solirc> FYI: We now have #scotty for scotty related discussions.
10:28:12 <albeit> How can I get a function like this to work? "func :: Bar a => IntMap a -> Int; func imap = (imap IntMap.! 5) :: Int", and Int implements the Bar typeclass.
10:28:56 <rwbarton> well, the type of your function is actually IntMap Int -> Int
10:29:34 <rwbarton> it can't take an IntMap X for any other type X, since it is supposed to return an Int
10:29:42 <rwbarton> Bar is irrelevant
10:30:17 <albeit> Hmm guess that example was bad. I need to extract different types from the IntMap, all of which implement Bar.
10:30:57 <jfischoff> different types is the problem
10:30:58 <albeit> If I have "f :: String -> Bool -> Foo", I want to call something like "f (imap ! 5) (imap ! 6)"
10:31:15 <albeit> Where imap :: Bar a => IntMap a
10:32:03 <albeit> Is that even possible?
10:32:29 <jfischoff> I’m not exactly sure what you are trying to do but …
10:32:56 <jfischoff> if you want to store a bunch of different types of something in a container, you don’t
10:33:00 <jfischoff> you make one type
10:33:03 <rwbarton> well, yes it is possible. I expect it's not what you wanted
10:33:13 <jfischoff> all the types can be converted into
10:33:20 <jfischoff> and out of
10:33:40 <jfischoff> The hammer in this case is something Data.Dynamic
10:33:52 <ski> albeit : seems like you either want a polymorphic map (unlikely), or you want different `Int' keys in the map to be associated with values of different types (determined by the key)
10:33:53 <jfischoff> unitype FTW!
10:34:16 <ski> albeit : if you have a fixed/closed set of possible types, you can use a sum type
10:34:24 <albeit> ski: Yes, the latter.
10:34:34 <rasfar> it looks like I picked a good time to have a generics question...
10:34:45 <ski> `Dynamic' might also be possible -- but is rarely what one wants
10:35:16 <albeit> I'm actually doing that now with a sum type, it's just becoming cumbersome, and I'm struggling to explain how/why
10:35:17 <ski> albeit : i think it ought to be possible to have a map where types of values are determined by keys -- but then the keys can't be `Int's, for sure
10:36:01 <albeit> jfischoff: What do you mean exactly by having one type that the other types can be converted into and out of?
10:36:11 <jfischoff> basically a sum type
10:36:21 <jfischoff> or the Typeable version of it
10:36:26 <jfischoff> Dynamic
10:36:43 <albeit> jfischoff: Of the form "Foo = Int | String | Text ..." or somethign like "Foo = FooInt Int | FooString String | FooText Text"?
10:37:06 <jfischoff> yes pretty much, if you know in advance the types
10:37:23 <rwbarton> there's also the so-called existential typeclass antipattern
10:37:36 <rasfar> how does one do a tree-to-tree generic map that changes the type?
10:38:01 <rasfar> say to just get the skeleton of the tree (or some projection on the node types)?
10:38:16 <bergmark> rasfar: you can use uniplate for this
10:38:20 <rasfar> i'm having a heck of a time; hope i'm not barging in here
10:38:23 <albeit> jfischoff: I know the types in advanced... in the two examples, what kind of sum type should I be using?
10:38:44 <rasfar> bergmark: are you sure? it seems like the type of the transformation is always alpha -> alpha
10:38:46 <ReinH> rasfar: changes the type but preserves the structure of the tree?
10:38:56 <rasfar> ReinH: exactly
10:39:00 <ReinH> fmap
10:39:05 <rasfar> (GHC AST in particular)
10:39:58 <rasfar> fmap ... um, really? I can do that without generics then, if certain instances are defined for the tree?
10:40:06 <rasfar> Traversable?
10:40:07 <bergmark> rasfar: i don't understand, what type do you want this function to have?
10:40:11 <ReinH> If it's a Functor, yes
10:40:11 <jfischoff> albeit: I didn’t really look at your code, but my guess is you would have a type that wraps the other types and is also an instance of Bar
10:40:43 <jfischoff> ReinH: its going to be monomorphic in the node type I bet
10:40:51 <albeit> jfischoff: Sorry, no code. By wrap do you mean "Foo = FooString String | FooInt Int" or "Foo = String | Int"?
10:40:59 <rasfar> bergmark: Let's say I want to wrap each node of a GHC parse tree in a "supernode" with additional fields
10:41:00 <bergmark> uniplate lets you do `foo :: (Int -> Int) -> Tree -> Tree' for instance
10:41:03 <ski> albeit : the former
10:41:05 <jfischoff> well the first one, yes
10:41:09 <ski> albeit : and you need `data'
10:41:30 <ReinH> rasfar: what's the type of the GHC tree?
10:41:39 <jfischoff> yes what ski said
10:41:40 <rasfar> bergmark: but that "Tree" has to be the same, no?
10:41:44 <ski> albeit : `data Foo = String | Int' would just be a new type `Foo' with two constructors (taking no arguments), unrelated to the types `String' and `Int'
10:42:03 <jfischoff> rasfar: those were closing ticks
10:42:03 <rasfar> ReinH: HsModule or so?
10:42:11 <bergmark> rasfar: ok, then the tree needs to have a polymorphic node
10:42:14 <jfischoff> the tree is the same
10:42:28 <ReinH> rasfar: Can you be more specific?
10:42:38 <rasfar> my target tree does indeed have a polymorphic node; but the GHC parse tree doesn't (there's numerous data types)
10:42:55 <jamie_h_> is there a way to convert an instance into another instance type if they have the same type class?
10:42:56 <ReinH> If the tree isn't polymorphic in its nodes then you can't fmap it and you can't, in any event, change the type of the node
10:43:31 <albeit> Ahh, okay so I have the "Foo = FooString String | FooInt Int" structure now, but I'm implemented my Bar class on Int and String... and I should be doing it on Foo, yeah?
10:43:36 <ReinH> jamie_h_: not generally
10:43:53 <rasfar> ReinH: I basically just want to project the tree structure and discard all the data, so I can apply structural analysis without worrying about generics etc. that the complicated GHC AST would entail.
10:43:57 <bergmark> if you want to map that tree to your own data type, like `foo :: (Int -> Wrapped Int) -> Tree -> MyTree' then I think uniplate solves your problem again
10:44:19 <klrr_> anyone got any ghci config at hand or know any tutorial how to use it more sanely than importing essential stuff like Control.Monad, Applicative, monoid etc. manually?
10:44:23 <jfischoff> jamie_h: only if the typeclass they are both members of provides that capability, usually through a canonical type
10:44:35 <rasfar> bergmark: I do hope so... I didn't see how (and Biplate is for multiple type parameters, I thought maybe it was what I wanted but no.)
10:44:52 <jfischoff> albeit: sounds reasonable
10:45:17 <albeit> I guess the issue is if I have an IntMap Foo, and a function "f :: Int -> String -> Blah", I need to extract the two parameters from the IntMap manually... like "FooString s = imap ! 5; FooString n = imap ! 6; blah = f s n"
10:45:20 <rasfar> I'd be willing to go Tree -> List -> MyTree if necessary
10:45:33 <albeit> And I was hoping to sort of generically get the values from the intmap to plug in to the function.
10:45:36 <rasfar> (heck it would probably fuse away, right? :)
10:45:44 <albeit> Because there could be a lot of values to extract from the intmap
10:46:42 <bergmark> albeit: what's List?
10:46:45 <jophish> Is there a unicode operator for infix fmap?
10:46:51 <jophish> a shorthand for <$>
10:47:17 <albeit> bergmark -> rasfar: what's List?
10:47:18 <rasfar> bergmark: was that question directed at me?
10:47:22 <jfischoff> albeit: I think you can use some helper functions to make that easier, but yes it is going to be some what annoying
10:47:24 <geekosaur> not "standard" but nothing stops you from picking a symbol character and defining one
10:47:33 <geekosaur> jophish ^^
10:47:51 <bergmark> albeit, rasfar: oh sorry, yes
10:47:53 <jophish> geekosaur: probably best to stick with <$> then
10:47:55 <rasfar> bergmark: well, just there are some generic functions one comes across which flatten trees etc.
10:48:13 <jophish> geekosaur: or perhaps ☃
10:48:17 <rasfar> maybe it would be easier to go through that intermediate, don't know...
10:48:34 <jophish> Nothing says 'fmap' like a snowman wearing a fez
10:48:44 <bergmark> rasfar: i can't picture it completely, so i can't say for sure that uniplate will help
10:48:46 <rasfar> those functions mostly throw away the structure and give the data; I need the opposite.
10:49:05 <rasfar> but then there's serialisation/deserialisation which preserves structure
10:49:20 <jfischoff> bergmark: uniplate tends to not work in GHC code, because of all the undefines in the ASTs
10:49:33 <jfischoff> they add them initially and later fill them in
10:50:13 <rasfar> (I should not have said "wrap in supernode", since then the type complexity stays; the "projection to bare tree skeleton" is more to the purpose.)
10:50:17 <geekosaur> u+229a?
10:51:20 <rasfar> it seems like such a fundamental thing to do, I'm surprised I've had some trouble finding examples.
10:51:25 <chrisdone> bitemyapp: hey
10:51:27 <jophish> geekosaur: that makes me think of 'join'
10:51:59 <chrisdone> jfischoff: i had this problem when trying to use the ghc api for structured-haskell-mode. it's full of landmines of error "no type info yet"
10:52:27 * jfischoff nods
10:52:49 <bergmark> everybody stop what you are doing: https://twitter.com/simonmar/status/476410598818054144
10:53:09 <ReinH> OMG
10:53:12 <ReinH> Awesome
10:53:16 <chrisdone> oh neato!
10:53:17 <klrr_> lol
10:53:25 <klrr_> someone posted that earlier but to the actual project
10:53:28 <klrr_> ;P
10:53:31 <Church-> Nice.
10:54:00 <chrisdone> the first official open source facebook-backed haskell library?
10:54:03 <bergmark> i got all teary eyed at the zurihac update-talk this weekend
10:54:40 <klrr_> https://code.facebook.com/projects/854888367872565/haxl/
10:56:00 <chrisdone> it also has a cool logo
10:56:17 <rasfar> bergmark, ReinH, jfischoff: thanks for your comments
10:56:19 <bergmark> this is the truth
10:56:24 <bergmark> rasfar: np!
10:57:13 <rasfar> so just one last time: anyone, how you'd use generics to project a complicated mutually-recursive parse tree to a simple Rose tree, to just obtain the strucutre?
10:57:14 <bergmark> now i need to rewrite our entire stack with extensible-effects+haxl+opaleye
10:57:51 <jcullen> Hey guys. I'm about to begin my quest to learn about lenses, and I'm curious if there is a consensus on the best lens library and most up to date resources to learn from.
10:57:55 <jcullen> Could anyone point me in the right direction?
10:58:02 <albeit> jfischoff: Thanks for the help, think I got it figured out
10:58:04 <bergmark> jcullen: fclabels ;-)
10:58:10 <jfischoff> albeit: np
10:59:24 <jcullen> bergmark: thanks for the suggestion.  why do you prefer that over lens? out of curiousity
10:59:35 <rasfar> I thought maybe I could carry state which I could use to rebuild some simpler tree after traversing. But I'm puzzled how to encode strucutral info in the State...
10:59:36 <bergmark> jcullen: my coworkers wrote it so i have no choice
10:59:37 <chrisdone> jcullen: it depends on what you want to learn. if just basic lenses, check out data-lens. it's simple and clean: http://hackage.haskell.org/package/data-lens-2.10.5/docs/Data-Lens-Common.html
11:00:16 <bergmark> but i think fclabels can be a good starting point, and then if you feel the need for the big guns you can check out lens
11:00:24 <jfischoff> I would say the this the most beginner friendly intro to lenses: http://www.haskellforall.com/2012/01/haskell-for-mainstream-programmers_28.html
11:00:26 <chrisdone> also see:
11:00:26 <chrisdone> http://twanvl.nl/blog/haskell/overloading-functional-references
11:00:26 <chrisdone> http://twanvl.nl/blog/haskell/cps-functional-references
11:00:41 <chrisdone> they used to be called functional references, but now are almost unanimously called lenses
11:01:05 <rasfar> can lenses do homomorphism of trees? ...
11:01:15 <jcullen> cool
11:01:23 <klrr_> yeah van hoveen posts was what made it click for me, i also suggest explicitly and manually evaluting some basic lens operation it makes it easy to see how it works
11:01:32 <chrisdone> the CPS-based ones are what the 'lens' package uses
11:01:42 <chrisdone> the overloading ones are what data-lens uses
11:01:54 <jcullen> I see
11:01:57 <jcullen> thanks for the resources
11:02:20 <jcullen> I'm also interested in the theory, so lens seems like it might be worth looking at
11:02:26 <jcullen> but I'll check out the suggested others first
11:02:29 <chrisdone> fclabels is (was) simple like data-lens although it's got some weird stuff like the 'lens' package now
11:02:51 <jamie_h_> is it a bad idea to have Maybe a as an input arg?
11:03:15 <Zekka> jamie_h_: Do you do anything unusual if the input is Nothing?
11:03:24 <chrisdone> jcullen: actually the theory for 'lens' is from there. the 'lens' package uses so-called “van Laarhoven lenses”, so the inventor is a good source =)
11:03:30 <Zekka> (that is, other than returning a default value or propagating the Nothing?)
11:03:39 <jamie_h_> Zekka yeah I want to handle Nothing and Just a differently. But when I try Just a in pattern matches it complains
11:03:53 <benzrf> jamie_h_: what do you do if its nothing
11:03:59 <rasfar> jamie_h_: it's done in Data.Map.alter so you have a good precedent there
11:04:31 <jamie_h_> benzrf return Nothing
11:04:35 <rasfar> jamie_h_: you probably need parentheses around that: (Just a)
11:04:58 <chrisdone> if you return nothing if an arg is nothing you might as well just take 'a' and live in the maybe monad =)
11:05:07 <chrisdone> oops, i said 'the maybe monad'
11:05:10 <chrisdone> @slap chrisdone
11:05:10 * lambdabot slaps chrisdone with a slab of concrete
11:05:13 <Zekka> Ditto on chrisdone's suggestion -- I'll be back in a bit
11:05:44 <Zekka> also it doesn't even sound to me like you need the maybe monad -- it sounds to me like you need a pure function unless you occasionally return Nothing in the Just branch
11:05:45 <jcullen> chrisdone: cool, thanks again.  Looks like I've got alot of reading to do
11:06:03 <jcullen> Always suprised by how excellent this irc channel is.
11:06:17 <benzrf> chrisdone: perhaps yo~u mean Functor
11:06:26 <benzrf> jamie_h_: just define it over a and use fmap
11:07:08 <bergmark> chrisdone: \o/ https://github.com/silkapp/rest/pull/11 this is the first step to automatically generate fay clients for our rest framework, then we will win in type safety
11:07:48 <chrisdone> see also http://www.cis.upenn.edu/~bcpierce/papers/lenses.pdf
11:08:13 <Zekka> jcullen: Basically a functor lets you say "I have a Maybe a, and a function a -> b. Can you apply that and give me a Maybe b?"
11:08:19 <Zekka> More succinctly, it says this
11:08:21 <Zekka> :t fmap
11:08:22 <lambdabot> Functor f => (a -> b) -> f a -> f b
11:08:28 <ReinH> Also SPJ did a nice video lecture on lenses recently
11:08:40 <Zekka> where f is Maybe, [], Either a, etc.
11:08:52 <ReinH> Zekka: it also says some things about laws
11:08:55 <Denommus> can >>= be defined in terms of >=>?
11:09:03 <Zekka> ReinH: Yeah, that's true too
11:09:25 <ReinH> Well, *it* doesn't. It expects you to though.
11:09:35 <ReinH> Well, *it* doesn't... anyway...
11:09:45 <chrisdone> bergmark: nice =)
11:09:50 <ReinH> I really should stop anthropomorphising my languages.
11:09:51 <jcullen> Zekka: Think you pinged the wrong person fyi
11:09:54 <Zekka> The laws seem pretty intuitive to me although it's probably good practice to spell themout
11:09:56 <ReinH> They hate it when I do that.
11:09:58 <Zekka> jcullen: Oh, sorry about that
11:10:05 <jcullen> :) np
11:10:07 <Zekka> jamie_h_: pretend I pinged you for the above
11:10:18 <Zekka> Denommus: One sec, I'll try to and see if I run into trouble
11:10:21 <Zekka> intuitively I think it should be possible
11:10:29 <jamie_h_> Zekka you were right, was a parentheses issue :)
11:10:38 <ReinH> :t (>>=)
11:10:39 <lambdabot> Monad m => m a -> (a -> m b) -> m b
11:10:41 <ReinH> :t (>=>)
11:10:42 <lambdabot> Monad m => (a -> m b) -> (b -> m c) -> a -> m c
11:11:00 <benzrf> Denommus: i think so
11:11:23 <Denommus> it's >=> that makes the monad a monoid, right?
11:11:28 <ReinH> :t (>=>) return
11:11:29 <lambdabot> Monad m => (b -> m c) -> b -> m c
11:11:32 <ReinH> Denommus: no
11:11:43 <ReinH> Denommus: >=> makes it a Kleisli category
11:11:45 <benzrf> :t return . (>=>)
11:11:46 <lambdabot> (Monad m1, Monad m) => (a -> m1 b) -> m ((b -> m1 c) -> a -> m1 c)
11:11:48 <Zekka> Monads are a monoid under >=> and return, though, correct?
11:11:54 <pjdelport> :t flip (>=> return)
11:11:55 <lambdabot> Monad m => b -> (b -> m c) -> m c
11:11:58 <Denommus> ReinH: why is a monad a monoid, then?
11:11:58 <ReinH> pjdelport: yep
11:12:02 <shachaf> Zekka: Well, not just one monoid but lots of different ones.
11:12:05 <benzrf> pjdelport: thats just id
11:12:07 <ReinH> Denommus: it is a monoid in the category of endofunctors
11:12:14 <ReinH> :t join
11:12:15 <lambdabot> Monad m => m (m a) -> m a
11:12:15 <bergmark> :t [(=<<), (id >=>)]
11:12:17 <lambdabot> Monad m => [(a -> m b) -> m a -> m b]
11:12:22 <Denommus> ReinH: yes, I know, but what makes it a monoid?
11:12:29 <shachaf> (Int -> m Int) is a monoid with (return :: Int -> m Int) as the identity and (<=<) as composition.
11:12:35 <shachaf> Similarly for (Char -> m Char).
11:12:54 <Zekka> Yeah, I was terminologically clumsy -- shachaf's description is more accurate
11:13:01 <pjdelport> :t flip (id >=>)
11:13:02 <lambdabot> Monad m => m b -> (b -> m c) -> m c
11:13:09 <ReinH> Denommus: Because join is a monoidal product of endofunctors
11:13:17 <Zekka> pjdelport: That looks right
11:13:28 <benzrf> in a category of endofunctors
11:13:29 <Denommus> ReinH: what is the neutral element of join?
11:13:33 <benzrf> are morphisms nat trans?
11:13:34 <ReinH> Denommus: return
11:13:52 <shachaf> I feel like using lots of new complicated words doesn't clarify much.
11:14:01 <Denommus> ReinH: but... in a monoid, shouldn't the operation be binary? Isn't join unary?
11:14:10 <Hodapp> it clarifies enough to get me a job.
11:14:11 * Hodapp smirks
11:14:13 <rasfar> ReinH, bergmark: I think what I'm looking for is called "gmap" : http://www.haskell.org/pipermail/haskell-cafe/2014-January/111995.html
11:14:24 * chrisdone admits the first implementation he thought of was: x >>= y = (const x >=> y) ()
11:14:34 <shachaf> join = id >=> id
11:14:53 <shachaf> Denommus: It's a "monoid" in a non-obvious way, since the definition of a monoid in a category is more general than the usual one.
11:14:57 <rasfar> just in time by the looks of it (2014)
11:15:06 <Zekka> chrisdone: My first thought was along those lines but it didn't typecheck
11:15:10 <shachaf> Denommus: It's a "binary operation" because join :: (m . m) a -> m a
11:15:17 <Zekka> actually, wait
11:15:22 <Zekka> yes it does, what am I talking about
11:16:01 <ReinH> shachaf: which new complicated words are you objecting to?
11:16:03 <gregnwosu> what do people feel about haxl
11:16:12 <gregnwosu> i suppose this has been discussed already
11:16:18 <bergmark> gregnwosu: fuzzy things!
11:16:37 <gregnwosu> bergmark: que?
11:16:41 <rasfar> so if gmap works out, i'll be sure to let y'all know.... bye
11:17:42 <bergmark> gregnwosu: i'm definitely going to try to use it
11:18:32 <bitemyapp> chrisdone: yis?
11:18:43 * hackagebot buildwrapper 0.8.5 - A library and an executable that provide an easy API for a Haskell IDE  http://hackage.haskell.org/package/buildwrapper-0.8.5 (JeanPhilippeMoresmau)
11:20:22 <gregnwosu> ill give it a spin tonight
11:20:24 <Phyx-> Is there a documentation somewhere for the new hackage? specifically.. how do you provide a changelog?
11:20:52 <gregnwosu> oh does anyone know of a good guide to setting up emacs with haskell
11:21:12 <bitemyapp> gregnwosu: https://github.com/bitemyapp/learnhaskell#emacs
11:21:45 <klrr_> gregnwosu: use structured-haskell-mode, its awesome
11:22:21 <ReinH> gregnwosu: check out chrisdone's emacs config
11:22:33 <osfameron> gregnwosu: oo, didn't know facebook did haskell
11:22:57 <gregnwosu> yes theyve been doing it for a while , until now i didnt know what they used it for
11:22:58 <ReinH> osfameron: yep, in a pretty big way now too
11:23:13 <Zekka> osfameron: For a shop with a PHP frontend they've apparently got a ton of Haskell and ML-family programmers internally
11:23:38 <jfischoff> a ton really?
11:23:43 * hackagebot sandi 0.3.0.1 - Data encoding library  http://hackage.haskell.org/package/sandi-0.3.0.1 (MagnusTherning)
11:23:51 <jfischoff> outsides of bos’s team?
11:23:59 <ReinH> Maybe just bos's team
11:24:01 <cloudhead> do I gain anything from using pipes with UDP? Seeing as it's message-based
11:24:08 <bitemyapp> ReinH: eh, bos' team is separate
11:24:11 <bitemyapp> ReinH: bos' team uses OCaml.
11:24:17 <ReinH> bitemyapp: ?
11:24:21 <Zekka> jfischoff: This is me speaking as an outsider, but from what I hear OCaml and Haskell are two of the preferred languages to start new projects in internally
11:24:21 <bitemyapp> ReinH: Haxl was separate of Hack.
11:24:24 <gregnwosu> yes the infamous Simon Marlow works for them
11:24:27 <ReinH> Uh. No they don't.
11:24:27 <bitemyapp> Hack is OCaml, Haxl is Haskell.
11:24:30 <jfischoff> bitemyapp: bos is also simons manager
11:24:35 <bitemyapp> jfischoff: oh? TIL
11:24:35 <gregnwosu> he wrote Concurrent Programming in Haskell
11:24:41 <ReinH> bitemyapp: bos is Simon's manager
11:24:47 <gregnwosu> or something similiarly titled
11:24:48 <bitemyapp> jfischoff: I wonder why he told me his team was all OCaml then, he must've meant Hack only.
11:24:51 <jfischoff> bos has a large number of direct reports, 20 or so
11:24:51 <ReinH> bitemyapp: They might do both
11:25:03 <jfischoff> yes Hack is ocaml
11:25:03 <chrisdone> bitemyapp: did you try it?
11:25:13 <bitemyapp> chrisdone: no, sorry - working on a cheat sheet.
11:25:22 <gregnwosu> im going to hack some haxl tonight
11:25:40 <ReinH> I talked to Simon about Haskell at Facebook, remember? ;)
11:25:43 <gregnwosu> i wonder if its worth uploading to hackage so we can get some cabal goodness
11:25:51 <bitemyapp> chrisdone: not a lot of time or mental energy to sharpen the saw lately. This weekend is a better bet.
11:26:03 <bitemyapp> chrisdone: I have the function you highlighted bookmarked.
11:26:15 <chrisdone> neat
11:26:36 * chrisdone pops up like Rumpelstiltskin demanding success stories
11:26:39 <bitemyapp> chrisdone: http://jafingerhut.github.io/cheatsheet-clj-1.3/cheatsheet-tiptip-cdocs-summary.html want to clone this but for Haskell.
11:29:40 <klrr_> is it considered good haskell style to write do's like this: https://gist.github.com/klrr/f717b28d34c93ff633a2
11:30:33 <Zekka> klrr_: Speaking personally, it wouldn't piss me off
11:30:46 <gregnwosu> ok cheery bye people
11:30:52 <gregnwosu> thanks for the answers
11:31:04 <klrr_> it just feels right with shm, but usually indent two spaces next line
11:31:07 <Zekka> I tend to start on the next line though and indent two spaces for each indentation level, but I think a lot of Haskeller codes prever to indent their code much more like Lisp
11:31:12 <Zekka> prefer*
11:31:20 <Zekka> Haskell coders*
11:31:26 <Zekka> I cannot talk at all apparently
11:32:15 <Phyx-> Hi, does anyone know how the changelog feature on hackage works?
11:32:59 <bergmark> Phyx-: add CHANGELOG or CHANGELOG.md (or other names i don't know) as extra-source-files
11:33:29 <Phyx-> bergmark: ah thanks! so it supports markdown then?
11:33:32 <supki> Phyx-: https://github.com/haskell/hackage-server/blob/master/Distribution/Server/Packages/ChangeLog.hs
11:33:37 <bergmark> Phyx-: it doesn't render markdown
11:34:04 <bergmark> http://hackage.haskell.org/package/fay-0.20.0.4/changelog
11:34:15 <bergmark> but hopefully it will at some point
11:34:25 <Phyx-> ah thanks bergmark, supki
11:34:57 <bergmark> i'd like to be able to give a url instead
11:35:15 <bergmark> that way you can edit it if you miss something
11:35:26 <chrisdone> bitemyapp: that'll be nea
11:35:27 <chrisdone> neat
11:36:14 <Phyx-> ah, i see, it doesn't display it inline
11:36:16 <ReinH> klrr_: I think your parens definition is wrong btw ;)
11:37:52 <Phyx-> I also wonder if there isn't a better way to display dependencies... it gets quite hard to follow hehe
11:39:00 <bergmark> Phyx-: especially conditionals ;-(
11:39:49 <Phyx-> bergmark: yeah :(
11:40:26 <bergmark> i don't think either of these is a hard project
11:41:28 <Phyx-> probably not, but it's most likely not a priority for now hehe
11:41:43 <bergmark> well, *hint* *hint* :-)
11:42:12 <`Jake`> When I write a file without main method, to be used in ghci, is it appropriate to call it script instead of program?
11:42:42 <`Jake`> Or, more generally, which is the preferred term in this situation?
11:42:48 <ninedotnine> 'module' might be a better term, if it actually is one
11:42:56 <`Jake`> ninedotnine: So far, it isn't
11:42:57 <bergmark> isn't that just a library `Jake`?
11:43:20 <ninedotnine> aside, haskell has a main function, not a main method
11:43:26 <bergmark> does it matter that it runs in ghci?
11:43:29 <Phyx-> hahah, bergmark I think I have way to little free time for that atm :) which is what everyone probably says hhe
11:43:32 <`Jake`> oops, too much java lately
11:43:38 <ninedotnine> i guessed so ;)
11:44:08 <`Jake`> bergmark: I don't know
11:44:23 <ninedotnine> library is good
11:44:36 <chrisdone> bitemyapp: i want to use the "what i wish i knew when learning haskell" article to improve haskell-lang. like, rather than linking to the cabal user guide, perhaps it should simply as par for the course explain how to use cabal
11:44:44 <rwbarton> technically it is a module even if you don't write "module M where"
11:44:46 <ninedotnine> but even better would be to make it a module and call it that
11:44:48 <`Jake`> It also contains problem-specific information though, which isn't exactly normal for a library, is it?
11:45:07 <`Jake`> ninedotnine: I'll do that
11:45:11 <`Jake`> thanks
11:45:19 <bergmark> `Jake`: i thought all libraries were problem specific :-)
11:45:21 <chrisdone> a file to be loaded in ghci is just a file, or amodule =)
11:45:29 <ninedotnine> sure thing :}
11:45:42 <`Jake`> bergmark: They are for a set of similar problems, but not for one specific problem
11:45:56 <bitemyapp> chrisdone: My next goal video-wise is a Cabal tutorial explaining how to use it and how ghc-pkg etc. works.
11:46:04 <bitemyapp> chrisdone: I was thinking of doing a companion text article.
11:46:23 <bitemyapp> chrisdone: I am *not* doing what jfischoff suggested for free. Way too laborious.
11:46:31 <bergmark> bitemyapp: that's cool, there are a lot of small tricks that are hard to learn
11:47:01 <bitemyapp> bergmark: it'd also be an insanely boring and not easily indexable video.
11:47:16 <bitemyapp> bergmark: people are going to encounter problems with Cabal and google them, they will want direct textual answers for their questions.
11:47:26 <chrisdone> bitemyapp: yeah, that's good. maybe i can crimp your article =p
11:47:27 <bergmark> heh
11:48:04 <bitemyapp> chrisdone: we'll see. I want the cheat sheet done first.
11:48:47 <bergmark> bitemyapp: if you want someone to review it, lemme know!
11:49:50 * shapr boings quietly
11:50:14 <bitemyapp> bergmark: thanks, it'll definitely need fact-checking at a minimum as I am no expert.
11:51:42 <Phyx-> lol.. so ghc no longer provides standalone windows installers? :p but a tar.bz2?
11:52:06 <chrisdone> windows users stand alone already
11:52:08 * chrisdone budum tish
11:52:31 <Zekka> Don't you have to compile from source anyway on posix?
11:52:41 * Phyx- gives a golf clap 
11:52:43 <Phyx-> lol
11:53:04 <klrr_> Zekka: i think their are fairly universal binaries iirc
11:53:11 <klrr_> there
11:53:19 <klrr_> !slap klrr_
11:53:26 <klrr_> ²slap klrr_
11:53:30 <klrr_> meh
11:53:30 <chrisdone> on posix i just get a binary
11:53:36 <Zekka> Really? Nobody told me the last time I recompiled it from source
11:53:45 <Phyx-> I've been having trouble compiling the latest version, but I just wanted to see if there's a bug in 7.6.2 or if it's my code :P
11:53:47 <Zekka> (oh well, it's a while in the past)
11:54:05 <chrisdone> zekka: http://haskell-lang.org/downloads/linux
11:54:32 <Phyx-> from source configure has been bombing out with "config.status: error: cannot find input file: `libraries/prologue.txt.in'"
11:54:48 <Zekka> chrisdone: That webpage doesn't load for me
11:54:59 <chrisdone> zekka: orly
11:55:06 <Zekka> Except now it apparently does
11:55:10 <Zekka> strange
11:55:15 <bitemyapp> chrisdone: I really do not like platform.
11:55:22 <Zekka> This is just the platform, isn't it?
11:55:29 <bitemyapp> Zekka: I have an alternate suggestion.
11:55:33 <chrisdone> scroll down!
11:55:40 <klrr_> i just install ghc happy and alex and cabal and oyu are ready to go
11:55:45 <bitemyapp> chrisdone: you uh
11:55:47 <chrisdone> the page suggests both ways
11:55:49 <bitemyapp> chrisdone: please look at this: https://github.com/bitemyapp/learnhaskell#getting-started
11:55:54 <klrr_> then i install cabal with cabal and remove cabal
11:55:58 <bitemyapp> chrisdone: the advanced install is mostly unnecessary.
11:55:58 <Zekka> https://www.haskell.org/ghc/download_ghc_7_8_2 <- oh, right, found it
11:56:03 <bitemyapp> Zekka: hold on
11:56:06 <bitemyapp> Zekka: what distro are you using?
11:56:13 <bitemyapp> Zekka: or OS
11:56:14 <chrisdone> as i never personally use the platform, i install a binary from ghc's page
11:56:15 <Zekka> bitemyapp: Ubuntu (12.04)
11:56:20 <bitemyapp> Zekka: use my guide then: https://github.com/bitemyapp/learnhaskell#getting-started
11:56:39 <bitemyapp> chrisdone: which is why I want you to not recommend platform, no offense - but it's hypocritical.
11:56:42 <chrisdone> bitemyapp: oh nice ppa, let me add that
11:56:45 <Zekka> I actually hve ghc installed already but that looks really low-hassle
11:56:50 <bitemyapp> chrisdone: many experienced Haskell users don't use Platform *for a reason*
11:56:52 <chrisdone> bitemyapp: i wouldn't say it's hypocritical
11:56:57 <Zekka> bitemyapp: Not-platform was actually on that page
11:57:10 <bitemyapp> chrisdone: well, my reason for not using it are highly sympathetic to the needs of beginners.
11:57:14 <benzrf> whats wrong with the platform :_(
11:57:16 <bitemyapp> chrisdone: maybe you have different ones.
11:57:23 <bitemyapp> benzrf: napping can explain my stance.
11:57:26 <chrisdone> i don't use the platform because the manual steps to setup ghc and cabal are ritual for me now
11:57:42 <Phyx-> klrr_: same
11:57:43 <bitemyapp> chrisdone: also bindist doesn't install a bunch of packages that'll break your builds into the global package-db.
11:57:44 <chrisdone> when i was a newbie not sure if i even like this language i would've appreciated a quick installer
11:57:51 <Phyx-> klrr_: I don't like to install platform either hehe
11:57:58 <Zekka> The platform was probably a significant part ofw hy I stuck with Haskell
11:58:00 <bitemyapp> chrisdone: that's why my guide points them to auto-installers-that-are-not-Platform by default.
11:58:09 <bitemyapp> chrisdone: falling back to bindist manual install only when necessary.
11:58:17 <Zekka> "you've got to try this language here recompile this code from source" doesn't appeal to me
11:58:21 <chrisdone> bitemyapp: so does that come with cabal?
11:58:23 <Zekka> even though I don't use Platform any more
11:58:25 <bitemyapp> Zekka: you don't need to compile anything.
11:58:43 <bitemyapp> chrisdone: hvr's PPA has GHC and Cabal, installs to /opt/$VERSION/ so it supports multiple simultaneous versions.
11:58:47 <Phyx-> even if you do, the only package that would be any issue is network
11:58:54 <Zekka> bitemyapp: Yeah, sorry, you're right
11:58:54 <bitemyapp> chrisdone: the Mac OS X .app also supports multiple versions and comes with Cabal.
11:58:55 <Phyx-> the rest should be fairly straigh forward
11:59:05 <bitemyapp> Zekka: just follow the guide.
11:59:07 <chrisdone> hm, nice
11:59:33 <bitemyapp> chrisdone: I spent way too much time fixing broken installs and builds when I started teaching, I don't want people to keep tripping into that nonsense. It's unnecessary pain.
11:59:48 <bitemyapp> bindist / PPA / .app + sandboxes -> you'll be okay
11:59:59 <Zekka> bitemyapp: obligated to mention, I already have it working even though I apparently took the path of greatest resistance and keep unintentionally assuming that's the path everyone hast to take
12:00:02 <S11001001> I love compiling language impls
12:00:07 <bitemyapp> chrisdone: please steal flagrantly from my guide for haskell-lang.
12:00:16 <chrisdone> bitemyapp: way ahead of ya =p
12:00:17 <Zekka> the ppa you suggested looks like a much-improved install process
12:00:19 <bitemyapp> Zekka: ask/verify often!
12:00:27 * chrisdone steals with abandon
12:00:29 <bitemyapp> Zekka: always check if something seems painful if it's necessary.
12:00:38 <Zekka> (In fact, I might finally update to ghc7.8 using it today)
12:01:24 <chrisdone> bitemyapp: there's also the fact that your way recommends a ghc version from this year
12:01:26 <Zekka> (although I'm a little reluctant because some of my old projects fail to build with 7.8 and the prospect of opening that can of worms is a little discouraging -- especially when it's my birthday!)
12:01:51 <bitemyapp> Zekka: the PPA supports simultaneous 7.6 and 7.8 installs.
12:01:57 <bitemyapp> Zekka: as does the bindist approach.
12:02:01 <bitemyapp> Platform does not.
12:02:18 <Zekka> bitemyapp: How much of a pain are simultaneous 7.6 and 7.8 installs with it?
12:02:22 <chrisdone> what's the bindist approach?
12:02:37 <bitemyapp> Zekka: very little, switch PATH.
12:02:41 <chrisdone> personally i have
12:02:41 <chrisdone> $ ls /opt/ghc
12:02:41 <chrisdone> 7.2.2  7.4.2  7.6.3  7.8.2
12:02:43 <bitemyapp> Zekka: cabal uses whatever ghc is in the path.
12:02:52 <bitemyapp> Zekka: and sandboxes already namespace by GHC version.
12:02:59 <chrisdone> and then export PATH=/opt/ghc/7.8.2/bin:$PATH
12:02:59 <chrisdone> whenever i want to use a specific ghc version
12:03:00 <Zekka> bitemyapp: How do they handle the issue of sharing ~/.cabal and ~/.ghc?
12:03:11 <bitemyapp> chrisdone: manual bindist is just doing what the PPA does, but for yourself.
12:03:32 <bitemyapp> Zekka: I don't precisely understand the question. I have had any problem with the simultaneous 7.6 and 7.8 install on my mac or linux machines.
12:03:38 <bitemyapp> I haven't had any problem*
12:03:45 <chrisdone> bitemyapp: so downloading the ghc and untar'ing and ./configure --prefx=/opt/'ing and make'ing?
12:03:54 <bitemyapp> Zekka: ~/.ghc is namespaced too.
12:04:03 <Zekka> bitemyapp: It is? The more you know!
12:04:04 <bitemyapp> Zekka: look at it. It has the GHC version in the path.
12:04:07 <pdxleif> Anyone know of something like http://docs.travis-ci.com/user/osx-ci-environment/ that also includes GHC?
12:04:11 <chrisdone> chris@retina:~$ ls ~/.ghc
12:04:11 <chrisdone> ghci_history  x86_64-linux-7.2.2  x86_64-linux-7.4.2  x86_64-linux-7.6.2  x86_64-linux-7.6.3  x86_64-linux-7.8.2
12:04:20 <bitemyapp> chrisdone: yeah more or less.
12:04:47 <Zekka> .cabal doesn't seem to be although I think some of its subdirectories are
12:04:53 <bitemyapp> chrisdone: namespacing by version, installing somewhere. I have the a link to manual instructions in the guide by davesq, but I try to aim people towards packages that do it for them.
12:04:59 <chrisdone> for cabal that's where sandboxing helps
12:05:01 <Zekka> ka@zekka-yk:~/.cabal$ ls ~/.cabal/share
12:05:02 <Zekka> doc  x86_64-linux-ghc-7.4.1
12:05:03 <bitemyapp> chrisdone: the packages I recommend are all bindist based.
12:05:22 <bitemyapp> Zekka: that's an old GHC :)
12:05:24 <Zekka> I already sandbox pretty heavily
12:05:40 <Zekka> bitemyapp: Yeah, hence why I was planning on updating sometime soon
12:05:43 <bitemyapp> Zekka: you'll be fine, just use the PPA and add the bin dir to your path :)
12:05:54 <Zekka> .cabal/bin? It's already on my path
12:06:12 <chrisdone> bitemyapp: no auto-installer for windows users?
12:06:13 <bitemyapp> Zekka: no.
12:06:16 <bitemyapp> Zekka: PPA installs to /opt
12:06:34 <bitemyapp> chrisdone: I don't dev on windows and very few people that come to me use it.
12:06:38 <chrisdone> trouble is we need windows users who will make stuff like this easier
12:06:41 <bitemyapp> chrisdone: so, basically, no.
12:06:45 <chrisdone> i don't have any windows machines either
12:06:56 <bitemyapp> I *have* a windows machine, I just don't dev on it.
12:07:03 <bitemyapp> they can either use bindist manually or use Platform.
12:07:07 <Zekka> I have a windows machine but I haven't developed on it recently
12:07:13 <bitemyapp> Windows users are possibly the only ones with a good reason to use Platform.
12:07:37 <chrisdone> yeah, it's why on this page i only recommend the platform http://haskell-lang.org/downloads/windows
12:07:45 <Zekka> actually started running some of my networked software on there intead of on here because my Windows computer is wired into the network and my laptop isn't, and it seemed like less effort to install/configure Platform than to move the wire
12:07:45 <chrisdone> the binary setup is just a PITA on windows
12:08:03 <Zekka> (my wired connection seems to be more reliably for whatever reason)
12:08:30 * chrisdone updates the os x page
12:08:50 <bitemyapp> chrisdone: I talked to etrepum about an OS X installer at BayHac, didn't expect him to make one that damn quickly.
12:09:00 <bitemyapp> chrisdone: he's been extremely responsive about bugs and problems as well.
12:09:11 <Zekka> Oh, were you at bayhac? It's entirely possible we've run into each other before.
12:09:28 <chrisdone> ah, he is maybe the guy who asked to use the logo from haskell-lang
12:09:34 <bitemyapp> chrisdone: yep, he was.
12:09:51 <chrisdone> i'll ping him about copying his page into /downloads/osx
12:09:55 <pdxleif> Was looking at using http://win-builds.org/ to make binary packages of haskell apps.
12:09:57 <bitemyapp> Zekka: I don't know what I could tell you that would identify me. I'm a notoriously unpleasant person - that's all I can think of that's specific.
12:10:00 <chrisdone> etrepum: are you already here?
12:10:21 <Zekka> bitemyapp: You could mention what was on your nametag.
12:10:26 <chrisdone> bitemyapp: you are pretty aggressive though =p
12:10:28 <bitemyapp> Zekka: oh, I'm Chris Allen/
12:10:34 <bitemyapp> pdxleif: bless ya if you ya do. Need a bindist package.
12:10:38 <bitemyapp> chrisdone: yep!
12:10:45 <Zekka> Oh. I don't think we saw each other: I was Jeremiah "Zekka" Nelson, including quoted nickname
12:10:53 <pdxleif> bitemyapp: of ghc, or specific haskell apps?
12:11:08 <bitemyapp> pdxleif: GHC + Cabal, add to path.
12:11:19 <bitemyapp> namespaced directory.
12:11:36 <pdxleif> Hmm... does the cabal-install bootstrap script work on windows?
12:11:46 <Zekka> only attended a few talks, spent a lot of time outside the main room coding but helped Eli Frey out with his sisyphean church numerals project in addition to bugging some other folks
12:12:35 <bitemyapp> Zekka: I think I was mostly talking to jfischoff, ReinH, kmett, etrepum. Some others like begriffs.
12:13:00 <ReinH> Zekka: oh were you at bayhac?
12:13:07 <chrisdone> does anyone do the 'advanced' install on osx?
12:13:09 <Zekka> bitemyapp: I strongly suspect that already today I've spoken toa few people I don't recognize in the channel
12:13:22 <pdxleif> chrisdone: What's in the "advanced" install?
12:13:24 <chrisdone> as here http://haskell-lang.org/downloads/osx
12:13:29 <Zekka> ReinH: Yeah, I was there
12:13:35 <ReinH> Zekka: oh cool, me too
12:13:37 <chrisdone> or should i just remove that section?
12:14:12 <bitemyapp> chrisdone: if you're going to leave it in, link to davesq's article instead.
12:14:20 <bitemyapp> chrisdone: he wrote a thorough "how I did it" guide on that topic.
12:14:31 <Zekka> Not sure how to identify myselfo ther htan by what was on my nametag -- I guess I was the teenage guy who wasn't from Snowdrift and wasn't delivering the lens presentation
12:14:46 <pdxleif> chrisdone: Oh, that.  I used to do that on FreeBSD, but that was probably for lack of binaries like GHC and cabal-install
12:14:47 <bitemyapp> chrisdone: https://github.com/bitemyapp/learnhaskell#detailed-manual-install-guide-for-mac-os-x
12:15:41 <chrisdone> i'm basically trying a policy of no linking
12:16:11 <chrisdone> every external page i link from haskell-lang.org makes it seem fragmented and pages will 404 eventually
12:16:15 <bitemyapp> chrisdone: well, then just remove in favor .app IMO.
12:16:18 <chrisdone> instead i'm asking authors if i can copy them  in
12:16:19 <bitemyapp> chrisdone: less noise is better.
12:16:28 <bitemyapp> chrisdone: don't make them think.
12:17:09 <bitemyapp> just answered another question that tells me I need to do the Cabal article/video.
12:17:39 <bitemyapp> chrisdone: might I recommend Yorgey's course over LYAH/RWH for http://haskell-lang.org/documentation ?
12:17:54 <bitemyapp> chrisdone: I've had a lot more luck putting learners through his course. I might edit it soon as well.
12:18:11 <bergmark> chrisdone: there are binaries for cabal too
12:18:12 <bitemyapp> chrisdone: I recommend RWH/LYAH primarily as references, not as main-course tutorials.
12:18:23 <enthropy> has haddock always called "newtype" "data"?
12:18:24 <Zekka> bitemyapp: ghc7.6.2 installed, seems to work
12:18:37 <bitemyapp> Zekka: awesome.
12:18:38 <chrisdone> bitemyapp: where's his course?
12:18:50 <enthropy> as in http://hackage.haskell.org/package/optparse-applicative-0.9.0/docs/Options-Applicative-Internal.html#t:NondetT is actually a newtype, but haddock says "data"
12:18:50 <bitemyapp> chrisdone: https://github.com/bitemyapp/learnhaskell#yorgey-course---do-this-first-this-is-the-primary-way-i-recommend-being-introduced-to-haskell
12:19:27 <Zekka> Is there a reason you particularly like his course?
12:19:41 <bitemyapp> Zekka: it works supremely better for newbies.
12:19:52 <bitemyapp> Zekka: dropout rate is much higher with LYAH and RWH, too boring/slow/ponderous
12:19:57 <Zekka> Just looking at the headings it looks like it covers a reasonable body of subject matter
12:20:07 <bitemyapp> Zekka: LYAH leaves people fucking *mystified* on Applicative and Monad - unnecessarily so.
12:20:14 <chrisdone> i'll add it to the list
12:20:17 <bitemyapp> Zekka: Yorgey's course does a better job leading you into those topics without being verbose.
12:20:19 <Zekka> I liked LYAH, but fair point from what my friends tell me
12:20:24 <albeit> Shot in the dark, but for anyone curious... does this (http://lpaste.net/105408) look "proper"? Any clearer way of doing it?
12:20:24 <enthropy> nevermind it is just hackage's haddock that is misbehaving
12:20:28 <ocharles> ReinH, my good man.
12:20:37 <ReinH> ocharles: hello good sir
12:20:49 <Zekka> maybe I'll link your learnhaskell repo next time I'm evangelizing
12:21:39 <fread2282> how can I get the typeOf a type indicated by a Proxy?
12:24:05 <corgifex> proxyTypeOf :: Proxy a -> TypeRep; proxyTypeOf = typeOf . deproxy where deproxy :: Proxy a -> a; deproxy = undefined
12:24:31 <fread2282> corgifex: thanks
12:24:35 <corgifex> oops, missing (Typeable a) constraint
12:24:59 <shachaf> I,I proxy a -> TypeRep
12:25:22 <rwbarton> or in 7.8 you just use typeRep
12:25:23 <shachaf> This function is called typeRep in GHC 7.8
12:25:54 <shachaf> And before GHC 7.8 Proxy wasn't in the standard library, so if you're using that Proxy then you can just use typeRep.
12:27:10 <chrisdone> oh neat, Proxy is in base now?
12:31:57 <fread2282> is there any way to turn a typeRep into a Proxy type or similar?
12:33:26 <fread2282> *TypeRep
12:33:55 <enthropy> no
12:35:18 <fread2282> :(
12:35:25 <rwbarton> what would that mean?
12:35:49 <corgifex> how would you use it?
12:36:52 <fread2282> I want to serialize a Proxy
12:37:14 <corgifex> into what? 0 bits?
12:37:30 <rwbarton> we are way into Y territory here
12:37:43 <shachaf> I,I TypeRep -> (exists x. Typeable x *> x)
12:38:01 <fread2282> corgifex: thereis ConcreteTypeRep, but then I want to deserialize it
12:38:27 <corgifex> what would that mean? how would you use it?
12:47:22 <albeit> I have a sum type wrapping other basic types, like "data Foo = FooString String | FooInt Int". Is there anyway to "unwrap" a Foo back to a String/Int, without pattern matching?
12:47:46 <Zekka> albeit: In what way do you want to unwrap it?
12:47:59 <monochrom> what is the type of the unwrapped result?
12:48:02 <Zekka> Like, do you want to then perform an operation on what comes out which is valid both for strings and for ints?
12:48:16 <monochrom> but I know the answer
12:48:19 <albeit> Given "foo = FooString "str"", I want to get "foo' = "str""
12:48:34 <Zekka> albeit: But what if foo = FooInt 0?
12:48:35 <monochrom> safeUnwrap :: Foo -> Either String Int
12:48:36 <fread2282> albeit: but what if foo = FooInt 1
12:48:49 <albeit> Woah
12:49:00 <albeit> Yes, that is an issue
12:49:10 <Zekka> albeit: There's a few options here if you ask me
12:49:17 <Zekka> You could have foo' be a Maybe
12:49:24 <Zekka> Then you could define a function Foo -> Maybe String
12:49:29 <Zekka> You could have foo' be an either, too
12:49:38 <Zekka> which would then be Foo -> Either Int String
12:49:53 <Zekka> Either Int is a functor, so it wouldn't be too hard to operate on the String inside
12:49:59 <Zekka> You could just throw up if htere's an Int
12:50:02 <albeit> The end goal is to get two Foos to be inputs into a function "f :: Int -> String -> ..."
12:50:07 <Zekka> which would be Foo -> String
12:50:17 <kazagistar> albeit: the reason pattern matching is the main way of doing that is because it uses the type system to encourage you to handle the cases properly
12:50:22 <monochrom> then why did you have Foo to begin with?
12:50:29 <fread2282> you probably want data Foo = Foo Int String?
12:50:30 <Zekka> Yeah, I'm a little confused about what Foo does here
12:50:43 <Zekka> because it seems to me liike there's a lot of ways to create invalid input using Foos for this case
12:50:58 <Zekka> but not a lot of ways to do that using i.e. fread's definition
12:51:04 <rwbarton> the two function arguments are supposedly stored in two entries of an IntMap (source: earlier today)
12:51:09 <albeit> Foo is necessary, it encapsualted a bunch of different types that read in input can be
12:51:10 <monochrom> to a large extent I should just walk away because you have an infinite series of XY problems
12:51:30 <albeit> rwbarton: Good memory! Yes, Foos are stored in an IntMap Foo
12:51:36 <Zekka> albeit: So it's basically a big either between a lot of types that are similar in what way?
12:52:02 <Zekka> If the types it lets you choose between are similar in some way you can use typeclasses and hten define a function (TheImportantSimilarity a) => Foo -> a
12:52:08 <Zekka> er, that's not right
12:52:40 <Zekka> hold up, I'm bad at quantification, let me experiment with types a second
12:53:10 <albeit> Zekka: Yes, they all have a similarity... but I experimented with the typeclass route before and it didn't work
12:53:21 <Zekka> albeit: What happened instead of it working?
12:53:39 <Zekka> And please excuse that type, I haven't used rank2types for a little while and I forget the appropriate way to syntactically phrase what I mean
12:54:23 <monochrom> IMO, near the input stage, you should already not put the number and the string in the same IntMap. you should have already stored them in a record.
12:54:46 <Zekka> I think the correct way to phrase it is Foo -> (forall a. Similarity a => a)
12:54:51 <albeit> Well... I'm reading in a bunch of values that can be one of many types. And I eventually need to know those types. I can't remember the exact reasons, but it seemed like a sum type was the way to go
12:55:09 <monochrom> and after knowing how aeson and optparse-applicative do things, I know how to do this
12:55:32 <albeit> monochrom: How would they be stored in a record?
12:56:00 <monochrom> typical aeson usage examples show how.
12:56:14 <albeit> The final record which is generated from the input string depends on wheter or not specific int keys exist, and the values of specific keys
12:56:54 <monochrom> that is nothing new to typical usages of aeson
12:57:23 <albeit> Do you have any examples of some aeson that might demonstrate what your saying?
12:57:33 <albeit> Not sure what to look for exactly...
12:57:36 <monochrom> no. but aeson has.
12:57:43 <albeit> I gather that
12:57:44 <monochrom> or rather, aeson doc has
12:57:51 <albeit> I'll take a look
12:58:13 <monochrom> all I know, I learned from the doc. do you think I can really invent brand new things?
12:58:45 <albeit> When you say doc, is that separate than what would be on hackage for the package description?
12:59:20 <monochrom> I don't understand the question.
12:59:42 <albeit> What is aeson doc as opposed to aeson?
12:59:54 <monochrom> aeson's API doc
13:00:33 <ski> shachaf : hm, perhaps a variant `TypeRep :: forall k. k -> *' would be useful
13:01:40 <phaazon> hey, I’m trying to write my own reactive lib (FRP) ; it’s my second shot : https://github.com/phaazon/reactant/blob/master/FRP/Reactant.hs ; what do you think of it?
13:01:49 <phaazon> (it’s not complete yet though)
13:02:33 <albeit> monochrom: Still not quite sure what I'm looking for... sorry for pestering... but something about storing an input in a record before another data structure?
13:02:58 <monochrom> let me say some high level things that may or may not be useful
13:03:47 <fread2282> an int64 is 8 bytes, right?
13:03:55 <monochrom> internally, aeson keeps a map from keys to values, to be sure. but firstly and unimportantly, "value" is simply String or Text or whatever is the rawest kind of input data
13:04:23 <monochrom> secondly and importantly, it doesn't bloody expose that to you. you never even know that the map exists.
13:05:21 <ReinH> > 8 * 8
13:05:23 <lambdabot>  64
13:05:56 <monochrom> what it exposes: a parser library. you can ask for the value of key "xxx" for example. but right at that point, you already has to say what type you want, by context (type inference) or by annotation
13:06:43 <monochrom> if you asks for Int, then a parser is chosen to parse the String to Int. you never even see String. you see Int.
13:07:42 <albeit> Okay, so it delays parsing the actual values until they are required and the type can be inferred. But if its parsing "foo=123", it will read and store "123", and then parse "123" when its required... so its effectively reading "123" twice, yeah?
13:08:10 <corgifex> monochrom: your 2nd person singular verb forms are broken :-)
13:08:13 <albeit> I would much prefer to parse the value as its encountered so I don't have to go back and "reparse" it
13:08:43 <monochrom> so you do this: MyCtor <$> (get value from key "xxx") <*> (get value from key "yyy"). by MyCtor I mean data MyType = MyCtor Int Bool
13:09:20 <phaazon> huhu, no one for my FRP lib? :D
13:09:26 <benzrf> phaazon: go on...
13:09:31 <benzrf> what does it bring to the table eh
13:09:36 <benzrf> we already have like 10
13:09:40 <monochrom> this jumps directly from Map String String to MyType. no intermediate Either Int Bool involved
13:09:45 <albeit> But if I don't know what constructor to use until I've parsed the entire input string, what then?
13:09:48 <Zekka> Well, now you have eleven!
13:10:32 <monochrom> as for "but I have 3 cases depending on the value of the 1st field", that can be handled too. every parser lib can.
13:10:56 <phaazon> 22:07 < benzrf> phaazon: go on...
13:11:11 <phaazon> ok I guess that means “stop doing it” and the rude way?
13:11:26 <corgifex> no, it means "go on"
13:11:50 <albeit> monochrom: I guess the issue is what if which constructor depends on the third value, but some of those constructors need earlier values?
13:11:57 <ReinH> benzrf: it looks more like phaazon is exploring FRP concepts than trying to release a library for people to use
13:12:06 <benzrf> ah
13:12:26 <ReinH> (which is a totally cromulent thing to do btw)
13:12:38 <benzrf> god damn
13:12:41 <benzrf> my brain filled in a more
13:13:01 <monochrom> ok, slash my notion of "1st field"
13:13:41 <phaazon> 22:09 < corgifex> no, it means "go on"
13:13:46 <phaazon> I read some irony in there ;)
13:13:51 <monochrom> you, as well as aeson, do not really have a concept of "nth field", no? only a concept of "the value of key 1", "the value of key 3", and "the value of key xxx", no?
13:13:58 * hackagebot persistent-mongoDB 1.3.2 - Backend for the persistent library using mongoDB.  http://hackage.haskell.org/package/persistent-mongoDB-1.3.2 (GregWeber)
13:14:17 <geekosaur> "pray, continue"
13:14:17 <albeit> monochrom: Sure
13:14:47 * ski . o O ( "Pray, Pay, and be Healed Today !" )
13:15:01 <monochrom> so the value of key 3 determines what the parse does for the rest. it may be 3 or it may be 398234. just hardcode that number, no?
13:15:10 <monochrom> s/parse/parser/
13:15:57 <monochrom> you read the input, store it in a key-value store, then look it up a couple of time. I don't see how this counts as "reading twice"
13:16:10 <tmobile> Is it possible to add a typeclass constraint on the "return type" of a type family?
13:16:17 <monochrom> I can agree that it counts as "two pass", but why does it matter?
13:16:20 <tmobile> Specifically one defined inside a typeclass.
13:17:03 <monochrom> you are effectively saying, the 9302834th byte determines how to interpet the 1st byte to the 9302833th byte. how can it not be two-pass?
13:17:15 <albeit> monochrom: It would matter only if, say, it would take twice the time to read "foo=123" into ("foo", "123"), and then to ("foo", 123), instead of just straight to ("foo", 123)
13:17:35 <monochrom> ("foo", 123) will never exist.
13:17:49 <albeit> Sorry, just 123
13:18:20 <albeit> so "foo=123" -> ("foo", "123") -> 123 vs "foo=123" -> 123
13:18:24 <monochrom> 123 alone will exist, yes, why is it wrong? don't you want to obtain 123 alone?
13:18:49 <albeit> Yes, its the intermediate step, where we read it as a text, then later go back to that same text and parse it into its final value.
13:18:52 <monochrom> ok, yes, "foo=123" -> ("foo", "123") -> 123 is true. why is it bad?
13:19:09 <monochrom> have you read what I said about two-pass and why it is necessary?
13:19:17 <monochrom> if not, read it 3 times
13:19:23 <monochrom> if yes, read it 2 more times
13:20:27 <albeit> I was referring specifically to reading the same text twice, once to text then to its final type, instead of just once to its final type.
13:20:42 <monochrom> I was referring to that, too
13:20:55 <albeit> How are there two-passes for the second scenario?
13:21:42 <monochrom> the second scenerio cannot be implemented, as long as you insist "later input changes how to parse earlier input"
13:22:05 <monochrom> there are 0 passes for the second scenerio. because it can't be done.
13:22:55 <albeit> To clarify that, later inputs determine the final structure, but the final type of each value is determined purely by its key.
13:22:58 <monochrom> if you are willing to change input format so that "early input completely tells me what the rest means", such as "the first field tells me", then you can do one-pass
13:24:18 <monochrom> that sounds nice. upon closer examination, later input determines what keys are present and what keys are absent in earlier input. you are none the wiser.
13:24:22 <Eduard_Munteanu> Hmm, would be nice if RecordWildCards could expand accessors recursively.
13:24:40 <benzrf> RecordWildCards does what?
13:25:39 <monochrom> e.g., I have to look at later input, find "xxx=10", that tells me "do not look for key yyy in earlier input, it is not there". my parser still has to wait for later input before scrutinizing earlier input
13:25:44 <Eduard_Munteanu> benzrf: along with NamedFieldPuns, you can write e.g. f Foo {..} = ... here you can use the accessors of Foo without a Foo parameter ...
13:26:13 <benzrf> O:
13:26:18 <benzrf> now that is cute!
13:26:48 <Eduard_Munteanu> benzrf: e.g. data Foo = Foo { fooX :: Int, fooY :: Int }; add Foo {..} = fooX + fooY
13:27:11 <albeit> monochrom: True, but if each key/value pair is read into an IntMap Foo (assuming each key is an Int), where Foo is a sumtype wrapping all possible types of the value, the earlier inputs don't need to be reparsed... they are already in their final type
13:28:26 <Zekka> Eduard_Munteanu: So it's automatic {fooX = fooX, fooY = fooY, [...]}? Does it do anything else?
13:28:36 <BeardedCoder> anyone know why (read "3" :: Pico) consumes all memory until system crashes?
13:28:51 <monochrom> ok, maybe you can stick to that plan. but it merely redraws the boundary of "parsing" without solving it completely.
13:29:17 <monochrom> you seem to think, "after I have produced the IntMap, I am done parsing".
13:29:37 <Eduard_Munteanu> Zekka: that's it, pretty much
13:29:52 <albeit> Yeah I guess I am... which I probably shouldnt be... because I still have to "parse" that IntMap into the final structure
13:29:58 <monochrom> but no, until you also know that, the key "xxx" is present, and its value is FooInt 314 and not FooString "acb", you are not really done parsing.
13:30:09 <albeit> I think I'm slowly understanding ;)
13:30:11 <monochrom> at least that's my opinion of what counts as parsing
13:30:33 <Eduard_Munteanu> Zekka: you can combine them like { fooX = x, .. }, IIRC, though.
13:31:08 <monochrom> you can combine your plan with my plan
13:32:17 <phaazon> which FRP lib would you recommend then?
13:32:38 <zwer> > read "3" :: Pico
13:32:43 <lambdabot>  mueval: ExitFailure 1
13:32:55 <monochrom> you can keep the IntMap Foo. but you add some "parsing-like" lib that does the extra checking
13:33:22 <rwbarton> > show (3 :: Pico)
13:33:23 <lambdabot>  "3.000000000000"
13:33:33 <rwbarton> > read (show (3 :: Pico)) :: Pico
13:33:37 <lambdabot>  mueval-core: Time limit exceeded
13:33:40 <corgifex> BeardedCoder: works in my ghci
13:33:52 <benzrf> Pico?
13:33:56 <benzrf> :k Pico
13:33:57 <lambdabot> *
13:33:58 <rwbarton> well that doesn't seem good
13:34:00 <albeit> monochrom: Thanks btw!
13:34:08 <corgifex> Prelude Data.Fixed> read "3" :: Pico
13:34:09 <corgifex> 3.000000000000
13:34:20 <rwbarton> huh, doesn't work for me
13:34:28 <zwer> works in here too
13:34:29 <BeardedCoder> I have to kill mine or it will scarf all my memory shortly
13:34:36 <corgifex> 7.6.3, windows
13:34:41 <BeardedCoder> 7.8.2 osx
13:34:44 <rwbarton> maybe it broke in 7.8
13:35:08 <zwer> I have 7.6.3 too
13:35:36 <zwer> linux
13:37:13 <gamegoblin> Ok so I ask this on here every now and then because I’ve never actually seen an answer: how would I implement the regex “a[ab]+a” in parsec or attoparsec
13:37:59 <corgifex> eh, that requires unlimited lookahead
13:38:17 <fread2282> gamegoblin: [] is any of?
13:38:37 <corgifex> when would you ever need that?
13:39:12 <gamegoblin> corgifex: In the original URI spec, it calls for something like “alpha” “alphanum”+ “alpha” for one of the terms
13:39:40 <gamegoblin> fread2282: yes
13:39:40 <corgifex> ok, but that doesn't need to be handled in the grammar necessarily
13:39:56 <gamegoblin> corgifex: yes, I was just curious if I were being daft, though
13:40:21 <gamegoblin> corgifex: seems like something that should be implementable in a context sensitive parser, if it’s just a regular language
13:40:21 <corgifex> I don't know attoparsec but I think you can make parsec fully backtracking with 'try'
13:40:41 <gamegoblin> corgifex: I think it’s possible with some crazy combination of try and lookahead, but I never figured it out
13:41:08 <corgifex> x <||> y = try x <|> y
13:41:24 <corgifex> many' p = many1' p <||> return []
13:41:42 <corgifex> many1' p = (:) <$> p <*> many' p
13:42:09 <corgifex> char 'a' *> many1' (char 'a' <||> char 'b') *> char 'a'
13:42:14 <corgifex> super untested
13:42:32 <eflynn> i don’t understand reader monads
13:42:39 <corgifex> probably won't work
13:42:47 <gamegoblin> I actually made my own entire parsing library after encountering this issue
13:42:51 <gamegoblin> so it’s not a problem anymore
13:42:53 <gamegoblin> lol
13:43:16 <corgifex> hmm
13:43:34 * corgifex ponders
13:43:42 <gamegoblin> And I kind of wanted to see if I could. Now I have a deeeep understanding of monads that I didn’t have before.
13:44:02 <corgifex> a[ab](b*a)+
13:44:10 <corgifex> isn't that equivalent to the original pattern?
13:44:53 <corgifex> char 'a' *> oneOf "ab" *> many1 (many (char 'b') *> char 'a')
13:45:14 <gamegoblin> Not quite quivalent
13:45:20 <gamegoblin> or wait
13:45:21 <gamegoblin> hmm
13:46:01 <gamegoblin> I think it is actually, but god is it ugly
13:46:06 <gamegoblin> good job
13:46:14 <corgifex> I think the original is semantically ugly
13:46:19 <gamegoblin> Very clever
13:47:25 <rwbarton> I don't see how the original is "semantically ugly" except perhaps as viewed through the lens of parsec
13:47:38 <rwbarton> it just "starts and ends with an a, and in the middle has one or more as or bs"
13:47:45 <corgifex> ok, *operationally ugly
13:47:51 <rwbarton> if you weren't trying to use a parsing library it would be a trivial task
13:47:59 <albeit> For a typeclass, is there a way to have a default (like "f _ = Nothing"), and in the implementation have patterns that precede the default? (like "f (Foo 5) = Just 5")
13:48:14 <gamegoblin> In my parsing library, you just do ` char ‘a’ >> many1_ (oneOf “ab”) >> char ‘a’ ` and it takes care of the magic behind the scenes
13:48:36 <gamegoblin> Though it’s not terribly memory efficient (yet)
13:48:38 <corgifex> gamegoblin: sure, that's not hard. the trick is making it efficient
13:48:41 <benzrf> gamegoblin: that sounds like parsec
13:48:41 <corgifex> :-)
13:48:48 <benzrf> in fact thats almost exactly parsec
13:48:56 <corgifex> o rly
13:49:01 <gamegoblin> benzrf: is it?
13:49:02 * hackagebot persistent-mongoDB 1.3.3 - Backend for the persistent library using mongoDB.  http://hackage.haskell.org/package/persistent-mongoDB-1.3.3 (GregWeber)
13:49:04 <benzrf> yeah
13:49:14 <gamegoblin> benzrf: How so?
13:49:14 <benzrf> take the _ away and that's valid parsec
13:49:18 <benzrf> iirc
13:49:21 <gamegoblin> benzrf: but it doesn’t do the same thing at all
13:49:25 <benzrf> oh?
13:49:39 <gamegoblin> As we’ve been discussing, in parsec that will fail
13:49:43 <benzrf> orly
13:49:48 <gamegoblin> The middle term will consume the input the last term is looking for
13:50:09 <benzrf> gamegoblin: oic
13:50:18 <gamegoblin> if you remove the _ my library works just like parsec, but it’s the _ added that makes my library do something special with magical backtracking
13:50:19 <benzrf> i wasnt paying very close attention ;p
13:50:40 <gamegoblin> Which actually isn’t terribly inefficient when you take laziness into account
13:50:50 <fread2282> gamegoblin: how does it do on benchmarks?
13:51:14 <gamegoblin> fread2282: I’m polishing up v2 now, in which I am implementing every function parsec and attoparsec have for full compatability, and I will benchmark then
13:51:41 <gamegoblin> fread2282: Something I am not quite good at yet is various prepocessor directives like INLINE which parsec and attoparsec seem to put on nearly every function
13:52:29 <gamegoblin> And attoparsec just upgraded its system so it’s even faster now T_T but I think I’ll be able to be on par with parsec
13:52:48 <gamegoblin> Mine works on arbitrary Stream types just like Parsec, so it’s not specialized for bytestrings
13:53:12 <fread2282> gamegoblin: can you use attoparsec/parsec for most functions?
13:53:16 <albeit> Do typeclass instances fall back to the default implementation if, for example, the instance's implementation is not a total function?
13:53:19 <corgifex> rwbarton: do you happen to know if regexes lose power if every choice is made possessive?
13:53:24 <gamegoblin> fread2282: What do you mean?
13:53:26 <benzrf> albeit: i do not think so...
13:53:30 <corgifex> albeit: no
13:54:09 <albeit> Thanks
13:54:28 <rwbarton> corgifex: possessive?
13:54:49 <rwbarton> like with parsec try?
13:54:54 <rwbarton> er, parsec <|>. not try
13:54:59 <corgifex> in perl syntax, every a|b becomes (?>a|b) and every a* becomes (?>a*) (also known as a*+)
13:55:23 <corgifex> that's not quite the same as parsec <|>
13:55:33 <rwbarton> I don't speak that much perl
13:55:48 <corgifex> yeah, I used to have a pure math formulation of that idea somewhere
13:56:00 <rwbarton> oh, weird
13:56:25 <gamegoblin> fread2282: What did you mean earlier about using parsec/attoparsec for functions?
13:56:47 <gamegoblin> Woah what the hell. WHy did 50 people just leave the room?
13:56:56 <davidthomas> netsplit
13:56:58 <WilliamD`> split
13:57:16 <corgifex> rwbarton: basically, (?>A|B)C means you try A first. if it succeeds, you proceed to C but forget all backtracking save points, so if you fail in C, you don't try B
13:57:25 <corgifex> rwbarton: you only try B if you fail in A
13:57:36 <fread2282> gamegoblin: nevermind
13:57:45 <corgifex> parsec doesn't go by position in the pattern; it checks whether you consume any input
13:57:46 <fread2282> gamegoblin: but you should checkout trifecta
13:57:50 <sjoerd_visscher> 50 people are scared of edward kmett
13:58:36 <WilliamD`> trying to play w hs-platform on arm. just found out ghci is not supported. bummer, that was the first thing I tried. second thing was cabal install hsenv. "template haskell bracket requires ghc with interpreter support" :(
13:58:54 <gamegoblin> fread2282: never heard of it. Reading now.
14:00:29 <ocharles> Hey sjoerd_visscher, I got what I wanted working this morning. Prepping a blog post now :)
14:01:01 <ocharles> Doesn't need a free category or anything, it's mostly just Kleisli composition
14:02:44 <corgifex> rwbarton: http://jsbin.com/yowunade/1
14:02:55 <jle`> yay another ocharles blog post
14:03:02 <ocharles> jle`: :)
14:03:03 <jle`> i still need to understand your last one
14:03:13 <jle`> it seems like you directly applied things you learned at that well typed course?
14:03:19 <sjoerd_visscher> ocharles: can’t wait to read it!
14:03:21 <shachaf> corgifex: Is your website still around, speaking of which?
14:03:24 <simukis_> is it possible to ask `cabal init` to generate cabal file which builds an executable with threading (i.e. add  ghc-options: -threaded to the cabal file)? cabal init might be used non-interactively and editing the cabal file by hand afterwards is not an option.
14:03:33 <corgifex> shachaf: it wasn't really a website, and no
14:03:42 <shachaf> Your HTTP server.
14:04:06 <shachaf> Is it permanently gone? I used to link to it all the time.
14:04:32 <fread2282> gamegoblin: also IIRC it manages to beat attoparsec
14:05:10 <corgifex> it was just a dynamic dns entry pointing to my (now dead) desktop machine
14:05:23 <shachaf> Is that also the reason preflex is gone?
14:05:42 <corgifex> yeah
14:06:52 <jle`> corgifex: are you preflex?
14:07:03 <corgifex> heh
14:07:08 <corgifex> do I look like a bot?
14:10:04 <jle`> if i squint
14:10:39 <hpc> corgifex: botsnack
14:10:59 <corgifex> :-)
14:11:07 <hpc> well that proves it
14:11:12 <hpc> you are a bot
14:11:31 <corgifex> dammit
14:11:36 <corgifex> failed the turing test again
14:11:50 <monochrom> I pass the turing test
14:12:04 <monochrom> it's easy. just screw up basic arithmetic.
14:12:24 <monochrom> and write buggy programs
14:12:25 <Taneb> monochrom, that is two good ways to do it
14:12:29 <Taneb> 3 even
14:12:30 <monochrom> hehe
14:12:31 <silasm> I don't so much care about a bot passing the turing test so much as dreading the day when most humans fail it.
14:12:37 <rhodesd> Anyone know of a module that can parse ghc's .hi interface files?
14:12:44 <monochrom> yes silasm :)
14:12:49 <corgifex> monochrom: http://www.smbc-comics.com/?id=2999
14:12:49 * geekosaur can do a pretty good job of failing the turing test (moderate-to-severe autism being funny that way)
14:13:10 <monochrom> the test applied to humans, I have called it the monochrom test
14:13:44 <shachaf> rhodesd: Probably only GHC.
14:14:09 <monochrom> a haskell interpreter may yet pass that test, if it defaults to Rational
14:14:58 <corgifex> yes, but here failing arithmetic doesn't mean you're human
14:15:03 <danking> Any idea why after `cabal install happy' I don't see it listed in `ghc-pkg list'?
14:15:14 <rhodesd> shachaf: does that mean my only bet is to use ghc --show-iface?
14:15:17 <corgifex> danking: it's probably not a library
14:15:21 <silasm> > let 2 + 2 = 5 in 2 + 2
14:15:22 <lambdabot>  5
14:15:28 <danking> corgifex: Hmm.
14:15:36 <danking> I hadn't considered that option.
14:15:40 <shachaf> rhodesd: You could import GHC code to use it as a library, I imagine.
14:15:51 <shachaf> rhodesd: But of course it breaks between versions etc.
14:15:55 <geekosaur> rhodesd, there used to be programd that parsed .hi files directly. they broke often
14:16:04 <geekosaur> *programs
14:16:12 <geekosaur> and even libraries (infamously, plugins)
14:16:18 <rhodesd> shachaf: ok thanks, I'll give that a try then.  I'm not worried about breakage to much.
14:16:21 <rhodesd> too :/
14:16:25 <geekosaur> the better bet turned out to be to use ghc-api whenever possible
14:21:46 <Black-Heaven> rwbarton: thanks
14:22:48 <albeit> Is there an elegant way to convert Either a b -> Either a (Maybe b), but always to Just, so Right 5 -> Right (Just 5), Left "Bad" -> Left "Bad"?
14:23:51 <dmj`> is there a better way to write this: join . fmap I.lookup uid <$> tryReadMVar mvar... to get an IO (Maybe a)
14:24:03 <bergmark> @type right Just
14:24:04 <lambdabot> Either d a -> Either d (Maybe a)
14:24:35 <albeit> Oh, great thanks
14:24:56 <benzrf> :t lmap
14:24:57 <lambdabot> Profunctor p => (a -> b) -> p b c -> p a c
14:25:20 <corgifex> :t fmap Just `asAppliedTo` Right 'x'
14:25:21 <lambdabot> Either a Char -> Either a (Maybe Char)
14:25:29 <benzrf> @hoogle Bifunctor f => (a -> b) -> f a0 a -> f a0 b
14:25:31 <lambdabot> Warning: Unknown class Bifunctor
14:25:31 <lambdabot> Data.Graph.Inductive.Graph emap :: DynGraph gr => (b -> c) -> gr a b -> gr a c
14:25:31 <lambdabot> Control.Arrow (^<<) :: Arrow a => (c -> d) -> a b c -> a b d
14:25:34 <benzrf> >:{
14:25:39 <benzrf> :t bimap id Just
14:25:40 <lambdabot> Bifunctor p => p b c -> p b (Maybe c)
14:25:45 <benzrf> :-O
14:27:40 <fread2282> :t second Just
14:27:42 <lambdabot> (d, a) -> (d, Maybe a)
14:28:33 <bergmark> dmj`: fmap (lookup uid =<<) . tryReadMVar
14:28:58 <benzrf> bergmark: i cant easily parse that
14:29:04 <benzrf> o wait
14:29:07 <benzrf> i think i can
14:29:09 <dmj`> bergmark: ahh nice!
14:29:10 <bergmark> :-)
14:30:20 <bitemyapp> :t fmap (lookup uid =<<) . tryReadMVar
14:30:21 <lambdabot>     Not in scope: ‘uid’
14:30:21 <lambdabot>     Perhaps you meant one of these:
14:30:21 <lambdabot>       ‘id’ (imported from Data.Function),
14:30:24 <bitemyapp> oh, nuts.
14:30:44 <bitemyapp> :t fmap (lookup id =<<) . tryReadMVar
14:30:45 <lambdabot> Not in scope: ‘tryReadMVar’
14:30:49 <bitemyapp>  >:[
14:30:50 <bergmark> oh, nuts.
14:31:01 <benzrf> @hoogle tryReadMVar
14:31:03 <lambdabot> No results found
14:31:09 <bitemyapp> benzrf: fml
14:31:39 <bergmark> just trust me on this one people!
14:31:41 <benzrf> :t let tryReadMVar = undefined :: (String -> IO (Maybe String)) infmap (lookup id =<<) . tryReadMVar
14:31:41 <lambdabot> parse error on input ‘)’
14:31:44 <benzrf> :t let tryReadMVar = undefined :: (String -> IO (Maybe String)) in fmap (lookup id =<<) . tryReadMVar
14:31:45 <lambdabot>     Couldn't match type ‘Char’ with ‘(a0 -> a0, b)’
14:31:45 <lambdabot>     Expected type: String -> IO (Maybe [(a0 -> a0, b)])
14:31:45 <lambdabot>       Actual type: String -> IO (Maybe String)
14:31:47 <dmj`> @typ \mvar uid -> (lookup uid =<<) <$> tryReadMVar mvar
14:31:48 <lambdabot> Not in scope: ‘tryReadMVar’
14:31:50 <benzrf> well im sure thats ont the real type p:
14:33:41 <fread2282> @hoogle Int -> Int64
14:33:43 <lambdabot> Data.Set elemAt :: Int -> Set a -> a
14:33:43 <lambdabot> Prelude (!!) :: [a] -> Int -> a
14:33:43 <lambdabot> Data.List (!!) :: [a] -> Int -> a
14:33:56 <corgifex> :t fromIntegral
14:33:58 <lambdabot> (Num b, Integral a) => a -> b
14:33:58 <bergmark> :t \uid tryReadMVar -> fmap (lookup uid =<<) . tryReadMVar
14:33:59 <lambdabot> (Functor f, Eq a1) => a1 -> (a -> f (Maybe [(a1, b)])) -> a -> f (Maybe b)
14:36:42 <bergmark> speaking of pointless programming i want to make this nicer ;o
14:36:46 <bergmark> :t \c p f g o n -> c <$> join (p <$> f o <*> g n)
14:36:48 <lambdabot> (Applicative f, Monad f) => (a -> b) -> (a2 -> a1 -> f a) -> (t -> f a2) -> (t1 -> f a1) -> t -> t1 -> f b
14:37:00 <geekosaur> pointless is often the opposite of nicer :)
14:37:54 <dwcook> I define "nice" as "expressible combinatorially", so there
14:38:27 <bergmark> yay
14:39:05 <fread2282> :t (\c p f g o n -> (\c p o n -> c <$> join (p <$> o <*> n)) c p (f o) (g n))
14:39:06 <lambdabot> (Applicative f, Monad f) => (a -> b) -> (a2 -> a1 -> f a) -> (t -> f a2) -> (t1 -> f a1) -> t -> t1 -> f b
14:39:06 <albeit> If I know a "Either a b" is Left, is there an easy way to convert it to a "Either a c"?
14:39:21 <fread2282> :t (\c p o n -> c <$> join (p <$> o <*> n))
14:39:22 <lambdabot> (Applicative f, Monad f) => (a -> b) -> (a2 -> a1 -> f a) -> f a2 -> f a1 -> f b
14:39:27 <Shoop> I am on linux mint and I just removed haskell and reinstalled it using apt-get but ghc-pkg check still says i have broken packages. Is there something I missed when doing a complete uninstall?
14:39:41 <fread2282> :t liftM2
14:39:42 <zomg> Shoop: ~/.ghc probably
14:39:43 <lambdabot> Monad m => (a1 -> a2 -> r) -> m a1 -> m a2 -> m r
14:39:52 <jle`> albeit: hm. how about fmap id
14:39:58 <Shoop> zomg: ah thanks
14:40:19 <jle`> :t fmap id (Left () :: Either () Int) :: Either () String
14:40:20 <lambdabot>     Couldn't match type ‘Int’ with ‘[Char]’
14:40:20 <lambdabot>     Expected type: Either () String
14:40:20 <lambdabot>       Actual type: Either () Int
14:40:24 <bergmark> albeit: if you knew that you wouldn't have an Either ;)
14:40:55 <albeit> Well I'm checking with isLeft... and if its left, I want to return the left value but as part of different type Either
14:41:04 <jle`> i guess the best way to do it would just be to use a case expression
14:41:08 <bergmark> albeit: pattern match or use a combinator instead
14:41:23 <jle`> case x of Left l -> Left l; Right r -> something;
14:41:30 <Shoop> zomg: anywhere else that apt-get wouldnt take care of? other than .cabal?
14:41:36 <bergmark> either, (+++), and (|||) are your Either friends
14:41:38 <albeit> Okay
14:41:54 <pchiusano> I am trying to install lens 4.2, which depends on aeson-0.7.0.3, which is failing to build due to 'Data.Scientific' does not export `scientificBuilder`, anyone have any idea what's going on?
14:42:09 <ab9rf> what jle said
14:42:22 <pchiusano> ghc version 7.6.3, cabal version 1.20.0.2
14:42:34 <bergmark> pchiusano: missing upper bounds
14:42:43 <ab9rf> pchiusano: ghc
14:42:51 <ab9rf> ghc -v
14:42:53 <bergmark> pchiusano: if you add --contstraint='scientific < 0.3' it shuold work iirc
14:42:57 <pchiusano> bergmark: say more
14:43:00 <jle`> > either id undefined (Left () :: Either () String) :: Either () Int
14:43:01 <lambdabot>  Couldn't match type ‘()’ with ‘Data.Either.Either () GHC.Types.Int’
14:43:01 <lambdabot>  Expected type: Data.Either.Either
14:43:01 <lambdabot>                   (Data.Either.Either () GHC.Types.Int) GHC.Base.String
14:43:01 <lambdabot>    Actual type: Data.Either.Either () GHC.Base.String
14:43:11 <ab9rf> pchiusano: or constraining aeson < 0.7
14:43:21 <bergmark> pchiusano: or use aeson 0.7.0.6 which has proper bounds and doesn't suffer from DoS
14:43:45 <pchiusano> so, is it the case that aeson has wrong upper bounds in 0.7.0.3?
14:43:46 <ab9rf> i've had hellacious difficulties using aeson 0.7 with ghc 7.6.3
14:43:56 <bergmark> pchiusano: yes
14:44:01 <ski> bergmark : with arguments in that order ?
14:44:18 <pchiusano> okay, that is helpful
14:44:26 <bergmark> ski: huh?
14:46:41 <ski> bergmark : would the ordering `\c f g p o n -> c <$> join (p <$> f o <*> g n)' (or even moving `c' past `f' and `g') be ok ?
14:46:42 <bergmark> pchiusano: aeson 0.7.0.4 and 0.7.0.6 are the only in the 0.7 series that aren't deprecated if you check http://hackage.haskell.org/package/aeson/preferred
14:46:52 <bergmark> ski: yes!
14:48:33 <bergmark> f and g should probably ge grouped together since they are similar, and the same for o and n
14:50:06 <pchiusano> bergmark: but it looks like 4.2 of lens is still using 0.7.0.3
14:50:41 <bergmark> pchiusano: it is a bit wierd that it'd try to install 0.7.0.3 for you at all, maybe you had scientific 0.3 installed first, i think already installed dependencies have higher priority than deprecation in the dependency solver
14:51:21 <bergmark> pchiusano: check http://hackage.haskell.org/package/lens, it allows aeson 0.7.*
14:51:51 <ocharles> ReinH: btw, your comment on HaskellDB being able to do optimisation doesn't really hold
14:52:04 <pchiusano> bergmark: hmm weird
14:52:13 <pchiusano> i wonder why it is using that version
14:52:23 <ocharles> ReinH: you need statistical information on your database to do optimisation. I mean you can do *some* stuff without that info, but any database engine should already be doing at least that much
14:52:34 <bergmark> pchiusano: do you already have lens 4.2 installed? or what do you mean?
14:52:39 <ocharles> The real optimisation is "should I join this now or later?" which you just can't figure out statically :(
14:53:16 <pchiusano> bergmark: I have a library that depends on lens >= 4.2 (not aeson, directly)
14:53:40 <pchiusano> it appears that it pulled in 0.7.0.3 of aeson
14:53:54 <pchiusano> perhaps that is due to some other dependency I have that pulls in aeson though
14:54:03 <bergmark> ocharles: right, especially postgres is good at this :-)
14:54:08 <ocharles> yea
14:54:17 <ocharles> it's insane what you can throw at PG and have it figure out the right thing
14:54:40 <bergmark> pchiusano: one way to check is `cabal install foo --constraint='aeson >= 0.7.0.6' --force-reinstalls --dry-run'
14:55:07 <bergmark> pchiusano: that should always succeed in giving you a build plan unless someone has an upper bound more restrictive than that
14:56:30 <pchiusano> bergmark: okay, thanks, that is helpful
14:57:27 <bergmark> pchiusano: problems like these are almost always because of incremental installs, you do 'cabal install x` which can use the latest version of `a', and then you `cabal install y' which needs an older version of `a'
14:58:22 <bergmark> hopefully bitemyapp's article will cover this!? :-O
14:59:33 <bergmark> this is also what makes me dislike the haskell platform, even if you use cabal sandboxes it will reuse the HP-installed dependencies by default and you'll get into this mess anyway
15:00:04 <monochrom> soon, you will also dislike GHC because it comes with bytestring
15:00:10 <bergmark> :-)
15:00:11 <fread2282> also not using the latest GHC is more likely to cause dependency problems
15:00:53 <bergmark> hackage was 7.8 compatible extremely quickly, 
15:01:30 <bergmark> switched a week after the release and only had to send two pull requests
15:02:10 <pchiusano> bergmark: hmm, is there a way to disable that
15:02:23 <fread2282> should I be using a full parser library for just parsing an int64?
15:02:55 <bergmark> pchiusano: hmm i'm not sure, you could try cabal install --no-user-package-db, not sure if that works
15:03:28 <bergmark> fread2282: probably not...
15:04:16 <bergmark> fread2282: but are you sure it matters?
15:06:46 <erikd> fread2282: if you just want to parse an Int64 from a ByteString, have a look at readDecimal from the bytestring-lexing package
15:10:18 <ski> @let infixr 9 ~>; (~>) :: (a1 -> a0) -> (b0 -> b1) -> ((a0 -> b0) -> (a1 -> b1)); (f ~> h) g = h . g . f
15:10:20 <lambdabot>  Defined.
15:13:13 <shachaf> :t dimap `asTypeOf` (~>)
15:13:14 <lambdabot> (a -> b) -> (c -> d) -> (b -> c) -> a -> d
15:14:45 <Philonous> What's the "best" way for binding to C at the moment? Is it still c2hs?
15:16:08 <orzo_> i normally just use ffi to make the particular function i need available
15:17:24 <Philonous> orzo_, That's OK for a handful of functions maybe. But writing all that boilerplate marshaling code quickly gets old.
15:17:51 <ski> @let bindM2 :: Monad m => (a -> b -> m c) -> (m a -> m b -> m c); bindM2 f ma mb = join (liftM2 f ma mb)
15:17:53 <lambdabot>  Defined.
15:18:38 <shachaf> The best part is when you can convert do-notation to bindM2 and similar.
15:18:57 <ski> @type (\f g c -> (f ~> g ~> liftM c) . bindM2) :: Monad m => (a1 -> m a0) -> (b1 -> m b0) -> (c0 -> c1) -> ((a0 -> b0 -> m c0) -> (a1 -> b1 -> m c1))
15:18:59 <lambdabot> Monad m => (a1 -> m a0) -> (b1 -> m b0) -> (c0 -> c1) -> (a0 -> b0 -> m c0) -> a1 -> b1 -> m c1
15:19:12 <ski> bergmark : ^ best i could figure out atm
15:19:13 * hackagebot parsers 0.11.0.2 - Parsing combinators  http://hackage.haskell.org/package/parsers-0.11.0.2 (EdwardKmett)
15:19:13 <kazagistar> is LYAH down for anyone else?
15:19:32 <ski> shachaf ?
15:20:11 * ski is a bit surprised `bindM2' hasn't found its way into `Control.Monad'
15:20:17 <dmj`> kazagistar: there are other links to the pdf
15:20:57 <albeit> Do case statements in Haskell fall through? "case t of; 0 ->; 1 -> f; 2 -> g" will do f for both 0 and 1?
15:21:29 <zwer> albeit no
15:21:32 <shachaf> ski: In some cases you can use Applicative instead of Monad for efficiency. But sometimes you can't completely switch to Monad, but you can still go part of the way by rewriting code to use join along with Applicative operators.
15:21:59 <zwer> albeit does that even compile?
15:22:13 <albeit> zwer: Didn't try ;) Was also wondering if there was some way to do that...?
15:22:52 <guymann> hi
15:22:53 <shachaf> ski: As in do { x <- a; y <- b; z <- f x y; g z } into join (fmap g (join (liftA2 f x y)))
15:23:27 <Philonous> albeit, No, but you can use pattern guards to avoid repeating patterns a lot
15:23:58 <Philonous> albeit, case x of x' | 1 < x && x < 10 -> ...
15:24:17 <Philonous> albeit sorry, I meant , case x of x' | 1 < x' && x' < 10 -> ...
15:24:22 <albeit> Philonous: Good call, switching to pattern guards
15:26:28 <haiden> is there some operator or a function for composing predicates? even <op> (>0)  should return a predicate that returns True if argument is an even positive number
15:26:51 <shachaf> You can say liftA2 (&&) even (>0)
15:27:04 <ski> @let infixl 4 <*>>; (<*>>) :: Monad m => m (a -> m b) -> (m a -> m b); mamb <*>> ma = join (mamb `ap` ma)
15:27:07 <lambdabot>  Defined.
15:27:18 <ski> @type \f ma mb -> f <$> ma <*>> mb
15:27:20 <lambdabot> (Functor m, Monad m) => (a1 -> a -> m b) -> m a1 -> m a -> m b
15:27:29 <ski> @type \f ma mb mc -> f <$> ma <*> mb <*>> mc
15:27:30 <lambdabot> (Applicative m, Monad m) => (a2 -> a1 -> a -> m b) -> m a2 -> m a1 -> m a -> m b
15:29:07 <monochrom> interesting. I thought <*>> was a typo :)
15:31:07 <ski> @type \a b f g -> do { x <- a; y <- b; z <- f x y; g z}
15:31:08 <lambdabot> Monad m => m t -> m t1 -> (t -> t1 -> m t2) -> (t2 -> m b) -> m b
15:31:12 <ski> @type \a b f g -> g =<< f <$> a <*>> b
15:31:13 <lambdabot> (Functor m, Monad m) => m a2 -> m a1 -> (a2 -> a1 -> m a) -> (a -> m b) -> m b
15:31:17 <ski> shachaf : like that ?
15:31:21 <ski> monochrom : no :)
15:31:55 <ski> @type \f ma mb -> f <*> ma <*>> mb
15:31:57 <lambdabot> (Applicative m, Monad m) => m (a1 -> a -> m b) -> m a1 -> m a -> m b
15:32:00 <ski> @type \f ma mb mc -> f <*> ma <*> mb <*>> mc
15:32:01 <shachaf> ski: More along the lines of an automatic compiler transformation.
15:32:01 <lambdabot> (Applicative m, Monad m) => m (a2 -> a1 -> a -> m b) -> m a2 -> m a1 -> m a -> m b
15:32:03 <ski> also work, of course
15:32:07 <benzrf> :t (<*>>)
15:32:09 <lambdabot> Monad m => m (a -> m b) -> m a -> m b
15:32:12 <benzrf> o.o
15:32:24 <ski> shachaf : is probably semantics-changing
15:32:37 <benzrf> @src (<*>>)
15:32:37 <lambdabot> Source not found. You untyped fool!
15:32:42 <shachaf> ski: Given the laws that pure=return, ap=(<*>)?
15:32:52 * shachaf uses = symmetrically.
15:32:52 <benzrf> :t (join .) . (<*>)
15:32:53 <lambdabot> (Applicative m, Monad m) => m (a1 -> m a) -> m a1 -> m a
15:32:56 <ski> benzrf : it's useful for `bindM2'-like stuff (see above), but used more like `ap'/`(<*>)'
15:33:13 <benzrf> :t bindM2
15:33:14 <lambdabot> Monad m => (a -> b -> m c) -> m a -> m b -> m c
15:33:14 <benzrf> p:
15:33:14 <ski> shachaf : yes, assuming that
15:33:19 <benzrf> eenteresting
15:33:22 <shachaf> ski: How?
15:33:24 <ski> shachaf : hmm
15:33:35 <benzrf> :t liftM2
15:33:36 <lambdabot> Monad m => (a1 -> a2 -> r) -> m a1 -> m a2 -> m r
15:33:41 <benzrf> oic
15:34:21 <ski> shachaf : or i suppose i'm probably thinking about cases where `ap = (<*>)' does *not* hold
15:34:41 <jfischoff> shachaf: it could make a serial execution become parallel no?
15:35:03 <shachaf> ski: OK, but that's going to be a law and is arguably already a law.
15:35:07 <shachaf> jfischoff: Maybe?
15:35:42 <ski> benzrf : sometimes you have an `liftM2 f ma mb', and you now want to also allow `f' to perform effects .. you can wrap with a `join', but it can look a bit cumbersome
15:36:06 <wei> .
15:36:06 <dmj`> this question might be dumb, but is it possible for an exception to escape to the top level of an application after its been caught?
15:37:50 <ski> shachaf : the example i was mostly thinking of was basically (a wrapped, then) `Either e' with `Monoid e' (or better `Semigroup e'), where `(<*>)' calls `mappend'
15:39:17 <ski> shachaf : but where you'd also often want a monadic `(>>=)', which obviouslty can't collate exceptions
15:39:38 <jfischoff> dmj`: no but it is easy to think you are catching an exception when infact you are not
15:40:08 <corgifex> dmj`: is it the same exception if you reraise it?
15:40:16 <corgifex> this is getting philosophical
15:40:18 <ski> (shachaf : the other example was Magnus Carlsson's adaptive/incremental computation monad, which iirc also features an `(<*>)'-like operator, which isn't exactly `ap')
15:41:43 <ski> shachaf : any suggestion for how to handle such suggestions ? anything better than explictly passing between two distinct types (one for the `Monad', the other for the `Applicative') ?
15:41:53 <ski> s/such suggestions/such cases/
15:43:07 <dmj`> jfischoff, corgifex: I am catching a "ConnectionClosed" exception, printing to stdout that I caught it, but yet on my servers top-level logs it says "ConnectionAbruptlyTerminated" has escaped to the top level
15:43:15 <dmj`> http://lpaste.net/105417
15:43:37 <dmj`> I guess multiple exceptions might be thrown at once..
15:44:11 <dmj`> it appears they happen at the exact same time, viewing the logs with tail -f log/error.log
15:44:50 <jfischoff> what is the return value of handleConnection, also you should probably be using bracket
15:45:41 <jfischoff> anyway, whatever the return value is, is not fully evaluate is my guess,
15:45:55 <dmj`> jfischoff: I am using bracket to cleanly close it (send a close message, remove the connection from the MVar Intmap Connection), maybe I'm using it improperly
15:46:03 <dmj`> http://lpaste.net/105418
15:46:10 <jfischoff> no I just didn’t see it there
15:46:35 <dmj`> handleConnection :: UID -> WS.Connection -> MVar WSClients -> IO ()
15:47:15 <jfischoff> okay I don’t think my first guess is right
15:47:15 <dmj`> I mean yea, let me paste it all :)
15:48:29 <dmj`> http://lpaste.net/105420
15:48:34 <dmj`> jfischoff: ^
15:48:55 <jfischoff> dmj`:brb
15:49:06 <dmj`> k
15:50:28 <WilliamD`> so, there are key packages I can't compile w cabal install because ghc lacks interactive support on arm, needed for TH brackets. like aeson. yet, there are debs for some such libraries. well, cabal install doesn't seem to notice I've installed these packages globally via apt, and tries to build aeson again. and fails. Am I supposed to tell it to skip a dependency somehow, or how to proceed.
15:51:38 <shachaf> ski: You mean cases where you have an Applicative instance which is incompatible with ap/return?
15:51:46 <shachaf> (Such as ZipList?)
15:52:02 <ski> yes, that's another example, i suppose
15:52:16 <ski> but i think my examples above are more practically interesting
15:52:36 <shachaf> I don't have a good answer.
15:52:47 <Tjr> Hmm, it just occurred to me that the main function never does anything. It returns an IO action, which then actually does things.
15:53:03 <ski> (because the difference between `ap' and `(<*>)' there in some sense seems less)
15:53:16 <ski> Tjr : yes :)
15:53:22 <ski> also, it's not a function
15:53:28 <shachaf> It doesn't return an IO action and it's not a function.
15:53:32 <shachaf> It is an IO action.
15:53:34 <zwer> main *is* an IO action
15:53:42 <Tjr> ?
15:53:51 <ski>   main :: IO a
15:54:00 <ski> no arguments here, so it's not a function
15:54:03 <shachaf> Just 5 :: Maybe Int -- not a function, doesn't return a Maybe action
15:54:07 <Tjr> isn't that a 0-parameter function?
15:54:12 <ski> no such thing
15:54:25 <ski> every function takes exactly one argument in Haskell
15:54:56 <hpc> Tjr: "everything is a function" leads to confusion
15:54:59 <hpc> confusion leads to anger
15:55:01 <hpc> anger leads to lisp
15:55:03 <Tjr> I guess I'll read up on command line arguments soon enough.
15:55:05 <ski> when we say "two-argument function", we *usually* mean "function that returns function" (sometimes we mean "function that accepts a pair")
15:55:07 <hpc> lisp leads to the dark side
15:55:15 <Tjr> hpc: never say anger leads to bad things.
15:55:28 <Tjr> :-)
15:55:32 <hpc> :P
15:55:35 <corgifex> :t getArgs
15:55:36 <lambdabot> Not in scope: ‘getArgs’
15:55:53 <corgifex> @hoogle getArgs
15:55:55 <lambdabot> System.Environment getArgs :: IO [String]
15:55:55 <lambdabot> System.Posix.Env.ByteString getArgs :: IO [ByteString]
15:55:55 <lambdabot> Graphics.UI.GLUT.Initialization getArgsAndInitialize :: IO (String, [String])
15:58:22 <chrisdone> hpc: *that* is why you fail :: Monad m => String -> m ()
15:58:24 <haiden> print is a function though, correct
15:58:29 <haiden> ?
15:58:36 <shachaf> Yes.
15:58:39 <corgifex> :t print
15:58:40 <lambdabot> Show a => a -> IO ()
15:58:45 <corgifex> -> in its type, right there
15:59:13 <corgifex> > let x = print "hello" in length [x, x, x]
15:59:15 <lambdabot>  3
15:59:25 <corgifex> I can apply print to an argument ("hello")
16:00:46 <tikhon> Hey, has anyone here used shpider to write a web crawler?
16:04:58 <jfischoff> > return undefined `catch` \(e :: SomeException) -> print e
16:05:00 <lambdabot>  <IO ()>
16:05:07 <WilliamD`> interesting, using a constraint on the version worked. one step closer, though grossly inelegant
16:05:23 <jfischoff> > (return $! undefined) `catch` \(e :: SomeException) -> print e
16:05:24 <lambdabot>  <IO ()>
16:06:00 <jfischoff> that’s not what ghci does
16:06:16 <corgifex> true
16:06:28 <corgifex> ghci special cases IO actions
16:06:40 <corgifex> lambdabot just calls show
16:06:44 <jfischoff> ah
16:07:15 <blochchain> i'm in a messy situation in which i need to bootstrap GHC from 6.8.3 because my research machine is Scientific Linux 5 and I don't have sudo. when running ./configure while installing 7.0, i'm told I don't have GHC installed because it isn't in /usr/bin. How do i let the config script know where the old copy is?
16:07:35 <corgifex> is it in your PATH?
16:08:08 <Tjr> In http://byorgey.wordpress.com/2010/04/03/haskell-anti-pattern-incremental-ad-hoc-parameter-abstraction/#comment-1998 the line
16:08:09 <Tjr> fun exp = let (PP{..}) = mkPP myPPConf in ppExpr exp
16:08:32 <Tjr> Does the let simply assing a variable PP?
16:08:43 <corgifex> no, variables can't start with uppercase letters
16:08:55 <Tjr> What does it do, then?
16:08:59 <corgifex> PP is a constructor
16:09:00 <blochchain> it's --with-hc
16:09:19 <corgifex> Tjr: I'm assuming there's a language extension or two active
16:09:34 <corgifex> using {..} to unpack all record fields as variables into the current scope
16:09:38 <Tjr> corgifex: yes, RecordWildCards
16:10:18 <shachaf> If you already know that it's RecordWildCards, what's the question?
16:10:41 <Tjr> I just don't fully understand how this piece of code works.
16:11:31 <geekosaur> PP{..} is a pattern matching a record constructor PP and binding its fields to similarly named local bindings
16:11:32 <jfischoff> dmj`: I added an evaluate: http://lpaste.net/105420
16:11:39 <jfischoff> just a guess really
16:12:04 <Tjr> hence ppExpr in this example, right
16:12:05 <Tjr> ?
16:12:10 <geekosaur> so it uses mkPP to create a PP record, then locally binds its fields and uses them
16:12:53 <geekosaur> I presume that's where ppExpr comes from
16:13:19 * geekosaur pops the link since the only PP he knows doesn't have a ppExpr (or a mkPP, for that matter)
16:13:23 <Tjr> why doesn't the line have to read
16:13:23 <Tjr> fun myPPConf  exp = let (PP{..}) = mkPP myPPConf in ppExpr exp
16:13:36 <dmj`> jfischoff: thanks! I'll try it out
16:13:39 <dmj`> right now
16:13:51 <geekosaur> ah, yes, there it is
16:14:21 <geekosaur> myPPConf is bound elsewhere
16:14:40 <geekosaur> they're just not showing it
16:15:05 <geekosaur> (it would be some set fo defaults in a PPConf record, used by mkPP)
16:15:09 <Tjr> so they're using one global variable for the "config", right?
16:15:16 <Tjr> Kind of defeats the purpose IMHO
16:15:22 <blochchain> sait, it's still not working
16:15:33 <blochchain> *wait
16:15:35 <blochchain> i'm in a messy situation in which i need to bootstrap GHC from 6.8.3 because my research machine is Scientific Linux 5 and I don't have sudo. when running ./configure while installing 7.0, i'm told I don't have GHC installed because it isn't in
16:15:38 <Tjr> Or is there somthing I'm not getting?
16:17:16 <geekosaur> PPConf is a configuration. it's used to instantiate a PP, which is then used to render a document. PP can't be parameterized easily, but PPConf can
16:17:36 <geekosaur> as I'm reading it, at least
16:19:04 <Tjr> Say I want to call "fun" with a slightly different "myPPConf". Wouldn't the code snippet require me to define some function fun' ?
16:19:33 <geekosaur> Tjr: it's a simplified version of the same trick that Parsec uses to achieve "parameterized modules" in Text.Parsec.Token and Text,Parsec.Language
16:20:13 <geekosaur> RecordWildCards lets you remove some of the boilerplate that Parsec uses to accomplish the same thing, with definitions in T.P.Language allowing you to "parameterize" T.P.Token
16:22:22 <dmj`> jfischoff: still same, appreciate it though
16:23:18 <jfischoff> turn on stack traces and see where it is getting thrown
16:24:59 <Tjr> geekosaur: good to know where it's from. Is it correct that the function "fun" is intended to be called with one specific config "myPPConf" and none else?
16:26:05 <dmj`> jfischoff: how do I do that? Run the app in ghci?
16:26:12 <geekosaur> sort of? the point is that myPPConf is how you are specifically parameterizing the module that creates/uses a PP
16:26:36 <geekosaur> so it's a specific one for *your* application, but someone else with a different need (presumably a different document style) would use a different one
16:26:55 <flaggy> hello. I'm trying to mix HUnit and quickcheck tests in the same project
16:27:23 <flaggy> I'm using tasty and defaultMain $testGroupGenerator to run the tests. Is there a way to do the same with HUnit test cases?
16:27:39 <geekosaur> if you create multiple documents with different types, you might have a different helper for each one, or maybe do something more complex; btu the point is to simplify the common case where you need one specific document type
16:27:49 <Tjr> geekosaur: ok, thank you. That clears it up.
16:27:51 <geekosaur> while allowing the module to support multiple document types
16:28:43 <Tjr> geekosaur: I had Mathematica's OptionPattern[] in mind, where you would specify the parts of the options "myPPConf " that change, every time you call the function "fun"
16:28:58 <Tjr> * OptionsPattern[], with an s-
16:31:58 <jfischoff> dmj`: compile with profiling and some RTS flag I think -xc or something brb
16:37:48 <dmj`> jfischoff: oh man... the VM I'm running on didn't have library-profiling : True turned on... when the deps went into the sandbox. Here comes a 30 minute install... *punches self in face*
16:38:36 <jfischoff> I wonder if just exectuable-profiling is enough if you are just testing your code? not sure
16:38:55 <Axman6> dmj`: make sure you have cabal 1.20 and then call cabal with -j to get parallel builds. makes things a hell of a lot faster
16:39:20 <benzrf> hey yo
16:39:30 <acowley> Rebuilding big sandboxes usually uses whatever cores I have even without -j
16:40:02 <acowley> But I don't have many cores :(
16:47:58 <kardboardb> Is there a generic version of partition, i.e. one that operates on more than just lists?
16:49:23 * hackagebot request-monad 0.3.0.0 - A transformer for generic requests  http://hackage.haskell.org/package/request-monad-0.3.0.0 (nahiluhmot)
16:49:31 <Tjr> kardboardb: (newbie here) there is a Foldable module, which generalizes a lot of map-over-list-things into map-over-anything things
16:50:47 <acowley> kardboardb: Since you need to build up new structures for either side of the partition, going by way of lists is probably fine
16:51:03 <kardboardb> Tjr: Right, I've been trying to figure out how partition could fit in Foldable, but I can't see how it can.
16:53:13 <kardboardb> acowley: Well, I'm working on a function that uses partition on its input, and I'd like to have it accept more than just lists. But as you say, I'll probably just have to convert the input/output to/from lists.
16:54:04 <acowley> kardboardb: Yeah, and Foldable fills that niche. But if you think about how you want to consider each element individually, then build up two structures from streams of input elements... lists are what you want.
16:55:20 <ReinH> partition is trivially generalizable to Foldable (it just uses foldr) so I'm sort of surprised it isn't in Foldable already.
16:56:18 <kardboardb> ReinH, the problem is when you get to the implementation of select, you don't an equivalent of cons for Foldables as you do with Lists.
16:56:48 <ReinH> kardboardb: It wouldn't be able to rebuild the structure, no
16:56:52 <ReinH> but that's not what Foldable is for
16:57:27 <acowley> I think that's the point
16:57:42 <acowley> sclv wrote an article on FP Complete about a Buildable type thing
16:58:04 <acowley> But I don't recall how firm the design was left
16:58:06 <kardboardb> That's the problem with Foldable, yes -- which is why partition isn't "trivially generalizable to Foldable"
16:58:11 <bitemyapp> acowley: is Buildable an extension to monoid?
16:58:22 <ReinH> kardboardb: sure it is
16:58:37 <ReinH> And it isn't a "problem", it's the design of the typeclass
16:59:11 <kardboardb> It's a "problem" if you're trying to implement partition with Foldable.
16:59:24 <ReinH> your version, which isn't partition, yes
16:59:27 <acowley> bitemyapp: Here's the article I was thinking of: https://www.fpcomplete.com/user/gbaz/building-up-to-a-point-via-adjunctions
16:59:33 <bitemyapp> acowley: thanks
16:59:49 <ReinH> Partition, which returns a tuple of lists *is* a fold
17:00:01 <ReinH> Generalizing partition is trivial
17:00:08 <ReinH> generalizing your thing with Foldable is impossible
17:00:13 <kardboardb> Only if it outputs lists.
17:00:15 <kardboardb> Right.
17:00:17 <acowley> It provides what kardboardb needs
17:00:20 <ReinH> Yes. That's what it does.
17:00:44 <kardboardb> You would lose any extra information attached to each member like that (eg. keys in a map).
17:00:57 <ReinH> Yes, that's how Foldable works.
17:01:14 <ReinH> It's about converting a structure into a single value
17:01:34 <kardboardb> Yep! And that's why Foldable doesn't work here. Which is where I was in the first place.
17:01:39 <ReinH> Sure it does.
17:01:45 <acowley> bitemyapp: If you read the article, remind me what shortcomings it has that justify it not being a thing we have to play with :)
17:01:45 <ReinH> Not for your needs.
17:01:51 <ReinH> But as a generalization of partition it's trivial.
17:02:06 <ReinH> You literally just move the code over and use Foldable.foldr instead of Data.List.foldr
17:02:33 <jle`> @src partition
17:02:33 <lambdabot> partition p xs = foldr (select p) ([],[]) xs
17:02:33 <lambdabot>     where select p x ~(ts,fs) | p x       = (x:ts,fs)
17:02:33 <lambdabot>                               | otherwise = (ts, x:fs)
17:02:34 <kardboardb> Only for a version of partition that outputs lists, which isn't what I'm looking for.
17:02:43 <ReinH> kardboardb: Right, it doesn't work for your thing, which isn't partition.
17:02:46 <ReinH> I'm talking about partition.
17:02:49 <jle`> :t Foldable.foldr
17:02:50 <lambdabot> Not in scope: ‘Foldable.foldr’
17:03:56 <kardboardb> ReinH, I know that; this is sitting on my screen right now: partitionF p xs = Foldable.foldr (select p) ([], []) xs
17:04:33 <kardboardb> Which fills your definition of partition, which is one that only outputs lists, which isn't what I'm looking for.
17:05:19 <ReinH> I'm not sure how yours can be generalized at all
17:05:27 <Tjr> More to the point, is there a reasonable way to build up a general Foldable structure?
17:05:37 <kardboardb> ReinH, that's exactly my problem.
17:05:48 <ReinH> Tjr: what do you mean?
17:06:23 <Tjr> For example, the Foldable package gives trees as an example. What would kardboardb's solution look like for trees?
17:07:02 <ReinH> Tjr: It doesn't give a way to construct a value of type Foldable a => a, no
17:07:15 <acowley> I linked an article that describes a way of doing that a few minutes ago
17:08:39 <silver> Tjr, you need to define a way to fold. that's it
17:10:09 <Tjr> acowley: from your link, "We define first a semigroup with an associative operation (*)" That's not going to work for trees
17:11:09 <ReinH> acowley: so it's right adjoint to Foldable
17:12:05 <ReinH> Tjr: That is dealt with later on.
17:12:13 <ReinH> You don't need an isomorphism, just an adjunction
17:13:16 <acowley> What's the problem of defining a semigroup for trees?
17:13:54 <ReinH> acowley: associativity
17:14:41 <jle`> it'll still Fold the same way though, right?
17:14:52 <jle`> i guess if it's in-order
17:15:41 <ReinH> You can do some hand waving like diagrams does and claim that they are "morally" associative ;)
17:15:48 <jle`> heh
17:15:54 <Tjr> kardboardb: I'm too tired right now to think, but I've got this hunch that it's indeed possible to use the Foldable space-of-ideas to do what you want. It's definitely a interesting problem.
17:15:56 <acowley> Hm, yeah
17:16:08 <jle`> i just remember that the naive tree merge forms the Free Magma
17:16:19 <jle`> which can't have anything "more" than a magma
17:16:24 <jle`> so...it can't be a semigroup?
17:16:30 <jle`> ...is that okay to say
17:16:33 <jle`> >_>
17:17:27 <kardboardb> Tjr: That's the feeling I get from it; still trying to work out how.
17:21:13 <ReinH> acowley: Yet another problem solved by kan extensions ;)
17:21:28 <acowley> ReinH: Such a slippery concept
17:21:33 <Tjr> kardboardb: I'd try to guess a reasonable "abstract cons", i.e. an additional structure to the Foldable class that lets you build up Foldable structures. Reasonable means it should work for lists, trees, associative monoids, and maybe some other special cases that capture the gist of foldable.
17:21:48 <ReinH> Tjr: did you not read the rest of the article?
17:22:09 <Tjr> ReinH: no. it specializes to lists, assumes associativity, and I'm a bit tired right now.
17:22:24 <ReinH> Tjr: Er. It does neither of those two things.
17:22:36 <ReinH> More to the point, it presents exactly the concept you're talking about
17:22:37 <acowley> Tjr: Well, when you're not tired you should read it while thinking about these questions! It's quite good.
17:23:38 <jle`> ReinH: if you eventually fold the tree in-order to use it, is it associative?
17:24:02 <acowley> It's the usual adjunction story
17:24:12 <ReinH> jle`: if the only thing you can observe is the fringe, I suppose it is
17:24:51 <ReinH> I usually wait to finish a paper before I decide to disagree with its conclusions.
17:25:24 <ReinH> jle`: but then your tree is just a funny way of representing a list ;)
17:26:12 <jle`> true, i guess it would have unobservable internal structure
17:26:20 <acowley> like I said, the usual adjunction story :P
17:26:36 <acowley> wash off the interesting bits, then go back and forth at will
17:26:42 <ReinH> acowley: :)
17:26:46 <jle`> are you referring to me acowley ?
17:27:01 <acowley> I have no intention of washing you jle`
17:27:19 <jle`> good because i reserve all washing rights
17:27:34 <acowley> Kan called dibs
17:27:35 <ReinH> acowley: Oh adjunctions. That's cute. I'm using kan extensions now. You've probably never heard of them. </hipster category theorist>
17:27:39 <jle`> what is this adjunction story, the latest taylor swift songg?
17:27:53 <jle`> i should probably actually read up on what those are.
17:27:57 <acowley> I don't think Swift's type system can express it
17:28:06 <jle`> will this come up in Catsters eventually
17:28:13 <ReinH> adjunctions? yep
17:28:13 <acowley> yes
17:28:16 <ReinH> there's a whole series on them
17:28:17 <jle`> ok neat
17:28:22 <jle`> acowley: :P
17:28:55 <jle`> will be looking forward to resuming them after finals
17:31:45 <ReinH> They don't cover kan extensions though. :(
17:32:11 <jle`> kaaannn!
17:32:13 <jle`> ...
17:32:18 * jle` should probably get back to studying
17:32:38 <benzrf> h
17:33:06 <acowley> "Use the functor, jle`" -- Mr. Miyagi
17:39:28 <streblo> alright, i'm going to do it! i'll learn haskell
17:39:32 <streblo> but first
17:39:36 <streblo> i need a sticker for my laptop
17:39:42 <streblo> where do i get one?
17:40:01 <vanila> I want a haskell sticker too
17:41:33 <acowley> The stickers are in Hawaii now: https://twitter.com/dysinger/status/472869208447913985
17:42:13 <ReinH> Edward had better have stickers in Chicago :(
17:42:37 <streblo> is haskell similar to ML?
17:43:10 <acowley> streblo: Yes!
17:44:29 <bergmark> edward had a million stickers in zurich at least :-)
17:46:36 <dmj`> ReinH: are you coming to chicago for lambda jam?
17:46:48 <ReinH> dmj`: looks that way
17:46:56 <dmj`> ReinH: shweet
17:47:01 <ReinH> dmj`: agree!
17:56:25 <ski> streblo : but there's also important differences
17:57:11 <ski> streblo : btw, in case you didn't know, there's also an #sml channel on the network
18:02:32 <Fuuzetsu> Any RHL/CentOS users here? What packages does one install to get GHC + Cabal environment?
18:02:58 <Fuuzetsu> ‘haskell-platform’?
18:05:04 <slack1256> Does uniplate and syb have the same purpose of traverse data structures making queries or transforming, or are about different use cases?
18:05:56 <streblo> ski: cool, just curious. i'm not super familiar with ML, just read purely functional datastructures and was wondering how hard it would be to translate that to haskell
18:06:59 <zzo38> Is this considered OK?   hGetContents' = hGetContents >=> liftA2 seq length return;
18:09:19 <zzo38> Do you think this is OK?   withDir f j = getCurrentDirectory >>= (setCurrentDirectory f *>) . (j <*) . setCurrentDirectory;
18:09:43 <Fuuzetsu> I think ‘(\x -> length x `seq` x) <$> hGetContents’ is more obvious although I'm unsure if it will give the same result
18:10:18 <zzo38> Fuuzetsu: Maybe
18:10:48 <zzo38> I just don't like the existing getContents because lazy I/O makes it impure so I did this one instead
18:11:18 <Fuuzetsu> use a library which does these things for you
18:11:28 <zzo38> I could do that.
18:11:54 <Fuuzetsu> there's even https://hackage.haskell.org/package/strict-io although I'm not sure if it's up to date
18:11:59 <zzo38> O, OK
18:12:23 <Fuuzetsu> but there are other solutions like pipes &c
18:12:48 <slack1256> although is worth even knowing pipes for the neat techniques it enables.
18:13:03 <bitemyapp> zzo38: do you need Text or ByteString? They have strict IO
18:13:03 <zzo38> Yes, although I don't like the way the normal Haskell system does it
18:13:11 <bitemyapp> zzo38: there's pipes, conduit, and simple-conduit as well.
18:13:24 <zzo38> bitemyapp: No, I don't need those
18:13:27 <benzrf> pipes v conduit whats the difference?!?!
18:14:52 <Fuuzetsu> benzrf: you'll love the pipes-conduit package!
18:15:00 <benzrf> :o
18:15:04 <benzrf> also machines???
18:15:18 <zzo38> When using internet connection, the lazy I/O won't work very well, also. However, I just think the ordinary getContents and hGetContents are no good and break purity. Pipes might be a better way to do it and retain functional purity, if they are implemented in a good way.
18:15:23 <Fuuzetsu> I should learn pipes properly
18:15:35 <zzo38> Example of internet:   gopherGet h s = withSocketsDo (connectTo h (PortNumber 70) >>= \h -> hPutStr h (s ++ "\r\n") >> hFlush h >> hGetContents' h);
18:16:15 <Fuuzetsu> pipes solve this one
18:16:35 <zzo38> Then show me how?
18:16:58 <bitemyapp> Fuuzetsu: you should learn simple-conduit properly, then pipes :)
18:17:36 <benzrf> 1. how is conduit vs pipes vs machines ?!
18:17:53 <benzrf> 2. how i write arbitrary char grids no scroll vim style
18:18:46 <zzo38> I don't actually know how to use continuations in any programming language other than Haskell, although I do have some idea of how something similar would be done in Forth.
18:18:52 <Fuuzetsu> bitemyapp: why go through simple-conduit?
18:21:46 <zzo38> But why is continuation programming generally done by Peirce's law and not law of excluded middle? I find law of excluded middle easier to work with. Did you know that?    lemCC = ContT $ \c -> c $ Right (\a -> ContT $ \_ -> c (Left a));  callCC x = lemCC >>= either return x;
18:22:15 <ski> zzo38 : you could learn Scheme, there are several papers discussion continuations, which use Scheme for examples
18:22:40 <zzo38> ski: OK, I can try to learn, but can Scheme to law-of-excluded-middle-continuations?
18:22:43 <ski> zzo38 : in SML/NJ, continuations aren't by Peirce's law
18:22:47 <bitemyapp> Fuuzetsu: wondrously simple.
18:23:22 <zzo38> In fact you can implement either one in terms of the other, for example:   lemCC = callCC (return . Right . (<=< return . Left));
18:23:47 <zzo38> ski: What is SML/NJ and what are they then by?
18:23:53 <ski>   ; call-with-current-continuation : (((A) -> B) -> A) -> A  ; Scheme
18:24:13 <ski>   (* `SMLofNJ.Cont' : *)
18:24:18 <ski>   val callCC : ('a cont -> 'a) -> 'a
18:24:29 <ski>   val throw : 'a cont -> 'a -> 'b
18:24:32 <zq> @hoogle Word8 -> Word8 -> Word16
18:24:34 <lambdabot> Data.Function on :: (b -> b -> c) -> (a -> b) -> a -> a -> c
18:24:35 <lambdabot> Prelude curry :: ((a, b) -> c) -> a -> b -> c
18:24:35 <lambdabot> Data.Tuple curry :: ((a, b) -> c) -> a -> b -> c
18:24:48 <ski> where `cont' is to be read as (postfix) negation
18:24:59 <zzo38> ski: Yes, that is what I thought as soon as I saw it
18:25:14 <ski>   val lem : unit -> ('a,'a cont) either  (* is easily codable in SML/NJ *)
18:26:41 <Fuuzetsu> zq: what do you want the function to do?
18:26:50 <ski> zzo38 : "Continuations and Continuation Passing Style" <http://library.readscheme.org/page6.html> has references to some papers related to continuations, several of them having Scheme examples
18:26:50 <Fuuzetsu> add? concat? what?
18:27:15 <Fuuzetsu> :t fromIntegral :: Word8 -> Word16
18:27:16 <zq> Fuuzetsu: \high low -> (high << 8) | low
18:27:16 <lambdabot> Word8 -> Word16
18:27:53 <zq> Fuuzetsu: but everything in data.bits operates on Int and i'm pretty sure that an Int is the width of a machine word
18:29:00 <Fuuzetsu> does it matter? if you're shifting by something that fits into Word8 anyway only lower bits  will be shifted
18:29:02 <Fuuzetsu> I think
18:29:12 <zq> never mind
18:29:13 <zzo38> ski: OK
18:29:17 <ReinH>  > (\high low -> shiftL (fromIntegral (high :: Word8)) 8 + (fromIntegral (low :: Word8))) 1 1 :: Word16
18:29:18 <ski> zzo38 : SML/NJ <http://www.smlnj.org/>
18:29:21 <Fuuzetsu> > shift 8
18:29:21 <zq> the Int parameter indicates how many bits to shift
18:29:22 <lambdabot>  <Int -> Integer>
18:29:34 <zq> :t shift
18:29:35 <lambdabot> Bits a => a -> Int -> a
18:29:36 <ski> > shift 8 1
18:29:38 <lambdabot>  16
18:29:41 <ski> > shift 8 3
18:29:43 <lambdabot>  64
18:29:56 <ski> > shift 3 8
18:29:58 <lambdabot>  768
18:29:58 <fread2282> is there an Word7 variable-length library somewhere?
18:29:59 <zq> oh hey lambdabot has a Show instance for functions now
18:30:03 <zq> > print
18:30:05 <lambdabot>  <() -> IO ()>
18:30:14 <ski> zq : been there for a long time ?
18:30:16 <zzo38> As a kind of experiment, I have designed a programming language based on Gentzen's sequent calculus, except that the negation rules are considered as structural rules, making continuations to be implicit. But I don't think continuations can be implicit in Scheme or Haskell??
18:31:13 <ski> zzo38 : LK or LJ ?
18:31:33 <zzo38> ski: LK
18:32:32 <ski> streblo : ok, just in case you already knew some SML, i was mentioning the channel
18:32:36 <ski> streblo : iirc Purely Functional Datastructures has Haskell code in the appendix ?
18:32:55 <Fuuzetsu> yes, I think so
18:33:17 <zzo38> ski: O, it does have Haskell in appendix? I often use Haskell codes for describing functional datastructures too
18:34:41 <benzrf>                jjjjjjjjjjjjjj
18:34:43 <benzrf> oops
18:34:49 <benzrf> > print 3
18:34:50 <lambdabot>  <IO ()>
18:34:54 <Fuuzetsu> inferior-editor user detected
18:35:01 <benzrf> Fuuzetsu: ha
18:35:18 <benzrf> i tend to hold down letters then press ^W to delete the spam
18:35:29 <benzrf> when the letter is j, the ctrl overlaps and sends a CR
18:35:30 <benzrf> >.>
18:35:41 <benzrf> *linefeed
18:35:45 <Fuuzetsu> ^J is pretty good
18:35:54 <benzrf> eh?
18:35:55 <Fuuzetsu> overrides those pesky emacs ‘are you sure’ questions
18:35:56 <zzo38> Yes, CTRL+J is linefeed; CTRL+M is carriage return
18:36:16 <benzrf> irssi woot
18:36:24 <benzrf> [tbh i use arrows in vim]
18:36:28 <benzrf> [pls dont tell]
18:36:38 <Rarrikins> :r
18:36:43 <zzo38> When using vim I use both hjkl and arrow keys actually
18:37:00 <Lutin`> I use arrow when I'm insert mode and just need to do a quick little movement
18:37:08 <benzrf> its cuz i arrow about in insert mode occasionally
18:37:12 <benzrf> so switching is awkwar
18:37:13 <benzrf> d
18:37:14 <zzo38> Lutin`: Yes, same to me
18:37:24 <benzrf> Lutin`: yea
18:37:27 <zzo38> benzrf: Yes, that is what I do too sometimes
18:37:37 <Lutin`> tbh I want to switch to Emacs or some more easily scripted text editor
18:37:43 <Fuuzetsu> you guys should come and contribute to Yi instead~
18:37:44 <Lutin`> but I miss my vim motions
18:38:08 <Lutin`> too much cognitive burden in Emacs IMO
18:38:09 <dsturnbull> emacs has a decent vi emulator
18:38:17 <zzo38> Lutin`: If you want emacs with vim commands, couldn't you do M-x vim or something like that? I don't really know so well emacs working, but I guess like that
18:38:18 <dsturnbull> but i keep coming back to vim
18:38:27 <Lutin`> zzo38: I've heard you could
18:38:32 <Lutin`> but it doesn't feel right
18:38:58 <dsturnbull> it works great, tbh
18:39:01 <Lutin`> Plus I have a lot of production systems I don't want to just start installing things on
18:39:08 <Lutin`> and they only have nano and vi installed
18:39:13 <dsturnbull> there was a new mode in 24.3.x or similar
18:39:15 <Lutin`> and obviously I'm not going to us nano LOL
18:39:52 <zzo38> Althought to exit insert mode I usually use CTRL+[ rather than the escape key, because escape key is a bit far to type (as far as arrow keys, actually)
18:40:01 <Lutin`> Fuuzetsu: You on the Yi dev team?
18:40:17 <Fuuzetsu> is that a trick question because I want you to write code for me
18:40:36 <Lutin`> well I want to write code
18:40:42 <Fuuzetsu> cool
18:40:46 <Fuuzetsu> there's #yi if you didn't know
18:40:50 <benzrf> is Yi like Vi
18:40:54 <benzrf> when will there be Yim
18:41:05 <Lutin`> Looks like It's like Yimacs
18:41:05 <Fuuzetsu> benzrf: there's Vi/Vim emulation
18:41:14 <Lutin`> but haskell instead of elisp
18:41:16 <Fuuzetsu> benzrf: We use the Yi monad which is aliased to YiM ;)
18:41:24 <benzrf> im sold
18:41:26 <benzrf> [not rly]
18:41:41 * benzrf clings to his vim
18:41:44 <Fuuzetsu> Lutin`: actually the Vim emulation is more polished
18:41:45 <benzrf> Vi/Vim
18:41:49 <benzrf> Vi[m]
18:41:54 <benzrf> Fuuzetsu: you wasted a character!
18:41:55 <Lutin`> Fuuzetsu: I was just looking at the default bindings
18:42:15 <benzrf> Fuuzetsu: does the vim emu support q/@
18:42:28 <Fuuzetsu> benzrf: I don't know what that does, I use emacs
18:42:40 <benzrf> Fuuzetsu: macro capture/playback
18:42:59 <toors> is there a more generic version of fold that i could use to reduce an Int instead of []
18:43:06 <benzrf> you press 'q<regname>', do some editing, 'q'
18:43:10 <ski> zzo38 : it's not clear to me how you have negation rules as structural (i assume you mean applying them leaves no trace in proof terms ?)
18:43:15 <benzrf> then '@<sameregname>' to play back the recorded editing
18:43:40 <benzrf> toors: Foldable
18:43:44 <benzrf> toors: wait what
18:43:50 <benzrf> toors: reduce an Int?
18:43:53 <Fuuzetsu> benzrf: uh, I think so?
18:44:11 <zzo38> ski: Kind of; I mean that if you use the variable on the wrong side and its type has a negation, it creates/calls a continuation, and you don't need to specify it explicitly.
18:44:39 <benzrf> Fuuzetsu: emacs cretin!
18:44:44 <benzrf> UNIX IS MY IDE
18:44:56 * benzrf dons hipster glasses
18:44:56 <Lutin`> <3
18:45:08 <Lutin`> tbh that's what draws me to Vim
18:45:16 <Lutin`> small composable actions
18:45:48 <zzo38> benzrf: Well, when working on UNIX systems I use vim; when working on Windows I don't
18:45:52 <benzrf> i like vim because i can type ':%!markdown %' instead of installing a markdown plugin :^)
18:46:19 <benzrf> oh wait i mean ':%!markdown'
18:46:38 <ski> zzo38 : hm, sounds strange
18:46:44 <toors> benzrf: i have a quantity of items that i want to divide into containers so i am following the general pattern of a fold to consume the quantity into the largest container possible then move on to smaller containers until the quantity is <= 0
18:47:29 <benzrf> toors: how interesting, Denommus was asking the exact same problem like a week ago
18:47:36 <zzo38> benzrf: O, I don't use markdowns commands anyways
18:47:36 <benzrf> why don't you ask him what he found
18:47:40 <guesting> Is it me or is Map.fromListWith (++) taking up a lot of memory?
18:47:45 <toors> seems like a fold because each recursion reduces the Int until the terminal case
18:47:54 <benzrf> toors: there may be more efficient solutions
18:48:39 <ab9rf> guesting: probably folding the wrong way
18:48:55 <toors> I'm pretty new to Haskell so my knowledge of what's out there is pretty limited
18:49:02 <guesting> ab9rf: That would just be time consuming, right? Not necessarily memory hogging...
18:49:31 <ski> zzo38 : "The Duality of Computation" by Pierre-Louis Curien,Hugo Herbelin in 2000 at <http://citeseerx.ist.psu.edu/viewdoc/summary?doi=10.1.1.43.6938> might be interesting to check out. it has proof terms for values and continuations for an LK-based system
18:49:45 <ab9rf> guesting: yeah, high memory consumption is usually due to building lots of thunks
18:49:51 <zzo38> ski: I don't have access to citeseerx.
18:50:02 <benzrf> toors: i pm'd him and he said he couldnt find anything
18:50:17 <guesting> ab9rf: So you think it's making a lot of thunks? Is there a strict version of Map.fromListWith (++)?
18:50:23 <benzrf> so if perf is not a major priority fold is the best solution i can come up with off the top of my head too
18:51:00 <guesting> ab9rf: Would Map.fromListWith (:) work if it's the right order?
18:51:02 <benzrf> toors: i think you just want a tail recursive function btw
18:51:20 <benzrf> toors: im not sure there's any much shorter method for iterating over something and modifying it
18:51:27 <benzrf> *consuming it
18:51:38 <ski> zzo38 : try <http://yquem.inria.fr/~herbelin/publis/icfp-CuHer00-duality.ps.gz> ?
18:51:41 <benzrf> as a general case, i mean
18:51:44 <toors> cool, just wanted to throw it out there
18:51:53 <ab9rf> guesting: no, (:) and (++) have different results
18:51:57 <toors> lots to learn still
18:52:15 <guesting> ab9rf: So my only option is a strict version of (++)?
18:52:23 <benzrf> toors: i could be wrong of course :-)
18:52:32 <ab9rf> @src Map.fromListWith
18:52:33 <lambdabot> Source not found. My brain just exploded
18:52:35 <ab9rf> bah
18:53:03 <zzo38> ski: O, OK, let's see if I have GhostScript though otherwise I don't think I can display such a file
18:53:11 <ab9rf> guesting: are you using Data.Map.Strict or Data.Map.Lazy
18:53:30 <guesting> ab9rf: Data.Map, which I guess is lazy
18:54:06 <zzo38> I don't know how similar to what I have already made up.
18:54:12 <guesting> ab9rf: Yeah, it's lazy. I'll try strict
18:54:57 <ski> zzo38 : <http://yquem.inria.fr/~herbelin/publis/icfp-CuHer00-duality+errata6.pdf> seems to be a PDF version (including errata)
18:55:16 <ski> zzo38 : i'm getting these links from <http://yquem.inria.fr/~herbelin/publis/index-eng.html>
18:55:28 <zzo38> ski: OK, let me see if I can load that. Some PDF files don't work on my computer but I will try that one
18:55:30 <ab9rf> guesting: fromList uses a foldlStrict in both implementations
18:55:54 <guesting> ab9rf: Darn, so it wouldn't have an effect anyway
18:56:03 <zzo38> This file works OK.
18:56:08 <ski> fine
18:56:38 <ab9rf> guesting: my guess is that it's using foldl instead of foldr
18:56:42 <jle`> is there a built in sum (replicate n x) ?
18:57:10 <ab9rf> guesting: how many elements in your list?
18:57:49 <guesting> ab9rf: Hundreds of thousands
18:58:05 <ab9rf> guesting: i'm guessing that the (++) ops are getting deeply thunked
18:58:23 <guesting> ab9rf: Yeah. So how can I turn ++ strict?
18:59:44 <guesting> ab9rf: I guess I can redefine it with bang patterns
18:59:53 <fread2282> guesting: won't fix it, but ++ is inefficient, maybe consider Data.Sequence?
19:00:57 <zzo38> ski: It is very different from how I have done; their way is much more complicated.
19:01:11 <ab9rf> guesting: i don't like using (++) because it's expensive.
19:01:35 <guesting> ab9rf: Should I do what fread2282 said and use Sequence? I need to convert it to a list later...
19:02:10 <fread2282> guesting: you should be able to use a Sequence all the way through
19:02:25 <guesting> fread2282: I need to use foldr on it later
19:02:46 <fread2282> guesting: you can foldr on Sequences
19:02:58 <guesting> fread2282: Nice! Let me try it out...
19:03:15 <ab9rf> guesting: you could, i suppose, create a Map k [a] with fromList and then transform it into a Map k a with map foldr
19:03:27 <ab9rf> sorry, map (++)
19:03:44 <ab9rf> that would at least reduce the number of times you traverse each list doing (++)
19:04:43 <ab9rf> probably map (foldr (++)) actually... too much of a headache right now and the vodka hasn't taken effect yet
19:05:21 <guesting> ab9rf: Haha, I feel drunk and I haven't had anything
19:05:47 <ab9rf> guesting: it rained today so my son couldn't go outside and spent the whole day yelling in the house
19:05:53 <ski> zzo38 : i would be interested in hearing/reading about your approach
19:06:02 <zzo38> One difference is that I did not consider naturalness and stuff like that, and probably you would not use it mainly for writing most kind of programs at all (although it can be used for such).
19:06:09 <guesting> ab9rf: Sounds like hell
19:06:20 <ab9rf> guesting: i hate summer vacation
19:06:24 <zzo38> ski: To see mine you can look for http://esolangs.org/wiki/Gentzen (I think that is the URL?)
19:06:27 <ski> zzo38 : perhaps if you could write down the inference rules you use, that would help
19:06:40 <guesting> ab9rf: A few more months...
19:06:57 <zzo38> ski: Well, there is where I wrote all of the rules
19:07:06 <ski> ok
19:07:35 <zzo38> Like Haskell there is import/export although it work a bit differently
19:09:05 <ski> zzo38 : i'll have to look into it later, when i'm not so tired, though ..
19:09:28 <zzo38> ski: OK. It is MediaWiki so there is talk page on there.
19:29:08 <codygman> What's the easiest way to use 2 different ghc's? I'd like to use 7.6.3 from haskell platform then alternatively be able to use ghc7.8
19:32:21 <monochrom> ./configure --prefix=/usr/local/ghc-7.6.3 and ./configure --prefix=/usr/local/ghc-7.8.2, respectively. then play with PATH.
19:32:45 <monochrom> http://www.vex.net/~trebla/tmp/playpath.txt is useful
19:45:43 <the_berserker> How to write a `while` loop that returns the last value evaluated when it terminates?
19:46:04 <the_berserker> whileM' :: m Bool -> m a -> m a
19:46:32 <flebron> Is there a resource for a formal treatment of Curry-Howard? That is, stated and proved as a formal theorem?
19:49:48 * hackagebot mongoDB 1.5.0 - Driver (client) for MongoDB, a free, scalable, fast, document  DBMS  http://hackage.haskell.org/package/mongoDB-1.5.0 (GregWeber)
19:49:50 * hackagebot bytable 0.0.0.0 - data from/to ByteString  http://hackage.haskell.org/package/bytable-0.0.0.0 (YoshikuniJujo)
19:51:43 <Hafydd> the_berserker: what does whileM' (return False) undefined give?
20:02:32 <the_berserker> @faq Can I write prototype-based object-oriented code in Haskell?
20:02:33 <lambdabot> http://www.haskell.org/haskellwiki/FAQ
20:06:07 <the_berserker> @faq Can I write Haskell as fast as C?
20:06:07 <lambdabot> http://www.haskell.org/haskellwiki/FAQ
20:28:34 <umbriel> can any senior programmer help me real quick? (just some advices, nothing more)
20:28:45 <Fuuzetsu> just ask
20:29:47 <Lutin`> ugh another microcontroller running javascript
20:29:55 <ion> lutin: GHCJS!
20:30:12 <Lutin`> It's not me I'm worried about!
20:31:03 <Lutin`> I just see microcontrollers as one of the last bastions of considering performance when coding, and I feel javascript isn't the best language to aid in that learning experience
20:31:09 <Lutin`> Or maybe it is and I just have a stick up my butt
20:35:36 <Lutin`> umbriel: What's your question?
20:36:14 <umbriel> Fuuzetsu: well, Im coursing IS, and I Java is the main programming language being taught, but I dont want it to be my main language, and recently I discovered the world of FP, and I fell in love! So, I want to learn one of them, so, its a good trade having in mind that my focus will be business apps?? (sorry for the awful english)
20:37:34 <Fuuzetsu> Business apps? If you're looking to end up writing Enterprise™ code then Java is definitely the bigger market. I don't see a reason for not learning both though.
20:38:08 <umbriel> *enterprise, sorry hehee
20:38:37 <crazydave> umbriel: one of the advantages of learning Haskell is that it is so different and will change the way you think.  so it is likely to help you write better Java code!
20:38:54 <crazydave> also, one day Haskell will take over the world *evil laugh*
20:39:31 <Guest34693> clojure people are saying the same thing
20:39:40 <umbriel> Java verbosity make me sick!
20:39:57 <mayski> I for one welcome our Haskell overlords
20:39:59 <Guest34693> java, c#, the more typing you are doing the more productive
20:40:11 <Guest34693> or your money back
20:40:39 <crazydave> contractors charge by the hour.  More verbose language is good.
20:40:49 <crazydave> They will all go broke if people make them write Haskell code.
20:41:13 <Lutin`> Or they increase their rate because of the high quality of the deliverables?
20:41:44 <umbriel> i understand that, but my concern right now is my pleasure programming =P
20:41:45 <Guest34693> brrrr wrong
20:41:57 <Fuuzetsu> Guest34693: sure but majority of Clojure people seem to say ‘it's a LISP!!!!!!!11’ as their selling point
20:42:31 <crazydave> don't you mean it's a LISP))))))
20:42:40 <umbriel> LOL ^
20:42:43 <Fuuzetsu> (((((((((((((((((((((((((((((((((((((LISP)))))))))))))))))))))))))))))))))))))
20:42:47 <shachaf> Can we have less h8in' on other languages in here? It just makes the channel unpleasant.
20:42:50 <Fuuzetsu> is what I usually refer to it as
20:42:57 <Fuuzetsu> yeah sorry
20:43:05 <vanila> omg LOL
20:48:24 <pharaun> thank you shachaf
21:13:39 <sgronblo> doing some lunchtime haskell studying by reading this https://github.com/facebook/Haxl/blob/master/example/sql/readme.md
21:15:17 <sgronblo> does the deriving for UserReq have to be split up into two because of the GADT thing?
21:15:51 <sgronblo> and I was about to ask what O::Int means but now I can see with the right font that it is 0::Int :)
21:17:17 <shachaf> Yes.
21:18:37 <chrisdotcode> guys, I keep getting a "    Could not find module ‘Data.Text’" error when using cabal sandbox?
21:19:11 <chrisdotcode> is it that I need to add text to build-depends?
21:19:16 <chrisdotcode> but isn't it in base?
21:19:42 <shachaf> This channel isn't all guys, for what it's worth.
21:19:55 <shachaf> text isn't in base. That's why it has a package name.
21:20:11 <chrisdotcode> data Guys = Guys | Girls
21:20:22 <shachaf> hilarious
21:20:50 <ion> heh
21:21:18 <chrisdotcode> but in all seriousness,  shachaf, I didn't get a "it is a member of the hidden package text", as I'd usually get for another library
21:21:49 <shachaf> I was in all seriousness too.
21:22:04 <chrisdotcode> sorry, clarified improperly.
21:22:10 <shachaf> But OK. Data.Text isn't in base. It's in a package called text. I've never used cabal sandbox and don't know how it works.
21:23:03 <chrisdotcode> alright, so that'll probably solve my problem, thank you.
21:23:03 <chrisdotcode> but for those of you who *do* use cabal sandboxes, this time it didn't give me a "is a member of the hidden package text" error this time, any particular reason?
21:30:01 * hackagebot bytable 0.0.0.1 - data from/to ByteString  http://hackage.haskell.org/package/bytable-0.0.0.1 (YoshikuniJujo)
21:33:45 <ion> shachaf: You should try the cabal sandbox, it’s great.
21:52:42 <ab9rf> fwiw, i think of "guys" as gender-neutral these days....
22:09:10 <mayski> not a native speaker but that what I was thinking since as far as I can remember
22:09:23 <mayski> maybe what was meant was "Chiefly British Slang. a grotesquely dressed person. "
22:09:27 <mayski> ?
22:10:05 * hackagebot bytable 0.0.0.2 - data from/to ByteString  http://hackage.haskell.org/package/bytable-0.0.0.2 (YoshikuniJujo)
22:10:06 <ion> I’m not a native speaker either, but i was also under the impression it’s gender-neutral.
22:14:40 <mzero> Yay! Haskell Platform is now set up with Travis-CI !
22:14:50 <mzero> https://travis-ci.org/haskell/haskell-platform
22:15:57 <Guest7649> :D
22:17:13 <ion> mzero: nice
22:17:29 <mzero> We have Yitzchak Gale to thank
22:25:07 * hackagebot bytable 0.0.0.3 - data from/to ByteString  http://hackage.haskell.org/package/bytable-0.0.0.3 (YoshikuniJujo)
22:28:55 <etrepum> mlen: I'm aware of path_helper but it's a bit fragile (easy to have a profile that doesn't call it) and global (requires sudo, makes it hard to add/remove versions, etc.)
22:29:46 <altern> @hoogle minus
22:29:47 <lambdabot> Foreign.Ptr minusPtr :: Ptr a -> Ptr b -> Int
22:29:48 <lambdabot> Language.Haskell.Lexer Minus :: Token
22:29:48 <lambdabot> Foreign.C.Error throwErrnoIfMinus1 :: Num a => String -> IO a -> IO a
22:29:52 <altern> @hoogle -
22:29:53 <lambdabot> Prelude (-) :: Num a => a -> a -> a
22:29:53 <lambdabot> keyword -
22:29:53 <lambdabot> keyword --
22:30:26 <syllogismos> :t sqrt
22:30:27 <lambdabot> Floating a => a -> a
22:30:34 <syllogismos> :t (,)
22:30:35 <lambdabot> a -> b -> (a, b)
22:30:41 <syllogismos> :t (,) sqrt
22:30:42 <lambdabot> Floating a => b -> (a -> a, b)
22:31:07 <syllogismos> how?
22:31:18 <mzero> altern: are you looking for subtract?
22:31:24 <mzero> @type subtract
22:31:25 <lambdabot> Num a => a -> a -> a
22:31:30 <syllogismos> what does the function (,) do
22:31:40 <mzero> makes a tuple
22:31:47 <mzero> it is the tuple constructor
22:31:53 <altern> mzero: yeah, probably
22:31:58 <mzero> >(,) "hi" 42
22:32:07 <altern> @hoogle subtract
22:32:09 <lambdabot> Prelude subtract :: Num a => a -> a -> a
22:32:09 <lambdabot> Graphics.Rendering.OpenGL.GL.Texturing.Environments Subtract :: TextureCombineFunction
22:32:09 <lambdabot> Graphics.Rendering.OpenGL.GL.PerFragment FuncReverseSubtract :: BlendEquation
22:32:37 <mzero> > (,) "hi" 42
22:32:38 <lambdabot>  ("hi",42)
22:32:43 <syllogismos> oooooh..
22:33:06 <mzero> > let takeEmDown = subtract 1 in takeEmDown 42
22:33:07 <lambdabot>  41
22:33:29 <pqmodn> :t (,,)
22:33:31 <lambdabot> a -> b -> c -> (a, b, c)
22:34:04 <mzero> and if you have the right extension turned on (-XTupleSections if I recall)....
22:34:26 <mzero> > let and42 = (,42) in and42 "hi"
22:34:28 <lambdabot>  ("hi",42)
22:34:49 <mzero> > let hiAnd = ("hi",) in hiAnd 42
22:34:51 <lambdabot>  ("hi",42)
22:51:43 <jle`> - is a keyword?
22:52:10 <mzero> well - it is baked into the grammar
22:52:28 <pqmodn> > let (-) = (+) in 3 - 3
22:52:29 <lambdabot>  6
22:52:38 <jle`> is it that unary operator thing
22:52:40 <pqmodn> > let if = 0 in if
22:52:41 <lambdabot>  <hint>:1:8: parse error on input ‘=’
22:52:43 <jle`> > (-4)
22:52:44 <lambdabot>  -4
22:52:49 <jle`> > (-4) 3
22:52:51 <lambdabot>  Could not deduce (GHC.Num.Num (a0 -> t))
22:52:51 <lambdabot>    arising from the ambiguity check for ‘e_143’
22:52:51 <lambdabot>  from the context (GHC.Num.Num (a -> t), GHC.Num.Num a)
22:52:51 <lambdabot>    bound by the inferred type for ‘e_143’:
22:52:51 <lambdabot>               (GHC.Num.Num (a -> t), GHC.Num.Num a) => t
22:52:58 <jle`> is that why it's a part of the grammar?
22:53:02 <vanila> yes
22:53:04 <jle`> > (+4) 3
22:53:04 <pqmodn> not the same kind of keyword that "if" is, i guess
22:53:05 <kadoban> Yeah, it's special because of negative numbers
22:53:05 <lambdabot>  7
22:53:11 <jle`> how silly
22:53:18 <kadoban> Little bit, heh
22:54:08 <mzero> well, and also because of -> and <- not to metion --
22:54:20 <jle`> -> is a keyword but that doesn't mean that - is
22:54:24 <jle`> if is a keyword but not i
22:54:27 <mzero> correct...
22:54:31 <mzero> - isn't a keyword
22:54:38 <jle`> but lambdabot just said it was
22:54:43 <mzero> but it is treated somewhat differently than other operator symbols
22:54:45 <jle`> i guess i shouldn't trust lambdabot
22:55:03 <jle`> @hoogle -
22:55:04 <lambdabot> Prelude (-) :: Num a => a -> a -> a
22:55:04 <lambdabot> keyword -
22:55:04 <lambdabot> keyword --
22:55:07 <mzero> where did lambdabot say that?
22:55:13 <jle`> er well, hoogle said that
22:55:16 <mzero> that's hoogle, not lambdabot
22:55:38 <jle`> but lambdabot endorses anything hoogle says
22:55:50 <mzero> btw, if you ever want to have (-4) as a function... do this:
22:55:58 <jle`> i just use subtract these days
22:56:02 <mzero> > let subFour = (-4+) in subFour 8
22:56:03 <lambdabot>  4
22:56:11 <pqmodn> cute
22:56:30 <jle`> oh i'll definitely switch to that.
22:56:43 <mzero> well, you will if you're code-golfing
22:56:46 <mzero> :-)
22:56:51 <jle`> hoogle also suggests
22:56:57 <jle`> > (+(-4)) 7
22:56:58 <lambdabot>  3
22:57:02 <jle`> i'll never understand haskell
22:57:35 <jle`> oh
22:57:38 <jle`> it's just adding (-4)
22:57:41 <jle`> :|
22:57:41 <pqmodn> yeah
22:57:48 <mzero> would have been better if they had just left negative number literals out of the language!!!
22:58:05 <jle`> or maybe if they had had some sort of support for prefix unary operators
22:58:09 <mzero> who needs 'em?
22:58:12 <jle`> and made them first-class
22:58:16 <mzero> negatie literals that is
22:58:17 <jle`> $5
22:58:20 <pqmodn> mzero, and -n is always parsed as a function call?
22:58:24 <coppro> (-) is a dirty, dirty hack
22:58:34 <mzero> let i = 7 in -i
22:58:47 <mzero> > let i = 7 in (-i) 10
22:58:48 <lambdabot>  Could not deduce (GHC.Num.Num (a0 -> t))
22:58:49 <lambdabot>    arising from the ambiguity check for ‘e_1710’
22:58:49 <lambdabot>  from the context (GHC.Num.Num (a -> t), GHC.Num.Num a)
22:58:49 <lambdabot>    bound by the inferred type for ‘e_1710’:
22:58:49 <lambdabot>               (GHC.Num.Num (a -> t), GHC.Num.Num a) => t
22:58:55 <mzero> tada! no!
22:59:04 <mzero> > let i = 7 in (-i)
22:59:06 <lambdabot>  -7
22:59:27 <mzero> it is always negation....
22:59:38 <pqmodn> i mean if they had left negative number literals out, -n would be parsed as a unary operator applied to n?
23:00:06 <mzero> I'm happy to be forced to write   (0 - n)  for the sake of rationality
23:00:14 <jle`> or negate n
23:00:24 <mzero> because, frankly, the rules around parsing - always trip me up anyway .... they might as well be uniform
23:00:43 <wz1000> you can also use ((-)x) if you want a function that subtracts x
23:00:57 <jle`> wz1000: i'm not sure that works
23:00:58 <shachaf> ((-) x) is (x -)
23:00:58 <wz1000> no, thats wrong
23:01:09 <shachaf> You can use (subtract x) if you want a function that subtracts x.
23:01:15 <wz1000> you can also use (flip (-)x) if you want a function that subtracts x
23:01:23 <shachaf> Please don't. :-(
23:01:41 <mzero> > let x = 7; f = (flip (-) x) in f 10
23:01:42 <lambdabot>  3
23:01:46 <mzero> :-)
23:01:47 <rwbarton> negate . (+x) . negate
23:01:47 <jle`> how about (`(-)` x)
23:02:02 <pqmodn> i think that's a parse error
23:02:07 <wz1000> i dont think that works
23:02:12 <pqmodn> > (`(-)` 3) 3
23:02:14 <lambdabot>  <hint>:1:3: parse error on input ‘(’
23:02:20 <shachaf> > over (involuted negate) (+5) 8
23:02:22 <lambdabot>  3
23:02:23 <pqmodn> `( is no good
23:02:38 <shachaf> The thing between `s is an identifier, not an expression.
23:02:50 <ion> > 42 & iso negate negate -~ x
23:02:52 <lambdabot>  negate (negate 42 - x)
23:02:54 <orzo_> maybe it shoudl be an expression though
23:03:03 <ion> involuted, huh? /me looks
23:03:14 <wz1000> @let minus = (-)
23:03:15 <lambdabot>  Defined.
23:03:35 <wz1000> >(`minus` 2) 5
23:03:39 <shachaf> I shouldn't have gotten lens involved.
23:03:40 <orzo_> y `f x` z  == f x y z
23:03:47 <wz1000> > (`minus` 2) 5
23:03:49 <lambdabot>  3
23:03:56 <shachaf> No, it shouldn't be an expression.
23:04:03 <orzo_> why not
23:04:16 <pqmodn> orzo_, y `y `f x` z` z :)
23:04:20 <shachaf> Occasionally I think #haskell would be improved by not having lambdabot.
23:04:27 * ion will try to remember involuted in the future
23:04:43 <shachaf> ion: It's a convoluted name.
23:05:00 <kadoban> *groan*
23:05:36 <orzo_> pqmodn: is that a reason?  Just disallow backticks in the expression.  Maybe disallow a lot of stuff, just function application so that you can absorb all but the last two
23:06:02 <ion> > let a − b = a - b in (− x) y
23:06:04 <lambdabot>  y - x
23:06:14 <jle`> heh
23:07:01 <wz1000> i'll kill anyone who shows me code like that in production
23:07:46 <shachaf> Please don't phrase that in terms of killing people.
23:09:34 <gsingh93_> hey guys, i need a little help. I'm doing exercise two here: http://www.seas.upenn.edu/~cis194/hw/01-intro.pdf
23:09:40 <bitemyapp> Can you print a dependency tree for a project via cabal?
23:09:48 <gsingh93_> i need to double every other integer starting from the back
23:10:06 <gsingh93_> i could probably find the solution online, but i'd rather have a hint. I don't know how to start
23:11:01 <bitemyapp> > zip [1, 3, 8, 6] [1..]
23:11:03 <pqmodn> there are probably many ways. it might be easier if you reversed the list
23:11:03 <lambdabot>  [(1,1),(3,2),(8,3),(6,4)]
23:11:04 <bitemyapp> gsingh93_: ^^
23:11:22 <levi> gsingh93_: What kind of strategies do you know for tackling that sort of problem?
23:11:39 <jle`> gsingh93_: cycle might help you
23:11:46 <shachaf> zip [1..] doesn't actually help. And I think talking is better than code at this point for gsingh93_.
23:11:46 <jle`> > cycle [1,2]
23:11:47 <gsingh93_> levi: I could emulate a loop, but that's not very functional
23:11:48 <lambdabot>  [1,2,1,2,1,2,1,2,1,2,1,2,1,2,1,2,1,2,1,2,1,2,1,2,1,2,1,2,1,2,1,2,1,2,1,2,1,2...
23:12:19 <levi> gsingh93_: What do you mean by 'emulate a loop'?
23:12:20 <Axman6> gsingh93_: how about you tell us some ways you can think you could do it
23:12:24 <gsingh93_> hmm, cycle is an interesting approach
23:12:25 <bitemyapp> jle`: good :)
23:13:03 <jle`> not sure if that is too much of a hint though
23:13:10 <gsingh93_> i'd reverse the list, keep a counter and if the counter was even double the value, then reverse it back
23:13:11 <jle`> sry
23:13:31 <levi> gsingh93_: Well, why don't you try doing it that way first?
23:13:54 <Axman6> then we can talk about improvements
23:14:00 <gsingh93_> kk, will do
23:15:09 <dfarm> I know this is a PITA but can anyone tell me how I can try to "reset" my haskell install (on ubuntu)? cabal is completely screwed up so I tried apt-get remove haskell-platform; rm -rf ~/.cabal; apt-get install haskell-platform and it's still complaining about packages I had before.
23:15:15 <levi> I have a solution to that particular problem saved from someone else's question about it.
23:15:36 <levi> dfarm: You might also need to kill .ghc
23:15:38 <orzo_> dfarm: also ~/.gpg
23:15:40 <orzo_> er
23:15:44 <orzo_> yeah, that .ghc
23:16:04 <orzo_> i hope he didnt delete his keyring :/
23:16:28 <dfarm> hehehe
23:17:33 <dfarm> Awesome, I think that did it.
23:18:25 <dfarm> Thanks levi and orzo_
23:18:31 <levi> gsingh93_: My solution to that problem is expressed as a foldr, BTW.
23:20:48 <wz1000> gsingh93: i used a foldl and zip
23:22:01 <levi> wz1000: Did you get the "every other starting from the end" bit correct?
23:22:11 <wz1000> yeah
23:23:03 <wz1000> why do haskellers generally prefer foldr over foldl
23:23:45 <shachaf> You can write foldl with foldr but not the other way around.
23:24:45 <jle`> foldr feels a little prettier to me
23:24:45 <vanila> foldr is the catamorphism
23:24:53 <levi> foldr also performs guarded recursion
23:24:58 <jle`> you have 1:2:3:4:[]
23:25:01 <vanila> it's more natual
23:25:09 <jle`> and foldr just replaces (:) with the operator, and [] with the base case
23:25:15 <vanila> yes exactly as jle` said
23:25:20 <vanila> thats what a catamorphism is
23:25:20 <jle`> so foldr (+) 0 is like 1 + 2 + 3 + 4 + 0
23:25:23 <jle`> ah
23:25:51 <shachaf> "catamorphism" is a fancy word for what people usually call "fold".
23:25:56 <jle`> in practice you can use it to short circuit stuff too
23:26:09 <jle`> you can't write a short circuiting foldl
23:26:15 <shachaf> foldl is an odd special case.
23:26:28 <levi> Guarded recursion ensures that the result can be consumed lazily.
23:27:01 <jle`> > foldr (||) False (cycle [False, True])
23:27:02 <lambdabot>  True
23:27:20 <Zekka> (Will feeding lambdabot nonterminating code cause bad things to happen?)
23:27:24 <wz1000> ah
23:27:33 <jle`> the list is infinite but it stops after the second element because it knows the result will be True no matter what
23:27:37 <c_wraith> > repeat 1
23:27:38 <lambdabot>  [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1...
23:27:49 <jle`> > sum [1..]
23:27:54 <lambdabot>  mueval-core: Time limit exceeded
23:28:31 <jle`> > foldr (||) False (repeat True)
23:28:32 <lambdabot>  True
23:28:37 <jle`> > foldl (||) False (repeat True)
23:28:41 <lambdabot>  mueval-core: Time limit exceeded
23:28:59 <Zekka> This is because foldl needs to know the last element in the list to begin folding, right?
23:29:18 <Zekka> so it just keeps saying 'yes, but first I must compute the next element?'
23:29:36 <My_Hearing> @src foldl
23:29:36 <lambdabot> foldl f z []     = z
23:29:36 <lambdabot> foldl f z (x:xs) = foldl f (f z x) xs
23:29:53 <My_Hearing> It just needs to reduce the input to an empty list before it can terminate
23:29:55 <wz1000> doesn't foldl only need the first element
23:30:30 <Zekka> Mon_Ouie: Yeah, that's more technically accurate, thanks
23:30:43 <levi> foldl's recursion is not guarded by a data constructor; it just keeps going.
23:30:46 <wz1000> how would you terminate without getting the first element with foldr
23:30:57 <jle`> hm?
23:31:02 <shachaf> 'l' and 'r' are odd names in the first place. They're referring to left/right associativity, not "from the left/right", whatever that means.
23:31:05 <jle`> > foldr (const ()) [1..]
23:31:06 <lambdabot>  Couldn't match expected type ‘[t] -> [t]’ with actual type ‘()’
23:31:06 <altern> @hoogle List
23:31:08 <lambdabot> Data.List module Data.List
23:31:08 <lambdabot> Control.Monad.List module Control.Monad.List
23:31:08 <lambdabot> Control.Monad.Trans.List module Control.Monad.Trans.List
23:31:13 <jle`> > foldr (const ()) 0 [1..]
23:31:14 <lambdabot>  Couldn't match expected type ‘b -> b’ with actual type ‘()’
23:31:19 <levi> @src foldr
23:31:19 <lambdabot> foldr f z []     = z
23:31:19 <lambdabot> foldr f z (x:xs) = f x (foldr f z xs)
23:31:32 <jle`> er, yeah
23:31:38 <Zekka> >foldr const 0 [1..]
23:31:52 <Zekka> > foldr const 0 [1..]
23:31:54 <lambdabot>  1
23:32:17 <wz1000> :t const
23:32:18 <lambdabot> a -> b -> a
23:32:36 <wz1000> > const 0 1
23:32:37 <lambdabot>  0
23:32:43 <jle`> @djinn a -> b > a
23:32:43 <lambdabot> Cannot parse command
23:32:49 <jle`> @djinn a -> b -> a
23:32:49 <lambdabot> f a _ = a
23:33:03 <wz1000> shouldnt foldr const 0 [1..] give a 0
23:33:29 <Mon_Ouie> Look at t he definition, f is first applied an element of the list
23:33:30 <jle`> wz1000: look at @src foldr
23:34:20 <wz1000> oh ok
23:35:26 <jle`> wz1000: just imagine, 1:2:3:[] --> 1 `const` 2 `const` 3 `const` 0
23:35:38 <jle`> which is const 1 (const 2 (const 3 0))
23:35:40 <wz1000> yeah i got it
23:36:16 <wz1000> > foldr (:) 0 [1..10]
23:36:18 <lambdabot>  No instance for (GHC.Show.Show a0)
23:36:18 <lambdabot>    arising from a use of ‘M223134921172600975325464.show_M2231349211726009753...
23:36:18 <lambdabot>  The type variable ‘a0’ is ambiguous
23:36:18 <lambdabot>  Note: there are several potential instances:
23:36:18 <lambdabot>    instance [safe] GHC.Show.Show
23:36:38 <wz1000> > foldr (:) [0] [1..10]
23:36:39 <lambdabot>  [1,2,3,4,5,6,7,8,9,10,0]
23:36:59 <wz1000> > take 3 foldr (:) [undefined] [1..10]
23:37:01 <lambdabot>  Couldn't match expected type ‘(a2 -> [a2] -> [a2])
23:37:01 <lambdabot>                                -> [t0] -> [t1] -> t’
23:37:01 <lambdabot>              with actual type ‘[a0]’Couldn't match expected type ‘[a0]’
23:37:01 <lambdabot>              with actual type ‘(a1 -> b0 -> b0) -> b0 -> [a1] -> b0’
23:37:10 <wz1000> > take 3 $ foldr (:) [undefined] [1..10]
23:37:12 <lambdabot>  [1,2,3]
23:37:34 <xxx-man> foldr (:) [0] [1..10]
23:37:52 <wz1000> so foldr can be used to lazily append elements to lists
23:38:07 <jle`> as opposed to stricty append? :P
23:38:16 <jle`> > take 3 $ [1..10] ++ repeat undefined
23:38:17 <lambdabot>  [1,2,3]
23:38:24 <wz1000> without evaluating the last element
23:38:33 <wz1000> > [1,2,undefined]
23:38:35 <lambdabot>  [1,2,*Exception: Prelude.undefined
23:39:10 <wz1000> > take 1 $ reverse $ foldr (:) [0] [1,2,undefined]
23:39:12 <lambdabot>  [0]
23:39:51 <jle`> foldr (:) ys should be identical to (++ ys), i believe
23:39:52 <wz1000> > take 2 $ reverse $ foldr (:) [0] [1,2,undefined]
23:39:54 <lambdabot>  [0,*Exception: Prelude.undefined
23:40:50 <wz1000> >take 3 $ reverse $ [1..] ++ [13..20]
23:41:06 <wz1000> > take 3 $ reverse $ [1..] ++ [13..20]
23:41:11 <lambdabot>  mueval-core: Time limit exceeded
23:41:14 <gsingh93_> alright, here's my not so efficient solution: http://pastebin.com/BZiYnFTt
23:41:39 <jle`> wz1000: take 3 [1,2,3,undefined,undefined] doesn't blow up either, so i'm not totally sure what you are trying to show :)
23:41:40 <levi> folding doesn't evaluate the values in the list if you don't provide a function that looks at them; it just works on the spine.
23:42:16 <jle`> gsingh93_: you can use otherwise
23:42:31 <wz1000> > take 3 [1,2,undefined]
23:42:32 <lambdabot>  [1,2,*Exception: Prelude.undefined
23:42:39 <wz1000> > take 3 [1,2, error ""]
23:42:41 <lambdabot>  [1,2,*Exception:
23:43:06 <pavonia> gsingh93_: You don't need an Integer to count, toggling a Bool would suffice
23:43:29 <jle`> ^^ along those lines, you can use the `not` function to toggle a Bool
23:43:34 <jle`> > not True
23:43:35 <lambdabot>  False
23:44:59 <jle`> > iterate not True
23:45:00 <lambdabot>  [True,False,True,False,True,False,True,False,True,False,True,False,True,Fals...
23:45:24 <wz1000> :t iterate
23:45:25 <lambdabot> (a -> a) -> a -> [a]
23:45:38 <wz1000> @source iterate
23:45:38 <lambdabot> Unknown command, try @list
23:45:50 <wz1000> @src iterate
23:45:50 <lambdabot> iterate f x =  x : iterate f (f x)
23:46:07 <jle`> iterate f x is just x : f x : f (f x) : f (f (f x)) : ...
23:46:31 <wz1000> > iterate (+1) 0
23:46:33 <lambdabot>  [0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,2...
23:49:12 <gsingh93_> jle`: earlier you suggested to use cycle. i tried to do it with cycle, but i'd still have to reverse two lists, right?
23:49:39 <gsingh93_> this doubles ever other from the front: doubleEveryOther' xs = [a * b | (a, b) <- zip xs $ cycle [1, 2]]
23:50:18 <wz1000> so reverse the list before passing it in
23:50:38 <jle`> > zipWith (*) [1,6,3,10,9] (cycle [1,2])
23:50:39 <lambdabot>  [1,12,3,20,9]
23:51:20 <jle`> > [ a * b | a <- [1,6,3,10,9], b <- cycle [1,2] ] -- if you want to use a list comprehension
23:51:21 <lambdabot>  [1,2,1,2,1,2,1,2,1,2,1,2,1,2,1,2,1,2,1,2,1,2,1,2,1,2,1,2,1,2,1,2,1,2,1,2,1,2...
23:51:29 <jle`> oh yeah that doesn't work
23:51:38 <jle`> sry :|
23:51:44 <gsingh93_> np
23:51:52 <gsingh93_> i'll try foldl/foldr now
23:52:40 <sbrg> > zipWith (*) [1,6,3,10,9] (cycle [1,2])
23:52:41 <lambdabot>  [1,12,3,20,9]
23:53:17 <sbrg> uh, duh
23:53:20 <sbrg> someone just posted that
23:53:35 <levi> > zipWith (*) [1..9] (cycle [1,2])
23:53:37 <lambdabot>  [1,4,3,8,5,12,7,16,9]
23:53:39 <sbrg> that's what I get for entering and not reading
23:53:45 <levi> > zipWith (*) [1..10] (cycle [1,2])
23:53:47 <lambdabot>  [1,4,3,8,5,12,7,16,9,20]
23:54:00 <levi> See the problem?
23:54:27 <jle`> you'll have to reverse it, yeah
23:54:42 <jle`> in this case the list size is fixed though so you can probably get away with not >_>
23:54:56 <levi> There's no need to reverse it to get a solution, though.
23:55:04 <matematikaadit> is that yourgey course exercise?
23:55:05 <levi> Just to do it *that* way.
23:55:13 <levi> matematikaadit: Yeah.
23:56:01 <gsingh93_> i have no idea how to do this with foldl
23:56:13 <levi> You wouldn't, I'm pretty sure.
23:56:37 <wz1000> @let doubleEveryOtherReversed = (flip (zipWith (*)) $ (cycle [1,2])) . reverse
23:56:39 <lambdabot>  Defined.
23:56:40 <sbrg> gsingh93_: something with a tuple containing the list you're building and a bool like mentioned before you toggle on and off
23:56:59 <pavonia> > (\l -> let n = length l `mod` 2 in zipWith (*) l (cycle [(n+1) `mod` 2 + 1, n+1])) [1,2,3,4]
23:57:01 <lambdabot>  [2,2,6,4]
23:57:10 <pavonia> > (\l -> let n = length l `mod` 2 in zipWith (*) l (cycle [(n+1) `mod` 2 + 1, n+1])) [1,2,3,4,5]
23:57:11 <wz1000> >doubleEveryOtherReversed [1..10]
23:57:12 <lambdabot>  [1,4,3,8,5]
23:57:22 <sbrg> what is the 'challenge', by the way? Just double every other element?
23:57:35 <gsingh93_> sbrg: from the back, yes
23:57:37 <levi> Well, if you're going to take the length, you might as well reverse. :P
23:57:39 <sbrg> oh.
23:58:34 <gsingh93_> levi: you said you used foldr?
23:58:36 <orzo_> just use a recursion
23:58:49 <altern> Hi again. I have problem with monad implementation: http://lpaste.net/105429
23:59:02 <altern> Does anybody have any idea how to make it work?
23:59:21 <jle`> altern: what's your error?
23:59:37 <jle`> altern: it might have to do with return being a -> m a
23:59:56 <altern> jle`: Couldn't match type `[Int]' with `LL a'
