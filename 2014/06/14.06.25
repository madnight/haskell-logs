00:01:08 <solidus-river> is there a way to search within a module on hackage
00:02:59 <tdammers> solidus-river: yes. Hoogle, hayoo, and the search box in the top right corner
00:03:03 <tdammers> oh wait
00:03:08 <tdammers> *within* a module
00:03:37 <solidus-river> yeah, so i know Graphics.OpenGL must have a way to turn off back face culling
00:03:45 <solidus-river> but the best i can do to find it is stumble through submodules
00:07:08 <levi> Install the haddocks (or source) locally and grep them?
00:07:26 <levi> I'd like to be able to do that too.
00:08:07 * hackagebot conduit-combinators 0.2.6.1 - Commonly used conduit functions, for both chunked and unchunked data  http://hackage.haskell.org/package/conduit-combinators-0.2.6.1 (MichaelSnoyman)
00:08:07 * hackagebot yesod-form-json 0.0.1 - Extension for Yesod web framework to handle JSON requests as applicative forms  http://hackage.haskell.org/package/yesod-form-json-0.0.1 (acheshkov)
00:08:51 <solidus-river> hmm.. maddening
00:09:04 <solidus-river> no one seems to have information on how to disable face culling using haskells OpenGL library
00:09:18 <solidus-river> its like no ones every thought to do it
00:09:24 <tdammers> if you can guesstimate the type signature, you can feed that to hoogle
00:09:36 <tdammers> @hoogle String -> IO ()
00:09:37 <lambdabot> Prelude putStr :: String -> IO ()
00:09:38 <lambdabot> System.IO putStr :: String -> IO ()
00:09:38 <lambdabot> Prelude putStrLn :: String -> IO ()
00:09:39 <tdammers> like that
00:10:10 <solidus-river> eh, it would most likely be setting state via an enumerator
00:10:12 <jle`> solidus-river: you can also look at the index
00:10:12 <solidus-river> so i can't really guess
00:10:19 <jle`> and ctrl+f
00:10:28 <jle`> that's what i did when i worked with opengl heh.
00:11:28 <solidus-river> HAHA
00:11:36 <solidus-river> jle` has the winning technique
00:11:49 <solidus-river> cullFace in Graphics.Rendering.OpenGL.GL.Polygons
00:11:50 <jle`> no but really
00:11:57 <solidus-river> yeah, that really did it
00:11:58 <tdammers> heh, the opengl API isn't exactly haskell-friendly, is it
00:12:02 <solidus-river> went to index and all and ctrl+f
00:12:06 <jle`> haha
00:12:26 <tdammers> all the functions are like `Double -> GL ()`, or `GL Double`
00:12:32 <solidus-river> well, opengl is mostly around managing the gpu as a big state machine
00:12:42 <solidus-river> so i cna see how that'd be pretty not friendly to haskell
00:12:49 <tdammers> yeah, I know, I've done my share of opengl coding myself
00:12:56 <solidus-river> but i dont think you actually have to keep much info about that state
00:13:06 <tdammers> that was C++ though, pretty much just driving the C API directly
00:19:00 <xpika> does anyone know how i can strictly evaluate a function for the purposes of benchmarking?
00:19:29 <xpika> i want to test the speed of Data.List.(!!)
00:24:30 <alpounet> xpika: criterion provides an easy way to do that
00:24:57 <alpounet> and criterion pretty much is our "standard" tool for benchmarking
00:27:13 <solidus-river> an, thats really awkwordly placed but makes sense to turn off face_culling you do cullface $= Nothing
00:27:21 <solidus-river> er cullFace
00:30:17 <ivanm> Is it possible to have a Functor-like typeclass but with no restriction on the kind of the data type?
00:30:37 <ivanm> (I have types of kind * -> * -> * and * -> * -> * -> * that I want to apply it to)
00:31:57 <levi> multi-parameter type class extension?
00:32:11 <solidus-river> damn, nope thats not it either
00:32:41 <ivanm> levi: not sure how MPTCs apply here
00:33:29 <ivanm> I suppose another way of putting it would be: how can I write a class like Functor where I can make the function apply to the Left constructor in Either, as well as work on Maybe
00:33:53 <ivanm> (I'm not sure if this _is_ possible, I'd just like it to be :p)
00:34:11 <ivanm> If all else fails I can have multiple classes for the different kinds
00:36:12 <Fuuzetsu> is there a better ’break’ anywhere which takes [a] rather than a?
00:36:22 <Fuuzetsu> :t break
00:36:23 <lambdabot> (a -> Bool) -> [a] -> ([a], [a])
00:36:37 <Fuuzetsu> @hoogle ([a] -> Bool) -> [a] -> ([a], [a])
00:36:37 <lambdabot> No results found
00:36:50 <ivanm> Fuuzetsu: some kind of infix search?
00:36:56 <Fuuzetsu> yeah
00:37:00 <ivanm> did you look in the split package?
00:37:07 <Fuuzetsu> I can't do external deps
00:37:22 <ivanm> if all else fails, some variant of using isPrefixOf and tails?
00:37:25 <ivanm> ahhhh
00:37:28 <Fuuzetsu> I think I'll just do a silly hack for my usecase
00:37:31 <ivanm> copy the source of split into your package :p
00:37:35 <Fuuzetsu> I want to split on # or \#
00:37:49 <Fuuzetsu> ivanm: already doing that with half of attoparsec ;/
00:37:56 <ivanm> Fuuzetsu: use the ReaderP parser combinator library that comes with GHC?
00:38:06 <Fuuzetsu> I think I'll break on # and then drop trailing \ if it exists on the left of the tuple
00:38:32 <Fuuzetsu> I hate having to drop things from the end
00:38:59 <bartavelle> is there already a known function for running a "pure" monad stack computation in an impure one ? ie. MonadState s m => State s a -> m a
00:39:22 <bartavelle> (in my case it's specialized for state)
00:39:42 <steffen> I'm working on a haskell project with emacs and haskell-mode and I have to edit files somewhere down in the module path. If I then press C-c C-l ghci can not find the other imported modules which belong to the project. somehow I have to make haskell-mode aware of the ProjName.cabal file in the root dir of the project so it finds the modules. Please, how can I achieve that?
00:40:45 <mikusp> Hi. Is there any package that could be a replacement for MonadCatchIO-transformers-foreign? I need to use generalized allocaArray.
00:40:55 <Fuuzetsu> steffen: I use .ghci in my project root which does -isrc
00:41:08 <Fuuzetsu> then before I C-c C-l the first time, I M-x cd to the project root
00:41:22 <ivanm> bartavelle: run it separately?
00:41:35 <bartavelle> ivanm, that's what I am doing, just wondered if this already existed
00:41:36 <xpika> is there a version of System.Process.system which simply returns the stdout as a string?
00:41:38 <ivanm> steffen: if you use the "cabal repl" support then it takes the patsh from your .cabal file
00:41:49 <steffen> Fuuzetsu:  okay, I'll try that
00:42:06 <Fuuzetsu> oh, yes, you could also (setq haskell-program-name "cabal repl"), you'll have better results that way too
00:42:22 <Fuuzetsu> (run cabal configure by hand first and make sure you cd to the root)
00:42:24 <steffen> ivanm: Okay, I'l ltry that first
00:52:08 <steffen> Okay, what I did now: I added (setq haskell-program-name "cabal repl"), I ran cabal configure in the root directory, where the .cabal file is, I cd to that root dir with M-x cd and then for the first time ran C-c C-l. It kind of worked the problem now is, that it does not find "normal" inputs like Data.Text. Any suggestions?
01:01:21 <fragamus> OK... the Cont monad is very weird
01:10:27 <rola> is there something similar to lambdabot's @src in ghci
01:11:47 <kbrei> rola: not that i know of. but :i at least tells you in which module you should look
01:13:09 <phaazon_> hi! my packages don’t have haddock documentation anymore
01:13:13 <phaazon_> it’s been a while now
01:13:16 <phaazon_> for instance: http://hackage.haskell.org/package/monad-journal-0.2.1.1/reports/
01:13:22 <phaazon_> does anyone have a clue? :/
01:19:01 <phaazon_> no one ?
01:19:02 <phaazon_> :(
01:19:28 <solidus-river> i'm just looking
01:19:54 <solidus-river> irc moves slowly
01:19:57 <phaazon_> ;)
01:21:06 <solidus-river> does cabal haddock work for you locally?
01:21:37 <phaazon_> yep
01:21:47 <alpounet> phaazon_: report it https://github.com/haskell/hackage-server/issues
01:22:14 <phaazon_> I’m gonna investigate a bit more before opening a ticket alpounet
01:22:19 <phaazon_> but I guess I’ll have to
01:22:28 <alpounet> phaazon_: the hackage doc builder is known to lag behind uploads, but AFAIK it's not known that it *deletes* documentation
01:22:41 <phaazon_> lag
01:22:43 <phaazon_> you name it
01:22:53 <phaazon_> the latest version of monad-journal is something like 2 months aged
01:22:54 <phaazon_> :D
01:23:15 <phaazon_> I need to upload a new one, I’m gonna check EVERYTHING before
01:23:27 <alpounet> phaazon_: yeah but the docs for monad-journal were there before right?
01:23:42 <phaazon_> I don’t think so
01:25:08 <alpounet> ah, that's something different then, maybe the doc generation failed. they've never been generated on hackage, for any of the versions?
01:26:26 <phaazon__> oh, I guess I do have a haddock error
01:26:27 <phaazon__> cabal: .\dist\doc\html\monad-journal\.\haddock-prolog2348.txt: invalid argument
01:27:48 <phaazon__> http://trac.haskell.org/haddock/ticket/20
01:27:49 <phaazon__> seriously ?
01:28:04 <phaazon__> Opened 6 years ago
01:28:08 <phaazon__> is this some kind of joke?
01:28:24 <MP2E> heh
01:28:27 <phaazon__> seems to be fixed though
01:28:52 <solidus-river> Aha! and i finally got a triangle strip drawn!, its the little wins that make your day
01:29:37 <phaazon__> ok, what is that prolog39487.txt file?
01:30:42 <phaazon__> Fuuzetsu: hey! I’m coming to you from this post http://fuuzetsu.co.uk/blog/posts/2014-01-06-Fix-your-Hackage-documentation.html
01:31:17 <phaazon__> Fuuzetsu: I have an issue with my monad-journal package, http://hackage.haskell.org/package/monad-journal-0.2.1.1, no doc at all :/
01:31:21 <augur> is there a way to prob a program to see where it might be looping?
01:32:38 <Fuuzetsu> phaazon__: alrighty, and can I help somehow?
01:32:45 <phaazon__> sure!
01:33:00 <phaazon__> I’m running the cabal haddock on local
01:33:03 <phaazon__> and got this:
01:33:11 <phaazon__> cabal: .\dist\doc\html\monad-journal\.\haddock-prolog3612.txt: invalid argument
01:33:16 <phaazon__> I thought it was related to this issue:
01:33:22 <phaazon__> http://trac.haskell.org/haddock/ticket/20
01:33:31 <phaazon__> but it seems to be fixed now
01:33:50 <Fuuzetsu> there are more issues about prolog files, look on cabal issue tracker
01:34:03 <phaazon__> ok, but what are they?
01:34:27 <Fuuzetsu> they vary, I have no idea which one you're hitting without having a snoop around
01:34:37 <Fuuzetsu> which I won't be able to do until in like 10 mins, let me just finish commiting some stuff
01:34:48 <phaazon__> ok
01:35:12 <phaazon__> btw, I may disconnect, I’m at work and our network is… rubbish.
01:37:21 <solidus-river> goodnight all
01:37:30 <solidus-river> phaazon__: it builds locally for me fine
01:37:39 <phaazon__> oh?
01:37:41 <phaazon__> weird
01:37:43 <phaazon__> DAMMIT
01:37:49 <phaazon__> alarm training…
01:37:58 <phaazon__> brb, Fuuzetsu you can answer at phaazon
01:37:59 <phaazon__> see you
01:38:03 <solidus-river> yeah i just cloned and tried to haddock it
01:38:35 <Fuuzetsu> please post your Haddock version
01:44:31 <augur> my program is spinning forever and i dont know why :(((
01:45:16 <Taneb> Does it contain "forever $ spin"?
01:45:21 <MP2E> haha
01:46:01 <augur> Taneb: :P
01:46:26 <augur> Taneb: its some weird behavior that i dont understand, because code that is only marginally different isnt hanging
01:46:33 <MP2E> augur : are you evaluating something infinite strictly? are you using foldl on an infinite structure? are you using foldl-style recursion on an infinite structure?
01:46:38 <MP2E> post the code :P
01:46:49 <augur> no MP2E
01:46:53 <augur> im not doing any of those
01:46:58 <MP2E> hmm
01:47:05 <augur> also posting code wont help, its too big
01:47:12 <MP2E> ah
01:47:41 <sipa> :t spin
01:47:42 <lambdabot>     Not in scope: ‘spin’
01:47:42 <lambdabot>     Perhaps you meant one of these:
01:47:42 <lambdabot>       ‘sin’ (imported from Prelude), ‘span’ (imported from Data.List),
01:48:01 <Fuuzetsu> :t sin . undefined . span
01:48:01 <lambdabot> Floating c => (a -> Bool) -> c
01:48:09 <Fuuzetsu> let spin = sin . undefined . span
01:48:38 <augur> lol
01:48:50 <Fuuzetsu> undefined makes for best glue
01:51:52 <phaazon_> Fuuzetsu: Haddock version 2.13.2
01:52:15 <augur> is there any kind of call profiling i can do?
01:53:21 <michaelt> augur  Debug.Trace.trace ?
01:53:37 <augur> i dont need to spit output, i need to profile function calls to see whats causing the loop
01:54:40 <michaelt> if the traced element is part of the loop it will be kind of obvious?
01:55:15 <augur> yes, and then i have to try putting trace all over the place in the hopes that i find the thing
01:55:59 <michaelt> augur: yes, I was thinking that
02:04:09 <k00mi> augur: you want to see the variables in the loop?
02:04:48 <Fuuzetsu> phaazon: perhaps https://github.com/haskell/cabal/issues/1721
02:05:32 <augur> koala_man: yes
02:05:37 <augur> whoops
02:05:40 <augur> k00mi: yes
02:05:43 <augur> the called functions
02:06:07 <augur> aha! got it
02:06:19 <k00mi> there is ghci's debugger, not sure how useful it is
02:06:40 <augur> some i was accidentally extending the typing context with dummy vars and this was causing problems o_O
02:06:53 <augur> problems for normalization, i guess, which is weird
02:07:19 <augur> why the heck should that be...
02:07:21 <augur> that doesnt make any sense
02:07:28 <michaelt> Fuuzetsu: is there a script that helps write haddocks locally for uplifting to hackage? I was using a python script attributed to you, but haddock doesn't like the options
02:07:43 <michaelt> uplifting!
02:07:47 <Fuuzetsu> I don't remember writing a Python script for this so it's weird it was attribute to me
02:07:56 <augur> ok no it wasnt that at all
02:07:57 <augur> hmm
02:07:59 <Fuuzetsu> oh, I think someone wrote one based on the terrible bash script though
02:08:05 <michaelt> oh right, it was based on a blog post you wrote sorry.
02:08:23 <Fuuzetsu> there is *a* script I wrote but I think it needs some further tweaks
02:08:47 <Fuuzetsu> there is also a script someone wrote before me but I don't remember where to get that
02:08:53 <Fuuzetsu> let me see if I can find and update my bash script
02:09:17 <Fuuzetsu> honestly what you should do is create an issue on cabal issue tracker, they should be handling this
02:09:21 <ccapndave> Hey everyone
02:10:42 <ccapndave> I am trying to map through two lists at once (reelSymbols and randomList) so for each reel I can have a random number, but I can't figure out the structure.  I know its something to do with zip but can't match up the types :(
02:10:42 <ccapndave> https://gist.github.com/ccapndave/5a55e87a9233d97e28d4
02:11:05 <michaelt> Fuuzetsu: oh here's the script fwiw https://gist.github.com/nh2/8284831
02:11:49 <michaelt> Fuuzetsu: it's a 'cabal haddock' problem I'm having; I guess you're right.
02:14:51 <MP2E> ccapndave:  let spunReels visibleSymbolsCount randomList reelSymbols = zip randomList $ map (take visibleSymbolsCount . drop stopPoint . cycle) reelSymbols where stopPoint = 1
02:16:02 <MP2E> you're probably going to have to change your type signature to Int -> [Int] -> [Reel] -> [(Int,Reel)]
02:16:20 <aphury> Hello there. At the moment I am trying to comprehend some type aspects of Haskell. I’m struggling with data records. As far as I know, it’s syntactic sugar, but for what? My problem is, given any algebraic type: `data Obj = { name :: String, len :: Int }` it holds that `\x -> x { name = “Barney“ } :: Obj -> Obj`. What is `x { name =  “Barney“ }`? Function application? Syntactic sugar for what?
02:16:26 <ccapndave> MP2E Thanks
02:16:51 <ccapndave> MP2E Maybe I am going about this the wrong way - all I really want to do is use the list in randomList to choose stopPoint, one per iteration of map
02:16:57 <ion> aphury: It’s syntax for updating the record.
02:17:29 <ion> Not function application.
02:17:45 <aphury> yeh, but how does it fit into „everything is a function“? Or: how would one translate into lambda-calculus?
02:17:47 <Fuuzetsu> michaelt: I have https://gist.github.com/Fuuzetsu/8276421 but you're probably better-off using what you have already
02:17:54 <Fuuzetsu> there *is* another script around but I can't find it
02:17:54 <ion> aphury: Who claimed everything is a function?
02:18:09 <jtcwang> I'm trying to define an unboxed type. can anyone tell me why this isn't valid?
02:18:11 <jtcwang> data MyType = MyType { {-# UNPACK #-} toInt :: !Int }
02:18:20 <pjdelport> aphury: Have you looked at https://en.wikibooks.org/wiki/Haskell/More_on_datatypes#Named_Fields_.28Record_Syntax.29 ?
02:18:25 <ion> jtcwang: Try moving the pragma in front of the type.
02:19:09 <pjdelport> aphury: In functional programming, everything is a value (including functions).
02:19:22 <michaelt> Fuuzetsu: oh, thanks I'll study.
02:19:28 <aphury> pjdelport: Ah!  : )
02:19:31 <ion> pjdelport: Not everything is a value, and “every value is a value” is just a tautology.
02:19:32 <ccapndave> MP2E Maybe a fold with a starting value of the two arrays would be more performance?
02:19:35 <MP2E> ccapndave: as in read an element randomList and use that to determine the length to read? or terminate reelSymbols at the end of randomList?
02:19:38 <jtcwang> ion, cool that type checks. what about this? newtype MyType = MyType { toInt :: {-# UNPACK #-} Int }
02:20:00 <MP2E> an element from randomList*
02:20:01 <jtcwang> (note the new type, and i took away the ! at the front cuz  it was complaining)
02:20:07 <michaelt> jtcwang: it's a newtype so it doesn't need it
02:20:16 <pjdelport> aphury: In pure lambda calculus everything is a function, yeah, but that's quite a different theoretical realm. You can, however, encode arbitrary data into functions that way: see https://en.wikipedia.org/wiki/Church_encoding
02:20:21 <ccapndave> MP2E As in iteration one, take the first element of reels and use the first element of randomList to choose a point, then in iteration two take the second element of reels and use the second element of randomList to choose a point, etc
02:20:23 <ccapndave> They are they same length
02:20:28 <Axman6> \x -> x { name = "barney" } is equivalent to: \x -> case x of Obj _ l -> Obj "barney" l
02:21:05 <pjdelport> aphury: There's an example there of Church-encoding the tuple and list types; ADTs and records are just a natural elaboration of that.
02:21:09 <Axman6> jtcwang: unpacking a value doesn't make sense in a newtype as there's nothing to unpack into
02:21:36 <jtcwang> michaelt, what I'm trying to do is define a new type with an unboxed Int (Int#)
02:22:05 <Axman6> newtype Foo = Foo Bar = like saying struct Foo {Bar val}, the runtime representation is identical to Bar, but has a different type as the time type checking is done
02:22:37 <aphury> okay, thanks a lot. Much to read again.  : )
02:22:39 <haskoiner> zip the reellist with the random list and then map a function choosePoint to do whatever you want over the list of tuples [(randomNum, reel)]
02:22:53 <ccapndave> ok
02:22:55 <ccapndave> Is zip fast?
02:23:09 <Axman6> is 7 fast?
02:23:11 <jtcwang> Axman6, basically, I want to define a type of which when compiling, it is treated as a "new type" (with custom operations), but during execution, it's pretty much a Int#
02:23:31 <MP2E> ccapndave : oftentimes GHC will fuse the iterations over the lists anyway
02:23:35 <ccapndave> ok
02:23:36 <MP2E> so it shouldn't be noticable
02:23:38 <ccapndave> TBH I had written some Scala code which was super slow and was hoping that porting it to to Haskell would make it way faster, but figuring out Haskell looks like its a bit more of a job than I thought it would be.  Might have to leave all this for another day :(
02:23:39 <michaelt> ccapndave:  zip is certainly part of the ghc list optimization machinery
02:23:48 <jtcwang> Axman6, or will I always need a type constructor at the front
02:23:53 <Axman6> jtcwang: I'm not sure that's possible. you can't pass around unboxed types like boxed types
02:24:20 <Axman6> the compiler will do what it can to remove all the boxing though
02:24:28 <jtcwang> Axman6, so the best I can do is this?
02:24:48 <jtcwang> data MyType = MyType { toInt :: {-# UNPACK #-} !Int }
02:25:10 <Axman6> yes, though that'll have exactly the same overhead as Int
02:25:13 <Axman6> at runtime*
02:25:21 <michaelt> jtcwang: that certainly works, but it amounts to renaming the Int# constructor
02:25:44 <michaelt> no, the I# constructor
02:25:44 <jtcwang> hmm, i through Int wasn't strict
02:25:58 <michaelt> data Int = GHC.Types.I# GHC.Prim.Int# 	-- Defined in ‘GHC.Types’
02:26:11 <Axman6> I feel you may be prematurely optimising...
02:26:11 <jtcwang> hence we need !Int?
02:26:22 <RchrdB> Is there any particular reason why you're not defining it as newtype MyType = MyType { toInt :: Int } -- ?
02:27:03 <jtcwang> Axman6, this is around 25% of my program time, and I think it's worth learning about it
02:27:27 <Axman6> IIRC, data Foo = Foo !Int is only really as strict as Int is, the Int will be evaluated when checking the constructor of Foo
02:27:30 <jtcwang> RchrdB, I am already :) Is that the fastest possible way?
02:27:43 <Axman6> yes
02:27:51 <jtcwang> I have this atm: newtype MyType = MyType {getInt :: Int}
02:28:11 <Axman6> want to share the code so we can see if there's any reason it's so dominant?
02:28:24 <jtcwang> sure
02:28:51 <jtcwang> https://github.com/jtcwang/HaskSplit/blob/master/src/lib/FiniteField/GF256.hs
02:28:57 <jtcwang> type is question is GF256Elm
02:29:02 <jtcwang> (MyType)
02:29:31 <jtcwang> I'm gonna optimize Vector Int next
02:30:07 <jtcwang> or should I be using some other structure? It's pretty much a table lookup for multiplication and division
02:30:35 <Axman6> hmm, if your numbers are always mod 255, why not use Word8?
02:30:50 <michaelt> yeah, I wondered that?
02:31:00 <jtcwang> what's special about Word8?
02:31:02 <michaelt> and why not unboxed vectors
02:31:09 <Axman6> if you're doing a lot of lookups in a static Vector, you definitely want an Unboxed Vector
02:31:10 <michaelt> > maxBound :: Word8
02:31:11 <lambdabot>  255
02:31:17 <michaelt> > minBound :: Word8
02:31:18 <Axman6> jtcwang: it's uint8_t in C
02:31:18 <lambdabot>  0
02:31:37 <augur> ahahaha i found the problem :)
02:32:06 <jtcwang> michaelt, Axman6 I didn't know about Unboxed Vector when i started haha
02:32:24 <Axman6> jtcwang: try using import Data.Vector.Unboxed as V
02:32:27 <michaelt> jtcwang: where they are possible, they are much much better
02:33:00 <Axman6> also if you know _for sure_ you'll never index outside the array bounds, you can use unsafeIndex
02:33:21 <jtcwang> Axman6, I guess I can do that
02:34:21 <ccapndave> Hooray!  I did it
02:34:38 <jtcwang> I'll read into unboxed vector now, not too sure what's the difference here
02:34:42 <ccapndave> https://gist.github.com/ccapndave/05688b572b6a660f9631
02:34:48 <augur> now see, i couldve caught this bug very quickly if i had a function call profile :(
02:34:54 <jtcwang> Axman6, michaelt thanks for you help
02:35:42 <Yuu_chan> jtcwang: boxed stores pointers to values (plus one level of indirection), unboxed stores values as-is
02:35:49 <Axman6> jtcwang: Vector is an array of pointers to thunks, unboxed vector is a contiguous array of values
02:35:58 <jtcwang> ouch
02:36:21 <jtcwang> so unboxed can only be used for primitives?
02:36:38 <Axman6> it can only be used for valued in the Unbox class
02:36:57 <Axman6> to all the Int and Word types, Characters, and tuples of those types
02:37:22 <Axman6> Bool too (though it's not bit packed, so it's 1 byte per value, which is usually fine)
02:37:41 <ddellacosta> weird, people are talking about boxing and primitives in #clojure and #haskell but the context is completely different
02:37:45 <jtcwang> gotcha
02:38:04 <jtcwang> what're the clujure crowd talking about
02:38:06 <kazagistar> I thought the bool instance of STArray was bitpacked...
02:38:07 * ddellacosta is amused
02:38:45 <kazagistar> or it looked that way from a super brief look, though I might be mistaken or misremember
02:38:57 <joshkirklin> I have a bunch of precalculated key-value pairs of type (Int, Int). Can someone advise me on which package I might use to create the most efficient lookup?
02:39:18 <Axman6> jtcwang: IntMap would be a good place to start
02:39:23 <Axman6> uh, joshkirklin
02:39:27 <jtcwang> Axman6, wait, so is unboxed array using Int#?
02:39:45 <jtcwang> vector*
02:39:46 <Axman6> jtcwang: yes, you will have the equivalent to an int[] in C
02:40:05 <jtcwang> cool
02:40:12 <Yuu_chan> I have a gut feeling they all use ForeignPtr or something
02:40:21 <Axman6> joshkirklin: are there any other features of the keys that might be useful? (such as all values within a certain range)
02:40:39 <joshkirklin> Axman6: looking at the hackage docs, the lookup appears to be O(min(n,W)). I was hoping for something O(1), do you know of anything like this?#
02:40:42 <Yuu_chan> @src Vector
02:40:42 <lambdabot> Source not found. Wrong!  You cheating scum!
02:40:51 <Axman6> @hackage vector
02:40:51 <lambdabot> http://hackage.haskell.org/package/vector
02:41:15 <Axman6> http://hackage.haskell.org/package/vector-0.10.11.0/docs/src/Data-Vector-Unboxed.html
02:41:48 <Axman6> or not
02:41:59 <Yuu_chan> Ew, there is some type family magic in Unboxed.
02:42:10 <Axman6> bah, it's probably defined in Data.Vector.Unboxed.Base but the source isn't available
02:42:30 <joshkirklin> Axman6: I'm afraid not, they're fairly evenly distributed in the entire range of Int
02:42:34 <Axman6> Yuu_chan: that's used so that Vector (a,b) can be represented as basically (Vector a,Vector b)
02:42:35 <Yuu_chan> Axman6: http://hackage.haskell.org/package/vector-0.10.11.0/docs/src/Data-Vector-Unboxed-Base.html ?
02:43:16 <Axman6> joshkirklin: is it a big range? and are there value values that you don't expect to ever see (say negative values)
02:43:48 <Axman6> Yuu_chan: hmm, the Haddock page says page not found, but I guess changing the URL is another way to get to it =)
02:44:37 <Yuu_chan> Axman6: I simply clicked the "Source" url in the data family Vector a definition :)
02:45:27 <Axman6> huh, ok
02:45:46 <joshkirklin> Axman6: There are on the order of around 10,000 key-value pairs. There are no negative valued keys, and (although I would be impressed if it helped) their highest prime factor is 41
02:46:14 <k_bx> Hi everybody! I fail to install alex on ghc-7.8, ld cannot find HSrandom library. Can anyone take a look please? http://lpaste.net/106272
02:46:39 <Axman6> joshkirklin: what about values? you could implement it as an unboxed vector where you return -1 for values which you don't actually have a key for for example
02:47:18 <MP2E> k_bx: is the package random installed? cabal install random, if not
02:47:34 <MP2E> maybe the dependency wasn't specified.. heh
02:48:02 <joshkirklin> Axman6: that seems like a reasonable solution; is it space efficient to store so many extra values?
02:48:27 <Axman6> Yuu_chan: http://hackage.haskell.org/package/vector-0.10.11.0/docs/src/Data-Vector-Primitive.html#Vector shows it used a ByteArray (there's Data.Vector.Storable if you need C interop)
02:48:30 <k_bx> MP2E: it was, but seems reinstall helped, thanks! How can that be possible? Should I wipe out old /usr/local/lib/ghc-7.6.3 ?
02:48:36 <Yuu_chan> As far as I could find, Vector wraps Array, which wraps Array#, which is GHC-primitive.
02:48:44 <Axman6> joshkirklin: depends on how widely spread your keys are
02:48:49 <michaelt> Yuu_chan: yes, is that bad?
02:48:51 <MP2E> k_bx: ooh yeah that's a good idea.
02:49:12 <Yuu_chan> michaelt: dunno :)
02:49:13 <k_bx> MP2E: thanks! Will do that.
02:49:27 <joshkirklin> Axman6: ok, I'll give it a try and see, thanks for the help
02:49:37 <Axman6> Yuu_chan: Array is just an Int indexed array of Haskell values (thunks/heap allocated stuff)
02:49:56 <Axman6> joshkirklin: IntMap is definitely worth looking at though =)
02:50:03 <michaelt> Yuu_chan: the point is, we don't have to think about that array unpleasantness; or that's what's pleasing to me.
02:50:05 <Axman6> it implements exactly the interface you want
02:50:14 <pamojarpan> soifrp
02:50:35 <Axman6> soy frappe?
02:50:41 <joshkirklin> ok, I'll check it out. still worried about the O(min(n,W)) though
02:52:01 <Yuu_chan> michaelt: I'd want to know about overhead and stuff
02:52:34 <Yuu_chan> And that's always interesting to learn something from implementation of core things
02:53:14 <michaelt> Yuu_chan: Data.Vector.Unboxed is partly so fast because of the basic implementation with unboxed array goop; but also because of the 'stream fusion' optimization system
02:54:57 <michaelt> Yuu_chan: thus e.g. filter even $  map (+1) (drop 7 vec)  doesn't have to write the 'intermediate' arrays.
02:56:13 <jtcwang> well, this is funny. unboxed vector seem to perform worst than boxed vector
02:56:18 <Yuu_chan> michaelt: I know a bit of fusion and rewriting and they are amazing
02:56:32 <jtcwang> I'm using (!) to access the indexes atm tho
02:56:37 <Yuu_chan> jtcwang: that's why both exist :)
02:57:20 <jtcwang> Yuu_chan, I'd like to figure out why though, i must be missing something somewhere
02:57:29 <MasseR> Hah. I'm so hyped up. I've learnt something new. Unless I made a mistake somewhere (possible), I just converted a huge frameworks core idea into two lines of haskell code
02:58:07 <jtcwang> MasseR, dem feels
02:58:13 <MasseR> jtcwang: No kidding
02:58:19 <Yuu_chan> jtcwang: what is your use case? I.e., how big the array is, how many lookups are performed, etc?
02:58:52 <MasseR> jtcwang: Just imagine the maintenance difference between one line of code (+ one line of types) vs. thousands of lines of java
02:58:58 <jtcwang> size is 256 (lookup table)
03:00:08 <Yuu_chan> Btw, is boxed Vector strict?
03:00:12 <jtcwang> so imo unboxed should be significantly faster
03:00:45 <Yuu_chan> jtcwang: can you profile to be sure?
03:00:51 <MP2E> MasseR : Even complex Haskell software is usually about the size of "smaller" C projects :D
03:01:07 <MasseR> MP2E: True
03:01:11 <MP2E> take GHC for instance, it's about the size of the Doom engine in terms of Haskell LOC count
03:01:18 <MP2E> I'm kinda cheating because there's the RTS and everything but still
03:01:19 <MP2E> :P
03:01:25 <jtcwang> Yuu_chan, let me pull the profile results sec
03:02:08 <Axman6> Yuu_chan: boxed vectors ae by definition strict
03:02:43 <Yuu_chan> Axman6: could you explain why?
03:02:45 <MP2E> 2 lines though, that is pretty neat.. I don't think I've heard of a framework being converted to 2 lines before :P
03:02:50 <MasseR> MP2E: Now if only there were some libraries for couple of 'endpoints', I could really try implementing it in haskell :)
03:03:15 <jtcwang> is Int strict?
03:03:16 <MasseR> MP2E: Core idea. Add to that threading and IO endpoints, such as scp, http, smb etc
03:03:18 <Yuu_chan> Probably I'm missing something. If there are an array of pointers underneath, couldn't there be a pointer to thunk?
03:03:30 <Axman6> Yuu_chan: because there's no where for lazy values to exist inside it. U.Vector a is basically equivalent to struct vec_a { size int; a[] vals;}
03:03:31 <RchrdB> Axman6, I believe you have that backwards. *Unboxed* vectors are strict by definition. Boxed vectors aren't.
03:03:48 <Axman6> RchrdB: uh, I did mean Unboxed vectors, my bad
03:03:53 <Yuu_chan> Axman6: _boxed_
03:03:54 <RchrdB> No worries.
03:04:12 <Axman6> Yuu_chan: boxed vectors are not strict, no
03:04:30 <Axman6> which means you can use them for all sorts of tying the knot goodness
03:04:37 <Yuu_chan> Axman6: that may be an explanation why they performed better in jtcwang's case
03:04:44 <Axman6> and efficient and clear dynamic programming
03:05:35 <Axman6> jtcwang: can you share your changes? also are you using unsfeIndex? each call to (!) causes a bounds check
03:05:38 <jtcwang> Yuu_chan, preliminary results seems like I was too quick to judge
03:06:05 <Yuu_chan> Axman6: yeah, I solved bioinformatics stuff with lazy recursive initialization of 2d lookup arrays :)
03:06:14 <jtcwang> Boxed: 7.3%, Unboxed: 3% of total prog running time
03:07:27 <Axman6> jtcwang: so it sped it up by over 50%!
03:07:37 <jtcwang> yeap more tests seems consistent
03:07:46 <jtcwang> haha but my program runs slower overall with unboxed
03:07:49 <jtcwang> for some reason lol
03:08:00 <Axman6> odd
03:09:02 <jtcwang> interesting, using unboxed vector doubled running time of my ZipList multiplication
03:09:19 <Axman6> I'm really confused why you need to use this complex implementation of multiplication
03:09:20 <jtcwang> let zl = (*) <$> ZipList (pList)  <*> ZipList poly
03:09:49 <jtcwang> Axman6, it's Galois Field
03:10:01 <Axman6> hmm, ok
03:10:18 <jtcwang> their multiplication is a bit complex
03:10:36 <Axman6> right
03:10:38 <jtcwang> so we normally generate a table first and use lookups
03:11:03 <jtcwang> As it stands, I have huge amount of space leak
03:11:19 <Yuu_chan> MasseR: could you tell more about those two lines? :)
03:11:23 <jtcwang> total alloc = 5,933,884,368 bytes  (excludes profiling overheads)
03:11:46 <Axman6> jtcwang: that just tells you how much data was allocated in total, not how much was resident
03:12:12 <Axman6> basically all haskell programs will allocate a lot of data, but much of it is immediately consumed
03:12:20 <Yuu_chan> Do I get it right that strict containers would break fusion?
03:12:22 <MasseR> Yuu_chan: Sure. http://mulesoft.org is the framework. My thought was 'with :: (MonadPlus m, Monad m) => a -> m b -> (b -> m ()) -> m ()' and the obvious implementation for it
03:12:38 <jtcwang> Axman6, right. My heap profiling tells me it spikes to 1600k tho
03:12:41 <MasseR> Then you could do something like 'with (parseFoo >=> parseBar) { doSomethingWithBar }'
03:12:42 <Axman6> also, it seems like a really bad idea to be using guards in the definition of (*) and (/)
03:13:05 <jtcwang> Axman6, are guards costly?
03:13:27 <MasseR> And have routing with msum
03:13:29 <jtcwang> what's an alternative that'll be faster?
03:13:32 <vanila> wouldn't it be with (parseFoo >=> parseBar) (do doSomethingWithBar)
03:13:42 <Axman6> they add branching to code that might otherwise not have branches, and that can slow things down a lot on modern CPUs
03:13:51 <MasseR> vanila: In the example only one function, so no :)
03:13:58 <MasseR> Although {} might be wrong
03:16:00 <Axman6> jtcwang: oh! also, change mod to rem, since you'll never have negative valued right?
03:16:12 <jtcwang> Axman6, yes
03:16:40 <Axman6> yeah rem is faster (but has different behaviour to mod for negative values)
03:16:58 <jtcwang> hmm actually my division could potentially have them
03:17:17 <jtcwang> Axman6, are you familiar with the conduit library?
03:17:27 <Axman6> sort of
03:17:40 <jtcwang> I'm currently zipping two sources
03:17:44 <Axman6> but haven't used it for a long time
03:17:49 <jtcwang> one is a file source (sourceFile)
03:18:01 <jtcwang> one is a source of StdGen
03:18:35 <jtcwang> i then take the head of the sourceFile (thus I have ha Word8) and put it in a tuple with my StdGen
03:18:42 <jtcwang> (Word8, StdGen)
03:19:02 <Axman6> the Random library is notoriously slow
03:19:17 <Axman6> you might consider using something like the mersenne twister library
03:19:23 <jtcwang> I feel like this is kinda inefficient, since wouldn't it read one byte, do processing, then read another byte?
03:19:39 <Axman6> quite probably
03:20:07 <jtcwang> so my question is, is there a function in Conduit.Binary that allows me to read a fixed chunk?
03:20:32 <jtcwang> since I can do with (ByteString, StdGen) where ByteString is a fixed length chunk
03:20:49 <Axman6> https://hackage.haskell.org/package/vector-random-0.2/docs/Data-Vector-Random-Mersenne.html might be useful to you
03:20:58 <jtcwang> Axman6, I'll look into it
03:23:23 <nicoo> Axman6: epending on jtcwang's usecase, MT might not be a good RNG (it is completely predictable after observing dome output)
03:23:45 <Axman6> isn't StdGen too?
03:25:22 <Yuu_chan> Masser: «Mule is the most lightweight integration platform available, with the fully loaded distribution weighing in at 40 MB»
03:25:31 <nicoo> I have not sure (never checked its internals) but probably.
03:25:34 <Yuu_chan> Now that's lightweight.
03:25:50 <nicoo> Yuu_chan: Ahah :]
03:26:10 * nicoo knows people who gripe about a 500KB increase in binary size ...
03:26:32 <MP2E> 500kb?!? THINK ABOUT THE COMMODORES!
03:26:36 * MP2E shot
03:27:10 <MasseR> Yuu_chan: To be honest, it comes with a bug-ridden-modified eclipse
03:27:20 <MasseR> No wait, 40MB? That's just the runtime
03:27:30 <MP2E> oh god
03:27:30 <MasseR> Eclipse would bring the distribution closer to 700M
03:27:36 <Yuu_chan> To be honest, static Haskell binaries are typically fat as well...
03:27:41 <MP2E> yeah they are
03:27:51 <MasseR> (bug-ridden = removes source files)
03:27:53 <MP2E> I like to use upx to slim them down :P
03:28:14 <MP2E> i've noticed for whatever reason upx can pack Haskell executables more efficiently than C/C++ executables, on average
03:28:18 * hackagebot rest-client 0.3.0.0 - Utility library for use in generated API client libraries.  http://hackage.haskell.org/package/rest-client-0.3.0.0 (AdamBergmark)
03:28:25 <MasseR> And of course mule comes with n scripting languages to use when you code your integration platform with xml
03:28:29 <MP2E> typically Haskell executables compress at 19% source size while C++ is usually about 25-30% source size
03:28:57 <MasseR> One of them, the one which comes together with NIH syndrome, has little problems like (true && false) != (false && true)
03:29:05 <Yuu_chan> MasseR: that justifies :)
03:30:29 <Yuu_chan> && is non-commutative, so what? Strong typing is for wimps who can't write clear and safe code by themselves.
03:30:43 <MasseR> Yuu_chan: + "in xml"
03:30:50 <MasseR> It wasn't painful enough yet
03:31:51 <MasseR> No but really, don't get me started. I could probably rewrite the entire tdwtf from this
03:32:25 <Yuu_chan> MasseR: that's the system your company is working with, right?
03:32:42 <MasseR> I've been using it a lot lately yes
03:34:02 <tomejaguar> If I use ConstraintKinds to allow a type synonym for a constraint can I use that constraint in an instance definition?
03:34:39 <Axman6> you can't give types at all for instance definitions
03:35:11 <tomejaguar> I'm confused
03:35:42 <tomejaguar> If I do 'type Foo = Functor; data MyFunctor a = ...' why can't I do 'instance Foo MyFunctor where ...'
03:52:19 <ivanm> does doctest or something allow me to define code within Haddock and then also run it?
03:52:38 <ion> yes
03:53:34 <solirc> ivanm: Depends on what you mean with define code.
03:53:48 <ivanm> I was thinking of having an entire worked-through example of my library
03:53:56 <solirc> ivanm: With doctest you can do everything that you can do in GHCi
03:54:52 <solirc> ivanm: When it comes to scoping, doctest will keep everything in scope within one comment and have a fresh clean scope for each new comment.
03:55:21 <ivanm> yeah, I was thinking more having something like a literate code example
03:55:28 <solirc> So if you have a long example that involves several functions from your module, you could put that in the haddock for the module.
03:56:17 <ivanm> this was going to be in a separate module
03:56:32 <ivanm> i.e. having a module solely for a worked-through example
03:56:37 <solirc> ivanm: There is also support for $setup-hookes, which may be useful (https://github.com/sol/doctest-haskell#setup-code)
03:56:43 <ivanm> I suppose I can use it within several named chunks
03:56:58 <ivanm> solirc: are you the sol that maintains doctest?
03:57:03 <solirc> ivanm: yes
03:57:11 <ivanm> ahhh, hence why you know so much about it :p
03:57:34 <ivanm> solirc: so apart from $setup, there's no way to have one chunk require another chunk to be run first?
03:57:44 <solirc> ivanm: But for documentation, I also use a literate Haskell program at times (using markdown-unlit).
03:57:53 <solirc> ivanm: no
03:58:22 <solirc> ivanm: https://github.com/sol/markdown-unlit#readme
03:58:43 <solirc> ivanm: or https://github.com/yesodweb/wai/tree/master/wai#readme for an example
03:58:56 <solirc> ^ just in case this better suites your need
03:58:59 <ivanm> though that won't get displayed on Hackage as part of the documentation
03:59:22 <solirc> yes, that is the drawback
04:00:33 <solirc> I tend to just link to the README in that cases.  But this still has the disadvantage that you usually point the README of current master, which may not reflect what's on hackage...
04:04:35 <ivanm> solirc: just to check: will doctest actually generate the results, or just test that the ones I've specified are equivalent to the output?
04:04:55 <tero-> alex & happy-related question. For happy, I have the monad StateT ParserState IO, but I'd like to use the "monad" wrapper for alex. So far I haven't figured out how to combine these..
04:05:38 <solirc> ivanm: I'm not sure if I understand what you mean.
04:05:40 <tero-> I need IO to support "include"-style definitions
04:05:51 <solirc> It does string comparison, if that is what you mean.
04:06:22 <ivanm> solirc: ahhh, I was hoping to have the output generated by doctest and spliced into the resulting html generated by haddock
04:08:46 <solirc> ivanm: Ahh, ok, no it does not.  It just tests that the ones you've specified are equivalent to the output.
04:09:17 <ivanm> which doesn't help me at the moment as I'm constantly improving what the pretty-printed output _is_ :p
04:19:46 <tomejaguar> Why do contexts play no part in tests for overlapping instances?
04:23:19 <ivanm> tomejaguar: because GHC discards them; I think there's more info in the GHC manual
04:47:08 <klrr_>  in the applicative superclass of monad proposal, will functo also be a superclass of monad?
04:47:18 <tomejaguar> Functor will be a superclass of Applicative
04:47:31 <klrr_> okey
04:49:35 <klrr_> feels bad to use liftM now :/
04:51:36 <FreeFull> klrr_: I think Functor already is a superclass of Monad
04:53:05 <Cale> klrr_: Well, liftM serves a purpose: it's a way to implement fmap for free given that you can implement return and (>>=)
05:05:38 <pjdelport> Like clubbing someone to death with a loaded Uzi, as the saying goes. :)
05:05:38 <tomejaguar> FreeFull: Functor is not a superclass of Monad: http://haddocks.fpcomplete.com/fp/7.4.2/20130829-168/base/src/GHC-Base.html#Monad
05:08:05 <Yuu_chan> What is forall in the Monad definition for?
05:08:10 <mmmm> Say I have f :: a -> a -> b and [a,a] is there a nice way to apply the function to the values in the list?
05:09:05 <tomejaguar> What if the list doesn't have two elements?
05:09:24 <int-e> @type (+) <$> (!!0) <*> (!!1)
05:09:25 <lambdabot> Num b => [b] -> b
05:10:35 <Yuu_chan> uncurryList :)
05:10:50 <int-e> mmmm: \[x,y] -> f x y   seems simple enough, actually.
05:11:22 <mmmm> hmm I guess something more general isn't going to exist
05:12:19 <int-e> you're in variadic function territory. it can probably be achieved with typeclasses (and definitely with template haskell) but at the same time it doesn't seem worth the effort
05:13:03 <Yuu_chan> int-e: what is list of arguments is known only in runtime?
05:13:06 <Yuu_chan> *what if
05:13:20 <quchen> Variadic functions are "just because you can doesn't mean you should" territory.
05:14:04 <Yuu_chan> quchen: but printf is neat... >_>
05:14:13 <int-e> Yuu_chan: the translation would be type-directed anyway.
05:14:21 <tdammers> data FuncArgs = FuncArgs { faPositional :: [ String ], faNamed :: HashMap String String }
05:14:21 <int-e> > printf "%d" "abc" :: String
05:14:22 <lambdabot>  "*Exception: printf: bad formatting char 'd'
05:14:25 <quchen> Yuu_chan: Convenient maybe. But not neat.
05:14:27 <tdammers> problem solved
05:14:49 <int-e> Yuu_chan: so you'll probably get runtime errors in such cases, as printf does
05:14:59 <BoR0> > printf "%d" 3
05:15:01 <lambdabot>  No instance for (GHC.Show.Show a0)
05:15:01 <lambdabot>    arising from a use of ‘M443132488817841954323646.show_M4431324888178419543...
05:15:01 <lambdabot>  The type variable ‘a0’ is ambiguous
05:15:01 <lambdabot>  Note: there are several potential instances:
05:15:01 <lambdabot>    instance [safe] GHC.Show.Show
05:15:09 <BoR0> > printf "%d" 3 :: Int
05:15:10 <lambdabot>  No instance for (Text.Printf.PrintfType GHC.Types.Int)
05:15:10 <lambdabot>    arising from a use of ‘Text.Printf.printf’
05:15:35 <int-e> > printf "%d %d" 23 52 :: String -- the type is the type of the whole expression
05:15:35 <quchen> printf either "print" or "string"s.
05:15:36 <lambdabot>  "23 52"
05:15:45 <tdammers> seriously though; if the number of arguments isn't known at compile time, then you pretty much *have* to live with runtime errors
05:16:12 <vanila> you could pass a list of arguments
05:16:19 <pjdelport> Yuu_chan: "Explicit for-alls so that we know what order to give type arguments when desugaring"
05:16:20 <Yuu_chan> int-e: I know, but other only options seem to be a humongous bunch of show's and ++'es or typesafe TH printf.
05:16:24 <vanila> printf "%d %d" [23,52] much more sane
05:16:45 <tdammers> vanila: except that printf "%d %s" [23, "foobar"] is an error
05:16:47 <BoR0> > printf "%d %d" 53 :: String
05:16:49 <lambdabot>  "53 *Exception: printf: argument list ended prematurely
05:16:49 <int-e> Yuu_chan: as quchen said, it *is* convenient
05:16:51 <bergmark> there's a library for this... but what was the name
05:17:07 <BoR0> well, (23, "foobar") could work, no?
05:17:26 <vanila> BoR0, you'd be better to make a custom data type the sums the kind of things printf can handle
05:17:43 <quchen> tdammers: You could use a list of existentials to do this though, like `printf "%d %s" [p 23, p "foobar"]`. But that doesn't look as nice as plain printf anymore of course.
05:18:16 <int-e> BoR0: HList pushes this idea quite far.
05:18:23 <rwbarton> you would still get runtime errors if the list was the wrong length
05:18:25 <tdammers> quchen: don't even need existentials for that - class P a where p :: a -> PrintfArg
05:18:30 <tdammers> something like that
05:18:43 <tdammers> bit like how hdbc does it
05:18:51 <quchen> tdammers: Hmm right
05:19:15 <quchen> Speaking of printf, any chance to get a Text instance anytime soon?
05:19:38 <int-e> :t printf
05:19:39 <lambdabot> PrintfType r => String -> r
05:20:05 <quchen> PrintfType is IO and String only :-(
05:20:27 <quchen> The API didn't export the class methods, but I think that changed with 7.8, allowing new PrintfType instances
05:21:05 <quchen> Argh no, nevermind. Still hidden.
05:21:29 <quchen> "Its implementation is intentionally not visible from this module.", no reason given.
05:21:50 <vanila> a better way to format strings would be:  contact [show 23, " ", show 52]
05:22:16 <tdammers> how would that be better?
05:22:17 <quchen> Or use 'words'.
05:22:22 <quchen> Unwords, I mean.
05:22:27 <quchen> Not as readable though.
05:22:27 <tdammers> unwords . map show
05:22:28 <Yuu_chan> pjdelport: didn't notice that line, thanks
05:22:39 <vanila> better than printf "%d %d" [23,52]
05:23:05 <int-e> > printf "%3.4f %05d" pi 42 :: String
05:23:07 <lambdabot>  "3.1416 00042"
05:23:09 <tdammers> vanila: what about printf "%-02.5d %04x" [23, 52]
05:23:23 <tdammers> how would you do that with your concat/show approach?
05:25:57 <Yuu_chan> Btw, is there a simple "%x.yf" equivalent? Like showFloating :: Floating a => Int -> Int -> a -> String
05:30:34 <quchen> Yuu_chan: Numeric has a couple of functions to show numbers, maybe there's something in there.
05:30:39 <quchen> http://hackage.haskell.org/package/base-4.7.0.0/docs/Numeric.html
05:32:30 * rwbarton just uses printf
05:32:52 <pjdelport> http://hackage.haskell.org/package/text-format has some stuff for Text
05:33:05 <quchen> rwbarton: You monster! ;-)  (Well, everyone does.)
05:33:22 <vanila> The printf formatting language is nice but I think it's a shame to give up on embedding it in haskell in a type-safe way
05:33:31 <Yuu_chan> quchen: yay, thank you!
05:33:31 <chrisdone> https://github.com/chrisdone/formatting
05:34:26 <quchen> New Haskell rule: there's always a chrisdone or edwardk library to do that.
05:34:55 <Yuu_chan> chrisdone: I like what you did there
05:35:02 <chrisdone> quchen: that's like comparing a shoe to a tank
05:35:33 <quchen> chrisdone: No army wins without shoes
05:35:41 <vanila> "Holey Monoids" love it
05:35:44 * Yuu_chan went to replace all printfs
05:35:47 <vanila> This is great
05:36:08 <quchen> Why did I not know about this
05:36:41 <chrisdone> i'mma write a blog post about it eventually
05:37:25 <klrr_> oh that seems interesting, is it kinda like printf in Idris?
05:37:30 <Yuu_chan> chrisdone: could you add locale-specific number formatting?
05:39:01 <chrisdone> yuu_chan: i'm open to locale-specific formatting if it doesn't complicate the library much
05:40:35 <chrisdone> there seems to be no standard i18n package for haskell yet
05:41:31 <chrisdone> klrr_: sort of
05:41:54 <chrisdone> idris can unpack strings in the type system
05:42:05 <chrisdone> i don't know if singletons can do that yet
05:42:37 <chrisdone> can you pattern match on a type-level string with a closed type family?
05:43:09 <rwbarton> I think you can compare for ordering ......
05:43:30 <chrisdone> i mean like this:
05:43:31 <chrisdone> type family Elem x xs :: * where
05:43:31 <chrisdone>   Elem y Nil         = False
05:43:31 <chrisdone>   Elem y (Cons y xs) = True
05:43:33 <chrisdone>   Elem y (Cons x xs) = Elem y xs
05:43:45 <chrisdone> here i'm pattern matching on a type-level list to check if an element exists in it
05:43:46 <rwbarton> oh but you can't say "tail"
05:44:27 <rwbarton> you can test whether the string starts with a '%' by checking whether it's between '%' and whatever the character after '%' is, but you can't then get the rest of the string
05:44:30 <chrisdone> maybe tailMay
05:45:18 <rwbarton> they're not really strings so much as opaque symbols
05:45:30 <chrisdone> ah
05:46:18 <chrisdone> if you could symbol->string them into a type-level list that'd be neat
05:47:42 <quchen> chrisdone: I also like that the package has no String capability :-)
05:47:56 <chrisdone> quchen: =3
05:49:18 <chrisdone> rwbarton: i guess you'd also need a type for every character, too
05:49:49 <chrisdone> or some kind of special syntax to express '%' :: HChar '%'
05:49:52 <chrisdone> or w/e
05:50:27 <Christoph5> I'm trying to get mueval running after upgrading from ubuntu 12.04 to 14.04 and it always dies with "mueval: ExitFailure 1 mueval: Prelude.undefined"
05:50:31 <Christoph5> it used to work fine
05:50:40 <christianpbrink> QuickCheck question... is it possible to do I/O in a generator without using Test.QuickCheck.Monadic?
05:50:43 <Christoph5> any ideas?
05:51:20 <Christoph5> google sent me here because I found that lambdabot had the same problem last month
05:51:38 <chrisdone> Christoph5: that's weird. i'd grep the source for undefined
05:52:26 <chrisdone> quchen: you posted my lib before i had a chance to blog about it =p
05:52:27 <Christoph5> http://codepad.org/mGul3IOa <- this is what I did
05:53:22 <quchen> chrisdone: Word has to get out there!
05:53:37 <quchen> (Should I delete it again? I thought you meant to write a blog post "in some time", as in, never)
05:54:16 <chrisdone> eh, it's ok, i commented a link to the more comprehensive examples and extension guide in the README
05:54:36 <ccapndave2> Is record syntax less performant than normal data types?
05:54:44 <ccapndave2> Or does the compiler make them equivalent
05:54:47 <christianpbrink> Or: even if it's possible to do I/O in a generator without using Test.QuickCheck.Monadic, is it conventional to use that module when doing so?
05:56:08 <int-e> Christoph5: that's weird, because lambdabot's mueval was compiled in april.
05:56:08 <Christoph5> chrisdone: hm... should have been obvious, how could I miss that
05:56:24 <quchen> chrisdone: Any reason there's no binary/octal?
05:56:26 <Christoph5> there seems to be a hardcoded time limit in watchdog.hs
05:56:41 <int-e> chrisdone: did you see my lpaste question?
05:56:55 <Christoph5> I increased it by a factor of 10, now it works
05:57:05 <Christoph5> but mueval is incredibly slow now
05:57:22 <Christoph5> ~20 seconds to evalute "1+1"
05:59:17 <chrisdone> quchen: no design decision, it's just that text-format comes with a hex displayer, so i included it: http://hackage.haskell.org/package/text-format-0.3.1.1/docs/Data-Text-Format.html
05:59:25 <klrr_> could someone help me with this syntax error? http://lpaste.net/899170073640435712 i get "src/CPSConv.hs:25:6: parse error on input `in'" and im not sure why
05:59:43 <chrisdone> int-e: what lpaste question?
05:59:55 <quchen> chrisdone: Ah, I see. Well, I guess I'll have to send a patch in case I need it. :-)
06:00:04 <chrisdone> sure =)
06:00:27 <Aetherspawn-> klrr_: I dont think you can have a 'in' inside a do
06:00:45 <Aetherspawn-> if you removed 'in', your code would be the same
06:00:48 <chrisdone> quchen: of course, the nice thing is you can extend it without having to patch the library giving you a grace period to try a formatter out before submitting it upstream
06:00:53 <klrr_> oh
06:01:00 <klrr_> Aetherspawn-: that's certainly the problem, thanks
06:01:17 <klrr_> now it works, awesome.
06:01:20 <int-e> chrisdone: I was wondering whether lpaste imposes some upper limit on the paste size (there's a pull request by benzrf to allow lambdabot fetch pastes as @let input)
06:01:23 <quchen> chrisdone: Is there a way to combine Formats? Like "Print 100 in hex, and pad it to the left with '.' to length 10"?
06:01:37 <chrisdone> int-e: no, it imposes no limit presently
06:01:58 <int-e> thanks
06:02:36 <chrisdone> quchen: yeah,
06:02:37 <chrisdone> λ> format (left 2 '0' %. hex) 10
06:02:38 <chrisdone> "0a"
06:02:59 <chrisdone> %. is like % but feeds one formatter into another
06:03:13 <quchen> Ah, I missed that operator.
06:03:16 <chrisdone> not sure that's the best way to do it, but i'm trying it out
06:03:34 * hackagebot diagrams-postscript 1.1 - Postscript backend for diagrams drawing EDSL  http://hackage.haskell.org/package/diagrams-postscript-1.1 (bergey)
06:04:22 <quchen> (%.) isn't available in the API though
06:04:38 <chrisdone> hm let me see
06:04:48 <quchen> http://hackage.haskell.org/package/formatting-5.0/docs/doc-index.html
06:05:30 <chrisdone> ah, i need to push a new hackage version
06:05:41 <chrisdone> i made this operator only recently as i realised it was a use-case
06:07:58 <int-e> Christoph5: mueval is slow, but 20 seconds is excessive. In my experience, most of the time is spent on linking in packages - how long does ghci take to evaluate the same expression?
06:08:23 <chrisdone> quchen: this version also makes Holey a functor, replacing the hmap function
06:08:34 * hackagebot tz 0.0.0.5 - Efficient time zone handling  http://hackage.haskell.org/package/tz-0.0.0.5 (MihalyBarasz)
06:08:36 * hackagebot formatting 5.1 - Combinator-based type-safe formatting (like printf() or FORMAT)  http://hackage.haskell.org/package/formatting-5.1 (ChrisDone)
06:08:40 <tomejaguar> formatting is extremely cool
06:08:47 <quchen> I really don't understand Holey, but it sounds like I should try to.
06:08:49 <int-e> Christoph5: If linking is indeed the bottleneck, then there's a huge potential gain from using shared libraries.
06:08:55 <quchen> Conceptually it seems simple.
06:09:23 <chrisdone> quchen: probably an easier one to understand is: http://hackage.haskell.org/package/HoleyMonoid
06:09:37 <quchen> chrisdone: You reimplemented that in your lib?
06:09:41 <chrisdone> on which formatting is based. but they don't expose the constructor which i needed
06:09:43 <chrisdone> yeah
06:10:01 <chrisdone> it's almost a verbatim copy-paste, but i reversed some type args to get the functor instance, and i don't have a category instance
06:10:14 <quchen> chrisdone: So a Holey is basically a DList-like monoid that builds up a chain of functions with either values or "function args left open"?
06:10:20 <chrisdone> (i thought % would be less intrusive than importing Control.Category)
06:11:37 <int-e> Christoph5: (still, ghc -e '1+1'  is 3 times faster than mueval --expression '1+1' for me, but the latter takes about half a second)
06:11:50 <quchen> You copypasted it because the other lib seems unmaintained, I assume, chrisdone?
06:12:05 <Christoph5> OK, the problem was that my VM config was broken and it had way too little CPU. mueval is not to blame
06:12:21 <tomejaguar> quchen: I don't think Holey's got anything to do with DList, except they're both continuation-ish
06:12:33 <Aetherspawn-> it's so tiny
06:12:40 <Aetherspawn-> probably not worth the dependency
06:12:52 <chrisdone> quchen: holeymonoids seemed like a nice library in and of itself. very easy to read. i didn't want to complicate it
06:13:57 <Brody> Hello, what would be your initial reaction to someone who said he is making a 2d Realtime strategy game similar to BroodWar using Haskell?
06:14:22 <Axman6> excellent and best of luck!
06:14:24 <tdammers> Brody: hypothetically speaking? I'd say "hello" or something like that.
06:15:32 <chrisdone> quchen: emm echoing what tomejaguar said, i don't know how similarly it matches dlists. the `r` is a continuation, like in printf's but rather than applying immediately it builds up args, like ap
06:15:43 <frerich> Brody: "Does it have Orcs?"
06:15:58 <klrr_> why wont fmap or (<*>) work on this monad http://hackage.haskell.org/package/monad-gen-0.1.0.0/docs/Control-Monad-Gen.html ? it looks like it implements instances for both functor and applicative to me
06:16:14 <mmmm> what is the error message
06:16:30 <Axman6> Brody: it's definitely doable, but how you'd go about I'd have no idea (but I wouldn't have any idea in any language)
06:17:16 <Brody> frerich ha nice. Axman6 thankyou for the relpy
06:17:30 <Axman6> Brody: how much Haskell do you know?
06:17:41 <chrisdone> quchen: shachaf has a nice version that works with basic function composition
06:18:25 <chrisdone> http://www.reddit.com/r/haskell/comments/14met7/oleg_typesafe_formatted_io/c7f8un6
06:18:27 <quchen> chrisdone: So a "Holey m r a" encapsulates a monoidal type m, an r, and builds up a "result function type" a
06:18:39 <quchen> What's the "r" for?
06:18:46 <klrr_> oh forgot to cotrain the m..
06:18:52 <klrr_> constrain
06:19:18 <tomejaguar> Brody: "Hurry up and finish so I can play it" :)
06:20:07 <Brody> axman6 I am a beginner programmer, 6 months of python and 2 months of haskell. I am not delusional though, I know I cant make a game (especially a huge complex one like that). tomejaguar haha :)
06:20:18 <chrisdone> quchen: r is the return result, and the a is where functions are built up
06:20:47 <Axman6> Brody: you might be surprised how easy it is. just need to put your mind to to. You'd learn a lot even if you failed to complete it
06:21:11 <chrisdone> quchen: newtype HoleyT r a m = Holey { runHM :: (m -> r) -> a }
06:21:16 <quchen> chrisdone: Ah, so "a" will be a function type with "r" at the end?
06:21:34 <tdammers> the nice thing about a game as a learning project is that it's not as open-ended as other things
06:21:41 <chrisdone> oh, the flipping of the args from HoleyT to Holey confuses this
06:22:00 <tdammers> you'll make an unmaintainable mess anyway, but at least with a game you can draw a line and say "this is it, it's done, I'm not touching that code ever again"
06:22:06 <chrisdone> quchen: right
06:22:18 <quchen> chrisdone: I'm only talking about the Holey in your lib, Holey m r a = (m -> r) -> a
06:22:26 <quchen> Ah, I understand. Excellent.
06:22:28 <chrisdone> quchen: compare: now :: m -> Holey m r r
06:22:29 <chrisdone> quchen: and: later :: (a -> m) -> Holey m r (a -> r)
06:22:43 <Brody> tdammers nice thinking
06:22:54 <flux> tdammers, you say like there's a point when you have nothing to add or fix in a game..
06:23:23 <flux> maybe you can get there if your game is a tetris
06:23:25 <tdammers> flux: no; I'm saying there's a point in making a game where it's complete enough
06:23:43 <chrisdone> λ> :t Holey id
06:23:44 <chrisdone> Holey id :: HoleyT r (m -> r) m
06:23:44 <chrisdone> which is like… Holey m r (m -> r)
06:23:57 <tdammers> with most software, people will start using it and come up with feature requests
06:24:20 <quchen> chrisdone: Ah, "now" simply creates a Holey without holes; later creates a Holey with a new hole (which adds an "a" to the 3rd Holey parameter).
06:24:22 <tdammers> they'll start using your code for things you didn't anticipate, and you add features, and it starts to develop
06:24:31 <quchen> But now I'm confused about the (a -> m) again.
06:24:43 <tdammers> but with a game, it's more like you get it to the point where it's playable and fun, and people play it, and that's it
06:24:57 <tdammers> although some games are more like non-games in that regard
06:24:58 <chrisdone> quchen: because later is supposed to take some arbitrary arg (like an Int) and return a monoid, in our case a Builder
06:25:00 <tdammers> modding and all that
06:25:15 <quchen> chrisdone: Aaah, if we wanted it to work with monoids only, m~r.
06:25:28 <quchen> But Int isn't a Monoid, so you left the final "to monoid" mapping open?
06:25:46 <chrisdone> hm?
06:25:49 <frerich> tdammers: Alas, my personal experience is that my games usually end up being engines. Or frameworks. 8-[
06:26:24 <tdammers> frerich: it takes quite some discipline, I'm not denying that
06:26:30 <Brody> frerich have you got a spare RTS engine going free?
06:26:37 <chrisdone> λ> later show
06:26:38 <chrisdone> later show :: Show a => Holey String r (a -> r)
06:26:38 <zomg> frerich: that's why I gave up writing a game from scratch and have just been using Unity and such... :D
06:26:48 <quchen> chrisdone: Suppose m=r in all Holeys. The thing would still work conceptually, but you could only build Holey values with monoidal values. In the current implementation however, you can use non-monoids too.
06:26:55 <zomg> frerich: though none of them end up being complete even with that
06:28:04 <frerich> One of my first games was Solitaire and I ended up with a framework which allows you to define a deck of cards and rules using propositional logic so the same framework worked for Solitaire as well as Uno.
06:28:19 <zomg> heh
06:28:21 <frerich> Of course, I didn't actually finish either game unless you consider text mode with lame ascii art as finished.
06:28:36 * hackagebot haddock-library 1.1.0 - Library exposing some functionality of Haddock.  http://hackage.haskell.org/package/haddock-library-1.1.0 (MateuszKowalczyk)
06:29:07 <chrisdone> quchen: you can definitely build holeys without m being a monoid, but when you want to compose them you'll have to decide on a composition operation, of course
06:29:09 <zomg> I kinda wanna make an xcom-like game, but with multiplayer player vs player combat and such
06:29:17 <chrisdone> in this case %, but yeah, it could also be (+) or (*)
06:29:30 <tdammers> frerich: given enough effort, every software project eventually ends up being a programming language
06:29:42 <zomg> but as with many of my projects I really don't have the time or focus :P
06:29:44 <pjdelport> Brody: Making a Haskell game is ambitious, but ambition is good. :) You might want to look at http://www.haskell.org/haskellwiki/Applications_and_libraries/Games
06:29:56 <zomg> I get pulled into something else cool that catches my fancy
06:30:13 <frerich> tdammers: For large values of 'eventually', yes. It happens much earlier for configuration file formats though. :-}
06:30:28 <Brody> pjdelport thankyou
06:30:45 <tdammers> frerich: I accidentally invented a programming language when I set out to make a template engine that could target both PHP and JavaScript
06:30:51 <chrisdone> later show :: Show a => Holey String r (a -> r)
06:30:52 <chrisdone> runHM (later show) :: Show a => (String -> r) -> a -> r
06:30:52 <chrisdone> runHM (later show) id :: Show a => a -> String
06:30:52 <chrisdone> runHM (later show) id 5 → "5"
06:31:32 <zomg> tdammers: are there any other options beyond mustache for that?
06:31:36 <quchen> tdammers: Fun fact, PHP was invented in a similar way
06:31:37 <zomg> or mustache-like languages
06:31:53 <frerich> tdammers: Right. Any kind of data format (e.g. templates) which gets extended with conditionals eventually ends up as LISP.
06:32:36 <pjdelport> frerich: In the best case. (see aforementioned PHP)
06:32:39 <tdammers> zomg: not that I know of. That's part of why I made my own.
06:33:15 <zomg> yeah some years ago had to find a solution like that as well
06:33:21 <zomg> just went with mustache despite it being annoyingly limited
06:34:58 <tdammers> hpaco
06:35:01 <tdammers> it's on hackage
06:35:15 <tdammers> bit unpolished though
06:35:21 <tdammers> and haven't touched it in a while
06:37:27 <Aetherspawn-> its impossible to write ghcs garbage collector in Haskell, right?
06:38:42 <quchen> Everything's possible, the question is whether it makes sense.
06:39:19 <quchen> Writing the RTS in C was probably done because it had better low-level capabilities.
06:39:23 <rwbarton> it sounds pretty impossible to me
06:39:53 <Aetherspawn-> the new IO manager is haskell
06:39:57 <rwbarton> unless you're going to define a non-GCed fragment of the language to write it in
06:40:04 <Aetherspawn-> alas it didn't have to do allocation
06:40:06 <arw> writing the gc in haskell would mean having to write haskell that doesn't rely on a working gc.
06:40:19 <Cale> It sounds possible to me. Just have that Haskell code generate C--
06:40:28 <quchen> Haskell doesn't rely on GC, does it?
06:40:32 <Aetherspawn-> or alternatively, write important allocation routines in cmm
06:40:32 <rwbarton> Cale: or C!
06:40:35 <arw> Cale: wouldn't that be cheating?
06:40:39 <rwbarton> yes
06:40:39 <Cale> arw: Why?
06:40:40 <Aetherspawn-> and then write the *actual* collector in Haskell
06:40:45 <quchen> (Is there a language that relies on GC at all?)
06:40:48 <Aetherspawn-> then you dont pay for the FFI swap between haskell and the gc
06:41:11 <rwbarton> I can write a Haskell program that outputs the entire contents of rts/sm/
06:41:12 <tdammers> quchen: lots of languages kind of require some sort of automatic memory management
06:41:17 <Cale> I mean, you could treat the construction of the GC as part of the codegen
06:41:21 <luite> gc = putStrLn "void gc() { ... }"
06:41:45 <Aetherspawn-> luite: it's quite a bit larger than that ;)
06:41:50 <rwbarton> I mean, some low-level parts of the RTS are produced that way already
06:42:12 <arw> Cale: well, the definition for 'in haskell' would have to be somewhat more flexible
06:42:26 <rwbarton> all the stg_ap_ppv_fast etc.
06:42:33 <quchen> tdammers: In what way? Without GC you need a giant load of memory, but the power of the language should be independent of that. Similarly, you could introduce a Haskell primitive "nGC :: a -> a" that disables GC in its argument.
06:42:46 <luite> Aetherspawn-: that's what the dots are for, the rest is just scribbling
06:42:46 <Aetherspawn-> rwbarton: thats all cmm
06:42:49 <arw> Cale: you don't write stuff 'in assembler' just because your C compiler happens to generate it as an intermediate step
06:42:57 <rwbarton> Aetherspawn-: yes, but it's generated by a Haskell program
06:43:02 <rwbarton> but, I think (like you) this is rather uninteresting
06:43:04 <Aetherspawn-> .. really?
06:43:13 <Cale> arw: No, if you wrote C code, then you wrote the code in C :)
06:43:41 <arw> Cale: hm, right. I think that was your point.
06:43:42 <Cale> arw: This would involve writing Haskell code which happens to generate assembly or some other intermediate representation language for the GC.
06:43:57 <Aetherspawn-> One way you could definately do it would be to write the allocation routines in cmm
06:44:03 <arw> Cale: yes, I'm convinced you are right
06:44:10 <Aetherspawn-> then write the actual collector in Haskell, such that the collector makes junk the same as the rest of the program
06:44:25 <rwbarton> Aetherspawn-: utils/genapply/GenApply.hs
06:45:47 <luite> i stole the GenApply idea for ghcjs :) ( https://github.com/ghcjs/ghcjs/blob/master/src/Gen2/RtsApply.hs )
06:46:09 <Aetherspawn-> wow
06:46:20 <Aetherspawn-> that's neat.
06:46:36 <luite> oh hm, i should really fix that fixme before release...
06:48:44 <Aetherspawn-> anyone know where to find the AP_STACK stuff
06:50:22 <mmmm> Is anyone here familar with Text.XML.Light?
06:50:49 <mmmm> If so, what does the CRef constructor correspond to?
06:51:16 <ccapndave2> Hey everyone - I am a bit stuck with pattern matching.  I am trying to only match a certain pattern if a condition is true, but can't figure out how to do it.  Line 29 of https://gist.github.com/ccapndave/55630eeca7ab8ebf981d is the problem
06:51:44 <ccapndave2> I looked at http://www.haskell.org/haskellwiki/Pattern_guard, but don't really understand what it means or if its relevant
06:52:09 <frerich> ccapndave2 : Try "Just (flavour, count)" i.e. put the tuple values in parentheses.
06:52:10 <Cale> ccapndave2: Well, you could write   matcher (Just (NormalSymbol i), count) (NormalSymbol i') | i == i' = ...
06:52:24 <Cale> what?
06:52:29 <frerich> Err, wait
06:52:42 <frerich> I see you also have "Nothing, count".
06:52:43 <ccapndave2> Only the flavour is Maybe
06:52:53 <Cale> yeah
06:53:11 <Cale> This isn't a type problem, he just wants the pattern to match differently, as I understand it
06:53:19 <ccapndave2> Yeah, the types are fdine
06:53:24 <Cale> ccapndave2: Does the change I suggested make sense?
06:53:27 <ccapndave2> I think its a Haskell syntax problem
06:53:36 <ccapndave2> I'm just trying it - you are saying that a pipe lets me add a guard
06:53:39 <ccapndave2> Right?
06:53:39 <Cale> yes
06:53:53 <Cale> and you can test the two Int values for equality that way
06:54:28 <ccapndave2> AWesome!
06:54:30 <ccapndave2> Thanks :)
06:54:33 <ccapndave2> That totally works
06:54:34 <Cale> Or of course, if you prefer, you could leave the pattern as is, and use a guard like  | flavour == NormalSymbol i
06:54:42 <ccapndave2> That's what I did
06:54:49 <ccapndave2> Hang on, I'll update the gist
06:55:01 <ccapndave2> https://gist.github.com/ccapndave/55630eeca7ab8ebf981d
06:55:17 <ccapndave2> Are you saying there is a prettier way to do this?  There are a lot of 'matcher's
06:55:52 <Cale> ccapndave2: You could use a case expression instead
06:56:12 <Cale> hmm
06:56:26 <ccapndave2> I couldn't figure out the syntax to do pattern matching in cases
06:56:31 <ccapndave2> (I am a noob, in case you didn't realise ;) )
06:56:36 <Cale> Well, that's all that case expressions do
06:56:44 <Cale> (is pattern match)
06:56:57 <Aetherspawn-> you can do it possibly prettier but less succinctly :\
06:57:11 <Aetherspawn-> using mixtures of pattern guards and cases
06:57:54 <Cale> Note that matcher (x,count) (WildSymbol _) = (x, count + 1)
06:58:10 <Cale> That cuts the number of cases down a bit
06:58:30 <ccapndave2> Oh yeah
06:58:33 <ccapndave2> Good spot
06:58:44 <pjdelport> Re. earlier, is there any existing formal subset of Haskell that doesn't require GC?
06:58:51 <ccapndave2> Any other comments about this code in general?
06:58:55 <pjdelport> (or other "heavy" features?)
06:59:09 <Cale> pjdelport: Haskell will theoretically be just fine if you never GC, you'll just use a lot of memory in a hurry
06:59:17 <Aetherspawn-> pjdelport: prettymuch no.
06:59:19 <pjdelport> It's certainly possible to write a runtime GC in something like that: PyPy's RPython is a good example of that.
06:59:31 <Aetherspawn-> Oh, there's ddc
06:59:37 <Cale> ccapndave2: It's unusual to be using foldl
06:59:39 <Aetherspawn-> that has an Alloc effect you can avoid using
06:59:40 <steffen> Can I write a "data-constructor-synonym", meaning having a dataconstructor Asc :: Bool and Desc :: Bool?, so that Asc is synonym for True and Desc a synonym for False?
06:59:44 <ccapndave2> Cale ok
06:59:48 <Cale> ccapndave2: Usually you either want foldr or foldl'
06:59:55 <ccapndave2> Cale Really?
06:59:59 <pjdelport> Cale: Right, but I mean a subset that's restricted or annotated in such a way that it can be compiled to non-GCed C-like code.
07:00:02 <rwbarton> steffen: with a new language extension in 7.8 you can
07:00:02 <Cale> ccapndave2: yes
07:00:03 <ccapndave2> Cale What is foldl'?
07:00:14 <Cale> ccapndave2: A stricter variant of foldl
07:00:19 <pjdelport> Cale: Analogous to RPython, in other words.
07:00:54 <pjdelport> http://www.haskell.org/haskellwiki/Monadic_regions comes to mind
07:00:56 <ccapndave2> foldr starts at the right hand side of the list and folds the left side into that, right?
07:01:00 <steffen> rwbarton: hmm okay, so thats a no for now... :(, But thank you for the answer :)
07:01:02 <Aetherspawn-> No, it folds right
07:01:04 <Aetherspawn-> left to right
07:01:04 <Cale> pjdelport: Perhaps something with no let/where?
07:01:07 <Aetherspawn-> O(1) memory
07:01:21 <Cale> @src foldr
07:01:21 <lambdabot> foldr f z []     = z
07:01:21 <lambdabot> foldr f z (x:xs) = f x (foldr f z xs)
07:01:23 <Aetherspawn-> foldl is bad because it uses memory proportional to the size of the list
07:01:32 <rwbarton> steffen: also possible with the C preprocessor? :) #define Asc True
07:01:42 <Cale> @src foldl
07:01:42 <lambdabot> foldl f z []     = z
07:01:42 <lambdabot> foldl f z (x:xs) = foldl f (f z x) xs
07:01:48 <steffen> rwbarton: hihihi :)
07:01:54 <ccapndave2> So foldr takes the 1st element of the list first, then the 2nd, etc
07:02:01 <pjdelport> ccapndave2: foldr right-associates, foldl left-associates.
07:02:03 <Cale> foldl does nothing but greedily call itself with new arguments until it reaches the end of the list
07:02:03 <Aetherspawn-> Cale: thats still hard to understand
07:02:04 <Aetherspawn-> :C
07:02:18 <Cale> while foldr f z (x:xs) immediately passes control to f
07:02:24 <rwbarton> pjdelport: reading the description of RPython now, so far it sounds a lot like haskell :P
07:02:33 <Aetherspawn-> (the @src stuff, that is)
07:02:45 <Cale> If f doesn't examine its second argument, then the foldr might terminate early
07:03:06 <pjdelport> rwbarton: It does? It *should* sound a lot more like C. :)
07:03:15 <rwbarton> well, that too
07:03:40 <Cale> and if f is able to produce some of its result without examining that second argument, the foldr might work fine even on infinite lists:
07:03:53 <Cale> > foldr (\x xs -> x:x:xs) [] [1..]
07:03:54 <lambdabot>  [1,1,2,2,3,3,4,4,5,5,6,6,7,7,8,8,9,9,10,10,11,11,12,12,13,13,14,14,15,15,16,...
07:04:00 <ccapndave2> Cale Ok, but foldr f z [1, 2, 3] would pass 1, then 2, then 3
07:04:12 <rwbarton> I mean that so far haskell mostly has these properties of RPython
07:04:12 <Cale> > foldr f z [1,2,3]
07:04:14 <lambdabot>  f 1 (f 2 (f 3 z))
07:04:18 <rwbarton> I guess the catch will come when I get to GC
07:04:37 <Cale> Yeah, 1 comes first. (Remember that lazy evaluation is outermost-first)
07:04:51 <ccapndave2> Sweet
07:05:07 <Aetherspawn-> you can take the direction literally
07:05:18 <Aetherspawn-> lists are always constructed left to right essentially
07:05:19 <ccapndave2> This is confusing ;)
07:05:22 <pjdelport> rwbarton: It's no more properties than C has; it really lacks anything Haskell-like. No run-time definition of functions, for example. :)
07:05:32 <Aetherspawn-> foldr is left to right (if you imagine the list as a long strip of papers with squares on it)
07:05:34 <ccapndave2> foldr f z [1,2,3] = f 1 (f 2 (f 3 z))
07:05:37 <Aetherspawn-> and foldl is right to left
07:05:41 <ccapndave2> What would be the equivalent expansion for foldl?
07:05:52 <Cale> You physically can't process lists in any order other than left to right
07:05:59 <chrisdone> i suggest you try it manually
07:06:01 <Cale> Because they're singly linked lists
07:06:09 <chrisdone> @src foldl
07:06:09 <lambdabot> foldl f z []     = z
07:06:09 <lambdabot> foldl f z (x:xs) = foldl f (f z x) xs
07:06:13 <Cale> You *must* decompose them starting at the beginning
07:06:20 <ccapndave2> ok
07:06:22 <chrisdone> try expanding foldl (+) 0 [1,2,3]
07:06:23 <ccapndave2> I think I see
07:07:14 <Cale> I'll do it: foldl (+) 0 [1,2,3] -> foldl (+) (0+1) [2,3] -> foldl (+) ((0+1)+2) [3] -> foldl (+) (((0+1)+2)+3) [] -> ((0+1)+2)+3
07:07:26 <ccapndave2> Wow, quicker than me
07:07:29 <Cale> Note that this expression is growing in memory
07:07:33 <ccapndave2> I had got as far as writing fold (+) ;)
07:07:34 <Aetherspawn-> isn't that foldr
07:07:38 <Aetherspawn-> I would have expected 0 + (1 + (2 + 3)) ?
07:07:41 <pjdelport> ccapndave2: The diagrams in https://en.wikipedia.org/wiki/Fold_(higher-order_function) are quite illustrative.
07:07:48 <Cale> Aetherspawn-: you have them backward
07:07:58 <Cale> (I made those diagrams! :D)
07:08:02 <Aetherspawn-> 0 + next
07:08:06 <Aetherspawn-> 0 + (1 + next)
07:08:06 <pjdelport> Cale++ !
07:08:07 <Aetherspawn-> and so on
07:08:36 <ccapndave2> Ok
07:08:38 <ccapndave2> Thanks
07:08:39 * hackagebot lord 2.20140625 - A command line interface to online radios.  http://hackage.haskell.org/package/lord-2.20140625 (rnons)
07:08:40 <Jaak> > foldl (+) a [b, c, d]
07:08:40 <chrisdone> cale: way to spoil the exercise
07:08:41 <lambdabot>  a + b + c + d
07:08:41 <ccapndave2> That was very helpfuly :)
07:08:52 <Jaak> well that's useful
07:09:09 <Cale> ccapndave2: If your list were a million elements long, then this ((0+1)+2)+3 would end up being much larger of course. This is not only a problem from the perspective that it'll take a lot of space to accumulate, but also the fact that because (+) will pattern match on both of its arguments, many of those pattern matches will have to wait on the stack while the first argument is evaluated
07:09:13 <quchen> @quote socratic
07:09:13 <lambdabot> chrisdone says: It's actually impossible to employ the socratic method in here. Ask a newbie a question and it *will* be answered by someone else.
07:09:15 <quchen> :>
07:09:21 <chrisdone> quchen: =)
07:09:28 <monochrom> hehe
07:09:38 <pjdelport> I think it's very misleading as thinking of either foldr and foldl as operating "to the right" or "to the left", because that suggests a certain evaluation order. It's much clearer just to say that foldl is left-associative and foldr is right-associative.
07:09:39 <Cale> and you might get a stack overflow that way if GHC isn't smart enough to pick up on it (it turns out in this case, it is smart enough with optimisations turned on)
07:09:54 <Cale> pjdelport: yes
07:09:56 <augur> is there any way to parameterize a module by a value?
07:09:56 <pjdelport> And that should also make it clear why foldr more naturally matches the structure of lists, because (:) is also right-associative.
07:10:24 <ccapndave2> Hmm
07:10:33 <Aetherspawn-> augur: oh, you.
07:10:35 <ccapndave2> Just swapping foldl for foldr breaks my types
07:10:36 <Cale> In any case, they both process the list left-to-right, it's just that the expression tree/graph they produce associates one way or the other.
07:10:39 <ccapndave2> Better read the manual
07:10:48 <Aetherspawn-> augur: did you read about Backpack on reddit/r/haskell ?
07:10:51 <Cale> ccapndave2: Yeah, the function takes the arguments in the opposite order
07:10:51 <pjdelport> And that's why (non-strict) foldl is not so great, because it operates against the natural grain of lists.
07:11:05 <augur> Aetherspawn-: no
07:11:16 <Cale> ccapndave2: If you were using foldr, you'd have matcher :: Symbol -> WinLineMatch -> WinLineMatch
07:11:16 <Aetherspawn-> oh, I thought your question was cheek
07:11:19 <monochrom> 1+(2+3) is about parsing, not evaluation order. highschool says "evaluation order" for simplicity; it is not like highschool introduces non-strict operators anyway. (but they should. if-then-else is a useful non-strict operator.)
07:11:29 <ccapndave2> ah, that function
07:11:38 <Aetherspawn-> augur: this might be what you want http://plv.mpi-sws.org/backpack/
07:11:52 <augur> Aetherspawn-: no. im defining a plugin system, where one particular plugin needs to be able to reference the plugin system as a whole
07:12:16 <ccapndave2> Cool
07:12:21 <ccapndave2> Except now my algorithm doesn't work
07:12:47 <ccapndave2> That's weird
07:12:53 <augur> i guess i can just parameterize all the things in this module
07:13:01 <Cale> ccapndave2: In this case, probably the right thing if you want to be efficient is to use foldl' really, and put a ! on the first occurrence of count in order to force its evaluation as you go.
07:13:20 <rwbarton> augur: or you can pack them into a record and parameterize that
07:13:51 <augur> rwbarton: yes, indeed.
07:13:53 <Cale> ccapndave2: (at present, your function will build up a potentially-large expression which looks like ((((0 + 1) + 1) + 1) + 1) in the second component of the pair)
07:14:06 <chrisdone> monochrom: in high school maths?
07:14:19 <Aetherspawn-> Cale: I evaluate things from the deepest nested brackets outwards
07:14:22 <augur> rwbarton: tho, the module serves only to declare a single variable plugin, so.. :p
07:14:28 <Aetherspawn-> and that *really* looks like foldr to me
07:14:29 <monochrom> yes, in high school maths
07:14:41 <Cale> Aetherspawn-: That's called strict evaluation, and it's not a valid way to evaluate Haskell code.
07:14:59 <Aetherspawn-> it's how humans read stuff though..
07:15:01 <pjdelport> Aetherspawn-: Haskell always evaluates "outside-in"
07:15:07 <Cale> Aetherspawn-: speak for yourself
07:15:12 <chrisdone> monochrom: where does strict or laziness enter high school maths?
07:15:15 <Aetherspawn-> essentially you've flipped + around to make it confusing
07:15:35 <monochrom> Cale, please call it eager evaluation. either that, or say "non-strict evaluation" for its opposite. eager vs lazy. strict vs non-strict.
07:16:11 <Aetherspawn-> we read left to right
07:16:20 <Aetherspawn-> and most of us evaluate left to right too, when given the chance.
07:16:35 <chrisdone> i suspect even evaluation order of arguments in c is undefined
07:16:36 <Cale> monochrom: I understand why that makes more sense in some ways, but I've heard "eager evaluation" used to refer to some more complicated schemes
07:16:41 <frerich> Cale: You created those pretty graphs visualizing how 'foldl' and 'foldr' work (on the Wikipedia page)? Thanks a lot for them, I remember that they were quite the eye-opener for me :-)
07:16:49 <Cale> frerich: yeah
07:16:50 <ccapndave2> Cale: I don't seem to have foldl'
07:16:55 <frerich> In fact, it's still how I remember their difference ("foldl" having the "left arm")
07:17:02 <Cale> http://cale.yi.org/share/Folds.png
07:17:05 <Cale> ^^ some more there
07:17:13 <Cale> ccapndave2: import Data.List
07:17:17 <m1dnight__> guys, quick question. A while ago I read about a web framework on Hackernews for haskell. The framework spit out a frond- and backend. It allowed for typesafety across front and backend.
07:17:21 <m1dnight__> does that ring a bell to anyone?
07:17:25 <m1dnight__> it's not snap.
07:17:33 <joshkirklin> when using getChar, the input character is echoed back to stdout. is there a way to prevent this?
07:17:34 <ccapndave2> Thanks
07:17:40 <frerich> Cale: Pretty! Did you create them for some lecture or a book or something?
07:17:56 <Cale> frerich: They're by no means my idea though, people have been drawing expression graphs like that for quite a long time before I even started programming in Haskell :)
07:18:02 <Eduard_Munteanu> joshkirklin: hSetEcho IIRC
07:18:05 <Cale> (In fact, before Haskell existed)
07:18:32 <ccapndave2> Cale I'm not quite sure where to put the ! on count.  That's to make it evaluate eagerly, right?
07:18:43 <joshkirklin> Eduard_Munteanu, thanks
07:18:44 <Aetherspawn-> m1dnight__: wai?
07:19:02 <Eduard_Munteanu> joshkirklin: mind it's not getChar doing it but the terminal itself
07:19:06 <Cale> frerich: Well, I created them specifically to show to people here on IRC, and then I realised that the Wikipedia page on folds was absolute garbage, so I deleted and rewrote it.
07:19:14 <tdammers> m1dnight__: happstack? yesod?
07:19:14 <Eduard_Munteanu> You'll have to turn it back on after getChar.
07:19:37 <Cale> frerich: and people have edited it heavily since then
07:19:40 <chrisdone> f !x = … is like f = (\x -> x `seq` …)
07:19:52 <chrisdone> so you put ! on whatever needs to be evaluated before you even start evaluating the function
07:19:58 <joshkirklin> Eduard_Munteanu, that makes sense I think
07:19:59 <joshkirklin> thanks
07:20:02 <Cale> ccapndave2: Yeah, on the first occurrence of that variable
07:20:11 <frerich> Cale: Thanks a lot for that link to Folds.png, I didn't see that one before. I suppose you don't have some sort of vector graphic (SVG or so) of the picture?
07:20:17 <Aetherspawn-> you know
07:20:27 <m1dnight__> It could be happstack, I'm not sure
07:20:27 <Aetherspawn-> I think some of those graphs would look really nice if the operators were not in infix
07:20:36 <Aetherspawn-> then they would show laziness, too.
07:20:39 <Cale> ccapndave2: It makes it like you're pattern matching on a specific number for count, but without actually doing that -- so it forces the count to be evaluated, and then ignores the result
07:20:52 <frerich> Cale:I think it would be very nice for a Haskell cheat-sheet. Especially scan* and mapAccum* because I very very rarely use them. Or rather - I guess I *could* use them more often but I just don't realize it.
07:21:04 <Cale> Aetherspawn-: They look really great if animated
07:21:12 <Aetherspawn-> yes!
07:21:25 <Cale> http://www.cas.mcmaster.ca/~kahl/HOPS/
07:21:26 <monochrom> chrisdone: the major operators and functions introduced in highschool: +, *, /, sqrt, log, sin... they're all strict functions. since they're all strict, there is no need to mention strictness at all. since it's safe to use eager evaluation pervasively, there is no need to mention the issue at all. then it is also safe to conflate parsing and evaluation. imagine in Parsec "(+) <$> multiplicative_term <*> multiplicative_term". it is correct if you inten
07:21:26 <monochrom> d eager evaluation.
07:21:29 <frerich> Hmm, SVG can animate such things, too...
07:22:11 <ccapndave2> Cale Illegal bang-pattern (use -XBangPatterns)
07:22:18 <Cale> When I worked for a Summer at McMaster University, Dr. Kahl showed us his graph rewriting language HOPS
07:22:35 <dncr> Is there anything like "import Hugs.Observe" for GHC?
07:22:50 <Eduard_Munteanu> dncr: what does that do?
07:22:51 <Cale> ccapndave2: Adding {-# LANGUAGE BangPatterns #-} to the top of your file will also work if you don't want to pass the compiler another commandline flag
07:23:13 <ccapndave2> Cale Cool!
07:23:14 <ccapndave2> Thanks
07:23:23 <chrisdone> monochrom: + is strict on some numbers, yes =p
07:23:43 <dncr> Eduard_Munteanu: (observe x) is like (trace x) but it tells you what parts of x aren't evaluated
07:23:44 <chrisdone> monochrom: but does anyone in school deal with non-total maths where strict/non-strict differs?
07:23:48 <monochrom> well how many number systems does highschool introduce anyway?
07:23:55 <Cale> Watching some expressions get evaluated in HOPS taught me something about functional programming which I think it's really quite hard to learn or express clearly with words.
07:24:03 <monochrom> no
07:24:24 <Cale> Or at least, how functional programs are evaluated, if not the business of functional programming. :)
07:24:31 <Eduard_Munteanu> dncr: I vaguely remember the ghci debugger being able to show the evaluation state of stuff
07:24:34 <dncr> Eduard_Munteanu: (take 2 $ observe [0..]) prints "0 : 1 : _"
07:24:37 <Cale> There are a couple examples here: http://www.cas.mcmaster.ca/~kahl/HOPS/ANIM/index.html
07:24:43 <monochrom> see, the trick they play is they don't introduce the if-then-else operator.
07:25:04 <Cale> One of the really nice things about being able to see the expression graphs at runtime is that space leaks are totally obvious
07:25:05 <rwbarton> fundamentally, math is not about evaluation at all, though admittedly much of high-school math is
07:25:21 <frerich> Cale: Ah it's nice how memory usage directly relates to screen estate used :)
07:25:26 <Cale> They make the program actually take more space on the page, and you can see the retainers directly.
07:25:29 <Cale> yes
07:26:02 <frerich> It would be cool if there was a 'time line slider' control of some sort which you could drag and forther to control the animation.
07:26:12 <monochrom> if you're unable to say "if n=0 then 5 else 4/n", then it's safe to say "evaluate 4/n first" even if it's non-total.
07:26:17 <chrisdone> monochrom: true, i don't think i've ever seen a case analysis in high school
07:26:37 <Cale> I really wish that GHC had some kind of support for this sort of thing. There are some tools, but GHCs actual structures in memory don't really contain enough information to draw the graphs I'd like to see.
07:26:58 <monochrom> but it's a great loss to omit the if-then-else operator!
07:27:01 <rwbarton> Cale: you've seen ghc-vis?
07:27:04 <Cale> yeah
07:27:07 <chrisdone> monochrom: but nor were functions introduced, as something you could define. just uses of functions: sin, cos, tan, etc.
07:27:20 <rwbarton> dncr: let x = [0..] :: [Integer]; take 2 x; :print x
07:27:27 <rwbarton> dncr: or :sprint x
07:27:40 <monochrom> did you know: some people can go out of their way to use abs and sqrt to mimic if-then-else
07:27:56 <Aetherspawn-> I imagine you can reduce lambda calculus to heaviside functions
07:28:15 <dncr> monochrom: isn't avoiding conditionals with crazy math the name of the game for extreme performance?
07:28:23 <DineroxInternet> Alguien conoce a alguna persona que le gustaria ganar dinero por internet solo por navegar en paginas? no importa de que pais sean no es necesario invertir dinero - Anyone know someone who would like to earn money just by surfing on internet pages? no matter what country you are do not need to invest money - Alguém conhece alguém que gostaria de ganhar dinheiro apenas por navegar em páginas
07:28:23 <DineroxInternet> da Internet? não importa em que país você está não precisa investir dinheiro - MAIL: negociosporinternet@telmexmail.com
07:28:30 <Cale> Aetherspawn-: Heaviside functions are more powerful than anything the lambda calculus can express, because they're discontinuous, and hence uncomputable :)
07:28:40 <monochrom> what extreme performance? we're talking about highschool education.
07:28:44 <Cale> (well, on the reals!)
07:29:08 <Aetherspawn-> the sheer thought of it makes me happy inside
07:29:09 <monochrom> getting extremely high marks in Math Olympiads?
07:29:14 <Aetherspawn-> because it screams "SAT Solver!"
07:29:32 <chrisdone> i hated high school maths, anyway =)
07:29:32 <Cale> More like Turing oracle :)
07:29:54 <Eduard_Munteanu> Highschool is pretty bad at teaching calculation, they don't teach you any tricks yet you get sent off with a ton of homework.
07:30:00 <Cale> Shouldn't even be too hard to write a Turing oracle given a step function. :)
07:30:31 <Cale> The other way around, I'm not sure
07:30:39 <Cale> Maybe
07:30:43 <Eduard_Munteanu> Tricks as in methods employed by human calculators.
07:30:46 <Aetherspawn-> nyways, night
07:31:05 <chrisdone> I was made to learn by heart: "The square of the sum of two numbers is equal to the sum of their squares increased by twice their product." I had not the vaguest idea what this meant and when I could not remember the words, my tutor threw the book at my head, which did not stimulate my intellect in any way.
07:31:06 <chrisdone> — Bertrand Russell
07:31:56 <monochrom> it's why I prefer formulas
07:32:22 <dncr> monochrom: ah well it made me think of branch prediction and using math to avoid it. e.g.: http://stackoverflow.com/questions/11227809/why-is-processing-a-sorted-array-faster-than-an-unsorted-array/11227902#11227902
07:33:21 <dncr> rwbarton: thanks, :sprint is great
07:34:39 <chrisdone> dncr: do you use emacs?
07:34:50 <dncr> chrisdone: not usually
07:34:54 * chrisdone is sure his gravestone will read “and he used emacs”
07:35:09 <chrisdone> k. there's a lazy printer in haskell-mode
07:35:14 <dncr> nice
07:35:36 <chrisdone> https://www.youtube.com/watch?v=oJhIvHtflbI
07:36:59 <dncr> that's cool
07:38:23 <monochrom> Knuth uses emacs too. you're in good company :)
07:39:06 <pjdelport> chrisdone: "Here lies Chris Done. M-x save-buffers-kill-terminal" ?
07:39:34 <Saizan> chrisdone: cool, how does that work?
07:39:36 <chrisdone> pjdelport: =)
07:41:03 <monochrom> I think it's "intercept ghci output, parse, make guesses if necessary"
07:41:07 <chrisdone> Saizan: it uses Data.Data to inspect the type and returns a unique ID for each sub-slot to request expansion of it. implementation is here: http://hackage.haskell.org/package/present-1.1/docs/Present.html
07:41:27 <monochrom> oops, Data.Data is better than parsing and guessing :)
07:41:29 <chrisdone> then it outputs an s-expression of the Presentation type to Emacs, which just prints it
07:41:36 <chrisdone> monochrom: =)
07:41:55 <chrisdone> a little better. the only downfall is that many types aren't instances of Typeable or Data
07:43:02 <Saizan> chrisdone: we should add that to agda's error messages
07:44:40 <chrisdone> :3
07:48:23 <Ankhers> Is it possible with my data type to do something like Below == 0 to return True? http://lpaste.net/106291
07:49:15 <rwbarton> well... you shouldn't
07:49:38 <Ankhers> rwbarton: Can you explain?
07:49:41 <arw> Ankhers: that would make it necessary to create a weird kind of ==-operator.
07:50:00 <rwbarton> if you have Below == 0 then that means 0 :: Position, and that in turn means 27 :: Position and you can add two Positions and so on
07:50:15 <Ankhers> rwbarton: Makes sense.
07:51:50 <Ankhers> rwbarton, arw: Thanks
07:52:45 <frerich> Ankhers: What do you need it for? You could also derive 'Bounded' and then use 'Below == minBound :: Position'
07:55:25 <Ankhers> frerich: I'm receiving JSON, and this field is a [Int]. Each Int corresponds to a language. There are about a dozen languages that could potentially be there. I was just trying to come up with a way to prevent doing an explicit search for each language.
07:55:59 <wolfspaw> -- Newbie question:
07:55:59 <wolfspaw> Why (map round).(replicate 5)  1.5 -- does not work
07:55:59 <wolfspaw> while
07:55:59 <wolfspaw> let f = (map round).(replicate 5) -- f 1.5 works
07:56:17 <tomejaguar> Because of parentheses
07:56:52 <tomejaguar> You need some more (and you don't need the ones you have).
07:56:52 <rwbarton> "(map round).(replicate 5)  1.5" is "(map round) . ((replicate 5) 1.5)"
07:57:20 <monochrom> it's just a grammar issue
07:57:26 <frerich> ankhers: you can do that indeed if you also derive from 'Enum'
07:57:36 <wolfspaw> hmm, I see. thanks!
07:57:52 <frerich> ankhers: '[minBound..maxBound] :: [Position]' gives you a list of all the values, and you could just use '!! 0' with that.
07:58:01 <frerich> ankehrs: ...to get the right language for a given integer.
07:58:45 <rwbarton> or just use toEnum
07:59:19 <frerich> rwbarton: D'oh! :-)
07:59:56 <tomejaguar> or just minBound?
08:00:43 <Ankhers> frerich: I completely forgot that Enum was a type class in Haskell. I feel like an idiot. Thanks for pointing that out!
08:00:54 <rwbarton> in this context, I think "0" was a variable Int
08:01:39 <frerich> Right, it was just an example.
08:04:13 <frontendloader> wolfspaw: map round $ replicate 5 1.5
08:04:52 <rwbarton> (Also, why are you mapping over the result of replicate? why not replicate 5 (round 1.5))
08:05:01 <matheus23> What _exactly_ is the issue, if cabal-install tells me "cannot satisfy package-id" stuff?
08:05:30 <tdammers> matheus23: it means that you have dependencies that cannot be resolved
08:05:31 <frontendloader> rwbarton: why are we rounding a value that we already know what the result of is?
08:05:37 <frontendloader> why ask why ;)
08:05:56 <tdammers> matheus23: usually because two of your dependencies have incompatible requirements on another dependency
08:05:59 <matheus23> tdammers: so what would be an example case of dependencies that cannot be resolved? What's that exactly?
08:06:01 <frontendloader> could be learning how map works
08:06:09 <rwbarton> frontendloader: True enough
08:06:11 <tomejaguar> matheus23: Sometimes, rerunning `cabal configure` fixes it.
08:06:23 <tdammers> matheus23: or it could be because your dependencies specify versions that don't exist
08:06:26 <matheus23> tomejaguar: okay thanks for that tip
08:06:53 <rwbarton> if you want to know the exact issue, start by reading the entire error
08:06:55 <matheus23> (I have to test that out in a second)
08:08:27 <matheus23> But, but... simply "cabal install cairo" fails?!? So have they a wrong .cabal setup, so that they have conflicting package version dependencies?
08:09:23 <bergmark> matheus23: sometimes cabal prefers installed packages a bit too aggressively instead of suggesting to reinstall
08:10:02 <rwbarton> "cabal install cairo" just worked for me, fwiw. but I didn't use a sandbox
08:10:16 <matheus23> rwbarton: I don't do either.. should I?
08:10:48 <matheus23> Why do I have these issues with cabal, but not with something like pacman? Why does pacman work?
08:11:04 <rwbarton> maybe, my point is, just because it worked for me does not mean it will work for you, since we may have different packages installed currently
08:11:16 <klrr_> because pacman is a package manager, cabal-install is not
08:11:18 <geekosaur> mostpackage managers don't have to cope with ghc's annoying library handling
08:11:26 <rwbarton> but I don't feel like waiting half an hour to find out whether it installs into a clean sandbox
08:11:51 <bergmark> matheus23: i think the major issue is that you cannot have the same version of a package installed with different sets of dependencies
08:11:56 <geekosaur> and yes, pacman will generally update dpeendencies as necessary, cabal does not
08:12:14 <geekosaur> and mostly can't because it would usually lead to cabal having to reinstall all your packages
08:12:18 <geekosaur> because ghc
08:12:42 <rwbarton> I mean, cabal could just reinstall all your packages I guess
08:12:55 <rwbarton> it would take a lot longer than for pacman, since pacman is installing binary packages
08:12:59 <geekosaur> eventuallyy I suspect it will have to
08:13:35 <matheus23> hmmm... So is there a package manager for haskell? And an alternative to ghc's library handling?
08:13:44 * hackagebot monad-journal 0.2.1.2 - Pure logger typeclass and monad transformer  http://hackage.haskell.org/package/monad-journal-0.2.1.2 (DimitriSabadie)
08:13:44 <bergmark> sandboxes try to solve this by only using one version of all packages
08:13:46 * hackagebot json-schema 0.6 - Types and type classes for defining JSON schemas.  http://hackage.haskell.org/package/json-schema-0.6 (AdamBergmark)
08:14:02 <bergmark> in practice this doesn't always work either though since you may need multiple versions
08:14:22 <rwbarton> I recommend following these instructions http://www.vex.net/~trebla/haskell/cabal-cabal.xhtml#lockdown
08:14:45 <rwbarton> which seem to eliminate most of the problems in practice
08:14:50 <rwbarton> and then just wipe out .ghc every so often
08:14:55 <rwbarton> it's not really a big deal
08:16:35 <matheus23> rwbarton: apart from feeling like a dirty solution :( I don't actually know which constraints to set?
08:17:08 <rwbarton> for every package which came with ghc, add a constraint
08:17:15 <rwbarton> you can see them with ghc-pkg list, the top part
08:17:48 <bergmark> i think you can also just have `constraint: haskell-platform installed' if you are using HP
08:18:25 <rwbarton> really, I would like to be able to just say "never install more than one version of a package, ever"
08:19:57 <matheus23> bergmark: what's haskell-platform and what is HP?
08:20:02 <bergmark> hp = haskell platform
08:20:49 <levi> HP is a company that sells printer ink, and a couple other things. :P
08:21:03 <latermuse> hey guys, is it possible to make a haskell program like this run on multiple cores and get better performance? http://lpaste.net/106292
08:21:23 <bergmark> it's a distribution of ghc, cabal, and some commonly used packages and binaries
08:21:37 <latermuse> im passing a file that is 100 million lines to that program and it is taking too long to finish
08:21:52 <latermuse> using 100% of one of the cores on my machine. but I have multiple cores
08:21:59 <latermuse> would using multiple cores speed things up?
08:22:23 <pjdelport> latermuse: That problem should probably be I/O bound, rather than CPU bound.
08:22:57 <pjdelport> Oh, wait, Set.
08:23:00 <bergmark> latermuse: what is the bottle neck of your program?
08:23:11 <matheus23> levi: :P
08:23:11 <pjdelport> Yeah, multiple cores would probably make that faster.
08:23:18 <latermuse> Im not sure. I dont see a bottleneck.
08:23:33 <bergmark> latermuse: then you might want to profile and figure that out
08:23:38 <latermuse> It looks pretty straightforward and basic to me
08:24:17 <dfsdf> anyone familiar with safecopy?
08:24:28 <pjdelport> latermuse: The bottleneck may be string comparison. Repeated comparisons with strings is not very efficient in general, especially if they share prefixes.
08:24:48 <latermuse> any idea how to fix that?
08:25:14 <rwbarton> how about replacing your program with 'LANG=C sort | uniq | wc -l'
08:25:37 <latermuse> and is there an easy way to make this run on multiple cores? or do I need to rewrite the algorithm to use mvars?
08:25:43 <pjdelport> latermuse: Try using Data.HashSet first, and see how much difference it makes?
08:25:45 <rwbarton> sort --parallel=N
08:26:19 <pjdelport> latermuse: No, you shouldn't use mvars; you could simply split up the list, set-ify them separately, and then union the sets.
08:26:37 <pjdelport> latermuse: Control.Parallel has combinators to help writing that kind of thing.
08:26:43 <latermuse> I see
08:27:27 <pjdelport> But first try hashing. Balanced trees with string elements generaly does not work well, because comparisons are generally O(string length) instead of constant.
08:27:53 <monochrom> wait, and computing a hash value is not O(string length)?
08:27:54 <latermuse> ok ill try hashing now
08:28:20 <latermuse> if hashing doesnt work, then im going to try that LANG=C example. if that fails, then ill rewrite using control.parallel
08:28:27 <rwbarton> monochrom, it is but you only have to do it once, and then you can traverse the whole tree
08:28:28 <pjdelport> monochrom: You only do it once, not repeatedly.
08:28:46 * hackagebot HFuse 0.2.4.2 - HFuse is a binding for the Linux FUSE library.  http://hackage.haskell.org/package/HFuse-0.2.4.2 (M15K)
08:29:25 <rwbarton> the trickiest part will probably be splitting up the input
08:29:35 <latermuse> the input is 100 million lines
08:30:01 <latermuse> im trying to calculate the uniques that are coming to my website every hour based on page impressions
08:30:27 <pjdelport> latermuse: Have you profiled Haskell before, by the way? Might want to get that in place before you seriously experiment.
08:30:40 <latermuse> yes I have
08:30:46 <pjdelport> Cool.
08:31:13 <rwbarton> you might also consider Bloom filters/hyperloglog if you don't need exact counts
08:31:23 <pjdelport> latermuse: Can you profile your existing code to confirm whether string comparison is the culprit?
08:31:28 <vanila> can haskell really process 100 million lines?
08:31:39 <pjdelport> vanila: Of course.
08:32:04 <vanila> that would be really impressive
08:32:35 <latermuse> pjdelport: okay, give me a few minutes to set that up. ill run it on 10 million lines and see what the profiler says. it might take me 20 minutes to finish running the script on my server
08:32:48 <latermuse> it took 7 minutes for 10 million lines without profiling
08:33:12 <latermuse> I want to get the runtime for 100 million lines to under an hour
08:33:20 <latermuse> so that I can calculate the uniques every hour
08:34:00 <pjdelport> latermuse: Dang, that's long. How big is the file in bytes? And how long does "sort | uniq | wc -l" take?
08:34:54 <rwbarton> oh, GNU sort has a built-in uniq also, sort -u
08:34:55 <latermuse> sort | uniq | wc -l doesnt even work
08:35:04 <rwbarton> doesn't work how?
08:35:13 <latermuse> spits out an error message
08:35:35 <rwbarton> ...
08:35:50 <latermuse> around 4 gigs for 100million lines
08:35:57 <latermuse> one sec, im looking for that error message
08:36:12 <latermuse> here is the error message:
08:36:12 <latermuse> sort: write failed: /tmp/sort1mpdkB: No space left on device
08:36:20 <rwbarton> nice
08:36:21 <levi> Heh.
08:36:42 <rwbarton> yeah, it does out-of-core sorting for large files
08:37:03 <rwbarton> under the assumption that disk is larger than memory...
08:37:23 <latermuse> im worried my memory is not large enough to process 100 million lines
08:37:31 <latermuse> it used 20% of available memory to process 10 million lines
08:37:53 <latermuse> server has 8 gigs ram and 10 gigs swap
08:38:12 <levi> You may need to change your algorithmic approach if your problem is too big to be tackled all at once.
08:38:32 <latermuse> yes
08:38:38 <rwbarton> sort -T dir will let you specify a different directory for temp files
08:38:47 <rwbarton> maybe somewhere you have more than 4 G of space free...
08:38:47 * hackagebot semigroups 0.15.1 - Anything that associates  http://hackage.haskell.org/package/semigroups-0.15.1 (EdwardKmett)
08:38:49 * hackagebot quickcheck-webdriver 0.1.0.0 - Utilities for using WebDriver with QuickCheck  http://hackage.haskell.org/package/quickcheck-webdriver-0.1.0.0 (christianpbrink)
08:39:05 <latermuse> rwbarton: woah great. i didnt even notice that flag
08:39:23 <latermuse> ill try that now real quick and see if it does better than haskell for 10 million lines
08:39:29 <ReinH> you might try mmaping
08:39:59 <latermuse> 500 gig ssd should do the trick :)
08:40:30 <pjdelport> Eek, okay. Yeah, at 4GB, that's definitely I/O and memory-bound.
08:40:52 <pjdelport> latermuse: Algorithm first: what's the exact nature of the data lines, and what are you interested in?
08:40:58 <pjdelport> Can you paste a sample?
08:41:09 <latermuse> its just IP addresses
08:41:14 <rwbarton> (I wonder if your /tmp is a size-limited RAM filesystem, how ironic that would be)
08:41:28 <latermuse> time cat tmpdat.txt | sort -T /storage/ | uniq | wc -l | awk {'print $1'}
08:41:30 <latermuse> this kicked ass
08:41:31 <latermuse> 13 seconds
08:41:50 <latermuse> haskell -> 7 minutes
08:42:12 <latermuse> my /tmp was a ramdisk. /storage is ssd
08:42:17 <vanila> why isn't haskell performing the same in this situation?
08:42:27 <latermuse> vanila: not sure. would need to profile to figure that out.
08:42:29 <ReinH> why would you expect it to?
08:42:55 <pjdelport> latermuse: Literally just IP addresses? For 4GB, that translates to 40 bytes per line, which sounds like more.
08:43:07 <latermuse> IP addresses and some reverse lookup stuff
08:43:18 <rwbarton> maybe they are IPv6 addresses ~~
08:43:18 <ReinH> so figuratively literally
08:43:19 <latermuse> reverse hosts
08:43:23 <pjdelport> vanila: Data.Set does a lot more work than sort.
08:43:33 <vanila> ah
08:43:51 <latermuse> im just going to use the gnu utils instead of haskell for this
08:45:51 <latermuse> haskell would probably perform way better if i spent a few hours profiling it and getting a proper algorithm sorted
08:46:11 <latermuse> but those gnu utils are just so easy to use, so im not going to bother with haskell on this project. thanks for the help guys!
08:47:57 <pjdelport> latermuse: Cool. If you're going that route, try: <data.txt awk {'print $1'} | sort -u -T /storage/ | wc -l
08:48:48 * hackagebot quickcheck-webdriver 0.1.0.1 - Utilities for using WebDriver with QuickCheck  http://hackage.haskell.org/package/quickcheck-webdriver-0.1.0.1 (christianpbrink)
08:50:09 <latermuse> pjdelport: thanks, ill try that out also
08:50:12 <latermuse> ls
08:50:14 <latermuse> oops
08:50:16 <latermuse> haha ;)
08:56:24 <pjdelport> latermuse: Oh, just for future reference, if you want to solve a similar problem, you'll probably want ByteStrings instead of Text, if you don't need UTF-8 decoding.
08:56:55 <latermuse> ah yes, thats a good idea
08:57:05 <latermuse> would lazy bytestring be preferable over strict bytestring?
08:57:56 <pjdelport> latermuse: Lazy for the reading, definitely.
08:58:26 <pjdelport> Though individual addresses could be made strict.
08:58:41 <latermuse> how do you mean?
08:59:40 <pjdelport> latermuse: If you were to write some real analytics in Haskell for this, you'd probably want to parse the IP addresses into integers, actually, and then use those as identifiers for further analysis.
08:59:49 <pjdelport> (or to an actual IP address type)
08:59:49 <rwbarton> you could also parse the IPv4 addresses (if that's what they are), there are only 2^32 of them, and use a bitmap, that's just 512 MB
09:00:14 <pjdelport> For integers, Data.Set would be just fine.
09:00:31 <latermuse> not IPv4 addresses
09:00:35 <latermuse> they are mostly reverse host lookups
09:00:56 <pjdelport> Ah, okay. ByteStrings then. :)
09:01:26 <latermuse> most lines look like this:   softbank***[redacted]****.bbtec.net
09:03:53 <phaazon> http://lpaste.net/106294
09:03:54 <phaazon> :(
09:03:54 <Gu_______> What's the deal with IPv6
09:04:29 <Gu_______> When will that be mainstream?
09:04:34 <Gu_______> I want some more hex in my Ips
09:05:16 <arw> Gu_______: some said it would be mainstream as soon as you can google stuff via IPv6. that works since around 3 years ago
09:05:53 <latermuse> ipv6 is a big pain, hopefully we can keep it non-mainstream for as long as possible
09:05:57 <Gu_______> why?
09:06:49 <arw> depends. dhcpv6 is broken and unusable which makes deployment a pain. stateless autoconfiguration kind of works, but is not an option in many places.
09:06:53 <latermuse> syn flood attacks from ipv6
09:07:22 <arw> and end users usually lack ipv6 connectivity because of shitty providers
09:07:24 <phaazon> https://ghc.haskell.org/trac/ghc/ticket/7824
09:07:27 <phaazon> it should be fixed
09:07:35 <phaazon> why isn’t fixed on my arm dammit
09:08:07 <rwbarton> can you paste the output of ghc --info
09:08:39 <phaazon> rwbarton: http://lpaste.net/106295
09:08:47 <phaazon> I guess the ghc package on raspbian is a bit old
09:08:49 <kazagistar> latermuse: why is syn flood attacks a bigger problem for ipv6?
09:09:08 <latermuse> easier to get a bunch of IP
09:09:24 <rwbarton> phaazon: oh yes it's too old
09:09:33 <latermuse> my site was attacked by syn flood non-stop for a month. i ended up blocking entire countries and dash 8s to stop the attack
09:09:48 <phaazon> rwbarton: I changed the pinning of the raspbian
09:09:54 <phaazon> in order to match my desktop (testing)
09:10:02 <phaazon> but I’m not sure it’s possible on ARM
09:10:13 <rwbarton> yeah but 7.4 supported x86 better than ARM
09:10:28 <rwbarton> at least I think that is the issue
09:10:50 <rwbarton> you can try building 7.8 from source
09:10:54 <rwbarton> using 7.4 to bootstrap
09:11:32 <deni> omg this seems like a terrible type to have: res :: IO (Either String (IO BS.ByteString))
09:11:35 <rwbarton> not sure if 7.6 is good enough
09:13:16 <rwbarton> phaazon: actually, I'm mostly sure 7.6 isn't new enough
09:13:28 <deni> are there any good resources out there for dealing with IO in haskell? but in mean in an architecture sense more....not syntax and basic idioms
09:14:08 <phaazon> rwbarton: what’s the newest?
09:14:19 <phaazon> mine is up to date according to the debian testing repo
09:14:23 <phaazon> 7.6.3
09:14:29 <rwbarton> 7.8.2 is the most recent release
09:14:47 <phaazon> ok
09:15:02 <rwbarton> 7.8 introduced using the system dynamic loader in ghci, as opposed to ghci's custom one (which was never implemented for arm)
09:15:06 <rwbarton> hence no ghci on arm
09:15:34 <phaazon> that’s odd
09:15:38 <phaazon> it’s been one year
09:15:41 <phaazon> it should be in testing repo
09:16:06 <rwbarton> 7.8 is just a couple months old
09:16:08 <c_wraith> deni: lots of articles on http://www.haskellforall.com/ address that issue.  That's tekmo's site, by the way, and he's often in here - but not right now.
09:16:38 <phaazon> rwbarton: april
09:16:39 <phaazon> yeah
09:16:47 <phaazon> I was talking about 7.6
09:16:54 <phaazon> http://www.haskell.org/ghc/
09:16:59 <c_wraith> phaazon: in general, debian handles ghc very badly.
09:17:16 <rwbarton> ah
09:17:28 <ninja_code> I'm looking for "String -> [Int]", where I give it a string, which is a list of space-separate integers. I get back http://www.haskell.org/hoogle/?hoogle=String+-%3E+%5BInt%5D ... is there no builtin for what I wnat?
09:17:32 <phaazon> c_wraith: why is so?
09:17:33 <tomejaguar> Never had any problems with GHC on Debian
09:17:36 <ninja_code> i.e. I want "1 2 3 4 5" -> [1 2 3 4 5]
09:17:36 <c_wraith> phaazon: its ghc setup is acceptable for installing things that require GHC to build, but it's very bad for development.
09:17:38 <phaazon> who’s the maintainer?
09:17:49 <vanila> > map read . words $ "1 2 3 4 5" :: [Int]
09:17:50 <lambdabot>  [1,2,3,4,5]
09:17:58 <phaazon> c_wraith: I just install ghc, ghc-doc and ghc-prof + cabal-install
09:18:02 <phaazon> and I do the rest in cabal
09:18:46 <c_wraith> phaazon: the way debian manages ghc packages is guaranteed to cause terrible problems when combined with cabal-install.  And as you've just noted, it lags behind by several months.
09:19:09 <phaazon> c_wraith: how is it on archlinux?
09:19:16 <phaazon> I was used to archlinux for a while
09:19:27 <phaazon> I don’t even remember using ghc on arch
09:19:56 <Clint> c_wraith: it's not guaranteed
09:20:01 <ninja_code> vanila: nice, thanks!
09:21:52 <deni> c_wraith: checking it out....I'm getting the sense that there's soooo much stuff I need to read before writing any code at all and that's not just how my brain works...I need to write and learn, but then i get stuck and it's back to the drawing board...
09:22:02 <deni> so much stuff is over my head at the moment
09:22:08 <rwbarton> in general it's the same as anything else on debian, if you're happy with the (probably old) versions in the distribution, you can just use the distribution, if you want something else, do it from scratch yourself
09:23:09 <c_wraith> deni: then write and learn.  The thing haskell is best at is making sweeping rewrites of your code easy when you decide to try it another way.
09:23:43 <c_wraith> deni: maybe skim those article, just to see what problems they're trying to solve.  When you run into those problems yourself, go back and read the articles in more detail.
09:23:55 <phaazon> oh
09:24:01 <phaazon> 7.8 is in experimental
09:24:03 <phaazon> not in testing
09:24:18 <Clint> phaazon: a ghc person advised that 7.8 isn't ready yet
09:24:49 <phaazon> ready to what?
09:24:55 <phaazon> it has bugs?
09:25:05 <glosoli> Anyone knows some article that would introduce Reactive Programming practises using Haskell ?
09:25:09 <c_wraith> There are a few small issues that another bugfix release is planned for
09:25:14 <phaazon> glosoli: yeah
09:25:15 <deni> c_wraith: yeah i'm looking through the archives now and finding what's interesting to me atm. he's the author of the pipes lib right? haven't used it so far, but the names pops out a lot
09:25:20 <phaazon> glosoli: seek for reactive-banan, on hackage
09:25:20 <ninja_code> I have one more idiomatic question. How do I go from [1, 2, 3, 4, 5, 6] to [(1, 2), (3, 4), (5, 6)]
09:25:22 <c_wraith> deni: correct
09:25:46 <glosoli> phaazon: Thanks Sir
09:26:17 <phaazon> reactive-banana*
09:26:26 <kazagistar> ninja_code: what if the list has an odd number of items?
09:26:26 <deni> I'm totally sold on haskell but every now and then I need to bitch about how I don't get anything at all (mostly happens when i get stuck on something). I gotta say though, the community is really helpfull...and that goes a long way
09:26:40 <ninja_code> kazagistar: guaranteed to be even
09:27:10 <c_wraith> deni: there's a lot of stuff in Haskell-land that operates at levels of abstraction that just aren't present in other language.  It takes time to get used to it.  I'm used to it, but I still don't understand all of it. :)
09:28:03 <kazagistar> ninja_code: I would just pattern matching + recursion it, but I dunno if that is particularly idiomatic or whatever
09:28:16 <deni> c_wraith: yeah i noticed there's a lot of totally different stuff. right now i'm trying to at least learn to use a lot of stuff..and try and understand what's underneath at a later time
09:28:20 <deni> lenses come to mind :D
09:28:46 <c_wraith> deni: lenses are on the list of things that I basically accept on a conceptual level, and can even generally use, but am far from understanding deeply. :)
09:29:18 <deni> c_wraith: I have an open tab with kmett doing a presentation on the subject..haven't gotten around to watching the whole thing yet. :D
09:30:08 <Para__> is there a builtin function in the Prelude or something that returns every other element from a list? I wrote a function using recursion to do that, but I'm not sure if there is a more idiomatic/already implemented function that does the same thing
09:30:22 <kazagistar> ninja_code: pairUp [] = []; pairUp (x:y:ls) = (x,y) : pairUp ls
09:30:22 <c_wraith> deni: if osmosis is a learning style that you can manage, the #haskell-lens channel isn't overly active, but it's handy for seeing occasional discussions about everything from theory to implementation to use.
09:31:57 <enthropy> > chunksOf 2 [1 .. 6]
09:31:58 <lambdabot>  [[1,2],[3,4],[5,6]]
09:32:19 <c_wraith> :t chunksOf
09:32:20 <lambdabot> Int -> [e] -> [[e]]
09:32:26 <deni> c_wraith: tnx
09:32:26 <tar_> I have a map over a pure function that I want to calculate in parallel. What's the simplest way to make that happen?
09:32:43 <enthropy> @hackage split -- is where it's from
09:32:43 <lambdabot> http://hackage.haskell.org/package/split -- is where it's from
09:32:45 <c_wraith> @hoogle parMap
09:32:45 <latermuse> > map (head) . chunksOf 2 $ [1..6]
09:32:46 <lambdabot> Control.Parallel.Strategies parMap :: Strategy b -> (a -> b) -> [a] -> [b]
09:32:47 <lambdabot>  [1,3,5]
09:32:53 <tar_> c_wraith: thanks!
09:33:08 <c_wraith> tar_: The Strategy stuff in that takes a bit of work to get right, though
09:33:13 <tar_> oh
09:33:22 <latermuse> Para__: This should work -> map . head . chunksOf 2 $ [1..10]
09:33:28 <c_wraith> tar_: I mean, it's usually easy, you just need to understand what you're doing. :)
09:33:29 <ninja_code> kazagistar: nice, thanks!
09:33:51 * hackagebot rethinkdb-wereHamster 1.8.0.5 - RethinkDB driver for Haskell  http://hackage.haskell.org/package/rethinkdb-wereHamster-1.8.0.5 (wereHamster)
09:33:56 <kazagistar> ninja_code: you could also use chunksOf as they are saying above
09:33:58 <Para__> oh hm
09:33:59 <Para__> ok
09:34:00 <latermuse> map head . chunksOf 2 $ [1..10]
09:34:02 <latermuse> sorry mistake
09:34:03 <Para__> its not builtin though
09:34:17 <gilligan_> hm.. trying to understand parts of the hoogle sources - but I can't figure out what the &= operator is ?
09:34:19 <Para__> as in, its not a signle function
09:34:24 <Para__> single/commonly used function
09:34:38 <latermuse> you can make it a single function easily
09:34:49 <tar_> c_wraith: I'll have to look for an example! I feel like this is a pretty basic case.
09:34:52 <latermuse> its not included in prelude
09:35:00 <rwbarton> could also write it with filter and zip and cycle
09:35:02 <c_wraith> tar_: the strategy you want for parMap is usually either rseq or rdeepseq
09:35:10 <kazagistar> ninja_code: pairUp = map (\[x,y]->(x,y)) . chunksOf 2
09:35:21 <c_wraith> tar_: both of which are in the Control.Parallel.Strategies module
09:35:29 <rwbarton> it = Para__'s function, a bit of a mess though
09:35:35 <kazagistar> > map (\[x,y]->(x,y)) . chunksOf 2 $ [1..6]
09:35:36 <lambdabot>  [(1,2),(3,4),(5,6)]
09:35:37 <ninja_code> kazagistar: noted, thanks!
09:35:56 <zwer> kazagistar your function is not total (it does not handle [x])
09:36:11 <Para__> oh okay
09:36:15 <kazagistar> zwer: ninja_code said it was guarenteed to be even
09:36:31 <Para__> I mean this is what I have so far:
09:36:32 <Para__> every_other_element :: [a] -> [a] every_other_element [] = [] every_other_element (a:_:as) = a:every_other_element as
09:36:59 <Para__> oh
09:37:04 <Para__> I should include a case with just one element in the list
09:37:22 <c_wraith> tar_: basically, a Strategy tells the parallel stuff how to evaluate a data structure in parallel.  parMap starts with "evaluate every element in parallel", but it doesn't know how to evaluate each element.  That's what the strategy you pass to it is for.
09:38:19 <tar_> c_wraith: hmm, evaluate as in evaluate thunks?
09:38:24 <c_wraith> tar_: usually, you'd want to fully evaluate every element in a parMap.  If the elements are not a recursive type, rseq is an appropriate strategy.  If they are a recursive type, like lists (including String), you probably want rdeepseq instead.
09:38:29 <rwbarton> probably the nicest version of the zip approach is every_other_element xs = [ x | (p,x) <- zip (cycle [True,False]) xs, p ]
09:39:11 <kazagistar> I like that one
09:39:39 <c_wraith> tar_: well, yes.  It's about laziness.  If all parMap did was apply the function to every element in parallel, it wouldn't help much.
09:40:11 <c_wraith> tar_: Because all that applying a function does is create a thunk.  Creating thunks in parallel isn't a win.
09:40:23 <tar_> c_wraith: oh!!
09:40:33 <c_wraith> tar_: you need to actually evaluate those thunks in parallel to get any speedup.
09:40:59 <c_wraith> tar_: and that's what the Strategy is about:  it's instructions for how to evaluate the thunks.
09:51:04 <ninja_code> hmm
09:51:30 <ninja_code> is there anyway to tell haskell to parse somethign like "[(1, 2), (3, 4), (5, 6)]" into [(Int, Int)] ?
09:51:57 <chrisdone> read should parse that
09:52:00 <c_wraith> > read "[(1, 2), (3, 4), (5, 6)]" :: [(Int, Int)]
09:52:01 <lambdabot>  [(1,2),(3,4),(5,6)]
09:52:13 <chrisdone> but it depends on your use-case
09:52:24 <c_wraith> yeah, if you don't mind read's fragility, it works fine
09:52:28 <chrisdone> if speed and safety are concerns, other parsers will be better
09:52:42 <ninja_code> hmm
09:52:43 <ninja_code> I'm using haste.
09:52:47 <ninja_code> Haste compiles haskell to js.
09:52:59 <ninja_code> I need to pass complicated data structure rom js back to ahskell
09:53:00 <ninja_code> I'm using strings.
09:53:41 <chrisdone> better to do that with json or something
09:53:51 <chrisdone> can haste compile aeson?
09:54:12 <chrisdone> or does it have some automated way to do json serialization?
09:54:21 <rwbarton> for this specific case, read should be fine, but, yeah
09:54:32 <rwbarton> as long as the data structure isn't large
09:54:50 <ninja_code> it's non-trivial in size but < 1 MB
09:55:07 <tar_> c_wraith: thank you, it's working well. :)
09:55:34 <luite> chrisdone: i don't think it can unmodified, since vector is a dependency and that requires template haskell
09:55:44 <rwbarton> hmm, well that sounds sort of large
09:56:58 <luite> ghcjs has some JSRef <-> aeson Value conversion functions, but i'd like to build somthing that can avoid the intermediate Value step
10:19:48 <hexagoxel> where is class ArrowInit defined?
10:21:39 <jamiehannaford> is anyone familiar with http://hackage.haskell.org/package/MonadRandom-0.1.13/docs/Control-Monad-Random.html?
10:30:46 <Ankhers> Can anyone explain why I am getting this error? http://lpaste.net/106302
10:31:06 <jamiehannaford> if I have a list of monads, is there a way to sort them? basically want to apply `sort` to the internal value of each monad
10:32:19 <nomeata> jamiehannaford: “internal value of each monad” doesn'T quite work
10:32:22 <Iceland_jack> jamiehannaford: there is no 'internal value'
10:32:32 <nomeata> jamiehannaford: but "fmap sort . sequence" might do what you want
10:32:33 <Iceland_jack> but you can make sortM
10:32:40 <nomeata> @type fmap sort . sequence
10:32:41 <lambdabot> (Ord a, Functor f, Monad f) => [f a] -> f [a]
10:32:48 <jamiehannaford> monads are just functors, right? so you can apply a function to them
10:33:11 <Ankhers> Nevermind. I think it was an issue with Emacs...
10:33:20 <Iceland_jack> you need more than Functor for that
10:33:25 <Sloane21>  Here some videos. I hope you like them! http://j.mp/1lpMrG8
10:33:46 <bergmark> Ankhers:
10:33:47 <bergmark> :t \x -> Object (HashMap.fromList [("foo", x)])
10:33:48 <bergmark> \x -> Object (HashMap.fromList [("foo", x)]) :: Value -> Value
10:33:48 <lambdabot> Not in scope: data constructor ‘Object’
10:33:48 <lambdabot> Not in scope: ‘HashMap.fromList’
10:35:28 <bergmark> Ankhers: since you used a numeric literal it tries to find a Num instance for Value, which doesn't exist
10:37:59 <jamiehannaford> nomeata thanks - but I wanted to return a list of sorted Monads, not a Monad containing a sorted list
10:38:27 <nomeata> jamiehannaford: how do you sort monads? Do you have a specific monad at hand?
10:41:01 <nexx> I think jamiehannaford is talking about monad values
10:43:42 <jamiehannaford> sorry, got disconnected
10:43:47 <jamiehannaford> I meant a function that would turn [Just 1, Just 10, Just 3] into [Just 10, Just 3, Just 1]
10:44:11 <joelteon> what happens when there's a Nothing
10:44:12 <chrisdone> sort?
10:44:32 <chrisdone> > sort [Just (),Nothing,Just ()]
10:44:33 <lambdabot>  [Nothing,Just (),Just ()]
10:45:02 <chrisdone> :t sortBy (flip (comparing id))
10:45:03 <joelteon> jamiehannaford: use sort
10:45:03 <lambdabot> Ord a => [a] -> [a]
10:45:15 <joelteon> jamiehannaford: how do you sort [IO a]?
10:45:35 <chrisdone> > sortBy (flip (comparing id)) [Just 1,Just 10,Just 3,Nothing]
10:45:36 <lambdabot>  [Just 10,Just 3,Just 1,Nothing]
10:45:51 <pavonia> flip comparing id == flip compare, no?
10:46:38 <DanielDiaz> > sortBy (flip compare) [Just 1,Just 10,Just 3,Nothing]
10:46:39 <lambdabot>  [Just 10,Just 3,Just 1,Nothing]
10:46:40 <jamiehannaford> the `Just x` was an example. the real monad I'm dealing with is from Control.Monad.Random. see here: http://lpaste.net/523987693739180032
10:46:58 <DanielDiaz> pavonia: that was exactly what I was thinking of
10:47:08 <jamiehannaford> so if I do `replicate 3 die`, I get a list of `Rand StdGen DieValue` types back
10:47:11 <jamiehannaford> I want to sort that list
10:47:40 <Cale> jamiehannaford: In what way? The three elements of the list are equal, and not of a type which is ordered.
10:47:41 <joelteon>  why
10:47:55 <Cale> replicate n x is a list whose elements are all the same
10:48:06 <Cale> Probably what you want to do is to run those three actions and sort the list of results
10:48:11 <rwbarton> think about what a value of type Rand StdGen DieValue actually is
10:48:25 <chrisdone> pavonia: yeah, but all compares become comparing ime so i tend to write that first
10:48:27 <jamiehannaford> yes, each monad computes a random value (in this case an Integer)
10:48:39 <Cale> There's only one monad, it's Rand StdGen
10:48:52 <jamiehannaford> so the monad represents the possibility of a random output?
10:48:52 <Cale> There are three actions (which are really all the same action)
10:48:57 <chrisdone> <Cale> There's only one monad
10:49:02 <chrisdone> out of context quotes are awesome
10:49:05 <Cale> heh
10:49:27 <Cale> jamiehannaford: A monad refers to a type constructor
10:49:33 <Cale> Maybe is a monad, Just 4 is not
10:49:42 <pavonia> @quote mother.*monads
10:49:42 <lambdabot> No quotes match. Maybe if you used more than just two fingers...
10:49:54 <Cale> jamiehannaford: IO is a monad, getLine is not
10:50:24 * rwbarton imagines a Samuel L Jackson quote
10:50:30 <Cale> jamiehannaford: Typically the values of some type which is constructed with a monad M are called M-actions
10:50:39 <Cale> e.g. getLine is an IO action
10:50:42 <jamiehannaford> yes, and in this context? The Rand StdGen represents a type that has the ability to compute rand numbers
10:50:56 <Cale> and die is a Rand StdGen action
10:51:19 <Cale> jamiehannaford: Anyway, what you're probably looking for is  fmap sort (replicateM 3 die)
10:51:34 <Cale> replicateM n x = sequence (replicate n x)
10:51:34 <chrisdone> “which wallet's yours?” “it's the one that says Comonad Functor on it!”
10:51:57 <Cale> sequence :: (Monad m) => [m a] -> m [a]
10:52:21 <Cale> takes a list of actions, and sews them together into an action which runs them each in turn, constructing a list of the results
10:52:51 <jamiehannaford> ah okay, and then you simply fmap sort over it
10:52:51 <Cale> sequence [] = return [] -- in the case that the list is empty, we produce the action which does nothing except to result in the empty list.
10:53:18 <Cale> sequence (x:xs) = do v <- x; ... -- in the case that the list is nonempty, we first run the first action in the list, and then ...
10:53:37 <Cale> sequence (x:xs) = do v <- x; vs <- sequence xs; ... -- run the rest of the elements of the list, getting a list of the results
10:54:02 <Cale> sequence (x:xs) = do v <- x; vs <- sequence xs; return (v:vs) -- and put the first result and list of remaining results together into a complete list
10:54:07 <mietek> Are there any good examples of using Haskell QuickCheck for testing side-effectful code?
10:54:19 <merijn> morallyDubiousIOProperty?
10:54:25 <merijn> Or did that get dropped?
10:55:03 <Iceland_jack> mietek: Funny you should ask
10:55:14 <mietek> merijn: nice name, but I'm thinking more about tactics
10:55:18 <Iceland_jack> I just added a pull request for documenting monadic actions
10:55:23 <Iceland_jack> Test.QuickCheck.Monadic
10:55:28 <mietek> Iceland_jack: huh!
10:55:41 <Iceland_jack> The woefully underdocumented module that nobody seems to know about
10:55:52 <Iceland_jack> mietek: https://github.com/nick8325/quickcheck/pull/17/files
10:56:03 <mietek> Thanks, that's very nice
10:56:17 <Iceland_jack> It's not nicely formatted but you should be able to make out some of the examples
10:56:33 <mietek> Oh, and I see there's a paper referenced
10:56:56 <Iceland_jack> Yes, it's pretty old though and some of the examples have a lot of baggage
10:57:01 <Iceland_jack> mostly involving the ST monad
10:57:13 <Iceland_jack> if you just want to test some simple IO stuff, refer to the docs
10:57:45 <Iceland_jack>     prop_test ... = monadicIO $ do
10:57:45 <Iceland_jack>         a <- run ioAction
10:57:45 <Iceland_jack> 	assert (a = "something")
10:57:54 <Iceland_jack> with correct indentation of the final line
10:58:17 <ReinH> Iceland_jack: I think "Will generate follow this form" is a typo
10:58:56 <Iceland_jack> Yes you're right, and so early on in the documentation
10:59:01 <ReinH> :)
10:59:08 <ccapndave2> Is there something built in to unpack [Maybe a] such that I end up with [a]?  I want Maybes to be unboxes, and Nothings to be discarded
10:59:16 <ccapndave2> unboxed
10:59:19 <rwbarton> @hoogle [Maybe a] -> [a]
10:59:21 <lambdabot> Data.Maybe catMaybes :: [Maybe a] -> [a]
10:59:21 <lambdabot> Data.Maybe maybeToList :: Maybe a -> [a]
10:59:21 <lambdabot> Prelude sequence :: Monad m => [m a] -> m [a]
11:00:00 <ccapndave2> Thanks
11:00:07 <ccapndave2> I keep forgetting about Hoogle (blush)
11:00:22 <Iceland_jack> ReinH: fixed, cheers
11:00:54 <Iceland_jack> QC.Monadic has saved my butt several times, it deserves more recognition :)
11:01:12 <ccapndave2> catMaybes is the puppy
11:02:17 <chrisdone> is there a sequence for two monads?
11:02:30 <chrisdone> maybe in Traversable
11:02:46 <chrisdone> sequenceA
11:03:08 <chrisdone> ah, not quite
11:04:26 <chrisdone> sequenceP :: (MonadPlus m,MonadPlus f) => [m a] -> f [a]
11:04:29 <chrisdone> something like that
11:04:40 <marteo_> o/ folks
11:04:55 <chrisdone> @djinn (MonadPlus m,MonadPlus f) => [m a] -> f [a]
11:04:56 <lambdabot> Error: Undefined type []
11:05:00 <chrisdone> d'aw
11:06:10 <chrisdone> actually (MonadPlus m) => [m a] -> [a] should be sufficient
11:06:15 <chrisdone> :t foldr mplus mzero
11:06:16 <lambdabot> MonadPlus m => [m a] -> m a
11:06:18 <chrisdone> \o/
11:06:30 <chrisdone> ah, not quite, either
11:07:45 <marteo_> I have a question I don't know how to categorize
11:08:00 <marteo_> I define a bunch of constants of type {name :: String, nums :: [Int]}
11:08:34 <marteo_> and the rest of the code only needs to get all constants that have a particular Int x in their nums
11:08:58 * hackagebot mangopay 1.6.3 - Bindings to the MangoPay API  http://hackage.haskell.org/package/mangopay-1.6.3 (FelipeLessa)
11:09:20 <marteo_> is there a canonical way to compute the relevant Map only once, at compile-time ?
11:09:36 <chrisdone> mymap = M.fromList […]
11:09:58 <chrisdone> won't happen at compile-time, but will happen once
11:10:11 <jamiehannaford> Cale if I have `Rand StdGen Bool`, is there any way to use that to return a Bool ?
11:10:12 <chrisdone> if you want compile-time then template-haskell will be handy
11:10:12 <marteo_> once every execution of the program
11:10:20 <marteo_> that's interesting
11:10:46 <chrisdone> then what i wrote will eval once and no more. you can add a {-# NOINLINE #-} pragma next to it to be sure it's not inlined too
11:10:47 <joshc> jamiehannaford: only if you "run" the action; see runRand; you'll have to provide a seed
11:11:04 <pjdelport> marteo_: Probably not at compile-time, unless you generate source.
11:11:24 <rwbarton> you can't really write a Map "literal" at compile time at all, without dirty tricks
11:11:40 <chrisdone> indeed. you'd have to have a literal way to represent a map in template-haskell's AST
11:11:47 <Cale> jamiehannaford: evalRand :: RandomGen g => Rand g a -> g -> a
11:11:47 <chrisdone> (which there isn't)
11:12:02 <marteo_> I see
11:12:44 <fragamus> > runCont (do {a <- return 1;b <- cont (\fred 10 ++ fred 20); return $ a+b}) show
11:12:45 <lambdabot>  <hint>:1:48: parse error on input ‘++’
11:12:51 <Cale> jamiehannaford: If you're using it inside another Rand StdGen action, you just write something like do b <- x; ... where x :: Rand StdGen Bool, and then b :: Bool in the rest of the action.
11:13:29 <Cale> jamiehannaford: and then the do-block as a whole will have type Rand StdGen t for some type t (whatever type of result the last line has)
11:13:31 <fragamus> > runCont (do {a <- return 1;b <- cont (\fred 10 ++ fred 20); return $ a+b}) show
11:13:31 <fragamus> > runCont (do {a <- return 1;b <- cont (\fred -> fred 10 ++ fred 20); return $ a+b}) show
11:13:32 <chrisdone> a monad morphism would maybe allow what i want
11:13:32 <lambdabot>  <hint>:1:48: parse error on input ‘++’
11:13:32 <lambdabot>  can't find file: L.hs
11:14:19 <fragamus> > runCont (do {a <- return 1;b <- cont (\fred -> fred 10 ++ fred 20); return $ a+b}) show
11:14:20 <lambdabot>  "1121"
11:14:28 <jamiehannaford> Cale what do you mean having "b :: Bool" in the rest of the action?
11:14:54 <jamiehannaford> this is what I have:
11:14:57 <jamiehannaford> winsAgainst :: Rand StdGen [DieValue] -> Rand StdGen [DieValue] -> Bool
11:15:03 <jamiehannaford> a `winsAgainst` b =  (>) <$> a <*> b
11:15:25 <fragamus> so I am getting a firmer grasp on the Continuation monad but I would like to discuss it
11:17:25 <Cale> jamiehannaford: You need a StdGen to do that
11:17:39 <Cale> and yeah, that type signature is wrong for the implementation you gave
11:18:01 <Cale> jamiehannaford: That's a  Rand StdGen Bool
11:18:13 <Cale> on the right hand side of your equation
11:18:15 <jamiehannaford> yep, trying to figure out how to return Bool
11:19:29 <Cale> Well, if you want to run that action, you can have something like  main = do g <- newStdGen; print $ evalRand (something `winsAgainst` somethingElse) g
11:19:40 <rwbarton> what is your function supposed to mean?
11:22:33 <jamiehannaford> rwbarton I have two monads: each representing a list of computations that result in a random number. I want to first sort and then compare each list, and see whether a is greater than b - i.e. the winner
11:23:44 <joelteon> a monad is a type of kind * -> *, not a value
11:24:17 <jamiehannaford> but you can run it to return something, right?
11:24:43 <pietervdvn> if you have a monadic action, you can run it
11:24:44 <joelteon> no, that's an implementation detail
11:24:55 <rwbarton> you are again in the same situation as before
11:25:02 <joelteon> your intuition about how monads work is incorrect
11:25:16 <joshc> I'd suggest clearly separating the "randomness" out from the other logic; make your winsAgainst of type [DieValue] -> [DieValue] -> Bool; only when you have that working worry about lifting it into Rand StdGen
11:26:59 <rwbarton> a Rand StdGen [DieValue] is like a *process* that produces some value of type [DieValue], randomly
11:27:25 <jamiehannaford> right. I have two processes which produces two lists of random integers
11:27:35 <rwbarton> you can't compare two processes like this
11:27:40 <rwbarton> and get a Bool
11:27:53 <rwbarton> "which one is the winner" is itself a random process
11:28:02 <jamiehannaford> let me provide some context: http://lpaste.net/8632864379261419520
11:28:26 <jamiehannaford> dieA and dieB represent the outputs of the process which finds random die values
11:28:44 <jamiehannaford> well, no - not the outputs, the processes themselves
11:28:50 <rwbarton> right
11:29:04 <jamiehannaford> so, I need to "run" each one - is that what you mean?
11:29:17 <rwbarton> in order to see which result is greater, yes
11:29:33 <jamiehannaford> okay, I understand. how do I do that?
11:29:51 <joshc> :t evalRand
11:29:52 <lambdabot> Not in scope: ‘evalRand’
11:29:52 <rwbarton> here I would use do notation
11:30:06 <rwbarton> do { rollA <- dieA; rollD <- dieD; return ( ... ) }
11:30:33 <rwbarton> write the [DieValue] -> [DieValue] -> Bool function like joshc suggested, to determine the winner based on the particular die outcomes
11:31:33 <rwbarton> then apply it to rollA and rollD inside that "return ( ... )", they are the particular outcomes
11:31:37 <jamiehannaford> can you use if else statements in the do block?
11:31:44 <rwbarton> the whole thing is a big compound process
11:32:35 <rwbarton> if-then-else is an expression, you can use it anywhere you can use an expression
11:35:55 <jamiehannaford> rwbarton can't you have normal assignments in do blocks? foo = 123
11:36:06 <rwbarton> let foo = 123
11:36:54 <pjdelport> jamiehannaford: The way you use let in ghci is actually analogous to using let in do blocks.
11:37:45 <stolaruk> bcus ghci is in the IO monad, no?
11:38:10 <jamiehannaford> sweet, it worked! :) thanks everyone
11:52:16 <Ankhers> I have a bunch of different data types that have very similar data. Is there a way for one type to inherit fields from another, or some other way to reduce duplication?
11:54:11 <nexx> you could put the common data into another datatype and use it as a member in the other types
11:59:02 * hackagebot rest-client 0.4 - Utility library for use in generated API client libraries.  http://hackage.haskell.org/package/rest-client-0.4 (AdamBergmark)
11:59:04 * hackagebot rest-core 0.31 - Rest API library.  http://hackage.haskell.org/package/rest-core-0.31 (AdamBergmark)
11:59:06 * hackagebot rest-gen 0.14 - Documentation and client generation from rest definition.  http://hackage.haskell.org/package/rest-gen-0.14 (AdamBergmark)
11:59:08 * hackagebot rest-happstack 0.2.10 - Rest driver for Happstack.  http://hackage.haskell.org/package/rest-happstack-0.2.10 (AdamBergmark)
11:59:35 <glosoli> when naming my literate haskell files, is it some convention to use dash'es or underscores to separate words
11:59:35 <glosoli> ?
12:00:44 <glosoli> oh, just realised I should just see in some OSS project, nvm
12:01:58 <Cale> glosoli: Usually CamelCase.lhs
12:02:31 <Cale> glosoli: You want to name them the same as the module names, and most things in Haskell (including module names) are CamelCase by convention.
12:02:43 <glosoli> Cale: I see, thanks!
12:04:02 * hackagebot rest-types 1.10.1 - Silk Rest Framework Types  http://hackage.haskell.org/package/rest-types-1.10.1 (AdamBergmark)
12:04:04 * hackagebot rest-snap 0.1.17.12 - Rest driver for Snap.  http://hackage.haskell.org/package/rest-snap-0.1.17.12 (AdamBergmark)
12:04:06 * hackagebot rest-wai 0.1.0.2 - Rest driver for WAI applications.  http://hackage.haskell.org/package/rest-wai-0.1.0.2 (AdamBergmark)
12:04:43 <mlaine> hi all, i wonder how well haskell is suited for scientific programming, numerical modelling etc.
12:06:11 <mlaine> are there decent packages for making plots
12:08:22 <tolt> I don't know exactly what you're looking for but https://github.com/timbod7/haskell-chart/wiki is pretty nice.
12:12:14 <Rosy21>  Hi! I give you some videos. I hope you like! http://bitly.com/1qaKTCP
12:13:01 <mlaine> tolt: thanks, i've been using python for almost a year now and would like to learn another language, took a course on Mathematica and got interested in functional languages
12:15:34 <matematikaadit> @where op
12:15:34 <lambdabot> I know nothing about op.
12:15:41 <matematikaadit> @op
12:15:41 <lambdabot> Maybe you meant: yow wn v rc pl id do bf @ ? .
12:16:27 <matematikaadit> ah, the spam has been killed
12:18:43 <wz1000> Is there any tool for visualising Haskell data structures? Graphs, trees and the like
12:19:13 <luite> wz1000: diagrams
12:19:42 <phi__> \join #numerical-haskell
12:19:59 <luite> wz1000: it has some tree layout things in contrib, probably some graph relatd things too
12:20:59 <wz1000> luite: Thanks, this looks interesting
12:34:20 <genericpersona> how do you guys deal w/ cabal? in some ways it's a very nice package manager, but eventually it ends giving me dependency hell
12:34:31 <genericpersona> is this just me being a n00b, or is this a common experience?
12:34:34 <frontendloader> drinking
12:34:42 <genericpersona> definitely drinking
12:34:45 <genericpersona> hahaha
12:36:38 <Pythonfant> genericpersona: sandbox all the things
12:36:46 <geekosaur> cabal isn't really a package manager, it's a library manager for ghc (which is incredibly picky) with some installation capability. most "cabal problms" are really cabal failing to find a way to appease ghc
12:37:04 <genericpersona> Pythonfant: what do you use to sandbox everything?
12:37:15 <Pythonfant> genericpersona: cabal sandbox init
12:37:19 <genericpersona> ah
12:37:21 <genericpersona> nice
12:37:50 <Pythonfant> then any cabal commands executed in that directory will install into the sandobx located in that directory
12:38:01 <genericpersona> excellent!
12:38:05 <kazagistar> genericpersona: sandboxing is somewhat new, so if you have an unupdated old version of haskell platform cabal it does not work
12:38:10 <genericpersona> it worked for me
12:38:18 <kazagistar> but then you should just update anyways :D
12:38:20 <genericpersona> i run arch so i have pretty up to date stuff
12:38:23 <genericpersona> :)
12:39:23 <kazagistar> yeah, I just recently started using sandboxes and the cabal build system properly, and it has been nice
12:49:05 * hackagebot quickspec 0.9.5 - Equational laws for free  http://hackage.haskell.org/package/quickspec-0.9.5 (NickSmallbone)
12:50:46 <luite> does cabal pass the -j flag on to ghc if there's only one package to build?
12:53:26 <ballheart> I have an Android app with a haskell backend, is it OK to ask about the visual design of the app here then? I need some input...
12:54:06 * hackagebot quickcheck-webdriver 0.1.0.3 - Utilities for using WebDriver with QuickCheck  http://hackage.haskell.org/package/quickcheck-webdriver-0.1.0.3 (christianpbrink)
12:57:50 <dmwit_> ballheart: I would think it's fine to ask here, but I'm not sure you're best served by it.
12:58:18 <dmwit_> Have you considered asking other Android developers, or finding a UI community instead?
12:59:07 * hackagebot quickcheck-webdriver 0.1.0.4 - Utilities for using WebDriver with QuickCheck  http://hackage.haskell.org/package/quickcheck-webdriver-0.1.0.4 (christianpbrink)
13:02:23 <ballheart> well can you point me to a GOOD UI community. android-dev is not answering in any help ful way
13:02:23 <kardboardb> Is there an equivalent of foldM for Applicative?
13:02:23 <kardboardb> OI'
13:02:40 <ballheart> http://sv.tinypic.com/view.php?pic=10cnbxt&s=8#.U6sltPmSySo <- do you think it is unclear?
13:03:05 <kardboardb> I'm looking for a foldA :: Applicative f => (a -> b -> f a) -> a -> [b] -> f a
13:03:50 <dmwit> Very unclear. I would have no idea what the ramifications of clicking "Next" were or why there was a button at all.
13:04:00 <dmwit> But then I don't know what your app is supposed to do in the first place.
13:04:15 <dmwit> There's a StackExchange for UX. No idea whether it's "good" by your standards.
13:04:21 <ballheart> it is a football quiz app, i removed the title.
13:05:11 <dmwit> I think it's possible that you're not getting very good help because you're not asking a very good question.
13:05:47 <dmwit> :t F.foldA
13:05:48 <lambdabot>     Not in scope: ‘F.foldA’
13:05:48 <lambdabot>     Perhaps you meant one of these:
13:05:48 <lambdabot>       ‘F.foldr’ (imported from Data.Foldable),
13:05:55 <dmwit> :t T.traverse
13:05:56 <lambdabot> (Traversable t, Applicative f) => (a -> f b) -> t a -> f (t b)
13:06:00 * rwbarton is just curious about the "Haskell backend" part
13:06:11 <vanila> ballheart, I hate "Nbr"
13:06:20 <hexagoxel> the link to archlinux on http://www.haskell.org/platform/linux.html is broken. and i fail to find out where there is a bugtracker/maintainer for the page..
13:06:40 <dmwit> :t T.foldM
13:06:41 <lambdabot>     Not in scope: ‘T.foldM’
13:06:41 <lambdabot>     Perhaps you meant one of these:
13:06:41 <lambdabot>       ‘F.foldr’ (imported from Data.Foldable),
13:06:45 <dmwit> :t F.foldM
13:06:46 <lambdabot>     Not in scope: ‘F.foldM’
13:06:46 <lambdabot>     Perhaps you meant one of these:
13:06:46 <lambdabot>       ‘F.foldr’ (imported from Data.Foldable),
13:06:48 <dmwit> bah
13:06:53 <ballheart> dmwit: i meant is the buttons unclear? if you know the app name is "world cup quiz" and you start it and see that, is it really unclear?
13:07:21 <quchen> :t F.foldrM
13:07:22 <lambdabot> (Foldable t, Monad m) => (a -> b -> m b) -> b -> t a -> m b
13:07:23 <quchen> :-)
13:07:35 <quchen> (as opposed to foldlM)
13:08:16 <kazagistar> kardboardb: yeah, what you want probably requires a monad, not just an applicative
13:08:21 <dmwit> Do the names "foldr" and "foldl" really generalize to containers that are not actually modeling sequences?
13:08:35 <dmwit> Applicative should be enough.
13:08:49 <quchen> dmwit: Foldable is about introducing a sequential shape to a container, so I would say yes
13:08:57 <vanila> foldr can, but not foldl
13:09:36 <quchen> dmwit: Set for example is arguably not a sequential thing, with Ord being there just for efficiency. Foldable makes it a "sorted list".
13:09:46 <dmwit> ...or should it? huh
13:09:48 <kazagistar> as long as you can have a sequential shape, you can foldr
13:09:58 <dmwit> quchen: Yeah, I find that a bit odd.
13:10:11 <dmwit> ...but sort of unavoidable.
13:10:33 <quchen> Ideally we'd like to have a mathematical "Set" of course, but that has terrible performance (and would still require Eq to do anything useful with I guess)
13:11:06 <dmwit> ballheart: I wouldn't really understand what "number of players" was about. Number of questions seems sort of clear, but still may be up for some confusion.
13:12:17 <quchen> kardboardb: I have a strong feeling that fold*M is monadic, but I'm not sure how to prove it.
13:12:34 <dmwit> ?src foldM
13:12:35 <lambdabot> foldM _ a []     = return a
13:12:35 <lambdabot> foldM f a (x:xs) = f a x >>= \fax -> foldM f fax xs
13:12:38 <kardboardb> quchen: Hmm. That'd be unfortunate.
13:13:04 <quchen> Oh right, you're repeatedly applying a function to a value, the function generates a "m a" every time.
13:13:21 <dmwit> I dunno. You could traverse, then collapse with fmap.
13:13:21 <quchen> That gives you a long and nested thing of "m (m (m (... m a))))" eventually.
13:13:26 <quchen> Without Monad you can't collapse it.
13:13:30 <dmwit> :t traverse
13:13:31 <lambdabot> (Traversable t, Applicative f) => (a -> f b) -> t a -> f (t b)
13:14:06 <quchen> dmwit: In Traversable, the (Applicative) values are independent of each other, though.
13:14:14 <dmwit> Okay, I get it.
13:14:18 <quchen> It's like map vs fold.
13:14:19 <dmwit> And I agree.
13:14:38 <ballheart> dmwit: it is a quiz app, you read the questions out loud, so nbr of players is just how many people you want to play with. How could it be made clearer?
13:15:41 <dmwit> ballheart: I have no idea. I don't know anything about designing good UIs.
13:16:16 <quchen> When you don't know how to design a good API, convince yourself that a console interface is good enough ;-)
13:16:29 <kazagistar> ballheart: if you are looking for UI focused communities, haskell is probably a strange place to start :P
13:18:05 <ballheart> quchen: well convince people like my dad that a console interface is good on his android :)
13:18:53 * quchen admits defeat
13:19:55 <rwbarton> one thing I'm sure of is Nbr is not a word
13:23:35 <joelteon> is there a package that provides getEnv with bytestrings instead of strings?
13:23:44 <dmwit> ballheart: I have only one thought that I could reasonably label as helpful, which is this: are you sure you need to know how many questions and how many players up front?
13:25:33 <arj> when installing tsl via cabal I get the following error. http://lpaste.net/106311 any ideas or suggestions?
13:26:48 <savanni> arj: that looks like a bug in the package.  I have 1.2.8 installed in on my system, so can you upgrade at least one point release?
13:27:24 <arj> savanni: I didn't get the last sentence. "one point release"?
13:27:28 <kazagistar> dunno, my dad was using unix before I ever touched a computer
13:27:35 <savanni> 1.2.4 or some such
13:27:39 <kazagistar> and he is a mathematician, not a computer guy
13:27:53 <savanni> "point release" I think refers to that third digit.
13:27:54 <dmwit> arj: My suggestion (if upgrading the way savanni suggested doesn't work) is to cabal unpack tls and load the file in question in ghci to find out where Fail comes from. Perhaps it changed recently, and you need to update a dependency.
13:28:48 <arj> ok, let's see... I just want to install yesod...
13:29:07 <arj> at the moment a fresh / clean system cannot install yesod using cabal install yesod-bin
13:29:24 <arj> +yesod.
13:29:30 <arj> I'd consider this very bad :/
13:29:39 <savanni> Sometimes the things that Yesod depends on break.  Snoyman has talked about that problem and I think he developed an alternative install for Yesod in particular.
13:29:54 <l0cust> arj: the obvious solution is to not use yesod
13:30:03 <l0cust> arj: yesod is pretty awful
13:30:14 <arj> l0cust: what can you recommend, then?
13:30:21 <l0cust> arj: I'm a fan of happstack
13:30:37 <l0cust> arj: really, rails would probably be better than yesod
13:30:39 <arj> why do you consider it superior?
13:30:46 <l0cust> arj: better documentation
13:31:06 <l0cust> arj: that's really the only reason
13:31:13 <kazagistar> but everyone loves playing type tetris, right?
13:31:16 <savanni> arj: also less magic with templates and undocumented monad stacks
13:31:29 <Ankhers> If I have a data type `data Gender = Male | Female deriving (Show, Eq, Enum)`, how would I be able to write an instance of FromJSON?
13:31:31 <l0cust> kazagistar: "type tetris" - I love that
13:31:52 <savanni> arj: Also, I lied.  happstack-tls apparently didn't install tls, and I was just looking at the version that was available, not the version installed.  Sorry.
13:32:01 <l0cust> Ankhers: Well, first you have to define how you would represent it as json
13:32:01 <stepcut> Ankhers: that's a pretty limited view on Gender..
13:32:14 <l0cust> stepcut: lol
13:32:17 <Ankhers> stepcut: I'm simplifying for the sake of asking here.
13:32:30 <Ankhers> stepcut: That, and I'm using someone elses API.
13:32:35 <l0cust> Ankhers: well, in JSON, you would want something like
13:32:43 <l0cust> "gender": "male"
13:32:50 <dmwit> Ankhers: Have you tried "instance FromJSON Gender"?
13:32:51 <arj> thanks to you all. giving happstack a shot now :)
13:32:53 <stepcut> Ankhers: do you want to write an instance? or derive on automatically?
13:33:14 <l0cust> arj: snap is also worth looking at
13:33:16 <kazagistar> l0cust: I picked it up from someone else either here or on reddit, I forget who though :P
13:33:26 <l0cust> arj: although I do prefer Happstack
13:33:35 * stepcut better finish uploading the Happstack that supports network 2.5 and mtl 2.2 !
13:34:09 <savanni> arj: While I prefer Happstack, Yesod is very good so long as what you're doing is covered in the Yesod tutorials.  It's when I went beyond the tutorials that I got bitten.
13:34:55 <dmwit> l0cust: It's not clear to me that's what you would want, actually.
13:35:13 <dmwit> l0cust: Now, if this were part of a record with a field named "gender" maybe I'd be on board...
13:35:13 <l0cust> savanni: well said
13:35:15 <arj> savanni: I don't want to be bitten ;-)
13:35:19 <ballheart> dmwit: ty
13:35:19 <Ankhers> stepcut: If it did it automatically, would it run just as fast as if I wrote my own?
13:35:22 <pharaun> i like wai/warp its nice
13:35:35 <arj> has happstack been tested in 'large' settings?
13:35:46 <pharaun> and I've had good luck with using stripped down yesod with like yesod-routing, etc..
13:36:06 <pharaun> yesod is a modular framework, so you can swap in/out what you want fwiw
13:36:08 <l0cust> pharaun: even with wai/warp, you still get into type tetris
13:36:24 <l0cust> pharaun: it's not a modular framework, that's the issue
13:36:36 <frontendloader> a list is a monad?
13:36:42 <sarkyniin> Hi!
13:36:43 <pharaun> l0cust: oh? in what area i haven't had too much issue there, but i'm mostly using it for a json/xml endpoint
13:36:48 <stepcut> arj: hackage is based on happstack..
13:36:53 <sarkyniin> I'm currently learning haskell with learn you a haskell for great good
13:36:55 <dmwit> frontendloader: Not quite. [], the list type constructor, is an instance of Monad.
13:37:00 <rwbarton> arj: I'm just trying to build yesod in a fresh user package db now and it got through tls (it installed tls-1.2.8 btw, maybe you need to cabal update?)
13:37:05 <arj> stepcut: ah, I wasn't aware of that!
13:37:34 <rwbarton> my .cabal/config isn't entirely vanilla
13:37:37 <sarkyniin> I wanted to know, what are people's thinking process when making patterns for pattern matching? I understand the basic ones like function :: (Integral a) => a => a
13:37:38 <arj> rwbarton: I updated cabal just before installing it and got version 1.20.0.2
13:37:46 <l0cust> pharaun: I'm sure it's fine for a simple little JSON server
13:37:48 <sarkyniin> but how do people make more complex ones? What's their thought of process?
13:37:51 <arj> mmh maybe something else is wrong
13:37:54 <rwbarton> arj: not update cabal, but download the latest package list
13:38:04 <savanni> arj: if you go with just plain Happstack, though, you're going to find that there's a lot of nice features that are missing.
13:38:06 <arj> rwbarton: using cabal update? I did this, too
13:38:11 <rwbarton> hmm, odd
13:38:15 <l0cust> sarkyniin: what do you mean "patterns for pattern matching"
13:38:25 <kazagistar> frontendloader: it is an "option" monad that is related to list comprehensions
13:38:25 <nomeata> Hi. Has anyone seen "cabal: does not exist" errors when running "cabal update"?
13:38:27 <l0cust> sarkyniin: It sounds like you're talking about type signatures
13:38:29 <sarkyniin> when you want to make a function that uses pattern matching
13:38:31 <pharaun> l0cust: but i guess i still don't get what you mean by type tetris, i played around lots with the api and it seemed ok so far
13:38:31 <arj> rwbarton: well, probably it is a local problem here.
13:38:34 <sarkyniin> how do you make patterns with type signatures
13:38:35 <sarkyniin> yea
13:38:38 <sarkyniin> that's what I meant
13:38:46 <arj> savanni: for example?
13:38:55 <sarkyniin> learn you a haskell doesn't really go in depth about that
13:39:02 <l0cust> sarkyniin: patterns are a way of writing functions - not the type signatures
13:39:05 <l0cust> for instanec
13:39:08 <l0cust> f 0 = 1
13:39:10 * hackagebot rest-stringmap 0.2.0.2 - Maps with stringy keys that can be transcoded to JSON and XML.  http://hackage.haskell.org/package/rest-stringmap-0.2.0.2 (AdamBergmark)
13:39:25 <ajcoppa> yeah, are you talking about actually pattern matching, or the type signatures specifically?
13:39:28 <savanni> arj: Yesod's handling of forms is really nice, and Happstack doesn't have that.  You'll also have to decide from the various HTML templating options, because none are native to Happstack.  Things like that.
13:39:29 <l0cust> f n = (*) n $ f (n-1)
13:39:31 <sarkyniin> type signatures
13:39:37 <l0cust> that's a pattern match
13:39:37 <kazagistar> pharaun: type tetris is when instead of examples and documentation, you have to figure out how to use the API by attempting to fit the types togeather
13:39:44 <pharaun> ahh
13:39:48 <l0cust> sarkyniin: it's a way to circumvent 'if' statements
13:39:49 <pharaun> haha yes
13:39:50 <ajcoppa> sarkyniin: are you asking how you decide what type signature your function should have?
13:39:55 <sarkyniin> yeah
13:39:57 <pharaun> kazagistar: it does suffer from it
13:40:20 <dmwit> sarkyniin: Usually, once you know what you want your function to do, its type signature is pretty clear.
13:40:20 <l0cust> sarkyniin: well, it depends on what your function doe
13:40:21 <l0cust> *does
13:40:22 <pharaun> i've gotten used to type tetris on lots of under documented libraries so i guess i'm at the point where i don't bait a eye at it
13:40:25 <stepcut> savanni: what aspect of form handling in particular?
13:40:28 <savanni> arj: also, "routing" so to speak is done through a set of monadic functions of various kinds.  There is a web-routes system that does routing in the same-ish way as Rails and Yesod, though I find it confusing.
13:40:32 <ajcoppa> it's hard to be general because you choose the types based on what you want the function to do :)
13:40:52 <l0cust> savanni: wnat
13:40:52 <pharaun> on being general, often i just implement a specific function with specific type
13:40:54 <savanni> stepcut: Yesod has a nice way to declare a form, and that declaration both generates the HTML for it and parses the result, depending on which way you choose to interpret it.
13:41:01 <pharaun> then if i notice multiple versions of this function
13:41:03 <l0cust> savanni: what's confusing about web-routes?
13:41:05 <pharaun> i go back and genericify it
13:41:16 <quchen> l0cust: What you wrote is actually a corner case of pattern matching, known as "n patterns". It's not an actual pattern match; "f 0 = foo" is rewritten to "f n | n == 0 = foo", for example.
13:41:25 <stepcut> savanni: that is what reform does.. is there something you prefer about the yesod approach?
13:41:33 <dmwit> sarkyniin: If you want your function to produce Blargle's out of Widgets and Whatchamacallits, then its type is Widget -> Whatchamacallit -> Blargle. There's a little more to it than that... but not all that much, really.
13:41:33 <quchen> It looks like you're matching on a constructor named "0" of course.
13:41:33 <savanni> l0cust: I've mostly had confusion with the incantation that plugs it into the Happstack Server.
13:41:50 <sarkyniin> lol dmilith
13:41:53 <sarkyniin> dmwit*
13:42:02 <ajcoppa> sarkyniin: if you want a function to concatenate two Strings, for example, it's probably going to need to take in a String, take in another String, and give you back a String
13:42:04 <sarkyniin> yeah that's a bit more talking
13:42:11 <savanni> stepcut: I've not gotten far enough in my current web apps to look at reform.  I was hoping that was what I would find there.  PMy original point being that these are features stacked on top of Happstack, where Yesod has them baked in.
13:42:13 <sarkyniin> if I wanted to make a function that associates a letter with a word, for example, would I just go "f a :: (Integral a) => a -> String?"
13:42:33 <l0cust> sarkyniin: a letter - no you would use Char
13:42:40 <l0cust> f :: Char -> String
13:42:41 <sarkyniin> I mean
13:42:43 <sarkyniin> a number with a word*
13:42:47 <l0cust> Ah
13:42:56 <l0cust> f :: Int -> String
13:43:05 <stepcut> savanni: happstack-foundation has them baked in, if you like..
13:43:32 <ajcoppa> the argument names ("a" in your example) don't need to go in the type signature
13:43:36 <kazagistar> quchen: actually, I think the first is more essential in haskell then the second, since the second requires (==) ...
13:43:38 <savanni> stepcut: Oh?  I'll look into that.  As a curiosity point, what HTML templating system do you recommend?
13:43:47 <l0cust> savanni: blaze!
13:43:52 <stepcut> savanni: I can agree that happstack gives you too many choices and people just want to be told what is best :)
13:44:09 <stepcut> savanni: I personally use HSX -- which is similar to hamlet but more powerful
13:44:09 <quchen> :t let f 0 = "hello" in f -- kazagistar
13:44:10 <sarkyniin> that gives me an error, tho, l0cust
13:44:10 <lambdabot> (Num a, Eq a) => a -> [Char]
13:44:14 <quchen> Eq! :-)
13:44:39 <sarkyniin> wait
13:44:42 <sarkyniin> the error doesn't come from that
13:44:44 <chrisdone> pharaun: "i don't bait a eye at it" -- it's bat an eye, as in eyelid, as in showing shock/surprise. baiting an eye sounds like some sort of medieval blood sport
13:44:45 <sarkyniin> sry yea
13:44:47 <sarkyniin> that looks good
13:44:50 <sarkyniin> thanks!
13:45:01 <kazagistar> I meant { "f 0 = foo" is rewritten to "f n | n == 0 = foo" } is not really right afaik
13:45:07 <dmwit> How do you bait an eye? With eye candy, of course.
13:45:16 <pharaun> chrisdone: oh! hah sorry, i am bad at remembering the correct way to say idiom
13:45:17 <chrisdone> dmwit: and shouting “yoink!”
13:45:26 <savanni> l0cust: that's what I use.  Some day I'll write up the scheme I devised for being able to have the same handlers used for multiple applications that want different HTML output.  That way you all can laugh at my hacked up solution. ;)
13:45:27 <dmwit> kazagistar: It's pretty right. What do you mean?
13:45:47 <rwbarton> it's non-wrong
13:45:56 <chrisdone> pharaun: nonnative speaker gets a free pass. *hands pharaun a free pass*
13:46:06 <l0cust> savanni: If I didn't have to play type tetris with Hamlet, I'd probably use it
13:46:32 <savanni> l0cust: oh, it's no library.  Just a particular way of coding.
13:47:22 <l0cust> savanni: sounds interesting
13:48:09 <dmwit> kazagistar: "Matching a numeric, character, or string literal pattern k against a value v succeeds if v  ==  k, where == is overloaded based on the type of the pattern. The match diverges if this test diverges." From the Haskell 2010 Report.
13:48:38 <quchen> kazagistar: What I wrote is pretty close to the definition in the Report, "formal semantics of pattern matching", item (h)
13:48:58 <rwbarton> what's the translation of 'f 0 (Just x) = x'
13:49:04 <jfischoff> I have an issue in production, and I am starting to wonder if I am seeing an issue with the RTS.
13:49:22 <kazagistar> hmm, I was looking at haskell core, where the only conditional is the case statement...
13:49:26 <chrisdone> jfischoff: ohh, that sinking feeling
13:49:32 <dmwit> rwbarton: I'm pretty sure the Report says patterns are matched left-to-right, if that's what you're asking.
13:49:49 <rwbarton> so you can't really re-write it with a guard, can you
13:50:08 <dmwit> You can. You just also need to rewrite all the other patterns along with it. =)
13:50:15 <dmwit> But yes, I get your point.
13:50:26 <chrisdone> f a b | a == 0, Just x <- b = x =p
13:50:50 <kazagistar> dmwit: but I guess literals being handled differently makes sense
13:51:11 <quchen> rwbarton: It's always a good brain teaser to work patterns out by hand using the Report's table. But takes a lot of patience, frustration tolerance, and rigor.
13:51:19 <jfischoff> when load increases, and more threads exist to service requests, A periodic oscilation occurs, once every 30 secs: threads stop doing work (not entirely), and the system cpu goes up.
13:51:31 <dmwit> Yes, surface-syntax-patterns are compiled away into Core matches that don't use equality tests. But then the equality test is explicitly available in the Core.
13:51:37 <jfischoff> I’m on 7.6.3
13:51:39 <chrisdone> jfischoff: is it garbage collection?
13:51:39 <quchen> kazagistar: Specifically, there are String, Integral, and Char literals by default
13:51:44 <albeit> How can I perform a bunch of IO computations on a map? I need something like Map a (IO b) -> Map a b?
13:51:56 <jfischoff> chrisdone: could be
13:51:59 <quchen> s/Integral/"numeric"
13:52:16 <kazagistar> it would really be desugared into something like case (x == 0) of {True -> foo} or somesuch eventually then, I guess?
13:52:17 <chrisdone> hmm tho the ghc should be parallel so not all threads should lock up
13:52:18 <dmwit> albeit: Can't. But could do Map a (IO b) -> IO (Map a b).
13:52:20 <quchen> I think this may have been the reason to have Eq as a superclass of Num, actually.
13:52:41 <chrisdone> jfischoff: are you running it with n cores specified? curious
13:52:43 <albeit> dmwit: Ah true, I guess that's what I want to do.
13:53:02 <jfischoff> chrisdone: no it is single threaded I think
13:53:03 <dmwit> albeit: Then you can use the Traversable instance.
13:53:07 <jfischoff> so green threads
13:53:21 <dmwit> :t T.sequenceA
13:53:22 <lambdabot> (Traversable t, Applicative f) => t (f a) -> f (t a)
13:53:31 <rwbarton> kazagistar: it hopefully gets optimized eventually into a "case x of { 0# -> foo }"
13:53:32 <chrisdone> jfischoff: right, then i imagine a GC in that setting is essentially a stop-the-world
13:53:35 <dmwit> :t T.sequenceA :: Map a (IO b) -> IO (Map a b)
13:53:36 <lambdabot>     Not in scope: type constructor or class ‘Map’
13:53:36 <lambdabot>     Perhaps you meant ‘M.Map’ (imported from Data.Map)
13:53:36 <lambdabot>     Not in scope: type constructor or class ‘Map’
13:53:43 <dmwit> :t T.sequenceA :: M.Map a (IO b) -> IO (M.Map a b)
13:53:44 <lambdabot> M.Map a (IO b) -> IO (M.Map a b)
13:53:48 <quchen> kazagistar: The Report says    case v of { k -> e; _ -> e' } = if v == k then e else e'
13:53:50 <jfischoff> chrisdone: no wait it is threaded
13:54:02 <chrisdone> jfischoff: how?
13:54:02 <albeit> dmwit: Perfect thanks
13:54:46 <quchen> kazagistar: And "if" is short for a case on Bool, I think. In any case, remember that these are the semantics; implementations can obey them in whatever way they like.
13:54:47 * jfischoff is looking at startup configs
13:54:58 <kazagistar> right, I was being lazy, because core demands exhaustive case statements
13:55:08 <Rembane> jfischoff: Are they lean?
13:55:20 <chrisdone> jfischoff: any +RTS -Nx?
13:55:43 <jfischoff> chrisdone: yeah I’m double checking I’m pretty sure the answer is no, so only one thread
13:56:21 <jfischoff> yeah I don’t see any parameters being passed
13:56:36 <jfischoff> okay well that is any easy theory to test
13:56:55 <jfischoff> I’ll change the garage collection frequency see if the oscilation changes
13:58:06 <chrisdone> you could also use tibbe's ekg tool http://blog.johantibell.com/2011/12/remotely-monitor-any-haskell.html
13:58:44 <chrisdone> to monitor the memory use over time
13:58:49 <jfischoff> we have our own tool, I can use the same hooks though, which I have been meaning to do, so thanks for the reminder
13:59:08 <jfischoff> we use this: https://github.com/imvu-open/istatd
13:59:32 <jfischoff> chrisdone: got to go, thanks for the help
14:00:19 <chrisdone> i think ekg tells you more about what the GC is doing
14:00:28 <dncr> When I make a heap profiling graph the "time" axis ends at 0.5 seconds even though my program ran for 3.8 seconds.
14:00:28 <chrisdone> i don't think istatd knows what ghc's garbage collector is doing
14:00:42 * chrisdone → bed
14:00:47 <dmj`> chrisdone: ekg is a good tool, the snap dependency is a little heavy :/
14:01:07 <dmj`> chrisdone: I just use GHC.Stats
14:01:20 <dmj`> think that's what ekg is using under the hood
14:01:33 <rola> GHCats
14:01:44 <dmj`> :)
14:15:26 <l0cust> Hey, question
14:15:31 <l0cust> What editor do you all use?
14:15:53 <savanni> I'm on SublimeText 2.  Most of the time.
14:16:01 <pranz> vim
14:16:08 <dmj`> emacs
14:16:09 <sipa> mcedit
14:16:13 <l0cust> emacs
14:16:18 <l0cust> sipa: what the hell is mcedit?
14:16:19 <dmj`> notepad.exe
14:16:26 <l0cust> dmj`: lol
14:16:27 <dmj`> midnight commander
14:16:59 <dmj`> http://en.wikipedia.org/wiki/Midnight_Commander
14:17:19 <l0cust> oh
14:17:26 <l0cust> That doesn't actually what the fuck
14:17:54 <l0cust> That just seems like shitty dired
14:17:55 <dwcook> ed
14:18:05 <dwcook> (just kidding, vim)
14:18:14 <l0cust> dwcook: http://xkcd.com/378/
14:18:24 <dwcook> Knew it'd be that one
14:18:51 <tar_> is there a general way to load an image file into a texture with Rasterific? the closest I've gotten is http://pastie.org/9324151 but that can't handle most types (including whichever one my JPG file is)
14:18:51 <napping> https://www.gnu.org/fun/jokes/ed-msg.html
14:19:00 <l0cust> M-x butterfly is actually an emacs command
14:19:59 <tanmaig> How should I recompile a cabal package with my modifications? I already have an installed pacakage. I went go .cabal/packages/... , un-tarred it and modified the file I wanted.
14:20:01 <tanmaig> Now what?
14:20:07 <savanni> What's it do?
14:20:26 <l0cust> I feel like there should be a separate channel specifically for cabal issues
14:20:28 <savanni> I assume emacs users don't have hoards of butterflies wired into their computers.
14:20:37 <l0cust> savanni: you would be wrong
14:20:49 <johnw> there really should be a #cabal
14:20:56 <l0cust> johnw: there is, last i checked
14:21:03 <l0cust> johnw: it only has 5 users
14:21:15 <l0cust> oh, six now
14:21:24 <rwbarton> are they the right six users?
14:21:36 <ccapndave2> Hey everyone - I am trying to make a loop that executes a function lots of times so I used a foldr over a range, but I don't think its actually executing more than once .  What's a good way to do this?
14:21:38 <rwbarton> tanmaig: just 'cabal install' from inside the directory
14:21:44 <ccapndave2> foldr (\wins acc -> spin slotMachine 1 (randomRs (1, 50) randomGenerator :: [Int])) [] [0..iterations]
14:21:49 <ccapndave2> That's what I have
14:21:54 <rwbarton> tanmaig: you can also do your first steps with 'cabal unpack <packagename>'
14:21:58 <l0cust> cpa_: no loops in haskell
14:22:07 <johnw> ccapndave2: you could use repeat
14:22:09 <l0cust> s/cpa_/ccapndave2
14:22:09 <johnw> :t repeat
14:22:09 <ccapndave2> Even when iterations is 10000000 it still runs instantly, which seems a bit suspect
14:22:10 <lambdabot> a -> [a]
14:22:15 <johnw> :t replicate
14:22:16 <lambdabot> Int -> a -> [a]
14:22:27 <l0cust> ccapndave2: what are you trying to do
14:22:36 <rwbarton> ccapndave2: you don't use wins or acc in your fold function
14:22:39 <l0cust> ccapndave2: loops aren't really a thing in haskell
14:22:48 <ccapndave2> I am trying to run a simulation of a slot machine and gather some stats
14:22:53 <l0cust> Ah
14:22:54 <johnw> ah
14:23:02 <ccapndave2> spin slotMachine 1 (randomRs (1, 50) randomGenerator :: [Int]))
14:23:13 <ccapndave2> That does one run, and returns a Win object
14:23:21 <ccapndave2> I need to constantly count stuff and take averages etc
14:23:31 <ccapndave2> But for now I would be happy just to run it n times and see how long it takes
14:24:50 <savanni> ccapndave2: you're running afoul of laziness.  You'll have to do something to force the evaluation of each Win.
14:25:23 <rwbarton> for benchmarking, try criterion
14:26:05 <ccapndave2> Cool
14:26:08 <dmj`> for random numbers try mwc-random
14:26:13 <dmj`> https://hackage.haskell.org/package/mwc-random
14:26:23 <ccapndave2> Is this StdGen this no good?
14:26:41 <luite> where can i find the package+version list for the upcoming 2014 haskell platform release?
14:26:45 <ccapndave2> But anyway, before improving things and generating nice benchmarks I just want to force this to run 1000000 times
14:26:51 <ccapndave2> Is there a hacky way to do it quickly?
14:27:00 <ccapndave2> It doesn't have to be nice
14:27:18 <ccapndave2> I just need to use unix 'time' in order to compare it against PHP, HHVM and Scala versions
14:27:23 <geekosaur> luite: it was posted on the libraries mailing list at one point
14:27:27 <savanni> ccapndave2: does Win have any data in it?
14:27:34 <rwbarton> it's a little tricky
14:27:46 <ccapndave2> savanni Yes, sometimes
14:27:56 <ccapndave2> savanni Its a [Win]
14:28:12 <rwbarton> yeah, there are two issues, one is completely evaluating the result, the other is avoiding sharing
14:28:29 <savanni> ccapndave2: Then it's more complicated than I was hoping.  But make any data in Win strict, then you might get it to work right by counting the number of Wins.  And then being sure to print the count.
14:29:05 <ccapndave2> How about turning the spin into an infinite list and taking the first million elements
14:29:08 <ccapndave2> Or something?
14:29:17 <savanni> That would still be lazy.
14:29:33 <ccapndave2> And counting them?
14:29:58 <savanni> Counting them would help, but I'm afraid that it wouldn't fully evaluate the data within each Win.
14:30:05 <ccapndave2> hmm
14:30:06 <luite> geekosaur: ah got buried in a huge thread that was somehow split into multiple parts in my mailig list folder, but managed to dig it up. tnx :)
14:30:19 <zwer> ccapndave2 that reminds me when haskell was dominating one online benchmark because it didn't require output, so haskell code didn't compute anything :)
14:30:24 <ccapndave2> :)
14:30:35 <geekosaur> ah, I was digging for it just now (although I'm having to ride herd on a couple other channels atm, so a bit distracted...)
14:30:43 <ccapndave2> Can I turn laziness off for a function?
14:30:47 <luite> just checking how much of the Haskell platform i should build by default with GHCJS
14:31:20 <rwbarton> you can make your data type non-lazy
14:31:26 <ccapndave2> Ah
14:31:28 <ccapndave2> With a !
14:31:43 <sarkyniin> If I wanted a function that would find a list's last element, I could just use:
14:31:44 <sarkyniin> myLast :: [a] -> a
14:31:44 <sarkyniin> myLast (xs:x) = x
14:31:46 <sarkyniin> right?
14:32:00 <rwbarton> no
14:32:00 <ccapndave2> Hmm, that didn't work
14:32:15 <zwer> > [] : 1  -- nope
14:32:17 <lambdabot>  No instance for (GHC.Show.Show t0)
14:32:17 <lambdabot>    arising from a use of ‘M170319805000656518030787.show_M1703198050006565180...
14:32:17 <lambdabot>  The type variable ‘t0’ is ambiguous
14:32:17 <lambdabot>  Note: there are several potential instances:
14:32:17 <lambdabot>    instance [safe] GHC.Show.Show
14:32:25 <Pythonfant> :t (:)
14:32:26 <lambdabot> a -> [a] -> [a]
14:32:29 <ccapndave2> ooo
14:32:32 <Pythonfant> snowp: take a look at that
14:32:33 <ccapndave2> I put ! on the accumulator
14:32:36 <rwbarton> sarkyniin: (xs:x) is a list whose first element is (oddly) named xs, and whose remaining elements are a list named x
14:32:38 <zwer> sarkyniin x and xs names don't have any special meanings
14:32:40 <ccapndave2> foldr (\wins !acc -> spin slotMachine 1 (randomRs (1, 50) randomGenerator :: [Int])) [] [0..iterations]
14:32:43 <ccapndave2> Now I have a stack overflow
14:32:46 <zwer> they are just a convention
14:32:55 <Pythonfant> you can only prepend to a list so only do pattern matching on the first element
14:33:27 <Pythonfant> (well actually I think there is an extension that allows you to match on a function or something like that)
14:33:29 <luite> a few packages don't make much sense (OpenGL / OpenGLRaw aren't quite compatible with WebGL, cgi seems fairly useless), some still need some work to be fully supported (zlib, regex-posix, network)
14:33:32 <sarkyniin> zwer / rwbarton : is _:x the correct way to do it?
14:33:52 <rwbarton> no
14:33:55 <rwbarton> you need recursion
14:33:58 <sarkyniin> oh
14:34:00 <sarkyniin> right
14:34:02 <Pythonfant> sarkyniin: (:) takes a single element on the left and a list on the right
14:34:14 <sarkyniin> oh
14:34:41 <luite> an i still need to finish the file io in base, the directory and process packages so they work as expected in node.js
14:36:05 <sarkyniin> oh okay, that cleared it up for me Pythonfant
14:36:16 <sarkyniin> I could do myLast (_:xs) = myLast xs
14:36:31 <sarkyniin> but add myLts x = x before that so it doesn't go infinitely
14:36:37 <sarkyniin> myLast*
14:37:34 <zwer> x will match anything. if you want to match a list with a single element you want either `myLast [x] = x' or `myLast (x:[]) = x'
14:37:56 <ajcoppa> sarkyniin: also, what should happen when you give myLast an empty list?
14:38:13 <sarkyniin> I have a myLast [] = "Empty List" ajcoppa
14:38:20 <sarkyniin> at the beginning
14:38:27 <ajcoppa> "Empty List" isn't of type a though
14:39:08 <zwer> if that is what you wrote your myLast would only work with [String]
14:39:14 * hackagebot hsx2hs 0.13.2 - HSX (Haskell Source with XML) allows literal XML syntax in Haskell source code.  http://hackage.haskell.org/package/hsx2hs-0.13.2 (JeremyShaw)
14:39:19 <hexagoxel> (archlinux:) what is the easiest way to install ghc 7.6 (plus cabal.. (?)) in addition to 7.8.2?
14:40:39 <sarkyniin> hm
14:40:42 <sarkyniin> yeah I guess ajcoppa
14:40:47 <ajcoppa> :)
14:41:01 <ajcoppa> in general, you can't write a safe function [a] -> a because of that case where the list is empty
14:41:02 <sarkyniin> dunno how I would go about it then
14:41:15 <ajcoppa> you can blow up with an error if it is called with an empty list
14:41:17 <Pythonfant> sarkyniin: use maybe a
14:41:23 <ajcoppa> the other way is to use Maybe a, yep
14:41:25 <alex94nts> you could use Maybe sarkyniin
14:41:33 <ccapndave2> Ok, I got round laziness by counting the wins as suggested by savanni, but now I am getting a stack overflow.  Why is foldr using the stack?
14:41:40 <sarkyniin> what's maybe?
14:41:56 <alex94nts> because foldr has to evaluate the whole list, you should use foldl'
14:41:59 <sarkyniin> myButLast :: [a] -> maybe a?
14:42:05 <ccapndave2> alex94nts Ah
14:42:07 <sarkyniin> what does it do
14:42:15 <ajcoppa> sarkyniin: a type of Maybe a it is kind of like a nullable type in other languages. it can either be Nothing, or Just a value of type a
14:42:19 <ccapndave2> alex94nts Thanks
14:42:22 <ajcoppa> :t Just 3
14:42:23 <lambdabot> Num a => Maybe a
14:42:26 <alex94nts> it's the strict version of foldl in the prelude
14:42:29 <sarkyniin> ohok
14:42:32 <ajcoppa> :t Just "hi"
14:42:32 <lambdabot> Maybe [Char]
14:43:17 <alex94nts> would it be pedantic to say that Maybe is a Functor?? xD
14:43:32 <coppro> no
14:43:33 <hpc> it would be correct
14:43:42 <ajcoppa> sarkyniin: what resource(s) are you using to learn haskell?
14:43:45 <rwbarton> it might not be relevant?
14:43:45 <kazagistar> Maybe is an instance of Functor, correct
14:44:01 <Pythonfant> nullable value seems like a good enough explanation to get started
14:44:17 <eikke__> is the 'plugins' package still the way to go for such functionality?
14:44:42 <alex94nts> haha yeah, only said so because i've been trying lately to get a thorough understanding of Functors and Applicatives...
14:45:17 <alex94nts> they seem so much abstract to me, do you have any examples where it could be useful?
14:45:34 <ajcoppa> alex94nts: have you heard of the NICTA course?
14:45:49 <ajcoppa> it is tough, but you go through implementing functors, applicatives, and monads
14:45:51 <alex94nts> ajcoppa: nope, what is that?
14:45:58 <ajcoppa> https://github.com/NICTA/course
14:46:10 <kazagistar> usually, Maybe like the second functor people mention, right after lists
14:46:11 <zwer> sarkyniin prelude's last uses error, so you can use that until you learn Maybe
14:46:11 <ajcoppa> try it out and ask for help if you need it
14:46:18 <zwer> :t error "empty list"
14:46:19 <lambdabot> a
14:46:35 <alex94nts> ajcoppa: thanks a lot!
14:47:09 <ajcoppa> you will likely hit a couple of speed bumps since the course doesn't hold your hand too much
14:47:15 <ajcoppa> but ask questions here or in #haskell-beginners
14:47:44 <ccapndave2> foldl' (\acc wins -> acc + length(spin slotMachine 1 (randomRs (1, 50) randomGenerator :: [Int]))) 0 [0..iterations]
14:47:57 <ccapndave2> This is still doing weird stuff
14:48:17 <ccapndave2> Its either returning 0 or 10001 or 30003 etc, still suspiciously quickly
14:48:24 <ccapndave2> (with iterations = 10000)
14:48:25 <rwbarton> are you compiling with optimizations?
14:48:30 <ccapndave2> Umm
14:48:36 <ccapndave2> I am just calling cabal build
14:48:43 <rwbarton> ok, then yes
14:48:58 <rwbarton> ghc notices that length(spin slotMachine 1 (randomRs (1, 50) randomGenerator :: [Int])) doesn't depend on acc or wins
14:49:05 <rwbarton> so, it only has to compute it once
14:49:22 <ccapndave2> hmm
14:49:36 <ccapndave2> Damn Haskell and its extremely smart optimizations
14:49:38 <rwbarton> (btw, 10000 iterations is not that many, maybe you want more like 10000000?)
14:49:49 <Cale> ccapndave2: Well, what are you trying to do?
14:49:50 <rwbarton> (I don't know how long you expect one 'spin' to take)
14:50:05 <Cale> ccapndave2: Of course it should only compute it once, it's a constant.
14:50:08 <ccapndave2> Well, in PHP 10000 takes about 9s and in Scala about 3s
14:50:14 <rwbarton> oh ok
14:50:20 <ccapndave2> Badly coded Scala though
14:50:33 <ccapndave2> (randomRs (1, 50) randomGenerator :: [Int])
14:50:38 <ccapndave2> Isn't this different each time though?
14:50:44 <rwbarton> Nope
14:50:46 <rwbarton> it can't be
14:50:46 <Cale> If you give the same randomGenerator, it's the same
14:51:03 <ccapndave2> Hmm
14:51:11 <rwbarton> what is the definition of randomGenerator?
14:51:19 <ccapndave2> gen <- newStdGen
14:51:34 <ccapndave2> I have to say I am copying the random stuff from tutorials without completely understanding it
14:51:37 <tommd> Cale: No it isn't!
14:51:49 <int-e> ccapndave2: unsafePerformIO is unsafe.
14:52:04 <kazagistar> it cant be, because you cannot escape the IO monad and have random numbers without using a bind... did you do unsafePerformIO?
14:52:22 <rwbarton> ccapndave2: ok so it sounds like you are running newStdGen once, and then using the same generator many times
14:52:26 <ccapndave2> No, but gen <- newStdGen is in main
14:52:27 <Cale> tommd: ?
14:52:36 <tommd> @where paste
14:52:36 <lambdabot> Haskell pastebin: http://lpaste.net/
14:52:44 <int-e> ccapndave2: how does gen become randomGenerator?
14:52:49 <ccapndave2> I'll paste the code
14:53:17 <rwbarton> since you happen to have this 'wins' variable (which is really a counter 0..iterations) you could use it with mkStdGen
14:53:22 <rwbarton> or whatever it's called
14:53:27 <Cale> tommd: PRNGs are deterministic, and StdGen is no exception.
14:53:32 <ccapndave2> https://gist.github.com/ccapndave/b447844d6aaefecd211e
14:53:41 <tommd> Cale: http://lpaste.net/106314
14:53:51 <kazagistar> ccapndave2: I see. I think you are confused because randomGenerator is immutable...
14:54:02 <tommd> Cale: There is an unsafeperformIO hidden under cprng which destroys equational reasoning for any of its users.
14:54:12 <tommd> well, inlinePerformIO, but you understand.
14:54:14 <Cale> tommd: Isn't ccapndave2 using StdGen?
14:54:18 <int-e> ccapndave2: in any case, it'll be the same one in every iteration, and that was your real question
14:54:23 <tommd> Oh, well I joined late -sorry.
14:54:37 <Cale> tommd: Also, if that library does that, it's broken, and should be fixed.
14:54:45 <rwbarton> anyways that wouldn't stop ghc from doing the optimization
14:54:45 <tommd> Cale: I've made the same comment.
14:55:00 <rwbarton> @type mkStdGen
14:55:01 <lambdabot> Int -> StdGen
14:55:07 <ccapndave2> Can I take an infinite stream of random numbers and pass that to the simulator?
14:55:10 <tommd> Its broken-ness has not motivated the author to unbreak it or the multitude of users (ex: Yesod) to avoid it.
14:55:10 <ccapndave2> Or something
14:55:45 <kazagistar> ccapndave2: sure, but you need to remember the state of the stream either way, using something shaped like a state monad
14:56:19 <ccapndave2> er
14:56:22 * ccapndave2 is lost
14:56:24 <kazagistar> ccapndave2: Randoms -> (Result, Randoms)
14:56:58 <Cale> ccapndave2: If you give a function the same parameters, it ought to always produce the same result
14:57:16 <ccapndave2> Yup
14:57:30 <ccapndave2> That's why I though an infinite stream of random numbers might work
14:57:32 <Cale> ccapndave2: So if you want different results, you need to give different inputs somehow
14:58:05 <ccapndave2> Looking at 'randoms' now, but not sure how to use it
14:58:06 <marteo_> thanks chrisdone rwbarton pjdelport for just earlier
14:58:07 <Cale> and yeah, randomRs gives you an infinite list of pseudorandom values starting from the given seed
14:58:10 <kazagistar> so "randomRs" is getting the same exact parameters each time you call it in the lambda
14:58:16 <ccapndave2> OK
14:58:27 <ccapndave2> So if I pass randomRs into the function and iterate over that?
14:58:30 <marteo_> I do the computation at runtime but once, so that's something.
14:58:50 <Cale> ccapndave2: Yeah, you might chop the infinite list into segments somehow
14:59:01 <ccapndave2> I need it in blocks of 5 anyway
14:59:03 <ccapndave2> hmm
14:59:11 <Cale> ccapndave2: But if you pass the same generator to randomRs, you'll get the same infinite list each time
14:59:22 <ccapndave2> That's ok
14:59:33 <ccapndave2> The simulation will use the infinite list until the end
14:59:35 <ccapndave2> "end"
14:59:36 <ccapndave2> :)
14:59:43 <ccapndave2> i.e. it won't get passed in more than once
14:59:56 <Cale> > map (take 5) . iterate (drop 5) $ randomRs (1,6) (mkStdGen 42)
14:59:57 <lambdabot>  [[6,4,2,5,3],[2,1,6,1,4],[4,4,1,3,3],[2,6,2,4,1],[3,1,1,5,5],[5,1,3,6,1],[5,...
15:00:16 <ccapndave2> And then the compiler will figure out not to optimize it right?
15:00:42 <rwbarton> if you pass different lists, it won't be able to optimize it
15:00:48 <Cale> Well, the constant lifting optimisation won't apply
15:01:40 <kazagistar> ccapndave2: usually yes. Remember that lists, if they are linear types (consumed only in one place, in the order they are created) act as iterators in other languages
15:02:23 <pjdelport> "lists are reified loops"
15:02:45 <pjdelport> "loops are melted lists"
15:03:27 <savanni> Could somebody define the term "reify"?  I've seen it used in many places but never been able to understand it.
15:03:53 <l0cust> savanni: I have never heard that word - googled it
15:03:57 <kazagistar> loops tend to act like a list monad over a state monad... or something?
15:04:08 <l0cust> savanni: take an abstract idea and apply it to something
15:04:27 <rwbarton> literally it means to make into a thing (res), typically "thing" means a value
15:04:42 <tommd> savanni: It is often used to refer to acquiring a value, such as an ADT, representing something that was previously a type or a computation.
15:04:55 <savanni> l0cust: Ohhh... I see.  Now it makes sense to say "reify a class".
15:04:59 <pjdelport> savanni: It just means "to make real / tangible", roughly.
15:05:12 <l0cust> Hey, so, I'm teaching a guy Haskell next week
15:05:13 <pjdelport> savanni: "realized" also works, but that's overloaded.
15:05:14 <savanni> If I were to stick strictly to OO terms, it would be the same as instantiating an objcect from a class.
15:05:20 <l0cust> He's an experienced programmer
15:05:30 <l0cust> How should I go about it
15:05:30 <sarkyniin> are there some exercices that go hand-in-hand with Learn You A Haskell?
15:05:37 <pjdelport> savanni: In this context "lists are frozen loops" also kind-of works.
15:05:47 <Cale> Just like a loop either might happen 0 times (because its precondition isn't met, say), or consists of a single iteration followed by another loop, a list is either empty, or consists of a single element followed by another list.
15:05:51 <l0cust> sarkyniin: lipovača keeps saying he'll add exercises, but he never does
15:05:56 <l0cust> sarkyniin: go to codingbat.com
15:06:01 <Cale> l0cust: You're in touch with him?
15:06:02 <l0cust> sarkyniin: those are good
15:06:08 <savanni> pjdelport: yeah, that really makes sense.  This will also help the next time I dive into trying to understand Typeable.
15:06:10 <sarkyniin> thanks, l0cust
15:06:28 <joelteon> guys, what do you suppose is the most efficient way to collapse multiple spaces into one space in a Text?
15:06:29 <l0cust> Cale: He says it in one of the appendices
15:06:37 <l0cust> sarkyniin: I have solutions on my github page
15:06:44 <pjdelport> joelteon: unwords . words ?
15:06:46 <sarkyniin> l0cust: where's the haskell part?
15:06:50 <sarkyniin> there's no link on the main page.
15:06:51 <l0cust> sarkyniin: The solutions are only in Java and Python
15:07:04 <sarkyniin> oh
15:07:06 <l0cust> sarkyniin: Here you go - https://github.com/pharpend/codingbat-hs
15:07:06 <joelteon> oh, that might be clever yeah
15:07:08 <Cale> l0cust: He pretty much dropped off the face of the Internet a little while after writing the book. He used to hang out in here, but he disappeared.
15:07:17 <l0cust> Cale: I emailed him the other day
15:07:23 <sarkyniin> thanks, l0cust
15:07:25 <l0cust> Cale: So he still exists
15:08:03 <pjdelport> savanni: "reify a class" is probably not quite the same as object instantiation: reify usually implies turning the *same* thing from an intangible to a tangible form.
15:08:09 <hpc> did he follow dons to the G+ hipster dimension?
15:08:30 <MP2E> haha hipster dimension
15:08:30 <pjdelport> savanni: For example, in Java, the reflection API would be a (weak) way of reifying a class at run-time.
15:08:43 <l0cust> Anyway - I'm teaching an experienced programmer Haskell, how should I go about it
15:08:53 <l0cust> I was planning to run through RWH
15:08:56 <pjdelport> (if you're familiar with that)
15:09:19 <ccapndave2> Things are looking up - now my simulation executes for an infinitely long time
15:09:39 <savanni> pjdelport: only tangentially.  I first saw reify in a Clojure context, and I knew that it had to do with interacting with Java.  I think maybe in defining a Java class in Clojure code.
15:10:14 <savanni> pjdelport: but I've since seen it also in descriptions of some of the most abstract Haskell modules.
15:11:12 <pjdelport> savanni: Ah, that sounds about right. Java's class system is not easily accessible or manipulable at runtime, so JVM languages tend to need to jump through many hoops like that.
15:11:46 <rwbarton> there reification is the process of going from a class to a Class object
15:11:48 <pjdelport> savanni: Contrast that with many other OO languages, where classes are implicitly "reified" all the time.
15:12:09 <kazagistar> would the way Typeclasses are turned into datatypes in the GHC compiler count as "reification"?
15:12:30 <pjdelport> kazagistar: Maybe in a certain technical sense, but not in a way that's exposed to you as a programmer.
15:12:42 <MP2E> depends on the programmer, I'd say. For instance: I really liked LYAH despite knowing programming for 10 years previous. It was a little overly verbose at points, but the author managed to get me very excited about all of the theoretical aspects of Haskell, and I feel as though LYAH does a good job of showing "why you should care" about Haskell. On the flip side of the spectrum, RWH is more like a classic programming textbook.. I found it better
15:12:56 <pjdelport> kazagistar: You might say that they're reified as dictionaries in GHC Core, in the context of compilation.
15:13:30 <kazagistar> well, more like records then dictionaries afaik
15:13:46 <pjdelport> kazagistar: You can do the same thing in plain Haskell, though, and reify typeclasses as plain ADTs.
15:13:57 <rwbarton> there is a trick to turn an instance into a value in a user program, too, data Dict c where Dict :: c => Dict c
15:14:21 <rwbarton> you could call that reification
15:14:22 <benzrf> rwbarton: is that supposed to be a ->
15:14:28 <rwbarton> nope!
15:14:30 <pjdelport> kazagistar: Yeah; i just said "dictionaries" because that's how the type class representations are usually referred to.
15:14:38 <rwbarton> Dict :: Constraint -> *
15:14:38 <benzrf> ooh, you can paramterized GADTs with constraints?
15:14:46 <rwbarton> with ConstraintKinds
15:14:51 <benzrf> neat
15:15:26 <benzrf> @let data Dict c where Dict :: c => Dict c
15:15:26 <lambdabot>  Parse failed: Illegal class assertion
15:15:28 <benzrf> lame!
15:15:58 <pjdelport> l0cust: It might be easier to find out what puzzles them, or interests them, and work from there.
15:16:15 <pjdelport> l0cust: Without knowing that, all that can really be recommended is the generic set of tutorials.
15:16:15 <l0cust> pjdelport: my current thoughts are, work through RWH
15:16:28 <l0cust> pjdelport: that's a good plan
15:16:52 <l0cust> pjdelport: I think RWH is the best choice, because I will be there when he doesn't understand
15:17:16 <l0cust> LYAH is great because it's so in-depth and elaborate
15:17:36 <kazagistar> I stopped like halfway though LYAH and just started doing stuff, but I kinda feel like I should go back and finish just for completionism :P
15:18:00 <MP2E> I think of LYAH as the theoretical motivator and RWH as bringing all of that theory back to real life
15:18:33 <benzrf> int-e: im adding a thing
15:18:37 <djahandarie> I honestly don't even know how I learned most of my Haskell. I think it was just by watching people talk in here.
15:18:55 <l0cust> djahandarie: that's a good way
15:18:59 <MP2E> for me it was reading those 2 books referenced above twice and reading every blog and research paper I could possibly find
15:19:00 <pjdelport> l0cust: Cool. Of course, you don't have to choose just one. They can find what works for them; you just have to make pointers available.
15:19:02 <MP2E> still doing it
15:19:47 <pjdelport> l0cust: By far the best way of learning is getting an environment up and running and poking at it, writing some toy programs.
15:20:01 <pjdelport> l0cust: Get them in this channel. :)
15:20:04 <l0cust> pjdelport: for most languages, I would tend to agree
15:20:21 <l0cust> pjdelport: however, with Haskell, I think watching lectures is the best way :)
15:20:31 <pjdelport> l0cust: Well, both.
15:20:37 <kazagistar> I was motivated by translating sweedish to haskell (https://www.youtube.com/watch?v=RqvCNb7fKsg) (10 min) and the simple made easy talk (http://www.infoq.com/presentations/Simple-Made-Easy) (1 hour) and then LYAH being such a fun book
15:20:57 <ccapndave2> Hooray!  It runs :)
15:21:02 <pjdelport> I don't mean poking away at it in isolation; ideally side-by-side with a good textbook and a #haskell window.
15:21:08 <MP2E> I love blog posts
15:21:23 <ccapndave2> its about 4x faster than the Scala version, but would you guys mind taking a peek and seeing if you can see any obvious optimizations?  https://gist.github.com/ccapndave/b447844d6aaefecd211e
15:21:26 <l0cust> MP2E: they all tend to be really out of date, tho
15:21:32 <MP2E> It's true :<
15:23:27 <ajcoppa> l0cust: brent yorgey's course is a good set of intro material + exercises for learning haskell
15:23:36 <ajcoppa> http://www.seas.upenn.edu/~cis194/lectures.html
15:24:40 <l0cust> ajcoppa: that's an interesting way of going at it
15:24:49 <l0cust> ajcoppa: starting with algebraic data types
15:24:58 <l0cust> ajcoppa: but that looks like a good way to go at it
15:25:53 <sarkyniin> l0cust: in your parrotTrouble solution
15:25:55 <sarkyniin> parrotTrouble :: Bool -> Int -> Bool
15:25:55 <sarkyniin> parrotTrouble talking hour = talking && 7>hour && 20<hour
15:26:09 <l0cust> sarkyniin: yeah
15:26:17 <sarkyniin> isn't it "parrotTrouble talking hour = talking && (7>hour || 20<hour)" ?
15:26:24 <sarkyniin> because that looks like it'll always be false
15:26:37 <sarkyniin> if the hour needs to be inferior to 7 but superior to 20
15:26:56 <l0cust> sarkyniin: yes, you're right
15:26:59 <l0cust> I'll fix that
15:27:06 <sarkyniin> :D
15:29:05 <l0cust> sarkyniin: should be fixed
15:30:09 <pjdelport> Something i really miss in Haskell sometimes is chained comparisons, like "7 < hour < 20".
15:30:31 <l0cust> pjdelport: what languages have those?
15:30:36 <rwbarton> I like to write < always (within reason) to make this kind of thing more obvious
15:30:37 <simukis_> l0cust: python.
15:30:52 <l0cust> simukis_: of course
15:31:05 <pjdelport> l0cust: Python, yeah.
15:32:39 <quchen> :t liftA2 (&&) (7 <) (< 20) -- Haskell style!
15:32:40 <lambdabot> (Ord a, Num a) => a -> Bool
15:33:03 <l0cust> Personally, I'm thinking I should fuck off with the yoda expression nonsense, because it isn't needed in Haskell
15:34:04 <rwbarton> I find "7 < hour && hour < 20" a lot easier to read than "7>hour && 20<hour" (and yes I know they aren't the same!)
15:34:31 <rwbarton> "hour < 7 && 20 < hour" is obviously wrong
15:34:43 <rwbarton> since 7 < 20 too
15:35:04 <rwbarton> I probably would never have spotted the error in the original though (well, I'd rewrite it and then spot it I guess)
15:35:24 <ccapndave2> Any advice on how to get profiling to work with cabal?  I did cabal configure --enable-executable-profiling, then cabal install, but now running my app with +RTS -p says 'the flag requires the program to be built with -prof'
15:35:44 <ccapndave2> Trying to compile directly with GHC says 'could not find module Prelude'
15:35:45 <rwbarton> "cabal install" will re-configure
15:35:58 <rwbarton> use cabal build, or cabal install --enable-executable-profiling
15:36:22 <ccapndave2> ah
15:36:30 <ccapndave2> Perhaps you haven't installed the profiling libraries for package `base'?
15:36:34 <ccapndave2> Perhaps not
15:36:45 <ccapndave2> How do I install profiling libraries?
15:38:22 <rwbarton> how did you install ghc?
15:39:27 <ccapndave2> apt-get
15:39:37 <rwbarton> then install 'ghc-prof' also
15:40:01 <ccapndave2> ok
15:40:44 <ccapndave2> ooh
15:40:46 <ccapndave2> Better
15:40:57 <ccapndave2> Now it wants profiling libraries for split-0.2.2
15:41:20 <pjdelport> quchen: Hmm, you could probably make a combinator library for that.
15:41:24 <ccapndave2> ah I figured it out
15:41:28 <ccapndave2> cabal install with -p
15:41:53 <rwbarton> you probably want to edit your .cabal/config so that future packages will be installed with profiling libraries by default
15:42:02 <mietek> Is there any way to squelch the haddock "could not find link destination" warning?
15:42:05 <mietek> -v0 doesn't do it
15:42:31 <ccapndave2> rwbarton Ok
15:44:28 <benzrf> can i put guards on a case expr
15:44:45 <hpc> you can modify any pattern match with guards
15:44:50 <benzrf> oneat
15:45:17 <hpc> > let Nothing | 6 == 5 = Nothing in 5
15:45:18 <lambdabot>  5
15:45:31 <hpc> (how meaningful it is depends on context, obviously)
15:47:28 <ccapndave2> rwbarton hum... this is just telling me that 99% of the time is spent in Main
15:47:55 <rwbarton> oh
15:48:02 <rwbarton> you need to specify -fprof-auto also
15:49:14 <jfischoff> does calling threadDelay cause a yield?
15:49:43 <ccapndave2> rwbarton From cabal install?
15:51:49 <ccapndave2> cabal install --enable-executable-profiling -fprof-auto -fticky
15:53:42 <rwbarton> ccapndave2: as a ghc option
15:53:58 <rwbarton> which I think means passing --ghc-option=-fprof-auto to cabal
15:54:13 <rwbarton> I don't think you want ticky
15:54:19 <ccapndave2> ok
15:55:11 <ccapndave2> ghc -prof -auto-all -fprof-auto -o Main src/Main.hs
15:55:38 <ccapndave2> Then ./Main +RTS -r ?
15:56:16 <rwbarton> oh, what version of ghc are you using? -auto-all became -fprof-auto, you don't need both
15:56:51 <ccapndave2> 7.4.1
15:57:25 <kazagistar> damn, that is like from the stone age
15:57:33 <ccapndave2> Really?
15:57:34 <rwbarton> looks like that is the first version with -fprof-auto
15:57:35 <kazagistar> or like half a year ago
15:57:40 <kazagistar> but still
15:57:41 <ccapndave2> ah :)
15:57:58 <ccapndave2> ghc -prof -fprof-auto -o Main src/Main.hs
15:58:01 <ccapndave2> So this
15:58:17 <rwbarton> should work, note you don't have optimizations by default there (that is a cabal thing)
15:58:18 <ccapndave2> THen ./Main +RTS -r ?
15:58:19 <kazagistar> version 7.4.1... released February 2012
15:58:32 <kazagistar> we are like 2 versions later now
15:58:40 <hexagoxel> i have two installs of ghc (7.8.2 system-wide, 7.6.3 in user directory). i want to use the latter to build a cabal package. tried using "cabal install -w$MYGHCDIR", does not work. is that command wrong in any way?
15:58:47 <rwbarton> I forget what -r is, but if it outputs a .prof file, then sure :)
15:58:53 <rwbarton> I thought it was -p
15:59:05 <ccapndave2> aha
15:59:07 <ccapndave2> -p works
15:59:16 <ccapndave2> Hooray!
15:59:17 <ccapndave2> Profiles :)
15:59:18 <ccapndave2> Thanks
15:59:23 <rwbarton> hexagoxel: use the actual pathname of the compiler itself
15:59:32 <rwbarton> like /blah/blah/ghc-7.6.3
15:59:50 <rwbarton> or you can leave off the -7.6.3 I suppose
16:00:20 <hexagoxel> i tried the full path of the ghc executable, before
16:01:29 <rwbarton> including the 'ghc' part at the end? what was the error?
16:01:44 <ccapndave2> Oh, I guess I had better put the optimizations on for the profiling to be true.  -O2 is it?
16:02:41 <hexagoxel> rwbarton: well it seemed to use the right ghc (used -v to see that)
16:02:55 <hexagoxel> but did not compile "Control.Monad.State does not export State(State)"
16:03:23 <rwbarton> oh, well, that is a version issue of ... transformers i think
16:03:28 <hexagoxel> i am not sure if, in some way, i still use something from 7.8.2
16:03:35 <rwbarton> nope
16:04:08 <benzrf> @tell int-e i added a thing with the PR
16:04:08 <lambdabot> Consider it noted.
16:04:17 <rwbarton> oh not transformers, mtl
16:05:05 <rwbarton> whatever you're building expects an old mtl version where there was a separate State type with a State data constructor
16:05:16 <hexagoxel> rwbarton: hmm ok thanks. will try to maybe add some different constraints
16:09:22 * hackagebot boomerang 1.4.3 - Library for invertible parsing and printing  http://hackage.haskell.org/package/boomerang-1.4.3 (JeremyShaw)
16:09:26 <ccapndave2> OK awesome, my profiling has told me that Data.Map is causing a big slowdown.  Is there some equivalent that has O(1) lookup time?
16:09:53 <geekosaur> um? Map should be pretty fast. any chance you're handing it unevaluated expressions?
16:10:04 <Iceland_jack> ccapndave2: Are you using strictness properly?
16:10:13 <geekosaur> excessive laziness means Map has to evaluate all your keys to use them
16:10:14 <Iceland_jack> Jumping to a new library should not be your first thought
16:10:40 <ccapndave2> https://gist.github.com/ccapndave/b447844d6aaefecd211e
16:10:58 <rwbarton> also keep in mind that if basically all you do is stuff with Maps, then you will see similar profiling results regardless of whether Map is "slow" or "fast" or whether you're using it right or not
16:11:22 <ccapndave2> The map is constructed using Map.fromList, then I look it up with Map.lookup in collectResults
16:11:36 <rwbarton> though that doesn't really appear to be the case here
16:11:45 <rwbarton> can you paste the profiling output too?
16:11:49 <ccapndave2> Sure
16:12:21 <ccapndave2> https://gist.github.com/ccapndave/b447844d6aaefecd211e
16:12:40 <ccapndave2> When I took out the Data.Map lookup line the run time went from about 0.3s to 0.1s
16:13:48 <ccapndave2> Stack overflow tells me that Data.Map is a binary tree, so lookup is O(log n)
16:15:00 <tanmaig_> I'm having problems with parseWith in attoparsec. When does it e execute the monadic function to get more data? And after it fetches more data, does it refresh the whole parsing or continue from where it left off?
16:15:23 <geekosaur> ccapndave2, and what is n?
16:15:25 <rwbarton> ccapndave2: it looks like you could use an Array
16:16:28 <ccapndave2> geekosaur n?
16:16:57 <ccapndave2> rwbarton Can arrays have arbitrary type keys?
16:16:57 <geekosaur> now I wonder if you even understand what big-O actually means in practice
16:17:13 <Fer_> Hello, I am trying to follow this tutorial http://www.seas.upenn.edu/~cis194/lectures/05-type-classes.html But I get this error: http://pastebin.com/iwZ8KQ5h Can anyone help?
16:17:17 <ccapndave2> geekosaur Oh right
16:17:22 <ccapndave2> geekosaur Its tiny
16:17:34 <ccapndave2> geekosaur 30 or something
16:17:41 <ccapndave2> geekosaur But it happens a *lot*
16:17:57 <ccapndave2> Sorry, I thought you mean there was an n in the code somewhere
16:18:18 <rwbarton> ccapndave2: not arbitrary
16:18:26 <ccapndave2> Typed I mean
16:18:31 <ccapndave2> i.e. not just integers
16:18:39 <int-e> @tell benzrf wonderful, thanks!
16:18:39 <lambdabot> Consider it noted.
16:18:52 <geekosaur> and how much is "a lot"? I think you're talking several million occurrences for it to be visible, assuming it's not *also* forcing evaluation of thunks as it goes
16:19:03 <matematikaadit> Fer_: use ghc -XFlexibleInstances
16:19:05 <ccapndave2> geekosaur It will be billions
16:19:10 <rwbarton> your Map only seems to have keys of the form (Just (NormalSymbol x), y), though, so you could represent that by (x, y) and use an Array indexed by (Int,Int)
16:19:13 <ccapndave2> geekosaur This will form part of a genetic algorithm
16:19:38 <ccapndave2> rwbarton In fact there will be different symbols in the future (this is just an easy test)
16:19:50 <Fer_> matematikaadit: is this something that I shouldn't be doing? or is that flag normal?
16:19:51 <rwbarton> oh
16:19:55 <ccapndave2> rwbarton So the things are the Symbol type, the symbol value and the count
16:19:58 <matematikaadit> Fer_: or add "{-# LANGUAGE FlexibleInstances #-}" in your source
16:20:13 <ccapndave2> That's cool though - I could have a key (Symbol, Count)
16:20:16 <ccapndave2> Right?
16:21:14 <rwbarton> for an Array? you would have to write an Ix instance for Symbol
16:22:12 <ccapndave2> oh
16:23:04 <ccapndave2> I guess that wouldn't be too hard
16:23:09 <Makoryu> @pl \f a -> f a >> return a
16:23:09 <lambdabot> (`ap` return) . ((>>) .)
16:23:25 <matematikaadit> Fer_: it's most common language extension, don't sweat using it
16:23:59 <Fer_> matematikaadit: ok thanks
16:25:57 <mietek> Any tasty users?
16:26:48 <ccapndave2> huh maybe this is more complicated than I though
16:26:56 <ccapndave2> I have to define range, index and inRange do I?
16:28:05 <pjdelport> You can derive Ix
16:28:37 <ccapndave2> It doesn't let me for: data Symbol  = WildSymbol Int | NormalSymbol Int deriving (Eq, Show, Ord)
16:29:11 <rwbarton> yeah, not for a sum type
16:29:26 <ccapndave2> These methods are confusing
16:29:30 <pjdelport> Ah, i see: "Such derived instance declarations for the class Ix are only possible for enumerations (i.e. datatypes having only nullary constructors) and single-constructor datatypes, whose constituent types are instances of Ix."
16:29:41 <ccapndave2> I thought there would just be a toIndex function or something
16:29:47 <rwbarton> you will need to know something about what values of Int will be expected
16:31:26 <Para__> Is there a way to go from Rational -> Float, so that I can compare them?
16:31:33 <Para__> I have something that is compiling fine
16:31:37 <Para__> (Even though it shouldn't)
16:31:43 <Para__> or at least I don't think it should
16:31:49 <Para__> so I'm worried of getting an error relating to that
16:32:24 <pjdelport> Para__: How exact do you want to be? Float -> Rational might be better, depending.
16:32:41 <Para__> Uh doesn't have to be too accurate
16:32:49 <Para__> within like 5 or 6 decimal places should be enough
16:33:28 <pjdelport> Para__: You have fromRational and toRational, basically.
16:33:58 <Para__> oh hm
16:34:02 <pjdelport> Para__: http://www.haskell.org/haskellwiki/Converting_numbers
16:34:03 <Para__> okay
16:34:03 <Para__> that should be good
16:34:15 <Para__> thanks
16:35:12 <pjdelport> ccapndave2: range is effectively the "toIndex" method.
16:38:27 <pjdelport> ccapndave2: How do you want the indexing to work for that type?
16:38:40 <ccapndave2> pjdelport I'm trying to figure it out
16:38:43 <ccapndave2> It doesn't really matter
16:39:05 <ccapndave2> NormalSymbol 1 - n, then WildSymbol 1 - n for example
16:39:22 <ccapndave2> I just want things to have a unique index
16:39:32 <rwbarton> keep in mind this n has to be fixed
16:39:41 <ccapndave2> It will be fixed per run
16:39:50 <rwbarton> no, it has to be fixed fixed
16:39:53 <rwbarton> fixed per compile :)
16:39:59 <ccapndave2> ah
16:40:03 <ccapndave2> That's an issue then
16:40:15 <rwbarton> you could also just do your own indexing
16:40:15 <ccapndave2> However, I can guarantee n will never be more than e.g. 100
16:40:48 <pjdelport> ccapndave2: Is there any special relation between the numbers?
16:40:53 <ccapndave2> Nope
16:40:59 <ccapndave2> Totally irrelevant
16:41:09 <ccapndave2> I just want to look up the values in O(1) time
16:41:49 <ccapndave2> i.e. I want to say 'find me the entry for (NormalSymbol 3, 4)' and get it back
16:42:05 <pjdelport> You could define it so that the range (NormalSymbol n, WildSymbol m) means [NormalSymbol n..NormalSymbol m..WildSymbol n..WildSymbol m
16:42:23 <pjdelport> (assuming n <= m)
16:43:01 <rwbarton> oh yes you're right
16:43:07 <rwbarton> like a tuple, effectively
16:43:29 <ccapndave2> What if m < n?
16:43:57 <ccapndave2> Or will range always be called with m > n
16:44:27 * hackagebot web-routes 0.27.6 - Library for maintaining correctness and composability of URLs within an application.  http://hackage.haskell.org/package/web-routes-0.27.6 (JeremyShaw)
16:44:29 * hackagebot web-routes-wai 0.24.0 - Library for maintaining correctness of URLs within an application.  http://hackage.haskell.org/package/web-routes-wai-0.24.0 (JeremyShaw)
16:44:35 <rwbarton> it'll be called with whatever you specified as the bounds when you built the array in question
16:46:59 <pjdelport> ccapndave2: You have to define what it means, but typically with this approach n > m means an empty range.
16:47:11 <pjdelport> > range ((2,2), (4,4))
16:47:13 <lambdabot>  [(2,2),(2,3),(2,4),(3,2),(3,3),(3,4),(4,2),(4,3),(4,4)]
16:47:18 <pjdelport> > range ((2,2), (1,1))
16:47:20 <lambdabot>  []
16:47:25 <ccapndave2> Oh I see
16:47:35 <ccapndave2> Array (1, 10) [...]
16:47:38 <ccapndave2> So the range is 1, 10
16:47:54 <ninja_code> I have a list of length 6n, for some n. Is there a way to generate a list of length n, where each element is a 6-tuple ?
16:48:12 <pjdelport> ccapndave2: The above approach is a lot like having a tuple range where the first part of the tuple is a Bool (i.e., which constructor you have)
16:48:30 <pjdelport> > range ((False,5), (True,10))
16:48:32 <lambdabot>  [(False,5),(False,6),(False,7),(False,8),(False,9),(False,10),(True,5),(True...
16:48:37 <pjdelport> > range ((False,5), (True,7))
16:48:38 <lambdabot>  [(False,5),(False,6),(False,7),(True,5),(True,6),(True,7)]
16:49:06 <ccapndave2> ninja_code chunksOf will turn it into a [[a]]
16:49:10 <kazagistar> Ix is a much better way of doing indexing then in most languages, imho
16:49:21 <ninja_code> http://hackage.haskell.org/package/text-1.1.1.3/docs/Data-Text.html#v:chunksOf
16:49:23 <ninja_code> hoogle says otherwise
16:49:31 <pjdelport> ccapndave2: Does that make sense?
16:49:52 <ccapndave2> Yes, it does
16:49:54 <ninja_code> where do I get a [a] -> [[a]] chunksOf ?
16:50:09 <ccapndave2> Data.List.Split
16:50:15 <kazagistar> it seems mildly ironic to me that haskell has a nicer way of doing mutable arrays then imperative langauges
16:50:36 <kazagistar> @hackage split
16:50:36 <lambdabot> http://hackage.haskell.org/package/split
16:50:53 <kazagistar> ninja_code: ^
16:50:54 <pjdelport> kazagistar: Unlike other languages, Haskell has first-class support for imperative programming. :)
16:51:16 <ninja_code> kazagistar: thanks!
16:53:17 <kazagistar> hmm, maybe I should take an hour or two and document something, that seems productive :P
16:54:28 * hackagebot reform 0.2.5 - reform is an HTML form generation and validation library  http://hackage.haskell.org/package/reform-0.2.5 (JeremyShaw)
16:54:30 * hackagebot reform-hamlet 0.0.3 - Add support for using Hamlet with Reform  http://hackage.haskell.org/package/reform-hamlet-0.0.3 (JeremyShaw)
16:58:41 <ccapndave2> meh
16:58:42 <ccapndave2> I give up
16:59:41 <kazagistar> ccapndave2: hmm? at doing what?
16:59:46 <ccapndave2> Making the Ix
17:00:21 <kazagistar> ah, hmm
17:00:37 <kazagistar> I might have something "in progress to help" if you have just the right problem :P
17:00:53 <kazagistar> * "in progress" to help
17:01:07 <ccapndave2> That would be very useful :)
17:01:19 <kazagistar> well, it depends on the problem, looking through scrollback...
17:01:32 <ccapndave2> data Symbol  = WildSymbol Int | NormalSymbol Int deriving (Eq, Show, Ord)
17:01:49 <ccapndave2> I want to give this an Ix instance so I can use it in the key of an array
17:02:05 <ccapndave2> I understand the concept of the Ix methods, but can't figure out the math or syntax
17:02:31 <kazagistar> ah, ok, sure
17:03:35 <kazagistar> so, we start with the assumption that we have a "minimum" and "maximum" Symbol, right?
17:03:49 <ccapndave2> Right
17:04:01 <kazagistar> hmm, oh wait, I see the issue
17:04:17 <ccapndave2> [NormalSymbol 1, NormalSymbol 2, NormalSymbol 3, WildSymbol 1, WildSymbol 2, WildSymbol 3]
17:04:25 <ccapndave2> Let's say that's the order
17:04:28 <kazagistar> the problem is that you need to define 2 ranges not 1
17:04:30 <ccapndave2> Like the True/false
17:04:34 <ccapndave2> Right
17:04:51 <ccapndave2> And also [NormalSymbol n..NormalSymbol m] doesn't work
17:04:55 <ccapndave2> Something about Enum
17:05:08 <kazagistar> (it should be backwards, Boolean would be defined data Bool = False | True, but yeah)
17:05:32 <ccapndave2> In fact there will be other symbols in the future so it doesn't matter that much
17:05:39 <ccapndave2> Just so long as it indexes
17:05:44 <kazagistar> no so you cannot really define Ix in an elegant way, because it assumes the range is contiguous, kinda
17:05:54 <ccapndave2> Yeah
17:06:02 <ccapndave2> Maybe this is too complicated an optimization :)
17:06:03 <gamegoblin> Just for fun I was hacking on a parser combinator library in C today. Really made me appreciate Haskell.
17:06:20 <ccapndave2> I thought it would be an easy one but I'm not so sure
17:06:46 <kazagistar> ccapndave2: well, one solution is to use 2 arrays, one for the wild and one for normal
17:06:58 <ccapndave2> Oh
17:07:04 <ccapndave2> That's a good idea
17:07:06 <ccapndave2> :)
17:07:09 <pjdelport> ccapndave2: It should be pretty easy.
17:07:21 <Para__> @type dropWhile (<2) . takeWhile
17:07:22 <lambdabot>     Couldn't match type ‘[a1] -> [a1]’ with ‘[a]’
17:07:23 <lambdabot>     Expected type: (a1 -> Bool) -> [a]
17:07:23 <lambdabot>       Actual type: (a1 -> Bool) -> [a1] -> [a1]
17:07:43 <Para__> That doesn't work until I give takeWhile its first argument
17:07:47 <Para__> wait
17:07:52 <Para__> I might know whats wrong
17:07:56 <kazagistar> ccapndave2: another would be to construct an isomorphism to a type like Symbol { isWild :: Bool, data :: Int }, and store that instead
17:08:28 <ccapndave2> That would be tricky as it won't scale when there are other symbols
17:08:46 <kazagistar> sure it would
17:09:06 <Para__> @type dropWhile (< 2) .) . takeWhile
17:09:07 <lambdabot> parse error on input ‘)’
17:09:13 <Para__> @type (dropWhile (< 2) .) . takeWhile
17:09:14 <lambdabot> (Ord a, Num a) => (a -> Bool) -> [a] -> [a]
17:09:30 * hackagebot reform-happstack 0.2.3 - Happstack support for reform.  http://hackage.haskell.org/package/reform-happstack-0.2.3 (JeremyShaw)
17:10:19 <kazagistar> ccapndave2: well, you could just have it be { data Symbol  = Symbol SymType Int derving (Ix...); data SymType = Normal | Wild deriving (Ix...) }
17:10:56 <kazagistar> ccapndave2: but yeah, it fails to scale if the things you are storing dont have a "box" shape
17:12:03 <ccapndave2> Not to worry
17:12:09 <ccapndave2> I will try and optimize something else for the moment
17:14:04 <ccapndave2> map (\(r, l) -> take visibleSymbolsCount . drop r . cycle $ l) list
17:14:06 <ccapndave2> This is very slow
17:14:10 <ccapndave2> I will work on that instead :)
17:14:11 <mietek> Is there a way to get color output from tasty with  cabal test --show-details=streaming?
17:14:31 * hackagebot happstack-server 7.3.7 - Web related tools and services.  http://hackage.haskell.org/package/happstack-server-7.3.7 (JeremyShaw)
17:14:33 * hackagebot happstack-server-tls 7.1.1 - extend happstack-server with https:// support (TLS/SSL)  http://hackage.haskell.org/package/happstack-server-tls-7.1.1 (JeremyShaw)
17:18:48 <quchen> Streaming? Interesting, --help doesn't mention that
17:19:05 <enthropy> cabal is full of undocumented goodies
17:19:28 <quchen> That's one way to call bad docs
17:19:28 <enthropy> also, I have a question about rearranging a recursion to reuse more values http://lpaste.net/106319
17:19:32 * hackagebot happstack-clientsession 7.2.7 - client-side session data  http://hackage.haskell.org/package/happstack-clientsession-7.2.7 (JeremyShaw)
17:19:33 <mietek> quchen: https://github.com/haskell/cabal/pull/1727
17:19:34 * hackagebot happstack-lite 7.3.4 - Happstack minus the useless stuff  http://hackage.haskell.org/package/happstack-lite-7.3.4 (JeremyShaw)
17:19:36 * hackagebot happstack-foundation 0.5.5 - Glue code for using Happstack with acid-state, web-routes, reform, and HSP  http://hackage.haskell.org/package/happstack-foundation-0.5.5 (JeremyShaw)
17:19:38 * hackagebot hsx-jmacro 7.3.5 - hsp+jmacro support  http://hackage.haskell.org/package/hsx-jmacro-7.3.5 (JeremyShaw)
17:20:05 <mietek> Is it normal for  cabal haddock  not to look for  hscolour  in  .cabal-sandbox/bin ?
17:20:41 <enthropy> sounds abnormal if .cabal-sandbox/bin is in $PATH
17:20:48 <mietek> It's not in $PATH
17:20:53 <geekosaur> then it should be
17:20:57 <mietek> Darn
17:21:40 <faul_sname> So I was playing around in GHCI, and I found that while I can do (foldl (.) id (replicate 3 (+3))) or something of the sort, and it has the type signature (Num c => c -> c), as expected. However, if I try the same thing with map instead of (+5), it tells me that it can
17:21:41 <rwbarton> enthropy: probably with a list of pairs (p_n, integral of p_n) or similar
17:21:51 <faul_sname> t construct an infinite type.
17:22:22 <Para__> :t (+3)
17:22:23 <lambdabot> Num a => a -> a
17:22:25 <Para__> :t (map)
17:22:26 <lambdabot> (a -> b) -> [a] -> [b]
17:22:44 <rwbarton> enthropy: wait maybe I don't understand
17:22:47 <faul_sname> I'm new at Haskell, and am a bit confused. I expected that to give me (id . map . map . map)
17:23:21 <faul_sname> With the type signature of ((a ->b) -> [[[a]]] -> [[[b]]])
17:23:31 <Para__> :t replicate
17:23:32 <lambdabot> Int -> a -> [a]
17:23:33 <quchen> faul_sname: When you chain (+3) n-times with itself, you get a composite function of the same type out again.
17:23:45 <quchen> On the other hand, composing map with itself results in a new function with a different type.
17:23:48 <quchen> :t (+3)
17:23:49 <lambdabot> Num a => a -> a
17:23:54 <quchen> :t (+3) . (+3)
17:23:54 <lambdabot> Num c => c -> c
17:23:59 <coppro> faul_sname: map is a function which produces a function
17:24:00 <quchen> Now compare to map,
17:24:01 <quchen> :t map
17:24:02 <lambdabot> (a -> b) -> [a] -> [b]
17:24:03 <quchen> :t map . map
17:24:04 <lambdabot> (a -> b) -> [[a]] -> [[b]]
17:24:09 <coppro> (+3) is a function which produces a single value
17:24:11 <enthropy> b_i is the integral of b_{i-1} plus some constant to make b_i integrated between 0 and 1 equal 0
17:24:33 * hackagebot happstack-hstringtemplate 7.0.4 - Support for using HStringTemplate in Happstack  http://hackage.haskell.org/package/happstack-hstringtemplate-7.0.4 (JeremyShaw)
17:24:34 * hackagebot happstack-hsp 7.3.1 - Support for using HSP templates in Happstack  http://hackage.haskell.org/package/happstack-hsp-7.3.1 (JeremyShaw)
17:24:37 <coppro> faul_sname: As a result, the type system ends up trying to unify a function whose result type is its own type, this is infinite
17:24:50 <quchen> faul_sname: The reason it's not working with "map" is that the type of "mapNTimes n" would depend on "n", which is something Haskell cannot do: types cannot depend on values.
17:24:59 <faul_sname> Oh, I see.
17:25:07 <quchen> (That's what dependent types do, which is something Haskell does not support.)
17:25:27 <quchen> (Some GHC extensions let you venture a bit into dependently typed territory, but that's not beginner stuff.)
17:25:44 <faul_sname> foldl (.) id :: [c -> c] -> c -> c
17:25:46 <faul_sname> I see.
17:25:56 <mietek> There's no --with-hscolour option to cabal haddock...
17:26:38 <mietek> And yet, there is one to cabal install
17:26:51 <mietek> Although cabal install doesn't need it, because it's smart enough to find hscolour in its sandbox
17:26:58 <mietek> While cabal haddock is not.
17:27:04 <mietek> geekosaur: argh
17:27:07 <quchen> faul_sname: Chaining multiple functions of type "something -> something" together is what the Endo Monoid is good for, by the way. Might be worth a look :-)
17:27:53 <quchen> (appEndo . mconcat . replicate 10 . Endo) (+3) 0
17:28:04 <geekosaur> I think the problem there is that cabal can only offer options that the program does
17:28:27 <geekosaur> hm, maybe I am confused
17:28:29 <mietek> huh?
17:28:33 <mietek> No, cabal is confused
17:28:34 <mietek> ;)
17:28:53 <mietek> "internal error when
17:28:54 <mietek> calculating transative package dependencies.
17:28:56 <mietek> "
17:28:56 <Para__> agh, I hate it when I spend like 30 minutes looking for an error and the error is that I missed a $
17:29:06 <geekosaur> what I'm seeing is that *haddock* has no option to specify where hscolour lives
17:34:34 * hackagebot happstack-authenticate 0.10.13 - Happstack Authentication Library  http://hackage.haskell.org/package/happstack-authenticate-0.10.13 (JeremyShaw)
17:34:35 * hackagebot happstack 7.0.2 - The haskell application server stack + code generation  http://hackage.haskell.org/package/happstack-7.0.2 (JeremyShaw)
17:39:38 <rwbarton> enthropy: yeah so how about storing both the polynomial and its derivative
17:39:45 <rwbarton> *integral
17:40:52 <rwbarton> f (p, ip) = case polyIntegral ip of ip2 -> let c = constPoly (evalPoly ip2 0 - evalPoly ip2 1 in (c `addPoly` ip, polyIntegral c `addPoly` ip2)
17:41:36 <rwbarton> of course you can inline that polyIntegral . constPoly to a linear polynomial, however you write that
17:45:39 <enthropy> rwbarton: yep that transformation works
17:46:38 <enthropy> still there are two integrals, but "polyIntegral . constPoly" ought to be cheaper than integrating the whole polynomial
17:46:49 <rwbarton> right
17:49:55 <pjdelport> ccapndave2: Still around?
17:49:59 <ccapndave2> heya
17:50:05 <ccapndave2> Yup
17:50:18 <ccapndave2> Should really be in bed, but got a bit obsessed with all this FP nonsense
17:51:00 <pjdelport> ccapndave2: There's actually a trivially cheap way to define the Ix instance: just piggy-back on the instance for tuples. :)
17:52:03 <kazagistar> pjdelport: that works if your thing is a product type, but not as well for sumtypes
17:52:17 <ccapndave2> How do I piggy back on another instance?
17:53:02 <kazagistar> if you had something like Mytype Int Int, then ix would be defined exactly like (Int, Int)
17:53:22 <ccapndave2> Ok
17:53:27 <ccapndave2> How does the MyType get stored?
17:53:47 <kazagistar> and you could just basically alias one as the other
17:54:28 <pjdelport> ccapndave2: http://lpaste.net/106321
17:54:28 <kazagistar> I meant data Mytype = Mytype Int Int
17:54:50 <pjdelport> ccapndave2: The bijection is a bit manual, but that's one way to do it.
17:56:05 <kazagistar> right, thats what I meant when I said (earlier) to define an isomorphism, but you said it more elegantly with example code now :P
17:56:16 <ccapndave2> I see
17:56:29 <ccapndave2> Cool :)
17:56:32 <ccapndave2> That's great
17:56:35 <ccapndave2> Thankyou very much!
17:57:37 <pjdelport> ccapndave2: The conversion back and forth might carry some constant overhead when indexing, but GHC might be smart enough to inline everything (i'm not sure).
17:57:38 <kazagistar> its probably optimal if you just use something structured like that tuple to store it anyways, but transforming will do
17:58:07 <ccapndave2> Awesome
17:58:16 <ccapndave2> Its definitely worth it
17:58:32 <ccapndave2> My benchmarks show a drop from 0.6s to 0.15s when I take out Data.Map
17:59:33 <pjdelport> ccapndave2: Note that also lets you use bounds like ((WildSymbol 1),(WildSymbol 10)) to get an Array of just 10 elements, indexed only by WildSymbols (NormalSymbol will throw an index error).
18:01:35 <pjdelport> ccapndave2: You can keep an eye on the index method when profiling, if you suspect it might be slow: the others probably won't be critical in tight loops.
18:01:35 <zRecursive> How to calculate `(expt 2 #c(1 3)) => #C(-0.97398883S0 1.7468102S0)` in haskell ?
18:02:06 <pjdelport> ccapndave2: If it's slow, you can manually inline it to match the tuple instance's definition. (Yay for equational reasoning!)
18:02:15 <ccapndave2> Ok
18:02:28 <abstract-alf> hey all
18:02:40 <ccapndave2> My brain is working at minimum efficiency so I am copying all this into a document to think about properly tomorrow :)
18:02:42 <kazagistar> zRecursive: what is the code on the left? its not quite clear to me
18:03:04 <zRecursive> kazagistar: (expt 2 #c(1 3))
18:03:23 <kazagistar> ...which does...?
18:03:29 <zRecursive> means 2^(1+3i)
18:04:07 <jonashw> howdy
18:04:30 <zRecursive> jonashw: howdy =
18:04:32 <zRecursive> ?
18:04:41 <jonashw> (it's a greeting)
18:04:57 <zRecursive> means hi ?
18:05:02 <jonashw> http://en.wikipedia.org/wiki/Howdy
18:05:27 <kazagistar> hmm
18:05:34 <jonashw> http://cdn.hark.com/images/000/006/085/6085/original.0
18:05:49 <Aetherspawn-> gday m8
18:06:43 <zRecursive> It seems not convenient to manipulate Complex in haskell ?
18:07:11 <zRecursive> how to calculate 2^(1+3i) ?
18:07:14 <jonashw> so, I've got a few haskell applications now... seeing patterns emerge and now I want to refactor some code into a few libraries to share amongst my apps.  Do I use cabal?
18:07:33 <rwbarton> > 2 ** (1 :+ 3)
18:07:35 <lambdabot>  (-0.9739888359315625) :+ 1.746810163549743
18:07:49 <zRecursive> :t (:+)
18:07:50 <lambdabot> a -> a -> Complex a
18:07:55 <jonashw> :t (**)
18:07:56 <lambdabot> Floating a => a -> a -> a
18:08:15 <kazagistar> damn
18:08:31 <zRecursive> where is the definition of (:+) ?
18:08:33 <kazagistar> I just finished type tetrising it, and someone beat me to it with preexisitng knowlege
18:08:44 <enthropy> @src Complex
18:08:44 <lambdabot> data (RealFloat a) => Complex a = !a :+ !a
18:09:14 <Yuriy`> zRecursive: you should read the docs for Data.Complex
18:09:23 <zRecursive> great ! thanks
18:09:28 <kazagistar> zRecursive: its is the type constructor for Complex, but its not in the documentation :/
18:09:41 <kazagistar> owait it is
18:09:45 <kazagistar> I am just blind as a bat
18:11:53 <kazagistar> hmm, the existance of (^), (^^), and (**) seems a little awkward
18:13:43 <coppro> it is
18:14:37 * hackagebot STL 0.2 - STL 3D geometry format parsing and pretty-printing  http://hackage.haskell.org/package/STL-0.2 (bergey)
18:17:20 <kazagistar> I am sure someone has their own numeric stack out there somewhere that fixes these sort of things with a crazy amount of mathy typeclasses
18:17:28 <kazagistar> although haskell already does that
18:18:10 <coppro> nah
18:27:07 <jle`> :t (^^)
18:27:08 <lambdabot> (Integral b, Fractional a) => a -> b -> a
18:27:24 <jle`> kazagistar: they have different semantics
18:28:01 <jle`> in some cases x ^ y should not be equal to x ** y
18:28:33 <kazagistar> hmm, which cases?
18:28:52 <kazagistar> or for which instances or whatever
18:30:22 <jle`> well hm maybe i'm breaking a Num law or something >_>  but in my uncertain library https://github.com/mstksg/uncertain, it is important to make the distinction between x * x * x and "x cubed"
18:30:51 <jle`> because x * x * x represents three distinct independent identically distributed samples of a random variable
18:30:52 <l0cust> So, question
18:31:04 <jle`> and x**3 represents one sample, cubed
18:31:06 <l0cust> Is darcs completely dead nowadays?
18:31:13 <l0cust> I don't see anyone using it
18:31:26 <jle`> l0cust: mm_freak/ertes/author of netwire uses it at least >_>
18:32:06 <jle`> x*x*x is x^3
18:32:43 <jle`> also i guess (^) is also useful the same way div and quot are useful
18:33:06 <jle`> why have div and quot when you can just have (/) and floor/trunc? :P
18:33:11 <jle`> (and fromIntegral)
18:33:36 <jle`> > 7 ^ 3
18:33:37 <lambdabot>  343
18:33:42 <jle`> > (fromIntegral 7) ^ 3
18:33:44 <lambdabot>  343
18:33:46 <jle`> er
18:33:51 <jle`> > (fromIntegral 7) ** 3
18:33:53 <lambdabot>  343.0
18:37:30 <enthropy> jle`: what's your take on giving the individual distributions being sampled from names?
18:38:25 <jle`> enthropy: oh i never read what you wrote earlier actually. i'm going to scroll back and get to it
18:38:36 <jle`> enthropy: also i do'nt understand your question
18:38:57 <enthropy> you can scroll back to a couple weeks ago?
18:39:31 <enthropy> I have a dubious implementation of http://en.wikipedia.org/wiki/Fourier_amplitude_sensitivity_testing
18:39:44 <enthropy> it would be nice to have one notation to specify "uncertain problem"
18:40:24 <enthropy> then get results calculated with whichever method you pick (monte carlo, quasi monte carlo, linearization)
18:44:44 <vervic> Hi, how can i get the concrete type of an recursive algebraic datatype (like a ternary tree) within ghci or vim?
18:44:50 <labancle> does anyone know a good library for converting an absolute filepath to a relative one that works when the relative path is above the base path?
18:49:02 <l0cust> fuck it, I'll go to offtopic
18:49:13 <l0cust> oh oops wrong channel.
18:49:15 <l0cust> Sorry!
18:49:32 <jle`> enthropy: yeah, i have private logging on, but don't tell anyone :)
18:51:01 <jle`> so basically have some abstracted representation of a probability distribution?
18:51:08 <kazagistar> labancle: System.FilePath does not work? hmm, maybe they dont have that exact functionality...
18:51:15 <jle`> and be able to compose them, manipulate them etc.
18:51:26 <jle`> and then "running"/sampling them with a given method?
18:51:30 <napping> Was there a lens or comonad or something like (a , b -
18:51:33 <napping> (a, b -> c)?
18:51:54 <napping> I made something like that for a kind of two-pass traversal
18:51:59 <edwardk> napping: that is the indexed store comonad
18:52:23 <napping> I'm gathering constraints on variables, and building up a term with final sorts
18:52:29 <edwardk> :t Control.Lens.Internal.Context.Context
18:52:30 <lambdabot> (b -> t) -> a -> Context a b t
18:53:04 <edwardk> we use it to do two pass things in lens as well
18:53:06 <edwardk> that and
18:53:13 <edwardk> :t Control.Lens.Internal.Bazaar.Bazaar
18:53:14 <lambdabot> (forall (f :: * -> *). Applicative f => p a (f b) -> f t) -> Bazaar p a b t
18:53:17 <edwardk> its big brother
18:53:18 <edwardk> =)
18:53:36 <enthropy> jle`: yeah
18:53:40 <napping> I changed a function that was a bit hardcoded in some circular programming stuff to just take a "sort lookup" function in an applicative
18:53:43 <napping> I was thinking I
18:54:00 <napping> I was thinking I would make two passes, working first in Const <info> and then in a reader
18:54:10 <napping> but one call in something like that Context works out
18:55:43 <napping> Is that runContext provided anywhere?
18:55:55 <jle`> enthropy: that'd be nice.  have you started on implementation?
18:56:52 <napping> Ah, you don't have the Monoid a => Applicative (Context a b) I want
18:57:14 <Fuuzetsu> this is not the Monoid a => Applicative (Context a b) you're looking for
18:58:46 <kazagistar> labancle: yeah, tested it and it fails, hmm
19:03:59 <enthropy> jle`: there's a older and newer version in http://lpaste.net/105478, http://hackage.haskell.org/package/ipopt-hs-0.4.2.0/docs/Ipopt-AnyRF.html is pretty much the same problem (done badly in that case because it doesn't let you add new functions)
19:05:19 <jle`> enthropy: thanks, i'll check it out
19:07:08 <napping> edwardk: supplying my own version of runContext got the "knot tying" bit of my type checker down to one line
19:12:43 <SparkySparkyBoom> hi there
19:12:51 <SparkySparkyBoom> how would i pattern match on two values?
19:13:34 <groovy2shoes> SparkySparkyBoom: put them in a tuple: (value1, value2)
19:13:34 <jle`> SparkySparkyBoom: tuple them up
19:13:38 <groovy2shoes> then match on the tuple
19:13:45 <SparkySparkyBoom> ty
19:14:05 <jle`> matching on a grouple? use a tuple!
19:14:10 <jle`> - jle`
19:14:42 <SparkySparkyBoom> XD
19:19:45 * hackagebot web-routes-hsp 0.24.4 - Adds XMLGenerator instance for RouteT monad  http://hackage.haskell.org/package/web-routes-hsp-0.24.4 (JeremyShaw)
19:20:26 <Aetherspawn-> cough
19:20:30 <Aetherspawn-> @ kazagistar and others
19:21:05 <Aetherspawn-> https://hackage.haskell.org/package/numeric-prelude
19:21:12 <Aetherspawn-> also @carter has one too I think
19:30:08 <FlashingFire> Hi. I'm trying to use the music-suite cabal package from Eclipse on Windows. This is my first experience with haskell. How do I put the dependency in there so that i can avoid: Could not find module `Music.Prelude.Basic'
19:30:36 <FlashingFire> EclipseFP created a skeleton project with Setup.hs but I'm struggling with the cabal docs.
19:30:46 <napping> I rarely use any of those, but there should be some kind of project/cabal view you can add the dependency
19:31:12 <FlashingFire> if I were using a plain text editor, would I edit Setup.hs?
19:31:32 <flaggy> Hey. I'm trying to work with quickCheck. I made several properties and I'm trying to run them all with this: mapM_ quickCheck [prop_idempontent, prop_minimum, prop_ordered, prop_permutation, prop_sort_model]. That doesn't work because I have some props returning Bool and others Property. How should I do it?
19:32:12 <napping> Unless you misspelled the module name, the problem is setting up the project so it includes the package
19:32:40 <dmwit> flaggy: I think there's a bit of TH in quickcheck that will run all the values named "prop_*" in a module.
19:32:49 <FlashingFire> yes, that is the problem. how would you solve it, regardless of eclipse?
19:33:22 <dmwit> flaggy: Documentation is here: http://hackage.haskell.org/package/QuickCheck-2.7.5/docs/Test-QuickCheck-All.html
19:33:49 <FlashingFire> the music-suite docs go straight from "cabal install music-suite" to "import Music.Prelude.Basic" without anything about Setup.hs or whatever
19:34:09 <napping> I think eclipse has a nice interface, but in a .cabal file you would add it to build-depends:
19:34:35 <napping> If you were just using ghci/ghc directly, then you could import it after cabal install
19:35:07 <napping> but building with a cabal project description compiles with only the packages you explicitly request, to keep builds halfway under control, so you have to add it somewhere
19:35:26 <napping> I'll see if I have EclipseFP installed and working
19:35:51 <FlashingFire> cool
19:38:00 <FlashingFire> aha... I think I see... opening Stuff.cabal gives a GUI thingy
19:38:23 <SparkySparkyBoom> i found eclipsefp to be quite laggy
19:38:47 <SparkySparkyBoom> so i just use emacs
19:39:00 <napping> Yeah, the Executables/Library tabs have dependency lists
19:39:18 <SparkySparkyBoom> anyone have any performance tips for it?
19:39:29 <Lutin^> FlashingFire: Most of the time you won't need to change Setup.hs
19:43:38 <FlashingFire> wierd... music-articulation and such show up in the list, but not music-suite itself
19:44:09 <napping> Did you add anything?
19:44:17 <napping> It starts out empty if it's a fresh project
19:44:35 <napping> If you edited the .cabal file by hand maybe some formatting is wrong
19:44:48 * hackagebot vinyl-gl 0.1.3.1 - Utilities for working with OpenGL's GLSL shading language and vinyl records.  http://hackage.haskell.org/package/vinyl-gl-0.1.3.1 (AnthonyCowley)
19:44:50 * hackagebot vinyl-gl 0.1.3.2 - Utilities for working with OpenGL's GLSL shading language and vinyl records.  http://hackage.haskell.org/package/vinyl-gl-0.1.3.2 (AnthonyCowley)
19:47:11 <FlashingFire> well, editing by hand lets me add music-suite...
19:47:33 <FlashingFire> this looks bad:
19:47:34 <FlashingFire> music-suite-1.7.0.1 depends on music-score-1.7 which failed to install.
19:47:34 <FlashingFire> unix-2.7.0.1 failed during the configure step. The exception was:
19:47:34 <FlashingFire> ExitFailure 1
19:47:59 <FlashingFire> I'm on windows. not supported?
19:48:50 <SparkySparkyBoom> is map the only way to apply a function that returns IO () to a list?
19:49:38 <napping> probably depends on a
19:49:40 <SparkySparkyBoom> scala has a foreach function for collections
19:49:43 <napping> C library you don't have installed
19:49:49 * hackagebot quickcheck-webdriver 0.1.0.6 - Utilities for using WebDriver with QuickCheck  http://hackage.haskell.org/package/quickcheck-webdriver-0.1.0.6 (christianpbrink)
19:50:02 <SparkySparkyBoom> it returns unit
19:50:41 <napping> mapM_?
19:50:53 <Iceland_jack> @ty mapM_
19:50:54 <lambdabot> Monad m => (a -> m b) -> [a] -> m ()
19:51:02 <Iceland_jack> :t mapM_ print [1..]
19:51:03 <lambdabot> IO ()
19:51:23 <dibblego> why does the QuickCheck paper point out that reverse [] == [] when that is given by parametricity?
19:52:57 <enthropy> maybe they wanted to rule out "reverse [] = undefined"
19:53:01 <phaethon_> Can anyone point me at a library for webcam access?
19:54:00 <enthropy> phaethon_: https://github.com/acowley/HOpenCV/blob/master/src/Examples/VideoFunhouse/VideoFunhouse.hs
19:54:15 <phaethon_> enthropy: Thank you
19:54:54 <rwbarton> dibblego: probably because it is part of what it means to be an antihomomorphism
19:54:55 <enthropy> it might be in sinelaw's HOpenCV too
20:01:13 <SparkySparkyBoom> thanks Iceland_jack
20:04:19 <robbie> Hi, is it possible to programatically create default values for arbitrary record types? Assume that default values for base types are known (eg. form data-default).
20:12:08 <merijn> robbie: Yeah, but generally it doesn't seem that useful over just manually specifying a default value for a record type
20:12:22 <dpwright> I've been implementing some basic type inference, based on the paper "Typing Haskell in Haskell" (http://web.cecs.pdx.edu/~mpj/thih/thih.pdf)
20:12:54 <dpwright> That paper, and others I've seen, define a Subst type which is a simple lookup, [(TyVar, Type)]
20:14:05 <dpwright> it also defines a function (@@) which applies the substitutions in the first parameter to all types in the second, and then appends the first parameter
20:14:14 <merijn> dpwright: A bit of an orthogonal remark, but if you wanna learn about type systems (and implement your own) getting a copy of TaPL may be a good investment
20:14:39 <dpwright> it looks like this: [(v, apply s1 t) | (v, t) <- s2] ++ s1
20:14:41 <djahandarie> There's also a translation into Japanese.
20:15:32 <dpwright> merijn: Thanks, I haven't picked that up yet, though I did buy PFPL and found it... a bit over my head at the moment :-/
20:16:21 <dpwright> djahandarie: Good to know, my native language is actually English but I'm just trying to start up a functional programming group here in kansai so that might be worth getting a hold of as well
20:16:30 <bms1> I'm using a list comprehension to represent non-deterministic computations. What's the best way to incorporate a Maybe value (as a possibly failing path)? Right now, I just convert it to a list with "maybe [] (:[])"
20:16:30 <dpwright> anyway, onto my question...
20:16:33 <djahandarie> Ah, alright.
20:17:27 <enthropy> robbie: http://hackage.haskell.org/package/template-default-0.1.1 or http://hackage.haskell.org/package/data-default-generics
20:17:36 <merijn> dpwright: TaPL is relatively easy and actually comes with OCaml implementations of all the typing systems described, so that might be easy (if you know haskell, reading the ocaml code should be relatively trivial), but anyway back to your question
20:17:36 <dpwright> at some point I squinted at (@@) and thought, I'm combining substitutions here, I have an empty substitution, this almost sounds like a job for monoid!
20:18:06 <merijn> bms1: First off
20:18:10 <merijn> :t listToMaybe
20:18:11 <lambdabot> [a] -> Maybe a
20:18:12 <merijn> eh
20:18:15 <merijn> I meant the other
20:18:30 <merijn> My reading is broken >.<
20:18:33 <bms1> maybeToList = maybe [] (:[]), right?
20:18:35 <merijn> catMaybes
20:18:47 <dpwright> so I made a newtype for it and implemented mappend as (@@).  But then I looked at it again and remembered that it's a list anyway, and mappend for lists is (++)
20:18:57 <robbie> I know that it is possible to define a default value, but the records I am working with (if viewed as a tree) have many nodes. Making default values would require a large amount of boilerplate.
20:19:05 <merijn> bms1: Well, you could newtype list and overwrite >>= as "catMaybes . concatMap", I'm not sure that obeys the laws, though
20:20:17 <dpwright> obviously (++) is not the functionality I want in this case, so maybe it makes sense to override Monoid for Subst specifically, but I just thought I'd ask -- am I thinking along the right lines, or is my attempt to write mappend like (@@) and then replace all my (@@) calls with (<>) misguided?
20:20:22 <DanC_> I wonder why music-preludes depends on unix. `grep -ir unix .` shows nothing
20:20:23 <enthropy> so long as the boilerplate looks something like "instance Default C where def = C def def def def", probably either of those packages will work
20:20:38 <dpwright> I mean, it seems to work.  I'm not 100% confident about the associativity, but... looks ok?
20:20:55 <bms1> merijn: Thanks! I'm interleaving lists and maybes. But I think it will be best to work with lists and use maybeToList; that's a lot cleaner than "maybe [] (:[])"
20:21:00 <enthropy> DanC_: I'd look for modules like System.*
20:21:11 <enthropy> imports of those modules that is
20:21:35 <DanC_> ah. right.
20:21:46 <DanC_> meanwhile...
20:21:47 <DanC_> src/Music/Time/Behavior.hs:227:12:
20:21:47 <DanC_>     Ambiguous occurrence `tabulated'
20:21:48 <DanC_> sigh.
20:21:56 <merijn> bms1: catMaybes will at least easily let you filter out Nothing values from your list
20:22:02 <jonashw> my mind is melting on state monad right now
20:22:18 <jonashw> :t get
20:22:19 <lambdabot> MonadState s m => m s
20:22:20 <merijn> jonashw: The best explanation is to try and implement it yourself :)
20:22:37 <merijn> jonashw: Ignore that type, that type is part of mtl, you want the one from transformers
20:22:38 <kazagistar> > foldMap (maybe [] (:[])) [Just 3, Nothing, Just 4]
20:22:39 <jonashw> merijn, yeah, I know what the alternative is...
20:22:39 <lambdabot>  [3,4]
20:23:35 <jonashw> merijn, I know that the alternative to the state monad is carrying your state manually.. returning it from functions in a tuple with another result
20:23:52 <DanC_> has anybody installed music-suite lately?
20:24:00 <kazagistar> an alternative is an applicative with a zero, right? :P
20:24:02 <jonashw> my mind is melting now because of state monad in do notation...  the state is HIDDEN!
20:24:30 <DanC_> the monad context is kinda always hidden
20:24:31 <merijn> jonashw: That's not an alternative for the state monad, that's exactly what the state monad does :p
20:25:17 <jonashw> merijn, maybe I'm missing something but the return type of my Stateful functions has no sign of a tuple
20:25:59 <enthropy> State is a newtype that hides that tuple
20:26:02 <jonashw> I guess you're saying that the same thing is happening as before... just that the State monad is doing it instead of doing it myself
20:26:08 <merijn> jonashw: "newtype State s a = State (s -> (a, s))"
20:26:27 <merijn> jonashw: You can see this in:
20:26:30 <merijn> :t runState
20:26:31 <lambdabot> State s a -> s -> (a, s)
20:26:39 <jonashw> ah, right
20:26:47 <merijn> That takes a "State s a" and turns it back into "s -> (a, s)"
20:26:49 <jonashw> so that stuff is obscured when using the state monad
20:27:02 <dpwright> ...having typed that out now I think I've realised I didn't really have a question, since I've done a thing and it works, and.... that's it :-P
20:27:47 <merijn> jonashw: For fun, try reimplementing the state monad instances of Functor/Applicative/Monad yourself, given: "newtype State s a = State (s -> (a, s))", "put :: s -> State s ()", "get :: State s s"
20:28:03 <dpwright> it seems to happen quite often with Haskell that even though I've done something and it works, I feel like I want to confirm whether doing that thing is "ok", since I haven't done it before and I don't have such a good sense of what is "good haskell" yet.  Maybe that's it.
20:28:09 <merijn> jonashw: If you get stuck, trying substituting the "State s a" bits of signatures with the "s -> (a, s)" type
20:28:58 <jonashw> ah, the type trickery just clicked
20:29:19 <merijn> jonashw: The nice thing about State is that it's really hard to implement it wrong and still have it typecheck :)
20:29:43 <kazagistar> dpwright: in my experience, my haskell is almost certainly never crazy and abstract enough yet to qualify as good haskell compered to someone :P
20:30:29 <jonashw> Int -> State M.IntMap Int    ===     Int -> (M.IntMap Int) -> (Int, M.IntMap Int)
20:30:31 <jonashw> right?
20:30:44 <jonashw> ah
20:30:44 <jonashw> no
20:30:50 <jonashw> Int -> State (M.IntMap Int) Int    ===     Int -> (M.IntMap Int) -> (Int, M.IntMap Int)
20:31:04 <DanC_> ah... I see this ambiguity problem is fixed on github but not released...
20:31:05 <merijn> jonashw: Right
20:31:30 <jonashw> furthermore...
20:31:33 <kazagistar> the parens around the second parameter are not neccessary, fyi
20:31:37 <merijn> jonashw: Now, if you understand how do notation desugars to >>= and >>, you should realise how it actually works
20:31:56 <jonashw> Int -> (M.IntMap Int) -> (Int, M.IntMap Int)      ===   Int -> (M.IntMap Int -> (Int, M.IntMap Int))
20:32:08 <dpwright> I tend to find I write something the "obvious" way first, and it works, and then I notice some property (in this case that it looks monoidal), so I try implementing that class, and find it means I can delete a couple of the functions I wrote, and then I notice another property... etc, and before I know it I find that I hardly have any functions left because they're all implemented in the standard libraries!
20:32:11 <jonashw> I like that last bit, it shows that what is returned from my function is another function
20:32:13 <dpwright> and any that aren't are in lens :-P
20:32:18 <merijn> jonashw: Right
20:32:35 <jonashw> a function which is applied to a state out of site
20:32:42 <jonashw> with >>= and runState
20:32:42 <edwardk> =P
20:32:49 <jonashw> sight*
20:32:56 <merijn> jonashw: Correct
20:33:20 <merijn> jonashw: As for how that plays together with do notation, this is highly recommended reading if you haven't seen it yet: https://en.wikibooks.org/wiki/Haskell/do_Notation
20:33:25 <jonashw> god, I swear.  If monads are the last powerful programming concept I'll ever learn, I'll be happy
20:33:38 <dpwright> but I never notice these things until I've implemented it the obvious/long-winded way first
20:33:40 <merijn> jonashw: That explains how do-notation is turned into >>=
20:34:24 <kazagistar> jonashw: don't worry, there are plenty more hiding around in haskell :P
20:34:27 <merijn> jonashw: 3 months after this realisation you'll be going "pfffft, I don't get why I ever thought this was hard" :p
20:34:29 <jonashw> right, my favorite realization from that page is that names are bound via lambda arguments
20:35:06 <kazagistar> 6 months after the realization you think "man, it was so hard because they explained it WRONG... I better write my own monad tutorial"
20:35:13 <dpwright> jonashw: yeah, monads are like pointers; they seem hard until you get them, then they seem so easy and obvious you wonder how you ever struggled with them
20:35:28 <jonashw> merijn, pfffft, I think I'll remember the day when I really get it as the day when I first learned to breath underwater
20:35:40 <Welkin> I never understood what was difficult about pointers
20:35:51 <jonashw> Welkin, me neither..  my intuition worked that way
20:36:04 <zRecursive> Are there any maxima like software(s) developed using haskell ?
20:36:04 <Welkin> monads, on the other hand, take some time to learn
20:36:12 <jonashw> Welkin, again, agreed
20:36:23 <corgifex> Welkin: int a[10]; what's the type of &a? :-)
20:36:38 <copumpkin> corgifex: what happened to preflex?
20:36:40 <merijn> I was confused by points for ages
20:36:52 <merijn> copumpkin: preflex ran on mauke's desktop and his desktop died
20:36:54 <copumpkin> I wanted 6st the other day
20:36:56 <corgifex> copumpkin: the pc it was on died
20:36:56 <copumpkin> :(
20:37:06 <copumpkin> that's sad
20:37:11 <DanC_> cabal: Could not resolve dependencies: ... rejecting: lens-4.1.2.1/installed-c47... (conflict: music-preludes =>
20:37:11 <DanC_> lens>=4.2 && <4.3)
20:37:12 <dpwright> I think people struggle with the extra level of abstraction... if variables are numbers in a box, everything you've done up until that point has involved manipulating these things in boxes, but now suddenly you're dealing with the "box" itself
20:37:12 <kazagistar> no one remembers how hard programming was to learn, or how long it took
20:37:19 <Welkin> corgifex, I see your point about confusion from C syntax
20:37:28 <Welkin> yes, the syntax can be confusing, but the concept is simple
20:37:29 <rwbarton> DanC_: you need to get the other packages from github too I think
20:37:34 <corgifex> Welkin: so what is the type?
20:37:37 <DanC_> yeah; I'm just griping
20:37:56 <DanC_> I guess I expected released stuff to build
20:38:05 <kazagistar> Simple concepts are the hardest. You should tutor someone through learning basic algebra sometime.
20:38:14 <Welkin> corgifex, the address of a[0]
20:38:15 <jonashw> dpwright, that's a fun way to word it
20:38:32 <corgifex> Welkin: 1) that's wrong and 2) that's not even a type
20:38:36 <dpwright> jonashw: I resisted the "thinking outside the box" pun
20:38:46 <jonashw> it's a pointer to an array of ints, right?
20:39:01 <jonashw> *[Int] or however that's written
20:39:13 <corgifex> jonashw: yes (array of 10 ints, because C puts the size in the type)
20:39:37 <jonashw> corgifex, well you were just looking to trap someone with that weren't you ;)
20:39:39 <zRecursive> address of address ?
20:39:49 <kazagistar> lets not try to get too creative and compare x::[Int] to int x[];
20:39:49 <corgifex> zRecursive: no
20:39:56 <kazagistar> cause... the similarities break down fast
20:40:22 <merijn> corgifex: Do you still have your C programs (like the sizeof example) somewhere? I keep wanting to link people to them, but all my links are now dead
20:40:36 <corgifex> jonashw: I'm just very, very skeptical when someone claims C pointers are so easy to understand
20:40:40 <dpwright> types and programming languages... ¥8819 :-/
20:41:04 <Welkin> corgifex, I never said C pointers were easy to use; of course they are easy to mess up if you don't use them daily
20:41:19 <Welkin> I was talking about the concepts; concepts are not implementation
20:41:22 <jonashw> corgifex, well C isn't the only language with pointers.  Welkin was just talking about pointers in general
20:41:30 * zRecursive seems no maxima like software in haskell :(
20:41:46 <kazagistar> corgifex: I am empathetic. It is pretty hard to realize how hard simple concepts can be to understand once you understand them
20:41:55 <Welkin> I used to be quite good at identifying syntax correctly when I used C a lot
20:41:59 <corgifex> merijn: that one is in my head: printf("%d\n", sizeof(0)["abcdefghi"]);
20:42:04 <Welkin> I haven't used C in a long time
20:42:19 <enthropy> zRecursive: I think we brought some options last time this topic came up?
20:42:20 <jonashw> let's see.. it's been 8 years since I last used it
20:42:55 <zRecursive> enthropy: maybe, now i want to use sth ...
20:43:46 <zRecursive> enthropy: maybe i forget it
20:44:13 <jonashw> I'm confused by: instance Monad (State s) where  ...
20:44:15 <jonashw> when: newtype State s a = State { runState :: s -> (a,s) }
20:44:18 <merijn> corgifex: That one I still know too, the rest I forgot :p
20:44:29 <jonashw> (State s) vs State s a... how can it be written both ways?
20:44:41 <merijn> jonashw: "State s" is a partially applied type
20:44:47 <jonashw> ah, that explains it
20:44:47 <zRecursive> @google haskell maxima
20:44:48 <lambdabot> https://github.com/danbst/hsmaxima
20:44:49 <corgifex> jonashw: isn't that how all functions work in haskell?
20:44:55 <corgifex> jonashw: a b c parses as (a b) c
20:45:05 <jonashw> I forgot that types work that way too
20:45:08 <merijn> jonashw: Monad only works on types that take one type as argument
20:45:21 <jonashw> merijn, now that I did not know
20:45:38 <merijn> jonashw: Think about it
20:45:41 <merijn> :t (>>=)
20:45:42 <lambdabot> Monad m => m a -> (a -> m b) -> m b
20:45:51 <merijn> jonashw: m takes exactly one argument
20:46:05 <corgifex> @kind Monad
20:46:06 <lambdabot> (* -> *) -> Constraint
20:46:23 <merijn> If we had "Monad State" we'd get "(>>=) :: State a -> (a -> State b) -> State b" which is wrong
20:46:42 <jonashw> yeah, that wouldn't be very useful at all
20:46:51 <merijn> jonashw: "Monad (State s)", on the other hand, becomes "(>>=) :: State s a -> (a -> State s b) -> State s b"
20:47:01 <corgifex> > undefined :: State Int
20:47:02 <lambdabot>  Expecting one more argument to ‘Control.Monad.Trans.State.Lazy.State GHC.Typ...
20:47:03 <lambdabot>  Expected a type,
20:47:03 <lambdabot>    but ‘Control.Monad.Trans.State.Lazy.State GHC.Types.Int’ has kind ‘*
20:47:03 <lambdabot>                                                                       -> *’
20:47:16 <corgifex> overqualified :-(
20:48:11 <jonashw> like Weird Al when he applied for a job at Burger King
20:48:21 <enthropy> zRecursive: http://ircbrowse.net/browse/haskell?id=18335995&timestamp=1402710758#t1402710758 is the log
20:50:15 <corgifex> time to play Hardware Store
21:02:54 <jonashw> :t (>>)
21:02:55 <lambdabot> Monad m => m a -> m b -> m b
21:03:34 <jonashw> ah, it's just glue
21:03:59 <c_wraith> :t flip const `asTypeOf` (>>)
21:04:00 <lambdabot> Monad m => m a -> m b -> m b
21:04:09 <c_wraith> totally a valid implementation, right?
21:04:11 <jonashw> anyone else wish they had discovered haskell when they were 15?
21:04:15 <c_wraith> Yes.
21:04:38 <c_wraith> I guess I was about 10 when Haskell started, so it was possible - though very unlikely without internet access.
21:04:44 <kazagistar> hi, who do I ask to get lambdabot to join #algorithms?
21:04:55 <c_wraith> kazagistar: int-e is running it now, so presumably him
21:05:02 <jonashw> just ask lamdabot ;)
21:05:14 <kazagistar> @join #algorithms
21:05:14 <lambdabot> Not enough privileges
21:05:17 <kazagistar> she hates me
21:05:45 <jonashw> <monotone>lamdabot is not a she. lamdabot has no gender. lamdabot is above gender</monotone>
21:06:02 <c_wraith> lambdabot used to be a she.
21:06:06 <c_wraith> But no longer.
21:06:14 <c_wraith> Transcending gender is a new feature.
21:06:42 <kazagistar> fine then
21:06:56 <kazagistar> xhe hates me
21:08:08 <cstanfill> :t lambdabot
21:08:10 <lambdabot> Not in scope: ‘lambdabot’
21:08:13 <enthropy> @nixen
21:08:13 <lambdabot> I brought myself down. I impeached myself by resigning.
21:08:15 <cstanfill> :-\
21:09:27 <cstanfill> what's the function that fully ... computes a thing, and returns another thing?
21:09:33 <cstanfill> @hoogle a -> b -> a
21:09:34 <lambdabot> Prelude const :: a -> b -> a
21:09:34 <lambdabot> Data.Function const :: a -> b -> a
21:09:34 <lambdabot> Prelude seq :: a -> b -> b
21:09:40 <cstanfill> ah seq
21:10:14 <copumpkin> I wouldn't say that fully computes a thing
21:10:17 <c_wraith> :t seq `asTypeOf` (>>)
21:10:18 <lambdabot> Monad m => m a -> m b -> m b
21:10:26 <c_wraith> Hey, look, another handy implementation!
21:10:33 <copumpkin> it forces one level of the computation
21:10:56 <cstanfill> I was thinking of deepSeq
21:11:08 <merijn> You shouldn't be thinking of deepSeq >.<
21:11:29 <ivanm> merijn: unless benchmarking?
21:11:30 <cstanfill> I was using it in an interpreter that wasn't doing strictness how I wanted
21:11:33 <c_wraith> deepseq is a handy sledgehammer.
21:11:41 <corgifex> > drop 3 "deepSeq"
21:11:43 <lambdabot>  "pSeq"
21:11:43 <cstanfill> so I bent it into shape in entirely the wrong manner I think
21:11:46 <c_wraith> But it is a sledgehammer, and you can often be more delicate
21:11:54 <rwbarton> c_wraith, I can come up with some more implementations if you'd like :)
21:12:07 <cstanfill> or maybe I just used it with a print statement as a debug tool <_<
21:12:23 <merijn> cstanfill: Debug.Trace
21:12:55 <c_wraith> printing a value usually evaluates it as much as deepseq does.  (not always)
21:12:58 <cstanfill> it's quite possible that would've been better
21:13:17 <cstanfill> c_wraith: so I was trying to do some stuff with signals and interrupting the calculation
21:13:25 <cstanfill> and mvars
21:13:28 <cstanfill> it was gross
21:13:54 <cstanfill> deepSeq was not likely the *right* solution
21:14:11 <cstanfill> but was the handiest tool for whatever awful mess I'd gotten myself into
21:14:33 <lfairy> cstanfill: try putting ! in your data structures
21:14:42 <lfairy> e.g. data Value = Bool !Bool | Int !Int
21:14:54 <cstanfill> mm yeah
21:15:04 <lfairy> dunno, just firing in the dark here
21:15:08 <meadowlands> I'm new to both haskell and emacs, and I was searching for some suggestions in the emacs room on the following question: when editing code on a remote server, what options are available? So far I have come across suggestiosn for sshing in, and running emacs in the terminal, or using x-forwarding, but they mean I can't use my local emacs configuration
21:15:09 <cstanfill> I don't think I always wanted them to be strict either
21:15:26 <geekosaur> meadowlands: tramp
21:15:27 <cstanfill> i.e I wanted let clauses that had nonstrict things in them? I scrapped the project months ago anyway
21:15:47 <meadowlands> will tramp let me use haskell-mode if it's only installed on the remote machine?
21:15:55 <geekosaur> no
21:16:04 <geekosaur> tramp is for editing remote files with a local emacs
21:16:07 <meadowlands> heartbreaking!
21:16:27 <merijn> Coq is a pretty amusing video game, although I feel like I've regressed back to videogame programming...
21:16:27 <geekosaur> if you need to be running it on the remote machine, your options are ssh, X forwarding, or a remote session (rdp/vnc)
21:16:54 <cstanfill> oh boy coq
21:17:08 <cstanfill> I'm supposed to be messing more with that but idk if I have the gumption
21:17:45 <meadowlands> seems like local editing is my only option then, in a cabal sandbox that haskell-mode is able to see locally
21:18:01 <meadowlands> if I want to retain my local emacs configuration
21:19:03 <mavnoob> hi people, I just started learning haskell today
21:19:18 <benzrf> mavnoob: good luck
21:19:23 <mavnoob> I had a few questions
21:19:47 <meadowlands> to impose on your collective generosity, another emacs question for the room: any tips on how to interactively query for the type signature in the middle of a line in haskell-mode?
21:20:13 <meadowlands> for instance as a simple example, after writing map, I want to query for what map expects
21:20:36 <meadowlands> from prelude, a function and a list - and I think hoogle can tell me that
21:21:03 <meadowlands> but what about local cabal dependencies?
21:21:18 <mavnoob> The online manual I'm using says the '/' does only floating point division, but in ghci it divided integers
21:21:22 <mavnoob> what's up with that
21:21:24 <meadowlands> can I hook up hayoo? is there something more convenient?
21:21:43 <geekosaur> I think you ant to look at ghc-mod?
21:21:50 <geekosaur> *want to
21:23:10 <cstanfill> :t (/)
21:23:11 <lambdabot> Fractional a => a -> a -> a
21:23:37 <AlecTaylor> hi
21:24:01 <cstanfill> > 4 / 5
21:24:01 <meadowlands> ah thanks, this looks interesting! I thought haskell-mode had something built-in and had not looked further than the wiki
21:24:03 <lambdabot>  0.8
21:24:05 <cstanfill> :t (4 / 5)
21:24:06 <lambdabot> Fractional a => a
21:24:20 <cstanfill> > (4 :: Integer) / (5 :: Integer)
21:24:21 <lambdabot>  No instance for (GHC.Real.Fractional GHC.Integer.Type.Integer)
21:24:21 <lambdabot>    arising from a use of ‘GHC.Real./’
21:24:26 <cstanfill> okay, cool
21:25:00 <cstanfill> mavnoob: did you do 4 / 5? because the way number literals work in haskell is maybe not what you would expect
21:37:49 <jonashw> with nested do-blocks, are you still in the context of the first monad?
21:38:34 <rwbarton> the variables you bound are still in scope
21:38:59 <jonashw> and in the second do block, is the behavior of 'return' the same?
21:39:20 <jle`> jonashw: do you know how do blocks are desugared?
21:39:22 <joelteon> values from the other block are still in scope
21:39:23 <joelteon> the behavior of return depends on the type of the block
21:39:24 <joelteon> > do { x <- Just 3; return x }
21:39:25 <jonashw> as lambas
21:39:26 <lambdabot>  Just 3
21:39:30 <jle`> jonashw: not quite
21:39:38 <jle`> as binds
21:39:41 <jle`> :t (>>=)
21:39:41 <jonashw> lamdas bound with >>=
21:39:41 <lambdabot> Monad m => m a -> (a -> m b) -> m b
21:39:43 <kazagistar> the other do block might not even be the same monad at all
21:39:46 <jle`> :t (>>)
21:39:46 <lambdabot> Monad m => m a -> m b -> m b
21:39:50 <joelteon> > do { x <- [1]; y <- do { x <- Just 1; return x }; return (x == y) }
21:39:52 <lambdabot>  Couldn't match type ‘Data.Maybe.Maybe’ with ‘[]’
21:39:52 <lambdabot>  Expected type: [a0]
21:39:52 <lambdabot>    Actual type: Data.Maybe.Maybe a0
21:39:56 <jle`> so all that matters is the type of the lines
21:39:59 * hackagebot web-plugins 0.2.6 - dynamic plugin system for web applications  http://hackage.haskell.org/package/web-plugins-0.2.6 (JeremyShaw)
21:40:02 <joelteon> damn it, i did it wrong
21:40:04 <jle`> determines what is (>>=)
21:40:04 <joelteon> that's not helpful
21:40:07 <jonashw> kazagistar, thanks, you've confirmed my suspicions
21:40:29 <jle`> when it doubt just manually desugar
21:40:30 <joelteon> > do { x <- [1]; y <- maybeToList (do { x <- Just 1; return x }); return (x == y) }
21:40:32 <lambdabot>  [True]
21:40:35 <joelteon> there, look at that
21:40:47 <joelteon> in the inner do block, return is a -> Maybe a, while in the outer it's a -> [a]
21:40:50 <corgifex> @undo do { x <- [1]; y <- maybeToList (do { x <- Just 1; return x }); return (x == y) }
21:40:50 <lambdabot> [1] >>= \ x -> maybeToList (Just 1 >>= \ x -> return x) >>= \ y -> return (x == y)
21:41:09 <jle`> of course if it's the same Monad m, return behaves the same because it's the same function globally
21:41:17 <jle`> because instances are global
21:41:25 <joelteon> jonashw: in a situation like do { a <- f; b <- do { ... }; return b } then the inner do block is the same type at the outer
21:41:28 <jonashw> joelteon, thanks for the example
21:42:10 <toki78> hi
21:42:11 <jonashw> ah, I see the connection
21:42:11 <joelteon> hence the type error in my first example
21:42:25 <joelteon> but yeah, do blocks are just expressions
21:42:39 <dmj`> > do do do do 4 + 4
21:42:40 <lambdabot>  8
21:42:57 <ivanm> dmj`: needs some "wop" :p
21:43:04 <toki78> is there something like teamviewer for linux ?
21:43:07 <lfairy> reminds me of stacking id
21:43:10 <ivanm> toki78: vnc?
21:43:23 <lfairy> > id id id id id 4
21:43:24 <lambdabot>  4
21:43:35 <toki78> ivanm, vnc needs an open server port
21:43:53 <ivanm> then I've got nothing ;-)
21:46:19 <corgifex> toki78: http://www.teamviewer.com/en/download/linux.aspx
21:46:48 <jle`> > ala Endo foldMap (replicate 100000000 id) ()
21:46:52 <lambdabot>  mueval-core: Time limit exceeded
21:47:05 <jle`> > ala Endo foldMap (replicate 10000000 id) ()
21:47:09 <lambdabot>  ()
21:48:25 <jle`> > foldr ($) id (replicate 100000000 id) ()
21:48:29 <lambdabot>  mueval-core: Time limit exceeded
21:48:32 <jle`> > foldr ($) id (replicate 10000000 id) ()
21:48:33 <lambdabot>  ()
21:48:38 <jle`> id is srs business
21:49:02 <toki78> ivanm, corgifex thx !!
21:50:00 * hackagebot clckwrks 0.22.2 - A secure, reliable content management system (CMS) and blogging platform  http://hackage.haskell.org/package/clckwrks-0.22.2 (JeremyShaw)
21:52:20 <jle`> hey, why don't people use forM_, etc. in infix form
21:52:25 <jle`> that way we don't have to do the ugly ($)
21:52:46 <jle`> instead of forM_ [x,y,z] $ \s -> ...
21:52:54 <jle`> [x,y,z] `forM_` \s -> ...
21:53:05 <ivanm> jle`: it doesn't always chain as well, especially when also using operators
21:53:32 <jle`> chain how?
21:53:54 <enthropy> `infixFunctions` aren't very popular for whatever reason
21:53:57 <rwbarton> do you really not need $ there?
21:54:16 <ivanm> list `function` foo <> bar
21:55:46 <rwbarton> > [1,2,3] `forM_` \s -> [s,s+1]
21:55:48 <lambdabot>  [(),(),(),(),(),(),(),()]
21:55:52 <rwbarton> huh, TIL
21:56:04 <jle`> > forM_ [1,2,3] \s -> [s+1]
21:56:05 <lambdabot>  <hint>:1:15: parse error on input ‘\’
21:56:40 <Iceland_jack> > forM [1,2,3] (\s -> [s,s+1])
21:56:42 <lambdabot>  [[1,2,3],[1,2,4],[1,3,3],[1,3,4],[2,2,3],[2,2,4],[2,3,3],[2,3,4]]
21:57:45 <jle`> down with ($)
21:58:40 <jle`> i can live with ``
21:59:37 <enthropy> infixr 0 `id`
21:59:49 <jle`> :P
22:00:09 <jle`> forM_ [x,y,z] `id` \s -> ...
22:00:10 <jle`> hm
22:00:13 <zRecursive> enthropy: thanks
22:00:28 <enthropy> zRecursive: what did you settle for?
22:00:55 <zRecursive> settle means ?
22:01:07 <enthropy> as in what did you decide to use?
22:01:12 <jle`> > forM [1,2,3] `id` \s -> [s,s+1]
22:01:13 <lambdabot>  [[1,2,3],[1,2,4],[1,3,3],[1,3,4],[2,2,3],[2,2,4],[2,3,3],[2,3,4]]
22:01:26 <rwbarton> much better
22:01:31 <zRecursive> enthropy: like maxima to study math
22:01:45 <jle`> ikr
22:02:08 <enthropy> zRecursive: yes
22:02:27 <jle`> > id `id` id `id` id 5
22:02:28 <lambdabot>  5
22:05:06 <jle`> flip const = const id
22:05:07 <jle`> now you know
22:05:28 <toki78> oops, I wanted the linux channel ?!?
22:05:38 <jle`> :t flip id
22:05:39 <lambdabot> b -> (b -> c) -> c
22:05:44 <jle`> :t flip const
22:05:45 <lambdabot> b -> c -> c
22:05:47 <jle`> :t const id
22:05:48 <lambdabot> b -> a -> a
22:05:57 <jle`> i wonder if there's anything deep to gain out of that
22:06:06 <toki78> okay folks bye !!!
22:06:13 <jle`> byte toki78
22:15:20 <jle`> i was playing with ghci and i wrote
22:15:32 <jle`> let f n = print n >> threadDelay 500000 >> f (n+1)
22:15:45 <jle`> and i checked the type and it was IO a
22:16:16 <jle`> and i thought "whoa i can construct any type forall a. IO a..."
22:16:29 <jle`> er, I can get an IO a for any a
22:16:34 <jle`> i thought that only bottom could do that
22:16:40 <jle`> and then i realized that my function didn't terminate so that made sense >_>
22:17:46 <jle`> not that it doesn't terminate when run
22:17:53 <jle`> but it doesn't terminate in evaluation either
22:25:05 * hackagebot shakespeare 2.0.1 - A toolkit for making compile-time interpolated templates  http://hackage.haskell.org/package/shakespeare-2.0.1 (MichaelSnoyman)
22:29:30 <lfairy> my god... irc supports client-to-client connections
22:29:35 <lfairy> ssh over irc, anyone?
22:36:31 <ninja_code> how do I use deepseq ? I need a way to force evaluation -- so I can do timings
22:36:49 <ninja_code> laziness makes timing hard, i.e. start_time <- .... ; bunch of lazy ops ; end_time <- ... ; well, end_time = start_time
22:37:04 <ninja_code> how do I use deepseq to force evaluation, to say something like "fucking evaluate this now so I can do timing" ?
22:37:13 <johnw> check out criterion
22:38:08 <ninja_code> johnw: is "criterion" fo rme or someone else ?
22:38:15 <joelteon> for you
22:38:30 <johnw> criterion has examples of doing exactly what you wanta
22:38:43 <johnw> plus it's a great framework for collecting and reporting the data
22:39:57 <augur> argh
22:40:10 <augur> i need a tutorial on proper Parsec hacking :(
22:41:45 <ninja_code> the idea behind parsec
22:41:45 <ninja_code> is that you have two continuations
22:41:51 <ninja_code> one for if current succeeds, one for if current fails
22:41:57 <ninja_code> then you just pass them around and do stuff
22:42:09 <savanni> heh
22:42:33 <augur> ninja_code: :P
22:42:46 <augur> more like, i need a proper tutorial on how to make precedence stuff work
22:43:42 <ninja_code> isn't it just the order you tell it to try stuff?
22:43:44 <Welkin> isn't precedence from left to right between <|> ?
22:44:00 <augur> "just"
22:46:47 <ninja_code> damn it
22:46:51 <ninja_code> does Haste do tail call optimiation?
22:48:32 <jle`> is there a lens for Identity
22:48:40 <johnw> Welkin: use :i (<|>) in ghci
22:51:00 <Welkin> johnw, Parsec or Control.Applicative?
22:51:19 <johnw> latter
22:51:23 <johnw> the former just re-exports the latter
22:57:20 <jle`> looking for a Lens (Identity a) (Identity b) a b i guess
22:59:50 <supki> :t iso runIdentity Identity
22:59:51 <lambdabot> (Profunctor p, Functor f) => p a (f b) -> p (Identity a) (f (Identity b))
22:59:53 <firebird1> all alpha exist here
23:00:06 <jle`> supki: any built in one?
23:00:29 <jle`> er, pre-defined one
23:01:23 <supki> jle`: _Wrapped', I think
23:01:27 <supki> or something
23:02:21 <jle`> > Identity 5 & _Wrapped *~ 3
23:02:23 <lambdabot>  Identity {runIdentity = 15}
23:02:26 <jle`> oh neat
23:02:27 <supki> hmm, no, it's not polymorphic enough
23:02:28 <jle`> thanks
23:02:43 <jle`> > Identity 5 & _Wrapped %~ show
23:02:45 <lambdabot>  Identity {runIdentity = "5"}
23:02:59 <supki> yeah, _Wrapped looks good
23:03:04 <jle`> thanks
23:03:10 <jle`> is _Wrapped' the Simple version?
23:03:25 <jle`> > Identity & _Wrapped' %~ show
23:03:26 <lambdabot>  Couldn't match type ‘Control.Lens.Wrapped.Unwrapped
23:03:27 <lambdabot>                         (a0 -> Data.Functor.Identity.Identity a0)’
23:03:27 <lambdabot>                with ‘[GHC.Types.Char]’
23:03:27 <lambdabot>  The type variable ‘a0’ is ambiguous
23:03:27 <lambdabot>  Expected type: GHC.Base.String
23:03:37 <jle`> > Identity 5 & _Wrapped' %~ show
23:03:38 <lambdabot>  No instance for (GHC.Num.Num GHC.Base.String)
23:03:38 <lambdabot>    arising from the literal ‘5’
23:03:42 <jle`> ah
23:04:12 <trap_exit> is there a way to make the following faster? (context: Haste, fromJSStr = JavaScript string -> haskell String). " let lst = map read $ words $ fromJSStr s :: [Int] "  ; this line of code takes 15 seconds to execute
23:04:17 <trap_exit> yet "s" is < 1 MB
23:04:29 <trap_exit> also, "s" is not lazy, since it's returned from a Javascript FFI
23:05:10 * hackagebot GLUtil 0.7.5 - Miscellaneous OpenGL utilities.  http://hackage.haskell.org/package/GLUtil-0.7.5 (AnthonyCowley)
23:06:49 <johnw> trap_exit: could I see more context/code?
23:07:10 <trap_exit> johnw: no, you may not
23:07:10 <trap_exit> :-)
23:07:13 <trap_exit> let me try to package this a bit better
23:07:44 <johnw> it really depends on what you're doing with the list
23:07:55 <johnw> like, if you take its length, but don't read its contents
23:08:14 <trap_exit> actually, this is a bit messy due to IP / minimal examples
23:08:17 <trap_exit> can you recommend me some reading
23:08:20 <trap_exit> on haskell performance?
23:08:32 <johnw> then I think every read thunk will hold a reference to its sublist
23:08:40 <trap_exit> I love the type system + compile time error detection; but unable to reason about performance hurts
23:09:10 <johnw> ok, the best performance comes if you consume this list one element at a time, but don't need the list beyond that
23:09:30 <johnw> if you force the spine of the list, you'll have a bunch of thunks which must hold data in memory for them to act on when the time comes
23:09:35 <johnw> but even that's not terribly slow
23:09:57 <johnw> this is why I would need context, because how you use the results of that expression has a lot to do with how it performs
23:10:43 <Aetherspawn-> Actually, it's probably nothing to do with that in this case
23:10:47 <Aetherspawn-> read is slow. Really slow
23:10:52 <Aetherspawn-> Not even just slow, it's horrifically slow.
23:10:53 <johnw> really, *that* slow?
23:10:58 <Aetherspawn-> Yes. *that* slow.
23:11:04 <johnw> ok, good to know
23:11:05 <Aetherspawn-> use a parser if performance bothers you.
23:11:12 <johnw> right
23:11:21 <johnw> using parsec over the whole string could be much better
23:11:26 <trap_exit> i have a dumb question
23:11:31 <trap_exit> can we do the following:
23:11:34 <Aetherspawn-> or attoparsec, if you can. That's faster than c now!
23:11:41 <johnw> numbers :: Parser [String] ; numbers = many decimal
23:11:41 <trap_exit> can we generate a string, of length 1000000
23:11:46 <trap_exit> where it's "0 1 2 3 4 .... 1000000"
23:11:52 <trap_exit> then do map read $ words s
23:11:54 <trap_exit> where s = above string
23:11:54 <Aetherspawn-> [0..1000000]
23:11:59 <johnw> or: numbers :: Parser [String] ; numbers = many (sepBy space decimal)
23:12:08 <trap_exit> right, that's a list, not a string
23:12:09 <Aetherspawn-> > words "foo bar qux"
23:12:10 <lambdabot>  ["foo","bar","qux"]
23:12:15 <Aetherspawn-> :t words
23:12:16 <lambdabot> String -> [String]
23:12:36 <Aetherspawn-> What you probably actually want to do
23:12:42 <trap_exit> how do we go [Int] -> String ?
23:12:52 <Iceland_jack> > unwords (map show [1,2,3])
23:12:54 <lambdabot>  "1 2 3"
23:13:11 <trap_exit> unwords (map show [1 .. 1000000])
23:13:13 <Iceland_jack> :t unwords . map show
23:13:14 <lambdabot> Show a => [a] -> String
23:13:22 <trap_exit> > map read $ words $ unwords (map show [1 .. 1000000])
23:13:23 <lambdabot>  [*Exception: Prelude.read: no parse
23:13:27 <trap_exit> now, how do we time the above line? :-)
23:13:50 <Iceland_jack> > map read $ words $ unwords (map show [1 .. 1000000]) :: [Int]
23:13:52 <lambdabot>  [1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,...
23:13:53 * Aetherspawn- hopes someone defined a words/unwords rewrite rule
23:14:22 <trap_exit> > map read $ words $ unwords (map show [1 .. 1000000]) :: [Int]
23:14:24 <lambdabot>  [1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,...
23:14:31 <trap_exit> okay, maybe read is my problem
23:14:42 <trap_exit> since I'm running it in Haste, which is running it in javascript
23:14:47 <trap_exit> what should I use instead of read for reading a list of integers?
23:15:00 <Iceland_jack> If you really do have a list you can use
23:15:00 <Iceland_jack> > read "[1,2,3]" :: [Int]
23:15:02 <lambdabot>  [1,2,3]
23:15:02 <trap_exit> what should I replace: " map read $ words $ fromJSStr s :: [Int]" with ?
23:15:10 <Iceland_jack> but then you don't map read
23:15:33 <Aetherspawn-> might be able to use a parser i.e. attoparsec or parsec
23:15:41 <Aetherspawn-> those are generally fast
23:15:57 <Aetherspawn-> a much bigger solution than Iceland_jack's though
23:15:58 <Aetherspawn-> try his first.
23:16:23 <trap_exit> dumb qeustion
23:16:26 <trap_exit> why is calling read once faster than mapping read ?
23:16:46 <MP2E> mapping read makes it called once for every element
23:16:52 <MP2E> instead of just once.
23:16:56 <trap_exit> yes, but on a much shorter string
23:17:11 <Iceland_jack> trap_exit: Also you're comparing calling words as well, invoking a function almost always has a certain cost
23:17:38 <Aetherspawn-> first of all
23:17:43 <Aetherspawn-> trap_exit: is it faster? did you test?
23:17:58 <trap_exit> Aetherspwan-: testing right now
23:18:05 <kazagistar> read is very "complicated" and thus it has a lot of overall setup time
23:18:22 <Aetherspawn-> and if so, it's probably faster because `read` doesn't necessarily get into a tight loop (fast loop) if it's being called many times
23:18:43 <Aetherspawn-> calling it once allows a tight loop to be produced. Like you would see in C if you wrote "for (int i = 0; .... ) { }
23:19:15 <Aetherspawn-> naturally the latter has less overhead than setting up the call many many times
23:19:58 <kazagistar> I suspect that list read calls int read anyways though...
23:20:03 <kazagistar> no idea
23:20:38 <trap_exit> hmm
23:20:40 <Enigmagic> it probably does, it's most likely implemented as fmap read with some extra goo
23:20:43 <trap_exit> definitely slower
23:20:52 <trap_exit> okay, is there a simple, dumbass String -> Int ?
23:20:54 <trap_exit> that's not read ?
23:21:03 <trap_exit> i'm half tempted to roll my own int reader right now
23:21:14 <Enigmagic> trap_exit: just for kicks, try this: reverse (foldl' (\y x -> read x:y) [] (words x)) :: [Int]
23:21:46 <Enigmagic> might be slower, might not be. i'm not sure how haste represents String
23:22:12 <trap_exit> eh, fuck it
23:22:15 <trap_exit> I'm going to use Haste's json parser :-)
23:22:25 <trap_exit> time to use nukes to kill ants
23:22:26 <kazagistar> trap_exit: before you roll it from scratch, roll it from attoparsec or something
23:22:40 <Aetherspawn-> attoparsec is the way to go
23:22:44 <Aetherspawn-> its blazing fast and super easy
23:22:49 <Iceland_jack> It's not like 'read' was build for speed
23:23:07 <Aetherspawn-> > read "0 3"
23:23:08 <lambdabot>  *Exception: Prelude.read: no parse
23:23:15 <Aetherspawn-> > read "0..3"
23:23:17 <lambdabot>  *Exception: Prelude.read: no parse
23:23:17 <trap_exit> actually, int parser should be quite easy, i.e. foo [] = 0; foo x : ls = (x - '0') + 10 * foo ls
23:23:29 <kazagistar> Aetherspawn-: (hint: give it a type signature)
23:23:31 <trap_exit> reverse the string before calling foo
23:23:38 <Aetherspawn-> > read "0..3" :: Int
23:23:39 <lambdabot>  *Exception: Prelude.read: no parse
23:23:44 <trap_exit> Aetherspawn: I'm using haste. I need stuff that Haste supports.
23:23:48 <Aetherspawn-> just checking what kind of rubbihs it might accept
23:23:49 <kazagistar> :t read "0 3"
23:23:50 <lambdabot> Read a => a
23:24:01 <Aetherspawn-> also, is Haste string singly linked?
23:24:04 <kazagistar> oh right, well... this is what it is spoiler
23:24:19 <kazagistar> > read "()"
23:24:20 <lambdabot>  ()
23:24:46 <kazagistar> Aetherspawn-: haskell strings are a list, lists are singly linked yes
23:24:47 <trap_exit> Aetherspawn- : I have no fucking clue. How do I check?
23:24:56 <Aetherspawn-> kazagistar: I know that
23:24:58 <Aetherspawn-> we're talking about Haste
23:24:58 <kazagistar> oh... Haste
23:25:01 <kazagistar> derp
23:25:03 <kazagistar> I cant read
23:25:18 <Aetherspawn-> the issue is, if it isn't, the operation is going to be extremely ineffecient
23:25:24 <Aetherspawn-> copying the string for each usage of : ..
23:25:42 <Enigmagic> trap_exit: try running: reverse (foldl' (\y x -> read x:y) [] (words x)) :: [Int]
23:27:20 <Enigmagic> trap_exit: it will: a) prevent thunk buildup by converting the whole list at once, b) allow the input string to be GC'd immediately (assuming it's not used)
23:27:31 <Enigmagic> not to say that it'll be faster
23:27:55 <trap_exit> Enigmagic: hmm, I don't understand what you said
23:27:59 <trap_exit> but it sounds reasonable, so I'll try it
23:28:09 <trap_exit> I bet you can get people to execute "rm -rf / " too :-)
23:28:18 <Enigmagic> trap_exit: guess what that does ;-)
23:28:42 <Aetherspawn-> did nothing for me
23:28:52 <Aetherspawn-> just kidding :)
23:28:59 <trap_exit> Aetherspawn-: are you running haste?
23:29:10 <Aetherspawn-> nope
23:29:11 <Enigmagic> > reverse (fold' (\y x -> read x:y) [] (words "foo bar baz") :: [Int]
23:29:12 <lambdabot>  <hint>:1:68:
23:29:12 <lambdabot>      parse error (possibly incorrect indentation or mismatched brackets)
23:29:20 <Enigmagic> > reverse (fold' (\y x -> read x:y) [] (words "foo bar baz")) :: [Int]
23:29:21 <lambdabot>  Not in scope: ‘fold'’
23:29:21 <lambdabot>  Perhaps you meant one of these:
23:29:21 <lambdabot>    ‘foldr’ (imported from Data.List),
23:29:21 <lambdabot>    ‘BS.foldr’ (imported from Data.ByteString),
23:29:21 <lambdabot>    ‘BSL.foldr’ (imported from Data.ByteString.Lazy)
23:29:49 <Enigmagic> > reverse (foldl' (\y x -> read x:y) [] (words "1 2 3")) :: [Int]
23:29:50 <Aetherspawn-> > reverse (foldl' (\y x -> read x:y) [] (words "foo bar baz")) :: [Int]
23:29:50 <lambdabot>  [1,2,3]
23:29:51 <lambdabot>  [*Exception: Prelude.read: no parse
23:30:16 <Enigmagic> sorry, getting late :P
23:30:23 <Aetherspawn-> > reverse (foldl' (\y x -> read x:y) [] (words $ show [1..])) :: [Int]
23:30:28 <lambdabot>  mueval-core: Time limit exceeded
23:30:28 <lambdabot>  mueval: ExitFailure 1
23:30:30 <Aetherspawn-> ofcourse, it's not streaming.
23:30:35 <Aetherspawn-> > reverse (foldl' (\y x -> read x:y) [] (words $ show [1..400])) :: [Int]
23:30:36 <lambdabot>  [*Exception: Prelude.read: no parse
23:30:45 <Aetherspawn-> nevermind, Im dumb.
23:31:26 <trap_exit> fast_read_int :: String -> [Int] fast_read_int s = reverse (Data.Map.foldl' (\y x -> read x : y) [] (words s))
23:31:31 <trap_exit> above does not compile
23:31:42 <Enigmagic> trap_exit: you want Data.List.foldl'
23:32:47 <trap_exit> might ahve been slightly faser
23:32:47 <trap_exit> but still > 3 seconds
23:32:56 <trap_exit> trying json now
23:33:23 <trap_exit> one retarded question
23:33:32 <trap_exit> why are you guys helping me instead of commanding $$$ doing haskell consulting? :-D
23:34:21 <zRecursive> They are glad to help anyone
23:35:26 <Enigmagic> and on that note, i'm going to bed :P
23:35:36 <Enigmagic> good luck sir
23:36:17 <Aetherspawn-> today is my day off
23:36:30 <zRecursive> @src Data.List.foldl'
23:36:31 <lambdabot> Source not found. Do you think like you type?
23:36:33 <Aetherspawn-> I lambdacolyte so hard I only work 4 days a week ;)
23:36:43 <Enigmagic> @src foldl'
23:36:43 <lambdabot> foldl' f a []     = a
23:36:43 <lambdabot> foldl' f a (x:xs) = let a' = f a x in a' `seq` foldl' f a' xs
23:37:06 <zRecursive> ok
23:41:50 <trap_exit> silly question
23:42:03 <trap_exit> how do I go from "Double -> Int" ? http://www.haskell.org/hoogle/?hoogle=Double+-%3E+Int is not being very helpful
23:42:25 <kazagistar> trap_exit: don't you know that haskell is an "academic language"?
23:42:31 <Iceland_jack> it depends on what you want to do
23:42:35 <Iceland_jack> round? ceiling? floor?
23:42:39 <Iceland_jack> > round pi
23:42:40 <lambdabot>  3
23:42:45 <Iceland_jack> > round 2.5
23:42:46 <Iceland_jack> > round 3.5
23:42:46 <lambdabot>  2
23:42:47 <lambdabot>  4
23:42:49 <trap_exit> kazagistar: I'm in academia.
23:44:16 <Aetherspawn-> trap_exit: you have to round it
23:44:27 <Aetherspawn-> only conversions are defined for casts not transformations
23:44:34 <Aetherspawn-> ie, you could use fromIntegral once it's in integral form
23:44:41 <Aetherspawn-> but a Double is rational
23:44:50 <Iceland_jack> You can also use
23:44:50 <Iceland_jack> @ty const 6 :: Double -> Int
23:44:52 <lambdabot> Double -> Int
23:44:56 <Aetherspawn-> > fromIntegral (3.02 :: Double) :: Int
23:44:57 <lambdabot>  No instance for (GHC.Real.Integral GHC.Types.Double)
23:44:57 <lambdabot>    arising from a use of ‘GHC.Real.fromIntegral’
23:45:19 <Aetherspawn-> Iceland_jack: surely that does not work!
23:45:33 <Iceland_jack> <trap_exit> how do I go from "Double -> Int" ?
23:45:33 <Iceland_jack> :) solves the problem
23:45:44 <Iceland_jack> I've already suggested round, ceiling, floor, ...
23:46:10 <Iceland_jack> And besides, 6 is probably the best number
23:46:22 <kazagistar> pretty sure 4 is though
23:46:39 <Aetherspawn-> IEEE says 4.
23:46:43 <Aetherspawn-> theres an xkcd thats relevant
23:47:22 <Iceland_jack> If 4 is the best number, why did Iceland_jack choose 6 for their earlier example
23:47:48 <zRecursive> 6 is a perfect number
23:48:10 <kazagistar> hoogle IS surprising bad at finding round, floor, and ceiling
23:48:20 <zRecursive> the second perfect number is 28
23:48:27 <Iceland_jack> yes, numeric conversion is hell for to explain to newcomers
23:48:38 <Iceland_jack> *for explaining
23:49:18 <kazagistar> its all typeclasses which is cool but hoogle fails sometimes at them
23:49:46 <kazagistar> it does a pretty good job with functors and monads and such
23:50:19 * hackagebot vinyl-gl 0.2 - Utilities for working with OpenGL's GLSL shading language and vinyl records.  http://hackage.haskell.org/package/vinyl-gl-0.2 (AnthonyCowley)
23:53:03 <kazagistar> @hoogle [Maybe Char] -> Maybe String
23:53:03 <lambdabot> Prelude sequence :: Monad m => [m a] -> m [a]
23:53:03 <lambdabot> Control.Monad sequence :: Monad m => [m a] -> m [a]
23:53:03 <lambdabot> Data.Maybe catMaybes :: [Maybe a] -> [a]
23:53:14 <kazagistar> for example, thats all helpful
23:54:23 <kazagistar> @hoogle Float -> Integer
23:54:24 <lambdabot> Unsafe.Coerce unsafeCoerce :: a -> b
23:54:24 <lambdabot> Prelude floatRadix :: RealFloat a => a -> Integer
23:54:24 <lambdabot> Prelude toInteger :: Integral a => a -> Integer
23:54:51 <Iceland_jack> 'toInteger' doesn't even type check
23:55:05 <kazagistar> heh
23:55:20 * hackagebot vinyl-gl 0.2.0.1 - Utilities for working with OpenGL's GLSL shading language and vinyl records.  http://hackage.haskell.org/package/vinyl-gl-0.2.0.1 (AnthonyCowley)
23:55:22 * hackagebot vinyl-gl 0.2.0.2 - Utilities for working with OpenGL's GLSL shading language and vinyl records.  http://hackage.haskell.org/package/vinyl-gl-0.2.0.2 (AnthonyCowley)
23:55:40 <kazagistar> "hey newbie, I think what you are looking for is 'unsafe coerse', go ahead and give that a try ;) "
23:56:07 <Iceland_jack> “Hey it turns out I just needed unsafeCoerce. unsafeCoerce for everything!”
23:56:53 <kazagistar> unsafeCoerse :: MyProgramInput -> MyDesiredResults -- my program is finished!
23:57:31 <kazagistar> number 4 is fun to, throwDyn
23:57:36 <Iceland_jack>     main = unsafeCoerse (undefined :: JavaScript) :: IO ()
23:57:49 <Iceland_jack> *coerce
23:58:47 <kazagistar> hah, on the third page
23:58:54 <tdammers> unsafeCoarse
23:59:08 <tdammers> 'cause dealing with the fine print sucks
23:59:09 <kazagistar> we finally find floor :: (RealFrac a, Integral b) => a -> b
23:59:39 <tdammers> main = undefined -- TODO
