00:09:35 * hackagebot simple-conduit 0.4.0 - A simple streaming library based on composing monadic folds.  http://hackage.haskell.org/package/simple-conduit-0.4.0 (JohnWiegley)
00:09:35 * hackagebot yesod-platform 1.2.12.1 - Meta package for Yesod  http://hackage.haskell.org/package/yesod-platform-1.2.12.1 (MichaelSnoyman)
00:12:50 <juhp> is there a tool which can tell you if you have redundant build-deps in your project's .cabal file?
00:16:45 <adunumdatum> Hello, all! I've got a question for any pandoc users here. I'm trying to convert LaTeX to docx or rtf using Pandoc. I have a BibTeX bibliography, and am using LaTeX citations commands that are defined by the particular LaTeX package I'm using (apa6 -- the command include \citeA{}, \citeNP{}, etc. in addition to the normal \cite{} command). The conversion goes great for the most part, and citations called using the \cite{} command are rendered pr
00:16:45 <adunumdatum> operly. However, citations called using the other commands (e.g., \citeA{}) aren't rendered, and just don't show up at all in the docx and rtf output. I'd really like to keep using these LaTeX commands, since they offer more flexibility that just using the single Pandoc-style citation [@bibtex-id] format. Does anyone here have any advice on how to get these citations rendering properly in docx or rtf output?
00:16:46 <dottedmag> juhp: Is it possible? (Besides brute-forcing builds with subsets of build-deps removed and checking produced binaries?)
00:17:04 <adunumdatum> Whoops, sorry about so much text all at once! : /
00:17:15 <juhp> dottedmag, hmm not so easy guess, nod
00:17:57 <juhp> would be useful though...
00:18:11 <shachaf> adunumdatum: I think there's a Pandoc IRC channel. Maybe they would know more than people in here.
00:18:30 <dottedmag> Agree. Excessive build-deps is a common issue in all packaging systems (remembering some stats gathered from Debian and Fedora).
00:18:56 <adunumdatum> shachaf: I'll check there, too; thank you! It's seemed pretty dead the last few times I've dropped in, so I wasn't sure if it's still active.
00:19:24 <shachaf> I don't know either. But I doubt people in here will know much.
00:19:52 <juhp> adunumdatum, or try the mailing list (group) :)
00:20:25 <adunumdatum> juhp: Oh, I hadn't even seen that! Just found it; thanks! : )
00:20:39 <juhp> I think it is reasonably active
00:20:56 <juhp> dottedmag, yes
00:23:10 <juhp> another question:)  is there a library which can sort packages in dependency order (like cabal-sort does)?
00:23:48 <juhp> I may just be lazy for now and call out to cabal-sort... ;)
00:26:58 <zq> ehm
00:27:19 <zq> what's a nice way to quantify the similarity between graphs?
00:29:40 <zq> nevererer mind
00:40:18 <pavonia> adunumdatum: I don't know much about Pandoc but I don't think it parses package files at all or does any sophisticated macro expansion, so it doesn't know how to process these commands unless you give it some hints
00:44:38 * hackagebot latex 0.1.0.3 - Parse, format and process LaTeX files  http://hackage.haskell.org/package/latex-0.1.0.3 (HenningThielemann)
00:55:00 <ion> Can i query the positions of certain named points in the final result of a diagram generated using diagrams?
00:56:38 <johnw> #diagrams may know
00:56:49 <ion> Thanks, iâ€™ll join.
01:09:12 <jle`> juhp: i usually just comment out all my build deps and add them in one by one
01:09:20 <jle`> when cabal/ghc compain
01:09:27 <jle`> probably not a very scalable method though
01:09:43 <juhp> jle`, yeah I guess that is the simplest approach
01:12:10 <dmj`> juhp: cabal freeze creates a cabal.config file with all your deps versioned and sorted alphabetically
01:12:55 <juhp> dmj`, ah I want to sort by dependency (build) order
01:13:45 <juhp> sorry unrelated questions :)
01:16:25 <hunt> tell me some of you are awake
01:16:30 <hunt> im having a really weird bug experience
01:16:38 <hunt> check out the paste:
01:17:20 <jle`> nobody is awake
01:17:23 <hunt> http://lpaste.net/105559
01:17:26 <jle`> :)
01:17:32 <hunt> no plesae!!
01:17:49 <hamid> yeah nobody
01:17:50 <hunt> why does the first one fail and the second one does not? the first appears to perform no actions at all
01:17:50 <jle`> hunt: both are invalid syntax on their own
01:18:02 <hunt> jle`: what? they compile
01:18:06 <jle`> not alone
01:18:24 <hunt> jle`: oh yea, not alone, but the function theyre in is mostly irrelevant afaik
01:18:35 <jle`> what's the problem, exactly?
01:18:35 <hunt> jle`: do you want the whole thing?
01:19:21 <jle`> hunt: just not sure what the problem is :)
01:19:30 <jle`> if it's syntax, we'd need more to help
01:19:42 <hunt> jle`: genState makes an IO state, and the evalState runs on the unboxed state. im trying to generate a list of initial states and perform evalState on each state,
01:19:56 <hunt> jle`: i cant think of a way to do that besides fmap, which apparently doesnt work
01:20:57 <hunt> basically im trying to take a [IO a] and apply f a on each
01:21:09 <hunt> oh maybe i should use >>=
01:21:12 <jle`> hunt: what is the type of evalStateT (mapM_ runCommand comms)
01:21:32 <jle`> ah you're jumping ahead to the answer ;)
01:21:45 <hunt> jle`: i *can* get it to work with =<<
01:21:46 <hunt> jle`: ah ok
01:21:52 <hunt> jle`: is there a better way to do this?
01:22:09 <jle`> what's wrong with >>= ?
01:22:11 <hunt> jle`: cause im going to be mapping (=<< evalState ...)
01:22:32 <hunt> jle`: nothing it just seems like something that there might already be a function for
01:22:38 <jle`> so
01:22:41 <jle`> you want an IO a -> IO b
01:22:45 <jle`> er
01:23:07 <jle`> if you have an (a -> b), use fmap
01:23:14 <jle`> if you have an (a -> IO b), use =<<
01:23:27 <jle`> try
01:23:30 <hunt> jle`: ya ya ive got an idea
01:24:03 <jle`> so evalStateT (map blah) is State -> IO Something
01:24:15 <jle`> and genState 0 is an IO State
01:24:21 <jle`> so you want an IO State -> IO Something
01:24:58 <jle`> try
01:25:12 <jle`> test <- evalStateT (map blah) =<< initStates
01:27:09 <frerich> hunt: If you set 'let a = genState 0; b = evalStateT (mapM_ runCommand comms)' then your first version is 'fmap b a >>= \test ->' and the second one would be 'a >>= \state -> b state' -- did I see that right?
01:28:36 <jle`> man =<< looks so nice with <- syntax
01:29:06 <jle`> it...almost looks like arrow proc/do syntax
01:29:19 <jle`> x <- f =<< a
01:29:24 <jle`> x <- f -< a
01:29:29 <jle`> oh my
01:30:25 <jle`> why haven't i noticed this before
01:30:38 <eazar001> hahah
01:30:48 <jle`> please tell me that the fixity laws allow me to do something like
01:30:58 <eazar001> @src (=<<)
01:30:59 <lambdabot> f =<< x = x >>= f
01:30:59 <jle`> x <- h <=< g <=< f =<< y
01:31:14 <jle`> x <- g <=< f =<< y
01:31:16 <jle`> that'd be neat
01:31:25 <eazar001> yea it's pretty looking
01:31:36 <eazar001> i saw it first in the HTTP lib or something
01:32:47 <jle`> i guess it makes sense
01:33:02 <jle`> becuase >>= was always so friendly with lambda syntax and its ->
01:33:27 <eazar001> but =<< follows the path of the <-
01:33:29 <jle`> a >>= \x -> y >>= b
01:33:36 <jle`> with the \ and the ->
01:33:50 <jle`> and so i alaways thought =<< was awkward like that with no syntactic counterpart
01:33:53 <jle`> but i guess it does
01:33:55 <jle`> neat
01:35:06 <hunt> for anyone whos interested
01:35:10 <hunt> this is what i ended up using
01:35:34 <hunt> http://lpaste.net/105560
01:36:08 <jle`> hunt: there's a neat alias for sequence . map f
01:36:15 <jle`> in Prelude/Control.Monad
01:37:29 <jle`> mapM f = sequence . map f
01:44:28 <chrisdone> whyy: because i said so
01:45:23 <chrisdone> jle`: are you using arrow syntax for a standard of beauty?
01:46:05 <jle`> chrisdone: it is more the symmetry in and of itself
01:46:13 <jle`> between <- / =<< and <- / -<
01:46:21 <jle`> also it's cute because it looks like a little ascii arrow :3
01:52:10 <ski> hm, hadn't thought of it as similar to arrow syntax (though obviously had seen the symbols as symbolizing the direction of information flow)
01:55:39 <kgadek> `@pl \xs n -> take n xs ==> flip take
01:55:43 <kgadek> @pl \xs n -> take n xs ==> flip take
01:55:43 <lambdabot> flip flip (flip take) . ((==>) .) . flip take
01:56:07 <kgadek> @unmtl StateT s IO a ==> s -> IO (a, s)
01:56:07 <lambdabot> Plugin `unmtl' failed with: TypeOperators is not enabled
01:56:25 <kgadek> @undo do { x <- getLine; print x } ==> getLine >>= \ x -> print x
01:56:25 <lambdabot> getLine >>= \ x -> print x ==> getLine >>= \ x -> print x
01:56:36 <kgadek> @djinn (a, b) -> c -> (b, c) ==> f (_, a) b = (a, b)
01:56:36 <lambdabot> Cannot parse command
01:56:52 <kgadek> @hoogle [a] -> [a]
01:56:54 <lambdabot> Prelude cycle :: [a] -> [a]
01:56:54 <lambdabot> Data.List cycle :: [a] -> [a]
01:56:54 <lambdabot> Prelude init :: [a] -> [a]
01:58:27 <Maxdamantus> @djinn [a] -> [a]
01:58:27 <lambdabot> Error: Undefined type []
01:59:52 <kqr> why do i get so few hits for "ghc core" on google? is that intermediary representation formally called something else? (i mean, the flag isn't ddump-core, it's ddump-simpl)
02:10:00 * hackagebot pi-calculus 0.0.3 - Applied pi-calculus compiler  http://hackage.haskell.org/package/pi-calculus-0.0.3 (renzyq19)
02:12:24 <exicer> It looks like there are several options for processing commandline arguments. Which should I use for a simple utility ?
02:18:07 <johnw> I like optparse-applicative
02:18:13 <johnw> do you want a sample to guide you?
02:18:25 <exicer> johnw: That would be great
02:18:30 <johnw> check out Main.hs in https://github.com/jwiegley/pushme
02:18:34 <johnw> that's my latest use of it
02:21:19 <exicer> johnw: Cool, thanks.
02:22:59 <frerich> exicer: I like System.Console.CmdArgs, I used it e.g. https://github.com/frerich/lambdacrawler/blob/master/src/Arguments.hs
02:29:32 <eikke__> iirc dons once created a tool to (try to) figure out optimal GC settings for a program using a genetic algorithm. anyone got a pointer? google lets me down
02:31:38 <johnw> http://donsbot.wordpress.com/2009/03/09/evolving-faster-haskell-programs/?
02:31:48 <johnw> first google hit for "genetic algorithm optimal gc settings GHC"
02:33:14 <eikke__> johnw: yeah, but that's for compiler flags. I seem to remember something specific for GC, using a custom tool ,not acovea. I even see the fancy graphs from the post in my mind
02:33:53 <johnw> http://donsbot.wordpress.com/2010/07/05/ghc-gc-tune-tuning-haskell-gc-settings-for-fun-and-profit/?
02:34:54 <eikke__> johnw: thats it indeed, just found it as well
02:35:29 <matematikaadit> :t id
02:35:30 <lambdabot> a -> a
02:36:00 <Axman6> :t id id id
02:36:01 <lambdabot> a -> a
02:38:58 <Cale> :t id id id id id id id id id id
02:38:59 <lambdabot> a -> a
02:39:10 <johnw> idempotency ftw
02:39:27 <Cale> :t id id id id id id id id id id id id id id id id id id id id id
02:39:28 <lambdabot> a -> a
02:39:52 <Cale> istr there was something of this sort which required an exponential amount of space to typecheck
02:39:58 <Axman6> hmm, wasn't there something similar to that that used to cause huge type checking time blowups?
02:40:04 <Axman6> heh
02:40:13 <Axman6> that was what I was initially looking for
02:40:20 <dottedmag> > fix id
02:40:24 <lambdabot>  mueval-core: Time limit exceeded
02:40:28 <dottedmag> okay
02:40:29 <matematikaadit> that's reminds me of this question about "id" http://stackoverflow.com/questions/23746852/why-does-haskells-do-nothing-function-id-consume-tons-of-memory
02:40:46 <Cale> ah, yeah
02:41:18 <Axman6> :t let a = (,) in a . a . a . a . a . a . a . a $ 1
02:41:19 <lambdabot> Num s => b -> (b1 -> (b2 -> (b3 -> (b4 -> (b5 -> (b6 -> (b7 -> (s, b7), b6), b5), b4), b3), b2), b1), b)
02:41:23 <Axman6> :t let a = (,) in a . a . a . a . a . a . a . a
02:41:23 <lambdabot> a -> b -> (b1 -> (b2 -> (b3 -> (b4 -> (b5 -> (b6 -> (b7 -> (a, b7), b6), b5), b4), b3), b2), b1), b)
02:41:28 <shachaf> I think that as fixed in a new version of GHC.
02:41:32 <Cale> :t let f = id id id id id id id id id id id id id id id id id id id id id id id id id id id in f
02:41:33 <lambdabot> a -> a
02:41:37 <luzie> :t (flip id, flip ($))
02:41:38 <lambdabot> (b -> (b -> c) -> c, b1 -> (b1 -> c1) -> c1)
02:41:50 <Cale> hm, interesting that the same example seems to be fast now
02:41:52 <Axman6> hmm, that wasn't it. Ben L. had one that produced a huge type with a relatively small expression
02:42:00 <Axman6> :t let a = join (,) in a . a . a . a . a . a . a . a
02:42:01 <lambdabot> a -> ((((((((a, a), (a, a)), ((a, a), (a, a))), (((a, a), (a, a)), ((a, a), (a, a)))), ((((a, a), (a, a)), ((a, a), (a, a))), (((a, a), (a, a)), ((a, a), (a, a))))), (((((a, a), (a, a)), ((a, a), (a, a))), (((a, a), (a, a)), ((a, a), (a, a)))), ((((a, a), (a, a)), ((a, a), (a, a))), (((a, a), (a, a)), ((a, a), (a, a)))))), ((((((a, a), (a, a)), ((
02:42:01 <lambdabot> a, a), (a, a))), (((a, a), (a, a)), ((a, a), (a, a)))), ((((a, a), (a, a)), ((a, a), (a, a))), (((a, a), (a, a)), ((a, a), (a, a))))), (((((a, a), (a, a)), ((a, a), (a, a))), (((a, a), (a, a)), ((a, a), (a, a)))), ((((a, a), (a, a)), ((a, a), (a, a))), (((a, a), (a, a)), ((a, a), (a, a))))))), (((((((a, a), (a, a)), ((a, a), (a, a))), (((a, a), (
02:42:01 <lambdabot> a, a)), ((a, a), (a, a)))), ((((a, a), (a, a)), ((a, a), (a, a))), (((a, a), (a, a)), ((a, a), (a, a))))), (((((a, a), (a, a)), ((a, a), (a, a))), (((a, a), (a, a)), ((a, a), (a, a)))), ((((a, a), (a, a)), ((a, a), (a, a))), (((a, a), (a, a)), ((a, a), (a, a)))))), ((((((a, a), (a, a)), ((a, a), (a, a))), (((a, a), (a, a)), ((a, a), (a, a)))), (((
02:42:01 <lambdabot> (a, a), (a, a)), ((a, a), (a, a))), (((a, a), (a, a)), ((a, a), (a, a))))), (((((a, a), (a, a)), ((a, a), (a, a))), (((a, a), (a, a)), ((a, a), (a, a)))), ((((a, a), (a, a)), ((a, a), (a, a))), (((a, a), (a, a)), ((a, a), (a, a))))))))
02:42:02 <Cale> Maybe it's a performance improvement in the typechecker
02:42:04 <Axman6> that's it
02:42:05 <Axman6> >_>
02:42:16 <luzie> christ
02:42:23 <Axman6> heh
02:42:30 <Cale> :t let f x = (x,x); f1 x = f (f x); f2 x = f1 (f1 x); f3 x = f2 (f2 x) in f3
02:42:31 <lambdabot> t -> ((((((((t, t), (t, t)), ((t, t), (t, t))), (((t, t), (t, t)), ((t, t), (t, t)))), ((((t, t), (t, t)), ((t, t), (t, t))), (((t, t), (t, t)), ((t, t), (t, t))))), (((((t, t), (t, t)), ((t, t), (t, t))), (((t, t), (t, t)), ((t, t), (t, t)))), ((((t, t), (t, t)), ((t, t), (t, t))), (((t, t), (t, t)), ((t, t), (t, t)))))), ((((((t, t), (t, t)), ((
02:42:31 <lambdabot> t, t), (t, t))), (((t, t), (t, t)), ((t, t), (t, t)))), ((((t, t), (t, t)), ((t, t), (t, t))), (((t, t), (t, t)), ((t, t), (t, t))))), (((((t, t), (t, t)), ((t, t), (t, t))), (((t, t), (t, t)), ((t, t), (t, t)))), ((((t, t), (t, t)), ((t, t), (t, t))), (((t, t), (t, t)), ((t, t), (t, t))))))), (((((((t, t), (t, t)), ((t, t), (t, t))), (((t, t), (
02:42:31 <lambdabot> t, t)), ((t, t), (t, t)))), ((((t, t), (t, t)), ((t, t), (t, t))), (((t, t), (t, t)), ((t, t), (t, t))))), (((((t, t), (t, t)), ((t, t), (t, t))), (((t, t), (t, t)), ((t, t), (t, t)))), ((((t, t), (t, t)), ((t, t), (t, t))), (((t, t), (t, t)), ((t, t), (t, t)))))), ((((((t, t), (t, t)), ((t, t), (t, t))), (((t, t), (t, t)), ((t, t), (t, t)))), (((
02:42:31 <lambdabot> (t, t), (t, t)), ((t, t), (t, t))), (((t, t), (t, t)), ((t, t), (t, t))))), (((((t, t), (t, t)), ((t, t), (t, t))), (((t, t), (t, t)), ((t, t), (t, t)))), ((((t, t), (t, t)), ((t, t), (t, t))), (((t, t), (t, t)), ((t, t), (t, t))))))))
02:42:43 <Axman6> that's the one
02:43:24 <Cale> Standard sort of thing used to prove that typechecking is expensive
02:43:51 <dottedmag> It wouldn't fit on a stack of punched cards, yeah.
02:44:45 <Cale> In the asymptotic sense that you can have a sequence of programs of linearly increasing length, but whose types are exponential in size
02:47:26 <wz1000> @src filterM
02:47:26 <lambdabot> Source not found. I don't think I can be your friend on Facebook anymore.
02:47:37 <Axman6> :t filterM
02:47:38 <lambdabot> Monad m => (a -> m Bool) -> [a] -> m [a]
02:48:48 <Freundlich> Cale: It's hyperexponential even.
02:49:14 <Axman6> I'd guess: filterM p [] = return []; filterM p (x:xs) = p x >>= \b -> (if b then fmap (a:) else id) (filterM p xs)
02:49:25 <Axman6> hmm, that could've been clearer
02:49:48 <Axman6> > filterM (const [True, False]) "Hello"
02:49:49 <lambdabot>  ["Hello","Hell","Helo","Hel","Helo","Hel","Heo","He","Hllo","Hll","Hlo","Hl"...
02:50:44 <Axman6> > filterM (const [True, False]) [1,2,3,4]
02:50:46 <lambdabot>  [[1,2,3,4],[1,2,3],[1,2,4],[1,2],[1,3,4],[1,3],[1,4],[1],[2,3,4],[2,3],[2,4]...
02:51:26 <Axman6> does that function have a standard name? ordered subsets seems appropriate
02:53:46 <shachaf> No standard name.
03:04:54 * warpy writes java while listening to haskellcast. what a shame.
03:05:14 <hunt> how can i load a static library in ghci?
03:05:31 <hunt> im trying to test some functions that depend on functions from a lib.a
03:06:27 <hunt> these functions are too big not to test
03:18:39 <eazar001> Axman6: that function is the powerset
03:18:56 <eazar001> I think it's in the lists library or something, substrings
03:18:59 <Axman6> that's the one!
03:19:11 <eazar001> substrings?
03:19:14 <eazar001> or the formal name powerset?
03:19:22 <Axman6> yeah, powerset
03:19:35 <eazar001> yea, i don't know if they do it that way though, like you did ...
03:19:39 <eazar001> const [True, False]
03:19:53 <shachaf> powerset doesn't really describe operations on lists, since lists aren't sets.
03:19:56 <Axman6> I definitely didn't make it up
03:20:07 <eazar001> schachaf: true ...
03:20:09 <shachaf> Some people call that function "powerlist" but that's not very standard.
03:20:09 <eazar001> you can put duplicates in there
03:20:11 <Axman6> underpowerset
03:20:37 <eazar001> so technically it wouldn't be a set applied that function to [1,2,2]
03:20:54 <eazar001> if**
03:21:16 <eazar001> :hoogle substrings
03:21:21 <eazar001> @hoogle substrings
03:21:22 <lambdabot> Data.ByteString findSubstrings :: ByteString -> ByteString -> [Int]
03:21:22 <lambdabot> Data.ByteString.Char8 findSubstrings :: ByteString -> ByteString -> [Int]
03:21:57 <eazar001> foldr (const [True,False]) [1,2,3]
03:22:04 <eazar001> > foldr (const [True,False]) [1,2,3]
03:22:06 <lambdabot>  Couldn't match expected type â€˜[t] -> [t]â€™
03:22:06 <lambdabot>              with actual type â€˜[GHC.Types.Bool]â€™
03:22:14 <eazar001> > foldr (const [True,False]) [] [1,2,3]
03:22:15 <lambdabot>  Couldn't match expected type â€˜[t] -> [t]â€™
03:22:15 <lambdabot>              with actual type â€˜[GHC.Types.Bool]â€™
03:22:28 <eazar001> > filterM (const [True,False]) [] [1,2,3]
03:22:29 <eazar001> oops
03:22:30 <lambdabot>  Couldn't match expected type â€˜[t0] -> tâ€™ with actual type â€˜[[a0]]â€™
03:22:43 <eazar001> > filterM (const [True,False]) [1,2,3]
03:22:45 <lambdabot>  [[1,2,3],[1,2],[1,3],[1],[2,3],[2],[3],[]]
03:25:14 <eazar001> foldr (\x xs -> (map (\y -> x:y) ++ xs)     ) [[]] [1,2,3]
03:25:18 <eazar001> > foldr (\x xs -> (map (\y -> x:y) ++ xs)     ) [[]] [1,2,3]
03:25:19 <lambdabot>  Couldn't match expected type â€˜[[t]]â€™
03:25:19 <lambdabot>              with actual type â€˜[[a0]] -> [[a0]]â€™
03:25:19 <lambdabot>  Relevant bindings include
03:25:20 <lambdabot>    xs :: [[t]] (bound at <interactive>:1:11)
03:25:20 <lambdabot>    x :: a0 (bound at <interactive>:1:9)
03:25:39 <eazar001> > foldr (\x xs -> (map (\y -> x:y) xs)++ xs)     ) [[]] [1,2,3]
03:25:40 <lambdabot>  <hint>:1:48: parse error on input â€˜)â€™
03:26:49 <eazar001> > foldr (\x xs -> (map (\y -> x:y) xs) ++ xs     ) [[]] [1,2,3]
03:26:51 <lambdabot>  [[1,2,3],[1,2],[1,3],[1],[2,3],[2],[3],[]]
03:27:04 <eazar001> there we go, that's how you do it "un-moadically"
03:27:13 <eazar001> monadically
03:29:36 <eazar001> > foldr (\x xs -> (map (x:) xs) ++ xs     ) [[]] [1,2,3]
03:29:37 <lambdabot>  [[1,2,3],[1,2],[1,3],[1],[2,3],[2],[3],[]]
03:32:41 <eazar001> > drop 15 $ foldr (\x xs -> map (x:) xs ++ xs) [[]] [1,2,3,4]
03:32:42 <lambdabot>  [[]]
03:33:22 <eazar001> > drop 32 $ foldr (\x xs -> map (x:) xs ++ xs) [[]] "abcde"
03:33:23 <lambdabot>  []
03:33:30 <eazar001> > drop 31 $ foldr (\x xs -> map (x:) xs ++ xs) [[]] "abcde"
03:33:32 <lambdabot>  [""]
03:34:02 <Qfwfq> Is there a syntax extension for outfix type constructors yet?
03:34:25 <eazar001> > drop 1022 $ foldr (\x xs -> map (x:) xs ++ xs) [[]] "abcdefghij"
03:34:26 <lambdabot>  ["j",""]
03:36:33 <eazar001> Qfwfq: what's an outfix?
03:36:57 <Qfwfq> eazar001: Think '[a]'.
03:38:04 <eazar001> you mean a list of type a?
03:38:37 <frms_> or maybe circumfix.
03:38:41 <eazar001> oh i got it
03:38:47 <eazar001> i understand now
03:40:23 <robnea> hi, i'm having some trouble with using cabal on Fedora 20
03:40:43 <ski> > let combinations 0 as = return []; combinations _ [] = mempty; combinations n (a:as) = liftM (a:) (combinations (n-1) as) `mplus` combinations n as in combinations 3 "abcde" :: [String]
03:40:44 <lambdabot>  ["abc","abd","abe","acd","ace","ade","bcd","bce","bde","cde"]
03:41:29 <robnea> i have run 'cabal configure && cabal update && cabal install cabal', which fails when trying to install HTTP-4000.2.17
03:41:37 <eazar001> hey ski
03:42:07 <robnea> Apparently it cannot find module `Control.Monad.Error' and there are files missing in the `mtl-2.2.0.1' package
03:42:07 <ski> lo
03:42:13 <robnea> is this a known issue?
03:42:26 <eazar001> what do you mean it can't find the module?
03:42:36 <eazar001> is that exactly what it says?
03:43:07 <eazar001> are you in a sandbox?
03:44:16 <kqr> why do i get so few hits for "ghc core" on google? is that intermediary representation formally called something else? (i mean, the flag isn't ddump-core, it's ddump-simpl)
03:44:51 <shachaf> kqr: Usually people just call it Core.
03:44:58 <shachaf> That's the name of the language, as much as it has a name.
03:45:18 <shachaf> It's -ddump-simpl because it dumps the "simplified" Core, after optimization passes.
03:46:00 <shachaf> There are a whole bunch of other -ddump-x options that dump Core.
03:48:15 <shachaf> The GHC commentary has useful documentation on it.
03:48:18 <shachaf> https://ghc.haskell.org/trac/ghc/wiki/Commentary/Compiler/CoreSynType
03:48:33 <shachaf> It's a pretty straightforward language.
03:50:25 <kqr> shachaf, thank you. that page looks like exactly what i wanted in the first place
03:51:54 <robnea> eazar001: Network/Stream.hs:35:8:
03:51:55 <robnea>     Could not find module `Control.Monad.Error'
03:51:55 <robnea>     There are files missing in the `mtl-2.2.0.1' package,
03:51:55 <robnea>     try running 'ghc-pkg check'.
03:51:58 <robnea>     Use -v to see a list of the files searched for.
03:52:01 <robnea>  
03:52:13 <robnea> this is while "Preprocessing library HTTP-4000.2.17..."
03:52:58 <shachaf> What happened when you ran ghc-pkg check?
03:53:00 <robnea> my version of ghc is 7.6.3 from yum install haskell-platform on fedora 20, so i'm not sure what the problem could be
03:56:02 <robnea> shachaf: ghc-pkg -check gives 473 lines of output warning that various packages and directories don't exist. it starts with
03:56:06 <robnea> There are problems in package zlib-0.5.4.1:
03:56:06 <robnea>   Warning: library-dirs: /users/robnea/.cabal/lib/zlib-0.5.4.1/ghc-7.6.3 doesn't exist or isn't a directory
03:56:06 <robnea>  
03:56:27 <shachaf> Did you delete ~/.cabal and keep ~/.ghc or something?
03:57:23 <robnea> That sounds right, yes. The first time I ran into these problems I deleted .cabal, thinking that I was creating a "fresh" environment.
03:57:33 <shachaf> Then there you go.
03:57:40 <robnea> So I should delete both of these and start again?
03:57:52 <shachaf> ~/.ghc has package descriptions that refer to files in ~/.cabal
03:58:08 <shachaf> That is a thing you can do.
03:58:26 <shachaf> ("delete" means "rename until your new environment is working properly, just in case", of course.)
03:59:56 <robnea> Thanks for the suggestion, I have no idea how I would have found that otherwise!
04:01:03 <shachaf> A good start is always reading the error message. :-)
04:02:38 <robnea> I did try running ghc-pkg -check before, and I agreed with it that these files didn't exist (because I deleted ~/.cabal), but it didn't mention ~/.ghc, so I was a bit stumped after that.
04:03:44 <shachaf> Hmm.
04:03:56 <shachaf> Well, the fact that it's still looking for specific files in your home directory that don't exist is a clue.
04:04:14 <shachaf> One path after seeing that error message is to look for ways to get more information out of ghc-pkg check.
04:04:51 <shachaf> For example, ghc-pkg -v check will tell you which files it's looking at, and in particular starting with the one in ~/.ghc
04:05:14 <shachaf> Failing that, you could go for a blunt instrument like strace.
04:05:54 <robnea> Right, great, good point. I always forget about strace, but it has saved me a few times when nothing else seemed to help tracking things down.
04:07:34 <robnea> It's all working smoothly now, thanks again.
04:13:06 <hunt> what would it take for haskell not to be compiled to c before byte code?
04:13:27 <hunt> also is it feasable to write a fast compiler in haskell?
04:13:35 <hunt> i know you can write a really elegant one
04:13:37 <hunt> but fast?
04:14:38 <hunt> im wondering cause im writing a parser with parsec and its beautiful and pretty clear how easy it would be to write an interpreter with parsec, but im not sure if i could write a serious interpreter
04:14:53 <bergmark> doesn't ghc have a native code generator too?
04:15:10 <Axman6> hunt: haskell isn't compiled to C anymore
04:15:11 <hunt> bergmark: i thought it went through c first? im not sure
04:15:46 <Axman6> it used to use C, but it was somewhat hacky. now GHC has both a native code generator and an LLVm code generator
04:16:05 <hunt> Axman6: oh wonderful, thats awesome. is it not missing out though on the many millions of optimizations gcc has?
04:16:16 <Axman6> screw gcc :P
04:16:26 <hunt> Axman6: seems like itd be hard to compete with all those optimizations though
04:16:28 <Axman6> but LLVM has comparable performance to GCC's output anyway
04:16:32 <barrucadu> It gets the millions of optimisations LLVM has instead!
04:16:47 <hunt> Axman6: is llvm pretty much the same as compiling to  c?
04:16:49 <Axman6> the code produced by the NCG is quite good too
04:17:02 <Axman6> hunt: no, it's a lot more flexible
04:17:20 <hunt> Axman6: its like a c bnut dwesigned to be compiled to
04:17:36 <Axman6> it's much closer to assembly
04:18:20 <hunt> Also they say LLVM isnt an acronym on their website, but it mustve meant something right? like "Low Level Virtual Machine"?
04:18:31 <Axman6> hunt: both the NCG and the LLvm backends produce faster code than the c backend using GCC ever did btw
04:18:37 <Iceland_jack> hunt: Yes once
04:18:42 <Axman6> that's exactly what it used to be
04:19:15 <Axman6> but the project has grown a lot and includes many subprojects that nave little to do with any sort of virtual machine (and there never really was much of a VM anywhere)
04:19:33 <boothead> how does one call cabal repl with defer-type-errors? I've tried cabal repl -fdefer-type-errors...
04:19:52 <Axman6> boothead: possible cabal repl -- <flags>?
04:19:55 <Axman6> possibly*
04:19:59 <hunt> Axman6: i shyed away from it for a really long time because i thought it was a VM
04:20:25 <Iceland_jack> boothead: 'cabal help repl' says --PROG-option=...
04:21:52 <boothead> Iceland_jack, thanks, what's PROG here?
04:21:59 * hackagebot parconc-examples 0.3.3 - Examples to accompany the book "Parallel and Concurrent Programming in Haskell"  http://hackage.haskell.org/package/parconc-examples-0.3.3 (SimonMarlow)
04:22:01 * hackagebot parconc-examples 0.3.4 - Examples to accompany the book "Parallel and Concurrent Programming in Haskell"  http://hackage.haskell.org/package/parconc-examples-0.3.4 (SimonMarlow)
04:22:19 <Iceland_jack> boothead: part of the flag
04:22:25 <ski> > let partitions :: MonadPlus m => [a] -> m [[a]]; partitions = foldr (\a mps -> mps >>= \ps -> return ([a]:ps) `mplus` onElement (return . (a:)) ps) (return []) in map unwords (partitions "abcd" :: [[String]])
04:22:27 <lambdabot>  ["a b c d","ab c d","b ac d","b c ad","a bc d","abc d","bc ad","a c bd","ac ...
04:22:29 <Iceland_jack> remains unchanged
04:22:46 <ski> > let partitions :: MonadPlus m => [a] -> m [[a]]; partitions = foldr (\a mps -> mps >>= \ps -> onElement (return . (a:)) ps `mplus` return ([a]:ps)) (return []) in map unwords (partitions "abcd" :: [[String]])
04:22:48 <lambdabot>  ["abcd","a bcd","ab cd","b acd","a b cd","abc d","bc ad","a bc d","ac bd","c...
04:23:27 <boothead> Iceland_jack, must be friday, but I'm still not sure how to translate that to -fdefer-type-errors
04:23:34 <ski> hm, would it be more natural to start with the finest or the coarsest partition ?
04:24:21 <Iceland_jack> boothead: when you type 'cabal help repl' it says
04:24:21 <Iceland_jack>     --PROG-options=OPT   give an extra option to PROG (no need to quote options containing spaces)
04:24:39 <Iceland_jack> *PROG-option*
04:24:55 <Iceland_jack> So presumably that would be something like
04:24:55 <Iceland_jack>     cabal repl --PROG-option=-fdefer-type-errors
04:25:34 <Axman6> I think iy would be --ghc-option=-fdefer-type-errors
04:25:38 <boothead> Iceland_jack, I tried that first :-) : cabal: unrecognized option `--PROG-option=-fdefer-type-errors'
04:25:59 <boothead> Axman6, that's the puppy!
04:25:59 <Axman6> PROG needs to be replaced with the name of the program that the argument is to be passed to
04:26:25 <boothead> Axman6, what would be other things you could pass to PROG just out of interest?
04:27:01 <Axman6> ld and opt come to mind (the linker and the llvm optimiser if using -fllvm)
04:27:16 <boothead> ah thanks, interesting :-)
04:27:22 <ski> > let partitions :: MonadPlus m => [a] -> m [[a]]; partitions = foldr (\a mps -> mps >>= \ps -> return ([a]:ps) `mplus` liftM (\(p,ps) -> (a:p):ps) (select ps)) (return []) in map unwords (partitions "abcd" :: [[String]])
04:27:24 <lambdabot>  ["a b c d","ab c d","ac b d","ad b c","a bc d","abc d","ad bc","a bd c","abd...
04:27:45 <Axman6> also cpp potentially
04:28:29 <osa1> let's say I have typeclass T defined in my package. does adding a new instance for that typeclass count as "breaking change"? should I care about users who have orphan instances? I'm trying to decide how to bump version number after this change.
04:29:22 <bergmark> osa1: the pvp was changed recently so adding non-orphan instances is now just a minor bump
04:29:37 <osa1> bergmark: what's pvp?
04:29:49 <osa1> bergmark: but that'll break some widely used app in my case
04:29:54 <bergmark> @where package versioning policy
04:29:54 <lambdabot> I know nothing about package.
04:30:16 <bergmark> @google package versioning policy
04:30:17 <lambdabot> http://www.haskell.org/haskellwiki/Package_versioning_policy
04:30:18 <lambdabot> Title: Package versioning policy - HaskellWiki
04:30:53 <osa1> bergmark: thanks, I'll check that.
04:32:35 <Tjr> How long did it take you to understand how doubly linked lists work in Haskell?
04:32:50 <Tjr> http://www.haskell.org/haskellwiki/Tying_the_Knot
04:32:56 <ski> @where pvp
04:32:56 <lambdabot> http://www.haskell.org/haskellwiki/Package_versioning_policy
04:33:12 <bergmark> osa1: your widely used app should have a minor dependency on the package that defines the class to be safe
04:33:58 <bergmark> ... and the pkg that defines the type
04:34:16 <osa1> bergmark: the problem is that app is not mine :P maybe I can send an email to the author or wait for more changes before pushing to hackage
04:34:28 <ski> Tjr : the basic idea isn't that hard to understand, but grokking how to construct it is harder
04:35:47 <Tjr> ski: yeah. So that means I'm not excessively stupid if I don't understand the constructor right away?
04:36:39 <ski> (by "constructor" itym `mkDList')
04:36:45 <ski> Tjr : *nod*
04:36:48 <zipper> Finally, I've been waiting for so long. Haskell cast 7.
04:36:53 <ski> it may take a while to sink in
04:37:15 <ski> > let fibs = 0 : 1 : zipWith (+) fibs (tail fibs)
04:37:17 <lambdabot>  not an expression: â€˜let fibs = 0 : 1 : zipWith (+) fibs (tail fibs)â€™
04:37:22 <ski> > let fibs = 0 : 1 : zipWith (+) fibs (tail fibs) in fibs
04:37:24 <lambdabot>  [0,1,1,2,3,5,8,13,21,34,55,89,144,233,377,610,987,1597,2584,4181,6765,10946,...
04:37:35 <ski> Tjr : if you've seen and understand that ^ one, it may help
04:38:16 <Axman6> Tjr: I found the code harder to read than understanding the concept. I'm not sure I could reconstruct it from memory if asked to
04:38:43 <Tjr> ski: yes, that's pretty obvious (and well-written code).
04:39:04 <bergmark> osa1: it's possible to change depndency ranges on hackage now without uploading a new version so you could ask them to do that
04:39:36 <osa1> that also makes sense. I didn't know that's possible, thanks.
04:39:52 <bergmark> osa1: it was enabled just a few days ago :-)
04:40:37 <t7> zipper: that episode sound pretty interesting
04:41:20 <ski> Tjr : understanding `repMin' may also help
04:41:30 * Tjr googles repMin
04:41:56 <ski> the task is to replace every element of a tree with the minimum of all the elements in the tree, with only one traversal of the tree
04:42:36 <ski> (or you can replace each element with that element minus the average of all elements, if you prefer a variant that doesn't leave all the elements of the resulting tree the same)
04:43:56 <ski> @let data LeafTree a = Leaf a | Branch (LeafTree a) (LeafTree a) deriving Show
04:43:59 <lambdabot>  Defined.
04:51:05 <ski> > let repMin :: Ord a => LeafTree a -> LeafTree a; repMin t0 = m_t1 m where (m,m_t1) = loop t0; loop :: Ord a => LeafTree a -> (a,a -> LeafTree a); loop (Leaf a) = (a,\m -> Leaf m); loop (Branch l0 r0) = (lm `min` rm,\m -> Branch (m_l1 m) (m_r1 m)) where (lm,m_l1) = loop l0; (rm,m_r1) = loop r0 in repMin (Branch (Leaf 3) (Branch (Leaf 2) (Leaf 4)))
04:51:06 <lambdabot>  Branch (Leaf 2) (Branch (Leaf 2) (Leaf 2))
04:51:19 <ski> Tjr : can you follow that, staged, version ?
04:51:31 <Tjr> ski: I'm reading http://www.haskell.org/haskellwiki/Circular_programming#Repmin_problem . How would the compiler this?
04:51:31 <Tjr> evaluage trace f input = let (output, feedback) = f (input, feedback)
04:51:31 <Tjr>                 in output
04:52:59 <ski> Tjr : yes ?
04:54:17 <Tjr> ski: so I'm trying to wrap my head around how the compiler evaluates the example on the wiki.
04:54:32 <ski> the staged `repMin' above (or really its helper `loop' function) takes a tree and returns a pair of the minimum as found in *that* tree, together with a *function* that when given the *global* minimum (which could be other than the minimum of the *current* tree) constructs the replacement tree of the (current) tree, with all elements replaced by the (global) minimum
04:54:40 <Axman6> Tjr: do you understand how thunks are compiled?
04:54:45 <Axman6> roughly?
04:54:58 <ski> > let repMin :: Ord a => LeafTree a -> LeafTree a; repMin t0 = t1 where (m,t1) = loop t0 m; loop :: Ord a => LeafTree a -> a -> (a,LeafTree a); loop (Leaf a) m = (a,Leaf m); loop (Branch l0 r0) m = (lm `min` rm,Branch l1 r1) where (lm,l1) = loop l0 m; (rm,r1) = loop r0 m in repMin (Branch (Leaf 3) (Branch (Leaf 2) (Leaf 4)))
04:54:59 <lambdabot>  Branch (Leaf 2) (Branch (Leaf 2) (Leaf 2))
04:55:36 <ski> is the cyclic version of that (the one of the wiki does basically the same as well)
04:55:46 <ski> Tjr : for the cyclic version, part of the output gets fed back as input to the *same* call that is producing that output
04:55:46 <Tjr> trace f input
04:55:47 <Tjr> output
04:55:47 <Tjr> fst f (input, feedback)
04:55:47 <Tjr> fst f (input, fst f (input, feedback))
04:55:47 <Tjr> fst f (input, fst f (input, fst f (input, feedback)))
04:55:47 <Tjr> ...
04:56:26 <Tjr> So I'm wondering -- either f terminates after one step, or you're going round and round the loop forever.
04:57:34 <ski> Tjr : the difference between the staged and the cyclic versions is that in the former, we pass the "early input" (original tree), getting an "early output" (local minimum), and a function taking a "late input" (global minimum) and returning a "late output" (tree with elements replaced by global minimum)
04:58:18 <Tjr> I'll get to the tree in a minute. Please help me understand the trace function first.  http://www.haskell.org/haskellwiki/Circular_programming#Repmin_problem
04:58:44 <ski> Tjr : while for the latter, we, somehow, pass the "late input" (global minimum) "*before*" getting back the "early output" (local minimum)
04:58:53 <ski> Tjr : do you understand `fix' ?
04:59:02 <Tjr> I've never heard of fix
04:59:10 <ski>   fix f = x
04:59:13 <ski>     where
04:59:15 <ski>     x = f x
04:59:23 <ski> > fix (1 :)
04:59:24 <lambdabot>  [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1...
04:59:31 <ski> @src fix
04:59:31 <lambdabot> fix f = let x = f x in x
04:59:53 <Tjr> I'd imagine the compiler tries to evaluate "fix f" like this:
05:00:13 <BoR0> f (f (f (f...
05:00:14 <ski> `fix' takes a function, here called `f', and calls `f' on an argument that is the result of this same call to `f', this result is also returned by `fix f'
05:00:32 <Tjr> fix f
05:00:32 <Tjr> f (fix f)
05:00:32 <Tjr> f (f (fix f))
05:00:33 <Tjr> ... -- at this point, the compiler gets into an infinite loop
05:00:59 <ski> because of non-strict evaluation, it doesn't need to get into an infinite loop
05:01:41 <Tjr> So even if f is a mathematical function from [0,1] to [0,1], with a true fixed point, that information should never get passed to the part of the compiler running in circles
05:01:50 <ski> calling `fix (1 :)' basically evaluates to `let x = 1 : x in x', which constructs a "cyclic list", which in terms of implementation probably only contains a *single* cons cell
05:02:05 <Cale> Tjr: Well, no, but it does result in a cycle in the expression graph at runtime.
05:02:54 <Cale> Tjr: Which means that you can end up with defined data structures as the result of applying fix to various functions.
05:03:14 <ski> > fix (1 +)  -- obviously doesn't work
05:03:19 <lambdabot>  mueval-core: Time limit exceeded
05:03:24 <ski> > fix (0 *)  -- doesn't work either
05:03:28 <lambdabot>  mueval-core: Time limit exceeded
05:03:39 <Axman6> > fix (0 *) :: Nat
05:03:41 <lambdabot>  Not in scope: type constructor or class â€˜Natâ€™
05:03:43 <Cale> Tjr: fix finds the least-defined fixed point of the function though, so if f _|_ is _|_, then fix f will be _|_
05:03:43 <Axman6> :(
05:03:48 <ski> (even though `0' *is*, mathematically speaking, a fixpoint of `(0 *)')
05:03:56 <BoR0> > let fact = \f x -> if x == 0 then 1 else x * f (x - 1) in fix fact 3
05:03:56 <Tjr> > let { fix f = (let x = f x in x)  ;  f:: Reals -> Reals ; f y = y/2 +1 } in fix f
05:03:58 <lambdabot>  Not in scope: type constructor or class â€˜Realsâ€™
05:03:58 <lambdabot>  Perhaps you meant â€˜Realâ€™ (imported from Prelude)Not in scope: type construct...
05:03:58 <lambdabot>  Perhaps you meant â€˜Realâ€™ (imported from Prelude)
05:03:58 <lambdabot>  can't find file: L.hs
05:04:04 <ski> (here i was intending the `Integer' type)
05:04:19 <ski> s/Reals/Double/ ?
05:04:59 <ski> > fix show  -- is another classic
05:05:00 <lambdabot>  "\"\\\"\\\\\\\"\\\\\\\\\\\\\\\"\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"\\\\\\\\\\\\\...
05:05:11 <Cale> Where here, _|_ is ascii art for the symbol used to represent the bottom of an ordering. It's used to represent a computation which is nonterminating or which throws an exception.
05:05:15 <Axman6> > fix (\f x -> x/2+1 : f x) 3
05:05:15 <snyp> for record value constructors, what if the field name functions of 2 different types are the same?
05:05:17 <lambdabot>  [2.5,2.5,2.5,2.5,2.5,2.5,2.5,2.5,2.5,2.5,2.5,2.5,2.5,2.5,2.5,2.5,2.5,2.5,2.5...
05:05:32 <Axman6> > fix (\f x -> x/2+1 : f x) pi :: CReal
05:05:33 <lambdabot>  Couldn't match expected type â€˜Data.Number.CReal.CRealâ€™
05:05:33 <lambdabot>              with actual type â€˜[a0]â€™
05:05:33 <lambdabot>  Relevant bindings include
05:05:33 <lambdabot>    x :: a0 (bound at <interactive>:1:9)
05:05:33 <lambdabot>    f :: a0 -> Data.Number.CReal.CReal (bound at <interactive>:1:7)Couldn't ma...
05:05:39 <Axman6> > fix (\f x -> x/2+1 : f x) pi :: [CReal]
05:05:41 <lambdabot>  [2.5707963267948966192313216916397514420986,2.570796326794896619231321691639...
05:05:53 <Axman6> does that converge to something?
05:06:24 <snyp> data Person = Person {name :: String, id :: Integer }; data School = School { name :: String, established :: Int }
05:06:28 <Tjr> Axman6: mathematically, it converges exponentially fast. However, Haskell code I can't tell
05:06:35 <snyp> what about the name field ?
05:06:44 <snyp> both Person and School have it..
05:07:01 <Tjr> :i fix
05:07:05 <Tjr> hmm
05:07:09 <Tjr> @i fix
05:07:09 <lambdabot> Maybe you meant: id ignore index instances instances-importing irc-connect irc-password v @ ? .
05:07:14 <Cale> :t fix
05:07:15 <lambdabot> (a -> a) -> a
05:07:16 <Axman6> snyp: in the past they could conflict, but I think the latest GHC has the ability to cope with it based on the type of the argument
05:07:24 <snyp> Axman6, i see
05:07:33 <Tjr> Cale: so who do I get the function's definition, not just the type?
05:07:34 <ski> Tjr : note that with `fix' on a numeric function, you wouldn't get a (conceptual) sequence of number (which might or mightn't converge, mathematically speaking)
05:07:39 <snyp> Axman6, what are haskell coding conventions regarding this?
05:07:39 <Cale> @src fix
05:07:39 <lambdabot> fix f = let x = f x in x
05:07:49 <Cale> (though this just reads it from a text file)
05:08:04 <snyp> Axman6, should i do like personName, personId, personBlah ?
05:08:19 <Axman6> snyp: in the past, they were "don't do that", use some kind of prefix on the names. these type directed name resolution (TDNR) should be able to resolve it
05:08:26 <Axman6> snyp: yeah, something like that
05:08:27 <snyp> ohk
05:08:41 <Axman6> @google type directed name resolution haskell
05:08:41 <Tjr> So let me try to trace the evaluation of "fix (\a -> a/2 +1)"
05:08:43 <lambdabot> http://www.haskell.org/haskellwiki/TypeDirectedNameResolution
05:08:43 <lambdabot> Title: TypeDirectedNameResolution - HaskellWiki
05:08:50 <warpy> Axman6: it still conflicts
05:08:54 <snyp> hmm
05:09:00 <Tjr> calling f = (\a -> a/2 +1)
05:09:03 <Axman6> warpy: with TDNR?
05:09:04 <warpy> > data Person = Person {name :: String, id :: Integer }; data School = School { name :: String, established :: Int }
05:09:06 <lambdabot>  <hint>:1:1: parse error on input â€˜dataâ€™
05:09:20 <Cale> If you want to see the real definition, http://www.haskell.org/ghc/docs/latest/html/libraries/base-4.7.0.0/Data-Function.html -- you can click on the Source link on the right here, in this case, lambdabot has the code exactly as it exists in base.
05:10:06 <ski> Tjr : `fix (\a -> a/2 +1)' loops infinitely, though. it might be more interesting with an example that doesn't do that -- but go ahead if you want to
05:10:36 <Tjr> It shouldn't loop because it should converge to a=2
05:10:53 <Cale> Tjr: No, because (\a -> a/2 + 1) undefined = undefined
05:10:54 <BoR0> let test = (\f x -> (x/2 + 1) : f(x/2 + 1)) in fix test 3
05:10:56 <warpy> Axman6: test.hs:1:79:   Multiple declarations of ‘name’    Declared at: test.hs:1:23                 test.hs:1:79
05:10:59 <BoR0> > let test = (\f x -> (x/2 + 1) : f(x/2 + 1)) in fix test 3
05:11:01 <lambdabot>  [2.5,2.25,2.125,2.0625,2.03125,2.015625,2.0078125,2.00390625,2.001953125,2.0...
05:11:07 <Axman6> warpy: have you turned on TDNR?
05:11:13 <Cale> Tjr: and undefined is less defined than anything else, so that's the fixed point it finds.
05:11:19 <BoR0> Tjr, that converges to 2
05:11:25 <Cale> Tjr: fix finds the least defined fixed point of a function
05:11:33 <warpy> Axman6: how do i do that
05:11:41 <ski> <Cale> Tjr: fix finds the least-defined fixed point of the function though, so if f _|_ is _|_, then fix f will be _|_
05:11:45 <ski> Tjr ^
05:12:23 <ski> <Cale> Where here, _|_ is ascii art for the symbol used to represent the bottom of an ordering. It's used to represent a computation which is nonterminating or which throws an exception.
05:12:48 <Cale> Tjr: Note that for instance (1:) undefined is not itself undefined -- for example, head (1 : undefined) = 1, whereas head undefined is undefined, so they're different.
05:12:52 <Axman6> warpy: add {-# LANGUAGE TypeDirectedNameResolution #-} to the top of your file or use -XTypeDirectedNameResolution when calling GHC(i) (or use :set -XTypeDirectedNameResolution inside ghci)
05:12:58 <Cale> So undefined is not a fixed point of the function (1:)
05:12:59 <Tjr> the compiler doesn't know what "fix (\a -> a/2 +1) 3" is when it first finds it, so it goes to fetch the definition of "fix  funciton". The starting point 3 shouldn't be applied at all.
05:13:02 <BoR0> hm, for f(x) = x/2 + 1, how do you show that f^n(x) converges to 2 (mathematically) ?
05:13:12 <Cale> Tjr: That expression is a type error
05:13:26 <warpy> Axman6: ghc: unrecognised flag: -XTypeDirectedNameResolution
05:13:39 <Axman6> warpy: which version of ghc?
05:13:41 <warpy> on ghc 7.8.2
05:13:56 <Cale> (Well, it requires an instance of Num for functions which doesn't happen to exist normally)
05:14:11 <Cale> (and Fractional)
05:14:15 <ski> Tjr : `fix (\a -> a/2 +1) 3' is a type error (assuming say the numbers are `Double's)
05:14:33 <ski> `fix' doesn't take a "starting guess approximation"
05:14:48 <Cale> > fix (\x -> 1:x)
05:14:50 <lambdabot>  [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1...
05:14:54 <Axman6> warpy: hmm, it might not actually be implemented yet
05:14:59 <Cale> > fix (\x -> x/2)
05:15:03 <lambdabot>  mueval-core: Time limit exceeded
05:15:04 <ski> > fix (\s -> ". " ++ s)
05:15:06 <lambdabot>  ". . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . ....
05:15:06 <warpy> Axman6: is what i said
05:15:09 <d3m1g0d-> (\a -> a + 1) 3
05:15:23 <ski> d3m1g0d- : you forgot `> '
05:15:23 <d3m1g0d-> fix (\a -> x/2) 3
05:15:27 <Tjr> BoR0: in maths, observe | f^(n+1) x - f^(n+1) y| <= 1/2 * | f^n x - f^n y|
05:15:27 <Tjr> By induction, |f^n x - f^n y| <= 2^(-n) |x-y|. That (and compactness of the domain of f) gives you a cauchy sequence.
05:16:02 <d3m1g0d-> >fix (\x -> x/2) 6
05:16:05 <d3m1g0d-> like this ? o_O
05:16:16 <ski> d3m1g0d- : missing the ` ' after the `>'
05:16:37 <d3m1g0d-> > fix (\x -> x/2) 6
05:16:38 <lambdabot>  Could not deduce (GHC.Num.Num a0)
05:16:38 <lambdabot>    arising from the ambiguity check for â€˜e_126â€™
05:16:38 <lambdabot>  from the context (GHC.Num.Num a, GHC.Real.Fractional (a -> t))
05:16:38 <lambdabot>    bound by the inferred type for â€˜e_126â€™:
05:16:38 <lambdabot>               (GHC.Num.Num a, GHC.Real.Fractional (a -> t)) => t
05:16:54 <ski> > fix (\x -> x / (2 :: Double)) 6
05:16:56 <lambdabot>  Couldn't match expected type â€˜a0 -> tâ€™
05:16:56 <lambdabot>              with actual type â€˜GHC.Types.Doubleâ€™
05:16:56 <lambdabot>  Relevant bindings include x :: a0 -> t (bound at <interactive>:1:7)
05:17:08 <Tjr> Cale: why are you saying that "fix (\a -> a/2 +1) 3" is a type error?
05:17:11 <Axman6> ski: that doesn't take an argument
05:17:18 <ski> Tjr : i said that
05:17:21 <ski> Axman6 : i know, that's the point
05:17:27 <Axman6> ah, ok =)
05:17:36 <Cale> Tjr: The method being used to find fixed points here only uses a directed-complete partial ordering which exists for every datatype, and roughly speaking x <= y in this type if occurrences of _|_ in x can be replaced by other values to obtain y.
05:17:43 <BoR0> :t fix
05:17:44 <lambdabot> (a -> a) -> a
05:17:48 <Cale> er, s/in this type/in this ordering/
05:18:03 <Cale> Tjr: because fix :: (a -> a) -> a
05:18:18 <Cale> Tjr: So if you expect that (\a -> a/2 + 1) :: Double -> Double for instance
05:18:19 <d3m1g0d-> > (\x -> x / 2) 6
05:18:19 <ski>   âŠ¥ âŠ‘ x
05:18:21 <lambdabot>  3.0
05:18:26 <Cale> Then fix (\a -> a/2 + 1) :: Double
05:18:37 <Cale> and applying it to another parameter is a type error
05:18:45 <Cale> (because it's just a number)
05:18:59 <BoR0> > let test = (\f -> \x -> (x/2 + 1) : f(x/2 + 1)) in fix test 3
05:19:01 <lambdabot>  [2.5,2.25,2.125,2.0625,2.03125,2.015625,2.0078125,2.00390625,2.001953125,2.0...
05:19:07 <Tjr> ah, so fix cannot be handed a starting point to interate from.
05:19:25 <d3m1g0d-> :t zipWith
05:19:25 <Axman6> sure it can
05:19:26 <lambdabot> (a -> b -> c) -> [a] -> [b] -> [c]
05:19:27 <Cale> Tjr: Right, ski said this a while ago
05:19:41 <Cale> Tjr: However, see BoR0's trick here
05:19:44 <d3m1g0d-> > zipWith (\a b -> (a * 30 + 3) / b) [5,4,3,2,1] [1,2,3,4,5]
05:19:45 <lambdabot>  [153.0,61.5,31.0,15.75,6.6]
05:19:54 * Tjr has trouble keeping up reading and thinking.
05:20:28 <BoR0> fix test 3 = (fix test) 3, so it's test (test (test (... 3)))
05:20:40 <Cale> Tjr: Pretty much any recursive computation can be expressed using fix instead of recursion (not sure about polymorphic recursion though)
05:20:40 <BoR0> and test =s (\f -> \x -> (x/2 + 1) : f(x/2 + 1))
05:20:53 <Cale> Tjr: Consider this:
05:21:17 <Cale> > fix (\fac n -> if n == 0 then 1 else n * fac (n-1)) 10
05:21:19 <lambdabot>  3628800
05:21:30 <Cale> Not sure why lambdabot was so slow there :)
05:21:43 <Tjr> BoR0's trick is a neat way to find the iterative sequence of approximations that should converge to a fixed point. In a maths sense, it's neat. In a haskell sense, I'm not sure how it helps me understand "fix (\a -> a/2 +1)"
05:21:59 <ski>   âŠ¥  âŠ‘  (âŠ¥,âŠ¥)  âŠ‘  (Just âŠ¥,âŠ¥)  âŠ‘  (Just âŠ¥,âŠ¥ : âŠ¥)  âŠ‘  (Just âŠ¥,âŠ¥ : âŠ¥ : âŠ¥)  âŠ‘  (Just âŠ¥,âŠ¥ : 3 : âŠ¥)  âŠ‘  (Just False,âŠ¥ : 3 : âŠ¥)  âŠ‘  (Just False,âŠ¥ : 3 : [])  âŠ‘  (Just False,5 : 3 : [])
05:22:10 <sroberts> NICK samr
05:22:11 <ski> Tjr : that ^ shows an example of the definedness ordering
05:22:16 <Cale> Right, it doesn't, it just shows a way to use fix to get hold of the sequence of approximations using a starting point
05:23:22 <d3m1g0d-> i need a 3rd monitor especially for that chat
05:24:01 <Axman6> samr: heh, that remined me of a simpson's episode, "I'll call him Homer S., no wait, H Simpson!" (or something like that)
05:24:06 <ski> Tjr : you could think of a convergence sequence like BoR0's, only always starting with âŒœâŠ¥âŒ
05:24:20 <Cale> Tjr: To be quite a lot more vague than we've been already, the arithmetic operations on Doubles don't contribute any information without complete information about their inputs.
05:24:29 <ski> Tjr : for `fix (1 :)', you'd get the ordered sequence :
05:25:01 <Cale> (and in fact, every Double is either _|_ or it is totally defined in the sense of the definedness ordering)
05:25:02 <ski>   âŠ¥  âŠ‘  1 : âŠ¥  âŠ‘  1 : 1 : âŠ¥  âŠ‘  1 : 1 : âŠ¥  âŠ‘  1 : 1 : âŠ¥  âŠ‘  â‹¯
05:25:13 <BoR0> ski can you explain this notation to me?  âŠ¥  âŠ‘  (âŠ¥,âŠ¥)
05:25:22 <BoR0> bottom is subset of two bottoms...?
05:25:26 <Tjr> ski: so you're saying your example for a definedness-ordering is the path that a chompski-level-3-langue substitution ruleset traces from the starting point to the desired expression, where the ruleset can replace _|_ with anything?
05:25:35 <samr> axman6: apparently samr's not the name of my old nick either ... I was so sure it would be one of those two ...
05:25:37 <Cale> BoR0: That says _|_ is less defined than or equal to (_|_, _|_)
05:25:49 <Axman6> samr: heh, fair enough =)
05:25:55 <Cale> (but really, it's strictly less defined)
05:25:56 <ski> BoR0 : âŒœâŠ¥âŒ ("bottom") is the symbol from domain theory used for the "value" "undefined"
05:26:15 <d3m1g0d-> what kind of mathematics are  these notations part of
05:26:27 <BoR0> what d3m1g0d- asked :) I'd like to read more into that theory
05:26:28 <ski> domain theory
05:26:54 <ski> ties in with denotational semantics
05:27:08 <Cale> Tjr: It's kind of like that. Really, you need a specific definition of the definedness ordering for each type
05:27:18 <Tjr> now that makes a lot more sense
05:27:31 <Cale> Tjr: But _|_ is always present (at least in Haskell)
05:27:41 <Cale> :t fix id
05:27:42 <lambdabot> a
05:28:02 * hackagebot string-combinators 0.6.0.5 - Polymorphic functions to build and combine stringlike values  http://hackage.haskell.org/package/string-combinators-0.6.0.5 (BasVanDijk)
05:28:08 <ski> Tjr : you could think of âŒœâŠ¥âŒ as the zeroeth approximation of `fix (1 :)', âŒœ1 : âŠ¥âŒ as the oneth approximation, âŒœ1 : 1 : âŠ¥âŒ as the twoth approximation, âŒœ1 : 1 : 1 : âŠ¥âŒ as the third approximation, &c.
05:28:11 <Cale> fix id will always be an infinite loop
05:28:16 <cow_2001> an ever looming butt
05:28:36 <ski> Tjr : in this case, you only get the "real answer" in the limit (as opposed to before, at a finite stage)
05:28:55 <d3m1g0d-> you guys are phd students ? That part of mathematics "Domain Theory" looks pretty advanced
05:29:22 <d3m1g0d-> actually not advanced, but rather "specific"
05:29:23 <Cale> d3m1g0d-: I only have a BMath and got out of academia after that
05:29:31 <ski> so, we're in some sense using âŒœâŠ¥âŒ as a canonical "zero" approximation/guess, regardless of the type of the expression to compute
05:29:34 <Cale> But I study lots of stuff on my own :)
05:29:44 <Tjr> So you're saying the compiler equips the set of finite strings with the definedness ordering, takes _|_ as a starting value, and substitutes the definition of (fix f = let x = f x in x) into _|_ iterativling, stopping when the definedness ordering doesn't increase anymore?
05:30:23 <BoR0> Cale, what domains of math did you study at academia?
05:30:45 <ski>   âŠ¥  âŠ‘  f âŠ¥  âŠ‘  f (f âŠ¥)  âŠ‘  f (f (f âŠ¥))  âŠ‘  f (f (f (f âŠ¥)))  âŠ‘  â‹¯
05:31:03 <ski> is basically what `let x = f x in x' (iow `fix f') will compute, yes
05:31:31 <Tjr> d3m1g0d-: ex maths postdoc, since you asked
05:31:42 <ski> Tjr : operationally, you can think of it as setting up an information loop from `f x' back to `x' (via the equality `x = f x')
05:31:57 <Cale> BoR0: It was a 4 year bachelor's degree in pure mathematics. A lot of my 4th year courses were cross listed grad courses. I got a pretty decent range of stuff...
05:32:22 <ski> Tjr : so first we know nothing about `x', so mathematically/conceptually, we approximate it with âŒœâŠ¥âŒ (here read as "no information")
05:32:41 <Tjr> ski: " âŠ¥  âŠ‘  f âŠ¥  âŠ‘  f (f âŠ¥)  âŠ‘  f (f (f âŠ¥))  âŠ‘  f (f (f (f âŠ¥)))  âŠ‘  â‹¯" >> thank you, that clarifies "fix" perfectly
05:33:06 <ski> Tjr : but then `f' may be able to compute some information for `f x', even though `x' isn't known yet -- and then by the equality `x = f x', this information ends up in `x', which then gets passed around the loop again, &c.
05:33:09 <BoR0> at comp sci I only had calculus I & II, discrete math, some abstract algebra. but that's probably a good base I guess
05:33:45 <Cale> BoR0: Algebraic topology and geometry, functional analysis, measure theory, algebraic combinatorics, algebraic number theory...
05:33:45 <ski> BoR0 : the discrete math including logic ?
05:33:53 <Cale> Mathematical logic and model theory
05:34:11 <BoR0> ski, yes. sets, logic, recursion, induction, graphs, proof of correctness, algo complexity
05:34:19 <ski> BoR0 : learning natural deduction, and also some basic model theory, can help a lot, i think
05:34:44 <Tjr> ski: in case the sequence of definedness-ordered strings doesn't turn constant pretty fast, how does haskell decide when to bail out?
05:34:53 <ski> Tjr : no
05:35:15 <Cale> I think I basically took every course titled algebraic X that was available, for various X. :)
05:35:25 <Cale> Algebraic graph theory
05:35:30 <Tjr> Cale: algebraic _|_ ?
05:35:42 <ski> Tjr : typically, only as much of the expression is computed as is actually *demanded* by the surrounding context
05:36:15 <Tjr> So how does haskell know when it's stuck in a non-converging fix-sequence?
05:36:23 <Cale> Tjr: It doesn't
05:36:27 <ski> Tjr : in case the surrounding context would require an infinite amount of computation, then the whole computation simply doesn't terminate (so conceptually the "value" of the whole computation is then âŒœâŠ¥âŒ :)
05:36:39 <ski> > last [2,3,5,7]
05:36:40 <lambdabot>  7
05:36:45 * Tjr is aware of the halting problem.
05:36:45 <ski> > last [0 .. 99999]
05:36:47 <lambdabot>  99999
05:37:11 <ski> > last (let x = 1 : x in x)  -- doesn't terminate, so "value" is âŒœâŠ¥âŒ
05:37:16 <lambdabot>  mueval: ExitFailure 1
05:37:27 <Cale> Tjr: Sometimes it can detect it. At runtime, values are represented by pointers to code
05:37:28 <ski> so there's no "early bail out"
05:38:09 * hackagebot plist 0.0.4 - Generate and parse Mac OS X property list format  http://hackage.haskell.org/package/plist-0.0.4 (YurasShumovich)
05:38:31 <Cale> Tjr: When the code is entered for the first time, the pointer is rewritten to point to what's called a "black hole", which is a bit of code that throws an exception because that can only run if there's a loop
05:38:46 <d3m1g0d-> > foldl (+) 0 20
05:38:48 <lambdabot>  No instance for (GHC.Show.Show a0)
05:38:48 <lambdabot>    arising from a use of â€˜M5238953795097204542463.show_M5238953795097204542463â€™
05:38:48 <lambdabot>  The type variable â€˜a0â€™ is ambiguous
05:38:48 <lambdabot>  Note: there are several potential instances:
05:38:48 <lambdabot>    instance [safe] GHC.Show.Show
05:38:59 <Cale> Tjr: Then, the value is computed, and the pointer is again rewritten to point at a short piece of code which will thereafter return it immediately.
05:39:04 <ski> as Cale said, in a few cases (bascially complexified versions of `let x = x in x'), it can *sometimes* determine that there's an infinite loop, and abort
05:39:13 <t7> i thought bottom was  x = x,  but your list thing is constructive (is that the right term)
05:39:18 <ski> but you can't typically rely on this behaviour
05:39:30 <ski> Tjr : that's just one way to get a bottom
05:39:31 <ski> er
05:39:34 <ski> t7 ^
05:39:56 <Tjr> Back to bragging, I know a bit about every subject thrown around so far, except haskell, algebraic number theory, domain theory, model theory, algebraic combinatorics.
05:40:03 <ski> > foldl (+) 0 [20]
05:40:04 <lambdabot>  20
05:40:05 <BoR0> d3m1g0d-, foldl takes a binary function, a "last" value and a list
05:40:21 <BoR0> or can the "last" value be referred to as bottom in the foldl case?
05:40:23 <Cale> Tjr: "Productive" tends to get used for that
05:40:29 <ski> Tjr : so you know denotational semantics, then ? ;)
05:40:51 <d3m1g0d-> ooops, forgot the parantheses
05:41:07 <Tjr> ski, Cale ok, thank you, that makes the question when haskell stops, sufficiently clear.
05:41:24 <Tjr> ski: sorry, I must have missed denotional semantics.
05:41:34 <Cale> Tjr: Recursive definitions where the recursive occurrences of the thing being defined only occur inside the parameters to data constructors
05:42:25 <Cale> Tjr: At some level, the only reason any expression is ever evaluated is in order to pattern match on it to see which data constructor it is built with (if possible)
05:42:45 <Tjr> Cale:  sounds a lot like how mathematica works internally
05:43:24 <Axman6> > fix (\x -> 1)
05:43:26 <ski> > [0 ..]  -- an infinite list
05:43:26 <lambdabot>  1
05:43:27 <lambdabot>  [0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,2...
05:43:35 <Tjr> > import Productive
05:43:36 <lambdabot>  <hint>:1:1: parse error on input â€˜importâ€™
05:43:38 <ski> > sum [0 ..]  -- summing an infinite list doesn't work
05:43:42 <lambdabot>  mueval-core: Time limit exceeded
05:43:46 <Tjr> Cale: ;-(
05:43:54 <Axman6> it so does... eventually
05:43:58 <Axman6> >_>
05:44:04 <ski> > sum (take 3 (map (^ 2) [0 ..]))  -- but here we still terminate
05:44:05 <lambdabot>  5
05:44:16 <Cale> > let primes = 2 : filter isPrime [3,5..]; isPrime n = all (\p -> n `mod` p /= 0) (takeWhile (\p -> p*p <= n) primes) in primes
05:44:18 <lambdabot>  [2,3,5,7,11,13,17,19,23,29,31,37,41,43,47,53,59,61,67,71,73,79,83,89,97,101,...
05:44:41 <Axman6> also, ghc should clearly implement an optimisation sum [0..] -> (infinity*(infinity+1))/2 >_>
05:44:52 <ski>      sum (take 3 (map (^ 2) [0 ..]))
05:44:59 <Cale> Tjr: ^^ computing primes by trial division with only primes :)
05:45:09 <ski>   =  sum (take 3 (map (^ 2) (0 : [1 ..])))
05:45:21 <ski>   =  sum (take 3 (0 ^ 2 : map (^ 2) [1 ..]))
05:45:34 <ski>   =  sum (0 ^ 2 : take 2 (map (^ 2) [1 ..]))
05:45:42 <Cale> Tjr: Note that it's *very* important that I handed it the initial 2 there
05:45:46 <ski>   =  0 ^ 2 + sum (take 2 (map (^ 2) [1 ..]))
05:45:53 <ski>   =  0 + sum (take 2 (map (^ 2) [1 ..]))
05:45:57 <Cale> > let primes = filter isPrime (2:[3,5..]); isPrime n = all (\p -> n `mod` p /= 0) (takeWhile (\p -> p*p <= n) primes) in primes
05:45:59 <ski>   =  0 + sum (take 2 (map (^ 2) (1 : [2 ..])))
05:46:01 <lambdabot>  mueval-core: Time limit exceeded
05:46:01 <Cale> ^^ this won't work at all
05:46:05 <warpy> ski: is so much slower than lambdabot
05:46:13 <ski>   =  0 + sum (take 2 (1 ^ 2 : map (^ 2) [2 ..]))
05:46:23 <ski>   =  0 + sum (1 ^ 2 : take 1 (map (^ 2) [2 ..]))
05:46:37 <ski>   =  0 + (1 ^ 2 + sum (take 1 (map (^ 2) [2 ..])))
05:46:41 <ski>   =  0 + (1 + sum (take 1 (map (^ 2) [2 ..])))
05:46:50 <ski>   =  0 + (1 + sum (take 1 (map (^ 2) (2 : [3 ..]))))
05:46:53 <Cale> Yeah, I shouldn't be interrupting this calculation that ski is doing, it's good to look at that kind of thing to get a sense for what goes on :)
05:47:05 <ski>   =  0 + (1 + sum (take 1 (2 ^ 2 : map (^ 2) [3 ..])))
05:47:18 <ski>   =  0 + (1 + sum (2 ^ 2 : take 0 (map (^ 2) [3 ..])))
05:47:27 <ski>   =  0 + (1 + (2 ^ 2 + sum (take 0 (map (^ 2) [3 ..]))))
05:47:39 <ski>   =  0 + (1 + (4 + sum (take 0 (map (^ 2) [3 ..]))))
05:47:46 <ski>   =  0 + (1 + (4 + sum []))
05:47:50 <ski>   =  0 + (1 + (4 + 0))
05:47:55 <ski>   =  0 + (1 + 4)
05:47:58 <Cale> The machine implementation is really fairly faithful to the idea that you're rewriting expression graphs in order to do expression evaluation, and usually thinking at the level of expressions will suffice to understand the performance and runtime behaviour of Haskell programs.
05:47:58 <ski>   =  0 + 5
05:48:00 <ski>   =  5
05:48:08 <ski> Tjr : is more or less how that expression evaluates
05:48:14 * hackagebot compdata 0.8.1.1 - Compositional Data Types  http://hackage.haskell.org/package/compdata-0.8.1.1 (PatrickBahr)
05:49:22 <ski> Tjr : note that the evaluation is *demand*-driven : because `sum' wants to know whether the list has ended yet, `take' demands to know whether *its* list argument has ended yet, and the the same for `map', and only then does `[0 ..]' compute to `0 : [1 ..]', producing the first element of that list
05:49:25 <Tjr> Cale's "let primes = filter isPrime (2:[3,5..]); isPrime n = all (\p -> n `mod` p /= 0) (takeWhile (\p -> p*p <= n) primes) in primes" >> I'm still wondering what it doesn't terminate.
05:50:20 <Tjr> s/what/why/
05:50:24 <ski> Tjr : then that element "trickles" up through the computation, passing `map (^ 2)' (which squares the element), and the `take' (which passes the element on, for the first three elements), and then `sum' "turns" `:' into `+'
05:50:28 <Cale> Tjr: Well, before it can even determine if the list is empty or not, it needs to first check whether isPrime 2 is true
05:50:44 <Tjr> Cale: gotcha.
05:50:57 <ski> Tjr : when the counter of `take' reach `0', it doesn't bother to demand more of its input list (the result of the `map' call), and so it isn't even computed
05:50:58 <Cale> Tjr: So, isPrime 2 = all (\p -> 2 `mod` p /= 0) (takeWhile (\p -> p*p <= 2) primes)
05:51:15 <ski> Tjr : and `sum []' is then `0', and then it's just arithmetic left
05:51:18 <Tjr> it's clear now, thanks
05:51:31 <Tjr> Back to your tree examples.
05:51:50 <Cale> and then the 'all' will force the evaluation of the 'takeWhile', which will force the evaluation of 'primes', which is what we were trying to evaluate to see if it was [] or (_ : _) in the first place
05:51:58 <ski> Tjr : do you get `trace' now as well ?
05:53:57 <ski> Tjr : and the `fix show' example ?
05:54:02 <BoR0> unsafePerformIO :: IO a -> a. how is this possible that such a function exists?
05:54:10 <ski> BoR0 : it's not a function
05:54:28 <Tjr> err, the tree examples are somehow gone from my chat logs :-(
05:54:37 <ski> > fix show
05:54:38 <lambdabot>  "\"\\\"\\\\\\\"\\\\\\\\\\\\\\\"\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"\\\\\\\\\\\\\...
05:54:52 <ski> <ski> @let data LeafTree a = Leaf a | Branch (LeafTree a) (LeafTree a) deriving Show
05:55:14 <Tjr> > show undefine
05:55:15 <lambdabot>  Not in scope: â€˜undefineâ€™
05:55:15 <Tjr> > show undefined
05:55:15 <lambdabot>  Perhaps you meant â€˜undefinedâ€™ (imported from Prelude)
05:55:17 <lambdabot>  "*Exception: Prelude.undefined
05:55:30 <BoR0> ski, what is it?
05:55:32 <ski> @let stagedRepMin :: Ord a => LeafTree a -> LeafTree a; stagedRepMin t0 = m_t1 m where (m,m_t1) = loop t0; loop :: Ord a => LeafTree a -> (a,a -> LeafTree a); loop (Leaf a) = (a,\m -> Leaf m); loop (Branch l0 r0) = (lm `min` rm,\m -> Branch (m_l1 m) (m_r1 m)) where (lm,m_l1) = loop l0; (rm,m_r1) = loop r0
05:55:35 <lambdabot>  Defined.
05:55:43 <ski> > stagedRepMin (Branch (Leaf 3) (Branch (Leaf 2) (Leaf 4)))
05:55:45 <lambdabot>  Branch (Leaf 2) (Branch (Leaf 2) (Leaf 2))
05:55:55 * Tjr takes some time to grok that
05:56:45 <ski> <ski> the staged `repMin' above (or really its helper `loop' function) takes a tree and returns a pair of the minimum as found in *that* tree, together with a *function* that when given the *global* minimum (which could be other than the minimum of the *current* tree) constructs the replacement tree of the (current) tree, with all elements replaced by the (global) minimum
05:57:30 <ski> in the staged version, we pass the "early input" (original tree), getting an "early output" (local minimum), and a function taking a "late input" (global minimum) and returning a "late output" (tree with elements replaced by global minimum)
05:57:55 <Tjr> those two explanations are very helpful
05:58:08 <ski> Tjr : note that there's still no strange cyclic tying-the-knot thing going on here .. yet
05:58:55 <ski> now, the idea for the cyclic version is to, somehow, pass the "late input" (global minimum) "*before*" getting back the "early output" (local minimum)
05:59:10 <ski> @let cyclicRepMin :: Ord a => LeafTree a -> LeafTree a; cyclicRepMin t0 = t1 where (m,t1) = loop t0 m; loop :: Ord a => LeafTree a -> a -> (a,LeafTree a); loop (Leaf a) m = (a,Leaf m); loop (Branch l0 r0) m = (lm `min` rm,Branch l1 r1) where (lm,l1) = loop l0 m; (rm,r1) = loop r0 m
05:59:11 <lambdabot>  Defined.
05:59:30 <ski> > cyclicRepMin (Branch (Leaf 3) (Branch (Leaf 2) (Leaf 4)))
05:59:31 <lambdabot>  Branch (Leaf 2) (Branch (Leaf 2) (Leaf 2))
06:00:31 <ski> in the type, i changed from `LeafTree a -> (a,a -> LeafTree a)' to `LeafTree a -> a -> (a,LeafTree a)' -- moving the `a ->' "temporally" before the `(a,...)' part
06:00:42 <ski> the changes in the code follows from that change
06:00:47 <ski> the interesting part here is
06:00:58 <ski>   cyclicRepMin t0 = t1
06:01:00 <ski>     where
06:01:02 <ski>     (m,t1) = loop t0 m
06:01:36 <ski> here we're passing the "early output" `m' (in `(m,t1)') as "late input" in `loop t0 m'
06:02:05 <Tjr> ski: I've now understood the code from before you said "Tjr : note that there's still no strange cyclic tying-the-knot thing going on here .. yet"
06:02:10 <ski> the strange thing is that, in some sense, the "late input" here "happens" *before*" the "early output"
06:02:24 * Tjr continues staring hat ski's code
06:03:23 * hackagebot rank1dynamic 0.2.0.0 - Like Data.Dynamic/Data.Typeable but with support for rank-1 polymorphic types  http://hackage.haskell.org/package/rank1dynamic-0.2.0.0 (TimWatson)
06:03:24 <ski> just as for `fix f = x where x = f x' and for `trace f x = y where (y,z) f (x,y)', we pass (part of) out output back as input to the *same* call
06:03:25 * hackagebot distributed-static 0.3.0.0 - Compositional, type-safe, polymorphic static values and closures  http://hackage.haskell.org/package/distributed-static-0.3.0.0 (TimWatson)
06:03:27 * hackagebot network-transport 0.4.0.0 - Network abstraction layer  http://hackage.haskell.org/package/network-transport-0.4.0.0 (TimWatson)
06:03:29 * hackagebot network-transport-tcp 0.4.0 - TCP instantiation of Network.Transport  http://hackage.haskell.org/package/network-transport-tcp-0.4.0 (TimWatson)
06:03:31 * hackagebot distributed-process-simplelocalnet 0.2.1.0 - Simple zero-configuration backend for Cloud Haskell  http://hackage.haskell.org/package/distributed-process-simplelocalnet-0.2.1.0 (TimWatson)
06:03:42 <ski> (er, that should be `trace f x = y where (y,z) = f (x,y)')
06:04:04 <Tjr> ski:  why didn't you just implement cyclicRepMin via repMin?
06:04:17 <ski> which `repMin' ?
06:04:25 <ski> i haven't defined a `repMin' here
06:04:38 <Tjr> err, via stagedRepMin
06:05:29 <ski> (what `http://www.haskell.org/haskellwiki/Circular_programming#Repmin_problem' called `repmin', i called `cyclicRepMin', and what it called `repIImin', i called `loop' (in the local definition inside `cyclicRepMin'))
06:05:43 <ski> Tjr : well, then it wouldn't be "tying-the-knot"
06:05:50 <ski> then it would just be a staged version
06:06:02 <Tjr> hmm
06:06:18 <ski> the staged version can easily be done in a language with strict evaluation
06:06:22 <Sm21> wtf is haskell?
06:06:25 <ski> the cyclic one can't
06:06:29 <ski> Sm21 : a programming language
06:06:38 <Sm21> for?
06:06:53 <ski> programming various things ?
06:07:06 <Sm21> o nice
06:07:15 <Sm21> im mark shuttleworth was just curious
06:07:19 <ski> @where LYAH
06:07:19 <lambdabot> http://www.learnyouahaskell.com/
06:07:25 <ski> might be interesting to check out
06:08:31 <ski> @src undefined
06:08:32 <lambdabot> undefined =  error "Prelude.undefined"
06:08:33 * hackagebot distributed-process 0.5.0 - Cloud Haskell: Erlang-style concurrency in Haskell  http://hackage.haskell.org/package/distributed-process-0.5.0 (TimWatson)
06:08:35 * hackagebot distributed-process-platform 0.1.0 - The Cloud Haskell Application Platform  http://hackage.haskell.org/package/distributed-process-platform-0.1.0 (TimWatson)
06:08:37 * hackagebot cloud-haskell 0.0.1.0 - The Cloud Haskell Application Platform  http://hackage.haskell.org/package/cloud-haskell-0.0.1.0 (TimWatson)
06:08:53 <ski>   undefined | False = undefined  -- is another popular definition
06:09:27 <ski> > let x | False = "unreachable" in x
06:09:28 <lambdabot>  "*Exception: <interactive>:3:5-29: Non-exhaustive patterns in function x
06:10:13 <ski> Tjr : anyway, the definition of `cyclicRepMin' is a little bit "brittle"
06:11:08 <ski> Tjr : i have to make very such i don't "look" at the "late input" `m' (globabl minimum), when computing the "early output" (local minimum) -- otherwise, the whole computation will just get stuck in an infinite loop that demands itself
06:11:55 <ski> Tjr : the same is true of the `fibs' definition, which keeps "chasing its own tail", but never catches up with itself (which is good, otherwise we'd get stuck after a while)
06:13:27 * hackagebot pi-calculus 0.0.4 - Applied pi-calculus compiler  http://hackage.haskell.org/package/pi-calculus-0.0.4 (renzyq19)
06:13:30 <ski> > let numbers = 1 : [n | m <- numbers,n <- [2*m,2*m+1]] in numbers
06:13:31 <lambdabot>  [1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,...
06:13:37 <ski> is another example of the same thing
06:14:10 <ski> think of the above as a binary tree, with `1' in the root node, `2' and `3' in the nodes at the next level, `4',`5',`6',`7' in the nodes at the next level, and so on
06:14:47 <ski> the above computation does a breadth-first-traversal of this tree
06:14:48 <ski> note that
06:15:08 <ski> > let numbers = 1 : [f m | m <- numbers,f <- [(2 *),(2 *) . (+ 1)]] in numbers
06:15:10 <lambdabot>  [1,2,4,4,6,8,10,8,10,12,14,16,18,20,22,16,18,20,22,24,26,28,30,32,34,36,38,4...
06:15:14 <ski> is just another way to write the same thing
06:15:37 <Tjr> ski: I've understood your cyclicRepMin now. What ou call interesting "t1 where (m,t1) = loop t0 m" pretty close to my naive idea of implementing it via stagedRepMin.
06:15:48 <ski> however, changing the order of the two generators in the list comprehension like
06:15:51 <ski> > let numbers = 1 : [f m | f <- [(2 *),(2 *) . (+ 1)],m <- numbers] in numbers
06:15:53 <lambdabot>  [1,2,4,8,16,32,64,128,256,512,1024,2048,4096,8192,16384,32768,65536,131072,2...
06:16:21 <Tjr> ok
06:16:32 <ski> will instead traverse the binary tree in a *depth*-first fashion .. and since other branches than the rightmost one are infinite, this won't actually enumerate all the elements of the (infinite) tree
06:16:56 <Tjr> So basically, in the trace example from http://www.haskell.org/haskellwiki/Circular_programming#Repmin_problem, you're saying the programmer has to arrange things carefully so that the compiler will find a way to define f?
06:17:05 <Tjr> err, define trace f
06:17:25 <ski> Tjr : if you want to, you could elaborate on your idea of implementing it in terms of `stagedRepMin' .. ?
06:18:29 * hackagebot egison 3.3.7 - Programming language with non-linear pattern-matching against unfree data  http://hackage.haskell.org/package/egison-3.3.7 (SatoshiEgi)
06:19:11 <ski> > let numbers = 1 : [n | m <- numbers,n <- [2*m,2*m+1],n < 10] in take 9 numbers
06:19:12 <lambdabot>  [1,2,3,4,5,6,7,8,9]
06:19:54 <ski> corresponds to a breadth-first traversal of a binary tree with levels : `1'; `2',`3'; `4',`5',`6',`7'; `8',`9'
06:19:58 <Tjr> cyclicRepMin t0 = let { (m_t1, m ) = stagedRepMin t0 ; t2 = m_t1 m} in t2
06:19:59 <ski> > let numbers = 1 : [n | m <- numbers,n <- [2*m,2*m+1],n < 10] in take 10 numbers
06:20:03 <lambdabot>  mueval-core: Time limit exceeded
06:20:04 <ski> > let numbers = 1 : [n | m <- numbers,n <- [2*m,2*m+1],n < 10] in numbers
06:20:08 <lambdabot>  mueval-core: Time limit exceeded
06:20:48 <Tjr> ski: admittedly, it ties the knot at the uppermost level where it's not really a knot anymore.
06:20:54 <ski> this actually computes âŒœ1 : 2 : 3 : 4 : 5 : 6 : 7 : 8 : 9 : âŠ¥âŒ, which is why i used `take 9' to get the defined elements of the list
06:21:17 <sebzim4500> I'm getting an error when I try to install the 'idris' package on windows: http://lpaste.net/105562
06:21:47 <sebzim4500> According to the guys on #idris it is an error with my version of the 'network' package
06:22:06 <ski> the problem here is that in this breadth-first traversal, which is a bit similar to `fibs' (except that the distance between the "cat" and its "tail" that it is chasing, varies with time)
06:22:35 <ski> the problem is that it catches its tail, and then we get a "deadlock", a loop where a demand waits for itself to finish
06:22:44 <bergmark> sebzim4500: are you using the latest version of network?
06:22:52 <Tjr> ski: what you're calling breadth-first versus depth-first, reminds me very much of whether it's better to solve exp(x)=x via fixed-point iteration of exp or of log.
06:23:18 <sebzim4500> the installed version is the same as the default available version
06:23:36 <sebzim4500> presumably that means it's the latest version
06:24:36 <ski> Tjr : note that my `stagedRepMin t0 = m_t1 m where (m,m_t1) = loop t0' corresponds to your `cyclicRepMin t0 = let { (m_t1, m ) = stagedRepMin t0 ; t2 = m_t1 m} in t2', if you rename `loop' to `stagedRepMin' and `cyclicRepMin' to `stagedRepMin' -- so your definition *is* the wrapper part of the worker-wrapper solution in my `stagedRepMin' above :)
06:24:52 <ski> Tjr : hehe, why is that ?
06:25:26 <Tjr> ski: ok, great. The repmin stuff is clear now.
06:25:32 <ski> @let data NodeTree a = Tip | Fork a (NodeTree a) (NodeTree a) deriving Show
06:25:34 <lambdabot>  Defined.
06:26:07 <sebzim4500> When I try to do 'cabal repl' I get this error: http://lpaste.net/105566
06:26:14 <Tjr> ski: if you look at how the numerical iteration is conditioned, you'll see that the exp function eats its tail, while the intervals of possible approximation error get smaller if you iterate the log
06:26:37 <Tjr> where tail == interval of values for the fixed poitn that we haven't excluded yet
06:27:15 <ski> the (finite) tree being traversed was `Fork 1 (Fork 2 (Fork 4 (Fork 8 Tip Tip) (Fork 9 Tip Tip)) (Fork 5 Tip Tip)) (Fork 3 (Fork 6 Tip Tip) (Fork 7 Tip Tip))', in case it wasn't clear
06:28:17 <ski> (the way i built the tree, you multiply by two as you move to the left child, and add one after multiplying by two to move to the right child)
06:29:13 <ski> > let numbers = 1 : [f m | m <- numbers,f <- [(2 *),(+ 1) . (2 *)]] in numbers  -- sorry, realized i got the ordering of the function composition wrong before
06:29:14 <lambdabot>  [1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,...
06:29:52 <ski> > let numbers = 1 : [n | m <- numbers,n <- [2 * m,2 * m + 1]] in numbers  -- same thing
06:29:54 <lambdabot>  [1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,...
06:30:13 <Tjr> hey, maybe this ties-the-knot stuff can be shoehorned into a method how to generalize the A* algorithm if you've got both a lower and an upper estimate for the unknown part of the distance to the destination (and you want to take advantage of that to keep computation costs down)
06:30:31 <ski> corresponds to adding the children of a node to the end of a "queue" before moving on to the next node at the front of the queue
06:30:40 <ski> while
06:31:10 <ski> > let numbers = 1 : [f m | f <- [(2 *),(+ 1) . (2 *)],m <- numbers] in numbers
06:31:11 <lambdabot>  [1,2,4,8,16,32,64,128,256,512,1024,2048,4096,8192,16384,32768,65536,131072,2...
06:31:25 <ski> while in this case we (conceptually) add the children to the *front* of the queue, so that we'll investigate them next
06:32:16 <Tjr> ski: do you think it's possible to retrotit a pre-made A* implementation with this ties-the-knot stuff so that it it takes advantage of an additional upper estimate?
06:32:17 <ski> in this depth-first traversal, we first make the choice `f <- [(2 *),(+ 1) . (2 *)]' of which child to move to, and then `m <- numbers' recursively select an element of that child subtree
06:32:34 <Tjr> s/retrotit/retrofit/
06:34:04 <ski> while in the other breadth-first traversal, we first (strangely) make the choice of a number from the whole tree being defined `m <- numbers', before making a choice as to whether compute the element in the root of the left or right child tree : `n <- [2 * m,2 * m + 1]' / `f <- [(2 *),(+ 1) . (2 *)]'
06:34:04 <Tjr> lengths of the graph edges are Fractionals in my intended example, so the compiler can't use induction in its decision which paths to cut away
06:35:28 <Tjr> ski: thank you, the point of the list comprehension examples is clear now :-)
06:35:30 <ski> Tjr : "you'll see that the exp function eats its tail, while the intervals of possible approximation error get smaller if you iterate the log" -- hm, iiuc, you mean the difference between attractive and repulsive fixed points, wrt at iteration scheme -- nice observation ! ;)
06:38:07 <Tjr> In an imperative language, I'd simply store the lowest upper estimate in some global variable, and discared paths whose lower estimate is worse than this global upper estimate.
06:39:17 <ski> Tjr : anyway, that depth-first neither work well for infinite trees (because it's depth-first) (not even for trees where the only infinite branch is the rightmost, where it might perhaps be expected to work, because of the following) nor for finite trees (since it hits an "bottom" / infinite loop after reaching the end of the first path to a leaf)
06:44:26 <ski> > let numbers = 1 : [f m | m <- numbers,m == 1 || m `mod` 2 == 0,f <- [(2 *),(+ 1) . (2 *)]] in numbers
06:44:28 <lambdabot>  [1,2,3,4,5,8,9,16,17,32,33,64,65,128,129,256,257,512,513,1024,1025,2048,2049...
06:44:48 <ski> > let numbers = 1 : [n | m <- numbers,m == 1 || m `mod` 2 == 0,n <- [2 * m,2 * m + 1]] in numbers
06:44:50 <lambdabot>  [1,2,3,4,5,8,9,16,17,32,33,64,65,128,129,256,257,512,513,1024,1025,2048,2049...
06:45:05 <ski> > let numbers = 1 : [n | m <- numbers,n <- [2 * m,2 * m + 1],n == 1 || n `mod` 2 == 0] in numbers
06:45:07 <lambdabot>  [1,2,4,8,16,32,64,128,256,512,1024,2048,4096,8192,16384,32768,65536,131072,2...
06:45:14 <ski> > let numbers = 1 : [n | m <- numbers,n <- [2 * m,2 * m + 1],n < 10 || n `mod` 2 == 0] in numbers
06:45:16 <lambdabot>  [1,2,3,4,5,6,7,8,9,10,12,14,16,18,20,24,28,32,36,40,48,56,64,72,80,96,112,12...
06:46:31 <ski> Tjr : and the breadth-first only works for infinite trees (i.e. with at least one infinite branch), but not for finite trees
06:46:52 <ski> though if you already know how many elements you'll get, you can use it, with a `take'
06:47:43 <ski> my main point here was mostly to attempt to explain (by way of example) better what i meant by "chasing its own tail" and that it will loop indefinitely if it ever succeeds in doing so
06:48:42 <Tjr> yes, it's clear now :-)
06:48:57 <ski> Tjr : that "lower and an upper estimate" sounds like the interval domain
06:49:07 <Tjr> interval domain?
06:49:14 <ski> which is a way to implement a kind of computable real numbers, in terms of rational numbers
06:49:37 <Tjr> no, I know the length of each path exactly
06:49:42 <Tjr> no interval there
06:50:07 <Tjr> except for the fact that the intended graph is an infinite tree
06:50:50 <Tjr> and I have lower and upper estimates for the infinite portion of the total paths, whereas most of the length is on the finite start of each path
06:50:50 <ski> normally in Haskell, a value is either only known to be âŒœâŠ¥âŒ (iow it's unknown, yet), or it's know to be of the form âŒœC (â‹¯) â‹¯ (â‹¯)âŒ, i.e. a data constructor applied to some values/computations (which in turn may be âŒœâŠ¥âŒ or ...)
06:51:24 <ski> (this is omitting/ignoring functions, and also abstract data types provided by the language)
06:51:57 <ski> Tjr : so, either the "top node/form/shape" of a value is unknown, or it has become fully known (but "child" parts may still be unknown)
06:52:09 <kazagistar> how do I get windows to display unicode properly? or is it my chat client that is failing?
06:52:24 <ski> Tjr : however, one can easily imagine a spectrum between "unknown" and "top shape fully known"
06:52:34 <kazagistar> the only symbol I can read there is bottom
06:52:40 <d3m1g0d->  Consider the expression sum (map sqrt [1..130]). Because $ has such a low precedence, we can rewrite that expression as sum $ map sqrt [1..130], saving ourselves precious keystrokes!
06:52:58 <d3m1g0d-> is this language full of bullsh*t like that ?
06:53:19 <d3m1g0d-> saving precious keystrokes ?
06:53:23 <d3m1g0d-> seriously ?
06:53:33 <BoR0> d3m1g0d-, you are missing the point
06:53:33 <Hafydd> No.
06:53:34 <BoR0> @src $
06:53:34 <lambdabot> f $ x = f x
06:53:36 <Rarrikins> Trolls...
06:54:01 <ski>   âŠ¥  âŠ‘  [1 % 1,2 % 2]  âŠ‘  [1 % 1,15 % 10]  âŠ‘  [1 % 1,142 % 100]  âŠ‘  [1 % 1,1415 % 1000]  âŠ‘  â‹¯
06:54:14 <Hafydd> Whoever wrote that doesn't seem to know what they're talking about, since an operator with any precedence at all would have the same effect there.
06:54:14 <pdpi> d3m1g0d-: thatâ€™s a pretty bad explanation for why youâ€™d want to use $.
06:54:33 <ski> could be an approximation/definedness chain/sequence for âŒœâˆš2âŒ
06:54:43 <warpy> d3m1g0d-: with some proper indentation $ increases readability over nested ()s
06:55:24 <ski> where `%' is the rational divisor sign, and âŒœ[lo,hi]âŒ here denotes *some* real number in the closed interval between âŒœloâŒ and âŒœhiâŒ
06:55:29 <BoR0> its simple definition allows you to not use a lot of brackets for in a case where right-associativity is needed. e.g. consider f (f (f (f (f (f (f x)))))))) (not sure I matched the parentheses anyway). that could be f $ f $ f $ f $ f $ f x
06:56:12 <ski> the point is that these interval approximations here can be *improved* (as opposed to just "trivial" improvement, by which i mean replacing some part âŒœâŠ¥âŒ by a (more) defined value)
06:57:31 <ski> Tjr : "<Tjr> interval domain?" -- sorry, we was talking about two different things here -- you were still thinking of the traversals of the trees (i think), while i moved on to responding to your comment on intervals and "lower and an upper estimate"
06:57:58 <ski> Tjr : or maybe i'm misunderstanding what you meant by "path" and "length of each path" ?
06:58:17 <Tjr> d3m1g0d-: LYAH is full of bad and good jokes. Don't worry, you found a bad one :-)
06:58:33 <Tjr> ski: How familiar are you with the A* algorithm?
06:59:01 <ski> hm, i just realized you probably was talking about that one
06:59:05 <kazagistar> its a joke cause it saved no keystrokes :P
06:59:13 <ski> i've looked into it at some time, but it's not fresh in my mind
07:00:04 <Tjr> ski: basically, you have a directed graph where each vertex has only finitely many neighbors.
07:00:23 <Tjr> ski: each edge is assigned a positive real number, its length
07:00:28 <ski> Tjr : is there a variable cost for the steps on the map/graph ? or unit cost for each step/edge ?
07:00:31 <ski> ok
07:00:31 <Tjr> variable
07:00:47 <Hafydd> If you count the shift key, it saved one keystroke.
07:01:25 <Tjr> you've got one designated starting vertex, you've got a way to know if a given vertex is the goal
07:01:40 <ski> d3m1g0d- : btw, i'd prefer `sum (map sqrt [1 .. 130])' to `sum $ map sqrt [1 .. 130]', here
07:01:54 <d3m1g0d-> ofcourse you would
07:02:15 <BoR0> I'm a bit confused tho, why $ has precedence of 0? shouldn't it have highest precedence?
07:02:30 <d3m1g0d-> lowest
07:02:36 <ski> "I have lower and upper estimates for the infinite portion of the total paths" -- which portion is the infinite one ?
07:02:44 <Tjr> ski:  and, crucially, for each vertex, you have a reasonably good lower extimate of the length of the shortest path to the neares goal vertex.
07:02:47 <ski> d3m1g0d- :)
07:03:06 <Tjr> ski: ok, let's assume the graph is finite but very big
07:03:34 <Tjr> In my intended application, edges "far away" from the starting vertex are also very short
07:03:38 <ski> BoR0 : lowest means it binds the loosest, so that `foo x $ bar y + z' means `(foo x) $ ((bar y) + z)'
07:04:16 <ski> Tjr : ok
07:04:20 <kazagistar> BoR0: does + or * have higher precedence? which do you evalutate first? which do you evaluate last? which is $ more like?
07:04:39 <ski>   infixl 6 +
07:04:46 <ski>   infixl 7 *
07:05:00 <Tjr> ski: classical A* then keeps increasing a "region" around the starting vertex. At first, that region is the start only.
07:05:00 <ski> kazagistar : `*' has highest precedence, so it binds the tigher of those two
07:05:11 <ski> function application has a precedence of `10'
07:05:24 <kazagistar> ski: I know, I am trying to lead him to the answer via questions, sheesh :P
07:05:44 <ski> kazagistar : oh, sorry then :/
07:06:22 <Tjr> ski: In each iteration, it looks at all vertices V that are connected directly to region, and computes the (known) path length from the start  to V, plus the lower estimate of V to the goal.
07:06:37 <d3m1g0d-> Tjr: its funny how these fully deterministic algorithms are considered to be A.I., but in fact are just an exhaustive search
07:06:40 <d3m1g0d-> its not even heuristics
07:07:05 <Tjr> d3m1g0d-: the heursitic is how to find an efficient lower estimate for the graph metric
07:07:44 <Tjr> ski: then it add the vertex V' with the lowest extimate to the region (along with a pointer how we came to that vertex V').
07:07:52 <kazagistar> I dont remember "rules" like "$ has the lowest precedence", I tend to just derive things from nearby intuitions
07:08:11 <ski> (s/the vertex/a vertex/, s/the lowest/a minimal/)
07:08:35 <BoR0> kazagistar, well, $ is infixr 0
07:08:38 <Tjr> kazagistar: that's one possible way to learn a language, especially if you like to read beautiful code
07:08:50 <Tjr> ski: good catch. I see you understand A*
07:08:54 <ski> Tjr : this is a greedy algorithm, right
07:08:55 <ski> ?
07:09:19 <Tjr> ski: now that I think of it, yes.
07:09:42 <ski> so it's not necessarily guaranteed to find an optimal solution
07:10:05 <Tjr> ski in fact it is guaranteed. that's why you use lower estimates.
07:10:08 <ski> (depending on the heuristic, and on actual graph and start and end nodes, i suppose)
07:10:17 <ski> ah, ok
07:10:18 <ski> interesting
07:10:27 <Tjr> clear? or would oyu like an explanation?
07:11:14 <ski> so the computed path length (with heuristics added) will now be intervals
07:11:25 <ski> so not any more totally ordered
07:11:28 <ski> is that right ?
07:11:39 <Tjr> not yet, I was getting ahead of myself
07:11:46 <Tjr> the compounded path length is still a real number.
07:11:57 <ski> wait, you said lower estimate. ignore me
07:12:04 <kazagistar> Tjr: its mostly just how I learn math, becasue I could never memorize things like formulas, but I could remember how to derive them... I still struggle with the quadratic formula, but I can derive it by completing the sqare in my sleep :P
07:12:24 <Tjr> kazagistar: that's phd material. (no sarcasm)
07:12:44 <d3m1g0d-> thats a really good way to think about stuff
07:13:28 <kazagistar> so I tend to like software that I dont have to remember, but I can just get an idea of how it "should" work and look up or guess the details
07:13:40 <Tjr> ski: I know the actual path length of the starign portion, and a lower estimate for the rest. So I get a possibly-lower different real number for the estimated total path length.
07:13:52 <ski> BoR0,kazagistar : well, in `x + y * z', you can think of `+' and `*' both pulling at the poor `y' inbetween, and `*' wins the struggle, since it binds tighter than `+' (which binds looser), because `*' has higher precedence than `+'
07:14:00 <kazagistar> sooo I still like python a lot, but I also find hoogle and a lot of haskell libraries to be pretty nice that way too
07:14:03 <Tjr> s/starign/starting/
07:14:38 <d3m1g0d-> Tjr: ski  are you guys phd students / have phdss ?
07:14:40 <ski> kazagistar,BoR0  : for myself, i find this a nice picture of how one can think about it. maybe it can help you as well
07:14:49 <BoR0> ski, but, shouldn't $ have higher precedence than * so that f (x+1) $ y * z equals (f (x+1)) $ (y * z) (it wins the battle against + and *)
07:14:55 * ski is an ordinary student
07:15:03 <Tjr> ski: now let's assume we are given an implementation of A*, and later we find that we also have an upper estimate for the path lengths to the goal, in addition to the lower one.
07:15:28 <Tjr> d3m1g0d-: I can't speak for the rest, but yes.
07:15:30 <kazagistar> ski: that pulling is pretty nice... I just think of it as application of substitution rules, like most functional computation... the higher precedence means that substitution happens first
07:15:38 <ocharles_> goldfire: if you're around - what's the status of kind equality in GHC? Does HEAD have code that would let me promote GADTs to the type level yet?
07:16:12 <BoR0> ski, kazagistar, so if higher precedence means substitution happens first, shouldn't $ have higher precedence?
07:16:19 <BoR0> f $ x, you substitute for f and x
07:16:57 <kazagistar> BoR0: well, do you want "f $ g + x" to have the + or the $ substitution happen first?
07:17:21 <BoR0> aha!
07:17:54 <BoR0> ok :)
07:18:01 <ski> BoR0 : no, function application (`f ') wins over `$' : it pulls the `(x + 1)' away from it. and `*' also wins over `$', it pulls `y' away -- so only after those have combined into `f (x + 1)' and `y * z' does `$' manage to bind those two "complexes together"
07:18:37 <ski> BoR0 : one can perhaps think of it a bit like some kind of molecules (though not quite ordinary ones), where some bindings are tigher than others
07:18:40 <BoR0> such a simple definition of a function, but so much thought to put into it (just like id x = x)
07:19:17 <ski> in this case, the `... $ ...' is the weakest, it will "break", when all is put under strain/stretch, before any of the others
07:19:17 <kazagistar> so, if I have f g + x, then f g is substituted for its result, and then the + is later (lower), but if I have f $ g + x, then the + happens first, and the $ happens later on the result of that
07:19:58 <BoR0> got it
07:20:09 <ski> Tjr : i assume it terminates when we reach a goal node
07:20:20 <Tjr> ski: indeed
07:20:27 <ski> Tjr : is the upper estimates not used during the actual search ?
07:20:33 <Tjr> ski: it finds a shortest path through a graph
07:20:43 <kazagistar> ski: the binding explanation is pretty cool, I like it too, I will use it as a backup explanation :D
07:20:46 <Tjr> ski: no, the upper estimate isn't used at all, classically.
07:21:18 <kazagistar> not that I will be teaching FP in a non-casual setting any time soon, I am still an undergrad haha
07:21:38 <Tjr> kazagistar: what's your subject, if you don't mind?
07:22:30 <Tjr> ski: effectively, the upper estimate for the best start-of-a-path found so far, provides a way to throw away other path-starts.
07:22:53 <ski> BoR0 : if you want to substitute for `f' or `x' (or both) in `f $ x', then for safety sake, you should always include brackets, like `(...) $ (...)' -- only sometimes can you then safely remove the brackets (namely when the last "open" operator in the former `(...)' is stronger than `$', respectively when the first "open" operator in the latter `(...)' is stronger than `$')
07:23:12 <deweyvm> is it possible that the OS kills my program for running out of memory before haskell triggers GC?
07:23:36 <ski> kazagistar : np :)
07:24:30 <kazagistar> Tjr: computer science, but almost all my learning has to happen outside school
07:24:47 * hackagebot propellor 0.7.0 - property-based host configuration management in haskell  http://hackage.haskell.org/package/propellor-0.7.0 (JoeyHess)
07:24:51 <ski> Tjr : by "classically", do you mean in the classical formulation of the algorithm, or do you mean in a "classical math" specification of the function (ignoring efficiency and maybe even computability) ?
07:25:24 <Tjr> in the classical formulation of the algo
07:25:34 <ski> kazagistar : if you don't mind me being curious, perhaps you could say why it has to happen outside school
07:25:38 <Tjr> A* is supposedly very efficient
07:25:42 <ski> ok
07:25:54 <d3m1g0d-> deweyvm: i dont think so . Theoretically you have a maximum size of the stack per thread, but ... the heap is as big as it can get
07:26:25 * Tjr half expects kazagistar to report about a only-coding-java school
07:26:25 <ski> Tjr : so the upper bounds are only used for proving termination, then ? (and possibly also for an improved version which is more performant)
07:26:29 <kazagistar> we have one good algorithms teacher (so everyone hates his classes for being hard) and no languages teachers (my compilers professor stopped learning about languages with pascal), and no one interested in the math and symbolics side of things
07:26:41 <deweyvm> hmm okay then. i have a memory leak and im trying to sort out what it could be. my program is just a simple forever loop reading in data and inserting it into a db
07:26:50 <kazagistar> Tjr: well, the teach us java, but... they let us chose languages upper division
07:26:57 <prophile> deweyvm: source?
07:27:11 <Tjr> ski: the upper estimate isn't used at all. However, I'd like to make it more efficient, since I have an upper estimate, wherease the classical situation doesn't.
07:27:13 <ski> kazagistar : sounds a bit sad
07:27:34 <ski> Tjr : oh, i see
07:27:43 <deweyvm> prophile: https://github.com/deweyvm/starstats/blob/master/src/StarStats/DB/Tables.hs#L715 thats the main loop, please forgive the messiness :P
07:28:16 <kazagistar> the software engineering proffesor used to teach code proofs before I got there, but he switched to OCL and test design by the time I took the class
07:28:37 <Tjr> kazagistar: "my compilers professor stopped learning about languages with pascal" >> This might be related to the fact that industry doesn't write compilers anymore. They write apps that turn a language specification into a compiler.
07:29:21 <ski> Tjr : hm, presumably the start vertex and all(?) the goal vertices are required to be in the same connected component (or simpler, just require the graph to be connected) ?
07:29:48 <ski> (and there has to be at least one goal vertex)
07:29:52 <Tjr> yes, the graph is connected. If not, the algo will simply stay in one connected component.
07:29:55 <deweyvm> i fear it may be a leak in hdbc/hdbc-odbc
07:30:04 <kazagistar> Tjr: yeah, well, the class wasnt really about compilers anyways, they just needed a class where it would be a sizable group project with a decent amount of code written, which is cool I guess
07:30:07 <rwbarton> deweyvm: try heap profiling
07:30:26 <rwbarton> deweyvm: or actually, start with just +RTS -sstderr
07:30:29 <Ankhers> Is there an ETA for the next HP?
07:30:39 * ski was for some reason worrying about infinite paths, but that shouldn't be a problem, if there's a finite distance to some goal node, and the algorithm search will reach it
07:31:20 <geekosaur> Ankhers, currently waiting on ghc 7.8.3
07:31:37 <geekosaur> more bug fixes >.>
07:31:43 <Ankhers> I thought I heard that was ready now. My bad.
07:31:52 <geekosaur> it may be ready but it's not yet released
07:32:02 <Ankhers> Understood.
07:32:04 <geekosaur> at least I've not seen the release announcement for it yet
07:32:16 <Ankhers> I trust your information over mine.
07:32:30 <rwbarton> it's not quite ready, there are some merge conflicts/validate failures when backporting bug fixes from HEAD
07:33:01 <ski> Tjr : anyway, what i wanted to say about the interval domain is that you can efficiently implement `f(lo,hi,x) = max(lo,min(x,hi)) = min(max(lo,x),hi)' which satisfies the condition `lo =< f(lo,hi,x) =< hi'
07:33:11 <Ankhers> rwbarton: Are you one of the devs for GHC?
07:33:36 <rwbarton> yes
07:34:05 <ski> Tjr : using this, one can e.g. implement the bisection method for finding a root for a continuous function on an interval where the function changes sign, without a "base case" in the recursion :)
07:34:19 <albeit> What would be the best way to get the rest of a text after the second occurrence of a character? f 'X' "123X456X789" -> "789"
07:35:19 <ski> Tjr : basically, you ask whether the result is greater or lesser than some given threshold, and it only computes an interval approximation accurately enough to be able to answer
07:36:02 <ski> Tjr : i'm not sure, but i was imagining that perhaps you could have use of something like that in your case
07:36:08 <deweyvm> rwbarton: what does this do?
07:36:35 <deweyvm> rwbarton: nvm found it :P
07:36:40 <osfameron> albeit: dropWhile twice or Data.List.Split might be easy ways
07:36:46 <osfameron> albeit: or a parser/regex
07:37:11 * ski saw some handwritten paper (or lecture notes) about this somewhere, but can't recall where :/
07:37:33 <albeit> osfameron: Ah dropWhile twice sounds good, thanks
07:37:44 <deweyvm> rwbarton: my program takes days to run, is there a way to get the output when quitting early?
07:37:46 <kazagistar> if I wrote a MINIMAL pragma for typeclass in Base (like Ix), would that be useful or accepted as a patch?
07:37:51 <deweyvm> ctrl c didnt give me any
07:39:06 <Tjr> ski: `f(lo,hi,x) = max(lo,min(x,hi)) = min(max(lo,x),hi)' >> That's what I figured. Now if the pre-made A* algo is calling the graph distance functions, how to I pass around the current best estimates of "lo" and "hi"?
07:39:49 <rwbarton> deweyvm: can you just give it less input
07:39:51 <rwbarton> that would be easiest
07:39:57 * hackagebot git-annex 5.20140613 - manage files with git, without checking their contents into git  http://hackage.haskell.org/package/git-annex-5.20140613 (JoeyHess)
07:40:04 <deweyvm> hehe true
07:40:59 <Tjr> ski: regarding the numerics method - it's called regula falsii. Often, only one interval endpoint converges to the actual root, i.e. the intervals might not become infinitely short.
07:41:22 <rwbarton> though if it takes days to fill up your RAM, this will be a pretty unpleasant issue to track down...
07:42:15 <ski> Tjr : "falsi" or "falsii" ?
07:43:15 <Tjr> falsi (sorry) http://en.wikipedia.org/wiki/False_position_method
07:43:26 <ski> ok
07:43:48 <ski> "regarding the numerics method" -- which numerics method ? (iow, why did you mention it ?)
07:44:15 <ski> hm, "In numerical analysis, double false position became a root-finding algorithm that combines features from the bisection method and the secant method." -- i see
07:44:16 <Tjr> regula falsi is a numerical method to find the root of a continuous, monotonic function.
07:45:12 <Tjr> I though you meant that with your comment about handwritten notes
07:47:13 <ski> well, i don't think it required it to be monotonic ?
07:50:52 <Tjr> ski: oh, right. but it does have to have different signs at the endpoints
07:51:07 * ski nods
07:51:49 <ski> (monotonicity should imply uniqueness)
07:52:43 * ski idly wonders whether one should consider such algorithms as implementing committed-choice modes for (binary) relations, rather than functions
07:53:49 <Tjr> what are committed-choice modes?
07:55:33 <ski> in logic programming, computation consists in solving for some variables `X',`Y' in a relational expression `r(3,X,Y,5)'
07:56:37 <ski> there is no predefined input and output parameters. depending on the circumstance, a parameter may sometimes be used as an input (already known before solving for this subformula) or output (will be known after solving it, in case it has any solution(s))
07:57:15 <ski> a different pattern of using some parameters for input and other parameters for output is considered a separate mode of the relation in question
07:58:13 <ski> so e.g. if you ask `append([0,1,2],[3,4],Xs)' it will compute the solution `Xs = [0,1,2,3,4]'
07:58:46 <ski> if you ask `append([0,1,2],[3,4],[0,1,2,3,4])' or `append([0,1,2],[3,4],[0,1,2,3,4])', it will compute `true' (one trivial solution with no values for variables) or `false' (no solution)
07:59:36 <ski> (er .. or `append([0,1,2],[3,4],[0,1,5,3,4])', i meant to say)
07:59:54 <ski> if you ask `append([0,1,2],Suffix,[0,1,2,3,4])' or `append([0,1,2],Suffix,[0,1,5,3,4])', it will compute `Suffix = [3,4]' or `false'
08:01:15 <ski> if you ask `append(Prefix,Suffix,[0,1,2])' it will compute `Prefix = [],Suffix = [0,1,2] ; Prefix = [0],Suffix = [1,2] ; Prefix = [0,1],Suffix = [2] ; Prefix = [0,1,2],Suffix = []', four separate solutions (here `,' is "and", `;' is "or")
08:02:14 <Tjr> This sounds like the kind of stuff generations of phd students must have already improved upon
08:02:14 <ski> in general, `append(Prefix,Suffix,List)' expresses the relation that `List' is the concatenation of the lists `Prefix' and `Suffix' -- this relation can be used "both forwards and backwards"
08:02:40 <ski> with each mode one usually associates an approximation of the number of solutions it could possibly produce
08:03:09 <ski> `det' - exactly one solution, `semidet' - at most one solution, `multi' - at least one solution, `nondet' - any number of solutions
08:04:09 <ski> this is the Logic Programming paradigm, as exemplified in e.g. Prolog,Mercury,Oz,lambdaProlog,lolli,Curry,Escher
08:04:46 <ski> however, sometimes one's only interested in whether there exists a solution -- then it's wasteful to compute all of them
08:04:58 <Tjr> presumably append is just one example?
08:05:03 <ski> yes
08:05:21 * hackagebot inflections 0.1.0.7 - Inflections library for Haskell  http://hackage.haskell.org/package/inflections-0.1.0.7 (jsl)
08:05:28 <ski> "committed-choice" means that one has an implementation of a predicate mode, which only computes at most one solution, even though there may logically be more
08:06:02 <Tjr> can't you just lexicographically order the set of solutions, and pick the smallest one?
08:06:02 <ski> cf. a function computing one of several possible answers, constrained by a specification that only says that one of them has to be computed
08:06:30 <Tjr> from a theoretical perspecitve, that should reduce the problem to something well-known
08:06:37 <ski> Tjr : that may be costy -- and depending on circumstance, the ordering one would want to use can vary
08:07:13 <ski> also, if you leave the language implementation more freedom, it may be able to generate more efficient code
08:07:38 <Tjr> ski: maybe you could research how this is implemented: http://reference.wolfram.com/mathematica/ref/FindInstance.html
08:07:59 <ski> if you only need to check whether there's any solution, it may be easier to search for the first one, according to some arbitrary choices made by a compiler, rather than (in the worst case), post hoc sorting the solutions
08:09:33 <deweyvm> how would i implement a "longest match" parser in parsec? the docs mention it but its not really what im looking for. i want to get "this is ' a ' test" from 'this is ' a ' test'
08:09:47 <deweyvm> the string im parsing it longer than that but has no other single quotes
08:09:54 <mm48> ciao
08:10:10 <ski> (logic programming is also typically more directed towards symbolic tree computation, though there are constraint logic programming packages that can handle some classes of arithmetic constraints -- i don't know much about constraint solving for polynomials (&c.) and for finitely presented algebraic structures, though)
08:12:31 <ski> Tjr : anyway, to summarize, "committed-choice nondeterminism" is an term from implementation of search in logic programming. different forms of such nondeterminism are related to various pre-orders on powerdomains (Egli-Milner,Smyth,Hoare)
08:15:48 <ski> <https://en.wikipedia.org/wiki/Logic_programming>,<https://en.wikipedia.org/wiki/Constraint_programming>,<https://en.wikipedia.org/wiki/Constraint_logic_programming>
08:17:39 <biscarch> I'm trying to replace the X in fetchAsync here: http://lpaste.net/105567 where X is a function that takes the `a` in BlockedFetch as its argument
08:19:32 <biscarch> Most of the errors I've been getting have been Kind errors
08:19:59 <biscarch> So I think my forall knowledge is failing me. Can anyone point me in the right direction?
08:20:48 * hackagebot Hipmunk 5.2.0.15 - A Haskell binding for Chipmunk.  http://hackage.haskell.org/package/Hipmunk-5.2.0.15 (FelipeLessa)
08:21:36 <deweyvm> heres what i have so far http://pastebin.com/tXSBzvkL
08:21:56 <ski>   fetchAsync :: (forall a. a -> ...) -> BlockedFetch r -> IO (Async ())  -- perhaps ?
08:22:04 <ski> biscarch ^
08:23:57 <biscarch> ski: that looks like it worked. Thank you
08:24:53 <ski> fread2282 : note that `fetchAsync' (while being polymorphic in `r') is *not* polymorphic in `a' !
08:25:09 <ski> rather, it expect the first *argument* to be polymorphic in `a'
08:25:37 <ski> this means that it's not the caller of `fetchAsync' (who provides that argument function) that will get to decide what type `a' should be
08:25:41 <Tjr> ski: bye & thanks for the discussion
08:25:51 <ski> rather `fetchAsync' will decide for itself
08:25:56 <ski> Tjr : *nod*, nice to chat
08:27:21 <joseanpg> Hi
08:27:40 <ski> (possibly `fetchAsync' could use its argument polymorphic functions in several places, possibly with different choices of `a' for each -- in your particular case, there will probably only be one place, and the `a' it chooses will be the (unknown) type (`a') that is hidden inside the argument of type `BlockedFetch r'
08:27:41 <fread2282> ski: wrong user?
08:27:53 <ski> fread2282 : hm, yes. sorry
08:28:13 <ski> biscarch ^
08:28:23 <biscarch> ski: reading
08:28:26 <ski> hello joseanpg
08:30:02 <fread2282> are there any big users of classy-prelude on github or otherwise available?
08:30:57 <joseanpg> hello ski
08:31:12 <ski> are you new to Haskell ?
08:38:22 <biscarch> ski: yes, that works when I use a concrete `a`. I'm currently trying to abtract it out though.
08:40:42 <biscarch> So I guess I would need to go a different route for `a` to be polymorphic.
08:40:43 <ski> it also works for unknown `a', whether that comes because `fetchAsync's type is universally quantified over such an `a' (if we imagine `fetchAsync :: forall r a. (forall a. a -> ...) -> BlockedFetch r -> (..a..) -> IO (Async ())'), or because the type of an argument of it existentially quantifies over `a' (as `BlockedFetch r' basically does)
08:41:01 <ski> `a' is just a type variable, it can't be polymorphic
08:41:22 <ski> values of type of the shape `forall a. ..a..' are called polymorphic
08:41:51 <biscarch> ok
08:41:56 <ski> typically, when stating a type signature `foo :: forall a. ..a..', that is shortened to `foo :: ..a..', taking the `forall a.' part to be implied
08:42:14 <biscarch> right
08:42:21 <ski>   data BlockedFetch r = forall a. BlockedFetch (r a) (ResultVar a)
08:42:27 <ski> gives
08:42:44 <ski>     BlockedFetch :: r a -> ResultVar a -> BlockedFetch r
08:43:31 <ski> and we know this works for every `a' (because of the `forall a.' before the data constructor, in the `data' type declaration), and for every `r' (because it's a parameter of the declaration)
08:43:35 <ski> so, we really have
08:43:42 <ski>   BlockedFetch :: forall r a. r a -> ResultVar a -> BlockedFetch r
08:43:49 <ski> now, this is almost the same as
08:44:12 <ski>   BlockedFetch' :: forall r a. (r a,ResultVar a) -> BlockedFetch' r
08:44:15 <ski> corresponding to
08:44:31 <ski>   data BlockedFetch' r = forall a. BlockedFetch' (r a,ResultVar a)
08:44:52 <ski> and now we can restate the type signature of the data constructor :
08:44:58 <ski>   BlockedFetch' :: forall r a. (r a,ResultVar a) -> BlockedFetch' r
08:45:05 <ski>   BlockedFetch' :: forall r. forall a. (r a,ResultVar a) -> BlockedFetch' r
08:45:12 <ski>   BlockedFetch' :: forall r. (exists a. (r a,ResultVar a)) -> BlockedFetch' r
08:45:47 <ski> because of the logical law that says that `forall a. (..a.. -> ...)' is equivalent to `(exists a. ..a..) -> ...', provided the `...' doesn't mention `a' (freely)
08:46:28 <ski> this is why such datatypes are usually referred to as "existentially quantified", in Haskell
08:46:49 <bergmark> pretty confusing that ghc tells you "no instance for MyTypeAlias" instead of resolving the name ;-(
08:47:10 <ski> (though i suppose it's really the data constructors which are "existential", in that their argument (conceptually) has an existential in them)
08:47:44 <biscarch> ski: yes. Existentially Quantified Types just made sense for me in a new way. Thank you.
08:48:56 <ski> iow
08:49:02 <ski>   data BlockedFetch' r = forall a. BlockedFetch' (r a,ResultVar a)
08:49:07 <ski> could possibly have been written as
08:49:16 <ski>   data BlockedFetch' r = BlockedFetch' (exists a. (r a,ResultVar a))
08:49:29 <ski> if there had been any `exists' keyword in Haskell
08:50:54 <ski> anyway, the data constructor is polymorphic in the "hidden" type variable because it'll accept any choice of type for it, but since it doesn't occur in the result type, that type will be "hidden" by the application of the data constructor, there won't anymore be a trace in the types as to what this type was
08:51:34 <ski> (unlike applying `Just :: forall a. a -> Maybe a', e.g., where `Just False :: Maybe Bool', recording the type `Bool' of the variably typed part `False')
08:52:43 <ski> and because any type could have been hidden, and we don't know it from the type of the whole constructed value, we can't (in general) know what type we'll get when we unpack (pattern match) on the value
08:53:06 <ski> so we have to expect any possible type, so we can assume nothing
08:53:52 <ski> this is very similar to the way `a' works in `length :: forall a. [a] -> Int' (and other polymorphic values), since here the called function can't assume anything about the type Â´a' -- it is also unknown (to `length')
08:54:43 <ski> for `callee :: forall a. ..a..', the callee of this decides the actual type to use for `a', and `callee' has to be able to work with any such choice
08:55:13 <ski> er, the *caller* decides the actual type to use for `a'
08:56:01 <ski> for `callee :: exists a. ..a..' (if that was valid syntax), it's the *`callee'* which decides which actual type to use for `a', and any "caller" (/ user), they have to be able to work with any such choice, has to be prepared for anything
08:56:33 <ski> so in this way, `forall' and `exists' are dual, they flip the roles of caller and callee as to who decides the actual type to use for the type variables
08:56:41 <ski> biscarch : does that help ?
08:56:50 <biscarch> yes. definitely.
08:57:05 <biscarch> saving that for future reference as well.
08:57:48 <Sculptor> g'day
09:03:55 <biscarch> ski: I just got everything working (including other stuff related to that). Thanks for the thorough explanation.
09:04:55 <chrisdone> has anyone done any image edit distance algos in haskell?
09:05:06 <chrisdone> to give a similarity rating
09:05:25 <ski> bergmark : hth
09:05:56 <chrisdone> ski :: Bergmark -> Biscarch
09:06:07 <chrisdone> maybe? =p
09:07:10 <ski> hehe, yeah, must be it
09:07:53 <deweyvm> okay i ran some profiling on my memory leak. -sstderr says the program is using a constant 2MB, but `top` says that its steadily increasing (albeit slowly). what does this mean? output http://pastebin.com/mMUkZkcp
09:08:00 <deweyvm> memory leak in native code maybe?
09:12:22 <zert> hi guys
09:12:55 <chrisdone> deweyvm: perhaps some C code is hanging onto memory unseen by the GC?
09:12:59 <zert> where i can find transition manual from tls-1.1 to tls-1.2?
09:13:17 <zert> there is so many changes so i cannot fix old code
09:14:43 <bergmark> zert: i'm wondering the same thing
09:14:53 <bergmark> but i think i managed to sort out most of it...
09:15:56 <zert> what instead of fileReadCertificate and fileReadPrivateKey now?
09:15:56 <deweyvm> chrisdone: thats what im afraid of :(
09:16:14 <bergmark> people who don't like upper bounds seem to also not like changelogs
09:17:06 <bergmark> zert: using certificate? you need to switch to the x509-* packages
09:17:10 <chrisdone> bergmark: meow
09:17:14 <bergmark> chrisdone: :3
09:17:19 <zert> oh, thanks
09:17:22 <zert> i'll see it
09:18:38 <ReinH> ocharles_: lol I fail at email
09:18:44 <schell> hi all, iâ€™m trying to profile an executable built with cabal and am getting this error when running my program with +RTS -sstderr â€œMost RTS options are disabled. Link with -rtsopts to enable them.â€
09:19:19 <bergmark> schell: easiest is to put ghc-options: -rtsopts in your cabal file
09:19:22 <schell> iâ€™ve tried adding -rtsopts to my cabal file as GHC-options and ld-options, is there another?
09:19:32 <schell> oh well then maybe my ghc is borked
09:20:27 <bergmark> you need to build everything with profiling enabled also, i think
09:21:27 <schell> bergmark: is that a completely separate process?
09:23:07 <bergmark> schell: reinstall (all?) packages with --enable-library-profiling
09:23:23 <schell> what iâ€™ve done so far is update my ~/.cabal/config with library-profiling : True, rm -rf ~/.ghc, cabal install â€”reinstall world and then update my packages ghc-options (and ld-options)
09:24:04 <schell> ah - so - cabal install â€”reinstall â€”enable-library-profiling world
09:24:16 <bergmark> ok, i don't recall if there were any other steps
09:24:47 <schell> i just realized that i hadnâ€™t set executable-profiling: True in my cabal config
09:26:31 <schell> doing this installs some profiling symbols (or something) â€œnext toâ€ the regular packages correct? not â€œinstead ofâ€
09:26:35 <pchiusano> in Haddock, is there a way to supply docs for a constructor's fields, without naming these fields?
09:27:08 <pchiusano> as in, if I have data Bar = Blah Foo Foo | â€¦
09:27:10 <rwbarton> schell: library-profiling, yes
09:27:26 <rwbarton> executable-profiling will produce a profiled executable "instead of"
09:27:27 <pchiusano> and I want to document what the first Foo and second Foo mean in Blah
09:28:32 <schell> rwbarton: okay - so if i ever decided to â€œrealeaseâ€ a binary i could set executable-profiling: False and the cabal build with -O2 or something and have a â€œleanâ€ binary?
09:29:17 <bergmark> schell: yes
09:29:30 <schell> awesome! thanks guys
09:31:48 * hackagebot clippings 0.1.2 - A parser/generator for Kindle-format clipping files (`My Clippings.txt`),  http://hackage.haskell.org/package/clippings-0.1.2 (vi)
09:33:28 <samrat> if I have two IO [String] 's how do I zip them up together? I figured out how to zip an IO with Int's using liftM but having trouble when both are IO
09:34:13 <jfischoff> there are a few ways, but the easiest for beginners tends to be to use do notation
09:34:16 <samrat> ie. I want to write something of type IO [String] -> IO [String] -> IO [(String, String)].
09:35:01 <jfischoff> foo mx my = do { x <- mx; y <- my; return $ zip x y; }
09:35:20 <jfischoff> maybe I got the braces right :p
09:35:44 <jfischoff> otherwise there is liftM2 zip mx my
09:35:55 <jfischoff> and zip <$> mx <*> my
09:36:09 <jfischoff> :t liftM2
09:36:10 <lambdabot> Monad m => (a1 -> a2 -> r) -> m a1 -> m a2 -> m r
09:36:13 <benzrf> liftA2 tho
09:36:18 <jfischoff> sure
09:39:39 <samrat> jfischoff: thanks a lot. the first solution seems simplest to understand atm so I'll probably use that one. need to read up more on liftM2 though
09:40:21 <jfischoff> I would say for better or worse beginners start with the first solution then the second and then the third
09:41:20 <benzrf> jfischoff: actually, i use liftA2 even though i know applicatives perfectly well
09:41:24 <benzrf> it just reads clearer to me
09:41:27 <jfischoff> me too
09:41:59 <jfischoff> but it does seem that is the order people learn those forms, personal perference being another thing
09:42:32 <benzrf> hmm
09:42:35 <jfischoff> I use the applicative operators for more then two args though
09:42:56 <benzrf> yea
09:47:56 <ski> @type liftM2 . zipWith
09:47:57 <lambdabot> Monad m => (a -> b -> c) -> m [a] -> m [b] -> m [c]
09:48:15 <ski> @type liftM2 (zipWith (++))
09:48:16 <lambdabot> Monad m => m [[a]] -> m [[a]] -> m [[a]]
10:00:13 <ReinH> Hmm, I almost never use liftA* or liftM*
10:00:22 <ReinH> Not that I think thereâ€™s anything wrong with them.
10:00:34 <dwcook> ReinH: Do you prefer f <$> x <*> y?
10:00:38 <ReinH> Yeah
10:01:17 <chrisdone> me neither
10:01:35 <dwcook> In general if I know of an existing combinator for something, I tend to use it, unless I have an established preference for something else.
10:01:35 <chrisdone> i should because operators are a pita
10:01:50 <dwcook> For example, recently I found myself doing const . void $ â€¦ -- :)
10:02:10 <jfischoff> actually parsing and typing the intermediate parts of f <$> x <*> y <*> z is a good exercise
10:02:15 <pjdelport> liftA* / liftM* are occasionally useful when passing a function somwhere.
10:02:45 <jfischoff> really drives home the value of curried functions
10:02:58 <pjdelport> e.g. foldr (liftA2 (:)) (pure [])
10:03:15 <ReinH> pjdelport: true!
10:05:06 <schell> re:profiling - that totally worked, thanks!
10:07:16 * hackagebot clippings 0.1.3 - A parser/generator for Kindle-format clipping files (`My Clippings.txt`),  http://hackage.haskell.org/package/clippings-0.1.3 (vi)
10:08:22 <jfischoff> sometimes I wish there was a way to just write types, and if a definition was missing the compiler would just make it undefined
10:08:32 <jfischoff> writing undefined over and over again is annoying
10:09:31 <pjdelport> jfischoff: http://www.haskell.org/haskellwiki/GHC/TypedHoles ?
10:10:10 <jfischoff> yeah shorter, but i still have to repeat the name of the declaration
10:10:50 <jfischoff> e.g, foo = _ ; foo :: Int -> String
10:11:02 <jfischoff> I just want to write foo :: Int -> String
10:11:49 <shergill> i think it's nice to make it explicit. considering you're going to write the definition at some point you're only typing an extra '_'
10:12:15 <jfischoff> I'm not always going to write a function
10:13:05 <shergill> then why treat it as a function, or that's something that only becomes clear later on?
10:13:36 <jfischoff> I'm experimenting with different API choices
10:14:17 <jfischoff> most of the experiments I will throw away
10:14:18 <shergill> gotcha. in any case, i'm glad it's not the default
10:14:49 <jfischoff> yeah sure, but I would like to be able to pass a flag -fassume-undefined
10:17:13 <shergill> jfischoff: you could write some template haskell with a hopefully light enough syntax
10:17:43 <jfischoff> *shrug*
10:18:16 <saml> if someone asks how to learn haskell, what should i respond with?
10:18:21 <saml> recommend lyah ?
10:19:09 <jaco60> I've enjoyed "Programming in Haskell", too
10:19:09 <genericpersona> yeah, that's a good one
10:19:30 <genericpersona> or the Beginning Haskell book by Mena
10:20:02 <shergill> lyah, followed by haskell wiki-books, and typeclassopedia
10:20:06 <Sculptor> are there books like 'how to bring home the bacon with haskell'
10:20:44 <frontendloader> fridayfours
10:21:08 <ski> saml : you could direct them here, as well :)
10:21:51 <ski> @where tryhaskell
10:21:51 <lambdabot> http://tryhaskell.org/
10:22:04 <ski> saml : ^ could also be helpful
10:25:53 <saml> thanks ski
10:31:30 <hemanth> Can I view thunks in ghci? as in say (4+2,1) will be stored as (<thunk 4+ 2>, 1) internally right? Can I view that internal storage?
10:31:43 <chrisdone> :print and :sprint might work
10:32:32 <rwbarton> be careful with type class polymorphism / NoMonomorphismRestriction
10:32:52 <hemanth> chrisdone, like?
10:33:39 <hemanth> ghci said (_,4); for sprint
10:33:53 <hemanth> so _ is like not yet computed, thunk?
10:34:06 <rwbarton> yep
10:34:14 <hemanth> >> :sprint (2+3,4)
10:34:30 <hemanth> did not work, had to store it in a variable and then do a :sprint
10:35:05 <rwbarton> then you can e.g. evaluate the variable and :sprint it again
10:35:13 <hemanth> ((_t1::Integer),4) cool, makes sense.
10:35:40 <rwbarton> also check out ghc-vis
10:35:53 <hemanth> rwbarton, but why not just :sprint (2+3,4) works?
10:36:26 <rwbarton> well, in general, it wouldn't show you anything interesting
10:36:40 <rwbarton> since nothing can ever cause computation of that expression
10:37:04 <hemanth> ha, ok
10:37:06 <rwbarton> it would normally always print _
10:37:46 <rwbarton> this case is a bit special because constructors (the pair) and integer literals are already evaluated
10:38:17 <hemanth> that 2+3 is not evaluated unless we ask for it, right?
10:38:22 <jamiehannaford> does anybody know what the ruler function is? I don't know how it's returning the values
10:38:34 <darthdeus> @faq Is Predicate a functor?
10:38:34 <lambdabot> http://www.haskell.org/haskellwiki/FAQ
10:38:36 <hemanth> that's why it's called a thunk, no?
10:38:39 <darthdeus> -_-
10:39:20 <saml> :t ruler
10:39:21 <lambdabot> Not in scope: â€˜rulerâ€™
10:39:39 <jamiehannaford> saml it's a mathematical function I'm trying to write in haskell
10:40:06 <saml> jamiehannaford, http://mathworld.wolfram.com/RulerFunction.html ?
10:40:18 <hemanth> rwbarton, chrisdone, I'm learning haskell and making notes here -> https://github.com/hemanth/haskell-rascal/ :)
10:40:42 <ReinH> hemanth: yay!
10:40:58 <hemanth> ReinH, heh heh thanks
10:41:22 <hemanth> is ghc-vis packaged with ghci or should it be installed?
10:42:50 <rwbarton> it's a library on hackage
10:43:33 <kini> so does haskell-mode not currently parse -XMultiWayIf syntax?
10:43:58 <ReinH> chrisdone: ^
10:44:26 <ReinH> Oh no I have summoned himâ€¦ Prepare yourselves... He approaches...
10:44:31 <hemanth> cabal install ghc-vis --enable-shared --disable-library-profiling
10:44:37 <ReinH> Or maybe not.
10:45:06 <kini> lol
10:45:55 <kini> rather than haskell-mode I guess I should have said haskell-indentation
10:46:23 <kini> since the parse error occurred when I hit tab, and the backtrace has a bunch of functions that start with "haskell-indentation"
10:47:24 <fread2282> straw poll: do you prefer << and >> or <* and *> on a asthetic basis?
10:47:59 <shachaf> (<<) is not a function in the standard library, and probably shouldn't be.
10:49:23 <saml> jamiehannaford, ruler x is largest n such that 2^n divides 2*x
10:49:57 <kini> shachaf: why not?
10:50:27 <shachaf> It's unclear whether it should be like (<*) or like flip (>>).
10:50:43 <jamiehannaford> so if 1 is my input, it would the largest value of n in 2^n / 2?
10:50:57 <saml> 2^n is 2*2*2*... n times.   so when x is odd,  ruler x  will be 1   because only 2^1  divides 2*oddNumber
10:51:09 <fread2282> shachaf: but wouldn't those be the same?
10:51:22 <shachaf> No.
10:51:55 <fread2282> :t (<*)
10:51:56 <lambdabot> Applicative f => f a -> f b -> f a
10:52:02 <fread2282> :t (flip (>>))
10:52:03 <lambdabot> Monad m => m b -> m a -> m b
10:52:51 <chrisdone> what's the right cabal syntax for restraing a dependency like this? foo == 2.8.* || == 2.11.* || == 2.13.* || = 2.14.*
10:52:53 <zwer> what did you mean by like (<*)? (<<) = (<*) ?
10:53:45 <jamiehannaford> saml so if x = 3, how does n = 1 in 2^n / 6?
10:53:55 <saml> yes
10:54:24 <jamiehannaford> but that doesn't result in a whole number. and how is that the highest?
10:54:29 <saml> if x is 3,  find the largest number in 2,4,8,16,32, ...  that divides 2*3 = 6.  it is always 2. so n = 1
10:55:13 <saml> > [2^1, 2^2, 2^3, ..]
10:55:15 <lambdabot>  <hint>:1:17: parse error on input â€˜..â€™
10:55:56 <fread2282> > (^) <$> [2,2..] <*> [1..]
10:55:57 <lambdabot>  [2,4,8,16,32,64,128,256,512,1024,2048,4096,8192,16384,32768,65536,131072,262...
10:56:36 <jamiehannaford> saml 2 / 6 is a third - so how is that higher than, say, 8 / 6 which is 1 and a third?
10:56:44 <saml> no,  6/2 = 3. no remainder
10:57:08 <saml> 6/4 = 1 with remainder.  so answer is 2.
10:58:09 <honza> in aeson, how can i parse a numeric string into a maybe int? i have a custom data type and one of its fields is a maybe int
10:59:22 <honza> tried something like liftM p (v .: "field_name) where p has a type of Value -> Maybe Int
10:59:44 <h_noob> hey is it possible to search results from :browse in ghci??
10:59:57 <h_noob> or dump them into a string?
11:01:47 <geekosaur> h_noob, see http://www.haskell.org/haskellwiki/Ghci
11:01:56 <luite> chrisdone: oh i just realized i never submitted the reply to your reddit messsage on ghcjs/fay ffi. the reason GHCJS doesn't have `ffi "%3.a(%1,%2)"' syntax is that it introduces new syntax, ffi can only be applied to a literal, so it's not really a function (either that, or you have to check the pattern at runtime, which i like even less), i prefer to be conservative with changes like that to the language
11:02:02 <geekosaur> there's tricks hidden in there that let you capture output like that etc.
11:02:36 <h_noob> ok thx!
11:02:42 <schell> man - ghcâ€™s profiling reports are bomb
11:03:47 <luite> chrisdone: the same for automatic String marshalling (marshallign Text is a lot more efficient, toJSString for String actually converts through Text)
11:09:27 <flux> btw, how's darcs doing these days?
11:10:00 <flux> oh, almost zero research suggests not bad, it's in google summer of code program as well
11:10:03 <luite> chrisdone: but I have to admit that I usually spend much time on technical issues without focussing too much on what the user would want to write. i did get the machinery that allows us to change ffi types mergd in GHC 7.8 so nothing is set in stone
11:11:57 <saml> if x<=minX || x>maxX then defaultX else x        is there a name for this?
11:15:56 <luite> chrisdone: that said, I think that an XMLHttpRequest binding  xhr :: Request -> IO Response   (rather than xhr :: Request -> (Response -> IO ()) -> IO () ) is preferable over following JS closely.
11:15:56 <chrisdone> luite: i wasn't really advocating the ffi "foo" syntax, i meant rather that the %1.%bar or $1 %2 stuff is good. the automarshalling is the nicest thing for me
11:16:25 <chrisdone> luite: yeah hooking into the continuation is nice
11:17:52 <chrisdone> sweet, i'm just about done making haskell-docs work across four major ghc versions and haddock versions
11:18:01 <luite> chrisdone: i have some code where you can abort the request with an async exception (so timeout 1000 . xhr :: Request -> IO (Maybe Response)) where it closes the connection automatically
11:18:09 <h_noob> argh.  ok is there a way to search through :browse that's built in to ghci?
11:18:18 <luite> never got around to publishing it, wanted to show it at lambdajam but my video out didn't work :(
11:18:26 <chrisdone> h_noob: without a decent terminal? not that i know of
11:18:45 <hemanth> is there a file like .ghcrc or something similar, where I can :set prompt  of my choice?
11:18:52 <chrisdone> yeah, .ghci
11:18:58 <chrisdone> luite: sounds nnice
11:19:24 <chrisdone> :set prompt "Î»> "
11:19:52 <luite> chrisdone: oh and some cute example whre it does a streaming lazy xhr, and mapM_ T.putStrLn =<< take 10 . T.lines <$> lazyXhr "url"  gets a lazy text from the server and closes the connection after reading 10 lines
11:19:57 <ReinH> luite: will you be at chicago lambda jam?
11:20:21 <chrisdone> luite: what happens if the connection has an error? =p
11:20:27 <chrisdone> luite: lazy exceptions? =p
11:20:41 <h_noob> ok I'll just set my buffer higher and copy the results into a text editor for now
11:22:04 <hemanth> chrisdone, cool, thanks, that file was missing for me, I went and created it, ghci picked it :) and for me it's :set prompt "haskell-rascal> " ;)
11:23:44 <luite> chrisdone: yep, the code that forces the lazy things gets the exception, like you'd expect. lazy IO is definitely not suitable for everything, but I like that it works and is so easy to use
11:28:27 <luite> chrisdone: but since you've written much more client side code than I, do you mostly use String/Text marshalling, or do you also want things like (Maybe a) and functions to work?
11:29:47 * hemanth :if at all ghc.io has ghc-viz package installed :{
11:31:57 <ironChicken> I'm getting "Not in scope: data constructor `Ptr'"
11:32:14 <ironChicken> i have "import Foreign (Ptr, peek)"
11:32:33 <luite> hemanth: booh that thing is boring, try http://codeworld.info/ instead ;)
11:32:51 <rwbarton> ironChicken: you probably shouldn't be using the *data constructor* Ptr
11:32:57 <rwbarton> ironChicken: you've imported the type
11:34:36 <hemanth> luite, thanks, checking it out
11:34:43 <rwbarton> ironChicken: what is your code that is producing that error? and what are you actually trying to do
11:36:39 <luite> actually i shouldn't promote that thing since i'm still mad at cdsmith for making me implement eq' :: a -> a -> Bool (without an Eq constraint) comparing the contents of the heap objects directly, after a deepseq (also without NFData constraint, yuck)
11:37:03 <ironChicken> rwbarton: hmm, ok. i'm thinking about this. may ask a better question later
11:37:42 <cdsmith> luite: I really appreciate it, though.
11:38:12 <luite> =)
11:38:21 <schell> luite: is codeworld.info ghcjs or â€¦?
11:38:33 <luite> schell: yeah it uses ghcjs now
11:38:50 <cdsmith> Yes, GHCJS
11:39:11 <schell> is the main way to run ghcjs through a vm?
11:39:16 <hemanth> luite, still trying to figure out how ghc-vis could be used in the URL you pass me
11:39:48 <luite> hemanth: oh there's no ghc-vis yet for ghcjs, but it's coming :)
11:40:20 <cdsmith> For codeworld.info, I installed GHC 7.8 and built it directly
11:40:37 <luite> atm i'm busy doing a template haskell restructuring, GHCJS is going to run TH through node.js instead of building native code for everything
11:41:00 <hemanth> nice luite, anyway I'm adding that link to https://github.com/hemanth/haskell-rascal/ thanks! :)
11:41:04 <luite> since that affects a bigger part of the ecosystem (cabal in particular) i decided to do before release
11:41:31 <chrisdone> luite: dunno, Maybe a in fay just serializes the object to a JS object. Defined/Nullable serialize to undefined/null, tho
11:42:11 <rinder> I am trying to compile with --enable-library-profiling, but one of the packages (clock) does not have profiling libraries installed. why does it not have them? and is it safe to reinstall the clock package?
11:42:36 <rinder> I am trying to recompile my program for debugging purposes
11:44:44 <luite> chrisdone: right, i'm just trying to figure out what needs to be supported directly in the compiler and where it's easy to do with some library function
11:46:48 <luite> schell: a VM is not recommended anymore, just install GHC 7.8, install an updated Cabal and then install from github
11:47:03 <schell> luite: badass!
11:47:09 <schell> iâ€™ll check it out today
11:48:06 <luite> schell: the ghcjs-boot program might be a tad flaky, since the boot procedure is still rather fragile (because it needs to build working native code for everything)
11:48:50 <schell> luite: okay, but youâ€™re here and you talk, so thatâ€™s a big plus
11:48:52 <luite> schell: i'm working on the fix, but since that requires a bit of restructuring (changing how template haskell is run) it's not there yet. anyway join #ghcjs if anything fails
11:48:56 <luite> or here
11:51:29 <luite> cdsmith: i think the animations can be made smoother with requestAnimationFrame and h$runSync if you aren't already doing so
11:52:23 <cdsmith> luite: I am using requestAnimationFrame.  Not sure what you mean about h$runSync
11:53:36 <cdsmith> luite: I'm doing this: foreign import javascript interruptible "window.requestAnimationFrame($c);" js_waitAnimationFrame :: IO ()
11:56:45 <luite> cdsmith: oh, well requestAnimationFrame sets up a callback, ideally you'd recompute the whole next frame before returning from there. just calling $c wakes up the thread but it will only be scheduled later
11:57:42 <luite> cdsmith: h$runSync forces a whole computation to run immediately (as far as possible, since it has to suspend when blocking on an MVar for example)
11:58:14 <cdsmith> luite: I see.  So the callback passed into requestAnimationFrame just schedules a second callback?
11:59:09 * hackagebot haskell-docs 3.0.0 - A program to find and display the docs of a name from a  given module.  http://hackage.haskell.org/package/haskell-docs-3.0.0 (ChrisDone)
11:59:16 <ironChicken> ok, I've moved all my Ptr stuff into one place where the FFI is actually being used
12:02:40 <luite> cdsmith: here $c marks the blocked thread runnable, and then the next time the ghcjs scheduler is entered (h$mainLoop) it will run. but h$mainLoop itself is scheduled with a setTimeout loop, which probably doesn't run in sync with the animation
12:03:01 <lpsmith> Hmm, if a module exports another module,  is there a way to hide that entire module?
12:03:20 <geekosaur> no, it looks like it came from the module you imported
12:03:58 <lpsmith> right, but I was hoping I could do hiding (Blah) or hiding (module Blah) or some such
12:04:04 <lpsmith> But that doesn't appear to be the case.
12:04:35 <luite> cdsmith: I could change the handling of $c a bit so that it immediately runs one scheduling quantum of the thread in question
12:04:36 <lpsmith> Basically expand all the identifiers from that module out into the hiding definition
12:04:55 <geekosaur> as I said, that information is gone at that point
12:05:02 <cdsmith> luite: So I want to build an IO action to render a frame, wrap it with syncCallback, and then do something like foreign import javascript unsafe "window.requestAnimationFrame(function() { h$runSync($1); });" scheduleAnimation :: JSFun (IO ()) -> IO () ?
12:05:17 <geekosaur> the importing module cannot tell that some symbols came form a full module export; they all look like they are coming from the module you imported
12:06:07 <luite> cdsmith: yep that should work with the current version
12:06:08 <geekosaur> (ghc remembers it in types, but not in the module import info)
12:06:37 <lpsmith> No, the information is not gone.  I'm assuming the module you want to hide is visible,  and GHC does ultimately know where functions are defined from,  c.f. :info
12:06:58 <cdsmith> luite: The change to $c sounds like a decent optimization to me, but I'll make that change in the site now, so don't do it just for me. :)
12:08:19 <lpsmith> :info can even tell you where a function is defined whether the module is visible or not.
12:08:34 <luite> cdsmith: it's a very old issue actually, #59, more than a year old, you just reminded me of it :)
12:09:45 <luite> cdsmith: are you using -O or -O2 for your library/programs btw?
12:10:00 <lpsmith> I mean, the simplest (but perhaps not the most correct) is just to treat hiding (module Blah) as syntactic sugar for explicitly listing each and every identifer that Blah exports
12:10:02 <cdsmith> Using -O2 at the moment
12:10:33 <cdsmith> Well, for the programs.  Actually, I guess I'm not for the library.  Perhaps I should change that
12:10:49 <luite> cdsmith: okay, firefox in particular seems a bit sluggish. it has far worse memory management than the others though, so some slowness is expected
12:11:02 <luite> ah it can make a pretty big difference
12:11:28 <cdsmith> luite: I'll change that at the same time as the callback change.  Working on it now.
12:12:14 <lpsmith> A refinement of said technique would be to only hide those identifers that are using the same definition as the one exported,  although I don't know if that would be more "correct" or not
12:13:10 <luite> cdsmith: i'll add the $c change to my todo list, it's a fairly simple/local change, and i think it would be a win in most situations
12:13:34 <lpsmith> I can see arguments for both semantics,  though the ideal semantics I'd have in mind would depend on the intentions of the library writer which aren't available to GHC.
12:14:23 <nschoe> Hi, what is the "cleanest" way to check if a program exists from Haskell ? I plan on using System.Process.system "which progName" and check the resulting ExitCode.
12:14:49 <lpsmith> e.g. a simple passthrough implementation (used e.g. to deprecate an export) you might actually want to hide,  but maybe not another identifer that's redefined
12:15:53 <luite> cdsmith: and i like the blocking "waitForAnimationFrame :: IO ()" pattern better actually :)
12:15:58 <nschoe> Is it a "hack or is it okay ?
12:16:03 <monochrom> nschoe: there is a concern that some shells' "which" are inaccurate. (System.Process.system calls up a shell.) apart from that, it's the basic approach I would try
12:16:18 <cdsmith> luite: Yeah, I agree it's nicer.
12:16:35 <cdsmith> And not having to mention h$runSync in Haskell code is a huge bonus.
12:16:57 <nschoe> monochrom, (thanks), what do you mean by "inaccurate" ?
12:17:13 <lpsmith> What I'm working on at the moment involves a TQueue augmented with two additional operators,  one of which cannot be reasonably defined in terms of the public interface,  and one that's a lot more efficient if you bypass the public interface
12:17:37 <lpsmith> namely,  read the entire queue for inspection,  and another to modify the head of the queue
12:17:40 <luite> cdsmith: well you'd typically do syncCallback instead of doing it from JavaScript, but yeah, callbacks are a tad ugly with all their options
12:18:23 <cdsmith> Oh!  So if I wrap in syncCalback, I can skip the h$runSync?
12:18:44 <luite> cdsmith: yeah it creates a JSRef that does the h$runSync for you
12:19:01 <lpsmith> It'd be nice if I could just import Control.Concurrent.STM hiding (module Control.Concurrent.STM.TBQueue);  import TBQueue
12:19:29 <cdsmith> So I've just got foreign import javascript interruptible "window.requestAnimationFrame($1);" js_requestAnimationFrame :: JSFun (IO ()) -> IO ().  Any issues?
12:19:30 <monochrom> nschoe: sometimes "which" gives a wrong answer.
12:19:36 <literon> hi
12:19:55 <luite> cdsmith: unsafe, not interruptible
12:20:04 <cdsmith> Right, thanks.
12:20:14 <literon> Having LANGUAGE DoRec in ghc 7.8 gives me a warning that it is deprecated in favor of RecursiveDo - I thought it was the other way around, no?
12:24:37 <cdsmith> luite: Done.  I think it made a slight difference, but it might just be comfirmation bias.
12:25:43 <literon> hm, apparently no
12:25:52 <monochrom> literon: I'm guessing this: RecursiveDo covers both mdo and rec, DoRec covers rec only. they now want you to move to the more general one.
12:27:35 <literon> ahha - RecursiveDo was deprecated in 6.12 for DoRec, but it seems that now DoRec is deprecated again for RecursiveDo
12:27:47 <Rembane> The circle of life
12:27:56 <NeatBasis> asdfghjklÃ¶Ã¤'
12:28:00 <monochrom> RecursiveDeprecate
12:28:01 <literon> in this case the http://www.haskell.org/haskellwiki/MonadFix is misleading
12:28:28 <monochrom> no, just old, 6.12 era. (I was there. I wrote most of it.)
12:29:15 <literon> nice
12:29:42 <monochrom> well, I guess I'll have to change it. Goddamned Eurasia / East Asia.
12:30:43 <luite> cdsmith: i just added a comment, more ideas welcome https://github.com/ghcjs/ghcjs/issues/59
12:31:38 <luite> cdsmith: do you request the next animation frame from within the h$runSync ?
12:32:11 <cdsmith> luite: Yes.
12:32:52 <cdsmith> luite: Currently, I'm creating a new syncCallback every frame with a new closure.  I could switch to using IORef if that's too expensive.
12:33:05 <luite> cdsmith: aie that is really expensive
12:33:21 <cdsmith> luite: Got it.  Another change coming then
12:33:31 <luite> cdsmith: well depends on the retention, if you use AlwaysRetain then it will leak :)
12:33:36 <Smilex> when importing foreign C functions, is it more correct to say that the function returns an IO monad, rather than just a value, if the function does anything except just return a value?
12:34:15 <cdsmith> Right now I'm using NeverRetain, on the theory that I don't depend on any weak references or MVars
12:34:32 <luite> cdsmith: okay that's ok, and leaks less :)
12:34:45 <cdsmith> luite: Still worth switching to IORef?
12:35:20 <luite> cdsmith: possibly, just wondering how you're requesting the next frame from a synchronous thread. you have continueAsync = True?
12:35:51 <luite> or wait, you're just passing it in I guess, not a blocking call
12:35:54 <cdsmith> Oh.  Yes, continueAsync = True
12:36:11 <cdsmith> And yes, it shouldn't block
12:36:28 <luite> right then it doen't matter
12:36:48 <luite> continueAsync doesn't have any overhead unless the thread blocks on something
12:38:45 <rinder> is it possible to download profile version of a package I already have? without reinstalling it (trying to reinstall it tells me I would likely break some packages that depend on it)
12:39:25 <luite> cdsmith: is the change already http://codeworld.info ?
12:39:32 <luite> in
12:40:01 <cdsmith> luite: Yes
12:40:36 <cdsmith> luite: Actually, I'm being dragged off for lunch.  I'll try the IORef version this afternoon and see how much difference it makes.
12:41:01 <cdsmith> luite: Thanks for the help again!
12:42:38 <luite> cdsmith: cool, firefox seems a lot smoother than i recall it was last tim
12:42:42 <luite> e
12:44:09 <f-a> just to make sure I didn't get it wrong. Is this two liner tail recursive? pn (n:ns) a | n > 2000000 = a | otherwise   = pn ns (a*n)
12:44:19 <f-a> gah, I meant http://paste.debian.net/104859/
12:47:17 <literon> f-a: tail recursive, but will collect a large thunk in the accumulator
12:47:57 <f-a> literon: any tip to make that more efficient?
12:48:31 <literon> otherwise = let x = a * n in x `seq` x
12:48:48 <f-a> thanks
12:49:12 <literon> for efficiency you could use some kind of fold instead hand-rolling I guess
12:49:49 <f-a> indeed that's sensible
13:00:19 <charlieb>   /ignore -channels #haskell * JOINS PARTS QUITS NICKS
13:00:29 <charlieb> oops sorry
13:01:07 <danielszmulewicz> Hi there, is somebody in the mood to reply to a noob?
13:01:29 <charlieb> <-- or two noobs :)
13:01:37 <danielszmulewicz> :-)
13:02:02 <rinder> cabal by default does not install profile packages, and if I try to reinstall packages I need with profiling functionality I get a warning that I can break libraries and programs that depend on that package. how can I handle this?
13:02:57 <kazagistar> danielszmulewicz: ask your question, and someone might answer, dont ask, and you will certainly never get an answer
13:03:02 <heatsink> Unfortunately, I don't think that you have an alternative but to reinstall
13:03:32 <heatsink> You can change your cabal defaults so that future installs will automatically build profiling libraries
13:03:35 <eevar> rinder: rm -rf .ghc .cabal && cabal update && <edit your .cabal/config to enable profiling> && reinstall everything
13:03:46 <danielszmulewicz> kazagistar: thanks. I'll follow up on that.
13:04:42 <heatsink> Here's how to edit your cabal config: http://www.vex.net/~trebla/haskell/cabal-cabal.xhtml#config
13:04:44 <rinder> heatsink: if I try to reinstall cabal attempts to download never version of the package, which will apparently break packages that depend on it. cant I just tell cabal to install profiling library for the version of package that I already have?
13:05:17 <rinder> eevar: it sucks if that is the painless way to handle this :(
13:05:27 <heatsink> rinder: You can give cabal a specific package version to install
13:05:28 <danielszmulewicz> My question is this: when you write functions in a Haskell program, is the general practice to write type declarations or leave them out and let the compiler worry about it?
13:05:44 <heatsink> cabal install blah-1.1.2.3.5.8
13:05:56 <moghedrin> danielszmulewicz: Def. write the type declaration.
13:06:03 <monochrom> 3.1.4.1.5.9.2.6.5.3
13:06:43 <kazagistar> danielszmulewicz: in most contexts people write type signatures, because it (1) helps verify that your intuition about it is right (2) helps communicate your intent to people who read your code
13:07:07 <monochrom> I also write type signatures to help haddock :)
13:07:21 <eevar> rinder: I'm not sure it's the painless approach, but it'll probably work. tbh I avoid installing anything but essentials in ~/.cabal (i.e. ghc-mod, hlint, alex, happy and cabal-install)
13:07:55 <jhance> danielszmulewicz: Writing the type declaration forces the function to be the type you want it to be. You don't want to leave it out, because then if the function is defined wrong, the type error will usually occur where you used it rather than in the definition
13:08:21 <rinder> eevar: where do you install other packages?
13:08:39 <eevar> then i make a backup for whenever I forget to initialize a sandbox before using cabal. there shoudl be a sandbox-only option in the config imo
13:10:12 <parc> does anyone have a good idea of how cloud haskell compares to erlang itself?
13:10:49 <enthropy> rules like "put type signatures on every top-level decl" seem to push people to writing huge where clauses
13:11:17 <danielszmulewicz> Thanks, so is it only a "marketing" mantra that in Haskell you have an excellent type inference system to lean on?
13:11:20 * ski sometimes puts type signatures on local (mostly function) declarations, as well
13:11:36 <enthropy> so you end up with     f x y z = ... where functionNotUsingXYZ a b = ...
13:11:44 <danielszmulewicz> Or a misunderstanding?
13:11:45 <literon> enthropy: what do you mean "every top-level decl". Can you have other than main?
13:11:57 <ski> danielszmulewicz : some people prefer not writing as much type signatures
13:12:25 <ski> danielszmulewicz : you can add the intended type signatures later, if need be (e.g. when tracking down an error) -- but they do help with documentation
13:12:43 <kazagistar> I like my larger where clauses, but mostly because I don't like to fill my namespace up with 1-shot functions and whatnot... is that bad?
13:12:47 <mhl> HI, I'm doing some exercises from http://en.wikibooks.org/wiki/Haskell/ and I'm stuck on fold chapter.There is this exercise with implementing reverse function using some fold function. I've tried something like this: reverse' xs = foldr (:) [] xs, but it turns out that this is an invariant :) this returns not reversed list. What type of fold should I use here?
13:13:04 <ski> John Hughes (one of the original designers of Haskell, in the committe), doesn't write much type signatures in his code
13:13:16 <ski> kazagistar : i don't think so
13:13:22 <enthropy> literon: if you have a module M where { f = ..., g = ... }, by top-level I mean adding something like  f :: A
13:13:30 <ski> kazagistar : it can be slightly awkward for testing, sometimes
13:13:39 <parc> foldr works i think. look at the type signature for (:) vs foldr i think
13:13:59 <ion> The last time i looked, there was no OTP equivalent yet, but that was quite some time ago. Just copying its most important pays over based on the primitives that are already there probably won't be that huge a project.
13:14:11 <ski> kazagistar : it would be nice if one could "step into" a `where', and test the local functions, in GHCi, without having to move them to top-level (and possibly abstract over parameters to the outer declaration)
13:14:45 <enthropy> literon: I think you can have a main that is not called main (ghc --main-is=foo) but I don't think that's relevant
13:14:50 <literon> a single top-level declaration should be enough for everyone
13:15:02 <parc> no, foldl, but with flip (:) as the function :/
13:15:11 <cdsmith> danielszmulewicz: I definitely wouldn't call it "only a marketing mantra".  Haskell definitely does have excellent type inference, and it's very helpful.  You just don't want your programs to STAY that way for TOP-LEVEL definitions.  By all means, rely on inference when you're starting a new module, and for local definitions.
13:15:16 <ski> danielszmulewicz : personally, i usually write a type signature before writing the definition, because it seems to help me. you could experiment with both styles, and see what works best for you
13:15:47 <rinder> first time I try to debug something in haskell and everything is working against me..I reinstalled all the packages with profiling support, it broke some minor things in my program which I fixed, and now when  I compile with -gprof option I get this error: "cannot find -lHSbindings-DSL-1.0.20_p". without -gprof it compiles fine
13:16:09 <kazagistar> ski: that makes sense. The thing is, I also like to name partial results in many cases, and use where for that as well
13:16:31 <charlieb> I'm trying to write a fn that picks each item from a list and returns that item and the remainder in a list and I'm getting a type mismatch error and I just can figure it out
13:16:36 <charlieb> can I post code?
13:16:37 <ski> danielszmulewicz : but be aware that in some cases you have to write a type signature (polymorphic recursion, GADTs, and i think using `type'/`data' families also requires it -- and the DMR, in some cases)
13:16:40 <ion> s/pays/parts/, also highlight: parc
13:17:12 <danielszmulewicz> Very helpful answers, thanks!
13:17:17 <rinder> am I suppose to reinstall bindings-DSL with profiling enabled as well? error does not say that
13:17:30 <ski> kazagistar : i do that sometimes as well (usually separating the "local results" with the "local helpers" (which sometimes depend on a parameter to the outer declaration)
13:17:33 <ski> )
13:18:16 <ski> kazagistar : an alternative could be to use `let'-`in' for the "local results", i suppose
13:19:32 <kirelagin> charlieb: you should probably post a link to a pastebin
13:19:59 <rinder> yes that was it.. it finally worked
13:20:02 * hackagebot linx-gateway 0.1.0.1 - Implementation of the Enea LINX gateway protocol.  http://hackage.haskell.org/package/linx-gateway-0.1.0.1 (PatrikSandahl)
13:20:09 <danielszmulewicz>  `add = \(x,y) -> x + y` or `add (x,y) = x + y`? When I want to know what is better form, is there a style guide I can consult?
13:20:39 <solidus-river> aw, haste doesn't support Lens'es
13:20:40 <rinder> now the easy part, debugging a program that overflows stack after it runs for two hours :)
13:20:41 <kirelagin> add = uncurry (+)
13:20:59 <kirelagin> danielszmulewicz: anyway it's a matter of taste
13:21:15 <mhl> hm, foldl doesn't work here with (:)
13:21:27 <kirelagin> mhl: really?)
13:21:38 <parc> try flip
13:21:39 <zwer> > foldl (flip (:)) [] [1,2,3]
13:21:41 <lambdabot>  [3,2,1]
13:22:11 <mhl> ah, didn't know about the filp function
13:22:30 <zwer> foldl above excepts arguments in flipped order, a list first then the element to prepend
13:22:36 <heatsink> rinder: You could try running it with a smaller stack to force it to overflow sooner
13:22:55 <rinder> heatsink: good idea!
13:23:01 <heatsink> use a flag like +RTS -K32k
13:23:35 <charlieb> https://gist.github.com/anonymous/93141e5cb5b8e02e285b
13:23:47 <charlieb> ^ there's the code and error text
13:23:47 <mhl> Right, so flip changes the order of the arguments, so now I can do 'a : []', right?
13:24:44 <kirelagin> mhl: not exactly
13:24:59 <kirelagin> mhl: but instead of `(:) 1 []` you now can do `flip (:) [] 1`
13:25:10 <charlieb> I think the erro messages means that somewhere I'm treating the argument xs as [t] and other places as [[t]]
13:25:21 <charlieb> but I'm damned if I can figure it out
13:25:48 <kirelagin> charlieb: I bet too much $ is the issue
13:25:49 <danielszmulewicz> kirelagin: I think you're saying the "Haskell way" is to write curried functions. That's what I expect from a style guide to tell me :-)
13:26:33 <kirelagin> danielszmulewicz: not exactly, I'm trying to say that using builtin generic functions is a good idea
13:27:04 <danielszmulewicz> kirelagin: Point taken. Thanks.
13:27:27 <joshkirklin> I have a question that is probably best illustrated by a contrived example: why does ``randomIO`` not do the same as ``liftM head . sequence . repeat $ randomIO``?
13:27:47 <kirelagin> charlieb: no, I was wrong
13:27:52 <rwbarton> why does getLine not do the same as liftM head . sequence . repeat $ getLine?
13:28:22 <charlieb> kirelagin: I can get a little $ happy at times so I'll keep it in mind in any case
13:28:37 <joshkirklin> I suppose it is because randomIO / getLine must be evaluated infinitely many times
13:28:56 <kirelagin> charlieb: I suppose you wanted to use round brackets in the first where
13:29:15 <joshkirklin> my question then is how would I manage to do what I wish, that is for example take the head of the IO list lazily
13:29:30 <mhl> Thank you for your help. Is it possible to do this without flip somehow?
13:29:55 <kirelagin> mhl: err, plain old recursion?
13:29:56 <charlieb> kirelagin: well maybe, I'm not wedded to either really
13:30:14 <kirelagin> mhl: that's basically an unfolding of fold anyway
13:30:19 <kirelagin> charlieb: there is a great difference
13:30:28 <kirelagin> charlieb: (a, b) is a tuple, while [a, b] is a list
13:30:28 <zwer> mhi^ you can flip the arguments manually
13:30:33 <zwer> mhl*
13:30:50 <zwer> > foldl (\acc x -> x : acc) [] [1,2,3]
13:30:51 <lambdabot>  [3,2,1]
13:30:55 <kirelagin> charlieb: so (True ,"hi") :: (Bool, String)
13:30:56 <zwer> this is what flip does
13:30:57 <zwer> @src flip
13:30:57 <lambdabot> flip f x y = f y x
13:30:58 <mhl> kirelagin: Right, I mean with fold
13:31:13 <charlieb> kirelagin: I get that but as long as the user can handle it it doesn't make much difference ... or maybe it does?
13:31:14 <kirelagin> charlieb: while [True, "hi"] won't typecheck
13:31:29 <charlieb> ah
13:31:31 <charlieb> right
13:32:18 <tolt> Has anyone ever experienced a program not writing to nohup?
13:32:18 <charlieb> oh, so I'm trying to do put t and [t] into the same list!
13:32:25 <kirelagin> charlieb: exactly
13:32:31 <charlieb> doh
13:32:37 <mhl> zwer: Thanks
13:32:48 <joshkirklin> I will put my question a different way
13:33:04 <kirelagin> charlieb: basically you are asking the typechecker to solve an equastion X = [X]
13:33:15 <joshkirklin> sequence . repeat $ randomIO will construct an IO list of random values
13:33:15 <charlieb> kirelagin: Ok, modules loaded: Main.
13:33:17 <charlieb> :)
13:33:22 <kirelagin> charlieb: that's why it says you something about infinite types, because the only possible solution of this equation is an infinite type
13:33:30 <solidus-river> anyone here try doing something with haste or fay?
13:33:50 <joshkirklin> how would I take the head of this list without the entire list needing to be evaluated?
13:34:22 <ab9rf> joshkirklin: head list
13:34:25 <charlieb> kirelagin: yep, got it, thanks
13:34:39 <Iceland_jack> > head ('a':undefined) -- joshkirklin
13:34:41 <lambdabot>  'a'
13:34:44 <ab9rf> joshkirklin: well it's an IO list so you'll have to lift head into the list
13:34:47 <joshkirklin> it's an IO list, so that won't work
13:34:52 <joshkirklin> that's the problem
13:35:07 <joshkirklin> liftM head . sequence . repeat $ randomIO does not evaluate in finite time
13:35:09 <charlieb> kirelagin: well, I say got it but I don't understand about infinite types but I don't think I need to yet
13:36:48 <ski> @type sequence . repeat $ randomIO
13:36:49 <lambdabot> Random a => IO [a]
13:36:52 <kirelagin> charlieb: yeah, that's not unnecessary, just remember that once you get something about infinite types, that's probably because you have a list and you're putting a list of the same elements into it
13:37:03 <RchrdB> joshkirklin, if you want to make an infinite list of random values using randomIO, you *could* use unsafePerformIO. A better solution would be to use a pure RNG.
13:37:10 <RchrdB> er, unsafeInterleaveIO.
13:37:26 <parc> while we're on the subject of infinite types, to see if i understand free monads, would the free monad of a list basically allow you to construct lists like: [1,[2,3],[[4,[5]],6] (ignoring newtype wrapping/unwrapping)
13:37:51 <joshkirklin> RchrdB: randomIO is really just an example function here; it could be any function evaluating to IO a
13:37:57 <RchrdB> parc, not quite, they're more like [[], [[], []], []].
13:38:08 <kirelagin> joshkirklin: the whole point of sequence is that it executes effects of all the computations in the list
13:38:28 <rwbarton> joshkirklin: the answer is you can't
13:38:29 <ski> @type fix (System.IO.Unsafe.unsafeInterleaveIO . liftM2 (:) randomIO)  -- joshkirklin
13:38:30 <lambdabot> Random a1 => IO [a1]
13:38:30 <joshkirklin> is there an equivalent function that delays computation in a lazy way?
13:38:42 <kirelagin> joshkirklin: so asking it to combine all the effects into a single one and then trying to execute just one of them makes no sense
13:38:43 <rwbarton> joshkirklin: even if you somehow could "access" the head of the list, you wouldn't be able to do anything with it
13:38:53 <rwbarton> since the following IO action could never start
13:39:02 <kirelagin> joshkirklin: now your whole list is just a single value with a single effect being the combination of other effects
13:39:07 <sbrg> joshkirklin: let delay = passToLazyIntern >> return ()
13:39:10 <sbrg> that'll delay it for you
13:39:10 <RchrdB> parc, oh, I might have that wrong. I meant "data Mu f = Mu (f (Mu f))", Mu [] expresses things shaped like [[], [[], []]] and so on.
13:39:27 <RchrdB> parc, I think I might have just been talking about a different thing, sorry.
13:39:39 <nschoe> Does ghci take into account the fact it is launched inside a sandbox ?
13:39:52 <ski> joshkirklin : ok ?
13:40:05 <parc> yeah, that sounds right. Fix [] should only be able to have empty lists at the bottom, which i guess is closer to an infinite type than Free []
13:40:20 <danielszmulewicz> So all functions in Haskell are curried. Wow. I'm enjoying this.
13:40:22 <augur> how do i hide an instance in an import?
13:40:29 <parc> don't think you can
13:40:32 <nschoe> I am inside my sandbox, did 'cabal install --only-dep' but still can't import Cryopto.Cipher.AES
13:41:06 <rwbarton> joshkirklin: and yes as ski mentioned, you can do it using unsafeInterleaveIO. but not using "normal" IO methods
13:41:10 <RchrdB> parc, yeah, I got mixed up. Free is not the same as Fix! :)
13:41:10 <nschoe> augur, import Module hiding (function)
13:41:20 <augur> nschoe: i need to hide an instance, not a function
13:41:30 <nschoe> augur, ahem, sorry :/
13:41:33 <augur> :p
13:41:47 <parc> well i'm happy i can say i understand one more haskell concept today at any rate
13:41:48 <RchrdB> parc, Free [] Int does indeed model lists like [[1,2], [[[3]], [4]]]
13:41:56 <nschoe> augur, then I don't know. Can't you go around this by importing the module as qualified ?
13:42:39 <nschoe> Nobody for ghci and sandboxes ?
13:43:09 <joshkirklin> ski, rwbarton, kirelagin, etc. : Thanks for the help, that looks promising if a little complex
13:43:58 <augur> nschoe: i dont want to qualify everything tho :(
13:44:46 <ski> joshkirklin : you could also define it like `repeatIO act = unsafeInterleaveIO $ do a <- act; as <- repeatIO act; return (a : as)' (and then use `repeatIO randomIO')
13:44:58 <nschoe> augur, yeah well,  I know it is not optimal. Just the only thing i could think of... or maybe import twice : once qualified and once not qualified (with only the functions you want ?)
13:45:26 <nschoe> augur, I'm sorry, actually I'm out of my league here, I really misread you question and thought you wanted to hide a function, sorry for the inconvenience :/
13:45:37 <augur> sokay :p
13:46:14 <rwbarton> you can't hide an instance, period
13:48:15 <kazagistar> wow, -O2 is making a absurdly huge difference for my simple trial division prime number, hundreds of times faster
13:48:46 <kazagistar> its probably because I did (primes :: Integral a => [a])
13:49:01 <kazagistar> *prime number finder
13:50:36 <danielszmulewicz> The type notation is ghci is different than in hugs. For example, `add x y = x + y` is `add :: Int -> (Int -> Int)` while ghci tell me `add :: Num a => a -> a -> a`. I understand the former notation, but how do I read the latter?
13:50:50 <kirelagin> danielszmulewicz: it's a typeclass
13:51:12 <danielszmulewicz> kirelagin: Oh, I haven't gotten that far yey :-)
13:51:16 <danielszmulewicz> yet
13:51:38 <kirelagin> danielszmulewicz: typeclass are really not difficult, once you get there you'll understand the type of add
13:51:52 <kazagistar> danielszmulewicz: it is read as "given that a is something numeric, take 2 a's and return an a"
13:52:48 <danielszmulewicz> Very helpful. Thanks.
13:53:17 <kazagistar> a typeclass is basically a way of saying "something for which some functions are defined" (and usually they follow some laws)
13:54:04 <parc> basically like an interface. the function takes any `a` which implements the Num interface
13:54:34 <parc> which includes Ints, but also Integers, Doubles, and a bunch more
13:55:09 <parc> :i Num
13:55:24 <geekosaur> no :i here
13:55:24 <nschoe> @src <>
13:55:25 <lambdabot> Source not found. Do you think like you type?
13:55:25 <zwer> and yuo can define your own
13:55:26 <danielszmulewicz> Wow. Nice.
13:55:33 <nschoe> @src (<>)
13:55:33 <lambdabot> Source not found. Have you considered trying to match wits with a rutabaga?
13:55:35 <parc> boo. well try :i Num in ghci
13:55:46 <kqr> nschoe, for which instance?
13:55:55 <nschoe> kqr, bytestrings
13:56:07 <kazagistar> danielszmulewicz: a restriction being that there is specifically one a, you cant pick more then one
13:56:14 <geekosaur> nschoe: @src uses a tiny database that hasn't been updated in ages, it doesn't know about <>
13:56:29 <kazagistar> > (3 :: Int) + (4 :: Float)
13:56:30 <lambdabot>  Couldn't match expected type â€˜GHC.Types.Intâ€™
13:56:30 <geekosaur> but <> is infix mappend
13:56:30 <lambdabot>              with actual type â€˜GHC.Types.Floatâ€™
13:56:40 <nschoe> geekosaur, ah thanks.
13:57:15 <kazagistar> > (3 :: Int) + (3 :: Int)
13:57:16 <lambdabot>  6
13:57:24 <kqr> nschoe, it's just using the append function
13:57:34 <kirelagin> > repeat 0
13:57:36 <lambdabot>  [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0...
13:57:38 <nschoe> Do I have to explicitly include Data.Monoid ((<>)) in my code ?
13:57:40 <kirelagin> cool
13:57:52 <nschoe> (Damn I feel stupid asking such easy questions, don't know what's wrong with me tonight)
13:57:53 <kqr> nschoe, you can see in the source here: http://hackage.haskell.org/package/bytestring-0.10.4.0/docs/src/Data-ByteString-Lazy-Internal.html#ByteString
13:57:55 <kirelagin> nschoe: you just import DAta.Monoid
13:57:58 <kqr> nschoe, under instance monoid bytestring
13:58:04 <Zer000> I'm learning the basics of haskell and I frequently like to look up documentation for really simple things like the prepend operator for lists (:), or what <|> means in a program. Where do I search for such things?
13:58:11 <kqr> Zer000, hoogle
13:58:16 <kqr> Zer000, http://www.haskell.org/hoogle/
13:58:32 <kirelagin> Zer000: :i in ghci tells you the type, in most cases that's enough ;)
13:58:44 <nschoe> kqr, kirelagin, geekosaur thanks, you're awesome.
13:58:53 <kazagistar> Zer000: note, hoogle also does reverse lookup, where you give it a type and it gives you matching functions
13:59:11 <Zer000> very cool, thanks guys
13:59:27 <kazagistar> @hoogle Maybe a -> (a -> b) -> Maybe b
13:59:28 <lambdabot> Prelude fmap :: Functor f => (a -> b) -> f a -> f b
13:59:28 <lambdabot> Data.Functor fmap :: Functor f => (a -> b) -> f a -> f b
13:59:28 <lambdabot> Control.Monad fmap :: Functor f => (a -> b) -> f a -> f b
13:59:58 <kqr> kazagistar, fmap is what you want
13:59:59 <zwer> Zer000 what is interesting about hoogle is that you can even search functions by their type
14:00:18 <kazagistar> kqr: I was demoing hoogle, I know :P
14:00:23 <kqr> ah right, sorry
14:01:19 <parc> new question. are the monad laws just that (>=>) and return form a category?
14:01:57 <c_wraith> parc: yep
14:02:01 <rinder> @hoogle [a] -> a
14:02:02 <lambdabot> Prelude head :: [a] -> a
14:02:02 <lambdabot> Data.List head :: [a] -> a
14:02:02 <lambdabot> Prelude last :: [a] -> a
14:02:30 <parc> that's pretty simple then actually
14:02:53 <parc> as much as anything about monads can be described as simple
14:04:18 <c_wraith> parc: monads are super simple.  People just make them hard when they flail around looking for "the big deal"
14:05:04 <parc> i feel like i've got a good grasp on them now
14:05:14 <c_wraith> parc: (I think technically (<=<) is the category operator)
14:05:16 <cehteh> give a one line layman understandable explanation for monads please :)
14:05:20 <r444> i don't understand why this is happening with function monad
14:05:26 <r444> join (+) 5
14:05:26 <r444> 10
14:05:37 <zcd> is there a way to embed IO strings in GetOpts without unsafePerformIO?
14:05:40 <c_wraith> cehteh: it's a pattern for composing functions that return values of a certain form.  That's all.
14:05:49 <r444> @hoogle join
14:05:49 <lambdabot> Control.Monad join :: Monad m => m (m a) -> m a
14:05:49 <lambdabot> package join
14:05:49 <lambdabot> System.FilePath.Windows joinDrive :: FilePath -> FilePath -> FilePath
14:06:29 <c_wraith> r444: If you say m = (a ->), then m (m b) -> m b = (a -> a -> b) -> (a -> b)
14:06:43 <danielszmulewicz> Is there an emacs mode for lpaste (like refheap for Clojure snippets)?
14:07:13 <c_wraith> chrisdone: danielszmulewicz has a question you are uniquely qualified to answer. ^^^
14:07:30 <Peaker> c_wraith: s/functions/computations
14:07:42 <danielszmulewicz> Yes, there is: http://www.haskell.org/haskellwiki/Hpaste.el
14:07:43 <kqr> cehteh, do you understand functors and applicatives?
14:07:44 <c_wraith> danielszmulewicz: chrisdone is the author of lpaste *and* a big contributor to haskell-mode stuff
14:07:49 <danielszmulewicz> Thanks chrisdone!
14:07:53 <r444> c_wraith: so basically we're substituting second argument with first?
14:08:19 <r444> output function will be (a -> b) of course
14:08:30 <c_wraith> r444: it's turning a two-argument function into a one-argument function that uses the the argument twice
14:08:30 <cehteh> i am just asking because i havent yet seen a simple explanation
14:08:38 <danielszmulewicz> chrisdone: I stole your haskell config for Emacs. Awesome!
14:08:54 <c_wraith> Peaker: no, I really do mean functions.  I'm looking at it from the categorical perspective.
14:09:20 <r444> c_wraith: hm, so generally we can reduce last two arguments to one
14:09:23 <kqr> cehteh, for me, a monad is mostly about the "bind" operation, which allows you to "extract" a value from a type and put it into a function that gives a new value in the same type
14:09:35 <kqr> cehteh, and understanding that is easy if you grasp functors and applicatives, i think
14:09:39 <kini> c_wraith: then shouldn't you say morphisms? :P
14:10:10 <c_wraith> r444: actually, it's the first two.
14:10:23 <Peaker> cehteh: one possible hand-wavy way would be: "Monads let you define your own semantics for the semicolon"
14:10:33 <Peaker> or simply "overridable semicolons"
14:10:34 <c_wraith> kini: I could, and it'd be consistent..  But I don't have to. :)
14:10:50 <c_wraith> kini: since all the morphisms involved are actually functions
14:11:15 <kqr> r444, join :: (a -> a -> b) -> a -> b
14:11:20 <r444> c_wraith: yep, it's the first two, just tried it out in ghci
14:11:35 <kqr> r444, in "join f x" you'll find that "f :: a -> a -> b" and "x :: a"
14:11:37 <parc> i like to think of monads as being like functions. `f a` applys a pure function `f =<< a` applys a monadic function. then (.) is function composition and (<=<) is monadic function composition
14:11:42 <kini> c_wraith: so, Arrow is a generalization of Monad from functions to morphisms, if I understand correctly... right?
14:11:46 <kqr> r444, only possible implementation is join f x = f x x
14:11:48 <r444> kqr: oh, i see it now :)
14:12:10 <parc> if we pretend that functions of the form a -> m b aren't pure, which is technically not true
14:12:30 <c_wraith> kini: I have no idea what Arrow is.  I've never needed to use one, and I intend to keep never needing to use one.  This mostly means "not using hxt"
14:12:59 <kqr> c_wraith, really? not even simple arrow instances like for tuples?
14:13:02 <kini> I have no idea what hxt is :P
14:13:15 <r444> arrows are completely mysterious to me
14:13:16 <c_wraith> kqr: oh, I use the arrow instance for (->).  I just have no idea what it's abstracting
14:13:24 <kqr> ah right, i'm the same way
14:13:27 <kqr> i'll learn one day... eventually
14:13:29 <c_wraith> kini: hxt is the "haskell xml toolkit"
14:13:44 <kini> I see the wiki page for hxt mentions that it uses arrows
14:13:49 <c_wraith> kini: it is the only library strongly designed around an arrow interface.
14:14:06 <c_wraith> kini: well, that's not true.  Several of the FRP libraries are strongly arrow-based.
14:14:19 <c_wraith> kini: but they are even less-used than hxt.
14:14:22 <r444> c_wraith: do you really need to understand arrows to use it? It's kind of dsl-y, if i remember correct.
14:14:34 <kini> well, I don't know anything about Arrow but the generalization from functions to morphisms is usually about eliminating the concept of "inputs/outputs" and "applications", and keeping only "compositions"
14:14:37 <c_wraith> r444: well, you need to either understand arrows, or be really good at copy/paste
14:14:48 <Peaker> arrows are supposed to abstract the same thing Applicative abstracts -- in a cumbersome way
14:15:03 <c_wraith> kini: I've heard that Arrow is approximiately Applicative + Category
14:15:04 <benzrf> well
14:15:29 <benzrf> hmmmm
14:15:44 <Peaker> though it's due to a mistake. If the mistake is fixed -- then Arrows can abstract computations that Applicative would not be able to (I think Cale worked in a company that had a non-broken Arrow that did that -- basically removing "arr" and parameterizing the (,) type)
14:15:44 <benzrf> isn't it more like Functor + Category
14:16:15 <benzrf> arr is fmap
14:16:26 <Peaker> benzrf: Arrow <=> Applicative+Category
14:16:33 <benzrf> eh?
14:16:34 <Peaker> (You can implement either in terms of either)
14:16:39 <benzrf> hmm
14:16:47 <dottedmag> arr sounds like something that should belong to Pirate category.
14:16:57 <benzrf> category is for morphisms in a category sharing objects in hask
14:17:00 <benzrf> *with
14:17:22 <benzrf> Arrow is for when you have a functor to that category from Hask
14:17:23 <benzrf> right?
14:17:24 <r444> dottedmag: wat
14:17:39 <benzrf> where arr is the morphism component of the functor
14:17:53 <Peaker> benzrf: I don't know Category Theory, can't answer that :(   I know how to implement Arrow when I have just Applicative and Category instances, though
14:18:01 <Peaker> benzrf: and vice versa
14:18:10 <johnw> benzrf: I do not understand what you said
14:18:10 <Peaker> "arr" ruins the whole point of Arrow, imo
14:18:13 <dottedmag> r444: https://en.wikipedia.org/wiki/International_Talk_Like_a_Pirate_Day
14:18:16 <benzrf> johnw: ;-;
14:18:33 <benzrf>     
14:18:53 <benzrf> johnw: ok. the type that you instantiate Category with is the type of the morphisms in your category, right?
14:18:59 <benzrf> while the objects are the same as in Hask
14:19:15 <johnw> right
14:19:19 <johnw> :t (<<<)
14:19:20 <lambdabot> Category cat => cat b c -> cat a b -> cat a c
14:19:22 <johnw> :t liftA2 (.)
14:19:23 <lambdabot> Applicative f => f (b -> c) -> f (a -> b) -> f (a -> c)
14:19:23 <benzrf> ok
14:19:28 <r444> dottedmag: oh, you Y'arrow
14:19:32 <r444> you mean*
14:19:51 <r444> it's hillbilly arrow interpretation
14:19:54 <benzrf> johnw: so arr acts as the morphism-converting part of a functor from Hask to your category
14:20:16 <johnw> ah, I see what you're getting at
14:20:25 <benzrf> is the point of Arrow /not/ to define a functor to your category from Hask?
14:21:18 <dottedmag> r444: Y'arrow? Is that some Arrow tutorial? I don't know anything about it, just found the name funny.
14:21:56 <johnw> benzrf: something doesn't seem right about the notion of "functor to your category from Hask"
14:22:07 <benzrf> johnw: eh?
14:22:40 <r444> dottedmag: just messing with it back at you
14:22:53 <johnw> if arr embeds morphism in the target category, what embeds objects?  if the objects are morphisms, then the arrows in the target would be morphisms to morphisms
14:23:13 <kazagistar> welp, I just got a firsthand experience of the cost of abstraction... under -O0, { primes :: [Int] } is 50 times faster then { primes :: Integral a => [a]; primes' = primes :: [Int] }
14:23:32 <dottedmag> r444: Sounds like a name of arrow-based Web framework though.
14:23:50 <Peaker> benzrf: "arr" makes Arrows useless, since we already have Applicative.  If "arr" did not exist, Arrow could be useful! imagine bidirectional computations, for example
14:23:53 <johnw> hmm... wait, I'm not clear enough on this to say benzrf
14:24:13 <danielszmulewicz> Aww, no hpaste in MELPA. Can I submit it or do I have to ask the maintainer?
14:24:25 <Peaker> parser-builder compositions is a useful example of bidirectional compositions that arrow cannot describe because of "arr"
14:25:02 <benzrf> johnw: i think any category whose morphisms you can represent with Category has the same objects as Hask
14:25:12 <benzrf> johnw: so you only need to specify how to embed morphisms?
14:25:18 <c_wraith> Peaker: did GArrow ever end up on hackage?
14:25:28 <Peaker> c_wraith: Not sure
14:25:36 <johnw> given Category cat => cat a b, 'a' and 'b' are objects.  Arrow turns a -> b into Arrow a b, which is a Category a b, so the objects are still just Haskell types.  What Arrow abstracts are the morphisms, so that they can be richer than merely a -> b.
14:26:09 <johnw> i.e., have some kind of "context", ala Profunctor
14:26:23 <johnw> but Applicative already lets us manipulate "morphisms with context"
14:27:26 <johnw> it's just restricted to abstracting over actual functions; Arrow without 'arr' could represent pairs as function-like-things, for example.  If I'm understanding all of this correctly
14:27:49 <johnw> I think Arrow is the most-talked-about-but-least-used concept in Haskell
14:27:55 <benzrf> hmm
14:27:58 <benzrf> \] [/
14:29:03 <zcd> is there a way to embed IO strings in OptArgs from GetOpts without unsafePerformIO?
14:30:21 <dwcook> zcd: I don't know what OptArgs or GetOpts are, but have you tried using (>>=)?
14:37:57 <zcd> dwcook: it's an arg parsing library.  i dont think >>= will work since it takes a String -> a function as argument
14:39:22 <parc> is there a category theory concept that describes arrow without arr?
14:41:25 <dwcook> zcd: fmap (f :: String -> a)
14:42:07 <c_wraith> parc: I think it'd be something like category + products
14:42:22 <c_wraith> parc: but don't ask me for details
14:43:16 <rwbarton> sort of but not really, the presentation in the Arrow class is not a good one for tearing out arr
14:43:45 <parc> when i did first see Arrow i kind of assumed that's what it was. i wanted to do differentiable functions, which are sort of invertible
14:43:55 <rwbarton> for example, (&&&) gives you a b (b,b), which you can write also in terms of arr; but there's no way to get a (b,c) b, which you can also write in terms of arr; but you'd have it if you had products
14:46:08 <napping> Is "maybe mzero return" in a library somewhere?
14:46:28 <benzrf> :t maybe mzero return
14:46:29 <lambdabot> MonadPlus m => Maybe a -> m a
14:46:30 <benzrf> oic
14:47:14 <codygman> Does this type signature mean that it takes a Row of Text fields,  a monad, and a Row of Text fields? myProcessor :: Conduit (Row Text) m (Row Text)
14:47:54 <benzrf> codygman: i dont know conduit, but i would guess that it takes a row of texts and results in a row of texts
14:48:07 <benzrf> and the m is the base monad, assuming that Conduit is a transformer
14:48:45 <acowley> napping: I don't think that's worth defining in a library
14:49:47 <augur> :|
14:49:52 <augur> why cant i hide an instance! :(
14:49:54 <codygman> benzrf: I believe it is, but I can't say for sure. So it takes a conduit full of (Row Text), a monad used to transform that row, and then it returns (yields?) (Row Text)? My hangup is that I thought only things after "->" in the type signature were returned
14:50:06 <jfischoff> parc: symmetric monoidial categories are interesting relatives
14:50:09 <benzrf> codygman: huh?
14:50:15 * hackagebot dynamic-mvector 0.1.0.1 - A wrapper around MVector that enables pushing, popping and extending.  http://hackage.haskell.org/package/dynamic-mvector-0.1.0.1 (AndrasKovacs)
14:50:20 <benzrf> no, not a 'monad used to transform that row'
14:50:31 <benzrf> codygman: the conduit itself transforms the monad
14:50:37 <napping> acowley: compared to listToMaybe, catMaybe, etc?
14:50:41 <benzrf> codygman: it doesnt return it in the sense that you can apply it as a function
14:50:49 <benzrf> conduits are composable
14:51:14 <rwbarton> augur: why do you want to hide an instance
14:51:27 <benzrf> rwbarton: augur is ashamed of their instance
14:51:30 <augur> rwbarton: because i want to define a different one and not have to dick around with newtypes
14:51:43 <parc> i really need to read category theory for computer scientists sometime 0.0
14:51:43 <rwbarton> that's explicitly not allowed by the language standard
14:51:49 <codygman> benzrf: Thank you. I will have to think about this as I go through the conduit tutorial again.
14:52:14 <augur> rwbarton: horrible
14:52:17 <acowley> napping: Having some bad things isn't reason to have more! "Bad" in the sense that they're all useful, but mo' names is mo' problems.
14:52:24 <rwbarton> actually it's wonderful
14:52:40 <augur> rwbarton: no, its actually awful
14:52:42 * Eduard_Munteanu wishes 'import qualified <module> as <name>' was 'import <module> as <name> qualified'
14:52:43 <napping> augur: Map would be sad if you could hide and redefine Ord
14:52:44 <rwbarton> no u
14:52:58 <augur> napping: i dont need to redefine Ord
14:53:00 <enthropy> Eduard_Munteanu: where does the import list go then?
14:53:07 <augur> napping: i need to redefine the ord instances
14:53:10 <acowley> I think we're moving to a place where Foldable, Traversable, and Monoid newtypes will be more common first choices
14:53:20 <enthropy>  import Data.Map as M (lookup) qualified
14:53:25 <Eduard_Munteanu> enthropy: before qualified
14:53:32 <napping> acowley: if you had different modules using different Ord instances and passed maps between them, horrible things would happen
14:53:35 <augur> napping: namely, Map is a monoid by using left-biased union, but i want to use merging behavior
14:54:05 <Eduard_Munteanu> enthropy: the issue is 'qualified' looks ugly among non-qualified imports because it shifts the module name to the right
14:54:23 <enthropy> augur: is it that much trouble to use a  M.unionsWith (<>) or similar?
14:54:25 <Eduard_Munteanu> enthropy: yeah, like that
14:54:30 <hiptobecubic_> if your values are all monoids then your Map can be monoid as well no?
14:54:44 <napping> how about import Module qualified as M(asdfasdf)
14:54:48 <benzrf> hiptobecubic_: values cant be monoids!!!
14:54:52 <rwbarton> imporq Module
14:54:55 <augur> enthropy: yes, because i want it to work recursively automatically
14:54:56 <acowley> My bigger wish for imports would be import Data.Map (Map) qualified as M
14:55:00 <rwbarton> that would line up nicely
14:55:02 <napping> that would be nice too
14:55:04 <acowley> where now Map is available unqualified
14:55:04 <hiptobecubic_> benzrf, in general? or right now?
14:55:14 <benzrf> in general
14:55:16 <augur> enthropy:    instance (Ord k, Monoid v) => Monoid (Map k v)
14:55:18 <Eduard_Munteanu> napping: that's ok, but it shift the import list to the right
14:55:19 <acowley> Or what napping said
14:55:20 <benzrf> same as values are not monads
14:55:21 <napping> importing some names unqualified and having a qualifier for the rest is nice
14:55:30 <acowley> I just want qualified and unqualified in the same line
14:55:38 <napping> Eduard_Munteanu: you already had an "as M" shifting the imports over, didn't you?
14:55:44 <hiptobecubic_> benzrf, why can't values be monoids? You can't have Map Int [Int] ?
14:56:09 <Eduard_Munteanu> napping: hm, fair, nevermind
14:56:27 <napping> I worry anything after a potentially long input list might be hard to find
14:56:32 <Eduard_Munteanu> Or we could do like Agda, i.e. separate importing a module from opening it into scope.
14:57:17 <napping> maybe import Path.Module as M using (unqualified stuff)
14:57:18 <Eduard_Munteanu> Actually that wouldn't work nicely.
14:57:37 <k00mi> hiptobecubic_: he means only types can be instances of Monoid
14:57:43 <enthropy> hiptobecubic_: types have instances, but I don't think there's much confusion to say value
14:57:55 <hiptobecubic_> k00mi, oh. Yes.
14:57:56 <enthropy> any confusion actually
14:58:13 <Eduard_Munteanu> I thought 'open import ...' then '     import ...' but that indentation is wrong.
14:58:30 <hiptobecubic_> I meant in the context of Map you have keys and values, not in the context of Haskell, where you have Types and Values
14:59:11 <napping> Eduard_Munteanu: whatever the syntax, I think the two operations are importing some names unqualified, and picking a qualified name
14:59:23 <napping> the two most important, at least. It would be nice to get both at once
14:59:25 <fragamus> ((`mod` n) . round . (*n)) 18 0.6
14:59:50 <fragamus> let asdf = ((`mod` n) . round . (*n))
15:00:03 <Eduard_Munteanu> You could of course do 'open module A' separately but it'd be annoying.
15:00:09 <fragamus> > ((`mod` n) . round . (*n)) 18 0.6
15:00:11 <lambdabot>  Couldn't match expected type â€˜a0 -> tâ€™
15:00:11 <lambdabot>              with actual type â€˜Debug.SimpleReflect.Expr.Exprâ€™
15:00:20 <napping> restricting the set of names visible even with the qualifier comes up less often
15:00:38 <benzrf> hiptobecubic: 'monoid' is not a term that refers to values
15:00:46 <fragamus> oops
15:00:55 <fragamus> > ((`mod` 18) . round . (*18)) 0.5
15:00:56 <enthropy> augur: you can write a pile of overlapping instances
15:00:56 <lambdabot>  9
15:00:59 <Eduard_Munteanu> napping: yeah, because even with a 'qualified' after the module name, importing it twice would be ugly.
15:01:02 <benzrf> hiptobecubic: it's the same reason that any given dog is not a species
15:01:04 <napping> If you took import Data.Foo(a,b,c) as M to mean that the only things imported unqualified are a,b,c, you may not need a "qualified" as a keyword
15:01:06 <parc> in some instances it can be helpful to pass in the typeclass explicitly at runtime. like, you can make a writer monad like Reader (w -> w -> w, w) a where you explicitly pass the mappend and mempty in at runtime, and then you don't need the `a` to be a monoid, and syntactly it's still pretty nice
15:01:08 <napping> import Data.Foo() as M
15:01:11 <fragamus> can anyone help me make a function out of that
15:01:12 <benzrf> any given dog is a dog, and dog is a species
15:01:13 <enthropy> augur: then there's a chance your program will behave correctly
15:01:17 <hiptobecubic> benzrf, hmmm. Yes i suppose that's the wrong way to say it. "why can't your values be a monoid"
15:01:19 <Eduard_Munteanu> napping: cool
15:01:34 <fragamus> where 18 and 0.5 are params
15:01:35 <benzrf> and any given list is a list, and list w/ [] and (++) is a monoid
15:01:35 <napping> IIRC the current behavior is to included only the listed identifiers whether qualified or not
15:01:41 <augur> enthropy: :P
15:01:46 <augur> enthropy: 0% chance, sure!
15:01:49 <djahandarie> parc, wouldn't recommend that book.
15:01:50 <Eduard_Munteanu> napping: sometimes it's desirable to have the same names imported both unqualified and qualified
15:01:54 <napping> impot Data.Foo(importantThing) as M(some,raraer,stuff) for restricting what's as M
15:02:03 <hiptobecubic> benzrf, sigh. Yes. with a binary op and 0..
15:02:09 <benzrf> =3
15:02:13 <Eduard_Munteanu> napping: e.g. a module exporting another module and using the definitions in the latter as well
15:02:15 * danielszmulewicz Enjoying Dr. Erik Meijer's functional programming series tremendously.
15:02:18 <napping> Sure, but I think it's immensely more common to want a few names imported unqualified, and everything visible with the qualifer
15:02:36 <napping> so that's probably what a form with an "as M" and an import list should give you
15:03:48 <enthropy> augur: well if it's done by template-haskell, you can be sure that you have an    instance Ord k => Monoid (Map k M), with M being every Monoid instance in scope
15:04:05 <enthropy> I mean one instance for every particular M
15:04:13 <augur> enthropy: o_o
15:05:27 <napping> Eduard_Munteanu: import Full.Module as M(id1,id2) seems resaonble to have only id1/id2 visible, in both qualified and unqualified forms
15:05:45 <enthropy> I guess your functions can still go wrong if they are applied to types that were not in scope when you ran the TH to generate those instances
15:05:45 <enthropy> (or the types didn't have Monoid instances at the time)
15:05:45 <enthropy> @type reifyInstances
15:05:46 <lambdabot> Not in scope: â€˜reifyInstancesâ€™
15:05:51 <napping> Is there ever a reason to want everything visible unqualified, but only a few with a custom short module name?
15:06:16 <napping> Hmm, I guess I haven't considered qualifying with a full module name
15:06:49 <acowley> napping: as a bandaid to handle one name collision
15:07:51 <rwbarton> though then it's presumably fine to import everything with a short module name, unless you are running out of short module names also
15:07:55 <napping> acowley: that's plausble, but I don't quite wanting to exclude othrer things from the prefix
15:08:16 <napping> maybe if you do like import M1 as X(badName1); import M2 as X(badName2); import M3 as X(badName3)
15:09:08 <Eduard_Munteanu> Whoa, Proxy in base.
15:09:09 <rwbarton> yeah, that would be the only reason
15:09:25 <rwbarton> and it's not a very good one IMHO
15:10:45 <c_wraith> Eduard_Munteanu: it's handy to have it there for the new Typeable, even though it's not strictly necessary.
15:11:32 <c_wraith> Eduard_Munteanu: however, anything implementing the typeOf -> typeRep# compatibility layer needs something logically equivalent to polykinded Proxy anyway...
15:11:52 <c_wraith> Eduard_Munteanu: so you might as well move it into base so that there's one canonical version, I suppose.
15:13:19 <c_wraith> Eduard_Munteanu: that means it also got magical GHC support for being a 0-width value when possible, too.
15:14:25 <benzrf> :t typeOf
15:14:26 <lambdabot> Typeable a => a -> TypeRep
15:14:31 <benzrf> :t typeRep#
15:14:32 <lambdabot>     Not in scope: â€˜typeRep#â€™
15:14:32 <lambdabot>     Perhaps you meant â€˜typeRepâ€™ (imported from Data.Typeable)
15:14:35 <benzrf> phooey
15:14:36 <benzrf> :t typeRep
15:14:37 <lambdabot> Typeable a => proxy a -> TypeRep
15:14:50 <benzrf> > typeRep (Just 1)
15:14:52 <lambdabot>  Integer
15:14:56 <benzrf> heuh
15:15:27 <napping> Eduard_Munteanu: how's this look: import Full.Module [ "quailfied" | (importList) ] [as Id [ (importList) ] ]
15:15:57 <napping> I'm not quite sure what a quailified import should do
15:16:10 <napping> but qualified would be a synonym for ()
15:16:59 <benzrf> napping: clearly a quailfied import is one that converts the thing you're importing into a quail
15:17:03 <benzrf> very useful for poachers
15:17:14 <ab9rf> i never cared much for quail
15:17:26 <ab9rf> how do you get pheasant?
15:17:37 <napping> maybe other keywords could go there too
15:17:39 <chrisdone> aw  yeah, check this
15:17:43 <chrisdone> $ haskell-docs Data.ByteString length
15:17:43 <chrisdone> length :: ByteString -> Int
15:17:43 <chrisdone> *O(1)* length returns the length of a ByteString as an Int.
15:18:59 <chrisdone> now i just need to make it to search all installed packages instead of requiring a module name, then i won't need a local hoogle anymore
15:19:23 <napping> does that use haddock?
15:19:26 <chrisdone> yup
15:19:29 <enthropy> c_wraith: you're suggesting that "undefined :: Proxy ()" evaluates to Proxy in some cases?
15:20:09 <chrisdone> i spent the better part of this evening making it work on the last four major ghc versions and associated pinned haddocks, too
15:20:10 <c_wraith> enthropy: No.  I mean that in some cases, a value with type Proxy () has no runtime representation
15:20:27 <napping> so the index should let you search the local packages
15:20:33 <chrisdone> yep
15:20:39 <napping> sounds nice
15:20:54 <napping> going in haskell-mode too I suppose?
15:21:00 <chrisdone> ideally
15:21:09 <napping> I need to look into that a bit more
15:21:21 <napping> I'm running it, but something is screwed up with flymake/ghc-mod
15:21:37 <napping> that is, before I disabled them
15:22:24 <chrisdone> it'll serve two purposes for me: (1) a feature like M-x describe-function, (2) when GHC says "not in scope `foo'", haskell-mode hoogles `foo' and suggests to import the associated module. awesome feature but requires a lot of grunt work to get your hoogle setup properly. i'm hoping this will make that requirement unnecessary, and work across sandboxes
15:23:03 <chrisdone> something's always screwed up with those :[
15:23:06 <napping> across sandboxes might be trickier
15:23:27 <napping> If you mean to suggest imports from packages you don't even have in the current sandbox
15:23:40 <napping> That might be more of a cabal/hackage thing
15:23:55 <chrisdone> i'd prefer if it would restrict to my current sandbox, i think
15:24:01 <napping> ah, sounds fine then
15:24:12 <chrisdone> yeah. hm, let me try it, haven't tried it yet. it might automagically use the right package index
15:24:15 <napping> doesn't ghc already suggest something?
15:24:22 <c_wraith> enthropy: logically, those cases should be "when it was created with the Proxy constructor, and when it's never used as an argument to seq or pattern-matched".
15:24:34 <chrisdone> you mean suggest modules to import? not right now afaik
15:24:41 <napping> I thought it suggested imports any loaded package
15:24:59 <napping> huh, guess not
15:25:24 <napping> I was thinking of modules - it suggests what hidden module has a package name
15:25:29 <chrisdone> hmm. it gives me:
15:25:29 <chrisdone> Not in scope: â€˜packâ€™
15:25:29 <chrisdone> Perhaps you meant â€˜backâ€™ (imported from GHC)
15:25:33 <enthropy> they could have made it  newtype Proxy a = Proxy (Proxy a)
15:25:41 <chrisdone> sure
15:25:58 <c_wraith> enthropy: huh.  I guess it doesn't matter if it was created with undefined instead of Proxy, if it's never pattern-matched or the first argument to seq.
15:26:03 <chrisdone> probably ghc could do this feature, actually. but then i'll have to wait ages to use it =p
15:26:17 <napping> I'm just thinking that having an index of what modules export what things doesn't necessarily even require building haddocks
15:26:41 <napping> especially if you want to not run haddock for speed while populating sandboxes
15:27:09 <napping> then again, that's probably the easiest thing to get cabal to do automatically
15:28:54 <chrisdone> ideally, cabal would just generate a hoogle index automatically if you specified Hoogle: True in your ~/.cabal/config
15:29:03 <chrisdone> like it can do with documentation: True
15:29:07 <napping> I think it does
15:29:32 <augur> honestly, i think the merge instance is the right monoid instance for maps
15:29:35 <chrisdone> afaik it doesn't, there's a ticket on it
15:29:38 <augur> this left-biased union thing is BS
15:29:54 <napping> I was just thinking about how hard it would be to use the ghc api or something and dump an index of exported symbols from every package in the sandbox
15:29:56 <chrisdone> https://github.com/haskell/cabal/issues/395
15:30:00 <napping> whether or not you installed with hoogle
15:30:07 <napping> haddock, rather
15:30:08 <chrisdone> that's pretty easy to do, i think
15:30:24 <napping> Easily and automatically getting docs is awesome
15:30:27 <chrisdone> technically the type info i displayed above requires the ghc api to get, haddock doesn't store that
15:31:00 <parc> what's wrong with this data declaration: data MonadInstance m = forall a. forall b. MonadInstance (a -> m a) (m a -> (a -> m b) -> m b)
15:31:00 <napping> but maybe it's fancier than you need just to suggest imports
15:31:05 <chrisdone> i was just fiddling with code that dumps all the exports of a module and their types, and the cabal api has functions to get a complete list of packges and modules
15:31:23 <napping> then again, implementing both ways might be more work
15:31:41 <enthropy> parc: it doesn't need: forall a b.?
15:32:12 <parc> ah hah. thanks
15:32:23 <chrisdone> napping: possibly it could be a separate tool
15:32:46 <chrisdone> one to lookup an identifier by name using the ghc api, another to display docs
15:33:45 <chrisdone> you could also dump the types and then feed it to hoogle
15:38:51 <intrados> Am I likely to get better performance with `Vector.fromList . groupBy p . Vector.toList` or a naively written Vector-native groupBy?
15:39:13 <carter> ion: depends
15:39:20 <carter> intrados: depends
15:39:50 <carter> intrados: write it using Vector.Generic
15:39:54 <chrisdone> carter: how long is a piece of string?
15:39:55 <carter> and try both versions
15:40:00 <carter> chrisdone: ?
15:40:07 <chrisdone> carter: depends =p
15:40:15 <carter> yup
15:40:24 <carter> chrisdone: i'm kinda anti fusion in funny way
15:40:30 <carter> if only because not every algorithm fuses
15:41:27 <chrisdone> yes, rewrite rules are good and bad for that reason
15:42:32 <heatsink> Are rewrite rules really the culprit when fusion doesn't happen?
15:43:20 <Zer000> is anyone here a web developer? I am, and I use python/javascript but I want to learn and start using haskell. The problem is I won't be productive with haskell for a while so I can't justify starting a new project with HS. My question is - is learning fay a good way to get into haskell? Then I could write some front-end stuff with it, I already know the browser javascript api, so it should be easier.
15:44:07 <chrisdone> zer000: probably not a great way as it's not full haskell
15:44:20 <chrisdone> ghcjs or haste might be better
15:45:04 <kini> hey chrisdone, does haskell-indentation not handle syntax extensions like MultiWayIf and LambdaCase ?
15:45:13 <Zer000> and do those tools (fay included) result in bloated, slow code? Anything more than the overhead of JQuery is probably too much
15:45:17 <intrados> Though my attempts at haste were pretty frustrating due to library incompatibilities
15:45:52 <luite> Zer000: i'd start with Haskell on the server side then
15:46:38 <intrados> Zer000: purescript is only Haskell-like but emphasizes clean, light Javascript output
15:46:48 <chrisdone> kini: i doubt it, the modes predate those extensions
15:47:24 <chrisdone> https://hackage.haskell.org/package/Cabal-1.20.0.1/docs/Distribution-Simple-PackageIndex.html#v:allPackages
15:47:32 <chrisdone> cool, get all packages from the index. now, how do i get an index?
15:47:47 <kini> aww
15:47:47 <kini> so either I can use the sexy MultiWayIf syntax and have indentation keep beeping with parse errors at me from that point onwards in the file, or I can use "case () of _ | ..." :/
15:47:58 <enthropy> chrisdone: hoogle!
15:48:19 <c_wraith> yeah, it'd be nice of the indentation modes were aware of half the new syntax..
15:48:24 <luite> chrisdone: from Distribution.Simple.GHC, it's compiler-specific (it calls ghc-pkg and parses the output)
15:48:26 <enthropy> relatedly, there's no feature in hoogle to filter functions that provide a type
15:48:57 <enthropy> positive vs. negative
15:48:59 <chrisdone> luite: ah, lol. i was trying to avoid doing the ghc-pkg parse thinking cabal hooked into some API
15:49:50 <chrisdone> luite: thanks, this'll do the trick
15:50:44 <chrisdone> i wonder if this'll support sandboxes out of the, ehm, box
15:50:45 <benbangert> if there's two identical strings made, does haskell allocate two strings, or just have 2 pointers to the same string in memory?
15:50:50 <chrisdone> probably not
15:51:22 <c_wraith> benbangert: depends on how they're identical.
15:51:25 <chrisdone> benbangert: if it's a string literal, ghc will normally do common subexpression elimination
15:51:26 <piezo> chrisdone: I've used Distribution.Simple.GHC to get a list of package : https://gist.github.com/Piezoid/b4602e9d23f6888750ac
15:51:46 <c_wraith> benbangert: if they're both the result of IO, they almost certainly will not be the same space in memory
15:51:49 <luite> benbangert: there's no automatic hash consing for strings, but in some cases the same literal might compile to the same value
15:51:55 <benbangert> ah, ok
15:51:57 <piezo> but I think it's the same API, parsing ghc-pkg output
15:52:22 <chrisdone> piezo: aha, seems we're writing the same tool =p
15:53:10 <piezo> chrisdone: I'm not the only one to think that hoogle data is garbage :)
15:53:54 <chrisdone> i think hoogle was made just to be a server
15:54:01 <chrisdone> and that's why it sucks for local use
15:55:11 * chrisdone tries building piezo's script
15:55:58 <piezo> yes, if I want haskell.org's hoogle package selection, I just go to haskell.org
15:57:41 <chrisdone> piezo: we can submit a patch to hoogle
15:57:55 <chrisdone> so that it can do this
16:00:03 <piezo> there is already a --local flag, but I think it's for adding the '@package' links to local haddock
16:00:59 <leonixyz> Hello, Iâ€™m a newbieâ€¦ Iâ€™m trying to solve a very simple exercise where I have to write a function that checks whether a list is a prefix of another list (i.e. [1,2] is prefix of [1,2,3] and of [1,5,2] ) but I get a parse error, could someone please give a look at this? https://gist.github.com/leonixyz/c0b0fac8e9aef92a8819
16:01:07 <piezo> that's was my plans but I'm not too familiar with Shake rules, the data builds rules are a bit complex...
16:01:44 <luite> piezo: what exactly does 'hoogle data' do?
16:01:56 <piezo> I opted for a standalone script
16:02:09 <chrisdone> pulls files for base from haskell.org and generates a database
16:02:21 <chrisdone> base and bytestring, standard things that come with ghc
16:02:32 <piezo> luite: I'm not sure :) It seems to download a fixed list of .txt definitions
16:02:48 <luite> i've been using a script that builds the .hoo files for the latest version of all installed packages and combines them, but that was before i knew of hoogle data
16:02:48 <piezo> there is also a large database from hackage
16:03:03 <luite> i mean i wrote it before i knew about that :)
16:04:00 <chrisdone> i have a similar script
16:04:41 <chrisdone> but you have to make sure you cabal install'd with --hoogle
16:04:48 <chrisdone> so it's lame
16:05:22 <piezo> the 'hackage hoogle:' in cabal config is quite recent
16:05:37 <chrisdone> hackage hoogle:?
16:05:46 <chrisdone> what's that?
16:05:54 <luite> oh mine automatically unpacks and builds the packages where necessary (this was before you could let cabal build a hoogle db by default), but it only works if cabal unpack for the package+version works
16:06:03 <piezo> 'haddock\n\thoogle:True'
16:06:13 <chrisdone> oh
16:06:23 <chrisdone> someone needs to shout from the rooftops that these features exist
16:07:11 <piezo> somtimes I delete my config to get a new default one and see the new flags :p
16:07:18 <chrisdone> lol
16:09:19 <copumpkin> jmcarthur_mobile, newsham: I pushed some newer pickler ideas to github under copumpkin/picklers if y'all are interested. Still very rough so am reworking major parts of it at a time
16:10:20 <jmcarthur_mobile> Woohoo! I'll look later if I remember
16:10:25 * hackagebot loops 0.2.0.2 - Fast imperative-style loops  http://hackage.haskell.org/package/loops-0.2.0.2 (ThomasTuegel)
16:10:37 <leonixyz> Hello people, I wrote a 10 lines module that doesnâ€™t compile due to a parse error, Iâ€™m a newbie, could someone please help me? https://gist.github.com/leonixyz/c0b0fac8e9aef92a8819
16:10:47 <copumpkin> jmcarthur_mobile: once it gets better I'll bug you more for comments :) it's yet another approach from the ones we've looked at so far
16:11:14 <kini> leonixyz: need parentheses around "h1:t1" and "h2:t2"
16:11:20 <kini> and "x:xs"
16:11:24 <leonixyz> kini: ty
16:11:48 <kini> function application binds more tightly than anything else afaik
16:12:26 <c_wraith> kini: not quite, but close enough.  It binds more tightly than any infix operator, but the postfix record update operator binds more tightly than function application
16:12:35 <shachaf> Update and construction.
16:12:41 <c_wraith> right, I always forget about that.
16:12:56 <kini> er, is this lens stuff?
16:12:59 <c_wraith> no
16:13:00 <rwbarton> also, the @ thingy in patterns
16:13:09 <c_wraith> foo bar{baz=quux}
16:13:17 <kini> ah
16:13:43 <c_wraith> the update is applied to bar, not to foo bar
16:14:17 <chrisdone> i'd probably prefer it the other way round
16:20:08 <Eduard_Munteanu> Control.Monad.* exporting mapM and the likes is just terrible. :(
16:21:16 <benzrf> Eduard_Munteanu: eh?
16:21:21 <benzrf> :t Prelude.mapM
16:21:22 <lambdabot> Monad m => (a -> m b) -> [a] -> m [b]
16:21:23 <benzrf> :t Prelude.mapM_
16:21:24 <lambdabot> Monad m => (a -> m b) -> [a] -> m ()
16:21:27 <benzrf> hmmh
16:21:28 <benzrf> :t Prelude.sequence
16:21:30 <lambdabot> Monad m => [m a] -> m [a]
16:21:35 <benzrf> :t Prelude.repeatM
16:21:36 <lambdabot>     Not in scope: â€˜Prelude.repeatMâ€™
16:21:36 <lambdabot>     Perhaps you meant one of these:
16:21:36 <lambdabot>       â€˜Prelude.repeatâ€™ (imported from Prelude),
16:21:37 <benzrf> ok
16:21:42 <Eduard_Munteanu> :t Control.Monad.Reader.mapM
16:21:43 <lambdabot> Monad m => (a -> m b) -> [a] -> m [b]
16:21:54 <Eduard_Munteanu> :t Data.Traversable.mapM
16:21:55 <lambdabot> (Traversable t, Monad m) => (a -> m b) -> t a -> m (t b)
16:22:20 <Eduard_Munteanu> If you import Control.Monad.* you have to hide all of those to get the Traversable mapM.
16:24:12 <jle`> unfortunately
16:25:30 <benzrf> gross!
16:27:06 <enthropy> you could use something like http://hackage.haskell.org/package/basic-prelude-0.3.8/docs/CorePrelude.html instead
16:27:54 <benzrf> what are the major differences between haskell and ocaml, besides purity, laziness, and minor syntax?
16:28:08 <Eduard_Munteanu> Minor syntax?
16:28:16 <benzrf> minor syntax diffs
16:28:22 <benzrf> oh wait, it has for loops
16:28:25 <benzrf> ok that's a big diff
16:29:02 <Eduard_Munteanu> MLs are pretty different to Haskell syntax-wise, IMO.
16:29:05 <hpc> type classes, a crapton of language extensions
16:29:13 <enthropy> ocaml has no higher kinded types, but they have other stuff ghc does not have
16:29:31 <benzrf> hmmmm
16:29:38 <Eduard_Munteanu> The only thing OCaml has that comes to mind is equirecursive types.
16:29:42 <benzrf> it has loops o.o;;
16:29:52 <burp> :t forM
16:29:53 <lambdabot> Monad m => [a] -> (a -> m b) -> m [b]
16:30:01 <burp> there you go ;)
16:30:06 <benzrf> and lots of effectful functions taking unit
16:30:09 <benzrf> burp: ha.
16:34:21 <ab9rf> i found that not having explicit for-loops took about 15 seconds to get used to :)
16:34:49 <Nik05> only 15?
16:35:28 * hackagebot shelly 1.5.4.1 - shell-like (systems) programming in Haskell  http://hackage.haskell.org/package/shelly-1.5.4.1 (GregWeber)
16:42:37 <path[l]> hi I seem to have many versions of Cabal locally. 1.16 and 1.20, but the default in /usr/bin seems to be 1.16 and I dont know where 1.20 even is. How can I uninstall the current version
16:43:23 <hpc> path[l]: locate cabal$ perhaps?
16:44:03 <koala_man> path[l]: how do you know you have 1.20 installed?
16:44:15 <path[l]> I tried cabal info cabal
16:44:17 <path[l]> and it lists both
16:48:04 <koala_man> path[l]: probably in ~/.cabal then? you can use http://stackoverflow.com/a/10587933/1899640 to unregister a specific version
16:48:16 <path[l]> ah, let me try that
16:49:06 <spott_> So, I'm working my way through the exercises in the Typeclassopedia, and I've run into a problem (in the first exercise!)
16:49:23 <spott_> I'm attempting to define fmap for ((->) e)
16:49:34 <spott_> but I'm running into syntax problems.
16:49:41 <spott_> I would think it would be:
16:49:52 <augustss_> howdy
16:49:59 <spott_> fmap f ((->) e) = (->) $ f e
16:50:00 <carter> augustss_: is that a lennart i see?
16:50:07 <shachaf> whoa, it's augustss_
16:50:15 <dwcook> spott_: (->) is not a data constructor.
16:50:17 <augustss_> it is I
16:50:22 <benzrf> does ocaml curry
16:50:24 <carter> augustss_: welcome
16:50:25 <pavonia> spott_: (->) is type syntax, not value syntax
16:50:26 <dwcook> (Or a value of any kind.)
16:50:35 <carter> augustss_: i've been deep in array engineering land the past few months
16:50:38 <spott_> ok, I guess I'm a little lost
16:50:56 <pavonia> spott_: What would the type of that function be?
16:50:58 <dwcook> spott_: Why do you think you need the (->) on the right side?
16:51:04 <augustss_> and are the arrays good now?
16:51:12 <spott_> dwcook: ah!
16:51:14 <spott_> thanks
16:51:21 <carter> augustss_: yes, writing instances now
16:51:21 <benzrf> so
16:51:24 <benzrf> i realized
16:51:27 <spott_> but... i'm getting a syntax error on the left side too
16:51:30 <carter> augustss_: i have sparse and dense array formats both!
16:51:33 <carter> and you can add your own
16:51:40 <spott_> pavonia: can you clarify what that means?
16:51:42 <benzrf> a -> b <=> b^a
16:51:52 <benzrf> but b^a is also b*b*b*...*b
16:52:09 <benzrf> so logically any function can be represented as the tuple of outputs given a predefined listing of inputs
16:52:35 <pavonia> spott_: When you specialize the type of fmap to the given instance ((->) e), what result type do you get?
16:52:40 <pavonia> :t fmap
16:52:41 <lambdabot> Functor f => (a -> b) -> f a -> f b
16:53:41 <spott_> pavonia: If i knew the answer to that, I think i could write fmap for it :)
16:54:06 <pavonia> Do you know how type classes work?
16:54:09 <spott_> ok, so, ((->) e) is (e ->), it describes functions from e to something
16:54:23 <spott_> pavonia: in a high level, basic way
16:55:22 <pavonia> Hhm, not sure where to start then. You need to understand the types first to be able to write the correct function
16:55:37 <spott_> so, for fmap, it would be fmap ((a -> ) -> (b ->)) -> ((f a) -> ) -> ((f b) -> )
16:55:53 <pavonia> No
16:56:03 <spott_> hrm...
16:56:11 <pavonia> "Functor f" means f is the Functor
16:56:32 <dwcook> Substitute in (e ->) wherever you see f
16:56:40 <dwcook> Then simplify
16:56:51 <dwcook> The result might look familiar
16:57:08 <spott_> ok
16:58:53 <jmcarthur> sometimes, you just have to suck it up and use lens.
16:59:19 <spott_> so, fmap (a->b) -> (e -> a) -> (e -> b)
16:59:32 <dwcook> That's right
16:59:39 <dwcook> Does that look familiar?
16:59:45 <spott_> so, fmap g (f a) = f $ g a
16:59:47 <jmcarthur> oof. and sometimes lens doesn't... install? huh
17:00:09 <dwcook> spott_: The left side is malformed
17:00:15 <Axman6> to make a lense, first you must install the universe...
17:00:18 <Axman6> lens*
17:00:31 * hackagebot katt 0.2.0.3 - Client for the Kattis judge system.  http://hackage.haskell.org/package/katt-0.2.0.3 (DavidNilsson)
17:00:37 <path[l]> so this is confusing. I unconfigured version 1.16 of Cabal, but the cabal binary in /usr/bin still reports version as 1.16. Also I dont see any other binary on my system
17:00:41 <spott_> dwcook: hrm
17:00:47 <jmcarthur> looks like an issue with a permissive version constraint or something
17:00:57 <carter> path[l]: cabal install cabal-install
17:00:59 <carter> what OS?
17:01:11 <spott_> dwcook: should (f a) be (e -> a)?
17:01:14 <dwcook> spott_: It's the (f a) that's wrong
17:01:16 <path[l]> carter: osx. I did that and cabal now says the only installed version is 1.20
17:01:24 <Axman6> spott_: have a close look at the type, see that the function being fmapped is being applued to the result of g
17:01:26 <dwcook> spott_: no, forget about the (->) there, that's type syntax
17:01:27 <carter> path[l]: OH
17:01:29 <path[l]> carter: but the binary in /usr/bin itself is the wrong version
17:01:33 <carter> path[l]: nooo
17:01:36 <carter> path[l]: stop
17:01:40 <path[l]> stopped
17:01:41 <spott_> dwcook: ok
17:01:41 <carter> and now literally do exactly what i tell you
17:01:45 <path[l]> lol ok
17:02:08 <carter> "rm ~/.cabal/config ; cabal update ; cabal install cabal-install ; rm ~/.cabal/config ; cabal update"
17:02:25 <carter> then add ~/.cabal/bin to you rpath
17:02:32 <dwcook> spott_: Do you know what existing function has the type you mentioned?
17:02:36 <carter> where ~ == /Users/YourUserName
17:02:42 <carter> or whatever
17:02:44 <carter> path[l]: k?
17:02:45 <path[l]> carter: hmm ok.
17:02:54 <carter> oh
17:03:01 <dwcook> spott_: Let me try alpha renaming (which you can do anytime you like) to maybe make it clearer: fmap :: (b -> c) -> (a -> b) -> (a -> c)
17:03:03 <path[l]> carter: not overwrite the version is /usr/bin you mean?
17:03:12 <spott_> composition?
17:03:14 <carter> path[l]: add ~/.cabal/bin to your path first
17:03:18 <spott_> (.)?
17:03:26 <dwcook> spott_: exactly!
17:03:28 <path[l]> cool
17:03:30 <spott_> awesome!
17:03:30 <carter> path[l]: then do the directions
17:03:31 <spott_> thanks!
17:03:36 <carter> and you'll find "cabal --version"
17:03:39 <carter> is happy
17:03:40 <carter> after you're done
17:04:26 <path[l]> carter: but there is nothing in ~/.cabal/bin. Which command installs cabal there
17:04:33 <carter> path[l]: you'll see
17:04:40 <carter> add it to your path
17:04:42 <carter> then do the things i said
17:04:50 <path[l]> ok
17:04:51 <carter> make sure you expanded the ~ first
17:05:01 <carter> you got trolled by haskell platforms default for macs
17:05:14 <path[l]> hah I see
17:07:28 <Redz> SO: Why can't i use function parameters in a record update notation?
17:07:57 <Axman6> what do you mean?
17:08:21 <enthropy> r{ fieldname x = f x } -- ?
17:08:31 <enthropy> has to be   r{ fieldname = \x -> x }
17:08:53 <path[l]> carter: that didnt work, but I found cabal under ~/Library/Haskell/bin/cabal
17:09:29 <Redz> enthropy: yes, but why is this so?
17:10:29 <carter> path[l]: did you LITERALLY do what I said
17:10:32 * hackagebot organize-imports 0.3.0.0 - Organize scala imports  http://hackage.haskell.org/package/organize-imports-0.3.0.0 (lcycon)
17:10:34 <carter> "echo $PATH"
17:10:34 <path[l]> yep
17:10:45 <carter> i bet you ddint source your profile or whatever
17:10:55 <path[l]> â€” /Users/vsi/.cabal/bin:/usr/local/bin:/Users/vsi/.rvm/gems/ruby-1.9.3-p362/bin:/ â€¦
17:10:59 <carter> ok
17:11:03 <carter> ok
17:11:11 <carter> @lpaste your ~/.cabal/config
17:11:11 <lambdabot> Haskell pastebin: http://lpaste.net/
17:11:14 <path[l]> I didnt bother with that. I just did export PATH = ~/.cabal/bin:$PATH
17:11:34 <carter> no, @lpaste your cabal config file
17:12:09 <carter> path[l]: cp that into ~/.cabal/bin
17:12:19 <path[l]> http://lpaste.net/105573
17:12:38 <carter> cool
17:12:43 <carter> you have modern 1.20 style cabal
17:12:54 <path[l]> I just added ~/Library/Haskell/bin into my path and redid the steps
17:12:58 <carter> yeah
17:12:58 <path[l]> :)
17:12:59 <carter> ok
17:13:00 <carter> :)
17:13:01 <carter> congrats
17:13:27 <path[l]> thanks for the help carter
17:13:31 <enthropy> Redz: I don't think there is any good reason. Maybe nobody proposed that syntax, or mabye people on the committee thought it was not going to be very useful
17:14:19 <enthropy> augustss_ might have known
17:15:36 <spott__> thanks all!
17:15:38 <Redz> enthropy: are there some documented committee decisions on the web?
17:20:06 <delrik> hey, what happens if I define a data type without a name?
17:20:14 <delrik> such as data Delrik = Int
17:20:24 <c_wraith> delimax: you've defined a data type with a name
17:20:25 <delrik> how would I get a type of Delrik?
17:20:32 <c_wraith> err, delrik
17:20:47 <c_wraith> Int would be a constructor, of type Delrik
17:21:01 <delrik> hows that diff from a type synonym?
17:21:16 <c_wraith> There wouldn't be any value with a type of Int involved
17:21:25 <c_wraith> Constructor names and type names are 100% independent
17:21:27 <ab9rf> there'sno type Int in that case
17:21:34 <ab9rf> there's a data constructor called Int
17:21:36 <delrik> I see.
17:21:48 <delrik> So i could use Int in my type sigs
17:21:51 <ab9rf> there might be a type Int too, but that's unrelate
17:22:16 <enthropy> Redz: I don't think so. Probably you can find some ancient (1990-ish) mailing list archives somewhere
17:22:22 <c_wraith> If you really go digging, you might find that the name of the constructor for the Int type is I#
17:23:03 <c_wraith> But if you need to know that, you're *way* deep into using low-level details about how GHC works
17:23:39 <carter> yup
17:24:06 <carter> a lot of people do a lot of work to make sure most haskellers never ever had to think about that
17:24:24 <ab9rf> @let data Delrik = Int
17:24:24 <lambdabot>  .L.hs:173:1:
17:24:25 <lambdabot>      Multiple declarations of â€˜Delrikâ€™
17:24:25 <lambdabot>      Declared at: .L.hs:171:1
17:24:25 <lambdabot>                   .L.hs:173:1
17:24:25 <lambdabot>  
17:24:29 <ab9rf> oops
17:24:32 <ab9rf> @undef Delrik
17:24:32 <lambdabot> There's currently no way to undefine just one thing.  Say @undefine (with no extra words) to undefine everything.
17:24:34 <c_wraith> @undefine
17:24:34 <lambdabot> Undefined.
17:24:39 <ab9rf> @undefine
17:24:39 <lambdabot> Undefined.
17:24:42 <ab9rf> @let data Delrik = Int
17:24:44 <ab9rf> @type Int
17:24:44 <lambdabot>  Defined.
17:24:45 <lambdabot> Delrik
17:25:40 <ab9rf> @type 0 :: Int
17:25:41 <lambdabot> Int
17:26:37 <carter> :k Int
17:26:38 <lambdabot> *
17:26:40 <carter> ok good
17:27:14 <zcd> is there a clean way to turn a record into a pair of lists like ([fieldnames],[values])
17:27:35 <Clint> "a record"?
17:27:41 <c_wraith> field names?
17:27:49 <c_wraith> What would the type of the function you imagine be?
17:28:02 <carter> some template haskell madness?
17:28:09 <c_wraith> You can't do it with the list type
17:28:11 <carter> or type class of doom with Data.Daynamic
17:28:21 <c_wraith> Heh.  Unless you use Dynamic, sure
17:28:23 <carter> [(String,Data.Dynamic)]
17:28:27 <carter> BAM
17:28:30 <zcd> fine fine :( s/a record/algebraic data type in record syntax s/field names/the functions that get them
17:28:46 <zcd> ok ill look into dynamic thanks
17:28:53 <carter> zcd: woa woah
17:28:55 <c_wraith> zcd: you will feel pain.
17:28:55 <carter> lets zoom out
17:28:59 <carter> whats the actual goal
17:29:01 <zwer> I don't think dynamic is what you need
17:29:02 <c_wraith> zcd: Dynamic is a bad solution
17:29:13 <dibblego> c_wraith++
17:29:21 <carter> you really shouldn't use Data.Dynamic
17:29:25 <zcd> goal is to turn an algebraic data thing into a sql query
17:29:27 <carter> unless you wanna learn why you shouldnt
17:29:30 <carter> oh
17:29:32 <dibblego> or "field names" for that matter (there I said it)
17:29:40 <c_wraith> I've thought I had a reason to use Dynamic once or twice.  I was wrong.
17:29:42 <carter> zcd: have you looked at how postgres simple works?
17:29:54 <carter> i think thats OR equeleto
17:29:59 <carter> are better places to start
17:29:59 <zcd> i have not...
17:30:12 <carter> @hackage postgres-simple
17:30:12 <lambdabot> http://hackage.haskell.org/package/postgres-simple
17:30:18 <carter> @hackage esqueleto
17:30:18 <lambdabot> http://hackage.haskell.org/package/esqueleto
17:30:27 <carter> zcd: look at those two :)
17:30:38 <carter> i would say "postgres-simple"
17:30:39 <zcd> will do, thanks
17:30:53 <carter> if you want the full power of postgres, go withthat one
17:31:32 <ab9rf> it's genreally a bad idea to try to use a "bucket type"
17:31:48 <zcd> what's a bucket type?
17:32:05 <carter> a catch all blob of doom and sads
17:32:33 <carter> theres a lot of cool stuff involving applicatives that makes the need go away
17:32:47 <zcd> ohh i'm using the type as a result of parsing args from cli
17:32:58 <carter> oh
17:33:19 <carter> whats the current applicative parsing lib thats best?
17:33:23 <carter> i use opt-parse applicative
17:33:27 <carter> but its docs are a bit shitty
17:34:06 <ab9rf> once you use a bucket type you lose most the advantage of using a strictly typed language
17:34:57 <zcd> i dont think its an applicative parsing lib but i'm using System.Console.GetOpt
17:35:02 <carter> ah
17:35:08 <carter> you should try out applicative parsing
17:35:10 <carter> its nice
17:35:16 <carter> dibblego: do you have a fave?
17:35:19 <carter> i feel like you'd have a fave
17:39:37 <dibblego> carter: ekmett/parsers + trifecta
17:39:39 <peddie> carter: I dunno whether you've seen it, but the github README at https://github.com/pcapriotti/optparse-applicative complements the haddocks well and cleared up a lot of my questions!
17:39:46 <carter> ok
17:39:47 <carter> well
17:39:56 <carter> i use it, i just sometimes get confused on the fancy bits
17:57:48 <delrik> =O
17:57:57 <delrik> lambdabot knows my name!
17:58:06 <delrik> *feels special*
17:58:20 <benzrf> > delrik
17:58:21 <lambdabot>  Not in scope: â€˜delrikâ€™
17:58:23 <benzrf> tsk
17:58:31 <benzrf> delrik: you aren't in scope!
18:00:39 * hackagebot simple-postgresql-orm 0.9.0.1 - Connector package for integrating postgresql-orm with the Simple web framework  http://hackage.haskell.org/package/simple-postgresql-orm-0.9.0.1 (AmitLevy)
18:02:31 <ruuns> hi :]
18:05:39 * hackagebot rainbow 0.14.0.2 - Print text to terminal with colors and effects  http://hackage.haskell.org/package/rainbow-0.14.0.2 (OmariNorman)
18:11:30 <Para__> Hey guys
18:12:03 <Para__> Is anybody around to answer a question? (I just started learning haskell today so its probably very easy)
18:12:41 <hpc> ask and someone might know the answer
18:12:51 <c_wraith> Para__: just ask.  You get better answers to questions about haskell than questions about asking questions.
18:12:58 <Para__> haha fair enough
18:13:00 <Para__> alright
18:14:46 <Para__> so a list comprehension is usually pretty easy to make, [ f x | x <- [1..]] is equivalent to map f [1..]. Okay so I got that
18:14:47 <path[l]> hi, does anyone know where the bash_completion scripts for cabal lie
18:15:15 <Para__> but, at some point f x gets really large as x gets large
18:15:35 <Para__> and I only want the values of f that are less than N
18:15:36 <Para__> for some N
18:15:51 <Para__> how exactly can I do that? (if I know that f is increasing in x)?
18:16:02 <path[l]> takeWhile ?
18:16:14 <Para__> takeWhile?
18:16:18 <Para__> ok wait I'll google that
18:16:23 <Para__> I haven't gotten there yet
18:16:26 <path[l]> :)
18:16:28 <dwcook> Para__: Better yet, Hoogle it.
18:16:39 <matematikaadit> :t takeWhile
18:16:40 <lambdabot> (a -> Bool) -> [a] -> [a]
18:16:44 <dwcook> http://www.haskell.org/hoogle/
18:16:49 <matematikaadit> @src takeWhile
18:16:49 <lambdabot> takeWhile _ []                 =  []
18:16:49 <lambdabot> takeWhile p (x:xs) | p x       =  x : takeWhile p xs
18:16:49 <lambdabot>                    | otherwise =  []
18:17:04 <Para__> oh awesome, thanks!
18:17:31 <matematikaadit> @hoogle takeWhile
18:17:32 <lambdabot> Prelude takeWhile :: (a -> Bool) -> [a] -> [a]
18:17:32 <lambdabot> Data.List takeWhile :: (a -> Bool) -> [a] -> [a]
18:17:32 <lambdabot> Data.ByteString.Char8 takeWhile :: (Char -> Bool) -> ByteString -> ByteString
18:17:48 <dwcook> lambdabot's Hoogle interface isn't very good
18:18:04 <Para__> thanks!
18:18:26 <Para__> I had no idea about hoogle either (I thought it was a play on google being funny) haha
18:19:14 <dwcook> Para__: By the way, a naÃ¯ve implementation which doesn't use the knowledge that f is monotonically non-decreasing might be : [f x | x <- [1..], x < N]
18:19:28 <dwcook> That's worse-performing than the takeWhile solution though
18:19:30 <path[l]> carter: any idea how I can get bash_completion for cabal under osx? I see there is supposed to be a script when I google for it, but I cannot find itâ€™s location anywhere
18:19:37 <carter> path[l]: i use fish
18:19:53 <dwcook> Sorry, f x < N, not x < N
18:20:09 <path[l]> ah I see ok :)
18:20:17 <carter> fish is nice
18:20:18 <carter> try it
18:20:19 <carter> otu
18:20:58 <path[l]> hmm friendly makes it sound interesting
18:20:59 <path[l]> haha
18:21:07 <dwcook> Err, I should've written n, not N, since capitalized names are reserved for data constructors
18:21:51 <Para__> dwcook - that doesn't work if I'm summing over the list though, does it? (because it keeps looking forever?)
18:22:59 <dwcook> Para__: Correct, sum diverges when applied to an infinite list.
18:23:26 <enthropy> @src sum
18:23:26 <lambdabot> sum = foldl (+) 0
18:23:33 <dwcook> You could however use scanr to do "sum up to this point" and then you get an infinite list again.
18:23:35 <dwcook> @type scanr
18:23:36 <lambdabot> (a -> b -> b) -> b -> [a] -> [b]
18:23:48 <c_wraith> dwcook: I think that should be scanl
18:23:51 <dwcook> > scanr (+) 0 [1..]
18:23:56 <lambdabot>  mueval-core: Time limit exceeded
18:23:56 <lambdabot>  mueval: ExitFailure 1
18:24:09 <dwcook> > scanl (+) 0 [1..]
18:24:10 <lambdabot>  [0,1,3,6,10,15,21,28,36,45,55,66,78,91,105,120,136,153,171,190,210,231,253,2...
18:24:19 <c_wraith> dwcook: scanr goes from the other direction ...  The sum of the infinite list, the sum of the infinite list minus and element, etc
18:24:20 <dwcook> Yes, scanl.
18:24:27 <c_wraith> *an element
18:25:16 <Para__> gotcha
18:25:25 <Para__> okay can I show you guys my code that I just wrote
18:25:31 <Para__> to see if I'm doing anything stupidly wrong?
18:25:31 <c_wraith> Para__: use lpaste
18:25:33 <c_wraith> @where lpaste
18:25:33 <lambdabot> http://lpaste.net/new/haskell
18:25:47 <dwcook> Oh, and strictly speaking I suppose the thing I mentioned wouldn't be an infinite list, but rather a not definitely finite list.
18:25:50 <Para__> (it works but I feel like I'm making it more complicated than it needs to be or not idiomatic)
18:26:13 <dwcook> Para__: So, the naÃ¯ve "solution" I gave isn't. Woops. :)
18:26:23 <mmachenry> Anyone know of an icecast of shoutcast streaming library for Haskell?
18:26:27 <Para__> :)
18:26:28 <Para__> http://lpaste.net/105574
18:26:34 <Para__> its for project euler 2
18:26:41 <Para__> I'm trying to re-do the problems in haskell to help me learn it
18:26:46 <dwcook> This is what happens when you try to use finite reasoning on infinite objects.
18:26:50 <dwcook> (The mistake I made.)
18:27:11 <Para__> I basically need to find the sum of the even numbered fibonacci terms less than 4 million
18:27:51 <zardogg> do all functions in haskell accept a single argument?
18:28:00 <dwcook> zardogg: Correct, no more, no less.
18:28:32 <dwcook> zardogg: Colloquially, we may speak of multi-parameter functions, but those are just functions with a function output.
18:29:04 <Para__> (Its why you get types that are [a] -> [a] -> [a], for example instead of [a], [a] -> [a])
18:29:29 <zardogg> what about a function accepting a tuple? couldnt we look at a function accepting a tuple as a multi-argument function? that is what curry/uncurry functions imply
18:30:00 <zardogg> or seem to imply
18:30:11 <dwcook> zardogg: You could _see_ it that way, but it's still technically a single value, just a product of two values.
18:31:25 <dwcook> zardogg: You could speak of either a -> b -> c or (a, b) -> c or even [a] -> b as multi-parameter functions, but to be perfectly correct they all have exactly one parameter.
18:31:59 <dwcook> (Functions of those forms, anyway, not literally with those types)
18:32:35 <zardogg> yeah good point. so would you say curry/uncurry function are slighly misnamed, and misdocumented?
18:33:17 <zardogg> actually just misnamed, documentation is correct
18:33:37 <dwcook> Why do you think they're misnamed?
18:34:47 <Para__> wait dwcook - did you see the lpaste link I sent?
18:35:09 <dwcook> Para__: Yeah, sorry, didn't notice what you wanted to be done with it.
18:35:24 <dwcook> Ah, you wanted input on making it more idiomatic
18:35:36 <Para__> yeah :)
18:35:39 <Para__> if you didn't mind
18:35:58 <dwcook> Well personally I'd probably phrase it as the composition of a few functions
18:36:12 <dwcook> Though I can't really speak to that being "more idiomatic"
18:36:16 <zardogg> dwcook currying means taking a function that accepts multiple argument and returns a curried function (that accepts one argument and returns a function), yes?
18:36:26 <zardogg> and returning*
18:37:01 <dwcook> Para__: It's not bad to use list comprehensions, however it's useful knowing that they can be phrased in terms of other functions. For example, your even n there serves the purpose of filtering, and is equivalent to a certain use of filter.
18:37:03 <dwcook> @type filter
18:37:04 <lambdabot> (a -> Bool) -> [a] -> [a]
18:37:18 <dwcook> @type filter even
18:37:19 <lambdabot> Integral a => [a] -> [a]
18:37:32 <Para__> hmmm alright
18:37:38 <Para__> let me try to write a different version for practice
18:38:07 <zardogg> going by that definition curry accepts a function that takes multiple arguments
18:38:22 <dwcook> Para__: By the way, that fibonacci is going to take forever to compute. There's a neat trick with zipWith you can use to make it faster
18:38:36 <dwcook> Let me try to invent it from my head, one sec
18:39:04 <Para__> http://lpaste.net/105574
18:39:14 <dwcook> > let fibs = 0:1:zipWith (+) fibs (tail fibs) in fibs
18:39:15 <zardogg> wiki says it better than I did: "currying is the technique of transforming a function that takes multiple arguments (or a tuple of arguments) in such a way that it can be called as a chain[disambiguation needed] of functions, each with a single argument (partial application)"
18:39:16 <lambdabot>  [0,1,1,2,3,5,8,13,21,34,55,89,144,233,377,610,987,1597,2584,4181,6765,10946,...
18:39:17 <Para__> doesn't haskell do a cache-ing type of thing?
18:39:31 <dwcook> Para__: You don't have to use it, but it's worth tracing the evaluation to see how it works
18:39:42 <Cale> Para__: No, functions are not automatically memoised
18:39:48 <dwcook> Para__: Not the sort you might be expecting.
18:40:09 <Cale> Para__: While it wouldn't be incorrect to memoise them, it would mean that nothing would ever be garbage collected
18:40:19 <Para__> ah alright
18:40:19 <Para__> gotcha
18:40:38 <benzrf> be back tomorrow eh
18:40:42 <Para__> I'm just coming form python so purely functional programming is still very new to me
18:40:46 <Para__> from*
18:40:50 <benzrf> bye
18:41:05 <Para__> bye
18:41:29 <Para__> @hoogle zipWith
18:41:30 <lambdabot> Prelude zipWith :: (a -> b -> c) -> [a] -> [b] -> [c]
18:41:31 <lambdabot> Data.List zipWith :: (a -> b -> c) -> [a] -> [b] -> [c]
18:41:31 <lambdabot> Data.Text zipWith :: (Char -> Char -> Char) -> Text -> Text -> Text
18:41:37 <Welkin> another refuge from python
18:41:56 <Cale> Para__: On the other hand, variables get evaluated at most once so long as they remain in scope, so if you define a list of all Fibonacci numbers for instance, as it gets evaluated, the entries won't be recomputed.
18:42:01 <Para__> haha :), just wanted to learn something different
18:42:15 <Para__> ohhh ok, I might have gotten confused
18:42:46 <Para__> because I knew that if I did [fib n | n <- [1..1000], even (fib n)], fib n was only computed once
18:42:50 <Eduard_Munteanu> Any idea what happened with the non-automatic termination bits in conduit? Are they going to be merged into master anytime soon?
18:43:02 <zardogg> so which one is it? haskell has functions taking multiple arguments? curry/uncurry are slightl misnamed? none of the above? sorry if I am dwelling on this too much :)
18:43:03 <Eduard_Munteanu> Non-automatic termination for sources, that is.
18:43:04 <dwcook> Para__: Not true actually
18:43:09 <Cale> Para__: I'm pretty sure it'll get evaluated twice there
18:43:32 <Cale> Para__: You *could* write [x | n <- [1..1000], let x = fib n, even x]
18:43:47 <Cale> Para__: and then fib n will be evaluated once
18:43:51 <Eduard_Munteanu> zardogg: Haskell functions always take one argument, but they can return functions which consume further arguments
18:43:57 <Para__> oh whoops
18:44:01 <Cale> (for each n)
18:44:21 <Eduard_Munteanu> zardogg: A -> B -> C is by definition A -> (B -> C)
18:44:21 <c_wraith> GHC *might* decide to CSE that particular case, but I'd never count on that happening.
18:44:32 <Cale> GHC almost never does CSE
18:44:41 <Para__> out of curiosity, are you all in Academia? or what do you use Haskell for?
18:44:42 <dwcook> zardogg: To answer your question, I'd say there isn't a formal concept of multiple arguments in Haskell, so the term "curry" does the most appropriate thing instead.
18:44:47 <dwcook> s/does/means/
18:45:23 <Cale> From what I recall, the only case where GHC does common subexpression elimination at present is when you have nested case expressions with exactly the same scrutinee (which basically never shows up in code you'd write yourself, but may occur after various other optimisations and desugaring)
18:45:27 <dwcook> Para__: I think most Haskell users are not in academia. As for me, I program as a hobby, and that includes Haskell
18:45:37 <Eduard_Munteanu> Para__: no... I'm using it for various tasks I want to accomplish, recently a web scraper and a scanner driver is what I've been working on that comes to mind.
18:45:59 <Para__> Is there any particular reason to use Haskell over say, Python for like a web scraper for example?
18:46:02 <Cale> Para__: I've used Haskell at a few of my jobs now...
18:46:06 <zardogg> Eduard_Munteanu: according to quote I posted earlier currying means taking a function that takes multiple arguments and returning a function that takes one argument. so if curry function stands for currying (and is properly named), curry takes a function with two arguments
18:46:21 <Eduard_Munteanu> :t curry
18:46:22 <lambdabot> ((a, b) -> c) -> a -> b -> c
18:46:45 <Eduard_Munteanu> zardogg: curry takes a function which takes a *pair* (of arguments, you may say).
18:47:01 <Eduard_Munteanu> zardogg: but the pair is just one argument
18:47:20 <Para__> Cale - if you don't mind me asking, do you use Haskell because it is the language you're most comfortable with, or because it is particularly good at something?
18:47:38 <Cale> Para__: It's particularly good at most things
18:47:48 <Para__> I was under the impression that it was used for proofs in academia a lot too.
18:47:48 <Eduard_Munteanu> Para__: I personally find it annoying to discover most issues in Python code at runtime
18:48:05 <dwcook> Para__: Haskell is deficient as a proof system, among other reasons because of bottom.
18:48:10 <Para__> Did you all learn other languages before Haskell?
18:48:18 <Eduard_Munteanu> Para__: I also have difficulty reading Python docs because of the poverty of types.
18:48:22 <parc> coq or agda are better for proof assistants
18:48:30 <Cale> Para__: It's probably the least broken programming language for which a large usable set of libraries for a wide range of tasks exists.
18:48:31 <zardogg> Eduard_Munteanu: then would you agree that curry function is slighly misnamed? since it doesnt do currying, and that is what the name implies
18:48:34 <Cale> (at present)
18:48:39 <parc> i came from python
18:48:46 <Eduard_Munteanu> Para__: before Haskell, I was comfortable with C but I can't say the same about higher-level languages.
18:49:03 <Cale> Para__: I knew about 10 or 15 languages before starting to learn Haskell
18:49:06 <Eduard_Munteanu> zardogg: why not? It does do currying.
18:49:16 <dwcook> zardogg: Part of the problem involves defining currying within the semantics of Haskell. How would you do so?
18:49:25 <Para__> Is writing Haskell now that you're used to it just as easy/natural as writing C for example?
18:49:27 <Eduard_Munteanu> zardogg: oh, I see what you mean.
18:49:39 <Para__> or is it more difficult/requires more thought by virtue of being functional?
18:49:45 <jhance> (a,b)->c only has one argument
18:49:53 <dwcook> zardogg: At worst I'd say it's not well formed, rather than false.
18:49:55 <zardogg> Eduard_Munteanu: good, I was about to spam the channel again with that quote :)
18:49:58 <Eduard_Munteanu> Para__: they're not generally used for the same tasks, or shouldn't be.
18:50:05 <c_wraith> Para__: it requires more thought because of enforced purity and more abstraction
18:50:18 <Cale> Para__: As for the paid work I've done with it, one was working on a project to implement a compiler for a special purpose language for high performance signal processing applications. Another was working on an action RPG for iPhones and other mobile devices. My last job was working on the backend for a scheduling web application (Skedge.me).
18:50:27 <c_wraith> Para__: at the same time, my confidence in my haskell code is *way* higher.
18:50:29 <zRecursive> Except Symbolic Computing as Maxima, Haskell seems do things well ?
18:50:35 <jhance> Writing haskell is always far more natural than writing C for me
18:51:07 <c_wraith> Except the part where I keep ending up writing low-level unsafe haskell code, and then not being more confident in it than I am C
18:51:09 <Para__> oh hm okay
18:51:20 <Eduard_Munteanu> zardogg: currying actually refers to a pair of arguments, in type theories it usually comes into the form (A x B -> C) -> (A -> C^B), because math functions also take one argument.
18:51:45 <Para__> I'm just asking because say, if I'm trying to compute a least squares or something, it is just very natural to do in python because I have a predefined set of steps that I need to take, and so on
18:51:56 <Para__> but it feels like you have to come up with different ways of doing it in Haskell
18:52:01 <Para__> but that might not be a bad thing
18:52:04 <Eduard_Munteanu> zardogg: so it depends who you ask or how you define "multiple arguments".
18:52:04 <jhance> And you can't take those same steps in Haskell?
18:52:15 <Para__> well don't you have to take them differently?
18:52:24 <Cale> Para__: You can really use Haskell for pretty much anything. It's not directly great at stuff which requires lots of low-level fine-tuning, but it really works well as a metalanguage for that sort of thing (i.e. you write programs that construct the low-level programs for you)
18:53:00 <Eduard_Munteanu> zardogg: but the rigourous definition probably doesn't involve that wording
18:53:01 <Para__> hmm okay, I'm looking forward to getting to that level then :)
18:53:07 <c_wraith> Para__: haskell encourages you to break problems down into pipelines that transform data.  That might not be the same breakdown as python encourages, but it turns out to be a really good one.
18:53:31 <jhance> computing least squares wouldn't be particularly hard recursively, something like gradient descent is basically recursive. If you want to take the "imperative" approach, the data is pretty simple, so it could be done in a recursive state monad
18:54:22 <Para__> c_wraith -- yes, that's the impression I've been getting.
18:54:42 <Cale> There's an ugly way to transform pretty much any imperative algorithm to compute something into a purely functional one, wherein you turn all the mutable variables into function parameters, and you turn each point of control into a function, and have those functions call each other recursively according to the control flow of the original program.
18:54:42 <Para__> how long have you all been using Haskell? (in whatever you do?)
18:54:57 <zRecursive> Any package(s) relative to Symbolic Computing in haskell ?
18:55:05 <Para__> that seems really obfuscating though Cale
18:55:08 <Cale> This results in a mess, but once you do that, you can algebraically simplify the code by substituting equals for equals
18:55:09 <zardogg> Eduard_Munteanu: I was just curious. I had a similar exchange in another channel after saying that all functions in haskell take a single argument, and the other person claimd the opposite and used tuples and curry/uncurry as proof. in the end we werent sure who is correct
18:55:15 <enthropy> > x + y + y
18:55:16 <lambdabot>  x + y + y
18:55:24 <Cale> (like how you'd simplify an expression in highschool algebra)
18:55:28 <enthropy> :t x
18:55:29 <lambdabot> Expr
18:55:36 <Para__> oohhh, that sounds fun
18:55:41 <Cale> and often you can get it down to the point where it becomes simple again :)
18:55:41 <c_wraith> > f x y :: Expr
18:55:42 <lambdabot>  f x y
18:55:47 <Para__> I've been getting the expression that writing Haskell is a lot like just writing math
18:55:56 <Cale> I've done this on occasion to understand obfuscated C programs :)
18:55:58 <Para__> which is actually very much appreciated :)
18:56:22 <dwcook> zardogg: A value composed of other values is still a single value.
18:56:26 <jhance> zardogg: Depends on whether or not you interpret f :: (a, b) -> c has having one or two arguments. I'd tend to say one.
18:56:31 <c_wraith> Para__: It turns out that operation details really do matter in real-world haskell, so it's still writing steps for the computer to take - but in a much more abstract form than just a list of instructions.
18:56:48 <c_wraith> *operational details
18:56:55 <enthropy> zRecursive: probably some CAS like axiom is
18:56:55 <zRecursive> > diff(sin(x)) :: Expr
18:56:57 <lambdabot>  Not in scope: â€˜diffâ€™
18:56:57 <lambdabot>  Perhaps you meant â€˜dffâ€™ (imported from Data.Graph)
18:57:03 <enthropy> more like haskell than maxima is
18:57:07 <dwcook> If it's a question of whether it's more correct to say (Foo, Bar) -> Baz has one or two parameters, the answer is one.
18:57:20 <zRecursive> @hoogle axiom
18:57:21 <dwcook> You can say it has two, colloquially, as long as you understand that it actually only has one.
18:57:22 <lambdabot> No results found
18:57:49 <zRecursive> enthropy: like Maxima ?
18:57:49 <dwcook> Same deal with Foo -> Bar -> Baz, which is more commonly said colloquially to have two parameters than the previous type is.
18:57:54 <zardogg> dwcook: yes that is basically the question
18:58:07 <jhance> And if you don't consider it to be one, keep in mind that [1 2 3] is 1:2:3:~ which is 4 parameters. So then you would be saying a list is N arguments, not 1
18:58:21 <Para__> c_wraith, yeah! I was doing list comprehensions to solve problems because that is what is familiar to me, because it felt like I was defining a set like I would in a proof
18:59:07 <Eduard_Munteanu> zardogg: sounds like the problem is you two were not agreeing on what multiple arguments mean, rather than on currying.
18:59:07 <enthropy> zRecursive: yeah I think so. I've just used maxima, for which longer code looks like common lisp
18:59:07 <zRecursive> @google axiom CAS
18:59:08 <lambdabot> http://www.axiom-developer.org/
18:59:08 <lambdabot> Title: Axiom Computer Algebra System
18:59:42 <c_wraith> Para__: I don't end up using list comprehensions much - even when they are useful. I guess they sort of get in the way of thinking about programs as pipelines.. Comprehensions aren't functions.
19:00:01 <zRecursive> enthropy: The maxima is developed using Common Lisp
19:00:07 * jhance seems list comprehensions as monads, although he can't remember if monad comprehensions still exist
19:00:12 <Cale> Para__: There's a sense in which programming in a functional programming language and writing proofs is actually the same business. Types are like propositions, and programs are like proofs. Haskell isn't ideal for this approach, because it's Turing complete, so you can always write a program which loops forever that will prove any statement.
19:00:13 <jhance> sees*
19:00:17 <Eduard_Munteanu> Also list comprehensions are just a variation on do-notation.
19:00:37 <taktoa> monad comprehensions are still around, but I think you need a ghc extension
19:00:50 <enthropy> zRecursive: yeah it's not really a surprise
19:01:06 <Cale> But there are proof assistants which are basically functional programming languages with slight restrictions on how you're allowed to use recursion.
19:01:12 <zRecursive> enthropy: yeah
19:01:29 <Eduard_Munteanu> "slight", heh.
19:01:31 <zwer> zardogg note that the currying definition you quoted also mentions tuple of arguments: "transforming a function that takes multiple arguments (or a tuple of arguments)"
19:01:35 <Cale> Para__: In logic, if you want to prove A -> B (that is "if A then B"), you start by assuming A, and try to construct a proof of B from there.
19:01:38 <enthropy> @hackage ad
19:01:38 <lambdabot> http://hackage.haskell.org/package/ad
19:01:49 <matematikaadit> taktoa: monad comprehensions?
19:02:13 <Para__> and I'm guessing there's an analog in Haskell?
19:02:15 <Eduard_Munteanu> matematikaadit: using the list comprehension syntax for monads other than lists.
19:02:20 <Cale> Para__: In lambda calculus, if you want to construct a function of type A -> B, you start by assuming you have some variable x of type A, and try to write an expression y of type B in terms of it, and then (\x -> y) is your function.
19:02:22 <jhance> matematikaadit: Generalization of list comprehensions to abritrary monads
19:02:32 <Para__> c_wraith - I should stop using them then, at least temporarily so I can get used to thinking in terms of pipelines
19:02:37 <c_wraith> > [x | <- Just x] -- does lambdabot have monad comprehensions on?
19:02:39 <lambdabot>  <hint>:1:6: parse error on input â€˜<-â€™
19:02:43 <c_wraith> err
19:02:54 <jhance> > [y | y <- Just x]
19:02:54 <c_wraith> > [x | x <- Just 5]
19:02:55 <lambdabot>  Couldn't match expected type â€˜[t]â€™
19:02:55 <lambdabot>              with actual type â€˜Data.Maybe.Maybe Debug.SimpleReflect.Expr.Exprâ€™
19:02:55 <lambdabot>  can't find file: L.hs
19:03:00 <c_wraith> Nope.
19:03:05 <c_wraith> Not enabled
19:03:40 <Para__> Cale - so its just an explicit construction of the function?
19:03:48 <c_wraith> Para__: Nah, don't worry about it.  Use what's comfortable for you - but ask us for feedback whenever you're curious if there's another way to do something.
19:04:28 <jhance> list comprehension = concat . map
19:04:41 <Para__> also assuming some variable of type A, isn't that a "there exists" rather than "for all" in terms of the proof from A -> B?
19:04:47 <Eduard_Munteanu> [ <e1> | <pat> <- <e2>, <e3> ] ~ do { <pat> <- <e2>; guard <e2>; return <e1> }
19:04:53 <Para__> (I'm not familiar with Lambda calculus so I might be talking nonsense)
19:05:06 <Eduard_Munteanu> Er, guard <e3>
19:05:50 <c_wraith> jhance: and filter
19:06:07 <Para__> also, is lambda calculus usually covered in a specific class at Uni? (What class is it, if it is?)
19:06:14 <jhance> c_wraith: okay fine :(
19:06:34 <jhance> Para__: Maybe Programming Language Concepts-type courses will cover it, or if you have any FP courses
19:06:43 <jhance> Para__: Doubt its in standard curricula
19:06:55 <zRecursive> > [0..] >>= \n -> n^2 <$ guard (even n)
19:06:57 <lambdabot>  [0,4,16,36,64,100,144,196,256,324,400,484,576,676,784,900,1024,1156,1296,144...
19:07:27 <Para__> ah alright, I'll look around. I really want to take a FP class!
19:07:32 <kadoban> lambda calc was very briefly mentioned in a required course for me, but that was it...like a day as an aside
19:07:48 <simon> :t guard
19:07:49 <lambdabot> MonadPlus m => Bool -> m ()
19:07:53 <Para__> I might have to wait a year though because there might be prereqs or stuff so by that point I'll probably have learned it on my own if the class is introductory
19:08:04 <Para__> kadoban, what course was it?
19:08:25 <kadoban> Para__: Called Programming Language Concepts IIRC
19:08:41 <Para__> alright, thanks!
19:08:43 <Eduard_Munteanu> Perhaps type theory courses, if they don't focus too much on subtyping.
19:09:16 <simon> I only met the lambda calculus in a logic course on my bachelor.
19:09:28 <Para__> wait, is lambda calculus like something silly that you should be able to learn in a week or two, or is it something like the 'usual' calculus that has several classes dedicated to it?
19:09:44 <enthropy> zRecursive: have you looked at ftp://ftp.botik.ru/pub/local/Mechveliani/docon/2.11/ ?
19:10:04 <Eduard_Munteanu> Para__: untyped lambda calculus can be presented in a rather trivial manner
19:10:22 <zRecursive> enthropy: not yet, thanks
19:10:28 <Eduard_Munteanu> Para__: and there isn't really a connection to calculus as in real analysis.
19:10:39 <simon> Para__, there's not much to the calculus itself. you could probably get an understanding of it in minutes.
19:10:46 <Eduard_Munteanu> (derivatives, integrals etc.)
19:11:10 <Para__> oh alright! Is there more to typed lambda calculus though?
19:11:37 <Para__> and I suppose that would be a good thing to get myself familiarized with while/before continuing FP?
19:11:55 <kadoban> So, I'm getting this: http://haskell.1045720.n5.nabble.com/GHC-9104-internal-compiler-error-Segmentation-fault-for-haskell-src-exts-1-15-0-1-td5749513.html  on ghc 7.8.2 installing haskell-src-exts-1-15-0-1, which was closed because it's a dupclicate of a fixed bug? I don't get it. Doesn't seem fixed to me...
19:12:11 <kadoban> Anyone see this before?
19:13:31 <Eduard_Munteanu> Para__: depends on the subtopics you'd touch
19:13:49 <simon> Para__, reading about formal type theory is hardly necessary to begin FP. learning about the untyped lambda calculus can give a lot of intuition when handling functional programs. for example, beta-transforms, eta-reductions, currying.
19:14:23 <Para__> hmm okay
19:14:28 <Para__> thank you a ton guys!
19:14:44 <Para__> (I'm going to bed because I'm exhausted, but I'll be sure to stop by here more often!)
19:15:12 <simon> Para__, http://www.haskell.org/haskellwiki/Eta_conversion is one example using Haskell.
19:15:13 <Eduard_Munteanu> G'night and be back, then.
19:15:25 <Para__> I will!
19:38:51 <fread2282> @src catMaybes
19:38:51 <lambdabot> catMaybes ls = [x | Just x <- ls]
19:50:50 * hackagebot rainbox 0.4.0.4 - Two-dimensional box pretty printing, with colors  http://hackage.haskell.org/package/rainbox-0.4.0.4 (OmariNorman)
19:51:19 <platz> anyone have any thoughts on SOLID in context of FP?  LID seem sensible, but i find O suspect
19:55:41 <parc> is it possible to make a zipper for a data type like "data F b = forall a. F (F (a -> b)) (F a) | A b", or will the existential quantification make it impossible to know the intermediate types?
19:56:22 <c_wraith> parc: it will be impossible to know the intermediate types, but that doesn't mean it's useless.
19:57:06 <parc> i'm trying to replace an intermediate term just with a case statement to test, but i'm having issues, so i'm thinking maybe no?
19:58:18 <monochrom> I think it's a no, parc.
19:58:44 <parc> dang. so much for that
19:59:46 <monochrom> data F b = forall a. a ~ Maybe Int => F (F (a -> b)) (F a) | A b  :)
20:01:08 <shachaf> parc: What is the origin of this type?
20:01:58 <gbluma> platz: I imagine O corresponds to the expression problem. In haskell that means typeclasses, which are open to extension but not modification. Fundamentally though, it's just a new function with predictable semantics.
20:02:32 <shachaf> The expression problem doesn't really have to do with type classes.
20:02:57 <platz> gbluma: I don't think typeclasses solve the expression problem, isn't that why we have things like "datatypes a la carte"?
20:03:15 <parc> shachaf: an abstract syntax tree basically. i wanted to try something where intermediate asts could be replaced with asts of the same type, so if the ast represented a function you could (in theory) replace parts of it with more efficient functions
20:03:41 <shachaf> data Shape = Shape { circumference :: Double, area :: Double } vs. data Shape = Circle Double | Rectangle Double Double -- the expression problem, no type classes involved.
20:04:19 <parc> shachaf: the A constructor would also need a string to give a way to compare arbitrary atoms. i guess maybe the idea could still work with dynamic though
20:04:38 <yac> when an exception is thrown, it propagates all the way to the main and terminates the program, unless catched somewhere in the chain, right?
20:05:03 <shachaf> If it's in the main thread, yes.
20:05:28 <parc> yac: and it can only be caught in IO
20:05:43 <yac> and exception in haskell is nothing else than a custom data type defined for this purpose, right?
20:05:46 <yac> parc: right
20:05:52 * hackagebot twitter-conduit 0.0.3 - Twitter API package with conduit interface and Streaming API support.  http://hackage.haskell.org/package/twitter-conduit-0.0.3 (TakahiroHimura)
20:06:16 <yac> is it possible to generate a traceback?
20:06:49 <shachaf> Sometimes you can use
20:06:51 <shachaf> @where rts-xc
20:06:51 <lambdabot> ghc -prof -fprof-auto -rtsopts -osuf .p_o foo.hs && ./foo +RTS -xc # print stack traces on unhandled exceptions
20:09:06 <gbluma> I thought the expression problem attempted to fix the issue of common things that should have the same property (e.g. being able to be "shown"), hence show(Int) and show(Bool) opt-in to membership after definition.
20:09:48 <platz> gbluma: thats typeclasses
20:10:10 <yac> cool
20:10:41 <goldfire_> \msg lambdabot
20:10:55 <gbluma> platz: and that's what seems to mimic the open/closed principle in SOLID.
20:11:03 <goldfire_> @help
20:11:04 <lambdabot> help <command>. Ask for help for <command>. Try 'list' for all commands
20:11:11 <shachaf> goldfire_: /msg :-)
20:11:19 <shachaf> The expression problem is this: There are different kinds of things -- in my example, circles and rectangles -- and there are different kinds of operations -- in my example, circumference and area.
20:12:10 <shachaf> You want to design an API that's extensible. It's easy to design it so that people can add their own kinds of shapes -- define a shape in terms of the operations it supports -- or their own kinds of operations -- define a shape in terms of what it is.
20:12:24 <shachaf> The expression problem is "can we do both?".
20:12:43 <platz> gbluma: i agree there's some commong ground here; I'll have to think more about this relationship.  but I still think you're forgetting one of the other sides of the expression problem, being able to add new data to an existing data case, or adding new functions on that data
20:13:27 <shachaf> This has nothing to do with type classes except that when you use a type-class-based API, you're picking one side (define things in terms of operations).
20:13:37 <gbluma> platz: right, I think I oversimplified that part.
20:14:17 <shachaf> The answer to the expression problem, by the way, is "no, we can't".
20:15:07 <platz> shachaf: but only using classical FP or OO.  I thought folks like Oleg came up with solutions, although complex and probably not suitable for production
20:15:11 <c_wraith> shachaf: you don't believe the finally tagless approach really successfully solves it?
20:15:47 <gbluma> shachaf: Thanks for pointing that out. I'll read up on it more.
20:16:00 <shachaf> I think anyone who claims to solve it does it by redefining the problem.
20:16:13 <shachaf> Which is a great way to solve problems.
20:16:27 <pavonia> shachaf: Is that a general problem or especially one of Haskell/FP?
20:16:39 <shachaf> c_wraith: What is the finally tagless approach?
20:16:56 <platz> pavonia: it's a general problem
20:16:59 <shachaf> pavonia: It's a general problem but it comes up especially in Haskell because it's easy to express both approaches.
20:18:07 <shachaf> lambdabot [~lambdabot@silicon.int-e.eu] requested CTCP TIME from shachaf:
20:18:24 <shachaf> Good times.
20:19:55 <andkore> Anyone have experience with event sourcing? Right now I'm trying to figure out how to deal with code changes. I'm going to have one database that just has event data, and another that caches current state snapshots of entities/aggregate roots that have been requested before. But I don't know how to deal with code changes that essentially invalidate the cached current state.
20:19:56 <c_wraith> shachaf: I never did finish the paper: http://okmij.org/ftp/tagless-final/course/lecture.pdf
20:23:03 <yac> how can I catch ENOTEMPTY error?
20:24:24 <shachaf> c_wraith: Well, it's probably worth reading. I could be wrong.
20:24:45 <c_wraith> shachaf: oleg's usually worth reading.  Even if I disagree that the approaches are practical.
20:25:13 <shachaf> Yep.
20:26:25 <shachaf> It looks like their approach is "you can extend it along both axes and we can statically check that everyone along one axis is aware of the changes along the other axis".
20:26:54 <shachaf> I guess that's a valid interpretation of the problem.
20:29:06 <Cale> https://www.youtube.com/watch?v=P60Rl-JTgMs#t=166 -- oh, nice, someone uploaded this course to YouTube
20:29:42 <Bartleby> Newbie question about an error I'm getting
20:29:45 <Cale> It's a great series of lectures which has been around for a long while, but in a highly inconvenient format
20:30:49 <Bartleby> ((== 0) $ (mod 6)) 3 returns True
20:31:20 <Bartleby> but map ((== 0) $ (mod 6)) [3,5] gives me an error
20:31:21 <Cale> Bartleby: That ought to be a type error
20:31:33 <Bartleby> Why?
20:31:35 <Cale> Are you sure you don't mean (.) instead of ($)?
20:31:51 <shachaf> > ((== 0) $ (mod 6)) 3
20:31:52 <lambdabot>  Couldn't match expected type â€˜a1 -> tâ€™
20:31:52 <lambdabot>              with actual type â€˜GHC.Types.Boolâ€™
20:31:53 <Bartleby> Because period is compose...
20:31:55 <Bartleby> Right
20:31:59 <Cale> (== 0) $ (mod 6) means  (mod 6) == 0
20:31:59 <shachaf> It looks like they're both type errors.
20:32:03 <Bartleby> That would explain it
20:32:08 <Cale> i.e. you're checking whether that function is equal to 0
20:32:40 <parc> map ((== 0) . (mod 6)) $ [3,5]
20:32:52 <parc> might be what you want?
20:33:01 <Bartleby> Ok, then I'm not going to try to understand why dollar signs weren't giving me a type error.
20:33:11 <shachaf> Perhaps you omitted the parentheses.
20:33:11 <Bartleby> In the simple expression at least
20:33:13 <Bartleby> Nope
20:33:16 <Cale> Bartleby: They should have
20:33:30 <Cale> Bartleby: Are you sure that's the expression you actually had written?
20:34:11 <Bartleby> Prelude> (== 0) $ (mod 3)  3
20:34:12 <Bartleby> True
20:34:36 <Bartleby> Ah. Omitted the parentheses
20:38:32 <Bartleby> Well, end result:
20:38:35 <Bartleby> pe1 = sum  (filter (\i-> or (map ((== 0) . (mod i)) [3,5])) [1..999])
20:38:54 <Bartleby> I think I like this language.
20:39:54 <shachaf> > sum (filter (\i -> any (\n -> i `mod` n == 0) [3,5]) [1..999])
20:39:55 <lambdabot>  233168
20:40:39 <shachaf> I think it's much more readable with the lambda.
20:41:34 <shachaf> > sum [i | i <- [1..999], any (\n -> i `mod` n == 0) [3,5]] -- another option
20:41:35 <lambdabot>  233168
20:41:55 <Bartleby> I just find ((== 0) . (mod i)) cute
20:46:29 <Bartleby> ' any ' looks like a neat function
20:46:57 <shachaf> @src any
20:46:58 <lambdabot> any p =  or . map p
20:47:28 <Bartleby> That's cute
20:51:55 <zwer> @src or
20:51:56 <lambdabot> or    =  foldr (||) False
21:00:51 <Bartleby> You know, a little syntactic sugar is pretty nice once in a while.
21:02:11 <Bartleby> (Racket/Schemer on vacation)
21:40:18 <parc> @hoogle Dynamic -> TypeRep -> Maybe a
21:40:20 <lambdabot> Prelude const :: a -> b -> a
21:40:20 <lambdabot> Data.Function const :: a -> b -> a
21:40:20 <lambdabot> Data.Dynamic fromDyn :: Typeable a => Dynamic -> a -> a
21:40:48 <parc> is there any way to write a function like that? Dynamic -> TypeRep -> Maybe a
21:42:47 <shachaf> Maybe a?
21:43:18 <parc> Just a if the TypeRep of the Dynamic is equal to the provided TypeRep
21:43:41 <parc> without knowing the type in advance
21:43:56 <shachaf> I'm wondering whether you mean an existential type.
21:44:06 <shachaf> Probably not.
21:44:15 <shachaf> Typeable a =>?
21:44:26 <parc> i guess that would be a requirement
21:44:32 <shachaf> The caller of that function can specify any "a" they want, as it is.
21:44:44 <shachaf> For example, I can pick a = Int, and pass you a TypeRep for Char.
21:45:38 <parc> now that i think about it a little more i don't think i need to have such a function regardless, so moot point i guess
21:47:59 <kadoban> I can't seem to get haskell-src-exts 1.15.0.1 to build with ghc 7.8.2, anyone else succeed at that? It fails with a compiler segfault that I don't know what to do with...
21:50:09 <rwbarton> it's a segfault in gcc
21:50:36 <rwbarton> https://ghc.haskell.org/trac/ghc/ticket/8768
21:50:53 <rwbarton> kadoban: you can build it without profiling
21:52:04 <kadoban> rwbarton: Ahh, thanks, let me give that a try (without profiling).
21:55:36 <parc> supposing you absolutely needed a way to serialize/deserialize functions/infinite data types. any elegant ways to do that?
21:57:49 <enthropy> @type \d tr -> do a <- fromDynamic d; guard (typeOf a == tr); return a
21:57:50 <lambdabot> Typeable b => Dynamic -> TypeRep -> Maybe b
21:58:27 <copumpkin> parc: find a finite description of them and serialize that, along with an interpreter for it
21:58:52 <carter> rwbarton: gcc 48 being crashy?
22:01:05 * hackagebot foldl 1.0.5 - Composable, streaming, and efficient left folds  http://hackage.haskell.org/package/foldl-1.0.5 (GabrielGonzalez)
22:01:17 <enthropy> https://code.google.com/p/xmonad/issues/detail?id=522 is one such trick
22:02:15 <parc> best idea i've come up with is sticking the code in a binary tree with (Dynamic,Text) at the leaves, so you have a text interpretation of each leaf node, then have a Map (TypeRep,Text) Dynamic containing all the leaf values, and then i could serialize a tree with (TypeRep,Text) at each leaf node, and when i need to unserialize it use the map to look up the original Dynamic values
22:03:00 <enthropy> what is the point of Text there?
22:03:08 <parc> just to give a name to each function
22:03:45 <parc> or atom anyway. i want to be able to distinguish functions though mainly
22:03:52 <enthropy> you can't serialize Dynamic in general though
22:04:33 <parc> no, that's what the Map is for. you wouldn't serialize it, but you could serialize every else, and then use the Map to look up the atoms if it's defined in some module
22:09:16 <kadoban> rwbarton: Thanks again, that seemed to work. I guess I can't use library profiling on anything that depends on that then, but thankfully I don't think it matters
22:10:22 <enthropy> if you want to use Text for function names, and Dynamic to store their implementation, I think you might be better off with some other language that has such a style as the default
22:11:00 <parc> yeah, but i also want to generate an infinite tree of every abstract syntax tree, and lazy evaluation helps with that
22:13:08 <parc> not sure of any languages that have both features
22:14:37 <copumpkin> chances are you're trying to solve it in a way that Haskell isn't suited for
22:14:46 <copumpkin> I'd step back and look for more idiomatic solutions :)
22:14:53 <copumpkin> not that I know the specific problem
22:16:54 <parc> i was about to try another language, but then i came up with that (albeit weird) solution. the problem is efficient combinatorial search
22:17:31 <parc> of abstract syntax trees in this particular instance, which obviously makes things harder for haskell
22:19:00 <carter> parc: you might wanna look at bound
22:19:03 <carter> for modelling asts
22:19:07 <carter> whats the goal
22:19:18 <carter> combinatorial enumeration of ASTs to .... what?
22:20:53 <parc> the eventual goal is to be able to provide some way to score an arbitrary function for some problem and have the computer find a good one
22:21:35 <parc> though i'm not really planning to do anything that would be described as combinatorial exactly. i don't imagine that would ever scale
22:21:54 <codygman> Why does the first work, but the second doesn't: http://lpaste.net/105584
22:21:57 <bbopen> for those that use vim for haskell, is vim2hs a good starting point for a newbie haskeller with vim? https://github.com/dag/vim2hs
22:22:48 <parc> carter: and the programs i'm interested in are a very restricted subset of programs. a dsl would probably make more sense, i just wanted to generalize
22:23:06 <jmcarthur> "<parc> of abstract syntax trees in this particular instance, which obviously makes things harder for haskell"  huh, i would have thought this would make it seem *easier* for haskell relative to other languages
22:25:28 <parc> it's just the serialization that's the problem. if you don't have much in the way of reflection then F (A sin) (A 1.0) just looks like F (A ?) (A 1.0)
22:25:32 <enthropy> bbopen: you could write out where the arguments should go
22:26:10 <enthropy> if you mean    \(a,b) -> do print a; print b, you should write that
22:26:35 <parc> jmcarthur: if i'm keeping things general, i want to be able to distinguish between sin and cos for instance, which caused me some headaches initially
22:26:51 <enthropy> what you have now is smething like    \(a,_ ) -> do (_, b) <- print a; print b
22:27:19 <jmcarthur> if you have a syntax tree i don't see why that wouldn't just be trivial
22:27:23 <bbopen> enthropy: vim2hs is a somewhat misleading name. I donâ€™t think it is a vimscript to haskell code generator
22:27:48 <enthropy> oops, sorry my comments are for codygman
22:27:54 <bbopen> enthropy: it looks like just basically vim plugins (series highlighting, etc)
22:27:56 <bbopen> ok
22:28:18 <enthropy> vim2hs is reasonable though
22:29:07 <enthropy> http://projects.haskell.org/haskellmode-vim/ is older, but it has some things (shortcuts for adding pragmas) that I don't think vim2hs has
22:30:28 <bbopen> thanks
22:30:37 <parc> jmcarthur: well i want to have a runtime representation in haskell, which means you need to provide each function with a Text id so you have an Eq instance: A (_ name1) == A (_ name2) = name1 = name2, and something suitable for the recursive step for the function application constructor
22:31:37 <shachaf> parc is not the same person as parcs, huh.
22:31:48 <parc> no
22:31:58 <toki78> hi
22:32:07 <parc> shachaf: is that someone well known here?
22:32:11 <toki78> is there a channel for html5 / javascript ?
22:32:49 <shachaf> parc: Well, I guess he's not around right now.
22:33:18 <parc> jmcarthur: and i need to have a Map mapping ids to functions, so i can serialize and unserialize the AST later on (the functions cant be serialized, but the ids can), so i can take the serialized ids, look them up in the Map, and reconstruct the AST later on
22:34:31 <parc> jmcarthur: though i lose some type safety, since the Map can't have values of any type, but you can still make it very difficult to construct an improperly typed AST, so i'm not concerned about that
22:35:26 <parc> jmcarthur: the serialization is certainly more involved in haskell than in other languages, but there are a few things about the end result i like better
22:36:23 <enthropy> you could store "F (A Sin) (A 1.0)"
22:36:33 <zomg> toki78: ##javascript
22:36:45 <parc> enthropy: yeah, but then i need to make data constructors for every function, which is a pain
22:37:06 <toki78> zomg, thanx, could not find it within channel list
22:37:07 <enthropy> and compositions of functions
22:37:27 * enthropy wonders if template-haskell is appropriate
22:37:55 <kazagistar> this will memoize, right? {-# SPECIALIZE primes :: [Int] #-} primes :: Integral a => [a]
22:38:00 <enthropy> considering that it is a sensible way to make a haskell AST out of pieces
22:38:02 <parc> i was thinking about that too. my solution will probably need it regardless, there's quite a bit boiler plate
22:38:07 <enthropy> there's just no runtime eval
22:38:22 <jmcarthur> parc: http://hackage.haskell.org/package/dependent-map
22:38:25 <enthropy> eval :: Exp -> Dynamic
22:38:33 <ab9rf> ugh
22:39:11 <jmcarthur> i think i am still confused about why the serialization is hard, really
22:39:15 <enthropy> (ghc-api/hint have such a thing)
22:39:19 <parc> jmcarthur: hadn't seen that
22:39:29 <jmcarthur> why not just add binders to your syntax so you can represent cycles with a letrec construct?
22:39:33 <ab9rf> yeah, me neither, i'd think serialization would be easier in haskell or least no harder
22:39:50 <jmcarthur> then you get to decide the id instead of making the serializer do it
22:39:59 <kazagistar> cause under no optimizations, { primes :: Integral a => [a] } does not seem to be memoizing... it seems to act more like a function then a value
22:40:22 <toki78> anyone here working on ersatz ?
22:40:47 <jmcarthur> kazagistar: that would make some sense, because ghc implements type classes as dictionaries passed as arguments
22:41:08 <jmcarthur> kazagistar: with optimizations they often are inlined
22:41:14 <parc> i figured i would need template haskell to populate the map. i wouldn't even just need to repeat the names of all the functions, i'm pretty sure i'd also need to repeat them for different types for polymorphic functions
22:41:24 <codygman> Thanks enthropy
22:41:39 <toki78> I contributed example code to ersatz
22:42:09 <parc> insertToMap ((+) :: Int -> Int -> Int) "(+)" ; insertToMap ((+) :: Double -> Double -> Double) "(+)" etc...
22:42:34 <jmcarthur> honestly i still don't understand 100% what the map is for
22:42:45 <jmcarthur> i could see if it was an environment of some sort, but this sounds different
22:43:18 <kazagistar> jmcarthur: right, but I am wondering if there is a good way to force memoization, without having to pass "which list of primes I am using" into functions like "factor"
22:43:41 <samrat> what is a better pattern for doing the equivalent of  fmap (map f) xs ?
22:43:54 <jmcarthur> samrat: what's wrong with it as written?
22:44:12 <jmcarthur> samrat: you could make it more general, i suppose, by replacing map with fmap...
22:44:12 <parc> well in order to generate the tree of all ASTs i need to do something like choose a type, then choose an object from the tree, which could either by choosing an atom or recursing
22:44:31 <samrat> jmcarthur: nothing is wrong with it. just wondering if I was missing something
22:44:36 <jmcarthur> samrat: and depending on your tastes you could try expressing it at  (fmap.fmap) f xs  which is totally subjective
22:44:48 <jmcarthur> s/at/as/
22:45:08 <jmcarthur> parc: so it's *not* about serialization?
22:45:16 <parc> it's about both
22:45:28 <jmcarthur> sadly, i must go to sleep
22:45:38 <parc> well thanks for the advice :)
22:45:44 <jmcarthur> well, not sadly for me, as i am looking forward to sleep
22:45:49 <jmcarthur> gnite
22:45:59 <parc> gnite
22:46:12 * hackagebot aeson-qq 0.7.1 - JSON quasiquoter for Haskell  http://hackage.haskell.org/package/aeson-qq-0.7.1 (SimonHengel)
23:17:51 <d3m1g0d-> good morning, Haskell beasts
23:21:08 * vanila snarls and rolls over on a pile of lambdas
23:22:43 <ab9rf> gor
23:36:18 * hackagebot mvc-updates 1.0.0 - Concurrent and combinable updates  http://hackage.haskell.org/package/mvc-updates-1.0.0 (GabrielGonzalez)
23:41:18 * hackagebot hspec-wai 0.2.0 - Experimental Hspec support for testing WAI applications (depends on hspec2!)  http://hackage.haskell.org/package/hspec-wai-0.2.0 (SimonHengel)
