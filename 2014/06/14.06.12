00:01:43 <lfairy> or the asterisk, at that
00:02:55 <hunt_> so is haskell.org getting replaced with haskell-lang.org?
00:04:59 <zwer> > 'a' + 1
00:05:01 <lambdabot>  'b'
00:05:06 <zwer> :D
00:05:10 <bitemyapp> hunt_: haskell-lang is a separate community member's project.
00:05:26 <bitemyapp> hunt_: there's a lot to like about it haskell-lang, but I don't know if it'll replace haskell.org or not.
00:06:17 <hunt_> zwer wtf
00:06:54 <zwer> I defined a Num instance for char in private :)
00:07:26 <zwer> > ord $ 'z' - 'a'
00:07:27 <lambdabot>  25
00:08:23 <gamegoblin> I like the purple color on haskell-lang
00:08:30 <gamegoblin> It’s a good choice
00:08:52 <bitemyapp> gamegoblin: me too
00:08:59 <knappador> Okay, about to have GHC installed into a user directory
00:10:46 <knappador> I think I need cabal.  Do sandboxes use their own cabal?
00:10:58 <gamegoblin> In the attoparsec documentation, you encounter this acronym a lot: “WHNF”. What’s that?
00:11:00 <knappador> can/should they?
00:11:02 <johnw> they use the same cabal
00:11:16 <johnw> unless you install cabal-install within the sandbox, of course
00:11:34 <nschoe> gamegoblin, Weak Head Normal Form
00:12:04 <gamegoblin> So there is the `many` combinator and the many’ combinator. The many’ claims the result will be WNHF. What does that mean relative to the normal `many` combinator?
00:12:49 <triliyn> gamegoblin: an expression is in weak-head normal form if the top-level expression node thing is a constructor application
00:13:00 <knappador> So I probably want cabal and cabal-install.  Can I just use cabal-install to get cabal or does it depend on cabal? =D
00:13:13 <gamegoblin> trilliyn: Can you give an example, I am not quite getting it
00:13:17 <triliyn> In "a + b", the top-level node thing is +, so that's not in WHNF; in "a : b", : is a constructor, so that is
00:13:40 <johnw> NF = Just 10, WHNF = Just ..., unevaluated = ...
00:14:14 <knappador> nm i see in docs.
00:14:25 <triliyn> Right, another way to put it is that an expression is in WHNF if it's been evaluated far enough that you know what constructor the final result has
00:14:41 <nschoe> triliyn, awesome, I think you just cleared things out concerning WHNF for me !
00:14:52 <triliyn> :)
00:15:06 <frerich> triliyn: I think the "expression is WHNF is top-level node is a constructor" explanation is the nicest explanation I've ever heard.
00:15:07 <gamegoblin> hurg… I still don’t get how it relates to various combinators in attoparsec
00:15:44 <gamegoblin> bos uses the same example for both the WHNF and non-WHNF versions of the same combinator
00:16:17 <gamegoblin> The only difference is the non-WHNF require an Alternative and the WHNF version requires MonadPlus
00:16:32 <triliyn> hmmm
00:16:49 <triliyn> I think in this context it has something to do with strictness
00:16:59 <gamegoblin> I don’t see any bangs in the source code
00:17:56 <frerich> gamegoblin: For what it's worth, there's a very nice explanation of how strictness, lazy evaluation and Weak Head Normal Form at the beginning of "Parallel and Concurrent Programming in Haskell" by Simon Marlow, at the very beginning of th book even.
00:18:05 <zRecursive> @src ($!)
00:18:05 <lambdabot> f $! x = x `seq` f x
00:18:49 <gamegoblin> frerich: Thanks. I’d still like to understand what it is in this context right now if possible, since I’m trying to go for full compatibility with parsec and attoparsec
00:19:53 <frerich> ganegoblin: I just learned, that he book is available online! The section I was talking about is at http://chimera.labs.oreilly.com/books/1230000000929/ch02.html#sec_par-eval-whnf
00:20:31 <gamegoblin> Oh awesome. Reading now.
00:24:38 <gamegoblin> Ahh now I understand that, but I still don’t get how it relates to attoparsec...
00:24:59 <gamegoblin> and/or why it’s desireable
00:27:56 * hackagebot typeparams 0.0.5 - Lens-like interface for type level parameters; allows unboxed unboxed vectors and supercompilation  http://hackage.haskell.org/package/typeparams-0.0.5 (MikeIzbicki)
00:28:19 <johnw> izbicki should really come here
00:28:45 <johnw> and then change his nick to sonofoleg for his awesome type hackery :)
00:29:56 <enthropy> probably mikeizbicki is the right nick
00:30:04 <johnw> mikeizbicki: hello!
00:30:20 <riaqn> Hi all. I 'm quite new to FP. How is the "real world" implemented in IO monad in haskell?
00:32:28 <johnw> are you asking about the execution model for the GHC runtime?
00:32:39 <enthropy> @src IO
00:32:39 <lambdabot> Source not found. My brain just exploded
00:32:53 <johnw> I don't think it's implemented in Haskell at all
00:33:09 <wz1000> Can it be?
00:33:21 <enthropy> newtype IO a = IO (State# RealWorld -> (# State# RealWorld, a #))
00:33:22 <johnw> using the C FFI, sure
00:33:47 <riaqn> johnw: I didn't myself clear. So how is it implemented in C?
00:34:00 <wz1000> Don't you need IO to use the C FFI
00:34:02 <enthropy> is a trick to keep ghc from reordering things it shouldn't reorder
00:34:33 <johnw> riaqn: this is the best I could find: http://web.mit.edu/~ezyang/Public/jfp-ghc-rts.pdf
00:35:08 <wz1000> I wish haskell was a bit more lispy.
00:35:27 <gamegoblin> GHC actually sends haskell programs into the future to be compiled by skynet
00:35:28 <johnw> why is that, wz1000?
00:35:49 <riaqn> well, to make problem clear, what happens to the realworld argument when it's passed to an IO function?
00:36:16 <wz1000> code and data having the same representation is a beautiful idea
00:36:16 <johnw> why do you think there's a realworld argument?
00:36:30 <gamegoblin> Is there a way to examine the C - - code that is generated in the compile process?
00:36:36 <wz1000> and i dint like keywords
00:36:44 <wz1000> *dont
00:37:08 <riaqn> johnw: http://www.haskell.org/haskellwiki/IO_inside
00:37:27 <enthropy> wz1000: you're allowed to foreign import ccall "printf" cprintf :: CString -> Int -> ()
00:37:31 <enthropy> it's just not a good idea
00:38:26 <wz1000> so you can have functions that have side effects, but lie to you about it
00:39:25 <Cale> gamegoblin: -ddump-cmm
00:39:43 <Cale> gamegoblin: But in most cases, the useful intermediate representation is -ddump-simpl
00:40:26 <gamegoblin> Cale: cmm didn’t print anything out. simpl did, though
00:40:44 <gamegoblin> Cale: wait, typo
00:42:03 <gamegoblin> wow the cmm is terifying
00:42:05 <gamegoblin> and I love C
00:42:12 <Cale> riaqn: The  State# RealWorld  thing is just a 0-byte token -- it's just there to abuse/reuse the dependency analysis which already exists for expression evaluation to keep the order of effects straight.
00:42:13 <gamegoblin> goto’s everywhere
00:43:37 <gamegoblin> Cale: What is simpl exactly?
00:43:41 <Cale> riaqn: But really, I tend not to think in terms of GHC's actual implementation of IO (which is a hack), and instead picture that IO actions are effectively like syntax trees in terms of primitive IO actions, and that the runtime system is traversing one of those and interpreting it.
00:43:48 <shachaf> Cmm is more like assembly than like C.
00:43:48 <gamegoblin> Cale: Some weird AST or...?
00:43:58 <gamegoblin> shachaf: definitely got that vibe
00:44:01 <Cale> gamegoblin: That's the Core language
00:44:01 <shachaf> It's explained in the GHC manual.
00:44:16 <knappador> ghc takes a little bit to compile eh
00:44:18 <Cale> gamegoblin: After the simplifier has been run on it (so, after the most important optimisations)
00:44:35 <alpounet> gamegoblin: i've written up a more or less smooth intro to GHC Core, if you're interested: http://alpmestan.com/posts/2013-06-27-ghc-core-by-example-episode-1.html hopefully that'll help
00:44:37 <knappador> how exactly is it so gigantic?
00:44:54 <gamegoblin> alpounet: reading now, thanks
00:44:55 <Cale> knappador: You generally shouldn't bother compiling it yourself unless you're going to be working on it, or you're on a weird platform and nobody's produced a new-enough binary
00:44:56 <alpounet> knappador: if you need it to compile things quickly, turn off optimizations, with -O0
00:45:11 <alpounet> ah, misunderstood. nvm
00:45:22 <knappador> yeah, i'm on a shit platform.  this distro is getting scrubbed.
00:45:31 <Cale> knappador: What OS?
00:45:39 <knappador> Gentoo derivative
00:45:48 <Cale> Well, on any linux, there's a binary
00:46:03 <Cale> Assuming you're using x86/x64
00:46:09 <knappador> honestly.....I bet could have gotten away easier now that I know what the original issue was =)
00:46:29 <gamegoblin> So is Cmm a totally valid subset of C, or are there modifications?
00:46:33 <knappador> but i'm going through the motions on a local box and server too
00:46:48 <riaqn> Cale: Thanks for explanation.I 'm curious about how it's implemented? maybe just a random sequence?
00:46:49 <Cale> knappador: I'd normally just grab one of the binaries here http://www.haskell.org/ghc/download_ghc_7_8_2#x86linux
00:46:50 <knappador> oh wait, server is non-crap distro and the package manager does it's #*@Ying job
00:46:59 <Cale> knappador: and then install cabal-install
00:47:11 <riaqn> Cale: like Uniqueness type?
00:47:17 <Cale> by grabbing the tarball from hackage and running the bootstrap.sh script in it
00:47:26 <Cale> riaqn: It doesn't exist at runtime
00:47:26 <knappador> gonna go get groceries and do laundry =)
00:47:58 <Cale> riaqn: It's a 0-byte wide parameter, nothing even gets passed around.
00:48:20 <Cale> riaqn: (It's just there for the compiler's sake, it's a hack)
00:49:39 <Cale> riaqn: You can think of it as serving the same purpose as the RealWorld parameters in a system with uniqueness typing, but there are no uniqueness types here
00:50:07 <wz1000> @src sequence
00:50:08 <lambdabot> sequence []     = return []
00:50:08 <lambdabot> sequence (x:xs) = do v <- x; vs <- sequence xs; return (v:vs)
00:50:08 <lambdabot> -- OR: sequence = foldr (liftM2 (:)) (return [])
00:50:10 <exicer> I'm confused by bytestrings. If I read a file as a bytestring, and then show it, I can see what the characters are correctly. If I then write that bytestring to a file, it is gibberish - why ?
00:50:13 <Cale> knappador: I never rely on my distribution to provide reasonable Haskell-related stuff
00:50:39 <Cale> exicer: Uhhh, how are you reading and writing it?
00:50:45 <riaqn> I get it. "ghc treat realworld as a specical case", am I right?
00:50:55 <shachaf> exicer: This sounds like a confusion between characters and bytes. ByteStrings are strings of bytes, the misleading Show instance notwithstanding.
00:51:10 <levi> gamegoblin: I don't think it's very much like C at all.
00:51:11 <exicer> I'm reading it with Data.Conduit.Binary.sourceFile
00:51:21 <exicer> shachaf: Undoubtably..
00:51:31 <lfairy> exicer: are you using Windows?
00:51:35 <exicer> I'm writing it with Data.Conduit.Binary.sinkFile
00:51:41 <exicer> lfairy: os
00:51:45 <exicer> lfairy: Er, osx
00:51:55 <lfairy> what's the file?
00:52:16 <exicer> lfairy: A text file from a site taht I have downloaded
00:52:50 <exicer> So why does show "work", but sinkFile doesn't ?
00:52:55 <Cale> exicer: What package is that in? Are you using an old version of conduit?
00:53:00 <lfairy> give us more detail man
00:53:04 <johnw> how does it "not work"?
00:53:16 <lfairy> like, the actual file would help a bit
00:53:27 <exicer> johnw: Well work in the sense that I want to see the text as I see when I open the file in my text editor
00:53:32 <exicer> lfairy: One sec, I'll find the link
00:53:43 <johnw> is the encoding all screwed up?
00:53:53 <exicer> ftp://ftp.ensembl.org/pub/release-75/regulation/mus_musculus/
00:53:54 <exicer> any of them
00:54:12 <johnw> paste code please
00:54:14 <exicer> johnw: Yes, it looks like it to me
00:54:17 <exicer> johnw: One sec
00:54:48 <Cale> exicer: You realise those are gzip compressed files
00:55:06 <Cale> Are you reading the .gz files and then writing them to a file without a .gz extension?
00:55:18 <Cale> Some text editors will automatically decompress .gz files
00:55:27 <exicer> Cale: I'm using the conduit ungzip file
00:55:33 <exicer> er not file, function
00:55:42 <shachaf> Not consistent with "If I read a file as a bytestring, and then show it, I can see what the characters are correctly."
00:55:55 <exicer> shachaf: I have also tested vs downloading and unzipping the file
00:56:01 <exicer> http://lpaste.net/105519
00:56:06 <Cale> Yeah, at first I was thinking he was using Data.ByteString.readFile/writeFile
00:56:08 <shachaf> Oh, well, that's a lot of things not stated in the original question. I don't know anything about conduit so I'll stop saying anything.
00:56:34 <Cale> Maybe you should try just using plain Data.ByteString and skip the conduit nonsense for now :)
00:57:00 <exicer> Cale: The problem is there are other files that I will need to process that are several Gb in size
00:57:05 <johnw> i'm going to guess the problem is in regRegionFilter
00:57:18 <johnw> you didn't paste regRegionParser', so I can't say further
00:57:26 <exicer> johnw: Just a sec.
00:57:50 <exicer> http://lpaste.net/105520
00:58:22 <Cale> wtf is ∅
00:58:34 <exicer> Oh, ()
00:58:46 <Cale> ∅ is a terrible symbol to use for ()
00:58:54 <Cale> That's like using 0 to mean 1 ;)
00:59:01 <exicer> Cale: Yeah I was messing around with some emacs thing :p
00:59:12 <exicer> Cale: I think I will switch it off
00:59:24 <Taneb> On the other hand, ∅ is not so bad for Void
00:59:43 <johnw> exicer: you're parsing the text using ByteString.Char8, which is almost always the wrong thing to do
00:59:44 <Cale> Taneb: yeah
00:59:47 <wz1000> () is a bit like void
01:00:02 <Cale> wz1000: It has one more value than Void does
01:00:04 <Taneb> wz1000, yes, in the sense that 0 is a bit like 1
01:00:21 <johnw> the Char8 modules should really end in .Unwise or something
01:00:25 <Taneb> Or that the start of a line is bit like the end of it
01:00:28 <Zekka> It's a bit more like Just Void.
01:00:31 <Zekka> er, Maybe Void*
01:00:39 <exicer> johnw: Oh ?
01:00:45 <Cale> Void is a type with no (defined) inhabitants, () is a type with a single defined inhabitant
01:00:46 <ion> { Maybe Void* a; }
01:01:00 <wz1000> well, its the closest you can get to nothing in haskell
01:01:08 <Cale> data Void;
01:01:09 <Taneb> exicer, it is not recommended to use ByteString to represent Text
01:01:10 <johnw> exicer: for example, a UTF-8 codepoint that requires 2 bytes will be read by your parser as two characters
01:01:12 <ion> wz1000: Void is, yes
01:01:17 <Zekka> Not really, if you want to you can define a type with no inhabitants just as Cale did
01:01:33 <johnw> so something you think is \n may actually be the second byte of a codepoint
01:01:36 <Zekka> I think that () is a lot like Nothing if we're going with the Maybe Void comparison
01:01:50 <wz1000> but you cant have anything that will evaluate to Void
01:01:50 <Zekka> but I don't think that's what wz is saying
01:01:52 <exicer> johnw: Huh.
01:02:05 <johnw> I recommend Data.Attoparsec.Text
01:02:14 <Zekka> wz1000: You can have plenty of things that evaluate to (), though, although they're not always very interesting
01:02:22 <johnw> then in your conduit code, you must decodeUtf8 on read, and encodeUtf8 on write
01:02:25 <exicer> johnw: Okay. Why is it that I can liftIO $ print whatever at the end of my conduit line, and it displays as I would naievly expect ?
01:02:31 <johnw> and it will throw a nice exception if your text fails to decode
01:02:47 <johnw> because the show instance for ByteString is really just for debugging purposes
01:02:52 <jle`> bro do you even liftIO
01:03:00 <johnw> it's dump raw bytes, and your terminal is decoding them
01:03:04 <johnw> dumping*
01:03:06 <exicer> johnw: Ohhh
01:03:30 <exicer> I think I really am confusd with text encoding - does anyone have any suggestions of things to read on the topic ?
01:03:44 <johnw> as long as all you do is read/print, you can ignore decoding; but if you need to interpret/modify/parse the data in any way, you have to care
01:04:06 <johnw> exicer: http://www.joelonsoftware.com/articles/Unicode.html
01:04:43 <johnw> truly global software is a nearly unachievable chimera
01:05:16 <johnw> thank goodness we at least all agree on a 24 hour day; or do some countries have different notions of leap seconds too?
01:05:19 <exicer> Is there a way to determine, just from looking at some text, what it's encoding is ?
01:05:42 <johnw> exicer: sometimes, but it may require reading megabytes of data
01:05:57 <wz1000> Zekka: yes, thats my point. In C, you can have things that evaluate to void, so to simulate void in haskell, you need something that can be evaluated to, like () or in some cases Nothing. I would argue that the Void that Cale defined is not in the spirit of the C void
01:06:45 <Zekka> wz1000: If I understand you, then I'd agree and point out that they're not really designed to do the same
01:07:02 <dottedmag> johnw: Actually 2/3/4 bytes of UTF-8-encoded characters have 8th bit set, so one can rely on comparison with ASCII characters to be correct.
01:07:12 <Zekka> a C void is allowed to return -- a Haskell _ -> Void is not
01:07:18 <johnw> perhaps C's void is more like "forall a. a", as in, a value without a specific type?
01:07:19 <ion> exicer: You can make guesses based on statistics. And you’ll be wrong part of the time.
01:07:27 <exicer> ion: Heh, fair enough.
01:08:00 * hackagebot cabal2nix 1.63 - Convert Cabal files into Nix build instructions  http://hackage.haskell.org/package/cabal2nix-1.63 (PeterSimons)
01:08:44 <ion> exicer: Your web browser probably has a menu item called Encoding → Auto Detect. It will try to make a guess based on statistics.
01:09:58 <dottedmag> exicer: Some guesses will be stronger than others (UTF-8/UTF-16-encoded text have quite a specific structure, but 8-bit encodings detection is quite unreliable (unless one supplies more information, such as language expected))
01:11:01 <exicer> Hm. Okay.
01:11:18 <exicer> So I have also seen that utf16 has be and le encodings - why does uft8 not ?
01:11:28 <ion> To distinguish, say, ISO 8859-1 from ISO 8859-15 your statistical model will likely need to know that the author of the document is more likely to use € than ¤. But how about if the document is in fact related to ¤?
01:11:46 <dottedmag> exicer: Because UTF-16 is structured in two-byte chunks, and UTF-8 is byte-per-byte encoding
01:12:42 <exicer> dottedmag: Forgive my ignorance, I thought endianness was at a sub-byte level  ?
01:13:06 <ion> It doesn’t tend to be.
01:13:08 <dottedmag> exicer: Most often it is on byte level. For UTF-16 endianness is "which byte comes first".
01:13:28 <exicer> Right, good to know
01:13:36 <dottedmag> So, is the element s[0]*256 + s[1] or s[0] + s[1]*256.
01:13:41 <exicer> I feel like these kind of things are a good reason to learn C :s
01:13:50 <exicer> I really have no idea at the lowest level what is going on
01:14:25 <dottedmag> exicer: Joel's article is a very good overview
01:14:38 <exicer> dottedmag: I'm going to give it a read after converting this to Text, to see if it works :P
01:14:43 <flux> when going sub-byte endianess level you're writing in hardware description language or possibly a driver that needs to serialize/deserialize to/from bits
01:15:21 <exicer> What is the best way to convert Int -> Text ? I'm guessing Show is frowned on ? :P
01:17:31 <wz1000> I was going through my vim conceal config and i found ⁂ as a replacement for *** . What is ***? I can find no trace of it defined anywhere
01:17:47 <Zekka> wz1000: I think it's in Arrow
01:18:00 <Cale> :t (***)
01:18:01 <lambdabot> Arrow a => a b c -> a b' c' -> a (b, b') (c, c')
01:18:03 * hackagebot liblastfm 0.4.0.0 - Lastfm API interface  http://hackage.haskell.org/package/liblastfm-0.4.0.0 (MatveyAksenov)
01:19:04 <wz1000> hoogle gives a syntax error when fed ***
01:19:16 <Zekka> wz1000: You have to surround it with parens because it's an operator
01:19:20 <Zekka> try (***)
01:19:34 <wz1000> hoogle (***)
01:19:34 <wz1000> bash: syntax error near unexpected token `***'
01:20:54 <johnw> hoogle '(***)'
01:21:57 <ion> bash is the one that gave the syntax error, not hoogle.
01:22:13 <wz1000> thanks, got it
01:22:44 <johnw> exicer: for Int -> Text, pack . show is reasonable
01:23:36 <ion> @type Data.Text.singleton . chr
01:23:37 <lambdabot> Int -> Data.Text.Internal.Text
01:24:27 <lukku> hi guys ! I want to learn haskell , and i've started reading the learn you a haskell book . I have quite an experience with other programming languages, but i can't get my head around one thing  : When you declare a comprehension like this , does it actually mean you are declaring it recursively? removeNonUppercase st = [ c | c <- st, c `elem` ['A'..'Z']]
01:24:59 <lukku> st is the variable , but it also appears in the definition.
01:25:00 <shachaf> That doesn't look like a recursive definition. removeNonUppercase isn't referring to itself.
01:25:01 <exicer> johnw: Fair enough, that is what I have used!
01:25:09 <lukku> well the st
01:25:10 <shachaf> Oh. No, it's just an argument to the function.
01:25:23 <shachaf> "f x = x + 1" -- x is just an argument.
01:25:56 <ion> “f x = f (x+1)” is recursive, f recurses to itself.
01:26:06 <lukku> i see
01:26:35 <ion> “z = 0 : z” is also recursive but not a function like f
01:26:41 <lukku> i am just beginning to study haskell , so that's why my questions are not the brightest :)
01:26:56 <lukku> thanks
01:28:42 <lukku> so basically functionName variable = [ anyX
01:29:15 <wz1000> variables
01:29:15 <lukku> sorry , i will rewrite
01:29:44 <wz1000> add3 a b c = a + b + c
01:31:07 <lukku> so basically functionName variable = [ allX | allX <- variable , c property1, c property2. etc]
01:31:37 <lukku> where variable is used to evaluate allX
01:32:05 <ion> The name “allX” might be misleading. It only refers to one of the items in the list at a time.
01:32:15 <lukku> yes
01:32:58 <lukku> someX
01:33:02 <ion> > [ x | x <- [0..10] ]
01:33:04 <lambdabot>  [0,1,2,3,4,5,6,7,8,9,10]
01:33:08 <ion> > [ x | x <- [0..10], even x ]
01:33:10 <lambdabot>  [0,2,4,6,8,10]
01:33:18 <ion> Feel free to play with it in ghci.
01:33:38 <ion> > filter (\x -> even x) [0..10]
01:33:40 <lambdabot>  [0,2,4,6,8,10]
01:34:34 <Zekka> > filter even [0..10]
01:34:36 <lambdabot>  [0,2,4,6,8,10]
01:34:45 <Zekka> (I can't resist the urge to eta-reduce)
01:34:49 <lukku> well i get that , but the syntax variable = [x | x <- variable , condition1, condition2] is different
01:35:17 <wz1000> do you come from a python background?
01:35:31 <lukku> no , java/js/php
01:35:42 <lukku> csharp
01:35:55 <wz1000> what about coffeescript?
01:36:02 <dottedmag> lukku: you can't split function name and arguments, so it's not variable = ..., but function variable = ....
01:36:21 <lukku> no coffescript
01:36:40 <dottedmag> lukku: instead of passing literal [0..10] you are passing argument, variable. That's the only change.
01:38:10 <wz1000> basically what it says is construct a list with x, where x is every element from  a list(the variable),  and x satisfies some conditions
01:38:26 <lukku> dottedmag: so the variable is actually the parameter used to call the function
01:38:28 <lukku> ?
01:38:39 <wz1000> yes
01:38:48 <dottedmag> lukku: Yes. It's removeNonUppercase(st) in C-like syntax
01:39:05 <lukku> ok , i totally get it .. it wasn't hard at all
01:39:12 <lukku> thanks
01:39:14 <dmj``> lukku: C# = Enumerable.Range(0,10).Where(x => x % 2 == 0).. haskell = [ x | x <- [0..10], even x ]
01:39:50 <wz1000> > [x+y | x <- [1..10], y <-[1..3]]
01:39:52 <lambdabot>  [2,3,4,3,4,5,4,5,6,5,6,7,6,7,8,7,8,9,8,9,10,9,10,11,10,11,12,11,12,13]
01:40:14 <dmj``> lukku: have you gotten to monads yet
01:40:35 <lukku> no dude , i am still on the first chapter of the book :D
01:40:43 <wz1000> monads come a quite bit later in LYAH
01:41:45 <lukku> but i'm getting there, haskell seems very different from evrything else
01:42:10 <dottedmag> lukku: Its syntax is not Algol- or C-based, that's for sure.
01:42:45 <tdammers> lukku: not everything else, but most likely everything you know
01:43:08 <taktoa> lukku: probably the closest non-haskell language to haskell is ML, but even then it's tenuous
01:43:34 <tdammers> the syntax is the least of your concerns though
01:44:19 <tdammers> the part that can really hurt your brain is the combination of a powerful type system, relentless purity, and defaulting to non-strict evaluation
01:44:27 <wz1000> the syntax is slightly reminiscent of lisp
01:44:30 <dmj``> lukku: when you see how list comps are syntactic sugar for the list monad your mind will be blown
01:45:00 <tdammers> wz1000: *very* slightly :P
01:45:05 <Zekka> Short version: monads are types that follow a couple specific rules, and lists can also follow those rules.
01:45:22 <Zekka> And when you see how they follow those rules it's very easy to see how list comprehensions are a case of them
01:46:21 <tdammers> Zekka: the "mind blown" part comes from building an intuition for list comprehensions based on lists, and then suddenly realizing how you can look at it from the other side, where you approach comprehensions from the monad side, and lists are just one possible implementation
01:46:55 <Zekka> tdammers: I didn't really get that "mind blown" moment from monads, but maybe that's because I already got it from functors
01:47:20 <wz1000> tdammers: Well, it feels like it was designed by someone who was inspired by lisp but absolutely hated parenthesis
01:47:25 <dottedmag> tdammers: People coming from Python are already familiar with set comprehensions and map comprehensions though.
01:48:35 <wz1000> in python, a list comprehension is basically syntactic sugar for map.
01:48:39 <asante> wz1000: that sounds reasonably
01:48:41 <asante> :)
01:48:51 <Zekka> wz1000: Not true -- you get guards too if I'm not mistaken
01:49:17 <dottedmag> Zekka: Right.
01:49:24 <dottedmag> One can also produce a generator, not a full list.
01:49:51 <Zekka> an example of a list comprehension in Python doing everything at once: [x + y for x in [1, 2, 3] for y in [3, 4, 5] if (x + y) % 2 == 0]
01:49:56 <wz1000> yeah, but you cant draw from more than one list without using a nested comprehension if i remember correctly
01:50:10 <dottedmag> wz1000: ^^ :)
01:50:12 <Zekka> if there's anything else list comprehensions can do in Python I'd like to hear about it
01:50:36 <dottedmag> Zekka: (x + y for ... ) will return a generator
01:50:40 <dottedmag> That's basically it.
01:50:42 <Zekka> dottedmag: Yeah, I'm aware
01:50:49 <Zekka> you can also do set and dict comprehensions
01:52:23 <tdammers> dottedmag: yeah, but set and dict comprehensions are pretty much the same concept - iterating over a collection
01:52:46 <tdammers> dottedmag: monad comprehensions can be used on *any* monad - State, List, Maybe, Either, IO, you name it
01:53:09 <Zekka> tdammers: Pretty sure you can't use the comprehension syntax itself for every monad in the current version, although you can obviously use the do-notation
01:53:21 <Zekka> (which is more powerful anyway if I'm not mistaken)
01:53:44 <ion> There’s MonadComprehensions.
01:53:45 <dottedmag> tdammers: do comprehensions in Haskell desugar into monadic code?
01:53:50 <dottedmag> Ah, I see. Extension.
01:53:55 <Zekka> ion: Really? There's an extension for that?
01:54:00 <dottedmag> Zekka: https://ghc.haskell.org/trac/ghc/wiki/MonadComprehensions
01:54:15 <Zekka> dottedmag: From what I'm told they all desugar into monadic code but you're not allowed to use comprehensions for monads other than list by default
01:54:25 <tdammers> yep, -XMonadComprehensions is what I was hinting at
01:54:50 <tdammers> by default, comprehensions only work on lists, but MonadComprehensions generalizes them to arbitrary monads
01:54:56 <tdammers> because why not
01:55:05 <ion> λ> [ length l | l <- readFile "/proc/meminfo" ]
01:55:06 <ion> 1198
01:55:27 <Zekka> Just to be clear, there's no guarantee ghc will actually desugar them to do notation as far as I know
01:55:45 <Zekka> they just obviously correspond it into a straightforward way
01:55:54 <Zekka> GHC can do whatever it wants so long as the semantics remain the same
01:56:02 <frerich> I think it's quite interesting how list comprehensions seem to be a lot less common in Haskell than in Pthon though. Maybe due to the lack of lamda functions in Python (it only has lambda expressions AFAIK)?
01:56:05 <Zekka> er, s/do notation/monadic code
01:56:22 <Zekka> frerich: Usually I find an expression using map or filter is much shorter, personally
01:56:46 <tdammers> comprehensions feel somewhat imperative to me
01:56:54 <Zekka> As far as I know Python's lambdas are about as capable as the expressions you can write in the body of a list comprehension
01:57:00 <Zekka> I have a feeling it's a mix of how "lambda:
01:57:00 <asante> think the "problem" with python list comprehension is, that they are faster than maps in python?
01:57:15 <tdammers> asante: are they?
01:57:19 <Zekka> " is really long, even if the full list comprehension syntax is longer, and that Python programmers are used to foreaching
01:57:21 <tdammers> asante: even in p3?
01:57:52 <asante> tdammers: i guess so, because the python dev doesnt like fp
01:57:52 <ion> List comprehensions are convenient in something like [ x | SomeConstructor x <- xs ] where you want to filter by pattern matching.
01:58:19 <tdammers> ion: yes, that's the most common use case for me
01:58:22 <ion> (compared to map+filter)
01:58:27 <Zekka> I feel often like when I write a list comprehension there's a lot of redundancy
01:58:48 <Iceland_jack> @src catMaybes
01:58:48 <lambdabot> catMaybes ls = [x | Just x <- ls]
01:58:58 <Zekka> [doSomethingToX x | x <- list, conditionOnX x] seems really needlessly repetitive to me
01:59:19 <Zekka> compared to map dosomethingToX . filter conditionOnX $ list
01:59:23 <tdammers> Zekka: yes, but if you can use pattern matching instead of conditions, comprehensions are quite nice
01:59:40 <tdammers> [ doSomethingToX | SomeSumTypeConstructor x <- list ]
01:59:42 <Zekka> tdammers: I think ion's usecase is very good
01:59:43 <tdammers> eh
01:59:47 <tdammers> [ doSomethingToX x | SomeSumTypeConstructor x <- list ]
01:59:48 <frerich> Zekka: In that example, the list comprehension is shorter though ;-)
01:59:50 <Zekka> I'm just trying to speak in general about why I don't use them
01:59:57 <tdammers> right
01:59:59 <tdammers> yes, agree
02:00:13 <tdammers> I generally prefer map + filter, ideally point-free
02:00:21 <Zekka> It's also a matter that when you're using map/filter you're dealing with ordinary functions where you know how they work
02:00:26 <Zekka> list comprehensions are weird and syntactic
02:00:36 <tdammers> that too
02:00:37 <Zekka> obviously they're perfectly comprehensible but they aren't functions
02:00:46 <tdammers> but then, they're a nice way of getting pattern matching for free
02:01:18 <tdammers> useful for taming Maybes and such
02:01:42 <frerich> Of course, there's "catMaybes" for that case.
02:01:48 <chrisdone> [ x | Just x <- [a] ]
02:01:50 <chrisdone> i use this a lot
02:02:30 <Zekka> I often find myself using sequence for cases like that
02:02:40 <Zekka> generally the one in Data.Traversable
02:02:42 <chrisdone> it's normally to match other syntax
02:02:48 <Zekka> Obviously in that specific case it works slightly differently
02:03:11 <Zekka> I don't really like pattern matching very much if I can at all help it
02:03:26 <chrisdone> concat [[ Foo bar ]
02:03:26 <chrisdone>        ,[ Bob x | Just x <- […]]
02:03:26 <chrisdone>        ,[ Zot la la ]]
02:03:31 <chrisdone> looks more pretty than the alternatives
02:08:49 <AshyIsMe> oh wow i didnt realise you could do that with list comprehensions
02:08:55 <AshyIsMe> @src catMaybes
02:08:55 <lambdabot> catMaybes ls = [x | Just x <- ls]
02:11:31 <wz1000> is f x y = something syntactic sugar for f = (\x y -> something)
02:11:47 <dagle> It's much nicer than doing: map fromJust . filter isJust
02:12:01 <user> is there possibility to jump in the  source code to a function?
02:12:09 <Zekka> wz1000: The second one has slightly different semantics, but for the most part, yes.
02:12:22 <user> http://hackage.haskell.org/package/http-conduit-2.1.2.1/docs/src/Network-HTTP-Conduit.html#simpleHttp
02:12:31 <Zekka> wz1000: HEre's the difference: http://www.haskell.org/haskellwiki/Monomorphism_restriction
02:13:10 * hackagebot io-memoize 1.1.0.0 - Memoize IO actions  http://hackage.haskell.org/package/io-memoize-1.1.0.0 (DanBurton)
02:13:34 <lfairy> wz1000: They're equivalent as long as you supply type signatures, which you should always do
02:14:07 <user> *** Exception: FailedConnectionException2 "www.cnn.com" 80 False getAddrInfo: does not exist (error 10093)
02:14:08 <dagle> user: Could you try to formulate that differently?
02:14:26 <Zekka> user: Are you on Windows and are you using withSocketsDo?
02:15:03 <user> I am on windows, I am new to haskell and dont know how to use withSocketsDo
02:15:06 <wz1000> user: do you mean jumping to the definition of a function?
02:15:14 <user> wz1000: yes
02:15:29 <Zekka> user: OK. Basically, on Windows Haskell is stupid and requires you to call an extra function before doing anything with sockets
02:15:53 <Zekka> Your main function probably looks something like main = do {- complicated stuff -}, right?
02:16:27 <user> Zekka... I just inserted to WinGHCi Prelude Network.HTTP.Conduit> simpleHttp "http://www.cnn.com"
02:16:27 <user>  
02:16:32 <Zekka> user
02:16:35 <Zekka> er, oops
02:16:44 <wz1000> user: what editor are you using?
02:16:54 <Zekka> user: Try entering "withSocketsDo $ return ()" and doing the same again
02:17:24 <user> wz1000: emacs... but I browsed the source in web browser
02:17:42 <Zekka> import Network.Socket first (type "import Network.Socket")
02:18:45 <wz1000> use this https://github.com/haskell/haskell-mode/wiki
02:19:07 <user> thanks... now it worked
02:19:26 <user> (Zekka)
02:19:55 <Zekka> user: Yeah. It's really stupid, sorry about that
02:20:04 <Zekka> that one bit me a while ago
02:22:09 * chrisdone adds Zekka to his list of emacs users
02:23:03 <wz1000> What are you going to do with that list?
02:23:28 <chrisdone> gonna find out who's naughty and nice
02:23:28 <dagle> Take over the world?
02:23:46 <chrisdone> dagle: same thing we do every night?
02:23:59 <dagle> Okay boss!
02:24:10 <frerich> wz1000: Regarding the 'syntactic sugar' question - of course '\x y -> something' is really '\x -> \y -> something', so 'f x y = something' is actually syntactic sugar for 'f = \x -> \y -> something'
02:25:30 <wz1000> Is there any intermediate representation haskell code is parsed to before compiling? If yes, how do I see it?
02:26:28 <shachaf> There are lots of intermediate representations GHC uses. Core is one of them.
02:26:48 <Cale> -ddump-ds?
02:26:52 <chrisdone> it depends where 'compiling' starts for you
02:26:54 <shachaf> Look in the GHC user's guide -- there're a bunch of -ddump-... flags to look at all of them.
02:27:23 <frerich> wz1000: the 'Compiling Haskell Code' section of http://www.aosabook.org/en/ghc.html has a nice overview.
02:27:38 <frerich> though I don't know how up to date that is, IIRC I bought the book quite some time ago...
02:27:53 <wz1000> ok, thanks
02:27:59 <knappador> How do I activate a sandbox's bin directory?
02:28:22 <chrisdone> http://www.haskell.org/haskellwiki/GHC/As_a_library#Another_example
02:28:46 <knappador> ran cabal-install in sandbox.  have binary.  want way to use sandbox binaries conveniently
02:28:56 <chrisdone> this invocation of the ghc api lets you print out the parsed tree, desugared tree and core
02:29:50 <wz1000> wow, implementing a haskell compiler would take a huge amount of time
02:30:37 <Tene> knappador: just... run it?
02:30:42 <user> this page have funny example, lol : http://hackage.haskell.org/package/shpider
02:30:50 <knappador> script time
02:30:52 <knappador> hahahaa
02:31:06 <knappador> typing paths is against the lawww
02:31:42 <Tene> only untyped paths are permitted!
02:32:42 <knappador> someone has already fixed this somewhwere
02:33:00 <Tene> I'm curious what your actual problem is.
02:33:59 <hexagoxel_> knappador: you want the binary directory in $PATH, maybe?
02:34:31 <knappador> hexagoxel_: yeah, and whatever other environment setup needs done to make the sandbox "just work"
02:35:04 <hexagoxel> i can't think of any other setup necessary..
02:35:32 <knappador> if it's just bin, I can script it in no time
02:36:07 <Cale> wz1000: I think that depends on how good of a Haskell compiler you want it to be. :)
02:36:32 <hexagoxel> knappador: if you want to install a set of appplications using sandboxes, i have a script for that
02:37:17 <knappador> hexagoxel:  I just like to cd into a sandbox and automagicaly set the $PATH
02:37:22 <knappador> as far as unsetting....
02:38:11 <wz1000> Cale: well, you can knock out a decent scheme compiler in a couple of hours. compared to that haskell is a huge language
02:38:29 <chrisdone> the type system is the hardest part
02:38:53 <chrisdone> haskell's Core language is very small and simple
02:39:04 <hexagoxel> knappador: that sounds weird, i would not recommend changing $PATH whenever you move cd
02:39:08 <chrisdone> well, GHC's. but most haskell compilers have a core language
02:39:21 <Tene> knappador: What other environment would be necessary? o_O
02:39:54 <chrisdone> a haskell interpreter in haskell is easy, you get laziness for free =p
02:39:55 <hexagoxel> knappador: maybe "cabal install --bindir .." helps
02:40:05 <knappador> what is that?
02:41:04 <hexagoxel> "installation directory for executables"
02:41:06 <Tene> knappador: If you really want to do something every time you enter a directory, just set your PROMPT_COMMAND to a function that checks for cabal sandboxes and does that
02:42:13 <knappador> anyone know a quick way to modify path but only if the path doesn't include what i'm about to add?
02:48:42 <dottedmag> knappador: PATH?
02:49:03 <dottedmag> knappador: on unix-like os?
02:50:03 <knappador> dottedmag: yep
02:50:31 <dottedmag> knappador: Nothing shorter than echo $PATH | egrep -q '(^|:)/usr/sbin2(:|$)' || export PATH=$PATH:/usr/sbin2 comes to a mind
02:50:42 <dottedmag> With /usr/sbin2 replaced with needed path
02:51:46 <knappador> hehe, well, while you're here, is there a way to remove the path later?
02:51:59 <knappador> be sure to provide your gittip address lol
02:52:47 <dottedmag> That will be a little bit harder -- one need to remove single :
02:54:06 <frerich> knappador: Our of curosity, if appending the path to the PATH variable is acceptable, why does it matter if the path is already in there? Cleanliness?
02:54:21 <knappador> frerich: yes, and removing the path later
02:54:32 <knappador> so I don't have to re-source the shell over and over
02:54:47 <frerich> knappador: You could memorize the old value of PATH in a separate variable, I guess?
02:55:15 <dottedmag> knappador: Ugly: echo a:xxx:c | tr ':' '\n' | grep -v xxx | tr '\n' ':' | sed -e 's/:$//'
02:55:18 <Tene> knappador: PATH=$(echo $PATH|sed "s#:/path/too/foo##")
02:55:28 <dottedmag> Tene: only works if this path is not at the beginning
02:55:40 <frerich> Like 'export orig_path=$PATH; export PATH=$PATH:/mydir;' and later 'export PATH=$orig_path'?
02:55:41 <Tene> Yes, and it's a value he'll be appending to the end
02:55:47 <knappador> I like bash soo much
02:55:51 <Tene> So, works for that specific use case.
02:56:13 <dottedmag> knappador: there's niftier way: PATH=(...) $SHELL
02:56:29 <dottedmag> knappador: So exiting this shell will give you old PATH back
02:56:36 <knappador> dottedmag:  SUITE!
02:56:38 <knappador> there we go
02:58:02 <dottedmag> Adding something to PS1 for indication "we are in this mode" is a usual trick as well.
03:01:25 <knappador> dottedmag: are the paranthesis needed in your example?
03:01:55 <dottedmag> knappador: nope, it's a meta
03:02:10 <dottedmag> knappador: PATH=$PATH:newpath $SHELL should be sufficient.
03:02:25 <knappador> dottedmag:   I need to set the path in the new shell after .bashrc runs
03:02:37 <knappador> else I'll get my local haskell paths at the end
03:03:11 <dottedmag> knappador: --norc
03:03:19 <dottedmag> bash-specific though :(
03:03:26 <knappador> yeah i don't care haha
03:04:16 <knappador> actually I do...  I'll have to make RC read a variable to see if it needs to modify path at the end of rc
03:04:20 <knappador> sooooo hackish
03:05:10 <dottedmag> One could wish for plan9 rc to be a default shell
03:05:26 <dottedmag> With first-class lists instead of string variables
03:09:51 <jcullen> Hey all.  I'm having trouble with starting a cabal repl session inside a newly created project
03:10:01 <jcullen> it just says preprocessing library <Projectname>, and then quits
03:10:06 <jcullen> with no other message
03:10:09 <jcullen> anyone know why this might be?
03:10:17 <Maxdamantus> dottedmag: doesn't rc also just have lists of strings?
03:10:46 <yohyah> @help
03:10:46 <lambdabot> help <command>. Ask for help for <command>. Try 'list' for all commands
03:10:58 <Maxdamantus> bash just describes itself (and happens to be implemented) in terms of reduction of a command line string.
03:11:32 <Maxdamantus> foo=(a b c) # make array
03:11:46 <Maxdamantus> echo "${foo[0]}" # use easy indexing syntax
03:12:13 <dottedmag> Maxdamantus: that is right. But it is much better than sh
03:12:23 <dottedmag> Maxdamantus: And sh is not bash
03:13:06 <Maxdamantus> Oh, you mentioned the array construction syntax before.
03:13:15 <Maxdamantus> but $SHELL just accesses the first element of it.
03:13:27 <Maxdamantus> the entire array is "${SHELL[@]}"
03:13:49 <Maxdamantus> unless that's the rc, syntax, dunno.
03:13:49 <dottedmag> Maxdamantus: no, I hadn't, it was a lame attempt to use "meta" symbol
03:14:04 <dottedmag> I should have said =<SOMETHING YOU WANT TO PUT HERE> instead
03:16:21 <swain> take 5 [1..]
03:17:32 <knappador> suite.  done
03:18:46 <user> I read this page: http://hackage.haskell.org/package/shpider-0.2.1.1/docs/Network-Shpider-Forms.html and I see there this =: function and I want to jump to it... is there a way to jump to it?
03:18:49 <knappador> Maxdamantus: educating people about bash is like teaching people how to build whistling tips; it only makes the madness last longer
03:19:01 <Tene> whistling tips?
03:19:05 <user> "author" =: "Johnny"
03:19:26 <Tene> http://en.wikipedia.org/wiki/Whistle_tip ?
03:19:26 <user> there is the source button at the side, but it open a text file
03:19:31 <user> without hyperlinks
03:19:45 <knappador> https://www.youtube.com/watch?v=JZD-ADArwXo#start=0:00;end=1:07;cycles=-1;autoreplay=false;showoptions=false
03:19:47 <dottedmag> user: http://holumbus.fh-wedel.de/hayoo/hayoo.html#0:%3D%3A
03:19:53 <xenocons> it seems everyone always asks about monads, but not about categories
03:20:15 <Tene> user: notice that the description above it links to http://hackage.haskell.org/package/shpider-0.2.1.1/docs/Network-Shpider-Pairs.html#v:pairs with "pairs"
03:20:16 <vanila> categories aren't important to haskell
03:20:18 * xenocons hit the category wall tonight
03:20:28 <vanila> what wall?
03:20:29 <Tene> user: "It is convienent to use the pairs syntax here."
03:20:53 <xenocons> vanila: basically, i dont have enough knowledge about kleisli etc to understand type classing
03:21:33 <knappador> got the script working.  nice.  thanks dottedmag etc
03:21:35 <Maxdamantus> Reminds me of when I would ride over cans on my bike when I was younger, so the can would get trapped on the back of the wheel and make a motorbike sound.
03:21:38 <vanila> well kleisli is just a category of arrows of the form a -> m b I think
03:22:01 <edwardk> @remember dpwright this afternoon I've literally taken an entire (portrait) screen's worth of code and reduced it to about three lines and a few lens operators
03:22:01 <lambdabot> It is forever etched in my memory.
03:22:13 <xenocons> funny, was looking at an arrows imp. in another lang which is where i came accross kleisli and realised i know nothing
03:22:22 <user> Tene... ok but this problem is going to emerge again and again. I all the time see functions and want to see their definition
03:23:04 <Tene> user: usually you can just look it up on hoogle: http://www.haskell.org/hoogle/
03:23:17 * hackagebot language-puppet 0.14.0 - Tools to parse and evaluate the Puppet DSL.  http://hackage.haskell.org/package/language-puppet-0.14.0 (SimonMarechal)
03:24:17 <user> I did := no results found
03:24:59 <user> in other words you are saying that there is no source code that is hyperlinked
03:25:09 <luzie> user, https://hackage.haskell.org/package/shpider-0.2.1.1/docs/Network-Shpider-Pairs.html
03:26:27 <luzie> i don't know why it doesn't show up on hoogle
03:26:42 <dottedmag> user: Yes, this feature is lacking.
03:26:48 <user> ok
03:27:15 <dottedmag> user: But unlike other languages you can look at imports and then see those libraries for the contents.
03:30:40 <user> its much less convenient
03:31:00 <user> instead of one click at the function, I need to search all imports
03:31:18 <user> and I don't know any functions
03:31:20 <dottedmag> Sure it is.
03:31:26 <dottedmag> Yes, it is the real problem for learning.
03:32:23 <user> for example, now I want to figure out what: reverse . snd . flip runState [ ] does, instead of clicking on snd and runState I need to start searching them
03:32:58 <dottedmag> It sounds like a fun (or maybe not fun) task to improve Hackage.
03:33:24 <user> google code have something like that
03:33:35 <user> each function in the source is clickage
03:33:41 <user> clickable
03:38:29 <user> what these -> in runState mean? http://hackage.haskell.org/package/transformers-0.4.1.0/docs/src/Control-Monad-Trans-State-Lazy.html#runState
03:39:00 <srtw> @pl \xs n -> take n xs
03:39:00 <lambdabot> flip take
03:39:35 <user> is it part of the type of the function?
03:39:42 <user> or part of the function?
03:40:00 <user> oh
03:40:18 <user> the slplit x -> y -> z over several lines?
03:40:21 <Cale> yes
03:40:22 <dottedmag> yep
03:40:23 <Cale> that's all
03:40:29 <user> aha
03:40:37 <user> so confusing
03:40:42 <Cale> That allows for each parameter to be commented
03:41:03 <user> aha
03:41:14 <Cale> (Especially important because the documentation is being generated from the comments)
03:41:37 <srtw> @pl sum' xs = foldr (+) 0 xs
03:41:38 <lambdabot> sum' = foldr (+) 0
03:41:57 <user> aha
03:42:59 <srtw> @pl f (x:xs) 	| x > 0 = x : f xs
03:42:59 <lambdabot> (line 1, column 26):
03:42:59 <lambdabot> unexpected " "
03:42:59 <lambdabot> expecting operator
03:44:14 <srtw> @pl f (x:xs) = x : f xs
03:44:14 <lambdabot> f = fix ((`ap` tail) . (. head) . flip ((.) . (:)))
03:51:39 <srwt> @pl f x = filter (>0) x
03:51:40 <lambdabot> f = filter (> 0)
03:53:23 * hackagebot formatting 4.0 - Combinator-based type-safe formatting (like printf() or FORMAT)  http://hackage.haskell.org/package/formatting-4.0 (ChrisDone)
04:01:03 <simon> has anyone here read the book "
04:01:16 <simon> Haskell Financial Data Modeling and Predictive Analytics" by Pavel Ryzhov?
04:02:31 <r444> simon: i have it, haven't read it throughout though
04:03:08 <r444> simon: it's pretty fast and if you're in need of comprehensive guide, it's probably not for you IMO
04:04:09 <r444> so, it depends on your level of domain expretise
04:04:29 <r444> i don't have any and really feel the need of other domain knowledge source
04:04:40 <r444> hope this helps
04:07:38 <simon> r444, very much, thanks.
04:07:55 <simon> r444, I saw a less flattering reddit review, http://www.reddit.com/r/haskell/comments/1rj2jq/book_haskell_financial_data_modeling_and/
04:08:11 <simon> r444, and I have the impression that much of it is related to how he implemented HQuantLib.
04:09:45 <r444> simon: quite so, you have to be proficient in quantitative finance and haskell to get something useful from this book
04:09:46 <KorriX> Hi! Is there any way to alias value constructor? I'd like to have type Point2 = V2 (V2 is from linear package) and use syntax Point2 x y to construct points and pattern match on them
04:10:56 <simon> r444, it seems that I need to improve my understanding of quantitative finance elsewhere first, then.
04:11:54 <pavonia> KorriX: You can define constructor and destructor functions
04:12:58 <KorriX> pavonia: But I can't pattern match on them (I don't like -XViewPatterns)
04:13:34 <pavonia> Indeed, but there's no way around if the V2 constructors aren't exported
04:14:55 <KorriX> pavonia: Thanks
04:22:37 <pavonia> Doesn't Hackage list functions from re-exported modules in general or is it because of the qualification here? https://hackage.haskell.org/package/hquantlib-0.0.2.4/docs/QuantLib.html
04:25:44 <pavonia> It seems to be the qualification
04:28:31 * hackagebot force-layout 0.3.0.5 - Simple force-directed layout  http://hackage.haskell.org/package/force-layout-0.3.0.5 (BrentYorgey)
05:12:16 <haasn> > False <= undefined -- seems like the derived instance could be made lazier here
05:12:18 <lambdabot>  *Exception: Prelude.undefined
05:17:44 <hexagoxel> haasn: the report explicitly states that it does not make the instances lazy in that fashion, iirc
05:18:38 * hackagebot event-list 0.1.1.1 - Event lists with relative or absolute time stamps  http://hackage.haskell.org/package/event-list-0.1.1.1 (HenningThielemann)
05:18:53 <danilo2> Hello all! We are writing an interpreter in Haskell (something simmilar to ghci - we are using GHC API internally). We want to define a dataflow graph which cached results of functions. We want to know which cache should we recompute when user changes value of an input data. Does anybody has any suggestions how something like that could be implemented?
05:19:23 <danilo2> *with cached results
05:20:45 <cehteh> danilo2: i just stumbled upon 'hint' yesterday .. haskell interpreter, u know it?
05:22:44 <danilo2> cehteh: Thanks, yes I know the library - we were basing on the beginning on it, but our developers
05:24:19 <danilo2> cehteh: sorry - our developers needed some more functionality (like ability to define functions in interpreter), so we are using GHC API - anyway, even the library does not solve our ptroblem
05:24:36 <cehteh> ok
05:24:42 <luite> danilo2: start with STG, you'll want to cache/check StgApp results when you build the application. memoizing all application is usually not a win though
05:25:06 <danilo2> cehteh: I want to define the flow of a data - how the functions modyfying the data are connected together. I want to cache output of each function and when input data is changed, I want to know, which cache should I recompute
05:25:08 <cehteh> well i didnt used it, and i am new to haskell cant say much, but i am quite much interested into a seamless interpreter integration
05:25:32 <cehteh> should be doable since functions are pure
05:29:58 <danilo2> cehteh: How? If I use for example a function, which ocncatenates data to a tuple, another function which takes second element of a tuple and yet another elemennt- I want to know, that changing the first input, does not affect the last function
05:30:49 <benzrf> cehteh: seamless interpreter integration?
05:31:10 <cehteh> you know prolog? gprolog for example?
05:31:55 <cehteh> except for performance you dont notice much difference in things which are native compiled, bytecode interpreted or purely interpreted
05:33:15 <cehteh> currently i am hacking something in lua where some rules/engines can be extended dynamically, would be nice to make that in haskell someday, without recompliation or a big dependency on a full haskell toolchain
05:36:57 <luite> danilo2: how deep does it have to go? if you just want to track dependencies of each argument, then following the dependencies of the stg nodes should do ok, otherwise just caching function applications would be more feasible
05:40:35 <danilo2> luite: I'm going to look into STG right now. It sohuld not go into any depth - I want to cache results only on 1 "layer" of dataflow graph - because the user would work on this layer- he can define and add new functions and should see the resutls withoput recomputing previous computations - this is the only need for caching mechanism
05:40:55 <benzrf> danilo2: you could try quickchecking it
05:41:24 <Maior> is vector-space's AffineGroup typeclass actually like the mathematical concept of affine groups?
05:41:40 <Maior> (speaking as someone who likes and uses the former, but is struggling with https://en.wikipedia.org/wiki/Affine_group )
05:42:44 <danilo2> benzrf, luite: To be sure we are talking about the same - we've got data A and functions foo and bar, connected like this: A ---- foo --- bar . If I change A, I want foo and bar to be recomputed (assuming I need the results of bar). If I change a parameter to bar (another Variable - B) - then I want the results of foo be taken out of cache
05:43:15 <danilo2> benzrf: how quickchecking could help me here?
05:44:37 <KorriX> Can I have conditionally exported modules and conditional dependencies in Cabal?
05:47:06 <luite> danilo2: yes, caching function application would probably be the simplest way to get there, here you might want separate caches for everything the user manipulates.
05:49:33 <luite> danilo2: but it's a bit hard to say if it's a win. if your users know haskell they can be more clever, choosing the things they want shared themselves (and optionaly resort to memo tables through weak maps or something like memocombinators)
05:50:42 <danilo2> luite: the application assumes, user are processing images, applying filters with the functions - a long chain of filters can compute even several minutes, so caching results IS a big win here. Woudl you be so nice and tell me more about it? how can I use the stg here?
05:56:13 <luite> danilo2: can't you take it one level down, have some representation for a filter that you can inspect from haskell. then you're much more flexible in choosing how to run them
05:58:48 <luite> danilo2: are you using repa delayed arrays?
06:06:24 <danilo2_> luite: sorry, my internet connection went down. So yes, we are using repa and accelerate arrays - When uyser is working on one layer of dataflow graphs I want to cache all intermidiate computations
06:07:07 <danilo2_> So yes, I'm using repa delayed arrays and accelerate delayed computations
06:08:44 * hackagebot yesod-pnotify 0.4.4.1 - Yet another getMessage/setMessage using pnotify jquery plugins  http://hackage.haskell.org/package/yesod-pnotify-0.4.4.1 (KatsutoshiItoh)
06:08:55 <danilo2_> luite: But still I do not see how it could help - If I'm using delayed arrays - they are nto computed unless they need to - this is cool. But If they get computed, I want to cache the results - and cancel the cache if input changes - Maybe I just do not see the solution, which is clear to you ?
06:09:35 <ski> danilo2 : you may be interested in checking out "Adaptive Functional Programming" by Umut A. Acar,Guy E. Blelloch,Robert Harper in 2002 at <http://www.cs.cmu.edu/~blelloch/pubs.html#item503296> (also at <http://www.umut-acar.org/publications-by-venue>,<http://citeseerx.ist.psu.edu/viewdoc/summary?doi=10.1.1.1.2124>) (there's also a 2006 version, which i can't recall checking out)
06:10:52 <ski> danilo2_ : there's also a "Monads for Incremental Computing" by Magnus Carlsson in 2002 at <http://www.carlssonia.org/ogi/Adaptive/>, which is a Haskell version (using a monad). as of 2008, that is also on Hackage
06:11:33 <danilo2_> ski: Hmm, interesting. I'm looking right now into the documents!
06:11:51 <ski> danilo2_ : <http://stackoverflow.com/questions/20591629/automatically-recalculate-results> and <http://www.acooke.org/cute/AdaptiveCo0.html> might also be interesting
06:11:54 <danilo2_> ski: thank you
06:12:32 <ski> danilo2_ : note that this notion of adaptive/incremental computation doesn't handle your (non-)caching requirements (afaiui), but it should handle the recompute-what's-needed part, i think
06:12:50 <davnils> [Q] http-client has decided to go with "withManager :: ManagerSettings -> (Manager -> IO a) -> IO a", is there any way to integrate an existing monad trans stack into this? it seems to affect wreq as well, which is specialized to IO only... kinda sucks.
06:12:56 * ski nods to cehteh
06:13:06 <cehteh> hi ski
06:17:03 <danilo2_> ski: Ok, could you tell me additional (because it seems you know the stuff) - If you have any more concrete idea how this stuff could be implemented? Coudl you give me some hints before reading? Or I shoudl just read it and be back if the problems will not be solved?/
06:18:52 <deweyvm> would anyone happen to know what irc client generates the #haskell logs?
06:19:29 <tdammers> deweyvm: I suspect it's not a proper client at all, but a bot
06:20:39 <Faucelme> davnils: Perhaps using monad-control ?
06:23:25 <Faucelme> davnils:http://www.yesodweb.com/blog/2014/06/exceptions-transformers
06:24:22 <deweyvm> hmm yea, looks like it is custom
06:25:21 <ski> danilo2_ : i suppose when you explicitly set a new value for a node, you could want caches for "earlier" nodes to be deleted. afaicr, the adaptive implementation in those papers doesn't do something like that, though you could possibly try to incorporate that idea
06:27:32 <davnils> Faucelme: thanks. I will probably go with manual unwrapping in order to avoid this. too bad exceptions are such complex beasts (I love the either/maybe approach).
06:39:31 <sagittarian> exceptions are just misunderstood
06:39:34 <sagittarian> they mean well
06:40:13 <hcaulfield57> I'm looking at the mtl package. They have things like instance MonadState s (StateT s m) where ... In order to have arbritrary type variables like the 's' immediately after MonadState do you need FlexibleInstances?
06:42:22 <tdammers> MultiParamTypeClasses I think
06:43:19 <Philonous> Is there a convenient way to test IO actions with random inputs (like QuickCheck)?
06:43:21 <hcaulfield57> tdammers: No, not for the StateT s m part.
06:43:46 <hcaulfield57> The compiler asks for FlexibleInstances, but mtl seems to only use UndecidableInstances so I was wondering
06:43:57 <Philonous> I realize that there's QuickCheck tests for Monadic actions, but those don't work well if you need to set up and tear down an environment before/after the tests
06:46:09 <tdammers> Philonous: kind of defeats the purpose of pure functional programming in the first place :D
06:46:27 <geekosaur> hcaulfield57, if I had to guess, you don't have MultiParameterTypeClasses enabled?
06:47:17 <hcaulfield57> geekosaur: I do
06:47:46 <hcaulfield57> It compiles with MultiParam, FlexiableInstances, I just wondered
06:48:48 * hackagebot hspec-wai 0.1.0 - Experimental Hspec support for testing WAI applications (depends on hspec2!)  http://hackage.haskell.org/package/hspec-wai-0.1.0 (SimonHengel)
06:49:35 <bezirg> question: does cabal-install executable run the cabal user hooks inside Setup.(l)hs ?
06:53:20 <hcaulfield57> Well I have to go, maybe I'll ask back later.
07:09:09 <jamiehannaford> I have a function that returns Maybe a, and another that just accepts a. How can I pipe the result of the first into the second?
07:10:34 <deweyvm> jamiehannaford: f <$> mb
07:11:31 <deweyvm> f <$> (g x) where g :: b -> Maybe a, f :: a -> c
07:12:30 <jamiehannaford> says - Not in scope: `<$>'
07:12:42 <deweyvm> import Control.Applicative((<$>)) (its just fmap)
07:14:29 <dottedmag> jamiehannaford: mb >>= (return . f)
07:17:21 <jamiehannaford> I'm trying to do an exercise from yorgey's course - so I think I've gone wrong somewhere :/
07:22:42 <pjdelport> jamiehannaford: fmap / <$> will lift your function to Maybe, and keep its result in Maybe; if you want to get rid of the Maybe entirely, you have to unpack it with pattern-matching (or with an existing helper like fromMaybe)
07:22:47 <pjdelport> :t fromMaybe
07:22:48 <lambdabot> a -> Maybe a -> a
07:23:08 <albeit> Is there something like a "map sequence" so I can do "[m a] -> (a -> a -> a) -> m a". I want to sequence the computations, but instead of accumulating in a list, I want to combine them with a function
07:24:03 <deweyvm> albeit: foldM?
07:24:44 <albeit> deweyvm: Was looking at that, but the items I need to fold over are of type "m a"... they are already computations
07:25:01 <deweyvm> where are you getting the two a's from in a->a->a?
07:25:16 <deweyvm> how do you want to choose them
07:26:04 <albeit> Linearly form the list... so if "a1 -> a2 -> a", a1 would be the first "unwrapped" item in [m a], a2 would be an accumulator.
07:26:45 <deweyvm> and it returns a, not m a?
07:26:50 <albeit> Basically, I have a [Either a Text] that I want to convert to "Either a Text", by concatenating all the Texts...
07:27:30 <albeit> (Orreturning the first Left it finds)
07:27:32 <deweyvm> you could do [Either a b] -> ([a], [b]) and then treat the a's however you want
07:27:44 <deweyvm> and then concatenate the b's if the a's are empty
07:27:49 <deweyvm> i dont think there is a built in function for this
07:27:56 <deweyvm> i wanted to do something similar before
07:28:21 <deweyvm> http://holumbus.fh-wedel.de/hayoo/hayoo.html#0:[Either%20a%20b]%20-%3E%20%28[a]%2C[b]%29
07:28:49 <albeit> Yeah I've been bugging Hoogle a lot, can't find anythign relevant though
07:28:57 * hackagebot loops 0.1.0.1 - Fast imperative-style loops  http://hackage.haskell.org/package/loops-0.1.0.1 (ThomasTuegel)
07:29:09 <albeit> deweyvm: Actually that link didnt come up.. just redirect to main Hayoo page
07:29:20 <deweyvm> whoops
07:29:32 <deweyvm> well searching for [Either a b] -> ([a],[b]) comes up with a few people's solutions
07:30:01 <deweyvm> oh its in base :P
07:30:24 <deweyvm> weird, didnt find it back when i was looking
07:42:39 <pjdelport> :t foldr (liftM2 mappend) (return mempty)
07:42:40 <lambdabot> (Monoid a2, Monad m) => [m a2] -> m a2
07:42:49 <pjdelport> deweyvm: -^ ?
07:43:32 <deweyvm> albeit: ^ might do what you want
07:44:14 <albeit> Woah, looks good, gotta wrap my head around it, thanks!
07:45:40 <pjdelport> albeit: That's essentially the same as sequence, just with mappend and mempty replacing (:) and []
07:47:34 <pjdelport> If you don't want to be generic over monoids, it's just foldr (liftM2 append) (return empty) for Text only
07:48:14 <pjdelport> Also you don't actually need to limit it to monads:
07:48:18 <pjdelport> :t foldr (liftA2 mappend) (pure mempty)
07:48:19 <lambdabot> (Monoid b, Applicative f) => [f b] -> f b
07:48:30 <pyon> Just wondering... with HLists, is it possible to have a single zip function that subsumes zip, zip3, zip4, etc.?
07:48:53 <albeit> pjdelport: So that is essentially a customized generalized version of sequenceA?
07:49:41 <albeit> Very cool, thanks
07:50:13 <pjdelport> albeit: Strictly speaking, sequenceA would be a customized version of this, i think (for a particular choice of Monoid)
07:51:24 <yitz> @type fmap mconcat . sequence -- pjdelport, albeit
07:51:25 <lambdabot> (Monoid b, Functor f, Monad f) => [f b] -> f b
07:51:51 <pjdelport> That too
07:52:58 <yitz> pjdelport: so it isn't "essentially the same as sequence". it *is* sequence. you're just composing that with concatenation.
07:59:44 <dottedmag> pyon: How would it know a number of lists to zip?
07:59:53 <dottedmag> uhm, hlists
08:01:28 <pyon> dottedmag: Rather, it would be a HList of lists... or is this not possible? :-O
08:02:31 <toonces>  xmonad
08:02:42 <dottedmag> pyon: So basically re packing from hlist to a tuple? what for?
08:02:46 <dottedmag> *repacking
08:03:55 <dottedmag> uhm, or something like Hlist [a] -> HList ?
08:04:05 <dottedmag> Hlist -> [a] -> HList
08:05:02 <deweyvm> how would i convert an Int to a Fixed E12 ?
08:05:47 <pyon> dottedmag: On a second thought, I guess it cannot possibly work. At least, I have no idea how to enforce that all the elements of a HList are lists. :-|
08:10:16 <dottedmag> deweyvm: fromInteger 12 :: Fixed E12
08:10:29 <dottedmag> deweyvm: Fixed a is an instance of Num
08:10:38 <deweyvm> ahhh duh
08:10:40 <deweyvm> thanks :)
08:18:08 <schell> hi all
08:18:38 <benzrf> hell schell
08:18:39 <benzrf> *hello
08:18:48 <michaelt> hi schell
08:19:08 <schell> do you guys know if there is a way to catch failure in an arrow’s proc _ -> do?
08:20:22 <benzrf> schell: arrow's proc?
08:21:03 <schell> yeah, it’s like using `do` for monadic composition, but for arrows
08:21:05 <schell> http://www.haskell.org/arrows/syntax.html
08:22:09 <schell> oh - maybe my understanding is incorrect
08:22:14 <schell> maybe the don’t fail?
08:23:45 <schell> well - i’m using netwire and my goal is to create a wire that takes two wires, runs the first while the second inhibits and then switches to the second once it starts producing
08:24:54 <schell> anyway - i hope everyone’s having a good morning! (or afternoon or night) :)
08:30:57 <lordcirth> noob here, I want to use the "minus" function, which is in Data.List.Ordered, in ghci.  But I can't import Data.List.Ordered, and cabal can't find it either.  how do I get it?
08:32:09 <bergmark> lordcirth: it seems to be in the data-ordlist package, do you have that installed?
08:32:10 <mmachenry> lordcirth: cabal install data-ordlist
08:32:55 <mmachenry> lordcirth: Check out this page, the documentation you were probably reading http://hackage.haskell.org/package/data-ordlist-0.2/docs/Data-List-Ordered.html Notice the name in the very top left of the page. That's the cabal name for installing the package
08:33:30 <lordcirth> bergey, mmachenry oh thanks, I didn't see that
08:33:49 <mmachenry> lordcirth: Yeah, neither did I the first few times. ;)
08:44:06 * hackagebot rtlsdr 0.1.0.2 - Bindings to librtlsdr  http://hackage.haskell.org/package/rtlsdr-0.1.0.2 (adamwalker)
08:52:20 <exicer> Say I'm using attoparsec to parse a long string. I want to extract the sequence of Capitalised words the occur before "V.", and the sequence of Capitalised words the occur after it. I can do the after part, but how should one go about the before ?
08:54:05 <alpounet> exicer: you can use manyTill or manyTill'
08:55:08 <benzrf> till?
08:55:10 <benzrf> shouldnt it be til
08:55:28 <exicer> so if I had the string "blah blah blah James Anderson V. John blaublah blah", how might you do it ?
08:56:11 <exicer> I tried (manyTill (upperCaseWord <* (many space)) string "V.")
08:56:24 <exicer> it did not work :s
08:57:54 <gilligan_> I am trying to figure out a problem with cabal:  ``cabal: user error (You need to re-run the 'configure' command. The version of Cabal being used has changed (was Cabal-1.20.0.0, now Cabal-1.20.0.1). Additionally the compiler is different (was ghc-7.4, now ghc-7.8) which is probably the cause of the problem.)`` -- thing is I only have one cabal version installed. And also only ghc 7.8.2 on this system. So I really don't get this error
08:58:49 <bergmark> gilligan_: i had the exact same problem! travis?
08:58:49 <michaelt> gilligan_: the executable cabal-install you kept from the old arrangement?
08:59:05 <gilligan_> edwardk, hey - hope you were not utterly confused by the "Slovenia" reference in the twitter reply - in case you've seen it ;)
08:59:37 <bergmark> gilligan_: does this package have a test suite?
08:59:43 <gilligan_> bergmark, no i'm trying to use codex (https://github.com/aloiscochard/codex)
08:59:50 <edwardk> gilligan_: guessing we met up there when i was in ljubljana =)
09:00:09 <gilligan_> edwardk, haha..close but no
09:00:24 <edwardk> ok, now i'm confused =)
09:00:30 <gilligan_> edwardk, it was on the bus ride when the both of us clearly heard alex saying something about  Slovenia
09:00:39 <edwardk> ah yes!
09:00:47 <edwardk> ok, now i've internalized who you are =)
09:00:56 <gilligan_> edwardk, stupid detail, sorry. It just stuck to me for some reason because i found it so silly hehe
09:01:01 <syllogismos> query lambdabot
09:01:03 <bergmark> gilligan_: i had this problem on travis, and i managed to hack around it by doing `cabal configure --enable-tests; cabal install --only-dependencies; cabal test' rather than `cabal configure; cabal install; cabal test'
09:01:15 <edwardk> no worries. was searching farther afield for the line =)
09:01:23 <mdmkolbe> Is there a way to make the GHC specializer run a second time after inlining?
09:01:28 <gilligan_> bergmark, ah cool i'll try that then
09:02:02 <bergmark> gilligan_: i asked the cabal peoples about it and they had no idea what caused this, but kosmikus said he had the same problem at some point
09:02:16 <bergmark> so i've been trying to figure out some way to reproduce this
09:02:18 <gilligan_> bergmark, still really weird. I mean this is a freshly installed laptop that hasn't even seen anything else but ghc  7.8.2 and cabal 1.20.1
09:02:43 <bergmark> gilligan_: right, and i think travis only has one ghc installed by default too (but i'm not sure about this)
09:03:37 <bergmark> gilligan_: one thing you could try (wild guess) is to add a strict base dependency on the executable of codex
09:04:17 <bergmark> that's one thing it has in common with the cabal file of my project https://github.com/silkapp/json-schema/blob/master/json-schema.cabal
09:04:47 <eikke__> edwardk: is it normal Free has a Data instance (with constraints) in my GHC 7.6 env, but not in my 7.8 env?
09:05:57 <gilligan_> bergmark, does whoever organizes the haskellerz meetings hang out on irc ?
09:07:36 <bergmark> gilligan_: i have no idea
09:08:03 <bergmark> gilligan_: i'm checking if i can still reproduce it on travis: https://travis-ci.org/silkapp/json-schema/builds/27418453
09:08:41 <gilligan_> bergmark, cleaned up all sandbox stuff and trying again
09:09:09 <gilligan_> bergmark, if that won't work i'll try forcing the exact cabal version
09:11:49 <bergmark> come on travis :
09:14:20 <gilligan_> bergmark, hrm.. no dice
09:14:27 <bergmark> gilligan_: still the same problem?
09:14:42 <ReinH> edwardk: howdy stranger
09:15:35 <bergmark> i'll try to install codex too
09:17:11 <nyloxxx> ciaooo
09:17:35 <nyloxxx> !list
09:17:36 <monochrom> nyloxxx: http://lpaste.net
09:17:45 <rwbarton> monochrom++
09:18:32 <monochrom> actually should make it http://lpaste.net/browse
09:18:37 <rwbarton> yes
09:20:00 <bergmark> gilligan_: yep still reproducible on travis
09:20:09 <fuzzy_id> is there something short-hand for e.g. (\x y -> length x == length y)
09:20:14 <fuzzy_id> ?
09:20:26 <pjdelport> @pl (\x y -> length x == length y)
09:20:26 <lambdabot> (. length) . (==) . length
09:20:37 <fuzzy_id> oh :)
09:20:38 <jesyspa> (==) `on` length, I think it was.
09:20:54 <fuzzy_id> oh yeah, already heard of that
09:21:01 <fuzzy_id> :t on
09:21:02 <lambdabot> (b -> b -> c) -> (a -> b) -> a -> a -> c
09:21:18 <fuzzy_id> yeah, that's it
09:21:59 <gilligan_> bergmark, mind trying if you get codex to work or if its the same issue for you there ?
09:22:18 <fuzzy_id> :i on
09:22:28 <bergmark> gilligan_: i'm doing that! :_)
09:22:40 <bergmark> so many dependencies ;(
09:23:38 <bergmark> i'm trying out "never use the user package db", makes installs pretty time consuming
09:23:39 <gilligan_> bergmark, you do use sandboxes though?
09:23:44 <bergmark> gilligan_: yes
09:24:19 <gilligan_> bergmark, but yeah, quite some dependencies.. grabbing&compiling takes a bit
09:25:15 <gilligan_> bergmark, i patched some stuff with codex and everything worked fine on my old laptop which has ghc 7.6 installed. Once i tried on my new setup.. *fail*
09:25:42 <gilligan_> also alois (author of codex) seems to have disappeared
09:25:53 <gilligan_> haven't talked to him since zurihac
09:26:05 <gilligan_> not even responding to emails x_X
09:26:13 <bergmark> maybe he has a post hackathon vacation :-)
09:26:25 <gilligan_> hehe
09:26:45 <gilligan_> bergmark, did my first ever haskell pull request. I want him to bloody merge it in :)
09:26:55 <bergmark> :-)
09:28:05 <bergmark> gilligan_: it installed fine for me...
09:29:41 <gilligan_> bergmark, yeah but now actually /run/ it ;)
09:29:44 <gilligan_> codex update
09:29:48 <bergmark> ah
09:30:07 <gilligan_> bergmark, it's working for me now that i set the cabal version dependency to the one i have installed
09:30:29 <bergmark> how do i run it?
09:31:23 <bergmark> oh i did the right thigng but it's giving some weird probably related error
09:31:24 <gilligan_> bergmark, assuming you did a cabal install in your sandbox : ./cabal-sandbox/bin/codex update
09:31:36 <bergmark> codex: /Users/adam/Library/Haskell/repo-cache/hackage.haskell.org/00-index.tar: openBinaryFile: does not exist (No such file or directory)
09:31:52 <bergmark> i don't have a ~/Library/Haskell (but I did at some point)
09:32:22 <geekosaur> you need to fix or remove ~/.cabal/config which is using paths from a haskell platform package install
09:32:50 <bergmark> my cabal config doesn't mention Library
09:33:07 <geekosaur> hrm
09:33:35 <geekosaur> then it may be compiled into your cabal binary and you need to install one with your current paths instead of the official h-p package paths
09:33:50 <gilligan_> bergmark, uhm.. aren't those just files that hoogle creates as cache ?
09:34:07 <bergmark> my cabal binary is built from a sandbox
09:34:41 <rwbarton> maybe the paths are compiled into the Cabal library?
09:34:51 <rwbarton> actually that doesn't make much sense
09:35:13 <albeit> > 1 `mplus` 2
09:35:15 <lambdabot>  No instance for (GHC.Show.Show (m0 a0))
09:35:15 <lambdabot>    arising from a use of ‘M616182909243905702619448.show_M6161829092439057026...
09:35:15 <lambdabot>  The type variables ‘m0’, ‘a0’ are ambiguous
09:35:15 <lambdabot>  Note: there are several potential instances:
09:35:15 <lambdabot>    instance [safe] GHC.Show.Show a =>
09:35:19 <bergmark> i had a problem a couple of months ago where one sandbox referenced a Cabal from a completely different sandbox, it was super weird
09:35:26 <albeit> > (1 :: Int) `mplus` (2 : Int)
09:35:28 <lambdabot>  Not in scope: data constructor ‘Int’
09:35:28 <lambdabot>  Perhaps you meant one of these:
09:35:28 <lambdabot>    ‘In’ (imported from Lambdabot.Plugin.Haskell.Eval.Trusted),
09:35:28 <lambdabot>    ‘InR’ (imported from Lambdabot.Plugin.Haskell.Eval.Trusted)
09:35:35 <geekosaur> right but I would expect that path not to be in Cabal library
09:35:44 <geekosaur> since it's a cabal-install specific thing
09:36:13 <geekosaur> actually this makes me wonder if you have two copies of the cabal binary installed and are getting the wrong one
09:36:47 <albeit> How can I do something like "f (Right 1) (Right 2) = Right 3", "f (Left x) (Right 2) = Left x"?
09:36:48 <bergmark> i have two binaries, but the other one is ~/.cabal/bin/cabal-1.20
09:36:51 <jfischoff> when I
09:37:19 <jfischoff> I'm memory profiling with +RTS -h and -hc -xc , I'm only getting one sample
09:37:27 <jfischoff> any ideas why?
09:37:28 <albeit> Ohh liftA2, nvm
09:37:29 <bergmark> gilligan_: did you build the older cabal binary with an old version of ghc?
09:39:20 <gilligan_> bergmark, i have never had any different/older cabal version on this computer
09:40:18 <gilligan_> bergmark, the one i have installed globally is 1.20.0.0 - codex only requires 1.19 and for some reason that screwed things up. When I set the dependency to 1.20 it worked fine
09:41:18 <bergmark> gilligan_: `ghc-pkg list Cabal' ?
09:41:57 <bergmark> ghc comes with a cabal library, right?
09:42:04 <vlads1> hi, all. Right now I experience some wierd shit when running my haskell app on windows 7: It sometimes (about 75% of time) gives `Segmentation fault/access violation in generated code', but if try over and over, it works. I don't know where to ask or post it.
09:42:18 <gilligan_> bergmark, wow now i am confused
09:42:44 <gilligan_> bergmark, 1.18.1.3
09:43:08 <bergmark> right that's what ships with ghc 7.8.2
09:43:15 <peddie> vlads1: can you narrow the problem down to a small example and post it on lpaste.net?
09:43:19 <bergmark> and then you built 1.20 in a sandbox i'm guessing?
09:43:46 <peddie> @where paste
09:43:47 <lambdabot> Haskell pastebin: http://lpaste.net/
09:44:28 <gilligan_> bergmark, i found a ubuntu repo with ghc 7.8.2 & cabal 1.20 packages
09:44:51 <yitz> albeit: or just (+) <$> x <*> y
09:45:11 <gilligan_> bergmark, which is working fine so far so i haven't given it much thought
09:48:23 <bergmark> gilligan_: https://github.com/haskell/cabal/issues/1938
09:50:40 <gilligan_> bergmark, ah alright
09:50:49 <gilligan_> bergmark, would be nice if they could figure it out
09:50:57 <bergmark> gilligan_: it sure would ;-)
09:51:10 <vlads1> peddie: I've been trying to find a culprit before I found that app sometimes launches. I'll try to give a (not)working example
09:52:03 <jamiehannaford> I'm trying to define a new type, type Stream a = [a]
09:52:18 <jamiehannaford> but I get this error: Not in scope: data constructor `Stream'
09:52:52 <bergmark> jamiehannaford: the type alias looks ok, are you trying to use it as a constructor somewhere else?
09:52:52 <jamiehannaford> I think it's assuming I mean Data.Stream or something - is there any way to stop that?
09:53:13 <jamiehannaford> bergmark yeah in this function streamToList :: Stream a -> [a]
09:53:13 <geekosaur> jamiehannaford, you're misusing it somewhere
09:53:14 <bergmark> jamiehannaford: `type' just defines a type alias, it doesn't introduce a constructor
09:53:55 <geekosaur> that type signature looks fine, but somewhere you are trying to use Stream as a data constructor and that won't work
09:54:01 <bergmark> jamiehannaford: what's your implementation of that function? it should just be `id'
09:54:13 <jamiehannaford> streamToList s@(Stream a) = a : (streamToList s)
09:54:32 <geekosaur> that's wrong
09:55:14 <geekosaur> Stream is not a data constructor; it'd be s@[a:_] or something like that
09:55:20 <jamiehannaford> so you can only pattern match with data constructors?
09:55:24 <geekosaur> yes
09:55:40 <geekosaur> in fact that is their purpose
09:56:11 <c_wraith> Data constructors are functions that can be reversed with pattern matching.
09:56:13 <geekosaur> you are matchingon structure; `type` does not introduce a newstructural element, the structure is still [...]
09:56:23 <c_wraith> Otherwise, they'd just be functions.
09:56:27 <geekosaur> I got that wrong, s@(a:_)
09:56:33 <geekosaur> this is not prolog >.>
09:56:56 * c_wraith makes a note, haskell is not prolog
09:57:14 <jamiehannaford> when I use the `id' thing and try streamToList (Stream 1) in ghci I get Not in scope: data constructor `Stream'
09:57:16 <c_wraith> > let (x:xs) = undefined in x ++ xs
09:57:18 <lambdabot>  *Exception: Prelude.undefined
09:57:28 <rwbarton> jamiehannaford: yes, because Stream still isn't a data constructor
09:57:28 <jamiehannaford> do I need to export type Stream ?
09:57:33 <rwbarton> no
09:57:35 <geekosaur> you are still using it wrong
09:57:36 <c_wraith> err..  Why wasn't that a type error?
09:57:48 <rwbarton> the way you write a value of type Stream Int, say, is: [1]
09:58:01 <geekosaur> the structure of a Stream does not involve a data constructor called Stream, Stream is just a type alias for []
09:58:03 <rwbarton> I think your initial premise is wrong. you're not trying to define a new type, type Stream a = [a]
09:58:09 <rwbarton> you're trying to do something else
09:58:21 <geekosaur> yes, it sounds like you didn't want a type alias there
09:59:15 <syllogismos> https://gist.github.com/syllogismos/3dcd7ee2bd9ac478150c why am I getting this error
09:59:26 <syllogismos> just a little function
09:59:58 <c_wraith> syllogismos: because it doesn't know if you want a to be Float, Double, or an infinite variety of other things
10:00:12 <c_wraith> syllogismos: and it needs to know which one in order to generate code
10:00:20 <geekosaur> and it doesn't fir the constraints that would allow it to use defaulting
10:00:25 <geekosaur> *fit the
10:00:42 <c_wraith> I was going to leave defaulting for the followup question of why it works without the Random constraint
10:00:52 <geekosaur> heh
10:02:16 <c_wraith> Why doesn't GHC 7.8 give infinite type errors anymore?
10:02:42 <c_wraith> ah, it does...
10:02:45 <c_wraith> In *some* cases
10:03:04 <c_wraith> :t \(x:xs) -> x ++ xs
10:03:05 <lambdabot>     Occurs check: cannot construct the infinite type: a ~ [a]
10:03:05 <lambdabot>     Expected type: [a]
10:03:05 <lambdabot>       Actual type: [[a]]
10:03:24 <c_wraith> > let (x:xs) = undefined in x ++ xs
10:03:25 <lambdabot>  *Exception: Prelude.undefined
10:03:29 <syllogismos> what specific function has the problem here? print?
10:03:33 <c_wraith> Why is it executing it at all?
10:03:44 <c_wraith> That should fail typechecking before it can ever throw an exception
10:04:04 <c_wraith> syllogismos: print requires that it knows the type of its input, yes.
10:04:45 <c_wraith> :t let (x:xs) = undefined in x ++ xs
10:04:45 <lambdabot> [a]
10:04:51 <c_wraith> That's...  very wrong.
10:05:32 <rwbarton> it's right if the bindings are generalized
10:05:40 <rwbarton> I remember this coming up before
10:05:55 <sjoerd_visscher> is defer-type-errors enabled?
10:05:57 <rwbarton> and trying to decipher the language standard to figure out whether it was correct
10:06:02 <c_wraith> There's no way that generalization can work.
10:06:19 <intrados> Producing an arbitrary summary statistic (e.g. max) of a stream (e.g. a CSV downloaded via HTTP) in constant space is a bit too magical, even for pipes/conduit, right?
10:06:19 <c_wraith> x and xs can never be the same type as required for ++
10:06:44 <rwbarton> if each binding gets a generalized type
10:06:53 <geekosaur> hm? depends on the statistic
10:06:56 <rwbarton> then x :: forall a. a and xs :: forall a. [a]
10:07:12 <bergmark> intrados: sounds like it should be possible
10:07:20 <geekosaur> max and avg should be doable in constant space; max needs to only retain the hghest value seen, avg needs a single accumulator and a count
10:07:29 <c_wraith> rwbarton: ok, those type do unify, but that's useless generality that can never work.
10:07:51 <geekosaur> variance would be harder I think but there are tricks?
10:08:25 <c_wraith> Personally, for any statistics question, I'd just trust bos's statistics package.
10:08:30 <c_wraith> Let someone else think about it.
10:08:41 <c_wraith> Someone who knows what the term "numerical stability" means. :)
10:09:17 <intrados> geekosaur, bergmark: Right, it should be possible for some. But you can't just do something like `max stream` and expect everything to magically work out, right? You have to 'manually' streamify your calculation
10:09:19 <ReinH> c_wraith: Yeah, that's what I've done so far.
10:09:23 <ReinH> Pretty successfully.
10:09:28 <ReinH> It's a nice library.
10:10:13 <codygman> I found some typos on the Data.List docs, where should I report that? Email libraries@haskell.org?
10:10:14 <c_wraith> intrados: actually, folding the binary max function over the stream will work just fine by itself, assuming nothing else holds on to the stream in memory
10:10:30 <c_wraith> intrados: average requires more work, though
10:10:33 <ReinH> Here's how that usually goes for me: "I need the cumulative distribution function for the normal distribution of a Vector of sample data. Oh, that's a one-liner. Awesome."
10:11:04 <ReinH> intrados: monoids are great for stream processing :)
10:11:11 <geekosaur> yes, you will run into the same problem with the naïve average computation over a list
10:11:12 <ReinH> since associativity guarantees that they can accumulate new values
10:11:31 <ReinH> You can compute average from a (Count, Sum) monoid ;)
10:11:31 <rwbarton> > let (x:xs) = read "[[],[]]" in x ++ xs :: [[()]]
10:11:33 <lambdabot>  [[]]
10:12:06 <c_wraith> Hmm.  I wonder if chunking processing from a stream with monoids could ever usefully add parallelism.
10:12:31 <c_wraith> I guess it depends on if the monoid operation is more significant an operation than pulling the next value from the stream.
10:12:57 <ReinH> c_wraith: right, which is probably usually not the case
10:13:33 <albeit> Is needing to get the current time in an otherwise fully non-IO-utilizing module a fair reason to use unsafePerformIO, rather than doing everything in an IO monad?
10:13:45 <geekosaur> it is not
10:14:00 <geekosaur> in fact it's close to textbook why it is *not* valid
10:14:12 <intrados> Thanks all
10:14:20 <geekosaur> because the compiler is allowed to assume that it always produces the same value
10:14:45 <geekosaur> (indeed, unsafePerformIO specifically tells it that that is correct)
10:15:08 <albeit> So should I be doing everything inside IO then?
10:15:11 <geekosaur> yes
10:15:12 <rwbarton> why not just have whatever function needs the time accept it as an argument
10:15:24 <geekosaur> or, redesign so your pure and impure parts are properlys eparated
10:15:29 <rwbarton> or that, depends on what you are doing, the premise sounds odd
10:15:44 <geekosaur> it sounds like you are trying to write procedural code
10:16:04 <geekosaur> the only way to do this in haskell is in IO
10:16:42 <geekosaur> ...and the correct answer is to write proper functional code instead of trying to hold on to a procedural mindset
10:17:44 <vlads> peddie: If an application gives same error, but only upon closing - is it sufficient? I. e. before that it crashed immediately, now it does not, but very rarely closes without error.
10:18:05 <albeit> Hmm... here's what I'm trying to do. A module Foo constructs a ByteString from an internal data structure, but it needs to put the current time in that ByteString. Another module Bar (that is in IO) then sends that Bytestring over the network... but Foo and Bar should entirely be separate.
10:18:33 <ReinH> intrados: you can also, e.g., compute stddev and variance from a (Sum, SumOfSquares) monoid, while avoiding the floating point error accumulation problem at the same time!
10:19:05 <ReinH> not avoiding, ofc, just making the errors within an acceptable range
10:19:28 <ReinH> no more negative stddev! ;)
10:19:31 <peddie> vlads: no, I'd probably post the example that fails more readily to lpaste
10:20:02 <peddie> vlads: for better or worse, I don't know anything about haskell on windows and am unlikely to be much help -- but lpaste is the right place to put an example
10:20:12 <ReinH> albeit: data FooWithTime = FooWithTime { _foo :: Foo, _time :: TheTime }
10:20:23 <peddie> vlads: I don't know what you changed to cause it to crash at the end rather than immediately, but I suspect that's a good clue :)
10:20:48 <ReinH> or constructFooWithTime :: Foo -> TheTime -> ByteString
10:21:15 <ReinH> or both
10:21:26 <jamiehannaford> "streams are like lists but with only a “cons” constructor— whereas the list type has two constructors, [] (the empty list) and (:) (cons), there is no such thing as an empty stream. So a stream is simply deﬁned as an element followed by a stream"
10:21:30 <jamiehannaford> is this correct? data Stream a = Cons a (Stream a)
10:21:43 <vlads> peddie: yeah, I had come to same conclusion, and now try to check it
10:21:46 <ReinH> c_wraith: what you might be able to do is accumulate a sample of the data and then reduce it in parallel (tree fold)
10:22:05 <ReinH> c_wraith: but I'm having trouble figuring out a case where this is faster than just accumulating immediately
10:22:24 <peddie> vlads: good luck!
10:23:10 <ReinH> jamiehannaford: Yes
10:23:10 <intrados> jamiehannaford: I believe so. Haskell's laziness permits infinite lists which blurs the distinction somewhat
10:23:32 <vlads> peddie: it takes forever to link, sadly, even though application is not that big
10:23:34 <ReinH> intrados: the distinction is that streams *can't* terminate
10:23:46 <jamiehannaford> I'm trying to convert streams to lists with streamToList :: Stream a -> [a]
10:24:08 <ReinH> jamiehannaford: replace the Cons constructor with a (:) constructor via a fold
10:24:12 <c_wraith> ReinH: well, you could build the tree fold from the bottom up, but it still is only a win when the monoidal operation dominates the runtime.
10:24:19 <rwbarton> just use recursion
10:24:23 <ReinH> c_wraith: yep
10:24:33 <Maerten> Hi, I'm trying to compile my program with '-prof -fprof-auto', but it doesnt compile "Could not find module `Data.IP.` Perhaps you haven't installed the profiling libraries for package `iproute-1.2.12'?" However I enabled "library-profiling: True" in ~/.cabal/config and did a cabal install --reinstall iproute
10:24:40 <Maerten> Any help would be appreciated!
10:24:48 <peddie> vlads: yeah, GHC can be a bit slow at times; you could try running your application interpreted with "runhaskell" or "runghc" just for testing it out
10:25:04 <ReinH> rwbarton: yep
10:25:26 <ReinH> rwbarton: I meant "the fold recursive pattern", not necessarily "use foldr". I guess I should have been more specific. :)
10:25:34 <rwbarton> ah ok
10:25:50 <jfischoff> Maerten: are you using cabal?
10:25:56 <ReinH> Although if it has foldr you can use that :)
10:26:14 <jamiehannaford> ReinH I don't understand what you mean by "replace the Cons constructor" - you mean in the data type
10:26:14 <Maerten> jfischoff: yes
10:26:53 <ReinH> jamiehannaford: think about this definition of sum for a list: sum [] = 0; sum (x:xs) = x + sum xs
10:26:55 <Maerten> jfischoff: everything works when i compile it normally, but with -prof -fprof-auto it keeps complaining..
10:27:16 <ReinH> jamiehannaford: what that's doing is replacing the structure 0:1:2:[] with the structure 0+1+2+0
10:27:37 <ReinH> jamiehannaford: so it replaces the (:) constructor with (+) and the [] constructor with 0
10:27:45 <jfischoff> I don't think you need the -prof part, I think you can configure with --enable-executable-profiling or --enable-library-profiling ... maybe I am confused
10:27:56 <ReinH> jamiehannaford: this is the foldr pattern, but in your case you only need to replace Cons with (:) since there's no base case
10:28:19 <jfischoff> for some reason those flags are preferable, I'm hoping someone else in here can correct me or add color
10:28:33 <jamiehannaford> ReinH do I need to include "Con" in the pattern matching? I know how to pattern match a simple list for a sum or something
10:28:41 <ReinH> jamiehannaford: so you want to write toList (Cons x xs) = ???
10:28:43 <eacameron> anyone seen this from cabal on Windows? cabal: <socket: 364>: invalid argument
10:28:49 <eacameron> running cabal update
10:29:21 <jamiehannaford> ReinH I want to convert a stream into an infinite list (see exercise 3 here: http://www.seas.upenn.edu/~cis194/hw/06-laziness.pdf)
10:29:25 <jfischoff> I've seen something like that when cabal can't reach hackage
10:29:29 <ReinH> jamiehannaford: I know.
10:29:35 <ReinH> jamiehannaford: I'm telling you how to do that :)
10:29:43 <rwbarton> Maerten: yeah try configuring with --enable-executable-profiling
10:29:59 <jamiehannaford> ReinH ah okay - I'll try that :)
10:29:59 <eacameron> jfischoff: I get that every time, for days
10:30:09 <jfischoff> yikes
10:30:15 <ReinH> jamiehannaford: so yes, you need to pattern match on the Cons constructor
10:30:32 <Maerten> ah i'm sorry i thought you meant i installed my packages with cabal, i'm not using cabal to compile, just ghc.
10:30:36 <rwbarton> oh
10:30:51 <Maerten> so i'll look into compiling with cabal and see how that goes.. thanks!
10:31:05 <rwbarton> well it probably won't help, this is a simpler problem with ghc
10:31:14 <Maerten> hm ok
10:31:15 <ReinH> jamiehannaford: does that definition of sum above make sense to you?
10:31:43 <jamiehannaford> ReinH yeah. so I've defined data Stream a = Cons a (Stream a) but when I run in ghci it says Not in scope: data constructor `Stream'
10:31:53 <ReinH> jamiehannaford: Stream isn't a data constructor
10:31:55 <rwbarton> Maerten: I would ghc-pkg describe iproute-1.2.12 and find the library-dirs: line
10:32:05 <ReinH> Stream is a *type* (and a *type* constructor)
10:32:09 <jamiehannaford> ohhh okay
10:32:11 <ReinH> jamiehannaford: the data constructor is Cons
10:32:20 <ReinH> jamiehannaford: so you want to write toList (Cons x xs) = ???
10:32:49 <rwbarton> Maerten: then look in that directory and see if there is a Data/IP.p_hi
10:32:51 <ReinH> where x is a value and xs is the rest of the stream
10:33:01 <rwbarton> Maerten: alternatively, run ghc with -v and it will give you more info
10:33:03 <jamiehannaford> I have - streamToList (Cons x xs) = x : (streamToList xs)
10:33:11 <Maerten> rwbarton: no only a IP.hi
10:33:18 <ReinH> jamiehannaford: and does it work?
10:33:29 <rwbarton> Maerten: ok so it didn't actually build a profiling version
10:33:49 <rwbarton> Maerten: is it possible you installed a different version than 1.2.12 with cabal install --reinstall iproute?
10:33:52 <jamiehannaford> ReinH I don't know which arg to provide streamToList
10:33:55 <ReinH> jamiehannaford: (note that function application binds more tightly than the (:) operator so the parens on the right hand side are redundant)
10:34:00 <ReinH> jamiehannaford: what is its type?
10:34:31 <jamiehannaford> its type is Stream, so to create that I tried Cons 1 (Cons 1) - but it's recursive so didn't know how to construct it
10:34:41 <ReinH> jamiehannaford: is its type "Stream"? Are you sure?
10:34:51 <Maerten> rwbarton: no it is the right version.. it just doesnt seem to install the profling stuff ( cabal install --reinstall iproute shows: "iproute-1.2.12 (reinstall)")
10:34:57 <rwbarton> I guess jamiehannaford means "it = which arg to provide streamToList"
10:34:58 <ReinH> jamiehannaford: let's be precise here :)
10:35:03 <ReinH> rwbarton: I know :)
10:35:20 <rwbarton> well then, "what has type Stream"
10:35:23 <ReinH> rwbarton: but Stream is uninhabited ;)
10:35:27 <ReinH> rwbarton: It does not.
10:35:40 <ReinH> Stream has kind * -> *
10:35:47 <rwbarton> ok yes
10:35:56 <rwbarton> I thought you were talking about the type of the function
10:35:57 <jamiehannaford> Cons x (Cons x(Cons x(.........)))
10:36:04 <ReinH> jamiehannaford: Cons is not a type constructor :)
10:36:15 <ReinH> jamiehannaford: just do :t streamToList and be precise about what it says :)
10:36:21 <jfischoff> Maerten: what happens when you `cabal install --enable-library-profiling --reinstall iproute-1.2.12` ?
10:36:42 <rwbarton> Maerten: I guess somehow your cabal config is not taking effect then
10:36:54 <jfischoff> yeah that is my guess
10:37:26 <jamiehannaford> my problem is that I don't know how to create a type of Stream
10:37:33 <gsingh93_> can I specify the types for functions in a let clause?
10:37:38 <jamiehannaford> ReinH sorry! you're very patient :)
10:37:38 <jfischoff> yes
10:37:46 <jfischoff> for the most part I guess
10:37:46 <ReinH> jamiehannaford: that's not quite your problem, so stick with me for a moment :)
10:37:48 <Maerten> jfischoff / rwbarton yeah you are right, now it ignores the setting in the config. with --enable-library-profiling it works!
10:37:58 <Maerten> is there a way to reinstall all packages easily with profiling?
10:38:01 <ReinH> jamiehannaford: can you tell me the type of the argument to streamToList?
10:38:11 <ReinH> hint: "Stream" is very nearly correct
10:38:19 <ReinH> it's only off by two characters, in fact
10:38:24 <jfischoff> um with the config, so you would need to figure out why it is not being respected
10:38:46 <jfischoff> it will take awhile so it might not fit your definition of easy
10:39:14 <rwbarton> Maerten: are you on OS X by any chance?
10:39:21 <jamiehannaford> Stream a
10:39:21 <Maerten> i found a command on a blog, to generate a list of installed packages and then reinstall all of them.. it's running now so lets hope it works
10:39:26 <Maerten> rwbarton: yes i am
10:39:38 <ReinH> jamiehannaford: bingo :) Sorry if that seems pedantic but I'm trying to prevent later confusion from conflating the two
10:39:40 <rwbarton> if you installed cabal from Haskell Platform I think it stores its config somewhere else
10:39:54 <Maerten> ah
10:40:08 <jamiehannaford> ReinH no it's fine - it's details like these which matter
10:40:34 <ReinH> jamiehannaford: So you need to construct an *infinite* structure built from Cons constructors
10:40:42 <jamiehannaford> ReinH yeah
10:40:45 <rwbarton> ~/Library/Haskell or something
10:40:49 <geekosaur> it still uses ~/.cabal/config, paths in there redirect some other things though
10:40:55 <rwbarton> oh really
10:41:00 <geekosaur> yes
10:41:00 <ReinH> jamiehannaford: so recursion without a base case gives doesn't terminate, right?
10:41:04 <ReinH> s/gives //
10:41:05 <rwbarton> hmm then I have no idea
10:41:12 <athan_> Does anyone know what ExitFailure (-11) means? I'm trying to install attoparsec on ghc 7.8.2/cabal 1.20, and I keep getting this weird error: http://lpaste.net/105530
10:41:13 <Maerten> rwbarton: i will figure it out another time why the config is ignored.. thanks for your help rwbarton and jfischoff !
10:41:16 <jfischoff> sandbox?
10:41:26 <rwbarton> well, maybe you turned a line like -- library-profiling: False into -- library-profiling :: True
10:41:32 <rwbarton> um
10:41:35 <rwbarton> -- library-profiling: True
10:41:37 <jfischoff> oh yeah
10:41:37 <jamiehannaford> ReinH surely you'd need "a" for the base of the list though?
10:41:51 <rwbarton> that won't do anything, -- is a comment
10:41:54 <ReinH> jamiehannaford: but there's no base to the stream
10:41:58 <jfischoff> I guess Maerten should paste his config
10:42:22 <wz1000> So, if i worked through the lazy evaluation of quicksort correctly, these(http://pastebin.com/d7EtyZYs) programs are essentially equivalent. Can anybody verify?
10:42:24 <ReinH> jamiehannaford: so the trick is: you can use recursion to construct infinite structures.
10:42:42 <jfischoff> If the multiple instances of the same version restriction is lifted, one could install the profiling libraries without reinstalling everything ...
10:43:08 <ReinH> jamiehannaford: so think about this...
10:43:27 <ReinH> > let xs = 1 : undefined in take 1 xs
10:43:28 <lambdabot>  [1]
10:43:30 <athan_> How would I install yesod-platform with the new cabal/ghc without doing so globally? ie: installing them in a sandbox...?
10:43:56 <ReinH> jamiehannaford: what can I replace `undefined' with that will never stop consing 1's?
10:44:21 <Maerten> jfischoff: i dont mind reinstalling.. i'm working on something else while its compiling.. :-)
10:44:21 <ReinH> jamiehannaford: hint: it's sitting right there
10:44:32 <jamiehannaford> let xs = repeat x in take 1 xs ?
10:44:34 <jamiehannaford> sorry
10:44:36 <jamiehannaford> repeat 1
10:44:47 <ReinH> jamiehannaford: you don't get to use any helper functions
10:46:00 <ReinH> jamiehannaford: what does xs do?
10:46:02 <jamiehannaford> let xs = 1 : xs in take 1 xs ?
10:46:05 <ReinH> yes
10:46:10 <ReinH> > let xs = 1 : xs in take 10 xs
10:46:11 <lambdabot>  [1,1,1,1,1,1,1,1,1,1]
10:46:19 <ReinH> jamiehannaford: now do that with the Cons constructor instead
10:46:31 <ReinH> jamiehannaford: btw here's why repeat is cheating:
10:46:33 <ReinH> @src repeat
10:46:33 <lambdabot> repeat x = xs where xs = x : xs
10:46:47 <ReinH> ;)
10:47:06 <ReinH> jamiehannaford: as an intermediate step, you can use the (:) constructor prefix:
10:47:15 <ReinH> > let xs = (:) 1 xs in take 10 xs
10:47:17 <lambdabot>  [1,1,1,1,1,1,1,1,1,1]
10:47:37 <ReinH> jamiehannaford: now it should be pretty easy to spot where to put `Cons'
10:48:12 <athan_> How do I install executables with cabal in a safe way?
10:49:33 <jamiehannaford> is it let xs = Cons 1 xs in take 10 xs?
10:49:51 <ReinH> jamiehannaford: yes, althouth the take is there just so you can get some finite output to print
10:50:02 <jamiehannaford> i get an error: Couldn't match expected type `[a1]' with actual type `Stream a0'
10:50:13 <ReinH> jamiehannaford: because take expects a list
10:50:21 <ReinH> > let xs = 1 : xs in xs
10:50:22 <wz1000> athan_:  Do  you mean without messing up your existing installation?
10:50:22 <lambdabot>  [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1...
10:50:48 <ReinH> jamiehannaford: that's the same as:
10:50:52 <ReinH> xs = 1 : xs
10:51:04 <athan_> wz1000: Yeah! Can I use a wrapper project with a sandbox or something?
10:51:05 <lordcirth> That's a useful bot
10:51:07 <ReinH> jamiehannaford: you might instead write repeatStream in the style of repeat
10:51:09 <ReinH> @src repeat
10:51:09 <lambdabot> repeat x = xs where xs = x : xs
10:51:46 <wz1000> athan_: http://coldwa.st/e/blog/2013-08-20-Cabal-sandbox.html
10:52:28 <wz1000> athan_: Basically you navigate to the source sirectory, and run cabal sandbox init
10:52:45 <wz1000> *directory
10:53:33 <jamiehannaford> so the type of let xs = Cons 1 : xs is xs :: [Stream Integer -> Stream Integer]
10:53:42 <wz1000> athan_: then you just use cabal install like you always do
10:54:08 <jamiehannaford> ReinH I need Stream a where data Stream a = Cons a (Stream a)
10:54:26 <ReinH> jamiehannaford: Cons *replaces* the (:) constructor
10:54:33 <ReinH> (:) constructs lists, Cons constructs streams
10:54:35 <wz1000> athan_: if you mess something up use 'cabal sandbox delete'
10:54:49 <jamiehannaford> ReinH how stupid, of course
10:54:54 <ReinH> jamiehannaford: :) not stupid
10:54:57 <jamiehannaford> works perfectly now, woo hoo
10:55:00 <ReinH> jamiehannaford: :)
10:55:06 <jamiehannaford> thanks ReinH
10:55:11 <athan_> wz1000: A thousand thank-yous to you, sir :)
10:55:13 <ReinH> jamiehannaford: yw!
10:55:58 <ReinH> amiller: btw constructing a Stream is an example of corecursion :) http://en.wikipedia.org/wiki/Corecursion
10:56:24 <ReinH> er
10:56:26 <ReinH> jamiehannaford: ^
10:56:27 <athan_> wz1000: Get it?? Seriously, though, thank you!
10:56:34 <ReinH> amiller: sorry, I guess I skipped the 'k'
10:56:43 <wz1000> athan_: note, the sandbox is only in use when you are building in the source directory.
10:56:43 <ReinH> Or the 'j'. Obviously typing is not my strong suit today.
10:57:01 <wz1000> athan_: you're welcome
10:57:46 <athan_> wz1000: Dutifully noted :)
10:58:02 <Jefffrey> Hello boys and girls.
10:58:33 <wz1000> Hi Jefffrey.
10:59:12 <Jefffrey> Is there a way to specify, for each cabal executable in a cabal file, where the output executable file should be places (as opposed to dist/build)?
10:59:40 <kini> oh my god, cabal has 541 open issues
10:59:53 <Jefffrey> I've read the documentation and searched on Google, but nothing comes out. :(
11:00:50 <kini> including some ancient things like this https://github.com/haskell/cabal/issues/355
11:01:37 <nicoo> kini: I have many issues with cabal too
11:01:46 <nicoo> (mainly with cabal-install, in fact)
11:01:50 <wz1000> kini: let's try to fix them
11:02:27 <kini> wz1000: that requires getting familiar with the codebase first :)
11:03:13 <wz1000> kini: I have some free time
11:05:11 <kini> wz1000: great! good luck :P
11:05:44 <kini> aha, and my problem is already reported... https://github.com/haskell/cabal/issues/1700
11:15:44 <michaelt> intrados: http://hackage.haskell.org/package/foldl for example.
11:15:59 <wz1000> Jefffrey: This may help: http://www.haskell.org/cabal/users-guide/installing-packages.html#installation-paths
11:20:02 <kini> does anyone know how one would actually fix this? https://gist.github.com/leonbaum/9164940
11:20:19 <kini> er, https://gist.github.com/leonbaum/9164940#file-output-txt
11:21:52 <kini> I'm seeing exactly this error when trying to build the hashable library from github
11:22:28 <michaelt> kini are you doing cabal clean before rebuiding?
11:22:31 <kini> yup
11:22:52 <kini> in fact I'm just doing `cabal sandbox init ; cabal install --enable-library-coverage` from a fresh clone of the repository
11:23:01 <kini> which should be even more pristine than cabal clean, if anything :)
11:23:29 <kini> this is on ghc 7.8.2, cabal-install 1.20.0.2, cabal 1.20.0.0
11:23:29 <rwbarton> oh
11:23:37 <rwbarton> --enable-library-coverage is known to be broken, I think
11:23:41 <kini> eh? :(
11:23:58 <rwbarton> maybe if you use only static libraries it will work
11:25:05 <kini> well, I would like to avoid that if possible...
11:25:45 <rwbarton> kini: ok, then. go fix https://ghc.haskell.org/trac/ghc/ticket/9012 :)
11:26:42 <kini> oh, huh, it's an HPC issue is it...
11:26:51 <kini> I guess it's not as simple as the gist I linked
11:28:18 <kini> thanks for the link, I CC'd myself to the trac ticket
11:28:42 <michaelt> oh i see it now if I try it with logict
11:29:30 <rwbarton> I couldn't reproduce the issue in that gist using the source and config file from the gist, so I think that is a separate issue, maybe too old cabal
11:31:27 <joelteon> so I'm trying to approximate thompson's construction method for nondeterministic finite automata using Free, but I'm doing something wrong here: http://lpaste.net/105532
11:31:41 <joelteon> am I fundamentally misunderstanding something
11:32:42 <fuzzy_id> @pl (\x -> 0 /= x && 1 /= x)
11:32:42 <lambdabot> liftM2 (&&) (0 /=) (1 /=)
11:33:12 <fuzzy_id> is there a nicer equivalent?
11:33:35 <geekosaur> not really
11:34:10 <fuzzy_id> hmpf
11:34:24 <Ralith> fuzzy_id: not . flip elem [0,1]
11:34:57 <fuzzy_id> oh yeah :)
11:35:25 <rwbarton> :t notElem
11:35:26 <lambdabot> Eq a => a -> [a] -> Bool
11:36:01 <fuzzy_id> right, so its (`notElem` [0, 1])
11:44:43 <kini> rwbarton: looks like I can't reproduce it either. Interesting.
11:46:17 <Jefffrey> wz1000: Thanks. But I've already saw that. :)
11:54:29 <gilligan_> if i'm working on a project and I have ghci running via "cabal repl" : is there a way to trigger a recompile & reload of changed files so i can be sure the state in the repl is up to date ?
11:56:41 <koala_man> TIL there's a "cabal repl". That'll save me a lot of hassle
11:59:02 <sbrg> gilligan_: :r ?
11:59:45 <sbrg> Maybe you can use guard to run ghci on changed file, killing if it's already running
12:00:17 <gilligan_> sbrg, yeah that's what i expected. But it fai... oh wait a second
12:00:31 <gilligan_> sbrg, the project has an executable and a library
12:00:52 <sbrg> I don't see why just running :r is so much of a hassle?
12:00:53 <gilligan_> sbrg, i suppose the repl only has everything belonging to the executable loaded
12:00:54 <sbrg> That's what I do
12:01:04 <gilligan_> sbrg, it certainly is not
12:01:10 <gilligan_> sbrg, it just didn't work for me
12:01:33 <gilligan_> sbrg, and i think that's because it only updated everything belonging to the specified executable, and not the library
12:02:08 <jfischoff> If I have something like: almostApp :: Ref (a -> b) -> Ref a -> IO (Ref b), is there a way to massage it into something Applicative?
12:02:12 <gilligan_> sbrg, do you know what i mean at all?
12:03:00 <gilligan_> sbrg, cabal only supports loading of a single target
12:03:05 <sbrg> gilligan_: I believe so, yes. When I'm working on a multi-module project and want to reload all the files, I usually have the main file import all of them, and then reload reloads all changes
12:03:25 <gilligan_> sbrg, ah ok
12:03:27 <sbrg> or I reload the particular module I'm working on
12:03:41 <gilligan_> sbrg, right yeah..
12:03:53 <sbrg> Works For Me™
12:04:33 <gilligan_> sbrg, yeah sure. i made it more difficult than it is just because i did not  realize at first that the only reason :r did not work as expected was because of the separate targets
12:04:38 <gilligan_> sbrg, thank you though
12:11:36 <BeardedCoder> bitemyapp: I'm fixing to use Bloodhound for a small project I'm doing at work. I'll let you know if it works =)
12:13:30 <albeit> With cabal, can I compile a specific file and its imports, instead of everything?
12:15:40 <albeit> Like a "cabal build Foo.hs"
12:18:49 <rwbarton> jfischoff: you can make data Foo a = IO (Ref a) an Applicative (assuming you can write pure too)
12:18:53 <rwbarton> dunno if this is useful
12:19:16 <jfischoff> yeah, but seems to not workout the way want brb
12:29:33 * hackagebot Baggins 1.0 - Tools for self-assembly  http://hackage.haskell.org/package/Baggins-1.0 (pmeunier)
12:39:33 <rocurley> Hi
12:39:35 * hackagebot loops 0.2.0.0 - Fast imperative-style loops  http://hackage.haskell.org/package/loops-0.2.0.0 (ThomasTuegel)
12:41:15 <rocurley> I'm trying to load hmatrix-quadprogpp, a quadratic program solver, and I keep getting "unknown symbol `_ZN10QuadProgPP6MatrixIdEC1EPKdjj'
12:41:16 <rocurley> ", not when I import it, but when I try to use it
12:42:19 <rocurley> any ideas?
12:46:09 <int-e> rocurley: you need to load (or link to) the QuadProgPP C++ library somehow.
12:48:35 <NemesisD> hey folks. i've got a bit of a problem. I've got a transformer stack like ViewM a = ReaderT ViewState IO a, i've got a function that does a mapM_ (... :: ViewM())
12:49:17 <NemesisD> but now i've reached a point where I want to do those ViewMs in parallel, but I can't use any tools for doing parallel IO because ViewM has its IO on the inside
12:49:56 <NemesisD> in otherwords I want a parViewMapM_ :: (a -> ViewM b) -> [a] -> ViewM ()
12:50:07 <rocurley> int-e: Ok. Any pointers on how to get started on that? I did the whole make make install thing with the QuadProgPP library, and I don't know how to communicate to ghci that it should be looking in my lib folder
12:50:58 <int-e> rocurley: ghci -lQuadProgPP  may work
12:50:59 <alorente> I have a cabal problem. When I run `cabal install --only-dependencies`, cabal fails with very little information: http://lpaste.net/105539 I assume there's something wrong with my .cabal file but I don't know how to figure out what
12:51:19 <NemesisD> oh wait, it looks like someone thought of this in parallelList' http://hackage.haskell.org/package/parallel-tasks-4.0.0.0/docs/Control-Concurrent-ParallelTasks.html
12:52:05 <shapr> Yow! Good afternoon Haskellers! Any awesome code written lately?
12:52:28 <mmachenry> shapr: Hey. And of course. :)
12:52:30 <bergmark> shapr: lots of it!
12:52:40 <shapr> bergmark: ooh, what have you written?
12:52:46 <shapr> mmachenry: what was it?
12:53:01 <moghedrin> shapr: No such thing ;P
12:54:08 <bergmark> shapr: we are working hard to officially release our rest package
12:54:14 <monochrom> I wrote some java code today that was faster than some haskell code
12:54:50 <mmachenry> shapr: I wrote a prototype of a concurrent phone dialing server that will control many Freeswitch boxes
12:55:04 <NemesisD> monochrom: nuh uh
12:55:04 <shapr> mmachenry: whoa, nifty!
12:55:08 <mmachenry> I'm working on getting my boss to let me just use that for production :)
12:55:18 <monochrom> what does "nuh uh" mean?
12:55:33 <orzo_> means he doubts you
12:55:34 <shapr> I used to do a bunch of Asterisk work, though not anymore.
12:56:03 <DanBurton> Sanity check: readMVar is cheaper than modifyMVar_, correct?
12:56:16 <johnw> shapr: hey!
12:56:25 <shapr> howdy johnw! How's code?
12:56:30 <johnw> shapr: you should see how simple-conduit is shaping up!
12:56:51 <monochrom> I think it's only slightly cheaper, DanBurton
12:56:53 <johnw> I was able to make a huge number of simplifications last night and this morning, such that many of the combinators are one-liners now, or just new names for "lift" or ">>="
12:57:07 <shapr> johnw: sounds great!
12:57:11 <johnw> shapr: also, it looks like we will be co-locating at edwardk's house for Hac Boston!  We get to meet at last!
12:57:14 <rocurley> int-e: The load was sucessful: "Loading object (dynamic) QuadProgpp ... done
12:57:14 <rocurley> "
12:57:19 <rocurley> int-e: but it still can't load the package
12:57:55 <DanBurton> I want to make sure this is as good as it gets: http://lpaste.net/105541. Optimized for having more "hits" than "misses".
12:59:55 <johnw> DanBurton: what about the race between the read and modify, does that not matter?
13:00:11 <johnw> two threads call fetch, they may both attempt the action
13:00:39 <johnw> ah, I see
13:00:49 <johnw> the second will see the setting of the first
13:01:16 <shapr> johnw: w00t! Did you reserve the other couch? :-)
13:01:18 <DanBurton> johnw: Exactly. So it introduces a little overhead for writing
13:01:20 <int-e> DanBurton: I'd make the cache be an IORef holding a Maybe and an MVar () as a lock. (readMVar is just takeMVar followed by putMVar; it is not cheap.)
13:01:22 <johnw> shapr: I did!
13:01:26 <shapr> awesome!
13:01:32 <shapr> I'm looking forward to hanging out with you!
13:01:36 <johnw> shapr: me too!!!!
13:01:53 <johnw> shapr: perhaps with both of us there, we can convince edwardk that Emacs is just a better place to be :)
13:01:58 <joelteon> guys, I need help with this http://lpaste.net/105532
13:02:04 <edwardk> unlikely ;)
13:02:10 <johnw> joelteon: what kind of help?
13:02:23 <joelteon> I don't understand why the bit after the "star" is duplicated
13:02:30 <ReinH> johnw: which couch?
13:02:30 <joelteon> if you scroll down to the bottom you'll see the structure of 'test'
13:02:32 <DanBurton> int-e: readMVar *used* to be as you said, but apparently that has changed http://hackage.haskell.org/package/base-4.7.0.0/docs/Control-Concurrent-MVar.html#v:readMVar
13:02:36 <shapr> I would only consider myself a power user of emacs. I'm not even close to the caliber of johnw :-P
13:02:52 <johnw> Star introduces a tree
13:03:01 <johnw> which will break ala the list monad
13:03:04 <johnw> s/break/branch
13:03:09 <joelteon> okay
13:03:18 <edwardk> ReinH: i have 2 couches and the ability to set up an air mattress basically
13:03:18 <johnw> if you'd used Union, you'd see triple duplication
13:03:22 <int-e> DanBurton: oh, good to know. *checks rts source*
13:03:24 <joelteon> triplication
13:03:36 <johnw> I actually claimed the air mattress
13:03:37 <ReinH> edwardk: oh for Boston, cool
13:03:42 <joelteon> so I'm trying to do this to approximate converting a regex to a nondeterminate finite automaton
13:03:42 <johnw> I'm not quite edwardk-couch-sized
13:03:45 <joelteon> am I using the wrong thing?
13:03:52 <johnw> I still remember thoughtpolice folding himself up like origami
13:03:58 <edwardk> they are admittedly fairly shortish couches
13:04:04 <ReinH> johnw, shapr: See you in Boston then
13:04:13 <ReinH> Also maybe see you in Chicago?
13:04:15 <johnw> joelteon: it may be the right thing, you might just not want the Monad instance
13:04:29 <johnw> Free structures build trees
13:04:39 <johnw> for example, a list is a one-branch free structure
13:04:40 <thoughtpolice> the couch wasn't that bad, but i normally don't sleep on my back which was the shitty part
13:04:46 <johnw> ReinH: yes!
13:04:50 <int-e> DanBurton: readMVar# still locks the closure though, so there is some contention possible. Maybe some benchmarks are in order :-/
13:04:59 <ReinH> wewt
13:05:11 <joelteon> johnw: what would I use if not the monad instance?
13:05:20 <DanBurton> joelteon: ah, so you read that article, too? :)
13:05:23 <johnw> joelteon: a set of combinators to build the exact free structure you want
13:05:31 <joelteon> what article?
13:06:08 <johnw> edwardk: I was thinking a lot more about that presentation of Free Monads you mentioned
13:06:09 <shapr> thoughtpolice: will you be at Hac Boston?
13:06:22 <johnw> edwardk: is it true to say that any algebra, encoded as an algebraic datatype, is a free object?
13:06:25 <ReinH> johnw: which one?
13:06:36 <johnw> ReinH: the one Dan Piponi gave at BayHac
13:06:44 <ReinH> I enjoyed that one immensely
13:07:16 <DanBurton> joelteon: maybe not, then. I can't find it now, but it was an article I saw recently about exactly that, converting a regex to an NFA
13:07:17 <johnw> yes, it's a stroke of genius to think that way
13:07:38 <joelteon> DanBurton: no, I didn't read it
13:07:43 <joelteon> I will, but I want to figure this out myself first
13:07:58 <johnw> joelteon: I don't think liftF is what you want
13:08:10 <johnw> you want: Free (Star (Symbol 'o') ()) $ do char 'b'; char 's'
13:08:18 <johnw> or something along those lines
13:08:33 <johnw> i.e., you want to "split" your logic here
13:08:49 <johnw> so that the 'o' part goes into one branch of Star, and then remainder of falls into the other branch
13:08:53 <DanBurton> joelteon: ah, here it is. http://perl.plover.com/Regex/article.html
13:09:01 <edwardk> johnw: to say something is free figure out what you're forgetting ;)
13:09:24 <johnw> edwardk: you're forgetting every other algebra for that structure besides the initial one
13:09:39 <DanBurton> int-e: benchmarks are an excellent idea that I am probably too lazy to implement
13:09:41 <joelteon> johnw: that doesn't typecheck
13:10:10 <johnw> joelteon: error?
13:10:19 <joelteon> hang on
13:10:38 <edwardk> a free monad is left adjoint to the forgetful functor that takes monads to functors, so given a functor homomorphism (natural transformation) you get a monad homomorphism when you use the 'free' functor to map it
13:10:57 <johnw> ok, writing that down... :)
13:11:19 <joelteon> http://lpaste.net/105532
13:11:22 <joelteon> annotated
13:11:25 <edwardk> the free monoid is left adjont to the forgetful functor that takes monoids to sets, so given a morphism in the category of functions (Set) you get a monoid homomorphism when you use the free functor to map it
13:11:38 <edwardk> free is relative.
13:11:49 <DanBurton> Google translate feature request: "categoryspeak to english"
13:12:07 <johnw> I see
13:12:09 <johnw> thanks!
13:12:26 <johnw> joelteon: let me try this code here
13:12:45 <joelteon> johnw: you can remove the These import, I gave up on that one
13:13:20 <johnw> Free $ (Star (Symbol 'o' (Pure ()))) $ do char 'b'; char 's'
13:13:45 <johnw> output: Free (Symbol 'b' (Free (Star (Symbol 'o' (Pure ())) (Free (Symbol 'b' (Free (Symbol 's' (Pure ()))))))))
13:13:49 <joelteon> ok, that worked better
13:13:50 <johnw> now, make sure you understand *why*
13:13:57 <joelteon> yeah, I don't
13:14:00 <johnw> because this right here is a critical intuition to form
13:14:06 <joelteon> that seems to be the inverse of the expected behavior
13:14:24 <johnw> any value of type Free (Step Char) ()  describes a tree
13:14:37 <johnw> where that tree's branch of defined by all the places that the 'next' type variable appears in your definition of Step
13:14:47 <johnw> where that tree's branches are defined by all the places that the 'next' type variable appears in your definition of Step
13:14:52 <joelteon> okay
13:14:56 <johnw> so look at Star (Step a next) next
13:15:04 <joelteon> so I have to terminate what's inside Star myself
13:15:04 <exicer> I have some behaviour in attoparsec that I don't understand : http://lpaste.net/105543
13:15:05 <johnw> the Star constructor refers to two sub-trees
13:15:15 <joelteon> because otherwise the rest of the block is a subtree
13:15:16 <johnw> one relating to what you want to match on, and the other relating to the rest of the string
13:15:33 <joelteon> okay, makes sense
13:15:35 <johnw> so when we build our value in the monad, we need to build the two sub-trees separately
13:15:52 <johnw> what you had done before made the rest of the monad be used for *both* subtrees
13:15:59 <johnw> because that's the nature of the Monad instance
13:16:14 <joelteon> so is there a way to write this intuitively with do-notation? I guess not
13:16:19 <johnw> it's also what the list monad works the way that it does too
13:16:32 <johnw> you need a combinator to make this more easily expressible
13:16:42 <johnw> something like: star (first do block) (second do block)
13:17:07 <johnw> star (step 'o' (return ()) $ do char 'b'; char's'
13:17:09 <johnw> something along those lines
13:17:27 <joelteon> okay
13:17:55 <johnw> oh, no, just: star (char 'o') (char 'b' >> char 's')
13:18:30 <johnw> to build these expressions up, btw, you're only going to need Applicative
13:18:48 <johnw> the Free monad only needs to use monads when you evaluate them down to an action in the base monad
13:18:59 <johnw> if that statement even made any sense :)
13:19:08 <joelteon> okay so in the earlier block, it's Free (Star (something not wrapped in Free)) (...)
13:19:15 <johnw> said another way: building up Step values only needs functor or applicative
13:19:17 <joelteon> but do-notation will be Free (Step Char) ao
13:19:19 <joelteon> a*
13:19:56 <johnw> Free $ Star (char 'o') $ do char 'b'; char 's'
13:19:59 <johnw> would also have worked
13:20:10 <johnw> so, star = (Free . ) . Star
13:20:20 <joelteon> oh it's trivial
13:20:26 <DanBurton> johnw: the part of that that didn't make sense to me was "use monads". I believe what you meant by that was "perform effects" or something?
13:20:28 <joelteon> star (Free f) m = Free (Star f m)
13:20:29 <johnw> yeah, these sorts of combinators usually are
13:20:50 <johnw> DanBurton: I mean that building a free monad value never "uses" the underlying monad as a monad
13:20:58 <johnw> i.e., in Free f a, f only needs to be a functor
13:21:15 <johnw> to reduce Free f a -> f a, you need some notion of what return and join mean
13:21:23 <DanBurton> oh, right. Free builds a monad out of a functor.
13:22:36 <johnw> joelteon: maybe this will help some: https://github.com/jwiegley/notes/blob/master/MoreFree.hs
13:23:07 <johnw> and maybe it won't :)
13:29:41 * hackagebot miniutter 0.4.4.0 - Simple English clause creation from arbitrary words  http://hackage.haskell.org/package/miniutter-0.4.4.0 (MikolajKonarski)
13:34:41 * hackagebot loops 0.2.0.1 - Fast imperative-style loops  http://hackage.haskell.org/package/loops-0.2.0.1 (ThomasTuegel)
13:39:57 <monochrom> big print: monads for free!¹  fine print: ¹functor fees apply.
13:40:22 <joelteon> so does regex-tdfa trade slow runtime for high space usage?
13:40:40 <monochrom> possibly
13:41:08 <monochrom> but I hope you don't really run into high space usage often
13:41:46 <joelteon> no, i'm just trying to understand the difference between perl's regex engine and thompson NFA
13:42:42 <joelteon> but I guess TDFA and NFA aren't really similar at all, are they
13:44:37 <exicer> Anyone got any idea why changing inClass "-'a-zA-Z"
13:44:44 <exicer> to inClass ".,-'a-zA-Z"
13:44:47 <exicer> stops my parser working ?
13:44:49 <exicer> http://lpaste.net/105543
13:45:27 <joelteon> exicer: because ",-'" is the range of chars from ',' to "'"
13:45:38 <monochrom> regex and NFA are pretty close. from NFA to DFA is where exponential blowup may happen.
13:45:45 <exicer> ..doh
13:49:17 <Boreeas> exicer: Also, . matches everything anyway
13:49:37 <avaritia> hey guys is there a way of defining efficient c-like enums in haskell?
13:49:43 * hackagebot io-memoize 1.1.1.0 - Memoize IO actions  http://hackage.haskell.org/package/io-memoize-1.1.1.0 (DanBurton)
13:49:59 <DanBurton> data MyEnum = One | Two | Three
13:50:04 <DanBurton> is pretty darn efficient
13:50:17 <benzrf> avaritia: yes, define an ADT
13:50:21 <benzrf> as DanBurton said
13:50:32 <DanBurton> Haskell booleans are defined this way. data Bool = True | False
13:50:49 <DanBurton> Bool is just another enum in Haskell
13:51:10 <benzrf> hmmm
13:51:12 <avaritia> thats the way i have it right now, but wouldnt it be slowed down by Constructor unwrapping and whatnot?
13:51:23 <benzrf> avaritia: what constructor unwrapping?
13:51:28 <monochrom> data ModernNumber = Click | DoubleClick | RageClick  deriving (Eq, Ord, Show, Num...)
13:51:44 <avaritia> the magic thing that happens when i do something like Just a = lookup sth  ?
13:51:44 <benzrf> is there something like pipes that actually operates legitimately parallel
13:52:09 <benzrf> avaritia: in c, it has to unwrap the names into values
13:52:11 <benzrf> better use int
13:53:10 <DanBurton> benzrf: funny, I've been working on exactly that. It's a subscribe/publish model. Still very pre-alpha.
13:53:52 <avaritia> benzrf, DanBurton : hmm ok thx
13:54:25 <benzrf> DanBurton: neato
13:54:30 <DanBurton> benzrf: what's your use case?
13:54:34 <benzrf> nothing, jw
13:54:44 <dwcook> I have two types, Generator and Generatee, where Generatees are only interesting in that they can be compared for equality, along with a function, Generator -> (Generatee, Generator). I would like only Generatees obtained from the same Generator or a Generator obtained from it this way to be comparable for equality; if this is possible, what modification must I make?
13:54:45 <benzrf> hmm, if i just wanted concurrency and not true parallelism
13:54:53 <DanBurton> @hackage pipes-concurrency --there's also this
13:54:53 <lambdabot> http://hackage.haskell.org/package/pipes-concurrency --there's also this
13:54:54 <levi> benzrf: Pipes-concurrent will operate multiple pipelines concurrently
13:55:03 <levi> Er, what Dan said
13:55:09 <benzrf> i wonder if it's possible to unwrap and interleave the processing of two pipes
13:55:12 <benzrf> p:
13:55:14 <benzrf> hm
13:56:36 <DanBurton> benzrf: What does it mean to interleave the processing of two pipes? Are they drawing from the same source? Sending to the same sink? Or are they leaving messages for each other?
13:56:51 <benzrf> hmmmm
13:56:58 <benzrf> leaving messages i suppose
13:57:30 <levi> The whole point of pipes is to interleave processing phases with production/consumption of data.
13:57:38 <benzrf> hmm
13:57:38 <tac_> Is there a standard way to embed ST computations into IO?
13:57:39 <benzrf> orite
13:57:54 <heatsink> There's the stToIO function
13:57:58 <tac_> @type stToIO
13:57:59 <lambdabot> ST RealWorld a -> IO a
13:58:02 <benzrf> i wonder if it would be possible to have a ZMQ-style-routing setup for things like pipes
13:58:04 <tac_> that's what I'm looking for. Thanks
13:58:17 <tac_> and the RealWorld thing will usually not appear explicitly in code
13:58:18 <levi> benzrf: Did you look at pipes-concurrency?
13:58:26 <benzrf> levi: o
13:58:28 <tac_> since "ST computation" is typically universally quantified over the store type
13:58:34 <tac_> riht?
13:58:36 <tac_> right?*
13:58:45 <benzrf> :t stToIO
13:58:46 <lambdabot> ST RealWorld a -> IO a
13:59:01 <tac_> :t readSTRef
13:59:02 <lambdabot> STRef s a -> ST s a
13:59:30 <tac_> :t newSTRef >>= readSTRef
13:59:31 <lambdabot>     Couldn't match expected type ‘ST s (STRef s b)’
13:59:31 <lambdabot>                 with actual type ‘a0 -> ST s0 (STRef s0 a0)’
13:59:31 <lambdabot>     Probable cause: ‘newSTRef’ is applied to too few arguments
14:00:16 <dwcook> newSTRef requires an initial value
14:00:54 <tac_> right
14:01:15 <tac_> But the resulting computation is universal with respect to the store type param
14:01:16 <benzrf> > newSTRef 3 >>= readSTRef
14:01:18 <lambdabot>  <<ST action>>
14:01:20 <benzrf> :t newSTRef 3 >>= readSTRef
14:01:21 <lambdabot> Num b => ST s b
14:01:21 <tac_> So you don't need to talk about RealWorld at all
14:01:26 <benzrf>       
14:03:47 <benzrf> help w/ pipes
14:06:13 <benzrf> oh wait
14:06:15 <benzrf> hmm
14:06:26 <benzrf> ok
14:07:34 <benzrf> heuh
14:07:56 <benzrf> ok, what if you have 2-way communication between an upstream and downstream pipe
14:08:01 <benzrf> or Proxy i guess
14:08:39 <benzrf> is it impossible to have one yield without forcing the other to provide a result?
14:08:44 <benzrf> oh wait polymorphic types
14:08:52 <benzrf> righto
14:08:54 <benzrf> :-D
14:08:57 <benzrf> now that is a neat trick
14:10:17 <ReinH> dwcook: phantom type?
14:10:21 <mmachenry> Does anyone know of a way to stream audio to an icecast or shoutcast server in Haskell as a source client?
14:10:35 <dwcook> ReinH: That was the general idea I had, but I don't know how I'd make it work.
14:10:55 <ReinH> me neither :)
14:11:18 <dwcook> I took a look at ST and the way it handles that sort of thing is with runST. I guess I could make an equivalent but I don't know what it'd do exactly.
14:14:40 <benzrf> good-by
14:15:09 <Redz> hello, at one point of my code, a Nothing is a desired result. I consider to use a Either a () instead. Both ways sound stupid, what should i do?
14:15:55 <bergmark> Redz: so a Just indicates an error?
14:16:01 <Redz> yes.
14:16:09 <johnw> define your Generator type to take a parameter that you only refer to on the left side
14:16:19 <johnw> data Generator a = Generator; data Generatee a = Generatee
14:16:20 <dwcook> Redz: Either a () seems reasonable, especially if you want to combine them with Applicative or Monad methods.
14:16:44 <johnw> now in order for 'a' to unify, it will have to either be the same type, or the same universal
14:17:14 <johnw> Generator a -> (Generator a, Generatee a)
14:17:33 <bergmark> Redz: you could also use Except e from transformers
14:17:50 <johnw> then, when you run your generator pipeline, you concoct a forall a. a and use that for 'a', and that will be unable to unify with anything else
14:17:53 <dwcook> johnw: Makes sense. How would I have a way of obtaining a Generator a where every a cannot be unified with any other obtained this way?
14:18:08 <johnw> see how runST does it, it's the same trick
14:18:13 <BeardedCoder> Redz: I noticed something interesting in Gabriel's errors package ("success monad"). http://hackage.haskell.org/package/errors-1.4.7/docs/Data-EitherR.html
14:18:21 <BeardedCoder> Redz: Not sure if usefull, but interesting.
14:18:32 <Redz> thank you guys. i'll check these.
14:18:48 <johnw> you're essentially create a type from thin air and then requiring that your pipeline be parameterized over only that type, which nothing else can ever refer to
14:20:22 <dwcook> johnw: The part I'm having trouble with is the running the "generator pipeline" you referred to.
14:20:31 <johnw> you mean, making the runGenerator function?
14:20:37 <dwcook> Yes, I suppose so.
14:20:57 <johnw> it'll probably have te type: runGenerator (forall s. Generator s a) -> Generator s a -> a
14:21:33 <johnw> and that should be it
14:21:34 <dwcook> Why does Generator have two type variables now?
14:21:46 <johnw> well, presumbly you are generating a value of some kind, right?
14:21:51 <dwcook> Yes, the Generatees.
14:21:53 <johnw> if it's fixed by the type, then drop the 'a'
14:21:55 <dwcook> Okay.
14:21:56 <johnw> ah
14:22:04 <johnw> runGenerator :: (forall s. Generator s) -> Generatee s
14:22:06 <johnw> oops
14:22:12 <johnw> wait, that won't work
14:22:14 <johnw> the 's' can't escape
14:22:26 <johnw> you're final type will need to be something that doesn't refer to 's'
14:22:28 <johnw> your*
14:22:46 <johnw> that's why I parameterized over 'a'
14:23:13 <dwcook> Right, but my goal is for Generatees of different origins to be not comparable, which isn't captured in runST at all.
14:23:49 <dwcook> Or doesn't seem to be.
14:25:10 <dwcook> I'm also not actually sure it's possible.
14:25:32 <johnw> can you show me the type of the function you'd like to have?
14:26:00 <dwcook> I haven't figured out the type of the thing that lets you obtain Generators. Right now it's just newGenerator :: Generator which is probably not going to work.
14:26:18 <dwcook> The only other operation I have is generate :: Generator -> (Generatee, Generator)
14:26:50 <johnw> newGenerator can work just fine
14:26:55 <johnw> newGenerator :: Generator s
14:27:08 <johnw> when you use that within the runGenerator I mentioned above, s will be substituted for that forall s. s
14:28:09 <dwcook> You mean runGenerator :: (forall s. Generator s) -> Generatee s? That's at least a misleading type, is that what you meant?
14:28:31 <dwcook> (Because there are two distinct s)
14:28:34 <johnw> right
14:28:36 <johnw> that cant' work
14:28:46 <dwcook> I don't know what other type you meant
14:29:39 <dwcook> I think I might need to change my set of operations for this to work
14:29:42 <johnw> you'd need a type more like this:
14:30:13 <dwcook> Because right now I can do: fst (generate newGenerator) == fst (generate newGenerator)
14:30:18 <dwcook> And that is undesirable
14:31:17 <johnw> runGenerator :: (forall s. (Generator s -> (Generatee s -> a) -> a) -> a) -> a
14:31:30 <dwcook> Hmm
14:31:33 <rwbarton> how about data SomeGenerator = forall a. SomeGenerator (Generator a)
14:31:44 <johnw> that is: you pass runGenerator a function that receives a function that takes your generator, and another function that consumes the Generatee it generates, and then reduces that to a value
14:31:47 <johnw> that way, the 's' never escapes
14:32:04 <dwcook> So I have to do it all in CPS essentially to meet the requirement?
14:32:08 <johnw> yes
14:32:16 <johnw> the CPS structure contains the 's'
14:32:54 <johnw> rwbarton: that won't match up with SomeGeneratee
14:32:56 <rwbarton> same idea is to write newGenerator :: SomeGenerator and then   case newGenerator of SomeGenerator g -> {- ... -} where the type a cannot escape
14:33:02 <rwbarton> there is no SomeGeneratee
14:33:14 <rwbarton> just Generator a -> (Generatee a, Generator a)
14:33:19 <rwbarton> instance Eq (Generatee a)
14:33:24 <johnw> he wanted a Generator/Generatee pair where they are married for life
14:33:37 <rwbarton> yep
14:34:39 <dwcook> Back in a moment, I'll try both approaches once I get back
14:34:47 <rwbarton> well not quite, you are supposed to be able to make a new Generator along with the Generatee and keep calling that function
14:35:42 <johnw> ahh
14:36:22 <johnw> that is not captured by my function
14:38:08 <johnw> to do it CPS'd I would need to capture the innermost function as a recursive data type
14:38:28 <johnw> so that the caller can determine when to stop looping
14:39:05 <rwbarton> well, there's nothing wrong with providing Generator a -> (Generatee a, Generator a) as an ordinary function
14:39:22 <johnw> it doesn't have the requirement he originally asked for
14:39:26 <rwbarton> you need to control access to newGenerator
14:39:39 <johnw> that the generatee generated from a particular generator is linked by type
14:40:04 <rwbarton> the new generator has the same type too, I think
14:40:14 * johnw imagines Andy Serkis saying, "Skolem, skolem.."
14:40:17 <rwbarton> I would like only Generatees obtained from the same Generator or a Generator obtained from it this way to be comparable
14:40:55 <johnw> wait, are you working on this too, or are you just asking it the way joelteon would?
14:41:01 <rwbarton> sorry
14:41:05 <rwbarton> imagine quotes
14:41:10 <johnw> :)
14:41:11 <joelteon> huh?
14:41:11 <rwbarton> That's what he wrote, originally
14:41:20 <johnw> joelteon: can you paste some code that I can hack on?
14:41:31 <johnw> i'd love more practice with Rank-N types and skolems
14:41:36 <joelteon> skolems
14:41:40 <joelteon> i'll try to do a skolem in a bit
14:42:28 <dwcook> Back, now I'm trying to find a definition for that CPS function :)
14:43:29 <dwcook> Hmm, doesn't that permit only receiving one Generatee? I'm confused
14:43:35 <avaritia> hmm i've got a adt with multiple records in it, is there a nice way of matching it in a function while avoiding the (A _ _ _ _ _ ) type of stuff?
14:43:39 <johnw> are you working on it too, dwcook?
14:43:55 <geekosaur> avaritia, (A {}) ?
14:43:59 <dwcook> johnw: On what? My problem? Right now I'm trying to understand how to implement the suggestions.
14:45:01 <johnw> ah
14:45:02 <dwcook> The existential one seems easier to understand, I'll try that one first then
14:45:06 <johnw> i'm trying it now with some pseudo-code too
14:45:22 <dwcook> By the way, my goal is basically to implement something like a pure Unique
14:45:37 <dwcook> That might've been implied from context already but just wanted to make that clear in case it helped
14:47:35 <avaritia> geekosaur: it works thank you :)
14:47:39 <johnw> joelteon: https://gist.github.com/1c2165819a2f5f374683
14:47:46 <johnw> that's a rough sketch of what I meant
14:48:06 <johnw> oops, add print $ before the call to runGenerator
14:48:07 <dwcook> johnw: Did you mis-highlight?
14:48:19 <johnw> huh?
14:48:54 <dwcook> I'm just confused how joelton got involved in the conversation
14:49:01 <johnw> also, my guess is that the arguments (Generator s -> (Generator s, Generatee s)) -> (Generatee s -> a) can be collapsed down to Generator s -> a
14:49:02 <johnw> oh!
14:49:07 <johnw> I didn't realize this was your problem dwcook :)
14:49:22 <dwcook> o_0
14:49:42 <dwcook> I didn't even see joelton say anything until you highlighted them
14:49:59 <johnw> i've updated the gist
14:50:05 <johnw> heh, joelteon hijacked your question!
14:50:12 <joelteon> what did I say
14:50:15 <joelteon> what happened
14:50:20 <johnw> now I'm totally lost
14:50:26 <johnw> I feel like a skolem outside his function
14:50:30 <dwcook> XD
14:50:41 <joelteon> the last thing i was talking about in here was turning a regex into an automaton
14:50:43 <dwcook> johnw: Yes, the question was mine. I asked it at 16:52.
14:50:52 <dwcook> (Eastern Standard Time)
14:51:58 <johnw> oh wow
14:52:06 <johnw> i've been talking to dwcook this whole time and didn't realize it
14:52:08 <johnw> sorry joelteon!
14:52:10 <dwcook> XD
14:52:25 <johnw> dwcook: updated gist again
14:52:41 <johnw> basically, I have a generator I can play with as much as I want, as long as I yield some 'a' at the end of it all
14:53:31 <johnw> the question is how you connect Generatee s to that a
14:53:38 <johnw> which is why I went with the type Generatee s a
14:53:45 <johnw> unless Generatee are fixed at some concrete type always
14:54:08 <dwcook> I'm implementing Generatee as a newtype of Integer
14:54:13 <johnw> ahh
14:54:20 <johnw> that makes things so easy then
14:54:41 <johnw> btw, we could very easily turn your generators into a simple-conduit
14:54:51 <johnw> sourceGenerator newGenerator
14:54:55 <johnw> that way, it hides all of the CPS'ing
14:55:00 <dwcook> I'm not familiar with that
14:55:08 <johnw> because I wrote it a week ago
14:55:17 <johnw> http://hackage.haskell.org/package/simple-conduit
14:55:17 <dwcook> I'm familiar with pipes however
14:55:19 <dwcook> Oh
14:55:25 <dwcook> Not conduit then
14:55:26 <johnw> i'll show you what it would look like
14:55:31 <johnw> no, much simpler ;)
14:58:42 <moghedrin> :t foldM
14:58:43 <lambdabot> Monad m => (a -> b -> m a) -> a -> [b] -> m a
15:00:08 <johnw> dwcook: here's the simple-conduit form: https://gist.github.com/00146ade8f55c7e899f6
15:00:22 <dwcook> So it seems like newGenerator and generate are fine to have around but not to expose past the module boundary if I want to keep this guarantee I'm looking for
15:00:36 <moghedrin> @pl (\x y -> return (x && y))
15:00:36 <lambdabot> (return .) . (&&)
15:01:17 <dwcook> johnw: Generating Integers doesn't seem satisfactory either since those can be manipulated too freely
15:01:18 <johnw> dwcook: right, not if you want to disallow the user from creating his own Generator Foo, for example
15:01:34 <dwcook> johnw: Or is that not what this code is doing?
15:01:51 <johnw> the code I pasted most recently is using your Generator scheme to produce an infinite stream of integers
15:02:21 <dwcook> I don't want Integers to be obtainable though, just the Generatee wrappers
15:02:29 <dwcook> Otherwise the user can create collisions
15:02:37 <johnw> ah
15:02:50 <johnw> then you need to provide an environment in which the user can use a Generatee
15:03:03 <johnw> I see
15:03:04 <johnw> one sec
15:03:04 <dwcook> They have an Eq instance
15:03:11 <dwcook> Also might as well Ord
15:03:53 <dwcook> I appreciate your taking the time to help me with this
15:04:11 <dwcook> as well as rwbarton
15:05:35 <Duta> http://lpaste.net/5553043807764742144 --> How would I force evaluation of 'compile', i.e. make it fully evaluated before 'execute'
15:05:52 <johnw> dwcook: then I think you need this: https://gist.github.com/424b1f18cdb3d61dae12
15:06:24 <johnw> that is, running a generator produces an infinite stream of generatees which can only be used by the provided function.  Since this infinite stream never terminates, the only thing you can do in it is to generate side-effects
15:06:27 <dwcook> Why is the Monad instance required?
15:06:32 <johnw> you could "end" the stream by using Either as your monad
15:06:33 <dwcook> Ah.
15:07:29 <dwcook> You know, I bet I could write this as a pipes Producer straightforwardly.
15:07:43 <johnw> let me see if I can write it as a simple-conduit; if so, then yes you could
15:07:44 <dwcook> Since I'm actually familiar with that.
15:07:55 <kazagistar> Duta: are you looking for seq?
15:08:50 <Duta> kazagistar: I think so, but (a) I haven't checked yet if it will be sufficient, and (b) I'm not sure how I'd work it into the function
15:09:43 <kazagistar> :t seq
15:09:43 <lambdabot> a -> b -> b
15:10:24 <kazagistar> Duta: the first parameter is evaluated before the second is returned
15:10:28 <darthdeus> is there a good way to combine Day and TimeOfDay into a UTCTime?
15:11:25 <kazagistar> Duta: you might have to use deepseq instead
15:12:34 <Duta> kazagistar: I saw deepseq. However, the question stands -- I don't know how to make compile run before execute, because execute depends on compile
15:14:13 <kazagistar> Duta: hang on, now I am confused... anything that execute needs will be provided as it needs it, without a need for anything special. I am not sure what the problem is
15:14:59 <Duta> The problem is I need compile to fully evaluate prior to execute being called
15:15:32 <johnw> dwcook: https://gist.github.com/782a5e0feddf0c314d20
15:16:00 <Duta> It /works/, currently, however if an error is thrown late in the evaluation of compile, it happens after execution has started
15:16:03 <johnw> this turns a generator into a conduit of integers by way of the generatee
15:16:50 <johnw> note that the "reduce" function here is fixed
15:16:55 <johnw> and this may still be exposing too much
15:18:44 <kazagistar> Duta: then deepseq is exactly what you need to use, by replacing "execute . compile" with "execute . force . compile"
15:18:55 <dwcook> johnw: It's still exposing Integers, no?
15:19:31 <Duta> Ah, I hadn't found force!
15:19:37 <Duta> Thanks, that's exactly what I was looking for
15:19:46 <johnw> dwcook: what do you want the "final" result to be?
15:19:50 <johnw> it can't be a Generatee
15:20:02 <johnw> somehow, somewhere, we have to reduce a Generatee into something else
15:20:04 <kazagistar> Duta: force x = deepseq x x
15:20:15 <dwcook> johnw: The user should be able to take as many Generatees as they want, but not be able to know that they're in fact Integers.
15:20:27 <dwcook> johnw: Well, maybe it could be made more polymorphic?
15:20:34 <johnw> dwcook: what will they do with those generatees?
15:20:51 <dwcook> johnw: Use their Eq and Ord instances. That's practically all that can be done.
15:21:00 <kazagistar> Duta: basically, it forces the parameter to evaluate, and then returns the same parameter... deepseq is the more generic version, which can return a different parameter
15:21:15 <dwcook> johnw: For example, imagine a map (Generatee a) SomeData
15:21:19 <dwcook> s/map/Map/
15:21:54 <dwcook> I tried the Producer route but I don't think I understand it any better than I did the generate function >_<
15:22:04 <dwcook> By which I mean it's deficient in the same way as generate
15:22:51 <dwcook> I wrote uniques :: (Monad m) => Producer (Unique a) m b but nowhere does that restrict the type enough
15:23:23 <dwcook> And I don't understand what yours is doing
15:23:30 <johnw> dwcook: this is the best I can do then: https://gist.github.com/6e2665b62008f020b881
15:23:50 <johnw> i.e.,: give me a generator and I'll give you a stream of generatee, and you have to decide how to yield some value at the end
15:24:02 <Duta> kazagistar: It works perfectly. Thank you!
15:24:22 <dwcook> johnw: That sounds exactly like what I need
15:24:29 <dwcook> I just need to figure out how to actually use it :)
15:24:37 <johnw> i'll show you use of it
15:26:21 <codygman> Why does "map (+1) [1]" work but "map (-1) [1]" doesn't?
15:26:40 <heatsink> (-1) parses as negative 1
15:26:52 <heatsink> You can write (subtract 1) for (\x -> x - 1)
15:27:09 <codygman> heatsink: Thanks
15:27:44 <zwer> (-1) is an annoying quirk in syntax
15:28:30 <johnw> dwcook: https://gist.github.com/4585024be24aa586f271
15:28:42 <johnw> that lets me interact with the first 100 generatees
15:28:56 <johnw> oh, duh, I could have used takeC, let me update
15:29:17 <dwcook> johnw: so, sourceGenerator is what'd be exposed past the module boundary?
15:29:23 <johnw> updated
15:29:35 <johnw> yes, sourceGenerator and newGenerator are it
15:29:43 <johnw> if you'd like to create of a new generator to be implied, we can drop that too
15:29:52 <johnw> it would simplify the types
15:29:56 * hackagebot picologic 0.1 - Utilities for symbolic predicate logic expressions  http://hackage.haskell.org/package/picologic-0.1 (sdiehl)
15:30:05 <dwcook> newGenerator seems like it'd let users create generators that lack the non-equality guarantee
15:30:17 <johnw> the problem is in my example, where I draw x and y
15:30:27 <johnw> do I want to draw them from two separate generators, or from the same generator?
15:30:41 <johnw> if I have access to newGenerator, I can decide that for myself
15:30:53 <johnw> but you're right
15:31:13 <dwcook> Well suppose you made a source of sources of generatees…?
15:31:19 <dwcook> Or even a lsit
15:31:21 <dwcook> list*
15:31:36 <dwcook> Actually no that wouldn't work
15:31:42 <johnw> or we could have a function withGenerator
15:33:33 <johnw> hmm.. no, that doesn't work
15:34:25 <dwcook> I'm trying something similar to what you did, will see if it works
15:35:53 <dwcook> I think (Monad m) => (forall s. Producer (Unique s) m a -> a) -> a suffices, actually
15:36:07 <johnw> ok
15:36:10 <dwcook> Checking
15:36:35 <dwcook> Or, that's unnecessarily restrictive
15:37:36 <moghedrin> Okay! Question! If I've got something like "x <- (liftM2 (&&)) clause1 clause2" inside the state monad, clause2's side effects on the state won't be evaluated if clause1 evaluates as False, right?
15:38:33 <dwcook> Actually I think I need a break to get my thoughts back in order. Thanks for your help, johnw
15:38:48 <johnw> sure thing, I have to run now too
15:38:49 <johnw> good luck!
15:38:55 <dwcook> Have fun
15:39:09 <heatsink> moghedrin, you can always check by expanding out the definition
15:39:27 <heatsink> @src liftM2
15:39:27 <lambdabot> liftM2 f m1 m2 = do { x1 <- m1; x2 <- m2; return (f x1 x2) }
15:39:27 <moghedrin> heatsink: What do you mean?
15:39:32 <moghedrin> Ah
15:39:36 <moghedrin> Didn't know I could do that.
15:39:37 <moghedrin> Damn.
15:39:42 <moghedrin> Answers my question! XD
15:40:03 <johnw> dwcook: also see https://gist.github.com/jwiegley/4585024be24aa586f271
15:40:16 <johnw> there instead of making newGenerator available, the generator-maker is also passed as an argument
15:40:19 <heatsink> I think there's a package that defines a short-circuiting monad version of &&
15:40:52 <johnw> heatsink: there are about 3 I think
15:42:23 <heatsink> The cond package has one
15:42:59 <moghedrin> :t andM
15:43:00 <lambdabot>     Not in scope: ‘andM’
15:43:00 <lambdabot>     Perhaps you meant one of these:
15:43:00 <lambdabot>       ‘and’ (imported from Data.List),
15:50:24 <dwcook> johnw: So as it turns out, CPS with an existential type variable with a stream of the generatees is indeed sufficient to preclude comparison of generatees from different streams! Thanks a lot for helping me figure that out
15:51:00 <darthdeus> chrisdone: hey, sorry for bothering you :P but you know in what cases would I get " Wrong type argument: stringp, nil" when running haskell-process-reload-devel-main?
15:51:24 <darthdeus> I have the session running
15:51:35 <dwcook> My test gives a type error as desired: withUniques $ \a -> withUniques $ \b -> Pipes.Prelude.zip a b >-> liftM (\(a', b') -> a' == b') await >-> Pipes.Prelude.print
15:51:55 <dwcook> So, problem solved :)
15:53:19 <darthdeus> if i :load DevelMain.hs it works :|
15:54:09 <darthdeus> ha seems to work now that i opened DevelMain.hs in a buffer and switched back
15:55:41 <t4nk310> whatever happened to the habit programming language? if i remember it was haskell for low level programmers, and did it ever get a formal verifier?
16:00:47 <jaroldd> excuse the raunchy trivia, but given this question: "Nine heterosexual men and nine heterosexual women are in a house together for a night, during which all 18 pair off and have sex. How many possible pairings are there?"
16:00:53 <jaroldd> is the answer not 36?
16:01:17 <pjdelport> How heretoflexible are they?
16:01:23 <jaroldd> > do { x <- [1..9]; y <- [x+1 .. 9]; return (x, y) }
16:01:24 * pjdelport ducks
16:01:24 <lambdabot>  [(1,2),(1,3),(1,4),(1,5),(1,6),(1,7),(1,8),(1,9),(2,3),(2,4),(2,5),(2,6),(2,...
16:01:30 <jaroldd> > length $ do { x <- [1..9]; y <- [x+1 .. 9]; return (x, y) }
16:01:31 <lambdabot>  36
16:04:30 <pjdelport> jaroldd: That's how many choices there are for a single pairing out of all of them, but now how many unique configurations of choices there are for all 18.
16:05:07 <jaroldd> pjdelport I don't understand the difference.. and I can't see any of the pairings I am missing
16:05:21 <heatsink> It should be the number of 9-element permutations
16:06:14 <jaroldd> my mistake, man #1 can have sex with woman #1
16:06:19 <jaroldd> I am still getting only 81 combinations
16:06:43 * hayrom new canal #cvv2
16:06:43 <jaroldd> > length [(x, y) | x <- [1..9], y <- [1..9] ]
16:06:44 <lambdabot>  81
16:06:50 <pjdelport> jaroldd: You're just picking a single choice.
16:07:40 <jaroldd> hmm
16:07:42 <shachaf> jaroldd: I feel like there would be a better way of phrasing this problem with a very small amount of effort.
16:08:08 <jaroldd> shachaf no sex, fun allowed in here?
16:08:55 <pjdelport> jaroldd: It's the difference between asking (a) How many different ways are there to pick two toothpicks from two piles, and (b) If you threw all the toothpicks on the ground in pairs, how many unique ways are there for them to land?
16:09:11 <pjdelport> That's probably a sucky explanation, but eh.
16:09:18 <jaroldd> I am still not seeing it.. I'll think about it
16:09:29 <simon> jaroldd, I don't get it. heterosexual men can't have sex with other men?
16:09:32 <jaroldd> the answer is supposedly 362,880
16:09:38 <pjdelport> jaroldd: Right.
16:10:03 <jaroldd> simon not in this trivia :)
16:10:25 <pjdelport> jaroldd: Consider the process of choosing. The first item can be paired with 9 possible choices. Then, the next item can be paired with 8 possible choices. Then, the next with 7, etc.
16:10:48 <simon> jaroldd, Discovering Assumptions is a nice essay on that. http://niquette.com/books/sophmag/heurist.htm
16:11:09 <pjdelport> jaroldd: So on up to the last pair of items, which just go with each other.
16:11:40 <pjdelport> jaroldd: So, since those choices are independent, the number of possible choices altogether is the product of them.
16:12:05 <pjdelport> > product [9, 8 .. 1]
16:12:06 <lambdabot>  362880
16:12:23 <pjdelport> or 9! in other words
16:13:40 <jaroldd> can you give me an example of one pair I am missing in here? [(x, y) | x <- [1..9], y <- [1..9]]
16:15:17 <dottedmag> jaroldd: single pairing here is a set of 9 pairs.
16:15:21 <jaroldd> I am* pairing the first first item with 9 choices, the next item with 8 choices, etc
16:15:54 <dottedmag> So the first one will be ((1,1), (2,2), (3, 3)... (9,9))
16:16:08 <dottedmag> Second one will be ((1,2), (2,1), (3,3), ...(9,9))
16:16:09 <dottedmag> etc
16:16:44 <jaroldd> oh..
16:17:06 <jaroldd> pairing are different, even if we are repeating some pairs
16:17:09 <jaroldd> pairings*
16:17:46 <jaroldd> is that where the tricky part lies?
16:18:32 <jaroldd> the way I've read the question was "how many possible pairs are there"
16:19:54 <dottedmag> pairs/pairings are different things, though the words are confusingly similar.
16:25:41 <jaroldd> > take 10 $ zip (repeat [1..9]) (permutations [1..9])
16:25:43 <lambdabot>  [([1,2,3,4,5,6,7,8,9],[1,2,3,4,5,6,7,8,9]),([1,2,3,4,5,6,7,8,9],[2,1,3,4,5,6...
16:25:47 <jaroldd> > length $ zip (repeat [1..9]) (permutations [1..9])
16:25:48 <lambdabot>  362880
16:25:50 <jaroldd> is that it?
16:27:25 <dottedmag> yep
16:27:45 <jaroldd> yay :)
16:36:52 <frontendloader> > permutations [1..9]
16:36:53 <lambdabot>  [[1,2,3,4,5,6,7,8,9],[2,1,3,4,5,6,7,8,9],[3,2,1,4,5,6,7,8,9],[2,3,1,4,5,6,7,...
16:37:25 <jaroldd> nicer representation of the above.. (and now I am done dwelling on this)
16:37:28 <jaroldd> > zipWith (\x y -> zip x y) (repeat [1..9]) (permutations [1..9])
16:37:29 <lambdabot>  [[(1,1),(2,2),(3,3),(4,4),(5,5),(6,6),(7,7),(8,8),(9,9)],[(1,2),(2,1),(3,3),...
16:38:33 <simon> @pl \x y -> zip x y
16:38:34 <lambdabot> zip
16:38:36 <simon> :)
16:38:53 <jaroldd> haha, I knew that one but I didn't notice it
16:39:12 <jaroldd> don't think I have used zipWith zip before
16:39:15 <simon> I did zipWith (zipWith ...) once before... it feels... wrong!
16:42:18 <jaroldd> quite concise.. if there was a golf competition that haskell could win, this is the one
16:42:23 <jaroldd> main = mapM_ print $ zipWith zip (repeat [1..9]) (permutations [1..9])
16:52:22 <simon> I can't get it shorter, but I can make it more cryptic:
16:52:28 <gamegoblin> AHA if anyone was on here last night when I was puzzling over the use of WHNF in attoparsec, I have figured it out. bos defines a special liftM2 (liftM2’ — note apostrophe) that is strict in the first action
16:52:30 <simon> main = mapM_ print . uncurry (zipWith zip) . (repeat &&& permutations) $ [1..9]
16:58:17 <darthdeus> is there a builtin parser for time? like "11:23"
16:59:27 <pavonia> Yes, the time package has one
17:00:07 * hackagebot mwc-random 0.13.1.2 - Fast, high quality pseudo random number generation  http://hackage.haskell.org/package/mwc-random-0.13.1.2 (BryanOSullivan)
17:06:40 <AlainODea> if I have a 1 billion element bitmap (~125MB), what is an efficient way to process bitwise updates?  It's essentially a giant flagset and updates come in the form of a bit location either being turned on or off
17:09:35 <rinder> I am getting stack overflow after running my program for two hours.. what should I look into? program is too large to paste, and I was not able to write a proper test case
17:09:58 <rinder> is there a way to debug this?
17:10:10 <jfischoff> look at your loops
17:10:37 <jfischoff> usually adding ! on the arguments to loops is enough
17:10:45 <jfischoff> or can be enough
17:10:59 <rinder> I have tried that but without luck
17:11:12 <rinder> I added it to my main loop
17:11:22 <jfischoff> is that the only loop?
17:12:05 <jfischoff> what about things like logs? are you building up a big list anywhere that should be consumed
17:12:13 <rinder> the only loop that runs from the beginning until the end of the program. also, the only loop that recurses long enough to cause this, AFAICT
17:12:23 <fread2282> rinder: run with memory profiling
17:12:40 <jfischoff> yes do that
17:12:57 <fread2282> (heap profiling)
17:12:59 <jfischoff> although I find for slow leaks it is a pain
17:13:23 <rinder> I will try that
17:15:06 <boov> hi
17:15:18 <boov> which holocaust was your favourite one?
17:16:34 <boov> which holocaust was your favourite one?
17:16:58 --- mode: ChanServ set +o shachaf
17:17:01 --- mode: shachaf set +b *!*boov@*.neoplus.adsl.tpnet.pl
17:17:01 --- kick: boov was kicked by shachaf (boov)
17:17:03 --- mode: shachaf set -o shachaf
17:20:51 <pavonia> AlainODea: You could use an array of Words and update the bits with Data.Bits where you get the indices by modular arithmetric
17:21:34 <AlainODea> pavonia: I'll give that a shot.  Thank you :)
17:35:48 <centrinia> They don't have "buffalo" as a verb: http://demo.ark.cs.cmu.edu/parse?sentence=i%20buffalo
17:39:47 <Cale> centrinia: "buffaloes" seems to be identified
17:40:00 <Cale> (Try "He buffaloes")
17:40:59 <centrinia> But not "buffalo" :( http://demo.ark.cs.cmu.edu/parse?sentence=Buffalo%20buffalo%20Buffalo%20buffalo%20buffalo%20buffalo%20Buffalo%20buffalo
17:42:33 <kazagistar> the neat thing about that sentence is that it can expand further
17:43:55 <Shoop> Beginner here, I think I'm starting to understand monads. But I'm still confused - Can anyone explain when it is appropriate to use monads (or point to a resource that explains it)?
17:44:05 <fread2282> how can I tell haddock that I documented a function (I have 1-function classes and the docs live on the class, not the functon) for stats?
17:44:07 <benzrf> Shoop: dont worry about it
17:44:32 <Cale> Shoop: Monad is a general interface that various libraries fit into, it's appropriate to use the monad operations when the library you're using happens to define a monad.
17:44:39 <Shoop> benzrf: how will i know when to use them?
17:44:41 <benzrf> Shoop: if you find yourself doing things with a value resembling bind independently of the Monad typeclass, see if the type is a monad
17:44:49 <benzrf> Shoop: otherwise, just do what seems appropriate
17:44:54 <Cale> Shoop: You'll use the operations when there happens to be an instance of the Monad type class.
17:45:25 <Shoop> So basically just code until I figure out that I've made a monad on accident?
17:45:32 <Shoop> and then fix it
17:45:33 <kazagistar> Shoop: if you are asking "where should I create an instance of a monad", the answer is "when you notice that it would fit"
17:45:36 <kini> hmm, that parser doesn't seem to much like the first two sentences of Great Expectations
17:45:49 <Shoop> mhmmm
17:45:54 <Cale> Shoop: Yeah, you should never *set out* to define a monad
17:46:02 <Shoop> ok
17:46:15 <Cale> Shoop: It should always be "Oh, look, this thing I defined happens to be a monad"
17:46:28 <Shoop> yes
17:46:33 <Cale> If you try to go the other way, you'll just cripple your options for designing the library
17:46:34 <kazagistar> Shoop: of course, perhaps you will see monads created by others, like Free monads or parser combinators or whetever, and get inspired
17:47:03 <fread2282> Shoop: if you're asking "when should I use mtl?" the answer is that using mtl a lot is one way to structure your program, but often there is a more elegant way that uses mtl less
17:47:20 <Cale> Yeah, it comes out of writing libraries with a type whose values represent computations, parameterised by the type of result of that computation.
17:47:30 <fread2282> and if you're making a library, then as little as possible
17:48:11 <Cale> This is a common thing to do in functional programming, so a lot of things happen to end up being monads, but sometimes you get something a little different.
17:48:21 <Shoop> Also I know that it is considered good practice to separate IO functions from pure functions, but what do I do if i have a function that needs to use a value grabbed from IO but that function gets called layers down in the call stack? Do I have to pollute my arguments and pass it all the way down?
17:48:33 <Cale> Shoop: It's usually best to do that
17:48:37 <Cale> Don't think of it as pollution
17:48:47 <Cale> It's being explicit about what things the function depends on
17:48:48 <Shoop> Cale: is there any other way to encapsulate it?
17:48:53 <benzrf> Shoop: it's possible that you're just structuring your program poorly
17:49:17 <benzrf> Shoop: you get used to doing impure stuff from deep within your logic, and you keep thinking that way when you make the jump
17:49:35 <benzrf> but once you get the hang of designing functionally, that should stop being as much of a problem
17:49:35 <Cale> There are some other options, but I would *start* with that one, and worry about designing my types a bit better once I can see how the program uses the values.
17:49:38 <benzrf> ;)
17:49:46 <Shoop> benzrf: Well I am programming a word game and it reads a dictionary from a file and a bunch of functions way down depend on that dictionary
17:49:58 <Cale> Often you can package lots of "configuration" together into one parameter of some appropriate data type.
17:49:59 <benzrf> Shoop: you could use the Reader monad
17:50:05 <fread2282> Shoop: mostly unrelated, but check out lens
17:50:37 <Shoop> Since the dictionary is a static file I've been using unsafePerformIO since I decided it wasnt too sinful
17:50:41 <Shoop> but ill look at those, thanks
17:50:43 * benzrf slaps Shoop 
17:50:45 <kazagistar> Shoop: often, you can get the value first, and pass it in as a pure value
17:50:47 <benzrf> DONT USE UNSAFEPERFORMIO
17:51:02 <Cale> Yeah, lens is mostly interesting from the perspective of managing complicated nested record types you might end up with in a situation where you have lots of configuration packed into one value.
17:51:30 <Shoop> The best thing would be to load the dictionary as a pure value at compile time, that possible easily?
17:51:51 <kazagistar> Shoop: just fmap over the pure wordsearch function
17:52:01 <Cale> You could maybe use Template Haskell to build a constant value in your code
17:52:19 <Shoop> then the wordsearch function gets IO monad polluted and then everything becomes impure
17:52:25 <Cale> But it's really not that hard to load a dictionary and pass it to the functions which need it
17:52:37 <Cale> Just parameterise the functions on a list of strings
17:52:42 <Shoop> Cale: so thats probably just the best practice
17:52:46 <Shoop> mhmmm
17:52:48 <kazagistar> Shoop, the wordsearch can stay pure
17:53:00 <Shoop> kazagistar: how?
17:53:04 <Shoop> I tried
17:53:29 <kazagistar> wordsearch :: Dictionary -> Page -> Locations
17:53:39 <Cale> Yeah, you just load the file at the top of main, like words <- fmap lines (readFile "/usr/dict/words") and then you have a value words :: [String] which you can pass to things
17:53:48 <Shoop> oh I see
17:54:08 <kazagistar> :t liftM2
17:54:09 <lambdabot> Monad m => (a1 -> a2 -> r) -> m a1 -> m a2 -> m r
17:54:11 <benzrf> jesus dick monad transformers can be such a goddamn pain
17:54:19 <benzrf> why isnt there a generic lift
17:54:27 <Cale> benzrf: They're usually more trouble than they're worth
17:54:34 <benzrf> we need a better effect model
17:54:35 <Shoop> :t liftM5
17:54:36 <Cale> benzrf: lift is the generic lift
17:54:36 <lambdabot> Monad m => (a1 -> a2 -> a3 -> a4 -> a5 -> r) -> m a1 -> m a2 -> m a3 -> m a4 -> m a5 -> m r
17:54:43 <joelteon> lift is the generic...yeah, that.
17:54:44 <Shoop> ow
17:54:45 <benzrf> Cale: i mean for multipe levels
17:54:56 <Cale> benzrf: Well, that's inherently ambiguous
17:55:10 <benzrf> Cale: i.e. you lift any component mobit into a full stack mbit
17:55:12 <benzrf> *mobit
17:55:13 <joelteon> benzrf, it's usually a better idea for your library functions to be of type (MonadState Int m, MonadWriter [String] m, ...) => m (...)
17:55:15 <fread2282> benzrf: liftBase?
17:55:25 <benzrf> :t liftBase
17:55:26 <Cale> People actually use the word "mobit"? :D
17:55:26 <lambdabot> Not in scope: ‘liftBase’
17:55:28 <joelteon> that way, your entire program is a polymorphic value.
17:55:36 <benzrf> Cale: i try to
17:55:38 <fread2282> benzrf: transformers-base
17:55:40 <joelteon> if you want to add a logging layer, it's simple. add MonadLogger m to your context.
17:55:43 <Cale> That was a joke word that someone made up here at one point
17:55:47 <kazagistar> Shoop: so then { lift2M wordsearch (readDict "dict.txt") (readPuzzle "puzzle.txt") }
17:55:48 <benzrf> Cale: oh was it
17:55:52 <Cale> I just call them actions
17:55:58 <benzrf> i saw it and thought it was easier to type than 'monadic value'
17:56:02 <benzrf> Cale: actions is a loaded term
17:56:04 <benzrf> -.-
17:56:06 <Cale> Also, I avoid using the word "stack" altogether in this context
17:56:09 <Cale> I think it's unhelpful
17:56:11 <kazagistar> Shoop: the wordsearch stays pure, but then we lift it into the impure world later
17:56:24 <benzrf> joelteon: how /do/ the MonadX classes work anyway
17:56:56 <Shoop> kazagistar: thats cool, but I don't think I have a strong enough understanding of monad transformers
17:57:02 <joelteon> benzrf: if you look at the instances, you'll see that it's a common pattern to provide a concrete datatype (like StateT) for which you provide an instance
17:57:08 <joelteon> then you also provide a typeclass, like MonadState
17:57:10 <Shoop> kazagistar: time to reread lyah
17:57:11 <Cale> benzrf: If you do things right, you should only have lifts in the module which defines your new monad, and it should be impossible to tell that you're using monad transformers from outside that (hopefully smallish) module.
17:57:11 <fread2282> benzrf: the layers haddock gives a good summary of the problem and the solutions w/ lift
17:57:14 <kazagistar> Shoop: this isnt a monad transformer though, its just a lift
17:57:26 <benzrf> fread2282: what do the classes do?
17:57:26 <kazagistar> :t liftM2
17:57:27 <lambdabot> Monad m => (a1 -> a2 -> r) -> m a1 -> m a2 -> m r
17:57:29 <benzrf> :t liftIO
17:57:30 <lambdabot> MonadIO m => IO a -> m a
17:57:30 <Shoop> :t liftM
17:57:31 <lambdabot> Monad m => (a1 -> r) -> m a1 -> m r
17:57:35 <joelteon> There's an instance for MonadState s m => MonadState s (SomeMonadTransformer m)
17:57:51 <Cale> benzrf: You should define operations for your new monad which make it unnecessary to lift other computations, because all the primitives you need are already there.
17:57:59 <joelteon> that way, the return type of a state action (like "put ()") can be of any type for which a MonadState instance exists.
17:58:00 <fread2282> benzrf: the mtl classes do the lifting for you
17:58:01 <Shoop> so lift is like fmap on steroids kind of
17:58:12 <kazagistar> Shoop: it takes a pure function, and 2 (or however many) IO actions returning the values needed by the pure function, and constructs an IO action that returns the result of the pure function
17:58:13 <benzrf> Shoop: liftM is just fmap
17:58:21 <benzrf> Shoop: the types are different because of historical reasons
17:58:24 <Shoop> benzrf: oh ok
17:58:31 <benzrf> Shoop: but in real life all Monads should also be Functors
17:58:34 <kazagistar> Shoop: yeah, it just lets you lift more... you can also use do notation for more flexibility
17:58:34 <joelteon> What do you call it, Cale? Recursive instances?
17:58:35 <fread2282> benzrf: http://hackage.haskell.org/package/layers-0.1/docs/Documentation-Layers-Overview.html
17:58:37 <benzrf> even though strictly the language doesnt force you to
17:58:38 <Cale> Shoop: liftM is the same thing as fmap, only specialised to monads (and defined in such a way that it provides a valid definition of fmap for anything you can define (>>=) and return for)
17:59:23 <benzrf> 08:55 < joelteon> There's an instance for MonadState s m => MonadState s (SomeMonadTransformer m)
17:59:31 <benzrf> joelteon: so you write one of those for every MT?
17:59:37 <joelteon> well, library providers usually do.
17:59:37 <benzrf> yug
17:59:48 <joelteon> yeah, it's boilerplate. On the plus side, that means you, the end user, don't have to.
17:59:50 <benzrf> that grows by x^2
17:59:51 <benzrf> o.0
17:59:51 <Cale> joelteon: What do I call what? A bunch of monad transformers that have been applied to some monad?
17:59:55 <Cale> (just that)
18:00:01 <joelteon> Cale: No, the way mtl does "automatic" lifting
18:00:16 <Shoop> If I want to try to write my own monad to help learn it, what would be a good project I could eventually turn monadic
18:00:23 <joelteon> instance SomeMonad m => SomeMonad (SomeTransformer m)
18:00:25 <benzrf> Shoop: dont worry about monads man!
18:00:28 <joelteon> is there a name for that?
18:00:32 <benzrf> just use them when they become relevant in your code
18:00:37 <Cale> joelteon: Oh, automatic lifting is untenable in general, because it requires O(n^2) instances, so I tend to ignore that it even exists.
18:00:41 <Shoop> benzrf: but they look shiny!
18:00:47 <benzrf> Cale: hey, i just said that!
18:00:50 <mingzegao> hi
18:00:50 <joelteon> Oh. So that isn't best practice?
18:00:58 <benzrf> 08:57 < benzrf> that grows by x^2
18:01:03 <Cale> joelteon: Well, it's a matter of taste
18:01:17 <Cale> joelteon: I personally think that monad transformers are highly overrated
18:01:40 <joelteon> I prefer it to wrapping things in lift if I ever need to add a new constraint.
18:01:47 <Cale> and I only use them to craft monads which are immediately newtyped, with data constructor not exported
18:01:48 <joelteon> or another capability, I guess you could call it.
18:02:23 <Cale> and I tend to want to hide the fact that monad transformers are in use from external modules
18:02:42 <benzrf> earlier i was thinking about whether it could be possible to create some kind of data structure that represents a transformer stack, containing functions for lifting and binding each monadicsausage
18:02:46 <joelteon> Okay, that's interesting.
18:02:48 <benzrf> * each monad
18:03:08 <Cale> This has two good effects on the code (at least as I see it)
18:03:19 <benzrf> and if that could be passed into a function that autolifts arbitary combinations of monads in the stack structure
18:03:40 <Cale> One is that it forces you to clearly define an interface of primitives and combinators for your new monad
18:03:47 <benzrf> but i guess that's not really possible since not every MT takes the form MonadT m a = MonadT (m (Monad a))
18:04:18 <Cale> You can't rely on clients to do that if you're not going to export the newtype's data constructor, and in exchange, clients don't *have* to lift everywhere.
18:05:15 <Cale> Secondly, it means that if you ever change the definition of the monad, by for example inserting a new monad transformer, or obliterating the use of monad transformers to define the thing directly (which is sometimes necessary for performance reasons), the code you have to change in response is all in one place.
18:05:55 <Cale> (you don't have lifts all through your code and other people's code which have to be updated to deal with the new monad transformer or whatever)
18:06:20 <benzrf> we need a new effect model!
18:06:23 <benzrf> monads are dumb!
18:06:26 <Cale> I don't think we do
18:06:33 <benzrf> i kid i kid
18:06:34 <darthdeus> is it possible that i'll get "Could not find module ‘Database.Persist.Sql.Types' it is a hidden module in the package ‘persistent-1.3.1.1’" even if i have that package in my build dependencies?
18:06:38 <benzrf> pls dont hurt me q.q
18:06:42 <Cale> There are people playing with complicated effect models with dependent types
18:06:54 <Cale> But I don't find them terribly convincing myself
18:06:59 <Cale> It's worth looking at
18:07:15 <Cale> Well, there's things like FRP systems
18:07:28 <Cale> and those can be cool, but they're more specialised
18:08:27 <Cale> darthdeus: That module isn't exposed by the package, it's internal
18:08:32 <Cale> darthdeus: So you can't import it
18:08:37 <darthdeus> ah :\
18:08:51 <darthdeus> what should I do if i need to use a type from it in my type signature?
18:08:52 <Cale> There's Database.Persist.Types
18:09:46 <johnw> dwcook: great!
18:09:51 <heatsink> I sometimes wish for more expressive effects when I'm working with mutable objects
18:09:59 <Cale> Wait, that module doesn't even exist internally to the package
18:10:12 <enthropy> is there something to convert between lhs and hs and preserve comments?
18:10:14 <heatsink> It would be nice to have a finer-grained effect than "mutates the state"
18:10:16 <Cale> er, oh, it does
18:10:28 <benzrf>     
18:10:43 <Algebr> /#join rust
18:10:45 <Cale> darthdeus: Which type?
18:10:47 <darthdeus> Cale: it exists, uhm thep roblem is that i need to use SqlBackend in my signature
18:11:13 <Cale> darthdeus: That type is exported by Database.Persist.Sql
18:11:22 <heatsink> was that for me, Algebr?
18:11:28 <Algebr> No sorry
18:11:35 <darthdeus> Cale: cool, you're right, thanks :)
18:11:40 <Cale> http://hackage.haskell.org/package/persistent-1.3.1.1/docs/Database-Persist-Sql.html#t:SqlBackend
18:11:46 <Algebr> I was wondering, the rust reddit post has this: http://www.reddit.com/r/rust/comments/1nvsdh/a_note_on_conduct_please_read/ does Haskell community have something similar?
18:12:02 <athan_> What's an ExitFailure (-11)? There's literally nothing to see in `cabal install -v3` or the sandbox's log o.o
18:12:45 <Algebr> Python similiarly has, https://www.python.org/psf/codeofconduct/
18:12:51 <athan_> well, not literally, sorry for the over exaggeration, I'm just dumbfounded
18:13:05 <StahlGrau> quit
18:13:16 <johnw> i believe that's SIGSEGV, isn't it?
18:13:16 <Cale> Algebr: #haskell has one rule, it's Be Nice.
18:13:31 <johnw> #define	SIGSEGV	11	/* segmentation violation */
18:13:46 <Cale> It hasn't been necessary to spell out a code of conduct in any more detail than that.
18:13:51 <benzrf> alright
18:14:02 <benzrf> hmm
18:14:29 <Algebr> Cale: So its a Justice Potter kind of "You know it when you see it" kind of definition.
18:14:35 <benzrf> i have a idea
18:14:38 <benzrf> p:
18:14:43 <benzrf> but later
18:15:18 <Cale> Algebr: Basically, anything which would be a problem is also very likely to be offtopic and inappropriate for that reason also.
18:15:38 <Cale> But yes
18:15:43 <byorgey> Algebr: the haskell.org committee has been discussing this, actually.
18:16:07 <johnw> byorgey: are you coming to OPLSS?
18:16:16 <byorgey> anyone's thoughts on the issue are welcome
18:16:16 <Algebr> FWIW, I think it would be beneficial to have a formal code of conduct.
18:16:32 <johnw> I don't think a formal code would either help or hurt right now
18:16:34 <AlainODea> pavonia: hilarity ensues at least with "let data = Data.Vector.replicate 1000000000 (0::Data.Word.Word8) ; data ! 123456789".  My entire laptop almost froze solid when I ran that.  The first operation is effectively instantaneous, the second appears to be extremely intense.
18:16:44 <byorgey> Algebr: why do you think it would be beneficial?
18:16:51 <jmcarthur> i'm afraid of having a code of conduct, because as soon as you have one, now you're going to be inclined to just follow it, including whatever flaws it has, instead of practicing situational judgement.
18:16:54 <Cale> byorgey: I'm not sure it's something worth dwelling on too extensively. If there are specific issues, deal with them as they arise?
18:17:00 <johnw> AlainODea: the first "operation" is really just a promise to do that operation when required
18:17:02 <Cale> Yes
18:17:11 <byorgey> Algebr: (I'm not contradicting you, just genuinely curious)
18:17:55 <Algebr> byorgey: Because this community has a reputation of being snobbish and vehemently attacking other styles of coding.
18:18:03 <Cale> What?!?
18:18:09 <Cale> Algebr: Since when?
18:18:28 <Cale> Well, what do you mean "attacking"?
18:18:44 <byorgey> Algebr: I'm very sorry to hear that.
18:18:54 <Algebr> Through many a twitter flame war, and I've heard snobbish as such in person at numerous meetups in the NYC area.
18:18:55 <benzrf> Algebr: it's sort of tru
18:18:57 <pavonia> AlainODea: Oh wow, vector is supposed to be pretty efficient AFAIK
18:19:03 <AlainODea> johnw: good point.  That explains a lot.  Perhaps it is the allocation that is time consuming.  That makes way more sense
18:19:07 <byorgey> most people I know in this community certainly don't want that.
18:19:14 <Cale> If you mean "we know that certain approaches to constructing programs are bad, and aren't afraid to point that out", well, sure.
18:19:22 <benzrf> i have observed haskellers being snobby about FP being the best tool for any job
18:19:29 <benzrf> or haskell itself
18:19:51 <byorgey> Algebr: to be honest, I kind of doubt a formal code of conduct would help with snobbishness though.
18:19:55 <benzrf> i once got in an argument on 4chan with Fuuzetsu about whether it's ever appropriate to use python over haskell, remember?
18:19:58 <Cale> Well, there are a lot of cases where people are just using suboptimal tools out of inertia
18:19:58 <Algebr> Cale: There's a difference of saying "your current style of coding isn't the best way" and "if you're doing it this way, you're part of the cancer of the industry"
18:20:06 <byorgey> though I think there may be other good reasons to adopt one.
18:20:06 <jmcarthur> "randomX: You are clearly in violation of rule 2.3.1 of the Haskell IRC Channel Code of Conduct and are hereby banned for the minimum period of one week. You will be eligible for readmittance to the channel after a thorough review by a committee of no less than five volunteers from the Haskell Ops group."
18:20:19 <Cale> Algebr: Personal attacks are not considered appropriate
18:20:31 <Cale> and I don't think we have a reputation for those
18:20:39 <Algebr> Many people code to to get bread on the table, not for philosophical reasons.
18:20:41 <Cale> (at least, if we do, it's ill-founded)
18:20:56 <byorgey> jmcarthur: I really don't think that would happen.
18:21:16 <djahandarie> Cale, it's worth pointing out that the Haskell community is much larger than #haskell these days, and I'm not sure if you see all of it (I certainly know I don't).
18:21:21 <jmcarthur> byorgey: yeah, this is beyond exaggeration
18:21:32 <Cale> djahandarie: Well, that's true
18:21:59 <byorgey> Algebr did specifically mention twitter and NYC meetups, not #haskell
18:22:06 <Cale> In any case, I don't see that there's anything to be gained by attempting to formalise rules.
18:22:07 <AlainODea> pavonia: I think I need to play around a bit more.  I'm misusing it and I need to read the Haddocks/Tutorial thoroughly
18:22:32 <Algebr> Cale: Then the other groups that have formalized rules are clearly mistaken and have wasted their time?
18:22:37 <Cale> Algebr: Probably
18:22:41 <platz> rules are only effective if role models adopt them
18:23:12 <Algebr> I see, we really do have all the answers.
18:23:18 <AlainODea> Data.Vector.take 3 y
18:23:19 <byorgey> Algebr: as I said, there are other good reasons for adopting formal codes of conduct.  But I don't think stopping snobbishness is one of them.
18:23:38 <jmcarthur> byorgey: A more realistic kind of negative outcome I would anticipate is that there are several minor conflicts which are "settled" by reference to the rules. Major conflicts would get the attention they really need, but there would be an uncomfortably large collection of minor issues that don't. Contrast with right now; ops are constantly discussing their decisions and learning how to foster a better
18:23:41 <jmcarthur> environment.
18:24:03 <Cale> Yeah, the best thing for people to do is just to be good people, to the best of their own ability, and (politely) call people out on (what they see as) negative behaviour if and when it arises.
18:24:06 <darthdeus> anyone here using yesod? I'm trying to figure out how to use selectField with optionsPersist ... to simply show a select for a list of entities, but the types just don't align :\
18:24:42 <byorgey> jmcarthur: even formal rules are never clear-cut in their application.  A formal code of conduct would not lessen the need for constant discussion and refinement.
18:25:12 <savanni> But a formal code of conduct would give an agreed upon starting point for such discussion and refinement.
18:25:14 <Algebr> Cale: and if someone asks another why they are rude and are met with further spite?
18:25:38 <Cale> Algebr: A formal code of conduct isn't going to be of any help in that situation.
18:25:43 <byorgey> jmcarthur: in my view a formal code of conduct would mostly be a signal to outsiders and to people just joining the community expressing what kind of community we intend to have.  It would not significantly change the way things currently operate in practice.
18:26:03 <copumpkin> byorgey++
18:26:04 * djahandarie agrees with byorgey on that last point
18:26:09 <Algebr> In any case, as people here seem to be against having a formal code of conduct, then I'll hold my piece furthermore.
18:26:20 <jmcarthur> byorgey: I'd be in favor of an *informal* code of conduct, which would achieve that goal just as well.
18:26:21 <copumpkin> Algebr: I wouldn't say "people in here are against"
18:26:23 <Cale> An *informal* code of conduct is fine.
18:26:23 <copumpkin> there are lots of us
18:27:12 <byorgey> jmcarthur, Cale: what particular distinction do you have in mind between "formal" and "informal"?
18:27:14 <Cale> So far, we've been doing fairly well just through setting good examples.
18:27:44 <Cale> and typically it's very clear-cut when someone needs to be banned for disruptive behaviour or whatnot
18:27:49 <copumpkin> Cale: would we hear about the people who just say "ugh, I don't like this place" and quietly leave?
18:27:51 <byorgey> Cale: as I said, a code of conduct would be a signal to outsiders.  By definition it's kind of hard to tell what signals we are sending to outsiders.
18:28:07 <copumpkin> Cale: e.g., kmc
18:28:14 <byorgey> Cale: I agree we are doing a fairly good job of fostering good community among the people who are already in it.
18:28:34 <dsturnbull> codes of conduct are pretty handy for outsiders deciding whether to invest time in an online discussion forum. because we've all been in way too many useless, harmful online groups before.
18:28:41 <kadoban> If it helps any, I'm basically an outsider here and I think this is the best PL channel I'm in
18:28:45 <byorgey> although even that is colored by the fact that *I* feel very comfortable here, so I'm not aware of ways that some might not be.
18:28:59 <jmcarthur> byorgey: Something high level and warm and fuzzy, speaking of goals and positivity, as opposed to an enumeration of what is or is not acceptable behavior.
18:29:10 <goatfins> If my program calls "hSetBuffering stdin NoBuffering" should getChar return immediately on a keypress? It looks like my program doesn't actually read in the characters until I press return.
18:29:16 <copumpkin> but more specific than "be nice"
18:29:18 <Cale> copumpkin: Well, I think it's each person's own decision whether they're enjoying the community. If they choose not to be vocal about the problems they're having, it's not like a formalised code of rules would help that any.
18:29:37 <jmcarthur> if anything, i'm down with a kind of mission statement more than i am with a code of conduct
18:29:51 <copumpkin> Cale: I'm just wondering how you can say "we've been doing fairly well"
18:30:21 <dsturnbull> seems a bit echo chamber-like :)
18:30:22 <AlainODea> pavonia: I'm just impatient.  It was the replicate that was taking all the time.  Indexing is lightning fast once the array is created.
18:30:22 <Cale> copumpkin: Well, I personally think we've been doing a fairly good job of being welcoming to beginners and helpful for people with questions
18:30:22 <jmcarthur> still similarly helpful, because it provides a bar for you to weigh your behaviors (and decisions, as an op) against, but without defining the methodology
18:30:27 <shachaf> I agree with copumpkin.
18:30:50 <Cale> copumpkin: Obviously, my experience is biased as it's only been during times when I've been present to help out :)
18:31:29 <Cale> copumpkin: But I think in general, I've seen a lot of people pay forward the friendly help they've received in the past
18:31:40 <jmcarthur> goatfins: i think i would expect it to return immediately in that situation, but maybe there's some system level reason it wouldn't necessarily
18:32:12 <Algebr> I don't know if chrisamaphone is here on #haskell, but here was an example of a needless haskell flamewar
18:32:12 <shachaf> goatfins: What OS etc.?
18:32:30 <Algebr> https://twitter.com/weskerfoot/status/475823426267918336
18:32:37 <shachaf> goatfins: On Linux, hSetBuffering does two completely different things at the same time, I know that much.
18:32:59 <copumpkin> Algebr: that was a twitter exchange though, and can't be moderated
18:32:59 <goatfins> Running Arch Linux, urxvt/xterm, ghc 7.8.2
18:33:07 <Cale> Algebr: I am unfamiliar with this particular thread
18:33:15 <Cale> (also with Twitter, I don't see the purpose of it)
18:33:24 <Cale> Algebr: What's the story
18:33:26 <Cale> ?
18:33:27 <Algebr> I'm just giving an example of how outside people might view Haskell community
18:35:12 <Algebr> In any case, my experience in here has been golden and I don't mean to drag this on.
18:35:45 <zwer> is a function that applies f over both elements in a pair?  (a -> b) -> (a, a) -> (b, b)
18:36:02 <athan_> johnw: Oh shoot, so ghc is causing a segfault? :S
18:36:03 <shachaf> zwer: There isn't such a function in base.
18:36:04 <Cale> Ah, I see which thread they were talking about (Twitter's layout is weird and confusing to me)
18:36:22 <johnw> athan_: can you paste the whole error?
18:36:28 <jmcarthur> copumpkin: I don't think I would necessarily claim we've done as well as we could, since obviously some good people have left. However, I don't even understand *why* they left.
18:37:15 <darthdeus> http://stackoverflow.com/questions/24196456/how-can-i-show-a-select-for-has-many-relationship-in-yesod
18:37:30 <Cale> Algebr: It looks like a debate about whether Swift should be considered "modern". In that case, I kind of have to agree with the people who say it's not.
18:37:58 <shachaf> Can you please, *please* not turn this into an argument about whether some programming language is modern or whatever?
18:38:11 <Cale> (because apart from the bit where it came into existence recently, its feature set doesn't really contain much which is new)
18:38:39 <benzrf> Cale: does haskell tho
18:38:39 <goatfins> I have been able to disable echoing using setTerminalAttributes but I am not familiar with most of the TerminalMode constructors. Would one of those be relevant for disabling line buffering?
18:38:56 <djahandarie> Cale, I think you're missing the point.
18:38:57 <benzrf> @hoogle buffering
18:39:01 <lambdabot> System.IO BlockBuffering :: (Maybe Int) -> BufferMode
18:39:01 <lambdabot> GHC.IO.Handle BlockBuffering :: (Maybe Int) -> BufferMode
18:39:01 <lambdabot> System.IO hGetBuffering :: Handle -> IO BufferMode
18:39:07 <Cale> djahandarie: It's possible
18:39:09 <benzrf> @hoogle hSetBuffering
18:39:10 <lambdabot> System.IO hSetBuffering :: Handle -> BufferMode -> IO ()
18:39:10 <lambdabot> GHC.IO.Handle hSetBuffering :: Handle -> BufferMode -> IO ()
18:39:31 <jmcarthur> I, too, said some things about Swift when I first read about it that perhaps some people might interpret as "snobbish" or something, but I don't at all intend to belittle others.
18:39:33 <benzrf> goatfins: hSetBuffering stdin NoBuffering
18:39:37 <benzrf> @hoogle NoBuffering
18:39:40 <lambdabot> System.IO NoBuffering :: BufferMode
18:39:40 <lambdabot> GHC.IO.Handle NoBuffering :: BufferMode
18:40:00 <djahandarie> Cale, what do you think some of the concerns about that Twitter thread might be?
18:40:07 <goatfins> benzrf: I have that in my program, it apparently isn't working.
18:40:11 <jmcarthur> Cale: There were some personal attacks in that thread, as well.
18:40:16 <Cale> jmcarthur: Well, sure. There's a big difference between being negative about an idea or tool and being negative about a person.
18:40:34 <Cale> jmcarthur: Ah, okay, I missed that. (It's a long thread, and I haven't read it all)
18:40:38 <Algebr> Cale, can you message me? I'm not sure how to do it on ERc
18:41:04 <jmcarthur> Cale: I suspect that some people may attach themselves to their technologies more than I (or you) do.
18:42:03 <shachaf> For what it's worth, I think #haskell is pretty unpleasant to be in a large fraction of the time, for all sorts of reasons. I can certainly understand why people would leave.
18:42:07 <jmcarthur> Cale: However, it might be kind of presumptuous of me to say that is the only reason such remarks might be so apparently offputting.
18:42:56 <jmcarthur> shachaf: I am curious what you have in mind and whether there's anything we could do about it.
18:43:04 <djahandarie> shachaf, the main reason for me is just because it mainly contains conversation about things I'm not too interested in. (Beginner-level Haskell being one of them.)
18:43:31 <djahandarie> (Not saying this is something which needs "fixing".)
18:44:05 <jmcarthur> djahandarie: There is that. Somebody even created a #haskell-beginner channel some time ago, but I never figured that would work out just because segregation is so demotivating.
18:44:39 <shachaf> Also, if something like that Twitter thread happened in here, I would consider it entirely unacceptable and cause for either /part or /kick (the latter after a warning or something).
18:44:46 <jmcarthur> (Not to mention that that channel probably ended up with a couple experienced Haskellers trying to help an arkwardly large number of beginners...)
18:44:47 <athan_> johnw: http://lpaste.net/105547 It's on line 1070 (you said the whole error :P)
18:45:12 <athan_> oop, let me get you the log, too
18:45:29 * djahandarie agrees with shachaf regarding the Twitter thread. He finds it completely unacceptable as well.
18:45:47 <athan_> johnw: http://lpaste.net/105548
18:46:31 <shachaf> Probably these days I would /part, lacking the energy or motivation to deal with it.
18:46:37 <Cale> I actually really value the beginner-level discussion. I've found that explaining things over and over again to beginners, and trying to come up with ways to make the presentation better or organise them to avoid pitfalls actually does polish up my own understanding over time.
18:46:52 <vanila> So what do you do if someone treats you horrible in #haskell?
18:47:11 <Cale> vanila: Come to #haskell-ops and talk about it
18:47:15 <Kaidelong> #haskell-ops if it clearly is uncivil
18:47:19 <Cale> vanila: Or just point it out
18:47:20 <jmcarthur> vanila: call for @ops or discuss in #haskell-ops
18:47:24 <Kaidelong> oh I got beaten to it
18:47:25 <vanila> ok but I did that, and then the people #haskell-ops treated me like absolute shit
18:47:40 <ambimorph> I really like the Hacker School Social Rules.  They're only slightly more cumbersome than "Be nice": https://www.hackerschool.com/manual (scroll to Social Rules).
18:47:43 <Cale> vanila: Sorry you feel that way. What actually happened?
18:47:44 <platz> Compared to other langs I notice greater variance in Haskeller attitudes.  Amazing generosity, above and beyond anything else I've seen yet by some, but also a negative side in others
18:48:42 <goatfins> http://lpaste.net/105549 maybe my code is just bad? It seemed fairly simple...
18:48:45 <djahandarie> Cale, yeah. I just personally don't have time for really long interactions like that these days. Mainly looking for interesting tidbits which might catch my attention, and unfortunately such things get lost in the noise here.
18:49:08 <shachaf> goatfins: Oh, your stdout is probably still buffered.
18:49:38 <goatfins> Ah, duh. Thanks.
18:49:38 <shachaf> So you read a character at a time but it doesn't actually help because you're printing a whole line at a time.
18:49:57 <shachaf> Hooray for posting actual code! The solution to many problems.
18:50:05 <monochrom> I like to discuss haskell in #haskell. if some Q&As repeat history, although I find it inefficient, it is totally fine, I defend people's right to do it. however, prolonged discussions of other languages are unpleasant.
18:50:17 <platz> Just wish there was a way to fix the situation of the 3% doing 97% of the work
18:50:41 <Cale> monochrom: This discussion isn't so much about other languages as it is a meta-discussion about the community.
18:50:43 <shachaf> jmcarthur: Like copumpkin said, the people you should really ask are the people who found it too unpleasant to stay in here.
18:50:49 <monochrom> and a "what do you think of golang?" out of the blue is unambiguously trolling
18:50:53 <vanila> here's chatlog from #haskell-ops http://pastebin.com/jX8aKJBc
18:51:37 <vanila> in particular after shapr trolling me and attacking me I left #haskell-ops, then he jumps on me in #haskell threatening me "be nice or else" when I'm the victim here
18:52:21 <vanila> of course from the clique factor other ops like byorgey back him up on it completely and ignre me when I try to PM them explaining otherwise
18:52:51 <jmcarthur> vanila: byorgey said this to you then, apparently, and i'll repeat it. i know shapr in real life. he's a really nice guy and really cares about about having a positive community. i really don't think he meant for you to take what he said as an attack.
18:53:26 <Cale> vanila: Do you happen to have a log of the thing you were complaining about originally?
18:53:33 <vanila> yeah well im pretty upset about what all happened
18:53:50 <jmcarthur> Cale: i don't know what this web site is, but i found a transcript: https://bbs.progrider.org/prog/read/1401489030
18:53:54 <vanila> Cale, yes in #haskell a guy attcked me for some political discussion that came up in another channel
18:54:54 <jmcarthur> that page includes a lot of commentary... do people just read IRC transcripts and comment on them? amazing
18:54:56 <Cale> vanila: What was the attack? I don't see an attack here.
18:55:02 <enthropy> mgsloan: what should be done about zeroth?
18:55:16 <Cale> vanila: Maior asked whether or not you were trolling, was that it?
18:55:17 <shachaf> vanila: Yes, picking and choosing ops because someone disagreed with you, and sending private messages to ops because people aren't responding the way you'd like in public, aren't reasonable behaviors in #-ops.
18:55:18 <jmcarthur> Cale: i suspect he is referring to "<Maior> vanila: do you just sit in channels to troll them? the Django stuff yesterday about the master/slave stuff was unsubtle"
18:55:21 <enthropy> is there some hope for getting changes merged back?
18:56:10 <vanila> yes he was very rude to me, and I asked if we could resolve it in PM and he is like NO way I dont, PM people who arent my friends
18:56:30 <shachaf> #haskell is really not the channel for this, by the way.
18:56:51 <tac_> Is there a #haskell-ops?
18:56:55 <Kaidelong> well the reason he is here is that he felt people were unpleasant to him in #haskell-ops
18:56:55 <shachaf> #-ops is -- anything that we could say in here we would say in there.
18:56:57 <shachaf> tac_: Yes.
18:56:58 <monochrom> yes
18:57:08 <Kaidelong> however looking at the log I think there is a misunderstanding
18:57:14 <jmcarthur> yeah, #haskell-ops is very much the place for this conversation
18:57:31 <jmcarthur> but i understand if there's reluctance to go there
18:58:58 <mgsloan> enthropy: I don't know, I imagine the package author wouldn't mind it getting taken over.  tgeeky had a WIP attempt at getting it at least compiling (afaik not working though), here: https://github.com/technogeeky/zeroth
18:59:21 <enthropy> I mean I have a "working" fork
18:59:35 <mgsloan> Oh, no way!  Good stuff!
19:00:22 <AlainODea> How do I get Data.Vector.Generic.Mutable.new to give me an MVector of Word8's? I'm having difficulty making the types work.
19:00:23 <mgsloan> Maybe do the usual "send email to author + wait a week or two + take over the package"?
19:00:27 <Cale> vanila: I think you misunderstood what he said, btw. He said "I have PMs from non-friends disabled", which sounds like it's just a matter of how his IRC client was configured.
19:00:58 <Cale> vanila: i.e. he was explaining why he appeared to be ignoring you, when really it was just his IRC client
19:00:59 <jmcarthur> (it was a rather abrasive conversation though)
19:01:19 <shachaf> In general sending people private messages when they don't explicitly want them is bad IRC etiquette.
19:03:11 <AlainODea> I tried the Impure Arrays example, but I don't really want a Mersenne or any other random really. http://www.haskell.org/haskellwiki/Numeric_Haskell:_A_Vector_Tutorial#Impure_Arrays
19:03:17 <jmcarthur> AlainODea:    Generic.new len :: IO (Unboxed.Vector Word8)    -- should work just fine. feel free to swap IO for ST s or Unboxed.Vector for whatever other vector type you need, of course
19:03:52 <jmcarthur> AlainODea: ah woops, wrong type. needs to be a mutable vector
19:04:01 <Cale> vanila: Anyway, for the future, if you don't want to seem like you might be a troll, asking why a language is slow is always the wrong question. You should ask why a particular program compiled with a particular compiler is slow. Speed is not a property of programming languages -- they're just specifications of what the result of programs should be, not how fast or slow they should execute. Performance is a property of
19:04:01 <Cale>  the language implementation and the particular program in question.
19:04:02 <jmcarthur> AlainODea: Unboxed.MVector or something
19:04:13 <AlainODea> jmcarthur: great leverage from there.  Thank you :)
19:04:25 <vanila> cale....
19:04:29 <athan_> johnw: Any ideas? :/
19:04:41 <AlainODea> I couldn't figure out where to put the type info :)  Now I know
19:04:56 <vanila> rwbarton posted a line of code that was 4x slower than others
19:05:03 <vanila> why am I being told off again
19:05:23 <Hodapp> I was told that functional languages were immune to IRC drama. I demand an apology.
19:05:23 <jmcarthur> I don't see this as "being told off." It's just advice.
19:05:47 <johnw> athan_: can you get a backtrace from a core file?
19:05:54 <vanila> I'm not really complaining about some guy who holds a grudge against me being rude to me in #haskell
19:05:56 <Cale> Yeah, I'm not telling you off or anything, I'm just providing advice about how people are going to see things.
19:05:59 <vanila> the real problem is here is how the ops treated me
19:06:33 <vanila> they're not setting a good example at all, just making a really hostile community
19:06:40 <AlainODea> vanila: do you have a Haskell question?
19:06:46 <AlainODea> We're happy to help
19:07:05 <Cale> vanila: If your question was about the specific line of code, well, it's because Strings are linked lists of 32 bit wide characters
19:07:06 <vanila> AlainODea: that is patronizing and rude
19:07:23 <johnw> vanila: there is no reason to be inflammatory
19:07:29 <vanila> Cale, thank you. I didn't learn that
19:07:40 <Cale> So, if that ends up being only an order of magnitude slower than operating directly on 8-bit bytes, it's surprising :)
19:07:51 <vanila> now everyone is jumping on me and teling me
19:07:51 <vanila> off
19:07:55 <jmcarthur> ?
19:08:02 <vanila> I was not demnading to continue discussing this here, I'm just replying to Cale
19:08:07 <Cale> vanila: I'm not sure why you perceive that :)
19:08:13 <vanila> Cale: <AlainODea> vanila: do you have a Haskell question?
19:08:13 <vanila> <AlainODea> We're happy to help
19:08:14 <vanila> and
19:08:16 <shachaf> vanila: This isn't the right channel for that conversation. Feel free to ask in #-ops if you want to, but not in here.
19:08:16 <vanila> <johnw> vanila: there is no reason to be inflammatory
19:08:17 <Cale> vanila: We're trying to help you out.
19:08:40 <vanila> "do you have a Haskell question?" means shut up with your metadiscussion and get ontopic
19:08:46 <jmcarthur> well, a slightly different interpretation of the quote:
19:08:49 <jmcarthur> @quote fugue
19:08:49 <lambdabot> monochrom says: Welcome to #haskell, where your questions are answered in contrapuntal fugues.
19:08:54 <AlainODea> vanila: those are genuine and fair questions. I don't understand why you are reading them as anything else
19:08:59 <vanila> ok im done here PM me if anyone wants to discuss further
19:09:22 <Cale> vanila: Well, you're reading more than what was written if you interpret it like that
19:10:54 <athan_> johnw: I have no idea how :/
19:11:20 <Cale> vanila: I'm betting that johnw hasn't seen the whole prior discussion. When someone seems to be upset about how they're being treated, asking whether they have something specific they'd like to discuss is also a good way to sidestep the problem and get them the help they were looking for in the first place.
19:11:27 <johnw> athan_: :(  sorry, I have other things that need attending to; getting that info could be decidedly non-trivial based on your environment
19:11:29 <athan_> johnw: Any quick-start tutorials I could read?
19:11:49 <vanila> ok thanks Cale
19:11:52 <johnw> Cale is correct, I was not following the whole discussion
19:12:05 <athan_> johnw: Hey you help me all the time, give yourself some slack! Thank you anyway :)
19:16:01 <Cale> athan_: Sorry, I missed your previous stuff, what are you looking for help with?
19:16:58 <Cale> athan_: Oh, a build failure?
19:17:22 <dsturnbull> cale, that tactic is also very often used to shut people down.
19:17:52 <athan_> Cale: Thanks :) Yeah, it looks like I'm getting a segfault from attoparsec
19:18:05 <athan_> I'm not sure how, though, the logs don't give me much information
19:18:34 <athan_> john(w) was pointing toward doing a backtrace on the output from a core file, but I'm not sure how I'd go about doing that :/
19:18:37 <Hodapp> dsturnbull: it certainly can be, yes.
19:19:25 <Hodapp> dsturnbull: Sometimes that's appropriate. Other times, it's to silence legitimate criticism on an op's conduct. Luckily, I've pretty much never seen the latter here.
19:22:05 <AlainODea> I'm trying `arr <- Data.Vector.Generic.Mutable.new (1000000000 `div` 8) :: IO (MVector Word8)` and getting `The first argument of `MVector' should have kind `* -> * -> *', but `Word8' has kind `*`
19:22:56 <Cale> did you post /home/athan/dev/yesod-platform-1.2.12/.cabal-sandbox/logs/attoparsec-0.12.0.0.log ?
19:23:03 <Cale> oh, you did
19:23:23 <dsturnbull> Hodapp: i agree this channel is fine, but people coming in have been honed by the vast majority of the reset of the internet :)
19:23:40 <enthropy> AlainODea: if you're using Data.Vector.Generic, there's another parameter there to say whether it's Storable, Unboxed or whatever
19:24:22 <Hodapp> dsturnbull: Yeah. I've been in certain channels, though, where particular ops had some majorly personal issues with me.
19:24:33 <enthropy> hmm, or rather MVector is a class
19:25:06 <AlainODea> enthropy: okay. So it would be IO (MVector something Word8) ?
19:25:28 <Cale> athan_: An exit code of (-11) is rather weird
19:25:46 <enthropy> http://hackage.haskell.org/package/vector-0.10.11.0/docs/Data-Vector-Unboxed-Mutable.html has a definition IOVector that's probably more convenient
19:26:02 <enthropy>  arr <- new n :: IO (IOVector Word8)
19:28:42 <AlainODea> enthropy: awesome. That worked like a charm. Thank you :)
19:29:05 <AlainODea> The Generic stuff is likely for more advanced use cases than mine
19:29:06 <Cale> athan_: Out of curiosity, is this on OSX? Which gcc do you have installed?
19:29:35 <Cale> ah, it's 4.8
19:29:37 <Cale> hmm
19:30:33 <athan_> Cale: No, it's Lubuntu x86_64 :/
19:30:50 <Cale> Ah, and the negative exit code really does indicate that it received the corresponding signal
19:30:55 <athan_> It's a strange machine, HP with an Athlon 64 x2
19:31:02 <athan_> hmm!
19:31:18 <athan_> So that means that the kernel sucessfully sensed the segfault?
19:31:33 <AlainODea> enthropy, jmcarthur, pavonia my 1 billion bit flag updater application works now. Thank you again
19:31:36 <enthropy> AlainODea: the .Generic modules are roughly the same as what happens with Num, except there's no defaulting to save you from needing a type annotation
19:31:48 <jmcarthur> yay!
19:31:51 <Cale> Well, yeah, the kernel probably sent the process a SIGSEGV and that's what Haskell programs do now when they get that signal, apparently.
19:32:14 <enthropy> if you use the non-generic new, but everything else is from .Generic, probably you won't need annotations
19:32:34 <enthropy> besides a (n :: Word8)
19:34:35 <pavonia> AlainODea: Btw, what do you need such a big bit vector for?
19:35:45 <Cale> athan_: What happens if you just try to install attoparsec-0.12.0.0 on its own first?
19:35:59 <athan_> Cale: In it's own sandbox, it works like a champ :/
19:36:11 <AlainODea> pavonia: an array representing all possible SSNs and to check their presence on lists
19:36:22 <Cale> (that might not actually help things any, because the solution cabal finds for *its* dependencies might be different)
19:36:42 <Cale> athan_: So, if it's already installed, it still wants to rebuild it when installing the rest afterward?
19:36:43 <athan_> Cale: There's no implicit segfault is there? Sorry man
19:37:05 <Cale> This *looks* like GHC itself segfaulted, though I might be misreading it.
19:37:07 <athan_> Cale: yesod-platform is in it's own sandbox :/
19:37:38 <athan_> If I try to install it globally, with --force-reinstalls, I get a 'bad closure type' error
19:37:46 <AlainODea> pavonia: Haskell makes the code for this astonishing short and readable.  I wrote a BitGet parser for checking the entries and used Happstack to front it. Checks take 2-4ms over HTTP, much faster in-process, but this needs to be a service
19:37:58 <johnw> edwardk: ping
19:38:21 <Cale> athan_: I mean install attoparsec into the same sandbox you're installing yesod-platform into, only do it beforehand.
19:38:35 <Cale> (and pick the same version of course)
19:39:20 <athan_> Cale: Oh woah, how do I do that? Just `cabal install attoparsec-0.12.0.0` while inside yesod-platform's folder? (sorry...)
19:39:21 <Cale> athan_: This looks like there's a GHC bug here to me, but I'm not really sure how to investigate it properly, so let's see if we can sidestep it
19:39:33 <Cale> I think so (cabal sandboxes are new to me too)
19:39:34 <athan_> Cale: Thanks :)
19:52:22 <athan_> Cale: Wow that's weird... it installed just fine...
19:54:18 <Cale> athan_: What happened is that probably the solution for package versions that cabal came up with for just attoparsec on its own was different from the one it obtained for yesod-platform as a whole, and installing attoparsec first will affect which solution it later finds (it won't try to reinstall things if there's a solution with already-installed packages)
19:54:21 <rwbarton> how much ram do you have on this machine?
19:55:00 <Cale> Oh, good point, I suppose it might be running out of memory, but wouldn't that result in a different signal?
19:55:18 <rwbarton> I would think so
19:55:20 <Cale> (GHC got hit with a signal 11)
19:56:49 <athan> rwbarton: It has 2 GB, that's pretty close to the minimum, isn't it?
19:57:06 <athan> Cale: Thank you for your help, I'm giving it another shot now :)
20:04:32 <savanni> I have a rather fuzzy question about potential application of a monad transformer.
20:05:13 <savanni> Let's say I have an API for data access.  A fairly basic one.  Then, I want to add a "wrapper" that understands the permission model.  In my Python days, I would code things literally as a wrapper.
20:05:38 <savanni> But, here, I'm wondering if Permissions could be a Transformer in the same way ReaderT would be.
20:05:53 <savanni> Or, if I'm misapplying the Transformer concept.
20:06:47 <savanni> Another way of saying this is, does Business Logic lend itself to a Monad Transformer-type structure?
20:08:51 <kadoban> savanni: Take with large grain of salt: I /think/ you'd just write a wrapper in haskell as well. I don't think the monad transformer concept fits.
20:09:20 <savanni> kadoban: k.  That's kinda the direction I'm going at the moment because I'm trying to dream up how such a transformer would be written... and failing.
20:09:51 <savanni> Or, more accurately, my "transformer" is really looking like my access layer enhanced with a few extra parameters.
20:09:59 <athan_> Cale: Aha! Strange closure type found!
20:10:36 <dwcook> Is there a package that conveniently distills TCP socket client connects, disconnects, and messages in the form of ByteStrings into a streaming interface of some sort?
20:13:39 <Cale> athan_: :/
20:13:58 <athan_> Cale: Opening a ghc bug right now. Thank you for your help!
20:14:05 <Cale> No problem
20:14:34 <Cale> athan_: I've only ever seen that when switching GHC versions while leaving temporary (.hi/.o) files in place.
20:14:43 <Cale> athan_: But there are other GHC bugs which can cause it
20:16:05 <athan_> Cale: >< I've got the lucky machine then haha
20:16:14 <NemesisD> i was wondering something. are ADTs with multiple constructors less likely to have reasonable Monoid instances than ADTs with 1 constructor
20:17:11 <Cale> NemesisD: I'm not sure how to measure probability there. You can *always* get a valid Monoid instance somehow, but what "reasonable" means is a bit trickier :)
20:17:19 <dwcook> NemesisD: Numeric types often have many, many constructors and a Monoid instance
20:17:24 <vanila> always? wow! how?
20:17:39 <vanila> not just const?
20:17:52 <Cale> vanila: Well, there are monoids of every cardinality (in fact, there are groups of every cardinality)
20:17:55 <NemesisD> i guess by reasonable i mean law abiding
20:18:04 <vanila> ahh.. but that might not be computable?
20:18:17 <dwcook> One easy way is to adjoin an element outside the type (i.e., use Maybe :)
20:18:21 <Cale> I think there even ought to be computable ones
20:18:37 <Cale> But that's a bit trickier to prove, and doesn't follow immediately, I'll admit :)
20:18:45 <vanila> pretty interesting
20:19:19 <dwcook> Well the monoid I just described works over any set, as far as I know, so it's trivial to get one for any cardinality of set
20:19:29 <dwcook> Well, except for 0
20:19:37 <dwcook> There's no monoid there because you can't provide an identity element
20:19:40 <Cale> Oh, yes, there's no empty monoid :)
20:19:42 <dwcook> There's a semigroup though
20:19:47 <Cale> Right
20:20:00 <dwcook> I think Data.Void even has a Semigroup instance
20:21:25 <Cale> But yeah, just having a law-abiding random monoid structure isn't always useful
20:23:39 <Cale> The impression that it's easier to get monoid instances for product types probably comes from the fact that the product of monoids is a monoid in a canonical way. The categorical sum for monoids isn't built on the sum of the underlying sets
20:27:43 <syllogismos> when I do qualifid import, how do I use an inline operator from that import
20:27:45 <dwcook> I honestly don't think the existence of a Monoid instance has much, if anything, to do with the number of constructors, especially since that measure is pretty arbitrary. For example, newtype Foo = Foo Integer has precisely one constructor but infinitely many values.
20:28:11 <dwcook> Or data Nat = Zero | Succ Nat has two constructors and infinitely many values.
20:28:35 <syllogismos> V.(++)? when I want to use ++ from import qualified Data.Vector as V
20:28:40 <Cale> (V.++)
20:28:51 <Cale> x V.++ y
20:28:59 <Cale> It looks awful
20:29:20 <syllogismos> well its sooo obvious now..
20:29:21 <kadoban> syllogismos: You can always just do another import of the operators you want to use, which is much less icky looking.
20:29:22 <benbangert> thats why I import infix operators
20:29:26 <dwcook> Alternatively, if you don't need it, you can hide the corresponding Prelude binding. import Prelude hiding ((++))
20:29:37 <benbangert> always import operators explicitly to avoid V.++, its horrid
20:30:35 <Cale> yeah
20:32:01 <benbangert> I thought Data.Vector had an alternate concatenate method
20:32:25 <dwcook> (<>) perhaps?
20:32:30 <benbangert> lol
20:32:57 <dwcook> I'm not kidding, that's an option ;)
20:33:31 <benbangert> yea, thats really what I love about haskell. no one ever knows.... are you trolling? or are you serious? cause the answer is... YES
20:33:48 <dwcook> s/haskell/the internet/
20:34:13 <benbangert> indeed, but it seems especially handy with haskell. you could feel trolly, but be serious at the same time
20:34:37 <benbangert> british comedy....
20:35:15 <AlainODea> What is a good way to write an IOVector Word8 to a file?
20:35:17 <benbangert> Cale: not a huge improvement... but... (V.++) x y
20:35:36 <benbangert> Cale: at least the parens contain the annoyance
20:36:03 <benbangert> AlainODea: does it have a Binary instance?
20:36:26 <AlainODea> Let me see
20:36:54 <pingu> AlainODea: bytestring is ARR_WORDS, which is just a word8 array.
20:36:57 <Cale> benbangert: Yeah, I sorta mentioned that one first (though I didn't give an example of application)
20:37:09 <pingu> I presume you could go to bytestring pretty easily then just use bytestring IO functions
20:37:38 <AlainODea> pingu: I did part of the app with ByteString and binary-strict Get and BitGet.
20:37:58 <syllogismos> :t (<>)
20:37:59 <lambdabot> Monoid m => m -> m -> m
20:38:02 <syllogismos> ohhh Data.Vector is a monoid instance
20:39:09 <AlainODea> benbangert: I can't tell.  Not directly. http://hackage.haskell.org/package/vector-0.10.11.0/docs/Data-Vector-Unboxed.html#t:Vector
20:39:19 <pingu> AlainODea: if you can get the address out
20:39:24 <pingu> you can use packAddress
20:39:37 <benbangert> AlainODea: could just import binary and see if encode spits one out
20:39:37 <pingu> Data.ByteString.Unsafe unsafePackAddress :: Addr# -> IO ByteString
20:39:45 <AlainODea> neat.  Good to know
20:39:56 <AlainODea> I'm trying to avoid unsafe*, but I may be being pedantic
20:40:18 <benbangert> AlainODea: if you freeze it, I'm fairly certain binary can encode it
20:40:51 <AlainODea> benbangert: Data.Vector.Unboxed.freeze.  That makes sense.  I'll try that
20:41:33 <benbangert> AlainODea: if its missing something, its pretty trivial to write
20:46:24 <AlainODea> benbangert: looks like I need an instance of Binary for Vector Word8.  That shouldn't be too diffficult.
20:47:07 <benbangert> Word8 is fine already, so you just need the Vector instance
20:47:33 <AlainODea> Ah okay.  Handy
20:47:35 <benbangert> a simple toList should do it, there's already instances for a list, and Word8, so that'd be fine
20:48:16 <AlainODea> http://hackage.haskell.org/package/vector-binary-instances
20:48:19 <AlainODea> Freebie
20:50:46 <AlainODea> benbangert: toList won't explode on a 1/8th billion element list because binary will do it lazily right?
20:51:38 <AlainODea> benbangert: beauty. Worked like a charm. Thank you :)
20:52:59 <AlainODea> I added binary and vector-binary-instances, imported Data.Binary.Vector () and was able to use Data.Binary.encodeFile to write the vector out accurately. Verified with a separate implementation
20:54:43 <benbangert> AlainODea: yea, the io op should force it to write immediately so it won't be lazy
20:55:39 <benbangert> all funcs in the IO monad with side-effects will force everything needed for the side-effect to execute afaik. though I'm a newb, so maybe... ;)
20:55:39 * hackagebot simple-conduit 0.4.0 - A simple streaming library based on composing monadic folds.  http://hackage.haskell.org/package/simple-conduit-0.4.0 (JohnWiegley)
20:57:09 <AlainODea> benbangert: oh okay, but I hope it won't need to build all 1/8th billion cons cells in memory before proceeding to the disk writes. It seems fast, but computers are astonishing good at papering over my inefficient code :D
20:57:32 <dwcook> benbangert: You can't always assume things about strictness even in IO
20:57:34 <benbangert> well, you could run it one step at a time in ghci, and see what thunks are eval'd
20:57:52 <benbangert> there's that nifty little visualizer that shows you the graph of objects and where the thunks are
20:58:59 <benbangert> AlainODea: have you played with http://felsin9.de/nnis/ghc-vis/ ?
20:59:07 <dwcook> Cale: To continue from #haskell-blah, what were you saying about compositions of arrows?
21:00:23 <AlainODea> benbangert: I haven't.  That looks very handy. I've been slowly reading simonmar's book so I have gained an interest in understanding WHNF.
21:00:50 <AlainODea> benbangert: thank you very much again. I'm turning in for the night :)  Take care everyone.
21:05:52 <Cale> dwcook: Well, I'd kind of said it -- you see how that diagram could be seen as either side of the equation (f *** g) >>> (h *** k) = (f >>> h) *** (g >>> k) ?
21:06:13 <Cale> dwcook: So if that equation doesn't hold, the diagram notation doesn't really work
21:06:17 <dwcook> Cale: Oh, I see. And so to make things convenient we want that equality?
21:06:21 <dwcook> Okay.
21:06:22 <Cale> yeah
21:07:42 <Cale> It's sort of analogous to the lumped component abstraction in electronics -- we don't tend to assume that components on separate wires directly affect each other (even though in the real world, things like interference due to magnetic fields are possible)
21:08:11 <Cale> and it ensures that state is somehow "localised" in a way which makes reasoning a lot nicer
21:21:12 <dobblego> is there a library function to turn e.g. [a,b,c,d,e] -> [[a,b,c],[a,b,d],[a,b,e],[a,c,d],[a,c,e],[a,d,e],[b,c,d],[b,c,e],[b,d,e],[c,d,e]] ?
21:21:46 <fragamus> > ((`mod` 7) . round . (*7)) 0.6
21:21:48 <lambdabot>  4
21:22:06 <fragamus> > let argh n = ((`mod` n) . round . (*n)) in argh 7 0.6
21:22:08 <lambdabot>  No instance for (GHC.Show.Show a0)
21:22:08 <lambdabot>    arising from a use of ‘M333513234178005513127844.show_M3335132341780055131...
21:22:08 <lambdabot>  The type variable ‘a0’ is ambiguous
21:22:08 <lambdabot>  Note: there are several potential instances:
21:22:08 <lambdabot>    instance [safe] GHC.Show.Show
21:22:34 <fragamus> to this I say
21:22:35 <fragamus> WTF
21:24:00 <johnw> the two 7s may be different
21:24:12 <johnw> > let n = 7 in ((`mod` n) . round . (*n)) 0.6
21:24:14 <lambdabot>  4
21:24:19 <johnw> hmm.. guess not
21:28:45 <fragamus> yeah this is weird voodoo
21:41:08 <ab9rf> fragamus: numbers are weird in lambdabot :)
21:41:29 <fragamus> its bad in ghci too
21:41:48 <ab9rf> dobblego: you want what, exactly?
21:42:12 <ab9rf> dobblego: it looks like you want permutations, but only certain permutations, what's the filter?
21:42:40 <jle`> i think it's all ordered subsets of lenght three
21:42:47 <dobblego> http://lpaste.net/105551
21:42:47 <ab9rf> :t (\n -> ((`mod` n) . round . (*n))
21:42:48 <lambdabot>     parse error (possibly incorrect indentation or mismatched brackets)
21:42:51 <jle`> actually no they look unordered
21:42:54 <ab9rf> :t (\n -> ((`mod` n) . round . (*n)))
21:42:58 <lambdabot> (RealFrac b, Integral b) => b -> b -> b
21:43:05 <jle`> all size three subsets
21:43:13 <shachaf> johnw: Are you relying on the monomorphism restriction there or something?
21:43:22 <ab9rf> huh, what types are isntances of both realfrac and integral?
21:43:23 <shachaf> > (\n -> ((`mod` n) . round . (*n)) 0.6) 7
21:43:24 <lambdabot>  No instance for (GHC.Show.Show a0)
21:43:24 <lambdabot>    arising from a use of ‘M379898926113604766628150.show_M3798989261136047666...
21:43:24 <lambdabot>  The type variable ‘a0’ is ambiguous
21:43:24 <lambdabot>  Note: there are several potential instances:
21:43:24 <lambdabot>    instance [safe] GHC.Show.Show
21:43:29 <jle`> ab9rf: check out ghci :)
21:43:31 <shachaf> Oh, ab9rf wrote the same thing.
21:43:55 <shachaf> Those rae two different 7s.
21:44:29 <ab9rf> shachaf: yeah, one is an Integral and the other is a RealFrac
21:44:50 <shachaf> Well, types that are instances of those classe.s
21:45:03 <ab9rf> pedantically, yes
21:49:10 <ab9rf> is there a way to get a list of "commonly defined" types that are instances of a given class?
21:50:51 <Cale> :info ClassName  in ghci
21:51:14 <ab9rf> ah, forgot about that :)
21:51:15 <orzo_> oh man, groupBy doesn't do what i thought.  I assumed the relation that you pass in would be run on consecutive elements
21:51:49 <orzo_> i've been using groupBy for a long time thinking i knew what it did
21:51:50 <Cale> orzo_: Nope, it's the first element of each new group which is compared with successive ones
21:52:05 <Cale> orzo_: This behaviour is actually really useful
21:52:14 <orzo_> the one it has?
21:52:16 <Cale> yes
21:52:21 <orzo_> how so
21:52:27 <ab9rf> thought so.  there is no type in the standard prelude that is an instance of both RealFrac and Integral
21:53:07 <ab9rf> except Num
21:53:10 <ab9rf> indirectly
21:53:16 <orzo_> i think its a documentation bug that you have to veiw source to realize its the first of each new group
21:53:34 <Cale> orzo_: Well, the documentation says it should only be applied to equivalence relations
21:53:39 <Cale> in which case, it doesn't matter
21:53:44 <orzo_> hm
21:54:26 <Cale> Anyway, one case where I've found it useful was in breaking up a document with numbered headings like 1.2.1.3
21:55:05 <Cale> (and ultimately forming a tree)
21:55:22 <Cale> groupBy (<) is useful there
21:55:37 <fragamus> dobblego: (nub . (filter (\xs->length xs == length (nub xs))) . (map sort) . (map toList) . (replicateM 3)) "abcde"
21:55:37 <fragamus> ["abc","abd","abe","acd","ace","ade","bcd","bce","bde","cde"]
21:56:12 <fragamus> I got replicateM from Data.Sequence
21:56:28 <ab9rf> ugh.
21:56:48 <Cale> (using the number of components in the heading)
21:57:00 <jle`> replicateM should work from Control.Monad too I think...
21:57:03 <jle`> fragamus
21:57:07 <jle`> or Prelude for that matter
21:57:09 <Cale> > groupBy (<) [1,2,3,1,2,2,3,1,2,3,2,3,4]
21:57:11 <lambdabot>  [[1,2,3],[1,2,2,3],[1,2,3,2,3,4]]
21:57:43 <Cale> (and then you can drop the first element and recurse on the remainder)
21:57:47 <ab9rf> fragamus: does the order in which they're generated matter to you?
21:57:53 <orzo_> i often use it with const, to break things up on a deliminator, groupBy (const $ not . isPrefixOf "-") args
21:58:32 <fragamus> I was trying to answer dobblego's question above
21:58:44 <fragamus> my own question is unrelated
21:58:54 <orzo_> but this one time, i tried to do something a little different that required the behavior it doesnt have
21:59:24 <jle`> fragamus: map sort . map toList is also map (sort . toList) :D
21:59:30 <jle`> thanks to functor laws
21:59:34 <jle`> wee
21:59:58 <fragamus> its not just a good idea
22:00:04 <fragamus> its the law
22:00:58 <Cale> Another way to specify the behaviour of groupBy f that it has is that it breaks the given list into nonempty lists (x:xs) such that f x y holds for each y in xs, and the list of lengths of these lists is (lexicographically) maximal.
22:01:55 <Cale> (minimal would be boring since that would just consist of breaking it into singletons)
22:02:29 <jle`> @src groupBy
22:02:29 <lambdabot> groupBy _  []       =  []
22:02:29 <lambdabot> groupBy eq (x:xs)   =  (x:ys) : groupBy eq zs
22:02:29 <lambdabot>     where (ys,zs) = span (eq x) xs
22:03:02 <Cale> But yeah, the Report says groupBy is only meant to be defined when 'eq' there is an equivalence relation
22:03:41 <Cale> which I'm a little sad about, because it's occasionally useful to take advantage of the exact behaviour of the reference implementation
22:04:10 <Cale> Also, we *should* have another grouping operation which compares adjacent elements
22:09:59 <td123> does anyone know how I can write the partially applied function minus 1?
22:10:06 <td123> \x -> x - 1 works :)
22:10:18 <dobblego> subtract 1
22:10:19 <kadoban> td123: subtract 1
22:10:21 <orzo_> (subtract 1)
22:10:31 <td123> thanks!
22:10:35 <ab9rf> @unpl \x -> x - 1
22:10:36 <lambdabot> \ x -> x - 1
22:10:40 <ab9rf> feh
22:10:42 <ab9rf> @pl \x -> x - 1
22:10:42 <lambdabot> subtract 1
22:10:45 <ab9rf> see? :)
22:10:48 <kadoban> hah
22:12:38 <jle`> td123: also (-1+)
22:12:46 <ab9rf> heh
22:12:48 <jle`> > (-1+) 5
22:12:50 <lambdabot>  4
22:12:59 <jle`> > prev 5
22:13:00 <lambdabot>  Not in scope: ‘prev’
22:13:00 <lambdabot>  Perhaps you meant one of these:
22:13:00 <lambdabot>    ‘pred’ (imported from Prelude), ‘pre’ (imported from Control.Lens)
22:13:04 <jle`> > pred 5
22:13:05 <lambdabot>  4
22:14:11 <mayski> ahh nice
22:14:19 <ab9rf> dobblego: i managed to write a function that does what you want, but it's not a pure library call
22:15:04 <ab9rf> one function with three patterns and some extra gunk.  not that pretty.  can probably do better.
22:15:37 <ab9rf> and it doesn't generate them in the same order
22:16:00 <ab9rf> but it retains the same order in the subsequences that existed in the main sequence
22:16:42 <jle`> > nub . map (take 3) . permutations $ "abcdef"
22:16:43 <lambdabot>  ["abc","bac","cba","bca","cab","acb","dcb","cdb","cbd","dbc","bdc","bcd","da...
22:17:52 <vanila> > let [] `choose` _ = [] ; list `choose` 1 = map return list ; (x:xs) `choose` (n) = map (x:) (xs`choose`(n-1)) ++ xs `choose` n in "abcdef"`choose`3
22:17:54 <lambdabot>  ["abc","abd","abe","abf","acd","ace","acf","ade","adf","aef","bcd","bce","bc...
22:17:57 <ab9rf> > filter ((3==) . length) $ subsequences "abcde"
22:17:58 <lambdabot>  ["abc","abd","acd","bcd","abe","ace","bce","ade","bde","cde"]
22:18:08 <ab9rf> there you go.  not quite the same order
22:18:44 <dobblego> this is quite a different function
22:19:17 <jle`> i think it's closer to what he originally wanted
22:19:21 <jle`> unordered subsets
22:19:39 <vanila> > let [] `choose` _ = [] ; _`choose`0 = [[]] ; (x:xs) `choose` (n) = map (x:) (xs`choose`(n-1)) ++ xs `choose` n in "abcde"`choose`3
22:19:40 <lambdabot>  ["abc","abd","acd","bcd"]
22:20:27 <ab9rf> jle`: i dunno what he wants. :)  he's using lists, so i assume order matters :)
22:20:48 <jle`> oh
22:20:55 <jle`> the original person was dobblego
22:21:03 <jle`> mixed it up for some reason
22:21:23 <vanila> why can't I use the nicer base case
22:21:35 <vanila> oh well
22:22:47 <dobblego> > let threes' = filter ((3==) . length) . subsequences in any null (threes' [1..])
22:22:51 <lambdabot>  mueval-core: Time limit exceeded
22:23:22 <ab9rf> heh
22:23:27 <vanila> > let [] `choose` _ = [] ; list `choose` 1 = map return list ; (x:xs) `choose` (n) = map (x:) (xs`choose`(n-1)) ++ xs `choose` n in [1..]`choose`3
22:23:29 <lambdabot>  [[1,2,3],[1,2,4],[1,2,5],[1,2,6],[1,2,7],[1,2,8],[1,2,9],[1,2,10],[1,2,11],[...
22:23:40 <ab9rf> hehe
22:23:52 <ab9rf> > subsequences [1..]
22:23:54 <lambdabot>  [[],[1],[2],[1,2],[3],[1,3],[2,3],[1,2,3],[4],[1,4],[2,4],[1,2,4],[3,4],[1,3...
22:24:08 <Maxdamantus> > consequences [1..]
22:24:08 <ab9rf> > filter ((3==).length) $ subsequences [1..]
22:24:09 <lambdabot>  Not in scope: ‘consequences’
22:24:09 <lambdabot>  Perhaps you meant ‘subsequences’ (imported from Data.List)
22:24:09 <lambdabot>  can't find file: L.hs
22:24:16 <ab9rf> > filter ((3==).length) $ subsequences [1..]
22:24:17 <lambdabot>  [[1,2,3],[1,2,4],[1,3,4],[2,3,4],[1,2,5],[1,3,5],[2,3,5],[1,4,5],[2,4,5],[3,...
22:24:48 <vanila> subsequences subsequences
22:24:51 <vanila> i can't see the difference
22:25:11 <ab9rf> > filter (elem 6) $ filter ((3==).length) $ subsequences [1..]
22:25:11 <vanila> why did that happen
22:25:13 <lambdabot>  [[1,2,6],[1,3,6],[2,3,6],[1,4,6],[2,4,6],[3,4,6],[1,5,6],[2,5,6],[3,5,6],[4,...
22:25:23 <ab9rf> > filter (elem 200) $ filter ((3==).length) $ subsequences [1..]
22:25:27 <lambdabot>  mueval-core: Time limit exceeded
22:25:29 <ab9rf> heh
22:27:51 <xpika> how can i recusively list dependencies for a cabal package
22:27:53 <xpika> ?
22:35:50 * hackagebot yesod-platform 1.2.12.1 - Meta package for Yesod  http://hackage.haskell.org/package/yesod-platform-1.2.12.1 (MichaelSnoyman)
22:47:57 <hunt> hey haskell
22:48:07 <hunt> im having a real hard time figuring out this data structure
22:48:12 <hunt> its meant to be something like a tree
22:48:28 <hunt> but to insert stuff it seems like i have to replace the entire tree with updated references
22:48:55 <hunt> if i want to insert anything i have to replace its parent, then its parent, etc., and i have to replace all parental references with new parents
22:48:58 <hunt> it seems like a real mess
22:49:49 <eazar001> There is a data structure construct called a zipper to help you with that hunt
22:50:26 <hunt> eazar001: arent zippers fairly advanced?
22:50:33 <eazar001> no
22:50:42 <eazar001> have you read about them?
22:50:57 <eazar001> They address exactly the issue you are speaking about
22:51:02 <eazar001> I'll send you a few links
22:51:11 <eazar001> http://learnyouahaskell.com/zippers
22:51:35 <eazar001> http://en.wikibooks.org/wiki/Haskell/Zippers
22:51:50 <hunt> thanks eazar001 ill look at it
22:51:53 <eazar001> http://www.haskell.org/haskellwiki/Zipper
22:52:02 <eazar001> hunt, those are the three links I can refer you too
22:52:04 <eazar001> good luck
22:52:19 <eazar001> and don't tell yourself it's advanced, you can learn it, if you put your mind to it.
22:55:06 <ctangent> eazar001: that's really cool, thanks for the links
22:55:31 <eazar001> ctangent: no problem .... Xmonad happens to use zippers for workspace management I believe
22:56:01 <eazar001> If you haven't heard of Xmonad, they are window manager for linux programmed in haskell
22:56:25 <eazar001> So it's pretty common functional programming construct
22:56:50 <ctangent> i am but a functional programming padawan
22:57:04 <eazar001> haha, we all are in a sense
22:59:04 <hunt> eazar001: i havent finished through it yet but will this work for trees that have references to their parents as well?
22:59:27 <ctangent> haha. FP and haskell are so different than anything I've ever done, it's like the excitement of learning to program all over again
23:00:24 <eazar001> hunt, yes
23:00:44 <hunt> eazar001: perfecT! thanks man
23:00:48 <eazar001> welcome
23:01:07 <eazar001> ctangent, yea FP is amazing stuff, i'm starting to investigate LP myself (logic programming) ...
23:01:11 <eazar001> it's blowing my mind away
23:01:30 <eazar001> I think FP and LP are wonderful paradigms when implemented correctly
23:02:02 <enthropy> hunt: if the tree is reasonably balanced, the number of nodes to get back to the root is pretty small relative to the total number of nodes
23:03:24 <ctangent> eazar001: when I was in school i attended a lecture of a guy who used prolog to implement symbolic differentiation just by teaching it the rules of differentiation
23:03:32 <ctangent> it was absolutely amazing
23:04:22 <eazar001> tell me about, the industry is really far behind on the times
23:04:55 <eazar001> prolog + constraint solving is a formidable combination as well
23:05:25 <eazar001> but yea it really is a matter of "teaching" in a sense
23:05:45 <eazar001> solving problems in prolog is very much akin towards specifying the problem, haha
23:06:48 <ctangent> haha, that's what makes it so amazing
23:07:13 <eazar001> well if you're interested, join ##prolog, they have some nice people there!! See you ctangent.
23:07:19 <ctangent> thanks!
23:07:27 <eazar001> yw
23:28:11 <l4u-> are there any tutorials on haxl? the example haxl-facebook isn't quite trivial
23:35:30 <ddellaco_> ctangent: I know it was half an hour ago but the original paper on Zippers is pretty readable to, fyi: http://yquem.inria.fr/~huet/PUBLIC/zip.pdf
23:35:47 <ctangent> awesome, thanks!
