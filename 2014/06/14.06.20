00:00:07 <haasn> codygman: I don't understand your question. What do you mean by “ordered before”?
00:00:13 <`error> ah, so i want filterM
00:00:20 <pavonia> codygman: I'm not sure what you mean
00:01:49 <codygman> For instance in "Data Worker = ConstructionWorker {} | Banker {} | Gardener {}" how could I make sure that Gardener is GT than Banker and ConstructionWorker is greater than both.
00:02:14 <codygman> s/Data/data/
00:02:20 <eazar001> @t filterM (doesDirectoryExist) ["Development","b","c"]
00:02:20 <lambdabot> Maybe you meant: tell thank you thanks thesaurus thx tic-tac-toe ticker time todo todo-add todo-delete type v @ ? .
00:02:31 <eazar001> >filterM (doesDirectoryExist) ["Development","b","c"]
00:02:41 <eazar001> :t filterM (doesDirectoryExist) ["Development","b","c"]
00:02:43 <lambdabot> Not in scope: ‘doesDirectoryExist’
00:03:43 <`error> thanks yeah filterM was it!
00:03:44 <`error> hooray!
00:04:02 <pavonia> codygman: For Ord or Enum the constructors are ordered by the order of their definition
00:04:08 <haasn> codygman: It depends on how you define your Ord instance, really. Where does it come from? Are you auto-deriving it (eg. deriving Ord) as pavonia suggested?
00:04:43 <pavonia> Yeah, for derived instances that is
00:04:54 <codygman> I'm wondering how to manually write it
00:05:05 <codygman> I'm aiming to manually write it I should say
00:05:08 <eazar001> probably ...
00:05:22 <eazar001> someVar <- ["a","b","c"]
00:05:32 <eazar001> guard doesDirectoryExist
00:05:41 <eazar001> return ....
00:05:44 <eazar001> somethign like that
00:06:14 <haasn> codygman: as pavonia said, order of definition; eg in data Foo = A | B | C deriving Ord we have sort [B,C,A] = [A,B,C]; the exact rules are in http://www.haskell.org/onlinereport/haskell2010/haskellch11.html#x18-18300011.1
00:06:28 <pavonia> :t guard
00:06:29 <lambdabot> MonadPlus m => Bool -> m ()
00:06:45 <eazar001> guard will return [] on failure
00:06:59 <eazar001> and will essentially concatenate [] with the current list
00:07:26 <haasn> eazar001: That won't work, we're in different monads here ([] vs IO)
00:07:47 <eazar001> hassn: right! sorry got tunnel vision for a sec
00:09:20 <haasn> A manual approach that is not a naive loop could be based on something like String -> IO (Maybe String) and then using catMaybes + mapM
00:09:49 <haasn> But filterM pretty much does that exact same thing, so there's little reason to not use it
00:14:05 <Ainieco> hello
00:14:21 <Ainieco> are there haskell bindings for webkit2?
00:16:07 <pavonia> @hackage webkit
00:16:07 <lambdabot> http://hackage.haskell.org/package/webkit
00:17:07 <Ainieco> pavonia: is it webkit2?
00:17:10 <taruti> Can anyone confirm whether this is a problem with Juicy.Pixels, or whether I am doing something wrong: http://lpaste.net/105856
00:17:28 <pavonia> Ainieco: Oh, do the webkit versions correspond to the gtk versions?
00:18:31 <Ainieco> pavonia: not sure http://webkitgtk.org/reference/webkit2gtk/stable/index.html
00:20:33 <pavonia> Ainieco: So there only seems to be webkit for version 1 and webkitgtk3 for version 3 :S
00:23:30 <pavonia> taruti: What is the output you get?
00:23:32 <Ainieco> pavonia: oh, okay, too bad http://hackage.haskell.org/package/webkitgtk3 doesn't have any examples for starters
00:23:47 <taruti> pavonia: my error :(
00:24:54 <pavonia> taruti: You mean fail is called?
00:25:37 <taruti> pavonia: no, my drawing is messed up, and I was looking at alpha 0 vs 255 the wrong way around when trying to find the problem.
01:03:43 <qrada> im so confused
01:05:24 <augur> why is it sometimes haskell lets me use the State type constructor and other times it complains and asks if i meant StateT?
01:06:21 <augur> oh, nevermind
01:06:35 <qrada> im about to sleep, i've been battling this for about 2 hours.. so sad. Ok so, im messing around with par, pseq, etc.. I have a simple fib/euler combo from a parallel/concurrent tutorial from simon peyton jones.. so.. i compile with -threaded.. I run this program with -N1 runs fine, -N2 runs slower, -N3 runs even worse.. It seems that this spark that gets created should be utilized with -N2 as opposed to -N1.. total time increases as Iincrease +RTS -N<num>
01:06:46 <qrada> anyone have the slightest idea before i pass out and die
01:16:59 <pavonia> qrada: If you're still conscious, what does your code look like?
01:18:41 <qrada> hey, it's pretty attrocious.. can I paste you one function? it's ~4 lines
01:18:51 <qrada> dont want to flood in here
01:18:53 <dsturnbu1l> chuck it up on lpaste imo
01:21:05 <qrada> 1sec, just going to github it
01:22:33 <qrada> https://github.com/adarqui/AFP08-notes-examples/blob/master/src/AFP08/FibEuler.hs
01:22:59 <qrada> and then in examples/ I have a bunch of examples which use those fib/euler functions
01:24:28 <qrada> so.. as an example.. if I run say, time ./.cabal-sandbox/bin/ParSumFibEuler4
01:24:28 <qrada> 38 5003
01:24:46 <qrada> it'll complete in 2.75 seconds.. then, when I run that with +RTS -N2, it finishes in 3.2 seconds
01:25:11 <qrada> when I add -s (to +RTS).. it says my total time is increasing etc
01:25:25 <qrada> basically, I can't get any of the speed improvements that I'm reading in that parallel/concurrent tutorial doc
01:25:50 <qrada> everything is completely opposite for me (ghc 7.8 if that matters)
01:25:51 <qrada> ;f
01:26:23 <Qfwfq> How'd I ask GHC's heap profiler to describe everything it allocates? With +RTS -hc, I'm seeing only the most expensive.
01:28:26 <qrada> maybe drop the c? -h
01:28:29 <qrada> dno
01:28:35 <mbuf> what could I be missing? http://lpaste.net/105858
01:28:56 <qrada> pavonia: dsturnbu1l.. any idea? ;/
01:29:56 <qrada> mbuf, maybe (!) instead of ! ?
01:30:12 <qrada> :t (!)
01:30:14 <lambdabot> Ix i => Array i e -> i -> e
01:30:35 <pavonia> qrada: Looking at it, but I don't really understand what's going on
01:30:59 <pavonia> @hoogle (!)
01:31:02 <lambdabot> Data.IntMap.Strict (!) :: IntMap a -> Key -> a
01:31:02 <lambdabot> Data.IntMap.Lazy (!) :: IntMap a -> Key -> a
01:31:02 <lambdabot> Data.Array.IArray (!) :: (IArray a e, Ix i) => a i e -> i -> e
01:31:13 <mbuf> qrada, still get the same error
01:31:15 <qrada> pavonia: ya.. it's pretty much all in that par'fib'euler'Sum functions
01:31:46 <qrada> it just calls fib and euler in a 'parallel' way
01:31:46 <qrada> or, should ebe
01:31:56 <Abathurr> Hey guys
01:32:20 <Abathurr> I'm thinking of learning either Haskell or Lips, coming from C
01:32:22 <qrada> from the tutorial, ghc is suposed to create a spark for one of those functions and if i have enough cpu's available to that program, run completely on one of those sparks.. (could be wrong obviously)
01:32:34 <Abathurr> What are the differences?
01:33:10 <pavonia> mbuf: What package version are you using?
01:33:17 <tac_> Abathurr: Haskell is focused on static typing. It's arguably 'more modern' in terms of language design.
01:33:45 <mbuf> pavonia, latest sized-types 0.5.0
01:34:13 <tac_> Lisp is famous for being homoiconic, in that the syntax is very minimal. It tends to be more dynamic (typing-wise) and favors metaprogramming.
01:35:03 <tac_> For Lisp, SICP (the famous MIT text) is probably the best introduction. It uses Scheme. For serious work, Clojure is your best option.
01:35:21 <tac_> For Haskell, there's "Learn you a Haskell for Great Good" as the standard intro reference.
01:35:28 <tac_> (free online)
01:35:32 <Abathurr> Is either one more beginner-friendly, or both comaprable?
01:36:46 <tac_> Lisp is probably 'easier'.
01:37:22 <pavonia> mbuf: It seems it's using (1) form Data.Array in that version now, so try importing that module
01:37:28 <pavonia> * (!)
01:37:48 <qrada> just spend a few weeks with both.. in the end you'll choose haskell
01:38:05 * hackagebot haskell-docs 3.0.3 - A program to find and display the docs of a name from a  given module.  http://hackage.haskell.org/package/haskell-docs-3.0.3 (ChrisDone)
01:38:12 <Transfusion> is there a good haskell interpreter for android, so I can practice on the go? how workable is cross-compiling GHC? thanks for any suggestions
01:38:12 <qrada> ok im out, thanks pavonia/dsturnbu1l for the help
01:38:16 <qrada> gn
01:38:59 <pavonia> Well, I couldn't provide much help :)
01:39:35 <tac_> Transfusion: http://tryhaskell.org/ I think?
01:40:41 <Transfusion> tac_: it doesn't work properly in chrome for android for some reason, keyboard input isn't recognized but thanks anyways =)
01:40:46 <tac_> sad
01:41:04 <Transfusion> (and other webkit/blink browsers)
01:41:08 <Transfusion> yeah, a pity :f
01:41:32 <Pythonfant> Why does keepEqual = (foldr (\e acc -> if fst e == snd e then (fst e : acc) else acc) [] ) . zip result in a syntax error but keepEqual = (foldr (\e acc -> if fst e == snd e then (fst e : acc) else acc) [] .) . zip works as intended?
01:41:38 <Transfusion> i would prefer a local solution but i'm fine settling with others
01:41:40 <Pythonfant> I don't understand what I need the second . for
01:42:17 <Pythonfant> also I don't really understand why I need paranthesis around the foldr stuff
01:42:29 <Pythonfant> shouldn't foldr get partially applied?
01:44:00 <Pythonfant> so for (.) the left part is a function [(a,a)]->[a] and zip [a] -> [(a,a)]
01:44:11 <pavonia> :t (foldr (\e acc -> if fst e == snd e then (fst e : acc) else acc) [] .) . zip
01:44:13 <lambdabot> Eq b => [b] -> [b] -> [b]
01:44:20 <taruti> How does one reinstall all installed cabal packages with profiling? ("cabal install world" keeps wanting to install packages that fail to build and thus dies)
01:44:22 <pavonia> :t (foldr (\e acc -> if fst e == snd e then (fst e : acc) else acc) []) . zip
01:44:23 <lambdabot>     Couldn't match type ‘[b0] -> [(a, b0)]’ with ‘[(b, b)]’
01:44:23 <lambdabot>     Expected type: [a] -> [(b, b)]
01:44:23 <lambdabot>       Actual type: [a] -> [b0] -> [(a, b0)]
01:44:38 <pavonia> Pythonfant: It's not a syntax error but a type error
01:44:59 <Pythonfant> right but why do I get the type error the second time?
01:46:03 <pavonia> :t zip
01:46:04 <lambdabot> [a] -> [b] -> [(a, b)]
01:46:08 <Pythonfant> I put keepEqual :: Eq a => [a] -> [a] -> [a] on top
01:46:30 <Pythonfant> I thought that would change the type signature of zip to [a] -> [a] -> [(a,a)]
01:46:48 <pavonia> :t foldr (\e acc -> if fst e == snd e then (fst e : acc) else acc) []
01:46:50 <lambdabot> Eq b => [(b, b)] -> [b]
01:47:17 <mbuf> pavonia, thanks! had to import :m Data.Array.IArray
01:48:06 * hackagebot minisat 0.1 - A Haskell bundle of the Minisat SAT solver  http://hackage.haskell.org/package/minisat-0.1 (JeroenBransen)
01:48:21 <Pythonfant> pavonia: sorry, I still don't get it
01:49:39 <pavonia> Pythonfant: (.) expects a function (x -> y) as second paramater, unified with zip it's x ~ [a] and y ~ [b] -> [(a, b)]. It's first functions's type is (y -> z) ~ ([b] -> [(a, b)] -> z), but that doesn't match with [(b, b)] -> [b]
01:50:19 <pavonia> ~ means type equivalence here
01:50:38 <Pythonfant> ah ok, so (.) only takes one argument
01:50:46 <Pythonfant> seems clear when I think about it
01:50:47 <pavonia> No
01:50:51 <pavonia> :t (.)
01:50:53 <lambdabot> (b -> c) -> (a -> b) -> a -> c
01:51:02 <Pythonfant> the b can only be one argument
01:51:50 <pavonia> It takes two functions where the result type of the second one has to match the input type of the first one. This is not the case in your definition
01:52:09 <taruti> oh, well killing all packages and manually installing works.
01:53:10 <Pythonfant> pavonia: I think I got it now, thx for your help
01:53:40 <pavonia> No problem
01:55:06 <Pythonfant> one last question. Why can't I just put foldr … . . zip
01:55:17 <Pythonfant> but I need to but (foldr … .) . zip
01:56:59 <pavonia> Because it's not clear how that should be parsed, (f .) . g? f . (. g)? f (.) (. g)? etc.
01:57:23 <pavonia> What would 1 + + 2 mean?
01:57:45 <Pythonfant> I thought if the predences are not clear it would just evaluate from left to right
01:58:33 <Pythonfant> so so 1 + + 2 would be (1 +) + 2 which will result in a type error
01:58:37 <pavonia> Ever infix operator has an attached precedence
01:58:42 <pavonia> *Every
01:59:02 <Pythonfant> hm k
02:00:40 <pavonia> Hhm, maybe there would be a sane way to implement it but the develpoers decided to not do it :)
02:25:20 <Abathurr> hullo
02:26:45 <hexagoxel> hi
02:30:59 <forgottenone> is there anything in future module which brings python3 strings to python2
02:32:12 <hexagoxel> forgottenone: wrong channel?
02:32:32 <forgottenone> twanvl so sorry i thought i am in python channel
02:33:28 <alpy> does any one know a good paper about type famillies?
02:41:29 <pavonia> alpy: I haven't read it but the title sounds promising http://www.haskell.org/haskellwiki/Simonpj/Talk:FunWithTypeFuns
02:42:16 <Abathurr> This is very weird
02:42:28 <Abathurr> there is a firewall that blocks my internet connections at a certain time but IRC still works
02:42:29 <Abathurr> very odd
02:43:10 * hackagebot simple-sql-parser 0.4.0 - A parser for SQL queries  http://hackage.haskell.org/package/simple-sql-parser-0.4.0 (JakeWheat)
02:44:12 <Abathurr> I'm an idiot. What's the difference between something being homomorphic and something being isomorphic
02:45:01 <vanila> "homomorphic" is more of a topology term
02:45:07 <vanila> it's not used so much in general
02:46:27 <pavonia> Homomorphisms do not have an inverse, no?
02:46:39 <Kinnison> http://en.wikipedia.org/wiki/Homomorphism#Specific_kinds_of_homomorphisms
02:46:52 <Kinnison> an isomorphism is a bijective homomorphism according to that article
02:47:38 <pavonia> Aha, that way around
02:48:10 * hackagebot shake 0.13.2 - Build system library, like Make, but more accurate dependencies.  http://hackage.haskell.org/package/shake-0.13.2 (NeilMitchell)
02:48:31 <Abathurr> Oh kk, thanks guys.
02:48:37 <Abathurr> That clears things up a lot.
02:51:12 <Radio-DEEJAY> Hallo World :-)   Please Vote and share my Amateur Radio Station in address " http://radiodeejay.caster.fm "
02:51:41 <identity> no thanks
02:52:49 <Kinnison> Radio-DEEJAY: Is it related to haskell?
02:54:18 * Kinnison imagines a radio station playing only things like 'Life thru a Lens', stuff by 'Dire States' or 'Monadonna'
02:54:18 <identity> lol.
02:54:25 <identity> also @ root
02:54:38 <identity> running your irc client on root on a network where your IP address is visible by default
02:54:39 <identity> excellent.
02:54:55 <Rembane> Risks are fun!
02:55:34 <identity> @quote * Kinnison imagines a radio station playing only things like 'Life tru a Lens', stuff by 'Dire States' or 'Monadonna'
02:55:34 <lambdabot> No quotes match. Sorry about this, I know it's a bit silly.
02:55:36 <identity> eh
02:55:41 <identity> how work.
02:56:03 <idiony> sgh4578
02:56:35 <Kinnison> idiony: remember <nick> <quote>
02:56:39 <Kinnison> identity: ^^ even
02:56:42 * Kinnison can tab-complete, oh yes
02:57:01 <identity> @remember Kinnison * imagines a radio station playing only things like 'Life tru a Lens', stuff by 'Dire States' or 'Monadonna'
02:57:01 <lambdabot> Okay.
02:57:05 <identity> @quote monadonna
02:57:05 <lambdabot> Kinnison says: * imagines a radio station playing only things like 'Life tru a Lens', stuff by 'Dire States' or 'Monadonna'
02:57:17 <vanila> identity, i dont think if your irc client says root it necessarily means that you are root
02:57:22 <Kinnison> And now I am immortalised \o/
02:57:36 <identity> vanila: By default, most irc client make your user your username.
02:57:56 <vanila> and what is even the issue with that?
02:58:19 <vanila> if someone somehow can exploit your client, is being root much worse than not
02:58:34 <identity> .. yes?
02:58:55 <identity> Kinnison: We need a Haskell/FP band.
02:59:00 <identity> Funktional Projamming
02:59:13 <Kinnison> identity: oh dear
02:59:29 <Kinnison> identity: although I did attend an interesting talk about using haskell for live-coding of music a few months back
02:59:31 <identity> or maybe The Simons
02:59:45 <identity> Kinnison: Yeah, I've seen all that algorave stuff. It's terrible
02:59:58 <Kinnison> https://github.com/yaxu/
03:01:42 <identity> Kinnison: this FP band notion is now stuck in my mind
03:01:48 <identity> Ideas for lyrics and stuff.
03:02:06 <identity> "Our love used to be Pure, but now it's in IO" etc
03:02:37 <identity> this is terrible
03:04:43 * Kinnison dares identity to write a filk: "Fold me baby, one more time!"
03:05:50 <identity> oh my god
03:06:10 <Kinnison> Or perhaps a Coors filk: "You're irreducible!"
03:06:19 <Kinnison> Coors? Corrs!
03:11:58 <taruti> Any tips how to rewrite this faster, my core-fu is too weak: http://lpaste.net/105861
03:13:50 <Rufflewind> I'm using Cabal's test-suite to run some tests in module Test,  but the module Test depends on another module Utils.  When I try to run it in cabal, it fails with a linking error which looks as though Cabal didn't link my Utils module; how do I get Cabal to include this other module in the linking process? (Cabal 1.20.0.2)
03:14:04 <Rufflewind> (Note that it works fine when I do it manually with ghc)
03:17:11 <Abathurr> Would it be worthwhile to learn category theory if learning haskell?
03:17:26 <Abathurr> I'm getting confused about why isomorphism isn't always bijective, for instance.
03:18:04 <Pythonfant> Abathurr: isn't an isomorphism bijective by definition?
03:18:04 <sruz25> maybe a bit of a newb question: is there something like getType, which I could use instead of naming the type (which can be very long)?
03:18:40 <Abathurr> Pythonfant: According to Wikipedia no
03:18:59 <Pythonfant> Abathurr: could you point me to the paragraph saying that? I'm interested in it :)
03:19:18 <Abathurr> Pythonfant: Uno momento.
03:19:43 <Rufflewind> sruz25: I don't think that's possible.  Why is the type signature so long?  You could define an alias for it.
03:20:14 <Pythonfant> Abathurr:  However, there are concrete categories in which bijective morphisms are not necessarily isomorphisms (such as the category of topological spaces), and there are categories in which each object admits an underlying set but in which isomorphisms need not be bijective (such as the homotopy category of CW-complexes).
03:20:15 <Pythonfant> found it
03:20:31 <Abathurr> Pythonfant: Yep
03:22:36 <sruz25> Rufflewind: it's two dimensional array. Also there are like 5 arguments and I'm it would be easier this way instead of determining the type myself....
03:23:18 <Rufflewind> sruz25: why not just let Haskell infer the type then?
03:23:33 <Rufflewind> (if you don't want to write the type signature)
03:27:44 <Abathurr> Sorry to make you guys into Google, but my internet is blocked. One more question. What are lexical closures?
03:28:13 * hackagebot hmatrix 0.16.0.2 - Numeric Linear Algebra  http://hackage.haskell.org/package/hmatrix-0.16.0.2 (AlbertoRuiz)
03:28:38 <tristanStrange> hey all. whats the simplest way to reinstall a stack of libraries when you want to enable profiling?
03:29:24 <tristanStrange> using cabal that is. Is there a simple way to turn it off again? - would I even need to? I assume there is a performnce hitusing this stuff?
03:29:57 <identity> enabling profiling builds one version for profiling and another without
03:31:28 <tristanStrange> hmmm.... I'm trying to enable profiling for Gloss - which depends on a stack of stuff by following step 1 in this doucment: http://www.haskell.org/ghc/docs/latest/html/users_guide/profiling.html
03:32:13 <identity> tristanStrange: you using sandboxes?
03:32:43 <tristanStrange> nope.... I'm wondering if i should just clear out my cabal at the moment and start working with them
03:33:14 * hackagebot hmatrix-gsl 0.16.0.0 - Numerical computation  http://hackage.haskell.org/package/hmatrix-gsl-0.16.0.0 (AlbertoRuiz)
03:33:16 * hackagebot hmatrix-glpk 0.4.0 - Linear Programming based on GLPK  http://hackage.haskell.org/package/hmatrix-glpk-0.4.0 (AlbertoRuiz)
03:33:18 * hackagebot hmatrix-special 0.3.0 - Interface to GSL special functions  http://hackage.haskell.org/package/hmatrix-special-0.3.0 (AlbertoRuiz)
03:33:20 * hackagebot hTensor 0.8.2 - Multidimensional arrays and simple tensor computations.  http://hackage.haskell.org/package/hTensor-0.8.2 (AlbertoRuiz)
03:33:20 <sruz25> Rufflewind: it can't, because I initialize it with empty list as one argument - or whatever the reason for it not being able to determine the type is....
03:33:33 <identity> probably not a bad idea. While you're at it, enable profiling in your ~/.cabal/config so that you always have profiling versions of packages as well
03:33:36 <sruz25> (invoke)
03:33:41 <identity> it's library-profiling: True
03:33:57 <tristanStrange> many thanks identity!
03:44:44 <tristanStrange> ok i'm having issues with cabal sandboxing now
03:45:10 <tristanStrange> follow instructions here: http://coldwa.st/e/blog/2013-08-20-Cabal-sandbox.html (after cleaing out my ~/.cabal completely)
03:46:15 <tristanStrange> and get told: http://lpaste.net/105862
03:46:36 <tristanStrange> should i just install process?
03:47:41 <tristanStrange> doesn't look like it.... apparently already installed?
03:48:23 <mossplix> why is this function not tail recursive
03:48:28 <mossplix> tailen :: [a] -> Integer
03:48:28 <mossplix> tailen (x:xs) = looper (x:xs) 0 where
03:48:28 <mossplix>                 looper [] a = a
03:48:30 <mossplix>                 looper (x:xs)  a = looper xs  (a+1)
03:50:55 <srh_> why would it be tail recursive?
03:51:26 <tristanStrange> oh i had files also living in ~/.ghc.....
03:51:51 <mossplix> same idea works when summing
03:52:33 <Hafydd> mossplix: tailen is not tail-recursive, because it never calls itself. looper, however, is tail-recursive.
03:52:56 <srh_> it might well build up a linear size thunk though
03:53:07 <mossplix> looper is not tail recursive
03:53:13 <mossplix> gives a stackoverflow
03:54:34 <frerich> mossplix: The accumulator is never forced though AFAICS
03:54:57 <frerich> mossplix: I.e. the stackoverflow might come from the huge '((a+1)+1)+1...' thunk being constructed
03:55:11 <Hafydd> mossplix: yes. You should make it strict in its arguments.
03:55:32 <Hafydd> Well, in the second argument, at least.
03:56:08 <srh_> mossplix: unrelatedly, note what tailen [] does
03:58:13 <mossplix> ah ... cool
03:58:16 * hackagebot cgrep 6.4.1 - Command line tool  http://hackage.haskell.org/package/cgrep-6.4.1 (NicolaBonelli)
04:13:17 * hackagebot cgrep 6.4.2 - Command line tool  http://hackage.haskell.org/package/cgrep-6.4.2 (NicolaBonelli)
04:13:19 * hackagebot hnn 0.2.0.0 - A reasonably fast and simple neural network library  http://hackage.haskell.org/package/hnn-0.2.0.0 (AlpMestanogullari)
04:45:16 <jcullen> Hey all, does anyone mind taking a look at some event handler code I'm writing?
04:45:18 <jcullen> http://pastebin.com/JeTBK6Kd
04:46:01 <jcullen> I've got most of it spec'd out, but I'm having a bit of a tough time figuring out what data structure to use to hold a bunch of event callback functions
04:47:56 <frerich> jcullen: The first thing which strikes me as odd is that there's one type per event, as opposed to a single 'data Event = HeroDeathEvent | EndOfturnEvent | BeginningOfTurnEvent'
04:48:39 <jcullen> frerich: yeah. I did it that way because I want it to be extensible enough to allow new events to be defined in other modules
04:49:18 <jcullen> frerich: so I went with a type class based interface instead of one event type
04:50:37 <jcullen> It seems like getting EventDispatcher to work correctly is going to require a little bit of some type level programming.. but I'm not sure the best way to approach it
04:50:55 <jcullen> curious if there is something idiomatic for this kind of situation that I haven't run into before
04:59:30 <slomo> jcullen: http://lpaste.net/104937 maybe this can give you some ideas, what you describe sounds like a similar problem i once had (having handlers of different types... mine just were stateful and had different states)
05:04:26 <jcullen> slomo: Cool thanks, I'm taking a look.  Will probably take me a bit to figure out since I haven't done much with existential quantification.
05:04:27 <jcullen>  
05:05:07 <Ainieco> hello
05:05:53 <jcullen> Hi :)
05:08:21 * hackagebot hmatrix 0.16.0.3 - Numeric Linear Algebra  http://hackage.haskell.org/package/hmatrix-0.16.0.3 (AlbertoRuiz)
05:16:46 <Aetherspawn-> does anyone know a library for doing integer arithmetic and floating point operations
05:17:00 <Aetherspawn-> but simulated on a different architecture with more or less bits?
05:18:22 * hackagebot ghc-make 0.2 - Accelerated version of ghc --make  http://hackage.haskell.org/package/ghc-make-0.2 (NeilMitchell)
05:22:45 <fread2282> do we have mtl?
05:22:54 <fread2282> whops, wrong channel
05:23:23 * hackagebot haskell-docs 4.0.0 - A program to find and display the docs of a name from a  given module.  http://hackage.haskell.org/package/haskell-docs-4.0.0 (ChrisDone)
05:23:24 <ClaudiusMaximus> Aetherspawn-: there's 'rounded' (still not quite yet ready for release) which wraps mpfr with a nice api for arbitrary precision floating point  https://github.com/ekmett/rounded
05:25:27 <Aetherspawn-> ClaudiusMaximus: know of anything for integer arith?
05:26:54 <ClaudiusMaximus> Aetherspawn-: http://hackage.haskell.org/package/largeword is one, not sure if there's anything more general
05:27:20 <qrada>  /win 1
05:27:25 <qrada> eek
05:28:36 <Aetherspawn-> ClaudiusMaximus: thanks
05:54:35 <Ainieco> hello
05:54:46 <Sculptor> hello
05:55:09 <Ainieco> with what can i substitute onDestroy from gtk to compile my app with gtk3?
05:55:12 <Ainieco> @hoogle gtk
05:55:14 <Ainieco> @hoogle gtk3
05:55:16 <lambdabot> package gtk
05:55:16 <lambdabot> package gtk-jsinput
05:55:16 <lambdabot> package gtk-mac-integration
05:55:16 <lambdabot> package gtk3
05:55:16 <lambdabot> package gtk3-mac-integration
05:55:18 <lambdabot> package webkitgtk3
05:55:27 <Ainieco> @hackage gtk3
05:55:27 <lambdabot> http://hackage.haskell.org/package/gtk3
05:55:29 <Ainieco> @hackage gtk
05:55:29 <lambdabot> http://hackage.haskell.org/package/gtk
05:55:33 <Ainieco> these ones ^
05:55:41 <Ainieco> sorry for spam
06:03:44 <Ainieco>  why does it gives me parse error "window `on` deleteEvent $ liftIO mainQuit >> return False"
06:05:43 <Ainieco> ack, copy pasted example fron internet with nasty tabs
06:11:46 <Ainieco> how to replace onRowActivated in gtk3?
06:11:54 <Ainieco> any gtk3 experts around?
06:12:52 <chrisdone> InstalledPackageInfo_ is totally a functor
06:13:00 * chrisdone demands his functor instance
06:14:25 <chrisdone> having to write this http://lpaste.net/6924036431375499264
06:14:33 <a___> Greetings, Haskellers!
06:17:34 <Ainieco> anyone?
06:18:10 <chrisdone> ainieco: probably `foo` and $ have the same precedence
06:18:34 <Twey> They don't in general
06:19:02 <Twey> And that gives you a more specific error about precedence, even if someone's set `on` to be the same precedence as ($), not a general parse error
06:19:26 <Twey> Probably it's to do with something else around the line
06:19:48 <chrisdone> λ> id `on` id $ id
06:19:48 <chrisdone> <interactive>:186:1:
06:19:49 <chrisdone>     Precedence parsing error
06:19:51 <chrisdone>         cannot mix `on' [infixl 0] and `$' [infixr 0] in the same infix expression
06:20:04 <chrisdone> λ> :i on
06:20:05 <chrisdone> on :: (b -> b -> c) -> (a -> b) -> a -> a -> c
06:20:05 <chrisdone>   	-- Defined in `Data.Function'
06:20:05 <chrisdone> infixl 0 infixl 0 on on
06:20:32 <chrisdone> ainieco: infix is overrated =)
06:21:06 <prolugger> are u a bad enough dude to monad the president
06:22:29 <Twey> chrisdone: It's not that `on`
06:22:33 <Twey> (but ewww)
06:24:25 <Ainieco> yeah, that was because of 1 nasty tab
06:26:17 <Ainieco> No instance for (WidgetClass WebView)
06:26:57 <Ainieco> does it means that i can't use webkit with gtk3 and should use webkitgtk3 which fails to compile?
06:28:45 <Ainieco> The pkg-config package webkitgtk-3.0 version >=1.8 is required but it could not be found.
06:28:58 <Ainieco> could someone please decypher it?
06:29:28 <Twey> It wants you to have webkitgtk-3.0 installed on your system in order to bind to it, and you don't have it
06:29:30 <Ainieco> does it needs pkg-config of >= 1.8 version?
06:29:38 <Ainieco> ahh
06:29:45 <Ainieco> thanks
06:30:00 <Twey> (or you have an old version <1.8)
06:37:06 <qrada> hey.. having some problems trying to implement the par/pseq examples from a Parallel/Concurrent tutorial (from simon peyton jones).. Basically, i'm not getting the speed increases that they are getting. In fact, my tests are getting slower, not faster (when I go from -N1 to -N2 to -N3 etc). I'm at a loss, would anyone mind taking a look? https://github.com/adarqui/AFP08-notes-examples/blob/master/src/AFP08/FibEuler.hs
06:38:12 <qrada> I have ghc 7.8 if that matters at all.. basically, i'm just trying to see speed ups via par'fib'euler'Sum'{3,4} vs 1,2 and fib'euler'Sum... those 3/4 functions are in the tutorial and mention it's the proper way to get that parallelism via the sparks
06:38:16 <qrada> any idea?
06:40:38 <Cale> qrada: and you're compiling with -threaded ?
06:40:54 <Cale> (Well, I'm not sure that RTS flag even exists if not...)
06:41:39 <benzrf> wtf
06:42:11 <prolugger> monadic nick underliner
06:43:07 <qrada> Cale, ya .. in my Install.cabal I have these flags:  GHC-Options:         -threaded -O2 -Wall -rtsopts -auto-all -prof
06:43:26 <bennofs> qrada: maybe try without -auto-all and -prof?
06:43:40 <qrada> I've messed with all of the options and always get the same behavior of results
06:43:44 <qrada> ok gimi a sec
06:43:44 <mariomystic> How to double quanitfy. something like data Foo = forall a . forall b . (Show a, Show b) => Foo a b. This doesn't work.
06:43:47 <bennofs> qrada: It could be that profiling changes the result
06:44:07 <bennofs> mariomystic: you can say forall a b.
06:44:32 <mariomystic> bennofs: thanks
06:47:01 <tejas_> hai
06:47:11 <qrada> $ ./.cabal-sandbox/bin/ParSumFibEuler4 38 5300
06:47:11 <qrada> Starting: ParSumFibEuler4
06:47:12 <qrada> Elapsed time: 1.711701
06:47:20 <qrada> $ ./.cabal-sandbox/bin/ParSumFibEuler4 38 5300 +RTS -N2
06:47:20 <qrada> Starting: ParSumFibEuler4
06:47:20 <qrada> Elapsed time: 1.818628
06:47:25 <qrada> etc, even without auto-all/prof
06:47:47 <Luke> What does it mean when I get this failure for "cabal update": "cabal: Codec.Compression.Zlib: premature end of compressed stream"
06:48:02 <Luke> i'm able to visit  hackage in the browser
06:48:30 <qrada> this is the behavior i'm consistently seeing.. The "supposedly slow" function (fib'euler'Sum) which simply does : fib 48 + euler'Sum 5300 , is the fastest
06:49:01 <bennofs> qrada: how many cores do you have?
06:49:16 <qrada> on this box i'm testing on, 16.. on the box i was testing on all last night, 4
06:50:53 <qrada> i'm trying to run through all of the examples/exercises in this tutorial/document: http://research.microsoft.com/en-us/um/people/simonpj/papers/parallel/AFP08-notes.pdf
06:51:35 <qrada> so, the very first set of examples, parallelizing fib + sumEuler ... getting the complete opposite of what they state in the tutorial
06:54:49 <Yahweh> How can I have a type function variable in Haskell that obeys a certain law? For example, I want to define a new type, which is the type of all functions [a] -> [a] -> [a], but I want it to necessarily be only associative functions. How do I do that?
06:55:11 <Cale> Yahweh: Not easy to express in Haskell's type system
06:55:21 <Cale> Yahweh: For things like that, you'll really want dependent types
06:55:52 <Yahweh> Like what?
06:55:52 <Cale> (Like Coq, Agda and Idris have, for some examples)
06:56:01 <Yahweh> ahh I see
06:56:15 <Yahweh> Then there would be a type failure if I try to feed as an argument a function that's not associative?
06:56:31 <Cale> yeah, well, you'd have to provide a proof that the function is associative
06:56:48 <Yahweh> The compiler will not check it by itself?
06:58:23 <Cale> You'd have a dependent pair, consisting of such a function f, together with some structure of some type like forall x y z, f (f x y) z = f x (f y z)
06:59:24 <Yahweh> I see, so I'd specify, in the definition of the type, the code which means what it is to be associative.
06:59:30 <Cale> There are mechanisms for having the compiler do proof search
06:59:43 <Cale> yeah
06:59:56 <Yahweh> That sounds like exactly what I'm looking for.
06:59:58 <pjdelport> Yahweh: You can embed the constraint in Haskell as a type class, such as Monoid or Semigroup (which might fit your needs).
07:00:00 <qrada> at first i thought i was a nub, but now im thinking my ghc is wrecked
07:00:02 <Cale> In general, once you get to this level of expressiveness, you can't really rely on the machine to be able to find all the proofs
07:00:19 <qrada> ok it's most likely still the former.. par/pseq is not making sense for me
07:00:31 <qrada> it makes sense but the results i'm getting make no sense
07:00:53 <Yahweh> OK so Agda is my final goal but I have to go through Haskell first.
07:01:03 <pjdelport> Yahweh: Haskell won't actually prove that your instance obey the Monoid / Semigroup laws, but it will check that you only use Monoids / Semigroups in the appropriate places.
07:02:15 <Cale> qrada: Evaluating (x `par` y) puts x into a queue of things which should be evaluated if there's time available, before resulting in y. Evaluating x `pseq` y simply evaluates x and then results in y.
07:03:08 <Yahweh> What I want, for example, is to have a function that takes a semi-group as an argument, which I suppose really is a tuple (S, f) where S is a list of type [a] and f is a function [a] -> [a] -> [a], and I want the function to fail (as a type error) if f is not associative.
07:03:10 <Cale> qrada: Managing that queue of available work does have a cost, so just trivially sprinkling par everywhere, while it won't change the result of your program, might hurt performance.
07:04:11 <Cale> Yahweh: You probably mean, where S is a type, and f is a function S -> S -> S which is associative
07:04:12 <pjdelport> Yahweh: Would type classes work, or is that not relevant to your approach?
07:06:20 <Yahweh> pjdelport: I'm not sure, I guess I'll have to look into it. Cale: I don't follow..why?
07:06:32 <pjdelport> Yahweh: Does what I said above make sense?
07:07:09 <Cale> Yahweh: Well, a semigroup is normally a set together with an associative binary operator on that set.
07:07:09 <Yahweh> pjdelport: Yes, but what if I have other laws that are not covered by Monoid or Semi-group?
07:07:27 <pjdelport> Yahweh: You can just add orthogonal type classes, or write your own.
07:07:31 <Yahweh> Cale: Right, so a set is a list [a] and a binary operation is a function [a] -> [a] -> [a].
07:07:44 <Cale> Yahweh: No, the function acts on the elements of the set
07:07:54 <Cale> Yahweh: So, perhaps a -> a -> a
07:08:02 <Yahweh> Ahh yes
07:08:03 <Cale> Even if you're going to keep the list
07:08:07 <Yahweh> sorry.
07:08:14 <Yahweh> [a] and a->a->a indeed.
07:08:16 <Cale> But then, why not just have the type a stand in for the set?
07:08:37 <Cale> I guess that depends on how you view types
07:08:51 <Cale> But often types are regarded as sets (or at least some types are)
07:09:09 <Yahweh> Like Bool = {True, False}?
07:09:33 <Cale> yes
07:10:01 <`stupid`> i can't for the life of me define ioNot :: IO Bool -> IO Bool
07:10:07 <Cale> :t fmap
07:10:08 <`stupid`> which just nots its input :(
07:10:09 <lambdabot> Functor f => (a -> b) -> f a -> f b
07:10:19 <`stupid`> it is making me very sad.
07:10:23 <Cale> Well, are you familiar with do-notation at all?
07:10:31 <`stupid`> no
07:10:31 <Cale> fmap not  will work
07:10:57 <Cale> But in order to glue IO actions together, do-notation is pretty helpful, and also makes this not too difficult
07:11:04 <Yahweh> Thanks Cale and pjdelport, I appreciate your responses.
07:11:20 <Cale> ioNot x = ...
07:11:26 <`stupid`> yes
07:11:29 <`stupid`> = ...
07:11:30 <Cale> we want to run x, getting some Boolean result b
07:11:35 <Cale> ioNot x = do b <- x; ...
07:11:44 <`stupid`> hm
07:12:09 <pjdelport> Isn't ioNot just "fmap not"?
07:12:13 <Cale> and then we want to run the action which does nothing except to produce (not b) as its result
07:12:24 <Cale> pjdelport: Yeah, I mentioned that
07:12:49 <Cale> But given that he's struggling with this, I think seeing it written with do-notation will be more helpful
07:12:58 <Cale> ioNot x = do b <- x; return (not b)
07:13:23 <Cale> If v is any value, then return v is the IO action which does nothing, except to, well, return v :)
07:13:27 <qrada> right Cole, but this is pretty much straight from a doc by microsoft research which states a ~25% increase in performance etc.. because using par/pseq properly would cause one of those functions to be evaluated on one of those spark's that are created
07:13:42 <`stupid`> hm
07:13:47 <ion> When i was a newbie, i found thinking of fmap in terms of do notation helpful. I just realized i’m not doing that anymore.
07:13:58 <`stupid`> i see that fmap and the do the works.
07:14:04 <Ainieco> is there webkitqt for haskell?
07:14:05 <`stupid`> i'm not entirely sure why.
07:14:54 <`stupid`> i guess :t fmap is the answer
07:14:56 <`stupid`> :t fmap
07:14:58 <lambdabot> Functor f => (a -> b) -> f a -> f b
07:15:05 <`stupid`> okay.
07:15:07 <`stupid`> fair enough.
07:15:22 <`stupid`> thanks
07:15:27 <ion> @type fmap `asTypeIn` \fmap -> fmap undefined (undefined :: IO a)
07:15:28 <lambdabot> (a -> b) -> IO a -> IO b
07:15:39 <Cale> `stupid`: http://www.haskell.org/haskellwiki/Introduction_to_IO
07:16:12 <`stupid`> Cale: yeah, i looked at that, it didn't tell me the answer.. unless i missed it
07:16:34 <Cale> Well, it doesn't immediately contain the answer
07:16:36 <`stupid`> i guess maybe i needed to do to further reading or something
07:16:43 <Cale> But it talks about the things which I used to build an answer
07:17:02 <Cale> You could also write  ioNot x = x >>= (\b -> return (not b))
07:17:10 <nibblediz> Is there an apply function to go from (x, y) to f x y ?
07:17:27 <Cale> :t curry
07:17:28 <lambdabot> ((a, b) -> c) -> a -> b -> c
07:17:34 <Cale> :t uncurry
07:17:35 <lambdabot> (a -> b -> c) -> (a, b) -> c
07:17:50 <nibblediz> Nice, thanks Cale
07:20:05 <Cale> `stupid`: So, when you have a do-block with some IO actions in it, it describes an IO action that, when executed, will execute each of them in turn, perhaps capturing some of their results as variables (like the line b <- x in the above)
07:20:22 <Cale> and then the result returned by the last action will be the result of the whole action
07:20:41 <Cale> `stupid`: So do-blocks are a way of gluing smaller IO actions together into more complicated ones
07:21:13 <`stupid`> hm
07:21:22 <`stupid`> i guess the whole point is i didn't want to define ioNot
07:21:24 <`stupid`> i wanted to use not
07:21:28 <`stupid`> on an IO bool
07:21:31 <`stupid`> and i was sad
07:21:34 <`stupid`> because `not` failed.
07:21:36 <Cale> Right, in that case, fmap not is the answer for you
07:21:41 <`stupid`> but it seems the answer to do fmap not
07:21:42 <`stupid`> yeah
07:21:50 <`stupid`> i was trying liftIO
07:21:53 <`stupid`> but i guess that's the wrong idea.
07:21:55 <Cale> liftM would work
07:22:00 <Cale> liftIO is something else
07:22:17 <`stupid`> so liftM not would also work?
07:22:22 <Cale> (liftIO takes an IO action and transforms it into an action of some fancier type of monad)
07:22:28 <`stupid`> yeah
07:22:35 <`stupid`> i guess i clearly don't entirely understand that yet
07:22:37 <Cale> liftM does work
07:22:41 <`stupid`> i think fmap has the type signature i was after.
07:22:45 <Cale> yes
07:22:47 <Cale> :t liftM
07:22:49 <lambdabot> Monad m => (a1 -> r) -> m a1 -> m r
07:22:51 <`stupid`> alright, well cheers, thanks for the help.
07:22:59 <Cale> liftM is the same thing as fmap, but specialised to monads
07:23:15 <`stupid`> ah yeah, i guess liftM was more what i had in mind.
07:23:17 <nibblediz> Is there also a function that takes a 3-tuple and returns the last two components?
07:23:22 <Cale> It can be defined as  liftM f x = do v <- x; return (f v)
07:23:40 <`stupid`> thnaks Cale
07:23:42 <Cale> nibblediz: there aren't many named functions which operate on 3-tuples
07:23:50 <pingu> Why does ghci pick (a1 -> r) instead of (a -> r)?
07:23:51 <Cale> nibblediz: Better to just write a lambda
07:23:52 <nibblediz> Cale: ah, ok
07:23:54 <pingu> i've never understood that
07:23:59 <nibblediz> Cale: thanks!
07:24:00 <pjdelport> `stupid`: This might not be entirely relevant right now, but fmap, <$>, and liftM are all essentially the same thing.
07:24:11 <Cale> nibblediz: (\(x,y,z) -> (y,z)) is probably clearer than any naming scheme you could come up with :)
07:24:27 <nibblediz> Cale: yeah, that's probably true :)
07:24:30 <Cale> pingu: Because that's how it was written in the library code
07:24:46 <Cale> pingu: GHC tries to preserve the variable names that you use, if possible
07:24:51 <Cale> :t liftM2
07:24:53 <lambdabot> Monad m => (a1 -> a2 -> r) -> m a1 -> m a2 -> m r
07:24:55 <Cale> :t liftM3
07:24:56 <lambdabot> Monad m => (a1 -> a2 -> a3 -> r) -> m a1 -> m a2 -> m a3 -> m r
07:24:58 <pingu> ah.
07:25:02 <Cale> ^^ makes more sense in context of that code
07:25:07 <benzrf> j
07:25:07 <pingu> thankyou :)
07:25:18 <pingu> I like it when little mysteries are solved!
07:36:09 <heatsink> @let {coget = put; coput = get}
07:36:13 <lambdabot>  Defined.
07:42:14 <m9h> Is there anyone who can into lambda calculus?
07:45:29 <Twey> m9h: Ask your question
07:46:54 <m9h> Let there be two terms: P, Q. Both have no normal form. e.g. (\x.xx)(\x.xx). But term (P Q) must have normal form. I need to invent those P and Q.
07:47:14 <m9h> I was thinking for a couple of hours, but came up with nothing.
07:48:30 <heatsink> It would probably involve P and Q containing un-normalizable terms that can be discarded when (P Q) is normalized
07:48:52 <heatsink> > cycle []
07:48:54 <lambdabot>  *Exception: Prelude.cycle: empty list
07:48:57 <heatsink> > const 1 (cycle [])
07:48:58 <lambdabot>  1
07:49:16 <Twey> The problem is P
07:49:21 <m9h> Yeah.
07:49:36 <heatsink> Normalization is also done inside lambdas, right?
07:49:45 <Twey> No
07:49:50 <heatsink> ah
07:50:00 <Twey> Er, well, depends
07:50:14 <m9h> Term is normalised when no reduction possible.
07:50:25 <prolugger> are u a bad enough dude to normalize the president
07:51:14 <Twey> m9h: Right, but you can choose to normalize under binders or not (e.g. (λx. (λx. x) x) ⇒ (λx. x))
07:51:23 <napping> Does anyone know anything about haskell-mode? #haskell-emacs seems dead
07:51:44 <napping> It looks like it's not running the hooks
07:51:50 <m9h> Twey: I chose to normalize under binders.
07:51:52 <napping> or at least not the one that turns on indentation
07:51:59 <Twey> Okay
07:52:34 <heatsink> napping: Which hooks?  Does syntax highlighting activate?
07:52:49 <napping> yeah, it has syntax highlighting
07:53:18 <napping> but hitting TAB just brings up a *Help* window for haskell-mode-hook?!
07:53:54 <Twey> napping: Have you read said help window?
07:53:59 <heatsink> Did you put one of the indentation modes in your initializaiton file?
07:54:12 <napping> It says the value of the variable is (el-get-ghc-mod-hook el-get-haskell-hook turn-on-haskell-indentation turn-on-haskell-doc-mode)
07:54:15 <napping> so yes
07:54:19 <m9h> Twey: If I normalize inside binders I could say Y combinator has no normal form, right?
07:54:31 <napping> manually invoking (run-hooks 'haskell-mode-hook) myself fixes the indentation
07:54:40 <napping> (and somehow turns on flymake mode, which I do not want)
07:55:25 <Twey> m9h: Not of itself, no
07:56:10 <Twey> Err
07:56:23 <Twey> Yes, sorry
07:56:26 <napping> well, the flymake turns out to be implied by the ghc-mod bit
08:01:09 <heatsink> napping: For me, haskell-mode-hook just contains (turn-on-haskell-indentation)
08:03:20 <napping> Uninstalling ghc-mod seems to fix it
08:04:14 <napping> It tended to hang or leave file_flymake.hs files lying around
08:05:59 <levi> napping: Yeah, something is definitely weird about haskell-mode and hooks.
08:06:31 <levi> I'd really miss ghc-mod.
08:07:47 <levi> I'd miss flycheck mode, too. But I can do without flymake.
08:10:39 <napping> It seems to be working fine now that I removed the ghc-mod hook
08:10:51 <napping> I guess that was somehow failing and stopping it from getting to the later ones?
08:12:11 <tolt> Does anyone have any resources on cross compiling for arm?
08:12:38 <tolt> I've seen some things about it being better with 7.8
08:18:42 <levi> I dunno. Might be fun to play with when I get some time; I have lots of ARM things.
08:21:15 <deweyvm> is there a way to avoid the repetition of arguments here? http://pastebin.com/vKQCNJJP
08:21:22 <deweyvm> without the 'do' i could just leave them off
08:23:51 <Twey> deweyvm: Not a nice one, I think
08:24:51 <Twey> deweyvm: If you rearrange the arguments to rawHarmony so that ref comes last, you can
08:25:04 <deweyvm> Twey: oh i could do that, how would it work then?
08:25:26 <Twey> Oh wait, sorry, no
08:27:13 <roelof> Are the good books about ruby and OO programming so I can learn more about the sending messages to another object ?
08:28:15 <Twey> roelof: Wrong channel
08:28:37 <roelof> sorry
08:30:34 <monochrom> hey! why don't we recommend the O'Haskell paper? :)
08:30:58 <chrisdone> ew
08:31:04 <chrisdone> O'Godno
08:34:21 <benzrf> what's o'haskell then
08:35:26 <ion> “A dialect of Erlang that uses indentation like Python, and has many improvement like ErlangObjectSystem” https://github.com/zed-throben/erlangeos
08:35:34 <ion> benzrf: HaskellObjectSystem because OO makes everything better.
08:35:52 <monochrom> http://www.haskell.org/haskellwiki/O%27Haskell
08:36:18 <benzrf> jesus christ
08:36:57 <Lutinzzz> please tell me this is a joke
08:37:07 <monochrom> and then there is OOHaskell. this one is an Oleg thing.
08:38:14 <c_wraith> what's fascinating to me is that since starting to use haskell, I've never once found myself thinking "subtypes sound like a good way to solve this"
08:38:39 <chrisdone> tbh i probably have once or twice, e.g. with haskelldb, but otherwise not really
08:38:44 <napping> c_wraith: never run into compiler things where you'd like subsets of constructors?
08:38:46 <Twey> deweyvm: If you move ref to the back of rawHarmony's arguments, you can say that: harmony = (. rawHarmony) . fmap . fmap . fmap . fmap . fmap . fmap $ (getRandomR (0.0, 360.0) >>=)
08:38:59 <deweyvm> hahaha
08:39:03 <napping> Of course that's more of thinking "polymorphic variants sound like a good way to solve this"
08:39:03 <deweyvm> but thats so silly
08:39:17 <Twey> deweyvm: But I don't recommend it; you'd do (much) better to avoid passing all those doubles and wrap them up into some kind of semantically meaningful structure
08:39:47 <deweyvm> im hesitant to do so because that structure wouldnt be used in any other function
08:39:49 <monochrom> hmm, polymorphic variants and row polymorphism. are they duals?
08:39:54 <napping> yes
08:39:56 <napping> see MLPolyR
08:40:03 <Twey> deweyvm: That's fine
08:40:06 <qrada> can anyone help me understand the profiling/heap output of this http://hastebin.com/ebipokegab.vbs  ..... If oyu just look at the last two tests, the one with -N2 is slower than -N1, why though? everything looks pretty much the same except for the spark being fizzled or not... The -N2 test is 3 seconds slower than the -N1 test, same function etc
08:40:22 <napping> It's just a {_} that takes a row to a record, and a <_> that takes a row to a variant type, but rows are rows
08:40:36 <napping> they even match up more closely for extensible cases
08:40:37 <deweyvm> hmm ill try it, thanks :)
08:40:40 <Twey> deweyvm: I mean, not necessarily bundle all of them into one big record; I don't know what the o and r are for, but o1 and o2 and r0 and r1 and r2 at least look like they belong together
08:41:17 <szymanowski> Hello, Is it possible extend a builtin Type to a user typeclass? like: instance MyTypeClass Num where ...
08:41:17 <napping> A case is basically applying {row => a} to <row>, if you let row => t mean each type in the row is wrapped in (_ -> t)
08:42:26 <Lutin`> szymanowski: Num is a typeclass, but you can do 'instance Num a => MyTypeClass a where'
08:42:55 <szymanowski> ok great, thank you
08:42:56 <monochrom> please don't do that. it does not mean what you think.
08:43:19 <monochrom> instead, "class Num a => MyTypeClass a" and then write instances
08:43:31 <Lutin`> Ah yeah sorry that's what I meant
08:43:34 <monochrom> in fact, s/write instances/write specific instances/
08:44:42 <szymanowski> I will try, thank you
08:45:15 <Peaker> given the paper on boxy types suggests that it has already been implemented for GHC (a while ago),  how come:  ":t runST . forever"  still fails in ghc-7.8.3? :(
08:45:20 <Peaker> 7.8.2, oops
08:45:42 <Peaker> is that not in ghc yet or does that paper not allow  "runST . forever"?
08:45:46 <monochrom> because I think it's only done for $
08:46:06 <qrada> anyone know if there's a channel on freenode dedicated to haskell performance/parallelism/concurrency stuff?
08:46:52 <Peaker> monochrom: why? Shouldn't it just resolve the RankN problems once and for all (at least given explicit annotations for polymorphic arguments)?
08:47:04 <monochrom> then I don't know
08:47:06 <Lutin`> qrada: Could you post the code too?
08:47:14 <Peaker> well, reading the paper then :)
08:47:23 <rwbarton> boxy types is obsolete I think
08:47:23 <qrada> sure.. to preface, im getting absolutely wrecked by this.. ;f
08:47:30 <Peaker> rwbarton: why?
08:47:33 <qrada> https://github.com/adarqui/AFP08-notes-examples/blob/master/src/AFP08/FibEuler.hs
08:47:36 <qrada> there's the code
08:47:57 <rwbarton> I think OutsideIn(X) replaced it
08:48:04 <rwbarton> not sure though
08:48:17 <qrada> the world is not making sense to me with these tests
08:48:32 <Lutin`> Oh man
08:49:03 <Peaker> rwbarton: why does it still not work to instantiate (.) at polytypes? And impredicative types are still considered a problem?
08:49:13 <Lutin`> Yeah that definition of fib is fairly heavy
08:49:18 <rwbarton> Peaker, don't ask me
08:49:23 <rwbarton> I know nothing about these things
08:49:28 <Peaker> who's the regional type system expert? :)
08:49:32 <qrada> ya.. but.. Lutin` , i'm try to 'de-heavy it' via par/pseq
08:49:37 <qrada> that's the problem im having
08:50:09 <qrada> ie, I want my use of par/pseq to get me some parallelism on another core and thus make par'fib'euler'sum'4 the fastest of all of those tests
08:50:17 <qrada> which, by teh document im trying this from, says would happen
08:50:23 <qrada> but it's actually going the opposite direction
08:50:31 <rwbarton> qrada: have you timed fib and euler independently to make sure there is enough parallelism?
08:50:41 <monochrom> f `par` (f + e) means: the answer is f + e; however, attempt to compute f and f+e in parallel
08:51:10 <rwbarton> e.g. your profiling output suggests fib is roughly 20x as expensive as euler
08:51:19 <qrada> rwbarton: so time each one separately?
08:51:29 <monochrom> e `pseq` (e+f) means: the answer is e+f; however, must compute e before computing e+f
08:51:37 <qrada> rwbarton: ya well that's the thing.. im taking these examples from http://research.microsoft.com/en-us/um/people/simonpj/papers/parallel/AFP08-notes.pdf
08:51:43 <jcullen> I got that game event system working finally.
08:51:46 <qrada> monochrom: ya..
08:51:50 <jcullen> in case anyone I've been bouncing ideas off of the past few days is around
08:51:56 <jcullen> here is what I came up with: http://pastebin.com/M8snP0rW
08:52:34 <rwbarton> oh hmm, fibs does no allocation
08:52:59 <jcullen> slomo: Thanks for that snippet.  it wasn't directly relevant but it got me thinking about existential types which proved useful
08:53:15 <qrada> the tutorial says you can't reason about f `par` (f+e) or f `par` (e+f), because of the lazyness of +.. so it says to do that f `par` (e `pseq` (f + e)) to achieve the correct speed increases
08:53:23 <qrada> because now you know exactly how it will behave
08:53:30 <monochrom> + is not lazy, usually
08:53:39 <rwbarton> qrada: try building with -fno-omit-yields
08:53:44 <qrada> but the slowest function of them all (based on the tutorial), is performing the best.. the fastest one in the tutorial, is the worst
08:53:52 <yaymukund> in a list comprehension, is there a way to say "get 3 vars from this generator". so instead of `[(a,b) | a <- [1..n], b <- [1..n]]`, I'd like something like `[(a,b) | (a, b) <- [1..n]]` or something.
08:54:02 <yaymukund> get *2 vars from this generator
08:54:41 <rwbarton> yaymukund, no, but you could simply write a function to do that
08:54:49 <rwbarton> [(a,b) | (a, b) <- pairs [1..n]]
08:54:51 <c_wraith> qrada: are you actually using multiple cores?  And is the cost of generating f and e high enough that you get a real gain despite the overhead of bookkeeping?
08:55:02 <Lutin`> qrada: You'd not looking at the right time
08:55:02 * hackagebot haddocset 0.1.0 - Generate docset of Dash by Haddock haskell documentation tool  http://hackage.haskell.org/package/haddocset-0.1.0 (HirotomoMoriwaki)
08:55:16 <yaymukund> rwbarton: cool, that makes sense. getting used to doing things the haskell way
08:55:19 <qrada> ya im witnessing it using multiple cores
08:55:21 <yaymukund> ty
08:55:26 <pavonia> :t pairs
08:55:28 <lambdabot> Not in scope: ‘pairs’
08:55:30 <Lutin`> qrada: It takes more total cpu time, but about half of wall clock time
08:55:32 <qrada> trying the -fomit-no-yields flag
08:55:50 <qrada> Lutin`: but that's the thing.. I have my 'elapsed' function give me the wall clock time
08:55:53 <pavonia> rwbarton: What is pairs?
08:56:13 <rwbarton> pavonia, a function one could write
08:56:16 <qrada> ------------------------- ParSumFibEuler4 42 5300 +RTS -N2:
08:56:16 <qrada> Starting: ParSumFibEuler4
08:56:16 <qrada> Elapsed time: 17.420506
08:56:22 <qrada> that Elapsed Time: is from my elapsed function
08:56:35 <qrada> if I use 'time' on that program, it'll give me the same time as elapsed
08:57:09 <qrada> $ time ./.cabal-sandbox/bin/ParSumFibEuler4 42 5003 +RTS -N2
08:57:09 <qrada> Starting: ParSumFibEuler4
08:57:09 <qrada> Elapsed time: 16.866016
08:57:10 <qrada> real    0m16.869s
08:57:13 <qrada> sorry for the pastes guys
08:57:31 <Lutin`> the pastebin you linked earlier showed total time  =        8.66 secs
08:57:37 <qrada> so, i'm running my fib+euler test in between two time functions, which gives me the Elapsed Time:
08:57:43 <monochrom> "Basic Parallelism: The Evil Monad" :)
08:57:54 <rwbarton> Lutin`: that's from the profiler
08:58:02 <qrada> ya Lutin`
08:58:05 <qrada> I see that too
08:58:13 <qrada> but the program is taking longer than 8s to complete
08:58:20 <qrada> it's taking Elapsed time: to complete
08:58:34 <qrada> maybe my brain is melting..
08:58:34 <rwbarton> I think what is happening maybe is that profiling ticks are only occurring on one thread
08:58:45 <rwbarton> but it assumes they are happening on both, and divides
08:59:01 <Lutin`> Is it maybe the 2GB of allocation that's happening?
08:59:01 <qrada> ya because every time i see that time split in half, the actual time is double
08:59:27 <qrada> thing is, even if i make it less intense (ie a smaller fib), the 'slow fnction' always beats my par/pseq variation
08:59:39 <qrada> so 1 core is always beating out my multi core tests
08:59:44 <Lutin`> Ah nevermind gc seems to be low
09:00:03 * hackagebot focus 0.1.0 - A general abstraction for manipulating elements of container data structures  http://hackage.haskell.org/package/focus-0.1.0 (NikitaVolkov)
09:00:50 <rwbarton> what were the results with -fno-omit-yields?
09:01:01 <qrada> oh sorry
09:01:18 <qrada> slightly faster, but probably not significant.. faster by ~.8 s
09:01:20 <qrada> on the test i did
09:01:31 <qrada> $ time ./.cabal-sandbox/bin/ParSumFibEuler4 42 5003 +RTS -N2
09:01:31 <qrada> Starting: ParSumFibEuler4
09:01:31 <qrada> Elapsed time: 16.866016
09:01:32 <qrada> real    0m16.869s
09:01:36 <qrada> that's with -fno-omit-yields
09:01:40 <rwbarton> hm
09:01:47 <rwbarton> for me it made the numbers look reasonable
09:02:08 <rwbarton> I also turned off profiling though
09:02:50 <qrada> i can commit this test.sh if you want it'll run all of those tests i ran
09:03:10 <qrada> im still seeing this crazy behavior
09:03:33 <Lutin`> What OS are you on?
09:03:34 <qrada> ok so, maybe let's backup 1 sec, if you guys who are helping could maybe look at this: http://research.microsoft.com/en-us/um/people/simonpj/papers/parallel/AFP08-notes.pdf
09:03:47 <qrada> they have the exact example im using (which they say gets 2x speed increase)
09:03:49 <Lutin`> I'd check out http://www.haskell.org/haskellwiki/ThreadScope
09:03:50 <qrada> Lutin`: Linux
09:04:01 <qrada> a bunch of different linux boxes, and mac
09:04:03 <qrada> all performed the same
09:04:06 <qrada> ok 1sec
09:05:14 <qrada> on page 9 of that doc
09:05:31 <qrada> you'll see they say that (my par'fib'euler'sum'4) results in a 2x speed increase
09:05:34 <qrada> for them
09:06:20 <qrada> ive tried calling those functions multiple ways.. not even in elapsed etc.. by themselves etc.. everything results in the same
09:06:32 <qrada> so ya im basically mindwrekt
09:10:00 <Ankhers> Could anyone suggest a way to fix this type error? http://lpaste.net/105875
09:10:31 <chrisdone> fire! and lots of it!
09:11:01 <chrisdone> ankhers: what type is echo?
09:11:04 <Ankhers> If it matters, I'm trying to create a basic warp application
09:11:07 <napping> you are trying to mix bytestrings and text
09:11:55 <napping> dropping the package and module prefixes, it just says "expected type Bytestring with actual type [Text]"
09:12:03 <rwbarton> qrada: with -fno-omit-yields and no profiling I do see the expected parallelism: http://lpaste.net/105876
09:12:48 <rwbarton> I would guess the profiler is somehow interfering
09:13:04 <Ankhers> Essentially, pathInfo returns a [Text], which I check against. and responseLBS looks for a ByteString. I am just trying to echo back to the user what they placed in the URL.
09:13:39 <qrada> rwbarton: thanks so much man..
09:13:43 <qrada> ok so...
09:13:52 <qrada> this is the first glimpse into the idea that i'm not going insane
09:14:18 <qrada> i have library/executable profiling 'enabled' by default on my dev machine etc.. so even when i don't compile with -prof, maybe it's somehow effecting it?
09:14:26 <qrada> let me scratch all of that and add your compile flag
09:14:41 <qrada> also, i looked for that flag, not sure what it does.. sometimes ghc flags are hard to find eh!
09:14:44 <qrada> pdkgdposkgfdo
09:15:32 <chrisdone> qrada: what, you don't spend your spare time reading ghc's manual?
09:15:33 <monochrom> no, if you don't add -prof, you don't get affected profiling libs
09:15:36 <rwbarton> yeah, because the version that is documented is -fomit-yields (on by default)
09:17:33 <qrada> chrisdone: wish i had that time tbh.. hehe!
09:18:11 <qrada> rwbarton: thanks alot for your help man.... so it's the profiling that is wrecking me..
09:18:38 <qrada> confirmed it on my end
09:19:02 <qrada> not seeing a 2x speed up but definitely finally seeing -N2 outperform -N1 and par'4 beat the slow fib func
09:19:17 <rwbarton> you don't see 2x speed-up because your problems are not well balanced in size
09:19:30 <Lutin`> Huh..
09:19:46 <Lutin`> I'm not getting proper parallelism
09:19:49 <rwbarton> in my lpaste you can see the runtime for the parallel version matches the longer of the two computations
09:19:54 <Lutin`> let me try no-omit-yields
09:20:39 <rwbarton> fib does no heap allocation, so without -fno-omit-yields, if a worker thread starts evaluating fibs n, it will never get preempted
09:20:51 <rwbarton> I don't totally understand why that explains the results we see, but it seems plausibly related
09:21:18 <Lutin`> I opened it in threadscope
09:21:33 <Lutin`> and it's only running on one thread
09:21:48 <qrada> ok so..
09:22:05 <JoaoPortela> Hey! I'm going on a long flight and would like to take the opportunity to practive some haskell on my windows laptop. Any recomendations on what I should install prior to the flight (assume I have nothing haskell related installed) and what tutorials should I download?
09:22:24 <armlesshobo> JoaoPortela: the haskell platform
09:22:26 <qrada> when i increase fib without increasing euler... then i'm going to run the risk of the 'not enough parallelism'.. basically, im just waiting on fib to complete at that point
09:22:34 <rwbarton> if there's ever a use case for haskell platform, this is it
09:22:40 <qrada> so the example in the microsoft research paper uses fib=38 euler=5003
09:22:42 <armlesshobo> JoaoPortela: your editor of choice
09:22:52 <armlesshobo> JoaoPortela: Tylenol
09:22:56 <armlesshobo> Dramamine
09:23:01 <qrada> so if i up it to 42..... fib is now dominating even more, the percentage of work
09:23:06 <rwbarton> qrada, right
09:23:09 <qrada> and parallelism becomes useless (for the most part)
09:23:13 <rwbarton> yes
09:23:17 <qrada> i knew this struggle was worth it
09:23:17 <qrada> lul
09:23:42 <qrada> awesome, thanks folks..
09:23:59 <qrada> i think i'll be able to reason about things a bit more now and get past this initial par/pseq example in this doc hehe..
09:25:05 * hackagebot focus 0.1.1 - A general abstraction for manipulating elements of container data structures  http://hackage.haskell.org/package/focus-0.1.1 (NikitaVolkov)
09:25:12 <Lutin`> o.o
09:25:23 <Lutin`> Total allocated 16.7 GiB
09:26:45 <Lutin`> It seems I'm just getting tons of heap overflows
09:30:05 <rwbarton> most haskell programs allocate a few gigs per second
09:32:14 <Lutin`> http://imgur.com/yvDcxZg
09:32:37 <Lutin`> Does that look normal?
09:33:47 <Lutin`> I can't even match spj's threadscope results
09:34:43 <Lutin`> Maybe some recent update made the sumEuler super fast, and now the progrm is just dominated by fib no matter what
09:35:23 <rwbarton> oh, well, yeah
09:35:33 <rwbarton> you are scrolled way to the right
09:35:47 <rwbarton> so unless the two match very closely, you're going to be past the faster one completing, right?
09:36:30 <rwbarton> what happens in the first second or so?
09:36:57 <Lutin`> Well the second thread only runs for about 0.5 ms at the beginning
09:37:44 <rwbarton> is this with -fno-omit-yields?
09:37:51 <Lutin`> Yep
09:38:04 <rwbarton> what numbers are you running it with?
09:38:18 <Lutin`> The ones from the paper
09:38:26 <Lutin`> 38 5300
09:38:44 <Lutin`> http://imgur.com/NYCqY89
09:38:49 <Lutin`> That's the beginning
09:39:51 <rwbarton> this program only takes 0.877 s to run for me with those args
09:40:17 <Lutin`> weird..
09:40:21 <rwbarton> so I don't really know what's going on
09:40:30 <Lutin`> What are you compiling with
09:40:42 <Lutin`> And running with
09:40:52 <rwbarton> -threaded -O2 -Wall -rtsopts -fno-omit-yields
09:40:54 <rwbarton> +RTS -s
09:41:07 <rwbarton> profiling disabled
09:41:11 <qrada> The paper is from 2008.... I would think everything in there would hold 'exactly' as to what they are describing
09:41:16 <rwbarton> I've actually never used threadscope
09:41:29 <qrada> so Lutin` you are seeing some weird behavior? directly from the example in the paper?
09:41:30 <rwbarton> do you have to build with some different flags to use it?
09:41:30 <bennofs> qrada: 2008 is pretty old in haskell world
09:41:45 <Lutin`> wat
09:41:52 <qrada> the paper does have it's own par definition actually...
09:41:58 <qrada> par a b = b
09:42:00 <qrada> pseq = seq
09:42:19 <Lutin`> Oh :X
09:42:20 <qrada> perhaps GHC.Conc.Par , with those 'more proper definitions', ie calling lazy b etc.. is making the difference
09:42:26 <qrada> is that what's going on
09:42:28 <Lutin`> rwbarton: the paper doesn't use -O2
09:42:37 <rwbarton> oh
09:42:55 <rwbarton> I copied (and then modified) from qrada's repo
09:42:56 <Lutin`> But that actually doesn't affect it
09:43:13 <qrada> btw I also tried with par/pseq the way they had it, and without -O2 etc.. was experiencing the same behavior for everything
09:43:17 <qrada> just fyi
09:43:24 <rwbarton> "par a b = b" is not parallelism
09:43:26 <qrada> but you guys would know better than me with this stuff
09:44:09 <qrada> rwbarton: but can't it achieve parallelism? if 'a' gets assigned to some spark
09:44:28 <Lutin`> I'm only ever getting 1 spark
09:44:41 <rwbarton> par (the real one) is what creates sparks
09:44:50 <rwbarton> "par a b = b" means you can just replace "par a b" by b
09:45:09 <rwbarton> so a is irrelevant
09:45:34 <qrada> so will this create sparks or not, curious
09:45:34 <qrada> {-# INLINE par  #-}
09:45:34 <qrada> par :: a -> b -> b
09:45:34 <qrada> par  x y = case (par# x) of { _ -> lazy y }
09:45:37 <qrada> that's from ghc.conc.par
09:47:38 <rwbarton> Lutin`: there's only one spark in the program
09:47:56 <Lutin`> Oh qrada
09:48:14 <Lutin`> Nevermind you're importing par and pseq
09:49:18 <qrada> ya.. from control.parallel
09:50:36 <qrada> Lutin`: do you see a mistake on my part? curious
09:51:56 <Lutin`> Huh
09:52:11 <Lutin`> outputting the event log breaks the parallelism
09:52:28 <Lutin`> ah needed to do -N3
09:52:32 <rwbarton> aha
09:52:42 <Lutin`> There we go
09:52:51 <Lutin`> That's better
09:53:26 <Lutin`> http://i.imgur.com/1dXM8zz.png
09:53:41 <rwbarton> ooh pretty
09:54:12 <Lutin`> Also if I just do `import Control.Parallel` I guess it uses a different par?
09:54:52 <rwbarton> hm?
09:54:55 <Lutin`> Ah nope nevermind, user error
09:55:27 <Lutin`> Ran without -N3 after removing specific funtion imports
09:57:33 <Lutin`> Yeah -O2 makes it about 6x faster alone though haha
09:59:25 <rwbarton> oh, also with -O0 I guess you wouldn't need -fno-omit-yields
09:59:35 <rwbarton> because then the Ints in fib won't get unboxed
09:59:44 <rwbarton> so it will be allocating on the heap
10:01:39 <Lutin`> huh -fno-omit-yield is twice as fast
10:01:46 <qrada> fffff
10:02:00 <qrada> ofofofofo
10:02:17 <qrada> oops, sorry
10:02:21 <Lutin`> oh no I think qrada had an aneurysm
10:02:28 <qrada> hah nah, my internet died
10:02:41 <qrada> and my tmux got wrecked
10:03:09 <qrada> but ya I feel like I had a few of those lately
10:03:19 <Lutin`> Man I love arch
10:03:39 <Lutin`> The gtk2hs install guide lists packages in 3 other distros for gtk2hs-buildtools
10:04:17 <Lutin`> And their names are like Debian: libghc-gtk-dev, Fedora: ghc-gtk-devel,  Gentoo: available in the haskell overlay as dev-haskell/gtk
10:04:33 <Lutin`> In arch it's simply the same as the cabal name, gtk2hs-buildtools
10:04:38 <Lutin`> ftw
10:07:50 <qrada> Lutin`: http://community.haskell.org/~simonmar/papers/threadscope.pdf .. has the same fib/euler example from that other doc (one we were playing with)
10:16:39 <kini> what does `cabal sandbox hc-pkg` do?
10:16:49 <Lutin`> qrada: It works once I do -N3
10:17:12 <geekosaur> kini: runs ghc-pkg using the sandbox database instead of your normal database
10:17:50 <kini> why is it "hc-pkg" and not "ghc-pkg"?
10:18:10 <bennofs> kini: probably because cabal is supposed to support other haskell compilers
10:18:15 <geekosaur> because cabal has the conceit that it can work with other haskell compilers
10:18:21 <kini> also why is it not documented anywhere?
10:18:25 <kini> :(
10:18:29 <geekosaur> except too many parts are either tied to or only meaningful with ghc
10:18:37 <benzrf> hmmm
10:18:47 <geekosaur> (jhc just removed most of its attempots to support cabal because it was a lost cause)
10:18:54 <benzrf> there is a `cc' command but not an `hc' command
10:19:01 <mtbeedee> what's up with hackage?
10:19:07 <bennofs> mtbeedee: ?
10:19:14 <mtbeedee> you are talking about cabal...
10:19:19 <bennofs> oh, it's down
10:19:20 <benzrf> whats up eh
10:19:34 * bennofs can't type, it's up ofc
10:19:45 <Lutin`> It's up for me
10:19:45 <mtbeedee> I just ran cabal update on a new machine and it says "Killed" after "updating the index cache..."
10:20:22 <Lutin`> Yeah, up for me
10:20:29 <rwbarton> what OS? "Killed" could be the OOM killer
10:20:35 <mtbeedee> ahh ok
10:20:50 <Lutin`> You need more than 512MB of memory in my experience
10:21:03 <mtbeedee> yea, this is a vm.  makes sense
10:21:14 <Lutin`> Yeah I've run into that issue before
10:21:27 <qrada> Lutin`: when I had profiling enabled, I was getting even worse slow downs with -N3 than -N2
10:21:30 <qrada> ill retry in a bit
10:24:41 <johnw> does anyone know what the comonad laws are in terms of extract and duplicate?
10:24:58 <c_wraith> I'm sure *someone* does
10:25:45 <johnw> i bet edwardk knows them
10:26:05 <c_wraith> johnw: I bet the documentation knows. http://hackage.haskell.org/package/comonad-4.2/docs/Control-Comonad.html
10:26:14 <c_wraith> johnw: I would win that bet, having just read the documentation
10:27:02 <kini> !? why would you need 512 MB of memory just to download the package list from hackage?
10:27:02 <johnw> excellent!  I should have checked there instead of Google :)
10:27:03 <benzrf> johnw: i'd imagine theyre the monad laws, but co
10:27:04 <benzrf> ;)
10:27:05 <johnw> thanks
10:27:48 <c_wraith> comonad colaws
10:27:59 <yaymukund> I haven't learned about monads yet, so I'm going to pretend that's like the robot laws
10:28:11 <c_wraith> yaymukund: pretty much the same thing, yeah
10:28:28 <yaymukund> :))
10:28:51 <benzrf> when i saw 'Cokleisli' for the first time my brain parsed it as a whole new thing and not as 'Co Kleisli'
10:29:06 <c_wraith> Coke lisli
10:29:19 <benzrf> i think it tried to lex Cok or Coke as a single token and then the rest looked diff
10:29:42 <chrisdone> kini: an embarassing bug in the http library
10:29:49 <kini> oh?
10:30:13 <chrisdone> downloads the file as string chunks and then fold ++'s and then reverses it, or something like that
10:30:24 <chrisdone> basically the worst thing you could probably do
10:31:14 <chrisdone> https://github.com/haskell/HTTP/pull/48
10:31:32 <luite> is there an easy way to get progress info (for a large download) from that lib by the way?
10:31:52 <benzrf> 1. make monad subclass of applicative
10:31:56 <benzrf> 2. make join the only method
10:31:58 <benzrf> 3. yay
10:32:10 <kini> chrisdone: ... wow
10:41:15 <rondo> Has anyone been able to get hmatrix to install on OSX 10.9? When I try to install, it quits saying it can't find GSL
10:41:26 <rondo> or it can't link GSL rather
10:54:09 <SrPx> What would you guys call the foo function below?
10:54:34 <fread2282> what happened to that article hating on go and talking about rust and haskell?
10:54:41 <SrPx> >  let foo op min x | x == min = x; foo op min x | x /= min  = (op x) . (foo op min) $ x - 1 in foo (*) 1 4
10:54:42 <lambdabot>  24
10:54:56 <benzrf> benzrf.com/misc/notstronger.mp3
10:55:02 <benzrf> oops wrong chanenl
10:55:19 * hackagebot haskell-docs 4.1.0 - A program to find and display the docs of a name from a  given module.  http://hackage.haskell.org/package/haskell-docs-4.1.0 (ChrisDone)
10:56:04 <jfischoff> Is there any reason to use a (TBQueue a) vs MVar [a] if I always read the whole TBQueue at once?
10:56:23 <Lutin`> chrisdone: It still requires that much memory though
10:56:44 <Lutin`> But it's after the HTTP download once cabal starts working with the data
10:56:47 <chrisdone> Lutin`: perhaps because it loads it all into memory? dunno
10:57:05 <chrisdone> oh, i don't think cabal has received much optimization
10:57:58 <Lutin`> hmm maybe that's what I'll do today
10:59:20 <fread2282> jfischoff: better write performance?
11:02:00 <napping> SrPx: I'd call it foldr1 op [x,x-1..min], I think
11:03:36 <SrPx> napping: sure, and what would you call let foo op min x = foldr1 op [x,x-1..min] ? d;
11:03:52 <qrada> so when it doesn't say I have 1 converted, instead for example Gc'd, it means my 'work' is not in proportion? (sparks/parallelism) -> SPARKS: 1 (0 converted, 0 overflowed, 0 dud, 1 GC'd, 0 fizzled)
11:04:26 <napping> I doubt I'd bother naming it
11:05:18 <napping> I might name fold-by-op for specific operators, and the interval thing
11:05:28 <napping> as in product [1..4]
11:05:40 <Lutin`> Maybe like
11:05:54 <Lutin`> foldrFromTo
11:06:09 <Lutin`> or ToFrom
11:09:06 <rwbarton> I would name it george
11:09:35 <Mathnerd314> how do I tell cabal install to compile&install stylish-haskell from hackage, but instead of using haskell-src-exts from hackage, to instead use the version in my Git repository?
11:10:39 <qrada> Mathnerd314: cabal-meta
11:11:02 <qrada> I use it all of the time, it works great.. you put your github dependencies/etc inside of a sources.txt .. so it becomes a wrapper on top of cabal
11:11:16 <qrada> so initially you do cabal-meta install instead of cabal install
11:11:34 <qrada> https://github.com/yesodweb/cabal-meta
11:12:15 <rwbarton> recent cabal also has something built-in for this, I think, cabal add-source
11:12:32 <Mathnerd314> yeah, I have cabal 1.20
11:15:39 <Lutin`> What's the best way to share a cabal sandbox between cabal projects?
11:15:57 <Lutin`> atm I'm just soft linking the directory and cabal.sandbox.config
11:16:37 <Mathnerd314> Lutin`: so that's just cabal sandbox init --sandbox=<path to sandbox>
11:23:25 <jfischoff> fread2282: better write performance in the TBQueue case?
11:25:22 * hackagebot csound-expression-dynamic 0.0.4 - dynamic core for csound-expression library  http://hackage.haskell.org/package/csound-expression-dynamic-0.0.4 (AntonKholomiov)
11:25:24 * hackagebot csound-expression-typed 0.0.4 - typed core for the library csound-expression  http://hackage.haskell.org/package/csound-expression-typed-0.0.4 (AntonKholomiov)
11:26:02 <genisage> > uncurry (flip seq) (1,2)
11:26:03 <lambdabot>  1
11:26:08 <dcoutts> jfischoff: TBQueue is of course bounded where as an MVar [a] is not
11:26:54 <jfischoff> true for the sake of argument replace [] with BoundedList
11:27:39 <jfischoff> I guess what I was thinking is if I have to retry the whole queue on a read, that means there will be contention between the reads and writes
11:27:59 <jfischoff> so I’m not sure there is much value over a MVar
11:28:12 <dcoutts> jfischoff: just thinking...
11:28:14 <jfischoff> err s/retry/retrieve
11:28:51 <dcoutts> jfischoff: so your reader blocks in a readTBQueue and when it works it does tryReadTBQueue as many times as it can until it would block?
11:29:03 <jfischoff> yes
11:29:07 <Lutin`> Mathnerd314: Ah okay thanks
11:29:11 <jfischoff> that is exaclty what it does
11:29:25 <dcoutts> jfischoff: and you expect most of the time for the reader to be blocking, waiting for new input
11:29:51 <jfischoff> that appears to be the case, because the list retrieved is rarely over length 1
11:30:22 * hackagebot csound-expression 3.2.3 - library to make electronic music  http://hackage.haskell.org/package/csound-expression-3.2.3 (AntonKholomiov)
11:30:35 <dcoutts> jfischoff: so I'd still use the TBQueue because it already exists and gets the corner cases right, and the cost vs an MVar (with correct exception stuff) is pretty minimal
11:31:04 * jfischoff nods
11:31:09 <mmachenry> I am using bracket to ensure that my handles are closed. The problem is bracket reraises the exception. Can anyone suggest a better way to write this that does that? The ways I have come up with require unrolling a lot of my concise code into 'do` and 'case' http://lpaste.net/105881
11:31:18 <dcoutts> jfischoff: STM is not nearly as expensive as you think
11:32:12 <JoaoPortela> armlesshobo, thanks.
11:32:13 * jfischoff nods
11:33:07 <johnw> mmachenry: just use `catch` and close the handle?
11:33:08 <dcoutts> jfischoff: and also note that if you do want it bounded, the MVar one gets a lot more complex. It's not just a matter of changing the pure structure inside the MVar because the boundedness is related to the blocking behaviour.
11:33:20 * jfischoff nods
11:34:03 <jfischoff> yeah I don’t actually see a clear way to do that.
11:34:24 <mmachenry> johnw: Yeah doesn't allow me to be point free about the file handle, so far as I know.
11:34:48 <dcoutts> jfischoff: it's doable but tricky, and the more tricky the MVar code gets the more attractive the STM code gets :-) (and the perf gap also narrows)
11:34:57 * jfischoff nods
11:35:33 * dcoutts has learned to stop worrying and love STM (after doing some benchmarks on concurrent queues)
11:35:57 <Lutin`> Does anyone know how the parallel compilation in GHC works?
11:36:22 <Lutin`> When someone was describing it it sounded like the supervisor queue used busy waiting instead of signals to monitor the threads
11:36:29 <jfischoff> so I have this odd bug last night. The writers to a TBQueue were detecting that it was full, but the readers showed a barely filled queue. Any ideas? (beyond mistaken metrics)
11:36:42 <Lutin`> which would explain the high kernel overhead when I build with parallel
11:36:48 <luite> dcoutts: do you still have those benchmark programs and are they simple to run as a standalone program (with just some terminal output)?
11:36:55 <darthdeus> what do you guys think about purescript vs fay?
11:37:13 <johnw> mmachenry: you could certainly write a helper function that would let you be pointfree at the place of use
11:37:26 <darthdeus> it seems that fay is more stable, but it doesn't have typeclasses
11:37:32 <dcoutts> luite: they were from Simon M's summer school exercises from a couple years ago. It's all available somewhere. (I was playing TA for his classes)
11:40:00 <dcoutts> jfischoff: no immediate guesses. Where were getting the metrics from?
11:40:41 <mmachenry> johnw: I wrote my own bracket that does this. I was hoping it just already existed. :)
11:41:08 <jfischoff> I record stats into this at work: https://github.com/imvu-open/istatd
11:41:23 <mmachenry> johnw: Haskell has spoiled me. Whenever I have an idea to make code more readable and high level it already exists and I don't even need to keep it implemented in my program.
11:41:24 <luite> dcoutts: ah good. i could use a few more test cases and benchmarks there. the ghc testsuite was rather light on stm tests when i checked last year, fryguybob (ryan yates) helped provide some test cases (he was working intel tsx supported stm then)
11:41:38 <mmachenry> johnw: This might be my first original idea ever :-P
11:41:59 <dcoutts> jfischoff: I mean the size of the queue is coming from the readers, based on the size of list the manage to read from the queue? or some separate size check?
11:42:09 <jfischoff> anyway after I read the whole queue, I log the size. Before I write I check if the queue is full and throw an exception it that case
11:42:24 <dcoutts> I see
11:42:26 <Lutin`> anyone handy with ghc space profiling?
11:42:45 <Lutin`> How can I see what PINNED consists of?
11:43:07 <jfischoff> I have isFullTBQueue and if statement to either write or return an error in a transaction
11:43:44 <dcoutts> jfischoff: ok, seems reasonable for testing purposes
11:43:59 <Lutin`> I'm guessing it's bytestrings
11:44:00 <jfischoff> on going logging, but testing too
11:44:10 <jfischoff> health monitor etc
11:44:19 <dcoutts> jfischoff: oh but if you throw an exception rather than blocking doesn't that screw things up?
11:44:50 <dcoutts> jfischoff: since it's a bit of a mystery, you could do worse than to sample the internal Int values in the TBQueue
11:44:53 <jfischoff> no that is the behavior we want. It is for a send and forget analytics service. The latency is sub millisecond and we want that
11:45:19 <dcoutts> jfischoff: ahh, you want discard on overflow
11:45:21 <dcoutts> fair enough
11:45:25 * jfischoff nods
11:46:34 <dcoutts> jfischoff: if performance is critical here, it is probably possible to customise the TBQueue to better fit the use pattern
11:47:10 <jfischoff> ah right, don’t return when full I guess
11:47:12 <jfischoff> err
11:47:16 <jfischoff> don’t retry
11:47:44 <jfischoff> in writeTBQueue that is
11:48:23 <dcoutts> jfischoff: and also, you can get much of the batching for free given the way the items are shuffled between the two TVars
11:48:46 <dcoutts> jfischoff: if you don't mind clearing the whole queue every time you can grab the whole list in one read (usually)
11:48:51 <jfischoff> right
11:48:53 <dcoutts> erm not clearing
11:49:53 <dcoutts> jfischoff: not obviously related to the problem you're seeing of course
11:50:21 <jfischoff> sure but if I am going to make my queue for testing might as well fit the problem … I guess
11:50:27 <dcoutts> jfischoff: I'd recommend logging the internal Int vals and see if that sheds any light on the matter
11:50:33 * jfischoff nods
11:50:45 <jfischoff> thanks
11:52:22 <luite> i wonder if doing most of the work with atomicModifyIORef would make a difference
11:52:40 <luite> if you don't need blocking on an empty queue you don't need anything else even
11:53:39 <luite> but i might've missed some of the requirements
11:53:47 * jfischoff is thinking
11:53:56 <bitemyapp> jfischoff: feeling thoughty?
11:54:04 <jfischoff> always ;)
11:54:13 <Lutin`> Any ideas? https://clbin.com/bWyyVd.png
11:54:15 <bitemyapp> jfischoff: finally got my first PR into hackage-server :)
11:54:25 <jfischoff> awesome
11:54:30 <jfischoff> what is it?
11:54:47 <Lutin`> chrisdone: ?
11:55:08 <bitemyapp> jfischoff: https://github.com/haskell/hackage-server/pull/220 cleanup, preparation for 7.8 compat, making the dependencies not quite as completely antediluvian.
11:55:17 <Lutin`> I guess it's probably not an important thing to optimize for most people
11:55:32 <bitemyapp> jfischoff: some documentation to help mac users that want to work on it.
11:55:38 * jfischoff nods
11:55:52 <chrisdone> Lutin`: pinned memory usually comes from things like bytestring with its internal buffers iirc
11:56:27 <chrisdone> maybe here https://github.com/haskell/cabal/blob/master/cabal-install/Distribution/Client/Tar.hs#L546
11:57:04 <chrisdone> it seems that cabal contains a complete tar implementation
11:57:23 <dcoutts> chrisdone: it's a copy of the tar package
11:57:40 <dcoutts> chrisdone: currently inlined until we add the tar package to the platform
11:57:41 <chrisdone> figures, avoid dependency issues
11:58:12 <dcoutts> chrisdone: but note that the tar package itself is quite good about streaming use cases, it doesn't itself retain memory
11:58:30 <dcoutts> tar being a linear format and all
11:59:41 <chrisdone> it'd depend on how it's being used, i think
11:59:43 <Lutin`> Does cabal update just download the index.tar.gz?
12:00:11 <Lutin`> Because uncompressed that file is only 390KB
12:00:48 <dcoutts> Lutin`: erm, uncompressed the index file is ~15Mb
12:00:55 <dcoutts> it's big
12:01:10 <benzrf> chrisdone: i am reading http://chrisdone.com/posts/haskell-lang
12:01:11 <jfischoff> luite: I think you are correct. The IORef version seems safe to me … right now
12:01:15 <benzrf> you /like/ purple + green?!
12:01:19 <benzrf> wtf man
12:01:41 <benzrf> i appreciate purple as much as the next guy, but with /green/?
12:01:54 <Lutin`> dcoutts: The one at /packages/index.tar.gz?
12:01:56 <chrisdone> benzrf: yeah grass and forests are ugly as hell
12:02:03 <dcoutts> Lutin`: yes
12:02:06 <benzrf> green's cool too
12:02:06 <bitemyapp> benzrf: I like purple and green too.
12:02:08 <benzrf> just
12:02:12 <benzrf> purple WITH green is gross
12:02:20 <benzrf> yall are nuts
12:02:51 <Lutin`> dcoutts: Oh derp
12:03:00 <Lutin`> Uncompressed it's 382 MB
12:03:24 <Lutin`> had my blocksize for du set wrong
12:03:52 <chrisdone> duncan says 15mb, you say 382mb. who knew .tar files were so elusive?
12:04:14 * chrisdone downloads to add a new number to the mix
12:04:30 <napping> is that .txz vs .tar?
12:04:39 <Lutin`> Well I just downloaded, uncompressed, and ran du to see how much it's taking up on my machine
12:04:44 <napping> or .tar.base64?
12:05:12 <Lutin`> But that includes the space that inodes take up as well probably
12:05:25 <dcoutts> chrisdone, Lutin`: sorry, was getting myself confused. On my system it's currently compressed 6.4M and uncompressed 116M
12:05:44 <Lutin`> huh wierd
12:05:44 <dcoutts> chrisdone, Lutin`: note that you never need to unpack it so the du size is not relevant.
12:05:52 <Lutin`> k
12:06:09 <dcoutts> cabal never unpacks the 00-index.tar
12:06:16 <Lutin`> Just looking into why cabal update spikes to nearly 300MB of ram
12:06:32 <Lutin`> But I'm probably not versed enough in Haskell to be doing that
12:06:51 <napping> I have a 128MB 00-index.tar.gz and a 6.9MB 00-index.tar.gz
12:07:01 <napping> isn't it necessary to decomporess the .tar.gz into memory to seek?
12:07:03 <Lutin`> I just know I've run into issues on low memory VMs with it running out of disk space
12:07:56 <Lutin`> You don't have to decompress the whole tar
12:08:34 <dcoutts> napping: cabal decompressed the .tar.gz to a .tar, but does not unpack it in the sense of creating 25,000 separate files
12:08:40 <napping> I'm just speculating cabal might use a convenient library that does
12:08:46 <Lutin`> actually nevermind you do because tar doesn't support random access
12:09:00 <int-e> or 42000 which is closer to the truth
12:09:03 <napping> Lutin`: you could decompress and throw away blocks in a streaming fashion to pull out what you want
12:09:04 <dcoutts> cabal also creates an index of the .tar file for random access :-)
12:09:19 <Lutin`> Ah yeah makes sense then
12:09:21 <rwbarton> is that the .cache file?
12:09:27 <chrisdone> it may be streaming perfectly but the data structures involved too lazy or generating garbage. hard to tell without looking into the use
12:09:31 <dcoutts> rwbarton: yes
12:09:37 <rwbarton> what high-level task is cabal doing when it uses lots of RAM? generating that cache?
12:09:39 <napping> is it the on-disk space of the .tar a problem?
12:09:41 <RedNifre> Hey there.
12:09:54 <dcoutts> napping: we don't consider it a problem
12:09:55 <chrisdone> oh, generating a cache would explain it
12:10:12 <napping> dcoutts: Lutin` said they had trouble running out of disk on some small machines
12:10:24 <RedNifre> Why is Maybe a either Just a or Nothing instead of a or Nothing?
12:10:28 <napping> Lutin`: was that disk for swap, or just disk space period?
12:10:35 <dcoutts> chrisdone: in principle that should be doable with low mem overhead, just need to retain the map that we're accumulating, package id -> block offset
12:10:35 <RedNifre> (I'm a total beginner when it comes to Haskell)
12:10:43 <napping> RedNifre: if it was just an a, it would be an a rather than a Maybe a
12:10:56 <Zekka> RedNifre: Just is a function a -> Maybe a
12:11:07 <dcoutts> napping: ghc is much much bigger than that, I don't think we can work with a 100M space constraint.
12:11:09 <Zekka> any sum type must provide functions that act something like that as constructors
12:11:14 <Lutin`> it might have just been a highly restrictive machine
12:11:19 <Zekka> (well, any sum type that can be constructed)
12:11:24 <ocharles> Blog post publishing time!
12:11:35 <Lutin`> Only had about 2GB free and used a swapfile but it kept getting killed
12:11:36 <rwbarton> are there really 129M of just .cabal files on hackage?
12:11:38 <chrisdone> oh, charles!
12:11:43 <Zekka> If you don't apply the constructor (Just), you don't get the Maybe
12:11:46 <napping> RedNifre: if you're asking about a runtime representation using null pointers for Nothing, that doesn't work nicely with laziness, but I think Rust optimizes like that
12:11:47 <ocharles> chris is done? chris done!
12:11:52 <RedNifre> I might be mistaken, but if I declare a function that takes a Maybe a, why do I have to write foo Just a =.. instead of foo a =?
12:11:56 <chrisdone> :3
12:11:58 <ReinH> ocharles: hai
12:12:08 <Zekka> RedNifre: Because they say different things
12:12:12 <ocharles> Hey ReinH
12:12:21 <Zekka> One matches for a and one matches for Maybe a
12:12:23 <napping> You said the argument is a Maybe a, so if you write foo x = ..., then x gets the whole Maybe a
12:12:33 <RedNifre> napping are you saying that "Just" is a runtime optimization?
12:12:40 <Zekka> Sorry I can't provide a better explanation other than that "this is how sum types work"
12:12:43 <napping> Another way to think about it, it if you have a Maybe a, you haven't checked if it's a real a or still Nothing
12:12:49 <Zekka> RedNifre: No, this is how sum types work
12:12:52 <napping> and an "a" is something you know for sure is a real a
12:12:59 <Zekka> they're a list of constructors which each have some type associations
12:13:09 <rwbarton> maybe it's good to specialize a = Char or whatever
12:13:11 <Zekka> like data Either a b = Left a | Right b
12:13:20 <napping> rwbarton: let's do that
12:13:46 <napping> RedNifre: other way around, I'm saying making the actual bits you get passed for "Hello" and Just "Hello" at runtime identical would be an optimization
12:13:49 <Zekka> or (pseudocode): data [a] = [a] | a:[a]
12:13:50 <RedNifre> Ah, so declaring foo Nothing =... and foo a =... is a bad idea since in order to figure out what foo Maybe... should call the runtime would have to "unpack" the maybe?
12:13:52 <chrisdone> haskell's null pointers are _|_ =p
12:13:56 <ocharles> http://ocharles.org.uk/blog/posts/2014-06-10-reversible-serialization.html have fun :}
12:14:13 <napping> RedNifre: no, let's say you want to write foo :: Maybe String -> String
12:14:25 <micahcowan> RedNifre, also, Haskell does not allow a function to return multiple different types, based on input values (though polymorphism lets it return different types based on input TYPES)
12:14:26 <ReinH> RedNifre: The runtime works by "unpacking" constructors via pattern matching.
12:14:29 <napping> foo Nothing = "Default"; foo a = a doens't compile, because the arugment "a" is a Maybe String
12:14:35 <chrisdone> ocharles: hey i did something similar t'other day
12:14:36 <Lutin`> dcoutts: Yeah I guess my situation wouldn't really hold up to a lot of things, so blaming cabal is pointing the finger in the wrong direction
12:14:55 <ocharles> chrisdone: yea, it's a fairly "obvious" idea - but extremely useful
12:14:56 <micahcowan> RedNifre, so, Just a is a way of returning the a you want, while still respecting Haskell's strict typing.
12:15:01 <RedNifre> napping ah, I think it might have clicked... let me ponder that for a moment...
12:15:02 <ocharles> thought it'd be good to get the idea into more peoples heads
12:15:02 <napping> you don't know that's it's really a String, as far as the type is concerned you're still not sure that "a" isn't Nothing, so you can't return it
12:15:10 <chrisdone> ocharles: i called it a 'Section'  with similar type to that actually. so it'd work with aeson or Show or w/e. like an Iso, but not bijective
12:15:33 <napping> a clause foo (Just a) = a says "Check if that maybe is really there, and if so let "a" be a name for the real value you get out"
12:15:41 <ocharles> chrisdone: the codez. i can needz them.
12:15:59 <Lutin`> ocharles: Oh this was what you mentioned to me about a week ago
12:16:03 <napping> ocharles: I was told there would be a new blog post
12:16:10 <ocharles> Lutin`: yea
12:16:18 <ocharles> napping: yea... it eventually got there. notice the date in the url :)
12:16:31 <Lutin`> Nice! Taking a look now
12:16:34 <chrisdone> aw i lost the code. i just write it in an emacs buffer and send it to edward and forgot about it
12:16:51 <chrisdone> but this is cool
12:16:53 <napping> "A Batch Querying Applicative Functor Without IORefs" is the newerst
12:17:25 <RedNifre> hmmm...
12:17:33 <napping> oh, direct url
12:17:43 <Lutin`> napping: Shows up on the listing for me
12:18:05 <napping> huh, maybe I've got a cache in the way
12:18:05 <deweyvm> im trying to install a library im writing locally. cabal is saying http://pastebin.com/Z0wFN2Lv but that directory does not exist and is not created. cabal is exiting with status 0
12:18:13 <deweyvm> i ran "cabal install"
12:18:22 <RedNifre> Maybe I was asking for syntactic sugar for dealing with Maybes, but that might be a bad idea since they aren't really a language feature but a simple function? Hm...
12:19:07 <deweyvm> my cabal version is 1.20.0.1
12:19:09 <ReinH> RedNifre: Types are a language feature. Pattern matching is a language feature.
12:19:24 <ReinH> Maybe is just a type.
12:19:34 <RedNifre> Yes, I think it's getting clearer...
12:19:44 <napping> it's just data Maybe a = Just a | Nothing
12:20:02 <orzo> Maybe does have syntactic sugar in the form of do syntax
12:20:02 <Zekka> RedNifre: Do you understand why data Maybe a = a | Nothing doesn't make sense?
12:20:08 <napping> maybe there could be a bit of sugar like you were saying, but that's kind of tricky
12:20:15 <micahcowan> RedNifre, There's lots of syntactic sugar for dealing with Maybes... for instance they're Monads, so you can have "do" followed by a slew of function calls, one per line, with the result being that if any of those functions return a Nothing, it will return Nothing, and otherwise the result is the final value.
12:20:18 <napping> any sort of implicit subtyping tends to really mess up type inference
12:20:38 <napping> The other thing I was talking about was the runtime representation
12:20:47 <napping> I guess there are two issues there
12:20:49 <micahcowan> (If you're still in the early stages of Real World Haskell (for instance), just keep reading until you see how to use Maybe as a monad... or search online for examples, is probably less hassle)
12:21:00 <RedNifre> Okay, how about this: I think my faulty understanding was "Maybe is a box that contains a value or Nothing", but now my understanding changed to "Maybe is either an empty box and that empty box is called Nothing, or it's a non-empty box which is called Just. So you first figure out which of these two boxes it is and if it's the Just box, you can take something out"
12:21:15 <Zekka> RedNifre: That's a pretty good intuition
12:21:30 <napping> if a null pointer already a legal value of type "a", you'd need to do something else to represent nothing - say for Maybe (Maybe a)
12:21:48 <Zekka> And anything inside a sum type must come in some kind of a box
12:21:48 <ocharles> napping: ack yes, my blog has annoying caching
12:21:52 <napping> also because of lazy evaluation, a "value" can be a pointer to some code to run to actually calculate the result
12:21:53 <ocharles> publishing new posts does not break the cache
12:22:13 <napping> not sure if that actually gets in the way, but maybe makes it a bit tricker
12:22:18 <Zekka> (where a sum type is one you define with `data`)
12:22:26 <Zekka> @src Maybe
12:22:26 <lambdabot> data Maybe a = Nothing | Just a
12:22:33 <Zekka> If you werre curious
12:22:36 <napping> Maybe a non-null pointer is pointing to a computation that will eventually return Nothing
12:22:44 <RedNifre> Thanks, I think I get it now.
12:22:45 <napping> so it's a bit tricky to do right, especially if it's an ordinary data type
12:22:47 <Zekka> it's something normal with normal source code
12:22:56 <Zekka> @src []
12:22:56 <lambdabot> data [] a = [] | a : [a]
12:23:12 <napping> If it's a bit more built in, like a ? type where you say ??a = ?a, then optimizing by null and stuff is easier
12:23:44 <Zekka> Minding that Haskell already has ways of saying that ??a is basically ?a, which are more general
12:23:46 <deweyvm> i didnt expose any modules, that was the error. terrible that it silently lets you do this though!
12:23:55 <Zekka> (join :: Monad m => m (m a) -> m a)
12:23:56 <RedNifre> Now, I like Maybe, but I was very surprised when the tutorial introduced Either. Either seems like a very messy thing, since Left or Right are completely nondescriptive. The tutorial used Left for an error message string and Right for the actual result, which reminded me of Go's multiple return values, which I also find very messy.
12:24:00 <ReinH> What is ??a? What is ?a?
12:24:06 <ReinH> Why do we need to introduce this weird syntax?
12:24:25 <Zekka> ReinH: Because a lot of people think Haskell's nullable vs nonnullable types are a good idea, but think monads are scary
12:24:28 <tromp__> Left is sometimes used as Wrong
12:24:49 <Zekka> Personally, I think Left and Right aren't descriptive names but Either's pretty much always used in exactly one way -- Left is an error, Right is a value
12:24:50 <napping> RedNifre: the menomic there is "sinister" from latin for left
12:25:02 <ReinH> Zekka: nullable vs nonnullable types?
12:25:09 <RedNifre> This Either seems like it's only useful as a reference implementation for something like a custom "Result" thing that could be either ErrorString or SuccessResult or something like that. Do you understand what I mean?
12:25:12 <ReinH> Zekka: except where it's used in the reverse way! :D
12:25:14 <Zekka> And mind that Haskell will never ever let you use an Either a b as a b, so it won't screw you like Go can sometimes
12:25:28 <Zekka> ReinH: I've never seen it used the reverse way except by people who really like fmapping over errors
12:25:37 <Zekka> ReinH: (Maybe a)s vs (a)s
12:25:38 <napping> RedNifre: yeah, nice things have a more proper result type
12:25:50 <ReinH> Zekka: there's EitherR
12:26:07 <napping> but then again Either has become fairly standard for a choice of error and result also
12:26:23 <napping> things like "try" which can be catching various different exceptions and of course have any type of normal result
12:26:30 <Zekka> ReinH: I didn't know about it, but looking at it now I'm tempted to say it kind of demonstrates my point
12:26:32 <ReinH> Zekka: http://hackage.haskell.org/package/errors-1.4.7/docs/Data-EitherR.html
12:26:39 <Zekka> that people would rather introduce a separate type than use Either 'wrong'
12:27:32 <napping> It might be somewhat more descriptive with a data Result err a = Wrong err | Ok a
12:27:39 <RedNifre> Not sure if I understood you correctly, but did you say that using Left for the bad result and Right for the ideal result is an established convention in the Haskell community?
12:27:48 <ReinH> Zekka: it's a new type introduced to allow redefinition of Functor, etc
12:27:48 <napping> yeah, it's fairly standard
12:27:53 <Zekka> RedNifre: Yeah, there's a reason why
12:27:55 <napping> http://english.stackexchange.com/questions/39092/how-did-sinister-the-latin-word-for-left-handed-get-its-current-meaning
12:28:02 <Zekka> ReinH: Yeah, I figured that out
12:28:10 <zq> what exactly does kind [*] mean?
12:28:25 <Zekka> which, once again, kind of my point -- the type system is governing usage here in a way that makes it pretty unpleasant to use Either 'wrong'
12:28:29 <ReinH> So I'm not sure it's evidence that people would rather introduce a separate type.
12:28:43 <Zekka> Well, they did, didn't they?
12:28:47 <micahcowan> Using Either and Maybe as Monads, instead of using exceptions, is nice because it forces the user to explicitly "catch" (by handling the Either or Maybe type), guaranteeing you don't just halt execution when that wasn't expected/desired (at least, until a "real" exception gets thrown because head was used on an empty list or something...)
12:28:51 <ReinH> It's evidence that people *have to* introduce a separate type if they want to define different instances
12:29:11 <micahcowan> (s/Either/an equivalent, more explicit structure/, if desired of course...)
12:29:12 <napping> RedNifre: if anything, Right being right/correct is an english thing
12:29:49 <micahcowan> Well, and Left is obviously silly for "Wrong". And Either is more versatile than simply "right" and "wrong", but I guess by convention it's most-often used that way.
12:30:07 <Zekka> ReinH: I'm kind of confused -- I'm arguing that due to various reasons including how Haskell's type system works, it's preferred that people use Either in this specific way
12:30:23 <RedNifre> Personally, I find this quite... suboptimal. Are you saying that Left Right is intuitive because if you know Latin and English you can read them not as directions but as "latin word with negative meaning" and "English synonym for correct"?
12:30:44 <Zekka> (sidenote: people basically can use the same type for both things with Bifunctor if they eally want to)
12:30:47 <napping> not intuitive, but that it's somewhat standard, and you can use that as a menomic
12:31:16 <Zekka> You seem to be arguing as if I'm arguing that people use Either just one way because less Haskell's type system, using it this way is only the sane thing to do
12:31:19 <ReinH> RedNifre: The actual reason it's intuitive is because it's a cultural norm.
12:31:30 <RedNifre> In C, it's somewhat standard to use -1 as "bad result" for functions that are supposed to return a positive integer, but I don't think that justifies it :/
12:31:31 <ReinH> And has relatively little to do with the etymology of sinister
12:31:34 <Zekka> RedNifre: You just get used to it.
12:31:42 <orzo> it's idiomatic
12:31:43 <micahcowan> Yeah, not necessarily a language thing, though I suspect that influenced it.
12:31:46 <orzo> a haskell idiom
12:32:08 <micahcowan> idiom, of course, meaning "thing you learn that's not actually part of the language, or intuitive on its own"
12:32:11 <micahcowan> But every language has 'em
12:32:26 <ReinH> micahcowan: that's why I said "cultural norm"
12:32:36 <ReinH> But yes, idiom also works.
12:32:59 <Zekka> Personally I think the names in Either are pretty stupid too and I'd have taken data Either a b = Failure a | Success b
12:33:24 <RedNifre> I completely agree with Zekka.
12:33:27 <micahcowan> Yeah. Anyway, RedNifre has a probably valid complaint, but you can always write your own isomorphic type (and even conversion functions to translate from other libraries' Either), but IMO something this small isn't really worth it, especially when the idiom is as pervasive as it seems to be
12:33:29 <napping> If you take "norm" as good, I suppose that's arguable, but only because there are standard functions and stuff for dealing nicely with Either
12:33:29 <ReinH> That is less general though
12:33:34 <Zekka> or possibly data Either a b = Except a | Value b (because Either behaves a *lot* like exceptions with a few short helper functions)
12:33:43 <micahcowan> * seems to be, stated from a guy who hasn't actually read much of a variety of Haskell code...
12:33:51 <chrisdone> ocharles: oh maybe it's different. the problem i was doing is a parser and printer that aren't a bijection but a section, so something like data Section f a b = Section { sect :: a -> m b, retract :: b -> a }; _Show :: (Monad m,Show a,Read a) => Section m String a; _Show = Section { sect = read, retract = show } and
12:33:51 <Zekka> ReinH: I'd agree, but I see this use a lot more than I see the general use
12:33:52 <chrisdone> then you could write generic code like sect _Show "5" :: Maybe Int, or sect _Aeson "[4,4]" :: Maybe Value and then retract _Aeson (Object ["x" .= 2]) :: ByteString
12:34:18 <Zekka> usually when I see some other kind of heterogeneous list it's more expressible with its own ADT
12:34:22 <micahcowan> Of course, when there's a near-ubiquitous idiom, sometimes the workarounds to make something more "pure" make for less readability than if it were just left alone...
12:34:23 <chrisdone> ocharles: something like that. rather like prisms but rather than bijective, they are explicitly surjective
12:35:00 <chrisdone> ocharles: anyhoo i see your post is about bijections so n/m
12:35:10 <ocharles> ah
12:35:13 <ReinH> It's trivial to make any sum type isomorphic to Either work like Either by deriving the various typeclasses
12:35:14 <Zekka> (if you have a list of members that can be of either one type or the other, I think what you probably mean is to define your own type describing that)
12:36:24 <chrisdone> ocharles: e.g. _Show here is an improper prism: http://hackage.haskell.org/package/lens-4.2/docs/Control-Lens-Prism.html#v:_Show
12:36:37 <ocharles> I thought it might be that
12:37:04 <ReinH> chrisdone: section and retraction might be a bit too CT for some people ;)
12:37:11 <ReinH> or too algebra
12:37:13 <chrisdone> ocharles: or are you calling it partial isomorphisms?
12:37:34 <chrisdone> reinh: lol
12:37:39 <Zekka> ReinH: I'll clarify -- I don't mean that people should define their own data Either a b = Left a | Right b for any case where they wold ordinarily like Either
12:38:04 <Zekka> I mean that in most situations I can think of where you want something like Either but not exceptional behavior, you want some other similar sum type
12:38:29 <ocharles> chrisdone: an improper prism is different from a partial isomorphism
12:38:29 <Zekka> something like data Order = Complete String | Incomplete (MoreInformation -> String), for instance
12:38:34 <ReinH> Zekka: sure
12:38:43 <chrisdone> ocharles: how do they differ?
12:39:04 <orzo> Zekka: atomically $ orElse (fmap Left x) (fmap Right y) -- I wanted another sum type?
12:39:04 <RedNifre> Ah, I also have a more meta question about learning Haskell: Is it a good strategy to get something working with incomplete Haskell knowledge first and refine it over time, or would this lead to bad habits that are hard to get rid of?
12:39:05 <ocharles> improper prisms just break the law, in that round-tripping normalizes the data
12:39:45 <Zekka> orzo: I'm not sure I understand your comment, can you clarify?
12:40:01 <ocharles> so "Just  5" would roundtrip to "Just 5"
12:40:05 <carter> i've a really really dumb parser error and i don't know why its failing
12:40:05 <Zekka> (currently looking up a few functions there because I don't know them offhand)
12:40:18 <ocharles> which is certainly in the same equivalance class, but is not the string you started with
12:40:19 <ocharles> so "Just  5" would roundtrip to "Just 5"
12:40:20 <ocharles> which is certainly in the same equivalance class, but is not the string you started with
12:40:22 <rwbarton> RedNifre: imo that is a great strategy
12:40:25 <ocharles> good work irc client.
12:40:57 <ocharles> chrisdone: that's what's improper about _Show, and all other parser-prisms
12:40:59 <Zekka> orzo: I don't know, based on that code, how you're using Either
12:40:59 <rwbarton> RedNifre: since you will appreciate why the new language features/libraries/etc. you learn exist, and how to implement them in terms of the fundamentals
12:41:17 <orzo> orElse will return the result that succeded first, the two alternatives are distingusihed mainly in that i listed one first, on the left, and the other next, further right.  Either seems ideal.  No right/wrong semantics
12:41:28 <RedNifre> For comparison, my experience with Ruby was that you could start with the basics, get something working and everything you learn after that only adds to it. I never had a moment where I thought "Oh no, I have been doing this all wrong and have to relearn it the right way".
12:41:58 <Zekka> orzo: How is it ideal where a type that specifically describes your problem is not ideal?
12:42:31 <micahcowan> RedNifre, well, maybe you'll have a moment like that (or perhaps not "wrong", but certainly, "less effectively" or whatever), but if so, so what?
12:42:56 <chrisdone> ocharles: right, just surjective. but what's a partial isomorphism? meaning you don't parse "Just  4" and only "Just 4" is valid?
12:43:39 <micahcowan> I mean, I've heard of people getting bitten by RWH, which has loads and loads of "bad example" code, mainly so that it can later introduce much better ways of doing things (but not telling the user until that point...)
12:43:58 <RedNifre> Do lists always start at 0?
12:43:59 <micahcowan> I'd prefer they told people they were doing that, but even so, what's the worst? Some mildly ugly code, that still works the way it should...
12:44:05 <ocharles> chrisdone: actually, maybe they are just orthogonal things. Partial isomorphism is like "natural numbers can always be mapped to integers, but we can't always map integers to natural numbers"
12:44:07 <ocharles> I... think.
12:44:38 <micahcowan> RedNifre, you mean, with the !! operator? Aside from that, lists don't really have an inherent index AFAIK
12:44:41 <ion> rednifire: Lists always start at (:)
12:44:46 <micahcowan> :)
12:44:58 <ion> non-empty lists, that is
12:45:02 <micahcowan> And arrays can be given absolutely any start index at all...
12:45:12 <orzo> Zekka: haskell doesn't allow casual local scope sum typtes, so you'd force the reader to go consult a definition for something that is basically a short-term marking
12:45:29 <RedNifre> What if I want to have an infinite chess board that has 0/0 in the middle?
12:45:34 <Zekka> orzo: How short-term?
12:46:03 <Zekka> Like I said, the line of code you posted does not tell me very much about what you're doing
12:46:13 <RedNifre> I can only think of clumsy ways to do that, like two infinite lists, one goes to the left, one to the right, and the elements are tuples of two infinite lists, one up, one down.
12:46:16 <rwbarton> in orzo's example, you might case-analyze the resulting value on the next line
12:46:21 <Zekka> Do you keep the left-and-right branches for a long time or do you turn them into something that looks like the same type pretty quickly?
12:46:23 <rwbarton> and then be done with the Either
12:47:14 <Zekka> rwbarton: Then why doesn't he just apply his cases to the results before they c ome out instead of mapping them in Left/RIght?
12:47:30 <Zekka> Then they'd be the same type as they come in.
12:47:35 <Zekka> wrapping them in Left/Right*
12:47:55 <Zekka> It'd just be fmap leftCase/fmap rightCase instead of fmap Left, fmap Right
12:48:09 <micahcowan> RedNifre, still not really understanding... "index" has very little meaning for Lists. Aside from, again, !!, you can represent your index into a list however you see fit. Of course, finding that index is always linear time, so I imagine something like a chessboard might work better if a particular position on that infinite board were generated directly by whatever algorithm you would otherwise have used to generate the infinite list...
12:48:43 <chrisdone> ocharles: oh, i see. natural numbers are a subset of the integers, because there is one and only one mapping from a natural to an integer and it's bidirectional within that mapping
12:48:51 <orzo> Zekka: can't be done if the case processing uses IO, best yo ucould do is have the atomically return an IO action and then bind the result afterward, which is okay, but a matter of taste if as there's a bit of awkwardness either way
12:49:34 <Zekka> orzo: I don't see much problem with the latter option although I'd agree that using an anonymous type in this case is probably bad
12:49:42 <Zekka> (Would you even have to bind the result? I think this is just a case for join)
12:49:43 <napping> ick, the Monoid for Data.Map maps deriving Monoid not work very nicely
12:50:09 <napping> I thought I could just to C x y z <> C x' y' z' = C (x<>x') (y<>y') (z<>z') and then found a nice library for that
12:50:11 <chrisdone> ocharles: whereas for parse.print, the set of parseable things has mappings to more than one parsed thing.  i.e. "Just  x" and "Just x" -> Just x is not a one-to-exactly-one
12:50:12 <rwbarton> yes, you could use join but now the inside of the "atomically" is very ugly
12:50:21 <chrisdone> ocharles: there's certainly a difference there
12:50:23 <ocharles> chrisdone: yea, that sounds right
12:50:25 <napping> but no, surprisingly enough I didn't want to just throw away map entries from the right side
12:50:25 <RedNifre> Well, consider this: You have your infinite chess board. You want to be able to move a piece from one cell to another, but you also want to be able to ask "Which piece is in this particular cell?". So I thought that the lazyness of Haskell would help me define the board in such a way that every cell is empty and takes no memory, until I actually move a piece there.
12:50:48 <ocharles> chrisdone: but it depends on what you need as to whether the "improper" stuff matters
12:50:50 <ocharles> iirc for lens, it can
12:50:51 <RedNifre> But I guess lists aren't fragmented, if I move a piece to say X=10, it generates all cells up to that position?
12:50:52 <ocharles> that's why it has laws
12:51:14 <Zekka> rwbarton: How is building an IO action in STM very ugly?
12:51:30 <rwbarton> imagine if for example one or both of the "continuations" is very long
12:52:06 <chrisdone> ocharles: yeah, indeed. that's why i thought an explicit section with its own surjective laws would be theoretically neat. in that setting it would be "proper" to parse more things than you produce. but i'll probably never have practical use, just thought it was neat
12:52:09 <rwbarton> I just mean it will be syntactically ugly
12:52:09 <ReinH> RedNifre: you can use a map
12:52:23 <Zekka> rwbarton: return $ do rather than do on the first line?
12:52:32 <Zekka> Or is there something I'm not considering?
12:53:06 <chrisdone> ocharles: (i.e. you wouldn't have a roundtrip law, you'd only have f.g=id and no more)
12:53:15 <rwbarton> Zekka: imagine "result <- atomically $ orElse (fmap Left x) (fmap Right y); case result of { Left l -> {- several lines -}; Right r -> {- several lines -} }"
12:53:25 * chrisdone puts ocharles's post on his kobo reader
12:53:36 <RedNifre> ReinH yeah, I guess I was overexited by infinite lists as in "when you have a hammer, everything looks like a nail". Having a map of the nonempty cells is probably more sensible.
12:53:40 <rwbarton> Zekka: now imagine "join $ atomically $ orElse (fmap (\l -> {- several lines -}) x) (fmap (\r -> {- several lines -}) y)"
12:53:45 <Zekka> You know, come to think of it, I actually do see a problem and it's kind of silly
12:53:56 <Zekka> You'r right that you do end up having to write it that way
12:54:03 <Zekka> you're*
12:54:07 <ReinH> RedNifre: you can use a list zipper of list zippers
12:54:14 <ReinH> but you probably just want a map
12:54:24 <Zekka> because there's no way to write a where clause in the middle of your do-notation that has access to everything up to where it starts, as far as I know
12:54:30 <micahcowan> RedNifre, yup, they have limits. But infinite lists are still way cool :)
12:54:31 <Zekka> (Ordinarily I'd say "just write a where clause!")
12:54:57 <rwbarton> yeah, you could use let but now the execution order is obscured
12:55:14 <Zekka> Not to mention that let syntax gets kind of screwy inside do notation
12:55:28 <micahcowan> Haskell's laziness also lets you represent a complex decision tree as a complete structure, and then only actually generates the parts you choose to follow.
12:55:42 <Zekka> I don't know specifically how but I'll ofetn have to tweak my code a little bit to get the whitespace to a point where Haskell's satisfied with it
12:56:07 <micahcowan> For instance, RWH's stripped-down Doc examples, where at every "soft" line break you can either follow the structure that puts a space there, or a line break. Both are entirely represented in the structure, but it only "exists" where you follow it. :)
12:57:02 <ReinH> Or game tree search that does pruning by not evaluating some paths.
12:57:08 <benzrf> Zekka: how does let syntax get screwy in do
12:57:32 <ReinH> benzrf: just the layout rules, I guess
12:57:50 <chrisdone> like
12:57:51 <chrisdone> do let x = 1
12:57:51 <chrisdone>     in foobar -- nope
12:57:51 <chrisdone> do let x = 1
12:57:52 <Zekka> benzrf: I'd have to experiment a little bit to give you the details, but if I remember right you're no longer allowed to put the binding on the same indentation level as the let
12:57:53 <chrisdone>     in bar -- yep
12:57:59 <chrisdone> oh, i screwed that up
12:58:13 * chrisdone needs shm in his erc client
12:58:21 <Zekka> in addition, if I know what Chris is getting at, if you use let/in you have to screw with indentation levels for the in
12:58:36 <chrisdone> yeah, that's what i meant
12:58:37 <micahcowan> The x value would have to be a monad type inside do, yes? otherwise I'd use a let outside the do...
12:58:52 <Zekka> micahcowan: Haskell doesn't care if it's a monadic type
12:59:03 <chrisdone> :t do let in these for view
12:59:05 <lambdabot> Not in scope: ‘these’
12:59:05 <lambdabot>     Not in scope: ‘for’
12:59:05 <lambdabot>     Perhaps you meant one of these:
12:59:10 <micahcowan> Well, yeah, if it's let/in
12:59:11 <chrisdone> aww. not enough imports =p
12:59:16 <micahcowan> But for a do/let (no in).
12:59:30 <Zekka> micahcowan: Both have the same behavior as far as I'm aware (unless I'm misunderstanding you)
12:59:34 <Zekka> it's just syntactic difference
12:59:39 <rwbarton> x could be any type
12:59:57 <rwbarton> but if its definition doesn't depend on any variable bound in the do-block, then there is no real reason to have it defined inside the do
12:59:58 <micahcowan> Gotcha. But I'd still probably put it outside the do, unless there was a compelling reason.
13:00:21 <chrisdone> i avoid let in do as much as i can
13:00:25 <chrisdone> in fact i avoid let
13:00:30 <chrisdone> in general
13:00:35 <micahcowan> In favor of where, I guess?
13:00:41 <chrisdone> yeah
13:00:42 <Zekka> I'll often use let inside do to define a value that should be labeled based on other things determined inside the function
13:00:54 <Zekka> I use let a ton
13:00:55 <chrisdone> i'll put up with adding parameters to a where function over the ugliness of let
13:01:13 <tnks> yeah, I feel let tells the story in the wrong order.
13:01:14 <Zekka> my code is let-tered with it
13:01:27 <chrisdone> tnks +1
13:01:51 <micahcowan> I dunno, at times it's easier to describe what we're talking about before we start talking about things. But I imagine that comes down to personal style.
13:02:05 <tnks> "oh, so you want to know about the brain. . . first let me tell you about quarks."
13:02:24 * tnks appologizes for the hyperbole
13:02:28 <ReinH> chrisdone has a rather particular Haskell style
13:02:28 <micahcowan> I basically use let/where haphazardly, at least currently... though I use let in do somewhat more strictly, and can't think of a case where I'd use let/in inside a do.
13:02:43 <ReinH> Although after trying it a bit (with the loving correction of sum) I admit I rather enjoy it
13:02:50 <ReinH> *shm
13:03:09 <ReinH> chrisdone: although I wish you'd let me use a line break and indent directly *after* the do ;)
13:03:18 <micahcowan> tnks, maybe if I was going to explicitly describe how they relate to the brain. Certainly there's effective writing like that (not that specifically, of course, since no one has much to say about quarks as they relate to brains ;) )
13:04:31 <micahcowan> It's bottom-up versus top-down, and there are times for both of those IMO.
13:04:36 <geekosaur> I was thinking Sagan did it better. "To bake an apple pie, you must first invent the Universe."
13:04:46 <micahcowan> :)
13:04:49 <chrisdone> reinh: =p if you go to a do like
13:04:50 <chrisdone> main = do foo
13:04:50 <chrisdone>           bar
13:04:50 <chrisdone> you can use C-c C-j at the start of the do to get
13:04:52 <chrisdone> main = do
13:04:55 <chrisdone>   foo
13:04:58 <chrisdone>   bar
13:05:14 <chrisdone> i call it "swinging", because it's like you're swinging underneath the main
13:05:15 <ReinH> at the start of the do? That moves the do down iirc.
13:05:24 <ReinH> you get:
13:05:26 <ReinH> main =
13:05:28 <ReinH>   do foo
13:05:29 <ReinH>      bar
13:05:31 <chrisdone> that's C-j
13:05:34 <ReinH> OH
13:05:38 <ReinH> Huh.
13:05:40 <chrisdone> C-c C-j is like "do something *like* C-j, but different"
13:05:45 <ReinH> Neat.
13:05:50 <Zekka> Hi, I'm a vim user.
13:05:55 <micahcowan> :D
13:05:57 <ReinH> Zekka: me too :D
13:06:05 <hiptobecubic> Everyone secretly is.
13:06:13 <chrisdone> i use vim inside emacs
13:06:13 <benzrf> Zekka: so'm i
13:06:17 <benzrf> B)
13:06:32 <hiptobecubic> chrisdone, as a subprocess :D ?
13:06:35 <Zekka> I actually used emacs briefly but I had a configuration issue and got tons of hostility from #emacs, which turned me off from using it any more
13:06:37 <hiptobecubic> Otherwise no you don't.
13:06:41 <micahcowan> I started in Emacs, later moved to Vim. Love them both, but Vim's what I use.
13:07:13 <Zekka> (lots of "read the f- source" when I had already read the source and found the apparent location of the problem (some builtin emacs functionality) and a few times asked "is it supposed to be behaving this way?")
13:07:17 <zwer> chrisdone do you use evil?
13:07:55 <chrisdone> nah, just joking
13:08:20 <benzrf> i should get a footpedal for vimming b)
13:08:33 <benzrf> altho im usually lying down and not sitting while computing
13:09:40 <chrisdone> benzrf: illness or laziness?
13:10:10 <benzrf> chrisdone: i use haskell for a reason :-)
13:11:21 <chrisdone> reinh: how awesome is C-c C-w?
13:11:28 <ReinH> wait what's that?
13:11:33 <chrisdone> reinh: on a scale of pretty-sweet→OMG
13:11:56 <chrisdone> reinh: eh, it just inserts or jumps to a where clause. not that cool, but handy =p
13:12:04 <ReinH> oh that. Yeah. Awesome.
13:12:15 <chrisdone> xD
13:12:17 <heatsink> I use vi for small files, emacs for large files.
13:12:43 <ReinH> chrisdone: how about case split for pattern matching definitions?
13:13:13 <chrisdone> ReinH: C-c C-s
13:13:18 <ReinH> hmm
13:13:55 <heatsink> It is awfully hard to discover functionality that's in emacs.
13:13:55 <chrisdone> ReinH: but that inserts a case analysis and works only for simple sum types atm
13:14:13 <chrisdone> heatsink: not really. C-h b would tell reinh that
13:14:19 <heatsink> I don't know most of what's in haskell-mode.
13:15:01 <heatsink> Hmm.  C-h b gives me a 2800-line buffer.
13:15:05 <haasn> For a moment, I thought chrisdone means that C-h b would instruct emacs to log into #haskell and tell ReinH the key combination for case splitting
13:15:12 <ReinH> probably
13:15:26 <ReinH> chrisdone: Right, I mean that I want it to introduce new definitions, not a case statement
13:15:33 <chrisdone> e.g. C-h b gives these for structured-haskell-mode and haskell-mode http://lpaste.net/2076858086252871680
13:16:04 <chrisdone> ReinH: i suppose that's easy enough, just haven't implemented it as i've no personal use for it. you want it?
13:17:11 <chrisdone> reinh: also, does the case version work for you? it uses the ghci process to get type info
13:19:39 <ReinH> chrisdone: yeah, its worked before.
13:19:42 <ReinH> it's
13:20:18 <ReinH> chrisdone: And yeah, splitting up a definition like that would be nice, or just replacing a variable with a constructor
13:21:22 <chrisdone> reinh: it's possible to expand a pattern, if that helps: C-c C-p you have to type the name of the type still, but until hdevtools or ghc-mod is integrated it can't guess the type
13:22:47 <chrisdone> reinh: but i can just make an alternative version of this: https://github.com/chrisdone/structured-haskell-mode/blob/master/elisp/shm-case-split.el#L42..L67
13:23:17 <ReinH> chrisdone: cool
13:23:46 <chrisdone> it's beer-o-clock
13:23:56 <chrisdone> reinh: i'll write this now
13:24:03 <ReinH> woo
13:24:03 <chrisdone> check this! https://github.com/chrisdone/haskell-docs/issues/2 \o/
13:26:57 <heatsink> chrisdone: I shall remember that
13:27:25 <chrisdone> heatsink: remember what?
13:28:04 <heatsink> C-h b
13:28:55 <chrisdone> heatsink: ah =)
13:35:03 <Pythonfant> chrisdone: does haskell-docs work with sandboxes or only with globally installed packages?
13:35:32 * hackagebot heroku 0.1.2 - helpers for deploying to Heroku  http://hackage.haskell.org/package/heroku-0.1.2 (GregWeber)
13:37:12 <chrisdone> Pythonfant: it does support sandboxes, someone made a pull request, i snarfed that up when i changed the commandline parsing, but i'll add it back soon
13:37:23 <Pythonfant> ok
13:37:42 <Pythonfant> I sandbox everything because otherwise I constantly broke my system
13:38:44 <chrisdone> Pythonfant: apparently like this: https://github.com/chrisdone/haskell-docs/pull/9
13:38:56 <chrisdone> but i wonder whether it's possible to detect a sandbox? maybe by the filename in the current dir?
13:55:28 <darthdeus> http://www.reddit.com/r/haskell/comments/28o7my/what_is_the_state_of_the_javascript_problem_what/
13:58:47 <ninja_code> I understand the three monad laws. I have written my own crappy state monad. I'm familair with IO, Maybe, State, and List monad. Now, I want to read a tutorial on a bunch (say 20? 30?) common Monads + their source code. What is recommended reading?
13:59:17 <ion> There are 20 common monads?
13:59:28 <ninja_code> s/common/useful
13:59:50 <Zekka> Offhand I can think of Reader, Writer, State, ST, IO, Maybe, List, STM, Either, and oh I'm out
14:00:01 <Zekka> anything else might be library-specific
14:00:03 <Judde> I'd read typeclassopedia. I think that's the logical next step
14:00:05 <ninja_code> does someone have a tutorial explaining how the source code of these work?
14:00:09 <hpc> there's a squajillion parser monads
14:00:19 <hpc> web framework monads
14:00:20 <ajcoppa> ninja_code: it's not exactly what you're asking for, but the NICTA course has you implement functors, applicatives, and a couple monads, including monad transformers
14:00:24 <ajcoppa> https://github.com/NICTA/course
14:00:25 <hpc> the Q monad (have fun with that one!)
14:00:25 <Judde> http://www.haskell.org/haskellwiki/Typeclassopedia
14:00:29 <napping> http://homepages.inf.ed.ac.uk/wadler/topics/monads.html#essence
14:00:32 <Zekka> Yeah. Also there's a few I forgot that I'm thinking of just now
14:00:48 <hpc> then stuff like ContT
14:00:50 <napping> ninja_code: Wadlers "The essence of functional programming" covers plenty
14:00:50 <Zekka> I wouldn't wish a full understanding of Q's implementation on anyone
14:00:53 <hpc> and Free
14:01:16 <ninja_code> ajcoppa: I'm purely after monads at the moment
14:01:30 <napping> ninja_code: if you want a nice little variety of fairly useful things
14:01:47 <hpc> honestly, you're wasting your time hunting for monads specifically
14:01:55 <hpc> Monad is just an API
14:02:46 <ninja_code> http://homepages.inf.ed.ac.uk/wadler/topics/monads.html#essence looks nice
14:02:46 <hpc> look for neat libraries instead
14:04:12 <benzrf> hmm
14:04:17 <benzrf> why are they monad comps and not applicative comps
14:04:55 <Zekka> benzrf: Because you can depend on the values of previous <-s?
14:04:56 <hpc> applicative is not webscale
14:04:59 <hpc> it doesn't support joins
14:05:18 <benzrf> Zekka: o i forgot
14:05:21 <chrisdone> darthdeus: i swear the same reddit post appears once every two weeks
14:05:51 <Zekka> > [[a, b] | a <- ['a'..'z'], b <- ['a'..a]]
14:05:53 <lambdabot>  ["aa","ba","bb","ca","cb","cc","da","db","dc","dd","ea","eb","ec","ed","ee",...
14:07:04 <ocharles> merijn: you wrote transformers-supply right?
14:07:25 <merijn> ocharles: Yeah
14:07:34 <chrisdone> get him!!
14:07:39 * chrisdone pounces on merijn
14:07:43 <ocharles> merijn: how on earth are you meant to use MonadSupply? I can't get anything useful from it
14:07:52 <merijn> uhoh
14:07:57 <mindeavor> hpc benzrf can you elaborate on not being webscale? are applicatives slower than monads?
14:08:09 <monochrom> that was a joke
14:08:12 <ocharles> merijn: that extra parameter to the type class really messes things up
14:08:27 <ocharles> I have: Wires.stepWire staticPage 0 () :: (MonadSupply Int m m, MonadReader (Wires.Event DOMEvent) m, Applicative m) => m (Wires.Output m () Element)
14:08:34 <merijn> ocharles: How so?
14:08:46 <ocharles> Yet: runSupplyT (Wires.stepWire staticPage 0 ()) + 0 doesn't type check because:
14:08:53 <ocharles> No instance for (MonadSupply Int (SupplyT Int m) (SupplyT Int m))
14:09:39 <ocharles> The m should be the m underneith SupplyT, but to use MonadSupply the point is I don't know what that m is
14:09:45 <merijn> ocharles: Oh, you might be right, I should look at that. I never really used MonadSupply in my own code, I mostly just used the plain one xD
14:09:46 <eazar001> that is one ugly type sig
14:10:06 <merijn> ocharles: I mostly included that for completeness sake
14:10:32 <ocharles> Yea, I don't need a monadic source
14:10:37 <ocharles> Just restricted state, basically
14:11:05 <ocharles> But I don't think what you have is particularly useful for mtl style usage, unfortunately
14:11:20 <merijn> ocharles: Yes, hence why I never really tested that bit xD
14:11:23 <ocharles> :)
14:11:37 <ocharles> consider this your first bug report then ;)
14:12:10 <merijn> ocharles: Could you dump the whole error/code on the github tracker? I won't have time to look at it until I get back from OPLSS
14:12:20 <ocharles> Sure
14:14:11 <darthdeus> chrisdone: show me one with good answers :P
14:16:35 <chrisdone> darthdeus: but i've made so manny posts :(
14:18:10 <toki78> hi guys, I just had a funny idea
14:19:44 <chrisdone> toki78: omg r u series
14:21:08 <napping> aww, Symbols are not typeable
14:23:03 <chrisdone> what's a Symbol?
14:23:15 <napping> the kind of type-level strings
14:23:36 <napping> > typeRep (Proxy :: Proxy "Hello")
14:23:38 <lambdabot>  <hint>:1:25:
14:23:38 <lambdabot>      Illegal literal in type (use DataKinds to enable): "Hello"
14:23:43 <napping> );
14:24:11 <chrisdone> ahh
14:24:37 <chrisdone> so :k "X" → Symbol
14:24:42 <chrisdone> ?
14:24:51 <napping> yeah, if ypu have DataKinds
14:26:26 <toki78> I implement this now, let's see, if it works
14:27:02 <toki78> I do a JavaScript version first, and a haskell version will follow
14:27:39 <eazar001> ?
14:27:53 <eazar001> toki78: you mean javascript to haskell compiler?
14:28:30 <toki78> oh, no I mean the thing I mentioned, before my internet crashed
14:29:44 <chrisdone> toki78: nothing was sent after you said "i just had a funny idea"
14:30:36 * hackagebot seacat 1.0.0.0 - Small web framework using Warp and WAI  http://hackage.haskell.org/package/seacat-1.0.0.0 (barrucadu)
14:30:44 <Sculptor> guys take five. spacex launch in 5 mins
14:30:56 <kazagistar> link plox
14:31:25 <Sculptor> http://youtu.be/EzX_wFm4OH4
14:31:47 <toki78> chrisdone, internet problem
14:31:58 <toki78>  why not replace neural nets by parametrized boolean functions and let a sat solver find the correct boolean parameters  ?
14:33:47 <asterblaster> hello
14:34:37 <asterblaster> I have troubles while building yesod (aeson-0.7.0.3, Data.Scientific does not export scientificBuilder)
14:37:09 <Sculptor> ah. the launch is in 32mins. my bad
14:40:07 <kazagistar> Sculptor: some time to get hyped is ok
14:40:44 <adrienne> Hello
14:41:50 <Guest10893> Does anyone have approaches for resolving gloss problems ?
14:42:03 <genericpersona> what are gloss problems?
14:42:05 <Guest10893> I have a program that I'm trying to run and I compiled it and then ran it, but it keeps quitting unexpectedly
14:42:26 <Guest10893> @genericpersona gloss is a graphics package for haskell
14:42:26 <lambdabot> Unknown command, try @list
14:42:34 <Guest10893> gloss is a graphics package for haskell
14:42:49 <genericpersona> ah
14:43:20 <kazagistar> gloss will always be a 3d graphics extention library for pygame in my heart <_<
14:45:07 <Guest10893> I've also been having annoying problems installing GTK for haskell (trying to visualize graphs) which might be related..
14:45:21 <Guest10893> I guess I could just try re-installing Haskell and cabal
14:45:35 <ricree> does anyone know if there is a flowchart library with haskell bindings for any of the major desktop UI libraries?
14:47:01 <ricree> (or alternately, if anyone could suggest a non-dead C library, since most of the ones I've found haven't been updated in years, and I'm not sure I want to take the trouble of making bindings for a dead project)
14:47:59 <heatsink> What does a flowchart library do?  Take a graph and draw it as a flowchart?
14:48:14 <kazagistar> Sculptor: I get the feeling that I am going to spend quite a few hours playing Kerbal Space Program today...
14:48:22 <ricree> I was thinking more about user constructed graphs
14:48:31 <ricree> like a simple editor
14:48:46 <heatsink> I don't know of any libraries for that.
14:49:15 <ricree> diacanvas, for example, seems to be what I want, but the fact that it doesn't have an update since 2007 makes me hesitant
14:49:43 <Guest10893> Does anyone have tips for uninstalling/reinstalling haskell and cabal?
14:50:05 <chrisdone> ghc-pkg unregister package-name
14:50:10 <Guest10893> Just did a google search but doesn't seem like there is a 'cabal uninstall' option
14:50:20 <Guest10893> oooh thanks chris
14:50:25 <michaelt> Guest10893: If you want to get rid of just a package?
14:50:52 <Guest10893> a program keeps crashing when i try to run it. i think it's because of the gloss graphics package
14:51:05 <Guest10893> so i'm thinking something happened with the install.
14:51:25 <michaelt> Guest10893: maybe you don't have the relevant C library, open gl or whatever it is
14:51:44 <Guest10893> hrmmm
14:52:14 <michaelt> cabal won't generally test for that, I think.
14:52:37 <Guest10893> i'm on a mac and I have xcode, so I don't think thats the problem
14:52:43 <michaelt> hm
14:53:59 <Guest10893> interesting point though.
14:54:05 <Guest10893> I'll try a cabal update and reinstall gloss
14:58:53 <genisage> Spacex launched delayed. :(
14:59:08 <genisage> s/launched/launch/
14:59:24 <Guest10893> grrr still crashing
15:03:20 <fmapE> edwardk: hello
15:05:38 * hackagebot configuration-tools 0.2.1 - Tools for specifying and parsing configurations  http://hackage.haskell.org/package/configuration-tools-0.2.1 (larsk)
15:24:59 <deweyvm> baffled by these error messages http://pastebin.com/RU6VFvtL
15:25:31 <deweyvm> it doesnt seem to think that type variables throughout called the same thing are the same?
15:29:49 <kazagistar> deweyvm: there could be more then one p for the same a, and it can't pick which one from the type
15:30:28 <deweyvm> how do i restrict it?
15:31:03 <toki78> Hi
15:31:27 <toki78> did you recieve my idea, or did my internet crash before ?
15:31:42 <kazagistar> deweyvm: I am not an expert, but I think this is what is functional dependancies
15:31:55 <Peaker> I'm playing with Hindley-Milner implementations, and wondering what it'd take to do RankN right -- apparently even Haskell doesn't do it right. Is there any type inference implemented that supports (explicit) RankNTypes while still correctly inferring things like "runST . forever"?
15:32:08 <Peaker> s/Haskell/GHC
15:32:21 <deweyvm> kazagistar: i tried that first but it didnt seem to make a difference
15:32:40 <benzrf> Peaker: i thought RankN was indecidable in general
15:32:42 <quchen> deweyvm: Fundeps seem related, yes. Here's a short description of them that I find useful. http://stackoverflow.com/questions/20040224/functional-dependencies-in-haskell/20040343#20040343
15:33:04 <Peaker> benzrf: It is -- but I think if the forall's are explicit then it should be ok
15:33:44 <Peaker> benzrf: there should be some RankNTypes implementation that can infer "runST . forever" correctly, I think -- though it requires the Monad type to be chosen as (forall s. ST s) which is a bit tricky
15:33:48 <deweyvm> giving it class Drawable a p | a -> p gives the same error
15:34:26 <benzrf> deweyvm: does a determine p?
15:34:57 <deweyvm> p should be fixed really
15:35:09 <deweyvm> so trivially it does
15:35:18 <deweyvm> but i dont think ive expressed that in the type
15:35:40 * hackagebot haskell-docs 4.1.1 - A program to find and display the docs of a name from a  given module.  http://hackage.haskell.org/package/haskell-docs-4.1.1 (ChrisDone)
15:35:42 * hackagebot haskell-docs 4.1.2 - A program to find and display the docs of a name from a  given module.  http://hackage.haskell.org/package/haskell-docs-4.1.2 (ChrisDone)
15:35:43 <Lutin`> eek
15:35:50 <deweyvm> p should really just be PixelRGBA8, but thats a constructor, not a type
15:36:02 <Lutin`> Trying to learn rust and I keep wanting to just run back to Haskell :[
15:36:26 <Peaker> Lutin`: Rust sounds pretty great.. but whenever I try to dive into it I'm disappointed by so many things
15:36:46 <moghedrin> Lutin`: Aye, that's my experience with every new language.
15:36:52 <Total_1mmersion> deweyvm, I think you intend for the p in colors :: Array2d p to be the same p in saveMap :: (Pixel p, ...
15:37:11 <Total_1mmersion> deweyvm, but I don't think that Haskell will interpret it that way
15:37:41 <Peaker> From distasteful syntax to the OOP style namespacing (ruining inference), to lack of effect typing, and more...
15:37:50 <kazagistar> deweyvm: yeah, so the types inside are not the same as the types outside, they do some kind of masking I think... someone else can point you towards a fix better then me :/
15:38:04 <[swift]> Peaker: argh yes, i'm glad i'm not the only one that hates the syntax
15:38:11 <deweyvm> ive used existentials to solve that in the past, but it didnt help this time
15:38:54 <[swift]> Peaker: the rust folks want to appeal to people coming from C++, i get that, but i still think they could have kept it cleaner without making it unreadable to C++ folks
15:40:06 <[swift]> Peaker: i overall like rust, actually, but i get frustrated with some of the missed opportunities
15:40:56 <Peaker> [swift]: yeah, I might use Rust in place of C or C++ myself too, but I wish it was more like Haskell while retaining the low-level non-GC semantics
15:41:11 <Total_1mmersion> deweyvm, I'm curious what would happen if you removed the type annotation for colors
15:41:29 <[swift]> that's how i feel as well. i was surprised at how few of the idioms i was used to transferred
15:41:30 <tromp__> i guess the wait is for Ruskell....
15:41:42 <deweyvm> Total_1mmersion: wasnt there originally, had no effect adding them
15:41:46 <moghedrin> tromp__: lol
15:41:53 <[swift]> in many cases it wasn't just that they were less efficient than rust's native idioms, it was that it was hard or impossible to implement them
15:42:25 <deweyvm> heres a work around at least http://pastebin.com/vB1Qc29g
15:42:33 <deweyvm> but it limits what implementations are allowed
15:42:53 <Total_1mmersion> deweyvm, have you tried the "Possible fix" suggested by GHC and added (Drawable a p1) to the context of the type signature for colors?
15:43:05 <deweyvm> then p1 becomes p2
15:43:08 <deweyvm> etc etc
15:43:34 <Total_1mmersion> lol, it's a runaway type error
15:43:39 <[swift]> tromp__: i've actually wondered a bit about something like "asm.hs"
15:44:18 <[swift]> tromp__: like, could we define a subset of haskell that we can compile to very efficient native code, and use a different code generator for modules written in that subset
15:44:31 <Total_1mmersion> deweyvm, what if you remove both type annotations for colors and getter? I see a p in getter's type annotation as well.
15:44:35 <pjdelport> [swift]: "GHC Core"?
15:44:58 <[swift]> pjdelport: does core serve that purpose already? i've never worked with it directly
15:45:24 <deweyvm> Total_1mmersion: same errors, but the types have different names now
15:45:26 <pjdelport> [swift]: Probably not really, but it's probably not too far off either.
15:45:36 <deweyvm> "pixel0" instead of p1
15:45:59 <[swift]> pjdelport: well, that's interesting. it sounds like a good starting point at least
15:46:31 <Peaker> [swift]: hmm.. a linearly-typed subset of Haskell?
15:46:35 <deweyvm> oh! using some combination of those suggestions i only have one error now
15:46:53 <Peaker> [swift]: I think purity requires linear typing to implement without incurring GC
15:47:26 <[swift]> Peaker: that seems reasonable to me. i wouldn't mind writing in that style for small "hot" regions of my program
15:47:37 <tromp__> the subset should be unboxed (hence strict) i guess
15:47:48 <[swift]> yeah, strictness seems to be a requirement
15:48:01 <Total_1mmersion> deweyvm, cool, could you post the code? I'm curious
15:48:54 <deweyvm> Total_1mmersion: http://pastebin.com/pBPDC00D
15:49:49 <deweyvm> turns out the forall there does nothing
15:50:22 <Lutin`> Well yeah that forall is the same as the implicit forall
15:50:24 <Total_1mmersion> I was just wondering if you really needed that myself
15:50:37 <Total_1mmersion> What does the | a -> p part on class Drawable do?
15:51:04 <geekosaur> functional dependency: the type of a determines the type of p
15:51:08 <deweyvm> it tells saveMap (and anywhere using a Drawable constraint) not to bother inferring p, to just look it up from the instance
15:51:16 <quchen> Total_1mmersion: http://stackoverflow.com/questions/20040224/functional-dependencies-in-haskell/20040343#20040343
15:54:46 <abstract-alf> hey all
15:55:16 <deweyvm> i fixed it
15:55:18 <abstract-alf> trying to get started with lens.. getting an error on `cabal install lens`: Could not find module `Control.Monad.Trans.Except'
15:55:20 <deweyvm> but i dont understand why
15:55:35 <deweyvm> Total_1mmersion: http://pastebin.com/ayP4SXtN
15:56:06 <Total_1mmersion> quchen, how is a function bar :: a -> b -> c even possible? How can that function return something of type c?
15:56:58 <abstract-alf> anyone know how I might overcome that error and get lens installed?
15:57:36 <edwardk> abstract-alf: you probably have an old-ish version of transformers-compat/lens, cabal update, nuke ~/.ghc if you have to and cabal install lens
15:57:57 <abstract-alf> edwardk: I'll try that now
16:00:28 <Jookia> Hello :D
16:01:09 <pavonia> Total_1mmersion: That c isn't arbitrary, it's fixed by the instance choosen (depending on the types a and b)
16:01:58 <Jookia> Is there a way to get out of cabal hell?
16:02:48 <hpc> Jookia: call a continuation from before you entered it ;)
16:03:06 <Jookia> is that possible
16:03:11 <joelteon> why can't I compute the first value of this list? http://lpaste.net/105896
16:04:05 <hpc> to evaluate the head of primes, you need to evaluate that filter function
16:04:10 <hpc> which evaluates primes
16:04:27 <hpc> you'll need to do something like primes = 2 : filter predicate [3..]
16:04:29 <joelteon> > take 5 $ filter (const True) [1..]
16:04:31 <lambdabot>  [1,2,3,4,5]
16:04:58 <joelteon> hpc: well, that evaluates 2
16:05:02 <joelteon> then locks up
16:05:22 <joelteon> why does filter have to evaluate the whole of primes? shouldn't any return True on the first success?
16:06:02 <hexagoxel_> but there might be no success
16:06:11 <joelteon> okay, but 2 mod 2 is 0
16:06:11 <hpc> for composites, yes
16:06:13 <benzrf>        
16:06:25 <joelteon> oh, right
16:06:26 <hpc> joelteon: it's not 2 mod 2
16:06:27 <joelteon> i get it now
16:06:29 <hpc> it's 2 mod (head primes)
16:09:38 <joelteon> anyway, i understand why that's wrong
16:09:50 <joelteon> because i shouldn't be testing 2 mod 2
16:10:05 <joelteon> i should be testing 2 mod (filter (< (floor (sqrt 2))) primes)
16:10:28 <quchen> You should be using takeWhile, not filter.
16:10:36 <joelteon> also, that
16:10:43 * hackagebot twitter-types 0.3.20140620 - Twitter JSON parser and types  http://hackage.haskell.org/package/twitter-types-0.3.20140620 (TakahiroHimura)
16:11:27 <pepper_chico> I'm just following http://www.infoq.com/presentations/haxl and at 25:22 Simon says "Every Applicative is a Monad, but the reverse is _not_ true", it's funny for me that, because I've just read in LYAH that "But rest assured, every monad is an applicative functor, even if the Monad class declaration doesn’t say so." =S LYAH seems to have the explanation reversed
16:11:58 <quchen> "Every Monad is Applicative" is correct, the inverse is not.
16:12:14 <quchen> Canonical example, ZipList is Applicative, but not Monad.
16:12:27 <pepper_chico> so, Simon got it reversed then
16:12:41 <Enigmagic> Simon doesn't know much about Monads
16:12:50 <pepper_chico> hmmm, ok
16:12:52 <Enigmagic> ;-)
16:13:05 <Jookia> is it possible to install binaries using cabal install, or should i be sandboxing them
16:13:27 <quchen> pepper_chico: Yeah he's got it backwards in his talk there
16:13:38 <abstract-alf> ^take 5 $ takeWhile (const True) [1..]
16:13:44 <pepper_chico> quchen, ok then, thanks
16:13:46 <abstract-alf> > take 5 $ takeWhile (const True) [1..]
16:13:48 <lambdabot>  [1,2,3,4,5]
16:13:54 <abstract-alf> neat-o
16:14:04 <quchen> pepper_chico: But note the previous slide, where he actually says "Applicative f => Monad f where". That's the correct way.
16:14:20 <quchen> Eh, it's even on the same slide.
16:14:56 <pepper_chico> ok, I'm not versed in Monad yet, I'm still some chapters before the monad/applicative stuff in LYAH, but that point got me
16:15:16 <pepper_chico> since I was watching this that came over me from twitter =D
16:15:26 <quchen> It's "Functor => Applicative => Monad", for future reference.
16:15:39 <pepper_chico> ok
16:15:47 <quchen> Where "=>" is Haskell's "=>", not logical implication.
16:16:01 <silasm> quchen: that's always bothered me, yeah.
16:16:02 <[swift]> yeah, if you read that as implication it's misleading =)
16:16:12 <abstract-alf> > map ($ 5) [(+1),(*2),(/2),(^2)]
16:16:14 <lambdabot>  [6.0,10.0,2.5,25.0]
16:16:40 <quchen> Haskell's "=>" is more like "given LHS the RHS can be defined"
16:17:24 <[swift]> it's necessary, but not sufficient
16:17:47 <silasm> quchen: well see that's where it's weird, because it's not really that way in typeclass definitions, but it is in instance definitions.
16:18:11 <quchen> Haskell likes reverse operators, eh? Like "a <= b" is "a implies b" ;-)
16:18:31 <Jookia> is there a cabal IRC channel or some documentation on deciphering dependency errors?
16:19:07 <ryantrinkle> is there a general way of dealing with datastructures that are functorial in type arguments other than the last one?
16:19:33 <ryantrinkle> like PFunctor and QFunctor, but more general
16:20:20 <johnw> byorgey: ping
16:20:25 <benzrf>  
16:20:27 <pepper_chico> Jookia, I got this (http://www.davesquared.net/2014/05/platformless-haskell.html) from this (https://github.com/bitemyapp/learnhaskell)
16:21:10 <pepper_chico> Jookia, it provides nice workflows regarding cabal usage, and tips regarding deleting build cache
16:21:27 <Jookia> alrighty'
16:21:29 <Jookia> :D
16:22:15 <silasm> quchen: if you're defining a typeclass, Foo a => Bar a means every instance of Bar must be an instance of Foo, i.e. Foo is necessary. If you're defining an /instance/, Foo a => Bar a implies Foo is sufficient.
16:22:16 <pepper_chico> I myself am not using sandboxing for everything, I've not used none yet, because I haven't installed big projects, I hope to use it only for big stuff
16:22:35 <pepper_chico> large dependencies etc
16:23:16 <marchelzo_> can someone explain to me what is going on here: ((+) <*> (+10))
16:23:20 <silasm> quchen: I guess when I put more thought into it it makes sense, but it confused me for a while.
16:23:30 <Jookia> pepper_chico: well it's pretty hard to install multiple binaries
16:24:29 <dottedmag> marchelzo_: Is it well-typed?
16:24:37 <pepper_chico> Jookia, haven't gone throught that yet to have an opnion =)
16:24:51 <dcoutts> marchelzo_: it'll be the (->) instance for applicative
16:25:18 <pepper_chico> the only binary I've looked for right now is cabal and ghc-mod for editor assistance =)
16:25:19 <marchelzo_> dcoutts: I know. But what actually happens? Why is the result 16 when you apply it to 3?
16:26:23 <Enigmagic> > ((,) <*> (+10)) 3
16:26:25 <lambdabot>  (3,13)
16:26:39 <Enigmagic> > ((+) <*> (+10)) 3
16:26:40 <lambdabot>  16
16:28:14 <marchelzo_> I don't understand
16:29:20 * pepper_chico the guys seems to be lacking that ha-ha moment...
16:29:33 <pepper_chico> =D
16:29:48 <pepper_chico> it'll come
16:30:05 <pjdelport> marchelzo_: That's known as Reader, or (r ->)
16:30:42 <marchelzo_> Just when I thought I at least understood Functor
16:30:45 * hackagebot haskell-docs 4.1.3 - A program to find and display the docs of a name from a  given module.  http://hackage.haskell.org/package/haskell-docs-4.1.3 (ChrisDone)
16:31:54 <kazagistar> marchelzo_: does this make sense at least? (+) :: (->) a ((->) a a)
16:32:28 <abstract-alf> woh, is there a typo in that type declaration?
16:32:46 <kazagistar> I dropped the Num bit for simplicity
16:33:50 <marchelzo_> kazagistar: sure. Is there a difference if you used (->) as infix?
16:34:30 <kazagistar> marchelzo_: yes, and no, there is no difference other then understanding it a little easier for me
16:34:41 <kazagistar> a Reader represents composing the results of functions that all have the same input... ie "once I get this input, I will be able to get you the answer"
16:35:43 <marchelzo_> I have never head of a Reader. Is that bad?
16:35:53 <johnw> no, it means you have fun ahead of you :)
16:36:47 <kazagistar> marchelzo_: so, look at it this way, (+) :: Reader a (a -> a), because "if given an a, it gives you an a -> a function"
16:37:11 <pjdelport> marchelzo_: The intuition behind Reader is that it represents a function from a shared environment. Every value that you compose together (via Functor, Applicative, or Monad) will be called with the shared environment value, before the rest of the computation continues.
16:37:39 <marchelzo_> kazagistar: sure, but why is it necessary to invoke this 'Reader' thing?
16:37:57 <marchelzo_> why not  (+) :: (Num a) => a -> a -> a
16:37:58 <kazagistar> well, lets look at <*>
16:38:08 <kazagistar> :t (<*>)
16:38:10 <lambdabot> Applicative f => f (a -> b) -> f a -> f b
16:38:21 <kazagistar> so what is f in your example?
16:39:11 <kazagistar> ((+) <*> (+10))
16:39:17 <marchelzo_> hmm
16:39:18 <pjdelport> mirsal: So when you have something like "(+) <*> (+10)", the value on either side of the <*> is a function of the shared environment. So when you say (+) <*> (+10) $ 3, each side is called with 3, and then application proceeds normally: (3+) (3+10)  -->  16
16:39:38 <marchelzo_> f is Reader?
16:39:41 <kazagistar> well, we have to match (a -> a -> a) with (f (a -> b))
16:40:08 <kazagistar> so if we rewrite it a bit it might be more clear
16:40:45 <kazagistar> (->) a ((->) a a)   and   f ((->) a b)
16:40:45 * hackagebot haskell-docs 4.1.4 - A program to find and display the docs and type of a name  http://hackage.haskell.org/package/haskell-docs-4.1.4 (ChrisDone)
16:41:05 <kazagistar> f matches up with (a ->)
16:41:12 <marchelzo_> yeah
16:42:18 <marchelzo_> But the type signature is  f (a -> b) -> f a -> f b
16:43:12 <kazagistar> so what is the intuition behind <*> in the reader case? it takes a "something that if given an environment, gives you a function a -> b" and "something that if given an envoronment, gives you an a" and returns a composed version, "something that if given an environment, gives you a b"
16:44:41 <kazagistar> the return type is f b, which in this case, is (->) a a
16:45:13 <marchelzo_> So..
16:45:31 <marchelzo_> Ok
16:45:34 <kazagistar> that function, when given a value, passes it to all the readers, and then applies the readers, and returns the result
16:45:46 <marchelzo_> If I said
16:46:04 <marchelzo_> f = (+) <*> (+10)
16:46:17 <marchelzo_> What would be a way to define f without functors?
16:47:39 <Sebboh> Hi. So I'm going to learn some haskell.  I'm a java guy.  And a lisp guy^Wfan.  I have a java program I wrote that creates a 1000x1000x4 byte array in memory which I then write to disk as-is and view as an image (1000px width, 1000px height, and four bytes wide = RGBA, 8bits each).  I'd like to recreate this in haskell.  Then I can write a few functions that draw lines and circles in the bitplane, ya know?  So.  Where do I start?  I'm
16:47:40 <Sebboh> on Debian, I've got ghc installed, and I've got emacs with haskell-mode. I've created rgba.hs and it is empty.
16:47:49 <dwcook> > let f = (+) <*> (+10) in f x
16:47:51 <lambdabot>  x + (x + 10)
16:48:08 <kazagistar> this is the most explicit version I could come up with http://lpaste.net/105898
16:48:11 <dwcook> marchelzo_: \x -> x + (x + 10)
16:48:29 <kazagistar> to make it clear what the reader is doing
16:49:17 <Sebboh> I'm vaguely aware that in haskell, what I'll actually do is *describe* the bitplane I want... then serialize the result to disk.  eh?
16:49:32 <ninja_code> Haskell.
16:49:39 <ninja_code> Wow.
16:49:45 <ninja_code> So pure. Much types. Such correctness.
16:50:39 <marchelzo_> kazagistar: Hmmm
16:51:21 <dottedmag> Sebboh: yes, describing and serializing sounds more Haskellish than manipulating bitmaps in memory.
16:51:27 <ninja_code> So serious. Little humor.
16:51:34 <marchelzo_> kazagistar: Is there no other to define f without having it's arguments in the definition than by using <*>?
16:51:50 <pjdelport> Sebboh: You might want to look at the https://hackage.haskell.org/package/JuicyPixels library.
16:52:49 <pavonia> Sebboh: Or maybe start with a basic Haskell introduction first
16:52:53 <pavonia> @where lyah
16:52:53 <lambdabot> http://www.learnyouahaskell.com/
16:53:10 <Sebboh> pjdelport: I haven't clicked the link yet.. My goal is not to make images, my goal is to twiddle bits.  The image part is just a way for me to see the results.  Should I stll check the pixel lib link? :)
16:53:10 <abstract-alf> that book is great
16:53:42 <kazagistar> marchelzo_: you could also you ap, but that is the same as <*>
16:53:46 <Sebboh> pavonia: yeah I've got lyah up in a tab.  Lists, whee.
16:53:58 <Lutin`> marchelzo_: Ahoy
16:54:01 <pjdelport> Sebboh: That library gives you bit-twiddling level access to image buffers, yes, and loading and saving them.
16:54:07 <marchelzo_> kazagistar: for some reason I just find it unintuitive that ((+) <*> (+10)) 3 returns a number
16:54:22 <marchelzo_> Lutin`: Hey, how's it going?
16:54:25 <Lutin`> Pretty good
16:54:53 <pjdelport> Sebboh: But yeah, you'll probably want to start by going through some general Haskell tutorials, to get a feel for the language. It's a bit different to Lisp / Java. :)
16:54:56 <Sebboh> pjdelport: I'm gonna check your link but if it has functionality for drawing lines I'm join to reject it because implementing that is part of the exercise I've layed out for myself...
16:54:57 <marchelzo_> It seems like it should return a function
16:55:03 <dwcook> marchelzo_: I would consider this function best written explicitly. Though, why do you want to avoid using Applicative or Monad methods?
16:55:29 <Lutin`> marchelzo_: (<*>) f g x = f x (g x)
16:55:35 <kazagistar> marchelzo_: ((+) <*> (+10)) returns a function, but you add the 3 at the end, so you apply the function to an argument
16:55:52 <dwcook> marchelzo_: That's probably because you aren't looking at the types.
16:55:54 <DanielDiaz> Sebboh: no, JuicyPixels won't do that for you. It is not a graphics library. It only handles image encodings.
16:55:55 <marchelzo_> dwcook: I don't. But defining the function with the arguments doesn't help explain what apply is doing
16:56:10 <pjdelport> Sebboh: No, it doesn't do that: it just handles low-level pixel and buffer level manipulation.
16:56:25 <dwcook> marchelzo_: Perhaps you'd be interested in looking at the actual definition of (<*>) for the function instance? One sec.
16:56:35 <Lutin`> dwcook: I just pasted it
16:56:40 <dwcook> Ah, so you did
16:56:41 <marchelzo_> dwcook: That is what I'm trying to implement right now
16:56:42 <Lutin`> (<*>) f g x = f x (g x)
16:56:48 <marchelzo_> Which is why I am so confused
16:57:23 <dwcook> marchelzo_: I think it would really help you to take a look at the type. So, what's the type of your (<*>)?
16:57:47 <dwcook> If you don't know, that's fine, we can derive it from the general type
16:58:01 <marchelzo_> one sec
16:58:05 <Lutin`> so (+) <*> (+10) = (\x -> (x + (x+10))
16:58:13 <Sebboh> pjdelport: yeah JuicyPixels looks like it will replace some work that I have to do with external applications in the java version of my exercise...  Thanks very much! :)
16:58:15 <Lutin`> so it applies 3 to the first one, then applies that to the second
16:58:30 <pjdelport> marchelzo_: This might make it clearer: (\r -> (r+)) <*> (\r -> (r+10))
16:58:45 <marchelzo_> (<*>) :: ((->) t (a -> b)) -> ((->) t a) -> ((->) t b)
16:58:56 <pjdelport> marchelzo_: You can just think of the value on either side of the <*> as a (\r -> ...)
16:59:40 <dwcook> marchelzo_: Looks good to me. You might want to write it in infix though, if that makes it easier to understand.
16:59:48 <Lutin`> marchelzo_: Yeah so (<*>) :: (t -> (a -> b)) -> (t -> a) -> (t -> b)
17:00:59 <dwcook> Try starting from here: (<*>) f g x = _
17:01:09 <marchelzo_> lol
17:01:16 <Lutin`> Or (t -> a -> b) -> (t -> a) -> (t -> b)
17:01:19 <dwcook> f :: t -> a -> b, g :: t -> a, x :: t
17:01:26 <marchelzo_> Lutin`: solved it for me above if I start like that
17:01:33 <Lutin`> lol woops
17:01:37 <dwcook> Oh heh
17:01:47 <dwcook> Forgot about that
17:01:50 <marchelzo_> But that definition makes it seem pretty intuitive
17:01:52 <Lutin`> brb supper
17:02:05 <dwcook> Well it seems like you already have your answer then
17:02:08 <marchelzo_> it hides the complexity for functions that take multiple arguments, though
17:02:15 <dwcook> How so?
17:02:26 <dwcook> One thing to remember: Every function has precisely one parameter.
17:02:37 <marchelzo_> Yeah, that is why that definition works
17:02:39 <dwcook> You can talk about "multi-parameter" functions as long as you understand that.
17:03:36 <marchelzo_> But when I read f x (g x), I think of g as a (* -> *)
17:03:43 <marchelzo_> which is not necessarily true
17:03:49 <Lutin`> woah there buddy
17:03:53 <marchelzo_> oops
17:04:01 <dwcook> Huh? Are you trying to write a kind signature?
17:04:03 <Lutin`> (* -> *) is a kind
17:04:11 <marchelzo_> dwcook yeah and then I realized it was wrong lol
17:04:15 <Lutin`> (a -> b) is absolutely true
17:04:31 <Lutin`> b could just possibly be another function (c -> d)
17:04:35 <Sebboh> ... dammit I do need to go through the cute tutorial book. *sigh* I'll be back after I know which characters demark a comment, for example. :P
17:05:14 <marchelzo_> Yeah I know Lutin`.. Is there any way to distinguish say an Int from and (Int -> Int)?
17:05:25 <dwcook> It can be easy to forget sometimes that functions are just values like anything else.
17:05:25 <Lutin`> You have already
17:05:48 <marchelzo_> dwcook: Yeah but I can't even express what I am thinking right now.
17:05:52 <Lutin`> The point is (a -> b) is forall a b. (a -> b)
17:06:06 <Lutin`> And forall definitly includes other functions
17:06:15 <marchelzo_> I expect (g x) to be something that can not be applied to anything
17:06:21 <marchelzo_> I guess is the best way to put it
17:06:36 <marchelzo_> I guess that is just because I'm new to functional programming, though.
17:07:02 <Lutin`> Does ((+) 3) make sense to you
17:07:19 <marchelzo_> Sure
17:07:29 <Lutin`> well g = (+) in (g x)
17:07:33 <pjdelport> marchelzo_: Remember that f a b c is just short for (((f a) b) c)
17:07:51 <Lutin`> ^
17:08:07 <marchelzo_> I know. It's not that I don't understand, it's that it isn't my natural interpretation.
17:08:15 <Lutin`> understandable
17:08:24 <Lutin`> curried functions can take some getting used to
17:08:50 <abstract-alf> when I found out that Haskell curried functions by default, I was quite excited
17:09:01 <abstract-alf> I'd been doing manual currying in javascript with Function.bind
17:09:09 <Lutin`> me too, haha
17:09:30 <abstract-alf> OH MY GOD, I finally got Lens to install
17:09:34 <Lutin`> brb dinner
17:09:35 <abstract-alf> (via cabal install)
17:09:39 <edwardk> now the fun starts
17:09:51 <dwcook> I swear edwardk has a highlight on lens
17:09:53 <abstract-alf> thank you, baby jesus
17:09:58 <edwardk> some times
17:10:13 <abstract-alf> edwardk: I'm watching you on Youtube *right now*
17:10:52 <edwardk> as long as it isn't a livestream happening somewhere in this restaurant, we're cool ;)
17:10:59 <dwcook> abstract-alf: The bad thing about that is it has a bad interaction with JS's special `this` parameter. People have written "proper" currying function in JS and it's non-trivial to get right.
17:11:17 <dwcook> s/function/functions/
17:12:35 * pjdelport finds it better to pretend that JS's "this" doesn't exist.
17:13:07 <abstract-alf> well, you sorta need it to write any non-trivial JS... but we digress.  Let's talk about haskell instead
17:13:53 <abstract-alf> edwardk: it's not a voyeur cam, I promise! https://www.youtube.com/watch?v=cefnmjtAolY
17:15:58 <kazagistar> it always surprises me how often currying can be useful without rearranging parameters
17:16:42 <benzrf> kazagistar: oh?
17:19:14 <kazagistar> benzrf: coming from python, I quite liked "named parameter partial application", where you could specify which parameter to partially apply, but if you order your parameters well, you rarely want to partially apply over anything other then the first parameter
17:20:03 <abstract-alf> in Haskell, can't you re-order params by using sections?
17:20:07 <kazagistar> ie, we dont see stuff like { rot :: (a -> b -> c -> d) -> (c -> a -> b -> d) }, even flip is not that common
17:20:27 <abstract-alf> * re-order and curry
17:21:39 <silasm> kazagistar: I think once it gets to that point people usually give up and use a lambda.
17:23:27 <Para_> hi guys
17:23:33 <Para_> out of curiosity, what editors do you guys use?
17:23:39 <kazagistar> silasm: but most of the time, functions have parameters ordered (by design) in descending order by how likely they are to be curried
17:23:47 <kazagistar> so it isn't needed
17:23:49 <ChongLi> Para_: vim/emacs
17:23:53 <abstract-alf> Para_: vim
17:23:58 <benzrf> vim
17:24:20 <Para_> hm well vim seems to be popular
17:24:20 <benzrf> kazagistar: yeah i usually try to think about which args are most likely to vary
17:24:21 <Para_> haha
17:24:24 <benzrf> when picking order
17:24:56 <kazagistar> sublime, gedit, notepad++... I am too lazy (and not lazy enough) to learn a real editor
17:25:12 <abstract-alf> sublime is nice, I think
17:25:28 <abstract-alf> has built-in vim key bindings
17:25:35 <Para_> yeah it does
17:25:40 <chrisdone> i just added M-x haskell-describe to emacs :3
17:25:40 <Para_> I really should take the time to learn key bindings
17:25:50 * hackagebot AttoBencode 0.3.0.0 - Fast Bencode encoding and parsing library  http://hackage.haskell.org/package/AttoBencode-0.3.0.0 (FlorianHartwig)
17:26:07 <abstract-alf> the key bindings have been a big payoff to me over the years
17:26:18 <kazagistar> yeah, I tried, but it has a learning hump, and it hasen't been interesting enough for me to get over it
17:26:26 <Para_> yeah ^ same here
17:26:34 <Para_> I usually do well enough with the arrow keys
17:26:38 <abstract-alf> that was my probelm with emacs
17:26:39 <Para_> so I've gotten lazy
17:26:44 <Para_> well arrow keys + whatever
17:26:53 <abstract-alf> I'm even lazier... I don't like to leave home row
17:27:08 <marchelzo_> I was inspired to learn Vim after watching people who are really fast with it
17:27:42 <kazagistar> heck, I dont even type properly, I hit an awkward local maximum years ago and feel a little sluggish when I type... not that it affects coding speed much
17:27:52 <chrisdone> cabal update; cabal install haskell-docs; M-x haskell-describe reverse RET
17:28:13 <benzrf> ST is bull use vim
17:28:37 <abstract-alf> benzrf: psh. ST is a fine tool.  vim is great too
17:28:47 <silasm> benzrf: I was severely confused for a minute thinking you meant the ST monad.
17:28:51 <MP2E> haha
17:28:58 <abstract-alf> yes, use vim instead of the ST monad
17:29:08 <MP2E> the vim monad
17:29:13 <chrisdone> http://chrisdone.com/haskell-docs.png
17:29:13 <kazagistar> I was inspired by the vim experts too, but inspiration does not last very long for me, it is a poor motivator
17:29:34 <benzrf> data Vim a = Normal a | Insert a | Visual a
17:29:54 <abstract-alf> kazagistar: sounds like vim wasn't for you.  I wouldn't worry abou tit
17:30:07 <chrisdone> benzrf: three whole modes! so advanced!
17:30:09 <Para_> I'm trying Komodo edit now, lets see how it goes
17:30:22 <benzrf> chrisdone: :-)
17:30:27 <benzrf> Para_: just lrn2vim
17:30:35 <abstract-alf> > over _1 (++"ary") ("G","Busey")
17:30:37 <lambdabot>  ("Gary","Busey")
17:30:43 <bernalex> silasm: I was equally confused until I saw your post. my context started at "ST is bull use vim".
17:30:45 <abstract-alf> yaaaaay lens
17:30:48 <benzrf> abstract-alf: unary busey
17:30:49 <Para_> lol benzrf -- I know very basic emacs
17:30:53 <benzrf> binary busey
17:30:57 <dwcook> I'm pretty sure Vim has way more than three modes
17:30:58 <Para_> but i might at some point
17:31:19 <chrisdone> > map ((++"-mode") . return) ['a'..]
17:31:20 <kazagistar> abstract-alf: eh, I wouldnt say that, or nothing would be "for me", I am just not able to sustain motivation in a controlled way in general
17:31:21 <lambdabot>  ["a-mode","b-mode","c-mode","d-mode","e-mode","f-mode","g-mode","h-mode","i-...
17:31:25 <chrisdone> ^ emacs
17:31:58 <Para_> okay komodo is a no-go
17:32:02 <Para_> doesn't have Haskell
17:32:03 <Para_> lol
17:32:28 <dwcook> http://darkpan.com/files/vim.svg
17:32:31 <abstract-alf> > map (++"-mode") ['a'..]
17:32:32 <lambdabot>  Couldn't match expected type ‘[GHC.Types.Char]’
17:32:32 <lambdabot>              with actual type ‘GHC.Types.Char’
17:32:41 <abstract-alf> hmm... why not?
17:32:43 <chrisdone> fail
17:33:00 <abstract-alf> I was just curious about your function composition above
17:33:00 <chrisdone> because
17:33:02 <chrisdone> :t (++)
17:33:03 <lambdabot> [a] -> [a] -> [a]
17:33:12 <abstract-alf> oh, duh
17:33:39 <chrisdone> > map (:"-mode") ['a'..'] -- also works
17:33:41 <lambdabot>  <hint>:1:23: parse error on input ‘]’
17:33:48 <chrisdone> when your fingers aren't tired
17:33:51 <abstract-alf> fail
17:33:52 * chrisdone → bed
17:34:15 <bernalex> chrisdone: that's a very odd type signature
17:34:18 <kazagistar> pure and return are both such terrible names :/
17:34:23 <abstract-alf> > map (:"-mode") ['a'..]
17:34:25 <lambdabot>  ["a-mode","b-mode","c-mode","d-mode","e-mode","f-mode","g-mode","h-mode","i-...
17:34:32 <benzrf> bernalex: it can be reduced to a -> b
17:34:42 <benzrf> clearly chrisdone is attempting to define unsafeCoerce#
17:35:01 <benzrf> what's the name for reduction by bound name swapping again
17:35:08 <benzrf> eta reduction is application, right>
17:35:56 <dwcook> benzrf: f = \x. f x
17:36:07 <dwcook> Eta-conversion is replacing the right side with the left
17:36:16 <benzrf> oh
17:36:19 <dwcook> Eta reduction*
17:36:33 <benzrf> alpha conversion is what i meant then
17:36:36 <bernalex> dwcook: you mean eta abstraction
17:36:53 <bernalex> I think
17:36:55 <benzrf> bernalex: replace rhs with lhs they said
17:37:23 <dwcook> Isn't "eta reduction" an appropriate term?
17:37:37 <Total_1mmersion> Can a constant be considered a function with no arguments?
17:37:41 <bernalex> there's eta conversion which is either eta abstraction or eta reduction
17:37:46 <Total_1mmersion> For example, pi = 3.14159
17:37:46 <benzrf> Total_1mmersion: i read an article about that
17:37:52 <benzrf> it said not really
17:37:57 <bernalex> just like beta conversion -> beta abstraction/reduction
17:38:11 <dwcook> Was it this one? http://conal.net/blog/posts/everything-is-a-function-in-haskell
17:38:28 <dwcook> Total_1mmersion: In short: No.
17:38:34 <abstract-alf> > pi
17:38:35 <lambdabot>  3.141592653589793
17:38:40 <bernalex> Total_1mmersion: there is no such thing
17:38:47 <benzrf> dwcook: probly
17:38:50 <bernalex> unless you define functions in a very useless way
17:38:57 <Total_1mmersion> ok, thanks
17:38:59 <benzrf> Total_1mmersion: functions always have exactly one argument
17:39:05 <benzrf> that is what a function is
17:39:14 <Total_1mmersion> gotcha
17:39:22 <dwcook> Total_1mmersion: Though of course it depends on what you mean by "constant"
17:39:34 <bernalex> Total_1mmersion: pi = 3 just makes pi a synonym for 3
17:39:37 <abstract-alf> benzrf: so, is `pi` a function that takes an invisiable argument?
17:39:41 <dwcook> And your example happens to be a bad one for another reason, which is that numeric literals are polymorphic :)
17:39:41 <benzrf> i saw conal's pic in the upper right on that page and i thought for a sec he was that guy in the 'dont fear the monad' video
17:39:41 <abstract-alf> > pi
17:39:43 <lambdabot>  3.141592653589793
17:39:44 <bernalex> abstract-alf: no
17:39:47 <bernalex> abstract-alf: it's a value
17:39:47 <benzrf> i think i was fooled by the cowboy hat
17:39:49 <abstract-alf> k
17:40:08 <benzrf> no they totally look similar
17:40:11 <dwcook> Well, functions are values too
17:40:16 <bernalex> abstract-alf: saying "everything is a function" is a disease that carried over from "everything is an object". people really want some neat "trick" that makes it seem simpler than it is.
17:40:22 <bernalex> dwcook: this is much more correct, yeah
17:40:25 <augur> whats the standard technique for loading code/plugins in haskell?
17:40:33 <benzrf> augur: in what sense?
17:40:42 <benzrf> augur: just importing, i'd imagine
17:40:45 <benzrf> unless you mean something different
17:41:11 <augur> benzrf: dynamic loading. like, runtime loading of precompiled code
17:41:14 <benzrf> oic
17:41:15 <MP2E> sounds like he means dynamically loading a shared obje- yeah
17:41:18 <benzrf> lol
17:41:27 <bernalex> abstract-alf: one thing, which you will find people saying, is that it's a variable. let a = 5 defines a variable a which is a synonym for the value 5. this really confuses imperative people, because a variable in an imperative language is a mutable thing.
17:41:31 * benzrf shrugs
17:41:31 <augur> precompiled haskell fwiw
17:41:45 <benzrf> abstract-alf: in haxell all is expression
17:41:52 <bernalex> augur: in haskell it's just a mathematical variable. I prefer just calling it a synonym. "constant" would also be better than "variable" IMO.
17:41:58 <kazagistar> if by function you mean "there is possible computation that needs to be done before we can get the value" then sure, I guess constants can be functions but it is still awkward to try to shoehorn it like that
17:41:59 <bernalex> errm abstract-alf: ^
17:42:00 <marchelzo_> pi _ = 3.1415926535
17:42:07 <benzrf> modulo efficiency, you could replace every occurence of a var with its value and get the same semantics
17:42:12 <augur> bernalex: :x
17:42:19 <benzrf> ^definition of referential transparency!
17:42:33 <benzrf> strictly, there's the issue of recursion
17:42:36 <abstract-alf> bernalex: right.  I liked in the Scala language that there was a keyword for variable (var) and for value (val);  the latter was immutable
17:42:38 <benzrf> but meh
17:42:40 <augur> benzrf: false
17:42:45 <benzrf> augur: ?
17:42:48 <augur> benzrf: that is NOT referential transparency
17:42:55 <benzrf> augur: oh wait derp
17:43:05 <augur> that is a common misunderstanding that has propagated through CS like a bad disease
17:43:06 * benzrf puts on a big cone hat and sits in the corner
17:43:07 <bernalex> abstract-alf: right. I like in haskell where we skip that whole mutable stuff. ;-) but that's the common way of doing it in impure functional ML-like languages.
17:43:27 <benzrf> augur: function application replaced with its result, right
17:43:32 <benzrf> or is that also wrong?
17:43:33 <augur> benzrf: no
17:43:36 <bernalex> abstract-alf: arguably, C-like languages these days should be const-default. i.e. "int i" should make a const int, and you should be forced to say "var int i" to make a mutable int. IMO.
17:43:41 <benzrf> augur: hmm?
17:43:49 <abstract-alf> I like that too
17:43:56 <augur> benzrf: firstly: referential transparency is a property of syntactic contexts
17:44:01 <benzrf> it is ?!
17:44:04 <augur> yes
17:44:12 <benzrf> since when o.O
17:44:14 <dwcook> Referential transparency is forall a b f of appropriate types, a == b → f a == f b, right?
17:44:18 <augur> benzrf: since always
17:44:22 <augur> dwcook: no!
17:44:27 <benzrf> dwcook: heck no
17:44:47 <dwcook> What is what I just stated called then?
17:44:50 <dwcook> Does it have a name?
17:44:50 <augur> benzrf: CS people misunderstood the original definition and have spread dozens of "reinterpretations", each subtlely different
17:44:59 <benzrf> augur: whats the def then
17:44:59 <augur> dwcook: congruency of ==
17:45:05 <abstract-alf> lens question: say I have nested tuples that I want to update: let row = ((1,2,3),(4,5,6),(7,8,9)).  I can access the '6' with (row ^. _2 ^. _3).  How would I do an update on the same position?
17:45:30 <benzrf> abstract-alf: over (row . _2 . _3)
17:45:38 <benzrf> abstract-alf: why are you nesting tuples
17:45:45 <abstract-alf> it's just a quick example
17:46:10 <augur> benzrf: secondly: a context k[_] is referentially transparent (relative to some equivalence = on fillers, and ~ on filled contexts) iff forall x, y, x = y -> k[x] ~ k[y]
17:46:15 <bernalex> opaque: void add (int y) { x += y; }, where x is global. transparent: not that
17:46:29 <abstract-alf> benzrf: that didn't work
17:47:18 <benzrf> abstract-alf: oh
17:47:19 <bernalex> a transparent alternative would pass x
17:47:23 <benzrf> i assumed row was a lens
17:47:28 <abstract-alf> oh, ok
17:47:30 <bernalex> and update &x
17:47:42 <bernalex> but sleep now
17:48:38 <benzrf> http://en.wikipedia.org/wiki/Referential_transparency_%28computer_science%29 seems different p:
17:48:52 <augur> benzrf: as i said, the concept in CS is muddled and confused
17:49:06 <augur> benzrf: it was first imported into CS by strachey and someone, but they botched it
17:49:09 <Lutin`> benzrf: See http://en.wikipedia.org/wiki/Opaque_context
17:49:21 <augur> benzrf: they thought they were quoting quine, but they fucked it up and created a different definition
17:49:32 <augur> benzrf: then other people quoted THEM, and fucked THAT up creating a THIRD definition
17:49:35 <marchelzo_> augur: What is a context in that context? no pun intended
17:49:58 <augur> marchelzo_: a syntactic object with part of it plucked out. an AST with a single node missing
17:50:09 <abstract-alf> please, someone just connect the dots for me: lens question: say I have nested tuples that I want to update: let row = ((1,2,3),(4,5,6),(7,8,9)).  I can access the '6' with (row ^. _2 ^. _3).  How would I do an update on the same position?
17:50:39 <benzrf> abstract-alf: over (_2 . _3) (+1) row
17:50:42 <benzrf> alternatively
17:50:50 <augur> benzrf: there's a good paper on this, let me find it
17:51:07 <abstract-alf> benzrf: ahhhh, thanks that works
17:51:11 <augur> benzrf: http://www.cs.tufts.edu/~nr/cs257/archive/peter-sestoft/ref-trans.pdf
17:51:16 <benzrf> abstract-alf: the operator version is
17:51:18 <benzrf> oh wait shit
17:51:20 <augur> benzrf: that gives the sordid history of CS dopery
17:51:21 <benzrf> what's operator over
17:51:28 <abstract-alf> %~
17:51:30 <benzrf> ah
17:51:46 <benzrf> row & _2 . _.3 %~ (+1)
17:52:03 <abstract-alf> man, does that look like Perl to anybody else?
17:52:04 <abstract-alf> haha
17:52:54 <michaelt> belief generates the characteristic 'opaque context':  Clark = Superman ->  Lois believes  Superman leaps tall building <-> Lois believes Clark leaps tall buildings
17:53:01 <abstract-alf> benzrf: man, that is great.  now my state updates can become less cumbersome
17:53:12 <benzrf> abstract-alf: fun fact
17:53:15 <augur> benzrf: the precision of the concept is necessary because most languages exhibit the CORRECT notion of RT/RO in different places, and some languages have it in even more interesting ways (eg lisp)
17:53:20 <benzrf> lens comes with operators that create StateT's
17:53:24 <benzrf> :t (%=)
17:53:25 <lambdabot> (MonadState s m, Profunctor p) => Setting p s s a b -> p a b -> m ()
17:53:26 <abstract-alf> whut
17:53:31 <augur> michaelt: yep. tho belief isnt likely to show up in a proglang ;)
17:53:33 <abstract-alf> omg
17:53:42 <michaelt> augur, right
17:53:43 <benzrf> :t _2 . _3 %= (+1)
17:53:44 <lambdabot> (MonadState s m, Field2 s s a b, Field3 a b b1 b1, Num b1) => m ()
17:53:52 <augur> michaelt: except maybe in an epistemic logic based proglang
17:53:53 <Para_> agh
17:53:53 <abstract-alf> holy shit
17:54:05 <augur> michaelt: i wonder if pfenning's written about that
17:54:13 <benzrf> abstract-alf: also, most of the view-like operations create MonadReader's and not straight up functions
17:54:21 <benzrf> :t view
17:54:22 <lambdabot> MonadReader s m => Getting a s a -> m a
17:54:25 <Lutin`> augur: But wouldn't it be fair to say that in the context of haskell, if a = b then I can swap the two, making haskell referentially transparent?
17:54:26 <benzrf> :t (^.)
17:54:27 <lambdabot> s -> Getting a s a -> a
17:54:32 <augur> Lutin`: no
17:54:35 <benzrf> oh wait
17:54:42 <benzrf> abstract-alf: so for example you can do
17:54:49 <benzrf> v <- view (_2 . _3)
17:54:53 <benzrf> abstract-alf: in any ReaderT stack
17:54:59 <benzrf> not just plain Reader
17:55:27 <benzrf> :t (&)
17:55:28 <lambdabot> a -> (a -> b) -> b
17:55:33 <augur> Lutin`: binding creates opacity
17:55:35 <benzrf> @src (&)
17:55:35 <lambdabot> Source not found. :(
17:55:38 <benzrf> lame
17:55:41 <Lutin`> augur: Ah true
17:55:43 <augur> Lutin`: shadowing destroys substitutability
17:55:45 <abstract-alf> benzrf: my intuition says its probably a Hasell idiom but what is the 'T' in "ReaderT"?
17:55:47 <Lutin`> I see the issue now
17:55:51 <benzrf> abstract-alf: transformer
17:56:07 <augur> Lutin`: for instance, if you have a top-level declaration x = 5
17:56:19 <benzrf> abstract-alf: monad transformers are type constructors that take another monad and make a combo one
17:56:26 <augur> Lutin`: you cannot substitute 5 for x in the the context    let x = 2 in _
17:56:30 <abstract-alf> k
17:56:38 <augur> Lutin`:    let x = 2 in x   /=   let x = 2 in 5
17:56:42 <Lutin`> But one could argue these are different contexts
17:56:46 <benzrf> abstract-alf: for example, 'ReaderT IO' is a monad that supports reading and IO
17:56:49 <augur> Lutin`: but they're notdan
17:57:00 <augur> the context is precisely     let x = 2 in _
17:57:10 <benzrf> abstract-alf: it is not uncommon to make stacks of monad transformers
17:57:12 <Lutin`> And that context is referentially opaque
17:57:17 <augur> right
17:57:20 <Lutin`> Alright
17:57:25 <abstract-alf> benzrf: maybe not uncommon for you ;)
17:57:28 <benzrf> abstract-alf: for example, i wrote a little lisp that used a stack of either, state, and IO
17:57:47 <benzrf> so i could throw errors, keep track of vars, and have side effects
17:57:52 <Lutin`> augur: I'll get back to reading that paper, thanks for the info :)
17:57:57 <augur> Lutin`: it gets even more tricky when you have quotational things. lisp's quote mechanism breaks transparency completely
17:58:09 <abstract-alf> benzrf: I hope to get to that point some day.  for me, it's back to my CLI Sudoku game
17:58:11 <Lutin`> Yeah I can imagine
17:58:28 <Lutin`> Because then you could say things like the 'Cicero' quotation example?
17:58:46 <abstract-alf> benzrf: come to think of it, I'm using nested tuples to model the Sudoku board.  do you think lists would be a better fit?
17:58:50 <augur> Lutin`: well, some people shrug those off in proglangs because strings dont have internal syntax
17:59:01 <benzrf> abstract-alf: almost certainly o.o
17:59:07 <augur> Lutin`: "x + y" is just a single string, not an AST inside `Quote`
17:59:16 <benzrf> tuples above 2 is usually a sign you should be using somethin else
17:59:36 <augur> Lutin`: but for lisp-like code quoting, yes, you get that issue because there you really DO have ASTs inside quotes, the difference is only whether they get evaluated or not
17:59:48 <meditans> Hi, I'd like to know more/think about automatic/computer aided program synthesis (having Haskell in mind). Would you mind to share any pointer, or perspective on the matter?
17:59:49 <augur> Lutin`: so its completely sensible to talk about plucking out a portion of the AST
17:59:54 <abstract-alf> benzrf: something tells me that if I want the board to be a certain shape (9x9), I should use a data structure that has that shape as in invariant.  with lists, there is the opportunity for a run-time error. thoughts?
18:00:00 <Lutin`> Yes, that makes sense
18:00:12 <abstract-alf> *as an invariant
18:00:32 <augur> Lutin`: and in fact quasiquotes make this point extremely well -- because they turn on evaluation, they create transparency
18:00:55 <benzrf> abstract-alf: eeeh
18:01:05 <augur> Lutin`: string interpolation is similar in that it creates little regions of transparency inside otherwise non-syntactic, opaque strings
18:01:25 <benzrf> abstract-alf: what we really need are length-indexed list types -.-
18:01:55 <abstract-alf> so, you would still use lists?
18:02:08 <Lutin`> benzrf: Type-level nats?
18:02:34 <Lutin`> augur: Makes sense. I definitely see now how the term  has been bastardized
18:02:36 <augur> Lutin`: if i were to ask you what the denotation of    `(+ 3 ,x)   is in lisp/scheme, you MUST take into consideration the transparency issues
18:03:05 <benzrf> uuuuuuuurgggghhhhhhh my fucking chromebook doesnt support redshift
18:03:36 <augur> that immediately shows you that the issue of transparency is interesting, because your denotations cant be trivial things any more
18:03:52 <Para_> anybody know if you can call haskell from python?
18:03:55 <augur> you need some proper account of intensionality
18:04:05 <benzrf> Para_: i think so
18:04:14 <gamegoblin> Para_: Look at the subprocess module
18:04:22 <Lutin`> augur: It's a problem I've run into before with refactoring but never thought of it as something that could be defined suchly
18:04:29 <Para_> subprocess in python or haskell?
18:04:34 <gamegoblin> Para_: python
18:04:38 <Lutin`> Or at least never thought to
18:04:39 <Para_> ah alright
18:04:43 <Para_> I'll check it out
18:04:53 <gamegoblin> Para_: Subprocess allows you to invoke any command line function and mess with its stdin, stdout, etc etc
18:04:59 <Para_> yeah
18:05:15 <Para_> I'm pretty sure you can do that with sys too though
18:05:20 <Para_> but subprocess might be better
18:05:21 <augur> Lutin`: and this is why i jumped on benzrf for spreading the misunderstanding, because the CORRECT notion is very important but very different that "can always substitute equals for equals"
18:05:41 <gamegoblin> Para_: Subprocess is better. It’s a more abstract and easy to use wrapper.
18:05:51 <Para_> gotcha
18:05:54 <Para_> alright sweet, thanks
18:06:10 <Lutin`> augur: And what CS refers to as referential transparency should really just be referred to as a pure notion
18:06:16 <Lutin`> and not try to conflate the two
18:06:22 <Lutin`> s/notion/function/
18:06:31 <augur> Lutin`: right, it's a different concept (actually there are multiple ones)
18:06:46 <augur> Lutin`: the link i gave discusses them all. they're importantly distinct
18:06:46 <Para_> (honestly I'd rather use pure haskell but I'm using python because I already have a bunch of stuff written and modules are really convenient)
18:06:59 <Lutin`> Para_: You could also use foreign exports
18:07:02 <Sebboh> Does this hang forever, or .. to some sort of MAX_INT? [x | x <- [1..], x > 5, x < 10]
18:07:14 <Lutin`> But I'm not sure how Python's FFI works
18:07:25 <gamegoblin> Para_: I use subprocess a decent bit for calling haskell programs from a django app
18:07:57 <Para_> I'm not totally sure either haha, I've usually relied on modules to do it for me
18:08:02 <Para_> but subprocess seems to be a nice way to do it
18:08:27 <Lutin`> I'm just suggesting if you want to use a library without writing a command line interface to all of it's functions
18:08:31 <Lutin`> its*
18:10:44 <gamegoblin> How do I make sure I get docs for a library on Hackage? I uploaded this library on hackage some time ago and the docs never showed up. I am about to upload v2 and I want to get it right. http://hackage.haskell.org/package/JustParse-1.0
18:11:18 <abstract-alf> benzrf: 'nother lens question: how can I construct a lens that focuses on a particular index in a list?
18:11:31 <abstract-alf> (or anyone who can answer)
18:11:36 <Sebboh> ... this returns an empty list... [x | x <- take 100000000000000000000000000000000 [1..], x > 5, x < 10] Please tell me about this.  And the other question above. :)
18:11:37 <dwcook> Sebboh: The meaning of [1..] is determined by the definition of enumFrom at the specific type you're working with.
18:11:49 <benzrf> abstract-alf: ix
18:11:51 <dwcook> @type enumFrom
18:11:52 <bms1> meditans: I like think of Hoogle as a sort of automated program synthesis tool
18:11:52 <lambdabot> Enum a => a -> [a]
18:11:56 <benzrf> that's a traversal though
18:11:59 <Lutin`> Para_: more on that approach http://weblog.haskell.cz/pivnik/building-a-shared-library-in-haskell/
18:12:02 <abstract-alf> ah, traversal
18:12:02 <benzrf> it isnt guarantee to work
18:12:09 <benzrf> so you may want to use preview
18:12:16 <benzrf> > preview (ix 2) [1, 2, 3, 4]
18:12:17 <michaelt> gamegoblin: good question, I have been building them locally and uploading them, after replacing the links; it's a nightmare
18:12:19 <lambdabot>  Just 3
18:12:22 <benzrf> > preview (ix 22) [1, 2, 3, 4]
18:12:24 <lambdabot>  Nothing
18:12:33 <meditans> bms1: it is in a sense, but I have in mind something a bit more powerful
18:12:42 <Para_> Thanks Lutin
18:12:45 <abstract-alf> benzrf: any idea why the name 'ix' was chosen?
18:12:51 <benzrf> short for index
18:12:52 <abstract-alf> benzrf: it helps my understanding
18:12:53 <abstract-alf> ok
18:13:19 <Sebboh> dwcook: I think the type I'm working with is.. Integer.  I dunno.  Is there a function that returns the type of an .. expression?
18:13:20 <meditans> bms1: like, synthesis using both examples and test properties, and the types it finds in your code
18:13:36 <Sebboh> Functions are called functions, right?
18:13:40 <Para_> @botsnack
18:13:40 <lambdabot> :)
18:14:15 <dwcook> Sebboh: Are you writing that expression in a Haskell program file or in ghci or something else?
18:14:15 <bms1> meditans: I'm particularly partial to type-directed synthesis
18:14:16 <Lutin`> Para_: This includes the python code
18:14:18 <Lutin`> https://wiki.python.org/moin/PythonVsHaskell#line-85
18:14:49 <Para_> oohh awesome
18:14:57 <Para_> thanks
18:15:29 <Sebboh> dwcook: ghci.  I know how to save function definitions in a .hs file and then :l (load) them.
18:15:39 <Sebboh> (But I didn't do that in this case.)
18:16:01 <dwcook> Sebboh: In the case of ghci, a type will be chosen by default if you haven't specified one, but if you ask ghci for its type with :t or similar, it will give you the most general type.
18:16:11 <Lutin`> That code gives me a warning since 100000000000000000000000000000000 is larger than the 64-bit Int range lol
18:16:24 <Sebboh> > :t 1
18:16:26 <lambdabot>  <hint>:1:1: parse error on input ‘:’
18:16:31 <Sebboh> aww.
18:16:32 <Lutin`> :t 1
18:16:34 <lambdabot> Num a => a
18:17:07 <Sebboh> same result in ghci.
18:17:23 <michaelt> gamegoblin: I use this script, only the middle part where it gives a special prefix command to cabal haddock doesn't seem to work, so I ... use regexes...
18:17:25 <Lutin`> Just ':t 1'
18:17:36 <michaelt> gamegoblin: https://gist.github.com/nh2/8284831 was the link I meant
18:17:36 <dwcook> Sebboh: Yes, but to evaluate the expression, ghci will pick a type. I'm not sure what its mechanism for doing so is. Someone else here might know.
18:17:44 <Sebboh> Lutin`, 64bit int, ok.
18:18:03 <Sebboh> oh a big number might get a different type?
18:18:24 <subleq_> what does it mean when people say that module systems are a research problem?
18:18:31 <Lutin`> No it's that the type of 'take' is
18:18:33 <Lutin`> :t take
18:18:34 <lambdabot> Int -> [a] -> [a]
18:18:36 <Sebboh> -- :t 100000000000000000000000000000000  gives a Num, too.
18:18:49 <Lutin`> So if you pass it that huge number you get an integer overflow
18:18:55 <Lutin`> or 0, one of the two
18:19:01 <dwcook> I had the expression [x | x <- [1..], x > 5, x < 10] in mind for everything I said.
18:19:18 <Lutin`> try `100000000000000000000000000000000 :: Int`
18:19:21 <hpc> subleq_: the short, simple, and slightly wrong version is that a module system that has all the features that picky haskellers want is currently not available
18:19:24 <hpc> but being researched
18:19:45 <subleq_> hpc: what are these features, and why is it hard?
18:20:00 <subleq_> is the problem specific to haskell?
18:20:08 <hpc> that's beyond what i can answer; i am not one of the picky ones ;)
18:20:26 <hpc> but one of the biggies is parameterized modules, iirc?
18:20:28 <Sebboh> take returns Int not Num. (the way I used it.) ok cool.  I can live with that.  And sometimes overflow results in 0.  which explains why I got an empty list back from the comprehension.  ...I think. :)
18:20:35 <dwcook> hpc: Like what ML has?
18:20:37 <subleq_> or can i understand this through comparison with something like python's module system, which i understand much more than haskell's?
18:21:02 <hpc> python's module system is fairly simple
18:21:12 <kazagistar> > take -20 [1..]
18:21:14 <lambdabot>  Could not deduce (GHC.Num.Num
18:21:14 <lambdabot>                      ([t0] -> GHC.Types.Int -> [a] -> [a]))
18:21:14 <lambdabot>    arising from the ambiguity check for ‘e_1201’
18:21:14 <lambdabot>  from the context (GHC.Num.Num ([t] -> GHC.Types.Int -> [a] -> [a]),
18:21:14 <lambdabot>                    GHC.Num.Num (GHC.Types.Int -> [a] -> [a]),
18:21:19 <kazagistar> er
18:21:20 <Lutin`> Sebboh: In your case it overflows to -8814407033341083648
18:21:29 <hpc> a module executes within a new namespace
18:21:29 <kazagistar> > take (-20) [1..]
18:21:30 <dwcook> kazagistar: that's (take) - (20 [1..])
18:21:31 <lambdabot>  []
18:21:31 <hpc> in order of import
18:21:42 <kazagistar> so, anything 0 or lower gives you an empty list
18:22:02 <Sebboh> ok.  I'll play around some more and use :t now that I know about it.  Thanks folks!
18:22:13 <kazagistar> giant overflows have a 50% ish chance of landing in the negative range, so your answer is not unexpected, Sebboh
18:22:29 <hpc> so, imagine a python module, for which i will use incorrect python because i am sleepy
18:22:34 <abstract-alf> benzrf: 'nother lens question: how can I construct a lens that focuses on a particular index in a list (to perform an update), where the index might not exist?
18:22:40 <hpc> module foo;
18:22:42 <hpc> er
18:22:46 <hpc> module foo(x);
18:22:56 <ninja_code> does haskell have something like clojure's core.async ? basically, I want to "invert" the control; and instead of havling callbacks, I want to have queues with events I can pull off (this is in the context of gui programming) -- in particular, I'm using haste + javascript. I'm wondering if Haskell has some crazy monad tricks to handle this.
18:22:58 <abstract-alf> or, what's the function that invokes a maybe update)
18:22:59 <dwcook> There's a fun problem, picking an absolutely random number, what's the chance it's a negative integer modulo 2^64? :P
18:23:01 <hpc> def do_the_thing():
18:23:04 <hpc>   return x;
18:23:10 <kazagistar> > (100000000000000000000000000000000 :: Int)
18:23:10 <dwcook> Wait, er
18:23:12 <lambdabot>  -8814407033341083648
18:23:14 <hpc> so now you can do
18:23:20 <dwcook> I wrote that wrong. But was being facetious anyway
18:23:22 <hpc> import foo(5) as five
18:23:25 <Para_> I'm reading a stack overflow answer and I'm having trouble understanding a certain pattern matching -- what does (x:xs@(x':_)) match to?
18:23:26 <hpc> import foo(6) as six
18:23:34 <hpc> five.do_the_thing() = 5
18:23:35 <Para_> from what I understand, x' is the first element of the list
18:23:39 <hpc> six.do_the_thing() = 6
18:23:46 <Para_> but then isn't x the first element of the list too?
18:23:48 <hpc> and those are two different modules
18:23:58 <abstract-alf> Para_: I think x' is the second element of the parent list.  x is the first
18:23:59 <Sebboh> kazagistar: so the "ish" in 50% ish is due to the fact that some bit patterns are invalid or represent NaN or something?
18:24:03 <hpc> (in the upper module that's importing foo twice)
18:24:06 <Lutin`> dwcook: Yeah good luck generating elements from the distribution of all integers
18:24:16 <abstract-alf> Para_: x' is the first element of the second list (aliased as xs)
18:24:19 <dwcook> Lutin`: yeeeah :P
18:24:36 <ninja_code> does haskell have something like clojure's core.async ? basically, I want to "invert" the control; and instead of havling callbacks, I want to have queues with events I can pull off (this is in the context of gui programming) -- in particular, I'm using haste + javascript. I'm wondering if Haskell has some crazy monad tricks to handle this. Damn it, Haskell sucks, clojure is so much better. :-)
18:24:54 <kazagistar> Sebboh: the ish is due to the fact that defining what a totally arbitrary random integer is seems like a complex problem, so I am leaving it alone
18:25:11 <Lutin`> dwcook: Also modulo 2^64 normally returns a positive number
18:25:14 <Sebboh> kazagistar: fair enough.
18:25:25 <Para_> abstract-alf: alright thank you
18:25:33 <qrada> ninja_code: Control.Concurrent.Chan/MVar/TVar ?
18:25:43 <dwcook> ninja_code: It sounds like you might be trying to solve the wrong problem. That said, you might be interested in either the concurrent package or the async package.
18:26:07 <ninja_code> dwcook: when writing haskell code that compiles to javascript, what is the correct way to handle keybaord/mouse events ?
18:26:21 <dwcook> ninja_code: I have no idea, I've never used any of the Haskell-to-JS compilers.
18:26:21 <benzrf> dwcook: isnt it 2^65
18:26:23 <Lutin`> What are you compiling with?
18:26:26 <zq> :t void
18:26:28 <lambdabot> Functor f => f a -> f ()
18:26:28 <ninja_code> Haste
18:26:29 <Lutin`> benzrf: No
18:26:39 <benzrf> abstract-alf: that's ix
18:26:41 <ninja_code> I'm using Haste to compile Haskell to Javascript. Wht is the haskell-ish way to handle keyboard/mouse events ?
18:26:50 <benzrf> abstract-alf: there is no other option that isn't that
18:26:51 <benzrf> afaik
18:26:54 <dwcook> Lutin`: That's the part I meant I wrote wrong but it wasn't worth correcting because it was a ridiculous question in the first place
18:26:58 <subleq_> hpc: eh, i guess that could be useful
18:27:07 <abstract-alf> benzrf: ok, but what's the function to 'maybe set' the value, rather than 'maybe get'
18:27:07 <ninja_code> I'm using Haste to compile Haskell to Javascript. Wht is the haskell-ish way to handle keyboard/mouse events ? Right now, I'm seeting up haskell callbacks on javascript events, which seems like the wrong way.
18:27:11 <abstract-alf> ?
18:27:12 <qrada> ninja_code: Doesn't haste have all of those On* events?
18:27:12 <Lutin`> benzrf: -(2^63) to (2^63-1)
18:27:17 <kazagistar> Sebboh: "given an Integer range of 0 to n, then the chance that it gives you a negative number when forced into an Int approaches 50% as n approaches infinity" is harder to type then 50%ish :P
18:27:22 <Sebboh> ok, so, the 'take' thing aside...  Back to my original question: will [x | x <- [1..], x > 5, x < 10] return eventually?
18:27:37 <Lutin`> kazagistar: It wouldn't approach 50
18:27:39 <dwcook> Sebboh: It depends on the definition of enumFrom.
18:27:40 <benzrf> Lutin`: blaaaaaaah
18:27:55 <benzrf> abstract-alf: over, of course
18:28:04 <abstract-alf> derp
18:28:21 <Sebboh> dwcook: is that not ... known?  I mean, to people other than me. :)  Does it vary?  I was asked how I was invoking the expression.  Why?
18:28:25 <Lutin`> kazagistar: Oh wait yes it would got my ranges flipped around
18:28:26 <kazagistar> Lutin`: I guess there is one more negative then positive number...
18:28:44 <dwcook> Sebboh: It's not known if you don't have a specific enough type to be able to pick a specific instance of Enum.
18:29:08 <dwcook> Sebboh: [a..] is actually just syntactic sugar for Prelude.enumFrom a.
18:29:37 <Sebboh> I don't understand.  I was asking for a specific expression.  ...In ascii.  ? :)
18:29:37 <Lutin`> kazagistar: Yeah but there's 2^63 negative out of 2^64 total
18:30:05 <kazagistar> Sebboh: that expression "returns" instantly, but you cannot ever fully evaluate it, no... the result of that expression is  6:7:8:9:_|_
18:30:29 <gamegoblin> What do I need to put in my .cabal file to have haddock generated in the dist?
18:31:13 <abstract-alf> benzrf: over (ix 2) (+1) [1,2,3,4]   --> [1,2,4,4]
18:31:21 <abstract-alf> benzrf: how about infix?
18:31:26 <dwcook> kazagistar: You could fully evaluate it if [1..] were finite.
18:31:31 <dwcook> also Sebboh
18:31:37 <benzrf> (%~), as you pointed out
18:31:40 <benzrf> :t (%~)
18:31:41 <dwcook> However, in any case, it will iterate over the entire list.
18:31:41 <lambdabot> Profunctor p => Setting p s t a b -> p a b -> s -> t
18:31:45 <benzrf> or
18:31:47 <benzrf> :t (%=)
18:31:49 <lambdabot> (MonadState s m, Profunctor p) => Setting p s s a b -> p a b -> m ()
18:32:21 <kazagistar> Sebboh: actually, yeah, I am wrong, it does fully evaluate, since [1..] is in fact finite for Int
18:32:21 <dwcook> Sebboh: You might be interested in dropWhile and/or takeWhile.
18:32:35 <Sebboh> [x | x <- [1..], x > 5, x < 10] does not return on my machine.  I get (sic): [6,7,8,9
18:32:49 <dwcook> Sebboh: Probably because ghci chose Integer as the type.
18:33:02 <dwcook> Also it might take a while to do it for Int as well.
18:33:07 <abstract-alf> benzrf: [1,2,3,4] & (ix 2) %= (+1)   (doesn't work :( )
18:33:17 <kazagistar> > [1,1000000001..]
18:33:19 <lambdabot>  [1,1000000001,2000000001,3000000001,4000000001,5000000001,6000000001,7000000...
18:33:24 <benzrf> :t [1,2,3,4] & (ix 2) %= (+1)
18:33:26 <lambdabot>     No instance for (Num t0) arising from the literal ‘1’
18:33:26 <lambdabot>     The type variable ‘t0’ is ambiguous
18:33:26 <lambdabot>     Note: there are several potential instances:
18:33:29 <benzrf> yooooo
18:33:34 <abstract-alf> omg
18:33:37 <Lutin`> Sebboh: It doesn't know that there are no more numbers that fit those conditions, so it keeps trying them all
18:33:50 <benzrf> :t ([1,2,3,4] :: [Int]) & (ix 2) %= (+1)
18:33:51 <lambdabot>     No instance for (Ixed s0) arising from a use of ‘ix’
18:33:51 <lambdabot>     The type variable ‘s0’ is ambiguous
18:33:51 <lambdabot>     Note: there are several potential instances:
18:33:55 <benzrf> >:{
18:33:56 <dwcook> Sebboh: ^ which is why I suggest dropWhile and/or takeWhile
18:34:00 <benzrf> :t ([1,2,3,4] :: [Int]) & (ix (2 :: Int)) %= (+1)
18:34:01 <lambdabot>     Couldn't match expected type ‘Index s0’ with actual type ‘Int’
18:34:01 <lambdabot>     The type variable ‘s0’ is ambiguous
18:34:01 <lambdabot>     In the first argument of ‘ix’, namely ‘(2 :: Int)’
18:34:04 <benzrf> i s2g
18:34:06 <dwcook> That has you explicitly specify when to stop checking
18:34:13 <benzrf> :t [1,2,3,4] & ((ix 2) %= (+1))
18:34:14 <lambdabot>     No instance for (Num t0) arising from the literal ‘1’
18:34:15 <lambdabot>     The type variable ‘t0’ is ambiguous
18:34:15 <lambdabot>     Note: there are several potential instances:
18:34:20 <Lutin`> benzrf: you know you can talk to Lambdabot in PMs
18:34:21 <benzrf> what the butt
18:34:52 <Lutin`> Specify a type for 1
18:34:57 <benzrf> .-.
18:34:57 <Sebboh> Sure, so, I think I understand now.  The expression checks the whole list, and for Integer [1..] is NOT infinite.
18:35:07 <benzrf> :t [1,2,3,4] & (ix 2) %= (+(1 :: Int))
18:35:07 <abstract-alf> .-.  <-- is that an operator, or a face?
18:35:08 <lambdabot>     Couldn't match type ‘IxValue s0’ with ‘Int’
18:35:08 <lambdabot>     The type variable ‘s0’ is ambiguous
18:35:08 <lambdabot>     Expected type: Setting (->) s0 s0 Int Int
18:35:11 <Lutin`> Sebboh: No for Integer it's infinite
18:35:12 <benzrf> abstract-alf: hehehe
18:35:20 <Lutin`> Sebboh: Well, bounded by your computer's memory
18:35:34 <Sebboh> Lutin`, won't it discard as it goes?
18:35:40 <kazagistar> Sebboh: Integer is unbounded (other then memory) while Int is bounded
18:36:01 <benzrf> :t ([1,2,3,4] :: [Int]) & (ix (2 :: Int)) %= (+(1 :: Int))
18:36:02 <lambdabot>     Couldn't match type ‘IxValue s0’ with ‘Int’
18:36:03 <lambdabot>     The type variable ‘s0’ is ambiguous
18:36:03 <lambdabot>     Expected type: Setting (->) s0 s0 Int Int
18:36:04 <Sebboh> Oh, oh, ok.  Fine. :)
18:36:07 * benzrf smacks lambdabot 
18:36:17 <Lutin`> Sebboh: after it gets past 9 it doesn't know that the list doesn't contain more elements that satisfy your conditions
18:36:20 <benzrf> oh wait im a idiot
18:36:24 <Lutin`> So it will run until you run out of memory
18:36:29 <benzrf> abstract-alf: (%=) is for creating State ops
18:36:36 <kazagistar> > maxBound :: Int
18:36:37 <benzrf> if you want to create a function, use (%~)
18:36:38 <Lutin`> since [1..] is unbounded for Integer
18:36:38 <lambdabot>  9223372036854775807
18:36:54 <Lutin`> @src Int Bounded
18:36:54 <lambdabot> Source not found. Are you on drugs?
18:37:00 <Lutin`> aw man
18:37:00 <abstract-alf> LOL
18:37:08 <Lutin`> I wish, lambdabot
18:37:16 <kazagistar> >maxBound :: Integer
18:37:39 <dwcook> kazagistar: space is required
18:37:43 <dwcook> > maxBound :: Integer
18:37:44 <lambdabot>  No instance for (GHC.Enum.Bounded GHC.Integer.Type.Integer)
18:37:44 <lambdabot>    arising from a use of ‘GHC.Enum.maxBound’
18:37:55 <kazagistar> as it should be :P
18:38:00 <abstract-alf> > [1,2,3,4] & (ix 2) %~ (+10)
18:38:02 <lambdabot>  [1,2,13,4]
18:38:05 <abstract-alf> wahoo!
18:38:08 <Lutin`> > maxBound :: Double
18:38:10 <lambdabot>  No instance for (GHC.Enum.Bounded GHC.Types.Double)
18:38:10 <lambdabot>    arising from a use of ‘GHC.Enum.maxBound’
18:38:14 <Lutin`> wat
18:38:21 <abstract-alf> benzrf: thanks for your help!
18:38:28 <benzrf> abstract-alf: no pralbum
18:38:29 <dwcook> Lutin`: Because of NaN, I guess
18:38:35 <Lutin`> Oh
18:38:37 <Lutin`> Infinity
18:38:51 <gamegoblin> What do I need to put in my .cabal file to have haddock generated in the dist?
18:39:58 <Sebboh> ...oh, ok, so, when you say memory bound, I ask myself "why would it keep 1, 2, 3, ... after it has checked them?"  But then I realized.. it doesn't, it discards them. But even still it is memory bound because my computer will run out of memory trying to store a *single* integer at some point, for some integer large enough.  Is that right?
18:40:15 <kazagistar> Sebboh: exactly
18:40:31 <Sebboh> Me gusta.
18:41:02 <Sebboh> Also fuck that , ctrl-c. :P
18:41:28 <abstract-alf> k:j:r
18:41:31 <Lutin`> Sebboh: Yep
18:41:33 <abstract-alf> oops. vim
18:42:11 <Sebboh> Well folks I like your little programming language.  Congrats. :)
18:42:24 <kazagistar> Sebboh: go ahead and give it a try... define factorial, then find (fact 1000000000000000000) and watch your computer crash from memory problems :P
18:43:20 <Sebboh> I can think of many ways to make large integers. :P  My DNA is an integer if/when I store it an switch encodings.
18:43:28 <Sebboh> *and
18:43:42 <kazagistar> > let factorial x = product [1..x] in (factorial 1000000000000000) :: Integer
18:43:47 <lambdabot>  mueval-core: Time limit exceeded
18:44:28 <kazagistar> sorry lambdabot, that was mean of me :(
18:44:36 <Para_> when I call a haskell program with a command line argument, say ./test arg1
18:44:42 <Para_> can I just read arg1 with a do block
18:44:46 <Para_> and a arg1 <- getLine
18:44:51 <Para_> or do I need to do something else?
18:44:54 <Sebboh> also my computer will not crash from memory problems, the kernel will just term the process. ;)
18:45:15 <Para_> never mind
18:45:21 <Para_> I couldn't find it earlier
18:45:24 <kazagistar> Para_: getArgs
18:45:25 <MP2E> Para_: `https://hackage.haskell.org/package/base-4.7.0.0/docs/System-Console-GetOpt.html
18:45:26 <Para_> but I must have accidentally skipped over it
18:45:34 <Para_> :)
18:45:35 <Para_> thanks though
18:47:30 <Lutin`> kazagistar: lol that factorial has 249,999,999,999,999,995 zeroes
18:51:20 <kazagistar> Lutin`: well, then it accomplishes my goal of requiring more memory then the computer has :P
18:53:40 <Lutin`> You would need somewhere around 25 exobytes to store the result with integers
18:54:04 <Lutin`> and that's not including the memory to store the arrays of arrays of arrays you would need to reference them
18:54:58 <Para_> okay wait so when you do an input
18:55:01 <Para_> args <- getArgs
18:55:11 <Para_> :t getArgs
18:55:12 <lambdabot> Not in scope: ‘getArgs’
18:55:20 <gamegoblin> Para_ It’s of type IO [String]
18:55:24 <Lutin`> Ah nevermind more around 0.7 exobytes
18:55:40 <Para_> alright -- so how can I parse it?
18:55:44 <Lutin`> very rough estimate
18:55:52 <Para_> I'm passing it, for example, [3,5,6,1,2,3]
18:55:55 <Para_> how can I make that a list?
18:56:08 <Para_> (of integers/integrals)
18:56:15 <Para_> (or just something that I can compute)
18:56:16 <Lutin`> You could try just 'read'ing it
18:56:21 <Para_> is that dangerous?
18:56:22 <Lutin`> Or use a parser library
18:56:27 <Para_> (I know in python we're told to stay away from eval)
18:56:31 <gamegoblin> Para_: Well it’s currently a list of Strings, you want a list of Ints, do “map read myList”
18:56:34 <Twey> Para_: read isn't eval
18:56:38 <Para_> okay
18:56:40 <silasm> :t read
18:56:41 <lambdabot> Read a => String -> a
18:56:50 <Para_> awesome thanks
18:56:52 <gamegoblin> Para_: `read` is similar to java “fromString” or something
18:56:53 <Twey> Para_: It's more like int("5") in Python terms.
18:56:58 <Para_> oh awesome
18:56:59 <Lutin`> > read "[1,2,3,4,5]"
18:57:00 <kazagistar> Para_: I like optparse-applicative
18:57:01 <lambdabot>  *Exception: Prelude.read: no parse
18:57:03 <Para_> no dangerous security things
18:57:09 <Lutin`> that can happen though
18:57:18 <Lutin`> read is very picky
18:57:19 <Twey> Lutin`: λb defaults to ()
18:57:30 <Twey> > read "[1,2,3,4,5]" ∷ [Integer]
18:57:31 <silasm> > map (read . show) [1,2,3,4,5]
18:57:31 <ludflu> hi haskellers. any thoughts on escaping cabal hell? I'm trying to install haste-compiler but it dies on the zip-archive-0.2.3 dependency
18:57:32 <gamegoblin> Para_: The only issue you can happen is trying to read something that isn’t an int, in which case a “no parse” exception will be thrown.
18:57:32 <Lutin`> Oh
18:57:32 <lambdabot>  [1,2,3,4,5]
18:57:32 <lambdabot>  can't find file: L.hs
18:57:39 <Lutin`> Fair enough
18:57:50 <Para_> oh alright
18:58:01 <Para_> wait though
18:58:05 <Para_> for example, if I have a float in there
18:58:08 <Para_> will everything become a float?
18:58:24 <Twey> Para_: Everything will be what type it needs to be (but only one type for the whole list)
18:58:28 <Twey> > read "[1,2,3,4,5]" ∷ [Float]
18:58:30 <lambdabot>  [1.0,2.0,3.0,4.0,5.0]
18:58:35 <Lutin`> > read "[1,2.0,3]" :: Num a
18:58:37 <lambdabot>  Expected a type, but ‘GHC.Num.Num a’ has kind ‘Constraint’
18:58:37 <Para_> gotcha
18:58:38 <Para_> thanks
18:58:39 <kazagistar> Para_: types are locked at compile time, runtime data cannot affect types
18:58:50 <Maxdamantus> Prelude Data.Count> length $ show $ toPos [1..25]
18:58:51 <Maxdamantus> 47318274
18:58:52 <Lutin`> oh man I'm screwing up consistenty
18:58:57 <Lutin`> > read "[1,2.0,3]" :: Num a => a
18:58:59 <lambdabot>  Could not deduce (GHC.Read.Read a1)
18:58:59 <lambdabot>    arising from a use of ‘Text.Read.read’
18:58:59 <lambdabot>  from the context (GHC.Num.Num a)
18:58:59 <lambdabot>    bound by the inferred type of it :: GHC.Num.Num a => a at Top level
18:58:59 <lambdabot>  or from (GHC.Num.Num a1)
18:59:06 <Lutin`> he
18:59:13 <Lutin`> > read "[1,2.0,3]" :: Num a, Read a => a
18:59:14 <lambdabot>  <hint>:1:26: parse error on input ‘,’
18:59:21 <Twey> Lutin`: There's no Read instance for Num a ⇒ a
18:59:37 <kazagistar> :t read "[1,2.0,3]" :: Num a, Read a => a
18:59:37 <Para_> awesome thanks guys!
18:59:38 <lambdabot> parse error on input ‘,’
18:59:47 <Lutin`> Oh
18:59:48 <kazagistar> > read "[1,2.0,3]" :: (Num a, Read a) => a
18:59:49 <Lutin`> parens
18:59:50 <lambdabot>  *Exception: Prelude.read: no parse
18:59:57 <Twey> Defaulted to () again =)
19:00:00 <Lutin`> Yeah
19:00:03 <kazagistar> :t read "[1,2.0,3]" :: (Num a, Read a) => a
19:00:04 <lambdabot> (Read a, Num a) => a
19:00:20 <kazagistar> ugh, it does not tell us that it defaults though
19:00:30 <Twey> Yeah, it's a bit counterintuitive.
19:00:43 <Twey> In a program you would just get an error
19:00:59 <silasm> > read "[(),(),()]" :: (Num a, Read a) => a
19:01:01 <lambdabot>  *Exception: Prelude.read: no parse
19:01:21 <Twey> > () + ()
19:01:22 <silasm> > read "[(),(),()]" :: [(Num a, Read a)] => a
19:01:22 <lambdabot>  No instance for (GHC.Num.Num ()) arising from a use of ‘GHC.Num.+’
19:01:24 <lambdabot>  The first argument of a tuple should have kind ‘*’,
19:01:24 <lambdabot>    but ‘GHC.Num.Num a’ has kind ‘Constraint’
19:01:27 <kazagistar> > read "()"
19:01:29 <lambdabot>  ()
19:01:32 <kazagistar> yay
19:01:35 <kazagistar> how useful
19:01:42 <Twey> Hehe
19:01:46 <luzie> > read "[(),(),()]" :: [()]
19:01:47 <lambdabot>  [(),(),()]
19:01:50 <Lutin`> > read "[1,2.0,3]" :: (Read a, Fractional a) => [a]
19:01:52 <lambdabot>  [1.0,2.0,3.0]
19:01:53 <silasm> > read "[(),(),()]" :: [(Num a, Read a) => a]
19:01:55 <lambdabot>  Illegal polymorphic or qualified type:
19:01:55 <lambdabot>    (GHC.Num.Num a, GHC.Read.Read a) => a
19:01:55 <lambdabot>  Perhaps you intended to use ImpredicativeTypes
19:01:57 <Lutin`> I win :D
19:02:04 <Twey> silasm: The syntax is (Num a, Read a) ⇒ [a].  But it won't work, for the same reason as the others.
19:02:24 <silasm> Twey: I thought the issue was it defaulting to () though?
19:02:32 <silasm> > read "[(),(),()]" :: (Num a, Read a) => [a]
19:02:33 <lambdabot>  *Exception: Prelude.read: no parse
19:02:38 <Twey> Hm
19:02:47 <luzie> > read "[1,2,3]" :: (Num a, Read a) => [a]
19:02:49 <lambdabot>  [1,2,3]
19:02:54 <Twey> I don't know what it will default to with a Num constraint
19:02:55 <luzie> ┐(‘～`；)┌
19:02:56 <silasm> oh right
19:03:02 <silasm> > () + ()
19:03:03 <lambdabot>  No instance for (GHC.Num.Num ()) arising from a use of ‘GHC.Num.+’
19:03:11 <Lutin`> Yeah it's not going to try every type that satisfies Num
19:03:14 <Twey> Integer, apparently
19:03:28 <silasm> :t read "[1,2,3]" :: (Num a, Read a) => [a]
19:03:29 <lambdabot> (Read a, Num a) => [a]
19:03:41 <Lutin`> If you give it the type it will just give it right back lol
19:03:46 <silasm> heh yeah
19:03:52 <Twey> @let x = read "[1,2,3]" :: (Num a, Read a) => [a]
19:03:54 <lambdabot>  Defined.
19:03:55 <Twey> :t x
19:03:56 <lambdabot>     Ambiguous occurrence ‘x’
19:03:56 <lambdabot>     It could refer to either ‘L.x’,
19:03:56 <lambdabot>                              defined at /home/lambda/.lambdabot/State/L.hs:157:1
19:04:00 <Twey> :t L.x
19:04:01 <lambdabot> (Read a, Num a) => [a]
19:04:11 <Twey> Hmph
19:04:21 <silasm> probably Integer.
19:04:26 <Twey> Probably Integer.
19:04:31 <silasm> since that tends to be the default
19:04:32 <Lutin`> we should stop anyways
19:04:41 <Twey> @undef
19:04:41 <lambdabot> Undefined.
19:04:45 <Lutin`> we're flooding the channel with stuff we can test in GHCi
19:04:51 <kazagistar> if someone asks real questions we can stop :P
19:05:10 <Twey> Lutin`: λb's defaulting rules are not GHCi's
19:05:14 <luzie> > let x = read :: (Num a, Read a) => String -> [a] in x
19:05:16 <lambdabot>  <[Char] -> [Integer]>
19:05:37 <Lutin`> Twey: Everything we've tried gives me the same as in GHCi
19:05:53 <Lutin`> luzie wins!
19:06:04 <Twey> GHCi doesn't default to ()
19:06:11 <Twey> read "()" is an error
19:06:22 <Lutin`> nope
19:06:25 <Lutin`> it returns ()
19:06:26 <Para_> putStrLn [3,4,5]
19:06:32 <kazagistar> > read "()"
19:06:33 <lambdabot>  ()
19:06:34 <Para_>  >putStrLn [3,4,5]
19:06:36 <luzie> my ghc defaults to ()
19:06:39 <luzie> er, ghci
19:06:44 <Twey> Prelude> read "()"
19:06:50 <Twey>     No instance for (Read a0) arising from a use of `read'
19:06:55 <Lutin`> @src putStrLn
19:06:56 <lambdabot> putStrLn s =  do putStr s; putChar '\n'
19:06:56 <kazagistar> mine errors too
19:06:57 <Twey> Huh, weird.  What version?
19:06:59 <Para_>  >putStrLn ((read [3,4,5]) :: [Char])
19:07:01 <Lutin`> Para_: See that
19:07:04 <Twey> I'm on 7.6.3
19:07:08 <kazagistar> its ambiguous
19:07:09 <luzie> i'm on 7.8.2
19:07:09 <Lutin`> @src putStr
19:07:10 <lambdabot> putStr s  = hPutStr stdout s
19:07:15 <Twey> I guess they added it
19:07:16 <Para_> uh
19:07:22 <Lutin`> Para_: putStrLn puts a string
19:07:25 <Para_> it only works with strings
19:07:25 <Para_> yeah
19:07:28 <Lutin`> you need to use show
19:07:30 <Para_> agh so I need to convert it to a string
19:07:34 <Lutin`> @src print
19:07:34 <lambdabot> print x = putStrLn (show x)
19:07:50 <Para_> so I might as well use print
19:07:54 <Lutin`> yep
19:07:58 <kazagistar> Para_: thats what it is there for
19:08:10 <Para_> why would people use putStrLn then?
19:08:14 <Para_> if you can use print with strings too?
19:08:21 <kazagistar> > print "hello"
19:08:22 <lambdabot>  <IO ()>
19:08:30 <Lutin`> foiled again!
19:08:31 <Twey> > show "foo"
19:08:32 <lambdabot>  "\"foo\""
19:08:37 <kazagistar> thanks
19:08:40 <luzie> print "hi" prints "hi" (with quotes)
19:08:57 <Twey> Para_: print will print out a show'd version, which usually means some kind of source literal
19:09:06 <Twey> Sometimes you just want to print out a literal string
19:09:16 <Para_> oh alright, and in that case putStrLn is good
19:09:19 <Twey> (usually, even)
19:09:19 <Lutin`> The idea is the output of show should be valid haskell
19:10:16 <Para_> oh
19:10:18 <augur> so, anyone know how to do proper code loading? :x
19:10:21 <Para_> so like __repr__ vs __str__ in pythn
19:10:34 <Twey> Para_: Something like that
19:10:39 <augur> i figure like loading pre-compiled haskell code ought to be trivial, if only we had proper modularity
19:10:41 <kazagistar> > show . M.singleton 2 5
19:10:42 <Lutin`> augur: Like hotloading?
19:10:43 <lambdabot>  Couldn't match expected type ‘a -> b0’
19:10:43 <lambdabot>              with actual type ‘Data.Map.Base.Map k0 a0’
19:10:51 <augur> ludflu: i need to have plugins
19:10:52 <kazagistar> er backwards
19:11:01 <Twey> Para_: Well, there is only __repr__ (Show)
19:11:09 <Lutin`> augur: Shared libraries?
19:11:28 <kazagistar> > show (M.singleton 2 5)
19:11:29 <Para_> __str__ is meant to be human-readable, and __repr__ machine readable though
19:11:29 <lambdabot>  "fromList [(2,5)]"
19:11:38 <Para_> isn't that sorta what it is?
19:11:46 <Para_> (machine readable as in valid python)
19:11:48 <Lutin`> Yes
19:11:50 <Twey> We don't have a built-in class for __str__; it depends on locale and how you want to pretty-print it and so forth, and is therefore split into a bunch of libraries
19:11:52 <augur> there is System.Plugins, this seems like the sensible route, since its a System submodule
19:11:55 <Para_> oh alright
19:12:23 <Lutin`> augur: Yeah it's written by dons so I'd check it out
19:13:18 <Twey> Para_: But print x is something like Python's print(repr(x)), and putStrLn x is like print(x)
19:13:31 <augur> Lutin`: what im looking for tho is something where the plugin conforms to a common interface
19:13:52 <Twey> __str__ is about converting to a pretty human-readable form; putStrLn is about printing without converting
19:15:01 <Para_> oh okay
19:15:08 <Para_> so they aren't exactly identical
19:15:15 <Para_> sweet, that makes it easier
19:17:26 <Para_> http://lpaste.net/105905
19:17:31 <Para_> I'm getting an error with that
19:17:34 <Para_> and its not at compile-time
19:18:19 <Twey> Para_: You passed it an argument that doesn't parse as a Float
19:18:20 <bms1> Para_: that should probably be "map read args"
19:18:29 <Twey> Er
19:18:32 <Twey> Yeah
19:18:39 <Twey> (how did that compile?)
19:19:01 <Para_> oh wait
19:19:04 <Para_> one second
19:19:06 <saml_> hey, i have three Ints x,y,z. where z <= x.   How can I make a list of x y's  and z of them are y+1?
19:19:08 <Para_> I might be compiling the wrong file
19:19:19 <Para_> I hate how moving stuff around on the terminal
19:19:29 <Para_> messes with stuff
19:19:33 <saml_> for example,  given 3,7,2  I want [7, 8, 8]
19:19:39 <bms1> Twey: Good question!
19:20:06 <bms1> Twey: List monad!?
19:20:21 <bms1> No, nevermind
19:20:22 <Twey> saml_: replicate (x - z) y ++ replicate z (y + 1)
19:20:31 <Twey> bms1: No, I think it just didn't compile.  :þ
19:20:35 <Para_> it didn't compile
19:20:38 <bms1> oh
19:20:41 <saml_> I got to replicate 3 7   :P
19:20:42 <Para_> the version that compiled
19:20:44 <Para_> was map read
19:21:22 <Para_> still gives me the error though
19:21:30 <Para_> and I gave it [3,4] as an argument
19:21:31 <Twey> Para_: What are the arguments you're parsing?
19:21:35 <Twey> There's your problem
19:21:36 <Para_> [3,4]
19:21:43 <Para_> hm
19:21:48 <bms1> Para_: command-line args are separated by spaces
19:21:53 <Para_> no no
19:21:56 <Para_> I want that to be one arg
19:22:00 <Para_> I want that to be a list of ints
19:22:04 <Twey> If you pass [3,4] then your argument list from getArgs is going to be ["[3,4]"]
19:22:34 <bms1> Para_: Maybe you want read (head args) then, to just look at the first command-line argument?
19:22:42 <Twey> You want parsed_args = read (head args) ∷ Float (or some better equivalent that does some kind of validation)
19:22:49 <Twey> Err
19:22:53 <Twey> You want parsed_args = read (head args) ∷ [Float] (or some better equivalent that does some kind of validation)
19:23:13 <Twey> Or, you can keep the code you currently have and run ‘./your_program 3 4’ instead
19:23:15 <saml_> is there zipWith that just returns longer list's elements as is?
19:23:32 <Twey> saml_: That wouldn't match the type
19:23:41 <Twey> :t zipWith
19:23:42 <lambdabot> (a -> b -> c) -> [a] -> [b] -> [c]
19:23:49 <Twey> a ≠ b ≠ c
19:23:52 <Para_> do I not need the map then?
19:23:53 <bms1> Twey: Well, if you restrict the types to all a's, it's okay
19:23:55 <saml_> > zipWith (+) [7,7,7] [1,1]   -- I want [8,8,7]
19:23:56 <lambdabot>  [8,8]
19:24:10 <Twey> Yep
19:24:12 <Para_> guess not
19:24:12 <saml_> ah i see
19:24:13 <Para_> :0
19:24:15 <Para_> :)
19:24:27 <Twey> saml_: You could use [1,1] ++ repeat 0
19:24:29 <Para_> awesome it works
19:24:42 <Twey> > zipWith (+) [7, 7, 7] $ [1, 1] ++ repeat 0
19:24:43 <lambdabot>  can't find file: L.hs
19:24:47 <Twey> > zipWith (+) [7, 7, 7] $ [1, 1] ++ repeat 0
19:24:48 <lambdabot>  [8,8,7]
19:25:09 <bms1> saml_: Not that I can think of; I think you should just define it yourself
19:25:13 <saml_> oh nice
19:25:31 <bms1> (Twey's solution will only work if one list is always shorter)
19:25:39 <Twey> Right
19:25:50 <Para_> thanks guys!
19:26:36 <saml_> what was bottom constant? wasn't there something like that?
19:26:44 <saml_>  > zipWith (+) [7, 7, 7] $ [1, 1, 1] ++ bottom
19:26:50 <saml_> > zipWith (+) [7, 7, 7] $ [1, 1, 1] ++ bottom
19:26:52 <lambdabot>  Not in scope: ‘bottom’
19:26:55 <Twey> zipWithExtras _ [] ys = ys; zipWithExtras _ xs [] = xs; zipWithExtras f (x : xs) (y : ys) = f x y : zipWithExtras f xs ys
19:27:02 <saml_> wanted to see if ++ gets evaluated or not
19:27:22 <Twey> > zipWith (+) [7, 7, 7] $ [1, 1, 1] ++ undefined
19:27:24 <lambdabot>  [8,8,8]
19:27:36 <saml_> ah thanks
19:28:19 <Twey> There are two: ‘undefined’ and ‘error’, which also lets you specify an error message
19:29:04 <saml_> oh type of zipWithExtras will be (a->a->a)->[a]->[a]->[a]
19:29:18 <Twey> > let zipWithExtras _ [] ys = ys; zipWithExtras _ xs [] = xs; zipWithExtras f (x : xs) (y : ys) = f x y : zipWithExtras f xs ys in zipWithExtras (+) [7, 7, 7] [1, 1]
19:29:19 <lambdabot>  [8,8,7]
19:42:53 <MP2E> How does one add Integer/Int to djinn? It just says 'Undefined type Integer' whenever I try to declare a simple datatype :s
19:43:17 <MP2E> (I typed in 'data PS = PS Integer' for reference)
19:44:26 <pavonia> Do you mean in lambdabot?
19:44:40 <MP2E> nah, I compiled the latest djinn from hackage with ghc 7.8.2
19:47:47 <MP2E> @djinn data PS = PS !Integer
19:47:47 <lambdabot> Cannot parse command
19:47:50 <MP2E> @djinn data PS = PS Integer
19:47:50 <lambdabot> Cannot parse command
19:48:06 <MP2E> hmm, *goes to read the manual*
19:49:32 <kristof> Question: does anyone know of a function that takes a "max-size" and returns a hash function optimized for that guesstimate of a hash table's capacity?
19:55:32 <MP2E> ohh djinn doesn't deal with specific types. Okay.
19:56:05 * hackagebot tagged-transformer 0.7 - Provides newtype wrappers for phantom types to avoid unsafely passing dummy arguments  http://hackage.haskell.org/package/tagged-transformer-0.7 (EdwardKmett)
20:03:52 <prototrout> funfunctor: Are you Applicative?
20:05:45 <MP2E> if we were to join two funfunctor's together, would they become one?
20:07:51 <funfunctor> yes I am
20:08:52 <kazagistar> what about an Alternative instance? could some ways of having fun fail?
20:09:29 <Axman6> funfunctor: so are you ap'py? =)
20:10:54 <funfunctor> kazagistar: youtube is full of fun fails.. type darwin
20:15:43 <QinGW> any framework support restful service?
20:23:35 <remy_d> Hey, I'm a 100% newbie - is there anyone here who might be willing to answer a simple question?
20:24:32 <remy_d> hello...?
20:24:44 <remy_d> well, anyway
20:24:52 <Welkin> just ask the question and someone might answer
20:24:56 <remy_d> I dont understand why I get an error when I do this
20:25:04 <remy_d> let x = 5
20:25:17 <remy_d> replicate (10 - x) '-'
20:25:30 <Welkin> paste your code in @lpaste
20:25:32 <Welkin> @lpaste
20:25:32 <lambdabot> Haskell pastebin: http://lpaste.net/
20:25:47 <Welkin> you need to use the keyword "in"
20:25:57 <Welkin> let x = 5 in x + 2
20:26:03 <remy_d> sorry I'm just running this in ghci
20:26:23 <remy_d> which seems to let me do "let" without "in"
20:26:35 <Welkin> let <variable> = <value> in <expr>
20:26:48 <luzie> works for me in ghci, what error do you get?
20:28:41 <remy_d> weird
20:28:50 <remy_d> if i do it with "in" it works
20:28:55 <Welkin> of course
20:29:31 <remy_d> I thought I could just assign stuff in GHCI with "let" and forget about "in"
20:29:35 <Welkin> there is no assignment
20:29:47 <Welkin> it is just a mathematical variable
20:29:54 <Welkin> it only exists within a statement
20:30:26 <Axman6> remy_d: you can yes
20:30:41 <Axman6> ghci is like one big IO do block
20:30:47 <Axman6> except when it's not
20:30:58 <remy_d> Ok, well the error I was getting was "Couldn't match expected type `Int' with actual type `Integer'"
20:31:03 <Welkin> yes
20:31:11 <Welkin> it inferred the type of your value as an Integer
20:31:15 <Axman6> remy_d: ah, x would have been defaulting to type Integer
20:31:19 <Welkin> not an Int
20:31:46 <Welkin> ghci does work a bit differently than compiled code
20:31:56 <Welkin> I would suggest compiling to test
20:32:03 <Axman6> > let x :: Integral a => a; x = 1 in  take x [1,2,3]
20:32:05 <lambdabot>  [1]
20:32:16 <Axman6> > let x :: Integral a => a; x = 1 in  (take x [1,2,3], x+x :: Integer)
20:32:18 <lambdabot>  ([1],2)
20:32:29 <Axman6> :o
20:32:39 <Welkin> :t replicate
20:32:41 <lambdabot> Int -> a -> [a]
20:32:47 <Welkin> replicate takes only an Int
20:33:01 <Axman6> my x is ALL Integral values =)
20:33:11 <Axman6> uh, types
20:33:55 <Axman6> > let x :: Integral a => a; x = 1 in  (take x [1,2,3], x+x :: Integer, x :: Word)
20:33:56 <lambdabot>  ([1],2,1)
20:34:11 <remy_d> Ok, I'm not sure I understood that
20:34:13 <remy_d> I did this
20:34:14 <remy_d> http://lpaste.net/105910
20:34:33 <Welkin> remy_d, replicate takes an Int
20:34:35 <Welkin> not an Integer
20:34:41 <kazagistar> Axman6: you mean this?
20:34:49 <Welkin> you must change your type declaratin to: Int -> String
20:34:50 <kazagistar> @hoogle genericReplicate
20:34:52 <lambdabot> Data.List genericReplicate :: Integral i => i -> a -> [a]
20:35:07 <remy_d> so if I do.... ((10 - x) :: Int)
20:35:30 <Axman6> :t let x = 1 in x
20:35:31 <lambdabot> Num a => a
20:36:03 <Axman6> bleh, I think ghci defaults more egearly to Integer
20:36:23 <Axman6> remy_d: anyway, you need to sat that x is an Int when declare it
20:36:26 <Axman6> say*
20:36:27 <remy_d> I'm doing the homework exercises for the yorgey lectures
20:36:35 <remy_d> so I can't change the type of the function
20:36:48 <remy_d> Is there some other way I can make it work?
20:36:50 <Welkin> then use genericReplicate from Data.List
20:37:03 <Welkin> typical homework assignments with arbitrary restrictions
20:37:11 <kazagistar> btw, it seems that stuff like primes :: Num a => [a] does not memoize
20:37:41 <remy_d> ahHA!
20:37:42 <remy_d> it works
20:37:48 <remy_d> thanks Welkin
20:37:54 <remy_d> genericReplicate
20:38:01 <Axman6> don't usew that >_<
20:38:06 <remy_d> no?
20:38:12 <Axman6> that is not the solution you should be using.
20:38:13 <Welkin> well, you could also just code your own version of replicate
20:38:22 <Welkin> like Axman6
20:38:25 <Axman6> you just need to define x to be an int: let x :: Int; x = 1
20:38:41 <kazagistar> if it is for homework and learning, then you should indeed code your own version, of everything possible :P
20:38:41 <Axman6> what? I didn't do anything like that...
20:39:08 <Welkin> @src replicate
20:39:08 <lambdabot> replicate n x = take n (repeat x)
20:39:19 <Welkin> just make a function replicate'
20:39:34 <remy_d> well, weirdly enough - in this homework exercise we are supposed to use Prelude functions instead of coding them ourselves
20:39:52 <Axman6> Welkin: I don't think that is good advice...
20:40:07 <Axman6> remy_d: did you try what I said?
20:40:54 <kazagistar> @let kreplicate n x = if x > 0 then x : kreplicate (n-1) x else []
20:40:58 <lambdabot>  Defined.
20:41:03 <kazagistar> :t kreplicate
20:41:04 <lambdabot> (Ord a, Num a1, Num a) => a1 -> a -> [a]
20:41:05 <remy_d> Axman, I tried - but I don't think I understand
20:41:12 <kazagistar> fail lol
20:41:21 <Axman6> what have you tried
20:41:35 <kazagistar> @undefine
20:41:35 <lambdabot> Undefined.
20:41:44 <Welkin> take and repeat are prelude functions...
20:41:44 <remy_d> I can't just go... myFn  x = let x :: Int in replicate (10 - x) '-'
20:41:46 <Hafydd> @undefine undefined
20:41:46 <lambdabot> There's currently no way to undefine just one thing.  Say @undefine (with no extra words) to undefine everything.
20:41:48 <kazagistar> @let kreplicate n x = if n > 0 then x : kreplicate (n-1) x else []
20:41:50 <lambdabot>  Defined.
20:41:54 <kazagistar> :t kreplicate
20:41:55 <lambdabot> (Ord a, Num a) => a -> a1 -> [a1]
20:42:04 <Axman6> remy_d: no, you need to also give it a value
20:42:20 <remy_d> but it already has a value?
20:42:32 <Axman6> remy_d: once something has a value you can't change its type
20:42:45 <remy_d> that makes sense
20:42:49 <Axman6> you're trying to say that after you define x, it should be of type Int, and you can't do that
20:43:01 <Axman6> so when you _define x_ you need to say what type it should be
20:43:05 <Axman6> because it can
20:43:20 <Axman6> can't predict the future and know you will want an Int, so it choses to make x an Integer
20:43:23 <remy_d> so... let x' = (x :: Int)
20:43:24 <remy_d> ?
20:43:28 <Axman6> which is not the same as an Int
20:43:29 <Axman6> no
20:43:37 <Axman6> that's trying to change the type of x still
20:43:44 <Axman6> you're in ghci right?
20:43:51 <remy_d> yep
20:43:53 <Axman6> if so, run :type x
20:44:08 <remy_d> Integer
20:44:15 <Axman6> right
20:44:30 <Axman6> you need to redefine x and make it an Int to make it work with replicate
20:44:33 <kazagistar> @hoogle Integer -> Int
20:44:35 <lambdabot> Data.Time.Calendar gregorianMonthLength :: Integer -> Int -> Int
20:44:36 <lambdabot> Data.Time.Calendar.Julian julianMonthLength :: Integer -> Int -> Int
20:44:36 <lambdabot> Language.Haskell.ParseUtils checkPrec :: Integer -> P Int
20:44:47 <remy_d> is there a way to copy x into a new variable y but with a different type?
20:44:51 <Axman6> I'm not sure why you're definint it at the top level though, that seems off
20:45:06 <Axman6> you can use fromIntegral, but there are bigger issues here
20:45:27 <kazagistar> fromIntegral (10 :: Integer) :: Int
20:45:37 <kazagistar> > fromIntegral (10 :: Integer) :: Int
20:45:40 <lambdabot>  10
20:45:46 <kazagistar> muhahahaha
20:45:56 <remy_d> this seems kind of weird
20:46:15 <remy_d> but I think there is a gap in my understanding
20:46:17 <Axman6> what do you mean?
20:46:23 <Axman6> yes, I think so too
20:46:34 <remy_d> fromIntegral (10 :: Integer) :: Int
20:46:38 <remy_d> it seems like a lot of work
20:46:46 <remy_d> to make replicate work with an Integer
20:46:57 <kazagistar> :t fromIntegral
20:46:58 <lambdabot> (Num b, Integral a) => a -> b
20:47:02 <Axman6> this isn't C, you can't arbitrarilly convert things between different types, you either need to make sure they're the right type to begin with, ot use a function to convert it to the type you need
20:47:16 <Axman6> remy_d: you don't want replicate to work with Integer though
20:47:21 <Axman6> just make x an Int >___<
20:47:22 <remy_d> and using genericReplicate is a bad idea?
20:47:49 <Axman6> it's completely unnecessary in this situation (and it's not a Prelude function like you've been asked to use)
20:48:25 <kazagistar> it converts from one type to another, and is paramitrized by input and output. so if it is already defined, it will figure it out
20:48:35 <remy_d> Just in case you're curious, these are the homework exercises: http://www.seas.upenn.edu/~cis194/hw/03-rec-poly.pdf
20:48:46 <remy_d> I'm doing the third one
20:50:18 <kazagistar> so why are you using replicate?
20:50:19 <Axman6> so where are you so far
20:50:43 <kazagistar> show us your code so we can critique it :P
20:50:44 <Axman6> kazagistar: because it's the obvious thing to use to make the histograms? :\
20:50:48 <remy_d> I'll paste it in the thing
20:53:27 <remy_d> http://lpaste.net/105911
20:53:38 <remy_d> The histogram thing doesn't work yet
20:53:49 <remy_d> I'm also not very good at this yet
20:54:28 <Welkin> have you read LYAH?
20:55:02 <kazagistar> Axman6: are you thinking something like this? unlines $ reverse $ transpose [replicate x '*' | x <- counts]
20:55:16 <Axman6> remy_d: personally I think the histogram would look better (and be way easier to write) if it were sideways not vertical
20:55:36 <remy_d> yes, I 'm planning to reverse the order of the bars
20:55:41 <Axman6> kazagistar: basically, but I think you'll need to mad each line before the reansposition
20:55:49 <remy_d> because otherwise they are going to be stalactites
20:55:54 <Welkin> you could construct the histogram horizontally then transpose it
20:56:24 <remy_d> transpose
20:56:31 <Axman6> > transpose ["**","*****","","","*"]
20:56:33 <lambdabot>  ["***","**","*","*","*"]
20:56:54 <Axman6> > text . unlines $ ["**","*****","","","*"]
20:56:56 <lambdabot>  **
20:56:56 <lambdabot>  *****
20:56:56 <lambdabot>  
20:56:56 <lambdabot>  *
20:57:05 <Axman6> > text . unlines . transpose $ ["**","*****","","","*"]
20:57:06 <lambdabot>  ***
20:57:07 <lambdabot>  **
20:57:07 <lambdabot>  *
20:57:07 <lambdabot>  *
20:57:07 <lambdabot>  *
20:57:19 <Axman6> yeah I don't think that's right
20:57:21 <remy_d> and then put a linebreak in between each "*"
20:57:34 <Axman6> > text . unlines . transpose $ ["**    ","*****","     ","     ","*    "]
20:57:36 <lambdabot>  **  *
20:57:36 <lambdabot>  **
20:57:36 <lambdabot>   *
20:57:36 <lambdabot>   *
20:57:36 <lambdabot>   *
20:59:33 <remy_d> Hey Axman6, thanks for your help
20:59:43 <remy_d> I'm going to take a break and try again later
20:59:45 <remy_d> cheers
21:00:58 <kazagistar> @let counted xs = map (\x -> length $ fiter (==x)  xs) [0..9]
21:01:00 <lambdabot>  .L.hs:149:35:
21:01:00 <lambdabot>      Not in scope: ‘fiter’
21:01:00 <lambdabot>      Perhaps you meant one of these:
21:01:00 <lambdabot>        ‘filter’ (imported from Data.List),
21:01:00 <lambdabot>        ‘BSC.filter’ (imported from Data.ByteString.Char8),
21:01:13 <kazagistar> @let counted xs = map (\x -> length $ filter (==x)  xs) [0..9]
21:01:14 <Axman6> remy_d: good luck
21:01:15 <lambdabot>  Defined.
21:03:13 <kazagistar> @djinn (a -> b) -> a -> (a, b)
21:03:13 <lambdabot> f a b = (b, a b)
21:03:46 <kazagistar> I really wish this was a standard function, I feel like I need it all the time
21:04:09 <augur> :(
21:04:10 <Axman6> something similar is particularly good for sorting too
21:04:14 <augur> noone knows the answer to my question :(
21:04:34 <Axman6> what was your question?
21:04:48 <augur> how do load plugins, constrained to use an interface
21:05:02 <Axman6> hsplugins?
21:06:30 <kazagistar> @let fab = \a b -> (b, a b)
21:06:32 <lambdabot>  Defined.
21:08:38 <augur> Axman6: quois
21:08:46 <gamegoblin> What do I need to put in my .cabal file to have haddock generated in the dist?
21:09:24 <augur> Axman6: oh, you mean the "plugins" package. i dont know how to use that to enforce interfaces
21:09:33 <augur> i should read dons' paper tho
21:10:18 <gamegoblin> I have a cabal package (library) and I want to upload it to hackage with haddocks. How do I do this?
21:10:34 <johnw> kazagistar: id &&& f
21:11:22 <kazagistar> :t id &&& f
21:11:24 <lambdabot> (FromExpr c', Show a) => a -> (a, c')
21:11:32 <johnw> :t (id &&&)
21:11:33 <lambdabot> (a -> c') -> a -> (a, c')
21:11:57 <kazagistar> :t &&&
21:11:58 <lambdabot> parse error on input ‘&&&’
21:12:00 <kazagistar> er
21:12:04 <johnw> :t (&&&)
21:12:05 <lambdabot> Arrow a => a b c -> a b c' -> a b (c, c')
21:12:05 <kazagistar> :t (&&&)
21:12:06 <lambdabot> Arrow a => a b c -> a b c' -> a b (c, c')
21:12:22 <kazagistar> ah, arrows, ill... get to learning about that eventually
21:12:34 <johnw> you don't need to know arrows, just a few combinators from that library
21:12:35 <zq> hm, either and Either curry-howard to disjunctive or
21:12:39 <johnw> first, second, &&&, ***
21:12:58 <Welkin> @src fmap
21:12:58 <lambdabot> Source not found. Whoa.
21:13:21 <zq> Welkin: fmap has no default implementation
21:13:26 <jle`>  kazagistar you don't need to know about Arrow to use (&&&)
21:14:09 <jle`> for the (->) instance it's literally just f &&& g = \x -> (f x, g x)
21:14:13 <luzie> :t (+2) &&& (+3)
21:14:15 <lambdabot> Num c' => c' -> (c', c')
21:14:53 <jle`> (&&&) takes a (a -> b) and a (c -> d) and gives you an ((a, c) -> (b, d))
21:14:55 <jle`> er
21:14:56 <jle`> sorry
21:15:06 <jle`> an (a -> b) and an (a -> c) and gives you an (a -> (b, c))
21:15:15 <jle`> for (->)
21:15:17 <kazagistar> gotcha
21:15:25 <Welkin> @src Data.Maybe.Maybe
21:15:25 <lambdabot> Source not found. Just try something else.
21:16:07 <kazagistar> @src (&&&)
21:16:07 <lambdabot> f &&& g = arr (\b -> (b,b)) >>> f *** g
21:16:28 <kazagistar> haha, how enlightening
21:16:51 <kazagistar> @src fold
21:16:52 <lambdabot> Source not found. You speak an infinite deal of nothing.
21:17:21 <kazagistar> so it has Arrow but is missing Foldable?
21:17:39 <kazagistar> @src index
21:17:39 <lambdabot> Source not found. You speak an infinite deal of nothing.
21:18:20 <kazagistar> @src inRange
21:18:20 <lambdabot> Source not found. Maybe you made a typo?
21:18:25 <lfairy> gamegoblin: try google "hackage custom doc upload". there's no built-in way to do it, but some dude posted a script that automates the process
21:18:59 <gamegoblin> lfairy: The last time I uploaded something to hackage, the docs never got generated. I don’t need custom docs per se, just the docs generated by “cabal haddock”
21:22:13 <lfairy> gamegoblin: did it fail because your package depends on a C library?
21:22:26 <gamegoblin> lfairy: my package has no dependencies except base
21:22:39 <lfairy> gamegoblin: okay, then you should message an admin to get it rebuilt
21:22:54 <gamegoblin> lfairy: I see… I’ll upload this version and see what happens.
21:23:02 <jle`> kazagistar: also useful is (***) which did what i wrote by accident before, f *** g = \(x, y) -> (f x, g y)
21:23:03 <gamegoblin> lfairy: That was a few months ago and they never got generated
21:23:10 <lfairy> gamegoblin: try #hackage or #haskell-infrastructure
21:25:53 <johnw> &&& splits a value into "this AND that"; *** applies two functions to a PRODUCT (aka tuple)
21:27:33 <Welkin> http://www.cs.nott.ac.uk/~nhn/FoPAD2007/Talks/nhn-FoPAD2007.pdf
21:27:42 <Welkin> that has a nice visualization
21:28:07 <Axman6> I was going to ask what lets you get back from (a,b) -> c but that's uncurry
21:31:14 <jle`> Axman6: :)
21:36:09 <eazar001> why is uncurry called uncurry
21:36:11 <eazar001> ?
21:36:13 * hackagebot JustParse 2.0 - A simple and comprehensive Haskell parsing library  http://hackage.haskell.org/package/JustParse-2.0 (grantslatton)
21:37:05 <jle`> eazar001: currying is the process of taking a function on (a, b) (returning c) and turning it into a function that takes an a and returns a function that takes a b which returns a c
21:37:18 <jle`> in types, currying is when you tak ean (a, b) -> c and turn it into an a -> (b -> c)
21:37:27 <jle`> :t curry
21:37:28 <lambdabot> ((a, b) -> c) -> a -> b -> c
21:37:38 <jle`> parentheses are implied but yeah
21:37:46 <eazar001> it looks like it's _currying_ to me
21:37:54 <eazar001> not uncurrying
21:37:56 <jle`> so "uncurrying" is taking an a -> (b -> c) and turnig it back into an (a, b) -> c
21:38:24 <jle`> in types, uncurry :: (a -> (b -> c)) -> ((a, b) -> c)
21:38:51 <jle`> the curried form is a -> (b -> c), and the uncurried/"normal in other languages" form is (a, b) -> c
21:38:52 <eazar001> i see ...
21:38:55 <eazar001> i get it now jle`
21:38:59 <eazar001> now it makes sense
21:39:04 <Welkin> @src (>>=)
21:39:04 <lambdabot> Source not found. I don't think I can be your friend on Facebook anymore.
21:39:30 <eazar001> i was looking at it from the perspective of the tuple (a, b)
21:40:09 <jle`> you might find x >>= f defined as join (fmap f x) in the future as a default implementation, when join goes into Monad
21:41:44 <Axman6> would someone mind saying something with some non-ascii text in it? (pretty quotes, lambdas or something)
21:41:52 <Welkin> I am trying to define fmap in terms of >>= and return (found in the source comments actually)
21:41:58 <Welkin> and join in terms of >>= and return
21:42:03 <eazar001> ²
21:42:13 <eazar001> is that pretty enough?
21:42:22 <Axman6> is that a superscript 2?
21:42:28 <eazar001> yes
21:42:35 <Axman6> then things are working =)
21:42:47 <Welkin> why isn't join in Monad anyway?
21:42:47 <eazar001> cool [=
21:42:51 <Axman6> seems that I have to tell tmux to turn off utf8 for utf8 to work...
21:42:56 <Axman6> thanks eazar001 =)
21:43:11 <eazar001> np, ....
21:43:13 <eazar001> but wait ...
21:43:20 <eazar001> that's is extended ASCII Axman6
21:43:24 <eazar001> Just to be aware
21:43:55 <Axman6> eh, All I could see in the past was _ whenever something non ascii showed up
21:44:12 <Welkin> 你好, Axman6
21:44:15 <jle`> Welkin: I don't think you need return for join, you only need (>>=) and a lambda
21:44:21 <eazar001> Welkin: , I can't see that
21:44:23 <jle`> or a fairly common function
21:44:26 <Axman6> Welkin: thanks, that worked fine
21:44:35 <eazar001> lol, how ironic
21:44:49 <Axman6> heh
21:44:52 <Axman6> which client?
21:44:56 <eazar001> weechat
21:45:11 <eazar001> weechat vanilla, i wrote a script for auto-sign in, that's it
21:45:18 <jle`> i can see it on weechat; it might be your terminal?
21:45:19 <Axman6> right
21:45:24 <eazar001> mmmm, xterm
21:45:30 <Axman6> I've been using irssi for years
21:45:43 <eazar001> that's a popular client
21:45:55 <eazar001> some actually use javascript chat clients these days
21:46:07 <Axman6> it's the one true client (and  it's going back into development!)
21:46:32 <luzie> there's a javascript client for weechat
21:46:36 <eazar001> hehhh, never even knew it went dark
21:48:04 <luzie> eazar001, https://github.com/glowing-bear/glowing-bear
21:49:15 <c74d> I see Welkin’s characters in WeeChat in tmux.
21:50:20 <kazagistar> @let histogram xs = let counts = [length (filter (==n)  xs) | n <- [0..9]] in unlines $  [[if x >= row then '*' else ' ' | x <- counts] | row <- reverse [1 .. maximum counts]] ++ ["==========", ['0'..'9']]
21:50:22 <lambdabot>  Defined.
21:50:26 <kazagistar> that was fun :P
21:50:40 <kazagistar> histogram [1,1,1,3]
21:50:46 <Welkin> histogram [2,4,7,30]
21:50:49 <kazagistar> > histogram [1,1,1,3]
21:50:50 <lambdabot>  " *        \n *        \n * *      \n==========\n0123456789\n"
21:50:51 <Welkin> > histogram [2,4,7,30]
21:50:53 <lambdabot>  "  * *  *  \n==========\n0123456789\n"
21:51:14 <kazagistar> it was built for that problem posted earlier
21:51:57 <Axman6> > text $ histogram [1,1,1,3]
21:51:58 <lambdabot>   *
21:51:58 <lambdabot>   *
21:51:58 <lambdabot>   * *
21:51:58 <lambdabot>  ==========
21:51:58 <lambdabot>  0123456789
21:53:02 <kazagistar> no transpose, no replicate were my personal constraints :D
21:54:13 <prototrout> > text . histogram . map (read . return) . filter isDigit $ show pi
21:54:15 <lambdabot>     * *   *
21:54:15 <lambdabot>   * * *   *
21:54:16 <lambdabot>   *********
21:54:16 <lambdabot>  ==========
21:54:16 <lambdabot>  0123456789
21:55:08 <kazagistar> pity my font is not monospaced
21:58:20 <kazagistar> hmm, I should port my generic fizzbuzz to haskell
22:00:56 <hunt> ive read a lot of people saying that record syntax is one of the primary things holding haskell back, and i can personally say that it does feele a little bit clunky to use comapred to the rest of the language
22:00:58 <hunt> so im wondering
22:01:02 <Welkin> how does this work?
22:01:03 <hunt> is anyone actually working on fixing it?
22:01:12 <Welkin> join x = x >>= id
22:01:22 <Welkin> id is not a function from a -> m a
22:01:25 <Welkin> but from a -> a
22:01:45 <prototrout> Welkin: It's also a function (m a -> m a)
22:01:45 <hunt> :t (>>=)
22:01:47 <lambdabot> Monad m => m a -> (a -> m b) -> m b
22:02:02 <hunt> Welkin: id the signature doesnt fit for >>= though
22:02:03 <prototrout> :t id :: Monad m => m a -> m a
22:02:04 <lambdabot> Monad m => m a -> m a
22:02:19 <bjornars> :t (>>= id)
22:02:19 <lambdabot> Monad m => m (m b) -> m b
22:02:31 <Welkin> but m a -> m a is not a -> a
22:02:37 <Welkin> er
22:02:40 <Welkin> but m a -> m a is not a -> m a
22:02:43 <hunt> ah ofc
22:02:58 <prototrout> Welkin: No but it's a specialization of (a -> m b) which is what (>>=) asks for
22:03:04 <prototrout> (where a = m b)
22:03:41 <hunt> Welkin: if id is called upon a type m b, it appears to the outer monad, m x (x :: m b), that id :: x -> m b
22:04:13 <Welkin> that is nice
22:04:28 <Welkin> I'm working through the typeclassopedia exercises
22:04:35 <johnw> I just did one of those today too
22:04:55 <hunt> somebody though, whats the deal with record syntax?
22:05:06 <hunt> is anyone working on improving it for a future ghc?
22:05:12 <nisstyre> hunt: are you jerry seinfeld?
22:05:18 <hunt> nisstyre: lol
22:05:24 <hunt> nisstyre: im not sure
22:05:35 <johnw> let's just say you could google for this...
22:05:36 <hunt> id hunt
22:06:01 <hunt> johnw: how would i google for this
22:06:13 <hunt> johnw: "is anybody wokring on fixing haskell record syntax" ?
22:06:17 <johnw> sure
22:06:21 <prototrout> "record syntax proposal haskell" or something?
22:06:24 <Welkin> isn't that what lens i for?
22:06:26 <hunt> is there one?
22:06:30 <johnw> there are many
22:06:38 <hunt> johnw: so whats current
22:06:41 <nisstyre> hunt: refer to this image http://whatsthedealwith.info/images/seinfeld.jpg
22:06:45 <hunt> is there anything thats being taken seriously
22:06:54 <johnw> dunno, I don't care enough to follow them
22:07:03 <hunt> anyone else?
22:07:08 <hunt> nisstyre: holy shit, that is me
22:07:16 <jle`> i am become monad
22:07:27 <Welkin> ask siri
22:07:27 <edwardk> hunt, johnw: the "ORF" work that gundry hacked on should go in for 7.10
22:07:41 <pingu> hunt: https://ghc.haskell.org/trac/ghc/wiki/Records
22:08:25 <edwardk> hunt: https://skillsmatter.com/skillscasts/5225-overloaded-record-fields-for-haskell is a talk on what has happened, how it works, and where it is going.
22:09:01 <hunt> edwardk: pingu awesome thanks, edwardk how does this stuff effect the value of lenses?
22:09:33 <johnw> they will work together
22:09:38 <edwardk> hunt: other lens libs get to use the field accessors directly _as_ lenses, so fclabels, data-lens, etc. just get better.
22:09:56 <edwardk> with lens you can use the ORF style field accessors with a combinator and get type-changing assignment
22:10:26 <edwardk> but you may still prefer to use classy lenses, etc. to get types that don't suck and to logically group things
22:13:16 <ion> edwardk: Thanks, i had missed it.
22:15:13 <kazagistar> ok, inspired by my horrible histogram 1liner, I decided to port my favorite python 1 liner that I created to haskell
22:15:22 <kazagistar> @let fbg s l u=unlines[case concat[w|(w,c)<-s,mod i c==0]of[]->show i;m->m|i<-[l..u]]
22:15:23 <lambdabot>  Defined.
22:16:19 <kazagistar> @let fizzbuzz = fbg [("Fizz",3),("Buzz",5)] 1 100
22:16:21 <lambdabot>  Defined.
22:16:30 <hunt> :t error
22:16:31 <lambdabot> [Char] -> a
22:16:37 <hunt> a?
22:16:51 <kazagistar> hunt: anything
22:16:59 <hunt> right that makes
22:17:00 <hunt> sense
22:17:07 <hunt> so you can actyually call it anywhere
22:17:14 <kazagistar> hunt: it can return whatever type you want it to, because it wont actually ever return
22:17:20 <hunt> its magic right?
22:17:37 <luzie> @src error
22:17:37 <lambdabot> error s = throw (ErrorCall s)
22:17:54 <luzie> @src throw
22:17:54 <lambdabot> throw exception = raise# exception
22:18:22 <kazagistar> @src raise#
22:18:22 <lambdabot> Source not found. You type like i drive.
22:18:24 <jebes> going down the rabbit hole, are we?
22:18:28 <kazagistar> yeah, I thought so
22:18:50 <kazagistar> # means it is part of the low level ghc stuff
22:18:58 <kazagistar> :t raise#
22:18:59 <lambdabot> Not in scope: ‘raise#’
22:19:12 <kazagistar> oh well
22:19:17 <kazagistar> > fizzbuzz
22:19:19 <lambdabot>  "1\n2\nFizz\n4\nBuzz\nFizz\n7\n8\nFizz\nBuzz\n11\nFizz\n13\n14\nFizzBuzz\n16...
22:20:02 <kazagistar> so if anyone ever asks that on an interview, I have the perfect answer to make their head hurt :P
22:20:28 <Welkin> write a haskell compiler in brainfuck
22:21:44 <kazagistar> I am not sure I feel up to the task of writing a haskell compiler in anything yet
22:22:31 <pepper_chico> some usage of brackets and other special operators in haskell sometimes recalls brainfuck
22:22:40 <kazagistar> hmm, I wonder...
22:22:46 <kazagistar> @src fbg
22:22:47 <lambdabot> Source not found.
22:24:43 * kazagistar shrugs
22:25:39 <hunt> :t fbg
22:25:40 <lambdabot> (Show a, Integral a) => [([Char], a)] -> a -> a -> String
22:26:11 <hunt> why does it take a -> a
22:26:15 <hunt> i could see it taking just a
22:26:20 <hunt> what does it do i mean
22:26:47 <kazagistar> it is generic fizzbuzz
22:26:55 <kazagistar> first one is minimum, second is maximum
22:27:01 <kazagistar> fbg s l u=unlines[case concat[w|(w,c)<-s,mod i c==0]of[]->show i;m->m|i<-[l..u]]
22:27:19 <kazagistar> it might be more clear if it was like...
22:27:28 <Axman6> Welkin: not a brainfuck compiler in haskell? that's much easier...
22:27:50 <kazagistar> @undefine
22:27:50 <lambdabot> Undefined.
22:27:58 <kazagistar> @let fbg s (l,u)=unlines[case concat[w|(w,c)<-s,mod i c==0]of[]->show i;m->m|i<-[l..u]]
22:28:00 <lambdabot>  Defined.
22:28:05 <kazagistar> :t fbg
22:28:07 <lambdabot> (Show a, Integral a) => [([Char], a)] -> (a, a) -> String
22:28:43 <hunt> :t fizzbuzz
22:28:44 <lambdabot> Not in scope: ‘fizzbuzz’
22:28:50 <hunt> > fizzbuzz
22:28:52 <lambdabot>  Not in scope: ‘fizzbuzz’
22:29:04 <kazagistar> @let fizzbuzz = fbg [("Fizz", 3),("Buzz",5)] (1,100)
22:29:06 <lambdabot>  Defined.
22:29:08 <hunt> why did it work for you
22:29:10 <kazagistar> I undefined it
22:29:13 <hunt> > fizzbuzz
22:29:14 <lambdabot>  "1\n2\nFizz\n4\nBuzz\nFizz\n7\n8\nFizz\nBuzz\n11\nFizz\n13\n14\nFizzBuzz\n16...
22:30:47 <hunt> @let (+) a b = a - b
22:30:49 <lambdabot>  Defined.
22:30:54 <hunt> > 1 + 2
22:30:55 <lambdabot>  Ambiguous occurrence ‘+’
22:30:55 <lambdabot>  It could refer to either ‘L.+’, defined at L.hs:156:3
22:30:55 <lambdabot>                        or ‘GHC.Num.+’,
22:30:55 <lambdabot>                           imported from ‘Prelude’ at L.hs:34:8
22:30:55 <lambdabot>                           (and originally defined in ‘base:GHC.Num’)
22:31:09 <Axman6> @undefine
22:31:10 <lambdabot> Undefined.
22:31:18 <hunt> what did it undefine? everything?
22:31:18 <kazagistar> :t fizzbuzz
22:31:19 <lambdabot> Not in scope: ‘fizzbuzz’
22:31:22 <kazagistar> yeah
22:31:34 <kazagistar> global state lol
22:31:41 <kazagistar> well done lambdabot
22:31:45 <kazagistar> :P
22:32:05 <hunt> there must be some way to break lambdabot
22:32:09 <Axman6> all @lets
22:32:17 <hunt> :browse
22:32:53 <Axman6> lambdabot isn't ghci, it just does some stuff the same
22:32:59 <hunt> @let a Prelude.+ b = a - b
22:32:59 <lambdabot>  Parse failed: Parse error in pattern:
22:33:37 <hunt> can we do io?
22:34:59 <krax_> is this the right place to ask for help?
22:35:08 <Welkin> krax_, no
22:35:18 <Welkin> you are obviously beyond help
22:35:44 <krax_> :/ k.
22:35:46 <Welkin> just ask a question
22:35:55 <Welkin> don't ask if you can ask
22:36:18 * hackagebot blank-canvas 0.4.0 - HTML5 Canvas Graphics Library  http://hackage.haskell.org/package/blank-canvas-0.4.0 (AndyGill)
22:36:30 <hunt> so whats your favorite source file from ghc
22:36:50 <hunt> Welkin: you drove him away
22:36:55 <hunt> Welkin: you bastard
22:36:55 <Welkin> hm
22:37:00 <Welkin> must not have a sense of humor
22:37:25 <bjornars> hunt: Makefile
22:37:45 <Welkin> not Base?
22:37:48 <hunt> bjornars: very tasteful
22:37:49 <xenocons> win 12
22:45:30 <ion> lose 13
22:49:44 <ninegrid> are you sure you want to lose 13?
22:49:50 <Welkin> :t (***)
22:49:51 <lambdabot> Arrow a => a b c -> a b' c' -> a (b, b') (c, c')
22:53:12 <augur> hmm
22:53:33 <augur> ok, who's a System.Plugins pro?
23:16:06 <haasn> “when (isJust i) $ putStrLn (show (fromJust i))” this is just.. wrong
23:16:18 <haasn> Somebody needs to immediately fix plugins' documentation
23:16:32 <haasn> mapM_ print i
23:19:13 <jle`> haasn: where did you find that monster?
23:21:38 <jle`> is there a built in case x of Nothing -> mzero; Just y -> return y ?
23:22:34 <jle`> MonadPlus m => Maybe a -> m a
23:22:38 <jle`> i could probably hoogle that
23:22:43 <jle`> @hoogle MonadPlus m => Maybe a -> m a
23:22:45 <lambdabot> Control.Monad mfilter :: MonadPlus m => (a -> Bool) -> m a -> m a
23:22:45 <lambdabot> Control.Monad mplus :: MonadPlus m => m a -> m a -> m a
23:22:45 <lambdabot> Control.Monad msum :: MonadPlus m => [m a] -> m a
23:22:55 <jle`> sad day
23:23:30 <jle`> i could do ...
23:23:45 <jle`> (*>) <$> (guard . isJust) <*> (return . fromJust)
23:23:50 <jle`> yes that is definitely a good idea to do.
23:24:43 <jle`> :t (>>) <$> (guard . isJust) <*> (return . fromJust)
23:24:44 <lambdabot> MonadPlus m => Maybe b -> m b
23:24:48 <dfeuer> jle`, that is disgusting.
23:24:52 <jle`> ;D
23:25:07 <lfairy> jle`: maybe mzero return
23:25:12 <lfairy> seriously
23:25:12 <jle`> :O
23:25:16 <jle`> i feel dumb now
23:25:26 <jle`> but still i would hope there would be a built-in :/
23:25:40 <lfairy> we all have our bad days ;)
23:26:10 <jle`> to justify myself, i was trying to make a purposefully repulsive solution >_>  yes. that was it.
23:26:18 <gamegoblin> Does hlint have anything to say about that?
23:26:18 <lfairy> of course
23:26:41 <lfairy> on that topic - foldMap on Maybe is awesomesauce
23:29:00 <jle`> foldMap f = maybe mempty f ?
23:29:18 <Axman6> :t foldMap
23:29:19 <lambdabot> (Monoid m, Foldable t) => (a -> m) -> t a -> m
23:29:39 <Axman6> :t foldMap `asAppliedTo` (Just "Hello")
23:29:40 <lambdabot>     Couldn't match expected type ‘a -> m’
23:29:40 <lambdabot>                 with actual type ‘Maybe [Char]’
23:29:40 <lambdabot>     Possible cause: ‘Just’ is applied to too many arguments
23:29:50 <jle`> :t flip foldMap `asAppliedTo` Nothing
23:29:50 <lambdabot> Monoid c => Maybe a -> (a -> c) -> c
23:30:02 <Axman6> :t (\t f -> foldMap f) `asAppliedTo` (Just "Hello")
23:30:03 <lambdabot> (Monoid m, Foldable t) => Maybe [Char] -> (a -> m) -> t a -> m
23:30:30 <ion> :t foldMap `asTypeIn` \foldMap -> foldMap undefined (Just "Hello")
23:30:30 <Axman6> :t (\t f -> foldMap f t) `asAppliedTo` (Just "Hello")
23:30:31 <lambdabot> Monoid m => Maybe [Char] -> ([Char] -> m) -> m
23:30:31 <lambdabot> Monoid b => ([Char] -> b) -> Maybe [Char] -> b
23:30:42 <jle`> yall can just use Nothing man
23:30:49 <jle`>  /woman
23:36:05 <pingu> what is this asAppliedTo magic?
23:36:19 <Axman6> :t asAppliedTo
23:36:19 <Welkin> :t asAppliedTo
23:36:19 <lambdabot> (a -> b) -> a -> a -> b
23:36:20 <lambdabot> (a -> b) -> a -> a -> b
23:36:31 <Axman6> I think it's just const
23:36:36 <pingu> Right but what's it part of? hoogle doesn't find it
23:36:44 <Axman6> :t const :: (a -> b) -> a -> a -> b
23:36:45 <lambdabot> (a -> b) -> a -> a -> b
23:36:46 <Welkin> @asAppliedTo
23:36:46 <lambdabot> Unknown command, try @list
23:36:50 <Welkin> @src asAppliedTo
23:36:50 <lambdabot> Source not found. It can only be attributed to human error.
23:36:57 <Axman6> @hoogle asAppliedTo
23:36:59 <lambdabot> No results found
23:37:02 <Welkin> @info asAppliedTo
23:37:02 <lambdabot> asAppliedTo
23:37:08 <Welkin> okay...
23:37:10 <haasn> asAppliedto = const
23:37:14 <haasn> oh, Axman6 said this
23:37:23 <ion> asTypeIn :: a -> (a -> b) -> a ; a `asTypeIn` f = a where { _ = f a } ; infixl 0 `asTypeIn`
23:37:24 <Axman6> it's all just type trickery
23:37:25 <ion> asAppliedTo :: (a -> b) -> a -> a -> b ; f `asAppliedTo` x = f `asTypeIn` ($ x) ; infixl 0 `asAppliedTo
23:38:06 <haasn> (Is that really necessary, as opposed to a `asTypeIn` _ = a?)
23:38:44 <ion> It’s redundant, but i like that the implementation also works without the type signature.
23:40:37 <jle`> pingu: it might be just convenient stuff for lambdabot
23:41:24 <WraithM> Since GHC 7.8, I haven't gotten full error messages in stdout (in a sandbox). Cabal logs to some file in the sandbox folder. Is there any setting to get it to spit out error messages again?
23:55:49 <MP2E> WraithM : go to .cabal/config and uncomment Verbose: 1
