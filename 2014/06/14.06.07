00:09:06 * hackagebot handle-like 0.0.0.3 - HandleLike class  http://hackage.haskell.org/package/handle-like-0.0.0.3 (YoshikuniJujo)
00:09:06 * hackagebot monomorphic 0.0.3.2 - Library to convert polymorphic datatypes to/from its monomorphic represetation  http://hackage.haskell.org/package/monomorphic-0.0.3.2 (HiromiIshii)
00:19:02 * hackagebot rest-wai 0.1.0.0 - Rest driver for WAI applications.  http://hackage.haskell.org/package/rest-wai-0.1.0.0 (SebastiaanVisser)
00:23:16 <roa_> Hi. I want to define this Graph class that takes a vertex type as argument. How would i go about expressing a function as: connect :: vertex -> vertex -> graph -> graph? The problem is that i need to say that the type of vertex is the same type as the one used in graph instance.
00:27:56 <ion> Functional dependencies or associated type synonyms perhaps?
00:30:22 <roa_> ion: thanks. i am just starting with haskell, and thought i am thinking in a 'java' way while missing the obvious, simple solution to this problem.
00:30:44 <ion> Are you sure you need a type class in the first place?
00:30:54 <roa_> ion: yeah. that is what i am thinking now :)
00:31:00 <ion> Would a graph data structure suffice?
00:31:46 <roa_> i have 2 representations for it. a vertex adj. list and a edges adj. list. it made some sense using a type class to define a interface for them.
00:32:22 <bennofs> roa_: maybe just make the type class take an argument of type * -> *?
00:32:46 <bennofs> roa_: so class Graph graph where connect  :: vertex -> vertex -> graph vertex -> graph vertex
00:33:00 <bennofs> s/type/kind
00:33:22 <roa_> bennofs: that means using a multi-parameter type class. correct?
00:33:59 <ion> no
00:34:04 <bennofs> roa_: no. this is just like class Functor f where fmap :: (a -> b) -> f a -> f b  , which also requires no multi-parameter type class
00:34:40 <ocharles> Hey dreixel_ - I think my branch is ready for you to review now
00:34:54 <ocharles> dreixel_: shall I change it's status to patch?
00:35:23 <roa_> bennofs: that is nice but it does not express a type dependency between a,b and f. in my case i want the vertex type to be the same type used for the graph.
00:35:52 <bennofs> roa_: so class Graph graph where connect  :: vertex -> vertex -> graph vertex -> graph vertex   --- the 'graph type' is 'graph vertex
00:36:06 <bennofs> so it forces the graph to have vertices of the given type.
00:38:13 <roa_> bennofs: how would you write a class definition for that?
00:38:54 <roa_> bennofs: [class Graph g where connect :: v -> v -> g -> g] is what i have now
00:39:53 <roa_> bennofs: i got it i think :)
00:40:03 <roa_> bennofs: s/g/g v
00:43:40 <bluebelle> hello, can somebody help me with this function? I keep getting type error on x and y http://lpaste.net/105230
00:46:13 <Cale> bluebelle: Based on head x * head y, it seems like x and y are both supposed to be lists of numbers, but based on x : y, we can tell that y had better be a list of lists (since we're adding the list x to the beginning of it)
00:46:37 <Cale> You should also avoid using null together with head or tail
00:47:07 <Cale> (pattern matching using case is generally much better)
00:53:58 <roa_> bennofs: thanks for the help. i figured it out :)
00:55:51 <jle`> bluebelle: why (|>) ? :)
00:57:48 <enthropy> if I have (data Type = Apply Type Type | ...), and pType :: Parser Type, is there a way to avoid the error of   Apply <$> pType <*> pType?
00:57:57 <enthropy> which has an infinite loop it seems
00:59:02 <bluebelle> jle` : yes, some people might like dot map in the end. I prefer to use pipe since map is very short
00:59:37 <enthropy> I mean "a way to make that error show up at compile time, rather than at runtime"
01:01:27 <dmj`> > groupBy (\x y -> if x < 0 && y < 0 || x > 0 && y > 0 then True else False) [1,2,-1,-2,3,-4]
01:01:29 <lambdabot>  [[1,2],[-1,-2],[3],[-4]]
01:02:30 <dmj`> bluebell: ^
01:02:53 <jle`> um
01:03:04 <jle`> if x then True else False? :P
01:03:40 <enthropy> that happens to everybody
01:03:55 <dmj`> what's a better way
01:03:59 <enthropy> id $ x
01:04:10 <jle`> > if 5 > 3 then True else False
01:04:11 <lambdabot>  True
01:04:13 <jle`> > 5 > 3
01:04:15 <lambdabot>  True
01:04:26 <bluebelle> dmj: thanks, though I'm not sure if I can use groupBy (this is from an exam paper, and the prof. does not specifically mention groupBy as allowed functions)
01:04:28 <dmj`> oh yea :)
01:04:37 <jle`> it does literally happen to everybody though heh
01:04:44 <dmj`> @src groupBy
01:04:45 <lambdabot> groupBy _  []       =  []
01:04:45 <lambdabot> groupBy eq (x:xs)   =  (x:ys) : groupBy eq zs
01:04:45 <lambdabot>     where (ys,zs) = span (eq x) xs
01:05:00 <jle`> @src span
01:05:00 <lambdabot> span _ xs@[]                     =  (xs, xs)
01:05:00 <lambdabot> span p xs@(x:xs') | p x          =  let (ys,zs) = span p xs' in (x:ys,zs)
01:05:00 <lambdabot>                   | otherwise    =  ([],xs)
01:05:37 <dmj`> > groupBy (\x y -> if x < 0 && y < 0 || x > 0 && y > 0) [1,2,-1,-2,3,-4, 9,9,9, -9,-9,9,-9]
01:05:39 <lambdabot>  <hint>:1:53: parse error on input â€˜)â€™
01:05:56 <dmj`> > groupBy (\x y -> x < 0 && y < 0 || x > 0 && y > 0) [1,2,-1,-2,3,-4, 9,9,9, -9,-9,9,-9]
01:05:57 <lambdabot>  [[1,2],[-1,-2],[3],[-4],[9,9,9],[-9,-9],[9],[-9]]
01:06:39 <pavonia> enthropy: You have a left-recursive parser?
01:06:41 <exicer> I can't work out how to use system.path.glob. I have a sub directory called data, and want to extract the filepath to all *.html files that live in data. How can I do so ?
01:07:21 <enthropy> pavonia: I want to find out about the mistake earlier
01:07:39 <enthropy> if I use happy it has a warning/error I think
01:08:04 <jle`> hm
01:08:20 <jle`> testing if they're both negative is like testing if their product is positive
01:09:11 <pavonia> enthropy: Can't you use a different Type for the first parameter? TypeFunc or something that needs extra functions to be converted from a Type?
01:09:24 <jle`> *testing if their sign is the same
01:09:59 <jle`> hm
01:10:00 <enthropy> possibly. But the AST I'm writing into is the one in template-haskell so that'd be another translation
01:10:05 <jle`> or you can compare their signums
01:10:07 * enthropy is aware of haskell-src-meta
01:10:39 <jle`> signum x == signum y
01:10:46 <jle`> x*y > 0
01:11:28 <pavonia> jle`: But that means they can both be positive too
01:11:46 <jle`> pavonia: yeah it's just checking if their signs match
01:11:55 <jle`> yeah i corrected myself >.<
01:19:08 * hackagebot type-natural 0.2.1.1 - Type-level natural and proofs of their properties.  http://hackage.haskell.org/package/type-natural-0.2.1.1 (HiromiIshii)
01:21:51 <bluebelle> thanks guys, fixed it
01:22:19 <jle`> bluebelle: congrats :)
01:31:54 <solidus-river> how do i convert from an Int64 to an Int
01:32:36 <jle`> solidus-river: is Int64 an Integral?
01:32:40 <jle`> then you can do fromIntegral
01:33:26 <dmj`> > maxBound :: Int
01:33:27 <lambdabot>  9223372036854775807
01:33:33 <dmj`> > maxBound :: Int64
01:33:35 <lambdabot>  9223372036854775807
01:34:06 <dmj`> solidus-river: are you on a 64-bit machine
01:34:21 <dmj`> isn't Int platform dependent
01:35:12 <solidus-river> dmj`: not sure, using a database library that returns Int64 for the number of rows affected but i want to convert it to Int to comply with a Class
01:35:29 <solidus-river> but i guess i could just say that that function of the class returns a num, integral
01:35:40 <solidus-river> actually thats probably better
01:36:08 <darthdeus> guys, how can I add directories to the import directory list (-i) when doing C-c C-l in emacs' haskell-mode?
01:39:17 <dmj`> darthdeus: maybe try adding them to your .ghci file, depends on what haskell-mode you're using I think, interactive-mode vs. inferior
01:39:22 <dmj`> https://github.com/haskell/haskell-mode/wiki
01:39:57 <darthdeus> dmj`: oh cool, I didn't know there were two modes
01:40:06 <darthdeus> could you point me to something about .ghci too? :)
01:40:50 <dmj`> http://www.haskell.org/ghc/docs/latest/html/users_guide/ghci-dot-files.html
01:41:02 <darthdeus> thanks!
01:41:05 <dmj`> np
01:41:45 <dmj`> this too: http://dev.stephendiehl.com/hask/#ghci
01:47:19 <bitemyapp> dmj`: that whole FAQ is godly.
01:49:47 <dmj`> bitemyapp: yea
01:59:14 * hackagebot simple-conduit 0.0.1 - A simple streaming library based on composing monadic folds.  http://hackage.haskell.org/package/simple-conduit-0.0.1 (JohnWiegley)
02:03:20 <Guest89452> @pl f = (\x -> read x :: Int)
02:03:20 <lambdabot> f = (:: Int) . read
02:03:41 <dmj`> anyone ever seen this, "forkOS_entry: interrupted" before?
02:09:15 * hackagebot fuzzcheck 0.1.1 - A simple checker for stress testing monadic code  http://hackage.haskell.org/package/fuzzcheck-0.1.1 (JohnWiegley)
02:12:27 <Guest89452> @pl f = (\x -> read x :: Int)
02:12:27 <lambdabot> f = (:: Int) . read
02:16:45 <haasn> wait what
02:16:49 <haasn> :t (:: Int)
02:16:51 <lambdabot> parse error on input â€˜::â€™
02:16:59 <haasn> I think @pl thinks :: is an operator
02:17:06 <haasn> This is why I wonder why people use @pl so much
02:24:03 <pavonia> @pl \x -> x x
02:24:03 <lambdabot> join id
02:24:15 <pavonia> :t join id
02:24:16 <lambdabot>     Occurs check: cannot construct the infinite type: a1 ~ a1 -> a
02:24:17 <lambdabot>     Expected type: a1 -> a1 -> a
02:24:17 <lambdabot>       Actual type: a1 -> a1
02:30:23 <jle`> haasn: haha
02:37:00 <jle`> what's the best way to print a floating rounded to x digits
02:37:03 <jle`> printf?
02:43:02 <johnw> the "best" would be the "rounded" library that edwardk and copumpkin are working on
02:43:10 <johnw> next best I'd say is the "numbers" library and the CReal type
02:43:12 <pavonia> jle`: Numeric also has several functions
02:43:25 <johnw> (rounded is basically a type-safe wrapper around MPFR, btw)
02:44:09 <jle`> oh i was just looking at rounded actually, but for a different purpose
02:44:13 <jle`> how funny
02:44:54 <jle`> i'll look into Numeric because it's an already installed package for some reason
02:46:10 <pavonia> It's in base
02:49:19 * hackagebot simple-conduit 0.0.2 - A simple streaming library based on composing monadic folds.  http://hackage.haskell.org/package/simple-conduit-0.0.2 (JohnWiegley)
02:50:43 <jle`> pavonia: ah, that'll explain it
02:51:03 <bitemyapp> pavonia: you should check out simple-conduit :)
02:51:05 <bitemyapp> errr
02:51:07 <bitemyapp> jle`: ^^
02:51:41 <jle`> bitemyapp: in relation to my question?
02:52:19 <bitemyapp> jle`: no I just think it's awesome.
02:52:27 <bitemyapp> jle`: sorry :)
02:52:30 <dmj`> does the performance hit of profiling occur when the program is run w/ profiling flags? Or does having the profiling libs installed affect performance w/ or w/o them
02:54:59 <reirob> hello Haskell folks
02:55:40 <matematikaadit> hi reirob
02:55:41 <reirob> I come here because I am stuck with a problem that seems trivial but after hours of googling I could not find an answer
02:55:54 <reirob> data MyTypeT = String | Int
02:56:05 <reirob> is allowed, right?
02:56:07 <bitemyapp> reirob: you need a value constructor mate.
02:56:10 <bitemyapp> reirob: no, not really.
02:56:12 <jle`> umm
02:56:16 <jle`> does it shadow?
02:56:23 <reirob> But GHC compiles it and in GHCI it seems to pass
02:56:27 <jle`> it's allowed
02:56:28 <bitemyapp> reirob: you probably meant String and Int to be types.
02:56:29 <pranz1> reirob: MyTypeT = MtString String | MyInt Int
02:56:30 <reirob> what do you mean by shadow?
02:56:30 <pranz1> is valid
02:56:31 <bitemyapp> reirob: not value constructors.
02:56:47 <jle`> it's like when you say length x = 4 * x
02:56:58 <bitemyapp> reirob: you created nullary value constructors out of type constructors because you didn't understand the separation between types and terms
02:57:02 <shachaf> There is no shadowing going on.
02:57:09 <jle`> oh wait yeah
02:57:11 <jle`> darn
02:57:12 <bitemyapp> jle`: no shadowing
02:57:14 <jle`> v.v
02:57:16 <jle`> right
02:57:17 <bitemyapp> reirob: what are you using to learn Haskell?
02:57:22 <shachaf> reirob: "data MyTypeT = String | Int" is like "data Bool = False | True"
02:57:36 <shachaf> You're defining new *values* called "String" and "Int".
02:57:38 <reirob> well, i went to a big part through rwh
02:57:39 <sipa> bitemyapp: the problem is that the two cases that constitute the type MyTypeT must have their own name
02:57:46 <bitemyapp> reirob: Bool is a type constructor, False and True are value constructors.
02:57:46 <shachaf> They have nothing to do with the types that happen to have the same name.
02:58:04 <sipa> bitemyapp: it's not just one type or another; it's either case A with type B or case C with type D
02:58:17 <reirob> i got into this problem when I started to build a parser for a legacy language
02:58:25 <sipa> oh, reirob ^
02:58:27 <sipa> sorry!
02:59:09 <reirob> so I have data RteGlobalStatementT = RteCommentT
02:59:09 <reirob>                          | RteAssignment RteVarNameT RteExprT
02:59:09 <reirob>                  deriving (Eq, Ord, Show)
02:59:21 <reirob> where RteCommentT is
02:59:28 <reirob> data RteCommentT = RteComment String
02:59:28 <reirob>                  deriving (Eq, Ord, Show)
03:00:02 <sipa> reirob: the syntax is: data <new type name> = <new value name> <type1> <type2...> | <new value name> <type3> ...
03:00:12 <reirob> An the problem is when I have functions that return a type of RteCommentT I want them to wrap in to RteClobalStatementT
03:00:27 <bitemyapp> reirob: RteCommentT, if that's all of it, could be newtyped
03:00:40 <bitemyapp> reirob: and the T at the end is unnecessary, type constructors and value constructors are separate spaces.
03:00:52 <bitemyapp> RteComment can exist in the type and value space.
03:00:56 <bitemyapp> simultaneously.
03:01:06 <matematikaadit> @lpaste
03:01:07 <lambdabot> Haskell pastebin: http://lpaste.net/
03:01:09 <reirob> well, if I do not use T at the end then I often get Multiple definition errors
03:01:11 <bitemyapp> > data Blah = Blah Int deriving (Eq, Show); print $ Blah 10
03:01:13 <lambdabot>  <hint>:1:1: parse error on input â€˜dataâ€™
03:01:19 <bitemyapp> dammit lambdabot.
03:01:26 <sipa> reirob: you're defining two constructors with the name RteComment
03:01:29 <bitemyapp> assume the example works, because it does.
03:01:34 <sipa> reirob: the construct names must be unique
03:02:13 <sipa> reirob: i'd advise you to try some more simple examples first
03:02:26 <reirob> The thing is, that I want to use RteCommentT in multiple places. And because it has its own constructor I would like to be able to reuse the constructor without having to wrap it again
03:02:41 <bitemyapp> wut
03:02:48 <bitemyapp> reirob: okay, you need to slow down.
03:02:56 <bitemyapp> reirob: you need to sit down and learn Haskell for a bit.
03:03:10 <bitemyapp> reirob: I recommend following this: https://github.com/bitemyapp/learnhaskell
03:03:17 <reirob> This means that I would have to write: data RteGlobalStatementT = RteCommentAnotherConstructor RteCommentT  | ...
03:03:18 <reirob> ?
03:04:02 <orzo> i've re-implemented the nss validation algorithm
03:05:02 <reirob> ok, I will try to simplify and come back again.
03:08:25 <KSkrzet> I'm trying to use c2hs to crosscompile from Linux to Android. hsc2hs is able to do that, but I have no idea how to do that with c2hs... any clues?
03:10:46 <iross_> KSkrzet: I maintain C2HS, but I've never heard of anyone using it for that sort of cross-compilation.  You might be on your own there...
03:12:07 <KSkrzet> iross_: Ah, too bad. I thought it might be the case. I guess I'll try to convert the cairo binding library to hsc2hs then.
03:12:32 <johnw> you could look at c2hsc too, which could make your life easier
03:18:09 <KSkrzet> johnw: I think it might be easier not to start from stratch but rather fix existing cairo package in which case c2hsc doesn't seem applicable, or am I wrong?
03:18:43 <KSkrzet> iross_: Is it possible to force C2HS to dump intermediate .hsc files or there are no such files?
03:21:08 <matematikaadit> I'm reading "MonadPlus: What a super Monad" (http://www.haskell.org/wikiupload/6/6a/TMR-Issue11.pdf) and a bit loss in the state transformer part.
03:21:13 <matematikaadit> How State Transformer + [] Monad works.
03:24:11 <darthdeus> is hspec or hunit preferred?
03:24:56 <exicer> How should I go about reading a large number of files (~5k). Doing the obvious thing leads to an error saying resource exhausted.
03:26:30 <darthdeus> or to be specific, I want to test my parser (using parsec), but it seems I can't easily compare on ParseError, since it doesn't have Eq instance
03:26:42 <exicer> I want to read each file, do some stuff, perform an IO action (e.g. printing certain parts) then move on to the next file.
03:28:53 <Phillemann> Would you guys say that there is more "IDE like" support for emacs or for vim with regards to Haskell? Are there good resources or sample configurations for either?
03:29:09 <pavonia> exicer: What is the obvious thing?
03:29:22 <dmj`> Phillemann: holy war
03:29:55 <Phillemann> dmj`: Hard to ask without starting a flame war? Okay then. ;)
03:30:05 <hexagoxel> exicer: iirc, the problem in such cases is the number of open system file descriptors
03:30:06 <abh> exicer: you need non lazy io
03:30:18 <abh> use conduit or pipes
03:30:41 <dmj`> exicer: use iteratees, if you use lazy I/O the file descriptors might not get recycled
03:31:16 <k00mi> Phillemann: emacs is more extensible and has more cool haskell features
03:31:31 <warpy> exicer: https://www.fpcomplete.com/user/snoyberg/library-documentation/conduit-overview
03:32:07 <dmj`> exicer: http://hackage.haskell.org/package/io-streams-1.1.4.6/docs/System-IO-Streams-File.html
03:32:15 <Phillemann> k00mi: I'm using emacs right now and am pretty happy with it. But I would switch to vim if there's a more actively maintained haskell package for it. ;)
03:32:49 <exicer> pavonia: Getting the list of files, mapM'ing a function that reads and processes
03:32:56 <exicer> over those file
03:33:22 <dmj`> exicer: are you reading them in as strings?
03:33:51 <dmj`> @typ readFile
03:33:53 <lambdabot> FilePath -> IO String
03:33:59 <k00mi> Phillemann: there isn't
03:35:26 <exicer> dmj`: Lazy byte strings
03:35:43 <pavonia> exicer: As already noted, the problem is most likely laziness/to lately closed files
03:36:13 <exicer> pavonia: Yeah, I guessed as much. I'll have a look at one of these streaming things
03:37:14 <k00mi> Phillemann: if you're using haskell-mode, have a look at this: https://github.com/haskell/haskell-mode/wiki
03:37:29 <k00mi> lots of cool features I didn't know about
03:38:08 <Phillemann> k00mi: Ok, thanks.
04:18:13 <darthdeus> is there a way to measure how long a ghci command takes?
04:18:20 <darthdeus> without doing anything crazy
04:18:58 <darthdeus> i've made a small macro that does   :reload and :main   for running my specs, and now I kinda want to see how long the whole reload/run thing takes ... I already know the :main part, since the tests output the runtime
04:19:00 <shachaf> :set +s
04:19:13 <darthdeus> awesome!
04:19:15 <shachaf> Ah, a command in particular.
04:19:17 <darthdeus> thanks
04:19:26 <darthdeus> :set +s outputs it :)
04:19:30 <shachaf> Maybe +s won't work for you.
04:19:31 <shachaf> OK then.
04:25:31 <darthdeus> how can I say something like "any combination of letters and spaces, but without space being the last character" in parsec?
04:34:33 * hackagebot Hs2lib 0.6.0 - A Library and Preprocessor that makes it easier to create shared libs from Haskell programs.  http://hackage.haskell.org/package/Hs2lib-0.6.0 (TamarChristina)
04:34:35 * hackagebot Hs2lib 0.6.1 - A Library and Preprocessor that makes it easier to create shared libs from Haskell programs.  http://hackage.haskell.org/package/Hs2lib-0.6.1 (TamarChristina)
04:36:56 <JagaJaga> how to shrink double to %.2 or smthing like that? like 1.2345 -> 1.23
04:40:00 <byorgey> JagaJaga: (/100) . fromIntegral . round . (*100) ?
04:40:50 <byorgey> if you just want to *print* it with a certain number of digits you can use  showFFloat
04:41:00 <byorgey> > showFFloat (Just 2) 1.2345 ""
04:41:01 <lambdabot>  "1.23"
04:41:12 <byorgey> or printf
04:42:00 <byorgey> > printf "%.2f" 1.2345
04:42:02 <lambdabot>  can't find file: L.hs
04:42:55 <JagaJaga> byorgey: oh! nice. Stupid am I.
04:44:34 * hackagebot simple-conduit 0.1.0 - A simple streaming library based on composing monadic folds.  http://hackage.haskell.org/package/simple-conduit-0.1.0 (JohnWiegley)
04:44:36 * hackagebot handle-like 0.0.0.4 - HandleLike class  http://hackage.haskell.org/package/handle-like-0.0.0.4 (YoshikuniJujo)
04:58:22 <andkore> Does anything think Leksah is good enough to use? Or should I just suck it up and learn vim?
04:59:22 <dottedmag> andkore: vim or Emacs, yes.
05:00:00 <andkore> dottedmag: thanks...
05:00:43 <dottedmag> andkore: Eclipse plugin is okayish as well, but vim/Emacs modes are the best out there so far.
05:01:39 <andkore> dottedmag: Eclipse plugin is better than Leksah? That's kind of discouraging
05:02:30 <darthdeus> andkore: emacs haskell-mode is really amazing
05:02:32 <dottedmag> andkore: Eclipse provides a lot of functionality "for free" while Leksah has to build from scratch.
05:02:41 <darthdeus> vim is shit compared to that (I'm a vim user using emacs just because of that mode)
05:03:22 <andkore> Hm, I'll check out emacs/vim soon.
05:03:26 <andkore> Thanks for the input.
05:05:55 <JagaJaga> darthdeus: vim with `neco-ghc`, `ghcmod-vim` is better than emacs's mode. IMO. And surely with `youcomplteme` and `syntastic`
05:06:26 <darthdeus> JagaJaga: ghcmod-vim with syntastic blocks whenever you save a file
05:06:38 <darthdeus> JagaJaga: that's like 5 seconds of the editor not responding  :\
05:06:58 <darthdeus> i'm actually trying to patch ghc-mod to overcome this by running on the background, but no luck yet
05:07:15 <darthdeus> JagaJaga: same for :GhcModType which hangs the editor as well :)
05:07:23 <darthdeus> unless you have some magic trick to overcome that :P
05:07:37 <dottedmag> darthdeus: isn't there something already working for that? I saw something for Emacs, but IIRC it was a engine+emacs frontend.
05:08:06 <darthdeus> dottedmag: emacs runs ghc-modi on the background, so that problem doesn't happen there
05:08:13 <dottedmag> hdevtools?
05:08:17 <darthdeus> it only happens with ghcmod-vim
05:08:25 <darthdeus> dottedmag: hdevtools doesn't work with cabal and ghc 7.8
05:08:36 <dottedmag> I see
05:08:52 <darthdeus> there are PRs for hdevtools that fix both, but it seems to be rather inactive
05:09:03 <darthdeus> as in nobody is merging those
05:09:49 <darthdeus> I wrote a wrapper for ghc-mod to overcome the vim issue https://github.com/darthdeus/ghc-modi-wrapper but it's still slow even when it runs on the background, at least compared to emacs, which does it async
05:10:08 <darthdeus> and the most awesome thing in emacs is that it's interactive mode doesn't even need ghc-mod to give you type info, etc
05:10:45 <johnw> darthdeus: hdevtools works for me with 7.8
05:11:04 <johnw> unless i'm unwittingly using a git clone...
05:12:19 <andkore> Do any of the editors have a "format code" feature? Preferably one that can be customized with your own code style.
05:14:16 <taktoa> andkore: https://github.com/jaspervdj/stylish-haskell
05:14:28 <taktoa> I believe there is integration for haskell-mode on emacs
05:14:47 <andkore> taktoa: cool, thanks.
05:14:57 <darthdeus> johnw: even in cabal projects?
05:15:28 <johnw> yes, even in cabal projects
05:15:28 <darthdeus> i had a problem for example when I added an extension to the .cabal file, and then hdevtools showed it as a missing extension, because it didn't parse the project cabal file
05:15:31 <darthdeus> interesting
05:15:41 <darthdeus> let me try it again :P
05:15:45 <johnw> ah, I don't get my extensions from the cabal file
05:15:48 <darthdeus> ah :)
05:15:53 <johnw> I list out a bunch of -X extensions manually to hdevtools
05:16:29 <darthdeus> hmm
05:29:11 <darthdeus> http://stackoverflow.com/questions/24097185/how-to-write-a-parsec-parser-for-a-list-of-prefixed-elements
05:33:54 <exicer> Anyeone know of a way to transform node names of a document parsed with xml-conduit ?
05:38:13 <exicer> I guess I just want to do toLower on nameLocalName.. but I can't work out how to do so
05:41:34 <bluebelle> clear
05:53:43 <supki> exicer: depending on how exactly you want to update your xml something like xml-lens may or may not be helpful
06:03:14 <exicer> supki: I will have a look.
06:07:03 <JagaJaga> guys, are here some masters of HStringTemplate? Is there a way to set smthing like "%.2f" to element? "$x;format=\"%.2f\"$" doesn't work :(
06:13:57 <lordkryss> hello, i've got a question about lambda calculus... i've got to reduce `(Î»x.x(xy))(Î»z.zx)` but an online solver did differently from the solution on my course notes
06:14:31 <lordkryss> i was hoping someone here could help me out with it, or could advice me a better channel to ask it
06:15:49 <reirob> hello again fine Haskell folks
06:16:35 <reirob> I am trying to define an AST for a parser and I often run into the trouble of getting "Multiple declarations of ..." errors
06:16:51 <reirob> if I use the same data constructors for different data types
06:17:00 <corgifex> lordkryss: if you have a question, you should ask it
06:17:55 <lordkryss> i don't know how to solve it, i mean, i thought that the first part had to be reduced like (Î»x.x(xy)) --> (xy)
06:18:16 <lordkryss> but the nodes says that the solution is (Î»z.zx)((Î»z.zx)y) â†’ (Î»z.zx)(yx) â†’ (yx)x
06:19:04 <corgifex> how do you get (xy) from (\x.x(xy))?
06:19:10 <reirob> So my question is how you guys deal with this problem? Do you reinvent every time a new data type constructor even if actually the same name makes sense?
06:19:10 <dottedmag> lordkryss: (Î»x.x(xy)) can't be reduced, because it is not an application.
06:19:28 <corgifex> oh, by precedence error?
06:19:34 <reirob> So if I have
06:19:36 <reirob> data FuncCall = MkFuncCall {
06:19:36 <reirob>     funcname :: String
06:19:36 <reirob>   , funcArgs :: [RHSExpr]
06:19:36 <reirob> }
06:19:44 <lordkryss> i thought it was (\x.x)(xy)
06:19:46 <reirob> data Statement = Assignment Assignment
06:19:46 <reirob>                | FuncCall FuncCall
06:19:53 <reirob> data RHSExpr = Var String
06:19:53 <reirob>              | String String
06:19:53 <reirob>              | FuncCall FuncCall
06:20:01 <corgifex> called it!
06:20:06 * hackagebot husk-scheme 3.17.1 - R5RS Scheme interpreter, compiler, and library.  http://hackage.haskell.org/package/husk-scheme-3.17.1 (JustinEthier)
06:20:07 <reirob> then I get the error
06:20:08 <reirob> Multiple declarations of ‘FuncCall’
06:20:22 <corgifex> lordkryss: in general, the body of a lambda extends as far to the right as possible
06:20:30 <dottedmag> lordkryss: nope, it's a (Î»x.(x(xy)))
06:20:43 <lordkryss> oh, so i only "reduce" when i see it in brackets?
06:20:44 <reirob> I understand where the error comes from. But it seems not "right" to invent every time a new data type constructor for FuncCall?
06:20:57 <corgifex> brackets are an artifact
06:21:05 <corgifex> ASTs are where it's at
06:21:52 <dv-> reirob: data constructors are functions
06:21:55 <corgifex> reirob: you could use a prefix for your data constructors
06:22:04 <corgifex> StFuncCall, ExFuncCall
06:22:14 <corgifex> one's a statement, the other an expression
06:22:19 <lordkryss> oh, about the free variables and renaming, i basically have to check that no bound variable has the same name of a free variable when i reduce?
06:22:35 <reirob> yes, this is what I finish by doing, but I thought there would be something more elegant
06:22:49 <corgifex> you could change your language to be more C-like
06:23:20 <dottedmag> lordkryss: you can only reduce when you have an application. As \x binds very loosely, you won't see any application until the bracket is closed.
06:23:33 <dottedmag> That is, application to this lambda.
06:24:17 <reirob> Thanks corgifex and dv. I just wanted to hear if there is another solution - without changing to a C-like language ;)
06:24:52 <corgifex> and by that I mean C has statement := ... | expression ';'
06:25:27 <dottedmag> lordkryss: yes, or you'll end up with a single variable instead of two.
06:26:03 <dottedmag> (\x\y.yx)(y) would end up as \y.yy, not as \z.zy
06:26:33 <reirob> oh no corgifex, I am working on parsing an existing legacy language, I am not designing a new one.
06:27:07 <corgifex> pascal? :-)
06:27:34 <dottedmag> corgifex: Algol-inspired, looks like.
06:27:41 <lordkryss> dottedmag, \x\y?
06:27:57 <dottedmag> lordkryss: the same as (\x.(\y.yx))
06:28:00 <corgifex> \x.\y*
06:28:10 <lordkryss> oh :)
06:28:41 <lordkryss> in that case i can write that as (\x.(\y.yx))y right?
06:28:48 <dottedmag> yes
06:28:49 <reirob> funnily the syntax has borrowed something from pascal. but it's purpose is more like natively compiled awk.
06:29:30 <reirob> it is a data driven language used for EDI translations.
06:29:59 <reirob> but anyway you've helped me. Thanks a lot!
06:31:36 <lordkryss> dottedmag, thanks :)
06:33:13 <dottedmag> You are welcome
06:37:26 <SrPx> Is it possible for one to normalize a term in SKI calculus that has big complexity and thus takes a lot of time (say, months), and at the same time provide a proof that will allow anyone to verify that it is correct in a few seconds?
06:44:44 <ljosha> :t const
06:44:46 <lambdabot> a -> b -> a
06:45:16 <oleo> :t ?
06:45:18 <lambdabot> parse error on input â€˜?â€™
06:45:31 <oleo> :t lift(a)
06:45:32 <lambdabot>     Couldn't match expected type â€˜m aâ€™ with actual type â€˜Exprâ€™
06:45:33 <lambdabot>     In the first argument of â€˜liftâ€™, namely â€˜(a)â€™
06:45:33 <lambdabot>     In the expression: lift (a)
06:46:40 <corgifex> :t lift"a"
06:46:41 <lambdabot> MonadTrans t => t [] Char
06:46:50 <oleo> :t lift a
06:46:51 <lambdabot>     Couldn't match expected type â€˜m aâ€™ with actual type â€˜Exprâ€™
06:46:51 <lambdabot>     In the first argument of â€˜liftâ€™, namely â€˜aâ€™
06:46:51 <lambdabot>     In the expression: lift a
06:47:34 <oleo> how do you get documentation for say lift or any other primitive ?
06:48:53 <corgifex> how is lift "primitive"?
06:49:02 <corgifex> http://www.haskell.org/hoogle/?hoogle=lift
06:49:54 <Axman6> you look at the haddock docs for it?
06:49:57 <Axman6> @hoogle lift
06:49:59 <lambdabot> Text.ParserCombinators.ReadPrec lift :: ReadP a -> ReadPrec a
06:49:59 <lambdabot> Control.Monad.Trans.Class lift :: (MonadTrans t, Monad m) => m a -> t m a
06:50:00 <lambdabot> Language.Haskell.TH.Syntax lift :: Lift t => t -> Q Exp
06:50:11 <Axman6> lambdabot!
06:50:23 <int-e> SrPx: There are some obvious shortcuts (for example you could calculate 2^100 `mod` 7 using church numerals by iterating some function f 2^100 times that has a cycle of length 7; it seems unlikely that real implementation of SKI calculus would look for such cycles)
06:50:48 <lordkryss> any advice for a good lambda calculus reducer?
06:51:02 <lordkryss> the one i found do them wrong according to my notes...
06:54:24 <int-e> SrPx: As an aside, this idea crops up in math competitions. Let f(x) = (1+x)/(1-x). What is f^2014(2)?
06:54:53 <Axman6> IT'S NOT
06:54:56 <Axman6> whoops
06:56:07 <ab9rf> int-e: that problem is easier to solve by other means....
06:56:14 <SrPx> int-e: ... what.
06:57:49 <int-e> ab9rf: it's a pen and paper problem.
06:58:47 <ab9rf> int-e: indeed.
06:59:39 <ab9rf> int-e: the solution is recognizing that f(2) is 1 and that 1 is a fixed point of f
07:00:00 <int-e> SrPx: it uses the same kind of shortcut as I suggested in the SKI setting.
07:00:03 <int-e> ab9rf: no.
07:00:08 <corgifex> > let f x = (1+x)/(1-x) in f 2
07:00:10 <lambdabot>  -3.0
07:00:10 <SrPx> I know, but still.
07:00:11 <ab9rf> int-e: oops, mistyped
07:00:41 <corgifex> > let f x = (1+x)/(1-x) in iterate f 2 !! 2014
07:00:43 <lambdabot>  -0.5000000000000001
07:00:44 <ab9rf> int-e: it's cyclic, my bad
07:00:58 <corgifex> > let f x = (1+x)/(1-x) in iterate f 2 !! 2014 :: Rational
07:01:00 <lambdabot>  (-1) % 2
07:01:08 <ab9rf> cycles through 2, -3, -1/2, and 1/3
07:02:00 <ab9rf> and 2014 mod 4 is 2, so youwant the 3nd element of the cycle
07:02:09 <SrPx> But I don't understand how this relates. What I am asking is if lambdabot can provide a proof that will allow you to verify that `f 2 !! 2014 = -1/2` quickly, without having you to normalise it yourself.
07:05:16 <darthdeus> how can I tell parsec that a parser should consume the whole input or otherwise fail?
07:05:37 <ab9rf> darthdeus: include eof as part of the grammar
07:05:51 <int-e> SrPx: A sufficiently lucky SKI evaluator would just replay the proof.
07:05:51 <ab9rf> eof succeeds at end of input and fails otherwise
07:06:14 <SrPx> ...?
07:06:21 <Franciman> Hi all
07:06:42 <Franciman> I have a problem with Happy. Can I show you here the grammar?
07:07:12 <Franciman> Happy just says Filename.y : 15 : Parse error
07:07:13 <corgifex> darthdeus: grammar <* eof
07:09:40 <darthdeus> does eof work even if i just give it a string?
07:09:45 <darthdeus> or is eof like a general end of input?
07:09:57 <Franciman> Here it is the grammar: http://pastebin.com/da6tjUu4
07:10:16 <int-e> SrPx: Sorry, mind wandering: Assuming that there is a small and easily checked certificate for an expensive SKI evaluation. Then you can use the verifier as an evaluator, but let it guess the certificate first. So you need some probabilistic model of complexity. (Which is not so surprising: factoring products of two primes is also easy if you just happen to guess one of the factors)
07:10:17 <corgifex> darthdeus: what else are you going to give it?
07:10:21 * hackagebot Ketchup 0.2.2 - A super small web framework for those who don't like big and fancy codebases  http://hackage.haskell.org/package/Ketchup-0.2.2 (Hamcha)
07:10:31 <darthdeus> corgifex: well there's parseFile
07:11:00 <corgifex> darthdeus: where?
07:11:21 <darthdeus> hmm seems not, i'm dumb, never mind :D
07:11:24 <darthdeus> thanks guys
07:12:16 <SrPx> int-e: I guess I know what you are talking about, but I guess that is pretty likely no? Using the verifier as an evaluator would be inviable due to big search space, the proof would be the pointer?
07:23:38 <lordkryss> why is  (Î»z.zx)((Î»z.zx)y) â†’ (Î»z.zx)(yx) and not (Î»z.zx)yx  ?
07:24:53 <lyxia> lordkryss: Successive applications are conventionally read xyz=(xy)z
07:25:08 <lyxia> oh
07:25:13 <oleo> inner one is applied to y first
07:25:30 <lordkryss> so the result of that is?
07:25:34 <corgifex> because (\z.zx)y reduces to yx
07:26:05 <lordkryss> corgifex, and what if i wanted to get the second one? would that be possible?
07:26:29 <corgifex> yes, just write (Î»z.zx)yx
07:26:50 <lordkryss> i mean, if i wanted to get that out of the first one i wrote
07:27:09 <corgifex> that's possible if you make up different reduction rules
07:27:20 <lordkryss> oh ok
07:27:36 <lordkryss> so everytime a lambda "return" i should put brackets aroud the result
07:27:50 <corgifex> no, just don't remove the parens that are already there
07:28:37 <lordkryss> but i thought that parens were there to let me do f(g(x)) and not f(g)(x)
07:29:04 <lordkryss> lambda calculus confuses me :S sorry
07:30:45 <corgifex> your talk about parens confuses me. I don't see lambda calculus as a text substitution game
07:31:03 <Franciman> it is
07:31:14 <corgifex> yes, this may be a problem on my end
07:31:34 <corgifex> but I immediately resolve stuff into trees and ASTs and think in terms of those
07:31:43 <lordkryss> trees? o.O
07:31:48 <corgifex> yes, expression trees
07:32:13 <lordkryss> i see them as functions that returns functions so i think of formal/actual parameters etc
07:32:26 <lordkryss> but it's the order of things and parens that confuse me :S
07:33:23 <eizo> lordkryss: http://wiki.western.edu/mcis/images/a/ae/Lamtree.png
07:34:14 <lordkryss> what are the @ for?
07:34:19 <lordkryss> parens?
07:34:23 <hayashi> @_@
07:34:31 <lordkryss> or applications?
07:34:35 <eizo> application
07:34:36 <corgifex> application
07:34:37 <lordkryss> thanks btw
07:35:50 <corgifex> lordkryss: http://i.imgur.com/1BaUgi7.png this is what I mean by expression trees
07:35:58 <corgifex> we drew them in 5th grade
07:37:38 <lordkryss> yes! i did an exercise correctly finally
07:37:49 <lordkryss> like the second in 10 that i tried :(
07:37:54 <aflag> has anyone here done coding dojos with haskell? Can you share with me the code produced, problem, etc?
07:50:32 * hackagebot inch 0.2.0 - A type-checker for Haskell with integer constraints  http://hackage.haskell.org/package/inch-0.2.0 (AdamGundry)
07:53:32 <pejo> Trying to figure out what something means. Here's the line: import Data.Array.Repa ( type (:.)((:.)) )
07:55:04 <danielszmulewicz> Hi there! Noob here! With a question: why does `cabal sandbox init` doesn't prompt me like `cabal init`does?
07:55:31 <pejo> The section in the manual gives "type (++)" as example. Does "type (++)(..)" make any sense?
07:56:46 <pejo> daniel, what do you want it to ask you about?
07:57:47 <lordkryss> just a question that bothers me... in lambda calculus... x,y,z... they are only functions/lambdas? or also values?
07:57:57 <danielszmulewicz> pejo: I want to start a new project.
07:58:03 <flebron> lordkryss: Only functions, by default.
07:58:08 <danielszmulewicz> If I type cabal init, I get prompted
07:58:21 <flebron> You can extend it to have whatever you want, but the lambda calculus itself only has functions.
07:58:24 <danielszmulewicz> If I type cabal sandbox init, there's no prompt
07:58:35 <danielszmulewicz> I mean all the properties of my project
07:58:38 <dcoutts_> danielszmulewicz: it's just doing a different thing
07:58:44 <danielszmulewicz> Oh, I need both!
07:58:54 <lordkryss> flebron, thanks, so for example `(Î»x.Î»y.(add x ((Î»x.(sub x 3)) y))) 5 6` is not "natural" lambda calculus?
07:58:59 <dcoutts_> danielszmulewicz: one creates a new project, one makes a sandbox, one needs to be interactive, the other does not
07:59:04 <danielszmulewicz> I thought cabal sandbox init was a replacement for cabal init!
07:59:08 <dcoutts_> danielszmulewicz: so yes, you may well want to do both
07:59:15 <flebron> No, because "add", "sub",3, 5, and 6 are not function expressions.
07:59:36 <lordkryss> thanks, that should make my exercises more understandable :)
07:59:43 <flebron> In a metalanguage you can define the symbol "add" to be some function, same with 3, 5, 6, and "sub", but that has to be outside lambda calculus itself.
07:59:56 <danielszmulewicz> Do you guys typically run one after the other, provided you want to create a project with non-global dependencies?
08:00:00 <flebron> Metalanguage being "Some language which you use to talk _about_ lambda calculus", for example English.
08:00:27 <lordkryss> i actually took that line from an exercise too, that i have to reduce
08:07:20 <deepfire> hello!  any hircules users here?
08:17:29 <hexagoxel> danielszmulewicz: i have not used "cabal init" before, but i can't see a problem. and the order should not matter, i think
08:29:58 <flaggy> hello. One important thing in testing is figuring out the corner cases. When we make a regular unit test, we think up all the possible corner cases and set up an example of each. However, when doing a quickcheck it's unclear to me how quickcheck will try to pick corner cases. For instance, if my function breaks on empty strings, but quickcheck picks 100 random non-empty strings, it will not be doing a very good job at corner-case checking.
08:32:19 <pejo> flaggy, here's an example on interval arithmetic testing: https://github.com/Feldspar/feldspar-language/commit/7fd41ddd6c76fe9195d531f6ea575d5d2e995ca7
08:33:21 <Maxdamantus> @check not . null
08:33:23 <lambdabot>  *** Failed! Falsifiable (after 1 test):
08:33:23 <lambdabot>  []
08:33:59 <Cale> flaggy: There is something called SmallCheck which provides a similar interface to QuickCheck (i.e. can use the same tests), but which tests small cases exhaustively
08:34:50 <aspidites> which reminds me, smartcheck (i know you mentioned SMALLcheck) purports to be a smarter quickcheck, but i don't ever here mention of it
08:35:48 <aspidites> i wonder where it went wrong
08:35:56 <Cale> flaggy: However, QC will often pick up many of the small cases anyway, because of how it tries tests with small sizes first
08:36:06 <flaggy> I see
08:36:40 <flaggy> I'll read it up
08:36:49 <Cale> aspidites: I hadn't heard of it
08:37:35 <aspidites> neither had i until it popped up on reddit about a month ago (http://www.reddit.com/r/haskell/comments/25aagr/quickcheck2_vs_smallcheck_vs_smartcheck_etc/)
08:37:56 <aspidites> unfortunately, i don't remember anyone explaining the differences, mostly sticking to smallcheck vs quickcheck
08:38:30 <pejo> aspidites, is the primary advantage once you have a failing test case?
08:39:05 <Cale> Ah, apparently it uses generics to do shrinking on its own, rather than relying on user-provided shrinking
08:39:50 <flaggy> There's been a long time since I last programed with haskell, but I'm planing to make a coding dojo at my company to see if I can get more people interested on the language. That's why I'm looking for quickcheck and apropriate haskell challanges :)
08:40:52 <aspidites> pejo: dont know, thats why i was asking/rambling
08:41:11 <pejo> aspidites, that's what the readme in the github repository seems to be claiming, as far as I can tell
08:43:32 <aspidites> ah. readme's are good unless you're lost to begin with :P. I think haskell experience can be calculated as the inverse of dog years
08:44:26 <aspidites> in which case, i've got about 2 months of experience with the language
08:55:56 <aspidites> when you guys are trying to model a data structure whose shape you are unsure of, do you just start with the most primitive thing possible and refactor when necessary, or are there rules of thumb i should be following?
08:56:25 <dfranke> Does Haddock have syntax for explicitly attaching a doc comment to a specific item? I want to document a declaration that was generated by Template Haskell.
08:57:21 <vanila> aspidites, yes haskell helps you refactor really really nicely
08:57:30 <vanila> so this way is much easier in haskell than untyped languages
08:57:48 <vanila> it even shows you ever line you have to update, when you make edits to the data
08:58:30 <aspidites> ok, thats what i figured. and how do you know when you've gone to far? as a concrete example...
08:58:55 <aspidites> i'm trying to model a card game i invented, which has turns which in turn consists of phases, each of those allowing a specific set of actions
08:59:44 <aspidites> as such, i was using lists for the sequence of actions that a user commited. then it occured to me that some actions span turns, so it would be nice to have a stream of them to pull from after each turn passes
08:59:53 <dfranke> aspidites: I tend to write modules by declaring all my data structures and type signatures first, before I ever start writing any term-level code.
09:00:17 <aspidites> term-level? excuse my ignorance
09:00:36 <dfranke> aspidites: as opposed to type-level. Actual stuff that can execute.
09:00:45 <aspidites> ah ok
09:01:23 <aspidites> i keep seeing that style advocated, but haven't been successful doing so myself. i often don't know what the types should look like until i start implementing things
09:01:31 <aspidites> perhaps i'm just not thinking hard enough :P
09:02:18 <pejo> aspidites, you've gone too far when the benefit of the eliminated error cases is small and the cost of eliminating them is high. I don't think there's a set answer, it all depends on how important the software is.
09:03:39 <dfranke> aspidites: I admit it didn't work for me very well until I'd been writing Haskell for a few years. Doing it successfully requires a lot of intuition.
09:04:24 <pejo> dfranke, do you get the data structures right on the first attempt?
09:04:45 <dfranke> pejo: these days, yes. But like I just said, it took me a while to get there.
09:05:40 <aspidites> thats encouraging and discouraging at the same time
09:05:56 <dfranke> before that, I'd write all my declarations, get something that looked good, and then start writing code, realize that I was trying to do something impossible, and have to throw it out and start over.
09:06:12 <aspidites> dfranke: and that's definitely discouraging
09:06:20 <dfranke> existential types are particularly excellent for foot-shooting.
09:07:38 <_deepfire> so, I browsed for a working haskell IRC client that is cabal-installable, and found nothing
09:08:29 <pejo> dfranke, I grabbed a couple of modules on random. There's 20-50 functions ("grep :: File.hs | wc -l") in most of them.
09:08:37 <aspidites> _deepfire: did you try hircules?
09:08:49 <aspidites> better question is probably what platform you're running
09:08:53 <_deepfire> couldn't figure out how to actually send messages in hircules (after fixing the catch -> catchIOError thing)
09:09:26 <_deepfire> fedora x64
09:10:02 <_deepfire> manatee-ircclient was entirely beyond hope - or, you could say, beyond my extremely limited debug abilities
09:10:24 <_deepfire> as in unbuildable
09:11:15 <aspidites> hmm... no readme for hirculese either
09:11:43 <_deepfire> yeah, I even went as far as trying to deduce its behaviour via source code, but I'm far too noob
09:12:23 <aspidites> i'm sure i'll be of no help then :-)
09:12:40 <_deepfire> a thing I noticed is that freenode responds with an error, when you try to "just type a message" in what is supposed to be a "channel window"
09:13:41 <aspidites> now i'm curious - i'm installing it now
09:13:47 <_deepfire> also, the error response from server goes away, when trying /privmsg #channel ..text..
09:13:58 <_deepfire> ..but, tcpdump show something weird
09:14:30 <aspidites> does anyone know if there's anything on the cabal horizon for installing build dependencies?
09:14:48 <aspidites> eg gtk2hs_buildtools
09:14:53 <_deepfire> that's what I see -- ;vb.M...RIVMSG #haskell :hello!  any hircules users here?
09:15:05 <_deepfire> i.e. the 'P' from PRIVMSG is omitted
09:15:15 <_deepfire> ..on the wire
09:15:39 <_deepfire> from my limited understanding of the IRC protocol, that's an error
09:16:45 <_deepfire> I'm not sure if I'm dangerously offtopic here, btw
09:17:10 <aspidites> nice, haskell-lang.org's built-in repl is live1
09:17:12 <aspidites> !*
09:18:43 <_deepfire> yes, definitely looks nice
09:21:52 <jrm2k6> Hi guys. When trying to used this example http://hackage.haskell.org/package/parsec-3.1.5/docs/Text-Parsec-Prim.html#v:parse it doesnt even compile
09:22:01 <jrm2k6> Just copy pastin the content, what could be wrong? imports?
09:22:29 <jrm2k6> https://gist.github.com/jrm2k6/5ecd546d98b0aa121751
09:26:35 <JagaJaga> guys, are here some masters of HStringTemplate? Is there a way to set smthing like "%.2f" to element? "$x;format=\"%.2f\"$" doesn't work :(
09:31:26 <rwbarton> jrm2k6: pay careful attention to how Text.Parsec.Token is expected to be used at the bottom of http://hackage.haskell.org/package/parsec-3.1.5/docs/Text-Parsec-Token.html
09:31:44 <jrm2k6> checking rwbarton
09:31:53 <enthropy> does something like https://github.com/luqui/parsec-layout exist for uu-parsinglib?
09:35:11 <herol3oy> can i ask a question about web developing problems?
09:36:05 * hackagebot ghcjs-dom 0.0.8 - DOM library that supports both GHCJS and WebKitGTK  http://hackage.haskell.org/package/ghcjs-dom-0.0.8 (HamishMackenzie)
09:36:07 * hackagebot ghcjs-dom 0.0.9 - DOM library that supports both GHCJS and WebKitGTK  http://hackage.haskell.org/package/ghcjs-dom-0.0.9 (HamishMackenzie)
09:37:15 <c_wraith> herol3oy: You can ask.  If they're haskell-related, you're likely to get a helpful answer. :)
09:37:29 <herol3oy> thanks
09:37:44 <herol3oy> act it's not related
09:37:51 <herol3oy> so i will ask somewhere else!
09:37:53 <herol3oy> ;)
09:41:09 * hackagebot jsaddle 0.1.1.5 - High level interface for webkit-javascriptcore  http://hackage.haskell.org/package/jsaddle-0.1.1.5 (HamishMackenzie)
09:45:56 <jrm2k6> rwbarton: I am not sure I get it.
09:46:04 <jrm2k6> Do you refer to makeTokenParser?
09:53:26 <orbital_> going to ask a stupid question: in the context of lists (at least), why did the mplus combinator have to be ++ and not +?
09:54:23 <dwcook> orbital_: (+) isn't defined over lists because there is no Num instance concerning them.
09:54:31 <orbital_> it's not like + is used for anything sensible, and ++ is ugly
09:54:42 <dwcook> (+) is. It's a method of Num.
09:54:50 <orbital_> dwcook: but why must it be confined to num?
09:54:57 <orbital_> *Num
09:55:18 <dwcook> Are you asking the semantics or design reason or something else?
09:55:20 <monochrom> like you said, if you don't like ++, you can always use mplus
09:55:31 <orbital_> (+) is not used for lists, i meant
09:55:47 <zwer> :t (+)
09:55:48 <lambdabot> Num a => a -> a -> a
09:55:53 <orbital_> dwcook: design, i suppose
09:56:11 * hackagebot jsaddle 0.1.1.6 - High level interface for webkit-javascriptcore  http://hackage.haskell.org/package/jsaddle-0.1.1.6 (HamishMackenzie)
09:56:12 <orbital_> yes yes, i know what (+) is defined to be
09:56:42 <dwcook> I don't know. Perhaps someone else does.
09:56:54 <rwbarton> you can't have two different functions with the same name, at least not if you want to be able to use them without module qualification
09:56:56 <dwcook> At a guess: It would be hard to figure out which (+) you meant.
09:56:58 <zwer> list is not a numeric class, so it would make no sense to implement (+) for it
09:57:02 <dwcook> Hard or impossible.
09:57:47 <rwbarton> you could call it Data.List.+
09:58:02 <dwcook> Of course you can qualify your uses of bindings from separate modules, like Prelude.+ and such. But having two things with the same identifier in base is probably something they deliberately avoided.
09:58:03 <rwbarton> I don't think that would be very popular
09:59:52 <orbital_> ok, that makes sense
09:59:54 <orbital_> thanks
10:01:07 <jrm2k6> :t commaSep
10:01:08 <lambdabot> Not in scope: â€˜commaSepâ€™
10:01:09 <rwbarton> (and yeah, there are a bunch of packages (bytestring, text, vector) that reuse a lot of names from Prelude)
10:01:14 <jrm2k6> gloup.
10:01:17 <orbital_> heh, i wasn't alone: http://stackoverflow.com/questions/10961483/haskell-duplicated-functions-and-mappend
10:01:38 <dwcook> Things like Data.Text are essentially designed to be imported qualified
10:01:58 <jrm2k6> Anybody can help with this? https://gist.github.com/jrm2k6/5ecd546d98b0aa121751
10:02:05 <jrm2k6> I dont get it.
10:02:22 <jrm2k6> especially because it is used as an example in the doc.
10:02:24 <dwcook> orbital_: that's asking a different question from what I understood yours to be. Are you saying you meant what that post is asking?
10:02:36 <jrm2k6> rwbarton: I tried to check your link but I dont get what is wrong
10:02:48 <rwbarton> in principle everyone could decide to import qualified Data.List as L and the list functions could not be reexported from Prelude, and then we could call list concatenation L.+
10:03:34 <orbital_> dwcook: they seem similar enough, mine was stated poorly
10:03:44 <rwbarton> jrm2k6: did you read the bottom of the page
10:03:45 <rwbarton> hang on
10:03:52 <jrm2k6> yes i did.
10:03:56 * monochrom shakes head at the idea of Monoid having both mappend and mmultiply. do they also wish for adding legs to snakes?
10:04:04 <rwbarton> import qualified Text.Parsec.Token as P
10:04:12 <rwbarton> integer = P.integer lexer
10:04:40 <jrm2k6> oh
10:05:15 <rwbarton> then you need to pick one of the language definitions
10:05:17 <orbital_> to clarify, my question stemmed from pondering the necessity of unpleasantness of having to stare at repeated use ++ :)
10:05:24 <dwcook> orbital_: So in short, why not just call the monoid operation (+) (or even (++)) and forget about the specialized (++)? Similarly, why do we call map map and not fmap map? Is that your basic question?
10:05:48 <monochrom> you can use âŠ• if you want
10:06:06 <orbital_> dwcook: yes
10:06:16 <monochrom> I don't find ++ unpleasant
10:06:51 <rwbarton> jrm2k6: or of course you could define your own parsers
10:06:53 <dwcook> I've heard cited the reason that we have map when fmap is around that the more concrete types are easier to understand for newbies. I don't know if I'm convinced by that though.
10:06:55 * monochrom is not a fan of "use the same symbol for everything under the sun"
10:06:58 <rwbarton> jrm2k6: but that's how the example is intended to be run
10:07:02 <jrm2k6> rwbarton: yes i begin to see
10:07:04 <orbital_> s/use/use of/
10:07:09 <glguy_> Not sure that it will help, but the operator for the monoid operation is currently (<>)
10:07:12 <rwbarton> jrm2k6: it should probably have a better example :)
10:07:13 <jrm2k6> http://www.haskell.org/haskellwiki/Parsing_expressions_and_statements rwbarton I guess this is my must read
10:07:14 <jrm2k6> :)
10:07:52 <monochrom> I wrote that article
10:07:56 <rwbarton> this is also using the LanguageDef functionality
10:08:09 <jrm2k6> monochrom: the one I mentionned?
10:08:14 <monochrom> yes
10:08:14 <orbital_> dwcook: i saw that argument too and had a similar reaction
10:08:20 <jrm2k6> wow.
10:08:24 <jrm2k6> such star :)
10:09:24 <orbital_> this sort of reasoning tends to prevent nice things, i think
10:09:43 <orbital_> (the catering to newbies, that is)
10:10:31 <rwbarton> map is easier to read for everyone. it gives you more information
10:10:38 <glguy_> fmap is the generalization which happens to encompass a bunch of other operations
10:10:48 <glguy_> There's no reason that the operations that it encompasses shouldn't be named
10:11:26 <dwcook> I think there might be hysterical raisins involved too. Didn't Functor not get added till later?
10:11:47 <glguy_> (.) stands on its own. It would be a bad idea to drop it simply because fmap exists
10:12:09 <glguy_> and it would be silly to confuse composition for its generalization
10:13:00 <orbital_> glguy_: whoa, who said anything about dropping (.)?
10:13:23 <dwcook> Well, the argument was made to drop (++) when we have mappend. The same one would apply to (.) and fmap
10:14:16 <orbital_> generalizing the argument is something entirely different!
10:14:50 <dwcook> Is it that you care specifically about mappend and (++)? If so, why those in particular?
10:15:38 <hexagoxel> how is fmap a more general form of (.) ?
10:15:45 <hexagoxel> they do not even have the same arity
10:15:48 <Tene> :t (.)
10:15:49 <lambdabot> (b -> c) -> (a -> b) -> a -> c
10:15:53 <hexagoxel> :t fmap
10:15:53 <Tene> :t fmap
10:15:54 <lambdabot> Functor f => (a -> b) -> f a -> f b
10:15:54 <lambdabot> Functor f => (a -> b) -> f a -> f b
10:15:56 <rwbarton> :t fmap `asTypeOf` (.)
10:15:57 <lambdabot> (a -> b) -> (a1 -> a) -> a1 -> b
10:16:14 <orbital_> not really. I was simply reading some code with heavy string concatenation and thought "hm, why ++ and not +?"
10:16:37 <dwcook> monochrom: I'm not sure the person who proposed mmultiply was aware that (+) and (*) make two different monoids.
10:16:40 <Tene> :t asTypeOf
10:16:41 <lambdabot> a -> a -> a
10:17:07 <glguy_> asTypeOf x y = x
10:17:35 <copumpkin> :t asTypeIn
10:17:36 <lambdabot> a -> (a -> b) -> a
10:17:36 <hexagoxel> meh thanks
10:17:38 <dwcook> orbital_: And the fact that (+) is already used for something else doesn't move you from that?
10:17:51 <monochrom> I understand. I shake head at people inventing ideas before checking facts
10:18:22 <monochrom> such people are also likely to be unaware that "snake" by definition has no legs
10:18:49 <glguy_> Only because scientists with no sense of imagination defined the work snake as such
10:19:01 <glguy_> word* :)
10:19:39 <monochrom> it is one thing to imagine an animal tube-like with legs. it is another thing to suggest "let's call it snake as well".
10:20:19 <glguy_> monochrom: Like a dachshund?
10:20:31 <monochrom> I don't know. I haven't learned that word.
10:20:38 <orbital_> dwcook: (had to ponder that for a second) no, not really. I tend to think of (+) as a semigroup operation, with Num being a concrete case.
10:21:09 <dwcook> orbital_: ah, so you think the notation more properly belongs to Semigroup (or Monoid). Then what would Num use?
10:21:54 <dwcook> Actually I'm not sure if Num even corresponds to a commonly used mathematical structure
10:22:16 <monochrom> it is ring plus a few more things
10:22:34 <glguy_> Num corresponds to the operations people could think of that were common to the basic numeric types in Haskell
10:23:32 <monochrom> I am fine with tautologically saying "it is a commonly used mathematical structure called Num" :)
10:23:40 <dwcook> Haha
10:24:02 <dwcook> Wasn't it you who wrote down those other tautologies?
10:24:07 <monochrom> yes
10:24:35 <rwbarton> monochrom wrote down all the tautologies that monochrom wrote down.
10:24:45 <dwcook> http://www.vex.net/~trebla/humour/tautologies.html
10:25:05 <orbital_> dwcook: I don't have a strong opinion, merely exploring :) I assume there is a reason a monoidal (+), a numeric (+) and (++) are differentiated and I just don't have a firm grasp on that yet.
10:25:23 <monochrom> Num does not fit those things mathematicians study. but mathematicians don't study practical computer programming anyway. Num is practical to a large extent.
10:25:53 <orbital_> practical <- that was my motivation
10:26:10 <monochrom> I have a better one for you, rwbarton. the tautologies I write are exactly the tautologies written by all people who write all tautologies I write.
10:26:16 <davnils> why do we have Num instead of Ring?
10:27:08 <dwcook> monochrom: Sometimes it doesn't fit the things you want to use it for though. How about nats?
10:27:13 <geekosaur> davnils, because haskell isn't quite expressive enough; a proper configuration (youcan find modules for it on hackage) turns out to be a pain to work with
10:27:16 <dwcook> (negate is a problem)
10:27:36 <monochrom> "use + for both numbers and strings" is "practical" in the same sense as "java and javascript do it"
10:27:37 <geekosaur> for example, the fact that we need to use wrappers to reflect the fact that there are two monoids on integral types
10:27:52 <glguy_> If you want a class that isn't just about overloading some valuable name realestate you can just make a new class for the structure it was you wanted
10:27:59 <monochrom> that is my only understanding of the motivation of "use + for both numbers and strings"
10:28:02 <rwbarton> we could just declare that Addition is the One True Monoid on numbers
10:28:25 <monochrom> ring would not fit nats either
10:28:39 <rwbarton> though + for noncommutative things rubs me the wrong way anyways
10:30:04 <orbital_> aha, noncommutativity is a great practical reason to not conflate (+) and (++)
10:30:22 <monochrom> Num is a war zone. everyone wants to change it for his/her personal interest.
10:30:26 <Tene> Yeah, + for noncommutative really irks me
10:30:27 <orbital_> (in my mind, at least :)
10:31:33 <Tene> I could see * being used for that, though; there are noncommutative mathematical uses of *.
10:32:13 <orbital_> numbers spoil everything
10:33:43 <orbital_> numbers let people confuse children with labels such as "real" and "imaginary"
10:33:52 <orbital_> <- childhood trauma
10:34:06 <monochrom> you met imaginary numbers during childhood?
10:34:40 <orbital_> monochrom: early adolescence, but what does it matter
10:35:02 <orbital_> it's really all imaginary
10:36:57 <monochrom> this is time to cue "be rational, get real": http://mightywombat.com/oldtoon.php?id=297&year=2007
10:37:36 <orbital_> and now we can't have a monoidal (+) -- because numbers! They just never give up.
10:39:06 <sveit> i have a rather simple function to print a matrix-like object, but I do not think it is written in the best way. it is a 4-line (really a 2-line) function, is there a better "haskelly" way to re-write it? http://lpaste.net/5384099817477636096
10:39:08 <orbital_> not teaching my children basic arithmetic until after AA
10:41:06 <latro`a> orbital_, you really would need a better superclassing system than haskell has for such a thing to make sense
10:42:03 <latro`a> since under your suggestion, every Num would be a Monoid
10:42:16 <latro`a> and the compiler would have to actually know this
10:42:39 <latro`a> unless you did the silly Prelude.+, Data.Monoid.+ thing
10:42:45 <orbital_> actually, i'm fine not using (+) for Num, personally :)
10:43:01 <latro`a> you're probably the only one
10:43:53 <Jefffrey> Hello.
10:43:53 <Jefffrey> Am I tripping? http://coliru.stacked-crooked.com/a/69295a1d1bfed102
10:44:10 <orbital_> well, numeric computation is not something i do most of the time
10:45:16 <Jefffrey> I think it's a bug.
10:45:43 <flaggy> i'm trying to use quickcheck, but when I try to make an instance from Arbitrary it sems to require that I make an instance of Random as well. Is that how things usually go?
10:46:13 <davnils> Jefffrey: check order of e and ls in both occurrences
10:46:27 <roconnor> flaggy: I don't recall ever making anything an instance of Random.
10:46:41 <darthdeus> how should I modify this parser so that the `sepBy` doesn't consume the space at the end, so that the string " {" can consume it?
10:46:41 <darthdeus> parse (sepBy (many letter) (string " ") >> string " {") "" "foo bar {"
10:46:55 <flaggy> my bad, I used choose instead of elements, I think that was it :)
10:47:00 <Jefffrey> davnils: Wow, I'm stupid. Thanks.
10:47:59 <rwbarton> btw, "Hello. Am I tripping? <random url>" makes you indistinguishable from a bot
10:48:43 <davnils> perhaps it is a bot, evolving through feedback..
10:49:14 <roconnor> darthdeus: I don't think sepBy should be consuming the last space.
10:49:21 <darthdeus> or more specifically, is there a way to push back a value after consuming it?
10:49:47 <darthdeus> roconnor: it is, since when i remove it from the second parser it works, like this
10:49:48 <darthdeus> @parse (sepBy (many letter) (string " ") >> string "{") "" "foo bar {"
10:49:48 <lambdabot> Maybe you meant: paste part
10:50:03 <darthdeus> but i want the second parser to be     string " {"
10:50:22 <monochrom> darthdeus: use a different approach. parse (spaces >> many word >> leftcurly). word = many letter <* spaces; leftcurly = char '{' <* spaces
10:51:18 <darthdeus> monochrom: but I can't modify the second parser in this case
10:51:35 <darthdeus> monochrom: i need to write the first one so that it consumes words up until the " {" without consuming it
10:51:39 <roconnor> darthdeus: I'm pretty sure that is now how sepBy works.
10:51:56 * roconnor tries
10:51:59 <darthdeus> roconnor: it's not, i just tested it
10:51:59 <darthdeus> http://i.imgur.com/PwtAFgJ.png
10:52:29 <monochrom> I do not understand "can't" and "need to". it's your code. you have freedom.
10:53:52 <monochrom> at any rate, my solution works, it's also the standard and preferred solution, Text.Parsec.Token does the same thing.
10:54:04 <sveit> to rephrase my question, is it "haskelly" to go line-by-line like this, or should i process the elements one-by-one? http://lpaste.net/5384099817477636096
10:54:33 <monochrom> in short, think tokenization, do not think that space is a separator
10:54:55 <davnils> sveit: yep, haskelly. hard to write shorter without any structure in Matrix.
10:55:08 <darthdeus> monochrom: what if that space was another character that had meaning to the second part?
10:55:10 <roconnor> darthdeus: oh use many1
10:55:28 <monochrom> then it would not be space.
10:55:43 <rwbarton> aha yes, the empty string after the second space is a (many letter)
10:55:44 <roconnor> darthdeus: hmm, that didn't work
10:55:51 <darthdeus> roconnor: yeah many1 doesn't help
10:56:06 <darthdeus> monochrom: this is just an example ...
10:56:24 <roconnor> oh, right, because it consumes the space
10:56:30 <darthdeus> roconnor: yes :P
10:56:47 <monochrom> then you have used an unfaithful example.
10:56:51 <darthdeus> monochrom: just imagine the " {" as 'something huge for which you already have a parser'
10:56:57 <roconnor> well many1 is definitely a step in the right direction
10:56:59 <monochrom> I refuse.
10:57:20 <darthdeus> well then I refuse to work around a problem I don't know how to solve, just because it's convenient in this case
10:57:44 <sveit> davnils: just worried about whether the intercalate "\n" part is idiomatic
10:57:58 <sveit> or if I should be doing the line-by-line in more detail
10:57:58 <rwbarton> sveit, unlines? it will add a trailing "\n" too though
10:58:36 <sveit> rwbarton: maybe, thanks.
10:59:00 <sveit> i guess i'm still a bit uncomfortable since in a different language it makes much more sense to go element-by-element
10:59:02 <sveit> i.e. in a loop
10:59:08 <sveit> and test the indices for when to put the "\n"
10:59:12 <sveit> which seems more efficient
10:59:26 <sveit> but perhaps because of the laziness this is OK?
10:59:32 <darthdeus> is there a way to push a consumed value back upstream?
10:59:48 <monochrom> yes
10:59:55 <darthdeus> i could probably live with consuming the space, pushing it back and then returning the value without the space
11:00:15 <StoneToad> darthdeus: this is parsec?
11:00:19 <darthdeus> StoneToad: yes
11:00:25 <monochrom> but I don't understand why you call it a space, when you have said it is not a space.
11:00:55 <roconnor> parse (sepBy (many1 letter) (try (string " " >> notFollowedBy (string "{"))) >> string " {") "" "foo bar {"
11:01:13 <roconnor> I'm not very happy with this.
11:01:21 <darthdeus> roconnor: hmm, that's perfect :P
11:01:27 <StoneToad> hmm
11:01:28 <darthdeus> monochrom: -_-
11:01:33 <roconnor> that's a strange definition of perfect
11:01:42 <roconnor> I call it: grossly akward
11:01:43 <StoneToad> darthdeus: will it always be a single char?
11:01:43 <monochrom> this is full of XY problems
11:01:47 <StoneToad> in your example it's a single ' '
11:02:01 <darthdeus> StoneToad: notFollowedBy takes an arbitrary parser no?
11:02:15 <danielszmulewicz> Any emacs users out there? I'm just starting with Haskell, and I could use some guidance for an optimal setup.
11:02:24 <darthdeus> i mean it could be something like (try (somethingComplicated >> notFollowedBy somethingElse))
11:02:46 <Pythonfant> danielszmulewicz: yep me, but I'm still pretty new to haskell myself
11:03:06 <danielszmulewicz> Pythonfant: which modes are you using?
11:03:11 <monochrom> my setup is not optimal
11:03:15 <Pythonfant> I only used haskell-mode
11:03:19 <Pythonfant> s/used/use
11:03:40 <Pythonfant> I tried structure-haskell-mode for indentation but it annoyed me too much so I switched back to haskell-indentation provided by haskell-mode
11:04:38 <StoneToad> darthdeus: lookAhead might work better in that case
11:04:49 <danielszmulewicz> Pythonfant: Interesting. I have structured-haskell-mode turned on, and now I find TAB is not doing anything.
11:05:05 <Pythonfant> danielszmulewicz: afaik that's the way it's supposed to be
11:05:15 <Pythonfant> you need to press C-j instead of enter if you want to do a line break
11:05:24 <Pythonfant> and select the correct node to get the right indentation
11:05:58 <danielszmulewicz> Right. It works for most things, but I don't know how to align inside an ADT.
11:06:03 <darthdeus> is there some comprehensive guide on using parsec "the right way"? the docs at http://legacy.cs.uu.nl/daan/download/parsec/parsec.html are pretty short
11:06:23 * hackagebot mono-traversable 0.6.0.2 - Type classes for mapping, folding, and traversing monomorphic containers  http://hackage.haskell.org/package/mono-traversable-0.6.0.2 (MichaelSnoyman)
11:06:45 <Pythonfant> danielszmulewicz: sry I don't think I can help you there. I had trouble myself getting into structured-haskell-mode which is the reason why I'm not using it anymore
11:07:06 <danielszmulewicz> Pythonfant: No problem. Have you tried ghc-mod? Is that widely used?
11:07:20 <Pythonfant> I have tried it and it seemed to work pretty well
11:07:33 <Pythonfant> I accidentally removed it and didn't reinstall it so far :)
11:07:40 <Pythonfant> but I most likely will
11:07:45 <danielszmulewicz> Pythonfant: :-)
11:07:46 <StoneToad> darthdeus: you know,  it's probably a terrible idea, but you could reimplement your own copy of sepBy that ignored trailing seperators
11:08:32 <danielszmulewicz> Pythonfant: What is the most common environment people write code around here? Is there some de facto standard?
11:08:39 <Pythonfant> no idea
11:08:45 <Pythonfant> probably vim and emacs
11:08:53 <Pythonfant> just use whatever your comfortable with
11:09:03 <roconnor> darthdeus: my recent experience is "use Text.Parsec.Token when parsing anything of remotely trivial complexity; and this implies using lexeme parsers"
11:09:09 <Pythonfant> So far I didn't see a need for some complex editor/ide features
11:09:20 <Pythonfant> I just write something, load it up in a repl and play around with it
11:09:21 <Lutin`> roconnor: Have you tried attoparsec?
11:09:31 <roconnor> darthdeus: where a lexeme parser consumes all whitespace afterwards.
11:10:00 <roconnor> Lutin`: My understanding is attoparsec is for online parsing, and my recent use case has been for offline(?) parsing.
11:10:13 <roconnor> I haven't tried attoparsec
11:10:15 <danielszmulewicz> Pythonfant: Right. That sounds good enough. I'm trying to get my code display "good behavior" and play nice with the style guide.
11:10:42 <danielszmulewicz> Also, I've tried to make sense of Chris Done's dot emacs setup: https://github.com/chrisdone/chrisdone-emacs/blob/master/config/haskell.el
11:10:51 <danielszmulewicz> Pretty involved.
11:10:59 <sveit> is mapping/folding over [1..n] the best way in haskell to "loop" over numbers? the two alternatives I can think of are lists as monads and explicit recursion
11:11:22 <rrradical> is there a name for a function that does mapping with an accumulated value? i.e. mapping and folding at the same time?
11:11:29 <sveit> i just try to keep my code clean of "syntactic sugar", and [1..n] feels very much like extra syntax and i'd like to avoid id
11:11:36 <sveit> it*
11:11:49 <danielszmulewicz> Pythonfant: thanks for your help.
11:11:58 <roconnor> darthdeus: I was avoiding using Text.Parsec.Token because "it looked kinda complicated".  Big mistake.
11:12:05 <Pythonfant> danielszmulewicz: you're welcome
11:12:19 <sveit> rrradical: can you provide a type? mapping is a strict subset of folding
11:12:21 <roconnor> danielszmulewicz: once I switchd to Text.Parsec.Token my life became a whole world better.
11:12:28 <sveit> rrradical: since map can be implemented in folds
11:12:30 <roconnor> opps
11:12:34 <roconnor> darthdeus: ^^
11:12:40 <rrradical> sveit: I wrote this function: mapfold :: (a -> b -> (a, b)) -> a -> [b] -> [b] -> (a, [b])
11:13:09 <Lutin`> roconnor: Ah yeah Text.Parsec.Token does seem to be a nice helper module
11:13:51 <roconnor> I suspect even if you don't use Text.Parsec.Token, just the idea of using lexeme parsers might be enough to save you a lot of pain.
11:13:55 <rrradical> sveit: so, yea, I guess it's technically just folding, but it's a convenience function
11:13:58 <sveit> rrradical: that looks like a fold, but why do you pass [b] twice?
11:14:19 <sveit> rrradical: it looks like nested folds
11:14:28 <rwbarton> @type mapAccumL
11:14:29 <lambdabot> (acc -> x -> (acc, y)) -> acc -> [x] -> (acc, [y])
11:14:38 <rrradical> the first are the mapped values thus far, and the second are the rest needing to be mapped
11:14:56 <monochrom> the first time I met Text.Parsec.Token, i was immediately attracted by its "always consumes trailing spaces". it solved a long standing dilemma of mine. soon, I used it to write up a lambda calculus parser pretty easily.
11:15:26 <rrradical> rwbarton: yes! thanks!
11:15:47 <roconnor> darthdeus: so I guess I could shorten the advice to: "use lexeme parsers"
11:16:16 <monochrom> later, when palomer ranted about his difficulty in writing a lambda calculus parser in parsec, I suggested the lesson I learned, I even showed him my code. but he was stubborn, he continued ranting.
11:16:54 <monochrom> I think part of his stubbornness was "but space has semantics, it's function application"
11:16:59 <roconnor> I recently implemented a langauge moderately more complex than the lambda calculus using parsec without trouble.
11:17:37 <darthdeus> roconnor: sorry was cooking food :) well my biggest issue with doing things with parsec is that i can't find these things explained anywhere
11:17:49 <roconnor> darthdeus: I agree.
11:17:56 <darthdeus> i mean I've looked at haddoc for Parsec.Token, but uhm ... not really sure how to use it
11:17:58 <Lutin`> I mean you're not throwing the spaces away so to speak, you're just turning them into `:`
11:18:13 <danielszmulewicz> Pythonfant: Oh, something else. C-c C-z will take you to the interpreter. But how do you get back to the buffer?
11:18:24 <roconnor> monochrom: Strange issue.  It' is adjecency that has semantics, not the spaces.  The spaces just give room for tokens to be adjacent. :)
11:18:39 <Pythonfant> danielszmulewicz: after all it's just a regular buffer
11:18:41 <roconnor> (without being identical)
11:18:42 <Pythonfant> so C-x C-o
11:18:52 <monochrom> space has semantics, it's left-associative function application. sure. that doesn't stop me from using a lexeme parser and simply "chainl1 term (return FunApp)"
11:18:53 <danielszmulewicz> Pythonfant: OK, got it.
11:19:35 <darthdeus> roconnor: it's similar to the whole "use applicative parser combinators instead of the monadic ones", though I can't find much on that either
11:19:35 <monochrom> yes roconnor, that is the right way to look at it
11:20:17 <monochrom> anyway, palomer rejected "chainl1 term (return FunApp)", and continued ranting
11:20:34 <roconnor> oh man, I should revisit using chainl now that I know what I'm doing.
11:21:13 <benzrf> is there a such thing as an isofunctor
11:21:29 <roconnor> the type for chainl looks insufficently general to me.
11:21:31 <benzrf> wait hmmm
11:22:29 <monochrom> or "foldl1 FunApp <$> many1 term"
11:22:36 <roconnor> darthdeus: I like the applicative style, but I don't think it is that big of an issue.  It probably won't make any difference to the correctness of your code.
11:23:14 <monochrom> in retrospect "foldl1 FunApp <$> many1 term" is more desirable, it doesn't abuse chainl1 with "the parser for the operator doesn't consume input" :)
11:23:27 <benzrf> hmmm
11:23:33 <benzrf> why does Traversable exist?
11:23:50 <benzrf> cant you implement sequence purely on top of Applicative and Foldable?
11:23:52 <monochrom> because its author existed
11:23:52 <benzrf> like
11:24:01 <roconnor> benzrf: nope
11:24:22 <benzrf> :t foldr (<*>) [] . fmap (flip (:))
11:24:23 <lambdabot>     Couldn't match type â€˜a1 -> [a1]â€™ with â€˜[a -> a]â€™
11:24:23 <lambdabot>     Expected type: [a1] -> [a -> a]
11:24:23 <lambdabot>       Actual type: [a1] -> a1 -> [a1]
11:24:28 <benzrf> eeehh?
11:24:33 <benzrf> oh wait
11:24:36 <benzrf> :t foldr (<*>) [] . fmap (:)
11:24:37 <lambdabot>     Couldn't match type â€˜[a1] -> [a1]â€™ with â€˜[a -> a]â€™
11:24:37 <lambdabot>     Expected type: a1 -> [a -> a]
11:24:37 <lambdabot>       Actual type: a1 -> [a1] -> [a1]
11:24:41 <benzrf> o.o
11:24:56 <roconnor> benzrf: won't work, but keep trying until you understand this.
11:24:59 <benzrf> oh wait derp
11:25:05 <benzrf> no hold on
11:25:09 <roconnor> benzrf: ideally keep trying in a private chat with lambdabot. :)
11:25:13 <benzrf> :t foldr
11:25:14 <benzrf> ;p
11:25:14 <lambdabot> (a -> b -> b) -> b -> [a] -> b
11:25:15 <glguy_> benzrf: This paper is worth reading if you're learning about Traversals and Applicatives http://www.cs.ox.ac.uk/jeremy.gibbons/publications/iterator.pdf
11:25:31 <roconnor> benzrf: probably want Data.Foldable.foldr
11:25:34 <roconnor> :t Data.Foldable.foldr
11:25:35 <lambdabot> Foldable t => (a -> b -> b) -> b -> t a -> b
11:26:06 <rwbarton> you can write lambda calculus without any spaces anyways, just use a lot of parentheses
11:26:09 <rwbarton> (foo)(bar)
11:26:18 <monochrom> I just found out that my lambda calculus parser doesn't even use Text.Parsec.Token. I simply wrote my own "lexeme p = do { x <- p; skipSpaces; return x }" and built everything on top of it. but I surely learned that trick from Text.Parsec.Token.
11:26:24 <roconnor> rwbarton: I just use the X combinator everywhere.
11:26:40 <monochrom> and it was not "p <* skipSpaces" because it was a long time ago before Applicative
11:26:56 <monochrom> err, X combinator?!
11:27:19 <monochrom> (was watching the X-Men movie a few days ago. confused now. :) )
11:27:34 <dwcook> X Combinator sounds like an X-Men spinoff series
11:27:48 <roconnor> monochrom: http://en.wikipedia.org/wiki/Combinatory_logic#One-point_basis
11:28:21 <monochrom> that is truly the Mystique combinator :)
11:28:27 <dwcook> If I'm not mistaken, doesn't that let you basically represent a computation with unlabeled trees?
11:28:37 <dwcook> Binary trees
11:28:44 <Lutin`> Gah all this makes me hate the CS program I'm in right now
11:28:48 <monochrom> yeah, sounds like so
11:28:55 <dfranke> {-# LANGUAGE DeriveDataTypeable, DataKinds, KindSignatures, GADTs, RankNTypes, TypeFamilies, TemplateHaskell, FlexibleContexts, StandaloneDeriving, NoImplicitPrelude, MultiParamTypeClasses, UndecidableInstances, PatternSynonyms, TupleSections, ParallelListComp #-}
11:29:21 <dfranke> (ok, so I don't actually have all those in the same module)
11:29:27 <roconnor> dfranke: I don't know how I feel about UndecidableInstances
11:29:38 <monochrom> this is fascinating and horrifying. I didn't know that it is possible "one combinator to rule them all, one application to bind them"...
11:29:50 <dfranke> roconnor: needed for mtl.
11:29:59 <roconnor> dfranke: really?
11:30:10 <EvanR> i seemed to have just missed the combinator of the century, what are we talking about?
11:30:12 * monochrom marvels at the huge like of dfranke's extensions :)
11:30:32 <benzrf> :t Data.Foldable.foldr (<*>) (pure []) . fmap (fmap (:))
11:30:33 <lambdabot> (Foldable t, Applicative f, Functor t) => t (f t1) -> f [t1]
11:30:39 <benzrf> ^so the issue is that that can only go to list
11:30:43 <monochrom> EvanR: scroll up and look for "One-point_basis" url
11:30:45 <benzrf> it cant do it in place on the structure
11:30:46 <dfranke> roconnor: (MonadReader r m) => MonadReader r (FooT m)
11:30:49 <EvanR> monochrom: i just joined
11:30:52 <dfranke> roconnor: that's undecidable.
11:30:58 <monochrom> http://en.wikipedia.org/wiki/Combinatory_logic#One-point_basis
11:31:02 <benzrf> i.e. sequence a tree /to a tree/
11:31:03 <EvanR> thx
11:31:08 <monochrom> :)
11:31:44 <roconnor> dfranke: really?
11:31:51 <darthdeus> could you guys show me a dumb example how to use the Text.Parsec.Token? i'm staring at the docs and just can't figure anything out
11:31:52 <dfranke> roconnor: yep. if 'r' were an associated type rather than a type parameter with a fundep, it would be fine.
11:32:03 <EvanR> ah the iota combinator
11:32:18 <dfranke> roconnor: but unfortunately, mtl predates ATs.
11:32:31 <roconnor> dfranke: I thought the fundep would be enough.
11:32:39 <darthdeus> maybe I just misunderstand how to use it though
11:32:40 <darthdeus> uhm
11:32:52 <flaggy> If I have a function that only works if the first argument is 1 or larger, how can I tell quickcheck that it must find an error whenever the first value is less than 1?
11:32:56 <benzrf> what does iota combinator do p:
11:33:30 <benzrf> also is it COM-bin-ay-tor or come-BINE-uh-tore
11:33:41 <dwcook> benzrf: I don't pronounce it either of those ways
11:33:53 <dwcook> Wait never mind I misread
11:33:54 <Lutin`> I pronounce it the first
11:34:11 <dwcook> I've never heard it pronounced the second way in fact
11:34:14 <EvanR> U f = (f S) K
11:34:19 <monochrom> darthdeus, my http://www.haskell.org/haskellwiki/Parsing_expressions_and_statements
11:34:22 <roconnor> darthdeus: IIRC the documentation was fairly clear.  You run makeTokenParser passing in a langauge definition based on one of the templateds.
11:34:36 <Lutin`> dwcook: Possibly deduced from the pronunciation of combinatorial
11:34:50 <augur> i think an interesting way to view monads is
11:34:52 <darthdeus> monochrom: thanks
11:34:55 <roconnor> darthdeus: And then unpack the field of the resulting GenTokenParser into your top level with a lot of boilerplate code.
11:35:09 <augur> monads are a way of going from n layers of m, to 1 layer of m, for any choice of n
11:35:13 <roconnor> monochrom: that is a very nice link
11:35:41 <augur> a -> m a   and   m (m a) -> m a   together suffice for that
11:35:51 <roconnor> monochrom: oh man, I should totally pattern match on the top level like that.
11:35:54 <augur> m^n a -> m a    is just iterated join
11:35:57 <monochrom> hehehe!
11:36:06 <augur> :t join.join
11:36:07 <lambdabot> Monad m => m (m (m a)) -> m a
11:36:12 <augur> :t join.join.join.join.join
11:36:14 <lambdabot> Monad m => m (m (m (m (m (m a))))) -> m a
11:36:38 <EvanR> or 0 layers to 1 ;)
11:36:40 <monochrom> augur, you're missing (a->b)->(m a -> m b)
11:36:43 <Lutin`> :t iterate join
11:36:44 <lambdabot>     Occurs check: cannot construct the infinite type: a ~ m a
11:36:44 <lambdabot>     Expected type: m (m a) -> m (m a)
11:36:44 <lambdabot>       Actual type: m (m a) -> m a
11:36:46 <augur> EvanR: yes. n to 1, for any n!
11:36:54 <augur> monochrom: ?
11:37:01 <diginet> http://neilmitchell.blogspot.com/2007/03/describing-haskell-to-ada-programmer.html
11:37:16 <diginet> that right there is everything that is wrong with the haskell community, my god the smug, it makes me hurt
11:37:21 <augur> monochrom: its implicit that we're talking about functorial structure :p
11:37:26 <monochrom> ok!
11:37:29 <augur> i wonder what it means to be 2-centric instead of 1
11:37:44 <rwbarton> roconnor: you can even more deviously pattern match with TokenParser{..} = ..., I think
11:37:48 <monochrom> then you get to call it "dyad" :)
11:37:52 <augur> monochrom: :p
11:37:59 <roconnor> rwbarton: with puns
11:38:02 <rwbarton> yeah
11:38:08 <EvanR> diginet: "so ada, hows the failure of space rockets going these days?"
11:38:11 <rwbarton> which I don't really like
11:38:19 <augur> or   m (m (m a)) -> m a   and   a -> m (m a)
11:38:30 <augur> call that negativad
11:38:33 <rwbarton> but in this case, it's more okay since the names you bring into scope don't shadow the record field extractors, because those are qualified, I think
11:38:35 <augur> negatad
11:38:57 <Profpatsch> How do I chain parsers?
11:39:17 <monochrom> depends on what "parser" you're using
11:39:20 <Profpatsch> where metaSep = char ":" <*> space
11:39:22 <Profpatsch> Parsec
11:39:25 <diginet> there is so much smug, using (by which usually means blogging about) Haskell doesn't make you a genius
11:39:41 <Profpatsch> But space takes no argument.
11:39:48 <monochrom> then there are <*>, >>=, >> etc depending on what you mean
11:39:56 <EvanR> thats a general problem with blogging
11:40:07 <monochrom> char ':' <* space
11:40:40 <Profpatsch> Oh, Iâ€™m silly.
11:40:42 <Profpatsch> Right.
11:40:43 <monochrom> there are about half a dozen operators for half a dozen different senses of "chaining". always ask a concrete question.
11:40:48 <benzrf> come-BINE-uh-tore sounds right to me
11:40:55 <benzrf> cuz combine = come-BINE
11:41:03 <monochrom> either that, or read the docs thoroughly three times a day
11:41:04 <benzrf> so combinator = come-bINE-uh-tore
11:41:05 <Profpatsch> monochrom: Yeah, I guess Applicatives are the best for Parsec, right?
11:41:11 <benzrf> Profpatsch: not always
11:41:13 <dwcook> benzrf: A lot of English isn't so straightforward.
11:41:16 <benzrf> depends on the context sensitivity
11:41:17 <monochrom> not always. but very handy.
11:41:18 <benzrf> dwcook: pfft
11:41:26 <monochrom> again, depends on your task
11:41:26 <diginet> EvanR: how does this channel have so many users? how is it that so many people manage to TALK about haskell, and yet, there seems to be mostly just toy code? I swear, if see yet another "ZOMG QUICKSORT"
11:41:40 <monochrom> when will people learn "the solution depends on the problem"?
11:41:48 <benzrf> diginet: lol
11:41:58 <benzrf> diginet: i feel like youre probably a troll
11:42:06 <diginet> benzrf: I'm not
11:42:08 <Profpatsch> diginet: Iâ€™m using Parsec right now.
11:42:09 <diginet> I'm annoyed
11:42:11 <monochrom> why are people looking so hard for "do you have an advice that works for all problems?"
11:42:14 <flaggy> also, I'm using test-framework and it doesn't seem to print "collect" data :(
11:42:21 <flaggy> from quickcheck
11:42:32 <dwcook> diginet: A little bit of research would've helped you not seem like a troll.
11:42:36 <monochrom> you know what, I can answer that too. don't solve any problem. go sleeping.
11:42:47 <diginet> I was looking for comparisons between Haskell's type system and others
11:42:50 <diginet> came across that blogpost
11:42:55 <diginet> I just hate the smug
11:43:09 <benzrf> diginet: k m8
11:43:16 <NemesisD> anyone have any suggestions for tracking down "thread blocked indefinitely in a STM transaction" error?
11:43:52 <roconnor> monochrom: once you have a single combinator, then you don't even need to write it as it is implicit,  You can just use a bunch of parentheses.
11:43:58 <monochrom> diginet: so look for a non-smug blog post. or don't try blog posts at all.
11:44:25 <EvanR> i agree with the latter
11:44:59 <diginet> monochrom: I know, I just was curious, but it made me think that Haskell has *serious* cultural problems
11:45:07 <diginet> mostly with people thinking their geniuses for using it
11:45:13 <benzrf> diginet: oh, but we are
11:45:17 <diginet> gag
11:45:26 <benzrf> diginet: look, i can use the (>>=) operator!
11:45:32 <benzrf> diginet: i bet you dont even know what it DOES
11:45:36 <benzrf> look how cool it looks <3
11:45:38 <diginet> and an extremely high signal to noise ratio
11:45:50 <EvanR> sees your >>= and raises a =<<
11:46:00 <benzrf> why not (>=>)
11:46:06 <NemesisD> haskellers in twitter are picking up the reputation of being religious zealots
11:46:09 <benzrf> or even
11:46:09 <Lutin`> Bet you can't use Monads in your imperative language you peasant
11:46:09 <EvanR> you just went all in
11:46:21 <Lutin`> ..oh wait you can?
11:46:31 <benzrf> (Category..)
11:46:40 <diginet> NemesisD: what annoys me are people who cannot understand why you would ever use anything besides Haskell
11:46:51 <benzrf> diginet: but why would you ???
11:46:51 <diginet> declarative type programming is generally not good for hard real itme
11:46:53 <benzrf> haskell is perfect
11:47:05 <monochrom> I understand why I use java, actually.
11:47:05 <benzrf> you could not possibly find a better language for a single application
11:47:16 <Saizan> diginet: uh, but of course you can use something else, there's Agda, Coq ...
11:47:32 <diginet> Saizan: heh
11:47:36 <EvanR> a type system specifically designed for hard real time would probably make hard real time easier to get right
11:47:45 <Lutin`> garbage collected languages in general probably aren't the best for hard real time
11:47:50 <diginet> they aren't
11:47:54 <dwcook> diginet: You seem to have made up your mind already and just want to let people know what you think. Why not write a blog post instead?
11:48:00 <NemesisD> honestly what percentage of the industry requires hard realtime though
11:48:08 <NemesisD> the people who need that know what they're looking for
11:48:24 <monochrom> diginet, I invite you to stay here for a week and observe, without presumption, what kind of people are here. without presumption inspired by what you saw elsewhere.
11:48:28 <EvanR> i have a hard real time requirement, all requests must be serviced in under an hour
11:48:33 <diginet> NemesisD: my point is that needs exist outside of what Haskell is good for, and many haskellers seem to be willfully obliviousy to that
11:48:53 <benzrf> diginet: willfully oblivious?
11:48:55 <dwcook> diginet: It's possible I misread something intended as sarcastic, and if so, sorry :)
11:49:02 <benzrf> diginet: i would never do such a thing :-O
11:49:04 <Lutin`> eh many in the channels you frequent maybe
11:49:05 <diginet> dwcook: no no it's fine
11:49:12 <diginet> Lutin`: I'm not on here often
11:49:18 <diginet> though I don't see how it has so many users
11:49:26 <Lutin`> I meant channels in the general term, not IRC
11:49:29 <diginet> oh
11:49:35 <Lutin`> i.e. Twitter, blogs, reddit, etc.
11:49:48 <diginet> Twitter is so so so so bad
11:49:51 <diginet> I hate twitter so much
11:49:54 <glguy_> It's your own fault if you are looking at Twitter
11:50:00 <benzrf> diginet: but http://twitter.com/PLT_HULK
11:50:03 <NemesisD> diginet: the ones i see proselytizing it as the one true way or not after those use cases. they're after web dev and other mainstream technologies
11:50:32 <NemesisD> diginet: i've *never* seen one of these people giving realtime software devs crap for not using haskell
11:50:34 <Lutin`> The same goes for python too though
11:50:53 <diginet> Lutin`: to be far, Python is MUCH MUCH MUCH worse in that respect than Haskell
11:50:59 <diginet> Python has an awful toxic community
11:51:02 <Lutin`> Yeah..I know..
11:51:09 <EvanR> python is still going on?
11:51:12 <monochrom> (pun) I never give people a real hard time for not using haskell :)
11:51:12 <diginet> not as bad as Ruby, but worse
11:51:16 <Lutin`> Every project I work on at my current job is in Python ... :{
11:51:27 <diginet> also, Haskell is competently designed
11:51:44 <Lutin`> And all of them in Django
11:51:47 <diginet> NemesisD: but here's the thing, it bothers me that people think Haskell is the one true way
11:51:54 <diginet> if you like it, it's fine
11:51:54 <benzrf> ruby community seems better than python's to me
11:51:59 <benzrf> #ruby is v friendly vs python
11:52:03 <benzrf> you're even allowed to say lol
11:52:11 <diginet> benzrf: maybe they've been humbled, ruby is hemorrhaging users
11:52:12 <joelteon> Does anyone know how to express the pattern Rec {..} in Template Haskell?
11:52:21 <diginet> or so I understand
11:52:26 <NemesisD> diginet: i honestly think its out of frustration. new technologies come and get so much excitement and are often times miles behind haskell in many ways
11:52:35 <diginet> NemesisD: I can see that
11:52:39 <benzrf> diginet: they say that MINASWAN
11:52:51 <benzrf> diginet: perhaps the rails community is more toxic than the non-rails community
11:52:52 <benzrf> :-)
11:53:04 <Lutin`> ugh rails don't get me started
11:53:04 <monochrom> haha "probabilistic programming already exists"
11:53:06 <_deepfire> you didn't see the lisp community..
11:53:07 <NemesisD> i do ruby dev, what is ruby hemorrhaging users to?
11:53:15 <diginet> it annoys me with Python, "ZOMG GAIZ LOOK AT THIS NEW FEETURRE PYTHON HAZZZ" yeah. . .you mean that thing Lisp had 40 years ago?
11:53:19 <glguy_> joelteon: I don't think you can (just looking at the available constructors)
11:53:19 <diginet> NemesisD: maybe it's just Rails
11:53:21 <NemesisD> go? node? equally shitty technology?
11:53:33 <diginet> NemesisD: Node is dsigustingly terrible
11:53:36 <diginet> Go is meh
11:53:46 <diginet> Node is the WORST way to do concurrency
11:53:52 <Lutin`> I hate that node.js performs better on benchmarks than warp
11:53:55 <joelteon> glguy_: well, that seems crazy.
11:53:55 <glguy_> diginet: Are you seriously belittling Python after complaining about a blog post belittling Ada?
11:53:58 <_deepfire> imagine how sad Lisp people get, because nobody seems to understand metaprogramming and staged compilation yet..
11:54:02 <NemesisD> yet people love it. something is seriously wrong with our industry's bullshit detectors
11:54:03 <benzrf> glguy_: i was about to say that!
11:54:22 <diginet> _deepfire: the difference is, Ada is actually good at what it does
11:54:25 <benzrf> diginet: you seem awfully snooty and critical for somebody who claims to be upset by snootiness and criticality
11:54:27 <joelteon> I'll install haskell-src-meta and see if it can convert it to something.
11:54:47 <benzrf> diginet: maybe you just dont like people disagreeing with you
11:54:56 <_deepfire> I watch how the OCaml guys design their ppx metaprogramming extensions -- and I want to weep..
11:55:02 <monochrom> NemesisD: I resolved that "they're humans too, they can't be better than humanity."
11:55:24 <diginet> benzrf: okay to be fair, I'm in a bad mood. . .python is okay I guess, I just hate it's community"
11:55:31 <hexagoxel> maybe a more constructive question is "is there a list of not-too-small, well-writen, open-source haskell programs (whose purpose is nothing related to haskell)?"
11:55:34 <diginet> you're right
11:55:41 <monochrom> this is a good time to cue my: http://www.vex.net/~trebla/humour/tautologies.html #1
11:55:43 <benzrf> hexagoxel: the classic example is xmonad
11:55:44 <benzrf> ;)
11:55:59 <_deepfire> lambdacube is of a significant promise
11:56:00 <joelteon> well this is weird!
11:56:05 <monochrom> everything you're complaining is a problem of human nature
11:56:11 <joelteon> you can't produce record wild cards using template haskell.
11:56:15 <joelteon> the world has gone crazy
11:56:16 <benzrf> bye later
11:56:19 <_deepfire> ..but it's a library, not a program, so not fair
11:56:32 <diginet> darcs?
11:56:40 <diginet> darcs is really cool, unfortunately kind of slow
11:56:44 <NemesisD> i think things might start going better when a few *high profile* projects get built in haskell, and not in a humble and quiet fashion
11:56:46 <glguy_> cryptol is non-small and open source now :)
11:56:59 <diginet> what confuses me is how many users this channel has
11:57:04 <diginet> join #python
11:57:07 <diginet> oops
11:57:19 <Lutin`> Most python users I know don't know what IRC is
11:57:25 <NemesisD> and preferably ones where people switch from the language-of-the-day like node or go to Haskell, drop LOC by half, increase performance, etc
11:57:33 <Lutin`> By the time you get to knowing what Haskell is you probably know what IRC is
11:57:35 <platz> I think I like git-annex better an an example, because xmonad uses haskell as config it's kind of falling under your "whose purpose it related to haskell" rule
11:57:44 <diginet> Lutin`: ooh, that's a good point
11:57:55 <NemesisD> because if a company replaces a bunch of Java EE with Haskell, the kids are going to scoff that anything is better than Java
11:58:08 <diginet> NemesisD: Scala?
11:58:09 <Lutin`> Plus I'd say this channel is more actively advertised
11:58:16 <diginet> Lutin`: true
11:58:41 <diginet> I just really don't see Haskell ever being a non niche language, and Node proves that
11:58:43 <NemesisD> diginet: no constructive comment on Scala, I don't use it. I've seen enough of its syntax and design though to make my stomach turn though
11:58:58 <Lutin`> People hate on Java, but JVM can be sexy when it comes to performance
11:59:01 <diginet> yeah I don't like it either, but it is vaguely functional-ish
11:59:10 <diginet> Lutin`: oh I agree, the JVM gets way too much hate
11:59:22 <diginet> I wish parrot was coming along better though :/
11:59:23 <monochrom> shapr made this channel a nice place to lurk in and chat. most people here can't use haskell in jobs. doesn't mean they can't stay here and consider haskell a hobby
11:59:26 <Lutin`> At least in web dev which is where I'm unfortunately at right now
11:59:37 <NemesisD> diginet: on the bright side, Scala is probably the closest language to Haskell to gain adoption. There's some overlap in communities. Maybe Scala folks will look to greener pastures at some time
11:59:37 <diginet> Lutin`: I feel ya man :/
11:59:39 <diginet> I am too
11:59:56 <diginet> NemesisD: yeah Scala is getting big, I've seen tons of activity in it
12:00:04 <diginet> Node is unequivocally awful, and its popularity makes me sad
12:00:18 <platz> relevant: https://michaelochurch.wordpress.com/2014/06/06/why-programmers-cant-make-any-money-dimensionality-and-the-eternal-haskell-tax/
12:00:23 <rwbarton> joelteon: hmm interesting
12:00:24 <diginet> my boss, while a nice guy, is woefully unknowledgable about programming, he only knows PHP
12:00:28 <diginet> it's terrible
12:00:38 <rwbarton> joelteon: when I try quoting it in ghci it produced RecP Data.Maybe.Just []
12:00:58 <NemesisD> my boss simultaneously just heard about Haskell, "loves" Scala and says we can't use Haskell because it requires high IQ
12:01:00 <rwbarton> joelteon: but that's also what it produced for quoting Just {} (as opposed to Just {..})
12:01:00 <joelteon> rwbarton: with haskell-src-meta, I get an error about non-exhaustive patterns in 'toFieldPat'
12:01:02 <Lutin`> Anyways we're getting a wee be off topic, chaps :)
12:01:06 <Lutin`> bit*
12:01:14 <rwbarton> hmm maybe this is because Just doesn't have any named fields
12:01:16 <joelteon> so I'm gonna guess template haskell doesn't do record wild cards
12:01:26 <joelteon> maybe this code can be rewritten without
12:01:43 <NemesisD> that's literlly how the conversation went. "I love Scala. What's Haskell. We can't use it, our offshore dev team isn't smart enough"
12:01:45 <_deepfire> joelton, I thought you could construct any AST in TH
12:01:50 <rwbarton> yeah when I quote my own type I get RecP Ghci2.X [(Ghci2.x,VarP x_1627416991)]
12:01:54 <diginet> NemesisD: lel
12:01:54 <joelteon> how odd.
12:02:02 <joelteon> _deepfire: tab complete my name
12:02:04 <Lutin`> NemesisD: *cringe*
12:02:15 <diginet> if Haskell requires a high IQ, then PHP deletes IQ
12:02:25 <diginet> PHP is the only language I know of that I like nothing about
12:02:29 <Lutin`> If they're anything like the ones some of our clients have, I wouldn't put it past them
12:02:29 <rwbarton> I guess the record wildcard got desugared before quoting
12:02:29 <_deepfire> joelteon, wasn't there a way to convert a String to an AST?
12:02:42 <joelteon> _deepfire: haskell-src-exts has it but it also has its own AST representation
12:02:48 <NemesisD> "I love square wheels. What are round wheels? We can't use round wheels, our engineers aren't smart enough"
12:02:48 <diginet> as much as it pains me to say it, I find the times when I deal with JavaScript much less painful
12:02:53 <joelteon> and there's an incomplete conversion function
12:03:07 <joelteon> I'm guessing there are better channels to discuss how other languages suck, right?
12:03:15 <_deepfire> oh, sorry for noise then
12:03:19 <Lutin`> There's #haskell-chat iirc
12:03:20 <joelteon> no problem
12:03:30 <geekosaur> #haskell-blah?
12:03:34 <Lutin`> Oh that
12:03:46 <Lutin`> _deepfire: You're fine
12:04:01 <NemesisD> yeah i'll stop derailing this channel. sorry. i actually did start all this with an actual Haskell question
12:04:46 <NemesisD> does anyone have any techniques for tracking down "thread blocked indefinitely in an STM transaction" errors
12:05:10 <davean1> NemesisD: does -xc help?
12:05:35 <_deepfire> heh, is there a channel for the intersection of nixos and haskell?
12:05:39 <rwbarton> joelteon: you should request it on trac
12:05:53 <joelteon> I think I will
12:06:05 <rwbarton> joelteon: but I guess you can always reify the data type and implement it yourself
12:06:28 <NemesisD> davean1: not completely, is there any way to get line numbers in those traces?
12:06:58 <Lutin`> Holy crap
12:07:07 <Lutin`> Google updates the log for this channel really fast
12:07:27 <Lutin`> https://www.google.com/search?q=%22thread+blocked+indefinitely+in+an+STM+transaction%22+debug
12:07:28 <davean1> NemesisD: you can set names for expressions
12:07:31 * roconnor is hearing the siren call of unsafeInterleaveIO
12:07:47 <davean1> NemesisD: Frankly, the entire concept isn't really well defined to begin with
12:07:54 <Lutin`> Oh wait that's a different person asking the same question
12:09:30 <Tjr> I'd like to generalize a library function slightly (Fractional instead of Float etc). In other languages, I'd try to write a macro to rewrite the library. What's the haskell best practise in that situation?
12:10:33 <Lutin`> NemesisD: Code paste might help
12:11:20 <NemesisD> this is officially a hard project to paste but its up on github, i can push what i'm working with
12:14:12 <NemesisD> Lutin`: https://github.com/michaelxavier/seraph i notice the exception when i feed it a config that isn't going to work, the default example.conf does it for me. so if you were to get all the deps set up and run: cabal run example.conf you'll see it
12:14:52 <Lutin`> In the future I suggest pushing to a separate branch :)
12:14:57 <rwbarton> Tjr: either patch the library and (maintain the patched version yourself or get the patch merged upstream) or simply copy the library code into your project
12:15:13 <Lutin`> But TBH I'm probably not the one to answer this, just figured such a thing would help
12:15:16 <rwbarton> how would you do this with a macro?
12:15:28 <NemesisD> Lutin`: i don't bother much with branches until i am actually approaching a releaseable branch
12:15:41 <NemesisD> releasable version*
12:15:44 <Lutin`> ah I use the hell out of branches
12:15:49 <Tjr> rwbarton: with a macro: write a file that (1) defines macro, (2) sources the library source, (3) applies the macro to the library.
12:16:15 <Lutin`> and rebase
12:16:24 <rwbarton> this sounds like it relies on details of the library implementation
12:16:45 <Tjr> rwbarton: ok, thanks. so haskell doesn't have a magic bullet for every situation :-)
12:16:59 <rwbarton> if you're relying on the library implementation to not change then you may as well just copy it and edit it
12:19:47 <aspidites> how do i get windows to recognize the cabal-install that I have installed locally?
12:20:00 <aspidites> i've already added %APPDATA%\cabal\bin to %PATH%
12:20:04 <rwbarton> Tjr: this kind of thing doesn't fit in with the philosophy of Haskell. if I write a function in a library I can change the definition and as long as it's semantically equivalent you can't observe the change
12:20:49 <rwbarton> (and semantical equivalence is not "identical ASTs")
12:21:03 <monochrom> aspidites: then it should work. order matters. apart from that, I don't know why it would not work.
12:21:07 <Tjr> well, in my case, it's not equivalent. I'm doing cookie-cutter changes.
12:21:28 <aspidites> its last, so i'll try reordering them monochrom
12:21:30 <Tjr> or at least indenting to (let me stay honets)
12:22:08 <aspidites> actually ,that makes sense
12:22:18 <aspidites> it's probably getting to the global one before the local one when path resolves
12:22:38 <eyebloom> How does one turn a haskell function into a C function pointer?
12:22:49 <aspidites> yep, thanks again monochrom
12:22:53 <rwbarton> Tjr: I mean the library author could make a change to an equivalent function, but braeeak your macro
12:23:10 <monochrom> must you make a pointer? normal export is not enough?
12:23:10 <Tjr> rwbarton: true.
12:23:20 <aspidites> or not...hmmm
12:23:25 <rwbarton> wow what happened to my backspace key
12:23:50 <Lutin`> suddenly boxes
12:24:11 <eyebloom> I see. Iâ€™m just hoping to make a callback for SDL itâ€™s looking for something of type FunPtr (Word32 -> Ptr () -> IO Word32)
12:24:22 <eyebloom> Sorry SDL2
12:24:49 <eyebloom> So far I have something of type IO (Ptr (t0 -> t1 -> IO b0))
12:24:56 <rwbarton> eyebloom: something involving either "wrapper" or "dynaicmic"
12:25:15 <Lutin`> rwbarton: That is a strange predicament indeed
12:25:25 <rwbarton> help
12:25:26 <monochrom> it's "wrapper" for this direction
12:26:26 <eyebloom> In which library is wrapper?
12:26:35 <rwbarton> part of the FFI
12:27:10 <monochrom> ok, find the doc of "Foreign.Ptr", go to the "Function pointers" section, pay attention to the example that has "wrapper", do something similar, use the thing similar to the mkCompare there
12:27:13 <Lutin`> rwbarton: What OS are you on?
12:27:30 <Lutin`> It's inputting the unicode delete symbol instead of actually deleting
12:27:35 <monochrom> the other two examples there don't concern your direction
12:27:41 <rwbarton> uh, I am on debian using mosh to connect to an Ubuntu server running screen
12:27:54 <rwbarton> I restarted mosh and it seems fine for now ...
12:28:10 * rwbarton will blame mosh
12:28:17 <aspidites> ok, it works after a re-login
12:28:48 <rwbarton> Lutin`: what unicode delete symbol was it inputting?
12:29:09 <rwbarton> U+007F?
12:29:12 <Lutin`> U+2421
12:29:25 <Lutin`> Or 0xE290A1 in hex
12:29:53 <monochrom> freeHaskellFunPtr is available on both the haskell side and the c side (maybe under a different name).
12:29:56 <Lutin`> well first is UTF-16 second is UTF-8
12:30:26 <Lutin`> http://vazor.com/unicode/c2421.html
12:30:46 <rwbarton> well, too weird for me, I will pretend it never happened
12:30:54 <Lutin`> Yeah that sounds best...
12:31:53 <Lutin`> You could report it, but since you don't have a way to reproduce might not be too useful
12:33:02 <monochrom> I have a sick example in which: I import a C function, then I make a FunPtr of it and hand it back to C...
12:33:07 <Lutin`> NemesisD: You should add a LICENSE file :P
12:33:32 <eyebloom> thank you
12:33:54 <NemesisD> Lutin`: lol yeah
12:34:05 <Lutin`> NemesisD: So what triggers it?
12:34:07 <eyebloom> Love to see that.
12:34:19 <Lutin`> I just did `cabal run example.conf` and it's running
12:35:01 <NemesisD> Lutin`: woah. for me it triggers right here https://github.com/MichaelXavier/Seraph/blob/master/src/Seraph/Core.hs#L134
12:35:28 <Lutin`> git status?
12:35:47 <NemesisD> Lutin`: yeah i pushed it specifically for debugging. what version of ghc are you using?
12:35:50 <Lutin`> You sure we have the same codebase
12:35:57 <Lutin`> Ah
12:36:03 <Lutin`> This VM is still on 7.6.3
12:36:16 <monochrom> I just read more and realized it is more sick than that. the imported C function takes a function pointer and calls it. I give it a FunPtr made from itself. so I'm telling it to call itself very indirectly.
12:36:24 <NemesisD> oh man maybe this is a bug with 7.8. i'm on 7.8.2
12:36:47 <Lutin`> are they supposed to run in the background?
12:36:51 <monochrom> it's in http://www.vex.net/~trebla/haskell/ghc-conc-ffi.xhtml last section, so scroll to the end and find the coding example there
12:36:58 <NemesisD> Lutin`: do you have access to 7.8 anywhere? i'd be interested to see if it reproduces on that for you
12:37:29 <NemesisD> Lutin`: it forks and spawn child processes. when you shut down the process you may want to kill any "watch date" processes. i had like 30 running from debugging for the last hour
12:37:41 <Lutin`> hmm
12:37:46 <Lutin`> I can just update to 7.8
12:37:49 <NemesisD> although if the program is working correctly it should actually kill those for you
12:38:07 <NemesisD> Lutin`: i don't want to force you into a huge yak shave or anything :P
12:38:34 <monochrom> I have a less sick, more useful example in https://github.com/treblacy/xchat-plugin-haskell-toy . find it in Whee.hs
12:38:56 <Lutin`> This is on 7.6.3 http://lpaste.net/290648266645700608
12:40:09 <NemesisD> Lutin`: i'm surprised those processes are still labeled seraph. those should either be dead or the processes in the config
12:40:55 <Lutin`> They're also orphaned
12:41:51 <NemesisD> Lutin`: yeah that may be a bug in the actual spawning code, i may need to invoke more unix runes to spawn child processes
12:42:33 <monochrom> why do I keep coming up with these sick ideas of self-reference :)
12:42:55 <NemesisD> Lutin`: i fork, twiddle the file descriptors with dupTo, and call executeFile which i'm assuming is doing execv or something. i may need to do something else to ensure they die when the parent dies. the program has logic to kill its children on shutdown though
12:43:23 <Lutin`> installing ghc-7.8.2 let's see what happens
12:43:57 <Lutin`> thankfully avoided a system update so far, this VM is about 6 months old lol
12:44:00 <Lutin`> and it's on Arch
12:44:02 <matheus23> is there some haskell library that has data structures for mathematical expressions like "2 + a * (b + c) ^ 4 + log(n)"? And wich lets me operate on it (for example multiply it by 4 or (maybe) solve expressions)
12:44:21 <NemesisD> Lutin`: this is what we call a terrible repro case if this is a ghc bug :(
12:44:27 <NemesisD> Lutin`: i'm running arch as well
12:44:35 <matheus23> me too ^^
12:44:45 <vanila> matheus23, you can easily just make a tree data type, add some operators and define a num instance - solving for particular variables is extremely hard though
12:44:49 <Lutin`> so you know how bad `pm -Syu` could have gone lol
12:45:02 <Lutin`> almost typed by reflex
12:45:04 <NemesisD> lol
12:45:15 <matheus23> I use yaourt
12:45:28 <Lutin`> yeah me too
12:45:44 <Lutin`> but I did: ln -s /usr/bin/yaourt /usr/bin/pm
12:45:53 <matheus23> huh, why "pm" then?
12:45:55 <Lutin`> because I'm lazy and didn't want to use aliases
12:46:25 <monochrom> matheus23: https://github.com/colah/HaskSymb may have something really slick and inspiring
12:47:00 <Lutin`> NemesisD: You using a sandbox?
12:47:03 <matheus23> monochrom: Oh that looks nice! And now I know how it's called: "Symbolic Algebra" right.. Now I can google, thank you :)
12:47:06 <NemesisD> Lutin`: yep
12:47:13 <Lutin`> k good
12:47:26 <NemesisD> *points to scars* i know better
12:47:57 <Lutin`> matheus23: You could also use Parsec, but that might be more involved that you're looking for
12:48:16 <matheus23> okay. But yeah I don't think I'll use parsec
12:49:37 <NemesisD> i wish it was straightforward to have multiple ghc versions on one machine and switch between them
12:49:51 <geekosaur> hsenv?
12:51:00 <NemesisD> geekosaur: oh interesting. i thought it was just a predacessor to cabal sandboxes. didn't know it did different haskell versions. do you know if it plays well with cabal sandboxes
12:51:35 <monochrom> don't you just "./configure --prefix=/usr/local/ghc-7.18.42" and then play with PATH?
12:52:05 <geekosaur> I don't think it does, its notion is more that you'd install stuff "globally" in its sandboxed ghc-s
12:52:06 <Lutin`> It's on the hackage page how to do it
12:52:36 <NemesisD> yeah reading that now. i may give this a try
12:52:49 <NemesisD> i'm playing risky games with my limited disk space here
12:53:15 <hayashi> Risky Games, a horror film about the Health and Safety Executive
12:54:55 <NemesisD> ahh damnit. hsenv doesn't build on 7.8
12:55:17 <NemesisD> HEAD does though!
12:56:36 * hackagebot stm-chunked-queues 0.1.0.0 - Chunked Communication Queues  http://hackage.haskell.org/package/stm-chunked-queues-0.1.0.0 (kholdstare)
12:58:31 <Lutin`> NemesisD: yep
12:58:36 <Lutin`> Doesn't work on 7.8.2
12:58:55 <NemesisD> Lutin`: hsenv or my program?
12:59:01 <Lutin`> Yours
12:59:08 <NemesisD> aahhh! wat do?
12:59:53 <monochrom> do you accept playing with PATH to switch between ghc versions?
13:00:03 <Lutin`> *shrugs*
13:00:06 <Lutin`> Beyond me
13:00:15 <Lutin`> @NemesisD
13:00:15 <lambdabot> Unknown command, try @list
13:00:30 <NemesisD> so is this likely to be an STM bug then?
13:03:36 <geekosaur> the semi-principled way to "playing with $PATH" would be modules.sourceforge.net or the various successors
13:03:40 <Lutin`> It could also be a bug that the previous one worked
13:03:53 <Lutin`> really no idea
13:04:29 <benzrf> bbiab
13:07:24 <NemesisD> its unfortunate Tekmo doesn't come in here too often anymore. this is using his MVC library and I'm curious if I'm doing something not smart here
13:08:32 <johnw> NemesisD: he's responsive to e-mail
13:10:13 <monochrom> I only just two shell functions to play with path. http://www.vex.net/~trebla/tmp/playpath.txt
13:14:57 <parc> what's the difference between ErrorT and EitherT?
13:15:49 <NemesisD> johnw: ah ok. i may give that a try. thanks
13:15:54 <Lutin`> holy crap it's 4 PM already
13:16:05 <Lutin`> I thought it was maybe 12 or 1
13:16:06 <johnw> it's Pi Time here
13:16:19 <Lutin`> gotta go, seeya guys
13:16:58 <NemesisD> johnw: actually does he publish his email publically? i don't see it on his site
13:17:41 <johnw> I found it by googling
13:17:50 <johnw> oh, no
13:17:51 <Lutin`> It's on hackage
13:17:58 <johnw> I found it by looking at haskell-cafe
13:18:05 <NemesisD> ah got it. thanks
13:18:14 <Cale> parc: The instances for ErrorT have Error e superclass constraints
13:18:33 <johnw> that Error e constraint is surely a beloved thing, isn't it
13:18:58 <glguy_> transformers-0.4 now has an ExceptT alongside its ErrorT
13:19:26 <glguy_> You can write code that works against both by including transformers-compat
13:19:29 <Profpatsch> Is there a way to look up Docstrings from ghci or from Emacs?
13:19:42 <glguy_> (both 0.4 and the 0.3 that comes with your GHC)
13:19:50 <Profpatsch> More than the :type and :info stuff.
13:19:56 <parc> so is one more preferable?
13:23:49 <glguy> I like the transformers route because it's one of the core libraries, but it's up to you
13:36:13 <EvanR> a while back i was wondering about a Text-like type but for Ascii text
13:36:43 <EvanR> i just stumbled upon http://hackage.haskell.org/package/text-latin1-0.3 and data checked, wow
13:37:04 <EvanR> these are interesting ideas for using the type system to represent evidence about values
13:37:37 <Profpatsch> I have to dispatch from a list of string tokens that could be parsed ("title:", "author:", â€¦) to the actual Constructor that is going to be used for that. In other languages (Python, Lisp) Iâ€™d use something like a hash map. Howâ€™d you do it in Haskell?
13:38:19 <EvanR> use a case, a Map, or a parser
13:39:29 <EvanR> the parser uses the right constructor or fails
13:40:21 <EvanR> or you could group all those fields in one record
13:41:38 <Profpatsch> Oh, I think I know how to do it now.
13:42:01 <Profpatsch> I looked at it from a wrong angle.
13:42:19 <Profpatsch> I am IN a parser and I can use <|> and define a few more parser functions.
13:42:50 <johnw> Profpatsch: often you use Applicative to construct data while parsing
13:44:42 <Profpatsch> johnw: Like here? http://ocharles.org.uk/blog/posts/2012-12-10-24-days-of-hackage-parsec.html
13:44:49 <Profpatsch> (longer example)
13:44:54 <johnw> right
13:45:12 <EvanR> data-checked seems awesome, i was thinking about something like this for a different language, its cool that haskell can do all this unexpected stuff with type classes
13:46:42 <tdrgabi> hi. if you're just starting with haskell, but coming from erlang (so fp is not new), which libs/stack would you use for a new hobby website?
13:46:52 <tdrgabi> there are lots of tutorials, but I don't know what community uses now.
13:47:03 <johnw> you mean, to build the web server, on just to build static pages?
13:47:13 <johnw> I'd probably look at snap first
13:47:25 <johnw> it's probably a medium on the abstraction scale
13:48:11 <tdrgabi> johnw: some light backend, db work and js/backbone for frontend. js is optional, if the lib provides frontend capabilities.
13:48:26 <tdrgabi> johnw: I'll take a look at snap.
13:48:28 <tdrgabi> thank you.
13:50:44 <zzing> I am learning haskell (again) to use with web stuff, and some research (masters) related work. Is 'Real World Haskell' (I have the book) [still?] a good resource for learning the language, or are there better resources now?
13:54:34 <cow_2001> there's a myriad of database interfaces in www.haskell.org/haskellwiki/Applications_and_libraries/Database_interfaces
13:54:45 <cow_2001> where do i even start ;_:
13:54:50 <EvanR> mysql_simple
13:54:55 <EvanR> or postgres_simple
13:55:02 <cow_2001> woah
13:55:28 <imalsogreg> zzing: I don't know of any thing better that's taken its place. There are a couple things that are a little out of date, but not many. Of course there's Learn You a Haskell now too (if that wasn't around when you learned last time), which is different from RWH and also terrific.
13:56:03 <cow_2001> EvanR: can i use them while being ignorant of sql queries?
13:56:07 <jophish> What's going on here:
13:56:11 <jophish> @seett hello
13:56:11 <lambdabot> |-|e1|O
13:56:12 <zzing> imalsogreg, I think it was, but a little too cartoony â€” but can still work :P
13:56:13 <EvanR> cow_2001: no
13:56:18 <jophish> @seet hello
13:56:19 <lambdabot> |-|E1l0
13:56:38 <rwbarton> spelling correction gone mad
13:56:54 <cow_2001> EvanR: i have an sql phobia. could i use some abstract layer on top?
13:56:57 <rwbarton> fun puzzle, figure out (in pm) what the real name is
13:57:03 <jophish> @leet hello
13:57:03 <lambdabot> |-|EL|0
13:57:05 <jophish> aha
13:57:10 <EvanR> personally i cant stand when my queries take 4-6 seconds because of the abstraction layer
13:57:11 <Lutin`> cow_2001: Why the phobia/
13:57:16 <EvanR> for ~ 100 things
13:57:26 <rwbarton> ok i guess it wasn't that hard a puzzle
13:57:27 <EvanR> but theres probably something in there that works
13:57:59 <EvanR> cow_2001: _simple libs make it really easy to use sql without the usual associated cruft
13:58:35 <cow_2001> Lutin`: 1. it's a new language to learn. 2. it has minutea and subtleties.
13:59:10 <EvanR> if you dont know sql and dont want to, maybe you should try a different kind of database
13:59:32 <jophish> @tell yitz I just found out that 'flip flip flip flip = flip flip flip flip flip'
13:59:32 <lambdabot> Consider it noted.
13:59:35 <cow_2001> also, what's up with all of those nosqls? they say they're a bad idea.
13:59:50 <EvanR> they are web scale
14:00:18 <cow_2001> i'm not a CS person with very little background.
14:00:20 <groovy2shoes>  /dev/null is web scale
14:00:38 <cow_2001> I've heard they have problems with atomic transactions
14:00:43 <cow_2001> it might be just FUD
14:01:21 <EvanR> doing database adminsitration of some sort, youre about to learn a lot ;)
14:01:28 <haasn> jophish: flip flip flip flip = flip flip flip too
14:02:01 <jophish> haasn: of course!
14:02:05 <jophish> cool
14:02:35 <haasn> and flip flip flip = \x -> flip x flip = \x y -> x y flip ?
14:02:44 <cow_2001> EvanR: what do you think of nosqls?
14:03:46 <haasn> It looks like concat (replicate n "flip ") for n > 3 is = \x y -> x y flip
14:03:48 <haasn> whatever that tells us
14:03:57 <EvanR> i usually model my data using something like relational algebra because its more resilient to changes in requirements than nested trees of lists of values, but many people use relational techniques in nosql anyway
14:04:04 <haasn> I have no idea
14:04:20 <EvanR> which has nothing to do with sql
14:05:14 <cow_2001> EvanR: resilient to change...?
14:05:58 <monochrom> whenever you're asked "there is a huge debate on X, what do you think?", with more than 99% probability you're right to answer, "that debate is worthless" regardless of X.
14:06:43 <cow_2001> sigh
14:07:07 <TallerGhostWalt> monochrom: what about x = "typed vs untyped"?
14:07:28 <warpy> unityped
14:07:29 <monochrom> I am on the typed side, but that debate is also worthless
14:07:36 <cow_2001> TallerGhostWalt: 1%
14:07:55 <TallerGhostWalt> cow_2001:lol, good answer
14:08:02 <warpy> selection bias. this is #haskell
14:08:32 <TallerGhostWalt> so if cabal isn't a package manager, have there been any attempts to make one?
14:08:33 <haasn> TallerGhostWalt: perfect example
14:08:48 <EvanR> typed vs untyped, the relational vs oop debate of the 10s ;)
14:08:50 <haasn> TallerGhostWalt: â€œuntypedâ€ languages are just languages with sufficiently unexpressive type systems
14:09:08 <haasn> there's no distinction
14:09:28 <haasn> So the comparison is between what individual type systems / languages can support; not some sort of general category or rule
14:11:17 <warpy> TallerGhostWalt: cabal isn't a package manager?
14:11:26 <avaritia> hey guys is there a way to filter mzero in a list?
14:11:42 <TallerGhostWalt>  warpy: well there is a blog post about how it isn't... I get a little lost in the reasoning.
14:11:50 <mirpa> how do you write backslash in comment on hub.darcs.net?
14:12:41 <warpy> :t \xs -> filter (/= mzero) xs
14:12:42 <lambdabot> (MonadPlus m, Eq (m a)) => [m a] -> [m a]
14:13:02 <warpy> avaritia: for filter out ^
14:13:07 <TallerGhostWalt> at some sick point in haskell I started sort of liking cabal hell... I think it means I am developing stolkholm syndromed.
14:13:15 <TallerGhostWalt> syndrom
14:13:25 <avaritia> warpy: hmm can you explain to me then why i cannot do pattern matching on it, like f mzero = 0  ?
14:13:34 <warpy> TallerGhostWalt: but didnt the sandboxes solve it?
14:13:54 <warpy> avaritia: what error do you get
14:13:55 <mirpa> TallerGhostWalt: at least you have nice cage (sandbox)
14:13:57 <geekosaur> avaritia, you can only pattern match on constructors. `mzero` is not a constructor
14:14:03 <TallerGhostWalt> lol
14:14:10 <jophish> const const const = const
14:14:17 <avaritia> warpy: i'm not getting an error i'm simply getting match for mzero all the time
14:14:20 <avaritia> geekosaur: thanks
14:14:28 <benzrf> avaritia: it's treating it as a var
14:14:29 <benzrf> i.e.
14:14:36 <benzrf> > let mzero = 3 in mzero
14:14:37 <lambdabot>  3
14:14:40 <jophish> id id = id
14:14:43 <benzrf> avaritia: you could use (==) if the value is an Eq instance
14:14:44 <geekosaur> yes, becuase it doens't look like a constructor, it looks like a binding --- menaing it always matches and binds that name to the matched whatever
14:15:00 * geekosaur eyes finfers warily
14:15:27 <TallerGhostWalt> I think I just need to change the order in which we extract stuff
14:15:37 <TallerGhostWalt> I think we might, extract stuff too early on my team
14:15:40 <avaritia> benzrf,geekosaur: that explains everything thank you
14:15:49 <TallerGhostWalt> so we are constantly clobbering libs.
14:15:52 <jophish> ($) ($) = ($)
14:16:21 <benzrf> jophish: k
14:16:33 <benzrf> > let c' c' c' = c' in c' 3 4
14:16:35 <lambdabot>  Conflicting definitions for â€˜c'â€™
14:16:35 <lambdabot>  Bound at: <interactive>:1:8-9
14:16:35 <lambdabot>            <interactive>:1:11-12
14:16:36 <jophish> Although those are not quite as cool as the fmap or flip ones
14:16:38 <benzrf> o:
14:16:47 * hackagebot haste-markup 0.0.1.0 - A port of blaze-markup and blaze-html to Haste  http://hackage.haskell.org/package/haste-markup-0.0.1.0 (AnupamJain)
14:16:56 <benzrf> :t flip flip
14:16:57 <lambdabot> b -> (a -> b -> c) -> a -> c
14:17:00 <benzrf> :t flip flip flip
14:17:02 <lambdabot> (a -> ((a1 -> b -> c1) -> b -> a1 -> c1) -> c) -> a -> c
14:17:23 <jophish> I wonder if there's a list of these cool identities
14:17:53 <chrisdone> does anyone use opengl or glut from inside ghci?
14:18:04 <jophish> chrisdone: I can't imagine doing that easily
14:18:53 <geekosaur> chrisdone, I think they're known to work poorly because they use thread local storage and ghci sandboxing (in pre-7.8) futzes with that. then there are other complications on windows and os x
14:19:16 <sindikat> Hi! I was trying to install Yi. I have an error:   Data/Aeson/Encode.hs:37:66:     Module `Data.Scientific' does not export `scientificBuilder'
14:19:24 <sindikat> google doesn't help. what should i do?
14:19:33 <monochrom> chrisdone: normally, ghci does a forkIO on almost each command you enter. this defeats those kind of libs. -fno-ghci-sandbox helps
14:19:40 <chrisdone> hm, darn. the simple demo (here: http://www.haskell.org/haskellwiki/OpenGLTutorial1) used to work from ghci in the past, but today there're GL errors
14:20:26 <chrisdone> monochrom: i'll try that
14:20:37 <aspidites> how do i tell ghc to use a different mingw?
14:20:43 <monochrom> "-dno-black-holing: Turn off black holing (probably doesn't work)" hahaha
14:21:15 <chrisdone> haha, yeah, i saw the same option while browsing ghc's options
14:21:21 <chrisdone> best kind of documentation!
14:21:25 <aspidites> i'm trying to compile an app that uses hsqml, but it errors out. hsqml's documentation suggests that it has to do with the different mingw's in ghc vs qt
14:21:38 <j4s0n> !snippet memory management features
14:21:44 <johnw> chrisdone!
14:22:13 <EvanR> hsqml = haskell sql html?
14:22:14 <j4s0n> etfinger!
14:22:17 <monochrom> what is !snippet?
14:22:20 <haasn> warpy: I think â€œcabal isn't a package managerâ€ is mainly the excuse for not having to implement features a package manager should have
14:22:31 <aspidites> unlike linux, compiling ANYTHING on windows seems to be a bit of a mess, so i'm hoping that rather than having to recompile ghc or Qt, i can just point ghc to a different set of mingw tools
14:22:38 <warpy> haasn: which feature
14:22:44 <chrisdone> http://lpaste.net/4868882537151201280 -- do any GL experts recognise this kind of problem? it only arises in ghci, if i compile with ghc it runs fine
14:22:59 <haasn> updating, removing and changing packages without breakage, for example
14:23:09 <haasn> solving dependency issues
14:23:25 <haasn> these are things cabal does actively try not to handle; even though it in principle could
14:23:30 <haasn> cabal-install, that is
14:24:16 <TallerGhostWalt> haasn: yeah that would all be nice
14:24:27 <Lutin`> chrisdone: Try `LIBGL_DEBUG=verbose glxinfo | grep direct`
14:24:33 <haasn> It is possible, however, to use a package manager for your haskell environment
14:24:39 <haasn> like portage or nix
14:25:05 <chrisdone> Lutin`: direct rendering: Yes
14:25:09 <Lutin`> hmm
14:25:14 <Lutin`> chrisdone: Try `LIBGL_DEBUG=verbose glxinfo | grep dri`
14:25:25 <TallerGhostWalt> haasn: but with sandbox add and remove?
14:25:54 <Lutin`> chrisdone: What platform are you on
14:26:03 <sindikat> haasn: hey, i just tried to install Yi thru cabal, had an error with dependency Aeson. Installed Aeson separately, now Yi installed correctly. Is that related to what you're describing?
14:26:16 <haasn> TallerGhostWalt: sandbox is a work-around, I think. You can still break stuff inside sandboxes, but then you can just nuke it and re-install. Sandboxes has made the rm -rf ~/.cabal pattern easier and more contained
14:26:19 <haasn> I think.
14:26:27 <chrisdone> Lutin`: that's blank. i'm on ubuntu. note: if i ghc --make DevelMain &&. ./Develmain it runs fine. it's just in GHCi that it shows this GL error
14:26:33 <Lutin`> ah
14:26:55 <TallerGhostWalt> haasn: yeah, I would just love cabal sandbox remove-package some-pkg --all
14:26:58 <haasn> sindikat: I guess so
14:27:02 <Lutin`> I just see `libGL error: failed to load driver: swrast` as the issue
14:27:12 <haasn> TallerGhostWalt: I've never actually needed that
14:27:42 <haasn> TallerGhostWalt: Anyway, another reason why sandboxes are a work-around is that you duplicate a *lot* of effort because you pull in all your dependencies into the local sandbox for every single thing you build
14:27:50 <Profpatsch> So it works for a simple case, but the code is very dirty still. I hate how I compare with Strings in the case.
14:27:50 <haasn> I think a package manager would generally try and re-use packages
14:27:52 <Lutin`> chrisdone: Try running GHCi with LIBGL_DEBUG=verbose
14:28:05 <chrisdone> Lutin`: okay let me seeâ€¦
14:28:05 <TallerGhostWalt> haasn: I agree, I guess I just feel like we are a long long way from that
14:28:12 <Profpatsch> Can someone look over this short function please: https://bigmac.caelum.uberspace.de/paste/parse-metatags.hs.html
14:28:35 <Profpatsch> I donâ€™t know how else to do it without comparing strings.
14:28:35 <monochrom> wow, I have to turn off CSS for that
14:28:36 <TallerGhostWalt> haasn: where getting some removal stuff to link together cabal sandbox hc-pkg and regular stuff is approachable
14:28:38 <haasn> TallerGhostWalt: We sure are, although there's been progress. Enough work-arounds exist, either way. I personally use portage but I've been really interested in trying out nix for that kind of stuff
14:28:40 <chrisdone> Lutin`: http://lpaste.net/1349465109356871680
14:29:10 <TallerGhostWalt> haasn: i am going to check into both these tools , nix I have heard of... portage no
14:29:13 <Lutin`> hmm
14:29:14 <chrisdone> Lutin`: it seems that GHCi is distorting the settings for GL: libGL: screen 0 does not appear to be DRI2 capable
14:29:18 <Lutin`> Yeah
14:29:25 <Lutin`> You need to install the mesa-dri-drivers
14:29:30 <Lutin`> not sure what package that is on Ubuntu
14:29:37 <Lutin`> at least I think that's the problem
14:29:56 <Lutin`> can you paste all of `LIBGL_DEBUG=verbose glxinfo`
14:29:56 <chrisdone> you don't think i have the drivers already if the compiled binary works?
14:30:05 <Lutin`> true...
14:30:25 <_deepfire> strace -f -eopen ?
14:30:41 <_deepfire> ..the working binary vs. the ghci one
14:31:21 <monochrom> Profpatsch: I have an idea
14:31:54 <warpy> haasn: you can use shared sandboxes for reusing packages
14:31:55 <exicer> Is there some way to force a conduit that is reading from a file to send the whole document downstream ?
14:32:01 <haasn> TallerGhostWalt: portage is Gentoo's native package manager. I don't know if you can (easily) use portage without using Gentoo. But I know that you can (easily) use portage inside GEntoo for your haskell packages
14:32:04 <exicer> er the whole file that is
14:32:05 <warpy> but ya, i agree with you
14:32:19 <haasn> warpy: Share enough and you're back at the square one of having global packages though, I think :p
14:32:40 <warpy> nah. use a shared sandbox for a bunch of related projects
14:32:41 <TallerGhostWalt> haasn:  Is Gentoo the most common linux env for hackage installs? I hear a lot about it
14:32:42 <Profpatsch> monochrom: If I could return Constructors with getKind I could pattern match for that, but these Constructors all take different types of arguments.
14:33:14 <Profpatsch> monochrom: So that wouldnâ€™t type-check.
14:33:15 <TallerGhostWalt> warpy: I do that for sure, shared sandboxes are awesome... I have a dir for yesod sandbox and one for lens < 4 and > 4
14:33:24 <dagle> Does ghc support a clean flag for cleaning up after a ghc --make?
14:33:39 <warpy> haasn: how is portage different from apt-get in terms of installing haskell packages
14:33:39 <monochrom> how could that be? "Title <$> many anyChar" and "Author <$> many anyChar" look compatible
14:33:52 <haasn> TallerGhostWalt: Almost certainly not, the most common are most likely in the family of debian derivatives I'd guess
14:33:52 <monochrom> at any rate, I have more than one idea
14:34:15 <Profpatsch> monochrom: Yeah, but I got stuff like Flow [SectionLabel] and Duration Seconds, too.
14:34:47 <Profpatsch> With this method I have to duplicate the information, and itâ€™s strings, too.
14:34:55 <TallerGhostWalt> haasn: That was what I figured, and why I am running what I am.  But still seems to be a lot of love for Gentoo
14:35:18 <warpy> is there a way to have instances collapsed by default in haddock generated docs
14:35:28 <warpy> except supplying my own css
14:35:33 <haasn> warpy: The main difference would probably be that it allows building haskell packages directly from hackage or git repositories, which is something I personally do a lot
14:36:03 <chrisdone> eh, i give up. just wanted to see whether glut would run in ghci. n/m. thanks chaps
14:36:14 <warpy> haasn: that sounds great! i have no idea how they build debs out of hackage packages
14:36:18 <Lutin`> chrisdone: Yeah looks like someone had the same issue 2 months ago
14:36:55 <haasn> warpy: Neither do I, but I know how they build gentoo packages (ebuilds) out of hackage packages; there's a program called â€œhackportâ€ which does all of the work for you (except for very complicated packages) - there's a similar script for Nix. I don't know about other package managers
14:37:29 <Profpatsch> haasn: There should be one for Arch, too, since they support hundreds of packages with two maintainers.
14:37:48 <warpy> somehow all the major packages on hackage end up on debian and ubuntu repo. i don't know who does that.
14:38:02 <haasn> The fairies
14:38:07 <Lutin`> chrisdone: Apologies
14:38:25 <TallerGhostWalt> lol
14:38:33 <Lutin`> chrisdone: Oh it was 14 months ago, looks like a long standing issue
14:38:57 <Lutin`> http://ircbrowse.net/browse/haskell?q=ghci+opengl
14:38:57 <TallerGhostWalt> haskell has a lot of faries
14:38:58 <_deepfire> and it looks like it's something stupid, on the surface
14:39:08 <TallerGhostWalt> things just randomly get faster and better
14:39:27 <Profpatsch> monochrom: I could think about a Map that maps String -> Parser.
14:39:30 <monochrom> Profpatsch: http://lpaste.net/105247 should be least redundant and pretty generalizable to your other cases
14:40:01 <monochrom> oops, I have a typo there. fortunately, lpaste supports a kind of in-place update!
14:40:20 <monochrom> done
14:40:44 <monochrom> anyway, the goal "a string literal appears only once" is achieved.
14:41:17 <chrisdone> i had the devious idea that i could use my cheeky ghci reloading trick to update the GL rendering function in-place rather than doing hard restarts
14:41:33 <chrisdone> but it seems now even getting it to run in the first place is now a challenge in and of itself =)
14:41:34 <EvanR> haha
14:41:35 <Profpatsch> monochrom: Thanks, I see where I can go with this.
14:41:39 <haasn> How come parsec requires explicit â€˜tryâ€™ to be able to backtrack but attoparsec does not? Aren't they in similar performance ballparks, or is there some degenerate case in attoparsec where explicit try would have been a lot better?
14:41:54 <monochrom> one more typo
14:42:13 <monochrom> such is the peril of cut-n-paste :)
14:43:01 <chrisdone> backtracking is a performance hit
14:43:06 <Profpatsch> haasn: Parsec says this in <|>: â€œThis non-backtracking behaviour allows for both an efficient implementation of the parser combinators and the generation of good error messages.â€
14:43:08 <chrisdone> so attoparsec throws it out, i think
14:43:21 <haasn> Oh, error messages is a really good point I hadn't considered
14:43:47 <EvanR> haasn: "This combinator is provided for compatibility with Parsec. attoparsec parsers always backtrack on failure."
14:43:53 <EvanR> attoparsec try docs
14:44:02 <haasn> yes, I'm aware that attoparsec always backtracks - that's why I was asking
14:44:05 <haasn> How come it can always backtrack
14:44:08 <haasn> But parsec can't?
14:44:16 <chrisdone> oh, interesting
14:44:22 <Lutin`> The way that it consumes input
14:44:51 <Lutin`> iirc try in Parsec saves the string it's parsing to go back to
14:45:04 <haasn> Oh, attoparsec is also not a monad transformer
14:45:05 <Lutin`> Attoparsec, at least now, uses cursors
14:45:18 <monochrom> it is a trade-off. spending tons of memory vs offending tons of programmers
14:45:44 <haasn> Lutin`: I guess this is because it's specialized towards strict data structures like ByteString or Text?
14:46:15 <Lutin`> Yes and incremental input
14:46:19 <EvanR> parsec just makes you have to explicitly decide to backtrack because of the cost, attoparsec is higher performance so treats it as a default
14:46:25 <haasn> Or at least ones that can be indexed very easily given a known index
14:46:48 <haasn> Would it be possible to make attoparsec even higher performance by making backtracking explicit?
14:46:50 <Lutin`> idk not an attoparsec/Parsec pro
14:47:01 <EvanR> haasn: i dont think so
14:47:03 <chrisdone> i wouldn't've expected attoparsec to backtrack by default, good to know
14:47:06 <EvanR> just dont backtrack
14:47:15 <haasn> fair enough
14:47:49 <Emilie18>  Hi! I give you some videos. I hope you like! http://j.mp/Smyc8S
14:47:57 <chrisdone> presumably the memory of keeping around the input stream at every conjunction adds some GC cycles
14:48:41 <chrisdone> but probably not enough for it to matter for speed
14:48:46 <EvanR> yeah how does it backtrack really far away when doing a giant incremental parse
14:49:10 <koala_man> how would I turn a [Maybe t] into Maybe [t] only if all elements are Just?
14:49:15 <chrisdone> :t sequence
14:49:17 <lambdabot> Monad m => [m a] -> m [a]
14:49:29 * chrisdone blows smoke from his lambdagun
14:49:30 <koala_man> nice, thanks
14:49:43 <EvanR> haha
14:50:08 <Tene> koala_man: For your "only if" part, you'll need to specify what you do when that's not the case
14:50:20 <bitemyapp> koala_man: catMaybes
14:50:30 <bitemyapp> koala_man: give a list of Maybe t, it'll drop all the Nothings
14:50:30 <Tene> And it'll have to be the same type, too.  Do you want Just []?  Nothing?
14:50:31 <haasn> I think he meant into a [t] only if all elements are Just, with the failure being encoded via Maybe [t]
14:50:41 <bitemyapp> koala_man: just be aware you might get []
14:50:57 <j4s0n> chrisdone: remember Shadrach Meshack and Abednego
14:51:05 <bitemyapp> koala_man: so combine the catMaybes with a pattern-match, if you get [], return Nothing
14:51:07 <koala_man> haasn's psychic powers are the most accurate
14:51:16 <bitemyapp> koala_man: my answer is based on what you wanted mate :)
14:51:22 <haasn> Because that's the question that makes the most sense
14:51:23 <chrisdone> pappy can parse in linear time (it's a packrat), but it uses recursive do notation/mfix which is a little awkward when the parser is large
14:51:33 <koala_man> bitemyapp: that's not what I want :P
14:51:41 <bitemyapp> koala_man: you can use length before/after if you want to see if *any* dropped.
14:51:52 <bitemyapp> koala_man: alternately, write your own function.
14:51:58 <koala_man> bitemyapp: or just use sequence
14:52:22 <chrisdone> > sequence [Just 1,Just 2]
14:52:24 <lambdabot>  Just [1,2]
14:52:24 <chrisdone> > sequence [Just 1,Nothing,Just 2]
14:52:25 <bitemyapp> koala_man: yeah sequence is nicer
14:52:26 <lambdabot>  Nothing
14:52:32 <bitemyapp> <--- disregard OP, he is idiot
14:52:34 <bitemyapp> sigh.
14:52:44 <monochrom> hehe
14:52:50 <Profpatsch> monochrom: Look, I contracted it even further: http://lpaste.net/105251
14:52:51 <chrisdone> @bitesnack
14:52:51 <lambdabot> :)
14:53:09 <TallerGhostWalt> hmm i need to read more about ghci, is there a way to customize the libs that are autoloaded?
14:53:13 <TallerGhostWalt> I wanna add shelly
14:53:25 <chrisdone> TallerGhostWalt: -package shelly will add it
14:53:31 <Profpatsch> monochrom: On the Basis that a Tag is written as "Metatag: some information"
14:53:41 <monochrom> yes
14:53:41 <chrisdone> -hide-package monads-tf will hide monads-tf, which everyone always does
14:53:48 <Profpatsch> With the label not case sensitive.
14:53:49 <haasn> Profpatsch: you could probably eliminate the (<$> many anyChar) too
14:54:05 <haasn> I'm guessing Title and Artist have the same type
14:54:15 <TallerGhostWalt> chrisdone: awesome! thanks
14:54:19 <Profpatsch> haasn: Iâ€™ll see, there are about 10 other constructors with different types.
14:54:21 <chrisdone> TallerGhostWalt: you can also specify -hide-all-packages if you really want to start from *scratch* =)
14:54:29 <haasn> Fair enough!
14:54:53 <chrisdone> TallerGhostWalt: they can be passed either when you launch the program, or via :set <the-flags>, fwiw
14:54:55 <TallerGhostWalt> chrisdone: hmm... maybe use something like Basic Prelude instead
14:55:03 <TallerGhostWalt> What about defaulting OverloadedStrings enabled?
14:55:33 <chrisdone> pass -XOverloadedStrings to the program, or :set -XOverloadedStrings in the REPL, or add that line in a .ghci file
14:55:35 <haasn> chrisdone: I use ghc hide monads-tf # or whatever the syntax is, for that
14:55:54 <haasn> Actually, I don't, because I don't have monads-tf installed
14:55:58 <haasn> I'm not sure what still uses it
14:56:10 <chrisdone> i think the version of lens i have to use at work requires it
14:56:16 <chrisdone> directly or transitively
14:56:37 <haasn> chrisdone: I like to get into the habit of using :seti instead of :set for interactive commands, especially for stuff like OverloadedStrings, because then they don't affect external files you load
14:56:46 <haasn> It can be really confusing to have a file work in GHCi but not when trying to actually compile it in GHC
14:56:51 <TallerGhostWalt> chrisdone: thx again
14:56:58 <haasn> (due to the :set affecting the file when loading interactively)
14:57:07 <chrisdone> haasn: :seti is a thing?
14:57:25 <haasn> Yes, it's like :set but the option only affects interactive usage
14:57:33 <chrisdone> ah, it arrived in ghc 7.6
14:57:41 <haasn> Oh, I did not know that
14:57:49 * chrisdone still stuck on ghc 7.4 at work, knows not of the wonderful things outside of that
14:58:18 <TallerGhostWalt> loving 7.8.2
14:58:27 <TallerGhostWalt> cept the error log has some sort of weird line limit
14:58:28 <monochrom> 7.4 is a bit old, yeah. that's the only major complaint against fpcomplete :)
14:58:31 <chrisdone> we're upgrading to 2.8 soon
14:58:56 <haasn> chrisdone: Use the unsafeness of GNTD as an argument to switch to 7.8 immediately!
14:59:15 <haasn> How can you be sure you're writing code that won't launch missiles otherwise
14:59:31 <haasn> (except when you're writing code to launch missiles, of course)
14:59:33 <chrisdone> what if i'm writing code for launching missiles?
14:59:37 <chrisdone> =p
14:59:44 <haasn> main = atomically $ launchMissilesSTM
14:59:44 <TallerGhostWalt> ooh joke beat
14:59:51 <monochrom> GNTD = global nuclear thermo detonation?
15:00:02 <haasn> launchMissilesSTM >> retry
15:00:07 <chrisdone> Would you like to play a game of chance?
15:00:21 <sbrg> chrisdone: Tell them that that particular feature request is impossible and that it will not be included in any versions of their nuclear missile submarines
15:00:26 <sbrg> regardless of what they say
15:00:28 <monochrom> did you know: there is a detonative semantics?
15:00:34 <TallerGhostWalt> async launchMissles >>= hide >>= wait
15:01:20 <monochrom> err, detonational semantics. http://article.gmane.org/gmane.comp.lang.haskell.cafe/85386/
15:01:33 * chrisdone tries really hard to think of a pun on â€˜operationalâ€™
15:01:53 * chrisdone 's nose starts to bleed
15:02:28 <monochrom> perhaps the "surgical operation" kind
15:02:57 <monochrom> oh, how about: Operation Detonational Semantics? :)
15:03:14 <monochrom> it's a military operation to blow up something :)
15:03:20 <chrisdone> unsafePerformCutTheBlueWire
15:03:28 * chrisdone reverts back to old reliable unsafePerform jokes
15:03:53 <sbrg> > reliable
15:03:54 <lambdabot>  Not in scope: â€˜reliableâ€™
15:03:56 <sbrg> > unsafe...
15:03:58 <lambdabot>  <hint>:1:10:
15:03:58 <lambdabot>      parse error (possibly incorrect indentation or mismatched brackets)
15:04:02 <sbrg> not you, lambdabot
15:04:16 <chrisdone> haha:
15:04:17 <chrisdone> zen semantics:
15:04:17 <chrisdone>     ah!
15:04:55 <chrisdone> reality isn't words or concepts, reality isâ€”
15:04:56 * chrisdone hits gong
15:06:05 <Chousuke_> I assume a missile launch action would involve black operational semantics.
15:06:29 * Chousuke_ leaves
15:06:29 <chrisdone> chousuke_: huehuehue
15:08:40 <chrisdone> monochrom: :3 https://github.com/haskell/haskell-mode/blob/f7f1a1794eb92b51cf3d0d054aa78565a93e188b/haskell-complete-module.el
15:10:28 <chrisdone> monochrom: c.m.s -> Control.Monad.State, n.w.a.s -> Network.Wai.Application.Static, d.fol -> Data.Foldable =)
15:10:50 <chrisdone> t.rx -> Text.Regex, etc.
15:10:54 <monochrom> "Maximum items to display in minibuffer." scares me.
15:11:08 <chrisdone> why?
15:11:22 <monochrom> it implies that the minibuffer could become huge
15:11:32 <haasn> chrisdone: Can I get this for vim?
15:11:47 <chrisdone> haasn: yeah, write some vimscript =p
15:12:10 <monochrom> isn't it better to use a completion buffer for this?
15:12:12 <chrisdone> monochrom: only as large as ido-mode
15:12:41 <chrisdone> monochrom: for me, no. this pretty much replicates how ido-mode looks and acts, just with a different way to do matching
15:13:01 <monochrom> I see
15:13:07 <chrisdone> (ido-completing-read "Module: " (haskell-session-all-modules)) vs (haskell-complete-module-read "Module: " (haskell-session-all-modules))
15:13:30 <chrisdone> do you use inf-haskell?
15:13:36 <monochrom> yes
15:13:44 <chrisdone> haasn:
15:13:57 <chrisdone> oops
15:14:08 <monochrom> what we need for vim: an elisp plugin
15:14:13 <haasn> I don't know what inf-haskell is
15:14:26 <chrisdone> monochrom: heh
15:14:56 <chrisdone> haasn: that was meant for monochrom, i mistyped. inf-haskell's an emacs way to talk to ghci
15:15:15 <chrisdone> monochrom: not a fan of interactive-mode?
15:15:36 <Francis49> hello all dear friends
15:16:28 <monochrom> I wouldn't know. I'm lazy. I just installed haskell-mode 2.8 a long time ago and did nothing further.
15:16:30 <diginet> monochrom: oh god that would be amazing
15:16:34 <diginet> troll mode, engaged
15:16:52 <sbrg> Okay, so I have.. build-depends: ... , threepenny-gui-0.4.2.0 and ghc-pkg with the sandbox db lists it as well. Yet cabal configure keeps telling me it's not there.
15:17:37 <chrisdone> monochrom: o _o
15:17:58 <chrisdone> i think 2.8 was written before haskell 1.4
15:18:10 <chrisdone> before unicode was invented
15:18:16 <chrisdone> before the internet
15:20:16 <monochrom> 2.8 = 1.4*2, yeah :)
15:20:16 <chrisdone> =p
15:20:16 <Francis49> hello monochrom, can i ask somethings?
15:20:16 <monochrom> yes. asking is free.
15:20:16 <Francis49> heheh right.
15:20:16 <chrisdone> it is? then did i pay for this stinking ticket?
15:20:16 <chrisdone> @slap everyone
15:20:16 * lambdabot beats up everyone
15:20:16 <hexagoxel> only the first question is free
15:20:16 <monochrom> the stinking ticket is for beverages
15:20:16 <Francis49> monochrom, for graphics in haskell, what library do you suggest? and where i can get it?
15:20:24 <Francis49> heheh the first only? hahaha
15:20:54 <haasn> I don't feel privileged to answer, but I hope I can feel free to suggest monochrom that he mention diagrams!
15:20:56 <monochrom> I think gloss is highly recommended? I am not familiar. find it and others on hackage.haskell.org
15:21:15 <monochrom> diagrams is good too
15:21:18 <chrisdone> i bet gloss works in ghci
15:21:22 * chrisdone grumbles quietly
15:21:35 <glguy_> gloss doesn't work in GHCi on OS X, but I think it does on Linux
15:21:40 <haasn> gloss and diagrams are for entirely different domains
15:22:03 <Francis49> gloss? it is general purpose? os specialized su something?
15:22:04 <haasn> diagrams is for â€œofflineâ€ static graphics and diagrams; gloss is good for generating dynamic or interactive vector graphics (but there are modules for raster graphics, too)
15:22:10 <chrisdone> speak of the author of the devil's package, and he shall appear
15:22:40 <monochrom> @quote monochrom shach
15:22:40 <lambdabot> monochrom says: * monochrom rubs @quote, and shachaf appears! he says, "what is your wish?"
15:23:00 <Francis49> i need something for chaos and fractals
15:23:31 <k00mi> Francis49: gloss is great for that
15:23:32 <chrisdone> sounds like a good pick-up line
15:24:01 <haasn> So is diagrams; but both are best at fractals you can describe as vector diagrams
15:24:09 <Francis49> ah, good then k00mi. this is what i need
15:24:20 <haasn> I'm not sure if either is optimal for something like rendering out your own (Int,Int) -> Color function
15:24:23 <haasn> I use repa for that
15:24:27 <haasn> +repa-devil or whatever
15:24:28 <monochrom> haha "not-gloss library: Painless 3D graphics, no affiliation with gloss"
15:24:40 <chrisdone> lol
15:24:59 <Francis49> i dont need 3d graphics at first
15:25:24 <chrisdone> it seems like graphics libraries take investment to assess
15:25:33 <chrisdone> and there are many of them
15:25:49 <chrisdone> i get the feeling some are created because authors couldn't be bothered assessing the existing crop
15:26:28 <Francis49> k00mi, do you used gloss?
15:27:04 <chrisdone> http://hackage.haskell.org/packages/#cat:Graphics
15:27:21 <chrisdone> force a thunk every time you see a description with "chart" or "simple graphics library" in it
15:27:30 <Francis49> thank you chrisdone, i will try the link
15:27:52 <k00mi> I did use it for some small fun stuff
15:28:24 <chrisdone> oo! http://hackage.haskell.org/package/ghci-diagrams
15:28:36 <k00mi> Francis49: here are some examples: http://gloss.ouroborus.net/
15:29:16 <tgeeky> chrisdone: you're not allowed to say 'oo!' about deprecated packages.
15:29:23 <chrisdone> =(
15:29:27 <monochrom> "deprecated in favor of activehs"
15:29:33 <chrisdone> tgeeky: what if i write it in reverse? =p
15:29:48 <Francis49> great dear friends, thank you very much
15:29:56 <chrisdone> monochrom: which is an odd deprecation because they don't seem to do the same thing
15:30:03 <monochrom> strange, activehs is an exe, no lib
15:30:07 <chrisdone> more like "we don't like this approach anymore but we like this one"
15:30:07 <Francis49> there are a lot i see
15:30:27 <Francis49> well dear friend, i go to see.
15:30:32 <tgeeky> chrisdone: that is acceptable, because the meaning changes to !oo, which means, unworth of oooo
15:30:46 <Francis49> thank you again and a nice day for all the friends in the channel
15:30:49 <chrisdone> tgeeky: Â¡oo
15:30:51 <Francis49> bye dear friends
15:31:17 <chrisdone> francis49: are you using an automatic translator?
15:31:21 <benzrf> do people actually use yi
15:31:25 <monochrom> I think there is a significant dose of "we no longer want to inflict raw haskell on students" :)
15:31:33 <Francis49> nope, sorry for my bad english
15:32:23 <chrisdone> francis49: it's fine =) i was just curious where "dear friends" came from, perhaps from a languaeg with more honorifics
15:32:33 <chrisdone> monochrom: indeed
15:33:02 <chrisdone> benzrf: i tried it out. it used a gig of memory and lagged when i typed so i just closed it and went back to emacs
15:33:12 <monochrom> haha
15:33:17 <benzrf> oh snap
15:33:23 <Francis49> nope chrisdone, hehehe, i learned a little englis by myself. whe i was young i studied franch
15:33:27 <benzrf> One Gigabyte And Constantly Swapping?
15:33:28 <benzrf> ogacs?
15:33:29 <monochrom> that may be a long time ago and no longer true
15:33:41 <sbrg> solution: add more gigabytes.
15:33:53 <monochrom> not the least because today you have 24G memory
15:33:54 <sbrg> Throw more $RESOURCE at it.
15:34:03 <haasn> Add more GigaHertz while you're at it
15:34:07 <Francis49> dear friends came from english i suppose
15:34:22 <monochrom> I mean, even I have a 12G-memory computer now
15:34:22 <Francis49> do you agree chrisdone
15:34:33 <benzrf> hmmm
15:34:46 <monochrom> Francis49: I think he's referring to culture, not just language
15:34:48 <chrisdone> monochrom: it wasn't swapping, i just mean that editing a simple file lagged so i looked at the memory usage and saw it using a gig and thought "well, that's not normal for an editor"
15:34:56 <haasn> I measure my computers in graph reductions per second
15:35:05 <benzrf> i wonder if it could be possible to have an operating system steeped in the concepts/princples of haskell the same way unix is steeped in the concepts/principles of C
15:35:11 <benzrf> is that what TUNES is
15:35:24 <chrisdone> i looked it up at the time, apparently there's a memory leak in the incremental parser
15:35:33 <Francis49> oh sure monochrom it is. thank you
15:35:49 <chrisdone> francis is so polite. i like francis
15:35:51 <tgeeky> can someone past an example of an impressive usage of djinn so I can impress someone? It's been a while.
15:36:27 <sbrg> look at what this guy who isn't me can do with this stuff!
15:36:38 <chrisdone> are there impressive uses of djinn? i was always impressed by what it implied could be done rather than what it actually does
15:36:45 <tgeeky> sbrg: exactly!
15:37:16 <monochrom> I'm pretty sure tgeeky will give credit to djinn rather than himself
15:37:24 <Francis49> thank you chrisdone. well, one time again a nice dai for you all. i go to see the link of the graphics link you give me. thanks again. bye all (dear friends)
15:37:36 <sbrg> don't you just have to rub the lamp and it will give you three wishes?
15:37:37 <chrisdone> ciao, francis
15:37:52 <Francis49> ciao chrisdone, :)
15:37:52 <monochrom> like if I show amazing haskell programs to friends, they think haskell is great, I'm just the messenger
15:38:05 <rwbarton> monochrom, we know the truth
15:38:10 <benzrf> @djinn (a -> b) -> (b -> c) -> (a -> c)
15:38:10 <glguy> ?djinn  ((a -> (b -> r) -> r) -> (a -> r) -> r) -> (a -> r) -> r
15:38:11 <lambdabot> f a b c = b (a c)
15:38:11 <lambdabot> f a b = a (\ c _ -> b c) b
15:38:34 <haasn> Blah, that's what I was about to paste
15:38:41 <tgeeky> that second one is complicated enough :o
15:38:49 <haasn> The second one is callCC
15:40:28 <chrisdone> "what's callCC?"
15:41:06 <haasn> I don't know, but I know that djinn can derive it and that makes it impressive
15:41:09 <chrisdone> â€œwell, it'sâ€¦â€ one hour later, â€œso that's what continuations are. anyway, back to why haskell is cool. wake upâ€
15:41:11 <altern> Hi all. Could somebody explain why I get "Partial _" when I execute string "parse stringToVN ( BS.pack "12" )" with the following code? http://lpaste.net/105254
15:41:19 <monochrom> my http://www.vex.net/~trebla/haskell/cont-monad.xhtml has callCC examples
15:41:29 <monochrom> oh, nevermind :)
15:41:43 <glguy> altern: Because the parser doesn't know that the input is complete
15:41:52 <glguy> and that you might have more numbers to come
15:42:09 <altern> glguy: how can I fix that?
15:42:37 <glguy> altern: Run the parser with parseOnly :: Parser a -> ByteString -> Either String a
15:42:46 <glguy> if you don't plan to supply more inputs
15:43:13 <altern> glguy: alright! thanks a lot!
15:43:23 <glguy> altern: According to http://hackage.haskell.org/package/attoparsec-0.12.0.0/docs/Data-Attoparsec-ByteString.html#t:Result   Partial: Supply this continuation with more input so that the parser can resume. To indicate that no more input is available, pass an empty string to the continuation.
15:43:36 <glguy> If you didn't want to change parser functions
15:46:05 <haasn> monochrom: Thanks. Every time I read one of your tutorials on continuations or other topics I feel like I understand them perfectly
15:46:20 <haasn> (For some reason, it doesn't seem to stay that way. Most likely because I never use continuations)
15:46:53 <chrisdone> i have to re-learn continuations every time
15:47:43 <chrisdone> i think every use for them i've had has been academic curiousity
15:47:54 <monochrom> it took me several rounds of practicing, too
15:48:42 <monochrom> did you know: only 70% of why I write these articles is for the sake of you folks. 30% is for my sake, so that I know where to re-learn them :)
15:49:14 <haasn> I thought that's why all academic papers are written
15:49:37 <monochrom> also, the process of writing-organizing is also a good component of learning
15:49:40 <chrisdone> monochrom: you should add a conditions example to it! exceptions with restarts =) "readFile: the file doesn't exist. (1) Try again, (2) provide a different filename, (3) abort"
15:49:42 <altern> glguy: parseOnly returns "Right (Number 12)". How could I get just "(Number 12)" ?
15:49:53 <monochrom> egads
15:50:08 <glguy> altern: use a case expression to match on the Right
15:50:08 <altern> glguy: do I need to write another function for that?
15:50:45 <chrisdone> yeah, http://chrisdone.com/posts/identity-monad is not really for people, it's just because i forget the concept and writing it out for public consumption is a good way to clarify it for myself
15:50:50 <corgifex> altern: not really
15:50:51 <monochrom> altern, remember that parse errors are a very real possibility, you must have a concrete plan for that. you will not always get Right.
15:50:53 <glguy> case parseOnly stringToVN ( BS.pack "12" ) of Right x -> <stuff with x>; Left e -> <stuff with e>
15:50:59 <platz> anyone know why i'm getting an "not in scope: 'catch'" error while building pandoc on 7.8.2?
15:51:17 <chrisdone> pandoc is assuming catch comes from prelude
15:51:31 <chrisdone> which it did before it was deprecated and then removed
15:51:49 <chrisdone> i think. i'm still stuck on 7.4, i'm not certain about this
15:52:05 <chrisdone> platz: what version of pandoc?
15:52:07 <platz> ah, a good tip though
15:52:25 <platz> cabal's trying to install 1.6 it seems
15:52:37 <chrisdone> yeah, that's a very old version
15:52:44 <chrisdone> from 2010
15:53:18 <chrisdone> perhaps something in your dependency list is bringing it down in the solver
15:53:35 <glguy> This is Haskell. You can't just put your code down overnight and expect it to build the next day :)
15:53:37 <platz> ah thanks, i'll try installing from source
15:53:51 <chrisdone> what does it say if you do cabal install --dry-run --constraint pandoc==1.12.4.2?
15:54:11 <glguy> or just: cabal install pandoc-1.12.4.2
15:54:21 <glguy> (with/without dry-run)
15:54:54 <chrisdone> if you're trying to install a package that uses pandoc, use mine. if you're just trying to install pandoc itself, use glguy's
15:55:47 <platz> just pandoc itself, building..
15:55:49 <chrisdone> although the latter's a good check just to see if pandoc will even work (it'd be weird if it didn't thoughon 7.8)
15:56:45 <chrisdone> platz: did you do a cabal update recently?
15:57:06 <platz> cabal update?  yep
15:57:26 <chrisdone> i don't see how cabal install pandoc would pick 1.6
15:58:34 <akurilin> quick question: should it theoretically be possible to convert a json tree to a Data.Tree structure with aeson?
15:58:58 <chrisdone> sure
15:59:36 <chrisdone> depends how you want to do it
16:00:16 <johnw> I don't see why not
16:00:19 <johnw> you fold down the json tree, and unfold up the Data.Tree
16:01:47 <akurilin> I'm guessing it's just a matter of implementing parseJSON in such a way that it returns a Tree MyType?
16:06:48 <glguy> akurilin: How about something like this: http://lpaste.net/105255
16:10:09 <akurilin> glguy: so it sounds like you're bypassing parseJSON altogether here, huh?
16:10:14 <akurilin> or am I misunderstanding?
16:10:52 <spott_> how do I remove my "user" cabal installed packages without destroying my sandboxes?
16:10:55 <johnw> i thin parsing it directly into Tree MyType will be more efficient
16:11:33 <johnw> spott_: I'd use rm -fr ~/.ghc ~/.cabal/lib
16:11:57 <spott_> thanks
16:12:34 <akurilin> johnw: "parsing it directly" meaning what specifically?
16:12:50 <johnw> using a FromJSON instance
16:12:58 <spott_> when you do a sandbox install... does it start figuring out what to install assuming that the "global" and "user" packages are installed? or does it ignore them and start from scratch?
16:13:07 <johnw> make a newtype wrapper around Data.Tree
16:13:13 <johnw> and then create a FromJSON instance for that wrapper
16:13:45 <akurilin> ah
16:14:18 <glguy> or just write the parser function you want and call that and don't bother trying to overload all the things
16:15:08 <johnw> I must overload all the things!
16:15:18 <_deepfire> so, does ghc-7.8 install on nixos nowadays?
16:15:23 <johnw> indeed it does
16:15:29 <johnw> I use ghc-7.8 quite happily on Nix
16:15:41 <johnw> it supports fully dynamic executables
16:16:32 <_deepfire> Hmm, I'm getting more enthusiasm to have my LUKS/LVM issues resolved then..
16:17:27 <Philonous> With a type familiy Foo and a singleton of type (Sing a), how can i construct a singletone (Sing (Foo a))? I tried mirroring the computation but ghc doesn't seem to pick up on it.
16:17:59 <johnw> Philonous: can you show us what you have so far?
16:18:15 <frankle> haskell seems to be a wonderful language, so why don't we see more people (or any companies of significance) use haskell on the server side for web applications?  i see scala used quite a bit.
16:18:35 <benzrf> frankle: because they fear us!!!
16:19:25 <joelteon> that's a good question frankle, I don't know why
16:19:36 <_deepfire> JVM is a factor, server-side.
16:19:40 <Philonous> johnw, https://gist.github.com/Philonous/235b6b217ac9476f5659
16:20:13 <akurilin> johnw, glguy I'll investigate, thanks forlks
16:20:16 <akurilin> *flks
16:20:18 <akurilin> *folks
16:20:54 <frankle> i just find it interesting on how haskell guys poke of of scala, but i rarely see haskell used.  i go to conferences and hear people in startups using clojure or scala, but not many people say haskell.  but, when you ask people what language they love, they say haskell.
16:21:04 <Philonous> johnw, My question basically is how to convince that the type-level computation and the computation on singletons coincide
16:21:07 <johnw> Philonous: I don't have enough context to reproduce whatever error you're seeing here
16:21:15 <johnw> where is SNil from?
16:21:24 <haasn> Philonous: What error do you get?
16:22:11 <zomg> frankle: probably because Scala and Clojure are much easier to pick up + they have the massive JVM ecosystem behind them, so they are a natural choice for someone who's fed up with Javas badness
16:22:14 <altern> All: Why do I get error "The first argument of `Monad' should have kind `* -> *` " when I try to run following code: http://lpaste.net/105254 ?
16:22:17 <Philonous> johnw, It's the normal promoted (empty) List constructor from Data.Singletons.Prelude.List
16:22:58 <haasn> altern: line 16 for example is problematic; â€˜VNâ€™ can't possibly be a monad because there's no type parameter
16:23:01 <shachaf> altern: Because VN can't be an instance of Monad. It doesn't have a type argument.
16:23:12 <haasn> altern: for example, what should be the type of return?
16:23:17 <shachaf> Compare: "Maybe" can be a Monad; "Int" or "Maybe Int" can't.
16:23:26 <jle`> altern: by the way, this sort of error is a compile-time error, not a run-time error
16:23:33 <jle`> altern: it happens before your code ever even runs :)
16:24:16 <benzrf> :k Monad
16:24:17 <lambdabot> (* -> *) -> Constraint
16:25:26 <jle`> :t return
16:25:27 <lambdabot> Monad m => a -> m a
16:25:34 <jle`> a -> VN a   ...?
16:25:43 <jle`> but VN is *, so VN a doesn't make any sense
16:25:52 <rrradical> anyone here have experience embedding haskell? I'm wondering if I repeatedly jump into haskell (like once a frame in game engine) whether I have to shuttle all of the data out and back in every time to maintain state
16:26:59 <benzrf> hmm
16:27:14 <benzrf> haskell Functors in general are isofunctors, right?
16:27:20 <benzrf> assuming isofunctor is a term in cat theor
16:27:45 <corgifex> endofunctor?
16:27:50 <benzrf> well
16:28:04 <benzrf> functors are kind of like homomorphisms
16:28:05 <jle`> if isofunctor were a term, what would it mean?
16:28:15 <benzrf> oh hmmmm
16:28:33 <benzrf> wait, are functors required to be isomorphic to begin with
16:29:38 <copumpkin> isomorphic?
16:29:42 <copumpkin> x is isomorphic to y
16:29:47 <copumpkin> things aren't just isomorphic in isolation
16:29:55 <copumpkin> except for the user isomorphic in here, I guess
16:30:25 <jonh> hehe
16:31:29 <benzrf> copumpkin: i mean
16:31:43 <benzrf> if you view functors as morphisms in the abstract algebra sense
16:31:51 <benzrf> they're required to be isomorphisms, right?
16:31:58 <benzrf> i.e. bijective and work in reverse
16:32:03 <copumpkin> no
16:32:06 <johnw> no
16:32:10 <johnw> just homomorphic
16:32:11 <benzrf> oh
16:32:14 <benzrf> in that case
16:32:25 <johnw> preserving identities/compositions and laws
16:32:27 <benzrf> haskell Functors in general are like that though arent they
16:32:35 <johnw> no
16:32:38 <benzrf> hmm?
16:32:42 <johnw> they aren't isomorphisms
16:32:53 <benzrf> is fmap not bijective?
16:32:55 <glguy> akurilin: Something like this, then? http://lpaste.net/7859074773337243648
16:35:33 <Philonous> johnw haasn : I realize now why my code couldn't possibly type check. I found something else I can try, Thanks.
16:36:11 <johnw> benzrf: the functor is the same on both sides of an fmap, so I think what you're saying is that when mapping fa to f b, f is always isomorphic to itself?
16:38:21 <benzrf> johnw: well a functor maps objects to objects and arrows to arrows
16:38:36 <johnw> right
16:38:44 <benzrf> johnw: the object mapping for Functor is trivially isomorphic as near as i can tell
16:38:56 <johnw> you mean, for endofunctors
16:38:57 <benzrf> f a is obviously reversible to a
16:39:03 <benzrf> johnw: im talking about Functors
16:39:06 <benzrf> not functors
16:39:23 <benzrf> johnw: anyway, i am unsure but
16:39:26 <monochrom> no, obviously irreversible
16:39:31 <benzrf> monochrom: oh?
16:39:34 <akurilin> glguy: interesting, let me think about it for a bit
16:39:38 <haasn> Philonous: I don't realize it; can you enlighten me too?
16:39:40 <benzrf> i mean, it is /mathematically speaking/
16:39:45 <monochrom> cannot reverse Maybe X to X
16:39:57 <monochrom> err, nevermind
16:40:03 <benzrf> :)
16:40:05 <akurilin> random question while I'm here: Is there a convention for calling factory functions? I've seen mkSomething around, but is that perhaps a TH convention?
16:40:09 <benzrf> arrows though
16:40:35 <benzrf> isn't fmap a bijection when treated as a 1-arg function?
16:40:59 <benzrf> oh wait
16:41:08 <benzrf> i guess you could have something like
16:41:10 <benzrf> [a] -> [b]
16:41:18 <benzrf> where it changes the a's, then reverses
16:41:25 <benzrf> and you cant move that back to a -> b
16:41:25 <Philonous> haasn, the different branches of the case expressions of incompatible types. SNil :: Sing '[], but SCons t SNil :: '[a] for some type a
16:41:32 <benzrf> *OVERTURNED*
16:41:45 <johnw> "changes the a's then reverses"?
16:41:47 <Philonous> haasn, sorry SCons t SNil :: Sing '[a]
16:41:53 <monochrom> I think you're looking at a tautology. haskell type constructors are injective. so you end up having injective functors.
16:41:54 <benzrf> johnw: i.e.
16:42:00 <benzrf> reverse . map show
16:42:12 <benzrf> monochrom: you have to also consider arrow mappings though
16:42:28 <benzrf> and not all f a -> f b map to a -> b
16:42:29 <johnw> benzrf: whenever you suspect an isomorphism, the easiest way to find out if it's the case is to implement a pair of functions
16:42:37 <benzrf> eehhh
16:42:43 <haasn> Philonous: That sort of makes sense; but it also seems like it should match up with Sing (FlattenRepType (RepType t)) in that case; of course, I don't think GHC can prove that your singleton constructors actually 1:1 match up to the forms it can have
16:42:45 <benzrf> whmm
16:42:47 <benzrf> *hmm
16:42:50 <haasn> We know this to be true, but GHC doesn't know it
16:42:53 <haasn> I think that explains it for me
16:43:10 <benzrf> given a Comonad, is the Functor for that comonad an automorphism, then?
16:43:15 <benzrf> or
16:43:17 <benzrf> autofunctor
16:43:18 <benzrf> w/e
16:43:30 <benzrf> since you have extract
16:43:58 <benzrf> given a comonad w you can write (f a -> f b) -> (a -> b)
16:44:21 <johnw> try it!
16:44:31 <benzrf> mmm
16:44:35 <benzrf> :t extract
16:44:36 <lambdabot> Not in scope: â€˜extractâ€™
16:44:40 * benzrf rolls eyes
16:45:23 <benzrf> @let class Functor w => Comonad w where extract :: w a -> a; extend :: w a -> w (w a)
16:45:26 <lambdabot>  Defined.
16:45:30 <Philonous> haasn, I might try arranging the coincidence and then "rediscover" it. That is, package the RHS of the case expressions in SomeSing, then unpack them and use some sort of safe cast.
16:46:21 <benzrf> ooooh right
16:46:23 <Philonous> haasn, Ah, but then I need the SingI instance in (FlattenRepType (Reptype a)) after all, which was exactly what I wanted to avoid.
16:46:23 <benzrf> no return
16:46:23 <benzrf> >.<
16:46:32 <benzrf> haha i feel dumb
16:47:03 <benzrf> @let boguscofmap lifted = extract . fmap lifted
16:47:06 <lambdabot>  Defined.
16:47:09 <benzrf> :t boguscofmap
16:47:10 <lambdabot> Comonad w => (a -> c) -> w a -> c
16:47:13 <benzrf> eeh
16:47:21 <benzrf> i did that wrong
16:47:25 <haasn> Yes to me it seems like it *could* work but you need a lot more instances; like maybe something ie. FlattenRepType (TypeStruct ts) ~ ts
16:47:29 <haasn> constraints*
16:47:39 <haasn> But I'm also not sure how that even works for the t = '[t] case
16:47:52 <benzrf> @let boguscofmap lifted v = extract (lifted (return v))
16:47:54 <lambdabot>  .L.hs:163:1:
16:47:54 <lambdabot>      Equations for â€˜boguscofmapâ€™ have different numbers of arguments
16:47:54 <lambdabot>        .L.hs:163:1-42
16:47:54 <lambdabot>        .L.hs:164:1-50
16:47:57 <benzrf> blah
16:48:01 <benzrf> @let boguscofmap' lifted v = extract (lifted (return v))
16:48:02 <lambdabot>  Defined.
16:48:05 <benzrf> :t boguscofmap'
16:48:06 <lambdabot> (Comonad w, Monad m) => (m a1 -> w a) -> a1 -> a
16:48:17 <benzrf> pfft
16:48:59 <haasn> Philonous: Thinking about it some more, it doesn't seem like the different branches of the case not having the same type would be a problem, as long as they all match the expected type under the local given constraints; but GHC probably doesn't know that in the STypeStruct case that FlattenRepType (TypeStruct ts) ~ ts
16:49:00 <benzrf> @instance Comonad Identity where extract = runIdentity; extend = Identity
16:49:00 <lambdabot> Maybe you meant: instances instances-importing
16:49:04 <benzrf> @let instance Comonad Identity where extract = runIdentity; extend = Identity
16:49:06 <lambdabot>  Defined.
16:49:20 <haasn> Probably too many variables involved. type family things get hairy when you involve variables
16:49:26 <haasn> like Sing (FlattenRepType (RepType t)) for some t
16:49:27 <benzrf> > boguscofmap (\Identity v -> Identity (v + 3)) 4
16:49:28 <lambdabot>  can't find file: L.hs
16:49:30 <haasn> I usually have to add lots of constraints
16:49:33 <benzrf> > boguscofmap' (\Identity v -> Identity (v + 3)) 4
16:49:35 <lambdabot>  Constructor â€˜Data.Functor.Identity.Identityâ€™ should have 1 argument, but has...
16:49:38 <benzrf> u wot
16:49:41 <benzrf> > boguscofmap' (\(Identity v) -> Identity (v + 3)) 4
16:49:42 <lambdabot>  7
16:49:43 <jle`> are there many useful monads+comonads though
16:49:44 <benzrf> ^works :^)
16:49:56 <benzrf> jle`: i know of none besides Id
16:49:57 <haasn> jle`: NonEmpty, Identity, ...?
16:50:03 <benzrf> NonEmpty?
16:50:07 <haasn> Stream!
16:50:17 <haasn> Oh, I think free and cofree are monad+comonad or something
16:50:25 <Philonous> haasn, Well, it's not a huge issue anyway. But I find it puzzling that I need the constraint since I can just compute the singleton.
16:50:26 <benzrf> cofree?
16:50:31 <benzrf> i keep reading that as coffee
16:50:44 <benzrf> ok, so we can establish that any Functor that is also a Monad /and/ a Comonad is necessarily an autofunctor
16:50:47 <benzrf> B)
16:50:51 <benzrf> HOW VERY USEFUL
16:51:02 <haasn> Philonous: By adding a SingI constraint, though, right?
16:51:40 <Philonous> No, I mean, I can actually computer it from the Sing (RepType a)
16:52:15 <haasn> (I still want to know what exact error message you get, by the way)
16:52:34 <Philonous> haasn, Oh, sure: https://gist.github.com/Philonous/d7ed52601b992c504a42
16:53:54 <haasn> Philonous: Looks like it's going into the FlattenTypeRep t = '[t] case
16:53:59 <benzrf> hnnnn
16:53:59 <haasn> perplexingly
16:54:09 <benzrf> actually you can weaken that to Applicative and Comonad
16:54:11 <benzrf> :^)
16:54:22 <benzrf> as if it makes a useful difference :-o
16:55:38 <EvanR> go go autofunctor
16:56:30 <haasn> is an autofunctor a functor that is its own isomorphism?
16:56:46 <haasn> its own inverse*
16:57:11 <benzrf> haasn: well
16:57:21 <benzrf> an automorphism is an endomorphism that is also an isomorphism
16:57:30 <benzrf> so i assumed an autofunctor would work the same way ;)
16:57:51 <EvanR> isofunctor
17:00:37 <benzrf> autofunctor is stronger than isofunctor!
17:00:42 <jle`> why do round/floor/ceiling require RealFrac ?
17:00:50 <EvanR> :t floor
17:00:51 <benzrf> jle`: just cuz
17:00:51 <jle`> wouldn't Fractional be enough?
17:00:52 <lambdabot> (RealFrac a, Integral b) => a -> b
17:02:31 <EvanR> really, it requires Archimedean ;)
17:03:11 <EvanR> consider a fractional set which includes infinity
17:03:26 <haasn> jle`: Real is required for getting something back to an actual number
17:03:27 <shergill> what's the reason that instance selection in haskell doesn't pay attention to the constraints?
17:03:30 <j4s0n> ok
17:03:35 <shergill> or well at least in ghc
17:03:43 <haasn> jle`: Fractional could be something like Fractional a => F a -- for some applicative F
17:03:57 <haasn> That's pretty much how I think about it, at any case
17:04:09 <EvanR> > floor (1/0)
17:04:11 <lambdabot>  1797693134862315907729305190789024733617976978942306572734300811577326758055...
17:04:19 <EvanR> > floor (1.0/0)
17:04:21 <lambdabot>  1797693134862315907729305190789024733617976978942306572734300811577326758055...
17:04:24 <EvanR> bwahaha
17:04:31 <Philonous> haasn, Heh, I will just apply the big ol' sledgehammer which is unsafeCoerce
17:05:03 <haasn> Philonous: or typeable safecoerce :p
17:05:07 <j4s0n> in any given case
17:05:18 <jle`> haasn: hm
17:05:38 <EvanR> what the hell is that number? the largest finite double?
17:05:48 <Philonous> haasn, Well, getting rid of one constraint by introducing another doesn't make much sense ;)
17:05:54 <haasn> > toRational (1/0)
17:05:56 <lambdabot>  1797693134862315907729305190789024733617976978942306572734300811577326758055...
17:06:34 <EvanR> > (log (toRational (1/0))) / (log 2)
17:06:36 <lambdabot>  No instance for (GHC.Float.Floating GHC.Real.Rational)
17:06:36 <lambdabot>    arising from a use of â€˜GHC.Float.logâ€™
17:06:49 <EvanR> > (log (floor (1/0))) / (log 2)
17:06:51 <lambdabot>  No instance for (GHC.Show.Show a0)
17:06:51 <lambdabot>    arising from a use of â€˜M810031921428960700417288.show_M8100319214289607004...
17:06:51 <lambdabot>  The type variable â€˜a0â€™ is ambiguous
17:06:51 <lambdabot>  Note: there are several potential instances:
17:06:51 <lambdabot>    instance [safe] GHC.Show.Show
17:07:41 <j4s0n> sys tars?
17:09:13 <haasn> I found the source code of toRational :: Double -> Rational
17:09:15 <EvanR> > (log (realToFrac (floor (1/0))) :: CReal) / (log 2.0)
17:09:17 <lambdabot>  1024.0
17:09:20 <haasn> > decodeDoubleInteger (1/0)
17:09:21 <lambdabot>  Not in scope: â€˜decodeDoubleIntegerâ€™
17:09:33 <EvanR> thats infinity
17:09:38 <haasn> > decodeFloat (1/0)
17:09:40 <lambdabot>  (4503599627370496,972)
17:09:46 <haasn> It takes that as the actual exponent
17:10:15 <EvanR> > 1/0 :: CReal
17:10:19 <lambdabot>  mueval-core: Time limit exceeded
17:10:46 <j4s0n> what is time limit for?
17:10:47 <benzrf> creal
17:10:56 <benzrf> j4s0n: savety
17:11:09 <haasn> A fix clearly seems simple in nature; add special cases for weird numbers in toRational
17:11:14 <benzrf> > 1 / 0'
17:11:16 <lambdabot>  <hint>:1:7:
17:11:16 <lambdabot>      lexical error in string/character literal at end of input
17:11:16 <benzrf> > 1 / 0
17:11:18 <EvanR> without it, dividing by zero would destroy a large part of the universe
17:11:18 <lambdabot>  Infinity
17:11:31 <benzrf> > infinity0
17:11:32 <lambdabot>  Not in scope: â€˜infinity0â€™
17:11:32 <lambdabot>  Perhaps you meant â€˜infinityâ€™ (imported from Data.Number.Natural)
17:11:34 <benzrf> > infinity
17:11:39 <lambdabot>  mueval-core: Time limit exceeded
17:11:39 <lambdabot>  mueval: ExitFailure 1
17:11:41 <benzrf> intresting
17:12:13 <j4s0n> is it real?
17:12:16 <EvanR> haasn: division only being defined for non zero divisors would be good in the type system, if practical
17:12:21 <benzrf> > infinity
17:12:27 <lambdabot>  mueval-core: Time limit exceeded
17:12:27 <lambdabot>  mueval: ExitFailure 1
17:12:30 <EvanR> of course its not allowed by your internal dependent type checker
17:12:32 <benzrf> > fix (+1)
17:12:36 <lambdabot>  mueval-core: Time limit exceeded
17:12:42 <haasn> EvanR: 1/0 is perfectly valid though
17:12:49 <haasn> And it has a perfectly valid result: Infinity
17:12:50 <EvanR> in ieee bullshit
17:13:02 <haasn> That doesn't allow our implementation of toRational to ignore IEEE and give us back wrong numbers
17:13:06 <benzrf> EvanR: the limit of 1/0 is unfinidy
17:13:10 <j4s0n> experts?
17:13:22 <haasn> An exception would be most ideal here, I think; similar to 1/0 on Int
17:13:26 <haasn> Or 1/0 on Rational
17:13:37 <EvanR> you can make floating point throw exceptions on things like this
17:14:02 <haasn> toRational (1/0) = toRational 1 / toRational 0 -- seems logical
17:14:03 <EvanR> from what i read, NaN and infinity are mostly there for non-numeric scientists to actually program their computer
17:14:39 <EvanR> but it also allows some fringe computations to complete correctly, ones that want to bend the rules and have n/infinity be zero
17:15:01 <j4s0n> decimals?
17:15:38 <EvanR> haasn: if im asking for an approximation or real numbers, or a subset of rationals, i dont want NaN and infinities by default
17:16:14 <benzrf> > toRational (1/0)
17:16:15 <haasn> Are you proposing we remove NaN and Infinity from Haskell?
17:16:16 <lambdabot>  1797693134862315907729305190789024733617976978942306572734300811577326758055...
17:16:19 <benzrf> gdamn
17:16:21 <j4s0n> real numbers
17:16:34 <j4s0n> Truman
17:16:49 <EvanR> im not proposing anything, hell if i know how to design a prelude
17:17:15 <j4s0n> I do not like lies
17:17:32 <EvanR> dont divide by zero
17:17:36 <EvanR> ;)
17:17:54 * benzrf divides by zero
17:18:07 <EvanR> nooooooo
17:18:48 <dwcook> What's even better is
17:18:53 <dwcook> > toRational (1/(-0))
17:18:55 <lambdabot>  (-17976931348623159077293051907890247336179769789423065727343008115773267580...
17:19:16 <EvanR> instance Property NonZero Pico
17:19:50 <j4s0n> EvanR do you wish me dead?
17:20:12 <benzrf> :k Property
17:20:13 <EvanR> (/) :: Fractional a, Property NonZero a => a -> a -> a
17:20:13 <lambdabot> *
17:20:33 <j4s0n> I hate lies
17:20:38 <benzrf> > -0
17:20:40 <lambdabot>  0
17:20:43 <benzrf> > 1/(-0)
17:20:45 <lambdabot>  -Infinity
17:20:46 <haasn> EvanR: So now I not only have to come up with my algorithm, but I also have to *prove* my result isn't zero?
17:20:48 <benzrf> uwot
17:20:52 <benzrf> > (-0) == 0
17:20:53 <lambdabot>  True
17:20:59 <benzrf> h-how
17:21:13 <dwcook> benzrf: welcome to the float world
17:21:28 <EvanR> haasn: you have to anyway, at least with integers
17:21:31 <haasn> Because I think inferring that property â‰… the halting problem
17:21:32 * benzrf floats away to a better numbering system
17:22:08 <dwcook> benzrf: actually what you saw there might have been Integer defaulting. Integers, afaik, have no -0
17:22:30 <dwcook> benzrf: a better test would involve writing an explicit type annotation
17:22:41 <dwcook> > -0 :: Double
17:22:43 <lambdabot>  -0.0
17:22:45 <EvanR> :t -0
17:22:47 <lambdabot> Num a => a
17:22:52 <benzrf> wtf
17:23:02 <j4s0n> floats are?
17:23:04 <benzrf> > (-0 :: Double) == 0
17:23:05 <lambdabot>  True
17:23:16 <benzrf> uwot
17:23:25 <EvanR> > (0/0) == (0/0)
17:23:26 <dwcook> Yeah, that happened to be true anyway and was what prompted my comment. :)
17:23:26 <lambdabot>  False
17:23:34 <corgifex> @let isNegative x = "-" `isPrefixOf` show x
17:23:37 <lambdabot>  Defined.
17:23:45 <corgifex> > isNegative (-0.0)
17:23:47 <lambdabot>  True
17:24:00 <j4s0n> is there a way out?
17:24:06 <EvanR> > -3 / (1/0)
17:24:07 <benzrf> git dang
17:24:08 <lambdabot>  -0.0
17:24:23 <benzrf> that was painful to look at
17:24:24 <benzrf> =[
17:24:57 <EvanR> > -0.0 - (-0.0)
17:24:59 <lambdabot>  0.0
17:25:02 <EvanR> > -0.0 - (0.0)
17:25:04 <lambdabot>  -0.0
17:25:14 <EvanR> > -0.0 + (-0.0)
17:25:16 <lambdabot>  -0.0
17:25:55 <corgifex> > isNegative "one"
17:25:57 <lambdabot>  False
17:26:11 <EvanR> > isNegative "negative one"
17:26:13 <lambdabot>  False
17:26:14 <EvanR> busteed
17:26:17 <dwcook> This is one of those things people complain about JavaScript for, but the truth is more sinister. Various languages have these floating-point quirks.
17:26:23 <geekosaur> don't try to understand it. ieee floating point is not for mortals to comprehend
17:26:44 <corgifex> IEEE is japanese for NOOO
17:26:45 <EvanR> signalling NaN with payload ;)
17:26:53 <geekosaur> (actually I think it has something to do with limits)
17:27:03 <johnw> in a future version, they'll have NotAPayload
17:27:19 <j4s0n> Then why is it called JavaScript and not Haskell
17:27:21 <warpy> hi, i have this exact issue http://www.haskell.org/pipermail/beginners/2012-August/010344.html, any ideas why?
17:27:46 <warpy> nobody ever replied to that email
17:28:00 <corgifex> probably because you don't have documentation for those other libraries
17:28:09 <geekosaur> warpy: what you dont have installed is the generated documentation for those modules
17:28:12 <warpy> and it is number one result on google for "haddock links to dependencies"
17:28:21 <pavonia> > (decodeFloat 0.0, decodeFloat (-0.0))
17:28:23 <lambdabot>  ((0,0),(0,0))
17:28:38 <corgifex> whatever decodes your float
17:28:44 <EvanR> lol
17:28:54 <warpy> corgifex: geekosaur shouldnt haddock just like to the docs of packages on hackage
17:28:59 <warpy> that would be sensible
17:29:12 <corgifex> I don't think haddock knows about hackage
17:29:13 <geekosaur> only for some uses / users
17:29:51 <geekosaur> if I'm working on a plane or otherwise with no or expensive network, I want my docs local
17:29:56 <dwcook> I'm so glad I took the advice of that one article and enable the documentation setting in my cabal config ages ago
17:30:05 <dwcook> enabled*
17:30:10 <warpy> so if i want to put my package's docs on internet, i have to put all the dependency docs too
17:30:16 <geekosaur> dwcook, the referenced message is for bootlibs
17:30:37 <geekosaur> there's a hackaround for that case somewhere (I think it was on the cabal mailing list)
17:30:40 <dwcook> geekosaur: I don't know what that means.
17:30:54 <corgifex> warpy: why don't you just link to haddock?
17:31:05 <warpy> i dont get you
17:31:06 <geekosaur> dwcook: your cabal documentation setting is not going to affect modules which are part of ghc
17:31:12 <warpy> link what?
17:31:18 <dwcook> geekosaur: Oh, okay.
17:31:34 <corgifex> warpy: what?
17:31:49 <warpy> i link what to haddock
17:31:54 <warpy> i dont understand
17:32:15 <corgifex> I don't understand the question
17:32:34 <warpy> but you asked it!
17:32:46 <warpy> uh, this is confusing
17:32:52 <corgifex> no, you did
17:33:05 <j4s0n> So does haskel have the fpu vulner?
17:33:18 <warpy> ok. i just want my haddock docs to link to the docs of dependencies on hackages
17:33:26 <warpy> how do i do that
17:33:31 <EvanR> the one from PHP where parsing a particular float causes an infinite loop haha
17:34:45 <benzrf> dont compre haskell to php
17:34:47 <EvanR> read "2.2250738585072011e-308" :: Double
17:34:51 <warpy> corgifex: geekosaur nvm. found the solution https://groups.google.com/forum/#!topic/haskell-cafe/_GhJOlJxd9Q
17:34:52 <EvanR> > read "2.2250738585072011e-308" :: Double
17:34:54 <lambdabot>  2.225073858507201e-308
17:34:59 <benzrf> :-)
17:35:11 <haasn> > 1e-10000000000000000 :: Double
17:35:16 <lambdabot>  mueval: ExitFailure 1
17:35:49 <jle`> what
17:36:19 <EvanR> > read "1e-10000000000000000" :: Double
17:36:21 <lambdabot>  0.0
17:36:52 <jle`> that's slightly more assuring
17:36:53 <haasn> The syntax form goes through fromRational (1 ^^ (-10000000000000000))
17:37:01 <haasn> which goes through (10^10000000000000000 :: Integer)
17:37:12 <startling> > 10^10000000000000000 :: Integer
17:37:18 <lambdabot>  mueval: ExitFailure 1
17:37:33 <startling> well !
17:37:36 <heatsink> > 1.0e-10000000000000000 :: Double
17:37:41 <lambdabot>  mueval: ExitFailure 1
17:37:43 <haasn> logBase 2 (10^10000000000000000) â‰… 10^16
17:37:49 <EvanR> polymorphic literals vulnerability ;)
17:37:53 <haasn> That's a lot of bits
17:38:13 <jle`> vulnerability if you allow your users to modify source code and recompile your program
17:38:29 <startling> :P
17:38:36 <EvanR> so that evaluation occurs during compile time?
17:38:43 * haasn .oO( this is why I use (read "3.1415") for all my floating point literals )
17:38:48 <j4s0n> So you were afraid I was going to kell
17:39:03 <EvanR> lol
17:39:09 <johnw> preflex: seen mgsloan
17:39:11 <startling> EvanR: which evaluation?
17:39:13 <haasn> EvanR: I don't think so
17:39:16 <j4s0n> Ahh yes
17:39:19 <EvanR> the literal
17:39:22 <EvanR> to double
17:39:22 <j4s0n> you made that whisper
17:39:27 <jle`> the call to fromRational is runtime
17:39:32 <startling> > (read 10^10000000000000000) :: Integer
17:39:34 <lambdabot>  No instance for (GHC.Num.Num GHC.Base.String)
17:39:34 <lambdabot>    arising from the literal â€˜10â€™
17:39:42 <startling> > (read "10^10000000000000000") :: Integer
17:39:43 <j4s0n> But if I can kell
17:39:44 <lambdabot>  *Exception: Prelude.read: no parse
17:39:52 <j4s0n> Then you made a graven image
17:40:10 <haasn> EvanR: Oh you're right, it does happen during compile time. Locks GHC up
17:40:18 <EvanR> sweet
17:40:27 <haasn> I can't even kill it properly, it just eats RAM
17:40:29 <j4s0n> Have you decided on a name yet?
17:40:35 <j4s0n> tooti
17:40:43 <byorgey> j4s0n: do you wish to discuss Haskell?
17:41:00 <jle`> that's weird
17:41:02 <startling> haasn: oh, interesting, that makes sense.
17:41:13 <jle`> i do not understand
17:41:20 <jle`> is fromString compiled in at compile time too?
17:41:52 <monochrom> usually no
17:41:52 <startling> jle`, no, but no reason it can't be.
17:41:53 <j4s0n> So does haskel have the fpu vulner?
17:42:04 <jle`> so is fromRational being called at compile time?
17:42:17 <jle`> is that what's happening here?
17:42:24 <haasn> Looks like GHC tries to inline it at compile time and get it down to a floating point literal
17:42:25 <altern___> All: why do I get error The first argument of `Monad' should have kind `* -> *',     but `VNum' has kind `* -> Constraint': http://lpaste.net/105254 ?
17:42:25 <monochrom> usually neither
17:42:25 <EvanR> even if its defined in your source code...
17:42:31 <haasn> This is even with -O0
17:42:41 <EvanR> or only for Double
17:42:48 <j4s0n> usually
17:42:50 <startling> haasn, I guess that makes sense, since floats / doubles are pretty small compared to integers
17:42:56 <dwcook> altern___: VNum is a typeclass. You want a type function from a concrete type onto a concrete type for instances of Monad.
17:43:03 <jle`> typeclasses aren't types, altern___
17:43:10 <monochrom> nevermind. what haasn says. empirical trumps guesses
17:43:17 <haasn> startling: Imagine having to first compute *every single* floating point literal used in your program
17:43:29 <j4s0n> Except for one
17:43:30 <haasn> whenever you run the program
17:43:35 <dwcook> altern___: what is it you're trying to express?
17:43:38 <jle`> haasn: i could probably test that by having my own fromRational that outputted a trace message
17:43:39 <haasn> that's pretty much what having fromRational at runtime there would be like, I suppose
17:43:44 <jle`> and seeing if he trace happened at runtime
17:43:44 --- mode: ChanServ set +o monochrom
17:43:46 <EvanR> monochrom: unless you have four guesses of a kind
17:43:57 <haasn> jle`: fromRational is probably not inlined for sufficiently non-built-in types. But test it
17:43:58 <startling> haasn: "imagine having to compute *every single* Text literal used in your program"
17:44:02 --- mode: monochrom set -o monochrom
17:44:06 <monochrom> hehe EvanR
17:44:45 <haasn> jle`: eg. module Foo (foo) where foo :: Rational a => a; foo = 1e-100000000
17:44:53 <haasn> I wonder what happens if I compile that
17:44:55 <jle`> i guess if it's not inlined then i could just make it bottom and have the compiler crash
17:45:17 <EvanR> heh
17:45:26 <haasn> Oh, still crashes
17:45:28 <altern___> dwcook: should I write "VNum :: VSize -> VN" instead?
17:45:43 <haasn> s/Rational/Fractional/
17:45:48 <haasn> Interesting, it hangs even before type checking
17:45:56 <dwcook> altern___: That's also wrong for a couple of reasons. What are you after?
17:46:15 <jle`> instance Fractional Void where fromRational = undefined
17:46:19 <altern___> I just want to come up with some monad to understand how it works
17:46:32 <EvanR> heh, what if the parser sees "<digits> :: Double" and computes it right there
17:46:33 <jle`> altern___: try implementing Maybe :)
17:46:40 <haasn> http://bpaste.net/show/353809/
17:46:45 <haasn> To whom it may interest ^
17:46:48 <altern___> jle`: I already did it :)
17:47:06 <dwcook> jle`: Come now, at least use absurd ;)
17:47:15 <EvanR> altern___: now implement Cont
17:47:17 <altern___> I am trying to implement my monad that takes either number and placeholder and produces next number
17:47:30 <dwcook> jle`: Oh I see, that's an invalid instance regardless :P
17:47:33 <benzrf> altern___: what makes it a monad
17:47:43 <haasn> I don't understand why -O2 makes ghc move the interegers to the top level
17:47:46 <haasn> Maybe so it can re-use them?
17:48:06 <haasn> either way, all of this suggests that GHC just statically computes the numerator and denominator every time it encounters a decimal literal
17:48:12 <haasn> even *before* type checking
17:48:15 <jle`> altern___: a good mental check is to see if the type signatures of the methods make sense
17:48:31 <haasn> Which sort of makes sense, if GHC's parser parses it as a Rational
17:48:43 <EvanR> haasn: thats it, it must be desugaring fractional literals into ration... yeah
17:48:46 <altern___> jle`: do you mean I need to apply monad laws first?
17:49:19 <jle`> return :: a -> VNum a doesn't make sense
17:49:25 <jle`> any more than foo :: a -> Show a
17:49:32 <jle`> because Show is a typeclass, not a type constructor
17:50:46 <dwcook> altern___: Your phrasing makes me think that you might be conceptualizing this wrong. Instead of thinking "I want to write a monad", think "I want to write a type". Then think about what operations you need over that type.
17:51:03 <dwcook> altern___: If it happens to have a Monad instance, great, but that comes afterwards.
17:51:22 <EvanR> i havent come up with many things that are monads
17:51:39 <EvanR> theyre annoying ;)
17:51:59 <dwcook> altern___: so, what operations do you need over this type?
17:52:00 <monochrom> I am not even convinced that a type is to be written. it sounds to me a function is to be written.
17:52:09 <dwcook> (And what type are we discussing? Is it this VSize one?)
17:52:20 <haasn> But are functions written or discovered?
17:52:43 <EvanR> the function was in this block of all 1s before i removed some bits ;)
17:52:46 <monochrom> a friend once put it greatly: "is math inflicted or discovered?" :)
17:54:27 <dwcook> monochrom: The way I see it, it might turn out that standard types can be used, and if so, great. Otherwise we're still talking about what operations we want over our data.
17:54:34 <altern___> dwcook: I am trying to come up with a good example.. I will share something in a minute
17:54:44 <dwcook> altern___: Okay. Take your time.
18:00:21 <haasn> monochrom: I think it's valid to approach programming as first deciding what something *is* (without thinking about implementation), and then figuring out how to write a function to get from where we are to where we want to be
18:00:54 <haasn> To go to a certain extreme, one could design a data type that *only* permits legal and sane values
18:01:11 <EvanR> i have a question. lets say i have a type which exports a Group interface, or its implementing a Group class. is it possible for me to somehow represent a type which is a principle homogeneous space for this group type, but make this work for any such group type, polymorphically?
18:01:38 <stephenmac7> Is it possible to use aeson on a type with multiple constructors?
18:03:08 <ion> In the list of built-in instances youâ€™ll find e.g. (FromJSON a, FromJSON b) => FromJSON (Either a b)
18:03:19 <copumpkin> EvanR: define a Torsor class and be polymorphic over that? I'd use TypeFamilies
18:03:29 <EvanR> oh
18:03:45 <stephenmac7> ion: Nevermind, it seems I made the mistake of asking before googling
18:04:03 <EvanR> copumpkin: what the feature im thinking of, associated type?
18:04:17 <copumpkin> class Group (Diff a) => Torsor a where type Diff a; diff :: a -> a -> Diff a; add :: a -> Diff a -> a
18:04:32 <copumpkin> EvanR: yeah
18:04:35 <EvanR> thats called type families? or
18:04:46 <copumpkin> you need to enable the TypeFamilies extension to make it work
18:06:05 <EvanR> hahaha awesome
18:06:27 <copumpkin> you could also do it with a multiparameter typeclass and a fundep
18:06:30 <copumpkin> but I wouldn't
18:07:50 <EvanR> i am more familiar with the type families
18:08:07 <EvanR> are fundeps good for anything?
18:08:14 <copumpkin> sure
18:08:37 <copumpkin> much more pleasant to write bidirectional linkage with them than type families
18:08:50 <haasn> Inst (A B) (C D) => foo  -- easier than (Inst (A B), T (A B) ~ C D) => foo
18:08:56 <haasn> this is an example of where MPTCs+FunDeps can be much cleaner
18:09:07 <haasn> Oh, yes, also they're more flexible than simply a -> b
18:09:19 <EvanR> bidirectional linkage?
18:09:35 <haasn> class Foo a b | a -> b, b -> a
18:09:56 <haasn> or class Foo s t a b | s a -> b t -- or whatever, basically more complicated associations
18:10:31 <EvanR> so this means given an a, or given a b, the instance is uniquely determined
18:11:18 <haasn> â€œor given a bâ€ reads awkwardly :) but ye s
18:11:32 <heatsink> I thought it was that the pair s a uniquely determines b and t
18:11:50 <EvanR> and instance Foo A B and instance Foo C B is illegal?
18:11:54 <haasn> EvanR: yes
18:12:32 <haasn> in TF world, instance Foo A where T A = B and instance Foo C where T C = B -- is fine
18:13:11 <EvanR> whats a good operator for groups
18:14:06 <benzrf> :t (+++)
18:14:07 <benzrf> mhm
18:14:07 <lambdabot> ArrowChoice a => a b c -> a b' c' -> a (Either b b') (Either c c')
18:14:19 <benzrf> i think thers a Data.Group int there
18:14:25 <benzrf> but maybe <>+
18:14:36 <benzrf> :t (<+>)
18:14:37 <lambdabot>     Ambiguous occurrence â€˜<+>â€™
18:14:37 <lambdabot>     It could refer to either â€˜Control.Arrow.<+>â€™,
18:14:37 <lambdabot>                              imported from â€˜Control.Arrowâ€™ at /home/lambda/.lambdabot/State/L.hs:36:1-20
18:14:40 <benzrf> eeh
18:15:02 <EvanR> Data.Group uses <>
18:15:06 <ion> Yes, it could indeed refer to either Control.Arrow.<+>
18:15:08 <benzrf> oh eh
18:15:22 <benzrf> :t (<><)
18:15:23 <lambdabot>     Not in scope: â€˜<><â€™
18:15:24 <lambdabot>     Perhaps you meant one of these:
18:15:24 <lambdabot>       â€˜<>â€™ (imported from Data.Monoid),
18:15:41 <benzrf> @let _ <>< _ = "fishy!!"
18:15:44 <lambdabot>  Defined.
18:15:54 <benzrf> > "ocean " <>< "more ocean"
18:15:56 <lambdabot>  "fishy!!"
18:15:58 <EvanR> @let (<>') = (<>)
18:15:59 <lambdabot>  Parse failed: Improper character constant or misplaced '
18:16:09 <EvanR> @let (<>.) = (<>)
18:16:11 <lambdabot>  Defined.
18:17:56 <benzrf> does optparse-applicative have any support for subcommands
18:18:32 <dwcook> I'd think Group wouldn't have its own operator, using Monoid's instead.
18:19:20 <dwcook> Hmm, is there even a Group in base? I see this groups package
18:19:34 <benzrf> eh
18:20:03 <benzrf> @let class Monoid g => Group g where inv :: g -> g
18:20:05 <lambdabot>  Defined.
18:20:19 <EvanR> i found this on reddit way after figuring it out at length from other sources >_< http://www.reddit.com/r/haskell/comments/166iju/subtractable_values_are_torsors/
18:20:20 <benzrf> @let instance Group Sum where inv = negate
18:20:21 <lambdabot>  .L.hs:170:16:
18:20:22 <lambdabot>      Expecting one more argument to â€˜Sumâ€™
18:20:22 <lambdabot>      The first argument of â€˜Groupâ€™ should have kind â€˜*â€™,
18:20:22 <lambdabot>        but â€˜Sumâ€™ has kind â€˜* -> *â€™
18:20:22 <lambdabot>      In the instance declaration for â€˜Group Sumâ€™
18:20:27 <benzrf> eh?
18:20:27 <EvanR> benzrf: yeah thats better
18:20:38 <benzrf> @let instance Num a => Group (Sum a) where inv = negate
18:20:39 <lambdabot>  Defined.
18:20:42 <benzrf>        jjjjjj
18:22:14 <EvanR> > inv (Sum 3) :: Group (Sum Int)
18:22:16 <lambdabot>  Expected a type,
18:22:16 <lambdabot>    but â€˜L.Group (Data.Monoid.Sum GHC.Types.Int)â€™ has kind â€˜Constraintâ€™
18:25:45 <EvanR> > Sum 3 <> Sum 2
18:25:47 <lambdabot>  Sum {getSum = 5}
18:26:07 <EvanR> > inv (Sum 3)
18:26:09 <lambdabot>  Sum {getSum = -3}
18:26:17 <EvanR> :t it
18:26:18 <lambdabot>     Not in scope: â€˜itâ€™
18:26:18 <lambdabot>     Perhaps you meant one of these:
18:26:18 <lambdabot>       â€˜idâ€™ (imported from Data.Function),
18:49:21 <benzrf> hehehe https://twitter.com/PLT_Hulk/status/462623729810694144
18:53:52 <ion> heh
18:54:45 <benzrf> ion: next tweet was https://twitter.com/PLT_Hulk/status/462627213566033920
19:38:30 <EvanR> im having trouble formulating this. the months (June 2014, July 2014...) and the notes (G, G#, ...) are both torsors of the additive group of integers. they seem to have the exact same structure but i cant find a definition of "isomorphism" which they satisfy
19:42:12 <SrPx> Hmm, I am the only one who has a feeling that (>) is inverted?
19:42:18 <SrPx> > let biggerThan10 = (>) 10 in biggerThan10 5
19:42:20 <lambdabot>  True
19:42:29 <_1_Sam24> hi
19:42:31 <SrPx> 5 is nawt bigger than 10 }:
19:42:38 <EvanR> funny
19:43:05 <copumpkin> (> 10) vs. (>) 10
19:43:13 <EvanR> > let biggerThan10 x = 10 > x in biggerThan10 5
19:43:15 <lambdabot>  True
19:43:30 <pqmodn> EvanR: Z12 -- integers under addition mod 12?
19:43:38 <EvanR> no, all the integers
19:44:01 <EvanR> funny that 12 appears in both, thats not the point
19:44:05 <pqmodn> oh
19:44:09 <SrPx> let biggerThan10 = (> 10) in biggerThan10 5
19:44:12 <SrPx> > let biggerThan10 = (> 10) in biggerThan10 5
19:44:14 <lambdabot>  False
19:44:19 <SrPx> Oh
19:44:42 * SrPx is confused
19:44:51 <EvanR> > (-) 3 4
19:44:52 <lambdabot>  -1
19:44:59 <copumpkin> (>) on its own is just the function, which means that its first argument is 10
19:45:02 <copumpkin> when you write (>) 10
19:45:15 <copumpkin> which is equivalent to \x -> 10 > x
19:45:27 <copumpkin> (> 10) makes 10 its second argument
19:45:35 <SrPx> that is what I don't get. Why?
19:45:43 <copumpkin> why what?
19:45:53 <SrPx> why (> 10) makes 10 its second argument
19:46:06 <EvanR> its a section, a different syntactic thing from (>)
19:46:07 <Maxdamantus> _ > 10
19:46:08 <copumpkin> because it's convenient and someone thought it'd be nice to have syntax for things liek that
19:46:17 <EvanR> contrast (10 >)
19:46:19 <copumpkin> (/ 10) 20
19:46:21 <copumpkin> > (/ 10) 20
19:46:23 <lambdabot>  2.0
19:46:36 <copumpkin> > (^2) 10
19:46:37 <lambdabot>  100
19:46:42 <copumpkin> > (2^) 10
19:46:43 <lambdabot>  1024
19:46:53 <SrPx> why go through that trouble of having specialised syntax, instead of just inverting the order of the arguments of > ? Then both ((>) 10) and (> 10) would do the same thing
19:47:07 <Axman6> SrPx: (>) === (\x -> \y -> x > y), so (>) 10 ==> (\y -> 10 > y)
19:47:12 <copumpkin> because inverting the arguments is weird
19:47:28 <EvanR> SrPx: you can invert them if you wish. flip (>)
19:47:33 <copumpkin> it's not specialized syntax for (>)
19:47:37 <copumpkin> it's just syntax for any binary operator
19:47:42 <SrPx> yes I get that
19:47:49 <Axman6> why should the arguments be inverted? we're not going to special case syntax just for a few funct5ions
19:47:52 <Maxdamantus> `(_ > 10)` and `(10 > _)` create a function that fills the gap with its argument. The gap is just represented by nothing though, not an underscore.
19:49:07 <Maxdamantus> That's the intuition.
19:49:54 <Maxdamantus> (>) is just a way to refer to the identifier used for the binary operator, which is usually a function.
19:50:39 <Maxdamantus> > (>) 5 10
19:50:40 <lambdabot>  False
19:50:57 <EvanR> usually
19:51:08 <EvanR> > let (+) = 9 in (+)
19:51:08 <Maxdamantus> > let (>) = 10 in (>) + (>)
19:51:10 <lambdabot>  can't find file: L.hs
19:51:10 <lambdabot>  20
19:51:15 <EvanR> who won
19:51:20 <Maxdamantus> I did.
19:51:28 <EvanR> heh
19:51:44 <Maxdamantus> So it has a race condition there?
19:52:27 * hackagebot Bang 0.1.0.0 - A Drum Machine DSL for Haskell  http://hackage.haskell.org/package/Bang-0.1.0.0 (5outh)
19:56:45 <EvanR> let f :: Month -> Note be June 2014 -> G, July 2014 -> G#, and so on. then f(m1) - f(m2) == m1 - m2 for all months m1 and m2... and f has an inverse... so they are isomorphic
19:58:26 <EvanR> but in this case theres an infinite number of such f that work
19:58:42 <Lutin`> Well of course
19:58:46 <Rehty77> Does anyone know how to order a list?
19:58:49 <Lutin`> I mean
19:58:54 <Rehty77> I know this may sound nooby
19:59:02 <Lutin`> Not an -infinite-
19:59:08 <Rehty77> But I am kind of a derpy noob
19:59:09 <Rehty77> :D
19:59:11 <Lutin`> There's 12
19:59:14 <Lutin`> Rehty77: You mean sort?
19:59:14 <copumpkin> :t sort
19:59:16 <lambdabot> Ord a => [a] -> [a]
19:59:20 <Rehty77> ok
19:59:20 <EvanR> i thought it was gcd(12,12) = 12 but
19:59:42 <Rehty77> exactly
19:59:45 <Rehty77> I mean sort
20:00:01 <EvanR> Lutin`: i guess i messed up, G4, G#4, ... ;)
20:00:12 <EvanR> Z
20:00:28 <EvanR> without origin
20:00:47 <Lutin`> Ah yes with octaves
20:00:52 <Lutin`> Otherwise it's just Z_12
20:01:06 <EvanR> right, same as months without years
20:01:12 <Lutin`> and hours :D
20:01:26 <EvanR> and donuts
20:01:57 <Lutin`> And unfortunately not digits :[
20:02:07 <Lutin`> stupid five fingered hands
20:02:15 <EvanR> were switching to base 12 at work, at least my department. its better.
20:02:26 <Lutin`> Man I wish I could do that
20:02:28 * hackagebot handle-like 0.0.0.5 - HandleLike class  http://hackage.haskell.org/package/handle-like-0.0.0.5 (YoshikuniJujo)
20:02:50 <EvanR> base 18 will be like our "octal"
20:03:11 <Lutin`> ?
20:03:15 <EvanR> i dont know
20:03:47 <Lutin`> lol np
20:05:25 <Lutin`> Do you use Haskell at work?
20:05:32 <EvanR> so what about a "FileT" monad where your computation assumes some open file handle in context, and if something goes wrong the whole thing aborts with an ERRNO
20:05:48 <EvanR> no i dont
20:06:12 <EvanR> i find sanity in haskell when i can, off the clock
20:06:18 <Lutin`> Same
20:06:35 <Lutin`> Most of our projects are web with python/php backends
20:06:37 <ab9rf> i wrote a web app in haskell once
20:07:35 <EvanR> i hacked a legacy (very important) php app at work to give me all the various errors and exceptions, including "fatal errors" including syntax errors
20:07:36 <ab9rf> it had been written in some ugly grotty perl code
20:07:46 <Lutin`> oh man
20:07:52 <Lutin`> a web app in perl
20:07:56 <EvanR> but if theres syntax errors in the file that sets that up, it doesnt work
20:08:03 <EvanR> white screen effect
20:08:18 <Lutin`> Have you ever worked with Magento?
20:08:35 <EvanR> we have to deal with it sometimes but i havent myself
20:08:47 <Lutin`> Don't haha
20:09:55 <EvanR> man, i miss direct-fastcgi haskell lib, and the websockets lib
20:10:06 <EvanR> im not sure they both exist anymore
20:10:28 <EvanR> im sure theres some fancy snap stuff these days
20:10:51 <EvanR> killer app? funno
20:11:39 <Lutin`> The most popular seem to be warp based or yesod
20:11:55 <akurilin> Say I have an averaging function. Does it generally make more sense to error out if I pass an empty list into it or is NaN sensible? To me it makes more sense to fail fast so I can fix the root issue.
20:12:00 <akurilin> But I might be missing some pattern here
20:12:19 <EvanR> Lutin`: at work, i try to use sinatra for the petty web tools they tend to need, saner than rails
20:12:29 * hackagebot Bang 0.1.0.1 - A Drum Machine DSL for Haskell  http://hackage.haskell.org/package/Bang-0.1.0.1 (5outh)
20:12:31 * hackagebot haskakafka 0.2.0.1 - Kafka bindings for Haskell  http://hackage.haskell.org/package/haskakafka-0.2.0.1 (tdimson)
20:12:49 <Lutin`> Haven't done much ruby, but from what I've seen there are some nice patterns
20:12:57 <EvanR> akurilin: i would make it so you cant pass in an empty list. for instance (a,[a]) -> b instead of [a] -> b
20:13:09 <EvanR> or some other thing
20:13:10 <Lutin`> Tried rails once but seemed to have too much baggage
20:13:27 <EvanR> its really bad these days
20:14:38 <EvanR> ruby itself can be wrangled with discipline
20:14:39 <Lutin`> akurilin: You could have it return maybe? But since you'd probably be returning a Float NaN might be sensible
20:14:57 <ab9rf> mmmm.
20:14:57 <EvanR> average of nothing makes not much sense, like division by zero
20:15:04 <EvanR> would avoid using types
20:15:48 <ab9rf> there's no difference in type between an empty list and a nonempty list.  you can't use types for that
20:16:07 <EvanR> i suggested (a,[a]) as the argument of your function
20:16:10 <EvanR> instead of [a]
20:16:15 <ab9rf> which is ugly as potatoes
20:16:19 <EvanR> alright
20:16:29 <Lutin`> Eh going by what Prelude does, maybe an Exception
20:16:37 <EvanR> that is my second suggestion
20:16:46 <EvanR> use error "average of empty list"
20:16:50 <EvanR> and then dont pass in an empty list
20:17:28 <EvanR> i prefer total functions
20:18:03 <EvanR> (a,[a]) is not hard to use and ensures you cant fuck up
20:18:58 <copumpkin> you can also define a nonempty list type
20:19:00 <copumpkin> and ask for that
20:19:12 <shachaf> I,I most list types are nonempty
20:19:42 <EvanR> today i found this lib data-checked so you can require Property NonEmpty [a] => in your signature
20:20:12 <EvanR> theres non empty list types too
20:21:07 <EvanR> or return NaN and be damned!
20:21:24 <EvanR> were all sons of bitches
20:21:26 <Lutin`> Issue is NaN seems to propagate through
20:21:33 <Lutin`> s/seems/tends/
20:21:56 <EvanR> well yes, it would indicate you fucked up and would go uncrashing for a while
20:23:06 <enthropy> EvanR: is it https://github.com/pseudonom/phantheck ?
20:24:15 <EvanR> http://hackage.haskell.org/package/Checked-0.0.0.2
20:24:26 <EvanR> that is not right
20:24:55 <EvanR> https://github.com/mvv/data-checked
20:25:02 <Lutin`> or http://hackage.haskell.org/package/data-checked-0.3
20:25:07 <EvanR> yes
20:25:32 <EvanR> this pattern seems to fit exactly with how we usually do it
20:25:40 <EvanR> just implicitly
20:26:43 <funfunctor> hi
20:27:52 <funfunctor> i'm working on trying to implement a parser for a language where scope matters a bit, for example:
20:27:58 <funfunctor> foo {
20:28:09 <funfunctor>    bar {
20:28:18 <funfunctor>      key "value"
20:28:53 <enthropy> EvanR: funny that such a library does `holds (undefined âˆ· p) v', when `hold (Proxy :: Proxy p) v' is "safer"
20:29:17 <EvanR> enthropy: really?
20:29:29 <enthropy> https://github.com/mvv/data-checked/blob/master/src/Data/Checked.hs#L49
20:29:58 <EvanR> whats the difference
20:30:35 <funfunctor> The problem is, I also want a REPL where I can go in and out of scope setting key/value pairs accordingly. Is Parsec suitable for this sort of thing?
20:30:36 <enthropy> that somebody can make a mistake and write  instance Property P v where holds !x y = True
20:31:15 <enthropy> > undefined
20:31:17 <lambdabot>  *Exception: Prelude.undefined
20:31:18 <EvanR> yeah, the doc says do not use the first argument, and if they do something like !x it will crash in sort order wouldnt it?
20:31:22 <enthropy> then the program just gives you that
20:32:02 <enthropy> hmm, I think phantheck
20:32:04 <EvanR> this lib uses it http://hackage.haskell.org/package/text-latin1-0.2/docs/Text-Ascii.html
20:32:12 <enthropy> is more ambitious in terms of propagating results
20:32:20 <EvanR> holds _ x = x < 128
20:32:36 * EvanR reads phantheck
20:32:56 <enthropy> yeah it's perfectly fine if you don't make a mistake in the Property instance
20:33:13 <enthropy> then again, you don't need these Property things if you don't make mistakes
20:33:40 <dfranke> I just wrote some amusingly twisty exception-handling code.
20:34:05 <pavonia> funfunctor: What do you mean by go in and out?
20:34:58 <dfranke> I'm using a library (llvm-general) that throws a lot of generic userErrors (monadic 'fail' actions) internally. I want to tag those exceptions as originating from llvm-general so that higher-level exception handlers can distinguish them.
20:35:17 <funfunctor> pavonia: right so, think of it like a file system hierarchy, foo/bar would be foo { bar { key "value" } }
20:35:37 <dfranke> Easy so far. Just put an exception handler around calls into llvm-general that catch exceptions and rethrow them as a different type.
20:36:14 <dfranke> But, llvm-general has a lot of bracketing functions that look like withFoo :: (Foo -> IO a) -> IO a
20:36:20 <funfunctor> pavonia: on the prompt I want to be able to do repl> edit foo and then repl[foo]> edit bar so that repl[foo/bar]>
20:36:40 <funfunctor> does that make sense?
20:36:42 <dfranke> and I want to tag exceptions thrown by the bracketing function itself, but not exceptions thrown by the callback.
20:36:56 <EvanR> enthropy: yeah, its the kernel of trust thing. im still not sold on tests
20:36:56 <dfranke> solution: http://lpaste.net/105258
20:37:59 <pavonia> funfunctor: Okay, but how is that related to parsing? It's just data value manipulation, no?
20:38:39 <pavonia> funfunctor: I mean you can of course use Parsec for pasring the REPL commands
20:38:58 <funfunctor> pavonia: because depending on scope the parser may need to act differently, i'm not sure
20:39:32 <Lutin`> Sounds more like the interpreting step
20:39:33 <funfunctor> pavonia: here is my concept doc https://gist.github.com/victoredwardocallaghan/7f385994a4fb94f1b5eb
20:39:43 <Lutin`> unless you want to check if things are in scope while parsing
20:39:47 <pavonia> funfunctor: Ah, I see. Yes, you can use e.g. Reader or State with ParsecT
20:40:22 <funfunctor> hmm good point
20:40:26 * enthropy thought ParsecT has some parameter for user state
20:41:10 <pavonia> Not sure if the parser really needs to parse differently, though
20:41:18 <funfunctor> ok so architecturally I would like each scope to have its own Haskell module with its own set of functions and key/value pairs shoved into data-types
20:41:46 <funfunctor> pavonia: bare in mind I am not very experienced in Parsec at all
20:43:05 <funfunctor> I kind of need a bit of a kick in the bum to figure out how to get started if you know what I mean?
20:43:56 <pavonia> You could have a parser that acts the same no matter what context and have an additional context check, or you could pass a state to the parser that is used for parsing
20:45:06 <pavonia> or at least a set with all possible key names
20:47:56 <funfunctor> there is way too many key names and they will be extendable in the future
20:48:04 <funfunctor> so it really needs to be modular
20:48:29 <EvanR> you can change the set
20:48:50 <funfunctor> I know what I need in 'theory' and sort of how it should 'look' but not exactly how to do it yet
20:50:11 <funfunctor> I sort of imagine context driven tag typed AST trees
20:51:00 <funfunctor> each tree is expected to have a certain form as so to ensure all keys have been set/defined
20:51:12 <EvanR> maybe you should just parse a basic ast and interpret the semantics afterward
20:51:37 <EvanR> parsing can be tricky enough without having to worry about modifying state
20:51:50 <funfunctor> true
20:52:10 <funfunctor> I'm just a bit lost where to start
20:52:59 <funfunctor> I guess i'll read http://kunigami.wordpress.com/2014/01/21/an-introduction-to-the-parsec-library/ now
20:56:40 <EvanR> > toRational (1/0)
20:56:42 <lambdabot>  1797693134862315907729305190789024733617976978942306572734300811577326758055...
20:56:58 <funfunctor> what!? ^
20:57:08 <Lutin`> > toRational Infinity
20:57:10 <lambdabot>  Not in scope: data constructor â€˜Infinityâ€™
20:57:36 <EvanR> you didnt learn about the largest rational in school? ;)
20:58:30 <funfunctor> EvanR: I have a morphism that maps me from that answer to the word "silly"
20:58:57 <funfunctor> that should come back with "undefined"
20:59:04 <EvanR> a string?
20:59:57 <EvanR> the behavior is silly, but some of the standard classes dont make sense for floats
21:03:53 <jmcarthur> > (1/0) :: Rational
21:03:55 <lambdabot>  *Exception: Ratio has zero denominator
21:03:58 <pepper_chico> hi, I'm following "Learn You a Haskell for Great Good" and at chapter explaining case and where, there's a "case of" code almost like this http://bl.ocks.org/anonymous/raw/23b5c29c260241d9cf19/ but in my current ghc it doesn't compile because of a error in that line with X. Why? and was that ok before since the book is using such code?
21:04:51 <shachaf> pepper_chico: I think I see what the problem is, but you should post your error.
21:05:15 <pepper_chico> shachaf "parser error on input ->"
21:05:22 <shachaf> That's not a full GHC error.
21:05:36 <Lutin`> 1/0 is defined in IEEE 754 to be +- Infinity
21:06:00 <pepper_chico> shachaf sample.hs:4:52:
21:06:01 <pepper_chico>     parse error on input `->'
21:06:15 <funfunctor> EvanR: no not a string sorry, just a type undefined
21:06:26 <pepper_chico> that's what I get, I should them pass some flag to get more verbose stuff
21:06:30 <shachaf> OK.
21:06:30 <funfunctor> so the type-checker stops it from compiling
21:06:33 <pepper_chico> s/them/then/
21:06:43 <shachaf> The problem is that every case of the case-of needs to be indented the same amount.
21:06:48 <shachaf> But the last one is indented one extra space.
21:07:07 <shachaf> So delete the space before the _.
21:07:34 <pepper_chico> shachaf, indeed thanks, sadly... the other way was prettier
21:07:40 <EvanR> funfunctor: well its defined as returning Rational, and in general the compiler doesnt know if you passed in Infinity
21:07:41 <pepper_chico> for me at last
21:08:01 <Lutin`> :t 1/0
21:08:03 <lambdabot> Fractional a => a
21:08:06 <funfunctor> EvanR: 1/0 isn't infinity its just undefined
21:08:17 <EvanR> funfunctor: with Double, 1/0 is Infinity
21:08:22 <Lutin`> EvanR: It is for floating-point numbers
21:08:26 <Lutin`> woops
21:08:28 <Lutin`> funfunctor:
21:08:35 <EvanR> thats the source of the issue
21:08:38 <pepper_chico> >(1/0) :: Double
21:08:45 <funfunctor> but that is a lie
21:08:48 <funfunctor> because its not
21:08:53 <Lutin`> Yes but that's the standard
21:08:55 <EvanR> > take 5 cake
21:08:57 <lambdabot>  Not in scope: â€˜cakeâ€™
21:08:57 <lambdabot>  Perhaps you meant one of these:
21:08:57 <lambdabot>    â€˜takeâ€™ (imported from Data.List),
21:08:57 <lambdabot>    â€˜Seq.takeâ€™ (imported from Data.Sequence),
21:08:57 <lambdabot>    â€˜BSLC.takeâ€™ (imported from Data.ByteString.Lazy.Char8)
21:08:57 <Lutin`> blame IEEE
21:09:00 <EvanR> damn
21:09:43 <funfunctor> A good reason to break "standards" is when the "standard" has the mathematical understanding of a 12yo
21:09:47 <EvanR> funfunctor: in any case it shouldnt be surprising this is how it is in every language
21:10:39 <funfunctor> EvanR: No the surprising part is how no one is prepared to break away and move forward
21:11:09 <EvanR> well it works if you dont use Double
21:11:42 <EvanR> > let x = 1/0 :: Rational in toRational x
21:11:44 <lambdabot>  can't find file: L.hs
21:11:47 <EvanR> > let x = 1/0 :: Rational in toRational x
21:11:48 <lambdabot>  *Exception: Ratio has zero denominator
21:12:05 <Lutin`> funfunctor: I agree, but you need to take that up with chip manufacturers
21:12:48 <EvanR> > let x = 1/0 :: CReal in toRational x
21:12:49 <lambdabot>  *Exception: CReal.toRational
21:13:12 <EvanR> nvm that wouldnt make sense, though why is it even an instance of Real
21:13:35 <Lutin`> Ugh I hate IEEE. IEEE 754-2008 isn't publicly accessable
21:13:38 <funfunctor> Lutin`: what has it got to do with the chip ISA? we can refuse to do it at the abstract level
21:14:00 <EvanR> Double has implications, you dont have to use it
21:14:08 <funfunctor> The type-checker could just say "2014 baby"
21:14:33 <Lutin`> Not the type-checker, but the runtime yes.
21:14:36 <EvanR> --refuse-to-use-floats ;)
21:15:01 <funfunctor> I rather divide by 0 not be runtime issue any more
21:15:04 <Lutin`> But you'd lose performance and potentially break FFI
21:15:07 <funfunctor> the hw can trap on that
21:15:12 <Lutin`> I agree
21:15:59 <EvanR> you dont want it to get to the point whre the hw traps that
21:16:06 <EvanR> thats a bug
21:16:17 <EvanR> its like segfault
21:17:57 <funfunctor> well actually the hw just jmp to 'an address' and the OS puts a handler there and printk("are you nuts dude.."); back to you
21:18:12 <Lutin`> Still a runtime issue :P
21:18:17 <funfunctor> or firmware
21:18:21 <funfunctor> yes runtime
21:18:22 <EvanR> would rather not deal with that
21:18:48 <funfunctor> make x/0 an invaild type it could never compile
21:18:54 <EvanR> good idea
21:19:10 <funfunctor> :)
21:19:14 <EvanR> haha
21:19:42 <Lutin`> Wouldn't solve the problem
21:19:59 <funfunctor> CS "invaild type" <-> Mathematics "your making undefined rubbish up"
21:20:00 <Lutin`> > (\x -> 1/x) 0 :: Double
21:20:01 <lambdabot>  Infinity
21:20:15 <EvanR> well yeah it wouldnt solve it for doubles, Infinity is a valid value
21:20:23 <Lutin`> > (\x -> 1/x) 0 then
21:20:25 <lambdabot>  <hint>:1:15: parse error on input â€˜thenâ€™
21:20:26 <Lutin`> whoops
21:20:31 <pepper_chico> I'm noob in haskell and in chapter 4 of LYHFGG. I've seen usage of type class as constraints and some declarations but I still haven't gone far to understand the main declaration, why is it :: IO (), it's the only one till now that needs parentheses
21:20:40 <funfunctor> > (\x -> 1/x) 0
21:20:42 <lambdabot>  Infinity
21:20:49 <EvanR> pepper_chico: () is a type in of itself
21:20:51 <funfunctor> ^ lies
21:21:15 <EvanR> pepper_chico: IO is a type constructor, you could have IO Int, IO String, in this case its IO ()
21:21:36 <Lutin`> :t (\x -> 1/x)
21:21:38 <lambdabot> Fractional a => a -> a
21:21:54 <pepper_chico> EvanR so it constructs a new type from its type parameters?
21:22:37 <EvanR> pepper_chico: right, IO Int and IO () are different types. () is simple, it has one value
21:22:49 <EvanR> > ()
21:22:51 <lambdabot>  ()
21:22:52 <EvanR> :t ()
21:22:54 <lambdabot> ()
21:23:00 <EvanR> too simple maybe ;)
21:23:20 <pepper_chico> EvanR what I should import to get IO in ghci?, so I could check :t IO () here
21:23:29 <EvanR> IO () is conventionally use for IO actions with no interesting result
21:23:40 <ReinH> pepper_chico: nothing. the IO constructor isn't exported.
21:24:11 <ReinH> EvanR: although IO a could be as well. ;)
21:24:16 <Lutin`> :t return ()
21:24:17 <lambdabot> Monad m => m ()
21:24:18 <EvanR> yes
21:24:53 <EvanR> :t return undefined
21:24:54 <lambdabot> Monad m => m a
21:25:08 <pepper_chico> ReinH ok, so, I tried :t IO () but got not in scope: data constructor `IO'
21:25:18 <EvanR> :t takes a value not a type
21:25:19 <lambdabot> parse error on input â€˜typeâ€™
21:25:20 <Lutin`> IO () is a type
21:25:28 <pepper_chico> ah
21:25:30 <ReinH> The only ways to construct a value of type IO () are return () or some exported function that provides an IO () like print
21:25:31 <pepper_chico> true
21:25:38 <Lutin`> You can do :k for kind
21:25:48 <EvanR> :k IO ()
21:25:49 <Lutin`> But that's not too interesting in this case
21:25:50 <lambdabot> *
21:26:00 <pepper_chico> ok, thanks =D
21:26:14 <shachaf> :t fmap (const ()) getLine
21:26:15 <lambdabot> IO ()
21:26:45 <ReinH> shachaf: fair.
21:27:17 <pepper_chico> ok, at last now I know IO () is a type in itself, I can now wait for the time to know that in fact is such a type
21:27:36 <pepper_chico> s/that in fact/what in fact/
21:27:44 <EvanR> main for example
21:27:48 <Lutin`> shachaf: And what does the Functor instance for IO use? ;)
21:28:12 <shachaf> Lutin`: Depends on the implementation.
21:28:25 <pepper_chico> EvanR I know main is of such type, but I don't get what IO is
21:28:34 <pepper_chico> or IO some_type
21:28:37 <SuperMind> IO () is generally the return type of an operation which is only interesting because of its side effects.
21:28:49 <pepper_chico> hmmm
21:28:58 <SuperMind> like main :: IO ()
21:28:58 <Lutin`> It's defined in Prelude as `fmap f x =  x >>= (return . f)`
21:28:58 <shachaf> return isn't magic, or special. There's a large exported API of things involving IO. getLine is part of it. The Monad and Functor instances for IO are two other parts.
21:29:04 <EvanR> pepper_chico: IO Int is an IO action that results in an Int, possibly doing IO effects
21:29:24 <pepper_chico> thanks, now I got it all =D
21:29:32 <Maxdamantus> The operation doesn't have side effects.
21:29:36 <SuperMind> :t putStrLn "Hello World"
21:29:37 <lambdabot> IO ()
21:29:38 <pepper_chico> so IO is allowing for I/O side-effects
21:30:20 <EvanR> the actions are executed outside the scope of haskell the language
21:30:22 <ReinH> Nor is it an "operation" ;)
21:30:44 <pepper_chico> thanks
21:30:47 <Maxdamantus> > do{ let choices = [putStrLn "foo", putStrLn "bar", putStrLn "baz"]; choices !! 1 }
21:30:49 <lambdabot>  <hint>:1:82: parse error on input â€˜}â€™
21:32:50 <Maxdamantus> O_o
21:33:09 * Maxdamantus is still confused by Haskell's indentation syntax.
21:33:22 <SuperMind> i know this, but i am talking to a beginner, i am not sure how i shouild speak so i am both understood by beginners and satisfyingly correct enough for the rest of us.
21:33:25 <Lutin`> shachaf: https://hackage.haskell.org/package/base-4.7.0.0/docs/src/GHC-Base.html#instance%20Functor%20IO
21:33:28 <Lutin`> But I get your point
21:33:31 <EvanR> > do { let x = [1,2]; return x !! 1 }
21:33:32 <lambdabot>  <hint>:1:35: parse error on input â€˜}â€™
21:33:38 <EvanR> > do { let x = [1,2]; return (x !! 1) }
21:33:40 <lambdabot>  <hint>:1:37: parse error on input â€˜}â€™
21:33:42 <EvanR> > do { let x = [1,2]; return (x !! 1); }
21:33:43 <lambdabot>  <hint>:1:36: parse error on input â€˜;â€™
21:33:54 <Axman6> huh
21:34:21 <ReinH> pepper_chico, SuperMind: I recommend http://www.vex.net/~trebla/haskell/IO.xhtml
21:34:23 <Maxdamantus> What is this I don't even
21:34:39 <ReinH> it does a good job of explaining IO in Haskell without lying about it
21:34:53 <EvanR> IO is like a burrito
21:34:55 <pepper_chico> ReinH tks!
21:35:07 <SuperMind> oh my god, is it going to tell me about how IO is referentially transparent in the context of the haskell language... because i juts got done saying i k now that.
21:35:16 <ReinH> SuperMind: not intending to imply that you are lying, just that it's difficult to describe without being misleading.
21:35:59 <ReinH> SuperMind: you asked about how to explain it to a beginner in a way that would satisfy an experienced haskeller
21:36:05 <ReinH> that's an example
21:36:21 <SuperMind> obviously if you neeed a paper to do it, then you are in no position to talk
21:36:28 <ReinH> ?
21:36:45 * pepper_chico intends to build a site with haskell for fun hoping it's not going be a waste of time =D
21:36:46 <ReinH> I'm not sure why you are being hostile
21:36:53 <EvanR> falling back on your ... helpful info!
21:36:57 <EvanR> pitiful
21:37:29 <SuperMind> so in other words, we should talk to the beginners by recommending they read papers.
21:37:48 <Lutin`> It was a helpful article...
21:37:52 <ReinH> ...
21:37:58 <Lutin`> Accessable to beginners
21:38:06 <ReinH> it isn't a paper.
21:38:39 <pepper_chico> I will let this article for later, I still don't know what a monad is
21:38:40 <ReinH> it's an explanation of IO that is accessible to beginners and doesn't mislead
21:38:41 <pepper_chico> =D
21:38:49 <SuperMind> There is nothing helpful, if i have to replace my sentence with a whole article or something, then that's not satisfying to me.
21:38:50 <ReinH> so yes, I will recommend that beginners read it
21:38:51 <Maxdamantus> So .. what's up with the indentation thing? what is "do\n  let x = 4\n  return x" if not "do{ let x = 4; return x }"?
21:39:04 <ReinH> SuperMind: ok
21:39:08 <EvanR> pepper_chico: to learn how IO works, i would disregard "monads"
21:39:22 <Maxdamantus> Writing the first thing then just adding curly brackets to it (without changing any spacing) doesn't work either.
21:39:41 <Axman6> SuperMind: many of the papers written about Haskell are extremely approachable (especially anything written by SPJ)
21:40:00 <ReinH> SuperMind: still not sure why you're being so hostile toward me. sorry if I offended you somehow.
21:40:34 <EvanR> > do{ let x = 4; return x } :: Maybe Int
21:40:34 <pepper_chico> why can't we be friends?
21:40:36 <lambdabot>  <hint>:1:25: parse error on input â€˜}â€™
21:40:37 <pepper_chico> =D
21:40:54 <joelteon> > do { let { x = 4 }; return x } :: Maybe Int
21:40:55 <lambdabot>  Just 4
21:41:10 <SuperMind> i used the word operation and side effect, whatever... I already know that this is happening outside the context of the haskell language which is referentially transparent. What i asked, is how should i phrase things so as not to be corrected.
21:41:10 <joelteon> semicolons and braces are used for separating declarations in a let-block, as well as in do notation.
21:41:26 * Maxdamantus tried that with a newline .. didn't work.
21:41:27 <ReinH> SuperMind: I understand that.
21:41:39 <SuperMind> if you cant answer in a single sentence, then you simply are as lost to it as i am.
21:41:42 <joelteon> Maxdamantus: which did you try?
21:41:46 <pepper_chico> I got a nice prompt with this tip https://coderwall.com/p/13h9bw
21:41:54 <ReinH> SuperMind: I don't think that follows at all
21:41:59 <SuperMind> yes it does
21:42:03 <EvanR> Maxdamantus: i cant get let to work in brackets
21:42:03 <pepper_chico> just saying
21:42:05 <SuperMind> how should the sentence be phrased
21:42:07 <Maxdamantus> Uh, this is crazy.
21:42:08 <EvanR> <- works
21:42:18 <Axman6> "IO is a domain specific language that is executed by the Haskell runtime which performs all the required "IO" for you"
21:42:20 <Lutin`> Maxdamantus, EvanR: See what joelteon
21:42:22 <Axman6> how's that?
21:42:22 <Lutin`> said
21:42:29 <Maxdamantus> joelteon: "do{\n  let { x = 1 }\n  return x\n}"
21:42:38 <ReinH> SuperMind: I am not interested in performing for someone who is actively hostile and abusive towards me.
21:42:42 <Maxdamantus> That doesn't work .. but it does without the first and last curly bracket.
21:42:42 <SuperMind> Axman6, that would be an acceptable answer
21:42:45 <SuperMind> to me
21:42:58 <SuperMind> how am i abusive or hostile?
21:43:02 <Lutin`> Maxdamantus: What about "do{\n  let { x = 1; }\n  return x\n}"
21:43:03 <Maxdamantus> and it works with an extra semicolon with or without the curly brackets on the `do`
21:43:12 <Maxdamantus> Didn't try that.
21:43:12 <Lutin`> Err
21:43:18 <bitemyapp> SuperMind: want to learn Haskell?
21:43:20 <joelteon> yeah, I don't think you're meant to combine semicolons and braces.
21:43:21 <Lutin`> Semicolon in the wrong place
21:43:46 <joelteon> but yes, if you add a semicolon after the let, it will parse.
21:43:52 <ReinH> SuperMind: do you know what a "microagression" is?
21:44:04 <joelteon> I think the presence of braces makes Haskell stop worrying about newlines.
21:44:07 <bitemyapp> ReinH: can we just call it being a prick?
21:44:21 <ReinH> telling me that I don't know what I'm talking about because I didn't answer a question in a way you would prefer is hostile.
21:44:50 <joelteon> ReinH: i'll be using the term microaggression in the future, thanks
21:44:57 <ReinH> My goal was to assist pepper_chico.
21:45:03 <SuperMind> no, you didn't asnwer the question. If you do no the answer, and are not answering just to be a troll, that's aggression.
21:45:05 <EvanR> > do{ let{ x=3 }; return x } :: Maybe Int
21:45:06 <ReinH> I though it might also be of interest to you.
21:45:07 <lambdabot>  Just 3
21:45:15 <bitemyapp> SuperMind: disengage and focus on what I'm saying.
21:45:19 <bitemyapp> SuperMind: do you want to learn Haskell or not?
21:45:22 <Lutin`> Yall need to chillax
21:45:37 <SuperMind> I am not a novice haskeller, and you have no idea what you are jumping into bitemyapp
21:45:45 <ReinH> SuperMind: no, I actually am not obligated to provide you with answers.
21:46:00 <EvanR> microaggression, good word
21:46:01 * bitemyapp blinks languidly and yawns
21:46:03 <ReinH> I can choose to do so. You are not entitled to them.
21:46:11 <bitemyapp> SuperMind: what do you want to know, then?
21:46:32 <SuperMind> okay, but i'm not obligated to refrain from pointing out that your statement to me that followed my question didn't address my question at all.
21:46:41 <Lutin`> *sigh*
21:46:50 <bitemyapp> SuperMind: I'm offering to consider your question and possibly provide an answer
21:46:55 <ReinH> You can do that. It just makes you sound like an asshole.
21:46:57 <bitemyapp> SuperMind: but in order for me to do that you need to disengage and talk to me.
21:47:01 <SuperMind> Axman6, addressed my question
21:47:09 <Axman6> not very well
21:47:12 <SuperMind> which was how to speak to a newbie
21:47:23 <SuperMind> no, but better than anyone else so far
21:47:26 <bitemyapp> SuperMind: you wouldn't need that question answered if you understood Haskell
21:47:32 <bitemyapp> SuperMind: which is why I asked if you wanted to learn Haskell.
21:47:39 <bitemyapp> SuperMind: so, do you want to learn Haskell?
21:47:43 <SuperMind> I do understand haskell
21:47:53 <coppro> no you don't. nobody does
21:47:57 <Lutin`> The issue is everyone keeps being pedantic and it's very passive-agressive and you guys need to realize that
21:48:05 <joelteon> guys, not to derail your argument, but I have a question
21:48:06 <ReinH> I wasn't aware that providing a link that answers a question isn't considered answering that question.
21:48:06 <bitemyapp> SuperMind: 1. You don't 2. Do you want to learn Haskell?
21:48:08 <pepper_chico> haha, I've read some pages already, and the discussion here is still going on
21:48:14 <bitemyapp> joelteon: that would be refreshing.
21:48:23 <EvanR> "nobody understands haskell" -- einstein
21:48:25 <pepper_chico> I'll come back check again later =D
21:48:26 <joelteon> Why do people use HList instead of nested tuples?
21:48:30 <ReinH> I guess there's no pleasing some people.
21:48:34 <Lutin`> pepper_chico: Just ask
21:48:56 <bitemyapp> joelteon: nested tuples are substantially less convenient. Have you tried both and compared?
21:49:01 <joelteon> I'm about to.
21:49:32 <bitemyapp> joelteon: go with god. I try to avoid needing HList as much as possible, but knowing it's available for that one day I truly need it is nice.
21:50:12 <EvanR> i cant imagine using something like hlist for something in a sane way
21:50:31 <SuperMind> you might learn a lot by exploring it tho
21:50:34 <bitemyapp> EvanR: I can, but I'm a lisper and I'm all about the mad science.
21:50:49 <bitemyapp> ex-lisper, really. You get the idea.
21:50:56 <joelteon> EvanR: there are, as I've just found out, some type-family related applications for it
21:51:24 <ReinH> joelteon: HList and vinyl have lost a lot of mindshare to lens these days.
21:51:24 <EvanR> i can imagine lisp type stuff with it, though i stand by the sane criteria
21:51:29 <Maxdamantus> To summarise: https://gist.github.com/Maxdamantus/5fbfca173843071b2f48
21:51:59 <EvanR> joelteon: lists of things all belonging to a type family?
21:52:08 <piezoid> hi
21:52:17 <piezoid> Why ConduitM fmap and >>= are not inlined in my code, even though it's a newtype ?
21:53:02 <ReinH> piezoid: what do you mean by "in my code"? Are you looking at core?
21:53:49 <piezoid> ReinH: yes, I have some $fApplicativeConduitM_$c>>= everywhere
21:54:07 <Lutin`> Maxdamantus: Yes it's due to the layout rules of the language
21:54:08 <Lutin`> http://www.haskell.org/onlinereport/lexemes.html#sect2.7
21:54:10 <ReinH> What level of optimization?
21:54:24 <Lutin`> "The effect of layout on the meaning of a Haskell program can be completely specified by adding braces and semicolons in places determined by the layout. The meaning of this augmented program is now layout insensitive"
21:54:36 <piezoid> ReinH: O2
21:55:02 <ReinH> piezoid: hmm. unsure.
21:55:23 <Lutin`> Maxdamantus: Once you start putting braces and semicolons in, you have to go all the way
21:55:30 <pepper_chico> my first contact with functional programming language was with Mathematica some 8 years ago, more or less, learning haskell now, I recall usage of pattern matching and other functional stuff similar what I'm seeing now. Now I'm a much more experienced programmer than I was, but not in the functional realm. At the time I didn't get very deep at the functional mindset so. Anyone have an idea whether Mathematica can provide a substantial functionality
21:55:30 <pepper_chico>  of Haskell, or the language is much lower in expressivity than Haskell?
21:55:42 <Maxdamantus> Mm .. didn't know that before.
21:55:47 <piezoid> ReinH: it's building a lot of 'let sat = \x.. in ...' closures, maybe it's releated
21:55:49 <Lutin`> Me either
21:56:15 <bitemyapp> pepper_chico: they're very different things.
21:56:28 <bitemyapp> pepper_chico: Haskell is a general purpose programming language that you can learn FP in
21:56:45 <bitemyapp> pepper_chico: getting better at Mathematica is extremely unlikely to convey the same information, but it's better at its niche.
21:56:46 <Lutin`> Maxdamantus: When you run into these things the Haskell report tends to answer most issues
21:56:53 <Lutin`> Just click around and Ctrl+F
21:57:13 <pepper_chico> bitemyapp, Mathematica is quite general too, not just math stuff
21:57:16 <EvanR> now im interested in learning about the type system, whatever it is, in mathematica
21:57:30 <EvanR> i remember using it was a bitch
21:58:03 <sjy> pepper_chico: its generality is limited by the need for people who run your software to buy and install mathematica
21:59:38 <pepper_chico> I recall defining my recursive functions with patterns and initial patterns etc, like in haskell superficially
21:59:51 <pepper_chico> but not much dealing with typesystem
22:00:02 <EvanR> ah right... if you do 1 + "foo" you get... 1 + "foo"
22:00:06 <pepper_chico> I have no idea of it in mathematica
22:00:11 <EvanR> no reduction
22:00:20 <EvanR> or error
22:00:25 <EvanR> no type system ;)
22:00:30 <pepper_chico> ah
22:01:20 <EvanR> arguably better behavior than auto conversion and arbitrary results like php and js
22:01:59 <pepper_chico> indeed
22:04:56 <Lutin`> EvanR: What does Evaluate[1 + "foo"] return?
22:05:18 <EvanR> i dont have mathematica anymore but i would expect 1 + "foo"
22:05:40 <EvanR> because + doesnt have a case for Integer and String
22:06:01 <EvanR> expressions
22:06:38 <EvanR> this stack overflow was enlightening, Head[expression] gives you something like what :t gives, but its not a type its just the top most expression
22:06:56 <EvanR> http://stackoverflow.com/questions/4558732/is-mathematica-an-untyped-language
22:07:22 <pepper_chico> shouldn't wolframalpha calculate that?
22:07:37 <EvanR> Head[1 + "foo"] would be Plus
22:08:31 <Lutin`> Yeah cause 1+ "foo" is Plus[1, "foo"]
22:09:22 <Lutin`> Everything is a symbolic expression
22:09:44 <Or1> whois StoneCypher4k
22:11:47 <enthropy> hmm, there's some amount of exhaustiveness checking with GADTs now
22:17:44 <ctangent> hi all, I'm learning haskell and I'm wondering, is there a reason why "(+1)" is a function that adds an integer 1 to its argument and "(-1)" invoked in the same way doesn't work?
22:18:03 <ctangent> in the context of something like map (-1) [1, 2, 3]
22:18:21 <ctangent> vs map (+1) [1, 2, 3]
22:18:45 <crazydave> the problem is that - 1 is a partially applied function of - 1 2 ... taking 2 away from one
22:18:45 <EvanR> theres a syntax quirk with -
22:19:02 <EvanR> > (-) 1 2
22:19:03 <lambdabot>  -1
22:19:05 <crazydave> and that (-1) is a negative number the number '-1'
22:19:29 <EvanR> :t (subtract 1)
22:19:30 <lambdabot> Num a => a -> a
22:19:35 <ctangent> ah, I see
22:19:39 <EvanR> use that
22:19:43 <ctangent> so ((-)1) or subtract 1?
22:19:46 <ctangent> makes sense, thanks!
22:20:13 <EvanR> > (- 1)
22:20:15 <lambdabot>  -1
22:20:17 <EvanR> heh
22:20:18 <pingu> or...
22:20:33 <pingu> > map (flip (-) 1) [1,2,3]
22:20:34 <lambdabot>  [0,1,2]
22:20:38 <crazydave> or in other words: haskell can't tell the difference between unary minus and binary minus
22:20:54 <crazydave> because we use the same symbol for both
22:21:01 <ctangent> ah, makes sense
22:21:07 <Lutin`> ctangent: From the Haskell Report "Because - is treated specially in the grammar, (- exp) is not a section, but an application of prefix negation, as described in the preceding section. However, there is a subtract function defined in the Prelude such that (subtract exp) is equivalent to the disallowed section. The expression (+ (- exp)) can serve the same purpose."
22:21:15 <EvanR> shoulda used s expressions ;)
22:21:20 <pingu> you'll also run into that problem when defining constants
22:21:51 <Lutin`> See section 3.4 and 3.5 of http://www.haskell.org/onlinereport/exps.html if you're so inclined
22:22:09 <crazydave> "how do I take one away from a list?" "You ADD minus one to all the elements" great :)
22:22:39 <ctangent> thanks everyone!
22:22:42 <EvanR> :t take 1
22:22:44 <lambdabot> [a] -> [a]
22:22:46 * hackagebot persistent-template 1.3.1.4 - Type-safe, non-relational, multi-backend persistence.  http://hackage.haskell.org/package/persistent-template-1.3.1.4 (MichaelSnoyman)
22:22:48 * hackagebot failure 0.2.0.3 - A simple type class for success/failure computations. (deprecated)  http://hackage.haskell.org/package/failure-0.2.0.3 (MichaelSnoyman)
22:22:57 <Lutin`> Oh you
22:25:10 <carter> johnw: your blog theme is AWESOME
22:25:14 <carter> can i steal it? :)
22:25:18 <Lutin`> I think it would be nice if we had something like PEP for Haskell
22:25:42 <pharaun> Lutin`: as in code formatting standard?
22:25:53 <pharaun> if you want that it seems better to have something like gofmt ?
22:26:15 <Lutin`> I meant more for adding enhancements
22:26:25 <pharaun> ahh
22:26:26 <trillioneyes> crazydave: there's also the function subtract, which exists for this very purpose
22:26:41 <trillioneyes> `subtract 1` does what you'd expect `(-1)` to do
22:27:06 <EvanR> :t +1
22:27:08 <lambdabot> parse error on input â€˜+â€™
22:27:21 <EvanR> no unary plus
22:27:55 <Lutin`> Yes
22:28:12 <crazydave> why do you need unary plus? A numeral is considered positive.  The plus sign is superflous
22:28:14 <EvanR> a shame really
22:28:41 <Lutin`> I agree with crazydave
22:28:49 <EvanR> no unary plus is so useful!
22:28:56 <Lutin`> For what exactly
22:28:59 <EvanR> why else would it be in C and other languages
22:29:09 <Lutin`> lol
22:29:19 <EvanR> i cant think of any use
22:29:29 <Lutin`> thought you were serious
22:29:50 <johnw> EvanR: why, so you can overload it of course
22:30:11 <EvanR> to fool code reviewers into thinking a variable that is in fact holding a negative value is positive
22:30:13 <pdxleif> > :t (+1)
22:30:14 <lambdabot>  <hint>:1:1: parse error on input â€˜:â€™
22:30:15 <crazydave> omg, Stack Overflow has "why is there unary plus in language <insert language other than haskell here>" asked in every language
22:30:17 <Lutin`> obviously because If I have a negative number unary plus should make it positive right?
22:30:20 <pdxleif> :t (+1)
22:30:21 <lambdabot> Num a => a -> a
22:30:23 <Lutin`> +-1
22:30:25 <Lutin`> is 1
22:30:43 <Lutin`> unary minus needs an inverse right guys
22:30:51 <EvanR> crazydave: yeah
22:30:58 <EvanR> its that cool
22:31:18 <pepper_chico> =/
22:31:26 <Lutin`> sup chico
22:31:33 <EvanR> we also need an operator to multiply by 1
22:31:38 <pepper_chico> someone needs math before programming
22:31:50 <pepper_chico> ...
22:31:54 <pepper_chico> xF
22:31:58 <Lutin`> We're all joking lol
22:32:17 <pepper_chico> yeah yeah, don't come with that one
22:32:21 <nisstyre> crazydave: unary plus is useful just as unary negate is useful
22:32:27 <Lutin`> plz son
22:32:32 <carter> johnw: may i steal your blog theming once i migrate off blogger?
22:32:33 <carter> :)
22:32:39 <pepper_chico> son!
22:32:41 <pepper_chico> xD
22:32:49 <nisstyre> they're syntactic sugar for (negate x)
22:33:09 <Lutin`> - e is actuall in the grammar
22:33:32 <nisstyre> I meant in general not in Haskell
22:33:42 <nisstyre> sorry if that was unclear
22:33:44 <Lutin`> fair enough
22:33:51 <Lutin`> sorry for being pedantic
22:34:04 <pepper_chico> well anyway, it may convey some meaning in a language where operator overload is ok, like c++, still, it's hard to think a symmetric usage of +X and -X for some use...
22:34:34 <pepper_chico> quantum physics?
22:34:39 <pepper_chico> xD
22:34:45 <EvanR> unary plus can be syntactic sugar for id
22:34:56 <Lutin`> Yeah spins might be it
22:35:05 <pepper_chico> yeah
22:35:17 <Lutin`> But the minus there is more a direction than operation to get additive inverse
22:35:30 <Lutin`> You can't really add spins lol
22:35:58 <EvanR> in any case the + in that sense is notation for the value not an operator
22:36:07 <EvanR> +1/2
22:36:10 <EvanR> not +s
22:37:20 <EvanR> K&R 2nd: The unary + is new with the ANSI standard. It was added for symmetry with the unary -.
22:37:30 <ReinH> Lutin`: additive groups generally, although the + is redundant.
22:37:53 <Lutin`> + is the binary operator in an additive group
22:38:13 <nisstyre> what does unary + do that unary - doesn't is the question I think
22:38:33 <pepper_chico> mathematically?
22:38:38 <pepper_chico> nothing
22:39:10 <pepper_chico> programmatically overloading, you choose
22:39:37 <ReinH> Lutin`: yes, although by symmetry with negation one might say that a + (+a) = a + a
22:39:42 <EvanR> class UnaryPlus a where; + :: a -> a ;)
22:39:50 <ReinH> one generally doesn't, ofc
22:40:11 <Lutin`> Yeah that doesn't really jive with me
22:40:28 <crazydave> um Num a => a -> a I think you mean.  It isn't the id function ...it is less general
22:40:54 <EvanR> class Num a => UnaryPlus a where
22:42:00 <Lutin`> ReinH: I definitely get what you're saying though :)
22:42:40 <EvanR> submitting that to the next version of haskell review board along with 1-tuples
22:42:44 <EvanR> going to sleep
22:43:13 <ReinH> Lutin`: one can also define the integers as the Cartesian product of {"","-"} and N or, isomorphically, {"+","-"} and N :p
22:43:20 <ReinH> ok I'll stop now
22:43:54 <Lutin`> hehe
22:43:57 <nisstyre> ReinH: I prefer to define them as a proper subset of the surreal numbers
22:45:14 <Lutin`> ReinH: Depends on if your naturals includes zero ;)
22:45:27 <Lutin`> (I hate that that's up for debate)
22:46:40 <Axman6> naturals and positives are different :(
22:47:33 <funfunctor> For a long time I didn't think that naturals should contain 0 since I thought that zero was its own concept but I actually think 0 should definely be considered a natural number since you can generate the rest of the naturals from it and 1
22:47:51 * hackagebot conduit 1.1.6 - Streaming data processing library.  http://hackage.haskell.org/package/conduit-1.1.6 (MichaelSnoyman)
22:47:57 <Lutin`> You can generate the rest from just 1
22:48:18 <nisstyre> funfunctor: it doesn't matter what it's called
22:48:20 <funfunctor> Lutin`: yes but addition is better defined
22:48:23 <Lutin`> Uh
22:48:25 <funfunctor> nisstyre: I know
22:48:25 <Lutin`> 1 + 1
22:48:38 <nisstyre> funfunctor: as long as you have a first and a successor function
22:48:38 <Lutin`> But yes I get having an identity
22:48:56 <Lutin`> Nice for (N,+) to at least be a monoid
22:48:59 <Lutin`> instead of a magma
22:49:22 <funfunctor> nisstyre: exactly but without idenitiy the definition tends to be pretty useless. So its all a matter of how you consider these definitions
22:49:30 <nisstyre> 0 is the additive identity but you don't *need* that to generate the naturals
22:49:42 <nisstyre> funfunctor: yeah I agree
22:49:52 <funfunctor> well true not to _generate_ sorry I should be better with my words
22:50:00 <nisstyre> I'm just saying why some people might think 1 makes more sense, or at least as much sense as 0
22:51:25 <funfunctor> nisstyre: hehe, I realise you could write faces if you wanted.. its just a representation
22:52:06 <nisstyre> funfunctor: yeah, but I guess some people refuse to use 0 to count things
22:52:30 <ReinH> I like the integers as the inverse completion of the nats :p
22:52:33 <nisstyre> I know it's strange that these people exist
22:52:48 <ReinH> nisstyre: yes, nats include 0 :p
22:52:58 <ReinH> everyone who thinks otherwise must be shunned.
22:53:06 <funfunctor> nisstyre: its the age old war against constructivism
22:53:33 <ReinH> Counting numbers are N \ {0}
22:53:50 <ReinH> now and forever.
22:53:51 <nisstyre> funfunctor: I do think it would be better if we used smilies though
22:53:53 <funfunctor> ReinH: I think of -1 as the concept of relfection in algebra and i as the concept of ratation in algeabra
22:54:09 <funfunctor> nisstyre: same ! :D
22:54:11 <ReinH> Hmm. Those are not words but ok :p
22:54:40 <funfunctor> reflection / rotation sorry
22:54:46 <funfunctor> :)
22:55:19 <funfunctor> I'm dyslexic but there exists a representation..
22:56:39 <funfunctor> http://web.maths.unsw.edu.au/~norman/ he is at my uni
22:56:40 <nisstyre> funfunctor: if we used smilies people would have much less trouble with the idea that counting = {a,b,c,d...} {a, b, c, d..} , {b,c,d...} {b,c,d..}, etc...
22:56:53 <funfunctor> he does not 'belive' anything but the rationals
22:57:43 <funfunctor> he has arguments like, "irrations don't exist because you could never write them down..", I told him to write 6 down then told him its not 6 but 5+1 was 6.
22:57:48 <funfunctor> He did not get me
22:57:49 <funfunctor> :<
22:57:59 <nisstyre> since they would not see it as "you're saying you counted all the numbers in N and all the numbers in Q and they were the same!!??"
22:58:12 <nisstyre> funfunctor: I've seen his youtube videos
22:58:35 <nisstyre> funfunctor: he doesn't believe anyone knows what a function is
22:59:51 <funfunctor> I think he is just 'confused' by something fundamental. Mathematics is a language and he would benefit from learning some CS
23:00:18 <nisstyre> funfunctor: I actually stumbled on to his yt channel while I was looking up the Stern-Brocot tree
23:00:30 <nisstyre> his video was actually useful/interesting but then I saw the rest of his channel
23:00:59 <funfunctor> My friend likes him with the following argument "He is the closes we have to aliens mathematics because he rejects our system and makes a different system"
23:01:42 <nisstyre> funfunctor: it seems like he accepts some parts of math and rejects others that he dislikes
23:01:59 <funfunctor> sounds 'nobel' on the surface but if aliens came down with a new form of mathematics it for sure would not be his arguments !
23:02:54 <funfunctor> thats fine, but you need a better reason to reject if you ask me..
23:03:06 <nisstyre> funfunctor: I prefer actual results
23:03:20 <nisstyre> traditional geometry/algebra has shown tons of real results
23:03:22 <funfunctor> yes, I prefer motor cars, jet engines and so on..
23:03:43 <nisstyre> by "traditional" I mean everything up till now
23:03:49 <funfunctor> if you think geometry is "divine truth" you are born in the wrong age
23:04:05 <nisstyre> yeah it sounds more like something ancient Greeks would like
23:04:15 <funfunctor> for â„œeals
23:04:36 <nisstyre> maybe he should resurrect the cult of Pythagoras
23:05:02 <seanparsons> If I have a ReaderT is there a sensible way to convert that into a RWST? It seems to be eluding my mind if there is.
23:05:57 <funfunctor> nisstyre: http://web.maths.unsw.edu.au/~norman/papers/IntelligentDesignhtml/IntelligentDesign1.htm <-- I rest my case
23:06:34 <ab9rf> all my designs are intelligent
23:07:07 <funfunctor> provided they are not in Ruby
23:07:38 <funfunctor> just joking....... or am I..
23:07:40 <funfunctor> ;)
23:07:49 <ab9rf> nothing wrong with ruby that can't be explained by it being ruby
23:08:07 <funfunctor> :)
23:09:52 <nisstyre> funfunctor: oh yeah I read that one too
23:10:30 <nisstyre> funfunctor: someone at the xkcd forums started a thread on him a few years ago apparently http://forums.xkcd.com/viewtopic.php?f=17&t=72537
23:10:50 <enthropy> :t \ rm -> RWST $ \r s -> do a <- runReaderT rm r; return (a, s, mempty)
23:10:51 <lambdabot> (Monoid w, Monad m) => ReaderT r m a -> RWST r w s m a
23:11:00 <enthropy> seanparsons: dunno if there's a nicer way to write such a thing
23:11:16 <enthropy> possibly it's better if you just add WriterT and StateT on top
23:12:31 <seanparsons> Yeah, I guess I was just asking if there was an inbuilt function for it, if I've got to write my own it's no massive issue.
23:17:20 <matematikaadit> When to use `StateT s [] a` and `ListT (State s) a`?
23:17:29 <johnw> which ListT?
23:17:53 <funfunctor> nisstyre: yea, he spams the web talking himself up.. I did the start of a diff geom class with him and he didn't teach diff geom because you need more than the Q to do that.. So I quit his class and complained to the head of school..
23:18:00 <johnw> ListT over State branches on multiple possible states
23:18:23 <funfunctor> nisstyre: I don't think he likes me now :p
23:18:26 <johnw> StateT over List has one state that ranges over multiple branches
23:18:52 <enthropy> @unmtl StateT s [] a
23:18:52 <lambdabot> s -> [] (a, s)
23:19:05 <enthropy> @unmtl ListT (State s) a
23:19:05 <lambdabot> (State s) ([] a)
23:19:21 <johnw> hmm
23:19:22 <enthropy> hmm, I thought it knew about ListT
23:19:29 <johnw> i think i'm wrong then
23:19:45 <johnw> s -> [(a, s)] forks the state too
23:19:46 <enthropy> or rather that it would expand State in the second half
23:19:57 <enthropy> @unmtl ListT (StateT s IO) a
23:19:58 <lambdabot> (StateT s IO) ([] a)
23:21:14 <aspidites> are there any straight forward instructions anywhere for cross compiling for windows from linux WITHOUT using wine?
23:27:25 <ReinH> Is ListT is transformers still broken?
23:28:18 <ReinH> That unmtl for ListT is the broken one iinm?
23:29:18 <carter> what was roman's thing about making MTL with closed type families?
23:30:22 <ReinH> Uh. Um.
23:30:30 <ReinH> Fc something?
23:32:05 <ReinH> Oh just mtl-tf?
23:32:18 <carter> they removed fundeps and make it emulate extensible effects
23:32:22 <carter> and kill free monad model?
23:32:55 <ReinH> Oh monads-fd and monads-tf
23:33:41 <carter> https://twitter.com/TacticalGrace/status/475459656353992704
23:33:43 <carter> that
23:33:52 <carter> shebange = Roman
23:34:44 <carter> ReinH: any clue?
23:35:33 <ReinH> Er. Mtl is basically transformers + monads-fd though
23:35:49 <ReinH> Mtl-tf is already a type family impl
23:36:03 <ReinH> So this is new?
23:36:25 <carter> something about closed type families instead of fundeps + extesnsible effects
23:36:34 <carter> kosmikus: care to cmment?
23:37:03 <ReinH> Right but monads-tf already uses type fams instead of fund eps...
23:37:12 <qz> hello. if i want to deal with exceptions inside my own monad stack do i have to deal with stuff described here: http://www.yesodweb.com/blog/2013/08/exceptions-and-monad-transformers ? or maybe there's easier way?
23:37:17 <ReinH> Fundeps thanks autocorrect
23:37:25 <qz> that monad-control stuff scares me off..
23:37:57 <ReinH> What's the new one? Replaced ErrorT recently?
23:38:57 <carter> ReinH: https://hackage.haskell.org/package/mtl-tf looks deprecated
23:39:12 <ReinH> ExceptT https://hackage.haskell.org/package/mtl-2.2.1/docs/Control-Monad-Except.html
23:39:38 <ReinH> carter: right so this is new?
23:39:43 <carter> yes
23:39:49 <ReinH> I thought the tf approach was out of favor.
23:39:54 <carter> notice how they say "CLOSED" type families
23:40:00 <ReinH> Ah
23:40:08 <joelteon> why is tf out of favor?
23:40:33 <ReinH> joelteon: don't quite remember but Edward was talking about it
23:40:38 <carter> joelteon: if you walsy need to invoke the type fun, the fundep style is less overhead
23:40:41 <carter> ux wise
23:41:09 <ReinH> I think working with the families was just unwieldy
23:41:18 <carter> probs
23:41:33 <ReinH> I've never tried tho
23:41:34 <joelteon> now edward is maintaining mtl too?
23:41:41 <joelteon> he's going to take over the whole goddamn ecosystem soon
23:41:50 <ReinH> Soon all of... Yep
23:42:01 <carter> i've a code base rigth now where i'm doing fundeps for params i *could* do a type funs, but since i'm using the params always, fundeps makes it nicer
23:42:16 <joelteon> if you rearrange the letters in Simon Peyton Jones, it spells Edward Kmett
23:42:21 <joelteon> give or take a couple
23:42:30 <ReinH> Close enough
23:42:46 <ReinH> Also his name has three words. Three. Half life
23:42:58 <ReinH> Oh I got cut off there...
23:43:01 <joelteon> lens 3 confirmed
23:43:05 <bitemyapp> joelteon: clearly Haskell is the language of the Illuminati who are trying to bring about the Singularity that will destroy mankind.
23:43:08 <ReinH> There it is
23:43:10 <enthropy> there's another name in there
23:43:16 <joelteon> bitemyapp: that's ok with me
23:43:20 <enthropy> http://research.microsoft.com/en-us/um/people/simonpj/papers/slpj-book-1987/
23:43:25 <joelteon> ugh, I'm working with Django and node.js at work right now
23:43:40 <kosmikus> carter: hm?
23:43:45 <matematikaadit> @paste
23:43:46 <lambdabot> Haskell pastebin: http://lpaste.net/
23:43:48 <joelteon> thank you for always being here for me #haskell
23:43:49 <bitemyapp> joelteon: I'm starting to think we need to be a less open community.
23:43:56 <joelteon> why?
23:43:57 <bitemyapp> joelteon: adopt the methods of the freemasonry and ancient gnostics.
23:43:58 <carter> kosmikus: feurbach / roman tweeted about MTL + closed type familes
23:44:02 <ReinH> enthropy: wait what
23:44:03 <carter> kosmikus: and you're involved?
23:44:04 <bitemyapp> joelteon: secret things are more desirable :D
23:44:05 <carter> care to comment?
23:44:14 <joelteon> bitemyapp: you have a point
23:44:17 <Axman6> joelteon: sounds webscale
23:44:22 <joelteon> Axman6: you're goddamn right.
23:44:25 <enthropy> ReinH: SPJ used to be SLPJ
23:44:32 <ReinH> Huh
23:44:39 <Axman6> but I don't see any NoSQL, tut tut tut
23:44:42 <ReinH> The L is silent?
23:44:44 <nisstyre> GHC -> GHCHQ -> GCHQ
23:44:46 <joelteon> man, if you could produce a language that was the exact opposite of haskell in every way, it'd be Javascript
23:44:52 <carter> joelteon: i've a friend who needs to run 100 ruby servers to handle a workload you could probably do with 5 haskell servers
23:44:55 <nisstyre> clearly GHC is spying on you
23:45:06 <joelteon> yeah, I worked with Ruby before my current project
23:45:07 <kosmikus> carter: oh, we can write a "get" that can be used to access multiple state monad transformers in a stack, based on the type of the state, without using any lift
23:45:10 <ReinH> carter: sounds right
23:45:13 <joelteon> asked the CTO what it would take to put Haskell on the "approved languages" list
23:45:22 <joelteon> she said that we'd need to have more than two people in the company that know it :(
23:45:29 <carter> joelteon: how big is the company
23:45:36 <joelteon> employees or engineers?
23:45:40 <carter> both?
23:45:43 <Axman6> both!
23:45:45 <kosmikus> carter: so in that way similar to what the extensible-effects paper praises as an advantage, but we do it with "normal" monad transformers
23:45:50 <joelteon> 4000 employees, a good part of that is customer support
23:45:55 <joelteon> might be 2-300 engineers
23:45:58 <joelteon> i really don't know
23:45:59 <ReinH> They employ non-engineers?
23:46:04 <bitemyapp> joelteon: approximately two engineers of ~30-40 at my company know Haskell. Still can't use it at work.
23:46:05 <ReinH> Doing what
23:46:18 <carter> joelteon: so clearly you need to do some recruiting
23:46:25 <carter> what type of biz?
23:46:30 <Axman6> bitemyapp: get them together, form the Haskell Team!
23:46:32 <joelteon> I work for godaddy, I think some of that 4,000 is the huge number of customer support reps we have
23:46:45 <carter> joelteon: ohhhhhh, Enigmagic  is there too
23:46:52 <carter> joelteon: you could totes point to him
23:47:00 <kosmikus> carter: so this is not about getting rid of the "functional dependency" from a technical viewpoint (by replacing it with another concept, such as a type family)
23:47:00 <ReinH> How many for the elephant shooting?
23:47:13 <joelteon> haha, relevant joke.
23:47:14 <carter> joelteon: you did know he's there right?
23:47:15 <ReinH> Too soon?
23:47:26 <joelteon> I don't know how long Bob Parsons has been gone, but it's been awhile
23:47:27 <kosmikus> carter: but about getting rid of the effects of the functional dependency, namely that you can have just one MonadState instance for a specific transformer stack
23:47:45 <bitemyapp> Axman6: he's been trying to find a way to use Haskell or Elm to no avail. I tried to form such a team but ran into internal obstructionism.
23:47:47 <enthropy> kosmikus: get :: StateT s (State t) (s,t)?
23:47:51 <joelteon> I do like people making GoDaddy jokes because it reminds me how much better our public policy has been
23:47:57 <joelteon> even if our services are crap.
23:47:57 <carter> hah
23:48:18 <joelteon> but there's a big difference between being crap, and being crap *and* offensive
23:48:24 <ReinH> Happy to be of service...
23:48:50 <joelteon> well, if I didn't think I couldn't improve GoDaddy, I wouldn't be there
23:48:58 <ReinH> Seems good
23:49:23 <ReinH> I haven't heard of any elephant-level incidents in a while
23:49:45 <kosmikus> enthropy: no, for "StateT s (State t)", you could use both "get :: StateT s (State t) s" and "get :: StateT s (State t) t".
23:49:57 <joelteon> see: http://www.reddit.com/r/IAmA/comments/23v7f3/hi_im_blake_irving_i_am_the_ceo_of_godaddy_ask_me/
23:50:04 <kosmikus> enthropy: of course, if they're the same type, then the inner state is shadowed ...
23:50:21 <ReinH> "Shoot the elephant" was the new "jump the shark" for a while though. Good times.
23:50:57 <Maxdamantus> let t = MaybeS (BoolS, MaybeS BoolS) in (make t $ Just (True, Nothing), unmake t 8) .. (8,Just (True,Nothing))
23:51:05 * Maxdamantus wonders if anyone's used something like this for anything.
23:51:32 <enthropy> kosmikus: get `asTypeOf` (undefined :: State s s')  still figures out s ~ s'?
23:51:42 <Maxdamantus> Packing finite structures into integers as efficiently as possible.
23:52:03 <carter> Maxdamantus: by integers you mean bit vectors? yup,
23:52:11 <Maxdamantus> carter: no, integers.
23:52:16 <Maxdamantus> carter: it doesn't waste bits.
23:52:20 <carter> integers ARE bit vectors
23:52:35 <Maxdamantus> Oh, then yes.
23:52:37 <Axman6> no they're not
23:52:43 <Maxdamantus> but it doesn't organise them in terms of bits.
23:52:50 <Axman6> that's just one representation of integers MAN
23:53:05 <carter> Axman6: bijection and HOTT stuff say they're equal :)
23:53:13 <Maxdamantus> count (BoolS, MaybeS BoolS) == 7
23:53:14 <Axman6> ur equal
23:53:17 <Axman6> >_>
23:53:43 <Maxdamantus> which means there are 7 possible values for `(Bool, Maybe Bool)`, and every integer from 0 to 6 is meaningful.
23:54:43 <carter> Maxdamantus: have you seen succint data structures?
23:54:45 <Axman6> Maxdamantus: this seems relevant: https://skillsmatter.com/skillscasts/3932-a-haskell-lecture-with-leading-expert-andres-loh
23:54:51 <carter> kosmikus: neat
23:55:11 <Maxdamantus> carter: doesn't sound familiar.
23:55:21 <carter> @google succint data structures
23:55:22 <lambdabot> http://en.wikipedia.org/wiki/Succinct_data_structure
23:55:23 <lambdabot> Title: Succinct data structure - Wikipedia, the free encyclopedia
23:55:48 <kosmikus> enthropy: no
23:55:53 <enthropy> Maxdamantus: how are you counting? Maybe Bool has [Nothing, Just True, Just False] if you pretend undefined doesn't exist
23:56:37 <enthropy> Maxdamantus: so shouldn't you just have 6 values?
23:56:38 <Maxdamantus> er, I missed a Maybe.
23:56:42 <kosmikus> enthropy: but I'll have to think about this. perhaps this is still possible somehow ...
23:56:50 <Maxdamantus> was meant to be MaybeS (BoolS, MaybeS BoolS)
23:56:56 <Maxdamantus> and Maybe (Bool, Maybe Bool)
23:57:59 * hackagebot hpc-coveralls 0.5.0 - Coveralls.io support for Haskell.  http://hackage.haskell.org/package/hpc-coveralls-0.5.0 (killy971)
23:58:14 <enthropy> kosmikus: probably it's possible. http://hackage.haskell.org/package/HList-0.3.4.1/docs/src/Data-HList-TIP.html does something like that with the HOccurs instance
23:59:46 <enthropy> ie. get first makes a list of all things that have State in the monad stack, then does a hOccurs
