00:04:49 <jle`> ugh hlint
00:05:09 <jle`> suggesting me do (\x -> fromMaybe x f) as (`fromMaybe` f)
00:05:26 <jle`> come on
00:05:39 <jle`> and now syntastic won't be happy until i fix it
00:06:25 <sipa> fix it by changing it to...?
00:06:52 <jle`> i guess i'll just break it out as a named function
00:07:09 <supki> jle`: you can also use annotations to silence dumb suggestions
00:07:20 <jle`> yeah but i don't want to disable for the entire file :/
00:07:25 <jle`> i like the flip warnings sumetimes
00:07:28 <jle`> sometimes.
00:07:35 <supki> {-# ANN $function_name ... #-}
00:07:49 <jle`> i think flip fromMaybe f works but it's just as bad.
00:07:52 <jle`> readability wise
00:08:01 <jle`> supki: hm, what do i put for that then?
00:08:23 <supki> {-# ANN $function_name "HLint: ignore $suggestion_name #-}
00:08:29 <supki> {-# ANN $function_name "HLint: ignore $suggestion_name" #-}
00:08:51 <supki> If you've enabled -XOverloadedStrings that string literal will need a type annotation
00:09:02 <jle`> hm
00:09:04 <jle`> thanks
00:09:06 <sipa> interesting how shell/perl/php like notation is used for metavariables in haskell code :)
00:09:21 <sipa> (in this channel)
00:09:25 <jle`> looks like php got something right :)
00:09:32 <jle`> (that was a joke)
00:09:35 <jle`> (don't ban me)
00:41:33 <Fuuzetsu> jle`: what's wrong with (`fromMaybe` f)?
00:41:40 <Fuuzetsu> also you can put down an annotation to silence hlint
00:41:48 <jle`> Fuuzetsu: it doesn't feel very readable to me
00:42:02 <jle`> if i saw it in the wild it might take me a few seconds to figure out what was going on
00:42:12 <jle`> whereas if i saw (\x -> fromMaybe x f) i would see it instantly
00:42:52 <jle`> it's a bit of an unnecessary cognitive overhead
00:42:54 <jle`> imo
00:43:36 <jle`> maybe i just haven't seen it used enough...but i think part of it comes from the fact that f is a function and it throws off a bit of my intuition
00:43:38 <jle`> maybe i am being unfair!
00:43:48 <solidus-river> is there an easy extension to convert between string literals and CStrings automatically, or whats the best way to go from a stringLiteral to a CString
00:44:03 <solidus-river> i thought overloaded strings would be magical, but not so
00:45:48 <bergmark> anyone know what can cause "cabal: does not exist" when running `cabal update'?
00:48:12 <solidus-river> are you sudo-ing the command?
00:48:18 <solidus-river> if so does cabal exist for the sudo'd user?
00:53:16 <bergmark> solidus-river: i'm not
00:53:58 <solidus-river> bergmark: what os?
00:54:04 <solidus-river> or distro
00:54:17 <solidus-river> cabal is both a library and a binary
00:54:25 <solidus-river> some distros package them seperate, some together
00:54:28 <solidus-river> you could have one but not the other
00:54:34 <solidus-river> er, the binary but not the library
00:55:43 <bergmark> i'm trying a thing...
00:59:36 <bergmark> i had a 1.18 binary too, that one works, and a 1.20 binary my collague built also works for me
01:03:28 <lfairy> bergmark: what does cabal --version say?
01:03:29 <bergmark> figured it out: https://github.com/haskell/HTTP/issues/68
01:04:55 <bergmark> weirdness :-)
01:06:00 <slomo> is there a way to not let hlint choke on cpp macros like MIN_VERSION_base?
01:07:05 <bergmark> slomo: check --help, there are some CPP flags
01:07:49 <slomo> bergmark: thanks
01:22:27 <Hermit> hmm, someone around is fluent with template haskell ASTs? I'm trying to declare an instance of a class declared in a module A, then trying to use ConT A.Class, but it's throwing me a "not in scope data constructor `A.Class'. Where should I look at to fix this?
01:23:28 <Hermit> sorry if the question is not full of useful information, i'm quite lost with this TH thing to begin with
01:23:39 <enthropy> Hermit: ConT 'A.Class
01:23:54 <Hermit> ' in the AST?
01:24:05 * Hermit reluctantly tries
01:24:24 <enthropy> it's usually better to just write [| Foo.Bar |]
01:24:34 <enthropy> or rather, that's a shorter way to do it
01:25:14 <enthropy> oops, you're doing types, so [t| Foo.Bar |]
01:25:18 <Hermit> I know I should be messing with quasiquoting and splicing instead of die-hard AST, but I wanted to get a deep understanding of all this before going with syntax sugar
01:25:49 <enthropy> and ''A.Class will refer to the type
01:26:17 <enthropy> data Class = ClassCon -- ''Class refers to the first, 'ClassCon refers to the second one
01:28:19 <Hermit> I see
01:29:04 <Hermit> fixed that error, now some type-tetris to get the Type -> Name and I should have something working (hopefully)
01:29:35 <rudra101_> I need some help. I was solving the following challenge : https://www.hackerrank.com/challenges/eval-ex
01:29:53 <rudra101_> and I submitted this code: http://ideone.com/JH4dPW
01:30:28 <rudra101_> I am getting runtime error. Can someone explain me why ?
01:30:55 * Hermit would totally help but is too busy trying to get some TH hackery working
01:31:24 <Hermit> arg, wtf
01:31:26 * Hermit opens link
01:32:15 <rudra101_> Please anyone ?
01:32:23 <jle`> Hermit: i see you've stumbled into the productivity black hole that is #haskell ;)
01:32:25 <MP2E> rudra101_ : pow and fact are both building up a lot of thunks before 'crunching' the whole thing
01:32:33 <MP2E> i suspect it is the thunks causing the stack overflow
01:32:53 <rudra101_> Okay. Any suggestions to avoid that ?
01:33:08 <Hermit> jle`: I think I need some clarification there ;-)
01:33:34 <MP2E> rudra101_ : rewrite your functions to use right folds instead of a left fold, if you look at your function and compare it to foldl you will notice they are very similar
01:33:57 <MP2E> err wait
01:33:59 <MP2E> the opposite
01:34:05 <MP2E> yours is foldr, it needs to be foldl
01:34:06 <Hermit> jle`: you mean it as in "very productive language", or some other interpretation?
01:34:11 <MP2E> http://www.haskell.org/haskellwiki/Foldr_Foldl_Foldl%27
01:34:29 <jle`> Hermit: i am referring to the #haskell channel
01:34:39 <rudra101_> Thanks. I am trying to work it out.
01:34:41 <enthropy> Hermit: Type -> Name can't happen in general
01:34:48 <jle`> i open it up and suddenly 5 hours have passed
01:35:21 <Hermit> jle`: oh, yeah, I know what you mean, that's why usually stay away from it unless I'm really banging my head against the wall
01:35:50 <Hermit> enthropy: hmm
01:37:23 <Hermit> jle`: I always strieve to figure things out on my own so that I don't bother anyone with my shit, but sometimes time is short and my griefmeter goes off the scale...
01:38:42 <Hermit> and one thing that's really ticking me off is the lack of anonymous/structurally-typed records. This code I'm working with would be sooooo much nicer with that feature....
01:39:20 <lfairy> maximumBy (comparing outcomes)
01:39:25 <lfairy> wow, that read really well
01:40:00 <Hermit> indeed, it's one of those really inspired idioms...
01:45:54 <lfairy> Hermit: too bad maximumBy calls error on the empty list :(
01:46:23 <lfairy> silly partial functions
01:47:12 <Hermit> lfairy: well, the problem is: what would be the maximum of an empty list?
01:47:21 <lfairy> Nothing
01:47:31 <lfairy> So maximum should return Maybe
01:47:39 <Hermit> same as head
01:47:44 <Hermit> but y'know...
01:47:56 <Hermit> so, shield it
01:47:56 <lfairy> which is why head is silly IMO
01:48:25 <Hermit> yeah, but head is less cumbersome where you know the list can't be empty
01:50:12 <lfairy> I've never used head in a serious application though :\
01:50:23 <lfairy> NonEmpty from semigroups captures that invariant better
01:50:57 <lfairy> fromMaybe "description" is better from a debugging POV
01:52:38 <jle`> head makes sense in some situations
01:52:51 <jle`> the same situations where tail makes sense
01:53:10 <jle`> but definitely not for the majority of situations that people use it for
01:53:22 <jle`> i feel like it should be removed from Prelude
01:53:38 <jle`> (head and tail)
01:57:14 * Hermit would like many things removed from Prelude
02:20:48 <frerich> jle`: I think partial functions aren't all that terrible, especially when you produce the input value yourself. The RLE exaple 'map (head &&& length) . group . sort' comes to mind.
02:21:52 <Trollinator> :t (&&&)
02:21:53 <lambdabot> Arrow a => a b c -> a b c' -> a b (c, c')
02:22:05 <frerich> jle`: It would probably be awkward to juggle with Maybe here even though you know that you won't ever call 'head' on an empty list.
02:22:06 <jle`> frerich: this is one situation where i think head and tail fit, semantically
02:22:30 <Yuu_chan> frerich: great example! I've always write a lambda instead of &&&...
02:22:47 <Yuu_chan> *written
02:22:52 <frerich> jle`: I agree that 'head' and 'tail' are something like "code smells" though. If I see them, I usually squint and try to find some issue ;-)
02:22:52 <jle`> :t (&&&) `asAppliedTo` (undefined :: a -> b)
02:22:53 <lambdabot> (a -> b) -> (a -> c') -> a -> (b, c')
02:23:18 <jle`> frerich: i think my point is that the majority of use cases of head/tail by new people are for the wrong situations
02:23:24 <jle`> but they are very useful functions
02:23:26 <jle`> in the correct situations
02:23:27 <Yuu_chan> :t asAppliedTo
02:23:28 <lambdabot> (a -> b) -> a -> a -> b
02:23:28 <jle`> :)
02:23:45 <jle`> Yuu_chan: it's const, but with a specialized type signature
02:23:54 <bergmark> if you want head and tail you can use non empty lists from semigroups
02:24:29 <jle`> ^^ yeah, so that the compiler can actually be of assistance
02:24:43 <Yuu_chan> jle`: const applied only to functions?
02:24:45 <jle`> :t (>>=) `asAppliedTo` Nothing
02:24:45 <lambdabot> Maybe a -> (a -> Maybe b) -> Maybe b
02:25:07 <jle`> Yuu_chan: asAppliedTo :: (a -> b) -> a -> (a -> b); asAppliedTo = const
02:25:21 <jle`> Yuu_chan: const aplied to functions where the input is the same type as the second ignored argument
02:25:39 <Yuu_chan> jle`: oh, that. Thanks.
02:25:40 <Trollinator> what is that for? it's not even shorter to type
02:25:53 <jle`> Trollinator: it's for things like finding specialized types
02:25:59 <jle`> like the (>>=) example
02:26:04 <Yuu_chan> Trollinator: maybe to get rid of explicit type signatures
02:26:19 <jle`> :t (<*>) `asAppliedTo` []
02:26:20 <lambdabot> [a -> b] -> [a] -> [b]
02:26:51 <jle`> :t (|||) `asAppliedTo` (undefined :: (a -> b))
02:26:52 <lambdabot> (a -> b) -> (c -> b) -> Either a c -> b
02:26:58 <jle`> more like...if you don't know the entire type signature
02:27:04 <Trollinator> :t const (<*>) []
02:27:05 <lambdabot> Applicative f => f (a -> b) -> f a -> f b
02:27:21 <jle`> Trollinator: the type signature of const by default is too general
02:27:44 <jle`> :t (const :: (a -> b) -> a -> (a -> b)) (<*>) []
02:27:44 <lambdabot> [a -> b] -> [a] -> [b]
02:27:47 <Trollinator> too general for what?
02:27:59 <jle`> to have the "asAppliedTo" usefulness
02:28:13 <Yuu_chan> :t asTypeOf
02:28:14 <lambdabot> a -> a -> a
02:28:28 <Trollinator> I don't get it. What do you mean by “finding specialized types“?
02:29:10 <Yuu_chan> > read `asAppliedTo` "" $ "\"test\""
02:29:11 <lambdabot>  Precedence parsing error
02:29:11 <lambdabot>      cannot mix ‘L.asAppliedTo’ [infixl 0] and ‘GHC.Base.$’ [infixr 0] in the...
02:29:37 <Yuu_chan> > (read `asAppliedTo` "") "\"test\""
02:29:39 <lambdabot>  *Exception: Prelude.read: no parse
02:30:08 <Yuu_chan> Okay...
02:30:33 <jle`> Trollinator: say i want to find out what the type of (<*>) is, for the Maybe instance of Applicative
02:30:44 <jle`> I can just do
02:30:51 <jle`> :t (<*>) `asAppliedTo` Nothing
02:30:52 <lambdabot> Maybe (a -> b) -> Maybe a -> Maybe b
02:30:52 * hackagebot packdeps 0.4.0.3 - Check your cabal packages for lagging dependencies.  http://hackage.haskell.org/package/packdeps-0.4.0.3 (MichaelSnoyman)
02:31:55 <jle`> it's less often use for "finding out" and more often used for demonstration
02:33:23 <k00mi> Yuu_chan: read always takes a String, you can't specify the return type with asAppliedTo
02:34:24 <Yuu_chan> k00mi: I see :)
02:34:56 <Yuu_chan> > read "\"test\"" `asTypeOf` ""
02:34:57 <lambdabot>  "test"
02:38:30 <jle`> > show `asAppliedTo` True
02:38:31 <lambdabot>  <Bool -> [Char]>
02:38:37 <jle`> :t show `asAppliedTo` True
02:38:38 <lambdabot> Bool -> String
02:40:42 <Black-Heaven> Hi all
02:46:00 <Black-Heaven> I'm trying to process (load, apply an XPath and generate a String) XML with HXT, I have a complete HTML file and, when I try to load it with parseHtmlContent, I have this error: "ERROR (1): "string" (line 2, column 1) markup char '<' not allowed in this context". is there a more suited function to load a complete HTML file? Thanks in advance for your help.
02:53:11 <Qfwfq> @src asAppliedTo
02:53:11 <lambdabot> Source not found. Maybe if you used more than just two fingers...
02:54:31 <k00mi> Qfwfq: it's just const with a more specialized type
02:56:58 <Qfwfq> @type asAppliedTo
02:56:59 <lambdabot> (a -> b) -> a -> a -> b
02:57:38 <Qfwfq> @type (const :: (a -> b) -> a -> a -> b) ap Nothing
02:57:39 <lambdabot> Maybe (a -> b) -> Maybe a -> Maybe b
02:58:15 <Qfwfq> Oh, neat.
03:01:21 <sshine> is the vault package comparable to AcidStore? has anyone here used these?
03:11:47 <k00mi> vault doesn't store data on disk as far as I can tell
03:20:56 * hackagebot eros 0.4.0.0 - A text censorship library.  http://hackage.haskell.org/package/eros-0.4.0.0 (pharpend)
03:25:39 * hackagebot HTF 0.11.4.0 - The Haskell Test Framework  http://hackage.haskell.org/package/HTF-0.11.4.0 (StefanWehr)
03:25:39 * hackagebot eros-client 0.4.0.0 - A command-line interface to the eros library.  http://hackage.haskell.org/package/eros-client-0.4.0.0 (pharpend)
03:28:32 <Javran> @pl \(a:b:_) -> (a,b)
03:28:32 <lambdabot> ap ((`ap` tail) . (. head) . (const .) . (,) . head) tail
03:28:55 <jle`> haha
03:30:34 * hackagebot eros 0.4.0.1 - A text censorship library.  http://hackage.haskell.org/package/eros-0.4.0.1 (pharpend)
03:34:03 <supki> :t flip (set (partsOf each)) (undefined, undefined)
03:34:04 <lambdabot> [b'] -> (b', b')
03:35:28 <Javran> :t partsOf
03:35:29 <lambdabot> Functor f => Traversing (->) f s t a a -> LensLike f s t [a] [a]
03:35:46 <Javran> :t each
03:35:47 <lambdabot> (Each s t a b, Applicative f) => (a -> f b) -> s -> f t
03:37:50 <Yuu_chan> :t set
03:37:51 <lambdabot> ASetter s t a b -> b -> s -> t
03:47:52 <ph88_> hey i made this program http://pastebin.com/PxjgzRzP from http://learnyouahaskell.com/starting-out at http://codeworld.info but i get  Line 3, Column 1:     Parse error: naked expression at top level
03:47:56 <ph88_> what's that about ?
03:48:13 <tdammers> ph88_: it means you have an expression at the top level
03:48:22 <tdammers> outside of any functions, that is
03:48:24 <ph88_> what to do about it ?
03:48:41 <tdammers> paste some code, maybe?
03:48:44 <tdammers> @where lpaste
03:48:44 <lambdabot> http://lpaste.net/new/haskell
03:48:53 <ph88_> my paste is here http://pastebin.com/PxjgzRzP
03:49:19 <Yuu_chan> ph88_: the second line is typed into an interactive interpreter named ghci
03:49:44 <ph88_> how can i get it to work on codeworld ?
03:50:06 <Yuu_chan> ph88_: which result do you want to get?
03:50:18 <tdammers> ghci performs a bunch of magic that puts you into some sort of implicit IO context
03:50:19 <ph88_> 18
03:50:34 <tdammers> normally, you want your main code inside a function called `main`, of type IO ()
03:50:54 <ph88_> o_O
03:50:59 <tdammers> and if you want to output anything, you have to do it explicitly
03:51:07 <tdammers> i.e.:
03:51:16 <tdammers> main = print (doubleMe 9)
03:51:24 <tdammers> instead of just
03:51:26 <tdammers> doubleMe 9
03:51:45 <tdammers> main = print $ doubleMe 9 -- is more idiomatic btw
03:51:56 <ph88_> Line 3, Column 8: Not in scope: print
03:52:23 <ph88_> for the second suggestion the same error + Line 3, Column 14: Not in scope: $
03:52:29 <tdammers> hmm
03:52:37 <tdammers> those should be in scope by default
03:52:45 <tdammers> try importing Prelude explictly?
03:53:05 <ph88_> hey man, i never wrote a line of haskell before
03:53:07 <tdammers> not really sure what codeworld does, never used it
03:53:11 <ph88_> i just like to get hello world in codeworld
03:53:28 <tdammers> idk, I use ghc directly myself
03:53:54 <ph88_> http://cdsmith.wordpress.com/2014/06/03/codeworld-rises-again/
03:54:04 <ph88_> i wanted to use this as haskell practise environment
03:54:12 <ph88_> can you see this?  http://codeworld.info/#PlT0BxQzi_qu4mohCZ2pj-w==
03:54:44 <ph88_> this blog suggest that even kids can use it http://twdkz.wordpress.com/2014/06/26/teenage-haskell/
03:56:48 <tdammers> looks like codeworld gives you different packages than what you'd get in vanilla ghc
03:57:00 <jle`> how interesting!
03:57:05 <jle`> if you want to try out things you would type into ghci
03:57:14 <jle`> you might want to look at tryhaskell.com
03:57:15 <ph88_> so i can't put text and numbers? only images ?
03:57:45 <jle`> oh it's tryhaskell.org
03:57:56 <tdammers> I don't know. It seems that it gives you a predefined set of imports, and that's what you get.
03:58:02 <tdammers> I can't see a way to specify other packages.
03:58:13 <jle`> i think codeworld might have its own "tutorial course"?
03:58:18 <jle`> that leverages its special imports?
03:58:41 <ph88_> Do you want to know about everything you can use to build your CodeWorld project? The collection of all variables and types you can use in CodeWorld is called the prelude, and you can look through the whole thing!
03:58:52 <ph88_> that's on the bottom of help
03:58:57 <jle`> hmm
03:59:15 <r444> ph88_: you can use http://tryhaskell.org/
04:00:09 <jle`> yes it does look like on codeworld you can only draw graphics...i tseems...
04:00:13 <ph88_> r444: that doesn't work for this first line here http://pastebin.com/PxjgzRzP  <hint>:1:12: parse error on input `='
04:00:22 <jle`> ph88_: let doubleMe x = x + x
04:00:29 <ph88_> what's let ?
04:00:45 <jle`> you can think of it as "interactive mode" syntax
04:00:49 <ph88_> ok
04:01:07 <jle`> it binds the name doubleMe to the function that takes x and returns x + x
04:01:09 <jle`> for the rest of the session
04:01:13 <ph88_> not an expression: `let doubleMe x = x + x'
04:01:16 <vanila> jle`, I think it's 'do' syntax
04:01:26 <jle`> vanila: yeah but this is literally day 0 for ph88_  :|
04:01:55 <jle`> hm i guess tryhaskell doesn't support ghci-like do block stuff
04:01:57 <vanila> that's why I think you should use correct terminology...
04:02:09 <jle`> ah, okay.  i'll concede
04:02:57 <jle`> i guess you can't define stuff in tryhaskell?
04:03:05 <tdammers> ph88_: that "prelude" is kind of not the standard prelude
04:03:14 <ph88_> maybe this one will be better https://www.fpcomplete.com/page/project-build ??
04:03:14 <jle`> try: let doubleMe x = x + x in doubleMe 6
04:03:22 <tdammers> ph88_: you may notice that it says "codeworld-base-0.1.0.0" in the top-left corner
04:03:24 <jle`> ph88_: fpcomplete has full prelude, yes, so that's nice
04:03:42 <jle`> that will def work for you if you do doubleMe x = x + x on one line, and main = print (doubleMe 5) on another
04:04:07 <ph88_> yes works thx jle`
04:04:20 <peterpan22> this is just amazing!!!!!!! http://basicandsense.blogspot.com best haskell blog ever!!!!
04:05:47 <ph88_> jle`: works perfect on fpcomplete :) :)
04:06:01 <jle`> yay :)
04:07:59 <jle`> ph88_: happy haskelling :)
04:09:53 <ph88_> thx
04:10:20 <ysf> I'm looking for a haskell book. Currently I'm reading the learnyouahaskell pdf and would like a book showing an programmer functional thinking and design using haskell. The Haskell-Wiki has some books but presents them in a value-free way, any (biased) pointers here what could be good for me?
04:11:57 <ienh> does anyone have experience using HXT for (moderately) large documents? I'm trying to process a 44MB XML file and memory usage is hitting a couple gigs
04:12:02 <tdammers> ysf: if you already have a background in programming, Real World Haskell could work
04:12:05 <tdammers> @where rwh
04:12:05 <lambdabot> http://www.realworldhaskell.org/blog/ http://book.realworldhaskell.org/read/
04:12:21 <tdammers> it's somewhat dated on a few aspects, but it does give a good primer on hands-on FP
04:12:46 <tdammers> ysf: Write Yourself A Scheme is also pretty interesting
04:12:50 <tdammers> @where scheme
04:12:50 <lambdabot> https://en.wikibooks.org/wiki/Write_Yourself_a_Scheme_in_48_Hours
04:12:51 <peterpan22> http://basicandsense.blogspot.com
04:13:05 <ysf> I think I skipped it because I thought it'll be dated, glad to hear it'll be a nice read either way
04:13:36 <vanila> @ops
04:13:36 <lambdabot> Maybe you meant: pl oeis docs
04:14:01 <tdammers> as long as you keep in mind that there are better/newer alternatives for the libraries it introduces, you should be fine
04:14:18 <ysf> Ok, Thanks you then tdammers :)
04:15:22 <jle`> ysf: i like Parallel & Concurrent Haskell by Simon Marlow, somewhere after LYAH
04:15:57 <jle`> even if you aren't interested in parallel and concurrent haskell, the book really takes you into the mind of one of the top haskell programmers in the world, and how to approach practical problems in haskell and the mindset of it all
04:16:36 <ysf> Great! Just found that it is available online as well: http://chimera.labs.oreilly.com/books/1230000000929/index.html
04:16:51 <jle`> yup :)
04:18:17 <peterpan22> http://basicandsense.blogspot.de amazing
04:18:56 <jle`> @where ops
04:18:57 <lambdabot> arjanb bos byorgey Cale conal copumpkin dcoutts dibblego dmhouse dolio dons edwardk elliott geekosaur glguy Heffalump Igloo jmcarthur johnw kosmikus Lemmih monochrom nyc Philippa Pseudonym quicksilver roconnor Saizan shachaf shapr sjanssen ski sorear SyntaxPolice xerox
04:21:05 <vanila> thanks jle`
04:21:13 <vanila> it didnt work for me
04:23:04 <jle`> they're all sleeping i guess
04:24:04 <peterpan22> http://basicandsense.blogspot.com amazing!
04:34:31 <bjobjo> Hello all, is there any good (up to date) guides for the supporting infrastructure typically used in haskell projects? I'm thinking of things like cabal, test frameworks, benchmarks, etc.
04:35:10 <bjobjo> I've read LYAH, and I'm working my way through real world haskell (though I am finding it a bit out of date in places), and mess around a bit with different projects from hackage
04:35:40 <bjobjo> just 15 minutes ago I found myself wishing I'd have known about cabal install --only-dependencies earlier :)
04:38:34 <popx_> bjobjo: good stuff for a beginner haskeller> http://dev.stephendiehl.com/hask/
04:38:44 <ienh> bjobjo: I've found http://www.haskell.org/haskellwiki/How_to_write_a_Haskell_program helpful
04:39:13 <bjobjo> thank you popx_ and ienh, both of those look helpful
04:43:13 <CaveJohnson> Hello, I'm currently wondering why https://gist.github.com/zackp30/b611c8f93a1f3ff27489 returns the error in that attached gist, it seems to expect [FilePath] when I specified IO FilePath, currently _very_ new to Haskell, any help would be appreciated.
04:44:38 <alpy> hey, i am having problems with cabal, is this the place i should ask help for ?
04:45:04 <popx_> alpy: perhaps ask here?
04:46:11 <jkarni> CaveJohnson: what exactly are you trying to do? Get rid of the "IO"?
04:47:05 <bjobjo> is it common for projects to assume that you have the haskell platform installed? I've bumped into at least one project (whose name escapes me at the moment) where the cabal file did not list happy or alex.
04:47:06 <CaveJohnson> jkarni: from the amount of SO answers I've been on, I've gathered that that's not meant to happen in Haskell. I'm trying to use `++' on a FilePath, and a String.
04:47:24 <alpy> so i have this project that uses several modules that are on their own files , then i use cabal init, i answer the questions but in the end it tells me it cannot find the modules that i made
04:47:40 <Yuu_chan> CaveJohnson: which "str" do you need to get from "dir"?
04:49:15 <jkarni> CaveJohnson: FilePath is a type synonym for String, so you can use ++ to combine it with a string without any further processing
04:49:16 <popx_> alpy: how are the files structured?
04:49:35 <CaveJohnson> Yuu_chan: basically I'm trying to get the current directory, and put another string on it
04:49:37 <CaveJohnson> jkarni: oh
04:49:39 <CaveJohnson> ok
04:49:41 <CaveJohnson> one sec
04:50:15 <jkarni> CaveJohnson: but the signature of your function is definitely wrong
04:50:28 <CaveJohnson> jkarni: yeah, sorry, still very new :(
04:50:32 <frerich> CaveJohnson: I commented on that 'gist' -- maybe that's what you meant to do?
04:50:34 <alpy> http://lpaste.net/106575
04:50:52 <alpy> popx_: http://lpaste.net/106575n here is an exemple
04:52:02 <Yuu_chan> CaveJohnson: could you put the full code snippet?
04:52:17 <CaveJohnson> that is all of it
04:52:23 <CaveJohnson> well uh
04:52:26 <CaveJohnson> sec
04:53:09 <Yuu_chan> CaveJohnson: from what I can see, this function is unnecessary
04:54:12 <Yuu_chan> CaveJohnson: you can for example do (dir ++ "/someSubdir") right after you get that: dir <- getCurrentDirectory
04:54:39 <frerich> CaveJohnson, Yuu_chan: In case you want to construct a path, I recommend not to use ++ but rather </>
04:55:19 <phi__> alpy this should be in the folder from which you call cabal init or in a folder named src inside it
04:55:25 <Yuu_chan> phi__: good point
04:55:44 <Yuu_chan> Er, I mean frerich:
05:00:12 <jpf> if one compiles the same file against ghc with a minor change (such as to a comment), will it take less time to compile (it seems like it does) the next time?, what I'm trying to ask is if GHC, well, specifically, the GHC-api (i know those are two different things) caches results
05:00:44 * hackagebot TrendGraph 0.1.0.0 - A simple trend Graph script  http://hackage.haskell.org/package/TrendGraph-0.1.0.0 (AlperAYDIN)
05:03:29 <alpy> Somehow it works now.
05:32:06 <fdsfsdf> can haskell-mode or ghc-mode show the callers of a function?
05:36:52 <Black-Heaven> I'm trying to process (load, apply an XPath and generate a String) XML with HXT, I have a complete HTML file and, when I try to load it with parseHtmlContent, I have this error: "ERROR (1): "string" (line 2, column 1) markup char '<' not allowed in this context". is there a more suited function to load a complete HTML file? Thanks in advance for your help.
05:53:58 <dabd> in brent yorgey's course he discourages using partial functions like head, (!!) etc.  How can I write this https://gist.github.com/dabd/c59477e4dfb3e0193305#file-gistfile1-hs without using head?
05:57:12 <vanila> dabd, There's no good reason not to use partial functions, in fact it's just a hassle to find hacks and work-around to avoid them
05:57:39 <vanila> There is a post-condition on the output of the group function that makes calling "head" on its elements will always work correctly
05:58:29 <ique> well if you don’t know that what you’re calling head on always has something in it, like in this case, there’s no good reason.. but if you don’t know then there’s plenty of reason not to use it
05:58:46 <ique> uh.. beginning of that sentence got a bit mangled :P
05:59:02 <ique> but you get my point, sometimes avoid it and somtimes not ^^
05:59:15 <dabd> vanila: what post-condition?
05:59:40 <vanila> the output of group will be a list of non-empty lists
06:01:04 <dabd> ok, how would you rewrite my function without using head?
06:01:51 <vanila> :t group
06:01:52 <lambdabot> Eq a => [a] -> [[a]]
06:02:14 <vanila> the type here [[a]] doesn't include the post-condition that using map head requires
06:02:31 <vanila> so you would want to create a function  group' :: Eq a => [a] -> [(a,[a])]
06:02:59 <vanila> now that the type enforces the fact that the "list" (represented by (a,[a])) is nonempty you can use fst instead of head
06:03:33 <dabd> if I try to use case and pattern matching case x of (y:hs) -> (y, length ys + 1) []-> ?  what doI return in the case of an empty list?
06:04:09 <rwbarton> and, now you can't get the length of the groups as easily
06:04:11 <vanila> you don't need to handle the empty list case because it cannot happen
06:04:43 <vanila> rwbarton, yeah as I said byorgey philosophy is too idealist that it's awkward and makes things unreadable in practice
06:05:21 <rwbarton> ah, yes
06:05:27 <frerich> dabd: For what it's worth, your lambda function can be shortened to 'head &&& length'
06:05:28 <vanila> you will always have conditions about data in your programs that cannot be expressed in the types
06:05:30 * frerich has a deja vu
06:07:46 <rwbarton> this is the kind of example that has me excited about LiquidHaskell (and not excited about dependent types)
06:10:01 <mgsloan> Any hsenv / cabal experts familiar with reasons I'd get "/usr/bin/ld.gold: error: cannot find -l..." errors, that others can't reproduce?  More details here: https://github.com/csabahruska/lc-dsl/issues/8
06:10:38 <Black-Heaven> Let me put it in another way: I have a blog post (a pure String) in HTML, I want to extract the introduction (all p tagged nodes between the first h5 and the first h3), what's the easiest way to do it? I though to do it with HXT, but it puts me in trouble. Thanks in advance for your help.
06:12:21 <jpf> Black-Heaven: easy != HTX, unless you're a CT theorist or seasoned haskeller
06:12:35 <jpf> Black-Heaven: *HXT
06:15:11 <Black-Heaven> jpf: I just learned that
06:15:33 <hexagoxel> i would like to understand how arrow-notation is translated. but i find that a) the Paterson paper does not cover let-statements inside the do-block b) ghc documentation does not cover the translation of rec (ArrowLoop) c) the arrowp executable does not compile on a clean ghc 7.8.2 setup. Is there some better documentation around somewhere?
06:17:54 <hexagoxel> my current approach would be to translate the "let x = y" to "x <- returnA -< y". is that semantically equivalent?
06:18:39 <rwbarton> hexagoxel: is http://www.haskell.org/ghc/docs/papers/arrow-rules.pdf helpful?
06:25:09 <hexagoxel> rwbarton: it covers let, but not rec :/
06:34:00 <Black-Heaven> so, there is no easy ways to do xpath in Haskell, right?
06:42:00 <bergmark> Black-Heaven: there's hxt-xpath
06:42:15 <bergmark> Black-Heaven: and https://github.com/silkapp/xmlhtml-xpath
06:45:53 * hackagebot MusicBrainz 0.2.2 - interface to MusicBrainz XML2 web service  http://hackage.haskell.org/package/MusicBrainz-0.2.2 (ClintAdams)
06:47:36 <ienh_> does anyone have experience parsing (moderately) large XML files? I've got a 44MB file I've tried processing with HXT, hexpat and tagsoup and all of them end up using multiple gigs of memory
06:49:15 <Black-Heaven> bergmark: Thanks, I'll have a look
06:49:52 <tdammers> ienh_: not in haskell, really, but generally speaking, you want to use a SAX-style (node visitor) parser rather than a DOM processor
06:50:08 <tdammers> I'm not sure which of the Haskell libraries implements that approach though
06:50:17 <tdammers> tagsoup doesn't, but HXT might
06:54:12 <Yuu_chan> ienh_: a friend of mine unsuccessfully tried to parse 10 GB XML
06:54:56 <bergmark> we are using fast-tagsoup for sax style parsing
06:56:47 <ienh_> yeah, I've tried fast-tagsoup and Text.XML.Expat.SAX
06:57:37 <ij> Is there div(ision) function that returns Num a => Maybe a?
06:58:55 <tdammers> ienh_: then maybe force evaluation in a few strategic spots?
06:59:13 <tdammers> ienh_: you may have laziness lurking around where you don't want it
06:59:53 <dabd> would appreciate some criticism of my attempt to solve homework 3 of brent yorgey's course: https://gist.github.com/dabd/87e462ef6057cb5019cf#file-cis194-hw3 thanks
07:00:55 * hackagebot nc-indicators 0.2 - CPU load and memory usage indicators for i3bar  http://hackage.haskell.org/package/nc-indicators-0.2 (MihalyBarasz)
07:01:38 <ienh_> tdammers: new to haskell, how exactly do I force evaluation in spots?
07:06:56 <tdammers> ienh_: seq
07:07:27 <ienh_> dabd: here are my solutions if you want to see how someone else approached it https://gist.github.com/anonymous/f0b5ec9cb2a033e8bd4c
07:07:38 <ienh_> I'm pretty happy with my histogram function
07:09:14 <ienh_> tdammers: thanks, I'll look into that
07:12:00 <ienh_> dabd: (minus your skip function that I pasted in and forgot to remove)
07:12:35 <ij> How could I print Maybe String without maybe?
07:13:03 <dabd> ienh_ thanks
07:19:58 <Yuu_chan> ij: what to print if it is Nothing?
07:20:09 <ij> Then do nothing at all.
07:20:28 <ij> :: Show a -> Maybe a -> IO ()
07:20:58 <Yuu_chan> case var of Just str -> putStrLn str
07:21:03 <ij> =>*
07:21:32 <Yuu_chan> Nothing -> return ()
07:21:49 <ij> Pattern matching seems like writing code, can't I do without it?
07:22:02 <ij> Can't I compose the same thing of something else?
07:22:39 <Yuu_chan> ij: er... change the behavior without writing code? How?
07:25:25 <ij> With just composing new code.
07:25:49 <ij> Yeah, well I'll probably do what you suggested.
07:26:03 <lyxia> @ty maybe
07:26:04 <lambdabot> b -> (a -> b) -> Maybe a -> b
07:26:19 <Yuu_chan> :t when
07:26:20 <lambdabot> Monad m => Bool -> m () -> m ()
07:26:24 <Yuu_chan> :t whenM
07:26:25 <lambdabot>     Not in scope: ‘whenM’
07:26:25 <lambdabot>     Perhaps you meant ‘when’ (imported from Control.Monad.Writer)
07:26:40 <cwraith> :t maybe (return ()) print
07:26:41 <lambdabot> Show a => Maybe a -> IO ()
07:26:43 <Yuu_chan> @src MonadPlus
07:26:44 <lambdabot> Source not found. The more you drive -- the dumber you get.
07:27:25 <Yuu_chan> maybe (return ()) print $ Just 42
07:27:36 <Yuu_chan> Oops, forgot about <IO>
07:29:01 <ij> @pl f n = z <$> y =<< x n
07:29:01 <lambdabot> f = (z <$> y =<<) . x
07:40:59 * hackagebot hs-carbon 0.1.0.0 - A Haskell framework for parallel monte carlo simulations  http://hackage.haskell.org/package/hs-carbon-0.1.0.0 (cholmgreen)
07:54:41 <bollu> if I have an IO bool, I have to ue bind or something to use an if condition over the IO bool right? I can't use an if condition on the IO bool directly?
07:55:05 <Tjr> :i when
07:55:08 <Tjr> :t when
07:55:09 <lambdabot> Monad m => Bool -> m () -> m ()
07:55:23 <Tjr> bollu: you could use "when2
07:55:26 <Tjr> s/2/"/
07:55:28 <augur> when is like if in imperative languages
07:55:37 <zwer> without an else
07:55:51 <bollu> zwer: and if I want to handle the else branch?
07:55:51 <augur> right. if (test) { consequence }
07:56:08 <augur> @hoogle Monad m => Bool -> m () -> m () -> m ()
07:56:10 <lambdabot> Control.Monad liftM3 :: Monad m => (a1 -> a2 -> a3 -> r) -> m a1 -> m a2 -> m a3 -> m r
07:56:10 <lambdabot> Text.ParserCombinators.ReadP between :: ReadP open -> ReadP close -> ReadP a -> ReadP a
07:56:10 <lambdabot> Control.Exception.Base bracket_ :: IO a -> IO b -> IO c -> IO c
07:56:21 <augur> guess not!
07:56:25 <bollu> augur: :)
07:56:27 <zwer> bollu I am not familiar with any function that handles that. you could write it yourself, though
07:56:36 <augur> bollu: at any rate, binding out is easy
07:56:40 <Cale> bollu: You could write your own thing, but it's more common just to write a do-block
07:56:53 <bollu> Cale: I'm getting swaped in do blocks :(
07:56:58 <augur> bollu: do { cond <- theThing ; if cond then consequence else alternative }
07:57:29 <bollu> augur: first time I'm doing something non-trivial in haskell, and I find myself doing lots of I/O which leads to lots of do blocks
07:57:35 <augur> yes
07:57:50 <bollu> augur: yes = deal with it?
07:57:59 <augur> bollu: not much else you can do!
07:58:01 <augur> haskell lacks syntax sugar for "automatically" lifting things to the level of binds
07:58:08 <augur> idris has some nice support for this actually
07:58:15 <augur> in idris, that do block above would just be
07:58:15 <bollu> augur: hm, fair enough
07:58:20 <augur> if !cond then consequence else alternative
07:58:27 <bollu> augur: oh that's sweet
07:58:46 <augur> the ! flags a term as "please lift into a do block"
07:59:05 <augur> actually it'd be !theThing not !cond, but you get the point
07:59:11 <bollu> augur: hm, that looks handy
07:59:14 <Cale> cond >>= \case True -> consequence; False -> alternative
07:59:19 <augur> effects are in-order
07:59:30 <bollu> Cale: which is what a do block does? :)
07:59:44 <augur> bollu: the lambda case is important tho
07:59:50 <Cale> bollu: Yeah, but the lambdacase makes it so you don't have to name the Bool
07:59:59 <bollu> Cale: ah, good point
08:00:04 <bollu> Cale: thanks for that insight
08:00:05 <augur> you could actually concretize that pattern
08:00:36 <bollu> augur: having used C/C++ for so long, I don't reach for lambdas to solve a problem. Will have to break that habi
08:00:38 <bollu> habit*
08:01:13 <augur> ifIO = (>>=) :: IO Bool -> (Bool -> IO () -> IO () -> IO ()) -> IO ()
08:01:31 <augur> then you can write   ifIO $ \case { True -> cons ; False -> alt }
08:02:27 <augur> still, i feel like this is just making up for a lack of support for compositional programs
08:02:31 <bollu> augur: hm, you just parametrized bind for IO bool right?
08:02:45 <augur> ! is a nice tool for making non-monadic things compose with monadic things nicely
08:03:25 <augur> bollu: basically, yeah. and ()
08:03:28 <bollu> augur: isn't case a keyword?
08:03:31 <augur> oh the type of that f is absolutely wrong
08:03:33 <augur> haha sorry :)
08:03:38 <augur> should be Bool -> IO ()
08:03:39 <augur> d'oh
08:03:45 <Tjr> Did ! get added after LYAH was written?
08:03:47 <bollu> augur: yeah, realized :)
08:03:52 <bollu> Tjr: LYAH?
08:03:55 <augur> Tjr: not to haskell! to idris
08:04:00 <augur> @where lyah
08:04:00 <lambdabot> http://www.learnyouahaskell.com/
08:04:03 <Tjr> oh :-(
08:04:08 <augur> Tjr: i know
08:04:14 <augur> its v. sad
08:04:15 <bollu> lambdabot: oh, I didn't know that tutorial was *that* popular
08:04:19 <augur> i rather love !
08:04:37 <negatratoron> :t (!)
08:04:38 <lambdabot> Ix i => Array i e -> i -> e
08:04:45 <augur> it has clear, obvious semantics and supports great compositionality
08:04:54 <augur> we'd have to have some other notation in haskell tho
08:04:56 <augur> dunno what
08:05:14 <augur> it should be simple to provide as a preprocessor
08:06:20 <simcity2000> are there any new/interesting commercial things going on with haskell lately?
08:06:22 <augur> like, its REALLY simple to implement as a tree traversal
08:07:04 <simcity2000> I saw facebook just put out Haxl, but I'm doing some poking around for what's what in functional programming and it got me curious
08:07:52 <bergmark> we just announced rest: http://engineering.silk.co/post/90354057868/announcing-rest-a-haskell-rest-framework
08:08:09 <matheus23> Okay. I have a problem with the Cairo lib... According to this (http://cairographics.org/matrix_transform/), Cairo can work/works 3x3 matrices, but in the Haskell Cairo Docs I can only find this: http://hackage.haskell.org/package/cairo-0.12.0/docs/Graphics-Rendering-Cairo.html#t:Matrix
08:08:24 <matheus23> Is there a way to set Cairos 3x3 CTM?
08:09:30 <matheus23> (in other words, in the haskell port of cairo, the API only allows for setting the CTM as a 3x2 matrix, but in the native cairo lib the CTM is a 3x3 matrix...)
08:10:07 <Tjr> bergmark: how can you tell from their jobs section (https://jobs.silk.co/) that they do haskell?
08:10:34 <matheus23> nvm, I saw the following sentence on the first link I posted: "In a cairo.matrix(1,2,3,4,5,6), 1 is a11, 2 is a21, 3 is a12, 4 is a22, 5 is a13 and 6 is a23. a31 and a32 are 0, a33 is 1."
08:10:54 <bergmark> Tjr: see the haskell logo in the image? :-)
08:11:19 <Tjr> bergmark: the red tulip with uneven leaves?
08:11:40 <rwbarton> I guess they must use Macintosh Plus computers also :)
08:11:50 <bergmark> wrong image :-(
08:11:51 <t7> i never really got that silk product
08:11:56 <t7> its like a wiki?
08:12:02 <hiptobecubic> yeah I don't know
08:12:50 <bergmark> t7: kind of, but it does semantic analysis of the contents too, to allow exploring data sets
08:13:18 <t7> bergmark: of everyones data?
08:13:26 <hiptobecubic> oh wow, spuistraat
08:13:40 <hiptobecubic> I wish I worked there :/  downtown ams is beautiful
08:13:45 <Tjr> bergmark: now i see it. in the japanese flag.
08:14:29 <t7> Tjr: theres a lambda in the leaves
08:14:47 <Tjr> bergmark: more to the point, using silk.co as an example, how would I go about finding haskell-ish jobs?
08:15:03 <Tjr> Because the key word "haskell" doesn't really bring up a lot ...
08:15:46 <bergmark> Tjr: we don't gather all of the data ourselves, users create sites with their own content
08:16:37 <bergmark> so you explore data on a site basis
08:17:30 <simcity2000> bergmark: missed this, but it's interesting!
08:18:09 <Tjr> bergmark: sorry, I don't get what you're saying. But I did find "software engineer, haskell" in the filled jobs section.
08:19:36 <bergmark> Tjr: yeah we don't have an announced position for haskell at the moment, but i'm sure we'd consider hiring a good haskell programmer anyway
08:20:00 <eikke__> bergmark: where?
08:20:31 <bergmark> at Silk in Amsterdam
08:20:49 <Tjr> bergmark: so you're saying "try your luck and apply at haskell-ish compaines anyway"? (I can't really leave the German-speakng world.)
08:21:02 <creichert> was just reading about rest
08:21:07 <eikke__> bergmark: misschien interessant ;-)
08:22:11 <bergmark> Tjr: doesn't hurt :-) though we don't do telecommuting
08:22:38 <Tjr> I mean, I can't relocate to Amsterdam, for family reasons
08:22:57 <eikke__> isn't amsterdam fairly expensive for living/rent?
08:23:35 <bergmark> Tjr: yeah, that's understandable
08:24:04 <bergmark> eikke__: cheapear than london and stockholm, that's all the data i have on bigger cities :-o
08:24:24 <bollu> Cale: I'm not able to compile the the \case True -> ...; False -> ...
08:24:52 <bergmark> but you can also live halfway across the country and still have less than an hour to commute
08:24:55 <albeit> With lens, if I have a Map a (Set b), how can I modify the map (and set) by inserting a new element into a set at a specific key?
08:25:11 <bollu> Cale: what am I doing wrong, any idea?
08:26:02 * hackagebot open-union 0.1.0 - Extensible, type-safe unions.  http://hackage.haskell.org/package/open-union-0.1.0 (BenFoppa)
08:26:26 <bollu> can someone explain to me how to use \case? >_<
08:27:37 <bollu> oh, I need to enable it?
08:29:16 <c_wraith> bollu: yes.  It's an extension that requires being manually enabled, either by compiler flag or pragmas in the file
08:29:37 <bollu> c_wraith: what's the pragma associated with it?
08:30:12 <c_wraith> {-# LANGUAGE LambdaCase #-}
08:30:16 <c_wraith> at the top of the file
08:30:36 <sveit> is there a way to pattern match (or do something similar) on the return type of a function? the application is that I want to write a specialized instance if fmap for functions that return certain values
08:30:48 <bollu> c_wraith: thank you!
08:30:50 <simon___> whats up with the Haskell platform, has it stopped dev last year?
08:31:07 <c_wraith> simon__: there's a new version due...  very soon.  I think it's waiting on a GHC 7.8.3 release
08:31:37 <simon___> c_wraith - thanks, be good if the docs said that :-)
08:31:50 <c_wraith> sveit: return *types* are fixed by the call site, not determined by the function being called.
08:32:38 <phaazon> hey, something I asked on #haskell-game and I got no answers: given an AST like data E a = V a | Lam (E a) (E (Maybe a)) | E a :@ E a, is it correct to say that “Var "x" :: E String” could refer to any type of value when substituting? how could I ensure a type for a variable?
08:32:39 <bollu> hm, if I have an IO bool (which is the path to the config file), and  I want to return a Maybe Config (which is the parsed config file), since I can't >>=, what operator do I use?
08:33:05 <sveit> c_wraith: not sure I understand. i pass functions to fmap, so the type is determined by the arguments being passed...
08:33:20 <c_wraith> bollu: The return type would have to be IO (Maybe Config) if you want to do anything useful with the IO Bool value
08:33:43 <bollu> c_wraith: aw, that sucks.
08:34:01 <c_wraith> bollu: it's actually really handy in the big picture.
08:34:05 <bollu> c_wraith: so then to access the Config I'd have to first >>= and then pattern-match maybe?
08:34:08 <bollu> c_wraith: how so?
08:34:39 <c_wraith> bollu: you know that things without IO (or something like it) in the type can't depend on the outside world, so you can reason about it locally.
08:35:07 <c_wraith> bollu: that ends up being a much bigger savings than occasionally adding IO to the type of something costs.
08:35:17 <bollu> c_wraith: hm, I choose to believe you :)
08:35:21 <bollu> c_wraith: thanks for the help
08:35:32 <bergmark> phaazon: I don't understand the question, what do you mean by "any type of value"?
08:35:54 <bollu> c_wraith: if I use this config file everywhere
08:35:57 <c_wraith> bollu: anyway, you have two basic options.  One to make your function be Bool -> Maybe Config.
08:36:01 <bollu> c_wraith: won't every function get tainted by IO ?
08:36:11 <bollu> c_wraith: continue
08:36:27 <c_wraith> bollu: you can apply that function to an IO Bool without the function actually knowing it's working on an IO value
08:36:38 <phaazon> bergmark: well, do you agree the AST doesn’t make any assumption on the type of the values referenced by the variables?
08:36:41 <bollu> c_wraith: ah, right
08:36:46 <phaazon> Var "x" + Var "y"
08:36:52 <c_wraith> bollu: that's the preferred approach wherever possible
08:37:02 <phaazon> here, x + y could be Float, Int, (Num a) => a
08:37:20 <bollu> c_wraith:hm, okay
08:37:21 <bergmark> phaazon: that ast doesn't but you could annotate everything with a type
08:37:46 <phaazon> bergmark: so an AST is just a way to make relations, and it’s not type safe?
08:38:12 <c_wraith> bollu: but in the cases where you can't just do that because you need to do IO pervasively (like if the Bool controls whether you load from a file or not), then you do just have to make the return type IO (Maybe Config)
08:38:22 <bollu> c_wraith: ah
08:38:23 <c_wraith> bollu: in that case, though, you're still not stuck with IO in *everything*
08:38:50 <c_wraith> bollu: Rather, you're stuck with IO in the things that have to do IO.  And with a little care, you can often structure it so most of your program doesn't have to do IO
08:39:23 <bollu> c_wraith: well, acutally, the function now looks like this: String -> IO (Maybe Paste); the string is the file path, the IO cause I check if the file exists, and Maybe if the parseing fails. Should I split the indivisual steps up?
08:39:50 <c_wraith> bollu: that is, you're strongly rewarded for separating IO from the logic itself, because that lets the logic not involve the IO type.
08:40:26 <bollu> c_wraith: "rewarded" as in my entire program doesn't become tainted with IO right?
08:40:32 <c_wraith> bollu: correct
08:41:24 <c_wraith> bollu: anyway, the way I'd break that down is a parser that doesn't involve IO, and just takes the contents of the file as a String or Text or whatever you're using, then a second function that attempts to load the contents of the file and pass to the parser.
08:41:58 <c_wraith> bollu: that separates the parts that do need IO from the parts that don't
08:42:04 <bergmark> phaazon: it's type safe, but you are talking about "types" on the value level, but you may be looking for GADTs
08:42:24 <phaazon> bergmark: maybe indeed
08:42:27 <bollu> c_wraith: okay.
08:42:29 <bollu> c_wraith: thanks again
08:42:57 <bollu> c_wraith: this is the first time I'm doing something non-trivial with haskell. It's equal parts fun and frustrating :)
08:43:38 <c_wraith> sveit: I mean in some sense, the caller already knows the types.  Admittedly, if the caller is also polymorphic, it may not know them explicitly - but the types are still controlled by the calling function, not the function being called.
08:43:53 <dmj`> how do I parse this following json "{ \"error\" : { \"type\" : \"hi\", \"message\" : \"ok\" }}" w/o using two data types?
08:44:38 <c_wraith> sveit: anyway, if your goal is to make how a function behaves depend on the types involved, there's one main tool for doing that in haskell: type classes
08:44:56 <bergmark> dmj`: with aeson? use (.:)
08:44:57 <sveit> c_wraith: that's fine, my point is that i would like fmap (a -> Double) b to be implemented differently from fmap (a -> b) c in general
08:45:19 <c_wraith> sveit: That's actually intended to be impossible.
08:45:36 <c_wraith> sveit: the whole point of Functor is that fmap is a natural transformation.
08:45:49 <c_wraith> sveit: that means it has to treat all "contained" types uniformly
08:46:04 * hackagebot open-union 0.1.0.0 - Extensible, type-safe unions.  http://hackage.haskell.org/package/open-union-0.1.0.0 (BenFoppa)
08:46:06 * hackagebot open-union 0.1.0.1 - Extensible, type-safe unions.  http://hackage.haskell.org/package/open-union-0.1.0.1 (BenFoppa)
08:46:27 <dmj`> bergmark: trying that but its returning Nothing, think I'm missing something
08:46:30 <dmj`> bergmark: http://lpaste.net/106627
08:46:36 <c_wraith> sveit: if you don't want to treat all the "contained" (quotes because it's not really an accurate word, but it's short and gets the point across) types uniformly, you need a different class than Functor.
08:46:44 <sveit> c_wraith: what you're saying is what i've been reading, but i've put my question more in code: http://lpaste.net/4472817558105358336 .
08:46:50 <bergmark> dmj`: you can use decodeEither to see the error message
08:47:26 <sveit> if the function passed to fmap is of type (Storable b) => (a -> b) i can use the CV constructor instead
08:47:30 <sveit> but i can't figure out how to do that
08:47:41 <glguy> dmj`: you aren't looking inside the "error" field
08:47:45 <c_wraith> sveit: you can't do that.  It's explicitly not what Functor is for.
08:48:03 <bergmark> dmj`: and you are just reading the properties from the top level object, you need some (.: "error")
08:48:08 <sveit> c_wraith: but did you take a look at the lpaste? it would still be returning a value of the same type
08:48:26 <radix> Are there any haskell debugging tools that nicely visualize the reductions of an expression?
08:48:34 <sveit> c_wraith: different constructor, same datatype
08:48:40 <mietek> Paging 23Skidoo
08:48:42 <glguy> sveit: If you want something that is similar to Functor but doesn't work like functor you can make a new typeclass
08:48:57 <WraithM> dmj`: You need to parse the top level object first, then look into the object under "error"
08:49:17 <minkowski> o/
08:49:35 <sveit> glguy: i get that, thing is i already have an instance of functor that does what i want, just inefficiently. i would like to get the same result but more efficiently.
08:49:39 <c_wraith> sveit: I see what you're asking, and what you want would be morally a Functor - but only because you were very careful to make it one.  It would be possible to write a broken implementation that breaks the Functor laws
08:50:16 <c_wraith> sveit: the tools haskell provides have made the choice that it's better to statically rule out that class of bugs than allow you to introduce it if you swear you'll get it right.
08:50:24 <sveit> c_wraith: but if i'm careful why shouldn't i be allowed to do it? :)
08:50:38 <c_wraith> sveit: because programmers often get it wrong. :)
08:50:54 <bergmark> dmj`: also consider using `withObject' so you don't need to handle the other cases
08:51:10 <sveit> c_wraith: so there is no solution? like you said, what I have is conceptually a functor, and i've even implemented an inefficient functor instance, but there is no chance of getting an efficient functor instance out of this?
08:51:40 <c_wraith> sveit: actually, what you have now isn't conceptually a Functor.  It breaks the Functor laws.
08:52:05 <sveit> c_wraith: really?
08:52:05 <c_wraith> sveit: I was saying that with more tools, you could write something that is conceptually a Functor, but those tools would be more dangerous than useful.
08:52:14 <rwbarton> sveit, you can consider something like data C a where CV :: (Storable a) => SV.Vector a -> (a -> b) -> C b
08:52:24 <rwbarton> that is an honest Functor
08:52:50 <glguy> sveit: fmap id  should be equivalent to id, but in your case it isn't
08:52:51 <c_wraith> That's just Coyoneda SV.Vector a...  But yes, it's a Functor alright!
08:53:05 <rwbarton> yes, it's sort of a free functor
08:53:16 <rwbarton> except with this Storable constraint
08:54:55 <c_wraith> rwbarton: true, though if you write it that way, you don't really need the Storable constraint.  At least, not in most cases.
08:55:45 <Tjr> sveit: maybe this is closer to what you're looking for? http://hackage.haskell.org/package/rmonad
08:55:50 <c_wraith> sveit: I do recommend looking into rwbarton's suggestion.  It might solve your problem
08:57:07 <sveit> c_wraith: going to try out rwbarton's suggestion now...
09:01:37 <sveit> c_wraith, rwbarton : I'm having trouble making this work, is there somewhere one of you guys could point me for more on this?
09:02:41 <c_wraith> sveit: well, the basic idea for that type is that's a true Functor wrapper for Storable vectors.  You'd also want a function like fromC :: Storable a => C a -> SV.Vector a
09:03:01 <c_wraith> sveit: and really the only meaningful operation C would support is fmap
09:03:34 <rwbarton> you can also read elements (C b -> Int -> b)
09:03:45 <c_wraith> Oh, that's true.  You can index just fine.
09:03:53 <sveit> ah i see, and fmapping is just composition?
09:03:58 <c_wraith> rwbarton has clearly thought about this more than I have. :)
09:04:04 <c_wraith> sveit: correct
09:05:07 <c_wraith> sveit: and something like toC :: Storable a => SV.Vector a -> C a  would just initialize the function as id
09:06:30 <sveit> c_wraith: and i probably want another typeclass, since fromC :: (Storable a) => C a -> SV.Vector a, but fromC :: C a -> [a] in general
09:06:32 <sveit> ?
09:06:55 <bennofs> How can I structure my project when I need to write different code for unix/windows? The code implements the same interface (=> data types should be shared), but using different underlying FFI functions. I'd like to avoid putting large chunks of code inside CPP
09:07:32 <c_wraith> sveit: I'm not sure if you get a big benefit from making that a class..  But you can try, if you like.  Personally, I'd start by just having two different conversion functions, and seeing if you can always manually pick the right one.
09:08:00 <glguy> bennofs: You might have your .cabal file include different source directories depending on that platform it's building for and then carefully keep them in sync...
09:08:01 <dmj`> bergmark: ahhh k I got it :)
09:08:04 <dmj`> parseJSON (Object o) = o .: "error" >>= \e -> StripeError <$> e .: "type" <*> e .: "message"
09:08:22 <dmj`> bergmark, glguy, WraithM: thanks bros
09:08:28 <bennofs> glguy: hmm, if that's the alternative, it's probably easier to just use CPP :)
09:12:56 <sveit> c_wraith, rwbarton : so why isn't data.vector implemented this way? it worries me, since i'm definitely not more experienced in haskell than the author of that package :)
09:13:51 <thinkpad20> hey guys does haskell do anything behind the scenes to speed up currying? It seems like a function like `foo a b c d = a + b + c + d` would be quite inefficient; not only does it have to create 4 functions (\a -> ..., \b -> ... etc) every time it's called, but on the right-hand side it needs to perform 4 function applications. It seems like this would be way slower than the uncurried equivalent. Anyone know what Haskell does to sp
09:14:44 <thinkpad20> I seem to recall seeing some paper, maybe by SPJ, describing the optimization of currying...
09:15:14 <dmj`> thinkpad20: http://dl.acm.org/citation.cfm?id=1166018
09:15:17 <glguy> thinkpad20: You might start here: https://ghc.haskell.org/trac/ghc/wiki/Commentary/Rts/HaskellExecution/FunctionCalls
09:15:22 <ParahSailin> thinkpad20: its probably all just StgClosure stuff
09:15:58 <thinkpad20> sweet thanks guys
09:16:06 * hackagebot tasty-th 0.1.2 - Automagically generate the HUnit- and Quickcheck-bulk-code using Template Haskell.  http://hackage.haskell.org/package/tasty-th-0.1.2 (BennoFuenfstueck)
09:16:42 <Pythonfant> Is there some tool to automaticly convert do notation to >>=?
09:17:11 <glguy> ?undo do x <- m; y <- n; return (x y)
09:17:11 <lambdabot> m >>= \ x -> n >>= \ y -> return (x y)
09:17:13 <c_wraith> sveit: it's not implemented that way for a couple reasons.
09:17:18 <dmj`> @undo do { a <- getThing; return a }
09:17:18 <lambdabot> getThing >>= \ a -> return a
09:17:23 <glguy> Pythonfant: You can play with ?undo in /msg
09:17:27 <Pythonfant> ah thx
09:17:36 <c_wraith> sveit: first, you can't add an element to that representation, or update the element at an index, or anything else.
09:19:38 <c_wraith> sveit: second, it actually slows down lookups.  Every lookup has to apply the function to return a value of the correct type.
09:20:25 <c_wraith> sveit: All the ways Vector normally stores data store data either fully evaluated or as a thunk where evaluation will be memoized.
09:21:33 <c_wraith> sveit: the tradeoffs Vector makes are all about getting the most speed, at the cost of some flexibility
09:21:42 <glguy> sveit: Are you sure you need a *Storable* vector?
09:21:49 <sveit> glguy: in my case, yes
09:22:00 <Pythonfant> undo doesn't seem to like let so I need to ask here: I intend to do something like that p x = get >>= (\s -> let res = S.member x s in put $ S.insert x s) >>= return res
09:22:16 <Pythonfant> but ofc now let is not available in the last return
09:22:20 <Pythonfant> how do I work around this?
09:22:36 <rwbarton> just move your parens around
09:22:44 <glguy> move the return inside the parentheses
09:22:44 <c_wraith> move the ( to just before the let
09:22:55 <c_wraith> either way.
09:22:59 <glguy> Brought to you by the monad laws
09:23:04 <c_wraith> err, no.  not either way.  glguy's way
09:23:17 <sveit> c_wraith: so do you think it is a dead end to try to find some compromise where i have a bunch of functions that try to use storable vector as much as possible, but fall back to list if needed, while preserving the performance of Vector and taking advantage of all the existing infrastructure of Functor/Applicative/Monad (which my things are conceptually, but not in haskell :) )
09:24:11 <c_wraith> sveit: in some sense, regular Vectors *are* the type for what you're doing.
09:24:31 <c_wraith> sveit: Storable Vectors should be a weird special case when you're not going to be manipulating the data.
09:24:45 <c_wraith> sveit: and instead are just going to be working with ffi calls
09:25:25 <sveit> c_wraith: that's the case for me, i use them a lot for ffi, and i figured since i often work with numbers the storable version is also unboxed so i get performance benefits
09:25:29 <rwbarton> in general polymorphism and absolute constant-factor performance don't mix so well
09:26:16 <rwbarton> e.g. you can have a polymorphic linked list with boxes, or a linked list with Doubles unboxed into the list cells, but not both at once
09:26:46 <sveit> c_wraith: i.e. i have some large operations for which I call out to C/FORTRAN, but would still like unboxed performance on numbers within haskell, while having the possibility of generality when/if needed
09:26:48 <Pythonfant> Now I'm getting a type error and I don't really understand why http://lpaste.net/106632
09:26:52 <glguy> sveit: You can write your own pair of fmap-like functions, one that tries to go back to a Storable, and one that goes to a list
09:27:22 <rwbarton> ^ this sounds like the real solution IMO, anything else seems to be premature ... something
09:27:40 <sveit> glguy: yeah, i know that i can write my own functions, but it would be upsetting to lose the nice pre-existing haskell infrastructure
09:27:48 <thinkpad20> hey guys another implementation question: are there any good papers on efficient implementation of polymorphism? For example, you have an id function `id x = x`, then this should accept any argument, but different arguments will be of different size; for example `Int` (4 bytes) vs `(Int, Int)` (8 bytes). A simple way is to use a pointer, so that everything is the same size, but this isn't very efficient. Any good refs for compilin
09:27:55 <sveit> isn't the whole point of haskell to avoid re-writing things?
09:28:12 <sveit> or part of the point at least :)
09:28:19 <rwbarton> sveit, it would help to have some concrete problem
09:28:51 <glguy> sveit: The point of Haskell is more that the types reflect what the code is doing. In the case of Functor the types tell us that the code isn't doing what you're trying to do. You need to pick some types that reflect what you're trying to do
09:28:53 <rwbarton> where you have to use fmap because it is used inside another library, or something like that
09:29:57 <carter> sveit: use Data.Vector.Generic
09:30:01 <Pythonfant> Ah got rid of the second error by using >> instead of >>= at the end
09:30:11 <sveit> rwbarton: well your question drew me out, this is pre-mature everything :)
09:30:18 <Nik05> i think the quarter, penny, coin and shoe dropped :)
09:30:28 <niix> Is there a popular Haskell web framework?
09:30:55 <carter> sveit: Functor generalized to some sort of indexed functor *could* be made to work I think
09:31:00 <carter> but not the one in Base currently
09:31:14 <pavonia> thinkpad20: Why are pointers not efficient?
09:31:18 <k00mi> thinkpad20: in general everything is a pointer, that's the cost of using a high-level language
09:31:34 <k00mi> thinkpad20: but note passing pointers is often much more efficient than copying
09:31:43 <carter> or the cost of using a low level language!
09:31:50 <carter> yeah, sharing is caring and faster
09:32:04 <k00mi> hehe
09:32:25 <niix> What are the popular uses for Haskell as a profession?
09:32:53 <carter> all of computing
09:32:55 <carter> all of it
09:32:57 <k00mi> niix: there are several: yesod, snap, happstack
09:33:31 <yitz> k00mi: that's just for web dev. which is certainly one popular direction.
09:33:46 <Pythonfant> ah fixed it
09:33:51 <k00mi> yitz: he asked about web frameworks earlier
09:34:03 <yitz> k00mi: ok
09:34:12 <yitz> Pythonfant: yay!
09:34:37 <niix> sorry, I should give some background.  I work as a web developer for a living, so I live in JS land all day long
09:35:00 <niix> I'm looking to expand my brain a bit and the way I approach things, so I wanted to give haskell a shot
09:35:21 --- topic: 'http://www.haskell.org/ | Paste code/errors: http://lpaste.net/new/haskell | Logs: http://tunes.org/~nef/logs/haskell/?C=M;O=D http://ircbrowse.net/day/haskell/today?mode=recent | Administrative issues: #haskell-ops | Hackage down? http://hdiff.luite.com | XCode 5 issues? http://is.gd/H4sEub'
09:35:21 --- topic: set by Cale!~Cale@CPEc8d3a35c2cdd-CM78cd8ec9750d.cpe.net.cable.rogers.com on [Sat May 31 02:09:44 2014]
09:35:21 --- names: list (clog phi__ thevishy pchiusano dsantiago litherum pjdelport Thra11 trism bjorkintosh Mon_Ouie jomg niix Lutinzzz knuton conal StoneCypher pavonia l0cust micahcowan jkarni M_F_B anRch tharper mars0000 solidus-river seschwar path[l] mfzb marcus-aurelius Vorpal silver_ nadirs Javran fabe systemfault Wertax kiniry vendethiel Kron ldbrandy tsani Sebastien-L khushildep Jesin augur Takle Judde jmcarthur_mobile osa1_ doomlord_1 favetelinguis alanz wilfredh thetallguy)
09:35:21 --- names: list (oubiwan__ elfenlaid stolaruk chatsiri_ oleo Nervkind zachmay triliyn a3gis simukis_ \q telser thinkpad20 codesoup bitonic Ankhers dmj` minkowski glguy aviraldg hebz0rl aschroeter divyanshu samrat maxcan jnoah Rufflewind inad922 umib0zu Apocalisp ndrei slroberts doyouevenmath phyrex1an moghedrin jrm2k6 _deepfire-laptop Zariel_ coltfred Velpoman tolt rrradical Kiryx marchelzo_ shesek innertracks MercurialAlchemi marsam ArneL lfp plutoniix hemanth ajf Brando753)
09:35:21 --- names: list (sritchie Soft andyland int3__ simcity2000 szymanowski dustin10 gabor cfricke zzzzzzzziiii toors WraithM jumblerg detrumi eacameron eevar seantallen ndeine ab9rf perspectival bennofs dgpratt yacks EvilPenguin glosoli Dtgr tommd quchen lambdageek nkhodyunya albeit leroux zaphar_ps dpwright kfish ystael hiptobecubic pmade ambimorph Sorella MindlessDrone saml n0n3such LangeOortjes ashbreeze pvt_petey wcunning cognominal afarmer klao juandopazo Guest40047 klaut_)
09:35:21 --- names: list (zos exobit tocklime mada whaletechno exgf pdpi mp_ prophile geekosaur2 ienh_ Gurkenglas OlegYch talzeus drdanmaku Aune dabd m00nlight Liskni_si jorr` marr zwer thunderrd dhil glaebhoerl_ goldfire matheus23 qxjit felixsch sxn kuribas yorick harski Dusty_ mgsloan puchdapixel tv tonbo erkin smth johnw ph88_ jesyspa paullik1 q66 ixti vanila ts33kr Raynes d3lxa certainty Fuco pfurla hackagebot Olive`_ c_wraith DT`` JesuZ-Home streep ZioCrocifisso BluePeppers)
09:35:21 --- names: list (freeman42 Sculptor andreasrx ceii trnh iwoeri haskoiner edsko SaBer fling caasih_ laar Chaze Khisanth phischu manfoo7 ft joneshf sjoerd_visscher SoupE jordanl Laney choosegoose Hermit sw1nn yitz MrWoohoo Ragnaroek_ erikd mannyv Ragnaroek mceier linduxed Lethalman sbjorn colluphid onthesta1rs gehmehgeh arenz hamarukusa netj slomo jackneill Itkovian nkoep snoyberg alpounet codygman arch_ texx RchrdB d3m1g0d- Somix sakirious vili dv- isenmann steamboat ozataman)
09:35:21 --- names: list (Swizec zph_ koninkje_away otto_s dbu jaimef corgifex tismith shanse hive-mind Plasmastar ephemeron wchun Arkaniad|Laptop nahob Qfwfq jeff_s1 ClarusCogitatio lemao kloeri ciaranm ksf centrinia_ apaku X2 fold george2 falafel jack_rabbit predator117 jedws byte48_ mattp_ lieven_ cobakobodob maaku SparkySparkyBoom ThatOtherPerson Exio4 benzrf petantik Rylee z0d rejuvyesh akurilin pikhq paddymahoney jrp6 petterw wlhlm happy0 LordDeath jameseb mno2_ td123 Lacriatch)
09:35:21 --- names: list (Reiser noplamodo lpaste jodaro_ lep-delete waterlaz fergusnoble pnielsen_ staffehn jasu0 wizonesolutions raid thirsteh_ callumacrae TDJACR jix RevJohnnyHealey l4u milli werdna MindfulMonk zz_LoRdToLsToI akahn nisstyre herrwolfe45 humppa zugz heikkih abh raphie__ clementd AlainODea_ Nickeeh_ blindscreen adnap Jo-haN byorgey Someguy123 sinclair|work zpconn_________ fnordbert lispy_ SLii teeteewhy phaskell Jaxan Raynos tekacs zerokarmaleft mrd_ popx_ SegFaultAX)
09:35:21 --- names: list (jagtalon_ Guest50458 taruti Shogun robbert cursork cdidd sea-gull nicoo theorb gws jml gibsonfs genericpersona Pythonfant vsayer jakutis Bazzie xinming JZTech101 idoru joneshf-laptop gemelen cbarrett ccasin thorkilnaur robbins banisterfiend wto anders^^ mike4 meretrix murgaan geekosaur Philonous jonathan2 CindyLinz saep zxq9 descender dmwit dr_ inr iulian theanine haasn acfoltzer etrepum AntiSpamMeta c74d Transfusion jnott mrb_bk Klumben electrogeek Vbitz dqd)
09:35:21 --- names: list (u-ou ocharles jmct airloom Polarina yac koz aristid-ic_ jzelinskie avallark jroesch_ Karethoth_ Edoxile Boreeas anachron sohum Jello_Raptor Tordek peddie Svedrin greymalkin wunki drdo Paprikachu kongo2002 sipa jlyndon docsis____ leifw superjudge_ himikov seanparsons andreypopp PatrickRobotham vera bchar ReinH ixian amatsu nakal Xorlev qixos dschoepe nemesit|znc FreeFull jedai wei2912 davidfetter Rakkin srbaker spaceships catsup tnks eikonos mornfall)
09:35:21 --- names: list (prototrout jrm bvad ezrios deni diginet s4msung defanor pdurbin jle` segmond bxc davean1 Gilfoyle zarul arun morolin _d3f kqr LeaChim Eliel Artpicre elgot canta vladan dosequis ivoscc anders0 pharaun pdxleif nelsonje redtricycle DarkFox SethTisue_______ stephenmac7_ __main__ duairc_ lenstr owlglass hpc kittenso1p mayski Hafydd Yawgmoth stvc shepheb_ michaelpj_ gseitz_ tmssgrdn Adeon irssi__ Boney companion_cube Freundlich Ornedan_ nik_89 tlevine ziman Ke)
09:35:21 --- names: list (japesina- jlouis Burton iota_ finnrobi atota_ suOya__ bsmti earthy cynick Fubar^ davidthomas Jonno_FTW phaazon numberten ChewieBeardy JPohlmann tessier_ Dodek bryan11 bjobjo BeardedCoder omefire2 mangaba_leitosa ChongLi BMeph cehteh kcm1700 dreixel_ jcarpenter2_ M-ou-se bartavelle ortmage dp_wiz steshaw_ qwandor Iloiny somenick nkpart sbyl yeltzooo obiwahn nifty myme Taneb ederign alang skarn ggreg Wayneoween honza alphonse23_ pyrtsa radix Bane^ Eelis dkua)
09:35:21 --- names: list (kcherkashin____ yrjolam sellout ircbrows- mxf jmcc blast_hardcheese Guest59866 si14 Imdsm ski_ ikkebr jonsterling MansurAshraf__ billyiii_ termos monochrom CARAM_ stbuehler BlastHardcheese mandu_ rola cstrahan Gowilla grohne_ cin honkfestival estulticia Bigcheese dolio posco_ lpsmith Na6hu7Ud_ b2coutts xplat XMunkki_ cjwelborn_ rsnous nesqi_ agrif kazagistar qz Yahweh dlundy liszt ForNeVeR CosmicRa` joshsz simon Natch thetallguy1 dsirenko_ zymurgy epta ivan`)
09:35:21 --- names: list (chirpsalot aupiff ajcoppa puzza007 brixen kini killy9999 gereedy idnar charliekilo solrize bounb rschulman neptunepink Walther pnielsen Cr8 dyreshark pp^ jonathanj eyck_ ValicekB cross_ mephx ipuustin_ obcode gniourf thirsteh lorem_ipsum ttuegel Bwild_ adlan Ezku FireFly amiller flux ryanakca ParahSailin zenoli rieper Antoine59 jrib c9sloud klugez noidi araujo luite banyan oconnore_ rwbarton mathu Igloo stephe__ bitemyapp mami_ jj2baile_ andares__ ousado_)
09:35:21 --- names: list (afleck_ chas nick1234abcd_ jcp betawaffle stepcut Ulrar SHODAN bd_ luzie David joeyh Intensity tpsinnem averell melter DarkCthulhu EvanR WJW LnL Chousuke ernst Nik05 DanC_ Maxdamantus blz37 bgamari creichert qrada Sauvin zeebo tgeeky ZettaBlade Ralith CaveJohnson mgomezch ggherdov bgyss ekroon_ yeshuah kylcarte yumike alcabrera|afk jayne sgronblo copumpkin Zekka hng nikola kame355 purefn joelteon Hodapp go|dfish Netfeed kxra mlen bbee Cryovat demolithion)
09:35:21 --- names: list (knyon dh marienz pfn schlumpi_ zeroskillor asm89 dropdrive benbangert savanni_ Clint isomorphismes jchee_ qr42 fabjan petercommand PierreM_ jzl_ lokydor_ simon__ itsmonkt1stic AncientPC newsham_ bens_ tippenein benedikt Zariel Sornaensis squimmy_ bergmark Eagle_Erwin DustyDin1o kwmiebach mbrcknl tobyp jackhill gregburd chasecaleb mankyKitty Argh2 Blkt ch3mical egisatoshi_away ivanm dustinswan cryon rocurley avdi Tehnix ehamberg Will| asfp` vhz barrucadu)
09:35:21 --- names: list (alexsdut1on MK_FG kwantam tazjin `nik`_ brackets metadave cipher stevely__ shergill adit DrCode drlemon ahihi cdk javax tych0 ilias davorak mgaare juhp troydm maoe alinab coeus mirsal nyanpasu Eridius kipras iross ybit3 evax Drezil ninegrid warden djahandarie dmilith mikecaruso bbloom yubrew g0dmoney- gbarboza Or1 mechairoi mikeplus32 sofancy jrw zenzike frerich moop Kobata enk0 Tesseraction vikraman akshatj-c gridaphobe tdammers apples saarin passiveobserver)
09:35:21 --- names: list (carter srhb imalsogreg blicero ivan\ amontez znutar_ dju wjlroe danneu sajith Deewiant pfoetchen Watcher7 Kinnison snowp rtl opqdonut Fuuzetsu KitC wormphle1m brisbin Hardolaf codeburg swen claudiyoh adimit eyem osfameron cmsd2 mero felipe_ aristid sordina2 lusory karls Merovius @ChanServ _1126 Razz valdyn phaer Belgarion0 Harbinger mrowe_away TheBrayn geal s_e GaveUp `micro keko_ heaumer solarus bjornars fall__ phadej majoh Sagi knyppeldynan AshyIsMe dixie_)
09:35:21 --- names: list (hbar gandr monsieurp tavelram_ otterdam hc Enigmagic aji paz stelleg pyry` hvr koala_man lahwran yusukesuzuki poucet pii ahf AtnNn statusfailed frms_ dottedmag heyj joar helgikrs1 comboy eiro aseidl ion runde sveit majackson sjy pranz mixi cschneid zomg mokus theDon Desoxy ZsoL_ kaol dxld WarzoneCommand Lemmih yriw raek hpd j0ni mietek seliopou qtplatypus l3kn burp saurik bzf wting saiam_ otulp dabradley tg haroldwu Nanar mimi_vx mp edk cyphase jdiez integral)
09:35:21 --- names: list (lacrosse_ Gothmog_ krakrjak rhodesd Arnar_ sleepynate tomejaguar Jei Jaak ido lyxia Paks bitraten Erstarrung notdan joe_k Nertskull katis mononofu DigitalKiwi boothead blenny kgadek edwtjo sviterok ibid eyenx jlewis DasIch chexxor joefiorini yan_ bcoppens noctux cmn joachifm jrslepak sunnavy kandinski horlicks_ tomaw `bps PHO_ sdx23 drone| FUZxxl spacebug jaysonsantos kosmikus em arrdem elfangor sam_d SwashBuckla hayashi Iceland_jack nispaur fryguybob indigo)
09:35:21 --- names: list (liyang Phillemann xahry_ ilmig Tene Bootvis zebr Kabaka niko albel727 shutdown_-h_now stass aford Dashkal bigos dogmaT Lindrian iron_houzi mr- boegel|work mak` felixn slobo_ hyPiRion helge_ gargawel tero- ninzine ps-auxw Cerise kmapped dlackty_ MMuse_ FliPPeh deavidsedice kragniz_ agolsme_ danking Phlogistique Saizan korpse_______ Draggor HugoDaniel ineb feltnerm `0660 aoh Excurio gdsx Kneiva gx^ MasseR hegge Cale vmeson mrshoe untwisted Luke quaestor supki)
09:35:21 --- names: list (dougia levi macron magicman tinyghost hiredman stiell andyo Gracenotes [swift] ephess sarlalian bwe helgar tridactyla tromp_ everett lulf Gika ethercrow farn Corey photex zz_robj_ dan64 alorente musicalchair jcurbo TakSuyu kardboardb plhk coppro Derander kshannon_ GGMethos cybrhuman fyolnish bra MrGwen djapo aloiscochard skrio JokerDoom elrancho mgomes _flow_ xpika deevus jpierre03 kalloc gidogeek tamiko Th0mas Kazurik metaf5 uncleBlazer spion cyrusdavid)
09:35:21 --- names: list (drbean xeno wagle ckw martingale tomboy64 swipetospork KaneTW Axman6 mnemon aseeon tumdedum Internet13 pcapriotti flebron BrianHV mikeizbicki wjm relrod kalz lamilami devn hongminhee mortberg charlieb shapr earldouglas zalami zeiris Nivim Licenser terlar [mth] rntz High-Q-Brah Baughn janne yano Twey Eiam mjrosenb tdg guampa studybot_ wjt jabbslad__ emmanueloga teehemkay cloudhead nsaje aljosa shennyg_ lambdabot sm julmac dcoutts derekv isomorphic NinjaPenguin)
09:35:21 --- names: list (Krakarn-- emlow mjo jlamothe Guest81616 zq tmct twopoint718 gienah identity mendez kakos peder hamishmack wollw systematik catalina fikusz yam pieter_ boot13 zso nwf kmicu Sonderblade Kruppe Rembane rxc noddy sgray10 Athas Rutger` unsymbol kav solirc cods rudi_s McManiaC oubiwann cjay fractalcat tomprince StoneToad lykathea bernalex ByronJohnson cwc liori KitD andrewsw jin_jin misetes xymox hmax malorie batz ij dilinger_ Nimatek rs0 algoriddle jimki annulus)
09:35:21 --- names: list (kloplop321 xenocons mrkishi ClaudiusMaximus froztbyte Sgoettschkes KorriX cstanfill asterblaster mrmonday eagleflo joshc xnyhps peltchu mike2 maurer int-e OrangeDuck flori scopedTV Starfire Vq eL_Bart0 k00mi mirf Spockz jaspervdj pi8028 natte mshroyer neektza MitchW thoughtpolice RayNbow`TU xaimus_ absence pingu TheMoonMaster asjo` Adios_ rblackwe)
09:35:55 <niix> whether or not I end up using Haskell in my job is different story, but I would like to learn a bit more about functional programming to help me solve problems in a different manner than I do now
09:35:56 <yitz> niix: so the frameworks mentioned by k00mi are for setting up server-side web apps. you plug the client-side JS into that.
09:36:03 <ij> Does lambdabot have hxt loaded? I want to use Text.XML.HXT.Arrow.ReadDocument.xread in >.
09:36:18 <carter> also GHCJS is a thing
09:36:23 <carter> which is really really really impressive
09:36:37 <glguy> ?type Text.XML.HXT.Arrow.ReadDocument.xread
09:36:38 <lambdabot>     Not in scope: ‘Text.XML.HXT.Arrow.ReadDocument.xread’
09:36:42 <glguy> nope, not there :)
09:36:58 <yitz> niix: on the client side, there is fay, ghcjs, and elm. (that's probably not a complete list...)
09:37:10 <thinkpad20> pavonia: because it adds an extra step of indirection. passing a value directly doesn't require this
09:37:48 <thinkpad20> for integer addition, for example
09:38:57 <thinkpad20> i suppose for large structs copying is probably less efficient than passing a pointer
09:39:17 <pavonia> But don't you always need at least one step of indirection when you don't know the type of the argument in advance?
09:39:54 <ij> Why can't I apply this arrow? It's from HXT. http://sprunge.us/PSIX
09:40:05 <pavonia> or some sore of lookup instead
09:40:27 <thinkpad20> but in a statically typed language you do know it
09:41:04 <k00mi> in the vast majority of cases you don't know the runtime size of objects
09:41:27 <thinkpad20> how wouldn't you know? except for vectors
09:41:44 <k00mi> we use a lot of recursive data types
09:42:08 <thinkpad20> each element of a recursive type has a known size
09:42:12 <k00mi> sure
09:42:14 <glguy> thinkpad20: You would only know if you did some kind of whole-program compilation. It isn't uncommon to compile a function not knowing what type it will be run at
09:42:26 <thinkpad20> so something like what mlton does?
09:43:13 <thinkpad20> I guess what I was imagining was monomorphization: seeing all of the cases where a polymorphic function gets used and generating a specific instance for each one
09:43:24 <thinkpad20> I think that mlton does that but I'm not sure
09:43:40 <thinkpad20> does C++ templates do something like that?
09:43:45 <pavonia> ij: I don't think you can apply an Arrow to an argument because it's not a function
09:44:08 <Hodapp> the primary function of C++ templates is to generate errors that make no farking sense.
09:44:09 <k00mi> thinkpad20: say you're writing a library that includes a polymorphic function in its interface
09:44:11 <ij> Okay, then I don't understand arrows at all.
09:44:23 <k00mi> thinkpad20: there is no way to know all the instances
09:44:24 <ij> You can only apply arrows if you lift functions into arrows?
09:44:55 <k00mi> thinkpad20: I don't know much about C++, but as far as I know that is exactly how templates work
09:45:08 <rwbarton> ij: the only things you can do with arrows, in general, are the methods of Arrow
09:45:55 <rwbarton> ij: if you have a specific type (that happens to be an Arrow) the library that provided that type might also give some functions that consume ("run") it
09:46:08 <ij> Oh, I see. And what does the run function do?
09:46:14 <ij> HXT has runX.
09:46:19 <rwbarton> depends entirely on the type in question
09:46:32 <ij> Can you give me an example of any kind?
09:46:45 <thinkpad20> k, fair enough
09:46:54 <thinkpad20> I guess you can't have everything :)
09:47:15 <k00mi> thinkpad20: you might look into how rust does this
09:47:15 <rwbarton> well, it's the same situation as with monads. for example, State and runState
09:47:18 <rwbarton> :t runState
09:47:19 <lambdabot> State s a -> s -> (a, s)
09:47:21 <thinkpad20> yeah I should
09:48:17 <thinkpad20> so is haskell's general strategy to pass pointers for everything, or only for polymorphic functions? For example if I pass `[]` into a function, is it passing a pointer to an empty list, or an actual struct (tagged union)?
09:49:04 <rwbarton> you're passing a pointer to something that is sort of like a tagged union
09:49:35 <thinkpad20> not the union itself, then
09:49:57 <rwbarton> right
09:50:03 <rwbarton> it doesn't use pointers for literally everything though
09:50:17 <thinkpad20> yeah I would think that would be inefficient e.g. for arithmetic
09:50:20 <rwbarton> you can also pass an actual integer or floating-point number
09:50:23 <rwbarton> right
09:50:49 <thinkpad20> I'm writing a compiler for a functional language so I'm curious :)
09:50:52 <k00mi> thinkpad20: GHC does pointer tagging and there are ways to encourage GHC to unpack things
09:51:13 <vanila> thinkpad20, for a lazy one?
09:51:28 <thinkpad20> strict, but with opt-in laziness
09:52:49 <rwbarton> it uses an unusual form of pointer tagging though
09:52:57 <rwbarton> it doesn't use tagging to distinguish pointers from non-pointers
09:53:24 <thinkpad20> but presumably a function is going to know whether its argument is a pointer or not
09:53:28 <rwbarton> right
09:53:33 <rwbarton> so in fact I lied slightly
09:53:46 <rwbarton> if you pass [] to a function, it's actually passing a pointer to something, plus 1
09:54:06 <rwbarton> 1 is the tag that means "hey you don't have to bother dereferencing this pointer if you just want to know which constructor it is"
09:54:06 <thinkpad20> does it use some bit flag or something, or...?
09:54:08 <saml> hello. I have data. how can I generate json and also parse json back to data?
09:54:27 <rwbarton> it uses the low 2 (32-bits) or 3 (64-bits) for this purpose
09:54:31 <Pythonfant> saml: http://hackage.haskell.org/package/aeson
09:54:38 <saml> do i need to write two functions?   serialize :: MyData -> Json     and parse :: Json -> MyData  ?
09:54:52 <thinkpad20> why does it need 3 bits?
09:54:54 <saml> or is there a way to express json structure once and let it generate serialize and parse?
09:55:03 <rwbarton> to identify the first 3 or 7 constructors (not sure exactly what happens when there are more constructors than this)
09:55:14 <rwbarton> a pointer to a cons cell will be tagged with 2 since it's the second constructor
09:55:36 <thinkpad20> oh right
09:55:54 <thinkpad20> so it's not a tagged union per se
09:55:57 <glguy> afaik the constructors beyond the limit are left with the "unknown" tag
09:56:07 <glguy> same that they had before being resolved
09:56:09 * hackagebot cipher-aes 0.2.8 - Fast AES cipher implementation with advanced mode of operations  http://hackage.haskell.org/package/cipher-aes-0.2.8 (VincentHanquez)
09:57:07 <thinkpad20> I would have thought it would be something like `struct Either {enum {LEFT, RIGHT} tag; union {data *left, data *right}}`
09:57:25 <thinkpad20> (altho you wouldn't actually need a union for that)
09:59:03 <vanila> thinkpad20, in a typed language you don't need any tags
09:59:29 <joelteon> does vincent hanquez ever come in here
09:59:29 <thinkpad20> you need tags to tell which constructor it is
09:59:32 <vanila> yeah
09:59:48 <simon> surreal numbers induce the natural numbers from 0 as well.
10:00:18 <simon> oops
10:00:30 <simon> meant for -blah.
10:02:44 <thinkpad20> rwbarton: do you have any links to papers on the things you were talking about? or how did you learn about that stuff?
10:04:34 <kaih> h
10:05:07 <rwbarton> thinkpad20: that's pretty much the representation of the object on the heap that is pointed to
10:05:10 <rwbarton> thinkpad20: one sec
10:05:20 <tnks> okay, so sandboxes aren't relocatable if I rename a directory?  Is that just that way it is, or am I doing something wrong?
10:07:59 <rwbarton> thinkpad20: see "The Spineless Tagless G-Machine" and "Faster laziness through dynamic pointer tagging" linked from https://ghc.haskell.org/trac/ghc/wiki/Commentary/Compiler/GeneratedCode
10:09:10 <geekosaur> tnks: depends on which directory. ghc's package database uses absolute paths, and you would need to edit the files in the package.conf.d directory and then `cabal sandbox hc-pkg recache` or something like that
10:12:10 <tnks> geekosaur: just saying I move the root sandbox directory. . . but your advice seems like it's in the right direction.
10:18:19 <thinkpad20> rwbarton thanks
10:26:46 <shlevy> What's a good type to represent absolute paths?
10:30:12 <jonathan2> Is there any faster way of removing duplicates from a list, than to go back and forth to a set?
10:32:03 <OlegYch> > distinct [1,2,2]
10:32:05 <lambdabot>  Not in scope: ‘distinct’
10:32:19 <OlegYch> worth a try
10:32:48 <prophile> jonathan2: nub?
10:32:57 <jonathan2> OlegYch: do you mean unique?
10:33:06 <prophile> > nub [1, 2, 2]
10:33:07 <lambdabot>  [1,2]
10:33:13 <jonathan2> prophile: nub is slow. It wastes time maintaining the order of the elements
10:33:47 <ReinH> jonathan2: no, unless the set has unusually bad asymptotics
10:33:47 <jonathan2> i.e., S.toList . S.fromList list is pretty much always faster than nub
10:33:57 <glguy> jonathan2: If all you know is that you have an Ord constraint, the Set route is going to be best you can get
10:34:27 <prophile> map first . group maybe, depending on ordering
10:34:28 <jonathan2> :(
10:34:51 <prophile> > (map first . group) [1, 2, 2]
10:34:52 <lambdabot>  Couldn't match type ‘a b’ with ‘[]’
10:34:52 <lambdabot>  Expected type: [c] -> [a b c]
10:34:52 <lambdabot>    Actual type: [c] -> [[c]]
10:35:09 <prophile> ah, s/first/head/
10:35:13 <prophile> > (map head . group) [1, 2, 2]
10:35:15 <lambdabot>  [1,2]
10:36:02 <jonathan2> I really need to speed this up, so consider this. The list I want the unique elements of is created by concatenating ~1000 smaller lists. Is there a way I could concat them and keep the result unique in a fast way?
10:36:19 <tommd> hashsets
10:36:22 <jonathan2> prophile: Tried that too, also slower :/
10:36:58 <tommd> jonathan2: If comparison is slow then use a hash set.
10:37:08 <jonathan2> tommd: You're right. That's the one I'm using though, forgot to say that
10:37:48 <tommd> OK, so you are nubbing a list of list of somethings using to/from hashset and want things to go faster still, is that right?
10:37:55 <pjdelport> jonathan2: Can you paste your code?
10:38:34 <jonathan2> tommd: Yep. A lot of data being processed :) profiling says 36% of the computing power is used to nub my lists
10:38:56 <pjdelport> jonathan2: Are you using fromList, or constructing sets incrementally? That should make a significant difference.
10:39:03 <tommd> jonathan2: I have had good success getting a performance increase by putting a bloom filter infront of Data.Set.Set.  I would bet the same to be true of HashSet, particularly if you jigger them to use the same hash.
10:39:07 <pjdelport> (That is, fromList should be faster.)
10:39:19 <jonathan2> pjdelport: I'm using fromList
10:40:48 <jonathan2> tommd: the bloom filter has false positives in the membership test, that could be problematic
10:41:03 <pjdelport> jonathan2: What's your elemant type?
10:41:06 <pjdelport> element, even
10:42:08 <moghedrin> jonathan2: Unless I misunderstand what tommd is saying, that shouldn't be an issue, as whenever a false positive gets marked, the Set should handle the duplicate.
10:42:23 <c_wraith> Is it bad that the first time I head "bloom filter" I thought it was a lens flare technique?
10:42:43 <edwardk> c_wraith: happens to all of us
10:42:57 <shapr> c_wraith: haha!
10:42:59 <jonathan2> pjdelport: http://pastebin.com/D6y3bNDw
10:43:20 <moghedrin> c_wraith: Right there with you, mate. Not the same as a bloom shader, apparently ;D
10:43:28 <shapr> Bloom filters are so nifty!
10:43:37 <tommd> moghedrin: Exactly.
10:43:46 <prophile> bloom filters are a really cool data structure that have close to zero actual use :)
10:43:58 <tommd> And SAT Filters too!
10:43:58 <shapr> prophile: I disagree, they're very useful
10:44:04 <jonathan2> Ok, so bloom filters are an alternative then. It'll likely take me a while to figure out how to use them though :P
10:44:50 <tommd> jonathan2: see http://stackoverflow.com/questions/22638997/haskell-best-way-to-search-a-list-of-large-size/22640047#22640047
10:45:17 <shapr> prophile: seen any of the research on using bloom filters for multicast tree encoding?
10:45:23 <pjdelport> jonathan2: L == Data.ByteString.Lazy ?
10:45:29 <prophile> shapr: I confess myself ignorant
10:45:55 <jonathan2> pjdelport: I didn't specify Lazy. Is it strict or lazy when you don't? :P
10:46:54 <pjdelport> jonathan2: Data.ByteString is strict, IIRC.
10:47:24 <jonathan2> Think lazy would make a difference here?
10:48:37 <pjdelport> Perhaps. With strict bytestrings, that concat will involve a copy.
10:48:57 <pjdelport> jonathan2: When you say "36% of the computing power is used to nub my lists", where exactly is that?
10:49:03 <pjdelport> IOW, which functions?
10:49:16 <pjdelport> Can you paste the relevant profiling bits too?
10:50:33 <jonathan2> pjdelport: it's basically the S.toList that takes all those 36%. The profiling doesn't really say much more than that (I'm not a pro on using the tools)
10:50:44 <tommd> jonathan2: Frustratingly, someone pointed out that I am thinking of the use case in which you have elements, e, which may or may not be in some known set, s.  Bloom filters are a good way to reduce the number of consultations to the set.
10:51:16 * hackagebot rubberband 0.1.0.1 - Binding to the C++ audio stretching library Rubber Band  http://hackage.haskell.org/package/rubberband-0.1.0.1 (mtolly)
10:51:23 <tommd> jonathan2: OTOH, when you want to ADD something to the set that wasn't previously there your original intuition was correct. I don't think bloomfilters can be leveraged well in this case.
10:51:26 <pjdelport> jonathan2: Actually, how does "S.fromList $ L.concat" make sense?
10:51:33 <tommd> jonathan2: sorry for the confusion.
10:52:21 <jonathan2> tommd: But the way you describe it, it would make sense for me to use in my other expensive part in the program. So I'll keep it in mind :)
10:52:37 <pjdelport> jonathan2: Isn't that a type error?
10:53:09 <tommd> And the stack overflow link I posed has code and performance numbers (be it, for a single contrived data set) if you want to take it as a seed.
10:53:19 <pjdelport> jonathan2: L.concat returns ByteString, but S.fromList expects a list of elements.
10:53:40 <pjdelport> jonathan2: Also, why is the result type HashSet [ByteString] instead of HashSet ByteString?
10:53:53 <pjdelport> Is there something else going on here?
10:54:40 <jonathan2> pjdelport: the second function there is returning lists as well
10:55:24 <jonathan2> pjdelport: i.e., views returns [[ByteString]], I do concat on a type [[[ByteString]]] => [[ByteString]] and HashSet makes it into HashSet [ByteString]
10:56:51 <pjdelport> jonathan2: Right, but that shouldn't be possible. concat is [ByteString] -> ByteString, not [[[ByteString]]] -> [[ByteString]]
10:57:46 <therp> is there any standard way to construct a function with the signature Monad m => (m a, b) -> m (a, b)? so the reason I am asking is that I used Arrow.first on a monadic function a -> m b, and I want to take out the monadic compuation from the first tuple element
10:58:44 <glguy> ?type \(ma,b) -> liftM (\a -> (a,b)) ma
10:58:45 <lambdabot> Monad m => (m t, t1) -> m (t, t1)
10:59:29 <jonathan2> pjdelport: I might have done it wrong when I pasted, because I removed a lot of unimportant stuff from the function. But I don't see why is would be [ByteString] -> ByteString
10:59:29 <therp> hmm, strange hoogle didn't find that for me. thanks glguy!
10:59:59 <joelteon> @djinn (f a, b) -> f (a, b)
11:00:00 <lambdabot> -- f cannot be realized.
11:02:04 <glguy> joelteon: It's not true for all 'f', just those with a Functor constraint (or better)
11:05:51 <pjdelport> jonathan2: I'm saying it *must* be [ByteString] -> ByteString (assuming that's Data.BytesString.concat). As it stands, it should be a type error.
11:06:30 <pjdelport> jonathan2: and i'm not sure just from that code what the intent is
11:07:42 <pjdelport> jonathan2: Is it possible to condense a minimal stand-alone example that typechecks and runs?
11:07:58 <pjdelport> including "subwords"?
11:08:36 <athan> Has anyone here done work with ArrowIf? I'm working with HXT right now, and it keeps mentioning `this` and `none`, implicitly as parts of ArrowIf. Does anyone have any references I could advise?
11:09:48 <jonathan2> pjdelport: It would be difficult, and the context would likely not get any clearer :P But do you think in general, that using lazy bytestrings could affect this?
11:10:29 <pjdelport> jonathan2: Well, at the very least, what should addViews actually be, then?
11:11:04 <pjdelport> jonathan2: It might or might not, but it's very hard to tell without understand how the code is intended to work.
11:11:14 <pjdelport> understanding, even
11:11:53 <athan> The crazy part is that HXT's haddocs actually link to ArrowIf with the nonexistent functions: http://hackage.haskell.org/package/hxt-9.3.1.4/docs/Text-XML-HXT-Arrow-XmlArrow.html#t:ArrowXml
11:12:03 <athan> Is there some kind of principal or philosophy I'm missing?
11:12:56 <pjdelport> jonathan2: What is the L import? Data.ByteString or something different?
11:14:11 <jonathan2> pjdelport: L is Data.List. And as far as I can see, the code should really do what I claim :P
11:14:29 <pjdelport> jonathan2: Oh! That's why I asked earlier. :P
11:14:58 <pjdelport> (I thought you said it was non-lazy ByteString)
11:15:05 <pjdelport> (misunderstood, sorry)
11:18:34 <jonathan2> pjdelport: they are non-lazy bytestrings?
11:19:44 <pjdelport> (jonathan2: I thought you meant you did import qualified Data.ByteSting as L)
11:20:07 <pjdelport> (because that's not unreasonable if it was Data.ByteSting.Lazy at some point)
11:20:24 <sveit> with multiparamtypeclasses, if why is it that if i have "class C a b c where f :: a b c -> c" haskell assumes (a :: * -> * -> *), and so (b :: *)? in my particular usecase, (a :: (* -> *) -> * -> *) and (b :: * -> *)
11:20:35 <jonathan2> pjdelport: ah, now I get it :)
11:22:58 <monochrom> the type "f :: a b c -> c" forces those kinds
11:23:05 <rwbarton> sveit: it's a sort of kind-level defaulting
11:23:28 <rwbarton> you can specify the kind of b, or leave it polymorphic, with some extensions
11:23:47 <sveit> rwbarton: with what extensions? :)
11:23:52 <monochrom> similarly in Monad "m a -> whatever" forces m :: *->*, because otherwise "m a" would make no sense
11:24:20 <c_wraith> sveit: do you want to leave it polymorphic, or just enforce that it's * -> * ?
11:24:29 <monochrom> oops, I guess "a b c -> c" just forces the kind of a
11:24:35 <c_wraith> a and c
11:24:43 <monochrom> yeah
11:24:46 <c_wraith> b could be polymorphic
11:24:52 <c_wraith> Or it could be concrete!
11:25:12 <sveit> it would be nice to leave it polymorphic, but how do I do either? can i do either without additional extensions?
11:25:14 <monochrom> yeah, b::* is a default
11:25:53 <sveit> it looks like i can specify the kind with kindsignatures
11:25:59 <sveit> how would I leave it polymorphic?
11:26:12 <sveit> typefamilies?
11:26:16 <pjdelport> jonathan2: Can you paste a snippet of the profiling results? I'm interested to see where the hot spots are.
11:26:53 <pjdelport> jonathan2: from the looks of it, it *may* be in the string construction, rather than in the hashset directly
11:27:09 <rwbarton> if you use {-# LANGUAGE PolyKinds #-} then b will be polymorphic by default
11:27:10 <monochrom> it's best to read GHC user's guide section 7.8 "kind polymorphism"
11:27:37 <pjdelport> jonathan2: In which case lazy bytestrings may help (but that depends on the relative costs of things inside the algorithm, probably)
11:27:38 <c_wraith> sveit: beware that kind polymorphism makes GHC's pretty-printer for types go nuts. :)
11:28:22 <c_wraith> sveit: so error messages or :t in ghci will confuse you for a while, before you understand the *weird* way it chooses to print types that involve polymorphic kinds
11:28:57 <jonathan2> pjdelport: Sure, it'll take a minute to generate it :)
11:30:03 <osa1> I'm forking a thread using forkIO but is there an easy way to force program to wait until thread is finished? without using MVars or something like that
11:30:03 <rwbarton> you can also use {-# LANGUAGE KindSignatures #-} and write "class C a (b :: * -> *) c where ..."
11:30:22 <c_wraith> osa1: nope.
11:30:42 <monochrom> use the async lib. it's easy.
11:31:10 <monochrom> this also means you don't forkIO yourself.
11:31:10 <c_wraith> I guess it's *slightly* easier to use async than an explicit MVar
11:31:46 <jonathan2> pjdelport: http://pastebin.com/jDq7iKsf
11:31:58 <thoughtpolice> osa1: I also second monochrom and recommend async
11:33:22 <osa1> thanks all, I'll check that
11:33:23 <pjdelport> jonathan2: Ah, so it's not in S.fromList ?
11:33:46 <pjdelport> (where does S.fromList fall in the statistics?)
11:34:18 <pjdelport> jonathan2: That sounds like the input construction is what's dominating the run-time cost, which sounds about right looking at the code.
11:34:36 <jonathan2> pjdelport: S.fromList is done in addViews. Moving the conversion to another function moves all the work to that function basically
11:35:49 <jonathan2> pjdelport: I'm not sure I follow. Which part is the input construction?
11:36:24 <pjdelport> jonathan2: The concatenation and sequencing and all that; everything to the right of S.fromList, basically.
11:37:31 <jonathan2> pjdelport: but it's not that part. Moving S.FromList to the function a step up also moves the cost there
11:37:54 <pjdelport> jonathan2: Are you using -fprof-auto ?
11:38:20 <jonathan2> no
11:38:51 <pjdelport> jonathan2: Oh, you probably should?
11:38:54 <pjdelport> How are you defining the cost centers?
11:39:45 <jonathan2> pjdelport: percentage of power used in the function in this case
11:40:08 <pjdelport> percentage of power used?
11:40:09 <jonathan2> I'll generate a new one with -prof-auto
11:40:15 <jonathan2> processing power*
11:40:30 <pjdelport> jonathan2: I'm not sure I understand; I mean, are you manually defining the cost centers?
11:40:50 <jonathan2> pjdelport: ah, no. --auto-all is doing that
11:41:42 <pjdelport> Oh, -fprof-auto is the GHC 7.4.1+ way of saying -auto-all.
11:42:17 <jonathan2> ah, then it's the same then :)
11:45:50 <pjdelport> jonathan2: Aha, I think you'll need another binding or annotation to distinguish the work done in S.fromList from the work done in its input.
11:46:07 <osa1> what's wrong with this "wait" function to wait a list of MVars to have False http://lpaste.net/106662 ?
11:46:39 <monochrom> what is it supposed to do?
11:47:02 <pjdelport> jonathan2: Try defining addViews as:  S.fromList $ {-# SCC "foo" #-} L.concat $ L.map (views k) channels
11:47:21 <jonathan2> pjdelport: But as I said. Moving S.fromList to another function, and keeping the work on the input, drops that function down to ~1% and moves the other 35% to whereever I put the fromList. This makes sense, because there will be ~100-1000 copies of each element, which S.fromList is removing
11:47:35 <pjdelport> jonathan2: Or alternately as: S.fromList foo where foo = ...
11:47:36 <osa1> monochrom: it should keep main thread looping until all mvars are set False
11:47:43 <monochrom> 1000 microseconds is just 1 millisecond
11:47:54 <osa1> is that microseconds???
11:47:59 <monochrom> yes
11:48:00 <geekosaur> yes
11:48:08 <monochrom> 1 second is threadDelay 1000000
11:48:19 <geekosaur> it'sa common mistake, even lambdabot had that bug at one point :)
11:48:59 <monochrom> readMVar is simply a takeMVar and putMVar. you may or may not have race conditions depending on what other threads do
11:49:11 <osa1> okay, but even if I use threadDelay 1000000 it doesn't finish, it loops in wait
11:49:29 <pjdelport> jonathan2: You mean you see that behavior when you just have "S.fromList foo" with foo being a separate binding / cost center?
11:49:39 <monochrom> then it depends on other threads. show a complete self-contained reproducible experiment.
11:50:20 <jonathan2> pjdelport: http://pastebin.com/vibb4u5f
11:50:45 <osa1> monochrom: http://lpaste.net/106664
11:51:16 <Pythonfant> Does somebody no the intend behind the distinct' function in the nicta course? afaics it's exactly the same as the distinct function in State.hs
11:51:20 <Pythonfant> https://github.com/NICTA/course/blob/master/src/Course/StateT.hs#L180
11:51:35 <albeit> I need a function of the type :: m (Maybe a) -> (a -> m b) -> m (Maybe b)... how could I do that?
11:51:58 <pjdelport> jonathan2: Aha. Yeah, that indicates that most of the time is spend in the construction (below foo), not in fromList.
11:52:08 <johnw> using MaybeT and lift you could do that
11:52:20 <johnw> :t runMaybeT . lift f . MaybeT
11:52:21 <lambdabot> Not in scope: ‘runMaybeT’
11:52:21 <lambdabot> Not in scope: data constructor ‘MaybeT’
11:52:44 <jonathan2> pjdelport: foo was the other stuff, S.fromList is in addViews
11:52:52 <albeit> Hmm okay, I'll try it out johnw, thanks
11:52:58 <rwbarton> osa1, a putMVar to a full MVar will block
11:53:07 <johnw> hmm.. that won't work exactly as I specified it
11:53:29 <pjdelport> jonathan2: IOW, addViews is 41.5%, but foo is 34.1%, which means that fromList itself is only ~7.4%
11:54:06 <johnw> :t \m f -> runMaybeT (MaybeT m >>= lift . f)
11:54:07 <lambdabot> Not in scope: ‘runMaybeT’
11:54:07 <lambdabot> Not in scope: data constructor ‘MaybeT’
11:54:09 <johnw> albeit: ^^
11:54:12 <johnw> that has the signature you wanted
11:54:21 <albeit> Awesome, tahnks
11:54:25 <osa1> rwbarton: using modifyMVar_ doesn't change anything, it still loops
11:54:39 <jonathan2> pjdelport: that's the memory allocations
11:54:52 <osa1> oh wait
11:54:58 <osa1> it ends after some time
11:55:23 <osa1> rwbarton: thanks, that solved it
11:55:27 <pjdelport> jonathan2: Oh, foo. % time is second-last in that, then?
11:55:45 <jonathan2> yes
11:57:55 <monochrom> osa1: you misunderstood MVar. since you initialized with newMVar True, it's non-empty. since it's non-empty, putMVar False is supposed to block.
11:58:12 <pjdelport> jonathan2: Okay, so in terms of time, addViews is roughly two-thirds S.fromList, and one-third its input construction.
11:58:47 <osa1> monochrom: yeah, thanks for help
11:59:21 <monochrom> the correct way to use MVar for this purpose (waiting for a thread to finish) is: newEmptyMVar initially, the thread does putMVar (), the waiter does takeMVar.
11:59:41 <monochrom> well, i guess the dual is also correct
11:59:46 <osa1> good idea.
12:00:23 <monochrom> there is also no need to do "wait a short time, poll again"
12:01:23 <osa1> monochrom: that works really well, thanks
12:01:24 <jonathan2> pjdelport: yes
12:01:41 <monochrom> MVar is by definition a bounded queue of size 0 or 1. while it could emulate a mutable cell, it's best used as a bounded queue not just mutable cell
12:02:39 <pjdelport> jonathan2: Are there any cost centers for hashWithSalt in the profile?
12:03:54 <glosoli> Is there some way to jump to source in haskell-mode ?
12:04:17 <jonathan2> pjdelport: unfortunately no. I've been wondering about that
12:06:33 <levy> ping
12:06:44 <levy> quit
12:11:23 * hackagebot pure-io 0.2.1 - Pure IO monad.  http://hackage.haskell.org/package/pure-io-0.2.1 (ChrisDone)
12:12:18 <pjdelport> jonathan2: Hmm
12:14:29 <uvelichitel> ** f
12:14:32 <pjdelport> jonathan2: It looks like HashSet's fromList is actually just a foldl' with insert
12:14:54 <pjdelport> jonathan2: Instead of using HashMap's insert (which uses an in-place unsafe-insert internally)
12:15:08 <pjdelport> jonathan2: That may actually be a performance issue to fix in HashSet.
12:16:04 <pjdelport> jonathan2: OTOH, if duplicate elements dominate in your input, then the safe insert shouldn't be that much worse: it should mainly be a win for non-duplicate elements.
12:16:24 * hackagebot acid-state-tls 0.9.2 - Add TLS support for Data.Acid.Remote  http://hackage.haskell.org/package/acid-state-tls-0.9.2 (JeremyShaw)
12:18:12 <jonathan2> pjdelport: I can't see that there would be a safe and an unsafe insert. Where do I find those?
12:22:25 <pjdelport> jonathan2: I'm just peeking at the source in hackage.
12:23:37 <pjdelport> jonathan2: http://hackage.haskell.org/package/unordered-containers-0.2.4.0/docs/src/Data-HashSet.html#fromList versus http://hackage.haskell.org/package/unordered-containers-0.2.4.0/docs/src/Data-HashMap-Base.html#fromList
12:27:42 <Algebr> General Programming Question: Say the function returns, once a function returns, its popped
12:27:42 <Algebr> 	 off the stack. Say that this function was a async function, so it
12:27:42 <Algebr> 	 might return asyncronsouly after it already returned. So where does
12:27:45 <Algebr> 	 that async code return to?
12:28:37 <johnw> it returns to the scheduler in the RTS code
12:28:44 <Lethalman_> Algebr, eventually called by a scheduler
12:29:23 <Algebr> So every programming environment has a scheduler?
12:29:51 <johnw> every programming environment has a runtime system, some of which support threading and have schedulers
12:30:19 <Algebr> What is C's runtime? The OS/Unix?
12:30:32 <johnw> it's in an object file called crt0.o
12:30:36 <johnw> "C Runtime"
12:30:45 <johnw> for C, it's really tiny
12:31:10 <johnw> mainly because, yes, the OS provides most of the services it needs
12:31:19 <Algebr> neato, thanks so much.
12:31:29 <johnw> systems like Java are the opposite, which have huge runtime systems because they provide a complete virtual environment abstracted away from the underlying OS
12:31:56 <Algebr> johnw: So even stuff like embedded systems have runtimes?
12:32:28 <johnw> yes
12:33:01 <johnw> runtimes are the interface between the user language and the core OS.  The only systems which do not have runtimes are so called "bare metal" environmets, where the runtime IS the OS
12:33:41 <RichardB> johnw, where would you put firmware in that ontology?
12:34:21 <johnw> perhaps I'd say that the firmware is the interface between the hardware architecture and whatever common abstraction the OS is expecting to talk to
12:34:33 <RichardB> Would you describe a firmware as a runtime for any application that might be run atop it, or as a program whose runtime happens to be implemented in hardware? :)
12:34:47 <johnw> haha
12:34:55 <Algebr> johnw: I think I read about that in C's spec, where C doesn't have to have a host environment.
12:34:55 <johnw> I guess it could be both, if you were running an application from firmware
12:35:22 <johnw> an article on "bare metal C": http://www.valvers.com/embedded-linux/raspberry-pi/step01-bare-metal-programming-in-cpt1
12:35:43 <johnw> Movitz is a bare metal Common Lisp, etc.
12:39:46 <geekosaur> firmware is the OS on a device
12:39:49 <RchrdBrrll> johnw, when you write a Movitz program, do you have to supply a GC yourself by some mechanism such as writing one in a non-GC'd subset of Common Lisp?
12:40:29 <RchrdBrrll> Oh, Movitz' run-time system already does that for you.
12:40:45 <johnw> yeah, they have a "Muerte" core, which apparently now has a GC
12:40:55 <johnw> which perhaps could then be called a runtime system!
12:41:18 <pjdelport> You'd say that Movitz has a runtime layer, but its runtime layer is on bare metal, instead of on a separate OS layer.
12:41:23 <johnw> right
12:43:47 <pjdelport> jonathan2: Do you have time to do a small experiment?
12:46:58 <jonathan2> pjdelport: Since hashset was using hashmaps for it's fromList, I went around hashSet and did fromList/toList with HashMap directly. Trying out both the strict and the lazy hashmap, I didn't get any difference
12:48:14 <pjdelport> jonathan2: try these two functions:
12:48:17 <pjdelport> test1 = H.fromList . map (\k -> (k,()))
12:48:17 <pjdelport> test2 = L.foldl' (\ m k -> H.insert k () m) H.empty
12:48:41 <pjdelport> against some representative input list of keys
12:48:55 <pjdelport> Can you see if there's any significant difference between them?
12:49:13 <pjdelport> Oh, and where L is Data.List, and H is Data.HashMap.Lazy
12:50:08 <pjdelport> jonathan2: Oh, and speaking of that, have you tried lazy bytestrings yet?
12:51:13 <pjdelport> jonathan2: That may reduce the number of allocations, depending, which may improve other things.
12:51:47 <jonathan2> pjdelport: I was using lazy bytestrings I believe
12:52:18 <pjdelport> jonathan2: Data.ByteString.Lazy? In that case, have you tried with strict bytestrings?
12:52:59 <pjdelport> jonathan2: What is the subwords function, by the way?
12:54:10 <jonathan2> pjdelport: using strict got really messy. I'm using the bytestrings as keys to the Trie-datastructure, that doesn't seem to accept strict byteStrings as keys. Also, I would need to change most integers to Int64 to get it to work :P A lot of work
12:54:39 <pjdelport> jonathan2: Oh, what Trie?
12:55:19 <jonathan2> pjdelport: "views" is the first of three layers of string manipulation basically. They do weird stuff
12:55:43 <jonathan2> pjdelport: http://hackage.haskell.org/package/bytestring-trie-0.1.4/docs/Data-Trie.html
12:56:27 * hackagebot polysoup 0.5.1 - Online XML parsing with polyparse and tagsoup  http://hackage.haskell.org/package/polysoup-0.5.1 (JakubWaszczuk)
12:57:49 <pjdelport> jonathan2: That trie looks like it takes strict bytestrings only
12:59:41 <jonathan2> pjdelport: could be me misinterpreting the errors, but it seemed like a very large project anyway. I gave up after ~15 minutes :P
13:00:11 <exfalso> hi, what is the right way of distributing precompiled cabal packages as opposed to always building them from source?
13:00:27 <pjdelport> jonathan2: Are you importing Data.ByteString.Lazy or Data.ByteString?
13:01:11 <jonathan2> pjdelport: Data.ByteString
13:01:20 <pjdelport> jonathan2: Okay, then it's strict, not lazy.
13:01:27 * hackagebot persistent-mongoDB 1.4.1 - Backend for the persistent library using mongoDB.  http://hackage.haskell.org/package/persistent-mongoDB-1.4.1 (GregWeber)
13:02:22 <pjdelport> jonathan2: Is subwords and so on using ByteString's builder monoid?
13:03:12 <pjdelport> jonathan2: You could probably define all of "views" using that, to make the generation part more efficient and allocation-friendly.
13:03:18 <jonathan2> pjdelport: They mostly do list-operations
13:04:01 <jonathan2> But the generation doesn't take that long anyway, it's still just the S.fromList that slows it down
13:04:03 <pjdelport> hmm, okay
13:04:52 <pjdelport> Right, but excess allocation while generating might be interfering with cache friendliness inside fromList. (I'm just guessing, though. :)
13:05:01 <jle`> you know i don't really seem to mind doing Num a => Ord a => a -> b -> c
13:05:12 <jle`> intsead of (Num a, Ord a) => a -> b -> c
13:05:36 <jonathan2> You see, everything else scales with the size of the problem. Looking at a problem instance of "size 1", addViews ~4%, size2 ~20%, size3 ~35% and so on.
13:06:06 <jonathan2> pjdelport: Unfortunately, I'll never have enough cache to make this cache-friendly :)
13:07:00 <monochrom> jle`: GHC accepts it already. here and now. :)
13:07:46 <jle`> monochrom: yeah, i found that out by accident
13:07:53 <jle`> i'm just saying i don't mind it as a style at all :)
13:07:55 <monochrom> \∩/
13:07:57 <pjdelport> jonathan2: How are you getting from this set to Trie keys?
13:08:02 <jle`> let's all swich to doing that instead ok
13:08:11 <doyouevenmath> why do :t () and :t (()) yield the same result?
13:08:24 <corgifex> because they're the same
13:08:32 <corgifex> :t 'x'
13:08:32 <lambdabot> Char
13:08:35 <corgifex> :t ('x')
13:08:35 <lambdabot> Char
13:08:42 <pjdelport> doyouevenmath: The inner () is a data constructor, the outer () is just grouping syntax
13:08:49 <doyouevenmath> Ahh so Tuple1[T] is identified with T
13:09:18 <monochrom> well, a benefit is in editing: adding and deleting "Ord a =>" is easier than changing the parentheses and the commas.
13:09:26 <pjdelport> doyouevenmath: There isn't really any Tuple1[T] in Haskell.
13:09:33 <Gurkenglas> :t ((,),)
13:09:34 <lambdabot> t -> (a -> b -> (a, b), t)
13:09:45 <pjdelport> doyouevenmath: ('x') is not a 1-tuple; it's just 'x'.
13:09:52 <doyouevenmath> ok I think I understand
13:10:23 <pjdelport> doyouevenmath: There's http://hackage.haskell.org/package/OneTuple if you *really* want 1-tuples :)
13:10:52 <benzrf> :t absurd
13:10:53 <lambdabot> Not in scope: ‘absurd’
13:10:54 <jle`> monochrom: agreed
13:10:56 <benzrf> dang
13:11:16 <doyouevenmath> thanks for the answers
13:11:23 <Gurkenglas> Why did the haskell devs do it that way? The only way to get 1-tuples seems to be deliberately making them, and in that case one should get them, right?
13:11:43 <corgifex> Gurkenglas: what's a 1-tuple?
13:11:57 <Gurkenglas> I'll tell you if you tell me what a 2-tuple is
13:12:04 <corgifex> a pair of two values
13:12:13 <monochrom> I seldom use 1-tuples. I don't miss them.
13:12:22 <Gurkenglas> pair is just a synonym for two-tuple
13:12:51 <corgifex> a product of two types
13:13:04 <monochrom> note: "newtype X = X Int" is not a 1-tuple. not if you mean it to be along the line of 2-tuples etc
13:13:08 <johnw> isn't a one-tuple just Identity?
13:13:12 <Gurkenglas> A 1-tuple is a product of one type, then
13:13:30 <corgifex> that doesn't make sense
13:13:33 <corgifex> * takes two args
13:13:46 <Gurkenglas> I meant capital Pi
13:13:48 <corgifex> what is the type of one hand clapping?
13:14:03 <atota_> floor
13:14:21 <monochrom> "data Y = Y Int" is a 1-tuple. it's also beginner-only code 99% of the time. the other 1% of the time it is for regaining laziness
13:14:21 <corgifex> bottom
13:14:46 <Gurkenglas> Product in the sense of the product in the category of types
13:14:50 <zwer> we have an empty tuple, so why not 1-tuple
13:15:10 <monochrom> I guess I'm agnostic
13:15:11 <corgifex> what makes () a tuple?
13:15:12 <Gurkenglas> Dangit zwer I was saving up that argument for bad times
13:15:21 <rrradical> if I have an ADT, is there an efficient way to store a collection of them such that I can retrieve all of those that have the same constructor? like storing Maybe Int values and pulling out all the Just Int values.
13:15:23 <Gurkenglas> corgifex, () is the empty product of types
13:15:30 <johnw> let's make negative tuples, and then call it a day
13:15:34 <corgifex> Gurkenglas: how so?
13:15:50 <jle`> monochrom: do you think I am allowed to start writing that way and call it idiomatic code
13:15:58 <monochrom> is a->() the type of -1-tuples? :)
13:16:14 <rrradical> I was thinking if I could associate a unique value to each constructor then I could use a HashMap and store each constructor in its own list
13:16:17 <corgifex> is not () half a Bool?
13:16:21 <Gurkenglas> corgifex, capital sigma denotes a sum over a set
13:16:29 <corgifex> I don't believe in sets
13:16:32 <monochrom> I don't know. what counts as idiomatic? if few other people do it, perhaps it doesn't count as idiomatic. for now.
13:16:53 <Gurkenglas> Umm?
13:17:04 <jle`> i have to be the change i want to see
13:17:58 <Gurkenglas> Negative tuples? You can't have a set with -1 element, so you're getting your notion of tuples elsewhere. Can you explain?
13:18:21 <monochrom> you cannot logically consistently do both "want to be the change" and "worry whether it's idiomatic" at the same time. you have to give one up and commit to the other.
13:18:37 <Gurkenglas> corgifex, you're gonna have to explain that "don't believe in sets" thing
13:18:37 <jle`> i commit to changing the world
13:18:47 <monochrom> ok, then just do it
13:18:53 <jle`> :D
13:19:08 <monochrom> I chose the "worry about idiomatic" road
13:19:16 <doyouevenmath> Gurkenglas: maybe a similar construction akin to the grothendieck group is possible to make sense of negative tuples?
13:19:21 <jonathan2> pjdelport: I'm not sure what the problem is there really, but I don't seem to get it working with other bytestrings :/
13:20:45 <pjdelport> jonathan2: You have to explicitly convert between lazy and strict bytestrings; they're essentially just two different types.
13:20:46 <Gurkenglas> doyouevenmath, my knowledge of the grothendieck group is in the "could probably reconstruct the definition" area. How would you use it to reduce the size of a tuple?
13:23:23 <doyouevenmath> Gurkenglas: define the types in an algebraic manner. I do not see how one could define them as sets
13:23:55 <Gurkenglas_> I didn't mean to define types as sets, I was talking about sets of types
13:24:37 <Gurkenglas_> The product takes a set of types and returns a type, namely a (cardinality of the set)-tuple
13:25:18 <doyouevenmath> Well you could do something like Tuple-2[A,B] * Tuple2[A,B] = ()
13:25:35 <doyouevenmath> The question is how to handle incompatible types
13:25:53 <doyouevenmath> (you would write Tuple1[A] * Tuple2[B,C] = Tuple3[A,B,C] e.g.)
13:26:48 <doyouevenmath> However, I do not see this definition to behave well and be of use
13:27:55 <c_wraith> doyouevenmath: are you familiar with the algebraic representation of algebraic data types?
13:28:15 <Gurkenglas__> (Oh wait actually it takes a family of types, not a set.)
13:28:45 <doyouevenmath> like writing a List[T] as Nil + T * List[T]?
13:28:49 <doyouevenmath> I am a starter there...
13:29:01 <doyouevenmath> studied cs and math but never really touched fp and relevant theories
13:29:08 <doyouevenmath> I know category theory from algebraic geometry and toplogy :)
13:29:23 <c_wraith> doyouevenmath: https://chris-taylor.github.io/blog/2013/02/10/the-algebra-of-algebraic-data-types/
13:29:27 <doyouevenmath> thx
13:29:32 <Gurkenglas> thx
13:34:08 <notthemessiah> Any libraries or types for unrooted binary trees? http://en.wikipedia.org/wiki/Unrooted_binary_tree
13:34:34 <shapr> tromp_: Do you have a twitter account?
13:35:49 <sveit> is there a way, in ghci, to load a lib with -lTESTLIB?
13:36:07 <sveit> i have tried doing :set -lTESTLIB (should work according to http://www.haskell.org/ghc/docs/7.8.2/html/users_guide/ghci-set.html but doesn't for me)
13:38:39 <Gurkenglas> c_wraith, there ought to be a way to see that that was basic stuff that I know without me having to know the "algebraic representation of algebraic data types" word. (Also the author of that page forgot to say that by (a,b), he means Mul a b.)
13:39:05 <c_wraith> Gurkenglas: he says that pretty explicitly
13:39:21 <Gurkenglas> Whoops, you're right.
13:39:42 <Gurkenglas> (Ah, but he doesn't stick with Mul! >:D)
13:43:21 <enthropy> sveit: it says "-l in particular) will also work, but some may not take effect until the next reload"
13:43:31 <enthropy> so did you :r after :set -lTESTLIB
13:43:52 <enthropy> probably it's easier to just pass that flag in when you start ghci
13:45:31 <sveit> enthropy: i did, it doesn't work
13:46:06 <enthropy> and it works if you pass -lTESTLIB when start ghci?
13:46:28 <exfalso> what is the right way of distributing precompiled cabal packages as opposed to always building them from source?
13:49:39 <sveit> enthropy: yep
13:56:31 * hackagebot jammittools 0.2.0.1 - Export sheet music and audio from Windows/Mac app Jammit  http://hackage.haskell.org/package/jammittools-0.2.0.1 (mtolly)
13:56:39 <vaz> hello
13:56:45 <ninja_code> I suspect the answer is "no", but I want to double check. Is it possible to create a top level definition of type "MVar Int", or can I only create top level defs of the form BLAH -> BLAH -> DOG -> IO (MVar Int) ?
13:57:09 <gregnwosu> whats the difference between sequence and traverse?
13:57:23 <hpc> :t sequence
13:57:25 <lambdabot> Monad m => [m a] -> m [a]
13:57:26 <hpc> :t traverse
13:57:27 <lambdabot> (Traversable t, Applicative f) => (a -> f b) -> t a -> f (t b)
13:57:47 <monochrom> ninja_code: it is impossible, unless you use unsafePerformIO
13:57:53 <pchiusano> i'm looking for a web framework in haskell to write a super simple REST+JSON api over HTTP
13:57:54 <simukis_> ninja_code: topLevel = unsafePerformIO $ (create your MVar) {-# NOINLINE topLevel #-}
13:58:07 <ninja_code> monochrom , simukis_ : understood, thanks!
13:58:32 <pchiusano> conduit and snap seem overly heavyweight for my purposes
13:58:34 <gregnwosu> therefore is sequence a traverse on lists?
13:58:36 <pchiusano> any suggestions
13:58:39 <gregnwosu> is that all it is?
13:58:42 <pchiusano> sorry, yesod and snap
13:58:42 <monochrom> under suitable circumstances it is a reasonable use of unsafePerformIO.
13:58:52 <johnw> pchiusano: try scotty
13:59:05 <johnw> pchiusano: it is much lighter weight
13:59:25 <johnw> pchiusano: see https://github.com/jwiegley/cgroups/blob/master/CGroups.hs for an example of a REST+JSON service using scotty
13:59:57 <gregnwosu> on id
14:00:50 <pchiusano> johnw: looks reasonable, although it depends on conduit
14:01:07 <gregnwosu> ah its slightly different , albiet similar
14:01:09 <gregnwosu> thanks all
14:01:15 <johnw> pchiusano: that was just an example, you don't need that
14:01:25 <johnw> if you want very cheap streaming I/O, see my simple-conduit library on Hackage
14:03:03 <pchiusano> johnw: thanks
14:10:12 <ticktockman> Has anyone been able to get bullet working without getting linking errors?
14:10:31 <ninja_code> https://gist.github.com/anonymous/aeddd33c5458c4caf6d4 <-- without use of lens + template haskell, is there a way to shorten these defs?
14:11:32 * hackagebot hlint 1.9 - Source code suggestions  http://hackage.haskell.org/package/hlint-1.9 (NeilMitchell)
14:14:32 <sveit> is there some verdict or opinion on cabal repl vs cabal-dev vs ghci?
14:16:27 <tolt> I could be very wrong but cabal sandbox has the same purpose as cabal-dev and cabal repl just loads a specific cabal project
14:16:56 <jle`> gregnwosu: traverse is more like mapM
14:17:05 <jle`> gregnwosu: mapM f = sequence . map f
14:17:09 <joelteon> tolt: that's correct, except that cabal sandbox is built in to cabal
14:17:13 <jle`> :t mapM
14:17:14 <lambdabot> Monad m => (a -> m b) -> [a] -> m [b]
14:17:15 <jle`> :t F.mapM
14:17:16 <lambdabot>     Not in scope: ‘F.mapM’
14:17:16 <lambdabot>     Perhaps you meant one of these:
14:17:16 <lambdabot>       ‘T.mapM’ (imported from Data.Traversable),
14:17:20 <jle`> :t T.mapM
14:17:21 <lambdabot> (Traversable t, Monad m) => (a -> m b) -> t a -> m (t b)
14:17:25 <jle`> :t traverse
14:17:25 <lambdabot> (Traversable t, Applicative f) => (a -> f b) -> t a -> f (t b)
14:17:39 <tolt> Yeah.
14:17:48 <joelteon> tolt: also, I don't think cabal-dev allows you to add other local dependencies
14:17:51 <joelteon> it might
14:18:27 <tolt> joelteon: I didn't use it much but I think you can have local sandboxes
14:19:07 <tolt> I mean local as in in a different location. That might not work the way sources work with cabal sandbox
14:19:16 <tolt> but I've been enjoying cabal sandboxes a bit.
14:22:39 <tulcod> tolt: i think cabal essentially has all the stuff you should need from cabal-dev
14:22:48 <tulcod> or it's supposed to, i think
14:22:56 <tolt> Yeah. It does now.
14:23:19 <tolt> I wouldn't be able to work without cabal sandboxes.
14:24:42 <ninja_code> is there a way to define MyIO, where MyIO is basically like IO ... except, there's a global State involved? i.e. MyIO, informally = IO + State
14:25:25 <tulcod> ninja_code: are you looking for monad transformers?
14:25:36 <ninja_code> tulcod: I have no clue
14:25:46 <monochrom> perhaps s -> IO (a, s)
14:25:47 <pjdelport> ninja_code: Do you want IO in addition to global state, or your own more limited MyIO that isn't unrestricted IO?
14:25:51 <ajcoppa> you are very likely looking for monad transformers :)
14:26:01 <ninja_code> I want unrestricted IO + a global state
14:26:09 <ninja_code> I don't want to pass this global variable around all the time
14:26:36 <yaymukund> ok this is probably a dumb question, but how does this solution to problem_12 count factors of a number? http://www.haskell.org/haskellwiki/Euler_problems/11_to_20#Problem_12
14:26:58 <yaymukund> I don't understand this group +1 length business. is there some basic math that I'm overlooking?
14:26:58 <moghedrin> ninja_code: Look into the State transformer monad.
14:27:05 <moghedrin> *monad transformer
14:28:15 <jle`> yaymukund: it just looks like a math property
14:28:36 <tulcod> yaymukund: 1 is a divisor of many numbers
14:29:00 <tulcod> yaymukund: and "group" sorts out uniqueness
14:29:12 <pjdelport> ninja_code: Have you looked at http://www.haskell.org/haskellwiki/Top_level_mutable_state ?
14:29:54 <tolt> Does anyone have a good way of dealiing with overloaded instances? http://lpaste.net/106671
14:32:14 <tolt> Sorry overlapping instances
14:32:40 <ninja_code> hmm, so reading http://www.haskell.org/haskellwiki/Top_level_mutable_state
14:32:56 <ninja_code> it soudns like no one has a good solution to this problem
14:33:15 <hpc> the good solution is don't use top-level mutable state
14:34:10 <johnw> or define MyIO as StateT s IO, and then use MyIO everywhere in your program
14:34:24 <johnw> as moghedrin suggested
14:34:49 <tulcod> ninja_code: don't underestimate the value of hpc's comment. you shouldn't be needing a top level state. if you desperately want one, then you are already hacking stuff together anyway, so you shouldn't expect to find a pretty solution to do so
14:35:30 <johnw> though, I often need a MyIO-like solution in order to make command-line option settings universally available throughout the IO parts of my program
14:35:41 <pjdelport> ninja_code: What problem are you solving?
14:36:38 <tulcod> johnw: hm, isn't that something you could do with a pretty "parse the command line" function?
14:36:58 <johnw> yes, but once I've parsed it, what do I do
14:36:59 <johnw> ?
14:37:08 <johnw> I now have an Options value, and lots of places where I want to query it
14:37:20 <johnw> so, not StateT, but ReaderT Options is what I use
14:37:27 <tulcod> johnw: so what you want is a cache, not a state
14:37:31 <pjdelport> johnw: Decompose it?
14:37:42 <johnw> Decompose?
14:38:53 <pjdelport> johnw: Can you decompose the Options into smaller sets of data?
14:39:09 <johnw> that doesn't help me with ferrying those bits of data down to the parts of my program which need it, though
14:39:32 <pjdelport> It does, if it leads to ferrying less data around.
14:39:56 <johnw> decomposing it leads to ferrying even more arguments everywhere
14:40:17 <tulcod> johnw: is there a problem with calling the parsing function every time you need it?
14:40:31 <johnw> but how would that parsing function have access to the data *it* needs?
14:40:39 <yaymukund> jle`, tulcod: you are both right. Seems to be a math thing that I didn't know-- http://math.stackexchange.com/a/295468
14:40:44 <yaymukund> thanks!
14:40:48 <tulcod> johnw: well if your function depends on IO it depends on IO
14:40:54 <johnw> ah, I see
14:40:56 <pjdelport> In other words, instead of a big Options structure, extract it into smaller things like flags early, and have your program work with those.
14:40:59 <johnw> use the filesystem as an external cache
14:41:09 <tulcod> johnw: the filesystem?
14:41:25 <johnw> how else will IO get the command-line arguments, without a Reader to pass them all the way down throughout the program?
14:41:37 <pjdelport> johnw: It depends on how they need it, but how many things that currently take Options can you replace with something that just takes generic parameters (which may or may not come from Options)?
14:42:02 <tulcod> johnw: System.Environment.getArgs ?
14:42:03 <johnw> the idea is to avoid the multiplication of parameters everywhere, which none of the intervening functions need in any way
14:42:18 <pjdelport> johnw: What's example of the kind of parameter you're working with?
14:42:20 <tulcod> johnw: i'm sorry, i feel i am missing something.
14:42:28 <johnw> yeah, I feel like we're strangely dancing around an issue here
14:42:40 <johnw> this isn't really all that important, carry on
14:42:46 <pjdelport> Pasting some code is a good way to make the discussion concrete. :)
14:42:58 <johnw> pjdelport: https://github.com/jwiegley/pushme/blob/master/Main.hs is where I used this paradigm the most recently
14:43:05 <tulcod> well it isn't - but you say you need some monad which i would guess doesn't need to be involved
14:43:10 <johnw> notice the App data type
14:43:22 <johnw> it allows my Options to be accessible throughout the program
14:43:50 <johnw> so that, for example, 'execute' can refer to the options, without every single user of execute having to pass them through as arguments
14:43:52 <monochrom> johnw: this option is viable: while you have a global IORef to store the data, draw an interface boundary so that the parser part sees write-only, and the other parts see read-only
14:44:13 <johnw> monochrom: sort of like a safer version of the io-storage library?
14:44:25 <monochrom> I don't know io-storage. I guess so.
14:44:51 <johnw> it uses IORefs behind-the-scenes to fake mutable globals in IO
14:45:05 <tulcod> johnw: okay, let me first say that this is indeed not an important issue. but I think you are just hiding the fact that you *are* passing these arguments around using your "magic" App monad
14:45:06 <johnw> but I prefer ReaderT
14:45:17 <johnw> tulcod: yes, I am
14:45:23 <johnw> tulcod: what was the original issue again?
14:45:36 <tulcod> why you needed Reader to pass IO input around
14:45:45 <monochrom> ReaderT is of course very good
14:46:01 <johnw> I'm using ReaderT to avoid passing a literal argument around everywhere; if you're fine with doing that, then I'm not saying you have to use ReaderT
14:46:18 <tulcod> okay :)
14:46:30 <johnw> I'm just saying that I do like using it, and that maybe it was answer to ninja_code's question
14:47:18 <tulcod> yeah ok I guess it saves you from having to type "opts". but IMO you might as well make everything IO instead and parse the options in each execution, possibly with caching (?)
14:47:37 <tulcod> anyway yeah i get your viewpoint
14:48:07 <johnw> I wonder if getArgs allows you to executse it multiple times though...
14:48:12 <johnw> since you mention that
14:48:21 <pjdelport> johnw: Cool. An example of the kind of decomposition I mean is that instead of say having the verbose flag in opts all over the place, you can use something like a writer or similar to handle your logging.
14:48:33 <johnw> ah
14:48:49 <johnw> you mean, move the filtering out of the producer, and to the consumer
14:48:50 <pjdelport> johnw: And then, at the top level, run the code with an appropriately verbose or non-verbose writer
14:48:50 <TheSpirit> why has nobody defined the IO comonad yet
14:48:52 <johnw> I can certainly appreciate that
14:49:08 <johnw> the IO Comonad can't exist
14:49:11 <johnw> what would extract do?
14:49:13 <TheSpirit> why not?
14:49:21 <johnw> extract :: IO a -> a
14:49:34 <pjdelport> johnw: Yeah; basically, the guiding principle is that only the code that *needs* to touch a certain option should have access to it, and stuff shouldn't have to be relayed without good reason.
14:49:47 <johnw> pjdelport: OK, I see your point
14:49:50 <johnw> and nicely made it is
14:50:05 <pjdelport> johnw: So if you can extract or decompose some part of the program out, you can entirely avoid having to pass any "global" state through it.
14:50:16 <johnw> right
14:50:42 <pjdelport> Ideally, your top level entry point should just be instantiating / configuring / wiring things together based on the command-line flags
14:51:08 <johnw> gotta go now, but thanks for the discussion
14:51:32 <phaazon> yeah!
14:51:34 <phaazon> http://lpaste.net/106672
14:51:35 <phaazon> finally!
14:51:45 <phaazon> I have my AST with name binding working
14:51:57 <phaazon> now, I need to use generalized de Bruijn indices
14:52:04 <phaazon> that maybe stuff is annoying
14:54:43 <tulcod> phaazon: apologies for being an ignorant twat, but what is this? template haskell reinvented?
14:55:01 <tulcod> phaazon: or some basis for a DSL?
14:56:03 <paulloz> hey peeps, i need a little help to understand these things : =<< >>=
14:56:16 <phaazon> tulcod: it’s an AST with name-binding
14:56:23 <phaazon> I’m learning the basis to understand bound
14:56:33 <phaazon> in order to use AST to represent 3D scenes
14:56:39 <phaazon> and actually any other of logic
14:56:46 <phaazon> I find that way of doing really handy!
14:57:02 <ij> paulloz, What do you need them for?
14:57:10 <tulcod> phaazon: you're using an abstract syntax tree to represent 3D graphics?
14:57:50 <paulloz> ij: nah, i'm reading some code where there's those operators
14:58:43 <phaazon> tulcod: yes
14:58:45 <phaazon> I plan to
14:58:49 <quchen_> paulloz: (>>=) is a standard Monad operator, I suggest you read up on those a bit for some overview.
15:00:06 <paulloz> as i understand it, foo =<< bar x y
15:00:24 <paulloz> will pass the value produced by `bar x y` to foo
15:00:32 <tulcod> paulloz: http://pastebin.com/4GpmreBj
15:01:05 <tulcod> paulloz: interpreted as in the IO monad, it "runs" the first argument and passes the result into the second
15:02:00 <monochrom> I recommend my IO tutorial: http://www.vex.net/~trebla/haskell/IO.xhtml
15:02:07 <pdxleif> What html templating do people use?
15:02:17 <pdxleif> Would something like this be usable? https://gist.github.com/LeifW/be637fd9019e86cdd636
15:02:27 <tulcod> paulloz: e.g. try getline >>= putStrLn
15:02:29 * hackagebot jammittools 0.2.0.1 - Export sheet music and audio from Windows/Mac app Jammit  http://hackage.haskell.org/package/jammittools-0.2.0.1 (mtolly)
15:02:29 * hackagebot hlint 1.9 - Source code suggestions  http://hackage.haskell.org/package/hlint-1.9 (NeilMitchell)
15:02:30 <tulcod> :t getline >>= putStrLn
15:02:31 <lambdabot>     Not in scope: ‘getline’
15:02:31 <lambdabot>     Perhaps you meant one of these:
15:02:31 <lambdabot>       ‘getLine’ (imported from Prelude),
15:02:36 <tulcod> :t getLine >>= putStrLn
15:02:37 <lambdabot> IO ()
15:02:46 <johnw> tulcod: I think io-memozie could be used to write a getOptions function in IO that only does the work of parsing the options once
15:03:15 <monochrom> oh, the "memoize" in "io-memoize" sounds right :)
15:03:18 <tulcod> johnw: yeah, i'm sure there's a fancy solution to store it in the IO monad - or maybe you can even instruct the compiler directly?
15:04:31 <monochrom> write-once read-many is the root cause of all religious wars between mutable and immutable :)
15:05:08 <hpc> i much prefer write-once read-in-between
15:05:12 <hpc> er, write-twice
15:05:46 <paulloz> okay
15:05:54 <paulloz> i'm understanding this a bit more!
15:05:55 <tulcod> see also: writeonly memory
15:06:44 <tulcod> paulloz: that's sort of how category theory (on which haskell is arguably based) works - you understand it a bit better every day
15:07:57 <monochrom> a write-once read-many API dissolves the wars, and therefore, as religious wars go, it the common enemy of all sides of the wars :)
15:08:10 <quchen> Haskell is based on category theory as much as adding is.
15:15:46 <ij> Haskell gives an xread function that's ArrowXML, which is a class dependent on Arrow(|List|Tree). Since it's a subclass of Arrow, shouldn't I be able to apply it? I can apply other arrows, why couldn't I apply this one?
15:15:50 <ij> :t arr (+1) 3
15:15:51 <lambdabot> Num c => c
15:15:58 <ij> > arr (+1) 3
15:16:00 <lambdabot>  4
15:17:26 * hackagebot deiko-config 0.5.0.0 - Small and typesafe configuration library.  http://hackage.haskell.org/package/deiko-config-0.5.0.0 (YorickLaupa)
15:22:26 * hackagebot hint-server 1.3.2 - A server process that runs hint.  http://hackage.haskell.org/package/hint-server-1.3.2 (CorentinDupont)
15:26:16 <identity> Does anyone else think c++11 type traits, static asserts and enum classes remind them of Haskell?
15:26:26 <identity> Haskell typeclasses in particular.
15:26:28 <identity> and ADTs
15:26:31 <identity> sortof.
15:28:19 <pjdelport> identity: "Any sufficiently advanced programming language is indistinguishable from FP"?
15:28:45 <identity> heh
15:29:01 <RchrdBrrll> identity, I've seen traits described as being largely inspired by type classes.
15:29:28 <identity> mm
15:29:46 <identity> static asserts are just a way to force the type system to complain about it as well
15:31:43 <Zekka> Aren't there a lot of Haskell programmers on the C++ standards board?
15:31:53 <Zekka> I've heard that as a rumor but haven't confirmed it
15:32:57 <identity> We are slowly but surely infiltrating all the world's major organizations, biding our time to finally assert our dominance over other inferior programming languages and humanity in general.
15:35:16 <zzzzzzzziiii> can i transform a -> b -> c -> d to b -> c -> d?
15:35:46 <jmcarthur_mobile> Sure. Apply it to an a.
15:36:11 <zzzzzzzziiii> and the other way around?
15:36:19 <Zekka> zzzzzzzziiii: Feed it to const
15:36:21 <Zekka> :t const
15:36:23 <lambdabot> a -> b -> a
15:36:29 <Zekka> :t const (undefined :: b -> c -> d)
15:36:30 <lambdabot> b -> b1 -> c -> d
15:36:42 <Zekka> actually, hold up
15:36:44 <Zekka> I mean flip const
15:36:48 <sipa> he's asking for the other way around
15:37:05 <sipa> which just needs applying an a value
15:37:07 <Zekka> jmcarthur already gave him the first way around
15:37:15 <pavonia> @djinn (b -> c -> d) -> (a -> b -> c -> d)
15:37:15 <lambdabot> f a _ b c = a b c
15:37:27 * hackagebot gitit 0.10.4 - Wiki using happstack, git or darcs, and pandoc.  http://hackage.haskell.org/package/gitit-0.10.4 (JohnMacFarlane)
15:39:30 <solidus-1iver> rec is the devils work
15:40:36 <Rufflewind_> is there a way to add more suffixes to knownSuffixHandlers in cabal without hacking cabal?
15:42:23 <identity> @djinn (a -> b -> c -> d) -> (b -> c -> d)
15:42:23 <lambdabot> -- f cannot be realized.
15:42:26 <identity> ah.
15:43:57 <Zekka> > ($ undefined) :: (a -> b -> c -> d) -> (b -> c -> d)
15:43:58 <lambdabot>  No instance for (Data.Typeable.Internal.Typeable d0)
15:43:58 <lambdabot>    arising from a use of ‘M3153777720512867667497.show_M3153777720512867667497’
15:43:58 <lambdabot>  The type variable ‘d0’ is ambiguous
15:43:58 <lambdabot>  Note: there are several potential instances:
15:43:58 <lambdabot>    instance Data.Typeable.Internal.Typeable Data.Dynamic.Dynamic
15:44:23 <Zekka> > let questionable = ($ undefined) :: (a -> b -> c -> d) -> (b -> c -> d)
15:44:24 <lambdabot>  not an expression: ‘let questionable = ($ undefined) :: (a -> b -> c -> d) -...
15:44:26 <Zekka> @let questionable = ($ undefined) :: (a -> b -> c -> d) -> (b -> c -> d)
15:44:29 <lambdabot>  Defined.
15:44:45 <Zekka> > questionable (\_ x y z -> x ++ y ++ z) "x" "y" "z"
15:44:47 <lambdabot>  "xyz"
15:51:49 <solidus-1iver> can you use rec with more than 2 functions
15:51:59 <solidus-1iver> or is it always set to 2 dependent functions
15:52:12 <solidus-1iver> i have a situation where
15:52:38 <Zekka> :t rec
15:52:39 <lambdabot>     Not in scope: ‘rec’
15:52:39 <lambdabot>     Perhaps you meant one of these:
15:52:39 <lambdabot>       ‘rem’ (imported from Prelude), ‘re’ (imported from Control.Lens)
15:52:55 <RchrdBrrll> solidus-1iver, 'rec' as in 'let rec'? Are you sure you're writing Haskell and not ML?
15:53:00 <rwbarton> what is "rec"?
15:53:18 <solidus-1iver> (a, b') -> a1
15:53:24 <Zekka> http://stackoverflow.com/questions/5405850/how-does-the-haskell-rec-keyword-work <- I've never seen this before
15:53:26 <solidus-1iver> er
15:53:44 <solidus-1iver> damn, let me lpaste it formally
15:53:50 <solidus-1iver> but yeha, i'm talking about the rec keyworld
15:53:51 <RchrdBrrll> Ah, it's in arrow notation.
15:53:55 <solidus-1iver> *keyword
15:54:13 <lampe2> hey i dont understand the concept of "lifting" can someone maybe link me to a good resource ?
15:54:22 <ij> Why can't I apply something that is of ArrowXml class from hxt?
15:58:40 <solidus-1iver> http://lpaste.net/106676
15:58:45 <solidus-1iver> i'm wondering if thats possible
15:58:55 <solidus-1iver> looking at rec though it seems like it is limited to two functions
15:59:03 <RchrdBrrll> rec or loop?
15:59:04 <solidus-1iver> so i guess i'd have to wrap f1 and f2 into an f4
15:59:28 <rwbarton> I'm pretty sure you can have more than two lines in the rec
15:59:33 <solidus-1iver> well, its in a loop but it has circular deps
15:59:46 <RchrdBrrll> All of the bits of arrow notation that I'm familiar with have desugarings that work for arbitrarily many values, even though the combinators only allow pairs, by nesting.
16:00:07 <solidus-1iver> RchrdBrrll: so will i have to explicitly rec in my rec
16:00:11 <RchrdBrrll> so I'd be -really- surprised if the arrow notation didn't allow three mutual rcs.
16:00:11 <solidus-1iver> or just write rec and have at it
16:00:26 <RchrdBrrll> No, it should be able to just desugar it for you into something reasonable
16:00:31 <solidus-1iver> also, as a side note, thats pretty badass
16:00:38 <solidus-1iver> is something like that remotely performant?
16:01:30 <RchrdBrrll> Check with -ddump-simpl (compiler flag for GHC) or ghc-core (program on Hackage which renders the GHC core in a relatively-readable way) if you're really worried.
16:02:18 <RchrdBrrll> If GHC's simplifier and inliner manage to flatten it all out then there's no reason why it couldn't be.
16:04:57 <solidus-1iver> thats just really cool though
16:05:09 <solidus-1iver> that saves a ton of temporary state management with a map and multiple iterations
16:05:24 <solidus-1iver> excited to try it out
16:14:59 <zzzzzzzziiii> http://lpaste.net/8283721539967254528 -- i am playing with tries and i am lost with the foldrWithKey implementation can someone give me a hint or two?
16:18:07 <edwardk> zzzzzzzziiii: type instance Key Trie = String
16:20:35 <edwardk> you want to do something like recursively foldMapWithKey and pass the function (f . (k:)) to out as you get each key k out instead of just passing f
16:20:47 <edwardk> er to it
16:23:27 <zzzzzzzziiii> ok thank you i'll try it
16:32:16 <ksf> http://homepages.cwi.nl/~ploeg/papers/zseq.pdf
16:32:20 <ksf> (warning: oleg paper)
16:32:34 <ksf> concerning monads that are moar faster.
16:34:48 <Luke_> i'm using cabal test to run unit tests. some tests are failing but 'cabal test' still is saying all the test suites pass. do I have to propagate some code or something?
16:35:19 <Clint> Luke_: what frameworks are you using?
16:35:28 <Luke_> HUnit
16:35:45 <Clint> you might want to put tasty, hspec, or test-framework on top of that
16:35:47 <Luke_> do I need to return nonzero or something?
16:46:13 <pjdelport> lampe2: There are a number of concepts that are sometimes called "lifting". What context did you hear it in?
16:47:29 <lampe2> pjdelport: iam reading about lifting operations in functional reactive programming
16:48:23 <pjdelport> lampe2: Ah, okay. Lifting in that context is very similar / related to lifting with functors and monads.
16:48:24 <Zekka> :t liftA
16:48:25 <lambdabot> Applicative f => (a -> b) -> f a -> f b
16:48:36 <Zekka> Is that what they're referring to?
16:48:39 <pjdelport> :t fmap
16:48:40 <lambdabot> Functor f => (a -> b) -> f a -> f b
16:49:03 <lampe2> pjdelport: okay
16:49:15 <lampe2> iam reading this paper http://soft.vub.ac.be/Publications/2012/vub-soft-tr-12-13.pdf
16:49:26 <lampe2> and section 3.4 is lifting operations
16:49:37 <pjdelport> :t fmap (+)
16:49:38 <lambdabot> (Num a, Functor f) => f a -> f (a -> a)
16:49:41 <pjdelport> :t liftA (+)
16:49:42 <lambdabot> (Applicative f, Num a) => f a -> f (a -> a)
16:49:46 <pjdelport> :t liftM (+)
16:49:47 <lambdabot> (Num a1, Monad m) => m a1 -> m (a1 -> a1)
16:50:02 <pjdelport> err, bad example, actually
16:50:10 <pjdelport> :t liftA2 (+)
16:50:11 <lambdabot> (Applicative f, Num c) => f c -> f c -> f c
16:50:16 <pjdelport> :t liftM2 (+)
16:50:17 <lambdabot> (Num r, Monad m) => m r -> m r -> m r
16:50:29 <lampe2> hmm
16:50:50 <pjdelport> lampe2: Those are the "lifted" versions of (+), to Applicative / Monad
16:51:34 <pjdelport> > let <+> = liftA2 (+) in [1,2,3] <+> [4,5,6]
16:51:36 <lambdabot>  <hint>:1:5: parse error on input ‘<+>’
16:51:43 <pjdelport> > let (<+>) = liftA2 (+) in [1,2,3] <+> [4,5,6]
16:51:45 <lambdabot>  [5,6,7,6,7,8,7,8,9]
16:52:12 <Zekka> This might be easier to read:
16:52:30 <Zekka> > let (<++>) = liftA2 (++) in ["a", "b", "c"] <++> ["A", "B", "C"]
16:52:31 <lambdabot>  ["aA","aB","aC","bA","bB","bC","cA","cB","cC"]
16:52:41 <Zekka> that might clarify how the applicative instance for list works a bit
16:53:06 <pjdelport> lampe2: So in the abstract, lifting is the process of taking a plain function on direct values, and lifting it into some other, more specialized domain, perhaps with fancier semantics.
16:53:25 <lampe2> okay
16:53:33 <Zekka> Well, it's a little more general than that actually
16:53:35 <Zekka> :t lift
16:53:36 <lambdabot> (MonadTrans t, Monad m) => m a -> t m a
16:53:56 <pjdelport> Right, right; that's another instance of it.
16:54:04 <Zekka> 'm a' is hardly a 'plain function on direct values', is it? But we use it  to change the output of the computation in one monad into a transformed version of that monad
16:54:07 <lampe2> let me think about that
16:54:12 <Zekka> into a computation in the transformed version*
16:54:50 <pjdelport> lampe2: In FRP, the basic idea is similar: you're taking a plain function like (+), and lifting it to operate on Behaviors
16:55:00 <lampe2> is lambda lifting the same thing ?
16:55:06 <pjdelport> No, that's unrelated.
16:55:13 <pjdelport> It's a compilation technique
16:55:17 <lampe2> okay
16:55:59 <lampe2> so lifting in this case means to take a operator like + and make it work with behaviors ?
16:56:42 <pjdelport> Right
16:59:37 <pjdelport> Given for example length :: [a] -> Int, you might have: liftB length :: Behavior [a] -> Behavior Int
16:59:57 <pjdelport> (assuming "liftB" is your lifting operator for Behaviors)
17:01:06 <pjdelport> :t fmap length
17:01:07 <lambdabot> Functor f => f [a] -> f Int
17:01:07 <lampe2> okay right now it looks to me like typecasting
17:01:38 <pjdelport> If your Behaviors declare a Functor instance, then fmap is your lifting operator.
17:01:39 <Luke_> Clint: good call on Tasty. Looks awesome
17:01:53 <Zekka> More than likely they're at least Applicative, though
17:02:00 <Zekka> given that you can't define liftA2 and so on without it
17:02:03 <Zekka> :t liftA2
17:02:04 <lambdabot> Applicative f => (a -> b -> c) -> f a -> f b -> f c
17:02:30 <pjdelport> lampe2: You can kind of think of it as type conversion, yes, but only really in the sense that all functions are some kind of type conversion. :)
17:03:11 <pjdelport> lampe2: The power of lifting is that it lets you take *any* function, and turn it into the corresponding function in the domain of Behaviors.
17:03:21 <pjdelport> Without having to write a special version for Behaviors.
17:03:36 <Zekka> So basically, FRP lets you treat Behaviors for the most part like ordinary values
17:03:45 <Zekka> and all the weird gluecode and stuff is handled by the library separately
17:03:45 <lampe2> okay
17:03:58 <Zekka> so the library's just defining a scheme for you to wire things together with
17:04:14 <lampe2> i think i get it
17:05:07 <Zekka> More usefully, it describes a scheme to wire things together with that already looks reasonably close to the scheme Haskell uses
17:05:39 <Zekka> and lifting is just how you convert Haskell-style wiring to FRP-style wiring
17:05:44 <lampe2> i have to write about it in a more general way
17:06:01 <Zekka> Lifting is about how  you convert x-style z to y-style z?
17:06:30 <lampe2> x-style z ?
17:06:40 <AfC> In order to build GHC 7.8, what is the minimum version of GHC you need installed to bootstraap?
17:07:18 <platz> my understanding is that no-one agrees on what FRP means anymore
17:07:23 <Zekka> lampe2: In this case, x=Haskell z=operations, y=FRP
17:07:41 <lampe2> ahh okay
17:07:42 <rwbarton> AfC: I think it might be 7.4, not sure though.
17:07:44 <bollu> I'm running into type errors while parsing JSON. Help? http://pastebin.com/2MnnTdmZ
17:07:49 <platz> essentially the creators of the term lost control of it's meaning and it's broadened as others have co-opted it
17:07:50 <Zekka> But you could also describe the monad transformer version with x=untransformed y=transformed z=computations
17:07:53 <Zekka> :t lift
17:07:53 <lambdabot> (MonadTrans t, Monad m) => m a -> t m a
17:07:58 <Zekka> (that is, this function)
17:08:59 <Zekka> lampe2: It's not by coincidence that this sounds like a typesig!
17:09:06 <Zekka> liftingInGeneral :: x z -> y z
17:09:06 <bollu> I think my imports are wrong or something, but I don't know how to resolve this: http://pastebin.com/2MnnTdmZ
17:10:25 <rwbarton> you have two versions of bytestring installed, leading to confusion
17:10:43 <lampe2> Zekka: okay let me think for aminute about that :D
17:10:44 <bollu> rwbarton: ah
17:10:53 <bollu> rwbarton: how would I go about resolving this?
17:11:11 <rwbarton> I would uninstall whichever is not the one that came with your ghc
17:11:29 <rwbarton> "ghc-pkg list bytestring" will show you the versions, you want the one at the top in the global package db
17:11:35 <bms1> Is Hackage down right now?
17:11:49 <bollu> redtricycle: hm
17:11:52 <bms1> Or was it down earlier today?
17:12:05 <bollu> rwbarton: I think the 0.10 bytestring was pulled by aesome
17:12:15 <bollu> rwbarton: thanks :)
17:12:34 <lampe2> pjdelport: Zekka oh and thanks for the help
17:12:57 <rwbarton> bollu: I use these instructions to make sure it doesn't happen in the future: http://www.vex.net/~trebla/haskell/cabal-cabal.xhtml#lockdown
17:13:12 <bollu> rwbarton: ghc-pkg seems to believe that there's only one bytestring package
17:13:13 <Zekka> lampe2: No problem, best of luck
17:13:49 <pjdelport> lampe2: No problem. :)
17:13:51 <rwbarton> hmm
17:14:15 <rwbarton> bollu: you can see though that the error message mentions two
17:14:34 <rwbarton> bytestring-0.10.2.0 and bytestring-0.10.4.0
17:14:37 <rwbarton> oh, are you in a sandbox?
17:14:46 <lampe2> liftingInGeneral :: x z -> y z . so x can be anything? and can be lifted to anzýthing ?
17:14:53 <bollu> rwbarton: yeah, I am in a sandbox
17:15:07 <Zekka> lampe2: It's less a real type and more a type where if you mkake the right substitutions you can get the form of most lifting operations
17:15:17 <bollu> rwbarton: does that change things significantly?
17:15:23 <Zekka> Don't take this as an actual function that appears in the stdlib
17:15:38 <ninja_code> how are peopel making ahskell more fun?
17:15:43 <rwbarton> bollu: well I guess then that cabal installed one of the versions into the sandbox -- to see it you need something like cabal sandbox hc-pkg list bytestring
17:15:46 <ninja_code> i.e. more closer to the "compile time errors, not run time errors" ?
17:15:58 <rwbarton> bollu: it might mean those "lockdown" directions don't apply, not sure
17:16:24 <bollu> rwbarton: cool, thanks
17:16:32 <bollu> rwbarton: I'll look into it.
17:16:38 <Zekka> lampe2: I just mean that in general functions that look kind of like that are lifting operations
17:16:43 <rwbarton> are you using a .cabal file for your project?
17:16:57 <rwbarton> that's one simple way to make sure you get consistent versions of everything
17:17:13 <lampe2> i have to learn more haskell... i come from the javascript world :D
17:17:34 <rwbarton> I wonder where this usage of "lift" came from
17:17:45 <Zekka> Have you looked into Elm?
17:17:45 <bollu> rwbarton: yeah, there is one
17:17:59 <bollu> rwbarton: and I've listed bytestring as a dependency
17:18:07 <Zekka> It's a pretty cool ML-style language (looks and feels sort of like Haskell) for Applicative-based FRP
17:18:16 <rwbarton> bollu: do you get this error when you run "cabal build"?
17:18:23 <bollu> rwbarton: yep
17:18:27 <Zekka> It compiles to javascript/html5
17:18:27 <rwbarton> how odd
17:18:42 <bollu> rwbarton: yeah, I nuked my sandbox and started afresh
17:18:46 <bollu> rwbarton: let's see what happens
17:19:00 <rwbarton> yeah, sounds good
17:19:04 <rwbarton> i don't think this is supposed to be possible
17:19:04 <Zekka> From what I hear there's a moderate degree of interoperability but the interoperability probably wouldn't be a major factor in using it because it doesn't really look or feel that much like JS to begin with
17:19:08 <Zekka> it's not like Coffeescript or something
17:19:23 <lampe2> what would be a example of lifting in JS ?
17:19:37 <Zekka> One sec, I have one in mind but I don't remember what it's called
17:19:55 <Zekka> https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/map <- This one's a pretty good example
17:20:03 <Zekka> in Haskell it's either map or mapM depending on whether you're a pedant
17:20:10 <Zekka> :t map
17:20:11 <lambdabot> (a -> b) -> [a] -> [b]
17:20:15 <Zekka> :t T.mapM
17:20:16 <lambdabot> (Traversable t, Monad m) => (a -> m b) -> t a -> m (t b)
17:20:20 <bollu> Zekka: isn't Elm a reaaaaly experimental project? I don't think anything in production has been written using it?
17:20:48 <Zekka> bollu: I think Prezi is using it in production but I don't know if anyone else is
17:21:06 <Zekka> Personally I think it's an already pretty decent/workable language with a lot of rough edges
17:21:21 <lampe2> hmm
17:21:35 <Zekka> (no higher-ranked type polymorphism for some strange reason, PHP-style filesystem/site structure correspondence)
17:21:44 <bollu> Zekka: ah.
17:21:53 <Zekka> er, higher-ranked isn't what I mean
17:22:02 <bollu> Zekka: what's the use of HKT? I've never fully grasped what it means
17:22:14 <Para__> @botsnack
17:22:14 <lambdabot> :)
17:22:17 <Zekka> I actually mean something else
17:22:26 <Zekka> Higher-kinded, I think, is what I mean
17:22:43 <lampe2> so in the first example where i got var numbers and var roots where is the lifting happening iam just squaring numbers
17:22:46 <Zekka> So you can't for instance write a type like this: newtype WrappedTwice f a = WrappedTwice (f (f a))
17:23:16 <bollu> Zekka: how is that higher kinded?
17:23:21 <Zekka> This wouldn't be necessary except Elm doesn't have typeclasses and pretty much any attempt to codify value-level typeclasses (see Gabriel Gonzales's 'scrap your typeclasses article') you end up needing it
17:23:38 <Zekka> bollu: f has kind * -> * -- is this not what I mean?
17:23:53 <Zekka> I strongly suspected I was making a vocabulary mistake but I wasn't sure where it was
17:24:22 <bollu> Zekka: like I said, I don't really know :) I think you're right though
17:24:39 <Zekka> What I was actually trying to say, without trying to use vocabulary, is that you can't be polymorphic over anything with kinds other than * from what I can tell
17:24:53 <Zekka> I definitely know you can't in records, but I think you can't in function typesigs either
17:25:13 <Zekka> The creator's stance on this is basically that types like that (and in general the algebraic stuff Haskell describes in typeclasses) are too abstract to be useful
17:25:28 <Zekka> he doesn't want to scare away new programmers
17:25:33 <lampe2> hmm
17:25:39 <Zekka> lampe2: First example?
17:25:45 <Zekka> He's lifting sqrt from single numbers to lists of numbers
17:26:03 <lampe2> ahhhhhhhhhhh
17:26:08 <lampe2> okayyyyy now i get it
17:26:25 <Zekka> :t map
17:26:25 <lambdabot> (a -> b) -> [a] -> [b]
17:26:28 <lampe2> that really a good example
17:26:42 <Zekka> (a -> b) -> ([a] -> [b]), rendered differently
17:26:56 <Zekka> so it turns a function from an a to a b into a function from a [a] to a [b]
17:27:08 <bollu> Zekka: map is a specialization of fmap right?
17:27:12 <Zekka> bollu: Yup.
17:27:19 <Zekka> @src [] fmap
17:27:19 <lambdabot> fmap = map
17:27:42 <bollu> Zekka: cool :)
17:27:49 <Zekka> and for kicks:
17:27:57 <Zekka> @src [] (<*>)
17:27:57 <lambdabot> (<*>) = ap
17:27:59 <bollu> rwbarton: it looks like it's fixed now >_> I don't get cabal
17:28:01 <Zekka> @src [] ap
17:28:01 <lambdabot> Source not found. Sorry.
17:28:08 <Zekka> Oh, apparently we don't have that
17:28:24 <bollu> rwbarton: thanks for the help
17:28:26 <geekosaur> ap isn't a typeclass function
17:28:30 <bollu> Zekka: don't have what? :)
17:28:30 <geekosaur> @src ap
17:28:30 <lambdabot> ap = liftM2 id
17:28:37 <Zekka> The source for ap for []
17:28:38 <bollu> :t ap
17:28:39 <lambdabot> Monad m => m (a -> b) -> m a -> m b
17:28:48 <bollu> :t liftM4
17:28:49 <lambdabot> Monad m => (a1 -> a2 -> a3 -> a4 -> r) -> m a1 -> m a2 -> m a3 -> m a4 -> m r
17:29:00 <bollu> :t liftM100
17:29:00 <lambdabot> Not in scope: ‘liftM100’
17:29:06 <bollu> hm, thought not
17:30:09 <geekosaur> only goes up to 6, iirc
17:30:17 <lampe2> so isnt lifting not just a nice way to say: write a function that fits your coding style/paradigm ?
17:30:18 <Zekka> Did a little googling, doesn't look like there's a single clear-cut definition of (<*>) based on the Functor operations
17:30:45 <Zekka> lampe2: It's the idea that operations between values in any weird context should be easy to derive based on operations on values in a normal context
17:30:52 <bollu> geekosaur: what's the use case for lift4 and stuff? don't <*> and <$> handle n parameters?
17:30:55 <geekosaur> that's why it's a typeclass function
17:31:05 <Zekka> Well, no, I meant for []
17:31:09 <geekosaur> bollu: applicative didn't exist back then
17:31:13 <Zekka> [] just defines it in terms of the monad operations
17:31:16 <ij> λ: runX $ readString [] "<r><i/></r>" >>> getXPathTrees "//i" >>> writeDocumentToString []
17:31:18 <ij> [""]
17:31:20 <ij> Why is that?
17:31:22 <Zekka> Obviously there's not a single definition period
17:31:31 <geekosaur> liftM2 etc. are ancient
17:31:40 <geekosaur> applicatives are only a couple years old
17:32:15 <geekosaur> and we're only just (in ghc 7.10, the *next* release) getting around to redoing Monad in terms of Functor and Applicative
17:32:18 <bollu> geekosaur: hm, wasn't the idea of applicatives well known? or were their definitions ... non-obvious?
17:32:27 <geekosaur> not back then
17:32:28 <bollu> geekosaur: ah, I see.
17:33:06 <geekosaur> there was Monad and there was Arrow. Arrow itself turned out to be a bit of a dead end, but it led to Applicative in one direction and Category in another
17:33:18 <lampe2> so basicly lifting says if your coding in styleX but you want to code in styleZ you first have to lift all the styleX operations to the styleZ operations
17:33:29 <Zekka> Right!
17:33:37 <bollu> geekosaur: dead end in what sense?
17:33:53 <Zekka> So if you want to deal with values in Behaviors, and you know how to deal with values, you should be able just to lift value operations into value-in-Behavior operations
17:34:08 <geekosaur> in the sense that Arrow was intended to be itself a general thing, but instead it turned out to be a rather specific one
17:34:10 <lampe2> yeah now i get it
17:34:19 <geekosaur> generalizing it in one direction gave us Applicative
17:34:19 <lampe2> thank you so much Zekka
17:34:50 <geekosaur> generalizing it in another direction turned out to be Category, which was already "known" but not formalized in Haskell
17:35:01 <bollu> geekosaur: Hm, I thought Arrows were supposed to be generalized Monads? and what's Category? lesson time? :)
17:35:06 <Zekka> Reminds me, by the way -- did anybody ever do any cool writing-up of the connection between Applicative and Monoid?
17:35:13 <Zekka> It seems to me like there's a clear connection but I haven't really explored it
17:35:13 <geekosaur> @where typeclassopedia
17:35:14 <lambdabot> http://www.haskell.org/haskellwiki/Typeclassopedia
17:35:17 <geekosaur> ^ read
17:35:17 <Kaidelong> arrows make more assmptions than category does
17:35:32 <Zekka> That for me or for bollu? I've read it before but it was a long time ago
17:35:39 <bollu> geekosaur: will do
17:35:43 <geekosaur> it's more about the relationships and less about the history though
17:35:49 <bollu> Zekka: which part?
17:36:07 <Zekka> (pure looks like mempty to me and (<*>) looks like mappend, with values bolted on)
17:36:07 <geekosaur> I think the original applicatives paper is linked in the haddock for Control.Applicative
17:36:11 <geekosaur> "idioms"
17:36:20 <Zekka> bollu: I read the whole Typeclassopedia article
17:36:30 <Zekka> He probably wanted you to read the Category section though
17:36:32 <geekosaur> along with a paper comparing Applicative, Monad, and Arrow
17:36:41 <Zekka> Category is actually really straightforward
17:36:52 <bollu> geekosaur: what's the most "general" of the three?
17:36:52 <geekosaur> oh, no, that one isn't linked there
17:37:08 <geekosaur> bollu, that's a hard question to answer
17:37:26 <lampe2> hmm my prof is writing that he thinks that i dont understand what the difference between behaviours and events is ...
17:37:27 <geekosaur> @google monads promiscuous
17:37:28 <lambdabot> http://homepages.inf.ed.ac.uk/wadler/papers/arrows-and-idioms/arrows-and-idioms.pdf
17:37:29 <lambdabot> Title: Idioms are oblivious, arrows are meticulous, monads are promiscuous
17:37:44 <Zekka> Thanks, reading
17:38:12 <bollu> geekosaur: thanks for the links
17:38:21 <geekosaur> in some sense, applicatives are most general. but they're not entirely comparable
17:38:45 <geekosaur> the last paper I linked to should haver a good description of what each one does well and does poorly
17:39:10 <geekosaur> basically when you gain generality in one dimension, you lose it in others
17:39:31 <geekosaur> and there is no great-granddaddy concept that is fully general
17:39:42 <bollu> geekosaur: ah, I see
17:40:34 <bollu> geekosaur: that relationship diagram is daunting >_<
17:40:49 <geekosaur> yep
17:41:03 <Zekka> bollu: I didn't learn most of these from the article but from playing with types and discovering holes in my knowledge
17:41:17 <Zekka> because a lot of the time I would think 'that intuitively *should* exist' and then google and find out it did
17:41:32 <bollu>  Zekka makes sense!
17:41:32 <Zekka> Like when I was playing around and noticed 'there really ought to be an effectful fmap'
17:41:35 <Zekka> :t fmap
17:41:36 <lambdabot> Functor f => (a -> b) -> f a -> f b
17:41:38 <Zekka> :t traverse
17:41:39 <lambdabot> (Traversable t, Applicative f) => (a -> f b) -> t a -> f (t b)
17:41:49 <Zekka> and there it was!
17:43:30 <Zekka> geekosaur: So far this is a little dense in type theory for me but I'm roughly following
17:43:51 <Zekka> probably because I already knew roughly what each of these typeclasses signified
17:44:02 <geekosaur> it's not *that* dense, I followed it fairly well and type theory usually turns my brain to mush >.>
17:44:09 <bollu> geekosaur: I substitute 'f' with 'T' in my head whenever I read haskell type definitions. bad habit or accpetable?
17:44:28 <Zekka> Why 'T'? What's T mean?
17:44:36 <Zekka> Do you mean like Option<T> or List<T>?
17:44:39 <bollu> Zekka: yep
17:44:46 <Kaidelong> 0the only problem is that T in haskell isn't valid
17:44:55 <rwbarton> usually T is called a :)
17:45:05 <Kaidelong> but I use t and u and v because they are slightly better picks than a b c
17:45:09 <Zekka> It probably doesn't hurt except that T isn't a valid name for a type variable, like Kai said
17:45:11 <Kaidelong> F# uses 'T
17:45:21 <Kaidelong> because it has the ML approach to free variables
17:45:28 <Zekka> they're required to be lowercase
17:45:28 <geekosaur> might be best not to follow that too far, because of (a) the syntax issue (b) C++ templates really aren't the same thing, and will eventually lead you into trouble the same way trying to pretend they're Java interfaces will
17:45:33 <geekosaur> (although for a different reason)
17:46:04 <Kaidelong> well is he talking about C++ templates or actual parametric polymorphism in a language like C#?
17:46:23 <bollu> Zekka: good to know. geekosaur: when I see f, I immediately jump to f(x), then jump back again and realize, no, it's f<T>
17:46:41 <geekosaur> point, I'm more aware of C++ than C#
17:46:45 <Zekka> bollu: Between you and me, type constructors act a lot like value-level functions
17:46:52 <bollu> Kaidelong: C++
17:47:08 <Zekka> They're even curried!
17:47:11 <Kaidelong> well yeah watch out for that
17:47:21 <Kaidelong> C++ templates are way more powerful and dangerous
17:47:32 <Zekka> (((Either) Int) Int) == ((Either Int) Int) == (Either Int Int)
17:47:41 <bollu> Zekka: xD
17:47:45 <Zekka> (just as soon as you define type-level Eq)
17:49:17 <Kaidelong> http://hackage.haskell.org/package/type-equality-0.1.0/docs/Data-Type-Equality.html
17:49:51 <bollu> Kaidelong: what's the link about?
17:50:04 <Zekka> bollu: Type-level equality checks!
17:50:08 <Kaidelong> Zekka mentioned a type level eq
17:50:08 <Zekka> wjp wpi;dm
17:50:12 <Kaidelong> so I gave him one
17:50:18 <Zekka> who wouldn't want to check whether types are equivalent?
17:50:21 <lampe2> so behaviours
17:50:23 <bollu> Kaidelong: ah :)
17:50:48 <Kaidelong> this isn't really that useful in haskell
17:50:58 <Zekka> I was actually pretty surprised it existed.
17:51:02 <Kaidelong> it is quite amazing in idris what you can do with it though to infer code
17:51:18 <lampe2> so behaviours always have a value and events occasionally ?
17:51:20 <Kaidelong> it's not useless though
17:51:32 <Zekka> lampe2: Offhand I don't actually know what events are in FRP, can you link your paper again?
17:51:53 <lampe2> http://cs.brown.edu/research/pubs/theses/ugrad/2007/lmeyerov.pdf Zekka point 2.2
17:53:00 <Zekka> Looks to me like Events are a Functor (possibly an Applicative) representing a alue over time
17:53:29 <Zekka> seems like page 20 addresses this, I'll read
17:53:33 <bollu> :t (->)
17:53:34 <lambdabot> parse error on input ‘->’
17:53:42 <bollu> :t (-> Int)
17:53:42 <lambdabot> parse error on input ‘->’
17:54:43 <bollu> ((->) e) is a functor? >_< what does it mean to "map" over that?
17:55:01 <Zekka> @src ((->) e) fmap
17:55:01 <lambdabot> Source not found. BOB says:  You seem to have forgotten your passwd, enter another!
17:55:07 <Zekka> Oh
17:55:09 <Zekka> Well, it's (.)
17:55:10 <briennetheblue> :k ((->) Int)
17:55:11 <lambdabot> * -> *
17:55:18 <Zekka> ((->) e) rewrites as (e ->), by the way
17:55:23 <lampe2> okay so basicly a event is something like the mousepostion it always has a value and Behaviours
17:55:30 <Zekka> :t fmap
17:55:31 <lambdabot> Functor f => (a -> b) -> f a -> f b
17:55:39 <pavonia> @src (->) fmap
17:55:39 <lambdabot> fmap = (.)
17:55:49 <lampe2> are formfield like a nickname this field has a specific value on a specific time
17:55:56 <Zekka> lampe2: That seems to be correct
17:56:06 <Zekka> behaviors change at discrete points in time
17:56:10 <Zekka> pavonia: Oh, my inner pedant!
17:56:10 <bollu> pavonia, Zekka nope, I don't get it. will spend time on it
17:56:19 <Zekka> bollu: I'll show you, one secon
17:56:21 <Zekka> second*
17:56:32 <Zekka> So, if f is (e ->), then that substitutes out to this:
17:56:39 <Zekka> fmap :: (a -> b) -> (e -> a) -> (e -> b)
17:56:49 <Zekka> So we need to change a function that turns es into as into a function that turns es into bs
17:56:55 <Zekka> bollu: Does that help?
17:57:04 <Zekka> It might help writing it out by hand
17:57:56 <pavonia> It's mapping a function over the result value of another function
17:58:02 <bollu> Zekka: so, is there a.. concerete example?
17:58:12 <Zekka> Well, I can make e a specific type
17:58:22 <Zekka> fmap :: (a -> b) -> (Int -> a) -> (Int -> b)
17:58:45 <bollu> Zekka: I can see how substituting ((-> e)) will yield that definition, but, like, how does it work? or how do I use it?
17:58:52 <Zekka> bollu: I'll give an example
17:59:05 <Zekka> Let's say our a -> b is (Int -> String): specifically show
17:59:22 <Zekka> fmap show :: (Int -> Int) -> (Int -> String)
17:59:24 <bollu> Zekka: okay
17:59:35 <Zekka> Let's say our (Int -> Int) is (+1)
17:59:44 <Zekka> fmap show (+1) :: (Int -> String)
17:59:55 <Zekka> (+1) is our 'value in a context'
18:00:04 <Zekka> it's an int in the context of it needs another int to be passed in to turn into a value
18:00:13 <Zekka> So we want to operate on the value it will be, using show
18:00:17 <Cale> bollu: It works exactly like function composition (.)
18:00:19 <bollu> Zekka: right, it's a partially applied function, sure
18:00:25 <Cale> :t (.)
18:00:26 <lambdabot> (b -> c) -> (a -> b) -> a -> c
18:00:36 <briennetheblue> comedy example
18:00:39 <briennetheblue> :t fmap fmap fmap
18:00:40 <lambdabot> (Functor f1, Functor f) => (a -> b) -> f (f1 a) -> f (f1 b)
18:00:43 <Zekka> Hence, fmap show (+1) = \x -> show ((+1) x)
18:00:56 <Zekka> fmap f g = \x -> f (g x)
18:01:02 <Zekka> fmap f g = f . g
18:01:04 <Zekka> fmap = (.)
18:01:19 <bollu> Zekka: ah
18:01:41 <bollu> Zekka: I think I understand now!
18:01:49 <bollu> Zekka, Cale: thanks :)
18:01:50 <Zekka> And yeah, you can stack fmap like that to get multiple layers into a functor stack
18:02:01 <bollu> :t fmap . fmap
18:02:02 <lambdabot> (Functor f1, Functor f) => (a -> b) -> f (f1 a) -> f (f1 b)
18:02:16 <bollu> Zekka: what's a usecase for that?
18:02:32 <Zekka> > fmap fmap fmap fmap fmap (++ "hey world") [Just ["what the ", "it's time to hit the "], Nothing]
18:02:33 <lambdabot>  Couldn't match type ‘a -> [GHC.Types.Char]’
18:02:33 <lambdabot>                with ‘[Data.Maybe.Maybe [[GHC.Types.Char]]]’
18:02:33 <lambdabot>  Expected type: ((a -> [GHC.Types.Char])
18:02:33 <lambdabot>                  -> f a -> f [GHC.Types.Char])
18:02:33 <lambdabot>                 -> ((a -> [GHC.Types.Char]) -> a -> [GHC.Types.Char])
18:02:42 <Zekka> > (fmap fmap fmap fmap fmap) (++ "hey world") [Just ["what the ", "it's time to hit the "], Nothing]
18:02:43 <lambdabot>  Couldn't match type ‘a -> [GHC.Types.Char]’
18:02:44 <lambdabot>                with ‘[Data.Maybe.Maybe [[GHC.Types.Char]]]’
18:02:44 <lambdabot>  Expected type: ((a -> [GHC.Types.Char])
18:02:44 <lambdabot>                  -> f a -> f [GHC.Types.Char])
18:02:44 <lambdabot>                 -> ((a -> [GHC.Types.Char]) -> a -> [GHC.Types.Char])
18:02:48 <briennetheblue> fmap fmap fmap is just a silly way to write fmap . fmap
18:02:51 <Zekka> Hm, I'll stop until I get it working
18:02:54 <Zekka> and brienne is right
18:04:59 <Zekka> > (fmap fmap (fmap fmap fmap)) (++ "hey world") [Just ["what the ", "it's time to hit the "], Nothing]
18:05:00 <lambdabot>  [Just ["what the hey world","it's time to hit the hey world"],Nothing]
18:05:02 <Zekka> There you are.
18:05:19 <benzrf> ahaha what
18:05:29 <Zekka> bollu: And if you really, really like going inside of structures and changing things, there's a great library based on a generalization of this pattern called lens
18:05:51 <bollu> Zekka: I did read about lens :)
18:06:04 <bollu> Zekka: I loved that you could compose lenses
18:06:37 <Zekka> By the way, if you're confused by the functor instance for (.), let me show you the applicative instance
18:06:59 <Zekka> :t ((+) <*>)
18:07:00 <lambdabot> Num a => (a -> a) -> a -> a
18:07:11 <Zekka> ((+) <*> (*40)) 4
18:07:17 <Zekka> > ((+) <*> (*40)) 4
18:07:18 <lambdabot>  164
18:07:41 <briennetheblue> this is how you write idiomatic #haskell
18:07:48 <bollu> xD
18:07:49 <briennetheblue> but probably not idiomatic haskell
18:08:05 <Zekka> Using the applicative and functor instances for ((->) a) is 'cool'
18:08:08 <Zekka> not cool but 'cool'
18:08:26 <bollu> Zekka: that's  insane.
18:08:29 <Zekka> 'fix' instead of explicit recursion is also 'cool'
18:08:46 <Zekka> :t (zipWith <*>)
18:08:47 <lambdabot> ((a -> b -> c) -> [a]) -> (a -> b -> c) -> [b] -> [c]
18:08:53 <lfairy> it makes sense if you think of it as mapping over the result
18:08:54 <bollu> Zekka: plz
18:08:59 <Zekka> :t (zipWith (++) <*>)
18:09:00 <lambdabot> ([[a]] -> [[a]]) -> [[a]] -> [[a]]
18:09:18 <Zekka> :t (zipWith (++) <*> reverse) ["alpha", "beta", "gamma"]
18:09:19 <lambdabot> [[Char]]
18:09:23 <Zekka> > (zipWith (++) <*> reverse) ["alpha", "beta", "gamma"]
18:09:24 <lambdabot>  ["alphagamma","betabeta","gammaalpha"]
18:09:56 <Zekka> (<*>) :: (a -> b -> c) -> (a -> b) -> (a -> c)
18:10:03 <lfairy> :t (,) <*> (^2)
18:10:04 <lambdabot> Num b => b -> (b, b)
18:10:06 <Zekka> so you get the second argument by doing something to the first argument
18:10:22 <lfairy> map ((,) <*> (^2)) [1..10]
18:10:27 <lfairy> > map ((,) <*> (^2)) [1..10]
18:10:29 <lambdabot>  [(1,1),(2,4),(3,9),(4,16),(5,25),(6,36),(7,49),(8,64),(9,81),(10,100)]
18:11:06 <bollu> lfairy: how do I read that?
18:11:11 <briennetheblue> > (==) <*> reverse $ "racecar"
18:11:13 <lambdabot>  True
18:12:02 <lfairy> bollu: have you looked into transformers? (->) is Reader
18:12:23 <bollu> map (id <*> (^2)) [1..10]
18:12:30 <bollu> lfairy: no, I have not
18:12:37 <bollu> > map (id <*> (^2)) [1..10]
18:12:39 <lambdabot>  Occurs check: cannot construct the infinite type: a0 ~ a0 -> b
18:12:39 <lambdabot>  Expected type: (a0 -> b) -> a0
18:12:39 <lambdabot>    Actual type: (a0 -> b) -> a0 -> b
18:13:34 <lfairy> bollu: essentially, a functor is a value with a "context"
18:13:49 <lfairy> for functions, this context is the argument of the function
18:14:35 <Zekka> (And the value is the return-value of the function)
18:14:43 <lfairy> yep
18:14:59 <lfairy> so fmap maps over the result of the function, ignoring its argument
18:15:09 <Zekka> (Because fmap modifies the value, not the context of the value)
18:15:25 <Zekka> (er, transforms the value in the functor if you want to put it in more precise terms)
18:15:52 <lfairy> and <*> ignores the first (outermost) argument, and applies the function inside
18:16:23 <bollu> lfairy: ignores the first argument? how os?
18:16:25 <bollu> so*
18:16:32 <Zekka> If your thought right now is 'well, why can't the value be the context and the argument be the value' then oh did I drop this? https://www.fpcomplete.com/school/to-infinity-and-beyond/pick-of-the-week/profunctors
18:16:39 <Zekka> er, the return value be the context*
18:17:49 <lfairy> :t <*>
18:17:50 <lambdabot> parse error on input ‘<*>’
18:17:55 <lfairy> :t (<*>)
18:17:55 <lambdabot> Applicative f => f (a -> b) -> f a -> f b
18:18:09 <lfairy> bollu: the first argument is the context
18:18:29 <Zekka> (For f is (e ->), (<*>) :: (e -> a -> b) -> (e -> a) -> (e -> b)
18:18:32 <Zekka> )*
18:18:33 <lfairy> bollu: <*> applies the /inner/ function, and leaves the context alone
18:20:33 <briennetheblue> > lmap succ even 1
18:20:35 <lambdabot>  True
18:21:35 <Zekka> (Which, as you know from the article, expands to (even . succ) 1)
18:21:38 <lfairy> bollu: taking briennetheblue's example, (==) takes a string and returns a function; reverse takes a string and returns a string
18:23:15 <lfairy> bollu: under the functor context, (==) :: f (String -> Bool) and reverse :: f String
18:23:37 <Zekka> (where f of course is (String ->))
18:24:21 <lfairy> yep. the functor is the "takes a string" part
18:24:30 <bollu> lfairy: go on
18:25:22 <lfairy> bollu: great. so when we <*> them together, we get ((==) <*> reverse) :: f Bool
18:25:54 <lfairy> which expands String -> Bool
18:26:00 <lfairy> *to
18:26:57 <lfairy> bollu: <*> applies /under/ or /within/ the context, see
18:27:17 <lfairy> so when we use <*>, we can ignore the fact that these take an extra string
18:27:22 <lfairy> and assume the string is already there
18:28:09 <lfairy> um, probably didn't word that last bit well
18:28:54 <bollu> lfairy: right, because of the way haskell pattern matches, we "extract" the (a -> b) bit from the f freely correct?
18:28:58 <Zekka> Basically (==) is a String -> Bool in the context of 'I want a string' and reverse is a String in the context of 'I want a string'
18:29:12 <lfairy> what Zekka said
18:29:20 <Zekka> so the result is the value in (==) applied to the value in reverse in the context of 'I want a string'
18:30:22 <lfairy> bollu: it's got nothing to do with pattern matching, but I think you're getting the gist of it
18:30:48 <lfairy> there is no extraction involved -- we don't get anything out of it until we actually give it a string
18:30:56 <lfairy> it's more like working inside of it
18:31:16 <Zekka> There's the standard 'it's a magic box and the key is a value of its argument type' analogy
18:31:20 <Zekka> or at least I think it's standard
18:32:04 <bollu> lfairy: Zekka: let me play around with this and get back :) Zekka : yeah, it is a standard analogy. thanks a lot
18:32:28 <Zekka> An easier application of the Applicative for (->) is liftA2
18:32:46 <benzrf>     j
18:32:48 <Zekka> :t (liftA2 (,))
18:32:49 <lambdabot> Applicative f => f a -> f b -> f (a, b)
18:32:54 <lfairy> bollu: np :)
18:33:01 <Zekka> :t (liftA2 (,) length)
18:33:02 <lambdabot> ([a] -> b) -> [a] -> (Int, b)
18:33:17 <Zekka> > (liftA2 (,) length head) [1, 2, 3, 4]
18:33:19 <lambdabot>  (4,1)
18:33:24 <bollu> lfairy, Zekka: I now understand what happens when you use (<*>) and to some extent why it works, but tracing the types with :t gives me zero insight
18:33:37 <benzrf> bollu: yes it is pretty annoying
18:33:42 <jle`> :t (<*>)
18:33:43 <lambdabot> Applicative f => f (a -> b) -> f a -> f b
18:33:52 <Zekka> bollu: I don't know offhand i there's a way to specialize it to a specific instance in lambdabot
18:33:54 <jle`> :t (<*>) `asAppliedTo` (undefined :: a -> b -> c)
18:33:55 <lambdabot> (a -> b -> c) -> (a -> b) -> a -> c
18:34:06 <Zekka> Oh, good on you!
18:34:15 <benzrf> :t asAppliedTo
18:34:16 <lambdabot> (a -> b) -> a -> a -> b
18:34:19 <benzrf> @src asAppliedTo
18:34:19 <lambdabot> Source not found. :(
18:34:21 <benzrf> well
18:34:26 <benzrf> asAppliedTo is just const
18:34:31 <Zekka> It might be easiest not even to think applicatively at all
18:34:37 <bollu> Zekka: how so?
18:34:49 <Zekka> So you have an (a -> b -> c), an (a -> b), and you need an (a -> c)
18:34:50 <benzrf> but its type forces the checker to specialize the 1st arg
18:35:04 <Zekka> How do you pull that off?
18:35:23 <Zekka> You already know you'll have an an a, but you need some way to get the c
18:35:25 <Zekka> er, to get the b
18:35:28 <lfairy> Zekka: but it's good to understand applicatives generally
18:35:29 <Zekka> How do you do that?
18:35:32 <benzrf> @djinn (a -> b -> c) -> (a -> b) -> (a -> c)
18:35:32 <lambdabot> f a b c = a c (b c)
18:35:35 <benzrf> :3
18:35:41 <Zekka> lfairy: Yes, but I'd argue this is a very bad applicative to learn to undeerstand them generally with
18:35:49 <briennetheblue> it's probably easier to understand "Reader a" rather than "((->) a)"
18:35:50 <jle`> i agree
18:35:51 * lfairy shrugs
18:35:57 <Zekka> Which, fun fact, is the primitive S combinator
18:36:07 <benzrf> so i tol
18:36:20 <Zekka> ('pure' for functions is the primitive K)
18:37:00 <Zekka> (I is not too hard, and B is a little tricky to define but I have some clever definition of it somewhere around here, and from there you're getting into easier territory)
18:37:18 <Zekka> but you probably don't know or care about combinatory logic
18:37:49 <bollu> lfairy: yeah, I'd like to understand the "machinery" behind it too if that makes sense. Zekka: no, I don't know :)
18:38:10 <the-manless-man> Zekka: I think B is just composition
18:38:10 <Zekka> A nice easy applicative is Identity
18:38:25 <Zekka> the-manless-man: It is, but defining composition in terms of (<*>) and pure is a little tricky
18:38:40 <Zekka> that is, without introducing lambda abstractions
18:38:47 <Zekka> which is cheating
18:38:48 <the-manless-man> nice exercise
18:38:51 <the-manless-man> :)
18:39:00 <Zekka> :t Identity
18:39:01 <lambdabot> a -> Identity a
18:39:16 <Zekka> So, Identity is just newtype Identity a = Identity a
18:39:35 <Zekka> :t (<*>) `asAppliedTo` (undefined :: Identity (a -> b))
18:39:36 <lambdabot> Identity (a -> b) -> Identity a -> Identity b
18:39:50 <Zekka> bollu: So how, given an (a -> b), and an a, do you get a b?
18:40:17 <jmcarthur> does anybody know of some up to date version of or alternative to ghc-heap-view?
18:40:22 <jle`> man can we get Applicative to be a superclass of Monad already
18:40:35 <jle`> it's like i'm living in the 17th century here
18:42:15 <bollu> Zekka: apply the (a -> b) on a? that gives us a 'b'
18:42:20 <Zekka> bollu: Yep!
18:42:23 <Zekka> Next one
18:42:30 <Zekka> :t (<*>) `asAppliedTo` (undefined :: Maybe (a -> b))
18:42:31 <lambdabot> Maybe (a -> b) -> Maybe a -> Maybe b
18:42:57 <Zekka> How do you turn a Maybe (a -> b) and a Maybe a into a Maybe b?
18:43:24 <bollu> Maybe (a -> b) <*> Maybe a
18:43:33 <bollu> will give you a Maybe b as I understand it
18:43:40 <Zekka> Yeah, so how's (<*>) defined?
18:43:48 <jle`> :t (<*>) `asAppliedTo` Nothing   -- Zekka :)
18:43:49 <lambdabot> Maybe (a -> b) -> Maybe a -> Maybe b
18:43:58 <jle`> hooray for polymorphic constructors
18:44:00 <bollu> ^
18:44:18 <bollu> what lambdabot said :) that's be the definition correct?
18:44:27 <bollu> f (a -> b) -> f a -> f b
18:44:28 <Zekka> That's the type, but not the definition
18:44:42 <bollu> Zekka: ah
18:45:13 <bms1> Zekka: If both are Just, the result is Just the application. If either is Nothing, there's only one thing to do... Nothing!
18:45:24 <Zekka> bms1: Correct! I'm setting up an lpaste to give examples in
18:45:37 <bollu> bsmti: hm, right
18:45:47 <bms1> Oh, I thought you were asking
18:46:04 <Zekka> bms1: I was quizzing Bollu
18:46:15 <bms1> oh, sorry Bollu!
18:46:20 <bollu> bms1: np :)
18:46:53 <bollu> Zekka: so, okay, with you till now
18:47:16 <Zekka> bollu: I threw up a new problem and a suggestion here: we can still talk them over in here but if you want tos ee earlier definitions they're up
18:47:22 <Zekka> er, one second, I'll link
18:47:27 <bollu> sure
18:47:56 <Zekka> http://lpaste.net/106681 <- here it is. You can use the edit feature to directly modify it
18:48:32 <Zekka> The applicative instance for ((,) e), aka (e, ) isn't actually that hard but you will need to know some typeclasses you don't already know
18:49:04 <Zekka> It's worth mentioning that Applicative has two operations: (<*>), and pure -- we've only defined (<*>) because it's generally the harder of the two, but if you were actually defining these instances you would have to define pure too
18:49:36 <Zekka> (well, one typeclass, and you might already know it, but it's not one of the ones i.e. LYAH introduces early-on if I remember right)
18:50:27 <Zekka> For (e, ) pure is actually a good starting point because it tells you a lot about how you'll need to define (<*>)
18:50:40 <bollu> Zekka: ah, will look around
18:58:23 <benzrf> fungtur
18:59:59 <acowley> Is everyone going to Hac Boston?
19:00:26 <acowley> I hope so. I need to figure out how to get myself there.
19:00:48 <Luke_> I'm trying to use Tasty with HUnit inside a CustomMonadT. what's the correct way to use Identity monad?
19:01:05 <Luke_> right now I have it hardcoded in some of the function signatures
19:01:28 <Luke_> but when I eval my monadT, it's returning an 'Identity a'
19:01:48 <Luke_> should I just runIdentity?
19:01:51 <Zekka> Luke_: Don't forget to runIdentity
19:01:56 <Zekka> Yeah, that should do it
19:01:58 <Zekka> :t runIdentity
19:01:59 <lambdabot> Identity a -> a
19:03:17 <ninja_code> so I ordere d aprint copy of LYSH ... and I feel completely disappointed
19:03:30 <Luke_> i just mean is "runIdentity" the idiomatic way of using Identity in a MonadT situation?
19:03:32 <ninja_code> the papges are black & white -- so I'm probably going to read the online version instead
19:03:37 <acowley> Luke_: Yes
19:03:42 <Luke_> great thanks
19:04:15 <dmwit> Luke_: It's alse quite idiomatic for whoever wrote the transformer to offer a non-T run version.
19:04:26 <Luke_> yeah i wrote it =)
19:04:30 <Luke_> so I didn't do that
19:04:40 <dmwit> e.g. there's runStateT and runState, and runState calls runStateT and runIdentity appropriately.
19:04:45 <Luke_> right right. that makes sense
19:04:46 <Luke_> thanks a lot
19:06:29 <Rotaerk_Web> hmm why does the OpenGLRaw package say it's a binding for OpenGL 3.2, but the OpenGL package says it's a binding for 4.4
19:06:42 <Rotaerk_Web> thought the latter was implemented in terms of the former
19:07:51 <Rotaerk_Web> also, am I correct in my determination that there's no way to assign a value to a matrix uniform using the OpenGL package's functions?
19:08:12 <Rotaerk_Web> the examples I've found suggest you have to fall back on the raw package for that
19:09:29 <acowley> oh geese, I don't think I have haddocks building on hackage for anything I upload anymore
19:09:54 <acowley> Rotaerk_Web: You can
19:10:11 <acowley> I don't remember how, but I'm looking
19:10:15 <Rotaerk_Web> thanks
19:10:17 <acowley> I'm sure one of my libs makes it easy
19:10:24 <Rotaerk_Web> I've tried a few things, but they haven't worked so far
19:10:31 <Luke_> is there an example of testing monadic code with Tasty anyone knows of?
19:11:06 <Luke_> I'm not sure how to build up a TestGroup while sequencing effects with my MonadT
19:11:17 <dmwit> "Oh geese"? What kind of swear is that? =P
19:11:29 <dmwit> (The very gentle kind, I guess.)
19:11:53 <Zekka> I wouldn't characterize geese as gentle
19:12:17 <zzzzzzzziiii> data Trie = T Bool (M.Map Char Trie) -- i have written insert and member, but how can i traverse the trie, apply the words to a function, save something like [(2,"foo"), (5,"bar")] and stop traversing the subtrie if the function returns something above a threshold?
19:13:17 <acowley> Rotaerk_Web: Ah, it's kind of dirty. You need to use uniformv and then something like Foreign.Marshal.withArray
19:13:28 <Rotaerk_Web> hmm
19:13:40 <acowley> Rotaerk_Web: But I really am sure I've written about some easier way of doing this
19:14:26 <Rotaerk_Web> I was using a [Vertex4 GLfloat], and then used withStorableArray to get the pointer
19:14:37 <Luke_> should I use a WriterT [TestTree] or something and then run the writerT at the end in order to get my tests?
19:15:05 <Rotaerk_Web> haven't used Foreign.Marshal.withArray
19:15:25 <sveit> is there somewhere online i can learn about *practical* aspects of haskell workflow? my particular case is that I am working on a library and a project that uses that library simultaneously, and would like changes from one to be seen by the other in an "easy" way
19:15:29 <acowley> Rotaerk_Web: I'm sure GLUtil and vinyl-gl offer you something that takes a "M44 GLfloat" and sets the uniform
19:15:37 <acowley> But I have to step away from the keyboard at the moment
19:15:45 <sveit> i.e. they are stored in separate directories and are morally separate projects
19:16:20 <Rotaerk_Web> acowley, okay, thanks; I hadn't heard of those packages
19:16:44 <int3__> i've a question about efficiency: since haskell is lazy, is appending O(N) lists of length O(M) together and then recursing once through the result an O(N*M) or O(M*N^2) operation? I imagine that as each element in the result list is 'used', ghc could just look for the appropriate element in the constituent lists...
19:16:45 <acowley> Rotaerk_Web: I've written somewhat old blog posts about them, feel free to contact me if need be
19:16:51 <acowley> Rotaerk_Web: They're both up to date on hackage
19:16:59 <acowley> Rotaerk_Web: But the docs aren't built
19:17:13 <jmcarthur> int3__: it depends on how you associate the appends
19:17:22 <Rotaerk_Web> cool, thanks
19:17:23 <acowley> Luke_: I use assertBool or assertEqual from HUnit when testing IO things with tasty
19:17:28 <acowley> okay, bbl
19:18:12 <int3__> jmcarthur: could you elaborate?
19:18:12 <jmcarthur> int3__: a ++ (b ++ (c ++ (d ++ ...)))   is pretty efficient (linear in the total number of elements of all lists)
19:18:39 <Zekka> @src concat
19:18:39 <lambdabot> concat = foldr (++) []
19:18:40 <jmcarthur> int3__: but (((a ++ b) ++ c) ++ d) ++ ...    is not so efficient, since it has to rebuild the list every time you append
19:18:54 <Zekka> What jmcarthur's describing is how concat is implemented, by the way
19:18:59 <jmcarthur> right
19:19:04 <int3__> ah, I see
19:20:00 <int3__> what about flattening a list of lists repeatedly with join -- is that also linear in the number of elements?
19:20:01 <jmcarthur> int3__: note that this is the same regardless of laziness
19:20:32 <Zekka> @src join
19:20:32 <lambdabot> join x =  x >>= id
19:20:33 <jmcarthur> int3__: laziness does allow you to consume some of the result and then stop without forcing the whole thing, though.
19:20:46 <jmcarthur> int3__: the right associated version is also better for that kind of consumption pattern
19:20:52 <Zekka> int3__: join should be implemented as concat or equivalent for lists
19:21:06 <jmcarthur> int3__: what do you mean by repeatedly? do you mean you actually started with a tree?
19:21:12 <int3__> jmcarthur: yeah, a tree
19:21:13 <Zekka> @src [] join
19:21:13 <lambdabot> Source not found.
19:22:10 <jmcarthur> int3__: done naively (replace each internal node with an append) it won't be as efficient as it could be. it would depend on how the tree leans. however, you could force it to append in a right associated manner if you want.
19:24:29 <jmcarthur> int3__: in other words, the naive way is to put the values in the leaves into lists and then transform the branches into appends. the less naive way is to replace each leaf x with (x:) and each internal node with (.); that gives you a function that prepends the contents of the tree onto an argument lists, which you can then just apply to [].
19:24:43 <jmcarthur> *an argument list
19:25:03 <jmcarthur> int3__: and that way also works well with laziness :)
19:25:18 <jmcarthur> (but loses some sharing compared to the naive way)
19:25:36 <int3__> jmcarthur: the less naive way involves passing an accumulator argument to my tree traversal function, correct?
19:25:54 <Zekka> int3__: One second, I'll implement jmcarthur's version
19:26:07 <jmcarthur> int3__: nah, accumulators are often a sign of overthinking in haskell. laziness means you can often do better *without* tail recursion
19:26:20 <jmcarthur> (not always bad though)
19:27:50 * hackagebot haskell-course-preludes 0.0.0.4 - Small modules for a Haskell course in which Haskell is taught by implementing Prelude functionality.  http://hackage.haskell.org/package/haskell-course-preludes-0.0.0.4 (gibiansky)
19:28:00 <jmcarthur> int3__: this way i've been describing transformations to you is generally called a fold
19:28:11 <jmcarthur> int3__: replacing constructors with functions
19:28:32 <int3__> jmcarthur: yup, I'm sort of familiar with basic folds
19:28:47 <jmcarthur> int3__: in this case, it's the fold for whatever tree data structure you have
19:29:18 <jmcarthur> int3__: and note that it behaves like a "right" fold. there is no accumulator
19:29:53 <Zekka> http://lpaste.net/106683 <- int3__
19:30:07 <jmcarthur> int3__: although really since this is a tree and not a list, assigning a direction to the fold is weird anyway
19:30:16 <Zekka> (you can make the suggested change if you want, but I think it's a little harder to read)
19:30:35 <jmcarthur> ah you went with values in internal nodes instead of leaves the way i assumed :)
19:30:52 <Zekka> It's still a correct strategy, isn't it?
19:30:57 <jmcarthur> it's worth pointing out how special  foldr (.) id  is
19:31:00 <jmcarthur> :t foldr (.) id
19:31:01 <lambdabot> [b -> b] -> b -> b
19:31:08 <jmcarthur> that's basically the coolest function in haskell
19:31:32 <Zekka> :t mconcat `asAppliedTo` ([] :: [Endo a])
19:31:33 <lambdabot> [Endo a] -> Endo a
19:31:42 <Rufflewind_> does it matter if I put my module under Foo vs Data.Foo on Hackage?  (it seems to complain somewhat about the former)
19:31:42 <Zekka> @src Endo
19:31:42 <lambdabot> Source not found. I feel much better now.
19:32:07 <jmcarthur> Zekka: yeah i think it looks right
19:32:52 <jmcarthur> Rufflewind_: i think people overemphasize the importance of the module heirarchy. most things just live under Data or Control, and sometimes even then it isn't clear where it belongs
19:33:33 <int3__> jmcarthur: foldr (.) id composes the functions in any list / tree etc structure, I guess?
19:33:50 <jmcarthur> int3__: well, since it uses foldr, it's just for lists
19:33:51 <int3__> Zekka: thanks for the code sample, I think I've got it now (and thanks @ jmcarthur too)
19:33:56 <Zekka> int3__: Any list
19:34:10 <Zekka> https://hackage.haskell.org/package/base-4.7.0.0/docs/Data-Foldable.html
19:34:10 <int3__> right. so... why's it special
19:34:12 <nexion> hey guys, what's the best way to fix this error during "cabal install text" on OS X Mavericks? http://pastebin.com/jbHPHVdH
19:34:27 <Zekka> You can define it with Foldable if you want to though
19:34:39 <Zekka> where your monoid would be Endo [a]
19:35:10 <Zekka> Obviously you'd need to define Foldable for your tree, but if you find you'll be doing lots of folding, that's possibly wise
19:35:34 <int3__> yup, that's the plan (defining Foldable)
19:35:41 <jmcarthur> int3__: it kind of explains everything you need to know about what a list is. lists could be defined like this, if one was so inclined:    newtype List a = List (forall r. (a -> (r -> r)) -> (r -> r))     -- note the resemblance to  (r -> r) -> (r -> r)
19:35:55 <Zekka> int3__: You can replace ':' in the above code with your operation, I'm pretty sure
19:36:08 <Zekka> Replace [] with the end of the fold and you have a correct definition of foldr!
19:36:18 <jmcarthur> int3__: in fact, Zekka's code does a map operation on the list first. it maps each value to a (r -> r)... just like the first argument of that representation i just made!
19:37:03 <jmcarthur> int3__: (i'm getting a little advanced for a beginner. mainly i want to show that even simple things like lists have interesting rabbit holes to get lost in.)
19:37:44 <int3__> jmcarthur: haha okay. yeah, I'll need some time to process this. but thanks :D
19:38:14 <Zekka> http://lpaste.net/106683 <- foldr for free!
19:38:26 <Zekka> Then untree is just foldr (:) []
19:39:56 <jmcarthur> man, it's so annoying that existential types with GADTs always require a box
19:40:12 <copumpkin> yes!
19:40:25 * copumpkin pouts
19:40:34 <copumpkin> jmcarthur: isn't there a ticket we can vote for?
19:40:35 <jmcarthur> you make this nice efficient data structure with type checked invariants and then go to hide the type parameters and boom! ... not quite as nice as before
19:40:53 <copumpkin> https://ghc.haskell.org/trac/ghc/ticket/1965
19:41:17 <jmcarthur> opened 7 years ago :(
19:41:30 <jmcarthur> top comment: "Why is this useful?" :(
19:42:51 * hackagebot handle-like 0.0.0.14 - HandleLike class  http://hackage.haskell.org/package/handle-like-0.0.0.14 (YoshikuniJujo)
19:45:31 <copumpkin> jmcarthur: I bumped it
19:45:37 <jmcarthur> yeah i see
19:46:06 <jmcarthur> i thought there was a way to follow tickets and get notifications when they are updated, but i can't find it now...
19:46:32 <jmcarthur> ah, the CC thing, probably. this isn't how i remember it working though
19:47:52 * hackagebot intricacy 0.3 - A game of competitive puzzle-design  http://hackage.haskell.org/package/intricacy-0.3 (mbays)
19:50:44 <Abathurr> Okay, so don't laugh at me for this idea, because I have no idea if it's feasible or not, that's why I'm asking here
19:51:14 <Abathurr> But let's say you have a shit computer with a shit processor, and you have something complex to finish like a huge render in maya or a compilation of code
19:52:04 <Abathurr> My idea is some program/network like p2p that would allow people in "clusters" to share processing time on each others machines. Maybe break up your task into smaller tasks that are sent to toher people's machines. What I want to know is, is this even possible? and 2, if so would it be any faster than doing the rendering (just for example) on your own machine
19:53:01 <cehteh> the answer depends very much on the problem you want to solve
19:53:30 <cehteh> if latency and I/O takes more time than calculating it locally then it wont help
19:54:07 <cehteh> see distcc which works quite well in many cases
19:55:03 <Abathurr> cehteh: That's what I figured. I thought it was a really cool idea but without knowing if it's feasible or not I don't want to start coding
19:55:13 <benzrf> Abathurr: like a beowulf cluster?
19:55:26 <cehteh> next thing is security
19:56:05 <Abathurr> benzrf: I didn't know what that was until you just said it, and I googled it. But yes, I guess pretty much the same thing
19:56:09 <Rufflewind_> jmcarthur: so is it okay then to put something directly in the root namespace? just wanted to know if it's something frowned upon or not
19:56:32 <cehteh> both sides need to trust each other, the sender that the code gets correctly executed, the receiver that the code doesnt do anything harmful
19:57:18 <cehteh> there are some distributed systems .. but all in a rather controlled environment and for specific problems
19:59:20 <cehteh> or see seti at home, gimps or such computing projects
19:59:23 <prototrout> Woohoo, my first post/question to haskell-cafe!
19:59:31 <cehteh> renderfarms for videos etc
20:00:17 <Abathurr> If it were feasible for some generic solution to distributed processing to exist, I'd very much like to code it. Something that would work for an entire class of problems, sure not everything you can dould think of doing but for a great many things...I'll have to research further
20:01:30 <savanni_> Abathurr: that's actually already been done in many major services.  I can't think of anything other than Beowulf that runs on your own infrastructure
20:15:11 <nkpart> lispy_: Hi! Can you get lambdabot to join a channel for me? #bfpg
20:15:21 <benzrf> you can sequence_ with just Foldable, but you need Traversable to sequence
20:15:22 <benzrf> right?
20:17:33 <jmcarthur> Rufflewind_: well, really it's your package and you can do whatever you want. different people have different tastes (and different ways of showing disagreement!)
20:17:52 <nexion> what's a good library to parse CSV files?
20:20:13 <Rufflewind_> jmcarthur: ok! :D
20:24:40 <prototrout> nexion: the "csv" library on Hackage seems to be the most popular (among other Hackage libraries) with cassava being next. Maybe start with those?
20:25:03 <prototrout> (I don't have experience with either, I'm just looking at the ones depended on by the most other packages)
20:26:51 <aaronmblevin> curious if anyone has figured out a way to get vim haskell-mode / ghcmod / ghc working with cabal sandboxes?
20:28:37 <aaronmblevin> I think I'm setting the right g:ghc_staticoptions and g:ghcmod_ghc_options set, but well, still not working ;\
20:32:28 <creichert> aaronmblevin: here is mine: http://lpaste.net/106690
20:32:52 <creichert> not using haskell-mode, though
20:33:12 <sclv_> nexion: i’m not necessarily a big fan of conduit, but the csv-conduit library is really well done, complete, and efficient
20:33:59 <aaronmblevin> creichert: thanks. I saw that and tried, but it didn't work for me. It's unclear to me if the issue is setting the right options or something else.
20:34:14 <sclv_> also lazy-csv is a welltyped product, so i’d trust it pretty automatically :-)
20:37:34 <jmcarthur> copumpkin: fyi, something i made a while ago: http://lpaste.net/106691
20:37:43 <jmcarthur> copumpkin: not that i'm especially proud of using unsafeCoerce
20:39:44 <copumpkin> hah
20:40:46 <copumpkin> kind of cute :)
21:09:49 <btubbs> I'm trying to adapt a GridFS (mongodB-based file storage) library i found online and get it to compile.  code is at http://lpaste.net/106692.  But I'm getting "`monadThrow' is not a (visible) method of class `MonadThrow'"
21:09:56 <btubbs> help?  google is failing me
21:11:21 <benzrf> bye
21:12:02 <Lutin`> btubbs: That's not the right MonadThrow instance
21:12:13 <Lutin`> it's throwM not monadThrow
21:12:20 * btubbs tries
21:12:20 <Lutin`> You're looking at old conduit docs
21:12:26 <btubbs> sounds likely
21:12:33 <btubbs> throwM comes from where?
21:12:57 <btubbs> same module?
21:14:13 <Lutin`> btubbs: exceptions
21:14:49 <Lutin`> Huh
21:15:56 <Lutin`> Data.Conduit.Binary isn't a thing anymore
21:17:41 <btubbs> Lutin`: got disconnected there and might have missed your response
21:17:52 <Lutin`> Data.Conduit.Binary isn't a thing anymore
21:18:18 <btubbs> ohh
21:18:20 <Lutin`> You could try with an older version of conduit but there's probably a better way to fix it
21:18:43 <Lutin`> Oh
21:18:47 <Lutin`> It's in conduit-extra now
21:19:21 <Lutin`> http://hackage.haskell.org/package/conduit-extra-1.1.1/docs/Data-Conduit-Binary.html
21:19:40 <Lutin`> And MonadThrow is now in http://hackage.haskell.org/package/exceptions-0.6.1
21:20:10 <jle`> is ther esome sort of commonly used natural transformation type
21:20:25 <jle`> type NatTrans m m' = forall a. m a -> m' a
21:20:27 <jle`> ?
21:21:21 <Lutin`> jle`: Looks like edwardk's category-extras library has that in it
21:21:28 <Lutin`> But it hasn't been touched since 2008
21:23:21 <tnks> so the part of me with JVM experience is leaning towards locking down all versions in my Cabal files (not using ranges) -- mostly for repeatable builds.
21:23:37 <tnks> but this doesn't at all seem to be the trend; is there an argument otherwise?
21:24:09 <Lutin`> Would you really want to bump your version number for every update in the libraries you depend on?
21:24:11 * hackagebot yesod-angular 0.1.0.0 - Yesod AngularJS integration.  http://hackage.haskell.org/package/yesod-angular-0.1.0.0 (ChristopherReichert)
21:24:16 <copumpkin> I'd kind of like a more nix-like approach in cabal
21:24:25 <copumpkin> Lutin`: sort of, yeah
21:24:48 <tnks> copumpkin: yeah, but I know this is the "burned from Maven/Ivy" part of me shining through.
21:24:56 <Lutin`> I guess at least the 4th number yeah, doesn't sound too rediculous
21:24:59 <tnks> but I feel deterministic builds are super useful.
21:25:15 <tnks> especially when those weird bugs creep in.
21:25:36 <Lutin`> tnks: Maybe just a limit on the minor number?
21:25:46 <Lutin`> copumpkin: What do you mean a more nix-like?
21:26:08 <tnks> Lutin`: well, the real point is for absolute determinism. . .  half-determinism kind of defeats the point.
21:26:12 <Lutin`> Allowing multiple installed versions of libraries?
21:26:51 <tnks> Lutin`: I think copumpkin is saying what I'm saying; reproduceable down to the last bit.
21:27:12 <Lutin`> Yeah I can understand that
21:27:30 <tnks> well, I'm going to run with this personal policy for now.
21:36:11 <Lutin`> I think it would be nice if hackage could enforce some sort of version number policy
21:39:08 <Lutin`> But it's easier said than done
21:42:49 <jle`> tnks: i do that for my own executables/programs that i use in-house
21:43:02 <jle`> but not for any libraries or things i put out for other people to use
21:46:43 <copumpkin> even that isn't fully reproducible though
21:46:53 <copumpkin> you want to enforce that all your dependencies are locked down too
21:49:14 <sclv_> just inline all yr deps
21:49:17 <dmwit> Lutin`: Do you know about the PVP?
21:49:25 <dmwit> Lutin`: It's not enforced, but in my experience it's pretty well followed.
21:49:46 <sclv_> and the deps of your deps
21:49:48 <sclv_> and the deps of those
21:49:57 <sclv_> and distribute the binary of ghc you used with your source
21:50:02 <sclv_> what could go wrong
21:50:05 <dmwit> Well. Followed in the sense that people pick their version numbers according to the PVP. Not necessarily followed in the sense that people give their dependency ranges strictly according to the PVP.
21:51:40 <Lutin`> dmwit: Yeah i know about it
21:51:44 <copumpkin> sclv_: well, if the libraries are just identified by hashes, then the hash of base should be a good proxy for ghc version
21:51:49 <Lutin`> But it would be nice if we could enforce it somehow
21:52:04 <dmwit> Reading back a bit: cabal/ghc already allows you to have multiple versions of a single library installed at once. However it turns out this is only half the needed solution: you also need multiple copies of a single version of a library, built against different dependencies, if you want to really do it right.
21:52:05 <Lutin`> But it's of course a fiddly thing
21:52:30 <copumpkin> dmwit: well, then you need to scope things by the full package they're in
21:52:49 <dmwit> copumpkin: I don't understand this sentence; can you explode it?
21:53:01 <copumpkin> so foo-3.7.1-Data.MyMagicTree.Tree and foo-3.8-Data.MyMagicTree.Tree don't get passed around incompatibly
21:53:20 <Lutin`> Especially when A depends on B depends on C and A removes an instance, B doesn't always update the minor version and package C can break
21:53:29 <copumpkin> if different versions of the same library can't really pass data to each other
21:53:33 <copumpkin> which might be fine
21:53:37 <copumpkin> but you want to make sure of that
21:53:38 <dmwit> copumpkin: I wouldn't expect any single build to involve two different versions of a package.
21:54:14 <copumpkin> dmwit: oh, but if I have one dependency that depends on foo-3.7.1 and has an interface that returns one of its Tree types
21:54:25 <copumpkin> and another one that was built with 3.8 and also returns one of its Tree types
21:54:37 <copumpkin> then two distinct Tree types from Data.MyMagicTree could appear in my program
21:54:43 <copumpkin> with the same name
21:55:10 <dmwit> copumpkin: Yes, it's a good point. I think we don't have a lot of empirical data on how annoying the restriction I'm proposing would be.
21:55:26 <rwbarton> well, we do sort of
21:55:30 <dmwit> copumpkin: In the case you suggest, it *probably* is just a matter of rebuilding one or the other dependency with an updated foo dependency, you see?
21:55:39 <rwbarton> we have no idea how much less annoying it would be to relax the restriction
21:55:47 <copumpkin> dmwit: but each of them might have other constraints that prevent that!
21:55:57 <dmwit> copumpkin: Yes. I acknowledge this.
21:57:11 <sclv_> obviously we should have fewer constraints
21:57:27 <dmwit> copumpkin: In my experience, every time I've built something that included two versions of a single package, I was able to rebuild with a single version of that package instead. But my experience is admittedly limited to projects at the "personal" scale.
21:57:35 <dmwit> Perhaps this property does not scale up.
21:59:08 <dmwit> Well. Or your restriction.
21:59:12 <dmwit> Sounds fine, too.
22:00:01 <dmwit> ...oh, now I understand your complaint.
22:00:12 <dmwit> Because then foo-3.7.1-Data.MyMagic.Tree isn't qualified enough, huh?
22:00:35 <dmwit> Because it needs to be foo-3.7.1-together-with-the-full-dependency-tree-described-here-in-my-import-yuck-Data.MyMagic.Tree.
22:00:38 <dmwit> dang
22:00:48 <copumpkin> ideally
22:01:30 <dmwit> It could be doable. But I agree that is pretty annoying.
22:01:40 <dmwit> You could hash the dependency tree to shorten the description.
22:01:46 <Lutin`> Aren't built packages already identified in the package db with hashes?
22:01:47 <copumpkin> well, it could just be scoped to an "installation" rather than a version
22:01:56 <copumpkin> when resolving things internally
22:02:13 <dmwit> Lutin`: Are those hashes portable across machines?
22:02:27 <Lutin`> Really not sure, probably not
22:02:35 * dmwit doesn't actually know what data participates in the package DB hashes
22:03:21 <ninja_code> I don't want to use MonadTransformers yet. I want to figure out how to do this manually first. How do I  add two functions to the IO monad: i.e. a getState and a setState .... so I can do, inside of an IO monad, shit like    data <- getState .... setState (func data) .... where getState/setState is basically a global variable
22:05:04 <Lutin`> dmwit: That's a no
22:05:08 <Lutin`> https://ghc.haskell.org/trac/ghc/ticket/4012
22:07:00 <dmwit> funny
22:07:04 <dmwit> compilers are complicated
22:07:21 <Lutin`> Maybe something like two hashes
22:07:37 <Lutin`> one from the packages that built it, one from the actual output
22:08:19 <dmwit> ninja_code: can't
22:08:33 <dmwit> ninja_code: However, you might like to look at IORef.
22:08:35 <jle`> ninja_code: it's a bad idea
22:08:44 <jle`> but you can get a similar thing with IORef
22:08:48 <ninja_code> what?
22:08:49 <jle`> the IORef is the "good solution"
22:08:49 <ninja_code> isn't what I want
22:08:54 <jle`> global variables are a bad idea
22:08:54 <ninja_code> basically monadtransfer of state + io ?
22:09:01 <jle`> this is not a monad transformer
22:09:09 <dmwit> ninja_code: All Haskell variables are global. However none of them are mutable.
22:09:15 <joelteon> you'd have to lift the IO actions, not the other way around
22:09:48 <dmwit> ninja_code: If you're willing to pass and receive an extra argument, then yes, what you are describing is essentially StateT s IO.
22:09:58 <jle`> an IORef is sort of like a pointer
22:10:10 <ninja_code> dmwit: yes, I feel like what I want is fairly standard
22:10:17 <ninja_code> I would like to read a tutorial on how to implement this myself
22:10:26 <dmwit> ninja_code: You might like All About Monads.
22:10:27 <ninja_code> for educational purposes
22:10:30 <jle`> you can implement your own StateT s IO
22:10:31 <__pp> Hi -- what's the best way of expressing and conditions using list comprehensions?
22:10:32 <jle`> if you want
22:10:33 <dmwit> ninja_code: It describes State/StateT quite nicely.
22:10:40 <dmwit> ninja_code: It's one of my top three monad tutorials.
22:10:41 <jle`> but it is a bit easier to just use IORefs
22:11:07 <ninja_code> jle`: enough with IORefs, I want, as an educational experience, to understan dmonadtransfers by implementign state+IO myself
22:11:09 <__pp> I have something like [x | x <- [1..5], f x 1 && f x 2 && f x 3]
22:11:17 <__pp> is there a way to express this in a more compact way?
22:11:34 <jle`> here is how to implement your own State+IO monad
22:11:43 <__pp> i.e. without writing all the end clauses explictly
22:11:52 <dmwit> jle`: About to type a monad tutorial into IRC? =)
22:11:53 <jle`> 1) think about functions (s -> IO (a, s))
22:12:00 <enthropy> __pp: you can use commas instead of &&
22:12:04 <hiptobecubic> __pp, ask djinn maybe?
22:12:10 <jle`> consider what it means to chain them
22:12:12 <dmwit> __pp: all (f x) [1,2,3]
22:12:24 <__pp> dmwit: thanks!
22:12:25 <dmwit> __pp: even better: filter (f x) [1..5]
22:12:29 <jle`> andThen :: (s -> IO (a, s)) -> (s -> IO (b, s)) -> (s -> IO (b, s))
22:12:33 <ninja_code> __pp : use and, and [ f x i | i <- [1, 2, 3]]
22:12:36 <dmwit> __pp: uh, sorry, ignore that second one
22:12:38 <rwbarton> better, but also completely different :)
22:12:41 <jle`> write and implement andThen, from scratch
22:12:42 <hiptobecubic> rwbarton, :D
22:12:46 * rwbarton likes list comprehensions
22:13:43 <jle`> so that the semantics are that resulting (s -> IO (b, s)) "runs" the first thing, uses the returned `s`, feeds that into the second thing, "runs" the second thing, and returns the result
22:13:58 <jle`> if you look at the type signature, it should make sense
22:14:28 <jle`> note that in this function, the "result" (a) of the first (s -> IO (a, s)) is "lost"; the second computation can't use it at all
22:14:43 <jle`> so then try a more powerful version
22:15:04 <jle`> andThenWith :: (s -> IO (a, s)) -> (a -> (s -> IO (b, s))) -> (s -> IO (b, s))
22:15:37 <jle`> instead of your second argument being a plain ol (s -> IO (b, s)), it is actually a function that takes an a (the result of the first one) and returns an (s -> IO (b, s))
22:16:10 <jle`> (...um i forgot to explain that s -> IO (b, s) is a a function that takes a state and returns an IO action that computes a resulting value and a modified state)
22:16:31 <jle`> the type signature from andThen should guide you; to an extent also should the type signature of andThenWith
22:16:46 <jle`> finally, realize that typing (s -> IO (a, s)) all the time is a big pain
22:16:52 <jle`> consider making a type synonym
22:17:06 <jle`> type MyIOState s a = s -> IO (a, s)
22:17:10 <ninja_code> jle`: thanks! will study this
22:17:16 <jle`> and seeing that the type signature of andThen looks pretty clean
22:17:30 <jle`> andThen :: MyIOState s a -> MyIOState s b -> MyIOState s b
22:17:33 <jle`> and as does andThenWith
22:17:52 <jle`> andThenWith :: MyIOState s a -> (a -> MyIOState s b) -> MyIOState s b
22:17:53 <jle`> neat!
22:18:12 <jle`> then realize that it looks they look like  (>>) and (>>=) if you squint hard enough
22:18:17 <jle`> that is, if you set m ~ MyIOState s
22:18:24 <jle`> andThenWith :: m a -> (a -> m b) -> m b
22:18:26 <jle`> :O
22:18:40 <jle`> then try to define a Monad instance where (>>=) is andThenWith, and realize that you can't define monad instances on type synonyms! :O
22:19:08 <jle`> so make a newtype MyIOState s a = MyIOState (s -> IO (a, s))
22:19:35 <jle`> realize that record syntax can make this look really neat
22:19:51 <jle`> newtype MyIOState s a = MyIOState { runMyIOState :: s -> IO (a, s) }
22:20:01 <jle`> runMyIOState :: MyIOState s a -> s -> IO (a, s)
22:20:09 <jle`> define return of course
22:20:17 <jle`> also define myLiftIO :: IO a -> MyIOState s a
22:20:28 <jle`> and voila, a State+IO monad, from scratch :)
22:21:01 <ninja_code> jle`: alright, this is what I have so far https://gist.github.com/anonymous/2ef0625a54678c0ac344
22:21:06 <zq> my god
22:21:07 <ninja_code> I think, by line count, I'm atleast 10% of the way there
22:21:10 <kvanb> does anyone know how to compose a pipes pipeline with errors
22:21:23 <zq> the more i read shellcheck's code, the more i want to punch my screen
22:21:47 <jle`> ninja_code: if you're going to go straight into instancing as Monad, you'll need a newtype instead of a type synonym
22:22:04 <jle`> i do recommend figuring out andThen and andThenWith for the actual functions (s -> IO (a, s)) first.  but it's up to you
22:23:00 <jle`> also, remember that MyIOState is not the monad.  look carefully at  andThenWith :: MyIOState s a -> (a -> MyIOState s b) -> MyIOState s b
22:23:14 <jle`> and then at (>>=) :: m a -> (a -> m b) -> m b
22:23:17 <jle`> ...what is `m`, there?
22:23:22 <jle`> (hint: it's not MyIOState)
22:23:39 <ninja_code> jle`: wait, let me get data line corect first
22:23:42 <ninja_code> do you mean I need: https://gist.github.com/anonymous/30961a2f32d53798c0e2
22:24:21 <jle`> ninja_code: why don't you try doing the explicit (s -> IO (a, s)), with the manual andThen :: (s -> IO (a, s)) -> (s -> IO (b, s)) -> (s -> IO (b, s)) first
22:25:00 <ninja_code> because I (perhaps arrogantly) believe if I have the right data, I can get return + >>= to work
22:25:15 <jle`> and then andThenWith :: (s -> IO (a, s)) -> (a -> (s -> IO (b, s)) -> (s -> IO (b, s))
22:25:24 <jle`> ninja_code: actually, even djinn has problems with it
22:25:27 <jle`> :)
22:25:37 <jle`> djinn gets andThen right, but not andThenWith
22:25:52 <dmwit> ninja_code: Why did you change from "s -> IO (a, s)" to "(a, s)" in your second paste?
22:25:53 <ninja_code> is djinn a bot or a human?
22:25:53 <jle`> i say "right" loosely, because djinn actualyl gets them technically correct, but does not know the semantics that i am asking for
22:26:27 <Lutin`> lol
22:26:30 <jle`> @djinn (s -> (a, s)) -> (s -> (b, s)) -> (s -> (b, s))
22:26:30 <lambdabot> f a b c =
22:26:31 <lambdabot>     case b c of
22:26:31 <lambdabot>     (d, _) -> case a c of
22:26:31 <lambdabot>               (_, e) -> (d, e)
22:26:42 <hiptobecubic> :D
22:26:45 <jle`> oh wait no he gets it wrong
22:26:49 <jle`> er, "wrong"
22:26:50 <Lutin`> I'm imagining someone sitting there answering djinn queries
22:26:52 <ninja_code> jle`: can you create a gist with a bunch of type declarations, and then I fill in the definitions?
22:26:58 <hiptobecubic> I love the simplicity of djinn.
22:27:04 <jle`> ninja_code: sure
22:27:05 <ninja_code> jle`: I think that would greatly help me understand how to do this
22:27:17 <hiptobecubic> "What's the simplest, most useless definition I can think of that satisfies this..."
22:28:08 <Lutin`> I'm surprised it's not just `const id` lol
22:28:34 <dmwit> Lutin`: djinn has some heuristics that try to use each argument if possible.
22:28:35 <hiptobecubic> indeed! way to drop the ball, djinn.
22:28:44 <dmwit> It's not dropping the ball, it's on purpose!
22:28:45 <Lutin`> Yeah makes sense
22:29:07 <Lutin`> I really need to stop watching competitive eating videos on youtube
22:29:11 <Lutin`> it's making me hungry
22:29:33 <ninja_code> Lutin`: watch american ninja warrior
22:29:35 <ninja_code> will balance out the calories
22:29:41 <jle`> @djinn (s -> (a, s)) -> (a -> (s -> (b, s))) -> (s -> (b, s))
22:29:41 <lambdabot> f a b c =
22:29:41 <lambdabot>     case a c of
22:29:41 <lambdabot>     (d, e) -> b d e
22:30:19 <jle`> wow good job djinn
22:30:23 <jle`> djinn++
22:30:31 <jle`> ninja_code: https://gist.github.com/mstksg/aa70c9182c387e6f67b1
22:31:08 <ninja_code> jle`: give me 10 ins
22:31:09 <ninja_code> s/ins/mins/
22:31:28 <jle`> mk. i made an edit because i saw a typo.
22:31:54 <kmels> hello how can i specify a package version depending on the compiler version in cabal? for example i want to use base 4.6.* if ghc == 7.6.1 and base 4.7.* if ghc == 7.8.2
22:32:11 <rwbarton> in this example, just leave off the bounds on base
22:32:24 <rwbarton> there is no other version of base that anyone will use with those ghc versions
22:32:27 <dmwit> There's no good way to detect compiler version in a cabal file.
22:32:41 <dmwit> But why not just depend on base >= 4.6 && < 4.8 in your case?
22:32:43 <kmels> okay
22:32:50 <jle`> maybe he just wants to check if the user is doing something sneaky
22:32:51 <rwbarton> even better, drop the upper bound completely
22:32:57 <jle`> "hey, i see what you did"
22:33:10 <kmels> thanks
22:33:12 <dmwit> Whether that's better or not seems to be a bit contentious.
22:33:27 <rwbarton> yes, however, I don't understand why :)
22:33:28 <ninja_code> jle`: this was too fucking trivial: https://gist.github.com/anonymous/704f2029f720736966a1
22:33:37 <jle`> ninja_code: i know right!!
22:33:38 <jle`> :D
22:33:39 <ninja_code> jle`: can I pm you to avoid spamming the channel?
22:33:42 <dmwit> rwbarton: Because if you leave off an upper bound, it can never ever be undone.
22:34:00 <ninja_code> jle`: alright, let's build out the rest of the monad
22:34:03 <dmwit> rwbarton: Which means you will be forever spoiling the constraint solver's view of the world.
22:34:11 <jle`> ninja_code: i don't think people mind too much; we're almost done
22:34:23 <jle`> do you know how to make a newtype of that (s -> IO (a, s)) ?
22:34:35 <ninja_code> no
22:34:41 <jle`> do you know what newtypes are?
22:35:01 <ninja_code> I know how to use "data ... "
22:35:02 <ninja_code> but I've never used newtype
22:35:08 <ninja_code> in short, no, I don't know what newtypes are
22:35:18 <dmwit> You can use data instead.
22:35:28 <jle`> yeah you can just use data
22:35:29 <ninja_code> I don't know any haskell. I just know how to read compiler errors and fix them.
22:35:35 <jle`> make a data type that "contains" a (s -> IO (a, s))
22:35:48 <hiptobecubic> ninja_code, sounds like you know haskell to me
22:36:00 <jle`> just like data Foo a = FooC a "contains" an a
22:36:02 <ninja_code> data MIO s a = MIO (s -> IO (a, s))
22:36:08 <jle`> cool
22:36:19 <jle`> now can you write andThen and andThenWith to use MIO instead?
22:36:33 <jle`> you can use pattern matching to "get" the function back out
22:36:39 <dmwit> rwbarton: I think http://softwaresimply.blogspot.com/2014/05/implicit-blacklisting-for-cabal.html is a good explanation of this point of view. But perhaps you meant you understood but didn't agree.
22:36:41 <jle`> or!!! this is a neat hack/trick
22:36:46 <jle`> you can use a record accessor
22:36:56 <jle`> data MIO s a = MIO { runMIO :: s -> IO (a, s) }
22:37:07 <rwbarton> specifically for base, the upper bound seems quite useless
22:37:08 <jle`> so no pattern matching necessary
22:37:17 <ninja_code> give me a few mins
22:37:18 <dmwit> base changes...
22:37:37 <dmwit> There's no real reason to believe it will never change in a backwards-incompatible way. It's even done that several times recently.
22:37:38 <jle`> work it out either way if you want ;D
22:37:51 <rwbarton> the only way I could ever gain is if I'm using an old compiler and using a package and then a newer version of the package relies on a new feature in base
22:37:55 <rwbarton> of course
22:38:05 <enthropy> dmwit: you can have conditionals like  if impl(ghc >= 7.6)  in a cabal file
22:38:06 <rwbarton> however, in this case I would usually prefer to just move to the newer compiler
22:38:19 <rwbarton> and the newer version of the package
22:38:45 <jle`> ninja_code: glad you think it's trivial, btw.  that's the magic of haskell :)
22:38:54 <jle`> by the way
22:39:00 <jle`> x <- f y; return y
22:39:01 <ninja_code> jle`: https://gist.github.com/anonymous/9e47173d5775a577ffaf <-- this is ugly as fuck though
22:39:03 <jle`> is equivalent to f y
22:39:05 <ninja_code> I think I am doing something wrong with the way I am using MIO
22:39:08 <jle`> (on your line 4-5)
22:39:36 <jle`> ninja_code: does it compile?
22:39:49 <ninja_code> jle`: yes, it compiles :-)
22:40:05 <ninja_code> it's like the frankenstein-monad
22:40:22 <jle`> consider using $ \s ->
22:40:27 <rwbarton> dmwit: the point is that base is unusual in that (given that I've already picked what compiler to build with when I invoked cabal) there's only one version of base I might ever want to use
22:41:02 <jle`> ninja_code: other than that, you did the best you can do with pattern matching
22:41:05 <jle`> congrats
22:41:10 <jle`> now try using the record accessor instead
22:41:22 <dmwit> rwbarton: Okay. Now I understand your point.
22:41:22 <jle`> data MIO s a = MIO { runMIO :: s -> IO (a, s) }
22:41:33 <jle`> remember how to use record accessors?
22:41:44 <jle`> data Foo a = Foo { getFoo :: a }
22:41:53 <ninja_code> jle`: I think https://gist.github.com/anonymous/0dab01f0b7f4342568b6 is what you were pushing for
22:41:54 <ninja_code> what next?
22:41:55 <dmwit> rwbarton: Still, it might be nice for cabal to tell you "couldn't satisfy dependencies" rather than spending an hour building all the dependencies before crapping out. =)
22:41:55 <jle`> getFoo takes a Foo a and pops back out that a
22:42:17 <ninja_code> hmm, let me try that
22:42:20 <jle`> so runMIO takes an MIO s a and pops back out the (s -> IO (a, s))
22:42:30 <enthropy> rwbarton: ghc-6.10 had two base versions I think
22:42:34 <jle`> in type terms, runMIO :: MIO s a -> s -> IO (a, s)
22:42:40 <enthropy> (so it used to make sense?)
22:42:41 <dmwit> enthropy: Strange. I thought I remembered depending on a specific version of base as a proxy for a GHC version in some cabal file, along with a descriptive comment of why. But now I can't find it.
22:43:45 <ninja_code> jle`: alright, so now we have: https://gist.github.com/anonymous/67ec3cd16329547769d6
22:43:47 <ninja_code> integrating the runMIO
22:43:55 <rwbarton> dmwit: I've wasted so much time fighting with --allow-newer that I'm perfectly willing to wait a bit longer for actual errors in the rare case that they arise
22:44:01 <jle`> ninja_code: looks a lot nicer, doesn't it?
22:44:03 <ninja_code> what next?
22:44:24 <jle`> pureMIO :: a -> MIO s a
22:44:27 <ninja_code> jle`: yeah, it looks like I didn't write hte code at all
22:44:37 <jle`> ninja_code: haha is that a good thing?
22:44:51 <dmwit> rwbarton: Hah! point
22:44:59 <Lutin`> jle`: You start on any of those books?
22:45:03 <jle`> pureMIO takes a value and produces a MIO s a that ignores the state and just pops out the `a`, without changing the state
22:45:08 <rwbarton> (actually, the case I mentioned earlier with an old GHC is wrong, that is an argument for lower bounds, not upper bounds)
22:45:31 <ninja_code> jle`: https://gist.github.com/anonymous/39bbd699a441f8d13025
22:45:33 <jle`> ninja_code: then try liftMIO :: IO a -> MIO s a
22:45:51 <jle`> ninja_code: it's the same thing as pureMIO, but it lifts an IO action instead of a normal value
22:46:10 <jle`> so now you can use normal IO a actions in MIO s a, without affecting the state
22:46:23 <jle`> Lutin`: haven't yet :)  but planning on soon :)
22:46:36 <ninja_code> jle`: https://gist.github.com/anonymous/8c0f50a86d2274232a7e -- you should teach an online haskell course
22:46:37 <enthropy> ninja_code: you can define andThen in terms of andThenWith
22:46:57 <Lutin`> ninja_code: Have you seen the NICTA course?
22:46:58 <enthropy> pureMIO = liftMIO . return
22:47:11 <jle`> ninja_code: i basically do ;D
22:47:27 <jle`> ninja_code: now you are ready to just write your Monad instance and MonadIO instance :)
22:47:31 <ninja_code> jle`: https://gist.github.com/anonymous/b4722f25310c0f97c988
22:47:57 <ninja_code> Lutin`: no
22:47:59 <dmwit> enthropy: Okay, I found the cabal file, and it says nothing more than what I claimed before. But I've just tested your suggestion and that seems to work just fine, so I was just wrong.
22:48:08 <ninja_code> jle`: great, how do I do that?
22:48:18 <jle`> ninja_code: first, look at what your monad is
22:48:32 <jle`> compare the type signature of andThenWith to (>>=) :: m a -> (a -> m b) -> m b
22:48:34 <ninja_code> well, pureMIO = return, andThenWith = >>=
22:48:50 <enthropy> dmwit: if people still used hugs, I think you might gain something by using CPP macro MIN_VERSION_base instead of __GLASGOW_HASKELL__
22:48:53 <Lutin`> ninja_code: https://github.com/NICTA/course
22:49:08 <jle`> and of pureMIO to return :: a -> m a
22:49:10 <jle`> what is "m" ?
22:49:14 <jle`> what is "m" in your case?
22:49:23 <ninja_code> m = MIO s
22:49:24 <enthropy> probably the same thing applies to .cabal files
22:49:30 <jle`> ninja_code: cool
22:49:32 <jle`> so
22:49:36 <jle`> instance Monad (MIO s) where ...
22:49:36 <Lutin`> Basically they give you a bunch of undefined functions with a type and explanations of what it should do
22:49:38 <ninja_code> Lutin`: is tonymorris jle` ?
22:49:42 <Lutin`> and you write the functions
22:49:44 <Lutin`> nope
22:49:44 <jle`> instance MonadIO (MIO s) where ...
22:49:50 <dmwit> enthropy: Depends what you're trying to say.
22:50:10 <jle`> http://hackage.haskell.org/package/transformers-0.4.1.0/docs/Control-Monad-IO-Class.html#t:MonadIO
22:50:12 <Lutin`> jle` is https://github.com/mstksg
22:50:20 <dmwit> enthropy: In my cabal file, I'm relying on a particular GHC version because the meaning of the TypeFamilies extension changed between 7.0 and 7.2. =P
22:50:28 <dmwit> enthropy: No good way to make that implementation-independent.
22:50:29 <jle`> or http://jle.im
22:50:35 <ninja_code> jle`: https://gist.github.com/anonymous/02e45bd26de0ae8342ac ... whoa, I'm glad I took you seriously
22:50:37 <jle`> (gotta protect dat branding)
22:51:02 <jle`> ninja_code: you can do some big-time eta-reduction there, but other than that, you got it :)
22:51:14 <jle`> oh, also MonadState
22:51:36 <jle`> http://hackage.haskell.org/package/mtl-2.2.1/docs/Control-Monad-State-Class.html#t:MonadState
22:52:23 <jle`> instance MonadState s (MIO s) where ...
22:52:39 <Lutin`> I need to build my website and do more on github :(
22:52:40 <ninja_code> jle`: hmm http://cv.jle.im/ ... why aren't you at a more prestigious phd program ?
22:52:50 <helge_> Hi guys, anyone care to take a look at http://lpaste.net/106694?
22:53:23 <dmwit> ninja_code: What kind of awful question is that?
22:53:29 <jle`> :P
22:53:40 <ninja_code> dmwit: jle` is clearly prestigious
22:53:43 <ninja_code> s/prestigious/brilliant
22:53:55 <ninja_code> so I'm curious why he's did not choose to go to MIT or somewhere for his PhD
22:54:02 <dmwit> ninja_code: stop
22:54:30 <jle`> their department itself was more closely aligned to my specific research interests, and also i wanted to stay in california.  there are only a couple odedicated compuational sciences phd programs in california; UCSD (my undergrad), andCa private in claremont, sdsu....
22:55:17 <jle`> chapman was the one most aligned to my research interests out of all of them.  and yes this is probably very off topic ^_^
22:56:31 <ninja_code> jle`: if my question was offensive (it was not meant to be), I apologize
22:56:33 <jle`> anyways yeah after instancing everything you should have your very own home-made IO+State monad
22:56:34 <ninja_code> let's forget I ever asked it, and back to MonadState
22:56:49 <jle`> that you can use using runMIO :: MIO s a -> s -> IO (a, s)
22:56:50 <ninja_code> so I need get, put, state
22:57:12 <jle`> you can probably even define your own execMIO :: MIO s a -> s -> IO s, and evalMIO :: MIO s a -> s -> IO a
22:57:42 <jle`> i'm pretty sure you can handle get put and state :)  i think they are actually uniquely defined due to parametricity
22:57:58 <ninja_code> hmm, actually wait
22:58:05 <ninja_code> get I'm a litlte stuck, perhaps psychologically on
22:58:10 <ninja_code> m = (MIO s)
22:58:22 <dmwit> definitely not unique
22:58:25 <jle`> actually put isn't uniquely defined, you can do a very stupid put
22:58:27 <ninja_code> so where it has "m s" ... which I'm goign to rewrite as "m a", it's relaly (MIO m a) ?
22:58:46 <jle`> you can also do a very stupid state i guess
22:59:12 <ninja_code> i feel like an idiot
22:59:13 <ninja_code> I don't see how to write get
22:59:17 <ninja_code> after claiming all this was trivial
22:59:27 <dmwit> Parametricity doesn't help much once you've monomorph'd to IO.
22:59:35 <ninja_code> so the type signature of GEt is (a -> IO (s, a)) right?
22:59:38 <dmwit> Parametricity only helps out with polymorphic stuff.
22:59:55 <dmwit> ninja_code: not quite
22:59:56 <dmwit> :t get
22:59:57 <lambdabot> MonadState s m => m s
23:00:03 <jle`> dmwit: ah true
23:00:36 <jle`> in your MIO "basic functions" term, m s --> MIO s s --> (s -> IO (s, s))
23:00:50 <ninja_code> right
23:00:55 <ninja_code> so it has type (MIO s a)
23:01:00 <jle`> no
23:01:03 <jle`> :t get
23:01:04 <lambdabot> MonadState s m => m s
23:01:08 <jle`> it has type MIO s s
23:01:14 <jle`> because m is MIO s
23:01:25 <ninja_code> :t MonadState
23:01:26 <lambdabot> Not in scope: data constructor ‘MonadState’
23:01:32 <dmwit> Actually, that's quite a subtle point.
23:01:36 <dmwit> And best not dwelt on for now.
23:01:43 <dmwit> But trust jle` that he got the end result right. ;-)
23:01:53 <dmwit> Functional dependencies can wait.
23:01:54 <jle`> ;)
23:01:57 <ninja_code> I have no doubt that jle` is right.
23:02:00 <ninja_code> However, I want to know where I am wrong.
23:02:00 <Lutin`> ninja_code: In that case the value of your state is the current state
23:02:04 <jle`> (i'm not actually that smart btw)
23:02:07 <Lutin`> err
23:02:29 <dmwit> ninja_code: Yeah, the tricky bit is that the "MonadState m s" constraint actually tells you more than just "this is an instance of MonadState".
23:02:43 <Lutin`> ninja_code: Your a is the same type as s in that case because get returns the state
23:02:47 <dmwit> ninja_code: It also picks a *particular* kind of state "s", and says you must return *that* kind of "s".
23:03:05 <dmwit> ninja_code: so the "s" in "MIO s" and the "s" in "m s" have to actually match
23:03:12 <jle`> ninja_code: remember that m a === MIO s a, right?  for your Monad instance
23:03:24 <jle`> so m s === ?
23:03:33 <ninja_code> well
23:03:36 <ninja_code> s is not a free variable
23:03:39 <dmwit> exactly
23:03:42 <ninja_code> so we should rewrite it to somethign else in "m s"
23:03:53 <jle`> er, yeah, that's the subtle point
23:04:06 <ninja_code> the subtle point is that the two s's should be the same s ?
23:04:16 <jle`> yeah, so...it's MIO s s
23:04:18 <dmwit> ninja_code: Yes. And moreover the compiler will actually check that for you.
23:04:26 <jle`> can you write an (s -> IO (s, s)) ?
23:04:27 <dmwit> ninja_code: But it's not obvious directly from the type signature why that should be.
23:04:36 <dmwit> ninja_code: You need to know something special about the MonadState class.
23:04:45 <jle`> there is only one obvious implementation
23:04:59 <ninja_code>  get = MIO $ \s -> return (s, s)
23:05:05 <dmwit> ninja_code: (So I think you were right to be confused at first, actually.)
23:05:23 <Lutin`> Precisely :)
23:05:38 <jle`> remember, the first item in the tuple is your "result" type.  so you want to 'return' the state.  so...yeah.  return (s, s) returns s for the result, and s for the state.
23:05:57 <jle`> maybe it was a bit bad to introduce MonadState, you probably could have just written getMIO, putMIO, and etc. by yourself
23:06:35 <Lutin`> hmm 2 AM I should sleep.
23:06:39 <Lutin`> Night #haskell
23:07:34 <Lutin`> jle`: PM
23:07:44 <ninja_code> hmm
23:07:46 <ninja_code> I am getting weird errors
23:07:51 <ninja_code> I think it is becuase I am using haste.
23:07:54 <ninja_code> switchign over to ghc for a moment.
23:11:09 <ninja_code> https://gist.github.com/anonymous/d0dd675c31fcc6e73f35 <-- weird error on line 19
23:11:43 <jle`> ninja_code: it's the syntax, instance MonadState s (MIO s) where ...
23:11:52 <ninja_code> Main.hs:19:22:     Expecting one more argument to `MIO s'     In the instance declaration for `MonadState (MIO s)'
23:12:03 <ninja_code> err, so it's not "MonadState (MIO s)"
23:12:07 <ninja_code> but "MonadState s (MIO s)" ?
23:12:16 <johnw> correct
23:12:29 <ninja_code> Main.hs:19:10:     Illegal instance declaration for `MonadState s (MIO s)'       (All instance types must be of the form (T a1 ... an)        where a1 ... an are *distinct type variables*,        and each type variable appears at most once in the instance head.        Use -XFlexibleInstances if you want to disable this.)     In the instance declaration for `MonadState s (MIO s)'
23:12:58 <johnw> yes, you'll need FlexibleInstances
23:13:04 <johnw> they are relatively safe
23:13:10 <jle`> oops
23:13:12 <ninja_code> what ?
23:13:14 <ninja_code> can I do this without flexibleInstances ?
23:13:19 <jle`> well
23:13:25 <jle`> you can define your own getMIO :: MIO s s
23:13:29 <jle`> putMIO :: a -> MIO s ()
23:13:31 <jle`> etc.
23:13:35 <jle`> and they'll work fine
23:13:38 <ninja_code> I'm actually using Haste (HS -> js compiler) and would prefer as few of these compiler fpags as possible
23:13:43 <jle`> but you need FlexibleInstances to instance it as MonadState
23:14:01 <jle`> so you can use "generic" get/put etc. for all MonadState's
23:14:42 <jle`> FlexibleInstances is just as mundane as extensions get tho.  besides maybe TupleSections
23:15:15 <ninja_code> gentlemen
23:15:20 <ninja_code> I now have to fork off to resolve this stupidity https://github.com/valderman/haste-compiler/issues/188
23:15:37 <ninja_code> but thanks for all your help; I think I can trake the rest from here after I get stupid haste errors to vanish
23:15:53 <jle`> ninja_code: no worries.  if anything, just forget about MonadState...it's not really worth it, especially for the mtl dependencies
23:16:02 <ninja_code> no no
23:16:03 <ninja_code> I need it
23:16:05 <ninja_code> I will have it
23:16:14 <jle`> you can define your own getMIO, putMIO, modifyMIO, etc.
23:16:16 <jle`> and even stateMIO
23:16:23 <jle`> you just won't be abble to use the same functions for all MonadState's
23:16:24 <ninja_code> ah, true
23:17:50 <jle`> ninja_code: getMIO :: MIO s s, putMIO :: a -> MIO s (), modifyMIO :: (s -> s) -> MIO s (), stateMIO :: (s -> (a, s)) -> MIO s a
23:18:18 <jle`> stateMIO is not really to useful; note that MIO :: (s -> IO (a, s)) -> MIO s a
23:18:26 <jle`> so stateMIO is just MIO without the IO
23:19:24 <ninja_code> jle`: noted, thanks!
23:24:25 * hackagebot http2 0.4.0 - HTTP/2.0 library including HPACK  http://hackage.haskell.org/package/http2-0.4.0 (KazuYamamoto)
23:35:44 <redtricycle> I'm trying to read this bit of code, what does "Right" do? i can't make sense of this http://hackage.haskell.org/package/base-4.7.0.0/docs/Prelude.html#v:Right
23:36:23 <redtricycle> Right (number,"")
23:37:53 <Trollinator> Right is a constructor of the Either datatype.
23:39:24 <redtricycle> What does Either do?
23:39:39 <pdxleif> Are you familiar w/ Maybe?
23:39:48 <redtricycle> yesyes
23:39:55 <redtricycle> oops, lag, meant to type yes once
23:40:31 <Trollinator> data Either a b = Left a | Right b
23:40:43 <pdxleif> You can think if it like Maybe, where instead of simply returning "Nothing" in the case of "failure", returns a value, maybe "why it failed"
23:41:50 <pdxleif> Like Maybe is to Boolean (parameterized on one case), Either is to Maybe (also parameterized on the other case), sorda...
23:42:42 <redtricycle> ah, so
23:42:47 <redtricycle> what would Right (number, "") do?
23:43:13 <redtricycle> It returns an "[DEither number ""
23:43:37 <pdxleif> > Right (5, "foo")
23:43:38 <lambdabot>  Right (5,"foo")
23:43:52 <pdxleif> @type Right (5, "foo")
23:43:53 <lambdabot> Num t => Either a (t, [Char])
23:44:30 <pdxleif> (5, "") is just a tuple of (Int, String)
23:45:15 <redtricycle> ah
23:46:14 <pdxleif> > if True then Right (10, "") else Left [1..10]
23:46:16 <lambdabot>  Right (10,"")
23:46:55 <redtricycle> @type Left [1..10]
23:46:56 <lambdabot> (Num t, Enum t) => Either [t] b
