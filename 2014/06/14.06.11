00:00:02 <levi> gsingh93_: Yup.
00:00:04 <jle`> so it expects a -> LL a
00:00:10 <jle`> but you made it
00:00:14 <jle`> Int -> [Int]
00:01:07 <gsingh93_> levi: can i get a hint?
00:01:24 <jle`> return x = LL [] x would typecheck
00:01:26 <jle`> but
00:01:31 <sbrg> gsingh93_: foldr 'folds from the back'
00:01:31 <jle`> why are you trying to make it a monad?
00:01:49 <levi> gsingh93_: Well, I think you've seen the general idea; just recall how foldr is different from foldl.
00:02:25 <jle`> altern: remember that all monad instances start from "hey, i have a type and i have some useful utility functions for working with that type."
00:02:42 <levi> gsingh93_: It doesn't involve zip or zipWith, but it does involve tupling.
00:03:01 <jle`> "oh hey, this helper function happens to have a type signature that resembles bind"
00:03:31 <altern> jle`: yeah, I have functions generateList for return and inc for bind
00:03:54 <jle`> altern: but those functions don't resemble return and inc
00:03:58 <jle`> er, return and bind
00:04:08 <jle`> at all, really
00:04:56 <jle`> bind and return for a type start off as useful functions for that type on their own right; then if they resemble bind/return, you can instance Monad in order to take advantage of overloaded syntax and existing monad combinators
00:05:14 <jle`> you typically don't make a type and then invent return/bind for that type in a vacuum
00:05:30 <jle`> hm
00:05:38 <jle`> in this case, look at the type signature of return/bind
00:05:44 <jle`> and look at the type signatures of generateList and inc
00:05:52 <gsingh93_> levi: I don't know what tupling is
00:05:55 <jle`> and see that they don't really look like eachother at all unfortunately
00:06:50 <levi> gsingh93_: Using (x,y) patterns to provide multiple arguments or return values.
00:06:54 <pavonia> altern: Start with a Functor instance, what would that look like?
00:06:54 <sbrg> gsingh93_: something like: f e (d, l) = if d then double and put in list and toggle bool else put in list toggle bool.
00:07:39 <jle`> altern: return :: a -> LL a, but generateList :: Int -> LL [Int]
00:07:47 <jle`> er, Int -> [Int]
00:08:01 <wz1000> how do i remove cabal if i lost the make file
00:08:41 <pavonia> What make file?
00:08:53 <wz1000> the make file for cabal
00:09:28 * hackagebot bytable 0.0.0.2 - data from/to ByteString  http://hackage.haskell.org/package/bytable-0.0.0.2 (YoshikuniJujo)
00:09:28 * hackagebot bytable 0.0.0.3 - data from/to ByteString  http://hackage.haskell.org/package/bytable-0.0.0.3 (YoshikuniJujo)
00:09:50 <pavonia> wz1000: Download the file from Hackage?
00:12:21 <wz1000> how do you guys manage your ghc/cabal installations? do you have seperate vms for each project?
00:12:38 <jle`> wz1000: sandboxes and PATH games
00:12:40 <sbrg> wz1000: separate vms? .. no
00:12:46 <sbrg> that seems a bit extreme
00:13:07 <cbarrett> wz1000 check out nix, http://ocharles.org.uk/blog/posts/2014-02-04-how-i-develop-with-nixos.html
00:13:21 <wz1000> my cabal has screwed up five times in the last month
00:13:43 <lfairy> wz1000: use sandboxes. it'll save your life
00:13:58 <catalyst> <wz1000> my cabal has screwed up five times in the last month <-- there's a joke about witchcraft in here somewhere
00:14:07 <sbrg> yeah
00:14:13 <sbrg> you should definitely be using sandboxes
00:16:31 <ocharles> cbarrett: are you using Nix?
00:16:33 <wz1000> what editor do you guys use? whats your workflow? I had an extremely bad time setting up my work environment.
00:17:10 <lfairy> I just use vim, and keep a terminal open with cabal repl
00:17:22 <lfairy> you really don't need an ide unless you
00:17:31 <lfairy> *'re doing something really big
00:17:43 <sbrg> wz1000: What he said. vim + ghcmod-vim
00:17:50 <sbrg> and cabal repl / cabal run in a terminal
00:17:51 <cbarrett> ocharles: I've been experimenting with it.
00:17:59 <ocharles> Cool :)
00:18:00 <frerich> wz1000: I use vim and in another tab of my console I have 'ghci' running for trying things out.
00:18:14 <cbarrett> hoping to write my own nix thing to package some internal software here
00:18:17 <sbrg> I almost always create a sandbox
00:18:19 <frerich> wz1000: ...and ghci has some addons for querying hoogle, getting the point-free for of things etc.
00:18:24 <sbrg> + cabal project for everything these days
00:19:04 <wz1000> I'm using vim too,  but initially I tried using Sublime Haskell and Eclipse FP. Neither of them worked
00:19:29 <nexx> When you get Eclipse FP to work it is nice
00:19:35 <wz1000> then i finally came across this script called vim now
00:19:41 <cbarrett> ocharles: I work on an embedded operating system. internally, updates of the OS are made available both as a whole and also piecemeal (it's quite a large OS actually) by project.
00:20:05 <ocharles> cbarrett: interesting. that could be a fun project to experiment with
00:20:20 <cbarrett> would like to use Nix to represent the OS + toolchain + additional new versions of libraries matrix
00:20:38 <cbarrett> biggest issue I'm having is dealing with older versions of things
00:20:45 <cbarrett> (we can move to #nixos if you'd like)
00:21:03 <sbrg> wz1000: vim + ghcmod-vim is a treat IMO.
00:21:09 <wz1000> yeah i used it on my windows laptop a bit, but it screwed up my eclipse on my linux box
00:21:39 <levi> cbarrett: What OS?
00:21:39 <nexx> I started to use a separated eclipse for it
00:22:01 <cbarrett> levi: I'd rather not say
00:22:59 <frerich> sbrg: Thanks for reminding me of ghcmod-vim, I forgot to read up on it. Looks interesting! Alas, a couple of native libraries as dependencies (I like purely vimscript based plugins since I often switch between three operating systems).
00:24:10 <f0rk_> hello, i am complete noob in haskell but trying to learn. I want to implement a worker, that reads something from external source (e.g. http server) with some interval, for example once in 10 seconds, parses the response and outputs it somewhere for example stdout
00:24:25 * hackagebot wai 3.0.0.1 - Web Application Interface.  http://hackage.haskell.org/package/wai-3.0.0.1 (MichaelSnoyman)
00:24:38 <ocharles> Hmmm, can anyone see a way to combine `a -> Maybe (Put b)` and `b -> Maybe (Put c)` ?
00:25:03 <f0rk_> made a gist with js-like pseudocode to explain the idea https://gist.github.com/DavidKlassen/c8422467d99683e9daad
00:25:06 <ocharles> I need to compose these things without actually running Put, but I don't think it can be done
00:25:45 <f0rk_> and here is haskell code that does some of the job https://github.com/DavidKlassen/haschup/blob/master/src/Haschup.hs
00:26:15 <Zekka> ocharles: Is Put a monad?
00:26:16 <f0rk_> could you help me to find the right direction for solving this task
00:26:24 <ocharles> Zekka: yes
00:26:37 <f0rk_> something to read and learn?
00:26:53 <Zekka> :t (>=>)
00:26:53 <sbrg> frerich: Yeah, I understand. But vimscript is terrible and slow, so plugins that use pure vimscript will always be more limited than one's that don't
00:26:54 <lambdabot> Monad m => (a -> m b) -> (b -> m c) -> a -> m c
00:27:00 <sbrg> (for some uses cases, I mean)
00:27:01 <Zekka> :t (>=>) >=> (>=>)
00:27:02 <lambdabot> Monad m => (a -> m b) -> (b -> m b) -> a -> m b
00:27:14 <Zekka> (Sorry, I always forget how to nest these things)
00:27:15 <frerich> sbrg: I used to think so, too - until I found CtrlP! :)
00:27:18 <sbrg> Especially since vim doesn't let you do async execution by default and so on.
00:27:32 <frerich> Ah, hmm.
00:27:34 <sbrg> frerich: Yeah, I use ctrlp as well. But ctrlp uses stuff like grep or find.
00:27:35 <Zekka> Let me pull out ghci and see if I can remember the proper way to do it
00:27:58 <ocharles> Zekka: Feel free to try, but I don't think it can be done :) Maybe I'm missing something though
00:28:00 <sbrg> but you can imagine how ... colossal it would be to implement a haskell language parser in pure vimscript :P
00:28:06 <f0rk_> for example, i have fetchPlaylist function in https://github.com/DavidKlassen/haschup/blob/master/src/Haschup.hs and want to execute it every 10 seconds and print result
00:28:47 <Zekka> ocharles: Nonsense! I'll stop trying to fool around and guess the correct definition and just do it the straightforward way
00:28:50 <frerich> sbrg: I didn't know that CtrlP uses grep or anything, I always uses it as a file-finder. I.e. CtrlP, then start typing.
00:29:07 <levi> A cool editor I found with a reasonable scripting language is Howl, which uses lua/moonscript for scripting.  It's got basic vim and emacs keybindings and you can write syntax lexers via PEGs.
00:29:14 <sbrg> frerich: yep, and I believe it calls find by default.
00:29:23 <sbrg> i'm not entirely sure, though
00:29:39 <sbrg> I know it can be configured to use grep or ag, for example.
00:29:57 <Peaker> Is there a common package for restricted Functor, Monad, etc instances, to get Set instances?
00:30:29 <Zekka> @djinn Monad m, Monad n => (b -> m (n c)) -> (a -> m (n b)) -> (a -> m (n c))
00:30:30 <lambdabot> Cannot parse command
00:30:34 <Zekka> @djinn help
00:30:35 <lambdabot> -- f cannot be realized.
00:30:56 <Zekka> @djinn (Monad m, Monad n) => (b -> m (n c)) -> (a -> m (n b)) -> (a -> m (n c))
00:30:56 <lambdabot> -- f cannot be realized.
00:31:07 <ocharles> You would need to be able to compose Maybe and Put, and I don't think those monads form a valid composition
00:31:11 <Zekka> @djinn (Monad m, Monad n) => (b -> m c) -> (a -> m b) -> (a -> m c)
00:31:11 <lambdabot> -- f cannot be realized.
00:31:26 <Zekka> ocharles: I think you're right and I'm being silly
00:31:33 <Zekka> @djinn (Monad m) => (b -> m c) -> (a -> m b) -> (a -> m c)
00:31:33 <lambdabot> -- f cannot be realized.
00:31:58 <Zekka> although it's strange that djinn seems to be failing on input where definitions already exist
00:31:59 <shachaf> Djinn doesn't do as much as you think. Probably best to experiment in /msg lambdabot rather than the channel.
00:32:15 <cbarrett> Peaker: do you know about CoYoneda?
00:32:17 <Zekka> shachaf: Oh, sorry about that.
00:32:25 <Peaker> cbarrett: nope
00:32:44 <ocharles> Zekka: basically you'll end up with Maybe (Put (Maybe (Put c)))), which isn't very useful - and no way to squish it together
00:32:45 <ocharles> Hmm.
00:32:55 <shachaf> cbarrett: Yoneda/CoYoneda-style Functor instances for Set don't work very well, and it gets much worse with Monad.
00:33:01 <cbarrett> ah
00:33:06 <cbarrett> interesting
00:33:19 <cbarrett> Not sure I can see that intuitively but I believe you
00:33:29 <shachaf> Well. The issue with the CoYoneda Functor instance is that the set will never shrink, because you save the function applications to the end.
00:33:34 <Peaker> does anyone know how generically mapping over sets in Scala works?
00:33:38 <f0rk_> ok, i'll make a question simpler ) how to run a periodic job in one thread?
00:34:05 <cbarrett> shachaf: I can follow that, but why is that a problem?
00:34:08 <Peaker> Do Scala sets have no constraints on what can be put in them?
00:34:10 <shachaf> E.g. (S.map expensive . S.map (const x)) is very different from S.map (expensive . const x)
00:34:27 * hackagebot hspec2 0.3.0 - Alpha version of Hspec 2.0  http://hackage.haskell.org/package/hspec2-0.3.0 (SimonHengel)
00:34:31 <shachaf> With Set that's not so bad because the set can't shrink but it can't grow either.
00:34:47 <shachaf> But with Monad and a list-comprehension-style expression, it'll grow very easily and never shrink.
00:35:04 <frerich> ocharles: Hrm, I can't seem to get rid of this "Maybe (Put (Maybe c)))" stack either (I just tried fmap'ing the second function onto the result contained in the Maybe yielded by the first function)
00:35:50 <sbrg> f0rk_: forkIO $ forever (threadDelay x >> doStuff) ?
00:35:55 <cbarrett> Ah, OK, I think I'm following now.
00:35:58 <ocharles> It can only be done if you run Put. That would be OK, but the only way to run Put is to run the ByteString Builder too, which is a shame
00:36:01 <cbarrett> shachaf: thank you
00:36:07 <ocharles> I'll have a poke around and see if I can make anything better
00:36:32 <shachaf> It's still a trick worth knowing and useful in lots of cases. Sometimes even for things like Set.
00:36:40 <cbarrett> yeah
00:36:45 <altern> @hoogle: curry
00:36:45 <lambdabot> Maybe you meant: hoogle+ hoogle
00:36:48 <shachaf> Anywhere where right-reassociating everything is good.
00:36:52 <altern> @hoogle curry
00:36:54 <lambdabot> Prelude curry :: ((a, b) -> c) -> a -> b -> c
00:36:54 <lambdabot> Data.Tuple curry :: ((a, b) -> c) -> a -> b -> c
00:36:54 <lambdabot> package curry-base
00:37:05 <cbarrett> shachaf: yeah
00:37:58 <Peaker> shachaf: you confused me above there, when you said "is very different" you meant "should be very different" (in order to get reasonable performance), right?
00:38:24 <shachaf> Peaker: Behaves very differently operationally, even though it computes the same thing.
00:42:15 <f0rk_> sbrg: thanks, actually i think i dont need forkIO if i want the action to be always done in one thread, right?
00:42:47 <Peaker> shachaf: it only behaves operationally differently if you let the Set shrink in intermediate steps -- which is what CoYoneda doesn't do, iiuc?
00:42:47 <Peaker> shachaf: if you use the fused function (expensive . const foo)  you're screwed in any implementation.. to not be screwed in the  fmap expensive . fmap (const foo)   you need to not postpone everything to the end
00:42:47 <sbrg> f0rk_: forkIO starts a separate lightweight thread. If you just want to run a single thread, then no.
00:43:20 <sopvop> Which would be faster? http://lpaste.net/105430
00:44:00 <shachaf> Peaker: What [Co]Yoneda does is fmap fusion.
00:44:10 <shachaf> Which is the reason for the example.
00:44:18 <shachaf> I'm not sure what you mean with postponing everything to the end.
00:45:56 <alpounet> sopvop: well, benchmark them? :p
00:45:58 <Peaker> shachaf: I mean fusion :)
00:46:25 <shachaf> ?
00:46:47 <shachaf> What do you mean by let the Set shrink?
00:46:48 <sopvop> alpounet: That's what I'll do, but didn't want to spend time on something which is probably obvious to someone on #haskell :)
00:47:06 <Peaker> shachaf: the way you phrased it, I thought you said   CoYoneda makes   fmap expensive . fmap (const foo)    very different from    fmap (expensive . const foo)    whereas it's exactly the opposite, and the difference is what you need to make it work properly
00:47:29 <alpounet> sopvop: the actual data type might carry some more weight with him, so I'd lean towards a tiny advantage for #2, but not sure, hence my comment :p
00:47:38 <shachaf> Peaker: Ignoring CoYoneda, those two expressions are very different.
00:47:53 <dbushenko> hi all
00:47:54 <shachaf> Peaker: CoYoneda does map fusion so it turns the former into the latter.
00:48:03 <dbushenko> I think it is not possible to use pattern matching in guards?
00:48:16 <shachaf> With a completely parametric type you usually want that but for something like Set you might not.
00:48:44 <Peaker> shachaf: great, now it all works out :)
00:48:58 <sopvop> alpounet: datatype is just for building sql expressions (it won't be just Builder though, because escaping)
00:51:47 <sopvop> alpounet: I guess function version should be more optimizable if everything is inlined. though I'm not sure if GHC will optimize away if-then-else with constant conditions.
00:53:05 <alpounet> sopvop: it's not really obvious at first sight, so really, whip up a quick criterion bench
00:53:11 <alpounet> you'll get your answer
00:53:28 <sopvop> alpounet: already doing
00:54:39 <alpounet> sopvop: please let me know what the bench says, out of curiosity :)
00:58:54 <vlads> In reactive-banana I need to do something like this: IO a -> Event t a, is this at all possible?
01:09:36 <jle`> vlads: you can't escape IO in general :)
01:14:33 * hackagebot bytable 0.0.0.4 - data from/to ByteString  http://hackage.haskell.org/package/bytable-0.0.0.4 (YoshikuniJujo)
01:19:33 <wz1000> ok so i'm getting  [14 of 50] Compiling General.Web      ( src/General/Web.hs, dist/build/General/Web.o )
01:19:33 <wz1000> src/General/Web.hs:50:26: Not in scope: â€˜responseToSourceâ€™
01:19:34 * hackagebot hsqml 0.3.1.0 - Haskell binding for Qt Quick  http://hackage.haskell.org/package/hsqml-0.3.1.0 (RobinKay)
01:19:43 <wz1000> when tyring to install hoogle
01:20:00 <wz1000> *trying
01:20:10 <bartavelle> on one of my systems I have ghc 7.6.2, on the other ghc 7.8.2. When I import Network.HTTP.Conduit and Data.Default, the 7.8 system can see the Default instance for Request, but the 7.6 one can't
01:20:20 <bartavelle> packages seem to be the same version on both systems
01:20:22 <bartavelle> hummm
01:21:14 <bartavelle> anybody had the kind of weird bugs ?
01:21:19 <bartavelle> that kind
01:24:04 <alpounet> bartavelle: isn't there a conditional directive or something in http-conduit that makes that happen?
01:24:14 <bartavelle> ah that could be it
01:29:07 <jle`> anyone know why haddock isn't parsing '^' as a link to the (^) function
01:29:15 <jle`> it just shows up as literally '^'
01:29:24 <jle`> is there some guide to haddock formatting somewhere?
01:32:08 <wz1000> how can i clear the cabal cache?
01:34:36 * hackagebot entropy 0.3.1 - A platform independent entropy source  http://hackage.haskell.org/package/entropy-0.3.1 (ThomasDuBuisson)
01:36:27 <dcoutts_> jle`: try '(^)'
01:39:15 <jle`> dcoutts_: does not work either, apparently
01:39:31 <jle`> btw, '*' works where '(*)' does not, for some reason
01:39:37 * hackagebot hspec-wai 0.0.0 - Experimental Hspec support for testing WAI applications (depends on hspec2!)  http://hackage.haskell.org/package/hspec-wai-0.0.0 (SimonHengel)
01:39:43 <dcoutts_> jle`: does haddock give a warning that it cannot find a link target?
01:39:50 <jle`> dcoutts_: it does
01:40:42 <ion> Can you really call something platform-independent when itâ€™s platform-dependent and happens to support a number of them?
01:40:50 <ion> Re: hackagebot
01:41:28 <jle`> ion: perhaps the intent is to say that the platform is abstracted away
01:41:39 <jle`> from an API standpoint
01:41:40 <dcoutts_> jle`: ok that's a good start, so have a look at the details there
01:41:50 <jle`> and not from an actual...platform independent standpoint
01:41:55 <jle`> in terms of compilation/working
01:44:38 * hackagebot bytable 0.0.0.5 - data from/to ByteString  http://hackage.haskell.org/package/bytable-0.0.0.5 (YoshikuniJujo)
01:45:05 <piezoid> hi
01:45:17 <piezoid> I have trouble to build vector in sandbox for profiling : https://gist.github.com/Piezoid/3ca81b0016a62930b3f9
01:47:39 <piezoid> I could build all the dependencies of xml-conduit in this environment, but vector is causing me some trouble
01:52:53 <wz1000> hoogle uses responseToSource from Network.Wai, which i can find no trace of over here: http://hackage.haskell.org/package/wai-3.0.0.1/docs/src/Network-Wai.html#responseToSource
01:53:46 <wz1000> so i can't build hoogle. what should i do?
01:54:17 <vlads> jle`: I found an answer to my question from a creator of reactive-banana. That's not a general case, because this situation happens already inside of some interaction. Although the answer was not trivial at all.
01:56:45 <lfairy> wz1000: does it exist in an older version?
01:56:59 <wz1000> i can't find it
01:57:25 <lfairy> well, it must be there somewhere
01:57:31 <lfairy> iirc wai was updated quite recently
01:57:39 <lfairy> I remember reading the 3.0 announcement
01:58:36 <wz1000> found it
01:58:54 <wz1000> how do i install  an old version of wai in a sandbox
02:01:09 <sopvop> alpounet: well, looks like GHC optimizes both to almost equal performance. And data version is a little bit (like 5%) faster. I guess that means that I should should bench on better inputs.
02:01:21 <alpounet> sopvop: yeah, larger
02:03:37 <lfairy> wz1000: clear the sandbox, then reinstall with --constraint='wai == blahblahblah'
02:04:41 * hackagebot rest-wai 0.1.0.1 - Rest driver for WAI applications.  http://hackage.haskell.org/package/rest-wai-0.1.0.1 (SebastiaanVisser)
02:05:36 <wz1000> thanks, it worked
02:05:51 <wz1000> should i report this to the hoogle dev
02:06:40 <lfairy> wz1000: go for it
02:08:29 <jle`> wz1000: he's pretty friendly
02:08:59 <wz1000> using the bug tracker is fine, right?
02:19:52 * hackagebot hourglass 0.2.2 - simple performant time related library  http://hackage.haskell.org/package/hourglass-0.2.2 (VincentHanquez)
02:29:10 <PassionateC> @help
02:29:11 <lambdabot> help <command>. Ask for help for <command>. Try 'list' for all commands
02:29:38 <PassionateC> @help list
02:29:38 <lambdabot> list [module|command]. Show commands for [module] or the module providing [command].
02:29:45 <PassionateC> list
02:29:57 <BoR0> @list Control.Monad
02:29:57 <lambdabot> No module "Control.Monad" loaded
02:30:06 <BoR0> @list Main
02:30:07 <lambdabot> No module "Main" loaded
02:30:09 <dramforever> @list unmtl
02:30:09 <lambdabot> unmtl provides: unmtl
02:30:16 <dramforever> @listmodules
02:30:16 <lambdabot> activity base bf check compose dice dict djinn dummy elite eval filter free fresh haddock help hoogle instances irc karma localtime more oeis offlineRC pl pointful poll pretty quote search slap source spell system tell ticker todo topic type undo unlambda unmtl version where
02:30:24 <dramforever> there you go
02:30:43 <alpounet> poll? uh
02:31:03 <PassionateC> @list
02:31:03 <lambdabot> What module?  Try @listmodules for some ideas.
02:31:21 * Kinnison fears the confusion here is that 'module' does not mean haskell module, but lambdabot module in this context
02:31:31 <PassionateC> @listmodules
02:31:32 <lambdabot> activity base bf check compose dice dict djinn dummy elite eval filter free fresh haddock help hoogle instances irc karma localtime more oeis offlineRC pl pointful poll pretty quote search slap source spell system tell ticker todo topic type undo unlambda unmtl version where
02:31:42 <vanila> @bf ++++++++.
02:31:43 <lambdabot>  Done.
02:36:14 * dramforever just used /me
02:37:11 <dabblingInHs> Hi there I need an advice on how to structure soime Haskell code better: http://lpaste.net/105435
02:37:23 <dabblingInHs> *some
02:37:39 <dabblingInHs> is there some better way sorting tuples?
02:38:00 <dramforever> ha ha, #haskell, the best haskell code refactoring tool!
02:40:01 <Cale> dabblingInHs: If you order the tuples the other way, sortGT would become flip compare
02:40:09 <Cale> er...
02:40:30 <Cale> Wait, you want reverse ordering on the second components?
02:40:44 <Cale> and ordinary ordering on the first?
02:41:06 <Cale> sortGT = flip (comparing snd) <> comparing fst
02:41:21 <Cale> Using the Monoid instance for Ordering (and functions)
02:42:27 <dabblingInHs> Cale: ok thank i try that
02:42:41 <Cale> > sortBy (flip (comparing snd) <> comparing fst) . map (ap (,) length) . group . sort . words $ "one three three three four four four two two four eight eight six six six six six six"
02:42:42 <lambdabot>  [(["six","six","six","six","six","six"],6),(["four","four","four","four"],4)...
02:43:07 <Cale> er
02:43:23 <Cale> no, that seems right
02:43:44 <pavonia> dabblingInHs: Btw, you can remove the "let" on lines following the first let-statement if you indent them properly
02:44:23 <Qfwfq> @type liftM2 (<<<) (&&&) (>>>)
02:44:25 <lambdabot> Arrow a => a b c -> a c c' -> a b (c, c')
02:44:27 * Qfwfq giggles
02:47:58 <dabblingInHs> Cale: whats the import im missing
02:48:01 <Cale> dabblingInHs: http://lpaste.net/105435
02:48:05 <Cale> see annotation :)
02:48:33 <Cale> ap (,) length is possibly less clear than (\x -> (x, length x)) but I couldn't resist
02:50:19 <frerich> Cale: Neat! I wasn't aware of the "<>" synonym, my reflex was to go for 'mconcat' (which is what I do in case I want to sort by multiple criteria).
02:55:57 <t7> @hoogle (a -> Maybe a) -> a -> a
02:55:59 <lambdabot> Data.IntMap.Strict updateMax :: (a -> Maybe a) -> IntMap a -> IntMap a
02:55:59 <lambdabot> Data.IntMap.Lazy updateMax :: (a -> Maybe a) -> IntMap a -> IntMap a
02:56:00 <lambdabot> Data.IntMap.Strict updateMin :: (a -> Maybe a) -> IntMap a -> IntMap a
02:57:25 <dabblingInHs> Cale: I want to reverse the function application with do notation but get indention errors , can you help me? : http://lpaste.net/105437
02:57:51 <Cale> dabblingInHs: That's not how do notation works
02:58:20 <Cale> dabblingInHs: If you really wanted to, you could invent some new infix operator
02:58:42 <dabblingInHs> Cale: in F# i used the |> operator
02:58:47 <dabblingInHs> it worked quite simple
02:58:50 <Cale> x |> f = f x
02:59:11 <Axman6> |> is just $ with the arguments reversed
02:59:38 <Cale> I think it's kind of uglier than just using proper function composition though
03:00:00 <jle`> aye, and it's much less composable
03:00:01 * hackagebot typeparams 0.0.4 - Lens-like interface for type level parameters; allows unboxed unboxed vectors and supercompilation  http://hackage.haskell.org/package/typeparams-0.0.4 (MikeIzbicki)
03:00:03 * hackagebot sloane 1.8 - A command line interface to Sloane's On-Line Encyclopedia of Integer Sequences  http://hackage.haskell.org/package/sloane-1.8 (AndersClaesson)
03:00:12 <jle`> i guess nothing is more composable than composition, though
03:00:13 <t7> @hoogle fromMaybe
03:00:13 <lambdabot> Data.Maybe fromMaybe :: a -> Maybe a -> a
03:00:41 <dabblingInHs> Cale: yes but I wanted an example with top down notion
03:00:53 <jle`> dabblingInHs: do notation actually doesn't desugar that way
03:01:07 <jle`> if you wanted to use (|>), you cand o it top-down
03:02:33 <dabblingInHs> jle`: whats the import for thaT=
03:02:36 <dabblingInHs> ?
03:03:11 <jle`> dabblingInHs: i've added an annotation containg how you would do it top down i think
03:03:26 <jle`> (|>) isn't in any standard libraries because it leads to somewhat unidiomatic haskell code
03:03:45 <dabblingInHs> jle`: thanks!
03:03:51 <jle`> there is (&) from Control.Lens but you wouldn't be using it for something like this
03:04:22 <jle`> you know, when going to a new language with new idioms, it might be counterproductive to try to force old models of thinking and old idioms/coding styles into a new environment
03:04:27 <jle`> that's just my two cents
03:04:38 <jle`> i mean, a C programmer can try to learn F# by using for loops
03:04:40 <dabblingInHs> I will add a note that this is *not* idiomatic haskell :D
03:04:47 <jle`> and doing everything he can to try to make for loops work
03:04:56 <jle`> instead of just learning how to use higher order functions
03:05:02 <jle`> dabblingInHs: :)
03:05:29 <jle`> the advantage of the main' compositional stye is that you can now "break out" parts of it
03:05:31 <jle`> and name them
03:05:59 <jle`> for example, say you had f . group . sort . words $ s
03:06:08 <jle`> and you thought that group . sort . words is something nice to be given a name
03:06:24 <jle`> you can say groupSortWords = group . sort . words, and then you just have f . groupSortWords $ s
03:06:38 <jle`> whereas, for the applicational style using |> or ($), it's not so simple
03:06:51 <jle`> s |> words |> sort |> group |> f ...
03:07:03 <jle`> words |> sort |> group isn't even "a thing"
03:07:30 <jle`> because it associates like (((s |> words) |> sort) |> group) |> f
03:07:36 <jle`> so you can't really "pull out" words-sort-group
03:07:42 <jle`> and name it
03:08:05 <t7> @pl  \i c -> fromMaybe c (Map.lookup i ms >>= target bs c)
03:08:05 <lambdabot> ap fromMaybe . (. target bs) . (>>=) . flip Map.lookup ms
03:08:15 <pharaun> that's terrible
03:08:42 <dabblingInHs> jle`: hm I still got compile error
03:08:55 <jle`> dabblingInHs: i misspelld words :)
03:09:06 <dabblingInHs> jle`: no still
03:09:08 <jle`> also i might not have defined (|>) with the right fixity/association
03:09:12 <jle`> what is the error?
03:09:31 <dabblingInHs> cannot mix |> and infix...
03:09:36 <dabblingInHs> yes
03:09:42 <dabblingInHs> https://www.fpcomplete.com/project/44911/BrS2YIxVsd
03:11:00 <jle`> dabblingInHs: you can add infixl 1 |>
03:11:13 <jle`> or add parentheses around (group . sort)
03:12:36 <jle`> also it seems that FPComplete is using some version of ghc where he monad instance of (->) a isn't in Prelude...
03:13:02 <dabblingInHs> jle`: src/Main.hs@17:13-17:15No instance for (Monad ((->) [String])),   arising from a use of `ap' Possible fix:  add an instance declaration for (Monad ((->) [String]))
03:13:13 <jle`> so you can find out whre you can import it or you can use (<*>) from Control.Applicative ( (<*>) === ap for monads)...or just do it pointfully
03:13:22 <jle`> ap (,) length or (,) <*> length is bad form anyway
03:13:28 <dabblingInHs> jle`:  :Dquite complicated for that simple example
03:13:41 <jle`> try
03:13:44 <dabblingInHs> jle`: maybe i go with the "idiomatiC" haskell version..
03:13:51 <jle`> (\str -> (str, length str))
03:13:55 <jle`> instead of ap (,) length
03:14:01 <jle`> nobody actaully does ap (,) length i hope >_>
03:14:07 * Maxdamantus wonders why ((->) [String]) can't be written (String ->)
03:14:09 <jle`> where did you get that from?
03:14:43 <dabblingInHs> jle`: (\str -> (str, length str))
03:14:55 <dabblingInHs> jle`:  yes thats even better, ok it works now , tanks a lot!
03:15:01 <jle`> no problem :)
03:15:30 <jle`> i would probably do (\str -> (str, length str)) as (id &&& length), with (&&&) from Control.Arrow
03:15:37 <jle`> but the lambda version is just fine
03:15:38 <knappador> What's a web framework barely written over the top of HTTP?  I need an application server process.  Database backends would be appreciated, but bolt-on is always great.
03:15:40 <jle`> nobody will ever be confused
03:16:13 <knappador> Looking for opinions as I port my child over to Haskell tomorrow to satisfy my very week demands for a "real" webpage
03:16:16 <knappador> weak*
03:16:37 <jle`> knappador: have you looked at scotty?
03:17:01 <knappador> sounds like star trek.  I like it.
03:17:17 <tdammers> scotty is lovely
03:17:19 <jle`> the name is a star trek pun i think
03:17:32 <jle`> i use scotty for my blog
03:17:34 <tdammers> yeah, because it defaults to the Warp web server
03:17:54 <knappador> haha
03:18:03 <knappador> Warp is a collection of threads?
03:18:09 <knappador> Reminds me of something....
03:18:12 <tdammers> warp is a web server...
03:18:38 <tdammers> of course, if scotty is too much still, you could just code against warp directly
03:18:40 <knappador> https://github.com/knappador/wing/blob/master/src/warp.c
03:19:20 <knappador> I would like to have a future, like I should learn something I might use in a medium size project
03:19:42 <jle`> knappador: if it is worth anything, my blog was my first medium size project
03:19:53 <jle`> pulling together scotty + blaze templating + persistent for database
03:20:06 <knappador> hahaha...I'm already so pleased that I don't have to learn 90% of bullshit I needed to know to make gunicorn run a Django app quickly
03:20:08 <jle`> and sort of putting together all of the integration from scratch
03:20:17 <dabblingInHs> thanks a lot @all for your Patience!
03:20:19 <tdammers> jle`: I'm doing the same, except I'm using plain HDBC for the database
03:20:20 <knappador> jle`: what does scotty give you on top of warp?
03:20:38 <jle`> knappador: i think some sort of routing system
03:20:39 <tdammers> knappador: routing, JSON output, and a bit of nitty-gritty
03:21:00 <tdammers> and, generally, a monad (transformer if you want) that abstracts away most of the underlying server
03:21:03 <jle`> if you've ever used sinatra for ruby, it occupies a similar sort of space
03:21:28 <tdammers> or flask in python, minus the default template bindings
03:21:39 <knappador> and what are some template systems?
03:21:49 <knappador> gotta have templates with html/css else die
03:21:59 <jle`> blaze, that haskell implementation of mustache, hamlet
03:22:00 <knappador> I'm just doing my home page tomorrow, so it's okay
03:22:01 <Axman6> there's hamlet from the yesod project
03:22:03 <tdammers> blaze, hxt, shakespeare, and a bunch more
03:22:28 <jle`> yesod has its js+css+html templating system with a system for each
03:22:33 <jle`> i actually am pretty happy with sass
03:22:33 <tdammers> I've written my own partial blaze drop-in replacement so that I can use it as a monad transformer
03:22:34 <Axman6> (hamlet is one of the shakespearian template languages)
03:22:59 <tdammers> I've also written two other template systems in haskell
03:23:07 <jle`> i've switched over to faye when i can for js
03:23:09 <tdammers> I think I see a pattern there :x
03:23:23 <knappador> faye?
03:23:28 <tdammers> sass is pretty damn awesome, yeah
03:23:37 <tdammers> Fay.
03:23:37 <Axman6> Fay
03:23:42 <jle`> er yeah, fay
03:23:44 <jle`> sry
03:23:45 <tdammers> compiles haskell to javascript
03:23:45 <knappador> sass and less similar?
03:23:52 <knappador> hahaha nice
03:23:56 <knappador> sounds fun
03:24:05 <tdammers> there's also ghcjs
03:24:16 <tdammers> but personally, I still prefer writing JS directly
03:24:17 <knappador> did I mention I like the new JS server-side rendering frameworks but hate their DB reliance on Mongo?
03:24:23 <jle`> ghcjs is slightly larger than faye so i don't really think i'd use it for just small scripts
03:24:28 <jle`> like i did
03:24:37 <jle`> here is a nice intro to fay, http://ocharles.org.uk/blog/posts/2013-12-23-24-days-of-hackage-fay.html
03:24:48 <tdammers> throw in require.js, underscore.js, and, god forbid, jquery, and you have a workable base
03:24:54 <knappador> I'm porting a very static site over to Haskell tomorrow.
03:25:08 <jle`> i liked blaze when i used it, but i sort of missed the whole html-as-data thing
03:25:23 <jle`> because blaze is an embedded dsl so it's actual haskel code and you can use all the normal haskell combinators
03:25:25 <chrisdone> blaze-ftw
03:25:44 <jle`> but it turned html into...logic/programming, for me
03:25:47 <tdammers> the fact that Markup is a monad is just a convenience thing, really
03:25:47 <knappador> MVC sort of rocks for fat client programming, so I'm not sure how this works in Haskell at all.
03:25:56 <jle`> sometimes i liked looking at it as just data
03:26:04 <jle`> but on the other hand blaze is pretty fast
03:26:10 <tdammers> it *is* just data
03:26:19 <tdammers> your data structures simply happen to also implement Monad
03:26:30 <chrisdone> i use an MVC style server-side for my web apps
03:26:30 <tdammers> just like List and Maybe
03:26:35 <tdammers> sort of
03:26:40 <jle`> i mean more like the API
03:27:01 <jle`> constructing your data is done with...normal haskell programming tools
03:27:01 <chrisdone> i have a Model monad and a Controller monad and a Html monad =3
03:27:09 <knappador> One web page port over to Haskell.  Some future.  Scotty?  Warp?  Do I need any other stack pieces?
03:27:17 <tdammers> jle`: oh, you mean you want the template itself to be data?
03:27:44 <jle`> tdammers: i'm not sure how to phrase it properly without misconveying what i am trying to say
03:27:51 <chrisdone> knappador: scotty, yesod, snap are all fine for that
03:27:51 <knappador> Client-side js rendering is pretty sexy
03:27:58 <jle`> but there's a difference when your template is like... a plaintext file that is interpreted
03:28:14 <jle`> instead of an .hs file that you program to assemble your data structure
03:28:16 <jle`> that is compiled
03:28:22 <chrisdone> knappador: https://www.fpcomplete.com/school/starting-with-haskell/libraries-and-frameworks/basics-of-yesod/yesod-1#hello-piggies-
03:28:31 <tdammers> knappador: it's also stupid if you need to support anything that's not a human equipped with a full-blown graphical web browser with javascript enabled and nothing blocked
03:28:47 <tdammers> jle`: yes, I think I know what you mean
03:28:49 <knappador> what is?
03:29:01 <Walther> What is the current state of Haskell-based "web-app" platforms? I use hakyll for personal static site generation, but what about the more versatile "app" things like Yesod, Snap, etc - what is the hottest of the hottest and most actively developed at the moment?
03:29:01 <tdammers> jle`: you want templates to be files that are interpreted at runtime
03:29:02 <knappador> tdammers: what is?
03:29:13 <tdammers> knappador: client-side js rendering
03:29:35 <jle`> tdammers: it's not the runtime nature exactly, i think it's just more of the general approach/how you view it
03:29:39 <jle`> i can't quite put it into concrete terms
03:29:50 <knappador> tdammers:   it's good for the first server hit and.....honestly I could spit out a json and have the client consume the goddamned json
03:29:56 <jle`> at least not at 3:30am
03:30:05 <tdammers> jle`: thing is, you *can* comfortably do type-safe compile-time templating in Haskell, so that's what everyone does
03:30:07 <Axman6> I've been considering using some JS to render a rather large table but haven't figured out how to do it. I probably shouldn't do that though
03:30:08 <chrisdone> walther: yesod and snap are both actively developed
03:30:14 <chrisdone> i don't know about happstack
03:30:24 <jle`> tdammers: yeah, i wouldn't mind that
03:30:25 <knappador> snap seems to have the most history
03:30:28 <tdammers> knappador: you can, but then Google will hate you
03:30:36 <jle`> tdammers: but it's different when it's literally a .hs file
03:30:38 <tdammers> knappador: as well as the blind
03:30:42 <jle`> where you can use al your normal haskell functions and logic
03:30:50 <tdammers> anyway, lunchtime
03:31:02 <chrisdone> tdammers: blind people don't care about javascript like that
03:31:10 <chrisdone> we're not in the 90's anymore
03:31:27 <knappador> tdammers:  No, the point of doing the server-side render is to get the data into the page before sending it out, but if you have a js client, the client needs to know hwo the page state is.  You can just initialize the client with a json that tells it how to pretend it just did the render.
03:32:22 <knappador> I had this argument all over this crap about "isomorphic" js frameworks.  I think some web developers decided they were writing tron or something.
03:33:02 <jle`> at least math terms are cool i guess
03:33:15 <jle`> cool enough that people would pretend to understand them for cool credits
03:33:29 <jle`> maybe haskell has a chance to become mainstream after all
03:33:48 <knappador> Pass the client state by writing it as a JSON and jsut have the client consume it (to sync with page data).  Bet fay can do this.
03:33:55 <knappador> With just a little work.
03:34:30 <knappador> Write the javascript to consume a json whenever it loads into the browser and then the client will be under the impression that it just rendered the page that haskell indeed rendered already server-side
03:34:51 <chrisdone> you can do that but i'd hate you for it =p
03:35:01 <knappador> and if fay compiles haskell, then your server-side render code in haskell now operates in javascript as well?
03:35:03 <knappador> hehe
03:35:08 <chrisdone> there's nothing worse than a content page that loads its content with javascript
03:35:22 <Axman6> yeah google
03:35:23 <chrisdone> like, the browser can do that. *well*. *better*. *faster*
03:35:53 <chrisdone> every time i have to load n megs of data to open google+ which is just some pictures and comments i despair
03:36:00 <jle`> it's not like browsers were invented to do that or something
03:36:05 <knappador> chrisdone:  if you load up a fat client with a lot of html/css, the client has no idea what just happened.
03:36:34 <knappador> so you put a json with the initialization data into the page so that the javascript can replay what happened in the render step on the server
03:36:47 <chrisdone> https://groups.google.com/forum/#!msg/haskell-cafe/daGwuBpxfVc/0K4j3EhV3S4J
03:36:50 <chrisdone> look at that page
03:37:04 <chrisdone> how long does it take to load?
03:37:57 <chrisdone> takes about 5 seconds for me
03:38:26 <chrisdone> 5 seconds. i have a broadband connection. connected to google. there are about 5 paragraphs in the page. 5 seconds. in 2014
03:38:34 <chrisdone> why? because javascript
03:39:17 <Axman6> chrisdone: it's over 10s for me according to safari's dev tools
03:39:39 <hipsterslapfight> more like because google
03:39:42 <hipsterslapfight> 48 requests for that page
03:40:15 <knappador> ~3s for a full refresh
03:40:33 <chrisdone> mhm
03:40:44 <chrisdone> now try this page: http://forum.dlang.org/thread/ln5nad$13sl$1@digitalmars.com
03:41:13 <chrisdone> the whole D forum is a shining example of how fast a web site can be when you don't clog it with crap
03:41:15 <Axman6> 1.45s
03:41:21 <knappador> about 1.05s
03:41:28 <Axman6> (refreshed though)
03:41:29 <yogurt_truck> it's nothing to do with javascript
03:41:31 <hipsterslapfight> 15 requests instead of almost 50, it's a very big difference
03:41:35 <hipsterslapfight> nothing to do with JS though
03:41:39 <knappador> round trips are the killer
03:41:43 <yogurt_truck> 14 requests vs. 40+ requests
03:42:00 <chrisdone> yogurt_truck: it's everything to do with javascript. why do you think you have to wait so long to see any content?
03:42:11 <yogurt_truck> chrisdone: because of the requests
03:42:13 <hipsterslapfight> because it's still requesting it?
03:42:23 <yogurt_truck> chrisdone: open your dev tools
03:42:35 <yogurt_truck> the right end of the request panel ends at the 5 seconds mark
03:42:41 <yogurt_truck> that's pretty awful
03:42:43 <knappador> js has a lot of rendering tools that can be used to write rich clients
03:42:45 <chrisdone> because we load the page first, then we load its resources, then we run the javascript, which makes a request for content
03:42:47 <knappador> but you need to initialize all that
03:42:48 <yogurt_truck> and the comparison just doesn't make sense
03:43:00 <knappador> like react.js etc
03:43:02 <chrisdone> the D forum just serves you the content straight-up like a fast food order
03:43:18 <t7> @hoogle (a -> Maybe b) -> [a] -> [b]
03:43:21 <lambdabot> Data.Maybe mapMaybe :: (a -> Maybe b) -> [a] -> [b]
03:43:21 <lambdabot> Prelude mapM :: Monad m => (a -> m b) -> [a] -> m [b]
03:43:21 <lambdabot> Control.Monad mapM :: Monad m => (a -> m b) -> [a] -> m [b]
03:43:22 <knappador> I could use some McDonalds.
03:43:36 <chrisdone> like it was in the 90's and early 2000's. browsers and internet connections are way better now, but we don't know that because we're using stupid architectures like that
03:43:39 <yogurt_truck> the D forum also doesn't make a billion requests that take 5 second to complete xD
03:43:39 <knappador> So is Scotty going to do me more justice than Snap in the long run?
03:43:57 <chrisdone> yogurt_truck: yes. 9 of the requests from google groups are HXT requests
03:44:13 <jle`> knappador: if you want to do learn how to do everything yourself, go with scotty
03:44:15 <knappador> using a fat client that doesn't know what to load until the js runs is page speed death
03:44:22 <chrisdone> knappador: it depends on your app. if it's a throwaway web site that does something dumb, use scotty
03:44:40 <yogurt_truck> scotty is lovely
03:44:41 <knappador> so I'll get perhaps more experience using snap?
03:44:55 <chrisdone> more experience implementing basic web things yourself for no reason, sure
03:45:07 <knappador> lol
03:45:22 <chrisdone> for an ajaxy site, it's okay
03:45:32 <yogurt_truck> I think you'll get more experience by going through the process of using scotty and then reaching its limits
03:45:33 <chrisdone> tryhaskell uses it, for example. very dumb site
03:47:02 <knappador> Reddit seems to reflect some of my opinion about web programming in general
03:47:13 <knappador> thread on haskell frameworks
03:50:34 <vlads> is there any clear way to perform [Functor a] -> Functor [a] ? I have accomplished this with (\ [a,b,c,d] -> (\ k l m n -> [k, l, m, n]) <$> a <*> b <*> c <*> d) but that's awful
03:51:25 <zwer> vladan is your Functor also a Monad?
03:51:39 <zwer> :t sequence
03:51:40 <lambdabot> Monad m => [m a] -> m [a]
03:52:00 <vlads> not a Monad, unfortunately
03:52:47 <shachaf> vlads: You should say e.g. [F a] -> F [a], where F is an instance of Functor.
03:52:54 <pjdelport> :t sequenceA
03:52:55 <lambdabot>     Not in scope: â€˜sequenceAâ€™
03:52:55 <lambdabot>     Perhaps you meant one of these:
03:52:55 <lambdabot>       â€˜T.sequenceAâ€™ (imported from Data.Traversable),
03:52:57 <shachaf> Otherwise it's very confusing.
03:53:00 <pjdelport> :t T.sequenceA
03:53:01 <lambdabot> (Traversable t, Applicative f) => t (f a) -> f (t a)
03:53:20 <pjdelport> vlads: There's that, but you can't do it with Functor alone.
03:53:20 <benj_> um. Anyone else have this problem? Trying to 'cabal install hoogle', in a sandbox, with ghc 7.8.2: "src/General/Web.hs:50:26: Not in scope: ‘responseToSource’"
03:53:25 <shachaf> And also that way we can figure out that F is also an instance of Applicative, and then we can use sequenceA like pjdelport said. :-)
03:54:12 <user> how to download webpage?
03:54:22 <vlads> shachaf, pjdelport: thank you, I will write clearer next time. Will now go try.
03:54:24 <chrisdone> how do i downloaded web page?
03:54:30 <snoyberg> benj_: i sent a pull request to neil a day or two ago, but he's on vacation
03:54:35 <chrisdone> user: use http-client or http-conduit, perhaps =)
03:54:47 <snoyberg> benj_: cabal install hoogle --constraint 'wai < 3.0' should do the trick
03:55:09 <benj_> snoyberg, thank you!
03:55:15 <snoyberg> sure
03:55:42 <user> "Could not find module `Network.HTTP.Client", what to do?
03:56:26 <snoyberg> user: cabal install http-client
03:57:05 <vlads> shachaf, pjdelport: that worked like a charm
03:57:25 <user> cabal install http-client
03:57:31 <shachaf> vlads: I wonder what your type is.
03:57:42 <user> it tell me Not in scope: 'cabal'
03:57:57 <user> in winGHCi
03:58:11 <snoyberg> user: you need to run it from the command line, to install the missing package
03:58:16 <snoyberg> user: then you can use it from winGHCi
03:58:25 <benj_> hm, I can see the value now of explicitly importing names. 'Not in scope' doesn't tell you much about where the author thought the name was supposed to exist.
03:58:30 <vlads> shachaf: it's (Behavior t a) from reactive-banana
03:59:29 <pjdelport> vlads: To understand it better, in this case, sequenceA for lists (as the traversable) is basically just: foldr (liftA2 (:)) (pure [])
03:59:58 <pjdelport> (or foldr (\x xs -> (:) <$> x <*> xs) (pure []) without using liftA2)
04:01:09 <pjdelport> which you'll probably recognize as an Applicative version of the identity fold, foldr (:) []
04:02:24 <pjdelport> The sequenceA from Traversable just makes that generic across other Traversable instances, not just lists, as the container for the Applicative being sequenced.
04:07:58 <user> where the api for http-client?
04:09:47 <user> sorry, I was disconnected for a bit
04:09:53 <user> did anyone answer?
04:10:36 <Maior> user: what have you tried so far?
04:10:40 <osfameron> user: doesn't look like it.  Have you looked on hackage?  e.g. https://hackage.haskell.org/package/http-client
04:10:59 <Maior> user: (have you tried googling for "haskell http-client" for example)
04:11:34 <osfameron> in fact that's what  did to get to the hackage link :D
04:16:35 <sopvop> Is there a way to make cabal repl not die on errors?
04:16:37 <sopvop> I guess it is because of sandbox add-source
04:20:18 <tdammers> knappador: if you want just a barebones web server with a monad that can do routing, and little else, then go with scotty
04:20:18 <tdammers> knappador: if you want something that gives you a working web app with minimal effort, use one of that larger frameworks
04:20:18 <tdammers> snap, yesod, happstack
04:21:28 <user> looked in hoogle, and found that page osfameron pointed too, didn't know what to do with it, but found some links in , and followed them now, now reading ...
04:21:32 <user> thanks
04:33:12 <hseg> http://lpaste.net/105445 I'm trying to use equational reasoning to fuse this with another function. However, I can't find the appropriate recursion scheme for this function. Help?
04:38:41 <frerich> Is anybody here Benjamin Kovach?
05:41:01 <lightandlight> silence broken
05:42:56 <user> I tried doing this:  x' <- get "http://www.bbc.co.uk/news/" concatHandler'
05:43:01 <user> and it didn't work
05:43:16 <user> in WinGHCi
05:43:29 <user> <interactive>:10:7: Not in scope: `get'
05:43:56 <benzrf> user: dont use winghci
05:44:00 <benzrf> use gnu/linux and ghci
05:44:02 <benzrf> (y)
05:44:17 <user> aha
05:45:20 <user> tried with ghci and got same result
05:45:27 <user> and I am on windows
05:45:52 <user> are you telling me that haskell work only on linux?
05:46:08 <exicer> If I wanted to match the beginning of a word with attoparsec, what would be the best way to do that ?
05:46:22 <dottedmag> user: he is just kidding
05:46:36 <benzrf> user: i'd just like to interect for a moment
05:46:48 <benzrf> what you're referring to as linux is actually gnu/linux
05:46:55 <benzrf> or as i've taken to calling it, gnu plus linux
05:47:04 <user> I am new to haskell
05:47:27 <user> and just trying to figure out how to make it work
05:47:53 <user> there is this web page http://hackage.haskell.org/package/http-streams-0.3.1.0/docs/Network-Http-Client.html
05:48:00 <user> that have the 'get' function
05:48:14 <dottedmag> user: Check some tutorials first: http://learnyouahaskell.com/
05:48:18 <user> I imported Network.Http.Client, and get is not in scope
05:48:18 <Nikentic> Sliter hÃ¥ret av mig. FP = krÃ¥ngligt.
05:48:21 <dottedmag> Uhm.
05:48:37 <user> I read half of the tutorial
05:48:42 <dottedmag> o
05:48:42 <dottedmag> k
05:49:00 <user> Now I try to do something real
05:49:21 <user> I can do it in other language, but I want to try in Haskell
05:49:33 <user> but first I need to read a webpage
05:49:38 <Nikentic> Lite nytt tankesÃ¤tt
05:49:42 <Nikentic> wtf
05:49:49 <Nikentic> This IRC software is pretty weird
05:50:47 <dottedmag> user: Are you using Haskell Platform?
05:50:58 <user> yes
05:51:34 <dottedmag> 2013.4.0.0?
05:51:51 <user> 2013.2.0.0
05:51:56 <dottedmag> err, yes, this one, sorry.
05:52:41 <dottedmag> I don't see Network.HTTP.Client in the modules distributed with Platform, actually.
05:52:55 <user> I got it with cabal
05:53:05 <dottedmag> So the latest version, I suppose. Right?
05:53:10 <dottedmag> 0.7.1.1
05:53:23 <user> I don't know what the version of it
05:53:51 <user> but I installed http-client just now, so it could be latest
05:54:50 <dottedmag> Right.
05:55:16 <dottedmag> then import Network.Http.Client does not bring 'get' into a scope?
05:55:28 <user> correct
05:55:31 <dottedmag> Try :t openConnection
05:55:38 <dottedmag> To see whether anything is in scope.
05:56:18 <user> also not in scope
05:56:48 <dottedmag> That is definitely weird.
05:56:53 <user> I see "Prelude Network.HTTP.Client> "
05:56:59 <user> as my prompt
05:57:05 <dottedmag> Just a sec
05:57:10 <simukis_> you can see package version by running ghc-pkg list
05:57:17 <dottedmag> Oh, it's a different namespace.
05:57:44 <dottedmag> user: Not sure why, but there are Network.HTTP.Client and Network.Http.Client
05:58:07 <frerich> dottedmag: Ouch...
05:58:09 <user> aha
05:58:16 <user> I am in HTTP
05:58:49 <dottedmag> Or is it just due to case-insensivity of fs?
05:59:02 <dottedmag> Nope, I can't import Network.Http.Client on case-insensitive HFS
05:59:21 <dottedmag> user: Try installing http-streams and importing lowercase one (you were reading documentation for)
05:59:39 <user> my packages are lower case
05:59:52 <dottedmag> user: importing Network.Http.Client, not Network.HTTP.Client
06:00:38 <user> in can't find that module
06:00:56 <dottedmag> user: have you installed http-stream using cabal?
06:00:58 <crobbins> user: you need to install http-streams
06:01:04 <user> <no location info>:    Could not find module `Network.Http.Client'    Perhaps you meant Network.HTTP.Client (from http-client-0.3.3.1)
06:01:04 <user>  
06:01:25 <crobbins> user: you installed http-client, not http-streams
06:01:37 <crobbins> that library that you are looking at is http-streams
06:01:44 <user> ah
06:01:48 <dottedmag> user: See, it says "from http-client", and if you look at documentation page, you'll see it is for library "http-streams"
06:02:08 <dottedmag> Pretty confusing, one should admit.
06:02:46 <crobbins> yeah, i can't imagine why we should have two different modules: Network.HTTP and Network.Http
06:02:50 <user> I am to confused to realize what I am confused about :S
06:03:25 <user> ok, I installed http-streams
06:03:32 <user> do I need to restart the ghci program?
06:03:52 <crobbins> probably
06:03:55 <dottedmag> try importing and restart if it does not work
06:04:19 <crobbins> you'll also need to enable OverloadedStrings to pass the URL like that
06:04:41 <crobbins> in ghci you can do :set -XOverloadedStrings
06:04:45 <user> still not working
06:05:03 <crobbins> user: post your error, did you enable OverloadedStrings?
06:05:18 <crobbins> worked for me
06:05:31 <user> Prelude> import Network.Http.Client <no location info>: Could not find module `Network.Http.Client' Perhaps you meant Network.HTTP.Client (from http-client-0.3.3.1) Network.Http.Types (from http-common-0.7.1.1)
06:05:32 <user>  
06:06:08 <crobbins> exit ghci and re-open it, looks like it can't find http-streams
06:06:12 <crobbins> you installed it, right?
06:06:35 <user> I installed yes, and restarted WinGHCi, this is after the restart
06:06:44 <user> ah
06:06:50 <user> there was an error in the install
06:06:54 <user> I didn't see it
06:07:21 <user> http-streams-0.7.1.1 depends on HsOpenSSL-0.10.4 which failed to install.
06:07:43 <user> openssl-streams-1.1.0.2 depends on HsOpenSSL-0.10.4 which failed to install.
06:07:53 <crobbins> user: look right above that, why did HsOpenSSL fail to install?
06:08:53 <user> Missing C libraries: eay32, ssl32
06:08:53 <user>  
06:11:28 <user> what should I do?
06:11:58 <crobbins> user: this seems similar, yet unhelpful: http://stackoverflow.com/questions/20624669/cabal-installing-hsopenssl-w-64-bit-openssl-libs-on-windows-server-2008
06:15:02 <vlads> > (\a -> init . filter (not . null . drop (length a - 2)) . subsequences $ a) [1..5] -- could anyone remind me of a name for this function, as I remember there should be something like this
06:15:04 <lambdabot>  [[1,2,3,4],[1,2,3,5],[1,2,4,5],[1,3,4,5],[2,3,4,5]]
06:17:11 <vhz> user: which OS are you using ?
06:17:21 <crobbins> he's using windows
06:18:00 <benzrf> lel
06:18:24 <vhz> user: don't use http-stream then, unless you know how to install openssl on windows and such.
06:19:25 <crobbins> vlads: not sure, but this seems like the same: filter ((==4) . length) . subsequences
06:19:28 <crobbins> > filter ((==4) . length) . subsequences
06:19:29 <lambdabot>  No instance for (Data.Typeable.Internal.Typeable a0)
06:19:29 <lambdabot>    arising from a use of â€˜M474708462568441662830502.show_M4747084625684416628...
06:19:29 <lambdabot>  The type variable â€˜a0â€™ is ambiguous
06:19:29 <lambdabot>  Note: there are several potential instances:
06:19:30 <lambdabot>    instance Data.Typeable.Internal.Typeable Data.Dynamic.Dynamic
06:19:42 <crobbins> oops
06:19:43 <crobbins> > filter ((==4) . length) . subsequences $ [1..5]
06:19:44 <lambdabot>  [[1,2,3,4],[1,2,3,5],[1,2,4,5],[1,3,4,5],[2,3,4,5]]
06:33:53 <vlads1> crobbins: that's correct, but afair there is some function for this purpose
06:35:19 <vlads1> crobbins: besides, I can not always rely on a known length, that was just an example
06:46:53 <piezo> it is possible to write a tail recursive insert function (for ordered list) ?
06:47:10 <mmachenry> piezo: Yes
06:47:54 <piezo> the Data.List is not, and I'm having trouble to write the TR version
06:48:03 <vanila> piezo, why do you want it tail recursive?
06:48:24 <vanila> since haskell is lazy, tail recursive programs aren't usually desirable
06:48:38 <piezo> for performance in a strict-spine context
06:48:42 <vanila> oh okay
06:48:47 <vanila> well you coudl accumulate a difference lst
06:49:25 <vanila> insert elt (x:xs) accum | elt > x = = insert elt xs (accum . (x:))
06:49:44 <vanila> insert elt (x:xs) accum | elt <= x = accum (elt : xs)
06:50:24 <piezo> ok thanks
06:52:08 <piezo> i'm writing a general update function (the predicate is like [a] -> Maybe [a]), but the context should be the same
07:00:33 <f-a> ghci runtime linker woes http://paste.debian.net/104458/ what do?
07:03:45 <nicoo> Does GHC has tailrec-modulo-constructor for spine-strict data-structures ?
07:05:38 * hackagebot formatting 3.1.4 - Combinator-based type-safe formatting (like printf() or FORMAT)  http://hackage.haskell.org/package/formatting-3.1.4 (ChrisDone)
07:10:39 * hackagebot buildwrapper 0.8.6 - A library and an executable that provide an easy API for a Haskell IDE  http://hackage.haskell.org/package/buildwrapper-0.8.6 (JeanPhilippeMoresmau)
07:11:07 <Tjr> What does hackagebot announce exactly? People uploading new versions on some central repository?
07:11:23 * Tjr assumes hackagebot isn't doing random ads.
07:11:27 <f-a> on hackage
07:11:59 <Tjr> can anybody upload stuff?
07:12:07 <bergmark> yes
07:12:08 <f-a> you need an account
07:12:39 <bergmark> but you can no longer upload new versions of other people's packages ;-)
07:12:52 <Tjr> bergmark: sounds scary.
07:12:58 <Clint> definitely a downgrade
07:13:20 <Tjr> what else is lurking in there, if you used to be able to write into others' code?
07:15:26 <bergmark> Tjr: you still needed an account, and at that point the useranem had to be your real name
07:15:38 <bergmark> and you could only register by sending an email to the admins
07:16:04 <Tjr> ah, so it's "you need to blackmail me to get an account in the first place" type of security.
07:17:06 <bergmark> Tjr: :-)
07:17:37 <bergmark> Tjr: package signing is coming
07:17:50 <bergmark> it was one of the projects the IHG decided to fund
07:19:41 <Tjr> Sounds like what  the Debian package system did.
07:20:29 <bergmark> i kinda wish they had kept the real name policy
07:21:38 <Tjr> They probably wouldn't have asked for a passport from Joe Q Miller anyway.
07:22:52 <Adeon> can I access non-exported stuff in a module with ghci? I'm thinking there is no way but I cannot be sure
07:22:56 <bergmark> i don't mean for security, i'm just not interested in seeing that happycat234 uploaded a new package
07:27:44 <Desheng> are the "lazyfoo tutorials ported to Haskell" a decent way to learn Haskell game programming or would they be considered too imperative?
07:28:31 <f-a> I liked it Desheng
07:28:55 <Desheng> ok thanks
07:28:55 <f-a> you can sever game-logic from using SDL (i.e. displaying and input), Desheng
07:32:00 <bgamari> How do I :load multiple modules at a time in ghci?
07:32:05 <chrisdone> :l X Y
07:32:13 <bgamari> It seems like I can only get one in the namespace at a time
07:32:21 <bgamari> chrisdone, with that method
07:32:28 <chrisdone> hm, what about with :m + X Y afterwards?
07:32:57 <bgamari> chrisdone, It doesn't complain when I do that but it also doesn't bring anything into scope
07:33:16 <chrisdone> are you using -fobject-code?
07:33:17 <bgamari> oh, never mind
07:33:23 <bgamari> all is well
07:33:25 <bgamari> chrisdone, thanks!
07:33:34 <chrisdone> er, welcome =)
07:35:25 <Black-Heaven> Hi all, I have this error: http://lpaste.net/105453 I understand why it fails (State is * -> * -> *, while s is * -> *), but I can't figure out how to write this, I tried s t o, but it isn't correct because k waits for a (* -> *), so if you have any hints, please tell me. Thanks by advance.
07:37:41 <Black-Heaven> (my goal is to combine Kleisli arrows)
07:38:44 <hexagoxel> the .cabal file of package named "foo" must be named "foo.cabal" (and not Foo.cabal), correct?
07:38:59 <dcoutts_> yes
07:38:59 <bergmark> i don't think that matters
07:39:01 <hexagoxel> because cabal check accepts the latter, but hackage seems not
07:39:10 <bergmark> but i trust dcoutts_ :_)
07:39:57 <dcoutts_> hexagoxel: I suppose that's a bug due to cabal not considering case-insensitive file systems properly
07:40:04 <dcoutts_> hexagoxel: on osx or windows?
07:40:11 <hexagoxel> negative, linux
07:40:14 <dcoutts_> hmm
07:40:22 <hexagoxel> should i file a bug somewhere?
07:40:26 <dcoutts_> odd, I thought cabal check did check that
07:40:38 <dcoutts_> hexagoxel: please, in the github issue tracker
07:44:28 <Black-Heaven> (for example : Kleisli (State s) i o' -> Kleisli (State s') o' o -> Sthing [s, s'] i o State Kleisli)
07:44:42 <Tjr> Black-Heaven: (newbie here). That looks like black magic. Where can I read up on that?
07:45:13 <pot> Benjamin Pearce's Types and PRogramming Languages
07:45:52 <Black-Heaven> Tjr: don't worry, I'm new too ^^ search for GADT, Higher Order Kind etc.
07:46:10 <Tjr> thanks
07:58:07 <aljosa> cabal sandbox init doesn't work: "cabal: unrecognised command: sandbox (try --help)". is this a known issue?
07:58:40 <Reite> Id guess you have an old version of cabal
07:58:43 <Reite> do cabal --version
07:58:44 <Kinnison> aye, old cabal
07:59:31 <f-a> http://stackoverflow.com/a/3392935 <-- can somebody tell me what "you should use the -x option to ld" means?
08:00:48 * hackagebot entropy 0.3.2 - A platform independent entropy source  http://hackage.haskell.org/package/entropy-0.3.2 (ThomasDuBuisson)
08:08:58 <subleq> how do you pronounce <*>?
08:09:37 <darthdeus> lessthanstargreaterthan
08:10:01 <jcsims> according to this answer, it's 'apply' http://stackoverflow.com/a/7747115
08:10:33 <Sculptor> all seeing eye
08:10:57 <chrisdone> ap
08:11:46 <subleq> ok
08:12:28 <subleq> i watched the haxl talk by simonmar, and he talked about hot code swapping with ghc. can i read more about that somewhere?
08:13:25 <bergmark> it's in 7.8 iirc so hopefully it's documented somewhere ;-o
08:13:54 <darthdeus> subleq: can you link the talk?
08:14:29 <joshc> I'm assuming it's episode 4 from haskellcast.com?
08:14:42 <subleq> darthdeus: https://skillsmatter.com/skillscasts/4429-simon-marlow
08:15:20 <subleq> all i've found about it is http://www.haskell.org/ghc/docs/latest/html/libraries/ghc-7.8.2/ObjLink.html
08:15:25 <darthdeus> subleq: thanks!
08:15:37 <subleq> which is far too low level for me
08:16:55 <subleq> i'd really like a higher-level overview with an example
08:19:06 <f-a> argh, I am getting mad with a "duplicate definition for symbol" linker error. How can I find packages which depend on the particular package that is giving me problem (i.e. vty)?
08:20:26 <user> what should I use?
08:20:26 <tommd> f-a: Which packages?
08:20:50 * hackagebot persistent-mongoDB 1.3.3.1 - Backend for the persistent library using mongoDB.  http://hackage.haskell.org/package/persistent-mongoDB-1.3.3.1 (GregWeber)
08:20:54 <user> vhz?
08:21:01 <user> what should I use?
08:22:10 <f-a> tommd: http://markmail.org/message/x4v2ghr32kpoz7fg I am experiencing this error, if that might help explaining the problem / my request.
08:22:17 <tommd> f-a: you can pass linker options, including -x, through ghc via -optl
08:23:40 <tommd> f-a: Did you re-install bytestring somewhere along the line?  That is strongly discouraged. I would build from a sandbox and see how things go (cabal sandbox ; cabal install)
08:23:54 <f-a> that was not me. I have a problem with vty
08:24:34 <tommd> I know you're not working on the same problem for 6 years.  So it isn't the same error then.
08:25:15 <f-a> http://paste.debian.net/104458/ my error is this, tommd
08:27:28 <rwbarton> you might be sort of stuck. it seems plausible that you really need two static libraries which both have a symbol __x86.get_pc_thunk.bx
08:27:48 <rwbarton> upgrading to ghc 7.8 would probably fix this
08:28:00 <f-a> argh, thanks rwbarton
08:35:05 <bernalex> is there some syntax sugar for making an endless list of []s?
08:35:25 <f-a> [1..] ? repeat s?
08:35:27 <simukis_> bernalex: repeat []
08:35:31 <Saizan> > repeat []
08:35:33 <lambdabot>  [[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],...
08:35:50 <bernalex> ah, of course! thanks simukis_
08:40:08 <vlads1> does anyone use wxHaskell? I came across a bug, it seems, but not sure if it's only for me, or maybe I am not using things right: http://lpaste.net/105458
08:40:20 <vlads1> could you check this out?
08:46:35 <pepper_chico> hey guys, how do I reload a module in ghci? there's a list inside some script which I have already loaded, :l :add seems to ignore it for loading
08:46:45 <f-a> :r
08:46:52 <f-a> :reload
08:47:38 <pepper_chico> ah, ok
08:47:42 <pepper_chico> fair
08:49:20 <pepper_chico> it's not really a module, I'm in the process of learning, I've made a script like this http://lpaste.net/8279163849521758208
08:49:37 <pepper_chico> it's called sample.hs
08:49:54 <pepper_chico> in ghci it's *Main
08:50:08 <pepper_chico> :r sample.hs doesn't work, :r Main works
08:50:20 <pepper_chico> but still, no reload of updated data
08:50:25 <f-a> just
08:50:26 <f-a> :r
08:50:49 <pepper_chico> no reload
08:50:54 <f-a> :s
08:52:06 <pepper_chico> aaaaa, nevermind, sorry =/ fromList should be producing a map with unique keys, hence I was not noticing it was the same stuff in the source
08:52:18 <pepper_chico> my bad
08:52:23 <f-a> ohhh
08:52:26 <f-a> now I get it too
08:52:41 <f-a> well, nicely spotted
08:52:52 <pepper_chico> dumb me
08:53:26 <f-a> smart you!
08:54:15 <pepper_chico> tks anyway, see ya
08:54:25 <f-a> o/~
08:56:07 <btcNeverSleeps> hey all... I'm trying to port a tiny function from Clojure (where it works fine) to Haskell. I'm getting "*** Exception: stack overflow" and I don't know how I should fix it. Here's the tiny function: lpaste.net/105461
08:57:06 <Enzo18>  Here some videos. I hope you like them! http://bit.ly/1odJivR
08:57:17 <Maior> btcNeverSleeps: http://www.haskell.org/haskellwiki/Tail_recursion may be of interest
08:57:21 <btcNeverSleeps> In Clojure I simply replaced the recursive call with 'recur' (instead of the function name) and then everything is smooth. However here in Haskell I'm a bit confused (I'm not even sure it's a TCO problem).
08:57:31 <ab9rf> ten million stack frames? :)
08:57:33 --- mode: ChanServ set +o glguy
08:57:39 --- mode: glguy set +b *!*@37.221.173.229
08:57:44 --- kick: Enzo18 was kicked by glguy (Your behavior is not conducive to the desired environment.)
08:58:04 <syllogismos> what is the best way to read .csv files in haskell, they are just rows of numers of type Double
08:58:17 <bergmark> syllogismos: i'm using cassava, i like it
08:58:37 <bergmark> btcNeverSleeps: works for me!
08:59:02 --- mode: glguy set -o+b glguy *18!~*18@*$#haskell-ops
09:01:28 <btcNever`> (ouch, my Emacs / erc just freaked out)
09:01:44 <user> which library for getting web pages is good on windows?
09:02:35 <ab9rf> btcNeverSleeps: that code works for me.. takes a little while but it runs fine
09:03:40 <glguy> btcNever`: http://lpaste.net/105462
09:03:50 <tolt> user: what exactly are you trying to do?
09:03:51 <glguy> btcNever`: The issue is that you're building up a large thunk in the second argument
09:04:04 <ab9rf> strictness might help
09:04:12 <glguy> btcNever`: One way to solve that is with a bang-pattern to tell GHC that it should evaluate that argument strictly
09:04:13 <user> tolt get a url
09:04:25 <btcNever`> glguy: oh gotcha
09:04:29 <ab9rf> user: what does "get" mean?
09:04:41 <user> you know wget?
09:04:46 <ion> HTTP GET probably
09:05:11 <tolt>  the response GET?
09:05:11 <tolt> If that's what you're trying to do you might look at HTTP Conduit or wreq
09:05:11 <user> I want a function that receive a URL and return the page content
09:05:30 <user> would that work in windows?
09:05:31 <btcNever`> ab9rf: could you try with 10x more calls see if my version works too on your setup? (out of curiosity...)
09:06:05 <user> last time I tried to install Http.Client and it didn't install
09:06:06 <glguy> btcNever`: Also if you'd compiled that code (rather than running in GHCi) GHC (at least in 7.8.2) would have determined that that argument should be strict
09:06:31 <tolt> did you have a dependency issue or a build issue?
09:06:55 <btcNever`> glguy: ah, I'm beginning with Haskell and still am on 7.4 (I think)
09:07:09 <ab9rf> btcNever`: in ghci it does require 1.6 gigabytes of memory to execute
09:07:23 <btcNever`> glguy: 7.4.1... And I did try it both with ghci (from Emacs) and by compiling with ghc from a terminal :)
09:07:48 <glguy> btcNever`: Did you use -O to turn on optimizations?
09:07:57 <ab9rf> btcNever`: if you're on a 32-bit arch it would probably fail
09:08:19 <ab9rf> btcNever`: i'm on a 64-bit arch so 32-bit apps have a 3G user space
09:08:21 <glguy> 7.4.1 is a couple years old now
09:08:30 <btcNever`> ab9rf: 64 bits, tried with -O2
09:09:18 <mmmm_> What is the opposite of dependent types?
09:09:31 <mmmm_> How do you describe it?
09:09:56 <btcNever`> glguy: I'll upgrade (7.4.1 was the stock Haskell for my Debian distro)
09:10:28 <glguy> 2 years behind is pretty good for a debian ;-)
09:10:45 <ab9rf> hm, adding strictness only helps a bit, cuts memory by 0.3 G and runtime by 5 seconds
09:10:46 <btcNever`> ab9rf: anyway I'll need way more than 100 millions calls... It's to create (and solve) Rivest's time lock crypto puzzles: people.csail.mit.edu/rivest/lcs35-puzzle-description.txt
09:10:56 * hackagebot libssh2 0.2.0.2 - FFI bindings to libssh2 SSH2 client library (http://libssh2.org/)  http://hackage.haskell.org/package/libssh2-0.2.0.2 (IlyaPortnov)
09:13:37 <rwbarton> hmm, for me the original decrypt program stack overflows in ghci but not when compiled with -O0, I wonder why
09:13:39 <btcNever`> ab9rf: you mean the bang pattern to add strictness still requires 1.3 GB of memory? (how can I see mem usage)
09:14:10 <ab9rf> btcNever`: in ghci, at leas (:set +s)
09:14:45 <ab9rf> i'm wondering why it's not recognizing the tail recursion
09:15:30 <btcNever`> btw in my example m is 253 (the product of the two primes 11 and 23). In real cases, it's going to a 1024 bit integer or so.
09:15:42 <rwbarton> :set +s shows total allocation I thought
09:16:09 <rwbarton> and of course you have to allocate a lot of Integers and stuff, doesn't mean the space usage at any given time is large
09:16:55 <ReinH> ab9rf: ghc doesn't "recognize tail recursion"
09:16:55 <ab9rf> rwbarton: hm, good point
09:17:03 <rwbarton> maybe in this case there is no stuff. just Integers :)
09:17:03 <ab9rf> ReinH: yes, i know, still
09:17:17 <ReinH> ab9rf: still what?
09:17:51 <ab9rf> rwbarton: there are a lot of integers running around.  also, i'm fairly sure you're right, because if it had allocated 1.6GB of memory, everything else on my system would ahave been paged out :)
09:18:52 <rwbarton> I watched the little memory bar in htop and it didn't get noticeably bigger. not the most scientific approach
09:19:04 <ReinH> Enable RTS profiling?
09:19:20 <rwbarton> well, this was in ghci
09:19:43 <glguy> What's the mystery? GHCi is slow and with compilation it runs instantly
09:19:48 <glguy> that sounds normal
09:20:03 <btcNever`> nice: using the bang pattern and 100 million calls from ghc (not ghci) takes 54 seconds on my machine. Compared to 320 seconds for the same in Clojure.
09:20:07 <ReinH> Not sure ghci is a good proxy for runtime behavior...
09:20:21 <btcNever`> (and a 512 bit integer)
09:20:22 <rwbarton> yes, everything is normal
09:20:51 <ReinH> where's the code for this btw?
09:22:07 <rwbarton> oh, the only mystery to me is why ghci uses more stack, apparently, or why the stack limit is set lower or something
09:22:46 <ReinH> rwbarton: I think it's just the latter
09:22:51 <ReinH> rwbarton: which ghc?
09:22:54 <glguy> btcNever`: What was taking 54 seconds? On my machine "main = print (decrypt 100000000 2 253)" takes just fewer than 4 seconds
09:23:03 <rwbarton> 7.8.1
09:23:04 <btcNever`> glguy: http://lpaste.net/105464
09:23:47 <rwbarton> so I know that when compiling the default stack size is something like 80% of my physical RAM; but I don't know what is happening in ghci
09:24:00 <btcNever`> glguy: 768 bits integer in the paste above... btw curious how fast it runs on your machine.
09:24:05 <rwbarton> it's possible it just uses a few times more stack somehow
09:24:16 <btcNever`> I compiled it with "ghc -O0 ..."
09:24:36 <glguy> btcNever`: It's running now and using 1.1 MB ram
09:24:50 <glguy> and on my laptop : real	1m0.188s
09:25:11 <ab9rf> btcNever`: yu realize tht that function enters a cycle fairly quickly
09:25:24 <rwbarton> most of the time will be spent in gmp anyways, for this big modulus
09:27:44 <ab9rf> i ended up rewriting that function using iterate :)
09:28:08 <glguy> iterate f x !! i    optimizes nicely
09:28:13 <ab9rf> glguy: exactly
09:28:23 <ab9rf> decrypt1 m p = (p * p `mod` m)
09:28:24 <ab9rf> decrypt t p m = (iterate (decrypt1 m) p) !! t
09:28:26 <ReinH> 44,416 bytes maximum residency
09:28:27 <ReinH> Not bad
09:28:41 <btcNever`> for this kind of stuff (big modulus, crypto computation, ...), is Haskell fast? (is sure seems quite faster than Clojure, which is using Java's BigInteger under the hood).
09:28:43 <monochrom> you may like a strict iterate
09:29:59 <monochrom> although, small memory footprint implies that someone already makes it strict for you :)
09:30:30 <rwbarton> btcNever`: probably it comes down to libgmp being faster than BigInteger
09:32:54 <btcNever`> ab9rf: could you lpaste the full version using iterate?
09:33:01 <ab9rf> btcNever`: it's just two lines
09:33:12 <ab9rf> could be done in one with a lambda
09:33:16 <glguy> ab9rf: Using iterate runs in 1.5x the time as the non-iterate version
09:33:27 <ab9rf> glguy: yeah, i noticed that too
09:33:32 <ab9rf> glguy: uses more memory too
09:33:39 <rwbarton> for m = 253 or the really big m?
09:33:47 <ab9rf> haven't tried with large m
09:33:50 <rwbarton> ok
09:34:02 <rwbarton> hmm
09:34:27 <btcNever`> ab9rf: large modulo here: http://lpaste.net/105464
09:34:27 <rwbarton> even with the large m, ghci managed to take twice as long as ghc -O2
09:34:42 <ab9rf> one line version: decrypt t p m = (iterate (\p -> p * p `mod` m) p) !! t
09:34:53 <ab9rf> which, oddly, runs twice as fast as the two-function verson
09:35:09 <ab9rf> moving it into a lambda halved the runtime in ghci
09:35:11 <BeardedCoder> Any pipes / pipes-parse experts got some time to help me out?
09:35:15 <rwbarton> so the amount of work being done in libgmp isn't so vast as to be able to dominate a sufficiently stupid compiler
09:35:47 <ab9rf> @pl \p -> p * p `mod` m
09:35:47 <lambdabot> ap (*) (`mod` m)
09:35:49 <glguy> ab9rf: Perhaps it didn't inline because you had two parameters left of the =
09:35:52 <ReinH> strict iterate version almost exactly the same time and space
09:36:07 <ab9rf> glguy: possibly true
09:36:14 <bennofs> BeardedCoder: I'm not an expert, but I know pipes a little bit, so maybe I can help.
09:36:47 <BeardedCoder> bennofs: cool, here is a simple example of some logs I'm trying to parse. They are much more complicated in my real example. https://gist.github.com/ccarter/0c896f54a1ddb4c688fa
09:37:29 <BeardedCoder> bennofs: Issue, I want to parse each pid as it's own stream (and technically each host/pid) but I just need some pointers
09:37:58 <btcNever`> when I try the one liner using iterate I get: "Couldn't match expected type 'Int' with actual type 'Integer' in the 2nd arg of (!!), namely 't'   (should I change the type signature?)
09:38:01 <ab9rf> glguy: i'm fairly sure that you're right about that
09:38:20 <ab9rf> btcNever`: yeah, !! requires Int, not Integer.  i discarded the type signature while fiddling with it
09:38:39 <bennofs> BeardedCoder: so you want multiple "streams", such that in each stream, there are only the logs of a single process?
09:38:43 <ab9rf> my function is Integral a => Int -> a -> a -> a
09:38:55 <BeardedCoder> bennofs: Ya, unless you have a better idea
09:38:56 <ReinH> btcNever`: t needs to be an Int
09:40:26 <ab9rf> btcNever`: the "iterate f x !! n" idiom is a nice way to do repeated applications of a function
09:41:11 <BeardedCoder> bennofs: There is a start and end to each chunk of logs that I want to gather stats from. In other words, there is a begining/middle/end that are different lines in the log.But, since other processes logs are interleaved I can't just parse it top to bottom
09:41:22 <ReinH> I still don't know why the strict version didn't make it into base
09:42:06 <ReinH> I wonder if compiling with llvm yields any improvements
09:42:37 <leino> Quick question: how come if I have 'class MyClass a b where ...' then I can do 'instance MyClass Maybe b where ...', but if I have 'class MyOtherClass a b c where ...', then I can't do 'instance MyOtherClass Either b c where ...' ? (multiparameter type classes enabled)
09:43:22 <monochrom> leino, that depends more on the methods than the header. kind inference thing.
09:44:06 <monochrom> in fact, make it: depends on the methods, does not depend on the header at all.
09:44:27 <ab9rf> btcNever`: making m a "very large numbe" (40 digits or so) only slightly increased runtime.
09:44:45 <leino> ok, so I need to fill in my '... to pose a good question?
09:44:51 <monochrom> yes
09:44:54 <leino> ok
09:45:14 <leino> thanks, I'll try to get a slightly more minimal example together and come back with a paste!
09:46:35 <monochrom> "Clutch Analytics" is a strange name for a company :)
09:46:52 <ab9rf> heh
09:47:00 <monochrom> w00t today is Wednesday, may have Haskell Weekly News!
09:50:16 <jfischoff> what is the more general version of Applicative to accompany the Control.Categorical.Functor http://hackage.haskell.org/package/categories-1.0.6/docs/Control-Categorical-Functor.html
09:51:57 <Cale> jfischoff: I believe you'd still want it to be an endofunctor
09:52:32 <ReinH> monochrom: Or as I like to call it, "Things Edward Kmett Did Weekly"
09:52:54 <Cale> I wonder why r and t are after f in the parameter list there
09:53:02 <jfischoff> Cale: are you saying Applicative would be the same but with a different superclass?
09:53:12 <Cale> jfischoff: Pretty much
09:53:39 <Cale> and some r's in place of (->)
09:53:59 <jfischoff> Does that class exist though?
09:54:10 <jfischoff> in some package somewhere?
09:54:21 <Cale> no idea
09:54:56 <rwbarton> Applicative as it is presented in Haskell is a weird beast
09:55:39 <jfischoff> because it is a curried monodial functor?  (I think I got that right)
09:55:53 <rwbarton> it should be a lax morphism of closed categories I think
09:56:13 <rwbarton> yeah, if you uncurry (sort of) then you get a lax monoidal functor between monoidal categories
09:56:41 <rwbarton> either way it is defined w.r.t. some additional structure (closed structure, or monoidal structure) on the two categories
09:56:55 <btcNever`> ab9rf: I think I should install something more recent than 7.4 before going further but both your 'iterate' version (two lines and one line) do stack overflow with 100 millions calls / 768 bit integers modulo here. The strict version / bang patterns works that said.
09:56:57 <Cale> Yeah, you may want to back off a bit on the weirdness and go with generalising  pair :: (f a, f b) -> f (a,b)  instead
09:57:08 <jfischoff> right
09:57:21 <Cale> (i.e. liftA2 (,) more or less)
09:58:26 <ab9rf> btcNever`: yeah, i was getting stack overflows on 100 million iterations, which is probably just because i'm not using -O
09:59:11 <rwbarton> jfischoff: so here you would want to parameterize on the monoidal structures too
09:59:14 <btcNever`> ab9rf: tried with -O0 and -O2 and it stacks overflows...
09:59:21 <rwbarton> using http://hackage.haskell.org/package/categories-1.0.6/docs/Control-Category-Monoidal.html
09:59:26 <glguy> A strong monoidal functor in a CCC, aka Applicative : https://github.com/ekmett/categories/blob/master/wip/Pro.hs#L405
10:00:04 <jfischoff> thanks guys Iâ€™ll chew on this
10:01:53 <Cale> jfischoff: Perhaps:  class (Category r, Functor f r s) => Monoidal f r s where unit :: s () (f ()); pair :: s (f a, f b) (f (a, b))
10:03:37 <btcNever`> something else: can someone explain me why "decrypt t p m = decrypt (t - 1) (p * p `mod` m) m" is building a large thunk on the second argument and not the first?
10:03:48 <Cale> and then you could fiddle with that until it's in a more convenient form. It's possible you can just write out the usual Applicative pretty much
10:04:14 <Cale> btcNever`: Is there a base case which pattern matches on t?
10:04:44 <glguy> btcNever`: the previous line with "decrypt 0" matched on the first argument
10:04:46 <btcNever`> Cale: yes, I think so.  I have   "decrypt 0 p m = p"
10:04:52 <Cale> btcNever`: Yes, that's why
10:05:06 <Cale> btcNever`: Matching forces evaluation
10:05:11 <sjoerd_visscher> hereâ€™s how you convert a strong monoidal functor into an applicative functor: https://github.com/ekmett/categories/blob/master/wip/Pro.hs#L464
10:05:11 <btcNever`> ooooh
10:05:20 <Cale> (In fact, at some level, it's the only reason anything is ever evaluated)
10:05:27 <jfischoff> cool
10:05:28 <ReinH> @where lazy
10:05:29 <lambdabot> http://www.vex.net/~trebla/haskell/lazy.xhtml
10:05:40 <ReinH> btcNever`: ^ is a great explanation
10:06:03 <btcNever`> ReinH: opened and bookmarked ;)
10:06:07 <holoed> Is there an alternative to Json and stdin/stdout for multilang projects?
10:06:20 <ReinH> holoed: There are lots of ways to do IPC, yes.
10:07:46 <jfischoff> let me give my motivation for this categorical stuff. I noticed that data Ref a = Ref { read :: IO a, write :: a -> IO () }, has a Functor and contravariant functor. It would appear I can make a more general fmap :: Iso a b -> Ref a -> Ref b, and I also want the accompany Applicative.
10:09:19 <jfischoff> s/accompany/accompaning
10:09:43 <geekosaur> s/i/yi/
10:09:56 <jfischoff> yes that too
10:10:08 <geekosaur> (...I see the spraygun recruiters have found haskell-cafe)
10:10:24 <ReinH> geekosaur: :(
10:10:27 <fragamus> Is there a way to make a case pattern like this: Foo _ _ _ ->           which would not need to be modified if the number of members of Foo changed
10:10:36 <ReinH> fragamus: no
10:10:45 <rwbarton> yes
10:10:46 <fragamus> say it aint so
10:10:46 <geekosaur> huh?
10:10:48 <rwbarton> Foo {} ->
10:10:48 <jfischoff> yes Foo {}
10:10:50 <geekosaur> Foo {}
10:10:51 <ReinH> Oh.
10:10:57 <benzrf> ReinH: nice try :-)
10:10:58 <fragamus> say it
10:11:05 <enthropy> was there some other way to add yourself to ghc's trac CC list than going into "Modify Ticket" and adding yourself at the very end?
10:11:10 <fragamus> "it aint so"
10:11:25 <btcNever`> so due to matching on t, using a bang on t in this: "decrypt t !p m = decrypt (t - 1) (p * p `mod` m) m" would be redundant?
10:11:37 <ReinH> btcNever`: yes
10:13:44 <ReinH> rwbarton: I suppose that I could argue that Foo {} isn't *like* Foo _ _ _, but I'm not feeling pedantic enough today ;)
10:14:32 <jfischoff> Iâ€™m curious how are they different?
10:14:40 <tommd> :q
10:14:51 <tommd> What?  This isn't vim!
10:14:56 <jfischoff> it is
10:15:09 <geekosaur> actually I seem to recall the language report specifically asserts that it is
10:15:29 <geekosaur> (and it's not merely something that happens to fall out of record syntax)
10:17:19 <intrados> If I want to process a large gzipped csv (without actually decompressing the file to disk), would pipes/conduit + zlib be the way to go?
10:18:54 <c_wraith> intrados: look into cassava for the actual CSV parsing - it streams pretty well
10:20:53 <intrados> c_wraith: Thanks, I've used cassava before. It's the pipes/conduit part I'm less familiar with
10:22:49 <enthropy> http://hackage.haskell.org/package/cassava-0.4.1.0/docs/Data-Csv-Streaming.html#t:Records doesn't compose as easily as conduits do
10:22:49 <c_wraith> intrados: why not use use lazy bytestrings?  Unless you need to close the input file promptly before consuming it all, it should have basically the same properties
10:26:07 <enthropy> c_wraith: I don't think cassava does that: if you return Either Error [Row], all the rows have to be evaluated to find out whether to use the Left or Right constructor
10:26:41 <c_wraith> enthropy: the streaming interface gives you a http://hackage.haskell.org/package/cassava-0.4.1.0/docs/Data-Csv-Streaming.html#t:Records
10:26:49 <c_wraith> enthropy: that handles a row at a time
10:27:38 <c_wraith> enthropy: odd that we link to the same thing, but my reading of it is entirely opposite of yours.
10:27:55 <c_wraith> enthropy: note that it's an Either per row
10:28:04 <enthropy> because interpreting that Records data type isn't as nice
10:29:16 <c_wraith> as nice as bringing in 10x as much machinery?
10:30:21 <gsingh93_> yesterday I asked about exercise two here: http://www.seas.upenn.edu/~cis194/hw/01-intro.pdf and someone said they could do it with foldr
10:30:33 <gsingh93_> I couldn't figure it out though
10:30:49 <c_wraith> gsingh93_: that's not a very interesting statement.  You can do anything with lists with foldr. :)
10:31:33 <gsingh93_> c_wraith: well I've solved it with two different (inefficient) methods, and i'd like to figure out how to do it with foldr
10:32:10 <jfischoff> [1,2,3] can also be written 1:2:3:[]. foldr replaces the constructors : and []
10:32:53 <jfischoff> foldr (#) bar $ 1:2:3:[] -> 1#2#3#bar
10:33:05 <jfischoff> thatâ€™s my hint
10:33:50 <jfischoff> I should also add I didnâ€™t really read the thing :p
10:34:15 <c_wraith> gsingh93_: I have no clue how the person suggesting it meant, but I'd do it by folding a tuple along.  the base case would be something like (False, []).
10:34:16 * btcNever` is gone eating and thanks everybody for the help
10:34:44 <c_wraith> gsingh93_: the Bool indicates whether you need to multiply the next value by 2 or not
10:35:02 <gsingh93_> yea, they said they folded a tuple
10:35:08 <gsingh93_> i think i know what they meant now
10:35:19 <c_wraith> gsingh93_: I *think* my hint is enough information.
10:36:27 <altern> Could please somebody explain why I am getting error  Left "Failed reading: takeWhile1" ?
10:37:41 <BeardedCoder> altern: attoparsec?
10:38:28 <altern> BeardedCoder: yes
10:39:18 <kazagistar> altern: cause it failed on a takeWhile1 I assume, attoparsec is not the most amazing at errors
10:39:21 <altern> BeardedCoder: here is my code: http://lpaste.net/105469
10:39:41 <jfischoff> altern: do you need the performance of attoparsec?
10:39:47 <john_minetest> Hi
10:39:49 <altern> BeardedCoder: And I am running the line parseOnly parseVersionNumber (BS.pack "X")
10:39:52 <jfischoff> there is also the parsec attoparsec thing
10:39:59 <altern> jfischoff: no
10:40:10 <BeardedCoder> jfischoff: Can you linky that. I was just looking for it
10:40:20 <Black-Heaven> (repeated) I have this error: http://lpaste.net/105453 I understand why it fails (State is * -> * -> *, while s is * -> *), but I can't figure out how to write this, I tried s t o, but it isn't correct because k waits for a (* -> *), so if you have any hints, please tell me. Thanks by advance.
10:40:28 <altern> OH! it seems that attoparsec is case sensitive :)
10:40:34 <jfischoff> altern: do you need resumable input
10:40:51 <jfischoff> BeardedCoder: I donâ€™t have the link either
10:40:59 <jfischoff> john_minetest: hi
10:41:33 <altern> @hoogle attoparsec
10:41:34 <lambdabot> package attoparsec
10:41:35 <lambdabot> package attoparsec-arff
10:41:35 <lambdabot> package attoparsec-binary
10:41:47 <altern> @hoogle string
10:41:49 <lambdabot> Text.ParserCombinators.ReadP string :: String -> ReadP String
10:41:49 <lambdabot> Text.Parsec.Char string :: Stream s m Char => String -> ParsecT s u m String
10:41:49 <lambdabot> Text.ParserCombinators.Parsec.Char string :: Stream s m Char => String -> ParsecT s u m String
10:43:27 <BeardedCoder> altern: How I troubleshoot my parsers is test each one by hand. When you combine them, test with combined input. In other words, start small and keep building up. When you end up with 1 big combination of parsers that don't work, comment out everything but the first one and "stub" out your algebra with fake data. Uncomment each line in your do sugar until it breaks.
10:44:28 <BeardedCoder> Only done this a couple of times so there may be better approaches. I'm curious about the Parsec -> AttoParsec method
10:44:54 <altern> BeardedCoder: I figured what's the problem. I tried to parse "x" while parser could parse only "x". It is matter of letter case
10:45:19 <BeardedCoder> jfischoff: Hey, nice seeing you here. It's Curtis from BayHac =)
10:45:26 <altern> BeardedCoder: but now I don't know how to match both cases of "x" and "X" to produce the same result
10:45:34 <jfischoff> BeardedCoder: oh hey!
10:45:47 <jfischoff> you are a beardedcoder :)
10:45:50 <BeardedCoder> yip
10:45:59 <BeardedCoder> Now you can laugh at my new questions =)
10:46:05 <BeardedCoder> newb*
10:46:16 <jfischoff> you got it ;)
10:47:19 <BeardedCoder> altern: There are some case insensitve parsers. Check out asciiCI
10:47:25 <BeardedCoder> altern: https://hackage.haskell.org/package/attoparsec-0.12.0.0/docs/Data-Attoparsec-Text.html
10:48:03 <BeardedCoder> altern: I've been using Attoparsec.Text, so switch to whatever module you are using.
10:48:54 <altern> BeardedCoder: alright, thanks for your help. need to go..
10:49:07 <BeardedCoder> gl
10:49:55 <jfischoff> BeardedCoder: I couldnâ€™t find the package I thought existed, but you can also use the Parsers packageâ€™s interface and then just run an AttoParsec parser
10:51:41 <BeardedCoder> jfischoff: Ya, I noticed some functions in atto that are just there for compatibiltiy. ie. try
10:55:07 <ReinH> jfischoff: the package wasn't parsers?
10:55:28 <jfischoff> Now but I donâ€™t think it provide much over parsers
10:55:38 <gsingh93_> c_wraith: I got it: http://pastebin.com/ymupsZda
10:55:41 <gsingh93_> thanks!
10:55:49 <jfischoff> I think it was a just a more attoparsecy interface
10:56:24 <c_wraith> gsingh93_: you could use the fst function to get rid of the let, but yeah.  That's exactly the technique.
10:56:33 <c_wraith> :t fst -- gsingh93_
10:56:34 <lambdabot> (a, b) -> a
10:56:44 <gsingh93_> cool, i'll change that
11:10:22 <jle`> gsingh93_: something ike that lambda might be worth pulling out into a helper function in a where clause
11:10:55 <jle`> then you can do fancy pattern matching :)
11:11:44 <LePhin> I'm trying to learn HXT arrows and having some trouble. I'm trying to define an arrow that sets one attribute on all nodes equal to another, so <div id="foo"> becomes <div id="foo" otherid="foo">.
11:11:44 <jle`> actually you might not get that much from fancy pattern matching in this situation
11:12:59 <LePhin> I've got an arrow that selects the attribute, but I'm not sure how to get this to setElemName (ArrowXml -> QName -> a XmlTree XmlTree).
11:13:32 <LePhin> Is there some equivalent to >>= in arrows so I can create an arrow from a function that returns an arrow?
11:15:38 <LePhin> So I have an Arrow s XmlTree (QName, XmlTree) but I don't know how to create the reverse.
11:16:03 <LePhin> ArrowXml a => a (QName, XmlTree) XmlTree
11:19:13 <fread2282> is binary lazy enough for me to run it and if I just use the unused input no actual parsing be done?
11:20:42 <monochrom> I think binary is pretty eager actually
11:21:12 * hackagebot attoparsec 0.12.1.0 - Fast combinator parsing for bytestrings and text  http://hackage.haskell.org/package/attoparsec-0.12.1.0 (BryanOSullivan)
11:21:15 <monochrom> otoh it only reads what you ask it to read. no more.
11:22:04 <pavonia> :t (>>^ snd)
11:22:06 <lambdabot> Arrow a => a b (a1, d) -> a b d
11:22:21 <pavonia> LePhin: ^ Is that what you want?
11:23:28 <fread2282> or cereal, doesn't matter which one I use
11:23:45 <benzrf> :t (>>^)
11:23:47 <lambdabot> Arrow a => a b c -> (c -> d) -> a b d
11:23:51 <benzrf> o:
11:24:00 <benzrf> :t (.) . arr
11:24:01 <lambdabot> (b -> c) -> (a -> b) -> a -> c
11:24:07 <benzrf> ??
11:24:13 <benzrf> :t (Category..) . arr
11:24:14 <lambdabot> Not in scope: â€˜Category..â€™
11:24:17 <benzrf> :t (Arrow..) . arr
11:24:18 <lambdabot> Not in scope: â€˜Arrow..â€™
11:24:21 * benzrf rolls eyse
11:24:27 <benzrf> :t (>>>) . arr
11:24:29 <lambdabot> Arrow cat => (a -> b) -> cat b c -> cat a c
11:24:33 <benzrf> heuh
11:29:00 <joeyh> anyone have a Windows machine with ghci and a second? For some reason here, Data.Time.LocalTime.getCurrentTimeZone always seems to yield a zone with 60 minute offsef, not matter what the timezone really is
11:29:09 <fread2282> monochrom: I'm a noob, but it looks fairly lazy to me (binary)
11:29:29 <joeyh> and I'd like to know if this only affects my old windows dev system, or more widely..
11:36:25 <pavonia> joeyh: Yes, same for me, it says Western European Summer Time where it should be CEST
11:37:54 <genericpersona> joeyh: seems like it's just you
11:38:03 <genericpersona> getCurrentTimeZone worked fine for me
11:38:20 <genericpersona> it accurately returned my time zone
11:39:10 <deweyvm1> @pl (\x y -> [Join x y]) <$> parseTime <*> parseNick
11:39:10 <lambdabot> flip flip [] . ((:) .) . Join <$> parseTime <*> parseNick
11:39:16 <deweyvm1> is there a better way to write this?
11:40:06 <joeyh> I get some different time zone names (possibly after a reboot), but alway the 60 minute offset
11:40:16 <joeyh> what windows was that pavonia?
11:40:23 <pavonia> WinXP
11:40:38 <deweyvm1> ah
11:40:41 <joeyh> sounds like it's time for a ghc bug report, perhaps
11:40:51 <deweyvm1> (.:) = (.) . (.)
11:40:54 <deweyvm1> return .: Join
11:41:02 <joeyh> genericpersona: which windows ver?
11:41:06 <deweyvm1> annoying to have an operator for each arity though
11:41:43 <joeyh> ok, I also have a XP VM that I use, so that might be the common thread
11:45:38 <JoaoPortela> What is "GMT Daylight Time
11:45:38 <JoaoPortela> " supposed to be?
11:48:28 <nadirs> JoaoPortela: can you provide more context? (https://en.wikipedia.org/wiki/Daylight_saving_time)
11:48:33 <pavonia> JoaoPortela: I think that's Western European Summer Time
11:49:00 <pavonia> or equivalent to that
11:49:25 <JoaoPortela> ohh.. it was weird because GMT is not supposed to have summer time.
11:49:35 <LePhin> pavonia: Doesn't that just ignore the first half of the tuple?
11:49:43 <JoaoPortela> that's what i got from that command on windows
11:49:55 <pavonia> LePhin: Yes
11:50:01 <joeyh> JoaoPortela: try timeZoneMinutes to get the minute offset
11:50:09 <LePhin> The issue I am having is that I need to turn the string part into an arrow and then apply that to the other half.
11:50:13 <pavonia> LePhin: You can use a custom function for snd
11:51:20 <LePhin> pavonia: What do you mean by "custom function"?
11:52:15 <pavonia> LePhin: Something that turns you pair into the result value
11:52:55 <pavonia> *your
11:53:38 <LePhin> So I have this arrow foo :: ArrowXml a => a XmlTree (QName, XmlTree) and a function bar :: ArrowXml => QName -> a XmlTree XmlTree.
11:53:42 <ljosha> What is the common way to define types for the multiple objects sharing the same property? Like some geometrical shapes, each having a position. Like data Shape = Circle { position :: Point, ... } | Square { position :: Point, ... } ..., or data Shape a = Shape Position a?
11:54:18 <ljosha> and then each shape having only it's peculiar field
11:54:19 <ljosha> s
11:54:29 <jle`> ljosha: probably data Entity = Entity Shape Position
11:54:32 <tulcod> i'm trying to install darcs. but it seems like it depends on array<0.5, and array-0.4.0.1 gives a build error (ghc 7.8.2)
11:54:36 <jle`> data Shape = Circle | Square | ...
11:55:13 <bergmark> tulcod: i tried installing darcs a few weeks ago, didn't manage
11:55:22 <tulcod> ok... so now what do i do?
11:55:24 <bergmark> you should probably stick to a binary distribution
11:55:32 <ljosha> jle`: I see, thanks!
11:55:33 <tulcod> okay
11:55:59 <jle`> LePhin: I think you need ArrowApply for that
11:56:35 <bergmark> tulcod: you could try to install it with --allow-newer too, if you are super lucky it might work
11:56:43 <KorriX> Hello! Is there any implementation of hashmap allowing key to be a property of object kept as a value?
11:57:06 <jle`> LePhin: or ArrowMonad
11:57:20 <jle`> hm
11:57:30 <enthropy> ljosha: sometimes you can also do stuff like data RegularPolygon = RegularPolygon { sides :: Maybe Int, position :: Point, ... } , then circle = RegularPolygon Nothing etc.
11:57:46 <lemao> anyone here familiar with haste-compiler implementation?
11:57:53 <bergmark> KorriX: that's an interesting idea! i don't know of anexisting implementation though
11:57:59 <enthropy> or maybe a circle has one side
11:59:07 <KorriX> bergmark: The thing boils down to the problem of observing values and rehashing according to changes
12:00:35 <ljosha> enthropy: yes, I have a case like this, thanks
12:01:56 <tulcod> ok can someone help me understand the output of this cabal install? http://pastebin.com/pmmHeUng
12:02:54 <kazagistar> KorriX: sorry, I might not know the right terminology, but what do you mean by property and object?
12:04:02 <KorriX> kazagistar: Imagine data Person = Person {name :: String, age :: Int} and map from person.name -> person
12:04:50 <jfischoff> tulcod: rejecting: deepseq-1.3.0.2/installed-716... (conflict: deepseq =>
12:04:51 <jfischoff> array==0.5.0.0/installed-9f2..., darcs => array>=0.1 && <0.5)
12:05:19 <KorriX> kazagistar: That's pseudocode. Normally you would have Map String Person, but that's making problem with keeping person.name and key in sync
12:05:28 <jfischoff> means that cabal wants to have use array < 0.5  and deepseq
12:05:59 <jfischoff> but the deepseq you have (which is shipped with ghc and you cannot uninstall) uses array 0.5
12:06:19 <tulcod> jfischoff: so... that's not a solvable issue then?
12:06:26 <jfischoff> so you need to tell cabal to let you use a later version of array, and hope it compiles
12:06:29 <kazagistar> KorriX: Person and Map are both immutable, so you cant get out of sync...?
12:06:31 <jfischoff> probably
12:06:39 <jfischoff> definitely with some amount of work
12:06:45 <jfischoff> what version of cabal do you have?
12:07:19 <tulcod> jfischoff: 1.20.0.2
12:07:38 <tulcod> so it should've been --allow-newer=array, then?
12:07:50 <tolt> tulcod: could you try cabal install deepseq-1.3.0.2?
12:07:51 <jfischoff> yeah
12:08:03 <tolt> That has a higher version of array
12:08:20 <jfischoff> he has that version
12:08:22 <KorriX> kazagistar: But then you need to hide value constructor for that kind of map and write implementation of insert and modify functions ensuring that key is in sync
12:08:44 <tulcod> tolt: already installed
12:09:04 <tulcod> okay, it's also blocking on base<4.7
12:09:21 <jfischoff> same thing allow newer
12:09:26 <LePhin> jle`: Thanks! `app` is exactly what I am looking for.
12:09:37 <KorriX> kazagistar: Moreover you have a lot of overhead with handling special cases
12:09:40 <tulcod> and then --allow-newer=array,base gives http://pastebin.com/Y99pzpbg
12:10:01 <jfischoff> definitely do not force
12:10:11 <jle`> LePhin: np!
12:10:36 <jfischoff> unix-2.7.0.1 -> 2.6.0.1 use the allow newer on unix
12:12:12 <tulcod> jfischoff: http://bpaste.net/show/363908/
12:12:24 <jfischoff> have to run to lunch, under no circumstances force
12:12:32 <tulcod> hehe sure
12:13:30 <jfischoff> what version of Cabal do you have?
12:13:44 <tulcod> i think i'll just go for a binary distribution of darcs
12:13:45 <kazagistar> KorriX: what about writing a newtype wrapper and then defining Hashable? that seems pretty low overhead and high performance
12:13:46 <tulcod> this is too much work
12:13:56 <jfischoff> it is
12:14:16 <jfischoff> but it is also worth learning if you run into an issue with a library
12:14:23 <jfischoff> follow your heart
12:14:38 <tulcod> but this is not learning. this is just telling the thing to try anyway :P.
12:14:40 <kazagistar> KorriX: or similarly a newtype wrapper of Ord and using a Set?
12:14:51 <jfischoff> troubleshooting
12:15:00 <tobiasgw> I just upgraded to ghc 7.8.2 and now I'm having trouble installing a haskell-src-exts. There is library the linker is unable to find (HScpphs-1.18.4-ghc7.8.2). Can that be because I have installed most packages with ghc 6.x and now I've upgraded?
12:15:06 <jfischoff> anyway, feel free to ask me questions when I get back.
12:15:17 <tulcod> sure
12:15:35 <KorriX> kazagistar: Set does not provide lookup operation. Hashmaps are storing keys separately - that's bad
12:16:41 <KorriX> kazagistar: I consider using some BST, but they are O(log n). I'd like something with O(1) lookups and max O(log n) for rehash/rebalance
12:17:47 <kazagistar> wait, I might not understand how haskell does its implementation, but why would a hashmap store its keys?
12:18:08 <kazagistar> *HashTable
12:19:27 <KorriX> kazagistar: I meant keeping them in type definition. They are defined as data HashMap k v
12:21:18 * hackagebot purescript 0.5.2.3 - PureScript Programming Language Compiler  http://hackage.haskell.org/package/purescript-0.5.2.3 (PhilFreeman)
12:23:29 <delrik> Hi guys!
12:25:19 <kazagistar> KorriX: if you are just concerned about hiding the type signature, a newtype wrapper should provide that for free for hash tables and for cheap for maps I think
12:26:10 <jle`> hi delrik!
12:26:27 <KorriX> kazagistar: look at http://hackage.haskell.org/package/unordered-containers-0.2.1.0/src/Data/HashMap/Base.hs#insert Hash is allways calculated from the key
12:26:55 <enthropy> just because something is in the type, doesn't mean there's an actual value
12:29:12 <delrik> @jle' , hey how long have you been a haskeller?
12:29:12 <lambdabot>  Parse failed: Parse error: ,
12:29:44 <fread2282> KorriX: what else would it be calculated from?
12:30:13 <KorriX> fread2292 I'd like to take it from the structure kept as a value (Inserted value)
12:30:15 <jle`> delrik: hm. about a year and a half?
12:30:23 <jle`> a little less than
12:30:45 <KorriX> *fread2282 sorry for the typo
12:31:13 <JoaoPortela> joeyh, I think the minutes were correct (60). I guess it's just a strange representation for WEST.
12:31:24 <enthropy> KorriX: I think they want to support "keys :: HashMap k v -> [k]"
12:31:46 <delrik> oooh nice! jle`
12:31:53 <enthropy> and also hash collisions happen
12:31:53 <jle`> delrik: ty!
12:32:09 <delrik> jle`: have you messed with Arrows at all
12:32:21 <jle`> delrik: a fair amount, having dabbled in afrp
12:32:42 <jle`> and am writing a slightly unrelated library with an arrowized interface as well
12:33:01 <fread2282> KorriX: huh? how would it deal with collisions?
12:33:14 <jle`> but there are people here who know more than me of course
12:33:34 <KorriX> fread2282: Exactly the same way as normal hashmap does...
12:33:40 <delrik> is that related to the FFI in any capacity?
12:34:17 <jle`> delrik: not really, no
12:34:39 <KorriX> enthropy: In my case having values :: HashMap k v -> [v] would be enough. Keys could be obtained by fmap \x -> name x $ values myHashMap
12:34:48 <kazagistar> KorriX: well, if you really are worried about keys using up memory or something, you probably have to write your own
12:35:03 <fread2282> KorriX: maybe you want HashSet?
12:35:25 <fread2282> normal Map also stores the keys
12:35:39 <delrik> jle`: My greeness is showing =)
12:35:51 <KorriX> fread2282: HashSet has no lookup operation
12:35:54 <ReinH> johnw: you got a shoutout in one of Carsten's taks about org-mode :)
12:36:32 <ReinH> johnw: so do you use devon now instead, in addition to?
12:37:19 <KorriX> kazagistar: I'm worried only about sync of keys <-> object names. Memory usage is not that important for me
12:37:24 <delrik> jle`: I'm trying to see how all these different pieces of software fit together, unfortunately Arrows haven't struck a chord with me yet.
12:37:45 <bergmark> uniplate :3
12:37:58 <kazagistar> KorriX: are your objects Refs or something?
12:38:12 <jle`> delrik: no worries, these days Arrow is a rather specialized and rare sort of library interface and you wouldn't really need to understand them until you are in a domain where they are useful
12:38:35 <fread2282> KorriX: you could implement it by using foldr
12:39:32 <delrik> jle`: yeah, but unfortunately for me , my curiosity usually gets the best of me.  I'm still not even comfortable w/ the type system yet. lol, I was reading through the doc: Monad Transformers Step by Step, in which Martin walks through Monad transformers, I have a quick question on that if you don't mind.
12:39:55 <jle`> delrik: you don't nee dto ask to ask, and i'm sure many people on here would be glad to help as well :)
12:40:07 <fread2282> KorriX: a hashmap is a map, which has keys and values
12:40:33 <enthropy> KorriX: you could use type NamedObject = (Key, Object) and use   Map Key Object instead of Map Key NamedObject
12:41:15 <KorriX> kazagistar: No. They are standard objects such as my previous example
12:41:28 <enthropy> substitute HashMap for Map I guess
12:41:59 <fread2282> KorriX: sounds like you want some type of Set or list
12:42:00 <KorriX> fread2282: Foldr takes O(n) - that's too much.
12:42:02 <kazagistar> KorriX: then synchronizaton is achieved through a newtype wrapper for free
12:42:31 <KorriX> fread2282: I'd like some kind of set
12:43:16 <KorriX> fread2282: Precisely some set with extra lookup operation. Possibly O(1)
12:44:00 <delrik> jle`: dope =)
12:44:38 <exicer> If I have a datatype data Test = Test ByteString, is there some way I can convert a Test back into a bytestring? Or do I have to write a function to do so?
12:45:14 <pavonia> You could define it like  data Test = Test { unTest :: ByteString }
12:45:15 <nadirs> exicer: that looks like a chance to use `newtype` instead
12:45:35 <nadirs> Also, what pavonia said.
12:46:31 <delrik> jle`: I was walking through that tutorial to build an expression evaluator, http://lpaste.net/105477
12:46:50 <exicer> nadirs: I don't actually understand newtypes really. Could you point me at something that explains them ?
12:47:25 <fread2282> KorriX: then maybe implement Hashable only with your "key" field and use NashMap myData () and isJust . lookup ?
12:47:27 <levi> KorriX: Pretty much all the Haskell map-like data structures I'm aware of are various sorts of trees.  HashMap is now a HAMT. So lookup is very fast.
12:47:28 <delrik> jle`: semantically, when I run my program and find myself in main, why isn't it necesary to use lift when invoking my monadic instructions?
12:47:43 <delrik> jle`: full source here: https://github.com/elrikdante/Transformers-hs/blob/master/src/Main.hs
12:48:27 <fread2282> KorriX: or be careful to; keep the Key up to date or just factor it out of your data structure
12:48:27 <nadirs> exicer: I can point you to the wiki and LYAH. I don't know if you already read those?
12:48:40 <exicer> nadirs: I read lyah ages ago. I will reread
12:48:49 <fread2282> s/NashMap/HashMap/
12:49:28 <nadirs> exicer: could you explain what doesn't tick about newtype? I'm a beginner but I'll try to help if possible :)
12:49:46 <karls> hey guys! i'm pretty new to haskell, but is there anything for haskell that mimics python's virtualenv or clojure's lein/project.clj? cabal, afaict, lets me install packages, but i take it they end up being installed globally? i'd just like pointers to what the convention is.
12:50:05 <johnw> ReinH: hey there
12:50:16 <johnw> @tell ReinH What was the link for Carsten's presentation.  And I use org-mode and DEVONthink collaboratively; org-mode is the master task index, with UUID-based links into the DEVONthink, which is the master archive
12:50:16 <lambdabot> Consider it noted.
12:50:16 <levi> delrik: main is an IO action, so there's no need to lift IO actions.
12:50:26 <KorriX> fread2282: Thanks for help
12:50:33 <fread2282> wait that won't work
12:50:37 <levi> karls: cabal sandbox
12:50:48 <fread2282> don't do that, lookup also uses Eq
12:50:57 <levi> karls: If you need different versions of ghc itself, there's also hsenv
12:51:19 <karls> levi: oh, cheers!
12:51:35 <fread2282> KorriX: you should probably just seperate your key from the rest of your data structure
12:52:11 <enthropy> KorriX: Data.Set has lookupGE
12:53:04 <KorriX> enthropy: I'll try with that then. Thanks
12:53:05 <rwbarton> sorry if this was already proposed but you could define a type class HasKey v k where key :: v -> k (or use an associated type maybe)
12:53:22 <rwbarton> and a newtype of HashMap k v with operations that always use that key function
12:53:33 <fread2282> is binary (or cereal) lazy enough for me to run it and if I just use the unused input no actual parsing be done?
12:53:44 <nadirs> karls: see also if this help: http://coldwa.st/e/blog/2013-08-20-Cabal-sandbox.html
12:53:45 <rwbarton> probably the associated type is better, HashMap (Key v) v
12:53:52 <rwbarton> the type class is to avoid coherence issues
12:54:07 <karls> nadirs: yep, just found it. thanks!
12:54:08 <syllogismos> if two different packages have the same import line, what package will the import statement import?
12:54:08 <levi> rwbarton: HashMap will still store the key (i.e. the hash of it) with the value at the leaf, though.
12:54:18 <delrik> levi: Thanks! , good to hear I've got that part right. I was expecting however that becasue I am in main, and my type uses the identity monad as its foundation, I'd have to lift multiple times to use the functionality of the different monads comprising my stack, which in this case are : Reader Error State
12:54:20 <syllogismos> like when I do import Data.Csv
12:54:30 <rwbarton> levi: yes. it's just one extra pointer per node though
12:54:39 <syllogismos> how can I know if its cassava, or csv-conduit or etc
12:54:44 <rwbarton> there are already a bunch of pointers per node anyways
12:55:03 <levi> rwbarton: Yeah, I don't really understand why KorriX is opposed to using HashMap the way it is.
12:55:15 <nadirs> karls: no problem :) This thread's comments are helpful too â†’ http://www.reddit.com/r/haskell/comments/27k7yl/developing_and_workflow_with_cabal_is_it_just_me/
12:56:10 <karls> nadirs: perfects, thanks!
12:56:17 <karls> s/perfects/perfect/
12:56:31 <ion> s/perfect/perfec/
12:57:10 <levi> delrik: The type of main is IO (), so the types of things elsewhere in your program aren't relevant.  And if you're using mtl, then the stack has handy typclasses so that the standard operations are automatically lifted to the correct monad; and to IO if you have the MonadIO constraint in your type.
12:57:56 <ReinH> johnw: neat
12:58:06 <rwbarton> levi: the only problem I am trying to solve with this type class is isolating the job of keeping the keys and values in sync to one module
12:58:07 <delrik> levi:  could you expand on this: The type of main is IO (), so the types of things elsewhere in your program aren't relevant.
12:58:10 <ReinH> johnw: talk is first one at http://orgmode.org/talks.html
12:58:26 <ReinH> johnw: so you define a link handler extension for devon links?
12:59:01 <delrik> levi: Are you saying that even if i base my stack on Identity I can still just use IO? w/out incorporating that into my stack?
12:59:17 <delrik> levi: as in a putStrLn?
12:59:21 <johnw> ReinH: exactly, org-devonthink.  let's carry on in privmsg
12:59:28 <ReinH> johnw: ok!
13:00:09 <glguy> delrik: He's not saying that. Identity wouldn't have an instance of MonadIO so it wouldn't work as the base monad if you were using the MonadIO constraint
13:00:11 <levi> delrik: No; IO has to be in the stack to do IO actions.
13:01:13 <delrik> okay, good, I was under that impression.  The only place I could indicrminitately use IO actions would be in my main declaration
13:01:22 <levi> Hm. You may have to prefix all IO operations with 'liftIO' now that I think about it.
13:01:38 <Zekka> You could define a MonadIO instance for a stack that doesn't include IO, but your MonadIO instance wouldn't be able to actually do any IO
13:01:55 <levi> delrik: You can write your own IO actions that can indiscriminately use IO actions.
13:01:58 <delrik> here's the stack: https://github.com/elrikdante/Transformers-hs/blob/master/src/Main.hs,
13:02:53 <levi> delrik: It's only when you've wrapped IO with a transformer stack that you need to liftIO.  You can write a whole program out of IO actions, though it's not really the best style if you don't need IO for everything.
13:03:09 <delrik> Oh!
13:03:10 <delrik> okay
13:03:22 <delrik> that makes sense, I did something similar when I wrote a scotty api
13:03:41 <Zekka> liftIO basically lets you, given a stack that has MonadIO, do (IO a)s to it
13:04:43 <delrik> I'm having a hard time coming to terms with monadic structures and how this affects program structure.  I always though if I needed to perform a wide range of actions across multiple monads, then building a stack and creating a type sysnonmy that instantiates it would be my best bet.
13:05:23 <levi> delrik: Yeah, it takes a bit of experience to get the hang of how it works; have you looked at the examples in Real World Haskell?
13:07:57 <levi> A common pattern is to have a monad stack that supports the monadic operations your program needs, but to have it polymorphic in its base monad so that you can wrap it over Identity and use it in pure code.  But then you generally have some sort of an IO-based driver around it that determines what sort of actions to run on the domain monad.
13:09:40 <delrik> levi: thx for the RWH, although I've seen it mentioned so many times, it probably became white noise.  thanks for the reference!   While we're on Monads, runReader unwraps a value from a MonadReader computation context , does that mean invoking runReader would be possible in arbitrary context?
13:10:06 <delrik> I'm assuming IO Is the only monadic action that is contrary to that?
13:10:20 <levi> Yeah, any monad that provides an unwrapper can be run anywhere.
13:10:38 <delrik> levi: nice =) thx
13:11:10 <delrik> levi: can I invoke those w/o having to explicate that in my functions return value?
13:11:21 <levi> Conceptually, the runtime is invoking your `main` action from within the IO monad, and does a 'runIO' to unwrap it and run your program.
13:11:40 <levi> But you can never do the 'runIO' yourself.
13:11:40 <delrik> levi: dope! that makes things really clear.
13:11:52 <shachaf> Conceptually "unwrapping" an IO action doesn't make much sense.
13:12:11 <delrik> unless you put "run"  in place of unwrapp
13:12:29 <fread2282> well, you can run io, but you shouldn't
13:13:03 <delrik> thanks for the help everyone
13:13:06 <delrik> levi: thanks again.
13:14:01 <levi> shachaf: I mean in the sense that most 'runX' things remove a newtype layer to get at whatever the underlying representation is, not in the sense of removing something from a container.
13:14:38 <shachaf> Conceptually IO isn't a newtype around something, either.
13:14:59 <fread2282> @src IO
13:14:59 <lambdabot> Source not found. Your mind just hasn't been the same since the electro-shock, has it?
13:15:02 <fread2282> :(
13:15:26 <delrik> speaking of that, does that mean conceptually my program is just a thunk?
13:15:54 <fread2282> Conceptually (and in GHC), IO a is RealWorld -> (a, RealWorld)
13:16:28 <kazagistar> hmm, is there a reason why IO is a special case, and we cannot have a generic version... like class LiftT t m where lift :: t a -> m a
13:16:40 <levi> shachaf: You seem to be taking an overly literal interpretation of what I'm saying; or maybe I'm not sure what your point is.
13:16:48 <fread2282> :t lift
13:16:49 <lambdabot> (MonadTrans t, Monad m) => m a -> t m a
13:16:49 <delrik> in Control.Monad we have that no?
13:16:58 <fread2282> @src MonadTrans
13:16:58 <lambdabot> Source not found. Have you considered trying to match wits with a rutabaga?
13:17:11 <warpy> it is interesting how the nicks in #haskell keep showing up in r/haskell too
13:17:16 <fread2282> kazagistar: we do has a generic version
13:17:29 <delrik> @src lift
13:17:29 <lambdabot> Source not found. This mission is too important for me to allow you to jeopardize it.
13:17:41 <fread2282> :t liftBase
13:17:42 <lambdabot> Not in scope: â€˜liftBaseâ€™
13:17:56 <delrik> (+1)(1)
13:18:06 <delrik> lambdabot has failed me.
13:18:06 <fread2282> > (+1)(1)
13:18:08 <lambdabot>  2
13:18:14 <delrik> =O
13:18:21 <kazagistar> fread2282: does it let you lift arbitrarily deep, like liftIO?
13:18:22 <delrik> faith restored.
13:18:27 <qrada> lmao
13:19:04 <delrik> unrelated, but I just realised what IRC bots are good for.
13:19:31 <kazagistar> insulting people when they fail to ask for valid things?
13:19:38 <delrik> sad that it took me this long to get what all the hubub was about.
13:19:50 <delrik> kazagistar: evaluating my haskell
13:20:00 <delrik> > (+1) 1
13:20:01 <lambdabot>  2
13:20:05 <delrik> =O
13:20:07 <delrik> nice
13:20:15 <fread2282> kazagistar: IIRC, no, but liftBase from transformers-base does
13:20:17 <levi> kazagistar: There's transformers-base that gives you the MonadBase class and liftBase
13:20:17 <qrada> :t (.)(.)
13:20:18 <lambdabot> (a -> b -> c) -> a -> (a1 -> b) -> a1 -> c
13:20:18 <delrik> > :m +Control.Monad
13:20:20 <lambdabot>  <hint>:1:1: parse error on input â€˜:â€™
13:20:31 <syllogismos> what happens when two packages have the same import statements? how do i import the package that I want?
13:20:36 <enthropy> syllogismos: you get the one that's installed
13:20:49 <kazagistar> fread2282: if you have like 5 nested monad transformers, dont you have to lift.lift.lift.lift.lift?
13:21:02 <kazagistar> oh, ok
13:21:13 <enthropy> you can compile with -package theOneIWant, or -hide-package theOneIDontWant
13:21:14 <kazagistar> ( I had chat scrolled up for a sec)
13:21:16 <delrik> I think unless you use mtl monads.
13:21:21 <fread2282> kazagistar: or liftBase or use mtl typeclasses
13:21:30 <enthropy> syllogismos: or ghc-pkg hide theOneIDontWant
13:21:44 <delrik> is ghc-pkg system wide?
13:22:00 <enthropy> it can be
13:22:03 <delrik> I was trying to install cabal-meta today , and its wrecking me >_<
13:22:21 <syllogismos> fpcomplete has a whole bunch of packages installed.. so i'm having issues..
13:22:23 <enthropy> delrik: what happened? I've had no issues with it
13:22:45 <syllogismos> thanks, I think i can change compiling options in fpcomplete
13:22:52 <delrik> entropy: I  fails on that final compile of main
13:23:08 <albeit> @pl (\ a c -> a  + ord c)
13:23:09 <lambdabot> (. ord) . (+)
13:23:11 <levi> syllogismos: Alternatively, there's a GHC extension that lets you qualify imports with the package name you want.
13:23:22 <enthropy> syllogismos: maybe you're supposed to make a .cabal file, which might be a better way to specify those flags
13:23:22 <albeit> @pl (\ a c -> ord c + a)
13:23:23 <lambdabot> (. ord) . (+)
13:23:37 <delrik> http://lpaste.net/105480
13:24:00 <delrik> enthropy: ^^
13:24:15 <albeit> If I need to sum the integral values of every character in a a lazy text, is the best way to just convert to string, and sum the "ord"ed values of each character?
13:25:07 <rwbarton> albeit: I think there is a fold of some kind that will let you avoid building the intermediate list
13:25:33 <albeit> rwbarton: Ohh yes there is, great
13:25:41 <levi> kazagistar: The mtl package provides a set of typeclasses that allow you to use all the actions of your stack without manually composing lifts with the actions.
13:25:47 <rwbarton> the list might get fused away anyways, not sure
13:26:20 <syllogismos> levi: whats the extension?
13:27:05 <fread2282> syllogismos: PackageImports
13:27:07 <enthropy> delrik: the one on hackage works for whatever reason
13:27:28 <delrik> oh cool, I've got the one from Github
13:27:48 <levi> syllogismos: http://www.haskell.org/ghc/docs/latest/html/users_guide/syntax-extns.html#package-imports
13:29:05 <delrik> enthropy: should I sandbox before installing?
13:32:29 <delrik> installed, *shrug* , thanks enthropy
13:36:14 <albeit> If I have a record datatype like "data Foo = Foo {bar :: Int, baz :: Int, ...}", is there a way to get all the fields in a list-like structure to fold over?
13:41:29 <levi> I'm not aware of any straightforward way to do that. You could write a foldFoo function that does it. If you have a whole bunch of similar types, you could probably do some Template Haskell magic to generate the summarizing functions.
13:41:43 <jle`> i think there might be some way using Data or Generics
13:42:10 --- topic: 'http://www.haskell.org/ | Paste code/errors: http://lpaste.net/new/haskell | Logs: http://tunes.org/~nef/logs/haskell/?C=M;O=D http://ircbrowse.net/day/haskell/today?mode=recent | Administrative issues: #haskell-ops | Hackage down? http://hdiff.luite.com | XCode 5 issues? http://is.gd/H4sEub'
13:42:10 --- topic: set by Cale!~Cale@CPEc8d3a35c2cdd-CM78cd8ec9750d.cpe.net.cable.rogers.com on [Sat May 31 02:09:44 2014]
13:42:10 --- names: list (clog Eliel pieter_ Fuco passiveobserver Liskni_si Sgoettschkes steve_himself pcapriotti masak Gothmog_ withaspoon user___ Revenant davidt bmuk tibbe ddellacosta anRch jumblerg predator117 mhi^ TheFuzzb_ msgodf tyfighter olauzon bonobo123 Guest_ dukedave OlegYch favonia ambimorph hoverbear gilligan- otto_s_ kyb3r_ dwcook slogsdon__ meoblast001 kazimir42 lodin mescalinum julmae ozgura coopernurse michaelneale afarmer joaoh82 conal perspectival maxcan PSoBI)
13:42:10 --- names: list (oliverz ioanel1 Kiryx jaga stolaruk streblo d3m1g0d- bones Guest58613 Apocalisp pmade __ru__ Eiam doomlord_1 mr-foobar ndrei Desheng Zariel_ Swizec nschoe sxn tomlane Licenser samrat milessabin osa1 pantsman kmels ferranpm kadoban pkkm mjs2600 c-rog tulcod Welkin davorb path[l] k0001 ninedotnine steamboat hub2 stian delrik Rarrikins calumet dsabanin hseg thrakcattack ompaul kjanosz _Vi stevely w3pm chaptastic tobiasgw folone oleo jang isaacd justinleitgeb)
13:42:10 --- names: list (Gurkenglas importantshock Kaini fran zwer guampa cads silasm Chaze kotopies_ rgr Velpoman lordkryss phischu sagittarian razieliyo nominolo Church- alanz glguy mpiechotka__ aartamonau ixti xenofungus yamadapc Itkovian DanielDiaz klaut niklasb slomo_ hng jeffmo suls LePhin pdxleif dustin10 sellout rs0 cwc eikke__ slacko228201 gabor noam_ _5kg nadirs ystael myoriel trism aristid-ic_ vendethiel PaulVisschers cyclizine jorj Guest89650 MoALTz joneshf-laptop amine_)
13:42:10 --- names: list (jrm2k6_ tremon platz gsingh93_ Sixmsj gniourf lw zzing enthropy chidy artyomkazak danclien levitation[A] q66 jefimenko Vince_Juicy rrradical pweaver_ intrados LordDeath Rakkin CatMtKing latro`a shreesh Betal triliyn tinyblak pavonia jfischoff sjoerd_visscher Haffa hiptobecubic_ boogie mephx tacit7 tomboy65 Kron paper fread2282 kazagistar marr tommd drdanmaku OscarZ seschwar __sebastian__ kiko`` silver whaletechno btcNever` eacameron syllogismos mister_integer)
13:42:10 --- names: list (yubrew__ ArneL detrumi studybot nus- yaymukund dolio ldbrandy haskoiner moghedrin FreeFull eupolis raichoo hmax_ divyanshu Brando753 geokon subleq uzo asmyers lemao seantallen aljosa whyy Reite allay christiaanb tantalum jmcarthur_mobile djbeau niyer Squarism ts33kr_ dmwit Noldorin coltfred croyd seanmcl sgregory pyon Black-Heaven armlesshobo c_wraith cfricke tdammers tolt yogurt_truck paintcan negatratoron_ codesoup bergey kosmikus ZioCrocifisso reizuki_)
13:42:10 --- names: list (phienone Sculptor sea-gull Paprikachu hebz0rl fnordbert slasktask haasn Nickeeh alpounet Svedrin voxpopuli vlads1 Edoxile derdon drdo JokerDoom yumike cpennington kjnilsson zaphar_ps LnL _flatline_ fergusnoble andreypopp AncientPC wagle raid schlumpi xinming_ nsaje Errorific nifty bchar mada derfj_ negatratoron makos wunki Burton SegFaultAX CARAM_ ocharles_ leifw lacrosse_ metadave teehemkay Imdsm seanparsons shennyg_ hammi kgadek dlackty_ liszt kcm1700 x__)
13:42:10 --- names: list (yrdz tnks asQuirreL apaku KorriX plutoniix pragma- mangaba_leitosa sclv jml banister m00nlight integral amatsu jdiez cyphase hiredman chexxor boot13 qwandor Boreeas yorick simukis_ edk djapo shanse reddodgem EvanR_ flojistik yan_ heudebeu bwe gargawel_ jrw tv_ Artpicre tsani RevJohnnyHealey effy Freundlich mpi_ tb01110100 avdi aninhumer Heffalump natte hamarukusa WraithM_ xnyhps blastrock kwmiebach mimi_vx mr- bd_ erkin MindfulMonk lokydor osnr XMunkki Nanar)
13:42:10 --- names: list (mrafiee2 fling knigitz ggreg Ralith eguim Rylee_ smth alphonse23_ shepheb mbrcknl tmobile_ maaku pikhq billyiii Adeon PierreM_ haroldwu t7 horlicks_ redtricy1le jedai tismith_ mshroyer_ Natch metaf5 M-ou-se user Sorella erikd wto anders^^ popx tg shachaf execut3 benj_ dilinger roconnor__ matheus23 SoupE luzie Philonous allsystemsarego eatman io2 banyan elfenlaid poindontcare adlan bsmt mendez obcode adnap vmeson Cale emlow tristanStrange dsantiago cromain)
13:42:10 --- names: list (dcoutts_ infinity0 thetallguy bjz pamojarpan hackagebot c74d ljhms RchrdB MrWoohoo andares lamilami dabradley MercurialAlchemi danvet sunwukong sakirious darthdeus Soft tromp_ shintahW arrdem choosegoose otulp chasecaleb hongminhee frontendloader indigo ivan\ __class__ juhp Rodya_ thunderrd 20WAABZDW 92AABD21A slyfox Arkaniad gregburd npcomp Ankhers litherum jimki taruti desc|zenbook aupiff AntiSpamMeta theorbtwo DT` taktoa rejuvyesh[away] Kazurik Sonderblade)
13:42:10 --- names: list (NobbZ David zebr mechairoi mee sviterok ivoscc ceii Maerten ThatOtherPerson Revenrof tomprince mars-92 Shogun jaimef nicoo mornfall stvc_ iulian saiam_ somenick_ dsturnbull koninkje1away drmegahe1tz wting_ heath ft bitemyapp wollw_ pqmodn prinsen jibi Tesseraction Oxyd totte pfn FliPPeh Someguy123 SCHAAP137 goldfire stephenmac7 LeaChim moop clementd joneshf yeltzooo martingale GGMethos bzf bbloom yrjolam kipras hayashi marienz pi8028 cross d3lxa lpsmith)
13:42:10 --- names: list (thorkilnaur gienah hpc Taneb MasseR helgikrs spacebug Boney kalloc noddy bxc Saizan saurik thoughtpolice spaceships alorente Na6hu7Ud Raynes bstrie fractalcat mads- chrra mandu tamiko stbuehler nesqi sshine srhb peltchu Tene Tehnix CosmicRay b2coutts dcoutts gx^ mirsal Zekka araujo nurupo codygman niko dgvncsz0f mathu troydm Kruppe S11001001 ParahSailin canta SparkySparkyBoom kwantam isomorphic jakutis PragCypher charliekilo jknick george2 ljosha quaestor)
13:42:10 --- names: list (tpsinnem pfurla tumdedum burp cosbykid athan lorem_ipsum blicero Phillemann ghorn DrCode augur nemesit|znc fxr Pythonfant fyolnish l3kn SLi superjudge_ rom1504 ephemeron shergill jpierre03 ninegrid Exio4 harski falafel Dtgr ab9rf genericpersona grantsmith MitchW kerrick gereedy MansurAshraf__ ederign mange deevus nisstyre qtplatypus descender tlevine Bazzie iteratee eikonos tmct z0d Ulrar Maxdamantus Nivim simon_ kakos eazar001 ckw guymann algoriddle)
13:42:10 --- names: list (cognominal KaneTW brackets vladan jaysonsantos aspidites cybrhuman honza mmmm_ SaBer kfish phaskell noplamodo archblob n-dolio Khisanth lojak sbrg magicman Starfire TDJACR saml mikecaruso albeit ivan` hamishmack neptunepink kirelagin cow_2001 pdurbin machineslearn iron_houzi seliopou mietek mindleyhilner u__ Kobata j0ni dfranke zso myme fredsir oconnore MK_FG hpd gdsx Yawgmoth agrif mirf_ monochrom raek orbital_ maoe1 dlundy jlamothe dagle orzo_ qz_ groth)
13:42:10 --- names: list (High-Q-Brah jayne joeyh yriw drbean statewave jrm Rufflewind_ copumpkin Adios davean1 dp_wiz cdidd oubiwann \q semberal tsou happy0 h_chiro lfp Gika kcherkashin__ Ornedan liyang Eelis Lemmih aoh Dodek SHODAN flebron xpika Axman6 bartavelle waterlaz ValicekB mgaare johnw mortberg bbee morolin chrisdone `bps mnemon ski felixn liori diginet Xack zq shutdown_-h_now WarzoneCommand kalz albel727 jonh sw1nn sbyl bjobjo alxgnon blast_hardcheese blenny evax jagtalon)
13:42:10 --- names: list (idnar etrepum DigitalKiwi vermeille1 djahandarie Th0mas annulus gbarboza tych0 boothead akurilin sm arun fikusz_ anders0 frerich g0dmoney Intensity dyreshark wjm mikeizbicki carter Vbitz rwbarton Ezku_ mrd killy9999 FUZxxl fryguybob owlglass PHO_ bvad mami jmct petantik zerokarmaleft thirsteh pnielsen stephe__ cynick lambdabot puzza007 dkua BrianHV Bigcheese Karethoth epta amiller absence tero- korpse______ chas nispaur Reisen sohum sipa brixen regtools)
13:42:10 --- names: list (b_jonas zpconn_______ qrada jle` rschulman jrib shans utkarsh xmm0 Derander Igloo kylcarte idupree_ atota Walther AlainODea Iceland_jack ipuustin_ pnielsen__ FireFly kini docsis__ ReinH ortmage jaj acfoltzer Cr8 Spacegoat bzcat bounb joelteon ajcoppa skarn werdna cjwelborn bailon vikraman RogueShadow nkpart Klumben kxra JPohlmann zenzike warpy jrp6 dxld joefiorini statusbot v0|d` eevar dreixel mrmonday jix_ kaol Chousuke danking mrshoe ByronJohnson ZsoL_)
13:42:10 --- names: list (ziman stepcut jin_jin bgamari mgomezch nakal_ Aune Desoxy jrslepak fussman Baughn theDon cehteh xaimus Lacriatch petterw barrucadu FreakyPenguin `0660 Gracenotes Tordek CindyLinz mokus davidthomas zomg earldouglas supki cschneid zymurgy pot helgar cin_ alang ircbrowse bernalex kittensoup xeno__ imalsogreg dhrosa Internet13 bcoppens mixi davean pranz eyck deavid cdk Nimatek jcsims dogmaT dqd ilmig C-Keen neektza sjy bjorkintosh carlasema finnrobi steshaw)
13:42:10 --- names: list (peddie majackson Jaxan ixian emma yano sveit s4msung drewr Wamanuz untwisted `^_^v Nik05 runde dmilith willb1 l4u tridactyla pyrtsa Bane^ heikkih jasu0 humppa ousado warden [mth] theanine ninzine zeiris ion Averell Lindrian asjo lpaste_ aford_ aseidl eiro thoradam Zariel blz37 Draggor sam_d macron xplat excarna comboy helgikrs1 lykathea Figueroa stiell hive-mind byorgey jlouis catsup nawal petanqk kragniz joar japesinator shelf heyj anoe mbrock dottedmag)
13:42:10 --- names: list (greymalkin frms_ joachifm nik_89 statusfailed AtnNn ahf ernst Kneiva prasm RayNbow` poucet cloudhead levi akshatj Plasmastar mak` n00dle1 joshc mjo farn yusukesuzuki bens lahwran mmaruseacph2 koala_man etabot hvr pyry` stelleg paz felttrip rblackwe ndngvr` saep Profpatsch aji Kabaka flori Enigmagic hc Akita otterdam rlp10 jonathanj tavelram_ peder monsieurp mavam gandr photex HugoDaniel hbar _flow_ iota_ kardboardb egisatoshi_away relrod dixie_ janne andrewsw)
13:42:10 --- names: list (j`ey andyland dustinswan Xorlev akahn tmssgrdn dh AshyIsMe robbert knyppeldynan noteventime nwf flux Sagi tekacs Polarina zz_robj_ mrb_bk inr drone| majoh eagleflo phadej Cerise fall__ coppro awruef kandinski c9sloud Blkt jroesch_ hyPiRion eL_Bart0 PatrickRobotham bjornars gidogeek vera tobyp mattp_ frawgie_ arch__ Raynos strmpnk jzelinskie Bwild [swift] solarus ChongLi heaumer Spockz scopedTV si14 bgyss tomaw numberten keko_ mike4 qr42 `micro Corey GaveUp)
13:42:10 --- names: list (Nshag s_e Jonno_FTW sdx23 geal alexsdut1on TheBrayn JustAPerson joshsz SethTisue_______ jonsterling eribeiro wizonesolutions mankyKitty hegge mrowe_away exicer xahry NickHu Harbinger idoru Athas michaelpj Belgarion0 cods felixsch phaer afleck Fubar^ yggr valdyn Razz prattmic ephess Ke bigos apples ps-auxw _1126 @ChanServ Merovius earthy duairc karls davnils cyrusdavid jaspervdj grohne edwtjo lusory musicalchair sordina2 aristid felipe_ mike2 cpa_ int-e)
13:42:10 --- names: list (OrangeDuck maurer k00mi itsmonkt1stic mero cmsd2 osfameron Laney eyem lispy adimit ciaranm claudiyoh gemelen boegel|work swen shapr codeburg phryk Hardolaf brisbin javawizard wormphle1m cow-orke1 KitB Rembane Fuuzetsu jj2baile Vq opqdonut eyenx ibid applybot rtl sgray10 spion snowp pp^ ejls Kinnison DasIch Watcher7 pfoetchen Deewiant sajith danneu wjlroe cjay BeardedCoder vhz solirc dju znutar_ amontez geekosaur isomorphismes NinjaPenguin melter mxf)
13:42:10 --- names: list (Jello_Raptor jonke_ slobo squimmy Eridius herrwolfe45 yeshuah ofan sgronblo Draconx bra Turboknot13 emmanueloga teeteewhy gaze alinab dropdrive suOya_ ttuegel mlen vsayer enko knyon obiwahn pjdelport kimiamania defanor_ capybara_ pingu ekroon pharaun ccasin dan64 benzrf benedikt mmaruseacph2|umb dschoepe McManiaC mgomes newsham demolithion yac dosequis ryanakca fabjan wjt honkfestival delimax asm89 callumacrae jmcc anachron companion_cube jodaro elrancho_)
13:42:10 --- names: list (Cryovat so posco uncleBlazer ggherdov rieper ehamberg _d3f Ptival dv- antoniy linduxed TakSuyu zeroskillor ChewieBeardy thirsteh_ alcabrera coconnor_ Eagle_Erwin myf jameseb Drezil betawaffle benbangert DustyDingo jzl irssi_ Hafydd luite phaazon Clint nikola saarin)
13:42:13 <bmuk> What is the recommended haskell web framework?
13:43:10 <levi> bmuk: There are several; the biggest active ones are Snap and Yesod, but there are some smaller ones like Scotty.
13:44:16 <levi> There's also Happstack, which is also nice.
13:44:33 <bmuk> levi: I am familiar with haskell but I haven't ever written a web app or website before. Which one, IYO, is the most straightforward, easy to grok, etc. I would like to be able to read the source
13:44:36 <fread2282> :t maybe
13:44:37 <lambdabot> b -> (a -> b) -> Maybe a -> b
13:45:11 <moghedrin> bmuk: I felt Snap was the most straightforward, but I guess that depends what you are familiar with.
13:45:33 <bmuk> moghedrin: I'll look into it, thank you.
13:45:42 <bergmark> bmuk: scotty might be the easiest to understand
13:45:52 <levi> bmuk: Probably Scotty? It's smaller, anyway. Snap is also nice, but has some advanced bits in it.
13:45:55 <bergmark> it's meant to be very light weight
13:48:03 <levi> Happstack is also reasonable, and it's got some very good walkthrough tutorial documentation.
13:48:55 <levi> There are some components you can use with it that are pretty advanced, implementation-wise, but there are also simpler alternatives you can start with.
13:56:25 <jle`> > (:) (:) [] <*> [] <*> []
13:56:26 <lambdabot>  []
13:58:57 <jle`> > (:) (:) [] <*> "abc" <*> ((:[]) <$> "xyz")
13:58:58 <lambdabot>  ["ax","ay","az","bx","by","bz","cx","cy","cz"]
13:59:08 <dottedmag> :t (:)
13:59:09 <lambdabot> a -> [a] -> [a]
13:59:25 <jfischoff> > 1:2:[]
13:59:27 <lambdabot>  [1,2]
13:59:57 <benzrf> u wut
14:00:00 <haasn> > liftA2 (:) "abc" $ map pure "xyz"
14:00:02 <lambdabot>  can't find file: L.hs
14:00:04 <haasn> > liftA2 (:) "abc" $ map pure "xyz"
14:00:06 <lambdabot>  ["ax","ay","az","bx","by","bz","cx","cy","cz"]
14:00:09 <benzrf> > (:[]) <$> "xyz"
14:00:11 <lambdabot>  ["x","y","z"]
14:00:15 <benzrf> i dont know what i expected
14:00:24 <benzrf> > (:) (:) []
14:00:25 <lambdabot>  No instance for (Data.Typeable.Internal.Typeable a0)
14:00:25 <lambdabot>    arising from a use of â€˜M71714228941249200414232.show_M71714228941249200414...
14:00:25 <lambdabot>  The type variable â€˜a0â€™ is ambiguous
14:00:25 <lambdabot>  Note: there are several potential instances:
14:00:25 <lambdabot>    instance Data.Typeable.Internal.Typeable Data.Dynamic.Dynamic
14:00:28 <benzrf> eh
14:00:35 <benzrf> :t (:) (:) []
14:00:36 <lambdabot> [a -> [a] -> [a]]
14:00:56 <fread2282> :t fromJust
14:00:57 <lambdabot> Maybe a -> a
14:01:12 <benzrf> fread2282: dont use fromJust
14:01:15 <benzrf> pattern match eh
14:03:56 <fread2282> is binary (or cereal) lazy enough for me to run it and if I just use the unused input no actual parsing be done?
14:04:03 <tolt> Why not use applicative?
14:04:52 <levi> I love the monkeyface: (:[])
14:05:15 <fread2282>  @djinn
14:05:22 <fread2282>  @help djinn
14:05:29 <fread2282> @help djinn
14:05:29 <lambdabot> djinn <type>.
14:05:29 <lambdabot> Generates Haskell code from a type.
14:05:29 <lambdabot> http://darcs.augustsson.net/Darcs/Djinn
14:05:30 <alpounet> fread2282: what do you mean by "use the unused input"?
14:05:35 <albeit> If a function is passed an instance of a typeclass such as "class Foo a where reqNums :: [Int]", how can that function access that instances reqNums?
14:06:02 <fread2282> alpounet: binaru (and I'm assuming cereal) have an incremental interface that gives you unused input
14:06:11 <benzrf> albeit: you could make it take a dummy arg
14:06:15 <benzrf> i.e.
14:06:26 <benzrf> class Foo a where reqnums :: a -> [Int]
14:06:30 <benzrf> then instance it to be a const
14:06:33 <benzrf> then pass it undefined :: a
14:06:33 <alpounet> fread2282: yeah but what would you do with it?
14:06:51 <benzrf> or just pass it the thing you were passed ;p
14:06:58 <benzrf> im not sure it's possible otherwise
14:07:13 <albeit> benzrf: That sounds fine. When you say instance it to be a const, what does that mean?
14:07:26 <benzrf> like, reqNums = const [1, 2, 3][
14:07:36 <benzrf> albeit: alternatively, you could do this:
14:07:41 <benzrf> oh wait nvm
14:08:32 <fread2282> alpounet: consume it
14:08:42 <albeit> benzrf: Ah got it thanks
14:08:50 <alpounet> fread2282: by doing what?
14:08:58 <alpounet> i'm not sure how you expect no parsing at all from this situation
14:10:22 <gregnwosu> hi guys im trying to compile 7.8 for armhf i guess my first question is does anyone have any binaries
14:10:26 <fread2282> alpounet: parsing it, but I want the part consumed by binary to not be parsed (I don't need the result of that part, I just want to skip it)
14:11:37 <alpounet> well it has to check that the parsers defined that way actually match on your input
14:11:39 <fread2282> @djinn (a -> a -> [a])
14:11:39 <lambdabot> Error: Undefined type []
14:11:44 <benzrf> @hoogle coerce
14:11:46 <lambdabot> Unsafe.Coerce module Unsafe.Coerce
14:11:46 <lambdabot> Unsafe.Coerce unsafeCoerce :: a -> b
14:11:46 <lambdabot> Language.Haskell.TH.Syntax unsafeTExpCoerce :: Q Exp -> Q (TExp a)
14:11:50 <benzrf> hmmmmmm
14:12:08 <benzrf> albeit: another option that doesn't involve undefined is to use Const
14:12:12 <benzrf> the type, i mean
14:13:04 <exicer> I've got a parser that works fine when I load the content via readFile, but never terminates when I stream it with conduit.. any ideas why that might be ?
14:13:28 <albeit> Related question: I want to have basically a type synonym like "forall a. Foo a => IntMap a"... but I can't do that. How can I achieve the same thing?
14:13:30 <exicer> using attoparsec conduit that is
14:13:58 <fread2282> alpounet: yea, but the binary instances provided are either fixed-length or encode a length, I want to know if it's lazy enough to do the minimal required work to skip whatever the binary instance parses
14:14:17 <gregnwosu> well its impressive that anyone can parse a stream
14:14:38 <gregnwosu> how would you parse ^foo.*bar
14:15:05 <gregnwosu> sorry ^foo.*bar$
14:15:09 <exicer> gregnwosu: ? Using attoparsec ?
14:15:24 <gregnwosu> if the stream is never ending how does one know you are at the end
14:15:41 <exicer> gregnwosu: The source sends a Nothing when there is no information left in the file
14:15:52 <alpounet> exicer: you have to wrap the IntMap and the forall in a type decl
14:15:53 <exicer> gregnwosu: If I don't include my parser in the pipeline it is fine
14:17:00 <alpounet> exicer: that should work
14:17:21 <alpounet> fread2282: if it tries the fixed length first for example, yeah I think so
14:17:22 <gregnwosu> sorry forgive me, i didnt think it was possible
14:17:39 <alpounet> it depends on how much your instances force things when decoding
14:18:24 <fread2282> alpounet: the instances have no seqs or bang patterns
14:18:41 <exicer> alpounet: I'm afraid I don't understand ?( What intmap ?
14:19:19 <alpounet> fread2282: yeah but: blah <- someParser; if blah == ... will necessarily consume input to be able to test the value of blah
14:19:26 <alpounet> that's why i mean
14:19:44 <alpounet> exicer: woops, that was meant for albeit, sorry
14:19:58 <delrik> if i want ghc 7.8, can't expect to find it in haskell-platform should i?
14:20:14 <geekosaur> not yet
14:20:23 <exicer> alpounet: How can I force things more ?
14:20:27 <geekosaur> soon.. yet again waiting on ghc (7.8.3 bugfixes, to be specific)
14:20:44 <fread2282> @pl (\a b -> a `cons` singleton b)
14:20:44 <lambdabot> (. singleton) . cons
14:20:53 <delrik> cool, any issues w/ me installing ghc 7.8 myself?
14:21:32 <exicer> I've also determined that parsed values seem to keep being passed to conduitParseEither
14:21:50 <alpounet> i'm not familiar with conduit, sorry
14:22:02 <albeit> alpounet: You're right ha
14:22:59 <rejuvyesh> hi! i am pretty new to haskell and wished to know if there was some version of toList which instead of making a list, combines the elements using <>?
14:23:02 <albeit> Can I have new type to be a type synonym, but also instance a typeclass?
14:24:06 <benzrf> rejuvyesh: toList?
14:24:08 <benzrf> :t toList
14:24:09 <lambdabot>     Not in scope: â€˜toListâ€™
14:24:09 <lambdabot>     Perhaps you meant one of these:
14:24:09 <lambdabot>       â€˜F.toListâ€™ (imported from Data.Foldable),
14:24:14 <benzrf> ah
14:24:18 <geekosaur> albeit: what?
14:24:19 <albeit> Specifically, if I instead use a newtype to wrap a IntClass, then instance that new type, I have to unwrap it everytime to get the IntMap...
14:24:30 <benzrf> rejuvyesh: just foldr mappend mempty
14:24:33 <benzrf> =)
14:24:34 <keko_> :t msum
14:24:35 <lambdabot> MonadPlus m => [m a] -> m a
14:24:54 <keko_> :t mconcat
14:24:55 <lambdabot> Monoid a => [a] -> a
14:24:55 <geekosaur> isn't that mconcat?
14:25:01 <benzrf> geekosaur: on Foldables
14:25:06 <benzrf> @hoogle f m -> m
14:25:08 <lambdabot> Language.Haskell.TH.Syntax Q :: (forall m. Quasi m => m a) -> Q a
14:25:09 <lambdabot> Network.BufferType buf_empty :: BufferOp a -> a
14:25:09 <lambdabot> Data.Monoid getDual :: Dual a -> a
14:25:14 * benzrf shrugs
14:25:19 <benzrf> 05:22 < benzrf> rejuvyesh: just foldr mappend mempty
14:25:36 <Lutin`> :t F.foldr mappend mempty
14:25:37 <lambdabot> (Monoid b, Foldable t) => t b -> b
14:25:42 <geekosaur> albeit: so you want haskell to figure out for itself whether you mean the wrapped or unwrapped type. think about that one for a moment
14:25:46 <benzrf> :t foldr
14:25:47 <lambdabot> (a -> b -> b) -> b -> [a] -> b
14:25:47 <benzrf> :t foldl
14:25:48 <lambdabot> (b -> a -> b) -> b -> [a] -> b
14:25:52 <benzrf> hrm
14:25:58 <Lutin`> :t F.foldr
14:25:59 <benzrf> yep
14:25:59 <lambdabot> Foldable t => (a -> b -> b) -> b -> t a -> b
14:26:12 <tulcod> benzrf: that doesn't sound type safe
14:26:19 <albeit> geekosaur: I know it doesn't make sense, I'm just trying to figure out another way of doing what I'm doing now...
14:26:19 <benzrf> tulcod: what?
14:26:22 <benzrf> what doesnt
14:26:32 <tulcod> benzrf: what you want haskell to do
14:26:38 <benzrf> tulcod: ?!
14:26:41 <Lutin`> tulcod: I think you mean albeit
14:26:42 <benzrf> which thing
14:26:43 <tulcod> ie if there were such a mechanism, presumably you could derive bottom
14:26:50 <tulcod> oops
14:26:52 <geekosaur> tulcod, are you confusing benzrf with albeit?
14:26:53 <tulcod> absolutely sorry
14:26:54 <benzrf> hehe
14:27:19 <mmachenry> Anyone else use the Yi editor?
14:27:32 <rejuvyesh> thanks benzrf !
14:28:14 <fread2282> mmachenry: #yi might be able to help you
14:28:25 * fread2282 kinda does
14:28:39 <Lutin`> :t <>
14:28:40 <lambdabot> parse error on input â€˜<>â€™
14:28:48 <Lutin`> What is <>?
14:28:57 <benzrf> :t (<>)
14:28:58 <lambdabot> Monoid m => m -> m -> m
14:29:00 <fread2282> Lutin`: mappend
14:29:01 <benzrf> infix mappend
14:29:03 <Lutin`> Ah derp
14:29:10 <benzrf> ;)
14:29:12 <Lutin`> that makes sense hehe
14:29:41 <mmachenry> fread2282: Haha, didn't even consider it'd have its own channel :)
14:29:42 <mmachenry> Thanks
14:37:17 <albeit> Example of what I'm trying to do here: http://lpaste.net/105484. It works, but it seems like there should be a better way to than defining "getMap" for every instance... (and future functions to modify the wrapped map, like "modifyMap").
14:39:07 <monochrom> eh, no methods for class TagValue? :)
14:39:27 <albeit> monochrom: There would be, that paste is just a mock
14:39:37 <monochrom> I see
14:40:01 <albeit> monochrom: And hello! Trying to adapt my parser to work as you were trying to explain yesterday, this is just an auxillary issue
14:42:04 <monochrom> do you have many instances of FixConstruct?
14:42:15 <albeit> Main issue is that all "FixConstruct"s are going to be XYZ = XYZ TagMap... then I need to wrap individual types to get the IntMap
14:42:20 <albeit> monochrom: Yes, 10+
14:42:28 <albeit> All of hte form XYZ = XYZ TagMap
14:43:15 <albeit> And only reason I'm wrapping each TagMap is so I can instance XYZ to be a FixConstruct
14:43:15 <monochrom> then I wonder why there are so many types doing the same thing
14:43:49 <albeit> Only reason is that each would have a different set of "requiredTags", and other 'defiining' constants
14:44:13 <crobbins> Anyone know how to enable the XmlSyntax extension for GHC?
14:44:24 <carter> wat
14:44:35 <carter> i'm semi confident no such thing exists
14:44:51 <carter> @google xmlsyntax ghc
14:44:52 <lambdabot> http://www.haskell.org/ghc/docs/7.0.4/html/libraries/Cabal/Language-Haskell-Extension.html
14:44:52 <lambdabot> Title: Language.Haskell.Extension
14:45:18 <carter> huh
14:45:20 <alpounet> it does yeah
14:45:22 <monochrom> it is possible that what you have now, though seemingly repetitive, is already the best way to satisfy all requirements of sanity and safety
14:45:27 <carter> crobbins: {-# LANGUAGE XmlSyntax #-}
14:45:43 <crobbins> thanks carter, but that doesn't seem to work for me
14:46:16 <carter> whats it supposed to do?
14:46:37 <kazagistar1> http://www.haskell.org/haskellwiki/HSP
14:47:04 <crobbins> I get: Unsupported extension: XmlSyntax
14:47:11 <carter> crobbins: in cabal or GHC?
14:47:16 <crobbins> when using the language pragma
14:47:20 <carter> what ghc ?
14:47:22 <Eduard_Munteanu> Why are there no resumable sinks? It doesn't matter for sinks?
14:47:22 <carter> version
14:47:27 <rwbarton> what is XmlSyntax
14:47:28 <carter> Eduard_Munteanu: what does resumable mean
14:47:31 <crobbins> The Glorious Glasgow Haskell Compilation System, version 7.6.3
14:47:43 <exicer> Does anyone know how Conduit.Attoparsec streams stuff? I mean, how does it deal with stuff being chunked midway through parsing ?
14:47:46 <monochrom> the other possibility is that you should not use 10 types, but rather 1 type and 10 values. data Object = Obj { requiredTags :: Set.Set Int, tagMap :: TagMap }. have 10 such records.
14:48:19 <Eduard_Munteanu> carter: that you can connect a source to it, disconnect it, then connect another one and the sink wouldn't even know.
14:48:37 <monochrom> and by "have 10 such records" I mean they all have the same type Object. "r1, r2, ..., r10 :: Object; r1 = Obj { requiredTags = ..."
14:48:41 <carter> Eduard_Munteanu: "connect and disconnet" sound statefull
14:48:57 <rwbarton> crobbins: there is no XmlSyntax extension in GHC
14:48:59 <albeit> monochrom: Speak of the devil, I was actually just trying that out. And then instead of FixHeader, I could have makeFixHeader that just returns an Object. I guess only issue then is its possible for the "constant" requiredTags field to be modified later...
14:49:29 <rwbarton> crobbins: I guess it is for some mythical other compiler
14:49:32 <crobbins> rwbarton: i guess i'm wondering, why is it available in Language.Haskell.Extensions?
14:49:37 <albeit> .... but then I could wrap it in a newtype and not export any functions that allow modification of the constant fields!
14:49:39 <albeit> Ahhh
14:49:41 <Eduard_Munteanu> carter: do { yield Foo; yield Bar } $$ resumableSink   vs   yield Foo $$ resumableSink; yield Bar $$ resumableSink
14:49:54 <rwbarton> crobbins: good question
14:50:03 <carter> burn the witch?
14:50:10 <rwbarton> in theory, Cabal is not GHC-only
14:50:20 <carter> its getting more multi compiler friendly too!
14:50:20 <crobbins> is it some theoretical extension that does not exist yet?
14:50:23 <carter> haskell-suite + GHCJS
14:50:27 <carter> crobbins: or is REALLY OLD
14:50:37 <rwbarton> I think it's more like some extension that exists in some abandoned fork of GHC or other compiler entirely
14:50:41 <monochrom> r1, ... r10 can be "internal code" so that only one module can possibly screw them up, but that module is so short you obviously see it doesn't screw up
14:50:55 <rwbarton> Also, I'm just assuming it's abandoned because it seems that all forks of GHC are eventually abandoned.
14:51:00 <ramers> hello  i  want   know    how  make  script  irc . ? .
14:51:13 <rwbarton> (unless they're merged back into GHC)
14:51:46 <crobbins> cool, i'll let it go for now, i was curious why it was there and if it was possible to use
14:53:04 <ramers> hello  world .
14:53:11 <sevak> > read "3"
14:53:13 <lambdabot>  *Exception: Prelude.read: no parse
14:53:19 <sevak> why does this happen?
14:53:27 <albeit> monochrom: Sounds good
14:53:28 <ramers> i  want   know    how  i  can  use   script   in  mirc .
14:53:33 <ramers> i  want   know    how  i  can  use   script   on  mirc .
14:53:50 <sevak> > show "3"
14:53:52 <lambdabot>  "\"3\""
14:53:55 <fread2282> ramers: ?
14:53:57 <sevak> > show 3
14:53:58 <lambdabot>  "3"
14:54:02 <rwbarton> sevak: because of type defaulting. in this case, it defaulted the type to ()
14:54:15 <rwbarton> > read "()"
14:54:17 <lambdabot>  ()
14:54:32 <crobbins> carter, rwbarton: btw, blame on github shows that extension was added 2009-05-29
14:54:42 <crobbins> so it could just be old
14:54:53 <monochrom> ramers, this channel does not deal with mirc scripts. I don't know which one does, and I don't care. this channel doesn't.
14:54:57 <ramers> i   really  want   know   how i  can  use  script  chere  .  se  on  mirc .
14:55:01 <ramers> i   really  want   know   how i  can  use  script  chere  .  use  on  mirc .
14:55:05 <ramers> i   really  want   know   how i  can  use  script  chere  .  use  on  mirc .
14:55:08 <sevak> rwbarton: hmmm, thanks I'll read up on that, so is there a way to express that correctly?
14:55:13 <ramers> i   really  want   know   how i  can  use  script  where  .  use  on  mirc
14:55:17 --- mode: ChanServ set +o monochrom
14:55:21 <rwbarton> sevak: well, you can do this
14:55:24 <rwbarton> > read "3" :: Int
14:55:26 <lambdabot>  3
14:55:56 <Eduard_Munteanu> Huh, how do you "request" someone to leave?
14:56:14 <sevak> so there you explicity provided the type correct?
14:56:24 <rwbarton> yes
14:56:29 <monochrom> the command is "remove". it seems available to freenode only
14:56:34 <ramers> what   yes ?
14:56:37 * hackagebot loops 0.1.0.0 - Fast imperative-style loops  http://hackage.haskell.org/package/loops-0.1.0.0 (ThomasTuegel)
14:56:39 <Eduard_Munteanu> Ah.
14:56:47 <ramers> i   give   one  question
14:57:16 <ramers> i am not  jews .
14:57:22 <sevak> rwbarton: why does it assume the type to be () ?
14:57:23 <ramers>  you know;
14:57:26 <ramers>  you know;
14:57:35 <ramers>  you know.
14:57:38 <tolt> Does anyone know how to change the maximumContentLength for a route?
14:57:41 <Eduard_Munteanu> ramers: stop flooding
14:57:43 <jnott> you must skeep haskell here ramers you will get kick
14:57:43 --- mode: monochrom set +b *!*@cha92-4-82-224-226-31.fbx.proxad.net
14:57:49 <tolt> using yesod* Sorry for that
14:57:51 <sevak> rwbarton: or maybe I should go read
14:58:08 <fread2282> ramers: this is not the channel you are looking for
14:59:11 <Eduard_Munteanu> Channel? He's "on mirc". :)
14:59:13 <monochrom> I mistakenly thought that +b already implied censorship
14:59:55 <Eduard_Munteanu> monochrom: is remove any different from kick? Does the user get asked for confirmation or something?
15:00:57 <monochrom> remove is different in this sense: it simulates the client side asking for /leave . the user is not consulted, it's compulsory
15:00:58 <Eduard_Munteanu> I still get annoyed by people in this area saying "irc? oh, mirc..." when I mention IRC-ing.
15:01:27 <albeit> I'm getting a type erro that I can't figure out... code (~ 10 lines) and the error are here: http://lpaste.net/105486
15:01:30 <deweyvm> why would ByteString.hGet choke on binary data? i'm getting Enum.toEnum{Word8}: tag (8217) is outside of bounds (0,255)
15:01:35 <carter> thanks monochrom
15:01:41 <deweyvm> i thought the whole point was to read as raw binary
15:01:54 <monochrom> people have been saying "I got sweaty doing Xerox copies, hand me a Kleenex please" all the time :)
15:02:04 <Eduard_Munteanu> Heh, I got thrown off by "ramers [...] has *left* #haskell (*requested* by [...])", which seemed to imply a polite request. :)
15:02:57 <monochrom> "remove" exists to confuse client software that detects getting kicked :)
15:03:02 <fread2282> can I do multi-statment let blocks in do?
15:03:07 <Eduard_Munteanu> Oh. :/
15:03:07 <monochrom> yes
15:03:17 <kadoban> fread2282: Sure.
15:03:18 --- mode: monochrom set -o monochrom
15:03:56 <monochrom> just make sure your indentation is right
15:04:29 <sshine> Eduard_Munteanu, I used to get annoyed at "on mirc", but now I get nostalgic. :)
15:05:18 <benzrf> why the hell do people use mirc anyway
15:05:42 <monochrom> that is isomorphic to "why the hell do people use windows"
15:05:54 <sshine> benzrf, it was a good, free IRC client.
15:06:03 <monochrom> I still don't know why, but it is here to stay
15:06:48 <monochrom> a lot of it is historical accidents and first-to-market. nothing more. nothing deep. nothing meritocratic. nothing meaningful.
15:07:24 <acowley> They've done a pretty good job at backwards compatibility
15:07:30 <sshine> I disagree. for windows there weren't a lot of good clients for a long time.
15:07:35 <monochrom> you may as well ask, "why wasn't I born into another family"
15:07:37 <acowley> Which has let a lot of companies nurse old investments for ages
15:07:44 <benzrf> yeah, why WASNT i?
15:07:47 <monochrom> hehe
15:08:13 <monochrom> anyway, why don't you use more haskell!
15:08:27 <acowley> benzrf: Take it up with the sorting hat
15:11:50 <Eduard_Munteanu> You can also blame the users, though.
15:11:52 <mietek> @pl foo xs@(x : ys) = foo ys `seq` xs
15:11:53 <lambdabot> (line 1, column 18):
15:11:53 <lambdabot> unexpected " "
15:11:57 <mietek> What's up with that?
15:12:01 <slack1256> Are syb and uniplate on the same niche? changing a data-type deep in a hierachy without writing the boilerplate?
15:12:10 <slack1256> Or are used in different scenearios?
15:12:13 <shachaf> mietek: @pl only handles part of Haskell syntax.
15:12:39 <shachaf> It's not really handling Haskell, just an untyped language similar to Haskell.
15:12:44 <mietek> Ah.
15:12:51 <shachaf> @pl (\x -> x x)
15:12:52 <lambdabot> join id
15:12:57 <mietek> @pl foo xs@(x : ys) = seq (foo ys) xs
15:12:58 <lambdabot> (line 1, column 18):
15:12:58 <lambdabot> unexpected " "
15:13:00 <shachaf> @pl (\x -> x x) (\x -> x x) -- Er, that.
15:13:04 <lambdabot> ap id id (ap id id)
15:13:04 <lambdabot> optimization suspended, use @pl-resume to continue.
15:13:26 <mietek> heh
15:13:27 <shachaf> So it doesn't handle @-patterns, and pattern-matching with @pl is a bad idea in the first place.
15:13:58 <sshine> @pl-resume
15:14:04 <lambdabot> ap id id (ap id id)
15:14:04 <lambdabot> optimization suspended, use @pl-resume to continue.
15:14:04 <mietek> Is there a forceSpine somewhere in HHL?
15:14:23 <mietek> There's one in the comments in http://hackage.haskell.org/package/stream-fusion-0.1.2.2/docs/src/Data-List-Stream.html
15:14:30 <albeit> Okay got my non-working code down to the most minimal possible... http://lpaste.net/105488.
15:14:46 <albeit> Getting a "could not deduce (_ a0) arising from the use of ___ from the context (_ a)
15:14:50 <albeit> And I have no idea why...
15:15:07 <monochrom> oh great, shachaf's loopy code has sent @pl into a loop :)
15:15:52 <latro`a> :t join id (join id)
15:15:53 <lambdabot>     Occurs check: cannot construct the infinite type: a0 ~ a0 -> a
15:15:53 <lambdabot>     Expected type: (a0 -> a) -> (a0 -> a) -> a
15:15:54 <lambdabot>       Actual type: (a0 -> a) -> a0 -> a
15:16:13 <latro`a> ah yes
15:16:20 <latro`a> hmm...
15:16:22 <latro`a> :t fix fix
15:16:23 <lambdabot>     Occurs check: cannot construct the infinite type: a ~ a -> a
15:16:23 <lambdabot>     Expected type: (a -> a) -> a -> a
15:16:23 <lambdabot>       Actual type: (a -> a) -> a
15:18:50 <hexagoxel> albeit: tried newtype instead of type?
15:19:32 <albeit> hexagoxel: I was trying to avoid that to avoid wrapping/unwrapping it every time
15:23:23 <exicer> What is the graceful way to deal with "not enough input" in attoparsec ?
15:23:33 <benzrf> exicer: in what context?
15:24:00 <exicer> I'm streaming some data with conduit.attoparsec
15:24:11 <exicer> I'm pretty sure I've done this in a stupid way.. let me lpaste it
15:24:39 <acowley> exicer: feed it more
15:25:40 <monochrom> have someone with a nice voice record a voice clip of "please provide more input". play it every time you have not enough input.
15:26:02 <rwbarton> albeit: it doesn't know at what type it should call "tags construct"
15:26:03 <exicer> acowley: It is the end of the input..
15:26:18 <exicer> http://lpaste.net/1015365792448905216
15:26:20 <acowley> Give it an empty input
15:26:31 <rwbarton> albeit: and yes it's irrelevant here since you don't use t at all, but I guess GHC does not care about that
15:26:32 <acowley> If you don't need the partial input feature, you can use parseOnly
15:26:33 <exicer> I'm streaming from a file, and using regRegionParser' to decoe
15:27:11 <exicer> acowley: I think I don't have this control, since the parsing is done by Data.Conduit.Attoparsec.conduitParseEither
15:27:33 <acowley> exicer: Ah, sorry! I'm not familiar with conduit, unfortunately.
15:27:49 <exicer> It basically works for all of my input, as I want.. until the last line
15:27:56 <exicer> wait
15:28:08 <exicer> of course it can't decode something when there isnt enough input..
15:28:11 <exicer> what an idiot
15:40:38 <exicer> Actually, does anyone know if there is a way to stream Text from a conduit into a file ?
15:42:21 <Eduard_Munteanu> exicer: Data.Conduit.{Text,ByteString} from conduit-extra
15:42:49 <benzrf> conduits vs pipes?
15:42:52 <exicer> Eduard_Munteanu: Is there a sink in Data.Conduit.Text ?
15:43:06 <benzrf> vs masheenz?
15:43:07 <Eduard_Munteanu> exicer: there's one in ByteString, which you can use after encoding
15:43:15 <exicer> Eduard_Munteanu: Ah, good point. Thanks.
15:44:39 <johnw> acowley: hey there
15:45:06 <johnw> exicer: sourceFile ... $= decode utf8
15:45:12 <johnw> exicer: sourceFile ... $= decodeUtf8, even
15:45:19 <johnw> (if you're using conduit 1.1)
15:45:50 <fread2282> benzrf: conduit has a better finalization story, machines has no libraries or users, pipes is based on category theory more and IMO the high-level interface is more flexible
15:46:07 <fread2282> I'm using conduit
15:46:55 <benzrf> finalization sotry?
15:46:57 <benzrf> *story
15:46:59 <benzrf> :T (%=)
15:47:04 <benzrf> :t ($=)
15:47:05 <lambdabot>     Not in scope: â€˜$=â€™
15:47:05 <lambdabot>     Perhaps you meant one of these:
15:47:05 <lambdabot>       â€˜$!â€™ (imported from Prelude), â€˜/=â€™ (imported from Data.Eq),
15:47:07 <benzrf> o:
15:47:09 <benzrf> :t ($!)
15:47:10 <lambdabot> (a -> b) -> a -> b
15:47:50 <fread2282> benzrf: closing handles automatically
15:48:31 <benzrf> but machines is by edwardk
15:48:35 <benzrf> how is it not the most popular one???
15:50:36 <fread2282> benzrf: disclaimers saying that it's not ready yet
15:50:38 <johnw> it's still a bit of a work in progress
15:51:21 <bmuk> does anyone know of any internships in haskell outside of ghc/academia?
15:51:33 <johnw> in case anyone here loves free monads, this may be of passing theoretic interest: https://github.com/jwiegley/notes/blob/master/MoreFree.hs
15:51:56 <johnw> bmuk: BAE has an internship program; I know we have a summer intern from IU right now (Ed Amdsen)
15:51:57 <fread2282> benzrf: pipes and conduit are becoming more similar over time
15:52:31 <jfischoff> johnw: yeah better names
15:53:06 <bmuk> johnw: BAE as in baesystems.com?
15:53:10 <johnw> yes
15:53:22 <johnw> particularly the SAFE project; I'm not sure if we're full up or not, but it can't hurt to ask
15:54:06 <jfischoff> wait I thought you worked at FP Complete?
15:54:24 <johnw> that contract ended; now I do PL research at BAE Systems
15:54:33 <jfischoff> ah cool
15:54:49 <bmuk> what would you expect them to look for in a potential candidate?
15:55:12 <albeit> rwbarton: So I fixed the previous error by giving a type definition, but for the real function I'm trying to do the error pops back up again. I feel like I'm playing whack-a-mole. Specifically, it doesn't know what type "v" is on the last line: http://lpaste.net/105492
15:55:21 <johnw> bmuk: a passionate interest in FP and programming language theory and design; deep knowledge of Haskell is not really necessary, but it helps
15:55:37 <albeit> But "v" was defined in the type definition to be TagValue a... so I'm not sure what else it needs?
15:55:44 <johnw> all of our tooling is in Haskell, but the subject of the research isn't
15:56:05 <jfischoff> so when profiling, you discover all of the time is in SYSTEM and CAF GHC.IO.Handle.FD   what to do?
15:56:19 <bmuk> johnw: do you think interns would be able to move up or would it just be a summer thing?
15:56:20 <johnw> jfischoff: it means you are totally IO bound, right?
15:56:37 <johnw> bmuk: I'm certain you could move up, if you're willing to relocate to Massachussettes
15:56:52 <jfischoff> I suppose so
15:57:10 <johnw> jfischoff: try profiling with a RAM disk as the backing storage
15:57:10 <bmuk> johnw: I definitely would be, but I'm not there right now (Florida)
15:57:31 <johnw> bmuk: yeah, Ed is temporarily relocated to MA for the summer, for example
15:57:35 <jfischoff> Its the zookeeper bindings I think
15:58:14 <rwbarton> albeit: you can't write your addTag function at all
15:58:15 <Tene> jfischoff: you could run it under perf, to get system-level profiling.
15:58:25 <jfischoff> what's perf?
15:58:26 <Tene> 'perf record ./whatever; perf report'
15:58:38 <rwbarton> albeit: well maybe you can. depends on what TagValue is I guess
15:58:40 <jfischoff> good to know
15:58:46 <Tene> jfischoff: linux profiling tool; apt-get install linux-tools
15:59:05 <jfischoff> oh it turns out I have it
15:59:19 <Tene> jfischoff: Yep, we install it from cfengine; I added that a couple of years ago
15:59:20 <albeit> rwbarton: Well... I was planning on instancing Int Text and some custom types to TagValue
15:59:51 <albeit> rwbarton: Two functinos would be :: a -> Data.Text.Builder, :: Attoparsec.Parser a
16:00:17 <albeit> rwbarton: How does it depend on what TagValue is?
16:00:22 <Tene> jfischoff: you might need to install debug symbols for a few libraries if you want useful output, thoguh
16:01:13 <rwbarton> albeit: Construct is a value that you can turn into an IntMap a for *any* a you like that's an instance of TagValue
16:01:33 <rwbarton> albeit: so I can turn it into an IntMap Int, and also an IntMap Text and so on
16:01:51 <jfischoff> Tene: thanks, I'm going to try some things
16:01:54 <acowley> johnw! I enjoyed reading about your simple-conduit library
16:02:08 <johnw> thank you, I've been plugging away at it some more
16:02:14 <rwbarton> if I have such a thing and then a value of some TagValue type that somebody else chose, I can't produce a new such thing by inserting
16:02:17 <joeyh> yay, I've fixed the windows getCurrentTimeZone issue.
16:02:19 <johnw> Source is now a monad ala ListT
16:02:23 <albeit> rwbarton: So I guess I need to be an IntMap a for *all * a where TagValue a =>
16:02:28 * joeyh wonders when he became a windows haskell porter :/
16:02:31 <Tene> jfischoff: Glad to help; hope it works out for you.
16:02:37 <johnw> but is still just a newtype wrapper around the fold function type
16:02:40 <rwbarton> because maybe you only handed me an Int, so I can't insert it into the IntMap Text
16:03:31 <acowley> johnw: It reinforced my feeling that we've overcomplicated things
16:03:48 <acowley> but I'm willing to believe that exceptions ruin everything
16:04:01 <albeit> rwbarton: Is there any way to have IntMap that holds values of all types (TagValue a => a) instead of any?
16:04:32 <johnw> acowley: it's a tradeoff between complexity and expressivity.  simple-conduit is terrible at letting you inject exception handling into the pipeline; exceptions abort the whole thing, periods.  But if that's exactly what you want, why pay for the expressivity?  There should be options
16:04:34 <rwbarton> your use of quantifiers is strange to me, but yes
16:04:58 <albeit> rwbarton: Ha yeah, was just trying to differentiate from your *any*
16:05:01 <acowley> johnw: Yes, my main reservation is that I wish you'd actually been stricter about keeping the package simpler!
16:05:09 <rwbarton> data SomeTagValue = forall a. TagValue a => SomeTagValue a -- or data SomeTagValue where SomeTagValue :: TagValue a => a -> SomeTagValue
16:05:59 <acowley> johnw: e.g. move ($=) and friends to a conduit-compat module/package, and keep a core with even fewer dependencies
16:06:22 <rwbarton> albeit: perhaps "some", rather than "all". it's hard to write the quantifiers unambiguously in english
16:06:26 <acowley> johnw: Because I think your article working through the development makes the very good point that the main pieces are just plain Haskell
16:07:00 <rwbarton> albeit: if you have a SomeTagValue, that means you have a value of some type a that is an instance of TagValue, but you don't know anything else about the type
16:07:00 <johnw> acowley: you know, that's a very good point
16:07:03 <johnw> acowley: I'll do that
16:07:21 <rwbarton> albeit: note that this is likely the so-called existential type class antipattern  http://lukepalmer.wordpress.com/2010/01/24/haskell-antipattern-existential-typeclass/
16:07:23 <johnw> simple-conduit's core really has nothing to do with conduit, and much of what's there is a compatibility layer
16:07:32 <acowley> Yeah!
16:07:51 <acowley> I think everything got off on the wrong foot in part due to the way Iteratees were first presented
16:07:59 <johnw> right
16:08:02 <acowley> which left virtually everyone scratching their heads for like six months
16:08:18 <johnw> acowley: have to run now, but thanks for the good ideas!
16:08:24 <acowley> np!
16:08:29 <rwbarton> perhaps we need more conduit-like words
16:08:38 <rwbarton> aqueduct
16:08:41 <acowley> haha
16:09:02 <johnw> channel
16:09:04 <rwbarton> I guess that is the lens approach
16:09:08 <jfischoff> acowley: a lot people are confused about what conduit/pipes solve. For instance I've heard use conduit instead of lazy bytestrings :p
16:09:52 <fread2282> > map ((+1) $) [1,2,3,4]
16:09:54 <lambdabot>  [2,3,4,5]
16:09:55 <acowley> I'm of the opinion that the anti LazyIO arguments boiled over into FUD territory
16:10:07 <acowley> But I realize that's controversial
16:11:54 <copumpkin> fread2282: you shouldn't need the $ there
16:13:01 <rwbarton> acowley: I couldn't agree more; but it seems to me that the anti-lazy IO sentiment has mellowed recently
16:13:33 <acowley> rwbarton: One of my favorite comments ever: http://www.reddit.com/r/haskell/comments/1o1ink/the_core_flaw_of_pipes_and_conduit/cco6z70
16:15:06 <jfischoff> drops mic *jealous*
16:15:09 <acowley> Do typed holes not play well with idiomatic lens usage, or is that just a ghc-mod issue?
16:15:32 <tmobile> HASKELL DETECTED
16:15:47 <rwbarton> actually I think there is a more general phenomenon of "don't use X" when there are still many valid uses of X, even though there are also alternatives Y
16:16:04 <sclv> carter: seen this?
16:16:05 <rwbarton> e.g.: X = regular expressions, Y = parser combinator libraries
16:16:05 <sclv> http://www.haskell.org/pipermail/haskell-cafe/2014-June/114562.html
16:16:21 <sclv> it would be nice if someone (nudge nudge) filed a ticket :-P
16:16:21 <rwbarton> there are few valid uses of "don't use X"
16:17:22 <monochrom> strangely, I was supportive of lazy I/O at the time it was attacked most strongly, and I am against lazy I/O now that no one attacks it :)
16:18:25 <monochrom> I think this is because between those two moments, I carefully explained lazy evaluation and recently Haskell I/O.
16:18:47 <jfischoff> oh?
16:18:52 <acowley> what?
16:19:17 <jfischoff> monochrom: what did you learn?
16:19:21 <Ghoul_> lazy IO makes a lot of sense w.r.t Haskell as a language
16:19:40 <acowley> How did you "recently Haskell I/O" or did I get whooshed?
16:19:46 <Ghoul_> not to mention, a lot of base library code uses unsafePerformIO or similar, and it would make that code inconsistent
16:19:49 <monochrom> without lazy I/O, both stories are simple and simply mergeable. with lazy I/O, their merger is much more complicated
16:19:52 <Enigmagic> i accidentally the whole thing
16:20:08 <jfischoff> ha
16:20:12 <acowley> Enigmagic: Lazy IO usually involves accidentally not the whole thing
16:20:21 <Ghoul_> haha
16:20:29 <monochrom> acowley, "carefully explained, recently, Haskell I/O"
16:20:35 <acowley> I am intrigued by recentlying the whole thing
16:20:41 <jfischoff> i accidentally the  <resource vanished>
16:20:45 <acowley> hahah
16:20:55 <Enigmagic> <<loop>>
16:25:15 <albeit> In the exisential typeclass antipattern, its suggested to change "class Foo a where func :: Int -> a -> String" is changed to "data Foo = Foo { render :: Int -> String }". But how can I translate a monadic operation? Like when a function of hte typeclass is "parse :: Parser a"?
16:25:50 <Lutin`> lol woops looks like I need more RAM in this VM
16:25:55 <Lutin`> cabal just got killed when updating
16:26:00 <monochrom> data Object a = Obj { parse :: Parser a, ... }
16:26:27 <jfischoff> has anyone every used this: Control.Monad.Adaptive
16:26:32 <jfischoff> errr http://hackage.haskell.org/package/Adaptive-0.23/docs/Control-Monad-Adaptive.html
16:26:40 <albeit> monochrom: Ah
16:26:51 <Enigmagic> jfischoff: i don't use packages that start with an uppercase character
16:27:01 <monochrom> strange rule :)
16:27:06 <taktoa> Enigmagic: why
16:27:37 <Enigmagic> taktoa: i prefer lowercase package names
16:27:56 <jfischoff> the mark of quality
16:28:01 <taktoa> well I guess I can't argue with that
16:28:01 <Enigmagic> indeed
16:28:19 <rwbarton> isn't the package name case-insensitive anyways? you could pretend
16:28:37 <Enigmagic> rwbarton: nope
16:28:40 <Enigmagic> case sensitive
16:28:44 <monochrom> cabal install adaptivE
16:29:12 <Enigmagic> i have a fork of QuickCheck that just changes the package name to quickcheck
16:29:21 <monochrom> do you accept package names full of numbers but no letter?
16:29:23 <Enigmagic> that way i didn't have to break my rule ;-)
16:29:29 <sclv> jfischoff: it is based on a good paper :-)
16:29:34 <rwbarton> weird, it works fine on the command line (cabal install adaptive)
16:29:39 <sclv> and iirc the author has written pretty nice code in the past
16:29:46 <sclv> but i canâ€™t speak to the lib per se
16:29:46 <monochrom> my command above also works
16:29:47 <jfischoff> the follow up this year looks very interesting
16:30:21 <Enigmagic> sclv: i don't think it works if you list it as a package dependency though
16:30:25 <acowley> rwbarton: cabal-install follows its own rules
16:30:31 <acowley> rwbarton: Which are unique unto it
16:30:35 <rwbarton> fascinating
16:30:39 <monochrom> I see
16:30:44 <sclv> jfischoff: is the followup accepted at icfp?
16:30:47 <jfischoff> yeah
16:30:49 <sclv> i have yet to read thru that whole list
16:30:58 <albeit> monochrom: Using the way you just described "data Object a = Obj { Parse :: Parser a}", I then can't make a "IntMap Object" then, because it could only an IntMap of Objects of a specific "a", right?
16:31:13 <monochrom> that is true
16:31:39 <sclv> wait looking at the list i donâ€™t see something with â€œadaptiveâ€ or â€œincrementalâ€ in the name
16:31:41 <sclv> what paper?
16:31:53 <jfischoff> sclv: one sec
16:31:58 <albeit> So it that an instance where the existential typeclass antipattern is not an antipattern, but a fair way to do it?
16:32:06 <monochrom> I don't know
16:32:57 <jfischoff> sclv: Functional Programming for Dynamic and Large Data with Self-Adjusting Computation
16:33:16 <sclv> ah cool thx
16:33:53 <albeit> rwbarton: Not sure if you've been following... but would it still be considered an anti-pattern to use existenion typeclasses when one of hte functions of the typeclass is a monad computation, like "func :: Parser a"?
16:33:57 <jfischoff> they moved onto a "implicit" approach, annotate types and transform the program
16:34:17 <jfischoff> or something like that, only skimmed
16:37:02 <sclv> the list doesnâ€™t have the url, if you have it, you should send a pull request: -) https://github.com/yallop/icfp2014-papers
16:38:35 <jfischoff> I don't have it, I read some of there recent ones on the same subject: http://www.umut-acar.org/publications-by-year
16:39:00 <jfischoff> "read" ~ looked at
16:39:00 <andkore> Should I bother trying to avoid using MultiParamTypeClasses, or should I just use it?
16:39:05 <jfischoff> use it
16:39:08 <acowley> use it
16:39:14 <andkore> OK, thanks
16:39:23 <monochrom> don't use it for evil
16:39:23 <shachaf> Depends on the situation. It's not a bad extension if you need it.
16:40:26 <jfischoff> it will lead to pain either way
16:40:39 <andkore> jfischoff: What do you mean?
16:40:56 <acowley> jfischoff: Do you have any code that uses Adaptive?
16:41:04 <jfischoff> there are not really any good resources on how instance selection works
16:41:20 <jfischoff> acowley: no I was hoping to find someone that did :p
16:41:34 <enthropy> jfischoff: I think the ghc manual is probably the best
16:41:40 <jfischoff> I think the idea of adaptive computation is very cool though
16:42:05 <jfischoff> enthropy: yes, but too dry for most beginners. To fast, lots of new terminology
16:42:20 <acowley> jfischoff: The types aren't the clearest thing in the world to follow
16:42:28 <jfischoff> yeah
16:42:52 <jfischoff> some examples would be helpful, maybe there are some ...
16:43:01 <enthropy> yes there are some
16:43:30 <jfischoff> enthropy: in adaptive?
16:43:40 <acowley> I also try to follow a rule of not using packages with no docs
16:43:55 <jfischoff> and yet you use ed's code ;)
16:44:03 <enthropy> I mean in sections like http://www.haskell.org/ghc/docs/7.8.2/html/users_guide/type-class-extensions.html#instance-overlap
16:44:03 <jfischoff> I kid he has doc these days
16:44:07 <acowley> He's why I said "try"
16:44:14 <jfischoff> enthropy: too conversations
16:44:17 <jfischoff> err two
16:44:28 <jfischoff> acowley: :)
16:45:18 <acowley> It's not a bad rule.
16:51:03 <sclv> look! an example! https://github.com/carlssonia/adaptive/blob/master/spreadsheet.hs
16:51:51 <albeit> If I have a typeclass "data Foo = forall a. Bar a => makeFoo a", and I create a foo like "foo = Foo (5 :: Int)" (assuming Int is an instance of Bar), is there any way to get back the Int value of 5 from foo later?
16:52:04 <benzrf> albeit: there are no classes here
16:52:20 <benzrf> albeit: and no
16:52:27 <benzrf> not unless you have a function Bar a => a -> Int
16:52:29 <rwbarton> it depends on what Bar is
16:52:46 <albeit> benzrf: Wrote typeclass to refer to Bar, not Foo, sorry
16:52:46 <geekosaur> that is not a typeclass, it is not legal (makeFoo?), it is only going to be accessible via whatever Bar provides
16:55:12 <albeit> benzrf: That function would be an instance of the Bar typeclass, right?
16:55:56 <benzrf> albeit: no, a method
16:56:13 <albeit> Ah I am messing up words, sorry, method not instance
16:57:20 <monochrom> albeit, a main feature of existential type is that you cannot get back the inner type. you can get back its value, but it comes with an unknown type.
16:57:59 <albeit> monochrom: But if I can get back its value, could I compare that value to other values of the same type?
16:58:41 <enthropy> @type cast
16:58:42 <lambdabot> (Typeable b, Typeable a) => a -> Maybe b
16:58:46 <monochrom> yes. if those other values are known to have the same type
16:58:56 <Ghoul_> casts, in Haskell
16:58:58 <Ghoul_> for what reason?
16:59:26 <enthropy> for albeit trying to compare two values that may or may not have the same type
16:59:42 <jfischoff> usually if you write a library and can't make a sum type for all the possible types your function work for
16:59:48 <albeit> monochrom: But if the type of the exisental typed value is unknown, isnt it impossible  for it ever have a known same type as something else?
16:59:54 <Ghoul_> oh Typeable is a compile time thing?
17:00:27 <jfischoff> the generate of the TypeRep is but not the cast
17:00:38 <monochrom> here is an example that works. "data X = forall a. Eq a => X a a". then you can create "v = X 'c' 'd'". then you can ask "case v of X c d -> c==d". this is legal.
17:01:26 <albeit> Ah, so its really only comparing to other values of that exisential type
17:01:46 <monochrom> here is an example that breaks. "data Y = forall a. Eq a => Y a". then you create "s = Y True", "t = Y False". then, as you have just found out, it is not known that s's inner type and t's inner type are the same type. cannot compare.
17:02:21 <Eduard_Munteanu> albeit: not necessarily in a context broader than (==)
17:02:35 <enthropy> Ghoul_: well if you have `data Dynamic = forall a. Typeable a => Dynamic a', in some sense the function  fromDynamic (Dynamic a) = cast a -- is doing things at runtime
17:03:09 <enthropy> since the typeable instance used is whichever one is carried along with the Dynamic constructor
17:03:23 <rwbarton> it does things at runtime to make sure it's safe to not do anything at runtime
17:03:27 <Ghoul_> so safe yet so .. not
17:04:00 <enthropy> anyways, such a thing is actually done properly in Data.Dynamic
17:04:17 <copumpkin> it always felt improper to me
17:04:27 <copumpkin> I thought the only reason it used Any was historical
17:04:37 <enthropy> oh, the comments are outdated?
17:04:44 <copumpkin> oh, maybe not?
17:04:51 * copumpkin looks again
17:05:15 <enthropy> "In GHC's new eval/apply execution model this type must not look like a data type.  If it did, GHC would use the constructor convention ... "
17:05:20 <enthropy> but who knows how new new is
17:05:53 <monochrom> time to book a lunch with SPJ and ask what's really going on :)
17:06:13 <copumpkin> I don't really get that comment
17:06:27 <copumpkin> if the existential didn't work, I'd be worried about GHC
17:06:32 * monochrom heards that it's the only way for OS writers to get some OS-relevant specs of Intel CPUs from Intel engineers
17:07:28 <enthropy> the comment is from 2006
17:07:32 <Eduard_Munteanu> Hm, does 'yaml' not support Generic parsers? I don't see a genericParseJSON and I don't think the one from aeson fits.
17:09:12 <rwbarton> I think the existential must work and there is some other reason (maybe not a very good one) for the way it is
17:09:58 <dmj> does it usually take hackage over a day to generate documentation?
17:10:14 <enthropy> dmj: it tends to take much less
17:10:15 <Eduard_Munteanu> dmj: it can
17:10:28 <enthropy> Eduard_Munteanu: recently?
17:10:58 <enthropy> or are you speaking for how hackage-1 used to be?
17:11:05 <Eduard_Munteanu> enthropy: I'm merely relaying what I've heard, I don't even have a Hackage account yet.
17:13:31 <dmj> ok, what are some reasons why documentation wouldn't get generated? Figured if running cabal haddock locally worked it should work remotely
17:14:47 <enthropy> look at the build log. It is at a secret url described by http://fuuzetsu.co.uk/blog/posts/2014-01-06-Fix-your-Hackage-documentation.html
17:15:05 <geekosaur> (1) it requires native libraries which aren't installed on the build machine (it must build the package to build docs) (2) it's for windows, the build machine is linux (3) ??? check logs
17:15:41 <monochrom> yikes
17:15:42 <dmj> enthropy: thanks for the link, i like good links
17:15:53 <monochrom> doesn't hackage have a way for people to upload docs?
17:16:09 <geekosaur> it does but there are some shortcomings
17:16:21 <geekosaur> like generating docs with links to other hackage packages requires extra work
17:16:25 <geekosaur> (locally)
17:16:57 <monochrom> I see, yeah
17:17:21 <dmj> so if package has no reports, that means it hasn't been built yet
17:17:24 <dmj> ?
17:17:59 <monochrom> to a large extent building docs has much lower requirement than compiling, no? I mean even when using haddock
17:18:10 <acowley> dmj: Consider manually uploading docs
17:19:11 <enthropy> haddock does things like adding inferred type signatures
17:20:30 <delrik_> > fmap (+1) [1,2,3]
17:20:31 <lambdabot>  [2,3,4]
17:20:43 <enthropy> monochrom: so I would say haddock is a higher requirement
17:21:41 <monochrom> well, I mean, it doesn't look at your c libs
17:34:08 <enthropy> maybe a concrete example is http://hackage.haskell.org/package/Rlang-QQ-0.2.1.0/reports/1/log which fails because haddock feels like running CPP (while ghc does not)
17:36:35 <Ghoul_> delrik:
17:36:37 <Ghoul_> > (+1) <$> [1..4]
17:36:38 <lambdabot>  [2,3,4,5]
17:36:49 <Ghoul_> > (+1) <$> (Map.fromList [1..5])
17:36:51 <lambdabot>  Not in scope: â€˜Map.fromListâ€™
17:36:51 <lambdabot>  Perhaps you meant one of these:
17:36:51 <lambdabot>    â€˜M.fromListâ€™ (imported from Data.Map),
17:36:51 <lambdabot>    â€˜IM.fromListâ€™ (imported from Data.IntMap),
17:36:51 <lambdabot>    â€˜S.fromListâ€™ (imported from Data.Set)
17:36:58 <Ghoul_> > (+1) <$> (M.fromList [1..5])
17:37:00 <lambdabot>  No instance for (GHC.Show.Show k0)
17:37:00 <lambdabot>    arising from a use of â€˜M5614070509376226266727.show_M5614070509376226266727â€™
17:37:00 <lambdabot>  The type variable â€˜k0â€™ is ambiguous
17:37:00 <lambdabot>  Note: there are several potential instances:
17:37:01 <lambdabot>    instance [safe] GHC.Show.Show
17:37:02 <Ghoul_> bugger.
17:37:17 <Ghoul_> I thought map had show instances?
17:39:38 <copumpkin> roconnor: you're needed in #coq
17:40:16 <Maxdamantus> > (+1) <$> (M.fromList $ zip [5,4..1] [1..5])
17:40:17 <lambdabot>  fromList [(1,6),(2,5),(3,4),(4,3),(5,2)]
17:40:45 <copumpkin> roconnor: troll is spamming and you're the only person on the access list
17:42:39 <acowley> Hmmm... https://translate.google.com/#auto/fr/spam
17:43:35 <monochrom> oh, that ramers who troubled us earlier
17:45:53 <monochrom> ok, where is Haskell Weekly News now? :)
17:46:01 <delrik> :t flip
17:46:03 <lambdabot> (a -> b -> c) -> b -> a -> c
17:46:33 <delrik> flip (:) $ [1,2,3] 4
17:46:37 <delrik> > flip (:) $ [1,2,3] 4
17:46:39 <lambdabot>  Couldn't match expected type â€˜a0 -> [a]â€™ with actual type â€˜[t0]â€™
17:46:46 <carter> sclv: what do you want?
17:46:52 <carter> sclv: ticket for which thing?
17:46:56 <delrik> :t flip (:)
17:46:57 <lambdabot> [a] -> a -> [a]
17:47:06 <carter> sclv: this?  http://www.haskell.org/pipermail/haskell-cafe/2014-June/114562.html
17:47:10 <zwer> > flip (:) [1,2,3] 4
17:47:12 <lambdabot>  [4,1,2,3]
17:47:34 <delrik> its crying about my $
17:47:36 <delrik> wow
17:47:37 <delrik> cool
17:47:44 <delrik> flip (:) [1,2,3] 5
17:47:50 <delrik> > flip (:) [1,2,3] 5
17:47:51 <geekosaur> yes, you told it to apply [1,2,3] to 4
17:47:51 <lambdabot>  [5,1,2,3]
17:47:53 <zwer> you were trying to use [1,2,3] as a function
17:48:07 <delrik> >_< fail
17:48:09 <delrik> thx =)
17:48:24 <delrik> :i $
17:48:30 <geekosaur> no :i here
17:48:36 <geekosaur> :t ($)
17:48:37 <lambdabot> (a -> b) -> a -> b
17:48:51 <delrik> thx
17:48:58 <geekosaur> $ behaves somewhat like low precedence parentheses, but it's a normal operator and not magic syntax
17:49:08 <delrik> ^
17:49:14 <delrik> that is my favorite thing about haskell.
17:49:28 <delrik> its disheartening how obvious things are.
17:49:31 <geekosaur> but that means people try to use it in oddball places
17:49:37 <delrik> which is why failing is so funny.
17:50:19 <kazagistar> yeah, it took me a while to stop trying to abuse $ so much
17:50:23 <delrik> yeah, i've gotta beef up my associativty / fixity rusles.
17:50:38 <cyclizine> what are some good examples of abusing ($)?
17:50:50 <Welkin> using $ instead of ()
17:50:57 <delrik> lulz
17:50:59 <gamegoblin> If I have a list of type `[a -> a]` and a value of type `a`, whatâ€™s the nicest way fold up the list? What I have so far is ` foldl (flip ($)) value list`
17:51:21 <gamegoblin> This might also be relevant to your $ abuse conversation ;)
17:51:26 <cyclizine> surely one of the main uses of $ is to stop haskell looking like lisp?
17:51:31 <dsturnbull> i dunno, i prefer $ almost exclusively.. it gets even better the more complicated your expression is, because then it starts working like | in a shell
17:51:32 <delrik> haha, why not zip?
17:51:34 <cyclizine> semi-serious
17:52:37 <kazagistar> cyclizine: (.) and small functions are often enough to make the parens minimal anyways
17:52:41 <delrik> :t foldl (flip ($))
17:52:42 <lambdabot> b -> [b -> b] -> b
17:52:48 <geekosaur> for xmonad we typically recommend $ for chaining layout modifiers and () as needed for parameters within a given modifier
17:52:55 <geekosaur> some consider this abuse of $
17:52:58 <gamegoblin> delrik: Thatâ€™s what Iâ€™ve got so far
17:53:06 <gamegoblin> delrik: Wondering if there was anything nicer
17:53:12 <geekosaur> but given what layouts look like in xmonad, this usually makes it easier to follow
17:53:28 <geekosaur> (hint: never look at the type of a layoutHook :p )
17:53:28 <delrik> gamegoblin: Yeah, I was literally just trying to see the type >_<
17:53:29 <monochrom> I know! re-define: ($) = (.) :)
17:53:32 <kazagistar> I meant abuse as in "things that dont compile" anyways
17:53:54 <cyclizine> fair enough
17:54:07 <cyclizine> I was under the impression that I chained $ fairly regularly
17:54:18 <cyclizine> but looking through my own code I am struggling to find examples
17:54:38 <gamegoblin> geekosaur: any opinion on my question? That is, any nice way to fold up a list of [a -> a] with a starting value? I currently have ` foldl (flip $) value list`
17:55:01 <gamegoblin> ($) not $
17:55:30 <kazagistar> cyclizine: often, I can just use (.) to chain, with a single ($) at the end, and sometimes it even eta-reduces :D
17:55:37 <geekosaur> looks reasonable to me
17:55:51 <gamegoblin> K just wondering if there was anything I wasnâ€™t thinking of
17:55:53 <delrik> :t foldl (flip ($)) 1 [(+1)]
17:55:54 <lambdabot> Num b => b
17:55:58 <delrik> =O
17:56:03 <delrik> foldl (flip ($)) 1 [(+1)]
17:56:08 <delrik> > foldl (flip ($)) 1 [(+1)]
17:56:09 <lambdabot>  2
17:56:14 <monochrom> > let { ($) = (Prelude..); (.) = (Prelude.$) } in take 1 $ map show $ map not . [True, False]
17:56:15 <lambdabot>  ["False"]
17:56:20 <gamegoblin> > foldl (flip ($)) 1337 [(+1), (+2)]
17:56:21 <lambdabot>  1340
17:56:30 <delrik> lol!
17:56:37 <delrik> nice
17:56:46 <delrik> > foldl (flip (id)) 1 [(+1)]
17:56:48 <lambdabot>  2
17:56:55 <delrik> id == $ ??
17:57:06 <gamegoblin> > foldl (flip id) 1337 [(+1), (+2)]
17:57:08 <monochrom> $ is a special case of id
17:57:08 <lambdabot>  1340
17:57:11 <gamegoblin> Huh so id works too
17:57:20 <gamegoblin> I think id is a bit cleaner
17:57:20 <benzrf> :t ($)
17:57:22 <lambdabot> (a -> b) -> a -> b
17:57:22 <cyclizine> *guess
17:57:24 <monochrom> or the other way round. I can't think.
17:57:24 <delrik> :t id
17:57:25 <lambdabot> a -> a
17:57:37 <cyclizine> okay, I'm getting very tired now
17:57:38 <cyclizine> bye
17:57:52 <kazagistar> :t appEndo . foldMap Endo
17:57:53 <lambdabot> Foldable t => t (a -> a) -> a -> a
17:57:58 <kazagistar> there ya go
17:58:10 <gamegoblin> Huh
17:58:12 <kazagistar> use those monoids and endofunctors
17:58:15 <delrik> nice
17:58:44 <Ghoul_> is that
17:58:51 <Ghoul_> fmap . unwrap or something
17:58:58 <delrik> :t uncurry ($)
17:58:59 <lambdabot> (b -> c, b) -> c
17:59:14 <delrik> :t uncurry (id)
17:59:14 <lambdabot> (b -> c, b) -> c
17:59:19 <delrik> =O
17:59:25 <delrik> mind === blown
17:59:33 <Welkin> this isn't javascript
17:59:39 <delrik> lol
17:59:41 <Ghoul_> what on earth
17:59:47 <sclv> carter: yep. its a regression in the typechecker speed :-)
18:00:11 <delrik> is was verifiying what monochrom said about id and ($)
18:00:20 <delrik> guess its true?
18:01:21 <Ghoul_> foldr (uncurry id) $ take  3 . zip (repeat (+1)) $ [1..]
18:01:23 <Ghoul_> woops
18:01:30 * Ghoul_ prays
18:01:32 <Ghoul_> > foldr (uncurry id) $ take 3 . zip (repeat (+1)) $ [1..]
18:01:33 <lambdabot>  No instance for (Data.Typeable.Internal.Typeable b0)
18:01:33 <lambdabot>    arising from a use of â€˜M73211762350023805547351.show_M73211762350023805547...
18:01:33 <lambdabot>  The type variable â€˜b0â€™ is ambiguous
18:01:33 <lambdabot>  Note: there are several potential instances:
18:01:33 <lambdabot>    instance Data.Typeable.Internal.Typeable Data.Dynamic.Dynamic
18:01:45 <Ghoul_> off to the prompt I go
18:01:49 <gamegoblin> Well it makes sense, since the type of $ is â€œ(a -> b) -> a -> bâ€ which can be rewritten as â€œ(a -> b) -> (a -> b)â€ which is just a specifialization of â€œa -> a"
18:02:16 <delrik> gamegoblin: there it goes again.
18:02:18 <gamegoblin> Iâ€™d never thought of it that way
18:02:31 <delrik> gamegoblin: haskells 'secrets' always hang out write in my face.
18:02:33 <gamegoblin> monochrome blowing minds up in here
18:03:11 <acowley> A lot of programming is a special case of id
18:03:14 <monochrom> I learned it from someone else, too
18:03:35 <gamegoblin> acowley: Sounds like an egg of philosophy in that
18:03:54 <delrik> lambda calculus is like that.
18:04:26 <Welkin> :t fmap . fmap . fmap . fmap
18:04:27 <lambdabot> (Functor f3, Functor f2, Functor f1, Functor f) => (a -> b) -> f (f1 (f2 (f3 a))) -> f (f1 (f2 (f3 b)))
18:04:32 <gamegoblin> LOL
18:04:36 <delrik> when I saw the proof that an if-then-else could be represented by simply two combinators I had an ephiphany which coalesced into a brain collapse.
18:04:48 <carter> sclv: the linked email doesn
18:04:56 <Ghoul_> delrik: SHOW
18:05:01 <carter> doesnt give me enough info to reconstruct the problem program
18:05:25 <gamegoblin> tbh I kind of wish Prelude had defined fmap2, fmap3, fmap4, etc kind of like zip or liftM
18:05:30 <carter> sclv: derp nvm
18:05:39 <Welkin> gamegoblin, you can define it
18:05:40 <gamegoblin> The number of times I have needed fmap2 definitely warrants it :P
18:05:41 <Zekka> gamegoblin: Sounds like you want Applicative
18:05:47 <Ghoul_> defining combinators feels so plebian
18:05:48 <Zekka> er, wait, assuming I know what you mean by fmap2
18:05:49 <carter> yup, applicative
18:05:55 <gamegoblin> Zekka : fmap . fmap
18:05:55 <Ghoul_> they dont fit in any of your modules nicely
18:05:58 <sclv> its a good test case to tickle the typechecker. i guess thereâ€™ll always be degenerate cases
18:06:00 <Zekka> Oh, wait, I see what you mean
18:06:02 <Ghoul_> hi Zekka
18:06:04 <Zekka> Never mind, that's not Applicative
18:06:10 <gamegoblin> fmap3 would be fmap . fmap . fmap
18:06:13 <gamegoblin> etc
18:06:18 <gamegoblin> Iâ€™ve never needed that. Just fmap2
18:06:20 <Zekka> Afternoon Ghoul.
18:06:21 <delrik> http://lpaste.net/105496
18:07:00 <delrik> I worked one out on the board at the office and felt hapiness for the first time.
18:07:39 <Zekka> If you're wondering, if you didn't already know, Applicative is necessary for (a -> b -> c) -> (f a -> f b -> f c)
18:07:57 <delrik> if-then-else just ends up being id and substitution =)
18:08:45 <Zekka> (which is where you get cool stuff like Aeson's API, of course)
18:09:22 <kazagistar> delrik: I am sorry for your tragic life until now
18:09:43 <rwbarton> fmap . fmap = fmapÂ²
18:09:45 <Ghoul_> I don't think I get the proof
18:10:05 <Ghoul_> that would be cool
18:10:13 <rwbarton> @let fmapÂ² = fmap . fmap
18:10:13 <lambdabot>  Parse failed: Illegal character ''\178''
18:10:16 <Ghoul_> a .. operator that uses Nat to duplicate the function that many times
18:10:18 <rwbarton> oh lambdabot
18:10:30 <Ghoul_> fmap .. 200 $
18:11:22 <delrik> kazagistar: don't be Haskell has filled the void
18:11:42 <acowley> You had a Void at runtime?
18:11:47 <delrik> Ghoul_: Work one out, it'll be clear as day.
18:12:01 <Ghoul_> I don't understand the notation
18:12:02 * hackagebot bytable 0.0.0.6 - data from/to ByteString  http://hackage.haskell.org/package/bytable-0.0.0.6 (YoshikuniJujo)
18:12:06 <Ghoul_> I haven't taken lambda calculus before
18:12:26 <Ghoul_> what does p q FALSE mean?
18:12:28 <Ghoul_> p(q, FALSE) ?
18:12:30 <kazagistar> Ghoul_: before the .  is input, after is output
18:12:57 <delrik> TRUE := Î» x y. x
18:13:02 <delrik> that basically says
18:13:07 <delrik> >id
18:13:10 <delrik> :t id
18:13:11 <lambdabot> a -> a
18:13:14 <kazagistar> not quite
18:13:16 <acowley> :t const
18:13:16 <lambdabot> a -> b -> a
18:13:22 <kazagistar> thats the one
18:13:30 <pranz> delrik: your if-then-else is id
18:13:31 <Ghoul_> :t snd . curry (id . id)
18:13:32 <delrik> ^
18:13:32 <lambdabot>     Couldn't match type â€˜b0 -> (a, b0)â€™ with â€˜(a0, c)â€™
18:13:32 <lambdabot>     Expected type: a -> (a0, c)
18:13:32 <lambdabot>       Actual type: a -> b0 -> (a, b0)
18:13:34 <delrik> yeah
18:13:35 <delrik> my bad
18:13:39 <delrik> its consts
18:13:44 <acowley> :t flip const
18:13:45 <lambdabot> b -> c -> c
18:13:52 <Ghoul_> can you do const with id
18:13:55 <Ghoul_> using curry
18:14:00 <Ghoul_> and snd
18:14:07 <benzrf> 09:11 < Ghoul_> can you do const with id
18:14:10 <benzrf> what does this mean
18:14:13 <kazagistar> @let TRUE x y = x
18:14:14 <benzrf> ?
18:14:15 <lambdabot>  .L.hs:173:1: Not in scope: data constructor â€˜TRUEâ€™
18:14:15 <lambdabot>  
18:14:15 <lambdabot>  .L.hs:173:12:
18:14:15 <lambdabot>      Ambiguous occurrence â€˜xâ€™
18:14:15 <lambdabot>      It could refer to either â€˜L.xâ€™, defined at .L.hs:173:6
18:14:19 <benzrf> :t id id id
18:14:20 <lambdabot> a -> a
18:14:23 <benzrf> :-D
18:14:26 <benzrf> > fix id 3
18:14:30 <lambdabot>  mueval-core: Time limit exceeded
18:14:31 <delrik> > let false = (\x -> \y -> y)
18:14:32 <benzrf> o=
18:14:32 <lambdabot>  not an expression: â€˜let false = (\x -> \y -> y)â€™
18:14:33 <Ghoul_> :t id . id
18:14:34 <lambdabot> c -> c
18:14:36 <pranz> :t curry
18:14:37 <lambdabot> ((a, b) -> c) -> a -> b -> c
18:14:44 <Ghoul_> well, sure, it's hard to make anything with id alone
18:14:44 <Ghoul_> :|
18:15:05 <benzrf> Ghoul_: yeah, you also need the K combinator
18:15:07 <benzrf> ;)
18:15:19 <kazagistar> > let TRUE = (\x y -> x); let FALSE = (\x y -> y);
18:15:20 <lambdabot>  <hint>:1:49:
18:15:20 <lambdabot>      parse error (possibly incorrect indentation or mismatched brackets)
18:15:29 <benzrf> (and S)
18:15:32 <benzrf> (and not id)
18:15:36 <kazagistar> meh whatever I am bad at haskell I guess :D
18:15:39 <delrik> kazagistar: you need the -> op
18:15:43 <benzrf> kazagistar: uppercase values m8
18:15:51 <kazagistar> aaaaah
18:15:55 <pranz> :t \x y -> snd (curry id x y)
18:15:56 <lambdabot> a -> b -> b
18:15:57 <delrik> > let false = (\x -> \y -> y) 5 6
18:15:58 <benzrf> kazagistar: also, you dont have any ins
18:15:59 <lambdabot>  not an expression: â€˜let false = (\x -> \y -> y) 5 6â€™
18:16:07 <delrik> > (\x -> \y -> y) 5 6
18:16:09 <lambdabot>  can't find file: L.hs
18:16:11 <pranz> Ghoul_:
18:16:17 <benzrf> lambdabot: shut it up you
18:16:21 <benzrf> > (\x -> \y -> y) 5 6
18:16:23 <lambdabot>  6
18:16:23 <delrik> lol!
18:16:39 <delrik> im confused
18:16:47 <delrik> hows that work but mine doesnt?
18:16:53 <Ghoul_> :t snd . curry id
18:16:54 <lambdabot>     Couldn't match type â€˜b0 -> (a, b0)â€™ with â€˜(a0, c)â€™
18:16:54 <lambdabot>     Expected type: a -> (a0, c)
18:16:54 <lambdabot>       Actual type: a -> b0 -> (a, b0)
18:17:00 <Ghoul_> Oh wait
18:17:17 <Ghoul_> :t (.) (snd . curry id)
18:17:18 <lambdabot>     Couldn't match type â€˜b0 -> (b, b0)â€™ with â€˜(a0, c)â€™
18:17:18 <lambdabot>     Expected type: b -> (a0, c)
18:17:18 <lambdabot>       Actual type: b -> b0 -> (b, b0)
18:17:20 <delrik> anyways Ghoul_: I spent three weeks learning lambda calculus before I touched any haskell, I've been going to bed late ever sicne =)
18:17:22 <Ghoul_> ffff ok nevermind
18:17:22 <monochrom> delrik: it wants an expression, not a definition
18:17:23 <pranz> :t (fmap.fmap) snd (curry id)
18:17:24 <lambdabot> a -> b -> b
18:17:29 <pranz> Ghoul_: ^
18:17:32 <Ghoul_> delrik: the proof makes sense now
18:17:35 <Ghoul_> I can read it, thanks :)
18:17:45 <Ghoul_> I didn't realize TRUE and FALSE were functions
18:17:50 <delrik> WAHHT
18:17:52 <delrik> lol
18:17:53 <delrik> nice
18:18:02 <delrik> thx monochrom
18:18:13 <Ghoul_> oh lawd pranz
18:19:03 <Zekka> Ghoul_: true = \x y -> x; false = \x y -> y; not = \f x y -> f y x
18:19:05 <Welkin> what is a good resource for learning lambda calculus?
18:19:06 <Zekka> Does that help?
18:19:25 <kazagistar> Ghoul_: dont you know? everything in lambda calculus is a function... JUST LIKE HASKELL muhahahahaha
18:19:34 * kazagistar ducks
18:19:35 <delrik> Welkin: I found a couple research papers, thats what I used.
18:19:57 <augur> whoa whoa whoa
18:20:04 <augur> are we talking church encodings?
18:20:20 <Zekka> Since this is #haskell after all, have a fun discovery of Haskell Curry: http://en.wikipedia.org/wiki/B,C,K,W_system
18:20:34 <delrik> yeah
18:20:42 <Welkin> wikipedia is the worst learning resource for math...
18:20:43 <augur> church encodings are fun
18:20:49 <augur> better to start with scott encodings tho
18:20:52 <Welkin> it's indecipherable
18:20:55 <Ghoul_> Zekka: yeah I just skipped past the start and read the interesting part which is never a good idea for proofs
18:20:57 <delrik> if you think the if-the-else is cool, encode some numbers as functions and then run succ
18:21:00 <Zekka> In short -- you can express any function in the lambda calculus using those four functions
18:21:10 <Zekka> delrik: And then write pred!
18:21:18 <augur> delrik: the encodings are quite simple once you know the pattern
18:21:22 <Zekka> I don't really recommend wikiedia for actually learning math
18:21:29 <delrik> lol same here
18:21:37 <Zekka> the bckw system is just really easy to understand/follow based on the definitions there alone
18:21:38 <delrik> wikipedia is so useless
18:21:44 <kazagistar> Welkin: wikipedia gets a bit better if you learn just a little of the foundation in an area, as a kind of lookup resource
18:21:56 <delrik> lol!
18:22:03 * hackagebot bytable 0.0.0.7 - data from/to ByteString  http://hackage.haskell.org/package/bytable-0.0.0.7 (YoshikuniJujo)
18:22:03 <Zekka> This article is pretty good if you ask me: http://www.jetcafe.org/~jim/lambda.html
18:22:04 <Ghoul_> physics formulas off wikipedia are mostly a waste of time
18:22:06 <delrik> yeah walking in there blind is asking to get wrecked.
18:22:08 <hpc> wikipedia is great for going from "i know one sorting algorithm" to "i know 5 sorting algorithms" and similar
18:22:13 <lfairy> wikipedia is a reference, not a tutorial
18:22:28 <delrik> touchÃ©
18:22:30 <lfairy> what kazagistar and hpc said
18:22:49 <Zekka> Yeah -- the articcle I linked is really self-explanatory if you already know a little bit about the lambda calculus
18:22:56 <Zekka> at which point it just becomes "oh, that's a cool idea"
18:23:04 <delrik> Zekka: yoy have an example of pred?
18:23:05 <Welkin> what about someone who knows zero lambda calculus?
18:23:06 <OffTheRails> so what would you suggest prior to wikipedia? books?
18:23:11 <Zekka> delrik: I odn't have an implementation of pred offhand
18:23:18 <delrik> its essentailly a fold right?
18:23:18 <Zekka> one of my friends drove himself nuts trying
18:23:22 <kazagistar> "I forgot what all the properties of a Near-Ring are, but I have an intuitive idea of what rings are, lets look it up on wikipedia!"
18:23:46 <Zekka> delrik: Well, a church number is basically a partially-applied fold IIRC
18:23:47 <Ghoul_> lambda calculus is pretty mindblowing.
18:23:51 <lfairy> OffTheRails: I find doing some coding helps build up intuition
18:23:51 <Zekka> so it's like implementing tail with foldr
18:24:01 <Ghoul_> how do you implement MAYBE ?
18:24:04 <delrik> nice
18:24:10 <Ghoul_> you can't
18:24:32 <delrik> lambda calculus is turing complete.
18:24:41 <kazagistar> homework: now you just have to implement a turing machine simulator in lambda calculus
18:24:47 <Zekka> Ghoul_: You can't?
18:24:57 <Zekka> Is there something I haven't considered? It doesn't seem like it would be that hard to me
18:25:03 <Ghoul_> not the way it was intended, surely
18:25:20 <Zekka> here's a quickc encoding, pair of (False, False) for Nothing, (True, Value) for Just Value
18:25:35 <Ghoul_> Zekka: not that maybe
18:25:36 <augur> Zekka: thats awful
18:25:54 <Zekka> augur: It is, there are probably much better encodings
18:25:55 <Ghoul_> bool = TRUE | FALSE | MAYBE
18:26:05 <augur> Zekka: just use the church encoding!
18:26:06 <silasm> Ghoul_: it's easy enough to church encode... Maybe a = Sum a ()
18:26:16 <augur> Zekka:    ChurchMaybe a = forall r. r -> (a -> r) -> r
18:26:33 <kazagistar> MAYBE being "randomly true or false"? yeah, that requires an extension, turing machines dont do randomness properly
18:26:34 <augur> Zekka:    nothing = \n j -> n
18:26:42 <augur> Zekka: just x = \n j -> j x
18:26:47 <path[l]> @pl (\xs -> (length xs, head xs))
18:26:47 <lambdabot> liftM2 (,) length head
18:26:53 <Ghoul_> silasm: again, I wasn't actually looking for Maybe
18:26:53 <Zekka> augur: That's a more elegant encoding
18:27:01 <Ghoul_> I was looking for MAYBE as shown in delriks example
18:27:02 <kazagistar> and apparently they dont do some kinds of randomness properly at all, or so the actor people tell me
18:27:03 * hackagebot bytable 0.0.0.8 - data from/to ByteString  http://hackage.haskell.org/package/bytable-0.0.0.8 (YoshikuniJujo)
18:27:16 <Zekka> I was trying to show off a way to generally represent any ADT
18:27:17 <augur> Zekka: the beauty of church encodings is that you can derive them mechanically from the ADT's definition
18:27:19 <delrik> kazagistar: I never looked at a Maybe as being random
18:27:24 <delrik> kazagistar: why do you say that?
18:27:28 <Zekka> which would be (ConstructorNumber, List)
18:27:28 <augur> Zekka: in what?
18:27:50 <Ghoul_> delrik: in your proof MAYBE implies it could be either TRUE or FALSE because it's not defined there
18:27:58 <Zekka> augur: As a church-encoded list?
18:28:16 <kazagistar> delrik: I think I was just going on a different definiton of MAYBE, not the haskell one
18:28:18 <augur> Zekka: i cant see a reason to do that at all
18:28:23 <Lutin`> aw man
18:28:30 <augur> Zekka: if you're going to use church encodings, you might as well use the correct one
18:28:35 <Lutin`> 512 MB of RAM isn't enough to run `cabal update`
18:28:38 <Zekka> augur: 'Correct'?
18:28:46 <acowley> Zekka: augur is following the method to encode any ADT
18:28:52 <augur> Zekka: yes :)
18:29:00 <Zekka> I don't understand what makes one correct and not another, can you clarify?
18:29:08 <augur> Zekka: there is a correct way of saying any ADT and turning it into a church encoding
18:29:09 <Zekka> (Sorry if I seem slow to follow, I'm being distracted by my other screen at the moment)
18:29:14 <delrik> kazagistar: oh okay
18:29:24 <augur> or at least a _canonical_ way that captures _precisely_ and _only_ the ADT in question
18:29:25 <Zekka> Would you mind if I tabbed back over in a few minutes to read your thoughts?
18:29:35 <augur> Zekka: sure
18:29:42 <Zekka> I have a feeling in this case you know more than I do but I'm being distracted pretty heavily
18:29:52 <augur> Zekka: its quite beautiful once you see it
18:30:00 <Ghoul_> augur: can yo show the lambda calculus
18:30:03 <albeit> @pl (\a v -> a `mappend` (f v))
18:30:03 <lambdabot> (. f) . mappend
18:30:05 <Ghoul_> I want to know what it would look like :)
18:30:15 <augur> Ghoul_: as a scot encoding?
18:30:20 <Zekka> I had a general way of doing it but I have a feeling it's much worse than yours
18:30:24 <Ghoul_> I don't know what that means, but sure
18:30:25 <kazagistar> is it the Near Semiring thing? :P
18:30:30 <dsturnbull> does (cabal update; cabale install cabal-install) ever terminate? it seems to say "Note: there is a new version of cabal-install available." forever
18:30:38 <augur> Ghoul_: what do you mean can i show the lambda calculus
18:30:45 <Ghoul_> dsturnbull: make sure cabal bin is on path
18:30:57 <Ghoul_> you keep updating the old cabal to a new cabal but keep using the old one
18:31:02 <Zekka> augur: Did you already describe your general way of doing it? If so I'll scroll up
18:31:02 <delrik> I feel like there is some overlap between ADT's and single argument type constructors.  Is there any kind of definitive difference between the two? use cases where one is obviously more idomatic than the other?
18:31:09 <augur> Zekka: no
18:31:21 <Ghoul_> show haskells Maybe as lambda calculus
18:31:30 <augur> Ghoul_: i already did!
18:31:44 <Zekka> You came up with a more elegant definition of Maybe -- how does it look in general?
18:32:01 <Zekka> Like, for a simple example, how would I encode data Maybe2 a = Just2 a a | Just a | Nothing ?
18:32:21 <Ghoul_> ah found it
18:32:22 <path[l]> could someone explain to me how to work past this error Could not deduce (Monad ((->) [a])) arising from a use of `liftM2â€™. Iâ€™m using liftM2 while mapping over a list
18:32:26 <Ghoul_> 11:24 AM <augur> Zekka: nothing = \n j -> n
18:32:26 <Ghoul_> 11:24 AM <augur> Zekka: just x = \n j -> j x
18:32:42 <path[l]> @pl map (liftM2 (,) length head)
18:32:42 <lambdabot> map (liftM2 (,) length head)
18:32:47 <augur> Zekka:    ChurchMaybe2 a = forall r. (a -> a -> r) -> (a -> r) -> r -> r
18:32:47 <Zekka> Ghoul_: This is a different data type, isn't it?
18:33:03 <augur> Zekka:    just2 x y = \j2 j n -> n2 x y
18:33:14 <augur> j2** not n2 sorry
18:33:14 <Ghoul_> I presume then that j = id in all cases
18:33:18 <monochrom> @type  map (liftM2 (,) length head)
18:33:19 <augur> Zekka:    just x = \j2 j n -> j x
18:33:19 <lambdabot> [[a2]] -> [(Int, a2)]
18:33:25 <augur> Zekka:    nothing = \j2 j n -> n
18:33:32 <augur> Zekka: here, consider the following
18:33:35 <path[l]> I assume I have to tell it that the monad in question is a list?
18:33:36 <augur> (gimme a moment to type)
18:33:45 <Zekka> I think I follow
18:33:55 <monochrom> I am not sure what map (liftM2 (,) length head) is supposed to mean, even if it's legal
18:33:58 <Zekka> So you just take the arguments of the constructor and then a function for what to do to match each constructor?
18:34:20 <Zekka> If I understand then that's a much better encoding than mine.
18:34:21 <delrik> monochrome: its getting the length and first element and creating a tuple?
18:34:27 <benzrf> monochrom: duuuh!
18:34:33 <path[l]> yeah thatsâ€™ what itâ€™s supposed to do
18:34:52 <benzrf> > map (liftM2 (,) length head) ["abc", "defg", "h", "ij"]
18:34:53 <lambdabot>  [(3,'a'),(4,'d'),(1,'h'),(2,'i')]
18:35:12 <monochrom> alright, then no type error, ticket closed?
18:35:16 <Ghoul_> > map (liftA2 (,) length head) ["abc", "defg", "h", "ij"]
18:35:17 <lambdabot>  [(3,'a'),(4,'d'),(1,'h'),(2,'i')]
18:35:30 <Ghoul_> using liftA is actually an optimization in this case :)
18:35:33 <path[l]> monochrom: when I run it on ghc, I get an error -> Could not deduce (Monad ((->) [a])) arising from a use of `liftM2'
18:35:37 <benzrf> Ghoul_: indeed!
18:35:49 <path[l]> Ghoul_: whats the difference and whatâ€™s happening here
18:35:59 <Lutin`> path[l]: What's your exact code
18:35:59 <Ghoul_> liftA doesn't thread an order through it
18:36:02 <path[l]> liftA2 and liftM2 I mean
18:36:06 <Ghoul_> it can be done in parallel automatically
18:36:10 <path[l]> ah
18:36:18 <path[l]> Lutin`: itâ€™s a practice problem on 99 haskell problems
18:36:25 <augur> Zekka: http://lpaste.net/105497
18:36:29 <Zekka> augur: Is this a correct definition of Either? left x = \l r -> l x; right x = \l r -> r x?
18:36:34 <Zekka> oh, reading
18:36:36 <rwbarton> it should make real difference, either way it can be inlined to \r -> (length r, head r)
18:36:37 <path[l]> Lutin`: it takes a list of lists and produces a run length encoding
18:36:42 <augur> Zekka: bingo :)
18:36:43 <rwbarton> *no real difference
18:36:45 <monochrom> I entered it in ghci and got no error. how can I reproduce the error?
18:37:01 <path[l]> monochrom: huh thatâ€™s odd. let me paste the source on pastie
18:37:05 <Ghoul_> rwbarton: actually, wouldn't it be more like
18:37:17 <Ghoul_> I can't even draw it
18:37:23 <Ghoul_> but there would be a state thread throug hthere wouldn't there
18:37:35 <augur> Zekka: the list exampleshould cue you into something
18:38:06 <Zekka> augur: It seems pretty straightforward
18:38:06 <rwbarton> Ghoul_: I don't understand
18:38:10 <augur> Zekka: it is
18:38:11 <delrik> Any idea why I can't do this? :t ((->) r)
18:38:12 <Zekka> each data structure is a pattern-matcher for itself
18:38:17 <Ghoul_> @src liftM2
18:38:17 <lambdabot> liftM2 f m1 m2 = do { x1 <- m1; x2 <- m2; return (f x1 x2) }
18:38:20 <augur> Zekka: not a pattern matcher
18:38:22 <augur> Zekka: a fold!
18:38:23 <path[l]> monochrom: here we go http://lpaste.net/105498
18:38:25 <Zekka> r is the type of the result of the pattern result
18:38:27 <Lutin`> delrik: Because that's a type
18:38:29 <rwbarton> liftM2 (,) length head = \r -> (length r, head r), and I have faith in GHC's inliner
18:38:32 <benzrf> delrik: that's not a value
18:38:40 <benzrf> :k ((->) r)
18:38:41 <lambdabot> Not in scope: type variable â€˜râ€™
18:38:46 <benzrf> :k forall r. ((->) r)
18:38:47 <augur> Zekka: ScottList a = forall r. r -> (a -> r -> r) -> r
18:38:47 <lambdabot> * -> *
18:38:48 <augur> Zekka:
18:38:48 <delrik> so i could do an :i on it?
18:38:49 <augur> :t foldr
18:38:49 <Zekka> augur: Really? It looks to me like we're just matching one layer with the list
18:38:50 <lambdabot> (a -> b -> b) -> b -> [a] -> b
18:39:05 <delrik> dude
18:39:06 <augur> Zekka: we're actually doing a recursion
18:39:10 <Zekka> we don't fold it over the whole list, instead just matching one occurrence of the constructor
18:39:14 <Ghoul_> @src liftA2
18:39:14 <lambdabot> liftA2 f a b = f <$> a <*> b
18:39:15 <delrik> I've been sitting here getting wrecked on that forever.
18:39:21 <augur> Zekka: no, with church encodings we fold
18:39:32 <Ghoul_> @src (<*>)
18:39:33 <lambdabot> Source not found. There are some things that I just don't know.
18:39:33 <augur> Zekka: with scott encodings we case
18:39:43 <delrik> LYAH was dangling it in my face, and I'm completely incapable of trying it myself.
18:39:44 <augur> sorry, i shouldve written ChurchNat etc
18:39:45 <augur> :(
18:39:54 <Lutin`> Ghoul_: That might be the case in another monad but consider the Applicative and Monad instances of []
18:39:55 <Welkin> @src liftA
18:39:55 <lambdabot> liftA f a = pure f <*> a
18:40:01 <monochrom> path[l]: I loaded that file into ghci with no error either.
18:40:02 <Welkin> @src liftA7
18:40:02 <lambdabot> Source not found.
18:40:02 <Zekka> Oh, you're right, I think we're talking about different types
18:40:06 <Welkin> @src liftA4
18:40:06 <lambdabot> Source not found. Sorry.
18:40:06 <augur> edited
18:40:08 <Welkin> @src liftA3
18:40:09 <lambdabot> Source not found. Just try something else.
18:40:13 <augur> Zekka: scott encodings are case
18:40:14 <monochrom> it's ghc 7.6.3 I'm using
18:40:19 <path[l]> monochrom: oh how bizarre â€¦ do you think itâ€™s a version thing?
18:40:21 <path[l]> let me check mine
18:40:23 <benzrf> just adding more (<*>)
18:40:25 <Welkin> :t liftA2 . liftA2
18:40:26 <lambdabot> (Applicative f1, Applicative f) => (a -> b -> c) -> f (f1 a) -> f (f1 b) -> f (f1 c)
18:40:26 <augur> Zekka:    ScottList a = forall r. r -> (a -> ScottList a -> r) -> r
18:40:38 <augur> ChurchList a = forall r. r -> (a -> r -> r) -> r
18:40:42 <Zekka> I see the difference
18:40:55 <Zekka> We're looking at the result of a previous fold with the binary function here
18:40:58 <benzrf> augur: u left off a 'type' in the front
18:40:58 <path[l]> 7.4.2 â€¦ ah this is another problem. I recently installed the latest ghc and even ran uninstall ghc, but it still runs the older version
18:40:59 <Zekka> we're not looking at the original structure
18:41:04 <augur> benzrf: hush you
18:41:05 <augur> :)
18:41:07 <benzrf> =3
18:41:30 <path[l]> monochrom: works on 7.6.3 as you said
18:41:36 <augur> Zekka: the beautiful thing is that, as long as you're using a proper ADT (not some weirdo ADT), you can always derive a Scott and Church encoding automatically
18:41:43 <path[l]> ugh thanks, dunno how to uninstall the older version :/
18:41:45 <augur> Zekka: there's actually a superior encoding that uses paramorphisms instead
18:41:58 <augur> Zekka:    ParaList a = forall r. r -> (a -> ParaList a -> r -> r) -> r
18:41:58 <Lutin`> path[l]: how'd you install the first and second versions?
18:42:09 <Lutin`> path[l]: You can do `which ghc` to figure out where the first one is
18:42:27 <monochrom> for 7.4.2 you may be able to work around by importing a module that also comes with GHC
18:42:30 <Zekka> augur: Can you help me with the intuition?
18:42:31 <path[l]> Lutin`: I think version 7.4.2 was already installed with my mac. The new version is actually in /usr/bin. I guess maybe I can rearrange the path variable
18:42:42 <Lutin`> already installed? :O
18:42:43 <Zekka> It looks like we're taking both the structure and the result of the fold in the binary function here
18:42:47 <augur> Zekka: well, scott encodings are case, right
18:42:49 <rwbarton> http://lpaste.net/105500, check out the core for pA :)
18:42:51 <Zekka> Right.
18:42:52 <augur> Zekka: yes precisely
18:42:56 <lfairy> no, don't use which! which lies
18:42:58 <Zekka> (It might help if I knew what a paramorphism was)
18:42:59 <path[l]> Lutin`: I think it comes bundled
18:43:00 <augur> they take the structure AND the recursing result
18:43:04 <Lutin`> lfairy: Does it?
18:43:16 <augur> Zekka: they're superior than either along because you can build case and fold cheaply from it
18:43:18 <Zekka> Oh, wait, did I actually get the whole idea there? I figured there was deeper and subtler magic here
18:43:25 <Lutin`> lfairy: Never had it lie to me
18:43:25 <codygman> > product []
18:43:27 <lambdabot>  1
18:43:32 <augur> Zekka: whereas if you have Churhch only, case is costly
18:43:34 <Zekka> Right, so that's just an encoding where you get case if you want it and fold if you want it
18:43:41 <codygman> Should 'product [] == 1' like that?
18:43:47 <augur> Zekka: and if you use Scott only, you need a generic fix operator which is naughty
18:44:02 <augur> Zekka: paramorphisms also generalize to dependent types trivially
18:44:32 <Zekka> augur: How do they do that?
18:44:35 <lfairy> Lutin`: bash caches the search path, but which doesn't
18:44:40 <benzrf> no church in the widl
18:44:44 <benzrf> *wild
18:44:49 <Lutin`> lfairy: But which is a bash built-in
18:45:07 <rwbarton> no, it's not
18:45:13 <Lutin`> oh hey so it's not
18:45:17 <rwbarton> type is, though
18:45:19 <Lutin`> It's just built-in in zsh
18:45:22 <augur> Zekka:    DependentScottList a = (f :: a -> *) -> f [] -> ((x :: a) -> (xs :: DependentScottList a) -> f xs -> f (cons x xs)) -> (xs :: DependentScottList a) -> f xs
18:45:35 <Zekka> ~$ which which
18:45:42 <augur> Zekka: er, well, thats not quite true
18:45:46 <Lutin`> haven't used bash as my shell in over a year so I forgot :P
18:46:02 <augur> rather, that type is the induction principle for a list
18:46:11 <Lutin`> `which which` returns `which: shell built-in command` for me
18:46:23 <Lutin`> but yeah if I run in bash it's a separate program
18:46:27 <Lutin`> sorry for misinformation
18:46:30 <Zekka> augur: Hold up, chewing on that definition a bit
18:46:35 <augur> Zekka: nah dont chew it
18:46:47 <augur> Zekka: ignore it, i was speaking loosely and slightly drunkly :)
18:47:38 <augur> Zekka: in dependent haskell tho you would have a function    ListInduction = forall a. (f :: a -> *) -> f [] -> ((x :: a) -> (xs :: [a]) -> f xs -> f (x:xs)) -> (xs :: [a]) -> f xs
18:47:43 <augur> grr
18:47:45 <augur> not =, ::
18:47:53 <augur> and it would be defined like the paramorphism
18:47:57 <johnw> acowley: ping
18:48:09 <copumpkin> roconnor: please
18:48:23 <augur> ListInduction f fnil fcons [] = fnil   ;   ListInduction f fnil fcons (x:xs) = fcons x xs (ListInduction f fnil fcons xs)
18:49:03 <path[l]> oh it was installed via homebrew, ok
18:49:06 <kazagistar> codygman: why wouldnt it?
18:49:11 <kazagistar> :t product
18:49:12 <lambdabot> Num a => [a] -> a
18:49:27 <kazagistar> hmm, that wasn't helpful, um
18:50:03 <Zekka> augur: I'm still having trouble understanding i, though: for a type-level function that turns any a into a type -- it looks roughly like a definition of cons
18:50:10 <Zekka> er, though: it looks*
18:50:24 <Zekka> I originally was writing an explanation of the type but meant to erase that and say it looked roughly like a definition of cons
18:50:25 <augur> Zekka: its crazy is what it is :)
18:50:31 <augur> Zekka: dont worry tho
18:50:37 <Zekka> well, type-level cons
18:50:45 <augur> Zekka: nah, not type level cons
18:50:46 <augur> its dependent!
18:51:01 <Zekka> augur: How much Idris will it take for such a definition to make sense to me
18:51:02 <Zekka> ?
18:51:04 <augur> dont worry tho, its a whacky thing you do in futuristic languages like idris :)
18:51:11 <Zekka> Oh, same thought.
18:51:29 <Zekka> I've had idris recommended to me but I think I had trouble getting it to build last time I tried taking it out
18:52:36 <kazagistar> codygman: multiplication is a monoid, and 1 is the identity of multiplication. If you look at the Monoid datatype, you will see similar behavoirs
18:53:28 <kazagistar> :t appEndo $ mconcat []
18:53:29 <lambdabot> a -> a
18:54:02 <kazagistar> :t mconcat (tail [[]])
18:54:03 <lambdabot> [t]
18:55:32 <Zekka> :t appEndo
18:55:33 <lambdabot> Endo a -> a -> a
18:55:48 <kazagistar> @src Endo
18:55:48 <lambdabot> Source not found. Whoa.
18:55:53 <kazagistar> ugh
18:56:15 <Zekka> What's the intuition for Endo?
18:56:30 <kazagistar> its a wrapper around (a -> a)
18:56:31 <johnw> it composes functions of type a -> a
18:56:32 <kazagistar> thats all
18:56:35 <Zekka> oh, I shouldn't start a conversation now
18:56:40 <Zekka> Oh, that's not so complicated
18:56:43 <kazagistar> nope
18:56:49 <kazagistar> but the neat thing is that it is a monoid
18:57:02 <Zekka> Oh, right, under (.) and id?
18:57:09 <kazagistar> Zekka: yep
18:58:06 <kazagistar> Zekka: foldr f z t = appEndo (foldMap (Endo . f) t) z
18:59:22 <Zekka> kazagistar: Oh, I see. So the appEndo/foldMap expression there turns all of the functions that operate on the list into one combined function that operates on the starting element?
18:59:41 <kazagistar> Zekka: yep, thats actually from the Foldable standard library
18:59:56 <Zekka> Right, that's how foldr is defined on Foldables?
19:00:31 <kazagistar> Zekka: well, its the default definition at least, mostly you override it
19:01:43 <kazagistar> Zekka: but it means all you need is foldMap for your data structure, and it takes care of the rest
19:02:02 <Zekka> :t foldMap
19:02:03 <lambdabot> (Monoid m, Foldable t) => (a -> m) -> t a -> m
19:02:39 <Zekka> Right, so it maps a function over a Foldable that turns the elements into a monoid and then mconcats them together using the Foldable's structure
19:03:10 <kazagistar> Zekka: and since it is done lazily, it is not as insane as it sounds :P
19:03:19 <Zekka> It doesn't really sound that bad
19:04:04 <kazagistar> Zekka: for bonus points, there is the dual version: foldl f z t = appEndo (getDual (foldMap (Dual . Endo . flip f) t)) z
19:04:34 <Zekka> kazagistar: Dual is the same as Endo except it composes in the opposite direction, correct?
19:04:56 <Zekka> er, actually, it's not the same
19:04:57 <Zekka> :t Dual
19:04:58 <lambdabot> a -> Dual a
19:05:16 <Zekka> Dual turns a monoid into a monoid that flips mappend?
19:05:27 <johnw> yep
19:06:24 <kazagistar> Dual x `mappend` Dual y = Dual (y `mappend` x)
19:06:43 <kazagistar> straight from Data.Monoid
19:12:26 <kazagistar> and I was kinda irked by newtype wrappers, until I realized that it basically realized that wrapping in Sum or Product desugars to passing in which functions you wanna use to implement the Monoid or whatever
19:12:57 <johnw> good intuition
19:13:46 <Zekka> I don't think newtype wrappers specifically ever bugged me that much, although I used to be suspicious of Haskell typesigs because so often you had a lot of layers of parametrization
19:13:58 <Zekka> and I was used to OO languages where that doesn't often occur
19:14:39 <CABALHATER> does anyone understand why cabal says "Warning: Note that reinstalls are always dangerous. Continuing anyway...". I was installing a package and one if its dependencies was a reinstall. I was NOT prompted however for whether i want to reinstall or not. it just went ahead and did it. and it broke my sandbox. can anybody explain the logic behind "this will screw up your sandbox but i like screwing up your sandbox anyway".  i just fa
19:15:17 <rwbarton> no
19:18:15 <kazagistar> mathematicians dont say "integers are a monoid", they say "integers are a monoid under multiplication", so you have to do "Int" only gives you the first part, and "Product a" gives you the second
19:20:37 <Zekka> kazagistar: Although Haskell obviously allows you to say 'this type is a monoid' when there's only one really obvious option, or when there's one option that seems more obvious, correct?
19:20:46 <Zekka> more obvious than others*
19:20:57 <kazagistar> Zekka: of course
19:21:17 <kadoban> CABALHATER: I don't think that's the default behavior, did you configure it like that? As I recall it doesn't do that unless you pass a command-line flag or put it in your config to do that.
19:21:35 <kazagistar> >fold [Nothing, Just 'a', Just 'b']
19:22:19 <Zekka> Yeah, I guess I'll clarify: it's not that I didn't know that it did that but that I figured a question like that would bring out any other commentary if there was something about the design decision that merited further comment
19:22:24 <Zekka> also, I think you need the space:
19:22:27 <kazagistar> wait, thats not right
19:22:32 <Zekka> > fold [Nothing, Just 'a', Just 'b']
19:22:33 <lambdabot>  No instance for (Data.Monoid.Monoid GHC.Types.Char)
19:22:34 <lambdabot>    arising from a use of â€˜Data.Foldable.foldâ€™
19:22:47 <kazagistar> I misread the maybe instance, this makes more sense
19:22:57 <Zekka> > (Just 'a') <> (Just 'b')
19:22:58 <lambdabot>  No instance for (Data.Monoid.Monoid GHC.Types.Char)
19:22:58 <lambdabot>    arising from a use of â€˜Data.Monoid.<>â€™
19:23:02 <Zekka> > (Just "a") <> (Just "b")
19:23:03 <lambdabot>  Just "ab"
19:23:06 <kazagistar> >fold [Nothing, Just (Sum 2), Just (Sum 4)]
19:23:10 <triliyn> > foldMap First [Nothing, Just 'a', Just 'b')
19:23:12 <lambdabot>  <hint>:1:43: parse error on input â€˜)â€™
19:23:15 <triliyn> > foldMap First [Nothing, Just 'a', Just 'b']
19:23:17 <lambdabot>  First {getFirst = Just 'a'}
19:23:19 <kazagistar> > fold [Nothing, Just (Sum 2), Just (Sum 4)]
19:23:21 <lambdabot>  Just (Sum {getSum = 6})
19:24:31 <kazagistar> Zekka: they are pretty careful about not having defaults if there is any ambiguity
19:25:27 <kazagistar> because throwing an error is still better then doing the wrong thing most of the time in software engineering :D
19:26:03 <johnw> is there a way to write polymorphic functions in where clauses?  I have a newtype that wants a Rank-2 function, but if I define that function in a where clause it complains that 'type variable 'foo' would escape its scope'
19:26:43 <johnw> if i move the code around so that it's not the where clause, but uses 'fix' for recursion, it works fine
19:26:52 <luite> edwardk: you managed to catch your flight?
19:27:14 <kazagistar> Zekka: unrelated, but I think Ix is also pretty damn cool
19:27:41 <Eduard_Munteanu> johnw: I don't see any reason it wouldn't work
19:27:47 <Zekka> @source Ix
19:27:47 <lambdabot> Unknown command, try @list
19:27:52 <Zekka> @src Ix
19:27:52 <lambdabot> class (Ord a) => Ix a where
19:27:52 <lambdabot>     range           :: (a,a) -> [a]
19:27:52 <lambdabot>     index           :: (a,a) -> a -> Int
19:27:52 <lambdabot>     inRange         :: (a,a) -> a -> Bool
19:27:52 <lambdabot>     rangeSize       :: (a,a) -> Int
19:27:56 <Eduard_Munteanu> johnw: did you give it a type signature?
19:28:08 <johnw> Eduard_Munteanu: here's the code: https://gist.github.com/1f63561d30d834aaf61e
19:28:24 <johnw> a version that works is on line 214
19:28:27 <Zekka> Oh, yes, this is used to allow indexed types to act as ranges for n-tuples, right?
19:28:32 <johnw> a version that doesn't is on line 226
19:28:40 <Zekka> actually, that may be garbled
19:28:47 <johnw> i've tried giving type signatures, but haven't found the secret sauce yet
19:28:52 <Zekka> No, my mistake, that's incorrect, I see what it does now
19:29:09 <Eduard_Munteanu> johnw: you can't really write rank-2 types without signatures, GHC doesn't infer rank-2
19:29:21 <Eduard_Munteanu> Write rank-2 functions, even.
19:29:22 <kazagistar> Zekka: @instances-importing Data.Ix Ix
19:29:33 <Zekka> @instances-importing Data.Ix Ix
19:29:34 <lambdabot> (), (a, b), (a1, a2, a3), (a1, a2, a3, a4), Bool, Char, Int, Integer, Ordering
19:30:32 <Zekka> Yeah, my mistake. For some reason I'd initially thought that it was a type that allowed you to induct that if a was a member, (a, a) was a member, (a, a, a) was a member, and so on, but because of haskell's tuple formulation obviously no such type can exist without trickery
19:30:45 <johnw> Eduard_Munteanu: I added a comment at the bottom of that gist
19:30:54 <johnw> with those type signature, 'go' typechecks, but 'loop' does not
19:30:59 <johnw> i'll paste the error
19:31:08 <johnw> well, there are several
19:31:08 <kazagistar> Zekka: its an all inclusive "anything that can be used for an index" typeclass... so I can have an array from (-5,-5) to (5,5), or from (True, 'a', Nothing) to (False, 'b', Just ()) if I was crazy enough
19:31:24 <Eduard_Munteanu> johnw: that doesn't look rank-2
19:31:24 <johnw> mainly about aN ~ a failing to deduce
19:31:39 <johnw> Eduard_Munteanu: how do I write it to be rank two?
19:31:47 <kazagistar> er, that second one is wrong oops
19:31:48 <johnw> Source need a universally quantified function
19:31:50 <Zekka> kazagistar: Right, so long as you can define range (and preferably come up with not slow-as-hell versions of the others)
19:32:47 <delrik> I was reading through Hlints source: wtf is this?
19:32:48 <delrik> instance Ord Dbl where +    compare a b | a == b = EQ +    compare (Dbl a) (Dbl b) = compare a b
19:32:49 <Zekka> As far as I can see you can write the other three methods in terms of range, you just wouldn't ever want to
19:32:54 <delrik> (sigh)
19:32:54 <Eduard_Munteanu> johnw: presumably you want ScopedTypeVariables, then  go :: forall r. a -> r -> (r -> a -> EitherT r m r) -> EitherT r m r   and forall a on the iterateC's signature.
19:33:01 <delrik> ignore that
19:33:02 <delrik> brb
19:33:32 <delrik> http://lpaste.net/105503
19:33:48 <johnw> Eduard_Munteanu: only 'r' should be universally quantified; but no, that did not help
19:33:53 <delrik> on line 2, whats that pattern saying?
19:34:32 <delrik> is the a == b part a predicate?
19:34:48 <delrik> or is this pattern matching two cases?
19:35:33 <johnw> Eduard_Munteanu: aha!  found it
19:35:46 <Eduard_Munteanu> johnw: loop's signature?
19:35:53 <johnw> commented the gist
19:36:10 <Eduard_Munteanu> Ah, missing the 'm'.
19:36:12 <johnw> the top-level function needs to "introduce" the rank-1 type variables into scope for the where bindings
19:36:48 <johnw> cool, this is the first time I've ever used ScopedTypeVariables for anything other than putting a type signature on a type variable  :)
19:38:11 <johnw> I now have a frighteningly large number of type signatures to write :(
19:40:16 <triliyn> delrik: it's a predicate
19:42:25 <xxx-man> Eduard_Munteanu: Hi
19:42:47 <Eduard_Munteanu> xxx-man: hi
19:42:53 <solidus-river> hey all, i'm having one hell of a time getting this code to compile using type families
19:43:02 <solidus-river> i've got it down to an error at the top level, all submodules compile fine
19:43:06 <solidus-river> but hte top level gives me this error
19:43:37 <delrik> triliyn: Thx
19:43:49 <solidus-river> http://lpaste.net/105504
19:43:57 <xxx-man> Eduard_Munteanu: could you see pm please?
19:44:01 <solidus-river> you can see the full code here https://github.com/fuag15/yaskl
19:44:09 <Eduard_Munteanu> Yeah.
19:44:31 <Eduard_Munteanu> xxx-man: er, sorry, I don't have much time right now.
19:44:40 <xxx-man> ok
19:44:48 <solidus-river> Am i trying to do something with type families that haskell just can't do? that would make me really sad :(
19:45:19 <xxx-man> Eduard_Munteanu: I just had very short question...
19:45:43 <solidus-river> xxx-man: what is your question, perhaps one of us can help who arent as busy as Eduard_Munteanu :)
19:46:03 <xxx-man> it is not related to haskell...
19:46:08 <xxx-man> thanks
19:47:24 <solidus-river> i think i understand why it cant infer what type uf0 is
19:48:01 <solidus-river> but its expected that type is undefined untill run time but during run time it is garuntee'd to be resolved to an instance of DBConnection
19:50:55 <Lutin`> ugh why does haskell-src-exts not require happy
19:51:16 <Lutin`> have to install it manually everytime on a new system
19:51:55 <solidus-river> heh, no clue what happy is
19:52:26 <kadoban> Me either, but I know I run into that every time I install haskell too, haha...
19:52:26 <coppro> Lutin`: because happy's a binary
19:52:43 <johnw> solidus-river: which function wants the type variable "uf"?
19:53:28 <solidus-river> loadConfiguration i'm guesing, but maybe dispatchTasks
19:53:46 <kazagistar> so I have put some effort into this idea, and I am wondering if finishing it up and making it a library is worthwhile: http://lpaste.net/105505
19:54:01 <johnw> somewhere there will be an actual type variable with that name
19:54:07 <johnw> i'm just too lazy to clone your code to grep for it
19:54:08 <solidus-river> the thing is i though that the injectivity typeclass i put in would resolve these sorts of errors
19:54:22 <solidus-river> johnw: you sure?
19:54:28 <solidus-river> i'll grep but i dont think there is a variable by that name
19:54:31 <johnw> fairly sure; GHC doesn't make that stuff up
19:54:32 <kazagistar> and I am looking for actual haskell pro input :D... as in, are the names good, is there an existing way to do this somewhere, etc
19:54:58 <solidus-river> johnw: aye, there is no variabl by that name
19:55:03 <solidus-river> i think its a side effect of type families
19:55:07 <johnw> possibly so
19:55:11 <solidus-river> i have a type family and an inverse type family
19:55:33 <solidus-river> and its complaining that it cant find the type to match the inverse of the type family that proves it is injective with respect to my database class
19:55:45 <solidus-river> but it shouldn't be able to find it, because it is all determined at run time
19:56:02 <kazagistar> basically, I can turn an Array k v into a Map k v, but this is a mechanism to go backwards, which does not exist in a generalized way but is possible in every standard case
19:56:05 <solidus-river> my motivation for using type families at all was to allow the concrete instance to be resolved at runtime based on a configuration file
19:56:20 <johnw> on what line do you use type families?
19:56:32 <solidus-river> https://github.com/fuag15/yaskl/blob/master/src/Yaskl/Data/Database.hs
19:56:33 <johnw> wait, how will type families let you resolve a type at runtime?
19:56:34 <solidus-river> and
19:56:48 <solidus-river> https://github.com/fuag15/yaskl/blob/master/src/Yaskl/PostgreSQL/Database.hs
19:56:52 <johnw> types don't exist at runtime
19:56:55 <solidus-river> are the places where type families are in use
19:57:22 <solidus-river> if you read those two files you should understand what i'm trying to do with it, i'm no doubt stating it wrong
19:58:01 <johnw> why not use a data family?
19:58:03 <johnw> they are injective
19:58:09 <johnw> and I doubt you want to share them
19:59:09 <solidus-river> johnw: i'd be up to try that however it started to complain about the type signatures of my functions when i switched and supposedly the inverse type family proving injectivity of the type family to the class should solve it
19:59:18 <solidus-river> let me try modifying it to use data and see if that resolves things
20:00:09 <enthropy> solidus-river: I would make InjectiveConnection also an associated type
20:00:10 <roconnor> coppro: what?
20:00:24 <solidus-river> enthropy: to the class?
20:00:26 <enthropy> that way you get warnings when you forget to write an instance
20:00:34 <enthropy> solidus-river: yeahp
20:00:58 <enthropy> and maybe a nice name is  UnDBConnection
20:01:00 <solidus-river> can i class be constrained by a type defined within the class?
20:01:08 <solidus-river> *a
20:01:29 <enthropy> of course
20:01:59 <solidus-river> enthropy: interesting, i wonder if that will resolve the problem
20:02:27 <solidus-river> oh, i couldn't use data families because it made any function that relied on the Connection fail
20:02:28 <enthropy> it shouldn't, unless your problem is caused by a missing type instance InjectiveConnection
20:02:49 <solidus-river> enthropy: then i'm still confused about the cause of the problem
20:03:01 * enthropy reads the scrollback
20:05:34 <kazagistar> Ok, ill try again cause I really want feedback on this: http://lpaste.net/105505
20:05:46 <kazagistar> its a typeclass for doing this: extents :: [a] -> (a,a)
20:06:05 <kazagistar> which, given a set of keys, finds a min and max index for it
20:06:22 <kazagistar> which is different from Ord in how it handles tuples and such
20:06:39 <enthropy> solidus-river: looks to me like you're doing the equivalent of    main = print $ read "1"
20:06:48 * solidus-river scratches head, i dont even get how to make the UnDBConnection an associated type, It takes a DBConnection a and returns a DatabaseHandler a
20:07:28 <enthropy> you need an annotation to specify that you're using the database type you defined in postgres, instead of some other one
20:08:01 <solidus-river> enthropy: aye, but the problem is i want my progrma to be able to read a 1, a 1.0, a 1/2 etc because that doesnt change the base logic
20:08:06 <enthropy> solidus-river: well you did it once already at https://github.com/fuag15/yaskl/blob/master/src/Yaskl/Data/Database.hs#L21
20:08:16 <solidus-river> is there anyway to keep that generality without forcing the postgres version of database in the program
20:09:53 <enthropy> solidus-river: so just make another line below that giving type InjectiveConnection b
20:11:12 <Lutin`> coppro: But it's on Hackage
20:11:18 <Lutin`> You can `cabal install happy`
20:11:27 <saml_> what's fastest k-nn in haskell?
20:11:30 <saml_> is it faster than rust?
20:11:33 <enthropy> > \x -> [show (readMaybe x :: Maybe Int), show (readMaybe x :: Maybe Double)] "1"
20:11:35 <lambdabot>  Not in scope: â€˜readMaybeâ€™Not in scope: â€˜readMaybeâ€™
20:11:46 <enthropy> > \x -> [show (Text.Read.readMaybe x :: Maybe Int), show (Text.Read.readMaybe x :: Maybe Double)] "1"
20:11:48 <lambdabot>  Not in scope: â€˜Text.Read.readMaybeâ€™Not in scope: â€˜Text.Read.readMaybeâ€™
20:11:58 <saml_> scope's too small
20:11:59 <Lutin`> saml_: What data structure?
20:12:03 <Lutin`> Does it matter?
20:12:05 <enthropy> @let import Text.Read
20:12:07 <lambdabot>  Defined.
20:12:10 <enthropy> > \x -> [show (readMaybe x :: Maybe Int), show (readMaybe x :: Maybe Double)] "1"
20:12:12 <lambdabot>  Couldn't match expected type â€˜[GHC.Types.Char] -> tâ€™
20:12:12 <lambdabot>              with actual type â€˜[GHC.Base.String]â€™
20:12:14 <saml_> http://huonw.github.io/2014/06/10/knn-rust.html  Lutin`
20:12:26 <solidus-river> enthropy: ah, i was trying to do InjectiveConnection (DBConnection a) not InjectiveConnection b
20:12:27 <enthropy> > (\x -> [show (readMaybe x :: Maybe Int), show (readMaybe x :: Maybe Double)]) "1"
20:12:29 <lambdabot>  ["Just 1","Just 1.0"]
20:12:34 <solidus-river> but you right, that did not help out the situation with my error
20:12:49 <coppro> Lutin`: yes, but it's not a dependency in the sense cabal uses
20:12:59 <coppro> cabal is not a package manager
20:13:08 <Lutin`> Ah yeah I get what you're saying now
20:13:15 <solidus-river> enthropy: but how can i tell GHC that the specific instance of the DBConnection is unimportant to the program, the only thing that matters is that it stay 1:1 with the DatabaseHandler instance being used
20:13:16 <Lutin`> It's used as a binary not a library
20:13:19 <coppro> yeah
20:13:24 <Lutin`> makes sense
20:13:34 <enthropy> @tell ion can you import Text.Read in \bot?
20:13:34 <lambdabot> Consider it noted.
20:15:01 <coppro> enthropy: it's imported
20:15:04 <solidus-river> enthropy: perhaps i'm over thinking this and creating two problems where there was one, i can easily make it a concrete type at load time in a case statement
20:15:10 <enthropy> @unlet
20:15:10 <lambdabot>  Define what?
20:15:14 <enthropy> @undefine
20:15:14 <lambdabot> Undefined.
20:15:21 <enthropy> > readMaybe "()"
20:15:22 <lambdabot>  Not in scope: â€˜readMaybeâ€™
20:15:30 <enthropy> coppro: until somebody does that
20:15:55 <enthropy> solidus-river: at some point you have to commit to a particular instance
20:16:18 <solidus-river> enthropy: aye, i just for some reason had it in my head that i had to commit too early
20:16:29 <solidus-river> it should work out fine if my loader resolves a concrete instance
20:16:57 <solidus-river> then i can still support a general class and perhaps GHC will be satisfied
20:21:40 <Lutin`> saml_: You could check out HLearn
20:22:23 <Lutin`> not sure if it's the fastest though
20:22:36 <Lutin`> It's probably not
20:24:31 <acconrad> Hi everyone! Iâ€™m reading the Learn You a Haskell book and I have a very basic question: how is it possible for Integer to not overflow under the hood? If a PC has at best 64 bits, does that mean that an Integer is a conglomeration of multiple address spaces to accommodate numbers that are arbitrarily large?
20:24:55 <StoneCypher4k> that phrasing is pretty weird, but essentially yes
20:25:17 <StoneCypher4k> i mean if you want it to seem less weird, just think about a string containing a decimal number
20:25:21 <enthropy> Integer can be bigger than a machine int
20:25:25 <StoneCypher4k> obviously that's awful and that's not how it's implemented
20:25:27 <kadoban> acconrad: Yes, it's a bignum implementation
20:25:32 <enthropy> > 1000000000000000000000000000000000000000
20:25:34 <lambdabot>  1000000000000000000000000000000000000000
20:25:40 <solidus-river> enthropy: well i'll be... that did it
20:25:41 <StoneCypher4k> but that's sort of the general idea, is it's just not a machine number at all
20:25:55 <solidus-river> i was just trying to force GHC to think about something generally that had no reason being general yet
20:25:59 <kazagistar> acconrad: think of Int as a constant sized array of bits, and Integer as a dynamically sized list of bits
20:26:01 <acconrad> yeah but how can the machine possibly do math on that
20:26:09 <johnw> someone should write a dgmp library, so that I can have numbers so big that they need to span multiple machines...
20:26:13 <acconrad> i thought the whole point of things like MOV were only able to operate on 1 address space
20:26:18 <solidus-river> so I think i made the right choice using type families and not datafamilies there but maybe not, what is the majore difference between them?
20:26:44 <acconrad> i mean i get that from a higher level that its array concatenation of bits
20:27:02 <acconrad> but from a machine level, i feel like its asking a PC to invent a color when its colorblind
20:27:06 <kazagistar> acconrad: the machine does not do math on Integer, it does math on chunks of it at a time, and haskell implements the rest, like carry operations when it overflows and whatnot
20:27:19 <kadoban> acconrad: It's not a simple assembly instruction to process Integers, it requires more work than that.
20:27:48 <kadoban> acconrad: If it will clear it up for you, it might be an interesting challenge to implement something like that, in Haskell or otherwise.
20:27:53 <johnw> acconrad: there's a very in-depth description of how multi-precision integers work, and how to implement them, in Knuth's Art of Programming book, I think vol 2
20:28:08 <StoneCypher4k> acconrad: again, just think of a decimal string.  how could you do math on that?  the same way you do on paper.
20:28:27 <StoneCypher4k> acconrad: that is, don't use the machine's math; do it yourself, "by hand" as it were
20:28:38 <acconrad> well i thought th eway decimals worked was by flipping the leading bit (or is that negatives)
20:28:59 <acconrad> again im pretty far removed from my university courses in low level programming, but it was just fascinating that LYAH showed factorial 50
20:29:13 <StoneCypher4k> acconrad: lots of functional languages are base bignum, actually
20:29:20 <StoneCypher4k> acconrad: ocaml, erlang, etc
20:29:22 <solidus-river> enthropy, johnw: thank you for your help with the type families
20:29:33 <johnw> solidus-river: what did you end up with?
20:29:57 <enthropy> solidus-river: data families would be less code on your end, but then you have to make a new constructor for every instance
20:30:07 <solidus-river> johnw: i made the Inverse type family associated with the class and then i commited to an instance of the class in the Loader module
20:30:16 <enthropy> instead of no constructor and two type family instances
20:30:51 <johnw> I'm pretty sure using a functional dependency would give you injectivity too
20:31:01 <acconrad> so does performance work in languages like ocaML and erlang because they are memory-intensive?
20:31:25 <acconrad> it seems to me like the advent of massive harddrives, caches and RAM is what allows languages like haskell to thrive
20:31:49 <johnw> acconrad: certainly we don't have to worry at the level of bits as much anymore
20:31:53 <acconrad> as its space bound, which we seem to have a relatively unlimited supply of
20:31:59 <johnw> but optimizing Haskell is still needed sometimes
20:32:06 <johnw> in fact, that's my task at work this very moment
20:32:09 <acconrad> i mean what, the GHC on my machine takes up 9 gigs or something insane like that
20:32:17 <johnw> trying to reduce the runtime of something that takes 9 hours down to a more reasonable frame of time
20:32:20 * hackagebot simple-conduit 0.3.0 - A simple streaming library based on composing monadic folds.  http://hackage.haskell.org/package/simple-conduit-0.3.0 (JohnWiegley)
20:32:26 <enthropy> johnw: yeah a fundep can be equivalent
20:32:32 <acconrad> johnw: what do you do for work? that seems so cool!
20:32:47 <solidus-river> acconrad: what allows languages like haskell to thrive is people are starting to realize how much of a crapshoot loose binding is but still wanting higher level paradigms :P imo
20:32:53 <johnw> acconrad: right now I'm working on this: I work for BAE Systems
20:32:54 <johnw> http://www.crash-safe.org/
20:33:10 <solidus-river> or.. thats what i thought was cool about, could be pretty wrong, only been messing with it for a little bit now
20:33:14 <levi> johnw: Yeah, the multi-precision arithmetic stuff is in Vol 2, in the second half of it.
20:33:30 <levi> johnw: (I only know because I was looking through it just a couple of days ago)
20:33:39 <johnw> levi: I've implemented them, but I later found some very cool C tricks that beat the pants off the best speed Knuth will give you
20:34:03 <levi> johnw: What kind of cool "C tricks"?
20:34:12 <johnw> let me find it, I think I fork the repo
20:34:15 <kazagistar> acconrad: while haskell does not spend a lot of time worrying about bitpacking and so on, it can still be pretty efficient generally
20:34:51 <johnw> levi: oh, n/m, I was thinking of decimal floating-point conversion
20:34:55 <acconrad> johnw: neat! wow this is so over my head
20:34:57 <levi> johnw: I'm just curious if they have anything to do with C or if they're just too low-level to do in Haskell.
20:35:05 <johnw> (which I used GMP to implement)
20:35:10 <acconrad> part of my fascination with haskell is it reminds me of school because it requires me to think
20:35:25 <johnw> acconrad: heh, try Agda sometime :)
20:35:26 <acconrad> i feel like my job as a front end developer is really easy - javascript is not hard, it does not offer me too much of a challenge
20:35:49 <levi> Speaking of low-level stuff, I was also recently looking at Hash Array Mapped Tries, which have some fun bit-level tricks.
20:35:50 <solidus-river> acconrad: not that don't already write good javascript, but i bet haskell will help you write better
20:35:51 <acconrad> but i feel like haskell will offer me some sort of enlightenment if i stick with it. and get me mentally invested in math again
20:36:10 <solidus-river> its certainly helped my code structure in unrelated languages since i started
20:36:21 <acconrad> solidus-river: i mean yes, javascript borrows many concepts from functional programming, and will even moreso in ES6
20:36:40 <acconrad> even Crockford said himself heâ€™s writing more FP-based JS, like not using new anymore and things like that
20:36:40 <solidus-river> acconrad: but functional purity isn't isolated to functional languages, or that concept isn't
20:36:50 <Zekka> I'm not sure I'd say Javascript looks that much like haskell specifically, mind
20:37:00 <Zekka> not that that's exactly what you were saying
20:37:07 <dsturnbull> sometimes, haskell is easier because you don't have to worry about all the holes in javascript. mutability, nullability are pretty hard problems, or at least annoying, to work around
20:37:07 <johnw> I had to extend a C++ program of mine the other day, and I was simply shocked at how much mutation and shared state it relied on to do the simplest things
20:37:14 <levi> Javascript isn't hard by itself, but I find programming in Javascript harder than in Haskell now that I know them both reasonably well.
20:37:32 <Zekka> I'd say the same as Levi
20:37:44 <kazagistar> Javascript claims functional heritage, but functional languages tend to disown Javascript :P
20:37:44 <acconrad> dsturnbull: yeah but i donâ€™t think those are holes of programming languages (e.g. mutability)
20:37:50 <acconrad> the holes in JS are that its broken
20:38:01 <dsturnbull> if (typeof my_var !== "undefined" && my_var !== null) { // you idiots put Rasmus Lerdorf to shame
20:38:02 <levi> Not because the language concepts in Javascript are hard, but because the environment and style of programming tends towards hard-to-manage programming situations.
20:38:04 <dsturnbull> }
20:38:06 <acconrad> typeof undefined == undefined
20:38:08 <johnw> there also a difference between "thinking with Haskell" and "thinking with Haskell and all of its cool libraries, like lens, pipes, frp, etc."  There are a lot of sub-languages within Haskell, implemented as libraries
20:38:09 <dsturnbull> ^ my favourite snippet
20:38:57 <acconrad> johnw: yeah but that requires you to write a lot of haskell to find those subsets
20:39:03 <johnw> it does
20:39:06 <acconrad> my biggest issue is i still havent found a reason to really program in haskell yet
20:39:14 <kazagistar> acconrad: you would be surprised... there are many places like C++ where people are starting to really push immutability semantics
20:39:16 <acconrad> at least with ruby and javascript, i had a need, which was to biuild a website
20:39:17 <johnw> nothing beats lots of experience followed by reflection and more experience :)
20:39:19 <julianb> acconrad, not really. Have you looked at Haxl?
20:39:40 <Zekka> I've found Haskell pretty useful for general purpose programming
20:39:44 <acconrad> but i feel like i need to write some financial quant code, or create some script to make picking stocks better for me
20:39:47 <acconrad> to really use haskell
20:39:48 <levi> acconrad: Make a reason up.  Write a program that plays tic-tac-toe or something.
20:39:58 <Zekka> whatever I wouldwrite in another language before learning Haskell I tend to write in Haskell now
20:40:45 <levi> acconrad: Work through the stuff here: http://www.boundvariable.org/
20:40:59 <dsturnbull> acconrad: any kind of data manipulation is joyous
20:40:59 <julianb> well, I usually find myself thinking in terms of fmap, filter and foldr, and I discovered haskell pretty recently
20:41:16 <zomg> acconrad: I just do web app stuff with haskell
20:41:17 <acconrad> julianb: see that just reminds me of scheme/lisp
20:41:53 <acconrad> zomg: i tried working with yesod and it was a nightmare just to make a form use an optional form element instead of a mandatory one. and i was pair programming with someone too. it just felt really difficult to use
20:42:32 <zomg> If you're not very experienced in Haskell it might be
20:42:35 <nisstyre> acconrad: yep
20:42:35 <julianb> actually, I'd say that a certain understanding such basic high order functions really goes a long way in understanding and programming within an imperative setting
20:42:44 <levi> acconrad: Yesod is not necessarily a great introduction to Haskell, though it's reasonably good at what it's trying to be.
20:42:52 <kazagistar> C++ talk about replacing loops with function calls, classes with typeclasses, mutable data types with immutable, and using lambdas everywhere -> shttp://channel9.msdn.com/Events/GoingNative/2013/Cpp-Seasoning
20:42:52 <nisstyre> zomg: no, yesod is unintuitive even for Haskell experts
20:43:07 <zomg> acconrad: you might wanna try something like Scotty if you've used Ruby or such before, it's a bit more straightforward to deal with I think
20:43:15 <zomg> nisstyre: dunno =)
20:43:27 <acconrad> fair. thats why i feel like i need to read LYAH, then maybe a book that introduces functional concepts for use object-oriented/procedural folks
20:43:38 <nisstyre> zomg: let's take SPJ and ask him to write a web app in yesod
20:43:50 <acconrad> and then try writing a stock scraper that inputs stock data and outputs stocks to pick based on a series of functions (formulas)
20:43:55 <kazagistar> that C++ talk was quoted as "the best talk he ever heard" in the talk by the Microsoft C compiler team talking about changes they were making recently
20:44:30 <levi> nisstyre: Let's not waste SPJ's time with web dev! ;)
20:45:04 <johnw> kazagistar: Sean Parent is a great guy
20:45:20 <nisstyre> acconrad: a good intro to FP is The Little Schemer
20:46:11 <acconrad> nisstyre: yeah but dont you need to write that in Scheme?
20:46:27 <nisstyre> acconrad: yes, but you can learn Scheme in ten minutes
20:46:38 <acconrad> yeah, i remember it from college
20:46:41 <nisstyre> acconrad: also it's more like an "investigation" into computation
20:46:44 <nisstyre> using Scheme notation
20:46:56 <acconrad> couldnt i just do SICP then?
20:46:59 <acconrad> thats using scheme
20:47:03 <acconrad> or i guess common lisp
20:47:03 <nisstyre> acconrad: you could
20:47:07 <nisstyre> SICP is a lot more reading
20:47:12 <nisstyre> acconrad: no
20:47:20 <nisstyre> common lisp is not something you should care about
20:47:22 <levi> Scheme is my favorite untyped language.
20:47:39 <acconrad> Scheme:Lisp::asm.js::Javascript?
20:47:41 <nisstyre> unless you need a ton of features that made sense in 1989
20:47:54 <nisstyre> like separate namespaces for functions and values
20:47:58 <julianb> obligatory xkcd https://xkcd.com/297/
20:48:06 <Ginto8> kazagistar: as a C/C++ guy who only recently started Haskell, I love C++'s incorporation of functional features.
20:48:07 <levi> No, Scheme is beautiful; asm.js is just low-level.
20:48:28 <nisstyre> levi: Scheme is my favourite language period
20:50:03 <kazagistar> Ginto8: as someone coming from dynamic languages and only having done C in the past, I find learning about C++'s functional features to be very interesting
20:50:43 <monochrom> oh w00t, Haskell Weekly News appeareth!
20:50:47 <nisstyre> acconrad: Scheme is not low level btw
20:51:05 <nisstyre> acconrad: the point of Scheme is to give you the ability to build on a small core
20:51:14 <nisstyre> and even to design the core language like that
20:51:24 <nisstyre> it influenced the design of compilers like GHC
20:51:32 <levi> acconrad: Scheme is a polished gemstone, the distilled essence of the tools required for programming.
20:51:38 <Ginto8> kazagistar: C++ is interesting in that it has adopted a lot of abstractions, but hasn't required them or hidden their (sometimes important) implementation details too deeply
20:51:40 <nisstyre> see the paper on RABBIT
20:52:04 <levi> asm.js is just the bits of javascript that accidentally happen to be well-optimized by a couple of JIT-compilers.
20:52:18 <nisstyre> yeah
20:52:40 <Ginto8> kazagistar: specifically, that lambdas are local classes with one object, virtual functions are explicitly implemented via vtables (which you can access if you're crazy with pointers), etc.
20:52:54 <nisstyre> also if Scheme did not exist it seems unlikely that we would know as much as we do about things like continuations
20:53:14 <nisstyre> since Scheme prompted their investigation
20:53:17 <levi> You can easily express patterns of computation in Scheme that require grody hacks in C, due to first-class continuations and guaranteed tail-call optimization.
20:53:23 <nisstyre> (points if you get the subtle joke there)
20:53:57 <levi> nisstyre: 'prompt' being a delimited continuation operator. :)
20:54:15 <nisstyre> yes :p
20:54:26 <acconrad> man
20:54:28 <acconrad> thats so nice to read
20:54:43 <acconrad> when i was a neophyte learning scheme in college at 18 i hated it because it felt too simple
20:54:51 <acconrad> especially for my simple mind stuck in java programming
20:54:52 <levi> I think it's probably safer to say that Scheme provided a vehicle for their investigation; they'd turned up at other times and probably would have been investigated.
20:54:58 <Lutin`> That's the point though
20:55:04 <nisstyre> levi: yeah fair enough
20:55:15 <Lutin`> To not be encumbered by the 'features' of your language
20:55:45 <nisstyre> Lutin`: it's also to not try and anticipate the problems/features people want
20:55:53 <nisstyre> and simply provide a vehicle to create them
20:55:53 <levi> Scheme *is* simple; it's the simplicity of a well-chosen set of features that combine with one another in interesting ways that give it power.
20:56:11 <Lutin`> Yes good point
20:56:25 <Lutin`> That's what I was trying to get at
20:57:04 <hunt> how do i get the Ptr to a storable?
20:57:15 <hunt> i have a Ptr and i would like to get the Ptr to that Ptr
20:57:22 <johnw> huh?
20:57:24 <acconrad> so if one who comes from a strong background of C++, Java, C#, Ruby and Javascript
20:57:29 <levi> Another reasonably good example of that school of language design is Lua, though it's not quite as clean and elegant as Scheme.
20:57:31 <hunt> johnw: whats confusing
20:57:31 <acconrad> were to gather a reading list
20:57:36 <acconrad> what order should he read them in?
20:57:43 <johnw> hunt: If you have a Ptr, you have a Ptr.  What do you mean, the Ptr to the Ptr?
20:57:45 <acconrad> right now Iâ€™m doing LYAH, though it feels really slow at the start
20:57:46 <Lutin`> mm I love Lua
20:57:51 <enthropy> @type new
20:57:52 <lambdabot> Not in scope: â€˜newâ€™
20:57:56 <levi> acconrad: What do you want to learn?
20:57:57 <enthropy> @type Foreign.new
20:57:58 <hunt> johnw: a Ptr references a memory address, id like to get the reference to that Ptr itself
20:57:58 <lambdabot> Foreign.Storable.Storable a => a -> IO (GHC.Ptr.Ptr a)
20:58:00 <nisstyre> acconrad: you can skip around if you want
20:58:02 <acconrad> but Iâ€™ve heard great things about Little Schemer, SICP, Real World Haskell...
20:58:14 <nisstyre> acconrad: RWH is kind of meh
20:58:17 <rwbarton> hunt, there is no such thing
20:58:27 <nisstyre> acconrad: it almost never does things the way I would, but ymmv
20:58:28 <rwbarton> you will have to allocate a Ptr (Ptr Whatever)
20:58:32 <hunt> rwbarton: Foreign.new seems correct
20:58:45 <rwbarton> using new for example yes
20:58:47 <enthropy> it allocates
20:58:49 <johnw> hunt: You don't get that, it can move in memory
20:58:52 <rwbarton> but you're not "getting" the pointer, you're allocating
20:59:00 <acconrad> levi: I want to learn how to actually feel comfortable writing haskell so I can write a stock picker, as I have no immediate commercial or fun use for it. For me I need to be motivated by a project to want to use a language
20:59:08 <nisstyre> acconrad: right now my favourite book is Lisp In Small Pieces (LISP), but it's like $50
20:59:13 <johnw> think of Ptr as a box that holds a number, which is the C pointer value
20:59:24 <johnw> the address of the box can move around, though the number stays constant
20:59:39 <Ginto8> johnw: so it's a pointer to a pointer
20:59:42 <johnw> I'm mostly sure that's how it works
20:59:43 <nisstyre> acconrad: but it guides you through the implementation of a bunch of interpreters and two compilers
20:59:50 <nisstyre> mostly for Scheme-ish languages
20:59:51 <hunt> johnw: yea ok that makes sense
21:00:02 <nisstyre> but it touches on common lisp features like separate namespaces
21:00:05 <johnw> Ginto8: yes, a Ptr is a Haskell value, which contains a number.  I think it's just a specialized Int
21:00:11 <nisstyre> (lisp-1, lisp-2)
21:00:39 <levi> acconrad: You might want to check out The Haskell School of Music; it's a freely-available draft textbook from one of the creators of Haskell.  He uses it to develop a computer music system, both for composition and synthesis.
21:00:41 <rwbarton> pretty much
21:00:48 <Ginto8> that would make sense, since pointers in C are just specialized ints ;)
21:01:03 <levi> It's not very related to stock picking, but it'll get you some projects to do.
21:01:08 <acconrad> levi: ah yes I saw that! I love computers AND musci so it fascinated me, but it felt like it required some rudamentary knowledge of the language first before diving in
21:01:12 <enthropy> levi: sounds kinda like "school of expression" which is a real book
21:01:27 <levi> enthropy: Yeah, same author, just a new book.
21:02:02 <levi> enthropy: "School of Music" is intended to be a "real book" too, I gather.
21:02:03 <Lutin`> Yeah Ptr holds an Addr# which internally is a 32/64-bit Int
21:02:14 <nisstyre> acconrad: if you do look at SICP, make sure you watch the recorded lectures too
21:02:19 <taktoa> HSoM is good
21:02:25 <nisstyre> they're pretty interesting, and cover material not in the book
21:02:54 <acconrad> does HSoM require some initial knowledge or prior reading (like LYAH) to truly grasp?
21:03:12 <Lutin`> not the last time I looked
21:03:21 <levi> acconrad: It starts out with pretty simple Haskell, you could probably manage it with just a reference handy.
21:03:29 <julianb> HSoM?
21:03:30 <nisstyre> acconrad: when I vaguely remember looking at it, the music theory stuff was way more daunting than the programming
21:03:36 <levi> julianb: Haskell School of Music
21:03:37 <acconrad> julianb: Haskell School of Music
21:03:40 <taktoa> Haskell School of Music
21:03:41 <nisstyre> but you may know more about that than me
21:04:01 <julianb> seems interesting
21:04:02 <acconrad> nisstyre: ha yes music theory i have a pretty solid knowledge of, and i really have a passion for music, so it definitely piqued my interest
21:04:05 <Lutin`> http://haskell.cs.yale.edu/wp-content/uploads/2014/04/HSoM1.pdf
21:04:18 <Lutin`> http://haskell.cs.yale.edu/?post_type=publication&p=112 is where the most updated link is kept
21:04:25 <levi> acconrad: Well, there you go. There's a project to get you started. :)
21:05:17 <hunt> haskell-src-ext gets a ghc segfault in .section .rodata (???) when i try to intsll it with LibraryProfiling True
21:05:19 <acconrad> levi: true! and i totally forgot one ofmy classmates from undergrad was one of the grad students at Yale that helped write this book
21:05:20 <Lutin`> acconrad: And flipping through it I don't think you'd really need any haskell background
21:05:46 <nisstyre> acconrad: also, since you've learned some imperative languages, I recommend you revisit them with something like http://www.amazon.com/Programming-Environment-Addison-Wesley-Professional-Computing/dp/0201563177
21:06:05 <rwbarton> hunt: probably https://ghc.haskell.org/trac/ghc/ticket/8768. it's gcc that's segfaulting
21:06:26 <nisstyre> just my recommendation though, if you really are interested in consolidating knowledge
21:06:44 <levi> For general books that give you a principled introduction to the core concepts in computing, I'd recommend "Concepts, Techniques, and Models of Computer Programming", "Structure and Interpretation of Computer Programs", and "Types and Programming Languages"
21:07:23 <levi> Also "Practical Foundations for Programming Languages"
21:07:32 <levi> And "Essentials of Programming Languages"
21:07:33 <nisstyre> tbh I really enjoy "domain specific" stuff like TCP/IP Illustrated
21:07:53 <nisstyre> I recommend looking at all the stuff mentioned though
21:08:20 <levi> More good books than time available to work through them. :(
21:08:30 <vincent99> hello
21:08:31 <nisstyre> Lisp In Small Pieces is really amazing though
21:08:43 <nisstyre> if you want to really understand how functional languages work
21:08:43 <Lutin`> hunt: Seems https://ghc.haskell.org/trac/ghc/changeset/396648eebaa1144d4d1f5326db716e8130f73732/ghc fixed it
21:08:47 <levi> I have that; I need to read it.
21:08:55 <vincent99> I created posted a paste but it doesn't appear to be working?
21:09:04 <nisstyre> levi: get Compiling with Continuations too
21:09:07 <Lutin`> But I can't quite find the current 7.8.3 tag
21:09:13 <levi> There's also SPJ's "The Implementation of Functional Programming Languages"
21:09:20 <levi> For a more haskell-colored look.
21:09:27 <levi> nisstyre: Ahh, I have read that one.
21:09:38 <acconrad> yeah maybe Iâ€™ll just read HSoM
21:09:45 <nisstyre> levi: CwC is about SML of NJ's use of continuations and a bunch of misc stuff like optimizations, register allocation, etc..
21:09:53 <acconrad> i feel like itâ€™s veil under music will be more interesting to me than LYAH or something else
21:09:54 <vincent99> I have heard that haskell is purely functional language, but seeing this program it looks rather imperative to me. I don't understand what is purely function about it. Can someone explain?
21:10:10 <vincent99> http://lpaste.net/105508
21:10:44 <nisstyre> vincent99: the answer is that values of IO a are still pure, they just do IO when they actually get executed
21:10:48 <shachaf> Haskell is a general-purpose language.
21:10:59 <shachaf> You can write imperative programs in it. That program is an example.
21:11:47 <levi> nisstyre: Yup; I've read it.
21:11:59 <vincent99> is that not contradictory?
21:12:01 <nisstyre> levi: did you actually make use of it for anything?
21:12:20 <julianb> vincent99, why should it be contradictory?
21:12:42 <vincent99> functional programming is not imperative programming?
21:12:53 <nisstyre> vincent99: the answer is that you can translate an imperative program into a functional one
21:12:58 <nisstyre> vincent99: and Haskell has this ability
21:13:07 <julianb> well, but that doesn't mean that you can't make a functional language look like an imperative one
21:13:12 <nisstyre> instead of doing it yourself it can do it automatically for some things
21:13:41 <levi> nisstyre: Unfortunately not yet.
21:14:07 <nisstyre> levi: I'm writing a compiler (in JavaScript heh) and the parts on closure conversion are useful for me
21:14:10 <shachaf> "purely functional language" doesn't really mean anything.
21:15:04 <vincent99> shachaf it says that on the wiki page, and it is what I've heard people say when describing haskell
21:15:08 <zwer> @undo do { putStrLn "What is your name?"; name <- getLine; putStrLn ("Hello " ++ name ++ "!") }
21:15:08 <lambdabot> putStrLn "What is your name?" >> getLine >>= \ name -> putStrLn ("Hello " ++ name ++ "!")
21:15:09 <Lutin`> It just means that the main language construct are functions that take in data and output data dependent only on the data that is put in
21:15:11 <johnw> I think what people mean by it is "use of IO is explicit"
21:15:43 <nisstyre> vincent99: entire papers have been written trying to explain what "purely functional" means
21:15:50 <levi> vincent99: Haskell's particular style of programming is more aptly called "denotative programming", meaning that its expressions have a fairly direct mathematical interpretation.  Imperative languages have a mathematical meaning as well, it's just not so direct.  So it's not too surprising that you can express imperative concepts in a denotative language.
21:15:53 <zwer> vincent99 does that still look imperative? do notation is just syntactic sugar for composing IO actions (not sure if this is being helpful to you, though)
21:16:48 <nisstyre> zwer: I tried to explain that as Haskell translating certain imperative programs into functional ones for you
21:16:56 <nisstyre> and that IO a is still a "pure" value
21:18:36 <vincent99> ok I can't follow that, I will keep reading. though, being purportedly purely functional is what attracted me to haskell, and i feel kind of cheated. :)
21:19:01 <Lutin`> vincent99: In this case `putStrLn "What is your name?"` doesn't actually print the string when evaluated. It evaluates to an IO 'action' that can be run by the GHC runtime
21:20:08 <Lutin`> It's a value that represents putting a string to std out, but it doesn't do it itself
21:20:09 <levi> nisstyre: Compiling with Continuations and the Lambda the Ultimate papers helped in a lot in developing an intuition for how you can represent arbitrary programs in terms of continuations and lambdas.
21:20:15 <vincent99> Lutin I see. so would you say it doesn't make haskell non-pure?
21:20:30 <Lutin`> It itself is very pure, it's simply a value
21:20:36 <Lutin`> But it has a special meaning to the GHC runtime
21:20:49 <nisstyre> levi: you wouldn't want to though, environments are best represented with something like a map, or even alists
21:21:18 <Lutin`> And we say that it's type is IO ()
21:21:23 <julianb> vincent99, I think you might find this useful: http://www.haskell.org/haskellwiki/IO_inside
21:21:31 <levi> nisstyre: Well, I meant control flow there more than managing bindings.
21:21:36 <nisstyre> levi: but yeah, Appel is a genius
21:21:43 <nisstyre> levi: oh yeah, fair enough
21:21:44 <taktoa> vincent99: think about it this way: when you run a haskell program, it shits out an imperative program and then runs *that*
21:21:57 <taktoa> the haskell program is pure, it's just writing code
21:22:26 <Lutin`> haha yeah
21:24:39 <zwer> imagine if main returned a list of bytes containing machine instructions for some ancient computer. construction of that list, and the list itself, would still be pure. and it wouldn't become any less pure if you wrote an interpeter and executed that machine code
21:26:18 <vincent99> interesting thanks guys. I am reading http://book.realworldhaskell.org/read/ btw. is that the recommended tutorial for someone with prior programming experience (C, various OOP languages)
21:26:42 <vincent99> but no functional programming experience
21:26:45 <nisstyre> vincent99: eh, I don't know if I would recommend it
21:26:59 <Lutin`> It tends to be the most accessable, but that's not always what you want
21:27:06 <nisstyre> vincent99: it's kind of heavy reading, and it does a lot of things the "long way"
21:27:07 <julianb> vincent99, I'd recommend LYAH
21:27:13 <nisstyre> it's very domain specific in parts
21:27:40 <nisstyre> by heavy reading, I mean there is simply a lot of text
21:27:48 <vincent99> I will check out LYAH too
21:27:49 <nisstyre> it doesn't give elegant explanations
21:28:05 <julianb> I would check LYAH out before Real World Haskell as well
21:28:23 * nisstyre read RWH before and regrets it
21:28:25 <julianb> I find it a quite intuitive introduction to haskell
21:28:44 <zwer> one more vote for LYAH
21:28:48 <nisstyre> and I actually never really read LYAH, just a few snippets
21:28:51 <dsturnbull> LYAH and RWH both trail off towards the end. but once you've read the first 3/4 of both, you can appreciate the last 1/4 of each
21:28:58 <nisstyre> but the snippets were decent
21:29:34 <dsturnbull> when RWH went on for chapters and chapters on pretty printing and parsing, i was very bemused... but after LYAH i realised why my mind was being blown
21:29:49 <nisstyre> dsturnbull: oh god yeah
21:29:51 <nisstyre> the json parser
21:29:54 <nisstyre> kmn
21:30:14 <solidus-river> I started with LYAH then i dove into trying to write a program then ran into fpcomplete.com
21:30:14 <dsturnbull> http://en.wikibooks.org/wiki/Write_Yourself_a_Scheme_in_48_Hours also fits in the mould, where once you get a grasp of the basics, it's really mind blowing
21:30:15 <acconrad> anyone know if there are solutions to HSoM?
21:30:47 <nisstyre> also I have a delightfully out of date copy of RWH now
21:33:09 <Lutin`> One of my favorite things about RWH is the online version
21:33:21 <Lutin`> Most questions I had were probably asked an answered in the comments
21:33:38 <acconrad> nevermind
21:33:39 <acconrad> http://haskell.cs.yale.edu/cpsc-432-532/homework-assignments/assignment-1/491-2/
21:33:43 <acconrad> starts from there and moves forward
21:34:50 <Lutin`> I would easily pay $1000 for an e-reader that looks and feels like a paper book
21:34:58 <Lutin`> hell even $2000
21:35:05 <Lutin`> one day...
21:35:34 <nisstyre> Lutin`: the technology for paper thin screens is there (almost) and the tech for e-ink obviously
21:35:44 <nisstyre> they just need to be combined into something with a few "pages"
21:36:36 <dsturnbull> paper thing, but as strong as paper?
21:36:43 <Lutin`> Heck if they came up with a nice interface for bookmarking pages and flipping back and forth I could probably deal with it
21:36:54 <nisstyre> I think they are made out of some kind of silicon yeah
21:37:06 <dsturnbull> i think shock absorption would be critical
21:37:08 <nisstyre> probably stronger than paper
21:37:09 <Lutin`> People keep saying graphene
21:37:13 <mzero> acconrad: I don't know of any... do you need help with HSoM?
21:37:40 <acconrad> mzero: I actually linked ot the solutions above
21:37:48 <mzero> I see that now... d'oh!
21:37:51 <acconrad> I just wanted to have a reference after trying the problems so I knew if I was on the right track
21:41:55 <jfischoff> I keep getting:  c_poll: invalid argument (Invalid argument)
21:42:25 <jfischoff> on OSX 10.9.3 ghc 7.8.2 and 7.6.3 any ideas?
21:42:32 <shachaf> strace to the rescue!
21:42:55 <shachaf> Or whatever the OS X equivalent is called. dtruss, I think.
21:43:21 <jfischoff> dtrace no?
21:43:56 <shachaf> dtruss - process syscall details. Uses DTrace.
21:44:03 <shachaf> I don't know much about OS X.
21:44:11 <johnw> it's dtruss
21:44:15 <johnw> which is a wrapper around dtrace
21:45:02 <zzo38> What are the strangest monads and comonads which can be used in Haskell effectively?
21:45:24 <mayski> so hum I'm getting ambiguity errors with Prelude.++ and Data.Vector++, can't ghc guess what I want from the type signature?
21:45:45 <mayski> seems "ugly" to have to write Data.Vector.++ explicitly
21:45:53 <mayski> or am I doing something completely wrong here
21:46:02 <ParahSailin> normally i "import qualified Data.Vector as V"
21:46:03 <shachaf> Perhaps you can use (Data.Monoid.<>)
21:46:33 <shachaf> Guessing the value you want from the type can be tricky, particularly when you're also guessing the type you want from the value.
21:46:35 <mayski> ParahSailin: ah ok that's nice
21:46:45 <mzero> jfischoff: that is strange
21:47:18 <jfischoff> mzero: I get it pretty consistently
21:47:25 <jfischoff> both version of ghc
21:47:30 <mayski> shachaf: I see
21:47:34 <mayski> thanks everyone
21:47:48 <jfischoff> the dtrace spew is giant and Iâ€™m not sure what I am looking for
21:48:17 <shachaf> poll() calls, presumably.
21:48:34 <shachaf> Perhaps debugging GHC isn't the best introduction to reading strace output.
21:49:46 <djahandarie> Debugging GHC probably isn't the best introduction to anything.
21:49:57 <dsturnbull> try checking https://ghc.haskell.org/trac/ghc/wiki/DTrace
21:50:03 <jle`> mayski: the keyword you're looking for is "type directed name resolution", btw
21:50:10 <mzero> jfischoff: do you know what is calling poll ?
21:50:35 <mzero> (from GHC.Event ... not c_poll)
21:51:01 <jfischoff> not really, I have some threads, MVars being read
21:51:26 <mayski> jle`: thanks!
21:55:01 <mzero> jfischoff: are you manipulating any FDs directly?
21:55:08 <jfischoff> no
21:57:00 <mzero> hmmmm... well, the error is just bubbled up from the underlying system poll call... but the only listed causes for that error are
21:57:15 <mzero> 1) more FDs than OPEN_MAX, or 2) timeout < -1
21:57:16 <jfischoff> Well I finally was able to watch the poll entry/return sys calls with DTrace and â€¦ again, I donâ€™t see anything useful, just a bunch of entry and return call :(
21:57:28 <jfischoff> hmm
21:57:36 <mzero> well, can you dtrace the one that fails?
21:57:48 <jfischoff> no sure how, but hopefully
21:57:50 <mzero> it would be interesting to know which of these two argument errors is the cause
21:58:02 <mzero> look for a call to poll that returns EINVAL
21:58:39 <enthropy> how bad are overlapping instances for a class used to generate a String passed to error?
21:58:41 <jfischoff> that actually gives me something to go on. I am using threadDelay maxBound a lot
21:58:57 <jfischoff> maybe it is overflowing?
21:59:10 <jfischoff> I
21:59:21 <ion> enthropy: Iâ€™m afraid iâ€™m not the Î»bot admin.
21:59:29 <jfischoff> â€˜m just going to modify the delay and see if the error goes away real quick
21:59:35 <enthropy> ion: I confused you with int-e?
22:00:33 <mzero> jfischoff: there is a bunch of hackery in GHC to deal with an issue that E.Timeout is an Int (64bits on your system I bet) where as the timeout to poll is CInt (only 32 bits)
22:01:14 <vincent99> hello. why doesn't this work? putStrLn getLine ?
22:01:16 <jfischoff> mzero: heh, switch to a smaller number and the error went away, thatâ€™s good enough for tonight
22:01:32 <shachaf> vincent99: The types don't match up.
22:01:39 <mzero> well, there ya go!
22:01:39 <Cale> vincent99: getLine isn't a String
22:02:00 <jfischoff> mzero: alright bed time, this weekend?
22:02:03 <Cale> vincent99: You probably want to run getLine first, and then apply putStrLn to its result, like  do x <- getLine; putStrLn x
22:02:05 <mzero> @type getLine
22:02:06 <lambdabot> IO String
22:02:20 <mzero> jfischoff: sure
22:02:33 <jfischoff> cool
22:02:35 * hackagebot haskeline 0.7.1.3 - A command-line interface for user input, written in Haskell.  http://hackage.haskell.org/package/haskeline-0.7.1.3 (JudahJacobson)
22:03:00 <vincent99> Cale actually original program someone gave me did just that. ok, I'll keep using <-
22:03:03 <Cale> vincent99: Or, if you prefer, you can use =<< for this:  putStrLn =<< getLine
22:07:35 * hackagebot hspec2 0.3.1 - Alpha version of Hspec 2.0  http://hackage.haskell.org/package/hspec2-0.3.1 (SimonHengel)
22:16:38 <knappador> just picked up cabal 1.18 from system packages
22:16:54 <knappador> attempting to get a cabal-dev environment going
22:17:17 <knappador> cabal sandbox
22:18:01 <carter> knappador: update to 1.20 for even more awesome :)
22:18:08 <carter> but >= 1.18 is a ncie setup
22:18:11 <knappador> carter:   attempting to
22:18:32 <knappador> got a lot of build errors when running  cabal install cabal cabal-install
22:18:41 <knappador> do i need to activate sandboxes in 1.18?
22:19:07 <johnw> just "cabal install cabal-install"
22:19:52 <knappador> first dependency fails
22:19:53 <knappador> Failed to install random-1.0.1.1
22:19:53 <knappador> Last 10 lines of the build log ( /home/knapper/projects/hatt/.cabal-sandbox/logs/random-1.0.1.1.log ):
22:20:01 <knappador> log is empty
22:20:04 <carter> knappador: don't build cabal-install in a sandbox
22:20:11 <knappador> lol
22:20:34 <pepper_chico> anyone here uses a Vim setup? I use vim2hs, and a bunch of other plugins, which are quite nice by the way. I have completion, warnings and errors: http://imgur.com/lUiDeA6,KNy9fCn. My only issue is that I'd like to avoid an specific warning, this one about Defaulting integer constant types http://i.imgur.com/KNy9fCn.png, anyone knows how can I prevent them from showing up in vim, I tried to set g:ghcmod_ghc_options but it didn't
22:20:34 <pepper_chico>  work
22:20:42 <knappador> sandboxes aren't self-hosting? i thought haskell is good for recursion =D
22:21:04 <carter> knappador: :P
22:21:09 <knappador> carter:  same issue in home directory
22:21:12 <carter> for what
22:21:14 <carter> doing what
22:21:18 <carter> @lpaste
22:21:18 <lambdabot> Haskell pastebin: http://lpaste.net/
22:21:22 <carter> paste what hapepns
22:21:25 <carter> WHAT OS
22:21:27 <carter> what GHC version
22:21:28 <carter> what os?
22:21:32 <carter> what does gcc--version say
22:21:39 <carter> what does the log say
22:23:05 <solidus-river> pepper_chico: thats quite the vim-fu you got goin there
22:23:48 <solidus-river> pepper_chico: i keep my vim prety vanilla so can't help
22:23:56 <pepper_chico> =/
22:24:26 <enthropy> pepper_chico: you might try to suppress the warning with {-# OPTIONS_GHC -fno-warn-default #-} (or whatever the flag is actually called)
22:24:28 <pepper_chico> at last, you don't need to mind about any useless warnings
22:25:02 <pepper_chico> enthropy I've tried to set that in the variable I said
22:25:16 <pepper_chico> it didn't worked... and when compiling from command line
22:25:22 <pepper_chico> I don't get that warning
22:25:24 <pepper_chico> so...
22:25:32 <pepper_chico> I dunno why it shows up
22:25:32 <carter> pepper_chico: you don't have -Wall on the CLI
22:25:36 <pepper_chico> ah
22:25:41 <enthropy> -fno-warn-type-defaults was the actual flag name?
22:25:45 <pepper_chico> should be that
22:25:50 <pepper_chico> yes
22:27:31 <knappador> http://lpaste.net/105510
22:28:26 <knappador> carter: does cabal default to per-user behavior?  wondering if i need to install system-wide (please no)
22:29:08 <knappador> I prefer a world where I use my system package just once to set up a virtual environment
22:29:13 <carter> knappador: how the heck did you install your ghc
22:29:16 <carter> what OS are you on
22:29:19 <knappador> Linux
22:29:23 <knappador> from package manager
22:29:29 <carter> ok
22:29:34 <carter> umm
22:29:41 <carter> i gotta repare the disk on this machine
22:29:47 <knappador> carter:   what's the problem?
22:29:49 <carter> bitemyapp: or Cale  or someone can help
22:29:53 <knappador> oh lol
22:29:53 <carter> my computer?
22:30:01 <knappador> nah, later
22:30:22 <knappador> what is weird about my GHC though?
22:30:43 <pepper_chico> ah, I think I know from where those warnings are coming I guess
22:32:06 <knappador> should I just install from source?
22:40:09 <bitemyapp> knappador: no
22:40:15 <bitemyapp> knappador: https://github.com/bitemyapp/learnhaskell
22:42:44 <user> http-conduit depend on http-client which doesn't install due to missing libs
22:42:46 <knappador> bitemyapp: should i just get haskell platform if I need ghc/cabal?
22:43:11 <knappador> i uninstalled my system libs to start doing this from scratch.
22:43:13 <mzero> that's sort of the plan!
22:43:18 <bitemyapp> knappador: please read the guide I linked.
22:43:23 <bitemyapp> knappador: it tells you what you should do.
22:44:26 <user> oh, it was http-streams that didn't install
22:44:46 <pepper_chico> one day I tried to install haskell from sources, and a recent haskell platform or something, it was a nightmare, just install haskell-platform, end of history
22:44:48 <knappador> bitemyapp: my system package manager does a crappy job.
22:45:34 <knappador> just get ghc and cabal?  this page recommends i get the platform.  http://www.haskell.org/ghc/download_ghc_7_8_2
22:45:46 <knappador> linked from your page
22:45:47 <mzero> what os are you on?
22:45:58 <mzero> and do you need 7.8 or is 7.6 good enough for now?
22:47:25 <bitemyapp> knappador: that page is wrong. Just get ghc and cabal.
22:47:46 <knappador> haha k
22:47:50 <mzero> that page is right!
22:48:08 <mzero> actually - either method is fine --- but most people find boostrapping cabal a PITA
22:52:44 <knappador> ah, i have a gcc error related to hardening flags
22:52:53 <bitemyapp> knappador: what distro/OS are you on?
22:53:06 <knappador> linux, gentoo w/ hardened gcc
22:53:24 <bitemyapp> knappador: gentoo doesn't have ports for GHC and Cabal?
22:53:33 <knappador> bitemyapp: they break too
22:53:50 <hunt_> guys im trying to install the haskell platform on mac, but in the installer the only option is install for all users of this computer
22:53:52 <bitemyapp> knappador: what part of the process is giving you an error?
22:54:01 <bitemyapp> hunt_: don't install platform...
22:54:03 <hunt_> im pretty sure if i do that i wont get a ~/.cabal or ~/.ghc
22:54:06 <bitemyapp> hunt_: http://ghcformacosx.github.io/
22:54:14 <knappador> bitemyapp: ./configure --home=/home/me/.haskell_bootstrap
22:54:16 <mzero> hunt_: is that a problem?
22:54:29 <mzero> but yes, GHC and Haskell Platform are configured to be installed system wide
22:54:36 <hunt_> mzero: yea it has been in the past because then all my cabal packages are in strange locations
22:54:38 <knappador> configure: Building in-tree ghc-pwd
22:54:42 <hunt_> mzero: it seems to mess with some libraries
22:54:52 <mzero> hunt_: well... it shouldn't
22:55:01 <bitemyapp> GHC is not necessarily system-wide at all. Many Haskell devs use multiple versions of GHC concurrently.
22:55:02 <mzero> where do you want cabal packages?
22:55:17 <hunt_> yea i dont want a system wide version anyways
22:55:23 <mzero> the Platform on Mac puts system packages under /Library/Haskell/xxxx
22:55:27 <bitemyapp> whether that's multiple versions in /opt or ~ is beside the point
22:55:36 <mzero> and puts user installed packages in ~/Library/Haskell/...
22:56:24 <mzero> Ithe only stuff that is installed in system location is the clean install of GHC and the Platform libs
22:56:32 <mzero> by default, everything else will be built and installed per user
22:56:52 <mzero> does that not match your needs?
22:57:04 <mzero> (wondering, as I am the packager of Haskell Platform for Mac OS X!)
22:57:39 <mzero> and, BTW, as installed with the Platorm, you can have multiple versions of GHC installed system wide
22:58:06 <mzero> In the next release of the Platform, it will come with a handy-dandy script for switching between versions of GHC and the Platform
22:58:11 <hunt_> mzero: well i dont know i think i had installed it previously with the platform and it wasnt working out
22:58:11 <mzero> !
22:58:26 <hunt_> mzero: my ~/.cabal was pretty much empty
22:58:31 <mzero> yes
22:58:41 <hunt_> :/ i like ~/.cabal
22:58:42 <mzero> on mac it all goes in ~/Library/Haskell
22:58:52 <hunt_> really?
22:58:54 <mzero> but, if you like, that is just configured by ~/.cabal/config
22:58:56 <bitemyapp> hunt_: if you use what I linked you, it will use ~/.cabal
22:58:58 <mzero> and you can put that how you like
22:59:02 <mzero> the Platform doesn't care
22:59:12 <bitemyapp> hunt_: http://ghcformacosx.github.io/ - I get a lot of people started with Haskell, mzero does not.
22:59:20 <bitemyapp> hunt_: just use the package I linked.
22:59:25 <mzero> BS, bitemyapp
22:59:38 <hunt_> lol why is there a turf war over this?
22:59:42 <mzero> there isn't
23:00:04 <bitemyapp> hunt_: Platform causes problems for new people, mzero refuses to fix it because he doesn't have enough experience getting new people through build errors.
23:00:16 <mzero> ?
23:00:17 <bitemyapp> hunt_: so he thinks there is no problem. Head in sand sorta deal.
23:00:24 <bitemyapp> hunt_: use the package I linked.
23:00:35 <mzero> which problems is it cause
23:00:38 <mzero> we have an issue tracker
23:00:40 <mzero> we have a mailing list
23:00:44 <mzero> I'm all ears
23:01:16 <vanila> bitemyapp, come on :)
23:01:30 <bitemyapp> vanila: I already talked to mzero before.
23:01:38 <bitemyapp> I don't have any patience for people to refuse to fix problems.
23:03:16 <hunt_> bitemyapp: why do i need to add something inside the .app to my path?
23:03:54 <bitemyapp> hunt_: if you run the .app, it should offer to do it for you.
23:03:59 <hunt_> tell me this, mzero & bitemyapp. will either of your solutions allow me to get to my ghc and packages the same way i would on linux, through ~/.cabal/bin or perhaps ~/.ghc/bin
23:04:06 <bitemyapp> hunt_: yes, the .app will!
23:04:13 <bitemyapp> hunt_: I like my setup the same way!
23:04:21 <hunt_> bitemyapp: yea it does, but whats inside the .app that needs to be in my path?
23:04:29 <hunt_> is that where ghc sits?
23:04:32 <bitemyapp> hunt_: yes
23:04:35 <danclien> hunt_: All the binaries are stored in the .app. I don't think it modifies your path for you though.
23:04:47 <mzero> hunt_: yes, but it isn't the default set up in the Mac installer for the Platform
23:05:11 <Fuuzetsu> sure is high tension in here today
23:05:13 <hunt_> mzero: why not btw? why not keep it the same as on linux distros?
23:05:44 <mzero> because apple has a layout system for all language subsystems
23:05:48 <mzero> and we thought we'd follow that
23:06:07 <bitemyapp> and in so doing, make it harder for the people that have dotfiles spanning Linux and Mac
23:06:12 <bitemyapp> forcing them to special case one or the other
23:06:20 <bitemyapp> https://github.com/bitemyapp/dotfiles/
23:06:22 <mzero> there is no forcing, actually
23:06:25 <knappador> bitemyapp:  it's something related to pie flags.  looks like configure.sh is running something that can't link to one of my binaries.
23:06:41 <mzero> the only issue is that Platform writes a default cabal config file... if you don't already have one ....
23:06:44 <bitemyapp> knappador: this is beyond my ken, you might want to find a Haskell user that is also a Gentoo user.
23:06:48 <mzero> and resets the locations to the Apple areas
23:06:54 <bitemyapp> knappador: I use Mac and Ubuntu, not Gentoo - haven't in like a decade.
23:06:57 <mzero> but if you have a .cabal config file, it leaves it alone
23:07:03 <mzero> and your stuff is wher eyou want it
23:07:21 <Fuuzetsu> knappador: there's #gentoo-haskell
23:07:45 <bitemyapp> @karma+ Fuuzetsu
23:07:45 <lambdabot> Fuuzetsu's karma raised to 3.
23:08:13 <mzero> so, I'm not sure there is an issue there - if you have a .cabal/config file already -- it will work on both Linux and Mac OS X
23:09:16 <knappador> i should just switch to a real linux
23:09:49 <vincent99> how would i read from stdin until EOF?
23:10:06 <pepper_chico> ok, my problems resumes on how to pass -fno-warn-type-defaults to ghc-mod check
23:10:22 <pepper_chico> I tried in several ways, none worked
23:10:34 <pepper_chico> always get the warning
23:10:58 <hunt_> im only reinstalling because when i try to install vector it fails horribly
23:11:14 <hunt_> http://lpaste.net/105512
23:11:35 <hunt_> after which it immediately fails with "ExitFailure 1"
23:11:45 <hunt_> this is during the build phase
23:12:47 * hackagebot hspec2 0.3.2 - Alpha version of Hspec 2.0  http://hackage.haskell.org/package/hspec2-0.3.2 (SimonHengel)
23:13:52 <Lutin`> vincent99: You can use getContents
23:14:02 <hunt_> anyone know what ti do?
23:16:29 <hunt_> guys please help me here i cant work on my project without vector
23:17:13 <simon> has anyone here implemented differential equations in haskell? I end up with a *lot* of zip4s and folds and the like.
23:17:22 <enthropy> hunt_: you might disable dynamic libraries
23:17:34 <solirc> hunt_: Pass -v to cabal
23:17:46 <Lutin`> hunt_ What version of GHC?
23:18:06 <hunt_> Lutin`: 7.8.2
23:18:50 <hunt_> solirc: http://lpaste.net/105513
23:19:04 <hunt_> enthropy: are you saying i might have them disabled already or i should try disabling them?
23:19:29 <enthropy> that if you disable them, vector might build
23:20:23 <vanila> simon: I did euler lagrange equations
23:21:21 <hunt_> enthropy: ok, im assuming thats a ~/.cabal/config thing
23:21:32 <Lutin`> hunt_: Can you paste your current cabal config?
23:21:33 <peddie> simon: I often use the ODE integrators from GSL in the 'hmatrix' package
23:22:21 <mzero> hunt_: are you buliding vector from source? or cabal install-ing it?
23:22:37 <mzero> and are you building sandboxed?
23:23:16 <mzero> also - please paste the output of "ghc-pkg describe primitive"
23:23:18 <hunt_> Lutin`: http://lpaste.net/105514
23:23:31 <hunt_> mzero: cabal install, not sandboxed, kkgetting ghc-pkg
23:23:44 <enthropy> > let h = 0.1 in unfoldr (\ (t,x) -> Just (x, (t+h, x+x*h)) ) (0, 1)
23:23:46 <lambdabot>  [1.0,1.1,1.2100000000000002,1.3310000000000002,1.4641000000000002,1.61051,1....
23:24:14 <mzero> .cabal/config looks fine
23:24:20 <mzero> it is the Platform std. version for OS X
23:24:24 <hunt_> mzero: http://lpaste.net/105515
23:24:54 <bitemyapp> hunt_: why isn't the install sandboxed?
23:25:34 <enthropy> simon: zip4 sounds unnecessary
23:25:36 <hunt_> bitemyapp: not totally sure, i think last time i tried sandboxing it waskind of painful and this stuff seems basic enough not to require a sandbox
23:26:15 <hunt_> bitemyapp: the things im installing rn are going to be reused by me a fair bit i think
23:26:26 <mzero> hunt_: that looks good too.... now if you look in /Users/elizabeth/Library/Haskell/ghc-7.8.2/lib/primitive-0.5.3.0/lib  ... you should see libHSprimitive-0.5.3.0.dylib
23:27:08 <Lutin`> mzero: Looks like some other people have had this problem on linux with GHC 7.8.2 as well
23:27:21 <hunt_> i dont see .dylib, i do see .o and .a
23:27:23 <hunt_> mzero:
23:27:38 <hunt_> mzero: and _p.a
23:27:49 * hackagebot hspec2 0.3.3 - Alpha version of Hspec 2.0  http://hackage.haskell.org/package/hspec2-0.3.3 (SimonHengel)
23:27:56 <hunt_> also my bad the .o one isnt libHS... its just HS...
23:28:02 <mzero> yes - GHC 7.8.2 on mac hasn't had all the kinks worked out!
23:29:16 <mzero> curious - so why isn't it building .dylibs? 7.8.2's ghci & TH use .dylibs now.....
23:29:22 <hunt_> so seing as i dont have the .dylib, what should i do? is there a flag to install for .dylib
23:29:54 <mzero> well, it happens when the package is built
23:30:13 <hunt_> i reinstalled primitive i think
23:30:14 <Lutin`> you could try rebuilding the package but I don't think that would fix things
23:30:31 <hunt_> oh no this sounds like theres not going to be a solution
23:31:56 <bitemyapp> hunt_: tried with a fresh cabal .config?
23:32:01 <bitemyapp> hunt_: and from inside a sandbox?
23:32:14 <bitemyapp> hunt_: I basically want you to try to do what you wanted to do, but as if you'd never installed Platform and done the install in a sandbox.
23:32:46 <hunt_> bitemyapp: im going to have to reinstall everything for that yea?
23:33:04 <hunt_> bitemyapp: how do i get a fresh config? can i just rename my old config?
23:33:16 <bitemyapp> hunt_: try that.
23:34:30 <hunt_> bitemyapp: kk will report back soon
23:37:36 <knappador> whoooooo !    gcc-config and there is a gcc-nopie
23:37:36 <Tene> I'm personally hoping that the bit over the arcane workbench here enables autocrafting, althoughg I highly doubt it: http://i.imgur.com/nQgVQNs.png
23:37:43 <Tene> Man, wrong channel.
23:37:45 <knappador> and just reload the . environment
23:37:52 <knappador> that wasnt' stupid and painful at all
23:37:55 <knappador> i'm switching
23:38:07 <knappador> gotta get back to my good linux
23:38:13 <taktoa> Tene: thaumcraft?
23:38:22 <Tene> taktoa: Yeah.
23:42:03 <hunt_> bitemyapp: it worked in the snadbox with fresh config, trying it elsewhere
23:44:15 <bitemyapp> hunt_: awesome!
23:44:52 <knappador> building ghc takes forever.  very glad.
23:45:27 <knappador> i was just going to set up a damned scotty server.  didn't know my linux distro is so needy.
23:49:22 <zRecursive> `cabal update` => cabal-install: Codec.Compression.Zlib: premature end of compressed stream
23:49:58 <Cale> Try again? That sounds like a download was cut off somehow
23:50:16 <zRecursive> Downloading the latest package list from hackage.haskell.org ...
23:50:30 <bitemyapp> knappador: using less popular distros often means pain like this :(
23:50:39 <bitemyapp> knappador: Arch Linux supposedly has good GHC and Cabal packages.
23:50:41 <gamegoblin> When haskell ints overflow they go to 0? Doing 2^3^4 gives 0
23:50:43 <Cale> I was just successfully able to cabal update
23:50:48 <gamegoblin> > (2 :: Int)^3^4
23:50:49 <lambdabot>  0
23:50:55 <Cale> gamegoblin: It's a power of two
23:51:20 <gamegoblin> ooooohâ€¦. yes
23:51:37 <gamegoblin> > (3::Int)^4^5
23:51:39 <lambdabot>  -7087363323575676927
23:51:41 <gamegoblin> Gotcha
23:51:46 <hunt_> bitemyapp: i unregistered primitive and it worked
23:51:52 <hunt_> bitemyapp: with the new config
23:51:54 <knappador> bitemyapp:   my thoughts exactly.  i've used arch on three or four machines now.  always like it.
23:51:58 <hunt_> bitemyapp: it mightve worked with the old too but i dont know
23:52:07 <Cale> (This isn't Haskell-specific behaviour at all, it's just how machine arithmetic works)
23:52:10 <knappador> docs are impeccable, prolific, and awesom
23:52:28 <bitemyapp> hunt_: excellent.
23:52:34 <bitemyapp> hunt_: I'm just glad your problems are swept away for now.
23:53:46 <triliyn> Wait, why does 2^3^4 overflow anyway? Shouldn't it just be 2^12, which is much smaller than maxBound?
23:54:10 <lfairy> triliyn: exponentiation is right-associative
23:54:19 <lfairy> 2^3^4 == 2^(3^4)
23:54:19 <triliyn> oh, okay
23:54:44 <lfairy> The More You Know
23:54:45 <triliyn> I've normally seen it left-associative because right-association is usually way too big for anything useful
23:54:49 <triliyn> But that makes sense, thanks
23:56:33 <Cale> Right associative is the usual convention in mathematics. If you wanted (a^b)^c, you could typically write a^(b*c) anyway
23:57:03 <Cale> (which in 2D notation wouldn't require the parens)
