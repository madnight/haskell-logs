00:00:08 <edwardk> given that you can define the put we use normally by   going from s_i -> (c, a_i)    replacing a_i with a_j   and going back from (c, a_j)    to s_j
00:00:13 <ski> (yes, just not wanting to get too much in the way of the lens 'splanation)
00:00:38 * ski . o O ( "lensplanation" ? )
00:00:45 <jle`> i think i vaguely remember some statement from catsters about something where this sort of "best stuff"...some sort of 'partial ordering' on possible candidates to reveal the 'best' one...is a critical/commonly used part of category theory
00:01:27 <jle`> edwardk: gotcha
00:01:35 <edwardk> this definition works for the category of haskell data types, because in a set-like category the notion of a lens can factor through the selection of a 'constant complement' (notice the choice of c didn't depend on the index i at all!)
00:01:57 <edwardk> but there are categories you can build lenses over where the notion of a lens _does not_ induce a constant complement.
00:02:10 <edwardk> so its a useful intuition, but its a limited one
00:02:52 <jle`> mhm
00:02:57 <cstanfill> "Best", "most general" "least constained" and "essentially unique" are all categorical ideas
00:03:02 <edwardk> but, we can talk about how    Lens' s a   is    exists c. s <-> a * c       then a prism is exists c. s <-> a + c
00:03:13 <ski> edwardk : is `i' quantified outside or inside the `exists' ?
00:03:28 <edwardk> inside
00:03:42 <edwardk> c is the same for all i
00:04:27 <jle`> ok
00:04:39 <jle`> i think i can sort of understand this on the mathematical level
00:04:56 <cstanfill> edwardk: what's the categorical construction of a lens look like?
00:04:58 <jle`> for Either a b, the _Left lens sort of gives you the Left a part or the "other" Right b part
00:05:03 <ski> jle` : yes, the "best" thing here is common in CT
00:05:29 <jle`> okay
00:05:45 <edwardk> jle`: yeah. in constant complement terms 'c' would be 'all the other cases'
00:05:58 <jle`> so i think my problem here was thinking that every structure that is Lensable is also a structure that is Prismable in the same way
00:06:23 <edwardk> cstanfill: mike johnson and bob rosebrugh have some nice papers exploring them more theoretically, but if you want a deep look down the rabbit hole:
00:06:37 <jle`> but that's like monad and comonad; not all monads are comonads and vice versa
00:06:51 <edwardk> https://github.com/ekmett/hask/blob/master/src/Hask.hs builds up a notion of a lens and prism more "correctly"
00:06:56 <jle`> _Left is the dual of fst in that it's the co-lens of the co-object
00:07:03 <ski> a very simple example of it is : given two natural numbers `m' and `n', `gcd(m,n)' (the greatest common divisor of `m' and `n') is the greatest natural number `d' that divides both `m' and `n' -- here "greatest" corresponds to "best" above
00:07:22 <edwardk> _Left and _1 have the same kind of relationship that Left and fst do
00:07:37 <jle`> there as strong a semantic analogy as i wa slooking for i guess
00:07:50 <jle`> i was trying to think about how any Lens can be a Prism and how any Prism can be a Lens
00:08:03 <jle`> but that's silly on hindsight
00:08:12 <edwardk> there are lens-likes that are both
00:08:15 <edwardk> we call them isos
00:08:16 <edwardk> =)
00:08:20 <jle`> :o
00:08:25 <jle`> i was just going to ask where isos fit into the picture
00:08:26 <ski> and "greatest" here should be interpreted wrt the divisibility ordering, so `1' is the least natural number here (it divides everything), and `0' is the greatest (everything divides zero), and `6' and `10' are uncomparable since neither of them divides the other
00:08:27 <jle`> heh.
00:08:34 <edwardk> an Iso in the lens package can be used as a Lens _or_ as a Prism.
00:08:38 <edwardk> they are simultaneously both
00:08:42 <edwardk> s <-> a
00:08:42 <ski> (which is incidentally why `gcd 0 0' should be `0')
00:08:49 <cstanfill> edwardk: thanks
00:08:51 <ski> > gcd 0 0
00:08:53 <lambdabot>  0
00:09:07 <jle`> so Iso gives you all four things
00:09:13 <jle`> an s -> a
00:09:14 <edwardk> which is both s <-> (c, a)   for c = ()        and s <-> c' + a   for c' = Void
00:09:22 <jle`> an (s, b) -> t
00:09:33 <jle`> an a -> t
00:09:44 <jle`> and an s -> Either b t
00:09:47 <jle`> um
00:09:50 <jle`> t -> Either s b ?
00:09:57 <edwardk> b -> t,    s -> Either t a
00:10:02 <jle`> ah
00:10:25 <edwardk> :t view (iso (+1) (subtract 1))
00:10:26 <lambdabot> (MonadReader t m, Num t) => m t
00:10:39 <edwardk> :t view (iso (+1) (subtract 1)) 1
00:10:40 <lambdabot> Num a => a
00:10:40 <jle`> so where does (+1) and (subtract 1) fit into that
00:10:46 <edwardk> :t preview (iso (+1) (subtract 1)) 1
00:10:48 <lambdabot> Num a => Maybe a
00:11:04 <edwardk> :t set (iso (+1) (subtract 1)) 4 1
00:11:05 <lambdabot> Num t => t
00:11:05 <Axman6> :t iso
00:11:06 <lambdabot> (Profunctor p, Functor f) => (s -> a) -> (b -> t) -> p a (f b) -> p s (f t)
00:11:15 <jle`> so in, say, iso show read
00:11:30 <pjdelport> Does Data.Sequence not have versions of mapAccumL/R ?
00:11:36 <edwardk> iso show read is making all those things from that pair of functions
00:11:50 <jle`> so the getter is show
00:12:01 <jle`> the setter is...
00:12:24 * ski would probably prefer that `iso' to be called `promiseIso' or something like that ..
00:12:43 <edwardk> ski: we long ago established why we don't let you name combinators ;)
00:12:47 <jle`> > set (iso (+1) (subtract 1)) 4 1
00:12:48 <lambdabot>  3
00:13:04 <jle`> > set (iso (+1) (subtract 1)) 4 10
00:13:07 <lambdabot>  3
00:13:15 <ski> edwardk : the point would be to remind the use of the proof obligation ;)
00:13:28 <ski> s/the use/the user/
00:13:33 <jle`> what is this do
00:13:53 <edwardk> here we're saying c is trivial. this lens 'has no memory'
00:13:54 <jle`> > map (set (iso (+1) (subtract 1)) 4) [0..10]
00:13:56 <lambdabot>  [3,3,3,3,3,3,3,3,3,3,3]
00:13:58 <jle`> ah
00:14:00 <jle`> there is onthing to set
00:14:10 <edwardk> whatever you set it to it has to set it back based just on your new input
00:14:11 <edwardk> :t iso
00:14:13 <lambdabot> (Profunctor p, Functor f) => (s -> a) -> (b -> t) -> p a (f b) -> p s (f t)
00:14:38 <jle`> are all isos memoryless?
00:14:45 <edwardk> you give me (s -> a)   (b -> t)      and i need tog ive you s -> b -> t   how do i do it? by dropping your s on the floor and kicking it a few times
00:14:48 <edwardk> yes
00:15:16 <edwardk> you can use 'over' on an iso just fine though
00:15:22 <edwardk> you just have all the structure while you do it
00:15:37 <edwardk> > over (iso (+1) (subtract 1) (*2) 5
00:15:38 <lambdabot>  <hint>:1:35:
00:15:39 <lambdabot>      parse error (possibly incorrect indentation or mismatched brackets)
00:15:41 <edwardk> > over (iso (+1) (subtract 1)) (*2) 5
00:15:43 <lambdabot>  11
00:16:01 <edwardk> take 5, add 1, double it, subtract 1
00:16:17 <edwardk> :t Numeric.Lens.adding
00:16:18 <lambdabot> (Profunctor p, Num a, Functor f) => a -> p a (f a) -> p a (f a)
00:16:32 <edwardk> > 5 & Numeric.Lens.adding 1 *~ 2
00:16:34 <lambdabot>  11
00:16:43 <edwardk> @let import Numeric.Lens
00:16:47 <lambdabot>  Defined.
00:16:48 <edwardk> > 5 & adding 1 *~ 2
00:16:50 <lambdabot>  11
00:17:01 <edwardk> > 5 ^.adding 1
00:17:03 <lambdabot>  6
00:17:18 <edwardk> > review (adding 1) 6
00:17:20 <lambdabot>  5
00:17:31 <ski> @type mapAccumL
00:17:32 <lambdabot> (acc -> x -> (acc, y)) -> acc -> [x] -> (acc, [y])
00:17:33 <ski> @type (runState .) . (Data.Traversable.mapM :: Monad m => (a -> m b) -> (Seq.Seq a -> m (Seq.Seq b))) . (state .)
00:17:34 <lambdabot> (a -> s -> (b, s)) -> Seq.Seq a -> s -> (Seq.Seq b, s)
00:17:43 <ski> pjdelport : `s' corresponds to `acc'
00:18:46 <edwardk> ski: did you see the hask thing i linked above?
00:18:46 <jle`> so over (iso (+1) (subtract 1)) is an "fmap" where to "get in", you apply (+1)....feed that result to the function...then apply (subtract 1) to "get out"
00:18:58 <edwardk> yeah
00:18:59 <ski> edwardk : i didn't look at it yet
00:19:19 <pjdelport> ski: Good heavens.
00:19:22 <jle`> i don't think i quite understand the behavior of set though
00:19:31 <jle`> why is it using subtract 1 only?
00:19:35 <jle`> oh
00:19:39 <edwardk> lets work through set as over
00:19:40 <jle`> hm
00:19:42 <jle`> ok
00:19:49 <edwardk> set l b = over l (const b)
00:20:07 <jle`> no way
00:20:15 <jle`> ...that makes sense
00:20:27 <edwardk> > over _2 (const "whatever") (1,4)
00:20:29 <lambdabot>  (1,"whatever")
00:20:45 <edwardk> > over _Left (+1) (Left 4)
00:20:47 <lambdabot>  Left 5
00:20:55 <edwardk> > over _Left (+1) (Right "not a number")
00:20:57 <lambdabot>  Right "not a number"
00:21:34 <edwardk> > set (traverse._Left) () [Left 4, Left 5, Right "whoa", Left 6]
00:21:36 <lambdabot>  [Left (),Left (),Right "whoa",Left ()]
00:22:11 <jle`> so iso gives us the over
00:22:54 <jle`> over (iso f g) h = g . h . f
00:22:54 <edwardk> iso gives you an Iso, which is a legal Prism and a legal Lens,   every Lens (or Prism) is a legal Traversal, every Traversal is a legal Setter. Setter is what you need for 'over'
00:23:18 <edwardk> yeah over is a form of convolution
00:23:24 <edwardk> (for isos)
00:23:47 <edwardk> :t setting
00:23:49 <lambdabot> (Conjoined p, Settable f) => ((a -> b) -> s -> t) -> p a (f b) -> p s (f t)
00:23:51 <jle`> so set (iso f g) = ..?
00:24:02 <jle`> (nevermind that ..? is a valid operator)
00:24:31 <edwardk> set (iso f g) b = g . const b . f = g . const b
00:24:56 <jle`> okay so h is replaced with const b
00:25:13 <ski> > (`runState` "") (T.mapM (\n -> state (\s -> (n^2,s ++ ";" ++ show n))) (Seq.fromList [0,1,2,3]))  -- pjdelport
00:25:15 <lambdabot>  (fromList [0,1,4,9],";0;1;2;3")
00:26:51 <jle`> edwardk: thanks :) i really must retire now, but i appreciate this
00:26:58 <jle`> you do good work
00:27:00 <jle`> edwardk++
00:27:05 <edwardk> np, happy to help
00:28:02 <ski> edwardk : any particular thing in it you had in mind ?
00:28:41 <edwardk> ski: few things. notably the abuse of reflection like hacks to make the Constraint kind cartesian closed, and the fact that you can uses lenses to manipulate constraints
00:29:36 <edwardk> because the category of Constraint types is cartesian, and you can walk down into the structure of the products using Strong, etc.
00:38:43 * ski ponders `instance (Functor p, Functor1 p) => Bifunctor p'
00:40:45 <edwardk> only works because we use parametricity in there as a _very_ strong form of naturality
00:41:27 <edwardk> notably naturality in each argument in isolation can be show to induce naturality in the pair of arguments
00:41:31 <ski> yes, i figured it would only work in special circumstances
00:42:02 <edwardk> i am really happy with the use of limits and composition to get Functor1
00:42:13 <edwardk> sjoerd_visscher knocked that one out of the park =)
00:42:28 <edwardk> Functor1 = Limit (Up p Functor)
00:42:38 <edwardk> er
00:42:41 <edwardk> Functor1 p = Limit (Up p Functor)
00:44:37 <ski> hm, this is quite long :)
00:51:09 <edwardk> ski: got excited and just started coding at one end and had lots to say ;)
00:51:38 <edwardk> it is unfortunately quite incestuous so there isn't much i can easily split out =(
00:51:55 <edwardk> i can move some of the Via machinery out to another module, Foldable/Traversable
00:53:25 <edwardk> i need limits to talk about Functor1, Functor1 for Profunctor, Profunctor for Iso, Iso to talk about adjunctions, the adjunction for Const and Limit, etc.
00:53:50 <edwardk> and also for the notion of a strong profunctor, etc.
00:54:07 <edwardk> because i need cartesian
00:55:58 <haasn> How would that kind-check?
00:58:27 <edwardk> haasn: which part?
00:58:37 <edwardk> Functor1?
00:59:24 <edwardk> type family Lim :: (i -> j) -> j
00:59:52 <edwardk> there is an instance for type family Lim = (LimC :: (i -> Constraint) -> Constraint)
01:00:15 <edwardk> type family Up :: (i -> j) -> (j -> k) -> i -> k
01:00:54 <edwardk> class g (f a) => UpC f g a; instance g (f a) => UpC f g a
01:01:15 <edwardk> class Functor (f :: x -> y)
01:01:31 <edwardk> Up is flipped functor composition
01:01:58 <haasn> edwardk: (Functor p, Bifunctor p)
01:02:19 <edwardk> Functor1 p   is functoriality in the second argument
01:02:34 <edwardk> with the way that code is written you can work with instance Functor Either  -- note the lack of 'a'
01:02:52 <haasn> Oh, this is not the prelude Functor
01:02:59 <edwardk> then     fmap :: (a -> b) -> Nat (f a) (f b)
01:03:29 <edwardk> haasn: everything in here is rather.. generalized
01:03:40 <mr-> And what is "Limit (Up p Functor)"? The limit of pre/post composition with p ?
01:03:54 <haasn> Where is functor1 defined:
01:03:56 <haasn> ?
01:04:40 <edwardk> fairly late. 2000 lines in https://github.com/ekmett/hask/blob/master/src/Hask.hs#L2146
01:04:53 <haasn> ah
01:05:39 <cow_2001> is there a function for applying the function `f` `n` number of times like: f . f . f . ... f $ x
01:05:57 <ion> iterate f x !! n
01:06:00 <cow_2001> huh
01:06:06 <cow_2001> thanks!
01:06:19 <haasn> > foldr id x $ replicate 10 f
01:06:20 <lambdabot>  Ambiguous occurrence ‘x’
01:06:20 <lambdabot>  It could refer to either ‘L.x’, defined at L.hs:164:1
01:06:20 <lambdabot>                        or ‘Debug.SimpleReflect.Vars.x’,
01:06:20 <lambdabot>                           imported from ‘Debug.SimpleReflect’ at L.hs:112:1-26
01:06:20 <lambdabot>                           (and originally defined in ‘simple-reflect-0.3.2:De...
01:06:28 <haasn> @undefine
01:06:28 <lambdabot> Undefined.
01:06:30 <haasn> > foldr id x $ replicate 10 f
01:06:32 <lambdabot>  f (f (f (f (f (f (f (f (f (f x)))))))))
01:07:12 <cow_2001> O_o
01:07:13 <mayski> jesus lawd almighty
01:10:26 <batz> Hey there. Isn't it possible to create an data type composed of an own Integer Range? "data OwnInt = 1 | 2 | 3" is not working for me
01:11:49 <haasn> No, that's not possible in Haskell
01:12:09 <haasn> (In particular because 1, 2 and 3 are not valid constructor names, they're literals which are a bit special)
01:12:18 <Walther> ...huh
01:12:22 <batz> Ok, thanks. Is there any other way to define an own (countable) domain?
01:12:28 <haasn> If you want to create a data type which is range limited, you could use an abstract data type and only export functions to construct it that check the range first
01:13:17 <haasn> like module Digits (Digit, mkDigit) where newtype Digit = Digit Int; mkDigit :: Int -> Maybe Digit; mkDigit n | n `elem` [0..9] = Just (Digit n) | otherwise = Nothing
01:13:55 <batz> Ah, ok, I will try this, thanks. But I see, there is a lot of stuff to learn beforehand (Maybe/Just/...) :-)
01:14:15 <ski> @type inRange
01:14:16 <lambdabot> Ix a => (a, a) -> a -> Bool
01:14:20 <simon> data Maybe a = Just a | Nothing -- that's it.
01:14:21 <lieven_> Data.Ix could be useful too
01:14:38 <haasn> Ix++
01:14:51 <Pythonfant> I'm looking for an algorithm to find the maximum number of disconnected nodes in a dag, more precisely I mean nodes so that when I mark them and then spread marks from their edges no one of the starting nodes will be marked again. (sry bit offtopic)
01:15:00 <haasn> One of my favorite Ix functions is range
01:15:03 <batz> Data.Ix looks promising, thank you!
01:15:06 <haasn> > range (0,10)
01:15:08 <lambdabot>  [0,1,2,3,4,5,6,7,8,9,10]
01:15:27 <haasn> > range ((0,0),(3,3))
01:15:28 <lambdabot>  [(0,0),(0,1),(0,2),(0,3),(1,0),(1,1),(1,2),(1,3),(2,0),(2,1),(2,2),(2,3),(3,...
01:15:37 <haasn> > [(0,0)..(3,3)]
01:15:38 <lambdabot>  No instance for (GHC.Show.Show t1)
01:15:38 <lambdabot>    arising from a use of ‘M73558254835683705181549.show_M73558254835683705181...
01:15:39 <lambdabot>  The type variable ‘t1’ is ambiguous
01:15:39 <lambdabot>  Note: there are several potential instances:
01:15:39 <lambdabot>    instance [safe] GHC.Show.Show
01:15:48 <Axman6> damnit haasn,I had typed literally exactly that example :P
01:16:20 <ski> i suppose `Ix' ranges could be considered (closed) intervals on partial orders
01:16:21 <simon> > [(0,0),(2,2)] :: [(Int,Int)]
01:16:22 <lambdabot>  [(0,0),(2,2)]
01:16:35 <simon> > [(0,0)..(2,2)] :: [(Int,Int)]
01:16:36 <lambdabot>  No instance for (GHC.Enum.Enum (GHC.Types.Int, GHC.Types.Int))
01:16:36 <lambdabot>    arising from the arithmetic sequence ‘(0, 0) .. (2, 2)’
01:17:11 <ski> (obviously not counting the instances based on `Float' ior `Double')
01:17:22 <haasn> > range (0,10) :: [Double]
01:17:23 <lambdabot>  No instance for (GHC.Arr.Ix GHC.Types.Double)
01:17:23 <lambdabot>    arising from a use of ‘GHC.Arr.range’
01:17:54 <ski> hm, right. for a moment i was apparently thinking about `Enum'
01:17:55 <ski> ty
01:18:07 <haasn> > map (inRange ((0,0),(10,10)))  [ (3,5), (11,7), (-5,5) ]
01:18:09 <lambdabot>  [True,False,False]
01:18:43 <haasn> Now if only it didn't have those ugly tuples everywhere :(
01:19:16 <haasn> > rangeSize ((0,0),(10,10))
01:19:17 <lambdabot>  121
01:19:26 <haasn> Oh, 11*11
01:19:47 <haasn> Much fun can be had with Ix
01:20:37 <ski> i wonder whether there's any nice partial order theoretic way to talk about "ascending paths"
01:20:46 <haasn> edwardk: I see how it kind checks now, that's pretty cool. You don't care about the left argument in Functor because it's all kind polymorphic
01:20:59 <edwardk> x`yeah
01:21:15 <haasn> however, now I don't understand Profunctor. It's given as Contravariant p, Functor1 p
01:21:18 <haasn> Shouldn't it be the other way around?
01:21:36 <edwardk> there are varying schools of thought on profunctor
01:21:45 <haasn> So it's intentionally the opposite of profunctors' Profunctor?
01:21:51 <edwardk> no
01:22:04 <edwardk> C^op X D -> E is what we have here
01:22:08 <edwardk> same as profunctors
01:22:17 <edwardk> Functor1 counts from the _start_
01:22:17 <ski> in `(->) a b', `a' occurs contravariantly and `b' covariantly
01:22:42 <ski> `Contravariant f' talks about an `a' in `f a'
01:23:00 <ski> `Functor1 f' talks about a `b' in `f a b', for any `a'
01:23:03 <ninja_code> I am familiar with monads. wtf does liftIO do? (context: I'm using Haste to compile Haskell to Javascript, I need to convert IO a into CIO a), where CIO stands for concurrent.
01:23:11 <haasn> Oh!
01:23:35 <edwardk> now, CT types like to go C X D^op -> E for various reasons to agree with yoneda and make the connection to presheaves more obvious, etc.
01:23:41 <haasn> I had looked at it the wrong way around; in Contra f ~ (b ~> a) -> f a ~> f b the “hidden” extra parameter is hidden by ~>; so it's like f a x ~> f b x
01:23:49 <edwardk> yeah
01:23:53 <haasn> It's not hidden by ‘f’, like g x a ~> g x b
01:23:55 <ski> ninja_code : are you familiar with monad transformers ? the class `MonadTrans' and `lift' ?
01:24:00 <edwardk> you have to runNat to lift it out
01:24:05 <ninja_code> no
01:24:08 <ninja_code> I am not familiar with monad transformers.
01:24:09 <haasn> Okay, now I understand this a bit more
01:24:13 <edwardk> hence why we have first/lmap for convenience
01:24:19 <ninja_code> I am a fan of Optimus Prime though. Does that help?
01:25:00 <lfairy> it usually doesn't, but you can pretend it does if it makes you feel better
01:25:16 <lfairy> abstractions are like that
01:25:25 <haasn> Is this the part where somebody writes a monad tutorial based on Transformers?
01:25:51 <ski> ninja_code : well, `liftIO' "lifts" an `IO'-action into any other monad capable of representing I/O (and usually also more stuff), in this case your `CIO' monad is probably one such
01:26:02 <haasn> (Maybe it already exists. Conjecture: If it exists, somebody has written a monad tutorial based on it)
01:26:18 <ski> ninja_code : so if you have `getLine :: IO String', then `liftIO getLine :: CIO String' (if you want to)
01:26:32 <ninja_code> so I'm reading the source at : https://github.com/valderman/haste-compiler/blob/dec53909434470ff6faa86ac7b05caa2cd13b22a/libraries/haste-lib/src/Haste/Concurrent/Monad.hs
01:26:34 <ninja_code> ski: ^
01:26:39 <ninja_code> what do I need to import to get liftIO ?
01:26:50 <haasn> ninja_code: Does this help? http://www.haskell.org/haskellwiki/Typeclassopedia#Monad_transformers
01:26:50 <ski> ninja_code : so while you can't use `getLine' in `CIO', you *can* use `liftIO getLine'
01:27:08 <ninja_code> ski: let me play with this
01:27:08 <edwardk> haasn: the nice thing is this way indexed monads and normal monads can share the same combinators
01:27:12 <edwardk> return is return is return =)
01:27:14 <ninja_code> haasn: let me exhaust ski's suggestions first
01:27:50 <haasn> edwardk: and fmap = rmap = second helps too
01:27:55 <ski> @index liftIO
01:27:55 <lambdabot> Control.Monad.Trans, Control.Monad.Reader, Control.Monad.Writer, Control.Monad.State, Control.Monad.RWS, Control.Monad.Cont, Control.Monad.Error, Control.Monad.List
01:28:07 <ski> ninja_code : `liftIO' is in `Control.Monad.Trans'
01:28:12 <edwardk> yeah
01:28:22 <edwardk> greatly reduces the number of instances i write!
01:28:24 <edwardk> also
01:28:33 <edwardk> the definitions of those are completely structurally determined
01:28:35 <haasn> edwardk: I take it I'm looking at base 4.8's source code here?
01:28:39 <edwardk> so they can be automatically generated eventually
01:29:11 <ninja_code> ski: it compiles (assuming it works) now, thanks!
01:29:21 <edwardk> so you can given a k argument data type automatically generate its functors/contravariant instances
01:29:28 <edwardk> just a small matter of coding
01:29:36 <ski> ninja_code : "it" being that Koen Claessen code ?
01:29:51 <ninja_code> 'it' being that code I'm writing on top of Haste
01:30:28 <haasn> (Where do these crazy Semigroup/Monoid definitions come from?)
01:30:40 <haasn> Oh, 1584
01:32:36 <haasn> “herpOp, derpOp” I take it this is what happens when edwardk finally exhausts his own namespace
01:33:12 <frerich> haha
01:33:15 <edwardk> haasn: i don't like that approach, it was a statement of annoyance at ghc when i first used it
01:33:35 <pjdelport> > let recur n = appEndo . mconcat . replicate n . Endo in recur 10 f x
01:33:37 <lambdabot>  f (f (f (f (f (f (f (f (f (f x)))))))))
01:33:38 <edwardk> you'll note that whole section is commented out
01:34:05 <pjdelport> cow_2001: Another silly way to do that -^
01:34:20 <edwardk> > ala Endo foldMap (replicate 10 f) x
01:34:21 <lambdabot>  f (f (f (f (f (f (f (f (f (f x)))))))))
01:35:01 <pjdelport> Oh, neat.
01:35:51 <cow_2001> pjdelport: you're all insane :p
01:37:09 <Welkin> :t ala
01:37:10 <lambdabot> (Rewrapped t s, Rewrapped s t) => (Unwrapped s -> s) -> ((Unwrapped t -> t) -> e -> s) -> e -> Unwrapped s
01:37:39 <lieven_> what's the meaning of the name 'ala'?
01:38:04 <Welkin> "in the style or manner of"
01:38:23 <ion> I would feel better about “iterate f x !! 10” if Prelude had “iterate :: … -> InfiniteList a” and “(!!) :: InfiniteList a -> …”
01:38:58 <haasn> edwardk: Oh, I only just saw the = unsafeCoerce
01:39:00 <haasn> Yikes
01:39:14 <edwardk> > x^.partsOf (iterated f).ix 10
01:39:15 <lambdabot>  f (f (f (f (f (f (f (f (f (f x)))))))))
01:39:32 <ion> edwardk: heh
01:39:54 <haasn> :t ix
01:39:55 <lambdabot> (Ixed m, Applicative f) => Index m -> (IxValue m -> f (IxValue m)) -> m -> f m
01:40:06 <haasn> How come you can read that using (^.)?
01:40:28 <haasn> :t partsOf (iterated f).ix 10
01:40:29 <lambdabot> (FromExpr t, Contravariant f, Applicative f, Show t) => (t -> f t) -> t -> f t
01:40:35 <edwardk> x ^. l = getConst (l Const x)
01:41:16 <edwardk> that is passing Const for that argument. feeding it 'x' and getting back a Const, it unwraps
01:41:25 <haasn> > 0 ^. partsOf (iterated succ).ix 10
01:41:26 <lambdabot>  No instance for (GHC.Show.Show a0)
01:41:26 <lambdabot>    arising from a use of ‘M23523172175995934362211.show_M23523172175995934362...
01:41:26 <lambdabot>  The type variable ‘a0’ is ambiguous
01:41:26 <lambdabot>  Note: there are several potential instances:
01:41:26 <lambdabot>    instance [safe] GHC.Show.Show
01:41:46 <haasn> > 0 ^? partsOf (iterated succ).ix 10
01:41:48 <lambdabot>  Just 10
01:41:49 <haasn> Thought so
01:42:05 <haasn> > mempty :: Expr
01:42:06 <edwardk> oh there it abuses mempty
01:42:06 <lambdabot>  mempty
01:42:30 <edwardk> > x^?partsOf (iterated f).ix 10
01:42:32 <lambdabot>  Just (f (f (f (f (f (f (f (f (f (f x))))))))))
01:42:45 <edwardk> > x^?taking 4 (partsOf (iterated f)).ix 10
01:42:47 <lambdabot>  Just (f (f (f (f (f (f (f (f (f (f x))))))))))
01:43:01 <edwardk> oh 4 parts =)
01:43:02 <haasn> > x ^? iterated f.Lens.index 10
01:43:03 <lambdabot>  Couldn't match type ‘Control.Lens.Internal.Indexed.Indexed
01:43:03 <lambdabot>                         i0 a (Control.Applicative.Const (Data.Monoid.First a)...
01:43:03 <lambdabot>                with ‘Debug.SimpleReflect.Expr.Expr
01:43:03 <lambdabot>                      -> Control.Applicative.Const
01:43:03 <lambdabot>                           (Data.Monoid.First a) Debug.SimpleReflect.Expr.Expr’
01:43:10 <edwardk> > x^?partsOf (taking 4 (iterated f)).ix 10
01:43:11 <lambdabot>  Nothing
01:43:18 <haasn> Oh, iterated isn't indexed
01:43:23 <edwardk> sadly
01:43:32 <edwardk> you can use 'indexed (iterated f)'
01:43:37 <haasn> Yeah, and that one works
01:43:45 <edwardk> but then you have a hard time answering index with that, because its infinite
01:43:58 <edwardk> so it never knows when to stop
01:44:08 * edwardk heads to sleep.
01:44:34 <taruti> Are there any pretty and usable frameworks for ghcjs for dynamic web pages/applications?
01:48:11 <simon> I'll try here... assuming you have e.g. \s -> (x,s') >>= \s' -> (y, s'') >>= \s'' -> (z, s'''), it is conceivable that z can be resolved through term rewriting without a complete reduction of e.g. s''', right?
01:57:09 <ninja_code> haskell is badass
01:57:12 <ninja_code> every line of code I write is like a puzzle
01:57:20 <ninja_code> it's like reverse jynga
01:59:24 <ion> If you write code that is like a puzzle, you might be doing it wrong. :-P
02:01:01 <simon> ion, I wouldn't offend a ninja.
02:02:46 <benj_> writing haskell is like moving from shoving together lumps of play-doh, to doing a jigsaw puzzle
02:08:26 <tdammers> mmmmh, just found a nice yet easy way to do html form binding
02:08:28 <tdammers> yum
02:09:09 <tdammers> class ToFormData a where toFormDict :: a => [(Text, Text)]
02:09:34 <tdammers> bindForm :: ToFormData a => a -> View -> View
02:09:44 <tdammers> where View is a template
02:09:59 <ski> s/:: a =>/:: a ->/ ?
02:10:22 <tdammers> yeah
02:10:46 <tdammers> so then inside the template, I just say textInput "username" "Username:"
02:11:08 <tdammers> and it pulls the value from the Reader part of View, which is filled in bindForm
02:11:37 <tdammers> bindForm user $ do { textInput "username" "Username:" }
02:11:56 <tdammers> it's kind of stringly-typed, but hey, it's the web :P
02:28:41 <CindyLinz> This is also true for cabal install lens... XD # http://oisyn.nl/compiling.png
02:33:07 <t7> lens is haskells boost
02:33:12 <t7> brb 2 hours, compiling
02:33:16 <cheese_> lol
02:38:43 <tdammers> t7: try yesod some time
02:38:59 <tdammers> 1. :make<CR>
02:39:03 <tdammers> 2. order pizza
02:39:09 <tdammers> 3. order more pizza
02:39:15 <tdammers> 4. go home
02:39:20 <tdammers> 5. come back in the morning
02:39:22 <tdammers> 6. coffee
02:39:34 <tdammers> 7. "oh look, it doesn't compile! guess I made a typo there."
02:40:45 <Walther> another thing that takes time is to cabal install snap on a raspberry pi ;)
02:41:08 <tdammers> raspberry pi == asking for it
02:41:13 <Walther> yyyup
02:41:27 <tdammers> is it possible to virtualize the pi?
02:41:41 <tdammers> 'cause that's how I build haskell projects for my web server
02:41:49 <Walther> pretty sure there are some projects for cross-compiling, buuut
02:42:03 <tdammers> nah, I mean a VM that emulates a pi
02:42:12 <tdammers> only faster
02:54:29 <dagle> tdammers: you can do it with qemu, most likely you will have to patch for support and qemu will accept things that the real hardware wont.
02:55:07 <tdammers> dagle: well, this is just theoretical musing - I'm not currently running anything on a pi
02:55:12 * hackagebot crypto-pubkey-openssh 0.2.6 - OpenSSH keys decoder/encoder  http://hackage.haskell.org/package/crypto-pubkey-openssh-0.2.6 (FedorGogolev)
02:55:21 <tdammers> dagle: and for the i386 server, virtualbox has me covered
02:56:17 <dagle> ?
02:57:23 <dagle> Well, you asked for "virtualize the pi".
02:57:29 <dagle> And qemu can do it.
03:00:00 <tdammers> I asked for it, yes, as a suggestion how one could speed up compilation on a pi
03:08:00 <l0cust> So, I'm having a bit of an algorithmic dilemma
03:08:16 <l0cust> My code is here https://github.com/pharpend/eros
03:08:58 <l0cust> I'm working on how to efficiently implement an algorithm to score each word
03:10:32 <l0cust> This would be in the module Text.Eros.Message
03:19:06 <yitz> l0cust: what is the question?
03:19:40 <l0cust> yitz: oh, I'm trying to figure out an efficient way to check if a Message is dirty
03:19:51 <l0cust> yitz: Or rather, get a score for each message
03:20:06 <l0cust> yitz: I already have a tree of Phrases, and their associated scores
03:20:25 <l0cust> yitz: I'm trying to figure out how to efficiently check a message against the various trees
03:22:00 <l0cust> I'm thinking
03:22:07 <l0cust> use the breakOn function from Data.Text
03:22:16 <yitz> l0cust: without look at more details, just at the code so far:
03:23:01 <yitz> l0cust: you might want to replace the assoc list with a map, and use Map.intersection for efficient lookup of all the words at once.
03:23:53 <l0cust> yitz: didn't know about that library, thank you
03:24:14 <yitz> l0cust: l0cust it's just regular Data.Map, from the containers library.
03:24:30 <yitz> l0cust: you would have to structure things a little differently though.
03:24:49 <l0cust> yitz: how so?
03:25:13 <yitz> l0cust: the method I described would give you a return type of Map Text PhraseTree instead of [Maybe PhraseTree]
03:25:42 <l0cust> yitz: Alright, well, I'll try it
03:25:51 <l0cust> I'm not at all committed to my current structure
03:25:57 <yitz> l0cust: using Map.elems, you can easily turn that into [PhraseTree], discarding the relationship between the trees and the words, if that's what you want.
03:26:48 <yitz> l0cust: just an idea for a direction.
03:27:49 <bitonic> edwardk: do you have any ideas for a monadic `bound'?  something where the reduction can live in ST for example, if I want to do stuff like graph reduction or hash consing.  I can write a specialised version that allows substitution but I wonder if there are more general abstractions
03:29:54 <bitonic> edwardk: btw, I've reproduced a decent subset of Agda using bound <https://github.com/agda/agda/tree/prototype/src/prototyping/term>.  disappointingly Bound.Scope.Simple performs better, at least for my use case where I'm often traversing inside Scopes
03:31:01 <Fuuzetsu> :t Maybe fmap
03:31:02 <lambdabot> Not in scope: data constructor ‘Maybe’
03:31:16 <Fuuzetsu> what's the syntax for unifying things like Functor f => … to Maybe &c?
03:32:05 <Fuuzetsu> @src (-> a) fmap
03:32:05 <lambdabot> Source not found. I don't think I can be your friend on Facebook anymore.
03:32:15 <Fuuzetsu> @src fmap Maybe
03:32:15 <lambdabot> Source not found. Just try something else.
03:34:06 <bitonic> @src Maybe fmap -- Fuuzetsu
03:34:06 <lambdabot> Source not found. Where did you learn to type?
03:34:09 <bitonic> @src Maybe fmap
03:34:09 <lambdabot> fmap _ Nothing       = Nothing
03:34:09 <lambdabot> fmap f (Just a)      = Just (f a)
03:34:50 <quchen> Lambdabot @src database: https://github.com/int-e/lambdabot/blob/master/lambdabot/State/source
03:35:15 <Fuuzetsu> did it not do :t?
03:35:36 <bitonic> Fuuzetsu: :t works like in ghci, iirc.  so you have to provide a valid term.
03:35:45 <Fuuzetsu> oh
03:36:35 <bitonic> Fuuzetsu: @src is a curated collection of haskell bits
03:38:31 <pjdelport> Is there any existing combinator that's like "f =<< x", but takes a pair on either side and joins them in parallel?
03:39:18 <byorgey> pjdelport: not that I know of.
03:40:46 <pjdelport> In other words, (f,g) ==<< (x,y) such that it sequences the two on the left, takes their results, and then sequences f a and f b.
03:42:53 <l0cust> So, I'm having a weird issue with cabal's repl
03:43:01 <pjdelport> The idea would be for example to express swapping two indexes in a mutable array as: (write j, write i) ==<< (read i, read j)
03:43:09 <l0cust> I included some files with my library
03:43:18 <l0cust> they should have been installed to the sandbox
03:43:34 <l0cust> but cabal keeps looking for them in my home directory
03:43:36 <l0cust> that is
03:43:44 <l0cust> when I run "cabal repl"
03:43:45 <ion> (f,g) ==<< (mx,my) = do { x <- mx; y <- my; liftM2 (,) (f x) (g y) }
03:43:52 <l0cust> import Paths_eros
03:44:08 <l0cust> getDataFileName ...
03:44:16 <Fuuzetsu> @undo do { x <- mx; y <- my; liftM2 (,) (f x) (g y) }
03:44:17 <lambdabot> mx >>= \ x -> my >>= \ y -> liftM2 (,) (f x) (g y)
03:44:23 <l0cust> "/home/pete/.cabal/share/x86_64-linux-ghc-7.8.2/eros-0.0.0.0/res/phraselists-ugly/pornography.json"
03:44:28 <l0cust> that's the returned value
03:44:35 <l0cust> That's not what it should be
03:45:03 <Fuuzetsu> @pl (==<<) (f, g) (mx, my) = mx >>= \ x -> my >>= \ y -> liftM2 (,) (f x) (g y)
03:45:03 <lambdabot> (line 1, column 25):
03:45:03 <lambdabot> unexpected " "
03:45:03 <lambdabot> expecting operator
03:45:06 <l0cust> It should return "/home/pete/src/eros/.cabal-sandbox/..."
03:45:12 <Fuuzetsu> @pl foo (f, g) (mx, my) = mx >>= \ x -> my >>= \ y -> liftM2 (,) (f x) (g y)
03:45:12 <lambdabot> foo = uncurry (flip flip snd . (ap .) . flip flip fst . (((.) . flip ((.) . (>>=)) . flip ((.) . (>>=))) .) . flip . (((.) . liftM2 (,)) .))
03:45:16 * hackagebot ini 0.2.1 - Quick and easy configuration files in the INI format.  http://hackage.haskell.org/package/ini-0.2.1 (ChrisDone)
03:45:18 <Fuuzetsu> beautiful ;_;
03:45:28 <Fuuzetsu> :t uncurry (flip flip snd . (ap .) . flip flip fst . (((.) .
03:45:28 <Fuuzetsu>             flip ((.) . (>>=)) . flip ((.) . (>>=))) .) . flip . (((.) .
03:45:28 <Fuuzetsu>             liftM2 (,)) .))
03:45:29 <lambdabot>     parse error (possibly incorrect indentation or mismatched brackets)
03:45:31 <Fuuzetsu> oops, sorry
03:45:35 <Fuuzetsu> uncurry (flip flip snd . (ap .) . flip flip fst . (((.) . flip ((.) . (>>=)) . flip ((.) . (>>=))) .) . flip . (((.) . liftM2 (,)) .))
03:45:36 <Fuuzetsu> :t uncurry (flip flip snd . (ap .) . flip flip fst . (((.) . flip ((.) . (>>=)) . flip ((.) . (>>=))) .) . flip . (((.) . liftM2 (,)) .))
03:45:37 <lambdabot> Monad m => (a -> m a2, a1 -> m a3) -> (m a, m a1) -> m (a2, a3)
03:45:40 * Fuuzetsu shuts up now
03:45:51 <bitonic> Fuuzetsu: (,) <$> (f =<< mx) <*> (f =<< my)
03:46:11 <l0cust> This should be the output - /home/pete/src/eros/.cabal-sandbox/share/x86_64-linux-ghc-7.8.2/eros-0.0.0.0/res/phraselists-ugly/pornography.json
03:46:16 <l0cust> It works on my other machine
03:46:23 <l0cust> what am I doing wrong?
03:46:29 <pjdelport> Fuuzetsu: Yeah, I have something like that, but I was hoping for something cleaner / more idiomatic.
03:47:21 <bitonic> pjdelport: I would say that the idiomatic way is to get the two results in a `do' and do whatever you need to do with them
03:47:25 <bitonic> instead of re-packing them in a pair
03:47:46 <bitonic> btw, in your read-write example you don't have a result to collect
03:49:05 <pjdelport> bitonic: That version of yours changes the ordering, though; the goal of this is to evaluate both arguments first, before evaluating the two consumers (otherwise something like the swapping example won't work).
03:51:38 <l0cust> Any ideas?
03:52:08 <bitonic> pjdelport: ah, right
03:57:01 <l0cust> okay, just reinstalled the library fixed it
03:57:08 <l0cust> that is, deleting the folder
03:57:11 <l0cust> re-cloning it
03:57:18 <l0cust> starting a new sandbox
03:57:21 <l0cust> running "cabal install"
04:06:08 <pjdelport> bitonic: I'm just wondering because this seems like it would be a useful abstraction.
04:09:38 <pjdelport> Especially for longer tuples: like how in Python you can say "a, b, c, ... = x, y, z, ...", where those are arbitrarily complex expressions.
04:11:26 <bitonic> pjdelport: you can do [a, b, c, d] <- sequence [f x, g, y, h z]
04:11:41 <bitonic> not statically checked though
04:11:49 <quchen> Python style!
04:12:00 <bitonic> I don't see that as better than `do a <- fx; ...' though
04:12:21 <pjdelport> bitonic: Well, the idea would specifically be to have the f, g, h etc. on the left side of that effect, not the right.
04:13:52 <simon> I'm looking at some xmonad code and wonder how what looks like a monadic guard works:
04:14:07 <simon>     handleMess (SWN _ c (Just (i,w))) m
04:14:07 <simon>         | Just e    <- fromMessage m = handleTimer i e (deleteWindow w >> return Nothing)
04:14:10 <simon>         | Just Hide <- fromMessage m = do deleteWindow w
04:15:05 <simon> wouldn't the first of these guards always catch?
04:15:06 <quchen> Those are pattern guards, not monadic guards.
04:15:33 <bitonic> pjdelport: what do you mean with "on the left side"?  what would it look like in python?
04:15:43 <simon> sorry, I know there's a difference between a guard within a monad and a pattern guard. but I've never seen a '<-' inside a pattern guard.
04:15:45 <quchen> It evaluates "fromMessage m", and matches the result against "Just Hide". If it matches, the RHS of the "=" is evaluated.
04:15:52 <pjdelport> bitonic: For example x[j], x[k], x[i] = x[i], x[j], x[k]
04:16:01 <pjdelport> (which would do a rotation)
04:16:23 <simon> quchen, but it doesn't take the guards one at a time from the top and stops at the first that matches?
04:16:44 <quchen> simon: Yes, that looks like it's the case, and the second guard is redundant.
04:16:57 <pjdelport> bitonic: In general, the bindings on the left can be arbitrary setters, and all the expressions on the right are evaluated in order before being assigned in order.
04:17:05 <simon> quchen, good.
04:17:26 <pjdelport> bitonic: So it's as if the assignments happen in parallel (more or less).
04:17:29 <bitonic> pjdelport: yeah, if you really want to express that in one combinator it's not going to be too nice, imo.  but I'd ask myself the question if it's worth doing this with a combinator.  also, this seems to be a special case of what you asked where the functions performing the action on the results have () return type
04:17:54 <pjdelport> Right, in Haskell it would be more general and powerful (not surprisingly :)
04:18:19 <yitz> @type (uncurry (liftM2 (,)) .) . uncurry (***) . join (***) (>>=) -- pjdelport: slightly better, perhaps
04:18:20 <lambdabot> Monad m => (m a, m a) -> (a -> m b, a -> m b) -> m (b, b)
04:18:39 <quchen> It's *beautiful*!
04:19:49 <bitonic> I don't know why you would ever want to write that instead of the `do' form :P
04:19:59 <yitz> bitonic: i wouldn't :)
04:22:06 <mmmm> @hoogle [[(a,b)]] -> ([[a]],[[b]])
04:22:08 <lambdabot> No results found
04:23:28 <mmmm> ^ any ideas how to do that nicely?
04:24:13 <pjdelport> bitonic: Consider (write j, write i) ==<< (read i, read j) versus do { a <- read i; b <- read j; write j b; write i a }
04:24:26 <yitz> @type (map.map) fst &&& (map.map) snd -- mmmm
04:24:27 <lambdabot> [[(a, b)]] -> ([[a]], [[b]])
04:24:36 <bitonic> pjdelport: yeah, I'd prefer the second
04:25:14 <pjdelport> bitonic: I vastly prefer the applicative style :)
04:25:54 <bitonic> pjdelport: the second is going to be more readable, and the first doesn't buy you much in clarity even if you know what that ==<< combinator does
04:26:08 <bitonic> the only thing that the first saves you is a couple of newlines :)
04:26:23 <simon> :t (==<<)
04:26:24 <lambdabot>     Not in scope: ‘==<<’
04:26:24 <lambdabot>     Perhaps you meant ‘=<<’ (imported from Control.Monad.Writer)
04:26:34 <yitz> simon: they just made it up
04:26:58 <simon> ah, it's supposed to work in parallel
04:27:01 <pjdelport> simon: That's just made-up syntax; the idea is that it does "parallel" functorial/monadic application
04:27:32 <pjdelport> So it's just like f =<< g, but with more f's and g's on either side
04:27:42 <simon> right
04:27:52 <pjdelport> f =<< x, rather
04:28:27 <yitz> pjdelport: might be more worthwhile if it actually runs them concurrently :)
04:29:35 <simon> yitz, can't do { a <- foo; b <- bar; ... } be run in parallel?
04:30:24 <Axman6> the work done in Facebook's Haxl has a transformation to allow that
04:31:12 <simon> I just understood in Wadler's Comprehending Monads that they can so long as 'b' is not available until after 'a' is found to be something other than _|_.
04:31:41 <bitonic> well but then we would be working with Applicatives
04:31:54 <bitonic> in that case the two reads and the two writes would be parallel
04:33:23 <bitonic> e.g. do (x, y) <- par ((,) <$> read i <*> read j); par ((,) <$> write j x <*> write i y)
04:33:46 <bitonic> that you can parallelize
04:34:39 <FreeFull> In general, applicatives can be parallel where monads can't
04:35:29 <bitonic> well with Applicatives the actions you are composing can't depend on each other -- you don't have >>=
04:40:15 <pjdelport> bitraten: Right.
04:40:34 <pjdelport> s/bitraten/bitonic/
04:41:54 <ion> pharaun: aye
04:41:58 <ion> s/pharaun/pjdelport/
04:49:34 <pjdelport> Hmm!
04:52:23 <pjdelport> > let (&) = liftA2 (,); (f # g) (a,b) = f a & g b in f # g # h =<< a & b & c
04:52:25 <lambdabot>  Couldn't match expected type ‘m t1’
04:52:25 <lambdabot>              with actual type ‘Debug.SimpleReflect.Expr.Expr’Couldn't match e...
04:52:26 <lambdabot>              with actual type ‘Debug.SimpleReflect.Expr.Expr’Couldn't match e...
04:52:26 <lambdabot>              with actual type ‘Debug.SimpleReflect.Expr.Expr’
04:53:04 <pjdelport> That's not necessarily good punctuation, but it actually works.
04:53:30 <pjdelport> With any modified =<< even.
04:56:01 <pjdelport> "Without any modified =<<", even.
04:56:04 <Dodek> wut, i'm using someone's parsec parser
04:56:12 <Dodek> and i get
04:56:13 <Dodek> Error when parsing wrong_tmp.sgf: ParsecParseError "wrong_tmp.sgf" (line 1, column 1524):
04:56:16 <Dodek> unexpected end of input
04:56:17 <Dodek> what the heck
04:56:19 <Dodek> expecting end of input
04:57:42 <lieven_> Dodek: wrong end of line convention perhaps? 1524 is a long line for sgf
04:59:36 <Dodek> that one caught me as well
05:05:22 * hackagebot graph-rewriting 0.7.5 - Monadic graph rewriting of hypergraphs with ports and multiedges  http://hackage.haskell.org/package/graph-rewriting-0.7.5 (JanRochel)
05:05:24 * hackagebot graph-rewriting-layout 0.5.2 - Force-directed node placement intended for incremental graph drawing  http://hackage.haskell.org/package/graph-rewriting-layout-0.5.2 (JanRochel)
05:05:26 * hackagebot graph-rewriting-gl 0.7.4 - OpenGL interface for interactive port graph rewriting  http://hackage.haskell.org/package/graph-rewriting-gl-0.7.4 (JanRochel)
05:06:23 <pjdelport> So how about this: (<:>) = liftA2 (,) and (f <&> g) (a,b) = f a <:> g b
05:07:46 <pjdelport> <:> is just lifted tupling, and <&> is "parallel" composition
05:08:01 <ion> I would have expected <:> to be liftA2 (:)
05:08:52 <pjdelport> Then you can do: (f <&> g <&> h <&> ...) =<< (x <:> y <:> z <:> ...)
05:09:42 <pjdelport> ion: Unfortunately <,> doesn't work. :
05:09:42 <pjdelport> P
05:09:45 <ion> yeah
05:10:02 <pjdelport> (eek, cat on my keyboard)
05:10:33 <pjdelport> <#> perhaps
05:10:35 <ion> <×> ;-)
05:10:54 <ion> because (,) corresponds to multiplication
05:11:10 <ion> Too bad <*> isn’t free.
05:12:30 <tdammers> ion: cue RMS
05:19:10 <FireFly>  
05:20:23 * hackagebot graph-rewriting-ww 0.3.3 - Evaluator of the lambda-calculus in an interactive graph rewriting system with explicit sharing  http://hackage.haskell.org/package/graph-rewriting-ww-0.3.3 (JanRochel)
05:30:25 * hackagebot graph-rewriting-lambdascope 0.5.5 - Lambdascope, an optimal evaluator of the lambda calculus, as an interactive graph-rewriting system  http://hackage.haskell.org/package/graph-rewriting-lambdascope-0.5.5 (JanRochel)
05:30:27 * hackagebot haskell-docs 4.1.5 - A program to find and display the docs and type of a name  http://hackage.haskell.org/package/haskell-docs-4.1.5 (ChrisDone)
05:35:25 * hackagebot graph-rewriting-ski 0.6.3 - Two evalutors of the SKI combinator calculus as interactive graph rewrite systems  http://hackage.haskell.org/package/graph-rewriting-ski-0.6.3 (JanRochel)
05:43:24 <Peaker> Does GHC inline less between modules than inside the same module?
05:43:34 <Peaker> i.e: If I split a module into 5 different modules -- will this harm performance in any way?
05:45:09 <dabd> has anyone read "beginning haskell:  a project-based approach"?
05:45:26 * hackagebot graph-rewriting-trs 0.1.5 - Evaluate first-order applicative term rewrite systems interactively using graph reduction  http://hackage.haskell.org/package/graph-rewriting-trs-0.1.5 (JanRochel)
05:51:49 <proxfox> Hello! Could someone explain me why I'm getting space leaks calling this tiny little recursive function http://pastebin.com/Tb6HgnCK
05:52:09 <proxfox> for any bigger number the memory explodes
05:53:17 <vanila> proxfox, I guess it's because the tail recursion requires strictness
05:53:30 <vanila> using bang patterns on hp might fix it
05:53:50 <proxfox> vanila: thanks I'll try!
05:54:04 <frerich> On hp as well as 'period', I'd say.
05:59:00 <pjdelport> Peaker: "It depends."
06:01:19 <Peaker> pjdelport: what does it depend on?
06:02:13 <pjdelport> Peaker: http://community.haskell.org/~simonmar/papers/inline.pdf has a whole lot of details
06:02:49 <pjdelport> https://www.haskell.org/ghc/docs/latest/html/users_guide/pragmas.html also has some discussion, in the context of the pragmas you can give to control inlining
06:02:58 <natschil> Hello. I have a line in my code that looks like this: (randomBools,g') =  (finiteRandoms g (2*n)) :: ([Bool],StdGen). Haskell seems to be applying the :: to the n, instead of to g', as it gives an error about the actual type being "Integer". What am I doing wrong? (I can post the whole code if it isn't clear)
06:05:28 <natschil> actually, my bad, the error was somewhere else.
06:05:46 <marchelzo_> How can I get the contents of a webpage as a string in haskell? I'm attempting to use simpleHttp from Network.HTTP.Conduit but I'm getting an exception saying "False getAddrInfo: does not exist (error 10093)"
06:07:51 <alpounet> Peaker: yeah GHC inlines more easily things from the same module
06:08:10 <alpounet> "external inlining" is more seriously performed with -O or -O2
06:10:08 <pjdelport> Peaker: You can see inlineability information in ghc --show-iface foo.hi, somewhere.
06:10:27 <Peaker> pjdelport: thanks
06:12:30 <pjdelport> I'm not sure offhand what exactly you need to be looking for, though.
06:15:47 <dabd> is anyone using fpcomplete ide?
06:18:25 * simon shakes his head
06:18:27 <absence> i'm trying to cabal install zlib inside a sandbox. i use --extra-include-dirs with a directory that contains zlib.h, but still get the error "Missing (or bad) header file: zlib.h"
06:21:14 <marchelzo_> does anyone know how I can fix that FailedConnectionException2 (getAddrInfo: does not exist (error 10093))? I can't find anything useful on google
06:22:12 <rwbarton> marchelzo_: are you using windows?
06:22:26 <rwbarton> did you see http://stackoverflow.com/questions/19159686/internalioexception-getaddrinfo-does-not-exist-error-10093-on-windows-8
06:23:43 <marchelzo_> rwbarton: What the.. my google-fu is very weak.
06:23:47 <marchelzo_> Thanks :|
06:24:21 * absence solves problem by adding gcc to the path...........
06:25:41 <werdna> hi, I am having quite some trouble understanding the difference between dependent sum and dependent product types
06:26:01 <werdna> (studying the Curry-Howard Correspondence)
06:26:31 <werdna> I get that a pair type is a type with parameters, and a sum type is a type that can be one of many different types
06:27:27 <werdna> buuut I'm having trouble with understanding dependent sum and dependent product types -- is it the case that a dependent sum type is a type where the types of the arguments depend on one another whereas a dependent product is a function type where the type of the result depends on the types of the arguments?
06:27:39 <nbouscal> a dependent sum type is basically a pair where the type of the second element depends on the value of the first. a dependent product type is basically a function where the return type depends on the value passed in
06:28:28 <nbouscal> important to note it's not just that the type of the result depends on the *types* of the arguments, it depends on the *values* of the arguments. that's what makes it fancy.
06:28:54 <werdna> ahh, that's an important distinction to remember
06:28:55 <rwbarton> consider (x : Bool, B(x)) to see why a dependent sum is called a sum, and (x : Bool) -> B(x) to see why a dependent product is called a product
06:29:10 <werdna> so a dependent product type is definitely a function
06:29:14 <nbouscal> yes
06:29:34 <nbouscal> you'll see "dependent sum" and "dependent pair" used somewhat interchangeably, same with product/function
06:30:03 <werdna> okay, I was confused, I'd seen a "pair type" referred to as a "product type" of two types, is that wrong?
06:30:09 <werdna> no "dependent" in that case
06:30:11 <nbouscal> hehehe
06:30:19 <nbouscal> that's not wrong
06:30:26 <nbouscal> we just like making our naming as confusing as possible :)
06:30:34 <werdna> I don't think engineers should ever be allowed to name anything
06:30:40 <rwbarton> consider that the sum 10 + ... + 10 {- n times -} is also a product n * 10
06:30:50 <werdna> huh
06:30:54 <rwbarton> that is the same phenomenon here
06:31:12 <nbouscal> don't think engineers named these ones, i think it was the mathematicians to blame this time around
06:31:26 <werdna> it's just that pair is being used because in both cases there are two types, it's just that you're doing different things with the two?
06:31:31 <werdna> is that right, or am I missing something more?
06:31:57 <nbouscal> yeah that sounds right. importantly, they're each "products" in different senses
06:32:51 <werdna> in one case a product really means that it's a function, whereas in the other case it's more of a cartesian product… it can hold any value for either of the two types
06:33:31 <nbouscal> yeah the dependent product is a 'product' in a more general sense. i think.
06:33:32 <rwbarton> the cartesian product of two types is also a dependent product indexed on Bool
06:34:08 <werdna> rwbarton: might need to take that one step at a time
06:34:09 <Saizan> werdna: you can think of (x : A) -> B(x) as an |A|-ary product of a family of sets B(x)
06:34:13 <nbouscal> and a regular sum type is a dependent sum type indexed on Bool
06:34:16 <rwbarton> (x, y)   =   (b : Bool) -> (if b then x else y)
06:34:59 <werdna> rwbarton: huh, I thought a type that could hold an A or a B was a sum type of A+B, not a product type
06:35:06 <rwbarton> giving a function of type (b : Bool) -> (if b then x else y) means I give you for each input b : Bool an output of type if b then x else y
06:35:19 <rwbarton> so for the input True, I have to give you an output of type x
06:35:26 <rwbarton> and for the input False, I have to give you an output of type y
06:35:34 <rwbarton> so altogether I have to give you both an x and a y
06:35:34 <werdna> uh huh, so this is like Maybe
06:35:38 <frerich> werdna: It's also the product of '1*(A+B)' :)
06:35:48 <rwbarton> no, this is not a sum type
06:36:10 <rwbarton> a function has to give you an output for every possible input. there are two possible inputs, so there are two pieces of data that are the outputs
06:36:25 <werdna> oh, (b : Bool) -> (if b then x else y) is the actual TYPE
06:36:47 <nbouscal> well, in an notation-abusive sense, yeah
06:36:51 <werdna> It's actually encoded in the type signature that the function returns a different type based on its arguments
06:37:18 <werdna> I have this problem constantly with Haskell, I forget when I'm in typeland and when I'm in normalland and when I'm in monadland
06:37:23 <nbouscal> yeah you can have a dependent function that, say, returns an Int if you give it True and a String if you give it False
06:37:44 <werdna> right, but you can not only write that function, but you can enforce that in the type signature
06:37:54 <nbouscal> yeah
06:38:04 <werdna> man, this type rabbit hole is deep
06:38:38 <nbouscal> f : (x : Bool) -> C(x); C : U; C(True) = Int; C(False) = String;
06:38:44 <nbouscal> in pseudo-types
06:39:05 <nbouscal> C : Bool -> U; sorry
06:39:09 <werdna> gotcha, so that's a dependent sum, right?
06:39:27 <nbouscal> no =/
06:39:43 <nbouscal> a dependent sum would be ((x : Bool), C(x))
06:39:52 <werdna> and a dependent product is, say, where I have a function f which takes two parameters (a : Bool) and b, which is a string if you passed true for a or an int if you passed false for a
06:39:56 <werdna> oh, I have them the other way around
06:40:04 <nbouscal> (i should point out that there are like a dozen notations for this, I just picked the easiest one to type)
06:40:50 <rwbarton> Indeed
06:41:04 <werdna> got it.
06:41:31 <nbouscal> I would recommend not thinking of functions as taking two parameters when you're trying to learn this stuff
06:41:37 <werdna> oh?
06:41:45 <nbouscal> it's a fine shorthand generally, but, it can make you very confused when you're mixing dependent products with regular functions, etc
06:42:25 <rwbarton> a dependent sum IS two values (a : Bool) and b, which is a string if a IS true or an int if a IS false
06:42:31 <rwbarton> no function involved
06:43:26 <werdna> got it, so a dependent sum type could be (isInteger : bool), if isInteger then value : integer else value : string
06:43:28 <werdna> or so
06:44:38 <Ainieco> hello
06:44:54 <nbouscal> werdna: do you know what a type family is, in the dependent types context? e.g. C : A -> U (where U is a universe)?
06:45:16 <werdna> I'm not familiar with the notation, but I've used type families before in Haskell.
06:45:35 <nbouscal> Ok, it's the same thing except that it's easy to think of type families in Haskell different ways
06:45:50 <nbouscal> it's basically just a function from a type to the universe, where the values in the universe are themselves types
06:45:53 <werdna> so I probably don't have a great grasp on the theoreticals, to me they're sum types implemented using indexes?
06:46:24 <werdna> ahh yes, functions on types
06:46:36 <werdna> takes a type in, returns a type.
06:46:42 <nbouscal> takes a value in, returns a type
06:46:54 <nbouscal> haskell type families take a type in and return a type, but that's a special case
06:47:17 <Ainieco> i want a sum type Foo which can hold either Bar  record type or Baz record type, and haming hard time with naming Foo contstructors
06:47:23 <Ainieco> what is convention?
06:47:35 <nbouscal> werdna: the reason i mention this is that dependent types are best thought of in terms of type families
06:47:35 <Ainieco> data Foo = FooBar Bar | FooBaz Baz ?
06:48:00 <werdna> I think we did this for indexing vectors by their size. vector :: (n :: Int) -> Vec n
06:48:02 <werdna> or something like that.
06:48:06 <nbouscal> if you have a type family C : A -> U, then you can have the dependent sum type ((x : A), C(x)), and the dependent function type (x : A) -> C(x)
06:48:07 <simon> Ainieco, either that or data Foo = Bar Bar | Baz Baz
06:48:31 <Ainieco> simon: oh, you can have same names for constructors and types?
06:48:46 <werdna> nbouscal: huh, that does help actually
06:48:47 <simon> Ainieco, it depends on whether the type Bar also uses the constructor Bar - that would be a conflict.
06:48:59 <nbouscal> werdna: yeah it's really hard to think about dependent types without type families imo
06:49:09 <Ainieco> simon: cool, thanks
06:49:25 <werdna> functional programming does my head in. It's a huge amount more mathematical than anything I've ever worked on before.
06:49:25 <tdammers> Ainieco: the thing to understand is that values and types live in completely separate namespaces
06:49:28 <simon> Ainieco, if those types have only one constructor, it would be reasonable to assume that their constructor is named after the type, in which case what I wrote would be confusing.
06:49:40 <nbouscal> also having type families makes understanding the degenerate cases of the dependent types really easy: say you have the constant type family which always returns the same type. in that case, dependent sum degenerates to a simple pair, and dependent product degenerates to a simple function
06:49:52 <nbouscal> werdna: yeah, isn't it great? :)
06:50:10 <werdna> I like the mental challenge
06:50:12 <tdammers> Ainieco: constructors, functions, methods and constants live in the value namespace, type names, type variables and typeclasses live in the type namespace
06:50:34 <tdammers> data Foo = Bar Baz -- Foo and Baz are in the type namespace, Bar is in the value namespace
06:50:44 <werdna> I'd love to do some real world functional programming once this course is over (it's my second-last CS course), it must be really helpful for jobsearching etc.
06:51:18 <klrr_> could someone explain why cabal is behaving like this? http://lpaste.net/8083310029404372992
06:51:26 <Ainieco> tdammers: yeah, i understand, thank you
06:51:27 <klrr_> i just ran "cabal sandbox init"
06:51:35 <klrr_> still dependencies resolution issues...
06:51:42 <nbouscal> werdna: eh. you'll find a lot of people asking for applicants with FP experience but then trying to hire them to write Java.
06:51:48 <Ainieco> simon: what type have only one constructor?
06:51:58 <simon> nbouscal, that's not entirely true. there are C# jobs, too.
06:52:01 <rwbarton> klrr_, sandboxes do not insulate you from running a newer ghc than the package claims to support
06:52:05 <werdna> nbouscal: I'm writing PHP for my bread these days, so whatever works :p
06:52:08 <Ainieco> simon: sorry, completely missed what you've meant confuding
06:52:20 <nbouscal> hahaha. yeah, I used to write PHP for a living and am very happy to be able to write Haskell now
06:52:22 <rwbarton> klrr_: try --allow-newer=base
06:52:37 <rwbarton> klrr_: and then when the package has a dozen upper bounds on other packages too, give up and just try --allow-newer
06:52:44 <tdammers> werdna: http://nl1.php.net/manual/en/class.v8js.php
06:52:49 <Ainieco> nbouscal: haskell for living?
06:52:55 <Ainieco> lucky...
06:53:26 <werdna> tdammers: we're switching to HHVM at Wikimedia soon, and the people here love NodeJS
06:53:27 <werdna> so…
06:53:35 <werdna> tdammers is een heel Nederlandse naam :p
06:53:38 <nicoo> werdna: My condolences :(
06:53:40 <nbouscal> of course they love it, it's badass rockstar tech
06:53:44 <klrr_> rwbarton: gonna try that, thanks
06:53:47 <tdammers> werdna: lol, I'm from Germany originally
06:53:57 <tdammers> werdna: I do live in the netherlands though
06:54:05 <werdna> heh, "Dammers" just sounded very Dutch.
06:54:16 <tdammers> yeah
06:54:17 <nicoo> werdna: (About the NdeJS thing. HHVM is an half-way decent runtime for an awful language)
06:54:19 <tdammers> works in both languages
06:54:31 <werdna> buut I suppose NL/DE bled over back in the day as well.
06:54:45 <werdna> nicoo: heh, well, PHP can be written right if you know what you're doing
06:54:50 <werdna> it's just very easy to not know what you're doing
06:54:55 <tdammers> werdna: no, not really
06:55:22 <nbouscal> even PHP written really well is awful
06:55:39 <werdna> this is definitely not an argument I'm going to win in #haskell
06:55:42 <nbouscal> and very little of it is written really well :P
06:57:02 <klrr_> anyone here familiar with recursion-schemes? have i missunderstood it, or does it make sense to wonder if there is a function in it that works like traverse but for syntax trees?
06:57:23 <nicoo> werdna: This is actually an excellent argument to say that PHP is an awful language. You can do great thing in about anything (except perhaps Malboge), if you know what you are doing :)
06:57:51 * werdna shrugs
06:58:13 <tdammers> the thing is, PHP really lacks the expressive power to get to 100%
06:58:28 <werdna> I don't try to rank languages, but I think it's a bit rude to say all PHP programmers are wasting their time.
06:58:44 <werdna> not that anyone's necessarily saying that right up
06:58:53 <nbouscal> They're not wasting their time, and I wouldn't say that PHP is the wrong choice for many of the companies that use it. However, being the right choice doesn't mean that it's a good language or that you can write good code in it.
06:58:54 <tdammers> well, PHP is quite literally wasting time
06:59:13 <tdammers> but it is often worth it, unfortunately
06:59:28 <werdna> programmer time or CPU time?
06:59:30 <nbouscal> For example: If you already have a 10million line codebase written in PHP, you're likely never going to convert that into a proper language. That makes PHP the right choice, but doesn't make it a good language.
06:59:35 <tdammers> programmer time
06:59:39 <nicoo> werdna: I'm not saying they are wasting their time. I just say that PHP really isn't very good, and people should consider using something else when beginning a new project.
07:00:01 <vanila> what good alternatives are here to PHP?
07:00:03 <vanila> there*
07:00:12 <nbouscal> Haskell
07:00:16 <nbouscal> :D
07:00:24 <sm> there's nothing else in PHP's niche
07:00:29 <nbouscal> PHP
07:00:39 <nbouscal> PHP's niche is "make a web app without knowing how to program"
07:00:52 <tdammers> vanila: for a web project, my personal list of choices goes Haskell, Ruby, Python, Node.js, C++, INTERCAL, PHP
07:01:02 <werdna> I think it has its place. It's good for web programming, encourages you to think about one request at a time. Scales horizontally quite well. If you have the right framework the code is even tolerable
07:01:08 <nicoo> sm: Depends on what you consider to be PHP's niche
07:01:19 * nicoo adds OCaml to tdammers' list :3
07:01:27 <tdammers> nicoo: oops, yeah, OCaml
07:01:34 <tdammers> also, scheme
07:01:40 <werdna> encourages you also to put your storage etc outside of the web server
07:01:42 <benj_> may I suggest #haskell-php, k thx
07:01:59 <tdammers> werdna: it does?
07:02:18 <tdammers> werdna: if anything, it encourages you to hit the filesystem for no good reason
07:02:54 <tdammers> just because herp-derp, we can't figure out automatic memory management, so whee, let's just throw everything away and redo everything for every single request
07:03:39 <tdammers> of course it's a good idea to keep your storage separate from the web server
07:03:58 <tdammers> but this is a decision that should be based on actual technical considerations
07:04:07 <tdammers> not on stupid design decisions from 1991
07:04:10 <Ainieco> tdammers: ruby, wow. doing ruby programming for past 5 years and haskell programming for past year and haskell looks such much better than ruby....
07:04:26 <tdammers> Ainieco: sure, as a language...
07:04:51 <tdammers> Ainieco: but then, Ruby has many of the advantages of Python or PHP, but considerably fewer warts
07:05:42 <tdammers> self, if __name__ == '__main__', pass, def foo(a=[]), ...
07:09:44 <r444> tdammers: ruby is definitely more pleasant than python/perl/php/whatever
07:09:58 <r444> problem is controlling complexity
07:10:19 <r444> complexity is skyrocket in ruby applications
07:10:30 <tdammers> always is, especially in dynamic languages
07:10:40 <tdammers> python isn't the slightest bit better
07:10:44 <silver> wow, python in the line of php and perl these days
07:10:53 <tdammers> I'd argue python is even worse than php in this regard
07:10:55 <r444> it's silghtly better IMHO
07:11:03 <tdammers> php at least has visibility modifiers
07:11:13 <vanila> arent python, php, ruby all the same?
07:11:23 <tdammers> vanila: close, but not quite
07:11:29 <r444> i worked as python and ruby dev - ruby is more pleasant to work with, overall
07:11:35 <systemfault> They’re all untyped toys :)
07:11:39 <tdammers> python can't do real OOP, because it only has dictionaries, not objects
07:11:42 <r444> php is a joke
07:11:43 <r444> bad joke
07:11:45 <tdammers> php can't even do addition
07:12:18 <zwer> did Guido finally remove lambda, filter and map in python?
07:12:25 <tdammers> no
07:12:30 <eiro> perl have $_ and regexp manipulation directly in the langage. it's one of the reason i think it's way more pleasant than the others
07:12:35 <tdammers> but get this
07:12:40 <tdammers> zip() and map() are now lazy
07:13:06 <r444> eiro: perl is hackity hack with some hacks
07:13:40 <r444> it's hack collection, not a programming language(if we're speaking about universal languages, not text processing)
07:13:43 <simon> tdammers, what is "real OOP"?
07:14:08 <r444> smalltalk is pretty hardcore^WOOP-ish
07:14:17 <tdammers> simon: well, good question actually... but at the very least, I'd expect a separation of an object's public interface and its internals
07:14:22 <eiro> perl is a mess... but it's the only dynamic langage i always come back to just because it get the job done
07:14:32 <simon> tdammers, so you mean something other than duck-typing.
07:14:33 <eiro> also: unicode support is just awesome
07:14:56 <tdammers> simon: duck typing is an antipattern alright, but monkey-patching is actually worse
07:14:58 <r444> eiro: ruby/python have unicode support
07:15:00 <vanila> hat kind of language would be best for web?
07:15:02 <simon> tdammers, I don't see what that has to do with OOP, but I agree that it's a problem for large-scale systems programming.
07:15:11 <r444> eiro: i think it's a matter of familiarity
07:15:18 <r444> i usually go with ruby
07:15:25 <tdammers> simon: I consider encapsulation more important for OOP than inheritance
07:15:38 <tdammers> OOP is supposed to help fight complexity
07:15:54 <r444> tdammers: monkey patching is great prototyping tool
07:16:07 <tdammers> r444: yeah, for prototyping, sure, by all means
07:16:19 <nbouscal> OOP doesn't have anything approaching a consistent definition. All of the relevant experts disagree on what it means.
07:16:20 <tdammers> r444: prototyping is actually something where these languages shine
07:16:20 <eiro> r444, no ... perl is superior in many details
07:16:30 <tdammers> nbouscal: point taken
07:16:32 <eiro> plus they have cpan which is awesome
07:16:35 <simon> tdammers, good point. you can do that by naming conventions (__foo__ is private), but by that measure, you're never supposed to see anyone refer to __foo__s outside of modules. then again, you're never supposed to see an unsafe cast in Java, right? :)
07:16:54 <tdammers> simon: yeah... python's OOP just feels tacked on
07:17:04 <tdammers> but then, JS isn't much better
07:17:10 <nbouscal> To be fair and impartial: FP isn't much better. Lots of different definitions of 'functional' get thrown around.
07:17:18 <Iceland_jack> ot?
07:17:24 <simon> tdammers, I was going to say that. yet, lots of things are written in Python and JS. but maybe not a lot of large things?
07:17:30 <tdammers> Iceland_jack: for about a decade now, yes :P
07:17:34 <r444> eiro: so what? ruby has gems, python has eggs(frankly, they suck) and wheels(pretty ok)
07:17:36 <eiro> about OO: i'm not a fan of it but moose and moo are just the best OO system i wrote with in dynamic langages
07:17:37 <Iceland_jack> #haskell
07:17:42 <Iceland_jack> oops
07:17:45 <tdammers> guys: #-blah?
07:17:51 <nbouscal> tdammers: Lots of large things are written in Python and JS, they just become very difficult to manage at that point. People continue to try anyway.
07:18:02 <tdammers> nbouscal: yes, I know
07:18:08 <eiro> (i don't know the internals but it is very pleasant at use)
07:18:15 <nbouscal> Oh, that was supposed to be to simon, sorry
07:19:11 <eiro> r444, please check metacpan.org: none of those community have such a rich ecosystem around the package management
07:19:37 <nbouscal> python has such a rich package ecosystem that it has three different package managers :P
07:19:40 <eiro> gems is not so bad but far less confortable
07:19:58 <eiro> nbouscal, haha : )
07:19:58 <Hodapp> tdammers: what systems do you know of that implement un-tacked-on OOP?
07:20:20 <r444> eiro: do perl guys have their own bundler?
07:20:29 <tdammers> Hodapp: good question, actually... idk, C# maybe
07:20:54 <eiro> r444, you mean: in a ruby sens ? yes: it's carton
07:21:40 <geekosaur> carton and app::fatpacker
07:21:55 <r444> eiro: in my experience gems is less painful of all dynamic languages packaging system(not a perl guy)
07:22:00 <tdammers> Also, php has composer. its logo depicts a conductor, not a composer. Go figure.
07:22:18 <r444> tdammers: lol
07:22:29 <geekosaur> sure, gems are great until you run into the ruby problem. which is that every. single. app. has. its. own. disjoint. dependencies.
07:22:43 <r444> tdammers: it's php after all
07:22:45 <geekosaur> install a separate ruby ecosystem for every app, or none of them will work
07:22:46 <sveit> i want to write a
07:22:56 <r444> conduct with a sheet music, compose with a baton
07:23:05 <tdammers> r444: yeah... php... where 60% accuracy is plenty
07:23:30 <r444> geekosaur: better than cabal sandboxing
07:23:36 <tdammers> "they both do something with music, right? OK, good enough, ship it!"
07:23:38 <eiro> r444, so use cpanm! you'll be in joy
07:23:54 <geekosaur> r444: hsenv, if you must
07:24:06 <Hodapp> tdammers: a competent programmer ought to be able to handle that remaining 40% pretty easily. It's all corner cases. Corner cases are easy.
07:24:16 <geekosaur> but, also please keep blaming cabal for ghc's deficiencies if it makes you feel better
07:24:21 <eiro> geekosaur, ap::fatpacker is another thing but yes: pinto, fatpacker, par, cpanm, dh-make-perl (for debian sysops)
07:24:51 <geekosaur> it'd all be much *worse* if you had to deal with ghc directly
07:25:07 <eiro> all those stuff are one of the reason i don't use ruby more
07:25:53 <eiro> and still: $_ helps when a langage don't have partial application like haskell
07:26:01 <r444> eiro: Something particular to dislike? I like it very much and clearly don't understand the perl sentiment.
07:26:35 <eiro> in perl i can write now {say} take 10, filter {/foo/} lines "/tmp/bar"
07:27:20 <r444> perl is write-only language, after all, you can write all you want
07:27:24 <eiro> i can't write something similar in other langages
07:27:35 <sveit> is there a way to allow a datatype to have any type parameter in general (i.e. some data D a, where a can be anything) but only allow constructors for certain a that satisfy particular constraints? the application is that if a can be put in a vector i would like to do that, otherwise put it in a list
07:28:01 <eiro> r444, well ... you probably don't do perl if you think that way
07:28:09 <r444> eiro: you can do something very similar with Enumerator::Lazy and to_proc syntax in ruby
07:28:22 <tdammers> sveit: smart constructors?
07:29:00 <tdammers> sveit: but normally, I'd go with typeclasses there
07:29:10 <eiro> r444, the syntax isn't so convenient... when it comes to block, you always have to use |x| syntax
07:29:29 <Kaidelong> PHP has no advantage over perl in terms of ugliness
07:29:34 <eiro> in ruby you'll need to write { |x| puts x }
07:29:35 <Kaidelong> and perl is readable if you know what to expect
07:29:42 <eiro> in perl it's just {say}
07:29:50 <tdammers> as if syntax were the problem in the first place
07:30:01 <sveit> tdammers: so typeclasses dispatched over separate types?
07:30:08 <Kaidelong> well one of the reasons people abandoned perl was because of the syntax
07:30:08 <eiro> because {say} and {say $_} are the same
07:30:12 <Kaidelong> now they're using PHP
07:30:29 <tdammers> Kaidelong: those people abandoned Perl because the concepts were too complicated
07:30:30 <vanila> I want strong types to ensure correctness, like unvalidated user input would be a different type than validated for example
07:30:41 <tdammers> Kaidelong: even if they're perfectly straightforward concepts
07:30:42 <Kaidelong> PHP is worse than Perl/CGI in just about every conceivable way
07:30:56 <tdammers> Kaidelong: yes.
07:30:59 <Kaidelong> so it's bizzare that it happened
07:31:00 <Kaidelong> but it did
07:31:25 <tdammers> I think the #1 reason why it happened was because you could rename your .html files to .php on your shitty shared web hosting
07:31:43 <tdammers> throw in a bunch of <?php echo $username; ?>
07:31:49 <tdammers> and it "worked"
07:31:54 <Kaidelong> oh well a real advantage of deployment then
07:32:07 <eiro> Kaidelong, i used php in late 90 and the reason php beat perl on the web was: perl required you to have a little basic knowledge of what http is. they promoted the code separation (which is hard to understand for a newbie)
07:32:09 <tdammers> more like, a zero-height threshold
07:32:33 <tdammers> in order to start using PHP, you needed literally no programming knowledge at all
07:32:50 <vanila> that's the same with haskell
07:32:50 <eiro> perl was just *the* solution for most of the simple dynamic pages those times
07:32:54 <tdammers> sadly, "zero programming knowledge" is where it ended for many PHP "programmers"
07:33:26 <eiro> exactly!
07:33:30 <Kaidelong> eiro: people made some pretty complex things with it, look at Kingdom of Loathing
07:33:34 <tdammers> vanila: if you want to build a dynamic website in Haskell, you need to learn quite an impressive number of things before you can be productive
07:33:44 <Kaidelong> I think that's still done in perl because the code base for it is so big
07:33:53 <tdammers> Kaidelong: KoL is PHP IIRC
07:34:27 <systemfault> Is it true what some people say about haskell “Too math-y for normal programmers but not enough for mathematicians” ?
07:34:28 <eiro> i didn't say php haven't evolved ... but frankly: nowaday they are just light years from the level of perl
07:34:41 <vanila> that's not true!
07:35:34 * hackagebot psqueues 0.1.0.1 - Pure priority search queues  http://hackage.haskell.org/package/psqueues-0.1.0.1 (JasperVanDerJeugt)
07:35:48 <eiro> ruby and python are serious competitors. php and javascript are the bill we have to pay for the dominance of the web
07:36:33 <Kaidelong> Javascript can probably be fixed without too much effort
07:36:33 <tdammers> javascript is arguably too simple, but otherwise tolerable. It doesn't come anywhere near the shittiness that is PHP
07:36:34 <eiro> vanila, well.. show me just *one* interesting feature of php perl don' thave
07:36:47 <Kaidelong> giving it static, structural typing would go a long way
07:37:01 <Hodapp> Kaidelong: effort on whose part?
07:37:03 <Kaidelong> something akin to OCaml
07:37:07 <tdammers> giving it a consistent, feature-complete standard library would already go a long way
07:37:21 <eiro> javascript was written in 12 days: they have an excuse here (actually: it's an amazing job)
07:37:26 <eiro> php ...
07:37:26 <Kaidelong> Hodapp: the people who have to learn the new concepts
07:37:39 <tdammers> php wasn't written at all. more like pooped.
07:37:42 <vanila> eiro, sorry! I was responding to <systemfault> Is it true what some people say about haskell “Too math-y for normal programmers but not enough for mathematicians” ?
07:38:00 <eiro> but anyway: my goal now is to learn haskell and switch to compiled, typed systems :)
07:38:04 <systemfault> Sorry for messing up the conversation… that wasn’t my goal
07:38:11 <eiro> vanila, ok :)
07:38:13 <vanila> systemfault, my bad!
07:38:14 <Hodapp> Kaidelong: sorry, I must have misheard you. You just said that it wouldn't be much effort for a ton of people to learn a bunch of new concepts?
07:38:19 <Hodapp> Kaidelong: Was that a joke?
07:38:22 <Kaidelong> Haskell is not particularly mathy but because of unfortunate precedent people use some strange terms
07:38:44 <Kaidelong> Hodapp: No, I really think that it'd only take a minor conceptual leap to make javascript a lot better than it is now
07:39:09 <r444> > PHP has no advantage over perl in terms of ugliness <-- +1 on this one
07:39:11 <lambdabot>  <hint>:1:32: parse error on input ‘in’
07:39:25 <r444> my eyes are bleeding from perl
07:39:30 <Hodapp> Kaidelong: "minor conceptual leap" tells absolutely nothing about the level of effort that it would take to actually get this implemented and understood widely.
07:40:29 <Kaidelong> Hodapp: what exactly did I say that you are contesting?
07:40:34 <Kaidelong> this seems orthogonal
07:41:35 <Kaidelong> maybe we are imagining a change of different magnitude, I'm mostly concerned about how corner cases are handled
07:41:43 <eiro> r444, maybe your perl code make your eyes bleed: it's time to learn perl :)
07:41:56 <Kaidelong> I think the main fallout would be breaking programs that depend on strange behavior like [] == {}
07:42:29 <Hodapp> Kaidelong: You said "without too much effort". I asked, whose effort. You told me that the effort would be on the part of the people learning the new concepts.
07:42:49 <Kaidelong> Yeah I don't think you need to introduce too much new stuff into javascript to improve it a lot
07:42:58 <Kaidelong> the implementation might need to change a lot
07:43:02 <r444> eiro: oh, stop this super-advanced-sed endorsement
07:43:12 <r444> perl's niche is text processing one-liners
07:43:14 <Hodapp> Kaidelong: Then why are you talking about technical changes, and not how to achieve adoption and actually get it into place?
07:43:25 <r444> more complicated systems - NOPE
07:43:39 <Hodapp> Kaidelong: You're explaining to me how the *technical* changes are not very much effort. Why?
07:43:49 <Kaidelong> Hodapp: No I'm not
07:43:56 <eiro> r444, so what are projects like pdl, dancer, mojolicious, catalyst, ...
07:44:05 <Kaidelong> I didn't say anything one way or the other about the effort needed to introduce the changes at a technical level
07:44:11 <Kaidelong> I was only talking about adoption
07:44:32 <r444> eiro: bad judgement in tech
07:44:55 <eiro> because *you* know what's bad ? right ?
07:45:08 <r444> first versions of perl are okay to me
07:45:16 <Hodapp> Kaidelong: You are talking about *the language itself* - not the users, not the implementations, not the culture that holds it there. You are talking about the ease of technical issues, not about adoption.
07:45:18 <r444> this is hardcore and elegant text processing
07:45:18 <Kaidelong> sanitizing corner cases and adding some type checks would be easy for users to adopt, I have no idea how difficult it would be to implement
07:45:46 <r444> later versions - sed with 9000 hacks to make it universal programming language
07:47:13 <Hodapp> Kaidelong: This is like saying, "It wouldn't be much effort to get all of a city's bicycle riders to wear a helmet." and then justifying it with an explanation about chin straps being easy to operate.
07:47:51 <Kaidelong> Hodapp: but it hasn't been really, in my city they just started fining riders who didn't wear it, and they eventually started wearing it. It wasn't hard. People will do easy things when they're told
07:48:27 <Hodapp> Kaidelong: If it's that easy, then why don't you just tell them, "Quit writing buggy code." and forget about the static typing?
07:48:29 <Kaidelong> although some big player like Google will have to exercise some leadership
07:49:03 <r444> Kaidelong: are you suggesting fines for bugs?
07:49:14 <Kaidelong> Hodapp: yeah if people could just quit writing bad code then this wouldn't be a problem
07:49:49 <Kaidelong> but that's hard
07:49:51 <Hodapp> Oh, yes, it wouldn't take much effort except for A BIG COMPANY WITH CONSIDERABLY AUTHORITY DECIDING TO DEVOTE FAIRLY SUBSTANTIAL REAL DOLLARS DO IT.
07:49:55 <eiro> r444, if you still consider perl as a sed on steroids, i understand you can't be fan of what happenned in this world
07:50:06 <Kaidelong> Hodapp: that would take effort
07:50:16 <Kaidelong> I wasn't saying the whole effort would be easy
07:50:22 <Hodapp> You said it wouldn't take much effort.
07:50:27 <Kaidelong> just that you don't have to change Javascript much, it's already close to a good language
07:50:39 <eiro> but you really miss something there
07:50:55 <Kaidelong> I think you extrapolated what I was saying to something much more extravagant than what I actually was saying
07:51:12 <Kaidelong> I think it would be pretty much impossible to actually push these changes and make them stick
07:51:32 <Hodapp> Kaidelong: You said it wouldn't take much effort. I asked whose effort. You said effort on the part of people who have to learn the new concepts. This is explicitly what you said, not me.
07:51:44 <eiro> so .. time to play with applicatives (and see if i finally got it)
07:51:48 <eiro> cya all
07:51:54 <Kaidelong> Yeah I said I don't think people would have to undergo a major paradigm shift
07:51:56 <Hodapp> Kaidelong: Now you're saying that it would be pretty much 'impossible' to actually make the changes stick?
07:52:15 <Kaidelong> Hodapp: there are many more issues than just how easy it is to learn something
07:52:38 <Kaidelong> you have lots of old code that might break, people invested in the old implementation, the fact that it might be a lot of effort to make the new one
07:52:48 <Hodapp> Kaidelong: Um, that is exactly what I was telling you, and that you were arguing with, when you said it was "not much effort".
07:52:59 <Kaidelong> Okay well I wasn't arguing against that
07:53:08 <r444> eiro: perl has noisy syntax, it's weakly typed, advanced perl is impossible to read. It's more than enough arguments for me to never use it again.
07:53:09 <Kaidelong> sorry for the confusion
07:54:20 <Hodapp> Kaidelong: If users don't *want* to learn something new, that is a nonzero amount of extra effort. If users have to go and account for a change, that is also nonzero effort.
07:55:24 <Kaidelong> I am not going to argue that the political resistance or the costs of adapting to the new technology are minor, I am narrowly saying that the actual differences that would have to be put in textbooks etc would be very small
07:56:58 <Hodapp> Kaidelong: If you're talking about changes in *textbooks*, then why when I asked you what you meant by "not much effort" did you explicitly refer to the effort of people actually learning?
07:57:36 <Kaidelong> Hodapp: they don't need to relearn javascript? Almost all their old knowledge would still work?
07:58:23 <Kaidelong> the main thing I was trying to say is that javascript is almost a good language
08:00:10 <eiro> r444, in your last sentence, replace weakly by stongly, perl by haskell and that's what i hear about haskell nowadays
08:01:29 <eiro> still:  i'm happy to learn something that will drastically improve my productivity: learning something good needs comitment :)
08:01:46 <Hodapp> eiro: No, it's not much effort.
08:01:51 <r444> eiro: i think you're confusing strong typing with static typing
08:02:24 <eiro> r444, you think right :) what's the difference ?
08:02:52 <Kaidelong> depends how you define strong typing
08:02:59 <Kaidelong> as far as I am concerned, perl is strongly typed
08:03:20 <n-dolio> Static typing is when you check types before runtime. Strong typing is a meaningless term people like to throw around. :)
08:03:23 <eiro> for me: perl moose have strong types because you can write thing like :
08:03:33 <r444> eiro: https://www.destroyallsoftware.com/talks/useing-youre-types-good
08:03:40 <Kaidelong> haskell is weakly typed if you subvert type safety by casting
08:03:48 <Kaidelong> I'm not sure if you can actually do that in perl
08:04:00 <Kaidelong> so perl may be more strongly typed
08:04:01 <eiro> subset of Int where { $_ > 0 && $_ < 12 }
08:04:04 <r444> Kaidelong: perl is casting everything to string by default
08:04:07 <r444> kinda like php
08:04:09 <eiro> r444, thanks
08:04:19 <Hodapp> Use a loosely-typed language for something complicated, and then tell me with a straight face that 'strong typing' is meaningless.
08:04:29 <r444> eiro: this one is serious though: http://stackoverflow.com/questions/11889602/difference-between-strong-vs-static-typing-and-weak-vs-dynamic-typing
08:04:34 <Kaidelong> r444: those are explicit casts, weak typing AFAIC is when types are coerced
08:04:56 <Kaidelong> implicit*
08:05:13 <Kaidelong> I should have said coercion up there, and not casting
08:05:18 <r444> Kaidelong: they are implicitly coerced in perl, no?
08:05:46 <Kaidelong> r444: so perl uses the bits representing the number 10 as a string, and doesn't convert 10 into "10"?
08:05:49 <eiro> Kaidelong, in perl, scalars are scalars: you can even increment a string
08:05:49 <r444> "1 + 'foo'" is valid expression
08:06:18 <r444> Kaidelong: i don't remember details, only pain i felt T_T
08:06:22 <Hodapp> hah
08:06:35 <eiro> yep: it uses the looks_like_number built-in
08:06:48 <Kaidelong> I'm pretty sure perl converts it to a string, that was my experience when I used it anyway
08:07:14 <Kaidelong> weak typing would be if it did something like see "10" and then end up giving you a really weird string or crashing as it tries to find a null terminator
08:07:43 <r444> Kaidelong: it depends on how you see it
08:07:49 <eiro> perl uses operators to guess what to do
08:08:02 <Kaidelong> implicit casting is nasty but it is still strong typing
08:08:19 <eiro> so 10 . ''  gives a string and 10 + 0 gives an int
08:08:38 <eiro> conversion between each others are implicit
08:08:48 <r444> Kaidelong: adding integer to string is canonical weak typing
08:08:58 <Hodapp> er, yeah
08:09:07 <eiro> you can also print references in a string
08:09:14 <Hodapp> that's literally the canonical example of it
08:09:29 <Kaidelong> r444: but you're not actually adding an integer to a string or a string to an interger. You're turning one of them into a string to add a string to a string or one to an integer to add an integer to an integer
08:10:00 <Kaidelong> consider if you're working in bare assembler
08:10:07 <Kaidelong> you really could add an integer to a part of a string
08:10:21 <tdammers> according to my definition, strong typing would be if perl refused to add "10" and "5", because they're strings, not numbers
08:10:45 <eiro> r444, well you can write "10" + "2" and it works well: it's very usefull in a world where most informations are text serialized
08:10:49 <n-dolio> This is why it's meaningless.
08:10:56 <Kaidelong> this is why I like to avoid using "strong" and "weak" typing
08:10:58 <n-dolio> If you ask 10 different people, you'll get 6 different criteria.
08:11:07 <tdammers> indeed
08:11:10 <benj_> Bob Harper's Introduction to ML says ML is strongly typed, go figure
08:11:20 <r444> eiro: it's very useful if you're bored and want to debug something
08:11:21 <Hodapp> Bob Harper says a lot of things.
08:11:25 <tdammers> any language is strongly typed according to its fans
08:11:34 <n-dolio> I'd bet money that his criteria for strong typing don't fit Perl. :)
08:11:43 <benj_> rather, he says it's strongly typed because it's statically typed
08:11:50 * monochrom butts into the conversation. what is functional? :)
08:11:54 <tdammers> no, but maybe Larry Wall's criteria would fit Perl
08:12:26 <prolugger> a miserable pile of functions
08:12:29 <Kaidelong> monochrom: the base libraries provide higher order functions like map and you can construct your own
08:12:38 <Kaidelong> how's that?
08:12:44 <r444> you guys are fun, too bad i need to go o/
08:12:52 <Kaidelong> C# is functional
08:12:53 <benj_> so there's a definition that doesn't even admit any dynamically typed language to being strongly typed
08:12:54 <eiro> r444, your pov :)
08:12:59 <Kaidelong> so is Javascript
08:13:00 <eiro> bye r444
08:13:12 <eiro> oopps .. got to go too! bye all
08:13:17 <Kaidelong> Java and C++ are the laggards
08:13:26 <tdammers> calling a language "functional" is kind of misleading
08:13:48 <tdammers> does it mean it supports FP at all? does it mean it encourages FP? or even enforce it?
08:14:00 <Kaidelong> I think it should at least encourage it
08:14:08 <Kaidelong> which fortunately a lot of mainstream languages do now
08:14:10 <Hodapp> according to some people, it means that you could use it to implement a functional language.
08:14:14 <n-dolio> Does C# encourage it? :)
08:14:15 <monochrom> I support say-what-you-mean. I denounce do-what-I-mean which is euphemism for don't-say-what-you-mean. "10"+"2" = "12" is don't-say-what-you-mean.
08:14:19 <Hodapp> in other words, it can be programmed to do stuff.
08:14:31 <Guest99731> Hi. I'm trying to compile a haskell program with the -prof option, but I seem to miss some libraries. 1. What package do I need to install? 2. How do I help myself the next time?
08:14:31 <tdammers> Hodapp: but every turing-complete language can do that
08:14:46 <Kaidelong> n-dolio: yes! nowadays C# is all about parametric polymorphism and higher order functions and even its own take on do syntax
08:14:49 <monochrom> in my eyes the issue isn't even about typing
08:15:02 <benj_> whether or not there's a useful definition of "functional language", I believe it's unhelpful, beginners end up believing they are "doing functional programming" because they used a "functional language" - and look Wikipedia says Python is functional
08:15:06 <Kaidelong> it's glorious
08:15:09 <Hodapp> tdammers: that's why I reject what those people say.
08:15:23 <n-dolio> That doesn't gel very well with my recent experiences with it.
08:15:39 <hiptobecubic> Kaidelong, MS is careful not to say anything that sounds "FP" though, so they don't scare their drones ;)
08:15:49 <prolugger> it's like luggages. if i carry a bag from the supermarket is it a luggage? what if I bring a suitcase to the supermarket? what if I use a supermarket bag to carry clothes? at what point is it a "luggage"?
08:16:09 <bartavelle> Guest99731, for the next time, you might want to edit ~/.cabal/config and have library-profiling: True
08:16:21 <monochrom> it's about "let's make programming like bendable English" vs "let's make programming like objective logic"
08:16:26 <prolugger> language alone is too fuzy to describe the wonder that is luggage
08:16:29 <tdammers> how many shards can I chip off a jar before it stops being a jar?
08:16:43 <Kaidelong> n-dolio: I guess people could just stubbornly ignore the new features
08:16:51 <Kaidelong> that would make me really sad though
08:17:05 <n-dolio> Maybe that's what the project I was working on did. :)
08:17:37 <n-dolio> Anyhow, I was pretty unhappy writing C# relative to, say, F#.
08:17:59 <Kaidelong> the only thing I miss in C# is the lightweight syntax and pattern matching
08:18:00 <Guest99731> bartavelle: thank you :)
08:18:11 <Kaidelong> most every F# feature is there in C#, well, computation expressions I guess
08:18:17 <tdammers> I was pretty unhappy writing C#, but that was more because it meant using Windows and all the other parts of the MS toolchain
08:18:18 <Kaidelong> those are also missing
08:18:36 <n-dolio> I think pattern matching was the huge difference.
08:18:38 <Kaidelong> however C# beats out F# in terms of tooling and idiomatic use of external libraries
08:19:28 <n-dolio> Algebraic data types in general, really.
08:20:20 <Kaidelong> as a language, F# might be better than Haskell, I'm a bit ambivalent
08:20:37 <n-dolio> Well, I don't see how you could argue that.
08:20:41 <levi> Heretic. :)
08:20:57 <nbouscal> Isn't F#'s type system far less expressive than Haskell's?
08:21:02 <nbouscal> (Assuming GHC)
08:21:25 <n-dolio> But it seems far preferable to C#.
08:21:26 <nbouscal> (I haven't done any work in F#, so I could be totally wrong here)
08:21:28 <nicoo> nbouscal: Even without assuming GHC's extensions, AFAIK
08:21:38 <vanila> Kaidelong, how could F# be better than haskell?
08:21:39 <nicoo> nbouscal: It just sucks much less than C#
08:21:47 <nbouscal> That's the impression I had been given
08:22:08 <Welkin> what is with these "hybrid" OOP-FP languages?
08:22:16 <Welkin> it seems pointless
08:22:17 <Kaidelong> nbouscal: well with all the GHC extensions enabled maybe... it's a bit like "GHC with extensions" from the get go and its type system is pretty permissive but the tradeoff is no general type inference
08:22:18 <nbouscal> Welkin: evangelism
08:22:25 <n-dolio> nbouscal: F# lacks higher kinds, for instance. And they took out the feature of ML that plausibly lets you do without them.
08:22:35 <Kaidelong> oh yeah no higher kinds is a big one
08:23:02 <nbouscal> that's pretty huge
08:23:09 <kazagistar> if your metric is "How well it integrates with .NET and windows libraries" then maybe you could say F# is better, but that is kind of a limited metric, though sometimes useful
08:23:25 <nbouscal> I sometimes forget that windows still exists and is important to people
08:23:30 <monochrom> n-dolio: recently I realized that boolean blindness goes well with preferring looping constructs and avoiding recursion.
08:23:33 <zerokarmaleft> n-dolio: what feature is that?
08:23:40 <Welkin> I feel sorry for people that use windows
08:23:42 <zerokarmaleft> ML functors?
08:23:43 <n-dolio> zerokarmaleft: Higher-order modules.
08:23:46 <n-dolio> Yes.
08:23:55 <Welkin> they don't even know how bad it is
08:24:17 <Kaidelong> vanila: computation expressions are pretty neat, they made some better decisions about the standard library, IE there's a window function and the emphasis is forward pipes (flip id) which IMO is more idiomatic than . and $ and standard libraries really are quite important
08:24:25 <nbouscal> Yeah I disagree with pg on a lot of things, but the 'Blub paradox' is pretty spot-on. Applies to a lot more than just PLs
08:24:35 <Kaidelong> then there's also the simple fact that .NET is really nice to work on, Haskell is pretty low level when you have to do things like IO or GUIs
08:24:51 <vanila> yeah GUI in haskell is pain
08:25:04 <bernalex> <| & |> are a lot better than $ and &
08:25:10 <n-dolio> monochrom: I could see that.
08:25:29 <vanila> http://msdn.microsoft.com/en-us/library/dd233182.aspx I don't get this
08:25:37 <vanila> is this not just monad
08:25:41 <bernalex> but /isgd
08:25:43 <bernalex> ups
08:26:03 <Kaidelong> vanila: it is Monad, and MonadPlus, and a few other abstractions
08:26:12 <bernalex> vanila: well, yes. it even says so.
08:26:16 <vanila> well haskell has that
08:26:21 <Hodapp> I just have a hard time taking anything .NET seriously.
08:26:26 <Kaidelong> vanila: haskell has a small portion of that
08:26:44 <Kaidelong> vanila: computation expressions can do more, IE, a non-mind-bending approach to yield
08:26:51 <bernalex> Hodapp: word. I also have a hard time taking impure FP seriously.
08:27:05 <nbouscal> I find it very annoying when people refuse to call things what they are. "Workflow" doesn't tell me anything about what it is or what I can expect from it, whereas "Monad" gives me an entire literature
08:27:30 <Kaidelong> nbouscal: unfortunately monad also scares the bejeezus out of programmers =(
08:27:40 <nbouscal> anti-intellectualism is not a good excuse for doing things wrong
08:27:45 * monochrom may decide to blame it all on Dijkstra! boolean blindness considered harmful, goto considered friendly with algebraic data types! :)
08:27:45 <Kaidelong> also it would be incorrect in this case since this works for more than just Monad
08:27:47 <Hodapp> nbouscal: oh, I used to work with devs who did that all the time, and it annoyed me something awful. They'd take dirt-simple concepts and name them something else - sometimes, just a catchy name, but sometimes, a name that is just completely wrong.
08:27:58 <bernalex> nbouscal: it's about not scaring e.g. javascript programmers. I disagree with this approach too, as I prefer an initially steep learning curve to having an ill-defined set of semantics.
08:28:08 <bernalex> nbouscal: they're doing the same with elm, calling it "Commands".
08:28:09 <nbouscal> Kaidelong: Mixing together multiple things that ought to be separate also drives me nuts ;)
08:28:15 <Welkin> why build your software on proprietary systems (.NET)?
08:28:41 <nbouscal> Building your abstractions in correspondence with reality (read: mathematics) is the only way to prevent them from leaking
08:28:52 <n-dolio> monochrom: Clearly case analysis isn't structured programming. :)
08:29:05 <bernalex> Welkin: some people are Prosessional Programmers™ and work 9-5 to make money. they hardly care (or even know about) hacker ethic.
08:29:10 <nbouscal> If you build your abstractions around whatever seems convenient at the time, or around some architectural quirk of your current system, you are guaranteeing large amounts of future work
08:29:16 <Kaidelong> nbouscal: it actually works really well for this particular situation, particularly since there isn't some particular type it applies to, it works for anything that implements the methods, less strange when you consider that F# is also OO
08:29:31 <Kaidelong> oh I completely forgot about object expressions
08:29:36 <Eelis> n-dolio: conversely, writing code in pure correspondence with mathematics and no concern about resources is a fantastic way to produce programs that leak like snowden
08:29:40 <Kaidelong> a bit orthogonal comparing to haskell, but object expressions is something C# lacks
08:29:53 <Eelis> sorry, that was for nbouscal
08:29:55 <nbouscal> Another strike against it. "Object-oriented" has no actual semantic value. It's just a buzzword
08:30:32 <nbouscal> Eelis: Of course, but that is a concern at the compiler level, library level at most. It should be encapsulated away from the application programmer.
08:30:40 <vanila> Object-oriented is a programming paradigm
08:30:48 <nbouscal> vanila: What does it mean?
08:30:53 <vanila> like functional, procedural etc
08:30:56 <benj_> what is a paradigm?
08:31:08 <nbouscal> vanila: And then, once you have a meaning, get the main people in the field to agree on that meaning
08:31:09 <tdammers> it means you use "objects" as your building blocks
08:31:10 <Welkin> there is Java OOP then there is Smalltalk OOP
08:31:11 <nbouscal> vanila: I'll be here waiting
08:31:15 <vanila> uh ok bye
08:31:17 <nbouscal> tdammers: what's an object?
08:31:18 <Eelis> nbouscal: that's a nice ideal, but in the mean time i'll keep writing my programs in C++ if i need them to be efficient :)
08:31:33 <bernalex> Welkin: & CSE
08:31:34 <tdammers> nbouscal: a thing that has state and associated behavior
08:31:45 <nbouscal> Eelis: That's fair enough, but emphasis on the if there. Lots of applications do not have efficiency as a top-order priority
08:31:51 <Eelis> true
08:31:55 <Eelis> and for those i use Haskell
08:31:56 <nbouscal> tdammers: A "thing"?
08:32:02 <tdammers> nbouscal: ya
08:32:03 <bernalex> tdammers: I'd say something with data fields & methods to mutate these fields
08:32:09 <bernalex> which is basically the same
08:32:16 <tdammers> bernalex: methods *can* mutate fields
08:32:19 <tdammers> don't have to though
08:32:35 <Hodapp> Welkin: Java OOP is actually a good deal closer to Smalltalk OOP than a lot of OOP...
08:32:37 <tdammers> the unifying principle is that you bundle state with methods
08:32:38 <Kaidelong> Eelis: you may actually want a very strict mathy language when you are concerned about performance in a deep way, although I don't know if those exist right now
08:32:42 <Kaidelong> but in theory they could
08:32:48 <bernalex> tdammers: oh, true.
08:33:06 <monochrom> in reality, "writing code in pure correspondence with mathematics and no concern about resources" has not happened ever outside "hi I'm new to Haskell I'm using Project Euler to learn"
08:33:09 <Hodapp> Writing in C++ for efficiency? You might get some CPU or memory efficiency. Efficiency of expression or of coder time... ehhhh, no.
08:33:18 <Kaidelong> you could have types that encode the run times of actually running the program in some sub turing language
08:33:44 <nbouscal> http://c2.com/cgi/wiki?NobodyAgreesOnWhatOoIs
08:33:44 <Kaidelong> and thus have a proof that your algorithm really runs as fast as you think it does
08:34:02 <monochrom> people who are good at both math and programming know how to calculate their programs' time and space costs
08:34:21 <nbouscal> (Disclaimer again: FP is just as bad as OOP in this regard. Neither term is well-defined.)
08:34:22 <bernalex> nbouscal: you could say the exact same thing about functional programming. it's still a silly argument. everyone knows what type of languages you mean by it. it is a generalisation, and it serves its purpose.
08:34:37 <kazagistar> I think some people agree on what OO is, there are just many such groups that disagree :P
08:34:44 <nbouscal> I disagree that it serves any purpose at all
08:34:59 <nbouscal> When you're talking about F#, Scala, etc, it becomes very unclear what exactly you are getting from this "OOP" business, and whether or not that is valuable at all.
08:34:59 <Eelis> Hodapp: yes, i use C++ instead of Haskell when i need excellent CPU/memory efficiency
08:35:02 <bernalex> nbouscal: sure. you probably disagree that music genres serve a purpose too?
08:35:20 <Kaidelong> "Some people claimed polymorphism and encapsulation as the distinguishing features of object orientation but that falls on its face since both are supported by all major functional languages. "
08:35:28 <bernalex> nbouscal: meanwhile the rest of us are using them to great effect -- namely generalisation.
08:35:36 <nbouscal> bernalex: I disagree with the analogy.
08:35:40 <Kaidelong> wasn't the polymorphism provided by object orientation dual in a deep sense to the polymorphism of functional languages?
08:35:54 <nbouscal> Kaidelong: eh yeah, comonads
08:35:59 <prolugger> paradigms are like luggage. you can't strictly define what any paradigm is, but neither can you define what a luggage is. once you understand this, you become enlighted
08:36:00 <Kaidelong> something about existential rather than universal quantification
08:36:14 <nbouscal> Kaidelong: I dunno that it's dual "in a deep sense", but yes there's some duality available there if you look
08:36:26 <Kaidelong> maybe you could use that as a criteron
08:36:31 <kazagistar> it serves a purpose in that there is software engineering, architecture, and design principles that are specific to certain programming paradigms, like OOP or functional
08:36:37 <Kaidelong> a functional object languages just lets you use both dual concepts idiomatically
08:36:39 <Eelis> prolugger: i think you become enlightened once you stop thinking that you can become enlightened by knowing about "paradigms"
08:36:42 <nbouscal> I'm not saying you can't strictly define OO or FP, I'm just saying that nobody agrees on what they mean
08:36:47 <Kaidelong> but otherwise you define OO as having a dual-parametric type system
08:36:55 <nbouscal> Kaidelong: Everyone disagrees on what the idioms are!
08:37:18 <nbouscal> For decades idiomatic OOP used inheritance, now nobody would pass a code review on code that used inheritance other than in very uncommon situations
08:37:32 <Kaidelong> yeah that's a big irony
08:37:39 <Welkin> a language has idioms
08:37:41 <vanila> there are different types of object oriented programming
08:37:48 <Kaidelong> the "OO" languages now avoid actual OO paradigms in practice
08:37:51 <Kaidelong> that might be a shame
08:38:04 <nbouscal> There are different types of programming that different people call OOP, and nobody agrees on any of it, which is why it's basically a useless term, which is the point I was trying to make originally ten minutes ago :P
08:38:08 <nbouscal> And yes, the same for FP.
08:38:36 <systemfault> “Normal” programmers seem to agree that OOP is “like Java”, no?
08:38:51 <vanila> systemfault, java is just one instance of it though
08:38:53 <kazagistar> that seems reasonable
08:38:53 <nbouscal> But "like Java" in what way? statically typed? uses inheritance? private/public data/functions?
08:38:56 <bernalex> systemfault: depends on their proficiency
08:38:57 <Hodapp> nbouscal: I wouldn't call the term totally useless, I would just call it misused.
08:38:57 <Kaidelong> I really wonder when people are just going to realize that they are writing their code functionally and not really using the advantages of object orientation at all
08:39:01 <Kaidelong> and just decide to ditch OO
08:39:04 <systemfault> vanila: Totally agree.
08:39:04 <vanila> systemfault, there are very different OO systems
08:39:07 <Hodapp> Kaidelong: HAHAHAHAHAHAHA
08:39:11 <Hodapp> Kaidelong: Good luck with that one.
08:39:19 <nbouscal> Hodapp: Any term can be *made* useful if the people in the conversation nail it down and then use it one way. That doesn't mean that they commonly *are* useful
08:39:25 <prolugger> nbouscal: no one can agree on what a luggage is, yet is luggage useless? no, it is just a word that is unnecessary most of the time
08:39:28 <systemfault> vanila: I know, I personally just know “Java-OO” and “prototypal OO” because of JS
08:39:47 <nbouscal> prolugger: I don't think it's that hard to agree on what a luggage is. It's a container that you use to carry stuff. That's fine enough for that term.
08:39:47 <Hodapp> nbouscal: what I mean is that the *term* is awful, but the concept (given what it originally referred to) is meaningful.
08:39:53 <int-e> benzrf: I'm not around much recently, sorry
08:40:06 <nbouscal> Hodapp: I think it originally referred to a few different concepts, each of which is meaningful and useful, yes.
08:40:17 <kazagistar> just because there are other ways of defining OOP does not mean that most people do it that way. Java-like OOP (with C# and friends) and smalltalk-like OOP (with javascript and friends) seems to cover what most people see and learn
08:40:21 <Hodapp> nbouscal: Alan Kay has made it quite clear what his original definition was.
08:40:27 <prolugger> nbouscal: is a car a luggage then?
08:40:28 <nbouscal> Hodapp: As has Kristen Nygaard, and they're different
08:40:42 <Hodapp> nbouscal: Alan Kay also invented the term.
08:40:55 <Kaidelong> I don't think he did actually
08:40:57 <benzrf> sup int-e
08:40:58 <nbouscal> prolugger: We're arguing about completely different things. You're just trying to argue that many words have vague meanings. I'm arguing that OOP points to multiple distinct groups of concepts, each of which is vague. Different things.
08:41:06 <kazagistar> nbouscal: that is not a good definition of luggage because things that are not luggage match the term, like crates
08:41:09 <systemfault> kazagistar: Most people have no idea of what Smalltalk or Self are… so for them OO == classes + private/protected/public and inheritance.
08:41:16 <Kaidelong> wasn't Modula-7 the first "object oriented" language and wasn't object orientation first done in C as a practice?
08:41:20 <benzrf> int-e: i was gonna try writing a little addon to lambdabot to allow @letting from lpastes
08:41:21 <systemfault> Of course, it’s just my opinion...
08:41:22 <nbouscal> Hodapp: Alan Kay and Kristen Nygaard have roughly equal claim to being the originators of OOP. Either one of them has a fair claim to defining the term, and they define it differently.
08:41:37 <benzrf> it would be nice to have the browser util module from that subproject in this one
08:41:41 <Kaidelong> by systems developers, of all people
08:41:43 <benzrf> should i just copy it, or is there a way to import it?
08:41:45 <kazagistar> systemfault: a LOT of people have been exposed to the style by javascript though, even in a butchered form
08:41:54 <nbouscal> kazagistar: Yeah, I shouldn't have risen to the bait. Point is I'm not just talking about vagueness, I'm talking about multiple distinct definitions rather than one vague concept-cloud.
08:42:04 <systemfault> kazagistar: They usually don’t understand prototypes though and try to emulate “Java” classes in it
08:42:11 <Hodapp> "Object-oriented programming enables software developers to manage the complexity of computer systems.[citation needed]"
08:42:15 <IvoryTower> luggage is also uncountable, so saying a luggage is kind of abusing the term slightly
08:42:23 <vanila> luggage is just something you lug, right?
08:42:24 <Hodapp> if there ever were a place in Wikipedia that needed a citation, that is one :)
08:42:25 <levi> First OOP programming techniques were probably used in Ivan Sutherland's Sketchpad.
08:42:29 <nbouscal> IvoryTower: That depends on the dialect of english, i believe
08:42:31 <Kaidelong> I've taken to just thinking that Javascript is like Lua except it's in denial and still calls them objects
08:42:50 <monochrom> no, I hold it axiomatic that Hoare and Dahl invented OOP in their chapter in the book Structured Programming
08:42:54 <Kaidelong> much easier to just think of them as the dictionaries that they are
08:42:58 <IvoryTower> nbouscal: ok, I'll accept that,
08:43:01 <Hodapp> levi: Or they were probably used forever ago, because the term is that vague.
08:43:19 <nbouscal> The entire point is that there are multiple OOPs and so rather than using the term OOP at all, we should talk about the things that it is a pointer to. e.g. dictionaries, etc.
08:43:36 <kazagistar> Kaidelong: Python has a similar case of denial, and its OOP is far more java-like
08:43:47 <Hodapp> I'm fine with that as long as we can call the C++ variant "some crashy class-based nonsense"
08:44:01 <nbouscal> Hodapp: I'd never prevent anyone from describing C++ that way ;)
08:44:10 <levi> Hodapp: Sketchpad could probably be considered "forever ago"; it was a pretty early program.
08:44:36 <kazagistar> "class based type inheritence" "prototype based type inheritance"
08:44:39 <IvoryTower> nbouscal: it's uncountable in British English according to the British council - https://learnenglish.britishcouncil.org/en/grammar-reference/countable-uncountable-nouns-2
08:44:44 <Hodapp> Thus spake the LORD, "And ye shall let your classes inherit from other classes, though you may never instantiate them, for this is the way of INTERFACES."
08:44:50 <vanila> haha
08:45:02 <IvoryTower> and in AMerican English, not sure how many regions are left, but I won't disagree that there might be one where it's countable
08:45:12 <kazagistar> what is the name for mixing modules and polymorphism on the first parameter togeather?
08:45:12 <nbouscal> IvoryTower: Interesting. I'm American, and have it's uncountable here, but I distinctly remember hearing it used countably in the past so I assumed it was regional.
08:45:14 <IvoryTower> anways, I don't want to digress the conversation
08:45:18 <Hodapp> "bro, why do you have so many luggages?"
08:45:31 <Kaidelong> Hodapp: interface spam is people lamenting not having typeclasses
08:45:37 <k00mi> can everyone move the OOP discussion to #haskell-blah? it's diverged pretty far from anything haskell-related
08:45:40 <Welkin> speaking of python, the idiomatic (pythonic) way is to avoid using classes
08:45:42 <Kaidelong> I am very guilty of that
08:46:01 <Welkin> and to use functions instead
08:46:05 <IvoryTower> I would say that anyone who said "so many luggages" spoke poor English myself.
08:46:15 <IvoryTower> The same as saying I have many water
08:46:17 <int-e> benzrf: you're talking about lambdabot-reference-plugins and lambdabot-haskell-plugins? I see no fundamental reason why one should not depend on the other, though perhaps starting a lambdabot-util subproject is also an option.
08:46:24 <IvoryTower> it should be I have much water
08:46:25 <kazagistar> blah seems like a good place to talk OOP :P
08:46:25 <hiptobecubic> this is a pretty long discussion
08:46:32 <benzrf> int-e: think itd be ok to just copy the file for now
08:46:41 <benzrf> symlink it, maybe?
08:47:44 <benzrf> meh ok i'll make haskell depend on reference
08:55:05 <knapper_tech> how do i statically link a binary in cabal config
08:55:59 <rwbarton> executable-dynamic: False
08:56:33 <rwbarton> which is the default AFAIK
09:16:50 <pjdelport> kazagistar: Python's OOP is much more like CLOS or Dylan than something like Java.
09:27:07 <georgy3> hello. I am struggling to understand how seq works. I thought I got it, but it appears I didn't
09:27:20 <georgy3> > let x = 1; xs = undefined in xs `seq` head $ x:xs
09:27:21 <lambdabot>  *Exception: Prelude.undefined
09:27:24 <georgy3> ^^ works as expected
09:27:35 <georgy3> > let x = 1; xs = [undefined] in head $ x:xs
09:27:36 <lambdabot>  1
09:27:47 <georgy3> but why am I not getting exception there too?
09:28:32 <quchen> let x = 1; xs = [undefined] in head $ x:xs   ≡   head $ 1:[undefined]   ≡   1
09:28:44 <rwbarton> @src head
09:28:45 <lambdabot> head (x:_) = x
09:28:45 <lambdabot> head []    = undefined
09:29:10 <rwbarton> head (x:_) = x, so head (1:[undefined]) = 1
09:29:29 <vanila> [undefined] is  (:) undefined []
09:29:42 <vanila> the spine is (:) and it doesn't need to inspect undefined or []
09:29:54 <rwbarton> Even xs = undefined (rather than [undefined]) would yield the same result
09:29:58 <vanila> > let x = 1; xs = (:) undefined undefined in xs `seq` (head $ x:xs)
09:29:59 <lambdabot>  1
09:30:08 <vanila> > let x = 1; xs = undefined in xs `seq` (head $ x:xs)
09:30:10 <lambdabot>  *Exception: Prelude.undefined
09:30:34 <vanila> this fails because xs has no weak head normal form (you can't find out what constructor it is going to be, [] or (:))
09:30:49 <rwbarton> georgy3: Did you mean to write "xs `seq` head $ x:xs" in your second example?
09:31:13 <georgy3> yes sorry
09:31:31 <rwbarton> ok right, then listen to vanila :)
09:31:34 <georgy3> > let x = 1; xs = [undefined] in xs `seq` head $ x:xs
09:31:36 <lambdabot>  1
09:31:41 <georgy3> I am still processing it
09:32:13 <georgy3> I guess my problem is that I don't know what "head normal form" means. documentation of seq mentions it too
09:33:16 <quchen> "seq x y" is ⊥ if any of its arguments is ⊥, otherwise it is identical to y.
09:34:11 <pjdelport> georgy3: http://www.haskell.org/haskellwiki/Weak_head_normal_form / https://en.wikibooks.org/wiki/Haskell/Graph_reduction#Weak_Head_Normal_Form / http://stackoverflow.com/q/6872898/444705
09:35:12 <georgy3> I will read it
09:35:18 <rwbarton> I wonder why it says "head normal form" and not "weak head normal form"
09:37:04 <georgy3> rwbarton the two mean different things?
09:37:30 <n-dolio> It was probably written before people came up with weak head normal form, and never revised.
09:39:36 <zwer> > let x = 1; xs = [undefined] in xs `deepseq` head (x:xs)
09:39:37 <lambdabot>  Not in scope: ‘deepseq’
09:40:08 <rwbarton> georgy3: Yes, but head normal form is not relevant to Haskell
09:46:23 <Trollinator> deepseq can't be written in Haskell, can it?
09:46:42 <zwer> @hoogle deepseq
09:46:44 <lambdabot> Control.DeepSeq deepseq :: NFData a => a -> b -> b
09:46:44 <lambdabot> package deepseq
09:46:44 <lambdabot> package deepseq-generics
09:46:51 <c_wraith> Trollinator: deepseq is written in haskell.
09:46:56 <kazagistar> Trollinator: sure it can, in terms of seq
09:46:59 <c_wraith> Trollinator: but it depends on seq, which cannot
09:47:03 <rwbarton> Not as a magically polymorphic function
09:47:41 <rwbarton> In fact, you don't really need seq to write deepseq, in some sense
09:47:58 <c_wraith> That's true
09:48:01 <jfischoff> oh
09:48:07 <c_wraith> I forgot that detail
09:48:14 <jfischoff> I would like to know
09:48:16 <kazagistar> @hoogle deriveNFData
09:48:17 <lambdabot> No results found
09:48:24 <kazagistar> hmm oh well
09:49:20 <c_wraith> since deepseq actually has a class, it *could* be written without seq.  Though it wouldn't be possible to write a couple instances that are possible with seq, like for (a -> b)
09:49:29 <rwbarton> right
09:50:08 <jfischoff> but how do you set up evaluation dependencies without seq?
09:50:46 * hackagebot hs-nombre-generator 0.2.0.0 - Name generator.  http://hackage.haskell.org/package/hs-nombre-generator-0.2.0.0 (alvare)
09:51:04 <rwbarton> well, for Bool for example, you can define "seq False x = x; seq True x = x"
09:51:24 <jfischoff> ah
09:51:32 <jfischoff> I see
09:52:05 <jfischoff> so seq really could be a typeclass method
09:52:34 <kazagistar> seq forces weak head normal form, and so does one level of pattern matching
09:52:46 <benzrf> kazagistar: it does in ghc, anyway
09:53:08 <jfischoff> well minus the issue c_wraith brought up, when you don’t have constructors
09:55:48 <yitz> jfischoff: the only thing you can't write seq for in haskell98 is functions. some people disagreed with the decision to provide seq for functions in haskell98.
09:56:21 <jfischoff> what is the argument against providing seq for functions?
09:58:11 <yitz> jfischoff: it has to do with whether you consider \_ -> undefined and undefined to be the same.
09:59:12 <jfischoff> what are the arguments for and against \_ -> undefined being the same as undefined?
10:00:30 <kazagistar> seq tends to be an optimization, and it seems like those two might have different real world performance capabilities? dunno
10:00:58 <kazagistar> <- no idea what I am talking about, disregard
10:05:55 <yitz> jfischoff: eta-conversion says that f is the same thing as \x -> f x. but seq for functions breaks that.
10:06:08 <jfischoff> right
10:06:27 <yitz> jfischoff: see the bottom of http://www.haskell.org/haskellwiki/Seq, and see also http://stackoverflow.com/questions/12687392/why-is-seq-bad
10:06:35 <quchen> jfischoff: As for "for", `const ⊥` is observationally ⊥, so it would make sense to have `const ⊥ ≡ ⊥`.
10:07:52 <yitz> jfischoff: it breaks anything that depends on eta-conversion working properly; some optimizations, free theorem generators, other stuff
10:08:00 * jfischoff nods
10:08:33 <yitz> jfischoff: otoh - occasionally it's handy in practice to have seq for function types...
10:10:20 <Pythonfant> I'm trying to understand a bit of cathegory in relation to haskell, however I'm a bit confused: it seems to me like an instance of functor is not actually a functor but the cathegory the functor maps to. So for list the functors maps from types to lists
10:11:10 <cstanfill> Pythonfant: All instances of functor, as I understand it, are endofunctors from Hask to Hask
10:12:37 <ReinH> jfischoff: hi <3
10:12:52 * jfischoff waves at ReinH 
10:13:10 <cstanfill> Pythonfant: the objects of the source category are types, not instances; you map the type (object) a to [a], and the function (morphism) f :: a->b to fmap f :: [a] -> [b]
10:13:28 <jfischoff> ReinH: just got my copy of categories for the working mathematican
10:13:34 <ReinH> jfischoff: yay!
10:13:46 <ReinH> jfischoff: I just got my copy of Bird's Algebra of Programming!
10:13:51 <Pythonfant> cstanfill: yes but list describes the [a] and not the mapping you're describing?
10:14:06 <jfischoff> and the Steve Awodey categories book
10:14:13 <jfischoff> ReinH: dope
10:14:38 <ReinH> Pythonfant: Can you define a functor in category theory?
10:15:11 <ReinH> jfischoff: I think you'll enjoy those, and if you want to learn some algebra I highly recommend Mac Lane's Algebra as well.
10:15:22 <jfischoff> cool
10:15:26 <ReinH> in fact his Algebra is a good intro for his CftWM too
10:15:27 <cstanfill> Pythonfant: well it's a bit odd with lists because [] can be used to construct both the type and the list
10:15:47 * jfischoff nods
10:15:49 <ReinH> Pythonfant: Once we have a definition of functor we can see how it might map to the Functor typeclass
10:15:52 <Pythonfant> ReinH: not sure, I thought it consists of two mappings one from the objects to the objects in the other cathegory and one for arrows, that satisfy the laws
10:16:04 <ReinH> Pythonfant: sounds about right.
10:16:12 <Pythonfant> so the laws apply for fmap
10:16:20 <ReinH> Pythonfant: So if Functor has something to do with CT functors, we need to find an arrow mapping and an object mapping.
10:16:24 <ReinH> :t fmap
10:16:26 <lambdabot> Functor f => (a -> b) -> f a -> f b
10:16:30 <rwbarton> Pythonfant: btw, there's no h in category
10:16:37 <ReinH> you can bracket that as: Functor f => (a -> b) -> (f a -> f b)
10:16:41 <Pythonfant> rwbarton: thx, I always get that wrong
10:16:48 <yitz> Pythonfant: instance Functor Foo means: type constructor Foo "has kind * -> *", i.e, maps types to types. as such, it can actually be thought of as an endofunctor of Hask, with the following definition of fmap providing the mapping from a->b to Foo a->Foo b.
10:17:02 <ReinH> Pythonfant: which makes it pretty plain that fmap is a mapping between an arrow and an arrow. The arrows are right there, after all. ;)
10:17:10 <ReinH> Pythonfant: But what about the object mapping?
10:17:22 <ReinH> Pythonfant: If arrows in this category are functions, what would the objects be?
10:18:01 <Pythonfant> instances of types?
10:18:07 <ReinH> Pythonfant: Let's try that out.
10:18:18 <ReinH> What would a type mapping be in Haskell?
10:18:35 <Pythonfant> a data constructor
10:18:43 <ReinH> Pythonfant: A data constructor is a function.
10:19:04 <ReinH> It is a value mapping, not a type mapping.
10:19:08 <ReinH> But close.
10:19:26 <Pythonfant> hm
10:19:32 <ReinH> Pythonfant: how do we define an instance of Functor?
10:19:47 <ReinH> can you give me an example of one?
10:20:42 <ReinH> just the first one that comes to mind
10:21:19 <Pythonfant> fmap = map
10:21:21 <Pythonfant> for lists
10:21:30 <Pythonfant> so instance Functor [] where fmap = map
10:21:32 <ReinH> Ok, so how do you write the instance?
10:21:33 <ReinH> Right
10:21:34 <ReinH> So.
10:21:36 <ReinH> :k []
10:21:38 <lambdabot> * -> *
10:21:46 <ReinH> [] is a *type constructor*
10:22:00 <ReinH> A type constructor of kind * -> * is a mapping from a type to a type
10:22:07 <tommd> Doesn't help that is it a constructor at the value level too.
10:22:13 <ReinH> tommd: that's true
10:22:16 <ReinH> Let's use Maybe instead
10:22:21 <ReinH> :k Maybe
10:22:22 <lambdabot> * -> *
10:22:38 <ReinH> Pythonfant: So, type constructors give us our object mapping.
10:22:57 <Pythonfant> ah that seems logical
10:23:12 <ReinH> Pythonfant: So in Haskell, an instance of Functor is a functor that maps types to types and functions to functions within the ambient category of Haskell types and functions commonly known as Hask
10:23:31 <ReinH> Since they stay within that category, they are endofunctors.
10:23:50 <cstanfill> tommd: yeah I think that's where some of the confusion is coming from
10:23:56 <Pythonfant> thx for your detailed explanation I think I got it now
10:24:01 <ReinH> Pythonfant: np :)
10:24:08 <averell> and I did too. please ask another such question :)
10:24:44 <Pythonfant> averell: I'm trying to work myself through categories for the working mathematician so I'll surely have a lot more questions :)
10:24:53 <ReinH> Pythonfant: fun!
10:25:03 <ReinH> Maybe we should set up a study group with jfischoff
10:26:10 <yitz> i think just about anything in mac lane beyond what ReinH just explained is really for #haskell-in-depth, not for here.
10:26:27 <ReinH> yitz: or ##category-theory :)
10:26:41 <ReinH> without the dash
10:28:01 <phaazon> hey
10:28:10 <phaazon> is there a way to cross-compile to ARM?
10:28:12 <phaazon> with GHC
10:29:08 <phaazon> or do I have to install it on the ARM machine?
10:29:09 <tommd> phaazon: What platform?
10:29:25 <tommd> You can use ghc-android and there is some work on ios-android.
10:29:31 <phaazon> raspi, tommd
10:29:45 <rwbarton> yes*   (* some restrictions may apply)
10:29:46 <tommd> phaazon: But, say, a generic Linux I think you're better off using a native ARM ghc.
10:30:16 <tommd> And there is lots of fighting the tool-chain when you cross compile.
10:30:17 <phaazon> tommd: hm, ok
10:30:44 <rwbarton> no Template Haskell will limit what you can cross-compile
10:30:46 <phaazon> ok, I see
10:30:47 <tommd> TH is a prime example, but cabal in general likes to assume host == target.  Sometimes the cabal packages assume that much too.
10:31:03 <phaazon> is ghc available in debian arm ?
10:31:09 <tommd> yep
10:31:13 <phaazon> it seems it’s not in alarmpi :(
10:31:15 <phaazon> oh, great
10:31:20 <phaazon> gonna flash it then :)
10:31:34 <phaazon> I’m trying to put my happstack server on it :D
10:31:40 <tommd> I blogged about this back in 2010.  The situation has almost certainly improved even more since.
10:32:10 <rwbarton> Yeah, you don't want to cross-compile then.
10:32:20 <rwbarton> (Currently.)
10:32:28 <phaazon> ok
10:32:40 <Gurkenglas> So http://www.haskell.org/haskellwiki/Typeclassopedia#Laws says that any Functor instance satisfying (fmap id = id) will automatically satisfy (fmap (g . h) = (fmap g) . (fmap h)), but this seems obviously false: instance Functor [] where fmap g [] = [], fmap g (x:xs) = if (g x == x) then (x : fmap g xs) else (g x : g x : fmap g xs) should satisfy the first, but not the second
10:33:17 <rwbarton> Gurkenglas, try compiling that
10:34:06 <Gurkenglas> Yea, the comma doesn't work but I didn't want to use a newline. Also I copied the syntax used on http://www.haskell.org/haskellwiki/Typeclassopedia#Laws, does it not work?
10:34:13 <phaazon> http://www.raspberrypi.org/downloads/
10:34:14 <phaazon> huhu
10:34:17 <ReinH> :t (==)
10:34:19 <lambdabot> Eq a => a -> a -> Bool
10:34:25 <phaazon> there’re a lot of debian systems for raspi
10:34:27 <benzrf> Gurkenglas: Eq constriaint
10:34:28 <phaazon> which one to pick?
10:34:31 <rwbarton> Gurkenglas, try compiling what you meant :)
10:34:33 <phaazon> rasbian ?
10:34:38 <phaazon> raspbian*
10:34:47 <quchen> This is not a Raspberry Pi channel.
10:35:13 <phaazon> yeah well, we talked about that something
10:35:18 <phaazon> one minute ago
10:35:34 <phaazon> I’m looking for a way to get a ghc on raspi
10:35:40 <Gurkenglas> No idea how to write that such that it compiles, I'm reading the typeclassopedia cause http://dev.stephendiehl.com/hask/#monads told me to. I'll try to find a way
10:35:53 <quchen> Raspbian has GHC 7.4, maybe even 7.6, in the repos.
10:36:07 <rwbarton> you can define your own Functor' class so it doesn't conflict with the existing instance
10:36:41 <ReinH> You can also write your own list type :)
10:39:11 <jle`> Gurkenglas: the problem is that you need an Eq constraint for that definition
10:39:36 <jle`> Gurkenglas: typeclass constraints, all bets are off for parametricity
10:39:39 <Gurkenglas> jle', oh, okay
10:39:43 <jle`> id :: a -> a
10:39:47 <jle`> only has one possible implementation
10:39:51 <jle`> const :: a -> b -> a
10:39:54 <jle`> only has one posible impementation
10:39:59 <jle`> id :: Eq a => a -> a
10:40:03 <jle`> er
10:40:10 <jle`> let me think about this
10:40:32 <ReinH> jle`: it's a restriction
10:40:46 <jle`> i'm trying to show that it ruins paraemtricity
10:40:50 <ReinH> It doesn't.
10:40:51 <jle`> but i think i gave a bad example
10:40:53 <jle`> darnit :'(
10:41:02 <jle`> T.T
10:41:03 <rwbarton> how about Num
10:41:04 <nomeata> id :: Num a => a -> a
10:41:06 <ReinH> It leads to more proofs.
10:41:08 <nomeata> that has many implementations
10:41:14 <jle`> ah
10:41:23 <ReinH> Restricting the theorem makes it easier to prove :)
10:41:24 <jle`> it doesn't ruin parametricity, but it doesn't just have one implementation
10:41:29 <nomeata> (basically any type class with an a on the right of the arrow of a method)
10:42:10 <ReinH> That thing about Foldable and Buildable had a nice discussion of this
10:42:39 <Gurkenglas> No, no, I got it by the time I said oh, okay
10:42:50 <jle`> Gurkenglas: Functor is supposed to be parameterized on *all* a, or fmap on *all* (a -> b)... so if you limit it to only (a -> a)'s and Eq a's, then you have different proofs and theorems
10:42:57 <Gurkenglas> (Umm, at 38:13)
10:43:00 <jle`> ah ok
10:43:09 <jle`> ReinH: really? i will give it another read
10:43:34 <ReinH> jle`: right at the end, iirc
10:44:01 <ReinH> jle`: hmm maybe I'm wrong
10:44:53 <jle`> you have reminded me that I never finished the article for some reason
10:44:59 <jle`> thanks
10:45:13 <ReinH> np
10:45:15 <napping> Would (Endo (Set Sort)) be significantly faster than Set Sort for accumulating a smallish set of items?
10:45:33 <ReinH> napping: profile it?
10:46:58 <tommd> mokus: Ping!
10:49:30 <Gurkenglas> "Unlike some other type classes we will encounter, a given type has at most one valid instance of Functor." <- Let me guess, this is done via showing some universality argument from Category theory?
10:49:36 <Gurkenglas> -showing
10:52:28 <napping> ReinH: I'll see if the simple way is slow
10:53:11 <napping> Gurkenglas: fmap id = id is pretty strong, not sure how you get the rest
10:53:44 <rwbarton> it's not really a fact from category theory
10:53:54 <Gurkenglas> Guessed poorly then
10:54:07 <augur> RIP jim lambek :(
10:59:23 <phi__> using ad is there a way to write something like diff(f(x(t)) , diff(x(t) ) ) ? Forgive my notation.
11:00:34 <napping> Gurkenglas: You can get somewhere for invertible functions
11:01:23 <kazagistar> phi__: I am not sure what diff is.... what is its type?
11:01:26 <napping> no, I guess not
11:01:28 <pjdelport> phi__: ap or ad?
11:01:48 <phi__> it is derivative from Edawrd Kmett's ad
11:01:56 <simukis_> automatic differentiation
11:02:04 <phi__> pjdelport my bad
11:02:25 <phi__> ad actually, sorry again
11:02:27 <rwbarton> you can try asking on #haskell-lens also
11:02:29 <alpounet> phi__: it should be possible yeah
11:02:51 <kazagistar> I just saw it take both 1 and 2 parameters :P
11:03:34 <phi__> the problem is derivative is not (a -> a) -> a -> a so I have not been able to really write it
11:04:31 <phi__> kazagistar it can take any number of parameter
11:04:53 <pjdelport> (diff `fmap` f . x `ap` diff . x) t  -- using ap?
11:04:56 * pjdelport ducks
11:05:33 <benzrf> pjdelport: u should use (<*>), not ap
11:05:51 * hackagebot FixedPoint-simple 0.6.1 - Fixed point, large word, and large int numerical representations (types and common class instances)  http://hackage.haskell.org/package/FixedPoint-simple-0.6.1 (ThomasDuBuisson)
11:13:05 <jle`> diff (f (x t)) (diff (x t)) ?
11:14:19 <jle`> ap (fmap diff (f . x)) x
11:14:30 <jle`> $ t
11:14:52 <jle`> but this is why (<*>) and (<$>) exist too
11:14:54 <jle`> heh
11:15:15 <jle`> still in real code you should probably just write it all out
11:17:18 <kazagistar> jle`: the compiler can extract common subexpressions anyways, right?
11:17:41 <phi__> No jle I'm pretty sure that  does not work, f is supposed to take two arguments
11:17:57 <jle`> phi__: it looks like f only takes one argument in what you wrote
11:18:09 <jle`> kazagistar: oh i didn't realize the common subexpression part
11:18:52 <phi__> Sorry if I was not clear. f takes two arguments. We supply it with (x t) and (diff (x t))
11:19:25 <jle`> in the case of eliminating applying x twice you can do: ap (diff . f) diff $ x t
11:19:27 <jle`> ah ok
11:19:33 <jle`> so is it
11:19:40 <jle`> diff (f (x t) (diff (x t)) ?
11:19:49 <jle`> with another parentheses
11:19:54 <jle`> diff (f (x t) (diff (x t)))
11:20:27 <phi__> that will not compile I feel sure of that
11:20:36 <jle`> i'm not sure what you are asking
11:20:40 <jle`> what are you trying to write?
11:20:52 <jle`> can you give types?
11:20:52 * hackagebot sgf 0.1.3.1 - SGF (Smart Game Format) parser  http://hackage.haskell.org/package/sgf-0.1.3.1 (tonicebrian)
11:21:19 <rwbarton> you just want to take the partial derivative of f with respect to the second argument right?
11:21:23 <jle`> in the first thing you wrote, f takes one argument; in the thing i wrote again, f takes two arguments --- x t and diff (x t)
11:22:11 <mokus> tommd: Pong!
11:22:45 <jle`> t:: a; x :: a -> a; diff :: a -> a; f :: a -> a -> a
11:22:56 <phi__> jle` this valid code if diff has type like (a -> a) -> a -> a, which would be direct translation from math, but that is not diff's type here http://hackage.haskell.org/package/ad-4.2.0.1/docs/Numeric-AD.html
11:23:12 <tommd> mokus: Would you accept PolyKinds in dependent map?
11:23:14 <phi__> I want ad equivalent of this expression
11:23:24 <tommd> mokus: We have a project need and would rather not maintain a one-off package.
11:23:32 <mokus> tommd: certainly.  If I had more time to work on Haskell stuff these days I'd even do it myself for you :)
11:24:14 <tommd> We'll send you a patch, does that work?
11:24:32 <mokus> tommd: sure, email or git pull-request are both fine
11:24:39 * kazagistar looks up Smart Game Format and is horrified to find another random makeshift data storage format
11:24:41 <tommd> mokus: Great, pull request in-bound.
11:24:47 <mokus> tommd: cool, thank you
11:24:52 <jle`> phi__: so what is it that you want to write?
11:25:20 <jle`> ah this is using ad, not ap haha.
11:25:27 <jle`> i missed the correction to the correction
11:25:49 <phi__> sorry for that
11:25:55 <jle`> can you state what you want to write using math terminology, or in english?
11:26:26 <jle`> you want to find derivative of f(x(t)), at the point x(t) ?
11:27:16 <rwbarton> sort of lame but maybe you could do it with grad
11:28:44 <phi__> I have a function f which has two argument. But I can convert it into a single argument function by supplying the first argument as (x t) where x is a one argument function and the second with derivative of x at t. I want the derivative of this function
11:29:15 <rwbarton> oh
11:29:18 <rwbarton> that's not what I thought at all
11:29:33 <phi__> rwbarton grad is partial derivative I want the total derivative
11:30:04 <rwbarton> I thought you wanted the derivative w.r.t. the second argument (like in the Euler-Lagrange equation)
11:30:33 <phi__> I actually really want to translate the euler lagrange equations to ad language
11:31:03 <rwbarton> I suppose you can just be boring and use the chain rule
11:31:59 <rwbarton> hmm, doesn't diff (\t -> f (x t) (diff x t)) just work, as long as x is polymorphic
11:32:30 <rwbarton> (and if x isn't polymorphic, then you can't use ad at all anyways)
11:33:55 <phi__> but there after grad you also have to take a total time derivative and I have not been able to do so
11:34:47 <rwbarton> let f x x' = x' * x' / 2 - x; x t = sin t in diff (\t -> f (x t) (diff x t)) 1
11:35:58 <Rufflewind_> This might be nitpicking but it looks like c2hs just uses CInts for C enumerations -- how portable is this?
11:39:08 <phi__> yeah I guess it does work what does not work is if I want a partial derivative in between which is what I need for euler lagrange
11:39:37 <rwbarton> that's what I was suggesting using grad for
11:39:37 <phaazon> <3 raspbian has ghc
11:39:41 <phaazon> it’s gonna be just GREAT
11:40:10 <rwbarton> but maybe there's a nicer way
11:40:29 <rwbarton> grad (\[x,x'] -> f x x') !! 1
11:40:44 <rwbarton> erm, plus another argument to grad
11:42:17 <kwf> mokus: Pull request sent! :)
11:42:36 <phi__> rwbarton you are suggesting something like diff (\t -> (!! 1) . grad l $ [f t , diff f t]) x
11:42:50 <phi__> right?
11:43:42 <rwbarton> uhh right I hadn't thought about the next derivative yet
11:44:58 <rwbarton> something like that, does that work?
11:46:08 <rwbarton> Also, I still think you should ask on #haskell-lens. :)
11:46:15 <blablub> the GHC docs say that a handle in binary mode would not convert strings, but string literals in the source seem to get converted from utf-8 to latin-1. how can i prevent this?
11:46:19 <phi__> For general l , f and x it needs a type signature, I am trying to fiugre out what it is
11:46:34 <rwbarton> some time when ed is around
11:47:50 <rwbarton> blablub: string literals in the source are converted from utf-8 to Unicode strings (lists of Unicode code points)
11:48:38 <blablub> rwbarton: but when i output such a string to stdout, it gets converted to latin1 (or sth similar)
11:48:51 <rwbarton> well, sort of
11:49:14 <rwbarton> if the handle is in binary mode, then it outputs the byte n if the Unicode code point is n where 0 <= n <= 255, and otherwise raises an exception
11:49:18 <blablub> rwbarton: when i set the output encoding to utf-8, everything is fine, but when i turn on binary mode, it does the conversion again
11:49:48 <blablub> rwbarton: ok, that is not what i intended
11:49:59 <blablub> rwbarton: i hoped that it could just copy the string verbatim
11:50:11 <rwbarton> well, there is no "the string verbatim"
11:50:28 <blablub> rwbarton: i see. then maybe i have to resort to sth like bytestrings instead
11:50:43 <rwbarton> I would recommend that, yes
11:50:54 <blablub> rwbarton: hm, that won't work either, they only support char8
11:50:59 <rwbarton> don't use Char8
11:51:16 <rwbarton> instead, convert explicitly from String (or Text) to ByteString using the encoding you choose (utf-8 in this case)
11:51:37 <blablub> rwbarton: aren't word8 and char8 the only options with bytestrings? maybe i should pick text then ...
11:52:16 <blablub> rwbarton: ok, i didn't know that bytestrings could do this, will dig into the docs now. thanks for the hint
11:52:33 <rwbarton> I'm not sure where to find such conversion functions exactly.
11:52:55 <rwbarton> oh, text has some. I would use those
11:53:12 <rwbarton> http://hackage.haskell.org/package/text-1.1.1.3/docs/Data-Text-Encoding.html#g:5
11:53:41 <luite> those in text will fail on the Addr# things from string literals though
11:53:53 <rwbarton> I don't know what would happen if you just tried to write a Text to a handle in binary mode (using Data.Text.IO)
11:54:44 <rwbarton> right, you will have to use T.pack (or OverloadedStrings) and there will be an extra conversion internally
11:54:55 <Lutin`> There's also http://hackage.haskell.org/package/utf8-string-0.3.6/docs/Data-ByteString-Lazy-UTF8.html
11:55:05 <Lutin`> But I've never used it and I'm not sure of it's current status
11:55:07 <blablub> rwbarton: i think i found a solution. i will try utf8-string to convert the utf-8 chars to 8bit chars and use the handle in binary mode
11:56:07 <wz1000> Are there any haskell equivalents to Java's reflection or Python's inspect module?
11:56:37 <Lutin`> blablub: Also look at http://hackage.haskell.org/package/utf8-string-0.3.8/docs/System-IO-UTF8.html
11:56:41 <rwbarton> That should work too.
11:57:39 <luite> rwbarton: oh i mean that string literals are compiled to modified utf8, so you can't use some tricks to get the Addr# into a ByteString and decode it with Data.Text.Encoding
11:58:05 <blablub> rwbarton: usually i would pick text, but this time i need to output potentially broken utf-8 without the program crashing because of encoding errors, therefore this hack with utf8-string
12:00:10 <blablub> wz1000: i don't think that there is, but check out template haskell if you want to have a similar functionality at compile time, or data/typeable if at runtime
12:00:35 <mokus> kwf: accepted and uploaded to hackage as 0.2.1.0
12:00:56 * hackagebot dependent-sum 0.2.1.0 - Dependent sum type  http://hackage.haskell.org/package/dependent-sum-0.2.1.0 (JamesCook)
12:01:10 <phi__> rwbarton let f k = sin k in diff (\t -> (!! 1) . grad (\[x,y] -> exp x + cos y) $ [f t , diff f t]) 3 compiles
12:01:40 <phi__> but can't write down the type singature
12:03:30 <phi__> I mean for the fucntion go l f x =  diff (\t -> (!! 1) . grad l $ [f t , diff f t]) x
12:04:06 <rwbarton> yeah, it needs some polymorphic type which ghc can't infer...
12:04:19 <wz1000> blablub: I was looking for a way to inspect the contents of values while debugging in GHCi
12:04:43 <phi__> it need some crazy combination of foralls which I can't figure out
12:06:07 <blablub> wz1000: if you just want to have a string representation, then have Show instances for the types of the values you want to see
12:06:59 <phi__> I guess I will have to somehow ask edwardk
12:07:33 <wz1000>  blablub: I wanted a more detailed internal representation, including how much has been evaluated, and what is still left as a thunk
12:08:01 <edwardk> phi__: sup?
12:08:06 <napping> Is \a b c -> a c b c any standard combinator?
12:08:15 <blablub> wz1000: ah, i see. i think you can do this with ghci, but honestly, i haven'tused it yet, so don't know how
12:08:30 <phi__> edwardk what is the type of go l f x =  diff (\t -> (!! 1) . grad l $ [f t , diff f t]) x
12:08:49 <phi__> ghc can figure it out but you surely can
12:08:56 <edwardk> heh, nice try ;)
12:09:01 <phi__> sorry meant ghc can't
12:09:19 <blablub> wz1000: maybe you will find here, what you are looking for: https://www.haskell.org/ghc/docs/7.6.2/html/users_guide/ghci-debugger.html
12:09:26 <edwardk> consider that grad needs its argument to be rank-2
12:09:27 <phi__> edwardk my bad
12:09:32 <edwardk> so go needs a rank-2 argument
12:09:39 <edwardk> you need to pass in a quantified function
12:09:46 <edwardk> there are two ways to do this. one is to work out the signature by hand
12:09:52 <edwardk> the other is to use Numeric.AD.Rank1
12:09:58 <edwardk> and say 'meh i know what i'm doing'
12:10:09 <edwardk> but beware of the risk of infinitesimal confusion when you do that!!
12:11:57 <edwardk> http://thread.gmane.org/gmane.comp.lang.haskell.cafe/22308/ talks about the risk of confusing perturbations/sensitivities
12:12:16 <edwardk> the quantifiers when used correctly properly ensure that you can't screw it up
12:12:24 <phi__> edwark with Numeric.AD.Rank1.Forward it says occurs check: cannot construct the infinite type: c ~ Forward c
12:12:26 <edwardk> the rank-1 versions are easier to compose, but are easier to screw up
12:12:37 <edwardk> phi__: then you need to put an 'auto' in in the right place
12:13:00 <phi__> sorry I keep spelling wrong
12:13:01 <edwardk> auto  will lift c -> Forward c for you
12:14:06 <edwardk> once you get the type from Rank1 you can figure out where to put the quantifier in and switch to the higher rank form ;)
12:14:41 <phi__> let me try to figure it out, but I am quite sure I will come back whining
12:20:04 <hyPiRion> Is there a function f :: Int -> [a] -> [[a]] such that f 3 [1, 2, 3, 4, 5] => [[1, 2, 3], [2, 3, 4], [3, 4, 5]]?
12:20:29 <hyPiRion> I need a sliding window of size n, if that's easier to parse.
12:20:36 <johnw> it's in the library split
12:20:41 <Lutin`> That feel when you thought a file synced to a server, and you wipe the USB drive it was on, and then look and it hadn't synced
12:20:43 <Lutin`> :(
12:20:45 <johnw> chunksBy
12:20:51 <Lutin`> There goes 6 hours
12:20:59 <johnw> err, chunksOf
12:21:01 <johnw> :t chunksOf
12:21:02 <lambdabot> Int -> [e] -> [[e]]
12:21:20 <hyPiRion> ah, thanks. I need to improve my hoogle skills apparently
12:21:59 <jle`> Lutin`: :'(
12:22:12 <Lutin`> hyPiRion: If you can't find it on Hoogle, try Hayoo
12:22:52 <edwardk> > tails [1,2,3,4,5]
12:22:54 <lambdabot>  [[1,2,3,4,5],[2,3,4,5],[3,4,5],[4,5],[5],[]]
12:23:00 <edwardk> > take 3 <$> tails [1,2,3,4,5]
12:23:01 <lambdabot>  [[1,2,3],[2,3,4],[3,4,5],[4,5],[5],[]]
12:23:19 <edwardk> > filter ((==) 3 . length) $ take 3 <$> tails [1,2,3,4,5]
12:23:21 <lambdabot>  [[1,2,3],[2,3,4],[3,4,5]]
12:23:24 <edwardk> er
12:23:27 <edwardk> yeah
12:23:28 <hyPiRion> yeah
12:23:28 <edwardk> that should work
12:24:09 <hyPiRion> thanks
12:25:49 <johnw> another nice example of laziness
12:39:18 <robbins> Is there someway I can see the whole stacktrace in GHCi, like debugging with gdb (I haven't covered Monads, yet).
12:40:01 <robbins> Found it: http://www.haskell.org/ghc/docs/latest/html/users_guide/ghci-debugger.html
12:40:57 <pjdelport> napping: \a b c -> a c (b c) is (<*>), but I don't think there's one for \a b c -> a c (b c)
12:41:24 <bitemyapp> robbins: there is no stack-trace though.
12:49:04 <robbins> bitemyapp: Essentially, GHCi is complaining I'm accessing an element which doesn't exist, http://ideone.com/3yvVtZ
12:49:22 <robbins> So a stack trace wouldn't help too much anyway
12:51:00 * hackagebot Proper 0.4.2.0 - An implementation of propositional logic in Haskell  http://hackage.haskell.org/package/Proper-0.4.2.0 (dillonhuff)
12:52:05 <bitemyapp> robbins: don't !! 0
12:52:08 <bitemyapp> robbins: don't !! period
12:52:15 <bitemyapp> robbins: pattern match and handle the empty case.
12:53:08 <savanni> bitemyapp: is that simply because !! can error if the element isn't present?
12:53:13 <pjdelport> robbins: That will always fail on the last element of the list (because the xs matched by (x:xs) will be [])
12:53:21 <bitemyapp> > [] !! 0
12:53:22 <lambdabot>  *Exception: Prelude.(!!): index too large
12:53:57 <nadirs> savanni: Basically, yes. Avoid non-total functions
12:54:12 <bitemyapp> I'll go stronger than that
12:54:26 <bitemyapp> when you're first learning Haskell, never intentionally or knowingly write a partial function.
12:54:32 <MP2E> ^
12:54:44 <savanni> *nod* okay.  Just making sure I understood the logic.
12:54:46 <bitemyapp> you don't know how to prevent making a boo-boo with them, so don't bother.
12:55:03 <bitemyapp> importantly, you don't *need* them. Pattern match, handle the base case.
12:56:14 <robbins> bitemyapp: I managed to fix that error by pattern matching a list with 1 element
12:56:23 <nadirs> bitemyapp: though, I have a question on this matter. I sometimes used `head` in composing functions where the list could never be empty
12:56:31 <nadirs> like `head . lines` for instance
12:56:47 <bitemyapp> robbins: flkdsgmsg okay.
12:56:55 <nadirs> is there a fundamental error in this approach or are there exceptions as usual?
12:57:02 <bitemyapp> nadirs: if you know how to 100% guarantee that by construction you are no longer a beginner.
12:57:47 <bitemyapp> nadirs: the naïve don't know rules and suffer for it, the journeyman needs rules to keep on the path, the master is able to shed rules because they are the path.
12:57:56 <bitemyapp> nadirs: zen triples.
12:58:20 <bitemyapp> never assume where you are on the triple. It's a cycle.
12:58:59 <robbins> bitemyapp: Does that mean my approach is wrong?
12:59:07 <bitemyapp> To be clear, contextualized application of rules isn't hypocrisy, it's just good pedagogy.
12:59:26 <nadirs> bitemyapp: totally agree about the cycle
12:59:29 <bitemyapp> robbins: if you believe in good faith that you have written a total function and handled all possible cases then I am not going to complain.
12:59:29 <MP2E> robbins : no, imo, it's head in prelude that is wrong
12:59:43 <bitemyapp> robbins: if you are still using non-total functions I would be very nervous on your behalf.
13:01:04 <robbins> bitemyapp: I'm by no means writing production haskell code, I'm only doing the 99 haskell problems to practice - I just need to learn to grok haskell
13:01:25 <bitemyapp> robbins: https://github.com/bitemyapp/learnhaskell
13:01:54 <MP2E> you got 99 problems but production ain't one
13:01:57 <MP2E> (sorry)
13:02:22 <MP2E> bad pun is bad :D
13:02:30 <bitemyapp> MP2E: I've thunk worse.
13:02:39 <bitemyapp> > putStrLn "ba dum tish"
13:02:41 <lambdabot>  <IO ()>
13:04:01 <robbins> bitemyapp: Thanks, a connoical resource is what I was looking for.
13:04:04 <marchelzo_> Am I using memoize wrong? This code runs 3 times faster than when I use the memoized version: http://lpaste.net/1870904543164760064
13:04:32 <bitemyapp> robbins: I'm honoured you think my collection of material is canonical, but it's simply hammered out by experience.
13:06:12 <savanni> bitemyapp: my life would be infinitely easier if I could actually use the advice you put at the very top of the README.
13:06:30 <robbins> bitemyapp: Is that in teaching Haskell, or using it?
13:06:39 <MP2E> probably a little of both
13:06:59 <MP2E> I often learn things in here by answering questions and getting corrected by someone who knows way more than me :P
13:07:05 <MP2E> hehe
13:07:24 <bitemyapp> robbins: I teach a lot of Haskell, learn actively in my free time, and have written a library (happy experience)
13:09:08 <rwbarton> marchelzo_, overusing it, probably
13:09:09 <nadirs> bitemyapp: (by the way I realized my previous example `head . lines` was wrong, I rather wanted to say `map length . group`. As a classic excuse I'll say I'm tired :P)
13:09:27 <bitemyapp> nadirs: I say stupid things all the time, just look at my twitter. No sweat.
13:09:42 <pjdelport> robbins: The general thing to grok here is the idea of knowing when functions are total or partial.
13:09:43 <nadirs> (and again it was `map head`, not map length. Bye
13:09:49 <bitemyapp> nadirs: lol
13:10:00 <bitemyapp> > lines "\n\n\n\n"
13:10:01 <lambdabot>  ["","","",""]
13:10:12 <bitemyapp> map head $ lines "\n\n\n\n\n"
13:10:18 <bitemyapp> > map head $ lines "\n\n\n\n\n"
13:10:19 <lambdabot>  "*Exception: Prelude.head: empty list
13:10:25 <nadirs> bitemyapp: you've got to understand my country was just eliminated from the world cup :P
13:10:26 <bitemyapp> nadirs: are you sure lines doesn't give you an empty list?
13:10:40 <bitemyapp> nadirs: can we talk about what correct by construction means? :)
13:10:57 <nadirs> bitemyapp: no, in fact I meant `map length . group` (which hopefully is total)
13:11:02 <pjdelport> robbins: Informally a total function is one that is defined for all its possible inputs, such as length; a partial one is only defined for a subset of inputs, and fails or crashes on others.
13:11:04 <robbins> pjdelport: In the next few days I'm going to learn about testing, eg: in a reverse function, the length should stay the same - there's library (quicktest?) that does this.
13:11:10 <nadirs> uff. `map head . group`
13:11:17 <pjdelport> such as head and (!!) and several others
13:11:36 <robbins> That should help with partial functions.
13:12:07 <bitemyapp> nadirs: I think `map head . group` is total but that'd be a subtle point for a beginner to cotton onto.
13:12:18 <pjdelport> robbins: The partial functions in the Prelude are all there partly by tradition, and partly for convenience, but as a rule of thumb you should never use them unless you know your input is valid.
13:12:19 <bitemyapp> nadirs: even I wasn't sure until I tried a few cases and reminded myself.
13:12:45 <pjdelport> robbins: For example, only use head if the code around it has already proven that a list is not []
13:13:02 <pjdelport> robbins: And only use !! if you've proven that the index is in bounds.
13:13:07 <nadirs> bitemyapp: "correct by costruction": the codomain of g doesn't trigger the non-exhausted patterns of f's domain in `f . g`, maybe?
13:13:37 <bitemyapp> nadirs: that's the way I'd think about it in this case.
13:13:48 <pjdelport> robbins: As a shorter rule of thumb, just don't use them (yet): there are almost always better ways to do something, such as explicit pattern matching.
13:22:29 <sveit> i have a function f :: (a -> Double) -> SomeType Double, but i would like to populate SomeType with random Doubles. Is there a way to do this, since it appears all random number stuff must happen in IO?
13:24:40 <sveit> sorry, to be more specific i am talking about the mersenne-random hackage package
13:26:02 <savanni> sveit: does your function have to operate in pure code?  Or can you generate the data in IO and then pass the result into pure code?
13:27:26 <vova> Please help me to construct the RequestBody http://hackage.haskell.org/package/http-client-0.3.3.2/docs/Network-HTTP-Client.html#t:RequestBody
13:27:57 <sveit> savanni: in the actual case no, since the goal is to generate a structure with ~1000 elements (i.e. call the (a -> Double) function several thousand times)
13:31:33 <phi__> edwardk if you are still there is there a way to lift a function a -> a to Forward a -> Forward a
13:31:49 <edwardk> no
13:31:54 <edwardk> where would i carry the derivatives
13:32:04 <edwardk> you need parametricity in some form for me to get information through
13:32:05 <savanni> sveit: well, all the solutions I can think of will require a significant rewrite of f.  But, if you Must Not operate in IO, then you'll have to use StdGen
13:32:32 <savanni> sveit: And in that case, it means that you'll have to call `next` however many times you want, but be sure to feed the updated seed back in.
13:33:10 <phi__> then I guess you can't write go l f  x =  diff (\t -> (!! 1) . grad l $ [f t , diff f $ t]) $ x
13:33:59 <edwardk> one sec
13:34:02 <edwardk> let me install ad
13:34:02 <phi__> becuase the f in  f t has to be of type Forward a -> Forawrd but f in diff f t has to be of type Forrward (Forward a) -> Forward (Forward a)
13:34:03 <edwardk> =P
13:34:30 <edwardk> you can write this function
13:34:37 <edwardk> i do all sorts of things like this in Numeric.AD.Newton
13:34:47 <edwardk> you may have to be careful about using Or though, which sucks
13:35:20 <phi__> and go  l f g x =  diff (\t -> (!! 1) . grad l $ [f t , diff g $ t]) $ x works with type inference in rank-1 case
13:36:23 <edwardk> phi__: give me a few minutes to re-bootstrap my understanding of this domain
13:37:08 <phi__> sure edawrdk, I hope I not bothering you too much
13:37:48 <edwardk> its not a problem just trying to get you to slow down =)
13:38:04 <edwardk> you're about to reject a perfectly fixable piece of code
13:38:05 <edwardk> =)
13:38:16 <benzrf> arghhghh
13:38:18 <edwardk> its just that the solution is painfully subtle
13:38:19 <benzrf> i'm getting:
13:38:21 <benzrf> syntastic: error: checker haskell/ghc_mod returned abnormal status 1
13:38:33 <benzrf> why would ghc-mod have exit status 1
13:38:46 <benzrf> i found this paste http://lpaste.net/report/102695
13:39:18 <phi__> I am waiting and I have all the time in world since I am not doing what I am supposed to do
13:39:23 <benzrf> aha
13:39:24 <benzrf> GHCi runtime linker: fatal error: I found a duplicate definition for symbol my_inet_ntoa
13:39:27 <benzrf> whilst processing object file /home/benzrf/.cabal/lib/network-2.5.0.0/ghc-7.6.3/HSnetwork-2.5.0.0.o
13:39:30 <benzrf> wut?
13:39:48 <edwardk> so you want the answer and the derivative at the same time?
13:40:05 <edwardk> diff' :: Num a => (Forward a -> Forward a) -> a -> (a, a)
13:40:08 <edwardk> notice the '
13:40:31 <benzrf> http://www.fatvat.co.uk/2010/10/duplicate-symbol-myinetntoa-when.html
13:40:39 <benzrf> woot
13:41:00 <phi__> oh I was working with that in the morning and then threw it away because of the painfully complicated type
13:41:03 <edwardk> go l f x =  diff (\t -> (!! 1) . grad l $ let (y,y') = diff' f t in [y,y']) $ x
13:41:06 <edwardk> that is the easiest fix
13:41:22 <edwardk> you can fix 'f' so it can be called in two different modes but the fix is subtle
13:41:51 <edwardk> diff' computes both the answer and the derivative in one pass
13:42:07 <edwardk> in general given foo   foo' will also give you back the answer not just the derivatives since it had to compute it anyways
13:42:42 <phi__> thanks edwardk that works, indeed I should have been able to figure that out, now I feel a bit stupis
13:42:47 <phi__> I meant stupid
13:42:57 <edwardk> no worries. ad is huge and easy to get lost in
13:43:05 <edwardk> i have a tendency to write libs like that ;)
13:43:17 <pjdelport> robbins: Here are some compress variations for you: http://lpaste.net/106242
13:43:25 <pjdelport> Just for fun. :)
13:43:36 <benzrf> bluuuuuuuuugh
13:43:41 <phi__> I have to admit your libs almost always make me feel lost
13:43:44 <benzrf> this is tremendous shit
13:43:51 <phi__> expcept integration, that was a simple one
13:44:51 <benzrf> cabal sandboxes apply to subdirs righrt
13:44:54 <benzrf> *right
13:45:21 <pjdelport> robbins: Note the last example, where it's actually safe to to use head, because of group.
13:45:22 <bernalex> benzrf: IIRC -- yes. I had the same worrying "what if" thought a few days ago.
13:45:42 <sveit> suppose I have "nested" do blocks, the outer one being for some unknown monad "m", and the inner being for a known one, for example "ST". is there a way to access values of type m a in the inner do block?
13:45:56 <benzrf> k fuck it im wiping my packages
13:45:58 <benzrf> this sucks
13:46:29 <robbins> pjdelport: pjdelport Thanks, that's excellent.
13:46:38 <Peaker> sveit: probably, if I understand what you mean..
13:46:53 <edwardk> phi__: integration could stand to be generalized a bit. =)
13:46:58 <phi__> another unrelated question for you: is there a method for numerically solving ode's that is accurate and fairly universal even if it is slow or even painfully slow
13:47:00 * benzrf sighs
13:47:18 <sveit> Peaker: how?
13:47:22 <edwardk> phi__: not really my strong suit. sclv or someone can probably answer that better than i can
13:47:33 <edwardk> once things get stiff, etc. i'm pretty weak
13:47:52 <phi__> edwardk yeah please add multivariable integrals too though even now they are pretty easy to define
13:48:00 <triliyn> sveit: do you mean bind them or just use their values? There's no restriction on what values you can use within a do block as long as each line has the right type
13:48:04 <edwardk> well, be careful, nested integrals are hard!
13:48:05 <Peaker> sveit: do { ... do { return 5 :: m Int } } ?
13:48:10 <edwardk> quadrature schemes do not scale
13:48:15 <edwardk> you need MCMC-like techniques
13:48:26 <phi__> I meant just with constant limits
13:48:34 <mindleyhilner> benzrf: may i ask why you have chosen to purge your packages?
13:48:38 <pjdelport> robbins: You'll probably see foldr pop up a lot more: it's a very fundamental and useful list transformation, closely tied to the type's definition.
13:48:40 <triliyn> If you want to bind them, you have to do that in the outer do block, but then you can access the bound names from within the inner one
13:48:45 <phi__> for anything more complicated I will wait for a lib by you
13:49:08 <pjdelport> robbins: Let me know if you have any questions. :)
13:49:14 <benzrf> mindleyhilner: sadness
13:49:23 <triliyn> Peaker: I don't think that would work. The inner do block has to return something in the known monad, not the arbitrary one
13:50:04 <mindleyhilner> benzrf: elaborate
13:50:28 <edwardk> phi__: heh well, i'd be careful with using the integration package on nested integrals as it stands.
13:50:48 <benzrf> mindleyhilner: i dunno man
13:50:49 <benzrf> i dunno
13:50:53 <benzrf> it's all fucked up man
13:50:56 <benzrf> it's all fucked up
13:51:02 <benzrf> gotta purge and begin anew
13:51:09 <Peaker> triliyn: depends what "access values" means here
13:51:21 <edwardk> if you need deeply nested integrals i recommend using the approaches from STAN -- hybrid monte carlo (Hamiltonian MCMC using the derivatives)
13:51:40 <phi__> edawrdk I once used it for 3-d integrals, seemed to work fine
13:52:00 <sveit> triliyn, Peaker: I mean i have a function f :: Int -> m b
13:52:11 <sveit> then i have nested do blocks
13:52:19 <sveit> the outer one is with monad "m"
13:52:24 <sveit> the inner one is with the ST monad
13:52:25 <edwardk> HMC + No U Turn Sampling + some tricks from Girolami and Calderhead + Nesterov's dual averaging scheme give the closest thing to a universal approach I know.
13:52:28 <benzrf> sveit: do blocks are not magical
13:52:38 <edwardk> phi__: you didn't have very hard integrals then ;)
13:52:41 <benzrf> consider how it would work after they are desugare
13:52:42 <benzrf> d
13:52:44 <sveit> benzrf: i am aware, it's just the best way i have of explaining what i would like to do
13:52:46 <Peaker> sveit: and what do you want to do in the inner monad?
13:52:47 <triliyn> If it's f :: Monad m => Int -> m b, you can use that in any do block
13:52:51 <edwardk> quadrature from 2d on up gets bad for many many functions
13:52:56 <Peaker> sveit: in the inner do block, that is
13:53:20 <sveit> i would like to call f within the inner do block and access it's return value (or access it's return value in the inner monad)
13:53:26 <edwardk> and the reasoning that says tanh-sinh quadrature is universal doesn't work when used on itself
13:53:51 <sveit> sorry, m is some monad, not /any/ monad
13:53:53 <Peaker> sveit: execute actions of the outer monad in the middle of your ST computation?  That's interleaving, and it is not generally possible. You can interleave if you make the outer monad a transformer, and use transformed ST to interleave actions freely
13:54:24 <Peaker> sveit: otherwise, interleaving in the middle of ST would break all the guarantees ST is supposed to give
13:54:24 <sveit> Peaker: that's exactly what i would like to do. without making it a transformer is there another way?
13:54:27 <edwardk> well, by universal i mean universal over the Hardy space H^p
13:54:43 <phi__> edawrdk are C(infinity) functions fine or not?
13:54:47 <sveit> Peaker: can I interleave in general?
13:55:00 <Peaker> sveit: you could have the ST computation eventually return an action in m, and then execute it in the outer do block
13:55:28 <edwardk> phi__: for nested integrals by tanh-sinh? probably no
13:55:32 <Peaker> sveit: Nope, this problem is known as "monad don't compose".  i.e:  if "m" and "n" are monads, then m . n is itself not a monad
13:55:37 <robbins> pjdelport: It looks fine to me, thanks for writing out the different solutions
13:55:43 <edwardk> i'd be shocked if they were
13:55:57 <Peaker> sveit: where m . n  is type-level compose,  i.e: (m . n) a  ~=  m (n a)
13:55:59 <edwardk> for HMC methods? go for it
13:56:31 <Peaker> sveit: Functors & Applicatives, for instance, do compose.   if "f" and "g" are Applicatives, then "f . g" is also an Applicative
13:56:49 <phi__> edawrdk I mean by tanh-sinh. I guess I need a course in numerical analysis
13:57:08 <hpc> K-Lined?
13:57:36 <Peaker> sveit: so if you don't need the full power of the Monad, only Applicative, then you can combine the effects (it would still not interleave effects, but you'd have the full power of Applicative on your composition of m and ST)
13:57:54 <edwardk> phi__: tanh-sinh is picking a set of non-uniform points to take the quadrature. the problem is it picked them assuming you are doing it on a number line.
13:57:55 <sveit> ok so to be more specific and give a special case, i do not understand how to write a function generate :: (Monad m) => (Int -> m Int) -> m (SomeType Int)
13:58:19 <edwardk> it picked points that give a lot of information about functions in a wide-class of possible functions under those assumptions.
13:58:20 <sveit> where i would like to construct SomeType within an ST monad
13:58:33 <carter> o/ Peaker
13:58:34 <carter> hows the hacking?
13:58:40 <carter> we've not spoken in a while (twitter aside)
13:58:56 <edwardk> by transforming the integral into one that clumps up near the origin
13:58:58 <Peaker> carter: heh, yeah.  we've had serious problems in our custom type inference algorithms (initially correctness, then performance)
13:59:07 <carter> Peaker: oh?
13:59:13 <carter> lambdu?
13:59:13 <Peaker> carter: so we went back to standard HM inference, which has decent performance -- but isn't quite as flexible
13:59:16 <Peaker> carter: yeah
13:59:35 <carter> would HM(X) or adapted outside-in be relavent?
13:59:37 <Peaker> carter: so we took the "Algorithm W Step-By-Step" paper, debugged it, extended it with row-polymorphic records
13:59:41 <carter> @google lambdu
13:59:47 <Peaker> @google Lamdu
14:00:07 <rwbarton> sveit: you can't use ST here unless you can "do all the ST at once"
14:00:08 <Peaker> carter: what's HM(X)? I know OutsideIn is what GHC now uses. It would be useful, yeah
14:00:12 <phi__> edwardk if that is the case then shouldn't integration work well if function decays fairly rapidly as r goes to infinity
14:00:19 <carter> @google HM(X)
14:00:31 <carter> int-e: lambdabot is down :(
14:00:34 <edwardk> phi__: works better, yes =)
14:01:08 <int-e> carter: hmm.
14:01:10 <phi__> I guess that is why it seemed all right to me.
14:01:16 <edwardk> basically tanh-sinh is used because it looks a lot like erf, http://www.wolframalpha.com/input/?i=tanh%5Bsinh%5Bx%5D%5D+vs+erf%5Bx%5D
14:01:18 <ocharles> Is this a bit... non#haskell?
14:01:27 <savanni> sveit: you could solve all of this without a monad.  A recursive function that generates however many Ints you want would work, and would make it easy to handle propagating the seed from the random number generator to the next iteration.
14:01:28 <carter> Peaker: http://ww2.cs.mu.oz.au/~pjs/papers/jfp2007.pdf is a paper google picked up
14:01:30 <Peaker> carter: well, the standard, even naive, Algorithm W stuff is fast enough, it seems. With the records&row-polymorphism we added, we now need either RankN types or sum types.  RankN types don't seem easy, even GHC doesn't do them well
14:02:02 <Peaker> carter: we want to have sums implemented as sugar on top of records (via duality)
14:02:23 <Peaker> but we need RankN for that, and no HM system we know of does RankN well :(
14:02:25 <carter> Peaker: the way ghc lets you get rankN sanely is with a newtype wrapper
14:02:27 <edwardk> you can compare the derivatives as well http://www.wolframalpha.com/input/?i=derivative+of+tanh%5Bsinh%5Bx%5D%5D+vs+derivative+of+erf%5Bx%5D they are quite similar
14:02:45 <int-e> carter: https://clientarea.ramnode.com/announcements.php?id=364 ... (and I'm happy that it came back automatically as planned)
14:03:05 <Peaker> carter: how do you do it so you don't hit painful points like failing to type-check "runST . forever"
14:03:08 <carter> @google HM(X)
14:03:13 <carter> Peaker: hrmm
14:03:16 <lambdabot> http://www.hm.com/us/life/culture/h-m-inside/2014/04/alexander-wang-x-hm
14:03:22 <lambdabot> Title: H&M Life | H&M US
14:03:23 <rwbarton> I thought lots of basic problems involving higher-rank types were undecidable
14:03:36 <Peaker> carter: newtype PolymorphicST a = P (forall s. ST s a) ?
14:03:45 <carter> yeah
14:03:47 <edwardk> phi__: you can see that the sinh is used to bring it closer into line from tanh, by looking at http://www.wolframalpha.com/input/?i=derivative+of+tanh%5Bsinh%5Bx%5D%5D+vs+derivative+of+erf%5Bx%5D+vs+derivative+of+tanh%5Bx%5D
14:03:49 <int-e> carter: but I'm not sure why it took 45 minutes
14:04:04 <Peaker> carter: hmm..
14:04:18 <carter> Peaker: bidirectional type checking is a thing
14:04:26 <carter> Peaker: have you looked at ermine's engineering?
14:05:15 <Peaker> carter: only a bit
14:06:19 <edwardk> carter, Peaker: we don't allow impredicative instantiation
14:06:25 <phi__> edwardk can you suggest a reference for numerical analysis that is moderately advanced but not overly so? I mean for someone who has some background in math but is not a math major.
14:06:43 <carter> phi__: whats your linear algebra background
14:06:46 <n-dolio> edwardk: We don't?
14:06:47 <edwardk> phi__: good question. i'll skim my shelf later and see what i can recommend
14:06:51 <carter> phi__: also come join #numerical-haskell :)
14:07:09 <carter> phi__: what sorts of problems are you working on?
14:07:11 <edwardk> n-dolio: [forall a. a]   and the like?   didn't think we kept the rigid stuff
14:07:23 <edwardk> at least we haven't tested it in forever
14:07:34 <phi__> Basically an advanced quantum mechanics course + ring , field , theory ungrad courses
14:07:44 <phi__> I meant undergrad
14:08:03 <carter> neat
14:08:21 <Peaker> carter: the newtype trick for polymorphic "s" in ST doesn't seem to help much.. if you have some "runPST" function it's going to be polymorphic and therefore not composable with (.), and the input to that function is a polymorphic ST computation, ditto
14:08:49 <carter> Peaker: you can give . magic treatment like $ if you want
14:08:54 <Peaker> carter: :(
14:09:03 <rwbarton> Peaker: wouldn't it just be runPST :: PolymorphicST a -> a ?
14:09:06 <carter> Peaker: if you know how to make $ not need magic i'm all ears
14:09:13 <phi__> carter nothing organized basically random computational physics stuff that caught my fancy
14:09:14 <carter> phi__: come "/join #numerical-haskell"
14:09:16 <carter> cool
14:09:17 <sveit> i do not think i was being clear. here is my exact problem: Data.Vector has a function generateM :: (Monad m, Vector v a) => Int -> (Int -> m a) -> m (v a). I would like to write something similar, only where instead of going over every index, it only initializes values for about half of them (so only half the indices are passed to f)
14:09:42 <edwardk> Peaker: use ($) ;)
14:09:45 <Peaker> rwbarton: yeah, you're right -- my composition test was broken because of the composition with the PST data constructor, not because of the runPST. but it still doesn't help
14:09:57 <carter> sveit: you want uninitiatlized values?!
14:10:00 <n-dolio> edwardk: I definitely don't think we complain about [forall a. a]. But it's impossible to test right now, because we don't parse any type constructors.
14:10:02 <edwardk> i use ($) all over the place in my little hask package because of too many rank-n types =)
14:10:06 <n-dolio> But that's a separate check anyway.
14:10:17 <Peaker> carter: oh, I don't know -- I'm just claiming that RankNTypes don't seem to be solved well yet
14:10:29 <carter> Peaker: if you can solve that, theres a paper in it for you
14:10:32 <carter> plus our love
14:10:34 <carter> :)
14:10:42 <phi__> carter I will once I figure out how to join a second channel from freenode's webchat
14:10:45 <sveit> carter: yep. i don't look at them except under certain conditions when I have already initialized them
14:10:54 <carter> phi__: type "/join #numerical-haskell"
14:11:01 <edwardk> i don't particularly mind the middle-ground we have now where rank-n types can be used with functions with signatures and that to do anything more you need a newtype wrapper
14:11:04 <carter> sveit: then just use functions
14:11:17 <carter> sveit: you're trying to implement "delay vectors"
14:11:24 <carter> which are basically "Int -> a"
14:11:25 <phi__> thanks carter
14:11:29 <Peaker> carter: We've learned from Lamdu experience that attacking too many researchy things at once is a bad idea :)  We've got enough paper-material in the UI design, revision control, incremental type checking, ... that we don't need to venture into such deep waters where we don't really have a real advantage over other researchers...
14:11:29 <edwardk> they are the _checkable_ fragment of haskell so use them with care, but its quite productive where its at
14:12:08 <rwbarton> I'm pretty sure there is a large body of research done into higher-rank polymorphism
14:12:16 <mmmm> What's the best library for parsing xml these days?
14:12:17 <Peaker> carter: this is why we've decided to give up much flexibility we intended to have in our type system -- because our inference algorithms sucked. So we go back to less flexible W, but we can now make progress elsewhere
14:12:48 <Peaker> rwbarton: It's an interesting question whether any of it solves the magic($) problem
14:13:05 <n-dolio> edwardk: I guess you're right that we didn't add the rigid stuff. So there's no way to cause impredicative instantiation.
14:13:18 <rwbarton> well, I *think* some generalized form of that problem is known to be undecidable
14:13:32 <edwardk> we basically decided to just let it drop because we weren't using anything we couldn't write with GHC
14:13:55 <edwardk> magic ($) is unsatisfying =)
14:14:28 <Peaker> I suppose magic ($) treats ($) as sugar for ordinary function application?
14:14:42 <Peaker> (i.e: type-checks the inlined version of ($) ?)
14:14:43 <n-dolio> It type checks it the same way, anyhow.
14:16:12 <n-dolio> There are systems that don't require magic to get ($) to type check.
14:16:38 <n-dolio> And would also work for a flipped ($).
14:16:49 <n-dolio> So they aren't biased in one direction.
14:16:52 <Peaker> n-dolio: that also successfully check things like "runST . forever" ?
14:17:11 <n-dolio> Dunno. Probably.
14:17:19 <Peaker> (instantiating  m = forall s. ST s)?
14:17:31 <sveit> thanks for all the help so far, but I don't think i have been able to ask my question without code, so here is what i am asking about: http://lpaste.net/1431426520022253568 . the function 'generate' works as expected, i just have no idea how to write generateM
14:17:40 <n-dolio> Look at Daan Liejen's stuff on HMF and HML.
14:18:29 <rwbarton> sveit: you don't seem to be using mutable vectors in an essential way
14:19:12 <rwbarton> like with the array package (I don't know vector as well off-hand), this is simple just using 'array'
14:19:44 <sveit> rwbarton: partly it is as a learning exercise, but also isn't it useful to make sure the vector isn't being copied?
14:20:00 <rwbarton> run your f with mapM or something to get a m [((Int,Int),a)], and then fmap (array ((0,0),(mo-1,mo-1))) over it
14:20:20 <rwbarton> the point is there are ways to construct immutable vectors
14:20:35 <rwbarton> that don't involve constructing a bunch of intermediate vectors
14:20:48 <rwbarton> however, the downside is that maybe you have no way to avoid the intermediate list existing all at once
14:20:54 <rwbarton> depends on what 'm' is
14:21:21 <sveit> rwbarton: that is quite a serious downside for me...
14:21:43 <rwbarton> probably impossible to avoid in general though
14:21:46 <rwbarton> e.g. imagine m = []
14:22:00 <savanni> sveit: large data set?
14:22:07 <sveit> yep
14:22:25 <n-dolio> edwardk: Actually: >> :t (x f -> f x) ((x : forall a. a) -> "")
14:22:26 <savanni> k.  Then, yes, ensuring a lack of intermediate structures becomes important.
14:22:34 <n-dolio> forall (a : *). (((forall (a : *). a) -> String) -> a) -> a
14:22:41 <sveit> rwbarton: so you think there is no way to write generateM as in the example?
14:22:46 <sveit> or analogously?
14:23:08 <edwardk> n-dolio: interesting
14:23:15 <edwardk> left over from the hmf parts i guess
14:23:24 <rwbarton> (ugh, I hate the vector source so much)
14:23:58 <savanni> sveit: so let me be sure I understand what you're doing...
14:24:18 <savanni> You're generating a vector and running it in ST to ensure you can do destructive updates so that you're not making intermediate structures
14:24:39 <rwbarton> as far as I can tell, vector's generateM also builds an intermediate list
14:24:42 <savanni> You need the monad so that you can generate random data to put into the vector, hence IO.  Or maybe you're reading from disk.  Either way, you have a function that generates data in a monadic way.
14:25:03 <sveit> savanni: exactly. the "catch" is that i am also only checking ~ half the indices, so i can't use something like vector's generateM
14:25:19 <savanni> Define "checking" in this context.
14:25:54 <sveit> it is harder for me to be clear in language as opposed to the short code here: http://lpaste.net/1431426520022253568 , but basically i make a new vector and only run the function for ~half the indices
14:26:20 <sveit> rwbarton: then i guess this example/problem is more relevant to me than I thought :)
14:26:24 <napping> Did HMF work out poorly?
14:26:33 <savanni> Right, I'm looking at that.  I'm questioning whether it is necessary to leave out the half the indices, particularly since that leaves a timebomb for anybody who comes along afterwards.  Including you in three months.
14:27:01 <napping> The guaranteed claimed for MLF sounded pretty nice, but I didn't get much experience with type errors
14:27:06 <sveit> savanni: i promise i'm good about it in the rest of the application :)
14:27:13 <savanni> sveit: But, just for argument, I actually have a case in which I don't use generate at all because of the data source.
14:28:11 <rwbarton> sveit: I don't think it is possible, period, without building an intermediate list, or other comparable structure
14:28:21 <rwbarton> to write your generateM
14:29:06 <rwbarton> basically the type signature is too general
14:29:13 <sveit> rwbarton: i didn't think i'd run up on the limitations of haskell this early :(
14:29:37 <rwbarton> it's not a language issue
14:29:45 <rwbarton> you can't do it in another language either
14:31:10 * hackagebot lifted-base 0.2.3.0 - lifted IO operations from the base library  http://hackage.haskell.org/package/lifted-base-0.2.3.0 (BasVanDijk)
14:32:06 <rwbarton> presumably there is some specific m that you are really interested in
14:32:59 <sveit> rwbarton: i know that I can do this for IO, for example, as a special case, I was just hoping to write something general
14:33:03 <savanni> rwbarton: why is an intermediate list required?
14:33:46 <rwbarton> well, imagine m is the list monad for example
14:34:18 <phi__> carter at first glance there does not seem to be any time evolution there or am I missing something?
14:34:19 <savanni> Ah.
14:34:34 <carter> phi__: i'm not familiar with the code base at all
14:34:36 <carter> :)
14:34:47 <carter> aand yes, its not meant for mesh based stuff, if thats what you mean
14:35:25 <savanni> Well, actually, if I did the list monad, I would unsafeFreeze the vector at the end of the ST operation, and then when i return I would get a list that contains a single vector.
14:35:29 <rwbarton> it doesn't have to be a list specifically, you could maintain an intermediate vector, and copy the vector every time you want to update one entry
14:35:40 <joshkirklin> a quick question: I know I can set the number of cores to be used by a compiled threaded program using for instance '+RTS -N4'. Is there a ghc option I can set that automatically uses all of the available processing units?
14:35:53 <joelteon> +RTS -N
14:35:57 <savanni> Going from the vector to the list in a sensical way would be a full transformation that I wouldn't do, and which can't be generalized.
14:36:14 <joshkirklin> joelton: without needing any RTS options?
14:36:35 <joelteon> joshkirklin: -threaded
14:36:41 <rwbarton> oh a ghc option
14:36:49 <Peaker> stylish-haskell docs specify "--config" And other flags, but it seems the one from hackage just tries to parse any args as file names
14:37:33 <Peaker> oh! I used --constraint on a new mtl, so cabal chose an ancient stylish-haskell that had no upper bound. heh.
14:37:47 <rwbarton> joshkirklin: http://www.haskell.org/ghc/docs/7.6.2/html/users_guide/runtime-control.html#rts-opts-compile-time
14:37:52 <joshkirklin> joelteon: I know that I need to use that option to compile parallel code, but without the +RTS -N option, my program only runs on one core
14:37:53 <rwbarton> is this what you're looking for?
14:38:15 <joshkirklin> rwbarton: thanks, that looks promising
14:38:33 <benzrf> i ran lambdabot
14:38:35 <benzrf> it says:
14:38:36 <joelteon> you shouldn't need to use RTS opts to enable a program to run multicore, should you?
14:38:39 <benzrf>   Could not find module `Lambdabot.Plugin.Haskell.Eval.Trusted'
14:38:42 <benzrf> ???
14:39:05 <gspr> I have an attoparsec that parses a bytestring into a list of unboxed vectors of Ints, and I'm experiencing a size explosion. If I take the strict input bytestring and just compute the mod 256 sum of all its elements, profiling shows I'm using ~150 MB of memory for ARR_WORDS, and nothing else. This is the size of the file, so I'm happy. If I parse the same bytestring, I get an explosion of ByteString in my heap profile…
14:39:19 <rwbarton> by default even a program with -threaded runs on one capability
14:39:30 <joelteon> oh
14:39:36 <benzrf> int-e: yo
14:39:39 <rwbarton> "should", well, I don't know :)
14:39:40 <gspr> Since the input bytestring first shows up as ARR_WORDS, I'm a bit confused when it comes to trackign down the exploding ByteString
14:39:49 <joelteon> so you *do* have to use rtsopts for that?
14:40:00 <rwbarton> if you want to use more than one core yes
14:40:06 <joelteon> that's interesting
14:40:17 <rwbarton> or you can use this --with-rtsopts thing at build time
14:42:26 <benzrf> @ask int-e is your lambdabot repo up2date
14:42:26 <lambdabot> Consider it noted.
14:43:20 <savanni> Actually, rwbarton, I'm retracting my last assertion.  I did not think about it thoroughly enough beforehand.
14:44:24 <rwbarton> savanni: the thing is some of the Int -> Int -> [a] "actions" might be lists of more than one element
14:44:51 <benzrf> oh nvm i found it >.<
14:45:46 <benzrf>      Lambdabot.Plugin.Haskell.Eval.Trusted: Can't be safely imported!
14:45:46 <benzrf>      The package (lambdabot-trusted-5.0) the module resides in isn't trusted.
14:45:48 <benzrf> what?!
14:45:50 <sveit> rwbarton: thanks a lot, i see that you are right. I was wondering, in light of this, if haskell doesn't provide some way for me to write the general case, then factor out specific cases like IO? (without making a typeclass)?
14:47:22 <rwbarton> sveit: you could use vector's PrimMonad type class
14:47:34 <rwbarton> which is basically IO + ST
14:47:58 <geekosaur> benzrf: I think you need to mark modules as trusted yourself? `ghc-pkg trust ... `
14:48:37 <benzrf> othanks
14:49:11 <benzrf> > 3
14:49:12 <lambdabot>  3
14:49:24 <sveit> rwbarton: that was the idea, but how do i tell haskell "when m == IO, make generateM this specialized version"?
14:49:33 <rwbarton> oh
14:49:46 <rwbarton> as opposed to a general version that will build an intermediate list?
14:50:30 <rwbarton> you can use a RULE, then if the optimizer can see that the function is used at m = IO then it will use your specialized versoin
14:50:33 <sveit> rwbarton: yep. so my point is i know how to write generateIO, but i would still like to use generateM everywhere and have haskell substitute generateIO when it "knows"
14:50:44 <sveit> rwbarton: that sounds like what i want
14:50:51 <rwbarton> if it doesn't know, then it might use the generic version, even if m really is IO
14:51:00 <ParahSailin> http://www.haskell.org/ghc/docs/7.2.1/html/users_guide/pragmas.html#specialize-pragma
14:51:51 <kwf> mokus: Turns out I was slightly hasty; I need PolyKinds in the Template Haskell world as well.
14:52:04 <kwf> mokus: I'll send you another pull request shortly.
14:52:33 <rwbarton> SPECIALIZE is more for when the compiler can make further optimizations once it knows the concrete types
14:53:34 <rwbarton> like if you write a function with a Num a => ... context, but then specialize to a = Int, it might be able to make a lot of optimizations (inlining dictionaries, then strictness analysis allowing it to unbox recursive arguments etc.)
14:54:20 <rwbarton> a RULE lets you make any specialization you want -- even one that is unsound :)
14:56:12 * hackagebot cabalg 0.2.5 - alias for cabal install from given git repo  http://hackage.haskell.org/package/cabalg-0.2.5 (DmitryMalikov)
15:03:47 <Welkin> so what is the issue with gcc and haskell-platform on mac osx 10.9?
15:03:58 <Welkin> is it just a cplusplus extension?
15:13:26 <immersion> Since seeing the monad join function, I have a much better understanding of monads and how they're monoids. Has anyone else had a similar experience? I know that bind is used more frequently in practice, but in my experience it's more helpful to study join.
15:15:14 <Welkin> yes
15:15:29 <Welkin> you can implement join in terms of >>=
15:15:42 <MP2E> m >>= f = join $ fmap f m
15:15:43 <MP2E> ;)
15:16:23 <int-e> benzrf: yes.
15:16:34 <Welkin> :t (>>= id)
15:16:35 <lambdabot> Monad m => m (m b) -> m b
15:16:39 <Welkin> :t join
15:16:40 <lambdabot> Monad m => m (m a) -> m a
15:16:47 <benzrf> int-e: yeah i found the problem
15:17:09 <benzrf> btw i wrote a little patch that lets the bot pull code for @let from lpaste
15:17:17 <benzrf> will u accept it if i make a PR
15:18:34 <dfdsfsf> I have a function like foo a b c = a+b+c.  I'd like to define another function accepting the same number of arguments, e.g., bar a b c = qux $ foo a b c (where qux accepts one argument).  Is there an extension or a function that would allow to omit a b c in the definition of bar?
15:18:50 <int-e> benzrf: probably
15:19:08 <benzrf> cool
15:22:46 <benzrf> aw man
15:22:49 <benzrf> im so glad i installed hub
15:23:17 <benzrf> git fork && git push benzrf && git pull-request >>>>>> browser shit
15:23:24 <benzrf> int-e: https://github.com/int-e/lambdabot/pull/1
15:28:23 <tnks> okay, really simple "pragmatic" question.  Haskell seems to encourage reuse of namespaces like Control. Data. etc.
15:28:40 <tnks> it seems like this might lead to collisions for popularly extended things.
15:28:59 <benzrf> tnks: oh?
15:29:01 <tnks> I get the argument that "this rarely happens" but what can you do if it does?
15:29:42 <savanni> I know of an extension to the import statement that allows you to specify which package you are importing a namespace from.
15:30:32 <joshkirklin> > let foo a b = a + b; (.:) = (.).(.) in (negate .: foo) 1 2
15:30:34 <lambdabot>  -3
15:31:11 <joshkirklin> dfdsfsf: the above works for foo :: a -> b -> c
15:31:35 <joshkirklin> I'm not sure of a quick way to make it work for foo of three values
15:31:51 <pavonia> He already left
15:32:30 <joshkirklin> did he now
15:32:39 <savanni> tnks: the extension I'm thinking of is PackageImports, and I am sure I've seen it in practice once.
15:32:52 <joshkirklin> well I'm interested in if it's possible so the question's still open as far as I'm concerned
15:33:34 <pavonia> joshkirklin: There's the composition package that defined several similar functions
15:33:48 <tnks> savanni: yeah, Sooraj (here in the office) just mentioned the same thing.
15:34:02 <joshkirklin> pavonia: thanks, I'll check it out
15:34:04 <tnks> savanni: so cool. . . it's not as crazy as I thought.
15:34:06 <tnks> thanks.
15:34:20 <savanni> Other than that, a conflicting namespace might actually mean that two developers need to get together and possibly merge their work.
15:34:57 <tnks> savanni: sure, but in the middle of a production project, that's not always an option that can done in a timely way.
15:35:03 <tnks> so it's good to have an out.
15:35:18 <tnks> the good part is this is a complete enough solution for me.
15:45:03 <asterblaster> Hello
15:45:24 <heatsink> Hello starblaster
15:45:49 <asterblaster> I want to use Data.Heap to sort tupples (i,j) by 2^i+5^j value
15:46:15 <asterblaster> but I don't know how to make HeapT with such priority policy
15:46:52 <asterblaster> for example I want to insert (i,j) | i<-[1..],j<-[1..] into the heap
15:47:11 <asterblaster> and then view contentes of the heap
15:47:43 <asterblaster> any help?
15:47:44 <heatsink> A heap stores (priority, value) pairs
15:48:00 <heatsink> In your case, the value is a tuple (i, j)
15:48:11 <heatsink> and the priority is 2^i + 5^j
15:48:38 <asterblaster> heatsink: is it really _that_ simple? :)
15:48:58 <asterblaster> o hell!
15:49:01 <asterblaster> it works!
15:50:08 <benzrf> yo int-e can u look @ https://github.com/int-e/lambdabot/pull/1
15:56:08 <int-e> benzrf: I found a great distraction: looking at the lpaste sources, which are a bit confusing at first.
16:03:22 <int-e> @ask chrisdone does lpaste have any upper bound on paste lengths?
16:03:22 <lambdabot> Consider it noted.
16:03:50 <Welkin> int-e, test it with the text of a novel
16:04:11 <Welkin> anna karenina or war and peace
16:04:18 <sveit> if i call out in the ffi in haskell to some C function that normally runs in multiple threads on multiple cores if called from C code, will it behave the same from the haskell program?
16:12:31 <RchrdB> sveit, should do.
16:13:07 <RchrdB> sveit, GHC's RTS does nothing to prevent libraries from spawning more threads than the ones it does itself.
16:14:01 <RchrdB> From Haskell, you can use libraries like zmq that set up their own thread-pools.
16:20:23 <benzrf> Rakkin: 0mq-five o/
16:29:39 <int-e> benzrf: Btw since you asked about :info a while ago - the current implementation of :type and :kind is quite ugly (https://github.com/int-e/lambdabot/blob/master/lambdabot-haskell-plugins/src/Lambdabot/Plugin/Haskell/Type.hs) and the ad-hoc parser for the ghci output does definitely not work for :info. So it wasn't a 5 line change as I hoped.
16:35:12 <acowley> How can I use a class instance for a type computed from a SomeNat?
16:35:45 <bitemyapp> Anybody willing to offer help on refining a worker pool + queue example? http://www.reddit.com/r/haskell/comments/28zwt9/decided_to_play_with_tchan_last_night_made_a/
16:35:45 <acowley> Well, "don't" is a pretty good answer
16:36:20 * hackagebot AttoBencode 0.3.1.0 - Fast Bencode encoding and parsing library  http://hackage.haskell.org/package/AttoBencode-0.3.1.0 (FlorianHartwig)
16:38:54 <benzrf> i just found a great new use for my bouncer
16:39:04 <benzrf> since it doesnt play back joins and quits as part of buffer playback
16:39:18 <benzrf> i can /reconnect to filter out all of the recent joins and quits and get a condensed chat history
16:39:24 <benzrf> \o/
16:41:23 <benzrf> be back l8r
16:43:42 <acowley> Ugh, this is reflection where there are no values
16:59:23 <ddere> is there a ghc/ghci option that tells me where it finds a given module?
17:00:26 <geekosaur> -v maybe?
17:00:35 <ddere> like if it cant find a module, "-v" will tell you where it looked, but i want the location where it successfully found a specific module
17:01:47 <geekosaur> my understanding is -v shows you what it does. so it shows you all the places it is looking, and the last one should be where it found it
17:02:07 <ddere> hmm ok ill give it a try
17:17:23 <Ankhers> I'm using Aeson for JSON in an application. What would be the Haskell way to represent nested data structures?
17:19:11 <jle`> Ankhers: example?
17:21:29 <Ankhers> jle`: http://lpaste.net/106250
17:22:06 <jle`> if the schema is fixed you can just make it a normal data type
17:22:53 <jle`> data Foo = { fooName :: String, fooJob :: Job } ;     data Job = { jobName :: String; jobType :: String }
17:23:06 <jle`> or data JobType = Contract | Service | Something | Else
17:23:10 <jle`> and jobType :: JobType
17:24:02 <Ankhers> I was hoping there would be a solution that didn't require making a lot of data types. Though, I guess it doesn't really matter if I don't expose them.
17:24:21 <Ankhers> jle`: Thanks for the help!
17:24:22 <jle`> alternatively you can just use Map's
17:24:26 <jle`> er
17:24:31 <jle`> Aeson's built in json types
17:24:47 <jle`> where each level is either a map, an array, or a value
17:24:58 <jle`> data types aren't scary :)
17:25:40 <Ankhers> I wasn't aware of those types. Though, it is a fixed structure, so I guess it would be better to make those types.
17:26:03 <jle`> i think they have something like data JSON = JSONValue Value | JSONObject (Map String JSON) | JSONList [JSON]
17:26:13 <jle`> or something to that extent
17:26:20 <jle`> so you can infinitely nest and stuff
17:26:22 <ccapndave> Hey everyone
17:26:31 <jle`> hello ccapndave
17:26:49 <ccapndave> I am an absolute Haskell noob, and can't figure out why my (drop 30 . take 3) is chucking away the whole list
17:26:53 <ccapndave> https://www.fpcomplete.com/project/47205/xu5ikEnbeO
17:26:55 <Ankhers> I will keep that in mind for the future.
17:26:55 <ccapndave> Any clue?
17:27:09 <jle`> ccapndave: chunking away?
17:27:19 <rwbarton> ccapndave, because you are dropping the first 30 items of a list of length at most 3
17:27:24 <rwbarton> maybe you are reading the composition backwards?
17:27:30 <geekosaur> ccapndave, you take 3 elements, then drop 30 off of that
17:27:30 <ccapndave> Oh maybe
17:27:34 <geekosaur> leaving 0
17:27:36 <jle`> > take 3 [1..]
17:27:37 <lambdabot>  [1,2,3]
17:27:40 <jle`> > drop 30 [1,2,3]
17:27:41 <lambdabot>  []
17:27:53 <ccapndave> aha
17:27:59 <ccapndave> So the . does things in reverse order?
17:28:04 <jle`> it's function composition
17:28:07 <rwbarton> @src (.)
17:28:08 <lambdabot> (f . g) x = f (g x)
17:28:08 <lambdabot> NB: In lambdabot,  (.) = fmap
17:28:14 <rwbarton> ignore that last line
17:28:16 <jle`> (f . g) x = f (g x)
17:28:17 <gspr> How does one typically go about enforcing strictness in an attoparsec parser?
17:28:21 <jle`> like in math, ya know?
17:28:44 <jle`> ~*~.~* math *~.~*~
17:28:45 <ccapndave> Unfortunately my maths knowledge is only slightly better than my knowledge of 14th century history
17:29:17 <jle`> if you have a function f and a function g, f . g gives you a new function that applies g, then f
17:29:23 <jle`> it sort of makes more sense in the expansion
17:29:24 <ccapndave> Got it
17:29:28 <ccapndave> So, in reverse order :)
17:29:33 <jle`> well
17:29:37 <jle`> in a normal language
17:29:41 <jle`> foo( bar (x) )
17:29:46 <jle`> is that reverse order?
17:29:50 <jle`> foo comes first...is foo done first?
17:29:57 <ccapndave> I guess not
17:30:04 <ccapndave> Fair enough
17:30:11 <gspr> I think what's ccapndave is saying is that the application order of the functions is read from right to left
17:30:21 <ccapndave> I get it now though
17:30:31 <gspr> which is "reversed" compared to most natural western languages :p
17:30:36 <ccapndave> Its just shorthand to avoid writing brackets
17:31:04 <jle`> actually the benefits are much more profound than that :)
17:31:06 <dwcook> Not only that, it's more easily composable
17:31:25 * hackagebot haskell-course-preludes 0.0.0.3 - Small modules for a Haskell course in which Haskell is taught by implementing Prelude functionality.  http://hackage.haskell.org/package/haskell-course-preludes-0.0.0.3 (gibiansky)
17:31:33 <jle`> you will, in time, come to see how profound and deep the benefits are
17:31:44 <jle`> and i don't think anyone could have told me if i had asked them, when i was starting out :|
17:31:44 <ccapndave> Cool :)
17:31:44 <dwcook> If you have f = h . g then you can then write i . f to get yet another function, if they all have the right types
17:32:16 <ccapndave> I learnt Scala this morning, and have now moved to Haskell, so hopefully by tomorrow I'll be an expert...
17:32:22 <dwcook> :)
17:32:30 <jle`> one example, in another language, you might have foo( bar( baz( fuz( x ) ) ) )
17:32:45 <jle`> what if you decided that doing baz-then-bar was a useful thing?
17:32:50 <jle`> and you wanted to name it?
17:32:58 <jle`> in haskell, it'd be (foo . bar . baz . fuz) x
17:33:03 <jle`> and if i thought (bar . baz) was useful
17:33:08 <jle`> i can say let barbaz = bar . baz
17:33:12 <ccapndave> ok
17:33:14 <ccapndave> That is pretty cool
17:33:15 <jle`> in (foo . barbaz . fuz) x
17:33:29 <jle`> you just basically plop it right in there
17:33:38 <gspr> I have this attoparsec parser that essentially produces a list of unboxed vectors of ints… when it consumes a huge ByteString it builds up way too many thunks, but I'm a bit confused as to how I can make it stricter…
17:34:16 <MP2E> gspr : I'm not very experienced with attoparsec, but have you tried Bang Patterns?
17:34:24 <jle`> in a deeper sense it allows you to stop thinking about "what am i doing with what values?" and start thinking about "what functions compose to give the function i want?"
17:34:49 <ccapndave> Ok
17:34:53 <ccapndave> I always wanted to learn Haskell
17:35:03 <jle`> this usefulness is fully exploited in math
17:35:09 <MP2E> Composing functions is somehow satisfying to me
17:35:22 <jle`> haskell just happens to be one of the few languages that is able to take advantage of useful things people hav ebeen doing forever in math
17:35:22 <ccapndave> Am I going to be alright, not knowing huge amounts of math?
17:35:30 <gspr> MP2E: That's what I'd normally do… I'm just sort of expecting that this would be explained somewhere in some document called "so, you're parsing a gigabyte worth of bytestrings with attoparsec… here's what you need to remember"
17:35:32 <jle`> of course you are :)
17:36:00 <gspr> MP2E: Currently I'm just blindly throwing in bang patterns :p
17:36:07 <jle`> you don't need to know any outside math
17:36:32 <lfairy> yeah, you learn it as you go along
17:36:37 <MP2E> gspr : That's pretty much what I do, I haven't built a great intuition for them yet so I think of where they would make sense and then profile + compare
17:36:50 <dwcook> ccapndave, going in with previous knowledge of math, you might have a headstart. But you'll pick up what incidentally math-related knowledge you'll need.
17:36:56 <gspr> ccapndave: … but, as you sort of just illustrated - it really helps to have a firm grasp of *one* thing: What is a function (mathematically)?
17:37:56 <gspr> MP2E: Yeah, but profiles with bytestrings always confuse me... it seems that sometimes bytestrings show up as ARR_WORDS, and sometimes (I'm guessing when they're unevaluated slices of other bytestrings?) they show up as ByteString… makes it a bit hard to know what's going on
17:38:33 <johnw> wouldn't ByteString be the box around a pointer into ARR_WORDS?
17:38:41 <MP2E> gspr : ARR_WORDS is just unboxed
17:38:49 <gspr> Ah, right
17:38:52 <gspr> this makes sense
17:39:05 <MP2E> in fact, if you want your parser to be strict, you should probably use Vector.Unboxed
17:39:14 <MP2E> That datatype is strict by default
17:39:33 <gspr> I have one huge bytestring, so that'll only show up (significantly) as ARR_WORDS... and then I build up lots and lots of small slices as thunks, and *these* then mostly show up as ByteStrings
17:39:44 <gspr> well, that they're thunks doesn't matter I guess
17:40:02 <gspr> Hmm, except… yes... they should all be very short-lived, so they probably are thunks
17:40:40 <gspr> MP2E: Well yeah, but it too needs to be evaluated to WHNF, upon which all the elements are evaluated, right?
17:40:55 <ReinH> I think I'm going to have to switch to an emacs irc client now.
17:41:23 <ReinH> johnw: BTW I've been using org-mode to write up notes and exercises for books I'm reading and it's wonderful. LaTeX export is the shit.
17:42:41 <MP2E> gspr : Actually, I think that that forces each cell to be in NF, so each operation on the vector also has to operate strictly. I'm assuming this based off of how unboxed items are stored vs boxed
17:42:55 <MP2E> unboxed don't have to be on the heap so I don't think they can be thunks
17:42:59 <Para__> hey guys - so if we have a tuple, (>) first sorts by the first element, then the second, etc. Is there a way to make it sort by the second element first? (While maintaining generality -- so I'd rather not compose it with snd)
17:43:08 <gspr> MP2E: Ah, you're probably right.
17:43:26 <gspr> MP2E: My problem then is probably due to a bunch of ByteString slices remaining unevaluated for too long
17:43:29 <gspr> thanks
17:43:34 <acowley> ReinH: That sounds great! What benefits are you getting from doing it in org-mode over just LaTeX?
17:43:37 <MP2E> np :>
17:43:53 <ccapndave> Noob question #2
17:43:54 <ccapndave> https://www.fpcomplete.com/user/fpuser5839879/eryt
17:43:57 <ReinH> acowley: les TeX cruft, I can export to HTML as well with MathJax.
17:44:11 <ReinH> So I'm probably going to end up publishing my notes as HTML on my blog.
17:44:13 <gspr> ccapndave: That 404s for me
17:44:14 <dwcook> Para__, howe general do you want? Just pairs, for example, or any tuple?
17:44:26 <ccapndave> I would like to pass an integer to spunReels, but the current reelSymbols is invoked automatically by the curried function.  How can I add a parameter?
17:44:28 <nicoo> a
17:44:29 <Para__> I was hoping just on any Ord
17:44:39 <Para__> but that may not be possible
17:44:47 <ReinH> acowley: I'm currently starting Bird's The Algebra of Programming, which is amazing. https://dl.dropboxusercontent.com/u/632742/algebra_of_programming.pdf
17:44:48 <dwcook> Para__, wait, so you want to reverse the order entirely?
17:44:58 <dwcook> Para__, if a >= b then you want b >= a?
17:45:11 <Para__> no -- I want to sort via the second index instead of the first
17:45:19 <Para__> or the first instead of zeroth
17:45:22 <startling> Para__: how would that work for any Ord?
17:45:25 <Para__> because its a two-tuple
17:45:27 <dwcook> Para__, that's not as general as Ord, it relies on tuple in the description
17:45:30 <Para__> well just sort by the second tuple
17:45:35 <Para__> and default to normal behavior otherwise
17:45:41 <acowley> ReinH: I find myself periodically thinking I'll do more with babel mode, then I get frustrated because it's no way to write code
17:45:44 <startling> ccapndave: Not Found
17:45:54 <Para__> I'm asking because (>) works on any Ord
17:46:04 <ccapndave> Oh
17:46:05 <Para__> but okay
17:46:07 <ReinH> acowley: sounds about right. I'm not even writing any Haskell in my notes right now, except as Birdian pseudocode.
17:46:09 <ccapndave> I haven't quite figured out this IDE yet
17:46:12 <ccapndave> Its awesome though
17:46:20 <startling> ccapndave: I don't have an account; that may be part of it.
17:46:23 <Para__> so I basically need to compose it with snd
17:46:30 <acowley> ReinH: Have you tried doing it literate haskell?
17:46:31 <ccapndave> Me either
17:46:34 <startling> > compare `on` snd
17:46:34 <ccapndave> That may be another part of it
17:46:35 <lambdabot>  No instance for (Data.Typeable.Internal.Typeable a0)
17:46:35 <lambdabot>    arising from a use of ‘M678998384874251244514000.show_M6789983848742512445...
17:46:35 <lambdabot>  The type variable ‘a0’ is ambiguous
17:46:35 <lambdabot>  Note: there are several potential instances:
17:46:35 <lambdabot>    instance Data.Typeable.Internal.Typeable Data.Dynamic.Dynamic
17:46:38 <acowley> ReinH: It has a lot of the benefits
17:46:44 <startling> :t compare `on` snd ;; Para__
17:46:45 <lambdabot> parse error on input ‘;’
17:46:53 <startling> too much clojure >.>
17:46:56 <startling> :t compare `on` snd -- Para__
17:46:57 <lambdabot> Ord b => (a, b) -> (a, b) -> Ordering
17:47:01 <ReinH> acowley: true. I also need to get my feet wet with LaTeX for *reasons* though.
17:47:08 <startling> Para__: is that what you're asking for?
17:47:09 <ReinH> Although I could do literate haskell with latex
17:47:10 <Para__> oh hm
17:47:17 <Para__> yeah that should work!
17:47:22 <dwcook> Para__, special casing tuple isn't impossible, but I doubt it'd be pretty. Look into type families perhaps?
17:47:23 <Para__> although
17:47:33 <dwcook> Ah, never mind
17:47:33 <pavonia> > (compare `on` snd) (1,2) (2,2)
17:47:34 <startling> :t (>) `on` snd -- you can also do stuff like this
17:47:34 <lambdabot>  can't find file: L.hs
17:47:35 <Para__> I'm not sure its quite that startling
17:47:35 <lambdabot> Ord b => (a, b) -> (a, b) -> Bool
17:47:40 <johnw> ReinH: yeah, I'm going to use it build my slides for LambdaJam
17:47:41 <dwcook> So you did want it specific to 2-tuples
17:47:45 <pavonia> > (compare `on` snd) (1,2) (2,2)
17:47:46 <Para__> well
17:47:47 <lambdabot>  EQ
17:47:49 <acowley> ReinH: Yeah, I've done LaTeX in lhs with pretty good success in the past
17:47:50 <Para__> its just going to be 2-tuples
17:47:51 <ReinH> johnw: awesome :D which exporter?
17:47:54 <Para__> or other Ords
17:47:56 <johnw> org-beamer
17:47:57 <acowley> ReinH: It has the advantage of playing pretty well with cabal, etc.
17:48:06 <Para__> I just want the behavior to be different with 2-tuples
17:48:07 <ReinH> acowley: I also love being integrated with the rest of org mode so I can make todos for myself, etc.
17:48:08 <startling> Para__, sorry, I think you'll need to go into more detail
17:48:32 <acowley> ReinH: Yeah, I just haven't been able to make it work for myself... but I keep trying!
17:48:39 <Para__> So basically I want a function that, if given two 2-tuples, it does (>) by the second element, and if not, it defaults to the regular (>) behavior
17:48:43 <ReinH> acowley: :)
17:48:51 <dwcook> Para__, I guess you want a type family
17:48:53 <startling> Para__, that's not very easy to express in Haskell.
17:49:00 <Para__> oh hm
17:49:01 <Para__> okay
17:49:08 <startling> Para__: there's extensions you can use, but mostly the way we do that is by not wanting it.
17:49:22 <Para__> hm alright -- thanks
17:49:58 <dwcook> We are like monks who rebuke temptation for non-pretty things :P
17:50:14 <dwcook> (Not to say Haskellers don't do ugly things :P)
17:50:15 <Para__> :P
17:50:18 <ReinH> Para__: You can turn a into ((),a) to get that behavior.
17:50:49 <ReinH> Since () is always EQ to itself, it won't affect the sorting.
17:52:40 <ReinH> You can't write a single function that works on two different types though, so we generally look for other solutions.
17:52:50 <Para__> oh hm okay
17:52:52 <Para__> thanks
17:53:45 <sgronblo> class (DataSourceName, StateKey req, Show1 req) => DataSource u req where   -- What is the point of the DataSourceName in this line? Aren't these things supposed to quantify one of the expressions that come later, like StateKey and Show1 are doing?
17:53:51 <ReinH> if the thing in the middle is a good consumer and producer, map snd . thing . map ((,) ()) should be pretty inexpensive due to short-cut fusion.
17:54:31 <ccapndave> ooh, this is hard :)
17:54:34 <ccapndave> spunReels :: [Reel] -> [Reel]
17:54:34 <ccapndave> spunReels = map (take 3 . drop 30)
17:54:51 <ccapndave> I am trying to get a 'cycle' in there so that the list is never ending.  I can't figure out where to put it
17:55:18 <ReinH> :t take 3 . drop 30 . cycle
17:55:19 <lambdabot> [a] -> [a]
17:55:23 <ReinH> ccapndave: not in the obvious place, I guess?
17:56:01 <ccapndave> what the devil
17:56:05 <ccapndave> That didn't work before
17:56:15 <ccapndave> This IDE seems slightly flakey
17:56:15 <ReinH> ~~~~magic~~~
17:56:28 * hackagebot hs-nombre-generator 0.2.1.0 - Name generator.  http://hackage.haskell.org/package/hs-nombre-generator-0.2.1.0 (alvare)
17:56:41 <ccapndave> Thanks :)
17:56:57 <pavonia> sgronblo: This must be a mistake. Is that from compiling source code?
17:57:14 <sgronblo> pavonia: no, its from https://github.com/facebook/Haxl/blob/master/example/sql/readme.md
17:57:32 <ReinH> ccapndave: specifically, http://i.imgur.com/iZcUNxH.gif
17:57:49 <ccapndave> Nice unicorn
17:58:12 <pavonia> sgronblo: So either u or req is missing there
17:59:21 <ReinH> sgronblo: type in the docs, submit a PR to fix it :D
17:59:27 <ReinH> sgronblo: should be https://github.com/facebook/Haxl/blob/74a3874f0b0a83e4f3c90c1455a37b9d17f2ead7/Haxl/Core/Types.hs#L141
17:59:49 <ccapndave> ReinH Who is that dude
17:59:50 <ReinH> *typo
17:59:58 <ccapndave> ReinH I want to watch the whole show
18:00:03 <ReinH> ccapndave: haha I'm not sure actually
18:00:19 <ReinH> Also typo in "typo" for proper irony.
18:00:43 <Para__> also
18:00:53 <Para__> suppose I define my own data type: data Point = Point Int Float
18:01:15 <Para__> if I want to have a function with this type signature
18:01:22 <Para__> which is considered better -- to have a restriction
18:01:24 <Para__> like
18:01:32 <Para__> Point p => p -> p
18:01:32 <Para__> or
18:01:36 <Para__> to do something like
18:01:38 <Para__> Point -> Point
18:03:06 <ReinH> Para__: you can't do Point p because Point is not a constraint.
18:03:15 <ccapndave> It seems to be very confusing to generate a random number in Haskell
18:03:15 <ReinH> only typeclasses can be constraints
18:03:23 <Para__> isn't Point a constraint though?
18:03:24 <Para__> since I did
18:03:26 <Para__> data Point
18:03:35 <Para__> data Point = Point Int Float
18:03:41 <ReinH> Point is not a typeclass.
18:03:47 <ReinH> So it can't be used as a constraint.
18:03:48 <sgronblo> ReinH, pavonia: thanks for confirming i wasn't as stupid at haskell as i feared
18:03:52 <Para__> (wouldn't point be both a typeclass and a type?)
18:04:00 <ReinH> Para__: why would it be a typeclass?
18:04:14 <Para__> if I did
18:04:14 <ReinH> Typeclasses are introduced with `class`, not `data'.
18:04:23 <Para__> data Bool = True | False
18:04:26 <Para__> Bool is a typeclass?
18:04:30 <Para__> ohhh
18:04:31 <ReinH> Bool is a type
18:04:34 <Para__> gotcha
18:04:38 <Para__> okay
18:04:41 <Para__> sweet thanks
18:05:36 <jle`> was listening to ReinH's haskell casts and noticed all the lack of appreciation for arrow
18:05:39 <ccapndave> Note that you can get an infinite list of random values using the IO monad and use that [Int] in non-IO functions.
18:05:42 <ccapndave> Er
18:05:46 <ReinH> jle`: arrow is stupid and we hate it.
18:05:48 <ccapndave> Anyone know how to get that infinite list?
18:05:49 <jle`> :'(
18:05:52 <ReinH> jle`: :p
18:05:58 <jle`> i'm writing a library with an arrow api
18:06:03 <jle`> so maybe it can be my life crusade
18:06:08 <jle`> to bring arrow back
18:06:14 <jle`> by life crusade i mean summer project
18:06:37 <ReinH> jle`: the thing about arrow is that it's off by itself being weird while Monad and such are better connected to the rest of the typeclasses
18:06:50 <jle`> ccapndave: if you have an IO a, you can use normal (a -> b) functions fine
18:06:55 <ReinH> It might be nice if Arrow was written in terms of component pieces like Bifunctor
18:06:56 <jle`> by using fmap
18:07:02 <jle`> which turns an (a -> b) into an (IO a -> IO b)
18:07:25 <ReinH> But they didn't really exist when Arrow was discovered.
18:07:43 <ReinH> Meanwhile, Monad has been broken down into at least 100 different typeclasses by now.
18:09:02 <jle`> the bifunctor aspects of Arrow are less important to me than the profunctor aspects
18:09:11 <jle`> but i guess that latter part comes from Category
18:09:13 <jle`> not from Arrow
18:09:15 <jle`> er
18:09:21 <jle`> no, Arrow imbues profunctorness
18:09:30 <ReinH> jle`: yeah, that too
18:09:45 <ReinH> But you don't need Arrow for either, is more my point.
18:09:51 <ReinH> It's the other way around.
18:09:55 <jle`> but honestly i think that usage of first and second and (&&&) and (***) for the (->) instance
18:09:57 <jle`> is an abuse of Arrow
18:10:06 <jle`> peope shouldn't need Arrow to do tuple manipulation
18:10:22 <ReinH> Well, fan out is really useful for program derivation, so ofc they're going to get used
18:10:32 <ReinH> but they aren't really leveraging the typeclass
18:10:37 <jle`> i'm all for making Bifunctor idiomatic tuple manipulation thingies, but it sort of makes arrow look kinda silly
18:10:46 <jle`> s/but/and
18:11:43 <jle`> but arrows are good for composition and side chained composition
18:11:45 <ReinH> Ok, I did my maths reading for today, time for video games. :p
18:11:56 <ccapndave> jle`
18:11:58 <jle`> and also proc do notation is expressive
18:12:02 <drdo> I haven't written haskell in a while, but i remember wanting to define lots of combinators to make code less awkward to write
18:12:03 <ccapndave> Wowzas this is complicated
18:12:13 <jle`> ccapndave: what is?
18:12:18 <ccapndave> Trying to get a random number
18:12:50 <jle`> evalRandIO (randomR (0.0,1.0) ?
18:12:54 <ReinH> @hoogle randomR
18:12:56 <lambdabot> System.Random randomR :: (Random a, RandomGen g) => (a, a) -> g -> (a, g)
18:12:56 <lambdabot> System.Random randomRIO :: Random a => (a, a) -> IO a
18:12:56 <lambdabot> System.Random randomRs :: (Random a, RandomGen g) => (a, a) -> g -> [a]
18:13:09 <ReinH> If you don't need any special distributions, one of these will often do.
18:13:14 <jle`> anyways i shall make my arrow based library and people will love it and nobody will ever talk bad about arrow again
18:13:30 * jle` sheds a single tear
18:13:55 <ccapndave> print $ evalRandIO (randomR (0.0 1.0)
18:14:08 <MP2E> I'm guessing you're reading LYAH, ccapndave ? in that case, I wouldn't worry about it. LYAH introduces random numbers with a very verbose notation that is a bit tedious to write
18:14:10 <jle`> randomR takes a tuple for some reason
18:14:24 <MP2E> thankfully it covers Monads a few chapters later, which will remove a lot of the boilerplate and tedium.
18:14:37 <ccapndave> print $ evalRandIO (randomR (0.0, 1.0))
18:15:12 <ccapndave> No instance for (Show (IO a0)) arising from a use of 'print'
18:15:13 <ccapndave> er
18:15:29 <jle`> did i mix up functions
18:15:41 <jle`> also you can't print IO a
18:15:52 <jle`> print :: a -> IO ()
18:15:54 <jle`> but you have an IO a
18:16:03 <jle`> so you need a function to turn print into an IO a -> IO ()
18:16:05 <jle`> yes?
18:16:30 <ccapndave> I'm going to say yes
18:16:37 <jle`> because you have an IO a
18:16:41 <jle`> and you want to print the result
18:16:46 <jle`> print is a -> IO a
18:16:49 <ccapndave> The result is a without the IO bit
18:16:50 <jle`> but you have an IO a
18:16:54 <ccapndave> ?
18:16:55 <jle`> so you need an IO a -> IO a
18:17:03 <jle`> er, print is a -> IO ()
18:17:06 <jle`> so you need an IO a -> IO ()
18:17:13 <ccapndave> Ah
18:17:14 <ccapndave> Right
18:17:17 <jle`> the answer is (=<<)
18:17:32 <jle`> (print =<<) :: Show a => IO a -> IO ()
18:17:43 <jle`> so you would do print =<< evalRandIO (randomR (0.0, 1.0))
18:18:10 <jle`> also...evalRandIO is the wrong function I think, sorry >.<
18:18:16 <ccapndave> It doesn't like that
18:18:22 <ReinH> ccapndave: print =<< fmap (take 10 . randoms) newStdGen
18:18:38 <jle`> ah i was mixing up Monad.Random
18:18:47 <jle`> i prefer print . take 10 . randoms =<< newStdGen
18:19:01 <ReinH> or, generally: do { xs <- fmap ransoms newStdGen; doStuffWith (xs :: [Int] }
18:19:07 <ReinH> heh ransoms woops
18:19:16 <ccapndave> print =<< fmap (take 10 . randoms) newStdGen
18:19:18 <ReinH> also missing paren
18:19:29 <ccapndave> Ambiguous type variables
18:19:31 <MP2E> fmap ransoms president
18:19:33 <ccapndave> Let me type the other syntax
18:19:52 <ReinH> jle`: that's better, yes
18:19:55 <jle`> (print . take 10 . randoms) :: StdGen -> IO ()
18:20:05 <ccapndave> print . take 10 . randoms =<< newStdGen
18:20:22 <ccapndave> Ambiguous type variable 'a0' in the constraints (Show a0) arising from a use of 'print'
18:20:44 <ReinH> > print . take 10 . randoms =<< newStdGen
18:20:46 <ReinH> should work
18:20:46 <lambdabot>  <IO ()>
18:20:53 <ReinH> typechecks
18:20:56 <jle`> it works for me on my ghci
18:21:01 <jle`> but i can see why it isn't supposed to work
18:21:08 <jle`> if you're on ghci yuo can just do this
18:21:09 <ccapndave> I'm doing it in main :: IO()
18:21:14 <jle`> ah
18:21:20 <ccapndave> Should I do it elsewhere?
18:21:23 <jle`> then do
18:21:27 <jle`> gen <- newStdGen
18:21:38 <jle`> let randomList = randoms gen :: [Double]
18:21:45 <jle`> print (take 10 randomList)
18:21:46 <Para__> I'm having trouble understanding the composition inside of the first parentheses. What is it composing? f a b = (. snd) . (>) . snd a b
18:21:50 <Para__> if you write it out without composition
18:21:57 <Para__> would the dot be at the beginning and outside?
18:22:21 <Para__> so wouldn't you get something like
18:22:31 <jle`> Para__: do you know about operator sections?
18:22:38 <Para__> (. snd) >(snd a) b
18:22:52 <Para__> uh I don't think so -- should I read up on those?
18:23:02 <jle`> it's simple enough
18:23:09 <jle`> when you do something like (* 2)
18:23:21 <jle`> it interprets it as a function "waiting" for the number to go to the left of the *
18:23:26 <jle`> > (* 2) 5
18:23:27 <lambdabot>  10
18:23:30 <jle`> > (/ 2) 12
18:23:32 <lambdabot>  6.0
18:23:38 <ccapndave> jle` Hooray!  Random numbers
18:23:44 <jle`> (/ 2) is basically "waiting" for the number to go on the left of the /
18:23:44 <Para__> alright
18:23:45 <ccapndave> I have no idea what you just told me to do
18:23:48 <ccapndave> But it works
18:23:55 <jle`> ccapndave: are you working through a book/tutorial?
18:24:01 <jle`> you should understand it in due time
18:24:09 <Para__> that makes sense
18:24:18 <devn> ccapndave: think about it like you're threading a needle
18:24:19 <ccapndave> I am leafing through learn you a haskell (I've read it before a long while ago too)
18:24:27 <jle`> the problem is that randoms is a polymorphic/overloaded function that is polymorphic on the *return* type
18:24:31 <devn> the needle goes between the / and 2, and hits the 12
18:24:36 <devn> 12 2
18:24:39 <jle`> so if i ask randoms to give me an [Int]
18:24:41 <devn> err, / 12 2
18:24:44 <jle`> it'll give me an [Int]
18:24:55 <jle`> if i ask randoms to give me a [Double], it'll give me a [Double]
18:24:58 <ccapndave> Ok
18:25:00 <jle`> this is all resolved at compile-time
18:25:03 <ccapndave> ah
18:25:11 <jle`> randoms-to-get-double is different than randoms-to-get-int
18:25:11 <ccapndave> That's what the randoms gen :: [Double] means
18:25:21 <jle`> at the compiled assembly level
18:25:27 <jle`> and even at the intermediate compiled level
18:26:05 <jle`> you can think of "randoms gen" as a function that compiles differently based on the return type you want out of it.  GHC looks in a "dictionary" of sorts and says, "oh, he wants a [Double]? let me compile the [Double] version."
18:26:18 <jle`> the problem was that in the original version, you gave no clue about what type you wanted your random list to be of
18:26:24 <jle`> so GHC has no idea what function to compile
18:26:37 <ccapndave> Can I get a range?
18:26:42 <ccapndave> let randomList = filter (\x -> x > 0 && x < 10) (randoms gen :: [Int])
18:26:46 <Para__> jle` -- still though, wouldn't you get something like  a ((. snd)>(snd b))
18:26:49 <ReinH> ccapndave: randomRs
18:26:53 <ccapndave> I expect this will work eventually but its not too performance :)
18:26:54 <jle`> ccapndave: http://hackage.haskell.org/package/random-1.0.1.1/docs/System-Random.html
18:27:06 <ReinH> Para__: that compares the function (. snd) to the function (snd b)
18:27:07 <Para__> wait
18:27:13 <jle`> ctrl+f fr "class Random a where"
18:27:16 <Para__> yeah
18:27:17 <Para__> well
18:27:19 <Para__> originally it was
18:27:24 <Para__> (. snd) . (>) . snd
18:27:27 <jle`> or if you're on ghci, import System.Random and type :i Random
18:27:28 <Para__> applied to a b
18:27:31 <ReinH> well, one of those is a function, and the expression as a whole won't typecheck.
18:27:34 <Para__> let me try something really quick
18:27:50 <Para__> yeah still
18:27:59 <Para__> I'm unclear on why there is a (.) at the beginning
18:28:06 <jle`> ccapndave: you can do that :)  but remember to use `take` when you eventually want it
18:28:12 <ReinH> Para__: let's look at (. foo) and ignore everything else
18:28:20 <jle`> but randomR is probably a better option :P
18:28:22 <Para__> alright
18:28:23 <ReinH> :t (. snd)
18:28:24 <lambdabot> (b -> c) -> (a, b) -> c
18:28:27 <Go_> look here please http://adf.ly/pqAbN
18:28:29 <ReinH> what does that tell yuo?
18:28:48 <Para__> takes two functions
18:28:56 <Para__> and composes them, but in reverse
18:28:59 <ReinH> Does it?
18:29:04 <ReinH> Is (a,b) a function?
18:29:08 <Para__> oh wait no
18:29:11 <Para__> takes a function and a tuple
18:29:20 <Para__> and applies the function the the second element of the tuple
18:29:26 <ReinH> right
18:29:33 <Para__> oh
18:29:37 <Para__> that makes sense then
18:29:44 <Para__> ohhhhh
18:29:46 <Para__> okay
18:29:50 <Para__> it just clicked
18:29:53 <Para__> thanks :)
18:29:55 <jle`> Para__: (. snd) f === f . snd
18:30:12 <nomeata> http://jenkins.stackage.org lists all stackage builds as failing. What does that mean?
18:30:16 <Para__> :t (. snd) f === f . snd
18:30:17 <lambdabot>     No instance for (FromExpr c0) arising from a use of ‘f’
18:30:17 <lambdabot>     The type variable ‘c0’ is ambiguous
18:30:17 <lambdabot>     Note: there are several potential instances:
18:30:26 <jle`> === is my pseudo code heh.
18:30:29 <Para__> oh
18:30:29 <Para__> wait
18:30:33 <Para__> hah
18:30:33 <Para__> yeah
18:30:35 <Para__> just realized that
18:30:37 <jle`> the more ====='s means the bigger the point i want to make
18:30:46 <jle`> f . id ========== f
18:31:08 <jle`> :t \f -> f . snd
18:31:09 <lambdabot> (b -> c) -> (a, b) -> c
18:31:11 <jle`> :t (. snd)
18:31:12 <lambdabot> (b -> c) -> (a, b) -> c
18:31:39 <Para__> :t (.)
18:31:40 <lambdabot> (b -> c) -> (a -> b) -> a -> c
18:32:09 <Para__> got it
18:32:09 <Para__> :)
18:32:15 <Para__> @botsnack
18:32:15 <lambdabot> :)
18:39:24 <Para__> alright
18:39:26 <Para__> last question for today
18:39:43 <Para__> so I have this:
18:39:44 <Para__> data Point = Point {x::Integer, y::Float} deriving (Show)
18:39:52 <Para__> is there any way to make it so that when I do
18:39:58 <Para__> print p (if P is a point)
18:40:06 <Para__> so that it prints (x, y)
18:40:30 <ReinH> Para__: define your own Show, but Show is not for pretty-printing.
18:40:36 <gspr> Para__: You can implement your own Show instance, but it's not meant for that
18:40:59 <Para__> is there a pretty-printing thing that is commonly used?
18:41:04 <gspr> Show is meant to produce Strings that would be valid ways of constructing the values
18:41:06 <Para__> that I should define?
18:41:34 <gspr> Para__: If you're just gonna do this for Point, why not just make a function point2String :: Point -> String?
18:42:39 <Para__> oh hm
18:42:40 <Para__> okay
18:43:46 <sgronblo> so Show is like a serializable interface?
18:45:03 <joelteon> sorta
18:45:06 <nomeata> sgronblo: in a way, yes. But people recommend against using it for serialization
18:45:45 <sgronblo> so why should it "produce Strings that would be valid ways of constructing the values"?
18:46:30 <Para__> ok actually final question:
18:46:35 <Para__> suppose I have a list of functions
18:46:55 <jle`> sgronblo: you don't normally serialize data structures by writing down ways to construct them, do you?
18:46:55 <Para__> is there a way to apply each of these functions to the corresponding element in another list
18:47:03 <Para__> map usually would do it if I were just trying to do many to 1
18:47:05 <gspr> Para__: zipWith ($)
18:47:08 <Para__> ah
18:47:13 <Para__> idk why I didn't think of that
18:47:33 <gspr> :)
18:47:34 <jle`> ZipList fs <*> ZipList xs
18:47:42 <jle`> but you have to unwrap it later v.v
18:47:43 <Para__> :)
18:47:53 <Para__> awesome
18:47:56 <Para__> alright its getting late
18:48:02 <Para__> thank you very much guys
18:49:03 <Para__> actually jk
18:49:03 <Para__> one last one
18:49:16 <Para__> can I pattern match to an empty string?
18:49:30 <Para__> should I just use []
18:49:30 <Para__> ?
18:50:08 <rwbarton> that works, or "" is clearer
18:50:43 <Para__> alright awesome
18:50:44 <Para__> thanks!
18:51:27 <Para__> hmm
18:51:31 <Para__> it gave me a "Parse error"
18:52:14 <Para__> wait just kidding
18:52:17 <Para__> I messed up recursion
19:03:36 <dwcook> Para__, [] and "" both stand for the empty string, but [] is more general than that (without extensions).
19:03:51 <johnw> as do mempty, empty, and mzero even ;)
19:03:52 <dwcook> s/that/""/
19:04:04 <dwcook> Sure, I mean in patterns though
19:04:07 <johnw> ah
19:04:16 <Lutin`> They're both more general
19:04:25 <Lutin`> if you have OverloadedStrings for instance
19:04:34 <johnw> I love generality; sorry I can't be more specific
19:04:34 <dwcook> Lutin`, I accounted for that possibility in my statement
19:04:44 <Lutin`> So you did :X
19:04:56 <Lutin`> Woops, soz
19:15:32 <sclv> @tell phi__ the “universal” solver for ODEs is an adaptive euler that just reduces stepsize as things get fiddly. an implcit euler is sometimes better if i recall. low order implicit BDF methods are also very general purpose
19:15:32 <lambdabot> Consider it noted.
19:16:11 <sclv> @tell phi__ of course if these methods are waay slower than the stuff you can do if your ode is “nice”
19:16:11 <lambdabot> Consider it noted.
19:18:47 <sclv> @tell phi__ and this is my fav book on numerical methods, even though it is very dated: http://www.amazon.com/Numerical-Methods-Scientists-Engineers-Mathematics/dp/0486652416
19:18:47 <lambdabot> Consider it noted.
19:29:48 <xpika> is there a datastructure with fast prepend and fast lookup?
19:29:59 <platz> data.sequence
19:30:02 <xpika> of the list variety
19:30:12 <platz> i think
19:30:36 <xpika> platz: can you explain what O(log(min(i,n-i))) means?
19:31:04 <sclv> xpika: note that it has great asymptoics but crummy constant factors
19:31:11 <sclv> and fast _append_ is its distinguishing feature
19:31:25 <platz> I think it's basically O(log(n))
19:31:32 <sclv> normal lists have O(1) append, its just the lookup thats sorta rough
19:31:46 <sclv> are you looking for something more heap-like?
19:31:51 <MP2E> basically it means take whatever is smaller, i or n-i and pass it to log
19:31:58 <smorodin> why this structure does have fast lookup?
19:31:59 <MP2E> so yeah O(log(N)) in most cases
19:32:01 <sclv> or by lookup do you mean random access?
19:32:15 <sclv> like i can prepend on front, everything stays in order, but i also can index to the nth element fast?
19:32:27 <xpika> sclv: yes
19:33:05 <platz> yes that's harder
19:33:17 <sclv> in general with persistent structures you won’t do better than log(n) for lookup… but that can be plenty fast depending on what you want
19:34:50 <platz> Is there such a thing a zipper than can have multiple holes?
19:35:16 <sclv> platz: sure.
19:35:29 <platz> learned about Statecharts tonight and there seemed to be some similarities
19:35:46 <platz> one cool thing they have is a state which has multiple concurrent states
19:36:06 <sclv> so consider a list zipper as [a] [a], where the first list is “so far” and the second list is “not yet”
19:36:13 <platz> was thinking it (since they are nested trees) zippers could model this, but didn't know about the "concurrent" part
19:36:16 <sclv> now just “double zip” the first bit
19:36:33 <sclv> and you have [a] [a] [a] where you have “two holes” and the bit in the middle… easy!
19:36:47 <sclv> but yeah there’s obv no concurrency here.
19:37:00 <platz> i don't mean concurrency in the literal sence
19:37:01 <platz> sense
19:37:16 <sclv> but yeah, with [a] [a] [a] you can zip around in either hole
19:37:17 <platz> more like multiple 'selected' states at the same time
19:37:37 <sclv> in general i suppose [[a]] works for a list zipper with arbitrary holes
19:37:44 <platz> but there would also have to be a way , if one moved up the graph, to collapse some of the holes
19:37:55 <sclv> you can generalize the same notion to trees easy
19:38:03 <sclv> its just repeated differentiation if you know conor’s stuff
19:38:24 <sclv> xpika: what’s yr use case for the structure? i can find you something you want
19:38:47 <platz> http://www.wisdom.weizmann.ac.il/~harel/papers/Statecharts.pdf
19:38:58 <platz> sclv: thanks i'll do some digging
19:43:09 <sclv> xpika: okasaki’s random access lists are about the best option for what you’ve described. i can’t vouch for this package, but you can read the paper too: -) http://hackage.haskell.org/package/random-access-list
19:43:20 <knapper_tech> how do I set a .cabal config file to compile the package statically?
19:43:37 <knapper_tech> I would like to limit the amount of dependencies that I need to deploy to my server
19:43:47 <sclv> of course you can probably do better by simulating an array with an IntMap, in real world usage :-)
19:44:02 <knapper_tech> and make it so that the production server has a minimum set of functionality =)
19:44:19 <sclv> note that your branching will never exceed log(64), so its “constant enough” :-P
19:44:48 <platz> xpika: If you can limit the mutation to a specific step, there's always the option of using an MVector and then freezing it
19:47:09 <sinelaw> aloha
19:54:25 <xpika> sclv: looks sweet
20:20:13 <xpika> sclv: somehow it doesn't seem to be faster than [a]
20:20:39 <sclv> it won’t be unless you have _huge_ lists
20:20:57 <xpika> sclv: i've created a 1,000,000 size linked list
20:21:13 <xpika> sclv: and its three times slower for lookup
20:21:50 <sclv> yeah like i said the constant factors will kill you :-)
20:22:12 <sclv> also i have no doubt that package isn’t optimized at all
20:23:16 <xpika> sclv: is there a website which benchmarks haskell data types?
20:23:35 <sclv> not the more exotic ones
20:23:53 <xpika> how about the less exotic ones
20:23:54 <xpika> ?
20:25:30 <rwbarton> I can't imagine lookup into a million-element Seq is slower than a list
20:25:38 <rwbarton> unless you are looking very close to the start of the list
20:27:00 <xpika> rwbarton: i can make a gist for you
20:27:53 <chrisdotcode_> is there any particular reason why Lists aren't optimized to Vectors or something more efficient, but isomorphic under the hood?
20:28:50 <jle`> chrisdotcode_: do you mean []?
20:28:59 <jle`> [] is not meant to store data
20:29:13 <jle`> [] is basically streaming control flow
20:29:59 <chrisdotcode_> jle`: but is there a particular reason they aren't optimized to something like a vector? am I wrong in that they're isomorphic (or at least, vector implements the list interface)
20:30:01 <jle`> you can think of [] as basically just a data type representing a function [a] -> (a, Maybe [a])
20:30:02 <chrisdotcode_> ?
20:31:01 <jle`> because you don't use lists like you'd use vectors
20:31:15 <jle`> what about infinite lists?
20:31:23 <rwbarton> there are a lot of differences, laziness in the spine, sharing behavior
20:31:29 <jle`> sharing too, yes
20:31:38 <jle`> having lists this way makes lists even more performant than vectors for streaming
20:31:39 <chrisdotcode_> so then how come "use vectors" is a commonly listed optimization technique?
20:31:51 <jle`> it's not an optimization technique, it's "lists are not what you want"
20:32:00 <jle`> people use lists for the wrong reasons
20:32:23 <jle`> it's like if someone was using the strings "True" and "False" to represent Boolean values
20:32:30 <jle`> and someone said "you should use Bool instead of String"
20:32:35 <jle`> that's not an optimization technique
20:32:42 <jle`> (although it would probably give you a fair performance boost)
20:32:56 <jle`> it's just...you aren't supposed to use strings to represent true/false >_>
20:32:57 <chrisdotcode_> so the use cases for lists are streaming and recursion, sure
20:33:03 <chrisdotcode_> and the vectors' primary purpose?
20:33:28 <jle`> data storage with efficient access
20:33:34 <rwbarton> random access to an array
20:34:07 <jle`> yeah, efficient random access
20:34:38 <rwbarton> though there is also the fusion system which makes them more like lists again
20:38:27 <yomritoyj> Data.List has two definitions of reverse which differ only by an inlined function. Why?  http://stackoverflow.com/questions/24391077/why-two-definitions-of-reverse-in-haskells-data-list
20:45:13 <WraithM> Is there a good way to schedule functions to be executed? I mean something like a cron script in a program. I want to execute some stuff like say, every Tuesday and Thursday at midnight or something.
20:46:42 <xpika> is there any way to map a monad over a tuple.
20:46:57 <WraithM> xpika: What do you mean?
20:47:02 <aardvark315> @help
20:47:02 <lambdabot> help <command>. Ask for help for <command>. Try 'list' for all commands
20:47:09 <aardvark315> @list
20:47:09 <lambdabot> What module?  Try @listmodules for some ideas.
20:47:18 <aardvark315> @listmodules
20:47:18 <lambdabot> activity base bf check compose dice dict djinn dummy elite eval filter free fresh haddock help hoogle instances irc karma localtime more oeis offlineRC pl pointful poll pretty quote search slap source spell system tell ticker todo topic type undo unlambda unmtl version where
20:47:21 <ReinH> WraithM: cron sounds good for that ;)
20:47:30 <ReinH> aardvark315: you can also message lambdabot directly
20:47:37 <xpika> > join (***) print $ (1,2)
20:47:38 <lambdabot>  (<IO ()>,<IO ()>)
20:48:06 <WraithM> ReinH: Sure, but is there a good way to have similar functionality in a running Haskell application.
20:48:21 <WraithM> ?
20:48:33 <ReinH> I'm not sure. I've always just used cron.
20:48:39 <WraithM> Fair enough
20:48:53 <sgronblo> I'm trying to understand the use of forall by reading this article: http://en.wikibooks.org/wiki/Haskell/Existentially_quantified_types there's this [Showbox] example. But I don't see why you couldn't just define f :: (Show a) => [a] -> IO()?
20:49:14 <sgronblo> Is forall only about kind of syntax sugaring away the => constraint into a data type?
20:49:41 <ReinH> sgronblo: have you tried your version? Does it compile?
20:50:26 <sgronblo> ReinH: nope, I'm at work so I'm goofing enough already by just reading these articles :)
20:50:32 <sgronblo> goofing off
20:51:32 <sgronblo> Does this mean that ghc would write me a long essay if I tried to enter that as the type instead?
20:54:25 <rwbarton> that would be fine
20:54:31 <ReinH> sgronblo: For f :: (Show a) => [a] -> IO (), all the a's have to be the same.
20:54:54 <rwbarton> but heteroList wouldn't be fine if you tried to do something similar
20:56:35 <sgronblo> ReinH: ah, so obvious :)
21:15:40 <jle`> WraithM: do you just want to leave your haskell process running all day?
21:28:12 <krax_> hey all, im just starting out with haskell by doing some ProjectEuler problems.  Ive got a nice runnable main function, but it stinks having to "import qualified ProblemXX" and manually walk through all the problems like that
21:28:42 <krax_> anyone point at something to dynamically load or run my modules?
21:36:51 <solidus-river> how do i open up ghci in my modules root and have it work
21:36:59 <solidus-river> i've tried ghci -isrc
21:37:03 <solidus-river> but it wont :load my modules
21:37:23 <solidus-river> i forget how i do it because i've been working with a newer version of cabal with nicer commands / sandbox's
21:39:55 <solidus-river> wierd, i have no clue how i used to do this
21:40:05 <solidus-river> it definitely works fine some way
21:41:57 <levi> jle`: I leave several bash processes running all day... why should they have all the fun?
21:42:10 <MP2E> hmm, is defining bind in terms of join for a Monad instance generally slower than defining the instance directly? This is more a question of GHC's optimization capabilities, than anything
21:42:28 <MP2E> Naively speaking, it seems that defining bind and then defining join in terms of bind would produce better performing code
21:42:35 <solidus-river> balls, i got it, i was missing deps
21:42:58 <chrisdotcode_> how do you iterate over a Data.Aeson.Value, if it's an Object? Do I have to explicitly pattern match out the (Object o), and use the HashMap traverse instance?
21:43:05 <chrisdotcode_> because that ugly
21:43:08 <chrisdotcode_> *that seems
21:43:50 <levi> There's probably some nice lensy way to do it in just a few characters.
21:44:04 <solidus-river> MP2E: it depends on the compiler, there are some amazing blog posts on performance in haskell / optimization that are worth reading
21:44:08 <solidus-river> let me dig them up
21:45:01 <chrisdotcode_> levi: I thought the same; but if that's the case, then it should also be possible to do without lenses
21:45:56 <MP2E> Make Object an instance of Traversable? (I'm not familiar with HashMap so I'm not sure how general its traverse function is)
21:46:09 <chrisdotcode_> oh, now I"m confused
21:46:20 <chrisdotcode_> Object is both the name of a type constructor *and* a data constructor
21:46:31 <chrisdotcode_> I didn't see that before
21:46:39 <chrisdotcode_> that might help me slightly
21:47:15 <solidus-river> MP2E: http://stackoverflow.com/questions/6121146/reading-ghc-core
21:47:24 <MP2E> neat, thanks!
21:47:24 <solidus-river> ^ great for core / profiling / optimizing
21:47:35 <solidus-river> MP2E: http://blog.ezyang.com/2011/04/evaluation-on-the-haskell-heap/
21:47:36 <rrradical> I am having so much trouble allocing an array of floats to pass through FFI to a C function. This example is one the wiki but it won't compile on my ghc: http://lpaste.net/106261
21:47:50 <solidus-river> ^ really good breakdown of how laziness / the heap equates to performance
21:50:00 <levi> chrisdotcode_: Well, lens Prisms are handy for peeking into sum types.
21:50:06 <heatsink> rrradical: It's simpler if you don't need to rely on garbage collection
21:50:26 <sinelaw> what's a good queue  type for appending/removing stuff off the end?
21:50:30 <chrisdotcode_> levi: my lens knowledge is 0 right now
21:50:59 <heatsink> rrradical: Use mallocArray to allocate, free to deallocate, peekArray to read an element, and pokeArray to write an element.
21:51:06 <levi> Lens is pretty powerful stuff, but can be daunting.
21:51:18 <chrisdotcode_> so I've heard :)
21:51:23 <rrradical> heatsink: hmm, well I'm creating an interface for a type that I'll use throughout my code. I'd like to be able to treat them as normal haskell values
21:51:24 <chrisdotcode_> also that they compose backwards, whatever that means
21:51:25 <MP2E> I think lens gets a worse rap than it deserves :P It isn't all *that* complex. It is big, though.
21:52:09 <MP2E> I've found it to be generic and fast, and there aren't a lot of those :P If something is generic and fast you can usually bet the author is on to something
21:52:51 <heatsink> rrradical: Then you'll want ForeignPtr to let the garbage collector manage deallocation.
21:52:55 <levi> chrisdotcode_: I wouldn't worry about the 'compose backwards' thing. They only compose backwards if you're expecting something different than what they do. They compose with the standard function composition operator.
21:53:07 <chrisdotcode_> levi: sounds cool
21:53:14 <heatsink> rrradical: file:///Library/Haskell/doc/ghc-doc/libraries/haskell2010-1.1.1.0/Foreign-ForeignPtr.html
21:53:27 <heatsink> ForeignPtr is a wrapper around a Ptr
21:53:38 <rrradical> heatsink: yea, I got to there. but I can't get unsafeForeignPtrToStorableArray to typecheck
21:54:06 <levi> chrisdotcode_: They're very cool, and can lead to very clean and concise code over complex data. But occasionally you end up butting heads with some crazy-looking type signatures.
21:54:13 <rrradical> heatsink: the example in the wiki doesn't even work for me
21:54:20 <MP2E> Hahah. Yeah, it's more getting over how daunting the types look
21:54:22 <heatsink> Why do you want unsafeForeignPtrToStorableArray?
21:54:26 <MP2E> Lens' helps with this
21:54:36 <chrisdotcode_> levi: yeah, that's my primary worry as of now; I've read the blog post on the type signatures not being very nice looking
21:54:39 <levi> chrisdotcode_: Just check out the examples in Data.Lens.Aeson
21:55:10 <chrisdotcode_> "key :: (FromJSON v, ToJSON v) => Text -> IndexedLens' ValueIx (Maybe Value) (Maybe v)"
21:55:12 <chrisdotcode_> aaahhhhhhhhh
21:55:18 <heatsink> I'll see about removing the obsolete function example from the wiki
21:55:52 <chrisdotcode_> the code looks sexy, but the type signatures complexity make me cry
21:56:07 <levi> chrisdotcode_: It's not as bad as it looks, at least most of the time.
21:56:20 <rrradical> heatsink: hmm, I guess I don't need it. so I just keep the foreign pointer around and pass that in to my ffi functions. thanks, I'll try that
21:56:54 <levi> I mean, that just says you give it a Text and you get an IndexedLens. Once you know the things you can do with an IndexedLens, you're golden.
21:57:37 <MP2E> IndexedLens is just a lens with an index and a lens is just a fancy 'getter' and 'setter'. But a bit more generic :)
21:57:56 <MP2E> Lens essentially is an isomorphism at its core, a mapping to and from some sort of "object" which makes it great for getting and setting
21:58:36 <chrisdotcode_> I understand lens, fundamentally
21:58:41 <chrisdotcode_> the getter/setter part
21:58:46 <chrisdotcode_> but I haven't really ventured any further
22:00:06 <levi> Well, no time like the present.
22:01:17 <willqw> can i ask a newbie question on Reader monad?
22:01:46 <willqw> in this definition: instance Monad (Reader r) where
22:01:46 * hackagebot arbtt 0.8.1 - Automatic Rule-Based Time Tracker  http://hackage.haskell.org/package/arbtt-0.8.1 (JoachimBreitner)
22:02:00 <willqw> m >>= k = Reader $ \r -> runReader (k (runReader m r)) r
22:02:14 <willqw> i have a hard time understanding the definition of m >= k
22:02:22 <rrradical> heatsink: okay, I think I'm a bit confused, but here's what I have now: http://lpaste.net/106262 I'm trying to make a pure function that returns a new identity matrix. There's an FFI function that takes an array of floats (representing a matrix) and sets it to the identity matrix.
22:02:54 <willqw> the runReader accepts a Reader and environment, it returns a result, but what actually does "runReader (k runReader m r) r" do?
22:03:32 <willqw> what does the (k (runReader m r)) does yield?
22:03:36 <MP2E> runReader m r is evaluated first, the output is the second argument to the outside runReader
22:04:07 <willqw> ok suppose the output is "a", this becomes "runReader (k a) r
22:04:17 <willqw> MP2E what does (k a) yield?
22:04:40 <willqw> k is supposed to be a Reader
22:04:43 <MP2E> willqw: k a will take a pure value and return another Reader monad, let's call this "Reader b"
22:04:49 <heatsink> rrradical: You're trying to allocate an array of sixteen Mat44Structs.  But Mat44Struct is not a storable type.  There's no information about how many bytes of memory it takes.
22:05:07 <heatsink> rrradical: How is mat4x4_identity declared in C?
22:05:18 <willqw> ok so "k a" produces another Reader.
22:05:27 <MP2E> then you have your first argument to runReader, so whoops I suppose r is the second argument of the outside runReader :P
22:05:45 <rrradical> heatsink: basically void mat4x4_identity(float[4] m)
22:05:49 <MP2E> but yeah then you have 'runReader b r'
22:05:59 <rrradical> heatsink: sorry, float[16] I mean
22:06:41 <willqw> MP2E: this makes sense now. I didn't know "k a" yields another Reader, because Reader is a newtype
22:06:55 <heatsink> In Haskell, float is CFloat
22:06:59 <heatsink> and a pointer to a float is Ptr CFloat
22:07:14 <MP2E> Thankfully it's guaranteed that k a will return another monad because of the type signature of bind, (>>=) m a -> (a -> m b) -> m b
22:07:46 <willqw> MP2E: I see. k is a function that returns m b
22:07:54 <MP2E> exactly
22:08:03 <willqw> MP2E: this has cleared up my confusions. THanks MP2E
22:08:07 <MP2E> No problem :)
22:08:26 <heatsink> Mat44 should be Ptr CFloat
22:11:04 <rrradical> heatsink: oh okay. and then to make it it's own type I can do newtype Mat44 = Mat44 (Ptr CFloat). but then I need to unwrap it before the ffi call
22:11:21 <heatsink> yes
22:11:58 <heatsink> It is automatically unwrapped, as long as the newtype constructor is in scope
22:13:21 <rrradical> heatsink: oh great! thanks for your help
22:24:10 <zRecursive> @src fix
22:24:10 <lambdabot> fix f = let x = f x in x
22:28:00 <sinelaw> @hoogle [a] -> [[a]] -> [a]
22:28:01 <lambdabot> Data.List intercalate :: [a] -> [[a]] -> [a]
22:28:01 <lambdabot> Prelude (++) :: [a] -> [a] -> [a]
22:28:01 <lambdabot> Data.List (++) :: [a] -> [a] -> [a]
22:34:28 <MP2E> @djinn (a -> (s,(b -> c))) -> (s -> (a,b)) -> (s -> (s,c))
22:34:28 <lambdabot> f a b c =
22:34:28 <lambdabot>     case b c of
22:34:28 <lambdabot>     (d, e) -> case a d of
22:34:28 <lambdabot>               (f, g) -> (f, g e)
22:46:50 * hackagebot conduit-extra 1.1.1 - Batteries included conduit: adapters for common libraries.  http://hackage.haskell.org/package/conduit-extra-1.1.1 (MichaelSnoyman)
22:46:52 * hackagebot conduit-combinators 0.2.6 - Commonly used conduit functions, for both chunked and unchunked data  http://hackage.haskell.org/package/conduit-combinators-0.2.6 (MichaelSnoyman)
22:49:10 <jle`>  > let (x:_) !!* 0 = x; (x:xs) !!* n = x `seq` (xs !!* (n-1)); fibs = 1 : 1 : zipWith (+) fibs (tail fibs) in fibs !!* 1000000
22:49:24 <jle`> > let (x:_) !!* 0 = x; (x:xs) !!* n = x `seq` (xs !!* (n-1)); fibs = 1 : 1 : zipWith (+) fibs (tail fibs) in fibs !!* 1000000
22:49:28 <lambdabot>  mueval-core: Time limit exceeded
22:49:33 <jle`> im sorry lambdabot
22:51:47 <rudra101> Where can I find some cool things made entirely by using haskell ?
22:51:51 * hackagebot conduit-combinators 0.2.6.1 - Commonly used conduit functions, for both chunked and unchunked data  http://hackage.haskell.org/package/conduit-combinators-0.2.6.1 (MichaelSnoyman)
22:52:52 <jle`> rudra101: pandoc?
22:53:17 <jle`> xmonad
22:53:19 <rola> @about src
22:53:19 <lambdabot> Unknown command, try @list
22:53:28 <jle`> lambdabot
22:53:30 <jle`> heh
22:53:53 <jle`> FPComplete
22:54:04 <rola> darcs
22:54:06 <MP2E> xmonad was the first haskell application I looked at, it's succint and very hands on
22:54:37 <MP2E> succinct*
22:57:32 <MP2E> @src ap
22:57:32 <lambdabot> ap = liftM2 id
22:57:41 <MP2E> huh o.O
22:57:46 <MP2E> that is not what I expected.
22:58:07 <MP2E> oh wait derp of course
22:59:21 <solidus-river> how do i type cast an integer into somethign that is both Integral and Fractional
22:59:56 <solidus-river> thats a wonky constraint
23:14:59 <solidus-river> hmm, how does one get from Int -> CInt
23:16:08 <supki> :t fromIntegral :: Int -> Foreign.C.CInt
23:16:09 <lambdabot> Int -> Foreign.C.Types.CInt
23:17:22 <solidus-river> oy, i'm in integeger conversion hell i think
23:17:28 <solidus-river> i just cant find the righ tspecalu sauce mix
23:18:39 <solidus-river> http://lpaste.net/106267
23:18:44 <solidus-river> this function is absolute hell
23:20:40 <levi> What errors do you get?
23:22:49 <solidus-river> here i added some info
23:22:51 <solidus-river> http://lpaste.net/106267
23:23:03 <solidus-river> they both expect integral types so fromIntegral should work, i'm passing it Int's
23:23:18 <solidus-river> but for some reason it doesnt like floor -> toInteger then fromIntegral
23:23:58 <levi> Well, you're asking it to convert a function to an integer.
23:24:18 <solidus-river> but i thought everything was a function :)
23:24:28 <levi> Nope.
23:24:40 <levi> Things that are functions have an arrow in their type.
23:25:03 <solidus-river> hmm, but.. where am i asking it
23:25:07 <solidus-river> do i need more parenthesis then?
23:25:09 <levi> offset is a function
23:25:32 <solidus-river> but it returns an Integer
23:26:10 <solidus-river> :t offset :: Integer
23:26:11 <solidus-river> right?
23:26:11 <lambdabot>     Couldn't match expected type ‘Integer’
23:26:11 <lambdabot>                 with actual type ‘OEISSequence -> Int’
23:26:11 <lambdabot>     Probable cause: ‘offset’ is applied to too few arguments
23:26:31 <solidus-river> er
23:26:35 <solidus-river> type of offset is Integer right?
23:26:49 <levi> Well, not according to the errors.
23:27:09 <solidus-river> but that doesnt make sense?
23:27:28 <solidus-river> :t toInteger . floor .abs (fromIntegral (256 - 128) / 2)
23:27:29 <lambdabot> (RealFrac b, Fractional (a -> b)) => a -> Integer
23:27:36 <solidus-river> huh
23:27:46 <solidus-river> :t fromIntegral (256 - 128 / 2)
23:27:47 <lambdabot>     Could not deduce (Integral a0) arising from a use of ‘fromIntegral’
23:27:47 <lambdabot>     from the context (Num b)
23:27:47 <lambdabot>       bound by the inferred type of it :: Num b => b at Top level
23:27:55 <solidus-river> :t fromIntegral (256 - 128) / 2
23:27:56 <lambdabot> Fractional a => a
23:28:16 <solidus-river> :t fromIntegral ((256 - 128) / 2)
23:28:17 <lambdabot>     Could not deduce (Integral a0) arising from a use of ‘fromIntegral’
23:28:17 <lambdabot>     from the context (Num b)
23:28:17 <lambdabot>       bound by the inferred type of it :: Num b => b at Top level
23:28:22 <solidus-river> i dont get it then
23:28:29 <solidus-river> how am i supposed to work around these conversions
23:28:40 <solidus-river> this code is getting pretty ridiculous already wtih fromIntegral everywhere :\
23:29:08 <conehead> there should be parens around (toInteger . floor . abs) -- It's currently being evaluated as `toInteger . floor . (abs (fromIntegral (width - height) / 2))`
23:29:37 <brrrrian> is this function already in Prelude or Base?  \a b -> a
23:29:41 <brrrrian> what is that
23:29:46 <conehead> :t const
23:29:46 <joelteon> const id
23:29:47 <lambdabot> a -> b -> a
23:29:50 <joelteon> oh no
23:29:51 <joelteon> that's just const
23:30:06 <jle`> @src const
23:30:06 <lambdabot> const x _ = x
23:30:10 <jle`> brrrrian: hoogle might help you :)
23:30:14 <jle`> @hoogle a -> b -> a
23:30:15 <lambdabot> Prelude const :: a -> b -> a
23:30:15 <lambdabot> Data.Function const :: a -> b -> a
23:30:15 <lambdabot> Prelude seq :: a -> b -> b
23:30:37 <brrrrian> ah! I searched \a b -> a .. but i should have used the type
23:30:42 <brrrrian> thanks
23:30:44 <jle`> @where hoogle
23:30:44 <lambdabot> http://haskell.org/hoogle – See also Hayoo, which searches more packages: http://holumbus.fh-wedel.de/hayoo/hayoo.html
23:30:48 <jle`> brrrrian: yup, hoogle only takes types
23:30:49 <jle`> and names
23:30:57 * brrrrian .. doh moment
23:31:06 <jle`> ...i think it should have given you an error?
23:31:11 <levi> solidus-river: conehead's got your solution. Whenever you compose a bunch of functions that you want to apply after composed to an argument, you have to remember that application binds tighter than composition.
23:31:23 <supki> @@ @hoogle @type \a b -> a
23:31:24 <lambdabot>  Prelude const :: a -> b -> a
23:31:24 <lambdabot>  Data.Function const :: a -> b -> a
23:31:24 <lambdabot>  Prelude seq :: a -> b -> b
23:31:38 <jle`> supki: :P
23:31:54 * hackagebot yesod-form-json 0.0.1 - Extension for Yesod web framework to handle JSON requests as applicative forms  http://hackage.haskell.org/package/yesod-form-json-0.0.1 (acheshkov)
23:31:59 <solidus-river> :(
23:32:06 <solidus-river> conehead: thanks, that compiles
23:32:13 <jle`> brrrrian: as a fun activity, try to figure out how many possible functions of type (a -> b -> a) exist
23:32:13 <levi> E.g. f . g $ x or (f . g) x
23:32:15 <solidus-river> is there any way for me to cut down on fromIntegrals in here?
23:32:21 <solidus-river> http://lpaste.net/106270
23:32:33 <Lutin`> :t div
23:32:34 <lambdabot> Integral a => a -> a -> a
23:32:34 <solidus-river> or is that normal when working with different integer types
23:33:02 <cstanfill> you could make a let I guess
23:33:07 <jle`> solidus-river: you can name the fromIntegral width/heights
23:33:11 <jle`> or use view patterns
23:33:25 <jle`> viewportConfig (fromIntegral->width) (fromIntegral->height)
23:33:30 <Lutin`> > (256 - 128) `quot` 2
23:33:31 <lambdabot>  64
23:33:35 <jle`> but that only works if you only use width and height as the same thing every time
23:33:37 <jle`> ...i think
23:33:39 <Lutin`> Why not just use that
23:33:54 <jle`> oh yeah
23:33:59 <Lutin`> :t (256 - 128) `quot` 2
23:34:00 <lambdabot> Integral a => a
23:34:05 <jle`> why are you doing fractional division and then rounding it
23:34:21 <jle`> when you have integers in the first place
23:34:30 <jle`> maybe he wants to take advantage of implementation specific floating point errors?
23:34:34 <Lutin`> lol
23:35:00 <solidus-river> lol
23:35:05 <Lutin`> > toIntegral (1/0)
23:35:07 <lambdabot>  Not in scope: ‘toIntegral’
23:35:07 <lambdabot>  Perhaps you meant one of these:
23:35:07 <lambdabot>    ‘fromIntegral’ (imported from Prelude),
23:35:07 <lambdabot>    ‘toInteger’ (imported from Prelude),
23:35:07 <lambdabot>    ‘integral’ (imported from Numeric.Lens)
23:35:12 <Lutin`> > toInteger (1/0)
23:35:14 <lambdabot>  No instance for (GHC.Real.Integral a0)
23:35:14 <lambdabot>    arising from a use of ‘GHC.Real.toInteger’
23:35:14 <lambdabot>  The type variable ‘a0’ is ambiguous
23:35:14 <zRecursive> How to make 1/2+1/3 return 5/6 ?
23:35:15 <lambdabot>  Note: there are several potential instances:
23:35:17 <lambdabot>    instance GHC.Real.Integral GHC.Types.Int
23:35:19 <solidus-river> well i'm trying to center my viewport in an arbitrary window
23:35:22 <Lutin`> > toInteger (1/0) :: Int
23:35:23 <lambdabot>  Couldn't match expected type ‘GHC.Types.Int’
23:35:23 <lambdabot>              with actual type ‘GHC.Integer.Type.Integer’
23:35:27 <jle`> zRecursive: you can do Fractional
23:35:28 <Lutin`> fuck it
23:35:33 <jle`> > 1/2 + 1/3 :: Rational
23:35:34 <solidus-river> and if the width is less than the height i need to get half of the difference
23:35:35 <lambdabot>  5 % 6
23:35:35 <jle`> sorry, rational
23:35:39 <solidus-river> so the view is centered in the window
23:35:52 <Lutin`> solidus-river: Just use `div` or `quot` for integer division
23:35:59 <zRecursive> jle`: yeah, 5 % 6
23:36:01 <Lutin`> Not really sure of the differences
23:36:06 <jle`> infinite precision rational arithmetic woo hoo
23:36:14 <Lutin`> :t quot
23:36:15 <lambdabot> Integral a => a -> a -> a
23:36:24 <Lutin`> @src quot
23:36:24 <lambdabot> Source not found. This mission is too important for me to allow you to jeopardize it.
23:36:38 <jle`> Lutin`: it's a typeclass method i believe
23:36:41 <Lutin`> Oh
23:36:53 <Lutin`> They behave differently with negative numbers
23:37:13 <jle`> every Integral provides its own implemenation of quot and div
23:37:19 <Lutin`> quot is truncated towards zero, div is truncated towards negative infinity
23:37:42 <solidus-river> i still need the absolute value though
23:38:00 <Lutin`> then abs . quot
23:38:02 <jle`> absolute value works on all Num?
23:38:04 <jle`> :t abs
23:38:05 <lambdabot> Num a => a -> a
23:38:15 <solidus-river> huh
23:38:17 <jle`> and all Integral's are num
23:38:17 <zRecursive> :t (^^)
23:38:18 <lambdabot> (Integral b, Fractional a) => a -> b -> a
23:38:39 <jle`> and Ord, and Real, and Enum
23:38:52 <Lutin`> I think Prelude need an irrational
23:39:15 <Lutin`> So that I can precisely define Phi
23:39:36 <jle`> yeah, Rational to Real is too big of a jump
23:39:49 <jle`> we need Algebraic in there
23:40:06 <jle`> oh you mean an Irrational data type
23:40:09 <jle`> yeah
23:40:43 <jle`> actually i'm pretty sure it wouldn't be hard to make your own
23:40:44 <zRecursive> Do we really need Complex ?
23:40:47 <jle`> i wonder why people haven't done it yet
23:40:50 <jle`> zRecursive: need?
23:40:56 <solidus-river> interesting, its cool that quot is a funciton
23:40:57 <jle`> it's not even in Prelude
23:41:31 <zRecursive> jle`: Complex is not very useful ?
23:42:00 <levi> Of course Complex is useful.
23:42:09 <levi> Even C has complex numbers.
23:42:09 <jle`> Complex is useful if you're doing complex arithmetic?
23:42:18 <zRecursive> > 2 ^ i
23:42:22 <lambdabot>  mueval-core: Time limit exceeded
23:42:27 <Lutin`> lol
23:42:31 <Lutin`> > i
23:42:32 <lambdabot>  i
23:42:43 <Lutin`> oic
23:42:48 <jle`> Complex makes complex arithmetic much easier
23:42:53 <jle`> abstracting over complex numbers as numbers
23:43:28 <jle`> and for people that do complex arithmetic every day
23:43:33 <jle`> it's probably pretty useful to them
23:44:06 <zRecursive> > 2 ^ (3+2i)
23:44:07 <lambdabot>  Could not deduce (GHC.Real.Integral b0)
23:44:07 <lambdabot>    arising from a use of ‘GHC.Real.^’
23:44:07 <lambdabot>  from the context (GHC.Num.Num a)
23:44:07 <lambdabot>    bound by the inferred type of it :: GHC.Num.Num a => a at Top level
23:44:07 <lambdabot>  The type variable ‘b0’ is ambiguous
23:44:29 <jle`> :t (^)
23:44:30 <lambdabot> (Num a, Integral b) => a -> b -> a
23:44:54 <zRecursive> :t (**)
23:44:55 <lambdabot> Floating a => a -> a -> a
23:45:03 <jle`> Complex a is not Integral
23:45:25 <jle`> but RealFloat a => Floating (Complex a) should work for you
23:45:37 <Lutin`> ugh
23:46:05 <jle`> > exp 1 ** (0 :+ pi)
23:46:06 <lambdabot>  (-1.0) :+ 1.2246467991473532e-16
23:46:08 <Lutin`> Anyways bed time for me
23:46:15 <Lutin`> lol
23:46:22 <Lutin`> euler is rolling in his grave
23:47:09 <jle`> > exp 1 ** (0 :+ pi / 2)
23:47:10 <lambdabot>  6.123233995736766e-17 :+ 1.0
23:47:17 <alpy> I need help. The hackage site tells me that UTCTime is an instance of Show
23:47:25 <jle`> > abs $ exp 1 ** (0 :+ pi / 2)
23:47:26 <lambdabot>  1.0 :+ 0.0
23:47:38 <zRecursive> :t exp 1 ** (0 :+ pi / 2)
23:47:39 <lambdabot> RealFloat a => Complex a
23:48:07 <Lutin`> alpy: You need to import all of Time
23:48:17 <Lutin`> The show instance is in another module
23:48:42 <jle`> @check \i -> abs (exp 1 ** (r :+ i)) == 1
23:48:43 <lambdabot>  No instance for (Test.QuickCheck.Arbitrary.Arbitrary
23:48:43 <lambdabot>  Debug.SimpleReflect.Expr.Expr) arising from a use of ‘Lambdabot.Plugin.Haske...
23:48:58 <joelteon> :t r
23:48:58 <lambdabot> Expr
23:48:59 <jle`> @check \i -> abs (exp 1 ** (0 :+ (i :: Double))) == 1
23:49:01 <lambdabot>  *** Failed! Falsifiable (after 2 tests and 81 shrinks):
23:49:01 <lambdabot>  1.3938781536512043e-7
23:49:04 <jle`> boo
23:49:07 <alpy> Lutin`: thanks a lot
23:49:28 <Lutin`> np, you're not the first one with that issue
23:49:54 <jle`> @check \i -> abs (abs (exp 1 ** (0 :+ (i :: Double))) - 1) < 1e-5
23:49:55 <lambdabot>  No instance for (GHC.Classes.Ord
23:49:55 <lambdabot>  (Data.Complex.Complex GHC.Types.Double)) arising from a use of ‘GHC.Classes.<’
23:50:12 * jle` sneaks off
23:50:28 <Lutin`> alpy: It's in Data.Time.LocalTime.LocalTime
23:51:26 <Lutin`> night all
23:51:50 <jle`> night Lutin`
23:53:48 <solidus-river> does Graphics.Rendering.OpenGL have a state setter to disable BackfaceCulling, i'm poking around on hackage nad coming up empty
