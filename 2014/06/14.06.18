00:00:09 <l0cust> Zekka: the monad is the jail cell
00:00:14 <Zekka> http://chrisdone.com/posts/monads-are-burritos
00:00:14 <l0cust> or really, the act of containment
00:00:20 <xxen> Maybe they are supposed to be the cell
00:00:37 <l0cust> okay
00:00:47 <l0cust> you have a prisoner, and you don't want him escaping
00:00:54 <l0cust> but you need to transport him to another prison
00:01:03 <chrisdone> zekka =p
00:01:23 <arileo> Zekka: Not so sure about functors
00:01:29 <orzo> In the example at http://www.haskellforall.com/2012/07/purify-code-using-free-monads.html he uses a function liftF but the compiler complains for me and I cannot find it in Control.Monad.Free.  Where is it? Did i import the wrong package?
00:01:29 <phaskell> No symbol 'it' found anywhere.
00:01:35 <Welkin> chrisdone, I thought you were joking about the burritos
00:01:36 <l0cust> so, you keep him in his cell
00:01:36 <Zekka> Personally I think it's most useful to think of monads as a kind of functor
00:01:43 <Zekka> but I guess you can start with "monads are a kind of jail cell"
00:01:47 <Zekka> or "monads are a kind of burrito"
00:02:06 <l0cust> arileo: do you understand the issue at hand
00:02:17 <l0cust> so we bring an armoured car into the prison
00:02:35 <l0cust> secure the prison walls
00:02:43 <l0cust> move the prisoner into the armoured car
00:02:55 <l0cust> close the armoured car, before opening up the gate
00:03:02 <l0cust> that way there's no chance of him escaping
00:03:06 <l0cust> do you sort of get the idea?
00:03:18 <xxen> how does he get into the closed car?
00:03:23 <arileo> I suppose yes
00:03:32 <l0cust> You close the larger prison
00:03:37 <l0cust> transport him from his cell to the car
00:03:43 <l0cust> open the door, blah blah
00:03:46 <l0cust> okay
00:03:56 <l0cust> in this analogy, the prisoner is data from a file
00:03:59 <Welkin> I think type signatures make it easier to understand than any analogy...
00:04:05 <l0cust> Welkin: agreed
00:04:11 <l0cust> :t (>>=)
00:04:16 <lambdabot> Monad m => m a -> (a -> m b) -> m b
00:04:26 <orzo> :6 liftF
00:04:29 <orzo> :t liftF
00:04:30 <Zekka> I really think you need to "get" functors before you get monads
00:04:32 <lambdabot>     Not in scope: ‘liftF’
00:04:32 <lambdabot>     Perhaps you meant one of these:
00:04:32 <lambdabot>       ‘liftM’ (imported from Control.Monad.Writer),
00:04:45 <l0cust> Zekka: agreed
00:04:51 <Welkin> if you have read LYAH you should have a basic understanding of functors and monads
00:05:00 <Zekka> So let's start with a functors
00:05:03 <l0cust> what are the functor operator
00:05:04 <Zekka> arileo: You know aboout map, right?
00:05:09 <l0cust> *functor operators
00:05:09 <arileo> Yes, definitely
00:05:12 <l0cust> :t fmap
00:05:14 <lambdabot> Functor f => (a -> b) -> f a -> f b
00:05:18 <Zekka> l0cust: Don't rush him!
00:05:21 <Zekka> :t map
00:05:23 <lambdabot> (a -> b) -> [a] -> [b]
00:05:27 <Zekka> So that's the type of map, right?
00:05:38 <l0cust> Zekka: fmap is more like (.)
00:05:39 <kasnjtzschta> that's the distributive axiom in logic
00:05:53 <Zekka> l0cust: It's like map and like (.), it's e same operation
00:06:01 <l0cust> :t (.)
00:06:03 <lambdabot> (b -> c) -> (a -> b) -> a -> c
00:06:30 <l0cust> arileo: I'm sure you're terrified
00:06:35 <Zekka> I really think it's not a good idea to rush him too much, he said he barely understood functors
00:06:38 <arileo> Ah, somewhat
00:07:08 <arileo> I think the thing is, I'm actually having trouble understanding the notation for map, ( a -> b) -> [a] -> [b] -- not quite sure what I am reading there!
00:07:11 <Zekka> Well, there's a whole typeclass of things -- you know typeclasses, right -- that support an operation that's kind of like map
00:07:12 <l0cust> oh
00:07:13 <l0cust> okay
00:07:14 <Zekka> Oh
00:07:23 <Zekka> It takes a function from a to b, then a list of a, and gives you a list of b
00:07:30 <l0cust> arileo: so, say you want to uppercase a string
00:07:33 <l0cust> so you run
00:07:38 <l0cust> > map toUpper "hello"
00:07:43 <lambdabot>  mueval-core: Time limit exceeded
00:07:48 <l0cust> uh oh
00:07:51 <Welkin> haha
00:07:53 <l0cust> what did i do
00:07:56 <l0cust> anyway
00:08:03 <arileo> locust: that makes sense
00:08:03 <l0cust> that should have outputted "HELLO"
00:08:10 <l0cust> :t toUpper
00:08:13 <lambdabot> Char -> Char
00:08:24 <l0cust> and String is the same thing as [Char]
00:08:29 <Welkin> > toUpper "h"
00:08:31 <lambdabot>  Couldn't match expected type ‘GHC.Types.Char’
00:08:31 <lambdabot>              with actual type ‘[GHC.Types.Char]’
00:08:36 <Welkin> > toUpper 'h'
00:08:39 <lambdabot>  'H'
00:08:55 <Welkin> lambdabot is slow
00:08:58 <arileo> Yea, definitely, that makes sense so far
00:09:03 <l0cust> okay
00:09:09 <Welkin> > map toUpper "hallo thar"
00:09:13 <lambdabot>  "
00:09:16 <l0cust> wtf
00:09:23 <arileo> lol : p
00:09:24 <Welkin> > map toUpper "hallo"
00:09:27 <lambdabot>  "HALLO"
00:09:30 <MP2E> huh
00:09:30 <kasnjtzschta> It's amazingly similar to first order logic, or I am wrong?
00:09:41 <Zekka> arileo: Just so you know, this stuff is super obvious to people who know Haskell so a lot of people will try to breeze through it really fast
00:09:46 <l0cust> kasnjtzschta: this is programming, screw logic
00:09:49 <Zekka> If it's not obvious to you you should speak up
00:10:52 <kasnjtzschta> l0cust: say that to alonzo church
00:11:18 <kasnjtzschta> or Gregory Chaitin
00:11:19 <arileo> Yea, thanks... So, I understand the type notation for toUpper, but I'm still a little confused about the type notation for map,  ( a -> b) -> [a] -> [b]. Like, for toUpper Char -> Char I can read as "a character becomes a character"... But I'm a little confused as to how to read the map notation
00:11:25 <l0cust> okay
00:11:32 <l0cust> so in our example
00:11:47 <l0cust> we gave it map a function (toUpper) that takes a char, and gives you a char
00:11:52 <l0cust> that's the (a -> b) part
00:11:59 <l0cust> in this instance, a and b happen to be the same thing
00:12:07 <Welkin> arileo, do you know about currying and partial application?
00:12:15 <l0cust> we also gave it a list of chars. "hello"
00:12:26 <l0cust> we got back a list of chars "HELLO"
00:12:28 <arileo> Welkin: I know about partials, but not sure about the distinction between a partial and currying
00:12:30 * hackagebot haddock-library 1.0.0 - Library exposing some functionality of Haddock.  http://hackage.haskell.org/package/haddock-library-1.0.0 (MateuszKowalczyk)
00:12:43 <l0cust> or we were fupposed to
00:12:45 <l0cust> *supposed
00:12:48 <l0cust> thanks lambdabot
00:13:23 <Welkin> > putStr "hallo"
00:13:25 <lambdabot>  <IO ()>
00:13:58 <Welkin> arileo, you can think of the type signatures in this way: the last part is the thing that gets returned
00:14:32 <orzo> AfC: The article you linked me to about free monads seems to be out of date.  I cannot compile the code. 'liftF' is not in scope and there is no data constructor `Free'.  I don't see those things in older versions of Control.Monad.Free either, so i'm not sure what happened.  Can you help me update his example?
00:14:33 <Welkin> and if you see anything in parentheses, it is probably a function
00:15:16 <arileo> Hmm.. k
00:15:47 <Welkin> have you read Learn You a Haskell?
00:15:47 <arileo> In general, can I read type signatures as "this function takes a and b and c and d and returns e" ?
00:15:51 <arileo> Too simplistic?
00:15:57 <arileo> Welkin: A little, hoping to get started
00:16:04 <Welkin> it is really good and fun to read
00:16:10 <Welkin> I enjoyed the humor
00:16:28 <Welkin> :t map
00:16:29 <lambdabot> (a -> b) -> [a] -> [b]
00:16:48 <Welkin> arg1 -> arg2 -> result
00:16:53 <Welkin> in that case
00:16:57 <notdan> Hm, why do I have a /Library/Frameworks/GHC.framework/ directory with stuff for ghc7.6
00:17:01 <notdan> how can I get rid of it?
00:17:02 <arileo> Okay guys.... I've really got to get some rest. Thank you so much, especially l0cust, welkin, zekka, chrisdone.
00:17:21 <arileo> Take care all, you guys are great! : )
00:17:30 <Welkin> good luck
00:18:10 <Zekka> See you
00:18:29 <arileo> Thank you!
00:20:03 <orzo> Zekka: do you know where the author is getting the symbol ListF and data constructor Free from at http://www.haskellforall.com/2012/07/purify-code-using-free-monads.html ?
00:20:11 <orzo> sorry, liftF
00:20:25 <Zekka> :t liftF
00:20:26 <lambdabot>     Not in scope: ‘liftF’
00:20:27 <lambdabot>     Perhaps you meant one of these:
00:20:27 <lambdabot>       ‘liftM’ (imported from Control.Monad.Writer),
00:20:28 <Welkin> @liftF
00:20:28 <lambdabot> What module?  Try @listmodules for some ideas.
00:20:31 <Welkin> @src liftF
00:20:31 <lambdabot> Source not found. My mind is going. I can feel it.
00:20:41 <Zekka> http://hackage.haskell.org/package/free-2.1.1.1/docs/Control-Monad-Free.html
00:20:50 <Zekka> Seems to be from here
00:21:09 <orzo> oh i seem to have intalled the wrong package (package control-monad-free)
00:21:17 <dksmith> I tried to different googlings but I admit defeat and ask your help. Years ago I saw a proposal of a Haskell extension that would allow "someFunc (f1 arg1) (f2 arg2)" to be written as "someFunc\n\t<insert new operator here> f1 arg1\n\t<insert new operator here> f2 arg2" so you can have a nicer tree-like nested code structure and wouldn't have to parenthesize
00:21:17 <dksmith> each line of arguments
00:21:41 <orzo> Zekka: thanks
00:21:50 <dksmith> If I remember correctly, it was a page on the Haskell Prime wiki
00:24:29 <dottedmag> Has Haskell Prime died, by the way?
00:27:14 <path[l]> Hi, I need some help with monads and do notation. I have this generator defined here called genGlobPatternChar. It converts Literal chars into either “c” or “\\c”. However, when I do the same with the inner “set” type. I want to be able to arbitrarily print either the character … or an escaped version of the character. How would I do that?
00:30:24 <MP2E> path[l] : sounds like a job for a comonad
00:30:37 <MP2E> if you aren't familiar, a great readup can be found here http://www.haskellforall.com/2013/02/you-could-have-invented-comonads.html
00:30:39 <path[l]> is that like mixing two monads?
00:30:43 <path[l]> thanks
00:31:07 <MP2E> nah, a comonad is the categorical opposite of a monad. So instead of having bind and return as the things that define it, it instead has extend and extract
00:31:53 <path[l]> ok, let me read that :)
00:46:34 * dottedmag wonders whether the syntactic sugar for comonads should use keyword donotdo
00:49:13 <orzo> Is there any reason why i'd ever want to use Control.Monad.Free over Control.Monad.Free.Church ?
00:51:21 <orzo> hmm, actually, it seems like the church version would prevent me from inspecting the branches
01:10:14 <jle`> dottedmag: maybe codo
01:10:16 <jle`> ?
01:10:55 <jle`> there's already "don't blocks" :)
01:12:14 <dottedmag> jle`: I was just kidding -- if comonads are the opposite for monads, then dontdo is opposite for do.
01:12:39 <dottedmag> jle`: don't blocks are comments, right?
01:12:50 <jle`> no, it's from acme-don't
01:12:56 <jle`> er, acme-dont
01:13:04 <jle`> don't $ do { ... }
01:13:41 <Zekka> jle`: And I kind of feel like that would be useful if you're parameterizing a functiond over things like when and forever
01:13:51 <dottedmag> Heh.
01:14:05 <jle`> http://hackage.haskell.org/package/acme-dont
01:20:32 <path[l]> MP2E: I read that, but I couldnt follow it. I think I’m still lacking too much information.
01:21:15 <jle`> path[l]: can you clarify your question?
01:21:18 <jle`> what generator do you mean?
01:21:28 <path[l]> sure thing. let me paste some code
01:23:34 <path[l]> http://lpaste.net/105779 jle` so in this scenario, I’ve constructed a generator which gives me a globPatternChar.
01:24:33 <path[l]> jle`: it actually generates a string, but that’s because I want to say that sometimes characters can be written in a raw form, or they can be escaped with an escape character.
01:25:07 <path[l]> jle`: that is what I do for example when I type Literal x -> if x `elem` "*?[\\" then return [x] else elements [[x], ['\\', x]]
01:27:29 <jle`> so what's the problem?
01:28:18 <path[l]> jle`: I want to do the same for the characters in the Set (in the line below it), but at that point I’m inside a list … so I’m unable to figure out how to use generator syntax like “elements” inside a list
01:28:44 <path[l]> so when I see SetLiteral o, I want to be able to return [o] or [‘//‘, o] randomly
01:29:03 <jle`> path[l]: try assembling it using do notation
01:29:09 <jle`> er
01:29:11 <jle`> inside your monad
01:29:14 <jle`> instead of return
01:29:20 <path[l]> thats what I’m struggling with. Since I dont really understand do notation : x
01:29:24 <jle`> ah
01:29:33 <jle`> let me put something down
01:33:32 <jle`> let me know if the annotation works for you
01:33:48 <jle`> (<$>) is just fmap so
01:34:27 <jle`> do { fx <- f <$> a; g fx } is just a neater way to write do { x <- a; g (f x) }
01:35:20 <jle`> if you are uncomforatble with it you do xs <- mapM ...; return '[': concat xs ++ ...
01:35:26 <hunt> how do i take a bunch of maybe values and do nothing if any of them are nothing, and operate on them if theyre all something
01:35:31 <path[l]> still reading :)
01:35:35 <hunt> i know theres a maybe monad but i dont know how to use it
01:35:41 <hunt> or if ti would solve this
01:35:44 <hunt> which i mostly doubt
01:36:00 <path[l]> so <- f <$> a, gives me f(x)
01:36:03 <path[l]> cool I get it
01:36:27 <jle`> path[l]: think of it as applying f "before" x is bound
01:36:32 <jle`> yeah
01:36:37 <jle`> hunt: can you give a concrete example?
01:36:41 <path[l]> jle`: oh I just noticed that you had edited it
01:37:05 <jle`> hunt: you can do [Maybe a] -> Maybe [a], if that's what you mean
01:37:25 <jle`> where if all of the Maybe a's are Just, it gives you Just [x] with all of the Just values
01:37:28 <hunt> jle`: im inside this other monad, and i want to get some values which are maybes. i do something like a<- val; a is now a maybe. i repeat that for b,c; i want to compose a b c into some operation assuming theyre all there
01:37:29 <jle`> er, Just xs
01:37:45 <hunt> jle`: their types may vary
01:37:48 <jle`> and if any of them are Nothing, it returns Nothing
01:37:52 <jle`> jm
01:37:54 <jle`> hm
01:38:11 <jle`> this is probably a job for MaybeT
01:38:39 <Total_1mmersion> hunt, Maybe is a Monoid, so using msum on Maybe has type [Maybe a] -> Maybe a
01:38:40 <jle`> which might be overkill unless you have a lot of values to all depend on
01:39:23 <Zekka> Total_1mmersion: Maybe is a monoid iff its param is a monoid
01:39:24 <path[l]> jle`: what does mapM do there? I havent followed the exact sequence of operations that is occuring.
01:39:32 <jle`> :t mapM
01:39:34 <lambdabot> Monad m => (a -> m b) -> [a] -> m [b]
01:39:43 <Total_1mmersion> > msum [Nothing, Just 3, Just 4]
01:39:45 <lambdabot>  Just 3
01:39:56 <Zekka> Really?
01:40:07 <jle`> path[l]: so basically you have a bunch of functions (SetType -> Gen String)
01:40:08 <Zekka> I could have sworn I'd run into the problem I'm describing earlier
01:40:36 <jle`> and you have a [SetType]
01:40:44 <path[l]> ooh so its (mapM convert s)
01:40:51 <jle`> if you simply map it on, you get [Gen String]
01:40:53 <path[l]> does <$> have the lowest precedence?
01:40:57 <jle`> but you want Gen [String]
01:41:01 <jle`> oh yes, <$> is low precedence
01:41:12 <jle`> but that doesn't really matter becuase function appllication is highest precedence
01:41:17 <path[l]> ah
01:42:18 <jle`> so mapM lets you take an (a -> Gen b) and a [a], and "executes" your function on all of the results and collects them into a Gen [b]
01:42:31 <Total_1mmersion> hunt, try do { a' <- a; b' <- b; c' <- c; return (a', b', c') }
01:42:42 <path[l]> aha
01:42:44 <path[l]> cool
01:42:55 <jle`> Total_1mmersion: he is in another Monad, a is not Maybe a, it's m (Maybe a)
01:43:31 <jle`> > mapM (\x -> Just x) [1,2,4]
01:43:33 <lambdabot>  Just [1,2,4]
01:43:41 <path[l]> I see now
01:43:45 <path[l]> ok this makes sense
01:43:52 <jle`> you might have used it before for putStrLn
01:44:01 <jle`> mapM_ putStrLn ["hello", "world"]
01:44:12 <jle`> er, mapM
01:44:15 <jle`> gives you IO [String]
01:44:18 <jle`> er
01:44:20 <jle`> IO [()]
01:44:45 <Total_1mmersion> jle', I thought he said his a has type Maybe _?
01:44:47 <jle`> it executes putStrLn on all of the items on the list and re-collects it all together
01:45:02 <jle`> Total_1mmersion: the monad 'contains' a type Maybe a, i think
01:45:18 <jle`> so in { x <- f }; x is a Maybe a
01:45:51 <jle`> right hunt ?
01:46:00 <Total_1mmersion> jle', he said "a is now a maybe", which makes me think he could embed a Maybe do block to extract the values like he wants to.
01:46:37 <jle`> that's not quite how it works, i think
01:47:08 <jle`> hm
01:47:16 <jle`> a cheap way would be
01:47:48 <jle`> let x = sequence [a,b,c]
01:47:51 <Total_1mmersion> jle`, main = do { print $ do { a <- Just 3; b <- Just 4; return (a + b) } }
01:47:55 <jle`> but that doesn't work if the values are of different types
01:48:00 <Total_1mmersion> jle`, his a b and c have different types
01:48:01 <hunt> yea it doesnt
01:48:15 <jle`> Total_1mmersion: i think it would be more like if Just 3 and Just 4 were IO actions
01:48:23 <jle`> right?
01:48:29 <Total_1mmersion> jle`, I just ran it through ghci and it worked
01:49:02 <jle`> print $ do { a <- return (Just 3) :: IO (Maybe Int); b <- return (Just 4); return (a + b) }
01:49:28 <jle`> if your things that you are binding are IO (Maybe a), then you can't do that
01:49:51 <Total_1mmersion> Yes, but what I did was embed a do block in another do block
01:50:11 <jle`> you can do that, but that won't short circuit your computation
01:50:16 <Total_1mmersion> The outer do block is the IO monad, the inner is the Maybe monad.
01:50:22 <Total_1mmersion> Yes it will
01:50:22 <jle`> the inner do block isn't the Maybe monad
01:50:24 <jle`> it's the IO monad
01:50:29 <jle`> if your values are IO (Maybe a)
01:51:18 <jle`> print $ do { a <- return (Just 4) :: IO (Maybe Int); b <- return Nothing :: IO (Maybe Int); return (a + b) }
01:51:20 <jle`> won't work
01:51:36 <Total_1mmersion> Oh, of course
01:51:43 <jle`> (unless you have a num instance for Maybe Int, but that'll probably not do what he's thinking of)
01:52:08 <jle`> you need MaybeT
01:52:10 <hunt>  why is this so hard
01:52:13 <hunt> yikes
01:52:16 <Total_1mmersion> That's not what I'm suggesting though.
01:52:23 <jle`> that's his problem, isn't it?
01:52:24 <hunt> how do i throw a maybeT inside my other monad
01:52:26 <Total_1mmersion> You don't need MaybeT in this case
01:52:43 <hunt> Total_1mmersion: can you give an example of what youre suggesting?
01:52:43 <jle`> you don't need it in the situation you are describing, but you need it in the situation i am
01:52:56 <jle`> it depends on who is understanding hunt more correctly >_>
01:53:31 <hunt> i think i understand what Total_1mmersion is suggesting, and if i do it doesnt work, but im not sure if i do
01:53:46 <hunt> i tried something that sounds a little like what youre talking about
01:53:54 <hunt> and it didnt work
01:53:56 <jle`> do you have IO (Maybe a)'s or (Maybe a)'s ?
01:54:17 <jle`> because when you say do { x <- f }, and x is a (Maybe a)... it sounds like yuo have IO (Maybe a)'s
01:54:20 <jle`> or m (Maybe a)'s
01:54:20 <hunt> i have IO (Maybe a), IO (Maybe b), IO (Maybe c), i believe
01:54:23 <jle`> yeah
01:54:46 <jle`> so you need MaybeT to take advantage of Maybe short circuiting
01:54:52 <jle`> which fortunately isn't that complicated
01:55:03 <path[l]> jle`: what is <$> called (looks like I have to import it)
01:55:10 <jle`> path[l]: it's from Control.Applicative
01:55:19 <hunt> er wait i could do case (a,b,c) of (Just a',Just b', Just c') -> #; _ -> #;
01:55:19 <jle`> import it with ((<$>))
01:55:21 <jle`> (that gets everyone)
01:55:31 <hunt> jle`: i suppose thats not as powerful
01:55:31 <path[l]> ah
01:55:34 <Total_1mmersion> hunt, jle`, http://lpaste.net/105783
01:55:37 <jle`> hunt: yeah you can do that :) but it gets unweildy if you have a lot
01:55:46 <jle`> and also if you want to "branch" on the results of the previous one
01:56:15 <hunt> Total_1mmersion: i fail to extract values from that thing when i do it
01:56:39 <jle`> Total_1mmersion: that's not what he has
01:56:43 <jle`> i added an annotation
01:56:44 <Total_1mmersion> hunt, what do you mean you fail to extract values?
01:56:56 <jle`> i added an annotation which is more like what he has
01:57:51 <hunt> Total_1mmersion: http://lpaste.net/105785
01:58:36 <Total_1mmersion> hunt, the whole do block returns a Maybe
01:58:40 <Total_1mmersion> so you need to pattern match on it
01:58:43 <hunt> Total_1mmersion: last line is : return (p,n,e)
01:58:51 <hunt> Total_1mmersion: oh my god duh
01:58:55 <hunt> thanks Total_1mmersion a
01:58:58 <hunt> and thanks jle`
01:59:03 <Total_1mmersion> np
01:59:23 <jle`> wait, is pass :: Maybe a? >_>
01:59:34 <hunt> jle`: no its a maybe of some other type
01:59:38 <Total_1mmersion> jle`, I think hunt was a little confused about the exact types. It turns out the values were not wrapped in IO
01:59:51 <hunt> my bad, i unwrapped them before throwing them in the maybe
01:59:55 <jle`> ah
02:00:04 <jle`> well that makes sense and you can do that
02:00:09 <jle`> if none of your things do any IO
02:00:11 <orzo> how would i represent the operation f :: m a -> m a -> m (a, m a) in an ADT for a free monad for m ?
02:00:12 <jle`> that depend on previous results
02:00:21 <hunt> should've clarified, i just thought there was hot dispute about it and that i had done a find job communicating
02:00:41 <jle`> i think i did a bit of misunderstanding too; all of your values are independent
02:00:52 <jle`> so the tupling thing would work
02:00:55 <jle`> like in Total_1mmersion's case
02:01:13 <jle`> long night v.v
02:01:48 <path[l]> jle`: related question if you dont mind … why cant I do this http://lpaste.net/105786
02:02:09 <path[l]> I’m again trying to unpack the monad and stuff more things into it
02:03:24 <jle`> i guess this is a case where you'd need MaybeT http://lpaste.net/105787
02:03:43 <jle`> if you interleave IO (Maybe a) and IO a all together
02:04:05 <jle`> path[l]: what's the error?
02:04:47 <path[l]> hmm it said CheckGlobber.hs:36:3: parse error on input `return’, but it isnt doing it anymore. so I guess I screwed up the indentation : x
02:05:02 <jle`> path[l]: why don't you move the where block outside of the do block
02:05:26 <jle`> does it need to be in there?
02:05:39 <path[l]> yeah, I just rewrote it this way http://lpaste.net/105786
02:05:58 <jle`> cool
02:06:00 <jle`> all good?
02:06:04 <path[l]> yeah :)
02:06:10 <jle`> yay!
02:06:25 <path[l]> I’ve got one last step, to create a random string of this form now, but I think I understand the mechanism
02:06:38 <jle`> i'd align my ->'s for fun
02:06:59 <path[l]> hehe ok
02:07:03 <jle`> by the way, your do block
02:07:11 <jle`> x <- f; y <- g; return (x, y)
02:07:15 <jle`> might be more cleanly written as
02:07:25 <jle`> (,) <$> arbitrary <*> convertToString glob
02:07:31 <jle`> using applicative style
02:07:46 <jle`> > (,) 4 "hello"
02:07:48 <lambdabot>  (4,"hello")
02:08:00 <jle`> > (,) <$> Just 4 <*> Just "hello"
02:08:02 <lambdabot>  Just (4,"hello")
02:08:30 <jle`> you are sort of supposed to read it as normal applications...the <$> and <*> "disappear" and you don't notice them
02:08:37 <jle`> but it's basically function application "inside your monad"
02:09:03 <path[l]> hmm
02:09:49 <jle`> you can also do Set s -> (\xs -> '[': xs ++ "]") . concat <$> mapM convertSetItem s
02:10:08 <jle`> but that is on the border
02:10:22 <jle`> of readability
02:10:24 <jle`> heh
02:10:40 <path[l]> too many moving parts :), I want to get this working first. almost there!
02:10:43 <jle`> extra returns are just so ugly :'(
02:12:06 <Walther> gah, i should learn how to use monads. I've already read quite a bit on "what is a monad" and "why are they so important" etc, but haven't actually managed to use IO Monads or State or whatever :P
02:12:51 <Saizan> Walther: do it! ask if you get into type errors
02:14:17 <Walther> "if" :D
02:15:42 <path[l]> jle`: so to follow up. if I have [gen[a]] and I want to convert it into gen[a] (where [a] in the output is concat [[a]], do I go — concat <$> stuff ?
02:16:06 <simon> Walther, "case x of Nothing -> Nothing; Just x' -> f x" becomes "x >>= f" :)
02:16:18 <simon> oops, f x'
02:17:00 <Walther> simon: ...mmhm, mmhm, i know some of those words
02:17:35 <jle`> path[l]: er
02:17:40 <jle`> can you state that in types
02:17:53 <jle`> Walther: you just spot them here and there and throw them in
02:18:06 <jle`> avoid thinking of Monads as some monolithic unified "thing"
02:18:13 <jle`> Maybe has a set of very convenient utility functions
02:18:21 <jle`> so does IO
02:18:24 <jle`> so does State
02:18:32 <Walther> jle`: Aware, monads aren't a monolithic mystical thing that you get enlightened about
02:18:43 <jle`> the fact that they align with Monad shouldn't concern you
02:18:55 <jle`> when you say 'i haven't used Monads like Maybe'
02:18:56 <path[l]> ok. So I have [Gen[Char]] and I want to convert this to Gen[Char]. and the way I want to do the conversion is to use a function from [[Char]] -> [Char] (specifically, I want to use concat).
02:19:03 <Walther> my point was mainly "yeah, lurked the previous discussion, and should probably take some actions and do stuff in addition to just reading on stuff"
02:19:06 <jle`> you really are saying 'i haven't used these certain Maybe-specific utility functions"
02:19:21 <tdammers> Walther: the enlightenment is very much a zen thing, where you realize, most of all, what monads are *not*
02:19:31 <Walther> tdammers: tee hee hee :P
02:19:34 <jle`> "i have also not used these certain, extremely distinct-from-Maybe utility functions for State, and IO"
02:19:47 <benj_> the zen of realising that there is no zen of monads :P
02:19:53 <tdammers> benj_: meta-zen
02:19:55 <tdammers> at least
02:20:04 <ion> men
02:20:14 <tdammers> "the zen of realising how the zen of zen of zen is nothing more than the zen of zen"
02:20:39 <jle`> path[l]: if you want, you can take it in slow motion
02:20:43 <jle`> by using map and sequence
02:20:44 <Walther> and then to have an exit condition, let zen zen = just zen
02:21:05 <jle`> sequence :: Monad m => [m a] -> m [a]
02:21:10 <vanila> or just zen :: Zen and leave it undefined
02:21:18 <jle`> so sequence :: [Gen [Char]] -> Gen [[Char]]
02:21:22 <path[l]> oh
02:21:25 <path[l]> hmm
02:21:26 <jle`> then you can use map :: [[Char]] -> [Char]
02:21:29 <jle`> er
02:21:32 <jle`> map concat
02:21:37 <jle`> um
02:21:42 <jle`> concat :: [[Char]] -> [Char]
02:21:51 <jle`> map concat :: Gen [[Char]] -> Gen [Char]
02:22:12 <jle`> er sorry, fmap
02:22:23 <jle`> fmap concat :: Gen [[Char]] -> Gen [Char]
02:22:33 <jle`> fun exercise!  implement mapM in terms of fmap and sequence
02:22:43 <jle`> map and sequence
02:22:49 <path[l]> I was going to say that I dont think I followed the difference between fmap and mapM
02:22:53 <path[l]> :t fmap
02:22:55 <lambdabot> Functor f => (a -> b) -> f a -> f b
02:22:56 <path[l]> :t mapM
02:22:58 <lambdabot> Monad m => (a -> m b) -> [a] -> m [b]
02:23:04 <BoR0> :t sequence
02:23:06 <lambdabot> Monad m => [m a] -> m [a]
02:23:20 <jle`> fmap just applies the value "inside"
02:23:21 <Enigmagic> :f traverse
02:23:24 <path[l]> ok fmap seems to be the regular map I see.
02:23:24 <Enigmagic> :t traverse
02:23:26 <lambdabot> (Traversable t, Applicative f) => (a -> f b) -> t a -> f (t b)
02:23:37 <jle`> > fmap (+3) (Just 5)
02:23:39 <lambdabot>  Just 8
02:23:52 <jle`> fmap takes an (a -> b) and turns it to a (Gen a -> Gen b)
02:23:58 <jle`> so if you have a Gen [[Char]]
02:24:01 <path[l]> mapM Just [1, 2, 3]
02:24:06 <path[l]> > mapM Just [1, 2, 3]
02:24:08 <jle`> if you use fmap concat, you'll get a Gen [Char]
02:24:08 <lambdabot>  Just [1,2,3]
02:24:20 <path[l]> ah
02:24:38 <jle`> so if you have [Gen[Char]]
02:24:44 <jle`> you can use sequence to "pull the Gen out"
02:24:58 <jle`> sequence :: [Gen[Char]] -> Gen [[Char]]
02:25:07 <jle`> and then use fmap concat to "concat inside"
02:25:14 <jle`> fmap concat :: Gen [[Char]] -> Gen [Char]
02:25:19 <jle`> which gets you where you wanted, I think
02:25:26 <path[l]> yeah
02:25:45 <path[l]> I see. so let me try to understand how it relates to the previous thing
02:26:02 <jle`> if you want to connect it
02:26:10 <jle`> try implementing mapM f in terms of sequence and map
02:26:13 <jle`> :)
02:26:21 <jle`> :t mapM
02:26:22 <lambdabot> Monad m => (a -> m b) -> [a] -> m [b]
02:26:25 <jle`> :t sequence
02:26:26 <lambdabot> Monad m => [m a] -> m [a]
02:26:27 <jle`> :t map
02:26:28 <lambdabot> (a -> b) -> [a] -> [b]
02:26:32 <jle`> :t mapM undefined
02:26:33 <lambdabot> Monad m => [a] -> m [b]
02:27:23 <path[l]> ok let me try
02:27:40 <thrakcattack> i am trying to install ghc-mod-4.1.3 in a sandbox without breaking yesod
02:28:51 <thrakcattack> i successfully built it but now i can't figure out how to install the package
02:31:05 <thrakcattack> i want to install the module in my normal module path (not inside of the sandbox)
02:31:10 <thrakcattack> is this possible?
02:31:32 <Enigmagic> cabal copy?
02:31:37 <path[l]> jle`: sequence.(map f) ?
02:31:44 <jle`> path[l]: yes!
02:31:45 <Enigmagic> i just copied ghc-mod and the other bits to /usr/local/bin/
02:31:52 <jle`> @src mapM
02:31:52 <lambdabot> mapM f as = sequence (map f as)
02:32:03 <path[l]> ah neat
02:32:06 <jle`> mapM f = sequence . map f
02:32:08 <jle`> um
02:32:16 <jle`> i guess there was supposed to be some magic moment of understanding here
02:32:32 <jle`> somewhere...
02:32:39 <jle`> :t Traversable.mapM
02:32:40 <lambdabot> Not in scope: ‘Traversable.mapM’
02:32:55 <jle`> :t Data.Traversable.mapM
02:32:56 <lambdabot> (Traversable t, Monad m) => (a -> m b) -> t a -> m (t b)
02:33:04 <thrakcattack> Enigmagic: thanks, this should work
02:34:05 <Walther> :t fmap
02:34:05 <lambdabot> Functor f => (a -> b) -> f a -> f b
02:41:52 <klrr_> could someone help me spot what i do wrong calculating free variables? https://gist.github.com/klrr/4e9fadf2c431cf80296b
02:42:06 <path[l]> thanks for all the help jle`
02:42:10 <klrr_> free exp should return S.fromList ["x","y"], right?
02:42:24 <jle`> np path[l]
02:43:01 <latk> Anyone got any experience doing scientific computing in haskell ?
02:44:11 <Jei> define "scientific"
02:45:01 <simon> klrr_, no, x, y and z are all bound by a lambda abstraction and are not free.
02:45:46 <latk> Jei: Well, stuff that might otherwise be done in matlab/numpy. Basic statistical analysis, machine learning tasks, visualising/exploring potentially large data sets.
02:46:01 <latk> a reasonable amount of linear algebra
02:46:21 <klrr_> simon: oh, so the algorithm works?
02:46:55 <klrr_> but if i remove the outer lambda it still returns S.fromList []
02:47:32 <klrr_> x and y are free variables inside the inner lambda i would believe, is that not the case?
02:48:20 <simon> klrr_, yes, they are free within the inner lambda, but the case on line 5 removes them from the set of free variables of the total expression exp.
02:49:03 <klrr_> okey, still weird thought that i get S.fromList [] when i remove the outer lambda
02:50:11 <klrr_> oh wait im stupid, sorry
02:52:03 <klrr_> now it works :)
02:53:14 <simon> cool :)
02:58:03 <mossplix> why is this legal in haskell >>   data Foo = Int [String]
02:58:17 <Jei> latk: i would have defined it as something aiming to produce a published peer-reviewed article.
02:58:26 <benj_> mossplix, the Int constructor name probably shadows the type Int
02:58:37 <benj_> oh no hang on, what am I saying
02:58:42 <benj_> mossplix, it's obviously not a type, so no ambiguity
02:58:58 <zomg> same reason `type String = Int` is legal
02:59:03 <zomg> lol
02:59:47 <benj_> there's nowhere you could use that Int where it could be confused with the Int type
03:00:28 <tdammers> types and values live in completely separate namespaces
03:00:48 <mossplix> ah ok .. makes sense
03:01:04 <tdammers> the syntax rules about what is a type context and what is a value context are perfectly unambiguous, though not necessarily intuitive
03:01:36 <dottedmag> Are there syntax highlighters which distinguish them, by the way?
03:01:39 <zomg> I'm reasonably sure Int etc. are just defined as types like everything else, or at least GHC pretends that they are
03:01:48 <hpc> @src Int
03:01:48 <lambdabot> data Int = I# Int#
03:01:55 <dottedmag> haskell-mode highlights both types and value constructors with the same color.
03:02:06 <zomg> So you're just defining a new type in your own module, and there are no constraints about defining types with clashing names like that
03:02:09 <Krakarn> is there anything stupid about defining an "instance Num a => Num (a -> a)"?
03:02:11 <dottedmag> @src Int#
03:02:11 <lambdabot> Source not found.
03:02:44 <hpc> Krakarn: it makes instance resolution harder and results in some stupendously weird errors
03:02:53 <klrr_> @src I#
03:02:53 <lambdabot> Source not found. I am sorry.
03:02:56 <hpc> if you ever make a mistake
03:03:02 <Krakarn> right
03:10:28 <defanor> is there any Trifecta documentation around? in particular, i'm trying to figure out how to use feed/starve functions
03:24:40 <latk> Jei: Well yes, but those are the things necessary to produce a scientific paper, at least in my field!
03:25:37 <simon> I found a neat way to create a fixed-column table out of a longer list of items: http://jsfiddle.net/3zhbB/6/ - but it seems a little un-idiomatic. can anyone recommend a way to make this nicer?
03:26:09 <simon> I thought about replacing the whole function with _.range from underscore.js, but that's just cosmetic.
03:28:53 <tdammers> it's not cosmetic
03:29:09 <tdammers> it's the difference between reinventing the wheel and standing on the shoulders of giants
03:29:45 <tdammers> also, angular looks ugly, but that's an entirely different can of worms
03:30:00 <dsturnbull> i often find myself standing on the wheels of giants
03:30:01 <simon> tdammers, I agree. but I'm wondering if this kind of trick exists somewhere else in angular.
03:30:07 <hpc> if i am a mediocre programmer, it is because i have never encountered these so-called giants
03:30:11 <tdammers> it's not even a trick
03:30:15 <tdammers> you're just building a range
03:30:19 <tdammers> iteratively
03:30:40 <tdammers> hpc: well, the art is to tell the giants from the wannabes
03:30:52 <simon> tdammers, by trick I mean, I assume that building a fixed-column table is something that people generally do, so maybe there was an ng-repeat modifier of some kind that did this. but I'll settle with including underscore.js :)
03:31:27 <simon> tdammers, just like there's an ng-repeat-start, maybe there was one that triggered whenever some predicate was true or every nth iteration.
03:32:16 <ique> is there an easy way to inject >> between every item in a list? like a function [Action] -> Action where Action is monadic.. so [x,y,z,..] = x >> y >> z >> …
03:32:31 <quchen> sequence_
03:32:35 <ique> ahh
03:32:36 <ique> thanks!
03:32:51 <simon> tdammers, whoops. I meant to post this in #angularjs ;) I'm sorry!
03:33:12 <tdammers> simon: oh, so angular is a given. check :D
03:33:14 <k00mi> simon: I might be missing something, but why are you asking a JS question in here?
03:33:16 <k00mi> oh
03:33:18 <tdammers> and yeah, this is totally off-topic
03:33:25 <simon> k00mi, I'm just being very confused, it seems. ;)
03:34:50 <simon> (it only first occurred to me when I saw "injecting >> into a list of monadic expressions".
03:41:11 <Yuu_chan> Is there a concurrent version of sequence_?
03:41:27 <Yuu_chan> (or how to implement it easily)
03:42:09 <klrr_> :t sequence
03:42:11 <lambdabot> Monad m => [m a] -> m [a]
03:42:28 <klrr_> mapConcurrently
03:42:29 <klrr_> maybe
03:42:44 <quchen> Yuu_chan: void . mapConcurrently id?
03:42:57 <simon> where does mapConcurrently come from?
03:43:01 <quchen> async
03:44:10 <Yuu_chan> quchen: thank you!
03:45:31 <Yuu_chan> Looks exactly what I need
04:05:27 <klrr_> > foo = runIdentity . runStateT
04:05:28 <lambdabot>  <hint>:1:5: parse error on input ‘=’
04:05:32 <klrr_> > runIdentity . runStateT
04:05:34 <lambdabot>  Couldn't match type ‘s -> m (a, s)’
04:05:34 <lambdabot>                with ‘Data.Functor.Identity.Identity c’
04:05:34 <lambdabot>  Expected type: Control.Monad.Trans.State.Lazy.StateT s m a
04:05:34 <lambdabot>                 -> Data.Functor.Identity.Identity c
04:05:34 <lambdabot>    Actual type: Control.Monad.Trans.State.Lazy.StateT s m a
04:05:55 <klrr_> > \s k -> runIdentity $ runStateT s k
04:05:56 <lambdabot>  No instance for (Data.Typeable.Internal.Typeable
04:05:56 <lambdabot>                     Data.Functor.Identity.Identity)
04:05:56 <lambdabot>    arising from a use of ‘M72571754696804933748403.show_M72571754696804933748...
04:05:58 <klrr_> ups
04:31:24 <roelof> Hello, in chapter 1 of programming haskell I have to define a function which calculate a product of a array
04:32:13 <roelof> So I made this http://pastebin.com/XqXhF2Vy
04:32:22 <Cale> roelof: Probably you mean list, arrays also exist in Haskell, but they're different
04:32:32 <Cale> roelof: You want (x:xs), not [x:xs]
04:32:37 <tulcod> roelof: what's the type of [x:xs]?
04:32:57 <Qfwfq> 'cabal configure --enable-executable-profiling && cabal build -v | grep ghc' doesn't describe -prof (ghc-prof-options: -prof -auto-all), is its idempotence a known bug? /cc dcoutts
04:32:57 <Cale> [x:xs] matches a list with just one element which is itself a nonempty list with first element x and tail xs
04:33:09 <roelof> but now I see this error :http://pastebin.com/TPpiGP3Q
04:33:32 <Cale> roelof: That's because product is already defined in the Prelude
04:33:40 <roelof> [x:xs] must be a non empty array
04:34:08 <Cale> [x:xs] only matches a list with a single element (which is also a nonempty list)
04:34:33 <tdammers> :t [x]
04:34:35 <lambdabot> [Expr]
04:34:37 <tdammers> :t [x:xs]
04:34:38 <lambdabot>     Not in scope: ‘xs’
04:34:38 <lambdabot>     Perhaps you meant one of these:
04:34:38 <lambdabot>       ‘x’ (imported from Debug.SimpleReflect),
04:34:44 <tdammers> hehe
04:34:52 <zwer> :t [x:[]]
04:34:53 <lambdabot> [[Expr]]
04:35:14 <tdammers> :t (x:[]):[]
04:35:16 <lambdabot> [[Expr]]
04:35:39 <roelof> Oke, I changed the name in product2 and see this error : http://pastebin.com/ZfBYBdxs
04:35:56 <Qfwfq> I say idempotence, I mean it's a no-op.
04:36:23 <roelof> Cale : how do I make a non-empty list of any length ?
04:36:37 <jaco60> roelof, chapter 1 of Programming Haskell ask for product [2, 3, 4] so its parameter is a list (x:xs) or a empty list []
04:37:20 <tulcod> roelof: have you read anything we said?
04:37:35 <roelof> yes. but still confused
04:37:43 <tulcod> roelof: what's the type of [x:xs]?
04:38:05 <frerich> I tend to concur with roelof that the error message 'Occurs check: cannot construct the infinite type: t0 = [[t0]]' is not exactly helpful.
04:38:32 <tulcod> frerich: agreed, but an easy solution is to write type declarations of all functions you want to define
04:38:35 <tdammers> frerich: not without a bit of understanding of the type checker, no
04:38:44 <tulcod> ie. first write   product2 :: [Int] -> Int
04:38:44 <hexagoxel> the first thing you do when the type errors confuse you is to add type signatures
04:38:47 <tulcod> and then start implementing it
04:38:53 <tulcod> and it'll give you more helpful error messages
04:38:54 * hackagebot Baggins 1.0 - Tools for self-assembly  http://hackage.haskell.org/package/Baggins-1.0 (pmeunier)
04:38:56 <tdammers> it tells you that you try to construct a type that references itself in a way that cannot terminate
04:39:11 <tulcod> when in doubt, be explicit about your types
04:39:26 <tdammers> but yes, more explicit signatures
04:39:42 <roelof> oke, I reading how I can  see the type
04:39:54 <tulcod> roelof: you don't need to look it up - think about it
04:40:04 <tulcod> roelof: what's the type of the expression x:[]? it's a list, right?
04:40:08 <frerich> Right, so it could have said "No explicit type signature given, and I failed infer type automatically (an infinite type, really?)". ;-)
04:40:20 <roelof> tulcode : right
04:40:30 <tulcod> roelof: so [x:xs] is a list of lists
04:40:31 <tdammers> frerich: yeah, the wording is a bit cryptic
04:40:39 <Qfwfq> I think this is a Nix bug, actually.
04:40:52 <tulcod> roelof: surely that's not what you meant?
04:41:00 <roelof> oke, that is not what I ment. I want to have only a list
04:41:09 <tulcod> so what you want is just (x:xs)
04:41:43 <roelof> oke, I have changed that but still it fails
04:41:45 <jaco60> roelof, reread section 1.5 of your book
04:41:54 <jaco60> the solution is explained
04:42:03 <jaco60> (see the sum definition)
04:43:17 <roelof> jaco60:  that what I used for my product (sum [ ] = 0 sum (x : xs) = x + sum xs)
04:43:46 <jaco60> so ?
04:44:22 <roelof> wierd  now its working. I think the (x:xs) did the trick
04:52:41 <asfp> anyone using the chris done emacs setup?
04:53:57 <asfp> if I type 'import Control.Error' in the repl, I get 'rorrE.lortno Ctropim'?!
04:56:27 <asfp> similarly when I write 'import Control.Error' when editing a file, <enter>, Ctrl-j ESC etc. have no effect so I can't write an import statement.  That's probably structured-haskell-mode key bindings.  How does it work?
05:24:31 <klrr_> :t flip runStateT
05:24:32 <lambdabot> b -> StateT b m a -> m (a, b)
05:24:36 <klrr_> :t runIdentity
05:24:37 <lambdabot> Identity a -> a
05:24:43 <klrr_> :t runIdentity . flip runStateT
05:24:45 <lambdabot>     Couldn't match type ‘StateT a m0 a0 -> m0 (a0, a)’
05:24:45 <lambdabot>                   with ‘Identity c’
05:24:45 <lambdabot>     Expected type: a -> Identity c
05:24:46 <klrr_> wat
05:24:53 <klrr_> why wont that work?
05:25:33 <klrr_> is it that <wierdcategoryname> restriction thing, or am i just stupid?
05:25:55 <quchen> runIdentity . flip runStateT = \x -> runIdentity (flip runStateT x)
05:26:14 <quchen> And then … wait, it made sense in my head.
05:26:55 <quchen> Oh right, you're running a StateT, which gives you a function, which is not Identity.
05:27:30 <quchen> So what you want would be \stateAction initState -> runIdentity (flip runStateT initState stateAction)
05:27:48 <klrr_> why do i need to have them explicitly?
05:28:19 <quchen> You don't. I just made them explicit to show that your stateful action is missing.
05:28:22 <klrr_> :t \x y -> runIdentity $ runStateT x y
05:28:23 <lambdabot> StateT s Identity a -> s -> (a, s)
05:29:04 <klrr_> what do you mean missing, i want it to return a function taking the stateful action and the init state
05:29:09 <quchen> What you have is `\x -> runIdentity (flip runStateT x)`, and the type of the parenthesis is `StateT a m0 a0 -> m0 (a0, a)`, which you are trying to feed to `runIdentity`.
05:29:52 <klrr_> i dont get it, how does runIdentity . flip runStateT turn into some weird not returning function thing?
05:30:13 <quchen> Write it not pointfree and it'll be obvious.
05:30:34 <tdammers> quchen: "pointful"?
05:30:45 <tdammers> quchen: "pointed"? "pointy"?
05:31:09 <quchen> tdammers: Those are different things, because they lack the emphasis that doing it pointfree is the source of all evil here. :-)
05:31:18 * tdammers nods
05:31:27 <tdammers> "point-free style considered harmful"
05:31:29 <tdammers> noted.
05:31:49 <quchen> Time for our dear friend the dotdotdot operator!
05:31:51 <quchen> :t ((.)(.)(.)) runIdentity (flip runStateT)
05:31:53 <lambdabot> a -> StateT a Identity a1 -> (a1, a)
05:31:54 <klrr_> :t (+)
05:31:56 <lambdabot> Num a => a -> a -> a
05:32:10 <klrr_> but how can that work? that doesnt turn into \x -> (+) x
05:32:23 <Phillema1n> I have a function returning an infinite list of random elements (signature: "randomEls :: MonadRandom m => m [T]") and a function "takeSome :: [T] -> [T]" that takes a finite prefix of elements from the list (like takeWhile). When I run the function that basically does "takeSome =<< randomEls", I run out of memory.
05:32:35 <tdammers> quchen: is that a Total Recall reference?
05:33:04 <Phillema1n> I read somewhere that the underlying IO monad can cause trouble with infinite lists.
05:33:06 <quchen> tdammers: No, I just think dotdotdot is a useful and silly and useless operator, each in equal parts.
05:33:18 <tdammers> shame though
05:33:26 <tdammers> let recall = (.)
05:33:54 <simon> :t ((.)(.)(.))
05:33:55 <lambdabot> (b -> c) -> (a -> a1 -> b) -> a -> a1 -> c
05:35:10 <quchen> ((.)(.)(.)) f g x y = f (g x y)
05:35:30 <davd> Phillema1n: your takeSome isn't monadic but it's used as ".. =<< .." ?
05:37:46 <Phillema1n> davd: No, that was just wrongly simplified code (and a slightly simplified description). It's actually: "values <- randomEls; return $ take 10 $ takeSome values" where takeSome is a function that acts as a filter.
05:38:02 <simon> quchen, thanks :)
05:38:46 <simon> Phillema1n, sounds like there is some eager evaluation going on in takeSome?
05:39:29 <Phillema1n> The thing is, takeSome worked when I used the raw random interface with the "random" function returning a pair containing the random value and the new generator.
05:40:07 <Phillema1n> I switched to the random monad for prettier code, now it doesn't work anymore. :/
05:40:49 <Phillema1n> Of course, I'm not 100% sure that the monad causes the problems.
05:43:52 <davd> sounds like randomEls evaluates the spine of the list, for some reason
05:45:24 <Phillema1n> randomEls is just "sequence $ repeat randomEl" where randomEl is "v <- getRandomR (low,high); return v"
05:45:54 <davd> yeah, sequence is bad
05:46:04 <Phillema1n> When I replace that with "replicateM 10000 randomEl", the code "works".
05:46:43 <davd> > fmap (take 10) (sequence (return [1..]))
05:46:44 <lambdabot>  [[1],[2],[3],[4],[5],[6],[7],[8],[9],[10],[11],[12],[13],[14],[15],[16],[17]...
05:47:00 <davd> hmm
05:47:52 <Phillema1n> What's the solution to generate an infinite "laziely evaluable" list of monadic values?
05:48:03 <Phillema1n> Or isn't there one?
05:48:45 <int-e> davd: did you mean something involving  sequence (map return [1..])?
05:49:03 <identity> > :t repeat (return "foo" :: IO String)
05:49:04 <davd> yeah, nested lists..
05:49:04 <lambdabot>  <hint>:1:1: parse error on input ‘:’
05:49:37 <davd> Phillema1n: you can have a list of IO actions at least
05:50:01 <awestroke> Phillema1n: you can replace     v <- getRandomR (low,high); return v      with    getRandomR (low,high) >>= return    which is just    getRandomR (low,high)
05:50:14 <identity> > let bar = return "foo" :: IO String in repeat bar
05:50:16 <lambdabot>  [<IO [Char]>,<IO [Char]>,<IO [Char]>,<IO [Char]>,<IO [Char]>,<IO [Char]>,<IO...
05:51:36 <Phillema1n> awestroke: Yeah, I wanted to write something more complex (since the actual function contains more than one getRandomR), but I deleted that. ;)
06:00:40 <alpy_> Hello there.
06:00:56 <alpy_> I have this problem.
06:01:55 <alpy_> When i try to compile my code, i get this error: Illegal equational constraint V t ~ R2
06:02:05 <pjdelport> Phillema1n: What does your takeSome do?
06:02:18 <alpy_> do you what might have caused it, and how i might resolve it?
06:02:20 <pjdelport> alpy_: Can you paste your code to http://lpaste.net/new/haskell ?
06:05:43 * hackagebot haddock-library 1.0.0 - Library exposing some functionality of Haddock.  http://hackage.haskell.org/package/haddock-library-1.0.0 (MateuszKowalczyk)
06:05:43 * hackagebot Baggins 1.0 - Tools for self-assembly  http://hackage.haskell.org/package/Baggins-1.0 (pmeunier)
06:24:21 <remdezx> Hello! Is it possible to store functions like "id", "print" and others in a Map even some hacky way? I tried with Dynamic but it requires monomorphic types. I can make proper casts when getting and inserting values so its not a problem.
06:25:00 <octopuscabbage> what do you mean?
06:25:11 <octopuscabbage> are you trying to create a list of functions?
06:25:59 <octopuscabbage> are you trying to apply a list of functions to some arguments?
06:26:20 <remdezx> I'm creating some kind of cache. functions can be a result of computatons which I'm cacheing/
06:27:00 <pjdelport> remdezx: This sounds a bit like an http://mywiki.wooledge.org/XyProblem
06:27:35 <pjdelport> Why do you want to cache things? What behavior do you want from the cache?
06:29:02 <pjdelport> remdezx: There are probably many ways to approach this, but they all differ depending on what the underlying problem is.
06:29:39 * hackagebot haddock-library 1.0.0 - Library exposing some functionality of Haddock.  http://hackage.haskell.org/package/haddock-library-1.0.0 (MateuszKowalczyk)
06:29:39 * hackagebot Baggins 1.0 - Tools for self-assembly  http://hackage.haskell.org/package/Baggins-1.0 (pmeunier)
06:30:03 <remdezx> pjdelport: I'm creating an interpreter for my custom DSL based on Haskell  and I need to cache results of computations in something like Map.
06:30:33 <remdezx> These results unfortunately are not only simple objects, but also functions especially polimorphic
06:30:46 <octopuscabbage> are you sure you don't want some form of per function memoization? https://stackoverflow.com/questions/3208258/memoization-in-haskell
06:31:01 <pjdelport> remdezx: What does "computation" mean in this context?
06:31:09 <octopuscabbage> it seems strange to store the entire cache as one monolithic map
06:31:22 <Cale> octopuscabbage: You can use something like data-memocombinators
06:32:00 <Cale> octopuscabbage: What do you mean by 'per-function'?
06:32:10 <Cale> octopuscabbage: You absolutely can memoise a single function
06:32:27 <Cale> and in fact, I'm not sure what it means to memoise more than one function at once
06:32:42 <octopuscabbage> Cale: That's what I'm saying. I'm saying he should memoize each function individually
06:32:57 <octopuscabbage> Cale: If memoization is his intended goal
06:33:16 <octopuscabbage> Cale: Well, in this case it's probably more like caching but I consider that a form of memoization
06:33:18 <Cale> oh, I see, I missed part of the context
06:33:37 <octopuscabbage> Cale: Understandable, no hard feelings.
06:34:17 <remdezx> pjdelport: computations are some results of functions, especially partial applications and so on.
06:34:34 <pjdelport> remdezx: Isn't lazy evaluation enough?
06:34:52 <pjdelport> You may need to paste some code to make it clear what's going on.
06:35:15 <remdezx> pjdelport: Unfortunately not enough - I need to create caches and invalidate them if needed,
06:35:36 <pjdelport> remdezx: Can you paste something to help make us understand the need? :)
06:35:48 <remdezx> it's some kind reactive programming.
06:35:55 <pjdelport> This is sort of a question in a vacuum without knowing the details.
06:36:20 <remdezx> I know.
06:37:16 <remdezx> But I'm not looking for a solution of this greater problem because I have it, but rather on just cacheing polimorphic objects
06:37:47 <pjdelport> remdezx: What i'm trying to say is that it's hard to even know what caching semantics you want without knowing the greater problem.
06:37:53 <octopuscabbage> but why are your functions creating polymorphic objects? each function should have a specific return type that you can cache
06:37:56 <pjdelport> The problem doesn't make sense without knowing that.
06:39:08 <pjdelport> remdezx: The straightforward answer is probably just to depend on lazy evaluation; and if that's not enough, i can't suggest anything else without knowing why.
06:40:08 <pjdelport> It would really help to see the code you have so far, in context.
06:40:17 <octopuscabbage> How hard is it to learn F# after you know haskell?
06:41:36 <remdezx> pjdelport, octopuscabbage: You are definitely right. I will try to provide some code :)
06:42:01 <octopuscabbage> remdezx: well I have to leave for work in 10 minutes so i probably won't be able to help
06:42:07 <osfameron> octopuscabbage: they have many similarities.  F# has the
06:42:43 <osfameron> ... has different libraries (.Net) which will probably be the biggest thing in terms of learning
06:43:38 <octopuscabbage> osfameron: Yeah, I should probably dip my toes in .Net anyway, it seems a lot of things are using it currently.
06:43:56 <remdezx> octopuscabbage: okay, so maybe we'll try another time ;)
06:48:07 <_sebastian_> hi, I've a conduit pipe and would like to print the result as a json list. printing each element is easy: Data.Conduit.List.map Data.Aeson.Encode.Pretty.encodePretty. Any ideas?
06:49:14 <true_droid> hi. I'm familiar with algebraic data types which let you have a value that is ONE OF a set of predefined possibilities. Is there a way to encode the of a value that can be ONE OR MORE OF a set of predefined values?
06:49:37 <true_droid> think bitmasks in C: int x = VALUE1 | VALUE2; x&VALUE1 -> true
06:50:42 <jhance> true_droid: (Bool, Bool, Bool, Bool, Bool...)
06:50:46 <tristanStrange> hey chaps how do i get a range of numbers excluding the max number?
06:51:08 <tristanStrange> so [0,2..10]
06:51:25 <tristanStrange> without 10?
06:51:33 <tdammers> tristanStrange: just have it run up to 9?
06:51:38 <tdammers> [0..9]?
06:51:39 <frerich> [0,2..10-1] ? :-)
06:51:57 <Ankhers> Is warp still considered the fastest web server?
06:52:04 <tristanStrange> erm well I'm dealing with something more like [0,80..800]
06:52:05 <Ankhers> (In Haskell)
06:52:08 <alcabrera> tristanStrange: you can leverage the init function in that scenario
06:52:13 <frerich> tristanStrange : You can also use 'init'
06:52:17 <frerich> Goddammit I'm always too slow!
06:52:20 <popx> tristanStrange: init
06:52:21 <jhance> tristanStrange: [0,80..799]
06:52:34 <jhance> oh wait
06:52:36 <jhance> ha
06:53:06 <jhance> well if you know the gap in the range, then you can subtract the gap, slightly more efficient than the init
06:53:31 <tristanStrange> nice cheers all! I think ill use init.... something  abit dirty about subtracting 1
06:53:50 <true_droid> jhance: tuples or kind of similar but much less convenient. In the C example I can put the values in any order and quantity. With a tuple I would need to fully define it each time I want to create a value of the type
06:54:13 <jhance> tristanStrange: I don't know: I would consider duplicating the entire list to be dirty
06:54:49 <dottedmag> true_droid: [0,80..pred 800]
06:54:57 <tristanStrange> jhance: oh yes....
06:55:17 <remdezx> pjdelport: I have some problems with creating a code that will show how interpeter is working, but maybe I wll show you something like this http://lpaste.net/105796
06:55:29 <jhance> true_droid: Type with records then...
06:55:35 <remdezx> pjdelport: I'm not sure if it helps
06:56:12 <dottedmag> oops
06:56:12 <dottedmag> tristanStrange: [0,80..pred 800]
06:57:15 <Desheng> I found out last night that ghci lets you type out SDL calls one by one, it's been really useful for learning mapM and stuff
06:58:06 <Desheng> almost feels like using that turtle language wrt how sandboxy that monad acts that ghci starts you out in
07:00:05 <Desheng> I wonder if there's a way to build that into a program so that it runs as it would normally but also lets you attach a "terminal" to it that'd act like ghci does
07:00:27 <Desheng> like a client server thing with ports, for debugging purposes
07:01:11 <Desheng> like what the creators of the game jak and daxter did with their in house lisp implementation
07:01:49 <tdammers> it's probably sort of possible, but much much harder than it would be in lisp
07:02:05 <tdammers> worst case, you'll end up with something like lambdabot
07:02:59 <pjdelport> remdezx: That helps a bit to put it context, yeah. I don't think you can use Dynamic for polymorphic types like that, yeah.
07:03:51 <pjdelport> remdezx: For something like (\a b -> a * b), you'll probably have to store whatever the corresponding DSL source is, and instantiate it to non-polymorphic types as needed.
07:04:16 <remdezx> pjdelport: I can't it works only with monomorphic types. Do you know is there somethong more gerneral than Dynamic?
07:05:12 <rwbarton> keep in mind you can wrap your polymorphic type in a newtype and now it can be used with Dynamic
07:06:05 <pjdelport> remdezx: Wouldn't it make more sense to reify your DSL in a data type which you store instead of native Haskell types?
07:06:23 <remdezx> rwbarton: That's very usefull tip! thanks :)
07:06:43 <pjdelport> remdezx: In other words, not using Dynamic at all?
07:07:56 <remdezx> pjdelport: Maybe you are right, I should try to make my DSL more cache friendly.
07:08:31 <ozkar> sup
07:09:10 <pjdelport> remdezx: Well, you'll probably be able to do a lot more DSL-specific things with it in general, depending on how close or far it is from Haskell.
07:10:35 <pjdelport> remdezx: Would something like an Expr tree type work for your language?
07:10:37 <remdezx> pjdelport: If there is nothing more genreal than Typeable and Dynamic then yes, I will try to do it that way
07:10:59 <pjdelport> remdezx: Even if there is, that route will probably take more code and give you less utility.
07:11:05 * hackagebot haste-perch 0.1.0.0 - Create dynamic HTML in the browser using blaze-html-style notation with Haste  http://hackage.haskell.org/package/haste-perch-0.1.0.0 (AlbertoCorona)
07:11:09 <tristanStrange> can anyone point me at a haskell equivalent of this? http://clojure-doc.org/articles/tutorials/growing_a_dsl_with_clojure.html
07:11:28 <tristanStrange> The concepts don't really map from Clojure -> Haskell i don't think
07:12:19 <tdammers> tristanStrange: there's Write Yourself A Scheme
07:12:37 <tdammers> not exactly a DSL, but it shows you how to implement an interpreter
07:12:44 <tdammers> @where scheme
07:12:45 <lambdabot> https://en.wikibooks.org/wiki/Write_Yourself_a_Scheme_in_48_Hours
07:12:55 <remdezx> pjdelport: Hm, Expr tree wont work in that case unfortunately
07:13:20 <remdezx> pjdelport: I was also thinking about caching it not in a Map but in context of GhcMonad (I'm using ghc-api to interprete expressions) and binding values to names that wouldn't infere with anything
07:13:31 <pjdelport> remdezx: What's your DSL like?
07:13:40 <remdezx> maybe that would be an easiest option for now
07:13:53 <pjdelport> What do you need beyond something like an Expr data type?
07:14:47 <remdezx> pjdelport: oh, you meant Expr tree of my language, not haskell?
07:14:53 <pjdelport> Yes.
07:15:15 <remdezx> pjdelport: okay, now I understand
07:15:50 <remdezx> pjdelport: I'll need to think about it, maybe its another option to solve that problem
07:16:33 <pjdelport> remdezx: That way your namespace will just be "Map Name MyExpr"
07:16:51 <pjdelport> remdezx: And you can do a lot more things more conveniently with MyExpr than with Dynamic.
07:17:51 <pjdelport> You wouldn't need boilerplate like getVar and putVar, for starters.
07:19:04 <pjdelport> remdezx: An expression type will also let you do things like rewriting and manipulation easily; what advantage would using Dynamic give, over that?
07:19:38 <tristanStrange> cheers jdammer!
07:19:43 <remdezx> pjdelport: You are right, expression type will be more powerful than Dynamic
07:20:59 <remdezx> pjdelport: thank you very much for your help! :) I have multiple ways to solve this problem now :)
07:21:20 <pjdelport> remdezx: Cool. :) Let the channel know how it works out. :)
07:22:13 <pjdelport> Your Expr type probably doesn't have to be *too* detailed, if you want to leverage lower-level Haskell types as much as possible.
07:23:04 <pjdelport> Just enough to broader capture the structure of your DSL (especially where it differs from Haskell, if anywhere)
07:23:41 <remdezx> pjdelport: That's right! I will take care about that :)
07:24:52 <remdezx> pjdelport: Thanks again, for your time and advices :)
07:31:56 <Mathnerd314> so why isn't Double or Integer promotable (using DataKinds)? why are there type-level naturals but not type-level fractionals?
07:32:06 * hackagebot data-lens-light 0.1.2 - Simple lenses, minimum dependencies  http://hackage.haskell.org/package/data-lens-light-0.1.2 (RomanCheplyaka)
07:32:24 <jhance> Mathnerd314: Doubles are significantly more complicated than Integers
07:33:57 <Mathnerd314> huh? Integers are GMP data structures, while Doubles are assembly primitives. If anything Integers are significantly more complicated than Doubles.
07:34:08 <jhance> Mathnerd314: Sorry, I meant to say fractionals.
07:34:28 <jhance> Mathnerd314: And no, doubles would be significantly harder to represent in a type, in the same way you can promote naturals
07:35:45 <Mathnerd314> I'm not really seeing why
07:36:02 <jhance> Mathnerd314: Because Nats are trivial, data Nat = Z | Succ Nat
07:36:14 <ion> Nat-Z
07:37:03 <sie> Cabal doesn't have any .hs's of pkgs. Did it delete them after compiling or does it use some other format?
07:37:05 <jhance> Mathnerd314: Whereas the definition for a Double is at best like data Double = Double Bool [11-bit biased exponenet] [52 bit significand]?
07:37:12 <sie> I know that cabal get gives me the source, though.
07:37:55 <flebron> Try taking a look at the definition of Integer. It's not black magic.
07:38:10 <Mathnerd314> jhance: IIRC the actual definition for Double is data Double = Double Double#, which seems pretty simple
07:38:39 <jhance> Mathnerd314: Yes, but we are talking about data promotion... You want to use Double# in your promoted representation?
07:39:37 <Mathnerd314> yes, all I want to do is to write RGBSpace (Gamma 2.2) instead of RGBSpace (GammaOnePointTwo)
07:40:12 <flebron> Haskell doesn't have, in general, types depending on values. If you want to express that, perhaps another language would be more suitable.
07:40:31 <flebron> You can of course represent it as a rational made up of two Nats, if you so wish. I'm not sure what that buys you.
07:40:54 <jhance> Or a Bool/11-bit Nat/52-bit Nat if you actually want floating points
07:41:12 <flebron> If you aren't going to do arithmetic with such a type, and it's just for convenience, then you can shorten the name if you wish.
07:41:56 <jhance> Mathnerd314: I'm not sure how you would do any type-level arithmetic with Double though in the same way you can say that n+1 is Succ N
07:41:58 <flebron> (You may take a look at the preprocessor of .hs files, but I'm not sure that can do what you want.)
07:42:12 <rwbarton> ratio of nats wouldn't be too bad, RGBSpace (Gamma 22 10)
07:42:21 <dottedmag> Mathnerd314: Gamma2p2
07:42:34 <jhance> rwbarton: 22/10 =/= 2.2 so behavior changes
07:42:46 <jhance> rwbarton: Since 22/10 is exact and 2.2 is not
07:43:00 <rwbarton> if we are talking about doubles, then 2.2 = 22/10 by definition of 2.2
07:43:08 <jhance> rwbarton: No, its not.
07:43:20 <rwbarton> what do you think the definition of 2.2 is
07:43:24 <flebron> Depends on what you mean by 2.2
07:43:25 <jhance> rwbarton: Not if 22/10 is encoded as a fraction
07:43:37 <rwbarton> <rwbarton> if we are talking about doubles
07:43:42 <flebron> If you mean as real numbers, of course.
07:43:54 <jhance> rwbarton: But you proposed a ratio of nats, which is not a double
07:44:34 <rwbarton> but we can use it to represent those doubles which we can write as literals
07:44:41 <jhance> rwbarton: No
07:44:45 <rwbarton> um, yes
07:44:54 <rwbarton> I didn't say we could do arithmetic on them
07:44:57 <flebron> You both (I hope) know what the other means.
07:45:00 <Mathnerd314> actually, I should use a Rational instead of a Double, so rwbarton's solution works
07:45:01 <rwbarton> we can also use a string
07:45:13 <rwbarton> RGBSpace (Gamma "2.2")
07:46:06 <Mathnerd314> yeah, so I can write Gamma "2.2", Gamma 2p2, Gamma 22 10, but not Gamma 2.2...
07:46:35 <honza> how can i replace some substring with a different string in a lazy bytestring?
07:47:04 <Mathnerd314> oh, I forgot Gamma (22 % 10) (using a new rational type based on Nats)
07:47:05 <jhance> Mathnerd314: How about Gamma 0x400199999999999A
07:49:01 <zebr> hi all. does anyone know of anything i could look at that deals with Hindley-Milner type inference where recursive types are permitted? i have a feeling equirecursive types do make unification a little trickier.
07:49:08 <deweyvm> is there a nicer way to write `uniform` ? http://lpaste.net/1234738660205658112
07:50:20 <deweyvm> to avoid the repeated calls to incr
07:50:25 <dottedmag> deweyvm: Control.Monad.Random? I'm not sure though.
07:50:40 <cwraith> deweyvm: it's usually really helpful to put the "in" in the same column as the "let", just so that it's easy to find.
07:50:56 <deweyvm> oh i did not know that was allowed hehe
07:51:47 <Ankhers> Does anyone know if a Haskell connector to Aerospike?
07:51:54 <Ankhers> s/if/of
07:53:17 <deweyvm> control.monad.random looks mostly useful for adding rng to an existing monad. i dont want to be in another monad though
07:53:22 <monochrom> zebr: I think that eg "data X t = Ctor1 Int (X t)" simply means "add this axiom: Ctor1 :: Int -> X t -> X t". then no change to HIndley-Milner. this solves iso-recursive types. equi-recursive is a different story, yes.
07:53:22 <c_wraith> deweyvm: in any case, that's not a good implementation.  Each of the 3 lists you're producing will just be offset from each other.
07:53:35 <c_wraith> deweyvm: as in, they won't be independent
07:53:38 <deweyvm> oh well that is bad
07:53:59 <c_wraith> deweyvm: look at using split instead of incr
07:54:01 <dottedmag> deweyvm: look at runRand there.
07:56:28 <joshc> window 15
07:56:30 <joshc> ...
07:57:46 <deweyvm> okay now i have http://lpaste.net/7525329172755906560
07:58:27 <deweyvm> ill look into runRand, ill need a lot of rng stuff in this lib
07:59:33 <c_wraith> deweyvm: it'd be more idiomatic to use both results from split
08:00:12 <c_wraith> deweyvm: like http://lpaste.net/7525329172755906560
08:00:42 <c_wraith> deweyvm: in general, you don't want to re-use values that are RandomGens
08:01:00 <deweyvm> right
08:01:58 <deweyvm> :t getRandomR
08:02:00 <lambdabot> Not in scope: ‘getRandomR’
08:04:45 <deweyvm> http://lpaste.net/105803 there we go :)
08:04:47 <deweyvm> thanks all
08:08:18 <deweyvm> is it possible to then escape the MonadRandom or am i stuck there?
08:08:55 <jhance> deweyvm: runRand
08:09:33 <deweyvm> cool
08:11:24 <tar_> is it possible to write nub using a fold and still have it be lazy?
08:19:49 <ttll> hello
08:21:26 <ttll> I have a data type with a lot of constructors, I want to use the derived Show implementation for all but a few of them
08:22:28 <tar_> I don't think you can do that in a type-safe way.
08:22:43 <jhance> ttll: What is your purpose
08:23:41 <ttll> I want to override the implementation provided by "deriving (Show)" in a few cases
08:24:39 <jhance> ttll: Do you actually want Show then?
08:25:06 <n-dolio> That is not possible.
08:25:26 <ttll> it would be nice
08:25:42 <jhance> ttll: I would recommend deriving Show, because non-Show-derived Show instances are a bit odd, and then write your own function for string conversion that relies on show and the special cases
08:25:55 <ttll> ok
08:26:09 <jhance> ttll: Reason being that you probably want Read to not be broken
08:26:29 <pjdelport> tar_: foldr (\x xs -> x : filter (x /=) xs) [] ?
08:26:36 <ttll> well when I write my own instance I break read anyways
08:26:51 <jhance> ttll: Exactly, but show . read ideally should work
08:26:56 <napping> If you want to use read at all, you should probably derive Show
08:27:08 <joshc> you could use a newtype wrapper
08:27:40 <napping> On the other hand, if you don't want Read, Show could be something else
08:27:58 <jhance> Its the same thing as how when we parse values, we don't implement the parser as an instance of read, we create a separate function, because Show/Read aren't for pretty printing, they are for printing a haskell-code representation of the data
08:28:19 <napping> I've used Show for modestly pretty output of things I don't want Read instances of
08:28:32 <napping> granted, that was more necessary before GHCi let you switch out the printing function
08:29:30 <rwbarton> ghci does what now?
08:30:04 <napping> oh, doesn't it?
08:30:12 <yitz> napping: yeah it's not needed as much. and it's a bad habit - someday you will certainly find yourself needing quick serialization/deserialization for something and you'll be borked.
08:30:23 <napping> huh?
08:30:27 <napping> I'd just derive Binary for that
08:30:28 <ttll> well even if I use Read and Show for (de)serialization, I think there is something to be gained from being able to access derived methods
08:30:40 <tar_> pjdelport: cool! thanks, not sure why I couldn't see that solution. :)
08:30:43 <rwbarton> ttll: you can use some flag to ghc to have it print the instance it derived
08:31:04 <yitz> napping: then you'd have to go to all of the upstream authors of all the types involved and get them to provide Binary
08:31:06 <ttll> it could break read, but so could creating the instance from scratch
08:31:08 <rwbarton> ttll: -ddump-deriv
08:31:38 <napping> If you can't convince GHCi to use another function, than depending on how you work, being the class that ghci uses to print stuff is at least as significant as having a slow textual serialization
08:32:10 <jhance> Quick human-readable serialization
08:32:16 <yitz> right
08:32:19 <rwbarton> in my experience a common reason for using Show specifically is you actually have a [(String, T)] or whatever
08:32:32 <rwbarton> that you want to display
08:32:37 <napping> ttll: In any case, note that getting Show to produce valid code might require custom instances anyways if you want to hide the internal representation
08:32:59 <napping> jhance: I don't think I've ever needed that instead of quick human-readable output
08:33:10 <ttll> I'm pretty-printing anyways, so I'll just use a custom method
08:33:18 <jhance> napping: You've never had to debug anything in your life by looking at what data it contains?
08:33:36 <yitz> rwbarton: i've had cases where there is a huge nested type, involving hundreds of types, some local and some coming from hackage.
08:33:41 <napping> Yeah, if you want decent pretty printing you'll want a class that makes some kind of prety printer Doc
08:33:43 <rwbarton> if you don't want to piggyback on the existing Show instances then there's less reason to use Show specifically
08:33:52 <ttll> just wanted to make sure I'm not missing something, thanks anyway!
08:34:05 <jhance> Show does absolutely nothing for you if you don't want to derive, might as well derive it and use a separate function for pretty printing
08:34:06 <napping> jhance: never when the only source is serialized data which could have been reasonably serialized in an inefficient format
08:34:26 <yitz> rwbarton: a human-readable but inefficient serialization that can be had immediately for such a type can often be extremely valuable.
08:34:30 <napping> nah, show also provides instances for containers like lists and maps and so on of your data
08:34:50 <rwbarton> yitz: by serialization you mean something that can be deserialized too I guess?
08:35:02 <napping> for debugging values existing in memory, the important thing is dumping to a human-readable format, and that's fairly orthogonal from machine readable
08:35:04 <yitz> rwbarton: usually a bit more useful yes ;)
08:35:19 <rwbarton> yitz: you can make exactly the same argument for a display that is intended solely for human consumption
08:35:27 <rwbarton> yitz: so it's just a matter of what you want to do with it
08:35:53 <napping> If there was a standard pretty-printing class that provided instances like Pretty a => Pretty [a] and for maps and so on, then it would be equally convenient
08:36:05 <jhance> You also break anything that uses your data type from deriving Show and getting what they expect
08:36:07 <rwbarton> right, but in fact there's only one
08:36:17 <napping> and that's fine if it's a program rather than a library
08:36:33 <napping> I certainly wouldn't do that in anything I was distributing as a library
08:36:36 <jhance> Not necessarily, if you want to extend the program to add a new feature which requires a new type
08:36:44 <napping> huh?
08:36:58 <yitz> jhance: a real bona-fide Read/Show instance is invertible, and produces valid Haskell code. there can often be ways of doing that which are different than what you get from deriving.
08:36:59 <napping> If it's only used in my own program, than I control everything that might want to Read it too
08:37:24 <jhance> Okay, so you never work with anyone else?
08:37:27 <napping> I'd certainly never provide a Read and a Show for which read . show isn't suitable close to an identity
08:37:31 <rwbarton> why "never"?
08:37:36 <napping> but there are plenty of typed that never need a Read instance
08:37:44 <jhance> I just think its generally a good idea to not mess with whoever else is working on your codebase.
08:37:47 <napping> It's not like we're serializing program images to disk in Show format all the time
08:37:58 <napping> Do you claim every class needs a read instance?
08:38:08 <jhance> No, but I claim that every class with a show instance needs a read instance
08:38:14 <napping> Because if I don't provide a Read at all they couldn't derive Read on their types containing mine in the first place
08:38:16 <rwbarton> I don't understand why we either need to always be doing something or never be doing something
08:38:26 <napping> why in the world would you always need read with show?
08:38:46 <jhance> Why would there ever be a data type where I want to derive show but theres a reason to not derive read?
08:39:01 <napping> that's not the same as all types
08:39:07 <jhance> Yes it is
08:39:19 <napping> I didn't say there was a reason not to derive read, I said there was not a reason to derive read.
08:39:26 <jhance> for all types <=> not exists any not
08:39:38 <napping> only in classical logic
08:39:59 <napping> anyway, not exists is not the same as exists not
08:40:08 <Philonous> "The function ‘deleteWhere’ is applied to two arguments, but its type [...] has only two" Errr, no kidding.
08:40:09 <jhance> No, its not...
08:40:17 <jhance> not exists => forall not
08:40:39 <napping> In any case, there are plenty of types I've never wanted to read
08:41:10 <yitz> i used to be more cavalier about messing with Show and Read instances, but after getting burned enough times i stopped doing that.
08:41:14 <jhance> But you can't see into the future; you might need to read something that uses that type, and theres a zero-cost in productivity for just sticking on derive Read
08:42:03 <napping> there's a non-zero cost to productivity for using some non-derivable pretty printing class
08:42:36 <jhance> Its going to be nonzero whether or not you use show or your own function
08:42:48 <jhance> The only difference is whether you conform to the normal standards people expect from your show instance
08:43:07 <napping> you mean read . show ~= id?
08:43:28 <jhance> No, I mean that I get the exact output I would expect from a Show instance
08:43:44 <napping> so Map's show is broken?
08:43:50 <napping> cause it's certainly not the derived one?
08:43:56 <Peaker> Seeing a performance regression in 7.8.2 vs. 7.6.3 (12%) on some type inference stuff
08:44:08 <Peaker> (an implementation of Algorithm W, that is)
08:44:21 <napping> Peaker: your own code that's implementing type checking?
08:44:25 <jhance> Certainly not, thats the same as saying that String's show is broken because its not ['a', 'b']
08:44:27 <yitz> Peaker: uh oh
08:44:47 <napping> sounds like enough that GHC folks would be interested in either case
08:45:27 <yitz> Peaker: did you try HEAD?
08:46:13 <Peaker> napping: yes
08:46:35 <Peaker> yitz: nope.. just hoped some performance issues were resolved by 7.8 so I wouldn't have to code around them
08:46:57 <yitz> Peaker: some serious type inference bugs have been fixed and will soon be released as 7.8.3.
08:47:11 <napping> but it's a performance regression on the same code, right?
08:47:49 <yitz> not the bugs - the fixed ghc
08:47:57 <Peaker> napping: yes, exactly the same code (which happens to implement AlgorithmW/type-inference)
08:48:10 <napping> Do you have a way of coding around the performance problem?
08:48:26 <napping> If there's other code that's faster and shouldn't be, that's probably interesting for a bug report too
08:49:24 <rwbarton> do you use Typeable?
08:50:09 <napping> jhance: being able to get pretty printing of my values inside of other types that only provided a parameterized Show instance is valuable
08:51:06 <luite> hmm, check-pvp doesn't install with GHC 7.8 due to an overly restrictive base upper bound
08:51:17 <rwbarton> luite: lol
08:51:21 <rwbarton> figures
08:51:40 <napping> have you read what John Meacham says about that?
08:52:31 <rwbarton> Peaker: there is https://ghc.haskell.org/trac/ghc/ticket/9203, I think/hope it will be merged into 7.8.3, so try when that comes out
08:52:35 <luite> but actually i was looking for another tool, i recall there was something to check whether all upper bounds in a cabal file allow the latest version on hackage, does anyone know the name?
08:52:41 <luite> napping: i haven't
08:52:50 <fread2282> what happened to epigram 2?
08:53:15 <napping> basically that he's happy to use autotools (despite autoconf's annoyances), and just check for the existance of functions and instances he needs.
08:54:05 <napping> and that makes his code a lot more reliably portable to different versions of libraries and even non-GHC compilers
08:54:38 <yitz> luite: it does. use --allow-newer :)
08:54:51 <napping> And I think we could perhaps automate extracting signatures like that, and then PVP-style numbering/strict bounds on indiviual exported items would be useful
08:55:22 <napping> I assume it's almost all the time that some function changed in an incompatible way, still most function didn't
08:55:26 <rwbarton> seems like autoconf can solve the "will this build with the versions I have installed" problem, but not the "what versions do I need to install to make this build" problem
08:56:03 <Peaker> rwbarton: thanks, I don't use Typeable... I use GHC.Generic though it's probably unrelated
08:56:05 <rwbarton> however, with base specifically, the latter problem is pretty much irrelevant
08:56:18 <napping> Yeah, but if you had an automatical tool that would say something like "only code reachable from A.foo and B.bar changed since the laster version, do you need to bump bounds", then you could reasonably version individual symbols
08:56:36 <gdoteof> when i import a whole library rather than just a specific part of it; am i bloating the size of an executable?  and/or do unnecessary imports bloat an executable.. and/or will/can ghc trim out unnecessary imports?
08:56:38 <napping> And if you say "I need Data.List.group >= 0.0.0" and so on
08:57:01 <napping> then you could actually record strict upper bounds, and still reasonably compute compatibility
08:57:04 <rwbarton> then yes, you get more compatibility overall
08:57:07 <luite> yitz: yeah of course i did manage to install it, but do you know the name of the actual tool i was looking for?
08:57:18 <napping>  and also precompute which pairs of versions everything on hackage are compatible
08:57:41 <yitz> luite: actual? not check-pvp?
08:57:52 <luite> ah i guess i was looking for cabal-bounds
08:57:57 <napping> and maybe even get lower bounds lower than what you actually build against
08:58:23 <napping> if you e.g. only use functions from the 0.0 version of a type class, even though you build with a 0.1 that adds some more methods
08:58:46 <napping> basically, highly detailed dependency info could perhaps be automated enough to be practical
09:00:04 <yitz> napping: yes people have discussed that. it would be a nice.
09:00:07 <edwardk> someone a few weeks back posted an article showing a command line tool that gave a spanning tree showing the paths from your packages to your dependencies. does anyone remember where/what that was?
09:01:04 <napping> now that I say all of that, it actually sounds kind of approachable
09:01:40 <edwardk> cabal-db?
09:01:42 <napping> dust off the GHC api for some dependency analysis, download lots of code from Hackage, and have at it
09:01:43 <luite> hmm, cabal-bounds is close, but i just want some cabal-bounds check that reports whenever anything is out of date
09:01:51 <napping> to busy to try it soon, though
09:02:19 <luite> ah looks like cabal-db also does this :)
09:02:19 <edwardk> luite: i use packunused
09:02:48 <edwardk> luite: i set that up in my travis.yml to complain if i'm not using a dependency, etc.
09:03:29 <luite> edwardk: ah that's also useful
09:05:18 <napping> incidentally, optparse-applicative's bash completion is pretty nice
09:08:22 <keseldude> just playing with types -- is it possible to create a type that holds two possible types (like Either) and have something like Map (Either a b) (Either a b), except you constrain if 'a' is the key, then 'b' is the value and vice versa (if 'b' is the key, then 'a' is the value)
09:08:29 <keseldude> not necessarily practical, just curious
09:10:45 <dottedmag> Looks like what you want is the same as (Map a b, Map b a) :)
09:10:58 <keseldude> right, haha
09:11:02 <napping> and check out dependent-map
09:11:15 <keseldude> but I just wanted to see if it was possible to do it with type constraints
09:11:45 <keseldude> looking at dependent-map
09:11:46 <luite> napping: you should rewrite GHC's option parser with optparse-applicative
09:11:48 <napping> no, everyting involved has type Either a b
09:12:02 <napping> you need to look into the values a bit
09:12:22 <napping> luite: I'm writing a simpler option parser for now. I'd like to tweak some of the error reporting around subscommands
09:12:32 <napping> hmm, I guess GHC doesn't use them anyway
09:12:51 <napping> basically, program COMMAND is pretty darn useless as the main errr
09:13:11 <napping> but on the other hand once it's got a specific command the brief description is usually useful
09:13:35 <napping> maybe I should just set the metavar for now
09:16:44 <Twey> dottedmag: There's a ‘bimap’ package on Hackage, which is basically just a pair of maps
09:24:40 <keseldude> Twey: yeah, exactly, I just found that... seems like the best you can do for this
09:25:18 <Twey> I also find the bimap solution kind of unsatisfactory, but I'm not sure why
09:26:09 <Twey> Hm
09:28:48 <Twey> keseldude: I feel like DMap might be closer to what you originally specified, though
09:29:16 <keseldude> yeah, it's just a tiny bit over my head at this point
09:29:23 <keseldude> I'll have to spend some time to understand it
09:29:41 <Twey> napping: Heh, I encountered a program not so long ago whose sole error on incorrect invocation was literally ‘Usage: program <arguments>’
09:30:36 <napping> Twey: It's not nearly that bad, explicitly passing -h will actually tell you something useful
09:30:46 <napping> or did your program have a -h too?
09:30:55 <napping> I'm reminded of the default yacc error "Parse Error"
09:31:13 <napping> I was surprised how much just improving that to "Parse Error on line %d" helped
09:31:54 <Twey> napping: Not as far as I could find
09:32:06 <napping> oh, that's horrible then
09:32:40 <nexx> Twey some only accept --help
09:32:53 <napping> giving something that's recognizably an error on bad invocation, and actually useful help with -h or --help (or mabye /h /? if it's a DOS refugee?) is at least tolerable
09:33:23 <nexx> I think ‘Usage: program <arguments>’ error are not that uncommon :/
09:35:25 <rwbarton> hopefully with the actual program name substituted for "program", at least
09:39:20 <Chousuke> I appreciate GNU tools for that they usually have a good --help
09:39:53 <napping> I think anything written with optparse-applicative will have a good help
09:43:48 <rupert> I have what is perhaps a dumb question, but it is driving me crazy. I'm trying to import Repa as follows:
09:44:03 <rupert> import Data.Array.Repa ( Z, (:.) )
09:44:14 <path[l]> :t <$>
09:44:16 <lambdabot> parse error on input ‘<$>’
09:44:22 <path[l]> :t ‘<$>'
09:44:23 <d3m1g0d->    :t ($)
09:44:24 <lambdabot> lexical error at character '\8216'
09:44:29 <path[l]> oh
09:44:34 <path[l]> :t ($)
09:44:35 <rupert> Which I think should work but I get errors when I try to use Z or (:.)
09:44:35 <lambdabot> (a -> b) -> a -> b
09:44:43 <path[l]> hmm
09:44:51 <path[l]> I wanted to check <$> though
09:45:00 <Gurkenglas> :t (<$>)
09:45:01 <lambdabot> Functor f => (a -> b) -> f a -> f b
09:45:01 <Gurkenglas> derp
09:45:06 <path[l]> ah brackets
09:45:10 <path[l]> got it
09:45:11 <path[l]> thanks
09:45:40 <galderz> hi all
09:45:44 <Peaker> optparse-applicative is pretty great :)
09:45:54 <galderz> i've installed process-1.2 via: "cabal install process"
09:46:17 <rupert> anyone know why I can't import Z and (:.) alone from Repa? import Data.Array.Repa ( Z, (:.) ) doesn't seem to work for some reason...
09:46:22 <galderz> GHCi runtime linker: fatal error: I found a duplicate definition for symbol _getProcessExitCode
09:46:26 <galderz> any ideas?
09:46:35 <rwbarton> rupert: you're importing the types but you probably want the data constructors too
09:46:37 <galderz> whilst processing object file /Users/g/Library/Haskell/ghc-7.6.3/lib/process-1.2.0.0/lib/libHSprocess-1.2.0.0.a
09:47:02 <rwbarton> rupert: so Z(..), (:.)(..)
09:47:03 <rupert> rwbarton: ahhh yes. so import Data.Array.Repa ( Z(..))
09:47:04 <Gurkenglas> (Why do people use map instead of <$>?)
09:47:10 <rupert> ah
09:47:15 <rupert> :. is a type
09:47:17 <rupert> i see
09:47:20 <rupert> thanks
09:47:42 <rwbarton> right, it's used like 1 :. 2 :. Z :: Int :. Int :. Z -- iirc
09:48:01 <Philonous> Gurkenglas, "Say what you mean". Reading  "map" it's clear that he second argument must be a list.
09:48:10 <rupert> Yep, thanks. I couldn't remember what I was missing : )
09:48:41 <Faucelme> :galderz Try installing it from cygwin, I tend to have problems installing process from the windows command line.
09:48:54 <galderz> Faucelme, i'm on osx...
09:52:42 <galderz> any other ideas?
09:53:25 <rwbarton> galderz, maybe ghci is trying to load two different versions of process?
09:53:53 <galderz> rwbarton, i'd imagine that once you have installed a newer package, it would load that up...
09:54:01 <galderz> rwbarton, how do I tweak that?
09:54:03 <rwbarton> you might have a package which depends on the other version
09:54:11 <rwbarton> that you loaded first
09:54:25 <rwbarton> ghc-pkg list process
09:54:30 <rwbarton> will tell you what versions you have installed
09:56:09 <galderz> rwbarton, https://gist.github.com/galderz/68b1f34d597b5f3a1d18
09:57:09 * hackagebot aur 0.1.0 - Access metadata from the Arch Linux User Repository.  http://hackage.haskell.org/package/aur-0.1.0 (fosskers)
09:59:16 <rwbarton> galderz: in my opinion it's a bad idea to ever have multiple versions of a package installed, so I would unregister process-1.2.0.0 (as the other one seems to have come with GHC) and anything that depends on it
10:00:09 <rwbarton> then I would modify .cabal/config as described here (http://www.vex.net/~trebla/haskell/haskell-platform.xhtml#correction) so it doesn't happen again
10:01:05 <rwbarton> or if you don't have haskell platform installed, then do that for whatever packages came with ghc
10:01:17 <galderz> rwbarton, back to the dark ages of process...
10:04:30 <rwbarton> if you actually need new process features then there are other approaches, however this is the simplest
10:04:53 <galderz> rwbarton, ok, thanks for the help!
10:06:20 <moghedrin> @pl \x y f g -> f x y && g x y
10:06:20 <lambdabot> ap (ap . ((flip . (((.) . (&&)) .)) .) . flip . flip id) (flip . flip id)
10:06:29 <moghedrin> Ugh.
10:06:40 <armlesshobo> what does @pl do?
10:07:22 <moghedrin> armlesshobo: Gives you a pointless version of what you type in.
10:07:27 <armlesshobo> nice
10:07:34 <armlesshobo> i like cryptic and pointless
10:07:37 <c_wraith> :t liftM2 (liftM2 (&&))
10:07:38 <lambdabot> (Monad m1, Monad m) => m (m1 Bool) -> m (m1 Bool) -> m (m1 Bool)
10:07:44 <moghedrin> armlesshobo: Sorry. Not pointless. Point free.
10:07:51 <armlesshobo> ah
10:07:52 <armlesshobo> hahah
10:07:54 <c_wraith> moghedrin: I think that's what you're looking for
10:07:54 <moghedrin> XD
10:08:52 <c_wraith> :t liftM2 (liftM2 (&&)) (||) (&&)
10:08:53 <lambdabot> Bool -> Bool -> Bool
10:09:07 <c_wraith> :t liftM2 (liftM2 (&&)) (==) (/=)
10:09:09 <lambdabot> Eq a => a -> a -> Bool
10:09:13 <c_wraith> seems right
10:09:21 <bitemyapp> :t (&&)
10:09:22 <lambdabot> Bool -> Bool -> Bool
10:09:59 <armlesshobo> :t ap
10:10:00 <lambdabot> Monad m => m (a -> b) -> m a -> m b
10:10:19 <armlesshobo> :t flip
10:10:20 <lambdabot> (a -> b -> c) -> b -> a -> c
10:13:00 <c_wraith> Note that (liftM2 (liftM2 (&&)) (==) (/=)) is (const False) for anything that obeys the laws for Eq
10:13:16 <c_wraith> Well.  Perhaps a slightly-less-terminating version of const False
10:13:28 <napping> and also false for floats
10:13:32 <napping> so pretty false
10:14:52 <c_wraith> Eh.  Everyone knows floating point types don't obey the Eq laws
10:15:06 <napping> no, that's also const False even on floats
10:15:08 <Kaidelong> they do, Haskell Eq doesn't require reflexivity
10:15:22 <napping> NaN == NaN and NaN /= NaN are both false
10:15:42 <c_wraith> napping: so...  That expression will still return False, is what you're saying?
10:15:46 <napping> yeah
10:15:50 <c_wraith> napping: sounds like the same thing const False would return
10:15:51 <c_wraith> :P
10:16:26 <napping> if it returns False on anyting that obeys the Eq laws and the one exception allowed in base, then you can be really confident changing it to const False
10:16:42 <c_wraith> napping: Float and Double aren't exceptions
10:16:45 <napping> I'd hesitate a bit if it was something that floats could make behave strangely
10:16:51 <c_wraith> napping: they still return False
10:17:03 <Kaidelong> I think he means they don't obey the Eq laws
10:17:19 <Kaidelong> but AFAIK the Eq law they break isn't actually considered an Eq law
10:18:05 <Kaidelong> you are not supposed to assume, in general, that x == x
10:18:14 <rwbarton> pretty sure "a == a = True" is an Eq law
10:18:25 <c_wraith> Yes, the only Eq law my assertion depends on is that there is no pair (a,b) such that a == b is True and a /= b is True
10:19:15 <napping> even so, a == b && a /= b should be against the laws, if Eq has any at all
10:19:17 <rwbarton> or at least "a == a isn't False"
10:19:24 <quchen> Eq doesn't have any laws.
10:19:37 <napping> not ((a==b) == (a/=b))
10:20:06 <hayashi> > (0/0) == (0/0)
10:20:07 <quchen> Those are the default definitions. It's very good taste to keep this behaviour, but the Report doesn't mention any laws specifically.
10:20:08 <lambdabot>  False
10:20:14 <rwbarton> :t lookup
10:20:15 <lambdabot> Eq a => a -> [(a, b)] -> Maybe b
10:20:16 <hayashi> > (0/0) /= (0/0)
10:20:18 <lambdabot>  True
10:20:32 <hayashi> ^ !?
10:20:36 <rwbarton> surely one expects, for example, lookup a [(a,b)] = Just b
10:20:50 <hayashi> > (0/0)
10:20:52 <lambdabot>  NaN
10:20:56 <keseldude> how do I make a function with 20 applications of join without writing join . join . join ...
10:21:13 <rwbarton> I don't really think the Report is authoritative on laws
10:21:14 <c_wraith> keseldude: how do you end up with such a function?
10:21:38 <keseldude> foldr1 (.) (replicate 20 join) complains
10:21:40 <quchen> rwbarton: Well, it recommends the laws for Functor and Monad. It doesn't recommend for Eq.
10:21:42 <keseldude> just for fun
10:21:44 <hayashi> > ((0/0) == (0/0)) && ((0/0) /= (0/0))
10:21:47 <lambdabot>  False
10:21:54 <Gurkenglas> :t join
10:21:55 <lambdabot> Monad m => m (m a) -> m a
10:22:10 <jhance> keseldude: Can't fold because the type of the accumulator would change
10:22:11 <Gurkenglas> :t join . join
10:22:12 <lambdabot> Monad m => m (m (m a)) -> m a
10:22:15 <quchen> keseldude: You can't write that function in Haskell, it requires dependent types (since the type of "joinN n" depends on "n")
10:22:16 <keseldude> right
10:22:17 <Gurkenglas> That's not the same type
10:22:18 <c_wraith> keseldude: yeah, foldr (.) only works when the function's type unifies with a -> a
10:22:19 <Gurkenglas> Can't do fold
10:22:21 <Kaidelong> (!! 20) . iterate join
10:22:22 <rwbarton> quchen: maybe because Float/Double in fact don't satisfy the laws
10:22:28 <quchen> rwbarton: Probably, yes.
10:22:35 <Gurkenglas> :t iterate
10:22:36 <keseldude> can't do iterate join either
10:22:36 <lambdabot> (a -> a) -> a -> [a]
10:22:49 <Gurkenglas> Kaidelong, join isn't an a->a
10:22:49 <rwbarton> but everyone knows Eq is for equality, and everyone knows a thing is equal to itself
10:22:56 <keseldude> yeah, ok, can you do it with language extensions?
10:22:59 <Kaidelong> oh that's true
10:23:23 <keseldude> I couldn't think of how to do it with language extensions either
10:23:26 <Kaidelong> well mmm
10:23:40 <Gurkenglas> Well you can write log(20) times by doing jointwice=join.join and joinquads=jointwice.jointwice
10:23:52 <keseldude> haha true
10:23:55 <glosoli> What do folks use to develop desktop apps with Haskell ?
10:24:17 <Gurkenglas> (Couldn't you just do joinn n = joinn (n-1) . join?
10:24:18 <Gurkenglas> *)
10:24:28 <Kaidelong> @ty let j = join . join . join . join in let k = j . j . j . j in k . j
10:24:29 <jhance> Gurkenglas: No, won't typecheck.
10:24:29 <lambdabot> Monad m => m (m (m (m (m (m (m (m (m (m (m (m (m (m (m (m (m (m (m (m (m a)))))))))))))))))))) -> m a
10:25:00 <jhance> you could use TH
10:25:26 <Kaidelong> exploiting that 20 = 4 + 16
10:26:45 <genisage> Just out of curiousity, is it possible to declare something like:
10:26:57 <genisage> instance Num (Int -> Int) where...
10:27:07 <Kaidelong> (I expect he found himself needing to do this because he was working with matrices and wanted a length typed vector and is doing it with functions with huge arities, but what do I know)
10:27:18 <genisage> Without wrapping the functions in a new type
10:27:33 <genisage> Or does that not make any sense?
10:27:54 <Kaidelong> genisage: Num r => Num (a -> r)
10:28:04 <Kaidelong> @ty (+3) + (+6)
10:28:06 <lambdabot> (Num (a -> a), Num a) => a -> a
10:28:10 <keseldude> Kaidelong: don't be so optimistic in thinking that I have a use for this
10:28:14 <keseldude> I just wanted to see for fun
10:28:38 <Kaidelong> keseldude: I think in idris you can make a higher order function that does this, at least
10:28:41 <rwbarton> in general the purpose of typed languages is to not give you ways to write programs you don't need to write
10:29:20 <keseldude> haha, maybe you're right
10:29:30 <flazz> when submiting a ghc bug, is it preferred to put a simple test case inline or link in the test case field?
10:29:32 <Kaidelong> rwbarton: but this sort of program is perfectly acceptable to write, and haskell does let you write it, it is just tedious and there is no general case even though there should be a general case
10:29:53 <Kaidelong> and with a smarter type system you could probably write the general case
10:30:06 <jhance> Kaidelong: Idris has dependent types, so yes you can in Idris
10:30:45 <jhance> Kaidelong: And you technically can write the general case in Haskell w/ TH, if that counts...'
10:31:07 <Kaidelong> jhance: well that does kind of work around the type system rather than within it
10:31:09 <bitemyapp> Kaidelong: what's @ty?
10:31:22 <Kaidelong> bitemyapp: lambdabot expands it to @type
10:31:31 <bitemyapp> Kaidelong: what's @type?
10:31:39 <Kaidelong> lambdabot seems to understand @type in some contexts where it ignores :t
10:31:40 <bitemyapp> :t (+3) + (+6)
10:31:43 <lambdabot> (Num (a -> a), Num a) => a -> a
10:31:47 <bitemyapp> hrm.
10:31:52 <bitemyapp> I usually use :t
10:32:00 <Kaidelong> so I just use @ty by default
10:32:02 <bitemyapp> I'm a little confused now.
10:32:27 <jhance> :t is for GHCi only, but @type works w/ lambdabot
10:32:29 <lambdabot> parse error on input ‘,’
10:32:41 <Twey> bitemyapp, Kaidelong: The command is @type.  λb will expand any unambiguous partial command.  :t is a handy alias for @type that looks like GHCi's syntax.
10:32:45 <quchen> No, Lambdabot can do :t too.
10:32:46 <jhance> err, GHCi only accepts :t, but lambdabot will accept either
10:33:14 <Kaidelong> Twey: do you know why lambdabot sometimes seems to choke on :t?
10:33:22 <rwbarton> it used to ignore :t in PM
10:33:22 <Twey> Kaidelong: In what context?
10:33:33 <quchen>  :t is a hack in Lambdabot though (lambdabot is not GHCi after all).
10:33:38 <Kaidelong> I guess PM was the only place I really encountered
10:33:46 <Twey> The :t command is a magic alias, and may not always behave like a real command
10:34:24 <Twey> genisage: Yes, you can absolutely write such an instance.  Actually, lambdabot used to have one in scope: (f * g) x = f x * g x, et cetera
10:34:52 <Kaidelong> it doesn't still?
10:35:10 <Kaidelong> > ((+2) * (/4)) 65
10:35:12 <lambdabot>  No instance for (GHC.Show.Show a0)
10:35:12 <lambdabot>    arising from a use of ‘M648790020242609650812964.show_M6487900202426096508...
10:35:12 <lambdabot>  The type variable ‘a0’ is ambiguous
10:35:12 <lambdabot>  Note: there are several potential instances:
10:35:12 <lambdabot>    instance [safe] GHC.Show.Show
10:35:19 <Twey> :t (.)
10:35:20 <lambdabot> (b -> c) -> (a -> b) -> a -> c
10:35:23 <Twey> I think it was removed along with some of the other Caleskell extensions like (.) = fmap
10:35:47 <Twey> For newbie-friendliness, or something
10:35:48 <Kaidelong> well (.) = fmap is wrong anyway
10:35:52 <yitz> when caleskell was replaced by lenskell
10:35:58 <Twey> Heh
10:36:01 <Twey> Kaidelong: Why's that?
10:36:04 <Kaidelong> (.) should be the method from Category instead
10:36:13 <Twey> Mm, yeah
10:36:18 <Twey> Perhaps so
10:37:14 <hexagoxel> there are cases where "undefined" would be perfectly valid in production code, right?
10:37:45 <yitz> hexagoxel: we'd like to get away from that as much as possible, but there are cases where it is still needed.
10:37:57 <quchen> Valid maybe, perfectly valid not so much.
10:38:10 <Kaidelong> hexagoxel: there are two cases, one is for code branches that cannot be reached, but you can usually just leave those undefined rather than write down undefined
10:38:23 <Kaidelong> also in that case you should use error instead of undefined
10:38:23 <rwbarton> it's better to use error "some unique string", just in case
10:38:30 <hexagoxel> unless you want to avoid the warning..
10:38:37 <Kaidelong> the other case is for when you need something of a certain type but don't need to evaluate it
10:38:57 <Kaidelong> Typeable does something like that internally
10:39:18 <yitz> in Foreign you use it for casting pointers sometimes i think
10:39:37 <rwbarton> true, sizeOf (undefined :: Int) etc.
10:40:27 <hexagoxel> is there any convention of how to distinguish the valid from the "temporary" uses of undefined ("temporary" = "i know code is missing, but want to see if the program compiles so far")?
10:40:33 <Kaidelong> hexagoxel: if you are avoiding that warning for your pattern match being refutable then you really should use error "foo" instead of undefined anyway
10:40:40 <hexagoxel> you already mention to use "error" instead, i guess
10:40:55 <notdan> typed holes?
10:40:58 <Kaidelong> error "foo: Not implemented"
10:41:00 <Kaidelong> I guess would work
10:41:13 <notdan> http://www.haskell.org/haskellwiki/GHC/TypedHoles
10:41:16 <yitz> > floatDigits (undefined :: Double)
10:41:17 <Kaidelong> oh yeah you could use typed holes if you defer type checks to runtime
10:41:18 <lambdabot>  53
10:41:23 <Kaidelong> err type errors
10:41:24 <bitemyapp> really?
10:41:31 <Kaidelong> type checks still done at compile time, of course
10:42:02 <Kaidelong> https://www.haskell.org/ghc/docs/7.6.1/html/users_guide/defer-type-errors.html
10:42:57 <wz1000> Hi guys, I have a question. GHCi seems to accept when i define 'data P = (+) Char Char', but i can't use that definition of (+) in anyway. What's going on?
10:42:57 <Kaidelong> (speaking of which, ghc-mod should probably work with this functionality so that looking up the type of things will still work when the program has a type error)
10:44:31 <Kaidelong> wz1000: what does GHCi shout at you when you try it?
10:44:32 <rwbarton> wz1000: weird
10:45:05 <wz1000> Nothing, it just tries to use the Num definition of +
10:45:07 <hexagoxel> ah i did not know about defer-type-errors, thanks
10:45:11 <orzo> i just tried it
10:45:15 <orzo> interesting
10:45:23 <orzo>     No instance for (Num Char) arising from a use of `+'
10:45:27 <yitz> wz1000: yeah you're right. that looks like a bug.
10:45:38 <rwbarton> ghc should reject your data P definition
10:45:52 <rwbarton> since the constructor should start with a colon
10:46:19 <Iceland_jack> ghci> :i P
10:46:19 <Iceland_jack> data P = + Char Char    -- Defined at <interactive>:40:1
10:46:22 <Iceland_jack> interesting..
10:46:51 <rwbarton> ghc 7.4 correctly rejects it
10:46:57 <Iceland_jack> 7.8.3 doesn't
10:47:06 <orzo> rwbarton: ghci too?
10:47:06 <bitemyapp> Well that is terrifying.
10:47:13 <rwbarton> yes
10:47:15 * Iceland_jack shrugs
10:47:23 <Iceland_jack> Doesn't really have much of an effect
10:47:41 * hackagebot hblas 0.3.1.1 - Human friendly BLAS and Lapack bindings for Haskell.  http://hackage.haskell.org/package/hblas-0.3.1.1 (CarterSchonwald)
10:47:50 <Iceland_jack> You can't pattern match on it or construct values using it
10:48:02 <orzo> I used | to give P another value that ghci accepts as type P
10:49:08 <orzo> it doesn't take it as infix
10:49:20 <orzo> data P = Char + Char -- error
10:49:23 <rwbarton> yeah, if you pick another name like +++ and try to use it in an expression then ghci tells you that +++ isn't in scope
10:49:33 <yitz> in fact + retains its old definition which is not shadowed in any way
10:50:33 <wz1000> Is everyone using GHCi 7.8.* on a *nix?
10:50:40 <orzo> no i'm using old
10:50:41 <orzo> older
10:50:45 <Iceland_jack> I am
10:50:54 <orzo> 7.6.3
10:51:05 <Sebastian_> hey guys, trying to update cabal fails on a freshly installed system (windows, newest haskell platform). can someone help? http://pastebin.com/raw.php?i=qCP3ezmJ
10:52:01 <Kaidelong> does GHC 7.8.* work on Win64 yet?
10:52:05 <yitz> it does have an effect - with -Wall, all patterns for that type are now non-exhaustive.
10:52:17 <Kaidelong> last I knew it was broken there and that was why it wasn't the official release
10:52:22 <yitz> Kaidelong: i sure hope so.
10:52:57 <Iceland_jack> yitz: yes but this is a fairly pathological example, you notice if you can't use the constructor you just defined
10:53:22 <yitz> i just tried it in 7.8.2. same bug.
10:53:37 <orzo> changing (+) to (-) causes it to detect the error
10:53:47 <yitz> Iceland_jack: true. then again, all bugs are pathological. :)
10:54:01 <orzo> (*) works though
10:54:16 <yitz> Kaidelong: 7.8.2 is an official GHC release
10:54:49 <yitz> orzo: "works"
10:54:53 <orzo> yeah heh
10:55:01 <wz1000> (-) seems to show the same buggy behavior on 7.8.2
10:55:33 <wz1000> data P = (-) Int Int produces no complaint
10:56:09 <orzo> parse error on input `-'
10:56:24 <wz1000> Nope, not on 7.8.2
10:56:29 <orzo> hm
10:56:38 <Kaidelong> I imagine that's fixed then because I remember they specifically mentioned in the bug tracker that GHC 7.8 wasn't going to be "released" until it worked on windows
10:57:08 <wz1000> This gets even weirder.
10:57:10 <yitz> people on #ghc don't seem to be familiar with this. wz1000 would you like to create a ticket for this? nice find.
10:57:23 <wz1000> Yeah, sure.
10:58:47 <orzo> the fact that (-) didn't parse in 7.6.3 but does in 7.8.2 might be a useful hint to what is going on
10:59:08 <Iceland_jack> oh actually
10:59:08 <Iceland_jack>     data P = (+)
10:59:08 <Iceland_jack> works as well
10:59:24 <yitz> it seems likely that it's it a simple bug in the TypeOperators implementation.
11:00:55 <Iceland_jack> defining
11:00:56 <Iceland_jack>     data P = (+) (+)
11:00:56 <Iceland_jack> gives an interesting error :)
11:01:46 <flebron> Tangentially related question. I'm trying to understand Wadler's "Theorems for free." I can do the derivations syntactically, but I'm not entirely sure what these relations are supposed to be. I assign "types" the semantics "sets of values". What semantics can I assign these relations between types?
11:06:04 <pavonia> Is TypeOperators something like an undocumented extension? I can hardly find anything about it
11:06:21 <wz1000> Quick poll, which OS's and architectures is this reported on?
11:06:51 <Iceland_jack> Linux, i386
11:07:18 <Iceland_jack> pavonia: there isn't much to them, they just allow you to use infix notation for types
11:07:42 <Iceland_jack> pavonia: https://ghc.haskell.org/trac/haskell-prime/wiki/InfixTypeConstructors
11:09:05 <pavonia> Iceland_jack: But I can't find even a reference in the GHC docs to that extension
11:09:26 <jle`> what is even going on here
11:09:33 <jle`> i can define it as any arbitrary operator
11:09:38 <jle`> and the operator isn't in scope
11:09:53 <Iceland_jack> pavonia: You mean like this? http://www.haskell.org/ghc/docs/latest/html/users_guide/data-type-extensions.html#type-operators
11:10:12 <wz1000> Can anybody with an installation of GHC 7.5 confirm this bug? I think it is confirmed for GHCi 7.6 onwards and is not present on GHCi 7.4
11:10:16 <jle`> data P = (<<%>)
11:10:29 <rwbarton> there is no GHC 7.5
11:10:39 <rwbarton> or rather, there are many
11:10:46 <johnw> logically, everyone with GHC 7.5 can confirm that bug :)
11:10:47 <pavonia> Iceland_jack: Aha, thanks. Google was fooling me
11:10:54 <Iceland_jack> pavonia: works for me :)
11:10:55 <Iceland_jack> @google ghc docs type operators
11:10:55 <lambdabot> http://www.haskell.org/ghc/docs/latest/html/users_guide/data-type-extensions.html
11:10:55 <lambdabot> Title: 7.4.�Extensions to data types and type synonyms
11:11:26 <pavonia> I tried "TypeOperators" or "XTypeOperators" directly
11:11:55 <Iceland_jack> hm I see
11:16:09 <Desheng_> :t (^?!)
11:16:11 <lambdabot> s -> Getting (Endo a) s a -> a
11:17:51 <Desheng_> @src (^?!)
11:17:51 <lambdabot> Source not found. Listen, broccoli brains, I don't have time to listen to this trash.
11:17:52 <Twey> hexagoxel: Valid uses of undefined usually involve passing types around, since they're second-class citizens in Haskell
11:18:31 <merijn> pavonia: Have you read the GHC manual? It has pretty good docs for most extensions
11:18:33 <quchen> Desheng_: https://github.com/quchen/articles/blob/master/lens-infix-operators.md
11:18:41 <quchen> That may help.
11:19:10 <Twey> hexagoxel: Other than that, I don't think there are valid uses.  Places where you're tempted to use undefined should probably be handled with ‘error’ and a descriptive message instead, or, if you can, by better designing your types so those cases are statically guaranteed not to occur
11:19:26 <Twey> (or both, in an occasional case where the latter is true but the compiler isn't smart enough to recognize it)
11:19:53 <pavonia> merijn: Well yeah, the problem was I had trouble finding it in the documentation via Google :)
11:21:28 <BeardedCoder> In Conduit, how would I go about taking chunks of the stream to process them in batches instead of 1 at a time?
11:21:39 <Desheng_> thank you
11:21:55 <jle`> BeardedCoder: does xs <- replicateM n await work?
11:22:14 <BeardedCoder> jle` let me look at that
11:26:18 <johnw> BeardedCoder: isolate
11:26:50 <johnw> ah, maybe not what you wanted
11:26:55 <wz1000> Wow, there are 1308 open tickets for GHC
11:27:06 <johnw> xs <- isolate n $= sinkList
11:27:14 <johnw> ys <- isolate n $= sinkList
11:27:17 <johnw> I *think*
11:27:19 <merijn> johnw: Shouldn't you be paying attention to the lecture? ;p
11:27:24 <johnw> merijn: shhh!
11:27:36 <tommd> Which lecture?
11:27:42 <johnw> we're at OPLSS
11:28:04 <tommd> Ah.  Visiting Portland after?
11:28:10 <johnw> not me
11:28:30 <merijn> I am, for 6 hours, in the middle of the night >.>
11:28:51 <johnw> tommd: the lecture is on proof theory foundations
11:31:52 <Twey> johnw: Which foundations?
11:32:22 <merijn> Twey: "all of them", I think? :p
11:32:50 <l0cust> Is there just like a "plain string" quasiquoter, for multiline strings
11:33:17 <merijn> l0cust: Haskell has multiline strings builtin
11:33:24 <l0cust> hm
11:33:30 <merijn> l0cust: You can put any amount of whitespace between backslash
11:33:31 <l0cust> I always get errors whenever I try to do that
11:33:38 <merijn> > "test \         \ foo"
11:33:39 <lambdabot>  "test  foo"
11:33:47 <l0cust> hm
11:33:51 <l0cust> I'll give it a shot
11:33:54 <johnw> Twey: http://cs.mcgill.ca/~bpientka/oplss/
11:33:54 <BeardedCoder> johnw: https://gist.github.com/ccarter/57e8d1f4f9e37e667bdf
11:33:57 <johnw> that is the instructor
11:34:07 <l0cust> thanks merijn
11:34:15 <Twey> Oh, string gaps survived H2010?  Cool
11:34:18 <johnw> BeardedCoder: you need to replicate the isolation+print
11:34:24 <kini> lol wow there is some weird stuff on the haskell wiki http://www.haskell.org/haskellwiki/Darcs_vs._Git
11:34:32 <johnw> "isolate 2 =$ mapM bulklistIO" prints two elements, but leaves the rest of the stream alone
11:35:11 * hackagebot hums 0.7.0 - Haskell UPnP Media Server  http://hackage.haskell.org/package/hums-0.7.0 (BardurArantsson)
11:35:32 <Twey> johnw: Ah, looks like just FOL and Curry–Howard?
11:35:34 <BeardedCoder> johnw: k ty, I think I understand. Let me go code it up
11:36:04 <johnw> BeardedCoder: essentially isolate lets you "focus" on a subrange of the incoming stream
11:36:51 <johnw> I think for what you want to do, you'll need to code an explicitly recursive monadic loop; I'm unaware of a conduit that turns a sink into a cycled sink
11:39:04 <orzo> i have an operation f a b where f :: m x -> m x -> m (x, m x) and is either fmap (,b) a  or fmap (,b) a depending on which of those finishes faster.  What's a good name for that?
11:39:27 <orzo> i'm sorry, fmap (,b) a  or  fmap (,a) b
11:40:22 <tommd> orzo: This is like 'concurrently' then?
11:40:25 <Twey> orzo: It's called ‘unamb’
11:40:39 <Twey> … if they are actually the same thing
11:41:59 <johnw> BeardedCoder: https://gist.github.com/552c3d2de820fa445208
11:42:05 <johnw> so, that does what you want, but needs improving
11:42:13 <johnw> takeExactlyC is the new name for isolate
11:43:06 <BeardedCoder> johnw: Can you check that link for the gist. not working for me
11:43:31 <johnw> https://gist.github.com/39e529b7bdb42307e9ae
11:43:44 <BeardedCoder> johnw: ty
11:44:07 <johnw> note that this proceeds by *chunks* not by *elements*
11:44:17 <johnw> for elements, just switch to takeExactlyCE
11:45:47 <BeardedCoder> johnw: What version of Conduit are you using?
11:45:52 <johnw> 1.1.x
11:46:01 <johnw> with "import Conduit"
11:48:11 <cow_2001> why don't we have something like that yet? http://armyofrobots.herokuapp.com
11:48:40 <johnw> maybe because no one has written it yet?
11:48:54 <Zekka> cow_2001: It's speaking Hebrew at me, is there an ENglish mode?
11:49:37 <cow_2001> johnw: :D
11:49:46 <path[l]> Hi, I’d like some help. I’ve been playing around with quickcheck and now I have a working test that correctly identified a bug in my code. It uses a custom generator, but it doesnt shrink well. How do I implement shrink for a custom generator
11:49:46 <cow_2001> Zekka: huhm
11:50:05 <BeardedCoder> johnw: I'm not finding yieldMany or takeExactlyC ?
11:50:13 <Zekka> A while back I considered writing a Haskell game that made you play horse with types
11:50:41 <johnw> BeardedCoder: ah, I'm sorry, they are in conduit-combinators
11:50:42 <Zekka> so, someone constructs a value of a really gnarly type and then the list of functions they used gets sent to someone else, and that person has to construct the same type, and then another one
11:50:48 <BeardedCoder> johnw: k ty
11:50:53 <cow_2001> Zekka: of course my horse :|
11:50:53 <johnw> conduit split itself into 3 libraries in 1.1
11:50:59 <Zekka> repeating until one of them can't figure out how to construct the other's type
11:51:13 <cow_2001> Zekka: a horse that talks of course of course
11:51:17 <cow_2001> Zekka: with morse?
11:54:06 <allsystemsarego> Code: http://lpaste.net/105810 - this waits a while and then prints "thread blocked indefinitely in an MVar operation", any ideas?
11:56:35 <pavonia> allsystemsarego: You don't release the MVars in the second fork
11:56:46 <allsystemsarego> oh, let me look
11:56:53 <johnw> what pavonia said
11:57:05 <cow_2001> wow this channel is fast as hell
11:57:55 <flebron> path[l]: Shrink should return a list of instances that are in some way "smaller" than the one you're given.
11:58:00 <allsystemsarego> so I need a "putMVar integercountmvar integercount" in the second fork too?
11:58:07 <hexagoxel> allsystemsarego: and in the "third fork"
11:58:14 <hexagoxel> which is no fork :D
11:58:24 <johnw> allsystemsarego: each thread, if it takes the MVar, needs to restore it.  Better is to always use modifyMVar whenever possible
11:58:42 <Para_> when you have the choice, should you use foldl or foldr? (if both work?) Is one considered better than the other?
11:58:43 <allsystemsarego> oh I see
11:58:51 <allsystemsarego> thanks guys
11:59:04 <flebron> For example, if you're generating lists of random numbers, then a shrink of a list xs could be every prefix of xs, or every sublist of length (length xs - 1), or the like.
11:59:09 <johnw> foldr if you want laziness, foldl' if you do not
11:59:25 <Para_> should you ever do foldl without the '?
11:59:25 <flebron> The purpose of shrink is to give you "minimal" test cases, once you've found a failing one for a property.
11:59:34 <johnw> Para_: almost never, and not even then
11:59:54 <Para_> is there a particular reason for that?
12:00:13 <Para_> (Sorry if this is a stupid question -- I've recently started learning haskell)
12:00:17 <napping> foldl uses an accumulator so it doesn't return anything until the end of the list
12:00:21 <jomg> Para_: space efficiency
12:00:30 <napping> but it's lazy in the accumulator, so it just builds up a big unevaluated expression and returns that
12:00:40 <Para_> doesn't foldr also use accumulator?
12:01:00 <johnw> foldl can be useful in cases where you need a foldl that has to succeed in the presence of undefined values
12:01:00 <napping> nope
12:01:04 <johnw> see http://www.haskell.org/haskellwiki/Foldr_Foldl_Foldl'
12:01:04 <flebron> @src foldr
12:01:04 <lambdabot> foldr f z []     = z
12:01:04 <lambdabot> foldr f z (x:xs) = f x (foldr f z xs)
12:01:19 <napping> so if f is lazy, maybe it can give you a result without even needing the rest of the list
12:01:21 <flebron> So foldr just builds a recursive application of f, over and over.
12:01:27 <JordiGH> Apparently I don't have Control.IO? Is that because my ghc is too old?
12:01:29 <napping> > foldr (&&) [False, error "oops"]
12:01:30 <lambdabot>  Couldn't match expected type ‘GHC.Types.Bool’
12:01:30 <lambdabot>              with actual type ‘[GHC.Types.Bool]’
12:01:39 <napping> > foldr (&&) False [False, error "oops"]
12:01:41 <lambdabot>  False
12:01:48 <flebron> JordiGH: Should be System.IO shouldn't it?
12:01:49 <jomg> JordiGH: i think it's System.IO
12:01:51 <jomg> yea
12:01:57 <napping> foldl can never run in constant memory
12:02:08 <johnw> foldl takes an "accumulator" and an element; foldr takes an element, and a thunk which evaluates to the result of applying foldr to the remainder of the list
12:02:09 <wz1000> > foldl (&&) [False, error "oops"]
12:02:11 <lambdabot>  Couldn't match expected type ‘GHC.Types.Bool’
12:02:11 <lambdabot>              with actual type ‘[GHC.Types.Bool]’
12:02:20 <wz1000> > foldl (&&) False [False, error "oops"]
12:02:22 <lambdabot>  False
12:02:24 <napping> foldl' forces evaluation as it goes, so maybe the accumulator can stay small
12:02:25 <Para_> hmmm ok
12:02:49 <Para_> thanks
12:02:53 <wz1000> > foldl (&&) True  [False, error "oops"]
12:02:55 <lambdabot>  False
12:02:57 <napping> It's only ever sorta kinda useful if your function is lazy but you somehow want to be sure you apply it to all the list values
12:03:07 <napping> and even then I don't know why you wouldn't just use foldr
12:03:32 <johnw> in all my days I've never used foldl once, if that means anything
12:03:38 <Para_> if you have a non-associative function though, then perhaps you might want foldl?
12:03:46 <johnw> and everywhere that I've seen others use it so far, it has always been wrong
12:03:58 <notdan> foldl' also does not explode in your face like foldl
12:04:06 <Para_> or would you just do reverse foldr
12:04:11 <notdan> because foldl will eat a lot of memory on big lists
12:04:12 <Para_> orI meant
12:04:12 <johnw> but I'm sure you can come up with cases involving _|_ where it is the only solution to a specicially crafted problem
12:04:16 <Para_> foldr . reverse
12:04:25 <Para_> hmmm okay
12:04:31 <Para_> alright thanks
12:04:34 <c_wraith> actually, reverse is one of the few cases where the difference between foldl and foldl' isn't relevant
12:04:43 <c_wraith> @src reverse
12:04:43 <Para_> (I was about to write a foldl, but I'm switching it to a foldr now!)
12:04:44 <lambdabot> reverse = foldl (flip (:)) []
12:04:57 <notdan> <http://www.well-typed.com/blog/90/> The foldl function is broken. Everyone knows it’s broken. It’s been broken for nearly a quarter of a century. We should finally fix it!
12:05:07 <flebron> You're building the result list anyway, and it'll always be a bunch of thuns.
12:05:11 <flebron> *thunks
12:05:12 <johnw> Para_: plus, you can implement foldl using foldr, and nont vice-versa, so that you should tell you that foldl is never strictly necessary
12:05:29 <flebron> The ' is useful when you can reduce the bunch of thunks to a smaller thing at each step.
12:05:37 <johnw> Para_: switch it to foldl' unless you know you want laziness
12:05:48 <JordiGH> Oh, looks like I was copying bad code (which has since been fixed)
12:06:03 <Para_> alright, thanks!
12:06:07 <Para_> while we're on the topic of broken functions
12:06:11 <Para_> are there any other ones I should avoid?
12:06:47 <notdan> Para_: fromJust, I would say
12:07:00 <flebron> Not because there's an alternative, but because it's unstylish.
12:07:01 <Para_> fromJust should be fromMaybe?
12:07:08 <Para_> oh okay
12:07:09 <flebron> And it means you're not using the typesystem correctly.
12:07:18 <flebron> It means "I know this thing is a Just, but I can't prove it to the compiler."
12:07:34 <jomg> Para_: probably partial functions in general, unless you're sure they won't fail
12:07:36 <flebron> Same with other partial functions. You can use them, but it'd be better if you could prove these things to the compiler.
12:07:50 <flebron> a "head" will cause a runtime error when given the empty list. We like to avoid runtime errors.
12:08:57 <flebron> For example, given a x :: Maybe Foo, if you want to handle x, you should do it through either Maybe as a monad, or Applicative, or Functor, or some other typeclass, and not "looking inside it" and assuming you'll get a Just.
12:09:03 <glosoli>  What's the most popular way to deal with concurrency in Haskell ?
12:09:08 <glosoli> some sort of community de facto thing
12:09:16 <Para_> alright, sounds good
12:09:19 <Para_> thanks!
12:09:23 <flebron> That's why the "maybe" function exists: maybe x f b will apply f to the inner "Just" value if x is a Just, or return b if it's a Nothing.
12:09:33 <flebron> :t maybe
12:09:34 <lambdabot> b -> (a -> b) -> Maybe a -> b
12:09:42 <flebron> *maybe b f x :)
12:10:19 <asmyers> glosoli: http://chimera.labs.oreilly.com/books/1230000000929/index.html
12:10:27 <flebron> glosoli: Simon Marlow's Control.Concurrent.Async is pretty popular.
12:10:51 <flebron> (It doesn't hurt he's considered a demigod in terms of haskell concurrency, and literally "wrote the book" about it.)
12:11:14 <glosoli> flebron: aaa ok thanks sir
12:11:54 <Para_> is there an way to check if something is a subtype of something else? (i.e. how could I check if String is part of Ord)?
12:12:20 <Iceland_jack> Para_: you can use
12:12:20 <Iceland_jack>     ghci> :i Ord
12:12:22 <armlesshobo> @src String
12:12:22 <lambdabot> type String = [Char]
12:12:25 <armlesshobo> hmm
12:12:25 <Iceland_jack> or
12:12:25 <Iceland_jack>     ghci> :i String
12:12:38 <armlesshobo> @info String
12:12:38 <lambdabot> String
12:12:41 <armlesshobo> lol
12:12:43 <armlesshobo> ty l0cust
12:12:45 <armlesshobo> err
12:12:48 <armlesshobo> ty lambdabot
12:13:22 <Para_> ty lambdabot
12:13:47 <Iceland_jack> well, :i String is not quite the way to go but
12:13:47 <Iceland_jack>     ghci> :i Ord
12:13:47 <Iceland_jack> is :)
12:13:56 <gilligan_> I give up - does anyone here use hoogle with a database of all packages (hoogle data all) ? I can't get that to work.
12:15:28 <Para_> Iceland_jack -- one more question: I have this code snipped form LYAH:
12:15:32 <Para_> fromList' :: (Ord k) => [(k,v)] -> Map.Map k v
12:15:34 <Para_>   fromList' = foldr (\(k,v) acc -> Map.insert k v acc) Map.empty
12:15:54 <Para_> I'm somewhat confused about the lambda function
12:16:05 <Iceland_jack> Para_: is it the (k, v) part?
12:16:07 <Para_> isn't \(k, v) acc the wrong order because Map.empty is the accumulator
12:16:15 <Para_> and if we were to do fromList xs
12:16:25 <Para_> or add points
12:16:31 <Iceland_jack> well 'foldr' is operating on a list of pairs
12:16:36 <Para_> it would become fromList' xs = ... Map.empty xs
12:16:48 <Para_> :t foldr
12:16:49 <Iceland_jack> that's right
12:16:49 <lambdabot> (a -> b -> b) -> b -> [a] -> b
12:16:57 <Iceland_jack> :t foldr (\(k, v) -> undefined)
12:16:58 <lambdabot> b -> [(t, t1)] -> b
12:17:02 <Para_> oh ok
12:17:17 <Iceland_jack> :t foldr (\(k, v) -> undefined) M.empty
12:17:18 <lambdabot> [(t, t1)] -> M.Map k a
12:17:23 <Iceland_jack> which is just what you'd expect
12:17:39 <Para_> :t foldr (\(k, v) acc -> undefined) []
12:17:40 <lambdabot> [(t, t1)] -> [t2]
12:17:51 <Para_> hmm okay
12:17:54 <Para_> that makes sense
12:18:04 <Iceland_jack> > foldr (\(k, v) acc -> M.insert k v acc) M.empty [(1, "one"), (2, "two")]
12:18:04 <Para_> just making sure I'm not going crazy
12:18:05 <lambdabot>  fromList [(1,"one"),(2,"two")]
12:18:25 <Iceland_jack> you can also reverse it with
12:18:25 <Iceland_jack> > foldr (\(k, v) acc -> M.insert v k acc) M.empty [(1, "one"), (2, "two")]
12:18:27 <lambdabot>  fromList [("one",1),("two",2)]
12:18:41 <Krakarn> > round (0/0)
12:18:42 <lambdabot>  -269653970229347386159395778618353710042696546841345985910145121736599013708...
12:18:50 <Para_> got it
12:18:51 <Para_> sweet
12:18:57 <Iceland_jack> or omit the 'acc' parameter
12:18:57 <Para_> time to read more of it!
12:19:02 <Iceland_jack> :)
12:19:05 <Para_> wait you can omit the acc parameter?
12:19:12 <Iceland_jack> Para_: sure
12:19:21 <flebron> >id id id id id id id id id id id id id id id id id id id id id id id 42
12:19:22 <Iceland_jack> > foldr (\(k, v) -> M.insert k v) M.empty [(1, "one"), (2, "two")]
12:19:23 <lambdabot>  fromList [(1,"one"),(2,"two")]
12:19:24 <Para_> :t foldr (\(k, v) -> undefined) []
12:19:25 <lambdabot> [(t, t1)] -> [t2]
12:19:33 <flebron> > id id id id id id id id id id id id id id id id id id id id id id id 42
12:19:37 <lambdabot>  mueval-core: Time limit exceeded
12:19:39 <Para_> so whats the point of adding it then?
12:19:44 <Iceland_jack> clarity
12:19:50 <jle`> poor lambdabot
12:20:01 <jle`> what a thankless job
12:20:04 <Iceland_jack> Para_: if you have
12:20:04 <Iceland_jack>     (\f x -> (...) x)
12:20:04 <Iceland_jack> you can remove the 'x' (called eta-conversion)
12:20:05 <Para_> :t Map.insert
12:20:06 <lambdabot>     Not in scope: ‘Map.insert’
12:20:07 <lambdabot>     Perhaps you meant one of these:
12:20:07 <lambdabot>       ‘M.insert’ (imported from Data.Map),
12:20:10 <Iceland_jack> :t M.insert
12:20:11 <flebron> !botsnack
12:20:11 <lambdabot> Ord k => k -> a -> M.Map k a -> M.Map k a
12:20:22 <Para_> !botsnack
12:20:27 <Para_> I <3 lambdabot
12:20:32 <Para_> but hm ok
12:20:44 <Iceland_jack> Para_: like if you're defining
12:20:44 <Iceland_jack>     plus x y = (+) x y
12:20:47 <jle`> lambdabot++
12:20:50 <flebron> @botsnack
12:20:51 <lambdabot> :)
12:20:55 <jle`> @karma lambdabot
12:20:55 <lambdabot> lambdabot has a karma of 26
12:20:56 <Iceland_jack> you can also write it as
12:20:56 <Iceland_jack>     plus x = (+) x
12:20:56 <Iceland_jack> or
12:20:59 <Iceland_jack>     plus = (+)
12:21:12 <Para_> yeah
12:21:23 <Para_> oh okay
12:21:24 <Iceland_jack> that also works for anonymous functions
12:21:26 <Para_> so its just currying
12:21:29 <Para_> okay
12:21:30 <Para_> sweet
12:21:38 <jle`> not quite currying
12:21:41 <Para_> wait
12:21:42 <Iceland_jack> not currying, but it's possible because of currying
12:21:43 <jle`> but ok
12:21:44 <Para_> partial application
12:21:44 <flebron> It tends to be idiomatic, Para_. You can usually "cancel out" the parameters.
12:21:45 <Para_> *
12:21:50 <armlesshobo> :t curry
12:21:51 <lambdabot> ((a, b) -> c) -> a -> b -> c
12:22:18 <Para_> but thats valid with anonymous functions too - awesome.
12:22:19 <Para_> thanks
12:22:21 <flebron> Haskellers tend to write a relatively "pointfree" style, which means using as few bound variables as possible.
12:22:31 <armlesshobo> plus = \x y -> x + y
12:22:42 <flebron> For example, telling you that f x y z = g x y z is "noisier" than telling you that f = g.
12:23:11 <Para_> yeah
12:23:20 <Krakarn> > round (1/0)
12:23:22 <lambdabot>  1797693134862315907729305190789024733617976978942306572734300811577326758055...
12:23:30 <Para_> alright solid
12:23:35 <Para_> @botsnack
12:23:36 <lambdabot> :)
12:23:37 <armlesshobo> Krakarn: give or take a couple magnitudes
12:23:38 <armlesshobo> :P
12:23:46 <Para_> @karma lambdabot
12:23:47 <lambdabot> lambdabot has a karma of 26
12:23:50 <Para_> lambdabot++
12:23:54 <Para_> @karma lambdabot
12:23:54 <lambdabot> lambdabot has a karma of 27
12:23:57 <Para_> :D
12:23:57 <armlesshobo> lambdabot++
12:24:14 <armlesshobo> :t Just
12:24:14 <Para_> uhoh
12:24:15 <lambdabot> a -> Maybe a
12:24:19 <armlesshobo> lambdabot++
12:24:21 <Para_> I think I'm starting to treat lambdabot like a real person
12:24:27 <jle`> she isn't?
12:24:53 <armlesshobo> lambdabot: are you real?
12:25:02 <Iceland_jack> lambdabot never shows up to my parties
12:25:06 <armlesshobo> see, ignoring me like a normal person would
12:25:11 <Para_> haha
12:25:18 <Krakarn> armlesshobo: ;)
12:25:40 <Para_> @botsnack
12:25:40 <lambdabot> :)
12:25:43 <Para_> awww
12:25:44 <Iceland_jack> armlesshobo: so you're saying that saying nothing = passing the Turing test :)
12:25:59 <armlesshobo> Iceland_jack: haha
12:26:07 <armlesshobo> Iceland_jack: it passes *my* Turing test
12:26:08 <Para_> it smiles if you feed it! (or him/her, I don't know lambdabot's gender)
12:26:12 <Iceland_jack> “par for the course”
12:26:20 <Para_> unfortunately none of us pass armlesshobo?
12:26:30 <mendio> Hello, i'm an it student (2nd year) and i'm learning haskell for fun since today. First time doing functionnal programming so I have some difficulties. So, I'm trying to do a "ls" clone, I managed to get a list containing all file and dir as strings but I can't sort the alphabetically, I tried with "sort" from Data.List but I can't figure out the right syntax to even compile, any tips?
12:26:31 <armlesshobo> Para_: you're all evil robots
12:26:39 <armlesshobo> trying to eat my brain
12:27:00 <Para_> what do you have so far mendio?
12:27:06 <Iceland_jack> mendio: if you have 'getDirectoryContents "."' you can fmap sort over it
12:27:09 <Iceland_jack> > getDirectoryContents "."
12:27:10 <lambdabot>  Not in scope: ‘getDirectoryContents’
12:27:18 <Para_> and no I'm not!
12:27:19 <Para_> yet
12:27:23 <Iceland_jack> :t System.Directory.getDirectoryContents "."
12:27:24 <lambdabot> IO [FilePath]
12:27:28 <Iceland_jack> :t fmap sort (System.Directory.getDirectoryContents ".")
12:27:28 <mendio> 				d <- getCurrentDirectory 				dc <- getDirectoryContents d 				mapM_ putStrLn dc
12:27:29 <lambdabot> IO [FilePath]
12:27:52 <mendio> Can I past nice formated code here ?
12:27:59 <Iceland_jack> mendio: you use lpaste
12:28:00 <Iceland_jack> @lpaste
12:28:00 <lambdabot> Haskell pastebin: http://lpaste.net/
12:28:00 <armlesshobo> mendio: use lpaste.org
12:28:05 <Para_> use lpaste in the bar at the top
12:28:12 <armlesshobo> err, lpase.net
12:28:33 <Para_> @botsnack
12:28:33 <lambdabot> :)
12:29:23 <mendio> Ok, so I have this http://lpaste.net/105812
12:29:30 <mendio> just printing the dir content
12:30:00 <Iceland_jack> mendio: okay, and you want to sort it first?
12:30:23 <Iceland_jack> just replace the final 'dc' with '(sort dc)'
12:32:33 <joseph07> My first language was C, then I learned Java, then Haskell, then some Python. I was thinking I should dedicate some time to learning a dynamically typed language (ala lisp or python). Any recommendations for where I should go next?
12:33:04 <joseph07> (I use Java for work)
12:33:19 <hc> erlang? ;}
12:33:34 <mendio> Thanks, it worked. Parentheses are very important I guess aha. I have a long way to go, from C / C++ to haskell
12:33:42 <platz> joseph07: there seem to be a lot of haskellers that use clojure
12:33:52 <genisage> bancstar
12:33:53 <napping> anybody got a Haskell dependency injection framework?
12:34:11 <napping> well, some kind of type indexed way of wiring a bunch of functions together
12:34:24 <bitemyapp> napping: ?
12:34:37 <bitemyapp> napping: do you mean argument passing and typeclasses or something else? What's type-indexed in this case?
12:34:47 * herrwolfe45
12:35:07 <napping> well basically to take a pile of functions that compute various results, and need various inputs
12:35:14 <napping> and hooking enough up to make the answer you want
12:35:19 <napping> assuming all the inputs and output are Typeable
12:35:23 <joseph07> platz: clojure also has the benefit of being jvm language that is occassionally used at work
12:35:45 <joseph07> hc: I don't know much about erlang except messages
12:35:57 <napping> And maybe getting fancy with an applicative having a get :: (Typeable t) => Computes t function
12:36:06 <hc> you said you wanted something dynamic, that's the first one that came to mind
12:36:26 <hc> s/dynamic/dynamically typed/
12:36:47 <napping> then given a [exists t . (Typeable t) => Computes t] something could automatically compute the dependency graph and stuff
12:37:00 <hc> erlang messages work a bit like haskell channels
12:37:02 <mendio> By the way, is this a good "guide" http://learnyouahaskell.com/chapters (if you knwo it) and do you have  advices to go from imperative to functionnal programming ?
12:37:50 <Iceland_jack> mendio: LYAH is a good place to start
12:37:54 <allsystemsarego> Code: http://lpaste.net/105813 - this only updates the screen when I hit a key, not every second, any ideas?
12:38:01 <bitemyapp> mendio: https://github.com/bitemyapp/learnhaskell
12:38:18 <bitemyapp> mendio: I prefer Yorgey's cis194 but LYAH and RWH are both excellent supplementary resources.
12:38:38 <platz> napping: There tends to be less of an emphasis on frameworks for DI in FP.  Partly because you don't have OO ctors and can just use currying and function composition.  Also things like DI's idea of a Service Locator isn't popular because you don't want a global state-blog  providing dependancies throughout your system - not functional
12:38:49 <platz> blob
12:42:39 <platz> a full-featured OO DI tool also  holds and manages the lifetimes of the objects it creates - so it's a nest of state.  You can model it directly in FP, but FP tends to pushe to make flows of data more explicit, not less explicit, even if it sometimes involves more code
12:43:33 <napping> well, I don't want quite that much. I described what I have in mind
12:43:37 <gilligan_> is anyone here able to combine all hoogle databases from "hoogle data all" into a single default.hoo using "hoogle combine" ?
12:43:57 <joseph07> genisage: 8607,,,1
12:44:07 <joseph07> genisage: I was paying attention
12:46:13 * hackagebot ratio-int 0.1.2 - Fast specialisation of Data.Ratio for Int.  http://hackage.haskell.org/package/ratio-int-0.1.2 (RaphaelJavaux)
12:46:15 <jle`> mendio: my best advice is to just try to forget everything you know about programming
12:47:20 <jle`> mendio: there are some bits here and there that will help you, but a lot of what you know and your intuition is actually going to make learning functional programming more frustrating, "unintuitive", and difficult to process, i think
12:47:42 <jle`> it's not that functional programming is inherently frustrating, but when you try to apply intuitiotns and things you learned from your imperative backgrounds, you will run into your own frustration
12:47:53 <jle`> which would never have existed if you didn't know programming before in the first place :)
12:53:33 <d3m1g0d-> do you guys believe in the death of the imperative programming languages ?
12:53:36 <d3m1g0d-> is that a thing ?
12:54:32 <genisage> joseph07: I wish you the best in your new career as a bancstar guru.
12:56:13 * hackagebot app-settings 0.2.0.2 - A library to manage application settings (INI file-like)  http://hackage.haskell.org/package/app-settings-0.2.0.2 (EmmanuelTouzery)
12:56:29 <hexagoxel> let b="let b=; (c,d)=splitAt 6 b in putStrLn $ c++show b++d"; (c,d)=splitAt 6 b in putStrLn $ c++show b++d
12:58:01 <tolt> d3m1g0d-: Not the death.
12:58:42 <tolt> d3m1g0d-: Would you want to get rid of oranges even if you liked apples and though apples were better to eat?
13:00:30 <hexagoxel> and if you have a foreign fruit interface to oranges
13:02:00 <psps> hello! i'm pretty new to haskell and i'd like to play around with real time audio synthesis. anyone here with recommendations how to do it?
13:02:35 <genisage> hexagoxel: clever
13:05:07 <Darwin_> Hey guys, I have a question about haskell function naming convention. Should I use verbs in the names or not? For example, should my function be "makeEmptyMap" or "emptyMap"? Should I use "getTile" or just "tile"? If just "tile", what would be the equivalent for "setTile"?
13:05:23 <slomo> if i have a type "data R = R {x :: Int} | RS { rs :: [R]}", and i now have a list of these things. how do i pattern match on it? basically i want to match on [R {x=blablabla}:_] and [_:rs] so i can go through the list until the first non-RS value is there
13:05:50 <gamegoblin> Darwin: Is emptyMap a constant or a function?
13:06:02 <Darwin_> gamegoblin: It's a function
13:06:36 <gamegoblin> @pl \(x,y) -> (x+1,y)
13:06:36 <lambdabot> first (1 +)
13:06:47 <genisage> Darwin_: "makeEmptyMap" and "emptyMap" both have verbs.
13:07:09 <Darwin_> genisage: I meant empty as an adjective
13:07:12 <marchelzo_> is there a way to make hoogle only show functions with the exact type signature that you search for?
13:07:27 <genisage> Darwin_: I figured xp, just being nitpicky
13:08:11 <gamegoblin> And techincally “map” can be a verb, too ;)
13:08:21 <gamegoblin> You’re all verbs!
13:08:30 <bvad> Hello there, I'm pretty new at Haskell and was wondering if there's a simple way to serialize data types which are just composites of Word{8,16,32} into bytestrings?
13:08:42 <Darwin_> gamegoblin: You're right! I could see makeEmptyMap = make . empty . map happening
13:09:31 <marchelzo_> @src splitOn
13:09:31 <lambdabot> Source not found. Maybe if you used more than just two fingers...
13:09:39 <pmade> bvad: https://hackage.haskell.org/package/bytestring-0.10.2.0/docs/Data-ByteString-Builder.html
13:09:50 <gamegoblin> bvad: do you mean you have datatypes that are just wrappers around a few Word{8,16,22}? Like data Stuff = Stuff Word8 Word16 ?
13:10:20 <bvad> gamegoblin: exactly.. pmade, I'll look into it
13:10:41 <hexagoxel> psps: what kind of interface are you looking for? i currently use the alsa bindings for (low-level) sound output
13:11:25 <gamegoblin> bvad: so all of the WordX’s are already instances of serialize (http://hackage.haskell.org/package/cereal-0.3.0.0/docs/Data-Serialize.html), so you can make your type an instance of serialize pretty easily
13:11:53 <bvad> gamegoblin: Aaahh, of course!
13:12:48 <gamegoblin> bvad: bytestring has it’s own `concat` function which is [ByteString] -> ByteString, so you can do `encode (Stuff a b c) = concatMap encode [a,b,c]`
13:12:51 <gamegoblin> Done!
13:13:16 <marchelzo_> When I try to import Data.List.Split it say i haven't installed the "dyn" libraries for package 'split-0.2.2'. How do I install the dyn libraries?
13:13:40 <gamegoblin> bvad: actually change that concatMap to concat (map encode [a,b,c]), but same idea
13:13:41 <user`> what the association in : " [1..50] >>= (\x -> guard ('7' `elem` show x) >> return x)   "
13:14:35 <Iceland_jack> user`: association of what exactly?
13:14:55 <Iceland_jack> > [1..50] >>= (\x -> guard ('7' `elem` show x) >> return x)
13:14:57 <lambdabot>  [7,17,27,37,47]
13:15:00 <bvad> gamegoblin: Thanks a bunch, very helpful
13:15:19 <user`> I see all these functions >>= -> >> what the order?
13:16:22 <user`>  is it  [1..50] >>= (\x -> (guard ('7' `elem` show x) >> return x))
13:16:39 <vanila> \x -> _   is a lambda abstraction
13:17:16 <vanila> it's a function with x as the parameter
13:17:59 <quchen> user`: Lambdas are special syntax. You can imagine them ranging up as far to the right as possible.
13:18:15 <augur> is there an name for the problem of finding the closest matching run of text inside a document?
13:18:33 <quchen> augur: Fuzzy matching?
13:18:37 <user`> crashed
13:18:50 <quchen> augur: Maybe not fuzzy matching directly, but the problem sounds related.
13:18:52 <gamegoblin> augur: define closest
13:18:59 <user`> what was the answer to  [1..50] >>= (\x -> guard ('7' `elem` show x) >> return x)
13:19:01 <augur> quchen: ahh yes that sounds about right
13:19:34 <augur> quchen: fuzzy string searching is indeed the problem!
13:19:41 <user`> is it:  [1..50] >>= (\x -> ( guard ('7' `elem` show x) >> return x))
13:19:59 <Iceland_jack> user`: yes
13:20:06 <Iceland_jack> > [1..50] >>= (\x -> guard ('7' `elem` show x) >> return x)
13:20:07 <lambdabot>  [7,17,27,37,47]
13:20:08 <Iceland_jack> > [1..50] >>= (\x -> (guard ('7' `elem` show x) >> return x))
13:20:10 <lambdabot>  [7,17,27,37,47]
13:20:41 <user`> > ([1..50] >>= (\x -> guard ('7' `elem` show x)) >> return x)
13:20:43 <lambdabot>  [x,x,x,x,x]
13:21:04 <user`> ok
13:21:14 <Iceland_jack> a possibly nicer way of writing it is
13:21:14 <Iceland_jack> > [ x | x <- [1..50], '7' `elem` show x ]
13:21:15 <lambdabot>  [7,17,27,37,47]
13:22:06 <user`> > [1..50] >>= (\x -> (guard ('7' `elem` show x)) >> return x))
13:22:08 <lambdabot>  <hint>:1:60: parse error on input ‘)’
13:22:22 <user`> > [1..50] >>= (\x -> (guard ('7' `elem` show x) >> return x))
13:22:24 <lambdabot>  [7,17,27,37,47]
13:23:35 <gamegoblin> Man, I thought I was super smart for inventing a monad operator called “assert” but it turns out it already exists as “guard” in monadplus T_T
13:23:37 <quchen> user`: Similarly, "::" is special syntax that ranges as far as it can in both directions. "foo bar :: Maybe Int" means "(foo bar) :: (Maybe Int)", and not "foo (bar :: Maybe) Int" or something.
13:24:29 <napping> Does anything relate eqT :: Maybe (a :~: b) and the order on TypeRep?
13:25:00 <user`> I get confused about what the functions parameters are
13:25:24 <Iceland_jack> user`: maybe you should start with simpler examples
13:26:01 <user`> If I go back to read first chapters of lyh I will fall asleep
13:26:24 <user`> maybe there is a summary of the rules?
13:26:36 * Iceland_jack . o O ( there is no royal road to Haskell )
13:26:45 <Iceland_jack> you can try some video lectures
13:26:52 <Iceland_jack> from Chalmers, they're quite good
13:27:08 <user`> link?
13:27:18 <Iceland_jack> http://www.cse.chalmers.se/edu/year/2013/course/TDA452/FPLectures/Vid/
13:27:23 <gamegoblin> I tried learning haskell about 3 times before it truly stuck and made sense
13:27:40 <Iceland_jack> user`: to get the most out of those lectures, make sure to use the QuickCheck examples
13:27:42 <quchen> I used excessive parentheses in the beginning and then learned when they're redundant. Similarly, I used do notation everywhere and learned to refactor it. Both of these involve me and doing things, not reading about them.
13:28:02 <gamegoblin> quchen: for me, I used excessive $ everywhere
13:28:14 <quchen> Oh yeah and that
13:28:23 <gamegoblin> Evvvveeeerrryyyywhere
13:28:23 <quchen> My Haskell dark ages ;-)
13:28:28 <user`> Iceland_jack: what?
13:28:42 <Iceland_jack> user`: QuickCheck is a Haskell library
13:29:02 <Iceland_jack> for (property-based) testing
13:29:38 <user`> Iceland_jack I don't have a clue
13:30:19 <davd> how would you parse the time "tonigh 9/8C"?
13:30:36 <davd> s/tonigh/tonight/
13:31:11 <l0cust> davd: "tonight" maps to a date
13:31:25 <quchen> What kind of a time format is that? :-x
13:31:26 <l0cust> "9/8" maps to hours (presumably modulo 12
13:31:28 <user`> what I understand so far about haskell, is that it have this pattern matching against types, and then someone decided to call everything with confusing names
13:31:46 <l0cust> davd: something like
13:31:52 <davd> quchen: crazy americans
13:31:53 <Iceland_jack> user`: watch the videos
13:31:55 <l0cust> >words "tonight 9/8c"
13:32:06 <l0cust> > words "tonight 9/8c"
13:32:08 <lambdabot>  ["tonight","9/8c"]
13:32:10 <l0cust> there we go
13:32:15 <davd> right
13:32:15 <quchen> user`: You match type constructors, not types. "Maybe Int" is a type, "Just 1" is a value constructed using "Just".
13:32:23 <quchen> Eh
13:32:29 <quchen> Data constructors, not type constructors ^^^
13:32:43 <davd> l0cust: maybe c is central time?
13:32:48 <l0cust> let [day, time] = words "Tonight 9/8C"
13:32:54 <l0cust> davd: ah, I thought that was well known
13:32:56 <l0cust> no, it's weird
13:33:01 <quchen> What is 9/8C?
13:33:02 <l0cust> (I live in mountain tine)
13:33:06 <davd> I have no idea
13:33:19 <l0cust> The show plays at 9:00 PM in Central Time, and 8:00 PM in Mountain time
13:33:27 <Lutin`> It's 9 EST, 8 CST
13:33:29 <davd> ah, great
13:33:35 <l0cust> Lutin`: not here, it isn't
13:33:35 <Lutin`> I thought
13:33:40 <davd> l0cust: awesome, thanks.
13:33:50 <l0cust> oh, you know what
13:33:52 <Lutin`> They say 8C to mean 8 Central though
13:33:58 <l0cust> Yes
13:34:04 <Lutin`> So it's 9 eastern
13:34:07 <l0cust> It's pronounced "nine eight central"
13:34:16 <l0cust> That's what it should be
13:34:26 <Lutin`> I hear it all the time on TV lol
13:35:19 <l0cust> http://forum.wordreference.com/showthread.php?t=76009
13:36:28 <l0cust> Yeah
13:36:28 <flebron> Tangentially related question. I'm trying to understand Wadler's "Theorems for free." I can do the derivations syntactically, but I'm not entirely sure what these relations are supposed to be. I assign "types" the semantics "sets of values". What semantics can I assign these relations between types? What about relations between relations?
13:36:32 <l0cust> I think it's different in Mountain time
13:36:42 <l0cust> Who knows
13:36:45 <l0cust> Utah is weird
13:36:58 <l0cust> oh oh oh
13:37:01 <l0cust> davd:
13:37:02 <l0cust> okay
13:37:03 <l0cust> I got it
13:37:23 <l0cust> davd: it's 9:00 in Eastern *Standard* Time, 8:00 in Central *Standard* Time
13:37:45 <l0cust> davd: which is the same as 9:00 in Central *Daylight* Time, and 8:00 in Mountain Daylight Time
13:37:51 <eyebloom> I’m trying to define a type Scalar d s = Float where the type parameters d and s refer for example to the dimension that the value refers to and the coordinate system so that I can create a data constructor data Coord s = Coord (Scalar XDimension s) (Scalar YDimension s), where XDimension and YDimension are arbitrary types. I’m doing this to prevent accidentally mixing dimensions or coordinate systems without explicitly
13:37:51 <eyebloom> doing so. I’m wondering what would be the best way to define Scalar and the other types so that I can use it on all contexts that I would use a Float but I can’t mix values without explicitly doing so?
13:38:11 <kini> is there ever a reason to write a function of type Monad m => A -> m B ?
13:38:23 <l0cust> well yes
13:38:26 <kini> it seems like the only thing it can possibly be is some function of type A -> B composed with return
13:38:35 <l0cust> :t print
13:38:36 <lambdabot> Show a => a -> IO ()
13:38:44 <kini> that's not of type Monad m => A -> m B
13:38:44 <l0cust> in that case
13:38:51 <l0cust> yes it is
13:39:02 <l0cust> Monad m :: a -> m b
13:39:07 <l0cust> m happens to be IO
13:39:14 <kini> no no
13:39:15 <l0cust> do you mean A and B as typeclasses?
13:39:18 <kini> let me be more explicit
13:39:25 <kini> type forall m . Monad m => A -> m B
13:39:45 <davd> l0cust: oh, time is weirder than I thought. thanks for clearing that up.
13:40:08 <davd> CAPITALS denote constructors btw
13:40:20 <l0cust> kini Ah I got that
13:40:30 <davd> oh, sorry.
13:40:37 <l0cust> davd: thanks
13:40:47 <l0cust> I'm getting confused with his weird notation for generic types
13:40:55 <l0cust> or rather non-generic types
13:40:55 <kini> the A and B weren't supposed to be generic
13:40:58 <kini> exactly :)
13:41:01 <kini> hence the upper case
13:41:03 <l0cust> yeah
13:41:04 <l0cust> hm
13:41:11 <l0cust> Well, look at Putstr
13:41:14 <l0cust> :t putStr
13:41:15 <lambdabot> String -> IO ()
13:41:19 <kini> actual example of a type annotation I found in some code:
13:41:25 <kini> readBit :: Monad m => String -> m (Int, Integer)
13:41:26 <l0cust> So, there are some weird cases
13:42:06 <quchen> kini: You can do more than just composing a function with return here, for example fmapping over the result.
13:42:08 <kini> l0cust: "String -> IO ()" is not of the form "forall m . Monad m => A -> m B" for some A and B
13:42:08 <quchen> :t \x -> fmap (*2) (return x)
13:42:09 <lambdabot> (Num b, Functor f, Monad f) => b -> f b
13:42:10 <user`> I don't understand what >> is
13:42:24 <kini> quchen: but that requires Num and Functor as well
13:42:34 <l0cust> user`: a >> b means "do a, then do b"
13:42:43 <l0cust> :t (>>)
13:42:44 <lambdabot> Monad m => m a -> m b -> m b
13:42:47 <quchen> Monad implies Functor, Num is because of my choice of the fmapping function.
13:43:05 <Iceland_jack> l0cust: what does “do” mean for lists? :) (which is the monad instance in user`'s example)
13:43:05 <user`> it says : x >> y = x >>= \_ ->y
13:43:07 <joshc> @src (>>)
13:43:07 <lambdabot> m >> k      = m >>= \_ -> k
13:43:11 <Iceland_jack> user`: yes that's right
13:43:20 <kini> ah, I guess Monad will imply Functor in GHC 7.10 or something, right?
13:43:38 <augur> Iceland_jack: lists are non-deterministic values!
13:43:43 <l0cust> user`: so, basically, it takes x, and sends it to y, only y doesn't care about the results from x
13:43:50 <quchen> kini: Morally it does already right now, but it will be enforced in 7.10, yes.
13:43:52 <user`> what I see there is something like ignore x do y
13:43:55 <kini> :t \x -> fmap (reverse :: String -> String) (return x)
13:43:56 <lambdabot> (Functor f, Monad f) => String -> f String
13:43:56 <Iceland_jack> augur: they are not
13:43:59 <kini> there we go
13:44:02 <augur> Iceland_jack: they are!
13:44:03 <Iceland_jack> they can be thought of as :)
13:44:05 <Iceland_jack> but they aren't
13:44:15 <augur> Iceland_jack: thats the standard understanding of them as monad computations
13:44:21 <l0cust> user`: it's like if you have to write some lines to a file
13:44:29 <l0cust> user`: you write line a, then line b
13:44:30 <kini> quchen: that technically still counts as "some function of type A -> B composed with return", though :P
13:44:36 <Iceland_jack> augur: yes, but you didn't mention monads :)
13:44:40 <kini> but with return on the other side of the composition operator than what I originall meant
13:44:41 <l0cust> user`: but line b isn't dependent on the value of line a
13:44:42 <kini> *originally
13:44:53 <augur> Iceland_jack: they were already mentioned
13:45:13 <user`> l0cust:  why would x be done at all? it isn't important for the result y, no?
13:45:34 <l0cust> user`: It's only used with Monads
13:45:41 <l0cust> user`: which usually means there are side effects
13:45:49 <l0cust> user`: or the computations need to be performed in order
13:45:57 <augur> "side effects"
13:46:10 <user`> what if I will make my own class
13:46:14 <l0cust> user`: Imagine you need to create a file before writing to it.
13:46:21 <user`> with similar definition
13:46:24 <quchen> kini: The forall'd Monad forbids you to use any type-specific function; it requires your code to work with any Monad instance. So you can't put a "get" or "ask" in there, and the caller can be sure that the code is fully polymorphic in the value. Many (well, all) monadic functions are based on that principle. mapM itself cannot do IO, for example.
13:46:29 <user`> then it won't calculate x?
13:46:53 <kini> quchen: right...
13:46:59 <quchen> kini: What you can use is things that are monadic, like fmap, <*>, >>= and so on.
13:47:12 <quchen> So you're limited to compositions of those that end up having the type you want.
13:47:38 <kini> makes sense
13:47:46 <quchen> Your type is a -> m b, so taking an "a" you have to get something "into" the Monad somehow, hence the return somewhere in your definition.
13:48:15 <kini> :t const fail
13:48:16 <lambdabot> Monad m => b -> String -> m a
13:48:22 <kini> err
13:48:24 <kini> :t fail
13:48:25 <lambdabot> Monad m => String -> m a
13:48:28 <quchen> fail ಠ_ಠ
13:48:38 <kini> there's something of type Monad m => A -> m B for some A and B (if I specialize the "a") :P
13:48:49 <kini> which doesn't use return!
13:48:51 <dwcook> It's handy as both the name of the method and an appropriate interjection
13:49:07 <user`> ok, I think I understand
13:49:16 <quchen> kini: "fail" is also as monadic as "undefined" is monadic: it's not.
13:49:31 <kini> yeah, I gathered :)
13:49:40 <quchen> It's evil. And should be buried. Deeply. ;-)
13:49:45 <kini> our codebase is full of it :)
13:49:51 <user`> x is calculated in order to be used in the >>= function, but then it is thrown away
13:50:14 <user`> which means that haskell don't optimize that
13:50:41 <kini> only the value of x is thrown away, not the context
13:50:58 <user`> what do you mean by context?
13:52:03 <kini> if you think of monadic values as computations that return a result while also modifying some surrounding state, then x is "calculated" by running the computation and modifying the surrounding state, and producing a value; that value is thrown away but the modifications made to the surrounding state (if any) remain
13:52:03 <kini> (someone correct me if I'm wrong, I'm a beginner too :) )
13:52:46 * hackagebot metrics 0.2.0.0 - High-performance application metric tracking  http://hackage.haskell.org/package/metrics-0.2.0.0 (IanDuncan)
13:52:49 <benzrf> kini: that's a valid way to think about some monads
13:53:04 <quchen> ">>" is ">>= \_ ->", and I think that's all you should think about it ;-)
13:53:04 <benzrf> kini: but it's more like monads are a more general structure that can be used to describe such computations
13:53:14 <kini> right, sure
13:53:30 <benzrf> kini: whenever you think you grok monads, see if your intuition applies to all of:
13:53:34 <benzrf> 1. IO monad
13:53:37 <benzrf> 2. maybe monad
13:53:39 <benzrf> 3. list monad
13:53:40 <benzrf> 4. reader monad
13:53:53 <benzrf> anybody wanna add one?
13:54:05 <davidthomas> benzrf: Cont?
13:54:10 <Gurkenglas> []?
13:54:16 <hc> state monad? parser monad?
13:54:17 <Gurkenglas> Oh nvm missed 3
13:54:26 <davidthomas> state is good
13:54:29 <hc> array monads
13:54:44 <benzrf> davidthomas: ugh Cont monad
13:54:47 <davidthomas> heh
13:54:54 <dwcook> Free monads in general
13:54:56 <quchen> The trick when looking at examples is picking only some, instead of all possible ones.
13:55:07 <dwcook> I think Free is a particularly good exemplar because of its generality
13:55:08 <benzrf> quchen: 04:51 < benzrf> kini: whenever you think you grok monads, see if your intuition applies to all of:
13:55:56 <davidthomas> benzrf: My hope was "something sufficiently different to shake loose misconceptions"
13:55:59 <quchen> benzrf: Sure, but it sounded like eventually someone would suggest RWST ParsecT Tagged.
13:56:44 <benzrf> >.>
14:04:49 <user`> now I don't understand how >> work in : [1..50] >>= (\x -> guard ('7' `elem` show x) >> return x)
14:05:14 <user`> doesn't it translate to
14:05:17 <Iceland_jack> user`: start with smaller examples or watch the videos
14:05:23 <Iceland_jack> > "hello" >> "world"
14:05:24 <lambdabot>  "worldworldworldworldworld"
14:05:26 <Iceland_jack> > "hell" >> "world"
14:05:28 <lambdabot>  "worldworldworldworld"
14:05:29 <Iceland_jack> > "hel" >> "world"
14:05:30 <lambdabot>  "worldworldworld"
14:05:33 <Iceland_jack> > "he" >> "world"
14:05:35 <lambdabot>  "worldworld"
14:05:39 <Iceland_jack> that should give you an intuition
14:05:45 <Iceland_jack> > "" >> "world"
14:05:47 <lambdabot>  ""
14:06:58 <user`> > guard ('7' `elem` show [1..50]) >> return [1..50]
14:07:00 <lambdabot>  No instance for (GHC.Show.Show (m0 [t0]))
14:07:00 <lambdabot>    arising from a use of ‘M827615497138912741815976.show_M8276154971389127418...
14:07:00 <lambdabot>  The type variables ‘m0’, ‘t0’ are ambiguous
14:07:00 <lambdabot>  Note: there are several potential instances:
14:07:00 <lambdabot>    instance [safe] GHC.Show.Show a =>
14:07:15 <user`> doesn't it translate to that ^
14:07:27 <latk> Has anyone used postgres-simple with a query using "LIKE" ?
14:08:08 <genisage> :t >>
14:08:10 <lambdabot> parse error on input ‘>>’
14:08:16 <latro`a> :t (>>)
14:08:16 <Iceland_jack> :t (>>)
14:08:17 <lambdabot> Monad m => m a -> m b -> m b
14:08:17 <lambdabot> Monad m => m a -> m b -> m b
14:08:18 <genisage> :t (>>)
14:08:19 <lambdabot> Monad m => m a -> m b -> m b
14:08:23 <genisage> oops
14:08:34 <kini> > do x <- [1..50]; guard ('7' `elem` show x) >> return x
14:08:36 <lambdabot>  [7,17,27,37,47]
14:09:01 <kini> > do let x = [1..50]; guard ('7' `elem` show x) >> return x
14:09:03 <lambdabot>  <hint>:1:58:
14:09:03 <lambdabot>      parse error (possibly incorrect indentation or mismatched brackets)
14:09:16 <kini> > do { let x = [1..50]; guard ('7' `elem` show x) >> return x }
14:09:18 <lambdabot>  <hint>:1:61: parse error on input ‘}’
14:09:22 <d3m1g0d-> @src Just
14:09:22 <lambdabot> Source not found. I don't think I can be your friend on Facebook anymore.
14:09:27 <kini> huh
14:09:32 <Iceland_jack> > do let {x = [1..50]}; y <- x; guard ('7' `elem` show y) >> return y
14:09:34 <lambdabot>  [7,17,27,37,47]
14:09:37 <Iceland_jack> kini: is that what you're trying to do?
14:09:42 <kini> nope
14:09:49 <Iceland_jack> then what?
14:10:05 <kini> I was trying to produce the same error message user` got earlier by replacing >>= with (flip $)
14:10:26 <kini> <user`> now I don't understand how >> work in : [1..50] >>= (\x -> guard ('7' `elem` show x) >> return x)
14:10:26 <kini> <user`> doesn't it translate to
14:10:26 <kini> <user`> > guard ('7' `elem` show [1..50]) >> return [1..50]
14:12:35 <user`> ah.. but >>= do some fmap thing
14:13:12 <rasfar> cabal install --only-dependencies ... how to specify a non-standard build option to one of the deps?
14:13:20 <rasfar> in particular, -fopenssl for snap-server
14:13:20 <Rotaerk_Web> Zekka: were you the one I was talking to yesterday about the issues with reporting errors by creating ADTs to represent error-cases for failable functions?
14:13:28 <Zekka> Rotaerk_Web: Yeah
14:13:59 <sie> Can anything besides (->) be an Arrow?
14:14:11 <user`> I forgot what that fmap thing is
14:14:58 <Rotaerk_Web> Zekka: I realized one approach could be to define a typeclass for each possible error, and then do something like:  (ContainsFooError e, ContainsBarError e) => IO (Either e Result)
14:15:00 <Zekka> sie: Kleisli can (which describes functions a -> m b)
14:15:34 <Rotaerk_Web> class ContainsFooError e where fooError :: parameters -> e; isFooError :: e -> Boolean
14:15:48 <user`> > fmap (\x -> guard ('7' `elem` show x) >> return x) [1..50]
14:15:50 <lambdabot>  No instance for (GHC.Show.Show (m0 b0))
14:15:50 <lambdabot>    arising from a use of ‘M340100687727009999716202.show_M3401006877270099997...
14:15:50 <lambdabot>  The type variables ‘m0’, ‘b0’ are ambiguous
14:15:50 <lambdabot>  Note: there are several potential instances:
14:15:50 <lambdabot>    instance [safe] GHC.Show.Show a =>
14:16:12 <Zekka> Rotaerk_Web: It's a little type-dense, but if I understand your approah then it could work and be reasonably elegant
14:16:30 <user`> kini: I got the error again ^
14:16:32 <Zekka> (what's the quote? For every problem in Haskell there's a unique abuse of typeclasses that solves it)
14:16:44 <user`> > fmap (\x -> (guard ('7' `elem` show x) >> return x)) [1..50]
14:16:46 <lambdabot>  No instance for (GHC.Show.Show (m0 b0))
14:16:46 <lambdabot>    arising from a use of ‘M330086601012595013316223.show_M3300866010125950133...
14:16:46 <lambdabot>  The type variables ‘m0’, ‘b0’ are ambiguous
14:16:46 <lambdabot>  Note: there are several potential instances:
14:16:46 <lambdabot>    instance [safe] GHC.Show.Show a =>
14:16:49 <kini> user`: you need to think about the types here
14:17:07 <Rotaerk_Web> Zekka: by typedense you mean the signature is very long?
14:17:17 <Rotaerk_Web> the more error-types you have
14:17:32 <Zekka> Rotaerk_Web: I mean that it's using considerably more type system tooling than most folks would probably end up doing
14:17:38 <Rotaerk_Web> ah k
14:17:48 <user`> kini: why?
14:18:10 <kini> because types tell you what's going on
14:18:32 <kini> :t \x -> guard ('7' `elem` show x) >> return x
14:18:33 <lambdabot> (MonadPlus m, Show b) => b -> m b
14:18:40 <kini> :t fmap
14:18:41 <lambdabot> Functor f => (a -> b) -> f a -> f b
14:18:42 <user`> but the type is in the list [1..50]
14:19:23 <kini> fmap will take a function which is originally of type A -> B, to a function which is of type f A -> f B for some functor f
14:19:56 <kini> what do you mean by saying that the type is in the list [1..50]
14:20:00 <kini> the type of what, and how is it "in the list"
14:20:10 <user`> it is a list of ints
14:20:27 <user`> the show should be show int
14:20:41 <BeardedCoder> johnw: Hey, I got my code working based on your advice. I'm trying to expand a bit now and stream the result of the IO down for a sink to handle. Any ideas? I've been toying with repeatWhileM, but I'm a bit lost.
14:20:59 <kini> what do you mean by "be show int"
14:21:24 <johnw> BeardedCoder: Hi
14:21:32 <johnw> can you show me your current code?
14:21:38 <johnw> and what you hope to accomplish exactly?
14:21:41 <user`> I mean that the show should be the show receive and Int
14:21:52 <dwcook> @type [1..50]
14:21:53 <lambdabot> (Num t, Enum t) => [t]
14:21:55 <dwcook> user`: ^
14:22:00 <dwcook> Not specifically Int
14:22:12 <BeardedCoder> johnw: ya, let me expand on my earlier example 1 sec
14:22:33 <user`> dwcook, ok .. then what :t said, that should be the type
14:22:51 <dwcook> user`: That is a polymorphic type. You need to pick a t to know what instances to use.
14:23:07 <kini> that's not really the fundamental problem in understanding here though
14:23:34 <user`> so how can I fix that one?
14:23:58 <user`> > fmap (\x -> (guard ('7' `elem` show x) >> return x)) [1..50] :: [Int]
14:24:00 <lambdabot>  Couldn't match expected type ‘GHC.Types.Int’
14:24:00 <lambdabot>              with actual type ‘m0 b0’
14:24:00 <lambdabot>  Relevant bindings include x :: b0 (bound at <interactive>:1:8)
14:24:21 <dwcook> user`: put parens around [1..50] :: Int
14:24:28 <kini> don't use fmap there
14:24:39 <user`> > fmap (\x -> (guard ('7' `elem` show x) >> return x)) ([1..50] :: [Int])
14:24:40 <kini> fmap is not what you want
14:24:41 <lambdabot>  No instance for (GHC.Show.Show (m0 GHC.Types.Int))
14:24:41 <lambdabot>    arising from a use of ‘M727981735957972231216406.show_M7279817359579722312...
14:24:41 <lambdabot>  The type variable ‘m0’ is ambiguous
14:24:41 <lambdabot>  Note: there are several potential instances:
14:24:41 <lambdabot>    instance [safe] GHC.Show.Show a =>
14:25:00 <dwcook> Ah, woops, I skimmed over the error message
14:25:32 <user`> > fmap (\x -> (guard ('7' `elem` show x) >> return x)) [(1 :: [Int])..50]
14:25:34 <lambdabot>  Could not deduce (GHC.Enum.Enum [GHC.Types.Int])
14:25:34 <lambdabot>    arising from the arithmetic sequence ‘(1 :: [GHC.Types.Int]) .. 50’
14:25:34 <lambdabot>  from the context (Control.Monad.MonadPlus m)
14:25:34 <lambdabot>    bound by the inferred type of
14:25:34 <lambdabot>             it :: Control.Monad.MonadPlus m => [m [GHC.Types.Int]]
14:25:49 <dwcook> user`: What are you actually trying to do?
14:25:50 <user`> > fmap (\x -> (guard ('7' `elem` show x) >> return x)) [(1 :: Int)..50]
14:25:52 <lambdabot>  No instance for (GHC.Show.Show (m0 GHC.Types.Int))
14:25:52 <lambdabot>    arising from a use of ‘M797990679647988293516440.show_M7979906796479882935...
14:25:52 <lambdabot>  The type variable ‘m0’ is ambiguous
14:25:52 <lambdabot>  Note: there are several potential instances:
14:25:52 <lambdabot>    instance [safe] GHC.Show.Show a =>
14:25:55 <kini> don't just throw in random brackets and fmaps to try to get the typechecker to shut up
14:26:17 <user`> dwcook I try to learn haskell
14:26:29 <dwcook> user`: I mean with this expression you're trying to write.
14:26:44 <flebron> Tangentially related question. I'm trying to understand Wadler's "Theorems for free." I can do the derivations syntactically, but I'm not entirely sure what these relations are supposed to be. I assign "types" the semantics "sets of values". What semantics can I assign these relations between types? What about relations between relations?
14:27:13 <BeardedCoder> johnw: https://gist.github.com/ccarter/57e8d1f4f9e37e667bdf
14:27:31 <user`> it started with : [1..50] >>= (\x -> guard ('7' `elem` show x) >> return x)
14:27:43 <johnw> BeardedCoder: are you saying you want to sink pairs into a file?
14:27:44 <dwcook> flebron: I don't think types can be considered sets.
14:27:59 <user`> I thought that x >>= y does fmap y x
14:28:03 <Iceland_jack> user`: no
14:28:04 <user`> and tried to do it
14:28:15 <flebron> dwcook: Sure, there are going to be foundational issues, but that's at least my conceptual interpretation: A type is the set of values that are given such a type by the system.
14:28:15 <Iceland_jack> You're just typing things away not really listening to people's advice
14:28:32 <rasfar> cabal install --only-dependencies ... how to pass a non-standard build option to one of the deps? (in particular, -fopenssl for snap-server)
14:28:33 <BeardedCoder> johnw: The full use case: Streaming data from a database, batching up 5k rows at a time to import into ElasticSearch, writing the elasticsearch responses into a file.
14:29:10 <napping> flebron: are you sure that's what Wadler is doing with them?
14:29:11 <rasfar> otherwise a significant amount of reinstallation is needed after the cabal install --only-dependencies
14:30:01 <BeardedCoder> johnw: So for my example, IO String represents some sort of http response that I'm going to log per line, so I'd rather not have it all in mem if I don't have to.
14:30:16 <napping> flebron: I haven't followed the details of the derivations, but I think the idea is to give a somewhat nonstandard semantics
14:30:22 <flebron> napping: Initially? Yeah, explicitly.
14:30:56 <flebron> Page 4, 2nd sentence: http://ttic.uchicago.edu/~dreyer/course/papers/wadler.pdf
14:31:02 <kini> user`: >>= is a primitive function associated with each monad, it's not defined in terms of other things
14:31:05 <napping> flebron: for each Type you define also a relation on the sets of values of that type, for functions it's something like taking related values to related values, and then you prove that every well typed expresion is related to itself in the corresponding relation
14:31:08 <flebron> Then he goes and does the foundational yoga with frames instead of sets, but that's the general notion.
14:31:30 <flebron> napping: Can I consider such a relation a notion of "sameness"?
14:31:31 <quchen> I don't think calling >>= "primitive" is right.
14:31:45 <napping> I'm not quite sure about that
14:31:59 <napping> if anything I think it's more the flavor of a PER - a value related to itself is well-behaved
14:32:00 <flebron> For example, he assigns the natural numbers the identity relation on the natural numbers.
14:32:03 <quchen> It's one of the basic monadic functions and part of the typeclass, but it can be defined in terms of other things, such as join and fmap.
14:32:10 <napping> for primitive types like natural numbers and lists and so on will get identity, yeah
14:32:18 <flebron> So [[N]] = \Delta_N, same with booleans, [[B]] = \Delta_B.
14:32:31 <quchen> Δ <- copy/paste service :-)
14:32:40 <user`> for list it is : xs >>= f = concat (map f xs)
14:32:44 <mmmm> Can anyone please exaplain this error from parsec?
14:32:51 <Iceland_jack> quchen: how much do you charge? :)
14:32:55 <mmmm> http://lpaste.net/5602706591917801472
14:32:56 <johnw> BeardedCoder: I've commented the gist
14:33:19 <kini> quchen: but it isn't uniformly defined in terms of other things over all monads, is it?
14:33:19 <kini> whereas I gather that for example >> is uniformly defined in terms of >>=
14:33:22 <johnw> change "await" here to something that grabs 5K elements and then works on them
14:33:29 <Lutin`> marchelzo_: Hey
14:33:29 <johnw> and you'll be sinking to a file instead of a list
14:33:38 <flebron> And then [[A x B]], with A and B types, is interpreted as the things of the form ((x, y), (x', y')) such that (x, x') is in [[A]] (y, y') is in [[B]].
14:33:47 * hackagebot kansas-comet 0.3.0 - A JavaScript push mechanism based on the comet idiom  http://hackage.haskell.org/package/kansas-comet-0.3.0 (AndyGill)
14:33:50 <marchelzo_> Lutin`: Hi
14:34:00 <flebron> napping: What is a "PER"?
14:34:12 <napping> partial equivalence relation
14:34:28 <dwcook> mmmm: You need a way to extract Char from [Tag String] but there is no instance for that in scope. Are you sure [Tag String] is the type you want to parse?
14:34:47 <dwcook> parse Chars from, that is
14:35:06 <flebron> napping: What is that? Any subset of an equivalence relation?
14:35:45 <quchen> kini: I don't know what you mean with "uniformly defined". You can define your own implementation for ">>", but if you don't, there's a default.
14:35:46 <mmmm> dwcook: I see thanks
14:36:09 <napping> a symmetric and transitive relation, I think
14:36:24 <kini> quchen: I guess I mean that the only reason to define your own implementation for >> would be to provide a more efficient implementation -- the meaning of >> is supposed to be that of the default implementation
14:36:24 <kini> no?
14:36:31 <BeardedCoder> johnw: k, gimme some time to wrap my head. ty
14:36:34 <napping> That's the term from various places where you define a relation like that, and things related to themselves are somehow good
14:36:36 <user`> why doesn't my fmap work?
14:36:59 <Lutin`> napping: That's correct
14:37:00 <flebron> Like, I think of [[A x B]] as giving a notion of "sameness", A and B, and two tuples (x, y) and (x', y') are "same" (in [[A x B]]) if (x, x') are "same" in [[A]], and (y, y') are "same" in [[B]].
14:37:25 <quchen> kini: Yes, that's the idea.
14:37:37 <flebron> Two functions (f, f') are "same" in [[A -> B]] if whenever two inputs (x, x') are "same" in [[A]], then the outputs (f x, f' x') are "same" in [[B]].
14:37:47 <napping> It might help to run a few types through the free theoroem generator, and take a particular look at the relation version of output: http://www-ps.iai.uni-bonn.de/cgi-bin/free-theorems-webui.cgi?
14:37:47 <dwcook> user`: You seemed to be saying earlier that you thought that fmap and (>>=) were the same thing. They're not, they even have different types.
14:37:49 <dwcook> @type fmap
14:37:50 <lambdabot> Functor f => (a -> b) -> f a -> f b
14:37:51 <dwcook> @type (>>=)
14:37:52 <lambdabot> Monad m => m a -> (a -> m b) -> m b
14:38:01 <napping> You need to generalize a bit more
14:38:01 <flebron> And then I have a meltdown for the case [[\forall X. F(X)]].
14:38:23 <Lutin`> I need to start reading more type theory papers...
14:39:03 <user`> dwcook, but >>= is defined as concat (fmap x y)
14:39:09 <napping> given a relation R between types s1 and s1, and a relation S between types t1 and t2, then a pair of functions (f,g) is good in the type/relation R -> S if for any R-related pair (x,y), (f x, g y) is an S-related pair
14:39:30 <napping> you do indeed end up instantiating with the equality relation on two copies of the same type for primitive types
14:39:30 <Twey> :t concat
14:39:31 <lambdabot> [[a]] -> [a]
14:39:36 <dwcook> user`: (>>=) has a potentially different definition for every type.
14:39:46 <flebron> napping: But R need not be a relation between types, right?
14:39:46 <napping> but for some reaon it's useful to generalize to pairs of related things over possibly different types
14:39:50 <flebron> It could be a relation between relations of types.
14:39:52 <merijn> dwcook: s/potentially//
14:39:55 <Twey> user`: concat is a specific example (for lists) of a more general function on monads called ‘join’
14:39:57 <Tjr> LYAH claims it's more efficient to add new elements to the right of a list, rather than to the left: http://learnyouahaskell.com/for-a-few-monads-more
14:39:59 <flebron> (And so on)
14:40:01 <napping> No, I don't think it goes that high
14:40:11 <flebron> Oh, then this is much simpler.
14:40:21 <napping> There's just the usual interpration of types and type variables
14:40:23 <dwcook> merijn: I'm not going to argue the point because it's not important.
14:40:42 <genisage> > fmap (\x -> (guard ('7' `elem` (show x)) >> [x] )) [1..50]
14:40:44 <lambdabot>  [[],[],[],[],[],[],[7],[],[],[],[],[],[],[],[],[],[17],[],[],[],[],[],[],[],...
14:40:47 <flebron> Tjr: No it doesn't, notice that you're adding a bunch of things to the left every time.
14:40:51 <napping> and then the variant interpretation of a type variable as a pair of ordinary types and a relation between their ordinary domains, plus the usual type operators combining those interpetations
14:40:57 <Twey> user`: return + bind is sufficient to define a monad, as is return + fmap + join.  bind can be written in terms of fmap + join, and join + fmap can be written in terms of bind
14:41:04 <flebron> napping: But I could have a type of pairs of functions, wouldn't that invoke relations of relations?
14:41:18 <napping> No, I don't think so
14:41:37 <napping> well, it's stratified
14:41:50 <Twey> user`: In Haskell, monads are given in terms of return + bind, and then join is defined in terms of bind (join m = m >>= id)
14:41:54 <Twey> @src join
14:41:54 <flebron> What does that mean?
14:41:54 <lambdabot> join x =  x >>= id
14:42:07 <napping> You have the usual interpretation, and then the other one. I'll say free theorems
14:42:27 <user`> Twey I don't speak the lingo well enough to understand
14:42:29 <lfairy> Tjr: where does it say that?
14:42:49 <Tjr> http://learnyouahaskell.com/for-a-few-monads-more
14:42:49 <Tjr> subheading "Inefficient list construction"
14:42:50 <napping> so the free-theorem level meaning of a type is a pair of ordinary types, and a relation between their domains
14:43:09 <Rotaerk_Web> Zekka: is there a reason you called it an "abuse" of typeclasses?
14:43:19 <flebron> napping: What is the domain of a type?
14:43:33 <Twey> user`: ‘Bind’ is the name for the operation written by (>>=) in Haskell; the others are Haskell functions as-is
14:44:01 <napping> the domain corresponding to the free theorem interpretation of a type is a pair of values from the ordinary domains of the left and right ordinary types, such that they pair of values satisfies some conditions
14:44:06 <lfairy> Tjr: flebron is right. By associating to the right, we ensure the left arguments are short.
14:44:06 <user`> I just see the (>>=) definition, and don't understand why I get type error when I write it using the definition. Maybe it to complicated for me now.
14:44:11 <Zekka> Rotaerk_Web: It's not really an abuse -- that's just the old saying
14:44:19 <Rotaerk_Web> ah
14:44:21 <lfairy> Tjr: The complexity of ++ depends on the left argument only
14:44:28 <Zekka> Most of the uses of typeclasses I've seen people say that about I wouldn't call abuses
14:44:47 <Zekka> it's just that typeclasses are way more expressive than I think a lot of people on the outside realize
14:44:57 <napping> then (Int,Bool,{(n,b) | b == isEven n}) is a "type" at the free theorems level
14:45:10 <napping> and (0,True), (3,False) are examples of values
14:45:23 <Tjr> flebron, lfairy : then why is it a problem at all? The definition of >>= for always appends from the left, so there should be no need to warn newbies about that issue.
14:45:23 <Tjr>     (Writer (x,v)) >>= f = let (Writer (y, v')) = f x in Writer (y, v `mappend` v')
14:46:09 <flebron> napping: So the first thing is what the paper knows as a "relation"?
14:46:10 <napping> and (a1,a2,R1) -> (b1,b2,R2) is (a1->b1, a2->b2, {(f,g) | (x,y) in R1 implies (f x,g y) in R2}
14:46:18 <flebron> Well yeah, I guess that makes sense.
14:46:32 <napping> so all the relations you end up making are relations on or between ordinary types
14:46:34 <Tjr> Err, the cited definition appends to the right. That doesn't even match the code examples.
14:46:53 <flebron> Right, yeah, I was just looking at that napping.
14:47:04 <flebron> Pairs take relations between types and produce relations between types.
14:47:07 <Tjr> @source Writer
14:47:07 <lambdabot> Unknown command, try @list
14:47:15 <Tjr> @src Writer
14:47:16 <lambdabot> Source not found. And you call yourself a Rocket Surgeon!
14:47:26 <napping> then just focusing down to things that are related to themselves in these funny relations will give you the free thoeorems and things that obey them
14:47:32 <lfairy> Tjr: not always. Try (replicateM_ 5000 $ tell "hello") >> tell "world"
14:47:48 <flebron> That is, if X : A ~ A', Y : B ~ B', then X x Y : (A x B) ~ (A' ~ B')
14:48:02 <flebron> And A, A', B, B' were types.
14:48:15 <johnw> did you mean ~ (A' x B')?
14:48:18 <flebron> As are A x B and A' ~ B'. So I think what you say makes sense, the hierarchy is actually flat.
14:48:21 <flebron> Err, yes.
14:48:28 <flebron> And twice, at that.
14:48:33 <Tjr> lfairy: I don't understand your last example. I thought the monad definition of Writer took care of the appending part, so the calling code should not matter at all.
14:48:35 <Twey> user`: There are two (amongst others) different (but equivalent) ways to define a Monad m.  You can provide a function fmap ∷ (a → b) → (m a → m b) (from Functor) and a function join ∷ m (m a) → m a, and then you can write bind ∷ m a → (a → m b) → m b as: bind m f = join (fmap f m)
14:48:48 * hackagebot stomp-conduit 0.0.2 - Stompl Conduit Client  http://hackage.haskell.org/package/stomp-conduit-0.0.2 (TobiasSchoofs)
14:48:51 <flebron> Twey: And return.
14:48:59 <Twey> And return, right
14:49:08 <rasfar> cabal install --only-dependencies ... how to pass a non-standard build option to one of the deps? (in particular, -fopenssl for snap-server) Otherwise a significant amount of reinstallation is needed after the cabal install --only-dependencies. [last try here]
14:49:45 <Twey> user`: Or, you can provide a function bind ∷ m (m a) → m a, and then you can write fmap f m = bind m (return . f) and join m = bind m id
14:49:53 <lfairy> Tjr: the monad instance appends exactly when you call >>/>>=. If you associate all your >> calls to the left, then all the mappend calls will associate to the left as well
14:49:58 <Twey> user`: In Haskell, we do the latter, for no good reason other than history
14:50:04 <flebron> napping: So the free theorem for a type is a relation between some (concrete) types?
14:50:39 <flebron> Oh, a relation between values, actually.
14:50:47 <Twey> user`: So the definition ‘m >>= f = join (fmap f m)’ isn't actually used anywhere: to create a monad you provide a (>>=) function (bind) yourself
14:51:09 <flebron> So that if a type T has a free theorem relation R, then for every term t of type T, parametricity says (t, t) is in R.
14:51:09 <lfairy> Tjr: in my example, I pretty much do "reallyreallyreallylonghello" ++ "world", which is inefficient
14:51:12 <napping> well, the big theorem is that any well-typed value is related to itself in the relation corresponding to the type
14:51:19 <Tjr> lfairy: so you'd have to do something like this to make Writer generate an inefficient monoid:
14:51:20 <Tjr> f1 >>= (f2 >>= (f3 >>= (f4 >>= f5 ....
14:51:23 <Tjr> right?
14:51:32 <Twey> user`: Nevertheless, it holds as an equation, because of the monad laws and the definitions of fmap and join
14:51:35 <lfairy> Tjr: nope. The other way round
14:51:38 <napping> like the big proposition on page 5
14:51:42 <Tjr> Since >>= is naturally left-associative, you'd have to break things deliberately
14:51:56 <napping> wow, I guess I understand this a lot more than the last time I tried to read that paper
14:52:02 <lfairy> Tjr: ((m >>= f) >>= g) >>= h is inefficient
14:52:19 <flebron> Haha, it's actually kind of embarassing: I am supposed to give a talk on it tomorrow as part of a group on functional programming.
14:52:29 <flebron> As it turns out, public embarassment is a good motivator to learning.
14:53:43 <flebron> But I guess it's still not intuitively clear to me why a type being a member of its relation tells you anything useful.
14:53:53 <flebron> But I guess the "key" is the \forall types?
14:53:58 <napping> yeah,
14:54:00 <flebron> And their interpretations as relations.
14:54:07 <napping> and expanding out just what the intepretation of a type is
14:54:10 <flebron> Where your expressions now have to "promise" to respect all possible relations.
14:54:25 <Tjr> lfairy: Since >>= is naturally left-associative, and because LYAH uses the default, that would mean that it showcases the inefficient example but claims it 's efficient.
14:54:33 <napping> and in particular specializing an input/output relation (a1,a2,R) down to choices of actually a function
14:54:41 <napping> (a1,a2) in R if a2 = f a1
14:54:43 <Tjr> So, is the bug in LYAH, or somewhere in our discussion?
14:54:55 <flebron> Yeah that's one thing I didn't immediately get - why not just talk about functions all along if the theorems are all derived for functions?
14:55:23 <napping> well, I guess you need to go through these relations and pairs to end up proving what you want about individual items
14:55:27 <flebron> That is, to actually derive information, it seems one always assume the "arbitrary relation" is actually a function
14:55:34 <flebron> Oh, so functions alone are too weak
14:55:35 <flebron> ?
14:55:42 <napping> That's kind of a general thing really, rather than saying something about a you say something about pairs (a,b)
14:55:46 <napping> pairs (a,a) rather
14:56:00 <napping> and then get more freedom by writing things as if they can independently vary while you prove stuff
14:56:10 <flebron> Ah, yes.
14:56:17 <rwbarton> flebron: my understanding is when higher-rank polymorphism is involved you might need non-function relations
14:56:21 <napping> for an instantiation, I'm working thorough (a -> b) -> [a] -> [b]
14:56:30 <lfairy> Tjr: do-notation desugars right-associatively, so I think LYAH is still correct
14:56:37 <napping> so concrete type constructors like [] need to become liftings on relations
14:56:51 <Tjr> :i (>>=)
14:57:05 <Tjr> @info (>>=)
14:57:05 <lambdabot> (>>=)
14:57:05 <napping> not sure how that goes systematically but saying relations lift elementwise works
14:57:13 <flebron> I was hopeful all free theorems would just be the natural transformations inferred by their types, but it seems they're more powerful than that.
14:57:32 <napping> what would you infer from (a -> b) -> [a] -> [b]
14:57:39 <gilligan_> given a cabal file is there a way to list all dependencies of it ?
14:57:43 <flebron> Namely because it's not true that all natural transformations between Id and Id are the identity, at least not in all categories, yet it's true that f : a -> a means f = id (assuming strictness)
14:57:52 <napping> I think the point is proving that the function actually respects the natural transformation that you'd like to infer from the type, perhaps?
14:58:01 <Tjr> Why is >>= left-associative, but its equivalent do-notation  right-associative?
14:58:01 <napping> or maybe it really is shaper?
14:58:08 <napping> actually, lets start with id
14:58:13 <flebron> napping: Well I'd think that's a natural transformation between the Hom functor and the functor that takes (a, b) to [a] -> [b].
14:58:23 <merijn> Tjr: Hysterical raisins
14:58:33 <flebron> But natural transformations themselves aren't powerful enough to express parametricity
14:58:34 <lfairy> Tjr: "left associative" is just syntax
14:58:35 <merijn> Tjr: The rewrite is simpler with right-associativity
14:58:44 <flebron> Say, multiplying by 3 is a n.t. between Id in the category of modules.
14:58:48 <merijn> Tjr: The Monad laws require both to be the same anyway
14:58:58 <napping> a pair (f,g) of functions respects the relation inferred from forall a . a -> a, if given any relation R on (a,b), you have that (x,y) in R implies (f x, f y) in R
14:59:09 <napping> then we specialize the relation down to a function t
14:59:11 <flebron> So there's no way I'm going to derive f_A = id_A forall A from knowing f: a -> a, or f: Id -> Id as n.t.
14:59:24 <Tjr> merijn: they are the same, but one is more efficient thatn the other (as per LYAH)
14:59:34 <napping> and say (f,g) repspects the relation given by the graph of t if t (f x) == f (t x) for any (t :: a -> b)
14:59:49 <flebron> napping: You meant (f x, g y) I'm sure
14:59:51 <napping> or t (f x) == g (t x), I guess
15:00:08 <napping> and maybe some similar mistake with pairs in the relational version
15:00:45 <flebron> So if f: a -> a, the free theorem is a relation between which values?
15:01:39 <napping> yeah
15:01:53 <BeardedCoder> johnw: I updated my gist to hopefully make more sense of what I'm trying to do.
15:01:55 <BeardedCoder> johnw: https://gist.github.com/ccarter/57e8d1f4f9e37e667bdf
15:01:58 <napping> and the big free theorems theorem says that any function of type forall a . a -> a is related to itself in the relation
15:02:35 <napping> So we've seen how to get at least as far as applying it to conclude that if (f :: a -> a), then for any g we have g . f == f . g
15:02:37 <flebron> Oh so the values are the function types of the form X -> X for some specific type X.
15:02:43 <flebron> Or, wait, no.
15:02:55 <flebron> They're the function types f: a -> a for type _variables_ a.
15:03:34 <miguelnegrao> Hi while trying to build buildwrapper with ghc 7.8.2 I get up to 12GB of memory usage, until memory runs out and ghc is killed by linux. Does this look like a bug ?
15:03:48 <napping> well, I guess if we take g == const v
15:03:56 <napping> then we get const v (f x) = f (const v x)
15:03:57 <napping> v == f v
15:04:02 <napping> so yay
15:04:18 * hackagebot stomp-conduit 0.0.3 - Stompl Conduit Client  http://hackage.haskell.org/package/stomp-conduit-0.0.3 (TobiasSchoofs)
15:04:46 <napping> If you've used it, this stuff about going through relations reminds me of the Coq Setoid library's "proper" and "respectful" definitions
15:05:11 <orzo> would it be a bad idea if ghc provided for IO triggers when an object is marked dead?
15:05:47 <napping> You get "map" in free theorems involving lists because the canonical relation lifting operation for [] takes the graph of a function f on some a -> b to the graph of map f on [a] -> [b]
15:05:50 <quchen> orzo: System.Mem.Weak?
15:06:15 <quchen> orzo: "Run this IO action when the thing is GC'd"
15:07:30 <orzo> well i have in mind a case where a thread is processing in order to compute the value of an MVar, but if other threads no longer care about the mvar, then the thread should abort and clean up
15:08:50 <orzo> can we acheive that with system.mem.weak?
15:09:01 <napping> and you can get down to f x == f id . map x by specializing the relation for (a -> b) -> [a] -> [b] enough
15:09:07 <orzo> i don't want to know when it's gced, i want to know when its marked for gc
15:09:19 * hackagebot librato 0.1.0.0 - Bindings to the Librato API  http://hackage.haskell.org/package/librato-0.1.0.0 (IanDuncan)
15:09:34 <quchen> It's marked for GC when there are no references to it left :-x
15:09:54 <napping> got to go now
15:10:39 <orzo> right, no references in other threads, but maybe my worker thread is keeping a weak reference
15:10:56 <Tjr> Some day, I want to read up on "free theorems". Except category theory isn't my strong poitn.
15:12:29 <orzo> it's nicer code than having the other threads explicitly release the info they no longer care about
15:12:30 <marchelzo_> Lutin`: Have you done any more of those Rosalind problems?
15:12:50 <Lutin`> marchelzo_: Nope, helping people with boot problems in #archlinux
15:13:22 <marchelzo_> ah, ok
15:13:38 <Lutin`> I need to, gotta remember my account first though
15:14:05 <marchelzo_> The one I'm on right now is really frustrating
15:14:43 <Guest90897> Hi. I have a fresh CentOS 6.5 image with haskell platform (ghc 7.6.3) and I wanted to install the haskell plugin for sublime Text. Following the instructions I first do cabal install ghc-mod and I'm told that lifted-base-0.2.2.2 failed during config and/because inlinable.h is missing. This seems far too hard, have I simply missed out something important?
15:14:47 <orzo> it'd be nicer than ResourceT
15:15:52 <inforgz> yep, you missed inlinable.h
15:23:47 <octopuscabbage> philisphical question: do haskell rascals consider Nothing equal to []?
15:24:21 <Zekka> octopuscabbage: They have different types.
15:24:31 <octopuscabbage> Zekka: So no?
15:24:43 <inforgz> no
15:24:47 <Zekka> octopuscabbage: I'd say they roughly *mean* the same thing, but they're not equal.
15:24:55 <hpc> they are definitely maybe equal, if you coerce them
15:25:01 <hpc> perhaps
15:25:51 <octopuscabbage> also, what do you all think of calling 'haskellers' haskell rascals
15:25:55 <RevJohnnyHealey> Similarly, 0 is not equal to False.
15:26:02 <hpc> octopuscabbage: the official term is haskelletor
15:26:32 <octopuscabbage> hpc: that's interesting because all of the haskell users i know in real life are extremely skinny, much like skeletor
15:26:37 <marchelzo_> Is there a word for something that is done in a way that suits Haskell? Like 'pythonic' in python.
15:26:43 <octopuscabbage> Functional?
15:26:49 <Zekka> marchelzo_: You can use the language-agnostic term "idiomatic"
15:26:50 <Iceland_jack> just idiomatic
15:26:53 <octopuscabbage> Draconian /s
15:26:56 <Lutin`> marchelzo_: Which one
15:26:59 <jfischoff> > mzero :: [Int]
15:27:02 <Iceland_jack> “Idiomatic Haskell” is used
15:27:03 <lambdabot>  []
15:27:08 <Lutin`> marchelzo_: Which problem that is
15:27:09 <RevJohnnyHealey> How about "correct"
15:27:11 <marchelzo_> Lutin`: Longest common substring
15:27:13 <jfischoff> > mzero :: Maybe Int
15:27:15 <lambdabot>  Nothing
15:27:25 <marchelzo_> Lutin`: I had a "solution" but it was like O(2^n) or something
15:27:36 <marchelzo_> it couldn't handle the actual data set
15:28:56 <marchelzo_> I tried to look up how to do it, and apparently you need to use generalized suffix trees. No idea what they are or how to implement them in Haskell, though.
15:29:12 <path[l]> is there a pre-existing list operation that allows me, given something like [1,2,3] and a mapping function 1 -> [1], 2 -> [4, 8], 3 -> [9, 27] and would give me something like [[1,4,9], [1, 4, 27], [1, 8, 9], [1, 8, 27]] etc. The type signature would be (a -> [b]) -> [a] -> [[b]], but more specifically it’s about making sure I get all possibile variants
15:29:36 <octopuscabbage> path[l] you're looking for a partition function
15:29:39 <Lutin`> marchelzo_: What was your solution?
15:29:48 <path[l]> ah am I? let me seach for what that is :)
15:29:50 <octopuscabbage> (assuming you don't care about the order of the list)
15:30:06 <benzrf> octopuscabbage: no, i dont think that's what path[l] wants
15:30:20 <octopuscabbage> haskell calls it something different, but you are partitioning the set
15:30:27 <path[l]> yeah, this is more like combinations, not partitions though
15:30:31 <Guest90897> inforgz: that's completely unhelpful
15:30:33 <rwbarton> path[l]: mapM
15:30:39 <benzrf> rwbarton++
15:30:49 <path[l]> :t mapM
15:30:51 <lambdabot> Monad m => (a -> m b) -> [a] -> m [b]
15:30:55 <benzrf> > sequence [[1], [4, 8], [9, 27]]
15:30:56 <marchelzo_> Lutin`: Get a list of every substring of the first string, and then filter that list with the condition that the string must be a substring of every other string that was passed. Then maximumBy (comparing length)
15:30:57 <lambdabot>  [[1,4,9],[1,4,27],[1,8,9],[1,8,27]]
15:30:59 <benzrf> @src mapM
15:31:00 <lambdabot> mapM f as = sequence (map f as)
15:31:07 <path[l]> oooh
15:31:20 <benzrf> path[l]: do u know ur monads?
15:31:34 <Lutin`> marchelzo_: Ah yeah, do you know the typical LCS solution
15:31:34 <benzrf> path[l]: in general, fancy cartesian products tend to be the domain of the list monad
15:31:36 <Lutin`> ?
15:31:51 <path[l]> aha
15:31:57 <marchelzo_> Lutin`: Not when there are >2 strings
15:32:10 <path[l]> benzrf: just ran into mapM yesterday, but I dont think I fully understood what sequence can do for me :)
15:32:24 <benzrf> path[l]: sequence is just [m a] -> m [a]
15:32:25 <Zekka> :t sequence
15:32:26 <lambdabot> Monad m => [m a] -> m [a]
15:32:40 <Zekka> So, it takes a list of monadic actions and combines them into a monadic action giving you a list of their results
15:33:09 <Lutin`> marchelzo_: Ah there's more than one
15:33:12 <benzrf> path[l]: for example, sequence on the IO monad takes a list of IO actions and returns an IO action that does all of them and gives a list of results
15:33:12 <path[l]> when I use [[1], [4,8], [9, 27]], which are the monadic actions over here?
15:33:18 <Lutin`> marchelzo_: Can you linx me the problem?
15:33:19 <benzrf> path[l]: lists
15:33:21 <benzrf> [] is a monad
15:33:35 <marchelzo_> http://rosalind.info/problems/lcsm/
15:33:51 <benzrf> path[l]: if [[1], [4,8], [9, 27]] :: [m a], then m :: []
15:34:20 <Darwin226> Hey, are there any preexisting functions that can do algebraic and similar operations with other functions? For example, f + g would make a new functions such that (f + g)(x)=f(x) + g(x). I'd also like to do (f, g), where (f, g)(x)=(f(x), g(x)). Maybe some dot product stuff ((f, g) `dot` (h, i))(x) = (f * h + g * i)(x)=(f(x)*h(x)...
15:34:30 <marchelzo_> What is the name of the (>>) function?
15:34:35 <Iceland_jack> marchelzo_: then
15:34:45 <hpc> as in "do this then that"
15:34:45 <marchelzo_> Iceland_jack: ah that makes so much sense
15:34:46 <Zekka> :t sequenceA
15:34:46 <lambdabot>     Not in scope: ‘sequenceA’
15:34:47 <lambdabot>     Perhaps you meant one of these:
15:34:47 <lambdabot>       ‘T.sequenceA’ (imported from Data.Traversable),
15:34:50 <Zekka> :t T.sequenceA
15:34:52 <lambdabot> (Traversable t, Applicative f) => t (f a) -> f (t a)
15:35:02 <Zekka> If you like sequence and wish it were more general
15:35:13 <Zekka> er, wait
15:35:16 <Zekka> :t T.sequence
15:35:17 <lambdabot> (Traversable t, Monad m) => t (m a) -> m (t a)
15:35:18 <marchelzo_> But for the Maybe monad, you would never really use the >>, would you?
15:35:29 <benzrf> marchelzo_: you might
15:35:32 <Zekka> only saw the Applicative version in Data.Traversable when I :browsed it, but there's also the monadic version
15:35:39 <Iceland_jack> marchelzo_: you sure would, e.g. for guards
15:36:01 <benzrf> marchelzo_: for example, let's say you have a function that returns Maybe Name for if a user has a name
15:36:14 <benzrf> marchelzo_: and you want to let them in only if they have a name listed
15:36:18 <benzrf> but dont care what it is atm
15:36:23 <benzrf> getName >> etc
15:37:07 <marchelzo_> so etc would have to be a Maybe Name as well? or at least a Maybe a?
15:37:21 <octophore> what is ((->) r) ?
15:37:31 <path[l]> benzrf: I sorta follow, but just to understand, what property of the list monad makes it such that sequence gives me all possible sequnces
15:38:37 <benzrf> path[l]: well
15:39:02 <benzrf> path[l]: sequence takes a list of mobits, then gives a mobit resulting in a list of results
15:39:06 <benzrf> path[l]: right?
15:39:24 <path[l]> yeah
15:39:43 <benzrf> path[l]: mobit bein used to mean 'monadic value' here
15:39:46 <benzrf> path[l]: ok
15:39:48 <path[l]> but it doesnt tell me how it merges the individual mobits (sorry my terminolgy is lacking)
15:39:54 <lyxia> octophore: ((->) r) x = r -> x
15:40:02 <benzrf> if you think of a list mobit as a computation giving multiple possible results
15:40:25 <benzrf> then you take a list of multi-output comps, then get a multi-output comp of lists of results of the inputs
15:40:45 <benzrf> path[l]: take [[1, 2, 3], [4, 5, 6], [7, 8, 9]]
15:41:09 <benzrf> path[l]: you have here a mobit yielding 1, 2, and 3, one yielding 4, 5, and 6, and one yielding 7, 8, and 9
15:41:29 <octophore> what's the term for that construct?
15:41:35 <Jefffrey> Hello everybody.
15:41:36 <Jefffrey> Is there a way to specify an external library (not from hackage), that resides on github, in a cabal file?
15:41:41 <benzrf> path[l]: now lets say you wanted to construct a mobit yielding lists of results, where each list of results is 1 from each source mobit?
15:42:11 <benzrf> path[l]: you'd make a mobit yielding every possible pick of outputs from each of the source mobits
15:42:18 <benzrf> path[l]: see what im sayin
15:43:17 <benzrf> path[l]: remember that when you use sequence on the list monad, you have lists being treated both as sequences and as multi-output computations
15:43:29 <benzrf> path[l]: you need to remember to mentally distinguish what each list involved is acting like
15:43:46 <Lutin`> marchelzo_: So you know how to do the dynamic programming approach for two characters yes?
15:44:56 <Lutin`> marchelzo_: i.e. the one that's on the wikipedia page
15:45:11 <marchelzo_> Hmm. Let me look at it.
15:45:34 <Lutin`> marchelzo_: Those properties they mention hold for any M sequences
15:45:40 <path[l]> benzrf: I  dont think my question was clear :). I meant, the sequence operation is trying to use some monadic operiton to merge two mobits. How does the list monad define this merge operation
15:46:34 <Zekka> > sequence [[1, 2], [3, 4], [5, 6], [7, 8]]
15:46:36 <lambdabot>  [[1,3,5,7],[1,3,5,8],[1,3,6,7],[1,3,6,8],[1,4,5,7],[1,4,5,8],[1,4,6,7],[1,4,...
15:46:52 <zwer> > sequence ["Ll", "Oo", "Ll"]
15:46:53 <lambdabot>  ["LOL","LOl","LoL","Lol","lOL","lOl","loL","lol"]
15:46:54 <benzrf> path[l]: oh
15:46:55 <octophore> does ((->) r) have something to do with the "Reader monad"?
15:46:56 <Zekka> (just as a reminder for those who don't know how it behaves on lists)
15:47:04 <benzrf> @src sequence
15:47:05 <lambdabot> sequence []     = return []
15:47:05 <lambdabot> sequence (x:xs) = do v <- x; vs <- sequence xs; return (v:vs)
15:47:05 <lambdabot> -- OR: sequence = foldr (liftM2 (:)) (return [])
15:47:50 <Iceland_jack> octophore: it sure does
15:47:50 <Iceland_jack> @unmtl Reader r a
15:47:50 <lambdabot> r -> a
15:48:19 <benzrf> path[l]: thats how sequence works on all monads
15:49:33 <marchelzo_> Lutin`: Ok. It's going to take me a while to figure out the algorithm, but I'll try to see where this takes me.
15:50:19 <benzrf> how does mtl differ from transformers
15:51:12 <hpc> mtl is built on transformers and adds more useful abstractions
15:55:02 <benzrf> :t view
15:55:04 <lambdabot> MonadReader s m => Getting a s a -> m a
15:55:06 <benzrf> hmmmm
15:55:10 <benzrf> :t preview
15:55:11 <lambdabot> MonadReader s m => Getting (First a) s a -> m (Maybe a)
15:55:16 <benzrf> coo
15:56:45 <Lutin`> marchelzo_: Just reread those conditions until it clicks
15:56:51 <benzrf> whats the methods on monadreader again
15:57:46 <johnw> benzrf: they are all in the Haddocks
15:57:55 <benzrf> im too lazy to pull it up :-:
15:58:06 <johnw> then you're too lazy to find out ;)
15:58:06 <benzrf> @haddock monadreader
15:58:07 <lambdabot> Unknown command, try @list
15:58:12 * benzrf pummels lambdabot 
15:58:21 <jfischoff> ask local
15:58:25 <johnw> @hoogle MonadReader
15:58:27 <benzrf> i dont have local
15:58:27 <lambdabot> Control.Monad.Reader.Class class Monad m => MonadReader r m | m -> r
15:58:28 <lambdabot> Control.Monad.Reader class Monad m => MonadReader r m | m -> r
15:58:30 <benzrf> god
15:58:48 <johnw> well, real Hoogle will get you to the docs in about a second
15:58:48 <path[l]> benzrf: let me put my question another way. I assume sequence is diferent on the maybe monad?
15:58:53 <benzrf> yeshuah:
15:58:54 <benzrf> *yes
15:59:05 <path[l]> > sequence [Mabye, Just 3, Just 5]
15:59:06 <lambdabot>  Not in scope: data constructor ‘Mabye’
15:59:10 <benzrf> path[l]: :P
15:59:16 <path[l]> > sequence [None, Just 3, Just 5]
15:59:17 <jfischoff> :t Data.Traversable.sequence
15:59:17 <lambdabot>  Not in scope: data constructor ‘None’
15:59:17 <lambdabot>  Perhaps you meant one of these:
15:59:17 <lambdabot>    ‘Node’ (imported from Data.Tree),
15:59:17 <lambdabot>    ‘Nonn’ (imported from Lambdabot.Plugin.Haskell.Eval.Trusted)
15:59:18 <lambdabot> (Traversable t, Monad m) => t (m a) -> m (t a)
15:59:21 <bunky> Anyone know where I can find a good resource about hacking into a dd-wrt router from WAN side?
15:59:23 <path[l]> > sequence [Nothing, Just 3, Just 5]
15:59:24 <ryantrinkle> are there any good options for generating SQL from an AST?
15:59:25 <lambdabot>  Nothing
15:59:27 <path[l]> ah
15:59:33 <path[l]> > sequence [Just 2, Just 3, Just 5]
15:59:34 <lambdabot>  Just [2,3,5]
15:59:36 <jfischoff> :t T.sequence
15:59:37 <lambdabot> (Traversable t, Monad m) => t (m a) -> m (t a)
16:00:22 <benzrf> ryantrinkle: sounds like a bad idea to me!
16:00:29 <ryantrinkle> benzrf: how come?
16:00:35 <path[l]> benzrf: so does the Maybe Monad and the list Monad define an operation that takes two mobits and returns a new mobit?
16:01:15 <benzrf> path[l]: yes, (>>)
16:01:19 <benzrf> path[l]: do you know monads?
16:01:23 <bunky> I know all open ports and -A from a LAN side nmap scan...
16:01:48 <path[l]> benzrf: I have some idea, but still not a very clear one :)
16:02:00 <quchen> bunky: This is a Haskell (only) channel.
16:02:45 <path[l]> benzrf: I’ve often seen people talk about bind (>>=) and return. Not so much about (>>) (whose name I dont know)
16:02:59 <benzrf> then
16:03:09 <benzrf> it's actually defined in terms of (>>=)
16:03:15 <benzrf> @src (>>)
16:03:16 <lambdabot> m >> k      = m >>= \_ -> k
16:04:51 <path[l]> @src (>>=)
16:04:51 <lambdabot> Source not found. You type like i drive.
16:04:58 <path[l]> can I find the source of that for List
16:05:14 <quchen> Lambdabot @src database: https://github.com/int-e/lambdabot/blob/master/lambdabot/State/source
16:05:41 <Total_1mmersion> Why is -> the symbol in lambda expressions instead of =?
16:05:44 <quchen> ?src [] (>>=)
16:05:44 <lambdabot> xs >>= f     = concatMap f xs
16:06:06 <kini> what I want to know is why it's -> instead of .
16:06:19 <octopuscabbage> has anyone written an emulator in haskell? if so, how did that go?
16:06:27 <benzrf> int-e: do u ever plan to actually add :i
16:06:30 <kini> octopuscabbage: an emulator of what?
16:06:33 <lfairy> Total_1mmersion: it's consistent with -> in type signatures
16:06:39 <octopuscabbage> kini: some old system
16:06:55 <kini> i.e. a computer system? I dunno, probably
16:06:57 <Total_1mmersion> lfairy, true, but inconsistent with = in top level functions or let bindings
16:07:07 <kini> lambda abstraction isn't definition
16:07:23 <lfairy> what kini said
16:07:26 <kini> \lambda x . x^2 isn't saying that anything is "equal to" x^2
16:07:26 <rwbarton> a definition "f x = x + 1" can also be read as an equation
16:07:33 <rwbarton> right
16:07:46 <octopuscabbage> kini: i understand that there exists a person who /has/ done it, i more meant here that could tell me about their experience with it
16:08:08 <kini> octopuscabbage: hehe, sorry :) I would be interested to hear about that too
16:08:22 <Total_1mmersion> I'm still not seeing how f x = x^2 is different from \x . x^2
16:08:37 <kini> Total_1mmersion: "f x = x^2" defines the entity "f"
16:08:45 <octopuscabbage> kini: my interest stems a lot from trying to take a task that seems like it would be almost inheritly imperative into a functional system.
16:08:57 <kini> f x = x^2 is (mathematically) equivalent to f = \lambda x . x^2
16:09:12 <kini> just \lambda x . x^2 by itself is a value, a mathematical object
16:09:19 <kini> it's not a statement or a claim or an axiom or a definition
16:09:43 <kini> octopuscabbage: basically you'd throw it all in a monad I imagine :)
16:10:03 <Total_1mmersion> Oh, so different symbols are used for naming something and creating a lambda?
16:10:06 <Total_1mmersion> that makes sense
16:11:39 <quchen> I guess they didn't take "." for lambdas because that's very awkward to read when the language has a "." operator elsewhere already.
16:11:46 <kini> personally I wouldn't think of either of those as an "action" per se. "f x = x^2" is a statement (says something) and "\ x -> x^2" is a value (is something)
16:11:49 <path[l]> quchen: ah I see. so it’s concatMap … hmm let me think. 
16:11:51 <kini> neither one "does something"
16:11:52 <path[l]> @src sequence
16:11:52 <lambdabot> sequence []     = return []
16:11:52 <lambdabot> sequence (x:xs) = do v <- x; vs <- sequence xs; return (v:vs)
16:11:52 <lambdabot> -- OR: sequence = foldr (liftM2 (:)) (return [])
16:12:17 <quchen> path[l]: This should be easier to understand, https://github.com/quchen/articles/blob/master/functions_comprehensible.md#sequencemapm
16:12:34 <path[l]> thanks, let me look at that :)
16:13:23 <benzrf> @t 3
16:13:24 <lambdabot> Maybe you meant: tell thank you thanks thesaurus thx tic-tac-toe ticker time todo todo-add todo-delete type v @ ? .
16:13:27 <benzrf> hmmm
16:13:28 <benzrf> @thx
16:13:28 <lambdabot> you are welcome
16:13:30 <benzrf> ok
16:14:08 <geekosaur> you wanted :t / @type maybe?
16:14:18 <benzrf> i was testing if @t was a thing
16:14:21 <benzrf> i know about those :)
16:14:48 <Lutin`> marchelzo_: Any luck?
16:15:56 <marchelzo_> No :| Is the method you're referring to the one where you make a table filled with 0s and then iterate over the rows, comparing the letters in each string?
16:16:23 <Lutin`> marchelzo_: nono
16:16:46 <Lutin`> marchelzo_: Just the definition of the LCS function
16:17:01 <zwer> Total_1mmersion by the way, f x = x*2  is syntactic sugar for f = \x -> x*2
16:17:03 <marchelzo_> Is it the longest suffix of the pairs of prefixes?
16:17:04 <Lutin`> Based on the first and second property
16:17:19 <Lutin`> That's the second property yes
16:17:28 <quchen> zwer: No, it is not.
16:17:30 <Lutin`> But it holds also for the longest prefix of the pairs of suffixes
16:17:34 <marchelzo_> Oh... are you on the wikipedia page for Longest common subsequence?
16:17:39 <Lutin`> Yes
16:17:41 <zwer> quchen how so?
16:17:49 <marchelzo_> I was on longest common substring
16:17:52 <Lutin`> Ah
16:17:59 <marchelzo_> I see now the properties you are talking about
16:18:12 <Lutin`> Crap that's a different algo
16:18:15 <Lutin`> one sec
16:18:35 <quchen> zwer: GHC handles those two differently, for example in inlining.
16:18:57 <quchen> (And the Report doesn't define them as equal as well.)
16:19:20 <path[l]> is there an equivalent of @src inside ghci
16:19:29 <benzrf> no
16:19:30 <Total_1mmersion> zwer, yep
16:21:23 <s6sdde> How can I make sure that a string is written to a file before I attempt to read the file?  In other words, how can I force an IO action?  Both actions happen inside forkIO if it's important.
16:22:31 <benzrf> :t f
16:22:32 <lambdabot> FromExpr a => a
16:22:35 <benzrf> mm
16:23:51 <benzrf> @let {-# LANGUAGE Testing #-}
16:23:52 <lambdabot>  Parse failed: Parse error: EOF
16:23:54 <benzrf> lame!
16:25:37 <octopuscabbage> is there a flag in ghc so that it will print stack trace on unhandled exceptions
16:25:42 <quchen> zwer: There are also subtleties with the DMR and lambda-vs-"="-definitions, see the DMR section of the Report (search "The monomorphism rule has a number of consequences").
16:30:56 <Lutin`> marchelzo_: Do you want to do the dynamic programming or the generalize suffix tree approach?
16:31:41 <octopuscabbage> Does anyone have a link for a tutorial on DSLs? I don't really get what they are.
16:31:58 <marchelzo_> I'm leaning toward the suffix tree, but I have no idea how to do it. I've never taken a data structures / algorithms class, but I'm watching a youtube video on it atm.
16:33:16 <s6sdde> octopuscabbage: try searching for "lennart augustsson dsl"
16:34:53 * hackagebot haddock-library 1.0.1 - Library exposing some functionality of Haddock.  http://hackage.haskell.org/package/haddock-library-1.0.1 (MateuszKowalczyk)
16:36:24 <zwer> quchen ok. a bit surprising that ghc output can be different for the two functions
16:44:54 <kini> <quchen> I guess they didn't take "." for lambdas because that's very awkward to read when the language has a "." operator elsewhere already.
16:44:54 <kini> I guess, but they did take "." for the "forall" keyword which does type-level lambda abstraction, in a sense
16:45:18 <quchen> But there is no "." on the type level :-þ
16:46:14 <quchen> On the type level, both -> and => were already taken anyway, so using them for forall was probably hard
16:46:58 <kini> well, the -> on the type level is sort of the same thing as the "forall" and "." combo, isn't it? :P
16:47:17 <kini> and so is the =>, maybe...
16:48:20 <octopuscabbage> >>= has a different meaning per monad correct?
16:48:54 <kini> well, depends on what you mean by "different" :P
16:49:16 <octopuscabbage> different function attached to it (not just different in type)
16:49:21 <johnw> yes
16:49:45 <octopuscabbage> does anyone wanna take a bat at explaining what it does to me (i really don't understand monads very well, i've watched at least 3 hours of video on them)
16:50:43 <octopuscabbage> actually
16:50:45 <octopuscabbage> a better questoin would be
16:50:47 <octopuscabbage> when do i use a monad?
16:51:00 <Iceland_jack> octopuscabbage: spending 3 hours using monads would have been a better bet :)
16:51:13 <marchelzo_> Have you read LYAH? It might give you some idea of how they are useful
16:51:25 <sie> octopuscabbage, You can use it to IO.
16:51:28 <hpc> octopuscabbage: do you understand Applicative?
16:51:39 <hpc> or Functor?
16:51:43 <hpc> or type classes in general?
16:52:12 <marchelzo_> I get lost at Applicative
16:52:27 <benzrf> marchelzo_: think of Applicative in terms of (**) not (<*>)
16:52:30 <benzrf> 1 sec
16:52:47 <benzrf> @let x ** y = liftA2 (,) x y
16:52:49 <lambdabot>  Defined.
16:52:53 <benzrf> :t (**)
16:52:54 <lambdabot>     Ambiguous occurrence ‘**’
16:52:54 <lambdabot>     It could refer to either ‘L.**’,
16:52:54 <lambdabot>                              defined at /home/lambda/.lambdabot/State/L.hs:149:3
16:52:57 <benzrf> dang
16:53:01 <johnw> huh?
16:53:02 <benzrf> :t (L.**)
16:53:04 <lambdabot> Applicative f => f a -> f b -> f (a, b)
16:53:07 <benzrf> marchelzo_: ^
16:53:18 <benzrf> marchelzo_: this is isomorphic to the real applicative
16:53:21 <benzrf> and easier to grok
16:53:29 <johnw> how is that?
16:53:43 <benzrf> marchelzo_: Applicative lets you take 2 functorial values and merge them into 1
16:53:45 <marchelzo_> Functor's usefulness is immediately obvious. fmap's applications are very clear. But the ability to do something like Just (*2) <*> Just 5 doesn't seem useful.
16:54:09 <johnw> marchelzo_: (*) <$> Just 2 <*> Just 5 is a bit easier to see the necessity of
16:54:19 <octopuscabbage> Iceland_jack: I kind of have to know how they work to use them don't i? :P
16:54:30 <octopuscabbage> sie: I understand that much, is it just for 'tainted' operations
16:54:35 <Iceland_jack> octopuscabbage: Do you?
16:54:36 <johnw> since it's just fmap (*) (Just 2) <*> Just 5, or Just (2 *) <*> Just 5 or Just (2 * 5)
16:54:36 <octopuscabbage> hpc: I don't think so
16:54:54 <hpc> octopuscabbage: you should learn type classes, then Functor, then Applicative, then Monad
16:55:07 <sie> octopuscabbage, Well not only for that. It's just that IO fits well in the data pipelines that monads describe.
16:55:08 <hpc> there's a lot of conceptual dependencies that will be hell to slog through all at once
16:55:10 <octopuscabbage> Iceland_jack: I mean I /know/ how to use the IO monad, but i don't really know why it's a monad or anything
16:55:22 <octopuscabbage> sie: so a monad is just for pipelining data?
16:55:23 * hackagebot AttoBencode 0.2.1.0 - Fast Bencode encoding and parsing library  http://hackage.haskell.org/package/AttoBencode-0.2.1.0 (FlorianHartwig)
16:55:28 <Iceland_jack> octopuscabbage: Okay, then pick a different monad and try using that
16:55:31 <hpc> plus Functor/Applicative are pretty rad on their own
16:55:41 <Iceland_jack> but also learn about Functors first
16:55:57 <sie> octopuscabbage, I think so
16:56:12 <sie> correct me if I'm wrong, someone
16:56:16 <marchelzo_> johnw: I still don't see when that would be useful. Then again, I don't use Maybe very often.
16:56:59 <Iceland_jack> monads are not really for pipelining, it's also good to avoid trying to find analogies for monads
16:57:01 <Iceland_jack> :)
16:57:54 <johnw> marchelzo_: say you have a value constructor that takes 10 arguments, and the values for all ten arguments come from executing IO actions
16:58:11 <johnw> with the IO monad, you'd bind all ten results to variables, and then call the constructor as normal with those values
16:58:28 <johnw> with Applicative, you can say: Ctor <$> actionOne <*> actionTwo <*> actionThree ...
16:59:19 <johnw> now, you don't have to use Applicative to get that done, you could always use the monad as I mentioned; but there are times when it can be quite convenient to not have to bind everything to intermediary names
16:59:39 <johnw> this becomes especially clear in writing parsers using a library like Parsec
16:59:46 <johnw> or JSON parsers for aeson
17:00:40 <marchelzo_> johnw: ah yes, that does seem useful.
17:01:45 <marchelzo_> What is <- called in do blocks?
17:01:51 <Iceland_jack> marchelzo_: you can call it bind
17:01:54 <johnw> binding the result to a name
17:02:00 <octopuscabbage> it's shorthand for a lambda expression (kind of)
17:02:06 <johnw> which is actually what it does too
17:02:09 <marchelzo_> isn't >>= bind, though?
17:02:10 <Iceland_jack> octopuscabbage: no it isn't
17:02:13 <johnw> x <- foo turns into foo >>= \x ->
17:03:08 <crocket> Do haskell-to-js transpilers have value on the web?
17:03:57 <nisstyre> crocket: ask luite
17:04:47 <sie> Iceland_jack, Hmm, well okay. It doesn't always actually send any data, but still there's a chain of operations, so it's somewhat like a pipeline still, no?
17:04:52 <marchelzo_> Hmm. I think I just need to mess around with some more monads, to get a feel for them. What are some that have obviously useful implementations of bind?
17:05:02 <crocket> haskell dudes don't seem to focus on the web.
17:05:12 <flebron> Hi. Continuing trying to understand Theorems for Free. Say I have a term t with type T. I can generate a relation R and I know (t, t) is in R by parametricity. What is, conceptually, R?
17:05:39 <flebron> marchelzo_: [], reader, writer, state, and IO come to mind.
17:05:57 <flebron> Oh, and can't forget maybe.
17:05:59 <crocket> nisstyre, What does he know?
17:06:11 <marchelzo_> flebron: thanks
17:07:05 <nisstyre> crocket: https://github.com/luite/ghcjs
17:07:27 <crocket> luite, Tell me how haskell has value on web browsers.
17:08:12 <ajcoppa> http://www.haskell.org/haskellwiki/The_JavaScript_Problem
17:08:47 <crocket> While clojurescript has focus on the web, ghcjs merely looks like an attempt to try haskell on the web.
17:08:52 <nisstyre> crocket: also as someone writing a javascript compiler for a functional/typed language, apart from learning purposes, I want to write cleaner easier to understand code that runs in my browser
17:09:09 <nisstyre> *that is, a compiler in javascript, not a compiler for javascript
17:09:16 <crocket> nisstyre, You also need a maturing ecosystem.
17:09:43 <nisstyre> crocket: it's mostly for myself, also it will be able to hook into the DOM and perhaps other libraries in plain JS
17:09:53 <crocket> The web requires a complex graph of libraries.
17:10:04 <crocket> I'm not sure ghcjs has it yet.
17:10:36 <nisstyre> crocket: it's similar to using C libraries in Haskell, you have to figure out how to create a typed interface to it
17:11:02 <crocket> nisstyre, That sounds as if I almost had to build an ecosystem from scratch.
17:11:08 <hpc> crocket: complex in that parts of the graph are imaginary? ;)
17:11:59 <nisstyre> crocket: it's not free if that's what you mean
17:12:08 <johnw> marchelzo_: check out Identity and Const too, and prove to yourself why Const can't be a monad, although it is an Applicative
17:12:15 <crocket> nisstyre, I'll wait for a few years.
17:12:42 <marchelzo_> johnw: I'll try
17:14:07 <ajcoppa> marchelzo_: in case it hasn't already been recommended, the NICTA course is fantastic for gaining a deep understanding of functors/applicatives/monads
17:14:15 <Lutin`> Oh man
17:14:31 <marchelzo_> ajcoppa: Thanks, I'll check it out.
17:14:34 <ajcoppa> https://github.com/NICTA/course
17:14:53 <ajcoppa> it's pretty challenging, but well worth it. ask questions if you need help
17:15:09 <Lutin`> Reading more and more suffix tree algorithms I'm realizing how many of them are more easily implemented in C++ et al
17:15:35 <marchelzo_> Lutin`: Yeah
17:15:41 <octopuscabbage> why does the NICTA link to scalaz
17:15:57 <Lutin`> marchelzo_: I mean we can do it in haskell with an Array
17:16:17 <Lutin`> But the whole direct memory access is what a lot of these runtimes hinge on
17:16:27 <octopuscabbage> What does the haskell and functional programming job market look like? is it growing, if so at what rate?
17:17:00 <Lutin`> marchelzo_: Plus mutability is a real benefit in this case
17:17:03 <ajcoppa> octopuscabbage: i think it just mentions it since a lot of the community around the NICTA course consists of scala'ers too
17:17:33 <Lutin`> marchelzo_: I'm interested in seeing the answers in haskell to this problem once we solve it
17:17:41 <marchelzo_> Lutin`: me too
17:18:27 <marchelzo_> I bet David Powell will have done it in haskell
17:18:35 <Lutin`> marchelzo_: I mean at this point I want to just drop to C++ :X
17:19:14 <marchelzo_> Lutin`: Yeah. I thought about trying my old method in C. The strings might be small enough that you could brute force it
17:19:38 <Lutin`> The generalized suffix tree looks like the best way to solve this
17:19:51 <marchelzo_> Yeah
17:21:19 <Lutin`> But Ukonnen's algorithm, which is what most of the Theta(N) runtimes hinge on has a lot to grasp
17:21:37 <dmwit> ?src Const
17:21:38 <lambdabot> Source not found. I've seen penguins that can type better than that.
17:21:49 <dmwit> data Const a b = Const a -- ?
17:22:13 <octopuscabbage> Can anyone recommend a haskell gui library?
17:22:38 <dmwit> Do you already know gtk, wx, or qt from another language?
17:22:39 <hpc> octopuscabbage: take your pick of haskell interfaces to general gui libraries
17:22:39 <johnw> data Const a b = Const a
17:22:57 <Lutin`> dmwit: The one in Control.Applicative is 'newtype Const a b = Const { getConst :: a }'
17:23:09 <lordcirth> Qt is more multiplatform than gtk
17:23:29 <hpc> Qt has awful haskell bindings iirc
17:25:24 <lordcirth> It must be harder to bind an imperative lib to a functional language tho
17:25:53 <zwer> what about wxWidgets?
17:27:56 <luite> crocket: sorry i missed some stuff, busy writing build scrips for ghcjs. any questions
17:30:56 * hackagebot OpenSCAD 0.1.0.0 - ADT wrapper and renderer for OpenSCAD models.  http://hackage.haskell.org/package/OpenSCAD-0.1.0.0 (MikeMeyer)
17:35:47 <johnw> in a cabal file, how do I say that I want to do something only if it's newer than a certain version of GHC?
17:37:05 <luite> johnw: impl(ghc >= version)
17:37:09 <luite> flag
17:37:28 <johnw> thanks!
17:39:41 <marchelzo_> ajcoppa: I cloned the repo, and I'm in ghci, what do I do, though? How do I know what the problem is that I have to solve?
17:39:52 <marchelzo_> ajcoppa: for the NICTA thing
17:40:16 <ajcoppa> marchelzo_: check out the README, there are some instructions there
17:40:41 <marchelzo_> Yeah it just says the first recommended exercise is Course.List
17:41:54 <ajcoppa> check out src/Course/List.hs
17:42:50 <marchelzo_> ah ok, so the descriptions are in the source
17:42:54 <marchelzo_> thanks
17:43:15 <ajcoppa> yep, and the same will be true for all the exercises
17:44:01 <marchelzo_> haha yeah that sort of follows
17:46:26 * hackagebot git-gpush 3.1.0 - More intelligent push-to-GitHub utility.  http://hackage.haskell.org/package/git-gpush-3.1.0 (JohnWiegley)
17:46:29 * hackagebot git-monitor 3.1.1.1 - Passively snapshots working tree changes efficiently.  http://hackage.haskell.org/package/git-monitor-3.1.1.1 (JohnWiegley)
17:46:30 * hackagebot gitlib 3.1.0 - API library for working with Git repositories  http://hackage.haskell.org/package/gitlib-3.1.0 (JohnWiegley)
17:46:32 * hackagebot gitlib-cmdline 3.1.0 - Gitlib repository backend that uses the git command-line tool.  http://hackage.haskell.org/package/gitlib-cmdline-3.1.0 (JohnWiegley)
17:46:34 * hackagebot gitlib-cross 3.1.0 - Run tests between repositories  http://hackage.haskell.org/package/gitlib-cross-3.1.0 (JohnWiegley)
17:46:35 <benzrf> o.o
17:46:44 <benzrf> johnw: busy?
17:48:10 <bitemyapp> johnw: actually, I'd like to know how you did the batch push.
17:48:21 <bitemyapp> johnw: do you have a script with your username and password in it?
17:50:51 <pepper_chico> man... LYAH is really beginner level in all aspects, not just haskell/FP...
17:51:34 <Welkin> that's the point
17:51:36 * hackagebot gitlib-libgit2 3.1.0 - Libgit2 backend for gitlib  http://hackage.haskell.org/package/gitlib-libgit2-3.1.0 (JohnWiegley)
17:51:38 * hackagebot gitlib-s3 3.1.0 - Gitlib repository backend for storing Git objects in Amazon S3  http://hackage.haskell.org/package/gitlib-s3-3.1.0 (JohnWiegley)
17:51:40 * hackagebot gitlib-sample 3.1.0 - Sample backend for gitlib showing the basic structure for any backend.  http://hackage.haskell.org/package/gitlib-sample-3.1.0 (JohnWiegley)
17:51:42 * hackagebot gitlib-test 3.1.0 - Test library for confirming gitlib backend compliance  http://hackage.haskell.org/package/gitlib-test-3.1.0 (JohnWiegley)
17:52:06 <crocket> luite, Does ghcjs have value on the web now?
17:52:15 <crocket> luite, Does it have some web frameworks?
17:52:20 <MP2E> LYAH was a quite enlightening book. I particularly like it because it never forgets to tell you _why_ you're learning the concept you're learning
17:52:45 <octopuscabbage> LYAH might be the worst programming book i've ever read, but man did i enjoy reading it
17:52:51 <MP2E> with Real World Haskell I couldn't help but feel that I had no idea why what I was learning was useful :P
17:53:02 <MP2E> RWH helped a lot as the second book though
17:53:56 <pepper_chico> it's nice, but, I'm a programmer for years already... and I've used FP more or less in other languages, it's a nice read, indeed it's well written, I like the humor, and the funny drawings, but
17:54:50 <MP2E> ah yeah I could see how it wouldn't help if you were already experienced with FP
17:54:53 <pepper_chico> it needs to explain what are command line arguments, not just how they are used in haskell, but what they are, and there's a lot of stuff in this sense
17:55:03 <orzo> why's it "for Great Good!" instead of "for Great Justice!"
17:55:06 <pepper_chico> which is ok for a beginner in programming in general
17:55:10 <pepper_chico> but not for me
17:56:26 * hackagebot haxr 3000.10.3 - XML-RPC client and server library.  http://hackage.haskell.org/package/haxr-3000.10.3 (BrentYorgey)
17:57:00 <pepper_chico> anyway, I still will try to finish it, but it's sometime boring in all the explanation stuff =D
17:58:01 <path[l]> @src mapM
17:58:01 <lambdabot> mapM f as = sequence (map f as)
17:58:56 <pepper_chico> @src mapM_
17:58:56 <lambdabot> mapM_ f as = sequence_ (map f as)
17:59:34 <pepper_chico> didn't know about sequence_ =D, not in LYAH at this point yet
18:00:52 <path[l]> I dont understand why I cant rewrite sequence (map f as) as sequence.(map f) as … isnt that the same thing
18:00:59 <path[l]> :t sequence_
18:01:01 <lambdabot> Monad m => [m a] -> m ()
18:01:08 <benzrf> path[l]: precedence
18:01:14 <benzrf> sequence . (map f) as
18:01:16 <benzrf> gets parsed as
18:01:19 <benzrf> sequence . ((map f) as)
18:01:21 <benzrf> you want
18:01:26 <benzrf> (sequence . (map f)) as
18:01:29 <path[l]> ah
18:01:32 <benzrf> or
18:01:35 <benzrf> sequence . (map f) $ as
18:01:40 <path[l]> for some reason I expected . to have much higher precedence
18:01:44 <path[l]> ok cool :)
18:01:50 <benzrf> path[l]: no, function app is ALWAYS highest precedence
18:01:51 <benzrf> period
18:02:01 <path[l]> :)
18:02:14 <benzrf> which means you get strange-looking things like 'foo bar:baz' is '(foo baz):baz' and not 'foo (bar:baz)'
18:02:28 <benzrf> *(foo bar):baz i mean
18:03:23 <magicman> Is there a library for resources that are somehow cached?
18:04:15 <magicman> Like... it has an internal MVar of the latest change time, and the latest known value, and instead of reading the file and doing complicated things, just use the latest known value when the latest known change time is the same as the actual last modification time.
18:04:24 <magicman> (or whatever implementation)
18:10:19 <marchelzo_> ajcoppa: I'm confused by these custom data types. What am I allowed to use without it being considered cheating?
18:12:03 <ajcoppa> the custom data types can be a little confusing if you are already used to using normal lists in haskell. you should have everything you need in that file though
18:13:06 <marchelzo_> but I'm allowed to use guards, lambdas, list comprehensions, etc.?
18:14:23 <ajcoppa> i don't think list comprehensions will help you, but the others are fine
18:15:48 <marchelzo_> right... there are no lists. haha. But yes I have basically just been using foldLeft and foldRight with lambas for every problem and was wondering if that is considered cheating. I guess it's ok, though. Thanks
18:15:58 <ajcoppa> nope, that's totally fine
18:15:58 <marchelzo_> lambdas*
18:16:00 <marchelzo_> ok
18:20:44 <mindeavor> hi, I just caball installed something for the first time. It worked, but I got hundreds of warnings, almost all of them being “missing terminating ' character”. Should I be worried?
18:20:56 <benzrf> mindeavor: probably not
18:21:01 <benzrf> you didnt do it as root did you
18:21:04 * knappador is away: Day of Delivery
18:21:06 <Lutin`> Oh man
18:21:07 <mindeavor> nope, no root
18:21:10 <benzrf> good
18:21:23 <Lutin`> marchelzo_: So I couldn't figure out what I used for Rosalind before, so I'm starting from the beginning :(
18:21:47 <marchelzo_> Lutin`: aww that's lame
18:22:08 <mindeavor> benzrf: do you know why it’s happening? does it have to do something with compiler versions?
18:26:22 <Lutin`> marchelzo_: I think I overkilled the first one
18:26:23 <Lutin`> http://ix.io/d2c/hs
18:26:27 <Lutin`> brb
18:30:37 <path[l]> can someone help me with performance. I have this quickcheck test http://lpaste.net/105823 … and it crawls. I wonder if some of it is the whole strict/nonstrict thing, or this is inevitable
18:32:06 <benzrf> i should learn scala
18:32:17 <marchelzo_> why
18:32:17 <Welkin> why?
18:32:27 <MP2E> ^
18:32:45 <benzrf> why not
18:32:59 <benzrf> is more knowledge suddenly a bad thing o3o
18:33:09 <benzrf> and what if i have to do something on the jvm for some reason
18:33:18 <marchelzo_> i guess
18:33:39 <marchelzo_> java is out of the question I take it?
18:33:51 <benzrf> i already know java
18:33:53 <Hafydd> It can be a bad thing, if you waste your time while learning it, or even set your education astray.
18:34:19 <marchelzo_> well there you go. if you need to do something on the jvm you can use java
18:34:33 * benzrf reaspberries at Hafydd 
18:34:34 <MP2E> "object oriented meets functional" on scala's front page.. dear dear :P
18:34:35 <benzrf> *raspberries
18:34:42 <MP2E> Someone hasn't heard of comonads, it seems
18:34:51 <benzrf> since when are comonads oo
18:34:57 <MP2E> comonads supercede oo
18:35:01 <benzrf> lol sure
18:35:21 <yogurt_truck> anything supercedes oo
18:35:26 <MP2E> also this ^
18:35:38 <benzrf> sounds to me like somebody only knows of OO through java
18:35:47 <MP2E> i know of OO through C++, which might be worse :P
18:36:07 <benzrf> probably
18:36:20 * yogurt_truck prefers definitions #34 and #128 of OO. those are the right ones!
18:37:57 <yogurt_truck> she said that he said that they said that alan kay said that william cook said that gilad bracha said that the Java folks said what OO "is *really* about"!
18:38:35 <path[l]> anyone?
18:39:24 * benzrf shrugs @ path[l] 
18:39:40 <path[l]> oh ok, I was hoping it was something obvious :)
18:39:58 <benzrf> yogurt_truck: OOP = bundling behavior with data in a single interface
18:40:09 <dsturnbull> where are you seeing "#34 and #128"?
18:40:42 <yogurt_truck> benzrf: yes, that's definition #13.
18:47:28 * hackagebot dns 1.4.0 - DNS library in Haskell  http://hackage.haskell.org/package/dns-1.4.0 (KazuYamamoto)
18:54:28 <Ralith> anyone know any good CAD file format libraries?
18:58:14 <crocket> yogurt_truck, Do you know any altjs language other than clojurescript that has nice web frameworks?
19:01:08 <Lutin`> marchelzo_: How's it goin?
19:03:21 <marchelzo_> Lutin`: Ehh I got side tracked. I started doing the NICTA functional programming course.
19:03:31 <marchelzo_> The suffix trees are over my head.
19:07:40 <yogurt_truck> crocket: ur/web
19:10:38 <Ralith> ur/web is pretty great
19:12:57 <crocket> yogurt_truck, YourWeb might be great.
19:13:00 <crocket> MyWeb is not.
19:16:38 <benzrf> crocket: :-O
19:26:10 * flebron wonders if people have read the Theorems for Free paper and could answer some questions.
19:38:23 <ninja_code> in writing distributed haskell progs, how does one deal with things like "that machien died" or "the disk is full" or "that process get killed by the kernel" ? [ erlang's solution to all these appears to be supervisor threads -- what is the haskell solution to this ]
19:43:10 <Lutin`> ninja_code: Cloud Haskell takes after Erlang in that and many other regards
19:44:40 <ninja_code> Lustin`: interesting; thanks
19:50:54 <genericpersona> Lutin`: how advanced/stable is Cloud Haskell? have you used it successfully?
19:51:17 <Cale> ninja_code: You might find this talk interesting: https://www.youtube.com/watch?v=1jJ2paFuErM
19:51:41 <Lutin`> genericpersona: Never used it, just read up on it real quick
19:51:47 <Cale> More recently (just a few days ago) this package was released: http://hackage.haskell.org/package/distributed-process-platform
19:51:53 <genericpersona> it sounds pretty awesome
19:52:04 <ninja_code> so it sounds like the short answer is
19:52:08 <genericpersona> erlang always seemed like a worthwhile and necessary language
19:52:16 <ninja_code> "people smarter than you are working on it; don't worry about it, buy the time you need it, it'll be ready" :-)
19:52:54 <Cale> ninja_code: It already looks pretty usable, but I don't know about how many people have put it to use yet
19:56:02 <Lutin`> Man I wish I could go to ICFP
19:56:20 <Lutin`> But it's a 15h plane ride and abou $1000 roundtrip
19:57:20 <genericpersona> where are they holding it?
19:58:11 <Lutin`> Gothenburg, Sweden
20:00:32 <Lutin`> Plus it's a bit expensive even for a student
20:11:29 * hackagebot samtools 0.2.3 - Binding to the C samtools library  http://hackage.haskell.org/package/samtools-0.2.3 (NicholasIngolia)
20:42:03 * hackagebot handle-like 0.0.0.10 - HandleLike class  http://hackage.haskell.org/package/handle-like-0.0.0.10 (YoshikuniJujo)
20:45:41 <Rotaerk_> is there a typeclass with this signature:  class Foo a b where { blah :: a -> b }
20:46:00 <Rotaerk_> if not, I'm making one called "Reports" or "Conveys"
20:46:05 <Rotaerk_> or something
20:46:51 <dwcook> Rotaerk_: Coercible
20:47:00 <dwcook> Though it has a fairly specific use if I recall
20:47:04 <augur> @hoogle a -> b
20:47:07 <lambdabot> Unsafe.Coerce unsafeCoerce :: a -> b
20:47:07 <lambdabot> Prelude ($) :: (a -> b) -> a -> b
20:47:07 <lambdabot> Data.Function ($) :: (a -> b) -> a -> b
20:49:03 <Rotaerk_> well I'm using this for error reporting... for instance:  (Reports ErrorType1 e, Reports ErrorType2 e) => EitherT e IO Program
20:49:29 <Rotaerk_> i guess I could just make my own typeclass even if it has the same signature, since it has a different ... purpose
20:49:36 <Redz> how can i format floating point numbers for printing?
20:49:48 <Rotaerk_> Redz: show?
20:49:54 <Rotaerk_> or do you mean custom format
20:50:05 <dwcook> Rotaerk_: Sounds like you're reinventing the exception system
20:50:19 <Rotaerk_> dwcook: it's not exactly the same as the exception system
20:50:44 <dwcook> The real question is whether it's isomorphic :)
20:50:50 <dwcook> </facetious>
20:51:05 <Rotaerk_> heh
20:51:16 <Rotaerk_> EitherT SomeException IO Program is less... specific
20:51:57 <dwcook> Hmm, actually, I seem to recall there being an interesting article about error handling
20:52:03 <dwcook> @google Albert Lai error
20:52:05 <lambdabot> http://ca.linkedin.com/in/albertlai
20:52:05 <lambdabot> Title: Albert Lai - Canada | LinkedIn
20:52:06 <Rotaerk_> I prefer ADT-based error reporting, but without the huge amount of overlapping ADTs
20:52:07 <Redz> Rotaerk_: cutting some digits behind the comma.
20:52:07 <dwcook> Not that
20:52:24 <Rotaerk_> so this allows the caller to define how to capture errors
20:52:34 <Rotaerk_> into an ADT, into a string, into an exception, whatever
20:53:01 <dwcook> Heh, never mind, the article I was thinking of must not have been written by him
20:53:18 <Redz> i know there is a nice function somewhere, but i can't find the module.
20:54:44 <dwcook> http://www.randomhacks.net/2007/03/10/haskell-8-ways-to-report-errors/
20:54:54 <dwcook> Might not be directly pertinent, but you reminded me of it
20:55:09 <Rotaerk_> I've read that one
20:55:28 <Rotaerk_> I've been spending a decent amount of time looking at all the error reporting mechanisms, and not really liking any of them
20:55:54 <Rotaerk_> the "simple stupid" approach is just to define an ADT to encapsulate all the error conditions, but that leads to headache
20:57:32 <Rotaerk_> and this approach I'm doing uses typeclasses to construct a union of sorts in the function signature
20:57:46 <Rotaerk_> without having all those overlapping ADTs everywhere
20:59:51 <Rotaerk_> though it is a tad verbose
21:00:09 <Rotaerk_> buildProgramFromSource :: (Reports (ListElementError ShaderCompileError) e, Reports ProgramLinkError e) => [ShaderDescription] -> EitherT e IO Program
21:06:58 <Rotaerk_> yay, thunderstorm !
21:10:18 <sinelaw> Greetings
21:10:39 <sinelaw> My program is hitting the memory ceiling
21:10:50 <sinelaw> Trying to figure out why.
21:11:26 <sinelaw> what type of profiling output is useful for that?
21:13:52 <mbuf> is there a way to do semantic checks on XML data with Haskell?
21:30:43 <diwank> Hey guys, haskell newbie here. Need some help with an unresolved overloading error
21:30:55 <bjornars> diwank: just ask
21:31:05 <joelteon> paste away
21:32:19 <diwank>  I really cant seem to figure out why this function gives an unresolved overloading error when I try to run it.   sum' :: (Num a) => [a] -> a \ sum' [] = 0 \ sum' (x:xs) = x + sum' xs
21:32:46 <diwank> \ : newline
21:33:31 <joelteon> okay, can you paste the actual compiler error?
21:33:39 <joelteon> lpaste.net
21:33:45 <diwank> Here is the trace
21:33:51 <diwank> sum' [1 1 2] ERROR - Unresolved overloading *** Type       : (Num a, Num b, Num (a -> b -> c), Num c) => c *** Expression : sum' [fromInt 1 1 2]
21:34:02 <joelteon> use lpaste.net
21:34:22 <diwank> Ok
21:35:16 <sgronblo> What is the fromInt for?
21:45:36 <Crockeo> Hey, I've got a quick question. I'm writing some AForms in Yesod and I'm noticing that the areq flag isn't working on textareaFields. Anyone know what's up with that?
21:54:58 <jle`> diwank logged off
21:54:59 <jle`> but
21:55:07 <jle`> i think he has the wrong list literal
22:38:22 <octopuscabbage> how janky and bad looking is it to have a program who's gui is essentially just offline web pages
22:39:06 <octopuscabbage> because i already know html, css, js and have a haskell web framework i like and want to do a small program, is it worth actually using a gui tool or could that work?
22:43:54 <jg> hi all, i'm trying to map a data constructor over a value:
22:43:55 <jg> data Args = Args { issueNumber :: Integer } deriving (Show)
22:43:56 <jg> fmap Args (fmap readMaybe issueNumber)
22:44:28 <jg> what's the right way to go here?
22:45:45 <arileo> Hi all. I'm trying to run this code, but I get an error network.hs:5:14: parse error on input `<-' https://gist.github.com/anonymous/1fc9c1f05f0cc0417c9f
22:45:56 <arileo> Not quite sure what is wrong!
22:46:26 <apples> you need a "do" on line 4
22:50:15 <arileo> apples: Thanks!
23:23:06 <haskellnewd> best tutorials?
23:23:55 <srh_> a gentle introduction to haskell
23:24:04 <Walther> haskellnewd: Learn You A Haskell, Real World Haskell, Gentle intro to Haskell
23:24:20 <srh_> was kind of joking about gentle intro :/
23:24:39 <srh_> oh well, nothing wrong with suffering
23:25:01 <Walther> oh right it was *that* one, sorry, my bad
23:26:12 <srh_> hey the tutorial's had 98 versions, it must be good
23:27:24 <spacekitteh> does (fmap g) . (fmap f) automatically fuse into fmap (g.f)?
23:37:49 <srh_> spacekitteh: I would guess it depends.  If g and f are known to be lists by the compiler, then maybe thanks to inlining... yes?  I say this as somebody with no direct knowledge
23:38:06 <srh_> erm, not g and f, but the target of the fmap itself.
23:38:45 <pavonia> spacekitteh: I don't think so, because it could change the evaluation behaviour if fmap doesn't satisfy the Functor laws
23:46:11 <Fuuzetsu> AFAIK the compiler never assumes any typeclass laws are obeyed
23:49:28 <spacekitteh> pavonia: is that really... something one would have to worry about, though? they break the law anyway
23:52:54 <pavonia> spacekitteh: IMO, yes. If I want a Monad instance only for convenience, I don't want to care about if I implement fmap correctly such that the compiler doesn't mess up the evaluation
23:54:56 <spacekitteh> :/
