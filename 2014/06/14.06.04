00:00:01 <crazydave> hunt: are you sure that copying the vector to Storable is going to be the bottle neck?  Why not implement it using the most natural type for haskell and then copy that data structure to a storable one for FFI
00:00:04 <roboguy_> augur: I know
00:00:14 <augur> roboguy_: type classes provide a way to get that for FREE
00:00:16 <roboguy_> augur: but then you don't even need to worry about heterogenous containers at all *and* you get type safety!
00:00:24 <hunt> crazydave: the natural data type is list and im switching now because it seems to be causing major slow down
00:00:25 <augur> roboguy_: except no
00:00:30 <Cale> roboguy_, augur: What is this discussion about?
00:00:32 <roboguy_> and it's a nice implementation of prototype based OO
00:00:33 <crazydave> hunt: If you need to refactor later then that shouldn't be too hard
00:00:37 <augur> roboguy_: you still have to worry by doing what that link says
00:00:37 <roboguy_> Cale: subtyping in haskell
00:00:43 <augur> roboguy_: only there, its impossible to do at all
00:00:49 <roboguy_> Cale: and whether or not it's good/possible
00:00:50 <Cale> roboguy_: Subtyping, or just OO?
00:01:03 <augur> roboguy_: there is no way to use that link's suggestion for heterogeneous lists
00:01:11 <roboguy_> Cale: mostly a focus on subtyping
00:01:11 <hunt> crazydave: oh sure yes i see what you mean. although it seems its going to be a bit of a pain because this special storable vector isnt as useful as the standard one
00:01:11 <Cale> roboguy_: I think subtyping is bad, but you can encode OO nicely in Haskell
00:01:18 <Cale> (without it)
00:01:19 <arj> If I have a pattern miss ghci just says "Prelude.undefined" at the moment. Can I make it producing a backtrace?
00:01:23 <arj> or a line number
00:01:28 <roboguy_> Cale: with functions in data types?
00:01:32 <augur> roboguy_: the type class he defines is the method collection, not the underlying data
00:01:32 <Cale> yes
00:01:37 <Cale> You don't tend to need subtyping nearly so much with this encoding.
00:01:58 <roboguy_> Cale: right. augur is arguing that type classes should be preferred over that though, I think
00:02:11 <Cale> Because most of the reason for subtyping to exist is just that in OO languages, they artificially tie the implementations of the methods to the type of the objects.
00:02:13 <enthropy> @where -xc
00:02:13 <lambdabot> http://www.haskell.org/ghc/docs/latest/html/users_guide/runtime-control.html#rts-options-debugging
00:02:16 <crazydave> hunt: but vector will be faster than (linked) list for most access patterns ... and the copy from Vector to Storable Vector is probably not going to be your problem.  So perhaps do the easy win first of replacing list with Vector
00:02:30 <Cale> You don't even need typeclasses to do OO well in Haskell
00:02:35 <Cale> Just functions and records
00:02:50 <hunt> crazydave: isnt it going to be pretty slow though to copy a big vector over?
00:02:53 <doomlord_1> what does the haskell community make of apple swift
00:03:16 <enthropy> arj: that -xc flag up there can help a bit
00:03:20 <Cale> doomlord_1: I've heard one guy say something nice about it? I haven't bothered to look at it much myself yet.
00:03:30 <crazydave> hunt: how big is big?
00:03:49 <arj> enthropy: thanks
00:03:54 <hunt> crazydave: not too big, like 400x400 up to 1000x1000
00:04:10 <hunt> crazydave: there also doesnt seem to be a haskelly way of converting to a storable vector
00:04:13 <tdammers> Cale: any reading material on the OO stuff? I've played around with the idea myself, but never got out of the clumsy phase
00:04:31 <huser2014> hello, I have a problem understanding class/instance. here is my example:
00:04:31 <huser2014> class Mergeable m where
00:04:31 <huser2014>     merge :: m -> m -> m
00:04:31 <huser2014> instance Ord a => Mergeable a where
00:04:31 <huser2014>     merge x y | x < y = y
00:04:32 <huser2014>               | otherwise = x
00:04:38 <Cale> huser2014: lpaste.net
00:04:39 <huser2014> the compiler gives error.
00:04:55 <crazydave> hunt: hmmm shame because there is a haskell-y way of converting a list.  You've profiled your code?
00:05:08 <augur> roboguy_: you cant use the linked blogpost to do what you want
00:05:12 <Cale> huser2014: That instance declaration would overlap with everything
00:05:21 <hunt> crazydave: i havent :|\
00:05:30 <roboguy_> Cale: basically, the discussion started with the question of whether there's anything that OO does well than FP does poorly. I mentioned subtyping and how it can be messy to express it. I haven't done the thing you're talking about, but it always seemed like a cool idea for prototype style OO
00:05:42 <hunt> crazydave: im 60% sure lists are the problem though,
00:05:50 <crazydave> hunt: !!!!
00:05:52 <roboguy_> augur: what do you mean?
00:05:53 <Cale> huser2014: The compiler will never assume that there's *not* an instance of some class when deciding which instance to pick (because a future module might always define one)
00:06:07 <augur> roboguy_: you cant have a heterogeneous list of GUIObjects that way
00:06:15 <Cale> huser2014: So that instance (if it's allowed) will be selected for all types.
00:06:19 <hunt> crazydave: i know.... this hasnt taken too long though so if i can get vectors -> storable working i can actually see
00:06:22 <roboguy_> augur: yeah you can: [Widget]
00:06:26 <augur> roboguy_: no
00:06:29 <roboguy_> no?
00:06:32 <Cale> huser2014: (and there will be an error if there doesn't turn out to also be an instance of Ord for the type)
00:06:34 <augur> roboguy_: no!
00:06:37 <huser2014> Cale: I want to create a class and I want to give a implementation for any type that implements ord for the other I want to be able to give other implementation.
00:06:38 <roboguy_> haha, why not?
00:07:07 <augur> roboguy_: because Widget there is not analogous to GUIWidget in an OO lang
00:07:14 <augur> roboguy_: Widget is the GUIWidget vtable
00:07:28 <crazydave> hunt: http://hackage.haskell.org/package/storable-static-array-0.6.1.0/docs/Foreign-Marshal-StaticVector.html
00:07:32 <huser2014> Cale: is there a way to do this?
00:07:45 <augur> roboguy_: [Widget] is not heterogeneous: everything in the list is PRECISELY and ONLY a Widget
00:07:47 <Cale> huser2014: You could use a bunch of language extensions, but this kind of instance is usually not a good idea.
00:07:52 <roboguy_> augur: yeah
00:08:00 <roboguy_> that's a good thing though
00:08:00 <augur> roboguy_: its not a ButtonWidget or a TextWidget
00:08:06 <augur> roboguy_: no its not
00:08:11 <augur> roboguy_: thats the whole point
00:08:14 <roboguy_> why?
00:08:17 <hunt> crazydave: staticvector = vector?
00:08:25 <augur> roboguy_: with that approach, there cannot BE subclasses
00:08:36 <augur> roboguy_: you cannot define subclasses of Widget that way
00:08:41 <roboguy_> augur: but, like Cale suggested, you need subtyping less with this approach
00:08:42 <Cale> huser2014: Better to lift out the definition of merge for Ord (just making it an ordinary function), and then define instances for specific types using that.
00:08:50 <augur> roboguy_: so?
00:09:05 <augur> roboguy_: less subtyping to get a DIFFERENT program
00:09:09 <augur> roboguy_: the point is to get the SAME program
00:09:13 <platz> What is the most popular solution to solving the Expression Problem?  I'm aware of datatypes-a-la-carte, but I'd be suprised if anyone used that in production code
00:09:21 <Cale> If you're going to do subtyping, I recommend doing it explicitly by writing functions that convert between object types.
00:09:23 <augur> roboguy_: and the typeclass-less approach does not let you do that
00:09:24 <roboguy_> augur: I thought the point was to discuss if OO has something over FP...
00:09:32 <augur> roboguy_: yes, and ive shown you it doesnt!
00:09:40 <hunt> crazydave: i dont see hwo i can convert this to a storable vector
00:09:42 <augur> roboguy_: your examples dont work
00:09:46 <roboguy_> I think we're arguing for the same thing but from different perspectives
00:09:52 <frerich> roboguy: FWIW, I find that in OOP base types are usually used to abstract behaviour. Like, you have an abstract 'paint' method and subclasses reimplement that appropriately. And later you just deal with references to the base class. In Haskell, you get the same thing by having a list of functions just paint things.
00:09:58 <augur> roboguy_: no you're just confused about how to do without typeclasses
00:10:05 <augur> roboguy_: let me give you a better example, ok
00:10:08 <roboguy_> ok
00:10:31 <augur> roboguy_: class Button : Widget { ... }; class TextView : Widget { ... }; Array<Widget> ws;
00:10:46 <augur> roboguy_: do this without using type classes but still using the thing in the blog post
00:10:49 <augur> roboguy_: you cant
00:10:52 <frerich> roboguy: I.e. if you want to iterate over a "heterogenous list" to call 'paint' on all objects in OOP, you just store a list of 'paint' functions (which, through currying, may do totally different things) in FP.
00:11:06 <augur> roboguy_: ws = [new Button, new TextView];
00:11:09 <augur> roboguy_: you just cant do it
00:11:23 <huser2014> Cale: how ca I lift merge to work over two diferent classes? Ord and (mergeable but not Ord)
00:11:24 <Cale> frerich: Yeah, *most* of what subtyping is really used for is spurious hierarchy that's the result of requiring distinct types in order to have distinct method implementations.
00:11:44 <roboguy_> how about ws = [makeButton, makeTextView]
00:11:52 <crazydave> hunt: that's the reason I tend to use lists for everything .... they have the most functions defined for them.  The 'replacement' data types all have holes
00:11:53 <augur> roboguy_: no can do!
00:11:54 <hunt> crazydave: what i need is a pointer to the structure and i dont think i get one there
00:12:00 <augur> roboguy_: what are the types of those functions?
00:12:08 <roboguy_> augur: both Widget
00:12:20 <augur> roboguy_: but then you're not making Button's and TextViews, but just Widgets
00:12:22 <Cale> huser2014: Because type classes are open, that is, because another module can always come along and define another instance of a class, nothing is allowed to rely on *not* having an instance of some particular class.
00:12:28 <roboguy_> augur: you could throw in some GADT stuff
00:12:39 <roboguy_> or some phantom types I mean
00:12:42 <Cale> huser2014: There's no way to know that there *isn't* an instance of Ord for some type
00:12:51 <roboguy_> I guess you'd run into some existentials then too
00:12:53 <augur> roboguy_: yes, thats another possibility -- have multiple constructors for Widget
00:12:53 <enthropy> ws :: [(forall w. Widget w => w -> r) -> r]; ws = [ \k -> k makeButton, \k -> k makeTextView ]
00:13:01 <Cale> huser2014: Because some other module which imports the one you're writing might define such an instance.
00:13:04 <augur> roboguy_: but then you'd have a problem with subtyping THOSE things
00:13:22 <augur> roboguy_: class RoundButton : Button { ... }; class SquareButton : Button { ... }
00:13:28 <enthropy> if it's so much trouble to make a data constructor
00:13:51 <augur> roboguy_: you'd have to have this whole hierarchy of phantom-type classes like you dont like
00:13:54 <Cale> huser2014: The right thing to do here is to write instances of Mergeable as you need them.
00:14:11 <roboguy_> augur: not phantom type classes, phantom types
00:14:20 <augur> roboguy_: :|
00:14:23 <hamishmack> augur: Gtk functions (like gtk_viewport_get_hadjustment) are not part of an OO interface (in that you cannot provide different implementations even in C code).  In C++ they would be non virtual member functions.  If there is a polymorphic implementation in GtkViewport it is private and these functions are the public wrappers.  The haskell Gtk2Hs functions are the same.  I don’t think these functions should
00:14:24 <hamishmack> be in the typeclass.
00:14:27 <roboguy_> but you'd probably still have the existential thing
00:14:29 <Cale> huser2014: But if you *really* want it, there's an OverlappingInstances extension you could use
00:14:30 <augur> roboguy_: phanthom-type classes
00:14:37 <roboguy_> augur: what?
00:14:37 <augur> roboguy_: classes that organize your phantoms
00:14:40 <roboguy_> oh
00:14:50 <roboguy_> that doesn't really work
00:15:05 <augur> roboguy_: you'd still need existentials tho yes:   [forall a. WidgetSubclass a => Widget a]
00:15:10 <augur> roboguy_: the correct solution is this:
00:15:12 <huser2014> Cale: I can manually just implement instance of Mergeable for the types I want but for all the types that are Ord I will just call the max function. Can I write in DRY manner?
00:15:47 <Cale> Yeah, just define the max function separately and use that to make the instances
00:15:49 <augur> roboguy_:   class Widget a { ... }   class Widget a => Button a { ... }   class Widget a => Textual a { ... }
00:16:05 <fread2282> t
00:16:36 <roboguy_> augur: I still say it's bad that we can't do "Widget a => Vector a" though
00:16:39 <Cale> huser2014: See 7.6.3.4 here: http://www.haskell.org/ghc/docs/latest/html/users_guide/type-class-extensions.html
00:16:53 <augur> roboguy_: what is that supposed to mean?
00:17:02 <Cale> (and the following sections)
00:17:06 <roboguy_> augur: a Vector of Widgets
00:17:32 <Cale> huser2014: actually 7.6.3.5 is more about what you want to do
00:17:35 <augur> roboguy_: Vector Widget
00:17:43 <augur> roboguy_: or as i wrote it, HCList Widget
00:17:44 <roboguy_> augur: but you're using type classes
00:17:48 <augur> roboguy_: yes, i am
00:17:49 <augur> so what?
00:17:53 <augur> roboguy_: it does what you want
00:17:59 <roboguy_> augur: that's not valid because Widget is a constraint not a type
00:18:06 <augur> roboguy_: ofcourse its valid
00:18:25 <augur> roboguy_: haskell has constraint kinds!
00:18:49 <lennartj_> grr, ImpredicativeTypes seems to not want to play nicely with lenses
00:18:55 <augur> roboguy_: you can define   data HCList (c :: Constraint) = Nil | forall a. c a => Cons a (HCList c)
00:18:56 <lennartj_> any advice on what to do here? http://lpaste.net/105061
00:19:04 <augur> roboguy_: where c is a type class
00:19:16 <huser2014> Cale: ok. 10x, I'll read it. bye.
00:19:19 <crazydave> hunt: I think (and am not sure) that you might be able to just call convert
00:19:32 <hunt> crazydave: im going to test that
00:20:45 <roboguy_> augur: right I forgot about that. but the need to make a new data type is a minus
00:20:59 <roboguy_> anyway, I need to get to bed soon
00:21:09 <augur> roboguy_: why a minus?
00:21:18 <enthropy> lennartj_: foo = map reverse  might work just as well?
00:21:19 <augur> roboguy_: it gets you what you want
00:21:23 <roboguy_> augur: because, like I've said, it's good to use already made data types
00:21:27 <roboguy_> say you want a HashMap
00:21:32 <enthropy> as in avoid using ImpredicativeTypes
00:21:35 <augur> roboguy_: no you're confused again
00:21:41 <roboguy_> why am I confused?
00:21:50 <augur> look, roboguy_, you do the EXACT same thing in C++ or C#
00:22:04 <roboguy_> yes, but it has potential to be more type safe in haskell
00:22:06 <augur> roboguy_: you use generics to get class-constrained arrays
00:22:16 <augur> roboguy_: Array and Array<> are not the same type in whatever language
00:22:22 * hackagebot egison 3.3.5 - Programming language with non-linear pattern-matching against unfree data  http://hackage.haskell.org/package/egison-3.3.5 (SatoshiEgi)
00:22:35 <enthropy> on the other hand augur uses ImpredictaiveTypes sometimes here
00:22:36 <augur> roboguy_: the problem you raise exists in _every_ OO language
00:22:38 <lennartj_> enthropy: my actual code is more complex and involves nested record fields
00:22:51 <augur> roboguy_: so OO languages dont do it better
00:22:54 <augur> roboguy_: which is the point
00:23:08 <hunt> crazydave: seems like itll work
00:23:13 <lennartj_> but, I'll try rewriting with map and losing the pretty syntax :P
00:23:16 <augur> roboguy_: the problems you raise for haskell exist in C++ too. they're not magically gone
00:23:46 <roboguy_> augur: you don't need a new Array class to handle things with subclasses if you already have an Array that handles basic types like int
00:23:52 <roboguy_> in C++
00:24:05 <augur> roboguy_: you do it you want it to be type safe
00:24:19 <augur> roboguy_: if you dont want it to be type safe, then you dont need a new type in haskell EITHER
00:24:49 * fread2282 test
00:25:18 <crocket> Googld trends tell me people are losing interest in haskell slowly.
00:25:25 <crocket> Is it really what's happening?
00:26:17 <tdammers> the problem with google trends is that it can't tell the difference between a programming language, a logician, various places in the US, and an indian dish
00:26:31 <roboguy_> augur: ok, I think one of us isn't understanding the other and I'm too tired to even figure out which of us that is haha (maybe both). I need to get to bed. have a good night augur! maybe we'll talk again when I'm more awake
00:28:06 <lennartj_> enthropy: no, map also complains (rightly)
00:28:41 <lennartj_> because it's insufficiently polymorphic
00:29:34 <crocket> tdammers, Is haskell really an indian fish?
00:30:39 <lennartj_> oh, maybe I should be using existential types rather than impredicative types
00:31:42 <crazydave> tdammers: https://www.google.com/trends/explore#q=haskell%2C%20programming&cmpt=q
00:33:20 <crazydave> tdammers: oops, I thought that would show me the and .... my mistake
00:33:54 <fread2282> https://www.google.com/trends/explore#q=%2Fm%2F03j_q&cmpt=q
00:34:37 <crocket> Is haskell a good langauge on web browsers?
00:34:39 <frerich> fread2282: That graph looks a lot more plausible (also the reginal interest)
00:34:59 <tdammers> crocket: *dish*
00:35:07 <tdammers> but fish works in a pinch
00:35:13 <crazydave> I searched for GHC and found that it was probably developed in Ghana!
00:35:34 <crocket> tdammers, pardon?
00:36:04 <tdammers> 09:27:42          crocket | tdammers, Is haskell really an indian fish?                                                                                 │ _1126
00:36:27 <tdammers> I was referring to "curry" though, in case this wasn't obvious
00:36:38 <frerich> ouch...
00:37:01 <tdammers> also, #haskell-blah
00:37:03 <tdammers> I guess
00:37:13 <fread2282> interesting that haskell had a spike in 2011 in Estoina
00:37:27 <coppro> especially interesting because I learned to sing estonian today
00:37:56 <Kaidelong> arvo part?
00:38:23 <coppro> Kaidelong: nope. ilus maa
00:46:37 <dibblego> is it possible to pipe the output of a GHCi result to a file?
00:46:53 <dibblego> :info Blah > blah.info
00:46:57 <dibblego> for example
00:47:10 <dibblego> (a GHCi command)
00:58:55 <shachaf> You can run ghc -e ':info Blah' > blah.info
00:59:07 <dibblego> oh yeah good one
01:02:28 * hackagebot aeson-qq 0.7.0 - JSON quasiquoter for Haskell  http://hackage.haskell.org/package/aeson-qq-0.7.0 (SimonHengel)
01:40:49 <Jookia> Is there a generic `Tree a b`library with definitions for functors, etc already?
01:43:09 <k00mi> Jookia: why two type variables?
01:44:03 <Jookia> k00mi: I'm trying to somehow map the 'pathtype' library to a tree, and there's two path types: Dir and File, I want to somehow be clear what's what
01:44:15 <dottedmag> Leaves and internal nodes.
01:44:32 <Jookia> dottedmag: Hmm?
01:45:34 <dottedmag> Jookia: a and b types in k00mi's question
01:45:41 <fizruk> Free ((,) a) b
01:46:10 <Jookia> The problem is kinda that directories can be branches
01:46:34 <Jookia> So branches have their own type and leaves have their own type
01:47:30 <fizruk> hm, FreeT ((,) a) [] b rather
01:49:07 <Jookia> Hmm, I will have to think about this a bit more. Ciao.
01:50:48 * hackagebot egison 3.3.5 - Programming language with non-linear pattern-matching against unfree data  http://hackage.haskell.org/package/egison-3.3.5 (SatoshiEgi)
01:50:48 * hackagebot aeson-qq 0.7.0 - JSON quasiquoter for Haskell  http://hackage.haskell.org/package/aeson-qq-0.7.0 (SimonHengel)
02:25:48 * hackagebot typeparams 0.0.1.0 - Lens-like interface for type level parameters; allows unboxed unboxed vectors and supercompilation  http://hackage.haskell.org/package/typeparams-0.0.1.0 (MikeIzbicki)
02:28:00 <Profpatsch> data (->') e a = (->') e a
02:28:02 <Profpatsch> instance Functor ((->') e) where
02:28:04 <Profpatsch>   fmap f ((->') x y) = (->') x (f y)
02:28:16 <Profpatsch> Could this be right? I can’t find the actual implementation anywhere.
02:28:29 <Profpatsch> (Training example from Typeclassopedia).
02:29:54 <coppro> Profpatsch: That is the implementation?
02:30:19 <Profpatsch> coppro: No idea, it’s what I think the implementation is.
02:30:49 <coppro> Profpatsch: Well, does it obey the laws?
02:31:34 <Profpatsch> fmap id = id check.
02:31:39 <fizruk> Profpatsch: that’s just Writer
02:31:58 <fizruk> Profpatsch: or equivallently ((,) e)
02:31:59 <coppro> fizruk: sshhhhh
02:32:16 <Profpatsch> fmap (f.g) = fmap f . fmap g … no idea.
02:32:23 <coppro> Profpatsch: well try it
02:32:25 <fizruk> Profpatsch: you don’t have to prove the second one
02:32:47 <coppro> fizruk: why not?
02:32:59 <fizruk> Profpatsch: it comes for free :) but you still should try as an excercise
02:33:05 <fizruk> coppro: free threorem
02:33:32 <coppro> fizruk: hmmmm... I'm skeptical, but explain
02:34:56 <fizruk> coppro: it’s not actually obvious, but I guess Wadler gives a proof that second functor law follows from fmap’s type and fmap id = id law
02:35:00 <fizruk> coppro: see http://stackoverflow.com/questions/8305949/haskell-functor-implied-law
02:35:44 <quchen> Also see this, https://github.com/quchen/articles/blob/master/second_functor_law.md
02:37:19 <merijn> Parametricity \o/
02:37:56 <fizruk> quchen: thanks for that link!
02:38:08 <Profpatsch> So fmap (f.g) (a -> b) = (a -> (f.g) b)
02:38:47 <quchen> You're mixing types and values here.
02:39:21 <fizruk> he has data (->’) e a = (->’) e a
02:39:45 <quchen> Ah ok
02:40:02 <Profpatsch> Normally one would use (\x -> …) for this? It’s not real Haskell, since -> is a builtin.
02:40:38 <quchen> data e :-> a = e :-> a
02:41:12 <Profpatsch> I thought :-> was only a Quickcheck thing?
02:41:16 <quchen> I think that one should work. There are a couple of arrow-shaped things you can use to create data that looks like functions.
02:41:23 <merijn> Probably you want "data e :-> a = FunWrapper (e -> a", then you can actually lift functions
02:41:25 <quchen> ~> is a value-level "->".
02:41:45 <Profpatsch> quchen: All I want to do is grasp Functors. :)
02:41:58 <Profpatsch> No practical use whatsoever for now.
02:42:39 <quchen> Since you're worrying about the function instance, I assume you understand the Maybe and List instances already?
02:42:45 <coppro> By default, ->' doesn't work simply because it's not a type name
02:42:50 <coppro> :-> does because it starts with a colon
02:42:59 <coppro> -> and : are special cases in the language
02:43:15 <merijn> coppro: Actually, the reason "->'" doesn't work on the type level is the fact that ' is a letter and not an operator symbol
02:43:21 <Profpatsch> coppro: So :-> does really mean ->' to the compiler?
02:43:21 <coppro> merijn: that too
02:43:31 <coppro> Profpatsch: :-> is just a name that happens to be in the type namespace
02:43:35 <coppro> it's not magic
02:43:54 <quchen> You could also name it :> or :< or :----->
02:44:01 <Profpatsch> Ah, you mean I can’t use ' for infix, normally you use : for that.
02:44:03 <merijn> coppro: My point was that : is not necessary
02:44:19 <merijn> This is perfectly valid Haskell (module -XTypeOperators) "data a --> b = Wrap (a -> b)"
02:44:21 <coppro> merijn: it is by default, I thought? or did they turn that on for types now?
02:44:42 <merijn> And without TypeOperators :-> isn't a valid type either
02:45:58 <Profpatsch> But is (x -> (f.g y)) really the same as (x -> (f y)) . (x -> (g y))?
02:46:03 <Profpatsch> Man, I suck at these.
02:46:59 <coppro> merijn: ay, you're right
02:47:01 <Profpatsch> s/x/\x/g
02:47:47 <coppro> Profpatsch: where'd you get that from?
02:48:39 <Profpatsch> coppro: Isn’t that what I have to show if I want to check if fmap f ((->') x y) = (->') x (f y)  describes a functor?
02:49:55 <coppro> Profpatsch: no, because your hypothetical type ->' is isomorphic to (,), not to (->)
02:50:04 <coppro> not to mention that (x -> (f.g y)) doesn't even make sense
02:52:36 <Profpatsch> coppro: So how would I implement fmap for (->) if I could do that?
02:53:10 <merijn> Profpatsch: Try writing out the type for fmap?
02:53:12 <coppro> Profpatsch: You can; it is in fact commonly done.
02:53:18 <coppro> Think about it a bit and if you can't get it, come back :)
02:53:33 <merijn> "f = (->) e"
02:53:34 <merijn> :t fmap
02:53:35 <lambdabot> Functor f => (a -> b) -> f a -> f b
02:53:47 <merijn> Try writing that out and staring until you achieve enlightenment ;)
02:54:05 <coppro> remember that (->) e a ~ e -> a
02:54:59 <quchen> I think enlightenment might be easier by realizing that "a -> b" is a collection of "b" indexed by "a".
02:55:21 <quchen> Lookup is function application, fmap changes all values in the collection.
03:05:38 <orzo> is there a Bits instance for ByteString that i can import?
03:10:09 <kazagistar> orzo: isnt a bytestring an arrray of Word8's, which does have a bits instance?
03:10:26 <orzo> yeah
03:10:36 <tdammers> kazagistar: yes; problem with a Bits instance would be that you have to decide on an endianness
03:11:08 <orzo> why is endianness relevent
03:11:16 <Profpatsch> coppro: I’m not sure how the first part of my fmap definition has to look. fmap f ((:->) x y) = ?
03:11:23 <tdammers> because a bytestring is an ordered collection of bytes
03:11:24 <orzo> the problem is what to do with bytestrings of different sizes
03:11:26 <orzo> i figure
03:11:37 <orzo> if they are the same size, endianness does not matter
03:11:43 <tdammers> you have to decide whether the first byte in your bytestring is the MSB or the LSB
03:11:55 <orzo> for Bits?
03:12:00 <orzo> bitwise ops
03:12:33 <sipa> Bits has a bit function, which takes a bit position and returns its value
03:12:41 <orzo> oh
03:12:42 <sipa> give me bit 9 of "bla"
03:12:47 <tdammers> at least for shift, rotate, and all the functions that address bits by index, yes
03:13:06 <tdammers> you can do bitwise AND, OR, XOR and NOT
03:13:09 <orzo> i just needed and and or and xor and such
03:13:23 <tdammers> but Bits requires more than that
03:13:27 <sipa> perhaps there should have been a BitsOfUnknownOrder, with and/or/not/xor, and Bits extending it with the rest :)
03:13:51 <tdammers> sipa: yes, Haskell is way too pragmatic
03:13:57 <quchen> Changing classes in Base is pretty hard.
03:14:06 <tdammers> (see also: numeric prelude...)
03:17:40 <orzo> Bits and OrderedBits would be better names
03:17:52 <orzo> i need a Word128
03:17:54 <orzo> heh
03:18:46 <tdammers> orzo: type-level integers ftw
03:18:57 <tdammers> Word n
03:19:25 <orzo> wait, what?  Can i import that?
03:21:34 <tdammers> orzo: no
03:32:19 <awestroke> is foldr always strict?
03:32:32 <Philonous> awestroke, On the contrary
03:32:50 <awestroke> Philonous: there are strict versions of foldl and foldl1, but not foldr and foldr1
03:33:16 <Philonous> awestroke, because a strict version of foldr doesn't make sense. You have to build up the thunks anyway.
03:34:04 <awestroke> so what's more performant, foldl' or foldr?
03:34:10 <Philonous> > foldr (&&) True (repeat False) -- not strict
03:34:11 <lambdabot>  False
03:34:25 <quchen> foldl' and foldr are different functions serving different purposes.
03:34:51 <Philonous> awestroke, That depends. If you _know_ you will have to walk the entire list and your function is commutative than foldl' will be better.
03:35:37 <Philonous> awestroke, OTOH foldr can be much faster when the function it takes is lazy in it's second argument.
03:36:09 <quchen> > foldr const 0 [1..] -- Infinitely faster!
03:36:11 <lambdabot>  1
03:36:45 <piezoid> hi
03:36:49 <piezoid> do you know a better 'Int -> ByteString' than 'pack . show' ?
03:36:54 <Maior> so in https://github.com/doismellburning/hess/tree/feature/partial I have `Hess.Core` and `Hess.Partial` (to which I've extracted a bunch of partial functions for convenience etc.) - I'd like to use things in HP in HC's doctests, but I'm a little stuck on how to do that
03:36:55 <Philonous> awestroke, And, as quchen demonstrated, when the function in the argument is productive, foldr can work on infinite lists, foldl(') can't.
03:37:40 <Maior> I've tried the $setup block from https://github.com/sol/doctest-haskell#readme, but, not hugely surprisingly, I can't `import Hess.Partial` there because I guess include-dir config doesn't exist
03:38:16 <awestroke> thanks
03:38:46 <quchen> piezoid: "pack . show" is *bad*.
03:38:56 <quchen> Binary or Cereal are libraries to convert data to ByteString.
03:38:57 <piezoid> quchen: i know...
03:39:07 <Yuu_chan> piezoid: Builders probably
03:39:29 <piezoid> I found readInt but no writeInt in ByteString.Char8
03:39:37 <quchen> Don't use Char8.
03:39:38 <Philonous> quchen, What's so bad about (pack . show( for an ascii encoding?
03:39:48 <quchen> https://github.com/quchen/articles/blob/master/fbut.md#bytestringchar8-is-bad
03:40:04 <quchen> Philonous: ASCII is not an appropriate encoding for Int.
03:40:23 <Philonous> quchen, Well, if the protocol demands it.
03:40:24 <Yuu_chan> piezoid: byteString . intDec
03:41:01 <quchen> Philonous: If the protocol demands it then the function is wrong since show produces String, which is not ASCII.
03:41:07 <piezoid> quchen: thank you. I forgot that Builders are now inclueded in the library.
03:41:49 <Philonous> quchen, Well, technically your right, of course, but in the case of Integers we know the output of show will be ascii only.
03:42:27 <Philonous> quchen, Never mind. I'm arguing an indefensible point.
03:43:00 <Yuu_chan> I'm using ByteString.Char8 with Attoparsec and nobody will stop me!
03:43:23 <quchen> Enjoy debugging later
03:43:58 <piezoid> quchen: I'm in the limited use case of Char8, where everything is ASCII
03:45:59 * hackagebot postgresql-simple 0.4.2.3 - Mid-Level PostgreSQL client library  http://hackage.haskell.org/package/postgresql-simple-0.4.2.3 (LeonSmith)
03:52:49 <dottedmag> What is the common use-case for asTypeOf?
03:54:05 <Feuerbach> hey dottedmag, good to see you here
03:54:13 <Yuu_chan> dottedmag: to "force" the type inference
03:54:19 <Maior> :t asTypeOf
03:54:20 <lambdabot> a -> a -> a
03:54:25 <Feuerbach> asTypeOf can be used to restrict the type of a polymorphic value
03:54:33 <hpc> in a where clause when you are doing something extremely delicate and can't write the type signature
03:54:35 <merijn> dottedmag: Forcing type inference or abuse with dynamic typing
03:54:36 <hpc> or when golfing
03:54:44 <dottedmag> Feuerbach: o/
03:55:05 * bahamas is reading the last chapter of LYAH
03:55:09 <bahamas> zippers are cool
03:55:12 <Feuerbach> dottedmag: here's a fun example of asTypeOf usage: http://ro-che.info/articles/2014-03-13-type-of-local-function.html
03:55:17 <bitemyapp> bahamas: zippers are comonads.
03:55:26 <bahamas> bitemyapp: don't scare me
03:55:32 <bahamas> I have no idea what comonads are yet
03:55:32 <merijn> bitemyapp: Correct, but also not really helpful
03:55:45 <Yuu_chan> coburritos are comonads
03:56:00 <merijn> That's like saying "lists are monads", also true, but not particularly helpful
03:56:07 <dottedmag> Feuerbach: thanks.
03:57:15 <dottedmag> Yuu_chan: hpc: merijn: So, basically, in obscure situations. It's not something used daily, right?
03:57:50 <Feuerbach> right
03:57:53 <Yuu_chan> dottedmag: Yeah.
03:58:36 <bahamas> Yuu_chan: little donkeys?
03:59:07 <bitemyapp> Yuu_chan: hey
03:59:12 <bitemyapp> Yuu_chan: I wrote RangeQUery
03:59:29 <bitemyapp> Yuu_chan: I also wrote TermsQuery and IdsQuery, I'm working on QueryStringQuery right now.
03:59:36 <bitemyapp> Yuu_chan: I did some clean up and warning-squashing too.
04:00:00 <bitemyapp> it's 0558 - I can wrap up what I have now and push a release before I pass out or I can keep going.
04:00:10 <bitemyapp> Yuu_chan: do you just need the github repo or do you need a hackage release?
04:01:06 <Yuu_chan> bitemyapp: nice to hear that! I think a fresh build from repo will be enough to me.
04:01:43 <Yuu_chan> I also thought about expanding ranges to dates and strings
04:02:46 <bitemyapp> Yuu_chan: I haven't touched that yet. What are your thoughts?
04:03:14 <awestroke> what's (# #) ?
04:03:44 <Yuu_chan> awestroke: packed tuples IIRC
04:04:05 <bitemyapp> awestroke: like Yuu_chan said, they're value-typed tuples.
04:05:15 <bergmark> fiatjaf: i ran across the same problem with entropy that you had, are you running 32 bit linux? https://github.com/TomMD/entropy/issues/12
04:09:27 <Yuu_chan> bitemyapp: one thought was: class ToJSON a => Ranged a; instance Ranged Double; instance Ranged UTCTime; newtype LessThan a = LessThan a; data Range = forall Ranged a =>a . RangeLtGt a a | <...>, but existentials seems to be an overkill
04:10:11 <merijn> *Un*packed tuples
04:10:45 <bitemyapp> Yuu_chan: that's possibly the existential typeclass anti-pattern.
04:10:48 <Yuu_chan> merijn: er, right, thanks
04:11:00 <bitemyapp> Yuu_chan: http://lukepalmer.wordpress.com/2010/01/24/haskell-antipattern-existential-typeclass/
04:11:19 <bitemyapp> Yuu_chan: but I like the core structure you're thinking about here.
04:11:35 <bitemyapp> Yuu_chan: this is something I'll want to ponder when I'm not exhausted. At least you have your RangeQuery.
04:11:45 <bitemyapp> n.b. I haven't added tests for it yet.
04:12:07 <Maxdamantus> Has there been any experimentation into representing transitively unpacked values as integers?
04:12:28 <Yuu_chan> bitemyapp: yes, that article bothers me too
04:13:07 <Maxdamantus> (Bool, Ordering)
04:13:15 <Maxdamantus> should have 3*2 possible values.
04:13:35 <Maxdamantus> first element can be v%2, second will be v/2
04:14:05 <Maxdamantus> otherwise, the second element would be v%3 and the first v/3
04:14:43 <Yuu_chan> Maxdamantus: what about packing|unpacking costs?
04:15:00 <bitemyapp> Yuu_chan: the article bothers you?
04:15:15 <Maxdamantus> if you had even a pair of those, that's still only 36 values, can be stored within a single octet.
04:15:44 <Maxdamantus> Yuu_chan: yes, that's the tradeoff.
04:15:46 <Yuu_chan> bitemapp: I mean I can't confidently use existentials since I've read it
04:16:14 <Maxdamantus> but they should just be div/mod operations.
04:16:22 <Yuu_chan> Maxdamantus: remind me of bit-packed structures in C
04:16:33 <Yuu_chan> *reminds
04:16:45 <Maxdamantus> (and mul/add for going in the other direction)
04:17:00 <Maxdamantus> Mm, bitfields.
04:17:22 <Maxdamantus> Unfortunately C can't do it easily with other fields, because other fields are meant to have addresses.
04:17:43 <Maxdamantus> Can't take the address of a bitfield though.
04:29:14 <Athas> Is there a way to build a profiled version of my library/program (for stack traces) without having profiled versions of all library dependencies?
04:32:40 <merijn> Athas: No
04:36:05 * hackagebot hapistrano 0.1.0.0 - A deployment library for Haskell applications  http://hackage.haskell.org/package/hapistrano-0.1.0.0 (jsl)
05:00:04 <zipper`> Uh how do I check whether a package in installed?
05:00:11 <zipper`> a haskell package
05:01:20 <merijn> ghc-pkg list
05:01:42 <merijn> Only works for libraries, though
05:02:20 <zipper`> merijn: Yeah I was sure I had Network.Wreq but right now when I try importing in into ghci it won't work.
05:03:02 <t7> whats the name for a matrix whose length, width, height etc are the same (but for all dimensions) ?
05:03:10 <nomeata> Hi. How would I draw a rectangle around some diagram?
05:03:36 <nomeata> (in diagrams, that is)
05:06:08 * hackagebot units-defs 1.0.1 - Definitions for use with the units package  http://hackage.haskell.org/package/units-defs-1.0.1 (RichardEisenberg)
05:06:19 <Yuu_chan> t7: square?
05:06:29 <t7> not cubed?
05:06:51 <Yuu_chan> 3d matrix?
05:07:45 <byorgey> nomeata: I often do something like  enRect d = roundedRect (w+0.5) (h+0.5) 0.5 <> d # centerXY where (w,h) = size2D d
05:07:51 <zipper`> Ok somehow installed packages seem to have vabished into thin air.
05:08:01 <zipper`> *vanished
05:08:22 <byorgey> nomeata: there are lots of ways to tweak that but hopefully you get the idea
05:09:41 <nomeata> byorgey: ok, just checking that I did not overlook something
05:10:06 <nomeata> byorgey: (I’m trying to reproduce this animation with diagrams: http://www.joachim-breitner.de/blog/archives/557-A-copying-garbage-collector-animated.html)
05:10:15 <nomeata> (you might remember it)
05:11:02 * frerich thinks Joahmin Breitner would make an awesome death metal guitar player
05:11:16 <nomeata> frerich: the picture is very outdated :-)
05:11:46 <nomeata> byorgey: also, is there a way to have vcat consider the line width? Currently, when I use vcat with colored rects, their borders overlap and one color is missing.
05:12:43 <frerich> nomeata: I would like to claim that I knew *you* are Joachim Breitner but alas, I wasn't aware of this. Sorry, it wasn't meant in a negative way. Death Metal guitar players are living the life to its fullest! :)
05:13:03 <quchen> Is there a reverse of "typeRep", i.e. a function that gives me a Proxy given a TypeRep?
05:13:21 <Axman6> that would require dependant types no?
05:13:31 <zipper`> Has anyone ever had haskell packages just vanish or break after not using them for a few weeks?
05:14:09 <Yuu_chan> zipper`: no... Do you have gremlins in your cabal?
05:14:59 <quchen> Axman6: Right, unless there's some extension magic around :-)
05:15:30 <dottedmag> What is the idiomatic way to define in a module a data type named like the one in Prelude?
05:16:10 <Yuu_chan> dottedmag: import Prelude hiding (ThatType)?
05:16:20 <zipper`> Yuu_chan: Uh I guess not.
05:16:43 <dottedmag> Yuu_chan: thanks.
05:16:53 <zipper`> Yuu_chan: I hope there's not a real thing called gremlins in haskell. I hope we're talking about mystical creatures.
05:16:55 <dottedmag> Is the implicit Prelude import disabled by explicit one?
05:17:02 <tdammers> yes
05:17:11 <dottedmag> That's handy. Thanks.
05:20:42 <Axman6> Yuu_chan: did you install a new version of GHC?
05:22:05 <archblob> hello, anyone on 7.6.3 ?
05:24:18 <cloudhead> how would a I structure a cabal project which has client, server and shared library?
05:24:27 <dottedmag> "To convert a Char to or from the corresponding Int value defined by Unicode, use toEnum and fromEnum from the Enum class respectively (or equivalently ord and chr)."
05:24:28 <cloudhead> are there any examples out there I can look at?
05:24:35 <dottedmag> I don't seem to find ord/chr. Are they not in Prelude?
05:24:59 <dottedmag> Ah, found it in Hoogle, sorry for the noise.
05:25:09 <tdammers> Data.Char
05:25:35 <tdammers> cloudhead: I'd make that three projects
05:25:47 <tdammers> one for the lib, one for the client, one for the server
05:26:04 <tdammers> and then keep them side-by-side in the same git repo
05:26:11 <cloudhead> ohh
05:26:15 <cloudhead> didn't think of that
05:26:42 <tdammers> bit of shared tooling on top - tags, versions, that kind of thing, so I don't have to worry about keeping versions in sync
05:26:49 <cloudhead> and for client/server to have visibility on the library, I'd have to cabal install?
05:26:50 <bahamas> :t (Just 4) >>= liftM (+2)
05:26:52 <lambdabot> (Num (Maybe b), Num b) => Maybe b
05:26:58 <bahamas> > (Just 4) >>= liftM (+2)
05:26:59 <lambdabot>  No instance for (GHC.Show.Show b0)
05:27:00 <lambdabot>    arising from a use of ‘M433856673690773286216464.show_M4338566736907732862...
05:27:00 <lambdabot>  The type variable ‘b0’ is ambiguous
05:27:01 <lambdabot>  Note: there are several potential instances:
05:27:03 <lambdabot>    instance [safe] GHC.Show.Show
05:27:07 <tdammers> you'd install the library into the sandboxes for the client and the server, yes
05:27:13 <cloudhead> yea
05:27:14 <cloudhead> cool
05:27:39 <tdammers> cd client; cabal install ../lib # something like that
05:27:55 <cloudhead> mhm
05:27:59 <cloudhead> cheers
05:28:14 <tdammers> although sometimes I just throw everything on hackage and have cabal pull the library from there
05:28:34 <cloudhead> haha
05:29:55 <bahamas> can anyone explain what's wrong with my attempt above?
05:30:01 <archblob> can anyone run something for me on 7.6.3 ?
05:30:36 <tdammers> bahamas: you're trying to make lambdabot print something that doesn't have a Show instance
05:31:04 <tdammers> bahamas: try adding some type annotations
05:31:45 <tdammers> > (Just 4) >>= liftM (+2) :: Maybe Int
05:31:46 <lambdabot>  No instance for (GHC.Num.Num (Data.Maybe.Maybe GHC.Types.Int))
05:31:46 <lambdabot>    arising from the literal ‘4’
05:31:56 <tdammers> oh heh
05:32:45 <quchen> Apart from that the code is probably wrong.
05:32:53 <quchen> > Just 4 >>= return . (+2)
05:32:55 <lambdabot>  Just 6
05:33:08 <quchen> > fmap (+2) (Just 4)
05:33:09 <lambdabot>  Just 6
05:33:14 <tdammers> > (+2) <$> Just 4
05:33:16 <lambdabot>  Just 6
05:33:40 <tdammers> > (+) <$> Just 4 <*> Just 2
05:33:41 <lambdabot>  Just 6
05:33:58 <Maxdamantus> Just (+2) <*> Just 4
05:34:01 <Maxdamantus> > Just (+2) <*> Just 4
05:34:02 <tdammers> compulsive-applicative disorder, they call it
05:34:03 <lambdabot>  Just 6
05:37:17 <bahamas> quchen: yes, what's wrong about my approach? why doesn't using liftM work?
05:37:30 <bahamas> :t liftM
05:37:31 <lambdabot> Monad m => (a1 -> r) -> m a1 -> m r
05:37:57 <benzrf> bahamas: why are you using liftM and not fmap
05:38:07 <bahamas> benzrf: I'm playing around
05:39:34 <nomeata> byorgey: After looking up a diagram with "withName", can I find out what line color has been applied to it?
05:47:08 <quchen> bahamas: "return . f" is not "liftM f".
05:48:49 <quchen> If you write your code from above out, it reads  (Just 4 >>= liftM (+2)), which is (Just 4 >>= (\x -> x >>= return . (+2))), which has a >>= too much.
05:57:22 <merijn> :t liftM (+2) :: Maybe Int -> Maybe Int
05:57:23 <lambdabot> Maybe Int -> Maybe Int
05:57:27 <merijn> :t (>>=)
05:57:28 <lambdabot> Monad m => m a -> (a -> m b) -> m b
05:57:47 <merijn> bahamas: >>= expects "Int -> Maybe Int", not "Maybe Int -> Maybe Int"
06:00:29 <benzrf> bahamas: you want fmap
06:00:32 <benzrf> no need for monads
06:00:35 <benzrf> functors are enuf
06:01:10 <bitemyapp> benzrf: http://lpaste.net/6780991166897717248
06:02:45 <benzrf> bitemyapp: w-what
06:02:57 <bahamas> merijn: I was confused about what liftM does then
06:03:05 <Maior> @src liftM
06:03:05 <lambdabot> liftM f m1 = do { x1 <- m1; return (f x1) }
06:03:12 <Maior> hm
06:03:41 <Krakarn--> :t (Just 4) >>= return . (+2)
06:03:43 <lambdabot> Num b => Maybe b
06:04:08 <dottedmag> :t liftA
06:04:09 <lambdabot> Applicative f => (a -> b) -> f a -> f b
06:04:12 <benzrf> Krakarn--: this is also know as fmap
06:04:21 <bitemyapp> benzrf: welcome to my life.
06:04:26 <bitemyapp> bwahahahaha
06:04:32 <Krakarn--> benzrf: yes it was in contrast to bahamas code snippet above
06:04:33 <benzrf> bitemyapp: i am scar
06:04:36 <benzrf> Kabaka: oh
06:04:37 <bahamas> it shows that I've been away from haskell for a few weeks
06:04:38 <benzrf> * Krakarn--
06:04:40 <bitemyapp> benzrf: this is what happens you make the ugly other people subject you to explicit.
06:05:10 <benzrf> bitemyapp: btw im
06:05:15 <benzrf> makin vampire into a proper thing
06:05:19 <bitemyapp> benzrf: <3
06:05:24 <benzrf> i made a repo
06:05:25 <bahamas> when is liftM useful then?
06:05:40 <bitemyapp> λ> mkQueryStringQuery (QueryString "blah")
06:05:42 <bitemyapp> QueryStringQuery {queryStringQuery = QueryString "blah", queryStringDefaultField = Nothing, queryStringOperator = Nothing, queryStringAnalyzer = Nothing, queryStringAllowLeadingWildcard = Nothing, queryStringLowercaseExpanded = Nothing, queryStringEnablePositionIncrements = Nothing, queryStringFuzzyMaxExpansions = Nothing, queryStringFuzziness = Nothing, queryStringFuzzyPrefixLength = Nothing, queryStringPhraseSlop = Nothing, queryStringBoost = Nothing, 
06:05:49 <bitemyapp> er, woops. Wrong channel. Sorry.
06:05:49 <Krakarn--> :t liftM (+1) (Just 1)
06:05:51 <lambdabot> Num r => Maybe r
06:06:17 <bitemyapp> re: ^^     -  WE BELIEVE IN NOTHING LEBOWSKI
06:06:25 <Krakarn--> I think it's just because the Monad didn't have a Functor constraint
06:07:46 <quchen> liftM is mostly useful to define fmap in terms of it. In a year or so, that "mostly" will become "only".
06:08:34 <dottedmag> quchen: what is going to happen in a year?
06:08:43 <bitemyapp> dottedmag: 7.10 probably.
06:09:22 <killy9999> I'm trying to understand arrows
06:09:36 <Okasu> dottedmag: Applicative => Monad
06:09:42 <killy9999> Hughes' "Generalising Monads To Arrows" says:
06:10:02 <arj> killy9999: did you see? http://en.wikibooks.org/wiki/Haskell/Understanding_arrows
06:10:04 <killy9999> "arrows do indeed generalise monads; for every monad type, there is a corresponding arrow type"
06:10:16 <killy9999> arj: no, I haven't
06:10:32 <merijn> killy9999: He's referring to Kleisli arrows
06:10:35 <killy9999> does this senetence mean that every monad can be made into an arrow?
06:10:38 <killy9999> ah
06:10:53 <merijn> killy9999: "newtype Kleisli m a b = Kleisli { runKleisli :: a -> m b }"
06:11:10 <merijn> "instance Monad m => Arrow (Kleisli m) where"
06:11:43 <t7> @hoogle Maybe a -> a -> a
06:11:45 <lambdabot> Data.Maybe fromMaybe :: a -> Maybe a -> a
06:11:45 <lambdabot> Prelude asTypeOf :: a -> a -> a
06:11:45 <lambdabot> Data.Generics.Aliases orElse :: Maybe a -> Maybe a -> Maybe a
06:11:46 <killy9999> yes, I undertsand how Kleisli arrows are made into instances of Arrow
06:12:05 <merijn> killy9999: Basically he just means there's a Kleisli arrow for every monad
06:12:06 <killy9999> but I don't undertsnad how it relates to existing monads
06:12:06 <t7> @hoogle m a -> a -> a
06:12:07 <lambdabot> Data.Monoid appEndo :: Endo a -> a -> a
06:12:07 <lambdabot> Prelude asTypeOf :: a -> a -> a
06:12:07 <lambdabot> Data.Maybe fromMaybe :: a -> Maybe a -> a
06:12:44 <killy9999> merijn: right, but what does this conclusion give us?
06:12:52 <killy9999> I mean if I have Maybe monad
06:13:11 <killy9999> can I somehow convert it to Arrow?
06:13:17 <t7> i think there should be a class of things that implement this    a -> m a -> a     fromMaybe, safeHead etc
06:14:18 <merijn> killy9999: You can't convert monads to an Arrow, but you can convert any monadic function to an arrow using Kleisli, yes
06:14:32 <zipper`> t7: There is a fromMaybe
06:14:45 <merijn> If you have "a -> Maybe b" then you can turn that into "Kleisli Maybe a b", which is an arrow
06:14:55 <t7> i don't think you understand what i mena
06:15:09 <killy9999> merijn: ah, that makes sense
06:15:11 <killy9999> thanks
06:15:14 <killy9999> need to lurk more
06:15:39 <bahamas> was LYAH supposed to go farther than Zippers? it ends abruptly
06:15:59 <merijn> bahamas: It was a work in progress (zippers got added later), but BONUS got very busy and didn't continue updating
06:16:48 <bahamas> merijn: I see. I need to move on to something else then
06:16:58 <zipper`> bahamas: What are you saying about me?
06:17:09 <zipper`> bahamas: Are you saying that I am not good enough?
06:17:40 <merijn> bahamas: There's some good wikibooks, RWH (just skip the first couple of chapters explaining haskell) and there's a whole lot of good papers that are fairly easy to read, depending on your interest
06:18:21 <bahamas> zipper`: nothing is
06:18:51 <bahamas> merijn: yeah. I'll give RWH a look. I also want to look at the standard lib
06:18:54 <zipper`> bahamas: ;)
06:18:58 <bahamas> merijn: where are those papers?
06:19:23 <killy9999> bahamas: most papers are available for free on the internet
06:19:53 <bahamas> killy9999: I believe, but I need to know where and what they are. I assumed merijn was referencing some in particular
06:20:00 <bitemyapp> zipper`: you're a comonad.
06:20:05 <bahamas> s/believe/believe you/
06:20:06 <bitemyapp> zipper`: :P
06:20:27 <killy9999> bahamas: I think merijn didn't mean any particular papers
06:20:39 <killy9999> it's just that there are a lot of various topic in Haskell
06:20:48 <merijn> bahamas: There's things linked from documentation (like the exception/stm papers), also this channel is a good source. I know several yeah, but whether they're interesting depends on your interests, i.e. practical haskell programming? Advanced type hacking? Theory?
06:20:57 <killy9999> and depending on your interests you'll want different papers
06:21:16 * hackagebot range-set-list 0.0.6 - Memory efficient sets with continuous ranges of elements.  http://hackage.haskell.org/package/range-set-list-0.0.6 (phadej)
06:21:57 <bahamas> merijn: alright. I'll ask when the time comes. thanks
06:22:03 <zipper`> bitemyapp: I keep hearing comonads. I should read about them. Know what I am.
06:22:54 <heatsink> What is the right command to globally install a package when the global database isn't owned by root?
06:23:45 <zipper`> heatsink: Are you sure you want to install it globally?
06:24:28 <killy9999> heatsink: cabal has --global flag
06:24:48 <heatsink> zipper`, yes.  It's a development version of GHC that is installed in a subdirectory of my home directory.
06:25:43 <heatsink> I don't want cabal to put root permissions on files in my home directory.
06:26:33 <heatsink> and since it's a development version of GHC, I don't want it cluttering the directories where user-level packages get installed
06:28:02 <merijn> heatsink: GHC uses a per version package database
06:28:22 <merijn> heatsink: So dev GHC shouldn't clutter the user-level package directories?
06:30:00 <killy9999> heatsink: may it be that you want a way of sandboxing GHC?
06:30:28 <heatsink> That would be nice.  Cabal 1.16 doesn't have 'sandbox'.
06:30:56 <killy9999> heatsink: http://lambda.jstolarek.com/2013/12/configuring-ghc-development-environment-tips-tricks/
06:31:06 <killy9999> see second section "Sandboxes"
06:31:22 <killy9999> and, most importantly, check the link to Edsko's blog post
06:32:04 * edsko is glad his blogpost is still useful :)
06:32:46 <zipper`> edsko: Wait are you jstolarek?
06:33:00 <edsko> whatwhatwhat? :)
06:33:08 <zipper`> edsko: If you are I've been having issues with http://lambda.jstolarek.com/2012/10/code-testing-in-haskell/
06:33:14 <edsko> nope, I'm not
06:33:31 <edsko> I'm the "edsko" in "sandboxing method described by Edsko" :p
06:33:45 <fser> Hi! I have an issue understanding attoparsec char8 datatype. I've followed a tutorial (https://www.fpcomplete.com/school/starting-with-haskell/libraries-and-frameworks/text-manipulation/attoparsec) which proposes to parse IP addr, using char8 datatypes. But I you try to parse a non valid IP, such as 331.45.68.123, the parser does not complain, and returns 75 45 68 123.
06:34:02 <killy9999> zipper`: I'm jstolarek
06:34:19 <fser> I that "normal"? I mean, one could expect strong typing and side effect free language not to silently fail that way, don't you think so?
06:34:36 <killy9999> zipper`: what were the problems?
06:34:48 <zipper`> edsko: I wish I'd seen that just 15 minutes ago,
06:35:09 <klrr_> fser: not sure what you mean, gonna check the link
06:35:20 <klrr_> or, can you paste the code?
06:35:20 <zipper`> killy9999: Ok the issue I had got me so frustrated that I gave up on testing for a while.
06:35:43 <fser> klrr_: main = print $ parseOnly parseIP "331.45.68.123"
06:35:49 <fser> returns 75 45 68 123
06:35:50 <zipper`> killy9999: but I guess it's good coicidence because I decided to try it again today. I'm taking another shot.
06:35:59 <fser> where 75 is the truncated value of 331
06:36:12 <zipper`> killy9999: If I run into any issues I will ask you. I seem to have forgot the specific issues.
06:36:20 <klrr_> fser: well that's not the code im interested in ;)
06:36:21 <fser> which is understandable given the binary representation, but I would have expected an error while parsing
06:36:26 <fser> of course
06:36:27 <fser> wait
06:36:39 <killy9999> zipper`: sure, although I won't be here for too long today
06:36:46 <killy9999> but you can always comment on the blog post
06:36:54 <fser> klrr_: http://paste.lautre.net/?213e4d89a4700cd6#JYovVZKpGbLfYcucTFf60dZ1uUefQjmboEu3AaNLdV8=
06:37:09 <klrr_> thanks
06:37:50 <zipper`> killy9999: What's your timezone? What time of the day are you usually online?
06:38:07 <heatsink> Why do the sandbox instructions say to configure with a --prefix path that's not in the sandbox?
06:38:30 <killy9999> zipper`: Europe
06:38:35 <killy9999> That's GMT+1
06:39:06 <zipper`> killy9999: hmmm I am GMT+3 so I guess whenever it is daytime for me it is daytime for you.
06:39:21 <killy9999> ah, sounds like Russia
06:39:27 <killy9999> ie. Moscow
06:39:32 <zipper`> killy9999: I might ask you tomorrow.
06:39:42 <zipper`> killy9999: Who me? No. I am in Nairobi.
06:39:44 <klrr_> fser: no idea why, but it certainly caused by the semantics of the decimal parser
06:39:47 <klrr_> http://hackage.haskell.org/package/attoparsec-0.11.3.4/docs/src/Data-Attoparsec-ByteString-Char8.html#decimal
06:39:57 <killy9999> oh
06:40:15 <killy9999> zipper`: your best shot is to contact me via comments on the blog post
06:40:16 <dottedmag> There's whole continent down there under Europe ;)
06:40:26 <killy9999> or post to haskell-cafe and CC me
06:40:31 <killy9999> I;m not too often on IRC
06:40:36 <fser> klrr_: do you agree that this is unexpectable?
06:40:46 <killy9999> I mean I'm always on the channel because I have a session running on my server
06:41:35 <killy9999> zipper`: also, you might be interested in this post: http://lambda.jstolarek.com/2014/01/code-testing-in-haskell-revisited-with-tasty/
06:41:37 <zipper`> killy9999: I could PM you and whenever you join you will find the question.
06:41:56 <zipper`> killy9999: I will look at that.
06:42:04 <killy9999> zipper`: sure, except that I won't get the notification until I log to the server :-)
06:42:12 <klrr_> fser: hmm
06:42:18 <killy9999> but if that's fine for you then it is fine for me
06:42:24 <killy9999> anyway, need to go AFK
06:42:27 <klrr_> fser: i tried decimal in the terminal and it worked fine
06:42:31 <klrr_> might be a bug
06:42:49 <fser> no overflow?
06:42:57 <zipper`> killy9999: Ok uh first Moscow seems to be GMT+4. I guess I could CC you from haskell-cafe. I always wanted to use it.
06:43:05 <klrr_> overflow?
06:43:29 <zipper`> killy9999: White background for text hurts my eyes.
06:43:32 <zipper`> :(
06:44:11 <fser> klrr_: 331 beeing returned as 75 isn't an int8 overflow to you?
06:45:14 <dottedmag> > 766::Int8
06:45:16 <lambdabot>  can't find file: L.hs
06:45:31 <Maior> win 57
06:45:34 <Maior> er sorry
06:45:39 <rwbarton> Word8 is specifically supposed to have wrap-around behavior (mod 256)
06:45:49 <fser> Oh I see.
06:45:58 <fser> not a bug then.
06:46:28 <rwbarton> you could argue that maybe the 'decimal' parser ought to try to check for overflow
06:46:30 <fser> But still, in that context, I would have wanted the compiler to complain about the size of the input, because the first quartet (331) cannot fit into the int8 of the first quartet of the IP.
06:47:23 <rwbarton> well the compiler has no idea about that
06:47:23 <killy9999> zipper`: sorry :-( It looks really good on my screen
06:47:33 <killy9999> perhaps you can force the browser to use a custom css
06:47:57 <dottedmag> fser: you'll need to either use another parser (not decimal) or check values before return
06:48:01 <fser> but still, from my point of view, the input data does not fit so it should not be accepted as an input
06:48:35 <rwbarton> you could use 'decimal' at type Integer, and then check that the result is within the bounds of Word8 before converting
06:48:41 <klrr_> fser: well that would require dependent types or a wrapper checking its size
06:48:48 <zipper`> killy9999: Yes I usually do that. It's no biggie.
06:49:05 <fser> dottedmag: I'm trying to understand some basics here. I mean, in Coq for instance, you can have "fixed size array" type. So I was thinking that maybe, using a small data type in haskell would provide stronger guaranties than in C, where you would expect that behaviour.
06:49:16 <rwbarton> fser, there is a guarantee
06:49:22 <rwbarton> a Word8 will only store a number from 0 to 255
06:49:27 <killy9999> zipper`: a good thing in using Haskell-Cafe is that you are likely to also get answers from Roman Cheplyaka, who wrot Tasty and knows a lot more about tasting than I do
06:49:31 <fser> same in C rwbarton
06:49:43 <rwbarton> it's just that also by definition, with the arithmetic operations on Word8, 3*100 + 3*10 + 1 = 75
06:49:46 <rwbarton> yes
06:49:48 <dottedmag> fser: Not for signed ints, though.
06:49:53 <fser> but this is regarding the underlying architecture. At least the truncate part.
06:49:58 <klrr_> fser: i think Word8 works like this, if you go above 255 it "starts over"
06:50:06 <fser> I see.
06:50:33 <fser> thanks for your inputs :)
06:50:34 <dottedmag> fser: There are other types to choose from, like Integer (which you can check afterwards)
06:50:55 <fser> dottedmag: let's consider another example
06:51:07 <dottedmag> But parsing directly into Word8 is, well, unwise.
06:51:59 <fser> if I want to have 2 data types, such as "smallint" and "largeint" where the inference rule would be (stupid of course, just for the example) that every integer lesser than 65536 should be smallint , and over should be largeint
06:52:21 <fser> then there would be no way to build this with the grammar only, I should have to add a specific conditionnal case?
06:53:33 <dottedmag> That is dependent types, I suppose.
06:54:35 <fser> then I see no point to use int8 rather than int, because in all case, the memory footprint shloud not be a concern in functionnal language.
06:55:03 <rwbarton> what
06:55:21 <rwbarton> you use Int8 if you want the semantics of a single-byte value with wraparound behavior
06:56:20 * hackagebot diagrams-core 1.2.0.1 - Core libraries for diagrams EDSL  http://hackage.haskell.org/package/diagrams-core-1.2.0.1 (BrentYorgey)
06:56:46 <rwbarton> or if you just want to represent the fact that the number will be a single byte
06:56:47 <rwbarton> in an API
06:56:50 <fser> rwbarton: I may totally be wrong
06:57:06 <fser> but I expect it to be lesser than 255 because of it's size
06:57:09 <fser> not wrapped
06:57:13 <fser> but this is a "debate"
06:57:26 <fser> a false understanding of strong typing from a system guy :)
06:57:42 <rwbarton> well I'm really confused
06:57:52 <rwbarton> an Int8 is just an integer in the range -128..127
06:57:56 <rwbarton> it's not "wrapped"
06:57:59 <dottedmag> fser: It *will* be lesser
06:58:10 <rwbarton> now, the arithmetic on Int8 uses wrap-around to handle overflow/underflow
06:58:11 <fser> sorry this might be because of my english.
06:58:32 <dottedmag> fser: But conversion from integer will be by mod 256.
06:58:44 <dottedmag> That's how it defined.
06:58:49 <fser> dottedmag: indeed, 75 is lesser :)
06:59:02 <fser> let me try it another way, maybe you'll understand my point of view.
06:59:23 <dottedmag> fser: basically you'd like to have a type which causes runtime error on conversion from int outside of range. right?
06:59:50 <merijn> fser: The problem is that "decimal" works for ANY integral type and therefore doesn't do bounds checking
06:59:55 <fser> in C
06:59:59 <fser>         char a = 42;
06:59:59 <fser>         char b = 65536;
07:00:03 <fser> and gcc complains :
07:00:06 <fser> machin.c:4:2: warning: overflow in implicit constant conversion [-Woverflow]
07:00:14 <rwbarton> ghc will warn also
07:00:24 <dottedmag> BTW, why Integral is not Bounded?
07:00:26 <merijn> rwbarton: It won't
07:00:28 <fser> so when I write a compiler, using small datatypes, I expect the same kind of behaviour, but from the underlying lib itself.
07:00:32 <rwbarton> <interactive>:4:1: Warning: Literal 65536 is out of the Int8 range -128..127
07:00:36 <merijn> dottedmag: Because not all Integral types are bounded?
07:00:40 <merijn> dottedmag: Integer is not bounded
07:00:45 <dottedmag> Oh, right.
07:00:57 <merijn> rwbarton: Oh, that didn't happen last time I tried. Yay! Progress!
07:01:21 * hackagebot diagrams-lib 1.2.0.1 - Embedded domain-specific language for declarative graphics  http://hackage.haskell.org/package/diagrams-lib-1.2.0.1 (BrentYorgey)
07:01:21 <rwbarton> oh yeah, I see it's new in 7.8
07:01:32 <merijn> fser: Right, but that's not what decimal does and writing what decimal does in C would also not produce a warning
07:01:43 <fser> merijn: that I agree.
07:01:58 <fser> but I was expecting some magic from the haskell prophete :D
07:02:09 <merijn> fser: And the simple answer is: You need to write your own replacement for decimal if you want bounds checking
07:02:15 <fser> but I get it, again, thanks everyone! :)
07:02:28 <dottedmag> fser: there's nifty class called Bounded
07:02:54 <merijn> fser: The source is here: http://hackage.haskell.org/package/attoparsec-0.12.0.0/docs/src/Data-Attoparsec-Text.html#decimal should not be hard to adapt that into something that does bounded checking too
07:02:55 <fser> which will produce the runtime error?
07:03:10 <fser> ok merijn
07:03:12 <dottedmag> fser: so if you have something like boundedDecimal :: (Integral a, Bounded a) => Parser a, then you can call literal inside and do a bounds checking using maxBound and minBound
07:03:14 <merijn> fser: No, the Bounded class is really separate from this discussion
07:03:15 <fser> but i'm still a newbe :)
07:03:26 <dottedmag> s/literal/decimal/
07:03:42 <merijn> fser: Well, it's literally just a fold + simple Char to Int conversion :)
07:03:56 <fser> yep I saw that
07:04:02 <fser> quiet simple indeed.
07:05:02 <merijn> fser: Bounds checking with fixed size types is kinda a pain though, I committed some commented code for that to the RTS, maybe I should generalise it and put it in a library...
07:05:50 <merijn> Lemme find the snippet
07:06:30 <merijn> Github has no way to search commits? :\
07:06:56 <dottedmag> merijn: git log -S<text>?
07:07:05 <hvr> merijn: try http://git.haskell.org
07:07:56 <yubrew> couldn't git log | grep <text> work?
07:08:20 <hvr> yubrew: then you could just use 'git log --grep=<text>'
07:08:22 <dottedmag> Oh, right, -S is for the diffs
07:08:46 <merijn> dottedmag: I don't use git
07:08:56 <merijn> fser: See these comments: https://github.com/merijn/ghc/blob/master/libraries/base/GHC/Event/Poll.hsc#L107-L140
07:09:23 <fser> thanks!
07:09:42 <merijn> It's kinda ugly
07:10:06 <rwbarton> max maxBound ... looks funny
07:10:22 <merijn> rwbarton: Yes, there's a reason why there's 2/3 commits :p
07:10:39 <merijn> rwbarton: "Fixed OS X RTS crash" -> "*Really* fixed OSX RTS crash" :p
07:11:02 <rwbarton> doesn't this always return maxBound
07:11:32 <hvr> rwbarton: only for well-defined Bounded/Ord instances =)
07:11:40 <rwbarton> well, here it's Int
07:11:53 <merijn> rwbarton: Ugh, now I need to rethink this patch again, last month I was worried about correctness too
07:13:56 <rwbarton> I'm confused why the final result isn't equivalent to the initial version though
07:14:00 <dottedmag> merijn: in the case 2 it will return maxBound :: Int
07:14:12 <dottedmag> Not maxBound :: Cint, as per comment
07:14:22 <merijn> dottedmag: Yes, I'm trying to figure out why I thought this was correct >.<
07:14:41 <dottedmag> Pretty useful function, btw. maxPollTimeout = maxBound :: Int ;)
07:16:09 <merijn> I remember having the same doubts a month ago, but I don't remember why I decided it was correct then
07:16:22 * hackagebot linx-gateway 0.1.0.0 - Implementation of the Enea LINX gateway protocol.  http://hackage.haskell.org/package/linx-gateway-0.1.0.0 (PatrikSandahl)
07:16:35 <rwbarton> well, did it fix the crash? :)
07:16:57 <rwbarton> I don't understand how it could so maybe I'm missing something
07:17:41 <merijn> rwbarton: It did, but it introduced a newer less likely one, hence the second patch
07:17:52 <rwbarton> I mean, was it still fixed after the second patch
07:17:57 <merijn> Yes
07:17:58 <rwbarton> which looks to me like it effectively undoes the first patch
07:18:03 <merijn> rwbarton: No
07:18:25 <rwbarton> because maxPollTimeout = maxBound
07:18:29 <Ankhers> Does anyone use company-mode within Emacs for Haskell?
07:18:33 <rwbarton> and then tout <= maxPollTimeout is always true
07:18:35 <rwbarton> I would think
07:18:56 <merijn> Let's see
07:19:33 <merijn> rwbarton: ugh
07:19:58 <merijn> See, this is why I fully support the notion of having hardware traps for overflows and only explicit conversions
07:20:29 <merijn> like 3 people have looked over this patch and everyone missed the bugfix of the bugfix introduced yet another bug
07:20:37 <ljosha> what is the common pattern to generate many different random sequences? I have to generate some objects with random attributes, each attribute has its own range. Currently I use split and randomRs to generate them, but this means too many splits.
07:20:55 <gdoteof> i have something like `myList <- readIORef myIORef; let newList = if (member key myList) then myList; else do --some IO-- and I think I am not allowed to do IO there?
07:21:23 * hackagebot avr-shake 0.0.0.2 - AVR Crosspack actions for shake build systems.  http://hackage.haskell.org/package/avr-shake-0.0.0.2 (JamesCook)
07:22:26 <saml> gdoteof, you probably have to run the io in else expression
07:22:56 <saml> type of A and B should be the same in  if Bool then A else B
07:22:57 <dottedmag> merijn: min (toInteger (maxBound :: Int)) (toInteger (maxBound :: CInt)) -- something like this?
07:23:27 <gdoteof> oh.. i see.  i am not doing IO in the true branch, only the else branch
07:23:46 <saml> @hoogle m a -> a
07:23:48 <lambdabot> Language.Haskell.TH.Syntax Q :: (forall m. Quasi m => m a) -> Q a
07:23:48 <lambdabot> Network.BufferType buf_empty :: BufferOp a -> a
07:23:48 <lambdabot> Data.Monoid getDual :: Dual a -> a
07:24:03 <saml> @hoogle IO a -> a
07:24:04 <lambdabot> Foreign.Marshal unsafeLocalState :: IO a -> a
07:24:04 <lambdabot> System.IO.Unsafe unsafePerformIO :: IO a -> a
07:24:04 <lambdabot> Foreign unsafePerformIO :: IO a -> a
07:24:09 <merijn> dottedmag: Plus conversion back to Int, yeah
07:26:14 <merijn> Should be: "fromIntegral $ min (toInteger (maxBound :: Int)) (toInteger (maxBound :: CInt))"
07:26:24 * hackagebot twitter-feed 0.1.1.1 - Client for fetching Twitter timeline via Oauth  http://hackage.haskell.org/package/twitter-feed-0.1.1.1 (jsl)
07:26:56 <ljosha> currently i use something like: http://lpaste.net/7842319852512477184
07:27:16 <Francis49> hello friens, need some help if you can
07:27:25 <ljosha> but everything should be random, no fixed category etc
07:27:32 <saml> we can help Francis49
07:27:33 <bahamas> Francis49: just ask the question
07:27:50 <Francis49> thank you saml
07:27:58 <Guest23122> What's the best way to convert Data.ByteString.Char8 to Data.ByteString.Lazy?
07:28:00 <alpounet> ljosha: i've written http://hackage.haskell.org/package/probable for that among other things
07:28:06 <Francis49> do you know the leksah ide?
07:28:10 <gdoteof> saml: since I am modifying an IORef isn't that a dangerous place to use unsafePerformIO?
07:28:23 <alpounet> ljosha: see http://hackage.haskell.org/package/probable-0.1.0.0/docs/Math-Probable-Random.html
07:28:35 <saml> gdoteof, i'd do    result <- if condition then return x  else do { ... ; return somethingElse }
07:29:01 <saml> gdoteof, i mean, do a "return"  in true expression
07:29:02 <Guest23122> nevermined, found an SO answer.
07:30:06 <Yuu_chan> Francis49: we do, is this the question? :)
07:30:30 <gdoteof> saml: thanks.
07:31:06 <Francis49> i am new to askel, saml. the question is: the haskel compiler is built-in inside the leksah ide?
07:31:28 <tdammers> Francis49: no
07:31:30 <saml> Francis49, ghc is a popular haskell compiler. i believe leksah uses it
07:31:47 <ljosha> alpounet: thanks, i'm reading it.
07:31:51 <tdammers> AFAIK, leksah calls out to ghc
07:32:01 <tdammers> but ghc is a standalone compiler
07:32:16 <tdammers> you can invoke it directly, or you can use a tool like cabal, or a makefile, to call it
07:32:24 <tdammers> or you can hook it into an IDE, like leksah
07:32:32 <Yuu_chan> Francis49: if you are new, install Haskell Platform and then Leksah
07:33:01 <albeit> If I have a  :: Fixed E12, how can I convert that to an Int? (Discarding any part after the decimal)
07:33:56 <Francis49> i downloaded the hgc 7.8.2 but i am unable to run it inside the leksah ide
07:35:58 <albeit> :t truncate
07:35:59 <lambdabot> (RealFrac a, Integral b) => a -> b
07:36:05 <Yuu_chan> Francis49: are there any error messages?
07:36:17 <Yuu_chan> :t round
07:36:18 <lambdabot> (RealFrac a, Integral b) => a -> b
07:36:25 * hackagebot roman-numerals 0.5.1.4 - Parsing and pretty printing of Roman numerals  http://hackage.haskell.org/package/roman-numerals-0.5.1.4 (RoelVanDijk)
07:37:04 <Francis49> yes Yuu, a lot of error message. i am accustomed with lisp, interactive
07:37:47 <Francis49> i found a lot of problems so far
07:41:25 * hackagebot json-schema 0.5 - Types and type classes for defining JSON schemas.  http://hackage.haskell.org/package/json-schema-0.5 (AdamBergmark)
07:42:23 <Yuu_chan> Francis49: if you like lisp, use emacs :)
07:43:42 <Francis49> Yuu, i like to migrate to Haskell. Can you suggest me what i must do? As tell before, i came from an interactive programming
07:44:09 <tdammers> Francis49: there is nothing you "must" do, really
07:44:24 <tdammers> Francis49: if you like a REPL, you can play with haskell in ghci
07:44:25 <Yuu_chan> Francis49: Haskell offers interactive programming and REPL
07:44:43 <seanparsons> Francis49: #leksah might be of more use for Leksah specific questions.
07:44:56 <seanparsons> Emphasis on might however.
07:44:58 <seanparsons> :)
07:45:18 <tdammers> and you don't really need an IDE either; the language is concise enough to get away with just a text editor and a standalone compiler even for relatively large projects
07:45:38 <Francis49> then i must use ghci in a console? to be interactive i mean
07:46:06 <Yuu_chan> I agree with tdammers, Leksah could be too cumbersome to start toying with a new language
07:46:18 <lwm> Francis49: you can try to emulate this environment if you like vim - http://haskelllive.com/environment.html
07:46:42 <lwm> Francis49: could be considered overkill ... but quite cool
07:46:47 <osfameron> yeah, with an ide, you often end up spending lots of energy learning the ide...
07:46:50 <Yuu_chan> Francis49: as long as you have GHC installed, just type ghci in the console. Or, if you are on Windows, launch WinGHCi.
07:47:20 <Yuu_chan> Then you got REPL and can try examples and so on
07:48:00 <Francis49> and where i find the REPL if i am from the console?
07:48:27 <Yuu_chan> ghci is a REPL itself
07:48:42 <tdammers> Yuu_chan: Francis49 not just that; haskell is pretty damn good, but it's a fast-moving target, things break occasionally, and you are expected to make an active effort at keeping up, so installing an IDE and expecting everything to work flawlessly out of the box can be disappointing
07:49:11 <Yuu_chan> http://learnyouahaskell.com/starting-out#ready-set-go can be useful for you
07:50:43 <Yuu_chan> tdammers: I installed Leksah a while ago and it worket out of the box... but was quite unintuitive. And I still don't know how to fix the problem with packages indexing on Windows.
07:51:21 <tdammers> Yuu_chan: all I'm trying to say is you won't get the same kind of smooth experience as you'd expect from, say, VisualStudio or Eclipse
07:51:27 * hackagebot algebraic 0.1.0.0 - General linear algebra structures.  http://hackage.haskell.org/package/algebraic-0.1.0.0 (danilo2)
07:51:37 <tdammers> but then, I'm totally not an IDE guy, so maybe I got it all wrong
07:51:51 <Sculptor> hi
07:52:22 <Francis49> i tryed eclipse too, but was unable to download the haskell plugin
07:55:43 <Francis49> tdammer, yuu, i will try again. suggest me some books
07:56:02 <tdammers> @where lyah
07:56:03 <lambdabot> http://www.learnyouahaskell.com/
07:56:06 <tdammers> @where rwh
07:56:07 <lambdabot> http://www.realworldhaskell.org/blog/ http://book.realworldhaskell.org/read/
07:56:17 <tdammers> also, write yourself a scheme
07:56:26 <tdammers> not sure how to get that out of lambdabot :D
07:56:42 <tdammers> that last one should appeal to you as a lisper
07:56:46 <rwbarton> @where scheme
07:56:46 <lambdabot> https://en.wikibooks.org/wiki/Write_Yourself_a_Scheme_in_48_Hours
07:56:50 <tdammers> ah
07:56:53 <tdammers> yeah
07:57:11 <tdammers> it teaches you haskell by implementing a basic scheme in it
07:58:07 <klrr_> great tutorial
07:58:11 <Yuu_chan> http://ohaskell.dshevchenko.biz/en/ a new introductory ebook
07:58:15 <klrr_> made programming click for me
07:59:18 <Francis49> hehehe dear friends, i used scheme too. i want learn haskell. wello dear friends, i will try the sites you tell me. I come back later. thank you very much and a nice day for you all. bye
07:59:37 <Yuu_chan> Good luck Francis49 :)
08:00:23 <Francis49> thenk you bye all
08:00:41 <klrr_> l
08:01:28 * hackagebot rest-types 1.10.0.3 - Silk Rest Framework Types  http://hackage.haskell.org/package/rest-types-1.10.0.3 (AdamBergmark)
08:01:30 * hackagebot rest-stringmap 0.2.0.1 - Maps with stringy keys that can be transcoded to JSON and XML.  http://hackage.haskell.org/package/rest-stringmap-0.2.0.1 (AdamBergmark)
08:01:32 * hackagebot rest-snap 0.1.17.11 - Rest driver for Snap.  http://hackage.haskell.org/package/rest-snap-0.1.17.11 (AdamBergmark)
08:01:32 <Yuu_chan> bitemyapp: so, ranged date queries with dates encoded as doubles really work. I had corrupted data the first time :)
08:01:34 * hackagebot rest-gen 0.13.1.2 - Documentation and client generation from rest definition.  http://hackage.haskell.org/package/rest-gen-0.13.1.2 (AdamBergmark)
08:01:36 * hackagebot rest-core 0.30.0.3 - Rest API library.  http://hackage.haskell.org/package/rest-core-0.30.0.3 (AdamBergmark)
08:01:56 <Yuu_chan> (I found that when already wrote a hack for string-based ranges)
08:13:09 <z0d> anyone else having problems installing cabal-install? I run bootstrap.sh and get: <no location info>: module 'parsec-3.1.5:Main' is defined in multiple files: .....
08:16:29 * hackagebot cyclotomic 0.4.3 - A subfield of the complex numbers for exact calculation.  http://hackage.haskell.org/package/cyclotomic-0.4.3 (ScottWalck)
08:17:35 <ReinH> chrisdone_: So I've decided. I'm going to give myself a month to learn emacs for good.
08:17:53 <shapr> ReinH: yay!
08:22:12 <ReinH> shapr: wish me luck
08:23:00 <shapr> ReinH: good luck! and feel free to ask questions, I'm a long time emacs user
08:23:12 <vanila> how would you define liftMn for any n?
08:23:16 <vanila> generically
08:23:20 <ReinH> shapr: Thanks! My problem is that I'm a long time vim user. ;)
08:23:20 <shapr> I use emacs for irc, twitter, jabber, todo lists, shell, and a bunch of other things.
08:23:25 <solidus-river> anyone have thoughts on sodium vs reactive banana from a performance standpoint for games?
08:23:36 <shapr> ReinH: I used vi before I made a serious effort at comparing the two
08:23:52 <vanila> I spent about an hour trying things but nothing worked
08:23:55 <ReinH> shapr: I've used vim for about a decade :)
08:23:58 <solidus-river> i took a look at netwire and it looks too opinionated about frp to jump on
08:24:06 <ReinH> shapr: so I've got some serious muscle memory to contend with
08:24:08 <solidus-river> but i cant decide between sodium / reactive banana
08:24:26 <shapr> ReinH: Yeah, I remember. You may end up with vimperator or one of those modes to help you out
08:24:35 <ReinH> shapr: absolutely not :)
08:24:51 <shapr> ReinH: good choice :-)
08:24:53 <ReinH> I can't stand vim modes in non-vim editors
08:24:54 <Yuu_chan> bitemyapp: I execute a filtered query and get that "filter does not support [execution]" exception in Elastic response
08:25:05 <ReinH> they are always broken in some way that makes them untenable
08:25:09 <ReinH> I use a *lot* of vim ;)
08:25:13 <shapr> ReinH: also, even if you don't end up switching to emacs, you'll still learn useful things you can do with any editor.
08:27:38 <solidus-river> i guess i'll just have to write a simple game in all three and make a post about the experience :)
08:27:57 <rwbarton> solidus-river, I'd be interested
08:28:02 <rwbarton> I have used only reactive-banana
08:28:14 <rwbarton> sodium seemed to have a pretty similar API
08:30:10 <solidus-river> aye, sodium and reactive banana seem pretty comperable, netwire is supposed to be specifically for gaming / ai etc but i've heard bad things about that design decision being restrictive
08:44:24 <dottedmag> shapr: Or at least in every readline-based shell.
08:45:26 <shapr> dottedmag: Yup, although you can change edit themes for readline
08:48:13 <z0d> I'm installing cabal and after ./Setup install it gets installed, but I don't find the cabal executable
08:48:28 <z0d> only the library is installed(?)
08:48:43 <dottedmag> z0d: have you installed cabal-install package?
08:48:55 <z0d> not yet. do I need to install it beforehand?
08:49:08 <dottedmag> cabal contains the library, cabal-install contains the CLI frontend.
08:49:12 <geekosaur> no, cabal-install is the cabal command, Cabal is just a library
08:49:21 <z0d> oh
08:49:23 <benzrf> :t (=<<)
08:49:24 <lambdabot> Monad m => (a -> m b) -> m a -> m b
08:49:25 <z0d> thank you. didn't know that
08:53:43 <Yuu_chan> benzrf: (=<<) = flip (>>=) and has an opposite fixity
08:54:31 <piezoid> Archlinux doesn't install profiling libs, so how i'm supposed to profile an application ?
08:55:14 <piezoid> ultimately, every lib will require the profiling version of base, so I can't juste use a sandbox
08:55:38 <pjdelport> Doesn't it have profiling versions of the libraries packaged?
08:56:53 <TallerGhostWalt> so it seems like there is a max speed you can openLocalStateFrom, in acid-state
08:56:57 <TallerGhostWalt> really odd
08:57:01 <TallerGhostWalt> maybe a gc issue?
08:57:01 <piezoid> pjdelport: no.
08:58:03 <piezoid> cabal doesn't allow me to rebuild base, is it really impossible ?
08:58:23 <piezoid> I know it's ugly but I don't see another way...
08:58:28 <rwbarton> arch is nuts
08:58:37 <rwbarton> you definitely can't rebuild base in any way
08:58:43 <saml> archlinux?
08:58:45 <rwbarton> I would just install from the binary tarball
08:59:09 <rwbarton> or, maybe the profiling libraries are in some other arch package?
08:59:11 <benzrf> hmmmm
08:59:19 <benzrf> does haskell have anything resembling thorkilnaur
08:59:21 <benzrf> *Thor
08:59:40 <solidus-river> benzrf: are you talking about the rails thing?
08:59:44 <nclarke> A bearded god with a mystical hammer that can control the lightning?
08:59:55 <benzrf> solidus-river: since when is it a rails thing
09:00:05 <solidus-river> benzrf: are you talking about the ruby thing?
09:00:07 <piezoid> rwbarton: thanks, I'll use that.
09:00:08 <benzrf> solidus-river: yes
09:00:27 <solidus-river> no it doesn't, but i've replicated that functionality using grunt.js
09:00:34 <benzrf> eeehhh
09:00:35 <z0d> where should I add --ghc-options for this workaround: https://github.com/haskell/cabal/issues/1740 ?
09:01:01 <benzrf> how would you like it if you were in #ruby and for something like lens, and i said 'are you talking about that yesod thing'
09:01:02 <solidus-river> benzrf: if you want to reinvent a thing that watches things and does stuff, be my guest, but i'd just use grunt or guard
09:01:04 <benzrf> ;p
09:01:08 <benzrf> huh?
09:01:12 <benzrf> no, Thor is this:
09:01:18 <benzrf> http://whatisthor.com/
09:02:05 <solidus-river> benzrf: oh i'm thinking of something completely different
09:02:26 <solidus-river> benzrf: no it doesnt, maybe in templatehaskell land
09:03:07 <benzrf> D:
09:03:10 <benzrf> i should make it!
09:03:15 <solidus-river> benzrf: honestly that model doesn't seem to fit well into a haskell land, unless your over level 9000 in the type system
09:03:23 <benzrf> well i just mean
09:03:34 <benzrf> some kind of dsl for making cmdline interfaces
09:03:37 <solidus-river> you want something to abstract cli based IO and do thigns with it
09:03:39 <benzrf> not necessarily directly isomorphic :u
09:03:42 <benzrf> yeah
09:04:07 <solidus-river> benzrf: your going to have a hell of a time getting the type system to be ok with that, i think best bet is still something in template haskell
09:04:13 <benzrf> >mfw
09:04:38 <albeit> If I have a file with a bunch of imports, is there any way to see what imports its not using?
09:04:41 <TallerGhostWalt> has anyone had any trouble reading large numbers of files in other libraries?
09:04:53 <TallerGhostWalt> they are using the Posix FD stuff in acid-state
09:05:13 <solidus-river> benzrf: but i wish you luck :D
09:05:14 <TallerGhostWalt> I get invalid file descriptor warnings if I openLocalState too fast
09:06:36 * hackagebot algebraic 0.1.0.1 - General linear algebra structures.  http://hackage.haskell.org/package/algebraic-0.1.0.1 (danilo2)
09:06:39 <benzrf> solidus-river: im thinking make a simple description monad
09:06:45 <benzrf> with liek
09:06:48 <benzrf> *like
09:06:51 <benzrf> some stuff?
09:08:09 <benzrf> hmmmmmmmm
09:08:16 <z0d> anyone having problems with this on MacOSX: https://github.com/haskell/cabal/issues/1740 ?
09:08:56 <piezoid> is libHSbase-4.7.0.0_p.a a lib with profiling ?
09:09:05 <rwbarton> piezoid: yes
09:09:16 <rwbarton> the '_p' means profiling
09:10:07 <piezoid> ok, so arch ship static profiling libs but not the dynamic ones :)
09:11:11 <piezoid> but Cabal keeps looking for p_dyn libs...
09:11:33 <rwbarton> I'm not sure profiling dynamic libraries are supported at all
09:12:05 <rwbarton> at any rate the binary distribution doesn't include them either
09:12:50 <piezoid> rwbarton: ok, but why cabal wants p_dyn ? I'm in a sandbox with 'shared: False'
09:13:04 <rwbarton> probably you have executable-dynamic: True
09:13:22 <rwbarton> if you're trying to profile an executable
09:13:34 <rwbarton> (as opposed to just building profiling versions of a library)
09:14:11 <rwbarton> hmm... https://ghc.haskell.org/trac/ghc/ticket/5021
09:14:19 <piezoid> oh, ok. I forgot to reenable library-vanilla in the sandbox (disabled from my user config)
09:15:25 <piezoid> so even with 'shared : False' cabal try really hard to build something, it's cute...
09:16:37 * hackagebot snap-core 0.9.6.3 - Snap: A Haskell Web Framework (core interfaces and types)  http://hackage.haskell.org/package/snap-core-0.9.6.3 (GregoryCollins)
09:21:38 * hackagebot transf 0.12 - Text transformer and interpreter.  http://hackage.haskell.org/package/transf-0.12 (HansHoglund)
09:26:39 * hackagebot snap-server 0.9.4.5 - A fast, iteratee-based, epoll-enabled web server for the Snap Framework  http://hackage.haskell.org/package/snap-server-0.9.4.5 (GregoryCollins)
09:29:59 <sveit> is it more performan to have an algebraic data type that is frequently switched between, or a single-constructor data type with a field?
09:30:04 <sveit> performant*
09:31:32 <levi> What do you mean by "switched-between"?
09:33:00 <sveit> so for example i could have data DataType = TA Int | TB Int and have many operations like "f (TA a) = TB a"
09:33:43 <sveit> or I could have data DataType2 = T Char Int and have operations like "f (T 'a' i) = T 'b' i
09:34:19 <levi> I can't imagine your second option having better performance than the first.
09:35:24 <levi> A sum type is essentially a 'tagged union' representation, and GHC's code for discriminating unions is reasonably fast, as that's at the very core of the evaluation model.
09:36:01 <levi> It uses some pointer tagging tricks, IIRC.
09:37:09 <sveit> and there are definitely no data copies during the conversions? i asked this before but just want to clarify/make sure of exceptions
09:37:11 <levi> For the second option, you would have the overhead of an extra field, which (unless you made it strict and instructed the compiler to unbox it) would be a reference field that it'd have to follow to do the pattern match.
09:37:18 <rwbarton> using a boxed Char like in your second example is definitely very bad
09:37:30 <ovens> is this usage of unsafeInterleaveIO reasonable? http://lpaste.net/10111379511967744
09:38:43 <levi> sveit: Are you sure data copies would be a problem?
09:39:52 <monochrom> both choices copy.
09:39:55 <rwbarton> well, it has to copy the pointer to the Int into the newly-allocated value
09:42:37 <monochrom> ovens: it seems reasonable
09:43:38 <ovens> I just tried eliding the unsafePerformIO and my segfault is still around... so I guess my problem must be something much subtler...
09:45:21 <sveit> levi, monochrom, rwbarton: so I just gave an example, in reality the enclosed data is not an int but a larger type with lots of subfields. my real question is would THAT be copied? I think this would indeed be costly
09:45:42 <monochrom> a pointer is copied
09:46:18 <tommd> Unacceptably high overhead involved in that.
09:47:35 <levi> sveit: Pretty much everything in haskell is handled by reference unless you are explicit about asking your compiler to make it strict and unboxed.
09:47:39 <albeit> What's the best way to update a package on cabal? "cabal install package-a.b.c.d" or --reinstall or something else?
09:48:48 <DanielDiaz> albeit: use "cabal update" to update your package database, and "caba install foo" will install the latest available version of the package "foo"
09:49:37 <albeit> DanielDiaz: Tried that... trying to install attoparsec-0.12.0.0, already have 0.11.3.4, and when I "install attoparsec" after "update" it says its already installed.
09:50:11 <bergmark> albeit: i'm guessing cabal notices that upgrading it would break packages so it keeps the old version
09:50:43 <napping> or maybe just that it has an installed version that matches the constraint as written
09:50:44 <DanielDiaz> albeit: it seems that you already have the last version then.
09:50:45 <bergmark> you can do `cabal install attoparsec-0.12.0.0 --force-reinstalls --dry-run' to see what would break
09:50:45 <jfischoff> albeit: you can recursively unregister and reinstall. Never forse
09:50:49 <jfischoff> force
09:50:56 <monochrom> there is no upgrade. there is only piling up more and more versions to confuse yourself. unregister the old version, then get the new version.
09:51:42 <jfischoff> albeit: I use this to unregister: https://github.com/glguy/GhcPkgUtils/blob/master/Unregister.hs
09:51:54 <monochrom> read my http://www.vex.net/~trebla/haskell/sicp.xhtml
09:52:03 <jfischoff> albeit: ^^^
09:52:33 <jfischoff> until Nix style management shows up, we will always have these problems
09:53:48 <albeit> jfischoff: So that file will recursively unregister any packages the would break from the initial unregister, ya?
09:54:38 <jfischoff> yes. When you try to unregister you will be told it will break x, y, z: that will unregister x, y, z in addition to then you actually want to unregister
09:54:46 <jfischoff> then cabal install foo x y z
09:54:50 <jfischoff> all at once
09:55:25 <jfischoff> try to cabal install as much as you can at once, it is more likely things will work together that way
09:55:56 <johnw> yes, the more information you give to cabal, the better the result
09:56:42 * hackagebot codex 0.0.2.1 - A ctags file generator for cabal project dependencies.  http://hackage.haskell.org/package/codex-0.0.2.1 (aloiscochard)
09:57:00 <rwbarton> sveit: if your DataType itself has a lot of fields then it will have to copy a pointer for each field
09:57:06 <rwbarton> sveit: the same would be true of DataType2 anyways
09:57:38 <rwbarton> sveit: if you have data DataType = TA X | TB X where X is a record with a lot of fields then your f only has to copy one pointer
09:59:07 <albeit> jfischoff: Beautiful, everything is reinstalling/upgrading/reregistering now, thanks
09:59:15 <jfischoff> \o/
09:59:46 <jfischoff> albeit: it never hurts to read monochrom’s blog FWIW
09:59:55 <albeit> Yep, just started! (again)
10:00:43 <joey_> Does somebody here understand SBV?
10:02:51 <rwbarton> joey_, I've used it before
10:04:08 <joey_> I was trying to figure out the difference between constraints and anding clauses into the expression I give sat but I think I figured it out
10:04:23 <joey_> As long as I am only using sat it seems there is no difference
10:06:45 * hackagebot pipes-attoparsec 0.5.1 - Attoparsec and Pipes integration.  http://hackage.haskell.org/package/pipes-attoparsec-0.5.1 (RenzoCarbonara)
10:11:45 * hackagebot pipes-aeson 0.4.1 - Encode and decode JSON streams using Aeson and Pipes.  http://hackage.haskell.org/package/pipes-aeson-0.4.1 (RenzoCarbonara)
10:13:37 <benzrf> is there a built-in typeclass for applying functions to lists or tuples
10:13:55 <joeyh> ocharles: nice job on the papers repo! (A few 404s however)
10:14:33 <bergmark> benzrf: what type would that function have?
10:14:41 <benzrf> typeclass, i said ;P
10:14:47 <benzrf> and i guess, for tuples?
10:14:59 <bergmark> what type would the functions in that type class have?
10:15:00 <benzrf> something like
10:15:28 <Fuuzetsu> are you looking for something like Traversable or Foldable or something?
10:15:36 <benzrf> @let class Apply f a r where apply :: f -> a -> r
10:15:38 <lambdabot>  Defined.
10:15:38 <benzrf> or something, idk
10:15:40 <benzrf> o_o
10:16:01 <benzrf> oh wait
10:16:08 <benzrf> r wouldnt work there i guess :I
10:16:08 <rwbarton> there is nothing "built-in" like that except (obviously) Functor
10:16:31 <benzrf> mehh
10:16:33 <napping> It should work pretty well with some fundeps and equality constraints and stuff
10:16:39 <johnw> there's a typeclass for f -> a -> a
10:16:40 <rwbarton> > (3,4) & each %~ (+1)
10:16:43 <lambdabot>  (4,5)
10:16:52 <rwbarton> > [3,4] & each %~ (+1)
10:16:53 <benzrf> heuh
10:16:54 <lambdabot>  [4,5]
10:16:59 <napping> instance (a~a', b~b') => Apply (a -> b -> c) (a',b') c
10:17:02 <benzrf> @undefine
10:17:03 <lambdabot> Undefined.
10:17:18 <benzrf> :\
10:17:43 <ocharles> joeyh: thanks! I have those papers, so we're thinking of using the Internet Archive to mirror them
10:19:07 <benzrf> @let class Apply f a r | f -> a r where apply :: f -> a -> r
10:19:08 <lambdabot>  Defined.
10:19:33 <benzrf> @let instance Apply (a -> b -> c) (a, b) c where apply = uncurry
10:19:34 <lambdabot>  Defined.
10:19:43 <benzrf> > apply (+) (1, 2)
10:19:45 <lambdabot>  3
10:20:01 <benzrf> @let instance Apply (a -> b -> c -> d) (a, b, c) d where apply = uncurry3
10:20:02 <lambdabot>  .L.hs:155:17:
10:20:02 <lambdabot>      Not in scope: ‘uncurry3’
10:20:02 <lambdabot>      Perhaps you meant ‘uncurry’ (imported from Data.Tuple)
10:20:04 <benzrf> pfft
10:20:15 <benzrf> @let instance Apply (a -> b -> c -> d) (a, b, c) d where apply f (a, b, c) = f a b c
10:20:16 <lambdabot>  .L.hs:151:10:
10:20:16 <lambdabot>      Functional dependencies conflict between instance declarations:
10:20:16 <lambdabot>        instance [safe] Apply (a -> b -> c) (a, b) c
10:20:16 <lambdabot>          -- Defined at .L.hs:151:10
10:20:16 <lambdabot>        instance [safe] Apply (a -> b -> c -> d) (a, b, c) d
10:20:21 <benzrf> eeeehhhh
10:20:24 <benzrf> of course -.-
10:21:22 <napping> How can you specify the main module in cabal?
10:21:46 * hackagebot parser-helper 0.1.0.0 - Prints Haskell parse trees in JSON.  http://hackage.haskell.org/package/parser-helper-0.1.0.0 (carymrobbins)
10:22:03 <benzrf> o wait hmm
10:22:06 <benzrf> @undefine
10:22:06 <lambdabot> Undefined.
10:22:19 <benzrf> @let class Apply f a r | a r -> f where apply :: f -> a -> r
10:22:21 <lambdabot>  Defined.
10:22:27 <benzrf> @let instance Apply (a -> b -> c) (a, b) c where apply = uncurry
10:22:27 <joeyh> ocharles: makes total sense to use the IA
10:22:28 <lambdabot>  Defined.
10:22:32 <benzrf> @let instance Apply (a -> b -> c -> d) (a, b, c) d where apply f (a, b, c) = f a b c
10:22:33 <lambdabot>  Defined.
10:22:36 <benzrf> O:
10:22:43 <benzrf> > apply (+) (1, 2)
10:22:45 <lambdabot>  3
10:22:56 <napping> main-is lets you pass a file, but it still expects the module to be Main
10:23:09 <benzrf> > apply foldl ((+), 0, [1, 2, 3])
10:23:11 <lambdabot>  6
10:23:15 <benzrf> sweet
10:23:24 <benzrf> does anything like ^ already exist p:
10:24:04 <benzrf> @let class ListToTuple t =
10:24:04 <lambdabot>  Parse failed: Parse error: =
10:24:05 <benzrf> oops
10:24:37 <benzrf> @let class ListToTuple a t | t -> a  where listToTuple :: [a] -> Maybe t
10:24:38 <lambdabot>  Defined.
10:25:27 <Fuuzetsu> benzrf: seems like lens could do what you want
10:25:29 <benzrf> @let instance ListToTuple a () where listToTuple [] = Just (); listToTuple _ = Nothing;
10:25:30 <lambdabot>  .L.hs:161:10:
10:25:30 <lambdabot>      Illegal instance declaration for ‘ListToTuple a ()’
10:25:30 <lambdabot>        The liberal coverage condition fails in class ‘ListToTuple’
10:25:30 <lambdabot>          for functional dependency: ‘t -> a’
10:25:30 <lambdabot>        Reason: lhs type ‘()’ does not determine rhs type ‘a’
10:25:32 <benzrf> hmm
10:25:53 <benzrf> @let instance ListToTuple a (a, a) where listToTuple [a, b] = Just (a, b); listToTuple _ = Nothing;
10:25:54 <lambdabot>  Defined.
10:26:04 <benzrf> @let instance ListToTuple a (a, a, a) where listToTuple [a, b, c] = Just (a, b, c); listToTuple _ = Nothing;
10:26:06 <lambdabot>  Defined.
10:26:31 <benzrf> @let applyList f l = listToTuple l >>= apply f
10:26:32 <lambdabot>  .L.hs:168:1:
10:26:32 <lambdabot>      Could not deduce (Apply f a0 (Maybe b))
10:26:32 <lambdabot>        arising from the ambiguity check for ‘applyList’
10:26:32 <lambdabot>      from the context (Apply f a (Maybe b), ListToTuple a1 a)
10:26:32 <lambdabot>        bound by the inferred type for ‘applyList’:
10:26:35 <benzrf> eeehhh
10:26:47 * hackagebot unbounded-delays-units 0.4 - Thread delays and timeouts using proper time units  http://hackage.haskell.org/package/unbounded-delays-units-0.4 (jcristovao)
10:26:49 * hackagebot command-qq 0.3.0.0 - Quasiquoters for external commands  http://hackage.haskell.org/package/command-qq-0.3.0.0 (MatveyAksenov)
10:27:18 <squimmy> does haskell have a builtin predicate for "does this value match this pattern"?
10:27:38 <benzrf> @let (Apply f t r, ListToTuple a t) => applyList :: f -> [a] -> r; applyList f l = listToTuple l >>= apply f
10:27:39 <lambdabot>  Parse failed: TemplateHaskell is not enabled
10:27:42 <benzrf> u wot
10:27:56 <benzrf> oh Maybe r
10:28:09 <squimmy> e.g. i have "data Foo = Bar Int | Baz Int" and i just want to check if a given Foo matches the "Bar _" pattern
10:28:16 <rwbarton> patterns aren't first-class things
10:28:20 <squimmy> ah
10:28:35 <squimmy> so i just write a function that uses a case/of and use that instead, i guess?
10:29:07 <benzrf> @let applyList :: (Apply f t r, ListToTuple a t) => f -> [a] -> Maybe r; applyList f l = listToTuple l >>= apply f
10:29:08 <lambdabot>  .L.hs:169:14:
10:29:08 <lambdabot>      Could not deduce (Apply f t0 r)
10:29:08 <lambdabot>        arising from the ambiguity check for ‘applyList’
10:29:08 <lambdabot>      from the context (Apply f t r, ListToTuple a t)
10:29:08 <lambdabot>        bound by the type signature for
10:31:52 <pavonia> squimmy: Yes, or you could use list comprehensions if you want to filter a list
10:32:52 <squimmy> pavonia: thanks :)
10:38:09 <nomeata> Hi. Any les experts here? Is there a combinator that changes "Foo -> a Foo" into "Bar -> a Bar", if a is Applicative, and Foo is a field of Bar (e.g. if Bar = [Foo], and I would  "ix 5 %=" to apply a function Foo -> Foo at the 5th position).
10:38:22 <nomeata> *lens experts
10:38:30 <cloudhead> with 'pipes', if I wanted to open a tcp socket from which I can read and write, would that required a bi-directional pipe?
10:38:35 <cloudhead> or am I misunderstanding?
10:38:39 <shachaf> nomeata: A lens itself will do that, I think.
10:39:10 <shachaf> Lens s t a b = forall f. Functor f => (a -> f b) -> s -> f t
10:39:18 <shachaf> Unless I'm misunderstanding the question.
10:39:38 <nomeata> shachaf: heh, you re right
10:39:47 <nomeata> I definitely do not grok lenses yet :-)
10:39:50 <jfischoff> If I make a finalizer for a MVar will I have access to the MVar in my finalizer, or will it already be garbage collected?
10:39:52 <rwbarton> :t traverseOf
10:39:53 <lambdabot> Over p f s t a b -> p a (f b) -> s -> f t
10:39:57 <albeit> Is there a cleaner way to do "foo = if bar==0 then baz else bar"?
10:40:39 <edwardk> traverseOf = id
10:41:13 <shachaf> traverseOf is the more explicit way to do it, yes. It's probably clearer.
10:42:05 <shachaf> But this is key to understanding lens lenses.
10:43:11 <pjdelport> albeit: That's probably not very improvable. Depending on context, guards may be better, perhaps.
10:48:56 <jfischoff> albeit: I that reads fine to me
10:49:12 <albeit> Okay
10:49:16 <benzrf> :t traverseOf
10:49:17 <lambdabot> Over p f s t a b -> p a (f b) -> s -> f t
10:49:28 <benzrf> Over vs Setting?
10:50:35 <johnw> foo | bar == 0 = baz; | otherwise = bar
10:50:41 <benzrf> nomeata: your request is exactly what a lens is !
10:50:43 <johnw> (not sure about ; there)
10:50:49 <benzrf> nomeata:
10:51:00 <benzrf> >
10:51:27 <benzrf> > _1 (subtract 1 . Identity) (3, 4)
10:51:28 <lambdabot>  No instance for (GHC.Show.Show t0)
10:51:29 <lambdabot>    arising from a use of ‘M170108427871984870220384.show_M1701084278719848702...
10:51:29 <lambdabot>  The type variable ‘t0’ is ambiguous
10:51:29 <lambdabot>  Note: there are several potential instances:
10:51:29 <lambdabot>    instance [safe] GHC.Show.Show
10:51:32 <benzrf> >.<
10:51:50 * hackagebot directory-layout 0.7.3.1 - Directory layout DSL  http://hackage.haskell.org/package/directory-layout-0.7.3.1 (MatveyAksenov)
10:51:52 <benzrf> oh wait
10:51:58 <benzrf> > _1 (Identity . subtract 1) (3, 4)
10:52:00 <lambdabot>  Identity {runIdentity = (2,4)}
10:52:10 <benzrf> > _1 (Const) (3, 4)
10:52:12 <lambdabot>  No instance for (GHC.Show.Show
10:52:12 <lambdabot>                     (Control.Applicative.Const t0 (b0, t1)))
10:52:12 <lambdabot>    arising from a use of ‘M143827705909160570720412.show_M1438277059091605707...
10:52:12 <lambdabot>  The type variable ‘t1’ is ambiguous
10:52:12 <lambdabot>  Note: there are several potential instances:
10:52:15 <benzrf> > getConst $ _1 (Const) (3, 4)
10:52:17 <lambdabot>  3
10:54:38 <jfischoff> how do I convert NomialDiffTime to microseconds?
10:55:52 <jfischoff> (*10^6) . realToFrac ?
10:56:28 <jfischoff> err with a truncate
10:57:02 <monochrom> that should do
10:57:30 <rwbarton> the Time Police would probably tell you "you can't"
10:57:47 <jfischoff> fuck the Time Police
10:57:54 <rwbarton> Amen
10:57:59 <jfischoff> no seriously why?
10:58:18 <rwbarton> because it depends on how many leap seconds occur in the particular range your NominalDiffTime is supposed to cover
10:58:21 <rwbarton> or something
10:58:34 <jfischoff> oh interesting
10:58:44 * jfischoff realizes he is easily amused
10:58:57 * StoneCypher sometimes thinks we should just keep a lookup table of the first second of a year
10:59:11 <StoneCypher> it's not like we're gonna have storage problems for that any time soon
10:59:15 <StoneCypher> and by the time we do, etc
10:59:34 <monochrom> there is a lookup table already.
10:59:59 <StoneCypher> well.  alright then.
11:13:10 <dmj`> what happened to Test.QuickCheck.Batch?
11:25:36 <jarlah> asks humbly for help .... let fibs = 1 : 1 : zipWith (+) fibs (tail fibs) ... is as I see a lazy infinite list ... the problem for me .. is this a recursive function? how can we visualize how the list is built up?
11:26:08 <shachaf> It isn't a function at all, just a list.
11:26:22 <shachaf> Well, a recursive list, I guess.
11:26:57 <shachaf> tikhonjelvis had some visualizations of it, I think.
11:27:09 <mdietz> Hi, I'm trying to use HLearn to train on a set, and then predict where new points will fall on a graph.  I see how to get the current distribution, but I don't see how I can get projected results for new values, and I missing something obvious?
11:27:13 <shachaf> http://jelv.is/blog/Lazy-Dynamic-Programming/
11:28:02 <jarlah> ill take a look
11:32:18 <mdietz> Is that what mean is supposed to do?  Or will that only fill in known points?
11:33:10 <piezoid> catMaybes could use a inline pragma, I don't like to see Maybes in core when i use them for control flow
11:33:24 <piezoid> I got a ~1.5x performance increase by replacing catMaybes with list comprehension
11:33:44 <c_wraith> wait, catMaybes *doesn't* have an inline pragma?
11:33:57 <dmj`> catMaybes is list comprehension though isn't it?
11:34:08 <dmj`> catMaybes [ x | Just x <- xs ]
11:34:12 <dmj`> @src catMaybes
11:34:13 <lambdabot> catMaybes ls = [x | Just x <- ls]
11:34:17 <c_wraith> dmj`: the difference is whether it's inlined so GHC can optimize across the boundary
11:34:27 <bennofs> dmj`: @src is not always what ghc uses. It's a hardcoded database
11:35:08 <dmj`> bennofs: in base-4.7 it is exactly that
11:35:24 <dmj`> not inlined tho...
11:35:31 <piezoid> c_wraith: i don't see it, mapMaybe neither, but it have some rules
11:36:13 <c_wraith> piezoid: submit request to the libraries list, or something.  That should definitely get done.
11:36:29 <jfischoff> I is there more general purpose version of monad-logger? Something simpler like, class MonadLogger l m where log :: l -> m ()?
11:36:59 <johnw> jfischoff: perhaps http://hackage.haskell.org/package/logging?
11:37:12 <johnw> but no, I don't know of a more general type like that
11:37:22 <johnw> my aim was to make MonadLogger more trivial to use for trivial cases
11:37:36 <jfischoff> that is helpful
11:37:40 <yesthisisuser> what is a better way of doing Data.ByteString.Char8.pack . show?
11:37:54 <jfischoff> I was going to have to write that so thanks for the doing work alread :)
11:37:54 <johnw> yesthisisuser: what is the input type?
11:37:59 <yesthisisuser> oh, Int
11:38:04 <c_wraith> johnw: hahaha.  haddock is eating your exampls
11:38:15 <piezoid> c_wraith: ok. (I've just tested mapMaybe, same issue)
11:38:16 <johnw> c_wraith: grr, will add to my todo to fix
11:38:17 <yesthisisuser> Int -> ByteString...
11:38:25 <dmj`> jfischoff: hslogger too
11:39:01 <jfischoff> dmj`: not sure if that is as easy to add to a transformer stack
11:39:19 <johnw> yesthisisuser: not that I know of
11:39:20 <c_wraith> piezoid: it may be possible to change them to use fusion, actually.  That'd be an even bigger potential win.
11:39:32 <johnw> I used to use hslogger, but I don't prefer it
11:40:13 <c_wraith> johnw: my only issue with logging frameworks is that it's really easy to make them a performance bottleneck.  That's why yesod's fastlogger is as complex as it is
11:40:27 <johnw> yes; well, I do use fast-logger
11:40:35 <johnw> there are also lots of multi-thread issues too
11:40:39 <piezoid> c_wraith: mapMaybe have build/foldr rules, but I don't know why they don't trigger in my case
11:40:40 <johnw> which fast-logger is good for
11:40:41 <yesthisisuser> johnw: so (pack . show) is not "frowned upon"..
11:40:48 <Philonous> shouldn't ghc be able to figure out inline for catMaybes on its own?
11:40:53 <johnw> yesthisisuser: not at all; proper decomposition is a good thing
11:41:02 <johnw> if you find yourself doing it a lot, you may want to define a helper function
11:42:09 <yesthisisuser> great. thanks
11:42:31 <c_wraith> piezoid: well, the build/foldr stuff doesn't do a thing unless the definition gets inlined, so...
11:43:38 <Philonous> johnw, I think the issue is that "show" isn't meant for data serialization. It works for ints, but it is conceptually brittle in a way. Also, String isn't a sequence of ascii-characters but of unicode-codepoints, so relying on [..].Char8.pack to do the right thing because our strings happen to be in the ascii set is again brittle .
11:43:54 <johnw> true, I should have asked why he wanted to do it :)
11:44:02 <johnw> yesthisisuser: is your intention not serialize integers?
11:44:06 <johnw> s/not/to
11:44:25 <c_wraith> piezoid: the RULES for eliminating foldr/build only can apply when foldr and build are next to each other, which requires inlining
11:45:11 <WraithM> Is there a generalization of zip? Something that's like: f a -> f b -> f (a,b) I can't really find anything on hoogle.
11:45:29 <johnw> yes, I remeber seeing that from edwardk
11:45:37 <Philonous> @type liftA2 (,)
11:45:38 <lambdabot> Applicative f => f a -> f b -> f (a, b)
11:45:44 <WraithM> There we go...
11:45:45 <WraithM> lol
11:45:55 <WraithM> Thank you!
11:45:56 <johnw> ah, not him
11:46:05 <johnw> here: http://hackage.haskell.org/package/chunked-data-0.1.0.1/docs/Data-ChunkedZip.html#v:zip
11:46:22 <johnw> but Applicative is nicer
11:46:39 <piezoid> c_wraith: ok, I don't know how to get this right. There is a NOINLINE [1] keep the mapMaybe definition arround before the rule trigger. So a simple inelineable should do the trick ?
11:47:03 <johnw> now I wonder why Zip exists
11:47:08 <Philonous> WraithM, Note, however, that it doesn't really generalize zip. That is, liftA2 (,) isn't zip for lists
11:47:08 <yesthisisuser> john: yes, i just felt that using show is an extra overhead
11:47:22 <johnw> yesthisisuser: for serialization, the binary or cereal packages are better
11:47:24 <Philonous> > liftA2 [1,2,3] ['a', 'b', 'c']
11:47:26 <lambdabot>  Couldn't match expected type ‘GHC.Types.Char -> b -> c’
11:47:26 <lambdabot>              with actual type ‘[t0]’
11:47:29 <Philonous> > liftA2 (,) [1,2,3] ['a', 'b', 'c']
11:47:31 <lambdabot>  can't find file: L.hs
11:47:31 <WraithM> Philonous: Right, though, it actually solves my problem.
11:47:36 <WraithM> in this case
11:47:40 <Philonous> OK
11:48:05 <WraithM> Thank you :)
11:48:12 <Philonous> yw
11:48:19 <c_wraith> piezoid: I don't know how to get it right, either.  It's complex, and depends on a lot of details I haven't learned.
11:49:29 <yesthisisuser> johnw: i had a look at cereal, but I didn't "grok" it, I'll try again
11:49:33 <edwardk> :t Control.Monad.Zip.mzip
11:49:34 <lambdabot> Control.Monad.Zip.MonadZip m => m a -> m b -> m (a, b)
11:50:34 <armlesshobo> > mzip (Just 1) (Just 2)
11:50:35 <lambdabot>  can't find file: L.hs
11:50:54 <johnw> I guess he created Zip so that there's only a Functor dependency, dunno
11:55:07 <johnw> edwardk: I tried your centipede trick on conduit
11:55:11 <johnw> the result was: https://github.com/jwiegley/notes/blob/master/Contuit.hs
11:56:03 <johnw> yesthisisuser: cereal is easy, though I admit it may seem odd at first
11:56:09 <edwardk> cute
11:56:53 <lennartj> do any of you know a trick for make lenses work with existential types? as in http://lpaste.net/105084
11:57:05 <lennartj> among other things, this code makes ghc's brain explode
11:57:09 <johnw> yesthisisuser: maybe this would help: http://random.axman6.com/blog/?p=124
11:57:23 <shergill> what's the centipede trick?
11:57:27 <lennartj> "src/Main.hs:19:24: My brain just exploded"
11:57:50 <johnw> shergill: pull 99 legs off and then see what it can do
11:58:01 <johnw> in this case, reduce conduit down to the simplest thing that isn't completely useless
11:58:38 <johnw> edwardk talks about it here: https://www.fpcomplete.com/user/edwardk/editorial/procrustean-mathematics
11:59:20 <Philonous> Well, even compared to the usual bellicisms this metaphor is astonishingly grizzly.
12:00:20 <shergill> johnw: gotcha; investigative science
12:00:41 <Philonous> grisly, even
12:01:38 <johnw> "that metaphor was positively kodiak!"
12:02:14 <Philonous> johnw, Turns out, at least according to Websters, "grizzly" is a valid alternative spelling of "grisly"
12:03:47 <edwardk> Philonous: if one is going to compare most applied math / computer science to pulling legs off a centipede, i figured an equally grisly turn of phrase was warranted in rejoinder
12:04:29 <Hodapp> are we talking house centipedes, or not?
12:05:03 <Hodapp> because those jerks can keep all their legs
12:05:10 <Hodapp> as long a they're using them to get away from me
12:07:40 <Philonous> edwardk, It was in no way meant to be a criticism.
12:07:42 <bergmark> s/rejoinder/reindeer?
12:08:05 <edwardk> heh Philonous wasn't taken as such, just motivating the analogy =)
12:10:41 <hexagoxel> does anyone know of a library for very basic "pretty"-printing of a tree structure with indentation (WriterT output::[String] + StateT identation::Int or something)?
12:11:59 * hackagebot music-suite 1.7.0 - A set of libraries for composition, analysis and manipulation of music.  http://hackage.haskell.org/package/music-suite-1.7.0 (HansHoglund)
12:12:14 <Fuuzetsu> hexagoxel: does pretty-tree not do what you want?
12:12:26 <bergmark> hexagoxel: check out pretty-show and groom
12:12:30 <Fuuzetsu> http://hackage.haskell.org/package/pretty-tree-0.1.0.0/docs/Data-Tree-Pretty.html
12:17:34 <hexagoxel> Fuuzetsu, bergmark: thanks
12:18:07 <dmj`> When is it ok for the magic hash to come before the name of a symbol?
12:18:27 <dmj`> http://lpaste.net/105086 <-- get a parse error at : (# s, ... )
12:18:31 <hexagoxel> (too bad those packages are not listed under "pretty printing" on hackage.. the term "pretty" alone is way too common on the full list)
12:19:03 <rwbarton> dmj`, that is UnboxedTuples
12:19:28 <dmj`> rwbarton: thank you!
12:19:46 <monochrom> (# is one single token, not attached to s
12:20:37 <merijn> dmj`: Also with MagicHash # is only valid at the end of an identifier, nowhere else
12:20:51 <jarlah> silly_list = 1 : 2 : 3 : zipWith (+) silly_list (tail silly_list) .... <- proves the fact that that such functions can remember any arbitrary number of elements... in this case [1,2,3] is zipped with [2,3] yielding [1,2,3,3,5]
12:21:02 <merijn> so '#s' -> two tokens '#' and 's'
12:21:41 <dmj`> monochrom, merijn: ok so the hash before the s means the entire tuple is unboxed, lives on stack not on heap
12:21:47 <merijn> jarlah: Eh, that definition keeps going infinitely
12:21:55 <jarlah> yup ..
12:21:58 <monochrom> I don't know about living on stack
12:22:24 <merijn> dmj`: "living on the stack" is not a term that makes sense in haskell
12:22:30 <BeardedCoder> So, I'm using cabal freeze and it's freezing dependencies such as Network and HTTP. If I setup a new build box now, installing "cabal install" installs different versions of these than I have one my other boxes. What is the correct way to manage this type of issue.?
12:22:32 <merijn> dmj`: And that's not what unboxed means
12:22:53 <merijn> dmj`: unboxed means "no pointer indirection"
12:23:01 <jarlah> merijn: using it as an example on how the fibbonaccia infinte sequence can possible work ... where http://jelv.is/blog/Lazy-Dynamic-Programming/index.html .. gave me important cues
12:23:04 <deweyvm> why would piping the output of a program to another program stop the program from outputting anything? like this http://pastebin.com/YPqvjiJz
12:23:29 <monochrom> buffering. line-buffered when tty, block-buffered when not
12:23:42 <deweyvm> im flushing stdout after every print
12:23:46 <Fuuzetsu> cat is probably waiting for end of line
12:24:18 <monochrom> I can't reproduce the problem. what should I do to reproduce the problem?
12:25:27 <dmj`> merijn: where do unboxed values reside in memory?
12:26:03 <merijn> dmj`: "it depends"
12:26:14 <thetallguy> where do sum and product types like :+: and :*: live now?
12:26:15 <merijn> The same place as most other things, usually
12:26:47 <maxmc_> Hi, I'm trying to install leksah via cabal on ubuntu 14. The installation fails with 'Failed to install glib-0.12.5.4' any ideas on how to resolve the issue?
12:26:53 <merijn> dmj`: You could call it the "heap", but everything in haskell lives on the heap
12:27:16 <deweyvm> okay now cat will echo it but my other program wont hmmm
12:27:43 <dmj`> merijn: "Unboxed tuples are used for functions that need to return multiple values, but they avoid the heap allocation normally associated with using fully-fledged tuples. When an unboxed tuple is returned, the components are put directly into registers or on the stack; the unboxed tuple itself does not have a composite representation."
12:27:47 <rwbarton> in this case since it is an unboxed tuple being returned from a function, it will be stored in registers according to the calling convention on the particular platform
12:27:54 <rwbarton> or on the stack if there are lot of them yes
12:27:59 <monochrom> maxmc_: do you have libgtk2.0-dev and libglade2-dev?
12:28:28 <rwbarton> iirc here "the stack" is the C stack
12:28:50 <merijn> rwbarton: No, the update frame stack of STG, I think
12:30:02 <maxmc_> monochrom: just installed both, but the leksah installation still fails with the same error
12:30:16 <monochrom> then I don't know
12:30:21 <rwbarton> anyways in this case the 's' has no representation, and so the other component of the tuple will go into the usual return register, I think
12:31:59 <vamega> Hi.
12:32:22 <vamega> Does anyone know what the main difference between regex-pcre and regex-pcre-light is?
12:33:48 <napping> was there a trick for commenting out one of two pieces of code?
12:33:50 <vamega> I can see they both wrap the pcre library.
12:34:02 <vamega> And that pcre-light has been updated more recently.
12:34:04 <bennofs> napping: you mean {- and -} ?
12:34:07 <albeit> What's the best way to parse only a few digits of a number in attoparsec? Example: func 4 "98765" == 9876
12:34:09 <geekosaur> vamega, regex-pcre implements the full regex interface, which is rather hairy and sometimes hard to use
12:34:15 <vamega> But I'm unsure how they're functionally difference.
12:34:22 <bennofs> > {- this is a comment -} undefined
12:34:24 <lambdabot>  *Exception: Prelude.undefined
12:34:43 <vamega> geekosaur - if the full regex interface is hairy and hard to use, what's the recommended approach to using regular expressions?
12:35:09 <geekosaur> that is, there is a standard Text.Regex interface which works for a bunch of different libraries, and provides full functionality by means of complex typeclasses
12:35:25 <geekosaur> pcre-light provides a simple interface only to the pcre library
12:35:33 <joelteon> vamega: see http://hackage.haskell.org/package/regex-base-0.93.2/docs/Text-Regex-Base-RegexLike.html#t:RegexLike
12:35:57 <napping> bennofs: no, like the C /* A /*/ B /**/ vs. A /*/ B /**/ thing
12:35:58 <geekosaur> once you see what those typeclasses look like, you may never want to look at it again >.>
12:38:02 <pavonia> napping: What does that do?
12:38:37 <davnils> implementing regexp -> epsilon-NFA conversion is quite straightforward and simulation is easy if you only need to test language membership
12:38:52 <dottedmag> pavonia: one-symbol change causes it to flip two braches of code to be commented/uncommented.
12:39:07 <napping> pavonia: because C comments don't nest, /*/ is an end comment (after a /) inside a comment, and an open comment (followed by a /) if you are not
12:39:22 <Philonous> vamega, Most people prefer parser combinators over regular expressions. They are much more readable/manageable/maintainable, compose properly and allow you to process the matched data
12:39:57 <johnw> geekosaur: there are a bunch of regex-* implementations
12:40:01 <johnw> http://hackage.haskell.org/packages/search?terms=regex
12:40:15 <albeit> :t fst . fromJust <$> readInt <$> take
12:40:16 <lambdabot>     Couldn't match type ‘Maybe (b, b0)’
12:40:16 <lambdabot>                   with ‘(Char -> Bool) -> (Char -> Int) -> ReadS ([a0] -> [a0])’
12:40:16 <lambdabot>     Expected type: ([a0] -> [a0]) -> Maybe (b, b0)
12:40:22 <johnw> Philonous: not to mention more type safety!
12:40:24 <vamega> Philonous, yes I'm aware. I heard that before and just finished writing a few programmes using attoparsec to understand it.
12:40:40 <rwbarton> napping: I guess you can use {- \n ... \n -- -}, and then add -- before the first line, to toggle one block at least
12:40:58 <vamega> However, if I want to perform matching based on user input.
12:41:04 <johnw> albeit: a <$> (b <$> c) is the same as a . b <$> c
12:41:10 <vamega> A regex engine is far simpler to ship around than a haskell compiler.
12:41:33 <Philonous> vamega, That's fine, of course.
12:41:35 <sveit> is there a typeclass in haskell that represents "application"? i.e. if i have an object o, i can define a function apply :: o -> a -> b
12:41:37 <vamega> Specifically I'm thinking about having a config file that might have a regex that is used to match against some data.
12:41:57 <albeit> @pl (\n -> fmap f (g n))
12:41:57 <lambdabot> fmap f . g
12:42:05 <napping> vamega: That's probably a good case for regular expressions, but that doesn't need a Haskell compiler
12:42:12 <vamega> So I'm just trying to figure out if there is any consensus on the "best" regex library.
12:42:27 <napping> parser combinators are just values, you can have code assemble them at runtime if you want
12:42:38 <maxmc_> monochrom: thanks anyways, maybe I'll use the eclipse plugin instead of fiddling with dependencies...
12:42:59 <napping> Of course, regular expressions are familiar syntax and that's probably enough to go with them for user-visible things
12:43:26 <vamega> napping - right but I imagine that involves writing a parser for whatever the file specifies as a match.
12:43:28 <napping> rwbarton: yeah, I noticed that. Maybe I was imagining
12:43:43 <vamega> And then assembling a parser combinator for that.
12:43:44 <maxmc_> monochrom: just want to try haskell, have heard great things about it :)
12:44:05 <vamega> Which is what I think regex-parsec does.
12:44:10 <napping> vamega: yeah, you'd need to get your specification from somewhere and then assemble a parser
12:44:20 <napping> regex-parser does sound like something that would do that
12:44:26 <napping> regex-parsec, I mean
12:44:43 <napping> (unless it's for efficiently parsing regexes as a subparse of a Parsec parser)
12:44:55 <albeit> @pl (\n -> fmap (f . g) (h n))
12:44:56 <lambdabot> fmap (f . g) . h
12:45:03 <napping> If you want to offer regular expressions, it should be more efficient to use a regex engine
12:45:16 <napping> especially if you worry about the cases that go exponential under backtracking
12:45:34 <napping> rwbarton: --}\n always ends a comment
12:46:03 <vamega> Yeah, I just saw the r/haskell post on RE2 bindings.
12:46:09 <napping> {- is the only way to start a multiline comment, and it's interpreted inside multiline comments
12:46:16 <vamega> Which is pretty great.
12:46:17 <napping> so I don't think toggling works right
12:46:23 <rwbarton> #if 0
12:46:34 <vamega> Not sure I need full PCRE.
12:46:37 <rwbarton> the ultimate solution
12:46:46 <vamega> And if that works it'd be great.
12:47:58 <napping> vamega: if you want to go without a C library, the tdfa packages define similar asymptotics
12:50:03 <napping> I think Russ Cox and Chris Kuklewicz exchanged some ideas while working on those libraries
12:51:47 <mightybyte> What's the story with the Writer monad?  I've heard people say it has performance problems.
12:53:05 <bergmark> hmm can't find the link to that, somewhere on stackoverflow iirc
12:54:18 <davnils> @tell sx drawn any conclusions regarding your accelerate problems? I'm really interested in real-world implementations.
12:54:19 <lambdabot> Consider it noted.
12:55:03 <rwbarton> mightybyte: there's no way to avoid mappend build-up in the 'w'
12:55:46 <mightybyte> rwbarton: Ahh, it can't be forced?
12:55:52 <davnils> napping: do you know if DFA minimization followed by simulation is used in practice?
12:56:01 <rwbarton> there's no way to refer to it at all from within the computation
12:56:16 <mightybyte> What about the strict version?
12:56:28 <napping> davnils: that's about how those libraries work
12:56:37 <rwbarton> the strict version is not enough stricter
12:56:42 <mightybyte> Ahh
12:56:52 <rwbarton> what I never really understood is why you couldn't write one that is enough stricter
12:57:02 <davnils> napping: ah, I see. thanks!
12:57:03 <mightybyte> Is not possible?
12:57:13 <mightybyte> Could you do it on top of the State monad?
12:57:17 <napping> well, not sure about the minimization - I think there are some tricks with generating a reasonably small NFA/DFA from the start, or incrementally determinizing an NFA or something
12:57:22 <rwbarton> mightybyte: yes
12:57:44 <napping> I may be confusing that with tricks I've heard of for LTL model checking
12:58:06 <DR6> since when is this legal syntax?
12:58:07 <DR6> shallowAlpha :: Data s => Eq s => s -> s -> LC s -> LC s
12:58:18 <DR6> I didn't know you could put constraints like that
12:58:22 <napping> but re2 and the tdfa family of Haskell regex libraries are certainly based on automata, and gracefully handle cases where backtracking takes exponential time
12:58:36 <rwbarton> mightybyte: I have the impression of having read somewhere that it is not possible to make a Writer that's strict in the way you want without basically reimplementing State
12:58:42 <Eduard_Munteanu> DR6: you can, it's basically forall s. Data s => (Eq s => ...)
12:58:51 <mightybyte> rwbarton: Ahh, interesting.
12:58:53 <DR6> has that been there forever?
12:58:54 <johnw> rwbarton: didn't Tekmo write one that was stricter?
12:58:59 <DR6> I understand what it means
12:58:59 <Eduard_Munteanu> DR6: yeah
12:59:06 <davnils> napping: yeah, I guess time for compilation might be a concern. there is at least a quadratic algorithm though. perhaps the converted (eps-NFA -> DFA?) are far from the worst case of exponential growth.
12:59:07 <jarlah> i have now understood that zipWith recurses on the tail of the produced list... but where can i see proof of that? I mean, if I COULD look at the source code of zipWith I should be able to see the recursiveness ... because ...  yada = take 100 ([1,2,3] ++ (zipWith (+) yada (tail yada))) ... is also infinte .. in a more readable manner
12:59:14 <DR6> wow, I always thought tuples were the only way
12:59:18 <DR6> I guess it makes sense
12:59:20 <Eduard_Munteanu> @src zipWith
12:59:20 <lambdabot> zipWith f (a:as) (b:bs) = f a b : zipWith f as bs
12:59:21 <lambdabot> zipWith _ _      _      = []
12:59:21 <napping> DR6: oh, that's a bit wierd. perhaps it's just a side effect of allowing things like (forall x . Show x => x -> x -> String) -> [Int] -> String
12:59:23 <rwbarton> johnw: that is part of the impression too but I think it is implemented on top of State
12:59:25 <Eduard_Munteanu> jarlah: ^
13:00:33 <jarlah> Eduard_Munteanu: omg ty
13:01:07 <napping> davnils: there are n log n algorithms - and also just running the NFA directly is still linear in the side of the string
13:02:23 <davnils> napping: oh! time to read up :)
13:02:39 <davnils> the simulation part makes sense.
13:02:40 <napping> that might be an average case bound, I guess
13:02:59 <davnils> I've just taken an intro course in automata theory.
13:03:44 <TallerGhostWalt> ls
13:04:01 <TallerGhostWalt> man, eshell habbits die hard
13:04:29 <napping> davnils: this looks interesting: www.cs.tut.fi/~trak/lecture8.pdf
13:04:45 <TallerGhostWalt> where do I go to report a bug with System.IO?
13:05:12 <napping> what's the bug?
13:06:19 <TallerGhostWalt> when I try and open more than 1024 files, then write to them, then close them using openFile... I get an error
13:06:33 <davnils> TallerGhostWalt: ulimit setting
13:06:39 <TallerGhostWalt> 10k
13:06:42 <merijn> TallerGhostWalt: Doesn't sound like a bug
13:06:44 <TallerGhostWalt> both root and normal user
13:06:55 <merijn> TallerGhostWalt: Sounds like kernel file descriptor limit
13:07:06 <TallerGhostWalt> is that diff than the ulimit?
13:07:34 <geekosaur> depending on platform and ghc version, 1024 could be the old select limit
13:07:34 <davnils> napping: thanks btw.
13:07:47 <rwbarton> Try closing them using hClose instead?
13:07:47 <johnw> TallerGhostWalt: it works with 1023 files?
13:08:02 <TallerGhostWalt> yeah
13:08:05 <TallerGhostWalt> using hClose now
13:08:28 <rwbarton> what is the error?
13:08:40 <TallerGhostWalt> one sec
13:08:44 <TallerGhostWalt> i'll get it all set
13:11:29 <TallerGhostWalt> acidStress: <file descriptor: 1035>: hClose: invalid argument (Bad file descriptor)
13:12:31 <TallerGhostWalt> https://github.com/smurphy8/broken-acid-test/blob/master/src/Broken.hs
13:12:44 <TallerGhostWalt> running 'openAndCloseABunchOfFiles'
13:14:01 <TallerGhostWalt> that last time I ran it , it stopped at <file descriptor: 1035>:
13:14:14 <TallerGhostWalt> I am open to the idea of it being on my system, but my ulimit is set to 10k
13:14:44 <napping> Maybe you should ask on the library list
13:15:01 <Cale> I really doubt that's a Haskell-specific problem.
13:15:06 <napping> Even if you hit a limit, I wouldn't expect open to return a handle around a bad file descriptor
13:15:40 <TallerGhostWalt> napping: gp
13:15:54 <Cale> Oh, that's a reasonable point, if you only have an error *closing* the handle.
13:16:03 <TallerGhostWalt> yeah
13:16:08 <TallerGhostWalt> I can open a whole mess of em
13:16:37 <napping> also, I don't see errors from calling hClose a bunch of times on one handle, so I think it should remember it's closed
13:17:00 <napping> are you using a recent GHC?
13:17:26 <rwbarton> it would be helpful if you could reproduce it without acid-state
13:18:23 <TallerGhostWalt> 7.8.2
13:18:27 <TallerGhostWalt> I did
13:18:38 <rwbarton> oh?
13:18:43 <TallerGhostWalt> rwbarton: if you look at the git i posted, I am running it w/o acid state
13:18:58 <rwbarton> I see a bunch of Data.Acid imports
13:19:08 <napping> a more minimal example would be nice
13:19:11 <TallerGhostWalt> yeah, unused
13:19:14 <TallerGhostWalt> k
13:19:16 <TallerGhostWalt> one sec
13:19:51 <napping> I'm not sure whether there's anything fishy in your code
13:19:57 <napping> heck, you're importing fdToHandle
13:20:09 <napping> you could arbitrarily screw yourself up if you use that carelessly
13:20:47 <davnils> 7.8.2 has non-fd bugs, might be a good idea to test on 7.6.3 (latest hplatform)
13:20:50 <napping> just that the error message isn't consistent with simply hitting your ulimit
13:21:04 <napping> but there were some IO manager bugs (though I think they only happened under heavy concurrency)
13:22:20 <jfischoff> which is faster StateT or an IORef?
13:22:43 <napping> depends what you are doing
13:22:57 <jfischoff> how so?
13:23:13 <napping> StateT pretty much becomes an extra argument and result
13:23:15 <Eduard_Munteanu> jfischoff: a transformer may be slower in itself
13:23:20 <rwbarton> well if you never access the IORef, then the IORef is faster :)
13:23:26 <jfischoff> :)
13:23:33 <TallerGhostWalt> hmm... okay so it goes away
13:23:33 <napping> I'm not sure whether that's faster or slower than hitting a reference
13:23:42 <TallerGhostWalt> what on earth am I doing wrong them
13:23:43 <TallerGhostWalt> then
13:23:50 <napping> TallerGhostWalt: sounds like the right place to report may be with acid-state then
13:23:56 <jfischoff> That what I was thinking actual, if you are constantly modifying the state IORef would probably be slower
13:24:25 <napping> jfischoff: on the other hand, LLVM at least *might* be able to promote a reference back up to a local variable?
13:24:28 <TallerGhostWalt> maybe, I am not sure still, cause I am not actually using any of that acid-state stuff
13:24:42 <napping> TallerGhostWalt: did you try just deleting the imports and then it went away?
13:24:44 <JokerDoomWork> Is haskell any good for linear algebra?
13:24:48 <TallerGhostWalt> no
13:24:48 <napping> or keeping the imports and removing the TH stuff
13:24:53 <TallerGhostWalt> made a new file
13:25:03 <TallerGhostWalt> just doing open, write and close
13:25:11 <TallerGhostWalt> gonna do that next
13:25:15 <napping> Well, something is wrong somewhere
13:25:25 <TallerGhostWalt> napping: agreed
13:25:38 <napping> actually, try just dropping the TH calls and leaving the imports
13:26:01 <davnils> JokerDoomWork: sure, there are plenty of libs. need perf? roll with hblas bindings
13:26:02 <napping> well, probably worth asking whatever list is appropriate for acid-state
13:26:33 <TallerGhostWalt> napping: yeah, I did ... they said ulimit (or at least 1 person did)
13:26:48 <napping> JokerDoomWork: think NumPy, maybe
13:27:11 <napping> On IRC?
13:27:12 <Arnob> Hi all
13:27:21 <Arnob> I have a many to many problem that I am stuck with
13:27:34 <napping> That bad fd message doesn't seem like ulimit
13:27:43 <napping> hmm, have you tried turning your ulimit way down and seeing what happens?
13:27:46 <napping> if it's 200 or so?
13:28:00 <JokerDoomWork> davnils, no I mean: if I wanted to implement a very fast LinAlgebra lib myself using only haskell, would I be able to compete with other langs' implementations?
13:28:22 <TallerGhostWalt> no
13:28:24 <Arnob> I have a list of categories, that I am trying to "migrate" over to a new list
13:28:26 <davnils> lol
13:28:51 <Arnob> i.e. the old categories need to be moved over to new categories
13:28:55 <Arnob> here is an example
13:29:00 <Arnob> http://lpaste.net/105087
13:29:12 <napping> JokerDoomWork: as far as I know, every competitively fast linear algebra library eventually hits hand tuned assembly, or at least thin intrisics over vector instructions
13:29:20 <davnils> JokerDoomWork: I guess it depends on what you're aiming for. i.e. strengths of abstraction and concurrency vs low-level optimizations
13:29:41 <rwbarton> here is where carter pipes up about SIMD shuffles
13:29:54 <Arnob> but some of the old categories map to multiple new categories, and some of the new categories map to multiple old categories
13:29:59 <napping> But then, I doubt many people can compete with Goto, whatever language they use
13:30:07 <davnils> next year is the year of haskell, obviously
13:30:15 <JokerDoomWork> napping, that tends to be correct, but I mean - holding other languages to the same standard, that a C# lin alg library must only be C# how close could I get haskell to being about the same perf
13:30:17 <Arnob> I am not dure how to create a many-to-many "function" that can handle this
13:30:52 <monochrom> jfischoff: once upon a time, someone wrote random-using code, it used randomIO many times, which boiled down to readIORef-writeIORef many times. I changed that to one call to newStdGen and randoms, it got a lot faster.
13:30:53 <napping> JokerDoomWork: oh, then I think it's fairly reasonable - repa and accellerate are probably the things to check out
13:30:58 <napping> or BLAS bindings for that matter
13:31:16 <pavonia> Arnob: mapCat :: [Category] -> [Category] would do such a mapping
13:31:17 <augur> does OverloadedXs let you unify functions?
13:31:35 <napping> then again, I doubt you really want to try to write your own BLAS implementations, so binding to good linear algebra libraries is probably plently
13:31:50 <rwbarton> hmm, acid-state doesn't build for me
13:31:51 <jfischoff> monochrom: I vaguely remember something on the Haskell-Cafe to a similar effect
13:32:09 <JokerDoomWork> Oh ty napping, these are pure haskell through and through?
13:32:10 * hackagebot hapistrano 0.1.0.1 - A deployment library for Haskell applications  http://hackage.haskell.org/package/hapistrano-0.1.0.1 (jsl)
13:32:17 <Arnob> what is the logic of mapcat
13:32:40 <Philonous> Arnob, Your transformed list still contains "Mining Oil and Gas", I guess that's supposed to be "Support Activities for Oil and Gas Operations" ?
13:32:49 <napping> TallerGhostWalt: if you see a different symptom with a hard ulimit of 500 or, that would be something to go back to the acid people with
13:32:54 <albeit> If I'm deriving an instance  with generics, why do I have to write "instance Foo FromJSON where" instead of "instance Foo FromJSON"?
13:32:55 <carter> rwbarton: was AFK
13:33:10 <carter> napping: JokerDoomWork  i've plans for SIMD, but C FFI aint so bad
13:33:14 <carter> for SIMD
13:33:15 <Arnob> updated
13:33:25 <Arnob> [Construction of Buildings, Drilling Oil and Gas Wells, Support Activities for Oil and Gas Operations]
13:33:28 <carter> napping: i'm doing boht :)
13:33:29 <davnils> JokerDoomWork: most DSLs use side effects to observe sharing, but there is like a pure-by-proof interface outwards (i.e. no side effects based on reasoning)
13:33:32 <carter> *both
13:33:38 <JokerDoomWork> davnils, I'm interested in this to teach myself Haskell more, I've written a decent C# lib for linear alg that I used to teach myself lin algebra wi
13:33:38 <JokerDoomWork> th
13:33:38 <JokerDoomWork>  
13:33:44 <TallerGhostWalt> napping: yeah, I am experimenting now... Thanks!
13:33:51 <carter> JokerDoomWork: come hang on #numerical-haskell
13:34:07 <Philonous> Arnob, Simple solution is this: Define a Function (f :: OldCategory -> [NewCategory]) and use concatMap to map it over the list of old categories
13:34:13 <napping> JokerDoomWork: if it's that sort of thing, then it should be decently fast - I think I can promise no worse than 10x under e.g. unoptimized C
13:34:14 <carter> JokerDoomWork: i'm actually aiming to get within 2x of BLAS / LAPACK in a few months
13:34:26 <carter> napping: unoptimized C has terrrible memory locality
13:34:28 <carter> terribleeeee
13:34:31 <napping> sure
13:34:32 <Arnob> what is concatMap
13:34:40 <Arnob> map concat?
13:34:42 <napping> but I think it's a decent benchmark for a hobby project kind of thing
13:34:45 <davnils> Arnob: concat . map f
13:34:46 <carter> sure
13:34:51 <carter> i hit that perf a year ago
13:34:52 <carter> :)
13:34:52 <Philonous> > let {f 1 = [2,3]; f 2 = [1, 4]; f x = [x]} in concatMap f [1, 2 , 4] -- Arnob
13:34:53 <Arnob> ah
13:34:54 <lambdabot>  [2,3,1,4,4]
13:35:09 <napping> like, if you ever considered a dynamic language for a second...
13:35:21 <JokerDoomWork> carter, ty!
13:35:38 <Philonous> @src concatMap
13:35:39 <lambdabot> concatMap f = foldr ((++) . f) []
13:36:33 <rwbarton> how ugly
13:36:40 <squimmy> given the choice, should i be using par or forkIO?
13:37:07 <napping> squimmy: checked threadscope?
13:37:11 * hackagebot maclight 0.1.0.0 - Control screen and keyboard backlights on MACs under Linux  http://hackage.haskell.org/package/maclight-0.1.0.0 (TychoAndersen)
13:37:24 <napping> squimmy: have you seen Simon Marlow's book?
13:37:30 <squimmy> no
13:37:39 <squimmy> nor have i looked at threadscope
13:37:46 <davnils> it's very readable, you should check it out
13:37:52 <rwbarton> given the choice, read that book yes
13:38:29 <squimmy> also: threadscope looks pretty good. i think i'll have a play aroudn with that, too.
13:38:33 <squimmy> thanks! :)
13:38:51 <napping> raw par is tricky, strategies might be okay
13:39:59 <sveit> is there a way to encode numbers in the type signature?
13:40:06 <sveit> or other values?
13:40:51 <rwbarton> TallerGhostWalt: wait your broken-acid-state-test.cabal depends on acid-state >= 0.12.2.1, but there is no such version on Hackage
13:41:06 <rwbarton> TallerGhostWalt: is this something you patched yourself to work around the fact that 0.12.2 doesn't build?
13:41:10 <rwbarton> or what
13:42:01 <davnils> sveit: https://hackage.haskell.org/package/singletons
13:44:22 <davnils> sveit: http://www.haskell.org/haskellwiki/Type_arithmetic
13:44:50 <TallerGhostWalt> napping: open :: FilePath -> IO FHandle
13:44:51 <TallerGhostWalt> open filename = fmap FHandle $ openFd filename WriteOnly (Just stdFileMode) defaultFileFlags
13:45:01 <TallerGhostWalt> does that look suspicious?
13:45:25 <TallerGhostWalt> when I use openFile from System.IO the error goes away
13:45:28 <nomeata> Another lens question: I want to apply the same function f at lenses ix 1, ix 2, ix 5 and ix 7. How would I combine them?
13:45:29 <TallerGhostWalt> but using that, it comes back
13:45:31 <merijn> TallerGhostWalt: Well, while are you using openFd?
13:45:36 <merijn> s/while/why
13:46:07 <edwardk> nomeata: what happens when you accidentally pass it 1 and 1?
13:46:10 <TallerGhostWalt> i'm not, it is in acid-state
13:46:25 <nomeata> edwardk: hmm, good question
13:46:33 <TallerGhostWalt> merijn: I am just trying to get to the bottom of what is causing this problem when I open it
13:46:33 <edwardk> nomeata: there are a few solutions here
13:46:50 <edwardk> nomeata: 'indices' can be used to traverse and filter by a predicate on the indices
13:47:28 <edwardk> > M.fromList [(1,1),(2,2),(3,3)] & traversed.indices odd +~ 1
13:47:29 <lambdabot>  Couldn't match expected type ‘(a1
13:47:30 <lambdabot>                                 -> Data.Functor.Identity.Identity a1)
13:47:30 <lambdabot>                                -> p0 a0 (Data.Functor.Identity.Identity b)’
13:47:30 <lambdabot>              with actual type ‘[i0]’Couldn't match expected type ‘GHC.Arr.Arr...
13:47:30 <lambdabot>              with actual type ‘a2 -> GHC.Types.Bool’
13:47:50 <edwardk> > M.fromList [(1,1),(2,2),(3,3)] & traversed. Lens.indices odd +~ 1
13:47:52 <lambdabot>  fromList [(1,1),(2,3),(3,3)]
13:48:06 <edwardk> > M.fromList [(1,1),(2,2),(3,3)] & itraversed. Lens.indices odd +~ 1
13:48:08 <lambdabot>  fromList [(1,2),(2,2),(3,4)]
13:48:11 <nomeata> edwardk: and I guess I need to think about how to combine the applicative effects from f (which is of type Bar -> Active Bar)
13:48:47 <TallerGhostWalt> rwbarton: Yeah i made that verion
13:48:56 <TallerGhostWalt> rwbarton: just experimenting
13:48:57 <rwbarton> ok
13:49:16 <nomeata> > M.fromList [(1,1),(2,2),(3,3)] & itraversed. Lens.indices odd +~ (\n -> [n,n+1])
13:49:18 <lambdabot>  No instance for (Data.Typeable.Internal.Typeable t0)
13:49:18 <lambdabot>    arising from a use of ‘M496695233486525621722531.show_M4966952334865256217...
13:49:18 <lambdabot>  The type variable ‘t0’ is ambiguous
13:49:18 <lambdabot>  Note: there are several potential instances:
13:49:18 <lambdabot>    instance Data.Typeable.Internal.Typeable Data.Dynamic.Dynamic
13:50:09 <edwardk> > M.fromList [(1,1),(2,2),(3,3)] & itraversed. Lens.indices odd %~ \n -> [n,n+1]
13:50:11 <lambdabot>  Occurs check: cannot construct the infinite type: b ~ [b]
13:50:11 <lambdabot>  Expected type: b -> [b]
13:50:11 <lambdabot>    Actual type: b -> b
13:50:16 <edwardk> > M.fromList [(1,1),(2,2),(3,3)] & itraversed. Lens.indices odd %%~ \n -> [n,n+1]
13:50:17 <sveit> i guess i am having trouble translating math -> haskell. if i have an operator o from space a -> space b, should i encode this as (o a b) or include it in the definition of o?
13:50:18 <lambdabot>  [fromList [(1,1),(2,2),(3,3)],fromList [(1,1),(2,2),(3,4)],fromList [(1,2),(...
13:50:31 <edwardk> %%~ is just 'id' again
13:52:09 <benzrf> M?
13:52:25 <nomeata> edwardk: perfect!
13:53:16 <nomeata> edwardk: The simultaneous fadeing-out at the end is your itraversed: http://www.joachim-breitner.de/various/test.webm
13:53:56 <edwardk> nomeata: nice
13:54:02 <solrize> free monads being the new hotness, does anyone know if Atom (the realtime EDSL) could be formulated that way?
13:55:05 <deweyvm> okay now i have stdin and out both set to line buffering and im flushing stdout after every write (and every write ends in a newline) but i still get different behavior in my program vs piping output to cat
13:55:20 <deweyvm> cat sees the output, my program doesnt
13:56:02 <darthdeus>  guys if I have a module which I want to test, but I'm only exporting one function from it ... how should I approach this? I don't want to make the other functions public, but I do want to test them
13:56:03 <deweyvm> maybe theres some nuance to getLine im not understanding?
14:00:55 <deweyvm> http://pastebin.com/G0m88yzd this is basically what im doing
14:02:05 <benzrf> deweyvm: how strange
14:02:13 * hackagebot hit 0.6.1 - Git operations in haskell  http://hackage.haskell.org/package/hit-0.6.1 (VincentHanquez)
14:02:14 <benzrf> deweyvm: have you tested that specific minimal case
14:03:26 <albeit> If I have a function that returns "StateT m IO ()", what context should I be giving to "m"?
14:04:47 <jfischoff> well ‘m’ is the state (I’m struggling to parse your question)
14:04:54 <deweyvm> two factors that might be confounding? they are the same exe, and the getLine is wrapped in try (i fail when i get an error anyway though)
14:04:57 <deweyvm> trying it now
14:05:25 <albeit> I want it to be able to call the function over multiple StateT _ IO, but the compiler can't deduce what m is within the function
14:06:08 <jfischoff> albeit: I would paste the code
14:06:08 <pavonia> "StateT m IO ()" means it works for any m
14:06:21 <albeit> Oh my bad I had a separate type definition within the function with "m" as well. All good
14:06:55 <deweyvm> benzrf: no i cant seem to get it to happen with simpler examples, but i cant imagine anything that would make it happen anyway
14:08:05 <kini> are undefined and const undefined "the same thing", in some sense?
14:08:27 <kini> I was talking with a friend, and it seemed to me that since const undefined is in WHNF, but undefined has no WHNF, that they must be different
14:08:51 <benzrf> kini: of course they're different...
14:09:02 <kini> but his point of view was, the only way you can distinguish two values of a function type is to try to apply them to something, and both undefined and const undefined will show the same behavior when you try to apply them
14:09:12 <hpc> kini: they are the same in the absence of seq
14:09:20 <hpc> which is sometimes theoretically useful
14:09:31 <kini> sorry, I should have said, "undefined :: a -> b" and "const undefined :: a -> b"
14:10:00 <kini> hpc: oho, good point!
14:10:25 <merijn> hpc: I'm pretty sure they're not
14:10:46 <hpc> merijn: what other way is there to differentiate?
14:11:08 <kini> maybe replacing "the absence of seq" with "the absence of strictness annotations"?
14:11:12 <kazagistar> memory usage? :P
14:11:19 <hpc> afaik the only other thing you can really do to force a lambda is application
14:11:22 <merijn> hpc: Actually, nvm, you're right
14:11:28 <hpc> in which case they are extensionally equal ;)
14:11:49 <merijn> hpc: I was thinking case would force the application, but it won't
14:12:15 <hpc> what, like case f of {}?
14:12:34 <shachaf> kini: This is the reason that people don't like seq and equivalents.
14:12:50 <shachaf> You "shouldn't" be able to distinguish undefined and const undefined, but you can.
14:13:03 <merijn> hpc: "case undefined 1 of x -> True" vs "let foo = const undefined in case foo 1 of x -> True"
14:13:16 <kini> shachaf: what's the argument as to why you shouldn't be able to distinguish them?
14:13:32 <merijn> hpc: But that doesn't actually force the application
14:13:46 <hpc> yep
14:19:06 <xenomachina> I was reading http://www.haskell.org/haskellwiki/GADTs_for_dummies and I don't get the point of being able to do something like "D2 :: T Bool".
14:19:06 <phaskell> D2: Add .arcconfig - https://phabricator.haskell.org/D2
14:19:40 <xenomachina> in a data declaration, I mean.
14:20:06 <hpc> xenomachina: it's easier to see when you get to writing functions on T
14:20:22 <benzrf> xenomachina: it lets you define the type of a value without requiring it to specifically contain a value of that type
14:20:24 <hpc> xenomachina: to take a totally contrived example, you're writing an interpreter for a language
14:20:49 <benzrf> xenomachina: for example, if you want to make a functor instance
14:20:57 <hpc> data Val a where Num :: Double -> Val Double; String :: String -> Val String
14:21:09 <benzrf> xenomachina: and your type uses predefined values and not actual a's and b's
14:21:10 <Darwin226> If I have a function that takes one parameter and returns a binary function, why can't I do this http://lpaste.net/105090 ?
14:21:23 <mietek> Has anyone tried linking a Haskell app with -framework Cocoa?
14:21:30 <benzrf> xenomachina: you can state that 'ThisCons' has type 'T Bool' and not 'T a'
14:21:33 <Darwin226> Complains about arity mismatch
14:21:37 <merijn> Darwin226: All patterns need to have the same number of arguments
14:21:45 <proxfox> is there a way to hardcode a data structure into an executable during compilation, the intermediate list with which it is built takes 4GB memory, but the structure only 500MB... I'm using http://stackoverflow.com/questions/12716215/load-pure-global-variable-from-file and it's just `read` over a file. Is there a more efficient way?
14:21:46 <benzrf> xenomachina: then you can make fmap take a boolean-taking function or something
14:21:49 <merijn> Darwin226: The first one has 3 arguments, the other 1
14:21:52 <benzrf> xenomachina: not that *that* is useful ;p
14:22:01 <benzrf> just as an example
14:22:05 <Saizan> benzrf: that usually prevents functor instances
14:22:06 <Darwin226> merijn: I see. Is there a workaround?
14:22:09 <benzrf> Saizan: yeah
14:22:20 <hpc> proxfox: template haskell, more likely?
14:22:38 <Saizan> benzrf: precisely because fmap needs to work for all types
14:22:43 <proxfox> hpc: yep, it's template haskell in the stackoverflow link
14:22:44 <merijn> Darwin226: Change the first line into 'op "set" = \_ y -> y'? :)
14:22:46 <kadoban> Darwin226: First like you can do op "set" = const id -- I believe, check that that makes sense though
14:23:01 <hpc> proxfox: as much as a choice between unsafe* and TH is a rock and a hard place, that's what i would go with
14:23:19 <Saizan> benzrf: so i think you picked the one thing that gadts make not work
14:23:19 <proxfox> hpc: but the read just parses a fromList [], which ends up eating 4GB of memory
14:23:19 <benzrf> TH is not *that* terrible
14:23:20 <Darwin226> Thanks guys, should have done those
14:23:23 <benzrf> unsafe* is eeevil
14:23:27 <merijn> Darwin226: :)
14:23:28 <benzrf> Saizan: haha
14:23:33 <kadoban> Darwin226: Oh, no I'm wrong I think, heh...go with the other suggestion
14:23:43 <benzrf> i started typing before the conductor of my train of thought could see the cliff
14:24:19 <hpc> proxfox: TH will eat the space at compilation to compute the value, then dump the result into the source
14:24:45 <benzrf> xenomachina: one other eeeeevil application of GADTs:
14:24:55 <hpc> (fsvo "source", i would assume it's not actually reifying the TH results as stringy source because ew)
14:25:07 <benzrf> data Identity2 a b where Identity2 :: a -> Identity2 a a
14:25:08 <xenomachina> hpc: I get the purpose of things like "data T a where Foo :: Whatever -> T Whatever". I just don't get where it makes sense to have the type be a "T Type" with no parameter of that type.
14:25:09 <proxfox> hpc: is it possible that it doesn't compute all values? I did notice that it takes about 400MB to compile but at runtime it still eats a lot of memory and then stabilizes at 500MB...
14:25:13 <benzrf> xenomachina: now you can say:
14:25:28 <benzrf> instance Functor a => Functor (Identity2 a)
14:25:36 <benzrf> xenomachina: muahaha!
14:25:37 <hpc> xenomachina: it can be used as a tag
14:25:52 <hpc> xenomachina: so for instance, i think there's a GADT out there that does type-safe file IO
14:26:18 <hpc> so there's a function close :: Foo Open whatever -> Foo Closed whatever
14:26:52 <hpc> xenomachina: and Open and Closed would be just whatever; most likely data Open = Open, or an EmptyDataDecl of just data Open
14:26:57 <monochrom> xenomachina: if you keep your T abstract to your user, then you are giving them a restricted API that enforces rules you want enforced
14:27:13 <proxfox> hpc: I'm guessing that the solution I'm using is not really doing most of the work during the compile time, so I'll try to rewrite ti
14:27:36 <Saizan> benzrf: Functor a is ill-kinded there
14:28:04 <Saizan> benzrf: also, the Functor instance won't work anyway
14:28:22 <monochrom> types do not just hold data. types mediate abstractions.
14:29:08 <xenomachina> benzrf: I don't know anything about functors, so I didn't really understand that explanation.
14:29:25 <rwbarton> don't worry
14:29:49 <hpc> @quote loop.waiting
14:29:49 <lambdabot> No quotes match. Just try something else.
14:30:08 <hpc> i forget the quote, something along the lines of "lists are a loop waiting to happen"
14:30:24 <merijn> @quote loops.waiting
14:30:24 <lambdabot> No quotes match. My mind is going. I can feel it.
14:30:26 <merijn> hmm
14:30:32 <hpc> @quote waiting.to
14:30:32 <lambdabot> Cale says: You should think of lists as being like loops which are waiting to happen.
14:30:36 <hpc> ah
14:30:41 <monochrom> @quote list.*loop
14:30:42 <lambdabot> Cale says: A list is a bit like a loop which hasn't happened yet. This operation is similar to "how do I make the 5th iteration of my loop do something different from the others?"
14:30:47 <hpc> but that's a good example of "doesn't contain data"
14:31:08 <hpc> even though it does :P
14:31:23 <monochrom> a list still contains enough data. maybe not all of the data at the same time due to lazy list. but still.
14:32:07 <xenomachina> hpc: The Open/Closed example seems a bit different, since the only value of type "Open" is "Open".
14:32:41 <monochrom> I just want to say, in the 1960s, types were 100% about "what data do you want to carry". today, types are 30% about "what data do you want to carry" and 70% about "what API do you want to expose"
14:33:23 <benzrf> monochrom: heh
14:33:37 <xenomachina> hpc: Using a multi-valued type when there is no actual value seems like an abuse of the type system.
14:33:39 <benzrf> types in c were about 'how i divide'
14:33:50 <Welkin> what about types in swift?
14:34:03 <Welkin> I don't see how it has typeclasses...
14:34:07 <merijn> xenomachina: It's very common to add extra typesafety to your data
14:35:13 <hpc> xenomachina: no, just "use" ;)
14:35:27 <hpc> you'll eventually get used to the type system being a language unto itself
14:36:01 <monochrom> why do you think it is an abuse? is it because you still think the 1960s "types are only about carrying data"?
14:36:02 <xenomachina> monochrom: what kind of abstraction is comes from the "D2 :: T Bool" in a GADT? Why use Bool and not something else if there can never be any Bool value?
14:36:03 <phaskell> D2: Add .arcconfig - https://phabricator.haskell.org/D2
14:37:27 <hpc> xenomachina: because the type itself has meaning regardless of the values it can take
14:37:34 <xenomachina> monochrom: Saying someone thinks in the 1960s seems less like a rational explanation and more like an ad hominem.
14:37:53 <monochrom> ok, sorry then, delete "the 1960s".
14:39:04 <xenomachina> hpc: such as?
14:40:20 <hpc> type class resolution, for instance
14:40:23 <monochrom> you can have an operation "op1 :: T a -> T a -> T a". users can use it as T Bool -> T Bool -> T Bool. or T Char -> T Char -> T Char. but not T Bool -> T Char -> T Bat. therefore, you know that certain ways of using your API cannot happen. you have fewer error cases to handle.
14:41:00 <napping> http://en.wikibooks.org/wiki/Haskell/GADT seems pretty good
14:41:18 <glguy`> With Proxy the type helps with type resolution
14:41:39 <glguy`> With ST the type links logical threads of work
14:42:05 <monochrom> the "Expr a" example is an example of what I just said
14:42:14 <hpc> or it could simply be used as a flag
14:42:21 <rwbarton> if select(2) indicates that a file descriptor is ready for write, how much data am I guaranteed to be able to write to it without blocking?
14:42:25 <hpc> data T a where S :: T String; I :: T Int
14:42:31 <hpc> foo :: T a -> a
14:42:37 <hpc> foo S = "string"
14:42:39 <napping> rwbarton: I'm not sure you're even guaranteed to actually be able to write anything
14:42:40 <hpc> foo I = 17
14:43:29 <vanila> hpc, can you write liftM <n> in this way? where n is some gadt
14:43:30 <xenomachina> monochrom: So what would make you choose to use "data T a where { D2 :: T Bool ; ... " rather than "data T a where { D2 :: T Char ; ... }"?
14:43:35 <albeit> Is there any way to see if a file isn't using any of its imports, so that  I can prune the import list?
14:43:54 <napping> rwbarton: and I'm pretty sure you can construct cases where only 1 byte can be sent
14:44:01 <monochrom> I don't understand the question.
14:44:02 <excarna> albeit: I use ghcmod-vim, which alerts me of useless imports
14:44:18 <jfischoff> albiet: ghc has a flag for dumping a minimal import list
14:44:30 <jfischoff> albeit: err ^
14:44:33 <rwbarton> napping: hmm, but maybe write(2) will then return 1 [one byte written] and not block?
14:44:34 <napping> xenomachina: if you are using types like that, probably your type has *something* to do with Bool or Char or whatever
14:44:52 <napping> rwbarton: I'm not sure whether select is guarnateed not to have spurrious wakeups
14:45:02 <napping> rwbarton: also, if there are any other writers, maybe they take up the space
14:45:07 <rwbarton> yeah
14:45:15 <rwbarton> I guess that is always possible
14:45:15 <albeit> excarna: Cool, using vim2hs, guess I'll add that too
14:45:27 <napping> anyway, you should be doing non-blocking operations on fds you are using select/whatever on
14:45:32 <napping> why are you using select anyways?
14:45:53 <rwbarton> if you open a file with openFileBlocking then when you try to write to it, GHC checks whether it's ready for writing
14:46:17 <rwbarton> using select
14:46:37 <monochrom> where did "data T a where { D2 :: T Bool ..." come from? who wrote it, and for what purpose?
14:46:38 <phaskell> D2: Add .arcconfig - https://phabricator.haskell.org/D2
14:46:52 <monochrom> may I ban phaskell already?
14:46:57 <xenomachina> napping: What could it have to do with Bool or Char? I'd really like to see a (short) example of something like this where the Bool wasn't just pulled out of a hat and actually interoperates with something that really uses Bool values.
14:47:24 <napping> xenomachina: a usual example (detail in the link I put) is an interpreter
14:47:54 <monochrom> xenomachina, that kind of example is already in http://en.wikibooks.org/wiki/Haskell/GADT which napping already suggested
14:48:00 <napping> if you have something like data Exp a where Not :: Exp Bool -> Exp Bool; ETrue :: Exp Bool; EFalse :: Exp Bool; Plus :: Exp Int -> Exp Int -> Exp Int; ...
14:48:13 <napping> then eval :: Exp a -> a is a lot simpler
14:48:24 --- mode: ChanServ set +o monochrom
14:48:28 <vanila> is it possible to use these GADT techniques to make a general liftM?
14:48:38 <vanila> that covers liftM, liftM2, liftM3
14:48:41 <napping> I don't see what they have to do with liftM
14:48:47 --- mode: monochrom set -o monochrom
14:48:49 <vanila> :t liftM
14:48:50 <lambdabot> Monad m => (a1 -> r) -> m a1 -> m r
14:48:50 <vanila> :t liftM2
14:48:51 <lambdabot> Monad m => (a1 -> a2 -> r) -> m a1 -> m a2 -> m r
14:48:56 <napping> just using the <$> <*> from applicative is the usual way to generalize stuff
14:49:04 <vanila> I wanted to make  liftM <n> : type of liftMn
14:49:10 <vanila> where <n> is some GADT
14:49:24 <napping> It's really a type function you need there, I think
14:49:37 <vanila> the operators way is much better yeyah
14:50:28 <napping> maybe something with closed type families?
14:51:15 <napping> xenomachina: a lot of other things make more sense with types that don't (necessarily) have values at all, like Open/Closed for file stuff and so on
14:52:53 <napping> xenomachina: also, this is reasonably fancy stuff. You can go pretty far without needing GADTs
14:53:24 <xenomachina> napping: which example are you specifically referring to?
14:54:19 <napping> on the GADT page, the examples up through 2.4
14:56:09 <Petit_Dejeuner> Is there anyway for parsec to return a value different then the one it reads? I'm trying to use parsec to transform \n \r \t and \\ into the symbols they represent for a scheme interpreter.
14:56:49 <napping> Petit_Dejeuner: parser >> return v?
14:56:56 <xenomachina> I think I understand now, thanks. Though I don't actually see any examples in 2.4 of that page that do the kind of thing I'm talking about.
14:57:12 <napping> what kind of thing in particular?
14:58:16 <fread2282> d
14:58:32 <tibbe> jfischoff: not really
14:58:37 <tibbe> jfischoff: patches accepted
14:58:53 <napping> an Expr Bool doesn't necessarily contain a Bool, but through eval it gives you a Bool
14:58:54 <jfischoff> tibbe: I forgot what I asked :p
14:59:01 <Gurkenglas> @hoogle (k->k->k)->(a->a->a)->Map k a->Map k a->Map k a
14:59:01 <lambdabot> No results found
14:59:15 <tibbe> jfischoff: nfdata for network
14:59:38 <xenomachina> The examples there all seem to be functions. eg: "B :: Bool -> Expr Bool". That I already understood. I just didn't get the purpose of being able to have a "singleton" (not sure what the correct terminology is) that has a type like "T Bool".
14:59:40 <tibbe> jfischoff: i don’t find these instances terribly useful but im not opposed to them
15:00:04 <napping> xenomachina: eval :: Expr a -> a is the other half of the example
15:00:13 <napping> and you can build up something like Eq (I 1) (I 2) :: Expr Bool
15:00:21 <jfischoff> tibbe: the instance won’t do anything, but it makes it easier to use with code that requires it
15:00:31 <tibbe> jfischoff: fair enough
15:00:32 <jfischoff> it might do something
15:00:37 <jfischoff> probably not
15:00:41 <jfischoff> cool
15:00:50 <napping> The point here is that you can have an Expr a for varying types of a, but the "Int Constant" case I only makes sense/only should be allowed when a = Int
15:01:20 <rwbarton> I think xenomachina is specifically asking about GADT constructors with no fields
15:01:35 <Petit_Dejeuner> napping, Thanks, that seems to work.
15:02:27 <xenomachina> rwbarton: I'm not sure on the terminology, but that sounds about right.
15:02:32 <napping> As the "phantom types" section goes through, you could always prevent people from building bad instances by not exporting the real constructors, but when you pattern match and find one of the special cases you don't know you're in those types
15:02:42 <monochrom> xenomachina: if you're saying "data T a where D2 :: T Bool", period, then I agree it is useless. but real code is not going to be like that.
15:02:52 <Francis49> hello dear friends
15:03:28 <jfischoff> hello Francis49
15:04:16 <xenomachina> monochrom: I mean like the example in the "GADTs for dummies" page, essentially data T a where { D1 :: Int -> T String ; D2 :: T Bool ; D3 :: (a,a) -> T [a] }
15:04:19 <monochrom> a type like "data Proxy a = Proxy" is a singleton, but it's a polymorphic singleton, it allows you Proxy Bool, Proxy Char, Proxy (Int -> String). that's different from "data T a where D2 :: T bool"
15:04:30 <Gurkenglas> So this text is saying that foo :: Show a => [a] is declaring to, given any Show instance of any type a, return a list of elements of that type. But isn't that instead declaring that the type of elements of the list it returns will be a Show type?
15:04:38 <monochrom> does that page show you examples of use?
15:04:40 <Francis49> hello jfishhoff
15:05:01 <jfischoff> close enough ;)
15:05:05 <Francis49> friend yuu_chan are you here?
15:05:19 <xenomachina> monochrom:
15:05:54 <monochrom> where is the "GADTs for dummies" page so I can read it for real?
15:06:12 <xenomachina> monochrom: That's getting into another think that confuses me, but which I think/hope is a separate issue.
15:06:30 <xenomachina> I linked it earlier: http://www.haskell.org/haskellwiki/GADTs_for_dummies
15:07:35 <monochrom> then it is an example of what is legal, not necessarily what is useful
15:07:36 <napping> xenomachina: that's just a syntax example
15:08:48 <Francis49> jfischoff, can i ask something?
15:09:24 <monochrom> it seems that GADTs for Dummies is a tutorail on... type families!
15:09:43 <xenomachina> monochrom: I wasn't asking about cases like "data Proxy a = Proxy" but rather GADTs where constructor was a singleton with a specific type for the type parameter. The Expr example napping linked to didn't contain something like that, but at least made it possible for me to think of how such a thing would be useful.
15:10:02 <monochrom> yes
15:11:27 <Gurkenglas> > print "I'm still responding"
15:11:41 <monochrom> @botsnack
15:13:11 <napping> you might have something like data SNat n where SZ : SNat Z; SS : SNat n -> SNat (S n)
15:13:11 <benzrf> napping: ::, you mean
15:13:11 <napping> if you already have a data kind Nat = Z | S Nat around
15:13:11 <napping> oh, probably
15:13:11 <napping> and then maybe a type of length indexed vectors or something
15:13:11 <napping> data Vector n a where VNil :: Vector Z a; VCons :: a -> Vector n a -> Vector (S n) a
15:13:29 <lambdabot> :)
15:13:33 <lambdabot>  <IO ()>
15:13:41 <monochrom> the first time I dabbled in GADTs was writing a type to model SQL expressions. but it's equivalent to the "Expr a" example. except at the end I just wanted "emit_SQL_code :: SQLExpr a -> String"
15:14:05 <jfischoff> Francis49: you can ask all of us
15:14:44 <monochrom> using GADT allowed me to restrict user-written expressions to be type-correct. they cannot possible write something that translates to "34 * 'hello'"
15:14:55 <xenomachina> napping: Yes, I get that. The issue I was having is that the example is so random that it completely obscured why you'd ever want to have something like "D2 :: T Bool" in a GADT.
15:15:23 <Francis49> thanks jfischoff. do you know recursion, yes. i tryed a recursive procedure and worked max 50! it is possible?
15:16:07 <jfischoff> Francis49: is what possible?
15:16:13 <napping> xenomachina: I've messed around with things like making a GADT that tells you what a type looks like : data TyRep a where TBool :: TyRep Bool; TInt :: TyRep Int; TPair :: TyRep a -> TyRep b -> TyRep (a,b); TArr :: TyRep a -> TyRep b -> TyRep (a -> b); ...
15:16:35 <monochrom> I think there is merit in telling apart "this example shows useful code" from "this example shows legal code, change details to do useful things"
15:16:51 <monochrom> it seems unrealistic to expect all examples to be useful
15:17:08 <napping> not a whole lot better or different from foo [1,x,y] = x+y; foo [z] = length (show z); ...
15:17:23 <Francis49> yes, jfischoff. i am very new to haskell, i migrate from lisp (better from scheme dialect) a i used with petite scheme to do 900,000!
15:17:27 * hackagebot hstorchat 0.1.1.0 - Distributed instant messaging over Tor  http://hackage.haskell.org/package/hstorchat-0.1.1.0 (ChristopherReichert)
15:17:49 <napping> xenomachina: In general, I'd say that as you use types to explain/enforce fancier things that what kind of values you have in an container, then the relationship between types/type parameters and values necessarily becomes more complicated as well
15:18:02 <jfischoff> @hpaste
15:18:02 <lambdabot> Haskell pastebin: http://lpaste.net/
15:18:04 <monochrom> for all I heard about python people complaining "you haskell people use useless academic examples such as fibonacci in your tutorials", I thought that the python tutorial would be much better.
15:18:15 <jfischoff> Francis49: paste the code using the url above ^
15:18:35 <companion_cube> "you python people use academic examples such as addition in your tutorials"
15:18:41 <monochrom> then one day, I needed to learn python finally, so I hopped over to the official python tutorial. lo and behold, their first example was fibonacci.
15:19:01 <napping> So whatever the type parameters mean, if a no-argument constructor belongs in your type, it might go with specific values of the type parameters
15:19:08 <hpc> everyone knows you're supposed to use factorial!
15:19:11 <monochrom> that day, I learned a great deal about human nature.
15:19:26 <xenomachina> napping: How would you actually use a type like your TyRep?
15:19:30 <hpc> monochrom: try learning ruby sometime
15:19:36 <hpc> the official docs are a manifesto to OOP
15:20:07 <napping> xenomachina: you can write functions like TyRep a -> a -> String
15:20:24 <napping> maybe you don't do anything interesting for the function case then...
15:20:32 <Francis49> yes i will try. done
15:20:53 <napping> Usually type classes or something are a better idea, but if you want type-specific functions over a limited universe, then reflecting down types like that can work
15:20:54 <jfischoff> Francis49: paste the url here
15:21:07 <kini> haskell-mode seems to understand cabal and sandboxes... right? but then why does the repl it brings up (with haskell-interactive-bring) fail to load all the intra-project module imports in my file?
15:21:43 <kini> The error message looks basically the same as if I were to go into the subdirectory where this particular file is, and do `ghci file.hs`
15:21:45 <Francis49> jfischoff i done
15:21:45 <napping> kini: do you have a few projects sharing a sandbox?
15:21:56 <jfischoff> Francis49: whats the url?
15:22:12 <napping> kini: importing files between different directories in a single cabal project under a sandbox works fine for me
15:22:15 <kini> napping: no, it's just one project with its own sandbox in the root of the project directory... the sandbox does have external sources added to it though
15:22:31 <Francis49> jfischoff here
15:22:37 <Francis49> http://lpaste.net/1792248947352272896
15:22:38 <merijn> hpc: Do the docs makes you write a Car class that inherits from Vehicle? :p
15:22:53 <kini> there is a "hs-source-dirs" directive in this .cabal file - maybe that's confusing haskell-mode?
15:22:53 <napping> So cabal build works, and lists all the source directories and modules you want and stuff like that?
15:23:00 <kini> cabal build works, cabal install works
15:23:10 <kini> libraries and executables are correctly produced
15:23:34 <napping> huh, dunno then
15:23:45 <kini> this is on ghc 7.8.2 btw, and cabal-install 1.20.0.2, cabal 1.20.0.0
15:24:15 <napping> that's what I have, except cabal-install 1.20.0.1
15:26:24 <kini> this .cabal file has a "library" section with "build-depends: [...]", "hs-source-dirs: src", and then "exposed-modules:" with a giant list of modules
15:26:24 <kini> and then also an "executable" section with "build-depends: [...]", "hs-source-dirs: app", and a "main-is:", but no "exposed-modules"
15:26:40 <kini> that seems reasonable... doesn't it?
15:26:56 <napping> I also have an executable and library, and imports/reply from the executable to the library modules works okay
15:27:14 <napping> opening the repl to the executable's module, that is
15:27:38 <kini> what about opening the repl to library modules?
15:27:43 <monochrom> Francis49: since you use Int, which has only a few bits, you won't get right answers for big factorials
15:27:45 <kini> (with haskell-interactive-bring)
15:27:59 <monochrom> however, you have written correctly.
15:28:18 <napping> I'm just hitting C-c C-l / C-c C-b, but opening library modules works fine too
15:28:24 <napping> I was taking that for a given
15:28:44 <jfischoff> Francis49: It will overflow if you put in 50. Use Integer instead. You should probably for the executation of the `n-1` but it should not really matter. The factorial of 90000000 or whatever is probably not something you computed in scheme: http://lpaste.net/105094
15:28:56 <deweyvm> i was wrong, its not that the output isnt happening, its that print is hanging (i think?)
15:29:23 <Francis49> ah thanks monochrom. i am new to haskell. but factorial use integer. i will try
15:29:41 <sveit> in the current dependent typing "hacks" for haskell, are there ways to specify arbitrarily high numbers in the typesystem without huge recursive data structures?
15:30:13 <Francis49> jfischoff, really, with petite scheme 8.4 64 bit i got 900,000! factorial. incredible but really
15:30:29 <napping> TypeLits should be reasonably arbitrarily high
15:30:38 <jfischoff> crazy must of been pages of digits
15:31:08 <monochrom> merely some 900000*log(900000) digits
15:31:30 <jfischoff> heh
15:31:46 <Francis49> uh indeed. i saved it in a text file. some megabyte, do not remember but very very very big
15:31:49 <pavonia> > 900000*log(900000)
15:31:52 <lambdabot>  1.2339135038075803e7
15:32:05 <xenomachina> napping: thanks for your help.
15:32:55 <monochrom> some people can memorize a million digits of pi. but they don't memorize a million digits of factorial of 900000.
15:33:15 <hpc> monochrom: i have the least significant digits memorized!
15:33:28 <monochrom> I am dumb, I only remember 10 digits of pi. they are 0, 1, 2, 3, 4, 5, 6, 7, 8, 9
15:33:40 <deweyvm> only?
15:33:43 <deweyvm> i think thats all of them
15:33:47 <Axman6> hey, you got them in order too!
15:33:55 <hpc> no, you forgot decimal point
15:33:56 <haasn> In order of frequency?
15:33:59 <Francis49> monochrom, i saved the file with 900,000 factorial on the other my computer. next time i will tel precise the number of the digits
15:33:59 <monochrom> I am also speaking modestly
15:34:04 <napping> hpc: you've even memorized more of them than monochrom cares to listen to, I'd wager
15:34:13 <Axman6> nah, they're in that order somewhere
15:34:35 <hpc> napping: i wrote a library that exactly computes pi - http://hackage.haskell.org/package/acme-php
15:35:41 <companion_cube> does php have bigints ?
15:35:47 <kini> Actually, even though I am unable to get haskell-mode to bring up a repl, I am wondering how much it will really help me.
15:35:48 <kini> From poking around while trying to debug this, it seems that C-c C-t (haskell-process-do-type) just dumps ":t <word-at-point>". So won't that only work for things that are defined at the top level?
15:35:55 <monochrom> I can't find where acme-php computes pi
15:36:06 <kini> How can you get type information about subterms of something that you're in the process of writing? (Like you might get in an IDE for other languages)
15:36:08 <hpc> monochrom: pi = "3.14"
15:36:18 <monochrom> haha, I see now, yes
15:36:34 <haasn> Axman6: heh http://mathworld.wolfram.com/PiDigits.html
15:36:35 <monochrom> I was looking for something long
15:36:37 <kini> Is that what ghc-mod / hdevtools are for?
15:36:42 <hpc> monochrom: that's adorable :P
15:36:48 <haasn> http://oeis.org/A101815
15:37:42 <Francis49> monocrhom and jfischoff, with integer now works. my guilt. i have a lot da learn
15:37:46 <haasn> There is an OEIS entry for *everything*
15:38:13 <haasn> Actually, is there an OEIS entry for a sequence of numbers that is not an OEIS entry?
15:39:01 <Axman6> (<>) :: IO String -- heh
15:39:03 <Francis49> great friends, 30,000! hehehe, very good. thank you a lot
15:39:15 <bergey> kini: Maybe you want typed holes: http://www.haskell.org/ghc/docs/7.8.2/html/users_guide/typed-holes.html
15:39:21 <Axman6> haasn: um...
15:39:28 <bergey> I don't know if any of the emacs tools support them directly yet.
15:40:39 <kini> bergey: yup, I just found out about that a little while ago...
15:41:24 <kini> however if I put a hole in my program and do C-c C-t on it it tells me, "found hole '_' with type: t"
15:41:25 <kini> lol
15:42:43 <enthropy> @hoogle reproxy
15:42:48 <lambdabot> Graphics.Rendering.OpenGL.GL.Texturing.Queries textureProxyOK :: ParameterizedTextureTarget t => TextureQuery t Bool
15:43:43 <Francis49> jfischoff, monochrom, what is the best haskel book or books?
15:44:19 <monochrom> http://www.vex.net/~trebla/haskell/learn-sources.xhtml lists some
15:46:20 <Francis49> thanks monochrom, i have to read three books, hehehe
15:50:16 <rwbarton> @tell TallerGhostWalt I tracked down the issue to a ghc bug: https://ghc.haskell.org/trac/ghc/ticket/9168
15:50:16 <lambdabot> Consider it noted.
15:51:03 <kini> well, I guess writing holes in my code, switching to a terminal, doing `cabal install`, waiting 5-10 seconds, and then scrolling up to see the hole information works
15:54:26 <hexagoxel> kini: why not use repl? i think it generally is faster than "cabal install"
15:55:07 <kini> because first of all I can't get the repl to properly load the imports in my file (whereas cabal understands them correctly)
15:55:18 <hexagoxel> "cabal repl"?
15:55:19 <kini> and second of all, repl can only report type information about top-level definitions, right?
15:55:28 <kini> cabal repl still has the second problem
15:55:37 <kini> and also haskell-mode doesn't seem to be able to use cabal repl
15:55:51 <kini> I don't know what it is doing, but whatever it is doing, the repl that appears in emacs has a bunch of "could not find module foobar" in it
15:56:43 <hexagoxel> hmm so you get more information for type holes in install vs repl?
15:56:48 <kini> I think so...
15:56:56 <hexagoxel> interesting.
15:57:03 <kini> oh, you mean I could type holes into the repl?
15:57:08 <kini> I didn't try that
15:57:25 <infinity0> Continuations seem very similar to Futures to me, what's the difference?
15:58:32 <Francis49> monochrom, jfischoff, do you knows the leksah ide? any suggestion?
15:58:59 <monochrom> I don't know leksah. I just use emacs. sometimes even notepad-plusplus
15:59:10 <kini> leksah seems not to have been updated in about 2 years
15:59:14 <jfischoff> I used it years ago and it worked fine. I just use a text editor these days
15:59:16 <jfischoff> ha
15:59:28 <kini> whereas chrisdone_ updates haskell-mode quite regularly these days, I think
16:00:16 <monochrom> I don't know Future. I just watched Days of Future Passed yesterday.
16:01:11 <hpc> monochrom: -blah
16:01:13 <Francis49> becose i am accostumed to be strong interactive with lisp, i prefer use an ide. but i must think about this
16:01:30 <mpgaillard> hello, while reading a book called Learned You a Haskell and seeing the description of Quicksort I can't help but notice how much slower this must be compared to the regular procedural version even though it is much more elegant. Is this one of the weaknesses of Functional Programming in comparison to regular procedural programming? I notice for example that it is using much more memory since it is creating all these smaller lists in
16:01:30 <mpgaillard> each recursive calls similar to something merge sort would though which is one of the advantages quick sort has over merge sort, and that also adding two lists with ++ is very slow
16:01:43 <mpgaillard> this is the code I am talking about
16:01:47 <hpc> mpgaillard: that quicksort is a lie
16:01:48 <mpgaillard> quicksort :: (Ord a) => [a] -> [a]
16:01:48 <mpgaillard> quicksort [] = []
16:01:49 <mpgaillard> quicksort (x:xs) =
16:01:49 <mpgaillard>     let smallerSorted = quicksort [a | a <- xs, a <= x]
16:01:49 <mpgaillard>         biggerSorted = quicksort [a | a <- xs, a > x]
16:01:49 <mpgaillard>     in  smallerSorted ++ [x] ++ biggerSorted
16:02:11 <joelteon> that's not quicksort, mpgaillard
16:02:12 <monochrom> you can use a mutable array. you don't have to use a list.
16:02:14 <joelteon> quicksort is in-place
16:02:41 <joelteon> for actual quicksort, it'd have to be written on a mutable array
16:02:55 <hpc> mpgaillard: this is how you write a really good sort in haskell - http://hackage.haskell.org/package/base-4.7.0.0/docs/src/Data-List.html#sortBy
16:02:57 <mpgaillard> ok, I have not read about mutable arrays yet. I thought that in haskell everything was immutable
16:03:05 <joelteon> I think that version of "quicksort" has a significantly higher complexity than actual quicksort.
16:03:17 <rwbarton> it has the same asymptotic complexity
16:03:20 <joelteon> because filter runs in linear time
16:03:27 <Axman6> mpgaillard: we have mutation, and its much nicer than in most languages
16:03:32 <hpc> mpgaillard: don't expect to understand it right away, augustss is a wizard :D
16:03:35 <benzrf> Axman6: dont be absurd
16:03:36 <monochrom> it is a limitation of showing an example using very limited tools because you are new and you only know limited tools
16:03:43 <Axman6> i'm not
16:03:47 <joelteon> oh it has the same complexity?
16:03:48 <joelteon> that's neat
16:03:49 <Axman6> ST is beautiful
16:03:54 <benzrf> lol
16:04:01 <Axman6> ?
16:04:06 <benzrf> maybe technically speaking
16:04:10 <benzrf> not in usage, id imagine
16:04:26 <Axman6> so you've never used it
16:04:29 <Axman6> ?
16:05:04 <hpc> i quite like using ST
16:05:08 <Axman6> me too
16:05:28 <hpc> i rarely get a chance to use it though because at that point staying in IO is easier :(
16:05:34 <mpgaillard> thanks for the explanation
16:05:41 <Axman6> being able to implement mutating algorithms with a completely pure interface? yes please!
16:06:09 <Francis49> well dear friends monochrom, jfischoff, and all the other, i go. hope to see you next time. a nice day for you all and thanks much. a nice day for all the friends in the channel. bye
16:06:50 <Axman6> mpgaillard: to somewhat answer your question, using linked lists in any language is not fast (though Haskell does a lot to make it fast when it can by removing the lists). They're fantastic teaching tools and it's why they're used to teach haskell
16:06:57 <jfischoff> Francis49: bye bye now
16:07:38 <hpc> this channel is brought to you by the number three and the color blue
16:07:47 <rwbarton> joelteon: it has the same asymptotic complexity because the imperative in-place partition still takes linear time
16:07:55 <joelteon> nice
16:07:57 <rwbarton> joelteon: so asymptotically that pays for all the filtering, and the (++)s
16:08:06 <companion_cube> lists can be more efficient than arrays, especially when you need to insert elements in front
16:08:25 <Axman6> and take elements off the front!
16:08:33 <Axman6> stacks, yeah!
16:08:34 <companion_cube> also
16:08:44 <companion_cube> in a persistent setting
16:09:04 <dwcook> Is there an msum but for Alternative defined in the standard libraries?
16:09:04 <benzrf> hey
16:09:10 <mpgaillard> I will go through the other explanation of quick sort and read about mutable arrays and how to implement them. Axman6: why do you say that it is nicer than in most languages?
16:09:23 <benzrf> how do i get cabal to build a lib
16:09:47 <dwcook> Heh, right after I asked that I came upon Data.Foldable.asum.
16:09:48 <dottedmag> mpgaillard: Because you can always limit it, so state won't escape a piece of code you've contained it into.
16:10:36 <dottedmag> mpgaillard: and that's a nearly-unique facility of Haskell.
16:10:57 <Axman6> mpgaillard: mutation in Haskell is nicer in my opinion for a few reasons; the ST monad lets us write algorithms that work best with mutation, while providing a completely pure interface (and the type system ensures that). Also you can limit the amount of mutation you need in the rest of your program by using persistent data types by default, and only using mutation to share the values between
16:11:03 <Axman6> threads for example
16:14:45 <benzrf> glah
16:14:45 <benzrf> how do i tell cabal that i want it to install the lib as well as the binary
16:15:08 <Fuuzetsu> doesn't it do that by default
16:15:36 <mpgaillard> Thanks, I am reading about monads now since I had never heard of this before. This language is completely different from what I am used to. This is going to be fun
16:17:17 <Axman6> mpgaillard: stick to the basics, monads will come later (not too much later though. they're fun!)
16:17:33 <dwcook> You could also just say "ST" instead of "the ST monad".
16:17:49 <dwcook> It's the ST type that's special in this case, not monads.
16:18:04 <kadoban> mpgaillard: IMO, avoid any monad info that gets into metaphors. They add more confusion than clarity.
16:18:18 <Axman6> it's kind of a pain to use without using it as a monad though
16:19:27 <mpgaillard> which resources do you guys recommend? What is the next step once I am done with Learn You a Haskell. I am reading about a chapter a day and have solved the first few problems of 99 Problems in Haskell and will continue
16:19:44 <Axman6> learn you a haskell is agreat start
16:19:55 <Axman6> and 99 problems
16:20:28 <Axman6> real world haskell is worth looming at, but it's somewhat outdated these days (needs a rewrite, but I'm not sure that'll ever happen)
16:21:01 <quchen> Implement functions found in Prelude and Data.List yourself as an exercise.
16:21:04 <fread2282> how can I run a conduit conditionally?
16:21:08 <mmmm> quick question, is a "cofree comonad" just a free comonad?
16:21:49 <fread2282> I have Conduit a m (Maybe a) and Conduit a m a and I want to run the second one iff the first one returns Nothing
16:22:29 <mpgaillard> maybe a good book on functional programming? Is there something similar to Introduction to Algorithms from Corman for functional programming?
16:23:07 <Axman6> there's Okasaki's functional data structures I guess
16:23:29 <Axman6> but you'll learn heaps by implementing much of the prelude yourself as quchen suggested
16:23:40 <mmmm> I wouldn't say that Okasaki is a good introduction
16:23:55 <sveit> for haskell ffi, is something like a CChar 'pinned'? i.e. if i already have a cchar value haskell-side, can i get a pointer to it to pass to ffi-based code?
16:23:59 <mmmm> It's quite intricate
16:24:29 <rwbarton> sveit, no
16:24:48 <sveit> rwbarton: so the only way to go is to allocate memory and copy the value?
16:25:08 <rwbarton> if you really need a pointer to a single char (sounds a bit odd, but okay) then yes
16:26:57 <redtricycle> bb
16:27:14 <sveit> is there a standard library function like "withValuePtr :: (Storable a) => a -> (Ptr a -> IO b) -> IO b"? I could easily write my own, but don't want to duplicate work
16:27:26 <rwbarton> @hoogle (Storable a) => a -> (Ptr a -> IO b) -> IO b
16:27:28 <lambdabot> Foreign.Marshal.Utils with :: Storable a => a -> (Ptr a -> IO b) -> IO b
16:27:28 <lambdabot> Foreign.Marshal.Array withArray0 :: Storable a => a -> [a] -> (Ptr a -> IO b) -> IO b
16:27:28 <lambdabot> Foreign.Marshal.Array withArray :: Storable a => [a] -> (Ptr a -> IO b) -> IO b
16:27:59 <sveit> thanks!
16:28:21 <fread2282> or, alternatively, can I do that wite pipes?
16:28:52 <fread2282> s/write/with/
16:29:01 <fread2282> s/write/wite/
16:30:16 <zwer> @src nub
16:30:17 <lambdabot> nub = nubBy (==)
16:32:20 <rwbarton> sveit: and if you dig a bit you'll see that it allocates the temporary memory with newPinnedByteArray#. a crucial detail :)
16:33:38 <kini> I heard that someone was writing something like agda2-mode for haskell to operate with GHC 7.8's typed holes, as a GSoC project
16:33:44 <kini> is that true?
16:36:56 <fread2282> or my first Conduit can just be a -> Maybe a
16:43:16 <monochrom> sorting algorithms have been less important than tree data structures and hash tables
16:46:48 <flebron> Hi. So the following form a semiring, correct? (Void, (), Either, (,))
16:46:50 <benzrf> how i push to hackage
16:47:57 <dfsdfff> I'm trying to cabalize a package.  The cabal utility suggests to put specific versions into the .cabal file.  I gather that would be to restrictive.  How can I determine the bounds that will work?  Is there a way to do so automatically?
16:48:14 <shachaf> flebron: Up to isomorphism, yes.
16:48:42 <dfsdfff> Or should I simply keep the PVP in mind and do everything manually?
16:48:52 <flebron> shachaf: Can one extend that to a "semialgebra"? In which case, does this "semialgebra" have a name?
16:49:15 <flebron> And can one somehow incorporate the property of -> being ^ in this object?
16:49:48 <flebron> (Being cartesian closed just says -> falls within the category, but doesn't explicitly say it's ^)
16:50:06 <rwbarton> semialgebra?
16:50:24 <rwbarton> like a semiring that is a module over ... something?
16:50:49 <rwbarton> or do you just mean "some structure that mentions (->)"
16:52:47 <flebron> Well we can formulate the category of these things (with morphisms respecting Either and (,) I suppose), and one can then make explicit that A -> B is B^A, with ^ defined (somehow?) in terms of (,).
17:05:30 <ReinH> chrisdone_: ping
17:05:43 <donnobot> hello
17:05:57 <benzrf> woot just pushed to hackage for the first time \o/
17:06:04 <donnobot> nice
17:06:06 <jfischoff> \o/
17:06:23 <punchagan> benzrf: what did you push?
17:06:38 <benzrf> http://hackage.haskell.org/package/vampire
17:07:16 <benzrf> ^so alpha it wrapped back to omega
17:07:30 <fread2282> can I define <*> with fmap and pure?
17:07:48 <Cale> fread2282: no
17:07:51 * hackagebot vampire 0.1.0.0 - Analyze and visualize expression trees.  http://hackage.haskell.org/package/vampire-0.1.0.0 (benzrf)
17:07:54 <benzrf> fread2282: of course not
17:08:31 <benzrf> how can i make hackage generate haddock
17:08:42 <Cale> It's less obvious than the fact that you can't define join in terms of fmap and return
17:08:55 <benzrf> t-true
17:09:18 <Cale> (at least there you can count the number of m's involved)
17:09:22 <Axman6> benzrf: it will be generated in a few hours
17:09:27 <benzrf> ah
17:09:55 <benzrf> fread2282: you can define f (a -> b) -> f a -> f (f b) with fmap
17:09:59 <benzrf> if i'm not mistaken
17:11:10 <benzrf> > let fab = [(+1), (+2), (+3)]; fa = [1, 2, 3]; in fmap (\f -> fmap f fa) fabjan
17:11:12 <lambdabot>  Not in scope: ‘fabjan’
17:11:13 <benzrf> > let fab = [(+1), (+2), (+3)]; fa = [1, 2, 3]; in fmap (\f -> fmap f fa) fab
17:11:15 <lambdabot>  [[2,3,4],[3,4,5],[4,5,6]]
17:24:57 <donnobot> Has anyone set up a web server using Haskell?
17:25:44 <donnobot> Hyena or snap server?
17:26:52 <mightybyte> donnobot: That's easy.  Hyena is not actively maintained, snap is.
17:27:53 <pdxleif> I use WAI
17:28:08 <donnobot> ok great....i'm looking into this for the first time...nice to have a direction
17:28:15 <pdxleif> My last job used Snap; I didn't get much of a chance to interact w/ it.
17:28:16 <donnobot> I'll look into snap
17:28:38 <jfischoff> scotty is a nice simple option. Yesod and Snap are logger more full featured
17:28:54 <donnobot> I just want to fiddle around with it to learn haskell
17:29:14 <jfischoff> There is also spock which is like scotty I think
17:29:15 <mightybyte> The bare snap server is close to scotty in simplicity.
17:29:26 * jfischoff nods
17:29:37 <donnobot> hmmm ok all good to know
17:30:20 <donnobot> but overall you guys think snap is the easiest to setup? I'm just doing this locally on my mac
17:30:50 <jfischoff> I would just try to install one
17:31:02 <jfischoff> and if it doesn’t work try another
17:31:09 <mightybyte> Snap...the name says it all. ;)
17:31:18 <donnobot> gotcha gotcha thanks
17:31:21 <fread2282> donnobot: but warp is fast
17:31:30 <donnobot> i look at that as well
17:31:39 <fread2282> beats nginx fast
17:31:48 <donnobot> i'm starting from ground zero.
17:31:58 <jfischoff> I don’t think it beats nginx
17:32:03 <fragamus> > 1+1
17:32:05 <lambdabot>  2
17:32:11 <fragamus> runCont (do {a <- return 1;b <- ContT (\fred->fred 10);return $ a+b}) show
17:32:23 <fragamus> > runCont (do {a <- return 1;b <- ContT (\fred->fred 10);return $ a+b}) show
17:32:26 <lambdabot>  "11"
17:32:58 <fragamus> > runCont (do {a <- return 1;b <- ContT (\fred->fred 10 ++ fred 20);return $ a+b}) show
17:32:59 <lambdabot>  Couldn't match type ‘Data.Functor.Identity.Identity’ with ‘[]’
17:33:00 <lambdabot>  Expected type: [GHC.Base.String]
17:33:00 <lambdabot>    Actual type: Data.Functor.Identity.Identity GHC.Base.StringCouldn't match ...
17:33:00 <lambdabot>  Expected type: Data.Functor.Identity.Identity GHC.Base.String
17:33:00 <lambdabot>    Actual type: [GHC.Base.String]Couldn't match type ‘Data.Functor.Identity.I...
17:33:14 <fragamus> why does that not work
17:33:16 <fread2282> jfischoff: http://www.yesodweb.com/blog/2014/02/new-warp , notably http://www.yesodweb.com/assets/new-warp/result.png
17:34:06 <monochrom> Couldn't match type ‘Data.Functor.Identity.Identity’ with ‘[]’. fred 10 :: ContT Identity xxx yyy
17:34:19 <monochrom> err sorry
17:34:36 <monochrom> fred 10 :: Identity String, not just String
17:35:04 <monochrom> actually, I may be right the first time
17:35:11 <monochrom> @type ContT
17:35:12 <lambdabot> ((a -> m r) -> m r) -> ContT r m a
17:35:26 <fread2282> jfischoff: also http://aosabook.org/en/posa/warp-images/benchmark.png from http://aosabook.org/en/posa/warp.html
17:35:47 <jfischoff> fread2282: last I saw even with MIO Mighty was slower, but that was looking at scaling with cores
17:36:05 <monochrom> the second time is right. m = Identity. r = String. fred 10 :: m r = Identity String
17:36:39 <jfischoff> fread2282: the graphs in here paint a different story: http://haskell.cs.yale.edu/wp-content/uploads/2013/08/hask035-voellmy.pdf
17:38:54 <fragamus> > runCont (do {a <- return 1;b <- ContT (\fred-> Identity $ runIdentity (fred 10) ++ runIdentity (fred 20));return $ a+b}) show
17:38:56 <lambdabot>  "1121"
17:38:58 <dibblego> type constructor application is always left-associative, correct?
17:39:09 <fragamus> hows them apples
17:39:10 <monochrom> yes
17:39:16 <apples> pretty good
17:39:21 <fragamus> lol
17:39:36 <monochrom> and oranges? cranberries?
17:39:40 <dibblego> well InstanceSigs thinks redundant left-associated parentheses changes the type
17:39:49 * monochrom chose cranberry juice last night for dinner
17:40:06 <monochrom> what is instanceSigs?
17:40:16 <dibblego> allows signatures in instance declarations
17:40:17 <dibblego> sec
17:40:38 <dibblego> http://lpaste.net/105100
17:41:25 <fragamus> can anyone make my last input to lambdabot suck less
17:41:48 <fread2282> jfischoff: after that article mighty and now warp use prefork to beat nginx
17:41:56 <monochrom> I see. then I don't know why
17:42:20 <dibblego> monochrom: ok cheers
17:42:23 <fread2282> warp also does tricks to burden the IO manager less
17:43:11 <dibblego> I take that back — it appears to be fixed in 7.8 (I was using 7.6)
17:49:41 <fragamus> So I'm trying to get a handle on this Cont monad…
17:50:20 <heatsink> Are you reading a tutorial?
17:50:33 <fragamus> im reading the mother of all monads
17:50:39 <hpc> there's precious few good explanations of Cont
17:50:50 <hpc> mother of all monads is not one of them, it's more of a showoff piece
17:51:48 <fragamus> well maybe we can play with it here
17:51:52 <akurilin> What's the most idiomatic way of dealing with making a decision in haskell based on a few values I have in the current function? In a different language I'd have used "case" for it. I think guards are pretty close to what I'm looking for, but it seems like I need to make a separate function just for them if I want to use them?
17:51:52 <monochrom> I see. (\fred -> fred 10 ++ fred 20) was legal in old mtl because Cont was its own type. not legal in new mtl because Cont is now ContT r Identity a
17:52:04 <monochrom> however, you may find the helper function "cont" useful
17:52:07 <monochrom> @type cont
17:52:09 <lambdabot> ((a -> r) -> r) -> Cont r a
17:52:12 <monochrom> yeah
17:52:25 <fragamus> how does that help
17:52:34 <monochrom> runCont (do {a <- return 1;b <- cont (\fred->fred 10);return $ a+b}) show
17:52:51 <monochrom> err, useless example
17:52:59 <monochrom> runCont (do {a <- return 1;b <- cont (\fred->fred 10 ++ fred 20);return $ a+b}) show
17:52:59 <fragamus> > runCont (do {a <- return 1;b <- ContT (\fred-> Identity $ runIdentity (fred 10) ++ runIdentity (fred 20));return $ a+b}) show
17:53:01 <lambdabot>  "1121"
17:53:09 <fragamus> use that to start with
17:53:22 <hpc> heh
17:53:32 <fragamus> you did
17:53:40 <monochrom> > runCont (do {a <- return 1;b <- cont (\fred-> fred 10 ++ fred 20);return $ a+b}) show
17:53:42 <lambdabot>  "1121"
17:53:48 <heatsink> akurilin: If it's not 'case', it's syntactic sugar for case; so you can't go too wrong by using 'case'.
17:54:21 <fragamus> oh i like that
17:54:33 <fragamus> it sucks less
17:55:02 <hpc> fragamus: what about Cont are you having trouble with?
17:55:24 <fread2282> I have (a -> Maybe a) and Conduit a m a and I want to run the conduit in a chain one iff the function one returns Nothing (if it return Just a I want to yield a), hiw can I do this?
17:55:30 <fragamus> Well… I have two big blobs of code I'm trying to knit together
17:55:44 <oisin620> I am having a bit of a trouble implementing (http://lpaste.net/105103) a way to print column matrices using the Show instance. Would someone mind pushing me in the right direction?
17:55:48 <fragamus> but it is for my work and I can't really talk about it
17:55:52 <hpc> ah, k
17:56:07 <fragamus> I think Cont is the answer though
17:56:59 <monochrom> in the latest example, fred = \b -> show (a + b). the "a+b" part comes from "return (a+b)". the "show" part comes from your provided "show". in general, fred is a function that contains the stuff from the rest until the end of runCont
18:00:22 <monochrom> oisin620: consider exploiting Text.PrettyPrint. comes with GHC
18:00:43 <heatsink> @src cont
18:00:43 <lambdabot> Source not found. Have you considered trying to match wits with a rutabaga?
18:01:48 <silver> @hoogle cont
18:01:49 <lambdabot> Control.Monad.Trans.Cont cont :: ((a -> r) -> r) -> Cont r a
18:01:49 <lambdabot> Control.Monad.Cont cont :: ((a -> r) -> r) -> Cont r a
18:01:49 <lambdabot> package container-classes
18:02:20 <monochrom> cont is something that saves you a lot of runIdentity and Identity when you use ContT r Identity :)
18:04:33 <fragamus> > runCont (do {a <- return 1;b <- cont (\fred-> fred 10 ++ fred 20);return $ a+b}) (\x->[x])
18:04:35 <lambdabot>  [11,21]
18:05:40 <fragamus> so um… this creates a kind of separability between the effects and the computation
18:06:14 <monochrom> yes, except I am no longer sure who is the effect and who is the computation :)
18:06:45 <StoneCypher4k> (spooky voice) you are the effect.  and YOU ARE THE COMPUTATION
18:06:45 <fragamus> me niether
18:07:01 <fragamus> neither
18:07:47 <darthdeus> what does "Orphan instance: instance Eq ParseError" mean?
18:08:14 <fragamus> I need a good tutorial on Cont
18:08:40 <dibblego> darthdeus: the instance declaration is not in the same module as Eq, nor ParseError
18:10:53 <Skyler> yo
18:12:16 <darthdeus> dibblego: thanks
18:13:27 <wyager> Would anyone care to critique the draft of my blog post comparing Go to Rust and Haskell?
18:13:48 <heatsink> ok
18:13:49 <darthdeus> wyager: totally :)
18:14:00 <wyager> Can I email you guys? It’s in RTF right now
18:15:11 <oisin640> wyager: I'm not very experienced with the other two, but I wouldn't mind.
18:15:33 <darthdeus> can I somehow chain  :r and :main into a single command in ghci?
18:15:44 <darthdeus> :r; :main doesn't work
18:16:17 <wyager> Alright, sent. Thanks guys
18:17:16 <darthdeus> wyager: also, what's the url of your blog?
18:17:21 <wyager> yager.io
18:17:31 <wyager> But the draft isn’t up yet
18:17:37 <wyager> I write it in rtf first and then convert it to html
18:19:41 <kadoban> darthdeus: Look at :def and :script maybe?
18:20:09 <kadoban> darthdeus: Should be able to just throw :r <newline> :main in a file and then define a command that runs the script
18:20:30 <darthdeus> hmm, didn't know ghci supported these
18:20:34 <darthdeus> interesting
18:21:19 <wyager> Oh, guys, I had a question. So when I do :info (->), it tells me that (->) is a data constructor (presumably for the type of a function?), but when I do :t (->) it gives me a parse error. What gives?
18:22:29 <kadoban> wyager: I don't think (->) has an actual type, it's more syntax than an actual operator or anything, iiuc.
18:22:38 <bstrie> wyager: having read your blog post, as just a completely editorial change, I would make the title less inflammatory
18:22:53 <bstrie> it distracts from the technical arguments
18:23:01 * hackagebot music-dynamics-literal 1.7 - Overloaded dynamics literals.  http://hackage.haskell.org/package/music-dynamics-literal-1.7 (HansHoglund)
18:23:03 * hackagebot music-pitch-literal 1.7 - Overloaded pitch literals.  http://hackage.haskell.org/package/music-pitch-literal-1.7 (HansHoglund)
18:23:05 * hackagebot abcnotation 1.7 - Haskell representation and parser for ABC notation.  http://hackage.haskell.org/package/abcnotation-1.7 (HansHoglund)
18:23:07 <wyager> bstrie: I toned it down a lot from “why go sucks"
18:23:07 * hackagebot musicxml2 1.7 - A representation of the MusicXML format.  http://hackage.haskell.org/package/musicxml2-1.7 (HansHoglund)
18:23:09 * hackagebot lilypond 1.7 - Bindings to Lilypond  http://hackage.haskell.org/package/lilypond-1.7 (HansHoglund)
18:23:24 <monochrom> I disbelieve that ghci says that (->) is a data constructor
18:23:25 <dibblego> wyager: (->) is a type constructor
18:23:31 <bstrie> wyager: if you have an updated version, I would be happy to read it
18:23:35 <bergey> wyager: :k (->)
18:23:35 <bergey> (->) :: * -> * -> *
18:23:56 <wyager> Gotcha. So it doesn’t have a type
18:24:02 <dibblego> it has a kind
18:24:03 <rwbarton> just like Maybe doesn't have a type
18:24:27 <wyager> bstrie: When did you read it? Like two days ago? It hasn’t changed so much since then. Mostly just wording and stuff.
18:24:53 <bstrie> wyager: yeah, two days ago or so
18:25:00 <wyager> OK, cool. Yeah, you’re mostly up to date
18:25:10 <wyager> I want to keep the semi-inflammatory title for two reasons
18:25:30 <wyager> 1: I want people who like Go to read it. They won’t if they’re not angry
18:25:45 <wyager> 2: I don’t want to make it seem like I’m happy with Go and these are just some minor complaints
18:25:50 <dibblego> Go does not "suck" — it's just not useful
18:25:58 <wyager> Really? I’d say the opposite
18:26:02 <wyager> it’s useful, but it sucks
18:26:03 <stephenmac7_> Never tried Go myself.
18:26:07 <stephenmac7_> The game's fun though :D
18:26:27 <bstrie> wyager: well as the main moderator of the rust subreddit, if the submitted title is too inflammatory I'll remove it, since I'm not interested in triggering flame wars :)
18:26:31 <stephenmac7_> The programming language looks slightly interesting
18:26:54 <wyager> bstrie: Can I submit it with a bowdlerized title, but link to the inflammatory article? :D
18:27:03 <bstrie> wyager: sure
18:27:35 <wyager> Alright, cool. Also, I tried to have a lot of disclaimers and stuff so no one would get too angry. I threw Go quite a few bones
18:28:11 * hackagebot music-score 1.7 - Musical score and part representation.  http://hackage.haskell.org/package/music-score-1.7 (HansHoglund)
18:28:12 <monochrom> I know how to submit one title that links to a totally different title
18:28:13 * hackagebot music-pitch 1.7 - Abstract representation of musical pitch.  http://hackage.haskell.org/package/music-pitch-1.7 (HansHoglund)
18:28:15 * hackagebot music-dynamics 1.7 - Abstract representation of musical dynamics.  http://hackage.haskell.org/package/music-dynamics-1.7 (HansHoglund)
18:28:17 * hackagebot music-articulation 1.7 - Abstract representation of musical articulation.  http://hackage.haskell.org/package/music-articulation-1.7 (HansHoglund)
18:28:19 * hackagebot music-parts 1.7 - To be written.  http://hackage.haskell.org/package/music-parts-1.7 (HansHoglund)
18:29:08 <monochrom> http://www.amazon.com/Advanced-Go-Programming/dp/1593272839/
18:29:24 <darthdeus> monochrom: lol
18:29:37 <wyager> Haha
18:29:56 <wyager> Trolling opportunity
18:30:09 <akurilin> heatsink: ok. I think I figured out how ot use a let and still use guards in my function
18:30:20 <akurilin> discovered "where" apparently
18:32:45 <heatsink> wyager, what did you do using Go?
18:32:59 <wyager> My website, and a few web service projects
18:33:21 * hackagebot music-preludes 1.7 - Some useful preludes for the Music Suite.  http://hackage.haskell.org/package/music-preludes-1.7 (HansHoglund)
18:33:23 * hackagebot music-graphics 1.7 - Diagrams-based visualization of musical data structures.  http://hackage.haskell.org/package/music-graphics-1.7 (HansHoglund)
18:33:25 * hackagebot music-sibelius 1.7 - To be written.  http://hackage.haskell.org/package/music-sibelius-1.7 (HansHoglund)
18:33:26 <heatsink> ok
18:33:27 <darthdeus> wyager: just finished the article, can't wait till you publish it so that I can send it to all my Go friends :P
18:33:52 <monochrom> @hoogle (<$>)
18:33:53 <lambdabot> Data.Functor (<$>) :: Functor f => (a -> b) -> f a -> f b
18:33:53 <lambdabot> Control.Applicative (<$>) :: Functor f => (a -> b) -> f a -> f b
18:36:14 <wyager> darthdeus: Thanks. Hopefully it sways a few of them :)
18:36:40 <wyager> I’ll probably throw it up over the weekend
18:36:42 <heatsink> It took me a little while to figure out what you meant about control flow structures
18:37:06 <wyager> Yeah, that part was a bit hard to word. Remember, I’m trying to explain this to people who come from languages with very simple control flow
18:37:07 <heatsink> since it's really about allowing conditional execution to "return" a value instead of just assigning variables
18:37:15 <wyager> Right
18:38:03 <stephenmac7_> any way to simplify (\acc x -> x acc) ?
18:38:19 <heatsink> @unpl flip ($)
18:38:20 <lambdabot> (\ b c -> c b)
18:38:20 <dibblego> stephenmac7_: (&)
18:38:25 <dibblego> @type (&)
18:38:26 <lambdabot> a -> (a -> b) -> b
18:38:52 <wyager> heatsink: I like that wording though. I’ll use the word “return”
18:39:20 <stephenmac7_> dibblego: Where does and come from?
18:39:25 <stephenmac7_> *&
18:39:26 <dibblego> Control.Lens
18:40:45 <stephenmac7_> dibblego: That's quite a big package.
18:41:03 <dibblego> I didn't know there were any more haskell projects not using it
18:41:58 <wyager> Is & used for evaluating left-to-right? I wondered why there wasn’t a built-in operator like that
18:42:15 <wyager> Like (flip $)
18:42:29 <wyager> err, (flip ($))
18:42:47 <fread2282> @src (&)
18:42:47 <lambdabot> Source not found. I can't hear you -- I'm using the scrambler.
18:43:47 <benzrf> :t flip id
18:43:49 <lambdabot> b -> (b -> c) -> c
18:43:49 <fread2282> wyager: it's in control.lens for the (structure & lens .~ value) pattern, but it can be used for left-to-right function composition
18:44:06 <benzrf> fread2282: i believe you mean application :v
18:44:13 <benzrf> it isnt compose
18:44:24 <benzrf> so whats the point of arrows anyway
18:44:31 <benzrf> in what way do they encompass monads
18:45:13 <anon_555> What is the difference between print and putStr
18:45:35 <benzrf> anon_555: print = putStrLn . show
18:45:40 <fread2282> anon_555: print calls show
18:45:42 <benzrf> :t putStrLn
18:45:43 <lambdabot> String -> IO ()
18:45:44 <benzrf> :t print
18:45:44 <lambdabot> Show a => a -> IO ()
18:45:48 <zwer> @src print
18:45:49 <lambdabot> print x = putStrLn (show x)
18:45:55 <glguy_> ?. Djinn type (&)
18:45:55 <glguy_> Wasn't there a command for compose?
18:45:56 <lambdabot> Plugin `compose' failed with: Unknown command: "Djinn"
18:46:16 <glguy_> ?@ Djinn type (&)
18:46:16 <lambdabot>  Djinn type (&)
18:46:19 <fread2282> > print "foo"
18:46:20 <monochrom> "x -> M y" is Kleisli arrow "A x y".
18:46:20 <lambdabot>  <IO ()>
18:46:26 <fread2282> > putStrLn "foo"
18:46:27 <lambdabot>  <IO ()>
18:46:29 <benzrf> :t (&)
18:46:29 <anon_555> ok then when to use print and putStr
18:46:30 <lambdabot> a -> (a -> b) -> b
18:46:38 <benzrf> monochrom: o
18:46:53 <fread2282> > "foo"
18:46:54 <benzrf> monochrom: so Kleisli is an instance of Arrow
18:46:55 <lambdabot>  "foo"
18:47:01 <monochrom> yes
18:47:08 <benzrf> what do arrows give you that monads dont then
18:47:14 <fread2282> > unsafePerformIO $ putStrLn "foo"
18:47:16 <lambdabot>  Not in scope: ‘unsafePerformIO’
18:47:20 <fread2282> > unsafePreformIO $ putStrLn "foo"
18:47:21 <lambdabot>  Not in scope: ‘unsafePreformIO’
18:47:26 <benzrf> @djinn a -> (a -> b) -> b
18:47:26 <lambdabot> f a b = b a
18:47:31 <benzrf> fab
18:47:33 <fread2282> @print "foo"
18:47:33 <lambdabot> Not enough privileges
18:47:38 <benzrf> fread2282: lambdabot is 3safe5u
18:47:56 <fread2282> > show "foo"
18:47:58 <lambdabot>  "\"foo\""
18:47:58 <fread2282> vs
18:48:02 <fread2282> > "foo"
18:48:03 <lambdabot>  "foo"
18:48:09 <pavonia> @@ @djinn @type (&)  -- glguy_
18:48:11 <lambdabot>  f a b = b a
18:48:25 <benzrf> @@
18:48:29 <benzrf> oic
18:48:32 <benzrf> neato
18:48:40 <benzrf> @eval
18:48:44 <benzrf> @eval 3
18:48:55 <anon_555> can anyone debug this code http://lpaste.net/105104
18:49:15 <monochrom> arrow composition has type "A y z -> A x y -> A x z". note that both arguments have type "A ? ?". "A" is your type, you write its definition, you have full control over it. this means you can examine it as data during run time, if you write it as plain data.
18:49:28 <pavonia> anon_555: What are a and b?
18:49:48 <anon_555> parameter and actually i am very new to functional programming
18:49:50 <anon_555> :)
18:49:52 <benzrf> pavonia: number 1
18:49:53 <monochrom> monad composition has type "M a -> (a -> M b) -> M b". note the argument type "a -> M b". it means arbitrary function that you cannot examine.
18:50:01 <wyager> (Re. what monochrom said: Compare arrow composition to function composition)
18:50:01 <benzrf> * anon_555 number 1 problem
18:50:06 <benzrf> anon_555: a and b are not defined :I
18:50:10 <benzrf> anon_555: number 2 problem
18:50:12 <heatsink> wyager, the explanation of why you should care about type inference, immutability, and control flow structures is somewhat weak.  People who use Haskell or Rust will understand, but I don't think the explanation fits with how Go or C++ users think about programs.
18:50:12 <fread2282> anon_555: use print only for debugging
18:50:16 <benzrf> you're applying print to add
18:50:24 <fread2282> use putStrLn for other console output
18:50:31 <benzrf> anon_555: what languages do you already know?
18:50:35 <monochrom> arrow weakens a user power to strengthen an implementer power
18:50:45 <anon_555> python, ruby, c / c++ and java
18:50:46 <wyager> heatsink: OK, interesting. How do you think I should convince them that they’re cool/useful?
18:50:51 <benzrf> monochrom: oic
18:50:55 <benzrf> monochrom: interesting
18:51:05 <monochrom> you can, in fact, say the same of Applicative. many Arrow applications are also good Applicative applications.
18:51:07 <benzrf> isn't this a feature of Category and not arrow?
18:51:27 <monochrom> yes too. but Arrow adds you &&& etc
18:51:44 <benzrf> so why do people around here seem to hate arrow
18:52:03 <monochrom> it doesn't sit at a sweet spot
18:52:10 <benzrf> mm
18:52:24 <monochrom> Applicative ends up sitting at a sweeter spot
18:52:40 <heatsink> wyager: It's hard to get people thinking in this way.  I think copumpkin's recent tweet is relevant.
18:52:53 <heatsink> "I don't want "more features" / "more power". I want more composable features and a principled model of your system, that I can reason about."
18:53:05 * hackagebot music-suite 1.7.0.1 - A set of libraries for composition, analysis and manipulation of music.  http://hackage.haskell.org/package/music-suite-1.7.0.1 (HansHoglund)
18:53:49 <monochrom> Cale will also tell you from experience how the provision "arr :: (x -> y) -> A x y" prevents optimizations and also weakens your implementer's power in examining your own A type as data.
18:54:05 <benzrf> hmm
18:54:20 <benzrf> arr looks to be vaguely equivalent of return
18:54:21 <benzrf> *to
18:54:28 <monochrom> yes
18:54:29 <anon_555> benzrf can you help me
18:54:39 <benzrf> anon_555: sure!
18:54:49 <anon_555> benzrf, thank you
18:54:50 <benzrf> anon_555: do you know about currying?
18:55:22 <wyager> heatsink: Well I guess we’ll have to hope some of the examples punch through.
18:55:39 <hoverbear> benzrf: I had some great chicken curry this weekend.
18:55:44 <benzrf> hoverbear: :^)
18:55:54 <heatsink> wyager: Mentally simulating code to figure out what it does is hard, but that's the default mindset for some programmers.  The benefit of immutability and control flow structures is that you don't have to simulate it.  You can just examine the relevant piece of the code.
18:56:06 <anon_555> benzrf yes little bit in maths
18:56:10 <benzrf> anon_555: ok
18:56:16 <benzrf> in haskell all functions are curried
18:56:23 <benzrf> therefore, function application is left-associative
18:56:26 <benzrf> meaning that
18:56:33 <benzrf> print add a b
18:56:34 <benzrf> is actually
18:56:40 <benzrf> ((print add) a) b
18:56:47 <fuzzyhorns> http://www.infoq.com/presentations/functional-pros-cons
18:56:52 <benzrf> and 'print add' won't work
18:56:53 <fuzzyhorns> any thoughts on this lecture ? ^
18:57:02 <benzrf> anon_555: you probably want `print (add a b)'
18:57:09 <benzrf> anon_555: also, you need to pass values to add
18:57:28 <benzrf> anon_555: right now you're passing along the values of some variables, but those variables are not bound in scope
18:57:33 <heatsink> wyager: For control flow structures: I'd compare expressions like {BIG_BLOCK_OF_CODE; temperature = x; BIG_BLOCK_OF_CODE; pressure = y;}
18:57:38 <BananaNipples> is haskell used much in the industry? it doesnt seem like there are many jobs for it. why is it one of the biggest channels on freenode. (serious question, not trying to troll)
18:57:52 <heatsink> wyager: with let (temperature, pressure) = BIG_BLOCK_OF_CODE in ...
18:58:10 <benzrf> BananaNipples: because it's awesome!
18:58:11 <benzrf> \o/
18:58:20 <heatsink> wyager: In the latter case, it's easy to see what the block of code is about.  In the former, you have to search the whole thing to see what its output is.
18:58:22 <wyager> BananaNipples: Particle physics isn’t used much in industry, but it’s still f*cking sweet
18:58:25 <benzrf> BananaNipples: also, it's popular for academics
18:58:31 <benzrf> BananaNipples: and hobby programming
18:58:40 <BananaNipples> any advantages over say C?
18:58:42 <benzrf> and i'm told that some companies use it for internal systems
18:58:47 <wyager> BananaNipples: It’s all relative
18:58:51 <wyager> It depends what you’re doing
18:58:53 <benzrf> BananaNipples: that's like saying advantages of bikes vs riding the train
18:58:56 <benzrf> it's not really comparable
18:59:06 <benzrf> it really depends on the context
18:59:18 <monochrom> haskell is higher-level than c
18:59:24 <BananaNipples> what type of programming is it good for?
18:59:42 <BananaNipples> i see you mentioned academic and hobby but what part of those specifically?
18:59:47 <saml_> what are different types of programming are there BananaNipples ?
18:59:47 <fuzzyhorns> does haskell allow you to do user-defined control structures?
18:59:53 <saml_> there are*
18:59:57 <geekosaur> sort of
19:00:08 <wyager> Haskell is really nice for writing correct programs
19:00:22 <wyager> It’s really easy to write a wrong program in C
19:00:23 <geekosaur> laziness means that a lot of things that would require control structures in strict languages can be written as normal functions
19:00:25 <wyager> it’s a lot harder in haskell
19:00:28 <heatsink> wyager: Does it make sense what my sketchy example is trying to convey?
19:00:29 <monochrom> haskell is much less prone to buffer overrun than c
19:00:52 <wyager> heatsink: Yes. I’m trying to decide if I want to put code like that in the example. I’m worried about scaring people off
19:01:02 <wyager> I kind of wanted to go with “look how short and simple this is!"
19:01:06 <monochrom> haskell has richer and better type checking
19:01:20 <stephenmac7_> dibblego: Never heard of Control.Lens
19:01:34 <monochrom> haskell takes the Leibniz subtitution principle seriously
19:01:36 <anon_555> Can anyone explain me the recursion in Haskell http://lpaste.net/105105 how it works without return
19:01:46 <heatsink> arite
19:02:02 <monochrom> "down for maintenance!"
19:02:28 <geekosaur> anon_555, everything in haskell is an expression; imperative return is not needed
19:02:28 <monochrom> alright, I can see it now
19:02:29 <saml_> anon_555, you don't need to return in haskell.
19:02:37 <geekosaur> the `return` in haskell is actually something different
19:02:39 <glguy> anon_555: return doesn't work in Haskell like it does in other languages. It's not a control statement. But the reason your example works is that if_then_else_ takes a boolean and returns the corresponding expression
19:02:44 <monochrom> "xs" already returns xs
19:03:24 <wyager> anon_555: If statements in Haskell are like functions in other languages. They can actually “return” a value
19:03:29 <anon_555> how does this else calling myDrop will work
19:03:55 <zwer> > if True then "yes" else "no"
19:03:57 <lambdabot>  "yes"
19:04:12 <monochrom> myDrop 5 [a,b,c] becomes myDrop (5-1) [b,c]
19:04:34 <monochrom> becomes myDrop (5-1-1) [c]. etc
19:04:52 <monochrom> to a large extent, you can simply say "equal"
19:05:12 <fuzzyhorns> how do you debug haskell?
19:05:16 <monochrom> myDrop 5 [a,b,c] equals myDrop 4 [b,c] equals myDrop 3 [c].
19:05:31 <wyager> fuzzyhorns: You usually don’t need to
19:05:46 <wyager> The type system catches 99.9% of errors in my experience
19:05:46 <fuzzyhorns> wyager: this lecture dude is saying that is hogwash
19:05:51 <wyager> It’s kind of crazy actually
19:05:51 <fuzzyhorns> wyager: http://www.infoq.com/presentations/functional-pros-cons
19:05:52 <anon_555> and there is nor print statement when does it print the result
19:05:57 <fuzzyhorns> i am curious what yall think of it
19:06:29 <monochrom> the REPL prints the result. or use IO to print it. read my http://www.vex.net/~trebla/haskell/IO.xhtml
19:06:32 <wyager> fuzzyhorns: I haven’t seen the lecture, but my personal opinion is that Haskell’s strong type system almost completely eliminates bugs. If a program compiles and I didn’t do anything really stupid, it probably works perfectly
19:07:08 <fuzzyhorns> wyager: so there is no occasion for debugging?
19:07:10 <wyager> >Gilad Bracha is the creator of the Newspeak programming language and a software engineer at Google where he works on Dart.
19:07:13 <wyager> Not exactly unbiased
19:07:20 <saml_> is there a language like haskell or ml but with manual memory management?
19:07:29 <glguy> More realistically, you rely on the type checker to catch the basic stuff and then you try to structure your functions so that you can call them independently and test them out or write properties that they should satisfy
19:07:29 <benzrf> saml_: that would be so dumb
19:07:31 <fuzzyhorns> wyager: of course not, and def not an academic
19:07:33 <wyager> fuzzyhorns: I have never needed a debugger, and I’ve build pretty significant backend software in haskell
19:07:41 <monochrom> I write my program as the composition of small functions so that each one is informative to test. I use Debug.Trace sometimes as well.
19:07:48 <saml_> hrm maybe ATS
19:07:54 <geekosaur> you can do manual memory management in haskell, and sometimes must do so for FFI stuff
19:07:59 <heatsink> saml_: ATS is sort of a hybrid of C and Dependent ML
19:08:09 <fuzzyhorns> that makes sense to me
19:08:15 <fuzzyhorns> I think the dude is being a bit of a hater heh
19:08:19 <anon_555> monochrom  and there is no print statement when does it print the result
19:08:20 <saml_> oh, Rust
19:08:30 <geekosaur> as for debugging, a typical debugger is not very useful, especially given how control flow works
19:08:37 <monochrom> the REPL has implicit print statements inside. it's a REPL.
19:08:42 <wyager> Rust is nice. It has a really nice hindley milner type system like haskell
19:08:51 <glguy> It put the P in REPL
19:08:56 <wyager> ATS sounds cool. I want to play with dependent types a bit
19:09:08 <benzrf> monochrom: have you tried my new abominatino
19:09:11 <benzrf> *abomination
19:09:19 <geekosaur> however we have our equivalent of printf debugging (Debug.Trace module) and for xmonad debugging I have written various helper modules that do logging
19:09:20 <monochrom> no, what is your new abomination?
19:09:21 <fuzzyhorns> this dude is dragging hindley-milner through the coals now
19:09:26 <kazagistar> what cases does referecne counting fail in haskell?
19:09:46 <benzrf> monochrom: something along the lines of this http://imgur.com/a/BGBtg
19:09:49 <wyager> Does there exist a language that has the memory management level of C (or even more precise) but a very rigorous dependent type system? That’s what I’d want airplane software to be written in
19:09:49 <monochrom> "x = 0 : x" defeats reference counting
19:09:52 <saml_> any recursive data.. [a]
19:10:01 <geekosaur> there is some evaluation tracing capability in ghci, althugh laziness can confound you a bit with it: it steps reductions, not instructions
19:10:03 <wyager> monochrom: How?
19:10:15 <wyager> Isn’t that a valid way to repeat a thing into an infinite list?
19:10:36 <glguy> Just so everyone's on the same page, GHC doesn't use reference counting for memory management
19:10:37 <geekosaur> what is x's reference count?
19:10:37 <kazagistar> airplanes are super reliable anyways, much more likely to die driving to work then on a plane
19:10:55 <wyager> kazagistar: OK, space shuttle then :)
19:10:57 <geekosaur> kazagistar, only until we have flying cars :p
19:11:13 <monochrom> wyager, it is a valid infinite list, and it defeats reference counting. is there a contradiction?
19:11:16 <geekosaur> (just what we needed, flying car drag racing)
19:11:37 <kazagistar> yeah, I know reference counting is not in haskell, I am just curious in what cases reference counting would be insufficient for a language like haskell?
19:11:39 <wyager> monochrom: What do you mean “defeats”? Also, HS is garbage collected, so where is the reference counting?
19:12:01 <monochrom> "defeats X" means "forces X to give the wrong answer"
19:12:19 <wyager> But there’s no GC system to give the wrong answer…(?)
19:12:26 <wyager> *refcount system
19:12:51 <glguy> wyager: monochrom is answering's kazagistar question about how would reference counting not work out
19:12:53 <rwbarton> does ByteString not have a fusion framework?
19:12:54 <monochrom> I hate the "*xxx" correction form. it's ambiguous. what do I replace "xxx" by?
19:13:13 <wyager> s/GC/refcount/g
19:13:18 <heatsink> fuzzyhorns: The only complaints I see in his slides are about the absence of stack traces and counterintuitive type errors
19:13:31 <monochrom> refcount gives the wrong answer by definition of refcount
19:13:38 <fuzzyhorns> heatsink: he goes further
19:13:51 <monochrom> the wrong answer being "still in use, do not free"
19:14:14 <oisin640> Is it terrible to have something at the bottom of my pattern matches like: fn _ _ = error "...Some semi-helpful error message."  Should I realistcally be catching all of the patterns?
19:14:37 <benzrf> oisin640: why *wouldnt* you match em all
19:14:42 <kazagistar> monochrom: OK, I see, if we dumped recursive data structures, strongly referenced, then refcount would be sufficient, but that would be silly
19:14:43 <fuzzyhorns> he says pattern matching "allows fpls to pretend they dont do dynamic typechecks and casts"
19:15:17 <oisin640> benzrf: http://lpaste.net/105106  I would have to match a few different ugly constructors
19:15:35 <monochrom> I agree that pattern matching corresponds to dynamic checks. I disagree that it corresponds to casts.
19:15:36 <anon_555> so what is the error now in http://lpaste.net/105107
19:15:56 <monochrom> I only agree that casts appear as an implementation technique.
19:16:23 <rwbarton> oisin640: the only reason to do that would be to shut up incomplete pattern match warnings
19:16:27 <saml_> anon_555, main = print (add a b)
19:16:33 <rwbarton> you will get a semi-helpful error message by default anyways when no equation matches
19:16:42 <monochrom> but must I worry about how dirty an implementation technique is?
19:16:47 <glguy> anon_555: show :: Show a => a -> String, but main should have type: IO ()
19:16:54 <benzrf> monochrom: did you examine my link
19:16:58 <oisin640> rwbarton: Is it possible to just relay the compiler's message and still shut up the warnings?
19:17:10 <rwbarton> good question
19:17:16 <pqmodn> oh no, gilad bracha
19:17:16 <anon_555> how to change add a b to string
19:17:23 <jmcarthur> i could see how one might construe pattern matching as casting. the tag tells you which view of the union to assume. but yeah, this is a very implementation-focused argument and really misses the point.
19:17:25 <rwbarton> I don't think so
19:17:48 <oisin640> Ah, ok
19:18:21 <monochrom> benzrf: is it necessary to runhaskell the thing first?
19:18:26 <benzrf> hmmm?
19:18:33 <benzrf> yes, notice i'm loading Wtf and not Demo
19:18:51 <benzrf> monochrom: i put what is basically a marginally cleaned-up version on hackage :>
19:18:55 <monochrom> is step 2 necessary? does it generate files that later steps read?
19:19:01 <benzrf> monochrom: yeah
19:19:05 <monochrom> I see
19:19:06 <anon_555> now guys can you shoe me the basic skeleton of haskell programm
19:19:06 <benzrf> monochrom: yeah10:16 < benzrf> yes, notice i'm loading Wtf and not Demo
19:19:08 <benzrf> oops
19:19:16 <benzrf> also, the implementation is eviller than the average vampire
19:19:25 <benzrf> don't try it on anything significant if you value your computer's life
19:19:29 <benzrf> (or so i assume)
19:19:39 <monochrom> my error correcting modem replaced Wtf by Demo. don't worry about that part
19:19:44 <benzrf> hah
19:19:52 <benzrf> monochrom: try eet o3o
19:20:52 <benzrf> cabal install vampire >> vampire Code.hs >> ghci >> :l CodeVampired >> import Debug.Vampire >> viewExpr (\_ -> expr)
19:21:02 <monochrom> this is unspeakable evil
19:21:05 <benzrf> :)
19:21:25 <benzrf> * u need an ImplicitParams pragma in Code.hs as well as an import Debug.Vampire.Trace
19:21:32 <benzrf> monochrom: im gonna fix it ITF to auto-insert those
19:21:46 <monochrom> I suppose I am preaching to the choir when I critique "pattern matching is casting" here
19:21:51 <benzrf> as well as set up some way of selectively picking bits to rewrite
19:23:27 <fuzzyhorns> his stuff on Monads at 30 is kinda good though heh
19:24:03 <dwcook> anon_555: here is a minimal, complete, non-exception-raising Haskell program: main = return ()
19:24:53 <dwcook> anon_555: You can't just have show for main, since main's type must be IO a or something unifying with that.
19:24:59 <dwcook> anon_555: Try replacing show with print.
19:25:17 <dwcook> print = putStrLn . show
19:26:15 <monochrom> "main = print (add a b)" works great.
19:26:33 <heatsink> He rediscovered the monads-as-lists analogy, how wonderful.
19:27:11 <kazagistar> fuzzyhorns: a lot of his complaints (as far as I have gotten) are firing towards the strict and impure functional languages, things with closures and mutability and eager evaluation and whatnot
19:27:35 <fuzzyhorns> kazagistar: really? i havent gotten that at all i guess
19:28:13 <dwcook> heatsink: is that an analogy people actually use? Seems misleading to me given that the free _monoid_ is the list, whereas the free monad is something else.
19:29:05 <Welkin> why use analogies?
19:29:18 <monochrom> "monad-as-list" is just an instance of "monad-as-container". list is just an easy target
19:29:19 <Welkin> just read this: https://en.wikibooks.org/wiki/Haskell/Category_theory#Monads
19:29:38 <dwcook> Welkin: not even. Just read the Monad class definition and the associated laws.
19:30:09 <monochrom> people feel insecure without analogies
19:30:36 <kazagistar> fuzzyhorns: im only at 13 min, but he complained how it is ill defined cause "oop has closures and fp languages have effects", and mentioned how square bracket lambdas are cool for when you dont have params (when in haskell, you dont even need the brackets, etc
19:30:58 <heatsink> dwcook: I'm going by the slides, where he explains monads in terms of flatMap
19:31:14 <fuzzyhorns> kazagistar: some of it seems like haterade to me
19:33:28 <fuzzyhorns> what does "scalar operators extended pointwise to collections mean"?
19:33:33 <fuzzyhorns> idk what pointwise means in this context
19:33:57 <pqmodn> guessing, he means element-wise
19:36:55 <kazagistar> fuzzyhorns: its true that "if it typechecks it works" is over the top. What people usually mean is "if it is carefully engineered with small, well typed modules, and it typechecks, it works more often then other languages"
19:37:12 <fuzzyhorns> kazagistar: yeah i would think so too
19:39:47 <sveit> do I need to keep a direct reference to a foreignptr for the memory to remain un-collected, or can I create some other object that references that data to prevent it from being freed? in my case i want to use unsafeFromForeignPtr0 from the data vector library
19:39:49 <kazagistar> fuzzyhorns: he seems to go after the strawman "HM means you dont have to write types" really hard (which few advocate, normal practice has lots of type signatures to verify your thinking), but I am not sure, its really confusing
19:40:18 <fuzzyhorns> kazagistar: tbh i really dont get his HM section
19:40:25 <fuzzyhorns> kazagistar: it seems contradictory to me
19:41:09 <kazagistar> fuzzyhorns: "relying on a type system is not a good thing, but that is a subject for another talk"... zzz
19:41:16 <monochrom> sveit: I think any direct or indirect reference will do
19:41:39 <fuzzyhorns> kazagistar: yeah i really wish he had even vaguely substantiated that :P
19:42:10 <benzrf> hmmmmm i just realized
19:42:19 <sveit> monochrom: ok, thanks. is there some proof in the documentation? :)
19:42:23 <rwbarton> the ForeignPtr needs to be "live" according to the Haskell GC
19:42:27 <benzrf> @undo do foo <- bar; baz <- quux; quuux
19:42:28 <lambdabot> bar >>= \ foo -> quux >>= \ baz -> quuux
19:42:32 <benzrf> hmmmm
19:42:49 <benzrf> foo >>= (\bar -> baz >>= quux)
19:42:57 <benzrf> foo >>= (\bar -> baz) >>= quux
19:43:00 <benzrf> ^same, right?
19:44:38 <sveit> rwbarton: what does that mean?
19:46:08 <rwbarton> well, when the GC detects that the ForeignPtr is no longer referenced, then it will run the attached finalizer, freeing the underlying resource
19:47:18 <sveit> rwbarton: but what does "referenced" mean? does that mean the pointer itself or the data it points /to/?
19:47:30 <rwbarton> the ForeignPtr itself
19:47:34 <kazagistar> fuzzyhorns: "first class patterns are missing in haskell"~ "waaa my pet feature is missing from a 20 year old programming language, all FP is flawed!"
19:47:49 <rwbarton> unsafeFromForeignPtr0 will produce a Vector that points at the ForeignPtr
19:47:54 <rwbarton> so all is well
19:48:06 <rwbarton> the data it points to isn't managed on the Haskell heap at all
19:48:19 <rwbarton> so the GC has no idea whether somebody has other pointers to that
19:49:01 <sveit> rwbarton: i see, so internally the vector just keeps a reference to the foreign pointer itself? is there a way i could have found this out without either reading the source or getting advice from you? :)
19:49:22 <oisin640> If I write something like: mmult :: Num e => Matrix r c e -> Matrix c r e -> Matrix r r e, is there any form of type safety given the fact that I've used the same variable name (r and c)?
19:49:41 <rwbarton> well, I read the source
19:49:45 <rwbarton> unsafeFromForeignPtr0 fp n = MVector n fp
19:52:03 <sveit> ah i see. on a (somewhat) related note, is the best way to learn about the ST monad from the original 1994 paper, or are there canonical resources/tutorials?
19:52:09 <fuzzyhorns> kazagistar: idk, i thought he was just saying pattern matching is held up to be a great thing in haskell (which strangely it does seem to be hyped up) when its not orthogonally implemented
19:53:18 <fuzzyhorns> kazagistar: "his point about pattern matching is that people hide holes in their types there with incomplete pattern matches, and effectively deferring type errors to run-time. He even mentions that OCaml solves this with the exhaustive pattern matching check." seems a fair point
19:55:02 <fuzzyhorns> kazagistar: unless haskel actually does exhaustive pattern matching check, idk offhand
19:56:06 <kazagistar> fuzzyhorns: haskell makes it a warning, which seems fine, since often you know better, and you would only have the last pattern matches be errors anyways, which they are by default
19:56:31 <fuzzyhorns> gotcha so he was just wrong on that then
19:57:07 <monochrom> first-class patterns are coming to GHC
19:57:36 <monochrom> first-class x-men were two years ago or something :)
19:58:00 <fuzzyhorns> monochrom: xD
20:00:20 <kazagistar> fuzzyhorns: his dart type signature is not conveying any information about monads, probably cause dart's type system is too limited to express it.. and then he complains that the signature does not express enough
20:01:02 <fuzzyhorns> http://www.newspeaklanguage.org/ his language
20:05:43 <zzing> Does anyone have any experience with ghcjs-boot --init on the mac? I am attempting to run it, but when it tries to run git it claims there is an empty file path.   (output: https://gist.github.com/iaefai/bd1eacfbf50b75a24d3a )   I tried doing some of it manually, but I don't know everything that it does.
20:08:35 <ReinH> monochrom: first-class patterns?
20:08:52 <monochrom> I don't know details
20:09:18 <ReinH> monochrom: well, are they first-class?
20:09:35 <monochrom> I guess I am not sure either
20:09:39 <glguy> Are you talking about these? http://www.haskell.org/ghc/docs/latest/html/users_guide/syntax-extns.html#pattern-synonyms
20:10:10 <monochrom> yes
20:10:49 <ReinH> monochrom, glguy: oh neat
20:15:33 <rwbarton> they aren't exactly first-class I'd say
20:15:59 <kazagistar> fuzzyhorns: I think he is right that there is too little interest in tooling, and the untouched potential there, especially with stuff like Arbitrary that gives you a lot of cool options for live programming
20:18:42 <dibblego> that talk is one of the most misleading of the year
20:19:24 <benzrf> dibblego: which talk?
20:19:41 <dibblego> Gilad Bracha pretending to know what functional programming is, among other things.
20:19:49 <heatsink> The slides http://www.slideshare.net/InfoQ/deconstructing-functional-programming
20:19:49 <pqmodn> http://www.infoq.com/presentations/functional-pros-cons
20:19:59 <pqmodn> oh, another one?
20:20:26 <pqmodn> nm, same talk
20:20:46 <kazagistar> Final statements: "I encourage people to take a sceptical look when people promise..." eh, I took a sceptical look at haskell, and stayed, so I agree with his conclusion as being a positive one :P
20:21:51 <dibblego> It is this fallacy of false compromise, laden with poorly-formed concepts and misinformation about fundamental subjects, which Gilad Bracha is so committed to propagating, that makes my job harder
20:22:35 <monochrom> I encourage people to be sceptical at every video talk
20:22:50 <glguy> I encourage people
20:22:59 <monochrom> actually, to equalize, more sceptical when the video has higher quality
20:23:06 <tnks> did someone bring up this talk in a new thread?
20:23:19 <tnks> or are we just ambling down memory lane?
20:23:47 <monochrom> it is the first time I heard that such a talk exists
20:24:08 <dibblego> tnks and others have discussed it a long time ago
20:24:13 <dibblego> (FYI)
20:24:20 <tnks> December of last year.
20:24:25 <tnks> maybe the wound can heal.
20:24:51 <dibblego> today, at least one individual didn't recognise it was complete bullshit, so maybe not
20:25:28 <benzrf> good night
20:25:37 <benzrf> bye
20:26:13 <ReinH> dibblego: I just read 63 slides and I have no idea where he talks about functional programming
20:26:38 <dibblego> he tries, just before trying to talk about monads, iirc
20:26:43 <dibblego> please don't make me watch it again
20:27:08 <ReinH> His first example of "FP" is... some Smalltalk?
20:27:10 <kazagistar> ReinH: he talks about some kind of strawman FP, which is vaugely related to FP
20:27:18 <dibblego> what kazagistar said ^
20:27:22 <ReinH> Makes sense
20:27:54 <kazagistar> ReinH: he is trying to show how "some objecty languages have FP stuff too, before the term FP was invented, so hah!"
20:28:06 <kazagistar> thats the first... half I think?
20:28:13 <dibblego> oh gawd it's coming back at me
20:28:25 <dibblego> I will leave this discussion, sorry
20:28:31 <kazagistar> feel free
20:28:42 <kazagistar> I find it funny if anything
20:28:43 <ReinH> Wait, he thinks LINQ is "a Monad"? Because of selectMany?
20:29:06 <ReinH> Ok, going to put this back down and pretend I didn't read it.
20:29:09 <tnks> is LINQ not monadic?  I was pretty sure it was.
20:29:20 <tnks> maybe by convention, though.
20:29:34 <dibblego> tnks: LINQ is similar to Scala for-comprehensions, but "LINQ is a monad" is not a true statement.
20:30:05 <dibblego> (and dissimilar to do-notation in that there is no type-class denoting a monad)
20:30:54 <tnks> dibblego: yeah, I understand the distinction, but perhaps his point is less fine; he's clearly /way/ more eggregious in his other comments.
20:30:55 <yogurt_truck> that Gilad Bracha talk is one of the most empty talks I've ever watched. it's just hollow in every sense.
20:31:15 <ReinH> I'm sorry I even started talking about it
20:31:30 <ReinH> let's go back to something more interesting. Anyone have any wet paint I can look at for a while?
20:31:31 <dibblego> tnks: I am just clarifying for you — I am out in terms of Bracha hackery
20:31:47 <tnks> dibblego: no problem, thanks.
20:32:53 <kazagistar> the more I think about that talk and learn about the things he talks about, the less it makes any sense... its like the exact opposite of http://www.infoq.com/presentations/Simple-Made-Easy
20:33:38 <kazagistar> that talk... some things confused me at first, until I thought about them or saw their functional equivalents
20:36:34 <monochrom> I thought FP was invented before even Simula
20:36:49 <monochrom> both name and idea
20:37:20 <monochrom> has anyone asked him "have you heard of Simula?"
20:38:01 <kazagistar> monochrom: the term "Functional Programming"? did it exist pre 1977?
20:38:55 <monochrom> I see, I guess not
20:39:31 <monochrom> then simula was earlier
20:41:25 <kazagistar> its a silly point, and frankly, I dont care much for computer history beyond "that thing which creates the baggage we have to deal with today"
20:41:38 <kazagistar> well, and the ideas that came out of it, on the positive side :P
20:46:43 <d3m1g0d-> one of the main reasons why the quality of developers nowadays is so low
20:48:10 <kazagistar> I meanto say, learning what worked and what didnt is useful, but who got it first is not
21:07:11 <rwbarton> what happens if I send lambdabot an expression that would crash ghci?
21:08:12 <mornfall> rwbarton: depends on how it crashes ghci
21:08:13 <kazagistar> rwbarton: do it?
21:08:15 <rwbarton> will it crash the whole lambdabot process or does it spawn a new process for each expression?
21:09:09 <mornfall> it is fairly well sandboxed, but it's possible that it's not entirely foolproof
21:09:56 <mornfall> rwbarton: http://www.haskell.org/haskellwiki/Safely_running_untrusted_Haskell_code
21:10:05 <kazagistar> if you find a way to crash it, file a bug report :P
21:10:20 <rwbarton> right OK
21:11:05 <mornfall> (it forks, among other things, so it should be safe from most types of crashes)
21:11:25 <rwbarton> oh, then I imagine it's fine
21:11:28 <rwbarton> it's just a segfault
21:16:22 <rwbarton> yeah, it just printed "Terminated"
21:16:42 <roconnor_> I kinda wish Haskell made inexhastive pattern matches an error and forced you to write an error clause yourself if you are going to cheat.
21:16:56 <Maxdamantus> It should say "Failed to terminate"
21:17:03 <dfranke> :pl (\a -> (unL . f) a lc))
21:17:23 <roconnor_> flip (unL . f) lc
21:18:28 <rwbarton> roconnor_: well, you can use -Werror -fwarn-incomplete-patterns
21:18:29 <dfranke> roconnor_: thanks... but I seem to be having bad luck automating this. lambdabot isn't answering me, and 'pointfree' on my system is saying 'TemplateHaskell is not enabled'. Trying to figure out why.
21:18:49 <rwbarton> @pl (\a -> (unL . f) a lc))
21:18:49 <lambdabot> (line 1, column 23):
21:18:49 <lambdabot> unexpected ')'
21:18:49 <lambdabot> expecting variable, "(", operator or end of input
21:18:53 <roconnor_> rwbarton: but I'm worried about *other* people's code. :P
21:18:55 <rwbarton> @pl (\a -> (unL . f) a lc)
21:18:55 <lambdabot> flip unL lc . f
21:20:01 <rwbarton> roconnor_, you can compile their code with -Werror -fwarn-incomplete-patterns :P
21:20:21 <rwbarton> and yes I know what you really mean
21:20:24 <roconnor_> :D
21:28:23 * hackagebot avr-shake 0.0.0.3 - AVR Crosspack actions for shake build systems.  http://hackage.haskell.org/package/avr-shake-0.0.0.3 (JamesCook)
21:30:12 <Aditya> hi
21:35:30 <NemesisD> how would one catch exceptions in a MonadIO
21:36:42 <jozefg> NemesisD: Control.Exception.catch? It lives in IO though.
21:37:09 <jozefg> You can't, exceptions can be thrown from non-IO places but only caught in IO
21:37:23 <ryantrinkle> is there any way to do something about the typechecking in template haskell?
21:37:34 <NemesisD> jozefg: yikes
21:37:53 <NemesisD> exceptions are the pits man. ugh
21:37:55 <jozefg> NemesisD: Why yikes? Personally I just hate exceptions, I'm an Either person myself
21:38:05 <ryantrinkle> i frequently have quasiquoted expressions that fail to typecheck at quasiquote-time even though they're fine as applied
21:38:33 <NemesisD> jozefg: that's exactly what i'm trying to do, apply "try"
21:38:42 <NemesisD> unfortunately every library that does IO seems to prefer throwing
21:38:52 <ryantrinkle> NemesisD: there's also MonadBaseControl and similar typeclasses
21:39:03 <enthropy> ryantrinkle: can you use ghc-7.8?
21:39:09 <ryantrinkle> enthropy: hmmmm
21:39:16 <ryantrinkle> enthropy: possibly; was there a significant change?
21:39:22 <jozefg> NemesisD: The exceptions package makes things slightly more pleasant
21:39:37 <enthropy> ryantrinkle: https://ghc.haskell.org/trac/ghc/wiki/TemplateHaskell/Typed is in ghc-7.8
21:39:49 <NemesisD> exceptions honestly bum me out in haskell. i wish they were never added
21:40:07 <NemesisD> they make writing software in haskell extremely unpleasant
21:40:47 <jozefg> NemesisD: Hm.. well living in IO in general just makes things slightly unpleasant.. What's your specific problem, maybe there's a better way
21:40:55 <ryantrinkle> enthropy: hmm; i'm not sure if that would help
21:40:57 <rwbarton> (http://www.vex.net/~trebla/haskell/exception.xhtml)
21:41:33 <ryantrinkle> enthropy: i'll have to try it out; thanks for the pointer :)
21:42:28 <enthropy> ryantrinkle: oh I see your problem. Stuff like  [| 'a' + 3 |] is accepted in ghc-7.8
21:42:50 <ryantrinkle> enthropy: ok, cool
21:42:59 <ryantrinkle> enthropy: it's weird how it's overly conservative sometimes
21:43:01 <enthropy> [|| 'a' + 3 ||] does type checking and appropriately fails
21:43:09 <NemesisD> jozefg: i've got to do a bunch of gnarley IO stuff: forking, manipulating file descriptors, etc. I'm using a free monad but my IO one lives in MonadIO. i haven't looked at monadbasecontrol. never knew what it did
21:44:11 * enthropy probably has had times where type checking in [| |] has caught mistakes
21:44:18 <enthropy> but usually it was just a pain
21:44:34 <enthropy> to rewrite stuff in terms of things like lamE caseE etc.
21:47:34 <NemesisD> oh god reading MonadBaseControl this is hell on earth
21:47:37 <LordBrain> maybe we should have ghc compile exception code into IO Either code
21:47:54 <NemesisD> how do people jump through all these hoops with a straight face
21:48:26 <LordBrain>  -XNoExceptionsAtAll
21:48:28 <LordBrain> heh
21:49:24 <NemesisD> i think its a moral imperative. exceptions are not usable
21:49:59 <NemesisD> don't get me wrong, i don't like the idea of exceptions, but they are especially difficult to use in Haskell and destroy all reasoning with it
21:50:22 <monochrom> http://www.vex.net/~trebla/haskell/exception.xhtml
21:50:52 <rwbarton> monochrom, already posted 10 minutes ago :)
21:51:30 <monochrom> ah
21:51:48 <NemesisD> why are there so many single quotes in that post? i've never seen code like that
21:52:02 <monochrom> because I learned it from oleg
21:52:41 <monochrom> it's a good approximation to space
21:56:12 <NemesisD> how are you embedding io in that monad
21:56:37 <monochrom> newtype EIO a = IO a
21:58:44 <dwcook> type EIE a = a ; type EIEIO = EIE IO
22:00:12 <kazagistar> ExtendableInterfaceEngine
22:00:21 <kazagistar> ... hmm, that sounds like it needs a factory
22:00:21 <LordBrain> lol
22:00:27 <NemesisD> oh sod it i'll just make this IO and not MonadIO
22:00:32 <haasn> type EIEOH = IO
22:01:06 * dwcook wonders if anyone noticed the reference to Old MacDonald
22:02:06 <kazagistar> nope, still dont see it
22:02:10 <kazagistar> you should explain
22:02:24 <dwcook> Not worth it :P
22:23:30 * hackagebot mono-traversable 0.6.0.1 - Type classes for mapping, folding, and traversing monomorphic containers  http://hackage.haskell.org/package/mono-traversable-0.6.0.1 (MichaelSnoyman)
22:23:32 * hackagebot yesod-auth 1.3.1 - Authentication for Yesod.  http://hackage.haskell.org/package/yesod-auth-1.3.1 (MichaelSnoyman)
22:23:34 * hackagebot yesod-core 1.2.15.2 - Creation of type-safe, RESTful web applications.  http://hackage.haskell.org/package/yesod-core-1.2.15.2 (MichaelSnoyman)
22:23:36 * hackagebot yesod-form 1.3.9.1 - Form handling support for Yesod Web Framework  http://hackage.haskell.org/package/yesod-form-1.3.9.1 (MichaelSnoyman)
22:23:38 * hackagebot yesod-test 1.2.2 - integration testing for WAI/Yesod Applications  http://hackage.haskell.org/package/yesod-test-1.2.2 (MichaelSnoyman)
22:28:31 * hackagebot influxdb 0.4.0 - Haskell client library for InfluxDB  http://hackage.haskell.org/package/influxdb-0.4.0 (MitsutoshiAoe)
23:02:57 <MP2E> Hey guys, running into a weird cabal issue. When compiling vector-0.10.10 with ghc-7.8 latest git cabal segfaults for some reason. It's a cross compiler I built to cross to Android so some oddities are to be expected, I'm more curious as to how I can enable tracing in cabal or something similar to get a more descriptive error message
23:03:12 <MP2E> error for reference: Loading package ghc-prim ... zsh: segmentation fault (core dumped)  arm-unknown-linux-androideabi-cabal build
23:04:58 <MP2E> dynamic linking is completely disabled so it's not that, btw :P
23:05:26 <MP2E> (or shouldn't be heh)
23:07:47 <Geraldus> Hello everybody! I have a simple ADT like data Answer = AnswerNo | AnswerYes. I easily can declare this type as instance of Show typeclass, but I can’t understand how should I make it to be an instance of Read typeclass, how should I define readsPrec?
23:08:39 <Kaidelong> Geraldus: if you actually want to implement Read yourself, you should learn about parsers, but you should never ever actually implement Read yourself. Use "deriving (Show,Read)" instead
23:09:03 <Kaidelong> it helps ensure that Read and Show are properly derivable on types that encapsulate yours
23:09:06 <MP2E> Geraldus, a good rule of thumb is to make your Read implementation symmetrical to Show. That is to say, if you were to Show something and immediately Read it, you would get that thing back. But this is moot because Kaidelong is right
23:09:18 <Kaidelong> and also that the two are inverses of one another
23:09:25 <amosr> MP2E: this may be a silly question, but have you tried with “cabal … -v —ghc-options=“-v””?
23:09:38 <MP2E> amosr : I have not, thanks!
23:09:38 <Kaidelong> instead of overriding read and show, make a specialized functions instead
23:09:59 <Kaidelong> manually implementing Data, Typeable, Show, and Read is almost always a bad idea
23:10:23 <Geraldus> Kaidelong: hmm, what about that case when I want `show` render my value as `Yes` instead of `AnswerYes`?
23:11:00 <Geraldus> I believe that I can’t derive Read without Show, right? )
23:11:23 <glguy_> Show is for serializing back to Haskell like syntax
23:11:43 <glguy_> If you want some special presentation make a special function
23:12:00 <Kaidelong> Geraldus: don't use show for that, instead make a function like getAnswerString :: Answer -> String
23:12:02 <MP2E> ouch, seems -v didn't help much with the error verbosity
23:12:05 <MP2E> http://pastebin.com/xLUpQAji
23:12:14 <flux> the return type of show should instead be some gadt for haskell adt or perhaps a list of tokens ;)
23:12:18 <MP2E> so it's definitely ghc-prim being loaded causing this segfault..
23:12:44 <flux> (s/ adt/ ast/)
23:13:07 <oisin640> Is it possible to deriving those instances when using GADTs? Or is implementation the only option?
23:13:25 <Kaidelong> Geraldus: but go ahead and derive show and read with "deriving (Show,Read)"
23:13:44 <Kaidelong> they're still useful, but they're not for custom display formats or parsing
23:14:05 <Kaidelong> fortunately haskell has some pretty nice parser libraries, I learned Parsec enough to write a simple XML parser in a day
23:14:56 <amosr> MP2E: hmm. I have no idea, sorry!
23:16:26 <Geraldus> ok, I also thought about special function. Thanks for explanation!
23:16:39 <MP2E> No problem, this one may be one for the bug tracker :s
23:28:50 <matematikaadit> :t either
23:28:51 <lambdabot> (a -> c) -> (b -> c) -> Either a b -> c
23:38:03 <fling> This is awesome! -> http://www.youtube.com/watch?v=RqvCNb7fKsg
23:44:57 <fread2282> s
23:45:20 <Axman6> @hoogle mapM
23:45:21 <lambdabot> Prelude mapM :: Monad m => (a -> m b) -> [a] -> m [b]
23:45:22 <lambdabot> Control.Monad mapM :: Monad m => (a -> m b) -> [a] -> m [b]
23:45:22 <lambdabot> Data.Traversable mapM :: (Traversable t, Monad m) => (a -> m b) -> t a -> m (t b)
23:52:54 <gamegoblin> trlw1
23:53:12 <fread2282> t
23:53:20 <gamegoblin> typo
23:53:26 <gamegoblin> liftM0 == return
23:56:40 <fread2282> > 1
23:56:42 <lambdabot>  1
23:56:42 <matematikaadit> what is the opposite of @pointfree
23:57:07 <fread2282> @unpl (.id)
23:57:07 <lambdabot> (\ b -> b)
23:57:30 <matematikaadit> fread2282: thanks
