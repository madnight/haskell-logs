00:08:14 * hackagebot locators 0.2.4.2 - Human exchangable identifiers and locators  http://hackage.haskell.org/package/locators-0.2.4.2 (AndrewCowie)
00:08:14 * hackagebot rados-haskell 3.0.4 - librados haskell bindings  http://hackage.haskell.org/package/rados-haskell-3.0.4 (ChristianMarie)
00:12:22 <teakay> anyone know if there is a standard way to obfuscate database id's in yesod/haskell?
00:43:11 * hackagebot binary-conduit 1.2.2 - data serialization/deserialization conduit library  http://hackage.haskell.org/package/binary-conduit-1.2.2 (AlexanderVershilov)
01:28:03 <tibell> Someone just made the claim (in another forum) that "Type inference is undecidable for any language.". That sounds very wrong to me. It's definitely decidable in ML-like languages, no?
01:28:14 <tibell> And also local type inference is decidable in e.g. Scala
01:30:28 <AshyIsMe> http://en.wikipedia.org/wiki/Type_inference
01:30:57 <AshyIsMe> quite a few languages have it so it seems like a bit of a silly claim
01:31:06 <bartavelle> "In 1969 J. Roger Hindley extended this work and proved that their algorithm always inferred the most general type."
01:31:19 <bartavelle> there is a pretty obvious example with unityped languages ;)
01:32:07 <sjy> maybe there is a miscommunication re the word "any"
01:32:36 <bartavelle> you can certainly create a language where it is undecidable
01:32:40 <dfsdf> Is it reasonable to do (C.pack "ab") == (BS.pack [0097,0098])?
01:33:14 <frerich> This reminds me -- it's not really Haskell specific but there seem to be a lot of people from academica here so I guess it might be a good forum: I read that many proofs of various things are so complicated that people devised methods to mechanically verify that a proof of sound. However, doesn't this merely mean that now everybody has to agree that the mechanism used to verify a proof is sensible itself, i.e. it shifts the problem?
01:33:37 <sjy> bartavelle: exactly, and maybe "type inference is undecidable for any language" actually means "it's not the case that type inference is decidable for every language"
01:34:16 <bartavelle> sjy : knowing what was originally meant seems undecidable
01:35:40 <sjy> i can think of a relatively simple decision algorithm: ask the person who said it ;)
01:36:08 <bartavelle> heh
01:51:53 <darthdeus> guys, anyone here using fay?
01:52:05 <darthdeus> I'm having a really weird issue and I'm unable to debug it https://github.com/faylang/fay/issues/408
01:52:12 <abstract-alf> :t fix
01:52:14 <lambdabot> (a -> a) -> a
01:53:20 <abstract-alf> take 10 $ iterate (*2) 1
01:53:24 <abstract-alf> > take 10 $ iterate (*2) 1
01:53:25 <lambdabot>  [1,2,4,8,16,32,64,128,256,512]
01:55:46 <darthdeus> any tips are welcome :(
01:56:21 <abstract-alf> > tatk 10 $ fix (\f n -> if n <= 0 then 1 else n * f (n-1))
01:56:22 <lambdabot>  Not in scope: ‘tatk’
01:56:25 <abstract-alf> > take 10 $ fix (\f n -> if n <= 0 then 1 else n * f (n-1))
01:56:26 <lambdabot>  Couldn't match expected type ‘a0 -> a0’ with actual type ‘[a]’Couldn't match...
01:56:27 <lambdabot>  Relevant bindings include
01:56:27 <lambdabot>    n :: a0 (bound at <interactive>:1:19)
01:56:27 <lambdabot>    f :: [a] (bound at <interactive>:1:17)
02:11:21 <abstract-alf> > pl \x y -> x + 1
02:11:22 <lambdabot>  <hint>:1:4: parse error on input ‘\’
02:11:43 <abstract-alf> @pl \x y -> x + 1
02:11:43 <lambdabot> const . (1 +)
02:13:16 <abstract-alf> @unpl flip flip snd . (ap .) . flip flip fst . ((.) .) . flip . (((.) . (,)) .)
02:13:17 <lambdabot> (\ aa f b -> (snd >>= \ ae -> return ((\ p w -> ((,)) (aa (fst p)) (f w)) b ae)) b)
02:13:20 <abstract-alf> lol
02:13:38 <abstract-alf> lamdabot, you slay me
02:21:58 <ivanm> If I have [a] and p :: a -> Bool, what would be the best way to delete all but the _last_ value that satisfies the predicate
02:22:44 <abstract-alf> and you want to preserve order?
02:23:19 * hackagebot soap 0.2.2.4 - SOAP client tools  http://hackage.haskell.org/package/soap-0.2.2.4 (AlexanderBondarenko)
02:23:31 <ivanm> yes
02:24:51 <abstract-alf> I would do it with a lens/traverse
02:25:25 <abstract-alf> :t traverse
02:25:26 <lambdabot> (Traversable t, Applicative f) => (a -> f b) -> t a -> f (t b)
02:25:35 <ivanm> my current thinking is to use the split package to separate them based upon `p' and then a fold to merge them and delete excess values, but I wasn't sure if there was an existing function that did something like that
02:27:05 <abstract-alf> so then you don't care about order
02:27:09 <ivanm> travewait, I can probably just use foldr from the beginning
02:27:21 <ivanm> no, I _do_ care about order
02:27:31 <ivanm> s/travewait/wait/
02:27:39 <ivanm> I'm not sure how traverse applies
02:28:33 <abstract-alf> forget what I said, sounds like you're on the right track
02:29:31 <abstract-alf> so, it's almost like you want to remove duplicates?
02:30:08 <ivanm> yes, but keep the last one
02:30:14 <abstract-alf> have you considered nub and nubBy?
02:30:28 <abstract-alf> > nub [1,2,3,4,5,2,3,4,1,2,3,2]
02:30:29 <lambdabot>  [1,2,3,4,5]
02:30:50 <abstract-alf> :t nubBy
02:30:51 <lambdabot> (a -> a -> Bool) -> [a] -> [a]
02:33:16 <ivanm> yeah, but to use nubBy I'd have to do reverse . nubBy p . reverse
02:33:24 <ivanm> as nubBy keeps the _first_ value, and I want the last one
02:33:44 <abstract-alf> yeah, that's right
02:34:18 <Tjr> if your type a supports an ordering:
02:34:32 <ivanm> Tjr: they don't
02:36:39 <ivanm> OK, using foldr with a (Bool, [a]) to store whether a value satisfying the predicate has been spotted yet works
02:36:47 <Tjr> Out of curiosity, what naturally-occuring types support Eq but not Ord?
02:36:57 <ivanm> which is simpler than my original thinking
02:37:23 <ivanm> tuples?
02:37:26 <ivanm> Complex
02:37:38 <lieven_> lexicographic ordering
02:37:40 <Tjr> tuples support lexicograpic ordering
02:37:45 <Tjr> Complex are tuples
02:37:50 <ivanm> yeah, I just realised that
02:37:56 <lieven_> all sets can be well ordered :)
02:37:57 <Tjr> (but the lexicographic ordering isn't compatible with multiplication)
02:38:10 <jle`> Complex is not semanticaly orderable
02:38:13 <ivanm> nope, Complex doesn't have Ord
02:38:22 <Tjr> lieven_: haskellers will kill you for that assertion, given that code and functions form a set
02:38:28 <nicoo> Tjr: The is no total order for complex numbers that is compatible with arithmetic
02:38:41 <nicoo> There*
02:38:49 <lieven_> Tjr: yeah the constructive crowd doesn't like the axiom of choice
02:38:55 <Tjr> ivanm: just wrap it in a newtype and order it lexiocographically
02:39:11 <nicoo> Tjr: They form a countable set. Of course they can be well-ordered !
02:39:21 <abstract-alf> ivanm, can I see the expression you arrived at?
02:39:27 <ivanm> Tjr: IIRC the problem with Complex is that there are two possible ordering
02:39:27 <Tjr> nicoo: that's beside the point for an efficient, custom nub
02:39:44 <ivanm> Tjr: in my case, this is a custom type
02:40:00 <ivanm> I probably _could_ derive an Ord instance for it, but there's no need
02:40:02 <nicoo> Tjr: Probably, I missed all the beginning of the discussion
02:40:04 <jle`> Complex doesn't have a meaningful ordering
02:40:08 <jle`> er
02:40:14 <Tjr> sure it does
02:40:18 <jle`> meaningful distinguished ordering
02:40:22 <Tjr> for ordering purposes only
02:40:31 <jle`> yes, if you wanted to store it in a Map or something
02:40:52 <darthdeus> guys what's the prefered way of having multiple installs of ghc?
02:40:59 <jle`> Complex the data type might have a possible instance of Ord
02:41:07 <jle`> but Complex the concept it represents can't be an Ord
02:41:08 <darthdeus> what i'm doing now is basically symlinking one or the other and  then moving ~/.cabal and ~/.ghc around
02:41:08 <Tjr> ivanm: it really depends on how long your list is. Anythign that doesn't order somehow, will always have quadratic runtime. Ordering cuts down to n log n
02:41:11 <ivanm> onlyLastCommit = snd . foldr f (False,[]) where f x (seenLast,ys) | not (p x) = (seenLast, x:ys) | seenLast = (seenLast,ys) | otherwise = (True, x:ys)
02:41:22 <jle`> darthdeus: keep them in separate directories
02:41:26 <jle`> when you --configure
02:41:31 <jle`> and then change your $PATH
02:41:34 <jle`> when you need one or the other
02:41:47 <ivanm> Tjr: efficiency isn't a huge detail, as this is for pretty-printing error messages
02:41:47 <darthdeus> jle`: you mean keep ~/.cabal and ~/.ghc in separate directories?
02:41:56 <jle`> darthdeus: no, keep the actual binaries
02:41:59 <ivanm> if you get an error, then having it take a bit more time to pretty-print probably doesn't matter :p
02:42:04 <darthdeus> jle`: how?
02:42:07 <jle`> when you install
02:42:19 <darthdeus> oh
02:42:20 <jle`> ./configure --prefix=/where/you/want/it
02:42:20 <Tjr> ivanm: ok, I agree Eq is totally fine for that
02:42:23 <darthdeus> I have them installed separately
02:42:26 <jle`> yeah
02:42:29 <darthdeus> what I'm worried about is cabal and binaries
02:42:32 <identity> ivanm: You doing some git stuff or some such? Out of curiosity
02:42:33 <jle`> cabal takes care of it for you
02:42:35 <darthdeus> by binaries i mean package binaries
02:42:37 <darthdeus> oh really
02:42:37 <jle`> ls ~/.cabal
02:42:39 <ivanm> Tjr: I actually don't even need Eq, as I use pattern-matching :p
02:42:46 <jle`> erl
02:43:00 <ivanm> identity: nope: http://community.haskell.org/~ivanm/paraphrase-docs/paraphrase/src/Text-Paraphrase-Examples-XML.html
02:43:02 <jle`> ls ~/.cabal/lib
02:43:05 <jle`> and observe
02:43:20 * hackagebot hnetcdf 0.2.1.0 - Haskell NetCDF library  http://hackage.haskell.org/package/hnetcdf-0.2.1.0 (IanRoss)
02:43:20 <darthdeus> hmm that is interesting
02:43:23 <jle`> oh, you mean like executables installed by cabal packages?
02:43:28 <darthdeus> yeah
02:43:43 <jle`> those really don't depend on ghc or cabal or anything
02:43:44 <ivanm> jle`: I don't think you even need to do that, just specify the exact versioned ghc binary when configuring
02:43:54 <darthdeus> like for example if i have yesod installed in my global path, i probably want to have the version compiled with the same ghc as the one as my app
02:43:55 <ivanm> and there's various sandboxing wrappers that let you choose which GHC you're using
02:43:57 <jle`> you can just build them in a sandbox and copy them to your bin
02:44:01 <darthdeus> even if they're like wai-handler-devel, etc?
02:44:14 <identity> ivanm: ah, i see.
02:44:21 <ivanm> identity: errrr, remove the /src from that directory
02:44:28 <ivanm> s/directory/url
02:44:38 * ivanm even fails at sed'ing :(
02:44:48 <ivanm> http://community.haskell.org/~ivanm/paraphrase-docs/paraphrase/Text-Paraphrase-Examples-XML.html
02:44:58 <darthdeus> jle`: what if i have a project with a sandbox, do i need to re-create the sandbox when I switch versions, or is that separated as well?
02:45:12 <ivanm> specifically: the error log at the end has multiple copies of the commitment message, when only the last one is really necessary
02:45:17 <jle`> darthdeus: your sandbox is associated with a ghc version
02:45:57 <jle`> so i think you'll need to have the correct ghc in your path
02:46:06 <darthdeus> ok, cool :)
02:46:32 <jle`> it'll be the ghc version you have in your pathw hen you cabal sandbox init
02:46:35 <jle`> *had
02:47:02 <jle`> you can see it in cabal.sandbox.config i believe
02:47:26 <ivanm> there are other sandbox utils (hsenv maybe?) which allow for more control over ghc version
02:47:49 <ivanm> by specifying various variables
02:51:08 <mmmm> What is the function called which takes a list of Maybe and returns the first Just in the list?
02:51:59 <ttll> :t head . catMaybes
02:52:00 <lambdabot> [Maybe c] -> c
02:52:36 <mmmm> that isn't safe though
02:52:53 <ttll> pattern match on catMaybes then
02:54:31 <ttll> or msum
02:54:33 <ttll> :t msum
02:54:34 <lambdabot> MonadPlus m => [m a] -> m a
02:57:30 <mmmm> I wanted mconcat with the First wrapper from Data.Monoid thanks
02:57:40 <darthdeus> ivanm: i thought hsenv was deprecated
03:05:47 <ivanm> darthdeus: is it? doesn't say so on hackage or its github
03:05:54 <ivanm> admittedly, it's been over a year since the last release
03:06:48 <darthdeus> yeah
03:18:23 * hackagebot collapse-util 0.1.0.0 - utility for collapsing adjacent writes  http://hackage.haskell.org/package/collapse-util-0.1.0.0 (MarkWotton)
03:23:23 * hackagebot collapse-util 0.1.0.1 - utility for collapsing adjacent writes  http://hackage.haskell.org/package/collapse-util-0.1.0.1 (MarkWotton)
03:36:43 <codygman> Why am I getting a parse error? http://lpaste.net/106379
03:38:29 <iago> codygman, each equation must have the same number of patterns
03:38:42 <codygman> iago: Thanks
03:38:48 <iago> but also
03:39:02 <iago> if you use pattern guards, then you omit =
03:39:14 <ttll> also y is a single element, you can't map over it
03:39:26 <iago> so don't write f = | ... just f | ...
03:40:33 <ttll> and x == "-"  is the same as (x ==) "-"
03:52:20 <mmmm> \quit
04:04:39 <artyomkazak>  
04:58:04 <dabd> how was starting to work through "real world haskell" but i read some comments on reddit about it being a bit old so I was thinking of working through "beginning haskell:  a project-based approach". Any opinions on this book? Thanks.
05:01:30 <r444> i dislike it, hard to read and grok
05:01:41 <AshyIsMe> learn you a haskell is pretty good
05:01:45 <r444> dropped it at 1/2
05:01:54 <r444> LYAH is a good first book
05:02:19 <dabd> i've read lyah i was looking for a more practical book now
05:02:23 * Kinnison found LYAH to be good, esp. when read alongside RWH
05:02:37 <dabd> more updated too
05:02:37 <Kinnison> beyond that, I learned the most by trying to write something "proper" and asking questions here
05:02:56 <r444> dabd: personally i like combining everything possible after LYAH
05:03:06 <frerich> dabd: I very much recommend 'Prgramming in Haskell' by Graham Hutton. For some reason it's not as popular as RWH or LYAH but it's IMHO a much nicer introduction to the language.
05:03:13 <r444> RWH + #haskell + wikis + w/e
05:06:20 <dabd> another question: is anyone using fpcomplete instead of a local installation?
05:10:24 <darthdeus> guys i'm getting "cabal: You need to re-run the 'configure' command. The version of Cabal being used has changed (was Cabal-1.20.0.0, now Cabal-1.20.0.1). Additionally the compiler is different (was ghc-7.8, now ghc-7.6) which is probably the cause of the problem." ... even after i do cabal clean and cabal configure
05:10:52 <darthdeus> and also i currently have 7.8, not 7.6, even though it says 7.6 in the error message
05:18:25 <darthdeus> hmm, reinstalled cabal-install and now it works
05:32:22 <klrr_> im trying to write a CPS conversion algorithm for my Scheme project, but it behaves in a quite strange manner
05:32:25 <klrr_> http://lpaste.net/106383
05:33:18 <klrr_> could someone help me with this? im sorry for the ugly code, perhaps there is a more consice way to express it
05:34:35 <klrr_> the Bool cpsConv takes is a ugly state that makes sure i dont make atomic expressions "k x" and just "x" instead if they are args to a function
05:34:56 <klrr_> but checks for nested calls
05:35:47 <vanila> klrr_, are you working from some equational rules for CPS transforming
05:37:20 <klrr_> vanila: nope, i know about one blog post (in scheme) and i have appels book at hand, but i did not understand those two a single bit so i try write my own intsead (i guess that is pretty stupid, but i really dont get the other two and i dont know other resources)
05:37:49 <klrr_> the problem is that the continuation get applied twice
05:37:52 <klrr_> for some reason
05:37:55 <vanila> I would recommend getting your equational rules written out as clearly as possible and then implement the code to reflect them
05:38:22 <vanila> You could ask about the bits of appel that weren't clear
05:39:03 <klrr_> well, i dont understand his whole syntex tree representing cps'd code
05:39:05 <vanila> it's not stupid, it's a really good approach to experiment like that when you don't understand! It's just that the code as I see it is hard to read to the point that I recommend a second attempt from a different angle
05:40:25 <klrr_> :)
05:40:44 <vanila> let me see if i can dig something up that might be useful
05:41:22 <klrr_> thanks, i gonna try see if i can rewrite his CPS-ast in haskell and make sense out of it
05:47:12 <vanila> it's disappeared from the internet :\
05:47:31 <klrr_> i got a copy in pdf
05:47:46 <klrr_> can i pm?
05:47:55 <vanila> oh I meant the thing I was looking for, a compact description of how to CPS on scheme syntax
05:47:58 <vanila> yeah sure
05:48:12 <troydm> guys any ideas? http://lpaste.net/106384
05:48:34 * hackagebot websockets 0.8.2.5 - A sensible and clean way to write WebSocket-capable servers in Haskell.  http://hackage.haskell.org/package/websockets-0.8.2.5 (JasperVanDerJeugt)
05:55:33 <jkarni> troydm: can you try constraining to scientific < 0.3.2.1 and see what happens?
06:00:56 <bergey> troydm: If you can, upgrade whatever is keeping you from using aeson-0.7.0.6.  (Typically some older attoparsec.)  If you can't do that, aeson-0.7.0.4 has accurate version bounds in the .cabal, but also some DOS vulnerability.
06:01:47 <jkarni> troydm: yeah, just checked, and it isn't too high an upper bound that's the issue
06:03:52 <bergey> jkarni: aeson-0.7.0.3 only builds with scientific<0.3.
06:05:26 <jkarni> bergey: fair enough
06:12:12 <troydm> jkarni: I'm trying to build yi and aeson is just installed as dependency, I think one of dependencies has this version specified
06:13:21 <troydm> https://github.com/yi-editor/yi/blob/master/yi/yi.cabal
06:13:36 * hackagebot sunroof-server 0.2.1 - Monadic Javascript Compiler - Server Utilities  http://hackage.haskell.org/package/sunroof-server-0.2.1 (JanBracker)
06:13:38 * hackagebot sunroof-examples 0.2.2 - Tests for Sunroof  http://hackage.haskell.org/package/sunroof-examples-0.2.2 (JanBracker)
06:22:18 <bergey> troydm: If you run `cabal install -v3` it will give a (very long) output explaining which packages are introducing which constraints.
06:22:25 <mbrock> vanila: I'd be interested in that too
06:22:45 <mbrock> vanila, klrr_: in case it's of any use, here's some code I wrote (years ago) to do a CPS transform on Scheme code, in Haskell: https://github.com/mbrock/schume/blob/master/Schume/Compiler.hs
06:23:09 <mbrock> there might be something wrong with it, but it seemed to work ;)
06:24:48 <bergey> I built yi a few days ago, but it looks like I was using GHC-7.8 with a recent attoparsec.
06:26:57 <troydm> bergey: http://lpaste.net/106387
06:28:38 <rwbarton> ok so it looks like you have an attoparsec installed which is older than what the latest aeson requires
06:29:01 <Ankhers> Is there a cleaner way to deal with slightly different JSON field names than this? http://lpaste.net/106386
06:29:02 <bergey> It's odd that you have a version of Scientific already installed.  Are you building in a sandbox?  Try in a clean sandbox and see how it goes.
06:29:37 <Ankhers> (pretend Foo is Person)
06:30:05 <troydm> bergey: yeah, well I've built in a clean sandbox
06:31:01 <rwbarton> Ankhers: you should be able to "factor out" everything but the name/full_name field
06:31:18 <rwbarton> Person <$> (v .: "name" <|> v .: "full_name") <*> v .: "age"
06:34:24 <bergey> troydm: Either you've installed Scientific-0.3.2.1 into your sandbox, or you have it installed globally.  Either way, that's the problem, and you need a sandbox without it.  (Or without attoparsec<0.11.3.4).  Do you know how to check and fix that?
06:35:34 <Ankhers> rwbarton: Thanks!
06:36:23 <troydm> bergey: it's not globally install
06:36:26 <troydm> *ed
06:36:39 <sharyari_> rwbarton: Just curious, did the guy yesterday manage to convince you of having solved N=NP? :)
06:38:37 <bergey> troydm: Then it should be easy: `cabal sandbox delete` followed by `cabal sandbox init`, `cabal install`.  (You can just remove scientific, but then there's a chance of running into similar problems with some other library.)
06:38:37 * hackagebot whois 1.2.0 - WHOIS client library.  http://hackage.haskell.org/package/whois-1.2.0 (RickyElrod)
06:38:40 <rwbarton> unsurprisingly, no
06:39:43 <rwbarton> oh neat, I didn't know about "cabal sandbox delete"
06:41:42 <popx> i'm trying to install cabal from source on freebsd but it errors out: http://lpaste.net/106388
06:41:43 <Pepe348727021094> Hello?
06:41:56 <popx> anyone familiar with the issue?
06:42:01 <Pepe348727021094> Awesome it works!
06:42:06 <troydm> bergey: does cabal sandbox delete  does something different than rm -rf .cabal-sandbox ?
06:42:24 <Pepe348727021094> I just made a terminal IRC client in haskell!
06:42:38 <Pepe348727021094> Can anyone see my smessages?
06:42:41 <bergey> rwbarton, troydm: someday I should read the docs and find out what `cabal sandbox delete` actually does, eg, whether add-source persists across recreation.
06:42:44 <popx> Pepe348727021094: yes
06:43:00 <rwbarton> it removed the cabal.sandbox.config file too
06:43:09 <rwbarton> which I guess is where that would be stored
06:43:10 <Pepe348727021094> Cool
06:43:30 <Pepe348727021094> I am having it just alternate beteween the socket and stdin with hReady.
06:43:38 * hackagebot mangopay 1.7.0 - Bindings to the MangoPay API  http://hackage.haskell.org/package/mangopay-1.7.0 (FelipeLessa)
06:43:48 <Pepe348727021094> So I just receieve messages inuntil I start typing.
06:43:49 <bergey> rwbarton: Yes, I guess so too.  Thanks.
06:44:02 <Pepe348727021094> Too bad I didn't implement quit. Good bye.
06:44:33 <ptrxyz> guys, quick question: why does "(\x -> (\y -> x+y) x*2) 5" evaluate to 20 and not to 15 (as I would think it does...)
06:45:02 <rwbarton> > (\x -> (\y -> x+y) x*2) 5
06:45:04 <lambdabot>  20
06:45:14 <popx> 5*2*2 = 20
06:45:27 <rwbarton> oh, because '(\y -> x+y) x' is a function application that binds tighter than *2
06:45:50 <ptrxyz> ahhh
06:46:01 <ptrxyz> so lambda pwns multiplication?
06:46:10 <ptrxyz> hm ok.
06:46:16 <piezoid> > (\x -> (\y -> x+y) $ x*2) 5
06:46:17 <lambdabot>  15
06:46:20 <ptrxyz> ah ok, got it :)
06:46:37 <ptrxyz> yup, the lambda y is executed first, then the multiplication, right?
06:46:39 <troydm> it's (\y -> 5+y) 5*2
06:47:09 <ptrxyz> yey, thank you :)
06:51:02 <mbrock> that it's a lambda isn't actually relevant; think of it as: (\x -> f x * 2) 5
06:51:18 <mbrock> application binds strongly, like "sin" and "cos"
06:51:56 <bgb> clear
06:52:04 <bgb> sorry
06:53:39 * hackagebot request-monad 0.3.0.1 - A transformer for generic requests  http://hackage.haskell.org/package/request-monad-0.3.0.1 (nahiluhmot)
06:55:50 <Marquis> can you recommend a graph library in haskell which provides path search and shortest path? My graph does not have weigths on the edges but i need a concrete number how many edges i needed from a to b
06:58:29 <c_wraith> there's really only one graph library in haskell, fgl
06:59:42 <c_wraith> it appears to have a good selection of algorithms
07:00:05 <c_wraith> BFS would do what you're looking for
07:00:46 <c_wraith> documentation seems a bit sparse, though
07:01:18 <c_wraith> ah, http://web.engr.oregonstate.edu/~erwig/fgl/haskell/old/fgl0103.pdf has the real documentation.
07:01:47 <Marquis> that looks good, i ll start reading. thanks
07:01:52 <edwardk> in theory graphs also does bfs, but it was just an experiment in porting an API from C++ (boost graph library) to haskell
07:02:13 <edwardk> fgl is much much better supported though
07:02:23 <edwardk> so unless you need external memory go there ;)
07:03:39 <wad67> Hello everyone, I am seeking a little guidance at this point in time, Since I was seven years of age, I was fooling about in QBASIC. Ten years down the track I am about to graduate from high school, I don't have the money to attend a university and I have no Formal training in the world of ICT, due to the rural environment in which I grew up in. I
07:03:39 <wad67> don't really have any skills other than that in computers and I have really gotten stuck in terms of furthering my programming knowledge, I always get to a certain point in whatever I am working on and everything just seems to stop working, Everything I know has been self taught, so all I can really write is buggy linear text adventures or calculat
07:03:39 <wad67> ors that crash consistently. The peak of my programming would be copying a kernel off the internet and modifying it to say weird things, making a boot disk and making an old computer boot off a disk and say 'this computer is terrible' I have not really progressed beyond "hello world" or " 2 * 2" and I just really don't know what to do with myself.
07:03:39 <wad67> I have read countless books and followed countless guides, (including the interactive haskell one) But I find that I don't really retain information well through reading. I am at a loss of what to do here, I have been consistently trying to make something of programming for ten years now, and I was wondering if somebody could offer some advice of w
07:03:39 <wad67> hat to do in general. Either that or I drop my interest of computers and resort to mowing lawns for the rest of my life :/
07:04:50 <ivanm> edwardk: fgl is supported in theory... >_>
07:05:13 * ivanm did start on a replacement, but got burnt out trying to track down weird performance issues with transformers/mtl in the storage layer
07:05:20 <edwardk> there's that ivanm guy any ways ;)
07:05:57 <ivanm> wad67: what's your internet access like?
07:06:40 <wad67> ivan\: Acceptable, for australia anyway. 20mbit/s so that would equate to about 2.1 megabytes per second
07:06:44 <ivanm> (as in, is it feasible to work off of online tutorials consistently, or is it better to have written material)
07:06:52 <vlabs> Question about return - the type signature is return :: Monad m => a -> m a. However, something like return (Just 55) or even return 5 does not return a monad at all. what gives? :|
07:07:04 <ivanm> wad67: ahhh, another Aussie... if you believe iinet, Hungary has better internet than us :p
07:07:17 <ivanm> bollu: the caller gets to choose the Monad
07:07:34 <bollu> ivanm: sure, but what monad gets chosen when I use return in GHCI?
07:07:39 <mbrock> wad67: you still sound like you're pretty good at self-driven learning. maybe some online courses would be a nice change?
07:07:43 <bollu> like, which monad does it return?
07:07:50 <ivanm> wad67: I suggest you pick a project you're interested in and work on that, either by extending/hacking on an existing one or starting from scratch
07:07:53 <bollu> I tried :t but it didn't really reveal anything
07:08:17 <wad67> I have done a fair bit of that, I tend to taper off interest though as things get stuck.
07:08:18 <ivanm> bollu: just "return 5" in ghci seems to do some magic Identify monad...
07:08:28 <ivanm> oh, wait, duh
07:08:33 <ivanm> it's probably in IO
07:08:35 <ImadeAnIRCclient> This is a test.
07:08:42 <ImadeAnIRCclient> C
07:08:49 <ImadeAnIRCclient> Can you guys see what I type?
07:08:50 <bergey> wad67: Some of us learn well through reading, but nearly everyone does better by writing code.  Picking a project that's hard enough to make you learn something new, but not so hard as to be frustrating is hard.  I think a lot of what formal education does is scaffold progressively harder problems.
07:08:55 <ivanm> ImadeAnIRCclient: no, we can't
07:08:57 <ivanm> ImadeAnIRCclient: :p
07:09:17 <ivanm> wad67: there's also #haskell.au if you want a more local crowd
07:09:22 <ImadeAnIRCclient> I made a terminal based IRC client.
07:09:23 <bollu> ivanm: really? hm, what if I do a <- ret
07:09:52 <bergey> wad67: Have all of your projects been personal projects?  As in, you were the only programmer, maybe no users?  I find having fellow-programmers and users is great for keeping interest after the initial excitement.
07:09:54 <ImadeAnIRCclient> @lambdabot unlines ["That", "is", "cool", "person."]
07:09:54 <lambdabot> Unknown command, try @list
07:10:08 <wad67> That's the problem though, you can only google so much information, you eventually create your own programming problems so bad that nobody has heard of them before :P I usually get told to scrap everything and start again
07:10:15 <ivanm> bollu: ghci is a weird sort-of extended IO monad block
07:10:28 <ImadeAnIRCclient> Yep
07:10:30 <ivanm> ImadeAnIRCclient: just do "> unlines ..."
07:10:31 <vlabs> nick bollu
07:10:40 <ImadeAnIRCclient> Aww do you know what would be cool?
07:10:57 <vlabs> Yeah, so, if I use a <- return 5, then :t tells me it's int, not IO int or anything
07:11:02 <mbrock> wad67: also, meetups for language communities or projects are great for being inspired, seeing what other people are working on, and very often there will be people/projects who need help and offer guidance in getting up to speed
07:11:05 <ImadeAnIRCclient> If ghci supported other monads (that are MonadIO.)
07:11:05 <wad67> Basically everything I have made is personal, nobody in my area has any interest in computers and the internet seems 'disconnected'/
07:11:09 <vlabs> so what's m in /that/ case?
07:11:26 <vlabs> Integer*  not int.
07:11:33 <ivanm> vlabs: still IO
07:11:44 <vlabs> ivanm: how? ;_;
07:11:46 <ivanm> because after you do the <- the value isn't a monadic one
07:11:48 <wad67> So basically I would have to save up, and move out to a big city.
07:11:48 <ImadeAnIRCclient> OA@lambdabot > unlines ["That", "is", "a", "cool", "irc", "client."]
07:11:55 <vlabs> why doesn't GHCI tell me that it's IO?
07:12:15 <mbrock> I guess the majority of programming jobs are in bigger cities anyways, right?
07:12:20 <ImadeAnIRCclient> @lambdabot > unlines ["That", "is", "a", "cool", "irc", "client."]
07:12:20 <lambdabot> Unknown command, try @list
07:12:21 <ivanm> vlabs: because the "return" bit is; just like in a do-block, when you do "x <- return 5", the `x' isn't a monadic value
07:12:30 <ivanm> ImadeAnIRCclient: that's not how to do that
07:12:41 <ivanm> wad67: I tend not to do much in-person Haskell stuff
07:12:44 <ImadeAnIRCclient> @lambdabot >unlines
07:12:44 <ivanm> and I live in Canberra
07:12:44 <lambdabot> Unknown command, try @list
07:12:50 <magicman> > unlines ["Hello","world"]
07:12:52 <lambdabot>  "Hello\nworld\n"
07:12:52 <ImadeAnIRCclient> @lambdabot @list
07:12:53 <lambdabot> Unknown command, try @list
07:12:54 <ivanm> ImadeAnIRCclient: use /msg lambdabot
07:12:56 <wad67> Never been to or lived in a city, sounds really daunting and I don't think I have the life skills to live on my own, I live in my parents back yard in a caravan...
07:13:05 <magicman> ImadeAnIRCclient: Don't start with @lambdabot.
07:13:11 <ninja_code> to the moon!
07:13:15 <ivanm> can someone please tell ImadeAnIRCclient to stop using lambdabot wrong? he'll hurt her feelings! :p
07:13:19 <ImadeAnIRCclient> > unlines ["That", "is a cool irc client."]
07:13:20 <lambdabot>  "That\nis a cool irc client.\n"
07:13:28 <ivanm> wad67: if you don't mind me asking, how old are you?
07:13:32 <ImadeAnIRCclient> Yes lambdabot, you are correct.
07:13:35 <vlabs> ivanm: so it defaults to IO? and even so, why doesn't it tell me that it's IO even if it is IO? I don't see why ghci refuses to claim that it's IO 5 or some such
07:13:35 <wad67> I'm 17.
07:13:47 <ivanm> wad67: ahhhh, heaps of time!
07:14:19 <wad67> ivan\: Sure does not feel like it, I only have half a year of school left, then I have to find a way to make money.\
07:14:24 <vlabs> ivanm: explaination? :)
07:14:26 <ivanm> vlabs: because of how do blocks work, when you do "do x <- someMonadicThing; ..." it de-sugars down to "someMonadicThing >>= \ x -> ..."
07:14:29 <ivanm> @type (>>=)
07:14:30 <lambdabot> Monad m => m a -> (a -> m b) -> m b
07:14:36 <ImadeAnIRCclient> Oh, and /msg lambdabot wouldn't work. My irc client doesn't support that command yet.
07:14:40 <ivanm> ^^ the `a' value isn't monadic in the function!
07:15:18 <k00mi> vlabs: do you want to understand ghci specifically? Because it behaves differently in many ways than "normal" haskell
07:15:21 <ivanm> wad67: alas, there's not many Haskell-related jobs in Australia, and even in more popular languages they typically won't take someone straight out of high school
07:15:42 <ivanm> wad67: but it's definitely possible to interact with people via IRC, mailing lists, github, etc. on programming projects
07:15:49 <vlabs> k00mi: I'd like to understand both - why it behaves that way in ghci, and what would happen external to GHCI
07:15:51 <wad67> I have tried more languages than I care to remember. If I don't get results really quickly I kinda loose interest, I am not really tied to haskell in any way.
07:16:06 <ivanm> wad67: what kind of programming projects interest you?
07:16:12 <vlabs> wad67: try Rust?
07:16:23 <ImadeAnIRCclient> You should make an IRC client.
07:16:23 <ivanm> vlabs: I'm still not sure what you're not understanding :p
07:16:47 <wad67> I like things that add user functionality, make the computing experience better, whether it be a simple clock in the linux terminal or a note taking program.
07:16:51 <ImadeAnIRCclient> when use the arrow thingy in ghci, it executes and takes out the result
07:16:55 <ivanm> vlabs: "return 5" is polymorphic in nature, but when you type that into ghci and hit enter, it runs it in the default "ghci IO monad"
07:17:24 <ivanm> wad67: so, as a relatively simple exercise, why not try working on and developing say a new text editor?
07:17:26 <ImadeAnIRCclient> t
07:17:29 <ivanm> give yourself a project to work towards
07:17:38 <ImadeAnIRCclient> @type return 5
07:17:39 <lambdabot> (Num a, Monad m) => m a
07:17:41 <wad67> What language? Haskell? :P
07:17:46 <ninja_code> hack on yi
07:17:46 <ivanm> sure
07:17:50 <ivanm> or anything you want
07:17:58 <k00mi> wad67: I don't know about australia, but here in germany many companies offer apprenticeships, so you work for them, they pay you, but you also go to school and are tought practical skills at work
07:18:02 <ivanm> ninja_code: is the source code for yi suitable for a beginner to look at?
07:18:12 <vlabs> ivanm: does a <- return 5; :t a; behave differently withing GHCI? I'm just confused as to why GHCI tells me the type of a is just "Integer" rather than "IO Integer" or something similar
07:18:22 <ivanm> k00mi: not as much for technical things here
07:18:32 <ninja_code> ivanm: I'm optimistic. I see people for what they can become.
07:18:41 <ImadeAnIRCclient> try doing let a = return 5
07:18:44 <wad67> k00mi: Australia is rather dead in regards to that sorta stuff, you really have to be qualified to begin with. Thanks for the help anyway
07:18:48 <ImadeAnIRCclient> The arrow is weird in ghci.
07:18:53 <ivanm> vlabs: as I said, for "a <- return 5", the `a' isn't monadic: it desugars down to "return 5 >>= \ a -> ..."
07:18:56 <ivanm> @type (>>=)
07:18:56 <lambdabot> Monad m => m a -> (a -> m b) -> m b
07:19:04 <mbrock> wad67: aside from projects, I was inspired by reading books like "The Pragmatic Programmer". that's also good stuff to learn about if you want to do programming work. on a similar note, "The Passionate Programmer"
07:19:11 <wad67> What's yi?
07:19:24 <ImadeAnIRCclient> @def a=return (5 :: Int)
07:19:26 <lambdabot>  Defined.
07:19:27 <ivanm> wad67: yi is an emacs-like configurable text editor written in Haskell
07:19:29 <ImadeAnIRCclient> @type a
07:19:30 <lambdabot>     Ambiguous occurrence ‘a’
07:19:30 <lambdabot>     It could refer to either ‘L.a’,
07:19:30 <lambdabot>                              defined at /home/lambda/.lambdabot/State/L.hs:149:1
07:19:30 <ninja_code> yi is '@gogole yi"
07:19:40 <ivanm> ImadeAnIRCclient: please don't @def random stuff like that for no reason
07:19:46 <vlabs> ivanm: so what does the "m" bind to in the m a -> (a -> mb) -> mb ? what is "m" here? >_< (within GHCI)
07:19:52 <ImadeAnIRCclient> I was trying to help, sorry.
07:19:55 <ImadeAnIRCclient> @undef a
07:19:55 <lambdabot> There's currently no way to undefine just one thing.  Say @undefine (with no extra words) to undefine everything.
07:20:03 <ImadeAnIRCclient> @undefine
07:20:03 <lambdabot> Undefined.
07:20:08 <ivanm> vlabs: it's weird ghci-specific IO-like monad
07:20:11 <wad67> mbrock: books are really not my thing to be honest, I am an avid reader I'm a big "king" fan but I have really bad retention.
07:20:25 <ivanm> ImadeAnIRCclient: you can do stuff like this:
07:20:32 <ivanm> @type let a = return (5 :: Int) in a
07:20:32 <lambdabot> Monad m => m Int
07:20:35 <vlabs> ivanm: which doesn't get displayed when I do :t? why not? It seems like they're trying to obscure things :)
07:20:51 <ImadeAnIRCclient> Notice that it uses let, not "<-"
07:20:54 <vlabs> wad67: I'm sorta in the same boat tbh :) same age at least
07:20:56 <ivanm> vlabs: by the time you do ":t", it's now outside the scope of the monad
07:21:08 <mbrock> wad67: sure, you don't need to read a lotta books. those books I mentioned aren't really textbooks on learning stuff, they're just kinda full of tips and stories and such. gives you a kind of different picture of programming as a craft... read 'em if they seem interesting :)
07:21:22 <vlabs> ivanm: what does that mean? care to expand on the "out of scope" ?
07:21:22 <ImadeAnIRCclient> "<-" breaks out of the monad. It isn't just an assigment. It actually does something.
07:21:41 <ivanm> vlabs: how much do you know about monads and do-blocks?
07:21:54 <ivanm> @undo do { x <- return 5; return (x + 3) }
07:21:55 <lambdabot> return 5 >>= \ x -> return (x + 3)
07:22:03 <vlabs> ivanm: I know what the monadic laws are, and how do works, like, what it expands to
07:22:05 <wad67> oh cool, I can pull it from github *leaps into the teminal*
07:22:40 <ivanm> vlabs: well, after you do "a <- return 5" in ghci, the rest of the ghci session is basically the function in the second argument to >>=
07:22:58 <ivanm> @type (>>=)
07:22:59 <lambdabot> Monad m => m a -> (a -> m b) -> m b
07:23:07 <ImadeAnIRCclient> @wad67 When you do "a <- return 5", a is NOT return 5. return 5 is run, the result is 5, and that gets assigned to a.
07:23:07 <lambdabot> Unknown command, try @list
07:23:26 <ImadeAnIRCclient> @wad67 If you wanted a to be return 5, you have to do "let a = return 5".
07:23:26 <lambdabot> Unknown command, try @list
07:23:35 <wad67> ?!?
07:23:44 <ivanm> ^^ in this case, "return 5" is the "m a", the "x <-" is the "a ->" and the rest of the ghci session is the "m b" in the function
07:23:56 <ivanm> ImadeAnIRCclient: just use the nick, don't prefix it with @
07:24:00 <ivanm> it'll confuse lambdabot
07:24:04 <ImadeAnIRCclient> Oh, sorry.
07:24:06 <ivanm> wad67: that was actually for vlabs
07:24:22 <wad67> I figured :P
07:24:38 <vlabs> ivanm: m b in the bind operator that is?
07:24:54 <ivanm> vlabs: well, the "m b" that's in the "a -> m b"
07:25:05 <ImadeAnIRCclient> Does lambda bot have typed holes yet?
07:25:07 <ivanm> since you never actually finish off and return a result from the ghci session ;-)
07:25:10 <ivanm> ImadeAnIRCclient: I doubt it
07:25:18 <ivanm> wad67: what part of Australia are you in?
07:25:27 <ImadeAnIRCclient> Ah, that would make this easy to show.
07:25:41 <ImadeAnIRCclient> I am getting on with pidgin instead of my terminal client.
07:25:44 <vlabs> ivanm: hm, I think I understand
07:25:47 <wad67> ivanm: Far North Queensland, further than Cairns.
07:26:01 <ivanm> wad67: yeah, then I doubt you'll find a Haskell group :p
07:26:04 <vlabs> wad67: what other programming languages have you used?
07:26:14 <ivanm> there might be _some_ kind of programming community up there, but Cairns would probably be the closest
07:26:35 <wad67> vlabs: C#, C++, Python, GML, QBASIC, FreeBasic, that's off the top of my head
07:26:58 <TheKing444> Okay, when you type "a<-return 5; :t a", it is like doing "return 5 >>= (\a->print :t a)"
07:27:00 <wad67> vlabs: oh and HTML, I found a book on it at the local second hand store somehow
07:27:30 <TheKing444> (That isn't valid code by the way.)
07:27:42 <vlabs> TheKing444: oh, that makes *so much sense* even if it's a small lie :P
07:28:10 <vlabs> wad67: which language do you know *well* ? and, like, have you tried contributing to projects you like / use?
07:28:41 <vlabs> TheKing444: how large a "not working" is it? :) and how accurate was that explaination?
07:28:45 <ivanm> wad67: anyway, good luck with your quest; it's time I got some shut-eye
07:28:54 <wad67> vlabs:  Freebasic is one where I don;t hit a brick wall at every turn. I have tried contributing once or twice in the past
07:28:57 <ivanm> vlabs: you can't do ":t" in actual code
07:29:02 <TheKing444> Yep
07:29:04 <wad67> ivanm:  Okay, thanks for the help
07:29:22 <TheKing444> I am actually find a way right now to do it though. (There has to be a typeclass for that some where.)
07:29:40 <ivanm> and it's actually more like "a <- return 5; :t a" goes to "return 5 >>= (\ a -> do { :t a ; .... the rest of the ghci session ... } )
07:29:51 <vlabs> ivanm: other than that it's a solid explaination? the >>= bit is isn't a lie right?
07:29:58 <wad67> uhh, would anybody know what dependencies I would have to apt-get install in order to make yi?
07:29:59 <TheKing444> Nope
07:30:02 <identity> > return 5 >>= \x -> print (typeOf (x :: Int))
07:30:04 <lambdabot>  <IO ()>
07:30:08 <vlabs> ivanm, TheKing444 : if so, then I've understood it ^_^
07:30:15 <vlabs> wad67: isn't there a ppa or something for yi?
07:30:17 <identity> > typeOf (undefined :: Int)
07:30:18 <lambdabot>  Int
07:30:23 <benzrf> cheater!
07:30:29 <wad67> vlabs:  ppa?
07:30:39 <TheKing444> @type typeOf
07:30:39 <identity> There is no cheating. There is only winning.
07:30:40 <lambdabot> Typeable a => a -> TypeRep
07:30:42 <identity> #biwinning
07:30:55 <TheKing444> Oh, there actually is a function for that!
07:30:58 <vlabs> wad67: https://launchpad.net/ubuntu/+ppas :)
07:31:00 <identity> of course
07:31:05 <TheKing444> @info typeOf
07:31:05 <lambdabot> typeOf
07:31:14 <TheKing444> Where did you find typeOf?
07:31:15 <identity> @hoogle typeOf
07:31:16 <vlabs> wad67: you want to build it or just use it?
07:31:17 <lambdabot> Data.Typeable typeOf :: Typeable a => a -> TypeRep
07:31:17 <lambdabot> Data.Typeable typeOf1 :: Typeable1 t => t a -> TypeRep
07:31:17 <lambdabot> Data.Typeable typeOf1Default :: (Typeable2 t, Typeable a) => t a b -> TypeRep
07:31:23 <TheKing444> Cool
07:31:38 <wad67> vlabs: Both
07:31:48 <TheKing444> >return (5 :: Int) >>= (\a -> print $ typeOf a)
07:31:54 <wad67> vlabs: Modify > build > use
07:31:56 <identity> > map (show . typeOf) ([1 ..] :: [Int])
07:31:57 <vlabs> TheKing444: so whatever expression I write in GHCI will have a monad "stripped" from it when I try to print because of the >>= ?
07:31:57 <lambdabot>  ["Int","Int","Int","Int","Int","Int","Int","Int","Int","Int","Int","Int","In...
07:32:06 <TheKing444> > return (5 :: Int) >>= (\a -> print $ typeOf a)
07:32:07 <lambdabot>  <IO ()>
07:32:21 <TheKing444> Whoops
07:32:42 <TheKing444> Ah well, you can just import the module.
07:32:48 <TheKing444> Lambdabot doesn't like printing things.
07:33:24 <identity> > cycle "Uhn Tiss " ++ "Baby"
07:33:26 <lambdabot>  "Uhn Tiss Uhn Tiss Uhn Tiss Uhn Tiss Uhn Tiss Uhn Tiss Uhn Tiss Uhn Tiss Uhn...
07:33:52 <TheKing444> identify Try using the dollar sign.
07:34:10 <vlabs> wad67: hm, just try and build it and then fix the errors as you go along?
07:34:24 <vlabs> repeated question: whatever expression I write in GHCI will have a monad "stripped"  ??? acfoltzer
07:34:25 <identity> TheKing444: The first is an infinite string. Even lambdabot can't append to that.
07:34:26 <vlabs>                           | from it when I try to print because of the >>= ?
07:34:48 <wad67> vlabs: make: ghci: Command not found
07:34:54 <identity> vlabs: It gets evaluated
07:34:55 <TheKing444> No, I meant if you wanted "Baby" to be included in the cycle.
07:35:05 <vlabs> whoops, tried naive copy pasting :P Question was: since GHCI uses >>=, won't I lose a monad every time I usr print?
07:35:13 <vlabs> wad67: install ghci
07:35:13 <identity> oh, nah.
07:35:28 <vlabs> wad67: sudo apt-get install haskell-platform I believe
07:35:33 <TheKing444> vlabs, Yes, it will always assume the monad is IO, and then "strip it". Which is really just >>=.
07:35:37 <wad67> ah okay
07:35:38 <vlabs> wad67: that pulls all haskell related dependencies
07:35:39 <identity> vlabs: in ghci: let foo = print "foo"
07:35:41 <TheKing444> Unless you do let a = return 5
07:35:47 <identity> now foo is a function :: IO () which hasn't been evaluated
07:35:48 <wad67> vlabs:  That's what I was after
07:35:53 <identity> you can then type "foo" in ghci and it will evaluate it.
07:36:19 <wad67> woo! 327 MB to download :/
07:36:22 <vlabs> TheKing444: :) identity cool, that sounds nice. And, well, this has been enlightening
07:36:32 <TheKing444> If you type in something that isn't IO, like "5+3", it gets changed to "print $ 5+3"
07:36:38 <vlabs> wad67: that should go pretty fast right?
07:36:38 <TheKing444> ghci is all about the IO
07:36:46 <vlabs> Thrhh
07:36:51 <vlabs> TheKing444: ohh*
07:37:03 <TheKing444> One big do statement.
07:37:06 <wad67> vlabs:  Speed is not my concern, HDD space is. :D Ancient computer.
07:37:35 <vlabs> wad67: ah xD
07:37:39 <TheKing444> If you copied everything you typed into ghci, putting prints in front of none IO, and put it in a do block, you would get valid code.
07:37:56 <TheKing444> @type print
07:37:57 <lambdabot> Show a => a -> IO ()
07:38:06 <TheKing444> That is why it complains about things being showable.
07:38:06 <vlabs> TheKing444, identity : print (return 5) seems to cause Hakell to get mad :P why?
07:38:15 <wad67> vlabs:  Built out of the finest scrap available, using every sata port on this motherboard I have about 240 GB of combined space from 4 different drives
07:38:25 <TheKing444> What was your error?
07:38:35 <vlabs> TheKing444: too latge to paste
07:38:38 <vlabs> large*
07:38:39 <ben> Is there any way to have a parameterised type use different representations depending on its type parameters, where one combination of types results in a specialized representation, while all others use another representation?
07:38:41 <wad67> vlabs:  One has bad sectors, one throws "SMART" errors.
07:38:45 <identity> vlabs: Because you're trying to print a monadic computation. (return 5) is Num a => m a. You can't print it.
07:38:51 <TheKing444> okay, I did it in ghci
07:39:05 <TheKing444> Now, ghci assumes that you are in IO, but only for the entire command.
07:39:19 <TheKing444> @type print undefined
07:39:20 <lambdabot> IO ()
07:39:34 <TheKing444> It knows that since you did print, the whole statement will be IO.
07:39:44 <TheKing444> But it doesn't know what "return 5" will be.
07:39:51 <vlabs> identity: I assumed it would bind m to IO ? like, it would return IO 5 which would then be printed?
07:39:59 <identity> To be specific, print requires its parameter to be an instance of Show. There is no valid instance for Show (m a)
07:40:00 <TheKing444> It could be [5], Just 5, const 5, or anything.
07:40:12 <identity> vlabs: 5 is not a type, it is a value.
07:40:21 <wad67> Okay, well I made some progress in compiling, It has started linking the files however It is missing one called HackerMain.hs
07:40:33 <vlabs> identity: sorry :P I assumed it would be IO Int
07:40:44 <TheKing444> When you type in an IO action, like "return 5 :: IO Int", it actually changes it to "return 5 >>= print"
07:40:46 <vlabs> wad67: which version of ubuntu?
07:40:54 <TheKing444> ghci just adds prints everywhere
07:40:57 <identity> vlabs: Well, you can do: print (return 5 :: IO Int), but there is still no valid way to print a function.
07:41:02 <wad67> I am currently running lubuntu, uhh
07:41:21 <TheKing444> Well, for IO, it is better to think about them as actions.
07:41:33 <identity> vlabs: Think of it this way: if the function is :: IO Int, but it is som IO computation that fetches an integer value from a server.. How would you print such a function?
07:41:37 <TheKing444> You can print an action, you have to preform it, then you can print the contents.
07:41:40 <vlabs> identity: hm, that sucks. wad67  uname -a should give you details?
07:42:09 <wad67> vlabs:  Linux shittox1337 3.13.0-24-generic #47-Ubuntu SMP Fri May 2 23:31:42 UTC 2014 i686 i686 i686 GNU/Linux
07:42:21 <vlabs> identity: so you're saying it won't print? or it can't print?
07:42:43 <TheKing444> Summary for ghci. If you type something that can be IO, it adds ">>= print" to the end. If it can't be made IO, it adds "print $ " to the beginning.
07:43:02 <TheKing444> vlabs, You can print actions. There is no way to show what an action is.
07:43:17 <TheKing444> vlabs, You have to preform the action.
07:43:34 <vlabs> TheKing444: ahh. You have a knack for explaining things :)
07:43:34 <identity> vlabs: There is no sensible way of printing a function.
07:43:38 <vlabs> wad67: I have no idea
07:43:45 <TheKing444> That is what (return 5) >>= print would do. It would preform the first action, and then print it.
07:43:57 <wad67> vlabs:  Same, I will figure something out
07:44:03 <vlabs> TheKing444: it would, well, *unwrap* the action no?
07:44:05 <wad67> vlabs:  I will keep looking at the wiki
07:44:13 <TheKing444> What would?
07:44:22 <TheKing444> >>=?
07:44:51 <TheKing444> >>= means unwrap the first thing, then do the second
07:45:08 <athan> identity: what about arrows? :)
07:45:20 <TheKing444> For IO actions, >>= means "do the action."
07:46:12 <TheKing444> Well actually, a >>= b for IO means "here is a new action: do action a, then do b with the result of a"
07:46:18 <identity> athan: I know roughly nothing about arrows and I'm not really talking about some strange, magic-ish stuff
07:46:25 <athan> There's also =<<, >=>, and a few others that parallel with $, &, and .
07:46:42 <TheKing444> For lists, a>>=b means "for everything in a, do b, then put the resulting lists together"
07:46:48 <TheKing444> >>= is flexible
07:46:56 <TheKing444> By I think I am getting of track.
07:47:01 <athan> identity: No yonedas? :V
07:47:21 <TheKing444> > return 5 >>= typeOf
07:47:22 <lambdabot>  Couldn't match type ‘m b’ with ‘Data.Typeable.Internal.TypeRep’
07:47:22 <lambdabot>  Expected type: a0 -> m b
07:47:22 <lambdabot>    Actual type: a0 -> Data.Typeable.Internal.TypeRep
07:47:28 <identity> athan: take your tongue-twisting type sorcery and begone!
07:47:32 <TheKing444> Ignore that
07:47:39 <athan> :x
07:47:39 * identity clutches his crucifix
07:47:48 <athan> *hisssss*
07:48:29 <athan> :t (>>=)
07:48:30 <lambdabot> Monad m => m a -> (a -> m b) -> m b
07:48:34 <athan> :t ($)
07:48:35 <lambdabot> (a -> b) -> a -> b
07:48:41 <athan> erm...
07:48:44 <athan> :t (&)
07:48:45 <lambdabot> a -> (a -> b) -> b
07:48:51 <athan> :t (=<<)
07:48:52 <lambdabot> Monad m => (a -> m b) -> m a -> m b
07:48:56 <athan> :t ($)
07:48:57 <lambdabot> (a -> b) -> a -> b
07:49:03 <athan> :t (>=>)
07:49:04 <lambdabot> Monad m => (a -> m b) -> (b -> m c) -> a -> m c
07:49:09 <athan> :t (.)
07:49:10 <lambdabot> (b -> c) -> (a -> b) -> a -> c
07:49:16 <athan> :D
07:50:04 <vlabs> sorry, was ADK
07:50:07 <vlabs> AFK*
07:50:09 <athan> By the way, (&) is __NOT__ standard. It's imported from Data.Lens (don't even google it yet if you don't understand (>>=) yet :x)
07:50:38 <TheKing444> @dijn (a->(a->b))->a->b
07:50:38 <lambdabot> Maybe you meant: djinn dice
07:50:41 <vlabs> wad67: AFAIK your version number wll be in Preferences -> About
07:50:45 <TecTec> On a related note, I am trying to get something like this to work: readFile "./payees.txt" >>= (liftM lines)
07:50:58 <TheKing444> @djinn (a->(a->b))->a->b
07:50:58 <lambdabot> f a b = a b b
07:51:03 <identity> TecTec: liftM lines $ readFile "foo"
07:51:15 <identity> :t  liftM lines $ readFile undefined
07:51:17 <lambdabot> IO [String]
07:51:22 <TheKing444> @djinn (a,b)->(b->a)
07:51:22 <lambdabot> f (a, _) _ = a
07:51:44 <identity> :t lines <$> readFile "foo" -- alternatively, TecTec
07:51:45 <lambdabot> IO [String]
07:51:48 <athan> TheKing444: I still have no idea how djinn works :x
07:52:07 <TheKing444> You give djinn a type, and it makes a thing with that type.
07:52:23 <TheKing444> @type (.).(.).(.)
07:52:24 <lambdabot> (b -> c) -> (a -> a1 -> a2 -> b) -> a -> a1 -> a2 -> c
07:52:31 <athan> *clenches stomach* I mean, internally
07:52:40 <TheKing444> Oh, not sure.
07:52:41 <vlabs> TheKing444: a $ b causes a to be applied after b right?
07:52:45 * darthdeus is patiently awaiting a certain person to ask him a question
07:52:48 <TheKing444> Probably has something to do with electrons.
07:52:59 <vlabs> darthdeus: you can answer mine ^_^
07:53:00 <TecTec> thanks identity
07:53:03 <TheKing444> vlabs, no $ has nothing to do with actions
07:53:18 <TheKing444> a $ b means that a is a function that you give b
07:53:20 <the_berserker> @help
07:53:20 <lambdabot> help <command>. Ask for help for <command>. Try 'list' for all commands
07:53:23 <darthdeus> vlabs: $ is just function application with left associativity
07:53:34 <TheKing444> a $ b = a b
07:53:40 <the_berserker> @help list
07:53:40 <lambdabot> list [module|command]. Show commands for [module] or the module providing [command].
07:53:40 <athan> :) thank you darthdeus
07:53:50 <athan> @src ($)
07:53:50 <lambdabot> f $ x = f x
07:53:55 <the_berserker> @list
07:53:55 <lambdabot> What module?  Try @listmodules for some ideas.
07:54:02 <vlabs> ooh
07:54:07 <TheKing444> For example
07:54:15 <TheKing444> > show 5+3
07:54:16 <athan> @src (&)
07:54:16 <lambdabot> Source not found. It can only be attributed to human error.
07:54:17 <lambdabot>  No instance for (GHC.Num.Num GHC.Base.String)
07:54:17 <lambdabot>    arising from a use of ‘GHC.Num.+’
07:54:21 <vlabs> huh, that's .. enlightening.
07:54:21 <athan> @src (Data.Lens.&)
07:54:21 <lambdabot> Source not found. My brain just exploded
07:54:23 <darthdeus> athan: vlabs a $ b c == (a (b c)),   while a b c == (a b) c
07:54:25 <TheKing444> > show $ 5 + 3
07:54:26 <lambdabot>  "8"
07:54:33 <TheKing444> See how the $ helps.
07:54:55 <darthdeus> haskell associates the other way compared to what you'd expect in most other languages
07:54:56 <TheKing444> Oh, and lambda bot is the archnemsis of ghci.
07:54:58 <athan> vlabs: The journey has just begun
07:55:00 <TheKing444> lambda bot hates IO
07:55:15 <darthdeus> is anyone around here using fay?
07:55:16 <darthdeus> please :P
07:55:20 <vlabs> athan: :) I've used haskell before, just never bothered to understand it :P
07:55:22 <athan> I wish!!
07:55:34 <vlabs> darthdeus: fay?
07:55:35 <TheKing444> Haste is better than Fay I hear.
07:55:36 <athan> darthdeus: Soon I will be :(
07:55:39 <darthdeus> https://github.com/faylang/fay
07:55:44 <TheKing444> You should look at Haste.App
07:55:46 <athan> vlabs: Haskell dialect that compiles to JS
07:55:53 <darthdeus> athan: nay idea why this is happening? https://github.com/faylang/fay/issues/408
07:56:01 <darthdeus> TheKing444: haste doesn't work on 7.8 atm
07:56:05 <TheKing444> You can run haskell in your browser!
07:56:06 <vlabs> oh wow, that's awesome
07:56:12 <TheKing444> What is atm again?
07:56:15 <vlabs> wad67: ping?
07:56:16 <darthdeus> I was playing around with both fay and haste until 6am today
07:56:17 <darthdeus> at the moment
07:56:18 <the_berserker> @pl \f g x y -> g f (y x)
07:56:18 <lambdabot> flip flip (flip id) . (((.) . (.)) .) . flip id
07:56:29 <athan> vlabs: Haskell can implement compilers pretty easilly
07:56:34 <athan> check out BNFC
07:56:40 <darthdeus> but it came down to Fay working and having better FFI imho
07:57:01 <TheKing444> With Haste, you can write one program, that is both the browser client and the server!
07:57:03 <athan> darthdeus: Ill dig into this
07:57:04 <darthdeus> the_berserker: yesod-fay works almost the same as Haste.App
07:57:08 <vlabs> athan: cool!
07:57:08 <TheKing444> Automatic type checked communication.
07:57:11 <darthdeus> TheKing444: you can do that with fay as well :)
07:57:20 <athan> TheKing444: !!!
07:57:22 <vlabs> Haskell can dynamically load other haskell modules right?
07:57:25 <darthdeus> TheKing444: check out this https://github.com/darthdeus/fayde/blob/master/fay/Home.hs#L37 it's basically typed ajax
07:57:34 <vlabs> I'm trying to write a metalsmith clone in haskell for funsies
07:57:40 <TheKing444> Fay has no monads though.
07:57:45 <TheKing444> Except its weird Fay monad.
07:57:53 <darthdeus> oh really?
07:57:55 <darthdeus> hmm
07:57:59 <TheKing444> I had to rewrite my entire module, just because I had an error checking monad.
07:58:02 <TheKing444> FAY IS EVIL.
07:58:07 <vlabs> xD
07:58:09 <darthdeus> but haste doesn't work :(
07:58:12 <TheKing444> USE COLD METAL TO DEFEAT FAY!
07:58:17 <vlabs> hm, why doesn't /nick work here?
07:58:19 <darthdeus> i mean it's FFI is horrible
07:58:31 <darthdeus> vlabs: works for me
07:58:42 <vlabs> darthdeus: that's odd. doesn't work for me
07:58:45 <athan> vlabs: mmm.... idk about that. You generally just tell cabal about all the modules & packages you'd need, and ghc does the rest. _Dynamically_ loading modules might be some tricky stuff
07:58:54 <darthdeus> TheKing444: maybe I'm missing something, but do you always have to wrap things like object access in a function in Haste?
07:58:59 <saikrishna> NICK saikrishna
07:59:05 <saikrishna> sry
07:59:06 <TheKing444> Wait, I remeber a module for hot patching.
07:59:09 <saikrishna> trying something
07:59:17 <darthdeus> TheKing444: I mean it seems incredibly sensible to just do setInnerHTML :: Element -> String -> Fay (); setInnerHTML = ffi "%1.innerHTML=%2"
07:59:32 <TheKing444> https://hackage.haskell.org/package/hotswap
07:59:34 <darthdeus> http://hackage.haskell.org/package/hint
07:59:34 <vlabs> System.Plugins.Load
07:59:43 <darthdeus> hint can hotswap code as well afaik
07:59:52 <TheKing444> I don't know.
07:59:52 <athan> :O
08:00:12 <vlabs> haskell docs seem more like incantations than docs >_>
08:00:21 <TheKing444> darthdeus Last time I checked Haste had a big DOM library.
08:00:35 <darthdeus> TheKing444: yeah but what if you want to wrap a framework?
08:00:37 <athan> vlabs: Yeah... lol
08:00:42 <TheKing444> Once you learn the incantations, you never go back to English.
08:01:03 <athan> ...Grammatical Framework...
08:01:04 <vlabs> TheKing444: :)
08:01:07 <TheKing444> I think you could use Haste.App with a framework.
08:01:09 <TheKing444> Probably
08:01:16 <vlabs> athan: more like denotational semantics
08:01:37 <darthdeus> but how about wrapping something like react.js? it seems too limiting to not be able to ffi arbitrary js string
08:01:40 <athan> vlabs: I'm joking :P. I wish I knew more about that, though
08:01:43 <darthdeus> or maybe i'm missing something
08:01:57 <athan> I'm still going through discrete mathematics. Then I'll take on types and programming languages
08:01:59 <TheKing444> I think they have ffi too now in Haste.
08:02:23 <vlabs> athan: wish I even knew that much ;_; I feel so.. insignificant sometimes
08:02:31 <darthdeus> TheKing444: there's one function but it's not documented :(
08:02:57 <athan> vlabs: Don't let us fool you! We are all like you!
08:03:06 <darthdeus> TheKing444: but you've convinced me to give it another try
08:03:12 <vlabs> athan: I wish :)
08:03:18 <athan> It's just a hobby, an interest that people have spent time on :P
08:03:29 <athan> nothing to be possessive of, or exclusive
08:03:34 <TheKing444> I haven't actually try it except for their window box a little.
08:03:40 <vlabs> athan: true!
08:03:43 <TheKing444> I just had a bad experince with Fay.
08:03:56 <darthdeus> hmm
08:04:01 <vlabs> TheKing444: what are you writing with Haskell?
08:04:09 <TheKing444> (It would be like calling Javascript a dialect of Java.)
08:04:22 <TheKing444> Oh, I just made this Go thing for a school project.
08:04:25 <athan> ahhhh
08:04:29 <TheKing444> It turned out okay.
08:04:30 <darthdeus> well i had bad experience with it as well :D but it must be good if fpcomplete is using it
08:04:36 <darthdeus> and many others are using it as well
08:04:39 <darthdeus> and it's not a new project ...
08:04:45 <TheKing444> It would have been better if I payed attention tot he word dialect though.
08:04:52 <athan> There's an html library that works with fay, too... I can'
08:04:55 <athan> t remember its name
08:05:20 <athan> darthdeus: I'm trying to change that, btw :3
08:05:20 <TheKing444> Do they atleast of Monads yetL
08:05:22 <TheKing444> ?
08:05:32 <TheKing444> I know Haste is completely haskell.
08:05:42 <darthdeus> athan: change the bad experience or the html thingy?
08:05:45 <TheKing444> The only libraries that need ported are compiler specific ones.
08:05:47 <darthdeus> athan: why did you choose fay?
08:06:03 <darthdeus> TheKing444: yeah but now they have to rewrite a bunch of stuff to support 7.6 and 7.8 together
08:06:03 <athan> oh, sorry, I'm making a whole new front-end suite
08:06:07 <athan> it's going to be insane
08:06:15 <deni> newb question if i do "let t = getRequest url" in the repl and then i do t<CR> the function gets executed, because of lazy evaluation and that's fine, but then when i do t<CR> again the get request is repeated obviously. How would I keep the return value of that function? and not re-execute it?
08:06:33 <vlabs> a <- 5; print a doesn't work. why?
08:06:53 <vlabs> athan: front end suite for?
08:06:57 <TheKing444> because 5 is not in a monad
08:07:04 <athan> vlabs: Web / UI design
08:07:08 <athan> and also cluster networks
08:07:12 <TheKing444> When you use the arrow in ghci, it must be in the IO monad
08:07:26 <athan> it's not necessarilly just web, though
08:07:32 <athan> I want it to be used in 3d applications as well
08:07:38 <athan> it's a weird project
08:07:41 <darthdeus> athan: why in fay?
08:07:44 <athan> all on paper right now
08:07:45 <vlabs> TheKing444: so.. x <- y means "assign x to y " right? so why the restriction of IO ?
08:07:51 <athan> darthdeus: No! Not in fay, sorry xD
08:07:53 <vlabs> athan: seems interesting!
08:08:07 <vlabs> well, "assign" is a shaky term
08:08:07 <darthdeus> vlabs: x <- y    means    y >>= \x -> ...
08:08:08 <athan> vlabs: Thank you :) I have been reforming it for years
08:08:14 <darthdeus> athan: ah :( in what then?
08:08:15 <TheKing444> No, x<-y means y >>= (x >- rest Of Ghci session)
08:08:27 <vlabs> TheKing444: outside of ghci.
08:08:30 <vlabs> TheKing444: in main
08:08:33 <athan> darthdaus: ...haskell... kinda hahaha. I may throw in some Omega-like stuff
08:08:36 <athan> it's going to be interesting
08:08:36 <TheKing444> let x = y means assign x to y
08:08:48 <darthdeus> no, let x = y   means bind x to y
08:08:54 <darthdeus> y to x*
08:08:58 <darthdeus> there's no assign :P
08:08:58 <athan> the compilation to javascript isn't as important as the clean design at the moment
08:09:01 <TheKing444> Isn't that what assign means?
08:09:04 <vlabs> darthdeus, TheKing444: so do is a repeated <- ?
08:09:16 <athan> but I want it to stand on shoulders of giants arbitrarilly, so you can choose which foundations you're leveraging
08:09:17 <vlabs> TheKing444: assign implies mutability aFAIK
08:09:22 <darthdeus> vlabs: do is a syntactic sugar for >>= and >>
08:09:28 <TheKing444> That is how do works, which then turns it into >>=.
08:09:31 <deni> bah nevermind....i'm looking at this totally wrong
08:09:38 <athan> if I could get it to cooperate with Bower, Yeoman, and different communications protocols, that would be dandy also
08:09:51 <athan> it's just a weird monstrous appendage at the moment lol
08:09:51 <darthdeus> athan: uhm but how will you compile the haskell?
08:10:08 <athan> darthdeus: The framework will be in haskell
08:10:13 <luite> vlabs: there is no mutability, if you do 'x <-' multiple times, then they just bind a new 'x' that shadows the old
08:10:13 <vlabs> darthdeus: wait, *outside of GHCI*, in main, what does x <- 5 mean? like, what does it translate to?
08:10:23 <vlabs> luite: oh, I see
08:10:48 <darthdeus> vlabs: x <- 5 isn't valid :) since 5 isn't in a monad ... but you could have something like    do { x <- return 5; print x }
08:10:59 <TheKing444> x <- 5 translates into 5 >>= (\x -> rest of do block
08:11:02 <darthdeus> TheKing444: have you tried purescript?
08:11:07 <TheKing444> It also doesn't make sense.
08:11:11 <TheKing444> No, what's that?
08:11:26 <darthdeus> haskell-ish dialect that compiles to very small JS http://purescript.readthedocs.org/
08:11:27 <athan> darthdeus: It's going to be weird... My goal is to make web development browser-bug free, a way to create polymorphic presentations, automatic SEO, and to have it FFI/cooperate with existing projects like GSAP
08:11:47 <darthdeus> it's not haskell compatible, but it's also very close to JS
08:11:55 <TheKing444> heard of ghcjs?
08:11:58 <darthdeus> athan: so basically you're creating another fay/haste thingy?
08:12:07 <darthdeus> yeah, but ghcjs has huge output, no?
08:12:09 <athan> darthdeus: Kinda. It's more expansive I think
08:12:15 <TheKing444> I think so.
08:12:19 <athan> it's not just for Web, the web stuff will be a backend
08:12:28 <darthdeus> athan: do you have a repo I can star and watch? :P
08:12:29 <athan> that's why I want dependent types
08:12:32 <darthdeus> or is it a secret
08:12:34 <athan> not yet xD
08:12:37 <darthdeus> :D
08:12:40 <athan> I've got a github though!
08:12:48 <athan> with weird organizations atm :P
08:12:58 <darthdeus> I also thought about using idris, but that's still a few weeks/month for me to learn and understand
08:13:01 <darthdeus> athan: link
08:13:01 <athan> I'll definitely let you know, I think I saw you on there :)
08:13:19 <athan> https://github.com/athanclark
08:13:32 <athan> darthdeus: It's really handy
08:13:35 <TheKing444> purescript looks a lot like haskell
08:13:39 <TheKing444> What is different?
08:13:43 <vlabs> okay, so, do a <- 5; print a; becomes  5 >>= \x print x ?
08:13:45 <darthdeus> you can use my SASS compiler for your websuite :P
08:13:47 <athan> you can automate a lot of proofs and deductions with it
08:14:05 <darthdeus> TheKing444: the syntax is about 95% the same, there are some things different, like types for anonymous JS objects
08:14:08 <TheKing444> sort of, still doesn't make since
08:14:15 <TheKing444> @type >>=
08:14:16 <lambdabot> parse error on input ‘>>=’
08:14:17 <vlabs> which will not compile because \x print x does not qualify the type signature a -> mb right?
08:14:26 <TheKing444> @type (>>=)
08:14:27 <lambdabot> Monad m => m a -> (a -> m b) -> m b
08:14:33 <vlabs> TheKing444: Ik it doens't make sense
08:14:34 <deni> i'm finding the idea of making a "memory cache"(ie. to not make a http get request if i already have the stuff handy in local memory) in haskell quite hard to get my head around....in imperative languages I would just have a global hashmap wich I would populate with the values that i get from the remote API, and clear it when needed.
08:14:37 <TheKing444> See, 5>>= whatever makes no since
08:14:40 <darthdeus> TheKing444: check out the output size http://tryps.functorial.com/, it's really really small
08:14:45 <vlabs> I'm just trying to see what happens
08:14:49 <deni> not sure how to do this in haskell as I don't get to have global mutable hash map
08:14:50 <athan> darthdeus: I wrote a proving / deduction system for the towers-of-hanoi problem, except I gave it way more options - like arbitrary stacks, arbitrary pillar numbers, and specialized routes between the tiers
08:14:54 <TheKing444> a <- return 5; print 5 would make since
08:15:08 <TheKing444> @undo do {a<- return 5; print a}
08:15:08 <lambdabot> return 5 >>= \ a -> print a
08:15:21 <TheKing444> @undo do {a <- 5; print a}
08:15:21 <lambdabot> 5 >>= \ a -> print a
08:15:24 <c_wraith> deni: if you throw out the word "global", it's easy.  And you should do that in any language, since globals have all those bad properties you don't like anyway
08:15:25 <deni> trying to figure out if I can use a state monad for this...but not sure
08:15:26 <vlabs> TheKing444: right, najes sebse
08:15:33 <vlabs> makes sense*
08:15:35 <TheKing444> vlabs, play with @undo
08:15:41 <athan> darthdeus: *pucks up spaghetti from floor* sorry, I get ahead of myself sometimes :P
08:15:45 <vlabs> TheKing444: is it present in ghc?
08:15:50 <c_wraith> deni: no, state monad doesn't work - at least in a concurrent setting, which is where I want that sort of thing most.
08:15:51 <TheKing444> (I am suprised it didn't complain at our nonsense.)
08:15:54 <TheKing444> @undo?
08:15:54 <lambdabot> Error: expected a Haskell expression or declaration
08:15:56 <deni> c_wraith: i know that they do, but how would i create a local memory memoization otherwise?
08:15:59 <vlabs> yeah, @undo
08:16:03 <TheKing444> Nope, only lambda bot has it.
08:16:07 <vlabs> TheKing444: oh :(
08:16:13 <TheKing444> You can download lambda bot though.
08:16:18 <vlabs> TheKing444: from where?
08:16:19 <TheKing444> You can also talk with it one on one.
08:16:31 <vlabs> by connecting to #lambdabot?
08:16:31 <c_wraith> deni: pass around a mutable table. Either explicitly or implicitly.
08:16:35 <deni> c_wraith: that sentece up there meant i know it has bad properties
08:16:39 <TheKing444> http://www.haskell.org/haskellwiki/Lambdabot
08:16:49 <TheKing444> No, what irc client are you using?
08:17:07 <vlabs> TheKing444: weechat!
08:17:12 <deni> c_wraith: then each concurrent thread would have it's own local storage
08:17:16 <c_wraith> deni: or if the code using it is small enough, you could just close over it.
08:17:20 <c_wraith> deni: not if the table is mutable
08:17:33 <TheKing444> You should be able to right click lambda bot.
08:17:49 <deni> c_wraith: what haskell datastructure would i use for that?
08:17:53 <vlabs> TheKing444: it takes me to labdabot/ :)
08:17:59 <vlabs> TheKing444: on chrome on less :P
08:18:09 <c_wraith> deni: there are about 100 options, depending on what characteristics you want.
08:18:09 <vlabs> and command + click unfortunately.
08:18:10 <deni> c_wraith: and what do you mean by close over it?
08:18:49 <darthdeus> athan: lolz
08:19:09 <c_wraith> deni: closing over a value is when you produce a second value that uses the first because the first value is still in scope.
08:19:15 <deni> c_wraith: i'm going for explicit passing, because i need to be able to switch the "local memory cache" for a different kind of cache...like a redis instance or something
08:20:00 <deni> c_wraith: so a closure?
08:20:19 <c_wraith> deni: yes, a closure closes over things.  They have the same name for a reason.
08:20:46 <c_wraith> deni: closure is what's created.  closing over is the process by which it's created.
08:20:47 <deni> c_wraith: :)
08:20:57 <deni> c_wraith: naming matters yes
08:20:59 <TheKing444> @dice 3d6+4d2+2
08:20:59 <lambdabot> TheKing444: (4+4+5) + 7 + 2 => 22
08:21:16 <dreams> Would you agree that it wouldn't make sense to comment Haskell code?
08:21:23 <c_wraith> deni: anyway, if you want to make this configurable, I recommend passing around the operations, not the data structure itself.
08:21:32 <vlabs> dreams: what? why not?
08:21:49 <athan> TheKing444: o.o
08:21:59 <deni> c_wraith: was just about to mention that yes....i can pass around the functions for getting, and setting stuff in the cache
08:22:22 <c_wraith> deni: and you probably want to package them in a record, just to make it easier
08:22:23 <deni> c_wraith: for the local memory part you mentioned there are about a hundred options
08:22:39 <deni> c_wraith: for the datastructure i mean....
08:22:53 <deni> i was thinking of using a simple map
08:23:04 <vlabs> Question: what's the relationship between haskell's monad and category theoy's monoid?
08:23:16 <TheKing444> Uhm
08:23:26 <athan> vlabs: So a monad
08:23:30 <deni> vlabs: "a monad is just a monoid in the class of endofunctors" famous quote
08:23:33 <c_wraith> deni: The basic concurrent mutable primitives are IORef, MVar, and TVar.  You then have tons of options on how to use each them.
08:23:35 <TheKing444> Category theory doesn't deal with monoids that much.
08:23:43 <athan> vlabs: deni ^
08:23:46 <benzrf> monoids
08:24:03 <TheKing444> Category theory does have Monads though.
08:24:07 <dreams> vlabs: I got into a debate with someone who claimed that is no implication in Haskell code therefore commenting the code would not make a difference. Basically this started after I noted that his code does not include comments at all but one.
08:24:09 <vlabs> deni: yeah, I've read the quote -_^ hardly tells me anything
08:24:46 <c_wraith> deni: the simplest approach is just storing something like a Map in an MVar.  It has the most predictable performance, though it *will* be a bottleneck if it's used heavily.
08:24:52 <deni> vlabs: i know, was meant to be funny :)
08:24:55 <athan> vlabs: so you know what a monoid is, right?
08:25:10 <vlabs> http://stackoverflow.com/questions/3870088/a-monad-is-just-a-monoid-in-the-category-of-endofunctors-whats-the-problem
08:25:25 <deni> c_wraith: so i would put for instnace a Map in an MVar. should be good for concurrency as well
08:25:26 <vlabs> athan: nope. nada. I know nothing of category theory other than what the arrows do
08:25:56 <vlabs> athan: I do know some topology if that helps
08:26:19 <c_wraith> deni: just be sure you don't introduce a space leak that way - it's really easy for a map in an MVar to grow without bound if you never force it to be evaluated sufficiently.
08:27:31 <deni> c_wraith: how does one deal with this? it's has to e evaluated cause all the get requests will look in the cache first before making a request to the real API
08:28:19 <deni> still I don't think a memory leak will be an issue for this particular case...ie. there isn't that much data
08:28:31 <c_wraith> deni: if that's the use case, you'll probably be fine.  Just be aware of the fact that if part of the map holds references to previous versions of the map, the growth can be painful.
08:28:43 <xenomachina> Why is it that I can write "(fmap . const) 5 [1,2,3,4,5]" but if I try to "let foo = (fmap . const)" ghci blows up with "No instance for (Functor f0) arising from a use of `fmap'"?
08:29:00 <c_wraith> deni: you might not run into the problem here, but it's likely you will at some future point.  Just remember that it can happen, so you can easily fix it when you do. :)
08:29:01 <systemfault> You know my worst problem with learning haskell right now… learning all the new terms that other programming language don’t have :/
08:29:35 <systemfault> morphism.. isomorphism.. functor… endofunctor…monoid.. monad.. applicative… arrows… and all those wods.
08:29:36 <frerich> Is there an existing function already which behaves like 'f xs = if null xs then Nothing else Just xs'?
08:29:37 <systemfault> words
08:29:48 <deni> c_wraith: what's the correct way to fix something like this then?
08:29:54 <vanila> systemfault, you only need to know functor then applicative then monad
08:29:59 <deni> c_wraith: when you said it was easily done :)
08:30:02 <c_wraith> systemfault: that's a good thing. Those terms are used to describe abstractions which are useful!
08:30:05 <deni> c_wraith: might as well do it right now
08:30:54 <c_wraith> deni: It depends on what's being stored.  In general, you want to make sure whatever you put in the MVar is fully evaluated.
08:31:00 <systemfault> c_wraith: Just saying that it’s an additional overhead to learning the language. And I’m still confused by the similarities with applicative/functor/monads
08:31:13 <xenomachina> vanila: and lens and prism and MonadTransformer.
08:31:13 <c_wraith> systemfault: the reason they don't show up in other languages is that those languages don't have the facilities to *support* those abstractions.
08:31:13 <systemfault> c_wraith: I’m still learning and love the language so far :)
08:31:23 <vanila> no don't learn lens or prism
08:31:38 <vanila> monad transform is advanced you don't need that until you understand monads fine
08:31:46 <xenomachina> vanila: and you have to get around the misuse of the word "state".
08:31:55 <matematikaadit> @slap matematikaadit
08:31:55 * lambdabot beats up matematikaadit
08:32:00 <c_wraith> I actually found monad transformers easier to grasp than monads.  They were less abstract.
08:33:00 <deni> c_wraith: so using evaluate instead of return should help there?
08:33:18 <c_wraith> deni: In the case of Data.Map.Strict (use the Strict variant, it makes it easier), this would mean making sure that whenever you add a key/value pair, make sure both the key and the value are fully evaluated.  Then make sure that you seq (or equivalent) the map before putting it back into the MVar.
08:35:06 <deni> c_wraith: tnx. this is very helpfull
08:35:08 <c_wraith> deni: possibly.  evaluate is an alternative to seq, but neither does the job completely on a String value, for instance.  How you actually do it has to be based on the types being stored, at least to some extent.
08:35:34 <monochrom> if "morphism.. isomorphism.. functor… endofunctor…monoid.. monad.. applicative… arrows…" are overhead words, then so are "object, class, subclassing, prototype, the Liskov substitution principle"
08:36:00 <c_wraith> It's rare to see an OO hierarchy that actually obeys the LSP.
08:36:00 <monochrom> the logical conclusion is to go back to Algol.
08:36:40 <Yuu_chan> monochrom: you forgot «strategy, command, factory, prototype, singleton, template method»
08:37:01 <monochrom> yes, I forgot a lot of those. good riddance!
08:37:23 <Yuu_chan> ^_^
08:37:35 <c_wraith> deni: really, this is something that just takes some experience to figure out.  deepseq is available as a brute-force solution in a lot of cases, but it's often an asymptotic overhead because it doesn't get to take advantage of things you already know.
08:37:56 <systemfault> The OO patterns or even the SOLID principles are not required to learn a language though..
08:38:29 <c_wraith> deni: also, sometimes you *do* want to store a structure unevaluated.  An infinite list, for instance. :)  There are no hard and fast rules here.
08:38:42 <monochrom> "object, class, subclassing" is not required to learn java? "object, prototype" is not required to learn javascript? don't kid me.
08:38:54 <systemfault> monochrom: Those are needed, of course..
08:38:59 <Yuu_chan> c_wraith: some of those languages actually could support those abstractions. For example, C++ has operator >>=!
08:39:03 <averell> it's not as much as you don't need to learn monad to use IO in haskell
08:39:15 <c_wraith> Yuu_chan: yes, but it's painful to use.
08:39:58 <monochrom> and "class" for example is an overhead word as much as "monad" is, because "class" is a fancy word for a record of data and procedures. and oh, they don't say "procedure", they have to make you say "method", one more overhead word.
08:41:14 <systemfault> monochrom: It’s probably because I’m still learning haskell but the idea of functor/monoid/monads still feel a lot more abstract than a stupid class (which can be vulgarized as being the blueprint of an object)
08:42:19 <deni> systemfault: that's the difference between the meaning of the words simple and easy/familiar
08:42:30 <deni> systemfault: you're just more familiar with these concepts so they seem natural
08:42:35 <systemfault> deni: I saw the video by Rich Hickey :P
08:42:38 <Nahiyan> what could I do to get something as: [1..500] - [1,3..] where this would mean removing 1,3,6,9.. from [1..500]
08:42:48 <Nahiyan> other than list comprehensions
08:42:52 <deni> systemfault: the truth is that you had to learn them the same way you are learning haskell terms
08:43:06 <deni> systemfault: that's the way i see it at least
08:43:08 <sharyari_> I have a function f :: [a] -> [[a]]. I'm trying to map that to a set of [a], but I can't seem to figure out how to do it without converting back and forth to a list. Can someone solve this for me maybe? Right now I'm doing: S.fromList $ L.concat $ L.map f $ S.toList set
08:43:17 <averell> i'd say explaining a monad to a child will be a lot harder than doing that for object/class
08:43:24 <Nahiyan> I don't want to include Data.Set because I am making it as short as possible
08:43:25 <Yuu_chan> Eight years ago, that was "I'm still learning Pascal but the idea of a pointer still feels a lot more abstract than a stupid variable" for me
08:43:47 * hackagebot property-list 0.1.0.3 - Apple property list parser  http://hackage.haskell.org/package/property-list-0.1.0.3 (JamesCook)
08:44:11 <Yuu_chan> Then it was "I'm still learning C++ but the idea of a class still feels a lot more abstract than a stupid record with fields"
08:44:38 <Nahiyan> I suppose C++ classes are useful for organisation
08:45:13 <Nahiyan> but then it replaced things like printf with cout for no reason
08:45:23 <Nahiyan> although I'm sure there's a reson
08:45:26 <systemfault> deni: I totally agree with you. Just said that they feel more abstract to me. Just look on google for monad tutorials… seems that nobody can explain them properly. Actually, I started to understand them when someone suggested me to read  the actual Wadler paper instead of the crap you can find on google.
08:45:27 <Nahiyan> reason*
08:45:29 <Yuu_chan> That's very natural that each language offers something new to learn. That's GOOD that Haskell has a whole bunch of new stuff.
08:45:58 <napping> athan: have you seen Ur/Web?
08:46:49 <Yuu_chan> Nahiyan: I think there are good reasons for replacing printf with cout which justify its verbosity.
08:47:15 <systemfault> Nahiyan: An haskeller is supposed to understand the notion of typesafety...
08:47:17 <systemfault> Weird.
08:47:28 <Yuu_chan> (huh, right one or two days ago we discussed matters of typesafe formatted output right here)
08:47:32 <systemfault> Should be an argument good enough to use cout instead of printf in C++
08:48:06 * Yuu_chan still tends to use printf in Haskell :'(
08:48:06 <athan> napping: o.O
08:48:42 <zwer> > filter (`notElem` [1,3..500]) [1..500]
08:48:44 <lambdabot>  [2,4,6,8,10,12,14,16,18,20,22,24,26,28,30,32,34,36,38,40,42,44,46,48,50,52,5...
08:48:46 <zwer> Nahiyan ^^
08:49:18 <athan> napping: Holy...
08:49:22 <monochrom> systemfault: I did not understand the explanations "a class is a template/blueprint for objects" until I understood class itself. in other words it was of negative help value.
08:49:45 <Nahiyan> ahh
08:50:16 <Yuu_chan> systemfault: I have a thought that if classes weren't mainstream there would be lots of crappy tutorials like "Classes are burritos" as well
08:50:18 <monochrom> I had to use "class" to explain "blueprint/template". fancy that!
08:50:58 <yogurt_truck> Yuu_chan: there already are
08:51:01 <systemfault> Yuu_chan: Haha, you could very well be right :D
08:51:51 <monochrom> there were a lot of that kind of crappy tutorials. I was there back then.
08:51:52 <yogurt_truck> hell, there are infinitely more "OOP is about classes/no, messages/no, burritos/astronauts/etc" articles than there are crappy monad articles
08:51:54 <zwer> Nahiyan or even better if you actually just want to remove odd numbers: filter even [1..500]
08:52:11 <cschneid> I like the trend of all programming actually just being burritos.
08:52:33 <monochrom> but it was also before the days of popular internet, so you don't get to see them. they were in books and magazines.
08:53:54 <Yuu_chan> monochrom: couldn't you remember one?
08:54:16 <monochrom> no. I avoided reading them anyway.
08:58:48 * hackagebot monad-loops 0.4.2.1 - Monadic loops  http://hackage.haskell.org/package/monad-loops-0.4.2.1 (JamesCook)
08:59:32 <Yuu_chan> yougurt_truck: I think the difference is that classes are so much prevalent that most programmers learn it intuitively and don't bother with reading articles. And that would be the same if they encountered a lot of monads everyday.
09:00:06 <Yuu_chan> yogurt_truck: sorry for weird misspelling of your nickname <_<
09:01:34 <monochrom> the internet is a great learning source, but only if you have a good BS-meter
09:01:54 <hexagoxel> for "cabal install", there is -w to set the compiler to use. why does this flag not exist for "cabal build"/"cabal repl"? what can i do instead?
09:02:07 <c_wraith> Yuu_chan: based on the introductory computer science classes I took, I'd say learning classes was a hugely painful deal for many people..
09:02:18 <monochrom> a rule of thumb: if you classify 90% of internet articles as "words of wisdom" rather than "BS", your BS-meter is wrong
09:02:26 <rwbarton> hexagoxel: use -w when you cabal configure
09:02:37 <rwbarton> for cabal build at least; not sure about cabal repl
09:02:39 <monochrom> another rule of thumb: if an article's code-to-essay ratio is lower than LYAH's, it's BS.
09:02:50 <hexagoxel> rwbarton: ok, thanks
09:04:17 <monochrom> and yes, to objectively measure the difficulty of learning OOP and see that it's as high as learning FP, you've got to look at 1st year students
09:04:35 <hexagoxel> rwbarton: seems to work for both build and repl
09:04:40 <monochrom> because you have 99.9% of forgetting what it was like when you were 1st year
09:04:46 <vlabs> monochrom: I'm interning at an institute, and I find that explaining OOP is way easier than explaining FP
09:04:47 <Yuu_chan> c_wraith: I don't remember exactly how classes were teached to us — in very lay terms probably, but eventually we managed to understand them "somehow"
09:04:55 <vlabs> well, not "way easier" but "easier"
09:05:11 <vlabs> monochrom: people seem to be able to visualize objects better than functions
09:05:30 <Yuu_chan> vlabs: people with which experience?
09:05:33 <yogurt_truck> how can OOP be "easier"? it's an extremely poorly defined concept
09:05:39 <vlabs> Yuu_chan: 19 year olds :)
09:06:18 <monochrom> we'll use vlabs's definition of OOP for this discussion and spare ourselves another round of "what is OOP"
09:06:20 <vlabs> Yuu_chan: so, well, close to no experience
09:06:37 <Yuu_chan> vlabs: I mean, did they program before?
09:07:10 <vlabs> Yuu_chan: a little, some in python, others in C (and those who had programmed in python had not known about objects)
09:07:15 <yitz> vlabs: do they know enough math to be very comfortable with the concept of functions in math?
09:07:21 <vlabs> Yuu_chan: my sample size is not large though.
09:07:23 <Yuu_chan> I teach a small FP course to 3rd year university students, and that's... hard due to baby duck syndrome
09:07:26 <vlabs> yitz: yep, I am
09:07:30 <monochrom> well, I guess it helps that an object is glorified data, and you get to imagine data to be concrete and procedures ethereal
09:07:37 <yitz> vlabs: no the people you are trying explain FP to
09:08:13 <vlabs> yitz: well, I suppose. the institution's entrance exam has Calc 2 in it. so.. I'm assuming they do
09:08:24 <vlabs> yitz: I can't really judge though
09:08:37 <monochrom> but I'm still unconvinced. when I teach FP, I teach data-centrically too
09:08:51 <vlabs> monochrom: what do you define as 'FP' ?
09:09:24 <monochrom> I first say "we have Int's, Char's, Bool's... we can write functions to process them"
09:10:00 <vlabs> Yuu_chan: do you teach often?
09:10:04 <monochrom> then I say "w00t we can define algebraic data types too! let's define some, and write more functions to proces them"
09:10:14 <yitz> monochrom: that's not the same thing as the "data-centric" of teaching an OO language
09:10:32 <vlabs> yitz: so what is "data centric" ?
09:11:05 <monochrom> and then I'll talk about foldr and map. but only after showing some boilerplate code that could use the help of foldr and map
09:12:22 <vlabs> monochrom: ah. I explained how functions are first class, then continued with map, filter.
09:12:22 <monochrom> and really my story looks like a very elementary OOP story with French words
09:12:40 <yitz> vlabs: saying things like "store the int in the variable x, increment it, store that in y, loop with z taking on the values from 1 to 10, etc."
09:12:43 <shapr> tres bien!
09:13:07 <systemfault> Génial
09:13:17 <vlabs> yitz: hm.
09:13:29 <vlabs> yitz: what was your experince with FP v/s OOP?
09:13:38 <yogurt_truck> FP *excels* at "data centric" teaching. data flow in terms of Input to Output, and function composition, etc. is familiar to anyone who ever connected a USB cable!
09:13:40 <Yuu_chan> vlabs: not quite, that's a spring single-semester course. 15 classes, one per week.
09:14:38 <Yuu_chan> vlabs: excuse me if I mixed up some specific terms, I once confused people here
09:14:50 <yitz> vlabs: why talk about functions being "first class", which is the most natural state of things, if they already aren't expecting then not to be first class? just say that the first argument of map is a "function, like f that we just defined above".
09:15:57 <vlabs> yitz: I just wanted them to be aware that such a distinction existed. didn't harp on it or anything :) And, well, I suppose you're right!
09:16:26 <yitz> vlabs: i was a very experienced OOP (and other imperative) programmer before i every heard of haskell. haskell was quite a shock.
09:16:48 <vlabs> yogurt_truck: was your first language an imperative language or a functional one?
09:17:05 <vlabs> yitz: same, Lisp felt *so weird* to program in
09:17:14 <yitz> vlabs: yeah, let them be shocked when they find out that they *can't* use functions that way in some other language :)
09:17:51 * magicman shudders at Java.
09:17:54 <yitz> vlabs: actually i did know some lisp, but not a lot.
09:18:06 <magicman> On the one hand. Yay, Java 8 has lambda and stuff. On the other hand, man, that stuff is ugly underneath.
09:18:13 <magicman> (still happy to use it, though >_>)
09:18:14 <vlabs> yitz: that should have made the transition much less harder
09:18:20 <vlabs> :)
09:18:22 <yitz> magicman: notice i said "some other language", not wanting to utter that word...
09:18:29 <vlabs> yitz: xD
09:18:45 <hexagoxel> rwbarton: let me correct my last statement: "cabal repl" works after "cabal configure -w..; cabal build", but "cabal configure -w..; cabal repl" does not work (and "cabal build" does not work after that one, either..)
09:19:18 <vlabs> yitz: I'm no expert on FP though.
09:19:32 <magicman> Heh. I'm required to mostly do Java-programming these days. But the guy who wrote the framework I'm using made sure that everything is immutable, and there's lambdas and method references everywhere.
09:19:37 <magicman> He might be a closeted Haskeller <_<
09:19:41 <hexagoxel> i probably use the wrong cabal version, or something
09:20:00 <yitz> magicman: cool. you're pretty lucky, for a java programmer.
09:20:10 <yitz> oops, there, i said it!
09:20:14 <magicman> XD
09:20:16 <averell> no kidding. already using a finished java 8 framework
09:20:19 <vlabs> magicman: I really hope that when I join someplace I'll be allowed to use Rust.
09:20:28 <vlabs> I don't mind C++ either. Java sucks though IMO
09:20:49 <moghedrin> vlabs: I would rather cut off my knee than deal with C++ or Java ever again XD
09:21:22 <monochrom> vlabs: http://www.cs.utoronto.ca/~trebla/fp/ is my FP course. but it's targetted at my close friends, they had long finished their CS degrees and gone into practice. nonetheless I thought hard on how to make things look elementary not high-horse. their education level meant only that I could go faster. my ingenuity was that I re-invented Piaget's theory: concrete before abstract, special before general.
09:21:38 <yogurt_truck> vlabs: ASM, perl, and C were my first torturers. Then Java. regardless of the language I was, though, the idea of something (a `sub` in perl, or a `function` in others, etc) *only* receiving some input and producing some output, without any other nonsense going on, was always the idea that seemed "sane" to me
09:21:48 <vlabs> moghedrin: aw come on, C++ is pretty nice once you learn the sharp corners. as long as you're careful. Java is just.. I don't like it. Rust is nice, even though it's new. D lost a long time ago and Go is irritating.
09:21:59 <rwbarton> hexagoxel: weird. i've never used cabal repl
09:22:10 <vlabs> monochrom: thanks!
09:22:11 <yogurt_truck> vlabs: ...and I guess that's why I eventually ended up moving to FP-land
09:22:36 <yitz> wow. piaget fp. gotta think more about that one.
09:22:38 <moghedrin> vlabs: Well, okay... I may have just had some PTSD flashback there ;) I suppose it's not SOOO bad.
09:22:47 <vlabs> moghedrin: :)
09:22:59 <napping> Rust is pretty interesting
09:23:20 <vlabs> napping: yeah, I really like it!
09:23:31 <vlabs> napping: it's like, what Scala should have been
09:23:39 <vlabs> napping: and what C++ should have been tbh
09:23:46 <napping> hmm, I'm not sure I'd relate it to Scala
09:23:59 <moghedrin> vlabs: I think I cried the first time I saw a class inherit from itself though. Conceptually, I don't think a language should allow that.
09:24:01 <napping> but it's definitely making a serious attempt to solve some low-level programming issues
09:24:01 <vlabs> napping: well, OOP + FP - Rust sits somewhere nicely in the middle
09:24:17 <magicman> Class. Inherit from itself. What? How. What?
09:24:19 <vlabs> napping: and it guarentees memory safety
09:24:26 <yogurt_truck> does Rust have higher kinded polymorphism?
09:24:26 <napping> Yeah, that's the really interesting bit
09:24:30 <vlabs> moghedrin: CRTP?
09:24:41 <monochrom> oh, Piaget's theory simply means: learn in the order integers -> fractions -> real numbers -> complex numbers -> fields -> universal algebra -> category theory, don't learn in the order category theory -> universal algebra -> fields -> complex numbers -> real numbers -> fractions -> integers
09:24:41 <napping> Higher kinded?
09:24:42 <vlabs> yogurt_truck: soon. HKT is being worked on
09:24:47 <napping> or higher rang?
09:25:18 <vlabs> magicman: I'm assuming moghedrin is talking about the curiosly recurring template pattern
09:25:28 <moghedrin> vlabs: Not quite, but it was pretty close.
09:25:36 <vlabs> moghedrin: what else?
09:26:06 <magicman> I think I prefer the J-word to C++. Though I haven't done much with C++ yet.
09:26:18 <napping> but yeah, Rust is actually interesting even as a language
09:26:45 <vlabs> magicman: no way, C++ offers you flexibility if nothing else. Java doesn't even give you wiggle room
09:26:45 <napping> I mean sure, there are popularity issues, or being built into every brower ever, or other things like that that may also make it a good idea to use a language
09:26:50 <magicman> (and the bit of C++ I've done was about 6 years ago <_<)
09:27:01 <napping> but even aside from that
09:27:09 <vlabs> napping: "popularity issues" ? it tops /r/programming like, thrice a month
09:27:16 <moghedrin> Honestly, I don't remember all that well. I remember it worked, and involved really atrocious templating. Hell, it could've been CRTP, it just didn't seem like it at the time.
09:27:22 <moghedrin> *shrug*
09:27:31 <napping> No, I'm listing positive reasons you might use a language even if the language itself isn't particularly nice
09:27:41 <vlabs> moghedrin: heh. yeah, metaprogramming is pretty damned insane all said and done
09:27:47 <vlabs> napping: oh, right :)
09:27:56 <napping> but Rust actually seems to be doing some things well that Haskell doesn't even try
09:27:59 <averell> i think the main reason java is popular post nowadays is that java is popular.
09:28:03 <vlabs> napping: like what?
09:28:15 <napping> the whole linear types/lifetime management stuff
09:28:17 <vlabs> averell: no, it's frameworks + libraries + familiarity
09:28:25 <vlabs> napping: yeah, but it's a bitch sometimes.
09:28:32 <identity> Anyone here use vim2hs? If so, do you ever have issues with gq all of a sudden being mapped to some shitty shortcut(think it's pl?) instead of what gq is normally mapped to, when writing stuff in filetypes that are *not* haskell?
09:28:39 <averell> which you would have in any other language if that was what every cheap programmer knew.
09:28:40 <napping> you can't really implement that sanely on top of a type system that doesn't already give you that substructural stuff
09:28:43 <identity> That is, I'm writing some markdown stuff and gq is trying to trigger pl on it.
09:29:04 <vlabs> identity: question - why use vim? ;_;
09:29:14 <moghedrin> vlabs: Yeah it is XD I was thrilled when I discovered how much easier TH was to use.
09:29:16 <napping> vlabs: even if it is, it's there, it's handle by the language, and they're making a decent go of making it actually useful
09:29:27 <identity> vlabs: Because vim is zen and it is the only correct path to nirvana.
09:29:40 <moghedrin> ^
09:29:48 <vlabs> napping: yeah, it's a nice language to use. although it's irritating sometimes, I'll take it gladly over a null pointer exception
09:29:58 <napping> I'm interested in some other rather dynamic languages doing interesting stuff nobody knows how to put a type system on
09:30:14 <napping> but Rust is one of very few typed languages that looks like I might want to actually use it
09:30:16 <vlabs> identity: xD
09:30:21 * magicman managed to let the build system give an NPE once.
09:30:28 <vlabs> identity: I personally prefer sublime text, but each to his own
09:30:29 <napping> Well, Agda and the like are fun too
09:30:34 <vlabs> identity: although SSH is a pain
09:30:56 <Hodapp> Rust does look compelling in some ways.
09:30:58 <magicman> Couldn't even compile the code to see if I had done anything stupid myself XD
09:31:10 <Yuu_chan> magicman: Java code of closeted FPers can be painful: http://govnokod.ru/14162
09:31:19 <moghedrin> vlabs: Ah! I remember now what it was. It was inheriting from a specialized template of itself.
09:31:29 <Hodapp> Yuu_chan: so can Java code of... everyone else :P
09:31:45 <magicman> That type!
09:32:17 <vlabs> sorry, idk why but weechat bugs once in a while >_>
09:32:50 <monochrom> http://www.vex.net/~trebla/humour/Nightmare.java
09:33:03 <systemfault> Yuu_chan: Haha, did something similar in the past using guava
09:33:23 <vlabs> monochrom: https://github.com/EnterpriseQualityCoding/FizzBuzzEnterpriseEdition
09:33:24 * Hodapp . o O ( guava? )
09:33:27 <systemfault> https://code.google.com/p/guava-libraries/wiki/FunctionalExplained
09:33:45 <Hodapp> vlabs: it's scary how relevant that is.
09:33:48 <vlabs> Hodapp: google's Java library
09:33:49 <systemfault> It’s the Google Java utility library.. a must for any java dev.
09:34:07 <systemfault> But see how it has .filter/.transform… etc..
09:35:11 <Yuu_chan> monochrom: may I please borrow some of your materials for my next course?
09:35:17 <monochrom> yes!
09:35:23 <vlabs> Hodapp: yeah ;_; I really hope I don't have to work with such Java code. C++ programmers may write crazy code, but they sure as hell don't write AbstractFactoryBeanFactoryStrategyCommand
09:35:29 <magicman> Time to craft me some UML. See ya.
09:35:43 <vlabs> Yuu_chan: can I pass your material to a prof I know?
09:35:50 <kini> why must the last statement in a 'do' block be an expression? wouldn't it make sense to just assume "return ()"?
09:35:58 <Hodapp> vlabs: ....yes, they do. I worked with plenty who did.
09:36:09 <Hodapp> vlabs: why? because OBJECT-ORIENTED ALL THE THINGS!
09:36:12 <vlabs> monochrom: can I have the link to your material again?
09:36:24 <monochrom> http://www.cs.utoronto.ca/~trebla/fp/
09:36:29 <vlabs> Hodapp: really? what field do you work on?
09:36:44 <comerijn> kini: Why would that make sense?
09:36:45 <systemfault> Anyway… nowadays, good C++ code is not entirely OO.
09:36:52 <vlabs> systemfault: yep
09:36:54 <Yuu_chan> vlabs: what my material?
09:37:01 <Hodapp> vlabs: the job I used to work was as a software developer and/or research engineer.
09:37:20 <vlabs> Yuu_chan: do you have some?
09:37:24 <Hodapp> vlabs: they developed a gigantic graphical(tm) client-server(tm) user-friendly(tm) enterprise(tm) application(tm)
09:37:31 <vlabs> Hodapp: ahh.
09:37:34 <kini> comerijn: oh, wait, never mind lol
09:37:47 <vlabs> Hodapp: most C++ code i've read is open source game related stuff (cause I've never had a job!)
09:38:17 <Yuu_chan> vlabs: yes, but it's all in Russian
09:38:37 <vlabs> Yuu_chan: oh :( that' sad.
09:39:05 <vlabs> Hodapp: are you allowed to use haskell where you work?
09:39:20 <Hodapp> where I am now, I can use what I want, provided that I deliver something.
09:39:31 <Hodapp> but since I'm programming an ARM Cortex M0, applications there are limited.
09:39:50 <vlabs> Hodapp: ah, low level code!
09:40:21 <Yuu_chan> vlabs: no need to be :) There are a lot of much more useful materials in English to fit any taste (which I simply can't use directly).
09:40:59 <vlabs> Yuu_chan: yeah, true :)
09:41:29 <Yuu_chan> Hodapp: I have faint memories of embedded Haskell via modified YHC or JHC...
09:41:47 <kini> I just wrote my first code that uses monad transformers -- can anyone see any obvious warts? http://lpaste.net/106391
09:42:08 <vlabs> what are monad transformers?
09:42:08 <Hodapp> Yuu_chan: isn't the runtime a bit heavy?
09:42:26 <vlabs> Hodapp: why does haskell need a runtime?
09:42:39 <tolt> Has anyone seen any sort of higher level expiring cache in haskell? I've used the Guava cache library a bit but I have pretty big need for an expiring cache with limits for queries.
09:43:05 <Yuu_chan> vlabs: the coolest moment was when I introduced achievements for students' tasks :)
09:43:13 <comerijn> vlabs: Same reason C needs a runtime?
09:43:26 <tolt> Also, if you're doing anything low level with VHDL you might want to check out http://christiaanb.github.io/clash2/
09:43:39 <Hodapp> tolt: I'm not that low-level
09:43:52 * hackagebot random-fu 0.2.6.0 - Random number generation  http://hackage.haskell.org/package/random-fu-0.2.6.0 (JamesCook)
09:43:54 <vlabs> comerijn: C's runtime is barely a "runtime"
09:44:02 <vlabs> comerijn: it just kicks things off and then leaves
09:44:28 <kini> vlabs: monad transformers are ways to create monads that sort of "do multiple things"
09:44:33 <Hodapp> Yuu_chan: I'd be interested though if any of these languages could compile tightly enough - and give some low-level control that I need - to run on something like a Cortex M0
09:44:36 <vlabs> kini: ah.
09:44:40 <kini> in my example, both IO and Maybe
09:44:45 <vlabs> Hodapp: rust?
09:44:52 <comerijn> vlabs: Sure, but there is one. Haskell's one just does slightly more kicking off (it provides garbage collection, for example)
09:44:55 <piezoid> hi
09:44:57 <Hodapp> vlabs: dunno, maybe...
09:44:58 <kini> MaybeT is a monad transformer that adds Maybe-like behavior to other monads, in my case IO
09:45:01 <piezoid> How should pass arround a Builder in a custom monad ? strict writer or state ?
09:45:04 <Hodapp> vlabs: I get the idea that Rust too has a much heavier runtime
09:45:06 <piezoid> because a Builder (like in Data.Text) is already a continuation based state monad
09:45:11 <tolt> Hodapp: Alright. I just thought it could be mentioned because it's a really cool library
09:45:28 <vlabs> Hodapp: really? you can strip rust down to bare minimum - hell, you can write a kernel with it
09:45:31 <Hodapp> tolt: yeah, I'm reading anyway...
09:45:38 <dreams> vlabs: https://ghc.haskell.org/trac/ghc/wiki/Commentary/Rts
09:45:50 <Hodapp> vlabs: 'bare minimum' here means that it better fit in 8 KB and still leave me room to do something
09:46:06 <vlabs> Hodapp: I.. don't know about that xD
09:46:10 <Yuu_chan> Hodapp: unfortunately I don't know particulars, you could take a look at http://ajhc.metasepi.org/
09:46:16 <geekosaur> vlabs: every language needs a runtime. even C has one, typically in crt0.o which is automatically linked into programs and in ld.so which is the "program loader" for executables. it performs housekeeping, sets up and tears down the execution environment, etc. in the case of Haskell, there is an I/O manager and the memory management (garbage collection)
09:46:20 * geekosaur sighs at local notwork
09:46:40 <Hodapp> vlabs: yeah, when I'm talking about a heavy runtime, I'm talking about relative to pretty barebones C
09:46:43 <vlabs> geekosaur: yeah, but C's runtime is really minimal
09:46:49 <vlabs> geekosaur: was what I meant.
09:46:50 <Hodapp> Yuu_chan: ooh, neat
09:46:55 <ReinH> geekosaur: and the parallel runtime! :D
09:46:58 <geekosaur> less so than you think, really
09:47:08 <geekosaur> also thread scheduler
09:47:13 <vlabs> geekosaur: Haskell uses GC cause it has thunks right?
09:47:20 <geekosaur> um?
09:47:32 <geekosaur> no, that's way oversimple
09:47:39 <Hodapp> I had to use a modified C runtime for this micro because stuff like printf was too large (and unnecessary)
09:47:42 <geekosaur> consider boehm-gc
09:47:54 <geekosaur> which is a garbage collector for C
09:48:26 <ReinH> geekosaur: and spark heap and work-stealing queues, and...
09:48:47 <napping> vlabs: more because it's pure/functional
09:49:05 <vlabs> napping: hm.
09:49:12 <napping> If you've got immutable data all over the place, how would you know when to free it, let alone make "free" something you could safely call
09:49:27 <ReinH> vlabs: if you're interested in understanding how a runtime for a functional language might work, I highly recommend SPJ's Implementation of Functional Langauges (1992) http://research.microsoft.com/en-us/um/people/simonpj/Papers/pj-lester-book/
09:49:32 <geekosaur> vlabs: haskell has GC because you don't manually allocate anything. (no malloc, ecept for use with the FFI)
09:49:45 <napping> Clean can actually maybe do that (and Rust does similar things)
09:50:05 <vlabs> geekosaur: right
09:50:11 <napping> ... if your type system/language can check that the argument to free is actually known to be the last reference, and stop you from using it afterwards, then it's safe to manually free
09:50:17 <vlabs> napping: Rust doesn't have a GC
09:50:25 <geekosaur> the closer a language is to the bare hardware, the smaller the runtime --- but any program has to make assumptions about its execution environment, and the runtime is what makes those assumptions valid
09:50:28 <vlabs> napping: well, it has reference counting in the stdlib
09:50:32 <vlabs> napping: not a GC though
09:50:39 <Hodapp> vlabs: Rust has an optional GC, I believel.
09:50:41 <napping> Yeah, I'm saying Rust and Clean are the only languages I know that have a sufficiently fancy type system to make manually calling free actually memory-safe
09:50:46 <Hodapp> believe*
09:50:51 <napping> \x -> free x >> free x in Haskell would be bad news
09:50:57 <vlabs> Hodapp: it has reference counting. The GC thing was never implemented AFAIK.
09:51:21 <napping> the equivalent in rust would be a type error about trying to use x after you no longer own it
09:51:29 <Hodapp> vlabs: oh, huh...
09:51:57 <deni> systemfault: reading blog posts that explain mondas is a mistake yes...they might as well say monads are burritos :D
09:51:59 <solidus-river> anyone got recommendations for a good matrix math lib
09:51:59 <Yuu_chan> napping: is that called "uniqueness typing"?
09:52:08 <napping> that's one name for it at least.
09:52:12 <kini> linear typing isn't it
09:52:17 <vlabs> Hodapp: like, rust knows how long things last (even heap allocations) (it has heap allocations), so it "inserts" the destructors
09:52:38 <napping> kini: isn't it?
09:52:39 <vlabs> Hodapp: so rust can be used without a refcount at all. you use refcounts usually in FFI code
09:52:43 <Yuu_chan> kini: I don't know exactly, that's why I ask :)
09:52:45 <vlabs> Hodapp: or multithreaded code
09:52:51 <kini> napping: that's what I thought it was called anyway
09:52:53 <napping> Yuu_chan: I think there are a few ways to get that kind of effect, one of them is called uniqueness typing
09:53:08 <napping> Oh, that was a question rather than a statement.
09:53:35 <kini> ah, well -- http://en.wikipedia.org/wiki/Uniqueness_type#Relationship_to_linear_typing
09:53:39 <kini> yes, a question rather than a statement :)
09:53:52 * hackagebot whois 1.2.1 - WHOIS client library.  http://hackage.haskell.org/package/whois-1.2.1 (purcell)
09:53:53 <napping> The name "Linear typing" comes from basing or inspiring type systems off of linear logic
09:54:03 <kini> makes sense
09:54:34 <napping> But often linear logic also requires you to use everything you get, in addition to not duplicating things
09:54:38 <vlabs> man I'm dumb, kept using (, , , ) to call a function >_>
09:54:47 * Yuu_chan still needs to read all through the TaPL
09:54:49 <napping> (or at least not things with duplicatable types)
09:54:50 <kini> napping: true
09:55:04 <napping> I think allowing dropping references makes "affine" logics
09:55:31 <napping> and there are also various fractional permission schemes that let you kind of track and reassemble references
09:56:07 <napping> I'm not quite sure where the Rust "borrowing" fits in with the type system literature, but it's probably in there somewhere
09:56:33 <napping> anyway, lots of different ways to design a type system that can actually tell you that you have the only/last reference to something
09:56:34 <benzrf> vlabs: nice try
09:56:36 <benzrf> :^O
09:56:47 <napping> and linear types are certainly one
09:56:47 <vlabs> benzrf: :)
09:56:59 <benzrf> foo(bar, baz) *is* valid haskell syntax
09:57:11 <vlabs> benzrf: it just passes a tuple :P
09:57:12 <benzrf> > foo(bar, baz)
09:57:13 <lambdabot>  Not in scope: ‘foo’
09:57:13 <lambdabot>  Perhaps you meant ‘T.for’ (imported from Data.Traversable)Not in scope: ‘bar’
09:57:13 <lambdabot>  Perhaps you meant one of these:
09:57:13 <lambdabot>    ‘Sym.var’ (imported from Data.Number.Symbolic),
09:57:13 <lambdabot>    ‘var’ (imported from Debug.SimpleReflect)Not in scope: ‘baz’
09:57:20 <benzrf> vlabs: well, duh
09:57:21 <benzrf> :^)
09:57:25 <vlabs> benzrf: xD
09:57:30 <benzrf> > var
09:57:31 <lambdabot>  No instance for (Data.Typeable.Internal.Typeable
09:57:31 <lambdabot>                     Debug.SimpleReflect.Expr.Expr)
09:57:31 <lambdabot>    arising from a use of ‘M243458743453197700731966.show_M2434587434531977007...
09:57:34 <benzrf> hmm
09:57:58 <napping> but at the very least, some kind of scheme of letting you temporarily use a uniquely-owned thing in a read-only but freely-sharable way is pretty nice for having an actually usable language
09:58:23 <napping> and I think the strictness and type discipline of Rust helps a bit with actually putting scoping like that
09:58:53 * hackagebot polynomial 0.7.1 - Polynomials  http://hackage.haskell.org/package/polynomial-0.7.1 (JamesCook)
09:59:04 <vlabs> napping: well, AFAIK the type inference and lifetime systems are orthogonal. I'm not sure though
09:59:17 <vlabs> is return () the correct way to define a no-op expression?
09:59:30 <benbangert> has anyone made a version of Warp's TimoutManager that lets you set individual timeouts per IO action registered?
09:59:56 <vlabs> or is there some other "standard" no op expression?
10:01:35 <joneshf> brainfart, can you pattern match the parts of a function? like can you say: foo (\x y -> result) = ...
10:01:44 <benbangert> in case anyone is curious, the answer seems to be http://hackage.haskell.org/package/control-timeout-0.1.2/docs/Control-Timeout.html
10:02:35 <Yuu_chan> vlabs: you can even use named arguments in Haskell! (with records)
10:03:21 <vlabs> Yuu_chan: not sure why you're telling me that, but that's a really nice feature to have
10:03:34 <Yuu_chan> vlab: what's a no op expression? An expression which computes nothing?
10:03:57 <vlabs> Yuu_chan: yep
10:04:31 <moghedrin> vlabs: If you're inside a monad, then yes.
10:04:59 <Yuu_chan> vlabs: because you "used" comma-separated arguments as in other languages :)
10:05:49 <vlabs> Yuu_chan: oh, yeah xD
10:05:52 <Yuu_chan> vlabs: but each expression must have a value. If a value of () is suitable for you, then yes.
10:06:01 <vlabs> Yuu_chan: yeah, () suits me fine
10:06:23 <Jefffrey> Hello
10:06:31 <chrisdone> ciao jefffrey
10:06:31 <Yuu_chan> :t Void
10:06:32 <lambdabot> Not in scope: data constructor ‘Void’
10:06:45 <Jefffrey> chrisdone: ?
10:07:06 <Yuu_chan> Привет, Jeffrey! ^_^
10:07:14 <Jefffrey> :)
10:07:19 <dwcook> vlabs, here's another useful no-op: id
10:07:21 <vlabs> Jefffrey: hey! I'm new :)
10:07:29 <vlabs> dwcook: id == identity?
10:07:29 <chrisdone> comè, jefffrey =p
10:07:35 <dwcook> vlabs, yes. id x = x
10:07:42 <vlabs> dwcook: cool, thanks!
10:08:07 <Jefffrey> chrisdone: How do you know I'm italian? ISP?
10:08:12 <dwcook> vlabs, to be fair I'm being slightly facetious. Not about the useful part though :)
10:08:17 <chrisdone> jefffrey .it =p
10:08:31 <vlabs> dwcook: xD
10:08:37 <Jefffrey> oh, cool
10:09:02 <Yuu_chan> Huh, my IRC client doesn't show addresses...
10:10:34 <Jefffrey> Well, anyway. Assuming I have a data type `X` and a function `setSomething` that modifies a field of `X` (:: X -> a -> X), can I make it so I can use it in a do block when `X` is in a state monad?
10:10:36 <chrisdone> yuu_chan: i work for the CIA so my irc client shows what room you're sitting in
10:10:44 * Yuu_chan imagines when Jefffrey logins and suddenly all channel starts to talk in Italian
10:11:20 <Jefffrey> chrisdone: You are italian?
10:12:02 <Yuu_chan> @hoogle modify
10:12:02 <lambdabot> Control.Monad.Trans.RWS.Lazy modify :: (Monoid w, Monad m) => (s -> s) -> RWST r w s m ()
10:12:02 <lambdabot> Control.Monad.Trans.RWS.Strict modify :: (Monoid w, Monad m) => (s -> s) -> RWST r w s m ()
10:12:02 <lambdabot> Control.Monad.Trans.State.Lazy modify :: Monad m => (s -> s) -> StateT s m ()
10:12:06 <chrisdone> jefffrey: no, habito in italia
10:12:12 <Yuu_chan> Jefffrey: see this
10:12:32 <Jefffrey> Yuu_chan, right thanks :)
10:12:34 <Yuu_chan> But you'd better to swap arguments of setSomething to curry.
10:13:24 <Jefffrey> chrisdone: Haskell lover?
10:13:44 <chrisdone> jefffrey: dove sei in italia? :3
10:13:51 <Jefffrey> verona
10:13:52 <vlabs> question, which is the preffered version, >>= or =<< ?
10:13:56 <vlabs> preferred*
10:14:05 <Jefffrey> vlabs: It doesn't matter
10:14:06 <Yuu_chan> vlabs: matter of taste
10:14:11 <chrisdone> jefffrey: trento here =)
10:14:17 <Jefffrey> nice
10:14:21 <chrisdone> you're close! we should meet up and geek out
10:14:29 <vlabs> Jefffrey: sure, they're equivalent, but I was wondering which the community favoured
10:14:29 <davidthomas> vlabs: >>= is slightly more common, but I'd say "prefer whichever allows your data to all flow the same direction in one line"
10:14:31 <chrisdone> haskell all the things
10:14:59 <chrisdone> italy needs more haskellers
10:15:02 <enthropy> solidus-river: linear or if you need some more operations, hmatrix
10:15:03 <Jefffrey> chrisdone: meh, I'm not good at meet ups
10:15:08 <Jefffrey> yes it does
10:15:12 <vlabs> davidthomas: cool, although I prefer =<< myself. reads much nicely IMO!
10:15:19 <Yuu_chan> vlabs: =<< can be used not to "break" the "control flow"
10:15:33 <vlabs> Yuu_chan: how so?
10:16:04 <solidus-river> enthropy: sweet, i'll check those out :)
10:16:29 <monochrom> if your chain consists of (.) and binds, then to fit with (.), you may like =<< for bind
10:16:32 <Yuu_chan> vlabs: imagine a long chain of functions: foo . bar . qux $ arg, the arg is "passed" from right to left
10:16:36 <vlabs> hm, how do I catch failure of readFile? (ik haskell does not have exceptions)
10:16:56 <ParahSailin> @hoogle Control.Exception
10:16:57 <lambdabot> Control.Exception module Control.Exception
10:16:57 <lambdabot> Control.Exception.Base class (Typeable e, Show e) => Exception e
10:16:57 <lambdabot> Control.Exception class (Typeable e, Show e) => Exception e
10:16:57 <monochrom> haskell has exceptions. even Haskell98 does
10:17:10 <solidus-river> it looks like hmatrix might be more performant
10:17:18 <chrisdone> haskell 1.4 had a conditions system
10:17:26 <solidus-river> but i have 0 informed reason for that
10:17:36 <vlabs> Yuu_chan, monochrom hm, ty about the =<<. so I can catch the exception?
10:18:10 <Yuu_chan> then you use it, say, in IO: readLine >>= print . foo . bar . quz . read, the flow starts from the first function and jumps to the last, then goes right to left
10:18:17 <dwcook> I like (=<<) because it's analogous to ($)
10:18:34 <dwcook> Likewise (<=<) is analogous to (.)
10:18:44 <monochrom> the bad news is that the exception API has been made so general, it's a bit hard to use, by this I mean you have to add more type annotations to indicate that you're after IOException
10:18:55 <Yuu_chan> vlabs: but you can reverse it so it restored the continuousness: print . foo . bar . quz . read =<< readLine, voila!
10:19:04 <Yuu_chan> vlabs: yeah, like dwcook said
10:19:52 <vlabs> monochrom: hm, I assumed Haskell used something like Result<T, E> or some such
10:20:03 <Yuu_chan> (however, I tend to like F# |> and >> more)
10:20:07 <vlabs> monochrom: or I could just test if the file exists. seems way easier
10:20:30 <monochrom> oh, the beauty is that there is a function (name is "try") to convert exception throwers to Either returners.
10:21:03 <Lutin^> We need some Florida haskell meetups
10:21:30 <newbie|2> because what happens in florida stays in florida
10:21:33 <Yuu_chan> We need some %anywhere% Haskell meetups >_<
10:21:38 <monochrom> in fact, it's recommended over catch-and-handle. but not for the ideological reason "Either is better"
10:22:40 <Lutin^> Maybe I should move to Texas
10:22:42 <vlabs> monochrom: will look into try
10:22:45 <monochrom> the reason is technical: when the handler is run, exceptions are blocked. 80% of the time you don't need it. 19% of the time you don't want it.
10:23:03 <vlabs> xD
10:23:37 <monochrom> as for the ideological debate of exception vs Either, my stance is http://www.vex.net/~trebla/haskell/exception.xhtml
10:24:08 <vlabs> so, only IO throws exceptions in haskell?
10:24:16 <vlabs> why is try only defined for IO ?
10:24:54 <monochrom> in standard Haskell, only IO throws exceptions. in GHC Haskell, everything throws exceptions, but only IO catches exceptions
10:25:10 <monochrom> oh, that's old try. new try works for everything
10:25:27 <vlabs> ah, interesting
10:25:48 <monochrom> new try and catch are in Control.Exception
10:25:51 <vlabs> there's a "haskell" and a "ghc haskell" ?
10:25:57 <monochrom> the old ones are deprecated or gone
10:26:11 <monochrom> there is Haskell 2010. but GHC does more.
10:26:24 <vlabs> ahh
10:27:27 <Yuu_chan> Good bye!
10:38:40 <Black-Heaven> Hi all, I have some troubles on installing hakyll with GHC 7.8.2 and cabal 1.20.0.3: http://pastebin.com/1kfAkUxu Am I alone? Is there a workaround? Thanks in advance for your help.
10:40:40 <marchelzo_> If I have the value Just "abc" how can I print the "abc" part only?
10:41:00 <marchelzo_> without using a function specifically for Maybe
10:42:34 <supki> :t F.traverse_ print
10:42:35 <lambdabot> (Foldable t, Show a) => t a -> IO ()
10:42:43 <identity> marchelzo_: (\(Just x) -> print x) or some such
10:43:06 <identity> > (\(Just x) -> show x) (Just "abc")
10:43:08 <lambdabot>  "\"abc\""
10:43:29 <marchelzo_> so there is no such function for Funtors in general
10:43:34 <marchelzo_> Functors*
10:43:38 <raek> marchelzo_: what do you want to print if the value is Nothing (that is, not Just something)
10:44:08 <marchelzo_> raek: Ok
10:44:15 <marchelzo_> I see the problem with having such a function
10:44:51 <johnw> Funtors and Moads, the new thing
10:45:11 <geekosaur> Black-Heaven, that's pulling in a very old version of pandoc --- current hakyll depends on pandoc >=1.12.4 && <1.13
10:45:15 <Lutin^> > show . fromMaybe "Nothing" $ Just "abc"
10:45:16 <lambdabot>  "\"abc\""
10:45:29 <Lutin^> > show . fromMaybe "Nothing" $ Nothing
10:45:31 <lambdabot>  "\"Nothing\""
10:45:32 <geekosaur> it's not compatible with ghc 7.6, much less 7.8
10:45:34 <identity> johnw: Then we also need Boretors and Lessads
10:45:44 <Black-Heaven> ah
10:46:07 <willem> hello everyone, i have written some code to work with Bayesian networks, but now want to extend it to Markov networks (which are essentially a generalisation of the former). they both support similar operations, so i have devised a "Network" class which contains those operations as implementable functions. however, that Network class looks like an OO code-smell to me. could somebody have a look at it and give me som
10:46:08 <willem> e advice if it's worthy haskell code? http://lpaste.net/106395
10:46:49 <geekosaur> I don't know why it's bilding that old a version of hakyll, unless that version is old enough to not have an upper dependency limit and there's not currently a 7.8 compatible version?
10:46:58 <Black-Heaven> it seems that hakyll version is pretty old too
10:47:27 <Black-Heaven> I don't know :/
10:47:46 <geekosaur> what version is it trying to install?
10:47:51 <Lutin^> 3.2.0.1
10:47:52 <identity> Black-Heaven: yeah, looks like it's rather old. 3.5 vs 4.x
10:47:56 <matematikaadit> :i foldM
10:47:57 <identity> or 3.2 rather
10:48:48 <geekosaur> not seeing anything in that version that stands out
10:48:50 <vlabs> can I use not on IO bool?
10:48:55 <Black-Heaven> I don't know why cabal does this
10:48:56 <identity> vlabs: sure you can
10:49:06 <vlabs> identity: not (some io bool) works?
10:49:12 <geekosaur> fmap
10:49:17 <identity> vlabs: what are you trying to do? o.o
10:49:18 <vlabs> geekosaur: ah, right
10:49:22 <identity> ah.
10:49:27 <identity> like that.
10:49:28 <vlabs> identity: checking if a file exists or not :P
10:49:32 <identity> yes, fmap or liftM
10:49:40 <Lutin^> geekosaur: Well that pandoc version it's trying to install is over 3 years old
10:49:44 <enthropy> willem: you could just have   data PNet = PNet { name, ... }. Whether it's Markov or Bayes would depend on the function you use to propagate things
10:49:54 <identity> fmap = (<$>) is beautiful-ler.
10:49:59 <Lutin^> geekosaur: And so is the Hakyll version
10:50:16 <geekosaur> Black-Heaven, because cabal is trying to satisfy ghc, which is absurdly version sensitive, and trying to satoisfy developers who don't want to do the work of expressing dependencies as precisely as types
10:50:23 <Lutin^> Black-Heaven: Just built find for me in a sandbox
10:50:23 <geekosaur> Lutin^, yes
10:50:29 <dwcook> vlabs, earlier you asked about the distinction between Haskell and GHC Haskell. GHC Haskell is Haskell but with (one or more) GHC extensions enabled.
10:50:29 <Lutin^> Oh wait
10:50:34 <Lutin^> I take that back
10:50:58 <Lutin^> strict-concurrency is olddddd
10:50:59 <vlabs> dwcook: ah, I see. Thanks
10:51:02 <geekosaur> probably need -v to see why cabal is selecting that version, I still suspect something has its versions wrong
10:51:09 <vlabs> so, liftM not (someIObool) ?
10:51:17 <identity> vlabs: sure
10:51:28 <vlabs> hm, but liftm would return back an IObool
10:51:35 <Black-Heaven> Lutin^: I'm also in a sandbox :/
10:51:46 <dwcook> vlabs, everything that must operate on the potential Bool there must be lifted
10:51:49 <enthropy> willem: or you can do    data PNet networkType = PNet { name, ... }; data Bayes; data Markov;  and then functions that don't care about the type of network can look like   jointDist :: Assignment -> PNet t -> Maybe Double
10:51:50 <vlabs> I'd like to branch
10:51:58 <dwcook> vlabs, one way to do this is with (>>=) and friends
10:51:59 <identity> :t not `liftM` (undefined :: IO Bool)
10:52:00 <lambdabot> IO Bool
10:52:01 <identity> returns a bool yes
10:52:07 <geekosaur> learn how to use do notation or >>= ?
10:52:12 <vlabs> I'd like to branch based on the value of the IO bool
10:52:15 <identity> ah.
10:52:24 <enthropy> and for the ones where it matters, you have    f :: PNet Bayes -> ...
10:52:26 <vlabs> geekosaur: I know what >>= does :) how does that help?
10:52:33 <dwcook> vlabs, sure, that's definitely possible. do { b <- someIOBool ; if b then … else … }
10:52:48 <geekosaur> uh, that question suggests to me you *don't* understand fully what it does
10:52:51 <vlabs> dwcook: oh, right, I'ld forgotten about the <- >_<
10:53:00 <identity> what dwcook said^ though I prefer using case for stuff like this because the if..then..else syntax is so terribly awkward
10:53:03 <geekosaur> hint: <- is >>=
10:53:04 <dwcook> vlabs, that's just sugar for someIOBool >>= \b -> if b then … else …
10:53:20 <identity> (or just when)
10:53:42 <Lutin^> All of you should back the Reading Rainbow kickstarter asap :)
10:53:42 <dwcook> Agreed with identity
10:53:46 <vlabs> dwcook: but I have to return an IO b
10:53:51 <vlabs> dwcook: I don't want to return anything
10:54:06 <vlabs> dwcook: nvm, stupid me. gotcha
10:54:07 <dwcook> vlabs, every expression has a value whether you like it or not
10:54:09 <Lutin^> Seth Macfarlane is matching backers up to $1million until the kickstarter ends in 5 days
10:54:14 <willem> enthropy: i've thought of that, but the problem is the 'parentsB' attribute in BayesNet and the 'cliquesM' attribute in MarkovNet. using that representation, i would have to choose 1 of them. answer to your second answer: i also have something like that in mind. but instead i could parametrise PNet over the type of either cliquesM (and get a Markov network) or parentsB (and get a Bayesian network). however, i would
10:54:14 <willem> still need to find a suitable name for the attribute which could be either one of those two attributes...
10:54:25 <vlabs> dwcook: yeah, realized
10:54:45 <willem> enthropy: either way, thank you for your help!
10:55:15 <vlabs> dwcook, geekosaur identity : thanks
10:55:24 <vlabs> geekosaur: love your username :)
10:55:48 <Lutin^> Oh man
10:56:03 <Lutin^> building cabal packages is like stress testing my CPU lol
10:56:14 <mokus> @query int-e
10:56:14 <lambdabot> Unknown command, try @list
10:56:22 <mokus> lol, whoops
10:56:22 <vlabs> Lutin^: yeah, I've noticed it spikes in the beginning. I'm not sure why
10:56:52 <Lutin^> Black-Heaven, geekosaur I'm building with -v and uploading the results to a pastebin for further inspection
10:57:39 <enthropy> willem: you cut off at "however, i would"
10:57:40 <identity> my cpu is rather terrible and I always feel like I'm basically forcing an old man to dealift 400 pounds or some such when I make it work
10:57:57 <willem> enthropy: still need to find a suitable name for the attribute
10:57:57 <willem>                which could be either one of those two attributes...
10:57:57 <identity> enthropy: really? he didn't for me o.o
10:58:09 <willem> enthropy: which could be either one of those
10:58:09 <willem>                two attributes...
10:58:10 <enthropy> you're right identity
10:58:32 <enthropy> connectivity
10:58:40 <vlabs> how does >> work? like, how does it sequence two expressions?
10:59:02 <dwcook> vlabs, a >> b is equivalent to a >>= \_ -> b
10:59:09 <dwcook> vlabs, so it depends on how (>>=) is defined
10:59:23 <dwcook> (unless it's been defined separately for a particular monad)
10:59:49 <marchelzo_> are these two functions any different? http://lpaste.net/8823481075171852288  I tested them with some fairly high numbers and neither of them gave a stack overflow and they both took roughly the same amount of time
11:00:09 <vlabs> dwcook: hm
11:00:47 <vlabs> dwcook: I can see how it works but it's sort of unintuitive to me
11:00:54 <vlabs> dwcook: will experiment a little more
11:02:26 <dwcook> vlabs, there isn't some general "way it works". The type signature and the laws are most of what's required to understand the general concept. However, if you want to know how it works on some specific monads, check their definitions of (>>=).
11:02:56 <dwcook> vlabs, and no, I don't expect you to suddenly get the intuition for how to read the types and laws, but I'm trying to point you in the right direction
11:03:47 <willem> marchelzo_: both should eventually cause a stack overflow, however if you evaluate 'acc' early in gSum using a bang pattern ({-# LANGUAGE BangPatterns #-} and replace acc with !acc), then gSum should run in constant space
11:04:21 <vlabs> dwcook: ah, sure, thanks. I didn't expect to be able to just "get" it either but I was hoping it would be a little less opaque :)
11:04:36 <dwcook> vlabs, by the way: http://www.haskell.org/haskellwiki/What_a_Monad_is_not#Monads_are_not_about_ordering.2Fsequencing
11:04:44 <marchelzo_> ah I often see that LANGUAGE BangPatterns thing at the top of code but didn't know what it was
11:04:48 <vlabs> dwcook: ty
11:04:59 <vlabs> marchelzo_: ? hashbangs?
11:05:06 <moghedrin> @t runStateT
11:05:06 <lambdabot> Maybe you meant: tell thank you thanks thesaurus thx tic-tac-toe ticker time todo todo-add todo-delete type v @ ? .
11:05:15 <willem> marchelzo_: as of right now, both bSum and gSum build up huge thunks which will be evaluated when you reach []
11:05:24 <moghedrin> :t runStateT
11:05:24 <lambdabot> StateT s m a -> s -> m (a, s)
11:06:03 <vlabs> why does everyone make fun of this? http://blog.plover.com/prog/burritos.html >_> it's harmless
11:06:04 <marchelzo_> willem: so the !acc will force it to be evaluated with each iteration rather than building up until the end?
11:07:06 <willem> marchelzo_: indeed, that's the idea
11:07:56 <marchelzo_> does it sacrifice speed?
11:08:05 <dwcook> vlabs, for one thing, it might mislead you into thinking that monads can be understood in terms of some real physical object.
11:08:49 <willem> marchelzo_: not that i know of, if you don't use it and keep the chain of thunks in memory then the chain will need to be completely evaluated at the end anyway
11:08:59 <pantsman-> You Could Have Invented Burritos
11:09:08 <dwcook> vlabs, you should also note that, unlike burritos, the general concept of monad is not a "container" of any sort. What does IO () contain? What does String -> Integer contain?
11:09:34 <dwcook> These are both monadic values where that concept gets a bit fuzzy.
11:09:40 <marchelzo_> willem: true. thanks
11:10:09 <dwcook> s/values/types/
11:10:09 <Lutin^> Black-Heaven, geekosaur: What the actual fuck
11:10:11 <vlabs> dwcook: String -> Integer is a monad? -_^ how?
11:10:15 <Lutin^> I compile with -v and everything works
11:10:22 <Lutin^> I compile without and it uses an old package
11:10:25 <benzrf> burritos are indeed monads
11:10:33 <benzrf> but not all monads monads are burritos
11:10:39 <dwcook> vlabs, in the (String ->) monad, or more generally, the (e ->) monad
11:10:40 <Lutin^> brb
11:11:18 <vlabs> dwcook: ah
11:11:43 <vlabs> question what's <*> called? and why doesn't :t for (<*>) work?
11:12:00 <dwcook> vlabs, http://hackage.haskell.org/package/base-4.7.0.0/docs/src/GHC-Base.html#line-69
11:12:06 <dwcook> vlabs, it's called "ap".
11:12:06 <marchelzo_> it should work, you might need to import Control.Applicative first, though
11:12:29 <vlabs> dwcook: is there a... list of these operators somewhere?
11:12:42 <vlabs> dwcook: new ones seem to crop up every time I visit a new link
11:12:49 <dwcook> vlabs, the documentation for the module containing them, usually
11:12:58 <dwcook> vlabs, (<*>) exists in Control.Applicative, as a method of Applicative
11:13:06 <vlabs> dwcook: hm, no centralized place? bummer
11:13:23 <dwcook> Not that I know of
11:13:36 <dwcook> Other than Hoogle
11:13:41 <dwcook> !hoogle (<*>)
11:13:44 <dwcook> The web interface is better
11:13:48 <rwbarton> the top and bottom of http://hackage.haskell.org/package/base-4.7.0.0/docs/doc-index-All.html? :)
11:13:48 <dwcook> @hoogle (<*>)
11:13:49 <lambdabot> Control.Applicative (<*>) :: Applicative f => f (a -> b) -> f a -> f b
11:13:59 <dwcook> Gotta go, back in a bit
11:14:17 <vlabs> applicative is identical to functor?
11:14:25 <joelteon> no
11:14:32 <vlabs> identical to fmap*
11:14:41 <tolt> vlabs: You might be using Hoogle but you should also look at hayoo http://holumbus.fh-wedel.de/hayoo/hayoo.html
11:15:04 <vlabs> tolt: cool, ty!
11:15:09 <chrisdone> or http://hackage.haskell.org/package/haskell-docs =p
11:15:17 <vlabs> @hoogle fmap
11:15:18 <lambdabot> Prelude fmap :: Functor f => (a -> b) -> f a -> f b
11:15:18 <lambdabot> Data.Functor fmap :: Functor f => (a -> b) -> f a -> f b
11:15:18 <lambdabot> Control.Monad fmap :: Functor f => (a -> b) -> f a -> f b
11:15:28 <vlabs> @hoogle (<*>)
11:15:29 <lambdabot> Control.Applicative (<*>) :: Applicative f => f (a -> b) -> f a -> f b
11:15:40 <vlabs> no difference other than the typeclass
11:15:43 <vlabs> hm
11:15:51 <pavonia> look closer ;)
11:16:15 <vlabs> ohh, there's a f (a -> b) in applicative
11:16:18 <tolt> chrisdone: obligatory thank you for your emacs related things.
11:16:18 <vlabs> the f
11:16:42 <chrisdone> tolt: oh how nice =)
11:16:47 <tolt> Yep. (<$>) is an infix fmap in applicative.
11:16:57 <vlabs> hm, so applicative takes a function and a value *both* wrapped in a monad?
11:17:16 <vlabs> how common is a case of function-in-an-Applicative?
11:17:16 <benzrf> vlabs: what?
11:17:20 <benzrf> wrapped in a monad?
11:17:21 <vlabs> Applicative not monad
11:17:29 <vlabs> having typeclass Applicative*
11:17:37 <vlabs> sorry, words :)
11:17:41 <benzrf> 'wrapped' is a tricky term
11:18:01 <johnw> dwcook: even better, what does this contain: https://gist.github.com/b4a78b512d3efade88b5
11:18:04 <triliyn> vlabs: one thing it is useful for is applying functions fmap-style but to multiple arguments
11:18:20 <triliyn> > (+) <$> Just 3 <*> Just 5
11:18:22 <lambdabot>  Just 8
11:18:38 <triliyn> You can't do this with just Functor
11:19:03 <vlabs> triliyn: hm, interesting
11:19:10 <tolt> I end up using ap (<*>) when you have some functors (f a, f b ...) and some functor (a -> b -> ... -> c).
11:19:27 <vlabs> this is a bit much to take in TBH
11:19:33 <Black-Heaven> Lutin^: it's not better when I try to compile site.hs: http://pastebin.com/kEUH5c3u
11:19:50 <vlabs> monads, functors, relationships to category theory, <$>, <*>, >>=, ...
11:20:07 <Lutin^> Hmm
11:20:14 <Lutin^> It looks like the issue is something in the new cabal
11:20:32 <Lutin^> my userwide install is on an old version
11:20:33 <chrisdone> vlabs: http://www.reactiongifs.com/r/2011/09/mind_blown.gif
11:20:46 <Lutin^> And when I just sandbox and use that, it installs
11:20:55 <Lutin^> but when I update first it tries to install an old version
11:20:58 <vlabs> chrisdone: perfect ;)
11:21:27 <Black-Heaven> Have I win something? :)
11:21:51 <chrisdone> Black-Heaven: you've won the gift of type safety
11:22:02 <Black-Heaven> nice
11:23:15 <vlabs> any other cool operators I should be aware of?
11:23:34 <chrisdone> *** and &&&
11:24:03 <benzrf> :t (***)
11:24:04 <lambdabot> Arrow a => a b c -> a b' c' -> a (b, b') (c, c')
11:24:10 <willem> :t on
11:24:11 <benzrf> :t (&&&)
11:24:11 <lambdabot> (b -> b -> c) -> (a -> b) -> a -> a -> c
11:24:12 <lambdabot> Arrow a => a b c -> a b c' -> a b (c, c')
11:24:13 <benzrf> :t first
11:24:13 <lambdabot> Arrow a => a b c -> a (b, d) (c, d)
11:24:29 <willem> :t compare `on` fst
11:24:29 <lambdabot> Ord b => (b, b1) -> (b, b1) -> Ordering
11:24:33 <chrisdone> @botsnack benzrf
11:24:34 <lambdabot> :)
11:24:38 <vlabs> benzrf: arrow? I haven't even finished monads >_<
11:24:45 <benzrf> vlabs: dont worry about arrows
11:24:47 <chrisdone> vlabsyou asked for it =p
11:24:54 <benzrf> just mentally swap 'a b c' for 'b -> c'
11:25:10 <benzrf> (->) is almost always the arrow instance youll want to be using at yourlevel
11:25:11 <Lutin^> Black-Heaven: k one sec generating some verbose logs
11:25:18 <benzrf> :t first
11:25:19 <lambdabot> Arrow a => a b c -> a (b, d) (c, d)
11:25:25 <benzrf> vlabs: if you swap a for (->)
11:25:27 <benzrf> that becomes
11:25:37 <benzrf> (b -> c) -> ((b, d) -> (c, d))
11:25:54 <benzrf> > first show (3, 4)
11:25:56 <lambdabot>  ("3",4)
11:26:00 <vlabs> nope, I'm confused
11:26:00 <rwbarton> Lutin^: I encountered something similar recently, ghc panic that went away with -v, maybe it was using a different version of a dependency, I didn't track down the cause
11:26:12 <vlabs> benzrf: don't bother :)
11:26:38 <Lutin^> rwbarton: Yeah I'm wondering if the issue stems from a package the new cabal-install depends on
11:26:39 <kini> why does `cabal sdist` accept a --builddir instruction? Does it do any building?
11:26:55 <Lutin^> such that a conflict is generated when using the new one
11:27:01 <Lutin^> so it tries to use an old version
11:27:13 <Lutin^> we shall see
11:27:56 <vlabs> @hoogle liftM
11:27:57 <lambdabot> Control.Monad liftM :: Monad m => (a1 -> r) -> m a1 -> m r
11:27:57 <lambdabot> Control.Monad liftM2 :: Monad m => (a1 -> a2 -> r) -> m a1 -> m a2 -> m r
11:27:57 <lambdabot> Control.Monad liftM3 :: Monad m => (a1 -> a2 -> a3 -> r) -> m a1 -> m a2 -> m a3 -> m r
11:28:01 <vlabs> @hoogle liftA
11:28:01 <lambdabot> Control.Applicative liftA :: Applicative f => (a -> b) -> f a -> f b
11:28:01 <lambdabot> Control.Applicative liftA2 :: Applicative f => (a -> b -> c) -> f a -> f b -> f c
11:28:01 <lambdabot> Control.Applicative liftA3 :: Applicative f => (a -> b -> c -> d) -> f a -> f b -> f c -> f d
11:28:12 <vlabs> why does liftM use a1 and r?
11:29:15 <Lutin^> Well then
11:29:24 <Lutin^> There's the issue
11:29:34 <Lutin^> http://ix.io/daR
11:29:59 <kini> btw Lutin^ do you know who runs ix.io
11:30:07 <kini> I'm always worried it's going to disappear one day
11:30:12 <Lutin^> same person as sprunge, but nope no idea
11:30:18 <kini> oh is it
11:30:21 <Lutin^> The server code is open source iirc
11:30:25 <andkore> Has anyone here designed a program that uses a database and does some querying of that database but doesn't use a relational database?
11:30:35 <kini> well sprunge is by http://github.com/rupa apparently
11:30:48 <kini> how do you figure that ix.io is run by the same person?
11:31:03 <Lutin^> I just remember someone saying that in #archlinux
11:31:17 <kini> oh, their website is http://un.ix.io/ so I guess that makes sense
11:31:39 <Lutin^> Black-Heaven: So the issue is the new versions of Cabal and HTTP conflict with the requirements of the most recent Hakyll version
11:32:05 <Lutin^> See _26 in the last ix.io paste
11:32:44 <vlabs> what's the usecase for <$?
11:32:44 <Lutin^> And 3.2.0.1 is the first one that satisfies it
11:32:52 <Lutin^> because that was before they used upper bounds on version
11:33:55 <Lutin^> Black-Heaven: btw use --verbose=3 to see all of the dependency solver output
11:35:19 <tolt> chrisdone: do you have any good example uses of Arrows?
11:35:26 * Lutin^ sighs
11:35:40 <Lutin^> Welcome to cabal hell
11:35:45 <Lutin^> enjoy your stay
11:35:57 <vlabs> Lutin^: just reinstall cabal? would that not work?
11:36:17 <tolt> Lutin^: We keep track of days since Cabal hell in the office. It's at a week
11:36:25 <vlabs> xD
11:36:44 <Black-Heaven> vlabs: already tried
11:36:45 <Lutin^> It's not specifically a cabal issue
11:37:03 <Lutin^> it's the the constraints on cabal allow the newest versions of HTTP and mtl to install
11:37:12 <vlabs> Black-Heaven: did you make sure it cleaned everything up?
11:37:14 <Lutin^> Which causes a conflict with the constraints of Hakyll
11:37:17 <Black-Heaven> Lutin^: I have finally installed it, by using -force-reinstall
11:38:46 <Lutin^> Yeah that would work
11:38:50 <Lutin^> for now
11:42:27 <Lutin^> Huh
11:42:38 <Lutin^> Black-Heaven: Did you cabal update, cabal install cabal-install inside that sandbox
11:43:14 <tolt> I had the mtl issue as well. Did you try "--solver=topdown"?
11:44:31 <shergill> i have a rudimentary understanding of 'initial' vs 'final' and 'algebra' vs 'coalgebra'. could someone explain why people mostly talk about final coalgebras? and not final algebras? similarly why don't people talk about initial coalgebras?
11:45:23 <Lutin^> Lutin^: Because it works for me as long as it's a perfectly clean sandbox
11:46:27 <johnw> shergill: are you still here?
11:46:34 <Lutin^> He just quit
11:46:35 <johnw> my name completion isn't working, which usually means the person has left
11:47:01 <vlabs> johnw: looks like he left
11:47:08 <vlabs> johnw: I'm interested in the answer though
11:47:30 <johnw> so, algebras are roughly of the form f a -> a, and coalgebras are a -> f a
11:47:35 <Lutin^> Black-Heaven: Yeah it works in a perfectly clean sandbox
11:47:42 <Lutin^> johnw: Start over he's back
11:47:48 <johnw> shergill: so, algebras are roughly of the form f a -> a, and coalgebras are a -> f a
11:48:25 <johnw> an algebra is free when it effectively does no computation whatsoever, but preserves the albgebraic structure *only*
11:48:32 <johnw> we call these data constructors in Haskell
11:48:38 <johnw> in category theory they'd be called initial algebras
11:48:50 <johnw> we also see them referred to as free structures of the algebra
11:49:10 <johnw> they are initial because every other algebra is a natural transformation from that initial algebra to some other algebra
11:49:52 <johnw> is that clear?
11:50:17 <vlabs> sorta
11:50:29 <johnw> take the monoid algebraic structure for example
11:50:38 <johnw> (S,*,e)
11:50:49 <johnw> we can write that in terms of function signatures as:
11:50:58 <johnw> (S,S->S->S,()->S)
11:51:09 <johnw> next, we can merge together the function signatures:
11:51:18 <johnw> (S, () -> (S -> S) -> S)
11:51:29 <johnw> now we can make a data type to encode the function signature:
11:51:45 <johnw> data MonoidF a = MEmpty | MAppend a a, (S, MonoidF S)
11:52:17 <johnw> that data type happens to be a functor
11:52:36 <Lutin^> wait how does that comma after the a work
11:52:42 <johnw> that's just a separator
11:52:48 <Lutin^> Ah
11:52:48 <johnw> ; --, something
11:52:51 <Lutin^> Yeah I see now
11:52:54 <shergill> johnw: sorry got dc'd for a bit. yes i understand the difference between algebras and coalgebras
11:53:01 <johnw> ok
11:53:06 <shergill> i'm wondering why we never hear about initial coalgebras, or final algebras
11:53:23 <shergill> why only initial algebra and final coalgebras
11:53:52 <johnw> a final algebra would be something pretty uninteresting, I'd think
11:54:11 <shergill> why so?
11:54:27 <johnw> wouldn't it be a catamorphism to an algebra that evaluates to unit?
11:54:34 <Black-Heaven> < Lutin^> Black-Heaven: Did you cabal update, cabal install cabal-install inside that sandbox <= yes
11:54:49 <johnw> i mean, the finality would mean that every algebra could be transformed to that algebra
11:54:50 <Lutin^> Black-Heaven: Yep there's the issue
11:55:03 <Lutin^> Doing so installed a specific version of HTTP and mtl inside the sandbox
11:55:12 <johnw> and the only algebra that could be is the algebra that forgets all information
11:55:19 <Lutin^> So when installing hakyll it conflicted instead of ignoring them and installing the older ones
11:55:30 <shergill> well it would mean there'd only be one way in which each algebra could be transformed to it
11:55:40 <Black-Heaven> ah
11:55:49 <Black-Heaven> ok
11:55:58 <johnw> shergill: right.  do you have any other examples of such an algebra in mind?
11:56:26 <Black-Heaven> so, what I was supposed to do to keep a sane sandbox?
11:56:28 <shergill> johnw: how did you get to that second conclusion. i.e., the only algebra that could be is the one that forgets all information
11:56:37 <shergill> clearly that satisfies, but why is it the only one?
11:56:40 <Black-Heaven> just cabal install hakyll?
11:56:44 <Lutin^> Yeah
11:56:50 <Black-Heaven> ok
11:56:54 <Lutin^> cabal update; cabal install cabal-install outside of the sandbox
11:57:38 <Lutin^> You basically only want the sandbox to have the dependecies for your cabal project installed inside it
11:58:30 <johnw> shergill: imagine there are multiple such algebras
11:58:48 <johnw> shergill: for them to be final objects, they would need to be isomorphic to each other, no?
11:58:57 <johnw> maybe I'm misundertanding here
11:59:06 <Black-Heaven> ok, Im trying
11:59:19 <johnw> I'm picturing the category of F-algebras for some algebra F, and we have a terminal object in that category
12:00:10 <ReinH> johnw: can I bother you about org-mode a bit?
12:00:23 <johnw> ReinH: sure, how about in #org-mode
12:00:41 <johnw> shergill: I suppose that algebra could have multiple implementations, though, if that was your point
12:00:42 <tolt> I assumed that the lack of Functor instance on Set was because of the O(nlogn) for fmap.
12:01:02 <tolt> is that true?
12:01:12 <johnw> it's due to the Ord constraint
12:01:16 <vlabs> johnw: question - if two things are isomorphic, that just means that they're *equivalent*, not *identical* correct?
12:01:27 <johnw> vlabs: equivalence is a weaker notion
12:01:33 <johnw> isomorphic means that f . g = g . f = id
12:01:36 <Lutin^> tolt: Functors shoudl be able to hold for any a
12:01:42 <Lutin^> tolt: But set requires Ord a
12:01:46 <shergill> johnw: nvm got it using positivity (not sure how valid that is), in algebra, the output is an algebra and as such it makes sense to look at the initial object since you just chain transformations. if you're looking at a final such algebra that means that the meta information in the functor would have to be the intersection of all such possibilities, yielding the functor which discards all meta information
12:01:52 <mr-> johnw: the unit type cannot be an algebra for F z = 1 + z * F z, for example
12:01:56 <johnw> equivalence means that f . g results in an object which is isomorphic, but not identical
12:02:02 <shergill> by positivity i mean input/output
12:02:08 <shergill> thanks
12:02:19 <vlabs> johnw: oh, I see. didn't know that
12:02:51 <johnw> "Isomorphism of categories is a very strong condition and rarely satisfied in practice. Much more important is the notion of equivalence of categories; roughly speaking, for an equivalence of categories we don't require that FG(x) be equal to x, but only isomorphic to x in the category D, and likewise that GF(y) be isomorphic to y in C."
12:02:53 <johnw> from http://en.wikipedia.org/wiki/Isomorphism_of_categories
12:04:02 * hackagebot stm-containers 0.1.2 - Containers for STM  http://hackage.haskell.org/package/stm-containers-0.1.2 (NikitaVolkov)
12:04:50 <johnw> shergill: nice, I think that's what I meant, but not 100% sure now :)
12:04:53 <vlabs> how would I install this using cabal? https://github.com/seliopou/toml
12:04:55 <tolt> Lutin^: ahhh. That makes sense. Thanks.
12:05:13 <johnw> mr-: right, in the F-algebra category, it wouldn't make any sense to fix 'a' for some final f a -> a
12:05:25 <vlabs> johnw: why don't we talk about initial coalgebras?
12:05:27 <johnw> it would just be the meta info which is thrown away
12:06:03 <johnw> an initial coalgebra would be like manufacturing an algebra from Void, wouldn't it?
12:06:49 <shergill> precisely
12:07:02 <shergill> or at least i think so
12:07:17 <vlabs> johnw: don't know :) just sat in a few classes.
12:07:52 <vlabs> how would I install the package using cabal? https://github.com/seliopou/toml
12:07:56 <vlabs> cabal install toml didn't work
12:08:28 <Lutin^> vlabs: cabal install only works with packages on hackage
12:08:36 <Lutin^> Just git clone; cd; cabal install
12:08:54 <shergill> well it must, right. because a coalgebra is a destructor i.e. it consumes f a. the initial object would be one whose destructor could be converted into the destructor of any other coalgebra. that means it can't be doing something very interesting (by parametricity)
12:08:55 <Lutin^> optionally creating a sandbox if you'd like
12:08:59 <vlabs> Lutin^: oh, I see. I didn't know that
12:09:02 <shergill> vlabs: ↑
12:09:19 <Lutin^> dat arrow
12:09:20 <vlabs> Lutin^: what's the sandbox for?
12:09:51 <Lutin^> vlabs: It allows a package's dependencies to not populate your global user namespace
12:10:12 <johnw> shergill: http://www.andrew.cmu.edu/user/awodey/students/hughes.pdf
12:10:13 <johnw> see page 32
12:10:33 <johnw> it talks about final algebras and initial coalgebras there
12:10:34 <Lutin^> pollute*
12:10:41 <johnw> he calls the final algebra "typically dull"
12:10:41 <nadirs> Whoo, latest cabal is able to create an MIT license file when you issue "cabal init"!
12:10:49 <shergill> johnw: ah thanks
12:10:58 <johnw> and that the initial coalgebra is always the "empty coalgebra"
12:10:59 <mr-> johnw, shergill: There is a canonical final algebra: Take the final Object X in Hask (or in a Hask that has that), F X -> X is final
12:11:13 <mr-> johnw, shergill: Dually, there is a canonical initial coalgebra
12:11:14 <Lutin^> And allows for version conflicts to just hide the conflicting package that's in the global db and install a non-conflicting version local to the sandbox
12:11:16 <johnw> so I think that confirms what we said, with much better grounded explanation
12:12:20 <mr-> So johnw was correct, it is not very interesting :-)
12:12:22 <mr-> sadly
12:12:32 <shergill> yeah
12:12:40 <vlabs> Lutin^: nice
12:12:46 <vlabs> Lutin^: so how do I enable sandboxing
12:14:40 <Lutin^> vlabs: cabal sandbox init
12:14:48 <Lutin^> when in doubt, cabal help
12:14:54 <Lutin^> or cabal help <command>
12:15:16 <vlabs> ooh, ty!
12:15:22 <Lutin^> It's local to a specific directory so be careful about running cabal commands in subdirectories
12:15:40 <Lutin^> I don't think it looks in parent directories for a sandbox, but I could be wrong
12:16:25 <vlabs> Lutin^: I don't seem to have sandbox as a command line argument
12:16:49 <Lutin^> What's your GHC, cabal-install version
12:17:10 <Lutin^> sandboxes have been around since cabal > 1.18
12:18:29 <phi__> gnuplot has stopped working for me since I upgraded to ghc 7.8. Anybody has a hunch why that might be?
12:18:48 <vlabs> cabal-install version 1.16.0.2
12:18:50 <vlabs> using version 1.16.0 of the Cabal library
12:19:03 <vlabs> hm, I installed it using brew :|
12:19:08 <vlabs> guess it's outdated
12:19:15 <vlabs> can cabal upgrade itself?
12:19:34 <Lutin^> yep
12:19:53 <Lutin^> cabal update to update the package database from Hackage
12:19:56 <tolt> cabal isntall cabal-install
12:20:07 <Lutin^> It will let you know if there's a cabal-install update and you can do what tolt said
12:20:33 <vlabs> ah
12:21:01 <Lutin^> what's your ghc version
12:21:44 <vlabs> lasgow Haskell Compiler, Version 7.6.3, stage 2 booted by GHC version 7.4.2
12:21:47 <vlabs> Using binary package database: /usr/local/Cellar/ghc/7.6.3_2/lib/ghc-7.6.3/package.conf.d/package.cache
12:21:49 <vlabs> Using binary package database: /Users/vlabs/.ghc/x86_64-darwin-7.6.3/package.conf.d/package.cache
12:21:51 <vlabs> hiding package Cabal-1.16.0 to avoid conflict with later version Cabal-1.20.0.1
12:21:53 <vlabs> wired-in package ghc-prim mapped to ghc-prim-0.3.0.0-d5221a8c8a269b66ab9a07bdc23317dd
12:21:55 <vlabs> wired-in package integer-gmp mapped to integer-gmp-0.5.0.0-2f15426f5b53fe4c6490832f9b20d8d7
12:21:57 <vlabs> wired-in package base mapped to base-4.6.0.1-6c351d70a24d3e96f315cba68f3acf57
12:21:59 <Lutin^> oh jesus please
12:21:59 <vlabs> wired-in package rts mapped to builtin_rts
12:22:01 <vlabs> wired-in package template-haskell mapped to template-haskell-2.8.0.0-c2c1b21dbbb37ace4b7dc26c966ec664
12:22:02 <Lutin^> stop
12:22:03 <vlabs> wired-in package dph-seq not found.
12:22:04 <Lutin^> pastebin
12:22:05 <vlabs> wired-in package dph-par not found.
12:22:07 <vlabs> sorry, didn't realize I dumped all of it
12:22:09 <vlabs> xD
12:22:11 <vlabs> yeah, realized
12:23:13 <vlabs> http://pastebin.com/yBKeB3Pk
12:23:39 <vlabs> is it old?
12:23:45 <Lutin^> Yeah
12:23:52 <vlabs> how old?
12:23:56 <Lutin^> I know some people have had issues with brew-installed GHC
12:24:05 * hackagebot gdiff 1.1 - Generic diff and patch  http://hackage.haskell.org/package/gdiff-1.1 (AndresLoeh)
12:24:09 <Guest54580> I tried a couple of Haskell examples but could never understand what is a monad. Now, I am playing with count dime exchange issue. It is a recursion that counds the combinations. Now, I think that I could run throught the same steps but instead of incrementing a counter, I could collect those combinations. Is it a monad or simple fold operation?
12:24:19 <Lutin^> vlabs: Well we're up to GHC 7.8.2
12:24:19 <vlabs> that sucks. I miss proper archlinux package management :(
12:24:25 <vlabs> Lutin^: :)
12:24:28 <Lutin^> Which was released in April 12 2014
12:24:35 <vlabs> oh, that's pretty recent
12:25:10 <Lutin^> But some suggest to install GHC and such this way
12:25:12 <Lutin^> http://haskell-lang.org/downloads/osx
12:25:21 <Lutin^> idk I'm on arch so..:P
12:25:38 <vlabs> yeah, pacman and yaourt <3
12:25:44 <Lutin^> ew
12:25:45 <vlabs> arch is really the best linux distro
12:25:50 <Lutin^> yaourt plz no
12:25:51 <vlabs> -_^
12:26:02 <vlabs> it's nice and overly cautious
12:26:10 <vlabs> wat's not to like? ;)
12:26:22 <Lutin^> It's buggy and breaks things
12:26:32 <Lutin^> Guest54580: Sounds like a good use for the list monad
12:26:39 <vlabs> Lutin^: no, I've never had any "buggy" experince with it
12:27:08 <vlabs> how many times do I have to go through the cabal update; cabal install cabal-install cycle?
12:27:27 <napping> should be once
12:27:33 <vlabs> napping: nope
12:27:42 <vlabs> napping: this is like the third time
12:27:50 <Lutin^> hmm
12:27:58 <Lutin^> Do you have ~/.cabal/bin on your Path?
12:28:01 <napping> well, if you say cabal install cabal-install-x.y.z for the most recent it should be just once
12:28:04 <nadirs> Lutin^: how is yaourt buggy? I've been using it flawlessly for about 1 and ²
12:28:12 <nadirs> * 1 and ½ year
12:28:15 <napping> yeah, also checking that you're actually running the newly installed cabal-install
12:28:27 <vlabs> napping: I didn't do that - I just said cabal install cabal-install
12:28:28 <napping> may need to rehash in the same shell?
12:28:31 <vlabs> Lutin^: I should
12:28:44 <napping> how about running cabal --version before and after?
12:29:21 <Lutin^> vlabs: aside -- this is why yaourt is bad https://wiki.archlinux.org/index.php/The_Arch_Way
12:30:06 <vlabs> Lutin^: once you get used to building PKGBUILDs by hand, it just gets tedious
12:30:17 <Lutin^> that's why pacaur ftw
12:30:33 <Lutin^> yaourt is too big and the code is ugly
12:30:36 <vlabs> napping: 0 version delta
12:30:57 <Lutin^> vlabs: What's your $PATH
12:31:04 <napping> and does it match the version it claimed to be installing?
12:31:25 <napping> Sounds very much like you are just repeatedly running the old cabal-install to install the same new cabal-install to somewhere not picked up on your path
12:31:30 <napping> also try "which cabal"
12:31:43 <Lutin^> Guest54580: Of course you can always do the same thing without using the monad interface
12:31:46 <vlabs> /usr/bin:/bin:/usr/sbin:/sbin:/usr/local/bin:/usr/local/git/bin:/usr/local/mongodb/bin:/usr/texbin
12:31:55 <vlabs> cabal's the one in /usr/local/bin/
12:32:05 <Lutin^> but that's the system
12:32:12 <Lutin^> cabal installs into ~/.cabal/
12:32:16 <vlabs> Lutin^: hm
12:32:31 <vlabs> AFAIK homebrew symlinks
12:32:48 <Lutin^> That would be wrong of them
12:33:02 <vlabs> Lutin^: *shrug*
12:33:23 <Lutin^> You use bash, yes?
12:33:32 <vlabs> zsh
12:33:44 <vlabs> at 1.20.0.1
12:33:47 <Lutin^> ah
12:33:54 <rorgor> how can I center 3 buttons with a distance and have the distance between increase and decrease with screensize?
12:33:58 <vlabs> the proper cabal that is
12:34:02 <Lutin^> Then you can just add 'export PATH=~/.cabal/bin:$PATH' to your .zshc
12:34:04 <Lutin^> .zshrc
12:34:25 <Lutin^> But that won't set it for xcode
12:34:28 <vlabs> Lutin^: did one better, moved the old cabal and symlinked the correct one
12:34:46 * Lutin^ cringes
12:34:51 <Lutin^> plz
12:34:52 <vlabs> rorgor: take percentages?
12:34:53 <Lutin^> plz no
12:34:54 <vlabs> Lutin^: :P
12:35:31 <Lutin^> I've been meaning to work on an implementation of Cassowary in Haskell that would be perfect for that
12:36:08 <vlabs> hm, apparently haskel-platform would break?
12:36:13 <Lutin^> vlabs: It appears OSX also has something called the path_helper tool
12:36:14 <vlabs> if I use cabal install?
12:36:30 <vlabs> Lutin^: interesting.
12:36:43 <Lutin^> that uses the /etc/paths.d/ directory
12:36:48 <vlabs> Lutin^: I just migrated to OSX. I don't like it. thanks for the tip
12:37:05 <Lutin^> Many people have suggested against using haskell-platform on OSX
12:37:18 <vlabs> Lutin^: so what's the "right" method?
12:37:21 <vlabs> download GHC?
12:37:23 <vlabs> >_<
12:37:23 <Lutin^> http://haskell-lang.org/downloads/osx
12:37:30 <vlabs> aww man
12:37:41 <vlabs> this feels like going back to windows >_>
12:37:44 <Lutin^> I mean you don't -have- to
12:37:56 <Lutin^> Hey man
12:37:59 <Lutin^> This is copying files
12:37:59 <vlabs> ?
12:38:03 <vlabs> xD
12:38:11 <Lutin^> enjoy your .apps
12:38:15 <rorgor> haskell on osx? haskell and limited resources, how would that work out?
12:38:26 <chrisdone> hur hur
12:38:32 <chrisdone> lutin^ <3
12:38:33 <vlabs> xD
12:38:34 <Lutin^> chrisdone: heh
12:38:43 <Lutin^> was waiting for you to notice
12:38:54 <chrisdone> ʘ‿ʘ
12:38:58 <vlabs> the keyboard is it's only saving grace
12:39:02 <vlabs> my god the keyboard is nice
12:39:11 <Lutin^> I really want a macbook air
12:39:24 <averell> because you hate high resolution?
12:39:37 <Lutin^> because I hate my laptop's weight and battery life
12:39:48 <vlabs> averell: :) resolution is nice, but it's more of an enhancement
12:40:02 <johnw> they should make a MacBook Helium next
12:40:13 <vlabs> johnw: imagine the marketing ;)
12:40:26 <dwcook> johnw, regarding your message to me earlier, I'm not sure that Applicative instance is valid, since it says you should be able to produce a Voided when that's clearly not supposed to be possible.
12:40:41 <dwcook> Barring _|_ of course.
12:40:50 <vlabs> haskell has bottom?
12:40:51 <johnw> doesn't the absurdity make that impossible?
12:41:20 <Lutin^> vlabs: yep
12:41:25 <Lutin^> undefined
12:41:39 <dwcook> johnw, you essentially created a logical contradiction. Let's say that a ~ (), aka truth. Then we have a proof that, given truth, falsity.
12:41:50 <johnw> ah
12:41:52 <vlabs> Lutin^:  I thought it had non-nullable types. doesn't a bottom invalidate that?
12:42:14 <dwcook> johnw, absurd is for when you're "given" a falsity and need to handle it.
12:42:22 <geekosaur> if you evaluate bottom, you get failure of some kind (an exception, an infinite loop, etc.)
12:42:35 <vlabs> geekosaur: ah.
12:42:35 <geekosaur> you can never eliminate all possible sources of bottom
12:42:43 <geekosaur> haskell just lets you reason about them a bit
12:43:13 <dwcook> But yeah, Haskell is happy to let you create contradiction if you're not careful :)
12:43:13 <vlabs> 128 KB/s ;_;
12:43:41 <Lutin^> iirc Haskell would have to be a total functional language to get rid of bottom in most cases
12:44:28 <Lutin^> which would make it not turing-complete
12:44:58 <dwcook> I still need to learn how to reason about data and codata as separate things
12:45:06 <chrisdone> woooo ride the netsplit ヽ (＾▽＾) ﾉ
12:45:15 <vlabs> what's with the sudden influx?
12:45:23 <chrisdone> someone unsafePerformIO'd
12:45:24 <dwcook> vlabs, netsplit ended
12:45:25 <Lutin^> woo weechat smartfilter I didn't see anything
12:45:39 <chrisdone> @quote unsafePerformIO
12:45:39 <lambdabot> Spockz says: it's just that my first name isn't Simon so I'm not allowed to use unsafePerformIO :P
12:46:05 <vlabs> dwcook: ahh
12:46:06 <Clint> anyone have a handy example of parsing "key delimiter value" with happy+alex?
12:46:09 <luite> :(
12:46:37 <vlabs> Lutin^: a fellow weechat user? :)
12:46:40 <chrisdone> luite: turn that frown uʍop ǝpᴉsdn
12:46:53 <Lutin^> you know it
12:47:18 <dwcook> chrisdone, ):
12:47:31 <chrisdone> dwcook: touché
12:48:53 <vlabs> why the hell is GHC close to a gigabyte?
12:49:14 <chrisdone> @google why is ghc so big
12:49:16 <lambdabot> http://stackoverflow.com/questions/4858585/why-is-ghc-so-large-big
12:49:16 <lambdabot> Title: haskell - Why is GHC so large/big? - Stack Overflow
12:49:33 <chrisdone> ≖‿≖
12:49:40 <luite> chrisdone: hehe i'm just grumpy because i'm trying to make things build on windows
12:49:47 <vlabs> :)
12:49:49 <chrisdone> luite: i don't envy you
12:50:08 <Lutin^> #haskell needs +s
12:50:29 <luite> while actually i want to work on the uberl33t template-haskell on node.js evaluator
12:50:43 <napping> huh?
12:50:55 <napping> specifically template-haskell?
12:51:03 <napping> like calling Haskell from node.js
12:51:07 <napping> and just never bothering to return :)
12:51:15 <Hodapp> calling Haskell from Node.js wut?
12:51:44 <napping> luite: If you're just saying you'd rather be working on node.js than on building for windows, I believe you
12:52:05 <vlabs> The Glorious Glasgow Haskell Compilation System, version 7.6.3 | I hope I did it right? :)
12:52:34 <Lutin^> Should be 7.8.2
12:52:38 <luite> napping: oh no, it's for template-haskell on ghcjs
12:53:02 <luite> currently loads native libs, but that makes the installation less flexible
12:53:10 <Lutin^> vlabs: uninstall the brew version
12:53:19 <napping> hmm, I'm just imagining a node plugin that includes a GHC runtime
12:53:30 <Lutin^> and read the instructions in the link I gave
12:53:59 <luite> napping: doesn't quite work, since that would still require native code
12:54:21 <napping> can't you provide native code?
12:54:28 <luite> you need the code for the dependencies you have and for the current module
12:54:41 <napping> ah, you mean of the Haskell. Okay
12:54:46 <Lutin^> node.js uses native code for it's http-parser so I don't see why you couldn't have native code for the GHC runtime
12:54:49 <Lutin^> Oh
12:54:51 <Lutin^> ghcjs
12:54:57 * Lutin^ sees himself out
12:55:04 <luite> napping: sure, but why use node.js at all then? then running it in ghci is much easier (just like template haskell is usually done)
12:55:20 <chrisdone> luite: my favourite pic is this https://lh5.googleusercontent.com/-P79JtrmNyg0/U5llGGwMU6I/AAAAAAAANNI/RBAvGWhkms0/w2210-h1480-no/DSC_0730.JPG
12:55:33 <napping> well, I was thinking you might be able to sell it as plugin for accelerating parallel processing or something :)
12:55:36 <coolwhip> hey I am using smartborders for managing my workspaces and it works awesome with the exception of one window that automatically floats when it runs. I want it to tile instead, is it possibly to tell xmonad to do this?
12:55:38 <chrisdone> luite: smile, smile, smile. luite: 1000-yard stare
12:55:43 <luite> :(
12:55:55 <chrisdone> luite: that's because of windows, i now know
12:55:58 <luite> i mean :|
12:56:15 <chrisdone> :) :) :) :) :) :) :) :) :) :|
12:56:37 <bitemyapp> chrisdone: that's a great picture :)
12:57:06 <napping> I'm having a bit of trouble with parsec myself now, with parens and mutual recursion between two nonterminals
12:57:13 <vlabs> Glasgow Haskell Compiler, Version 7.8.2, stage 2 booted by GHC version 7.6.3
12:57:49 <napping> basically Exp includes Id "(" ArgumentList ")", ArgumentList is mostly ","-separated Expr
12:58:11 <luite> chrisdone: hey don't you just feel like fixing a few cabal bugs today, like #1884? ;)
12:58:11 <napping> Except I'd like to allow also Exp = "(" Exp ")" and ArgumentList = "(" ArgumentList ")"
12:59:29 <Lutin^> chrisdone: Which one are you
12:59:33 <Lutin^> are you that coke bottle
12:59:35 <Lutin^> I bet you are
12:59:46 <chrisdone> luite: https://lh6.googleusercontent.com/-XluvrumIuT4/U5lkoH1uG1I/AAAAAAAAM74/QlGHAl6lcp0/w2234-h1496-no/DSC_0482.JPG
12:59:47 <chrisdone> luite: https://www.google.it/search?q=robert+carlyle&tbm=isch
12:59:54 <chrisdone> luite: amirite?
13:00:33 <luite> hmm google.it doesn't load here :/
13:00:47 <chrisdone> huh, weird. it should redir to .de
13:00:54 <chrisdone> Lutin^: i'm not there
13:01:19 <luite> why .de?
13:01:22 <vlabs> ^
13:01:36 <chrisdone> luite: i thought you were in .dermany
13:02:03 <luite> oh no netherlands
13:02:15 <chrisdone> luite: the true haskell nomad
13:02:22 <vlabs> :)
13:03:12 <vlabs> what the.. cabal just reverted my haskell version ;_;
13:04:57 <vlabs> hm, guess running force-reinstall once and then moving the old ghc out of the way did the trick
13:04:58 <napping> cabal never installs ghc
13:05:00 <vlabs> thanks all!
13:05:14 <vlabs> napping: it must have, the old ghc popped up suddenly
13:05:20 <vlabs> napping: I'm not sure what happened
13:05:32 <vlabs> anyway, I moved ghc and problem solved >_>;
13:05:37 <napping> probably your path is behaving strangely
13:05:44 <vlabs> napping: 'tis possible.
13:05:45 <napping> I usually just run a fresh terminal after installing anything
13:05:52 <vlabs> napping: good point
13:06:00 <vlabs> hm, anyway, night all!
13:06:05 <napping> or at least run `which foo` and `foo ==version`
13:06:18 <vlabs|Zzz> version was 7.6 now 7.8
13:09:18 <mmmm_> Does djinn work with lists?
13:10:57 <dwcook> mmmm_, not that I recall, but it's worth trying (e.g., in a PM)
13:11:14 <dwcook> Yeah, I get undefined type
13:11:20 <rwbarton> no
13:11:22 <mmmm_> yeah I was wondering if I was missing something
13:11:26 <rwbarton> lists are very boring from a logical standpoint
13:11:50 <dwcook> rwbarton, in that you can always come up with one?
13:12:14 <rwbarton> and if you receive one, it might just be empty
13:12:56 <dwcook> That does sort of tell you how general the types of functions over lists are too. [a] -> [a] has tons of interpretations
13:13:20 <bitemyapp> dwcook: tons?
13:13:36 <dwcook> bitemyapp, sure, drop n, take n, take just the odd elements, etc.
13:13:45 <dwcook> It could also be const []
13:13:56 <Black-Heaven> Lutin^: not better
13:14:08 <dwcook> bitemyapp, s/interpretations/values/
13:14:21 <Black-Heaven> unable to compile site.hs: http://pastebin.com/kEUH5c3u
13:14:22 <bitemyapp> dwcook: fair enough, but I'm comparing it with the same type in less nice languages and see a lot of possibilities eliminated.
13:14:33 <bitemyapp> dwcook: like Ord and a -> Bool not being included.
13:14:38 <dwcook> bitemyapp, I won't argue that. I was speaking just within the framework of Haskell.
13:14:58 <Jefffrey> Hello
13:14:58 <Jefffrey> Is there a way to test for inequality in Hspec?
13:15:00 <Jefffrey> I can't find a way.
13:15:25 <bitemyapp> dwcook: the uncertainty comes primarily from cardinality, AFAICT.
13:15:29 <Lutin^> Black-Heaven: You should use cabal if you're in a sandbox
13:15:33 <Lutin^> not ghc directly
13:15:42 <Lutin^> otherwise you need to set the cabal package directory
13:15:55 <bitemyapp> dwcook: the number of possible outputs is limited by the length of the list.
13:16:16 <Lutin^> Black-Heaven: Which you can do like this
13:16:18 <Lutin^> ghc -no-user-package-db -package-db .cabal-sandbox/*-packages.conf.d
13:16:31 <dwcook> bitemyapp, would you agree that drop 100 is a different function from drop 1000 even though you might pass it lists of fewer than 100 elements?
13:16:41 <dwcook> s/it/them both/
13:16:50 <Lutin^> Black-Heaven: But I strongly suggest writing a little cabal file and using cabal
13:17:22 <bitemyapp> dwcook: yeah sure.
13:17:26 <Black-Heaven> ok, thanks
13:17:44 <bitemyapp> dwcook: I'm thinking about the domain and codomain of [a] relative to []'s length right now.
13:18:17 <luite> grr filename/path handling is impossibl to do correctly...
13:18:35 <chrisdone> impossibru!
13:19:06 <luite> oh my 'e' key is still not working right
13:19:10 <luite> i ned a new laptops
13:19:11 <luite> -s
13:19:42 <chrisdone> luit
13:20:33 <luite> but system-filepath is more or less unusable since almost everything takes a normal path, and then on windows you have tools that expect / paths in msys and others that expect \
13:20:47 <luite> how can people live like this?
13:29:05 <bitraten_> hi, how can i map over all occurences of a string like "#example" in a larger string
13:29:40 <dwcook> bitemyapp, map over? What type/behavior are you looking for?
13:29:42 <zwer> if a window tool doesn't work with \ path separators it is broken. most winapi functions work with / separators and all of them work with \
13:30:26 <bitraten_> dwcook: i wanna convert tags (words starting with #) to an url <a>#example</a>
13:31:44 <pavonia> @hoogle subRegex
13:31:45 <lambdabot> Text.Regex subRegex :: Regex -> String -> String -> String
13:31:45 <dwcook> bitraten_, you might want some form of parser for that.
13:31:51 <dwcook> Orrr that
13:32:35 <bitraten_> thanks
13:37:37 <athan> Does anyone know if HXT has a `find` function, or something sane like that?
13:38:26 <athan> `hasAttrValue` just returns the virtual xml tree of the key and value :S
13:45:01 <joshc> how good is ghc's constant folding?  like, if I use one of the various HTML combinator libraries and completely static data; would ghc optime
13:45:25 <joshc> *optimize a render to the rendered string at compile time
13:45:28 <joshc> ?
13:49:10 <joshc> maybe an experiment is in order :)
13:49:18 <kazagistar> joshc: its probably not good enough to do that, and you probably have to use TH or something else
14:00:42 <statusfailed> Does gpipe install for anyone else?
14:01:07 <statusfailed> I don't understand the strange new world of cabal error messages :D
14:16:09 <kazagistar> statusfailed: are you using a sandbox?
14:16:09 * hackagebot haskell-docs 4.2.0 - A program to find and display the docs and type of a name  http://hackage.haskell.org/package/haskell-docs-4.2.0 (ChrisDone)
14:16:10 <tolt> statusfailed: I'm not able to install it in a fresh sandbox
14:16:10 <statusfailed> kazagistar: yes I think so: I just have to do "cabal sandbox init" right?
14:16:10 <tolt> statusfailed: I just realized that it hasn't been built for the newer containers.
14:16:10 <statusfailed> tolt: are you the author?
14:16:10 <tolt> statusfailed: nope
14:16:10 <statusfailed> tolt: oh :)
14:16:11 <kazagistar> he is just verifying that it is not your fault that it wont install as per request
14:16:11 <statusfailed> oh I see
14:16:11 <statusfailed> Using the latest git code seems to fare better, but still doesn't work
14:16:12 <tolt> statusfailed: Yeah. It looks like it has a dependency or two that hasn't been updated either.
14:16:13 <gamegoblin> If I have a vector and an index N, and then I have an expression which called myVector ! n about 4 times, should I assign myVector ! n in a let block beforehand, or will the backend optimizer take care of that, I wonder...
14:16:30 <johnw> you need to use the let form
14:16:44 <johnw> GHC won't necessarily do common subexpression elimination, and in this case I think it won't
14:18:14 <averell> with 4 times it's just more readable anyway, no?
14:19:09 <chrisdone> check the core
14:21:29 <johnw> chrisdone!!!
14:25:26 --- topic: 'http://www.haskell.org/ | Paste code/errors: http://lpaste.net/new/haskell | Logs: http://tunes.org/~nef/logs/haskell/?C=M;O=D http://ircbrowse.net/day/haskell/today?mode=recent | Administrative issues: #haskell-ops | Hackage down? http://hdiff.luite.com | XCode 5 issues? http://is.gd/H4sEub'
14:25:26 --- topic: set by Cale!~Cale@CPEc8d3a35c2cdd-CM78cd8ec9750d.cpe.net.cable.rogers.com on [Sat May 31 02:09:44 2014]
14:25:26 <johnw> haskell-mode again
14:25:27 <chrisdone> @hoogle fromFractional
14:25:28 <lambdabot> No results found
14:25:49 <bergmark_> i watched the purescript hangout and now i want to write an elisp backend for it
14:25:53 <chrisdone> johnw: ye gods!
14:26:06 <chrisdone> bergmark_: haha
14:26:10 <chrisdone> purelisp
14:26:26 <johnw> wow, it has really come far
14:26:26 <sshine> isn't the Readable typeclass preferrable over Read? (it generally returns Maybe blah)
14:26:32 <johnw> good job chrisdo
14:26:33 <johnw> ne
14:26:42 <chrisdone> thanks :3
14:27:08 <sshine> chrisdone, got a recent preview?
14:27:35 <chrisdone> sshine: i think everything on the README is recent. johnw hasn't tried it for like a year
14:27:49 <johnw> I'm just going to flip the meaning of C-j and RET
14:27:58 <johnw> seems my preference is the inverse of every mode author
14:28:07 <sshine> chrisdone, sorry, I thought johnw was referring to the haskell.org re-design :)
14:28:58 <johnw> i'd recommend shm-mode as an alias for structured-haskell-mode too
14:28:58 <chrisdone> johnw: i think if you're going to use it then i'll fix kill/yank for expressions whose parent column exceeds their children (it worked a while ago but i broke it and never had incentive to fix)
14:29:07 <sshine> johnw, I'd want ^O to insert above my line, move there and indent (like S-o does in vim).
14:29:14 <johnw> chrisdone: ok, well I'm going to seriously give this a try again
14:29:30 <hunt>  what is Purescript?
14:29:56 <systemfault> hunt: A haskell-ish language that compiles to JS (IIRC)
14:30:22 <bergmark_> right
14:30:25 <johnw> @google what is Purescript?
14:30:26 <lambdabot> https://github.com/purescript/purescript
14:30:55 <johnw> chrisdone: dude, seriously, good job
14:31:00 <johnw> this is incredible
14:31:06 <chrisdone> johnw: i expect something'll tick you off about it, but maybe you can set the shm-map to somethin empty and just add things that are unintrusive
14:31:28 <chrisdone> thanks =p
14:32:30 <johnw> i've been writing a lot of Agda this week
14:32:36 <johnw> so it's made we wish for better integration with GHC again
14:33:04 <chrisdone> yeah, agda-mode still puts haskell-mode to shame
14:34:25 <johnw> how come "do " adds two undefineds, and how should I jump to the next one?
14:36:15 <Fernandos> hi
14:36:45 <chrisdone> johnw: it adds two under the assumption that if you're do'ing you're doing more than one thing
14:37:00 <chrisdone> johnw: you hit TAB to jump between them, or <backtab> to go back
14:37:02 <johnw> but if I type do<RET>, it doesn't, right?
14:37:20 <chrisdone> nope. some people've requested that to do something
14:37:22 <johnw> ah, do<RET> provides an indentation of 2, although I configured it to use 4
14:37:43 <chrisdone> i think do<RET> is kind of an "undefined behaviour"
14:37:58 <johnw> ok, then I'll need to configure this sort of stuff
14:38:10 <johnw> I really dislike "do expr", as you well know :)
14:38:13 <chrisdone> although you can write
14:38:23 <chrisdone> do foo
14:38:24 <chrisdone>    bar
14:38:26 <chrisdone> and then go to the do
14:38:28 <chrisdone> and hit C-c C-j
14:38:32 <johnw> but otherwise I love what I'm seeing
14:38:32 <chrisdone> which will "swing" them down
14:38:42 <chrisdone> sloan's been using that feature
14:38:55 <chrisdone> i might be able to implement the do<RET> in similar terms
14:39:04 <johnw> if I can help, just give me pointers
14:39:10 <sshine> HaskellWiki says that Hask is a category in spite of '\x -> undefined' and 'undefined' are both of 'a -> b', since they "are the same morphism". does that mean that we only care about the fact that they have the same types, and that 'const 4' and 'const 5' "are the same morphism" as well?
14:39:39 <chrisdone> try the C-c C-j to see if it goes where you'd expect
14:40:06 <johnw> since ":i Type" shows you the data constructors for ADTs, we should be able to introduce a case expansion that auto-pattern matches on all the constructors
14:40:20 <johnw> C-c C-j gives me Debugger entered--Lisp error: (wrong-type-argument char-or-string-p nil)
14:40:24 <sshine> sorry - HaskellWiki does not say that Hask is a category, but that it's not not a category because of what I just said.
14:40:27 <johnw> oh, you mean after typing stuff
14:40:36 <chrisdone> johnw: try M-x shm/case-split
14:40:43 <johnw> I think Hask is a special form of CPPO category
14:40:50 <sshine> johnw, CPPO?
14:41:01 <sshine> johnw, Cartesian Closed Category O...?
14:41:06 <johnw> Cppo⊥ to be specific
14:41:09 <johnw> see http://takeichi.ipl-lab.org/~hamana/Papers/cpo.pdf
14:41:16 <sshine> cool. thanks :)
14:41:40 <chrisdone> might have to (require 'shm-case-split)
14:41:41 <sshine> I was reading Wadler's Comprehending Monads and his mentioning cartesian closed categories has so far taken me on a three-day detour.
14:42:01 <johnw> chrisdone: don't have that file
14:42:03 <johnw> is it very new?
14:42:17 <johnw> i'm using 1.0.2, packaged in Nix
14:42:18 <chrisdone> here: https://github.com/chrisdone/structured-haskell-mode/blob/master/elisp/shm-case-split.el#L1
14:42:34 <chrisdone> pretty old i guess. some months
14:42:49 <johnw> huh
14:42:56 <johnw> should I update Nix then?
14:42:57 <sshine> johnw, thanks.
14:43:17 <chrisdone> johnw: hmm, maybe because it's not in the makefile
14:43:17 <johnw> is the current HEAD considered stable?
14:43:22 <johnw> ah
14:43:37 <johnw> no, that wouldn't be it
14:43:39 <chrisdone> i didn't put it in the Makefile because it depends on haskell-process, which some people don't use
14:43:45 <johnw> the Nix recipe says: install "elisp/"*.el "elisp/"*.elc  $out/share/emacs/site-lisp
14:43:54 <chrisdone> ah
14:44:01 <chrisdone> perhaps they're going off of the hackage package
14:44:02 <johnw> oh, weird, it's there
14:44:14 <chrisdone> oh, you have it?
14:44:27 <johnw> one sec
14:45:06 <johnw> i don't and i do, have to figure this out; i'll continue this in #haskell-emacs
14:45:45 <asg0451_> \join
14:45:54 <Fernandos> I'm (also) writing a paper about FRP and in short my understanding of (discrete/continous) integrators of input signals over time using  λ (anonymous functions) in response to events over time can  also known as integral = λs.λt.∫ (0^t) s(t)dt can basically be expressed by a *NN (deep neuronal network). Or am I wrong with that?
14:46:51 <Lutin^> chrisdone: maybe I should try emacs..:/
14:47:43 <toki78> why are the other channels so little talkative ?
14:47:46 <Fernandos> To my understanding the difference of anytime algorithms (http://en.wikipedia.org/wiki/Anytime_algorithm) and FRP are only of formal nature and that anytime algorithms are forms of continous  AFRP systems in example..
14:48:35 <Lutin^> Maybe I could do it with Evil
14:48:59 <DilatedPupils|TH> pen tested a site today, able to intercept the request going to paypal and changed the payment to 1p, how many of the sites use the wrong implementation
14:49:39 <toki78> Fernandos, are these iterative algos ?
14:49:42 <Lutin^> DilatedPupils|TH: Wait they did the request client-side?
14:50:00 <chrisdone> Lutin^: maybe!
14:50:31 <Fernandos> toki78: What anytime algorithms?
14:50:32 <DilatedPupils|TH> yes, a lot off sites do
14:50:39 <Fernandos> or do you refer to FRP?
14:50:40 <toki78> Fernandos, yes
14:50:43 <Lutin^> ..that's stupid
14:50:56 <toki78> Fernandos, anytime algos
14:51:32 <DilatedPupils|TH> a LOT of sites have this problem
14:51:37 <toki78> Fernandos, can you help me ? what is an FRP ?
14:51:38 <Lutin^> DilatedPupils|TH: Do you know which Paypal API they used?
14:51:39 <Fernandos> toki78: not neccesarily, the naive implementation is, but can also be implemented using continuations and doesn't need to be 'truly iterative'
14:51:51 <DilatedPupils|TH> hm, no
14:51:53 <toki78> Fernandos, ok
14:51:59 <Lutin^> When I used Adaptive Payments the only clientside request was a redirect to the login and accept pages
14:52:45 <Lutin^> And we implemented our own API endpoints to do the Paypal API calls on the serverside
14:53:00 <DilatedPupils|TH> out of interest i had a look at a major site such as dominos, they were issued a token
14:53:52 <DilatedPupils|TH> then i looked at some live sites that i use, and found the issue there so emailed them just in case, doubt they will fix it
14:54:16 * hackagebot structured-haskell-mode 1.0.3 - Structured editing Emacs mode for Haskell  http://hackage.haskell.org/package/structured-haskell-mode-1.0.3 (ChrisDone)
14:55:14 <Fernandos> toki78: basically any algorithms like those used within MariaDB (formerly MySQL) that calculate responses to declarative requests operate within the CAP theorem and the use of FRP helps to integrate signals over time using lambda expressions. Not much different than using (s)FFT's for the integration of events over time.
14:55:33 <Fernandos> That's my current understanding of it.
14:55:58 <DilatedPupils|TH> i got disconnected, any messages aimed at me?
14:56:24 <toki78> Fernandos, I have a rough understanding now
14:56:46 <Fernandos> DilatedPupils|TH: make them an offer to fix it, for a fixed price (or rate) and I guess they'd consider it..
14:57:09 <eazar001> \leave
14:57:36 <DilatedPupils|TH> Fernandos haha they have their own dev team
14:58:37 <Fernandos> DilatedPupils|TH: Dev teams often times don't have  (certified) Penetrations Testers, who can really tell what's wrong with security and fix it.
14:58:52 <Fernandos> so they're less priviliged than you are :)
14:59:37 <DilatedPupils|TH> indeed, i would expect the tech architect to be informed
14:59:49 <Fernandos> toki78: no worries, you can find so much fuss about FRP and (almost) nobody talks really about what it really is in essence. All the writings describe the behaviour of FRP and rarely you find how it really works. (Implementations don't count, imho)
15:00:32 <Fernandos> hmm from my (limited) experience, there are also no real software architects in dev teams, just clever implementors
15:00:54 <toki78> Fernandos, what does FRP stand for ?
15:01:02 <Fernandos> Functional Reactive Programming.
15:01:10 <DilatedPupils|TH> i work in ecommerce, have been on supplier and client side, each site tends to have a TA
15:01:27 <toki78> thx
15:01:49 <DilatedPupils|TH> but for the bigger clients they do pen test before every major release
15:02:51 <Fernandos> Cool, I've been in some startups and none had a real software architect, but some clever sysadmin who was also partially involved in that role.
15:03:01 <Fernandos> in eCommerce too
15:03:44 <toki78> Fernandos, the system changes on a signal ?
15:04:17 * hackagebot webdriver 0.5.5 - a Haskell client for the Selenium WebDriver protocol  http://hackage.haskell.org/package/webdriver-0.5.5 (AdamCurtis)
15:04:54 <Fernandos> a signal is a trigger that lifts an event, that's when a system changes, but many implementations of FRP are a little different on that detail
15:05:29 <Lutin`> DilatedPupils|TH: Sorry I lost connection after you mentioned dominoes
15:05:32 <Lutin`> What were they doing?
15:06:14 <Lutin`> Oh hey a webdriver update :D
15:06:31 <Fernandos> toki78: this is how I think you can describe FRP too http://groups.csail.mit.edu/netmit/sFFT/algorithm.html
15:08:36 <Fernandos> the difference is that this is the pure FFT algorithm and has no relation to any View/Model/Controller, Object or similar. It can be implemented as an ADT (algebraic data type) though
15:08:39 <toki78> Fernandos, event driven programming for haskell ?
15:09:36 <Fernandos> toki78: Not sure what the question is related to in context. Can you clarifiy, please?
15:10:44 <Fernandos> The FRP Manifesto says that it is even driven, yes. If you mean that.
15:11:44 <toki78> yep
15:15:19 <Fernandos> FRP just tries to pack those 'events' into a (continous) stream, whilst not really being completely transparent on the behavior over time.
15:15:59 <Fernandos> still looking for a paper that explains it using lambda expressions..
15:18:23 <Fernandos> Curious how using "Memristor Logic" in a functional dataflow language would affect the complexity of the overall system and if it would make the language and also the behaviour over time more transparent and simple.
15:21:29 <toki78> Fernandos, naively said : type of FRP :: state -> signal -> state ???
15:22:02 <Fernandos> not sure
15:22:05 <Fernandos> sorry :)
15:22:21 <kazagistar> thats not quite right I think
15:22:23 <toki78> that's how I would understand it
15:32:44 <Noitanigami> is there an FAQ for installing libraries with Cabal? (in windows)
15:33:32 <Noitanigami> I'm getting an error when installing HopenCV.
15:35:10 <pavonia> Noitanigami: What error?
15:36:33 <Noitanigami> The program pkg-config version >=0.9.0 is required but it could not be found.
15:36:59 <Noitanigami> ... Exception was: ExitFailure1
15:37:35 <pavonia> You need to install that tool
15:39:42 <JagaJaga> Hi! I can see package in my `ghc-pkg list`, but my xmonad can't see it. Telling me that it can't find module. What can be wrong?
15:40:51 <Noitanigami> this was my guess, but a web search is only bringing up llvm-pkg-config. Are these the same thing?
15:41:13 <ij> Lambda calculus has free variables. In haskell those would be an error?
15:42:37 <Noitanigami> never mind. I didn't realize pkg-config wasn't haskell specific
15:43:56 <c_wraith> ij: mostly
15:44:35 <c_wraith> ij: there is an extension that allows free variables, but it's..  well, it's dynamic scoping.  Languages stopped doing dynamic scoping a long time ago for a good reason.
15:45:28 <jfischoff> what extension?
15:45:31 <c_wraith> :t \x -> x + ?y  -- ij: lambdabot has the extension enabled, this is what it looks like
15:45:31 <lambdabot> (?y::a, Num a) => a -> a
15:45:39 <jfischoff> oh
15:46:18 <ij> I'm guessing y never changes in scope of the program, yes?
15:46:31 <c_wraith> ij: it can, actually.
15:46:45 <ij> And that messes with purity?
15:46:53 <c_wraith> ij: it just happens that in order to use that, you need to have something named ?y in scope
15:47:07 <c_wraith> ij: either defined, or showing up in the type signature
15:47:46 <ij> The more you know. Thanks.
15:47:56 <c_wraith> > let x = ?y + 1 in (let ?y = 5 in x, let ?y = 7 in x)
15:47:57 <lambdabot>  (6,8)
15:48:20 <kazagistar> I would assume it just does something where it writes the function with ?y as just a parameter, and then automatically passes whatever is named "y" in the scope you call it in to that parameter
15:48:31 <c_wraith> ij: at the implementation level, it's converted to a function parameter
15:49:19 <jfischoff> :o
15:49:21 * hackagebot HaTeX 3.13.1.0 - The Haskell LaTeX library.  http://hackage.haskell.org/package/HaTeX-3.13.1.0 (DanielDiaz)
15:49:34 <kazagistar> interesting that it exists I guess
15:50:27 <kazagistar> the reason no one ever programs that way is because it is like the worst form of hiding side effects
15:50:48 <c_wraith> well, it's not totally hidden.  It shows up in type signatures.
15:51:10 <c_wraith> But that makes it super-clear that it's just a semi-hidden argument-passing technique
15:51:19 <c_wraith> and so people tend to prefer to just be a bit more explicit.
15:51:32 <kazagistar> c_wraith: fair enough, thats better then most such languages I guess
15:52:01 <kazagistar> I mean dynamic scope languages
15:52:09 <c_wraith> yeah
15:52:24 <c_wraith> though the only language I know of that still gets any use and is dynamically scoped is elisp
15:52:45 <c_wraith> And everyone just expects elisp to be a mess.
15:52:47 <kazagistar> perl supports it, right?
15:52:58 <c_wraith> I think it supports it, but it's not the default anymore
15:53:09 <chrisdone> kazagistar: where `it' is .* right?
15:53:54 <c_wraith> Though it's apparently a common pattern to reinvent dynamic scoping in ruby by patching Object with new methods and then changing them occasionally.
15:54:00 <kazagistar> I dont know enough perl to confirm or deny, thats why I had a (?) at the end
15:54:11 <c_wraith> ...  Why does ruby keep reinventing known bad design?
15:55:04 <Fernandos> Anyone having knowledge about Topological Domain Theory?
15:55:10 <monochrom> because they only invent, never design.
15:55:11 <kazagistar> as far as I can tell "because it is awesome"
15:55:13 <Fernandos> [1] http://homepages.inf.ed.ac.uk/als/Research/topological-domain-theory.html
15:55:17 <jfischoff> c_wraith: well they don’t of TH or Generics, so that is one way to generate boilerplate
15:56:59 <monochrom> they only pile cool features on top of each other, and never ask "what is the semantics of the whole thing"
15:58:21 <chrisdone> monochrom: some would argue C++ is the epitome of that
15:58:41 <c_wraith> and C++ has been suffessful!
15:58:53 <c_wraith> ...  what? Successful
15:59:28 <johnw> this isn't the place for language bashing
15:59:31 <chrisdone> it seems natural that the less you can express in your language the more extension it needs
15:59:42 <kazagistar> eh, C++ seems to have OK "semantics of the whole thing" as long as the whole thing only includes the newer stuff and stick to well trodden paths
15:59:56 <kazagistar> its more twisted by back compatibility then lack of vision
16:00:42 <chrisdone> johnw: i'm not going back to #language-bashing
16:00:56 <chrisdone> *cuts to scene of wild animals tearing eachother apart and flames in the background*
16:01:01 <chrisdone> never again
16:01:29 <c_wraith> I heard some terrible language called Haksell only lets you write programs that can't do anything.
16:01:32 <chrisdone> http://i.imgur.com/J77aBll.gif
16:01:41 <johnw> haha
16:03:10 <Zekka> c_wraith: My programs are so lazy I don't even invoke them.
16:03:23 <c_wraith> Zekka: that's some optimization
16:04:56 <chrisdone> my programs are so optimized i ran them through a tibbe . bos . dons :: Core -> Core function and it came out the same
16:05:43 * cehteh is so lazy he doesnt program in haskell at all
16:05:44 <jfischoff> no marlow?
16:06:25 <luite_> chrisdone: careful with that, if the dons rules fire too early, bos might not be able to do anything anymore
16:06:54 <chrisdone> luite_: that's ok, dons is mostly a no-op these days
16:07:20 <luite_> (actually the order seems appropriate, with dons fusion first, bos specialization second and tibbes low-level bitops last)
16:07:33 <chrisdone> tibbe's tid-bits
16:07:37 <luite_> hehe
16:07:45 <chrisdone> tibbit
16:07:49 <luite_> he should make a blog out of that
16:07:54 * chrisdone laughs at his own silly puns
16:08:05 <chrisdone> yeah he should xD
16:08:16 <johnw> I will live my life once someone starts reading my auto-biography
16:09:02 <Zekka> I think Haskell has the fastest sorts I've seen in any language: http://pastebin.com/8NW6P7et
16:09:16 <chrisdone> and then your gravestone will have on it: ”
16:09:38 <chrisdone> lol
16:09:45 <chrisdone> zekka: took me a second
16:09:46 <Zekka> also, that's actually one trillion, my mistake
16:10:07 <Zekka> But one quadrillion actually takes a slightly shorter time for me
16:10:10 <luite_> Zekka: and that's even unoptimized and interpreted
16:10:14 <chrisdone> assuming this isn't a cute joke, that list is never evaluated
16:10:18 <rwbarton> it only took ghc 0.360 seconds
16:10:43 <joelteon> chrisdone: nonsense...the compiler clearly short-circuited the sort since it knows the list is strictly ascending :)
16:10:49 <Zekka> chrisdone: Really? You mean I bought those thousand terabytes of memory for nothing?
16:11:09 <joelteon> it doesn't take a thousand terabytes of memory to store the numbers from 1..1000000000000
16:11:16 <chrisdone> zekka: maybe you could trade them in for cookies
16:11:25 <luite_> Zekka: you don't need that anymore, just compile with the -fcloud-haskell flag and it will compute it on the cloud
16:12:04 <Zekka> http://pastebin.com/07Y6RC2w <- O(1) sorting as n approaches infinity
16:12:28 <luite_> Zekka: but it's faster now, 0.240 seconds
16:12:44 <luite_> Zekka: that means that bigger cardinals should sort even faster
16:12:49 <chrisdone> sleep sort is better http://dis.4chan.org/read/prog/1295544154
16:13:21 <johnw> I have the most optimized sort in existence.  It is merely confined to lists of length 1
16:13:28 <kazagistar> we need a /r/vxjunkies specifically for haskell
16:13:32 <rwbarton> try l = [1.0..]
16:13:33 <quchen> Whenever I want to laugh at an algorithm, I re-learn and re-understand slowsort. Never failed me.
16:14:02 <chrisdone> quchen: is that the one with the hilarious paper?
16:14:09 <quchen> Yes.
16:14:23 * hackagebot pipes-csv 1.4.0 - Fast, streaming csv parser  http://hackage.haskell.org/package/pipes-csv-1.4.0 (WilliamCasarin)
16:14:29 <quchen> Pessimal algorithms and simplexity analysis. Uses multiply and surrender instead of divide and conquer.
16:14:42 <chrisdone> “Contrary to most algorithmic persuits, we actively aimed to create an algorithm that would have the appearance of speed but be incredibly slow.” or something like that
16:15:11 <chrisdone> www.cs.uiuc.edu/class/fa05/cs473ug/resources/pessimal-algorithms.pdf
16:15:20 <kazagistar> vxjunkies is a bit too hardware focused for my taste, I want something for math and algorithms and design patterns and such
16:15:29 <quchen> The cool thing is that their algorithms don't waste any time. They constantly work towards the goal.
16:15:38 <quchen> Slowsort doesn't repeat any comparison I think.
16:15:42 <chrisdone> Of course, we can get very slow algorithms by adding spurious loops before the first test of X against the Ai . However, such easy solutions are unacceptable because any fool can see that the algorithm is just wasting time. Therefore, we must look for an algorithm that does indeed progress steadily towards its stated goal even though it may have very little enthusiasm for (or even a manifest aversion to) actually getting there.
16:15:45 <chrisdone> hahaha, i loev this paper
16:16:18 <quchen> Slowsort is basically mergesort, but with a really silly merge operation.
16:16:42 <quchen> http://lpaste.net/106409
16:17:12 <quchen> Where splitMid splits a list in two halves
16:19:05 <kazagistar> Intuitively, a reluctant algorithm for a problem P is one which wastes time in a way that is suﬃciently contrived to fool a n¨aive observer. We can make this concept mathematically precise by saying that A is a reluctant algorithm for P iﬀ [equation] where N is the set of all n¨aive observers, t is time, W(A, t, W, P) is the predicate “A wastes time t in the way W while solving P”, and F(W, o) is the predicate 
16:19:38 <Zekka> Guys, I've just defined the fastest sortedset implementation: http://pastebin.com/70qWZXXW
16:19:59 <dwcook> I'm having trouble reasoning about the correct composition order for some monad transformers. I use Proxy from pipes for streaming from IO and want every element from that stream to possibly affect a global state. Should my computation look like Proxy … … … … (StateT World IO) …?
16:23:38 <quchen> dwcook: Proxy is conceptually a transformer that adds awaiting and so on to a monad, so I think that's reasonable.
16:24:05 <erlangkb> newbie question: to_json row = let [_,control,_,_,_player1,player2] = row control
16:24:08 <quchen> What would other options be? StateT (Proxy IO)?
16:24:24 <erlangkb> (sorry for interrupting)
16:25:22 <kazagistar> quchen: even though I have used them quite a bit I think something about the monad transformer intuition when you said that
16:26:14 <erlangkb> rephrasing: can I match on "control" and return control? or am I going about this the wrong way? http://pastebin.com/ZjHdu0vv
16:26:18 <dwcook> quchen, yeah, I can't figure out whether that makes more or less sense.
16:27:14 <quchen> dwcook: Maybe they're commutative even. But if you think about how you would do it without StateT, namely by manually passing the state around, that would be like using Proxy (StateT IO), no?
16:27:59 <quchen> erlangkb: When you add an "in" then your code should be valid.
16:28:54 <erlangkb> quchen: thanks
16:29:36 <quchen> erlangkb: It's pretty fragile though. What if your "row" parameter only has two entries?
16:32:11 <erlangkb> quchen: then I get "bad match" (or somesuch) and it blows up which is fine for my immediate needs (just playing with haskell to do some data manipulation) on clean data
16:32:54 <parc> is there something clever i have to do to export an infix type synonym from a module, or is it impossible?
16:33:19 <erlangkb> quchen: I may try to_json [_,control,_,_,_player1,player2] row =
16:33:41 <erlangkb> quchen... and then add other situations
16:33:45 <dwcook> parc, operators must be surrounded in parens on explicit import. e.g., import Foo ((+++))
16:34:14 <dwcook> parc, er, or export for that matter
16:34:25 <dwcook> module Foo ((+++)) where …
16:35:06 <parc> dwcook: yeah, i tried that, but it doesn't seem to be working for type synonyms
16:35:11 <dwcook> parc, show what you tried.
16:35:55 <parc> dwcook: module NewPrelude.TypeSynonyms ((^)) where { type a ^ b = b -> a }
16:36:05 <parc> dwcook: with {-# LANGUAGE TypeOperators #-}
16:36:31 <dwcook> Hmm, I seem to recall, though I'm not sure I remember correctly, there being a type keyword you can use to make explicit that you want to export the type with that name
16:36:49 <dwcook> In fact it is probably mentioned in the GHC docs on TypeOperators
16:37:39 <dwcook> parc, http://www.haskell.org/ghc/docs/latest/html/users_guide/data-type-extensions.html#type-operators
16:38:19 <parc> dwcook: ah, excellent, thanks
16:39:10 <dwcook> I think you actually were successfully exporting (^), by the way, but it was the value
16:39:25 * hackagebot haskell-docs 4.2.1 - A program to find and display the docs and type of a name  http://hackage.haskell.org/package/haskell-docs-4.2.1 (ChrisDone)
16:41:02 <chrisdone> ^ that version now supports this http://lpaste.net/813623198506549248
16:41:36 <parc> dwcook: yeah, i kind of thought maybe if i exported the value it would also export the synonym with it
16:43:51 <rhg> warning
16:43:51 <rhg>  you may be  watched
16:43:51 <rhg> do usa&israel use the internet(facebook,youtube,twitter, chat rooms ..ect)to spy??
16:43:51 <rhg> do usa&israel use the internet 2 collect informations,,can we call that spying??
16:43:51 <rhg> do they record&analyse everything we do on the internet,,can they harm you using these informations??
16:53:16 <ACSpike[laptop]> (probably using the wrong words) are type class methods namesspaced? i.e. do type class methods have to be named uniquely between two different type classes?
16:53:48 <Zekka> ACSpike[laptop]: They follow the same namespacing rules as other functions
16:54:16 <ACSpike[laptop]> Zekka: bummer… I don’t know those rules yet. :-)
16:54:19 <Zekka> so if you import two modules providing identically-named typeclass methods, you'll need to qualify them to prevent ambiguity
16:54:22 <Zekka> ACSpike[laptop]: They're pretty simple
16:54:34 <Zekka> everything defined on the top level is in module scope
16:54:59 <Zekka> if you import that module then its names are accessible without qualification (without Name.[x] syntax)
16:55:00 <kazagistar> ACSpike[laptop]: every function must have a unique principal type (without shady extentions), but you can use "import qualified Data.Map as DM" to make things easier
16:55:13 <Zekka> however, to prevent ambiguity you can qualified-import names
16:55:27 <Zekka> All top-level names defined within the same module should be unique
16:55:28 <ACSpike[laptop]> Zekka: ok, I think I’m following.
16:55:41 <Zekka> A qualified import looks like what kazagistar suggested
16:55:48 <Zekka> You're also allowed to import only specific names
16:56:00 <Zekka> "import Data.Map (assocs)" for instance
16:56:18 <Zekka> Or importing all names except specific names which conflict
16:56:27 <Zekka> i.e. "import Data.Map hiding (assocs)"
16:56:37 <ACSpike[laptop]> ah, excellent
16:56:43 <Zekka> Does that help?
16:56:43 <ACSpike[laptop]> I remember that now
16:56:49 <ACSpike[laptop]> very much!
16:56:59 <kazagistar> ACSpike[laptop]: the reason is that if two typeclasses have the same function, and a datatype implements both, which implementation to select is ambiguous
16:57:31 <ACSpike[laptop]> I’m taking a look at haskell again after a few years away. I’ve tried to learn it a few times and never mastered it. But I learn new bits on each attempt and it is always enjoyable.
16:58:03 <ACSpike[laptop]> kazagistar: right, thanks!
16:58:19 <simcity2000> are there any particularly interesting use cases for Haskell in production?
16:58:43 <systemfault> Anything… it’s a general purpose language..
16:58:46 <nisstyre> simcity2000: writing code really fast and being sure it "works"
16:58:51 <Zekka> simcity2000: There's cloud-haskell, which is an OTP-style Haskell message-passing library
16:58:51 <simcity2000> it's probably a loaded question, but hey
16:59:01 <simcity2000> Zekka: interesting!
16:59:01 <Zekka> I guess to clarify I'm assuming you don't mean "what's Haskell good for?"
16:59:08 <Zekka> because I use it for all kinds of gneral purpose programming
16:59:18 <simcity2000> right, I'm not talking like the usual "but what is it *for*" stuff
16:59:24 <nisstyre> simcity2000: I wrote a web api scraper that pushed crap to facebook through their api (used xml or something I forget)
16:59:25 <Zekka> I figured you meant "what are people doing with Haskell that's unusually cool"
16:59:27 <nisstyre> simcity2000: that was for a job
16:59:31 <nisstyre> er
16:59:35 <nisstyre> s/wordpress/facebook/
16:59:38 <kazagistar> how about "what does it excell at in practice"?
16:59:40 <nisstyre> lol
16:59:51 <nisstyre> s/facebook/wordpress/
16:59:51 <simcity2000> kazagistar: that's good too
17:00:13 <kini> I'm looking at the cabal "detailed-1.0" testing framework and I'm wondering
17:00:31 <kini> isn't there any way for my testing module to learn from cabal where its built executable is, where a good ghc to call is, etc.?
17:00:33 <simcity2000> for context, I use Go a lot (personally and professionally) for having a language that's good at handling concurrent tasks that scale well to many CPUs
17:00:47 <simcity2000> and for ease of inter-process, inter-machine communication
17:00:53 <nisstyre> simcity2000: you should detangle concurrency from parallelism
17:01:17 <Zekka> Marlow wrote a pretty neat book on concurrency/parallelism in Haskell if that's the sort of thing you'd be interested in
17:01:17 <nisstyre> simcity2000: Go does concurrency fairly well, but it's not better at parallelism
17:01:24 <Zekka> ditto on what Nisstyre said
17:01:47 <nisstyre> (fyi that's what Rob Pike thinks too)
17:01:52 <nisstyre> I'm not bashing Go
17:01:58 <simcity2000> nisstyre: that's actually a gripe I have with Go itself--but in general it's good at making writing concurrent things easily
17:02:08 <gaze__> Hey! What's the advantage of representing my AST as an f-algebra instead of a straight recursive ADT?
17:02:14 <nisstyre> simcity2000: it wasn't designed to be especially good at parallelism though
17:02:22 <gaze__> it seems like folks are into f-algebras these days
17:02:46 <gaze__> at the end of the fpcomplete tutorial there's a note that an f-algebra representation is more efficient somehow?
17:02:49 <simcity2000> for Haskell though, I guess I'm looking for a bit of inspiration on the kinds of things it does well, or that people are doing well with it
17:03:18 <simcity2000> cloud-haskell is pretty nifty
17:03:29 <dwcook> Where can I find (a -> b) -> Either a c -> Either b c?
17:03:30 <Zekka> A lot of the things I think haskell does well have more to do with internal/usability features than specific applications
17:03:32 <nisstyre> gaze__: idk, but I thought about using zippers for ASTs because then you could "mutate" the AST, instead of generating an entirely new one
17:03:39 <dwcook> Should I just write it myself?
17:03:40 <Zekka> dwcook: Bifunctors?
17:03:45 <Zekka> That'd be my guess
17:04:05 <dwcook> Zekka, looks right, thanks.
17:04:13 <Zekka> http://hackage.haskell.org/package/bifunctors-3.2.0.1/docs/Data-Bifunctor.html <- bifunctor first seems to have the sig you want
17:04:15 <simcity2000> Zekka: that's fair
17:04:32 <Zekka> By that I mean it's hard for me to say "Haskell's really great for eb apps!"
17:04:39 <Zekka> or "Haskell's really great for parallel processing!"
17:04:48 <Zekka> because the reasons it's good for those things don't involve being engineered around those things
17:05:17 <Zekka> It's really engineered more about making things that are ordinarily adhoc language features into things that can be directly manipulated by the language
17:05:22 <nisstyre> Zekka: actually parallelism has had special attention
17:05:24 <Zekka> If I had to pick a mission statement that would probably be it
17:05:35 <simcity2000> interesting...
17:05:38 <Zekka> nisstyre: Really? I thought Marlow said it was kind of an afterthought because it was easy to implement without killing speed
17:05:38 <nisstyre> Zekka: they completely rewrote parts of GHC to make it more efficient for parallelism years ago
17:05:49 <nisstyre> Zekka: oh, well maybe you're right
17:05:51 <Zekka> Screw me then, I must be mistaken
17:05:57 <nisstyre> but I thought he rewrote large parts of Haskell for that purpose
17:05:58 <kini> to make GHC itself more efficient, or to make it generate more efficient code?
17:06:01 <nisstyre> er, GHC, not Haskell
17:06:08 <kini> I would suspect the former
17:06:08 <nisstyre> my mind is elsewhere
17:06:26 <Zekka> It has more to do with GHC than Haskell but it wouldn't surprise me if this is an area where they brought in some pragmatism in revising the language
17:06:30 <kini> parallelizing an existing very linear-based algorithm is going to be hard in any language
17:06:32 <nisstyre> kini: can't remember where I read it, it might have been in one of many reddit or facebook comments
17:06:47 <gaze__> ekmett: in ermine where should I look for the sort of... bare AST? is there such a thing? What Exp a might be in bound/examples/Simple.hs
17:07:18 <Zekka> Even if it has a little more to do with GHC than Haskell I doubt they'd make revisions to Haskell that would break GHC's parallelism support without a really good reason
17:07:28 <quchen> nisstyre: I think there was some post about how hard it was to parallelize GHC itself, and that required some rewriting to make up for previous hacks.
17:07:44 <nisstyre> quchen: yeah that's what I was thinking of
17:07:51 <quchen> The story went like "parallelizing GHC would have been trivial, if we hadn't done this bad thing in the past"
17:07:59 <kini> yeah apparently the GHC codebase itself is full of hacks for speed
17:08:09 <kini> (or so I've heard :) )
17:08:13 <nisstyre> quchen: so not really about writing parallel Haskell programs right? (other than the garbage collection maybe?)
17:08:30 <Zekka> I hear GHC's overall kind of hacky, yeah
17:08:44 <quchen> nisstyre: That story was just about GHC itself, I don't know any other ones
17:08:45 <nisstyre> I've glanced at a few of the C headers and stuff
17:08:50 <nisstyre> not much beyond that
17:09:30 <systemfault> Hmm, ghc is not self-hosted?
17:09:35 <kini> it is
17:09:40 <Zekka> I think there's C code in GHC but it's mostly Haskell
17:09:48 <kini> the C code is for the runtime where it actually connects to the OS
17:09:52 <Zekka> The Haskell runtime library is in C, right?
17:09:54 <systemfault> Ahh ok :)
17:09:55 <Zekka> Yeah, that's what I thought
17:10:12 <geekosaur> parts of the runtime are in C; for example, it's kinda difficult to write a garbage collector in the language that needs said garbage collector
17:10:30 <nisstyre> Zekka: well what I saw were the prototypes for thunk stuff
17:10:57 <systemfault> What about that C— stuff, is it real?
17:11:18 <Zekka> What C- stuff? Offhand I don't know what you're referring to.
17:11:21 <quchen> C-- is an intermediate language used in the compilation process, not something parts of GHC are implemented in, I think.
17:11:38 <systemfault> Ah ok
17:12:29 <kini> is it even used when the llvm backend is turned on?
17:12:43 <systemfault> It’s just a flashback I had from something I read a few years back… Thought it was some intermediate format From haskell to C— to asm
17:13:17 <nisstyre> Zekka: for example https://ghc.haskell.org/trac/ghc/wiki/Commentary/Rts/Storage/HeapObjects
17:13:28 <nisstyre> https://ghc.haskell.org/trac/ghc/browser/includes/rts/storage/Closures.h
17:13:52 <nisstyre> lots of other headers to look at in /rts
17:14:16 <BeardedCoder> Anyone got a good example of exception handling in Conduit? Specifically handling an exception in a Conduit. I've been trying to use catchC, but it does not behave as expected.
17:14:37 <quchen> This is a very nice article about GHC's design: http://www.aosabook.org/en/ghc.html
17:15:21 <nisstyre> quchen: tbh, if you know a bit about functional compiler design, and can read C headers, then just poking around in /rts seems like it'd be fun
17:16:43 <quchen> systemfault: Haskell is converted to Core ("minimal haskell"), which is converted to STG ("how to run a lazy functional language"), which is converted to C-- ("something close to what computers run"), and that can be used to produce C, ASM, LLVM.
17:17:08 <systemfault> Ahh ok
17:17:32 <kini> aha, so C-- still comes into play when using the llvm backend eh
17:18:15 <quchen> The article I linked above has a nice diagram about this.
17:19:15 <nexx> there is a transformation from C-- to C?
17:19:29 <Zekka> This isn't a bad read at all, especially because I was considering implementing a small functional language with some similarities to Haskell
17:19:32 <quchen> GHC can compile to C, yes.
17:19:49 <nexx> I mean, I thought C-- is a subset of C
17:19:50 <kazagistar> "Type checking: 24,097" I guess thats what all the extensions did
17:20:12 <quchen> kazagistar: Typechecking is pretty complicated in GHC, because it's done quite early
17:20:22 <quchen> Before desugaring, in particular
17:21:25 <systemfault> Could Haskell in theory be as fast as C? (With idiomatic Haskell, not the C-like Haskell crap you see on the language shootout)
17:21:26 <kazagistar> quchen: what are the benefits of that? does it help error checking or something?
17:21:57 <quchen> kazagistar: Much nicer error messages is the reason I've heard. There may be others.
17:22:13 <quchen> From a purely theoretical point of view you'd like to typecheck Core because that's much simpler ;-)
17:22:58 <quchen> systemfault: There are plenty of examples (and blog posts etc) about achieving C-like performance with reasonably idiomatic Haskell.
17:23:09 <kazagistar> systemfault: when you start talking about idioms, you definitions become fuzzy
17:23:27 <quchen> Achieving the speed of hand-optimized C is pretty hard though.
17:23:59 <quchen> Getting close is often a matter of adding a few "!" to your code and using unboxed instead of boxed Vectors. ;-)
17:24:22 <kazagistar> especially if you force C to be used like "idomatic C", which might not actually be optimal in a lot of cases either
17:24:24 <systemfault> Cool :) “Close to C” performance is really interesting
17:24:53 <systemfault> It’s even crazy when you think how high-level haskell is
17:25:10 <quchen> Being high level allows the compiler to know much more about the code though
17:25:37 <kazagistar> or, as importantly, to know less about the code when you dont want it it
17:25:40 <quchen> Consider list fusion, that's a very hard problem in other languages because of aliasing effects etc
17:36:14 <gamegoblin> Mmmm just made an attoparsec parser that parses and evaluates lisp style arithmetic (+ 1 2 (- 3 4)) etc. It’s only 2% slower than my hand rolled C parser and evaluator. Damn.
17:36:59 <nisstyre> gamegoblin: I bet you could make the C one faster
17:37:25 <nisstyre> did you split things up into a reader (lexer) and parser?
17:37:32 <gamegoblin> No
17:38:17 <nisstyre> hmm, well if you were implementing a real lisp you'd do that
17:38:28 <nisstyre> but yeah attoparsec is fast
17:38:34 <gamegoblin> That sort of performance is pretty in line which what bos found when he released attoparsec 3: http://www.serpentine.com/blog/2014/05/31/attoparsec/
17:38:38 <nisstyre> I think it just got some improvements too
17:38:55 <nisstyre> yeah I saw him post about it on facebook
17:40:06 <kazagistar> isn't parsing something as simple as lisp generally IO bound?
17:40:31 <gamegoblin> kazagistar: I don’t think so, since Parsec is about 6x slower than my C and attoparsec code
17:41:06 <nisstyre> kazagistar: do you include macro expansion in that?
17:41:35 <[swift]> just parsing most reasonable languages, in my experience, should indeed be IO bound, if the implementation is efficient
17:41:46 <kazagistar> nisstyre: I wasn't, since that seems more like running then parsing, but I guess in lisp those are interwoven
17:41:52 <[swift]> but usually you build an AST and manipulate various data structures and that can slow things down significantly
17:42:04 <l0cust> Hey, could someone please look at my package before I push it to hackage? https://github.com/pharpend/eros
17:42:15 <l0cust> I ran `cabal check', nothing came up
17:43:25 <kazagistar> something that has a fairly short lexing lookahead and LL(1) or close grammar with a fairly simple type system just does not have all that much work to do
17:43:27 <heatsink> l0cust: Do you know about major-minor-bugfix version numbering?
17:43:33 <l0cust> heatsink: yes
17:43:40 <kazagistar> then again, few real languages satisfy that
17:43:43 <heatsink> Starting with version 0.0.0.0 is odd
17:43:49 <l0cust> heatsink: I don't like starting at 0.1.0.0, it seems inconsistent
17:44:02 <l0cust> heatsink: 0.0.0.0 makes more sense
17:44:12 <[swift]> kazagistar: even LR(1) can be parsed very efficiently. it's really the semantic actions that slow you down
17:44:26 <l0cust> heatsink: 1.1.1.1 makes more sense than 0.1.0.0
17:44:57 <kazagistar> [swift]: but the semantic actions shouldn't mean the difference between attoparsec and parsec, for example
17:45:52 <[swift]> kazagistar: i'm talking about efficient implementations
17:46:04 <heatsink> The two trailing zeros don't help, I would use 0.1.  But you can look at other hackage packages to see what conventions are in use.
17:46:15 <[swift]> (not trying to judge; i haven't used parsec *or* attoparsec much)
17:46:42 <heatsink> Also, it's good to constrain the package build-depends to at least a major version number
17:46:48 <heatsink> I think hackage warns you if you don't do that
17:47:08 <heatsink> It reduces the chance of breakage when one of the other packges gets updated
17:47:23 <heatsink> Your package apparently depends on itself
17:47:31 <l0cust> heatsink: the test suite does
17:47:35 <heatsink> Oh, right
17:47:36 <l0cust> heatsink: the package itself does not
17:50:37 <heatsink> l0cust: I think that auto-generated modules also have to be listed in the cabal file.  I do that in my packages.
17:51:26 <kini> lol, files in the Happy codebase still refer to gofer
17:51:27 <l0cust> heatsink: thank you
17:51:43 <kini> "To run the program, call this in gofer, or use some code to print it."
17:52:04 <heatsink> I didn't notice any other issues.
17:52:52 <l0cust> heatsink: How do I make sure the documentation is also uploaded
17:53:02 <l0cust> heatsink: I see some packages with documentation only for certain versions
17:57:18 <heatsink> l0cust: You can't.  That is a planned feature.
17:57:28 <l0cust> okay
17:57:36 <heatsink> l0cust: If the documentation doesn't show up, it is because hackage couldn't build it
17:57:53 <heatsink> You can see the build log at package/Eros/reports/1/log
17:58:03 <heatsink> after you upload it and wait for the builder to run
17:58:58 <l0cust> ah
17:59:12 <bergmark> i think you can upload documentation separately somehow
17:59:32 * hackagebot eros 0.0.0.0 - A text censorship library.  http://hackage.haskell.org/package/eros-0.0.0.0 (pharpend)
17:59:34 * hackagebot hOpenPGP 1.3 - native Haskell implementation of OpenPGP (RFC4880)  http://hackage.haskell.org/package/hOpenPGP-1.3 (ClintAdams)
18:00:18 <gamegoblin> How can I convert a word8 into an Int?
18:00:19 <l0cust> well there it is
18:01:01 <gamegoblin> like with char I can use `ord`
18:01:09 <gamegoblin> Is there anything simlar for word8?
18:01:24 <Lutin`> gamegoblin: You can just use toInteger
18:01:24 <heatsink> fromEnum
18:01:31 <gamegoblin> Oh ok excellent
18:01:35 <Lutin`> Oh to an int
18:01:35 <enthropy> fromIntegral
18:01:52 <Lutin`> Yeah what heatsink said
18:02:06 <l0cust> heatsink: well, there's no report
18:02:13 <l0cust> heatsink: so it must still be attempting to build it
18:02:17 <kazagistar> to figure out how to convert in general, look in the typeclasses
18:02:31 <l0cust> heatsink: I ran 'cabal haddock', and it generated just fine
18:02:33 <heatsink> Documentation isn't built immediately, l0cust.  It's built in batches a few tiems a day.
18:02:39 <l0cust> ah
18:02:56 <enthropy> hackage-1 did that
18:03:44 <heatsink> The curent hackage is different?
18:04:58 <kazagistar> what is the motivation of people to sign the various programming "manifestos"?
18:05:44 <heatsink> What are these manifestos?
18:06:15 <systemfault> What manifesto?
18:06:18 <ij> Sign — what does that mean?
18:07:06 <gamegoblin> GOD just fixed the most annoying compile error. Was using - and should have been using `subtract`.
18:08:04 <kazagistar> like the Reactive Manifesto, it has a "sign" button at the bottom
18:08:17 <systemfault> lol
18:08:36 <systemfault> That’s BS.
18:09:11 <kazagistar> I mean, of course its BS, but I still wanna understand what motivates that kind of crazy
18:09:36 <kazagistar> or the agile manifesto or whatever
18:09:39 <systemfault> I did sign one “manifesto” in my life though… One I actually believe in
18:10:57 <kazagistar> what was the intended purpose of that action?
18:10:58 <ij> Go on, tell us.
18:11:54 <ij> The agile manifesto was printed and put on a wall in my last workplace. And we were incouraged to go to conferences over agile.
18:11:58 <systemfault> Ah… The Software Craftsmanship Manifesto.
18:13:05 <kazagistar> I mean, I get the point of, say, isolating some set of ideals and sharing it
18:14:13 <systemfault> Inventing a manifesto for the latest hype isn’t good imho..
18:14:36 <kazagistar> the signing bit confuses me... I guess it is intended to be like a psychological trick to encourage personal investment and ego attachment
18:15:00 <systemfault> I guess.. I didn’t get a medal in return :/
18:16:41 <kazagistar> like "I hereby decree that my ego has a personal stake in this", which kinda shuts down debate and critical reasoning and stuff... well, I guess I answered my own question :P
18:20:47 <benzrf> those scoundrels!
18:23:00 <kazagistar> I should make an ego-free programming manifesto, and make the "sign" button tell you you're doing it wrong :P
18:23:15 <MP2E> hahaha
18:23:39 <benzrf> kazagistar: do it
18:24:37 <AshyIsMe> haha i'd sign that
18:25:53 <kazagistar> maybe like "Sorry, but even these ideas are not perfect nor absolute, but if you think they are good, discuss them with your friends [links to social media]"
18:27:46 <kazagistar> I am looking at the 10 commandments of egoless programming now, and a lot of them seem pretty unrelated
18:29:45 <Lutin`> ij: Yeah that's where my current workplace is at
18:33:04 <Zekka> Does anybody have a good explanation of the monadstate fundep on hand?
18:33:29 <Zekka> just a quick summary of "this is what happens when you don't have that, and try to use multiple monadstate instances" would work
18:34:06 <eyebloom> Is there a way to define a newtype Scalar t = Scalar {unScalar::t} deriving (Show, Num, Ord, Eq) if I know that type t has instances for (Show, Num, Ord, Eq) or can derive them?
18:35:15 <eyebloom> I’m using t to prevent myself from mixing spaces essentially.
18:35:24 <pavonia> I think these constraints are added deriving new instances
18:35:40 <pavonia> +when
18:37:10 <kazagistar> @let newtype Test a = Test a deriving (Show)
18:37:11 <eyebloom> I see
18:37:13 <lambdabot>  Defined.
18:37:18 <pavonia> So the derived instance will be something like "instance Show t => Show (Scalar t) where ..."
18:37:19 <kazagistar> @undefine
18:37:19 <lambdabot> Undefined.
18:37:27 <kazagistar> @let newtype Test a = Test a deriving (Num)
18:37:28 <lambdabot>  .L.hs:148:25:
18:37:28 <lambdabot>      Can't make a derived instance of ‘Num (Test a)’:
18:37:28 <lambdabot>        ‘Num’ is not a derivable class
18:37:28 <lambdabot>        Try GeneralizedNewtypeDeriving for GHC's newtype-deriving extension
18:37:28 <lambdabot>      In the newtype declaration for ‘Test’
18:37:31 <kazagistar> right
18:37:34 <rwbarton> for Num you need generalized newtype deriving
18:37:37 <kazagistar> thats what I though
18:37:41 <kazagistar> *thought
18:37:46 <AshyIsMe> so im having a bit of a brain fail
18:37:50 <kazagistar> the error even tells you the extension you need
18:38:17 <AshyIsMe> i have a Maybe Text and i want to run a command if it's a Just t but do nothing if it's a Nothing
18:38:39 <eyebloom> pavonia rwbarton: Thanks I’ll see if I can make that work.
18:38:44 <AshyIsMe> how do i go about that?
18:39:01 <AshyIsMe> (or what can i read about to fix my thinking if this is non-haskell style?)
18:39:46 <AshyIsMe> the command i want to run is a redis set call
18:40:15 <Cale> AshyIsMe: You could use a case expression, like  case myMaybeText of Nothing -> return (); Just x -> theCommand x
18:40:43 <Cale> AshyIsMe: Obviously it's possible to abstract over that sort of pattern a bit.
18:42:35 <Cale> (but often I find that leaving it as a case is clear enough)
18:43:28 <AshyIsMe> cool
18:44:09 <AshyIsMe> so i guess my problem is hedis specific, return () doesnt match the return type of the other case
18:44:30 <Cale> Oh, well, yes, you'll need to produce something of the same type in each branch
18:51:57 <sshine> I wonder if Haskell performs well compared with Erlang when doing WebSockets and so-called "long polling". does anyone here know some benchmarks?
18:54:41 <kazagistar> AshyIsMe: if you want to think about it in a really haskell/math/abstract way, there is a simple and standard way of getting "stuff" out of a disjunction (A or B)...
18:55:41 <kazagistar> AshyIsMe: given (A or B), and a (A -> C) and a (B -> C), I can give you a C
18:57:37 <benzrf> ooh, CHC
18:57:42 <AshyIsMe> kazagistar: in this case the constructor for C is not exported by the module
18:58:03 <kazagistar> so, you have an A or B in the form of (Just X | Nothing), and you have an X -> Action Y, so you need the last part, which looks like () -> Action Y
18:58:27 <l0cust> How is it that the Java IRC channel is less active than the Haskell IRC channel?
18:59:06 <AshyIsMe> i ended up doing:   case myKey of Just t -> set myKey "blah"  Nothing -> ping
18:59:14 <Iceland_jack> l0cust: Because they have jobs </snark> :)
18:59:23 <AshyIsMe> ping being a redis command that just pings the server but returns the same type
18:59:23 <kazagistar> AshyIsMe: is there no way to obtain a noop C at all?
18:59:31 <l0cust> Iceland_jack: haha
18:59:36 * hackagebot MusicBrainz 0.2.1 - interface to MusicBrainz XML2 web service  http://hackage.haskell.org/package/MusicBrainz-0.2.1 (ClintAdams)
18:59:38 <AshyIsMe> kazagistar: i dont think so
18:59:55 <kazagistar> AshyIsMe: so redis is not an applicative/monad? it has no return?
19:00:03 <l0cust> @grab Iceland_jack
19:00:03 <lambdabot> Unknown command, try @list
19:00:05 <l0cust> dammit
19:00:07 <l0cust> that's #archlinux
19:01:07 <AshyIsMe> kazagistar: im not sure: https://hackage.haskell.org/package/hedis-0.6.5/docs/Database-Redis.html#g:8
19:01:55 <kazagistar> AshyIsMe: the fact that they use do notation means they must be a monad, however, you mentioned that return () was the wrong type... that can be fixed too
19:02:40 <AshyIsMe> it's within a multiExec that i'm trying to do this
19:03:00 <AshyIsMe> https://hackage.haskell.org/package/hedis-0.6.5/docs/Database-Redis.html#g:19
19:03:22 <l0cust> Well, I might as well ask here
19:03:38 <l0cust> How do I go about porting (or binding) my Haskell library to something like Java or Scala?
19:04:29 <kazagistar> AshyIsMe: so your "C" looks like (Redis (TxResult a))? or like (Queued a)?
19:04:36 <l0cust> I eventually want to use it in an Android app
19:04:36 * hackagebot hspec-webdriver 0.2.3 - Write end2end web application tests using webdriver and hspec  http://hackage.haskell.org/package/hspec-webdriver-0.2.3 (JohnLenz)
19:05:02 <AshyIsMe> RedisTx (Queued Status)
19:05:16 <kazagistar> and you dont have a constructor for Status?
19:05:27 <MP2E> l0cust : Android doesn't require porting your app to another language, thankfully, but it will still take some work
19:05:32 <AshyIsMe> yeah i have Status constructors
19:05:34 <AshyIsMe> but not Queued
19:05:47 <MP2E> l0cust: make an Android GHC cross compiler, then use the foreign-jni library to bind with a Java frontend
19:06:04 <MP2E> The java will handle the UI elements, touch screen, and basically anything from the OS and forward it all to the Haskell core
19:06:12 <kazagistar> AshyIsMe: sure you do, queued is a monad, so you have "return :: Status -> Queued Status
19:06:13 <l0cust> MP2E: "make an Android GHC cross compiler" sounds complicated
19:06:22 <MP2E> l0cust: I have a working one for GHC 7.8 as we speak ;)
19:06:25 <MP2E> it's not all that bad
19:06:37 <MP2E> https://github.com/neurocyte/ghc-android
19:06:51 <AshyIsMe> https://github.com/informatikr/hedis/blob/master/src/Database/Redis/Types.hs#L38
19:06:57 <AshyIsMe> that's Status definition
19:07:00 <MP2E> Note that this repo hasn't been updated since november, so there's 2 changes
19:07:21 <MP2E> 1 do not apply unix-imports.patch
19:07:29 <MP2E> 2. I have another patch, let me go grab it
19:07:45 <MP2E> but yeah other than that I just follow the build script as my template to build GHC myself and it worked without a hitch
19:07:55 <MP2E> haven't tried the build script, it's probably broken
19:08:02 <kazagistar> AshyIsMe: here is the question... we are constructing an action that either does something, or does nothing. What do you want to get out of it?
19:08:07 <AshyIsMe> kazagistar: so i should be able to do:  Nothing -> return Ok ?
19:08:49 <l0cust> MP2E: I'll bookmark it, I won't need it for a while
19:08:55 <AshyIsMe> i guess i want the status of if the something succeeded otherwise if nothing happened assume success
19:10:21 <gaze__> anyone familiar with bound?
19:10:43 <kazagistar> AshyIsMe: alternatively you can use "traverse :: (Traversable t, Applicative f) => (a -> f b) -> t a -> f (t b)" from Data.Traversable
19:12:02 <kazagistar> AshyIsMe: which would result in a "Queued Maybe Status"
19:12:06 <kazagistar> er
19:12:17 <kazagistar> "Queued (Maybe Status)"
19:14:07 <dwcook> How can I learn the type of a local binding?
19:14:35 <dwcook> (Other than working it out in my head.)
19:15:11 <levi> ghc-mod can tell you
19:15:46 <AshyIsMe> kazagistar: ok cheers, i'll look into that
19:15:52 <kazagistar> AshyIsMe: specialized fully in your case it is something like "traverse :: (Text -> Queued Status) -> Maybe Status -> Queued (Maybe Status)" and does what you would expect, returns Just Status if there was text, or Nothing if there was none
19:16:20 <levi> Or you can annotate it with a bogus type and the compiler will tell you what it thinks it is.
19:17:20 <dwcook> levi, that second one sounds easier actually, thanks. :)
19:17:22 <levi> With ghc 7.8, you could use Typed Holes.
19:17:48 <dwcook> Well, but the value might have a more specific type than is required by its context.
19:17:58 <dwcook> I suppose I could use asTypeOf
19:18:45 <benzrf> i once typed holes
19:19:53 <enthropy> the type of a binding might not be that interesting
19:19:59 <enthropy> unless you have -XMonoLocalBinds
19:20:17 <dwcook> I get the feeling I might be going about reasoning about this program the wrong way anyway
19:25:16 <pavonia> :t let x = y Nothing where y = (head . fromJust) `asTypeOf` ?y in x
19:25:17 <lambdabot> (?y::Maybe [c] -> c) => c
19:28:50 <AshyIsMe> kazagistar: cheers, traverse is a lot nicer than the case statement
19:29:49 <kazagistar> AshyIsMe: yeah, even though it does not have much to do with the whole shpiel about disjunction types :P
19:33:27 <kazagistar> AshyIsMe: instead of the case statement, you could have used "maybe :: b -> (a -> b) -> Maybe a -> b", which has the same shape I talked about
19:35:00 <kazagistar> ie, { maybe (Just OK) command mytext }
19:35:08 <kazagistar> (er
19:35:21 <kazagistar>  { maybe (return OK) command mytext }
19:40:56 <Clint> ivanm: is there a quick replacement function for fgl 5.4's graphviz?
19:44:47 <hunt> anyone have any cool project ideas?
19:45:03 <hunt> i kind of wanted to implement vim but writing a text editor from scratch is kind of a pain
19:45:22 <hunt> im not really interested in having to deal with displaying text either
19:45:37 <AshyIsMe> plus Yi exists too
19:45:41 <hunt> yea exactly
19:46:03 <hunt> so like a command line tool would be ideal
19:46:11 <dfeuer> hunt, and writing vim is a *huge* project. If you wanted to implement a text editor it would make sense to start with a simpler one.
19:46:17 <hunt> im starting to get rusty from disuse of my haskell skillz
19:46:40 <hunt> dfeuer: well i would build it around my own plan for extensibility, so i wouldnt make it my goal to support all the modes, just to have a system that could
19:46:42 <dfeuer> hunt, how about reimplementing ed?  http://en.wikipedia.org/wiki/Ed_%28text_editor%29
19:47:06 <heatsink> hunt, you could implement a programmable typesetting system
19:47:23 <kazagistar> yeah, thats a smaller project then vim >_>
19:47:25 <hunt> heatsink: typesetting ie fonts?
19:47:30 <dfeuer> Hahahahaha.
19:47:40 <heatsink> Internet explorer fonts?
19:48:06 <hunt> heatsink: all fonts
19:48:19 <hunt> i actually have no idea what were talking about
19:48:35 <dfeuer> hunt, I think heatsink is joking. Donald Knuth started writing TeX to be able to typeset TAoCP. It turned into a multi-year project (and one of the most succesful software packages ever created).
19:48:45 <heatsink> Yes
19:48:47 <dfeuer> *successful
19:48:48 <kazagistar> typesetting is an area where I am very very glad to just use existing implementations and not touch it too much
19:49:39 <dfeuer> Of course, you *could* write a relatively simple one, like troff...
19:49:56 <kazagistar> building a new latex would be cool, but I know I am utterly unqualified
19:49:57 <hunt> oh wow TeX -> Latex
19:50:00 <hunt> i didnt even realize
19:50:02 <hunt> thats awesome
19:50:28 <hunt> although that doesnt sound too thrilling
19:50:35 <kazagistar> hunt: he was basically saying "build latex, but try to make it nicer" :P
19:51:04 <hunt> that sounds maybe too fimiliar, causae it seems like most of the work there is in parsing
19:51:05 <dfeuer> People have tried. No one's quite been able to figure out how yet.
19:51:31 <dfeuer> Um ... no. There is a *huge* amount of work that goes way beyond parsing.
19:51:56 <hunt> dfeuer: its l ike developing a programming language, right?
19:51:57 <kazagistar> hunt: parsing is super easy relative to the rest of it
19:52:22 <Lutin`> I think developing a programming language would be easier
19:52:23 <kazagistar> which is just like a programming language actually, in that sense
19:52:23 <hunt> my bad
19:52:31 <dfeuer> Well ... sort of?
19:52:44 <hunt> yea i mean i dont really know what goies into remaking latex, i dont really know how it works
19:52:52 <hunt> is it really more complex then developing a programming language?
19:53:01 <hunt> theres not variables or anything is there?
19:53:23 <kazagistar> hunt: it is turing complete
19:53:35 <dfeuer> You want it to be programmable, but there are a lot of things in the nature of constraint solving. You have to figure out exactly where each bit of text and each diagram should appear, which words should be hyphenated and how, and so on.
19:54:09 <kazagistar> to give you an idea about a small slice of the problems in typography: http://en.wikipedia.org/wiki/River_(typography)
19:54:13 <hunt> yea... that sounds like far beyond my reach
19:54:28 <hunt> im really really not interested in dissplaying text
19:54:35 <hunt> especially crazy math text
19:54:46 <kazagistar> I wouldn't say it is inherently beyond my reach, it would just take like a decade and be boring as hell :P
19:55:43 <hunt> kazagistar: yes ok maybe that applies to me too
19:55:59 <hunt> im totally fine with redoing an existing project too for my own amusement
19:56:00 <kazagistar> it applies to enough people that we still have latex
19:56:03 <hunt> if you guys have any good ideas
19:56:19 <hunt> i saw some guiy reimplementing sed on youtube in haskell which was pretty inspiring at first
19:56:29 <kazagistar> compilers are a classic haskelly thing
19:56:42 <hunt> how much do we really need a better latex anyways?
19:57:01 <Lutin`> You could implement your own layout engine
19:57:08 <MP2E> imo I haven't run into issues with latex, but I've only used it for small things like school papers
19:57:15 <Lutin`> That's something I've been meaning to work on
19:57:16 <MP2E> never a book or anythign
19:57:44 <Lutin`> Specifically an implementation of the Cassowary constraint solver in Haskell
19:59:32 <Lutin`> Maybe pick something on this page and implement it in Haskell https://wiki.archlinux.org/index.php/List_of_applications
20:00:18 <kazagistar> hunt: you dont need it if you are the sort of person who is confortable on the unix shell with all its quirks, but latex lacks a bit in the... clean discoverable design department
20:01:37 <hunt> Lutin`: thats actually a good idea. i was kind of offput by the idea of there being a universal list of applications, but i didnt realize that it was just for the package manager :P. ill start browsing
20:01:59 <Lutin`> Oh it's really just a page of common applications people use
20:03:23 <Lutin`> But I figure if it's general enough for us to throw at most questions in #archlinux, it would be general enough to get some ideas of what to do
20:04:35 <hunt> Lutin`: i was actually thinking abuot switching to arch just today. have you tried xmonad?
20:04:44 <MP2E> xmonad is so great
20:04:45 <MP2E> <3
20:05:02 <MP2E> if you're into tiling wms, of course. But those are my favorite too
20:05:04 <hunt> has anyone made any really absurd configs with it?
20:05:09 <Lutin`> I'm on i3 right now
20:05:18 <hunt> MP2E: i definitely want to try a tiling wms
20:05:46 <Lutin`> Was on xmonad, but I didn't have the time to implement a tree layout like i3
20:05:51 <Lutin`> So I just switched to i3 lol
20:05:55 <kazagistar> my favorite tiling window manager is the Put Windows Gnome Shell Extention :P
20:05:59 <MP2E> haha
20:06:17 <Lutin`> I've also been looking into bpswm and herbstluft
20:06:20 <MP2E> my favorite tiling wms are : dwm, wmii, i3, xmonad (in no particular order)
20:06:26 <MP2E> ooh I haven't tried those
20:06:39 <Lutin`> bspwm*
20:07:12 <l0cust> م3 مي فسنشل
20:07:16 <l0cust> dammit
20:07:18 <l0cust> i3 is great
20:07:34 <l0cust> Can't say I care for xmonad
20:07:53 <MP2E> xmonad appeals to me I think because I really liked dwm
20:07:55 <Lutin`> Yeah I love Haskell and all, but it's just too much work to get to where I want it
20:07:56 <MP2E> I used it for like 4 years
20:08:06 <MP2E> my dwm became pretty different from upstream :D
20:08:08 <Lutin`> i3 just has sane defaults
20:08:18 <pharaun> examples?
20:08:20 <Lutin`> But it's definitely less configurable
20:08:27 <Lutin`> examples of what
20:08:42 <pharaun> i guess what comes along as sane default may vary, i was just wondering if you had any examples :)
20:08:50 <pharaun> cos to me xmonad seems mostly reasonable i thought
20:08:53 <MP2E> indeed, I found xmonad to be pretty sane
20:08:56 <MP2E> my config is actually fairly stock
20:08:59 <l0cust> i3 is not very configurable
20:09:13 <l0cust> I don't like automatic tilers
20:09:16 <l0cust> like xmonad, awesome
20:09:25 <l0cust> And their configs tend to be much more complicated
20:09:35 <l0cust> I've heard good things about bspwm
20:09:41 <kazagistar> I used awesome for a while, and tried dwm, but it turned out that Gnome 3 does almost exactly what I want with my desktop with like 3 min of configuring...
20:09:49 <hunt> l0cust: what makes a tiler automatic?
20:09:56 <l0cust> I don't really have time to fuck around with window managers
20:10:02 <Lutin`> ^
20:10:06 <kazagistar> ^
20:10:08 <l0cust> hunt: you have to define the layout of your windows in a config file
20:10:17 <l0cust> and i3 is good enough for me
20:10:21 <hunt> l0cust: that doesnt sound automatic at all
20:10:31 <pharaun> ^
20:10:36 <l0cust> with i3 or herbstluftwm, you define the layouts as new windows appear
20:10:43 <Lutin`> For me it was just that I could install i3 and start using it immediately without setting up xmobar or a specific xmonad layout
20:10:44 <l0cust> which is called "manual tiling"
20:10:54 <l0cust> what Lutin` said
20:10:59 <l0cust> It works pretty well out of the gate
20:11:07 <pharaun> eh i just set up my config in a github repo
20:11:08 <Lutin`> and I don't need to set up things to make youtube fullscreen actually fullscreen
20:11:10 <l0cust> and it's good enough, unless you have some insane configuration needs
20:11:13 <hunt> is there an example of somebody making xmonad incredible after putting in the work
20:11:29 <pharaun> then clone it to any machine i use and its almost otb
20:11:35 <l0cust> I say this as a militant Arch user
20:11:47 <kazagistar> I guess Put Windows for gnome 3 qualifies as manual tiling then, cause you use the shortcut to put the windows in a corner, good to know :P
20:12:09 <l0cust> pharaun: I do the same
20:12:18 <pharaun> i guess with me i just don't want to have to manage my windows so i find the automated tiling in xmonad is nice
20:12:21 <Lutin`> hunt: It's automatic in that the window positions are defined by a layout
20:12:37 <pharaun> sometime it can be a bit of a pain but i just define 3 layout mainly with fullscreen be reachable via a hotkey
20:12:41 <hae> Lol. Archette would be the prescribed term.
20:12:52 <hae> By analogy to suffragette.
20:12:53 <Lutin`> Archista
20:13:03 <Lutin`> by analogy to pythonista
20:13:22 <hae> That too, but it sounds too much like barista.
20:13:24 <barrucadu> Archer. By analogy to archer :P
20:13:28 <Lutin`> lol
20:13:31 <pharaun> l0cust: i'll admit sometime i've wanted manual tiling in xmonad
20:13:40 <pharaun> but the majority of the time the auto is good enough
20:13:51 <l0cust> pharaun: I'm sure if I spent a weekend configuring xmonad, I would like it
20:13:58 <pharaun> heh
20:14:01 <l0cust> pharaun: it's just that I don't have a spare weekend
20:14:12 <pharaun> i'm used to customizing my workflow so much that it has became a second-nature i guess
20:14:23 <l0cust> pharaun: I used to be the same way
20:14:23 <hae> I tried xmonad, it's not bad. For my everyday purposes, Xfce is good enough though.
20:14:31 <pharaun> and then after the initial curve i never touch it after
20:14:38 <pharaun> (almost)
20:14:39 <Lutin`> l0cust: You can actually save layouts with herbstluft
20:14:52 <l0cust> pharaun: I discovered that I'm a lot more productive if I spend my time working, rather than fucking around with window managers
20:15:04 <pharaun> :)
20:15:05 <l0cust> Lutin`: you can do some i3-msg fu, and do the same with i3
20:15:13 <pharaun> l0cust: this is true of bout everything
20:15:14 <Lutin`> Ah
20:15:19 <hae> Lol i3.
20:15:24 <pharaun> i've configurated my zsh/vim/xmonad/etc
20:15:38 <l0cust> pharaun: death to the vim users!
20:15:43 <Lutin`> herbstluft you just do `herbstclient dump` and save the output somewhere
20:15:43 <pharaun> :)
20:15:44 <hunt> l0cust: yea but fucking around with window managers is kind of what makes computers fun and not just utilities
20:15:46 <hae> My hobby: adding unnecessary suffices to everything.
20:15:55 <pharaun> l0cust: you're one of those dirty emacs users? ;p
20:15:59 <kazagistar> pacman -Syu gnome gnome-extra
20:16:01 <kazagistar> muhahaha
20:16:05 <MP2E> I'm a dirty emacs user 8)
20:16:06 <elvis4526> I have a quick noob question. Why << main = do a <- getArgs; putStr a >> works and << main = putStr getArgs >> doesn't ?
20:16:10 <vlabs> hey all!
20:16:11 <pharaun> MP2E: go shower!
20:16:14 <hunt> vim is love, vim is life
20:16:15 <Lutin`> then you can load it again with `herbstclient load "dumpstring"`
20:16:17 <MP2E> i'm the dirtiest in fact, because I run emacs in vim mode
20:16:20 <MP2E> hahaha
20:16:24 <pharaun> hah
20:16:26 <vlabs> hunt: sublime text is love :P
20:16:27 <pharaun> MP2E: i've considered that yes
20:16:34 <l0cust> elvis4526: putStr =<< getArgs would be fine
20:16:37 <hunt> MP2E: evil mode, right?
20:16:38 <MP2E> I think emacs makes a better vim than vim does
20:16:41 <MP2E> yes indeed
20:16:41 <pharaun> but i've used vim for far too long i don't think i could ever get used to emacs
20:16:46 <l0cust> MP2E: seconded
20:16:49 <Lutin`> MP2E: I was thinking about getting into emacs using evil mode
20:16:52 <hae> elvis4526, monads.
20:16:54 <hunt> True dirt comes from running vim in emacs mode
20:16:54 <barrucadu> elvis4526: Look at the types of getArgs and putStr
20:16:57 <pharaun> i keep on thinking bout emacs + evil mode
20:16:59 <vlabs> MP2E: would you recommend switching to emacs?
20:16:59 <l0cust> :t putStr
20:17:00 <lambdabot> String -> IO ()
20:17:02 <l0cust> :t getArgs
20:17:03 <lambdabot> Not in scope: ‘getArgs’
20:17:04 <pharaun> it would in theory have better syntax i think
20:17:06 <Lutin`> pharaun: Let's do it
20:17:10 <pharaun> than vim (regexes) but yesh
20:17:11 <Lutin`> I'm tired of vimscript
20:17:14 <Lutin`> and vim plugins
20:17:15 <pharaun> haha me too
20:17:16 <elvis4526> well getArgs is IO [String]
20:17:19 <hunt> Lutin`: also vimscript makes no sense
20:17:21 <l0cust> okay
20:17:26 <hae> Emacs doesn't have plugins, it has libraries lol.
20:17:27 <l0cust> :t (>>=)
20:17:27 <pharaun> Lutin`: but i have not heard... much positive thing bout elisp tho
20:17:27 <lambdabot> Monad m => m a -> (a -> m b) -> m b
20:17:29 <Lutin`> I just want emacs with my motions and commands
20:17:29 <kazagistar> elvis4526: do notation is magical sugar around monads, so you have to handle it
20:17:35 <hae> Or packages I guess.
20:17:37 <hunt> Lutin`: i tried for 2 hours today to get some simple stuff working and i had to have a veteran vimmer do it for me
20:17:49 <elvis4526> Okay, but what does the type IO [String] means ?
20:17:52 <elvis4526> It means it's a list of string
20:17:53 <MP2E> vlabs : I would :) I've actually switched between emacs and vim about 3 times and I think i'm here to stay, finally
20:17:56 <elvis4526> but it's not an IO action
20:17:58 <AshyIsMe> hunt: what was the feature?
20:17:59 <l0cust> Emacs - Escape Meta Control Alt Shift
20:18:05 <hunt> Im just afraid that if i switch to emacs ill lose that vim prestige
20:18:05 <l0cust> elvis4526: yes, it is
20:18:12 <pharaun> MP2E: what made you finally stick?
20:18:13 <MP2E> evil provides all of the lightweight awesome keybinds that I love from vim and emacs provides me with the heavier stuff
20:18:16 <l0cust> elvis4526: it takes command line args
20:18:16 <elvis4526> It's an IO action, that returns a list of string ?
20:18:17 <johnw> @src (>>=) []
20:18:17 <lambdabot> Source not found. My mind is going. I can feel it.
20:18:18 <vlabs> MP2E: hm, cool. although I'm more of a sublime text fan
20:18:18 <Lutin`> Emacs - Say goodbye to your pinky
20:18:23 <hunt> AshyIsMe: i wanted to write a function that took a motion and then used it in a command line call
20:18:26 <pharaun> MP2E: how ... complete is evil ?
20:18:29 <MP2E> i've never tried sublime, I should try that :)
20:18:30 <hae> I mean I can use vanilla vim fine but for hardcore stuff Emacs is best.
20:18:37 <pharaun> because its the keybinding/etc is what keep me with vim
20:18:37 <l0cust> elvis4526: command line args come from outside your code
20:18:43 <elvis4526> Yes yes I know
20:18:51 <l0cust> elvis4526: so therefore they are IO
20:18:54 <vlabs> pharaun: how good are you at vim? ;) AFAIK it has everything other than a few obscure corners
20:18:55 <AshyIsMe> hunt: cool, sounds useful
20:18:56 <hae> I also have a script called electric-spacebar that makes my spacebar Control when held but not tapped.
20:19:02 <pharaun> vlabs: 10 years
20:19:04 <elvis4526> Okay
20:19:05 <kazagistar> lets keep the talk to haskell while there are haskell question being asked, #haskell-blah
20:19:05 <hunt> pharaun: i just read something on r/programming or something that evil mode is godlike
20:19:16 <vlabs> pharaun: *jaw drop* you're waaaay out of my league
20:19:22 <hunt> hae: lol electric spacebar thats a great name
20:19:26 <pharaun> vlabs: so probably much less good than some folks but yeah
20:19:34 <pharaun> hunt: haha
20:19:38 <hae> I know right? I don't think I came up with it though.
20:19:40 <pharaun> guess i should give emacs+evil a try again
20:19:47 <vlabs> pharaun: damn, I haven't even programming peoperly for 10 years >_>
20:19:50 <pharaun> i keep on hearing that the integration and stuff is much better
20:19:57 <elvis4526> but putStr take only a type String
20:19:58 <pharaun> esp syntax highlighting
20:20:02 <hunt> pharaun: i hope you dont use q a lot though
20:20:04 <pharaun> which always has bugged me in vim (regexes)
20:20:06 <MP2E> pharaun : i'd like to hear your input on it, particularly because you've used vim for so long
20:20:08 <vlabs> Zzz homebrew is building emacs :|
20:20:10 <l0cust> pharaun: #haskell-blah
20:20:11 <pharaun> hunt: i use macros all the time :|
20:20:11 <MP2E> I only used vim for about 2 years before I tried evil-mode
20:20:23 <hunt> pharaun: because i read that it doesnt work in a lot of help screens and menus, so some people disable it completely
20:20:34 <hunt> pharaun: that might not be offputting but some people seemed concerned about it
20:20:41 <systemfault> vlabs: Is there a reason why to build it from brew instead of downloading a binary?
20:20:49 <vlabs> MP2E: do you use emacs in the command line? or some other dedicated GUI?
20:21:00 <MP2E> I use emacs in daemon mode so I switch between graphical and terminal
20:21:02 <MP2E> I prefer terminal though
20:21:05 <vlabs> systemfault: it automatically updates packages AFAIK. I don't want dependency hell
20:21:05 <MP2E> it looks cleaner to me
20:21:05 <elvis4526> Am i on #emacs or what ?
20:21:07 <pharaun> ah
20:21:13 <systemfault> vlabs: Ah ok :)
20:21:16 <hae> Daemon mode is best mode.
20:21:17 <Lutin`> pharaun: evil doesn't have macros? :X
20:21:18 <pharaun> l0cust: ya joined, wasnt;' in it :)
20:21:19 <vlabs> systemfault: really new to mac tho. tell me if there's a better way
20:21:24 <hunt> elvis4526: we prefer not to take emacs or vim sides, this is an integrated irc channel
20:21:30 <pharaun> Lutin`: dunno its what hunt said
20:21:34 <hunt> elvis4526: if you want to discriminate you can take that elsewhere
20:21:39 <l0cust> elvis4526: You're on at the time where the americans are drunk, and the europeans haven't awoken
20:21:43 <hunt> elvis4526: origranner rightrs
20:21:47 <hae> No more startup delay every time you open a file.
20:21:56 <Lutin`> l0cust: Oh hey that's a good idea
20:21:57 <systemfault> vlabs: I usually download the gui version from there http://emacsformacosx.com/
20:22:02 * Lutin` gets out the vodka bottle
20:22:04 <lpsmith> hmm,  bytestring doesn't have a zipWith :: (Word8 -> Word8 -> Word8) -> ByteString -> ByteString -> ByteString
20:22:04 <vlabs> MP2E: do you use emacs in the command line? or some other dedicated GUI?
20:22:06 <elvis4526> Okay got it
20:22:12 <pharaun> anyway time to get emacs installed + evil mode to try it out and see
20:22:14 <MP2E> vlabs : command line, :P
20:22:14 <systemfault> vlabs: But then I’m not a emacs veteran
20:22:14 <hunt> pharaun: Lutin` no its just that some people disbale macros because a lot of emacs things use q for quit
20:22:15 <vlabs> systemfault: cool, will look into it
20:22:20 <lpsmith> unless zipWith and pack will fuze
20:22:20 <pharaun> ahh
20:22:22 <vlabs> MP2E: hm, okay.
20:22:26 <MP2E> I'm very much of the opinion that "unix is an IDE"
20:22:29 <MP2E> coreutils are your friend :)
20:22:36 <lpsmith> OTOH, it doesn't really matter for what I'm doing at the moment
20:22:36 <hae> l0cust, I was under the impression that Americans are always drunk.
20:22:38 <pharaun> thanks hunt  that scared the crap out of me :)
20:22:45 <l0cust> hae: we aren't the irish
20:22:49 <pharaun> hae: i'm sober!
20:22:56 <vlabs> systemfault: how's the GUI? emacs on linux looks atrocious
20:23:06 <hunt> pharaun: lol i felt like a fear mongerer too, im sorry
20:23:12 <l0cust> vlabs: it's fine if you disable the scroll bar, the tool bar, and the menu bar
20:23:14 <Lutin`> you people and your GUIs
20:23:15 <systemfault> vlabs: Fine with everything hidden..
20:23:17 <pharaun> hunt: its np :)
20:23:21 <hae> Yeah that.
20:23:27 <systemfault> Like l0cust said..
20:23:29 <pharaun> i'm just not familiar with emacs outside of the basics keybindings/etc
20:23:32 <hunt> sober here because i spend all my time programming instead of living the proper high school #yolo life
20:23:36 <hunt> not really im just a loner
20:23:38 <Lutin`> HEY GUYS
20:23:40 <vlabs> systemfault, l0cust doesn't that like, defeat the purpose?
20:23:43 <hae> Disable all the fancy GUI stuff and it's fine, plus the font and theme are entirely configurable.
20:23:43 <Lutin`> LETS HELP elvis4526
20:23:43 <l0cust> Lutin`: HI
20:23:47 <pharaun> sorry
20:23:51 <kazagistar> lpsmith: I think zipWith and pack are supposed to be good at fusing
20:23:52 <vlabs> hae: hm, good to know
20:23:52 <pharaun> elvis4526: what's up what's your issue
20:23:53 <l0cust> Lutin`: fuck off with your on-topic discussion
20:24:04 <hunt> pharaun: me neither, every time i touch it i create a mess
20:24:08 * MP2E grabs a picture of his emacs
20:24:20 <pharaun> indeed, anyway time to get it installed and i'll play a bit
20:24:21 <hunt> pharaun: inputting vim commands into default emacs gives you some schizophrenic looking code
20:24:26 <pharaun> :p
20:24:39 <hunt> pharaun: oh yea let me know how it works out
20:24:43 <vlabs> last time I tried getting to emacs, I couldn't find an equivalent to Vundle. was super confused >_<
20:24:44 <hae> I have a screenshot of mine lying around...
20:24:48 <MP2E> http://imgur.com/RZ8Zlzg
20:24:51 <hunt> elvis4526: what was your question
20:24:51 <elvis4526> I have a quick noob question. Why << main = do a <- getArgs; putStr a >> works and << main = putStr getArgs >> doesn't ?
20:24:52 <MP2E> Idk, I think my emacs looks nice :V
20:24:56 <MP2E> it's pretty minimalist though
20:25:04 <MP2E> I like minimalism a lot
20:25:10 <elvis4526> That was the question
20:25:11 <l0cust> Screenshot time! http://i.imgur.com/mRKeeoK.jpg
20:25:27 <MP2E> ooh neat
20:25:28 <hunt> elvis4526: getArgs :: IO [String]
20:25:30 <pharaun> uzbl?
20:25:37 <Lutin`> Emacs for Vim users :: C-x C-c
20:25:38 <hunt> elvis4526: putStr :: String -> IO ()
20:25:42 <elvis4526> Yes I got that know
20:25:44 <vlabs> l0cust: which window manager is that? herb? xmonad?
20:25:48 <l0cust> vlabs: i3
20:25:49 <vlabs> MP2E: neat!
20:25:53 <vlabs> l0cust: ohh
20:25:56 <elvis4526> I have to convert to output of getArgs
20:25:58 <Lutin`> pharaun: Just remember that and you'll be good
20:25:59 <kazagistar> elvis4526: (you should use {} instead for code, since >> and <<  are common operators with monads)
20:26:01 <elvis4526> to a string only ?
20:26:06 <vlabs> l0cust: I tried getting into the whole window manager thing but gnome3 is so.. neat
20:26:13 <hunt> elvis4526: so if you call putStr on getArgs youre trying to supply a value of type IO [String] to a function that takes a String
20:26:15 <vlabs> gnome3 + plank :3
20:26:16 <pharaun> btw elvis4526 a bit of tip don't use << >> as quotes that confused me :) i'm used to >> for bind
20:26:17 <elvis4526> kazagistar: okay thx for the tip i didn't noticed
20:26:20 <kazagistar> elvis4526: (so when a haskeller sees your question their eyes kinda cross a bit :P)
20:26:27 <Lutin`> l0cust: Jesus what monitor is that
20:26:27 <lpsmith> kazagistar, it looks like you are perhaps right,  zipWith (f :: Word8 -> Word8 -> Word8)    gets specialized to unpack . zipWith' f,  where zipWith' is not exported
20:26:29 <pharaun> kazagistar: mine did!
20:26:31 <hunt>  elvis4526 show can convert a [String] to a String if you want
20:26:32 <pharaun> i was very confused
20:26:43 <Lutin`> l0cust: Oh two vertical monitors
20:26:43 <lpsmith> Then hopefully pack . unpack would fuse away to nothing.
20:26:43 <l0cust> Lutin`: it's two 1920x1080 monitors, rotated vertically
20:26:49 <Lutin`> Yeah I see that now
20:26:58 <MP2E> ah, so that's how it's so big :P
20:27:02 <StoneCypher4k> l0cust: i do the same except with 4ks
20:27:11 <l0cust> StoneCypher4k: jesus, you must be loaded
20:27:13 <pharaun> main = show <$> getArgs >>= putStr ?
20:27:14 <hunt> elvis4526: this wont be very helpful but you could do: main = getArgs >>= (putStr . show)
20:27:24 <Lutin`> l0cust: compton?
20:27:32 <l0cust> Lutin`: yep
20:27:36 <vlabs> hm, can I rebind command to control?
20:27:42 <vlabs> that distinction is driving me nuts
20:27:51 <l0cust> vlabs: yep
20:27:53 <hunt> i feel like im forgetting how to write haskell
20:27:55 <StoneCypher4k> l0cust: it's about $1500 if you get the right sale, plus another $300 for a driving video card.  when you spend a significant amount of your life in front of them, and when they have a significant impact on fatigue, which i believe they do, it's an investment that pays out.
20:27:56 <hunt> i need to write something
20:27:56 <hunt> gayh
20:28:02 <pharaun> hunt: gah
20:28:12 <l0cust> hunt: gayyyyyyy
20:28:19 <hunt> pharaun: ty i hate being accidentally offensive :P
20:28:22 <hunt> lol
20:28:31 <pharaun> heh tis np
20:28:34 <barrucadu> elvis4526: An "IO [String]" can be thought of as a recipe to get a list of strings through some IO action. Haskell is pure, so you can't directly convert that to a [String]. Do notation provides syntactic sugar to build up chains of IO things (or any other monad) which handles the unpacking and repacking for you in a nice way
20:28:39 <Lutin`> hunt: https://www.youtube.com/watch?v=wXw6znXPfy4
20:28:44 <hae> https://i.imgur.com/uKTbUVt.png
20:28:45 <l0cust> StoneCypher4k: hm, I'll consider it
20:28:51 <hae> Another good theme.
20:29:10 <vlabs> hae: neat
20:29:11 <hae> The chat moved on though lol.
20:29:20 <elvis4526> hunt: it says there is no instance for (show (IO [String]))
20:29:34 <barrucadu> A thing to bear in mind is that the result of such a chain of functions, or a do block, will always be an IO something - you can't get pure values from an impure context
20:29:36 <MP2E> hae : I like the color scheme :>
20:30:00 <elvis4526> barrucadu: Okay
20:30:06 <vlabs> what's Meta on the mac? (for M-x)
20:30:10 <pharaun> time to spend 20 hours compiling emacs
20:30:20 <hae> Thanks, I think it kind of says "I'm serious" without looking too serious, you know?
20:30:24 <systemfault> vlabs: options
20:30:29 <vlabs> systemfault: ty
20:30:29 <systemfault> alt…
20:31:09 <vlabs> Alt+x just opens up this pane and says "Mark set" >_<. help?
20:31:10 <systemfault> I should be learning haskell instead of watching super mario world marathons..
20:31:18 <MP2E> hahah
20:31:18 <hae> You know it annoys me that on a standard Mac keyboard there's only the left Control key.
20:31:55 <vlabs> hae: oh my god I never noticed. *shakes fist*
20:32:27 <MP2E> first you take the right click now the right control?!? next the keyboard will be replaced with a scroll wheel
20:32:31 <MP2E> I kid, of course :P
20:32:52 <kazagistar> systemfault: oh no, did I miss the 120 star run?
20:33:25 <hae> ^ vlabs
20:33:26 <elvis4526> In a type signature, when it's written that a function take for example: (a -> b) as an argument
20:33:36 <elvis4526> (a -> b) represent an function
20:33:43 <elvis4526> that take a as an argument and returns b ?
20:33:51 <hunt>  elvis4526 correct
20:33:57 <barrucadu> "a" and "b" are type variables in this context
20:34:08 <elvis4526> all right
20:34:10 <hae> Type variables are best variables.
20:34:21 <hunt> elvis4526: could you paste your code/error here: http://lpaste.net/new/haskell
20:34:41 <hunt> hae: you use right control?
20:34:43 <hunt> hae: what?
20:34:51 <systemfault> kazagistar: No, it’s later :P
20:34:52 <hunt> hae: ive maybe pressed that button 2 times and by accident
20:34:59 <vlabs>  
20:35:10 <barrucadu> Something I've occasionally wondered about Haskell: why don't we have main :: [String] -> IO ()? starting off a program with a call to getArgs (or some argument parsing thing which uses getArgs) is pretty common
20:35:27 <hae> hunt, sometimes you'll use it on a laptop when you're only using one hand.
20:35:33 <hunt> systemfault: where are you watching them cause that sounds awesome
20:35:43 <hunt> hae: ah actually thats true
20:35:46 <systemfault> hunt:http://gamesdonequick.com/
20:35:51 <barrucadu> And a lot of other languages adopt the convention of main taking the argv as an explicit parameter
20:35:51 <systemfault> Err http://gamesdonequick.com/
20:35:59 <copumpkin> barrucadu: why?
20:36:35 <copumpkin> barrucadu: define a withArgs $ \args -> ...
20:36:52 <copumpkin> conceptually, I don't like getting things I'm not going to use
20:36:57 <barrucadu> copumpkin: It's just that command-line arguments are such a common way to interact with a program, when I was first learning haskell it kinda surprised me that I had to explicitly ask for them
20:36:58 <vlabs> barrucadu: "a lot" ? I can think of C/C++
20:37:00 <copumpkin> if I want them, I'll ask for them
20:37:25 <jle`> barrucadu: haskell is a language, not an implementation
20:37:30 <jle`> barrucadu: what about other backends?
20:37:34 <jle`> an iOS backend?
20:37:37 <jle`> javascript backend?
20:37:41 <barrucadu> vlabs: Java as well
20:38:06 <enthropy> jle`: those arguments would give whatever getArgs would provide
20:38:16 <vlabs> barrucadu: hm, don't remember about Java. but anyway, all other languages that I've used require you to explicitly access argv
20:38:41 <vlabs> python,ruby, Rust, lisp..
20:38:42 <jle`> enthropy: i mean, haskell as a language isn't built around the command line tool paradigm
20:38:55 <hae> I guess since not all programs have it in common, they didn't feel the need to do it.
20:39:00 <jle`> if it was built around unix, it might as well be [String] -> IO Int
20:39:05 <jle`> where you return the return code
20:39:09 <sveit> with type families, is it possible to do some very basic logical computation in the sense that suppose I have some type with a single parameter T a, then have a type family C such that if type C (T a) = D if a implements some typeclass, and type C (t a) = E if a doesn't implement that typeclass?
20:39:11 <copumpkin> ugh
20:39:28 <copumpkin> sveit: no
20:39:30 <hae> What they all do have in common is being run in hardware, hence IO.
20:39:43 <copumpkin> sveit: you don't have a closed world
20:39:44 <enthropy> @type interact
20:39:45 <lambdabot> (String -> String) -> IO ()
20:39:51 <copumpkin> sveit: so you can't ever say that something doesn't implement a typeclass
20:40:25 <hae> Sounds like one of those language extensions that will never be used. "Explicit non-implementation pragma"
20:40:26 <sveit> copumpkin: sure, how about this then: default to C (T a) = E, but if a implements a some particular typeclass F, C (T a) = D
20:40:56 <jle`> barrucadu: using higher order functions can handle most of these cases in clean ways; main = withArgs $ \args -> do ...
20:40:57 <copumpkin> but then code that might have compiled at some point without an instance has settled on "the default"
20:41:03 <copumpkin> and then you define the instance, expect it to do something idfferent
20:41:14 <copumpkin> and it doesn't because it didn't know about your instance at the time it was compiled
20:41:19 <copumpkin> it introduces compile order dependence
20:42:11 <sveit> copumpkin: but then why can I write something like "instance (TypeClass1 a) => TypeClass2 (B a) where ..." (with some GHC extension i've forgotten the name of)
20:42:31 <copumpkin> that's standard haskell
20:43:00 <copumpkin> what's wrong with that?
20:43:03 <sveit> copumpkin: you're right, i'm using so many extensions i've lost track
20:43:11 <sveit> anyway, doesn't that introduce the same dependency?
20:43:17 <copumpkin> not that I know of?
20:43:22 <Lutin`> omg what
20:43:33 <Lutin`> pharaun: I just installed powerline for zsh
20:43:34 <sveit> because then I can also write a different instance (i think this might require an extension) "instance TypeClass2 (B a) where...
20:43:42 <Lutin`> pharaun: And now I have vim keybindings in zsh
20:43:47 <copumpkin> sveit: that'll overlap
20:43:49 <MP2E> Lutin`: o.o
20:43:54 <MP2E> I think I'm going to install taht
20:43:56 <MP2E> I use zsh already
20:44:13 <Lutin`> It's kind of weird tho
20:44:18 <sveit> copumpkin: yep, but doesn't GHC resolve that? Anyway, i can see why you're right/this might be bad idea, but whats the solution to this?
20:44:24 <sveit> the "normal" solution?
20:44:59 <copumpkin> sveit: don't think there is one. Step back and look at what you're trying to do and figure out if it intrinsically needs to figure out if an instance exists or not? :)
20:45:23 <enthropy> you can make an overlapping instance, so that all types will have instances
20:46:52 <sveit> i guess i should be more specific. my problem is i have some datatype D a = SomeStructure a. if a implements some particular typeclass then SomeStructure can be made a more efficient structure
20:47:02 <Lutin`> :q
20:47:05 <Lutin`> whoops
20:47:25 <sveit> the problem is that I also want to make D a functor/traversable/all that other good stuff, so i want to fall back to lists in the even that a doens't implement the typeclass i'm thinking of
20:48:12 <pharaun> Lutin`: yup its sweet
20:48:25 <Lutin`> pharaun: The command bindings seem to be off though
20:49:14 <Lutin`> and I've gotten used to grml-zsh-config and it doesn't seem to work with that so. Anyways I'll stop being offtopic
20:49:30 <pharaun> heh np
20:49:38 <levi> sveit: You might want to look at how Vector is organized then.
20:49:50 <sveit> levi: problem with Vector is it isn't a functor
20:49:53 <vlabs> hm, how does one automatically pull dependencies?
20:49:54 <sveit> which is what I am trying to do
20:50:03 <levi> I didn't say to *use* Vector
20:50:09 <vlabs> I'm tryint to build them toml parser
20:50:35 <vlabs> trying*
20:50:41 <sveit> levi: of course. i've taken what is probably a very cursory look at vector already and found that this was missing
20:51:06 <levi> Vector provides an interface and several different implementations of it via a set of modules. You use the version that's appropriate.
20:51:20 <copumpkin> I don't think it helps sveit's use case
20:51:46 <copumpkin> the closest thing I can think of is edwardk's Arrayed class
20:51:54 <copumpkin> but I think he just lists out the types that can be more efficient
20:51:58 <vlabs> could someone help me understand what's going on wih cabal? http://pastebin.com/g65tAHCD
20:52:25 <copumpkin> sveit: honestly, I don't think it really fits with how we do things, and is going to be a huge hack if you can even get it to work
20:52:35 <hae> You know what I find weird? There's no Function class.
20:52:40 <copumpkin> hae?
20:52:57 <copumpkin> implicitly doing something fancy if it happens to have an instance seems somewhat scary to me
20:53:07 <copumpkin> because it literally isn't parametric anymore
20:53:26 <copumpkin> your "functor" could detect if it had an Int in it, and do something completely different if so
20:53:28 <vlabs> guys, help? >_< http://pastebin.com/g65tAHCD
20:53:36 <sveit> copumpkin: that's what it feels like. it's kind of unfortunate. the idea is i want to implement an efficient tensor type that stores it's elements in a data.vector if they implement data.vector for some vector, but otherwise in a list.
20:53:38 <copumpkin> which completely goes against the idea of parametricity
20:53:56 <copumpkin> sveit: Data.Vector always works
20:54:01 <copumpkin> Data.Vector.Unboxed is what you mean?
20:54:04 <levi> vlabs: runhaskell doesn't know about your sandbox
20:54:05 <enthropy> https://github.com/leftaroundabout/constrained-categories
20:54:15 <levi> vlabs: just type 'cabal install'
20:54:16 <sveit> copumpkin: yeah, sorry for not being specific
20:54:23 <sveit> copumpkin: and wrong :)
20:54:32 <sveit> but that's exactly what i'm thinking of
20:54:32 <copumpkin> sveit: in that case, that's exactly what edwardk's Arrayed class is for https://github.com/ekmett/structures/blob/master/src/Data/Vector/Array.hs
20:54:42 <vlabs> levi: will try
20:54:43 <levi> vlabs: Or if you want runhaskell to know about your sandbox, do 'cabal exec sh'
20:54:50 <vlabs> levi:  >_<
20:55:01 <heatsink> sveit, you can write the tensor methods as a type class with boxed default behavior and some instances that use unboxed arrays
20:55:22 <heatsink> Oh, that's what Arrayed is doing
20:56:23 <heatsink> nm, looks like arrayed is always unboxed
20:56:25 <vlabs> levi: now how do I use this "installed" library? I tried importing Text.Toml but that didn't work
20:56:47 <MP2E> cabal exec sh
20:56:57 <levi> vlabs: How did you try importing it?
20:57:08 <vlabs> levi: import Text.Toml
20:57:14 <sveit> heatsink: can you explain that a bit more?
20:57:24 <levi> I mean, in ghci or in a file or what?
20:57:28 <vlabs> levi: and import Text.TOML
20:57:30 <vlabs> levi: in a file
20:57:51 <vlabs> levi: and tried executing it with runhaskell
20:57:53 <copumpkin> heatsink: Arrayed tries to be as unboxed as possible
20:58:04 <copumpkin> heatsink: at least that's what I remember it trying to do.
20:58:14 <levi> vlabs: And what did it say?
20:59:03 <vlabs> Could not find module ???Text.TOML???
21:00:14 <heatsink> sveit: I don't think there's a way to completely automatically choose whether to use a boxed or unboxed vector.  But you can make it easy to write instances for each type you use.
21:00:29 <AshyIsMe> so i've modified a package from hackage and now i want to use it in my project
21:00:37 <levi> vlabs: What about if you use ghci and to :m + Text.TOML ?
21:00:39 <AshyIsMe> how do i specify a local package in the build-depends in the cabal file?
21:00:50 <heatsink> The instance would need to say what data type the tensor uses (a boxed or unboxed vector) and how to access the tensor (with boxed or unboxed vector functions).
21:00:53 <vlabs> levi: will do
21:00:53 <AshyIsMe> instead of it getting the version from hackage
21:01:25 <vlabs> levi: no, it doesn't work
21:01:44 <levi> AshyIsMe: If you're using sandboxes, you can add the local directory to the sandbox for your project.
21:02:06 <levi> cabal sandbox add-source
21:02:28 <AshyIsMe> yeah im using a sandbox, cheers
21:02:34 <vlabs> levi: I created a sandbox
21:02:42 <vlabs> levi: but I don't know is cabal picked up on it
21:03:43 <levi> vlabs: Are you trying to hack on toml or are you trying to use it in your own project?
21:03:44 <sveit> heatsink, copumpkin: it still seems as though Arrayed can't be made a functor
21:03:51 <copumpkin> yeah
21:04:07 <copumpkin> it's giving you the more efficient representation if it can, but it still won't be parametric
21:04:22 <kazagistar> hae: Arrow is vaugely like a Function class :P
21:04:35 <hae> Meh.
21:04:38 <sveit> this is very disturbing to me. i feel as though this is definitely something that should be possible for haskell.
21:04:54 <vlabs> levi: I'm trying to use it
21:04:54 <copumpkin> it's literally contrary to parametricity :P
21:05:16 <copumpkin> you can get into that restricted functor/applicative/monad stuff
21:05:22 <sveit> copumpkin: you're totally right, but I still think there should be a way to work with haskell to choose an efficient implementation
21:05:24 <copumpkin> but that's weird
21:05:32 <heatsink> weird?
21:06:06 <sveit> copumpkin: the face of my problem is extremely simple, i just want to be able to have a container C a that I can map over and chooses the most effective storage mechanism for a available
21:06:06 <vlabs> toml Default available version: 0.0.0
21:06:33 <copumpkin> sveit: you can have your own custom map that has additional constraints on the domain and codomain
21:06:42 <copumpkin> like Arrayed
21:06:44 <levi> vlabs: If you want to use it, you need to make a new directory and make your *own* cabal file and sandbox that has a build-depend of toml.
21:06:47 <vlabs> levi: if I'm trying to use a package, what's the recommended way to go abou it?
21:06:53 <copumpkin> Functor is making a statement that is simply not true in your case
21:06:56 <sveit> copumpkin: this might sound pouty but that's not what I want :)
21:07:16 <sveit> copumpkin: i disagree. i have a type C a that can take any type as a parameter, I just want to choose an efficient implementation
21:07:21 <vlabs> levi: ohh. so what should my custom file look like?
21:07:24 <sveit> or storage mechanism
21:07:35 <vlabs> levi: and why has no one written a package manager for haskell yet? >_<
21:07:48 <copumpkin> sveit: yes, and your implementation might be wrong and produce subtly different values. Do you know what parametricity says?
21:08:15 <sveit> copumpkin: but mine won't be :) suppose i use exclusively vector, and the unboxed version in the case of unboxable values
21:08:22 <levi> vlabs: You're working with one; you're just misunderstanding how it works a bit, I think.
21:08:28 <copumpkin> yes, and how do you determine if the values are unboxable?
21:08:32 <heatsink> sveit: Data.Vector.Unboxed and Data.Vector do not behave exactly the same.  For example, fromList [undefined] gives you different results
21:08:41 <vlabs> levi: possibly.
21:08:50 <vlabs> levi: I assumed cabal was more of a build system?
21:08:52 <heatsink> because boxed vectors can hold bottom values, while Unboxed cannot
21:08:55 <vlabs> levi: than a package manager?
21:09:07 <vlabs> levi: and cabal-install is this module which allows one to install?
21:09:17 <vlabs> levi: at least, that's the impression I got
21:09:18 <copumpkin> sveit: my point is that allowing you, Mr. Good, to inspect this sort of thing, means none of the rest of us can assume anything about parametric functions again
21:09:32 <copumpkin> sveit: this is what makes me like Haskell and dislike e.g., Sclaa
21:09:41 <copumpkin> sveit: so allowing your use case would actively make me not want it
21:09:42 <levi> vlabs: ghc-pkg is a package manager, cabal is a build system, and cabal-install is a downloader for hackage-based cabalized software.
21:10:20 <copumpkin> sveit: we have a mechanism for passing "additional knowledge" along with unknown types, and that's typeclasses
21:10:22 <copumpkin> but you can't hide that
21:10:28 <copumpkin> Functor says "no type constraint"
21:10:33 <vlabs> levi: so can I use ghk-pkg to "get" the toml library? hackage == online haskell repo for libs right?
21:10:44 <copumpkin> and we get a lot of strong reasoning power from that
21:10:47 <sveit> copumpkin: 99% of the time i would agree with you, but i would like to (for personal "fun") implement these matrix operations as efficiently AND generically as possible over arbitrary types. i think it's absurd that this is impossible
21:11:01 <copumpkin> it isn't
21:11:03 <sveit> copumpkin: conceptually, a matrix/tensor/container is absolutely a functor, i am sure you would agree with that
21:11:16 <levi> vlabs: If you're familiar with Debian/Ubuntu, ghc-pkg is kind of like dpkg; it doesn't *get* anything, but it keeps track of what's installed.
21:11:50 <vlabs> levi: yep, I am familiar with dpkg.
21:11:57 <levi> vlabs: http://www.vex.net/~trebla/haskell/sicp.xhtml
21:12:01 <vlabs> levi: but dpkg can install too given a .deb file :) dpkg -i !
21:12:25 <systemfault> but dpkg is low level.
21:12:35 <levi> *anyway*
21:12:38 <vlabs> systemfault: yeah, apt-get is the high level interface
21:12:57 <copumpkin> sveit: my only point is that allowing you to lie in your type allows everyone else to lie, and then we can't trust the type anymore
21:13:18 <copumpkin> adding a "taint" to it is what we call passing a typeclass around :P
21:13:37 <vlabs> levi: give me a TL;DR of instaling a package?
21:13:44 <vlabs> installing*
21:13:51 <levi> A cabal file tells how to *build* a package. A cabal sandbox builds a package and its dependencies in isolation. But if it's a library package, you don't want it isolated; you want it available as a build dependency for something else!
21:13:58 <copumpkin> sveit: if you can propose a mechanism by which I get my guarantees and you get your adaptive representation, I'll take it
21:14:12 <copumpkin> but absent that, I much prefer this situation than the one that allows your application
21:14:12 <vlabs> levi: oh, so I *don't* sandbox?
21:14:22 <levi> vlabs: Wait a minute.
21:14:39 <levi> vlabs: What you want is to describe how to build *your* software in a cabal file.
21:14:49 * hackagebot property-list 0.1.0.4 - Apple property list parser  http://hackage.haskell.org/package/property-list-0.1.0.4 (JamesCook)
21:15:15 <copumpkin> mokus: you're alive!
21:15:16 <vlabs> levi: ah, so I write a .cabal file for my project?
21:15:23 <vlabs> levi: which lists toml as a dependency?
21:15:24 <levi> vlabs: One of its dependencies is toml. So when you tell cabal to build your program's dependencies, it will grab them and build them in a sandbox that has all of *your project's* dependencies.
21:15:28 <vlabs> and *my* project is sandboxe?
21:15:32 <Lutin`> pharaun: Do you use powerline?
21:15:33 <mokus> copumpkin: for a day or two anyway :)
21:15:34 <jle`> vlabs: cabal init
21:15:38 <copumpkin> mokus: come back!
21:15:49 <mokus> copumpkin: i'd love to, i just have so little time these days
21:15:53 <copumpkin> boo
21:15:58 <copumpkin> what's eating it up?
21:16:01 <mokus> copumpkin: second of two kids is almost 1 :)
21:16:04 <pharaun> Lutin`: oh, i don't
21:16:04 <copumpkin> oh I see
21:16:15 <pharaun> i've heard of it but i never installed it
21:16:19 <Lutin`> pharaun: Ah okay, trying to decide on a font
21:16:31 <vlabs> jle`: I don't know what the project's going to be called ;) levi thanks, that gave me perspective. will try!
21:16:33 <mokus> copumpkin: and i have a very interesting non-haskell job, my last job let me do a lot of haskell work
21:16:41 <copumpkin> aha
21:16:43 <copumpkin> where are you now?
21:16:50 <mokus> that's probably the biggest factor actually :)
21:16:57 <mokus> a DOE lab in santa barbara
21:17:04 <copumpkin> ah, cool
21:17:14 <levi> vlabs: You can give it a bogus name and rename it later.  The important thing is just having a cabal file and sandbox that you can install libraries you want to use in.
21:17:54 <vlabs> levi: okay
21:18:06 <vlabs> Include documentation on what each field means <- what exactly does that do?
21:18:14 <mokus> i manage to do a bit with haskell there but unfortunately they're a lot less liberal about letting me open source my work
21:18:21 <copumpkin> :(
21:19:16 <vlabs> is build-depends comma separated?
21:19:20 <vlabs> what's the format here?
21:20:41 <mokus> copumpkin: i've barely been keeping up with major developments in the haskell community, any big interesting agda work going on lately?
21:20:43 <jle`> vlabs: it is comma separated :)
21:20:50 <vlabs> jle`: ty
21:21:05 <copumpkin> mokus: haven't kept up much myself either :/
21:21:06 <jle`> i could send you a description of the format, but i think it might be more beneficial to just look at different examples
21:21:10 <jle`> vlabs ^^
21:21:32 <blackdog> hello all - i'm going on a mini paper rampage to get back up to speed on theory. anyone got a good reference for understanding pipes/iteratees etc?
21:21:32 <levi> vlabs: http://www.haskell.org/cabal/users-guide/
21:22:15 <vlabs> jle`: thanks
21:22:27 <jle`> blackdog: the pipes tutorial is nice itself...but ther'es that monad reader article about continuation based libraries and stuff
21:22:33 <levi> For pipes, probably just the tutorials in the haddocks and Gabriel's blog.
21:23:00 <blackdog> jle`: yes, been going through the pipes tutes. monad reader is a good idea, cheers.
21:23:11 <jle`> imma find it for u
21:23:26 <jle`> it's issue 19
21:23:32 <blackdog> thanks :)
21:23:39 <blackdog> anyone here use mendeley?
21:23:40 <jle`> http://themonadreader.files.wordpress.com/2011/10/issue19.pdf
21:23:45 <jle`> coroutes, that's the word
21:23:47 <jle`> i use mendeley
21:24:02 <blackdog> i just found it - trialling it partly out for my gf
21:24:12 <blackdog> she's tied to the whole Word ecosystem because of endnote atm
21:25:20 <jle`> ah
21:25:35 <jle`> i use it to organize literature and share with other people. i'm in academia
21:25:58 <jle`> it's worked well for me
21:26:03 <jle`> and i get to sync my library across devices
21:26:36 <hae> Academia? Is that in South America?
21:26:48 <blackdog> jle`: right - that's what i'm keen on it for. would be nice to have a bunch of stuff i've already decided to read available everywhere
21:26:51 <jle`> yes it's nestled next to argentina
21:27:10 <hae> ^
21:27:17 <blackdog> otherwise i just dick around on twitter. (which reminds me, anyone got any suggestions for @evilhaskelltips? i haven't come across anything awful for weeks.)
21:27:18 <jle`> our national team didn't qualify for the world cup unfortunately
21:28:22 <heatsink> Name all your types "T" and all your classes "C"
21:28:29 <blackdog> jle`: the other thing i kind of want is a paper suggester - "hey, you read this and this and this, they all reference blah, maybe read that"
21:28:34 <blackdog> does mendeley do anything like that?
21:28:43 * blackdog has been out of academia a while and is feeling very rusty
21:29:47 <heatsink> Search engine citation links and conference proceedings are useful for finding new papers
21:29:57 <jle`> blackdog: i don't think so, no.  but usually ijust follow citation trails and conferences
21:30:24 <blackdog> fair enough.
21:30:49 <hae> blackdog, use lambda expressions anywhere you don't feel like using flip or application.
21:31:25 <jle`> always use ($) instead of (.) whenever possible
21:31:43 <ticktockman> Has anyone managed to install the bullet bindings recently? The link to the original bullet library (2.79) on GitHub is no longer a valid link, and when I install the 2.79 listed on google code, I get linking errors.
21:32:22 * blackdog just realises all these terrible suggestions are aimed at @evilhaskelltips :) clearly i need more coffee
21:32:54 <hae> blackdog, ooh, always make your functions return singleton lists and use null to sort out errors.
21:33:24 <blackdog> hae: there's a gem of something in there
21:33:33 <blackdog> needs to have some implicitness applied to (->) i think
21:33:33 <jle`> i do'nt think that's necessarily evil
21:33:39 <jle`> that's basically returning a Maybe a instead of an a
21:33:54 <blackdog> so that if it returns a Maybe a it can get implicitly fromJusted
21:34:28 <blackdog> also Cantor has something to say about Float having an Enum instance :)
21:34:50 * hackagebot Tape 0.4.0.0 - Bidirectionally infinite streams, akin to the tape of a Turing machine.  http://hackage.haskell.org/package/Tape-0.4.0.0 (kwf)
21:35:01 <hae> In case you want to add more results later and not change your type annotations lol.
21:35:19 <hae> ^ That's interesting, I guess.
21:35:24 <carter> @tell edsko i keep on finding new wasys to break ghc-events-analyze :*(
21:35:24 <lambdabot> Consider it noted.
21:36:21 <jle`> having a possibly erroring function return [a] is actually not too bad of an idea
21:36:33 <jle`> because then you can compose them with multivalued functions
21:36:47 <jle`> without maybeToList
21:36:54 <hae> But the bad part is it's a _singleton_ list, and you'll just use head to extract values.
21:37:00 <jle`> noooo
21:37:11 <jle`> use pattern matching, same as for Maybe
21:37:38 <lfairy> wait, what are we talking about here?
21:37:46 <jle`> the real evil tip would be to literally use a runtime error/bottom to report error, and using unsafePerformIO . evaluate
21:37:53 <hae> Appropriate evilness of tips.
21:38:08 <lfairy> oh, missed the part about @evilhaskelltips
21:38:38 <lfairy> jle`: don't you mean evaluate . force?
21:38:44 <hae> It just goes to show you a bad programmer can write bad programs in any language.
21:38:47 <jle`> :t evaluate
21:38:47 <lfairy> we need to be thorough here
21:38:48 <lambdabot> a -> IO a
21:38:56 <jle`> we want a pure function
21:39:04 <lfairy> evaluate only goes down to WHNF though
21:39:09 <jle`> oh yea
21:39:21 <jle`> well, there's a reason it's an evil tip ;)
21:39:31 <lfairy> that's what I was thinking too :D
21:39:34 <carter> i'm using Debug.Trace to help track the progress of a batch program
21:39:51 * hackagebot PeanoWitnesses 0.1.0.0 - GADT type witnesses for Peano-style natural numbers.  http://hackage.haskell.org/package/PeanoWitnesses-0.1.0.0 (kwf)
21:40:10 <jle`> good job carter
21:40:28 <carter> its actually really helpful in understanding which parts are too lazy !
21:40:41 <carter> i'm like "huh, why is it reporting its done, THEN doing the work"
21:40:52 <hae> I'm the strong, lazy type.
21:41:41 <jle`> i have more or less rationalized out a consistent semantics for Debug.Trace and unsafePerformIO type stuff
21:41:47 <jle`> so i no longer stay up late at night
21:42:54 <ReinH> equational reasoning is hard :(
21:43:08 <hae> I have a general idea: Use external shell commands to process some input.
21:43:17 <hae> That's a fantastic evil tip.
21:43:30 <hae> Especially if it depends on environment variables lol.
21:43:34 <jle`> hae: that's basically FFI ;)
21:44:31 <Lutin`> Write all your mission critical in C so that it's fast and call it from Haskell
21:44:37 <jle`> ReinH: 3 x < 9 u, solve for x
21:44:51 * hackagebot NestedFunctor 0.2.0.1 - Nested composition of functors with a type index tracking nesting.  http://hackage.haskell.org/package/NestedFunctor-0.2.0.1 (kwf)
21:44:55 <jle`> er
21:44:57 <jle`> i messed that up
21:44:59 <Lutin`> Nothing will go wrong
21:45:00 <jle`> 3 i < 9 u
21:45:06 <jle`> solve for i :3
21:45:37 <hae> Lol people think it's the language's fault when something is slow, when really it's just because more time has been invested in finding the optimal C solution.
21:45:52 <vlabs> http://pastebin.com/a8zj3dmS not sure what I'm doing wrong
21:46:38 <carter> hae: true
21:46:51 <carter> that said, i may have found a ghc bug :(
21:46:54 <hae> I even wrote a simple factoring algorithm that's the same complexity class as the standard shell util.
21:47:03 <hae> They didn't believe I could do it!
21:48:16 <vlabs> hm, wait, I have a sandbox now, with the dependencies listed in my .cabal file.
21:48:26 <vlabs> now the package that I need as a dependency is on github
21:48:33 <zachoakes> anyone know why cabal would fail to build a project on an external drive?
21:48:48 <vlabs> am I expected to a) clone the package *into my project folder* and then install
21:48:53 <vlabs> or b) something else?
21:49:05 <Lutin`> vlabs: clone into other directory
21:49:25 <vlabs> Lutin`: without a sandbox in that directory right?
21:49:26 <Lutin`> do `cabal sandbox init --sandbox=directory of your sandbox`
21:49:40 <vlabs> so it would point to my directory?
21:49:42 <vlabs> interesting
21:49:48 <Lutin`> at least that's what I'd do, there may be a better way
21:50:03 <Lutin`> Well the .cabal-sandbox directory in your project directory
21:50:10 <vlabs> Lutin`: gotcha.
21:50:26 <Lutin`> jle`: Does that sound alright?
21:50:27 <vlabs> Lutin`: how does one delpoy a haskell project with dependencies?
21:51:20 <kazagistar> there are a lot of non-haskell-specific tools for that...
21:52:15 <vlabs> kazagistar: :) I mean, how do you package your dependencies? if it were C++ you'd ship with the .a / .so, with rust you'd deloy with rlib, with python you'd write an egg...
21:52:23 <vlabs> what's the method for haskell?
21:54:16 <zachoakes> looking for help. cabal works fine on a project in my home dir, but the same project fails to build if i move it to an external drive.
21:54:22 <hae> Compile it first lol.
21:55:28 <hae> vlabs, it depends on what kind of dependencies you're talking about.
21:55:29 <zachoakes> cabal gives "unsupported operation" to be specific
21:55:46 <hae> zachoakes, maybe it's a file permissions thing?
21:55:53 <Lutin`> zachoakes: What OS and what format is the drive?
21:55:53 <mzero> zachoakes: does the remote drive have a space in it's name?
21:56:21 <hae> Or there's some kind of setting that limits it to not operate cross-filesystem, like Git?
21:56:24 <zachoakes> no space in the name. format is exfat and OS is ubuntu.
21:56:29 <vlabs> hae: haskell dependencise
21:56:29 <mzero> it would help if you'd lpaste the output from running it
21:56:37 <vlabs> hae: other haskell libraries that is
21:56:46 <vlabs> hae: like the toml library I'd like to use
21:56:46 <zachoakes> file permissions sounds like a possibility.
21:56:53 <Lutin`> yeah
21:56:59 <Lutin`> exfat doesn't support full unix permissions
21:57:09 <hae> vlabs, what's wrong with letting cabal handle it in that case?
21:57:12 <Lutin`> Something might need to be executable
21:57:15 <mzero> unsupported operation.... doesn't sound like permissions
21:57:34 <Lutin`> zachoakes: Can you put the full output on lpaste?
21:57:46 <mzero> sounds much more like a limit in exfat
21:57:52 <kazagistar> vlabs: well, a standard way is to statically compile
21:58:21 <hae> I remember that FAT has a hard 4GB limit on file size.
21:58:22 <zachoakes> the only output is "cabal: dist: unsupported operation"
21:58:54 <vlabs> kazagistar: right, I was hoping that you could do that
21:59:05 <mzero> ah - looks like exFAT doesn't support file links
21:59:23 <hae> That's what you were asking about the whole time, vlabs? GHC compiles statically by default.
21:59:26 <Lutin`> You could try cabal --verbose get more info
21:59:29 <mzero> as    ln    command
21:59:43 <mzero> which - would make it unsuitable I suppose for cabal
21:59:44 <Lutin`> Or strace it to see where the issue arises to confirm mzero's suspicions
22:00:36 <vlabs> hae:  yeah :)
22:00:45 <Lutin`> vlabs: If you're on arch you can use cblrepo to create a PKGBUILD
22:00:53 <hae> ^ that too
22:01:25 <zachoakes> with cabal --verbose build, it says creating dist/build, creating dist/build/autogen, and then the unsupported operation line
22:01:31 <mzero> zachoakes: poking around the web, looks like exFAT doesn't support links - and seems cabal dist uses them in some part of the operation
22:01:48 <vlabs> Lutin`: hm, that's nice
22:01:52 <hae> zachoakes, were those files created?
22:01:58 <mzero> right - I think those operations involve linking files ...  could go poke through the source to find...
22:02:07 <zachoakes> hae: yes, the directories were created
22:02:08 <Lutin`> strace would be faster lol
22:02:21 <hae> Probably what mzero just said.
22:02:43 <Lutin`> but I've never straced anything haskell related so it might be cluttered
22:02:44 <hae> Seriously, *FAT is the worst filesystem ever.
22:02:57 <zachoakes> mzero: thank you for looking into it. i suppose ill need to develop elsewhere.
22:03:44 <zachoakes> i formatted it as exfat so i could use it on windows 7 and os x as well as linux
22:03:52 <jle`> Lutin`: huh?
22:04:51 <Lutin`> jle`: Just wanted to get a second opinion on my suggestion
22:04:53 * hackagebot NestedFunctor 0.2.0.2 - Nested composition of functors with a type index tracking nesting.  http://hackage.haskell.org/package/NestedFunctor-0.2.0.2 (kwf)
22:04:55 * hackagebot IndexedList 0.1.0.0 - Length-indexed and element-indexed lists which sit somewhere between homogeneous and fully heterogeneous lists.  http://hackage.haskell.org/package/IndexedList-0.1.0.0 (kwf)
22:04:57 * hackagebot IndexedList 0.1.0.1 - Length- and element-indexed lists sitting somewhere between homogeneous and fully heterogeneous.  http://hackage.haskell.org/package/IndexedList-0.1.0.1 (kwf)
22:05:28 <hae> Probably NTFS would serve that purpose better.
22:06:06 <hae> But I digress.
22:07:32 <jle`> Lutin`: oh :)  i trust you.
22:08:22 <Lutin`> it's the backtick isn't it
22:09:13 <jle`> yes it is
22:09:50 <MP2E> backtick brothers
22:10:06 <Lutin`> 4 lyf
22:10:34 <jle`> dmj` is offline
22:16:33 <startling> so, when cabal-install complains about breaking the package ghc-7.6.3, what does it mean?
22:16:37 <startling> (what is that package?)
22:22:13 <startling> (will Bad Things happen if I break it?)
22:23:34 <simcity2000> so I'm playing with Control.Distributed.Process and I'm having a bit of trouble figuring out how to actually connect to remote nodes
22:24:17 <jle`> startling: usually for me i think it involves a version of TH or something that is associated with the ghc
22:24:26 <jle`> startling: have you tried using --constraint to find out what the package is?
22:24:43 <SparkySparkyBoom> what's the usual way of resolving a "Multiple declarations" error while compiling?
22:25:02 <SparkySparkyBoom> i have two constructors with the field name "channel"
22:25:18 <startling> SparkySparkyBoom, you name one something different, or you move one constructor to another module
22:25:37 <SparkySparkyBoom> hmm
22:25:43 <SparkySparkyBoom> and use qualified imports?
22:25:51 <startling> sure.
22:25:58 <SparkySparkyBoom> ah thank you
22:26:30 <startling> jle`: no, but I should, thanks
22:26:42 <startling> mostly I'm just wondering if I can get away with --force-reinstalls here
22:27:03 <jle`> i have not had good luck with force reinstalling ghc
22:27:08 <jle`> but ymmv
22:27:15 <simcity2000> does anybody have experience with cloud haskell or should I keep playing around?
22:27:20 <startling> jle`, what is the ghc package?
22:27:38 <jle`> startling: have you looked at Parallel & Concurrent Haskell by Simon marlow?
22:27:39 <startling> I think what's happening is that a package of mine wants a new text or bytestring or something
22:27:54 <startling> jle`, no. does it help here?
22:27:55 <jle`> startling: i mean, fore reinstalling when it'll break ghc
22:28:07 <jle`> oh sorry
22:28:09 <jle`> i meant simcity2000
22:28:11 <jle`> s<tab>
22:28:14 <startling> :P
22:28:19 <startling> I was wondering what you were getting at.
22:28:28 <jle`> simcity2000: have you looked at Parallel & Concurrent Haskell by Simon Marlow?
22:28:59 <simcity2000> jle`: I'm reading it now, and he seems to have skirted around that exact issue
22:29:16 <simcity2000> it looks like there's a findPeers function somewhere...but what it does is a mystery.
22:30:25 <simcity2000> everything else clicks, it's just a matter of actually connecting to peers and kicking work over to them
22:31:13 <jle`> hm darn
22:31:37 <simcity2000> I'm looking to get more into distributed stuff and Go/Haskell both seem like interesting choices for that
22:31:58 <simcity2000> having already started my way into it with Go, I thought I'd play catch-up and see where I get
22:32:34 <Lutin`> simcity2000: Are you talking about the 'Towards Haskell in the Cloud' paper
22:32:51 <jle`> simcity2000: :(  sorry, wish i could help
22:33:01 <simcity2000> Lutin`: nope, I'm talking about chapter 14 of Parallel and Concurrent Programming in Haskell
22:33:15 <Lutin`> Maybe check out http://research.microsoft.com/en-us/um/people/simonpj/papers/parallel/remote.pdf
22:33:16 <simcity2000> I saw word that the API in the paper doesn't quite match the implementation
22:33:21 <jle`> hm
22:33:29 <jle`> i have been meaning to get into distributed programming
22:33:38 <Lutin`> But yeah the API has changed since
22:33:52 <Lutin`> and it doesn't look like hackage has docs for 0.5.0
22:34:03 <enthropy> startling: the package called "ghc" is the ghc-api
22:34:10 <startling> enthropy: ah, I see
22:34:24 <enthropy> you shouldn't break it
22:34:25 <startling> I don't suppose I can tell cabal to rebuild it?
22:34:32 <startling> (after reinstalling new things?)
22:34:36 <Lutin`> simcity2000: What about http://haskell-distributed.github.io/tutorials/1ch.html
22:35:34 <simcity2000> Lutin`: same issue, all of the examples focus on spawning a local node (or nodes) and firing stuff at those
22:35:40 <dmj`> simcity2000: whats your use case?
22:35:57 <Lutin`> dmj`: backtick brother!
22:36:08 <simcity2000> dmj`: remote execution of processes on worker nodes, but for now I just want to ping a remote worker
22:36:09 <simcity2000> haha
22:36:35 <dmj`> Lutin` jle`: starting a trend
22:36:37 <enthropy> startling: I've never built it (aside from when building ghc itself)
22:36:48 <startling> Can I say "cabal install the dependencies for this package, upgrading them if possible but unless it would break ghc-7.6.3"?
22:37:23 <startling> ooh, --constraint?
22:37:55 <enthropy> probably it's easiest to add those to the ~/.cabal/config file
22:38:04 <dmj`> simcity2000: what task do the worker nodes accomplish?
22:38:09 <enthropy> constraint: containers installed
22:38:37 <startling> enthropy: sorry?
22:38:57 <enthropy> startling: you can add a line like that to ~/.cabal/config
22:39:10 <enthropy> which is easier than remembering to add --constraint="containers installed"
22:39:33 <startling> is "containers installed" a magic string or a metavariable?
22:39:36 <simcity2000> dmj`: depends. the idea in general is to be able to launch a process and get some kind of output streamed back, preferably over a channel
22:40:23 <enthropy> you can actually type that
22:40:25 <simcity2000> but the thing I'm after is (I believe) fairly narrow--I'm just playing around and need a way to actually find who I'm able to connect to
22:40:40 <enthropy> instead of --constraint="containers == 0.5.5.1"
22:40:47 <startling> enthropy: oh, I see.
22:41:00 <startling> can I say "ghc installed" instead?
22:41:19 <dmj`> simcity2000: makes sense
22:41:48 <simcity2000> dmj`: I think I've got an idea of how to do this pieced together
22:41:49 <enthropy> well the problem seems to be that cabal decided to upgrade one of the packages that the ghc api package depends on
22:41:50 <Lutin`> simcity2000: You could look at the benchmarks in the git repo
22:41:53 <Lutin`> They might help
22:42:07 <startling> enthropy: oh, and the constraint won't prevent that? blegh
22:42:21 <simcity2000> it's funny, everything else is very well-detailed and clear except for the part where I actually need to connect to other machines
22:42:32 <simcity2000> well-documented, rather
22:42:33 <dmj`> simcity: you could just start simple with network, then add features like parsing and streaming
22:42:53 <simcity2000> dmj`: yeah, I'll likely do that, just as soon as I know how to get to the peers :P
22:43:06 <simcity2000> it's (I hope) a fairly dull question
22:44:03 <dmj`> simcity2000: connectTo :: HostName -> PortID -> IO Handle
22:44:06 <startling> can I get a list of what packages 'ghc' requires?
22:44:27 <enthropy> startling: ghc-pkg describe ghc
22:44:42 <startling> that's a lot. :(
22:44:51 <simcity2000> dmj`: does that play nice with the cloud haskell packages?
22:44:55 <simcity2000> (if so, great)
22:45:03 <Lutin`> simcity2000: Join #haskell-distributed
22:45:05 <startling> it looks like template-haskell is the one that wants to upgrade things, hm
22:45:11 <simcity2000> there we go
22:45:48 <enthropy> you can't realistically upgrade template-haskell
22:46:09 <startling> It's too bad cabal doesn't know that. :x
22:46:17 <dmj`> simcity2000: I say start with the fundamentals and work your way up
22:46:31 <startling> that seems like the best solution, then.
22:46:34 <startling> enthropy: thanks!
22:47:12 <Fuuzetsu> > typeOf (5 :: Int)
22:47:14 <lambdabot>  Int
22:48:07 <Fuuzetsu> :t TypeRep
22:48:07 <lambdabot> Not in scope: data constructor ‘TypeRep’
22:48:38 <enthropy> startling: looks like cabal people changed their minds https://github.com/haskell/cabal/issues/667
22:48:42 <simcity2000> dmj`: that's totally fair, this is more of a curiosity than anything else
22:49:15 <startling> enthropy: oh, interesting
22:49:20 <startling> I wonder if upgrading cabal will fix it for me.
22:49:22 <simcity2000> I'm familiar with how to do these sorts of things in Go, but I'm curious about Haskell's capabilities too
22:49:56 * hackagebot eros 0.1.0.0 - A text censorship library.  http://hackage.haskell.org/package/eros-0.1.0.0 (pharpend)
22:50:11 <kazagistar> > typeOf typeOf
22:50:13 <lambdabot>  No instance for (Data.Typeable.Internal.Typeable a0)
22:50:13 <lambdabot>    arising from a use of ‘Data.Typeable.Internal.typeOf’
22:50:13 <lambdabot>  The type variable ‘a0’ is ambiguous
22:50:13 <lambdabot>  Note: there are several potential instances:
22:50:13 <lambdabot>    instance Data.Typeable.Internal.Typeable Data.Dynamic.Dynamic
22:50:32 <enthropy> startling: I dunno. Probably it's best to stick with the Cabal that ghc comes with
22:50:40 <startling> heh.
22:51:14 <ivanm> Clint: my graphviz package?
22:51:16 <enthropy> otherwise you end up with lots of "please re-run cabal configure: had Cabal-1.18 now Cabal-1.20"
22:51:32 <startling> enthropy: that's fine
22:54:23 <Fuuzetsu> startling: you're never meant to install ghc package yourself AFAIK
22:54:42 <startling> Fuuzetsu, yeah, I know. I just want to stop automatically breaking it. :(
22:54:51 <Fuuzetsu> how did you break it
22:54:56 <Fuuzetsu> and why aren't you using nix yet ;)
22:57:29 <startling> I broke it with --upgrade-dependencies (since we cache dependencies and this is usually a Nice Thing).
22:57:43 <startling> you know, in sane languages like Ruby. ;)
22:59:57 * hackagebot ComonadSheet 0.3.0.0 - A library for expressing spreadsheet-like computations as the fixed-points of comonads.  http://hackage.haskell.org/package/ComonadSheet-0.3.0.0 (kwf)
23:02:03 <Lutin`> Fuuzetsu: You use Nix?
23:02:38 <Fuuzetsu> Lutin`: sure
23:02:46 <Lutin`> What OS?
23:03:21 <Fuuzetsu> NixOS
23:03:56 <Lutin`> How's the space usage?
23:04:00 <simcity2000> Lutin`: looks like it was just a matter of finding the documentation for Simplelocalnet.
23:04:01 <zq> nixos is an os now
23:04:26 <simcity2000> that said, is there any way to actually get to the package docs from the little info page in hackage?
23:04:32 <Fuuzetsu> Lutin`: not as terrible as I thought it would be as long as you garbage collect sometimes
23:04:39 <Fuuzetsu> my / is 50GB
23:04:47 <Lutin`> Hmm
23:04:49 <Lutin`> I could do that
23:04:56 <Lutin`> I might just try it on a VM first
23:05:07 <Lutin`> Get everything setup then copy over the config
23:05:22 <Lutin`> I'd be hard to leave Arch though :(
23:05:23 <barrucadu> 50GB? I've not used NixOS, but that seems pretty huge
23:05:45 <Fuuzetsu> barrucadu: that's how much I allocate, I"m not using all that
23:05:51 <barrucadu> Ah, right
23:05:53 <platz> where does it put binaries that you compile from source yourself?
23:06:00 <Fuuzetsu> using 37GB atm but if I garbage collect it will probably go to 25 or so
23:06:23 <platz> or do you have to package everything yourself
23:06:32 <Fuuzetsu> platz: depends how you build it
23:06:41 <Fuuzetsu> everything?
23:06:53 <Fuuzetsu> I admit there was quite a bit of software I had to package when I switched but now I'm pretty much set
23:07:06 <mzero> platz: which OS?
23:07:18 <platz> nixos
23:07:21 <dmj`> Fuuzetsu: what is 7.8 support like w/ nixpkgs
23:07:56 <Fuuzetsu> you don't get pre-built binaries yet but other than that it's no problem
23:08:10 <Fuuzetsu> honestly I've been meaning to write up my experience a bit
23:08:12 <platz> I've gotten in the habi of 'checkinstall' on linux anyway, hopefully it's not tha tmuch harder
23:08:19 <mzero> built w/cabal? then dist/build/Foo/foo
23:08:37 <dmj`> Fuuzetsu: I'd love to read your experience with it, ocharles had a good writeup on it too
23:08:56 <Fuuzetsu> I refered to his blog post like 50 times in my first few days
23:08:56 <mzero> (though it dawns on me I might be missing the context!)
23:09:00 <mzero> :-P
23:09:04 <dmj`> lol
23:12:20 <Lutin`> I wonder how well Nix works on Arch
23:12:49 <augur_> mzero: :o
23:12:52 <augur_> can i bug you some more?
23:13:08 <mzero> sure
23:13:44 <Lutin`> Time for bed
23:13:47 <Lutin`> night guys
23:13:48 <Fuuzetsu> gn
23:13:57 <simcity2000> nighto
23:13:59 <Lutin`> and gals
23:17:42 <augur_> mzero: do you know how to consume non-newline whitespace?
23:18:05 <augur_> my token function is reading newlines as white space which is not so good when newlines are significant
23:18:31 <chrisdotcode> is there any way to install dependencies into a sandbox if they're already installed locally on your system?
23:18:51 <mzero> skipmany (oneOf " \t")
23:18:57 <augur_> ahh ok
23:19:01 <mzero> or whatever you want to define whitespace as
23:19:11 <augur_> that makes sense
23:19:20 <chrisdotcode> like, if I'm off-line and need data.text, ccan I install it from my global installation of it?
23:21:05 <mzero> chrisdotcode: you can try adding --package-db=clear -package-db=global    which should disable your user pkg-db... but you can't really get around things that are in the global one
23:21:20 <mzero> though I suppose you coul duse ghc-pkg to hide them?
23:21:46 <augur_> mzero: ok so here is my mystery: http://lpaste.net/106415
23:23:36 <chrisdotcode> mzero: okay, so let's say I did a 'cabal install text'. now, I'm offline with no hackage. if i make a sandbox, and include text as a dependency while offline, will it install the version I havee on my machine/
23:23:39 <chrisdotcode> *?
23:23:55 <mzero> no
23:24:24 <mzero> but if you have one on your machine, why are you installing it in the sandbox?
23:26:59 <chrisdotcode> mzero: don't you have to? if i include it as a dep in the sandboxed rep,and do a cabal instal, won't it install from hackage/
23:27:05 <chrisdotcode> *?
23:27:32 <mzero> not if it is in your global pkg-db
23:27:58 <mzero> even with sandbox, it always uses the global pkg-db
23:28:52 <mzero> augur_: are you importing Text.Parsec or Text.ParserCombinators.Parsec ?
23:29:02 <augur_> the latter
23:29:05 <chrisdotcode> and so you said to do that, i should do package-db=global?
23:29:16 <mzero> that's the older API -- use the former....
23:29:20 <augur_> ok
23:30:10 <mzero> but that's not the problem...
23:33:06 <augur_> mzero: well now i dont know what my parser type should me :X
23:33:22 <mzero> Parsec Char st
23:33:46 <augur_> what about the type of the returned value?
23:33:57 <mzero> er
23:34:00 <mzero> Parsec String st
23:34:12 <mzero> well, yeah
23:34:13 <augur_> ?
23:34:17 <mzero> pWord :: Parsec String st String
23:34:22 <augur_> ok
23:34:59 <mzero> if you pull all your parsers to top level (hence the renamed   pWord )   then you can use   parseText pWord "bob"
23:35:02 <mzero> to test 'em in ghci
23:35:59 <augur_> well, i just run it in textmate
23:37:01 <augur_> ok, converted to Text.Parsec
23:37:03 <augur_> now what :x
23:37:34 <mzero> well, you can do what I said and experiment with it in ghci - which is much faster than running your main
23:37:42 <mzero> because you can try out bits of your parser
23:37:47 <mzero> at present I'm a little surprised
23:37:53 <mzero> not sure why it isn't working
23:37:55 <augur_> the bits work fine
23:38:03 <mzero> not quite
23:38:05 <augur_> line works correctly
23:38:29 <augur_> and lines works fine as long as its one line
23:38:35 <mzero> if you expect "foo bar " not to parse, then yes
23:38:52 <augur_> yes
23:39:14 <augur_> i suppose for each line i can consume to the end
23:39:51 <mzero> well...
23:39:58 <mzero> I suspect you want endBy in lines, not sepBy
23:40:06 <SparkySparkyBoom> anyone know what might cause this error?
23:40:12 <mzero> sepBy -- if it parses the separator is going to insist on another item
23:40:14 <augur_> mzero: ok
23:40:17 <SparkySparkyBoom> Not in scope: ‘hPrintf’
23:40:20 <SparkySparkyBoom>     Perhaps you meant ‘hPrint’ (imported from System.IO)
23:40:32 <SparkySparkyBoom> ive imported System.IO
23:40:53 <mzero> OH
23:40:54 <mzero> augur_:
23:40:59 <augur_> O_O
23:41:00 <SparkySparkyBoom> ah nvm
23:41:14 <mzero> spaces >> newline >> spaces
23:41:20 <mzero> the first spaces eats the newline
23:41:28 <mzero> the newline is like "hey, where's MY newline?"
23:41:40 <augur_> i see. so its not going to backtrack appropriately with that
23:41:48 <mzero> no
23:42:00 <augur_> ok
23:42:13 <mzero> there is no backtracking in parsec if any input is consumed.... unless you use try
23:42:18 <mzero> now, it is tempting to use try all over
23:42:20 <augur_> i see. ok
23:42:30 <mzero> but that is expensive in time and space - which is why it isn't the default
23:42:52 <mzero> here, you need to factor the terminal condition better
23:43:09 <DanC_> I'm struggling to turn a Future (List X) into a Future IO ()
23:43:31 <DanC_> assuming show X, the IO should be to puts each X
23:44:33 <mzero> blank = oneOf " \t"   ;     blanks = many blank     ;        pLines = pLine `endBy` (blanks >> newline)
23:48:10 <augur_> mzero: im not following
23:48:59 <mzero> your BNF is         (space | tab | nl)* nl (space | tab | nl)*
23:49:24 <mzero> but the first (...)* is eating the only nl, there is no back tracking (since it ate something), so the nl fails
23:49:32 <mzero> you need to "refactor" the BNF
23:49:49 <mzero>      (space | tab)* nl (space | tabl | nl)*
23:49:50 <augur_> mzero: yeah, sure, change it to   (space | tab)* nl (space | tab | nl)*
23:49:58 <mzero> right
23:50:00 <mzero> so?
23:50:04 <mzero> what's not to follow/
23:50:08 <mzero> :-)
23:50:33 <augur_> should i have lines be sepBy or endBy??
23:52:42 <augur_> ahh
23:52:51 <mzero> well....
23:53:03 <mzero> you might want   sepEndBy    !
23:53:23 <mzero> does the last line require a newline?
23:53:38 <augur_> no
23:53:39 <jle`> hm
23:53:45 <mzero> then sepEndBy
23:53:52 <jle`> is a DeriveFunctor instance guarunteed to be the uniquely lawful Functor instance for a given type?
23:55:01 <augur_> mzero: 0.0
23:55:52 <augur_> mzero: it also seems like ending the lines by blanks is good too
23:56:06 <augur_> and starting the line separators with \n rather than blanks
23:56:17 <mzero> well - what do you want to happen with blank lines?
23:56:38 <augur_> they should just be like newlines
23:56:57 <mzero> (I'm assuming all this is just a learning exercise..... that you do know about prelude functions lines and words)
23:57:11 <augur_> yes, i know about lines and words :p
23:57:42 <mzero> does    "foo\n\nbar"    yeild  [["foo"],[],["bar"]]   or  [["foo"],["bar"]]
23:57:54 <augur_> im working towards figuring out how to parse source code like haskell source
23:58:02 <augur_> mzero: the latter
23:58:14 <ivanm> is what I'm wanting to do here possible/feasible? http://lpaste.net/106416
