00:00:22 <mzero> okay then.... yes, include eating up extra spaces after the newline
00:01:39 <augur_> it seems like it should be   line = word `endBy1` many blank    and    lines = line `sepEndBy (newline >> spaces)
00:03:28 <mzero>     line = balnks *> word `sepEndBy` many1 blank
00:03:33 <mzero> that would be my choice
00:03:51 <mzero> then      lines = line `sepEndBy` newline
00:03:57 <augur_> many1 blank?
00:04:19 <mzero> if you separate by a parser that matches the empty string... it always matches, eh?
00:04:45 <augur_> oh wait, its an optional end
00:04:46 <augur_> grr
00:04:49 <augur_> the name of that is awful
00:05:13 <augur_> same for many
00:05:20 <augur_> "many" in english does not mean "any number"
00:05:24 <augur_> it means multiple
00:05:30 <augur_> it should be any many not many many1
00:05:31 <augur_> :\
00:06:45 <kazagistar> augur_: many1 makes sense in haskellesse, because "at least one" functions tend to universally end with 1
00:07:11 <augur_> kazagistar: true
00:07:17 <augur_> doesnt mean its not confusing :P
00:07:42 <kazagistar> augur_: in some places, they use "some" for 1 or more which is worse
00:07:50 <augur_> why?
00:08:18 <kazagistar> cause it is inconsistant with the naming scheme?
00:08:26 <augur_> i suppose
00:09:23 <kazagistar> for example, foldl vs foldl1
00:10:33 <augur_> yes yes
00:10:57 <AshyIsMe> is there a way to do pattern matching on a list of ByteStrings while ignoring ordering?  https://github.com/AshyIsMe/snaplet-redis/blob/master/src/Snap/Snaplet/Auth/Backends/Redis.hs#L200-L220
00:11:20 <AshyIsMe> that is currently broken because it's expecting the keys to be in that specific order
00:11:21 <augur_> mzero: it seems easier to just break by \n, and then filter out empty lines, rather than try to parse multiple space-separated \n's as a single newline
00:11:32 <ivanm> AshyIsMe: sort them first?
00:11:41 <mzero> I agree
00:11:56 <Fuuzetsu> use a map and lookup
00:11:59 <AshyIsMe> ivanm: ah of course, cheers
00:14:46 <kazagistar> augur_: what would you prefer the many option that excludes 0 be called?
00:14:57 <kazagistar> or rather I mean the one that allows zero
00:15:18 <augur_> kazagistar: many ~> any, many1 ~> many (or some)
00:17:34 <kazagistar> augur_: any is a prelude function
00:17:38 <kazagistar> :t any
00:17:39 <lambdabot> (a -> Bool) -> [a] -> Bool
00:17:41 <augur_> yes i know
00:18:01 <kazagistar> so, where would you move any? I am curious
00:18:06 <augur_> i wouldnt
00:18:30 <kazagistar> just force hiding of prelude any?
00:18:44 <augur_> yes
00:19:33 <kazagistar> hmm, that seems less good to me personally
00:20:11 * augur_ shrugs
00:20:13 <kazagistar> personally, I just tend to not make too many assumptions about meanings until I learn the implementations, and it works out pretty well
00:20:39 <hunt> i think the only reasonm people complain about monads being complex is because everyone talks about monads like y ou need to understand them
00:20:44 <hunt> if people didnt say the word monad ata ll
00:21:00 <hunt> and instead demod the (>>) (>>=) and (return) operators
00:21:02 <augur_> i generally frown upon using english-word names in a way the conflicts with the english word's meaning substantially
00:21:07 <hunt> and explained that those were used in do blocks
00:21:16 <augur_> in the case of "many", it is definitely contradictory
00:21:24 <hunt> then there would be no misunderstanding
00:21:25 <kazagistar> I think there are worse naming problems
00:21:47 <hunt> augur_: yea but its ok beczuse many is used consistently accross all libs
00:22:21 <hunt> augur_: haskell return has nothing to do with the word return, its only linked because of its usage in traditional programming
00:22:42 <kazagistar> and pure is even worse in the "directly opposite meaning" department :PO
00:23:17 <hunt> kazagistar: pure kind of makes sense because youre purely bringing a value into an applicative, youre not operating on anything or doing anything weird
00:23:29 <hunt> kazagistar: the result of pure is a  plain unaltered pure applicative containing the data
00:24:12 <hunt> anyways what do you guys think of my monad teaching proposal
00:24:23 <hunt> that we start from the bottom up and maybe dont even mention the word monad
00:24:29 <hunt> instead of starting with monad and deconstructing it
00:25:11 <kazagistar> hunt: I think "monads by examples" works pretty effectively, you dont have to actively avoid it
00:25:27 <simcity2000> hunt: starting from the top down is rarely a good idea, so it doesn't sound so bad to me
00:25:42 <simcity2000> a lot of Haskell education has the same feel as new math textbooks for elementary school students
00:26:06 <simcity2000> new math as in the programs from the 60s meant to teach 8 year olds set theory, not contemporary math books
00:26:12 <hunt> kazagistar: maybe, i know the reason i didnt learn monads for a while is because people made them out to be cryptic and complex from the get-go, and everyone talks about how hard they are to learn. i just thought that i didnt need to waste my time learning it yet because i had other more basic things i had to do
00:26:13 <kazagistar> start with maybe, and implemet a cool bind "pattern" on it, then go to list, then reader, then IO, then monads in general
00:26:14 <vlabs> okay, I got toml to work by doing this. 1) cabal sandbox in init /my/project 2)cabal sandbox init --sandbox=../rel/path/to/my/project/.sandbox 3) cabal install 4) cabal build 5) cabal register 6)cabal install (in some order like that), and then 7) going to /my/project, 8)cabbal build 9) cabal run
00:26:18 <vlabs> how insane was what I did?
00:26:53 <hunt> kazagistar: i mean its pretty obvious how uiseful a sequence operator is, and if you can show that the changes are being made to the m of m a instead of to the a, its not a big leap before the people fully understand monads
00:26:55 <kazagistar> ... of course, what I descrbed exists and was how I learned it
00:27:23 <hunt> kazagistar: i really got it when i saw do desugaring
00:27:49 <hunt> kazagistar: i also think its better to disentangle understanding from specific instances  like maybe or lists
00:27:56 <hunt> kazagistar: although those totally helped me get it too
00:28:06 <kazagistar> I basically learned do notations notation after monads, I was kinda scared of it before then
00:28:45 <hunt> kazagistar: i was kinda scared of do notation too i suppose, although i was way more afraid of monads. do notation really connected the dots for me
00:28:54 <kazagistar> sure, its good to disentangle it from instances, but personally I tend to go from specific to general
00:29:17 <hunt> kazagistar: i think i was just maybe brought up being tought concepts and then shown their uses
00:29:23 <hunt> Just Maybe
00:29:33 <vlabs> why does the Setup.hs exist if I was able to get this up and running without using Setup.hs?
00:29:44 <vlabs> I'm confused about the relationship between cabal and the Setup.hs
00:30:12 <hunt> vlabs: i dont really understand cabal either but id guess that cabal compiles and runs Setup.hs, or at least uses it to help build
00:30:28 <vlabs> hunt: huh, I see
00:30:35 <hunt> vlabs: that might also be a hackage thing? it seems too common in packages to be written by the authors
00:31:13 <vlabs> hunt: It generated a setup.hs when I used cabal init. I don't know what's up with that :|
00:31:51 <hunt> vlabs: from google it looks like its definitely involved in cabal, http://www.haskell.org/cabal/users-guide/#whats-in-a-package
00:31:59 <vlabs> hunt: thanks
00:32:01 <hunt> vlabs: check out the "full details" link
00:32:10 <hunt> vlabs: np
00:33:23 <hunt> vlabs: http://www.haskell.org/cabal/users-guide/developing-packages.html#creating-a-package
00:33:38 <hunt> vlabs: looks like this is where cabal specifices your build dependencies, as well as your main module
00:33:47 <kazagistar> (1) do the first three instances with different names for bind (maybe, list, reader) (2) point out the pattern and abstract it with the name monad (3) show the IO instance (4) show do notation (5) transformers ...?
00:34:15 <hunt> kazagistar: whats the question?
00:34:26 <kazagistar> naw, its just a proposal for order
00:34:28 <vlabs> hunt: hm
00:34:35 <hunt> kazagistar: ah for teaching
00:35:02 <kazagistar> yeah, and the transformers is cause I am not as sure of the order to introduce those concepts
00:35:57 <kazagistar> there should also be a step (0) which is demoing a much simpler but still interesting typeclass like Functor or Monoid to warm people up to typeclasses
00:36:04 <kazagistar> in that sense
00:36:52 <hunt> kazagistar: (1) Understand basic Haskell (function usage and ADTs) (2) Understand functors (3) demo functors with additional data (4) operator to move between two different functors and affect the data (>>) (5) (>>=) (6) demonstrate popular usages [lists,maybe] (7) desugar do (8) call it a monad
00:37:03 <hunt> kazagistar: im not sure how well this lines up with your stuff but this is the route id take
00:41:05 <Welkin> getting emacs with haskell-mode set up on mac is pretty painful
00:41:14 <hunt> Welkin: (vim)
00:41:24 <Welkin> I use emacs
00:41:34 <Welkin> I finally got it set up and it is great now
00:41:47 <hunt> Welkin: wonderful, its pretty rough in vim too
00:41:52 <hunt> Welkin: but featureless
00:43:05 <platz> I was bullish on emacs for haskell until I found neco-ghc for autocompletion.  But I would go back if only the com-int repl allowed tab completion of bindings
00:45:08 <AshyIsMe> Fuuzetsu: map and lookup was much nicer, cheers
00:45:26 <dbu> what about yi?
00:45:34 <AshyIsMe> platz: you work in finance?
00:45:48 <platz> ahihi: hah, I wish
00:46:17 <dbu> eh, i don't wish to return to finance. maybe 50% more pay tahn consumer jnet stuff , but w/o IPO potential-upside
00:46:19 <kazagistar> hunt: functors with additional data?
00:46:27 <platz> Probably make more but they'd probably make we wear a pager or something
00:46:57 <hunt> kazagistar: i actually retract that step, just show them Maybe
00:47:13 <dbu> platz: did you try http://www.haskell.org/haskellwiki/Yi
00:47:36 <AshyIsMe> i'd like to get into trading
00:48:19 <kazagistar> hunt: were you thinking a conjunction or disjunction of additional data? or either of those?
00:48:38 <levi> dbu: I've played with yi before, but haven't felt compelled to use it much.
00:49:25 <hunt> kazagistar: not sure what those options mean, i was imagining some kind of functor T a = T a Int String ...
00:49:30 <Abathurr> easy noob question here
00:49:33 <platz> dbu: no but it looks nice
00:49:37 <Abathurr> what does => mean in a type declaration
00:49:39 <hunt> kazagistar: and sequentially altering the other structuresa
00:50:16 <levi> Abathurr: It means there are type class constraints on the type
00:50:37 <levi> Abathurr: The constraints are the things to the left of the =>
00:50:43 <zRecursive> Abathurr: context
00:50:51 <AshyIsMe> vim is pretty nice for haskell with ghc-mod and syntastic
00:50:54 <Abathurr> levi: Thanks!
00:51:01 <kazagistar> hunt: sorry, they are unnecessarily mathy words, conjunction is like "and" (like either), disjunction is like "or" (tuple)
00:51:01 <AshyIsMe> and codex
00:53:03 <hunt> AshyIsMe: what is codex? i use vim
00:53:31 <levi> Without constraints, a type variable is "parametric", meaning that the function can't observe anything about or act differently according to the type of that parameter. A type class constraint provides a limited view into the value based on the class methods.
00:53:35 <kazagistar> Abathurr: for example { (Num a, Ord a) => a -> a } would read as "a function from a to a, given that a is numeric and orderable"
00:54:46 <levi> Normally, parametricity says that the only possible (reasonable, anyway) implementation for a signature "a -> a" is the identity function. It can't examine the value at all, so all it can do is return it.
00:55:18 <ienh> new to haskell and cabal, could anyone help me resolve this: https://gist.github.com/anonymous/a6bbb2f5a60aff7f70a1
00:56:02 <levi> Adding the Num and Ord classes as constraints means that you can perform any Num or Ord methods on the parameter, but that's all.
00:57:19 <Abathurr> levi: Oh, thanks! Is Haskell smart enough to try to assign a type to something if you dont supply constraints though? Like if I just feed in a 5 or something to a function without explicitly declaring constraints
00:58:13 <levi> Abathurr: If a function is parametric, you can give it a value of *any* type.
00:59:14 <levi> Abathurr: If you haven't explicitly given your function a type signature and you do some operation that would require a Num constraint, it will automatically infer that Num constraint on the function's type.
00:59:26 <Abathurr> levi: Hmm. Let me clarify. I mean if I create a parametric function, and give it an integer, is it smart enough to know that it can perform numeric operations on that number
00:59:34 <Abathurr> levi: oops
00:59:40 <Abathurr> levi: You just read my mind
01:00:05 <levi> However, if you provide a type signature and you do something that would violate it, it will tell you so.
01:00:38 <kazagistar> Abathurr: it does not really care what you pass in, what it notices is that you use + inside the function (for example), and adds a Num constraint to its own infered type
01:01:10 <kazagistar> Abathurr: then if you pass Integer in, it checks if it satisfies the constraint (it does) and will typecheck successfully
01:02:13 <kazagistar> @let f x y z = if x > y then x + z else y - z
01:02:15 <lambdabot>  Defined.
01:02:17 <Abathurr> kazagistar: Okay, so what if I created this imaginary parametric function, which just adds two numbers...but I pass it a String? How does it know the + means something different
01:02:20 <kazagistar> :t f
01:02:21 <lambdabot>     Ambiguous occurrence ‘f’
01:02:21 <lambdabot>     It could refer to either ‘L.f’,
01:02:21 <lambdabot>                              defined at /home/lambda/.lambdabot/State/L.hs:150:1
01:02:26 <kazagistar> er
01:02:29 <kazagistar> :t L.f
01:02:30 <lambdabot> (Ord a, Num a) => a -> a -> a -> a
01:02:41 <corgifex> @undefine
01:02:41 <lambdabot> Undefined.
01:03:39 <corgifex> Abathurr: I don't understand that question
01:03:49 <kazagistar> Abathurr: + is only defined for things that are instances of Num, which string is not, so it would give an error
01:03:52 <corgifex> (+) is a function like that
01:03:56 <corgifex> it adds two numbers
01:04:00 <corgifex> if you pass it a string, you get an error
01:04:08 <levi> Abathurr: If it adds two numbers, it's not *paramteric*, because it must know that the parameters are numbers
01:04:11 <zRecursive> > f "a" "b" "c"
01:04:13 <lambdabot>  No instance for (GHC.Show.Show a0)
01:04:13 <lambdabot>    arising from a use of ‘M163613006716531424110735.show_M1636130067165314241...
01:04:13 <lambdabot>  The type variable ‘a0’ is ambiguous
01:04:13 <lambdabot>  Note: there are several potential instances:
01:04:13 <lambdabot>    instance [safe] GHC.Show.Show
01:04:21 <corgifex> > "a" + "b"
01:04:22 <lambdabot>  No instance for (GHC.Num.Num [GHC.Types.Char])
01:04:22 <lambdabot>    arising from a use of ‘GHC.Num.+’
01:04:30 <corgifex> [Char] is String
01:04:49 <kazagistar> Abathurr: but, if theoretically + was defined for Strings, then it would pick the right implementation according to the type
01:05:06 <Abathurr> levi: Well, what I mean is, say the function just takes an a and b and returns a+b. Say I don't define what a or b is.
01:05:28 <levi> :t (+)
01:05:28 <zRecursive> :t (+)
01:05:29 <lambdabot> Num a => a -> a -> a
01:05:29 <lambdabot> Num a => a -> a -> a
01:05:32 <Abathurr> levi: What I interpreted kazagistar as saying is that it will look at a and b and infer the types based on the +
01:05:42 <Abathurr> levi: But what if a and b are...chars for instance
01:05:58 <kazagistar> Abathurr: you interpreted wrong, let me try again
01:05:59 <levi> Then you are writing nonsense, not a valid expression.
01:06:12 <corgifex> Abathurr: (+) is that function
01:06:18 <corgifex> > 'a' + 'b'
01:06:19 <lambdabot>  No instance for (GHC.Num.Num GHC.Types.Char)
01:06:19 <lambdabot>    arising from a use of ‘GHC.Num.+’
01:06:21 <corgifex> this is what happens
01:06:47 <zRecursive> sure, no instance found
01:07:07 <hunt> did anyone get neco-ghc to work?
01:07:11 <hunt> i have no idea what to do with it
01:07:24 <hunt>  i installed it with pathogen i think but then what?
01:07:29 <kazagistar> Abathurr: it does not inspect the types passed in to the function until later. First, it looks at the function itself, and figures out that since (+) requires two Num types, it needs that constraint on the function parameters. Then, when it typechecks the function call itself, it verifies that what you are passing is infact an instance of Num
01:07:53 <Abathurr> kazagistar: Aaaah. Much clearer.
01:08:23 <Abathurr> kazagistar: Is there a way, like in an imperative language, to overload a + operator so it could be used to concatenate chars?
01:08:59 <kazagistar> Abathurr: sure, you can implement the Num typeclass for Char, though doing so might be crazy
01:09:32 <Abathurr> kazagistar: I'm beginning to like this language.
01:10:10 <corgifex> "like in an imperative language" o_O
01:10:29 <Abathurr> ?
01:10:30 <levi> In general, you should probably not "overload" operations for types that don't satisfy the normal meaning of those operations.
01:10:32 <mmmm> When is it worth to use the writer monad? (I'm writing a compiler from an AST)
01:10:55 <augur> Abathurr: you shouldnt do that
01:10:57 <corgifex> C doesn't even have operator overloading
01:11:05 <kazagistar> Abathurr: you can think of typeclasses (at first) a little like interfaces, except you can provide implementations anywhere instead of being confined to the same module as the datatype
01:11:10 <corgifex> does Java allow 'a' + 'b'?
01:11:33 <corgifex> PHP would probably turn 'a' + 'b' into 0
01:11:38 <Abathurr> corgifex: Java allows concatenation with +
01:11:41 <levi> Haskell provides ++ for concatenating strings.
01:11:45 <augur> Abathurr: (+) is for numeric addition, not for concatenation
01:11:46 <corgifex> Abathurr: on chars?
01:12:10 <Abathurr> corgifex: On Strings. It's still an overloaded operator is my point.
01:12:12 <zRecursive> > ord 'a'
01:12:13 <lambdabot>  97
01:12:14 <zwer> @let instance Num Char where { x + y = chr (ord x + ord y); x - y = chr (ord x - ord y); x * y = chr (ord x * ord y); abs = id; signum x = chr (signum (ord x)); fromInteger = chr . fromIntegral }
01:12:15 <lambdabot>  Defined.
01:12:19 <zwer> > 'a' + 1
01:12:21 <lambdabot>  'b'
01:12:23 <corgifex> Abathurr: but you can't overload it
01:12:26 <kazagistar> Abathurr: (+) could not concatenate chars into a string, because that would not match the definition of (+)
01:12:42 <zRecursive> can turn 'a' + 'b' into (ord a + ord b) ?
01:12:55 <Abathurr> I have too many conversations going on here and I'm not sure to whom I should be responding
01:13:11 <kazagistar> Abathurr: any, we can thread :D
01:13:22 <levi> Abathurr: The point of type classes is to provide a principled way to "overload" operations, but using them to conflate appending of strings with numeric addition is not a good idea.
01:13:42 <Abathurr> levi: Okay, understood.
01:13:56 <Abathurr> I'm simply trying to understand this language in the context of things I've seen before
01:14:08 <Abathurr> I have no intention of actually doing that
01:14:10 <kazagistar> Abathurr: if you want to conflate those ideas, you can use Monoid, but that might be moving too fast haha
01:14:21 <augur> Abathurr: to extent what levi said, type classes are supposed to represent a "common concept" that manifests in different ways for different types
01:14:24 <Abathurr> kazagistar: Yeah, I have no idea what those are heh.
01:14:30 <augur> Abathurr: addition and concatenation are not the same concept
01:14:54 <kazagistar> (though they are both monoids)
01:14:59 <levi> They're meant to provide families of types that are "the same" in some way, such as being numbers or having a well-defined ordering, or being comparable for equality.
01:15:04 <augur> kazagistar: yes, but thats a different concept.
01:15:21 <kazagistar> yeah, sorry, I'm done with that right now
01:15:56 <augur> Abathurr: its the same in an OO language, for instance
01:16:09 <augur> Abathurr: when numbers have a + method, it comes from some generic number class
01:16:21 <augur> Abathurr: if strings have a + method too, it is MERELY COINCIDENCE that it has this name
01:16:21 <zwer> @undefine
01:16:21 <lambdabot> Undefined.
01:17:11 <augur> so, you can in principle define your own class `Concatenable` with a method (+) but it wont be the same (+) as for numbers, and moreover there will be an ambiguity that youll have to deal with
01:17:26 <zRecursive> in OO, we can redifine "+" for diferent class/type
01:17:37 <kazagistar> so, Num basically means "has a (+), (*), abs, signum, fromInteger, and negate defined", but there are also certain rules and concepts that you really really should obey to keep things sensible
01:17:45 <augur> right, in OO you have some amount of type-directed name resolution
01:17:48 <augur> not so in haskell
01:18:41 <augur> actually its often not even resolution, it's just straight up dynamic dispatch
01:19:25 <Abathurr> Okay so this next question will most likely belie my inability to understand the typeclass idea...but I have to ask anyway
01:20:03 <Abathurr> When do you say "these too concepts are too dissimilar to be part of the same typeclass" rather than just "different implementations of the same thing"
01:20:36 <corgifex> intuition
01:20:42 <augur> no not intuition
01:21:08 <corgifex> no u
01:21:11 <augur> Abathurr: the Num type class has a fairly well-defined notion behind it: it represents types that support addition, subtraction, etc
01:21:19 <augur> basic arithmetic operations
01:21:21 <corgifex> how is that well defined
01:21:22 <zRecursive> Abathurr: maybe you can first reagard "typeclass" as "interface" type must implement
01:21:25 <corgifex> it doesn't even have laws
01:21:43 <augur> corgifex: lets not get ahead of ourselves :P
01:21:54 <augur> Abathurr: now, you can define such a thing for chars
01:22:15 <augur> Abathurr: but be clear: concatenation is not one of those operations. its something else entirely
01:22:19 <MP2E> Abathurr : The difference is that different patterns are abstracted into different typeclasses. I think the pattern you are seeing here between + on numbers and concatenation could better be served by using a Monoid constraint
01:22:40 <MP2E> Abathurr : You could easily use a function that operates on both Strings and Nums by using mappend along with the Monoid constraint
01:22:57 <corgifex> Num is not a type
01:23:07 <corgifex> Integer is not an instance of Monoid
01:23:48 <MP2E> Use Sum/Product, and yes I know Num is not a type
01:23:54 <zRecursive> so a instance of Num must implement (+), abs ,etc.
01:25:29 <Abathurr> I'll take your guys' word for it, but I still can't shake the idea that concatenation and + on numbers seems pretty similar to me
01:25:44 <Abathurr> Maybe I'll have to look up the Num typeclass for a definition or something
01:25:50 <kazagistar> Abathurr: they are, but so is multiplication
01:26:00 <corgifex> Abathurr: we expect a + b == b + a
01:26:06 <corgifex> doesn't hold for strings
01:26:18 <corgifex> Abathurr: but the main problem is that strings don't support -
01:26:45 <augur> Abathurr: ok so tell me what it means to subtract strings, or divide or multiply
01:27:01 <corgifex> :t div
01:27:02 <lambdabot> Integral a => a -> a -> a
01:27:22 <zRecursive> > "hello world" \\ "world"
01:27:23 <lambdabot>  "hel ol"
01:27:24 <augur> Abathurr: there is a WAY in which (+) on numbers and (++) on strings is similar -- both are monoidal. but that is NOT what the Num type class represents
01:27:25 <levi> corgifex: Num is pretty close to a Ring, though not quite.
01:27:25 <kazagistar> Abathurr: when do you write functions that will be used both to concatenate strings and sum numbers? such cases exist, but their utility is rare
01:27:45 <augur> Abathurr: Num represents more than just (+) -- it represents a whole collection of properties
01:27:50 <corgifex> kazagistar: ooh, excellent point
01:27:59 <augur> Abathurr: and those are different. they have different expectations, etc.
01:28:19 <Abathurr> augur: Ok that makes much more sense.
01:28:32 <Abathurr> Actually the way corgifex explained it made sense too
01:28:36 <augur> Abathurr: fwiw (+) and (*) are both monoidal
01:28:53 <Abathurr> a + = b + a
01:29:04 <Abathurr> whereas that wouldnt be the case with concatenation you'd have two different strings
01:29:16 <augur> Abathurr: so there is a sense in which they are like each other as well as like concatenation. but thats not what Num "means"
01:29:17 <levi> If Num didn't have abs and signum, it'd be a Ring.
01:29:47 <augur> Abathurr: this is why i say type classes represent "concepts". they represent a collection of things a type can do, when viewed a certain way
01:30:11 <Abathurr> augur: Ok, it's much clearer now. I just want to look at some documentation for the Num typeclass because I'd like to know what concept(s) Num encompasses for Haskell.
01:30:22 <Maxdamantus> I don't think `a + b = b + a` is required for monoids.
01:30:24 <augur> Abathurr: and the Num type class -- which "owns" the name (+) -- does not represent the concept that (+) and (++) have in common (namely, monoidality)
01:30:42 <augur> Abathurr: as i said, Num represents support for basic arithmetic
01:30:43 <kazagistar> Abathurr: might as well define a monoid, it is just something for which there is a binary operation, that operation is associative ((a + b) + c = a + (b + c)) and there is some kind of "zero"
01:30:47 <jonashw> what's an efficient way to get the following infinite list?  [1,1,2,2,3,3,4,4,5,5,6,6...]  I'm currently using concat $ map (\x -> [x,x]) [0..]
01:30:48 <jonashw> >take 12 $ concat $ map (\x -> [x,x]) [0..]
01:30:56 <jonashw> > take 12 $ concat $ map (\x -> [x,x]) [0..]
01:30:57 <lambdabot>  [0,0,1,1,2,2,3,3,4,4,5,5]
01:31:11 <Iceland_jack> jonashw: just use concatMap
01:31:16 <kazagistar> Abathurr: and the Monoid functions are called "mappend" and "mempty"
01:31:23 <jonashw> > take 12 $ concatMap (\x -> [x,x]) [0..]
01:31:23 <Zekka> Or =<< if you like obfuscation
01:31:24 <lambdabot>  [0,0,1,1,2,2,3,3,4,4,5,5]
01:31:29 <corgifex> > "abc" <> "de"
01:31:30 <lambdabot>  "abcde"
01:31:36 <Iceland_jack> > (\x -> [x,x]) =<< [0..]
01:31:37 <lambdabot>  [0,0,1,1,2,2,3,3,4,4,5,5,6,6,7,7,8,8,9,9,10,10,11,11,12,12,13,13,14,14,15,15...
01:31:41 <corgifex> > "abc" <> mempty
01:31:42 <lambdabot>  "abc"
01:31:59 <Iceland_jack> I worked on an extension that would allow you to write list sections where it would have been
01:31:59 <Iceland_jack>     [,] =<< [0..]
01:32:01 <jonashw> [1..] >>= (\x -> [x,x])
01:32:03 <jonashw> > [1..] >>= (\x -> [x,x])
01:32:05 <lambdabot>  [1,1,2,2,3,3,4,4,5,5,6,6,7,7,8,8,9,9,10,10,11,11,12,12,13,13,14,14,15,15,16,...
01:32:13 <Zekka> :t replicate
01:32:14 <lambdabot> Int -> a -> [a]
01:32:20 <Zekka> [1..] >>= (replicate 2)
01:32:25 <Zekka> > [1..] >>= (replicate 2)
01:32:26 <lambdabot>  [1,1,2,2,3,3,4,4,5,5,6,6,7,7,8,8,9,9,10,10,11,11,12,12,13,13,14,14,15,15,16,...
01:32:31 <Iceland_jack> You can remove the parens
01:32:34 <kazagistar> > Sum 3 <> Sum 2 <> mempty
01:32:36 <lambdabot>  Sum {getSum = 5}
01:32:39 <jonashw> yes, these are all great.  Which is most efficient ???
01:32:45 <Iceland_jack> jonashw: all the same
01:32:49 <Iceland_jack> basically
01:32:52 <jonashw> Iceland_jack, how do you know?
01:32:57 <skinnr> I would like to do real-time dsp in haskell. Is this a reasonable objective?
01:33:00 <kazagistar> > Product 3 <> Product 2 <> mempty
01:33:02 <lambdabot>  Product {getProduct = 6}
01:33:09 <Iceland_jack> jonashw: What do you mean? (>>=) is flip concatMap that's how I know
01:33:11 <jonashw> :t (<>)
01:33:12 <lambdabot> Monoid m => m -> m -> m
01:33:19 <Abathurr> Well I sure have a lot to think about now, damnit.
01:33:25 <Abathurr> And I was going to watch some mindless television.
01:33:27 <jonashw> Iceland_jack, k
01:33:37 <kazagistar> > "Hello" <> "Monoid" <> mempty
01:33:38 <lambdabot>  "HelloMonoid"
01:33:54 <levi> skinnr: Sure, though perhaps not directly. And it depends on what you mean by "real-time"
01:34:44 <skinnr> I'd like to move from languages such as spercollider and csound to haskell
01:35:33 <zRecursive> skinnr: "real-time"+'lazy' is a funny combination :)
01:36:14 <skinnr> I see your point, but it could be interesting specifically for this reason ;)
01:36:35 <kazagistar> Abathurr: if you want some simple and useful typeclasses, check out Eq, Ord, Enum, and Ix
01:36:45 <MP2E> I agree, I think it could be done. I think you will want most of your functions to be strict, with laziness saved for areas that may not be evaluated :P
01:37:44 <corgifex> Show is simplest
01:37:58 <kazagistar> Abathurr: oh, and Read and Show are important too
01:38:01 <corgifex> then Eq/Ord, then Read, then Enum
01:38:17 <kazagistar> yeah, thats probably better order
01:38:33 <corgifex> level 2, stage 1: Functor
01:39:42 <kazagistar> I think Arbitrary is one of the coolest in terms of "easy to understand the usefulness of typeclasses for imperative programmers"
01:39:56 <kazagistar> but it is def stage 2 at least
01:40:06 <kazagistar> er, level 2, or whatever you scheme is
01:40:23 <Abathurr> Oh, don't get me wrong, I can see the usefulness. It's just a lot of the concepts in Haskell are entirely new to me and intriguing because they force me to think about things in a different way...perhaps more abstractly? don't know fo rsure
01:40:43 <Abathurr> But definitely interesting enough to continue studying :)
01:41:21 <augur> Abathurr: i think at an instinctual level a lot of the concepts are actually familiar to you
01:41:21 <kazagistar> Abathurr: enjoy the ride
01:41:29 <augur> you're just not used to getting to use those concepts in this way
01:41:36 <mmmm> Is there a safe version of (!!)?
01:41:55 <skinnr> Haskell is the closest language I've expercienced that matches my mathematical intuition
01:42:05 <kazagistar> (until you get to stuff like the Endo instance of Monoid...)
01:42:06 <levi> skinnr: Not specifically music-related, but: http://www.cse.chalmers.se/edu/year/2013/course/TDA342/lectures/lecture9/lecture9.html#(1)
01:42:07 <corgifex> :t (listToMaybe .) . drop
01:42:08 <lambdabot> Int -> [a] -> Maybe a
01:42:20 <augur> Abathurr: for instance, it's not at all bizarre to think of the world being divided into two sorts of things: those which are tangible like cheese and those which are intangible like thoughts
01:42:35 <augur> Abathurr: and its not at all unusual to balk at the notion that you could "pick up" a thought
01:42:45 <corgifex> I can't pick up lava
01:42:50 <corgifex> or helium
01:43:00 <augur> corgifex: not with your hands you cant :P
01:43:14 <kazagistar> @pf (listToMaybe .) . drop
01:43:14 <lambdabot> Maybe you meant: pl bf
01:43:14 <skinnr> levi: thank you! :O
01:43:21 <zRecursive> Haskell is indeed interesting , but it is not a silver bullet to resolve all programming problems
01:43:39 <augur> Abathurr: being-able-to-pick-up presupposes that the thing is tangible. so you might say    class Tangible a where pickUp :: a -> Action
01:44:06 <Zekka> Do you mean "solve all programming problems" in the sense that "everything that was wrong is right again in Haskell?" or "if you can solve a problem in another language you can generally solve it in Haskell"?
01:44:08 <augur> Abathurr: thats not at all surprising and bizarre. certain actions can only be performed on certain things
01:44:16 <Abathurr> zRecursive: I agree, though I'm learning Haskell because it's oddly and uniquely interesting in a way other things haven't been to me, not so much for it's usefulness
01:44:34 <Zekka> Because I'd say that it's not the first but it is the second.
01:44:39 <Abathurr> augur: Oh I agree, at least on that level I understand very well
01:44:55 <Abathurr> augur: I only start to get confused when I try to think of the major differences between certain typeclasses that appear similar
01:45:04 <Abathurr> augur: but I will become better at it :)
01:45:25 <augur> Abathurr: well, an important skill is being able to state what you think is similar
01:45:54 <augur> Abathurr: for instance, can you state what you think (+) and (++) have in common
01:45:56 <Zekka> Isn't it a pretty common truism that knowing what a thing is is knowing what it isn't?
01:46:04 <augur> Abathurr: ignoring what others have said! :x
01:46:15 <augur> Zekka: a common falsism, perhaps
01:46:31 <Abathurr> augur: Erm let me think, it's pretty vague in my head other than this urge that the two are the same..
01:46:41 <Zekka> "is also" is a better way to put it
01:47:00 <Zekka> and it's not so much "this apple is not a rock, bucket, or anvil" as "this apple is too red and round to be a banana"
01:47:01 <augur> Abathurr: precision is the first step towards enlightenment :)
01:47:08 <Zekka> i.e., knowing the difference between things and similar things
01:47:12 <Zekka> Maybe this will help, Abathurr
01:47:14 <Zekka> :t (+)
01:47:15 <lambdabot> Num a => a -> a -> a
01:47:16 <Zekka> :t (++)
01:47:17 <lambdabot> [a] -> [a] -> [a]
01:47:59 <zRecursive> so its semantic is VERY different
01:48:10 <augur> "semantic"
01:48:17 <zRecursive> meaning
01:48:18 <Zekka> Well, there's something similar there, too
01:48:26 <Zekka> :t (,)
01:48:26 <lambdabot> a -> b -> (a, b)
01:48:32 <Zekka> er, that wasn't what I meant
01:48:33 <kazagistar> Abathurr: thats not to say they are entirely dissimilar, but formalizing it will isolate it and give you a tool to find other things that follow the same pattern of similarity
01:48:34 <levi> If you are dealing with Peano numbers, on the other hand...
01:49:02 <Zekka> Was trying to write the typesig of an operation that doesn't exist, silly me!
01:49:08 <Abathurr> kazagistar: I can see what you guys are saying, while similar there are fundamental differences. I'm just having a hard time putting into words what I think is so similar about them
01:49:17 <Abathurr> kazagistar: I'm going to have a smoke and think about it
01:49:41 <levi> There are similarities; but there are differences too.
01:49:52 <augur> Abathurr: having a think is good :)
01:49:58 <Zekka> Here's another hint
01:50:10 <Zekka> wait, no, my hint was bad
01:50:15 <augur> Abathurr: also consider: they might seem similar because youve been using + for both for too long :)
01:50:15 <Zekka> it kind of gives it away
01:50:56 <kazagistar> "ignoring what was already said"... I literally gave the answer, but it was probably too complex of an explanation to be useful haha
01:51:14 <Zekka> kazagistar: I was going to state the associativity law
01:51:30 <Zekka> but that pretty much carries everything there is to be said with it, implicitly
01:51:32 <Abathurr> kazagistar: I usually pride myself on being pretty quick, but people in here sometimes use vocabulary I dont undestand
01:51:50 <Zekka> Abathurr: Don't worry, I couldn't follow anything when I came in here first
01:52:05 <Abathurr> I mean corgifex saying a + b = b + a made sense to me but I cant actually put that into words what I want to say...its frustrating
01:52:17 <zRecursive> Abathurr: is English your 1st language ?
01:52:19 <kazagistar> Zekka: you can say that, those words mean very little to anyone who is not somewhat well versed in abstract algebra and such
01:52:31 <Abathurr> like with strings  a + b != b + a because you have "the dog" or " dog the"
01:52:31 <Zekka> kazagistar: No, I mean I was going to actually write it out as an expression
01:52:46 <Zekka> This was going to be my hint:
01:52:50 <kazagistar> Zekka: I actually did that earlier :P
01:52:56 <Zekka> Can you rewrite (a + b + c) any other way? What about (a ++ b ++ c)?
01:52:56 <levi> Abathurr: Unfamiliar vocabulary is unfamiliar whether you're quick or not. :) Fortunately, the terms are very useful for describing the sort of thing you're struggling to find words for.
01:53:11 <Zekka> If it helps, it's not as if anyone's trying to lord their knowledge over you
01:53:22 <Zekka> it's more that a lot of people who ran into the same questions decided to come up with words to describe their intuitions
01:53:39 <Abathurr> i DONT FEEL THAT WAY AT ALL
01:53:46 <Abathurr> whoops
01:53:48 <Zekka> For instance, the  "commutativity" of an operation f is whether f x y == f y x all the time
01:54:02 <Zekka> There's not an easy way to describe it so mathematicians came up with a word for it
01:54:11 <Abathurr> so a + b + c is always c + b + a but
01:54:13 <Abathurr> with strings
01:54:18 <Abathurr> a ++ b ++ c is only equal to that exact order
01:54:24 <Abathurr> i dont im not making sense
01:54:25 <Abathurr> ugh
01:54:35 <augur> Zekka: i dont think you're helping
01:54:38 <kazagistar> Abathurr: right, a + b == b + a is called the commutative property
01:54:56 <Zekka> augur: Oh, I didn't mean to say that these operations were commutative
01:55:10 <Zekka> He's right though that (+) is commutative and (++) isn't
01:55:34 <zRecursive> where is (++) defined ?
01:55:40 <Zekka> @src (++)
01:55:40 <lambdabot> []     ++ ys = ys
01:55:40 <lambdabot> (x:xs) ++ ys = x : (xs ++ ys)
01:55:40 <lambdabot> -- OR
01:55:40 <lambdabot> xs ++ ys = foldr (:) ys xs
01:55:47 <Zekka> I'll find it, one moment
01:56:00 <kazagistar> zRecursive: Data.List I think
01:56:04 <augur> @hoogle (++)
01:56:06 <lambdabot> Prelude (++) :: [a] -> [a] -> [a]
01:56:06 <lambdabot> Data.List (++) :: [a] -> [a] -> [a]
01:56:06 <lambdabot> Text.ParserCombinators.ReadP (+++) :: ReadP a -> ReadP a -> ReadP a
01:56:13 <Zekka> Kazagi's corret, although it seems to be reexported in prelude
01:56:27 <zRecursive> Zekka: so it is just a function to operate on List only
01:56:34 <kazagistar> most (all?) of the prelude stuff is exported from elsewhere
01:56:36 <Abathurr> whatever that lambda bot thing just said was like ten times clearer to me than anything else that has been said..heh. But I honestly don't care if anyone "lords" their knowledge over me I just want to understand
01:57:00 <Zekka> > "abc" ++ "def" ++ "ghi"
01:57:01 <lambdabot>  "abcdefghi"
01:57:08 <Zekka> > [1, 2, 3] ++ [4, 5, 6] ++ [7, 8, 9]
01:57:10 <lambdabot>  [1,2,3,4,5,6,7,8,9]
01:57:15 <zRecursive> :t "abc"
01:57:16 <lambdabot> [Char]
01:57:18 <Zekka> If you feel like your intuition's lacking at all, maybe that helps
01:57:51 <kazagistar> Abathurr: here is another small hint:
01:58:01 <kazagistar> > "abc" ++ ("def" ++ "ghi")
01:58:03 <lambdabot>  "abcdefghi"
01:58:25 <kazagistar> maybe big hint :P
01:59:30 <zRecursive> There is (\\) but no "--" in Data.List ?
01:59:43 <Zekka> :t (\\)
01:59:44 <lambdabot> Eq a => [a] -> [a] -> [a]
01:59:53 <jxv> -- is for comments
01:59:59 <zRecursive> > "abc123" \\ "123"
01:59:59 <Zekka> > [1, 2, 3, 4] \\ [2, 3, 4, 5]
02:00:00 <lambdabot>  "abc"
02:00:01 <lambdabot>  can't find file: L.hs
02:00:06 <Zekka> > [1, 2, 3, 4] \\ [2, 3, 4, 5]
02:00:07 <lambdabot>  [1]
02:00:18 <corgifex> > [1, 1] \\ [1]
02:00:20 <lambdabot>  [1]
02:00:22 <kazagistar> that would give the wrong intuition I imho, because ++ would not be inverse of such a --
02:00:34 <jxv> use concat then
02:00:49 <Zekka> (\\) is probably the closest analogue for (--) even though ++ is not an inverse
02:00:59 <jxv> > [1..4] `concat` [2..5]
02:01:01 <lambdabot>  Couldn't match expected type ‘[t0] -> t’ with actual type ‘[a0]’
02:01:09 <Zekka> :t concat
02:01:10 <lambdabot> [[a]] -> [a]
02:01:12 <jxv> oops
02:01:18 <jxv> mappend
02:01:23 <corgifex> <>
02:01:32 <Zekka> > [1..4] <> [2..5]
02:01:34 <lambdabot>  [1,2,3,4,2,3,4,5]
02:02:03 <zRecursive> > [1..4] ++ [2..5]
02:02:05 <lambdabot>  [1,2,3,4,2,3,4,5]
02:02:05 <Abathurr> oh wait
02:02:06 <Abathurr> wait
02:02:33 <kazagistar> ... waiting :D
02:02:50 <Zekka> I'm so tempted to :t (<>)
02:03:06 <jxv> Zekka, look at monoids first
02:03:12 <Zekka> Oh, I already know
02:03:24 <Zekka> I just meant 'to try to show Abathurr'
02:03:30 <Zekka> but I feel like it might really give the game away
02:03:34 <zRecursive> :t (<>)
02:03:35 <lambdabot> Monoid m => m -> m -> m
02:03:35 <jxv> ah
02:03:35 <kazagistar> Zekka: its not about being a "game" :/
02:03:35 <Abathurr> Ok so it seems that + matches value while ++ matches order if that makes any sense. When zRecursive did "abc123" // "123" it matched "abc" as if by value,,,I think I'm getting somewhere
02:03:42 <Abathurr> I must look liek such a tool heh
02:03:49 <Zekka> kazagistar: I was hoping to see if we'd get it himself
02:04:00 <Zekka> It's not about playing a game but about seeing if he can figure it out
02:04:01 <corgifex> > "Abathurr" \\ "Rhubarb"
02:04:02 <lambdabot>  "Atr"
02:04:12 <jle`> you don't look like a tool Abathurr :)
02:04:30 <Zekka> Abathurr: For the certain thing we're trying to get at, you're getting into correct territory although I don't think it's exactly hat folks have been trying to steer you into
02:04:41 <kazagistar> Zekka: it took hundreds of years of mathematics before we figured it out
02:05:08 <kazagistar> I think order is actually a great insight
02:05:14 <Zekka> Let me try to put this in neat terms.
02:05:35 <Zekka> (++) shares some properties of (+) due to the *structure* [] imposes
02:05:46 <Zekka> (+) doesn't deal with any such structure
02:05:54 <kazagistar> ++ cares about order, but + does not, which is a very significant difference
02:05:59 <Zekka> And it shares those properties because of what the idea of order meanas
02:06:10 <Zekka> He already guessed that it was commutative, mind
02:06:16 <Zekka> I think he's getting into some slightly different territory
02:06:51 <Zekka> Basically I think he's steering off into the direction of free structures
02:06:58 <kazagistar> ok fair enough
02:08:06 <levi> skinnr: http://www.haskell.org/haskellwiki/Synthesizer
02:08:39 <Abathurr> They need to invent a word for when you discover some branch of knowledge you feel compelled to figure out
02:09:33 <Abathurr> Anyway, I have no idea what free structures are but knowing I'm on the right track is a great help
02:09:41 <kazagistar> Abathurr: this particular branch is probably called abstract algebra with a dose of type theory
02:09:50 <Zekka> kazagistar: Can you think of any free structures that are easier to explain than []?
02:09:59 <Zekka> If he's going in that direction I kind of want to give him something to point out
02:10:11 <Zekka> but I feel like magmas are kind of hard to explain and point to and say "there, that's a thing you know about"
02:10:26 <Zekka> and the free semigroup feels like cheating
02:11:11 <kazagistar> meh, skip free for now
02:11:18 <levi> Abathurr: You don't really have to grok this stuff to program in Haskell, but it's helpful and fun to learn about.
02:11:48 <kazagistar> Abathurr: consider (*)... is it more similar to (+) or (++)?
02:11:52 <Zekka> Free structures are interesting and kind of neat but a lot of them don't look like things you intuitively know about
02:12:03 <Abathurr> levi: I'm going to make a confession. I don't really care about programming in Haskell really. I just read some wikipedia stuff and what Haskell is *based* in seems really really interesting
02:12:08 <Abathurr> levi: Even though I don't really understand any of it
02:12:10 <jle`> free magma maybe
02:12:31 <Abathurr> That was a lot of reallies
02:13:13 <kazagistar> or rather, which of those seem the most related and why?
02:13:23 <Zekka> If it helps I don't have any formal education in algebra
02:13:31 <Zekka> Well, I'm lying -- I took a semester course in it last year
02:13:45 <Zekka> Pretty much everything I know about it is from coding in Haskell: it's a really good teaching tool
02:13:48 <Abathurr> kazagistar: * seems more related to + but again I cant really explain why
02:14:01 <Abathurr> kazagistar: I'll try, give me a moment
02:14:05 <Zekka> :t (*)
02:14:06 <lambdabot> Num a => a -> a -> a
02:14:07 <Zekka> :t (+)
02:14:08 <lambdabot> Num a => a -> a -> a
02:14:09 <Zekka> :t (++)
02:14:10 <lambdabot> [a] -> [a] -> [a]
02:14:21 <Qfwfq>  /w 4
02:14:33 <kazagistar> thats not particularly insightful I think, Zekka :P
02:15:00 <levi> Abathurr: Well, if abstract math is what interested you, you'll find lots of interested parties here to talk about it.
02:15:04 <kazagistar> it does not affirm that insight for the right reason either
02:15:28 <Zekka> kazagistar: Yeah, if I'm getting at what you think I'm getting at I think you're right
02:15:32 <Abathurr> levi: I've virtually no training in mathematics, in fact I didn't even know this *was* mathematics until I was informed here
02:15:33 <Welkin> multiplication is just addition
02:16:08 <Sculptor> who's in for a nice math game http://euclidthegame.org/ 'm @ the last level
02:16:25 <kazagistar> Abathurr: well, just start naming things that both (+) and (*) have in common, and see how many you can find, we can fill in some you miss :D
02:16:56 <kazagistar> in mathematics, even trivial similarities are interesting
02:17:14 <augur> whats the standard YAML lib?
02:17:23 <kazagistar> (this kind of mathematics, as opposed to the kind that scarred you in grade school)
02:17:29 <levi> Abathurr: Way more things are mathematics than a lot of people realize.
02:18:15 <Zekka> A lot of what Haskell observes is actually kind of obvious in retrospect
02:18:19 <Zekka> (read: a lot of what algebra observes)
02:18:30 <levi> augur: Pandoc links to 'yaml'
02:18:40 <levi> Or uses, I guess.
02:18:50 <Zekka> like, there's a typeclass analogue for "things that have a binary operation defined on them"
02:18:59 <Zekka> (that is, an operation a -> a -> a)
02:19:01 <augur> levi: ok
02:19:16 <Zekka> and that's not really that interesting in the sense that when you hear it you think "Wow! I've never thought of that before!"
02:19:19 <Abathurr> kazegistar: Well here's the only way I can explain what I'm thinking. a * b defines a relation that affects a by the value of b where as there is no such similarity to ++, like...a could almost be a function that uses b as an input put that doesn't really happen with ++. I hate when my ideas are vague, though.
02:19:21 <jonashw> what's the prelude function ($!) good for?
02:19:36 <jle`> @src ($!)
02:19:36 <jonashw> :t ($!)
02:19:36 <lambdabot> f $! x = x `seq` f x
02:19:37 <lambdabot> (a -> b) -> a -> b
02:19:43 <jle`> for strictness
02:19:49 <jonashw> ah
02:20:01 <jonashw> I remember seeing seq in LYAH
02:20:04 <jle`> > const 4 (sum [1..])
02:20:05 <lambdabot>  4
02:20:09 <Welkin> if you are interested, watch the lecture by Philip Wadler
02:20:10 <jle`> > const 4 $ (sum [1..])
02:20:12 <lambdabot>  4
02:20:13 <Welkin> Abathurr, https://www.youtube.com/watch?v=-jablEX5E_U&list=PLtRG9GLtNcHBv4cuh2w1cz5VsgY6adoc3&index=13
02:20:15 <jle`> > const 4 $! (sum [1..])
02:20:19 <lambdabot>  mueval-core: Time limit exceeded
02:20:20 <Welkin> at 27:12
02:20:22 <jonashw> gotcha
02:20:39 <jle`> well that's an example where it's *not* helpful, but you get the picture :P
02:20:42 <Welkin> he explains how natural numbers leads to addition, leads to multiplication
02:21:02 <Zekka> Actually doing what jle did is not helpful but it's certainly helpful in understanding it
02:21:03 <jonashw> jle`, yeah, it forces strictness.  I remember something about using seq when strictness *improved* performance
02:21:15 <levi> augur: I dunno if that makes it "standard", but at least it's actively used.
02:21:25 <jle`> jonashw: classic example is foldl
02:21:27 <jonashw> jle`, does that sound right to you?
02:21:50 <jle`> strictness and laziness are both useful in their specific areas of usefulness
02:22:00 <jonashw> nice tautology there
02:22:00 <Abathurr> I wish i could just draw a picture of what I'm thinking damnit.
02:22:01 <jle`> (which is a tautology, but...)
02:22:03 <jle`> lol
02:22:05 <jonashw> ;)
02:22:23 <jle`> a lot of people seem to think that strictness is good for all situations or laziness is good for all situations
02:22:26 <levi> Strictness often improves performance; GHC tries to figure out when it can safely apply it as an optimization.
02:22:56 <jonashw> does it have to do with thunks taking up space?
02:23:09 <jle`> yes, but sometimes laziness just doesn't make sense
02:23:14 <levi> space, extra indirection, etc.
02:23:22 <jle`> like it's semantically not what you want
02:23:24 <jonashw> ok, so cycles too
02:23:38 <levi> It's not a *huge* overhead generally.
02:23:50 <kazagistar> Abathurr: could you be thinking about an inverse function? I dont want to put words in your mouth
02:23:52 <jonashw> thanks
02:23:53 <Abathurr> I guess another thing is there is a kind of linear rule with + and * like successive values will always lead to successively higher end values when doing a * b or a + b assuming they are positive, but there isn't really such a relation with ++
02:23:54 <skinnr> ZRecursive: I agree. However, I do believe that a language which sharpens my thinking and _forces_ me to think in novel ways/exit
02:24:13 <Abathurr> I mean is "dog" higher value than "cat"
02:24:19 <Abathurr> I don't know
02:24:22 <Welkin> yes
02:24:24 <jonashw> > compare "dog" "cat"
02:24:25 <lambdabot>  GT
02:24:29 <jonashw> there you have it
02:24:29 <jle`> jonashw: foldr (+) 0 [1,2,3] will build up the thunk (((0+1)+2)+3)
02:24:48 <jle`> which takes up space until you force it, yes...
02:24:54 <levi> > foldr f 0 [1,2,3]
02:24:54 <Welkin> characters have numeric values
02:24:55 <lambdabot>  No instance for (GHC.Show.Show a0)
02:24:55 <lambdabot>    arising from a use of ‘M169103386286324102212164.show_M1691033862863241022...
02:24:55 <lambdabot>  The type variable ‘a0’ is ambiguous
02:24:55 <lambdabot>  Note: there are several potential instances:
02:24:55 <lambdabot>    instance [safe] GHC.Show.Show
02:24:56 <jle`> but more importantly, it's really not what you want
02:25:02 <jle`> like, semantically
02:25:16 <Welkin> well, they have an ordering
02:25:17 <levi> > foldr f x [1,2,3]
02:25:18 <lambdabot>  f 1 (f 2 (f 3 x))
02:25:22 <jle`> oh
02:25:24 <jle`> i meant foldl
02:25:26 <jle`> sorry >_>
02:25:30 <jonashw> <_<
02:25:31 <kazagistar> the fact that negative numbers exist, though, is actually kinda important, but we could theoretically ignore those
02:25:37 <jle`> > foldl f 0 [1,2,3]
02:25:38 <lambdabot>  No instance for (GHC.Show.Show a0)
02:25:38 <lambdabot>    arising from a use of ‘M760374710206225355512212.show_M7603747102062253555...
02:25:38 <lambdabot>  The type variable ‘a0’ is ambiguous
02:25:38 <lambdabot>  Note: there are several potential instances:
02:25:38 <lambdabot>    instance [safe] GHC.Show.Show
02:25:42 <jonashw> >_>
02:25:43 <jle`> > foldl f 0 [1,2,3] :: Expr
02:25:44 <Abathurr> was I anywhere near the mark with that?
02:25:45 <lambdabot>  f (f (f 0 1) 2) 3
02:25:47 <jonashw> ^_^
02:25:58 <jle`> yes that will build up a fatty thunk for long lists
02:25:59 <Zekka> There's negative numbers, but can there be negative lists?
02:25:59 <Welkin> > foldl (+) 0 [1,2,3,4,5]
02:26:01 <lambdabot>  15
02:26:02 <jonashw> so, that's an interesting trick ... :: Expr
02:26:04 <Welkin> > foldl' (+) 0 [1,2,3,4,5]
02:26:06 <lambdabot>  15
02:26:14 <jle`> but you don't really want to represent the act of building up a thunk
02:26:18 <jle`> you want something that adds "as you go along"
02:26:21 <Welkin> > let f in foldl' f 0 [1,2,3,4,5]
02:26:22 <lambdabot>  <hint>:1:7: parse error on input ‘in’
02:26:45 <kazagistar> Abathurr: I think you are thinking too hard... that idea is indeed a property of + and *, but we are looking for simpler ideas
02:26:54 <augur> is there a conventional style for using the Yaml lib?
02:27:09 <jle`> strictness provides you with those semantics in situations where you desire it
02:27:41 <jonashw> jle`, hmm my intuition leads me to think of a foldl yielding a tree of thunks
02:27:59 <jle`> jonashw: and you are right, it does; see the Expr result
02:28:07 <jonashw> chop down the tree and and get a tree thunk
02:28:16 <jle`> thunk thunk
02:28:35 <Welkin> > foldl' g 0 [1,2,3,4,5] :: Expr
02:28:36 <lambdabot>  g (g (g (g (g 0 1) 2) 3) 4) 5
02:28:40 <kazagistar> Abathurr: ill just tell you what the math people think, and let you think about it?
02:28:42 <jle`> >_>
02:29:04 <Welkin> > foldr g 0 [1,2,3,4,5] :: Expr
02:29:06 <lambdabot>  g 1 (g 2 (g 3 (g 4 (g 5 0))))
02:29:22 <levi> It doesn't *evaluate* anything, so there's no difference in the Expr form between foldl and foldl'
02:29:30 <Welkin> yes
02:29:45 <jonashw> jle`, ok, so creating a tree from a list and then performing an operation on that tree is more expensive than just performing the operation on the list directly.  hence strictness performs better
02:30:12 <jonashw> jle`, if you know you are going to do all of the work, it's more performant to do it strictly than lazily
02:30:21 <jonashw> yes?
02:30:41 <Welkin> if you know you need every value calculated, then yes
02:30:58 <jle`> my take is that it's not really about performance but about the semantics of the computation/evaluation you want to declare
02:30:59 <Abathurr> kazagistar: Perhaps if I don't get it in a few more minutes.
02:31:03 <Welkin> laziness is useful where you are not sure if you need to calculate the value
02:31:10 <Abathurr> kazagistar: I will not give up! :)
02:31:33 <jonashw> jle`, I can see it that way too.  an infinite list is semantically different from a finite one
02:31:35 <kazagistar> Abathurr: what you are saying is not wrong, I want to emphasize that. However, we might say that some properties emerge from others so we want the simplest possible ones. you already got commutativity, which is a big one!
02:31:50 <jle`> jonashw: yeah, an infinite list is really a function that generates new elements on demand
02:32:03 <jonashw> I love infinite lists
02:32:17 <jonashw> jle`, you said something about foldl and seq.. what was that?
02:32:24 <jle`> > let from n = n : from (n+1) = from 0
02:32:25 <lambdabot>  <hint>:1:29: parse error on input ‘=’
02:32:29 <jle`> > let from n = n : from (n+1) in from 0
02:32:30 <lambdabot>  [0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,2...
02:33:11 <jle`> from 0 is a list, but really, when you use it in practice, it's actually a function that gives you a number and the "next generator" whenever you pattern match
02:33:13 <kazagistar> jonashw: doing it strictly means storing intermediate steps in memory
02:33:23 <jle`> if you can imagine uncons (x:xs) = (x, xs)
02:33:31 <jle`> then uncons (from 0) = (0, from 1)
02:33:36 <jle`> uncons (from 1) = (1, from 2)
02:33:40 <jle`> uncons (from 2) = (2, from 3)
02:33:42 <jle`> etc.
02:33:55 <jonashw> man, you type so quickly :)
02:34:00 <Welkin> uncons looks like pop
02:34:02 <jle`> from n is just a function that returns n, and "the next function"
02:34:35 <jonashw> jle`, your description here reminds me very much of Streams in scala
02:34:40 <kazagistar> if you use a list exactly once, from front to back, then haskell makes sure it never exists in memory, because you discard the bits that are finished
02:34:52 <jle`> that's because lists are just streams with potential termination :)
02:35:00 <jonashw> and I suppose Streams are a scala representation of infinite lists in haskell
02:35:10 <jle`> yeah, in this case, "from 2" is  just a function
02:35:16 <jle`> that you "call" with uncons
02:35:20 <jle`> this works in normal languages too
02:35:29 <jle`> er, strict languages
02:35:35 <jle`> like you seem to recognize from Scala
02:35:47 <ninja_code> when writing haskell code, shoudl I ahve with = 80 chars
02:35:54 <ninja_code> or does it make more sense to allow longer lines?
02:36:04 <jle`> ninja_code: 80 chars is more than enough
02:36:10 <jle`> some people do more but why
02:36:14 <levi> I believe Scala has optional lazy evaluation.
02:36:36 <jonashw> levi, that's right.  with the lazy keyword
02:36:41 <ninja_code> hmm, I find 160 more comfortable
02:36:46 <Welkin> ninja_code, it's always a good idea to limit to 80 characters
02:36:54 <jle`> jonashw: do you understand algebraic data types?
02:37:03 <kazagistar> I like more in some languages, but I never feel the need to get past 80 in haskell
02:37:09 <levi> Opinions vary on line width. :P
02:37:28 <jle`> data Stream a = Cons { uncons :: (a, Stream a) }
02:37:39 <jonashw> jle`: I believe so.  they're pretty simple in my mind so I might be missing something
02:37:41 <Welkin> 80 characters takes up a little more than half my screen width
02:37:45 <ninja_code> hmm, do you guys keep comments on the same line
02:37:46 <ninja_code> or a different line then?
02:37:51 <Welkin> always a new line
02:37:54 <ninja_code> i like to have comments on same line
02:37:55 <ninja_code> hmm
02:37:58 <Welkin> inline comments should be used sparingly
02:37:59 <jonashw> data Direction = U | D | L | R
02:38:14 <jle`> hm that was the wrong adt i wanted to use to show my point
02:38:22 <jle`> but yeah, lists are just functions that return an element and a new function
02:38:25 <jonashw> ?
02:38:27 <jle`> (sorta)
02:38:31 <ninja_code> http://lpaste.net/106420 <-- how should this be written isntead?
02:38:34 <jle`> (i was referring to my data Stream)
02:38:42 <jonashw> oh, sorry I missed that :)
02:38:43 <Abathurr> I give up. I got commutativity but I'm missing the last one
02:38:52 <Welkin> ninja_code, puts the comments on the line before the code
02:38:52 <jle`> oh yeah i was saying about foldl
02:39:09 <jle`> foldr is a case where laziness is useful
02:39:18 <jle`> > foldr (||) [True..]
02:39:19 <lambdabot>  <hint>:1:19: parse error on input ‘]’
02:39:25 <jle`> > foldr (||) [True ..]
02:39:26 <lambdabot>  Couldn't match expected type ‘GHC.Types.Bool’
02:39:27 <lambdabot>              with actual type ‘[GHC.Types.Bool]’
02:39:32 <jle`> > foldr (||) False [True ..]
02:39:33 <lambdabot>  True
02:40:12 <kazagistar> jonashw: you know what the reasonably optimal implementation of the O(N) "find the 10 smallest items" algorithm looks like in haskell?
02:40:13 <jonashw> can you clarify what is 'right' about foldr?
02:40:20 <Abathurr> kazagistar: I'm open to the answer, whenever you're ready :)
02:40:23 <Welkin> jonashw, it folds from the right
02:40:26 <jle`> jonashw: I just (||)'d an infinite list
02:40:27 <Welkin> > foldr g 0 [1,2,3,4,5] :: Expr
02:40:28 <lambdabot>  g 1 (g 2 (g 3 (g 4 (g 5 0))))
02:40:33 <jle`> and got an answer
02:40:48 <jonashw> Welkin, well it certainly doesn't start at the right of the infinite list
02:40:51 <kazagistar> jonashw: take 10 . sort
02:41:02 <Welkin> > foldr g 0 [1..] :: Expr
02:41:03 <lambdabot>  g 1 (g 2 (g 3 (g 4 (g 5 (g 6 (g 7 (g 8 (g 9 (g 10 (g 11 (g 12 (g 13 (g 14 (g...
02:41:06 <Welkin> it does
02:41:09 <jonashw> what
02:41:21 <Welkin> it never finishes
02:41:24 <jle`> that's because the *semantics* of foldr is that you apply the function on successive items ... until the function doesn't need any more items
02:41:59 <jle`> > foldr (&&) True (repeat False)
02:42:00 <lambdabot>  False
02:42:06 <jle`> sorry, that was the correct example
02:42:24 <jle`> > foldr (&&) True [True, False, undefined, fix error, error "hello"]
02:42:26 <lambdabot>  Couldn't match type ‘[GHC.Types.Char]’ with ‘GHC.Types.Bool’
02:42:26 <lambdabot>  Expected type: GHC.Types.Bool -> GHC.Types.Bool
02:42:26 <lambdabot>    Actual type: [GHC.Types.Char] -> GHC.Types.Bool
02:42:32 <kazagistar> Abathurr: ok 1 sec
02:42:37 <jle`> > foldr (&&) True [True, False, undefined, error "hello"]
02:42:38 <lambdabot>  False
02:42:44 <Abathurr> Unless its something like if 1 + 2 = 2 + 1 then 1 + 2 + 3 = (1 + 2) + 3 = (2 + 1) + 3 = 2 + (1
02:42:46 <Abathurr> + 3)
02:42:49 <jonashw> in that example, evaluation terminates after the first comparison, right (in foldr (&&) True (repeat False))
02:42:51 <Welkin> > foldr (+) 0 [1..]
02:42:52 <Abathurr> thats all I got. Im tapped out
02:42:56 <lambdabot>  mueval-core: Time limit exceeded
02:42:56 <lambdabot>  mueval: ExitFailure 1
02:43:07 <jle`> jonashw: that's because of the source of (&&)
02:43:14 <jle`> @src (&&)
02:43:15 <lambdabot> True  && x = x
02:43:15 <lambdabot> False && _ = False
02:43:27 <jle`> (&&) with a False on the left side doesn't care about the right hand side
02:43:37 <jonashw> > foldr (&&) True (repeat True)
02:43:39 <jle`> (&&) False = const False
02:43:41 <lambdabot>  mueval-core: Time limit exceeded
02:43:48 <jonashw> ok there
02:43:56 <jonashw> I got it to fail
02:44:03 <jle`> in this case, laziness provides the proper semantics for the thing you want to do
02:44:21 <jonashw> :t const
02:44:22 <lambdabot> a -> b -> a
02:44:29 <jle`> const x = \_ -> x
02:44:29 <jonashw> a 2-ary version of id ?
02:44:40 <jonashw> ish
02:44:53 <jle`> it ignores the second parameter, so never asks for it
02:44:54 <Maxdamantus> :t const id
02:44:55 <lambdabot> b -> a -> a
02:45:07 <Maxdamantus> :t const const id
02:45:08 <lambdabot> a -> b -> a
02:45:08 <jle`> :t flip const
02:45:09 <jonashw> :t flip const id
02:45:09 <lambdabot> b -> c -> c
02:45:10 <lambdabot> c -> c
02:45:13 <Iceland_jack> 'fmap (const _)' is morally id
02:45:21 <Iceland_jack> *Const
02:45:22 <jonashw> lol
02:45:34 <jonashw> ok
02:45:38 <jle`> by the way, foldr is a catamorphism...i think
02:45:48 <jle`> when you foldr a list like 1 : 2 : 3 : []
02:45:49 <kazagistar> Abathurr: associativity: (a + b) + c = a + (b + c)    commutativity: a + b = b + a      identity elements: a + 0 = a     inverse element: a + (-a) = 0 (related to identity)
02:45:53 <jle`> and you have foldr f b
02:45:54 <Maxdamantus> :t [flip const, const id, flip const const id]
02:45:55 <lambdabot> [(c -> c) -> c -> c]
02:46:06 <jle`> you basically go in and replace every (:) with f, and the [] with b
02:46:07 <kazagistar> Abathurr: ill let you verify those for multiplication too, but you got most of em
02:46:16 <jle`> so that turns into 1 `f` 2 `f` 3 `f` b
02:46:27 <Maxdamantus> :t [flip const, const id, flip const const id, const const const const id]
02:46:27 <lambdabot>     Occurs check: cannot construct the infinite type: c ~ c -> c
02:46:28 <lambdabot>     Expected type: (c -> c) -> c -> c
02:46:28 <lambdabot>       Actual type: (c -> c) -> c -> c -> c
02:46:28 <Welkin> a fold is a catamorphism
02:46:32 <Welkin> an unfold is an anamorphism
02:46:40 <jle`> so now it's obvious why foldr (&&) True works
02:46:41 <MP2E> and doing both is a hylomorphism :>
02:47:07 <jle`> because foldr (&&) True [x,y,z] is just x && y && z && True
02:47:27 <Abathurr> kazagistar: aha! I was missing the inverse I think which makes absolutely perfect sense, now I'm wondering how I missed that. I mean theres no negative of "the dog"
02:47:28 <jle`> foldr (&&) True (x : y : z : [])  is x && y && z && True
02:47:36 <jle`> basically s/:/&&/g
02:47:37 <Abathurr> kazagistar: Damnit, seems so obvious now.
02:47:39 <kazagistar> Abathurr: the one strangeness about multiplication is that there is no inverse of zero
02:47:44 <jonashw> ok, foldr expands well like that for infix functions
02:47:44 <jle`> and s/[]/True :)
02:47:52 <ninja_code> damn it
02:47:53 <ninja_code> I can't do less than 120
02:47:56 <jle`> foldl is different
02:48:11 <jle`> > foldr (:) [] (x:y:z:[]) :: Expr
02:48:12 <lambdabot>  Couldn't match type ‘[Debug.SimpleReflect.Expr.Expr]’
02:48:12 <lambdabot>                with ‘Debug.SimpleReflect.Expr.Expr’
02:48:12 <lambdabot>  Expected type: Debug.SimpleReflect.Expr.Expr
02:48:12 <lambdabot>                 -> Debug.SimpleReflect.Expr.Expr -> Debug.SimpleReflect.Expr....
02:48:12 <lambdabot>    Actual type: Debug.SimpleReflect.Expr.Expr
02:48:15 <jle`> darnit
02:48:22 <jle`> > foldr (:) [] (x:y:z:[]) :: [Expr]
02:48:23 <lambdabot>  [x,y,z]
02:48:37 <jonashw> lexical ordering
02:48:39 <kazagistar> Abathurr: the identity element with multipliation is not zero, I am sure you can figure out what makes all those rules fit though
02:48:40 <augur_> how the hell do i use the Yaml library :|
02:48:44 <jle`> > foldl f z [x,y,z]
02:48:45 <augur_> this is so confusing
02:48:45 <lambdabot>  f (f (f z x) y) z
02:48:55 <jle`> @src foldl
02:48:55 <lambdabot> foldl f z []     = z
02:48:55 <lambdabot> foldl f z (x:xs) = foldl f (f z x) xs
02:49:19 <jle`> um anyways.
02:49:23 <jonashw> > foldl (++) [] (x:y:z:[])
02:49:24 <lambdabot>  Couldn't match expected type ‘[a]’
02:49:24 <lambdabot>              with actual type ‘Debug.SimpleReflect.Expr.Expr’Couldn't match e...
02:49:24 <lambdabot>              with actual type ‘Debug.SimpleReflect.Expr.Expr’Couldn't match e...
02:49:24 <lambdabot>              with actual type ‘Debug.SimpleReflect.Expr.Expr’
02:49:26 <jle`> i sort of went about and talked about unrelated things, sorry.
02:49:29 <jonashw> > foldl (:) [] (x:y:z:[])
02:49:30 <lambdabot>  Couldn't match expected type ‘[[t]]’
02:49:30 <lambdabot>              with actual type ‘Debug.SimpleReflect.Expr.Expr’Couldn't match e...
02:49:30 <lambdabot>              with actual type ‘Debug.SimpleReflect.Expr.Expr’Couldn't match e...
02:49:30 <lambdabot>              with actual type ‘Debug.SimpleReflect.Expr.Expr’
02:49:33 <jonashw> erp
02:49:43 <jle`> foldl's function is backwards from foldr
02:49:46 <jle`> :t foldl
02:49:46 <lambdabot> (b -> a -> b) -> b -> [a] -> b
02:49:47 <jle`> :t foldr
02:49:48 <lambdabot> (a -> b -> b) -> b -> [a] -> b
02:50:18 <jle`> anyways, what if you wanted to not (&&) up an entire list, but to (+) up an entire list?
02:50:29 <jonashw> > foldl (flip . :) [] (x:y:z:[])
02:50:30 <lambdabot>  <hint>:1:15: parse error on input ‘:’
02:50:33 <jle`> the behavior you want is inherently different
02:50:38 <jonashw> > foldl (flip . (:)) [] (x:y:z:[])
02:50:39 <lambdabot>  Couldn't match type ‘[a -> c]’
02:50:39 <lambdabot>                with ‘Debug.SimpleReflect.Expr.Expr -> c’
02:50:39 <lambdabot>  Expected type: (a -> c) -> a -> Debug.SimpleReflect.Expr.Expr -> c
02:50:39 <lambdabot>    Actual type: (a -> c) -> [a -> c] -> [a -> c]Couldn't match expected type ...
02:50:41 <jonashw> derp
02:50:45 <jle`> flip (:), btw
02:50:56 <kazagistar> augur_: link it and maybe I can figure it out a little
02:50:58 <Abathurr> kazagistar: Man, thanks for everything :) Especially being patient
02:50:58 <jonashw> > foldl (flip (:)) [] (x:y:z:[])
02:51:00 <lambdabot>  [z,y,x]
02:51:01 <jonashw> thx
02:51:06 <augur_> kazagistar: theres nothing to link, i have NO idea what to do
02:51:26 <kazagistar> augur_: I mean the documentation for the library
02:51:36 <jle`> if you wanted to (+) up an entire list, your thing has inherently different semantics than if you anted to (&&) up an entire list
02:51:45 <augur_> https://hackage.haskell.org/package/yaml
02:52:05 <jle`> by the way, you can't foldl (&&) True an infinite list
02:52:12 <jle`> because of the way the function application works in foldl
02:52:37 <jonashw> foldl (&&) True $ repeat False
02:52:40 <jonashw> > foldl (&&) True $ repeat False
02:52:43 <lambdabot>  mueval-core: Time limit exceeded
02:52:45 <jonashw> ha
02:52:49 <kazagistar> augur_: ah, it seems to lean heavily (if not entirely) on Aeson for its interface from what it looks like
02:52:59 <augur_> maybe i should just use JSON
02:53:01 <jonashw> ok, so my intuition about foldr and foldl was flipped
02:53:09 <jle`> (&&) is strict on the first parameter and nonstrict on the second; in foldr, the second parameter is the result of &&'ing the rest of the list.  in foldl, the first parameter is the result of &&'ing the rest of the list.
02:53:10 <jonashw> foldr works on infinite lists, foldl doesn't
02:53:32 <jonashw> ah, I got it!
02:53:46 <jle`> so anyways when you want to sum a list, you don't really want to represent building up thunks as your computation
02:53:52 <jle`> that's not the semantic model you want for your computation
02:54:01 <jle`> you want something that basically adds things up as you go along
02:54:07 <kazagistar> augur_: well, it seems that whichever you use you will get the same applicative style api, but Aeson actually has a few examples
02:54:13 <jle`> in constant memory, more or less
02:54:17 <augur_> kazagistar: yeah
02:54:20 <jle`> laziness can't give you those semantics
02:54:22 <jle`> strictness can
02:54:25 <jonashw> I heard foldl' is good for that
02:54:28 <jonashw> is that right
02:54:28 <jonashw> ?
02:54:39 <jle`> yes, foldl' is foldl with strict semantics
02:54:45 <jle`> actually foldl is rarely ever a good idea
02:54:46 <jonashw> :t foldr
02:54:46 <lambdabot> (a -> b -> b) -> b -> [a] -> b
02:54:48 <jonashw> :t foldr'
02:54:49 <lambdabot>     Not in scope: ‘foldr'’
02:54:49 <lambdabot>     Perhaps you meant one of these:
02:54:49 <lambdabot>       ‘BS.foldr'’ (imported from Data.ByteString),
02:54:53 <jonashw> thought not
02:55:03 <jonashw> foldr wouldn't make sense with strict semantics
02:55:16 <MP2E> it does make sense, it's just not very useful :P
02:55:16 <jle`> the analogy isn't as perfect as i drew it, i realized >_>
02:55:27 <kazagistar> augur_: have you used Aeson before? the idea is you have to implement FromJSON" for your datatype(s) using applicative notation
02:55:44 <augur_> kazagistar: yes, the aeson docs are better
02:55:47 <jle`> but yeah.
02:55:54 <jonashw> thanks for the tour, jle
02:55:56 <jonashw> `
02:55:58 <jle`> seq x y says "when you want y, evaluate x"
02:56:28 <jle`> and you sort of have to get used to the intuition behind it
02:56:30 <kazagistar> augur_: I suspect that if you copy it verbatim and replace the import with yaml, you will get yaml
02:56:33 <jle`> @src foldl'
02:56:33 <lambdabot> foldl' f a []     = a
02:56:34 <lambdabot> foldl' f a (x:xs) = let a' = f a x in a' `seq` foldl' f a' xs
02:56:42 <augur_> kazagistar: im just going to use JSON
02:56:58 <jonashw> and we started with..
02:57:01 <jonashw> @src ($!)
02:57:02 <lambdabot> f $! x = x `seq` f x
02:57:03 <Qfwfq> yaml uses aeson's representation and instances iirc
02:57:12 <jle`> see, let a' = f a x in seq a' (foldl' f a' xs)
02:57:14 <jle`> says
02:57:21 <jle`> "when you try to evaluate foldl' f a' xs..."
02:57:30 <Qfwfq> (and you can just derive those using generics)
02:57:34 <jle`> "evaluate the a'"
02:57:59 <jle`> so basically you always pass an "evaluated" value a' into foldl' f a' xs
02:58:24 <kazagistar> augur_: yeah, you can chose whichever one you want without changing code later on anyways
02:58:42 <jonashw> :t seq
02:58:43 <lambdabot> a -> b -> b
02:58:48 <jonashw> @src seq
02:58:48 <lambdabot> Source not found. Are you typing with your feet?
02:58:51 <jonashw> lol
02:59:12 <jle`> it's sort of for the runtime
02:59:17 <jle`> implemented at the compiler/runtime level
02:59:24 <jle`> you can think of it as a primitive
02:59:32 <jonashw> ok
02:59:34 <jle`> let's try evaluating foldl (+) 0 [1,2,3]
02:59:38 <jle`> @src foldl
02:59:38 <lambdabot> foldl f z []     = z
02:59:38 <lambdabot> foldl f z (x:xs) = foldl f (f z x) xs
03:00:08 <jle`> foldl (+) 0 (1:(2:3:[])) = foldl (+) (0+1) (2:3:[])
03:00:18 <jonashw> yep
03:00:20 <jle`> = foldl (+) ((0+1)+2) (3:[])
03:00:25 <kazagistar> formally speaking, seq means something more like "crash if a contains a crash" but that can only really be reasonably implemented as evaluation
03:00:26 <jle`> etc.
03:00:35 <jle`> so now, let's try foldl'
03:00:39 <jle`> @src foldl'
03:00:40 <lambdabot> foldl' f a []     = a
03:00:40 <lambdabot> foldl' f a (x:xs) = let a' = f a x in a' `seq` foldl' f a' xs
03:00:51 <jonashw> > foldl (+) 0 [1..3] :: Expr
03:00:52 <lambdabot>  0 + 1 + 2 + 3
03:01:16 <jle`> foldl' (+) 0 (1:(2:[])) = let a' = 0 + 1 in a' `seq` foldl' (+) a' xs
03:01:24 <jle`> we try to "expand out" the recursive call
03:01:26 <jle`> but before we do that
03:01:33 <jle`> we "evaluate" a'
03:01:38 <jle`> so a' becomes 1, instead of 0+1
03:01:51 <jle`> so the recursive call is foldl' (+) 1 (2:[])
03:01:57 <jonashw> > foldl' (+) 0 [1..3] :: Expr
03:01:58 <lambdabot>  0 + 1 + 2 + 3
03:02:02 <jle`> instead of foldl (+) (0+1) (2:[])
03:02:15 <jonashw> no thunk there
03:02:34 <jle`> yeah, and it's neat that this "translates well" into pencil-and-paper-evaluation
03:02:42 <jonashw> right
03:02:46 <jle`> which is why haskell is infamously good at equational reasoning
03:02:50 <Abathurr> I think it's kind of interesting though that while a + 0 = a and a - a = 0, a * 0 = 0 and a * -a = -a almost like the two rules are reversed in what they mean. Weird and funny.
03:02:57 <jonashw> you mean "famously"
03:03:06 <jle`> basically seq as "before you expand out the call, 'flatten out' a'"
03:03:11 <jle`> jonashw: maybe i mean both ^.^
03:03:38 <jle`> so then when i pencil-and-paper expand out the recursive call to foldl', i pass in the evaluated a', instead of the unevaluated one
03:03:41 <kazagistar> Abathurr: thats not quite it... replace 0 with 1
03:03:54 <jonashw> @src foldr
03:03:54 <lambdabot> foldr f z []     = z
03:03:54 <lambdabot> foldr f z (x:xs) = f x (foldr f z xs)
03:04:06 <jonashw> foldl is tail-recursive, foldr is not
03:04:13 <jle`> and so then that's how you can implement a foldl contains the correct evaluation model & semantics for your desired computation
03:04:22 <jle`> tail recursion isn't really a real thing in this case
03:04:29 <jle`> what does tail recursion even mean?
03:04:30 <kazagistar> Abathurr: a * 1 = a, a * (1/a) = 1
03:04:38 <jle`> and how is it relevant in pencil-and-paper evaluation?
03:04:45 <kazagistar> Abathurr: 1 is the multiplicative identity
03:04:49 <jle`> in haskell's evaluation semantics?
03:05:07 <jonashw> jle`, well, I know that tail recursive functions can be optimized with tail-call elimination... computation resembles an imperative for-loop
03:05:23 <jonashw> not really anything to do with what you're describing
03:05:27 <jle`> that's only if you have a language that implements function calls as stack frames
03:05:32 <jle`> but function calls aren't stack frames here
03:05:47 <jle`> it's more like tree expansion and reduction
03:06:02 <kazagistar> Abathurr: strings also have an identity that acts the same way, but they lack the inverse and the commutativity
03:06:02 <jle`> so tco doesn't really translate as a useful concept
03:06:04 <jonashw> ok, that makes sense
03:06:21 <jle`> actually
03:06:24 <jle`> if you go to ghci
03:06:30 <jle`> and try doing foldl (+) 0 [1..some large number]
03:06:34 <jle`> you'll get a stack overflow, i believe
03:06:37 <jle`> which really confuses new people
03:06:38 <jonashw> yep
03:06:39 <jle`> heh
03:06:46 <jle`> it's not because of the lack of tco
03:06:51 <jle`> but because of the thunk evaluation process
03:06:55 <jle`> the thunk buildup process
03:07:08 <Abathurr> kazagistar: oh wait yeah I screwed up on that too because a * -a != -a stupid me. If it did though it would be a cool little thing because it would just be a reverse of the two rules... but I get what you mean with 1 as multiplicative identity
03:07:24 <jonashw> jle`: actually it's "out of memory"
03:07:44 <jle`> yeah, but for some reason ghc uses the stack to manipulate thunks
03:07:45 <Abathurr> kazagistar: But I don't really know what you're asking/meaning when you say "figure out what makes those rules fit"
03:07:50 <jonashw> > fold (+) 0 [1..1211212121]
03:07:51 <lambdabot>  Could not deduce (Data.Foldable.Foldable ((->) ([t0] -> t1)))
03:07:51 <lambdabot>    arising from the ambiguity check for ‘e_1011211212121’
03:07:51 <lambdabot>  from the context (Data.Monoid.Monoid t1,
03:07:51 <lambdabot>                    Data.Foldable.Foldable ((->) ([t] -> t1)),
03:07:51 <lambdabot>                    GHC.Num.Num ([t] -> t1),
03:07:54 <jle`> i ... am not totally familiar with the exact mechanism
03:08:02 <jonashw> > foldl (+) 0 [1..1211212121323232]
03:08:06 <lambdabot>  mueval-core: Time limit exceeded
03:08:09 <jonashw> boo
03:08:13 <jle`> in ghc 7.8.2, the stack is essentially unlimited
03:08:39 <kazagistar> Abathurr: eh, what I meant was "plug in something instead of 0 that would work for those rules", in this case 1
03:08:40 <augur_> im getting a bus error when i try to parse JSON :(
03:08:44 <jle`> so those errors don't show up anymore
03:09:12 <jle`> if anything you will run out of memory; more likely you'll give up before anything happens
03:09:16 <kazagistar> Abathurr: so, what is the identity for strings (or lists, in the more general case)?
03:09:23 <Abathurr> kazagistar: Ah okay, I thought you meant that there was some deeper rule that those rules were a consequence of or something
03:09:52 <Abathurr> kazagistar: well identity for strings is the same as for addition right? Because "the dog" plus 0 or "" is still just "the dog"
03:10:15 <jle`> jkjkj
03:10:22 <kazagistar> Abathurr: nailed it ;)
03:11:04 <jle`> sorry, terminal froze a bit
03:11:20 <Abathurr> kazagistar: great! Although, does it make sense for there to be some other rule that you can kind of derive associativity/commutativity/etc. out of? If so I want to find it because that would be cool
03:11:36 <kazagistar> Abathurr: these are not exactly rules, more like "classifications"
03:11:40 <Qfwfq> ^p^n^p^n
03:12:27 <kazagistar> Abathurr: in other words, you can prove all these properties by inspecting numbers and inspecting the definition of (+) over numbers
03:12:43 <Abathurr> kazagistar: Oh, okay.
03:13:07 <Abathurr> kazagistar: So it's more like..empirical rather than some algorithm generating these properties
03:13:22 <kazagistar> Abathurr: thus, real numbers are the datatype, but they fall into the "Abelian Group" under addition as a classification
03:14:47 <Abathurr> kazagistar: Ah okay... I'll have to remember that name. Abelian. Well, if I were interested in doing mathematics in college, do you just like....jump right into this stuff? I've never encountered math like this before
03:14:55 <kazagistar> Abathurr: the idea is that mathematicians (and programmers) are super lazy, and so they try to extract that useful pattern
03:15:00 <Abathurr> kazagistar: Well I mean I Heard all these rules at one time in algebra but not applied like this
03:15:18 <kazagistar> Abathurr: actually, the important part of the name is "Group", abelian just says that it is commutative
03:15:55 <Abathurr> kazagistar: Ah okay. Groups. I'll just look on wikipedia for groups because I want to see some of the whackier ones
03:16:30 <kazagistar> Abathurr: so, if a mathematician proves things about "addition of numbers" he has a small proof, but if he proves it about "abelian groups" he has a bigger proof
03:17:15 <Abathurr> because the abelian group contains more than just numbers?
03:17:57 <Qfwfq> If you prove it in terms of the properties of the group, you prove it for all things that form a group (i.e. have those properties)
03:18:34 <kazagistar> Abathurr: right. And any time you can prove that your "whatever it is" has the properties we mentioned, then all of a sudden you get a bunch of proofs that people have written for groups that you can use along with it
03:18:52 <vanila> groups are so strange
03:18:57 <Qfwfq> In the case of a group, that's left-and-right associativity on the operator and its inverse, identity, and closure.
03:18:58 <vanila> i wish i understood them better
03:19:03 <kazagistar> Abathurr: in the same way, the programmer can write a program to work with numbers, or they can write a program to work with anything that looks "numeric"
03:19:06 <Qfwfq> Also that the inverse workz.
03:19:51 <kazagistar> Abathurr: and when you have something numeric, all you have to do is implement the functions that demonstrate how it acts in a "numeric" way, and then you can use all the existing code for it
03:20:27 <Qfwfq> Is there an algebraic structure that's a ring with signum and abs? Is it called Num? :P
03:20:48 <mayski> Abathurr: I found this useful when doing stuff with groups etc http://www.csun.edu/~asethura/giaa/giaa.pdf
03:21:21 <Abathurr> mayski: Great, thanks. My parents locked down the internet so I can't look at it right now, for some reason I still get IRC though.
03:21:44 <Qfwfq> Why isn't Group used as widely as e.g. Monoid? I mean besides that Monoid is larger than Group.
03:22:03 <mayski> Abathurr: oh ok well it's "gentle introduction to abstract algebra", explains fields, rings and groups and stuff
03:22:19 <kazagistar> Monoid is the minimum you need for doing things in parallel
03:22:39 <kazagistar> in a sense, not formally dont crucify me for abusing the word
03:22:43 <kazagistar> :P
03:22:49 <Qfwfq> I'd like to see mconcat rewritten to use e.g. Strategies by default.
03:22:58 <Qfwfq> Though I guess that could break stuff if instances aren't lawful
03:23:15 <kazagistar> Qfwfq: unlawful instances deserve to be broken
03:23:32 <augur_> the Aeson example just dies without doing anything for me.  :(
03:23:42 <Abathurr> mayski: Awesome, thanks. I'll look at it when the net comes back up
03:23:45 <Qfwfq> augur_: It's probably a compiler bug ;)
03:24:03 <kazagistar> Qfwfq: really though, there is a problem with the way foldl is implemented that would make building it parallel not quite work
03:24:22 <Qfwfq> I think IRC has a file sharing part if you open the right ports, but is complicated.
03:24:40 <Qfwfq> I thought mconcat was written as foldr mappend mempty
03:24:42 <Qfwfq> @src mconcat
03:24:43 <lambdabot> Source not found. Maybe you made a typo?
03:25:14 <Qfwfq> Yeah, the default implementation uses foldr.
03:25:19 <jle`> mconcat is actaully a part of the typeclass
03:25:23 <jle`> for performance or something idk
03:25:33 <Qfwfq> So it can be overriden.
03:25:48 <augur_> Qfwfq: perhaps perhaps
03:25:58 <Qfwfq> I don't know how to ask lambdabot for a typeclass definition though
03:26:15 <jle`> src is just a lookup in a text file
03:26:24 <jle`> you can probably browse the text file to see if it even has it
03:27:03 <Iceland_jack> You can ask lambdabot for some typeclass definitions:
03:27:03 <Iceland_jack> @src [] return
03:27:04 <lambdabot> return x    = [x]
03:27:11 <Qfwfq> @src [] mconcat
03:27:11 <lambdabot> Source not found. stty: unknown mode: doofus
03:27:18 <Qfwfq> @src [a] mconcat
03:27:18 <lambdabot> Source not found. Take a stress pill and think things over.
03:27:34 <Qfwfq> lambdabot: You're rude.
03:27:45 <kazagistar> Abathurr: so yeah, here is the thing, lists concatenation still has associativity and identity, but not other "numberic" properties, so we call it something different (monoid), and it has different function names
03:28:54 <kazagistar> Abathurr: but of course, remember, it is not not that list or concatenation is *just* a monoid, it just happens to be one way we can classify it and use it
03:29:04 <augur_> :t mconcat
03:29:05 <lambdabot> Monoid a => [a] -> a
03:29:32 <augur_> Qfwfq: thats why it wont work. mconcat isnt a class method
03:29:36 <augur_> @src mconcat
03:29:37 <lambdabot> Source not found. The more you drive -- the dumber you get.
03:29:42 <augur_> mm..
03:29:47 <Abathurr> kazagistar: Okay, it's a lot clearer now than it was when I started. Not only did I learn something about Haskell but also about math which is awesome. And so lists can be thought of kind of like a subclass of a monoid, in a way? It shares all of the properties so we can use it like one, but there are also other properties which allow it to be something else?
03:29:48 <augur_> @src [] mappend
03:29:48 <lambdabot> Source not found. There are some things that I just don't know.
03:29:52 <kazagistar> :t fold
03:29:53 <lambdabot> (Monoid m, Foldable t) => t m -> m
03:29:55 <augur_> oh well.
03:29:58 <kazagistar> thats the one you are looking for
03:30:05 <kazagistar> its in Data.Foldable
03:30:44 <kazagistar> :t F.foldl
03:30:45 <lambdabot> Foldable t => (b -> a -> b) -> b -> t a -> b
03:30:49 <kazagistar> etc
03:31:45 <Qfwfq> @src Monoid a => [a] mconcat
03:31:45 <lambdabot> Source not found. Just try something else.
03:32:07 <Qfwfq> @src a mconcat
03:32:07 <lambdabot> Source not found. Abort, Retry, Panic?
03:32:15 <Qfwfq> Whatevs, lammy.
03:33:40 <kazagistar> the problem is if anyone uses the default implementation of F.foldl it will kill any usefulness of parallelism, and rewriting it to support Strategy would ruin the abstract beauty of it :P
03:33:51 <kazagistar> foldr f z t = appEndo (foldMap (Endo . f) t) z
03:34:14 <Qfwfq> That is pretty.
03:34:35 <jle`> :t ala Endo foldMap
03:34:36 <lambdabot> Foldable t => t (a -> a) -> Unwrapped (Endo a)
03:34:51 <jle`> :t ala Endo foldMap `asAppliedTo` []
03:34:51 <lambdabot> [a -> a] -> a -> a
03:35:13 <Taneb> jle`, what magic
03:35:37 <Qfwfq> Optickz
03:35:47 <kazagistar> deep magic O_o
03:36:20 <kazagistar> Abathurr: sure. In fact, you will often see such relations explicity in haskell
03:37:13 <Qfwfq> Magma => Semigroup => Monoid => Group => Ring
03:37:24 <kazagistar> Abathurr: for example the Ord typeclass (things for which comparisions are well defined) requires an Eq typeclass (things for which equality is well defined)
03:37:46 <kazagistar> or what Qfwfq said if you wanna go deep with it :P
03:37:56 <jle`> => Field
03:38:06 <Qfwfq> Oh yeah.
03:38:24 <Qfwfq> Algebra needs more UML diagrams.
03:38:55 <kazagistar> and then the Ix typeclass (things which can be used for indexing arrays) requires Ord
03:40:18 * hackagebot safe 0.3.5 - Library of safe (exception free) functions  http://hackage.haskell.org/package/safe-0.3.5 (NeilMitchell)
03:41:23 <kazagistar> UML does support things like interface inheritance just fine, but I don't think they have a good way of formalizing type signatures?
03:42:00 <Qfwfq> Well the lens diagram just lists signatures in the node body.
03:42:07 <kazagistar> (since they are so confused about if they want to be relational or not)
03:42:22 <Qfwfq> But that's not structural.
03:43:52 <kazagistar> UML does not really support typeclasses in the method signatures, because it wasn't really meant for that kind of reasoning
03:45:12 <jonashw> :t (\(a,b) -> a == b)
03:45:13 <lambdabot> Eq a => (a, a) -> Bool
03:45:21 <Iceland_jack> :t uncurry (==)
03:45:22 <lambdabot> Eq b => (b, b) -> Bool
03:45:23 <jonashw> any way to write that in point-free?
03:45:29 <Qfwfq> Heh.
03:45:36 <kazagistar> I guess it does support arbitrary type expressions
03:45:38 <jonashw> wha
03:45:43 <Iceland_jack> you can also ask lambdabot
03:45:43 <Iceland_jack> @pl f (a, b) = a == b
03:45:44 <lambdabot> f = uncurry (==)
03:45:46 <Qfwfq> @src uncurry
03:45:47 <lambdabot> uncurry f p = f (fst p) (snd p)
03:46:04 <Iceland_jack> @pl \(a, b) -> a == b
03:46:04 <lambdabot> uncurry (==)
03:46:12 <jonashw> what package is that in? prelude?
03:46:16 <jonashw> module*
03:46:19 <kazagistar> jonashw: dont worry, IRCs psychic predictive powers are here for
03:46:22 <Iceland_jack> Data.Tuple
03:46:33 <Qfwfq> It's exposed by the Prelude, but defined in Data.Tuple.
03:46:40 <jonashw> you guys are awesome
03:47:11 <kazagistar> just ask lambdabot with @pl and it will spit out some nonsense that works back at you automatically
03:47:12 <rola> @pl (\a b c → a == b == c)
03:47:12 <lambdabot> (line 1, column 10):
03:47:12 <lambdabot> unexpected "\134"
03:47:12 <lambdabot> expecting pattern or "->"
03:47:13 <Qfwfq> I think Data.Tuple defined fst, snd, swap, uncurry and curry.
03:47:26 <rola> @pl (\a b c -> a == b == c)
03:47:26 <lambdabot> (line 1, column 22):
03:47:26 <lambdabot> unexpected "c"
03:47:26 <lambdabot> expecting space
03:47:26 <lambdabot> ambiguous use of a non associative operator
03:47:36 <jonashw> pl stands for?
03:47:40 <Iceland_jack> pointless
03:47:44 <Iceland_jack> yes, and most of those are exported by Prelude anyway
03:47:46 <jonashw> COOL
03:47:47 <rola> http://hackage.haskell.org/package/pointfree
03:48:21 <jonashw> my god, I am surprised by something every day
03:48:30 <jonashw> (in Haskell)
03:48:33 <kazagistar> @pl (\a b c -> a == b && b == c)
03:48:33 <lambdabot> (`ap` (==)) . (((.) . (&&)) .) . (==)
03:48:41 <kazagistar> beautiful
03:48:48 <jonashw> yuck
03:48:49 <Pythonfant> definitly more readable
03:48:49 <rola> @pl (\a b c -> a == (b == c))
03:48:50 <lambdabot> (. (==)) . (.) . (==)
03:48:53 <Iceland_jack> only reason to import Data.Tuple is if you want 'swap' or if you're not using Prelude
03:48:59 <rola> @pl (\a b c -> (a == b) == c)
03:48:59 <lambdabot> ((==) .) . (==)
03:49:04 <Iceland_jack> rola: that probably doesn't do what you want
03:49:12 <Iceland_jack> @ty (\a b c -> a == (b == c))
03:49:13 <lambdabot> Eq a => Bool -> a -> a -> Bool
03:49:14 <Qfwfq> :t fmap (==) `fmap` (==)
03:49:15 <lambdabot> Eq a => a -> a -> Bool -> Bool
03:49:24 <Iceland_jack> @ty \a b c -> a == b && b == c
03:49:25 <lambdabot> Eq a => a -> a -> a -> Bool
03:49:41 <Qfwfq> :t fmap (==) . (==)
03:49:41 <lambdabot> Eq a => a -> a -> Bool -> Bool
03:49:42 <jonashw> holy shit, uncurry.. fantastic
03:49:55 <Qfwfq> :t fmap (flip (==)) . (==)
03:49:56 <lambdabot> Eq a => a -> a -> Bool -> Bool
03:50:09 <jonashw> uncurry actually makes my haskell *more* spicy rather than less
03:50:32 <Qfwfq> Oh right, the precedence is such that a needs be Bool
03:50:37 <kazagistar> jonashw: that said, the uses of uncurry and curry tend to be limited to dealing with functions that return multiple outputs, like state functions
03:50:46 <augur_> im trying to make ghc use the clang wrapper and im getting told "command not found". anyone know what i need to do?
03:50:47 <Qfwfq> (a == b) && (b==c) captures the expected semantics.
03:50:51 <Iceland_jack> not really precedence but yes
03:51:20 <Qfwfq> Well, one function application is applied at the same time.
03:51:27 <luzie> @pl f y = ((y * 2 + 1) * w + x) * 4 + 3
03:51:27 <lambdabot> f = (3 +) . (4 *) . (x +) . (w *) . (1 +) . (2 *)
03:51:30 <augur_> @hoogle Eq a => [a] -> Bool
03:51:31 <lambdabot> Prelude elem :: Eq a => a -> [a] -> Bool
03:51:32 <lambdabot> Data.List elem :: Eq a => a -> [a] -> Bool
03:51:32 <lambdabot> Prelude notElem :: Eq a => a -> [a] -> Bool
03:51:32 <Qfwfq> :t \a b c -> foldr (==) c [a,b,c]
03:51:33 <lambdabot> Bool -> Bool -> Bool -> Bool
03:51:41 <Qfwfq> Oh, duh.
03:52:07 <augur_> you should just do   foldr (==) True [a,b,c]
03:52:10 <augur_> make a generic function
03:52:20 <augur_> allEqual xs = foldr (==) True xs
03:52:29 <augur_> :t foldr (==) True
03:52:29 <lambdabot> [Bool] -> Bool
03:52:30 <Qfwfq> That's equivalent to all.
03:52:42 <augur_> whoops. thats not what i wanted :D
03:53:12 <augur_> well anwyay, make a listy function
03:53:52 <Qfwfq> You'd need a product of terms, I think.
03:54:02 <kazagistar> well, all has some extra noise about converting to bool, so not quite, it is equivalent to "all id"
03:54:49 <Qfwfq> \a b c -> all (==a) [a,b,c]
03:54:53 <augur_> allEqual [] = True ; allEqual (x:xs) = foldr (\x' b -> x' == x && b) True xs
03:54:57 <augur_> i think thats what you want.
03:55:26 <Qfwfq> No, that only works for a list of bools.
03:55:37 <augur_> no it should work for all lists
03:55:41 <Qfwfq> Oh no, sorry, I misread.
03:55:57 <augur_> :t \(x:xs) -> foldr (\x' b -> x' == x && b) True xs
03:55:58 <lambdabot> Eq a => [a] -> Bool
03:56:00 <kazagistar> you really should just drop the a in the list
03:56:01 <Qfwfq> That's a cute definition.
03:56:22 <augur_> actually, better to use all
03:56:33 <augur_> allEqual [] = True ; allEqual (x:xs) = all (x==) xs
03:56:39 <Qfwfq> Yeah.
03:56:54 <Qfwfq> I was halfway through a line writing it with head, but that isn't complete.
03:57:16 <augur_> i need to figure out this bus error thing
03:57:19 <augur_> this is really frustrating
03:58:02 <Qfwfq> :set formatprg=djinn
03:58:31 <kazagistar> @pl allEqual (x:xs) = all (x==) xs
03:58:31 <lambdabot> allEqual = ap (all . (==) . head) tail
03:58:48 <augur_> @djinn Eq a => [a] -> Bool
03:58:48 <lambdabot> Error: Undefined type []
03:58:52 <augur_> awful
03:59:06 <kazagistar> djinn is the worst
03:59:20 <Qfwfq> @djinn (a -> a -> Bool) -> [a] -> Bool
03:59:20 <lambdabot> Error: Undefined type []
03:59:56 <Qfwfq> @djinn Foldable f => Eq a => f a -> Bool
03:59:56 <lambdabot> Cannot parse command
04:00:08 <jonashw> :t ap
04:00:09 <lambdabot> Monad m => m (a -> b) -> m a -> m b
04:00:24 <augur_> theres some problem with type classes in djinn unfortunately
04:00:25 <Qfwfq> :t ap (,)
04:00:25 <lambdabot> (a -> b) -> a -> (a, b)
04:00:27 <jonashw> :t ap (all.(==).head)
04:00:28 <lambdabot> Eq a => ([a] -> [a]) -> [a] -> Bool
04:00:57 <kazagistar> @pl allEqual list = case list of { [] -> True; (x:xs) -> all (==x) xs }
04:00:57 <lambdabot> (line 1, column 30):
04:00:57 <lambdabot> unexpected '{'
04:00:57 <lambdabot> expecting variable, "(", operator or end of input
04:01:12 <augur_> :t list
04:01:13 <lambdabot>     Not in scope: ‘list’
04:01:13 <lambdabot>     Perhaps you meant one of these:
04:01:13 <lambdabot>       ‘last’ (imported from Data.List),
04:01:21 <rola> :t <$>
04:01:22 <lambdabot> parse error on input ‘<$>’
04:01:29 <rola> :t (<$>)
04:01:30 <lambdabot> Functor f => (a -> b) -> f a -> f b
04:01:31 <augur_> i thought list was the case function for lists. guess not.
04:01:57 <jonashw> kazagistar, of those two 'allEqual' functions, which do you prefer?  I like the first one, with the pattern matching
04:02:29 <kazagistar> jonashw: of which two?
04:02:39 <ebaldwin> dcoutts: please check your emial
04:02:51 <jonashw> ap allEqual = (all . (==) . head) tail        vs          allEqual (x:xs) = all (x==) xs
04:02:51 <rola> What are types like 'f a' or 'm a' or 'IO String' called?
04:03:22 <jonashw> 'f','a','m' are type variables
04:03:43 <Qfwfq> f, m, a have kind at least * -> *
04:04:00 <Qfwfq> Sorry; f, m, IO.
04:04:20 <kazagistar> jonashw: oh, certainly the second, point free syntax fails comprehensability very quickly
04:04:28 <Qfwfq> Unary product types? idk.
04:04:31 <kazagistar> :t allEqual list = if null list then True else all (== head list) (tail list)
04:04:32 <lambdabot> parse error on input ‘=’
04:04:48 <kazagistar> @pl allEqual list = if null list then True else all (== head list) (tail list)
04:04:48 <lambdabot> allEqual = ap (flip if' True . null) (ap (all . (==) . head) tail)
04:05:20 * hackagebot twitter-conduit 0.0.5 - Twitter API package with conduit interface and Streaming API support.  http://hackage.haskell.org/package/twitter-conduit-0.0.5 (TakahiroHimura)
04:05:25 <kazagistar> :t if'
04:05:26 <lambdabot>     Not in scope: ‘if'’
04:05:26 <lambdabot>     Perhaps you meant ‘f'’ (imported from Debug.SimpleReflect)
04:05:30 <jonashw> though, the point free version does read better with the spaces removed: ap (all.(==).head) tail
04:05:38 <augur_> if' :: Bool -> a -> a -> a
04:05:40 <Iceland_jack> :t bool
04:05:40 <lambdabot> a -> a -> Bool -> a
04:05:47 <Iceland_jack> > bool 't' 'f' True
04:05:48 <lambdabot>  'f'
04:05:59 <Iceland_jack> > flip bool 't' 'f' True
04:06:01 <lambdabot>  't'
04:06:01 <Iceland_jack> ;)
04:06:38 <rola> jonashw, Qfwfq, i mean to say types with spaces in them
04:06:51 <kazagistar> jonashw: typefree suffers from the Forth effect, where you have to manually track stack variables in your head
04:07:12 <augur_> rola: types like `f a` are just types. `f` is a parametric type
04:07:15 <jonashw> parametric type?
04:07:16 <augur_> or a type operator
04:07:16 <Qfwfq> rola: I suggested 'unary product types'. You can say 'parametrised type', it's a type taking at least one parameter, i.e. at least * -> *
04:07:19 <jonashw> yeah. parametric type
04:07:35 <augur_> rola: but keep it mind, its `f` which is the parametric type, NOT `f a`
04:07:43 <Qfwfq> rola: Do I know you from somewhere?
04:08:20 <Qfwfq> Oh, I know where.
04:09:59 <jonashw> kazagistar, when I google "Forth effect", I don't find anything substantial. Is that a term from somewhere in particular?
04:10:36 <kazagistar> jonashw: sorry, I made it up, but it is in reference to the programming language
04:11:15 <jonashw> oh, Forth the language
04:11:49 <kazagistar> yeah, also known as the "purely pointfree" language (by me)
04:12:05 <rola> hum
04:12:44 <Qfwfq|afk> @kind IO
04:12:45 <lambdabot> * -> *
04:12:47 <Qfwfq|afk> @kind []
04:12:48 <lambdabot> * -> *
04:12:50 <kazagistar> it is a simple and elegant design, but programming in it makes me hate everything
04:12:51 <Qfwfq|afk> @kind Either
04:12:52 <lambdabot> * -> * -> *
04:13:00 * Qfwfq|afk actually afk
04:13:08 <Iceland_jack> @kind forall a. Either a
04:13:09 <lambdabot> * -> *
04:13:10 <jonashw> kazagistar, lol I know the feeling
04:13:56 <kazagistar> but writing a Forth interpreter is an OK task for picking up a new language
04:14:25 <jonashw> because of the notation Forth uses?
04:14:37 <kazagistar> because it is so utterly minimal
04:14:43 <jonashw> yeah it is
04:14:49 <jonashw> 25 10 * 50 + .
04:14:53 <jonashw> remember what that does?
04:15:09 <deni> anyone having issue with vim and GhcModeType ? i keep getting "cannot guess type" for everything
04:15:21 * hackagebot Chart-diagrams 1.0 - Diagrams backend for Charts.  http://hackage.haskell.org/package/Chart-diagrams-1.0 (TimDocker)
04:15:25 <kazagistar> :SQUARE DUP * ;
04:15:47 <Iceland_jack> kazagistar: instead of the much saner 'join (*)' :)
04:16:14 <jonashw> :t join
04:16:15 <kazagistar> :PYTHAG SQUARE SWAP SQUARE + SQRT ;
04:16:15 <lambdabot> Monad m => m (m a) -> m a
04:16:27 <Iceland_jack> > join (*) 11
04:16:28 <lambdabot>  121
04:16:30 <jonashw> kazagistar, I'm sorry I did that to you
04:17:04 <jonashw> it looks like some crazed robot language
04:17:14 <jonashw> with all the caps
04:17:14 <kazagistar> thats just the allcaps :P
04:17:18 <Iceland_jack> Forth is an old language though
04:17:28 <kazagistar> but I was trying to write idiomatically haha
04:17:29 <Iceland_jack> there are more modern alternatives
04:17:35 <jonashw> BOOP BEEP _ BAP BOOP BEEP .
04:17:57 <kazagistar> :NAME starts a word definition, ; ends it
04:17:59 <jonashw> DESTROY THE HUMANS
04:18:04 <deni> bah nevermind....it can't gues the type if there is a compilation error
04:18:05 <jonashw> ok
04:18:11 <kazagistar> the stuff in between are just commands that are run and modify the stack
04:18:43 <kazagistar> DUP duplicated the top item on the stack, SWAP swaps the top two items on the stack, etc
04:23:16 <kazagistar> it seems sane until you try to implement something even remotely complex
04:23:42 <jonashw> I think I just walked up to the clip overlooking cabal hell.  I am staring down at "cabal: the following packages are likely to be broken by the reinstalls: lens-4.2  Use --force-reinstalls if you want to install anyway."
04:23:47 <jonashw> clif*
04:23:58 <jonashw> f
04:24:35 <jonashw> (trying to install hoogle)
04:24:46 <kazagistar> sandbox it, and then burn it with fire if it fails :P
04:25:04 <jonashw> I'm not even going to try that.. at least not yet
04:25:13 <jonashw> I'll just turn around and walk away
04:25:21 <jonashw> no hoogle for me tonight
04:32:54 <jonashw> to the vimmers in the audience: what is your must-have haskell/vim integration feature?
04:33:28 <popx> jonashw: I haven't found any really good integration...
04:33:29 <CindyLinz> jonashw: jump to the correct function definition
04:34:06 <ttll> jonashw: syntastic is somewhat useful but I'm still looking for better solutions
04:34:11 <popx> jonashw: easytags with hasktags is nice to jump to definitions
04:34:20 <CindyLinz> with ctags, only one target could be set for one-file-one-name
04:34:34 <ttll> syntastic with hdevtools installed
04:34:42 <CindyLinz> easytags is something like ctags.. @@"
04:35:03 <hpc> automatically get the hackage docs for an identifier
04:35:17 <jonashw> ttll, so do you use syntastic with hdvetools AND ghcmod, or is it just syntastic with hdevtools?
04:35:44 <hpc> online, so it works with setups that don't have a full workspace setup
04:41:15 <jonashw> hey benzrf
04:42:59 <ttll> I'm not quite sure, in ~/.cabal/bin is hdevtools and ghc-modi
04:43:09 <ttll> ghc-mod alone is a pretty slow
04:43:38 <ttll> I still haven't found a good indentation plugin though
04:55:24 * hackagebot Chart 1.2.3 - A library for generating 2D Charts and Plots  http://hackage.haskell.org/package/Chart-1.2.3 (TimDocker)
04:55:26 * hackagebot twitter-conduit 0.0.5.1 - Twitter API package with conduit interface and Streaming API support.  http://hackage.haskell.org/package/twitter-conduit-0.0.5.1 (TakahiroHimura)
04:55:28 * hackagebot Chart-cairo 1.2.3 - Cairo backend for Charts.  http://hackage.haskell.org/package/Chart-cairo-1.2.3 (TimDocker)
04:55:30 * hackagebot Chart-simple 1.2.3 - A wrapper for the chart library to assist with basic plots  http://hackage.haskell.org/package/Chart-simple-1.2.3 (TimDocker)
04:55:32 * hackagebot Chart-gtk 1.2.3 - Utility functions for using the chart library with GTK  http://hackage.haskell.org/package/Chart-gtk-1.2.3 (TimDocker)
05:00:34 * hackagebot Chart-diagrams 1.2.3 - Diagrams backend for Charts.  http://hackage.haskell.org/package/Chart-diagrams-1.2.3 (TimDocker)
05:11:59 <darveter> @pl (\a -> a*a)
05:12:00 <lambdabot> join (*)
05:12:17 <darveter> > oin (*) 3
05:12:19 <lambdabot>  Not in scope: ‘oin’
05:12:19 <lambdabot>  Perhaps you meant one of these:
05:12:19 <lambdabot>    ‘sin’ (imported from Prelude), ‘min’ (imported from Data.Ord),
05:12:19 <lambdabot>    ‘join’ (imported from Control.Monad.Writer)
05:12:31 <darveter> > join (*) 3
05:12:33 <lambdabot>  9
05:13:22 <darveter> :t join (*)
05:13:23 <lambdabot> Num a => a -> a
05:16:08 <wz1000> Why is 'type IO a = RestOfTheWorld -> (a, RestOfTheWorld)' a flawed model of IO?
05:17:07 <hpc> wz1000: it doesn't handle concurrency properly
05:17:37 <hpc> also, it presumes a pure function of type World -> World exists
05:17:41 <hpc> for something like sleep, say
05:18:06 <wz1000> Oh OK, only one action can run at a time
05:18:07 <hpc> if you sleep your program for a year, the next state of the world could be anything
05:18:44 <Hodapp> Rip van Haskell?
05:19:27 <wz1000> If we take our function to  operate instantaneously, is it an ok model?
05:24:08 <simukis_> wz1000: I think this model works with pure functions for the same reason it works with logical gates.
05:27:23 <Trollinator> is there a way to show the definition of a type class in GHCi?
05:27:45 <identity> you can see the functions it consists of using :info
05:27:49 <identity> @info Num
05:27:49 <lambdabot> Num
05:27:55 <Trollinator> thanks.
05:28:04 <identity> works in ghci
05:36:35 <DarkCthulhu> Hi, I have a question. http://ideone.com/fguh4J I've identified the error but I read that $ was a thing you could replace pairs of parentheses with. However, here, the $ causes it to become incorrect. How exactly does $ work?
05:39:21 <nadirs> anyone using ghc-mod on vim? I'd like to have the GHC error messages to be output in a buffer instead of the "vim command line" (which is just one single line so the message gets cut).
05:39:28 <nadirs> I can use ":GhcModExpand" but I'd like it to auto-update the same way the command line does
05:41:00 <Fuuzetsu> which module has readMaybe again?
05:41:33 <nadirs> :hoogle readMaybe
05:41:33 <Fuuzetsu> oh, Text.Read
05:41:39 <Fuuzetsu> @hoogle readMaybe
05:41:39 <lambdabot> Data.Graph.Inductive.Internal.Thread threadMaybe :: (i -> r -> a) -> Split t i r -> SplitM t j i -> SplitM t j a
05:41:39 <lambdabot> Data.Graph.Inductive.Internal.Thread threadMaybe' :: (r -> a) -> Split t i r -> Split t j (Maybe i) -> Split t j (Maybe a)
05:41:41 <Fuuzetsu> ;)
05:41:43 <nadirs> oh, right
05:41:52 <Black0range> Hey guys I'm new to haskell and i'm just trying to compile a module file. but it complains about a "main function"
05:41:55 <Black0range> what to do?
05:42:18 <Fuuzetsu> add a main function
05:42:24 <nadirs> is it meant to be an executable or a library?
05:42:28 <pavonia> DarkCthulhu: You can think of $ as "put parentheses around everything to the left and to the right", so here it is parsed as "(print$ sum_even) $ (0 [1,3,4,5,6])"
05:42:29 <HugoDaniel> main = undefined :D
05:42:29 <Black0range> library :)
05:42:45 <Fuuzetsu> main = shootmissiles
05:42:45 <nadirs> do you have a "yourlib.cabal" file?
05:42:50 <pavonia> DarkCthulhu: which means you're trying to appliy 0 to a list
05:43:11 <Black0range> Fuuzetsu: i like your thinking
05:43:26 <Black0range> nadirs: No i do not :/
05:43:34 <nadirs> Black0range: "cabal init"
05:43:37 <nadirs> :)
05:43:57 <DarkCthulhu> pavonia: The error seems to indicate that Show got 2 arguments instead of 1.
05:44:17 <DarkCthulhu> pavonia: I thought what happened was the $ caused the sum_even to get only 1 argument and bound the other argument to print.
05:44:43 <Black0range> nadirs: oooh so how do i load this library? :)
05:45:06 <nadirs> Black0range: if you just want to use it in a ghci session you don't need the cabal file, just :load it in ghci
05:45:32 <pavonia> DarkCthulhu: The error message can be misleading, the problem is the part after the second $
05:45:37 <Black0range> yeah but i want it compled :) (doing some speed testing schtuff)
05:45:43 <Black0range> compiled*
05:45:46 <DarkCthulhu> pavonia: Okay.. ty
05:45:54 <pavonia> > f $ x y
05:45:55 <lambdabot>  Couldn't match expected type ‘Debug.SimpleReflect.Expr.Expr -> s0’
05:45:55 <lambdabot>              with actual type ‘Debug.SimpleReflect.Expr.Expr’
05:46:13 <pavonia> > f $ g x
05:46:14 <lambdabot>  Could not deduce (GHC.Show.Show s0)
05:46:14 <lambdabot>    arising from a use of ‘Debug.SimpleReflect.Vars.f’
05:46:14 <lambdabot>  from the context (Debug.SimpleReflect.Expr.FromExpr t)
05:46:14 <lambdabot>    bound by the inferred type of
05:46:14 <lambdabot>             it :: Debug.SimpleReflect.Expr.FromExpr t => t
05:46:22 <nadirs> Black0range: in that case you might need the cabal file, after all :P
05:46:38 <Black0range> nadirs: i just made one :) soo how do i load it in ghci? :)
05:46:40 <DarkCthulhu> pavonia: That error message really sucks :/
05:47:05 <nadirs> Black0range: ":load Filename.hs" should work
05:47:08 <DarkCthulhu> pavonia: One more question, I am unable to replace the type signature of "sum_even :: Integer -> [Integer] -> Integer" with "sum_even :: (Num a) => a -> a -> a". Why doesn't this work?
05:47:17 <DarkCthulhu> Oh wait.
05:47:35 <DarkCthulhu> sum_even :: (Num a) => a -> [a] -> a
05:47:38 <nadirs> Black0range: but I'm afraid (not sure) it's not compiled with optimization
05:48:30 <Fuuzetsu> any good way to tell the defauting GHC warning to go and piss off except for inlining a type signature?
05:48:37 <nadirs> Black0range: to compile it and load it with "import" you need to "cabal build" it. Just make sure to do it in a "cabal sandbox" in order to avoid polluting your global/user space
05:48:44 <pavonia> DarkCthulhu: Also, instead of using head and tail on list we usually use (x : xs) as pattern directly in Haskell
05:49:05 <avallark> hello all :) newbie here
05:49:24 <DarkCthulhu> pavonia: I studied the pattern syntax, and guards as well :) I was just doing some particular tutorial.
05:49:38 <nadirs> Black0range: or maybe it was "cabal install" instead of "cabal build"? First of all run "cabal sandbox init" from inside the folder where your module is
05:50:21 <DarkCthulhu> pavonia: http://ideone.com/fguh4J Why does this fail?
05:51:07 <pavonia> For using even the constraint Num is not enought, it has to be an Integral
05:51:14 <pavonia> :t even
05:51:15 <lambdabot> Integral a => a -> Bool
05:51:28 <DarkCthulhu> pavonia: Oh! That makes sense
05:51:35 <Black0range> nadirs: this turned out to be a more confusing then i anticipated
05:51:53 <DarkCthulhu> pavonia: ty! I thought I was messing up syntax somehow.
05:51:57 <nadirs> Black0range: it's probably my fault, I'm not exactly an expert :P
05:52:23 <Black0range> nadirs: naah dont worry you got me in the right direction! :) Thanks mate
05:52:37 <nadirs> Black0range: no problem :)
05:54:12 <ACSpike[laptop]> reading a tutorial, a thought just occured to me… default parameters to functions lots of imperitive languages have this in some fashion. what do we have in haskell? Is currying the right answer? are there others?
05:57:50 <hpc> ACSpike[laptop]: generally you do something like
05:58:17 <wz1000> ACSpike[laptop]: You can use typeclasses to implement default parameters if you really want to
05:58:18 <hpc> data FooOptions = FooOptions {optionOne :: Int, optionTwo :: String}
05:58:34 <hpc> defaultOptions = FooOptions {optionOne = 5, optionTwo = "yes"}
05:58:40 <hpc> and then when you use it
05:58:48 <hpc> foo defaultOptions {optionTwo = "no"}
05:59:09 <ACSpike[laptop]> hpc, is that what’s called a record?
05:59:14 <hpc> that is a record
05:59:34 <hpc> (the data definition is, not the whole concept)
05:59:47 <ACSpike[laptop]> hpc: yup, thanks
06:00:07 <ACSpike[laptop]> wz1000: tell me about doing it with type classes
06:02:09 <augur_> i think its weird that update syntax binds tighter than application
06:02:10 <augur_> :(
06:02:15 <augur_> record update syntax*
06:02:40 <hpc> augur_: there are much weirder things
06:02:45 <augur_> hpc: :)
06:02:49 <wz1000> ACSpike[laptop]: here you go: http://stackoverflow.com/questions/7781096/is-there-a-better-way-to-have-optional-arguments-in-haskell
06:03:03 <ACSpike[laptop]> wz, thanks
06:03:10 <ACSpike[laptop]> wz1000: thanks
06:04:17 <Fuuzetsu> ffs, can café admin kick off zhangliu529@sina.com already?
06:05:31 * hackagebot hmatrix 0.16.0.4 - Numeric Linear Algebra  http://hackage.haskell.org/package/hmatrix-0.16.0.4 (AlbertoRuiz)
06:05:33 * hackagebot hmatrix-glpk 0.4.0.1 - Linear Programming based on GLPK  http://hackage.haskell.org/package/hmatrix-glpk-0.4.0.1 (AlbertoRuiz)
06:05:35 * hackagebot hmatrix-gsl 0.16.0.1 - Numerical computation  http://hackage.haskell.org/package/hmatrix-gsl-0.16.0.1 (AlbertoRuiz)
06:05:37 * hackagebot hmatrix-special 0.3.0.1 - Interface to GSL special functions  http://hackage.haskell.org/package/hmatrix-special-0.3.0.1 (AlbertoRuiz)
06:05:39 * hackagebot hmatrix-tests 0.4.0.1 - Tests for hmatrix  http://hackage.haskell.org/package/hmatrix-tests-0.4.0.1 (AlbertoRuiz)
06:06:49 <Clint> ivanm: i don't see a "graphviz" function in there
06:14:48 <rola> :k Maybe
06:14:49 <lambdabot> * -> *
06:14:53 <rola> :k fmap
06:14:54 <lambdabot> Not in scope: type variable ‘fmap’
06:15:07 <rola> :k []
06:15:08 <lambdabot> * -> *
06:15:19 <rola> :k IO
06:15:20 <lambdabot> * -> *
06:18:54 <nadirs> how is a type with kind "* -> *" called?
06:19:18 <hpc> there's not really a good word
06:19:46 <hpc> the closest is type function, but we don't really have a powerful enough type system to make that not a bit misleading
06:19:47 <Hafydd> A unary type constructor?
06:19:49 <Fuuzetsu> I wish _ was True in guards
06:19:52 <c_wraith> types with kinds that unify with k -> * are generally called type constructors
06:20:01 <c_wraith> err.  That's not true.  too restrictive
06:20:04 <nadirs> hpc: would "types that take one type parameter" make sense?
06:20:17 <c_wraith> nadirs: (* -> *) -> * would also fit
06:20:20 <hpc> it's not a type until it's of kind *
06:20:28 <nadirs> c_wraith: ah, right
06:20:53 <hpc> also don't use type constructor as a generic term for things of kind k -> *
06:20:53 <c_wraith> types that when applied to enough arguments result in kind * are called type constructors.
06:20:54 <nadirs> so it's a type constructor until it's reduced to just "kind *"
06:20:57 <nadirs> <'
06:20:57 <Fuuzetsu> hpc: what do we call it then? Type constructor?
06:21:06 <Fuuzetsu> isn't this why we have a ‘concerete type’ distinction?
06:21:06 <hpc> type constructor only refers to the ones with Capital First Letters
06:21:19 <hpc> same way you wouldn't call (+ 5) a data constructor
06:21:36 <c_wraith> hpc: type functions aren't types.
06:22:22 <hpc> ah
06:22:28 <c_wraith> hpc: and restricting it to capital first letters doesn't eliminate type functions anyway
06:22:37 <hpc> well anyway, there's definitely not a good word for it or we could all agree on it
06:22:46 <nadirs> so is it wrong to refer to "* -> *" as "the kind of a type"?
06:22:53 <hpc> nadirs: that is correct
06:23:15 <c_wraith> I don't see a problem with that.  Maybe is a type.  It's just not concrete.
06:23:48 <Fuuzetsu> @hoogle Either a b -> b -> b
06:23:49 <lambdabot> Data.Generics.Aliases ext2B :: (Data a, Typeable2 t) => a -> (forall d1 d2. (Data d1, Data d2) => (t d1 d2)) -> a
06:23:49 <lambdabot> Data.Graph.Inductive.Graph deg :: Graph gr => gr a b -> Node -> Int
06:23:49 <lambdabot> Data.Graph.Inductive.Graph indeg :: Graph gr => gr a b -> Node -> Int
06:23:59 <hpc> yeah, i derped a bit there :P
06:25:10 <nadirs> is it correct to say that "* -> *" is the kind required to create a Functor instance?
06:25:14 <Fuuzetsu> is there ‘f x = either (const x) id’ out there somewhere?
06:25:21 <c_wraith> nadirs: absolutely
06:25:35 <nadirs> c_wraith: nice, thanks
06:26:15 <hpc> Fuuzetsu: if it's not in Data.Either it's probably not anywhere
06:27:00 <Fuuzetsu> Data.Either isn't exactly the biggest module…
06:27:19 <Fuuzetsu> seems useful
06:28:18 <c_wraith> :t flip either id . const
06:28:19 <lambdabot> c -> Either a c -> c
06:28:29 <c_wraith> ...  yay for flip not making anything clearer
06:32:53 <mbrock> the `either' package has fromRight :: b -> Either a b -> b
06:40:53 <Fuuzetsu> is there a ‘safe apply’ for lists, which stops me from having to type out case foo of [] -> []; xs -> someNotTotalFunctionLikeLast xs
06:41:09 <c_wraith> fmap
06:41:16 <c_wraith> oh, nevermind
06:41:18 <Fuuzetsu> nope
06:42:04 <c_wraith> hmm.  there is something you could abuse for that.
06:44:19 <c_wraith> Or not.  I was trying to figure out how to abuse extended for that, but it ends up being just as bad.
06:45:25 <marchelzo_> Fuuzetsu: last returns an element, and [] is a list. The type would be incorrect
06:45:57 <Fuuzetsu> marchelzo_: not if you're working with [[a]]
06:46:47 <c_wraith> at that point, you lose a generic combinator that just takes a function
06:46:53 <c_wraith> You would also need to supply the base case
06:48:20 <Fuuzetsu> I think I'll just write a helper
06:48:26 <Fuuzetsu> @hoogle ([t] -> [a]) -> [t] -> [a]
06:48:27 <lambdabot> Text.XHtml.Strict changeAttrs :: CHANGEATTRS a => a -> ([HtmlAttr] -> [HtmlAttr]) -> a
06:48:27 <lambdabot> Text.XHtml.Frameset changeAttrs :: CHANGEATTRS a => a -> ([HtmlAttr] -> [HtmlAttr]) -> a
06:48:27 <lambdabot> Text.XHtml.Transitional changeAttrs :: CHANGEATTRS a => a -> ([HtmlAttr] -> [HtmlAttr]) -> a
06:49:38 <c_wraith> Fuuzetsu: possibly think of recasting your problem so you could work in terms of extended
06:49:47 <c_wraith> http://hackage.haskell.org/package/semigroupoids-4.0.2.1/docs/Data-Functor-Extend.html
06:54:04 <Fuuzetsu> the signature looks good but does it do what I want for lists?
06:54:09 <Fuuzetsu> :t extended
06:54:10 <lambdabot> Not in scope: ‘extended’
06:54:12 <Fuuzetsu> bah
06:54:31 <c_wraith> extended id is nearly tails, except it doesn't include []
06:55:17 <c_wraith> so, like...   extended last [1,2,3]  would result in [3,3,3]
06:55:18 <Fuuzetsu> Prelude Data.Functor.Extend> extended last ["foo", "bar"]
06:55:18 <Fuuzetsu> ["bar","bar"]
06:55:19 <Fuuzetsu> Prelude Data.Functor.Extend> extended last []
06:55:20 <Fuuzetsu> []
06:55:23 <Fuuzetsu> ;(
06:55:45 <c_wraith> You have to change to a "List of successes" approach
06:56:00 <c_wraith> and then keep in mind that you might have redundant successes
06:56:06 <c_wraith> So only consider the first one.
06:56:12 <Fuuzetsu> I don't care enough for the 2 times I'd use it as I'm probably going to be rewriting this anyway later
06:56:18 <Fuuzetsu> was just wondering
06:57:24 <ivanm> Clint: no, the graphviz package
06:57:30 <ivanm> @hackage graphviz
06:57:30 <lambdabot> http://hackage.haskell.org/package/graphviz
06:57:51 <ivanm> (I didn't think anyone actually used the Graphviz module in FGL, which is one reason why I removed it)
06:58:47 <Clint> ivanm: i understand this, i was just hoping that there would be a simple replacement function so i didn't have to figure out how to get the same effect
07:00:16 <ivanm> graphToDot nonClusteredParams
07:00:46 <Clint> ivanm: and then show?
07:01:01 <ivanm> well, printDotGraph
07:01:16 <ivanm> or see Data.GraphViz.Commands to actually run dot, neato, etc. on it
07:01:20 <ivanm> http://hackage.haskell.org/package/graphviz-2999.17.0.1/docs/Data-GraphViz-Commands.html
07:01:30 <ivanm> http://hackage.haskell.org/package/graphviz-2999.17.0.1/docs/Data-GraphViz-Commands-IO.html
07:02:08 <Clint> ivanm: ok, thanks
07:12:12 <Fuuzetsu> “Yukari-linux-x86_64: Prelude.read: no parse”
07:12:19 <Fuuzetsu> end my suffering for I have made the greatest sin
07:15:38 * hackagebot hopenpgp-tools 0.7.2 - hOpenPGP-based command-line tools  http://hackage.haskell.org/package/hopenpgp-tools-0.7.2 (ClintAdams)
07:17:16 <xenog> does anyone know which is the correct way to do custom read/write instances of things?
07:19:40 <c_wraith> xenog: for what purpose?  pretty-printing?  efficient serialization?
07:19:52 <xenog> primarily for pretty printing
07:20:02 <xenog> but it needs to respect the show . read = id
07:20:36 <xenog> I've seen instances that show things like "fromList [('a', 1), ('b', 2)]"
07:20:40 <quchen> Show is not for prettyprinting. https://github.com/quchen/articles/blob/master/fbut.md#show-is-not-for-prettyprinting
07:20:50 <xenog> thanks
07:22:52 <xenog> so I'm actually looking for the Doc class, it seems
07:25:38 * hackagebot sql-simple 0.2.0 - common middle-level sql client.  http://hackage.haskell.org/package/sql-simple-0.2.0 (HirotomoMoriwaki)
07:25:40 * hackagebot sql-simple-sqlite 0.2.0 - sqlite backend for sql-simple  http://hackage.haskell.org/package/sql-simple-sqlite-0.2.0 (HirotomoMoriwaki)
07:25:42 * hackagebot sql-simple-postgresql 0.2.0 - postgresql backend for sql-simple  http://hackage.haskell.org/package/sql-simple-postgresql-0.2.0 (HirotomoMoriwaki)
07:25:44 * hackagebot sql-simple-mysql 0.2.0 - mysql backend for sql-simple  http://hackage.haskell.org/package/sql-simple-mysql-0.2.0 (HirotomoMoriwaki)
07:26:59 <quchen> Doc is a type, but yes, that's one way to prettyprint things.
07:29:43 <phaazon> hi; I have a scene description (realtime 3D scene) done in a monad transformer. I’d like to create interprets of the scene. Up to know, my idea was something like class (MonadBase (SceneT m) p) => Interpret p where… , but I’m not sure (cc edwardk) ; any idea?
07:30:39 * hackagebot sql-simple-sqlite 0.2.1 - sqlite backend for sql-simple  http://hackage.haskell.org/package/sql-simple-sqlite-0.2.1 (HirotomoMoriwaki)
07:30:41 * hackagebot sql-simple-postgresql 0.2.1 - postgresql backend for sql-simple  http://hackage.haskell.org/package/sql-simple-postgresql-0.2.1 (HirotomoMoriwaki)
07:30:43 * hackagebot sql-simple-mysql 0.2.1 - mysql backend for sql-simple  http://hackage.haskell.org/package/sql-simple-mysql-0.2.1 (HirotomoMoriwaki)
07:34:28 <edwardk> why is the scene description in the transformer?
07:34:37 <edwardk> rather than just a structure you can poke and prod
07:35:01 <phaazon> edwardk: well, at the first time, in was a single monad Scene
07:35:13 <phaazon> in which I could call function like mesh, material, light, shader, and so on
07:35:17 <phaazon> in order to put them in a state
07:35:44 <phaazon> a few weeks ago, I added a typeclass, Identify, that lets me write material, mesh, light, shader, and so on as a single function called ident
07:36:02 <phaazon> (it’s basically a -> m (ID a))
07:36:36 <phaazon> my engine has resources support, then when I want to load resources, I just want to load identifiable values
07:36:54 <phaazon> and in order to get back id, I needed Scene, which is pure, whilst resources handling requires logging, and IO
07:37:11 <phaazon> then I just introduced SceneT, which is a scene context over a monad
07:37:26 <phaazon> in order to do something like (MonadIO m,MonadLogger m) => SceneT m
07:38:12 <phaazon> edwardk: the “structure” you mentionned is basically something I call SceneState
07:38:27 <phaazon> and SceneT is just a newtype wrapper over StateT SceneState
07:38:36 <edwardk> sounds messy ;)
07:38:44 <phaazon> how would you do that?
07:41:35 <Trollinator> why is genericLength not optimised the way it should be?
07:41:52 <hpc> @src genericLength
07:41:53 <lambdabot> genericLength []    = 0
07:41:53 <lambdabot> genericLength (_:l) = 1 + genericLength l
07:42:15 <hpc> how are you using it, and what optimization do you expect?
07:42:28 <phaazon> edwardk: let’s talk about that on #haskell-game
07:42:39 <Trollinator> I'm not using it and I'd expect it to be tail-recursive.
07:43:01 <geekosaur> tail recursion is kinda meaningless in lazy languages
07:43:14 <hpc> and in this case, actively unhelpful
07:43:29 <hpc> for instance, suppose you wanted to genericLength a potentially infinite list
07:43:35 <hpc> and used Nat as your result length type
07:43:50 <hpc> the final length would be fix Succ
07:44:07 <ttll> why is it not tail recursive?
07:44:28 <geekosaur> ...
07:44:58 <Trollinator> how is tail recursion meaningless? How is one supposed to write functions that don't overflow the stack then?
07:45:15 <hpc> Trollinator: the evaluation model of non-strict languages is completely different
07:45:21 <geekosaur> the tack you are thinking of is not relevant
07:45:28 <phaazon> edwardk: are you still there? :)
07:45:35 <geekosaur> in particular, in ghc there effectively is no call stack and *all* calls are "tail recursive"
07:45:43 <geekosaur> because eveything is CPS-transformed
07:45:53 <geekosaur> and every "function" immediately returns an unevaluated thunk
07:46:13 <geekosaur> the stack that matters in a lazy language is a pattern matching stack; tail recursion is not relevant to it
07:46:56 <nadirs> If I have `newtype Something = { unSomething :: a }` and `f :: a -> b` does `Something . f . unSomething` get compiled to just `f` (with no runtime/space overhead)?
07:47:07 <ttll> I mean the given definition would be tail-recursive in a traditional language
07:48:49 <vanila> ttll, <lambdabot> genericLength (_:l) = 1 + genericLength l
07:48:55 <vanila> ttll, if you meant that, it's not tail recursive
07:49:07 <vanila> genericLength isn't a tail call
07:49:09 <hpc> nadirs: in ghc, almost certainly
07:49:32 <nadirs> hpc: because newtypes get erased at compile time, right?
07:49:47 <vanila> but of course "tail recursive" on applies to strict functions
07:49:53 <vanila> only*
07:50:40 * hackagebot Nomyx-Language 0.6.2 - Language to express rules for Nomic  http://hackage.haskell.org/package/Nomyx-Language-0.6.2 (CorentinDupont)
07:50:42 * hackagebot Nomyx-Core 0.6.2 - A Nomic game in haskell  http://hackage.haskell.org/package/Nomyx-Core-0.6.2 (CorentinDupont)
07:50:45 * hackagebot Nomyx-Web 0.6.2 - Web gui for Nomyx  http://hackage.haskell.org/package/Nomyx-Web-0.6.2 (CorentinDupont)
07:50:46 * hackagebot Nomyx 0.6.2 - A Nomic game in haskell  http://hackage.haskell.org/package/Nomyx-0.6.2 (CorentinDupont)
07:51:13 <louisjb> hi, I'm using haskellmode and have ghc / ghci 7.6.3 installed but it won't accept n+k patterns by default. I thought it was enabled by default, what do I need to change?
07:51:26 <hpc> louisjb: don't use n+k patterns ;)
07:51:37 <louisjb> hpc, are they a bad idea?
07:51:38 <ttll> I see, something like this would be tail recursive?   genericLength n (_:l) = genericLength (n+1)
07:51:48 <ttll> + l
07:52:34 <hpc> they are backwards from what most people would expect
07:53:04 <vanila> ttll, yeah that call is in the tail position so it's tail recursive - of course haskell doesn't/can't do TCO and this will explode
07:53:11 <statusfailed> How does Lens' "makeLenses" handle types like "data Foo = Foo Int String" ?
07:53:16 <hpc> foo (n + 5) = n -- vs foo n = n - 5
07:53:31 <edwardk> statusfailed: it gives you nothing
07:53:41 <edwardk> statusfailed; it makes lenses for all 0 of the named fields ;)
07:54:11 <statusfailed> edwardk: I guess that is what I asked for :P
07:54:25 <statusfailed> is there a TH function to get the _1 and _2 lenses perhaps?
07:54:37 <louisjb> hpc that's exactly what I'd expect it to do, match (n+k) on z, n = z-k
07:54:59 <louisjb> is n+k a deprecated/frowed upon feature these days?
07:55:02 <benzrf> oh god why
07:55:08 <benzrf> i've gotten into an argument with php users
07:55:12 <louisjb> frowned*
07:55:15 * benzrf holds his head in his hands
07:55:23 <statusfailed> louisjb: I think it's deprecated isn't it?
07:55:33 <quchen> louisjb: n+k is not even deprecated, it is removed from the language.
07:55:49 <quchen> GHC still supports backwards compatibility with a pragma though.
07:56:46 <hpc> benzrf: ... how?
07:57:00 <louisjb> oh right I see, I thought they were added since a certain version but actually they were removed - ok I'll keep that in mind. Thanks
07:57:07 <hpc> did you manage to find the one group of them that's been using it long enough to get stockholm syndrome?
07:57:08 <phaazon> edwardk: may you please tell me why you think my design is messy ? :)
07:57:42 <benzrf> hpc: i went to #digitalocean
07:58:03 <hpc> i have no idea what that is
07:58:17 <hpc> anyway, let this cheer you up: http://hackage.haskell.org/package/acme-php
07:58:21 <nadirs> hpc: cloud hosting maybe? -- benzrf
07:58:37 <benzrf> it hurtttttts
07:58:41 <benzrf> it is so painful
07:58:43 <benzrf> why do i do this
07:58:51 <benzrf> why do i let myself get caught into these arguments
07:58:54 <edwardk> phaazon: got dragged away
07:59:00 <benzrf> i should know better
07:59:17 <nadirs> benzrf: pretend your connection dropped and leave the channel ;P
07:59:32 <benzrf> already left
07:59:50 <benzrf> closing remark was '>tfw get attached to shit, rationalize the shit, then get hurt when people point out it's shit'
08:00:06 <hpc> haha
08:00:24 <benzrf> i need to write a diatribe about people getting attached to things and rationalizing their bad points
08:00:27 <benzrf> oh shit
08:00:31 <benzrf> paul graham already did it for me
08:00:34 <benzrf> i totally forgot
08:00:47 <quchen> This is not the place to do this though.
08:01:00 * benzrf heads over to #haskell-blah and resumes whining
08:01:17 <geekosaur> ob someone is wrong on the internet
08:01:44 <benzrf> :{
08:01:57 <phaazon> edwardk: basically, my design is to represent connectivity between scene objects in a monad; this monad is just a builder helper, if you “run” it you get the whole scene objects as a SceneState ; then, depending on what I want to do with the scene (render it, serialize it, interact via user events, and so on), I can implement any stuff around SceneState
08:02:12 <phaazon> why do you think it’s messy?
08:02:41 <rola> Can you check which instances a type derives from ghci? (is this a right question i want to be asking?)
08:03:19 <phaazon> by “connectivity” I mean that meshes are not really handled as-is, you only use an ID (newtype over Int), and the real mesh is in a Vector, in the SceneState
08:03:22 <quchen> :i <type> will tell you what classes a type is an *instance* of, rola.
08:03:33 <quchen> Deriving is the process of automatically writing instances.
08:04:02 <geekosaur> rola: you can't see derives as such, but you can see what it implements (remember that instances can be written by hand) in :info
08:04:13 * geekosaur slow
08:04:52 <rola> :i IO String
08:05:20 <geekosaur> no :i in lambdabot, only ghci
08:10:24 <rudi_s> Hi. Can I get haskeline to interprete jk as escape to enter vim mode? This is much faster for me than using esc (which additional has a timeout). Thanks.
08:15:56 <tremon> hi all, I'm trying to use http-server in a project, but it requires data-text > 1.0. My system has 0.11. Is there a better solution than me recompiling half the world against the newer data-text?
08:16:18 <hpc> tremon: are you using cabal?
08:16:31 <tremon> yes
08:17:51 <tremon> cabal pulled in data-text 1.0 automatically, and then I got a link-time symbol error because of it
08:18:06 <hpc> can you paste the error?
08:18:09 <hpc> @paste
08:18:09 <lambdabot> Haskell pastebin: http://lpaste.net/
08:20:15 <ebaldwin> dcoutts: please check your email
08:20:43 * hackagebot dlist 0.7.1 - Difference lists  http://hackage.haskell.org/package/dlist-0.7.1 (SeanLeather)
08:21:13 <tremon> sadly, I don't have the error anymore. I already went three steps further, removed the local data-text and recompiled the rest against the system data.text
08:21:35 <tremon> i'll see if it
08:21:40 <tremon> 's still in my search history
08:27:25 <phaazon> edwardk: ok, I guess I’ll find out on my own… however if you have an idea please tell me here or on #haskell-game, gotta be idleing for a while now
08:30:44 * hackagebot vado 0.0.1 - Runs commands on remote machines using ssh  http://hackage.haskell.org/package/vado-0.0.1 (HamishMackenzie)
08:31:41 <tremon> I don't have the exact error, but it was something like "fatal error: duplicate definition for symbol" with a reference to the data-text-1.0 object file.
08:31:54 <tremon> probably easy to reproduce though
08:32:22 <voldyman> hey guys, i am trying to think in haskell need some help
08:32:39 <they> Alright, what's up voldyman?
08:32:53 <voldyman> there is this program i wrote a while back, which reads a stream of bytes from the serial port and parses that
08:33:00 <voldyman> it's in  c#
08:33:16 <they> I've never worked with serial ports, so I can't be of much help.
08:33:30 <voldyman> my question is regarding the parsing of the data
08:33:43 <voldyman> so if the bytes are like 00 02 04 38 etc
08:34:17 <voldyman> the user has provided me which a file which tells me which total number of byte in a packet, and how many bytes should be taken together
08:34:27 <tremon> hpc: http://lpaste.net/106423
08:34:32 <voldyman> i can't think of a way to implement this without a forlop
08:35:17 <bms1> Is there a library that allows you to timeout results of computations? I want to make a function that looks like [a] -> IO [a] which computes as many results as possible in a certain amount of time
08:35:31 <quchen> @hoogle timeout
08:35:32 <lambdabot> System.Timeout timeout :: Int -> IO a -> IO (Maybe a)
08:35:32 <lambdabot> package timeout-control
08:35:32 <lambdabot> package timeout-with-results
08:35:59 <voldyman> so if there are 10 bytes in a packet and applying the transformation, 00 01 02 00 03 06 90 -> 00 01, 02, 03 06; 90 ...
08:36:02 <quchen> But that's not really the timeout you're looking for I guess.
08:36:10 <voldyman> how would that be implemented in haskell
08:36:15 <monochrom> tremon, you have two versions of text, and your code actually brings in both. both versions come with C code of the same name. that is not going to fly. possessing two versions is confusing because of these issues and others.
08:36:24 <quchen> You can write a function to time out a computation yourself by racing the actual thread against a threadDelay.
08:37:31 <tremon> I know. data-text-1.1 was pulled in by http-server. My question was whether recompiling world locally was my only option, or there were other solutions that don't require my to replace all of the system libs
08:37:36 <bms1> quchen: Thanks!
08:38:44 <monochrom> I am not talking about data-text. I am talking about text.
08:39:05 <tremon> oh. oops. I thought they were the same
08:39:42 <tremon> obviously I meant the text package
08:40:19 <monochrom> I would seriously consider "cabal install --dry-run http-server --constraint='text installed'" and settle with slightly older version http-server-1.0.3
08:41:09 <tremon> ok will try that
08:41:45 <monochrom> and I accidentally left my --dry-run there
08:41:48 <tremon> constraint='text installed' is useful
08:42:36 <monochrom> but I always do a --dry-run and go through a bureacratic approval process before committing.
08:44:37 <monochrom> a rare instance of bureaucracy being net beneficial
08:46:07 <monochrom> this would not happen if cabal-install did not merrily allow multiple versions despite knowing the net trouble and confusion for years
08:47:56 <wz1000> Is there any way to get cabal to compile on a low memory system?
08:48:42 <monochrom> that is usually not up to cabal but up to ld (gnu ld vs gold)
08:49:24 <tremon> heh. Or at least giving a warning that an installed package will mask/conflict with a system package
08:49:34 <wz1000> How can I fix it?
08:49:50 <monochrom> but some GHC versions pass fairly hardcoded flags to ld such that gold is incompatible
08:50:07 <wz1000> I'm running ghc 7.8
08:50:21 <monochrom> that may help
08:50:59 <tremon> now I get a compile error with 1.0.3, couldn't match Data.Text.Internal.Text with [Char]: http://lpaste.net/106425
08:51:12 <monochrom> have /usr/bin/ld symlink to gold and give it a try. IIRC ghc 7.8 detects it on the fly and omits the problematic flags
08:52:06 <wz1000> I'll try that. Thanks.
08:52:22 <tremon> ghc too old?
09:13:35 <rudle> hi friends. beginner question here. in this code: `pointsum@(Point a b) = foldl' addPoint zeroPoint points` what is the meaning of @?
09:14:00 <Iceland_jack> rudle: it's an 'as-pattern'
09:14:12 <Iceland_jack> it basically means that 'pointsum' is the same as 'Point a b'
09:14:28 <Hafydd> It binds pointsum to Point a b.
09:15:05 <wz1000> monochrom: no, that did not work, it still ran out of memory. http://lpaste.net/106426 is the script i'm using to install packages
09:15:11 <rudle> and that would be useful if I wanted to say pointsum often
09:16:00 <Hafydd> Depending how well common-subexpression optimisation is implemented in your compiler, it may also save you from reconstructing Point a b many times.
09:16:30 <rudle> Hafydd: you anticipated the question i was typing! that sounds great
09:16:57 <quchen> Does GHC do CSE at all?
09:17:15 <quchen> I remember hearing that it's often not a good idea to do because of potential space leaks
09:17:21 <bennofs> quchen: it does sometimes IIRC, but not often
09:17:23 <rudle> i'm reading code from Parallel and Concurrent Programming in Haskell. I was warned that it was optimized - suppose I should've known better than to dig in too deep
09:17:31 <rudle> learning! yay! thanks friends
09:19:44 <gilligan_> hi
09:19:59 <wz1000> monochrom: It failed requesting the exact same amount of memory-1048576 bytes
09:29:37 <ReinH>  quchen http://www.haskell.org/haskellwiki/GHC/FAQ#Does_GHC_do_common_subexpression_elimination.3F
09:30:12 <ReinH> So, basically no.
09:30:24 <quchen> So, yes? :-s
09:30:37 <ReinH> Yes for one specific case, no for all the others?
09:31:47 <quchen> Well, I'm glad it didn't say "all this hand-written sharing you've been doing was unnecessary" :-)
09:32:53 <ReinH> :)
09:45:26 <LovingFunctional> Knock knock! Haskell newbie here..
09:45:59 <benzrf> nice nick :-)
09:46:02 <vanila> hi :)
09:46:13 <LovingFunctional> So I wanted to ask
09:46:40 <LovingFunctional> I am trying to implement my own dropWhile function
09:47:03 <LovingFunctional> the first step is to create a function which drops single element
09:47:08 <benzrf> LovingFunctional: is it?
09:47:11 <vanila> that's a good start
09:47:15 <LovingFunctional> here's the code (as written in tutorial)
09:47:31 <LovingFunctional> or wait should i use pastebin?
09:47:36 <benzrf> LovingFunctional: how many lines?
09:47:37 <quchen> @paste
09:47:37 <lambdabot> Haskell pastebin: http://lpaste.net/
09:47:38 <vanila> yeah use lpaste
09:47:45 <benzrf> less than 3 is ok here
09:47:51 <benzrf> more should be pasted
09:47:51 <LovingFunctional> Okay cool
09:48:06 <benzrf> > reverse "also, we have a bot for running code"
09:48:08 <lambdabot>  "edoc gninnur rof tob a evah ew ,osla"
09:48:18 <LovingFunctional> http://pastebin.com/qdjBYTFZ
09:48:36 <vanila> thats good but you should also handle the [] case
09:48:51 <vanila> because as is dropWhile' id [] will crash
09:48:56 <LovingFunctional> So I dont understand the 'then' part
09:49:07 <LovingFunctional> @vanila thanks! was about to implement it
09:49:07 <lambdabot> Unknown command, try @list
09:49:08 <benzrf> LovingFunctional: we at #haskell officially recommend lpaste  over pastebin.com
09:49:17 <vanila> well here's example:
09:49:19 <LovingFunctional> Got it
09:49:22 <vanila> > if True then "a" else "b"
09:49:24 <lambdabot>  "a"
09:49:26 <vanila> > if False then "a" else "b"
09:49:27 <lambdabot>  "b"
09:49:44 <LovingFunctional> yeah but why xs(Tail) when bool x is true
09:49:47 <vanila> so it just picks xs or (x:xs) to give back, depending on the bool
09:50:13 <vanila> well dropWhile is supposed to keep dropping elements that bool x holds for
09:50:24 <vanila> like if bool was the function that checked for the letter 'a'
09:50:31 <vanila> > dropWhile (=='a') "aaaaaaabcdef"
09:50:33 <lambdabot>  "bcdef"
09:50:38 <benzrf> > dropWhile (<100) [1..140]
09:50:39 <lambdabot>  [100,101,102,103,104,105,106,107,108,109,110,111,112,113,114,115,116,117,118...
09:50:58 <LovingFunctional> yep
09:51:41 <LovingFunctional> I think I got it, thanks everyone
09:51:46 <benzrf> LovingFunctional: :-)
09:52:28 <LovingFunctional> I come from Python background, learning Haskell feels like I m watching matrix, completely mind boggling
09:52:33 <vanila> hehe
09:52:34 <vanila> that's great!
09:52:44 <LovingFunctional> back to tutorials, Thanks everyone
09:55:51 * hackagebot csound-expression-typed 0.0.5 - typed core for the library csound-expression  http://hackage.haskell.org/package/csound-expression-typed-0.0.5 (AntonKholomiov)
09:55:53 * hackagebot csound-expression 3.3.0 - library to make electronic music  http://hackage.haskell.org/package/csound-expression-3.3.0 (AntonKholomiov)
10:00:51 * hackagebot csound-catalog 0.1.2 - a gallery of Csound instruments.  http://hackage.haskell.org/package/csound-catalog-0.1.2 (AntonKholomiov)
10:00:53 * hackagebot temporal-csound 0.3.1 - library to make electronic music, brings together temporal-music-notation and csound-expression packages  http://hackage.haskell.org/package/temporal-csound-0.3.1 (AntonKholomiov)
10:02:49 <benzrf> > 'foo'
10:02:51 <lambdabot>  Syntax error on 'foo'
10:02:51 <lambdabot>  Perhaps you intended to use TemplateHaskell
10:03:48 <benzrf> @letlpaste 106428
10:03:48 <lambdabot>  Parse failed: TemplateHaskell is not enabled
10:03:52 <benzrf> nice
10:11:32 <pavonia> @help letlpaste
10:11:32 <lambdabot> letlpaste <paste_id>. Import the contents of an lpaste.
10:12:04 <l0cust> Hey, so I'm trying to run my executable, getting this error - http://lpaste.net/106429
10:12:32 <l0cust> Here's the repo - https://github.com/pharpend/eros
10:12:41 <l0cust> I try to run "cabal build", and I get that cryptic error
10:12:44 <l0cust> No idea what it means
10:12:52 <pavonia> @letlpaste 106430
10:12:54 <lambdabot>  Defined.
10:12:55 <l0cust> If I exclude the executable, it works fine
10:13:05 <pavonia> > foo
10:13:07 <lambdabot>  123
10:15:03 <supki> l0cust: you need to add Paths_eros module to exposed- or other-modules in library section in eros.cabal
10:15:48 <l0cust> supki: god dammit, I thought I did that
10:15:51 <l0cust> supki: thank you
10:29:10 <d10genes> could someone enlighten me on cabal behavior that's confusing me?
10:29:26 <bennofs> d10genes: what is it?
10:29:31 <d10genes> I try doing `cabal install happy alex`
10:29:47 <d10genes> in a sandbox
10:29:59 <d10genes> and it says "The program 'happy' is required but it could not be found.", and fails
10:30:23 <d10genes> but it works when I do "cabal install happy", and later "cabal install alex"
10:30:30 <d10genes> is this to be expected?
10:30:58 <notdan> hm, weird
10:30:59 <quchen> The thing here is that happy builds an executable that is required
10:31:25 <corgifex> d10genes: yes
10:31:29 <d10genes> and it's trying to do them in parallel or something when I do them in the same command?
10:31:37 <corgifex> oh
10:31:49 <corgifex> no, that is weird
10:31:56 <quchen> Or Alex, or whatever. Anyway, Cabal can't install things that require executables built in the same process in my experience.
10:32:32 <d10genes> so will that mean I can't use them in the .cabal file doing "cabal install --only-dependencies" then?
10:32:40 <d10genes> I'll have to install them one by one?
10:32:49 <d10genes> because I was getting similar errors with that
10:33:09 <d10genes> (I'm just following bits and pieces I've gathered from tutorials)
10:33:39 <quchen> The problem arises only with Alex+Happy in my experience, so I basically put it in a mental footnote how to solve it.
10:34:16 <matematikaadit> How do I find out in which version of GHC did Control.Monad.Instances being deprecated?
10:34:42 <d10genes> quchen: but if I see the problem elsewhere, it's a good chance that it's cause from executables not in the path or something, it sounds like
10:35:56 <napping> matematikaadit: if you have no better ideas, you could look through past version of the documentation on haskell.org, like http://www.haskell.org/ghc/docs/7.6-latest/html/libraries/index.html
10:36:08 <napping> or more usefully, http://www.haskell.org/ghc/docs/
10:37:17 <quchen> matematikaadit: What I did was look through the docs of 'base' on Hackage. Click version number, open module, see if deprecated.
10:37:27 <quchen> 4.5.0.0 seems to be the last one where it wasn't.
10:37:58 <napping> You can see that GHC 4.0 was the first to have library documentation separate from the user's guide for example
10:38:46 <tnks> if I cabal install stuff into the user database, will sandboxes not default to those packages?
10:38:56 <ReinH> tnks: no, sandboxes are separate
10:38:58 <tnks> I think I'd prefer that sandboxes be completely isolated.
10:39:21 <tnks> I'm going to end up installing a few tools like hoogle, hlint, and stuf.
10:39:32 <matematikaadit> ah, thanks quchen. I though of searching in something like CHANGELOG
10:39:35 <tnks> and that seems to pull in some HTTP stuff that I may use in my own projects.
10:39:38 <napping> that's one of the uses of sandboxes, to have a build not depend on what versions you appen to have already installed
10:40:08 <tnks> napping: yeah, but do I get 100% isolation?  Or an overlay?
10:40:16 <napping> It's closer to 100%
10:40:32 <tnks> napping: in what case is it not 100%?
10:40:40 <napping> at least some global packages show through - certainly anything where GHC fixes the version to use like base
10:41:06 <napping> might even be all of them, I've long been installing GHC myself and then just cabal-installing into the user database so I wouldn't really know
10:41:18 <napping> It's certainly isolated from your user packages
10:41:28 <tnks> napping: okay, good to know.
10:41:39 <tnks> so I'll install whatever I want user-level and not worry about interactions.
10:41:45 <napping> well, I guess there are the mechanisms you can explicitly put multiple projects into a sandbox or import sources or something, but if it's on purpose it's find
10:41:52 <napping> oh, and binaries are not sandboxed
10:42:01 <tnks> sure, they are just on the path.
10:42:07 <napping> I mean if it wants to run happy or haddock or whatever then as far as I know it's just from the path
10:42:16 <tnks> "cabal update" is the best way to see what can be upgraded?
10:42:21 <napping> nope
10:42:29 <tnks> how then?
10:42:33 <napping> like apt-get update, cabal update just grabs the package list
10:42:42 <tnks> napping: yeah, that's what I'm seeing.
10:42:48 <tnks> how to see what can be upgraded?
10:43:23 <napping> huh, I never really check
10:43:59 <napping> unless something is broken or I know I specifically want a newer version, in which case I'm sprecifically cabal-installing it
10:44:36 <codygman> I want to get the image creation date from a picture, what would be the easiest way to do that in Haskell? It looks like unix provides a way to get the modification date but when I use stat it doesn't show the creation date of a picture.
10:44:39 <napping> there's probably some kind of install --reinstall --dry-run --ignore-whatever kind of thing you could to do ask to resolve current dependencies
10:45:26 <napping> basically, "If I was trying to install my .cabal dependencies into a fresh sandbox right now, what would I get"
10:45:58 <enthropy> codygman: maybe https://hackage.haskell.org/package/exif ?
10:46:13 <codygman> enthropy: Isn't exif JPEG specific?
10:46:17 <napping>  I'm not sure I understand why you want to "upgrade"
10:47:02 <napping> Oh, there's something about "world" too
10:47:38 <codygman> enthropy: Thanks btw
10:47:57 <matematikaadit> thanks napping and quchen, I've found it. Looking at the blamed source, https://ghc.haskell.org/trac/ghc/browser/ghc/libraries/base/Control/Monad/Instances.hs?annotate=blame Now I know that the DEPRECATED pragma was added in ghc 7.8
10:48:06 <enthropy> codygman: could be, but exiftool (perl) works with formats besides jpg
10:48:57 <napping> tnks: huh, try this: cabal install --upgrade-dependencies --dry-run
10:49:35 <napping> I'm assuming you have a .cabal file describing the code living in your sandbox
10:50:46 <napping> You can also install "world" - taking contents listed in .cabal-sandbox/world or your ~/.cabal/world, which tries to reinstall the things you have explicitly asked to install or something
10:51:48 <napping> so something like cabal install world --dry-run --reinstall --force-reinstalls --upgrade-dependencies (maybe with less of those) might give another idea of what could be upgraded
10:51:50 <codygman> Any ideas about how I would find a quicktime movie creation date?
10:56:49 <napping> tnks: was any of that stuff useful?
11:00:55 * hackagebot aivika 1.3 - A multi-paradigm simulation library  http://hackage.haskell.org/package/aivika-1.3 (DavidSorokin)
11:00:57 * hackagebot aivika-experiment 1.3 - Simulation experiments for the Aivika library  http://hackage.haskell.org/package/aivika-experiment-1.3 (DavidSorokin)
11:01:38 <l0cust> You know, I used to think JSON was a half-assed spinoff of XML.
11:01:41 <l0cust> But the more I work with it, the more I like it
11:01:53 <l0cust> It's certainly better than XML
11:02:20 <napping> It certainly doesn't do some things XML does
11:02:27 <l0cust> napping: what can't it do?
11:02:36 <napping> but most people generally don't really do those things
11:02:56 <napping> namespacing elements for one
11:03:04 <Freundlich> JSON is something completely different than XML. XML is markup which for one isn't context-free.
11:03:19 <l0cust> Freundlich: people try to use them for the same things
11:03:28 <l0cust> Freundlich: I wouldn't try to use JSON for markup. that's stupid
11:03:31 <Freundlich> People try to use XML when they shouldn't.
11:03:37 <dwcook> Seems to me like YAML and XML are more directly comparable
11:03:45 <l0cust> YAML is just hilarious
11:03:48 <napping> Sure you could somehow represent that in JSON, but having a standard way to do that is kind of the point
11:03:55 <l0cust> It would probably be useful if it's syntax wasn't so complicated
11:03:58 <napping> like processing documents with bits mixed in that you may not understand
11:04:23 <napping> I guess what I'm getting at is that XML seemed fairly popular for things where JSON is ridiculously better
11:04:24 <l0cust> YAML is practically a programming language
11:04:34 <l0cust> napping: well said
11:04:43 <l0cust> napping: like, storing static data
11:04:49 <l0cust> napping: json is just plain better
11:04:49 <napping> but that doesn't necessarily mean that there are not things XML might be useful for
11:04:55 <vanila> how is json so great but everyone hates s-expressions?
11:05:09 <napping> vanila: yeah, I don't know either. Maybe having a built in map type?
11:05:10 <l0cust> I love s-expressions
11:05:24 <napping> json for storing static data sounds pretty silly too
11:05:26 <vanila> hmm that is probably it actually
11:05:30 <napping> just somewhat less silly than XML
11:05:34 <dwcook> Speaking of, there's also self-ml
11:05:37 <napping> XMLRPC
11:05:41 <napping> that's the joke
11:05:56 * hackagebot aivika-experiment-chart 1.3 - Simulation experiments with charting for the Aivika library  http://hackage.haskell.org/package/aivika-experiment-chart-1.3 (DavidSorokin)
11:05:58 * hackagebot aivika-experiment-cairo 1.3 - Cairo backend for the Aivika simulation library  http://hackage.haskell.org/package/aivika-experiment-cairo-1.3 (DavidSorokin)
11:05:59 <napping> vanila: maybe clojure-flavored S-expressions will catch on then
11:06:00 * hackagebot aivika-experiment-diagrams 1.3 - Diagrams backend for the Aivika simulation library  http://hackage.haskell.org/package/aivika-experiment-diagrams-1.3 (DavidSorokin)
11:06:15 <dwcook> napping, how are Clojure sexps distinct?
11:06:18 <napping> Ah, edn
11:06:20 <vanila> i havent actually studied clojure yet
11:06:26 <napping> well, Clojure has syntax for map and vector literals
11:06:30 <dwcook> Ah, neat
11:06:33 <l0cust> dwcook: there's a few different types of s-expressions
11:06:38 <l0cust> dwcook: what napping said
11:06:50 <napping> not hugely different from what you could do with a lisp reader macros or whatever
11:07:03 <dwcook> Yeah but if we're talking about a markup language are we gonna have macros too?
11:07:07 <napping> but somehow I think just being able to say {:a 1 :b 2} to get a map makes kind of a big difference for JSON style things
11:07:12 <napping> https://github.com/edn-format/edn
11:07:16 <napping> nah, just the data subset
11:07:41 <l0cust> The reason I use JSON is because Aeson exists
11:07:42 <napping> you know, like JSON is just a subset of Javascript constants, doesn't mean we have proptotype chains in the format
11:07:54 <l0cust> Aeson is a wonderful library
11:08:01 <dwcook> Not quite a subset as it happens
11:08:08 <napping> well, pretty close
11:08:26 <napping> that's not necessarily a bad thing either, if people were otherwise tempted to eval json
11:08:32 <napping> or rather, eval what they hoped was just json
11:08:43 <dwcook> And then evil hackers pwned their web app
11:09:08 <napping> so perhaps deliberately not quite being a subset is a decent design if you have to go that way
11:09:33 <dwcook> Well, it's enough of a subset that eval actually often works, unfortunately. You just have to slap people on the wrist when they try that
11:09:46 <napping> on the other hand, I think clojure may make the eval safer by default
11:10:17 <dwcook> eval wouldn't be so bad in a language where evaluating expressions had no side effects
11:10:45 <dwcook> Though you've still gotta watch out for bottom (which is arguably a side effect)
11:11:06 <napping> eh, not too much
11:11:20 <ticktockman> https://github.com/csabahruska/bullet/issues/1
11:11:30 <napping> I mean if it's a web app where you could already have ill-behaved users trickle in data very slowly or whatever
11:11:34 <napping> you already need timeouts of some sort
11:11:41 <dwcook> Yep
11:11:58 <napping> Huh, not seeing something about eval being safe
11:12:06 <dwcook> At worst you run the pure computation and catch it in IO
11:12:16 <napping> but I vaguely recall some kind of *usafe-eval* / *safe-eval* dynamic you could/had to set
11:12:36 <napping> or maybe needed an extra argument to have it eval in an environment other than the completely empty one
11:13:07 <dwcook> I might be being idealistic here though. I've never delved into mueval's source :P
11:13:08 <napping> Clojure exposes some evil side effecting stuff too, and also has calls to java
11:13:18 <napping> what, what I'm talking about
11:13:25 <napping> of course, they just have a "read" like any decent lisp
11:14:26 <napping> and calling eval instead of read is quite purely stupid, instead of calling eval rather then rolling your own JSON parser or whatever
11:14:44 <napping> not to mention that you need read to turn a string into a form
11:15:01 <napping> so yeah, much safer by default than the JSON/Javscript situation
11:15:08 <dwcook> A lot of web developers seem to have an aversion to pulling in any but a monolithic DOM library like jQuery
11:15:35 <napping> ah, but then they add any jQuery plugin, right?
11:15:37 <dwcook> Of course browser JS does not have a very good import mechanism yet
11:16:26 <napping> Perhaps Javascript is as bad an example of dynamically typed languages as Java is of statically typed languages
11:16:39 <dwcook> Perhaps.
11:16:54 <napping> Certainly Clojure surprises me every now and then
11:17:13 <napping> not with the absolute level of safety they can provide, but how much they can for being a dynamic language
11:18:08 <dwcook> I haven't done the research to find a dynamically typed language that would be as analogously good as Haskell is among statically typed (and arguably all) languages. I do consider Python to be not too evil though.
11:18:32 <napping> Smalltalk can be kind of interesting
11:18:47 <napping> though I've only done a little and it's mostly the environment that's really neat
11:19:16 <dwcook> THe question would be like this, I guess: Is there a language that embraces dynamic typing in a way that makes us reconsider some of its bad points, much as Haskell shows us that verbosely writing out types is not a feature of all static languages even though it is in C?
11:19:59 <dv-_> i thought ruby was pretty nice
11:20:03 <dwcook> Actually, I think I have a surprising answer, and it is Prolog. Though I'm not sure if that's considered dynamically typed.
11:20:54 <napping> I don't know about reconsidering bad points or whatever
11:21:06 <napping> but there are certainly languages doing interesting and useful things that seem pretty darn hard to type
11:21:25 <dwcook> That seems like a good place to look. What's an example? Smalltalk you say?
11:21:32 <napping> Yeah, that's one
11:21:45 <napping> everything's objects in a single persistant image
11:22:15 <Ogig> hi guys. I'm trying to learn some haskell. As an  exercise i'm rewriting this script i use often, but i'm kinda stuck right now with html parsing. This is it: http://lpaste.net/106431
11:22:24 <kazagistar> dwcook: I feel like a prettty well optional typed language, like Julia, can fit that pretty well, if only because they allow types when you feel like you need em
11:22:30 <napping> you often write code by writing some code, then hitting the doesNotUnderstand message where you called something that didn't exist yet, writing the method, then continuing on your way
11:22:38 <Ogig> i will take any tip regarding any part of that awful code.
11:23:51 <napping> dwcook: also, simply figuring out how exactly modifying/updating code in a long running system should work
11:24:04 <d3lxa> is there an alternative to threadSleep for longer interval? it's limited to 1 day or something? it's in micro-seconds
11:24:37 <napping> wasn't it picoseconds?
11:24:39 <napping> threadDelay?
11:24:48 <enthropy> https://hackage.haskell.org/package/unbounded-delays
11:25:35 <dwcook> What about threads that only awaken when you say their name backwards three times while burning incense?
11:25:39 <napping> Ogig: you're trying to start using an HTML parser?
11:25:58 <d3lxa> napping: oh right! threadDelay
11:26:03 <Ogig> napping, in short, yes
11:26:23 <napping> kazagistar: What about an optionally untyped language, where you have Dynamic only where you feel like you need it :)
11:26:41 <napping> d3lxa: I guess I'm just used to 64-bit Int, which gets pretty up there
11:27:25 <napping> dwcook: oh, Erlang is also very good at what it does, even if that goodness is perhaps somewhat orthogonal to typing
11:27:43 <d3lxa> napping: I've read somewhere it's limited to 1 day or something, but I don't get this result: Int is 32 bits (1 << 32) / (1000 * 3600 * 24) = 49, or am I wrong?
11:27:51 <dwcook> napping, yeah, I mean much of the goodness of many of the languages we've mentioned doesn't even necessarily have to do with typing, come to think of it.
11:27:52 <napping> or arguably makes types somewhat less useful
11:27:54 <luite_> i think it's probably not a bad idea to change the type of threadDelay thing in some library revision
11:28:18 <napping> dwcook: as for example Armstrong lays out, it was explicitly designed for reliability
11:28:25 <dwcook> Although with Haskell the type system is a desired feature, basically. If you don't like it, you probably should use another language. :P
11:28:25 <napping> and for reliability you need multiple machines
11:28:26 <luite_> for base 5.0 perhaps?
11:28:30 <d3lxa> napping: oh right, missing 1000 again
11:28:48 <napping> d3lxa: if you use 64-bit Ints it's probably quite a bit longer
11:28:49 <quchen> luite_: 5.0 will be with GHC 8, I assume?
11:28:52 <d3lxa> napping: so it's about 1 hour, what do to?
11:29:07 <d3lxa> napping: you cannot put Int64 into Int, can you?
11:29:17 <napping> on a 64-bit system, Int is 64 bits
11:29:28 <napping> isn't it?
11:29:35 <d3lxa> not sure, but it's not that portable then
11:29:38 <enthropy> > maxBound :: Int
11:29:40 <lambdabot>  9223372036854775807
11:29:42 <enthropy> > maxBound :: Int32
11:29:44 <lambdabot>  2147483647
11:30:04 <napping> d3lxa: somebody else suggested a library that already does longer sleeps
11:30:20 <napping> it's not that tricky to make something that takes an Integer and calls threadDelay maxInt enough times or something
11:30:46 <d3lxa> I can live with 1 hour delay, but was just wondering if there was something more macro
11:31:00 <napping> dwcook: and then if you design your language along those principles, each process might as well assume it's on an independent machine
11:31:01 <dwcook> napping, makes me think, seems like it would be neat to have a "hardware language" that is basically an abstraction for using many machines. Though I have no idea the practical difficulties of such a thing :)
11:31:25 <napping> dwcook: and then, each interprocess message send can't be assumed to be much more typeful than a network link
11:31:54 <luite_> quchen: don't know if there are plans that reach that far. it's not required to bump to 5 for a new major GHC relase (GHC 7.0 bumped base from 4.2 to 4.3)
11:32:06 <napping> combine that with generally going for smaller cooperation processes, and it's not clear there's too much room for types to help
11:32:47 <dwcook> napping, is typing even completely sound even on just one machine? You could have a memory failure of some sort, perhaps
11:32:50 <napping> on the other hand it's already deserializing things into untyped terms
11:33:17 <napping> it is at least under a fail-stop model
11:33:28 <napping> Erlang came from telecoms stuff, ECC memory is the least hardware assumption
11:34:31 <napping> I bet you could exchange some more typing assumptions across machines and stuff, but it's not obviously trivial or obviously a big win
11:34:51 <napping> basically, for Erlang I can make an argument I actually respect that it wouldn't get much use from types
11:35:37 <napping> oh, the other big thing I haven't seen in typed languages is the assumption like you get, especially with Erlang or Smalltalk, that the system is going to be continuously live and updated on the fly, at the language level
11:36:07 <dwcook> That seems like an unfinished problem in Haskell
11:36:19 <napping> incrementally evolving parts of a running program, rather than having to shutdown and restart whole processes
11:36:38 <napping> yeah, I only have vague ideas of what the semantics should even be
11:37:02 <napping> something about an IO operation that takes a whole pure universe and makes a new one where you've substituted in a different version of a function maybe?
11:37:02 <kazagistar> that seems problematic if you have "pending" computation in the form of thunks all over the place
11:37:09 <napping> yeah, exactly
11:37:18 <dwcook> I'm even sort of doubting whether that's been tackled
11:37:32 <napping> I think things are getting there
11:37:40 <dwcook> Should it be another member of the awkward squad?
11:37:53 <napping> but code update is a big thing
11:38:04 <ReinH> napping: the funny thing about live code reloading is that even the Erlang folks don't use it very often in practice.
11:38:07 <napping> Erlang's solution is kind of simple - keep one old version of every module around
11:38:19 <ReinH> they're usually happy to let while systems fail and restart.
11:38:31 <ReinH> *whole
11:38:35 <napping> some explicit recursive calls will call into a new code version
11:38:37 <dwcook> So maybe it's not as big a deal as it seems
11:38:51 <napping> and if a process hasn't caught up by the n+2 version, well, it just dies
11:38:57 <kazagistar> dunno, I guess thunks could be treated like garbage collectable pointers to code, if you dont want to keep the old stuff forever
11:39:07 <napping> they get a lot of mileage out of that assumption that you have to be prepared for machines to die at any moment
11:39:22 <napping> then once you are prepared, you can also kill machines or processes at any moment for other reasons
11:39:25 <ReinH> It a pretty powerful one.
11:39:26 <dwcook> It seems like a handmade solution would be serializing the state of your world to disk every so often
11:39:33 <dwcook> Honestly that might be good enough for many applications
11:39:37 <ReinH> which we've known about since at least 1983 ;)
11:39:40 <napping> well, serializing the world is a different issue
11:40:15 <ReinH> there are two basic failure modes: fail stop and fail restart. the latter requires a "sync" step.
11:40:26 <ReinH> sync info can come from disk or other nodes
11:40:32 <napping> GHC recently started to support unloading code - at least unreferenced code
11:40:33 <dwcook> Oh, I see
11:40:58 <ReinH> Fail stop is for things that don't store internal state, which are surprisingly common.
11:41:01 <napping> and some of the resource limits stuff or other GHC hacks might help you find and update/kill thunks hanging on to old code
11:41:17 <napping> and there are people working on cloud haskell
11:41:19 <ReinH> And designing for fail stop systems tends to give more robustness. sync is hard.
11:42:15 <ReinH> @google fail stop processes
11:42:19 <lambdabot> http://pages.cs.wisc.edu/~remzi/Classes/739/Papers/fail-stop.pdf
11:42:19 <lambdabot> Title: Fail-Stop Processors: An Approach to Designing Computing Systems Fault-Tolerant
11:42:25 <ReinH> yep that's the paper
11:42:30 <ReinH> from 83
11:44:35 <Guest22391> Hey guys! I have a problem and I'm having difficulty thinking about it in a non-procedural way. THe problem is as follows. I have a list [a], where every 'a' refers to a point in space. The list, then, refers to a path through space. I want to remove loops. This means that if my list goes [5, 2, 1, 5, 6], I should remove the loop [5, 2, 1, 5], so my resultant path should be [5, 6]. I can't think of how to do this. Help?
11:45:10 <napping> Guest22391: any ways, or good ways?
11:45:27 <Guest22391> napping: good ways, hopefully.
11:45:42 <Guest22391> napping: I was thinking of a sort of double-nested foldl
11:45:43 <napping> If it's about getting started at all, how about trying first just to remove loops back through the first node
11:45:49 <ReinH> I can think of some terrible ways
11:45:53 <napping> I'd go by foldr
11:45:56 <napping> but yeah
11:46:03 <Guest22391> napping: why foldr?
11:46:17 <napping> if you have unloop :: Node -> [Node] -> [Node]
11:46:44 <napping> giving you first first/rest a path like first:rest except it doesn't loop back through first
11:46:54 <napping> then foldr unloop [] path removes all loosp from your path
11:46:57 <napping> maybe call it unloop1
11:47:02 <ReinH> A set and a zipper would work
11:47:21 <ReinH> zipper will give better backtracking behavior
11:47:34 <napping> that's getting into a smarter foldl solution
11:48:09 <Guest22391> ReinH: what do you mean? I was thinking I might zip the list with an index and then group by element
11:48:11 <napping> unloop is something like first:rest if rest doesn't contain first, or dropping elements up to the last occurance of first if it does
11:48:37 <Guest22391> napping: there's a function that splits at a predicate, isn't there!
11:48:49 <napping> Guest22391: the basic operation is taking a list like l1 X l2 X l3 and clipping it down to l1 X l3
11:48:55 <ReinH> set of seen elements, traverse zipper until a seen element is reached, drop from left side of zipper to that elem, remove from set
11:48:58 <napping> yeah, span/break
11:50:19 <ReinH> On phone or I'd write some code
11:50:31 <Guest22391> ReinH: I'm confused by what you mean by "zipper" in this context. What do you mean by "traversing" and then "drop[ping] the left side of zipper"
11:50:51 <phi__> Guest22391 if you use Seq a from Data.Sequence then you can just keep taking elements from end until first and last element mathces
11:50:52 <Guest22391> ReinH: It's okay -- I'll try to work out some code with the advice you guys have given me, and then come back
11:51:07 <napping> "zipper" here shouldn't isn't any more complicated than a prefix of a list
11:51:12 <ReinH> data ListZipper a = LZ [a] a [a]
11:51:19 <napping> or a reversed prefix for somehwat more efficient insertion/building
11:51:23 <napping> ReinH: that's too complicatedc
11:51:56 <napping> If you want to scan left to right, you just need to remember what's the path to the left of you, what different nodes you've see where, and what's the prefix before the first time you saw them
11:52:05 <jle`> i don't think that it would be too harmful to just do expicit recursion here
11:52:20 <napping> if your next node is one you've seen before, throw away the prefix before you back to the prefix before the last time you saw it
11:52:27 <jle`> although an hof would be nice
11:52:43 <jle`> oh
11:52:46 <napping> if it's new, add it to your table and current prefix and keep going
11:53:04 <napping> some kind of fold' update1 <fancy data structure> path
11:53:05 <ReinH> prefix table requires more space
11:53:39 <napping> but unlooping by one is easy
11:54:02 <ReinH> you can do something with tails, sure, but mine is O(n) space and O(n^2) time I think.
11:54:05 <napping> I guess ReinH assumes you're willing to pay n^2 time and rescan the whole prefix
11:54:24 <napping> If you have a map or something telling you want nodes you've seen before you get O(n log n) time
11:54:30 <napping> and of course still O(n) space with sharing
11:54:57 <napping> actually, the foldl where the accumulator is just a reversed prefix is pretty easy too
11:54:58 <ReinH> napping: did you miss the "set of seen elements" in mine?
11:55:03 <napping> not really any different
11:55:12 <napping> ah, guess I did
11:55:40 <napping> yeah, if you can test in log(n) whether the element is repeated
11:55:46 <ReinH> yep
11:55:49 <napping> then you only need to scan the prefix when you are actually deleting thing
11:55:57 <ReinH> yep
11:56:02 <ReinH> I said all this :p
11:56:15 <ReinH> zipper is just convenient way to access prefix
11:56:21 <Guest22391> So, guys, correct me if I'm wrong here -- there are two basic types of solutions being discussed. One is, basically a folding solution, where we break our list into x:xs and remove all x loops from xs, then do the next element after x, and so on down the line. That has O(n^2) time, and O(n) space. THe other solution is to attach indexes to every element of my list, and then go through them all at once, grouping and removing
11:56:39 <ReinH> no
11:56:42 <Guest22391> I can't figure out the space/time complexity for that
11:56:49 <ReinH> the othe solution is to keep a set of seen elements
11:56:57 <napping> They are not even all that differnt
11:57:02 <ReinH> and use a zipper to have access to prefix
11:57:10 <napping> both are basically to start from one end, with an empty list you know has no loops
11:57:13 <ReinH> it is the same as a fold that keeps the prefix
11:57:24 <matematikaadit> @hoogle a -> [a] -> [a]
11:57:25 <lambdabot> Data.List intersperse :: a -> [a] -> [a]
11:57:25 <lambdabot> Data.List insertBy :: (a -> a -> Ordering) -> a -> [a] -> [a]
11:57:25 <lambdabot> Data.List deleteBy :: (a -> a -> Bool) -> a -> [a] -> [a]
11:57:32 <napping> and one at a time include a new element, trimming down the already-processed part if it would make a loop otherwise
11:57:50 <napping> the question is just if you use a set or something to help you figure out when you need to do the trimming
11:58:07 <ReinH> Yes you do :p
11:58:12 <napping> well, if
11:58:15 <ReinH> Otherwise you backtrack on every element
11:58:21 <napping> if you're having trouble getting anything working at all, that's probably easier
11:58:56 <ReinH> This is like 5 lines of code though
11:58:58 <corgifex> :t M.insert
11:58:59 <lambdabot> Ord k => k -> a -> M.Map k a -> M.Map k a
11:59:01 <napping> and something like let trimmed = dropWhile (/=target) prefix in if null trimmed then <didn't find it> else <now trimmed is prefix trimmed back to the first place we looped>
11:59:27 <napping> I'd totally recommend using a set if that's not hard. It's also almost surely optional if you're just getting started and it is hard
11:59:36 <SOFUTPEMATACABAL> hi guys, does anyone know if an upgrade to ghc (7.4.1 -> 7.6.3) screws up cabal completely? (none of my previous projects build anymore now)
11:59:45 <SOFUTPEMATACABAL> (using sandboxes)
11:59:52 <napping> (or if you know you'll have to have code work on examples where O(n^2) is too slow)
12:00:07 <napping> SOFUTPEMATACABAL: you probably need to reinstall lots of packages in the sandboxes, but it shouldn't break more than that
12:00:20 <napping> no, you definitely need to reinstall packages in the sandboxes
12:00:33 <ReinH> for the non-set version, write a function "dropToOrAll x xs" :)
12:00:45 <SOFUTPEMATACABAL> thanks, i started a sandbox from scratch, with only 1 dependecy (scotty8.1) and all builds fail
12:00:46 <ReinH> then fold over tails
12:00:54 <SOFUTPEMATACABAL> i get things such as configure: WARNING: unrecognized options: --with-compiler, --with-gcc
12:00:56 <napping> ReinH: I think I already admitted that was dropWhile . (/=)
12:01:09 <ReinH> not over tails sry
12:01:31 <ReinH> napping: but if you don't find a match you want to give xs
12:01:38 <napping> or did you mean dropTillOrKeepAll?
12:01:44 <ReinH> yes
12:01:45 <napping> dropTillOrDropAll is rather different
12:01:58 <ReinH> yes
12:02:08 <ReinH> ambiguous sorry. typing on phone :p
12:02:13 <napping> dwcook: this is a fairly pretty version of a standard style of smalltalk tutorial https://medium.com/@svenvc/rediscovering-the-ux-of-the-legendary-hp-35-scientific-pocket-calculator-d1d497ece999
12:02:35 <napping> dwcook: If the video isn't working/informative it doesn't describe enough interaction basics to work on it's own
12:03:34 <corgifex> :t let deflob m c a = case m M.! c of Nothing -> a; c'@(Just v) -> deflob m c' (v : a) in deflob
12:03:35 <lambdabot> Ord a => M.Map (Maybe a) (Maybe a) -> Maybe a -> [a] -> [a]
12:03:47 <Xenasis> Is there any Emacs package or something I can do to get automatically generated function type (that you put above the function in Haskell) like in OCaml?
12:03:50 <Xenasis> e.g. val addone : int -> int = <fun>
12:04:01 <Xenasis> Is output automatically by OCaml
12:04:53 <ReinH> Xenasis: haskell-mode and C-u C-c C-t
12:05:18 <Xenasis> ah, fantastic, thanks
12:05:44 <Xenasis> It has been one of the things that has turned me off learning Haskell so far, it was annoying (but understandably necessary) in Agda
12:05:49 <corgifex> :t let flob xs = foldl' (\z (p, x) -> M.insert x p z) M.empty (zip (tail xs') xs') where xs' = Nothing ++ map Just xs ++ Nothing in flob
12:05:50 <lambdabot>     Couldn't match expected type ‘[Maybe a2]’
12:05:50 <lambdabot>                 with actual type ‘Maybe a0’
12:05:50 <lambdabot>     Relevant bindings include
12:06:17 <corgifex> :t let flob xs = foldl' (\z (p, x) -> M.insert x p z) M.empty (zip (tail xs') xs') where xs' = [Nothing] ++ map Just xs ++ [Nothing] in flob
12:06:18 <lambdabot> Ord a => [a] -> M.Map (Maybe a) (Maybe a)
12:06:19 <ReinH> Xenasis: it's often nice to write it yourself though :)
12:06:39 <simcity2000> and good practice, in my experience
12:06:41 <ReinH> I often write the type before the definition.
12:06:48 <napping> I sometimes start from  foo :: t; foo = undefined, as you might be familiar with in Agda :)
12:06:56 <ReinH> Yep
12:07:03 <napping> still, that's a handy keybinding to know
12:07:16 <ReinH> GHC has type holes now too, so that's nice.
12:07:25 <napping> still not quite up to snuff, I think
12:07:25 <Xenasis> Eh, I don't think it's good practice - it's a waste of time o.o
12:07:45 <Xenasis> You shouldn't have to write boilerplate that can be automated
12:07:50 <corgifex> :t let deflob c m a = case m M.! c of { Nothing -> a; c'@(Just v) -> deflob c' m (v : a) }; flob xs = foldl' (\z (p, x) -> M.insert x p z) M.empty (zip (tail xs') xs') where xs' = [Nothing] ++ map Just xs ++ [Nothing] in deflob . flob
12:07:51 <lambdabot>     Couldn't match type ‘M.Map (Maybe a1) (Maybe a1)’ with ‘Maybe a’
12:07:51 <lambdabot>     Expected type: [a1] -> Maybe a
12:07:51 <lambdabot>       Actual type: [a1] -> M.Map (Maybe a1) (Maybe a1)
12:07:52 <Xenasis> that's, surely, an advantage of a complex typesystem?
12:08:15 <napping> that's generally a cost of a complet typesystem, inference getting harder
12:08:31 <napping> having to write boilerplate that can be inferred is a sign of a poorly-designed type system
12:08:42 <napping> inference becoming intractable is a common price of complexity
12:09:00 <Xenasis> I disagree, OCaml's type system is pretty much the same as Haskell's, give or take
12:09:10 <napping> Sure
12:09:18 <gipp> so I've usually found that more complex questions get ignored here, but I'm completely stumped and have a question about heterogenous lists, constraints, and typeclass instances: http://lpaste.net/106436
12:09:22 <ReinH> Xenasis: it's not a waste of time at all
12:09:22 <napping> but Agda or Coq or something requires writing types because inference is intractable
12:09:35 <ReinH> types are not boilerplate
12:09:37 <gipp> basically i have a list whose elements are guaranteed to be Monoids, and I'd like to write a Monoid instance for the list that just applies mappend elementwise
12:09:38 <Xenasis> Yeah, I understand for Agda and Coq
12:09:40 <ReinH> they are information
12:09:46 <napping> and there are some fancier features like GADTs and TypeFamilies and so on that interfere with inference if you use them
12:09:47 <Xenasis> They're information that can be generated
12:09:59 <gipp> but GHC can't seem to understand that the instances I've written cover all possible instances of the list
12:10:04 <napping> for that matter, GHC doesn't try very hard to refold type synonyms, if you use them to abbreviate stuff
12:10:21 <ReinH> They are information that you can think about to help you design your programs
12:10:33 <Xenasis> I agree, but you don't need to write them to think about things
12:10:36 <napping> gipp: I don't think it ever tries to check coverage of instances like that. Maybe look into closed type families?
12:10:52 <napping> Xenasis: well, the other reason is for debugging type errors, and typechecking incomplete programs
12:11:00 <ReinH> but it helps
12:11:11 <napping> if you can write a complete well-typed SCC in one go, and than attach inferred type signatures, that's great
12:11:11 <Xenasis> Right, but type errors can be generated by the interpreter
12:11:20 <corgifex> > let deflob c m = case m M.! c of { Nothing -> []; c'@(Just v) -> v : deflob c' m }; flob xs = foldl' (\z (p, x) -> M.insert x p z) M.empty (zip (tail xs') xs') where xs' = [Nothing] ++ map Just xs ++ [Nothing] in deflob Nothing . flob $ [5, 2, 1, 5, 6]
12:11:22 <lambdabot>  [5,6]
12:11:26 <corgifex> \o/
12:11:46 <napping> well, when you have mutual recursion putting a type signature helps localize errors to the right place
12:12:04 <napping> can O'Caml give you partial signatures even if there's a type error?
12:12:11 <corgifex> has anyone else mentioned this solution before?
12:12:38 <Xenasis> OCaml will give you the signature of it as-is or tell you the error
12:12:49 <Xenasis> example -
12:12:51 <Xenasis> # 1 + 1.1;;
12:12:51 <napping> but not a fragment of a signature even if there is an error?
12:12:53 <Xenasis> Error: This expression has type float but an expression was expected of type
12:12:55 <Xenasis>          int
12:13:01 <Xenasis> (OCaml's extremely strongly typed, and (+) takes int and int)
12:13:03 <napping> okay, that's what I expected
12:13:16 <napping> smae in Haskell, either
12:13:50 <Xenasis> I should note that 1.1 was underlined but that didn't copy/paste
12:13:52 <Xenasis> o.o
12:13:54 <napping> (+) :: (Num a) => a -> a -> a, but the arguments still have to be exactly the same type
12:14:06 <napping> > 1 + 1.1
12:14:08 <lambdabot>  2.1
12:14:13 <dv-_> :)
12:14:16 <napping> is accepted because 1 is taken as a Float literal
12:14:16 <corgifex> 1.1 + 2.2 is a type error in ocaml
12:14:23 <napping> > (1::Int) + 1.1
12:14:24 <Xenasis> Right, 'a is OCaml's syntax
12:14:24 <lambdabot>  No instance for (GHC.Real.Fractional GHC.Types.Int)
12:14:24 <lambdabot>    arising from the literal ‘1.1’
12:14:36 <Xenasis> indeed, (+.) takes float and float
12:14:40 <Xenasis> (+) takes int and int
12:14:44 <napping> complains because there's no way for 1.1 to be an Int
12:15:12 <napping> > 1%2 + 1%3
12:15:14 <lambdabot>  5 % 6
12:15:15 <napping> for fractions, if you like
12:15:27 <corgifex> > 1 + 1.1 :: Rational
12:15:28 <lambdabot>  21 % 10
12:15:39 <Xenasis> I knew Idris had that, but not Haskell
12:15:43 <Xenasis> that's pretty cool! o.o
12:15:57 <Xenasis> How is modulo done then, "mod", like in OCaml?
12:16:00 <napping> gald you found the keybinding
12:16:01 <corgifex> > 1 + 1.1 :: Complex Double
12:16:02 <jmcarthur> implementing purely functional, real-time, catenable deques. finding that while the explanation is complicated, the implementation is not... just extremely annoying and repetitive to write.
12:16:02 <lambdabot>  2.1 :+ 0.0
12:16:16 <corgifex> :t mod
12:16:18 <lambdabot> Integral a => a -> a -> a
12:16:21 <corgifex> :t rem
12:16:22 <lambdabot> Integral a => a -> a -> a
12:16:23 <napping> I'm just warning you that there's a bit more going on at the type level, that you might find yourself not liking the inferred signatures
12:16:58 <Xenasis> If the inferred signatures are bad, that's a problem with the GHCI
12:17:10 <Xenasis> not a problem inherent with inferred signatures
12:17:28 <napping> oh, higher-rank types need signatures too
12:17:33 <napping> that's undecidable
12:17:50 <napping> I assume higher rank types and GADTs require signatures in O'Caml too?
12:17:56 <jmcarthur> yes
12:17:58 <corgifex> polymorphic recursion, anyone?
12:18:14 <jmcarthur> polymorphic recursion also support by both haskell and ocaml, also requiring signatures
12:18:17 <napping> Xenasis: not wrong, but just not ideal
12:18:28 <napping> like naming variables a b c rather than something slightly more evocative
12:18:43 <jmcarthur> napping: like haskell, ocaml only requires a signature for gadts when the different cases might offer different type equalities, of course
12:18:56 <jmcarthur> napping: ocaml's gadts actually have an exhaustiveness checker that works...
12:19:04 <napping> ooh, that would be nice
12:19:09 <jmcarthur> napping: but the type information you have to give it is a lot more annoying to write than in haskell
12:19:13 <enthropy> a b c would be fine. Sometimes you get a2 b1 etc.
12:19:38 <napping> oh, yeah
12:19:54 <corgifex> http://i.imgur.com/uodSAoV.gif
12:20:19 <jmcarthur> napping: you have to declare "locally abstract types" to unify with skolems or something funny like that. i know how to do it systematically but don't really understand the reason for it.
12:20:19 <napping> but following conventions like f/g for functors/applicatives, m/n for monads i/m/s/t/a/b/u for lens, etc
12:20:41 <bennofs> corgifex: what is that?
12:20:53 <corgifex> bennofs: concentrated evil
12:20:56 <napping> What did edwardk say about backing off on the absraction a bit when the types threatended to stab him?
12:21:17 <edwardk> We had i m a s t a b u at one point.
12:21:23 <edwardk> and i decided that was enough
12:21:28 <napping> oh, there was a duplicated a
12:21:31 <edwardk> yeah
12:21:34 <merijn> napping: afaik ocaml doesn't have higher rank types
12:21:41 <jmcarthur> merijn: it sort of does
12:21:46 <enthropy> corgifex: could you update setlocale to use -XDeriveDataTypeable?
12:21:48 <edwardk> it was the actual arguments to something not all the free variables in a forall
12:21:50 <napping> I forget exactly what they have.
12:21:58 <jmcarthur> merijn: you can delare records with polymorphic fields
12:22:02 <napping> but at least they recently have first class modules
12:22:06 <jmcarthur> merijn: or first class modules that have polymorphic functions
12:22:08 <edwardk> i like variables
12:22:20 <edwardk> data Cat r a c where Shallow :: !(Queue r a b) -> Queue r a b; Deep :: !(Queue r a b) -> Cat (Composed r) b c -> !(Queue r c d) -> Cat (Composed r) d e -> !(Queue r e f) -> Cat r a c -- whee
12:22:24 <edwardk> er
12:22:28 <napping> Is hask absorbing some of that back into profunctors?
12:22:30 <edwardk> data Cat r a c where Shallow :: !(Queue r a b) -> Queue r a b; Deep :: !(Queue r a b) -> Cat (Composed r) b c -> !(Queue r c d) -> Cat (Composed r) d e -> !(Queue r e f) -> Cat r a f -- whee
12:23:02 <edwardk> i think hask and my mainsteam stuff will remain disjoint for now
12:23:07 <edwardk> its too big a change
12:23:09 <monochrom> that is very deep indeed :)
12:23:09 <platz> I think a and b, and s and t are nice - they are easy to differentiate.  I hate it people use p and q or l and r
12:23:28 <napping> The s t a b convention is pretty nice
12:23:45 <edwardk> we debated about the convention change for probably a week before shachaf won me over
12:23:48 <jmcarthur> merijn: here's what such a record looks like      type 'a st_to_run = { run : 's. ('a, 's) st }      which would allow you to write the type of something like our runST like this (dropping IO):     val run_st : 'a st_to_run -> 'a
12:23:51 <enthropy> α β
12:23:54 <edwardk> they used to just be 'a b c d'
12:24:20 <edwardk> but then to unify with the types in a traversal you had to rename a to c b to d with capture avoiding substitution in your head
12:24:20 <jmcarthur> merijn: ocaml lacks higher kinded type variables, though... which really really stinks
12:24:22 <merijn> jmcarthur: I don't know ocaml well enough, I'm just parroting what I heard before :p
12:24:27 <monochrom> a cat is a shallow queue function (base case) or a deep cat in a queue hat (induction step)
12:25:01 <napping> jmcarthur: I thought the MLF stuff was coming from people more connected with O'Caml
12:25:01 <edwardk> monochrom: yeah, just indexed so i can use it to make faster free monads and free categories
12:25:18 <jmcarthur> napping: MLF?
12:25:24 <napping> It's a type system
12:25:29 <monochrom> oh god, if that is the price of using free monads, I would rather be not free
12:25:43 <edwardk> monochrom: the goal is to make it mostly invisible ;)
12:25:53 <monochrom> ok, that sounds better!
12:26:32 <napping> Basically ML-style type inference/principal types for system F, if you promise to annotate lambda binders of variable which get used polymorphically in the body
12:26:49 <edwardk> monochrom: historically we've had three ways to play with free monads. my Free, Codensity and my Church-free encoding, but Oleg and Atze van der Ploeg just showed that we can make a form that has both the benefits of church-free and Free. fast (>>=) _and_ fast inspection
12:26:54 <napping> (not necessarily if you just take and pass them along)
12:26:58 <jmcarthur> edwardk: ah, so you're implementing the indexed sequence thing for the free monad speedup in that paper?
12:27:27 <edwardk> monochrom: so now i can merge Plan and Machine in machines, i can make free never pay the asymptotic cost, we can make it so logict deals with multiple consumers, etc.
12:27:28 <edwardk> yeah
12:27:29 <jmcarthur> edwardk: what kind of sequence data structure are you going to use?
12:27:38 <napping> jmcarthur: Daan Leijen did a bit more work, has a QMLF paper trying to integrate type classes but it sounded like there were still some excessive runtime costs to the dictionary passing
12:27:44 <phaazon> edwardk: http://fr.reddit.com/r/haskell/comments/29c9dt/interpreters_how_should_it_be_done/
12:27:49 <phaazon> jmcarthur: you might help me as well ^
12:27:53 <edwardk> jmcarthur: playing with alternatives. for free i only need an output-restricted deque / steque
12:28:10 <jmcarthur> napping: yeah the optimizer doesn't do much at a high level :(
12:28:16 <edwardk> for free categories i should do a full deque
12:28:39 <jmcarthur> edwardk: i'
12:28:41 <jmcarthur> oops
12:28:57 <edwardk> then i can build a Cat<->Prof analogue to the Set<->Rel adjunctions for quotients / equality
12:29:05 <monochrom> hmm, queue, yeah that seems helpful
12:29:07 <edwardk> for that i need the notion of a free category
12:29:34 <napping> Ogig: If you're still looking, maybe try tagsoup
12:30:07 <edwardk> anyways, i'm playing with catenable real-time steques, and implicit recursive slowdown'ed implicit recursive queues ala the end of okasaki and/or tarjan's 2000 version of them which is simpler
12:31:19 <jmcarthur> right now i'm actually experimenting with an implementation of the Mihaescu and Tarjan 2003 variation
12:31:34 <edwardk> thats the one
12:32:04 <edwardk> anyways that one i mostly want for working in hask, not for real work ;)
12:32:13 <jmcarthur> heh
12:32:20 <edwardk> i don't need splitting, so paying the full fingertree price isn't worth it
12:33:03 <napping> wow generic programming with lens is working out really nicely - def ^.. template . _Constructor to dig out all the values
12:33:18 <edwardk> :t (...)
12:33:20 <lambdabot> (Plated c, Applicative f) => LensLike f s t c c -> Over p f c c a b -> Over p f s t a b
12:33:30 <edwardk> you can use that to skip past a bunch of stuff
12:33:34 <luite_> napping: it gets better when you want to modify them
12:33:45 <edwardk> e.g. ^..foo...bar
12:34:21 <Ogig> napping, still into it. I did find tagsoup but when i was deep into html-conduit already. I think the problem is my lack of general understanding rather than the lib. Thanks for the suggestion tho. I might try and see if it comes easier.
12:34:38 <gile> guys, I am a noob at Haskell, any pointer on how to debug " Error: the input pattern doesn't comply with the table pattern."
12:34:40 <napping> Ogig: actually looks like you got pretty darn close with HXT, if you're fishing out the top dib
12:35:07 <napping> gile: I've never seen that error before. paste some code?
12:35:15 <gile> sure, sec
12:36:12 <napping> edwardk: huh, interesting. I'm just fishing out leaves, but I'll keep the plated one in mind
12:36:50 <gile> napping: I bet this is not very helpful, but at least we can start from something http://pastebin.com/DuLkpRs3
12:37:09 <gile> I assume I get that error when it hits c0
12:37:20 <gile> the table is defined separately in a different file
12:37:32 <napping> I don't recognize that at all
12:37:36 <napping> Is that using some library?
12:38:01 <gile> https://github.storm.gatech.edu/NetASM
12:38:03 <napping> With a '#' comment that doesn't even look like Haskell
12:38:07 <gile> that was me
12:38:13 <gile> while doing the pastebin
12:38:20 <gile> it's not in the hs file
12:39:05 <napping> I just get errors "Not in scope: data constructor ‘WRT’", etc.
12:39:23 <napping> and other than that it looks completely well-formed
12:39:36 <napping> unless perhaps some of those are CPP macros or something crazier?
12:39:50 <napping> sounds like an error from that tool/library rather than a general Haskell thing
12:39:56 <napping> oh, and that github wants a login
12:40:04 <gile> hmm
12:40:06 <gile> sec
12:40:13 <napping> https://github.com/NetASM/NetASM-haskell
12:40:15 <napping> that close?
12:40:19 <gile> git clone https://github.com/NetASM/NetASM-haskell.git
12:40:21 <gile> sorry
12:40:35 <napping> sorry, that's a bit deeper than I want to get
12:40:46 <napping> If you can make a small self-contained file that shows the error I'll take a look
12:41:11 <napping> even if I do need to clone and build that thingy
12:41:29 <gile> I figured
12:41:30 <napping> but it sounds like NetASM is itself a compiler, and you're getting an error from it, rather than a general Haskell thing
12:41:49 <gile> I am not compiling
12:41:53 <napping> cause that snipped is just declaring constant data by the looks of it
12:42:02 <gile>  runhaskell Apps/ACL_Assignment_/Run.hs
12:42:03 <gile> Run.hs: Error: the input pattern doesn't comply with the table pattern.
12:42:07 <napping> so if that's actually in a .hs file, something crazy is going on
12:42:28 <napping> maybe there's template haskell in the Run.hs file?
12:42:40 <napping> any kind of $(foo ...) going on, or a bare expression at the top level?
12:43:15 <gile> I don't see something like that
12:43:31 <gile> looks like a normal haskell script
12:43:45 <gile> anything weird you see with my table maybe?
12:43:51 <gile> regarding patterns?
12:43:55 <napping> There's not an Apps/ACL_Assignment_ in there
12:44:01 <gile> yeah
12:44:03 <gile> sec
12:44:06 <napping> no, the only patterns are the names on the left hand side of =
12:44:14 <napping> nothing possibly wrong with those
12:44:17 <gile> wget -O ACL_Assignment_.zip  https://d396qusza40orc.cloudfront.net/sdn/srcs/netasm-assignment.zip
12:44:26 <napping> I think you need to find somebody that knows netasm
12:44:30 <gile> k
12:44:36 <gile> I don't want to bother you too much then
12:45:10 <gile> I am working on a SDN course, on Coursera, and this week they have the assignment in Haskell
12:45:23 <gile> so far I figured my self out in python :)
12:45:35 <gile> napping: thanks man
12:45:46 <napping> ah, that's clearly coming from inside the execut call
12:45:50 <napping> or the other one
12:46:09 <napping> right, you said "runhaskell"
12:46:14 <napping> looks like an error thrown at runtime
12:46:23 <gile> and what does that mean?
12:46:28 <edwardk> phaazon: i replied on your reddit thread
12:46:31 <napping> You should be able to compile it ahead of time with ghc --make Run.hs and get a program
12:46:33 <edwardk> phaazon: hope that helps
12:46:42 <napping> and then it just complains when you type ./Run, I think
12:46:50 <gile> let me try that
12:46:58 <napping> and if so, nothing is wrong with your Haskell as Haskell, just the values/arguments you're passing
12:47:23 <napping> I guess (template . _Just) doesn't have *that* scary of an inferred type signature
12:47:23 <phaazon> edwardk: thank you, I finish having dinner then I check :
12:47:24 <phaazon> :)
12:47:41 <gile> I don't get a Run file
12:47:56 <napping> maybe something else?
12:48:02 <napping> or change the module name in Run to Main
12:48:03 <gile> Code.hi  Code.hs  Code.o  Run.hi  Run.hs  Run.o
12:48:08 <gile> aha
12:48:42 <napping> you can override it if you want, but by default it only makes an executable if you give it a module named Main that defines main :: IO ()
12:48:53 <napping> I suppose runhaskell just takes main :: IO () from whatever you point it at
12:49:04 <napping> you don't  need to rename the file itself, eitehr
12:50:56 <napping> the O'Caml guy left?
12:51:58 <napping> I was going to ask if inferring template . _Just :: (Applicative f, Typeable a, Data s) => (a -> f a) -> s -> f s rather than :: (Data s, Typeable a) => Traversal' s a should be considered a bug
12:52:05 <napping> would be nice if were fixed as one
12:52:55 <gile> same error on two machines, so nothing wrong with my environment
12:53:10 <napping> could you compile it to a binary?
12:53:24 <gile> if you instruct me how
12:53:37 <gile> no clue what I need to change
12:53:39 <napping> open Run.hs, change "module Run" to "module Main" at the top
12:53:47 <napping> then ghc --make Run should give you a binary
12:54:25 <gile> I have this
12:54:28 <napping> (rather than the error)
12:54:29 <gile> module Apps.ACL_Assignment_.Run where
12:54:34 <gile> I need to change that?
12:54:39 <napping> oh, just delete it entirely if you like
12:54:41 <gile> to module Main where?
12:54:47 <gile> k
12:54:52 <napping> but yeah, "module Main where" should work too
12:55:00 <gile> comment
12:55:02 <gile> sec
12:55:17 <napping> I'm not entirely sure about the directory structure, but it's worth trying
12:55:48 <gile> ghc --make Apps/ACL_Assignment_/Run.hs
12:55:50 <gile> ?
12:55:55 <napping> sure, that's probably best
12:55:58 <gile> File name does not match module name:
12:56:14 <gile> so module Main I suppose
12:56:24 <napping> yeah, try that too
12:56:43 <napping> I usually set things up as a cabal project, don't remeber entirely how it goes by hand
12:57:01 <gile> it fails on import now
12:57:10 <gile> 46:1: parse error on input ‘import’
12:57:14 <gile> import Utils.Map
12:57:34 <napping> one more thing to try is just copying it up to the root directory
12:57:48 <napping> so mapping Utils.Map to checking for a Utils/Map.hs would do the right thing
12:58:20 <gile> where do I get Utils/Map?
12:58:42 <gile> I don't have that in this git tree
12:58:47 <gile> I have the others though
12:58:59 <napping> that's at the github thing you linked me
12:59:09 <napping> and I'm wondering how runhaskell worked at all then
12:59:35 <gile> yeah, it's not there
12:59:42 <napping> you're running from the root directory?
12:59:48 <napping> ghc --make Apps/... , I mean?
13:00:02 <gile> yes
13:00:17 <napping> because I just checked here that if I have some A/T.hs and B/X.hs and B/Run.hs, with A.T and B.X defining stuff
13:00:26 <napping> then ghc --make B/Run.hs from the root directory works fine
13:00:49 <napping> whether I have no module line or a module Main where line
13:01:00 <gile> how about this
13:01:02 <gile> you do this
13:01:10 <gile> wget -O ACL_Assignment_.zip  https://d396qusza40orc.cloudfront.net/sdn/srcs/netasm-assignment.zip
13:01:14 <gile> move that file in Apps
13:01:16 <gile> unzip it
13:01:25 <gile> and I can provide you my Code.hs and Run.hs
13:01:27 <gile> ?
13:01:34 <gile> and you tell me if I am smocking crack
13:01:39 <gile> of course if you have the time
13:02:00 <phaazon> edwardk: thank you for your feedback, I still need to decipher :D but thank you very much
13:03:00 <napping> gile: unzipping the .zip into the Apps directory of a fresh clone of master of https://github.com/NetASM/NetASM-haskell seems to work fine
13:03:55 <napping> then if I comment out -- module Apps.ACL_Assignment_.Run where
13:04:05 <marchelzo_> I can't backspace when giving a haskell program input on stdin. Is that normal and is there a way to get around it?
13:04:22 <napping> and run ghc --make Apps/ACL_Assignment_/Run.hs from the root of the checkout, I get a binary at Apps/ACL_Assignment_/Run
13:04:27 <napping> which prints some stuff
13:04:32 <gile> hmm
13:04:43 <gile> I have modified the files
13:04:51 <gile> since that's the point of the assignment
13:04:58 <napping> If you are missing Utils.Map, probably you have the wrong version of the checkout
13:05:08 <gile> do you have Utils.Map?
13:05:16 <napping> well, you could also try doing what I did with the zip you pointed at me
13:05:22 <napping> yeah, I cloned from the github repository
13:05:30 <napping> which has Utils.Map
13:05:43 <napping> anyway, if runhaskell does something, it's somehow finding a version of that
13:05:57 <napping> so the other thing to try before you go off along that line is just to open your run.hs in GHCI
13:06:25 <napping> put back the module line, and run ghci Apps/ACL_Assignment_/Run.hs from the root, and see if that does anything
13:07:40 <gile> napping: http://pastebin.com/y5hRa9Gm and http://pastebin.com/6ew6476t
13:07:42 <napping> (It's pretty likely to give you a similar error, then maybe you should try checking out NetASM from github and building/running your code inside that)
13:07:55 <gile> can you grab them and run it with those?
13:08:12 <gile> napping: I did that 10m ago, on a separate VM
13:08:24 <gile> I get the same error when using my modified files
13:09:04 <gile> first is Run.hs and second is Code.sh
13:10:02 <napping> after commenting out the module header, it compiles fine to a binary
13:10:13 <napping> which then complains "Run: Error: the input pattern doesn't comply with the table pattern."
13:10:22 <napping> seems you have a dodgy version of the NetASM code checked out
13:11:13 <napping> and separately some errors in your NetASM assmebly
13:11:24 <napping> and I should really get back to my own work :)
13:11:27 <gile> oh well
13:11:28 <gile> thanks
13:11:34 <gile> I'll get back to drawing board
13:11:52 <napping> I'd certainly hope this NetASM thing comes with nicer tools for checking/debugging programs than that
13:12:07 <gile> or go to bed and try it tmr
13:12:20 <napping> and you might still have some Haskell questions about installing packages or something
13:12:24 <gile> napping: that's why I wasn't sure if it's a haskell issue or NetASM
13:12:42 <napping> I have no idea how runhaskell could be working, unless you do have a Utils/Map.hs somewhere, or you've somehow installed a binary compiled version of NetASM which does
13:12:50 <gile> before hitting this, it was complaining pretty much with nice details
13:12:57 <napping> (but then, ghc --make should probably have found and used that, unless something else was going on)
13:13:00 <gile> no, I did git clone
13:13:11 <napping> but from the gatech repo, right?
13:13:20 <napping> which I never saw, maybe it's missing Util.Maps?
13:13:53 <gile> all I did was installed ghc
13:13:56 <napping> you know, if you're following a course, a link to their install instructions would help
13:13:57 <gile> and git clone https://github.com/NetASM/NetASM-haskell.git
13:14:12 <napping> one thing to check is running ghci in a directory *far away* from youre NetASM checkout
13:14:18 <gile> it's not public....
13:14:27 <napping> and type import Utils.Map
13:14:31 <napping> and see if it says anything
13:14:40 <gile> Could not find module ‘Utils.Map’
13:14:47 <napping> huh, no dice there
13:15:12 <gile> does that work for you in the directory?
13:15:19 <gile> doesn't for me
13:15:31 <napping> yeah, but I have that file
13:15:38 <napping> and I don't think runhaskell does anything different
13:15:38 <gile> from the git?
13:15:45 <napping> so it's really weird if it can get far enough to complain
13:16:30 <napping> oh, it can't import it from the directory either, but :load Utils.Map does work
13:17:07 <gile> doesn't work for me
13:17:14 <napping> also, just to check, run "cabal sandbox list-sources" in the root of your checkout
13:17:31 <napping> It should give you some error
13:17:39 <gile> no command found :)
13:17:46 <napping> okay, so it's not that either
13:17:51 <napping> try runhaskell again?
13:18:12 <gile> [idonev@snupe NetASM-haskell (master %=)]$ runhaskell Apps/ACL_Assignment_/Run.hs
13:18:14 <gile> Run.hs: Error: the input pattern doesn't comply with the table pattern.
13:18:22 <napping> that is super werid
13:18:31 <napping> maybe runhaskell -v
13:18:59 <napping> you could also try deleting the import of Utils.Map...
13:19:19 <napping> if you think there's any chance the private repository is better to use
13:19:25 <gile> Ok, modules loaded: Apps.ACL_Assignment_.Run, Utils.Map, Core.Language, Core.PacketParser, Apps.ACL_Assignment_.Code, Utils.List.
13:19:32 <gile> wtf
13:19:38 <napping> yeah, and where is it finding that Utils.Map?
13:19:44 <gile> no idea
13:20:05 <napping> un, runhaskell -v dumps lots of output for me
13:20:27 <gile> duh
13:20:46 <gile> I am blind
13:20:55 <gile> Apps  Core  LICENSE  README.md  Utils
13:20:58 <gile> it's there in the root
13:21:13 <napping> and there's a Maps.hs under it?
13:21:17 <gile> y
13:21:35 <napping> and this is the same root from which you were running ghc when it complained about not finding Utils.Maps?
13:21:44 <napping> Utils.Map, rather?
13:22:18 <gile> ghc never complained about that
13:22:26 <gile> [idonev@snupe NetASM-haskell (master %=)]$ ghc --make Apps/ACL_Assignment_/Run.hs
13:22:28 <gile> [5 of 6] Compiling Apps.ACL_Assignment_.Code ( Apps/ACL_Assignment_/Code.hs, Apps/ACL_Assignment_/Code.o )
13:22:29 <gile> [6 of 6] Compiling Apps.ACL_Assignment_.Run ( Apps/ACL_Assignment_/Run.hs, Apps/ACL_Assignment_/Run.o )
13:23:07 <gile> Linking Apps/ACL_Assignment_/Run ...
13:23:11 <napping> okay
13:23:15 <gile> after removing the first line
13:23:21 <napping> so then run ./Apps/ACL_Assignment_/Run
13:23:32 <gile> but it's not very helpful
13:23:43 <napping> I didn't mention it might dump the binary next to the .hs file?
13:23:49 <napping> I thought you weren't getting a binary at all.
13:24:01 <gile> I get the binary
13:24:06 <gile> but it throws the same error
13:24:08 <napping> and that's what most of what I've been suggesting for a while was about
13:24:11 <gile> and I have no idea how to address it
13:24:17 <napping> sure
13:24:27 <napping> that, I'm afraid, is now entirely a matter of this NetASM library
13:24:39 <gile> yeah
13:24:46 <gile> I agree
13:24:54 <gile> napping++
13:24:59 <gile> thanks a lot and have a nice day
13:25:02 <napping> I guess just try general stuff like building forwards from an older working version, or go with Python thingy if you have that working, or whatever
13:32:56 * hamid screams for fun.
13:34:51 <ggnmk> which library should I use if I want to build an API that sends http requests through a proxy? I've attempted ControlProxy.TCP and Network.HTTP.Proxy (and ...Conduits) without success
13:34:52 <codygman> What Type would this date be: 2013:12:07 18:00:16? My latest attempt didn't work: parseTime defaultTimeLocale "%y:%m:%d %T" "2013:12:07 18:00:16" :: Maybe UTCTime
13:35:54 <napping> codygman: what does formatting a type through that string give you?
13:36:07 <codygman> napping: Nothing
13:36:21 <napping> *formatting*
13:36:41 <napping> or does the printer also return Nothing?
13:39:00 <codygman> The printer returns nothing when I use the print function, yes.
13:39:05 <codygman> if that's what you mean
13:39:45 <napping> print . formatTime defaultTimeLocale "%y:%m:%d %T" =<< getCurrentTime
13:39:50 <napping> prints 14:06:28 20:38:09
13:40:04 <napping> don't say Nothing unless you are talking about Data.Maybe
13:40:17 <napping> how about "%Y:%m:%d %T?
13:40:40 <codygman> napping: Yep, that was the problem
13:40:51 <mmmm> It's way too easy to just stick another monad transformer on your monad stack
13:40:53 <codygman> >  parseTime defaultTimeLocale "%Y:%m:%d %T" "2013:12:07 18:00:16" :: Maybe UTCTime
13:40:55 <lambdabot>  Not in scope: type constructor or class ‘UTCTime’Not in scope: ‘parseTime’No...
13:40:59 <mmmm> makes me want to write all my code with the identity monad
13:41:53 <napping> works here
13:41:56 <eikke__> anyone familiar with Warp?
13:51:14 <Tjr> I've found several complicated explanations - do you know a simple one? What is the "free", as in free monads?
13:52:04 <solrize> why is read so slow?
13:52:12 <solrize> for integers e.g.
13:53:39 <rien> Tjr: the list monad has the same shape as the minimum structure for a functor to be a monad
13:54:07 <pieter_> ooooooooooooooooooooo
13:54:35 <Tjr> rien: you're probably not saying that all monads are variations of list.
13:54:57 <rien> Tjr: in a way yes
13:55:05 <rien> just with more structure
13:55:12 <hiptobecubic> I'm not sure that's a helpful thing to say
13:55:13 <bennofs> rien: a free monad is not a list
13:55:15 <napping> free monoids are lists
13:55:22 <napping> free monads are trees
13:55:26 <eikke__> free monads are trees
13:55:42 <rien> true, my mistake
13:55:42 <eikke__> haha
13:56:03 <napping> free monoids are trees
13:56:09 <rien> the free monad is a tree because a monad can dynamically decide the next action to take
13:56:20 <rien> so that ends up modeling a tree
13:56:20 <napping> the only thing a monoid promises is that there's a distinguished empty element, which is the unit for an associative operation
13:56:24 <napping> and a list is like that
13:56:25 <Tjr> I know the concept of free groups from algebra. Those are groups generated by some set of elements, where you basically assume the least amout of equality in the generated group.
13:56:26 <eikke__> Tjr: you could look up "free object" on Wikipedia
13:56:39 <rien> napping: right, I confused monoids and monads for a bit there
13:56:40 <mmmm> it's the same thing but for a functor rather than a set
13:56:42 <hpc> what's the free comonad?
13:56:42 <StoneCypher4k> wikipedia: for when you want to sort of get it
13:56:53 <napping> thats an instance of freeness
13:57:10 <Tjr> eikke__: "In mathematics, the idea of a free object is ..." Maths, or haskell?
13:57:18 <napping> you have a monoid on [a] for any a
13:57:21 <eikke__> StoneCypher4k: any other textbook on CT could do as well
13:57:23 <rien> Tjr: haskell is math
13:57:29 <hiptobecubic> StoneCypher4k, review for people who already get it.
13:57:44 <napping> if you pick a particular monoid on a, you can turn a [a] into a single by folding with that monoid
13:57:53 <napping> and it commutes with appending lists
13:58:02 <eikke__> :t Data.Foldable.fold
13:58:03 <lambdabot> (Monoid m, Foldable t) => t m -> m
13:58:17 <bennofs> :t Control.Comonad.Cofree.Cofree
13:58:18 <lambdabot>     Not in scope: data constructor ‘Control.Comonad.Cofree.Cofree’
13:58:19 <napping> well, that's saying [a] is the initial monoid over a
13:58:28 <rien> it's the initial algebra for it
13:58:39 <napping> maybe there's more to being free?
14:02:08 <Ogig> napping, i was indeed close, just a 4 lines function away to parse again the nodes.
14:02:44 <Ogig> wasting hours learning something and then come up with a 2 lines solutions is a repeating pattern in my haskell learning process, not sure if i like it.
14:02:52 <Tjr> rien: There are lots of meanings of free. Free beer, free (generated) group, free monad, free speech, free theorem.
14:03:42 <Tjr> rien: "because a monad can dynamically decide the next action to take" -- I'm not sure I understand that.
14:04:13 <hpc> :t guard
14:04:14 <lambdabot> MonadPlus m => Bool -> m ()
14:04:17 <hpc> er
14:04:19 <hpc> :t when
14:04:20 <lambdabot> Monad m => Bool -> m () -> m ()
14:04:25 <Tjr> Ogig: Same experience doing maths research
14:04:42 <hpc> Tjr: being able to write something like foo >>= \p -> when p bar
14:04:46 <rien> Tjr: if just need to chain actions together you can do that with Applicative, there's no need for a Monad. That is, if you know your actions beforehand.
14:05:16 <napping> Ogig: Would you rather learn something for hours and then find out it wasn't strong enough to give you a 2 lines solution? Or just take less hours?
14:05:51 <Tjr> napping: "you can turn a [a] into a single by folding" -- what do you mean by single?
14:06:19 <napping> into a single a
14:06:38 <napping> or a single value in whatever monoid it is that you have a function from a into
14:07:01 <napping> like, foldMap f (l1++l2) = foldMap f l1 <> foldMap f l2
14:07:11 <napping> foldMap f [] = mempty
14:07:16 <napping> foldMap f [a] = f a
14:07:58 <napping> so any other way of mapping a into a monoid is in some sense a specialization of just keeping a [a]
14:08:29 <napping> similarly, for any monad you can find some functor f so the tree over f is an inital monad
14:08:52 <Tjr> I can see how a list is an initial element in the category of monoids
14:08:58 <Tjr> * countable monoids
14:09:08 <napping> like if you just have a putChar :: Char -> m () and getChar :: m Char
14:09:10 <Tjr> But I can't follow for monads
14:09:26 <napping> you can define a functor CharOps a = PutChar Char a | GetChar (Char -> a)
14:09:50 <napping> and then the free monad from data Free f a = Return a | Act (f (Free f a))
14:09:54 <Tjr> * countable monoids generated by finitely many elements
14:10:29 <Ogig> napping, both things :)
14:10:34 <gilligan-> hm, is it in any way weird or bad style to use the state monad with an empty return value ? In some cases it just does not seem to be necessary to have a return value besides the  (arbitrarily complex) state that is carried around.
14:10:36 <napping> Free CharOps is more general than your monad
14:10:58 <c_wraith> gilligan-: State Foo () is fine
14:11:09 <napping> any Free CharOps a is a tree with leaves of Return carrying an a, 1-ary nodes labeled with a Char from your PutChar operation, and |Char|-ary nodes from GetChar
14:11:18 <gilligan-> c_wraith, ok thanks ;]
14:11:39 <c_wraith> gilligan-: unless that's what *everything* is, in which case it's a hint that you could just be using Foo -> Foo functions
14:11:45 <napping> The |Char|-ary nodes from that (Char -> a) in the functor correspond to your operation "making a choice" based on a Char
14:11:52 <Tjr> napping: what you're explaining sounds a lot like the parse tree in a language like lisp
14:12:12 <napping> and then the monad operation over Free is just taking a function from an "a" to another tree, and applying substitution
14:12:40 <napping> and you can map Free CharOps back into your monad by just running the operations
14:13:02 <napping> so it's initial in the same way lists are for monoids
14:13:17 <napping> incidentally anything about being finite is just in the number of mappens you take
14:13:25 <napping> a could itself be an infinite type
14:13:31 <napping> and [a] is still an initial monoid for a
14:13:46 <napping> unless your notion of monoid assumes you can take the monoidal sum of an infinite number of values
14:14:33 <c_wraith> some monoids can handle infinite numbers of values, if they're arranged well.  First, for instance.
14:15:01 <Tjr> So can I think of a free monad as the graph how a series of nested monadic statements are hooked up to each other?
14:15:07 <napping> well, I'm more talking about how [] doesn't assume the monoid is just finitely generated
14:15:11 <napping> Tjr: it was a bit more explicit than that
14:15:35 <napping> data CharOpsTree a = Return a | PutChar Char (CharOpsTree a) | GetChar (Char -> CharOpsTree a)
14:15:42 <napping> it's not just a graph
14:15:48 <Tjr> yes, I saw that bit
14:16:00 <Tjr> However its significance isn't quite clear to me
14:16:08 <Tjr> it's a special graph -- a tree
14:16:08 <napping> well, if you consider the GetChar nodes as having a subtree showing the sequence of operations you'd get for each possible value
14:16:09 <gilligan-> c_wraith, yeah that is something i've been wondering as well. I've made up a toy example to get used to the concept : State Hero DeadOrAlive -- so the state captures properties of an imaginary game player and interactions with the state return whether the player is still alive or not. Apart from the fact that this is a silly example i could surely also do it without the use of the state monad ...
14:16:16 <napping> it's more like fully unrolling every possible computation
14:16:37 <napping> or perhaps a graph of possible executions, not just how your statements are connected
14:17:04 <Tjr> back to the charops tree
14:17:14 <Tjr> I assume it's a model for something "real"
14:17:57 <napping> processes calling putChar and getChar?
14:18:12 <Tjr> and doing funky stuff in between that the chars don't see
14:18:16 <napping> throw in a few other primitives and you have a decent little IO thing like Li and Zdancewic
14:18:41 <napping> well, as far as the monoidal structure goes the only thing that matters is whether they end up calling putChar or getChar next
14:19:16 <Tjr> so how is the data structure CharOpsTree a monad?
14:19:41 <napping> join (Return t) = t; join (PutChar c t) = PutChar c (join t); join (GetChar k) = GetChar (join . k)
14:19:45 <Tjr> Certainly you ca
14:19:56 <napping> and return = Return, of couse
14:21:18 <c_wraith> gilligan-: It really does depend only on how much benefit you get out of having the extra value you can return.  If you don't use it often, it may be worth reconsidering.
14:21:27 <Tjr> so "PutChar Char (CharOpsTree a)" should be interpreted as print Char, then do whatever a tells us next. Right?
14:21:43 <napping> that's all mixed up
14:22:02 <napping> putChar 'x' t would print 'x' and then do whatever t says
14:22:22 <napping> CharOpsTree (CharOpsTree a) would do some sequence of putChar/getChar, and then return you a CharOpsTree a
14:22:50 <c_wraith> gilligan-: But that's really hard to put down hard rules for.  It comes down to how well things look, and how well they fit together.
14:23:52 <Tjr> so are you saying the mixup is between PutChar (the data type for a possible future computation ) and putChar (which turns the blueprint into action)?
14:24:33 <napping> no, you were mixing up PutChar which is a constructor, with Char and CharOpTree a which are types
14:24:49 <Tjr> By analogy to free groups in maths, I'd call PutChar the free monad and puChar the epimorphism from the free monad to some other concrete monad
14:25:00 <napping> that sounds about right
14:25:32 <napping> if you consider every possible monad which provides a putChar :: Char -> m () and a getChar :: m Char, CharOpsTree is initial among them
14:25:56 <napping> and we can uniformly build these tree thingies from functors with Free
14:26:12 <Tjr> initial, at the price of a very complicated morphism that depends on a lot of other stuff
14:26:23 <napping> hmm, probably not too complicated
14:26:46 <napping> just run (PutChar c t) = putChar c >> run t; run (GetChar k) = getChar >>= run . k; run (Return x) = return x
14:26:58 <napping> for whatever other choice of target monad / putChar you have in mind
14:27:00 <Tjr> for example, the morphism that takes the tree to emacs might depend on more than just the last letter typed.
14:27:20 <napping> now of course the target monad could have an arbitrarily complicated implementation
14:27:44 <napping> consuming such a tree by actually running it is a completely different operation than mapping from the tree into some other monad which provides appropriate operations
14:28:16 <napping> only the later is specifically the monad morphism, and that's simple.
14:28:30 <Tjr> I'm thinking in maths terms right now. Maps /are/ the abstraction of running things on a computer.
14:29:00 <napping> sure, but in math terms the complicated actually running bit is a function IO a -> World -> a
14:29:19 <napping> the morphism is just the nice simple CharOpsTree a -> IO a
14:29:32 <napping> which couldn't possibly depend on your emacs or whatever - no World around
14:29:47 <Tjr> I thought we were trying to map CharOpsTree  -> a, not (IO a -> World ) -> a
14:30:15 <napping> you want forall a . CharOptsTree a -> m a, for some other operation a
14:30:22 <napping> for some other monad m, rather
14:30:37 <napping> monads take type paramters
14:30:42 * Tjr doesn't know yet how haskell mangles "forall"
14:30:52 <napping> nothing of type CharOptsTree a -> a could sensibly be a monad morphism
14:31:33 <napping> I meant that fairly literally - you could have runChars :: forall a . CharOpsTree a -> IO a
14:31:40 <napping> you don't usually type "forall a .", but with extensions you can
14:31:44 <Tjr> ah, my error was thinking of "m a" as "[a]"
14:31:57 <Tjr> but lists don't have enough internal state to model something like emas
14:31:59 <Tjr> emacs
14:32:01 <napping> and for various reasons that turns out to be a natural transformation
14:32:23 <napping> the first issue is that lists may be monads, but they don't provide a putChar or getChar operation
14:32:35 <napping> and CharOpsTree is only promisied to be initial over monads that additionally provde that
14:33:03 <napping> Identity is free if you don't assume any other operations exist
14:33:25 <napping> because if you don't know any other operations in a monad m besides return, the only way you can build an m a is by returning some actuall a
14:33:42 <Tjr> sure, just replace (:) with getChar, and putChar with "do nothing". Then you'd need to be able to make CharOpsTree to list.
14:33:51 <Tjr> s/replace/map/
14:33:52 <napping> huh?
14:34:01 <napping> that's kinda backwards
14:34:18 <napping> GetChar :: (Char -> CharOpsTree a) -> CharOpsTree a
14:34:23 <napping> we can't get a Char from that
14:35:07 <Tjr> * need to be able to MAP CharOpsTree to list
14:35:12 <Tjr> woops
14:35:33 <napping> running a CharOpsTree on a list of input could only possibly be a monad morphism from CharOpsTree to itself
14:35:45 <napping> and it certainly doesn't commute with all the operations correctly to be even that
14:36:07 <napping> but for example you could map into State Char
14:36:10 <Abathurr> can anyone recommend a book that goes more in-depth than LYAHFGG
14:36:15 <napping> turning putChar and getChar into put and get
14:36:21 <napping> you'd certainly lose possible behaviors
14:36:29 <Tjr> since you're saying that CharOpsTree is initial for monads with certain operations, I started to play with the list monad and declared (:) to be one of those certain operations. Just to see what it would mean.
14:36:41 <napping> but being initial is the most informative one
14:36:53 <napping> except it kinda has the wrong type
14:37:03 <napping> now you could turn putChar to (:)
14:37:11 <Tjr> right
14:37:13 <napping> and just always return the some fixed '_' for getChar
14:37:25 <napping> but I don't think that respects the list monad operations correctly
14:37:26 <Tjr> and getchar to something trivial, if you input the same char over and over
14:37:33 <napping> no, that doesn't work at all
14:37:38 <napping> you still have Return a for an arbitrary a
14:37:49 <napping> so you list would also have to be [a] for the same a
14:37:52 <napping> and you can't assume it's Char
14:38:00 <napping> how about the State Char example?
14:38:13 * Tjr is a bit lost.
14:38:36 <napping> consider this - f :: CharOpsTree a -> State Char a
14:38:54 <napping> f (Return a) = Return a; f (PutChar c t) = put c >> f t; f (GetChar k) = get >>= f . k
14:39:31 <napping> you'd need to show f (join t) = join (f . fmap f) t
14:39:41 <napping>  f (join t) = join ((f . fmap f) t), rather
14:40:07 <napping> f (join (Return t0)) = f t = join (return (f t0))
14:40:19 <napping> etc.
14:40:23 <Tjr> your definition of f looks like a good candidate for " fmap f GetCharTree"
14:40:24 <napping> so it all works
14:40:34 <napping> what's a GetCharTree?
14:40:55 <Tjr> * CharOpsTree
14:41:35 <napping> what does that mean?
14:41:52 <napping> fmap f :: (Functor f) => f (CharOpsTree a) -> f (State Char a)
14:42:06 <napping> that does show up checking that join is respected
14:42:14 <Tjr> (join t) = join (f . fmap f) t -- why is f twice on the right side?
14:42:27 <Tjr> wouldn't the monad laws demand
14:42:34 <Tjr> (join t) = join ( fmap f t )
14:42:42 <napping> you start with a CharOpsTree (CharOpsTree a)
14:42:50 <Tjr> wait
14:42:55 <Tjr> are these the monad laws?
14:42:58 <napping> and check that whether you join before and then use f, or use f and then join, you get the same answer
14:43:13 <napping> related to the monad laws
14:43:22 <napping> checking the f is a homomorphism preserving things
14:43:29 <napping> preserving the monad operations, rather
14:43:37 <Tjr> why do you need to check them? If they're related, shouldn't they follow from the original monad laws?
14:43:42 <napping> no
14:44:07 <Tjr> "preserving the monad operations," -- ok
14:44:17 <napping> like mapping CharOpsTree a into [a] just by applying it to some fixed input
14:45:24 <napping> to use f to turn CharOpsTree (CharOpsTree a) into State Char (State Char a), you need f . fmap f
14:45:27 <napping> or fmap f . f
14:45:32 <Tjr> I'm still pondering how you get from "preserve monad laws" to the specific form of the equations
14:45:42 <napping> preserve the operations rater
14:45:50 <napping> CharOpsTree is a monad, State Char a is a monad
14:45:54 <Tjr> (specializing these to the CharOpsTree is the easier part)
14:46:03 <napping> but f (return x) better equal return x
14:46:51 <napping> and so on
14:46:53 <Tjr> f (return x) == return x -- ok, I see why that should hold
14:46:59 <napping> otherwise you have two monads and some random function beteween
14:47:07 <napping> not actually a homomorphism of monads
14:47:28 <napping> And if we were just caring about having any old random function, () or something would be initial
14:47:39 <Tjr> [off-topic] when do you say homomorphism, and when so you say morphism?
14:47:59 <napping> dunno
14:48:03 <athan> Could someone verify my understanding? So `deepseq` basically evaluates an entire thunk and it's child thunks as if the data type had been considered entirely strict, while with `seq`, you can manually evaluate sub-parts and have discretion...?
14:48:35 <napping> I guess I just say homomorphism if I want to emphasize the morphism we are talking about are not just plain old functions
14:48:58 <napping> sometimes morphism are just functions
14:48:59 <napping> or well-typed functions, at elast
14:49:55 <Tjr> (join t) = join (f . fmap f) t -- how does this derive from the monad laws?
14:50:55 <eikke__> Tjr: won't you need an f on the LHS?
14:51:18 <Tjr> eikke__: I'm just citing what I don't understand
14:51:23 <napping> that's not from a monad lay
14:51:29 <napping> that's just preserving join
14:51:42 <napping> f . join t = join ((f . fmap f) t)
14:51:44 <napping> was the correct form
14:52:01 <napping> draw a pretty square for it
14:52:29 <Tjr> f . join[preimage] t = join[image] ((f . fmap f) t)
14:52:40 <napping> yeah, that's it
14:53:07 <Tjr> why (f . fmap f)?
14:53:08 <eikke__> makes more sense than the original question :)
14:53:12 <napping> It's not f . join = join . f because the source and result of join have different types/shapes
14:53:36 <napping> f . join = join . f is ill-typed
14:54:04 <Tjr> sure
14:54:11 <johnw> is there any way to control backtracking in a parser like Parsec?  I have a situation where I need to read N tokens into the stream; if I encounter token X, I want to continue ahead and report any errors; if I encounter token Y, I want to backtrack by N tokens and then try another parser
14:54:22 <Tjr> why not simply "(fmap f)", eliminating the second f?
14:54:30 <napping> that's also ill-typed
14:55:12 <Tjr> Probably I'm dense, it looks well-typed to me
14:57:56 <napping> join :: m (m a) -> m a
14:57:59 <napping> f :: m a -> n a
14:58:16 <napping> fmap f over something of type m (m a) gives you something of type m (n a)
14:58:22 <Tjr> join[preimage] :: m (m a) -> m a
14:58:24 <napping> why should it be any more well-typed than just f alone?
14:58:31 <Tjr> join[image] :: n (n a) -> n a
14:58:46 <napping> just the (f t) part would have been well-typed too, giving you n (m a)
14:59:03 <napping> f . fmap f is obviously the right thing
14:59:17 <napping> the interesting question is whether some systematic procedure tells you that's the one you want, I don't know.
14:59:52 <phaazon> woah
15:00:00 <phaazon> bound sounds to resolve my issue
15:00:03 <phaazon> gonna give it a try
15:00:11 <napping> it is pretty nifty
15:00:17 <napping> whether or not it will fix your issue
15:00:52 <napping> as they say, "lens is a pretty cool guy. Eh writes Haskell and doesn't afraid of profunctors".
15:01:12 <napping> Tjr_: connection troubles?
15:01:18 <Tjr_> yes
15:01:22 * Tjr_ Is reading the logs
15:01:23 <napping> Tjr: or are you different people?
15:01:31 <Tjr_> also yes
15:01:37 <Tjr_> because yes or yes is yes :-)
15:01:47 <Tjr_> because yes or no is yes :-)
15:01:54 <Tjr_> because (yes or no) is yes :-)
15:01:55 <napping> okay, that's less surpsiring
15:02:15 <napping> anyway, I'm getting hungry and impatient
15:02:28 <Tjr_> I understood the f . fmap f part now
15:02:31 <napping> plenty of others can explain this stuff too
15:02:40 <Tjr_> thanks for your help
15:06:41 <jle`> rightful title has been reclaimed
15:08:46 <Tjr> napping: the "systematic procedure" might be called diagram chasing in homological algebra. Basically, the idea is to extend f :: m a -> n a to f :: m m a -> n n a by means of hopefully-common-sense rules. Next, the extension to arbitrarily nested m m m m m a is unique. Finally, f :: (m a | m m a | m m m a | ...) -> (same stuff) lets us write f . bind = bind . f
15:15:09 <codygman> After trying to use forM I started getting a null pointer exception with the haskell exif bindings: http://lpaste.net/106440
15:21:46 <pavonia> png images can have Exif data?
15:31:38 <merijn> Sounds like someone botched the FFI code
15:35:33 <pavonia> But it's a user error, not a null pointer dereference. To me it looks like it's only missing documentation "this function may fail with ..."
15:39:01 <jle`> it's neat that (::) aligns with (=>) and (->)
15:39:07 <jle`> when you light up type signatures
15:39:19 <jle`> er, when you line up types and constraints in type signatures
15:42:11 <hunt> how possible is better ffi? could we make ffi bindings for specific other common languages?
15:42:24 <hunt> i feel like that on its own would give haskell a pretty significant popularity boost
15:42:32 <c_wraith> there are packages like hubris, which is a haskell/ruby bridge
15:42:41 <hunt> is it good c_wraith?
15:42:48 <c_wraith> I have no idea.
15:53:03 <phaazon> hey
15:53:24 <phaazon> how do you turn off profiling while developping a lib?
15:56:22 <luite_> phaazon: you can configure your project with --disable-library-profiling
15:59:14 <phaazon> luite_: thank you! :)
16:00:21 <pharaun> is there any particular stance on hslogger vs monad-logger ?
16:00:31 <solidus-river> does it make sense to make a lens reader?
16:00:39 <phaazon> pharaun: what do you need?
16:00:42 <pharaun> i have not used logging at all and i'm looking at adding one to this project so i was wondering, both seems equally popular
16:00:51 <solidus-river> i'm trying to mix lens and netwire but i thought lens was already using state
16:00:57 <phaazon> I don’t use either, I use mine, pharaun
16:00:59 <phaazon> so I can’t tell
16:01:08 <pharaun> phaazon: mainly a way for me to have a hook in which i can provide a logger into a bunch of network/io stuff
16:01:34 <phaazon> pharaun: https://hackage.haskell.org/package/monad-journal-0.2.1.2 this is mine
16:01:34 <pharaun> so i can track/debug what is going on, working on a a NSQ library that will have multiple connections to multiple servers so having some sort of logging seems helpful :)
16:01:38 <pharaun> looking
16:01:45 <phaazon> it’s not designed to work in any specific monad
16:02:02 <phaazon> it’s a MonadWriter on steroids :)
16:02:30 <phaazon> the idea is that you logs stuff, and sink the whole logs history when you’re in MonadIO
16:02:47 <k00mi> solidus-river: what do you mean by "lens reader"?
16:03:04 <solidus-river> well, i'm trying to wrap my head around netwire but theres very little usefull documentation
16:03:06 <phaazon> I should write a better documentation some day…
16:03:12 <solidus-river> theres mention that you can store a state that each wire reads from
16:03:21 <pharaun> phaazon: ahh, that seems helpful for the more pure/code chunks
16:03:23 <solidus-river> so for game programming i asusme that would be the game state and youd run a wire that has a time component
16:03:38 <solidus-river> but the only examples of that i can find define readers for the state monad for the wire
16:03:40 <phaazon> pharaun: it’s exactly for that kind of stuff I wrote that
16:03:41 <RedNifre> Hey there!
16:03:46 <vova> Hi all. Please help me with this error. http://pastebin.com/93rHf4GW . It confused me.
16:03:52 <phaazon> logging in Maybe for instance
16:03:57 <pharaun> i was wondering bout how to handle that, but it seems like lots of this code here is mostly in MonadIO but yeah, looks like i could take this for the pure code part and then sink it into one of the other logger
16:03:58 <phaazon> hi RedNifre
16:04:13 <solidus-river> but i want to try to do that with lenses, yet lenses already have state internally so i don't get hot hat works.. :|
16:04:30 <phaazon> pharaun: have fun with it, and if you have any suggestions, I’m open to anything
16:04:34 <phaazon> btw :
16:04:52 <k00mi> solidus-river: lenses do not "have state internally"
16:04:59 <solidus-river> i feel like lens could be really cool, but theres very little usefull documentation out there
16:05:00 <phaazon> pharaun: http://www.reddit.com/r/haskell/comments/1ymawa/monadjournal_onthefly_logging_from_any_monad/
16:05:07 <solidus-river> k00mi: are you familiar with netwire?
16:05:09 <k00mi> there are operators for working with lenses in State
16:05:15 <phaazon> I wrote a little entry in my blog about that
16:05:21 <k00mi> the normal view function works on any MonadReader
16:05:24 <phaazon> if you want a deeper approach ;)
16:05:24 <k00mi> no
16:05:25 <pharaun> phaazon: oh nice, thanks
16:05:27 <pharaun> peeking
16:06:04 <k00mi> solidus-river: I think there is a vast amout of documentation on lens, but much less on netwire
16:06:06 <MP2E> solidus-river : what about netwire?
16:06:24 <RedNifre> So I finished a Haskell tutorial and wrote very small programs, that don't really do anything useful. What I want to do next is to write a very small, useful, stateless REST thingy. That is, it runs locally, I interact with it in my browser, but it also fetches data from real REST apis over the internet. Do you have any words of wisdom how I might start that?
16:06:28 <phaazon> you’re welcome pharaun
16:06:50 <MP2E> There isn't too much documentation on netwire, but it's still enough to figure out how to use it :P I'd recommend reading Arrow tutorials before moving into netwire
16:06:51 <jle`> RedNifre: sounds like something you can whip up with scotty :)
16:07:02 <MP2E> particularly the bits about Automaton Arrows and ArrowLoop
16:07:10 <vova> I've solve the issue, Thanks.
16:07:28 <jle`> solidus-river: if you have any specific questions about netwire, feel free to ask me or drop by #haskell-game
16:07:40 <solidus-river> MP2E: so i'm trying to wrap my head around a general game loop with keyboard input and then rendering a list of stuff with maybe some collision
16:07:45 <solidus-river> but theres very little examples out there
16:07:46 <jle`> the state of tutorials and documentation on netwire is a bit lacking unfortunately; there are a few good ones out there but it's not too well organized
16:07:56 <Welkin> I am going to use netwire, but haven'g gotten started yet
16:07:57 <jle`> solidus-river: i have been planning to write a series of netwire tutorials
16:07:57 <solidus-river> the readme on hackage doesnt really explain much thats interesting
16:08:00 <RedNifre> scotty sounds nice, especially that people compare it to sinatra :) Will have a closer look...
16:08:07 <MP2E> jle` : ooh netwire tutorials would be great
16:08:18 <solidus-river> it goes over the standards of netwire then says you can use a monad to store and retrieve state but only framework developers should worry about it, and never explains it
16:08:23 <jle`> i started an Automation arrow tutorial but it got a bit stalled on the second part
16:08:34 <jle`> solidus-river: look at ocharle's examples
16:08:38 <MP2E> yes
16:08:43 <jle`> they are from a netwire 4.x but most of the concepts scale
16:08:44 <MP2E> ocharles' asteroids port is great
16:08:49 <jle`> i am not too big a fan of some of the way he handles things
16:09:05 <jle`> but
16:09:07 <jle`> it's a great introduction
16:09:10 <solidus-river> theres this page here https://github.com/MaxDaten/netwire-examples but theres no documentation for it and it doesnt even seem like the examples will function
16:09:12 <MP2E> isn't the main difference between netwire 4 and 5 that you supply a time stepping?
16:09:12 <jle`> and it's something i followed a lot
16:09:31 <MP2E> but anyway solidus-river : i'd look into mvc to seperate your controller and rendering logic from your game
16:09:34 <jle`> MP2E: the difference in the Wire type is that it is parameterized on the time type
16:09:35 <solidus-river> and then i found this https://github.com/Mokosha/Lambency/blob/master/Examples/CubeDemo.hs  but tis all wrapped up in a framework already so doesnt help :(
16:09:38 <MP2E> Ahh
16:09:45 <jle`> but there is a major restructuring in the library itself
16:09:47 <jle`> and reorganization
16:09:51 <jle`> s/is/was
16:10:07 <jle`> solidus-river: check out ocharle's two posts
16:10:11 <Welkin> I noticed someone in here mentioned using mvc for games
16:10:15 <jle`> i also have a netwire experiments project ...
16:10:17 <jle`> hm
16:10:21 <solidus-river> jle`: is ther ea link to those?
16:10:29 <MP2E> yep that was probably me Welkin  :P
16:10:32 <Welkin> is that common?
16:10:33 <jle`> https://github.com/mstksg/netwire-experiments
16:10:36 <jle`> sorry, they aren't very well documented
16:10:43 <jle`> but i try to solve a lot of real world problems with inputs and dynamic wires
16:11:11 <jle`> solidus-river: http://ocharles.org.uk/blog/posts/2013-08-01-getting-started-with-netwire-and-sdl.html
16:11:17 <jle`> http://ocharles.org.uk/blog/posts/2013-08-18-asteroids-in-netwire.html
16:11:21 <jle`> ocharle's two netwire articles
16:11:27 <MP2E> Welkin : not particularly, mvc is new-ish. I find it helps me :) I like being able to seperate my input/output into seperate models from my game logic and mvc seems to be a great way to do that
16:11:47 <pharaun> phaazon: awesome the explaination on blog makes more sense :) i'll look into using this for the pure code portions
16:12:17 <solidus-river> jle`: thanks for the links! i was trying to do one thing in netwire and one in elerea and elerea has excellend documentation / has been easy to envision the project in
16:12:24 <solidus-river> netwire seems like a black hole of doc's
16:12:29 <jle`> :'(
16:12:43 <jle`> i have been putting off writing tutorials for them for about five months now due to school, but it's summer
16:12:53 <jle`> but i'm also working on my own arrowized locally stateful dsl/library
16:12:54 <phaazon> pharaun: :)
16:12:55 <Welkin> isn't netwire being replaces by wires?
16:13:02 <jle`> wires is a simplified/streamlined netwire
16:13:16 <phaazon> I’ll turn the blog talks into the haddock doc
16:13:16 <jle`> i'm also working on my own library with is slightly related to netwire and game programming
16:13:35 <jle`> so i'll try to balance writing netwire tutorials and also working on that
16:13:41 <Welkin> it's like striking gold when I find a good haskell tutorial
16:13:47 <jle`> netwire is one of the real gems of haskell, i believe
16:13:52 <Welkin> such as an example of using lens for an rpg
16:13:55 <MP2E> I agree with jle`
16:14:01 <Welkin> or sdl in haskell
16:14:07 <jle`> it's a shame that the documentation isn't too great, and it's not too accessible
16:14:12 <benzrf> :t product
16:14:13 <lambdabot> Num a => [a] -> a
16:15:18 <madjestic> jle`: documentation isn't too great is not a too large understatement
16:15:23 <jle`> :P
16:15:38 <jle`> if you read up on netwire's predecessors like YAMPA
16:15:44 <jle`> you might find some good tutorials there
16:15:50 <jle`> yampa and netwire share a lot of similar semantics
16:16:04 <jle`> like and arrowized interface and implicit inhibition
16:16:17 <RedNifre> I have a question regarding the use of "do" to define all these sort-of-functions in scotty: https://github.com/xich/scotty/blob/master/examples/basic.hs   Why are they declared in main/do and not in the source file directly?
16:16:26 <Welkin> or just read about FRP
16:16:38 <Welkin> I learned a good bit about it through Elm
16:16:51 <jle`> i think learning Elm might be harmful in learning FRP
16:16:57 <solidus-river> jle`: awesome info, netwire tutorials would be great :), i've got quite a handfull with what youve already shown though
16:17:09 <solidus-river> ive doen a lot of readon in FRP, i can work my way through eleria just fine
16:17:13 <MP2E> hmm really? I haven't tried Elm, why is that? :P
16:17:19 <solidus-river> but netwires types are scary and not really explained anywhere so far
16:17:31 <Welkin> @google elm-lang
16:17:32 <lambdabot> http://elm-lang.org/
16:17:33 <lambdabot> Title: Elm
16:17:37 <jle`> Elm totally ignores one of the most significant aspects of FRP
16:17:42 <solidus-river> and i think one thing i'm learning from haskell is if you don't understand the types of the library your using you'll have one hell of a time doing anythign with it
16:17:44 <jle`> as defined by the people who invented FRP
16:17:46 <Welkin> it's a fun little DSL
16:17:47 <jonashw> jle`, which aspects?
16:17:50 <Welkin> it's not full featured though
16:17:54 <jle`> solidus-river: the types in netwire are very tame compared to a lot of other libraries ;)
16:18:00 <jonashw> @pl (\a b -> compare (fst a) (fst b))
16:18:00 <jle`> Wire s e m a b
16:18:00 <lambdabot> (. fst) . compare . fst
16:18:04 <jle`> s is the time type
16:18:06 <jle`> usually Double
16:18:07 <benbangert> I have a list of monads, and I want to execute them until I get one back that is True, and not run any of the rest, is there a func for that?
16:18:18 <jle`> making it parameterized is commonly ocnsidered a mistake
16:18:32 <jle`> e is the inhibition type; if a wire inhibits, then it inhibits with something of value e
16:18:34 <jle`> usually it's ()
16:18:36 <solidus-river> jle`: aye, but no one explains what m is in that tipe
16:18:38 <solidus-river> *type
16:18:44 <jle`> basically wires output Either e b
16:18:50 <solidus-river> jle`: i know what e, a, b are, have a fair idea of what s is, but m is a mystery
16:18:58 <RedNifre> How do your haskell development environments look like? Folders? IDE? Which editors?
16:19:03 <jle`> solidus-river: it's a monad transformer
16:19:09 <jle`> you aren't really supposed to use it
16:19:13 <jle`> it's supposed to be Identity ;)
16:19:20 <jle`> it's there for performance hacks
16:19:26 <solidus-river> jle`: so thats where i see a lot of the game examples putting in a reader for global state, is that a bad idea?
16:19:27 <jle`> basically, a Wire is a function
16:19:27 <Welkin> RedNifre, emacs with haskell-mode with haskell-doc turned on
16:19:59 <jle`> s -> a -> m (Either e b, Wiser s e m a b)
16:20:09 <MP2E> RedNifre : I use emacs with structured-haskell-mode and a command line environment with zsh to develop
16:20:22 <jle`> set s to Double as it should be, and e to (), and repliacing Either () with Maybe
16:20:24 <jle`> you get
16:20:46 <jle`> Double -> a -> m (Maybe b, Wire Double () m a b)
16:20:54 <jle`> replacing m with Identity
16:20:56 <jle`> you get
16:21:02 <jle`> Double -> a -> (Maybe b, Wire Double () Identity a b)
16:21:23 <jle`> a Wire is a function that takes a double, and input, and returns an output with the "next wire"
16:21:36 <jle`> it actually returns m (Maybe b, Wire ...)
16:21:46 <jle`> this means that your wire "function" can be "impure"
16:22:10 <RedNifre> Hm... I use neither emacs nor vim usually... The Go tutorial has a nice setup described where you create a folder structure, set up some path variables and then you can import libraries directly from github urls, which loads the source in one folder, compiles it etc. Is there a best practice for using haskell, or does everyone create his/her own setup?
16:22:11 <solidus-river> so my function can carry aorund global state in a monad if i put a reader in as the transformer
16:22:22 <jle`> solidus-river: Reader is one of the "acceptable" things...but you really shouldn't need it
16:22:31 <jle`> yes
16:22:40 <jle`> if you pretend that Wire is your constructor
16:22:43 <solidus-river> so it takes an input a, might produce an output b, and then returns the next step in the wire
16:23:00 <solidus-river> and the state worke i've seen is purely performance hackage?
16:23:04 <jle`> data Wire m a b = Wire (Double -> a -> m (b, Wire m a b))
16:23:07 <Welkin> RedNifre, http://www.haskell.org/haskellwiki/Editors
16:23:18 <jle`> (if i pretend it can't inhibit)
16:23:19 <jle`> so you can do
16:23:28 <jle`> myWire = Wire $ \t s -> do ....
16:23:36 <Welkin> I don't know about folder structure, but I have seen many code bases divided up into folders by module
16:23:38 <jle`> as long as your do block returns something of type m (b, Wire m a b)
16:23:52 <jle`> so in that do block you can ask, asks, etc.
16:23:58 <jle`> the "performance hack" usually has to do with IO
16:24:13 <jle`> and graphics
16:24:25 <Welkin> RedNifre, http://www.haskell.org/haskellwiki/Structure_of_a_Haskell_project
16:24:30 <jle`> where you use IO in the do block to interface and cheat with your graphics library
16:24:36 <jle`> but i really really really suggest you don't do that
16:24:44 <jle`> it's a bad abuse of the monad transformer
16:24:47 <RedNifre> Thank you
16:24:54 <jle`> unless you really have to, after extensive profiling and optimization
16:25:24 <solidus-river> i made the unfortunate choice of goign with GLFW-b instead of sdl 1.x for my rendering / input so i cant just rip other peoples wires related to sdl
16:25:34 <jle`> i have an OpenGL backend
16:25:41 <jle`> and wires should be independent of your backend
16:25:43 <jle`> or your graphics
16:25:51 <jle`> your wires should be written to be backend-agnostic, anyways
16:25:57 <Welkin> why not sdl 2?
16:26:00 <MP2E> SDL2 <3
16:26:01 <jle`> jonashw: continuous time semantics
16:26:06 <solidus-river> jle`: so thats confusing to me, you basically needyour whole frame wrapped up into a wire, right?
16:26:14 <jle`> solidus-river: one way to think about it
16:26:16 <solidus-river> and that wire can have subwires that doe thing slike physics, input, animation etc
16:26:19 <jle`> is a wire is basically a function a -> b
16:26:33 <jle`> but every time you "run" it, the function changes internal state
16:26:50 <jle`> that's why wire is often said to enable "locally stateful computation"
16:27:08 <jle`> in practice, this means that your wire will be a function (all inputs) -> (all outputs)
16:27:09 <solidus-river> Welkin: i rejected sdl 2 because i have been burned by sdl 1.2 in c++ apps before. but looking back on it sdl 2 looks fine
16:27:25 <jle`> or (all inputs) -> (the state of what you want to display)
16:27:38 <MP2E> solidus-river : I know many veteran C/C++ programmers who do the same. It's understandable, if a little unfortunate
16:27:39 <jle`> your output might be the position of all your things, or it might be the delta's of where all your things went
16:27:47 <MP2E> because on my end of things it seems like SDL2 is SDL1.x done right ;)
16:27:47 <jle`> the job of your backend is to "run" that function; to "run" that wire
16:27:58 <jle`> at every step, give it the proper inputs, like keypresses, etc.
16:28:03 <jle`> and take that output, and display it
16:28:54 <solidus-river> jle`: my last question (maybe) about wires is it seem slike for game logic you'd want them to be a function of state and time
16:28:56 <jle`> actaully i lied, a wire "like" a function dt -> a -> b
16:29:03 <solidus-river> but wires seems to eithe rbe responses to an event or time change
16:29:14 <jle`> solidus-river: wires can carry internal state
16:29:17 <MP2E> I'm forced to use SDL2 anyway, AFAIK. I'm writing a haskell codebase that I want to compile for Android as well, and I don't know of any OpenGLES libraries for Haskell
16:29:32 <MP2E> or better yet, libraries that switch between GL or GLES depending which platform you are using ;)
16:29:42 <MP2E> restricting me to the subset of GLES of course.
16:29:43 <jle`> solidus-river: this might help; http://blog.jle.im/entry/intro-to-machines-arrows-part-1-stream-and ...been meaning to finish it >.<
16:30:04 <solidus-river> MP2E: yeah, sdl 2 looks very good, i don't want to backtrack from GLFW-b though i might
16:30:35 <jle`> Wire is implemented as an mealy machine internally
16:30:52 <solidus-river> jle`: a tutorial from you would benifit netwire a lot, you've just explained it in bits in irc way better than the readme / examples i could find in a week
16:31:15 <jle`> solidus-river: maybe the tutorial should be 'just go to #haskell and #haskell-game' :P
16:31:20 <solidus-river> lol
16:31:25 <jle`> although that is probably less time efficient
16:32:40 <jle`> benbangert: i think monad-loops might have what you are looking for
16:32:44 <solidus-river> oh right, i'm forgetting the s component
16:32:53 <jle`> RedNifre: what do you mean source file directly?
16:33:04 <jonashw> can lamdabot convert between list comprehensions and do-notation?
16:33:05 <solidus-river> its a pair of s and a that produce b and the next wire
16:33:16 <solidus-river> so am i correct in thinking a game loop wire would be something like
16:33:36 <RedNifre> I mean that you declare a regular function in the outer scope, not in a do in the main function.
16:33:38 <solidus-river> Wire Double () Identity Gamestate (IO ())
16:33:59 <jle`> RedNifre: there's no real reason, i think...just preference
16:34:05 <jle`> remember that do .. is just an expression
16:34:11 <jle`> and remember referential transparency
16:34:15 <kazagistar> jonashw: its kinda a one directional mapping...
16:34:16 <Guest17864> ciao
16:34:18 <Guest17864> !list
16:34:18 <monochrom> Guest17864: http://okmij.org/ftp
16:34:24 <l0cust> I need some help with xmonad, and the people in #xmonad aren't responding.
16:34:25 <jle`> x = foo $ do { bar; baz }
16:34:34 <l0cust> Would one of you fine people mind helping me?
16:34:37 <jonashw> kazagistar, I'm really just interested in comprehension -> do
16:34:38 <jle`> is equivalent to let thing = do {bar; baz} in x = foo thing
16:34:40 <solidus-river> l0cust: whats up? i might not be much help but i use xmonad
16:34:41 <jle`> ^^ RedNifre
16:34:45 <jle`> solidus-river: no
16:34:56 <solidus-river> jle`: what part did i flub in that type?
16:35:06 <benbangert> jle`: yup, anyM looks like what I want
16:35:07 <l0cust> solidus-river: running xmonad --restart seems to have no effect
16:35:07 <RedNifre> hm...
16:35:12 <jonashw> I'm looking for how to write the following comprehension in do-notation: [(a,b) | a <- [1..100], b <- [a..100], a * b < 200]
16:35:13 <kazagistar> jonashw: are you trying to see examples to learn it or...?
16:35:13 <jle`> solidus-river: a game loop might look like Wire Double () Identity KeyPresses Display
16:35:28 <jonashw> particularly, the filter bit
16:35:32 <jle`> jonashw: a guard
16:35:35 <kazagistar> jonashw: guard
16:35:38 <solidus-river> jle`: then where would the state of the game be kept?
16:35:40 <jonashw> ok, let me try
16:35:47 <jle`> jonashw: do { a <- [1..100]; b <- [a..100]; guard (a * b < 200) }
16:35:50 <jle`> er
16:35:51 <RedNifre> I guess it makes sense that way since those REST functions should only be reachable if that server is actually running? As in, you don't want anyone to import them by importing the source file?
16:35:53 <jle`> then return (a, b) at the end
16:35:58 <solidus-river> l0cust: are you running it in a console wher you can see feedback?
16:35:59 <jle`> solidus-river: inside the wire itself
16:36:02 <l0cust> solidus-river: yes
16:36:07 <jle`> it's magic ~~
16:36:08 <l0cust> solidus-river: there is no feedback
16:36:14 <jle`> the blog post of mine should help explain
16:36:18 <jle`> that internal state concept
16:36:25 <solidus-river> jle`: aye, i'm going to go read through that
16:36:29 <l0cust> solidus-river: there are only errors on --recompile if I deliberately put an error in xmonad.hs
16:36:31 <RedNifre> Also, why is the notation with all the points called "point free"?
16:36:40 <l0cust> RedNifre: no free variables
16:36:40 <jle`> RedNifre: by points do you mean (.) ?
16:36:47 <benbangert> jle`: thanks!
16:36:47 <kazagistar> jonashw: it comes from MonadPlus (which is really just Alternative + Monad)
16:36:48 <solidus-river> l0cust: oh in that case it is reloading, its just whatever you expect to change from your new config is wrong :P
16:36:59 <solidus-river> l0cust: what are you trying to modify?
16:37:01 <RedNifre> I . heard . this . is . called . point . free
16:37:02 <jle`> RedNifre: the "point" in point-free refers to the `x` in \x -> ...
16:37:03 <jonashw> :t guard
16:37:04 <lambdabot> MonadPlus m => Bool -> m ()
16:37:09 <l0cust> solidus-river: I was trying to modify the border color
16:37:12 <jle`> so instead of (\x -> foo (bar x))
16:37:17 <jle`> you do (foo . bar)
16:37:18 <solidus-river> l0cust: can you pastie your config?
16:37:22 <jle`> see, the "point" (the x) disappears
16:37:25 <jle`> the term comes from math
16:37:25 <l0cust> solidus-river: but even modifying the terminal emulator has no effect
16:37:31 <jle`> (.) is the composition ooperator
16:37:34 <jonashw> > { a <- [1..100]; b <- [a..100]; guard (a * b < 200) }
16:37:35 <lambdabot>  <hint>:1:1: parse error on input ‘{’
16:37:40 <jonashw> > do { a <- [1..100]; b <- [a..100]; guard (a * b < 200) }
16:37:42 <lambdabot>  [(),(),(),(),(),(),(),(),(),(),(),(),(),(),(),(),(),(),(),(),(),(),(),(),(),...
16:37:43 <jle`> jonashw: remember to return at the end
16:37:44 <l0cust> solidus-river: http://lpaste.net/106442
16:37:47 <jle`> sry
16:37:50 <jonashw> jle` ah :)
16:38:07 <RedNifre> So, is "point" just math for "variable when it's inside a function signature"?
16:38:21 <l0cust> RedNifre: when inside a function
16:38:25 <solidus-river> l0cust: your terminal emulator wont update untill you launch a new terminal
16:38:27 <jle`> RedNifre: point is a binding to a thing you manipulate
16:38:37 <l0cust> solidus-river: explain
16:38:44 <AshyIsMe> oh wow, neco-ghc is a sweet vim plugin for haskell
16:38:45 <jle`> in foo x, you have a point called x that you can work with freely
16:38:47 <jle`> kinda
16:38:53 <c_wraith> RedNifre: it actually comes from topology, in which a point is actually a point.
16:39:06 <AshyIsMe> uses ghc-mod to provide context aware completions
16:39:11 <jle`> i don't think point-free is a really useful concept or goal for haskell
16:39:18 <solidus-river> l0cust: reloading xmonad wont relaunch any existing x programs, it will just reload xmonads display mechanisms and redisplay all programs
16:39:22 <jle`> i think the dichotomy should be pointful vs. compositional
16:39:30 <RedNifre> You know, you could be joking and nobody would ever notice it ;)
16:39:35 <solidus-river> so fi you change the terminal emulator all terminals you have open will still be the old emulator, but a new terminal should give you the new emulator
16:39:37 <l0cust> solidus-river: changing the terminal emulator to "urxvt", and launching a new terminal. terminator is still launched
16:39:38 <solidus-river> afaik
16:39:53 <solidus-river> l0cust: :\
16:40:02 <l0cust> I'll go ask in #archlinux
16:40:30 <solidus-river> l0cust: aye, i'm goign to try reloading my config to make sure i'm not crazy
16:40:39 <solidus-river> but it seems like what your doing should work both fine and dandy
16:40:41 <c_wraith> RedNifre: the standard formulation of topology is point-set, in which you talk about individual points.  There are alternative formulations that are described as point-free, in which you never actually name the points you're operating on.
16:40:48 <kazagistar> its maybe useful to eliminate unneeded variables via eta reduction and such, but playing mad games with (.) and reader monads seems to have a lot less utility
16:40:49 <RedNifre> So, "f(g(x))" is NOT point free, but "f.g x" is? Or is it only called point free as long as it is as partially applied as possible?
16:41:05 <jonashw> @pinky
16:41:05 <lambdabot> Poit!
16:41:07 <jonashw> @pinky
16:41:07 <lambdabot> I think so, Brain! But do I have what it take to be the 'Lord of the Dance'?
16:41:17 <dwcook> RedNifre, "point-free" is defined with respect to the definition of a function, not an arbitrary expression.
16:41:23 <l0cust> solidus-river: A potential problem - I modified some /etc file to run xmonad from my /home/pete/.cabal/bin directory
16:41:30 <jonashw> @thanks
16:41:30 <lambdabot> you are welcome
16:41:42 <l0cust> solidus-river: I wasn't able to install xmonad-contrib via pacman
16:41:55 <jle`> RedNifre: it's not about partial application, it's about what you are sort of trying to "say"
16:42:13 <jle`> i can say foo x = bar (baz x), and i mean "foo x is what you get when you apply bar to the result of applying baz to x"
16:42:23 <jle`> if i say foo = bar . baz, i mean "foo is the composition of bar and baz"
16:42:31 <jle`> it's a different way of looking at things
16:42:49 <dwcook> RedNifre, your example could be adapted like so: \x -> f (g x) is pointful while f . g, while being the same function, is point-free.
16:42:56 <RedNifre> Okay, maybe I understood the tutorial wrongly. The way I understood it was "f(g x) and f $ g x are not point free, but f . g x is"... sort of like that.
16:43:17 <solidus-river> l0cust: hmm i'd poke the arch linux people, i use gentoo but i once foobar'd my haskell-platform install in the same way
16:43:35 <solidus-river> it ended up being a bit of a headache to fix but the gentoo peeps had written a utility
16:43:42 <dwcook> RedNifre, the key here is that the first one mentions its parameter, x, while the second does not.
16:43:46 <kazagistar> RedNifre: yeah, the last one is not even correct syntactically, to be pedantic
16:43:59 <jle`> well it's correct, but it doesn't do what you think it does
16:43:59 <kazagistar> or not equivalent at least
16:44:00 <jle`> ;)
16:44:07 <jle`> yeah, not equivalent
16:44:25 <RedNifre> But with currying, isn't it all the same? So is the decision whether to write parameters or not a bit like a comment?
16:44:42 <jle`> currying doesn't have anything to do with it
16:44:57 <dwcook> RedNifre, it's almost the same. There are certain other factors to consider like the monomorphism restriction
16:44:58 <jle`> i can write in a compositional style in other languages too
16:45:08 <jle`> also, sometimes it's easier to maintain compositional code
16:45:20 <kazagistar> { f . g x } has a order and meaning than { f $ g x }
16:45:36 <jle`> consider foo x = f (g (h (k x)))
16:45:41 <jle`> compare to foo' = f . g . h . k
16:45:42 <c_wraith> kazagistar: did you forget "different"?
16:45:55 <kazagistar> c_wraith: I did indeed :(
16:46:04 <NemesisD> hey guys. my test suite needs a few programs, one that shuts down for any signal, one that won't shut down for SIGINT/TERM. seems to me the sensible ways to build these in is do it in a shell script or figure out how to get cabal to build 2 exectuables as dependencies of my test suite
16:46:07 <jle`> what if you decided that (g . h) is something important and useful on its own right, and want to pull it out and name it?
16:46:10 <NemesisD> what do you guys recommend
16:46:11 <RedNifre> But couldn't I use both as either "foo" or "foo x"?
16:46:19 <jle`> you can say let gh = g . h
16:46:26 <jle`> and do foo' = f . gh . k
16:46:32 <jle`> basically like text substitution
16:46:37 <jle`> oh yeah, you use both the same way
16:46:55 <jle`> this is about writing maintainble definitions
16:47:03 <AshyIsMe> NemesisD: you can have multiple exes in a single cabal file
16:47:05 <RedNifre> That's what I mean, they are the same from the outside, so their structure is more like a comment?
16:47:05 <jle`> although i guess this is a bad example because it'd be just as easy to pull it out in the pointful version >_>
16:47:07 <Tjr> I wonder how many people ask about the word currying. It's not like we program in indian food.
16:47:14 <dwcook> RedNifre, for (almost?) any pointful function, you can write a pointfree counterpart. @pl does that automatically, in fact.
16:47:21 <AshyIsMe> NemesisD: ive been doing that for my testing, though im not sure if that's bad practice or not...
16:47:29 <dwcook> @pl \a b c -> a b (c b)
16:47:29 <lambdabot> (`ap` flip id) . ((.) .)
16:47:33 <jle`> RedNifre: it is more influential and useful for maintenance than a simple comment
16:47:45 <NemesisD> AshyIsMe: is there a way they can be hooked into the test process? I wouldn't want them installed when someone installs the package
16:47:56 <dwcook> RedNifre, as you can see, it doesn't always (or usually doesn't) give pretty results.
16:47:59 <jle`> i'm writing a program and i probably care just as much about how i implement what i write for future maintainability as i do about the API
16:48:01 <NemesisD> AshyIsMe: because the programs aren't what my package provides, they are just for test and don't do anything useful
16:48:14 <jle`> program or library
16:48:21 <Welkin> RedNifre, http://www.haskell.org/haskellwiki/Eta_conversion
16:48:42 <jle`> it's easy to write very unmaintainable code in any language; the difference is more than just a comment
16:48:54 <RedNifre> Yeah, I think I worder that poorly. What I meant is that how you write it is meant to make it easier to read or modify the code, but it has no effect on how you call the code.
16:49:03 <jle`> ah yeah
16:49:10 <Tjr> How do you prove formally that any f:: [a] -> Integral can only depend on the length of its list argument?
16:49:36 <jle`> Tjr: can it?
16:49:39 <jle`> f _ = 43
16:49:42 <kazagistar> Tjr: thats not true, it can not depend on the list at all
16:49:57 <dwcook> kazagistar, sure it can, look at length
16:50:05 <dwcook> (not quite but almost the same)
16:50:08 <Tjr> kazagistar, jle` : f = (const 43 ) . genericLength
16:50:23 <dwcook> Right now I'm trying to come up with an example of when it *does* rely on something besides the length
16:50:28 <dwcook> (I'm not sure there is one)
16:50:30 <NemesisD> AshyIsMe: maybe i could pull it off with some sort of flag
16:50:38 <kazagistar> dwcook: I thing my expression was ambiguous... (it can (not depend on the list at all))
16:50:52 <AshyIsMe> NemesisD: yeah im not sure, havent made it that far yet
16:51:02 <dwcook> kazagistar, ah, all right then.
16:51:20 <kazagistar> dwcook: it was a terribly written comment on my part though
16:52:03 <RedNifre> How smart is the Haskell runtime? Is this O(n) or O(2^n)?: fib n =  (fib n-2) + (fib n-1)
16:52:07 <dwcook> kazagistar, I think I still disagree though. I interpreted the question as "can at most depend on". I think that may be where the disagreement lies.
16:52:09 <AshyIsMe> NemesisD: looks like we need to read into this a bit: http://www.haskell.org/cabal/users-guide/developing-packages.html#test-suites
16:52:17 <jle`> RedNifre: are you saying is fib n memoized?
16:52:39 <jle`> automatic memoization is sort of a hard thing to really do smartly
16:52:46 <jle`> what do you memoize, and what do you not?
16:52:52 <jle`> (also , fib (n-1))
16:52:58 <RedNifre> Yeah, I mean in this case it depends on whether you do breadth first or depth first
16:53:15 <jle`> in haskell, "all" evaluation is by subsitution
16:53:16 <RedNifre> I mean, if you did depth first you might not have enough memory to keep everything
16:53:25 <jle`> this is the semantics of evaluation
16:53:42 <RedNifre> ah, so there would be a recursion limit eventually?
16:53:44 <dwcook> Tjr, as usual, seq/bottom spoils everything. Do you want to ignore those? With them, I think your proposition is false.
16:53:55 <jle`> no recursion limit
16:54:00 <jle`> it's a straightforward algorithm
16:54:13 <AshyIsMe> NemesisD: the snap-core project has a test suite.  good example i think: https://github.com/snapframework/snap-core/blob/master/snap-core.cabal
16:54:16 <kazagistar> RedNifre: its easier to express memoization explicitly as a list, ala { fib = 0 : 1 : zipWith (+) fib (tail fib) }
16:54:24 <jle`> let's try expanding fib 3, assuming fib 0 = 1 and fib 1 = 1
16:54:29 <Tjr> dwcook: care to elaborate?
16:54:36 <jle`> fib 3 = fib (3-2) + fib (3-1)
16:54:40 <jle`> = fib 2 + fib 1
16:54:42 <jle`> = 1 + 1
16:54:44 <jle`> = 2
16:54:50 <dwcook> Tjr, you can use seq to detect bottoms in the list and result in bottom instead of something based solely on the length of the list.
16:54:51 <jle`> oh wait i mean fib 1 and fib 2 are 1 >_>
16:54:53 <RedNifre> nah
16:54:55 <jle`> let's try fib 4
16:55:03 <jle`> fib 4 = fib 2 + fib 3
16:55:23 <jle`> = 1 + (fib 1 + fib 2)
16:55:31 <jle`> = 1 + (1 + 1)
16:55:33 <jle`> = 1 + 2
16:55:37 <jle`> = 3
16:55:53 <jle`> you can do the same thing with fib 5 for funsies.
16:55:57 <RedNifre> Yeah, but what exactly happened when the right fib2 turned into 1?
16:56:01 <Tjr> dwcook: thanks. Probably it's best to exclude bottom, and find a way to write code that excludes bottom.
16:56:02 <jle`> well
16:56:05 <jle`> you would probably have defined it
16:56:07 <jle`> fib 1 = 1
16:56:09 <jle`> fib 2 = 1
16:56:16 <kazagistar> @let fib = 0 : 1 : zipWith (+) fib (tail fib)
16:56:17 <jle`> fib n = fib (n-2) + fib (n-1)
16:56:19 <lambdabot>  Defined.
16:56:22 <kazagistar> > fib
16:56:24 <lambdabot>  [0,1,1,2,3,5,8,13,21,34,55,89,144,233,377,610,987,1597,2584,4181,6765,10946,...
16:56:25 <jle`> fib 2 = 1 is literally like a text substitution
16:56:37 <jle`> "okay, fib 2...let's look up the definition of fib 2...oh, it's defined as 1"
16:56:42 <jle`> "replace all instances of fib 2 with 1"
16:56:43 <RedNifre> Yeah, sure. Then I mean what would happen for fib 5 when you run into fib 3 multiple times?
16:56:50 <jle`> let's try
16:56:52 <RedNifre> Oh, I understand that part
16:57:22 <RedNifre> It's clear how the final result looks like, I just wonder if Haskell takes any short cuts. But please, show me with fib 4.
16:57:50 <jle`> fib 5 = fib 3 + fib 4 = (fib 1 + fib 2) + (fib 2 + fib 3) = (1 + 1) + (1 + (fib 1 + fib 2)) = 2 + (1 + (1 + 1)) = 2 + (1 + 2) = 2 + 3 = 5
16:57:53 <Tjr> You can force fibonacci to be O(n) if you always compute pairs (f n, f $ n-1)
16:58:15 <jle`> this is something you can do with pencil and paper :) i call it paper-and-pencil evaluation
16:58:50 <jle`> so this naive implementation is not memoized and is O(n^2)
16:58:54 <kazagistar> RedNifre: I think the answer you are looking for is no, it does not randomly figure out that your algorithm is shitty and substitute a better one that memoizes
16:58:56 <benzrf> @undefine
16:58:56 <Tjr> @> 1
16:58:56 <lambdabot> Undefined.
16:58:56 <lambdabot> Maybe you meant: v @ ? .
16:59:20 <RedNifre> jle` but what exactly does the computer do when it runs into "fib 2" multiple times? Does it compute it again? I mean, given that functions are pure and have no side effects, shouldn't it recycle those results?
16:59:23 <jle`> it doesn't say "oh, i found fib 3 before, let me just use the result of fib 3 that i saved somewhere off in memory"
16:59:33 <jle`> it *can* do that, technically
16:59:45 <jle`> it *can* save fib 3 off somewhere in a cache/memory
16:59:47 <jle`> because it's pure
17:00:08 <jle`> but...it's hard to decide what is useful or pactical to memoize and what is not
17:00:19 <jle`> because you might have unexpected space usage
17:00:31 <johnd> Hi, how can I define a function that given a polynomial (defined product, sum, etc.) returns the coefficients (rational, also defined) ? Any hint would be great
17:00:37 <RedNifre> I was hoping for something like garbage collection.
17:00:37 <jle`> if for example over the course of your program you find the fib of every natural number
17:00:54 <jle`> then you would basically be saving an unbounded amount of cached results
17:01:05 <benzrf> @let fib 1 = 1; fib 2 = 1; fib n = fib (n - 1) + fib (n - 2)
17:01:06 <lambdabot>  Defined.
17:01:31 <kazagistar> johnd: I think your definition is unclear... what exactly is your input?
17:01:45 <johnd> Sorry, I'll explain
17:01:52 <jle`> garbage collection? hm
17:02:08 <RedNifre> I'm a bit surprised, I thought that side effect free functions that have a deterministic result that only depends on input would be the perfect candidate for caching the last few results.
17:03:00 <jle`> well your language provides first-class mechanisms for cacheing
17:03:04 <jle`> so it doesn't have to be compiler magic
17:03:26 <jle`> caching the last few results might actaully be bad for performance too
17:03:29 <kazagistar> RedNifre: it still has significant performance cost if you do it when it is not helpful, especially since "the result of the function" could be very big things and such
17:03:45 <jle`> the result might be huge, or the equality comparison might be costly
17:04:10 <marchelzo_> How can I get a list of all matches of a regex with Text.Regex?
17:04:16 <RedNifre> Yeah, I guess caching results is too random, better motivate the programmer to implement a better algorithm that doesn't rely on cached results.
17:04:18 <jle`> maybe it could cache things like Int -> Int only, but in that case, your behavior is a bit inconsistent
17:04:21 <kazagistar> that too, not all inputs can be effectively compared, and looking them up in cache can be time consuming
17:04:29 * Tjr_ curses the connection.
17:04:30 <benzrf> @ping
17:04:30 <benzrf> lambdabot: u ok/
17:04:32 <lambdabot> pong
17:04:36 <jle`> might as well not rely on random/ad-hoc cacheing
17:04:45 <jle`> and let the programmer cache when they want it
17:04:46 <levi> RedNifre: Haskell doesn't magically cache things automatically. If you explicitly refer to something that was previously calculated, it won't be calculated again, but if a function expression occurs twice with the same parameters it's still evaluated twice.
17:04:55 <dwcook> GHC should memoize fib functions defined like that just for the sake of people wondering whether GHC will memoize them :P In seriousness, I had a professor who made the statement that that would happen automatically. I corrected them :P
17:05:03 <johnd> I've defined Polynomials, and also rationals beforehand. I want to creat a function that given a polynomial represented by the instance Poly it returns the cofficients list of the polynomial
17:05:05 <jle`> actually!
17:05:11 <jle`> i too thought functions like these would be memoized
17:05:13 <benzrf> > 3
17:05:13 <benzrf> 3 is my Official Numerical Foo
17:05:13 <benzrf> lambdabot is killy9999
17:05:13 <benzrf> *kill
17:05:15 <lambdabot>  3
17:05:16 <jle`> when i was new to Haskell
17:05:23 <benzrf> no
17:05:31 <dwcook> jle`, it seems to be a common misconception, I wonder where it stems from
17:05:46 <Rufflewind> is it safe to delete ~/.cabal/packages ?
17:05:47 <jle`> i don't know!  RedNifre provides some possible intuition
17:06:05 <levi> I think people hear of 'lazy evaluation' as a memoizing version of 'call by name' and extend the scope of memoization too far.
17:06:07 <jle`> but this is very prevalent
17:06:12 <jle`> ah, that might be it
17:06:14 <kazagistar> johnd: that should be doable by trivial inspection, but I have no idea what your polynomial implementation is
17:06:20 <dwcook> levi, I think you might have struck on it or come close
17:06:22 <Tjr> it's an easy misconception. For example Mathematica does cache these fib values automatically
17:06:26 <Lutin`> levi: Yeah that's why I thought so at first
17:06:27 <RedNifre> Well, if it's in the same "statement" it might make sense to expect that it gets evaluated in a smart way, if memory permits.
17:07:06 <jle`> finding out in what cases it is benificial to cache considering all the factors (like input equality testing, or size of result) is a bit difficult
17:07:18 <jle`> if you look at it from a certain angle, it's also undecideable
17:07:27 <jle`> (without running the actual computation/evaluation)
17:07:30 <augur> anyone know of an elegant way to turn this type:   (a -> Maybe b, b -> Maybe a)   into a single elegant functorial type, like lenses do to store?
17:07:43 <kazagistar> you can add such caching mechanisms yourself, but caching can have ugly side effects in some ways
17:07:44 <RedNifre> anyway, what I ended up doing was an infinite list, the constructor of the lists calls a function and that function looks up a value in the list. Which is very, very weird if you don't know about lazy evaluation. But it's magical :)
17:08:00 <Lutin`> Yep
17:08:08 <jle`> the fibs list is a classic example of programmer memoization that takes advantage of lazy evaluation
17:08:09 <jle`> um
17:08:15 <jle`> there was a nice article on the reddit a couple months back
17:08:22 <levi> The memoization that occurs is something that you wouldn't even think about in an eager language because it occurs pervasively by the nature of call-by-value evaluation.
17:08:37 <jle`> looking at dynamic programming problems (which are all about memoization)  and implementing them using lists
17:08:49 <kazagistar> its also a shit method, since recomputation is faster then chasing down a memoized list, but it is a commonly used example
17:08:50 <RedNifre> Ah, here it is:
17:08:51 <RedNifre> fibList = [fib (x-2) + fib (x-1)  | x <- [2..]]
17:08:51 <RedNifre> fib 0 = 1
17:08:51 <RedNifre> fib 1 = 1
17:08:51 <RedNifre> fib x = fibList!!(x-2)
17:09:01 <jle`> here ya go
17:09:03 <jle`> http://jelv.is/blog/Lazy-Dynamic-Programming/
17:09:12 <Lutin`> @let fibs = 1:1:(zipWith (+) fibs (tail fibs))
17:09:13 <lambdabot>  Defined.
17:09:19 <jle`> RedNifre: fibList = 1 : 1 : zipWith (+) fibList (tail fibList)
17:09:19 <Lutin`> > fibs !! 63
17:09:20 <lambdabot>  10610209857723
17:09:22 <johnd> kazagistar, I tried to explain somewhere in the chat, would it bother you if I ask you in a private chat ?
17:09:37 <Lutin`> > fibs !! 2000
17:09:39 <lambdabot>  6835702259575806647045396549170580107055408029365524565407553367798082454408...
17:09:59 <RedNifre> I tried that to see what the compiler would say about building an infinite list by calling a function that itself looks up something in the list again, but it worked anyway, which at first surprised me, but then it dawned on me that it works because of lazy evaluation.
17:10:14 <RedNifre> jle` I think mine is faster.
17:10:14 <jle`> the problem with this approach is that (!!) (or (:), depending on how you look at it) is not strict enough to give constant space evaluation
17:10:20 <levi> The trick there is not so much due to memoizing results of evaluation as it is the way evaluation stops at WHNF.
17:10:33 <RedNifre> WHNF?
17:10:39 <jle`> (the problem with the fiblist approach and lutin's approach too)
17:10:55 <levi> It's "Weak head normal form", a term from lambda calculus
17:11:12 <kazagistar> johnd: I see some explinations, but maybe if you pastebined the data structure we could help better
17:11:15 <RedNifre> ah
17:11:16 <rwbarton> in fact, RedNifre's is slower
17:11:21 <Welkin> wow, netsplit?
17:11:22 <levi> Basically means that you don't reduce expressions inside of a lambda or data constructor.
17:11:41 <Tjr> @let fibhelper n = cases (fibn, fibnn) of fibhelper (n-1) -> (fibn + fibnn, fibn) ; fibhelper 1 = (1,0)
17:11:41 <lambdabot>  Parse failed: Parse error: of
17:11:49 <Tjr> @let fibhelper 1 = (1,0);  fibhelper n = let (fibn, fibnn) = fibhelper (n-1) in  (fibn + fibnn, fibn)
17:11:50 <lambdabot>  .L.hs:153:1: Warning:
17:11:51 <lambdabot>      Pattern match(es) are overlapped
17:11:51 <lambdabot>      In an equation for ‘fibhelper’:
17:11:51 <lambdabot>          fibhelper 1 = ...
17:11:51 <lambdabot>          fibhelper n = ...
17:11:51 <johnd> oh, it's about 50 lines
17:12:02 <Tjr> How do I access fibhelper?
17:12:08 <RedNifre> oh, i missread. Yeah, I can't see which one is faster.
17:12:15 <Tjr> @fibhelper 2
17:12:16 <lambdabot> Unknown command, try @list
17:12:28 <Tjr> @let fibhelper 2
17:12:28 <lambdabot>  Parse failed: TemplateHaskell is not enabled
17:12:43 <rwbarton> like any other function
17:12:48 <Tjr> How?
17:12:49 <rwbarton> > fibhelper 2
17:12:51 <lambdabot>  (1,1)
17:13:09 <Tjr> thanks
17:13:24 <Lutin`> > fibhelper 5000
17:13:26 <lambdabot>  (387896845438832563370191630832590531208212771464624510616059721489555013904...
17:13:35 <Tjr> Why doesn't the lambdabot docu say so?
17:13:47 <jle`> lambdabot has documentation?
17:13:57 <Tjr> any decent piece of software should
17:14:01 <jle`> oh yeah, help. haha
17:14:02 <Tjr> it does have a help command
17:14:13 <RedNifre> > help
17:14:13 <rwbarton> #haskell is the lambdabot documentation
17:14:14 <lambdabot>  Not in scope: ‘help’
17:14:18 <Tjr> @help
17:14:18 <lambdabot> help <command>. Ask for help for <command>. Try 'list' for all commands
17:14:19 <jle`> lambdabot you are so silly
17:14:51 <Tjr> I a typically haskell way of doing things, the @help command doesn't help at all
17:14:54 <RedNifre> @let help = @help
17:14:54 <lambdabot>  Parse failed: Parse error: @
17:15:23 <RedNifre> @let test = "test"
17:15:24 <lambdabot>  Defined.
17:15:24 <RedNifre> > test
17:15:25 <benzrf> @let fib 1 = 1; fib 2 = 1; fib n = fib (n - 1) + fib (n - 2)
17:15:25 <lambdabot>  .L.hs:151:1: Warning:
17:15:26 <lambdabot>      Pattern match(es) are overlapped
17:15:26 <lambdabot>      In an equation for ‘fib’:
17:15:26 <lambdabot>          fib 1 = ...
17:15:26 <lambdabot>          fib 2 = ...
17:15:28 <lambdabot>  "test"
17:15:33 <benzrf> @undefine
17:15:36 <lambdabot> Undefined.
17:15:39 <benzrf> @let fib 1 = 1; fib 2 = 1; fib n = fib (n - 1) + fib (n - 2)
17:15:42 <lambdabot>  Defined.
17:15:48 <RedNifre> "@help"
17:15:49 <benzrf> > fib v
17:15:53 <lambdabot>  mueval-core: Time limit exceeded
17:15:55 <benzrf> oh wait.
17:15:58 * benzrf facepalms
17:16:15 <Tjr> >take 5 . map (first . fib) $ [1,,]
17:16:25 <Tjr> >take 5 . map (first . fib) $ [1..]
17:16:28 <benzrf> Tjr: do you mean fst
17:16:29 <johnd> kazagistar, I don't mind copying the whole code but it might bother other people, do you mind initiating a private chat ?
17:16:32 <benzrf> also, i redefined fib
17:16:42 <Tjr> >take 5 . map (fst . fibhelper) $ [1..]
17:16:45 <jle`> also, you need a space afer the >
17:16:47 <benzrf> > take 5 . map fib $ [1..]
17:16:48 <lambdabot>  [1,1,2,3,5]
17:16:51 <Welkin> johnd, use @lpaste
17:16:55 <Welkin> @lpaste
17:16:55 <lambdabot> Haskell pastebin: http://lpaste.net/
17:17:02 <jle`> did i use enough buzzwords in my package description guys https://github.com/mstksg/auto
17:17:05 <benzrf> fyi lambdabot can eval lpastes now :3
17:17:05 <johnd> oh, I'm sorry, how does it works ?
17:17:16 * hackagebot aivika-experiment-cairo 1.3 - Cairo backend for the Aivika simulation library  http://hackage.haskell.org/package/aivika-experiment-cairo-1.3 (DavidSorokin)
17:17:16 * hackagebot aivika-experiment-diagrams 1.3 - Diagrams backend for the Aivika simulation library  http://hackage.haskell.org/package/aivika-experiment-diagrams-1.3 (DavidSorokin)
17:17:19 <Welkin> paste your code and copy the link
17:17:22 <jle`> or do i need more buzz words
17:17:23 <Tjr> benzrf: that could be documented ...
17:17:31 <benzrf> Tjr: what could?
17:17:34 <jle`> @@ @hoogle @type id
17:17:36 <lambdabot>  Prelude id :: a -> a
17:17:36 <lambdabot>  Data.Function id :: a -> a
17:17:36 <lambdabot>  GHC.Exts breakpoint :: a -> a
17:17:58 <benzrf> jle`: git dang thats a lot of buzz words
17:18:06 <jle`> buzz buzz
17:18:14 <Tjr> benzrf: it sure wouldn't harm newbies if lambdabot could tell them that it can evaluate lpastes.
17:18:17 <benzrf> explain it in human
17:18:33 <benzrf> Tjr: i only pr'd that feature in about 2 days ago
17:18:39 <Welkin> jle`, your forgot to talk about how it is web-scale and how it synergizes developers to maximize output potential
17:18:47 <Tjr> benzrf: not in scope:: pr'd
17:18:56 <jle`> Welkin: oh yeah, must add that.
17:19:02 <jle`> benzrf: it is already in human...i think...
17:19:03 <jle`> ...
17:19:08 <jle`> ...well i understand some of those words
17:19:38 <RedNifre> > "\n@help\n"
17:19:39 <lambdabot>  "\n@help\n"
17:19:52 <Welkin> the NSA must be DDoSing freenode again
17:20:00 <benzrf> Tjr: pull requested
17:20:15 * benzrf shakes his fist @ nsa
17:20:25 <benzrf> WASNT GOING TO THE MOON ENOUGH
17:20:33 <Welkin> that was NASA
17:20:41 <benzrf> Welkin: hence teh joke
17:20:45 <RedNifre> @help
17:20:46 <lambdabot> help <command>. Ask for help for <command>. Try 'list' for all commands
17:20:51 <kazagistar> @let kfib x = snd $ iterate (\(x,y)->(y,x+y)) (0,1) !! x
17:20:52 <lambdabot>  Defined.
17:20:58 <Tjr> @help list
17:20:58 <lambdabot> list [module|command]. Show commands for [module] or the module providing [command].
17:21:19 <benzrf> kazagistar: cute :-O
17:21:22 <Tjr> Maybe somebody could change that into a list of all lambdabot commans?
17:21:36 <jle`> > kfib 100
17:21:37 <lambdabot>  573147844013817084101
17:21:38 <benzrf> @pl \(x, y) -> (y, x + y)
17:21:38 <lambdabot> uncurry (ap (,) . (+))
17:21:44 <benzrf> ^much more understandable
17:21:51 <kazagistar> uuuuhhh
17:21:58 <kazagistar> lol
17:22:02 <rwbarton> what's wrong with @list
17:22:05 <benzrf> @hoogle (a, b) -> (b, a)
17:22:05 <lambdabot> Data.Tuple swap :: (a, b) -> (b, a)
17:22:05 <lambdabot> Data.Graph.Inductive.Query.Monad (><) :: (a -> b) -> (c -> d) -> (a, c) -> (b, d)
17:22:05 <lambdabot> Data.Graph.Inductive.Query.Monad mapSnd :: (a -> b) -> (c, a) -> (c, b)
17:22:05 <solidus-river> l0cust: hey! sorrry, i ran there, family came home
17:22:08 <benzrf> :t swap
17:22:10 <lambdabot> (a, b) -> (b, a)
17:22:12 <jle`> what the
17:22:15 <jle`> there is a Data.Tuple ?
17:22:16 <l0cust> solidus-river: oh, don't mind it
17:22:20 <benzrf> :t first (+1) . swap
17:22:20 <l0cust> solidus-river: I got it working
17:22:21 <rwbarton> oh wait it doesn't do what lambdabot claims at all
17:22:21 <lambdabot> Num c => (a, c) -> (c, a)
17:22:24 <l0cust> solidus-river: thank you for your help
17:22:30 <benzrf> first (+1) . swap
17:22:36 <jle`> no way
17:22:38 <benzrf> \(x, y) -> (y, x + 1)
17:22:41 <benzrf> marginally shorter!!!!111
17:22:44 <RedNifre> > lpaste.net/106445
17:22:45 <lambdabot>  Not in scope: ‘lpaste’
17:22:45 <lambdabot>  Perhaps you meant one of these:
17:22:45 <lambdabot>    ‘last’ (imported from Data.List),
17:22:45 <lambdabot>    ‘BSC.last’ (imported from Data.ByteString.Char8),
17:22:45 <lambdabot>    ‘BSLC.last’ (imported from Data.ByteString.Lazy.Char8)Not in scope: ‘net’
17:22:51 <kazagistar> I kinda like \(before) -> (after) lambdas
17:22:54 <benzrf> oh wait that should be second (+1)
17:23:02 <RedNifre> @lpaste.net/106445
17:23:02 <benzrf> kazagistar: b-but muh point-free
17:23:02 <lambdabot> Unknown command, try @list
17:23:11 <RedNifre> @list
17:23:12 <lambdabot> What module?  Try @listmodules for some ideas.
17:23:18 <benzrf> wow
17:23:24 <rwbarton> wtf is @list
17:23:25 <jle`> oh haskell u
17:23:26 <benzrf> i just managed to type 'lambdabot' instead of 'irssi' in my google
17:23:27 <benzrf> somenick_: how
17:23:30 <benzrf> *somehow
17:23:31 <jle`> o lambdabot u
17:23:36 <RedNifre> so how to get it to run an lpaste?
17:23:44 <kazagistar> @listmodules
17:23:44 <lambdabot> activity base bf check compose dice dict djinn dummy elite eval filter free fresh haddock help hoogle instances irc karma localtime more oeis offlineRC pl pointful poll pretty quote search slap source spell system tell ticker todo topic type undo unlambda unmtl version where
17:23:44 <benzrf>  /ignore #haskell MODES JOINS PARTS QUITS
17:23:48 <benzrf> RedNifre: @letlpaste
17:23:49 <kazagistar> @list activity
17:23:49 <lambdabot> activity provides: activity
17:23:51 <johnd> here it is: http://lpaste.net/8191646512111943680
17:24:03 <RedNifre> @letlpaste lpaste.net/106445
17:24:03 <lambdabot>  Invalid paste ID.
17:24:05 <rwbarton> oh
17:24:09 <RedNifre> @letlpaste 106445
17:24:09 <lambdabot>  Parse failed: TemplateHaskell is not enabled
17:24:22 <RedNifre> huh?
17:24:22 <rwbarton> i see, sort of
17:24:28 <benzrf> RedNifre: it's like @let
17:24:33 <benzrf> it takes code and puts it into the env
17:24:35 <benzrf> not evals it
17:25:17 <benzrf> @alias
17:25:17 <lambdabot> Unknown command, try @list
17:25:19 <benzrf> lame@
17:25:21 <benzrf> * lame!
17:25:24 <Tjr> Who maintains lambdabot, actually?
17:25:30 <benzrf> Tjr: int-e
17:25:41 <kazagistar> johnd: the problem is I see a polynomial as being stored as something where extracting the coefficients should be trivial. Since you dont see it as trivial, then your implementation of polynomial is different from the one I imagine, and thus it is hard to help unless I know what your implementation is
17:25:46 <jle`> Tjr: the source code is online tho
17:25:48 <benzrf> RedNifre: http://lpaste.net/106446
17:25:51 <benzrf> @letlpaste 106446
17:25:53 <lambdabot>  Defined.
17:25:56 <benzrf> > someVar
17:25:58 <lambdabot>  3
17:26:02 <jle`> :O
17:26:12 <Tjr> int-e: Feature request: Maybe you could make @help return a hint how to get a list of all admissible lambdabot commands.
17:26:14 <johnd> hmm
17:26:19 <WJW> FRP vs. iTasks -- anyone compared?
17:26:20 <benzrf> Tjr: write it yrself
17:26:20 <jle`> Tjr: well, it sort of does
17:26:35 <jle`> @help
17:26:35 <lambdabot> help <command>. Ask for help for <command>. Try 'list' for all commands
17:26:37 <jle`> @help list
17:26:37 <lambdabot> list [module|command]. Show commands for [module] or the module providing [command].
17:26:38 <Tjr> benzrf: see, that's what's wrong with open source.
17:26:39 <jle`> @help list
17:26:39 <lambdabot> list [module|command]. Show commands for [module] or the module providing [command].
17:26:43 <Tjr> jle`: it doesn'T
17:26:44 <jle`> @list module
17:26:44 <lambdabot> No module "module" loaded
17:26:46 <benzrf> Tjr: i'd just like to interject for a moment
17:26:46 <jle`> @listmodules
17:26:46 <lambdabot> activity base bf check compose dice dict djinn dummy elite eval filter free fresh haddock help hoogle instances irc karma localtime more oeis offlineRC pl pointful poll pretty quote search slap source spell system tell ticker todo topic type undo unlambda unmtl version where
17:26:55 <benzrf> what you're referring to as 'open source' is actually 'free software'
17:26:58 <MP2E> Tjr : how is it any less of a problem with closed source
17:26:59 <pavonia> @list
17:26:59 <lambdabot> What module?  Try @listmodules for some ideas.
17:27:02 <benzrf> or as i've taken to calling it, 'libre software'
17:27:03 <RedNifre> @letlpaste 106447
17:27:04 <lambdabot>  Defined.
17:27:10 <jle`> ah that's it
17:27:13 <RedNifre> > helpyourself
17:27:14 <lambdabot>  "\n@help\n"
17:27:14 <jle`> @help -> @list -> @listmodules
17:27:14 <lambdabot> help <command>. Ask for help for <command>. Try 'list' for all commands
17:27:19 <rwbarton> i think the problem is that there are eighty billion commands
17:27:19 <RedNifre> ...
17:27:25 <RedNifre> Doesn't like newlines, huh?
17:27:29 <WJW> "libre" is a postmodifier, like "galore".  "Software libre".
17:27:36 <benzrf> WJW: w/e
17:27:41 <jle`> > text helpyourself
17:27:42 <johnd> kazagistar: the idea is that whether you write poly1, poly2 or poly3 you can obtain the coefficients
17:27:43 <lambdabot>  @help
17:27:50 <jle`> ^^ RedNifre
17:27:55 <WJW> benzrf, what's "w/e"?
17:27:58 <jle`> but yes it doesn't like newlines
17:28:01 <benzrf> WJW: whatever
17:28:05 <Welkin> with emus
17:28:08 <kazagistar> benzrf: my favorite permissive license to use is the WTFPL
17:28:09 <jle`> benzrf: don't just blow him off
17:28:15 <jle`> he asked you a question
17:28:17 <jle`> :P
17:28:17 <DanielDiaz> WJW: actually, it is also correct to write "libre software"
17:28:19 <DanielDiaz> :P
17:28:40 <WJW> benzrf, in regard to iTasks (used in Concurrent Clean) vs. FRP?
17:28:54 <Tjr> MP2E, benzrf It's a problem with the open source culture. In the windows world, missing documentation is often treated as a customer support issue, rather than "go guess what it does and then do my bugfixing work for me"
17:29:01 <WJW> DanialDiiz, well, it sounds wonky to me.
17:29:10 * Tjr isn't saying windows is better.
17:29:23 * Tjr is pointing out a bug in the open source culture.
17:29:31 <kazagistar> johnd: are poly1 and what not referencing something? I still dont see code or anything, so I am not sure what you are talking about (though my internet did die for a second)
17:29:31 <rwbarton> in all seriousness, lambdabot is a bot for #haskell, if you want to know how to use it, ask in #haskell
17:29:46 <MP2E> That's more because open source work involves hobbyists and people who are doing what they enjoy. Those same people typically don't enjoy writing docs
17:29:56 <MP2E> it is a problem, but closed source makes this unacceptable because there is a transfer of money
17:30:01 <Tjr> rwbarton: In such a situation, I've already been told to /query it.
17:30:02 <flebron> Hey, design questiomn. I have a problem and I'm modelling it as an integer linear program, and I'm creating testcases (i.e. inputs to an ILP solver which are instances of my problem). I'd like to have semi-random instances printed out, but be able to say "OK now this value is used", and in the random cases print out the random seed, so that test cases are repeatable. Does it make sense to have a type Context
17:30:04 <flebron> for all my problem's variables, which is created using HFlags in main, and then have the different things I have to output (matrices) all be of type Context -> a for each a I want?
17:30:20 <Tjr> rwbarton: that kind of defeats the purpose of "ask when you don't knwo how it works"
17:30:35 <MP2E> in other words, open source softwares would probably have better docs if they were getting paid to work
17:30:40 <MP2E> ;P
17:31:09 <RedNifre> hm....
17:31:18 <WJW> In runtime environments that support monadic I/O, what is the argument to the main routine; is it the world?
17:31:41 <Tjr> MP2E: easy solution: give  lambdabot a user-editable documentation / wiki / database /...
17:31:45 <dwcook> WJW, there is no argument. It's not a function.
17:31:48 <zwer_i> main doesn't take any arguments
17:31:50 <RedNifre> @let something = "something"
17:31:51 <lambdabot>  Defined.
17:31:52 <zwer_i> it is a value
17:31:52 <RedNifre> > something
17:31:53 <flebron> (So that if the flag is not set via command line, I use a random seed, and if it's set I use that value.)
17:31:54 <lambdabot>  "something"
17:32:06 <johnd> kazagistar: the code of the function 'coefficients' you mean ?
17:32:25 <dwcook> zwer_i, being a value isn't what's important. After all, functions are values.
17:32:38 <WJW> In runtime environments that support monadic I/O, what is the type of the value returned by the main routine?
17:32:44 <kazagistar> johnd: the code for what a Polynomial *is*, by your defintion
17:32:51 <johnd> oh
17:32:59 <zwer_i> dwcook that is true
17:33:29 <johnd> I thought i had sent it
17:33:46 <johnd> is this readable ? http://lpaste.net/8191646512111943680
17:34:20 <dwcook> WJW, it depends on what you mean by "returned". main can have any type of the form IO a, where a is a type variable.
17:34:33 <dwcook> s/type variable/type/
17:34:34 <kazagistar> johnd: so far it makes sense, ill take a peek
17:34:47 <WJW> What does the type notation "IO ()" evaluate to?
17:35:02 <rwbarton> it doesn't evaluate
17:35:06 <johnd> thx
17:35:12 <WJW> What I mean is, what information is encoded in the value of main?
17:35:50 <WJW> How can I understand the set of possible values of main?
17:35:52 <zwer> is there a word for a value in haskell that isn't a function?
17:35:59 <WJW> and what they mean?
17:36:14 <dwcook> WJW, IO a are procedures that can be executed by the runtime system.
17:36:20 <dwcook> zwer, "non-function value".
17:36:41 <WJW> What is the language of the procedures that can be executed by the runtime system?
17:36:43 <zwer> dwcook a better one?
17:36:51 <dwcook> zwer, there is none.
17:37:02 <derekv> when you define an algebraic data type, do you need to define your own predicate to check which variant a value is? eg if I want to filter a list by variant?
17:37:16 <flebron> WJW: IO () means an IO computation returning a value of type ().
17:37:19 <kazagistar> johnd: It seems like you would need to normalize it using some kind of algebra system
17:38:12 <johnd> hmm ?
17:38:31 <cstanfill> @hoogle [Maybe a] -> [a]
17:38:31 <WJW> My understanding is that the semantics of a type is a set (possibly infinite) of possible values.  Characterize the possible values that conform to the type "IO ()" in terms of what they mean when interpreted by the runtime system as I/O operations.
17:38:31 <lambdabot> Data.Maybe catMaybes :: [Maybe a] -> [a]
17:38:31 <lambdabot> Data.Maybe maybeToList :: Maybe a -> [a]
17:38:31 <lambdabot> Prelude sequence :: Monad m => [m a] -> m [a]
17:38:35 <Tjr> In C, you can do main()={return 3;}
17:38:46 <RedNifre> "a" value of type ()? Isn't () the only value of type ()?
17:39:00 <Tjr> How would a haskell app return an error code, lik this?
17:39:14 <rwbarton> WJW, there is no formal semantics of IO
17:39:19 <flebron> Tjr: System.Exit
17:39:24 <cstanfill> derekv: I don't know of any automatic predicate likethat
17:39:33 <Tjr> flebron: thanks
17:39:48 <flebron> WJW: You can look at the definition of the type IO to see which values it can have.
17:39:49 <cstanfill> derekv: but pattern matching makes it pretty easy
17:40:04 <kazagistar> johnd: well, your polynomial can be normalized into a sum of products and then the values extracted by inspection? unless that is undesireable for some reason
17:40:26 <RedNifre> well, gotta go. Good night!
17:40:39 <flebron> WJW: You can also take a look at http://www.haskell.org/haskellwiki/IO_inside
17:40:39 <johnd> nope, it isn't undesireable
17:40:40 <benzrf> nite
17:41:08 <Tjr> johnd: (just chiming in) do you admit polynomials in several variables?
17:41:08 <dwcook> WJW, practically any program that can be executed on your computer can be an interpretation of a value of an IO type.
17:41:22 <johnd> mmm no
17:41:31 <WJW> flebron, thanks, that reference seems to address what I wanted to know.
17:43:30 <derekv> cstanfill I know how to define one using matching, i just thought it'd be nice to do it in an anonymous function for, eg, filtering
17:43:59 <benzrf> 1
17:46:53 <kazagistar> johnd: binary form is actually a really terrible way of storing group operations, because it has excess structure, so it makes it hard to reason about and program with... I think lists are better... take Sum Poly Poly | Product Poly Poly and turn it onto { Term = Product [Sum] | Value | Var } and { Sum = Sum [Product] }, and then distribute product over sums to get a flat version
17:47:33 <kazagistar> er, *Sum [Term]
17:48:44 <johnd> kazagistar: It seems like a good idea what you just said, but it just to be done that way. The idea is to normalize it so it can return the list, e.g. coefficients poly2 : [1/3,2/5,0,1]
17:48:47 <kazagistar> if you only admit a single variable, then there is probably an easier way though
17:50:02 <kazagistar> you can just fold down the structure using some fancy monoid
17:51:14 <kazagistar> like, a list of coefficients
17:51:35 <kazagistar> defined recursively, should be pretty straightforward I think
17:51:47 <Tjr>  johnd in linear algebra, polynomials were defined as a finite list of coefficients, not as the functions from numbers to numbers.
17:52:08 <rudi_s> Can I get haskeline to interprete jk as escape to enter vim mode? This is much faster for me than using esc (which additional has a timeout). Thanks.
17:52:13 <Tjr> johnd: basically, it's easy to go from coefficients to function, but hard the other way around.
17:52:47 <Tjr> johnd: plus, it generalizes naturally to polynomials over finite fields, over fings, etc.
17:52:49 <int-e> Tjr: @help sort of does: @help points to @list; @list points to @listmodules and if you run @list for each module you'll collect a list of commands.
17:53:02 <benzrf> Tjr: fings?
17:53:05 <benzrf> are those like rings?
17:53:15 <Tjr> benzrf: you knwo what I mean
17:53:16 <kazagistar> johnd: lets just take a look at your function, and implement it recursively by cases Poly -> [Rationals]
17:53:24 <benzrf> Tjr: what does knwo mean
17:53:27 <andkore> Anyone know of a channel on freenode about program design/architecture/databases/scalability?
17:53:39 <benzrf> andkore: those are separate topics
17:53:43 <benzrf> you could try ##programming
17:54:25 <johnd> Tjr: I just need a function that extract the coefficients that have been defined previously
17:54:26 <andkore> I mean people here are a lot better informed than the people in ##programming
17:54:27 <Tjr> int-e: I'm writing this from a newbie perspective. @help is a natural thing to try if you don't know at all how to operate a piece of software. The response assumes you're hoogling, whereas a newbie would expect a pointer how to get the hand of lambdabot
17:54:40 <Tjr> s/hand/hang
17:54:43 <Tjr> s/hand/hang/
17:55:28 <Tjr> benzrf: s/fing/ring/
17:55:33 <kazagistar> johnd: I think it will be quite simple of you just start working through it, starting from the easy cases like Cte and Var
17:55:36 <benzrf> :^D
17:56:07 <Tjr> int-e: you're assuming a newbie knows what a module is.
17:56:54 <kazagistar> johnd: cooef (Cte r) = [r]; cooef (Var) = [0, 1];
17:57:07 <rwbarton> even I didn't understand what a module was
17:58:13 <rwbarton> even if it was "What command module?", that would help
17:59:24 <benzrf> @let data Term a = Term {coefficient :: a, var :: String}
17:59:25 <lambdabot>  Defined.
17:59:44 <benzrf> @let data Polynomial a = Polynomial [Term a]
17:59:45 <lambdabot>  Defined.
17:59:52 <benzrf> hows that
18:00:16 <kazagistar> thats how it was in my mind, but that is not how it is in his code, which is what we are working with
18:01:00 <int-e> @help eval
18:01:00 <lambdabot> eval. Do nothing (perversely)
18:01:01 <kazagistar> he starts with arbitrary binary operations (+ and *) on fractions and variables
18:01:44 <benzrf> @let class Ring a where radd :: a -> a -> a; rid :: a; rinv :: a; rmult :: a -> a -> a; mid :: a
18:01:46 <lambdabot>  Defined.
18:01:59 <benzrf> @let class Ring a => Field a where minv :: a
18:02:00 <lambdabot>  Defined.
18:02:19 * hackagebot aivika-experiment-diagrams 1.3 - Diagrams backend for the Aivika simulation library  http://hackage.haskell.org/package/aivika-experiment-diagrams-1.3 (DavidSorokin)
18:02:19 * hackagebot Ketchup 0.2.3 - A super small web framework for those who don't like big and fancy codebases  http://hackage.haskell.org/package/Ketchup-0.2.3 (Hamcha)
18:02:57 <benzrf> @let instance Ring Float where radd = (+); rid = 0; rinv = negate; rmult = (*); mid = 1
18:02:58 <lambdabot>  .L.hs:174:16:
18:02:59 <lambdabot>      Couldn't match expected type ‘Float’ with actual type ‘a0 -> a0’
18:02:59 <lambdabot>      Probable cause: ‘negate’ is applied to too few arguments
18:02:59 <lambdabot>      In the expression: negate
18:02:59 <lambdabot>      In an equation for ‘rinv’: rinv = negate
18:03:13 <benzrf> oh wait
18:03:13 <benzrf> dang
18:03:24 <benzrf> i messed up that type sig
18:03:46 <johnd> kazagistar: that seems to be the way
18:03:55 <benzrf> >mfw
18:04:00 <benzrf> @undefine
18:04:00 <lambdabot> Undefined.
18:04:15 <enthropy> [a] -> a -- is this type part of useful classes?
18:04:41 <int-e> @type msum
18:04:42 <lambdabot> MonadPlus m => [m a] -> m a
18:04:42 * enthropy could do   newtype F a b = F ([a] -> b) -- and have Profunctor F
18:04:43 <rwbarton> like mconcam?
18:04:45 <rwbarton> *t
18:04:54 <int-e> @type mconcat
18:04:54 <lambdabot> Monoid a => [a] -> a
18:05:00 <enthropy> but usually I have a~b, so maybe there's something more specific?
18:05:18 <Tjr> int-e: When I first came to this channel, I expected the @help command to inform me about ">", "@", ":t", "@src" and so on. I still don't know where to find a full list.
18:05:31 <enthropy> @commands
18:05:31 <lambdabot> Unknown command, try @list
18:05:32 <kazagistar> johnd: then, adding two items means adding the elements returned by the recursive call (resulting in the length of the longer list) and multiplying... ill let you work it out
18:05:35 <enthropy> @list
18:05:35 <lambdabot> What module?  Try @listmodules for some ideas.
18:06:06 <rwbarton> @yhjulwwiefzojcbxybbruweejw
18:06:06 <lambdabot> "\"\\\"\\\\\\\"\\\\\\"
18:06:18 <kazagistar> wtf
18:06:22 <kazagistar> @asferhfiauhiauhefl
18:06:22 <lambdabot> Unknown command, try @list
18:06:29 <kazagistar> so thats not what you did
18:06:35 <enthropy> int-e, rwbarton specifically I have types kind of like https://github.com/aavogt/ErrorProp/blob/master/ErrorProp/Linearized.hs#L45
18:06:51 <enthropy> which are like functions [a] -> a
18:07:23 <Tjr> kazagistar, johnd multiplying polynomials is the same operation as a list convolution of their coefficients. IMHO convolutions turn up often enough to be a useful abstraction.
18:08:44 <Tjr> * useful abstraction in its own right
18:08:57 <benzrf> :t recip
18:08:57 <lambdabot> Fractional a => a -> a
18:09:00 <int-e> @list
18:09:01 <lambdabot> What module?  Try @listmodules for some ideas.
18:09:04 <int-e> @listmodules
18:09:04 <lambdabot> activity base bf check compose dice dict djinn dummy elite eval filter free fresh haddock help hoogle instances irc karma localtime more oeis offlineRC pl pointful poll pretty quote search slap source spell system tell ticker todo topic type undo unlambda unmtl version where
18:09:07 <int-e> @list pretty
18:09:07 <lambdabot> pretty provides: pretty
18:09:44 <kazagistar> would it be too horrible to build a Num instance for polynomial? that seems like it would result in an instantly useful DSL
18:10:31 <rasfar> Tjr: I think the listing of lambdabot commands was disabled because it puts too much noise into the channel. There is http://code.haskell.org/lambdabot/COMMANDS
18:10:32 <Tjr> kazagistar: Num implies +, -, *, <=, >=. The latter two can be a bit weird.
18:10:54 <benzrf> hmmm
18:10:55 <kazagistar> does Num imply Ord?
18:10:57 <Tjr> rasfar: now if that link would pop up in a place newbies expect it ...
18:11:11 <Tjr> kazagistar: it doesn't?
18:11:19 <geekosaur> kazagistar, no, because Complex isn't Ord
18:11:29 <rasfar> But it doesn't mention commands beginning : or > so maybe there's other bots being used? / yeah, if that link is stable it should come up for @commands or @list!
18:11:47 <rasfar> or @help rather
18:11:53 <Tjr> Does Num imply commutativity? IOW, can matrix rings be Num?
18:11:53 <kazagistar> abs and signum are the problem
18:11:56 <geekosaur> no, those are part of lambdabot but aren't "commands" as such
18:12:05 <geekosaur> more like read-macros
18:12:06 <benzrf> http://lpaste.net/106448 <- seems like a reasonable basis of polynomials to me
18:12:06 <rasfar> I see, thanks geekosaur
18:12:12 <benzrf> @letlpaste 106448
18:12:13 <lambdabot>  .L.hs:164:9: ‘radd’ is not a (visible) method of class ‘Ring’
18:12:17 <benzrf> dang!
18:12:43 <benzrf> @letlpaste 106449
18:12:45 <lambdabot>  Defined.
18:12:48 <benzrf> cool!
18:12:57 <benzrf> > 3 `rplus` 4
18:12:59 <lambdabot>  No instance for (GHC.Show.Show a0)
18:12:59 <lambdabot>    arising from a use of ‘M438663709012809033628453.show_M4386637090128090336...
18:12:59 <lambdabot>  The type variable ‘a0’ is ambiguous
18:12:59 <lambdabot>  Note: there are several potential instances:
18:12:59 <lambdabot>    instance [safe] GHC.Show.Show
18:13:04 <benzrf> >.>
18:13:20 <Tjr> kazagistar: abs would have its natural counterpart in a polynomial's degree. (algebra calls it a valuation)
18:13:53 <kazagistar> Tjr: ill believe you :D
18:14:12 <int-e> benzrf: how are you planning to multiply polynomials? (monomials are products of variables, not just single variables]
18:15:05 <kazagistar> the only law stated in Num is that (abs x * signum x == x)
18:15:09 <benzrf> int-e: oh wait
18:15:18 <Tjr> kazagistar: bad news
18:15:39 <Tjr> kazagistar: essentially, you'd have to say signum ==1 and abs == id
18:16:10 <int-e> Tjr: the real issue is that there is no proper documentation for lambdabot. there is http://www.haskell.org/haskellwiki/Lambdabot for starting out, I guess. The command list on code.haskell.org is not up-to-date.
18:16:13 <benzrf> int-e: dang
18:16:17 <benzrf> i misread wikipedia
18:16:17 <kazagistar> I could easily construct a fitting set of functions actually... abs just takes the absolute value of each cooeficient, and signum returns the signum of each coefficient
18:16:31 <kazagistar> Tjr: or would that be too much of an abomination
18:17:04 <rwbarton> you can use the leading coefficient sign for sigum
18:17:26 <Tjr> int-e: that link is a lot bettter than nothing. Maybe it could be put in @help?
18:17:29 <kazagistar> signum is a -> a, so it can be a polynomial
18:17:43 <Tjr> Somebody initiated DCC (whatever that ts) and I misclicked. Please retry.
18:17:56 <rwbarton> yes but it's going to be quite difficult to ensure abs x * signum x == x
18:18:05 * rwbarton usually leaves abs, signum undefined
18:19:01 <benzrf> int-e: how about http://lpaste.net/106450
18:19:23 <Tjr> The trouble with coefficient-wise abs is that it doesn't satisfy any of the algebraic relations we'd expect from an absolute value
18:19:27 <benzrf> shit forgot to turn Term a into Monomial a
18:20:40 <Tjr> if you're going for divisions via the Euclidean algorithm, abs ==degree-of-polynomial.
18:20:41 <int-e> benzrf: that looks much better
18:21:42 <Tjr> if you're going for the unit ring (i.e. the polynomials that you can safely stick in to the denominator), then signum == leading-coeffficient is the natural choice
18:24:09 <ij> IOStateArrow basically acts like a function? (That just also happens to go through IO under the hood and can set state with state commands, if it wants?)
18:25:27 <benzrf> > "foo" ++ "bar" >>= succ
18:25:29 <lambdabot>  Couldn't match type ‘[b]’ with ‘GHC.Types.Char’
18:25:29 <lambdabot>  Expected type: GHC.Types.Char -> [b]
18:25:29 <lambdabot>    Actual type: GHC.Types.Char -> GHC.Types.Char
18:25:32 <benzrf> oh wait
18:25:51 <benzrf> > "foo" ++ ["b", "a", "r"] >>= succ
18:25:52 <lambdabot>  Couldn't match expected type ‘GHC.Types.Char’
18:25:52 <lambdabot>              with actual type ‘[GHC.Types.Char]’Couldn't match expected type ...
18:25:52 <lambdabot>              with actual type ‘[GHC.Types.Char]’Couldn't match expected type ...
18:25:52 <lambdabot>              with actual type ‘[GHC.Types.Char]’Couldn't match type ‘[b]’ wit...
18:25:52 <lambdabot>  Expected type: GHC.Types.Char -> [b]
18:25:57 <benzrf> > "foo" ++ (["b", "a", "r"] >>= succ)
18:25:58 <lambdabot>  No instance for (GHC.Enum.Enum [GHC.Types.Char])
18:25:59 <lambdabot>    arising from a use of ‘GHC.Enum.succ’
18:26:03 <benzrf> oh
18:26:11 <kazagistar> how do you do a "zipWith" that has leftovers?
18:26:22 <jle`> kazagistar: what do you want to do wiht the leftovers?
18:26:30 <kazagistar> put in default values
18:26:34 <jle`> you can use replicate
18:26:49 <rwbarton> if you know which side might be short, it's easy
18:27:04 <jle`> oh yea,h if you know what side will be short, heh.
18:27:15 <jle`> > zipWith (+) [1..10] ([1..5] ++ replicate 0)
18:27:16 <lambdabot>  Couldn't match expected type ‘[c]’ with actual type ‘a0 -> [a0]’
18:27:18 <jle`> um sorry, repeat
18:27:19 <kazagistar> I mean, a zipwith that fills in blanks, like (Maybe a -> Maybe b -> c) -> [a] -> [b] -> [c]
18:27:22 <jle`> > zipWith (+) [1..10] ([1..5] ++ repeat 0)
18:27:23 <rwbarton> otherwise you get to write your own I think
18:27:24 <lambdabot>  [2,4,6,8,10,6,7,8,9,10]
18:27:40 <jle`> yeah, a zip with that deals with either side being shorter you probably have to write on your own
18:27:41 <kazagistar> jle`: so I have to check which one is bigger first?
18:27:50 <jle`> yeah, if you want to use the default zipWith
18:27:57 <jle`> bu you can write your own; i do'nt think there's one in base
18:28:03 <kazagistar> well, I was just wondering if there was one oh well
18:28:20 <jle`> i wrote my own for Map
18:28:27 <jle`> at one point
18:28:28 <kazagistar> I just remember that python has an optional parameter on zip which fills in with a default value
18:28:38 <benzrf> @undefine
18:28:38 <lambdabot> Undefined.
18:28:42 <benzrf> @letlpaste 106453
18:28:43 <lambdabot>  .L.hs:186:15:
18:28:44 <lambdabot>      Expecting one more argument to ‘Monomial’
18:28:44 <lambdabot>      The first argument of ‘Show’ should have kind ‘*’,
18:28:44 <lambdabot>        but ‘Monomial’ has kind ‘* -> *’
18:28:44 <lambdabot>      In the instance declaration for ‘Show Monomial’
18:28:46 <benzrf> shit
18:28:51 <jle`> zipWith' :: a -> b -> (a -> b -> c) -> [a] -> [b] -> [c]
18:29:00 <jle`> zipWith' _ _ _ [] [] = []
18:29:29 <benzrf> @letlpaste 106454
18:29:30 <lambdabot>  .L.hs:187:24:
18:29:30 <lambdabot>      Could not deduce (Num a) arising from the literal ‘0’
18:29:30 <lambdabot>      from the context (Show a)
18:29:30 <lambdabot>        bound by the instance declaration at .L.hs:186:10-38
18:29:30 <lambdabot>      Possible fix:
18:29:30 <kazagistar> Show a => Show (Monomial a)
18:29:35 * benzrf flips a table
18:29:38 <jle`> zipWith' x0 _ f [] (y:ys) = f x0 y : map (f x0) ys
18:29:52 <benzrf> brb starting up my comp that has haskell on it so that i can check this BEFORE pasting it
18:29:57 <jle`> zipWith' _ y0 f (x:xs) [] = f x y0 : map (flip f y0) xs
18:30:19 <jle`> > zipWith' x0 y0 f (x:xs) (y:ys) = f x y : zipWith' x0 y0 f xs ys
18:30:20 <lambdabot>  <hint>:1:32: parse error on input ‘=’
18:30:25 <jle`> oops why did i do >
18:30:30 <kazagistar> benzrf: you can also PM lambdabot
18:31:09 <zRecursive> @hoogle Control.Monad.Random
18:31:10 <lambdabot> package Random123
18:31:10 <lambdabot> package RandomDotOrg
18:31:10 <lambdabot> package random
18:31:26 <zRecursive> Can package name use little letter ?
18:31:46 <t4nk048> hello everybody
18:31:54 <t4nk048> i have a question
18:32:13 <sclv> @bot
18:32:14 <lambdabot> :)
18:32:15 <jle`> @let zipWith' _ _ _ [] [] = [];  zipWith' x0 _ f [] (y:ys) = f x0 y : map (f x0) ys; zipWith' _ y0 f (x:xs) [] = f x y0 : map (flip f y0) xs;  zipWith' x0 y0 f (x:xs) (y:ys) = f x y : zipWith' x0 y0 f xs ys
18:32:16 <lambdabot>  Parse failed: Illegal character ''\157''
18:32:18 <rwbarton> zRecursive: package, yes
18:32:20 <jle`> aw
18:32:27 <zRecursive> rwbarton: ok
18:32:31 <jle`> t4nk048: go ahead :)
18:32:42 <t4nk048> what i need to implement a program that simulate a flight search?
18:32:55 <jle`> t4nk048: what is so-called "flight search"?
18:33:41 <jle`> @let zipWith' _ _ _ [] [] = []; zipWith' x0 _ f [] (y:ys) = f x0 y : map (f x0) ys; zipWith' _ y0 f (x:xs) [] = f x y0 : map (flip f y0) xs; zipWith' x0 y0 f (x:xs) (y:ys) = f x y : zipWith' x0 y0 f xs ys
18:33:42 <lambdabot>  Defined.
18:33:57 <jle`> > zipWith' 0 0 (+) [1..5] [1..10]
18:33:59 <lambdabot>  [2,4,6,8,10,6,7,8,9,10]
18:34:00 <sclv> periodic reminder about the magic of Expr
18:34:03 <sclv> > let fibs = 1 : 1 : zipWith (+) fibs (drop 1 fibs) in take 5 fibs
18:34:04 <lambdabot>  [1,1,2,3,5]
18:34:07 <sclv> > let fibs = 1 : 1 : zipWith (+) fibs (drop 1 fibs) in take 5 fibs :: Expr
18:34:08 <lambdabot>  Couldn't match expected type ‘Debug.SimpleReflect.Expr.Expr’
18:34:08 <lambdabot>              with actual type ‘[a0]’
18:34:14 <sclv> > let fibs = 1 : 1 : zipWith (+) fibs (drop 1 fibs) in take 5 fibs :: [Expr]
18:34:16 <lambdabot>  [1,1,1 + 1,1 + (1 + 1),1 + 1 + (1 + (1 + 1))]
18:34:20 <jle`> sclv: :)
18:34:31 <t4nk048> for example travelocity
18:34:54 <jle`> t4nk048: you're going to have to be a bit more specific, sorry :)
18:36:02 <t4nk048> something like this http://www.skyscanner.net/
18:36:05 <jle`> sclv: if only it left in the redundant parenheses in (1 + 1) + (1 + (1 + 1))
18:37:21 <jle`> t4nk048: what aspect do you want to 'simulate' ?
18:37:52 <jle`> t4nk048: if you have a database, you can just do a simple lookup
18:37:56 <jle`> or filter
18:37:58 <jle`> and sort
18:42:14 <benzrf> i made a better Show for polynomials
18:42:19 <benzrf> @letlpaste 106455
18:42:20 <lambdabot>  Defined.
18:42:35 <benzrf> > (Polynomial [Monomial 3 [Indeterminate "x" 2, Indeterminate "y" 1], Monomial 1 [Indeterminate "" 0]]) :: Polynomial Float
18:42:36 <lambdabot>  3.0(x^2)y + 1.0
18:46:27 <t4nk048> 2) The program interface can be as easy (questions by the command line arguments of the call or the program). Should provide the option to indicate port of departure and destination, optionally intermediate ports. Additionally there must be a way to select which factor has priority (time, cost, or other).
18:48:44 <kazagistar> t4nk048: well, you seem to have named all the things you need...
18:54:33 <benzrf> can types be `infixed`
18:55:14 <benzrf> :k Int
18:55:14 <lambdabot> *
18:55:23 <benzrf> :k Int `Either` Int
18:55:24 <lambdabot> *
18:55:27 <benzrf> nice
18:56:14 <benzrf> @let class a `Has` b where getHas :: a -> b
18:56:15 <lambdabot>  Defined.
18:56:44 <benzrf> foo :: a `Has` Int => a -> Int -> Int
18:56:47 <benzrf> :y
18:56:58 <benzrf> oh wait needed a fundep there
18:57:05 <benzrf> oh no nvm
18:57:21 <benzrf> @let instance a `Has` a where getHas = idnar
18:57:21 <lambdabot>  .L.hs:201:18: Not in scope: ‘idnar’
18:57:22 <benzrf> @let instance a `Has` a where getHas = id
18:57:23 <lambdabot>  Defined.
18:57:30 <benzrf> > getHas 3 :: Int
18:57:31 <lambdabot>  No instance for (L.Has a0 GHC.Types.Int)
18:57:32 <lambdabot>    arising from a use of ‘L.getHas’
18:57:32 <lambdabot>  The type variable ‘a0’ is ambiguous
18:57:32 <lambdabot>  Note: there is a potential instance available:
18:57:32 <lambdabot>    instance [safe] L.Has a a -- Defined at L.hs:200:10No instance for (GHC.Nu...
18:57:38 <benzrf> > getHas "foo" :: String
18:57:39 <lambdabot>  "foo"
18:57:41 <benzrf> :y
18:58:04 <idnar> oh noes, I'm not in scope!~
18:58:10 <benzrf> idnar: im so sorry
18:58:22 <idnar> that's okay :)
18:58:56 <pyon-kouhai> just wondering, is there anything -XRank2Types can do that -XExistentialQuantification cannot?
19:00:00 <idnar> pyon-kouhai: http://www.haskell.org/pipermail/haskell-cafe/2008-September/048133.html looks like it answers that question
19:00:08 <pyon-kouhai> oh nice thanks
19:00:21 <idnar> (I'm not familiar with the details myself)
19:00:53 <pyon-kouhai> i know -XExistentialQuantification only allows the forall keyword in data constructors
19:00:54 <benzrf> sup pyon
19:01:03 <pyon-kouhai> benzrf: hai
19:01:28 <benzrf> pyon pyon pyon
19:01:35 <pyon-kouhai> but i wondered whether everything that can be done with -XRank2Types could be replicated with -XExistentialQuantification , up to some isomorphism of types
19:02:11 <benzrf> pyon-kouhai: possibly
19:02:20 <pyon-kouhai> (a pair of functions back and forth between a legal type with -XExistentialQuantification and a type only legal with -XRank2Types)
19:02:27 <benzrf> but it'd be pretty inconvenient!
19:03:06 <pyon-kouhai> ah sure... in practice i just do -XRankNTypes and all of this becomes a nonissue :-)
19:03:14 <benzrf> y
19:04:19 <pyon-kouhai> benzrf: because it subsumes all of this... the problem is that i really dislike manually supplying type annotations
19:04:33 <enthropy> f :: (forall a. Num a => a -> a -> a); f g = (g 1 (1::Int), g 1 (1 :: Double))
19:04:43 <enthropy> how do you do such a thing with -XExistentialQuantification?
19:05:12 <benzrf> pyon-kouhai: y = yes
19:05:14 <enthropy> data NumF where Num a => (a -> a -> a) -> NumF ?
19:05:29 <enthropy> data NumF where NumF :: Num a => (a -> a -> a) -> NumF
19:05:44 <pyon-kouhai> data Foo = forall a. Num a => Foo (a -> a -> a)
19:05:53 <pyon-kouhai> gadt syntax works as well
19:05:54 <enthropy> but that lets you escape safely?
19:06:11 <pyon-kouhai> escape what?
19:06:38 <enthropy> I mean you can write that "f" above with type   f :: NumF -> (Int,Double) ?
19:06:52 <pyon-kouhai> wait lemme see trying on ghci
19:08:26 <pyon-kouhai> enthropy: wait, f's type isn't even a rank 2 type
19:08:41 <enthropy> it is if you correct my mistake
19:08:53 <enthropy> f :: (forall a. Num a => a -> a -> a) -> (Int, Double)
19:09:05 <pyon-kouhai> oh
19:09:08 <pyon-kouhai> lemme see
19:11:04 <benzrf> johnd: what does this dcc thing mean
19:12:01 <johnd>  oh, not much actually, I'm sorry if it bothered you
19:12:49 <nmal> why don't we have a Show instance for functions?  it would be less scary for newbies to print function name and signature than a weird error
19:13:17 <copumpkin> because that can't be implemented
19:13:34 <copumpkin> and "less scary for newbies" isn't really a consideration
19:13:43 <copumpkin> Show has a rough contract and that wouldn't satisfy it
19:13:49 <nmal> it would also stop experienced users from following that error with a :t just to see a type without all the noise
19:14:09 <johnd> benzrf: but i'd be great if you accept
19:14:21 <nmal> copumpkin can't be implemented as the user of the language, you mean? surely people who write haskell compiler could write it
19:14:32 <copumpkin> yes, but we don't like building stuff into the compiler
19:14:34 <benzrf> johnd: dont know how
19:14:47 <johnd> oh
19:15:42 <benzrf> > (++"foo")
19:15:43 <johnd> i'll try again
19:15:43 <lambdabot>  <[Char] -> [Char]>
19:15:45 <benzrf> ^is posibl
19:16:26 <rasfar> benzrf: uses Data.Dynamic?
19:16:43 <benzrf> probs
19:17:15 <enthropy> Data.Typeable more likely
19:17:33 <enthropy> > (const (Proxy :: Proxy "foo"))
19:17:34 <lambdabot>  <hint>:1:24:
19:17:34 <lambdabot>      Illegal literal in type (use DataKinds to enable): "foo"
19:18:13 <rasfar> > let f :: Int -> Int ; f x = 1 + x
19:18:14 <lambdabot>  not an expression: ‘let f :: Int -> Int ; f x = 1 + x’
19:18:24 <rasfar> (works in ghci!)
19:18:36 <rasfar> anyhow, Data.Dynamic.toDyn of that gives:
19:18:45 <rasfar> <<Int -> Int>>
19:19:08 <nmal> copumpkin ghci has plenty of exceptions from the language does it not?  It is kind of "you're in IO" environment, but not really. so I wouldn't mind if it only worked in ghci, where it would be most useful
19:19:28 <copumpkin> why is it more useful than typing :t?
19:19:28 <rasfar> nmal, the above works in ghci or compiled
19:19:44 <nmal> copumpkin because you don't have to type :t
19:19:59 <enthropy> > (3, (+3))
19:20:00 <lambdabot>  (3,<Integer -> Integer>)
19:20:06 <rasfar> @ let f :: Int -> Int ; f x = 1+x
19:20:22 <copumpkin> I dunno, doesn't seem very compelling to me to add a special case exception where something literally has different instances in ghci from non-ghci
19:20:25 <copumpkin> and magic instances
19:20:26 <Ralith> if typing three characters is too much work, programming might not be for you
19:20:30 <copumpkin> when I could simply type :t
19:20:46 <enthropy> you can just import/write that instance Typeable a => Show a where show = show . typeOf
19:20:51 <kazagistar> johnd: its better to keep requests for assistance in public channels
19:20:52 <copumpkin> it's not really a value-level concern
19:21:06 <nmal> most newcomers don't even know what the error means
19:21:19 <copumpkin> then they can learn really quickly
19:21:53 <copumpkin> I don't want to gunk up the language to give them pleasant lies
19:22:15 <gipp> would it be fair to say that GHC.TypeLits obsoletes the type-level package? I'm trying to get a handle on some type-level programming and knowing what's out of date in the wiki would help
19:23:05 <nmal> copumpkin what lies? who says that ghci must output Show instance?  and it has nothing to do with the language, but the ghci environment, making it more pleasant. language would remain intact. how do you feel about map working on [a] instead of Functor, by the way?
19:23:21 <copumpkin> it was a mistake
19:23:24 <rasfar> @ typeOf f  -- was that defined then?
19:23:29 <copumpkin> it was an explicit bad decision back after Haskell 1.4
19:24:08 <rasfar> > let f (x::Int) -> 1+x
19:24:09 <lambdabot>  <hint>:1:16: parse error on input ‘->’
19:24:16 <kazagistar> and folds should be over Foldable, etc, right?
19:24:18 <rasfar> > let f (x::Int) = 1+x  --oops
19:24:19 <lambdabot>  not an expression: ‘let f (x::Int) = 1+x  --oops’
19:24:32 <rasfar> *shrug*
19:25:06 <kazagistar> rasfar: drop the let
19:25:24 <kazagistar> rasfar: or rather, make it "let .. in ..."
19:25:26 <jle`> it's better to avoid making new typeclasses when making a new api/library right
19:25:33 <jle`> even if it means making two versions of every function?
19:25:39 <rasfar> > let f (x::Int) = 1+x in typeOf f  -- then!
19:25:40 <lambdabot>  Int -> Int
19:25:59 <copumpkin> jle`: I wouldn't go that far
19:26:02 <rasfar> > let f x = 1+x in typeOf f
19:26:05 <lambdabot>  Integer -> Integer
19:26:30 <enthropy> gipp: the Nats in GHC.TypeLits are pretty limited
19:27:27 <jle`> copumpkin: what is the cut off?
19:27:36 <copumpkin> not sure there's a solid one
19:27:50 <nmal> Ralith  typing them over and over again every time I mistakenly fail to supply all the arguments gets old pretty quickly.. perhaps I am used to repl from other languages, all of which are capable of printing the function (and unlike most of them, haskell could print something more useful than just a name)
19:27:51 <copumpkin> don't make typeclasses willy nilly, but if it seems appropriate, I see nothing wrong with it
19:28:54 <gipp> enthropy: yeah, they've been frustrating me. I'll have a look at the others. There doesn't seem to be a lot of reading out there on this, I guess most people interested in this kind of stuff work in dependently-typed languages?
19:29:21 <jle`> i feel like having a typeclass instead of a concrete type makes the learning curve go way up
19:29:26 <jle`> especially when reading a type signature
19:29:37 <jle`> and especially for people new to haskell :/
19:30:14 <jle`> foo :: Bar x y -> Baz y becomes foo :: (Barlike r, Bazlike z) => r x y -> z y
19:30:56 <jle`> might be alleviated with helpful type names like foo :: (Barlike bar, Bazlike baz) => bar x y -> baz y
19:31:16 <jle`> but in that case the error message is still 10x uglier
19:31:29 <jle`> *error messages
19:31:42 <jle`> *are
19:31:45 <jle`> *100
19:32:37 <jle`> ...i feel like i didn't ask the question to hear an answer but only to affirm my unsure decisions >_>
19:32:38 <kazagistar> Dunno, I dont mind the "could not deduce X from context Y" or whatever
19:33:20 <jle`> kazagistar: it might be a No instance for..., perhaps.  but still, not something you would want someone firs tlearning haskell to see
19:34:33 <kazagistar> jle`: hmm, but the problem then lies in the errors, or in the communication about the errors
19:35:13 <jle`> i don't disagree that error messages present some upper bound to helpful abstractions in haskell
19:35:20 <kazagistar> or, perhaps, just provide a little bit of newbie hint logic :P
19:35:38 <kazagistar> we already have "did you mean extention" which often helps
19:35:50 <jle`> the spell checker, you mean?
19:36:33 <jle`> i think 7.8.2 has gotten better at reporting with type synonyms...was this an actual feature, or am i just going insane?
19:37:25 <kazagistar> I mean, it already suggests that you implement instances, which is usually not very useful, but we might be able to provide a better suggestion?
19:37:58 <kazagistar> or even per-datatype / typeclass suggestions that you could override
19:38:26 <kazagistar> > (1 :: Float) + (1 :: Int)
19:38:27 <jle`> yeah, if that could be managed somehow, that'd be great
19:38:27 <lambdabot>  Couldn't match expected type ‘GHC.Types.Float’
19:38:27 <lambdabot>              with actual type ‘GHC.Types.Int’
19:39:10 <kazagistar> really, we need a proper study
19:39:23 <kazagistar> or even improper
19:39:35 <kazagistar> get newbies to document error messages they struggle with
19:39:43 <rasfar> jle': that would be nice! i had an early love for rapid prototyping using type synonyms, but I got over it for the sake of GHC errors...
19:40:10 <jle`> rasfar: it really breaks/leaks critical abstractions in pipes, lens, etc.
19:41:10 <rasfar> yeah, that scares the heck out of newcomers. or even not newcomers, just application-oriented programmers like myself.
19:41:25 <jle`> if you need a producer of x, the type is Producer x m r... but a type error will show it as Proxy () x & ** @*$(  saljf a83rhja or something
19:41:26 <kazagistar> we can imagine new users struggle with this or that, but really, we need a way to actually find out
19:41:28 <jle`> i don't even know
19:41:59 <jle`> the whole point of the abstraction is that you do'nt have to worry about how producers are implemented, or the underlying type
19:42:08 <jle`> but even simple errors destroy that
19:42:08 <rasfar> kazagistar: it seems like, if somehow GHC could know how the error was relieved, and gather statistics on that, the messages could be more realistic.
19:42:25 <jle`> same for lens
19:42:34 <jle`> the type signatures may be all neat and pretty in the documentation
19:42:42 <jle`> but the error message type signatures will look completely unrelated
19:42:54 <jle`> ...also for type holes
19:43:22 <jle`> which is a real shame because these authors put a lot of thought into useful and meaningful type signatures/type synonyms, so people can carry on doing "type signature reasoning"
19:43:37 <rasfar> what gets me is the way type synonyms and expansions of same are mixed in error messages. I'd rather see fully-expanded types, consistently, than the mixture.
19:43:39 <jle`> the kind we push in the first couple weeks of any haskell introduction
19:43:52 <jle`> "look how awesome haskell is guys, you can reason with what stuff does using type signatures""
19:44:06 <jle`> just don't mention error messages >_>
19:44:27 <jle`> or abstractions that rely on type synonyms
19:44:35 <jle`> </rant>
19:44:37 <jle`> ok back to work
19:44:40 <rasfar> yep
19:44:52 <kazagistar> if we just recruited a few people who are learning haskell here to fill out some forms for errors they found confusing, that would be enough to start
19:44:54 <jle`> it's ok because haskell is perfect
19:45:30 <rasfar> kazagistar: that sounds very positive! who is "we" in this case, if I may ask?
19:45:42 <jle`> i already have a list of errors in my mind that are impossible for any new person to understand without help.  and even errors that intermediate users would have trouble with.  and that's not even including errors introduced by the various extensions
19:46:08 <kazagistar> haha, I guess "we" should mean "I make a form and convince others to push it" :P
19:46:43 <jle`> > 5 && True
19:46:44 <lambdabot>  No instance for (GHC.Num.Num GHC.Types.Bool)
19:46:44 <lambdabot>    arising from the literal ‘5’
19:47:14 <rasfar> oh, sorry you said "if" -- I missed that, and was curious whether this was fpcomplete or something
19:47:55 <kazagistar> "Paste error: ___ Paste code: ___ What did you find confusing: ___ How did you try to resolve it: ___ How long did it take: ___ "
19:48:41 <kazagistar> I mean, I have plenty of motivation to do it, since I need to start thinking about grad schools urgently
19:48:53 <jle`> good luck kazagistar
19:48:53 <rasfar> with sufficiently wide participation that could be pretty valuable data
19:49:42 <rasfar> but it's not impossible for the compiler to pick up on this automatically... (in some cases at least)
19:50:15 <carter> jle`: i sometimes worry "am i not understanding this type error, or have i found a ghc bug"
19:50:19 <rasfar> for example, if it suggests writing an instance declaration in the message, but the error is resolved with a new instance 1/100 times, then...
19:50:31 <kazagistar> rasfar: hmm, it is a bit intrusive though
19:50:32 <Lutin`> Lenses use the function functor instance, yeah?
19:50:43 <jle`> Lutin`: hm? in what context?
19:51:01 <rasfar> kazagistar: how so? I haven't explained myself well if you think so.
19:51:38 <rasfar> there might be privacy issues, since the information needs to be propagated to GHC headquarters to gather the stats.
19:51:56 <Lutin`> jle`: Like realLens f (r :+ i) = fmap (:+ i) (f r) where realLens :: RealFloat a => Lens' (Complex a) a
19:52:12 <benzrf> > fix error
19:52:14 <lambdabot>  "*Exception: *Exception: *Exception: *Exception: *Exception: *Exception: *Ex...
19:52:32 <kazagistar> rasfar: thats what I mean. Having a compiler email random information to people is not exactly desireable in my mind
19:52:41 <carter> rasfar: kazagistar  theres no ghc hq
19:52:43 <carter> its just uss
19:52:56 <rasfar> well, some voluntary server then
19:53:09 <carter> well
19:53:10 <Lutin`> Technically there is a GHC HQ at Microsoft Research
19:53:15 <carter> i think it need not be done by HQ
19:53:20 <carter> Lutin`: not really
19:53:21 <rasfar> Cabal remote-build-reporting
19:53:22 <carter> spj yes
19:53:26 <Lutin`> At least that's what it used to be called
19:53:28 <rasfar> B)
19:53:37 <carter> but he's spending half his time on UK CS education
19:53:48 <carter> then Austin
19:53:53 <carter> and then everyone else who helps on ghc
19:54:06 <rasfar> Not one mention of Glasgow!
19:54:22 <carter> if you want to work on error messages, collect data and figure out a good plan to improve error messages with a concrete proposal
19:54:25 <carter> if you email ghc devs with
19:54:36 <carter> "i collected a survey about error messages"
19:54:39 <carter> no one will act on it
19:54:40 <kazagistar> rasfar: hmm, it does sound plausible, not sure... it seems like you would want to gather a diff between each failed compile attempt?
19:54:41 <rasfar> anyhow, it could be voluntary; even a few dozens of the willing would go a long way
19:54:48 <carter> my point being
19:55:07 <carter> there needs to be someone who takes ownership of experimenting with engineering to improve error messagess
19:55:10 <carter> for that to matter
19:55:32 <carter> uness you use it instead to inform intro pedagagy
19:55:33 <benzrf> http://steve-yegge.blogspot.com/2010/12/haskell-researchers-announce-discovery.html ;-;
19:55:38 <benzrf> oops wc
19:55:48 <rasfar> kazagistar: yeah, something like that -- but to be automated, the analysis system would need to understand whether the suggestions were relevant to the actual fix, which seems overly ambitious
19:55:59 * enthropy is pretty sure there have been research projects on improving type errors
19:56:11 <carter> yup, enthropy  is right
19:56:14 <carter> its REALLY hard
19:56:20 <kazagistar> rasfar: which is why it might be more meaningful in some sense to do adhoc surveys
19:56:33 <carter> theres phds lurking in improving ghc's error messages in a meaningful way
19:56:46 <rasfar> agreed; better short-term gains anyway
19:57:19 <carter> if you wanna do it, that'd be great :)
19:58:20 <kazagistar> haha I am still finishing up my undergraduate degree, but I dont try to let my status limit me
19:58:29 <kazagistar> *try not to let
19:58:32 <enthropy> http://nautilus.cs.miyazaki-u.ac.jp/~skata/MagicHaskeller.html is somewhat related
19:59:26 <enthropy> in that you might generate functions that are very close to the one provided (except they typecheck)
20:00:45 <kazagistar> enthropy: interesting
20:01:09 <kazagistar> it certainly looks better then djinn
20:01:39 <gipp> does anyone know whether there are concrete proposals for improving the TypeNats solver in upcoming versions of GHC?
20:02:00 <gipp> at least it's been really fun diving deep into GHC and type programming to find out that they can't do what i want
20:02:05 <enthropy> gipp: it's supposed to get better
20:02:08 <gipp> I learned a lot today!
20:02:26 <carter> gipp: i use peanos :)
20:02:33 <gipp> i wish i could
20:02:39 <jle`> Lutin`: are you looking at http://comonad.com/reader/2012/mirrored-lenses/ ?
20:02:46 <gipp> but i'm trying to work with the new hmatrix static-length vectors
20:02:51 <gipp> which are tied to GHC.TypeLits
20:02:55 <carter> gipp: ohhh
20:02:59 <carter> i'm sorry
20:03:04 <carter> solution: don't use them
20:03:14 <carter> gahhh, i need to get my matrix lib out
20:03:23 <carter> gipp: btw, #numerical-haskell is a thing
20:03:27 <carter> on the freenodes
20:03:33 <jle`> free the nodes
20:03:34 <Lutin`> jle`: Yeah
20:03:36 <jle`> all the nodes
20:04:06 * enthropy thinks Iavor Diatchki is responsible for the GHC.TypeLits Nats
20:04:14 <carter> yup
20:04:19 <gipp> carter: nice, I'll try and idle there some
20:04:22 <jle`> Lutin`: i think in that case f :: forall f. (Functor f, RealFloat a) => a -> f a
20:04:24 <carter> cool
20:04:29 <jle`> er wait
20:04:30 <carter> its a bit quiet now
20:04:31 <jle`> sorry
20:04:32 <enthropy> gipp: if you look in ghc's trac / mailing list you can probably find some status
20:04:41 <carter> will be a bit bonkers in a few more week
20:05:00 <jle`> f :: forall f. (Functor f, RealFoat b) => b -> f b
20:05:04 <carter> enthropy: i kinda want to give type lits peano powers + their current binary integer efficent rep
20:05:13 <Lutin`> jle`: Oh whoops was misreading
20:05:14 <jle`> sorry for using f for the function name and for the functor type variable
20:05:22 <enthropy> carter: there is such a thing somewhere...
20:05:25 * enthropy searches
20:05:36 <carter> enthropy: not that lets you go in both dir
20:05:38 <carter> afaik
20:05:39 <jle`> so then f r :: forall f. (Functor f, RealFloat b) => f b
20:05:39 <Lutin`> jle`: Yeah for some reason I thought fmap was using the Lens functor instance
20:05:43 <Lutin`> I see now
20:05:53 <jle`> Lutin`: yeah, it's using the functor instance of forall f. Functor f
20:05:56 <Lutin`> Yeah
20:05:59 <Lutin`> Thanks
20:06:01 <jle`> np
20:06:06 <carter> http://www.haskell.org/ghc/docs/latest/html/libraries/base-4.7.0.0/GHC-TypeLits.html
20:06:32 <jle`> man who invented van Laarhoven lenses
20:06:32 <carter> enthropy: theres no way to go back and forth
20:06:33 <jle`> they're smart.
20:07:11 <jle`> badum-pssshh
20:07:15 <enthropy> jle`: van Laarhoven
20:07:20 <enthropy> you wouldn't have guessed :p
20:07:26 <jle`> badum-pssshh
20:07:37 <jle`> or is it tsshhh
20:08:23 <enthropy> carter: so you want a list of digits in ascending powers?
20:08:32 <carter> enthropy: no
20:08:35 <carter> i mean
20:08:49 <carter> typelits nats are reprsented internally with Intteger
20:08:57 <carter> i want a peano interface on them too :)
20:09:05 <carter> so i can induct and have efficient rep both
20:09:34 <enthropy> I don't think you can do that without ghc hacking
20:09:56 <carter> yup
20:09:58 <carter> i knowww
20:10:02 <carter> thats why i said "i want"
20:10:05 <carter> not "i can"
20:10:35 <carter> :)
20:10:36 <enthropy> yeah somebody should do it
20:12:06 <carter> the tricky bit is figuring out how to hack it in such that no one gets sad
20:13:04 <rola> does it make sense to think about Functor and fmap as follows: suppose you have two categories C1 and C2 and a functor F : C1 → C2. fmap takes a list  of objects and morphism in C1 and gives you back F applied to the objects and morphism. (composition and identities are preserved)
20:14:01 <copumpkin> hm, doesn't sound quite right
20:14:08 <Iceland_jack> rola: why 'list of objects'?
20:14:20 <Iceland_jack> The definition of a functor is quite simple, especially if you ignore the laws
20:14:21 <copumpkin> fmap takes a morphism in C1 to a morphism in C2
20:15:06 <jle`> are there any other useful applicative-based typeclasses besides Monoid?  Some do Num and Fractional
20:15:17 <rola> copumpkin, oh
20:15:28 <Iceland_jack> Monoid is applicative-based?
20:15:32 <copumpkin> except fmap is all one category
20:15:33 <jle`> i mean
20:15:40 <jle`> hm
20:15:43 <jle`> that is a bad way to say it
20:15:46 <Iceland_jack> Applicative is actually monoidal :) but that's another story
20:15:48 <jle`> but my example is
20:16:01 <jle`> instance Monoid b => Monoid (a -> b) where
20:16:04 <jle`> mempty = pure mempty
20:16:07 <jle`> mappend = liftA2 mappend
20:16:17 <jle`> basically the Monoid instance comes for free with the Applicative instance
20:16:21 <jle`> same for Num
20:16:29 <jle`> instance Num b => Num (a -> b) where
20:16:31 <jle`> (+) = liftA2 (+)
20:16:37 <jle`> (*) = liftA2 (*)
20:16:43 <jle`> fromInteger = pure . fromInteger
20:16:45 <jle`> etc.
20:17:04 <Iceland_jack> Right but that's just lifting an operator, using a singular Applicative instance
20:17:15 <jle`> yeah, so i'm asking if there are any useful typeclasses to do this on
20:17:19 <copumpkin> I think the core observation is that you can lift any n-ary function over an applicative
20:17:24 <jle`> besides Monoid, Num, and Fractional
20:17:48 <enthropy> Floating
20:17:59 <jle`> i guess every typeclass can be lifted this way
20:17:59 <Lutin`> jle`: Parsers?
20:18:00 <jle`> huh.
20:18:14 <jle`> Lutin`: i mean typeclasses
20:18:17 <Lutin`> Oh
20:18:27 <Lutin`> Misread
20:18:27 <jle`> but Parsers are an Applicative wher eyou could apply this to
20:18:35 <jle`> you can make any Parser a monoid or a num or a fractional
20:18:35 <enthropy> jle`: some things you can't do like:   toRational :: Real a => a -> Rational
20:18:36 <Iceland_jack> This may be interesting to you
20:18:36 <Iceland_jack>     http://www.cs.ox.ac.uk/ralf.hinze/Lifting.pdf
20:18:50 <jle`> enthropy: oh yeah, i remember seeing that
20:18:59 <enthropy> also half of the methods in RealFloat won't work either
20:19:08 <Iceland_jack> You're basically just talking about lifting a function
20:19:08 <Iceland_jack>     lift (+) f g a = f a + g a
20:19:26 <jle`> mhm, i see
20:20:07 <jle`> are there many other useful typeclasses that can be lifted in this way and be practical?  and not just for (->) a but for arbitrary applicative.
20:20:12 <jle`> Floating sounds like one that would work
20:21:57 <Iceland_jack> You can do
20:21:57 <Iceland_jack>     instance (Applicative f, Monoid b) => Monoid (f b) where
20:21:57 <Iceland_jack>       mempty  = pure mempty
20:22:00 <Iceland_jack>       mappend = liftA2 mappend
20:22:55 <jle`> really?  is that....safe?
20:22:57 <Iceland_jack> no
20:23:01 <jle`> :P
20:23:39 <jle`> enum would work if it weren't for fromEnum
20:24:02 <jle`> ord does not work
20:24:13 <jle`> nor eq
20:24:33 <jle`> i guess any typeclass where all the members aren't of form a or a -> a  or a -> a -> a, etc.
20:24:38 <jle`> *methods
20:24:54 <jle`> ...where not all members are of the form a, a -> a, a -> a -> a, etc.
20:24:57 <jle`> methods
20:26:14 <solidus-1iver> jle`: whats your experience been with writing opengl in haskell and outputing to html5 / canvas?
20:26:28 <solidus-1iver> i noticed you mentioned some stuff related to that on your netwire tests repo
20:26:41 <solidus-1iver> have you got a workflow set up that does that well?
20:26:50 <jle`> solidus-1iver: i have a theoretical one
20:26:58 <jle`> but i got busy before i could implement the html5/canvas part
20:27:09 <jle`> i had to wait on a fix in ghcjs, but by the time it got fixed, i was busy
20:27:18 <solidus-1iver> how did you achieve it, ah ghcjs
20:27:35 <jle`> not the only way, but i wanted to be able to use the same data types and same library.
20:27:39 <solidus-1iver> i was about to attempt to do the same thing but i was looking at haste over ghcjs
20:28:05 <solidus-1iver> yeah i got less sure as i looked into it
20:28:19 <solidus-1iver> it seemed like nomatter what i was going to have to make a different codebase for html5 / css
20:28:33 <jle`> i think my plan was solid, but i didn't actually implement it, and i had no idea if the performance would be acceptable or not
20:28:57 <jle`> i wrote ghcjs-websockets to prepare for it
20:29:26 * jle` reminisces
20:32:38 <jle`> why is Monoid e => Either e not Alternative?!
20:32:40 * jle` flips table
20:32:56 <pyon-kouhai> wait it isn't?
20:33:11 <jle`> not in 7.8.2
20:33:33 <pyon-kouhai> it's a trivial generalization of Alternative for Maybe
20:33:39 <pyon-kouhai> i'd expect it to be there in stdlib
20:34:23 <jle`> maybe it is that not all mempty's are equivalent
20:34:34 <jle`> er
20:34:35 <jle`> empty
20:34:43 <jle`> well there is only one empty, empty = pure mempty
20:34:50 <jle`> um
20:34:50 <pyon-kouhai> yea
20:34:52 <jle`> empty = Left mempty
20:34:57 <pyon-kouhai> yea
20:35:03 <jle`> but then other Left's can effectively act like empty's
20:35:09 <jle`> and maybe there's a problem with that
20:35:13 <pyon-kouhai> no
20:35:18 <jle`> idk man!
20:35:20 <jle`> :'(
20:35:32 <pyon-kouhai> only 'Left mempty' is a legit empty
20:36:14 <jle`> would i get in trouble for defining my own instance of Alternative for Monoid e => Either e in my library then
20:36:18 <jle`> (probably :( )
20:37:34 <prototrout> Is there a library function anywhere that's equivalent to ((concat .) . (:))?
20:38:03 <jle`> :t (concat .) . (:)
20:38:04 <lambdabot> [a] -> [[a]] -> [a]
20:38:22 <jle`> is there an un-pl
20:38:35 <jle`> \xs xss -> concat (xs:xss)   -- ?
20:38:43 <prototrout> jle`: Yeah that's it
20:38:44 <sclv> jle`: i think you want the validation applicative?
20:38:45 <sclv> https://hackage.haskell.org/package/transformers-0.4.1.0/docs/Control-Applicative-Lift.html#v:Pure
20:38:51 <Iceland_jack>  @unpl ((concat .) . (:))
20:38:57 <Iceland_jack> @unpl ((concat .) . (:))
20:38:57 <lambdabot> (\ d g -> concat (((:)) d g))
20:39:02 <jle`> thank you Iceland_jack
20:39:12 <jle`> sclv: thanks, i'll look into it. i think i've heard of it before
20:39:13 <Iceland_jack> so many parentheses :)
20:40:01 <jle`> this (f .) . g idiom has got to go
20:40:24 <prototrout> jle`: Perhaps! But it was easier to type into the repl that way.
20:40:49 <jle`> maybe one day we'll see (.:) in Prelude
20:40:55 <jle`> idk
20:41:08 <jle`> @hoogle [a] -> [[a]] -> [a]
20:41:11 <lambdabot> Data.List intercalate :: [a] -> [[a]] -> [a]
20:41:11 <lambdabot> Prelude (++) :: [a] -> [a] -> [a]
20:41:11 <lambdabot> Data.List (++) :: [a] -> [a] -> [a]
20:41:16 <aji> i'm having a really hard time figuring out what (f .) . g would do
20:41:43 <jle`> aji: (f .) . g === \x -> f . g x === \x y -> f (g x y)
20:42:05 <aji> interesting
20:42:20 <jle`> it's not surprising that it isn't obvious
20:42:26 <jle`> :)
20:42:39 <jle`> i said both it's not and it isn't
20:42:47 <jle`> i always wondered if there was a rule in english that tells you which to use
20:43:04 <jle`> but i guess contractionation is an associative operation
20:44:50 <prototrout> If I have some definitions I've defined in the repl with "let", then I edit a file with :e, is there a way to have ghci automatically reload my "let" definitions? It's a pain to re-enter them every time I edit a file.
20:45:37 <enthropy> put the definitions in one of the files instead
20:45:48 <prototrout> (if I "let a = ()" then I ":e Main.hs", the definition of "a" is lost when Main.hs is reloaded)
20:45:49 <jle`> i just use ctrl+r :|
20:46:06 <jle`> but that's a bit ad-hoc
20:46:13 <aji> jle`: it's not vs it isn't i guess would depend mostly on author preference
20:46:16 <matematikaadit> @pl \f g -> (f .) . g
20:46:16 <lambdabot> (.) . (.)
20:46:21 <prototrout> enthropy: That's a bit of a pain because I'm often (re)defining them interactively
20:46:27 <matematikaadit> @@ @type @pl \f g -> (f .) . g
20:46:28 <lambdabot>  (b -> c) -> (a -> a1 -> b) -> a -> a1 -> c
20:46:52 <prototrout> and only saving to a file once I've settled on a definition
20:47:10 <ninja_code> damn it . someone needs to explain this to me . callback hell is a real problem . MVars solves it . How does haskell solve it with a library?
20:50:18 <copumpkin> ninja_code: you're going to need a more specific question than that to get something useful :)
20:50:43 <ninja_code> copumpkin: how should I rewrite ninja_code's question above to get somethign useful out of it? :-)
20:52:09 <copumpkin> the main thing GHC haskell does to avoid callback hell is to make blocking calls painless
20:52:18 <copumpkin> so you avoid callbacks in the first place
20:52:31 <copumpkin> the second thing Haskell can do to make callbacks less painful is to operate in the continuation monad
20:52:37 <prototrout> Somehow every time I ":e" and exit vim from within ghci, my terminal window's title gets another "Terminal - " prepended to it. It now reads "Terminal - Terminal - Terminal - Terminal - [...]"
20:52:48 <copumpkin> so you can act as if you have standard sequential code, even though secretly it's callback-based
20:52:51 <Lutin`> ninja_code: What exactly are you referring to with callback hell
20:53:59 <prototrout> ninja_code: I think a small code example demonstrating "callback hell" would be the most sure way to convey what you are asking
20:57:39 <genisage> If I do foldr (:) [] xs or foldr (++) [] xs, it's obvious to me that it can be lazily evaluated, but how does haskell decide whether or not it has to be strict?
20:58:07 <ninja_code> *thinking*
20:58:24 <copumpkin> genisage: haskell is always non-strict unless you go out of your way to tell it otherwise
21:01:47 <genisage> say I did, reverse $ foldl (flip (:)) [] [1..]
21:02:08 <genisage> That could be lazily evaluated if haskell was a bit smarter, but it isn't
21:02:25 <MP2E> that is lazily evaluated?
21:02:31 <MP2E> I don't understand :P
21:02:35 <copumpkin> genisage: why could it be?
21:02:57 <copumpkin> genisage: you appear to be applying external knowledge that is simply false
21:02:59 <genisage> It's [1,2,3,4,5...]
21:03:02 <copumpkin> no it isn't
21:03:32 <copumpkin> you seem to be assuming that reverse . reverse = id
21:03:46 <copumpkin> which is only true on finite lists
21:03:49 <copumpkin> this isn't a lazy evaluation thing
21:03:53 <copumpkin> it's just a computation thing
21:04:39 <jle`> reverse (reverse [1..]) still doesn't terminate if it's lazy
21:04:52 <jle`> @src reverse
21:04:52 <lambdabot> reverse = foldl (flip (:)) []
21:04:57 <jle`> @src foldl
21:04:57 <lambdabot> foldl f z []     = z
21:04:57 <lambdabot> foldl f z (x:xs) = foldl f (f z x) xs
21:05:04 <jle`> try evaluating it on pencil and paper
21:05:08 <jle`> that simulates "laziness"
21:05:20 <jle`> and you'll see why even in laziness it doesn't terminate
21:06:54 <Zekka> > reverse (reverse [1..])
21:06:59 <lambdabot>  mueval: ExitFailure 1
21:12:21 <genisage> Alright, that example was wrong, but I still think my original question is valid, that right fold ends up looking kind of like ( string1 ++ ( string2 ++ ( string3 ++ ... and I would like to know how haskell knows that it doesn't have to look at the right hand side of an operator to get the first elements. And if it's possible to tell haskell that your user defined operator will behave like that.
21:13:06 <Lutin`> genisage: It's about which argument your function is strict in
21:13:31 <Lutin`> We could say (:) is strict in it's first argument because (undefined : [] ) = undefined
21:14:03 <copumpkin> huh
21:14:08 <copumpkin> that's not true
21:14:19 <Lutin`> I might be using the wrong terminology
21:14:28 <copumpkin> not sure it's a terminology thing
21:14:31 <copumpkin> it just isn't true
21:14:32 <Lutin`> Oh wait
21:14:35 <Lutin`> nevermind
21:14:41 <Lutin`> Yeah it's just wrong
21:14:45 <copumpkin> :
21:14:46 <Lutin`> I was thinking uh
21:14:46 <copumpkin> :)
21:15:07 <Lutin`> what was I thinking of..
21:15:28 <Lutin`> it seems the no sleep has gone to my brain
21:15:47 <Zekka> > drop 1 (undefined: [])
21:15:48 <lambdabot>  []
21:15:57 <Zekka> Doesn't seem strict in its first segment to me
21:16:06 <Lutin`> Yeah I know it was wrong
21:16:09 <Lutin`> I was thinking uhmm
21:16:17 <genisage> probably you meant (++)
21:16:20 <genisage> right?
21:16:37 <Lutin`> Possibly?
21:16:58 <Zekka> > drop 1 (undefined ++ [1, 2, 3])
21:16:59 <lambdabot>  *Exception: Prelude.undefined
21:17:10 <Lutin`> I think I was thinking either ++ or ||
21:17:14 <Zekka> I think it's likely that's what you meant given that there's really no way to uncons through an undefined
21:18:12 <Lutin`> But I still wouldn't say it's not strict in the second argument
21:18:45 <genisage> So, how does haskell decide which arguments a function is strict in?
21:19:06 <Lutin`> That's more about what it has to evaluate to return
21:19:20 <Lutin`> a strict function is one such that `f undefined = undefined`
21:19:56 <copumpkin> genisage: it doesn't
21:20:01 <copumpkin> everything is non-strict
21:20:09 <genisage> But it initially assumes nothing is strict, and then gets what it needs as it needs it?
21:20:11 <Lutin`> well GHC does do strictness analysis
21:20:18 <copumpkin> yes, but that's GHC, not Haskell
21:20:20 <Lutin`> with -O
21:20:23 <Lutin`> Yes I agree
21:20:35 <copumpkin> genisage: yes, there's one condition that forces evaluation
21:20:43 <copumpkin> and that's pattern matching
21:21:08 <copumpkin> in a case expression or equivalent, I should say
21:21:19 <copumpkin> even that only happens if the result is demanded though
21:21:58 <copumpkin> > case undefined of True -> error "whoops" in 5
21:21:59 <lambdabot>  <hint>:1:42: parse error on input ‘in’
21:22:12 <copumpkin> > let x = case undefined of True -> error "whoops" in 5
21:22:13 <lambdabot>  5
21:28:57 <ReinH> genisage: haskell expressions are evaluated via pattern matching
21:29:01 <ReinH> @where lazy
21:29:01 <lambdabot> http://www.vex.net/~trebla/haskell/lazy.xhtml
21:29:04 <ReinH> ^ is a good introduction
21:29:20 <ReinH> I think it ought to be required reading, honestly
21:33:20 <carter> ReinH: i write Striaskell though :P
21:33:27 <carter> Bang Pattern bang bang bang
21:37:30 * hackagebot eros 0.2.0.0 - A text censorship library.  http://hackage.haskell.org/package/eros-0.2.0.0 (pharpend)
21:40:16 <andkore> I feel like there needs to be a channel for Haskell programmers to talk about things other than Haskell directly... Anyway, another off-topic question: what databases do you guys use? any people using non-relational databases? Brian O'Sullivan mentioned Riak in his "Running a startup on Haskell" talk
21:41:08 <carter> andkore: depends on your workload
21:41:17 <andkore> I have a feeling that relational databases are kind of a problem. SQL seems like abstraction at the wrong level.
21:41:20 <carter> use postgres until you have a reason not to
21:41:36 <andkore> carter: Have you heard of event sourcing?
21:41:45 <klurbin> I'm tweaking my Xmonad config and I often have trouble finding documentation about operators. For example I have a line "isFullscreen --> doFullFloat". I see other people online using something similar: "isFullscreen -?> doFullFloat". I can't find any documentation to figure out what the difference is between "-->" and "-?>"
21:41:54 <carter> probably, but thats not a formal term, so define it
21:42:02 <carter> @google event sourcing
21:42:03 <lambdabot> http://martinfowler.com/eaaDev/EventSourcing.html
21:42:03 <lambdabot> Title: Event Sourcing
21:42:10 <ggnmkk> andkore: #haskell-blah
21:42:18 <carter> andkore: you mean logging
21:42:20 <andkore> ggnmkk: is that real or are you just saying that?
21:42:26 <carter> if you have a transaction log
21:42:26 <rien> andkore: it's real
21:42:26 <andkore> well basically I think that any use of INSERT or UPDATE is a problem
21:42:28 <carter> its a real channel
21:42:30 * hackagebot eros 0.2.0.1 - A text censorship library.  http://hackage.haskell.org/package/eros-0.2.0.1 (pharpend)
21:42:38 <carter> andkore: you want a provenance log
21:42:38 <andkore> oh, good to know. shall we move there?
21:42:44 <carter> dont care
21:42:45 <carter> :)
21:43:08 <andkore> thanks for letting me know about that channel rien
21:43:09 <rien> I'm desperately trying to make an http request through a proxy. what's the recommended library?
21:43:14 <rien> andkore: np
21:46:56 <Adeon> can I somehow silence warnings about unused definitions selectively
21:48:22 <prototrout> rien: I don't know anything about 'recommended' or not, but wreq appears to let you specify a proxy
21:48:42 <prototrout> and given that it relies on http-client I assume that does too
21:50:40 <rien> prototrout: that looks pretty good. I'd never heard of it. thanks!
21:52:40 <gipp> oh my god I just caused a stack overflow, I didn't think that was actually possible
21:55:53 <Welkin> of course it is
21:55:58 <Welkin> if too many thunks build up
21:57:20 <rien> space leaks
21:57:30 <qrada> http://github.com/FtanML-WG/Specification/blob/master/grammar.txt , how is this grammar being expressed? anyone know the name of it?
21:57:48 <rien> qrada: BNF
21:58:28 <qrada> oo, got it thanks.. i searched BNF but clicked on extended. didn't realized extended uses = and normal uses ::=
22:10:55 <jle`> Adeon: if you prefix the name with _, you won't get any warnings
22:11:05 <jle`> const a _b = a
22:11:07 <jle`> gets no warnings
22:11:18 <rien> actually wreq won't do as it doesn't do authenticated proxies
22:11:32 <rien> I guess I'll have to go with libcurl
22:11:52 <Adeon> okay, that's something I didn't know about
22:43:33 <seanport> a
22:43:51 <seanport> a
22:44:01 <seanport> print hi
22:45:19 <seanport> a
22:45:19 <seanport> a
22:45:20 <seanport> a
22:45:20 <seanport> a
22:45:20 <seanport> a
22:45:23 <seanport> a
22:45:25 <seanport> a
22:45:28 <seanport> a
22:45:30 <ReinH> @where ops
22:45:30 <lambdabot> arjanb bos byorgey Cale conal copumpkin dcoutts dibblego dmhouse dolio dons edwardk elliott geekosaur glguy Heffalump Igloo jmcarthur johnw kosmikus Lemmih monochrom nyc Philippa Pseudonym quicksilver roconnor Saizan shachaf shapr sjanssen ski sorear SyntaxPolice xerox
22:45:43 <glguy> seanport, can you stop please
22:46:04 <seanport> sorry
22:51:28 <Maxdamantus> +
23:04:07 <solidus-1iver> jle`: so you have a wire that takes custom events for rednerEvent based on which backend is done, but this makes the whole game loop bouned by the output of render events correct?
23:04:34 <solidus-1iver> jle`: relly good blog post on Machines / AFRP
23:06:06 <jle`> solidus-1iver: thanks :)
23:06:11 <jle`> i'm not sure i understand your first statement
23:06:41 <solidus-1iver> i'm looking at your netwire examples repo
23:06:44 <jle`> oh
23:06:51 <jle`> hm let me see
23:06:54 <solidus-1iver> you have the game wire run based on renderEvents and leave it up to the backend to generate those
23:07:21 <solidus-1iver> so that means the backend completley determines framerate, correct? (i'm just making sure i'm understanding things right)
23:07:27 <gratimax> Hey, something I've always wondered. How does Haskell's operator parsing work? It seems (at least to me) that the information for operator precedence is available only after a parse tree is built. What magic is there?
23:07:37 * hackagebot tianbar 0.4.5.0 - A desktop bar based on WebKit  http://hackage.haskell.org/package/tianbar-0.4.5.0 (AlexeyKotlyarov)
23:07:38 <solidus-1iver> trying to look into how you do frame limiting
23:07:53 <jle`> solidus-1iver: i'm looking into the code so i can be sure we are using the same names for things
23:08:24 <jle`> okay, yes.  the game loop wire takes in Event RenderEvent
23:08:31 <jle`> which is provided by the backend
23:08:36 <jle`> when the backend runs it
23:08:47 <jle`> i'm looking at https://github.com/mstksg/netwire-experiments/blob/master/src/Render/Render.hs
23:08:59 <jle`> hm.
23:09:25 <jle`> what is the (a -> r)
23:10:40 <jle`> ah ok it's to provide generic rendering instructions for the wire output, a
23:11:11 <jle`> yeah, RenderEvent includes things like key presses and mouse movements
23:11:24 <jle`> each backend has to generate those and feed them into the wire
23:11:35 <jle`> https://github.com/mstksg/netwire-experiments/blob/master/src/Render/Backend/SDL.hs#L51-L59
23:12:23 <jle`> as for the framerate limiting
23:12:41 <jle`> it actually takes advantage of a fundamental concept of FRP
23:12:55 <jle`> your wire is supposed to behave identically no matter what dt you give it
23:14:21 <jle`> so if you feed it dt's of 0.1, 0.001, 0.2, and 0.999 ... at the end of it all, it should be identical to just feeding it 0.1, 0.1, 0.1 .. (13 times)
23:14:51 <jle`> basically you can sort of think of running the wire at "i want the state of the system at time = now + dt
23:15:13 <solidus-1iver> is there a way to tell a wire i only want you to run at most once every 1/60th of a second?
23:15:14 <jle`> where the semantics state that you can really do that for any dt, and it's like querying some underlying state that doesn't care about the discretization of time
23:15:55 <jle`> solidus-1iver: you do'nt tell the wire that
23:16:02 <jle`> that's the job of the backend
23:16:28 <jle`> you just want the backend to "ask"/run the wire no more than once every 1/60th of a second
23:17:22 <solidus-1iver> ah i see, k
23:17:36 <solidus-1iver> vero cool, a lot of the existing netwire tutorials aren't using wire's right it seems
23:17:43 <jle`> you can think of the wire giving you the ability to say, "okay, what is the state of the system at time t?"
23:17:59 <jle`> and so the backend's job is just to ask that question whenever it wants to
23:18:09 <MP2E> solidus-1iver: most netwire tutorials are old is the problem
23:18:11 <jle`> that's fundamental FRP, btw
23:18:24 <jle`> type Behavior b = Double -> b
23:18:35 <jle`> Wire is supposed to be sort of isomorphic to that concept
23:18:53 <jle`> so you can treat the wire as somethign where you can pass in any Double, and you'll get the state of the system at that time.
23:18:59 <jle`> it doesn't care about the size of your timestep
23:19:16 <jle`> "framerate" doesn't have any meaning in FRP semantics
23:19:39 <jle`> framerate happens when your backend finally "asks" at different t :: Double's.  and it can decide that t :: Double's it wants to ask
23:19:47 <jle`> are you familiar with vector vs raster graphics?
23:19:55 <jle`> (also, what netwire tutorials are these?)
23:21:01 <solidus-1iver> jle`: the stuff in netwire-examples i linked to earlier, they dont report themselves as workable examples
23:21:11 <jle`> heh
23:21:23 <jle`> there is also a lot of misunderstanding floating around about FRP
23:21:41 <solidus-1iver> aye, i am (vector / raster) i come from the graphics land of opengl
23:21:44 <jle`> a lot because of things like Elm
23:22:00 <solidus-1iver> for some reason i was expecting fram limiting somehow via signal inhibition using frp
23:22:02 <jle`> solidus-1iver: ok.  so in FRP, it's like you are working with vectors
23:22:08 <solidus-1iver> or signal analysis
23:22:10 <jle`> FRP is like vector graphics
23:22:21 <jle`> your backend is like something that renders vector graphics
23:22:47 <jle`> vector graphics have to eventually be rendered to be displayed...and when they are rendered, the render samples it or something
23:23:03 <jle`> vector graphics exist as ideal, continuous things
23:23:15 <jle`> but when they are displayed by a computer screen, they have to be sampled/turned into bitmaps
23:23:18 <jle`> to be displayed
23:23:50 <solidus-1iver> jle`: have you ever used elerea?
23:23:50 <jle`> so in FRP, things are continuous/"vector"...they can be zoomed, manipulated, infinitely stretched and restretched, skewed, etc. without losing any information or quality
23:24:15 <jle`> when you finally "render" the final signal, only then is when the discretization takes place
23:24:19 <kazagistar> so, your framerate is something like "infinity", and then you just pick out some of them at the end
23:24:30 <jle`> solidus-1iver: i haven't, but it looks interesting; i should probably check it out and see if it's real FRP
23:25:06 <solidus-1iver> jle`: elerea / netwire are the ones that stood out to me
23:25:07 <jle`> kazagistar: you can think of it that way, i guess..and vector graphics are like infinite resolution bitmaps?  it's not a perfect analogy
23:26:20 <solidus-1iver> guess im a little too used to workin in descreet space and forcing it to act like continuouse space
23:26:52 <jle`> yeah, FRP turns that on its head; the entire time you program, you are working in continuous space.
23:26:53 <kazagistar> yeah, infinity is an awkward thing to say "as arbitrarily large or small framerate as desired" is more like the idea probably
23:26:57 <jle`> continuous time
23:27:18 <jle`> infinitely scalable, compressible, etc. without losing information
23:28:11 <augur> hmm
23:28:21 <augur> i have a realy interesting structure here... hmm
23:29:05 <kazagistar> how does stuff like physics and collision work? the use of a discrete space seems to be in that it can make easier such problems where anything other then approximation is implausible
23:29:28 <jle`> solidus-1iver: elerea seems like a nice library/abstraction, but it is definitely *not* FRP as classically defined and understood
23:29:52 <jle`> but some people these days make the distinction between "classical" FRP and nueue FRP...which doesn't have much to do with the original FRP
23:30:01 <jle`> in terms of semantics
23:30:47 <augur> kazagistar: ive always wondered how to make a good model of FRP for physics
23:30:56 <solidus-1iver> jle`: why would you say its not "classical" frp
23:30:59 <jle`> kazagistar: well.  i don't know, i was actually going to make a physics engine in netwire my summer project
23:31:10 <jle`> solidus-1iver: because it doesn't have continuous-time semantics
23:32:24 <jle`> it does look like it has a well-defined semantic model --- which is a good step considering other libraries out there, but calling it FRP is what I would consider an abuse of the term
23:33:00 <solidus-1iver> ah, i see what your saying, its time varying values in __descrete__ time
23:33:28 <jle`> FRP as originally defined *is* the merger of two fundamental components
23:33:33 <jle`> 1) continuous time semantics
23:33:41 <jle`> 2) denotational style
23:33:50 <jle`> or denotational semantics
23:34:35 <jle`> that is, type Behavior b = Time -> b, and type Event b = [(Double, b)]
23:34:46 <kazagistar> I mean, a serious physics engine might have to deal with three body problems, collision events, etc... you would have to be very careful to make sure it does not become a hell of numerics or something
23:35:13 <jle`> kazagistar: well, remember, the implementation might be nitty gritty numeric and discrete
23:35:17 <jle`> but the interface must hide it all
23:35:35 <jle`> the composable, denotational interface/api must give the full, unbroken illusion of continuous time
23:36:28 <jle`> by unbroken illusion i mean that given a wire, you can't somehow manage to "extract" time step out of it
23:36:42 <jle`> by feeding it various timesteps and analyzing the results
23:37:09 <kazagistar> how does something like user input affect it? does it just change/recompute what the behavior is after the event when the user acts?
23:38:07 <jle`> in netwire, or in the semantic model?
23:38:19 <kazagistar> um, either I guess?
23:38:41 <jle`> the semantic model makes sense; hasPressed :: Event KeyPress -> Behavior Bool
23:38:59 <jle`> hasPressed [] t = False
23:39:14 <jle`> hasPressed (e1:_) t = t >= e1
23:39:36 <jle`> er, KeyPress ~ Double i guess
23:39:55 <jle`> so the Event KeyPress represents the event that the user presses a button
23:40:09 <jle`> and hasPressed keyPressEvent is a behavior that is False until the first time the user presses a button
23:40:31 <jle`> sorry, hasPressed ((_,te1):_) t = t >= te1
23:40:46 <jle`> because type Event b = [(Double, b)]
23:40:51 <jle`> ...i swapped the tuple, but you get the idea
23:41:32 <jle`> so that's how the semantic model handles such a behavior from such an event
23:42:36 <jle`> when i learned this from mm_freak, his strategy was "you write it yourself, and tell me the answer"
23:42:42 <jle`> haha
23:43:13 <MP2E> Hehe :P
23:43:14 <kazagistar> so if there are a thousand blocks, each has a trajectory (numeric or closed form of some kind), as well as maybe some kind of "next discrete event that will modify it" and a thunk that computes their path after that event. Each thunk that causes the possiblity of being rendered would have to be updated as the engine renders frames. Each time a user shoots a new block, it would invalidate the block which it would collide 
23:43:28 <kazagistar> something like that I guess
23:44:03 <jle`> by thunk do you mean function?
23:44:49 <MP2E> My only question here: Given you create a seperate wire to handle collision, and a wire to handle button pressing, how would you 'compose' the two to create a wire that does both of these things? By literal composition? :P
23:44:51 <kazagistar> jle`: no, I am pretty sure I meant thunk, as in "function that has all the arguments it needs but is not yet evaluated
23:45:22 <jle`> i'm not sure why not-yet-evaluated is important
23:45:56 <jle`> MP2E: in netwire, yes :) or using combinators. it depends on exactly what you want.
23:45:59 <kazagistar> jle`: because each block has an infinte number of potential bounce events in the future
23:46:48 <kazagistar> and any such non-trivial system is likely to be chaotic
23:47:09 <MP2E> kazagistar : is it any less chaotic to run imperative code that depends on state? :P
23:47:30 <kazagistar> MP2E: I meant chaotic in the actual mathematical sense in that case
23:47:53 <jle`> if you mean the semantic model, that would be implemented as a lazily evaluated list
23:48:11 <jle`> in netwire, you only have the current state ever in memory
23:48:21 <jle`> the current state of the world
23:48:30 <jle`> and a way to "update" it, to the next timestep
23:48:50 <jle`> so that update function, simply speaking, moves each particle to the future location, and handles collisions
23:49:01 <jle`> and it also takes into account user inputs to add or remove particles
23:49:06 <jle`> in the update process
23:49:10 <jle`> that's the implementation of netwire
23:49:19 <kazagistar> jle`: doesn't that mean that you DO have meaningful ways of observing timesteps, due to imprecision?
23:50:02 <jle`> due to imprecision, you will likely leak the timestep
23:50:05 <jle`> in the implementation
23:50:20 <kazagistar> gotcha, thats what I was confused about I think
23:50:35 <jle`> but that doesn't effect the semantic model of how things behave ideally, and how you "should" be vieweing the interface
23:50:38 <jle`> ah, yeah, i was oging to say that.
23:50:46 <jle`> i have an n-body simulation
23:50:50 <jle`> that does runge-kutta
23:50:56 <jle`> ...or was it verlet?
23:51:13 <jle`> in where it adapts to the timestep to make it not "supposed" to actually matter
23:51:25 <jle`> but of course if you use huge timesteps, the abstraction and timesteps will leak
23:51:38 <kazagistar> (I have heard runge-kutta, but I dropped my numerics course for other reasons (and really really should revisit it))
23:52:23 <jle`> this can be mitigated by having a max timestep and sort of...handling things behind the scene to try really really really hard to not let the timestep leak
23:52:39 <jle`> if you try hard enough you might get a perfect abstraction
23:52:42 <jle`> but that's not the "point"
23:52:46 <kazagistar> in a sufficiently complex chaotic system, you will always leak accuracy or time complexity I think
23:52:47 <jle`> heh. if that makes sense
23:53:04 <kazagistar> yeah, the point is the programming style and ideal, as opposed to the realities
23:53:07 <jle`> mhm
23:53:43 * jle` scrolls up
23:53:50 <jle`> i really need to stop using the enter key as punctuation
23:55:57 <kazagistar> due to the fact that you really only care about the illusion of continuity, it seems like you would want to simulate more or less accurately depending on player proximity or attention, for example, which I can see how it would be possible still (have multiple models that switch according to player proximity)
23:55:58 <jle`> actually the library i am writing is a lot like elerea but with arrows >_>
23:56:46 <jle`> i'm trying to define a semantic model for inherently discrete contexts
23:56:52 <jle`> like cellular automata and turn based games
23:57:05 <kazagistar> what I still need to think about is if it would work well with the style of networking that online games use, where there are clearly not any "true" models, and you just try to interpolate between the different ... approximations? of the world in a reasonable way
23:57:10 <jle`> kazagistar: that's a nice concept actually
23:57:41 <jle`> yes i was planning on using this summer to explore networking too in this context
23:57:54 <jle`> and how to abstract away the inherent discreteness of network communication
23:57:57 <jle`> :|
23:57:59 <jle`> i have too many summer projects
23:58:00 <MP2E> kazagistar: I believe it would. Many games have issues with things like interpolation, and often games use backwards reconciliation which means looking back on server state to determine future actions
23:58:14 <MP2E> I think functional programming, particularly functional reactive programming would be naturally conducive to this
23:58:35 <kazagistar> I assume you have read some of the background on how networking is done in industry? there was a really excellent paper about Halo 4 I think
23:58:38 <MP2E> I haven't done it yet though thus the 'think'
23:58:50 <jle`> the key is to have an extremely ugly implementation with a beautiful abstraction covering it up ^.^
23:58:54 <jle`> kazagistar: what's the paper? :)
23:58:56 <MP2E> Yeah I read the Halo 4 paper, I've read through Doom 3's source code and I contributed to 2 different classic Doom ports with client/server netcode
23:59:01 <MP2E> Online games are pretty interesting :D
23:59:28 * jle` . o O ( there's a halo 4? )
23:59:30 <kazagistar> lemme find the halo 4 paper
23:59:35 <kazagistar> or halo 3 or whatever it was
