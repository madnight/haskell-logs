00:00:23 <tar_> I have a daemon that connects to Twitter's streaming JSON API and sends e-mail alerts. It's written in Go, but I'd like to try writing it in Haskell. Could anyone point me at which libraries I'd want for this?
00:03:55 <zomg> tar_: perhaps aeson and http-conduit at least
00:05:14 <tar_> zomg: ah, this'll start me off. thanks.
00:43:00 <tar_> What happened to Data.Conduit.Binary (sinkFile)?
00:43:12 <tar_> !hoogle sinkFile
00:43:20 <tar_> > sinkFile
00:43:21 <lambdabot>  Not in scope: ‘sinkFile’
00:47:49 <chrisdone> tar_: i think it moved to conduit-extra
00:48:44 <tar_> chrisdone: ah, there it is! thanks.
00:49:24 <burz> Hey all, I was just wondering what "unexpected ()" meant in Parsec?
00:52:28 <levi> burz: Is that a runtime error you're seeing?
00:52:43 <burz> Yeah, it's the ParseError
00:53:50 <sgronblo> Is it possible to specify types for expressions in where?
00:54:05 <sgronblo> I'm getting some rigid type variable complaint
00:56:13 <levi> sgronblo: Yes, just have the type declaration be one of the where clauses
00:57:11 <levi> But if you have a rigid type variable complaint, it probably means you've done something non-parametric
00:58:38 <levi> burz: Is there a () in your input that your parser was not expecting?  I don't know enough about the guts of Parsec to make any solid guesses with the info you've given.
01:00:04 <sgronblo> levi: hmm, what would be an example of doing something non-parametric
01:01:58 <burz> levi: does this mean parenthesis? perhaps it's from the parens function failing from the lexer
01:02:13 <jamiehannaford> how can I stop iteration over an infinite list after it reaches a false?
01:02:39 <sgronblo> takeWhile?
01:03:14 <jamiehannaford> sgronblo yeah I thought that, but it doesn't stop
01:03:17 <jamiehannaford> takeWhile (\x -> x <= 4) $ filter (\x -> valExp 4 x) [0..]
01:03:30 <zwer> > takeWhile (<10) [1..]
01:03:31 <lambdabot>  [1,2,3,4,5,6,7,8,9]
01:03:50 <levi> sgronblo: Any operation that assumes some type for the parameter; e.g. a numeric operation or a comparison or something.
01:05:25 <sgronblo> levi: Hmm, I can't see any place where I would be doing that though.
01:05:34 <jamiehannaford> zwer it computes the numbers fine, but when it gets to the first false the cursor stays there and it hangs
01:05:44 <jamiehannaford> [0,1,2,3<cursor>
01:05:57 <jamiehannaford> let val n exp = (2*n) `mod` (2^exp) == 0
01:06:05 <jamiehannaford> takeWhile (<4) $ filter (valExp 4) [0..]
01:06:32 <jamiehannaford> sorry, I meant filter (val 4) [0..]
01:08:32 <zwer> jamiehannaford filter can't know when it has to stop
01:09:26 <zwer> > filter (<10) [1..]
01:09:30 <lambdabot>  mueval-core: Time limit exceeded
01:09:43 <jamiehannaford> zwer but it effectively stops after a certain number - although it's still applying it to the infinite list
01:09:47 <augur>  > [1..]
01:09:48 <levi> > take 4 $ filter (<10) [1..]
01:09:50 <lambdabot>  [1,2,3,4]
01:10:02 <levi> filter's recursion is guarded; that's not the problem.
01:10:06 <zwer> oh right, that should work
01:10:09 <augur>  > [1..]
01:10:16 <chrisdone> rather, filter doesn't know when to continue =p
01:10:26 <augur> boy, lambdabot seems to be choking on that one, huh
01:10:35 <chrisdone> weird
01:10:38 <jamiehannaford> doesn't `take 4` take the first 4? I want the highest element from a list where all elements are less than 4
01:10:43 <burz> levi: it wasn't parens, it may have something to do with the expression parser
01:10:59 <jamiehannaford> maximum $ takeWhile (<4)
01:11:17 <jamiehannaford> the takeWhile hangs on input provided from the filter, though
01:11:44 <sgronblo> http://lpaste.net/3419418146623193088 if anyone has time to improve my haskell skills
01:12:04 <levi> burz: Could be... sorry, I don't have enough info to guess.
01:12:29 <augur> sgronblo: the complaint about variables is because pairsAndRest is trying to use `a` from the type of `pairings`
01:13:00 <augur> sgronblo: but that type isn't "in scope", instead, the `a` in pairsAndRest is supposed to be universally quantified on pairsAndRest
01:13:32 <Cale> sgronblo: What is this function supposed to compute?
01:13:54 <Cale> sgronblo: All possible pairs of distinct elements from the original list?
01:14:13 <sgronblo> Cale: yeah
01:14:20 <sgronblo> augur: so what can I do?
01:15:37 <augur> sgronblo: try removing the type signature, see if that helps
01:15:38 <Cale> sgronblo: It's much easier to do this in terms of  select :: [a] -> [(a,[a])]; select [] = []; select (x:xs) = (x,xs) : [(y,x:ys) | (y,ys) <- select xs]
01:16:00 <sgronblo> Cale: yeah but thats not important right now
01:17:06 <sgronblo> I'm just trying to improve my haskell and learn to understand all these errors better
01:17:43 <sgronblo> augur: but then I wont be able to type what i expect the types for both expressions to be?
01:18:26 <augur> sgronblo: you might not need to give the type of that, is that point
01:19:06 <sgronblo> augur: but i want to specify the type so i can make sure that my definition matches that
01:19:45 <augur> then youll have to use scoped type variables
01:19:58 <augur> it should tell you what extension you need
01:21:05 <sgronblo> I need an extension for it?
01:23:23 <levi> If you want to use scoped type variables you do.
01:23:33 <sgronblo> The reason I wanted to provide a type for the where expression was that I get a type error for the cons part
01:23:48 <sgronblo> So I wanted to make sure that the type of pairsAndRest is correct
01:24:18 <sgronblo> I don't like that the type error stops at p:subPairing
01:24:33 <sgronblo> Well I guess the error must be p
01:24:47 <sgronblo> because you wouldnt cons to something that wasnt a list
01:25:08 <sgronblo> but how can p not be an (a, a)
01:28:00 <jamiehannaford> if I have an infinite list that stops after a certain number, like: [0,1,2  - how can I get those first numbers from it? takeWhile hangs because it's carrying on after the "2"
01:28:41 <sgronblo> how can it be infinite if it stops?
01:28:43 <Cale> jamiehannaford: take 3?
01:29:23 <kadoban> jamiehannaford: It's really not continuing, if you have the correct condition set. Your problem must be something else.
01:29:23 <Cale> jamiehannaford: Is there a particular condition where you can tell that you'll need to stop?
01:30:05 <Cale> Well, if your condition was something like takeWhile (<3), then it will get stuck of course
01:30:23 <jamiehannaford> let valExp n exp = (2*n) `mod` (2^exp) == 0 in filter (valExp n) [0..]
01:30:38 <Cale> > let valExp n exp = (2*n) `mod` (2^exp) == 0 in filter (valExp n) [0..]
01:30:40 * hemanth is having a tough time getting ghc-vis up and running on osx
01:30:42 <lambdabot>  mueval-core: Time limit exceeded
01:31:26 <jamiehannaford> so the result of the filter is [0,1,2,3 for "4"
01:31:28 <Cale> errr
01:31:34 <jamiehannaford> I'm basically trying to do the filter function
01:31:35 <Cale> > let valExp n exp = (2*n) `mod` (2^exp) == 0 in filter (valExp 3) [0..]
01:31:39 <lambdabot>  mueval-core: Time limit exceeded
01:31:51 <Cale> right
01:32:02 <Cale> > let valExp n exp = (2*n) `mod` (2^exp) == 0 in take 2 (filter (valExp 3) [0..])
01:32:03 <lambdabot>  [0,1]
01:32:11 <sgronblo> Cale: were you able to figure out why my suboptimal pairing code results in a type error?
01:32:29 <jamiehannaford> Cale you can't use "take" because different inputs have a different result count
01:32:43 <Cale> sgronblo: Because type variables are not scoped by default
01:32:46 <levi> hemanth: What version of ghc?
01:32:50 <jamiehannaford> 4 is [0,1,2,3 and 3 is [0,1
01:32:59 <sgronblo> Cale: not that type error
01:33:16 <sgronblo> the one where i try to cons
01:33:23 <anon_555> Guys this question might be little a bit unrelated but i want to work in missile automation and Airport security. Where can i make my career.
01:33:35 <Saizan> jamiehannaford: you've to use takeWhile from the start
01:34:01 <int-e> jamiehannaford: that sounds like you're solving a particular instance of the halting problem. you'll have to do the thinking (finding an upper bound on the value of the list elements, say) yourself
01:34:19 <hemanth> levi, Glasgow Haskell Compiler, Version 7.6.3, stage 2 booted by GHC version 7.4.2
01:34:33 <nschoe> I know it may not be the best channel to ask, but does anybody know why 'SublimeHaskell' doesn't appear in my package control install ?
01:34:41 <nschoe> (I'm using ST2)
01:34:48 <jamiehannaford> Saizan thanks! looks like that's the key :)
01:35:31 * int-e realizes this discussion has been going on for a while
01:35:33 <levi> hemanth: Well, I have recently got ghc-vis working with that version of ghc in Linux; what problem are you running into with OS X?
01:36:51 <hemanth> Could not find module `Data.Text.Lazy' levi, but I have fetched all the reps
01:37:26 <Cale> sgronblo: So p : subPairing :: [(a,a)]
01:37:34 <levi> sgronblo: The reason is all there in the error.
01:37:52 <int-e> > let valExp n exp = (2*n) `mod` (2^exp) == 0 in filter (valExp 3) [0..3-1]
01:37:53 <lambdabot>  [0,1]
01:37:57 <Cale> sgronblo: and so map (\subPairing -> p:subPairing) (...) :: [[(a,a)]]
01:38:32 <Cale> sgronblo: and then map (\(p,rest) -> ...) pairsAndRest :: [[[(a,a)]]]
01:38:57 <Cale> sgronblo: But from the type signature of your function, it's supposed to have type [[(a,a)]]
01:39:09 <Cale> So there's one additional layer of lists that shouldn't be there
01:39:33 <sgronblo> Ah I thought the error meant that the type of p was broken
01:39:40 <Cale> sgronblo: Also, just a style note, (firstElement:restElements) really isn't any clearer than (x:xs)
01:41:15 <Cale> When something has a small enough scope that all of its points of use are within sight of its point of binding, and especially if it's something structural like that, it's okay to give it a short variable name, I think.
01:42:16 <sgronblo> Yeah I had shorter names first
01:42:25 <Cale> My general rules of thumb are that variable names should get longer the larger the scope of the definition, and should be shorter the more frequently things get used
01:46:47 <levi> hemanth: How are you trying to build it?
01:46:52 <int-e> . o O ( maybe whatYouGetForNothing whatToDoWithJust theValueToConsidera = ... )
01:47:19 <dbushenko> is there any good tutorial for Parsec?
01:47:48 <kazagistar> are there any obvious ways that I could improve this code? http://lpaste.net/105585 the part with the maybe is especially ugly I think :/
01:47:59 <hemanth> levi cabal
01:52:22 <hemanth> levi http://pastebin.com/ttC889Kq
01:54:08 <hemanth> ^ for cabal update && cabal install gtk2hs-buildtools && cabal install ghc-vis --disable-library-profiling
01:57:38 <levi> hemanth: I don't see anything about Data.Text.Lazy there; where'd that error come from?
01:57:46 <lintguy> Hello.
01:58:23 <hemanth> levi that got fixed, after I did a sudo!!
01:59:06 <hemanth> re-trying again, it's saying Linking dist/setup-wrapper/setup ...
01:59:12 <levi> hemanth: Ah, ok.  Well, the problem now may just be related to building Cairo.
01:59:34 <hemanth> Looks, like...now it's Configuring cairo-0.12.5.3...
01:59:40 <lintguy> I'm checking around different programming languages to find one that is suitable for making API connections and sending data between two API's using REST and WSDL. Would Haskell be suitable for this, does tools exist for it or does it need to be written from scratch?
02:00:17 <levi> sgronblo: I got it to run by doing a concatMap rather than a map, though I am not sure whether it's doing what you wanted it to.
02:00:51 <lintguy> The project in question is already written in PHP, but the performance is subpar. I'm standing between node.js port or haskell port, although i know nothing about functional programming!
02:01:21 <levi> lintguy: There are libraries for http, streaming, and XML. I don't know about WSDL, though.
02:01:38 <lintguy> levi: is there a directory where i can search for such libraries?
02:02:09 <levi> If you don't know haskell, that's a pretty big yak to shave.
02:02:12 <levi> lintguy: hackage
02:03:24 <lintguy> there seems to be a few SOAP libraries
02:04:16 <lintguy> but yeah… it seems i would need to write quite a lot of extra support
02:04:29 <lintguy> supporting WSDL 2.0 is not easy, i already added support for it in the PHP project
02:05:00 <levi> kazagistar: What's wrong with the maybe bit?
02:05:10 <hemanth> levi still the same Failed to install glib-0.12.5.4 :|
02:05:33 <lintguy> seems haskell is a small community?
02:05:44 <levi> hemanth: I don't really have any experience with gtk stuff on OS X. I understand it's not the easiest thing to get working there.
02:06:00 <hemanth> hmm
02:06:05 <kazagistar> levi: it is not very clear what the code is doing from a brief reading
02:06:18 <levi> lintguy: The community that uses haskell and the community that uses SOAP don't have a very large intersection, I think.
02:06:23 <sgronblo> Cale: thanks, indeed i had one level of lists too much
02:06:31 <hemanth> any online ghc-vis?
02:06:37 <sgronblo> levi: yeah concatMap was the answer to the problem
02:07:20 <lintguy> levi: seems true, but i managed to find a wsdl2hs converter that a guy made
02:07:22 <hemanth> levi I would appreciate your feedback on https://github.com/hemanth/haskell-rascal/ :)
02:07:56 <lintguy> without knowing soap spec in detail, i think it would take more than a year for a single developer to port this project
02:08:14 <lintguy> so i guess i'll have to find other options
02:08:34 <levi> I used ghc-vis in a presentation on functional data structures. Everyone thought it was pretty cool.
02:08:46 <lintguy> hiphopvm may be an solution
02:09:34 <lintguy> levi: thanks for the link to hackage
02:09:54 <levi> There are plenty of good reasons to learn haskell, but I'm not sure that replacing a PHP SOAP widget is one of them.
02:10:59 <hemanth> PHP?!
02:11:48 <ion> SOAP?!
02:12:55 <zomg> There's only one word missing from this conversation to form the unholy trinity
02:12:58 <zomg> Enterprise
02:12:59 <zomg> ;>
02:13:13 <hemanth> :D
02:13:49 <levi> I can't imagine there would be much enthusiasm in the haskell community for maintaining SOAP stuff, especially since the web development community has largely come to their collective senses about it.
02:17:30 <Rembane> Why not build it in Java instead? That's where SOAP belongs.
02:18:42 <kazagistar> SOAP can't be *that* complicated to maintain, right? :P
02:18:53 <johnw> hahahaahahahah
02:19:12 <johnw> SOAP is ironic in how dirty it can make you feel
02:20:30 <ion> @google soap the s stands for simple
02:20:35 <lambdabot> http://wanderingbarque.com/nonintersecting/2006/11/15/the-s-stands-for-simple/
02:20:35 <lambdabot> Title: Pete Lacey’s Weblog : The S stands for Simple
02:23:28 <kazagistar> "(Reads XML Schema spec). Saints preserve us! Alexander the Great couldn’t unravel that."
02:24:02 <kazagistar> it all comes back to XML schemas being a clusterfuck in the end...
02:25:42 * hemanth : the happiness after understanding thunks! :)
02:28:15 <zomg> I remember when people were arguing that XSLT was the best way to do templating for web apps
02:28:17 <levi> API design, and protocol design in general, is hard. Too many people engage in it who have no business doing so.
02:28:27 <johnw> zomg: remember DSSSL?
02:28:48 <vanila> and isn't t?
02:28:50 <vanila> it*
02:28:51 <zomg> Never heard of, but looking it up I'm glad
02:28:52 <zomg> :D
02:28:58 <levi> But DSSSL was scheme!
02:29:22 <zomg> > DSSSL was thought to be too complex for the World Wide Web, and the World Wide Web Consortium thought about creating a DSSSL-Lite.
02:29:23 <lambdabot>  <hint>:1:59: parse error on input ‘,’
02:29:25 <zomg> hue hue
02:29:37 <levi> If I'm going to write a document-rewriting program, I'd sure pick scheme to do it over some XML-based monstrosity.
02:30:16 <zomg> tbh it sounds about as equally good as all the other web-related things
02:30:54 <zomg> because HTML was not designed with CSS in mind, and neither was DOM, it's all just a bit of a clusterfuck now
02:30:57 <zomg> :P
02:31:27 <kazagistar> zomg: how would html look if it was designed with CSS in mind?
02:32:22 <zomg> Well, for one, vertical centering wouldn't be the completely insane thing it is now
02:32:39 <vanila> HTML5 can vertical center easily
02:33:05 <zomg> Oh?
02:33:13 <kazagistar> everything is a div, it is implict, and the "class" attribute is where the tag name was :P
02:34:01 <vanila> http://philipwalton.github.io/solved-by-flexbox/demos/vertical-centering/
02:34:46 <kazagistar> <h1 class="intro"> stuff </h1>  =>  <h1 intro> stuff </>
02:35:05 <zomg> vanila: true
02:35:30 <zomg> I always forget about flexbox because as with all the newer CSS things it's a bit of a gamble to use any of it :P
02:35:56 <xpika> is there a common function for (a->b) -> (a,a) -> (b,b) ?
02:36:56 <levi> Here's a DSSSL cookbook: http://www.mulberrytech.com/dsssl/dsssldoc/cookbook/cookbook.html
02:37:41 <levi> xpika: Did you try searching Hoogle?
02:38:02 <vanila> :t join (&&&) :: (a->b) -> (a,a) -> (b,b)
02:38:03 <lambdabot>     Couldn't match type ‘a1’ with ‘(a1, a1)’
02:38:04 <lambdabot>       ‘a1’ is a rigid type variable bound by
02:38:04 <lambdabot>            an expression type signature: (a1 -> b1) -> (a1, a1) -> (b1, b1)
02:39:04 <kazagistar> xpika: tuples are generally used for heterogenus data, so such a use case is somewhat unusual
02:39:16 <xpika> kazagistar: sorry
02:40:33 <xpika> levi: yes
02:40:49 <kazagistar> xpika: what are you using it for? maybe we can find a better solution
02:43:20 <kazagistar> xpika: I mean writing your own is simple enough, but it might be that we could select better types for your use case
02:43:33 <kazagistar> :t \f (a, b) -> (f a, f b)
02:43:34 <lambdabot> (t -> t1) -> (t, t) -> (t1, t1)
02:45:59 <kazagistar> :t on (,)
02:45:59 <lambdabot> (a -> b) -> a -> a -> (b, b)
02:46:10 <xpika> > (\f (x,y)->(f x,f y)) sum (splitAt 3 [1,2,3,4,5])
02:46:12 <lambdabot>  (6,9)
02:46:12 <kazagistar> woot, I found the simplest one :D
02:46:38 <kazagistar> kinda
02:48:11 <xpika> kazagistar: i think there are some missing parens in that signature
02:48:19 <kazagistar> :t uncurry . on (,)
02:48:20 <lambdabot> (b -> b1) -> (b, b) -> (b1, b1)
02:49:04 <zwer> it would be cool if hoogle could also try to compose functions if none of them matched the signature
02:49:21 <kazagistar> zwer: apparently there has been research into that sort of thing
02:52:25 <kazagistar> @djinn (a -> b) -> (a,a) -> (b,b)
02:52:25 <lambdabot> f a (b, _) = (a b, a b)
02:52:57 <xpika> kazagistar: djinn got it wrong
02:53:06 <kazagistar> aaaaand that is why we write it by hand
02:53:29 <Saizan> :t join (***)
02:53:30 <lambdabot> Arrow a => a b c -> a (b, b) (c, c)
02:53:57 <kazagistar> djinn got the types write, the types were just insufficient to uniquely specify the semantics you wanted
02:54:09 <tar_> how do you use decodeUtf8 from pipes-text? I have a ByteString Producer that I want to use with pipes' unlines
02:55:44 <Cale> tar_: http://hackage.haskell.org/package/pipes-text-0.0.0.11/docs/Pipes-Text-Encoding.html looks useful
02:56:17 <tar_> sure does! over my head, though, it seems. I've been trying to piece this together from the docs for half an hour.
02:58:27 <tar_> It seems like decodeUtf8 is supposed to take a producer, and it returns some kind of a producer, but I don't know what to do with that producer it makes.
02:58:37 <Cale> So, decodeUtf8 from that module seems to turn a Producer ByteString m r into a Producer Text m (...)
02:58:44 <kazagistar> @djinn [Int] -> Text
02:58:44 <lambdabot> Error: Undefined type []
02:59:08 <Cale> tar_: Well, you probably want to connect that producer to whatever the rest of your pipes computation is
02:59:23 <Cale> tar_: Are you using pipes for a reason?
02:59:42 <Cale> Or are you just trying to convert UTF 8 encoded ByteStrings into Text?
03:00:37 <tar_> Cale: like runEffect $ (PTE.decodeUtf8 $ responseBody resp) >-> stdoutLn2    (where stdoutLn2 :: Consumer T.Text IO ()) ?
03:00:52 <tar_> I'm streaming some JSON over HTTP with pipes-http
03:00:52 <Cale> Yeah, try that
03:01:35 <tar_> Cale: I haven't been able to understand the error yet. http://pastie.org/9289271
03:01:54 <Cale> oh, I see
03:02:23 <Cale> tar_: You just need to ignore the result of the runEffect
03:02:43 <Cale> So, like, do runEffect ...; return ()
03:02:52 <xpika> @pl (\f g-> g f f)
03:02:52 <lambdabot> flip =<< flip id
03:04:39 <tar_> Cale: I still get an error when I do that. some more context might help: http://pastie.org/9289279
03:06:29 <Cale> Oh, right, >-> requires the result type of both its arguments to be equal
03:07:26 <Cale> So, maybe try applying  fmap (const ())  to the result of decodeUtf8
03:08:02 <Cale> runEffect $ (fmap (const ()) . PTE.decodeUtf8 $ responseBody resp) >-> stdoutLn2
03:08:16 <Cale> Does that work?
03:09:03 <Tjr> :i Empty
03:09:09 <Cale> I don't know what the type of stdoutLn2 is
03:09:09 <Tjr> @i Empty
03:09:09 <lambdabot> Maybe you meant: id ignore index instances instances-importing irc-connect irc-password v @ ? .
03:09:19 <Tjr> >:i Empty
03:09:39 <Tjr> What's up with the "Empty" bytestring?
03:09:52 <Cale> Tjr: hm?
03:09:55 <Tjr> LYAH says it should exist, but my ghci claims there is no such thing.
03:09:59 <jamiehannaford> can you use wheres in instances?
03:10:10 <Tjr> ghci> B.pack [99,97,110]
03:10:10 <Cale> > BS.empty
03:10:10 <Tjr> Chunk "can" Empty
03:10:11 <lambdabot>  ""
03:10:13 <tar_> Cale: that does compile! I'm not sure why yet, but I have some functions to look up now
03:10:24 <Tjr> However, I get something differnent: "can"
03:10:24 <Cale> jamiehannaford: yes
03:10:49 <Cale> Tjr: Oh, you're talking about the internals of lazy bytestrings?
03:11:06 <Tjr> I'm wondering why LYAH does something that my ghci doesn't
03:11:27 <Tjr> > pack [99,97,110]
03:11:28 <lambdabot>  Not in scope: ‘pack’
03:11:28 <lambdabot>  Perhaps you meant one of these:
03:11:28 <lambdabot>    ‘BS.pack’ (imported from Data.ByteString),
03:11:28 <lambdabot>    ‘BSL.pack’ (imported from Data.ByteString.Lazy),
03:11:28 <lambdabot>    ‘BSLC.pack’ (imported from Data.ByteString.Lazy.Char8)
03:11:36 <Cale> Tjr: What part of LYAH is this?
03:11:43 <Tjr> > BSL.pack [99,97,110]
03:11:44 <lambdabot>  "can"
03:11:49 <tar_> Cale: thank you
03:11:57 <Tjr> http://learnyouahaskell.com/input-and-output
03:12:22 <Cale> tar_: No problem. fmap f x applies a function f to the result of the computation x.
03:12:42 <Cale> tar_: We just wanted to discard the resulting Producer (I'm not even sure what that result is)
03:12:44 <Tjr> right where "The function pack has the type"...
03:12:51 <Cale> tar_: So, I applied const () to it
03:13:02 <Tjr> Cale:  ^^
03:13:42 <xpika> Saizan: thanks
03:13:50 <Tjr> > BSL.pack [99,97,110]
03:13:51 <lambdabot>  "can"
03:13:57 <Cale> Tjr: ah, apparently LYAH was written when the show instance for lazy ByteStrings was different
03:14:13 <Cale> Tjr: Chunk and Empty were never an exposed part of the interface
03:14:25 <Tjr> Cale: so I can forget about Empty?
03:14:37 <Cale> Tjr: Well, more or less.
03:14:42 <Tjr> Cale: ok, thank you
03:15:17 <Cale> Tjr: If you want to understand how lazy bytestrings work internally, they're pretty much like lists of strict bytestrings, where instead of (:), you have Chunk, and instead of [], you have Empty
03:15:30 <Cale> But Chunk and Empty aren't exported, so you can't fiddle around with the chunks
03:15:34 <Tjr> ok
03:15:47 <Cale> data ByteString = Empty | Chunk {-# UNPACK #-} !S.ByteString ByteString
03:16:14 <Tjr> and I guess a strict bytestring works internally just like a list, except it has an extra "seq" wrapped around every stage of the construction?
03:16:27 <Cale> No, it's more low-level
03:16:42 <Cale> Strict bytestrings are allocated contiguous arrays of bytes
03:17:03 <Cale> data ByteString = PS {-# UNPACK #-} !(ForeignPtr Word8) -- payload
03:17:03 <Cale>                      {-# UNPACK #-} !Int                -- offset
03:17:03 <Cale>                      {-# UNPACK #-} !Int                -- length
03:17:28 <Cale> Ah, right
03:17:38 <Adeon> what's a ForeignPtr inside
03:17:53 <tar_> Cale: ah! thank you. I think the ByteString was for error-handling when it's not valid UTF-8... or something
03:17:59 <luite> Adeon: it's a pointer that can have finalizers associated with it
03:18:05 <Adeon> that much I know
03:18:35 <Cale> data ForeignPtr a = ForeignPtr Addr# ForeignPtrContents
03:18:35 <Cale>                     deriving Typeable
03:19:01 <Cale> data ForeignPtrContents
03:19:01 <Cale>   = PlainForeignPtr !(IORef Finalizers)
03:19:02 <Cale>   | MallocPtr      (MutableByteArray# RealWorld) !(IORef Finalizers)
03:19:02 <Cale>   | PlainPtr       (MutableByteArray# RealWorld)
03:19:02 <Adeon> thanks
03:19:18 <lewis1> quit
03:19:20 <Cale> Basically, a pointer together with information about finalizers to be run when that pointer is GC'ed
03:19:51 <Adeon> I've sometimes thought if withForeignPtr has any overhead associated with it
03:20:03 <Adeon> not that it would have ever mattered in any of my programs
03:20:34 <Adeon> but if it's unpacked then I suppose that Addr# is right there
03:20:35 <Cale> Note: there's an offset field in ByteString as well, which lets it do slicing a bit more efficiently.
03:21:08 <Cale> e.g. when you apply drop to some ByteString, it'll be able to just change the offset
03:21:29 <robbins> I have a quick question - does anyone know where I can find the inheritance of different type classes (eg: to be part of Ord, the type has to be part of Eq)
03:21:38 <Cale> tail :: ByteString -> ByteString
03:21:38 <Cale> tail (PS p s l)
03:21:38 <Cale>     | l <= 0    = errorEmptyList "tail"
03:21:38 <Cale>     | otherwise = PS p (s+1) (l-1)
03:22:00 <Cale> robbins: Well, there's a handy little diagram for the standard ones in the Report...
03:22:12 <robbins> Cale: Haskell 2010 report?
03:22:24 <Cale> http://www.haskell.org/onlinereport/basic.html#standard-classes
03:22:46 <Cale> oh, right, I should have linked the H2010 report :)
03:22:55 <Cale> I still have H98 links in my bookmarks :)
03:23:18 <robbins> Cale: That's great, thanks. I'm finding it a bit difficult to get my head around type classes.
03:23:24 <Cale> lol, the one in the H2010 report is just a blurrier version
03:23:28 <Cale> http://www.haskell.org/onlinereport/haskell2010/haskellch6.html#x13-1270006.3
03:24:03 <Cale> (probably looks fine in the PDF still)
03:24:10 <jcullen> hey all.  I've got a question about modelling an event system in haskell and I'm not sure how to set up the types
03:24:39 <jcullen> I want to allow listners to subscribe to listen for an event
03:24:52 <jcullen> by supplying a "callback" function as well
03:25:13 <robbins> Cale: Thanks for your help, LYAH only mentioned a few sentences on, and didn't have a clear diagram.
03:25:17 <jcullen> but I want the callback to take parameters that depends on the event type subscribed to, because the parameters passed will have to vary based on the event type
03:25:32 <Cale> robbins: You can also get information about particular classes from GHCi by using :i ClassName
03:26:05 <Cale> robbins: It'll show you an abridged definition of the class, along with all the instances which are in scope
03:26:36 <Cale> jcullen: Maybe look at what Gtk2Hs does here?
03:27:08 <jcullen> I'll check it out
03:27:15 <jcullen> seems like it should be a fairly common issue though
03:27:29 <Cale> on :: object -> Signal object callback -> callback -> IO (ConnectId object)
03:27:54 <jcullen> its for a game
03:28:03 <jcullen> so for instance the events are like DamageToPlayer
03:28:15 <jcullen> which would need a callback that takes the player damaged and the amount
03:28:23 <jcullen> or PlayerDeath
03:28:29 <jcullen> which would need a different set of parameters
03:29:35 <zomg> simplest way to do that might be to just have data Event = Damage DamageInfo | Death DeathInfo ...
03:30:41 <jcullen> ahh yeah I think I see
03:30:54 <jcullen> then just have subscribe :: Event -> EventDispatcher -> EventDispatcher
03:31:09 <Cale> jcullen: Well, I think I'd have to know a lot about the rest of the design of your game to say what's right, but usually if you're producing a value, the parameters to the function which produces that value can be anything.
03:31:41 <Cale> Oh!
03:31:46 <jcullen> I think I've got an idea acually
03:31:52 <Cale> Another in-between option would be to use a GADT
03:32:11 <jcullen> I think my solution will work but I'm curious what you're thinking
03:32:41 <Cale> data EventType a where Damage :: EventType (DamageInfo -> IO ()); ...
03:33:06 <Cale> Then you have  subscribe :: EventType a -> a -> IO ()
03:34:13 <Cale> The idea being to put the type of the callback into the type parameter for the event
03:34:17 <jcullen> yeah I see
03:34:25 <jcullen> that seems like it could work too
03:34:27 <jcullen> hmm..
03:35:33 <jcullen> I was thinking to just supply the callback
03:35:45 <jcullen> and have the subscribe function map from the domain of the callback
03:35:50 <jcullen> to the type of event to subscribe it to
03:36:22 <jcullen> so subscribe would be subscribe subscribe :: (EventDetails -> IO ()) -> EventDispatcher
03:36:37 <jcullen> and then have another function EventDetails -> EventType
03:36:56 <Cale> I'll bet if you start writing the code which actually fires the events, it'll become clearer what the subscribe should look like.
03:42:15 * hemanth seeks some feedback on -> http://h3manth.com/new/blog/2014/thunks-in-haskell/ :)
03:48:02 <dottedmag> TIL :print
03:48:04 <dottedmag> hemanth: thank you
03:48:56 <hemanth> :)
03:56:52 * hackagebot yesod-text-markdown 0.1.2 - Yesod support for Text.Markdown.  http://hackage.haskell.org/package/yesod-text-markdown-0.1.2 (ArashRouhani)
04:12:34 <tulcod> i'm writing bindings, and i want to create some C strings which i want to keep around for the duration of the execution. should i just use newCString, or is there a neat way to clean up at the end of execution?
04:13:17 <tulcod> like, it's just a bunch of constant strings
04:14:14 <int-e> tulcod: there are withCString and withCStringLen in Foreign.C.
04:14:42 <tulcod> well yes, but i just want to make a store of constant strings
04:15:02 <int-e> hmm, what do you mean by "the end of execution"?
04:15:31 <tulcod> i need to store some constant c strings for the c library to use
04:15:34 <tulcod> their addresses can't change
04:15:48 <tulcod> and it's only like 30 short strings
04:16:16 <tulcod> so only when the program terminates do i want to clean up the memory used by them
04:16:37 <int-e> so you don't have to clean them up.
04:16:53 <tulcod> well yeah, but technically that would be a memory leak, right?
04:17:12 <int-e> newCString seems to be the way to go to me then
04:17:53 <tulcod> so can i clean up that stuff at program termination time?
04:19:44 <int-e> Not easily, I think, which means you should not bother since the memory allocated by the application is reclaimed by the OS anyway (the address space ceases to exist).
04:20:14 <tulcod> okay, thanks
04:26:11 <matematikaadit> :t log
04:26:12 <lambdabot> Floating a => a -> a
04:26:20 <matematikaadit> > log 2
04:26:21 <lambdabot>  0.6931471805599453
04:46:43 <dottedmag> Does valgrind produce any meaningful results for programs compiled by ghc?
04:47:39 <dottedmag> tulcod: ^^ valgrind'ing is probably the only way to see that your strings are leaked, so don't worry.
04:48:07 <tulcod> dottedmag: yeah, not worried, just wonedring if there was a pretty solution
04:48:17 <Cale> dottedmag: I can't really imagine that it would, if your program is 100% Haskell code, and you're not messing around at a low level
04:49:12 <Cale> GHC has a lot of that sort of thing built in though
04:49:36 <Cale> Ah, I missed tulcod's context
04:51:30 <dottedmag> Cale: I have heard some unprintable noises from the direction of people trying to use Valgrind to debug memory leaks in Go C extension, so I was interested in how GHC behaves.
04:51:54 <Cale> You'd probably much rather use GHC's heap profiler
04:52:02 <dottedmag> For C code as well?
04:53:05 <Cale> I forget how foreign objects show up (or if they do) in heap profiles. They probably don't.
04:53:21 <dottedmag> docs say so too
04:53:32 <darthdeus> is there a safe version of !! that's  Int -> [a] -> Maybe a ? hoogle doesn't find one :(
04:55:58 <Cale> There's atMay in the safe package
04:56:35 <darthdeus> thanks :)
04:57:17 <Cale> > let at n = fmap snd . find ((== n) . fst) . zip [0..] in at 4 "hello"
04:57:19 <lambdabot>  Just 'o'
04:57:21 <Cale> > let at n = fmap snd . find ((== n) . fst) . zip [0..] in at 5 "hello"
04:57:24 <lambdabot>  Nothing
04:57:27 <dottedmag> :t atMay
04:57:28 <lambdabot> Not in scope: ‘atMay’
04:57:44 <Cale> ^^ I'd probably just do something like that
04:58:12 <Cale> (But if you need stuff like that a lot, importing Safe is perhaps more convenient)
04:58:29 <Cale> Using anything along the lines of !! is usually a sign you're using the wrong data structure in the first place
04:59:09 <hemanth> what's the easy way to check process.uid?
04:59:22 <darthdeus> hmm, yeah importing safe is probably better for me at this point
04:59:44 <slroberts> at n = listToMaybe . drop n  ?
05:00:10 <Cale> hemanth: What do you mean by that?
05:00:25 <darthdeus> also guys, for anyone using interactive mode of haskell-mode in emacs, is there a way to tell it to not display errors in REPL in another buffer split, but rather inline?  for example if i type something that doesn't exist and hit enter, it opens a split and displays the error there
05:00:32 <Cale> slroberts: Ah, yeah, that's a decent way
05:02:01 <hemanth> Cale, if the current user sudo privilege or not
05:02:13 <dottedmag> sudo?
05:02:24 <Cale> http://www.haskell.org/ghc/docs/latest/html/libraries/unix-2.7.0.1/System-Posix-User.html
05:03:02 <hemanth> dottedmag, root privilage
05:03:50 <hemanth> Cale, how do I invoke it? new to this, noted that there is getProcessID method in it.
05:04:12 <Cale> you probably want getRealUserID
05:04:20 <dottedmag> hemanth: technically one also need to check for capabilities (for Linux), but getRealUserID should be fine as well
05:05:02 <knappador> Is there anything wrong with passing an entire program state in circles (recursively) and doing GUI updates in a monad?  Stack doesn't grow to the moon?  GC implementation means that program state is mostly zero-copy and free to pass in circles?
05:05:25 <Cale> knappador: There is no call stack
05:05:50 <knappador> Cale:   because it's laaazy?
05:06:07 <Cale> Yeah, lazy evaluation is outermost-first
05:06:16 <knappador> But strictly speaking, never returning doesn't imply some perpetual memory leak?
05:06:27 <Cale> right, it doesn't
05:06:33 <Cale> It's just a loop
05:06:40 <knappador> And the program state mutations will still be pretty much zero-copy?
05:06:54 <Cale> What you do have to watch out for is building up large unevaluated expressions in your function parameters
05:07:33 <hemanth> import System.Posix.User
05:07:33 <hemanth> uid <- getRealUserID
05:08:04 <Cale> Which might blow the stack that's essentially used to hold case expressions waiting for their scrutinee to be evaluated enough to match
05:09:41 <knappador> Cale so there are ways to trick the runtime into exploding, but there are probably patterns that preclude this possibility in addition to just making nice code?
05:10:03 <hemanth> let isRoot = uid <- getRealUserID == 0; is there a way to that something like that in one line?
05:10:12 <knappador> Is the style I'm talking about related to FRP in any way?
05:10:35 <Cale> knappador: Yeah, just make sure that things are either being pattern matched on, or their evaluation is being forced as they're accumulated
05:13:35 <Cale> knappador: FRP is something more sophisticated (and a bit nebulous, it's a related set of ideas for the design of libraries where the relationships between inputs, bits of program state, and outputs are expressed more declaratively, and the library manages keeping everything up to date)
05:14:11 <Cale> hemanth: That's not valid syntax
05:14:37 <hemanth> yup, so the valid syntax is?
05:14:41 <knappador> Life is going to be so nice.  All this stuff I used to have to know so intimately about the machine.
05:14:46 <Cale> hemanth: You presumably want something like  main = do isRoot <- fmap (== 0) getRealUserID; ...
05:14:55 <nschoe> How can I write a function's signature on several lines, like in many packages documentation ?
05:15:21 <Cale> hemanth: Or in two lines:  main = do uid <- getRealUserID; let isRoot = uid == 0; ...
05:15:25 <ion> foo :: Bar
05:15:29 <nschoe> I tried myFunc :: Bool
05:15:29 <nschoe>                     -> Maybe String
05:15:29 <nschoe>                     -> IO ByteString but I got parse error on '->'
05:15:30 <ion>     -> Baz
05:15:35 <ion> is what i tend to do
05:15:37 <hemanth> ha, fmap, neat. Thanks Cale
05:15:52 <ion> nschoe: Please pastebin your code and the error.
05:16:14 <nschoe> ion, yes sorry
05:17:25 <pjdelport> nschoe: That should work fine, as long as the -> bits are indentend.
05:17:25 <nschoe> Here it is : http://lpaste.net/105589
05:17:58 <rwbarton> --^ is not a comment
05:18:13 <Cale> --^ is an operator symbol
05:18:26 <nschoe> ah !
05:18:28 <pjdelport> nschoe: Ah, yes, you probably mean "-- ^" (with a space)
05:18:34 <nschoe> Thanks
05:18:45 <nschoe> yeah of course. did not know the space was relevant
05:19:34 <nschoe> thank you.
05:19:57 <Cale> A comment starts with two or more dashes followed by any non-symbol character
05:20:01 <Cale> :)
05:21:01 <jamiehannaford> "right folds work on infinite lists, whereas left ones don't" <- why is that?
05:21:30 <nschoe> Cale, okay thanks, will remember it, this time ^^
05:22:18 <slroberts> right folds *may* work on infinite lists, depending on how they are defined
05:22:39 <hpc> jamiehannaford: a fold transforms something like 1:2:3:[] into 1 - 2 - 3 - 0 (using minus because it's not commutative)
05:22:54 <pjdelport> jamiehannaford: The diagram here may help: https://en.wikipedia.org/wiki/Fold_(higher-order_function)#Folds_as_structural_transformations
05:23:09 <hpc> a right fold will transform the list into 1 - (2 - (3 - 0)) -- ie, the outermost operation in the result is the start of the list
05:23:20 <slroberts> a right fold which sums the elements in a list, for instance, cannot magically work on an infinite list
05:23:26 <hpc> a left fold is the opposite, ((1 - 2) - 3) - 0)
05:23:35 <hpc> outermost operation is at the end of the list
05:24:01 <pjdelport> jamiehannaford: With eager ("inside-out") evaluation, foldl starts evaluating from the beginning of the list, and evaluates the end last.
05:24:08 <hpc> when you go to evaluate the result of a right fold, suppose instead of (-) we used const, and instead of [1,2,3] used an infinite list
05:24:23 <hpc> const 1 (...)
05:24:32 <hpc> that (...) doesn't get evaluated and we just get 1
05:24:38 <pjdelport> jamiehannaford: With non-strict ("outside-in") evaluation, the dependency is the other way around.
05:24:53 <pjdelport> (This is a hand-wavey way of explaining it, but that's the essense of it.)
05:25:10 <hpc> if we did something similar with a left fold, we'd end up scanning the whole infinite list to get to the end
05:25:11 <cloudhead> is there any reason I shouldn't use 'forever' in a stateT?
05:25:26 <pjdelport> jamiehannaford: With foldr, it's just swapped.
05:25:55 <hpc> cloudhead: it's not necessarily bad - depends on how you use it
05:26:14 <cloudhead> hpc, basically instead of a tail call
05:26:34 <hpc> for instance, if you are running some kind of server you might have forever wrapping up a StateT ServerState IO () action
05:26:42 <hpc> @src forever
05:26:42 <lambdabot> Source not found. This mission is too important for me to allow you to jeopardize it.
05:26:50 <hpc> forever m = m >> forever m
05:27:04 <hpc> it's exactly the same as a tail call, feel free to use it
05:27:14 <cloudhead> interesting, cheers
05:27:21 <jamiehannaford> just to consolidate - why is computing the outermost operation first more efficient?
05:27:24 <hpc> (or rather, what you are thinking as a tail call - that term is somewhat perilous to use in haskell)
05:27:44 <cloudhead> yes : )
05:27:44 <jamiehannaford> because it allows you to short-circuit and not go on to the whole list?
05:28:02 <pjdelport> jamiehannaford: It's not intrinsically more or less efficient, but it's required to be non-strict, like Haskell is defined to be.
05:28:20 <jamiehannaford> what do you mean by non-strict?
05:28:48 <pjdelport> jamiehannaford: Basically, nothing gets evaluated unless its value is required by something else.
05:29:09 <pjdelport> jamiehannaford: http://www.haskell.org/haskellwiki/Lazy_vs._non-strict and http://www.haskell.org/haskellwiki/Non-strict_semantics talk about it more.
05:30:01 <pjdelport> > fst (5, undefined)
05:30:03 <lambdabot>  5
05:30:06 <rwbarton> a left fold could short-circuit too, if when you apply the operation to [the fold of the rest of the list] and the last element, it doesn't need that first argument. the difference is you have to get to the last element before you can do anything
05:30:15 <pjdelport> jamiehannaford: Non-strict evaluation means you can say something like the above in Haskell without an error.
05:30:51 <pjdelport> (The "undefined" can be anything that fails, or would go into an infinite loop in an eager language.)
05:31:27 <jamiehannaford> so if your binary function is (+) wouldn't both foldl and foldr carry on all the way through? ie. there would be no difference between eager/lazy evaluation
05:32:30 <pjdelport> Right. If your operator is strict in its operands (like + is), then foldr / foldl also becomes strict for the whole list.
05:33:10 <pjdelport> In that case, foldl' is usually recommended over foldr. (foldl' is the more strict and efficient version of foldl.)
05:33:22 <jamiehannaford> whereas if you're using a function that allows lazy evaluation, foldr is better because it won't force strict evaluation like foldl
05:33:30 <pjdelport> Right.
05:33:46 <jamiehannaford> what's an example of a function that has lazy evaluation
05:34:19 <Cale> > foldr (\x xs -> x : x : xs) [] [1..]
05:34:20 <pjdelport> Many standard list transformations, like map and filter.
05:34:20 <lambdabot>  [1,1,2,2,3,3,4,4,5,5,6,6,7,7,8,8,9,9,10,10,11,11,12,12,13,13,14,14,15,15,16,...
05:34:36 <Cale> > foldr (\x xs -> if even x then x : x : xs else x : xs) [] [1..]
05:34:38 <lambdabot>  [1,2,2,3,4,4,5,6,6,7,8,8,9,10,10,11,12,12,13,14,14,15,16,16,17,18,18,19,20,2...
05:34:40 <pjdelport> jamiehannaford: It's a fun exercise to write map and filter in terms of foldr, if you haven't already.
05:35:34 <Cale> jamiehannaford: The important thing is that it's able to produce a constructor (in my examples, (:)) without examining its second parameter
05:36:17 <pjdelport> jamiehannaford: You might enjoy http://www.cs.nott.ac.uk/~gmh/fold.pdf by the way, if you want to know more about the theory behind foldr, and why it's particularly useful.
05:36:35 <jamiehannaford> isn't strict evaluation useful sometimes, though? because then you don't have lots of call stack. you can use `seq` right?
05:37:02 <jamiehannaford> not sure if `seq` is what I mean
05:37:15 <pjdelport> That's right, yes.
05:37:29 <Cale> jamiehannaford: Remember, there's no call stack (or at least, the "call stack" is not being used for calls :)
05:37:50 <pjdelport> You can say that Haskell is non-strict by default, and explicitly strict when you want it to be. In many other languages, it's just the other way around.
05:37:52 <Cale> But yeah, foldl' is useful to avoid accidentally building up giant expressions
05:38:02 <Cale> Consider this:
05:38:09 <Cale> foldl (+) 0 [1,2,3]
05:38:19 <Cale> -> foldl (+) (0+1) [2,3]
05:38:24 <Cale> -> foldl (+) ((0+1)+2) [3]
05:38:31 <Cale> -> foldl (+) (((0+1)+2)+3) []
05:38:35 <Cale> -> ((0+1)+2)+3
05:38:53 <Cale> up to this point, essentially no stack space was needed (maybe one spot, for matching on the list argument)
05:39:07 <Cale> But now (+) needs to match on its first parameter
05:39:13 <Cale> which isn't evaluated yet
05:39:26 <pjdelport> jamiehannaford: Neither choice is universally better, necessarily: sometimes strict is more convenient than non-strict, sometimes the other way around. But modulo efficiency, non-strict semantics lets you express more programs than strict semantics.
05:39:29 <Cale> So, this goes on the stack, and we proceed to evaluate (0+1)+2
05:39:38 <Cale> and then we have the same situation
05:39:52 <Cale> and that waits on the stack, and we evaluate 0+1
05:40:21 <pjdelport> (And in theory, a good strictness analyzer can detect and annotate all the strict parts of a non-strict program.)
05:40:22 <Cale> If our list was millions of elements long, evaluating the resulting sum could possibly overflow the space allocated for the stack
05:40:50 <jamiehannaford> so with strict operators like (+), you need to allocate stack space for each operand. whereas lazy evaluation defers that until absolutely needed?
05:40:52 <Cale> (and yeah, this is something that the strictness analyser may catch and fix up for us at compile time anyway -- in this specific example, GHC's good enough)
05:41:24 <Cale> jamiehannaford: The stack is basically used to hold on to case expressions which are waiting for their scrutinee to be evaluated enough to match
05:41:53 <Cale> This is a little weird in the case of (+), because we don't tend to think about pattern matching the constructors of Int or Integer or something like that
05:41:59 <Cale> (but they exist, internally)
05:42:44 <Cale> But another way to think about it is that (+) needs to examine both its parameters before it can produce any part of its result (at least in the case of Integer)
05:43:14 <Cale> and so if those parameters are unevaluated expressions, it'll have to wait on the stack until they're evaluated enough for it to examine them
05:43:42 <Cale> (which in the case of Integer, means completely evaluated, since there's no way for an Integer value to be partly evaluated)
05:44:08 <Cale> jamiehannaford: Does that make sense?
05:44:08 <jamiehannaford> okay, I'm getting some of this. is there a good learning resource for how haskell interacts with the stack? for a beginner in very simple terms :)
05:44:23 <Cale> Simon Marlow's book has some stuff about this, I think?
05:44:44 <jamiehannaford> Cale which book is that?
05:44:57 <Iceland_jack> Parallel and Concurrent Programming in Haskell
05:45:05 <Cale> http://chimera.labs.oreilly.com/books/1230000000929/index.html
05:45:21 <Cale> I haven't read it in detail
05:45:30 <Iceland_jack> You can also check out
05:45:30 <Iceland_jack> @hackage parconc-examples
05:45:31 <lambdabot> http://hackage.haskell.org/package/parconc-examples
05:45:35 <jamiehannaford> I think it might be a bit complicated for me, I see monads haha
05:45:42 <Iceland_jack> but it doesn't go very deep into the run-time system
05:46:40 <Cale> jamiehannaford: I think this is one thing where we're kind of failing to teach it properly
05:47:02 <Cale> If I ever get around to writing a book about Haskell, I'll try to make sure to do a reasonable job of it
05:47:05 <Iceland_jack> jamiehannaford: http://www.aosabook.org/en/ghc.html definitely check this out
05:47:22 <Iceland_jack> Written by Simon Marlow and SPJ, informal overview of GHC
05:47:40 <jamiehannaford> I agree - the problem with high level languages is that you can get by with absolutely no knowledge of low-level memory allocation
05:48:09 <jamiehannaford> I'm getting to the point where I really want to know about it
05:48:30 <jamiehannaford> but a lot of the knowledge out there is very ambiguous or over-specific for a language
05:48:31 <Cale> jamiehannaford: But yeah, basically, you can picture the stack as containing case expressions which are waiting to be evaluated (as well as occasionally function applications which are waiting for the function to be a lambda term, but I have never run into a case where those were responsible for a stack overflow)
05:48:32 <Iceland_jack> GHC is also quite complicated
05:49:41 <Cale> Like, if I write:  case lookup 3 xs of Nothing -> ...; Just x -> ...
05:50:34 <Cale> The expression  lookup 3 xs  is not a constructor applied to some arguments, so the case expression can't tell which pattern matches yet
05:50:52 <Cale> So, this is what waits on the stack while  lookup 3 xs  gets evaluated
05:51:55 <Cale> I should also be clear that the way that I'm describing things is an abstraction of what's actually going on with code pointers and all sorts of other low-level stuff :)
05:52:23 <Cale> If you're interested in thinking at the level of thunks rather than expressions, that can work too, I just usually prefer to stay up here :)
05:52:39 <jamiehannaford> thank you - this is helping a lot :)
05:54:12 <kazagistar> personally, I find that the more "levels" I understand, the easier it is to reason about the any of them
05:54:58 <Cale> If you want to get down to those details, this paper is a good place to start: http://research.microsoft.com/apps/pubs/default.aspx?id=67083
05:55:35 <Cale> There's also a good little section where it talks about various different implementation choices for lazy evaluation which can be pretty helpful
06:04:03 <darthdeus> what's the difference between   import Data.Map as Map  and import qualified Data.Map as Map ?
06:04:11 <darthdeus> or import qualified Data.Map as M ?
06:04:33 <darthdeus> I mean i understand the difference between qualified as M and as Map, but what happens when I ommit the qualified?
06:05:01 <cow_2001> i want to write literate haskell. what's the least amount of hassle method?
06:05:47 <slroberts> darthdeus: omiting the qualified allows you to refer to the unqualified names as well as the qualified names
06:06:17 <darthdeus> slroberts: so that I can use unqualified on the ones that dont collied and qualified on the ones that collide with other packages?
06:06:34 <darthdeus> like   Map.map since prelude also has a map, but `fromList` without Map. since that's not in prelude?
06:07:19 <slroberts> iirc: yes. Mind you, I tend to be a real nazi with imports, so I've never actually tried it.
06:09:47 <slroberts> darthdeus: the haskell wiki lists all the possible combinations and what they each mean, http://www.haskell.org/haskellwiki/Import
06:09:52 <rwbarton> yes, though you wouldn't be able to use Prelude's map either without qualification
06:10:41 <Arnob> Hi all
06:10:47 <Arnob> I am having some cabal issues
06:11:17 <Arnob> I am trying to install the following programs:
06:11:19 <Arnob> cabal install ghc-mod stylish-haskell haskell-docs hdevtools
06:11:29 <Arnob> but the install doesn't success
06:11:31 <Arnob> I get the error
06:11:51 <Arnob> <command line>: cannot satisfy -package-id aeson-0.7.0.6-b19228a032fb34be4eef122 913c6e81a     (use -v for more information) Failed to install yaml-0.8.8.3 cabal: Error: some packages failed to install: ghc-mod-4.1.2 depends on haskell-src-exts-1.15.0.1 which failed to install. haskell-docs-3.0.0 failed during the building phase. The exception was: ExitFailure 1 haskell-src-exts-1.15.0.1 failed while unpacking the package. The excepti
06:11:53 <cow_2001> <jk>rm -rv ~/.cabal ~/.ghc</jk>
06:12:04 <Arnob> I am on windows, fyi
06:12:08 <cow_2001> err why rv and not rf
06:16:22 <Arnob> I am not sure if this is a cabal problem
06:16:30 <Arnob> or a haskell-src-exts problem...
06:29:55 <teknokratsevilla> ll
06:30:17 <Sculptor> llnp
06:36:44 <Arnob> this cabal error is driving me nutty
06:36:56 <Arnob> I can't seem to install anything at all
06:37:04 <Arnob> I downloaded the windows fork of hdevtools
06:37:23 <Arnob> C:\Program Files (x86)\Haskell Platform\2013.2.0.0\bin\ghc.exe --make -no-link - fbuilding-cabal-package -O -static -outputdir dist\build\hdevtools\hdevtools-tmp  -odir dist\build\hdevtools\hdevtools-tmp -hidir dist\build\hdevtools\hdevtools- tmp -stubdir dist\build\hdevtools\hdevtools-tmp -i -idist\build\hdevtools\hdevto ols-tmp -isrc -idist\build\autogen -Idist\build\autogen -Idist\build\hdevtools\h devtools-tmp -optP-DCABAL -optP-i
06:37:54 <Arnob> That's the output after running "cabal install -v" in that directory
06:38:06 <isomorpheous> Arnob: for future reference, pastebin
06:38:18 <Arnob> ah... sorry... wall of text
06:42:03 <leonixyz> Hello, I’m stuck with a very simple exercise for beginners… https://gist.github.com/leonixyz/51b4c4bffae956328a14 I get “Non-exhaustive patterns in function noOfElemTailRec” at runtime if I call the function with parameters [1..5] and 0
06:42:42 <anna_> > Hello, Im stuck with a very simple exercise for beginner
06:42:43 <lambdabot>  <hint>:1:6: parse error on input ‘,’
06:42:45 <anna_> nothing new ~
06:43:23 <luite> lambdabot: typo in your function name, line 8
06:43:24 <Eduard_Munteanu> leonixyz: that looks ok, turn on -Wall and see the warnings
06:43:28 <luite> leonixyz: oops i mean you
06:43:33 <Eduard_Munteanu> anna_: hi
06:44:00 <luite> leonixyz: also evene though this is tail recursive, this will get you a stack overflow
06:44:38 <anna_> @eduard: Hii
06:44:39 <lambdabot> Unknown command, try @list
06:46:37 <Arnob> Hi all, having some cabal issues
06:47:01 <Arnob> documented here: http://lpaste.net/105591 and here: http://lpaste.net/105590
06:47:53 <dfeuer> Is the Haskell Platform dead? It's still claiming a future release is to occur in November 2013, and its bug tracker is full of actual spam.
06:49:35 <rwbarton> no, it is expected soon-ish
06:51:46 <luite> doing releases on time is hard :)
06:52:13 <geekosaur> h-p is wating on ghc yet again (7.8.3 bugfixes, some cabal bugfixes but I think those got backported since the chances of upgrading Cabal in 7.8.3 are nil unless we want to wait another few months...)
06:52:53 <dfeuer> Oh, good to hear.
06:53:18 <dfeuer> But delays should be reflected on the website. And spam should be cleaned out of the bug tracker....
06:53:24 <luite> unfortunately no ghcjs support yet in the cabal in that haskell platform :(
06:53:46 <geekosaur> ghc is changing the scheduling of releases in the future which should hopefuly avoid this stuff in the future.h-p isn't cleaning the bug tracker because a move is planned shortly, iirc
06:54:38 <dfeuer> I'm just looking to experiment with alternative implementations of divMod and a "Euclidean" divMod, and I know there have been some significant changes in primop stuff in recent GHCs.
06:56:04 <dfeuer> I wouldn't want to get a win benchmarking against old code and draw a bad conclusion.
06:56:20 <leonixyz> Eduard_Munteanu: I’m sorry, I turned on -Wall but still can’t understand why the patterns matched are non-exaustive… It told me “(_ : _) _” and “[] _” but I cannot understand how actually match them
06:58:03 <geekosaur> leonixyz, did you fix the typo on line 8?
06:58:31 <leonixyz> geekosaur: Int to Integer? yes
06:58:36 <geekosaur> no
06:58:44 <geekosaur> noOfElemTailTec
06:58:58 <leonixyz> oh my god
06:58:58 <geekosaur> ghc thinks line 8 and 9 are different functions
06:59:06 <leonixyz> geekosaur: thank you
06:59:24 <leonixyz> my god my god
07:00:20 <luite> leonixyz: now figure out why it stack overflows if you give it a long list :)
07:00:52 <dfeuer> your god your god.
07:01:57 <leonixyz> luite: I have no idea…. i tried with noOfElemTailRec [1..10000000] 0 but it still works
07:02:06 <leonixyz> no stack overflow
07:06:31 <leonixyz> luite: did you mean that “In Haskell, the function call model is a little different, function calls might not use a new stack frame, so making a function tail-recursive typically isn't as big a deal—being productive, via guarded recursion, is more usually a concern.“  ?
07:09:58 <benzrf> leonixyz: productive?
07:10:45 <leonixyz> benzrf: i copied the last sentence from http://www.haskell.org/haskellwiki/Tail_recursion
07:14:26 <luite> leonixyz: ack apparently it doesn't here either, but at any rate you're building up a huge thunk in sum, since you never force it
07:15:17 <leonixyz> luite: i didn’t understand
07:15:57 <luite> leonixyz: so every time you recurse, you do so with (sum+1)
07:16:49 <Jefffrey> Morning all
07:16:49 <Jefffrey> I was wondering, if I have a bunch of executable placed into `x/xx/a/Main.hs`, `x/xx/b/Main.hs`, `x/xx/c/Main.hs` and so on, each must declare a `module Main`. How can I import a function that was declared in one of these `Main.hs`?
07:16:52 <luite> leonixyz: the first element, it will look like (0+1) (assuming you call it with 0), the second ((0+1)+1), (((0+1)+1)+1), ((((0+1)+1)+1)+1) and so on
07:17:41 <luite> leonixyz: since you don't force the thunk anywhere, it will just continue building up a bigger and bigger expression
07:17:56 <leonixyz> how do I force it?
07:19:31 <luite> leonixyz: you could make the resursive case: sum `seq` noOfElemTailRec t (sum+1)
07:21:07 <benzrf> WHNF
07:21:20 <benzrf> :t ($!)
07:21:21 <lambdabot> (a -> b) -> a -> b
07:26:40 <louisjb> frig, I'm such a newb. Just getting started, I'm trying to get random numbers to work with IO but struggling. could someone explain how rnds can be a new list each time please?  https://gist.github.com/LouisJB/1688bb14a46f00d4cbf2
07:27:26 * hackagebot snaplet-redis 0.1.3.2 - Redis support for Snap Framework  http://hackage.haskell.org/package/snaplet-redis-0.1.3.2 (DmitryDzhus)
07:28:06 <vanila> louisjb, how about trying randomIO?
07:29:15 <vanila> Prelude System.Random> do a <- randomIO ; b <- randomIO ; c <- randomIO ; return ([a,b,c] :: [Int])
07:29:15 <vanila> [1191700574901630706,1482929608558910489,5794511691577270389]
07:29:17 <benzrf> o
07:29:19 <vanila> for example
07:29:55 <louisjb> valila - ok thanks, I think I'm just at beginners stumbling block with IO monad and chaining it together
07:30:19 <louisjb> how would I make randomIO produce a bounded range of ints
07:30:35 <Iceland_jack> @ty randomRIO
07:30:36 <lambdabot> Random a => (a, a) -> IO a
07:30:55 <vanila> louisjb, for that, a different function: randomRIO (x,y) gives a number between x and y
07:31:09 <Iceland_jack> > randomR (100, 200) (mkStdGen 42)
07:31:10 <lambdabot>  (125,1720602 40692)
07:31:23 <louisjb> ok great
07:32:00 <louisjb> so here's my newbie stumbling, how can I pass or make use of that in playRound. I can see how it can be used in the main do block, do I have to pass in the IO () somehow?
07:32:16 <vanila> louisjb, if you change playRound :: [Int] -> Int -> Int -> Player to playRound :: [Int] -> Int -> Int -> IO Player
07:32:28 <vanila> louisjb, then you can write it using do notation, so it's monadic - and use randomRIO in there
07:32:35 <louisjb> ahhh!
07:32:37 <Iceland_jack> louisjb: you can also make the random numbers an input to playRound, that way it can stay pure
07:32:42 <vanila> and in that case, you can remove the [Int] paramter
07:33:04 <Iceland_jack> for example
07:33:04 <Iceland_jack>     r <- randomRIO (5, 10)
07:33:04 <Iceland_jack>     ... playRound ... r ...
07:33:16 <louisjb> well that's what I thought I was doing by passing in the [Int] rands,it's pure but I can't get new sequences for each run
07:33:16 <Iceland_jack> or you can run it in MonadRandom
07:34:05 <robusa> www.SoccerTips4Sure.com
07:34:26 <louisjb> which way would you guys write this. a do block in playRound or making it pure and passing in a [Int] random sequence each time?
07:34:52 <Iceland_jack> louisjb: I would use a random monad
07:35:00 <exicer> Are there any open source projects presenting good exampels of how to use Postgresql-simple ?
07:35:21 <louisjb> Iceland_jack - make one or one exists?
07:35:25 <Iceland_jack> louisjb: http://hackage.haskell.org/package/MonadRandom-0.1.3/docs/Control-Monad-Random.html
07:35:36 <Iceland_jack> Check the 'die' and 'dice' examples
07:35:39 <louisjb> Iceland_jack - ok thanks, will read up on that
07:35:39 <vanila> i dunno man IO woudl be pretty easy to start with
07:35:46 <vanila> you could change to random after you get it working
07:35:48 <Iceland_jack> although 'sequence (replicate n die)
07:35:55 <Iceland_jack> ' could just as well be replicateM n die
07:36:09 <benzrf> :t die
07:36:10 <lambdabot>     Not in scope: ‘die’
07:36:10 <lambdabot>     Perhaps you meant ‘div’ (imported from Prelude)
07:36:12 <Iceland_jack> but sure, if it's just to try it out then IO is easy to get started with
07:36:17 <Iceland_jack>     die = getRandomR (1, 6)
07:36:24 <louisjb> ok - that sounds good, let me make a simple start on what I have then try the Random Monad after
07:36:44 <louisjb> yeah, just learning the ropes, still haven't got a feel for when do blocks are ok
07:37:00 <Iceland_jack> louisjb: another (pedagogical) idea is to extract and pass the random seed manually
07:37:26 <kazagistar> isnt a random monad a thin wrapper around a state monad?
07:37:31 <vanila> yes
07:37:49 <Iceland_jack> where you generate two die throws with
07:37:49 <Iceland_jack>     let (val1, gen2) = randomR (1, 6) gen1
07:37:50 <Iceland_jack>         (val2, gen3) = randomR (1, 6) gen2
07:37:50 <Iceland_jack>      in (val1, val2)
07:38:02 <louisjb> for example I thought naively I could subs randoms newStdGen :: [Int] for rnds in let rs = [playRound rnds 0 0 | x <- [1 .. noOfRuns] ]
07:38:08 <kazagistar> possibly with a different Alternative implementation that forks rngs
07:38:53 <vanila> if you try to explicitly pass around a random generator, or infinite list of random numbers -- you're basically doing a direct implementation of the State monad in place
07:39:15 <Iceland_jack> yes, it's nice for learning
07:39:41 <Iceland_jack> the latter one is also nice for small problems
07:39:54 <benzrf> oooh, infinite random number list
07:40:01 <benzrf> that one never occurred to me
07:40:14 <Iceland_jack> > randoms (mkStdGen 42) :: [Bool]
07:40:16 <lambdabot>  [True,True,True,False,False,True,False,True,False,True,True,True,False,False...
07:40:43 <louisjb> Ok thanks everyone, lots to think about, I'll stumble around some more then come back with questions :)
07:40:52 <Iceland_jack> good luck louisjb
07:42:24 <louisjb> thanks, I feel so dumb right now, but it must be the only way to learn it
07:43:57 <Iceland_jack> It feels natural in no time
07:45:31 <benzrf> ugh GvR is lame
07:45:38 <benzrf> http://www.artima.com/weblogs/viewpost.jsp?forum=106&thread=4550 <- ctrl+f haskell
07:50:51 <sbrg> benzrf: wat.
07:51:03 <sbrg> is he talking about template haskell?
07:51:04 <Iceland_jack> (let's not have this ot conversation again)
07:51:37 <sbrg> oh.
07:51:38 <sbrg> that's ancient
07:51:45 <sbrg> 2003
07:52:19 <mmmm_> Hi, anyone know what the cause of errors like these are? http://lpaste.net/105593
07:52:42 <zomg> I kinda agree about what Guido says there
07:53:09 <Iceland_jack> Unbounded recursion is “low-level” in many ways
07:53:24 <hiptobecubic> I'm sure if you throw out the entire type system, haskell programs would be as "easy to understand" as python
07:53:25 <zomg> Recursion can be hard to understand and at least the kind of loops you'd use a lot with python (for-each) are reasonably straightforward
07:53:29 <heatsink> mmmm_: Some functions are missing in the texmath package
07:53:49 <zomg> but honestly if you consider it in terms of map, filter, and other such functions, then I feel those are simpler than looping even with foreach type loops
07:54:06 <mmmm_> heatsink: What can I do to fix this? cabal repl builds fine
07:54:07 <heatsink> It may mean that the pandoc's package dependences were not written correctly
07:54:19 <mmmm_> ah that might be why I've been screwing around with them a bit
07:54:36 * Eduard_Munteanu wishes for a MonadConduit class. :(
07:55:31 <heatsink> First you need to locate that function
07:55:46 <louisjb> ok sorry, back already - I tried the simple idea to make the function IO Player https://gist.github.com/LouisJB/1688bb14a46f00d4cbf2 and use a do but now I'm returning an IO Player I can't show it
07:55:50 <heatsink> Text.TeXMath.MathML.fromList
07:58:16 <sbrg> god, pandoc is huge
07:58:54 <rwbarton> normally you shouldn't be getting these undefined reference errors
07:59:17 <Iceland_jack> louisjb: First of all 'Int =>' makes no sense
07:59:51 <Iceland_jack> 'rs' is currently a list of _actions_, so you cannot print them
08:00:03 <Iceland_jack> you need to run them to get their values, then you can print those
08:00:42 <Iceland_jack> louisjb: It works if you write
08:00:42 <Iceland_jack>     rs <- sequence [playRound rnds 0 0 | x <- [1 .. noOfRuns] ]
08:00:42 <Iceland_jack>     print rs
08:01:28 <Iceland_jack> and there is room for improvement
08:01:42 <vanila> louisjb, but you're not using randomRIO
08:01:57 <mmmm_> heatsink: when I find this function, then what?
08:02:16 <Iceland_jack> Yes, louisjb seems a bit confused
08:02:31 <Iceland_jack> Currently everything in 'playRound' is pure, yet it's IO
08:02:37 <mmmm_> or how do I check where the problem is in my cabal file?
08:02:38 <heatsink> mmmm_, If the function is in a different version of texmath, then install the other version
08:02:42 <vanila> with what you said + what I said, he should be able to get it to work!
08:02:56 <louisjb> <- is confused
08:03:06 <heatsink> Did you modify the dependences in pandoc's cabal file, mmmm_?
08:03:29 <vanila> louisjb, instead of let x = head (take 1 rngs)
08:03:30 <Iceland_jack> louisjb: You need a clearer distinction between actions and running actions
08:03:40 <vanila> louisjb, how about something like  x <- randomRIO (1 :: Int, 6)
08:04:06 <vanila> you can get rid of the rngs parameter
08:04:55 <mmmm_> I made some changes to pandoc-types so I bumped the required version of that to match my local copy and added a dependency to cryptohash
08:05:08 <Iceland_jack> louisjb can get rid of almost all those let's in that code
08:05:40 <heatsink> Were you able to install pandoc before?
08:06:17 <mmmm_> yes, with these changes
08:06:32 <mmmm_> then I decided it would be a good idea to delete the sandbox and start again for some reason
08:06:33 <Iceland_jack> louisjb: I suggest you start out with a smaller example, I'm willing to go through the entire code in PM if you want
08:07:19 <benzrf> g2g
08:07:24 <louisjb> ok let me tidy it up, it's compiling and running again so if I can replace rngs with some io action to get new randomIO ints it'll be there I guess
08:07:33 <louisjb> give me a sec, I'll update the gist
08:08:06 <Iceland_jack> Sure, seeing something like
08:08:06 <Iceland_jack>     let x = head (take 1 rngs)
08:08:06 <Iceland_jack>     let y = head (take 1 (drop 1 rngs))
08:08:06 <Iceland_jack> should be a big warning flag in the future
08:08:40 <heatsink> mmmm_, then you can't see which package versions were installed last time
08:09:42 <mmmm_> I wanted to reinit the sandbox because I hadn;t used "add-source" for the pandoc-types dependency
08:10:17 <mmmm_> I'm trying now just doing "cabal install pandoc-types/" etc
08:10:44 <heatsink> Usually this kind of error happens when a package gets reinstalled
08:11:10 <heatsink> and the reinstalled package doesn't contain the same functions that the original did
08:11:22 <louisjb> Iceland_jack - totally, I was just trying to hack something then to learn how to tidy it, very quickly I got tangled in I have no idea how to chain the IO actions together :D
08:11:38 <heatsink> If you started installing in a new sandbox, though, that wouldn't happen
08:11:53 <rwbarton> mmmm_: try ghc-pkg check
08:11:58 <rwbarton> just to see if it has anything to say
08:12:00 <vanila> do a ; b ; c ; return ()   is like   sequence_ [a,b,c]
08:12:00 <louisjb> https://gist.github.com/LouisJB/1688bb14a46f00d4cbf2 is tidier, so if the rngs can be replaced with the randomIO that might do what I want, at the moment of course all rounds are identical!
08:12:49 <Iceland_jack> louisjb: at the moment there is no IO happening in playRound
08:13:26 <vanila> louisjb, like this http://pastebin.com/JpV9jMXJ
08:15:21 <Iceland_jack> louisjb: In vanila's version you don't need to use 'head (take 1 rngs)'/'head (take 1 (drop 1 rngs))'/'drop 2 rngs' in the code, but if you did you should absolutely use pattern matching to access them
08:15:58 <louisjb> ok right I see
08:16:08 <Iceland_jack>     playRound (x:y:rest) xLast yLast
08:16:08 <Iceland_jack>       | x < xLast = PlayerB
08:16:08 <Iceland_jack>       | y < yLast = PlayerA
08:16:08 <Iceland_jack>       | otherwise = playRound rest x y
08:16:31 <Iceland_jack> see how this eliminates all the 'let' and 'do' bindings?
08:16:40 <Iceland_jack> and all the heads/takes/drops/...
08:16:44 <darthdeus> guys what should I do about this error? "Could not deduce (t ~ f t) from the context (Functor f)"
08:17:04 <rwbarton> darthdeus, fix your code
08:17:12 <darthdeus> :P
08:17:21 <darthdeus> I'm not sure how to understand the error
08:17:26 <louisjb> Iceland_jack - ah of course, that would be much nicer
08:17:26 <darthdeus> here's the function
08:17:29 <darthdeus> magic :: Functor f => (a -> f b) -> (s -> a) -> (s -> b -> t) -> f t
08:17:29 <darthdeus> magic f sa sbt s = sbt s <$> f (sa s)
08:17:47 <heatsink> It means that your code requires t to be the same as (f t)
08:17:55 <darthdeus> hmm
08:18:22 <Iceland_jack> As a rule of thumb, if you see head/tail see if pattern matching doesn't simplify things
08:18:55 <louisjb> ok so it works now, something hasn't quick clicked, in order to be able to use randomRIO I needed to be in a do block, in order for that my return must be IO a and then I must use it as an action in the main do block, is that right?
08:19:00 <rwbarton> darthdeus, you forgot the last argument in the type
08:19:03 <darthdeus> I don't understand where though, I'm fmaping (b -> t)  on (f b) in order to get (f t)
08:19:17 <darthdeus> oh lol :)
08:19:24 <Iceland_jack> louisjb: That's along the right lines, it doesn't have to be in a do-block
08:19:25 <darthdeus> thanks! i dont know how i missed that
08:19:45 <Iceland_jack>     notInADoBlock :: IO ()
08:19:45 <Iceland_jack>     notInADoBlock = putStrLn "Hello!"
08:20:16 <louisjb> isn't any function that returns a different return for same args non-pure and must be in a monad
08:21:06 <Eduard_Munteanu> :t randomR
08:21:07 <lambdabot> (Random a, RandomGen g) => (a, a) -> g -> (a, g)
08:21:49 <Iceland_jack> sure, but monads don't imply non-purity and if it returns different values for the same argument it's called an 'action' in Haskell rather than a function
08:21:51 <Eduard_Munteanu> @hoogle getRandomR
08:21:53 <lambdabot> No results found
08:22:09 <Eduard_Munteanu> getRandomR :: Random a => (a, a) -> m a
08:22:12 <vanila> louisjb, yeah spot on
08:22:30 <louisjb> ok so it doesn't have to be a do block, but either an action or a set of actions joind with bind >>= or whatever then, is that right?
08:22:38 <Iceland_jack> louisjb: yes
08:23:05 <Iceland_jack> for example
08:23:06 <Iceland_jack>     foo = do
08:23:06 <Iceland_jack>       print 1
08:23:06 <Iceland_jack>       print 2
08:23:09 <Iceland_jack> is the same as
08:23:12 <Iceland_jack>     bar = print 1 >> print 2
08:23:17 <Eduard_Munteanu> louisjb: 'do' notation translates directly to (>>=) and lambdas.
08:23:18 <louisjb> oh right, ok - action not function. learning the right lingo helps here
08:23:35 <Eduard_Munteanu> (and 'fail', but that's not important)
08:23:36 <Iceland_jack> and if you only have a single statement then the 'do' is optional
08:23:52 <Iceland_jack> *single action to be consisten
08:23:55 <Iceland_jack> *consistent
08:24:12 <louisjb> ah right, penny dropped, so playRound now it has the randomIO in it, the outcome is random, now no longer pure the return type had to change to be an IO action
08:24:15 <Eduard_Munteanu> @undo do { y <- f x; z <- g y; return z }
08:24:16 <lambdabot> f x >>= \ y -> g y >>= \ z -> return z
08:24:46 <Iceland_jack> louisjb: yes, and you can't print a list of actions: you'll have to run them first
08:24:49 <louisjb> wheras before it was pure taking a lazy random list, but I had no idea how to pass it a new random list each time
08:25:14 <Iceland_jack> louisjb: Why do you need to pass a new list each time? The list is infinite
08:25:31 <Iceland_jack> But if you write
08:25:32 <Iceland_jack>     [print 1, print 2, print 3]
08:25:32 <louisjb> ok so maybe I should a) try the pure approach again so I can compare it b) try Random Monad
08:25:32 <Iceland_jack> then it has type
08:25:32 <Iceland_jack>     :: [IO ()]
08:25:39 <Eduard_Munteanu> @undo do { Just y <- f x; g y; h y }
08:25:39 <lambdabot> f x >>= \ a -> case a of { Just y -> g y >> h y; _ -> fail ""}
08:25:54 <Iceland_jack> louisjb: Feel comfortable with the IO approach before using the random monad
08:26:01 <louisjb> Iceland_jack true, but how would  I pass the results of one 'game' into the next to keep walking down the random seq
08:26:13 <louisjb> Iceland_jack - will do
08:26:43 <Iceland_jack> Isn't that what you do in your example? You call the function recursively and simply drop the 'used' values
08:26:56 <louisjb> it would have to return IO (Player, [Int]) where [Int] is the rest of the seq
08:27:28 <Iceland_jack> no
08:27:33 <louisjb> Iceland_jack - yes absolutely, and that worked, but I wanted to run it many times and get a statistical average, that's where I got stuck
08:27:58 <Iceland_jack> It doesn't have to be IO if you're using the 'list of random values' approach
08:28:13 <louisjb> so each 'top level' call to playRound recursively plays a different game to conclusion
08:28:41 <louisjb> could be the same random list of numbers, but how to chain the position back to the next call
08:28:54 <louisjb> by position, I mean new head
08:29:24 <Iceland_jack> I'm not clear what you mean by chaining the position
08:30:08 <louisjb> if I pass a lazy [Int] to playRound it will work recursively and be pure, resulting in a Player result
08:30:15 <Iceland_jack> yes
08:30:35 <louisjb> but if I want to play the game 100 times in a row... how to reuse a new head in the [Int] random seq for remaining games
08:31:10 <Iceland_jack> louisjb: If you want to play a new game you handle that in the place that calls playRound (in your case main)
08:31:13 <louisjb> naturally what I got before when it was pure was just the same game 100 times
08:31:42 <louisjb> Iceland_jack - ok, so that was my original question, how I could have done that (on the pure function)
08:32:25 <Iceland_jack> you can either generate 100 infinite lists (not so nice) or take the remaining tail of the unused list from completed rounds (even worse)
08:32:34 <Iceland_jack> using IO is nice enough here
08:32:42 <vanila> louisjb, you change from IO monad to State monad
08:33:01 <vanila> now it's still a pure function, but you program it in exactly the same way you currently have it (with do and stuff)
08:33:15 <Iceland_jack> vanila: I wouldn't recommend State to louisjb, before they understand IO properly
08:33:33 <vanila> okay
08:33:55 <Iceland_jack> If you're going to use State you might as well use the random monad which is a fancy state
08:34:54 <louisjb> ok, so maybe given it needs to run n hundred times this is a reasonable way before moving on to Random Monad etc
08:35:12 <louisjb> as it doesn't seem making it a pure function makes for a nice composition in any way
08:35:22 <Arnob> I hate cabal dependency hell...
08:35:32 <Arnob> can't get nothin' to build
08:35:51 <vanila> yeah exactly, the monad way is the good way to do it
08:35:56 <Iceland_jack> louisjb: Use vanila's impure implementation of 'playRound :: Int -> Int -> IO Player'
08:35:56 <Iceland_jack> <vanila> louisjb, like this http://pastebin.com/JpV9jMXJ
08:36:11 <Iceland_jack> and use that along with 'replicateM' to repeat it 100 times
08:36:26 <Iceland_jack> @ty replicateM :: Int -> IO a -> IO [a]
08:36:26 <vanila> since the function should give different values, when you call it with the same inputs - it is monadic/effectul
08:36:27 <lambdabot> Int -> IO a -> IO [a]
08:36:50 <Iceland_jack> 'replicateM n' repeats an action n-times and gives you its results
08:37:07 <louisjb> ah! ok, that's interesting
08:37:08 <Iceland_jack> so 'replicateM 100 (playRound 0 0)' plays 100 rounds
08:37:35 <Iceland_jack> and gives you a list of which player won each game: [Player]
08:37:38 <Iceland_jack> *IO [Player]
08:37:41 <louisjb> that must have been what I was trying to get to in the completely wrong way, given they are actions not values I can't do what I originally tried to do
08:37:54 <rwbarton> Arnob, do you have a specific problem?
08:38:05 <Iceland_jack> louisjb: That's the same as
08:38:05 <Iceland_jack>     sequence [ playRound 0 0 | x <- [1..noOfRuns] ]
08:38:07 <louisjb> perfecto - cool, thanks a lot, just started to play with this earlier today so first time to think about it
08:38:17 <Iceland_jack>     replicateM noOfRounds (playRound 0 0)
08:38:42 <louisjb> thank you Iceland_jack vanila
08:38:45 <Iceland_jack> yw
08:38:49 <vanila> im glad we helped !
08:38:51 <Arnob> http://lpaste.net/105591
08:39:04 <Arnob> http://lpaste.net/105590
08:39:22 <louisjb> I wrote this little game in Scala - thought it would take 2 mins to make a haskell version but it forced me to realise I don't know anything, best way to learn I guess :)
08:39:25 <Arnob> rwbarton: http://lpaste.net/105590 http://lpaste.net/105591
08:39:27 <louisjb> bye for now
08:39:39 <bergmark> Arnob: it looks a bit like your installation broke, can't tell for sure though
08:39:44 <Iceland_jack> louisjb: check out LYAH if you haven't already
08:40:01 <cow_2001> louisjb: wooo what kind of game
08:40:34 <bergmark> Arnob: are you using cygwin? you need that for the unix package
08:41:20 <Arnob> begmark: I am not sure. I am trying to use the windows fork of hdevtools
08:41:45 <louisjb> cow_2001 - hah no nothing fancy, the simplest game. I was originally trying to solve a puzzle with a recurrance relation and so thought I'd make a simple program to try and see how it behaves
08:41:47 <Arnob> bergmark: https://github.com/mvoidex/hdevtools
08:41:53 <louisjb> Iceland_jack - I will, thank you!
08:41:56 <leonixyz> Could someone please tell me what’s wrong with this simple sorting algorithm? https://gist.github.com/leonixyz/69bccc3ad18a93d28d0d
08:42:02 <Arnob> bergmark: this should be less dependent on cygwin I guess
08:42:27 <Arnob> (sorry I am new to IRC, not sure if I should be private messagin a person or posting to the main IRC window...)
08:42:52 <Arnob> bergmark: This is a fresh copy of Haskell Platform, if that helps
08:42:58 <rwbarton> Arnob, I would run ghc-pkg check
08:43:03 <rwbarton> are you using sandboxes?
08:43:19 <Arnob> bergmark: I am not... because I want these packages available globally
08:43:37 <Arnob> bergmark: I want sublimetest's sublimehaskell plugin to be able to use these packages
08:43:38 <Iceland_jack> leonixyz: use ':'
08:43:39 <vanila> leonixyz: Look at this:
08:43:40 <rwbarton> ok, that's fine. what does ghc-pkg check say
08:43:40 <vanila> oh
08:43:42 <vanila> neverind
08:44:42 <Iceland_jack> the logic is wrong though, more wrong for repeating values
08:46:17 <Arnob> rwbarton: http://lpaste.net/105595
08:46:28 <Arnob> rwbarton: that is the ghc-pkg check output
08:47:21 <rwbarton> huh, well, try 'ghc-pkg recache' then
08:47:41 <Iceland_jack> leonixyz: since the minimum increases, you either need to append it to the end of sorted or reverse the list in the end
08:48:06 <rwbarton> I've never seen that message, rather odd
08:48:08 <akater> Hello. I'm a complete newbie to Haskell and almost complete newbie to IRC.
08:48:08 <akater> For now I'm getting used to syntax. Is there a way to quickly check the precedence of operations in an arbitrary Haskell expression?
08:48:30 <leonixyz> Iceland_jack: ok, but I can’t even :l the module in ghci
08:48:33 <dyu>  fibo (x:a:b) = [x:a:b:a+b]  <-- gives me a  "Occurs check: cannot construct the infinite type: a0 = [a0]     In the first argument of `(+)', namely `a'     In the second argument of `(:)', namely `a + b'     In the second argument of `(:)', namely `b : a + b'"
08:48:44 <akater> Also, are there any IHaskell fans here?
08:48:48 <dyu> newbie. please don't hurt me
08:48:57 <Iceland_jack> dyu: 'a + b' is not a list :)
08:49:04 <Iceland_jack> but 'b' is
08:49:05 <leonixyz> Iceland_jack: what does it mean “use :”?
08:49:17 <Eduard_Munteanu> Is that an indexed Haskell? :P
08:49:31 <Iceland_jack> leonixyz:
08:49:31 <Iceland_jack>     orderIt unsorted sorted =
08:49:32 <Iceland_jack>         orderIt (delete (minimum unsorted) unsorted) (minimum unsorted : sorted)
08:49:37 <Iceland_jack> and then the output is reversed
08:49:51 <Iceland_jack> so you need to call the function using
08:49:51 <Iceland_jack>     orderIt' xs = reverse (orderIt xs [])
08:49:53 <vanila> dyu, it's because you're mixing lists and elements
08:49:56 <deweyvm> is there a haskell library for decoding strings which arent quite properly encoded?
08:50:11 <jamiehannaford> I have a data type: data JoinList m a = Empty | Single m a | Append m (JoinList m a) (JoinList m a), and a function (+++) :: Monoid m => JoinList m a -> JoinList m a -> JoinList m a
08:50:13 <jamiehannaford> but when I try (+++) Empty Empty I get: No instance for (Monoid m0) arising from a use of `+++' The type variable `m0' is ambiguous
08:50:18 <jamiehannaford> :S
08:50:55 <dyu> Iceland_jack: vanila: got it. thanks. i'm getting another error now. gonna try to figure this out before asking again in 5 mins
08:51:08 <copumpkin> bitemyapp: the bidirectional serialization stuff is pretty tricky. Have you read the pickler combinators paper?
08:51:19 <dfeuer> deweyvm, what kinds of strings?
08:51:29 <Arnob> rwbarton: this is the output after running ghc-pkg recache
08:51:31 <Arnob> http://lpaste.net/105596
08:51:35 <Arnob> did not seem to help
08:51:35 <deweyvm> dfeuer: like a file that is valid utf8 except for in N places where theres garbage
08:51:53 <rwbarton> Arnob: help with what? did you try your cabal installs again?
08:52:15 <dfeuer> Dunno.
08:52:41 <ReinH> jamiehannaford: give it a type. It can't infer the type of 'm' for Empty.
08:53:00 <Iceland_jack> jamiehannaford: What did you type? Does it work just doing
08:53:00 <Iceland_jack>     :t (+++) Empty Empty
08:53:00 <Iceland_jack> ?
08:53:05 <deweyvm> ive tried pruning them with iconv, but haskell still doesnt like them even if iconv says its all good
08:53:37 <Iceland_jack> because that shouldn't require you to specify the type
08:53:38 <jamiehannaford> ReinH typing that I get (+++) Empty Empty :: Monoid m => JoinList m a
08:53:47 <rwbarton> Arnob: those haddock warnings are irrelevant. it just means the docs weren't built
08:53:56 <jamiehannaford> how do I specify the type with (+++) Empty Empty ?
08:54:07 <Arnob> rwbarton: Yes, I am still getting the same errors
08:54:13 <ReinH> jamiehannaford: specify the type of Empty
08:54:16 <Iceland_jack> jamiehannaford: lpaste your code
08:54:18 <Iceland_jack> @lpaste
08:54:18 <lambdabot> Haskell pastebin: http://lpaste.net/
08:54:20 <Arnob> "C:\\Users\\Arnob\\AppData\\Local\\Temp\\haddock-2.13.2.1-4884\\haddock-2.13.2.1 \\dist": permission denied (Access is denied.) haskell-docs-0.2.0.0 depends on haddock-2.13.2.1 which failed to install. haskell-src-exts-1.15.0.1 failed while unpacking the package. The exception was: C:\Users\Arnob\AppData\Local\Temp\haskell-src-exts-1.15.0.1-4884\haskell-src-ext s-1.15.0.1\dist-tmp: MoveFileEx "C:\\Users\\Arnob\\AppData\\Local\\Temp\\h
08:54:33 <Arnob> this is from running
08:54:44 <Arnob> C:\Users\Arnob>cabal install ghc-mod stylish-haskell haskell-docs --constraint=h addock==2.13.2.1
08:54:48 <Iceland_jack> Given the data type you posted that shouldn't require annotations
08:54:51 <jamiehannaford> Iceland_jack http://lpaste.net/4085963063411343360
08:55:16 <ReinH> Iceland_jack: Empty +++ Empty is ambiguous.
08:55:25 <guestGuy> I was wondering if anyone could give me some help with inserting a list of values into a map - http://lpaste.net/105597
08:55:41 <Iceland_jack> type checks just fine
08:55:42 <Iceland_jack> ghci> :t (+++) Empty Empty
08:55:42 <Iceland_jack> (+++) Empty Empty :: Monoid m => JoinList m a
08:55:50 <guestGuy> I have no idea how to fold the list over the map
08:55:57 <enthropy> you could set -XExtendedDefaultRules, to get a type JoinList () ()
08:56:03 <Iceland_jack> if you want to evaluate it, sure you need a monoid instance
08:56:12 <begriffs> I've got a question about project naming conventions. What is the distinction between src/Module/Foo.hs and src/Module/Foo/Internal.hs that I see in many packages?
08:56:14 <dyu>  fibo (x:a:b) = [x:a:b] ++ a + b   <-- this also gives me an error :-(
08:56:24 <Iceland_jack> dyu: You need to think about the types here
08:56:28 <ReinH> Iceland_jack: yes, it type checks.
08:56:28 <Iceland_jack> ++ only works on lists
08:56:50 <Iceland_jack> dyu: Do you understand what ':' means?
08:56:50 <jamiehannaford> I get the same error with: (+++) Empty Empty :: Monoid m => JoinList m a
08:56:56 <dyu> add to the end?
08:57:12 <ReinH> jamiehannaford: Haskell can't just pick a Monoid m for you
08:57:21 <geekosaur> begriffs: often you don't want people poking inside your data structures because you need to maintain invariants. but sometimes you need to use things that need to see the insides of them (Typeable, Generics, some other things)
08:57:43 <Iceland_jack> jamiehannaford: (+++) Empty (Empty :: JoinList [a] b) works
08:57:44 <jamiehannaford> ReinH but I thought just Empty would be enough to construct a JoinList type
08:57:49 <geekosaur> so most people use the public interface, but for those who really need it the private interface is exposed in an Internal module
08:57:56 <Iceland_jack> dyu: it means to prepend (add to beginning) but the first element must be a value, the second element must be a list
08:58:13 <ReinH> jamiehannaford: 'm' is ambiguous and GHC can't just pick one for you.
08:58:32 <Iceland_jack> dyu: so when you have
08:58:32 <Iceland_jack>     x:y:zs
08:58:32 <Iceland_jack> 'x' and 'y' have type 'a' but zs is a list of a's: [a]
08:58:47 <jamiehannaford> but I thought Empty by itself was a valid data construct to produce a value of type JoinList
08:58:56 <jamiehannaford> ReinH ^
08:59:00 <Iceland_jack> jamiehannaford: it is, but only for type checking
08:59:04 <Iceland_jack> > let (x:y:zs) = [1,2,3,4] in (x, y, zs)
08:59:05 <lambdabot>  (1,2,[3,4])
08:59:12 <Iceland_jack> dyu: ↑ does that make sense
08:59:19 <rwbarton> Arnob: well I don't know why you apparently can't write to those directories
08:59:28 <Iceland_jack>     x = 1, y = 2, zs = [3,4]
08:59:29 <ReinH> jamiehannaford: it is, but JoinList is still JoinLost m a and +++ still puts a monoid constraint on the m
08:59:38 <rwbarton> Arnob: maybe you ran something as whatever the windows equivalent of root is, and it made them as the root user
08:59:42 <rwbarton> Arnob: I would go investigate that
08:59:48 <ReinH> so Empty still has a Monoid constraint on the m
09:00:02 <Arnob> rwbarton: I have also opened up a command prompt as Administrator, and tried running it, which would be the windows equivalent of root
09:00:19 <dyu> Iceland_jack: yup. it's not working coz a+b isn't a list
09:00:32 <Iceland_jack> dyu: also because 'b' _is_ a list
09:00:33 <rwbarton> Arnob: ok, well, that is a likely explanation for the permissions errors
09:00:37 <jamiehannaford> ReinH so all you need to do is specify a type after :: with fake args (like [a] b)
09:00:46 <Iceland_jack> dyu: in
09:00:46 <Iceland_jack>     fibo (x:a:b) = [x:a:b] ++ a + b
09:00:46 <Iceland_jack> 'b' is a list
09:00:51 <dyu> Iceland_jack: ahhh. now i understand why i can;t add them
09:00:55 <Arnob> rwbarton: Well, I guess I started with a fresh install of haskell platform, and then tried installing these tools (ghc-mod, etc.) from teh command line as a regular user
09:01:04 <ReinH> They aren't fake. They specify the type of Empty
09:01:14 <Iceland_jack> dyu: I'm guessing you want to accept a list of length 3?
09:01:16 <Arnob> rwbarton: when that did not work, I opened up another command prompt as Admin and tried running it
09:01:24 <Arnob> rwbarton: but results were the same
09:01:25 <Iceland_jack> dyu: Then you want to use [a, b, c] to match
09:01:26 <hexagoxel_> jamiehannaford: as soon as you use that expression in a context where m can be infered, it should work without further annotations
09:01:36 <jamiehannaford> ReinH okay. and you only need to do it to the second Empty because the first will pick up on the other's type?
09:01:43 <ReinH> You need to do this because GHC can't infer the type of m.
09:01:59 <Eduard_Munteanu> Jesus, writing conduits over conduits over conduits over some monad is ugly, especially since I can't use the type synonyms partially applied.
09:02:09 <Iceland_jack> > let [x, a, b] = [1,1,2] in [x, a, b] ++ [a + b]
09:02:11 <lambdabot>  [1,1,2,3]
09:02:18 <ReinH> +++ forces both to be the same type, so once you specify one it can infer the other.
09:02:28 <rwbarton> Arnob: literally the same? that seems quite unlikely, why would the administrator user get permissions denied errors?
09:04:13 <dyu> Iceland_jack: thanks. i wouldn't have figured that out on my own. i'm doing project euler exercises(this is the second one) so i can practice. i've read the first few chapters of learn you a haskell, but i wanted to try writing code with it instead of just reading all the time
09:04:43 <Iceland_jack> dyu: That's a good plan, if you want to get lists you just need to keep in mind that they only have two 'shapes'
09:04:53 <Iceland_jack> They're either empty [] or non-empty: x:xs
09:04:53 <Arnob> rwbarton: this is a guess, but I think the issue is with the haskell-src-exts package, where the dist folder does not exist in the actual distribution/cabal package
09:05:02 <Iceland_jack> and in the non-empty case, 'xs' is a list
09:05:21 <dyu> i see. question. what did people read before learn you a haskell?
09:05:23 <rwbarton> dist is what's produced by cabal building your package
09:05:30 <Iceland_jack> When you write
09:05:30 <Iceland_jack>     x:y:z:zs
09:05:30 <Iceland_jack> it's the same as
09:05:30 <Iceland_jack>     (x:(y:(z:zs)))
09:05:41 <heatsink> dyu: There was Real World Haskell
09:05:53 <monochrom> I read The Gentle Introduction
09:05:55 <heatsink> and a Gentle Introduction to Haskell, and various smaller tutorials
09:06:00 <aristid-ic_> kinds are not affected by the monomorphism restriction?
09:06:02 <monochrom> but I was born before LYAH existed
09:06:06 <aristid-ic_> (polymorphic kinds)
09:06:28 <Arnob> rwbarton: I saw a post to that effect somewhere, trying to find the link for it
09:06:36 <monochrom> no, kinds are not affected by the monomorphism restriction. the restriction is for types.
09:07:09 <dyu> thanks, all. :D
09:07:11 <monochrom> also, polymorphic kinds were invented long after people disdained the monomorphism restriction. :)
09:07:17 <Iceland_jack> dyu: you're welcome
09:07:17 <dyu> checking out a gentle intro
09:07:36 <aristid-ic_> monochrom: were they invented before or after GADTs?
09:07:44 <ReinH> Some books too, right? Bird? Hutton?
09:07:46 <monochrom> after GADTs, too
09:07:47 <Arnob> rwbarton: I think this is the issue https://github.com/haskell/cabal/issues/1698
09:07:48 <Iceland_jack> dyu: Keep in mind that
09:07:48 <Iceland_jack>     x:xs
09:07:48 <Iceland_jack> is a list of length 1 _or more_
09:07:58 <ryantrinkle> i'm seeing a situation where a multithreaded program (doing lots of DB requests) is using *far* more CPU per request under high load than under low load; any advice on profiling/debugging?
09:08:02 <Iceland_jack> If you only want to match lists of length 1, you do
09:08:02 <Iceland_jack>     x:[]
09:08:02 <Iceland_jack> or
09:08:02 <Iceland_jack>     [x]
09:08:13 <rwbarton> Arnob: oh, because it *does* exist in the package
09:08:14 <dyu> alright
09:08:19 <monochrom> kind polymorphism is very recent, like, ghc 7.4 or something
09:08:26 <ReinH> I actually don't know when LYAH was started.
09:08:46 <aristid-ic_> monochrom: not sure if what i'm doing is kind polymorphism.
09:09:29 <enthropy> aristid-ic_: if you don't enable -XPolyKinds, you get a really extreme monomorphism restriction
09:09:44 <monochrom> http://www.vex.net/~trebla/haskell/learn-sources.xhtml
09:09:45 <aristid-ic_> data XYZ :: * -> * where V :: XYZ a
09:09:47 <aristid-ic_> this
09:10:03 <aristid-ic_> is this a polymorphic kind if i just use V?
09:10:08 <enthropy> no
09:10:11 <monochrom> no kind polymorphism there. you've even hardcoded the kind.
09:10:40 <aristid-ic_> how do you call the fact that it's an a instead of something concrete then?
09:10:49 <Arnob> rwbarton: I do not see any resolution to the issue. Also, I have an OS X box in which I installed haskell-src-exts and it installed fine...
09:10:51 <monochrom> "data Whee :: x ..." would be kind polymorphism. x is a kind variable.
09:11:11 <monochrom> that is type polymorphism
09:11:31 <rwbarton> Arnob: it looks like people are saying if you "cabal unpack haskell-src-exts-1.15.0.1; cd haskell-src-exts-1.15.0.1; cabal install" it will work
09:11:31 <Arnob> rwbarton: Perhaps they are not the same versions of haskell-src-exts though. Maybe there was an older working version in OS X
09:11:43 <guestGuy> I was wondering if anyone could give me some help with foldl'ing a string into a map - http://lpaste.net/105597
09:11:53 <rwbarton> Arnob, I suspect it is a Windows-specific issue
09:14:23 <enthropy> guestGuy: insertWith :: (a -> a -> a) -> k -> a -> Map k a -> Map k a, so you have the argument 1 as a "k" not as an "a"
09:15:59 <Arnob> rwbarton: yes, following your instructions allowed me to install haskell-src-exts!
09:16:00 <enthropy> also foldl is passing in the arguments to the HOF in the "wrong" order
09:16:10 <Arnob> rwbarton: you sir are a gentleman and a scholar!
09:16:12 <enthropy> :t foldl
09:16:13 <lambdabot> (b -> a -> b) -> b -> [a] -> b
09:16:35 <guestGuy> enthropy: do you mean the argument (a -> a -> a) is actually (k -> k -> k)
09:16:42 <enthropy> no
09:17:04 <enthropy> I mean the argument you call "1" which is the second argument I guess
09:17:29 <Arnob> on a separate note, is there any way to make sure that cabal uses "-O2" optimization by default
09:19:04 <monochrom> deweyvm: if your data comes from a Handle, read System.IO.mkTextEncoding doc for how to stay alive under errors. if your data is in a ByteString, read Data.Text.Encoding.decodeUtf8' doc and below. in general, thoroughly read the docs of libraries you already have.
09:19:06 <enthropy> Arnob: ~/.cabal/config has an entry for optimization. There's also ghc-options if the other fails
09:19:08 <guestGuy> enthropy: I think I see, you mean the "1" here, correct, "(insertWith (+) 1)" .
09:19:33 <enthropy> :t Data.Map.insertWith (+) (1 :: Int)
09:19:34 <lambdabot> Num a => a -> M.Map Int a -> M.Map Int a
09:19:36 <guestGuy> enthropy: it should be a character and not a interger, right?
09:19:54 <Arnob> enthropy: I have optimization: true
09:19:57 <enthropy> yeah it should be one of the arguments to that function
09:20:01 <Arnob> but looks like the line is commented out
09:20:06 <Arnob> let me try uncommenting it
09:20:10 <enthropy> Arnob: me too. Maybe it'll accept 2 too
09:20:26 <deweyvm> monochrom: i need a bytestring in order to use that, i get the error trying to read one because i need to read line by line
09:23:30 <ddellacosta> confused newb question: how do I produce a function that lets me pass arbitrary rational number values into something that divides then applies a modulo?  I'm stumbling over types badly here, and it seems like it should be (and probably is) simple.
09:24:43 <Arnob> ddellacosta: could you give an example input and output of your program?
09:25:09 <ddellacosta> umm, let's say (12546 / 1000) % 100
09:25:14 <ddellacosta> Arnob: sorry ^
09:26:46 <Arnob> myFun a b c = (a / b) `mod` c
09:27:04 <Arnob> will divid a by b
09:27:13 <Arnob> and then modulo the result by c
09:27:29 <ddellacosta> Arnob: that gives me type errors up the wazoo
09:27:29 <Iceland_jack> Arnob: what type is both an Integral and Fractional?
09:27:51 <Iceland_jack> @ty \a b c -> (a `div` b) `mod` c
09:27:51 <lambdabot> Integral a => a -> a -> a -> a
09:27:54 <Iceland_jack> this should work
09:28:12 <Iceland_jack> > (\a b c -> (a `div` b) `mod` c) 12546 1000 100
09:28:14 <lambdabot>  12
09:28:43 <ddellacosta> Iceland_jack: so, the difference between that and Arnob fn is the / vs. div, huh?
09:28:46 * ddellacosta heads to the docs
09:29:08 <Iceland_jack> ddellacosta: 'div' works for things like Int, Integer
09:29:14 <ddellacosta> Iceland_jack, Arnob: thanks to you both
09:29:21 <Iceland_jack> (/) works for things like Float, Double
09:29:36 <Iceland_jack> If you want to mix those you'll need explicit coercions
09:29:51 <Arnob> looks like (/) only works with integers while `div` works with reals
09:30:01 <Arnob> everyday I learn something new!
09:30:07 <Iceland_jack> > (\a b c -> floor (a / b) `mod` c) 12546 1000 100
09:30:09 <lambdabot>  12
09:30:20 <Iceland_jack> that's one way of mixing those
09:30:26 <ddellacosta> Arnob: seriously, me too. :-)
09:30:57 <ddellacosta> Iceland_jack: gotcha!  Great, will review the types on all of these.  Thanks again
09:32:02 <Iceland_jack> (/) is Fractional (Float, Double), mod/div are Integral (Int, Integer, Word{..}, Int{..})
09:32:19 <Iceland_jack> the Fractional/Integral part can be confusing
09:33:21 <guestGuy> enthropy: this *seems to be* what I need to do, but I need to partially apply the first function: foldl' (insertWith (+) k (1 :: Integer)) newMap xs
09:33:35 <Iceland_jack> if you think of
09:33:35 <Iceland_jack>     Fractional = {Float, Double, …}
09:33:35 <Iceland_jack>     Integral   = {Int, Integer, Word, Word8, Word16, Word32, Word64, Int8, Int16, Int32, Int64, …}
09:33:35 <Iceland_jack> then it becomes simpler
09:33:43 <guestGuy> enthropy: at least, I think that this is what you were getting at
09:34:31 <ddellacosta> Iceland_jack: so, I see there is also a Rational type, how does that relate to the Fractional type?
09:34:34 <enthropy> guestGuy: yeah, but k on it's own isn't bound to the right thing
09:34:46 <enthropy> probably it'd be best to write a lambda
09:34:50 <Iceland_jack> ddellacosta: Rational is just Ratio Integer
09:35:01 <ddellacosta> Iceland_jack: ah, I see when I type :doc, gotcha
09:35:27 <Iceland_jack> ddellacosta: If you do
09:35:27 <Iceland_jack>     ghci> :i Ratio
09:35:27 <Iceland_jack> you get information about all instances for Ratio
09:35:35 <ddellacosta> aha
09:35:46 <ddellacosta> Iceland_jack: thanks! Very helpful.
09:35:49 <Iceland_jack> For example if 'a' is Integral, 'Ratio a' is Fractional
09:36:01 <Iceland_jack>     Integral a => Fractional (Ratio a)
09:36:18 <Iceland_jack>     Integral a => Num (Ratio a)       -- and also a number
09:37:02 <ddellacosta> Iceland_jack: gotcha, okay.  Wow, I have to mess around with these for a while so I can wrap my head about how they all interrelate.  The numeric types are a bit more complex than I had imagined.
09:37:09 <Iceland_jack> they are
09:37:21 <Iceland_jack> > (\a b c -> floor (fromRational (a % b)) `mod` c) 12546 1000 100
09:37:22 <lambdabot>  12
09:37:29 <guestGuy> enthropy: lol, lambdas produce new and exciting errors: http://lpaste.net/105601
09:38:16 <enthropy> guestGuy: just because you call it 'k' doesn't make it the key to the Map
09:38:33 <enthropy> foldl :: (b -> a -> b) -> b -> [a] -> b
09:38:51 <enthropy> foldl :: (Map k a -> a -> Map k a) -> Map k a -> [a] -> Map k a
09:39:32 <akater> Where do people come to Haskell from, aside from obvious cases, like CS or mathematics departments of universities?
09:39:33 <enthropy> and you can substitute k=Char, b=Integer, if that helps
09:40:19 <Rembane> A combination of the first programming course on my computer engineering education and LYAH.
09:41:28 <narendraj9> akater: Some companies like Galios use Haskell.
09:41:32 <ddellacosta> akater: all over. I'm coming from "industry" and want to learn more about Haskell after a decade of non-functional (and recently some functional but not statically-typed) languages.
09:43:23 <monochrom> I heard of haskell from newsgroups. comp.lang.functional
09:43:49 <bergmark> i came to haskell from javascript because my unit tsets got out of hand ;-)
09:43:55 <narendraj9> Where do people go after they have mastered Haskell? I think this would be of more interest to everyone.
09:43:59 <monochrom> then again, the only reason I read comp.lang.functional was that I was from CS, so probably I don't count :)
09:44:11 <ddellacosta> narendraj9: ...mastered Haskell?
09:44:14 <bergmark> narendraj9: idris?
09:44:29 <narendraj9> idris ? ? ?
09:44:32 <monochrom> I go on my way after mastering haskell.
09:44:43 <bergmark> narendraj9: http://www.idris-lang.org/
09:44:45 <tulcod> narendraj9: one can master haskell?
09:44:58 <ddellacosta> I ascend to the heavens and program without computers after mastering Haskell, merely converting reality to new thoughtforms
09:45:08 <narendraj9> tulcod: I mean learned enough of Haskell. I don't mean to say mastered it all.
09:45:18 <ddellacosta> narendraj9: sorry to be a wise-ass. :-)
09:45:40 <narendraj9> Learned enough that they would want to work with it all the time.
09:46:11 <monochrom> before hearing of haskell, I planned and wrote programs in other languages, maybe c++ and java. after mastering haskell, I plan and write the same kind of programs, this time in haskell. that is all.
09:46:33 <ddellacosta> narendraj9: I guess the problem is that it depends on what your goals are.  If you are looking for more stuff in the direction of building proofs, for example, I suppose you'd try coq or agda, perhaps?
09:46:37 <monochrom> it is just a programming language.
09:46:51 <tulcod> haskell is a way of life
09:47:06 <narendraj9> I would want a job that uses Haskell. I really really want companies to adopt it.
09:47:12 <tulcod> it's a way to think. a reason to live
09:47:16 <tulcod> haskell is the alpha and the omega
09:47:22 <guestGuy> enthropy: thanks for all the help, unfortunately I think about everything you've written and nothing clicks (I get what the type signatures say, just been fighting with one function for a few hours too many) it just doesn't seem right to have to fight for more than an evening to use two functions
09:47:24 <noctux> monochrom: heresy!
09:47:35 <monochrom> it is like asking "after you have switched from Toyota to Mercedes, where do you go?" answer: the same places, except driving Mercedes this time.
09:47:39 <narendraj9> tulcod: truly agree!
09:47:48 <monochrom> it's just a car.
09:47:51 <guestGuy> enthropy: I should probably reread real world haskell or something similar
09:47:56 <guestGuy> enthropy: thanks again
09:48:17 <narendraj9> monochrom: But you wouldn't want writing C++ for hours in your office after that. Would you?
09:48:20 <enthropy> guestGuy: probably. The answer is something like   foldl' (\m k -> insertWith (+) k 1 m)
09:48:36 <monochrom> that is correct. nor driving Toyota.
09:48:44 <d3lxa> I've got a problem with my cabal, anyone? Could not find module `Distribution.Simple'; There are files missing in the `Cabal-1.20.0.0' package ???
09:49:32 <bergmark> d3lxa: sounds like you need to re-install Cabal
09:50:13 <d3lxa> bergmark: how? this, is the result of cabal install cabal-install
09:51:28 <bergmark> d3lxa: cabal install Cabal --reinstall, you can add --constraint="Cabal >= 1.20.01" in there too since there is a newer version
09:52:01 <bergmark> 1.20.0.1*
09:52:02 <d3lxa> bergmark: I've moved my .cabal home dir, is there an other way to clean?
09:52:15 <d3lxa> (this move resulted in the error above)
09:52:19 <Ch0c0late> Where can I find documentation for each module in Haskell? As an example I can find documentation for Array module or something else on ruby-doc.org. It's categorized under array, string, etc.
09:52:22 <rwbarton> mv .ghc too
09:52:28 <bergmark> d3lxa: oh, you shouldn't do that
09:52:43 <rwbarton> d3lxa: .ghc is where the packages are registered
09:52:45 <d3lxa> bergmark, rwbarton: ok right, what's the good way? :)
09:52:47 <monochrom> hackage has docs. your hard disk may also have docs
09:52:49 * hackagebot OpenAFP 1.4.2 - IBM AFP document format parser and generator  http://hackage.haskell.org/package/OpenAFP-1.4.2 (AudreyTang)
09:52:51 * hackagebot ghcjs-dom 0.0.10 - DOM library that supports both GHCJS and WebKitGTK  http://hackage.haskell.org/package/ghcjs-dom-0.0.10 (HamishMackenzie)
09:52:53 <heatsink> Ch0c0late, if you installed the haskell platform, the documentation is installed on your system
09:52:59 <heatsink> Location depends on which OS you have
09:53:00 <bergmark> yeah you can rm -r ~/.ghc
09:53:21 <Ch0c0late> heatsink: Ah! Thanks. I'm on OS X.
09:53:45 <d3lxa> bergmark, rwbarton: all right! thx
09:53:47 <bergmark> d3lxa: you usually want to keep ~/.cabal since it contains the cabal-install binary and other things that are a bit more work to reinstall
09:53:49 <heatsink> Ch0c0late: It's installed in /Library/Haskell/doc/start.html
09:54:06 <fread2282> how can I quickCheck a prop that takes a function?
09:54:15 <d3lxa> bergmark: just doing a cleanup, so i don't mind
09:54:24 <heatsink> You can just use quickCheck
09:54:28 <fread2282> > quickCheck (\s f -> (lines . f . unlines) == f)
09:54:30 <lambdabot>  Couldn't match type ‘GHC.Types.Char’ with ‘[GHC.Types.Char]’
09:54:30 <lambdabot>  Expected type: [GHC.Base.String] -> [GHC.Base.String]
09:54:30 <lambdabot>    Actual type: GHC.Base.String -> GHC.Base.String
09:54:43 <fread2282> > quickCheck (\s f -> (lines . f . unlines) s == s)
09:54:44 <lambdabot>  <IO ()>
09:54:45 <bergmark> d3lxa: you probably have the cabal binary that comes with ghc somewhere too
09:54:55 <fread2282> :|
09:55:07 <bergmark> d3lxa: so you can put that one in front of your path to upgrade cabal itself
09:55:10 <d3lxa> bergmark: yes, it comes from debian 1.20, then I rebuild the new version
09:55:23 <rwbarton> @check (\s f -> (lines . f . unlines) s == s)
09:55:25 <lambdabot>  *** Failed! Falsifiable (after 3 tests):
09:55:25 <lambdabot>  [] <[Char] -> [Char]>
09:55:55 <Iceland_jack> fread2282: Check out Test.QuickCheck.Function
09:56:00 <heatsink> @check (\s f -> (lines . f . unlines) s == f s)
09:56:01 <lambdabot>  Couldn't match type ‘GHC.Types.Char’ with ‘[GHC.Types.Char]’
09:56:01 <lambdabot>  Expected type: [GHC.Base.String] Actual type: GHC.Base.StringCouldn't match ...
09:56:09 <Iceland_jack> Where you can shrink and show functions
09:56:12 <monochrom> oh! I see how to falsify it now
09:56:14 <heatsink> @check (\s f -> (lines . map f . unlines) s == f s)
09:56:16 <lambdabot>  Couldn't match expected type ‘[GHC.Base.String]’
09:56:16 <lambdabot>  with actual type ‘GHC.Types.Char’Couldn't match expected type ‘GHC.Types.Cha...
09:56:49 <monochrom> err, no, I am not thinking right
09:56:59 <monochrom> > unlines "\n\n\n"
09:57:00 <lambdabot>  Couldn't match type ‘GHC.Types.Char’ with ‘[GHC.Types.Char]’
09:57:00 <lambdabot>  Expected type: [GHC.Base.String]
09:57:00 <lambdabot>    Actual type: [GHC.Types.Char]
09:57:08 <Ch0c0late> heatsink: I took a look at it and I could not find List related method(maximum, minimum, sum, null, etc.). Where can I find these?
09:57:09 <monochrom> oops
09:57:18 <Iceland_jack> ghci> quickCheck (\s (Fun _ f) -> (unlines . Data.List.map f . lines) s == f s)
09:57:18 <Iceland_jack> *** Failed! Falsifiable (after 2 tests and 4 shrinks):
09:57:18 <Iceland_jack> "a"
09:57:18 <Iceland_jack> {_->""}
09:57:21 <heatsink> They're in Prelude or Data.List
09:57:50 * hackagebot jsaddle 0.1.1.7 - High level interface for webkit-javascriptcore  http://hackage.haskell.org/package/jsaddle-0.1.1.7 (HamishMackenzie)
09:57:50 <heatsink> You found the list of module documentation, right?
09:58:19 <aristid-ic_> how can people possibly live without ScopedTypeVariables?:)
09:58:22 <d3m1g0d-> > import Data.List
09:58:24 <lambdabot>  <hint>:1:1: parse error on input ‘import’
09:58:35 <akater> I've read somewhere “people don't use static typed languages for scripting”. Did anyone find themselves using Haskell instead of standard scripting language of their OS environment?
09:58:35 <akater> Or is it some particularly strange question to pose? :-)
09:58:42 <Ch0c0late> heatsink: Yes.
09:58:59 <monochrom> by sticking to HM, aristid-ic_
09:59:15 <fread2282> akater: I'd like to, and am playing around with using it for a shell
09:59:18 <vanila> akater, I WANT to
09:59:20 <osfameron> powershell has static typing doesn't it?
09:59:22 <aristid-ic_> monochrom: but that implies not using GADTs! *gasp*
09:59:25 <vanila> i think it would be great
09:59:27 <monochrom> I use haskell for scripting
09:59:36 <heatsink> Ch0c0late, they're in Data.List
09:59:56 <Ch0c0late> heatsink: Yes, I found it. Thanks.
10:01:07 <monochrom> I think I should stop responding to "I read XXX somewhere on the internet". the internet is full of personal preferences turned into absolute truth.
10:03:25 <monochrom> not to mention that "Mr. Obama, Romney said XXX, what do you think?" belongs to journalists, not practitioners.
10:04:07 <pjdelport> <narendraj9> Where do people go after they have mastered Haskell?
10:04:15 <pjdelport> Challenge Oleg to a duel?
10:04:22 <monochrom> haha
10:05:00 <bergmark> ah that's why they never come back
10:05:44 <monochrom> where did Oleg go after he had mastered Haskell?
10:06:08 <bergmark> mu
10:09:03 <dmj`> how do I get cabal repl to load as fast as ghci, or how do I get ghci to understand my project directory like cabal-repl
10:09:51 <darthdeus> guys, why does this uncps :: ((c -> r) -> a -> r) -> a -> c; uncps f = f id;   need to have the type signature written as uncps :: (forall r. (c -> r) -> a -> r) -> a -> c ... I'm not sure how to understand the forall there
10:09:51 <dmj`> I'm using cabal exec to set the package-db to that of my sandbox, cabal repl loads the project fine, ghci throws all these module not found errors
10:11:21 <Cale> darthdeus: Delete the type signature for a moment and look at the inferred type
10:12:22 <Cale> darthdeus: You get  uncps :: ((a -> a) -> t) -> t
10:13:20 <darthdeus> hmm, now i'm even more confused
10:13:23 <Cale> The implementation of uncps is choosing r = c, so if it was supposed to work for an arbitrary r, well, that implementation doesn't work
10:14:34 <darthdeus> I still don't understand
10:14:36 <darthdeus> i mean
10:14:46 <darthdeus> what you're saying is that the implementation says this    uncps :: ((c -> c) -> a -> c) -> a -> c
10:14:49 <Cale> Also, think about implementing the type you gave at first: ((c -> r) -> a -> r) -> a -> c
10:15:12 <Cale> Okay, so I give you a function f :: (c -> r) -> a -> r, and a value x :: a
10:15:13 <darthdeus> (btw I copied this from the lens derivation wiki)
10:15:33 <Cale> To apply f, you'll need a function of type c -> r
10:15:52 <darthdeus> oh, and because it uses `id` it implies that c -> r == c -> c
10:15:54 <Cale> However, you can't possibly get a defined one, as you have no values of type r, and no ways to get one
10:16:28 <Cale> So, yeah, your implementation of uncps needs the type r to be a parameter that it can choose
10:16:32 <darthdeus> so forall here means "i dont care what r is needed,i t doesn't matter"?
10:17:09 <Cale> Think of the forall as being like an additional function parameter which happens to accept a type, and which Haskell doesn't happen to let you fill in explicitly
10:17:20 <Cale> (but must be implicitly supplied)
10:18:03 <darthdeus> so that means it tells the type system that it's ok to not be able to derive a type for that parameter?
10:18:44 <dfarm> Hi all, what's the best way to browse Haskell library docs offline? For whatever reason the hackage docs for the 'linear' package don't seem to be available so I was hoping to just generate/browse them offline...
10:19:05 <Cale> Well, this is a hard example to work with because there are so many type parameters around
10:19:08 <chrisdone> dfarm: add documentation: True to your cabal config file
10:19:13 <Cale> But let's do it anyway
10:19:22 <chrisdone> dfarm: then (re-)install the packages you want documentation for
10:19:25 <Cale> uncps :: forall a c. (forall r. (c -> r) -> a -> r) -> a -> c
10:19:38 <Cale> That's the fully elaborated type of the working uncps
10:20:02 <monochrom> dfarm: read my http://www.vex.net/~trebla/haskell/cabal-cabal.xhtml#config
10:20:04 <Cale> Now, if we had type lambdas, we'd write something like:
10:20:42 * Tjr always wondered why you'd need "forall" if type variables are for all type-values anyway.
10:20:48 <chrisdone> check this out, a shell built upon conduit: http://lpaste.net/3237031187872481280
10:20:58 <dfarm> chrisdone, ok (actually I was just looking at your haskell-docs thing on hackage.) I assume sandboxes don't really affect it (i.e., I set it globally in ~/.cabal/whatever )
10:21:07 <geekosaur> Tjr: scope
10:21:08 <Cale> uncps = /\a -> (/\c -> (\(f :: forall r. (c -> r) -> a -> r) -> f c id))
10:21:19 <dfarm> Thanks monochrom, will do.
10:21:34 <darthdeus> huh
10:21:36 <Cale> darthdeus: Where here /\ is ascii art for uppercase lambda
10:22:05 <darthdeus> I don't think I know what that means :X
10:22:06 <Cale> and it indicates a polymorphic value which accepts a type
10:22:13 <Taneb> I really like cabal's parallel builds :)
10:22:22 <darthdeus> hmm
10:22:39 <Cale> So (/\a -> ...) is something which accepts a parameter which is a type, and produces something whose type depends on the variable a
10:22:47 <monochrom> Cale, I am guessing that the story of "caller chooses vs callee chooses" is shorter and more elementary
10:23:04 <darthdeus> so /\ is like a type level lambda
10:23:21 <Cale> darthdeus: Kind of, only it's a value-level thing in this case
10:23:35 <Cale> It's just indicating that there's a parameter which is a type
10:23:44 <darthdeus> ok, that makes sense
10:23:49 <Cale> http://en.wikipedia.org/wiki/System_F has these
10:25:01 <Para__> Guys -- how can you debug/test haskell code? Like in other languages you might do logging or print statements, is there an equivalent here?
10:25:41 <Eduard_Munteanu> Para__: see Debug.Trace
10:25:42 <darthdeus> Para__: there's Debug.Trace which allows you to add arbitrary debug logging anywhere
10:25:51 <Para__> awesome, thanks!
10:26:02 <Para__> (And see, I came back!)
10:26:06 <monochrom> each of my definitions is so small or so simple, a few tests reveals what's wrong with them
10:26:17 <Cale> Para__: For the most part, I use Debug.Trace only if I'm having difficulty figuring out for which parameters my function is misbehaving
10:26:54 <monochrom> in the rare case of complete mystery, Debug.Trace helps
10:26:59 <Cale> Para__: Since Haskell functions are honest functions, i.e. given the same arguments, they always produce the same result
10:27:11 <Cale> Para__: testing things by hand in isolation is a lot more meaningful
10:27:13 <Para__> okay, so for example, someone posted this code here yesterday to compute the fibonacci sequence "better" than the recursive definition: let fibs = 0:1:zipWith (+) fibs (tail fibs) in fibs
10:27:17 <mayski> oh there's a thing like that
10:27:20 <Para__> and i'm trying to figure out exactly what it does
10:27:28 <darthdeus> damn reading wiki about existential quantification doesn't help with this example :\ it seems like a completely different thing
10:27:37 <Cale> darthdeus: It is a completely different thing
10:27:39 <luite> that's true, my program always segfaults at exactly the same place :(
10:27:50 <darthdeus> Cale: oh good
10:27:51 <Cale> darthdeus: This is higher rank types
10:27:53 <Para__> alright - thanks Cale
10:28:09 <darthdeus> Rank-N or Rank2?
10:28:28 <Cale> darthdeus: Well, rank 2 specifically in this case.
10:29:15 <Cale> Para__: Have you heard about QuickCheck?
10:29:21 <Para__> let fibs = 0:1:zipWith (+) fibs (tail fibs) in fibs
10:29:25 <Para__> no, what is that?
10:29:30 <Para__> (sorry - didn't mean to paste that)
10:29:42 <Cale> Para__: Oh, I should help you to understand this program first, perhaps :)
10:29:50 <Cale> But QuickCheck is a really nice library for testing
10:29:51 <Para__> :)
10:29:57 <Para__> I'm sorta getting the general idea
10:30:09 <Para__> of zipWith, but I'm failing to see how it keeps extending
10:30:15 <chrisdone> i wonder if one could introduce an stderr/stdout distinction in conduit
10:30:42 <Para__> and why exactly this saves computation
10:30:46 <Cale> Para__: this diagram may help a little bit to visualise what's going on: http://www.haskell.org/tutorial/fig1.gif
10:31:03 <Cale> The node marked (+) there is really zipWith (+)
10:31:32 <monochrom> Para__: the method used in my http://article.gmane.org/gmane.comp.lang.haskell.cafe/23231 may help
10:31:56 <Para__> hmm
10:32:10 <chrisdone> maybe with something like data Output bytes = Stderr bytes | Stdout bytes and then consumers just consume Stdout's and add Stderrs to leftovers
10:32:25 <Cale> Para__: If you just want to see how it's possible to compute fibs this way (and not why it's so efficient), you can simply substitute in the definition of fibs on the right hand side
10:32:43 <Cale> If fibs = 0 : 1 : zipWith (+) fibs (tail fibs)
10:33:12 <Cale> then surely  fibs =  0 : 1 : zipWith (+) (0 : 1 : zipWith (+) fibs (tail fibs))  (tail (0 : 1 : zipWith (+) fibs (tail fibs)))
10:33:27 <Cale> Just replacing each occurrence of fibs with the definition
10:33:34 <Para__> ohhhhhhhhhh
10:33:42 <darthdeus> Cale: is there some place where the Rank2Types are documented? I only found https://ghc.haskell.org/trac/haskell-prime/wiki/Rank2Types which is really short
10:34:24 <monochrom> Cale: I never understood that picture. actually, put it this way: I could not use that picture to understand the program. the other way round. after I understood the program, I used that to explain the picture. yes, it is that bad.
10:34:42 <Cale> monochrom: Interesting :)
10:34:56 <Para__> Cale, that helps a lot
10:34:58 <Para__> (the expansion)
10:35:17 <monochrom> at present, I think it is because the picture merges a time series of animation frames into one.
10:35:29 <Para__> thanks :)
10:36:05 <Cale> Para__: The occurrences of fibs in the expression at runtime are really pointers to the same place in memory, which happens to be the first (:) (the one which has 0 as its first parameter)
10:36:42 <chrisdone> funny that so many projects have been started trying to make a good shell for haskell, when inadvertently pipes and conduit have made a stable and robust way of doing so and nobody seems to've noticed yet
10:37:08 <Cale> Para__: as each element of the list is computed, it will stay in memory and not be recomputed over and over
10:37:43 <monochrom> chrisdone, the shell rush began and ended before pipes and conduits were invented.
10:37:49 <chrisdone> monochrom: yup
10:37:57 <monochrom> ("shell rush" in the same sense as "gold rush")
10:38:06 <chrisdone> there're a dozen dead shell projects in haskell
10:38:11 <chrisdone> lots of vaporware
10:38:15 <Para__> okay, it makes sense now!
10:38:21 <Tjr> @t forever
10:38:21 <lambdabot> Maybe you meant: tell thank you thanks thesaurus thx tic-tac-toe ticker time todo todo-add todo-delete type v @ ? .
10:38:35 <Para__> its gonna take a while before I instinctively think like that though
10:38:38 <Tjr> >:t forever
10:38:44 <Tjr> @help
10:38:44 <lambdabot> help <command>. Ask for help for <command>. Try 'list' for all commands
10:38:45 <Cale> Para__: Yeah, it's a clever program
10:38:58 <Tjr> @help list
10:38:58 <lambdabot> list [module|command]. Show commands for [module] or the module providing [command].
10:39:09 <deweyvm> :t forever
10:39:10 <lambdabot> Monad m => m a -> m b
10:39:17 <Tjr> deweyvm: thanks
10:39:21 <Cale> > let evens = 0 : map (+1) odds; odds = map (+1) evens in (take 5 evens, take 5 odds)
10:39:23 <lambdabot>  ([0,2,4,6,8],[1,3,5,7,9])
10:39:49 <Cale> Para__: ^^ you can even have mutual recursion :)
10:40:06 <chrisdone> monochrom: although i know gabriel plans to make a shell based on pipes somewhen
10:40:07 <Para__> oh wow thats interesting
10:40:34 <teknokratsevilla> chrisdone, then conduits and pipes are worth a look ?
10:41:01 <Cale> > let primes = 2 : filter isPrime [3,5..]; isPrime n = all (\p -> n `mod` p /= 0) (takeWhile (\p -> p*p <= n) primes) in primes
10:41:03 <lambdabot>  [2,3,5,7,11,13,17,19,23,29,31,37,41,43,47,53,59,61,67,71,73,79,83,89,97,101,...
10:41:07 <chrisdone> teknokratsevilla: i would say so, if you ever want to do streaming IO
10:41:13 <Para__> I think part of what was tripping me up earlier though, was that the 'let a in b' essentially replaces all instances of a with something else wherever they appear in b
10:41:30 <Para__> I was unclear of what in did
10:41:35 <Cale> ^^ this computes the list of all primes, while using initial portions of that very list in order to test further numbers for primality :)
10:41:41 <monochrom> oh, "in" is just separator :)
10:41:56 <Para__> wait what does the backslash before a letter mean?
10:41:57 <Para__> why \p?
10:42:02 <monochrom> that is lambda
10:42:03 <Cale> That's a lambda
10:42:10 <Cale> > (\x -> x^2) 5
10:42:11 <lambdabot>  25
10:42:12 <monochrom> almost same lambda as python's
10:42:23 <Cale> It's because \ looks a bit like λ
10:42:33 <chrisdone> did anybody make a "describe haskell syntax" function yet?
10:42:35 <Cale> but is typically much easier to type :)
10:42:35 <Para__> is that the syntax you use in haskell too or just the irc?
10:42:40 <chrisdone> a la the one in #c++
10:42:43 <Cale> In Haskell
10:42:47 <Para__> gotcha
10:42:59 <Para__> thats an interesting prime function -- I was thinking of how I'd do that earlier
10:43:00 <monochrom> I am a "describe haskell syntax" function
10:43:05 <Para__> but my version seemed much more complicated
10:43:11 <Para__> and probably would not work
10:43:25 <chrisdone> i think http://hackage.haskell.org/package/haskell-src-exts-1.13.5/docs/Language-Haskell-Exts-Syntax.html
10:43:26 <chrisdone> is the best description i've seen of haskell syntax yet
10:44:08 <monochrom> yes, for people who have learned much of haskell
10:44:25 <Cale> chrisdone: Even though it's polluted with all the weird XML extension stuff? :)
10:44:27 <ajf> Great, I guess I have to change is_numeric_string
10:44:36 <random99> Hi!
10:44:44 <random99> I have a hard time figuring out how to use random numbers in Haskell
10:44:46 <ajf> wait why did I say that in Haskell
10:44:48 <chrisdone> cale: sure, it's not that much stuff
10:44:48 <random99> please have a look at this:
10:44:49 <random99> http://lpaste.net/4926405261779795968
10:44:49 <ajf> damn you colloquy
10:44:57 <bergmark> yeah i learned new things by looking at HSE parse trees :-)
10:44:57 <monochrom> haha
10:45:03 <random99> I generate a series and take the first element of that list
10:45:16 <random99> ...but I want to then take a modulus so that I can use that number in my application
10:45:40 <random99> but that doesn't seem to work
10:45:42 <Cale> random99: You're modding the list by 10, which is a type error
10:45:46 <monochrom> ok, look up "mod" or "rem"
10:46:06 <Cale> random99: Perhaps you wanted to map (`mod` 10) (randoms g :: [Int])
10:46:27 <chrisdone> i bet you could use syb to generate a cool sample module web page that would make a sample of every single syntactical case by just enumerating all the enum types
10:46:47 <chrisdone> and you could mouse over to see what they mean and stuff
10:46:49 <Para__> question: what is the difference between \p in Haskell and lambda p: in python? Also, can you have a lambda function with more than one variable? (Like you have lambda x, y: in python)
10:47:12 <chrisdone> and use the pretty printer to show the code
10:47:13 <monochrom> or: head (randoms g :: [Int]) `mod` 10
10:47:15 <random99> Cale: Thanks, that worked! But I dont' quite get why 'mod' was a type error
10:47:25 <bergmark> chrisdone: HSE allows things that aren't valid haskell though, like newtypes with multiple constructors
10:47:26 <Cale> > (\x y -> x^2 + y^2) 3 4
10:47:28 <lambdabot>  25
10:47:36 <Cale> Para__: ^^
10:47:46 <Para__> sweet
10:47:51 <monochrom> random99, you're looking at "head (list `mod` 10)" vs "(head list) `mod` 10"
10:47:56 <Para__> should I just think of it like the anonymous function in python?
10:47:59 <Para__> or is it different?
10:48:01 <Cale> yes
10:48:05 <chrisdone> bergmark: true, you'd need to add some contraints
10:48:08 <monochrom> and "$" does not mean "do what I mean". never.
10:48:23 <Cale> Though without the weirdnesses which come from mixing this stuff with mutable variables
10:48:45 <monochrom> always eliminate $ and put in redundant parentheses to see what the computer sees.
10:49:00 <bergmark> chrisdone: we do similar things in rest-gen, take a xml/json-schema definition and generate usage examples
10:49:16 <Para__> oh alright. the 'honest' functions will probably make debugging infinitely easier in the future
10:49:24 <chrisdone> bergmark: maybe you could validate it by first generating the expression, printing it, then trying to parse it. if it doesn't parse, discardi t
10:49:24 <Para__> debugging/writing code
10:49:51 <chrisdone> hmm i kinda want to try this now =p
10:49:52 <bergmark> need to switch to JsonGrammar though :3
10:50:08 <chrisdone> the bidirectional one?
10:50:11 <bergmark> aye
10:50:14 <chrisdone> that is sweet
10:50:26 <chrisdone> martijn is ace
10:50:42 <bergmark> it has an ADT representation internally so we can use it to generate schemas
10:50:43 <Cale> Para__: Yeah, it does. You generally spend a lot less time debugging, even if you include all the extra time it takes to get things to compile in the first place.
10:51:32 <bergmark> we already derive schemas generically, but there's no guarantee it matches the aeson instances
10:51:33 <Cale> Para__: It's a lot quicker to have the compiler tell you where all the problems are than having to track them down by looking at broken runtime behaviour, after all. :)
10:51:40 <random99> thanks, Cale & monochrom!
10:51:45 <Para__> true!
10:51:54 <Para__> I'm starting to really like Haskell
10:53:17 <Cale> (well, it doesn't catch *everything*, but the bugs which are left tend to be the really interesting ones)
10:53:26 <chrisdone> oh yeah, we were thinking more about the lazy printer (present), one of problem is many data types just don't have Data instances, so we thought instead to use TH to use reify and look inside the types that way
10:53:48 <bergmark> :-(
10:54:03 <chrisdone> yeah, it sucks, but i don't know another way to do it
10:54:51 <chrisdone> if a library you're using forgot to add a Typebale instance, you can't use deriving anymore >7.8, so it's just like "you can't inspect this type or any type using it, enjoy your life"
10:56:04 <chrisdone> that we're still using Show instances is a bit lame, so we have to nudge the haskell community into better places
10:56:06 <f-a> naive question: I have :set promt to "λ> " in ghci, but how do I save this option, so not to have to do it again every time I restart ghci?
10:56:17 <bergmark> adding all these instances can be kind of ugly too, if you have smart constructors you can't guarantee that everything will go through them
10:56:19 <chrisdone> add it to your ~/.ghci file
10:56:29 <f-a> oh,
10:56:44 <darthdeus> huh what's phabricator? :O
10:56:45 <f-a> thanks chrisdone , I probably overlooked it in reading mank ghci
10:56:49 <chrisdone> bergmark: true, Data can get around encapsulation
10:56:59 <chrisdone> as can TH, iirc
10:57:00 <Para__> alright, I gotta go, I'll see you all later
10:57:53 <chrisdone> though encapsulation's just a suggestion not a security thing, if people are going around it they deserve whatever hounds of hell they release
10:57:55 <bergmark> i'm still happily ignorant of TH :-)
10:57:57 <enthropy> you can write data instances that pretend to have constructors of whatever you pass into the "smart constructors"
10:58:35 <bergmark> enthropy: oh! that's cool
10:58:37 <chrisdone> bergmark: i wrote some TH today =p
10:58:49 <bergmark> chrisdone: :-(
10:58:51 <chrisdone> https://github.com/chrisdone/hell/blob/master/src/Hell/TH.hs#L18
10:58:58 <chrisdone> bergmark: no it's cool =p
10:59:06 <chrisdone> you can't write this in normal haskell
10:59:21 <bergmark> what about generics?
10:59:26 <enthropy> bergmark: for example the HListFlat in http://hackage.haskell.org/package/HList-0.3.4.1/docs/Data-HList-Data.html
10:59:27 <bergmark> (those are cool)
10:59:47 <monochrom> part of why most software systems are so fragile to tiny changes is that they take encapsulation as suggestion not security
10:59:50 <chrisdone> here's what it does: it looks at all your binaries in your PATH and then generates a top-level declaration of name args = runProcess "name" args
11:00:13 <chrisdone> so you can just write ls ["hi"] in the hell shell =3
11:00:16 <bergmark> chrisdone: ah! doesn't sound like generics material :-)
11:00:46 <chrisdone> yeah, generating names seems to be TH's best and most appropriate use-case
11:00:54 <monochrom> and part of why your user-land programs, despite being so fragile, segfault all the time and still can't crash the OS is that the OS takes encapsulation as security not suggestion
11:00:59 <chrisdone> example, i run mplayer here: http://lpaste.net/3237031187872481280
11:02:31 <ab9rf> monochrom: when i worked on the gimp back in the 90s, one of things we did was test the daylights out of the API for encapsulation violations.  wefound literally hundreds of bugs where an API call could crash the core code.
11:03:16 <ab9rf> monochrom: in the 80s, i worked on a project that involved feeding random garbage (random data) into various programs to see how they handled it.  we managed to crash about 60% of the standard UNIX utilities
11:03:44 <ab9rf> quite a few had printf-related bugs
11:04:02 <chrisdone> monochrom: partly the problem is people are poor judges at determining what should be encapsulated
11:04:57 <ab9rf> chrisdone: programmers tend to be good at figuring out how things "should work"
11:05:24 <ab9rf> not at how they shouldn't :)
11:05:44 <ab9rf> i have to admit, taking torts helped with that aspect of the process
11:05:45 <chrisdone> static types and module boundaries do help with this
11:05:58 <chrisdone> starting with "can't do anything" and work your way up does tend to be effective
11:06:19 <Redz> > read $ if b then "42" else True
11:06:19 <chrisdone> ab9rf: they took your tots?
11:06:19 <Redz> is this example solvable with ExistentialQuantification or RankNTypes or something?
11:06:20 <lambdabot>  Couldn't match expected type ‘GHC.Types.Bool’
11:06:20 <lambdabot>              with actual type ‘Debug.SimpleReflect.Expr.Expr’Couldn't match t...
11:06:20 <lambdabot>  Expected type: GHC.Base.String
11:06:20 <lambdabot>    Actual type: GHC.Types.Bool
11:06:27 <monochrom> on DOS, a friend once made a pointer error. out of sheer luck in the memory content, it ended in calling up the BIOS to low-level format the hard disk
11:06:28 <teknokratsevilla> hmm, haskell based OSes ?
11:06:40 <teknokratsevilla> a bit hard...
11:06:52 <chrisdone> monochrom: haha, sheer ‘luck’
11:07:27 <ab9rf> chrisdone: no, Torts, it's a class in law school.
11:07:46 <bergmark> Redz: no, read is not polymorphic in its argument
11:07:57 <ab9rf> monochrom: ha, that's awesome
11:08:28 <darthdeus> anyone knows how I can make interactive mode in haskell-mode in emacs not show errors in a split buffer when I <enter> an error in the repl?
11:08:39 <darthdeus> chrisdone: i bet you'd know :)
11:08:42 * chrisdone yawns reflexively at the mention of law school
11:08:58 <chrisdone> darthdeus: yeah there's a setting for that
11:09:11 <darthdeus> I was browsing the source code, but couldn't find it
11:09:16 <akater> teknokratsevilla: I'm a Windows user for about 13 years by now. Got interested in Haskell after wondering how to keep OS control by users as clean (≈ as side-effect free) as possible.
11:09:23 <chrisdone> M-x customize-variable haskell-interactive-popup-errors
11:09:45 <akater> teknokratsevilla: …since I ended up using Mathematica for every non-trivial task.
11:10:09 <darthdeus> chrisdone: I don't seem to have that
11:10:14 <chrisdone> darthdeus: pull =p
11:10:35 <darthdeus> lol :P does melpa always have the latest version?
11:10:40 <chrisdone> darthdeus: your version is so, like, 5 minutes ago
11:10:52 <chrisdone> darthdeus: mmm, perhaps you have to recompile your melpa thing
11:10:54 <Redz> bergmark: could i make a function that is polymorphic and working for that case?
11:11:07 <chrisdone> it seems that whatever people are using to use this melpa doesn't properly recompile when it updates
11:11:31 <bergmark> Redz: i don't understand what that function is supposed to do
11:11:36 <chrisdone> darthdeus: run make in the directory, if there is a directory
11:11:55 <stephenmac7> How would I go about applying (Just id) to [1,2,3]?
11:12:03 <Redz> bergmark: oh. i mean show, not read. sorry.
11:12:04 <stephenmac7> As an example.
11:12:20 <Cale> Redz: You're better off just moving the occurrences of show inward
11:12:21 <darthdeus> recompiling
11:12:22 <chrisdone> > fmap ($ [1,2,3]) (Just id)
11:12:25 <lambdabot>  Just [1,2,3]
11:12:31 <bergmark> Redz: so if you have "42" you want the result to be "\"42\"" ?
11:12:43 <Cale> if b then show "42" else show True
11:12:54 <chrisdone> > fmap ($ [1,2,3]) (Just reverse)
11:12:55 <lambdabot>  Just [3,2,1]
11:12:56 <Redz> bergmark: its just an reduced example.
11:13:07 <stephenmac7> chrisdone: I meant to each value
11:13:11 <stephenmac7> Sorry I didn't make that clear
11:13:31 <darthdeus> chrisdone: wow, reinstalled and it's there :O
11:13:34 <chrisdone> > fmap (map [1,2,3]) (Just (+2))
11:13:35 <lambdabot>  Couldn't match expected type ‘a0 -> b’ with actual type ‘[t0]’Couldn't match...
11:13:39 <chrisdone> darthdeus: neat
11:14:03 <Redz> bergmark: i'm a bit dizzy today.
11:14:11 <darthdeus> is there a way to not show the popup but keep the input from the previous command?
11:14:34 <chrisdone> stephenmac7: nope. but M-p goes up in the history
11:14:58 <stephenmac7> What is M-p?
11:15:06 <chrisdone> oh, woops
11:15:10 <chrisdone> darthdeus: nope. but M-p goes up in the history
11:15:17 <monochrom> heh
11:15:43 <chrisdone> > fmap (flip map [1,2,3]) (Just (+2))
11:15:44 <lambdabot>  Just [3,4,5]
11:15:50 <snyp> Why does Monoid require a concat operation? Mathematically, monoids only require (existence of) identity element and an associative addition operation, right?
11:16:05 <chrisdone> this answers a version of your question, but i suspect more details are forthcoming
11:16:16 <snyp> (I have no knowledge of group theory btw. just some linear algebra)
11:16:24 <stephenmac7> chrisdone: Nope, it was just conceptural
11:16:27 <stephenmac7> *conceptual
11:16:30 <chrisdone> snyp: it's just a bad name for the associative operation
11:16:46 <stephenmac7> Just wanted to know if there was something like an Applicative where the arguments are different types
11:16:47 <snyp> chrisdone, concat?
11:16:48 <chrisdone> it should've been mop or something or (<>)
11:17:23 <snyp> but isn't the associative operation mappend ?
11:17:45 <stephenmac7> Is it possible to have a recursive lambda?
11:17:45 <chrisdone> oh, i assumed you were referring to mappend
11:17:51 <chrisdone> concat isn't a required part of Monoid
11:17:55 <snyp> ah
11:17:58 <snyp> ok
11:18:17 <chrisdone> you can just leave it out and it's implemented as a fold of the other two methods
11:18:18 <snyp> (mconcat*)
11:18:26 <snyp> i see..
11:18:43 <chrisdone> BUT, if you have a faster way to implement mconcat
11:18:46 <chrisdone> then it's nice to have it in the class
11:19:18 <snyp> ah.
11:20:31 <chrisdone> not that i can think of a custom implementation of mconcat off the top of my head
11:21:10 <chrisdone> aha!
11:21:14 <chrisdone> vectors
11:21:22 <chrisdone> they have a custom implementation of mconcat
11:21:37 <chrisdone> http://hackage.haskell.org/package/vector-0.10.11.0/docs/src/Data-Vector.html#Vector
11:21:47 <chrisdone> mconcat = G.concat
11:23:30 <snyp> chrisdone, G is for global?
11:23:39 <chrisdone> as a foldr mappend mempty would allocate an empty vector and append lazily, whereas what you really want is to flatten things out and do a foldl
11:23:39 <pjdelport> stephenmac7: It is possible with a helper like fix.
11:23:59 <stephenmac7> pjdelport: What is fix?
11:24:03 <pjdelport> :t fix
11:24:04 <lambdabot> (a -> a) -> a
11:24:11 <pjdelport> @src fix
11:24:11 <lambdabot> fix f = let x = f x in x
11:24:12 <stephenmac7> Not in scope on ghci
11:24:12 <chrisdone> snyp: it's here: http://hackage.haskell.org/package/vector-0.10.11.0/docs/src/Data-Vector-Generic.html#concat
11:24:46 <stephenmac7> Isn't that just fix f = f $ fix f?
11:24:47 <chrisdone> the vector package is sweet
11:24:52 <pjdelport> stephenmac7: It's defined in Data.Function, IIRC, but as you can see it's pretty simple
11:25:04 <chrisdone> fix is Control.Monad.Fix
11:25:08 <stephenmac7> It just passes the function to itself.
11:25:28 <stephenmac7> I guess that won't work in a strict language.
11:25:34 <monochrom> stephenmac7: yes if you don't care about redundant computing. no if you do.
11:25:40 <chrisdone> not without wrapping in lambdas
11:26:32 <akater> By the way, Mathematica handles recursive anonymous functions beautifully: 0th argument of a (pure) function is the function itself. :-)
11:26:53 <stephenmac7> Now, what would happen if you wanted to write fix as a lambda?
11:26:59 <wz1000> stephenmac7: Check out y combinators
11:27:02 <bergmark> akater: javascript also does that ;-) arguments.callee
11:27:19 <stephenmac7> wz1000: y combinators?
11:27:21 <pjdelport> \f -> let x = f x in x
11:27:32 <stephenmac7> If I look that up I get some funding website.
11:27:43 <wz1000> stephenmac7:  http://mvanier.livejournal.com/2897.html
11:28:03 * hackagebot bytestring-handle 0.1.0.2 - ByteString-backed Handles  http://hackage.haskell.org/package/bytestring-handle-0.1.0.2 (GaneshSittampalam)
11:28:05 * hackagebot freenect 1.1.1 - Interface to the Kinect device.  http://hackage.haskell.org/package/freenect-1.1.1 (ChrisDone)
11:28:07 <pjdelport> stephenmac7: https://en.wikipedia.org/wiki/Fixed-point_combinator
11:28:13 <stephenmac7> Looks complicated
11:28:15 <wz1000> stephenmac7: search for y combinator functional programming
11:28:24 <chrisdone> adam boërgmirk
11:28:26 <luite> chrisdone: ooh, does that also work with the new kinect?
11:28:36 <pjdelport> stephenmac7: The Y combinator is a version of the fixed-point combinator that works in strict languages, like Scheme/Lisp.
11:28:45 <wz1000> stephenmac7: It's quite simple really
11:28:49 <bergmark> chrisdone: that's me! ??
11:28:52 <chrisdone> luite: don't know! i've only used the  regular kinect
11:29:00 <stephenmac7> Okay, I'll ask if I don't get something.
11:29:04 * chrisdone . o O ( there's a new one? )
11:29:25 <stephenmac7> Though it seems the article claims there's a "lazy y combinator" and a "strict y combinator"
11:29:26 <luite> chrisdone: the xbox one has an updated version, higher resolution, wider view and much more accurate
11:29:56 <luite> chrisdone: the xbox 360 kinect uses an infrared dot pattern to build the depth map
11:30:32 <wz1000> stephenmac7: Basically, since the function doesn't have a name to call itself recursively, you have to pass the function to itself so that it can call itself
11:30:44 <benzrf> :t fix
11:30:45 <luite> chrisdone: the new one has a time of flight camera and a light source, it estimates depth by measuring the time it takes from a photon from the kinect's light source to reflect back to the camera
11:30:45 <lambdabot> (a -> a) -> a
11:31:08 <chrisdone> luite: i honestly have no idea what xboxes are other than a thing people play pokemon on =p i just bought the device when i saw it in the store
11:31:22 <stephenmac7> wz1000: But, if you only have a lambda once, how can you use it without binding it to a name?
11:31:26 <benzrf> :t fix `asAppliedTo` \self arg -> if arg == 1 then arg else self (arg * (arg - 1))
11:31:27 <lambdabot> (Num a, Eq a) => ((a -> a) -> a -> a) -> a -> a
11:31:38 <chrisdone> luite: ah, okay, mine doesn't have a flight camera or light source
11:31:46 <benzrf> let fac = fix $ \self arg -> if arg == 1 then arg else self (arg * (arg - 1)) in fac 3
11:31:52 <benzrf> > let fac = fix $ \self arg -> if arg == 1 then arg else self (arg * (arg - 1)) in fac 3
11:31:57 <lambdabot>  mueval: ExitFailure 1
11:32:00 <benzrf> u wot
11:32:01 <benzrf> > let fac = fix $ \self arg -> if arg == 1 then arg else self (arg * (arg - 1)) in fac 3
11:32:03 <chrisdone> luite: mine's the basic infra red dots
11:32:07 <lambdabot>  mueval: ExitFailure 1
11:32:11 <benzrf> lambdabot: your a but
11:32:25 <benzrf> :t let fac = fix $ \self arg -> if arg == 1 then arg else self (arg * (arg - 1)) in fac
11:32:26 <lambdabot> (Num a, Eq a) => a -> a
11:32:29 <benzrf> -.-
11:32:31 <monochrom> chrisdone: how dare you to belittle xbox so! of course a self-respecting gamer uses xboxes for Civ Rev!
11:32:33 <chrisdone> luite: do you have one of the new ones?
11:32:35 <benzrf> oh wait im a idiot
11:32:37 * benzrf facepalms
11:32:46 <wz1000> Lets say we have a anonymous factorial function (\x - > if x == 0 then 1 else x *(<Something> (x-1))
11:32:49 <benzrf> > let fac = fix $ \self arg -> if arg == 1 then arg else arg * self (arg - 1) in fac 3
11:32:51 <lambdabot>  6
11:32:53 <benzrf> Y combinator baby
11:32:54 <chrisdone> monochrom: civ =)
11:33:31 <chrisdone> luite: tho fwiw i use the freenect C API, so if *they* support it, it'll probably be an easy migrate
11:33:32 <benzrf> @src fix
11:33:32 <lambdabot> fix f = let x = f x in x
11:33:47 <monochrom> fix doesn't use the Y combinator trick
11:33:48 <benzrf> ^this works for the above example cuz of lazy eval
11:33:53 <benzrf> monochrom: phooey
11:34:04 <monochrom> Y combinator also requires non-strictness
11:34:08 <luite> chrisdone: nope, they're not available here yet. but i think the technology is quite cool, that you can time millions of things at light speed at the same time, with an inexpensive consumer electronics device
11:34:20 <stephenmac7> monochrom: Seems it's possible in a strict language
11:34:24 <benzrf> fix f = let x = (\self arg -> if arg == 1 then arg else arg * self (arg - 1)) x in x
11:34:37 <benzrf> fix f = let x = arg -> if arg == 1 then arg else arg * x (arg - 1) in x
11:34:40 <monochrom> the strict one takes a concession
11:34:42 <benzrf> ^recursion!
11:34:44 <chrisdone> luite: sounds pretty awesome, i'll have to see it in action. i guess then the only bottleneck is throughput through software
11:35:00 <benzrf> wait i left off a \
11:35:10 <stephenmac7> wz1000: Okay.
11:35:31 <luite> chrisdone: the trick is a modulated light source and a very high frequency electronic shutter in the camera, so they can measure the phase shift between the source and target
11:35:38 <chrisdone> luite: reminds me of a TED talk i saw where a guy describes a project to transmit high bandwidth data via light instead of bluetooth or infrared
11:35:51 <wz1000> but we don't know what that somthing is, so we take it as an argument
11:36:07 <chrisdone> luite: right. super super high frequency
11:36:26 <stephenmac7> Got it.
11:37:02 <chrisdone> luite: what's the range like on it?
11:37:10 <wz1000> define a fixed factorial function yourself, and then we'll apply the y combinator to it
11:38:25 <stephenmac7> wz1000: \length (x:xs) if null l then 0 else 1 + length xs
11:38:32 <luite> chrisdone: hmm, not sure, they made it wider angle to make it more usable at short range
11:38:49 <stephenmac7> Actually, that doesn't work
11:39:02 <wz1000> It won't
11:39:06 <stephenmac7> \length l if null l then 0 else 1 + (tail l)
11:39:11 <monochrom> yeah
11:39:12 <stephenmac7> * l ->
11:39:43 <monochrom> > fix (\length l -> if null l then 0 else 1 + (tail l)) [5,4,3,2,1]
11:39:44 <lambdabot>  No instance for (GHC.Show.Show a0)
11:39:44 <lambdabot>    arising from a use of ‘M237127483267186161325241.show_M2371274832671861613...
11:39:44 <lambdabot>  The type variable ‘a0’ is ambiguous
11:39:44 <lambdabot>  Note: there are several potential instances:
11:39:44 <lambdabot>    instance [safe] GHC.Show.Show
11:40:03 <monochrom> oh, you forgot to call
11:40:09 <monochrom> > fix (\length l -> if null l then 0 else 1 + length (tail l)) [5,4,3,2,1]
11:40:09 <stephenmac7> :P
11:40:10 <lambdabot>  5
11:40:35 <monochrom> but you got the idea right. you just made some typos
11:40:53 <stephenmac7> So, that assumes we have the fix function
11:41:13 <wz1000> (\length_function xs -> if null xs then 0 else 1 + (length_function length_function (tail xs)))
11:41:18 <chrisdone> luite: sweet. yeah the old kinect has to be 0.7m - 6m, that 0.7m minimum is a PITA if you want a desktop toy
11:41:20 <monochrom> in an untyped language, replacing "fix" by "Y" works
11:41:32 <wz1000> that is your function
11:41:38 <chrisdone> luite: as the kinect itself is massive and there're few decent places to fit it on a desk
11:41:44 <stephenmac7> wz1000: Ah, that's cool.
11:41:54 <chrisdone> so those other little ones that are springing up are also cool
11:42:08 <wz1000> We'll it won't work yet
11:42:20 <wz1000> Can you tell me why?
11:42:32 <stephenmac7> No, I can't tell why.
11:42:37 <stephenmac7> Looks fine
11:43:04 <wz1000> it take two inputs, a length function and a list
11:43:11 <stephenmac7> Oh.
11:43:17 <stephenmac7> We don't have the length function
11:43:33 <wz1000> but we don't have a length funtion, thats why we are defining it
11:44:20 <wz1000> notice we are applying length_function to itself and the remaining list
11:44:28 <stephenmac7> That makes sense.
11:45:08 <stephenmac7> Maybe we can make something like (\f -> f f) ?
11:45:13 <wz1000> So, we are assuming the length function is the same as the function we just defined
11:45:15 <luite> chrisdone: hmm, can't find details now, but I think their shutter uses SiGe or GaAs transistors for the high frequency. the technique is called range gating
11:45:27 <wz1000> yeah, you just invented the y combinator
11:45:53 <benzrf> stephenmac7: no, that doesn't work
11:45:58 <wz1000> @let y f x = f f x
11:46:00 <lambdabot>  .L.hs:151:11:
11:46:00 <lambdabot>      Occurs check: cannot construct the infinite type:
11:46:00 <lambdabot>        t1 ~ t1 -> t2 -> t
11:46:00 <lambdabot>      Relevant bindings include
11:46:00 <lambdabot>        x :: t2 (bound at .L.hs:151:5)
11:46:03 <luite> chrisdone: the new kinect is bigger
11:46:10 <benzrf> stephenmac7: think about it
11:46:22 <benzrf> let's say 'f' is the factorial function mentioned earlier
11:46:43 <benzrf> stephenmac7: when it calls the passed callback in order to recurse, it will pass the number as the /first/ argument
11:46:53 <wz1000> @src fix
11:46:54 <lambdabot> fix f = let x = f x in x
11:47:00 <benzrf> > let fac = fix $ \self arg -> if arg == 1 then arg else arg * self (arg - 1) in fac 3
11:47:01 <lambdabot>  6
11:47:05 <benzrf> stephenmac7: look there
11:47:19 <stephenmac7> Oh. I see, and we're passing in the one that takes one argument
11:47:22 <benzrf> stephenmac7: if we used your definifion, it would need to be 'self self (arg - 1)', not 'self (arg - 1)'
11:47:28 <cschneid>     Not in scope: type constructor or class ‘ToJson’ --- I'm importing Data.Aeson in this file - why is it not finding that class?
11:47:29 <stephenmac7> (\f -> f (f f))
11:47:36 <benzrf> stephenmac7: you're only delaying it one layer
11:47:38 <stephenmac7> But then you'll just fix it once
11:47:40 <benzrf> yep
11:47:49 <stephenmac7> (\f -> f (f (f (f (f...
11:47:52 <benzrf> stephenmac7: ;)
11:47:58 <benzrf> that is, in fact, what fix does
11:48:04 <benzrf> it applies a function to itself to itself etc
11:48:05 <benzrf> @src fix
11:48:06 <lambdabot> fix f = let x = f x in x
11:48:17 <stephenmac7> f (fix f)
11:48:21 <benzrf> stephenmac7: correct!
11:48:25 <stephenmac7> f (f (fix f))
11:48:30 <monochrom> is this discussing going around in a circle?
11:48:33 <benzrf> the traditional definition of Y is:
11:48:40 <benzrf> y f = f (y f)
11:49:07 <stephenmac7> The article linked to claims that isn't a "combinator"
11:49:19 <benzrf> there is also a lambda version, but i cannot recall it atm
11:49:27 <benzrf> i'd figure it out but i g2g for a sec
11:49:29 <benzrf> brb
11:49:59 <wz1000> use a y to contruct the lambda definition of y :P
11:50:30 <monochrom> (\f -> (\x -> f (x x)) (\x -> f (x x)))
11:51:20 <joelteon> :t \f -> (\x -> f (x x)) (\x -> f (x x))
11:51:21 <lambdabot>     Occurs check: cannot construct the infinite type: t0 ~ t0 -> t
11:51:21 <lambdabot>     Expected type: t0 -> t
11:51:22 <lambdabot>       Actual type: (t0 -> t) -> t
11:51:29 <joelteon> There's a way to annotate that to make it typecheck, right?
11:51:49 <monochrom> no. there is a way to go through a newtype to work around it
11:52:02 <Tjr> joelteon: (newbie here) what's this lambda good for?
11:52:05 <benzrf> joelteon: the classic lambda Y is used in the lambda calc
11:52:08 <joelteon> Tjr, I have no idea
11:52:11 <stephenmac7> Tjr: Absolutely nothing
11:52:12 <joelteon> i'm sure it's good for something though
11:52:13 <benzrf> which is untyped :v
11:52:14 <stephenmac7> It seems
11:52:24 <Tjr> ok
11:52:26 <stephenmac7> http://citeseer.ist.psu.edu/mcadams01practical.html
11:52:32 <benzrf> Tjr: it can be used for recursion without any name bindings
11:52:38 <stephenmac7> ^ Y in Practical Programs
11:52:53 <benzrf> Tjr: which is useful in the lambda calculus, since it doesn't /have/ name bindings
11:53:01 <benzrf> beyond standard lambda arg bindings, i mean
11:53:07 <stephenmac7> Not that I actually visited the link
11:53:25 <stephenmac7> So, in haskell it can't be done
11:53:26 <wz1000> lambdas are pretty cool
11:53:49 <stephenmac7> Then again, I guess it's not useful in Haskell
11:53:52 <Tjr> ah, that's why we have map and foldr, but no function that does recursion for us.
11:54:09 <benzrf> stephenmac7: well, haskell does have fix ;)
11:54:16 <joelteon> Tjr, we have fix
11:54:16 <benzrf> which is functionally equivalent
11:54:20 <benzrf> @src fix
11:54:20 <lambdabot> fix f = let x = f x in x
11:54:26 <stephenmac7> Yes, but it doesn't have the "real one"
11:54:33 <monochrom> we are going around in a circle
11:54:34 <stephenmac7> Maybe that's why the examples are in scheme
11:54:48 <Tjr> monochrom: we are recursing :-)
11:54:49 <stephenmac7> monochrom: It's recursion, of course we're going around in circles
11:55:02 <monochrom> yes, I agree
11:55:13 <stephenmac7> I'm not sure it's total recursion though
11:55:14 <wz1000> :t fix
11:55:15 <lambdabot> (a -> a) -> a
11:55:28 <benzrf> > fix (1:)
11:55:29 <lambdabot>  [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1...
11:55:37 <benzrf> > fix Just
11:55:38 <lambdabot>  Occurs check: cannot construct the infinite type:
11:55:38 <lambdabot>    a ~ Data.Maybe.Maybe a
11:55:39 <lambdabot>  Expected type: a -> a
11:55:39 <lambdabot>    Actual type: a -> Data.Maybe.Maybe a
11:55:42 <benzrf> meh
11:55:47 <benzrf> oops
11:55:48 <Tjr> > fix fix
11:55:48 <stephenmac7> That's actually pretty cool
11:55:49 <lambdabot>  Occurs check: cannot construct the infinite type: a ~ a -> a
11:55:49 <lambdabot>  Expected type: (a -> a) -> a -> a
11:55:49 <lambdabot>    Actual type: (a -> a) -> a
11:55:58 <benzrf> > fix (++"foo")
11:56:02 <lambdabot>  mueval-core: Time limit exceeded
11:56:04 <pjdelport> stephenmac7: Haskell's fix is arguably closer to the ideal of a fixed-point combinator than the Y combinator (which is mainly there to work around strictness)
11:56:10 <benzrf> ^that doesnt work because you cant lazily expand it
11:56:21 <random99> I've to an issue with input handling
11:56:23 <benzrf> > fix Void
11:56:25 <lambdabot>  Not in scope: data constructor ‘Void’
11:56:31 <benzrf> @let data Void = Void Void
11:56:31 <random99> I've constructed a data type for directional input
11:56:34 <lambdabot>  Defined.
11:56:36 <benzrf> > fix Void
11:56:37 <lambdabot>  No instance for (GHC.Show.Show L.Void)
11:56:37 <lambdabot>    arising from a use of ‘M250889743258227495025529.show_M2508897432582274950...
11:56:37 <stephenmac7> > (\x -> fix (x:)) "test"
11:56:39 <lambdabot>  ["test","test","test","test","test","test","test","test","test","test","test...
11:56:39 <benzrf> oops
11:56:43 <random99> but I would like to print an error message when the input was wrong
11:56:44 <benzrf> @undefine
11:56:44 <lambdabot> Undefined.
11:56:48 <random99> how would I do this in Haskell?
11:56:50 <stephenmac7> Pretty cool, easy implementation of repeat
11:56:51 <benzrf> @let data Void = Void Void deriving (Show)
11:56:53 <lambdabot>  Defined.
11:56:55 <benzrf> > fix Void
11:56:56 <lambdabot>  Void (Void (Void (Void (Void (Void (Void (Void (Void (Void (Void (Void (Void...
11:56:57 <stephenmac7> @src repeat
11:56:57 <lambdabot> repeat x = xs where xs = x : xs
11:56:57 <random99> here is the code: http://lpaste.net/4777391388624945152
11:57:05 <random99> note that it compiles if I remove the last line
11:57:09 <benzrf> alternatively
11:57:12 <benzrf> repeat x = x:repeat x
11:57:24 <stephenmac7> or this: repeat x = fix (x:)
11:57:33 <benzrf> :)
11:57:43 <Adeon> it's application all the way down
11:57:50 <benzrf> @let Peano = Z | S Peano
11:57:51 <lambdabot>  Parse failed: Parse error: |
11:57:55 <benzrf> @let data Peano = Z | S Peano
11:57:56 <lambdabot>  Defined.
11:58:01 <benzrf> > fix S
11:58:02 <Cale> random99: Your problem is that putStrLn "..." :: IO () while the other branches, e.g.  return Up :: IO Direction  or whatever
11:58:02 <lambdabot>  No instance for (GHC.Show.Show L.Peano)
11:58:02 <lambdabot>    arising from a use of ‘M773259209389273124925603.show_M7732592093892731249...
11:58:05 <benzrf> meh
11:58:07 <benzrf> @undefine
11:58:07 <lambdabot> Undefined.
11:58:13 <benzrf> @let data Peano = Z | S Peano deriving (Show, Eq, Ord)
11:58:14 <lambdabot>  Defined.
11:58:15 <benzrf> > fix S
11:58:17 <lambdabot>  S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S...
11:58:19 <stephenmac7> Hope no one tries to look through the chat log...
11:58:19 <benzrf> ^lazy infinity!!!
11:58:21 <Cale> random99: Perhaps you want to immediately captureMove again after?
11:58:30 <benzrf> stephenmac7: you know peano numbers right
11:58:36 <stephenmac7> ?
11:58:37 <stephenmac7> No
11:58:38 <Cale> random99: like  do putStrLn "use wasd..."; captureMove
11:58:46 <benzrf> stephenmac7: they're a simple way of representing the whole numbers from scratch
11:58:55 <benzrf> Z is 0, S n = n + 1
11:59:00 <random99> oh, that's a nicd solution. Thanks!
11:59:07 <random99> This is all just a workaround
11:59:08 <random99> ideally
11:59:13 <gilligan-> evening
11:59:14 <stephenmac7> S (S (S Z)))) is 3?
11:59:16 <benzrf> yep
11:59:18 <random99> I would like to monitor the wasd keys and react to the button presses
11:59:29 <stephenmac7> Kind of the (() () ()) in the little schemer
11:59:29 <random99> instead of "w" + ENTER like it is now
11:59:41 <pjdelport> ~ S me a long, you're the Peano man ~
11:59:43 <benzrf> @let peanoPlus Z v = v; peanoPlus v Z = v; peanoPlus (S x) (S y) = S (S (peanoPlus x y))
11:59:43 <Cale> random99: Well, there's getChar
11:59:45 <lambdabot>  Defined.
11:59:50 <Tjr> random99: how about getChar?
11:59:55 <benzrf> @let peanoPlus (S (S (S Z)))
11:59:55 <lambdabot>  Parse failed: TemplateHaskell is not enabled
12:00:00 <benzrf> > peanoPlus (S (S (S Z)))
12:00:01 <lambdabot>  No instance for (Data.Typeable.Internal.Typeable L.Peano)
12:00:01 <lambdabot>    arising from a use of ‘M486496303162355842425665.show_M4864963031623558424...
12:00:02 <stephenmac7> Come to think of it, I think the little schemer had something about the Y in it and I kind of skipped over it.
12:00:03 <benzrf> derp
12:00:04 <Cale> random99: and you can turn off local echo to prevent the key from being printed to the terminal
12:00:06 <benzrf> > peanoPlus (S (S (S Z))) (S Z)
12:00:06 <joelteon> benzrf, please take it to a PM
12:00:07 <lambdabot>  S (S (S (S Z)))
12:00:12 <pjdelport> random99: To take character input like that is a bit more complex; you actually have to fiddle with the terminal mode.
12:00:13 <benzrf> joelteon: i am trying to demonstrate to stephenmac7
12:00:26 <benzrf> stephenmac7: anyway you can instance that to Num
12:00:27 <Tjr> random99: getChar will still not read a single char due to buffering, but maybe you could fiddle around with hSetBuffering on the standard input
12:00:28 <benzrf> therefore...
12:00:29 <joelteon> did stephenmac7 ask for the demonstration
12:00:30 <benzrf> > fix S
12:00:32 <lambdabot>  S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S...
12:00:35 <benzrf> ^lazy infinity!!!
12:00:37 <Cale> hSetEcho stdin False  (after importing System.IO)
12:00:38 <pjdelport> Oh, wait, or does getChar already do that?
12:00:42 <benzrf> it's > you
12:00:47 <stephenmac7> benzrf: Very cool.
12:00:51 <benzrf> :-O
12:00:54 <stephenmac7> Does haskell have that anyway?
12:01:00 <benzrf> float inifnity maybe
12:01:02 <benzrf> *infinity
12:01:15 <Cale> stephenmac7: Have what?
12:01:20 <stephenmac7> Lazy infinity
12:01:39 <stephenmac7> Not that it's useful
12:01:43 <Cale> Well, if you define a natural datatype, yes
12:01:46 <random99> Tjr: in other words: there is no straightforward solution to that problem?
12:01:59 <Cale> stephenmac7: It can be useful
12:02:06 <Tjr> random99: I don't know for sure, I'm too much a newbie for that
12:02:20 <stephenmac7> benzrf: I think I'll just read the article
12:02:22 <benzrf> @let infinity = fix S
12:02:22 <Cale> stephenmac7: If you compute the length of a list, really you might end up with infinity
12:02:24 <lambdabot>  Defined.
12:02:32 <benzrf> > infinity > (S (S Z))
12:02:33 <lambdabot>  Ambiguous occurrence ‘infinity’
12:02:33 <lambdabot>  It could refer to either ‘L.infinity’, defined at L.hs:150:1
12:02:33 <lambdabot>                        or ‘Data.Number.Natural.infinity’,
12:02:33 <lambdabot>                           imported from ‘Data.Number.Natural’ at L.hs:94:1-26
12:02:38 <benzrf> meh
12:02:41 <benzrf> > L.infinity > (S (S Z))
12:02:43 <lambdabot>  True
12:02:44 <Cale> stephenmac7: and it's possible to compare infinity with finite numbers
12:02:47 <benzrf> it is larger!
12:02:51 <Cale> (for order comparison)
12:02:57 <stephenmac7> Guess so.
12:03:14 <random99> Tjr: thanks! I'll make a note and will investigate this issue some other time.
12:03:24 <Tjr> Why don't you guys simply create a data type called Infinity and be done with it?
12:03:34 <Nik05> hello. i got a function foo :: Integral n => [n] -> n but when not giving a type declaration ghc says no top-level binding [...] foo :: [Integer] -> Integer. And im just using product, filter, map, subtract and even. Why doesnt ghc see the type can be more general?
12:03:37 <stephenmac7> Because we don't get to use fix
12:03:40 <Cale> Tjr: What datatype would that be?
12:03:44 <Tjr> err, data type including a constructor called Infinity
12:03:52 <Cale> Tjr: er, because that's different
12:04:01 <stephenmac7> He means data Infinity = Infinity
12:04:07 <Cale> Tjr: consider the problem of computing the length of a possibly infinite list
12:04:14 <Tjr> data ExtendedReals = NegInfinity | Double a | PosInfinity
12:04:28 <Cale> If we have a natural numbers type like:
12:04:34 <Cale> data Nat = Zero | Succ Nat
12:04:39 <Cale> and we write
12:04:46 <Cale> length [] = Zero
12:04:53 <Cale> length (x:xs) = Succ (length xs)
12:05:17 <Cale> Then given an infinite list, this will compute the "lazy infinity" that was mentioned above
12:05:26 <Cale> You'll get Succ (Succ (Succ (...)))
12:05:40 <Nik05> whats sucks
12:05:47 <Nik05> that*, damn there goes the joke
12:05:51 <Cale> Succ is short for successor
12:05:58 <Nik05> i know :)
12:06:02 <Tjr> Cale: if that's something useful in your situation ...
12:06:08 <chrisdone>  /me boos and throws tomatoes
12:06:12 <hexagoxel> you all successor!
12:06:20 <Cale> However, if you added an artificial Infinity constructor, there's no way you'd ever know to produce it
12:06:25 <monochrom> @let newtype Monoself a = Monoself (Monoself a -> a); monoy f = (\x@(MkH x') -> f (x' x)) (MkH (\x@(MkH x') -> f (x' x)))
12:06:26 <lambdabot>  .L.hs:157:11: Not in scope: data constructor ‘MkH’
12:06:26 <lambdabot>  
12:06:26 <lambdabot>  .L.hs:157:33: Not in scope: data constructor ‘MkH’
12:06:26 <lambdabot>  
12:06:26 <lambdabot>  .L.hs:157:43: Not in scope: data constructor ‘MkH’
12:06:34 <monochrom> err, heh
12:06:40 <Cale> You can't actually distinguish an infinite list from a very long one until you find the end of the list.
12:06:43 <stephenmac7> Related, why does length [1..] < 50 not stop when it realizes it's more than 50?
12:07:06 <stephenmac7> Guess ghc isn't _that_ smart
12:07:08 <chrisdone> because Int is not lazy
12:07:08 <Cale> stephenmac7: Because length in the Prelude is defined to produce an Int
12:07:09 <pjdelport> stephenmac7: It would, with lazy integers.
12:07:20 <monochrom> @let newtype Monoself a = Monoself (Monoself a -> a); monoy f = (\x@(Monoself x') -> f (x' x)) (Monoself (\x@(Monoself x') -> f (x' x)))
12:07:21 <lambdabot>  ghc: panic! (the 'impossible' happened)
12:07:21 <lambdabot>    (GHC version 7.8.2 for x86_64-unknown-linux):
12:07:21 <lambdabot>          Simplifier ticks exhausted
12:07:21 <lambdabot>      When trying UnfoldingDone a_s8xs{v} [lid]
12:07:21 <lambdabot>      To increase the limit, use -fsimpl-tick-factor=N (default 100)
12:07:25 <pjdelport> stephenmac7: But with strict integers, it has to consume the entire list before it can begin returning.
12:07:30 <monochrom> ooohhhh
12:07:34 <Cale> stephenmac7: and so it never finishes computing which Int it is
12:07:36 <monochrom> @undefine
12:07:36 <lambdabot> Undefined.
12:07:39 <monochrom> @let newtype Monoself a = Monoself (Monoself a -> a); monoy f = (\x@(Monoself x') -> f (x' x)) (Monoself (\x@(Monoself x') -> f (x' x)))
12:07:40 <lambdabot>  ghc: panic! (the 'impossible' happened)
12:07:40 <lambdabot>    (GHC version 7.8.2 for x86_64-unknown-linux):
12:07:40 <lambdabot>          Simplifier ticks exhausted
12:07:40 <lambdabot>      When trying UnfoldingDone a_s8sq{v} [lid]
12:07:40 <lambdabot>      To increase the limit, use -fsimpl-tick-factor=N (default 100)
12:07:45 <monochrom> sorry!
12:07:51 <benzrf> Cale: http://ro-che.info/ccc/09
12:07:55 <Tjr> Cale: if you're doing computations in measure theory, then 1 / 0 = Infinity. As well as x * Infinity = Infintiy for any strictly positive, real-valued x.
12:08:08 <stephenmac7> Can it be done with peano numbers?
12:08:09 * hackagebot leksah-server 0.13.1.1 - Metadata collection for leksah  http://hackage.haskell.org/package/leksah-server-0.13.1.1 (HamishMackenzie)
12:08:11 * hackagebot leksah 0.13.4.3 - Haskell IDE written in Haskell  http://hackage.haskell.org/package/leksah-0.13.4.3 (HamishMackenzie)
12:08:15 <Cale> stephenmac7: Yes.
12:08:48 <Cale> stephenmac7: If length produced a Nat of the type I'd described, and 50 :: Nat and (<) :: Nat -> Nat -> Bool were the obvious things
12:09:25 <Cale> Consider how (<) might look:
12:09:29 <stephenmac7> Would have to implement <
12:09:38 <benzrf> :k Nat
12:09:39 <lambdabot> Not in scope: type constructor or class ‘Nat’
12:09:43 <benzrf> :k Natural
12:09:44 <lambdabot> *
12:09:47 <benzrf> @undefine
12:09:47 <lambdabot> Undefined.
12:09:49 <benzrf> :t infinity
12:09:50 <lambdabot> Natural
12:09:54 <benzrf> > infinity
12:10:00 <lambdabot>  mueval-core: Time limit exceeded
12:10:00 <lambdabot>  mueval: ExitFailure 1
12:10:02 <enthropy> > genericLength [1 .. ]  > (50 :: Natural)
12:10:02 <benzrf> dang
12:10:03 <lambdabot>  True
12:10:14 <benzrf> neat!
12:10:21 <benzrf> :t genericLength
12:10:22 <lambdabot> Num i => [a] -> i
12:10:29 <stephenmac7> Cool
12:10:46 <kadoban> Wow, that's really neat
12:10:52 <Cale> n < Zero = False; Zero < Succ m = True; Succ n < Succ m = n < m
12:10:57 <heatsink> @lambdabot > infinity > 100
12:10:58 <lambdabot> Unknown command, try @list
12:11:19 <stephenmac7> > infinity > 100
12:11:20 <lambdabot>  True
12:11:26 <Cale> That'll only end up looking at a finite portion of the infinity Nat which gets produced by the length function
12:11:28 <stephenmac7> @src infinity
12:11:28 <lambdabot> Source not found. Do you think like you type?
12:12:04 <Cale> stephenmac7: @src only knows about a limited set of things which are in a little text database in lambdabot
12:12:16 <stephenmac7> Oh. That's too bad
12:12:40 <stephenmac7> > (50 :: Natural)
12:12:41 <lambdabot>  50
12:12:47 <honza> some help with bytestrings needed if you feel so inclined http://stackoverflow.com/questions/24223326/internal-data-structures-in-haskell-text
12:12:49 <klrr_> could someone explain this strange behavang attoparsec parser? https://gist.github.com/klrr/a632b25ef93112a70056
12:13:05 <stephenmac7> Okay. Thanks. Time to read the article
12:14:45 <Tjr> honza: maybe minimal example code would be great.
12:15:32 <Tjr> honza: just guessing - maybe the module you're using imported Data.Bytestring already in some weird qualified way, whence the Data.ByteString.Internal.ByteString
12:15:43 <honza> Tjr: I was hoping for more of a general explanation why some API use the internals directly and some use the top level type
12:16:12 <Tjr> honza: if you put that into the question, maybe somebody knowledable will be able to help you
12:17:38 <monochrom> @let newtype Monoself a = Monoself {de :: Monoself a -> a}; monoy f = g (Monoself g) where g x = f (de x x)
12:17:40 <lambdabot>  ghc: panic! (the 'impossible' happened)
12:17:40 <lambdabot>    (GHC version 7.8.2 for x86_64-unknown-linux):
12:17:40 <lambdabot>          Simplifier ticks exhausted
12:17:40 <lambdabot>      When trying UnfoldingDone g{v s8st} [lid]
12:17:40 <lambdabot>      To increase the limit, use -fsimpl-tick-factor=N (default 100)
12:17:50 <monochrom> oohhh, so it turns on -O
12:18:14 <monochrom> ah, I don't have to make it a newtype :)
12:18:34 <chrisdone> monochrom: nice
12:18:53 <monochrom> yikes, changing "newtype" to "data" doesn't help. the optimizer is too smart.
12:19:14 <monochrom> ah, I don't have to keep it a one-case type :)
12:19:26 <heatsink> What is that type even good for?
12:19:43 <heatsink> It looks like the STLC
12:19:49 <heatsink> which is uninhabited
12:19:54 <monochrom> damn, the optimizer is still too smart.
12:20:19 <heatsink> Maybe use a NOINLINE annotation?
12:20:27 <monochrom> heatsink, delete "Mono" and "mono" and you will see what real names I intended
12:20:42 <c_wraith> Would it be handy to have a way to tell GHC to report names as coming from a particular module that re-exports the name, rather than from the place that defines it?
12:21:09 <heatsink> Oh, it's Y
12:21:45 <monochrom> why oh why does ghc hate my y? :)
12:21:46 <c_wraith> Hmm.  That'd carry into more than just error messages - Typeable would really need to integrate with it, too.  Ok, that's kind of a mess.
12:22:42 <klrr_> could someone explain this strange behavang attoparsec parser? https://gist.github.com/klrr/a632b25ef93112a70056
12:22:57 <monochrom> ok thanks heatsink, it is noinlining g
12:23:54 <monochrom> @let newtype Monoself a = Monoself {de :: Monoself a -> a}; monoy f = g (Monoself g) where {g x = f (de x x) {-# NOINLINE g #-}}
12:23:54 <lambdabot>  Parse failed: Parse error: {-# NOINLINE
12:24:15 <monochrom> unstoppable human meets immovable compiler
12:24:46 <monochrom> MUTO vs Godzilla
12:25:12 <bergmark> c_wraith: if it mentioned both, that'd be nice
12:26:02 <gilligan-> how do I get hlint to ignore 'binding X shadows ...' warnings ? the hlint manual is somewhat confusing ...
12:26:05 <kazagistar> klrr_: shouldnt that be an "&&" instead of an "||"
12:26:10 <enthropy> c_wraith: typeOf Prelude.head /= typeOf Data.List.head?
12:26:11 <c_wraith> bergmark: Why would both ever be good?  The desired goal is GHC reporting Data.ByteString.ByteString instead of Data.ByteString.Internal.ByteString when it shows up in an error message and isn't imported at all.
12:26:37 <monochrom> oh!
12:26:40 <c_wraith> enthropy: the goal is that canonical locations would be specified, not all locations.  Typeable would report the canonical location
12:26:42 <monochrom> @let newtype Monoself a = Monoself {de :: Monoself a -> a}; monoy f = g (Monoself g) where {g x = f (de x x); {-# NOINLINE g #-}}
12:26:45 <lambdabot>  Defined.
12:26:49 <monochrom> \∩/
12:26:59 <c_wraith> enthropy: the same way typeable currently reports the canonical location
12:27:05 <monochrom> > monoy (\f x -> if x==0 then 0 else f (x-1)) 4
12:27:08 <lambdabot>  0
12:27:15 <c_wraith> enthropy: the new part would be setting the canonical location to something other than the definition location.
12:27:25 <bergmark> c_wraith: consider "couldn't match Data.Text.Internal with SomeRandomPackageReExportingLazyText.Text"
12:27:32 <klrr_> kazagistar: oh maybe, gonna try
12:27:35 <enthropy> well in the bytestring case they could just move that type into Data.ByteString and use hi-boot files
12:27:53 <kazagistar> > fmap (\c -> c /= ' ' || c /= ')') "a )"
12:27:55 <monochrom> what they said about "you have to press the right button"
12:27:55 <lambdabot>  [True,True,True]
12:28:04 <enthropy> to keep the internal stuff still in the Internal module
12:28:07 <kazagistar> > fmap (\c -> c /= ' ' && c /= ')') "a )"
12:28:09 <klrr_> kazagistar: oh lol, i thought as i was using takeTill xD thanks
12:28:10 <lambdabot>  [True,False,False]
12:28:18 <c_wraith> bergmark: and?  At the moment it says Data.Text.Internal.Text.  It should just say Data.Text.Text.  How is saying *both* an improvement?
12:28:33 <benzrf> (\c -> c /= ' ' && c /= ')')
12:28:34 <c_wraith> bergmark: it would still use imported names if the name is in scope
12:28:44 <benzrf> liftA2 (&&) (/=' ') (/=')')
12:28:44 <klrr_> thanks!
12:28:46 <benzrf> hmm
12:28:46 <c_wraith> bergmark: this is strictly about what happens when the name *isn't* in scope
12:28:51 <benzrf> marginally shorter
12:29:35 <bergmark> c_wraith: in my example you don't see that the problem is lazy vs strict text because you may not know what some other package re-exports"
12:29:52 <bergmark> for all you know it defines its own text type
12:29:57 <c_wraith> bergmark: but it's already in scope. You're suggesting an entirely different change than me.
12:30:04 <kazagistar> klrr_: I never trust my complex logic like that, I always test it and/or pull it out entirely as a separate function
12:30:20 <c_wraith> bergmark: I'm suggesting a change to handling names that aren't in scope.  You're suggesting a change to handling names that are in scope.
12:30:38 <wfaler> Is this the right channel to ask silly, stupid, n00bish Haskell questions?
12:30:40 <luite> chrisdone: would you happen to have some rejected haskell.org (or other site) design lying around that we could borrow for www.ghcjs.org? :)
12:30:43 <ab9rf> wfaler: yes
12:31:53 <wfaler> I'm going to write a tiny app that interacts with various system applications.. What's a good starting point, System.Cmd, System.Process or something else?
12:32:01 <bergmark> c_wraith: ok, but then it may tell you Foo.Text even though the place where you get the type erorr doesn't have anything to do with Foo, right?
12:32:24 <c_wraith> bergmark: yes.  But it's already doing that - it would just make it do that *better*.
12:33:56 <c_wraith> bergmark: unfortunately, the implementation details turn out to be really ugly.  enthropy's solution using hs-boot files might be as sane a solution as possible.
12:34:45 <c_wraith> bergmark: and...  yeah, if hs-boot is as sane as it gets, then you know it's ugly.
12:35:59 <tommd> dmwit_: Stop answering SO questions and move to Portland.
12:36:00 <bergmark> :-)
12:36:01 <chrisdone> luite: lol, i don't =p
12:36:55 <simon> wfaler, yes.
12:38:00 <kazagistar> bernalex: (`all`" )").(/=)  -- its perfect!
12:38:56 <enthropy> c_wraith: I guess you don't necessarily need mutually recursive modules
12:39:03 <benzrf> :t all
12:39:04 <lambdabot> (a -> Bool) -> [a] -> Bool
12:39:04 <kazagistar> erm, I mean * benzrf
12:39:12 <benzrf> hehehe
12:39:29 <tommd> bergmark: Thanks for the bug report earlier this week.  I've since set up Jenkins jobs for my most troublesome projects over a few 32 and 64 bit platforms.  Hopefully that helps avoid this issues in the future.
12:39:29 <benzrf> :t (`all`" )").(/=)
12:39:30 <lambdabot> Char -> Bool
12:39:33 <benzrf> hmmm
12:39:37 <benzrf> oic
12:39:43 <benzrf> i-interesting
12:39:46 <c_wraith> enthropy: I think you do for the case of making .Internal modules that don't define the type you want to operate on.
12:39:49 <enthropy> c_wraith: actually nevermind, that option won't work
12:40:11 <kazagistar> benzrf: see, it even expands out to however many invalid chars you want to include :D
12:40:15 <enthropy> because how can a .Internal module get access to the ByteString constructor, while Data.ByteString does not export it?
12:40:22 <benzrf> ooooh
12:40:25 <c_wraith> enthropy: oh, right.
12:40:27 <luite> chrisdone: aw :( i'm pretty bad a designing and tend to spend way too much time getting something that looks halfway decent... so i was hoping to avoid this pitfall somehow :) how's the haskell.org redesign going btw, is that going to be up soon?
12:41:11 <c_wraith> enthropy: I forgot that modules in an hs-boot cycle still only get access to the export lists of each module in the cycle.
12:41:26 <ab9rf> wfaler: don't worry about interrupting other people or be put off by people talking abot other stuff you don't understand, that's normal in here :)
12:41:48 <chrisdone> luite: it's up at http://haskell-lang.org i've no present intentions for anything to happen to haskell.org
12:41:54 <enthropy> c_wraith: I think the better option is to just make sure the types are in scope more often
12:42:30 <enthropy> which is easier if you don't have qualified imports
12:42:38 <bergmark> tommd: cool!
12:42:40 <enthropy> and have StrictBS and LazyBS
12:42:49 <enthropy> as the type names
12:43:12 <luite> chrisdone: oh i thought i heard somewhere that they gave you access to update haskell.org
12:43:13 <c_wraith> enthropy: I guess an alternate approach is having modules re-export all types their interfaces depend on.
12:43:14 <chrisdone> luite: yeah designing is time consuming work =)
12:43:22 <c_wraith> enthropy: that would also stop that sort of problem
12:43:28 <thoughtpolice> luite: we really need a new design for the GHC homepage too IMO, but at least the current site loads fast and is minimal :P
12:44:05 <c_wraith> enthropy: because the problem can only occur when a module's interface depends on a type it doesn't export....  Or you don't import that part of the module, I guess.
12:44:14 <luite> thoughtpolice: well, minimality is the one thing ghcjs.org has ;)
12:44:16 <thoughtpolice> luite: and also we're open to putting up a new redesign, the one from chrisdone or someone elses, but at the moment none of the infrastructure team has done so. we've mostly been working on overhauling more backend stuff.
12:44:59 <thoughtpolice> (if anyone were to feel inclined though, they could mostly just yell at us to get it done earlier.)
12:45:25 <stephenmac7> wz1000: benzrf: http://rosettacode.org/wiki/Y_combinator#Haskell seems to be the way to do it the other way
12:45:41 <luite> thoughtpolice: ah i see
12:46:08 <thoughtpolice> anyway a new front page would be cool since we're doing a lot of other nice improvements, but yeah, that will probably come a bit later
12:46:09 <bergmark> enthropy, c_wraith: it is pretty annoying when you have to add new dependencies just to write type signatures so re-exporting types is a good thing to do i think
12:46:26 <c_wraith> bergmark: that's a good point
12:47:30 <luite> thoughtpolice: is there by the way any windows test infrastructure that might be available for projects? i'd like to automate windows builds and internet explorer benchmarks somehow
12:48:12 <thoughtpolice> luite: yes that can be done, it's one of the longer term things on my mind - offering up resources for testing and/or things like benchmarking, etc.
12:48:16 * hackagebot fay 0.20.1.0 - A compiler for Fay, a Haskell subset that compiles to JavaScript.  http://hackage.haskell.org/package/fay-0.20.1.0 (AdamBergmark)
12:48:17 <chrisdone> luite: i'd probably fill out the page with more content before thinking up a design
12:48:45 <chrisdone> three links isn't really a web site worth having a design for
12:49:21 <leonixyz> Hello, I get a compile time error in this function to calculate prime numbers, https://gist.github.com/leonixyz/db27a7570f5578a1684b can somebody help me please?
12:49:24 <stephenmac7> chrisdone: Is this yours? http://chrisdone.com/
12:49:28 <chrisdone> yup
12:49:28 <thoughtpolice> luite: we're mostly moving all the servers (again) to Rackspace, which will be free mostly, more redundant, and give us some comfortable leg room. as a bonus we could offer some of that up to the community (e.g. temporary leases on, say, a 120GB RAM/32core system for public demos, etc)
12:49:46 <luite> chrisdone: oh bah even more work! why can't users just read the whole codebase first, instead of all this documentation nonsense! :)
12:49:50 <stephenmac7> chrisdone: You wrote fay?
12:50:04 <thoughtpolice> Windows build bots already exist for GHC on this infrastructure, so one for, say, GHCJS isn't really unthinkable.
12:50:14 <thoughtpolice> (Rackspace covers the licensing cost)
12:50:24 <chrisdone> stephenmac7: the first few versions, yeah
12:50:44 <chrisdone> luite: i know right =p
12:52:35 <luite> thoughtpolice: ok that would be great. i tried using travis-ci, but keep running into the time limit. now we have two hetzner servers for linux testing, but windows is still missing
12:54:07 <luite> thoughtpolice: do you also have OS X by the way?
12:54:58 <thoughtpolice> luite: no, i can't offer OS X machines in any reasonable way at the moment, I'm afraid. i will passively mention, however, that a modern Linux kernel and QEMU should allow you to virtualize it quite effectively.
12:55:07 <chrisdone> i'd prefer if ghc's "homepage" was just part of the haskell home page
12:55:36 <thoughtpolice> luite: a Hetzner EX40 is more than up to the job, I'm sure.
12:56:01 <thoughtpolice> but yes, OS X is a little more complicated since you can't get it licensed out to you so easily e.g. through a VPS provider
12:57:22 <chrisdone> there's always a separate page and design for parts of haskell
12:58:25 <chrisdone> the wiki, hackage, ghc, platform, haskell report, hoogle
12:59:00 <chrisdone> it looks like 6 different groups made 6 different pages and didn't really communicate about making something coherent because that's what happened
12:59:46 <luite> thoughtpolice: right, was just checking if i could save me the trouble of setting up OS X that way :) is there any documentation or scripts for setting up the linux build bots?
13:00:20 <thoughtpolice> there's some but I can't remember OTTOMH where it is, on the GHC Wiki I believe
13:00:45 <thoughtpolice> that infrastructure was originally written by Ian, Gabor now maintains the primary one people are starting to use again.
13:02:22 <michaelt> hm, leonixyz put backticks around `mod`, it's being used infix
13:03:47 <rinder> I have finally found what is causing stack overflow - recursion call from inside a catch. why does this cause stack overflow? http://lpaste.net/105605
13:05:18 <Cale> rinder: good question
13:05:19 <parc> the recursion causes catch to be called again. so you get main = catch (catch (catch ...
13:05:28 <luite> thoughtpolice: i'll probably ask again in a few weeks, when i have a bit more time. right now i'm busy with some template-haskell changes in GHCJS, running it through node.js instead of ghci (which makes installation a whole lot simpler and reliable, but is right now holding up the release)
13:05:35 <michaelt> rinder: isn't that about the same as main = main?
13:05:59 <rinder> michaelt: no because that wouldnt cause stack overflow
13:06:03 <Cale> Well, yes, you get an infinite application of catches, though it's still unclear why it's a *stack overflow*
13:06:04 <michaelt> rinder: oh sorry, right
13:06:37 <Cale> Probably you'd have to look carefully at the implementation of catch to see why
13:07:04 <luite> also GHCJS has (proper) stack traces now \o/ \o/ *happy dance*, thanks to osa1
13:07:32 <parc> i think there was a chapter of ... real world haskell? that had a similar example. lemme see if i can find it
13:09:01 <luite> (it's not yet merged though)
13:09:12 <chrisdone> luite: my plan is to bring everything under one roof (haskell-lang.org) by scraping or pulling from APIs until it's a complete everything-haskell site that i can link newbies to. maybe i'll propose it for haskell.org but by that time it won't matter much
13:09:27 <michaelt> It's not so easy to find the implementation of 'catch' ...
13:09:29 <heatsink> I think each catch sets up its own continuation that waits for a result, which is either an exception or a normal return
13:09:35 <Cale> It's probable that catch is strict in the IO action
13:10:15 <heatsink> So it's like foldl
13:10:15 <Cale> So, you have something like catch x f = case x of ...
13:10:31 <parc> or maybe it was in an erlang book. i found http://stackoverflow.com/questions/17559946/no-tail-recursive-code-in-a-try-catch-block, which might be similar to how it works in haskell
13:10:58 <max3> is -> left associate or right associative?
13:11:03 <max3> *associative
13:11:07 <parc> right
13:11:09 <benzrf> max3: in types?
13:11:16 <max3> yes
13:11:21 <benzrf> 04:07 < RubyPanther> benzrf saves the day:  http://fc01.deviantart.net/fs71/f/2012/197/9/0/derpy_unicorn_by_genicecream-d57i7fe.jpg
13:11:22 <max3> benzrf: yes
13:11:23 <Cale> A -> B -> C means A -> (B -> C)
13:11:24 <benzrf> oops wrong paste
13:11:26 <benzrf> 04:08 < parc> right
13:11:27 <chrisdone> benzrf: where else? =p
13:11:31 <benzrf> chrisdone: oh wait
13:11:36 <max3> thanks
13:12:02 <Cale> parc: Given that Erlang's evaluation is strict, probably not
13:12:13 <Cale> I would expect Erlang's stack is a call stack
13:13:04 <rinder> could this behavior of catch be considered a bug?
13:13:11 <Cale> not really
13:13:22 <Cale> I mean, that's a really weird program to write
13:13:50 <rinder> (whether it is a bug in the implementation od catch, or something else)
13:14:12 <Cale> You effectively wrote  main = catch (catch (catch (catch (...) undefined) undefined) undefined) undefined
13:14:37 <luite> chrisdone: right by then everyone will have forgotten about haskell.org so you can start charging for GHC enterprise edition downloads and add ask toolbar to the installer
13:15:28 <max3> i don't understand something like a -> a -> Point a. right associative suggests to parenthesize like this a -> ( a -> Point a), a mapping from type a to maps that map from a to Point a. i don't see how, semantically speaking, that's a 2 argument function
13:15:36 <Cale> I think it's probably reasonable for catch to be strict in its IO action parameter, though *maybe* it's possible that could be relaxed, it's a little unlikely that you'd ever need it to be
13:15:49 <chrisdone> luite: hm?
13:15:51 <Cale> max3: f x y z means ((f x) y) z
13:16:03 <michaelt> hm, there is a more primitive `catch#` not too surprisingly https://github.com/ghc/ghc/blob/master/libraries/base/GHC/IO.hs#L279
13:16:09 <Cale> max3: All functions really have exactly one parameter
13:16:35 <Cale> max3: and those which appear to take more arguments are really just producing other functions which accept the next argument
13:16:53 <luite> chrisdone: oh don't you have evil plans? :)
13:17:14 <max3> Cale: defined how, ie what kind of function is (f x)
13:17:15 <chrisdone> luite: i consider it more like stackoverflow to expert-sexchange =p
13:17:15 <parc> f x y = (f x) y. you apply f to x, and get back a function which takes one parameter, which you then apply the y to
13:17:31 <max3> what's the definition of g = (f x)
13:17:33 <Cale> max3: f being any function of (at least) 3 parameters here
13:17:53 <Cale> @let add x y = x + y
13:17:55 <lambdabot>  Defined.
13:17:57 <heatsink> max3: The definition is what you get by substituting y and z into the definition of f
13:18:02 <Cale> @let addOne = add 1
13:18:03 <lambdabot>  Defined.
13:18:11 <Cale> :t addOne
13:18:12 <lambdabot> Num a => a -> a
13:18:24 <identity> pandoc is amazing.
13:18:26 <max3> i understand projection
13:18:36 <rinder> Cale, I have to catch exceptions, and if an exception is caught I recurse with a different value than if all went well. so I have something like this in a actual code: run x = catch (do newX <- f; run newX) (\err -> print err >> run x)
13:18:54 <max3> (well it looks like projection) but what i'm saying is Cale says there are only one parameter functions
13:18:56 <heatsink> projection?  On products?
13:19:08 <heatsink> Functions aren't products.
13:19:19 <max3> '@let addOne = add 1' that looks like a projection to me
13:19:22 <max3> but i'm mixing domains
13:19:36 <rinder> how would you rewrite that without getting ugly, such as using IORef
13:19:59 <max3> :t add
13:20:00 <lambdabot> Num a => a -> a -> a
13:20:13 <Cale> max3: It's just function application
13:20:14 <heatsink> You could also define add like this
13:20:15 <Cale> max3: add is a function which takes a number and produces the function which adds that number to its argument
13:20:18 <max3> Cale: can you explain to me how add here is a function of one parameter
13:20:19 <luite> chrisdone: oh are you adding a similar QA system? something that's well integrated with the documentation would be quite useful
13:20:20 <chrisdone> luite: my wish is that the haskell web presence is coherent, professional and helpful. i'll be fought against if i try to do this on haskell.org, so my evil plan is just to do it with freedom. people have been sending me content pull requests so i'm not completely alone
13:20:24 <heatsink> @let add = \x -> (\y -> x + y))
13:20:25 <lambdabot>  Parse failed: Parse error: )
13:20:37 <heatsink> @let add = \x -> (\y -> x + y)
13:20:38 <lambdabot>  .L.hs:150:1:
13:20:38 <lambdabot>      Multiple declarations of ‘add’
13:20:38 <lambdabot>      Declared at: .L.hs:149:1
13:20:38 <lambdabot>                   .L.hs:150:1
13:20:59 <luite> chrisdone: right, more apple, less microsoft :)
13:21:25 <max3> "add is a function which takes a number and produces the function which adds that number to its argument" i don't understand this
13:21:40 <chrisdone> luite: maybe more apple, less slackware
13:21:51 <heatsink> Are you familiar with lambda notation, max3?
13:21:51 <max3> you seem to be distinguishing between the first param and the second, calling the second the argument
13:21:53 <flaggy> hello. I'm having trouble to write a program which reads from stdin and ends when it finds EOF
13:21:59 <max3> heatsink: vaguely
13:21:59 <Iceland_jack> max3:
13:21:59 <Iceland_jack>     add :: Int -> (Int -> Int)
13:22:05 <flaggy> I'm trying to use getLine, should I use somehting else?
13:22:09 <luite> chrisdone: hehe
13:22:22 <ion> flaggy: getContents
13:22:28 <max3> Iceland_jack: yes it is exactly expressions like that which confuse me
13:22:33 <Iceland_jack> max3: You don't need to understand lambda notation, every function takes only one argument
13:22:43 <michaelt> flaggy, interact :: (String -> String) -> IO ()
13:22:51 <Iceland_jack> max3: That's not quite an expression but what confuses you about it?
13:22:54 <heatsink> The definition of add looks like it takes two arguments, that's what he's trying to understand
13:22:58 <chrisdone> luite: a CI system? that would be fun to integrate status reports too, i suppose
13:22:59 <Iceland_jack> Does
13:22:59 <Iceland_jack>     add :: Int -> Int -> Int
13:22:59 <Iceland_jack> make sense?
13:23:08 <parc> say you wanted to take a list and replace any negative values with zero. you could do map (\x -> if x < 0 then 0 else x) [-5,1,-3,...]. but because max takes only one parameter you could just do map (max 0) [-5,1,-3,...]. max 0 returns a new function which takes a single value and returns the maximum of it and 0
13:23:45 <michaelt> flaggy: you can do do { b <- isEof; if b then putStrLn "done!" else ...}
13:23:47 <flaggy> ion: getcontents get all the lines, I want to get one ech time, not load it all in memory. michaelt I thoght interact worked per character not per line
13:23:56 <chrisdone> luite: there's only tryhaskell and haskellnews that're services i'm running atm, but the site should just be like a thin-client that pulls from other places
13:24:00 <max3> Iceland_jack: yes i was using expression in the colloquial sense (so many loaded words). i interpret Int -> (Int -> Int) as a map from a param to a map
13:24:07 <luite> chrisdone: no i meant a question/answer forum, with an easy way to refer to functions and their docs and comment on code in packages
13:24:15 <Iceland_jack> max3: well the two types are the same
13:24:17 <heatsink> Okay, we can use substitution.  If I have defined add x y = x + y
13:24:23 <ion> flaggy: The buffering done by the terminal affects when your process will receive a chunk of input.
13:24:28 <heatsink> Then (add 1) is like the function add_one y = 1 + y
13:24:30 <Iceland_jack>     Int -> Int -> Int = Int -> (Int -> Int)
13:24:31 <max3> one sec guys, i appreciate the help but too many
13:24:38 <max3> heatsink:  lemme talk to Iceland_jack for right now
13:24:45 <max3> Iceland_jack: i understand that
13:24:59 <flaggy> I'll try that isEOF approach
13:25:09 <Iceland_jack> max3: right, and you understand that when you have a function
13:25:09 <Iceland_jack>     f :: a -> b
13:25:09 <Iceland_jack> and give it an 'a', you get a 'b' back
13:25:17 <max3> yes
13:25:23 <chrisdone> luite: oic. nice idea. like github but on packages rather than git projects
13:25:23 <Iceland_jack> so if you have a function
13:25:23 <Iceland_jack>     f :: Int -> (Int -> Int)
13:25:23 <Iceland_jack> and give it an Int
13:25:26 <zwer> flaggy getContents wont load everything into memory because haskell is lazy
13:25:30 <luite> chrisdone: right
13:25:35 <max3> i'll get a function back
13:25:35 <Iceland_jack> you get a 'Int -> Int' back, which is a function
13:25:37 <Iceland_jack> exactly
13:25:46 <Iceland_jack> so let's try
13:25:46 <Iceland_jack> > (+) 5
13:25:48 <lambdabot>  <Integer -> Integer>
13:25:52 <chrisdone> luite: yeah it would be cool on a library docs to ask a question at a specific place and have it email the maintainers
13:26:06 <michaelt> flaggy: as zwer says, getContents is a bit more like getWhatIAskFor or something
13:26:07 <Iceland_jack> We get a function back, from Integer to Integer and that function is 'plus 5'
13:26:19 <max3> ah
13:26:20 <max3> i get it
13:26:29 <Iceland_jack> that's why you can write
13:26:30 <Iceland_jack> > (+) 5 10
13:26:31 <lambdabot>  15
13:26:35 <Iceland_jack> as
13:26:35 <Iceland_jack> > ((+) 5) 10
13:26:36 <lambdabot>  15
13:26:37 <luite> chrisdone: in particular if you had back references from code/haddock to questions bout it
13:26:42 <luite> +a
13:26:44 <max3> so for add for example that makes sense, you hold one of the arguments "in reserve" and then "apply" it to the second argument
13:26:48 <max3> yes
13:26:50 <max3> that makes sense
13:26:55 <luite> my keyboard is getting less reliably by the minute :(
13:27:07 <Iceland_jack> max3: so that way, functions only accept a single argument in Haskell: never moer
13:27:20 <max3> but it seems like sleight of hand
13:27:21 <luite> but that typo was my own fault
13:27:23 <chrisdone> luite: likewise hackage dev is sloooow. i spent a few hours making the 'Flags' section feature and it took like two weeks to be merged and i have no idea how long before it got on production, and the codebase is like something from 2008. bleh
13:27:44 <Iceland_jack> where you can think of a function
13:27:44 <Iceland_jack>     f :: A -> B -> C -> D
13:27:44 <Iceland_jack> as
13:27:44 <Iceland_jack>     f :: A -> (B -> (C -> D))
13:27:47 <Iceland_jack>  
13:27:52 <Iceland_jack> max3: how so?
13:28:00 <max3> i'm trying to construct a pathological example
13:28:01 <max3> one sec
13:28:01 <chrisdone> luite: but iirc hackage provides APIs to access package details and things, so it's possible to write a nicer interface for it
13:28:16 <max3> okay
13:28:27 <parc> max3: helpful slight over hand when you're using higher order functions. you can do things like: sin . (+) 2 . cos, to compose a bunch of functions together
13:28:29 <michaelt> flaggy: there are also methods in conduit and pipes & co. E.g the crude 'stdinLn' in the pipes library:  main = runEffect $ P.stdinLn >-> P.map reverse >-> P.stdout would reverse each line as it comes in
13:28:39 <eizo> max3: say you have f x y z = something, and you write g = f 5. you can see g as a function that takes a 'y' and a 'z' (and assumes x = 5), and returns 'something'
13:29:06 <max3> Iceland_jack: can i define a function sin(x/y) and apply it to 1 0? how about 0 1?
13:29:16 <Iceland_jack> max3: of course
13:29:26 <Iceland_jack> @ty \x y -> sin (x/y)
13:29:27 <lambdabot> Floating a => a -> a -> a
13:29:46 <Iceland_jack> if you want to apply it to '1' and '0' you do
13:29:47 <Iceland_jack> > (\x y -> sin (x/y)) 1 0
13:29:48 <lambdabot>  NaN
13:29:57 <Iceland_jack> and
13:29:57 <Iceland_jack> > (\x y -> sin (x/y)) 0 1
13:29:59 <lambdabot>  0.0
13:29:59 <ion> batman
13:29:59 <heatsink> max3: How would that be different from the 'add' example?
13:30:07 <max3> i'm trying to say that
13:30:19 <luite> chrisdone: otherwise it's easy to get the package index and have Cabal parse the files? not that the Cabal codebase feels more modern than 2008... :)
13:30:21 <chrisdone> luite: OTOH it's also possible to make a mirror like yours and then make a completely different interface with rating systems and comments and whatever. who cares what web interface people use to SEE the packages, it's the repo that's the important sharing point
13:30:24 <max3> that the 1 parameter intermediary function sin(x/0) isn't a function
13:30:47 <chrisdone> luite: yup
13:30:59 <heatsink> @let sinoverzero x = sin (x / 0)
13:31:00 <lambdabot>  Defined.
13:31:07 <Iceland_jack> > text $ ([1..9]>>show ((\x y -> sin (x/y)) 1 0)) ++ " Batman!"
13:31:08 <lambdabot>  NaNNaNNaNNaNNaNNaNNaNNaNNaN Batman!
13:31:10 <parc> max3: it basically still is. you can use it anywhere you need a function Floating a => a -> a
13:31:10 <heatsink> It looks like a function to me.
13:31:12 <max3> lol
13:31:14 <max3> good one
13:31:49 <ion> max3: In Haskell, a value is a function iff its type is A -> B for some A and B.
13:32:08 <max3> yes i understand that too
13:32:11 <parc> max3: i doubt ghc really treats it as a function which returns a function when you're fully applying it, but that's more of an optimization thing, and honestly i don't know either way
13:32:12 <max3> type value right?
13:32:51 <ion> @type sinoverzero  -- is a Haskell function
13:32:53 <lambdabot> Floating a => a -> a
13:33:21 <max3> one sec brb
13:34:11 <luite> chrisdone: oh btw, i have promised multiple times to host some haddocks on hdiff, but never found the script to build them, do you know a way? otherwise i might just hack something to just wget them at some point
13:34:17 <heatsink> parc, GHC has multiple-parameter function definitions internally, for efficiency
13:34:33 <heatsink> parc, it also has a different calling convention for calling a function with exactly the right number of arguments
13:34:56 <parc> heatsink: yeah, that's what i figured
13:36:06 <max3> thanks for the help guys. heading home while the rain has stopped
13:36:35 <Iceland_jack> yw
13:36:42 <heatsink> ok.  Feel free to ask more questions
13:36:56 <chrisdone> luite: i don't know what script is used to build them. other than launch an ec2 instance wget ghc && cabal install && cp dist/doc =p
13:37:03 <pharaun> one thing i always struggled with library design, is how to design for ex, network libraries in which there can be multiple messages in flight, should i ask the user to provide a callback that i can call/thread multiple times to handle, or should i let the library author worry about the concurrent stuff theirselves?
13:37:05 <jaco60> Hi... i don't know how to read the (((==0).).rem) part in a nubBy call like nubBy (((==0).).rem) [2..]
13:37:23 <pharaun> library user i mean
13:37:31 <ion> @unpl (((==0).).rem)
13:37:31 <lambdabot> (\ e h -> (rem e h) == 0)
13:37:44 <fragamus> I am loading a list into a Map. I think I should be using a fold, but I'm unclear as to whether I should be using a left fold or a right fold
13:38:07 <fragamus> I am loading a list into a Map. I think I should be using a fold, but I'm unclear as to whether I should be using a left fold or a right fold
13:38:10 <akurilin> Hey folks. I'm trying to implement an average function that checks for a possible NaN value, and for some reason I can't seem to get the types right. Any suggestions? http://lpaste.net/3774942027418959872
13:38:21 <luite> chrisdone: that might not be too far from the actual procedure :)
13:38:51 <chrisdone> luite: pretty much what travis scripts look like i guess. what's the timeout limit for unpaid travis?
13:38:51 <jaco60> ion, thanks... it helps... I think i've miss something about the composition operator..
13:39:01 <luite> chrisdone: 50 mins
13:39:14 <monochrom> > (\case of {0 -> True; 2 -> False; _ -> True}) 2
13:39:15 <lambdabot>  <hint>:1:3: parse error on input ‘case’
13:39:24 <piezoid> fragamus: why not use fromList ?
13:39:25 <monochrom> hmm does lambdabot have lambda-case?
13:39:29 <chrisdone> luite: https://travis-ci.com/plans
13:39:34 <monochrom> > (\case {0 -> True; 2 -> False; _ -> True}) 2
13:39:36 <lambdabot>  <hint>:1:3: parse error on input ‘case’
13:39:36 <chrisdone> luite: it seems you're hitting a limit that is unadvertised =p
13:39:37 <fragamus> ok
13:39:41 <ion> jaco60: FWIW, nested (.)s are just obfuscation, but you can manually evaluate that expression step by step (using the definition of (.)) and reach the correct result.
13:39:55 <akurilin> it's possible I'm not checking for NaN correctly tbh
13:39:59 <chrisdone> luite: maybe your use doesn't constitute 'fair use'
13:40:00 <Iceland_jack> akurilin: isNaN requires RealFloat
13:40:06 <luite> chrisdone: bah their fault for giving me slow virtual machines :p
13:40:31 <chrisdone> luite: i guess you're building a complete ghc though?
13:40:45 <thoughtpolice> that page terrible. it literally says "Unlimited Build Minutes", and below says all jobs are limited to 90 minutes
13:40:47 <piezoid> fragamus: it load list ordered in ascending order in linear time
13:40:50 <akurilin> Iceland_jack: so all it means is that I just want to cast the avg value to a RealFloat before I run that check?
13:40:51 <thoughtpolice> and if you need more you can split them with the build matrix
13:40:52 <thoughtpolice> wtf
13:41:02 <Iceland_jack> akurilin: no, let GHCi solve your problem for you
13:41:11 <fragamus> thanks
13:41:15 <chrisdone> "Should your build take longer, you can split it up using a build matrix."
13:41:16 <Iceland_jack> delete the type signature and type
13:41:16 <Iceland_jack>     ghci> :t average
13:41:21 <chrisdone> luite: did you look into that?
13:41:23 <thoughtpolice> and yes in any case, Travis does have a hard limit of about 1hr on GitHub projects. Joachim runs a Travis-CI instance for GHC, and it gets quite close to the build limit time
13:41:39 <thoughtpolice> so close we actually have to turn off a *ton* of things in the build for it to go through
13:41:45 <luite> chrisdone: not anymore, just GHCJS, but it has lots of deps. then ghcjs-boot, which builds a lot of things again (base, containers, aeson, vector, attoparsec etc), it often doesn't finish in time to even start running the test suite
13:41:52 <monochrom> interesting, in lambda-case, it's "\case { branches }" without ->
13:42:17 <akurilin> Iceland_jack: so basically I had set the constraints too tight?
13:42:21 <ion> fragamus: Is your function parameter to the fold non-strict in its “return value” parameter? foldr. Are you updating an accumulator strictly in each step of the fold? foldl'
13:42:44 <monochrom> but too bad lambdabot doesn't have lambda-case turned on :)
13:42:50 <thoughtpolice> chrisdone: i believe they mean if your use case is like "build, run tests, run benchmarks" but that takes too long, you can split it into say, just "build, run testsuite #1", "build, run testsuite #2", "build, run benchmarks", etc in the matrix. but that isn't helpful when 'build' alone takes up all the time
13:42:55 <Iceland_jack> no in a sense you didn't set them tight enough akurilin
13:43:01 <akurilin> Iceland_jack: also, am I losing anything by moving from (Real a, Fractional b) to (RealFloat a, Real b)
13:43:17 <Iceland_jack> What do you mean by 'losing'?
13:43:32 <Iceland_jack> You can perform more actions with a RealFloat, but potentially fewer types match it
13:43:39 <akurilin> perhaps it's now only 32bit floats internally
13:43:48 <luite> chrisdone: it used to be faster for some reason... after i finish the TH changes, ghcjs-boot should be faster, so i'll probably look into it again
13:44:01 <chrisdone> yeah seems easier to just setup a digitalocean VM and build with travis
13:44:07 <chrisdone> er, jenkins
13:44:10 <Iceland_jack> akurilin: You can do
13:44:10 <Iceland_jack>     ghci> :info RealFloat
13:44:10 <Iceland_jack> and it tells you what things are RealFloat
13:44:13 <thoughtpolice> but anyway GHC isn't really a good fit for Travis-CI as it stands anyway, it's a bit too large, and it requires a lot more than Travis can offer
13:44:32 <Iceland_jack> akurilin: both Float and Double for example, same as Fractional
13:44:35 <chrisdone> i bet one could use travis to build haddocks, though
13:44:48 <Iceland_jack>     instance RealFloat Float
13:44:49 <Iceland_jack>     instance RealFloat Double
13:45:03 <Iceland_jack> akurilin: So you're not really losing anything
13:45:21 <chrisdone> i.e. just make it do the build and then PUT the .tar.gz onto a server
13:45:27 <Fuuzetsu> Problem with using Travis for things is that it's likely that you're only using the free version so it's all in public and it's difficult to give it credentials that someone else can't come and abuse
13:45:29 <luite> chrisdone: yeah i do like the github things travis has though, so people sending a pull req get some feedback before it's merged
13:45:35 <akurilin> Iceland_jack: ok thanks for explaining. I'm reading through some of the literature on the different number type classes to grok it
13:45:43 <chrisdone> luite: yeah that's nice
13:45:54 <chrisdone> luite: although perhaps github has jenkins integration
13:46:06 <Iceland_jack> akurilin: The numeric types are daunting, normally it's best to ask GHCi to do the 'inferring' part for us though
13:46:24 <chrisdone> luite: so you could point it to "jenkins.ghcjs.org", for example
13:46:54 <chrisdone> hmm yah they do have jenkins integration, wonder what the extent is
13:47:06 <bergmark> we use teh jenkins+github
13:47:24 <luite> chrisdone: right makes sense. still there's some abuse potential, how secure is jenkins if you let arbitrary forks run code before looking at the code?
13:47:51 <bergmark> luite: not secure at all
13:48:24 <chrisdone> sure
13:48:33 <rinder> can someone suggest how to rewrite this without recursing from within catch (because doing so causes stack overflow).  http://lpaste.net/105606
13:48:33 <luite> i could make hdiff push a commit to a github repo for every new package it sees, then have travis-ci cabal install it and build a tar.gz with the haddocks, but that doesn't sound much like 'fair use' :)
13:49:05 <chrisdone> luite: i was thinking the same =p
13:50:29 <akurilin> Iceland_jack: sounds good, good tip, thank you
13:53:49 <heatsink> rinder: You can have 'catch' return the action to execute next
13:54:29 <luite> bergmark: is there some way to set it up so that the jenkins build bot vm doesn't need to keep any state, so you can just shutdown/reset the vm every time?
13:54:43 <chrisdone> luite: could combine jenkins with ec2 instances. gives you the jenkins integration, but the security of a fresh vm per run
13:55:21 <rinder> heatsink: I dont understand, dont I have that now? catch returns IO ()
13:55:38 <luite> chrisdone: yeah i was thinking vagrant for fresh vm, so it can run on the hetzner servers
13:55:58 <thoughtpolice> that's all Travis-CI does anyway, is use Vagrant
13:56:20 <heatsink> rinder: See http://lpaste.net/105606
13:56:45 <chrisdone> luite: right, vagrant would give you the windows integration you're after too
13:57:27 <Ainieco> hello
13:57:41 <chrisdone> have been considering vagrant for an lpaste compilation service
13:57:42 <rinder> heatsink: nice and simple! thanks
13:58:03 <chrisdone> i.e. start a fresh vagrant every hour. if it gets shafted by exploits, no big deal, a fresh one will start up soon
13:58:17 <michaelt> Hello Ainieco
13:58:39 <luite> chrisdone: still need a license though
13:59:01 <chrisdone> luite: true. i don't have any windows stuff for that reason. it's my excuse =p
13:59:06 <Ainieco> just wondering how to better organize creature bodyparts... E.g. I have a record type Creature, that Creature have some unrelated to its body fields like name but also I'd like it to have some body parts
13:59:16 <Ainieco> like eyes, teeth, etc
13:59:19 <akurilin> Is it generally a bad idea for me to be specifying Double as the type passed around in my functions if I just want a Fractional?
13:59:26 <chrisdone> luite: although you can get free as in beer windows copies these days from their site, i think
13:59:42 <akurilin> As in, I don't have any particularly strong reason to want a Double over some of the other representations
13:59:55 <Ainieco> should I create lots of fields in that record for each part of body or there is more expressive way to do such things
14:00:17 <chrisdone> luite: but perhaps not playing well with vagrant, don't know
14:00:18 <luite> chrisdone: not a bad excuse. they don't seem to make it easy at all. last time i downloaded the IE10/IE11 test VMs from their site they were already expired
14:00:30 <michaelt> akurilin: commit to Double
14:00:45 <Mathnerd314> is there a generic class Convert a b { convert :: a -> b } ?
14:00:53 <Mathnerd314> or should I just use lenses? :p
14:01:20 <bergmark> Mathnerd314: there's convertible, but it also deals with partial conversions
14:01:25 <akurilin> michaelt: any particular reason why? Fewer headaches?
14:01:28 <edwardk> Mathnerd314: there is no such function. should it be injective, surjective? what does it mean?
14:01:31 <Fuuzetsu> Coercible perhaps for muh performance
14:01:33 <michaelt> akurilin: yes.
14:01:50 <chrisdone> probably Convertible
14:02:04 <chrisdone> http://hackage.haskell.org/package/convertible-1.1.0.0/docs/Data-Convertible-Base.html
14:02:09 <edwardk> Mathnerd314: Fuuzetsu's mention of Coercible is at least a sane starting point in that it never lies
14:02:36 <Mathnerd314> edwardk: hmm. what about something like class HasIso a b { getIso :: Iso' a b } ?
14:02:39 <edwardk> chrisdone: ಠ_ಠ
14:02:50 <chrisdone> edwardk: just giving information uncensored
14:03:01 <edwardk> chrisdone: my look was mostly directed at the package ;)
14:03:02 <chrisdone> luite: it helps me avoid having to deal with windows at work too =p
14:03:30 <chrisdone> edwardk: i never really liked it either. i'm only aware of it via the old hsql (or hdbc) database libraries that used it
14:03:48 <bergmark> yup that's the only reason i've used it too
14:03:51 <chrisdone> it's very javascript-y in the lack of clarity of what happens to data loss and things like that
14:04:12 <edwardk> Mathnerd314: the issue is how to offer such a class usefully n a way that the isos are chosen canonically somehow. Coercible at least manages that last part
14:04:58 <edwardk> instance HasIso Int Int where getIso = iso negate negate -- would be a legal inhabitant if you are't careful ;)
14:05:03 <luite> chrisdone: yeah i can't keep ignoring IE though :)
14:05:06 <chrisdone> i lump it in with Bad Classes along with ‘Stringish’ classes that have a hundred methods
14:05:29 <Mathnerd314> edwardk: so maybe you need the constraint that instances exist iff getIso is unique :-)
14:05:45 <chrisdone> luite: heh. i haven't developed for IE for a year or so. yay technically savvy userbase
14:05:56 <edwardk> Mathnerd314: so basically you've got a class that works for Void and () ;)
14:07:23 <Mathnerd314> ok, so maybe my only problem is that I'm really bad at coming up with imaginative names for iso's.
14:07:43 <luite> chrisdone: have you tested fay's performance in the new firefox with generational gc?
14:08:19 <chrisdone> luite: nope. do you rate firefox's performance? whatever change they make v8 always makes it look amateur
14:09:12 <Mathnerd314> edwardk: is iso negate negate in the lens package?
14:09:55 <edwardk> :t Numeric.Lens.multiplying (-1)
14:09:56 <lambdabot> (Profunctor p, Functor f, Fractional a, Eq a) => p a (f a) -> p a (f a)
14:09:57 <chrisdone> luite: well, context matters. a single js <thing>Monkey program vs a single V8 js program have varying benchmarks, but that's always made irrelevant by firefox's single-process nature
14:10:01 <luite> chrisdone: well for haskell-type workloads, lots of allocation and short-lived objects, they were always far behind, but they are finally getting their act together (somewhat, while i get a 3x speedup on some nofib benchmarks, many tests hang or crash the new js engine)
14:10:03 <edwardk> close enough anyways ;)
14:10:10 <edwardk> we can add negated
14:10:56 <chrisdone> luite: hm, what kind of tests? that's worrying
14:11:31 <luite> chrisdone: just tests from the nofib benchmark suite that i compile with ghcjs, compare against native haskell
14:12:42 <chrisdone> luite: is that a development version of their interpreter or release?
14:13:09 <luite> chrisdone: development, it's alpha builds, will end up in firefox 32 unless the bugs bump it to a later version
14:13:28 * hackagebot simple-session 0.9.0.0 - Cookie-based session management for the Simple web framework  http://hackage.haskell.org/package/simple-session-0.9.0.0 (AmitLevy)
14:14:02 <chrisdone> luite: ah, good
14:14:07 <edwardk> Mathnerd314: https://github.com/ekmett/lens/commit/5936d08335932d972eeb23e3a4dcbc83dcfbc46d
14:14:37 <luite> chrisdone: http://download.cdn.mozilla.net/pub/firefox/nightly/latest-mozilla-central/ , jsshell from here, i then just run `./dist/build/test/test --benchmark' to run the suite, but with the new jsshell i ahve to keep killing hung js processes, otherwise it never finishes
14:15:01 <Mathnerd314> edwardk: thanks. I might actually end up using that...
14:15:23 <luite> chrisdone: i wish there was an easy command-line prog with the IE JS engine :)
14:16:12 <parc> @hoogle Maybe b -> Either a b
14:16:14 <lambdabot> Prelude Right :: b -> Either a b
14:16:14 <lambdabot> Data.Either Right :: b -> Either a b
14:16:14 <lambdabot> Prelude Left :: a -> Either a b
14:16:35 <chrisdone> luite: you probably have to install Microsoft Office to run the JS compiler
14:17:17 <chrisdone> and Microsoft Enterprise Development Express Edition 2014 Ⓡ
14:17:20 <luite> :)
14:18:14 <luite> chrisdone: it probably has some .NET API though
14:19:08 <chrisdone> true, back in VB 6 days you could use an ActiveX control to run scripts
14:19:13 <Guest62065> ciao
14:19:17 <Guest62065> !list
14:19:17 <monochrom> Guest62065: http://lpaste.net/browse
14:19:27 <chrisdone> ciao, comè
14:19:32 <gilligan_> i'm slightly confused. Why does hoogle not find anything from the timers package ? (http://hackage.haskell.org/package/timers-0.2.0.0/docs/Control-Concurrent-Timer.html)  -- For example searching for "TimerIO -> IO Bool" does not yield any results
14:19:45 <Krakarn> does anyone even use vb?
14:19:47 <chrisdone> hoogle only searches base packages because reasons
14:19:52 <ion> monochrom++
14:20:06 <Krakarn> just wondering
14:20:06 <monochrom> heh
14:20:10 <chrisdone> Krakarn: i think it's big in MS Access/Excel products
14:20:42 <luite> chrisdone: are you still in italy by the way? I took some zurihackers to italy earlier this week :)
14:20:54 <Guest62065> http://lpaste.net/browse
14:21:00 <chrisdone> we don't want to spend $5000 on an accounting system so we'll spend $10000 worth of time working with cheap developers to make something 50% as good and 200% as dangerous
14:21:03 <Krakarn> chrisdone: I mean it seems like it's ancient technolog
14:21:04 <Krakarn> y
14:21:13 <ion> I and friends wrote a demo in Excel VBA once.
14:21:34 <benzrf> chrisdone: http://www.reddit.com/r/ProgrammerHumor/comments/26uvij/if_carpenters_were_hired_like_programmers_xpost/
14:21:38 <chrisdone> Krakarn: to be honest VB is all about the development environment and libraries, and in that sense it beats Haskell
14:22:32 <Krakarn> chrisdone: well I wonder how good it would feel to program in vb
14:22:34 <chrisdone> the language may suck but in 5 minutes i can have a GUI and a little networked pong game that can play sound and embed rich editing in the app
14:23:12 <chrisdone> you can have that in about 3 hours in haskell, if you're on the right system and you're lucky
14:23:50 <chrisdone> it feels pretty lame, the language isn't much more advanced than BASIC of the 80's
14:24:56 <chrisdone> benzrf: it's a goodie =) also the tech meeting video about making triangles and circles and colors
14:25:32 <TheMoonMaster> Quick question, what's the best resource to get up to speed with Haskell now? Still Learn You a Haskell?
14:25:58 <chrisdone> it's a popular one
14:26:04 <Krakarn> TheMoonMaster: Real World Haskell is a good source i think alos
14:26:11 <Krakarn> also*
14:26:17 <chrisdone> i'm told by opinionated people that this is better http://www.seas.upenn.edu/~cis194/lectures.html
14:26:27 <TheMoonMaster> Krakarn: Yeah, both of them are kind of weird to me for whatever reason, but I'm trying to tough it out.
14:27:04 <TheMoonMaster> chrisdone: Thanks, I'll check it out.
14:27:05 <Eduard_Munteanu> chrisdone: hm, who wrote that?
14:27:07 <benzrf> chrisdone: the rock is a metaphor for node.js
14:27:10 <Krakarn> I learned a good deal of haskell concepts through learn you a haskell, and I come from an imperative background
14:27:19 <Eduard_Munteanu> Oh, byorgey.
14:27:35 <TheMoonMaster> Yeah, I come from mostly Ruby, but I do have decent knowledge of Clojure and Elixir/Erlang
14:28:04 <benzrf> sup TheMoonMaster
14:28:12 <benzrf> i think i've mis-pinged you before in #ruby
14:28:15 <benzrf> when typing 'them'
14:28:21 <TheMoonMaster> Haha, you have!
14:28:38 <TheMoonMaster> I get mis-pinged far too often
14:28:52 <Lutin`> How can I parallelize evaluations in the list monad? Or does GHC do it automatically?
14:29:15 <chrisdone> i think byorger's style is a bit more direct
14:29:18 <luite> Lutin`: it doesn't do it automatically
14:29:22 <chrisdone> i thik it depends on your learning style though
14:29:32 <Krakarn> heres an old lecture on functional programming: https://www.youtube.com/watch?v=2Op3QLzMgSY
14:29:33 <Krakarn> :D
14:29:38 <chrisdone> i enjoyed YAHT (an old haskell book they used to recommend here) because it had exercises
14:29:45 <benzrf> Lutin`: i think there's a monad for that
14:29:48 <benzrf> but i dont remember
14:30:03 * benzrf googles 'parallel list monad'
14:30:07 <luite> Lutin`: see Control.
14:30:07 <ion> Why would an IRC client do that? (I guess for the same reason mIRC et al. have ruined NOTICE for everyone.)
14:30:09 <chrisdone> i'm more hands-on when learning. others can just read lots of prose and get it
14:30:12 <luite> Lutin`: see Control.Parallel.Strategies
14:30:18 <Lutin`> Lutin`: Alright thanks
14:30:32 <benzrf> ion: i press tab-backsp while typing in vim, etc as a bad habit
14:30:39 <benzrf> or rather, mash-erase
14:30:44 <benzrf> ion: in irc it does not work so well
14:30:51 <chrisdone> benzrf: begone heathen!
14:31:02 <ion> oh,  ok
14:31:06 <benzrf> 'them<tab>' -> 'TheMoonMaster <backsp>' -> 'TheMoonMaster'
14:31:10 * chrisdone throws lambdas at benzrf
14:31:12 <tulcod> during the compilation of my haskell code, i need access to another library's data files (for template haskell related stuff), but its location may be system dependent. i can request their location using pkg-config. what's the cleanest way to do that from my package? just run pkg-config in a runIO? or is there some build-time option to pass pkg-config data along as constants?
14:31:26 <TheMoonMaster> benzrf: It's usually completing others names so it seems.
14:31:32 <benzrf> http://hackage.haskell.org/package/monad-parallel-0.5.1/docs/Control-Monad-Parallel.html from googles
14:31:45 <TheMoonMaster> Also, not trying to start a debate but just curious, do Haskell programmers more often use Vim or Emacs?
14:31:48 <Lutin`> And I'm wanting to parse a CSV into a list of my own data type. Should I use Parsec for the CSV parsing, or Data.CSV + Parsec
14:31:49 * FireFly throws 6's back on chrisdone
14:32:00 <benzrf> oh wait
14:32:04 <benzrf> no thats wrong i think
14:32:06 <benzrf> TheMoonMaster: i use vim
14:32:06 <FireFly> or at I guess
14:32:12 <benzrf> TheMoonMaster: i think emacs is probably a popular choice
14:32:15 <tulcod> TheMoonMaster: emacs here
14:32:20 <TheMoonMaster> Really? Neat.
14:32:20 <bergmark> tulcod: does the package expose ts Paths module?
14:32:22 <benzrf> since there's so much an editor can do in a language like haskell
14:32:22 <FireFly> Both are probably popular
14:32:24 <Krakarn> I use vim but I think emacs is more popular, although I'm not sure
14:32:27 <ab9rf> Lutin`: why nt use cassava?
14:32:27 <tulcod> its flycheck capability is very nice
14:32:32 <tulcod> bergmark: no, it's a C library
14:32:36 <benzrf> in languages like ruby, the editor can only do so much
14:32:37 <Lutin`> ab9rf: Didn't know about it, I'll check it out. Thanks
14:32:40 <TheMoonMaster> I'm a Vim guy, but I definitely assumed Emacs would be more popular.
14:32:47 <afarmer> lhs2tex question... line spacing seems to be inherited from document... anyone know how to force single spacing?
14:32:50 <FireFly> I use vim too, but I'm not much of a haskeller
14:32:53 <benzrf> but haskell has even more potential for editor assistance than, say, java
14:32:53 <chrisdone> themoonmaster: a debate will start whether or not you're trying to create one =p
14:32:58 <bergmark> tulcod: ok, then i don't know
14:33:01 <benzrf> so emacs works well with that afaik
14:33:04 <ab9rf> Lutin`: cassava offers the use of custom type conversions
14:33:06 <benzrf> [i still use vim B)]
14:33:12 <tulcod> bergmark: do you know if i can run commands in my .cabal file?
14:33:20 <TheMoonMaster> chrisdone: Eh, I can always hope everyone is civil enough.
14:33:25 <bergmark> tulcod: you can use a custom Setup.hs
14:33:30 <TheMoonMaster> I'm a Vim guy, but some emacs features make me super jealous.
14:33:50 <chrisdone> themoonmaster: we are in here, it's more tongue-in-cheek =p
14:33:53 <bergmark> tulcod: it's pretty fragile though, it doesn't have explicit dependencies
14:34:01 <tulcod> TheMoonMaster: not having a sore pinky makes me super jealous of vim users ;)
14:34:07 <TheMoonMaster> Hahaha
14:34:08 <Lutin`> TheMoonMaster: Yeah I tried switching to emacs just for the plugins, but I missed vim to much :[
14:34:09 <ab9rf> Lutin`: you can imbed whatever parser you want in the field converters, which could be parsec if you like
14:34:21 <ab9rf> Lutin`: no point in reinventing the wheel for the csv parsing itself
14:34:21 <ion> TheMoonMaster: I'm a vim user at the moment but i should get around to learning emacs. Some very nice Haskell-related things seem to exist for it. Also, org-mode
14:34:27 <benzrf> TheMoonMaster: i find that haskell generally has a pretty nice community
14:34:30 <tulcod> bergmark: thanks
14:34:33 <benzrf> at least, #haskell is pretty nice :-D
14:34:36 <chrisdone> org-mode is a reason all of its own
14:34:43 <Lutin`> ab9rf: Ah cassava is the Data.CSV I was referring to
14:34:44 <TheMoonMaster> Yeah, Haskell programmers seem to be more chill than most other communities
14:35:29 <chrisdone> cavassa and csv-conduit are both high quality csv libs
14:35:33 <TheMoonMaster> My company is practically ALL vim users anyways.
14:35:38 <chrisdone> i switch between them depending on my use-case
14:35:46 <benzrf> ruby seems nice also but in a slightly different Wayneoween
14:35:48 <Lutin`> and it looks like cassava uses attoparsec so I might use that
14:35:49 <benzrf> *way
14:35:51 <ab9rf> Lutin`: the decode function in cassava is wildly polymorphic and you can alter its performance by specifying an explicit type signature
14:35:56 <Eduard_Munteanu> Hm, there should be a liftSourceFromSink :: Monad m => Source (Sink a m ()) a ()
14:35:57 <benzrf> perhaps a more immature way :s
14:36:10 <Lutin`> Writing a little program to come up with my course schedule for me :P
14:36:40 <chrisdone> eduard_munteanu: hm what does that mean?
14:36:47 <ab9rf> Lutin`: you can also write your own FromField and ToField instances
14:37:28 <chrisdone> eduard_munteanu: oh, sink is the monad in which your source is running. i see.
14:37:42 <Lutin`> ab9rf: Yeah that's what I was just looking at.
14:37:48 <Lutin`> Thanks for the help everyone
14:37:52 <chrisdone> you can do the same with csv-conduit
14:38:07 <chrisdone> cavassa provides a bunch of instances for common data types, though, so that's handy
14:38:11 <Eduard_Munteanu> chrisdone: oh?
14:38:11 <Lutin`> Not very familiar with conduit but it might be a nice learning experience
14:38:17 <TheMoonMaster> I still need to figure out wtf a monad is.
14:38:17 <TheMoonMaster> My Haskell learning has been severely offput in favor of Erlang/Elixir and Clojure, but now I'm kind of regretting that.
14:38:36 <benzrf> TheMoonMaster: dw about monads
14:38:38 <chrisdone> eduard_munteanu: right?
14:38:41 <levi> Don't worry too much about what a monad 'is'.
14:38:42 <benzrf> try functors first
14:39:02 <Lutin`> TheMoonMaster: I've found once you start using things that are monads, the understanding of monads in general comes pretty easily
14:39:12 <chrisdone> eduard_munteanu: the many type aliases in conduit confuse me, i forget what goes where
14:39:15 <TheMoonMaster> Gotcha.
14:39:30 <TheMoonMaster> I'll probably start by writing an IRC bot since that's usually my "Hello world" when learning new langauges.
14:39:38 <TheMoonMaster> It just seems slightly more difficult with Haskell.
14:39:39 <ab9rf> TheMoonMaster: monads are these weird critters who like to eat burritos but only after they unwrap them.  ignore them, and go have a taco instead
14:39:40 <chrisdone> irc bots, classic
14:39:53 <TheMoonMaster> ab9rf: Those bastards!
14:39:55 <Eduard_Munteanu> chrisdone: it's supposed to await input from the underlying sink monad and source them.
14:39:56 <chrisdone> irc bots and lisp interpreters
14:40:02 <tulcod> TheMoonMaster: trying to understand what monads are as a goal per se is like trying to grep the number 0 before having had to count apples
14:40:05 <TheMoonMaster> Write you a scheme!
14:40:06 <Lutin`> heh first program I wrote was an IRC bot in PHP
14:40:06 <levi> The Typeclassopedia is a good reference for what the various funny-named typeclasses are and how they relate to one another.
14:40:08 <benzrf> @let newtype WeirdFunctor = WeirdFunctor String
14:40:10 <lambdabot>  Defined.
14:40:18 <benzrf> o wait
14:40:19 <Lutin`> God save my soul
14:40:26 <benzrf> derp
14:40:28 <benzrf> @undefine
14:40:28 <lambdabot> Undefined.
14:40:36 <benzrf> @let newtype WeirdFunctor a = WeirdFunctor [a]
14:40:37 <lambdabot>  Defined.
14:40:37 <TheMoonMaster> I wrote PHP, but never tried to write a PHP IRC bot.
14:40:41 <tulcod> TheMoonMaster: just write some darned haskell code - you'll quickly see where you can use some neat construction to simplify stuff
14:40:50 <TheMoonMaster> I'm so sorry Lutin`
14:40:52 <ab9rf> TheMoonMaster: now that sounds like masochism
14:40:59 <benzrf> nooooo hold on p:
14:41:03 <benzrf> shit
14:41:07 <TheMoonMaster> ab9rf: I started with PHP, but learned better when I found Ruby.
14:41:10 <benzrf> @undefine
14:41:11 <lambdabot> Undefined.
14:41:12 <chrisdone> eduard_munteanu: what's the implementation?
14:41:21 <Lutin`> TheMoonMaster: Same for me, but Python instead of Ruby
14:41:24 <ab9rf> TheMoonMaster: i'm not sure that's an improvement
14:41:27 <benzrf> @let data WeirdFunctor a where WeirdFunctor :: [a] -> WeirdFunctor a a
14:41:28 <lambdabot>  .L.hs:148:32:
14:41:28 <lambdabot>      ‘WeirdFunctor’ is applied to too many type arguments
14:41:28 <lambdabot>      In the type ‘WeirdFunctor a a’
14:41:28 <lambdabot>      In the definition of data constructor ‘WeirdFunctor’
14:41:28 <lambdabot>      In the data declaration for ‘WeirdFunctor’
14:41:33 <benzrf> blah
14:41:36 <benzrf> @let data WeirdFunctor a b where WeirdFunctor :: [a] -> WeirdFunctor a a
14:41:37 <lambdabot>  Defined.
14:41:40 <TheMoonMaster> ab9rf: Oh come on, don't hate on Ruby.
14:41:58 <benzrf> ooooh no that doesnt work
14:42:00 <benzrf> crud, trumped
14:42:07 <benzrf> =D
14:42:11 <levi> Let's just not hate on any languages here.
14:42:12 <benzrf> @undefine
14:42:13 <lambdabot> Undefined.
14:42:17 <benzrf> levi: besides php of course
14:42:18 <Lutin`> benzrf: There's this great thing called ghci, not sure if you've heard of it..
14:42:20 <Lutin`> haha
14:42:25 <benzrf> pfft
14:42:27 <chrisdone> themoonmaster: fwiw you should feel like you really grok the haskell type system and type classes first, then monads, applicatives, etc. will come naturally. otherwise it's a bit like running before you can walk
14:42:28 <benzrf> i dont have it on here
14:42:31 <benzrf> ARM ;-;
14:42:49 <levi> benzrf: Well, best not to hate too much on PHP either. Just makes for noise.
14:42:51 <pantsman-> no language is beyond hate
14:42:52 <benzrf> TheMoonMaster: trying to learn monads first thing in haskell is kind of like trying to understand mixins first thing in ruby when you dont know any programming yet
14:42:57 <TheMoonMaster> chrisdone: Yeah, I'm rocking type classes right now.
14:43:07 <ab9rf> TheMoonMaster: i hate every language, including haskell :)
14:43:12 <TheMoonMaster> Thanks for all the tips and help guys, you're awesome.
14:43:13 <Eduard_Munteanu> chrisdone: I'm working on it now, but basically  fix $ \loop -> lift await >>= mapM_ (\x -> yield x >> loop)
14:43:21 <benzrf> TheMoonMaster: damn straight we are!
14:43:23 <TheMoonMaster> A lot kinder and helpful than some other communities.
14:43:23 <levi> You can hate on any language you want, just don't express it *here*, because it reduces the signal/noise ratio.
14:44:03 <chrisdone> themoonmaster: good luck! oh, and try to use the text and bytestring packages when you decide to do IO
14:44:14 <Lutin`> :t id
14:44:15 <TheMoonMaster> I'm taking down notes, so I definitely will.
14:44:15 <lambdabot> a -> a
14:44:18 <TheMoonMaster> And thanks.
14:44:19 <Eduard_Munteanu> (mapM_ from Foldable)
14:44:33 <chrisdone> the base System.IO stuff is all String-based, which is not evil in and of itself, but it's all lazy IO and that's tricky and full of pitfalls even for experienced haskellers
14:44:36 <levi> TheMoonMaster: Have you learned about kinds at all yet?
14:45:04 <chrisdone> so i.e. that's Data.Text for text, and Data.ByteString for binary data
14:45:05 <Lutin`> Huh so how does `join m = m >>= id` typecheck? Shouldn't the type of id be `a -> M a`?
14:45:17 <TheMoonMaster> levi: A bit
14:45:19 <TheMoonMaster> Yeah
14:45:20 <chrisdone> might also come in handy http://dev.stephendiehl.com/hask/
14:45:54 <Lutin`> or `a -> m b`
14:46:05 <TheMoonMaster> Definitely
14:46:10 <TheMoonMaster> cabal is still a bit mysterious as well
14:46:50 <chrisdone> :t (>>=)
14:46:51 <lambdabot> Monad m => m a -> (a -> m b) -> m b
14:46:53 <chrisdone> :t (>>= id)
14:46:54 <lambdabot> Monad m => m (m b) -> m b
14:47:01 <chrisdone> :t join
14:47:01 <piezoid> Lutin`: no it's `m a -> m a`, but the type of m is `m (m a)`
14:47:02 <lambdabot> Monad m => m (m a) -> m a
14:47:06 <Lutin`> Ahhh
14:47:19 <Eduard_Munteanu> chrisdone: consider a sink that dispatches output to a bunch of consumers (e.g. file writers): Monad m => (Source (Sink Something m ()) ByteString -> Integer -> Sink Something m ()) -> Sink Something m ()
14:47:27 <benzrf> :k Source
14:47:28 <lambdabot> Not in scope: type constructor or class ‘Source’
14:48:24 <Lutin`> piezoid: That makes sense
14:49:06 <Eduard_Munteanu> chrisdone: you could call that as dispatcher (\s i -> ... s $$ sinkFile ...)  (where i can be used to derive a filename)
14:49:31 <Eduard_Munteanu> Anyway, that's the problem I'm trying to solve.
14:49:38 <chrisdone> eduard_munteanu: i have no idea what you're talking about :)
14:50:24 <Eduard_Munteanu> Eh, I'm working around the lack of multiple inputs/outputs in conduits.
14:50:43 * Eduard_Munteanu stops rambling :)
14:52:03 <chrisdone> eduard_munteanu: something like stdout/stderr?
14:52:18 * chrisdone was playing with conduits for a shell earlier this evening
14:52:52 <Eduard_Munteanu> chrisdone: more like reading a stream of data and writing to multiple files from it
14:53:04 <chrisdone> ahh
14:53:12 <golgotha> quick question, i've been out of #haskell for a while. is the haskell platform development still in active development?
14:53:19 <agsel> hi. I have a theoretical question. I have a While language and have to show how a special statement "sandwich" acts with certain state using continuation style semantics. sandwich is defined by S[[sandwich Stm]] k s = S[[Stm]] k (k s)
14:53:19 <agsel> so, how would it be calculated for a statement: sandwich (x := x * 2); x := x + 1
14:53:19 <agsel> I'm just having trouble with how should I operate with k (k s). let's say x = 1 in the beginning. first I probably have to solve  x := x + 1, e.g. x = 2. now should I do x *= 2 (x will be 2) and now what? again x*=2? or x += 1? I might understand it wrong, this S[[stm]] k (k s) part
14:53:29 <agsel> sry, a long post :)
14:53:48 <tulcod> golgotha: yes
14:54:24 <chrisdone> eduard_munteanu: so you're in a sink consuming Somethings but then you're passing that onto two other sinks to write to two separte files
14:54:37 <chrisdone> i've seen *that* done somewhere before
14:54:37 <golgotha> tulcod: is the latest version delayed due to the 7.8 release + the monad-instance-of-applicative thing?
14:55:41 <bergmark> golgotha: the 7.8 release yes, the monad-applicative will be in 7.10
14:55:43 <Eduard_Munteanu> chrisdone: yes, passing them as sources to some function that sinks them
14:55:49 <chrisdone> golgotha: this might be of interest http://haskell-lang.org/downloads/linux
14:56:30 <bergmark> golgotha: now they are delaying for 7.8.3, check the haskell-platform mailing list
14:56:34 <isomorpheous> So, I'm having trouble installing darcs
14:56:39 <isomorpheous> apparently I have a conflict
14:56:46 <chrisdone> eduard_munteanu: i did multiple inputs for this once: sourcesEqual :: (Eq b, Monad m) => Source m b -> Source m b -> m (Maybe Bool)
14:56:47 <isomorpheous> and cabal's error message is very cryptic
14:57:02 <Lutin`> isomorpheous: Just put it on lpaste and someone should be able to decipher it
14:57:11 <golgotha> chrisdone: thanks. great job on the 'alternative' portal btw
14:57:21 <golgotha> i'm on windows, though. i know, kill me.
14:57:42 <chrisdone> golgotha: ah, lol
14:57:43 <golgotha> bergmark: ah, didn't think of the mailing list. i only checked the wiki.
14:57:52 <Lutin`> chrisdone: I didn't notice your design was accepted :D
14:57:55 <Lutin`> Congrats!
14:57:55 <chrisdone> golgotha: yeah, the only download on there is http://haskell-lang.org/downloads/windows
14:58:01 <chrisdone> which you already tried
14:58:28 <chrisdone> Lutin`: actually it's not yet, the domain here is different. it's not ready for prime-time yet, although i am linking it sometimes
14:59:03 <darthdeus> is there a way to check if a function conforms to a given type signature? for example if I have a bunch of type aliases, and I want to check if some of the builtin functions has the same type, or if it can be used with one
14:59:32 <Lutin^> Crap I think I have a loose cable on my desktop
14:59:34 <bergmark> darthdeus: you can put them in a list and see if it typechecks
14:59:36 <isomorpheous> Lutin`: http://lpaste.net/105611
14:59:40 <isomorpheous> or someone
14:59:41 <bergmark> or yjust add an explicit type signature
14:59:48 <Lutin^> Just bumped into it and it froze :[
14:59:50 <golgotha> chrisdone: yeah. i had it from a long time ago. i'm usually on a mac os x box, but i'm stuck on windows on this box. maybe i should run from within a vm... thanks anyway.
14:59:56 <darthdeus> oh lol i didn't think of that :D thanks
15:00:15 <isomorpheous> I think something needs array
15:00:20 <tulcod> hah, i love the "Concise and Reliable: Pick Two" on haskell-lang.org home
15:00:21 <isomorpheous> and array conflicts with time
15:00:24 <bergmark> isomorpheous: darcs needs an older ghc
15:00:28 <isomorpheous> ah
15:00:37 <tulcod> it's a real good project
15:00:44 <chrisdone> tulcod: someone contributed that =p
15:00:53 <isomorpheous> is there a darcs-devel package, or something?
15:01:01 <tulcod> chrisdone: i think there should be more of those
15:01:07 <Lutin^> isomorpheous: It's between deepseq and darcs
15:01:20 <tulcod> cause those are exactly the reason haskell is such a great language. it really does things fundamentally differently
15:01:23 <random99> Is there an elegant solution for "pretty-printing" a list of integers?
15:01:37 <random99> I've got integers that are up to six digits long, in a list of lists
15:01:45 <random99> and I'd like to print them with a nice tab separation
15:01:49 <chrisdone> tulcod: yeah, i wanted to put laziness and purity on there. the guy who contributed didn't know what to write for them, but i have some ideas. examples will help illustrate why they're good ideas
15:01:49 <random99> so that the spacing is even
15:02:02 <tulcod> chrisdone: also, mad props for the in-browser interpreter whihc even icnludes IO
15:02:09 <Lutin^> isomorpheous: deepseq wants array=0.5.0.0, darcs wants array>=0.1 && <0.5
15:02:18 <chrisdone> tulcod: hehe, thanks. it comes from http://tryhaskell.org/
15:02:20 <isomorpheous> Thank you
15:02:30 <golgotha> chrisdone: the examples from the oldish programming in haskell book that showcases lazy vs eager are quite good imho
15:02:31 <chrisdone> woah, there are a lot of active users right now
15:02:34 <isomorpheous> yeah, even darcs-beta doesn't work
15:02:37 <Eduard_Munteanu> darthdeus: if you want to test types, with DataKinds (and maybe PolyKinds) you can do  data (==) :: k -> k -> *  where Refl :: a == a   then shouldEqual :: someType == otherType; shouldEqual = Refl
15:02:43 <chrisdone> 9 people on this moment
15:02:51 <Lutin^> isomorpheous: I wonder if deepseq was just recently updated
15:03:16 <Lutin^> or time or random was
15:03:16 <tulcod> chrisdone: maybe something along the lines of "tired of coming up with arbitrary bounds? of computing just the first N primes? in haskell, you can just compute all of them."
15:03:24 <kadoban> random99: You probably want Text.Printf.printf I would think?
15:03:43 <golgotha> i think newcomers should be warned that reliable depends on totality though.
15:03:58 <random99> kadoban: thanks, that sounds promising!
15:04:04 <golgotha> pattern match failures are one of the first gotchas imo
15:04:35 <tulcod> chrisdone: anyway, keep it up - i think you're solving an important issue with marketing haskell
15:04:40 <zwer> indeed. I think warn-incomplete-patterns should be on by default
15:04:42 <chrisdone> tulcod: mhm. i can think of three great things about laziness: infinite data structures, order of where/let declarations not mattering (leads to better abstraction), and composition of combinators (foldr/takeWhile/drop/scanl/etc)
15:05:06 <tulcod> chrisdone: the latter two won't make sense to people who haven't programmed in haskell
15:05:16 <chrisdone> tulcod: yep, that's where the examples come in
15:05:25 <tulcod> chrisdone: if you want to mention those, you'll need more arguments
15:05:27 <chrisdone> i managed to explain to a lisper why the latter two are actually cool
15:05:28 <Lutin`> test
15:05:40 <tulcod> well yeah, a lisper
15:05:41 <Lutin`> Oh god what is with my internet
15:05:46 <tulcod> Lutin`: pong
15:06:01 <isomorpheous> chrisdone: you're the shm maintainer, aren't you
15:06:06 <chrisdone> yep
15:06:09 <golgotha> zwer: agreed1
15:06:18 <tulcod> chrisdone: i mean you can focus on haskell being about what you /mean/ rather than being restricted by syntax oddities
15:06:33 <tulcod> and as part of that, yeah, order of stuff doesn't matter
15:06:41 <tulcod> hm. kinda like latin
15:06:45 <chrisdone> i mean this is a classic example:
15:06:45 <isomorpheous> chrisdone: Love shm. However, it doesn't have very good support for evil-mode. Are you planning on adding in any support for evil, or do I have to learn elisp and figure out how to do it myself?
15:07:02 <tulcod> chrisdone: (yeah also thanks for shm. using it as we speak)
15:07:19 <Tjr> Hi, I'm trying to solve tonymorris's intermediate haskell exercise #12 http://lpaste.net/105613
15:07:32 <marchelzo_> what is shm?
15:07:35 <Lutin`> dropping packets or something
15:07:48 <Tjr> Can anybody help me find a way to express jellybean in terms of banana and unicorn?
15:07:52 <tulcod> structured haskell mode
15:07:53 <tulcod> emacs plugin
15:08:17 <marchelzo_> is there anything similar for vim?
15:08:31 <tulcod> gives you a kind of expensive IDE feeling while programming
15:08:41 <enthropy> Tjr: pass a function with the right type to banana
15:08:52 <chrisdone> hm, i have a good example somewhere. i'll find it
15:08:54 <enthropy> dunno how you can get help without having the answer spoiled
15:08:56 <tulcod> marchelzo_: well some of its features are implemented more generally
15:09:05 <ion> tjr: Can you find an a and a b such that m a -> m b = m (m z) -> m z?
15:09:11 <tulcod> like, some smart indentation heursitics
15:09:15 <tulcod> but this plugin nails it
15:09:34 <chrisdone> isomorpheous: i don't know any evil. maybe the evil manual has instructions for how to add support for modes?
15:09:55 <Lutin`> Huh.. isomorpheous I think it might be an issue with cabal
15:10:06 <isomorpheous> Lutin`: Yeah
15:10:16 <isomorpheous> Lutin`: I think it's that darcs is poorly maintained
15:10:17 <Tjr> enthropy, ion still thinking about your hings
15:10:18 <Tjr> hints
15:10:29 <isomorpheous> I knew there was a reason I use git
15:10:31 <chrisdone> tulcod: cool, nice to hear someone besides me uses it =) it's not perfect but it improves all the time
15:10:32 <Lutin`> The deepseq package doesn't require array=0.5.0.0 just >=0.3 && <0.6
15:10:47 <Lutin`> But I guess when you installed it, it compiled against 0.5.0.0
15:10:52 <isomorpheous> chrisdone: I say that it doesn't work, but I don't have the latest version
15:11:04 <Lutin`> So cabal doesn't want to reinstall it against an older version of cabal
15:11:19 <pjdelport> Tjr: Cryptic hint: think about peeling a banana.
15:11:39 <Lutin`> older version of array*
15:11:40 <noctux> marchelzo_: well, there is basic support for it, but what i've heard shm is superior as of now... you might find interest in: vim-scripts/haskell.vim, lukerandall/haskellmode-vim, ujihisa/neco-ghc, bitc/lushtags and bitc/hdevtools however
15:11:41 <isomorpheous> the issue is that old versions of array don't compile
15:11:57 <Lutin`> 0.4.0.1 doesn't?
15:12:04 <marchelzo_> noctux: thanks, I'll check those out
15:12:06 <noctux> marchelzo_: the last one (hdevtools) however is said to be broken with very recent ghc versions
15:12:32 <tulcod> marchelzo_: now i am not quite up to date with vim's plugins, but emacs really has a very wide ranging and high quality base of plugins for all kinds of stuff
15:13:01 <noctux> marchelzo_: oh, and as we are speaking of it: lushtags should be used with tagbar, without it, it is a bit useless
15:13:36 * hackagebot tellbot 0.3.3.1 - IRC tellbot  http://hackage.haskell.org/package/tellbot-0.3.3.1 (DimitriSabadie)
15:13:36 <isomorpheous> alias pb='pastebinit -b http://lpaste.net'
15:13:38 <isomorpheous> oops
15:13:44 <isomorpheous> http://lpaste.net/105615
15:13:46 <isomorpheous> there we go
15:14:18 <isomorpheous> That's what happens when one tries to install array-0.3.0.0
15:14:34 <Lutin`> isomorpheous: Does 0.4.0.1 have the same issue?
15:14:57 <marchelzo_> tulcod: what is the best way to learn emacs? I haven't been able to find any good tutorials on youtube, and that is the main reason I began using vim
15:15:02 <Tjr> enthropy, ion, pjdelport I got it now: jellybean = banana id (not sure about peeling, though)
15:15:32 <isomorpheous> http://ix.io/cYj
15:15:36 <tulcod> marchelzo_: for both vim and emacs, i started out by printing out a cheatsheat and doing the "usual" tutorial
15:15:36 <sm> marchelzo_: there's an interactive tutorial and an excellent manual built in
15:15:45 <isomorpheous> Here we go
15:15:46 <isomorpheous> http://ix.io/cYj
15:15:46 <phaazon> hey
15:15:49 <zwer> don't know about best, but emacs includes a tutorial C-h-t (control + h followed by t)
15:15:50 <tulcod> marchelzo_: just keep the cheatsheet with your computer for a while until you don't need it
15:15:52 <phaazon> what do you think of JuicyPixels? :)
15:15:53 <isomorpheous> different issue, but it still doesn't work
15:16:18 <marchelzo_> alright, I'll give emacs another go
15:16:22 <Lutin`> isomorpheous: Ah, yeah darcs just needs to update for 7.8
15:16:32 <noctux> marchelzo_: there is also evil, and plugin for vi-like modal editing that I use whenever I have to use emacs
15:16:39 <pjdelport> Tjr: That's right. The peeling metaphor comes from the fact that you're basically making banana id strip a layer of Misty from its input.
15:16:51 <isomorpheous> Lutin`: I would contribute the patch myself, but I can't seem to install darcs, so I can't clone the project
15:16:55 <phaazon> I guess I should ask on #haskell-game
15:17:01 <Lutin`> Oh the irony
15:17:01 <isomorpheous> This seems like the darcs maintainer's fault
15:17:05 <marchelzo_> noctux: Yeah I heard about that.. I think I will use that. thanks for reminding me
15:17:35 <Lutin`> isomorpheous: Well it hasn't been touched in 16 months so...
15:17:50 <pjdelport> In other words, when you pass id to banana, your constraining a in the type to (m b), getting banana :: (m b -> m b) -> m (m b) -> m b
15:18:23 <isomorpheous> Lutin`: I'm thinking then that it's dead
15:18:38 <pjdelport> Tjr: The latter bit, m (m b) -> m b, is jellybean / join. :)
15:18:49 <sm> Lutin`, isomorpheous: #darcs could use your help
15:18:56 <isomorpheous> git was last updated 2 days ago
15:19:20 <isomorpheous> hg is confusing to use
15:19:23 <isomorpheous> damn
15:19:26 <Lutin`> isomorpheous: It's still in development, but ghc 7.8 support wasn't possible until maybe a month ago
15:19:52 <isomorpheous> 16 months of no development /= "still in development"
15:19:53 <Lutin`> But it looks to still be unstable
15:20:10 <Lutin`> 16 months of no release /= not in development
15:20:28 <isomorpheous> 16 months of no release = "not in development"
15:20:38 <isomorpheous> that's obscene
15:20:42 <tulcod> isomorpheous: e19
15:20:57 <tulcod> or what was it? 17?
15:21:12 <isomorpheous> i3 user here
15:21:51 <Lutin`> isomorpheous: There was a commit to darcs-screened 2 days ago
15:22:56 <isomorpheous> 7.8 has been around for what? 2 months?
15:22:59 <Lutin`> And GHC 7.8 support has existed for about 2 weeks
15:23:08 <isomorpheous> Lutin`: my point
15:23:12 <isomorpheous> exactly
15:23:28 <isomorpheous> they aren't making an appropriate effort to maintain their project
15:23:37 <Lutin`> Yes IMO something like darcs should be tested against GHC HEAD
15:23:53 <tulcod> isomorpheous: i'm making a point. e17 was under development for 12 years
15:24:00 <isomorpheous> jesus
15:24:03 <isomorpheous> that's awful
15:24:08 <tulcod> no. it was a success
15:24:11 <isomorpheous> actually, maybe
15:24:23 <tulcod> since then, the new versions have been flying out of the door
15:24:26 <isomorpheous> here's the difference - nobody can use darcs, because they aren't maintaining it fast enough
15:24:29 <tulcod> they have been extremely productive
15:24:39 <Lutin`> You could just not use GHC 7.8
15:24:50 <Lutin`> for darcs
15:24:56 <isomorpheous> and break every other package?
15:24:57 <isomorpheous> nice
15:25:03 <Lutin`> Multiple installs?
15:25:14 <isomorpheous> i could sandbox
15:25:19 <isomorpheous> but that would defeat the point
15:25:38 <isomorpheous> also, git seems to be faster than darcs
15:25:47 <isomorpheous> might not be quite as elegant
15:25:50 <isomorpheous> but definitely faster
15:26:40 <isomorpheous> ah, you can download a binary
15:26:43 <isomorpheous> still annoying
15:27:32 <Lutin`> No one's forcing you to use it :P
15:27:42 <Lutin`> But I understand your point
15:28:02 <benzrf> how does await work exactly
15:28:13 <benzrf> wheres the docs
15:28:14 <benzrf> wait nvm
15:28:54 <benzrf> is await basically yield but doesnt yield anything
15:29:07 <Lutin`> Exactly? https://hackage.haskell.org/package/conduit-1.1.6/docs/src/Data-Conduit-Internal.html#await
15:29:17 <benzrf> im talkin about pipes not conduit
15:29:29 <Lutin`> ah
15:30:36 <tulcod> Lutin`: some people are by offering their source over darcs...
15:31:41 <Lutin`> Are you being forced to use their source?
15:31:56 <isomorpheous> Not me
15:32:01 <isomorpheous> I was just interested in trying it
15:32:19 <sm> just for the record, it's easy to install and use multiple GHC versions, no sandbox required
15:32:33 <tulcod> Lutin`: that argument is like saying i shouldn't complain about the banks because i'm not forced to give them my money :-/
15:32:37 <sm> cabal install darcs -w ghc-7.6.3
15:32:59 <Lutin`> tulcod: Yeah it's not a great argument
15:35:49 <Lutin`> tulcod: I think my issue was more with him complaining about how GHC 7.8 support for darcs has only been around for 2 weeks
15:36:08 <Lutin`> But there's a binary you can download, or if you really need to build from source you can still use 7.6
15:36:57 <Lutin`> I understand being frustrated with `cabal install darcs` not just working, but things need to be considered before you start slinging hate at a project
15:38:14 <benzrf> mmm pipes-concurrency looks kinda like pipes + 0mq
15:41:37 <covi> Why is Haskell better than Java?
15:41:53 <monochrom> why do you ask? what is your real motive?
15:46:03 <Lutin`> Hmm are there any bidriectional parsers being developed? I.E. where parsing would be considered a bijective function from the set of valid strings to a set of data types?
15:46:36 <monochrom> yes, but I have to take some time to find a reference
15:47:14 <Lutin`> Awesome, take your time
15:47:33 <chrisdone> Lutin`: json-grammar is such a parser
15:47:42 <joelteon> it's SUCH a parser
15:47:53 <chrisdone> omg such a parser
15:48:07 <chrisdone> much token consume
15:48:20 <joelteon> very backtrack
15:48:28 <benzrf> wouldnt a json parser be surjective but not bijective
15:49:17 <heatsink> copumpkin was looking at combinatiors that build both serializers and deserializers
15:49:20 <heatsink> which is similar
15:49:20 <benzrf> [] vs [ ]
15:49:26 <monochrom> bijective modulo unimportant things like how many spaces and orders of fields, ok?
15:49:42 <benzrf> eeeeh
15:49:44 <chrisdone> true, it's more of surjective due to redundancy in the parser
15:49:48 <bergmark> Lutin`: here's a fay one https://github.com/silkapp/pickler.js
15:50:01 <chrisdone> parser is a retraction of the printer section
15:51:37 <luite> chrisdone: JsonGrammar produces a Maybe result when converting to JSON, which makes it feel like there's something wrong with the approach. is there?
15:52:03 <copumpkin> I'm not a huge fan of the partial isomorphisms approach
15:52:22 <monochrom> Lutin`: http://thread.gmane.org/gmane.comp.lang.haskell.cafe/85652/focus=85659
15:52:32 <copumpkin> but JsonGrammar is pretty neat for several reasons
15:52:46 <copumpkin> and yeah, I've been tinkering with several approaches to the problem
15:52:50 <copumpkin> mostly in the context of binary formats
15:53:01 <bergmark> luite: maybe it's because aeson only allows objects and arrays at the top level, same as encode in aeson
15:53:02 <copumpkin> pre-existing ones, so you care about the actual layout
15:53:37 <Lutin`> I wouldn't necessarily care about things like [] vs [ ] since they are equivalent under the syntax
15:54:16 <copumpkin> it's adjunction-flavored more than isomorphism
15:54:20 <Lutin`> So I guess it would more of a category than a set
15:54:48 <Lutin`> There's that word again..guess it's time to learn it
15:55:24 <monochrom> you need only set theory and equivalence classes for this. highschool stuff.
15:55:50 <luite> bergmark: oh i asked at BudHac but they mentioned that they use unions of prisms and can't guarantee or enforce exhaustiveness
15:55:52 <monochrom> equivalence class is why I said "modulo"
15:56:11 <copumpkin> and prisms are also not particularly efficient for large sums
15:56:25 <monochrom> but I'm really more concerned that people are so anal and pedantic on side issues
15:57:01 <Lutin`> monochrom: Ah yeah that's what I thought
15:58:16 <monochrom> "hi how do I write a function to print hello?" "dude it is not a function"
15:58:31 <Lutin`> monochrom: If that's highschool stuff I'm guessing you're not american
15:58:40 <monochrom> heh, I exaggerated
15:59:20 <chrisdone> *should* be high school stuff
15:59:21 <joelteon> Lutin`, did you not take equivalence classes 100 in high school? it was right after my creative writing class
15:59:33 <Lutin`> chrisdone: Yeah, I agree
15:59:56 <copumpkin> Lutin`: anyway, check out the pickler combinators paper, and I can show you some of my stuff if you want to see some in-progress thoughts for binary stuff
16:00:04 <Lutin`> I'm currently pursuing two bachelor's degrees in Math and CS
16:00:08 <chrisdone> aw dude, digital ocean is awesome
16:00:11 <copumpkin> and of course JsonGrammar and the partial isomorphisms
16:00:16 <Lutin`> The uni I'm at kind of sucks though :[
16:00:22 <Lutin`> So I'm just trying to learn a lot on the side
16:00:27 <monochrom> chrisdone, is "digital ocean" the name of a colour?
16:00:31 <joelteon> yes
16:00:36 <Lutin`> cloud hosting company
16:01:13 <chrisdone> luite: i just paid $5 for a credit to get a droplet. they have a simple json api to create, reboot, create snapshots or restore old snapshots
16:01:29 <chrisdone> luite: i was considering using vagrant, but it might be easier just to use their api's
16:01:31 <Lutin`> copumpkin: Alright will do. Eating dinner then I'll look at that and get back to you..eventually
16:01:38 <chrisdone> luite: https://developers.digitalocean.com/droplets/
16:01:43 <tulcod> Lutin`: learn category theory
16:01:46 <Lutin`> vagrant works really nice with deploying to droplets
16:01:56 <tulcod> dunno what year you're in, but at some point
16:02:00 <monochrom> droplets and ocean. cool names.
16:02:23 <chrisdone> yeah, i like the names =p
16:02:24 <Lutin`> I'm in my 4th year but I have about 2 more since I'm going after a dual degree
16:02:31 <chrisdone> i wonder if there's an API binding on hackage
16:02:37 <monochrom> perhaps I should start a similar service and call it molecules and atmosphere
16:02:48 <tulcod> Lutin`: okay, then it's about time
16:02:51 <chrisdone> monochrom: nice =p
16:02:52 <luite> chrisdone: ah interesting
16:02:59 <Lutin`> chrisdone: advantage with vagrant is you can run it locally to develop on so that your development and production environments are as close together as possible
16:03:35 <chrisdone> Lutin`: true
16:04:25 <Lutin`> If you do it right, you should be able to just copy the Vagrantfile and some setup scripts and run `vagrant up` on any machine with vagrant/vm host installed and get a fully working server
16:05:07 <Lutin`> let me know if you have any questions about vagrant, I use it at my job
16:05:19 <luite> Lutin`: is it easy with vagrant to have some VM state that's very fast to boot up (like waking up from suspend to disk) where it can be reset to clean slate in a second?
16:05:20 <Lutin`> tulcod: Any suggested paths to learn it?
16:05:31 <tulcod> yeah, buy a book on category theory and read it
16:05:44 <tulcod> steve awodey seems to be popular with computer scientists
16:05:51 <Lutin`> luite: virtualbox has snapshot support
16:06:02 <tulcod> but maclane's categories for the working mathematicians seems to be more popular among mathematicians
16:06:50 <luite> Lutin`: is there an easy vagrant wrapper for that?
16:06:51 <tulcod> Lutin`: note: category theory is abstract as fuck. you *will* have to reread the yoneda lemma 5 times.
16:07:22 <Lutin`> quick google shows https://github.com/dergachev/vagrant-vbox-snapshot
16:07:42 <Lutin`> brb dinner
16:08:15 <Lutin`> Also look at https://github.com/jedi4ever/sahara
16:08:22 <vova> Could you please help me with Data.Time module
16:09:22 <vova> I would like to assign some predicate with the time range. but without positive result.
16:11:28 <vova> For example : if time is from 08:00 am to 08:00 pm of current  day -> True.
16:13:54 <chrisdone> luite: hmm, the vagrant vbox snapshot support would be nice. for my compile server i'd install a server that takes in a haskell file and compiles it and then spits back out core, rewrite rules, assembly, etc. then i'd do vagrant snapshot take. whenever a request comes in i'd wait on a timeout and then run vagrant snapshot back to restore a fresh
16:14:08 <vova> At first glance it's very easy, but when I tried to write it, I faced with a lot of difficulties
16:15:46 <pjdelport> vova: What type are you working on?
16:15:50 <pjdelport> or with?
16:16:20 <chrisdone> luite: i think i could do the same process with DO, but there seems to be no there'd be a boot-up delay
16:18:05 <luite> chrisdone: for paste.hskll.org we used an selinux setup which seems to work reasonbly well
16:18:44 * hackagebot simple 0.10.0.0 - A minimalist web framework for the WAI server interface  http://hackage.haskell.org/package/simple-0.10.0.0 (AmitLevy)
16:18:46 * hackagebot simple-session 0.10.0.0 - Cookie-based session management for the Simple web framework  http://hackage.haskell.org/package/simple-session-0.10.0.0 (AmitLevy)
16:19:24 <vova> I work with type LocalTime
16:26:38 <chrisdone> luite: too complicated for me
16:27:52 <pjdelport> vova: Something like this? pred t = let h = todHour t in 8 <= h && h < 20
16:28:32 <luite> chrisdone: i think notdan has a vagrant script for setting up the machine, but selinux still is a bit hairy, compiling the policy stuff
16:29:54 <luite> chrisdone: and it's nice to be able to exactly specify what a process can do, for example no fork or new threads, only connect to a specific network port
16:30:06 <vova> pjdelport: thz. I'll try
16:35:46 <monochrom> "todHour" looks like a grave name, i.e., the "tod" part :)
16:38:47 * hackagebot dynamic-graph 0.1.0.0 - Draw and update graphs in real time with OpenGL  http://hackage.haskell.org/package/dynamic-graph-0.1.0.0 (adamwalker)
16:39:13 <vova> It does not work because "todHour t" takes only the time but it does not work with date. I need to check that this 8 - 20 range is of the current day
16:42:32 <Lutin`> chrisdone: I wasn't suggesting not using the features of droplets, just that setting up a droplet is really easy with vagrant
16:43:55 <benzrf> im thinking once i understand pipes better maybe ill
16:44:04 <benzrf> make something like pipes-concurrency but 0mq based
16:53:39 <mynomoto> the #haskell-begginers is kind of sleeping today (I guess that's because of the world cup). Can someone give me a little help with exercise 2.2 of Chapter 7 from Yorgey course: http://codepad.org/dH82rT8M ?
16:54:10 <benzrf> mynomoto: sure! let me see what it is
16:54:13 <mynomoto> When I try to change `m` on lines 41 or 42 I get: Could not deduce (b ~ Size)... I put the whole error on a comment on the paste.
16:54:58 <benzrf> mynomoto: what's Sized?
16:55:08 <mynomoto> benzrf: my attempt is on http://codepad.org/dH82rT8M
16:55:36 <mynomoto> benzrf: I will paste it.
16:56:40 <mynomoto> benzrf: http://codepad.org/2Rx3uJIQ
16:57:31 <Tjr> :t bind
16:57:32 <lambdabot>     Not in scope: ‘bind’
16:57:33 <lambdabot>     Perhaps you meant one of these:
16:57:33 <lambdabot>       ‘BS.find’ (imported from Data.ByteString),
16:57:42 <Tjr> :t >>=
16:57:43 <lambdabot> parse error on input ‘>>=’
16:57:51 <benzrf> :t (>>=)
16:57:52 <Tjr> :t (>>=)
16:57:52 <lambdabot> Monad m => m a -> (a -> m b) -> m b
16:57:53 <lambdabot> Monad m => m a -> (a -> m b) -> m b
17:05:29 <monochrom> mynomoto: loads fine here, no error
17:07:38 <mynomoto> monochrom: sorry... The problem is that the code on lines 41 and 42 is wrong. I think that m should be `(Size ((getSize m) - n)` or `((size m)) - (Size n))`. When I try those I get the error.
17:09:30 <mynomoto> monochrom: thanks for looking.
17:10:08 <monochrom> why do you think that? I can't understand.
17:11:21 <ab9rf> i'm sure ((size m) - (Size n)) is wrong, unless Size is an instance of Num or Integral or something
17:11:59 <mynomoto> monochrom: b is a counter on JoinList b a. When I drop something I need to update it.
17:12:00 <monochrom> Size is an instance of Num. however, Num is irrelevant.
17:12:01 <ab9rf> a constructor for a type that is an that is
17:12:07 <monochrom> no, b is not a counter at all.
17:12:36 <mynomoto> ab9rf: Size derives Num. Is that enough?
17:12:57 <cschneid> in ghci, how do I get the list of classes a type implements?
17:12:57 <monochrom> ok, b is a counter. however, it is still not Size.
17:13:09 <mynomoto> monochrom: to be precise b is a Sized and a Monoid.
17:13:26 <mynomoto> Size is a instance of Sized.
17:13:40 <ab9rf> mmm
17:14:06 <monochrom> yes, but that doesn't help. caller chooses b. callee (you) doesn't choose. you can't call it a Size at a whim. caller will disagree.
17:17:03 <mynomoto> monochrom: but I need to subtract n from m and to do that they need to be the same type. So I should convert it to something else later?
17:18:06 <monochrom> you are only given: m's type is b, b supports Sized operations and Monoid operations. there is no "subtraction" among those operations. if you want to subtract, dead end.
17:19:00 <monochrom> I do not know the purpose of m. I cannot be sure that subtraction is desired. and I don't know what is desired.
17:21:49 <tommd> Haskell is a great language.  I needed to test a program under high CPU load, so to burn some cycles I cabal-installed lens.  Is there anything Haskell can't do?
17:21:57 <edwardk> =P
17:21:59 <monochrom> hahaha
17:22:10 <monochrom> I would build GHC.
17:22:25 <edwardk> happy to help
17:22:26 <monochrom> @remember tommd Haskell is a great language.  I needed to test a program under high CPU load, so to burn some cycles I cabal-installed lens.  Is there anything Haskell can't do?
17:22:26 <lambdabot> Done.
17:22:35 <edwardk> next time make sure to use parallel cabal builds ;)
17:22:53 <tommd> It's a single core VM...
17:22:58 <edwardk> fair nuff
17:23:17 <mynomoto> monochrom: m should reflect the number of children of the JoinList. But I will think about what you said and try to find a way. Thanks.
17:23:30 <geekosaur> mynomoto: I get the impression you are expecting Haskell types to behave like types in some other language. ML-family languages have a very different view of types than, say, Java
17:23:55 * hackagebot git-freq 0.0.1 - A Git subcommand to show total addition, deletion per file  http://hackage.haskell.org/package/git-freq-0.0.1 (DaisukeFujimura)
17:24:59 <geekosaur> and Haskell's typeclasses look vaguely like classes (actually, interfaces) in Java but they are actually very different; trying to treat them like OO-styl classes will rapidly get you into trouble
17:25:47 <sm> Control.Concurrent.SampleVar was dropped from base 4.7 and isn't mentioned in the changelog - any idea where I can find it ?
17:25:48 <mynomoto> geekosaur: Haskell is my first typed language. I don't really have other experiences with types. My ignorance is not because of previous experiences, its innate ;)
17:26:42 <geekosaur> you may want to look through
17:26:45 <geekosaur> @where lyah
17:26:45 <lambdabot> http://www.learnyouahaskell.com/
17:27:25 <sm> ah, I see advice in the 4.6 haddock
17:27:28 <monochrom> mynomoto: do not think in terms of "m minus something". think in terms of forgetting m altogether, compute that field by asking children.
17:28:09 <edwardk> @remember bernalex I imagine hell as a place where spj & edwardk are holding talks at the same time and I have to choose.
17:28:09 <lambdabot> I will remember.
17:28:11 <monochrom> actually it's easiest to spell out how to compute it.
17:28:59 <mynomoto> geekosaur: I'm following bitemyapp lead and starting with http://www.seas.upenn.edu/~cis194/ but I'm reading lyah and real world haskell too.
17:29:10 <geekosaur> okay
17:29:15 <monochrom> whenever you do "Append xxx (aaa) (bbb)", you always want xxx = mappend (tag aaa) (tag bbb), don't you?
17:29:32 <monochrom> I'll have to reword that a bit
17:29:37 <monochrom> whenever you build "Append xxx (aaa) (bbb)", you always want xxx = mappend (tag aaa) (tag bbb), don't you?
17:29:45 <mynomoto> monochrom: wow. I think that solves it.
17:29:47 <monochrom> so why don't you do exactly that?
17:29:53 <monochrom> yes
17:29:59 <Eduard_Munteanu> Suppose 'type AliasT m a = SomeT m a', is there any way to write a type like 'OtherT (AliasT m) a' without expressing it as 'OtherT (SomeT m) a'?
17:30:52 <mynomoto> monochrom: I'm still getting used to the haskell way of thinking and doing things. But I can recognize the solutions which is the first step :)
17:31:52 <monochrom> it helps that I'm teaching a data structure course, binary search tree etc
17:32:47 <monochrom> if you say: every node in the BST has a "size" field or a "height" field, how do you update it after insertion or deletion?
17:33:46 <mynomoto> monochrom: now I know that you should ask the children :)
17:33:58 <Lutin`> :t (>=>)
17:33:59 <lambdabot> Monad m => (a -> m b) -> (b -> m c) -> a -> m c
17:34:05 <monochrom> we do not say "add 1" or "subtract 1". we actually say: re-compute it bottom-up. if your two children have their "size" or "height" fields right, then for yourself it's just "left.size + right.size + 1" or "max(left.height, right.height) + 1"
17:34:15 <Lutin`> ah klesli composition?
17:34:52 <mynomoto> monochrom: Thanks for that. I still think trees really hard, but I'm getting slowly getting used to them.
17:35:35 <mynomoto> monochrom: Now I can go back and do the tree height exercises that I skipped before :)
17:35:43 <monochrom> ah!
17:36:00 <Eduard_Munteanu> Lutin`: yes
17:36:25 <Eduard_Munteanu> :t (<<<) -- for Monad m => Category (Kleisli m)
17:36:26 <lambdabot> Category cat => cat b c -> cat a b -> cat a c
17:36:52 <benzrf> :k Kleisli
17:36:53 <lambdabot> (* -> *) -> * -> * -> *
17:37:05 <Eduard_Munteanu> @src Kleisli
17:37:05 <lambdabot> Source not found.
17:37:11 <benzrf>      
17:37:20 <Eduard_Munteanu> newtype Kleisli m a b = Kleisli (a -> m b)
17:37:42 <benzrf> instances of Category are types of kind '* -> * -> *' that represent morphisms in a category of haskell types
17:38:47 <monochrom> why quit IRC today, when you can quit IRC tomorrow?
17:39:07 <Eduard_Munteanu> They timed out waiting for tomorrow. :P
17:39:14 <monochrom> haha ok!
17:41:42 <Lutin`> Aha!
17:41:50 <Lutin`> That..actually makes sense
17:43:43 <Lutin`> Definitely need to read more about Category Theory. Thought it was interesting before, but it's slowly becoming more and more so
17:44:02 * hackagebot hspec2 0.3.4 - Alpha version of Hspec 2.0  http://hackage.haskell.org/package/hspec2-0.3.4 (SimonHengel)
17:48:09 <Lutin`> Eduard_Munteanu: When you say "for Monad m =>Category (Kleisli m)" you mean that as a type class?
17:48:26 <Eduard_Munteanu> Lutin`: the instance
17:48:33 <Lutin`> Alright
17:48:38 <Lutin`> That makes sense then
17:48:46 <benzrf> Lutin`: it is simple
17:48:49 <benzrf> you have some objects
17:49:00 <benzrf> you have some morphisms or arrows from an object to another object
17:49:05 <Lutin`> Yeah I think I understand, was just clarifying
17:49:11 <benzrf> every object has at least 1 morphism to itself
17:49:16 <benzrf> u can compose morphisms
17:49:21 <benzrf> there, that is a category
17:49:24 <Lutin`> That he didn't mean the type 'Category (Kleisli m)'
17:49:43 <benzrf> Lutin`: the category Hask is the category of haskell types
17:49:50 <benzrf> where functions are morphisms
17:50:16 <benzrf> a type that instantiates Category is the type of morphisms in some other category that also uses haskell types as objects
17:50:16 <Lutin`> yep yep I get that
17:50:19 <benzrf> kk
17:50:23 <Lutin`> Thanks though
17:50:26 <benzrf> :p
17:50:53 <Iceland_jack> lol
17:51:53 <Lutin`> WHAT'S SO FUNNY, JACK?
17:52:19 <Iceland_jack> Categories before it was polykinded
17:52:43 <michaelt> |\query lambdabot
17:52:48 <michaelt> bah
17:53:01 <Eduard_Munteanu> Iceland_jack: before what?
17:54:23 <Eduard_Munteanu> class Category (cat :: k -> k -> *)  sounds doable.
17:55:11 <wyager> Hey guys. I’m working on a blog post comparing Go to Rust and Haskell. I’ve uploaded the latest draft to http://yager.io/programming/go.html . Would anyone care to critique it?
17:55:12 <fread2282> :k Category
17:55:13 <lambdabot> (k -> k -> *) -> Constraint
17:55:31 <Lutin`> What's a Constraint?
17:55:37 <fread2282> Eduard_Munteanu: not nearly as useful though
17:55:45 <benzrf> something that goes to the left of a =>
17:55:49 <fread2282> Lutin`: Functor f =?
17:55:50 <Iceland_jack> Lutin`: it's means it forms a type constraint
17:55:52 <fread2282> Lutin`: Functor f =>
17:55:52 <Iceland_jack> :kind Eq
17:55:54 <Lutin`> Ah okay
17:55:58 <Iceland_jack> @kind Eq
17:55:59 <lambdabot> * -> Constraint
17:56:00 <Eduard_Munteanu> Lutin`: the kind of fully-applied typeclasses
17:56:06 <benzrf> i want a proper kind system
17:56:31 <benzrf> one where (=>) :: Constraint -> a -> a
17:56:35 <Eduard_Munteanu> (well, not just typeclasses, but anything before =>)
17:56:47 <benzrf> :k (~)
17:56:48 <lambdabot> k -> k -> Constraint
17:57:11 <benzrf> :k (->)
17:57:12 <lambdabot> * -> * -> *
17:57:14 <Lutin`> But typeclasses are the most common way to introduce type constructors that construct a Constraint?
17:57:18 <benzrf> now THAT'S wrong
17:57:33 <Eduard_Munteanu> benzrf: why?
17:57:41 <benzrf> what about functions between unboxed types
17:57:50 <Iceland_jack> subkinds
17:57:57 <benzrf> hueh?
17:58:05 <benzrf> is # a subkind of * or some shit
17:58:10 <fread2282> also with ContstrantKinds you can do Constraint alirses with type
17:58:14 <fread2282> *aliases
17:58:15 <Lutin`> :k ((->) Int#)
17:58:16 <lambdabot>     Not in scope: type constructor or class ‘Int#’
17:58:17 <lambdabot>     Perhaps you meant one of these:
17:58:17 <lambdabot>       ‘Int’ (imported from Data.Int), ‘Int8’ (imported from Data.Int)
17:58:25 <fread2282> bleh
17:58:25 <Lutin`> poo
17:58:51 <Eduard_Munteanu> @src Int
17:58:51 <lambdabot> data Int = I# Int#
17:59:01 * hackagebot git-freq 0.0.2 - A Git subcommand to show total addition, deletion per file  http://hackage.haskell.org/package/git-freq-0.0.2 (DaisukeFujimura)
17:59:21 <benzrf> o.O
17:59:25 <benzrf> I# ?
17:59:32 <benzrf> oic
17:59:35 <Eduard_Munteanu> benzrf: just a constructor with an odd name
17:59:43 <Eduard_Munteanu> # isn't special
17:59:47 <benzrf> i thought it was type, not data
17:59:48 <benzrf> thats all
17:59:50 <benzrf> misread :u
18:00:35 <Eduard_Munteanu> I wonder if (->) :: ?? -> ? -> * is still valid.
18:00:48 <Lutin`> What do the question marks mean?
18:00:50 <fread2282> anybody have open source stuff that uses ClassyPrelude?
18:01:14 <benzrf> whats ClassyPrelude
18:01:30 <Eduard_Munteanu> Lutin`: * plus unboxed arguments and/or tuples
18:01:32 <fread2282> @hackage ClassyPrelude
18:01:32 <lambdabot> http://hackage.haskell.org/package/ClassyPrelude
18:01:54 <fread2282> @hackage classy-prelude
18:01:54 <lambdabot> http://hackage.haskell.org/package/classy-prelude
18:01:56 <fread2282> that one
18:02:19 <wagle> no releases in a year, is haskell platform dead?
18:02:37 <rwbarton> no
18:02:49 <fread2282> benzrf: snoyman's prelude replacement
18:02:50 <wyager> I’m anxious for haskell-platform to get the latest GHC as well
18:03:47 <fread2282> uses TypeFamilies to define foldable, etc for ByteString, Text and defines all the common container operations in typeclasses
18:06:37 <fread2282> lets you use containers, bytestring, text, unordered-containers w/ no imports
18:10:39 <Lutin`> Eduard_Munteanu: Are ? and ?? different?
18:11:44 <Eduard_Munteanu> Lutin`: yes
18:11:51 <darthdeus> hmm, classy-prelude seems interesting
18:12:18 <Eduard_Munteanu> Lutin`: ?? does not contain unboxed tuples, IIRC
18:12:21 <fread2282> it's nice to work with, but sometimes you get even more scary error messages
18:12:47 <Eduard_Munteanu> Lutin`: it's meant to handle register arguments and such
18:12:48 * fread2282 is playing around with making a lens-based replacement for it
18:12:54 <Lutin`> Eduard_Munteanu: Gotcha
18:13:08 <Lutin`> fread2282: Talk about scary error messages.. :P
18:13:55 <fread2282> Lutin`: true, but if you don't mess up to much it's not that bad
18:17:31 <bgamari> Is there a monad or composition of monads that would nicely capture an iterative process that returns a result after every iteration but may terminate with failure?
18:18:10 <Eduard_Munteanu> bgamari: FreeT
18:18:16 <Lutin`> So does anyone have a suggestion for a CSV library if I want to parse the strings into data types? cassava and conduit-csv were mentioned. I really only dealing with string, list, time, and number fields
18:18:41 <Clint> i use csv-conduit and have never tried cassava
18:18:42 <benzrf> Eduard_Munteanu: u wot
18:18:53 <bitemyapp> Lutin`: is there a reason csv-conduit and cassava aren't suitable?
18:18:58 <benzrf> bgamari: why not just Maybe
18:19:10 <Lutin`> bitemyapp: Just surveying before trying one out
18:19:12 <benzrf> jjjjjjjjjjjjjjjjj
18:19:14 <benzrf> oops
18:19:28 <Lutin`> cassava looks more approachable, as I've never used conduit
18:19:42 <Lutin`> But I guess csv-conduit would help introduce me to that as well
18:20:17 <bgamari> sort of like [Either err result] but enforcing that no more results will be produced after a Left is returned
18:21:20 <copumpkin> bgamari: I've made a list-like thing before: data Listish a b = Cons a (Listish a b) | End b
18:21:28 <piezoid> bgamari: Free (Either e) ?
18:21:51 <benzrf>         mmmm
18:22:04 <bgamari> piezoid, Yes, I think that's what I want
18:22:08 <benzrf> bgamari: ah, but you want to keep what orked?
18:22:32 <bgamari> benzrf, yep
18:22:43 <benzrf> i c
18:23:17 <benzrf> how about Either but the Left is the progress
18:23:23 <jmcarthur> bgamari: ListT (Either e)  ?
18:23:50 <jmcarthur> ah, Free (Either e) sounds more like what you are after, actually, yeah
18:24:18 <copumpkin> which is exactly isomorphic to the type I gave I think
18:24:35 <fread2282> @src intercalate
18:24:36 <lambdabot> intercalate xs xss = concat (intersperse xs xss)
18:24:55 <Lutin`> does ghci have @src?
18:25:04 <jmcarthur> copumpkin: yours looks like    type Listish a b = Free (Compose (Either b) ((,) a))
18:25:08 <benzrf> lambdabot's @src is static
18:25:10 <benzrf> from a db it has
18:25:19 <jmcarthur> bah, i think i fail
18:25:20 <benzrf> :t intersperse
18:25:21 <lambdabot> a -> [a] -> [a]
18:25:24 <Lutin`> ah
18:25:25 <benzrf> hrm
18:25:26 <benzrf> oic
18:25:30 <jmcarthur> ah! no, i think i'm right after all
18:25:34 <copumpkin> jmcarthur: yeah you are actually
18:25:45 <benzrf> > intercalate "shit" ["this", "is"]
18:25:46 <lambdabot>  "thisshitis"
18:25:50 <benzrf> o w8
18:25:52 <copumpkin> but I think mine is closer to what bgamari actually said
18:25:53 <bgamari> Thanks everyone!
18:25:54 <benzrf> > intercalate "shit" ["this", "is", "ok]
18:25:55 <lambdabot>  <hint>:1:39:
18:25:56 <lambdabot>      lexical error in string/character literal at end of input
18:25:57 <benzrf> > intercalate "shit" ["this", "is", "ok"]
18:25:58 <lambdabot>  "thisshitisshitok"
18:26:10 <bgamari> copumpkin, hmm
18:26:17 <copumpkin> benzrf: if you're just going to talk to the bot, can you do it in PM?
18:26:25 <benzrf> wenk
18:26:27 <bgamari> copumpkin, well, that's what I'm currently using
18:26:34 <bgamari> copumpkin, perhaps I'll just stick with it
18:26:46 <copumpkin> ah
18:31:41 <fread2282> > foldr (\c r -> c <> "," <> r) mempty ["foo","bar"]
18:31:43 <lambdabot>  "foo,bar,"
18:49:45 <benzrf> im sleep
18:49:53 <benzrf> bye
18:50:11 <Para__> Hey guys -- so I know how to make a function declaration have different cases (myFunct [] = [], myFunct [a] = whatever), but what if I want to make special cases after manipulating the input? Do I need to use an if-else type of thing, or is there a way to do it by defining a function in more than one line?
18:50:40 <Fuuzetsu> Para__: what do you mean by special cases?
18:50:55 <Para__> So when you do recursive stuff, you can do myFunct [] = []
18:51:00 <Para__> and then myFunct [x] = something else
18:51:04 <Para__> to deal with empty lists
18:51:06 <Fuuzetsu> sure
18:51:18 <Para__> what if I wanted to do something different with inputs that were prime?
18:51:27 <Para__> if I already have a function that checks for primality?
18:51:33 <kadoban> Para__: Use guards?
18:51:36 <Para__> would I need to do an if-else, or is there a clean way to do it?
18:51:39 <Fuuzetsu> myFunct [x] | isPrime x = foo | otherwise = bar
18:51:59 <Para__> gotcha
18:52:01 <Para__> thanks
18:52:07 <Fuuzetsu> no problem, read about guards
18:52:12 <Para__> :) will do
18:52:17 <kadoban> They're pretty neat feature
18:53:27 <Lutin`> heh
18:53:54 <Lutin`> Xenotulip - What an alien gives to their significant other
18:58:02 <Para__> Alright, different question now. I'm trying to understand function annotations. From what I understand, say I have myFunct :: Integral x => x -> Bool, it takes an input that must be integral, and returns a Boolean value. But suppose it was myFunct x :: Bool x => x -> x, what would make that different from myFunct x :: Bool x => x -> Bool
18:58:32 <rwbarton> there is no such thing as "Bool x"
18:58:37 <rwbarton> so, both are illegal
18:58:56 <rwbarton> Bool is a type, whereas Integral was a type class
18:59:50 <Para__> Okay - so switch Bool with Integral then in the second scenario
18:59:59 <Para__> or is that illegal too?
19:00:09 <Para__> should it be Integral x => x -> Int
19:00:14 <rwbarton> ok, then there is no such thing as "x -> Integral"
19:00:46 <rwbarton> Integral x => x -> x is valid, so is Integral x => x -> Int
19:00:49 <rwbarton> they are different
19:00:58 <Fuuzetsu> :t fromIntegral
19:00:59 <lambdabot> (Num b, Integral a) => a -> b
19:01:08 <Fuuzetsu> :t fromIntegral :: Integral a => a -> Int
19:01:09 <lambdabot> Integral a => a -> Int
19:01:45 <Para__> alright, thanks!
19:04:35 <tam1138> i'm looking to write a terminal app; the two libraries i've found that seem most promising are vty and ncurses.  recommendations on which to choose?  (or another one i'm not considering?)
19:04:58 <Fuuzetsu> vty doesn't have Windows support I believe so that's something to consider
19:05:12 <tam1138> i did notice that.  i don't think that's a big deal at this point.
19:05:40 <Fuuzetsu> ncurses seems like it can do a lot more but I don't know the quality of bindings; we're using Vty in Yi. Vty 5.x was just released the other daya
19:06:02 <Fuuzetsu> depends on how fancy you want to get and what exactly you want to do I suppose
19:06:27 <tam1138> yeah, i'm not sure yet =)
19:06:36 <tam1138> have you found vty sufficient for yi?
19:07:01 <kadoban> ncurses can be a bit of a pain, I've never terribly enjoyed any of the times I had to use it. If there's another option I'd probably check into it.
19:07:26 <tam1138> good to know, thanks.  i've not used ncurses from any language before.
19:07:27 <Fuuzetsu> Hm, yes, it does fine. Where there are features missing, the maintainer updates Vty and even updates Yi accordingly
19:07:43 <tam1138> nice!
19:07:49 <Fuuzetsu> but then again, we're not exactly drawing whole terminal interfaces with buttons and all that
19:08:06 <tam1138> i don't plan to do that either, so i think vty might do me fine
19:08:08 <Fuuzetsu> (that's not to say you can't, I just don't know if it's made for that)
19:08:12 <Fuuzetsu> cool
19:08:21 <tam1138> i believe there are other packages that add ui elements using vty
19:09:02 <Para__> is there a maximum column length that I should stick to in Haskell? (Its usually 80, isn't it?) If so, how can I continue onto the next line. Do I need a special character for breaks?
19:09:42 <Fuuzetsu> there is no hard limit, I recommend 80
19:09:54 <Fuuzetsu> no special character, you use alignment to specify blocks
19:10:06 <Fuuzetsu> personally I use 2 spaces, some people use 4
19:10:13 <Fuuzetsu> just don't use hard tabs
19:10:32 <Para__> alright, thanks
19:10:48 <Para__> (if in your editor, tab does 4 spaces, that's fine right?)
19:10:48 <Fuuzetsu> FTR hard tabs are treated as 8 spaces by GHC
19:10:52 <jhance> My boss joked about incorporating an 80-char limit into our build system
19:10:54 <Fuuzetsu> yes, that's fine
19:10:58 <Para__> awesome
19:18:51 <Para__> hmm
19:19:24 <ReinH> I'd recommend using spaces though.
19:19:39 <Fuuzetsu> He is isn't it
19:19:43 <Fuuzetsu> at least that's what I interpretted it as
19:19:47 <ReinH> ok
19:21:05 <Para__> Yeah
19:21:09 <Para__> Like if I press tab
19:21:13 <Para__> to get rid of it I have to backspace 4 times
19:22:18 <jhance> Para__: Thats a problem with your editor - reconfigure it; you can have it remove the spaces like its a tab if you prefer it that way (I don't). Don't use hard-tabs, they mess up the indentation, which is important in Haskell
19:22:38 <Para__> wait
19:22:43 <Para__> i got confused
19:22:47 <Para__> its the other way around
19:22:50 <Para__> if I do space 4 times
19:22:52 <Para__> and backspace
19:22:54 <Para__> it gets rid of 4 at a time
19:23:12 <Para__> (I"m using sublime text 2, if that's relevant)
19:23:19 <jhance> Para__: That is certainly a weird editor configuration
19:23:55 <Para__> Yeah, I guess it is
19:24:04 <Para__> it only deletes 4 if it is at a multiple of 4 though
19:24:10 <Para__> so if I'm at 5 spaces, it'll first delete one, then four
19:25:32 <jhance> Para__: Shouldn't be a problem then, you can reach any number of spaces easily with that configuration.
19:26:14 <Para__> yep, it works pretty well with Python too (since whitespace is important) which is why I use i
19:26:50 <Para__> ok hmm, could you help me figure out why ghci doesn't like this: primes = filter is_prime [1..] where      is_prime n = all (\p -> n `rem` p /= 0) (takeWhile (\p -> p^2 <= n) primes)
19:27:11 <Para__> wait
19:27:14 <Para__> no thats not what I typed in
19:27:49 <Para__> I did: let is_prime n = all (\p -> n `rem` p /= 0) (takeWhile (\p -> p^2 <= n) primes) in primes = filter is_prime [1..]
19:28:23 <kazagistar> oh man, great minds think alike, I am writing a prime finder too
19:28:23 <Para__> and it says there is an error in parsing the input?
19:29:26 <Lutin`> Para__: You could probably just shift+tab
19:29:34 <Lutin`> instead of backspace
19:30:33 <rwbarton> Para__: you can't write   let ... in <binding>
19:30:37 <kazagistar> Para__: you arent supposed to use "let...in" in top level declerations I think
19:30:40 <rwbarton> only  let ... in <expression>
19:31:00 <Para__> oh okay --
19:31:01 <kazagistar> > let x = 3 in y = 2 + x
19:31:02 <lambdabot>  <hint>:1:16: parse error on input ‘=’
19:31:08 <Para__> is the where version valid though?
19:31:27 <kazagistar> > let y = let x = 3 in 2+x
19:31:28 <Para__> y = let x = 3 in 2 + x
19:31:29 <lambdabot>  not an expression: ‘let y = let x = 3 in 2+x’
19:31:36 <rwbarton> yes; but also you can't write a function declaration like that in ghci
19:31:45 <Para__> oh okay
19:31:48 <rwbarton> but, it would be valid in a .hs file
19:32:01 <rwbarton> you can write
19:32:04 <Para__> got it
19:32:13 <rwbarton> well actually this is a bit complicated to write in one line
19:32:23 <rwbarton> you can write in ghci, let is_prime n = all (\p -> n `rem` p /= 0) (takeWhile (\p -> p^2 <= n) primes)
19:32:25 <Para__> I mean you could manually replace it couldn't you?
19:32:28 <rwbarton> and then let primes = filter is_prime [1..]
19:32:54 <rwbarton> or in fact you can just write your original thing with "let" at the front
19:33:01 <Para__> rwbarton - I don't think you can do the first, since it references primes, can you?
19:33:15 <rwbarton> oh I didn't notice that, okay
19:33:49 <rwbarton> so you can't do the two separate line version
19:34:02 <Para__> wait
19:34:05 <Para__> I have an idea
19:34:22 <kazagistar> in .hs the order at top level is irrelevant (as well as in where clauses and whatnot) but you can always simulat multiple lines with C-esque syntax using { ; ; } stuff
19:34:22 <Para__> can't you use a semicolon?
19:34:39 <Clint> you can do let x = y; x = y
19:34:50 <rwbarton> yes
19:34:52 <Clint> but i don't think that's what you want
19:35:05 <kazagistar> >let x = y; y = x; print x
19:35:35 <rwbarton> you can't do that, but you can define multiple bindings in a let statement with semicolons
19:36:03 <rwbarton> (also lambdabot is not ghci anyways)
19:37:29 <Para__> okay
19:37:32 <Para__> i just found how to do it
19:37:36 <Para__> its a really bad hack
19:37:38 <Para__> but it works
19:38:08 <Para__> so what you do is first define is_prime like this: let is_prime n = all (\p -> n `rem` p /= 0) (takeWhile (\p -> p^2 <= n) [2..])
19:38:11 <Para__> then define primes as usual
19:38:23 <Para__> then you can define is_prime as the original thing again
19:38:24 <Para__> and it works
19:39:23 <rwbarton> it "works" but not in the right way, primes will be using the original is_prime
19:39:31 <Para__> how come?
19:39:36 <Para__> then you can re-define primes?
19:39:42 <Para__> with the "new" is_prime?
19:40:04 <rwbarton> yes but ITS is_prime will be using the primes with the old is_prime
19:40:13 <Para__> ohh
19:40:16 <Para__> thats messy
19:40:43 <rwbarton> you can't redefine anything, what you're actually doing is shadowing (reusing an old name for a new thing)
19:41:16 <kazagistar> :r
19:41:30 <kazagistar> ... sorry
19:41:39 * Fuuzetsu reloads #haskell
19:45:49 <Para__> ok
19:45:58 <Para__> i figured out how to do it, but the code is slightly different
19:46:07 <Para__> let primes = 2 : filter (\n -> all (\p -> n `rem` p /= 0) (takeWhile (\p -> p^2 <= n) primes)) [3, 5 ..]
19:46:31 <Para__> Is it considered bad practice to use anonymous functions?
19:46:45 <Fuuzetsu> no
19:46:51 <Fuuzetsu> do whatever seems sensible
19:47:32 <zomg> Para__: it's often a good idea to try and make the functions pointfree, but if that can't be achieved without a lot of code golfing, anonymous functions work perfectly fine
19:47:34 <kadoban> Para__: It depends. If there's a natural way to use slices (or a small composition of them), that might be better style. But nothing wronge with lambdas when they're appropriate
19:47:54 <Para__> What exactly do you mean by slices
19:48:03 <Para__> and alright zomg - I'll try to see if I can do that to my function
19:48:38 <Fuuzetsu> operator sections probably
19:48:46 <kadoban> Oh sections, yeah...sorry
19:49:09 <Para__> @hoogle sections
19:49:11 <lambdabot> No results found
19:49:15 <kadoban> (+1) is nicer than \x -> x +1, etc.
19:49:52 <Fuuzetsu> :t (-(-1))
19:49:53 <lambdabot> Num a => a
19:49:58 <Para__> ohhhh
19:49:58 <Para__> gotcha
19:50:02 <Clint> @pl \p -> p^2 <= n
19:50:02 <lambdabot> (<= n) . (^ 2)
19:50:06 <Fuuzetsu> ‘-’ is terrible
19:50:06 <Para__> yeah makes sense
19:50:08 <Fuuzetsu> I hate it
19:50:28 <Para__> why?
19:50:30 <Para__> subtraction?
19:50:52 <Fuuzetsu> because it has special parsing to allow people to write negative numbers
19:50:58 <Fuuzetsu> but
19:50:59 <Fuuzetsu> :t (+1)
19:51:00 <Para__> ah
19:51:00 <lambdabot> Num a => a -> a
19:51:02 <Fuuzetsu> :t (-1)
19:51:03 <lambdabot> Num a => a
19:51:05 <Fuuzetsu> pfft
19:51:12 <Para__> :t (subtract 1)
19:51:13 <lambdabot> Num a => a -> a
19:51:28 <Fuuzetsu> yes, but that's not a succint as using ‘-’
19:51:47 <Para__> True
19:51:49 <jhance> Unfortunately, if you remove that, naive people complain about lacking normal syntax for negative numbers
19:52:08 <AlainODea> haskell-mode question.  I can't get the Cabal keymaps to work.  I get 'Symbol's value as variable is void: haskell-cabal-mode-map'
19:52:11 <Fuuzetsu> yes, which is why I hate it but don't try to fight it
19:53:02 <Apha> test
19:53:03 <Para__> Okay - so as far as making stuff pointfree
19:53:15 <Para__> Would there be any possibility here: let primes = 2 : filter (\n -> all (\p -> n `rem` p /= 0) (takeWhile (\p -> p^2 <= n) primes)) [3, 5 ..]
19:53:19 <Para__> as an example?
19:53:35 <Fuuzetsu> @pl primes = 2 : filter (\n -> all (\p -> n `rem` p /= 0) (takeWhile (\p -> p^2 <= n) primes)) [3, 5 ..]
19:53:36 <lambdabot> primes = fix ((2 :) . flip filter [3,5..] . ap (all . flip flip 0 . ((/=) .) . rem) . flip (takeWhile . flip ((<=) . (^ 2))))
19:53:41 <zomg> Para__: I looked at it and tbh it looks challenging to say the least :)
19:53:58 <zomg> so it's probably not worth it if it makes the code harder to read
19:54:08 <zomg> the reason to do it in the first place is because it can improve readability
19:54:11 <Para__> Okay, thanks :)
19:54:19 <Fuuzetsu> for self-recursive definitions you'll often find it's not sensible to make the whole thing point-free
19:54:24 <Para__> I have it slightly more readable in he .hs file, I just couldn't input it into ghci
19:54:33 <Para__> and what does pl do?
19:54:51 <Fuuzetsu> it tries to turn things into point-free (pointless) style
19:55:03 <Para__> theres an algorithmic way to do that?
19:55:06 <Clint> @pl \p -> n `rem` p /= 0
19:55:06 <lambdabot> (0 /=) . (n `rem`)
19:55:13 <Para__> and is it usually encouraged for readability or for performance issues?
19:55:21 <Fuuzetsu> nah, we have a team of engineers in India around the clock doing the transformations
19:55:26 <jhance> Para__: Readabiliy
19:55:35 <Para__> oh okay
19:55:37 <Eduard_Munteanu> Para__: only if the result is better
19:55:46 <Para__> so no use in taking that current pointfree thing and putting it into my code
19:55:56 <Para__> because it seems less readable
19:56:00 <kadoban> Para__: You could mayyybe do the rem part: ((/=0) . (n `rem`)), but that's not terribly readable, I'd leave it alone. About the same with the p^2 part
19:56:04 <zomg> yeah the @pl version looks pretty crazy =)
19:56:07 <Eduard_Munteanu> @pl \a b c d -> f d c b a
19:56:07 <lambdabot> flip (flip . (flip .) . flip (flip . flip f))
19:56:14 <kadoban> haha
19:56:22 <Fuuzetsu> @unpl flip (flip . (flip .) . flip (flip . flip f))
19:56:22 <lambdabot> (\ b c g j -> f j g c b)
19:56:27 <jhance> ((/=0) . (n `rem`)) is okay I think
19:56:37 <enthropy> you can define names like divides a b = b `rem` a /= 0
19:57:34 <Para__> jhance - better than what I currently have?
19:57:54 <ReinH> Remove points when doing so improves your code, not for it's own sake.
19:58:11 <jhance> Para__: They are both equally readable, imo. The latter is a bit more compact but the function composition seems slightly unnatural
19:58:21 <ReinH> you might find, though, that intentionally writing in a point free style produces quite readable code.
19:58:29 <Para__> okay :)
19:58:35 <ReinH> Bird's stuff is a good example
19:58:39 <Para__> but thats not always possible?
19:59:00 <kadoban> It's kind of a fun puzzle figuring out how to do it too, but often it's best not to actually leave it that way.
19:59:01 <ReinH> no, it isn't, or it isn't always worth trying.
19:59:20 <bitemyapp> I've tried hackage and haskell-infrastructure, no response
19:59:23 <Para__> okay, that clears stuff up :)
19:59:28 <bitemyapp> I'm getting 403 forbidden for a package upload against my own package.
19:59:37 <bitemyapp> for which I am still listed as a maintainer and can change the settings for
19:59:44 <bitemyapp> the only thing I cannot do is upload a new package version.
19:59:46 <ReinH> but designing your system in terms of composable functions often yields nice code
20:00:10 <kazagistar> Para__: the @pl stands for pointless... but pointless can be fun
20:00:16 <jhance> For me its mostly don't waste time with stuff like `map (\x -> f x y) z` when you can do `map (flip f) z`. Those kind of simple things
20:00:54 <bitemyapp> anybody know what might be causing this issue with Hackage? I'd like to get this uploaded.
20:00:58 <jhance> Well, `map (flip f y) z`
20:01:46 <tam1138> is "ghc-pkg --user list" the right way to find packages i've installed with cabal-install ?
20:02:46 <mendozao> i want to search the logs for "> " (evaluator) anyone have any idea how i can do this?
20:02:46 <kazagistar> its true purpose is to make lambdabot flip out
20:02:58 <kazagistar> @pl f w x y z = z (w x) (y x) (z y)
20:02:58 <lambdabot> f = flip flip (flip id) . (liftM2 ap .) . (`ap` flip id) . (((.) . flip . flip id) .)
20:04:11 <bitemyapp> mendozao: symbolhound
20:05:27 <AlainODea> re:haskell-mode. I need to put my define-keys inside (defun haskell-cabal-hook (). (I'm an Emacs newbie)
20:21:17 <syllogismos> whats the function that converts Int -> Double
20:21:23 <syllogismos> 1 to 1.0 etc
20:22:29 <artyomkazak> realToFrac
20:23:40 <artyomkazak> or fromIntegral
20:23:55 <kurt__> is there a slick way to write foo :: [Maybe a] -> Maybe [a] so if any a is Nothing you get Nothing, otherwise Just [list of Just values] ?
20:23:56 <AlainODea> Damn it. No one called me on my incorrect answer. So much for that :D.  The correct answer is to (require 'haskell-cabal) in init.el before trying any define-keys for haskell-cabal-mode-map
20:24:27 <syllogismos> >fromInteger 1 :: Double
20:27:08 <artyomkazak> > fmap (map Just) . sequence $ [Just True, Just False]
20:27:09 <lambdabot>  Just [Just True,Just False]
20:27:30 <artyomkazak> > fmap (map Just) . sequence $ [Nothing, Just True]
20:27:31 <lambdabot>  Nothing
20:27:47 <artyomkazak> kurt__: here you have it
20:28:01 <artyomkazak> oh, wait
20:28:06 <artyomkazak> just sequence
20:28:18 <kurt__> thanks, but I want Just [True, False] if there are no nothings
20:28:23 <artyomkazak> yep
20:28:34 <artyomkazak> > sequence [Just True, Just False]
20:28:36 <lambdabot>  Just [True,False]
20:28:46 <artyomkazak> I misread “list of Just values”
20:29:33 <kurt__> aha! Thanks artyomkazak
20:31:23 <brrrrrrian> hello!
20:31:57 <brrrrrrian> If I have a text file consisting of a single line: a,b,"c"
20:32:07 <brrrrrrian> how do I convert it to a,b,c
20:32:29 <Fuuzetsu> your question needs to be a bit more generic in what you want to do
20:32:40 <brrrrrrian> basically, I want to parse a file line by line
20:32:53 <brrrrrrian> and transform the last column to remove the quotations
20:33:43 <brrrrrrian> a,b could have quotation marks, so I couldn't just strip the file of quotation marks
20:33:56 <Fuuzetsu> doWhateverToDropQuotes .splitAt "," . lines <$> readFile
20:34:00 <Fuuzetsu> for some definition of splitAt
20:34:21 <Fuuzetsu> well, map doWhateverToDropQuotes
20:34:21 * hackagebot bloodhound 0.1.0.2 - ElasticSearch client library for Haskell  http://hackage.haskell.org/package/bloodhound-0.1.0.2 (ChrisAllen)
20:35:41 <brrrrrrian> ahhh
20:35:44 <brrrrrrian> splitOn ?
20:35:52 <brrrrrrian> so... tokenize the line
20:35:55 <Fuuzetsu> unlines . reverse . (\(x:xs) -> tail (init x)) . reverse . splitAt "," . lines <$> readFile
20:35:57 <brrrrrrian> transform the last element
20:36:01 <Fuuzetsu> something like this should work although performance is questionable
20:36:06 <Fuuzetsu> uh
20:36:24 <Fuuzetsu> (that's wrong actually but you get the idea)
20:37:13 <kazagistar> brrrrrrian: usually, the right idea is to build a parser, cause then you can get it 100% right
20:37:47 <kazagistar> (well, if a parser for your format does not exist already, of course)
20:38:34 <brrrrrrian> ok I guess I must elaborate
20:38:50 <brrrrrrian> i have a CSV... and I am using cassava
20:39:27 <brrrrrrian> the format is: 123,some text,"123","456"
20:39:55 <kazagistar> that looks like fairly ordinary csv to me
20:40:20 <brrrrrrian> but I can't read the last 2 columns in as an Int... I have to read them as String
20:41:02 <brrrrrrian> so I figured I'd just preprocess the csv file to strip the quotation marks
20:41:24 <Fuuzetsu> sounds like it'd be easy to postprocess the CSV you get out
20:41:29 <Fuuzetsu> it'd be easier*
20:41:38 <kazagistar> brrrrrrian: it seems like you should just call read on the strings at the end
20:42:23 <brrrrrrian> with cassava, I define a data type.. and then decode the bytestring into a list of these data types
20:42:43 <brrrrrrian> so it would be nice to just specify the type as Int but I can't
20:42:52 <pqmodn> MyRecord <$> r ! 0 <*> r ! 1 <*> .. <*> (read <$> r ! 6) or some such
20:43:58 <pqmodn> where you declare the last field as Int. the compiler will know read applies to String and must generate an Int, so cassava will use the String parser
20:45:50 <brrrrrrian> pqmodn: doh, I was trying: MyRecord <$> r .: "foo" <*> r .: "bar" <*> read (r .: "baz") <*> read (r .:
20:46:23 <pqmodn> since (r .: "baz") is has some type like 'Parser a' you've gotta use fmap
20:46:34 <brrrrrrian> so with applicative <$> you're basically lifting `read' into the monad, right?
20:47:08 <pqmodn> yeah. it lifts a pure function into a Functor context
20:47:12 <brrrrrrian> pure read
20:47:14 <zwer_m> <$> is just fmap
20:47:17 <zwer_m> :t fmap
20:47:18 <lambdabot> Functor f => (a -> b) -> f a -> f b
20:47:20 <zwer_m> :t (<$>)
20:47:21 <lambdabot> Functor f => (a -> b) -> f a -> f b
20:47:45 <pqmodn> right, pure f <*> x is the same thing as f <$> x
20:50:38 <brrrrrrian> i have been playing with haskell for a while
20:51:04 <brrrrrrian> but i think i made a giant leap by carefully reading typeclassopedia
20:51:13 <pqmodn> that helped me quite a lot too
20:52:01 <pqmodn> also, re-implementing Functor, Applicative, and Monad instances for standard types
20:52:02 <brrrrrrian> i should have caught that error with read, but as soon as you provided your suggestion i knew exactly what you're talking about
20:59:04 <carter> brrrrrrian: you should just parse
20:59:17 <carter> oh
20:59:23 <carter> looks like folks are on the case
21:09:32 <Guest5822> yu
21:12:12 <tam1138> ni?
21:22:01 <chrisdotcode> when you make a newtype, do you automatically get the derived instances of the initial type?
21:22:20 <pqmodn> no
21:22:37 <Eduard_Munteanu> chrisdotcode: no, you need to derive them explicitly with GeneralizedNewtypeDeriving if you want
21:23:11 <chrisdotcode> Eduard_Munteanu: is there anything unsafe/a good reason as to why I have to use an extension, as opposed to just being able to do it defaulty?
21:23:24 <pqmodn> often you want different instances!
21:23:43 <bitemyapp> does anyone know to point at a specific package in haddocks?
21:23:57 <Eduard_Munteanu> chrisdotcode: not really, GeneralizedNewtypeDeriving is rather ok.
21:24:29 <chrisdotcode> Eduard_Munteanu, pqmodn:so if I want the same instances, nothing unforeseen can happen if I -XGeneralizedNewtypeDeriving away?
21:24:50 <Eduard_Munteanu> chrisdotcode: you also need derive clauses
21:25:04 <Eduard_Munteanu> Should be fine.
21:25:15 <chrisdotcode> cool.
21:25:15 <chrisdotcode> thanks!
21:25:30 <Eduard_Munteanu> The only controversy regarding it is some interaction with SafeHaskell.
21:25:46 <Lutin`> Oh yay :D
21:26:09 <Lutin`> Independent study this Fall in permutation groups and their algorithms
21:26:31 <Lutin`> And I'm going to push my partner to learn Haskell :D
21:26:49 <chrisdotcode> Eduard_Munteanu: my code is pure, but I'll lose safehaskell if i use it?
21:27:26 <Eduard_Munteanu> chrisdotcode: something like that, but unless you explicitly want Safe on, don't bother about it.
21:27:52 <enthropy> the controversy with GND is https://ghc.haskell.org/trac/ghc/ticket/7148
21:29:34 <chrisdotcode> thanks, enthropy
21:30:04 <tam1138> oftentimes when i'm reading through other people's code, i come across functions i don't recognize; is hoogle the right way to hunt those down, or is there a more efficient alternative?
21:31:08 <chrisdotcode> tam1138: hoogle is pretty efficient, no?
21:31:20 <Eduard_Munteanu> tam1138: Hayoo covers more packages
21:32:12 <tam1138> i was hoping for something more local.  ie, if i'm without internets.  or sometimes i'd like to see the source of a particular function, whereas the docs indexed by hoogle shows a description
21:34:56 <ab9rf> tam1138: hoogle can be asked to make a local (cached) database
21:35:28 <ab9rf> i think it does so by default, in fact
21:35:55 <slack1256> tam1138: if you have ghc-mod installed, GhcModInfo can give type signatures and where is defined. Maybe not what you want.
21:36:31 <xpika> is there anything more powerful than debug.trace ?
21:36:44 <tam1138> thanks, i'll look into getting a local hoogle thingy going
21:37:44 <xpika> i want to trace a whole function. is there any way to do this?
21:38:29 <slack1256> xpika: :step in ghci?
21:38:30 <Eduard_Munteanu> xpika: the ghci debugger, but it can be difficult to interpret the output
21:40:20 <xpika> something like fac 3 => 3 * fac 2 => 3 * 2 * fac 1 => 3 * 2 * 1 = 6
21:42:19 <slack1256> Oh, I remember a package that implemented that. It wasn't "Work everytime" but did pretty well.
21:43:11 <bitemyapp> Warning: The documentation for the following packages are not installed. -- getting this for a bunch of packages.
21:43:18 <bitemyapp> how do I address this?
21:43:53 <slack1256> bitemyapp: cabal.config "documentation: True"
21:44:08 <slack1256> but you have to reinstall those packages
21:45:06 <bitemyapp> sigh. nuts.
21:45:08 <bitemyapp> slack1256: thanks.
22:09:32 * hackagebot jose 0.1.27.0 - Javascript Object Signing and Encryption  http://hackage.haskell.org/package/jose-0.1.27.0 (frasertweedale)
22:15:10 <Lutin`> Does anyone know how big all of hackage is?
22:19:02 <carter> < 15gb for all the tarballs for alll of time
22:19:09 <carter> I think
22:21:54 <Lutin`> Oh really
22:24:33 <oisin620> I'm trying to use Parsec and the permute function to parse a file with multiple comments. The problem is the comments won't appear in just one block (so I can't just write permute <$$> many comments <||> ...). How do I account for random lines of comments appearing?
22:25:04 <oisin620> *would I write many permute ...?
22:29:35 * hackagebot apiary 0.10.0 - Simple web framework inspired by scotty.  http://hackage.haskell.org/package/apiary-0.10.0 (HirotomoMoriwaki)
22:30:58 <matematikaadit> :t sequence_
22:30:59 <lambdabot> Monad m => [m a] -> m ()
22:31:11 <matematikaadit> :t mapM_
22:31:12 <lambdabot> Monad m => (a -> m b) -> [a] -> m ()
22:32:12 <pavonia> oisin620: Have a look at Text.Parsec.Permutation
22:33:07 <oisin620> pavonia: That looks good, thanks!
22:34:36 * hackagebot apiary-logger 0.10.0 - fast-logger support for apiary web framework.  http://hackage.haskell.org/package/apiary-logger-0.10.0 (HirotomoMoriwaki)
22:34:38 * hackagebot apiary-persistent 0.10.0 - persistent support for apiary web framework.  http://hackage.haskell.org/package/apiary-persistent-0.10.0 (HirotomoMoriwaki)
22:34:40 * hackagebot apiary-websockets 0.10.0 - websockets supper for apiary web framework.  http://hackage.haskell.org/package/apiary-websockets-0.10.0 (HirotomoMoriwaki)
22:34:42 * hackagebot apiary-cookie 0.10.0 - Cookie support for apiary web framework.  http://hackage.haskell.org/package/apiary-cookie-0.10.0 (HirotomoMoriwaki)
22:34:44 * hackagebot apiary-clientsession 0.10.0 - clientsession support for apiary web framework.  http://hackage.haskell.org/package/apiary-clientsession-0.10.0 (HirotomoMoriwaki)
22:39:46 * hackagebot apiary-authenticate 0.10.0 - authenticate support for apiary web framework.  http://hackage.haskell.org/package/apiary-authenticate-0.10.0 (HirotomoMoriwaki)
22:57:28 <syllogismos> v
23:06:05 <ab9rf> ^
23:07:33 <syllogismos> so, my program is giving me out of memory error.. how do I avoid things like these. I'm new to haskell.. so when do I use lazy versions and when do I use non lazy versions? my program type checks and works for small values..
23:13:44 <pavonia> Without further information the only answer is: Add strictness annotations where needed
23:13:55 <Welkin> or add more RAM
23:15:49 <syllogismos> do you want to see my code? pavonia
23:16:02 <pavonia> Sure
23:16:07 <syllogismos> https://github.com/syllogismos/Neural-Network-Haskell/blob/master/src/NeuralNetwork.hs
23:17:54 <pavonia> syllogismos: And what function calls work and what fail?
23:18:59 <syllogismos> trainNN
23:19:14 <syllogismos> here is the fpcomplete link https://www.fpcomplete.com/user/syllogismos/test-1
23:20:27 <pavonia> @src sum
23:20:27 <lambdabot> sum = foldl (+) 0
23:20:30 <syllogismos> trainNN works when iter is 10 but doesn't when it getting bigger
23:21:01 <Lutin`> syllogismos: You can use heap profiling to see what's using up all the memory
23:21:37 <Lutin`> http://stackoverflow.com/questions/3276240/tools-for-analyzing-performance-of-a-haskell-program is a nice little intro
23:22:06 <Lutin`> There's also this http://book.realworldhaskell.org/read/profiling-and-optimization.html
23:23:32 <Lutin`> There's also this series by Edward Yang on more about how the heap works in Haskell http://blog.ezyang.com/2011/04/the-haskell-heap/
23:26:17 <syllogismos> ok thanks.. that is what I'm looking for
23:26:33 <syllogismos> hopefully i can make my code work
23:35:17 <ab9rf> why would you want your code to work? :)
