00:05:16 <pavonia> Which leads to another question: Does the compiler apply the rewrite rule if the Functor instance is derived?
00:08:52 * hackagebot samtools 0.2.3 - Binding to the C samtools library  http://hackage.haskell.org/package/samtools-0.2.3 (NicholasIngolia)
00:08:52 * hackagebot handle-like 0.0.0.10 - HandleLike class  http://hackage.haskell.org/package/handle-like-0.0.0.10 (YoshikuniJujo)
00:21:14 <spacekitteh> pavonia: it certainly should! i might look into that tonight :)
00:24:47 <biscarch> Has anybody used an Aeson Value with digestive functors?
00:26:24 <biscarch> I'm using an Object as a field in my datatype, but it doesn't have a Read instance
00:28:47 * hackagebot scotty 0.8.1 - Haskell web framework inspired by Ruby's Sinatra, using WAI and Warp  http://hackage.haskell.org/package/scotty-0.8.1 (SimonHengel)
00:40:46 <alpy> hey I need help with this project where i am using the diagrams modules, is there anyone who can help me?
00:42:35 <Cale> alpy: possibly!
00:43:05 <alpy> so here is my code: http://lpaste.net/105824
00:43:35 <alpy> and here is the error code it gives me: http://lpaste.net/8100279664234201088
00:45:17 <Cale> alpy: What it seems to be telling you is that you've given a more polymorphic type to histogrammeAxis than the implementation suggests
00:45:39 <alpy> I think
00:45:43 <Cale> alpy: What happens if you just comment out the type signatures for histogrammeAxis and histogrammeBar?
00:45:59 <Cale> Which types are inferred?
00:46:17 <alpy> It works:)
00:47:12 <ninja_code> I need a webserver that does two dumbass things: (1) server static files, and (2) can handle websocket. What haskell package should I use?
00:47:18 <Cale> If you open the program in ghci and type ":t histogrammeAxis" it should be able to tell you what the type ought to be
00:47:24 <ninja_code> I literally need nothing else.
00:47:44 <kyagrd> pandoc is so great hail everyone contributing to pandoc
00:48:02 <tdammers> kyagrd: pandoc has some unicode issues though :x
00:48:43 <kyagrd> tdammers: oh, haven't tried on non-latin languages
00:48:46 <tdammers> ninja_code: what about an off-the-shelf web server... idk, apache, nginx, lighttpd?
00:48:54 <ninja_code> oh
00:48:59 <ninja_code> I need haskell to handle the websocket
00:49:00 <ninja_code> so I need haskell package
00:49:02 <Cale> There's http://hackage.haskell.org/package/websockets which is very simple
00:49:03 <ninja_code> sorry if that as not clear
00:49:11 <tdammers> ninja_code: right
00:49:15 <Cale> I have no idea if it's good or not, I've never used websockets myself
00:49:54 <tdammers> kyagrd: pandoc's latex integration tends to break when you have unicode in your input that gets passed to a tex implementation that can't handle unicode
00:50:01 <ninja_code> damn it
00:50:04 <ninja_code> I don't want uncertainity
00:50:08 <ninja_code> :-)
00:50:12 <alpy> Cale: cheers, it works *internet hug*
00:50:12 <levi> I hear all the ninjas are using websockets these days.
00:50:23 <kyagrd> tdammers: Oh does that include greek characters in Math?
00:50:27 <ninja_code> levi: arr, it's our weapon vs pirates
00:50:38 <tdammers> kyagrd: not sure... could be that pandoc converts those to latex math
00:50:40 <kyagrd> tdammers: for math there are MathML conversion too
00:51:01 <tdammers> kyagrd: it's not usually a problem, except when you start automating things against user-provided input
00:51:36 <tdammers> kyagrd: I ran into this in a project where we converted half a million files with all sorts of personal notes in them from a custom MySQL database format into archivable PDF
00:52:00 <tdammers> kyagrd: my code had to deal with about 20 different scripts, and over 40 languages
00:52:22 <Welkin> what??
00:52:24 <Welkin> why pdf?
00:52:31 <tdammers> customer demanded it
00:52:32 <Welkin> that is the worst format you could ever use for archiving anything
00:52:37 <tdammers> there's pdf-a
00:52:40 <Hafydd> Personal notes, you say? Was there anything juicy?
00:52:50 <tdammers> which is supposed to be around 20 years from now
00:52:51 <Welkin> plain text/epub is much better
00:52:54 <tdammers> who knows
00:53:05 <tdammers> oh, we did also ship plain text along with the pdf
00:53:07 <tdammers> just in case
00:53:23 <levi> ninja_code: Also see the main website for the websocket package Cale linked to: http://jaspervdj.be/websockets/
00:54:26 <ninja_code> http://book.realworldhaskell.org/read/extended-example-web-client-programming.html has a broekn link to
00:54:28 <levi> PDF is a fine format for archival, especially when you value typography.
00:54:32 <ninja_code> http://www.haskell.org/http/
00:54:58 <Welkin> what does typography have to do with information?
00:55:03 <Welkin> for a printed page perhaps
00:55:07 <ninja_code> err
00:55:08 <Welkin> but electronic text? no way
00:55:09 <tdammers> typography was not really a concern there
00:55:12 <ninja_code> have you tried to read math that is not LaTeXed ?
00:55:29 <Welkin> that is stored in plain text...
00:55:43 <tdammers> Hafydd: oh yes
00:55:53 <tdammers> Hafydd: can't tell you more though
00:56:04 <tdammers> Hafydd: because of an NDA that I may or may not have signed
00:56:24 <tdammers> Hafydd: or possibly because I just don't wanna
00:56:30 <levi> Welkin: Yes way.  I like reading nicely typeset text, especially on a nice hi-res screen.
00:56:43 <tdammers> levi: we used GNU Unifont
00:56:47 <Welkin> levi... you can display plain text in whatever way you wish
00:56:53 <tdammers> levi: so there goes "nicely typeset"
00:57:26 <levi> Well, I can't help it if you're not taking advantage of what PDF can do for you.
00:57:28 <Welkin> pdf is by far the worst format for text
00:57:36 <Welkin> I cannot stand when I find ebooks in pdf format
00:57:44 <Welkin> it is an atrocity
00:57:52 * levi rolls eyes
00:58:07 <Welkin> it was not made for it
00:58:16 <Welkin> it's basically a giant image
00:58:33 <levi> You really ought to learn more about PDF.
00:58:49 <Welkin> do you know epub exists?
00:58:51 <chenglou> anyone available to help a newb with Haskell dependency installation?
00:58:55 <levi> Yes.
00:59:11 <levi> epub is fine. But so is PDF. They are for somewhat different things.
00:59:34 <levi> chenglou: What kind of problems are you having?
00:59:59 <chenglou> I'm new to haskell so trying things around. I need to install quickcheck2 in my cabal sandbox
01:00:13 <chenglou> everything else is already set up for me so I haven't dug much into it
01:00:38 <levi> When you say "my cabal sandbox", what did you do to set that sandbox up?
01:01:18 <chenglou> cabal sandbox init
01:01:53 <levi> OK, do you have a cabal file for your project?
01:02:06 <chenglou> the *.cabal? yes
01:02:12 <tdammers> Welkin: pdf is not a giant image. More like a binary DSL for mostly vector-based page layouting
01:02:31 <tdammers> Welkin: you can have images in pdf, you can have vector graphics, you can have text, and you can have a million other things
01:03:05 <tdammers> Welkin: the problem is not that it's unsuitable for (typeset) text, because it's not. The problem is that it's convoluted, way too complex, obscure, and proprietary (sort of)
01:03:22 <flux> well, it's unsuitable for reflowing text
01:03:30 <tdammers> flux: that's not what it's for anyway
01:03:35 <flux> it's very suitable for reproducing typeset text in the format it was typeset
01:03:40 <tdammers> yes
01:03:46 <tdammers> it's supposed to be a *publishing* format
01:03:50 <tdammers> not an *authoring* format
01:04:04 <flux> I think e'pub' is also a publishing format ;)
01:04:14 <tdammers> sure
01:04:19 <levi> For publishing of content with graphical design elements.
01:04:23 <flux> but I still agree that pdf is not currently suitable for e-reading purposes
01:04:29 <flux> because there are no large enough e-readers available
01:04:33 <tdammers> pdf is based on a print media paradigm
01:04:42 <flux> well, I suppose big tablets, but not e-ink devices
01:04:46 <levi> PDFs are beautiful on my 10" iPad.
01:04:56 <flux> I would love an a4-sized e-ink device.
01:05:12 <chenglou> levi: yeah I do have the .cabal file
01:05:26 <tdammers> epub is targeted at e-readers, so it's built for reflowing
01:05:43 <tdammers> pdf is targeted at print media, so it's built to reproduce layout accurately
01:05:47 <levi> chenglou: What have you put in your .cabal file?
01:05:50 <tdammers> different purposes, simple as that
01:06:18 <chenglou> levi: no quickcheck2
01:06:49 <Welkin> pdf looks horrible on my ipad
01:06:59 <flux> tdammers, wouldn't you still agree the original statement that pdf was not made for e-books, but rather for actual books?-)
01:07:00 <Welkin> it doesn't fit the screen properly and the text cannot be made larger
01:07:40 <levi> chenglou: I think QuickCheck is the package name
01:07:53 <chenglou> in that case, I have it listed
01:08:06 <sopvop> pdf looks ok on my Huawei MediaPad 10
01:08:08 <levi> Welkin: What kind of iPad do you have?
01:08:17 <Welkin> the newest one
01:08:17 <levi> And what kind of eyesight?
01:08:24 <chenglou> levi: there's an import Test.QuickCheck somewhere in my test
01:08:26 <chenglou> but also a import Test.Framework.Providers.QuickCheck2 (testProperty)
01:08:51 <levi> chenglou: Right, but the packages that provide those modules need to be in your .cabal file
01:08:59 <levi> In the build dependencies.
01:09:57 <chenglou> levi: here's my cabal file
01:09:57 <chenglou> http://pastebin.com/TZBd9BQv
01:11:11 <levi> OK, you've got QuickCheck there, but you need to add test-framework-quickcheck2 for Test.Framework.Providers.QuickCheck2 I think.
01:11:18 <ninja_code> erlang has riak
01:11:30 <ninja_code> does haskell have any sort of kv store (or db) whether consistent or evnetually consistent, written in pure haskell ?
01:11:59 <levi> There's acid-state, but it's not exactly the same thing.
01:12:50 <ninja_code> yeah
01:12:53 <ninja_code> it's like steel vs empire state building
01:13:29 <levi> Is that what it's like?
01:15:20 <Jei>  http://420.thrashbarg.net/juhannus_teoriassa_kaytannossa_paate.png
01:16:13 <chenglou> levi: cool, made some other configs and it works now. Although there's this new problem: "Module `Data.Either' does not export `isRight'"
01:16:15 <zomg> Jei: sounds about right
01:16:19 <chenglou> do I have an outdated version?
01:16:31 <Jei> zomg: ups, wrong channel.
01:16:48 <zomg> yeah thought it was a bit odd choice of link here =)
01:16:52 <zomg> but accurate nevertheless!
01:17:02 <ddellacosta> Jei: I was really confused by that
01:17:16 <ddellacosta> and now I'm intrigued
01:17:19 <zomg> Juhannus is a finnish midsummer holiday
01:17:30 <zomg> That's a comparison of Juhannus in theory and in practice
01:17:30 <zomg> =)
01:18:09 <levi> chenglou: It appears to be a new arrival to Data.Either, so it's possible.
01:18:26 <mayski> Finland mentioned!
01:18:33 <ddellacosta> zomg: ah, gotcha, thanks.
01:18:53 <chenglou> cool, I'll try to work it out, thanks!
01:19:44 <Tjr> LYAH discusses the State data type, and hints at a MonadState typeclass. Given that the State data is container which can hold anything anyway, what's the benefit of a MonadState typeclass?
01:20:18 <levi> chenglou: It's only a 2-line function; 3 if you count the type declaration. :)
01:20:57 <alpy> :t rect
01:21:00 <lambdabot> Not in scope: ‘rect’
01:21:00 <levi> Tjr: It's part of the `mtl` library that makes working with monad transformers a little cleaner/easier, for some values of 'cleaner' and 'easier'.
01:21:26 <Tjr> so in short, it's good for something but that something is too complicated to explain?
01:21:50 <tdammers> Tjr: it's not that complicated
01:22:03 <levi> Tjr: Well, it's not terribly complicated, but it does depend on some background knowledge of Haskell.
01:22:10 <tdammers> you have State, which happens to be a monad (but that's kind of irrelevant here)
01:22:17 <tdammers> and you have other types that do similar things
01:22:44 <tdammers> MonadState is simply a typeclass that says "this type supports State functionality"
01:22:51 <tdammers> :info MonadState
01:23:01 <tdammers> @info MonadState
01:23:02 <lambdabot> MonadState
01:23:02 <Tjr> can you give an example, for concreteness?
01:23:19 <tdammers> usually, the type in question is a monad stack
01:23:21 <levi> Tjr: Have you been introduced to monad transformers yet?
01:23:25 <Tjr> no
01:23:34 <tdammers> probably a bit above your head right now
01:23:40 <Tjr> it's not covered in LYAH
01:23:48 <levi> How familiar are you with using State, Reader, Writer, etc?
01:23:54 <tdammers> but you can have, for example, a MonadState MyState IO
01:24:26 <tdammers> this combined monad supports IO operations through the MonadIO class (which means you can convert any IO action to an action of this combined monad stack using liftIO)
01:24:36 <tdammers> but it also supports State operations
01:24:44 <tdammers> btw, it's StateT MyState Io
01:24:45 <Tjr> levi: just worked through them yesterday. Presumably there's a neat trick for when you need to pass a RNG around (State) and build up lists of intermediate values (Writer).
01:25:06 <Tjr> levi: err, all at the same time.
01:25:27 <tdammers> so you can have a type that is both an IO-like thing *and* a State-like thing
01:25:33 <levi> Monad transformers are a way to combine multiple monad 'features' into a single monad. They're not combined uniformly, though, they're layered. So you normally have to be explicit about which layer you're using the actions (e.g. tell, ask) from.
01:25:42 <Tjr> real life is calling
01:25:49 <Tjr> got to go
01:25:50 <tdammers> real life tends to do that
01:25:54 <Tjr> I'll read the chatlog
01:25:57 <levi> Ask again sometime. :)
01:26:05 <Tjr> in case I miss your answers
01:45:25 <taruti> Control.Monad.Random contains no lifting function? Have a function like (StdGen -> (Foo,StdGen)) and want to lift into "Rand StdGen Foo"
01:49:39 <notdan> taruti: http://hackage.haskell.org/package/MonadRandom-0.1.13/docs/Control-Monad-Random.html#v:liftRand ?
01:50:26 <taruti> hmm, I must be blind, stared at that haddock for 5min...
01:51:03 <tdammers> staring at haddock can do that to you
02:11:16 <r444> taruti: just search `lift` on the page next time :)
02:11:24 <CodedDMT> Helllo peeps new here
02:11:30 <CodedDMT> Just sayin hi
02:11:50 <taruti> r444: I did... somehow managed to mess it up.
02:12:35 <Cale> CodedDMT: hello!
02:12:58 <Cale> CodedDMT: Feel free to hang around and ask any questions you might have about Haskell
02:13:18 <CodedDMT> Thanks Cale!
02:14:00 <CodedDMT> I do have a question... I havent used irc in 8+ years... and wanted to get reacquainted w things. Is this a good channel for that?
02:14:36 <CodedDMT> Vet gone noob here typa shit...
02:14:45 <jle`> CodedDMT: with IRC?
02:14:50 <CodedDMT> Yea
02:14:55 <Cale> Well, it's not ideal for long conversations about how to use IRC, but if it's something easy :)
02:15:22 <jle`> if you want to discuss longer things there's always #haskell-blah :)  an equally friendly group
02:15:24 <CodedDMT> Okay cool. Just a heads up. I dont wanna be that guy..
02:15:38 <jle`> you can also query lambdabot, he is always down for a chat
02:16:04 <CodedDMT> How would i do that?
02:16:19 <frerich> Many books & tutorials mention how record syntax frees you from having to write 'accessor' functions yourself, but in my recent (granted: small) projects I got the impression that they actually cause some headache (mostly: clashing field names) and for the most part my types only have three or four fields, in which case I can just use 'let (_, name, _ _) = v' to exact values from them (or I do this right in the
02:16:19 <frerich>  function definition when pattern matching). Did anybody notice the same?
02:16:45 <jle`> frerich: people usually "manually namespace" their acessors
02:16:52 <frerich> By now, it seems to me that record syntax is only really useful if you have a lot of fields in some data type such that pattern matching becomes impractical.
02:17:03 <frerich> jle`: Yeah, I think that's pretty ugly, too :)
02:17:08 <jle`> data Foo = Foo { fooThing :: Thing; fooThat :: That; fooInt :: Int }
02:17:19 <CodedDMT> Is IRC still filled w trolls or is it more mature people now? Have I missed much in 8 yrsm
02:17:28 <jle`> it's also a bit more flexible than manual pattern matching
02:17:36 <jle`> if you want to rearrange the order or add a new field
02:17:52 <jle`> you don't have to change all your patterns
02:17:56 <jle`> CodedDMT: it really depends on the channel :)
02:17:58 <mayski> CodedDMT: depends on channel and network
02:18:12 <jle`> frerich: also you get functions, to.  and you don't have to write them yourself
02:18:37 <jle`> like map fooThat [Foo A B C, Foo X Y Z] ==> [B, Y]
02:18:39 <CodedDMT> Thanks jle and mayski
02:19:13 <jle`> manual namespacing is a well known wart of the record syntax constructs and people saw it even when it was being introduced
02:19:19 <frerich> jle`: True, however - I find that I don't usually need those functions because of pattern matching - and if I need them (to pass them to some higher-order function, for instance) it's easy to whip them up locally with a short name.
02:19:21 <jle`> there are some extensions being experimented with to help solve it
02:19:44 <jle`> frerich: whipping up the same function ten times might be a bit of a waste
02:20:03 <jle`> also, getSum is pretty useful?
02:20:05 <frerich> jle`: If you actually find that you do it ten times, you just do it once on a broader scope (e.g. global) of course. ;-)
02:20:26 <jle`> > getSum $ foldMap Sum [1, 7, 8, 3]
02:20:28 <lambdabot>  19
02:20:44 <jle`> as is runState
02:21:00 <jle`> (but i consider those slight abuses of record syntax so maybe i shouldn't be bringing it up :) )
02:21:36 <frerich> It's true that extending data types is easier if you do not use pattern matching. OTOH, maybe you *do* want to be forced to udpate your patterns to see which code pieces need to be adjusted, i.e. you explicitely want to say "I don't need this field here".
02:22:11 <jle`> i'm not sure what situation you are describing here
02:22:19 <jle`> if i hvae a function that only wants one part of a record
02:22:26 <jle`> why would it care how many other parts the record has?
02:23:01 <frerich> My thinking is - if you have a function that only wants one part of a record, but then you extend the record - maybe you should review whether the function should take the new field(s) into account, too.
02:23:05 <jle`> https://ghc.haskell.org/trac/ghc/wiki/Records/OverloadedRecordFields/Design is the extension to possibly solve the namespacing problem, btw
02:25:09 <frerich> It probably depends on the record and what fields get added - but I think that the "If you add a new field, you have to fixup all the places where you use pattern matching" thing is nto necessarily a bad thing, i.e. the reverse argument "If you use record syntax, you can just keep on using the accessor functions" is not necessarily a good thing. It really depends.
02:25:10 <levi> jle`: I think he means that exhaustive pattern match checks can help find bugs when you extend records. But not all inexaustive matches are necessarily bugs.
02:25:36 <jle`> yeah
02:25:57 <levi> Which is why it's a configurable warning, rather than an error.
02:25:59 <jle`> well the problem is the same if you didn't have records
02:26:13 <jle`> er, unless i am misunderstanding
02:26:23 <jle`> you can still pattern match with or without
02:26:33 <jle`> and for cases where you have functions that you can only expect to care about one part, you'd write helper functions anyway
02:26:47 <jle`> which do the same thing and excuse you from the same compiler warnings (except at the site of the helper function definition)
02:28:09 <jle`> with record syntax you can always still pattern match "by default" and chose to only use accessors in the same situations you'd use helper functions
02:28:11 <jle`> although
02:28:16 <jle`> i feel like i sort of lost the point i was trying to make
02:28:25 <jle`> and i'm sure i am not saying anything that contradicts what you are trying to say
02:28:30 <jle`> :|
02:28:33 <jle`> it's late >_>
02:29:05 <levi> Records give you a nice hook to auto-derive lenses. ;)
02:29:08 <jle`> as an honest confession i was very bothered by the manual namespacing at first, but over time i do'nt even see the prefixes anymore.
02:29:25 <jle`> not that that's a real solution
02:29:48 <jle`> but i think name clashes are the main major argument "against" record accessors, right?
02:30:31 <jle`> with or without, you can still always pattern match/use helper functions and avoid/run into the same potential bugs as with, if we are talking about extending records...so i guess my earlier point was less "extending records without compiler warnings is a good thing!" and more about "having helper functions you define yourselves globally are a good thing"
02:30:36 <jle`> er
02:30:39 <jle`> that you can define automatically
02:30:45 <jle`> maybe not globally :)
02:32:10 <levi> While we're reworking records, let's add row-polymorphism.
02:32:27 <levi> And build in something lens-like to them.
02:33:14 <LambdaDusk> I have a stupid question... when I am documenting a function "wrapper :: IO a -> IO a", what would I call the IO a params/return values in the doc? The function takes an IO a and adds some context via bracket_, it does not really return anything
02:33:18 <LambdaDusk> and hi levi
02:33:31 <levi> Hi, LambdaDusk.
02:33:50 <tdammers> LambdaDusk: actions?
02:34:54 <LambdaDusk> tdammers: actions... so the function returns an action
02:35:12 <jle`> it is an action transformer
02:37:28 <LambdaDusk> ok...
02:37:34 <frerich> jle`: I must admit I'm not *quite* sure I can follow you, but I think levi pretty much summed things up. The scenario I was thinking of was something like http://lpaste.net/105831 -- in case a new field is added to 'Person' (say, "age") then the isEligible' definition still works but isEligible complains about a wrong number of arguments to the 'Person' constructor.
02:38:16 <frerich> jle`: Now, whether or not a compile error is desireable really depends on the particular function. If "isEligible" should also depend on the age, a compile error is nice. If it doesn't need to, a compile error would be annoying. I'm thinking that using the pattern matching approach *forces* you to look at things and decide explicitely.
02:38:51 <tdammers> LambdaDusk: yes
02:39:00 <tdammers> LambdaDusk: it takes an action and returns another
02:39:15 <tdammers> LambdaDusk: you can call them "IO actions" if that part needs clarification
02:40:16 <jle`> frerich: i was saying that that problem persists if you have no record syntax + manual helper functions, but i guess you are advocating never using helper functions at all unless necessary for h.o.f.s?
02:40:51 <frerich> jle`: Well "advocating" is maybe exaggerated, but yes - I get the impression that not using record syntax and using manual accessor functions on demand is a pretty plausible default.
02:42:41 <frerich> The only exception being data types with a lot of fields such that pattern matching becomes really noisy ("isEligible (Person firstName lastName age hairColor petName favoriteFruit)" or so ;-)
02:42:44 <LambdaDusk> tdammers: Thanks
02:43:24 <jle`> there are some records i use/make where pretty much everything i do with them involves passing their accessors into higher order functions, so in those cases it'd be nice to have it available as a non-default :)  but i see what you mean by sensible default
02:43:38 <jle`> frerich: well if youa re using every single field, you might as well use record wildcards
02:43:51 <jle`> isEligible Person{..} = ...
02:44:01 <jle`> but
02:44:03 <jle`> wait
02:44:08 <jle`> you're saying if there was no record synatx heh
02:44:17 <jle`> sorry >.<
02:45:22 <jle`> i should probably head off to bed now before the hour gets exceptionally unreasonable :)
03:00:34 <roelof> how I can I check the type of this :  second xs = head (tail xs)
03:01:25 <roelof> Just type :type before it does not work. I see then this error message :  parse error on input `='
03:03:19 <jle`> roelof: you can do a let binding on ghci
03:03:21 <piezoid> :t \xs -> head (tail xs)
03:03:23 <lambdabot> [a] -> a
03:03:24 <frerich> roelof: You can either write it as an anonymous function (i.e. ":type \xs -> head (tail xs)") or you could define the function via 'let' ("let second xs = head (tail xs)" and then use ':type second')
03:03:25 <jle`> let second xs = head (tail xs)
03:03:31 <jle`> and then :t second
03:03:40 <jle`> or write anonymous function
03:03:46 <jle`> remember that you can only :t values
03:04:03 <jle`> er
03:04:06 <jle`> expressions
03:04:13 <jle`> (\xs -> head (tail xs)) is an expression
03:04:18 <jle`> second is an expression
03:04:24 <jle`> second xs = head (tail xs) is a declaration
03:05:39 <roelof> frerich:  thanks
03:09:07 * hackagebot digestive-functors-aeson 1.1.9 - Run digestive-functors forms against JSON  http://hackage.haskell.org/package/digestive-functors-aeson-1.1.9 (OliverCharles)
03:14:07 * hackagebot wai-extra 3.0.0.1 - Provides some basic WAI handlers and middleware.  http://hackage.haskell.org/package/wai-extra-3.0.0.1 (MichaelSnoyman)
03:27:55 <jocke12> i just finished my first haskell program (https://github.com/jocke12/stanford-cs240h/blob/master/lab1.hs). it's an old stanford lab assignment. (http://www.scs.stanford.edu/11au-cs240h/labs/lab1.html). does anybody mind giving some feedback on the code? would be greatly appreciated
03:29:08 * hackagebot clay 0.9 - CSS preprocessor as embedded Haskell.  http://hackage.haskell.org/package/clay-0.9 (SebastiaanVisser)
03:32:09 <jocke12> is it commonplace to stack the where bindings as i did? maybe some of them should be bound 'globally' (?) instead?
03:33:40 <frerich> jocke12: I think (almost?) all of those functions should rather be toplevel. It's not only a little easier to read IMHO, it more importantly allows you to test them in isolation (e.g. in ghci)
03:34:09 * hackagebot crf-chain1 0.2.2 - First-order, linear-chain conditional random fields  http://hackage.haskell.org/package/crf-chain1-0.2.2 (JakubWaszczuk)
03:34:11 * hackagebot json-assertions 1.0.3 - Test that your (Aeson) JSON encoding matches your expectations  http://hackage.haskell.org/package/json-assertions-1.0.3 (OliverCharles)
03:38:01 <jocke12> frerich: thanks. where should the line be drawn? which, of any, of those functions should be where bindings?
03:38:59 <frerich> jocke12: I'd start by making all of them global, for the sheer sake of being able to try them in ghci individually. In some cases, you could then consider reducing the scope. For instance, 'sortedWords' appears to be only used by 'wordsWithCount' so the former could be local to the latter.
03:41:07 <frerich> jocke12: In this particular case, I don't really understand why you need "sortedWords" though, the 'sorting' part in particular - I see that 'wordsWithCount' sorts itself based on the word count anyway.
03:41:47 <jcullen> hey guys.. I'm trying to upgrade to ghc 7.8.2, and having some trouble with missing dependencies in cabal that I didn't seem to have with ghc 7.6
03:42:10 <jcullen> everything I've tried to install beyond cabal-install is failing
03:42:20 <jcullen> in particular
03:42:59 <jcullen> hashable is failing to install with the message "cannot find -lHStext-1.1.1.3-ghc7.8.2"
03:43:08 <jcullen> but cabal says that I have text-1.1.1.3 installed already
03:43:11 <jcullen> anyone know what could be going on?
03:43:17 <mmmm> can you paste the full log please
03:43:22 <bvad> Hello, Is it possible to do a C-style typecast of a Word16 to a Word8? (e.g. an uint16 to uint8)
03:44:03 <jcullen> sure one sec
03:44:10 <jocke12> frerich: it should probably be renamed groupedWords or something.
03:44:23 <jocke12> frerich: that's, i guess, its main reason for existing
03:44:53 <jocke12> frerich: i did have the bindings on the top level when developing, but keeping them there sounds good
03:47:08 <jcullen> mmmm: http://pastebin.com/MTeBsY0i
03:47:12 <Walther> :t (.)
03:47:13 <lambdabot> (b -> c) -> (a -> b) -> a -> c
03:47:20 <Walther> :t $
03:47:22 <lambdabot>     parse error on input ‘$’
03:47:22 <lambdabot>     Perhaps you intended to use TemplateHaskell
03:47:26 <Walther> :t ($)
03:47:26 <lambdabot> (a -> b) -> a -> b
03:47:59 <mendio> Hello, I have a question, how is this things : "=<<"  ">>=" called ? I can't google it
03:48:15 <jcullen> bind
03:48:47 <Walther> Hm. If `(f . g) x` == f(g(x)), what is the difference really compared to $ - as `f $ g x` does pretty much the same thing, if I'm not mistaken?
03:48:59 <jcullen> mmmm: and here is the output of cabal install text: http://pastebin.com/JEZaRkB5
03:49:22 <frerich> jocke12: Two more thoughts - '\x -> (genericLength x, head x)' is the same as 'genericLength &&& head'. And in a few cases you can avoid 'fst' and 'snd' by using pattern matching, e.g. barLength could be 'barLength (count, _) xs' and then you could use 'count' instead of 'snd x' which arguably more expressive.
03:49:28 <jcullen> Walther: it does do the same thing semantically, but it has a lower operator precendence
03:49:40 <jcullen> Walther: so it allows you to not nest lots of parentheses
03:49:58 <Walther> as does $ :P
03:50:03 <mmmm> jcullen: https://github.com/tibbe/hashable/issues/78
03:50:38 <jcullen> Walther: i.e. you can write map (+1) $ sort $ filter (>5) $ [1,2,3,5,6]
03:50:51 <jcullen> instead of using a bunch of parentheses.
03:51:02 <Walther> jcullen: I know what $ does. I know what . does. I was just asking if there is any difference :P
03:51:09 <jocke12> frerich: amazing. thanks!
03:51:23 <frerich> Walther: (.) applied to two arguments yields a function whereas ($) applied to two arguments yields a value. E.g. "filter (not . isPunctuation)" typechecks, but "filter (not $ isPunctuation)" doesn't.
03:52:09 <mmmm> jcullen: https://github.com/haskell/cabal/issues/1830
03:53:33 <mmmm> jcullen: So the short answer (as with all cabal problems) is to remove ~/.ghc and retry
03:53:39 <jcullen> mmmm: Ahh I see. yeah that seems like it
03:53:57 <jcullen> mmmm: removed my .cabal but forgot to blow away .ghc.  I'll give it a try, thanks.
03:54:10 * hackagebot snap-cors 1.2.5 - Add CORS headers to Snap applications  http://hackage.haskell.org/package/snap-cors-1.2.5 (OliverCharles)
03:54:46 <jcullen> mmmm: yeah that did the trick thank you.
03:56:20 <jocke12> frerich: amazing. thanks!
03:56:26 <jocke12> hah. sorry
04:01:51 <jocke12> frerich: refactored to https://github.com/jocke12/stanford-cs240h/blob/master/lab1.hs. is this more along the lines of how you would write it?
04:02:31 <jocke12> thanks for the &&& operator. very clever
04:51:48 <joneshf> So i've written something like this a few times: either (const []) id
04:51:56 <joneshf> but this feels like im missing something
04:52:46 <joneshf> i mean in scala this is `getOrElse`
04:53:10 <smj> Does anyone have a copy of the Project Euler problems? The site is down.
04:54:34 <Tjr> joneshf: if all else fails, you can always make your own getOrElse.
04:55:00 <Tjr> Is there some neat way to classify all possible monads?
04:55:15 <Tjr> For example, Reader and Writer look like they should be dual to each other.
04:55:29 <joneshf> Tjr, true, just wonder why there's nothing in base for this
04:55:49 <joneshf> i mean there is for Maybe, but not either
04:56:01 <joneshf> s/either/Either/
04:56:15 <Tjr> and the list monad (and other containers) can be seen as functions from (index set) to (contained values), bringing them closer to Reader.
04:56:39 <Tjr> The third type of monad would be state-passing. IO is a special case, since you pass the state of the external world.
04:57:10 <joneshf> though i wonder, is there something like a comonad with a default value
04:57:18 <joneshf> as that's basically what i want here
04:57:57 <Tjr> joneshf: not necessarily a good answer -- have you looked at MonadPlus and its guard function?
04:59:07 <joneshf> Tjr, well, i don't want the Monad anymore, i want the value within the data type, or a default value
04:59:30 <joneshf> but i also want to supply the default value
04:59:52 <joneshf> it wont always be a list, for instance
05:00:24 <Tjr> the default value corresponds to the neutral element of MonadPlus's monoid.
05:00:41 <Tjr> err, the error value
05:00:42 <Tjr> sorry
05:01:02 <Tjr> id looks like the neutral element of the function composition monad
05:01:10 <Tjr> monoid
05:02:00 <joneshf> well, it might not even be the monoidal identity that i want for the default some times
05:02:17 <joneshf> maybe my use case is too specific
05:03:13 <Tjr> and the actual pattern "either (neutral of monoid) (default value)" would then disappear into the plumbing of  MonadPlus
05:03:55 <Tjr> disclaimer: I might be wrong, this is just intuition.
05:05:34 <pjdelport> joneshf: What was your original question? (I missed it.)
05:07:41 <joneshf> :t fromMaybe -- pjdelport this exists for Maybe, but there doesn't seem to be something similar for Either, more generally is there something like a Comonad with a default value
05:07:43 <lambdabot> a -> Maybe a -> a
05:09:23 <joneshf> i mean, i know `either` exists, so you could write: getOrElse def e = either (const def) id e
05:09:30 <joneshf> but its more a general question
05:15:16 <yitz> joneshf: CoIdentity?
05:16:25 <yitz> joneshf: i.e., if extract just gives you a default value, doesn't that basically means this is a trivial comonad, analogous to the Identity monad?
05:18:48 <joneshf> yitz, i dont think i explained it properly
05:19:17 <yitz> or perhaps Const?
05:19:40 <joneshf> extractDefault :: ComonadDefault w => a -> w a -> a
05:19:46 <joneshf> something like that
05:20:44 <joneshf> or i guess: class ComonadDefault w where { extractDefault :: a -> w a -> a }
05:20:47 <yitz> joneshf: when would it give you the default instead of the usual extract?
05:21:33 <joneshf> yitz, would depend on the data type i imagine
05:21:33 <pjdelport> joneshf: There's probably not a strong reason for the lack of that, but it's an interesting question.
05:22:42 <magicman> My google-fu fails me. I know that in the last month (or maybe two), there was an article about parsec, "try"-backtracking, and the result that a try-(<|>) combination has on error messages.
05:23:20 <magicman> But now I can't find it, and I'm in exactly the kind of situation where I think that article is appropriate.
05:23:33 <magicman> (possibly s/article/blog post/g)
05:24:04 <pjdelport> :t flip (<|>) . pure
05:24:06 <lambdabot> Alternative f => a -> f a -> f a
05:24:22 * hackagebot arithmatic 0.1.0.0 - Basic arithmatic in haskell  http://hackage.haskell.org/package/arithmatic-0.1.0.0 (AlanHawkins)
05:24:29 <pjdelport> That's kind of similar, but in Alternative.
05:25:19 <joneshf> well, i don't want the functorial value, I want the underlying value of the Functor
05:25:26 <pjdelport> Right.
05:28:08 <yitz> magicman: perhaps this? http://blog.ezyang.com/2014/05/parsec-try-a-or-b-considered-harmful/
05:28:30 <yitz> magicman: and ensuing reddit discussion: http://www.reddit.com/r/haskell/comments/25ulsv/ezyang_try_a_b_considered_harmful/
05:29:22 * hackagebot arithmatic 0.1.0.1 - Basic arithmatic in haskell  http://hackage.haskell.org/package/arithmatic-0.1.0.1 (AlanHawkins)
05:29:23 <magicman> yitz: Cheers, that's exactly what I was looking for.
05:29:30 <yitz> magicman: ed's title was cute, but by omitting parsec from it he sure made it harder to google. :)
05:30:17 <magicman> Yeah. I searched the reddit for "parsec", mailing lists for anything involving "parse", and some google search terms. But there's a lot of stuff written about the library.
05:30:53 <yitz> magicman: i happened to have had a discussion with some people about the issue at the time, so i was able to find the link in my private email.
05:32:19 <yitz> magicman: ah - i actually submitted the link to reddit myself. so that would have been an even easier way to find it. but i forgot that :)
05:32:44 <pjdelport> joneshf: This might be somewhat relevant: http://sneezy.cs.nott.ac.uk/fplunch/weblog/?p=69
05:33:48 <magicman> yitz: That'd do it. Thanks again, I'll go read it now. The reddit discussion seems particularly interesting.
05:36:00 <yitz> pjdelport: wait. why is that equivalent to the usual definition of Applicative?
05:37:53 <yitz> pjdelport: this is mcbride?
05:38:38 <ineb> first day haskell and i am wondering why my code is not working http://lpaste.net/105836
05:38:42 <ineb> it must be a compilerbug
05:39:23 * hackagebot cgrep 6.4 - Command line tool  http://hackage.haskell.org/package/cgrep-6.4 (awgn)
05:39:29 <frerich> ineb: Well 'quot' takes two arguments.
05:39:47 <frerich> ineb: ...but you just pass one. So the error message makes a fairly good guess when it says "Probable cause: `quot' is applied to too few arguments"
05:39:48 <yitz> ineb: two many parens
05:39:59 <yitz> *too
05:40:04 <pjdelport> yitz: I think so.
05:40:16 * yitz nods
05:40:18 <ineb> awwww
05:41:56 <yitz> pjdelport: i think that blog is called "fp lunch" because those people could eat people like me for lunch.
05:42:33 <pjdelport> :)
05:43:36 <pjdelport> Me too! I'm not sure how general that is; it might just be for that particular embedding of () / (,) in Functor?
05:44:07 <yitz> pjdelport: yeah i can't see how you could possibly get pure out of that.
05:44:41 <pjdelport> yitz: pure is just that unit, isn't it?
05:44:56 <yitz> pjdelport: well but only for ()
05:48:48 <implementation> hey guys, has someone got some experience croSS-building ghc for arm? i'm getting this error: http://paste.debian.net/105800/ and I don't know what to do about it :)
06:00:39 <joneshf> yitz, there was a good so question about this, let me try to find it
06:02:14 <rwbarton> pure a = fmap (const a) (unit ())
06:02:33 <joneshf> http://stackoverflow.com/questions/23316255/lax-monoidal-functors-with-a-different-monoidal-structure
06:02:43 <joneshf> yitz, ^
06:03:11 <rwbarton> implementation: do you have a #define SIZEOF_VOID_P line in includes/ghcautoconf.h?
06:04:34 <joneshf> pjdelport, I'll have to look at it more in depth whe ni'm more awake, but offhand, I think that's not really going to net much, since Maybe and Either can't be Comonads, but maybe im not thinking about it right
06:05:57 <implementation> rwbarton: yes, it's "#define SIZEOF_VOID_P 0", as well as SIZEOF_CHAR, SIZEOF_DOUBLE etc.
06:06:06 <rwbarton> implementation, well, that seems unlikely to work :)
06:06:49 <implementation> should I edit that manually? or is something wrong with the configure process?
06:08:19 <rwbarton> implementation: something is wrong with configure yeah
06:09:27 * hackagebot rail-compiler-editor 0.2.0.0 - Compiler and editor for the esolang rail.  http://hackage.haskell.org/package/rail-compiler-editor-0.2.0.0 (bubuiic)
06:09:45 <rwbarton> implementation: oh: "Define SIZEOF_type-or-expr (see Standard Symbols) to be the size in bytes of type-or-expr, which may be either a type or an expression returning a value that has a size. If the expression ‘sizeof (type-or-expr)’ is invalid, the result is 0."
06:09:55 <rwbarton> implementation: probably your arm cross-compiler just isn't working at all
06:10:43 <rwbarton> implementation: I would check config.log
06:10:46 <implementation> rwbarton: found this line in the output of ./configure: configure: WARNING: ctype.h: present but cannot be compiled
06:11:04 <rwbarton> ooh
06:11:18 <rwbarton> I guess maybe your compiler is partially working then
06:11:21 <implementation> as well as some other headers
06:12:47 <implementation> I'll try recompiling arm-linux-gnueabihf-gcc
06:13:19 <rwbarton> I would guess something is wrong with how it is installed, namely, it can't seem to find its header files
06:32:10 <Tjr> LYAH: " people first write up a Monad instance and then make an Applicative instance by just saying that pure is return and <*> is ap."
06:34:03 <Tjr> Can that be automated, e.g. "instance Monad m where {...} deriving ( Functor, Applicative)
06:34:28 * hackagebot clay 0.9.0.1 - CSS preprocessor as embedded Haskell.  http://hackage.haskell.org/package/clay-0.9.0.1 (SebastiaanVisser)
06:34:55 <nbouscal> Tjr: There's some work happening on that, tied in with the superclass stuff
06:35:15 <nbouscal> Not sure of the status, but I know that it's being worked on
06:38:20 <Tjr> nbouscal: thanks
06:41:41 <pjdelport> Tjr: There are the WrappedMonad instances.
06:42:47 <pjdelport> Tjr: That gives you the obvious Functor and Applicative instances for any Monad.
06:43:28 <Tjr> pjdelport: thanks
06:51:10 <pjdelport> Tjr: Once http://www.haskell.org/haskellwiki/Functor-Applicative-Monad_Proposal is in place, you'll be able to write the Applicative instance and have the Monad instance will automatically inherit its pure and <*>.
06:53:12 <Tjr> "On the other hand, removing fail has nothing to do with what we're trying to accomplish. "
06:53:20 <Tjr> Do people want to remove fail?
06:53:42 <rwbarton> pjdelport: well, then you still have to write the Monad instance (return and >>=), right? or at least >>=
06:54:07 <pjdelport> You'd only have to write join for the Monad instance, AFAIUI.
06:57:33 <c_wraith> Tjr: lots of people want to remove fail because it has nothing to do with being a monad
06:58:36 <Saizan_>  /win 10
06:58:48 <pjdelport> Tjr: https://github.com/quchen/articles/blob/master/monad_fail.md
06:58:52 <Saizan_> the irony is that this is win 10.
06:59:17 <c_wraith> Saizan: is that enough to win the whole tournament?
06:59:23 <rwbarton> Saizan: me too!
06:59:31 <rwbarton> win 10 that is
06:59:48 <Saizan> rwbarton: cheers!
07:00:51 <Saizan> c_wraith: ..no good comeback to that
07:04:30 * hackagebot chalmers-lava2000 1.4.1 - Hardware description EDSL  http://hackage.haskell.org/package/chalmers-lava2000-1.4.1 (EmilAxelsson)
07:05:39 <Saizan> so i have a strange CT,Haskell,HoTT kind of question, when do colimits have a first projection?
07:05:53 <mmachenry> Is there a version of bracket that does not reraise the exception? I have looked around hoogle and seems like try/catch stuff don't have similar types to stuff like bracket and finally.
07:06:14 <Saizan> existential types in haskell do not, but sigma types in TT do, and the grothendieck construction (which should be an oplax colimit) does.
07:07:10 <c_wraith> mmachenry: if it doesn't re-raise the exception, what does it return when there is an exception?
07:09:45 <mmachenry> c_wraith: I want :: Exception e => IO a -> (Either a e -> IO a) -> IO a
07:10:15 <mmachenry> So that second argument is a function that's always called, it might get the exception or it might get the return value from the first argument.
07:10:29 <mmachenry> And it returns whatever the second argument returns.
07:11:07 <rwbarton> Saizan: I think the projection you're thinking of can be described as the induced map from the colimit of your diagram to the colimit of the constant diagram on the terminal object
07:11:16 <mmachenry> Finally works like that. Bracket has an extra argument to allocate a resource (which I want) … but both are reraising my exception. I want it trapped. But I don't want to wrap the whole thing in a try
07:12:04 <rwbarton> Saizan: and also I think an existential type in Haskell is a coend -- at least when the type expression being quantified over is parametric (no GADT involved)
07:12:58 <c_wraith> :t \x f -> try x >>= f -- mmachenry, is this somehow not what you want?
07:12:59 <lambdabot> Exception e => IO a -> (Either e a -> IO b) -> IO b
07:14:22 <mmachenry> c_wraith: Yeah, it's kind of not. I want the extra argument that bracket has to open a resource.
07:14:36 <c_wraith> mmachenry: isn't that the first argument?
07:14:39 <mmachenry> c_wraith: What you wrote is what I would want if I wanted finally
07:14:44 <Saizan> rwbarton: ah, yeah, but my F for the coend is like F(_,x) = G x so it degenerates
07:14:58 <c_wraith> mmachenry: I mean, I slightly generalized on the type you provided.  It has the same number of arguments
07:15:39 <mmachenry> c_wraith: Yes I gave the finally type but what I really want is the bracket type, sorry for the confusion.
07:16:03 <Tjr> Do the @ signs in documentation mean anything beyond formatting?
07:16:05 <mmachenry> c_wraith, what you have there is a nice solution for finally.
07:16:16 <Tjr> e.g.  Right-to-left Kleisli composition of monads. @('>=>')@, with the arguments flipped
07:16:17 <c_wraith> mmachenry: so what type do you *actually* want?  I can think of like 3 different variants
07:16:27 <c_wraith> Tjr: those are just formatting
07:16:34 <Saizan> rwbarton: anyhow it seems to make sense, Gr (\(x : C) -> 1) seems equivalent to C
07:16:35 <Tjr> thanks
07:16:53 <mmachenry> c_wraith: bracket (connectTo "127.0.0.1" (PortNumber 8000)) hClose getCalls
07:17:02 <c_wraith> mmachenry: type?
07:17:10 <latk>  Is there some "insert or retrieve" function for Data.Map ?
07:17:29 <c_wraith> latk: I'm sure there is, if you squint a bit
07:17:41 <c_wraith> latk: (as in, it has some function that can be coerced to do that)
07:17:47 <latk> c_wraith: I couldn't see anything, but thought I would ask prior to writing it :p
07:19:02 <mmachenry> c_wraith: Exception e => IO a -> a -> IO b -> (a -> Either e b -> IO c) -> IO c
07:19:30 * hackagebot HUnit-Plus 1.0.0 - A test framework building on HUnit.  http://hackage.haskell.org/package/HUnit-Plus-1.0.0 (emc2)
07:19:32 <mmachenry> And it's just like bracket but it does not reraise… the third argument is passed the exception to deal with it as it sees fit.
07:19:49 <c_wraith> mmachenry: err, you mean Exception e => IO a -> (a -> IO b) -> (a -> Either e b -> IO c) -> IO c
07:19:51 <c_wraith> ?
07:20:21 <mmachenry> Yes, sorry
07:20:50 <mmachenry> I cut and pasted that from bracket and it didn't have parens in the docs. It used whitespace :)
07:20:58 <c_wraith> still only needs one try.
07:21:41 <mmachenry> How so?
07:22:40 <c_wraith> :t \init process cleanup -> do { x <- init ; y <- try $ process x ; cleanup x y }
07:22:41 <lambdabot> Exception e => IO t -> (t -> IO a) -> (t -> Either e a -> IO b) -> IO b
07:23:06 <Tjr> LYAH "The monadic counterpart to foldl is foldM."
07:23:24 <Tjr> Why is there no (name for the) monadic counterpart to foldr?
07:23:52 <Tjr> Given that left and right folds can be transformed into each other, a right monadic fold should exist.
07:23:57 <c_wraith> Tjr: it doesn't really work very well.
07:24:11 <rwbarton> Saizan: so I guess then the question becomes why is the sum type \sum_{x:A} () equivalent to A, while in Haskell data S = forall (x :: k). U has just a single value, even if k is promoted from a data type
07:24:26 <c_wraith> Tjr: it can't produce results lazily, it can't shortcut
07:24:37 <c_wraith> Tjr: with all those limits, you might as well just use foldl
07:24:42 <rwbarton> Saizan: in other words there still is a projection from data T = forall (x :: k). E[x] to data S = forall (x :: k). U, it just carries no information
07:24:44 <Tjr> c_wraith: is it because the left associativity of >>= breaks what you just said?
07:25:04 <Tjr> err, nonsense
07:25:08 <c_wraith> Tjr: it has nothing to do with associativity, and everything to do with what >>= means
07:25:34 <Tjr> c_wraith: thanks
07:25:55 <c_wraith> Tjr: same reason sequence can't return results lazily
07:26:21 <c_wraith> (at least in the general case)
07:26:27 <klrr_> is recursion-schemes useful if you want to do a lot of "modifications" on a recursive structure (like a syntax tree)?
07:27:51 <c_wraith> latk: you can use insertLookupWithKey and just keep using the old Map if the value was in the map previously.
07:28:04 <Tjr> How would you make folds perform well with monads?
07:28:11 <c_wraith> latk: this is taking full advantage of persistent data structures
07:28:48 <rwbarton> latk: you can one of the adjust-like functions too I think
07:29:06 <rwbarton> ah, alter
07:29:09 <rwbarton> :t Map.alter
07:29:10 <lambdabot>     Not in scope: ‘Map.alter’
07:29:10 <lambdabot>     Perhaps you meant ‘M.alter’ (imported from Data.Map)
07:29:13 <rwbarton> :t M.alter
07:29:13 <lambdabot> Ord k => (Maybe a -> Maybe a) -> k -> M.Map k a -> M.Map k a
07:29:56 <c_wraith> yeah, alter will do it.
07:31:04 <Saizan> rwbarton: i guess being able to write the map \sum_{x:A} () -> A relies on the naturality constraint being relatively weak, because it cames from the equality groupoid of A
07:31:36 <Saizan> rwbarton: while when you promote a datatype to a kind in haskell you kind of make it into an indiscrete category?
07:32:01 <rwbarton> Saizan: right, we still have parametricity over types of kind Bool etc.
07:33:08 <rwbarton> not sure how to fit that into the traditional notion of relational parametricity
07:33:45 <Saizan> have you seen atkey's paper with reflexive graphs?
07:34:08 <rwbarton> no, link?
07:34:36 <Saizan> http://bentnib.org/dtt-parametricity.html
07:35:30 <rwbarton> looks interesting, thanks
07:37:01 <frerich> Is anybody here Benedict Eastaugh?
07:37:14 <flebron> Does GHC benefit from me telling it that foldr f z (map g xs) = foldr (f . g) z xs, or does it already know this?
07:37:21 <Saizan> it seems quite flexible, because you always get to specify what relation to use when you introduce a new type
07:38:06 <Saizan> flebron: i'm pretty sure standard list fusion handles that already
07:38:14 <c_wraith> flebron: I think foldr/build should handle that easily
07:39:22 <Saizan> flebron: you could test though!
07:40:00 <flebron> Yeah, I was going to :)
07:44:45 <mmachenry1> c_wraith: that's what I have, basically for my definition of myBracket but I was hoping it already existed.
07:49:33 * hackagebot syntactic 1.13 - Generic abstract syntax, and utilities for embedded languages  http://hackage.haskell.org/package/syntactic-1.13 (EmilAxelsson)
07:51:38 <terrelln> \j haskell
07:55:10 <flebron> What intuition should I have for "build"?
07:56:10 <Saizan> ?type GHC.Exts.build
07:56:12 <lambdabot> (forall b. (a -> b -> b) -> b -> b) -> [a]
07:56:24 <Saizan> build f = f (:) []
07:56:52 <flebron> Yeah, but what can I imagine that to mean? What could f be?
07:57:22 <flebron> I'm thinking f could "hold" several a's, and it's applying those 'a's and the function it's passed?
07:57:31 <flebron> (And the initial b it's passed)
07:58:02 <bennofs> flebron: f is like a fold that was already applied to some structure. it uses an accumulator of type b
07:58:17 <Saizan> rwbarton: so actually the natural transformation you need to provide is between to constant functors, so the square collapses in one dimension, and so your notion of morphism for the index must match your notion of commutative diagram
07:58:40 <bennofs> :t \f a -> foldr f a [1,2,3,4]
07:58:40 <Saizan> well, f allows you to choose the type of the accumulator
07:58:41 <lambdabot> Num a => (a -> b -> b) -> b -> b
07:58:54 <bennofs> flebron: that's an example of a function that you could pass to build
07:59:11 <flebron> Right, yeah, so it's storing a list of a's and applying them over and over.
07:59:18 <jcullen> :t build
07:59:18 <flebron> i.e. folding that list of a's
07:59:19 <lambdabot>     Not in scope: ‘build’
07:59:19 <lambdabot>     Perhaps you meant ‘buildG’ (imported from Data.Graph)
07:59:20 <byorgey> flebron: f is a (Church-encoded) list
07:59:40 <bennofs> flebron: the list of 'a's doesn't even have to exist in memory, it could be just produced on the fly too
08:00:04 <flebron> Ah, OK, church encoding seems to make sense. So it materializes a church encoded list?
08:00:11 <byorgey> flebron: build turns a Church-encoded list into a normal one.
08:00:12 <flebron> (build, that is)
08:00:12 <byorgey> right.
08:00:40 <flebron> Cool, cool. Thanks.
08:01:58 <flebron> One unrelated question. In reading Theorems for Free, say I have a term t of type T. The theorem constructs the relation [[T]], and says (t, t) is in [[T]]. How should I think of [[T]]? What things are in that relation?
08:02:33 <flebron> (I only have a syntactic understanding of the theorem - I can compute the theorems, but the semantics of the relation construction escape me.)
08:04:26 <yitz> Saizan: with that definition, ((a -> [a] -> [a]) -> [a] -> [a]) -> [a] would do. why the rank 2 type?
08:04:29 <c_wraith> flebron: a relation can be thought of as a set of pairs
08:05:09 <c_wraith> flebron: { (a, b) | a is related to b }  (yes, it's directed)
08:05:12 <flebron> Sure, and if one omits the interpretation of the \forall rules, the relations all seem to be diagonals (i.e. of the form (x, x) for some xs.)
08:05:35 <flebron> The interpretation of \forall X. F(X) types seems to be the "key", I suppose, but that's one I still am not clear on.
08:05:46 <Saizan> flebron: well, it can be many things, but it must be respected by all the operations available for that type
08:06:19 <Saizan> flebron: so for base types like Bool or Nat it's just equality because pattern matching is a very strong operation
08:06:20 <byorgey> flebron: the interpretation of arrow types also gives you some nontrivial results, I think
08:06:22 <yitz> ah i see. bennofs gave an example that shows why.
08:06:39 <byorgey> flebron: the relation relates things which are "observationall equivalent"
08:06:47 <terrelln> > build (\f a -> foldr f a [1,2,3,4]) [0,0,0,0]
08:06:49 <lambdabot>  Not in scope: ‘build’
08:06:49 <lambdabot>  Perhaps you meant ‘buildG’ (imported from Data.Graph)
08:06:55 <flebron> Right, yeah, the functions do not distinguish more things than the relations in the input.
08:06:56 <byorgey> i.e. things you can't tell apart using the available operations
08:07:18 <yitz> > (\f a -> foldr f a [1,2,3,4]) (:) []
08:07:20 <lambdabot>  [1,2,3,4]
08:09:04 <flebron> Saizan: What do you think by "it can be many things"? Isn't [[T]] uniquely determined by T?
08:11:16 <Saizan> flebron: well, i mostly mean that there's some freedom in how you define [[_]] itself
08:11:32 <Tjr> flebron: my intuition for build is that it's the embedding map of a space into its bidual space.
08:12:55 <flebron> Haha, 'm afraid I'm not math-savvy enough for "bidual" to mean anything :)
08:13:44 * byorgey has never even heard the word "bidual" o.O
08:14:37 * byorgey thinks people who drop impressive-sounding but completely unhelpful math terms and then immediately quit the channel should be politely ignored
08:15:10 <flebron> Saizan: Not entirely sure I understand, doesn't the paper define [[_]] inequivocally? (The notation [[_]] is mine, the paper uses a stylized T to refer to the relation derived from a type T)
08:16:43 <_flatline_> hello byorgey
08:17:16 <Saizan> flebron: yeah, sorry, for that paper you have that one [[_]].
08:18:11 <Ankhers> I have `ghc-options: -O2 -threaded` in my .cabal file, but when I try and run my application with +RTS -N4 -RTS, it says that my program needs to be built with -threaded. What am I doing wrong?
08:18:40 <byorgey> hi _flatline_
08:19:42 <byorgey> Ankhers: is the ghc-options: field in the section of the .cabal file that corresponds to that executable?  How are you building the executable?
08:19:42 <Saizan> Ankhers: do you have that in the executable section?
08:20:02 <aochagavia> I have a question :)
08:20:23 <aochagavia> I am trying to export algebraic data type variants, but I get an error
08:20:35 <Ankhers> byorgey, Saizan: http://lpaste.net/105841
08:20:37 <aochagavia> I have something like: data EndState = Victory | Defeat
08:20:43 <rwbarton> "bidual" is just not-really-English for double dual (V |-> V**)
08:21:09 <aochagavia> and I cannot export it (Not in scope: type constructor or class `Victory`)
08:21:43 <byorgey> aochagavia: you have to put  EndState(Victory, Defeat)  in your export list
08:21:53 <byorgey> or EndState(..)
08:21:55 <aochagavia> ok, thanks!
08:21:55 <Ankhers> After that, I am just doing cabal install
08:22:42 <yitz> rwbarton: quartal? terral?
08:22:58 <flebron> Saizan: So just to clarify, when would (x, y) be in [[T]], conceptually?
08:23:10 <rwbarton> I guess the 3-version of duality is sometimes called triality
08:23:15 <rwbarton> never heard of a "trial" though :)
08:23:20 <yitz> heh
08:23:22 <byorgey> Ankhers: hmm, I'm not sure then. maybe try adding the -rtsopts flag to ghc-options: as well?
08:24:24 <Ankhers> Still getting the same error. I'm doing this in a cabal sandbox, does that make any difference?
08:24:26 <Saizan> flebron: what byorgey said, when they are observationally equivalent
08:24:44 <flebron> But then isn't (t, t) \in [[T]] "obvious"?
08:25:18 <Saizan> well, i guess the non-obvious part is that [[T]] respects this intuition
08:25:24 <byorgey> Ankhers: it shouldn't.  And you are running the executable in .cabal-sandbox/cabal/bin/ ?
08:25:31 <Ankhers> yes
08:26:43 <byorgey> flebron: given that intuition for [[T]], it is obvious that (t,t) should be in it.  But that doesn't mean proving it is easy.  the given definition of [[T]] might not actually correspond to that intuition.
08:27:27 <byorgey> the surprising thing is also that this "obvious" fact can also have interesting, non-obvious consequences for particular choices of T
08:28:41 <flebron> So what are the observers if this is observational equivalence? Function application?
08:29:21 <Saizan> mh, so maybe observationally equivalent is a property of [[T]], but [[T]] is actually stricter than that
08:29:42 <byorgey> Saizan: good point
08:30:03 <byorgey> flebron: any context, i.e. a term with a hole in it
08:30:31 <byorgey> flebron: two terms ore observationally equivalent if given any term with a hole in it, sticking the two terms in the hole results in terms which evaluate to the same thing
08:30:53 <flebron> Where the type of the hole is T?
08:30:57 <byorgey> right
08:31:10 <Ankhers> byorgey: I deleted the sandbox, reinitialized, recompiled, and now it works. Thanks for the help.
08:31:21 <flebron> That's pretty interesting, I'll try digesting that. Thanks :)
08:31:23 <byorgey> in other words, there is no possible function you can write that will give different outputs given the two terms as input
08:31:37 <byorgey> Ankhers: great!
08:32:10 <flebron> And is [[T]] somehow the "most general" set of pairs of observationally equivalent terms?
08:32:34 <byorgey> flebron: I don't know whether that's true.  I kind of doubt it actually.
08:32:45 <byorgey> there might be observationally equivalent terms which are not related by [[T]].
08:33:00 <flebron> Because their equality cannot be proven by the typesystem?
08:33:01 <Saizan> i would think of [[T]] as a relation on the semantics rather than the terms, btw
08:33:59 <flebron> Dumb question perhaps but, what does that mean? The semantics of what, of the terms?
08:34:21 <flebron> (I was thinking of terms as purely syntactical constructs)
08:35:39 <Saizan> yeah, the original paper went about it by defining a denotational semantics for the language, and then these relations over that semantics
08:36:44 <Saizan> and it was to solve the problem that if you just do the naive interpretation into sets and functions you get bad stuff in the semantics of forall
08:39:07 <byorgey> Saizan: by "the original paper" do you mean Wadler's "Theorems for Free" or Reynolds' "Types, abstraction, and parametric polymorphism"?
08:39:27 <flebron> (Tangentially related question: Can I prove that foldr and build are inverses syntactically?)
08:39:33 <Saizan> byorgey: the latter
08:41:36 <byorgey> flebron: my intuition is that one direction should be easy syntactically (I think build . foldr), but the other direction (foldr . build) probably requires parametricity
08:43:04 <flebron> Ah. So other than foldr (f . g) b = foldr f b . map g, what is another syntactically-provable thing that could help in optimizing a program?
08:43:25 <flebron> (I'm giving a small talk on proving properties of programs, going from these low level syntactic proofs, to proofs using naturality squares, to prametricity)
08:43:45 <Saizan> by syntactially you mean just using computation rules?
08:43:57 <flebron> Yeah :)
08:44:03 <Saizan> and induction i guess
08:44:13 <flebron> That too :)
08:44:37 * hackagebot IsNull 0.4.0.0 - A typeclass to determine if a given value is null.  http://hackage.haskell.org/package/IsNull-0.4.0.0 (jcristovao)
08:45:00 <Saizan> yeah, build . foldr should be doable like that
08:45:43 <quchen> build . foldr?
08:46:00 <quchen> I only know foldr (build ...), what's the other direction?
08:46:43 <flebron> foldr c n (build g) = g c n is the "optimizer" one, but it seems that requires parametricity.
08:47:41 <quchen> Yes, that's the usual one to me. What is the "build . foldr" equation?
08:53:14 <Saizan> yeah, because you need g to be nice
09:05:15 <johnw> bitemyap1: hi
09:05:30 <johnw> bitemyap1: I just do a 'find | xargs cabal upload' basically
09:06:46 <tristanStrange> hey all... any gloss fans about today?
09:06:59 <tristanStrange> I'm trying to use randomness in a sketch...
09:07:26 <tristanStrange> it uses simulate to schedule redrawing/updates to world etc.
09:07:58 <tristanStrange> currently I generate a list of random numbers at start up and index in to that using a time value that gets passed in
09:08:04 <tristanStrange> all feels a bitof amess really
09:09:51 <yubrew> is http://learnyouahaskell.com the best tutorial to get started?
09:10:23 <yubrew> it's my first try at a functional language
09:10:31 <xeno_> so, what parser library should I go for? parsec3? peggy?
09:10:38 <xeno_> peggy looks kinda cool
09:11:02 <mindeavor> yubrew: I think it’s an excellent place to get started, assuming you have experience in other programming
09:11:24 <yubrew> mindeavor yes, i'm pretty decent at ruby and somewhat decent with js
09:13:00 <mindeavor> yubrew: great, learning function programming will open your mind to new and shiny things :)
09:14:28 <yubrew> mindeavor how long have you been doing haskell? what do you do now for a career?
09:15:23 <yubrew> (if you don't mind saying)
09:16:26 <mindeavor> yubrew: I teach software development at an in-person code school. I’m not great at haskell, but learning it has “enlightened” me when programming in other languages (mainly ruby)
09:17:27 <xeno_> so, I guess cabal is immutable too? :) "cabal update" -> "there is a new version of cabal-install available" -> "cabal install cabal-install" -> "ok" -> "cabal update" -> "there is a new version of cabal-install available" ...
09:18:52 <flazz> will call by need memoize non bound expressions? will (f 2) + (f 2), only eval (f 2) once?
09:18:58 <geekosaur> xeno_, either the new one is not installed in $PATH (usually $HOME/.cabal/bin needs to be added) or your shell is caching its location and you need to clear the cache (`hash -r` in most shells, `rehash` in csh/tcsh)
09:19:59 <xeno_> geekosaur: not the latter, how can I find out about the former?
09:19:59 <geekosaur> remember (a) ~ is not reliable in $PATH, use $HOME to be certain; (b) earlier entries in $PATH override later ones, so add to the *start* of $PATH not the end
09:20:09 <geekosaur> echo $PATH
09:20:19 <xeno_> ah
09:20:42 <xeno_> there is no ~/.cabal/bin
09:20:49 <geekosaur> and then check where the new one was installed; this will be ~/.cabal/bin on most unixes, ~/Library/Haskell/bin on OS X with the official H-P package, no idea about Windows)
09:20:57 <xeno_> I have /Users/jan/Library/Haskell/bin/cabal
09:21:18 <geekosaur> yes, so you need to put $HOME/Library/Haskell/bin at the front of your $PATH
09:21:59 <xeno_> it already is
09:22:13 <alcabrera> flazz: I'm not sure call by need alone will memoize that, since both instances are unique thunks. That might fall into the realm of compiler optimization, in that ghc might be able to prove that both call paths are identical.
09:22:25 <xeno_> hmm...
09:22:29 <xeno_> but the new is installed in /Users/jan/Library/Haskell/ghc-7.6.3/lib/cabal-install-1.20.0.2/bin
09:22:50 <flazz> alcabrera: what makes the thunks unique?
09:23:25 <xeno_> alcabrera: ah, I missed a warning
09:24:22 <alcabrera> as far as I know, and I'm no expert here, is that they are invoked as 'Expr1 + Expr2'. Expr1 and Expr2 makes them distinct. I can double check this in ghci, flazz.
09:24:47 <geekosaur> xeno_: oh, I think that is a bug. have seen it, bot very consistently, and nobody involved with cabal-install seems to know what's up with it
09:25:04 <geekosaur> that it sometimes doesn't (re)create links to ~/Library/Haskell/bin
09:25:12 <xeno_> yep, that's the problem
09:25:16 <geekosaur> so you'll need to do it manually :/
09:25:58 <comerijn> geekosaur, xeno_: If you had already installed cabal-install by hand there will be a symlink in ~/Library/Haskell/bin and cabal won't update it
09:26:24 <comerijn> Cabal actually prints a warning about the symlink, but no one reads it
09:26:25 <tommd> Just because something is syntactically identical does not mean the compiler will recognize them as common sub-expressions.  If you'd like to ensure there is only one thunk then name it with a let binding (let x = f 2 in x + x)
09:26:38 <geekosaur> comerijn, there are cases where it just doesnt create the symlink at all
09:26:46 <geekosaur> when there's nothing already there to be replaced
09:27:43 <xeno_> comerijn: yeah, I noticed the warning too late
09:28:14 <xeno_> comerijn: the stuff I found when googling indicates that haskell doesn't track what links it manages, but guesses (wrongly)
09:28:56 <flebron> Is there a rigorous way of saying that polymorphic functions induce natural transformations between Hask endofunctors?
09:33:48 <latk> Is there an easy way to do Map a Int -> [a], where the list is constructed in ascending value of Int ?
09:33:54 <alcabrera> I'm having no luck, but you should be able to double-check whether something still is or isn't a thunk using :sprint in ghci, flazz. The beginning of chp 2 of parallel and concurrent haskell has a great section on this. :)
09:35:18 <tommd> latk: map fst . sortBy (comparing snd) . Map.assocs
09:36:25 <latk> tommd: Hah, yeah that will do it. Thanks
09:36:42 <xeno_> meh... openBinaryTempFile: permission denied (Permission denied)
09:39:37 <xeno_> that is during a cabal install - but cabal is installed in my own folder...
09:59:38 <jfischoff> I want to parse something and immediantly pretty print it to stdout. How should I structure my program so I can avoid intermediate datastructures?
10:00:02 <benzrf> jfischoff: hmmm?
10:00:12 <benzrf> avoid intermediate data structures?
10:00:13 <benzrf> why?
10:00:18 <jfischoff> performance
10:00:39 <jfischoff> no reason to create something I will immediantly destroy
10:00:49 * benzrf shrugs
10:00:54 <monochrom> if there is a parser error in the future, do you want to print anything now?
10:01:00 <jfischoff> yes
10:01:02 <benzrf> jfischoff: sounds like premature optimization to me
10:01:11 <benzrf> jfischoff: don't you know the 3 laws of optimization?
10:01:51 <monochrom> then consider my http://www.vex.net/~trebla/haskell/parsec-generally.xhtml#IO . you can print immediately with liftIO
10:01:57 <jfischoff> I’m fine with printing a partial result followed by “failed to parse"
10:02:07 <jfischoff> thanks
10:02:26 <monochrom> or even the yield tricks further down
10:02:50 <benzrf> actually
10:02:53 <benzrf> you don't even need liftIO
10:03:01 <benzrf> you can parse into an IO mobit
10:04:31 <benzrf> monochrom: why not use a transformer over pipes instead of a half-baked generator impl?
10:05:10 <monochrom> why do you ask?
10:06:01 <monochrom> I have shown an example of ParsecT IO. the example shows you can use ParsecT Whatever_You_Want. IO is just an easy example.
10:06:27 <monochrom> why not use the ParsecT IO example so that my article has lower barrier to entrance?
10:06:58 <monochrom> must all my artcles show exclusively how God would code?
10:07:39 <benzrf> monochrom: i meant for the yielding things >.<
10:08:00 <benzrf> nothing wrong with the IO bit o.o
10:08:17 <monochrom> I don't know PIpe.
10:08:18 <jhance> God doesn't use pipes because he doesn't know what to do with the leftovers
10:08:31 <benzrf> i read that comic :p
10:08:37 <benzrf> what are leftovers in this context?
10:08:53 <jhance> no idea, all I know is that god uses lazy IO cause he couldn't figure out how to do strict
10:09:15 <monochrom> and ContT and a ContT-based yield is just another example
10:09:15 <benzrf> monochrom: pipes is pretty simple if you just do basic producer/consumer/pipe stuff
10:09:27 <benzrf> and it's not that bad even when you expand to full-on proxies
10:09:30 <benzrf> monochrom: ok
10:09:51 <benzrf> :t Pipes.yield
10:09:53 <lambdabot> Not in scope: ‘Pipes.yield’
10:09:56 <benzrf> weh
10:09:58 <n-dolio> How come pipes users always bring up pipes whenever people don't use pipes?
10:10:13 <benzrf> n-dolio: when they're writing generators from scratch, sure
10:10:52 <jfischoff> same with lens though
10:10:54 <benzrf> n-dolio: in this specific context, monochrom has a code sample for something that yields values much like a Producer in pipes
10:11:34 <monochrom> this is why I don't provide a "comments" section on any of my articles. commentators always miss the point and focus on pedantic side issues and expect my articles to show how God would code.
10:11:41 <benzrf> monochrom: >.>
10:12:16 <benzrf> monochrom: all im saying is, if you were demoing how to integrate data structure updating into parsec, you'd use lens and not your own new thing, right?
10:12:30 <monochrom> this is why I don't make my articles an open wiki. contributors always bloat wiki articles to include everything under the sun.
10:12:32 <jhance> I'd rather not see a pipes dependency inside of parsec
10:12:38 <n-dolio> How do you know this article isn't older than pipes?
10:12:40 <n-dolio> And lens.
10:12:42 <benzrf> n-dolio: true
10:12:53 <benzrf> jhance: the article was about using parsec as a transformer
10:13:13 <monochrom> I would not use lens either.
10:13:22 <benzrf> monochrom: fair enough
10:14:17 <benzrf> ParahSailin: shouldn't it be ParahSalin
10:14:22 <monochrom> I would rather not see a pipes dependency or a lens dependency inside a parsec article.
10:14:26 <benzrf> monochrom: alright
10:14:40 <monochrom> this is possibly what jhance also means.
10:15:35 <benzrf> pipes is a pretty cool guy
10:15:53 <benzrf> hello banister
10:16:00 <banister> hello benzrf
10:16:02 <benzrf> we're bikeshedding \o
10:16:04 <benzrf> * \o/
10:17:27 <Rufflewind> does Haskell make any guarantees about whether CDouble and Double (likewise for [C]Float) have the same Storable representation? I would like to pass an array of them to FFI but would really want to avoid doing fmap realToFrac if possible
10:18:18 <mikeplus32> Rufflewind: i don't think it does... but they do seem to have the Storable representation
10:18:31 <Rufflewind> or at the very least, is there a way to know (i.e. throw a compile error) if CDouble and Double are compatible in the manner I described above?
10:19:01 <Rufflewind> so if someone tries to compile on a system where it isn't true they'd not get a segfault at runtime :P
10:19:12 <benzrf> segfaults >:o
10:19:17 <jhance> If all of those values are going to be processed, then the cost to the O(n) fmap realToFrac is asymptotically irrelevant
10:19:41 <jfischoff> well with rewrite rules it could be a noop
10:20:26 <gspr> Rufflewind: In GHC 7.8 there's the magical Coercible typeclass.
10:20:34 <jfischoff> Rufflewind: it you are worried about the performance of the conversion, you should check the core to see if it actually happens
10:20:58 <gspr> Rufflewind: There's an instance Coercible a b whenever a and b have the same representations. Then you can do coerce :: a -> b at no cost.
10:21:06 <jfischoff> if you conversion is truly id then ghc might get rid of the function for you
10:21:26 <rwbarton> what exactly are you doing? you have a storable array of Doubles and want to pass it to C?
10:21:30 <gspr> Rufflewind: I've wondered myself if there's plans for GHC to provide a compile-time list of which a and b there are Coercible a b instances for on the given platform
10:22:07 <gspr> Rufflewind: Because then we could say "convert Double to CDouble with coerce (no cost) on platforms where they're the same, and use realToFrac otherwise"
10:22:23 <gspr> But I don't know if there's a way to do this… still, Coercible seems nice.
10:22:38 <jhance> In what world would you have Double and CDouble with different representations, though
10:22:46 <jhance> I would assume both would always just be IEEE
10:22:58 <mikeplus32> well it's not really about coercing CDouble to/from Double anyway, it's about their storable instances in particular
10:23:26 <gspr> jhance: But that's not in the language specification, afaik
10:23:58 <gspr> jhance: (or is it?)
10:24:06 <Rufflewind> rwbarton: yeah something like that
10:24:09 <jhance> gspr: Well I'd say if you were on a platform that is using doubles that can't use hardware calculations, theres something far more wrong
10:24:24 <jhance> gspr: But you're right in that its probably not in the spec
10:25:08 <oisin620> I'm having a little trouble with arrows. I think I understand how they work - but could someone fill me in on why they're useful? The guide I've been reading shows how you can combine two arrows together using (>>>). But can't we do the same thing with functions using .?
10:25:13 <jhance> I highly doubt the fmap has any noticable cost even if it isn't fused away
10:25:39 <jhance> oisin620: Arrows are more generic than functions
10:25:48 <gspr> jhance: IIRC there's something interesting about that part in http://www.haskell.org/pipermail/haskell-cafe/2011-April/090778.html
10:25:54 <gspr> jhance: (might have the wrong thread though)
10:26:27 <oisin620> jhance: In what respect though? What can we do with arrows that can't be done using functions?
10:27:20 <jhance> gspr: Hmm, that seems crazy slow, although that might be due to the genericness of realToFrac. Is there a direct Double -> CDouble conversion defined anywhere?
10:28:08 <jhance> gspr: Same thread also reveals that they aren't exactly the same but unsafeCoerce is okay in most cases
10:29:15 <dwcook> oisin620: For one thing, you can also use Arrow to compose Kleisli arrows. There may be other interesting instances but functions and Kleisli arrows are the ones you can see in the docs.
10:29:20 <rwbarton> I thought there was a RULE somewhere to turn realToFrac between Double and CDouble into something trivial
10:29:46 <jhance> rwbarton: Thread is from 2011, so thats probably the case now
10:30:39 <n-dolio> oisin620: Maybe they're not a very useful abstraction. :)
10:31:23 <dwcook> That's basically the impression I get.
10:31:40 <jhance> dwcook: See HXT
10:31:54 <oisin620> dwcook: n-dolio: Ok - thanks :)
10:32:13 <jhance> oops, oisin620: see HXT
10:32:15 <dwcook> jhance: I can't use that as a useful search term, can you be more specific?
10:32:42 <jhance> dwcook: Its just an example of arrow usage. Its a package on hackage
10:32:50 <dwcook> Ah.
10:32:52 <deweyvm> how come this gives me a list of the same value over and over? http://pastebin.com/RzJpNQk0
10:33:19 <jhance> dwcook: Incidentally, it _is_ useful as a search term on google
10:33:50 <dwcook> So it is.
10:33:52 <oisin620> jhance: Thanks
10:34:44 <deweyvm> "gen" is asking for rng values, im certain
10:35:06 <gspr> jhance: Yeah, that's my takeaway aswell.
10:36:57 <pavonia> deweyvm: What are you using for gen?
10:37:20 <deweyvm> pavonia: http://pastebin.com/mNn2ReE1
10:39:32 <deweyvm> weird, a simpler generator works
10:39:47 <deweyvm> http://pastebin.com/ErsUgpCP this one
10:40:16 <deweyvm> i think i dont understand MonadRandom...
10:44:57 <deweyvm> nvm, its my algorithm i didnt understand
10:45:00 <deweyvm> it actually does work
10:45:05 <deweyvm> apologies!
10:50:37 <Rufflewind> jfischoff: map realToFrac :: Vector CDouble -> Vector Double didn't compile into a no-op unfortunately; although Coercible works, it still doesn't guarantee that the types have the same Storable instance
10:51:06 <rwbarton> storable Vector I assume?
10:51:11 <Rufflewind> yeah
10:51:15 <rwbarton> it's probably a bug that Coercible works
10:51:20 <rwbarton> the array package has the same issue
10:52:07 <jfischoff> Rufflewind: not terribly surprised, but just to be sure, you had optimizations turned on?
10:52:13 <Rufflewind> -O3
10:52:31 <Rufflewind> I think I'll just put Ptr Double in my FFI declarations and document it as an unchecked assertion
10:52:55 <Rufflewind> (which is what other libraries seem to be doing anyway)
10:54:13 <Rufflewind> but I'd say it'd be a lot easier if there was a way to check if Storable instances are identical (undecidability issues aside) :)
11:11:43 --- mode: asimov.freenode.net set +o ChanServ
11:12:30 <I_Am_Undercover> hi all
11:12:53 <nyanpasu> hi I_Am_Undercover
11:13:23 <joelteon> Is anyone here familiar with hjsmin?
11:17:11 --- mode: asimov.freenode.net set +o ChanServ
11:17:20 <chrisdone> fwiw, uglifyjs is the best out there by my books
11:17:30 <chrisdone> closure gives you the best size, but you pay for it by having to go get a coffee while it completes
11:18:05 <chrisdone> uglifyjs will compress to just a little bit larger than closure, about 7x faster. although after gziping it's smaller, so it's the best imo
11:18:14 <joelteon> no haskell bindings, huh
11:18:47 <chrisdone> sadly not, other than readProcess
11:18:52 <joelteon> oh, well that can't be too hard
11:19:02 <joelteon> i'll just do that instead
11:19:32 <joelteon> after all yesod already does that with coffeescript
11:19:44 <chrisdone> ah, so you're compressing for production in yesod
11:19:50 <joelteon> yea
11:20:17 <chrisdone> fwiw process-extra contains a readProcess for Text and ByteString, if you're avoiding Strings
11:20:26 <chrisdone> http://hackage.haskell.org/package/process-extras
11:20:28 <joelteon> good idea, i didn't want to have to unpack
11:20:51 <chrisdone> :)
11:28:03 <joelteon> that worked, thanks chrisdone
11:28:33 <chrisdone> \o/
11:31:12 * hackagebot vinyl 0.4.2 - Extensible Records  http://hackage.haskell.org/package/vinyl-0.4.2 (JonSterling)
11:32:53 <benzrf> is there a chrisstarting
11:33:07 <benzrf> :^)
11:33:24 <chrisdone> benprng
11:34:15 <jle`> i didn't realized it was pronounced with an o like in "dome" until haskell casts
11:34:18 <jle`> sorry chrisdone
11:34:49 <benzrf> chrisdone: is zrf a thing?
11:35:01 <benzrf> g2g see u
11:38:31 <chrisdone> jle`: almost no one does
11:38:58 <jle`> sometimes i pronounced it "dough-nay", like...french
11:39:10 <chrisdone> that was my nickname in high school
11:39:18 <chrisdone> doney
11:40:01 <jle`> glad to hear i am not alone
11:40:18 <chrisdone> i bet people say "justin lee" and it's supposed to be "leh" =p
11:41:24 <jle`> when my family came her they told everyone it was lee...probably to not have to explain it to everyone.  nowadays i actually get a bit of both.  but yeah you're right >_>
11:41:55 <c_wraith> chrisdone: I just figured you're finished. (I nearly resisted the Finnish) pun.
11:42:06 <c_wraith> hmm.  misplaced parens.  oh well
11:42:53 <monochrom> Joakim von Wright's "Wright" is supposed to be pronounced "Vricht".
11:43:12 <jle`> (by her i mean here and by here i mean the states...apologies for my amero-centric world views leaking out)
11:45:05 <bennofs> Wow, latest gloss version doesn't support GHC 7.6.3 anymore? DOes anyone know the reason for this?
11:45:20 <bennofs> (it requires base == 4.7.*)
11:45:38 <monochrom> I guess it's a mistake.
11:46:29 <c_wraith> or else it decided to use a GHC 7.8+ feature
11:47:42 <chrisdone> c_wraith: in italian i jokingly call myself Cristoforo Fatto, which has a better ring to it
11:48:04 <zerokarmaleft> Don Fatto
11:49:39 <chrisdone> someone decided to use a ghc 7.8-only feature? https://www.youtube.com/watch?v=a1Y73sPHKxw
11:50:33 <chrisdone> i'm betting if any feature, it was lambda case
11:51:28 <bennofs> I think someone was just didn't use CPP to keep supporting 7.6.3
11:52:05 <monochrom> wait, lambdacase is in 7.6 already
11:52:51 <chrisdone> oh, yeah
11:52:56 * chrisdone is still stuck on 7.4 >_>
11:53:05 <rwbarton> well, it must be some 7.8 feature that will be removed in 7.10, maybe that narrows it down ;)
11:53:12 <monochrom> that's FPComplete for you! <duck>
11:53:13 <chrisdone> we don't use none of y'all fancy dancy features round here
11:53:51 <chrisdone> checkout this cabal file http://hackage.haskell.org/package/haskell-docs-3.0.2/haskell-docs.cabal
11:53:57 <chrisdone> it compiles on all those ghc versions!
11:54:03 <chrisdone> \o/
11:54:50 <monochrom> that is impressive legacy there
11:55:00 <chrisdone> =p
11:55:25 <Rufflewind> what about ghc==7.3.*? :)
11:55:40 <chrisdone> there was no such release!
11:55:41 <monochrom> one day you will add "est. 2010"
11:55:51 <bennofs> yeah, let's also support all RCs ! :D
11:56:13 * hackagebot highlighting-kate 0.5.8.3 - Syntax highlighting  http://hackage.haskell.org/package/highlighting-kate-0.5.8.3 (JohnMacFarlane)
11:56:32 <monochrom> answer "some past version on github supports 7.3.99999999"
11:56:47 <monochrom> "use bisection to find it"
11:56:54 <chrisdone> hehe
11:56:57 <Rufflewind> how do I go from    a -> IO b    to    IO (a -> b)   ? (Is there even a way?)
11:57:19 <monochrom> I think there is no way
11:57:20 <chrisdone> it didn't take that much effort to make it work on them all so it was worth it, it sucks when you're stuck on a ghc version due to work and can't get decent tooling because of it
11:58:04 <Rufflewind> Debian still has 7.4 in the package manager
11:58:06 <jle`> Rufflewind: where doy ou need an IO (a -> b) ?
11:58:07 <chrisdone> hey sloany
11:58:15 <jle`> you might just want to go straight from (a -> IO b) to what you need
11:58:15 <Rufflewind> jle`: QuickCheck.ioProperty
11:58:17 <chrisdone> rufflewind: exactly!
11:59:02 <Rufflewind> jle`: I wanted to do some IO in a test without doing unsafePerformIO
11:59:23 <chrisdone> there's a IO support for quickcheck
11:59:28 <chrisdone> but i've never used it
12:00:06 <Iceland_jack> chrisdone: it's quite nice to use actually
12:00:09 <chrisdone> https://hackage.haskell.org/package/quickcheck-io
12:00:20 <Iceland_jack> you don't need a separate package
12:00:27 <Iceland_jack> you should use Test.QuickCheck.Monadic
12:00:36 <chrisdone> ah, that's it
12:00:46 <Iceland_jack> Allows you to test any monad, with special support for ST
12:00:49 <chrisdone> was added in 2.0
12:01:13 * hackagebot spe 0.2 - Combinatorial species lite  http://hackage.haskell.org/package/spe-0.2 (AndersClaesson)
12:02:13 <Rufflewind> I'm not sure how to use QuickCheck.Monadic though ...
12:02:33 <Rufflewind> guess it's time to google
12:02:41 <Iceland_jack> Rufflewind: what do you want to do?
12:03:16 <Iceland_jack> Running an action and testing its value is very simple
12:03:18 <jhance> Rufflewind: `monadic` and `monadicIO` unmonadify the property
12:03:22 <jle`> Rufflewind: you can also look at the haddocks :)
12:04:32 <Iceland_jack> Rufflewind: The docs are pretty bad for .Monadic, this has a nice example: http://stackoverflow.com/questions/7370073/testing-functions-in-haskell-that-do-io
12:04:44 <jle`> oops
12:05:17 <Iceland_jack> But the basic model is
12:05:17 <Iceland_jack>     prop_test = monadicIO $ do
12:05:17 <Iceland_jack>       a <- ma
12:05:17 <Iceland_jack>       assert (a == "hi")
12:06:27 <Iceland_jack> Another example from SO: http://stackoverflow.com/questions/2259926/testing-io-actions-with-monadic-quickcheck
12:08:05 <chrisdone> what would you call things like IORef and MVar?
12:08:21 <monochrom> mutable cells
12:08:22 <Iceland_jack> Probably 'mutable references'
12:08:24 <jle`> i think of them as pointers
12:08:35 <monochrom> MUTO
12:08:38 <chrisdone> incoherent replies, as expected
12:08:40 <jle`> (but don't listen to me)
12:08:56 <chrisdone> hmm
12:08:59 <Iceland_jack> The docs for MVar call it a 'mutable location'
12:09:02 <jle`> IORefs to me are what pointers are in C...except without arithmetic
12:09:17 <chrisdone> i need a better module name than this https://github.com/gregwebs/foreign-store/commit/32e488efed98a47f77a9afaebfd6f5f9fe91013c
12:09:18 <jle`> actually don't listen to me, i didn't think that through
12:09:27 * jle` backs out
12:09:29 <chrisdone> as Base makes no sense
12:09:43 <Iceland_jack> The naming scheme of IORef is rather unfortunate
12:09:56 <chrisdone> TVar, STRef, IORef, MVar
12:10:23 <jle`> references to mutable cells with "smart accesses"
12:11:02 <chrisdone> and i called my thing a 'Store' which is probably equally unfortunate
12:11:14 <chrisdone> https://github.com/chrisdone/foreign-store/blob/master/src/Foreign/Store.hs
12:11:21 <Iceland_jack> Store has other meanings
12:11:44 <Iceland_jack>     (s -> a, s)
12:12:02 <tristanStrange> is there anything i can derive from to make a data type work with randoms?
12:12:37 <chrisdone> :t randoms
12:12:39 <lambdabot> (Random a, RandomGen g) => g -> [a]
12:12:57 <chrisdone> probably implement RandomGen for your type using another type like Integer
12:13:08 <chrisdone> assuming your type is mappable to the integers
12:13:19 <Iceland_jack> chrisdone: RandomGen? You mean 'Random'?
12:13:21 <chrisdone> er, sorry, Random
12:13:48 <rwbarton> tristanStrange, you can't derive it, no
12:13:59 <tristanStrange> ah ok... theres no magic i can use then... was hoping i could say: randoms gen :: [Mytype] like i do with [Bool]
12:14:04 <rwbarton> except with GeneralizedNewtypeDeriving if your type is a newtype of something
12:14:20 <tristanStrange> its not... i don't think
12:14:27 <tristanStrange> data Direction = North | South | East | West
12:14:40 <Iceland_jack> tristanStrange: that's going to be easy to implement
12:14:42 <chrisdone> ah, then you can map it fairly easily at least
12:14:45 <identity> tristanStrange: If you derive Enum you can use fromEnum ..
12:14:54 <chrisdone> Enum gives you the integer encoding
12:15:09 <identity> but you can also just do it manually and skip on deriving Enum
12:15:28 <chrisdone> if you're trying to pass the time
12:15:54 <ReinH> chrisdone: o/
12:15:55 <Rufflewind> Iceland_jack: ohhh took me a while before I realized PropertyM is just a monad transformer
12:16:00 <tristanStrange> ok cheers guys
12:16:07 <chrisdone> @let data X = A | B | C deriving (Enum,Show)
12:16:11 <lambdabot>  Defined.
12:16:32 <chrisdone> > toEnum 0 :: X
12:16:34 <lambdabot>  A
12:16:39 <chrisdone> > toEnum 1 :: X
12:16:40 <chrisdone> etc
12:16:41 <lambdabot>  B
12:17:29 <chrisdone> @undef X -- is this possible?
12:17:29 <lambdabot> There's currently no way to undefine just one thing.  Say @undefine (with no extra words) to undefine everything.
12:17:39 <chrisdone> @undefine
12:17:39 <lambdabot> Undefined.
12:17:56 <Poultra> allo
12:18:11 <Poultra> ?
12:18:12 <chrisdone> hi poultra
12:18:22 <chrisdone> ça va?
12:18:23 <Poultra> hi choosegoose
12:18:26 <Rufflewind> did they change @faq?
12:18:34 <Poultra> ok
12:18:41 <monochrom> yes
12:18:51 <Poultra> hi choosegoose
12:19:12 <chrisdone> hej reinman
12:19:16 <Poultra> so
12:19:28 <Poultra> ca va
12:19:46 <Poultra> me from musik
12:19:52 <Poultra> 44 ans
12:20:21 <Poultra> ok
12:20:42 <Poultra> tu aimes la musiques
12:20:59 <mindeavor> does anyone know how to get rid of the hundreds of “missing terminating ' character” warnings when installing with cabal?
12:21:03 <Poultra> me 1970
12:21:09 <Poultra> me
12:21:33 <Poultra> mindeavor
12:21:47 <Poultra> do you love musik
12:22:09 <monochrom> Poultra, this is not the right channel.
12:22:12 <chrisdone> @let data X = A | B | C deriving (Enum,Show,Bounded)
12:22:13 <chrisdone> > map toEnum (randomRs (fromEnum (minBound::X),fromEnum (maxBound::X)) (mkStdGen 0)) :: [X]
12:22:14 <simon> Poultra, this is not a general-purpose chat channel.
12:22:14 <lambdabot>  Not in scope: type constructor or class ‘X’Not in scope: type constructor or...
12:22:16 <lambdabot>  Defined.
12:22:21 <chrisdone> > map toEnum (randomRs (fromEnum (minBound::X),fromEnum (maxBound::X)) (mkStdGen 0)) :: [X]
12:22:22 <lambdabot>  [C,C,A,A,B,B,A,B,B,A,C,B,A,B,C,B,C,A,A,A,B,A,A,C,B,C,C,A,C,B,C,C,C,C,B,B,C,B...
12:22:24 <chrisdone> anyone got a shorter way?
12:22:33 <geekosaur> mindeavor, that sounds unusual to me
12:22:34 <Poultra> me
12:22:50 <Poultra> do you love me
12:22:54 --- mode: ChanServ set +o monochrom
12:22:59 <rwbarton> it's the clang CPP issue I think
12:23:12 <identity> lol.
12:23:48 <chrisdone> tristanStrange: maybe that helps ^
12:23:52 <Rufflewind> Iceland_jack: thanks for the links; think I figured it out :)    "monadicIO . (assert =<<) . run" converts (IO Bool) into Property
12:24:54 <tristanStrange> ah ok nice..... but a little bit ugly chrisdone!
12:25:46 <joelteon> just like me!
12:27:33 <chrisdone> tristanStrange: it seems that instances are much easier to write
12:27:38 <chrisdone> instance Random Int where
12:27:39 <chrisdone>   randomR (a,b) g = randomIvalInteger (toInteger a, toInteger b) g
12:27:39 <chrisdone>   random g        = randomR (minBound,maxBound) g
12:27:59 <Poultra> allo toi
12:28:06 <chrisdone> instance Random Char where
12:28:06 <chrisdone>   randomR (a,b) g = case (randomIvalInteger (toInteger (ord a), toInteger (ord b)) g) of (x,g') -> (chr x, g')
12:28:06 <chrisdone>   random g	  = randomR (minBound,maxBound) g
12:28:07 <chrisdone> etc
12:28:21 <chrisdone> instead of ord and chr you would use fromEnum and toEnum, i think
12:28:33 * chrisdone tries it
12:28:53 <Poultra> its a dog
12:29:03 <Poultra> salut
12:29:08 <chrisdone> a very poor chat bot
12:29:16 <Poultra> i dont- want a dog
12:29:26 <Sculptor> if you are dog, you don't want to be in china, atm
12:29:28 <Poultra> ChewieBeardy
12:29:40 <chrisdone> monochrom: ping
12:29:43 <Sculptor> it's some dog eating holiday over there
12:29:44 <Poultra> if you are a dog
12:29:46 --- mode: monochrom set +b *!*@APuteaux-551-1-88-250.w92-132.abo.wanadoo.fr
12:29:46 --- kick: Poultra was kicked by monochrom (Poultra)
12:31:06 <chrisdone> ah, nevermind tristanStrange
12:31:10 <chrisdone> randomIvalInteger is not exported
12:31:18 <chrisdone> because convenience is for losers
12:32:07 <rwbarton> well, it is pretty close to just being randomR
12:32:54 <tristanStrange> thanks chrisdone.... thats all gonna take me a moment to digest!
12:32:55 <genisage> does lambdabot have anything similar to :i ?
12:33:43 <chrisdone> genisage: not really
12:33:48 <chrisdone> @src Maybe
12:33:48 <lambdabot> data Maybe a = Nothing | Just a
12:33:55 <chrisdone> ^ about the best you can get
12:33:58 <robbins> I have a quick question: Why is it advisable to use guards instead of patterns for the replicate function:
12:34:01 <robbins> replicate' :: Int -> a -> [a]
12:34:04 <robbins> replicate n x | n <= 0 = [] | otherwise = x: replicate (n-1) x
12:34:17 <robbins> according to LYAH
12:34:24 <chrisdone> because the condition is <=
12:34:31 <chrisdone> patterns can only do =
12:35:09 <robbins> chrisdone: Couldn't you use (eg: _ 0) instead?
12:35:48 <chrisdone> robbins: in the words of Morpheus, show me!
12:35:49 <robbins> Or am I making assumptions about the input
12:36:04 <genisage> what about something that tells you where a function is imported from? Can it do that?
12:36:16 <chrisdone> @hoogle maybe
12:36:19 <lambdabot> Prelude maybe :: b -> (a -> b) -> Maybe a -> b
12:36:19 <lambdabot> Data.Maybe maybe :: b -> (a -> b) -> Maybe a -> b
12:36:19 <lambdabot> Foreign.Marshal.Utils maybeNew :: (a -> IO (Ptr a)) -> (Maybe a -> IO (Ptr a))
12:36:19 <genisage> Or just a help function so I don't have to ask here
12:36:33 <chrisdone> why not just use ghci?
12:36:55 <robbins> chrisdone: replicate' :: Int -> a -> [a]
12:37:10 <genisage> That's why I asked that last question. So that I can import the function and use :i from ghci
12:37:19 <robbins> chrisdone: replicate' :: a -> Int -> [a]
12:37:19 <robbins> replicate' _ 0 = []
12:38:35 <monochrom> what will happen to "replicate' xxx (-3)"?
12:38:46 <robbins> monochrom: infinit loop :(
12:38:59 <robbins> *infinite
12:39:15 <monochrom> ok, but "replicate (-3) xxx" is not an infinite loop
12:40:03 <robbins> monochrom: my implementation results in an infinite loop, the replicate from prelude returns an empty list
12:40:32 <ion> replicate' xxx (-3) is the list to which you can add three xxxs to end up in the empty list.
12:40:42 <benzrf> O:
12:40:59 <chrisdone> ion: i like the way you think
12:41:30 <genisage> chrisdone: And also because I don't have half the things mentioned in irc installed locally.
12:41:45 <robbins> I'm testing for a boolean expressions, I think that's why guards are used.
12:42:07 <monochrom> yes
12:42:32 <monochrom> "why guard instead of pattern" to me is like "why walk instead of chat"
12:42:36 <rwbarton> does anyone understand this cabal error? http://lpaste.net/105847
12:42:59 <rwbarton> the package installed fine without --allow-newer
12:43:49 <monochrom> rwbarton, it seems like 1.8 is neither >=1.19 nor >=1.8
12:43:54 <robbins> Thanks for your help monochrom and chrisdone, the friendly atmosphere really helps when learning haskell.
12:43:56 <monochrom> err
12:44:05 <monochrom> it seems like 1.18 is neither >=1.19 nor >=1.8
12:44:10 <rwbarton> indeed, but I don't understand where 1.19.2 is coming from at all
12:44:21 <monochrom> err, nevermind
12:44:59 <chrisdone> robbins: welcome!
12:45:32 <rwbarton> one unusual feature of the package is that it has build-type: Custom
12:45:53 <monochrom> I think I don't understand that error.
12:46:01 <rwbarton> another build-type: Custom package has the same issue
12:46:28 <rwbarton> it's quite annoying because it means I can't automatically install these libraries as dependencies of something else that has draconian upper bounds that I need to ignore with --allow-newer
12:47:40 <rwbarton> oh, oops, I see
12:47:49 --- mode: monochrom set -b *!*@APuteaux-551-1-88-250.w92-132.abo.wanadoo.fr
12:47:53 --- mode: monochrom set -o monochrom
12:47:56 <rwbarton> my cabal is built with a different ghc, and is using Cabal 1.20.0.0
12:48:18 <monochrom> that should not matter
12:48:29 <rwbarton> but maybe it somehow matters with build-type: Custom
12:48:37 <rwbarton> since --allow-newer is new in 1.20?
12:49:35 <rwbarton> I guess I should install Cabal 1.20.0.0 here
12:56:38 <monochrom> rwbarton: I just tried with cabal-install 1.20, ghc 7.6.3, Cabal 1.16, no error.
12:57:01 <monochrom> but this is linux.
12:57:31 <chrisdone> want a webcam conversation? no way. want to compile some obscure language? totally
12:57:34 <chrisdone> Linux™
12:57:43 <monochrom> oh, --alllow-newer, I haven't tried that
12:57:59 <jhance> to be fair my webcam is tested to work but for some reason all the userspace apps like skype are bugged and cant use it
12:59:14 <monochrom> I see, --allow-newer triggers the error. but what newer things is it looking it anyway?
12:59:35 <rwbarton> in this case, nothing
13:00:29 <rwbarton> I am using --allow-newer to install another package which depends on this one (and several others in the same situation)
13:01:56 <monochrom> perhaps --allow-newer=specific package names
13:02:30 <Rufflewind> is there a way to prevent quickCheck monadicIO from running 100 repeats?
13:02:46 <monochrom> ooohhh, that doesn't help
13:02:52 <Iceland_jack> Rufflewind: sure, quickCheckWith
13:03:11 <Iceland_jack> then modify the arg appropriately
13:03:49 <Iceland_jack> Rufflewind: https://hackage.haskell.org/package/QuickCheck-2.7.5/docs/Test-QuickCheck.html#t:Args
13:04:25 <Rufflewind> Ah I see
13:04:28 <Rufflewind> thanks
13:23:45 <jle`> where should my --prefix be when i'm installing the new ghc-7.8.2 if i want to use other versions too?
13:24:00 <jle`> i remember setting it as something special when i did the ghc-7.8.0 prerelease
13:24:08 <jle`> s/installing/configuring
13:26:02 <monochrom> ./configure --prefix=/usr/local/ghc-7.8.2
13:26:19 <monochrom> this is before "make install"
13:27:34 <jle`> thank you
13:27:36 <jle`> monochrom
13:28:47 <jle`> hm
13:28:59 <jle`> /usr/local seems to be a su-protected directory
13:29:06 <jle`> i shoudn't be sudo making install, should i?
13:29:34 <dfeuer> Is there a way to install the arithmoi package on Fedora using yum, or must I resort to cabal-install?
13:29:55 <flux> either you do sudo make install or you configure the prefix to be under some your own home directory, in which case you won't need sudo
13:30:22 <jle`> is it bad to sudo make install?
13:30:35 <jle`> or is it normal
13:30:46 <dfeuer> jle`, it's the only way to install something system-wide.
13:30:52 <jle`> hm
13:30:53 <dfeuer> If you don't need to do that, then ... don't.
13:31:29 <spion> are there examples that make use of the psi combinator other than sortBy?
13:31:40 <jle`> oh i installed 7.8.0 on my own local
13:31:43 <jle`> hm.
13:35:08 <stolaruk> How can I use an "ANN" annotation that contains a string when I'm also using "OverloadedStrings"?
13:35:38 <stolaruk> I'm getting: No instance for (Data.String.IsString a0) arising from the literal `"HLint: ignore Use camelCase"'
13:36:10 <quchen> Code?
13:36:13 <rwbarton> add a :: String I guess? funny problem
13:36:34 <jhance> Explicitly type it
13:37:05 <gilligan-> Is there a somewhat sane programmatic way to get the path where hoogle stores its databases (by default they are stored in ~/.cabal/share/[ghc-version]/[hoogle-version]/databases  ? I'm looking at the hoogle sources right now but I am lost
13:37:14 <stolaruk> quchen: {-# ANN module "HLint: ignore Use camelCase" #-}
13:38:05 <supki> stolaruk: {-# ANN module ("HLint: ignore Use camelCase" :: String) #-}
13:38:49 <stolaruk> supki: Was just trying to figure out how to do that. It works! Thanks everyone
13:42:15 <benzrf> ANN?
13:42:30 <benzrf> i should write a PR for lambdabot to add :i
13:42:41 <benzrf> but i am not sure how to go about parsing its output =.=
13:42:56 <benzrf> it tends to be more complicated and varying than :t or :k
13:47:57 <octopuscabbage> how do i get an integer from standard input?
13:48:40 <jhance> octopuscabbage: read <$> readLine
13:48:49 <Iceland_jack> octopuscabbage: readLn
13:49:01 <jhance> octopuscabbage: Err yea read <$> readLn. My bad
13:49:07 <jhance> Oh wait
13:49:11 <jhance> is readLn = read . getLine?
13:49:15 <jhance> I always forget all the IO function names
13:49:15 <Iceland_jack> yes
13:49:31 <Iceland_jack> octopuscabbage: You can simply do
13:49:31 <Iceland_jack>     n <- readLn :: IO Int
13:49:43 <jhance> @src readLn
13:49:43 <lambdabot> readLn =  do l <- getLine; r <- readIO l; return r
13:49:43 <Iceland_jack> or
13:49:44 <Iceland_jack>     n :: Int <- readLn
13:49:44 <Iceland_jack> if you have ScopedTypeVariables enabled
13:50:12 <jhance> n <- readLn is sufficient if you are using it as an Int somewhere
13:51:01 <dfeuer> Note: you should always have ScopedTypeVariables enabled--they're an Obviously Good Thing.
13:51:49 <jle`> what is readIO ?
13:51:59 <jhance> I imagine it errors differently than read
13:52:01 <jhance> @src readIO
13:52:01 <lambdabot> Source not found. You type like i drive.
13:52:11 <jle`> also what is up with lambdabot's src of readLn
13:53:16 <jhance> jle`: you don't do r <- exp; return r all the time?
13:53:36 <monochrom> oh, hehe
13:53:56 <jle`> readIO =<< getLine
13:53:59 <jle`> hm
13:54:02 <jle`> no i'd do
13:54:10 <jle`> do { x <- readIO =<< getLine; return x }
13:54:30 <Iceland_jack> why
13:54:30 <Iceland_jack>     x <- f; return x
13:54:30 <Iceland_jack> ?
13:54:31 <octopuscabbage> can i define a custom type to be equal to a char literal?
13:54:45 <jle`> Iceland_jack: referring to lambdabot's readLn src and jhance's comment
13:54:46 <jhance> We are amused at the fact that lambdabot uses that pattern
13:54:53 <Iceland_jack> right
13:54:55 <Iceland_jack> octopuscabbage: do you mean overloading type literals
13:55:00 <jhance> octopuscabbage: type T = Char
13:55:29 <Iceland_jack> jhance: not a custom type though, just a synonym
13:55:42 <Iceland_jack> but possibly close enough to what octopuscabbage wants
13:55:46 <monochrom> I don't understand the question. do you understand it?
13:55:49 <jhance> Iceland_jack: I assumed he wanted a synonym since he wanted it to be equal
13:55:50 <Iceland_jack> either that or
13:55:51 <Iceland_jack>     newtype MyChar = MyChar Char
13:56:14 <Iceland_jack> they said equal to a 'char literal' which made it sound like they might want overloaded characters
13:56:27 <Iceland_jack> other than that they're not going to make a bespoke type that's equal to something of type Char
13:56:34 <jhance> The first thing I thought was that he wanted to promote characters to type level
13:56:42 <Iceland_jack> interesting though :)
13:56:52 <Rufflewind> how do I get QuickCheck to exit the program if a Property fails?  seems that if I use mustSucceed QuickCheck just catches the exception and moves on
13:57:11 <Rufflewind> ** not "mustSucced" I meant to say "whenFail"
13:57:53 <Ankhers> Which would be considered correct, to put your module declaration above or below any language extensions?
13:58:12 <Iceland_jack> Ankhers: after language pragmas
13:58:25 <Ankhers> Iceland_jack: Thanks!
13:59:50 <pchiusano> is it possible to hide the constructor, but not the pattern, for a data type?
13:59:57 <monochrom> no
14:00:07 <Iceland_jack> pchiusano: you can create a pattern synonym and export that
14:00:16 <monochrom> oh, that's neat
14:00:22 <pchiusano> Iceland_jack: how?
14:00:34 <Iceland_jack> module Foo (pattern Bar)  where ..
14:00:38 <timthelion> Has there ever been a project to create wikified software that anyone can edit?
14:00:58 <pchiusano> just to clarify, I have say data Blah = Foo Int | Bar, and I want to allow users of my module to pattern match on Foo, but not call the Foo constructor directly
14:01:31 <pchiusano> where Foo is assumed to have some smart constructor that I export
14:02:05 <Iceland_jack> pchiusano: sure
14:02:28 <asfp> Any advice on selecting between using the Failure typeclass vs EitherT for error handling?
14:02:28 <Iceland_jack> then you do
14:02:28 <Iceland_jack>     module BlahMod (pattern Foo, fooSmartConstructor, ...) where
14:03:37 <jle`> is anyone else having trouble installing the latest pandoc with the latest ghc?
14:04:09 <pchiusano> Iceland_jack: perfect... does this require a recent GHC?
14:04:16 <Iceland_jack> Yes, 7.8
14:04:19 <rwbarton> Iceland_jack: then the pattern is bidirectional though
14:04:34 <rwbarton> so I think you will have to make up a unidirectional synonym
14:04:39 <rwbarton> and export that instead
14:04:39 <pchiusano> rwbarton: oh?
14:04:47 <pchiusano> okay, how do I do that
14:04:49 <Iceland_jack> why do you sa that?
14:04:53 <rwbarton> because I tried it
14:05:02 <Iceland_jack> Well I also tried it and it works
14:05:10 <rwbarton> did you try calling the constructor?
14:05:32 <Iceland_jack> Hm yes you're right, my bad
14:05:40 <thoughtpolice> constructors themselves will be implicitly bidirectional, IIRC. so yes, i believe rwbarton is right, you need a unidirectional synonym
14:05:54 <rwbarton> I think it is still possible but I don't remember the syntax off-hand
14:06:03 <Iceland_jack> it is
14:06:04 <Iceland_jack>     pattern Foo a <- Fooð a
14:06:05 <Iceland_jack> oops
14:06:08 <Iceland_jack>     pattern Foo' a <- Foo a
14:06:22 <Iceland_jack> pchiusano: so try that, and export: pattern Foo'
14:06:42 <pchiusano> okay, cool
14:07:05 <Iceland_jack> I tried that with exporting only
14:07:05 <Iceland_jack>     pattern Foo', smartFoo
14:07:05 <Iceland_jack> where
14:07:05 <Iceland_jack>     smartFoo = Foo
14:07:07 <Iceland_jack> and it works
14:07:33 <rwbarton> yep, though now your client needs to enable PatternSignatures too
14:07:38 <pchiusano> related question, is there a way in module exports that I can just exclude functions I want private
14:07:51 <Iceland_jack> rwbarton: I suppose you could export a destructor function as well
14:08:02 <Iceland_jack> and possibly use ViewPatterns
14:08:17 <pchiusano> i have a module with like 25 things in it, all of which I want public, except for one constructor
14:08:20 <benzrf> i do not believe so pchiusano
14:08:22 <Iceland_jack> sadly no
14:08:33 <benzrf> pchiusano: hmmm
14:08:37 <benzrf> pchiusano: maybe you could
14:08:38 <octopuscabbage> pchiusano: is it only used in one place? if so you could make it local to that one place
14:08:50 <benzrf> define your module with all exported
14:08:55 <benzrf> then import hiding in another wrapper module
14:09:00 <benzrf> and only expose the latter
14:09:15 <benzrf> auto reexports by default right
14:09:30 <pchiusano> hmm, kind of kludgy but ok
14:09:35 <rwbarton> no but you can write module Foo (module Foo') where import Foo' hiding (...); ...
14:09:50 <jhance> pchiusano: That kind of pattern also helps you test stuff that you wouldn't normally export
14:10:03 <jhance> pchiusano: (something I haven't found a particularly good way to do)
14:12:09 <rwbarton> pchiusano: if you're trying to do a smart constructor thing then perhaps you could isolate that constructor to its own module
14:12:47 <rwbarton> like if you want data Blah = Foo Int | Bar but the Int has to be positive, then data Blah = Foo PositiveInt | Bar and in a separate module newtype PositiveInt = PositiveInt Int (constructor not exported)
14:13:14 <benzrf> rwbarton: oh hey i didnt know u could do that!
14:13:15 <benzrf> :-O
14:13:31 <rwbarton> if your smart constructor is more complicated (e.g. depends on the rest of your module) that might not work though
14:14:22 <pchiusano> rwbarton: that makes sense
14:15:34 <pchiusano> okay, I can work with one of these, thanks for the help
14:31:33 <benzrf> pchiusano: no problem m8 B-)
14:42:00 <riceandbeans> haskell is hard
14:42:17 <riceandbeans> but I recently found a giant app written in haskell that is really cool, called ganeti
14:46:28 <monochrom> sigh. in java, I have the temptation to write "public class F where" instead of "public class F {". :)
14:46:37 <benzrf> monochrom: he he he
14:46:45 <benzrf> why are you writing java anyway?
14:46:49 <monochrom> and I think, in haskell, I have the temptation to write "class F {"
14:46:57 <Iceland_jack> why wouldn't they be writing Java
14:47:11 <benzrf> Iceland_jack: because it is an irritating language
14:47:25 <Iceland_jack> okay
14:47:31 <riceandbeans> I hate java
14:47:36 <monochrom> I am teaching students who have seen python and java, but haven't seen haskell. the choice is obvious. :)
14:47:42 <riceandbeans> I wish java and the jvm would go away
14:47:46 <benzrf> riceandbeans: oh?
14:47:51 <benzrf> i thought the jvm was handy or somethinng
14:48:08 <riceandbeans> I'm not a fan
14:48:23 <genisage> Isn't python the better choice in that case?
14:48:43 <hpc> python is an awful teaching language
14:48:47 <joelteon> python is very rarely the better choice for anything
14:48:48 <riceandbeans> genisage: I would say so...but I'm not a fan of either
14:48:51 <benzrf> hpc: python is a pretty cool guy
14:48:52 <hpc> it's picky in exactly the wrong places
14:48:56 <benzrf> hpc: how so
14:48:57 <hpc> and permissive in exactly the wrong places
14:49:09 <riceandbeans> I think ruby/perl would be better
14:49:11 <riceandbeans> C even better
14:49:14 <Iceland_jack> Take it to -offtopic maybe
14:49:14 <benzrf> riceandbeans: wot
14:49:18 <monochrom> java works great for this course actually. I get to impose "public class<T> XXX { public void add(T x)" and you know what, this completely bans downcasting. this is already infinitely better than python. I mean, java has enough of parametric polymorphism for me.
14:49:21 <benzrf> Iceland_jack: do u mean -blah
14:49:23 <Iceland_jack> sure
14:49:25 <hpc> and yeah, this is a -blah topic
14:50:31 <asfp> I'm looking for an opinion on the failure vs the errors packages.  Which one is a better way of handling errors?
14:50:40 <monochrom> binary search tree is "public class AVLSet<T extends Comparable<T>> { ..." so this is close enough to haskell's "Ord t". and no upcasting and downcasting with Object. it's as good as it gets.
14:51:39 <monochrom> my only regret is lack of sum types so I can't pull off a "Maybe<T> lookup(...)"
14:52:07 <asfp> monochrom: isn't that like using core without typeclasses to teach typeclasses?
14:53:10 <monochrom> I don't understand the question.
14:58:19 <chrisdone> bitemyapp: is there an irc channel for this hangout?
14:58:30 <chrisdone> bitemyapp: the chat is kind of lame
15:00:13 <chrisdone> bitemyapp: weirdly the audio is pretty tinny, can't really understand it
15:01:57 <octopuscabbage> what's the function to append somethign to the end of a list
15:02:54 <asfp> monochrom: I mean you are using a language with subtyping and you want a language without subtyping so you come up with some fancy but quite confusing generics type signatures to disable a core OO idea.
15:03:07 <cow_2001> octopuscabbage: [a] ++ [b] ?
15:04:51 <cow_2001> octopuscabbage: appendToEnd :: [a] -> a -> [a]; appendToEnd xs y = xs ++ [y]
15:05:38 <Iceland_jack>     appendToEnd = snoc
15:05:41 <monochrom> I am disabling something. I am not convinced that it is a core OO idea.
15:05:56 <cow_2001> Iceland_jack: woah
15:06:08 <Iceland_jack> > reverse "cons"
15:06:09 <lambdabot>  "snoc"
15:06:18 <cow_2001> oh
15:07:30 <cow_2001> isn't it snoc xs y = reverse $ y : reverse xs
15:07:55 <cow_2001> such reverse
15:08:13 <cow_2001> much inefficience
15:08:26 <Iceland_jack> cow_2001: you can do that with the lens iso :)
15:08:35 <cow_2001> holy
15:08:39 <Iceland_jack> nicer way to write inefficient code
15:08:43 <cow_2001> what are lenses even O_O
15:09:18 <Iceland_jack> > "abcd" & reversed %~ ('A':)
15:09:22 <lambdabot>  "abcdA"
15:11:21 * hackagebot foreign-store 0.1 - Store a stable pointer in a foreign context to be retrieved later. Persists through GHCi reloads.  http://hackage.haskell.org/package/foreign-store-0.1 (ChrisDone)
15:13:23 <kclark> i'm working through the Lipovaca book and the sig "elem' :: (Eq a) => a -> [a] -> Bool" -- what is the difference b/w "=>" and "->"?
15:13:46 <Iceland_jack> kclark: The thing before => describes constraints
15:13:53 <Iceland_jack> you should read the chapter in LYAH about that
15:13:56 <Iceland_jack> quite important
15:14:09 <Iceland_jack> @google LYAH "type classes"
15:14:10 <lambdabot> http://learnyouahaskell.com/types-and-typeclasses
15:14:10 <lambdabot> Title: Types and Typeclasses - Learn You a Haskell for Great Good!
15:15:25 <kclark> so, go back and re-read that chapter i obviously didn't understand!  thanks!
15:16:09 <Iceland_jack> kclark: in short it just means that 'a' can be any type, as long as it can be compared for equality
15:16:40 <Iceland_jack> if you have (Eq a => ...) in your type signature you can use (==) and (/=) on those types
15:17:39 <bitemyapp> chrisdone: not aware of a channel, sorry.
15:18:09 <octopuscabbage> how do you define show on a record?
15:18:13 <octopuscabbage> or does it already have one?
15:18:25 <Iceland_jack> octopuscabbage: exactly the same as you would for a normal data type
15:18:42 <Iceland_jack> you can use 'deriving Show' or you can define it yourself
15:18:44 <octopuscabbage> oh yeah i forgot it's a type
15:18:50 <octopuscabbage> thanks
15:18:58 <octopuscabbage> wait
15:19:00 <octopuscabbage> deriving show?
15:19:03 <Iceland_jack> yes
15:19:05 <benzrf> hmmm
15:19:17 <octopuscabbage> does that make it's own print function?
15:19:18 <benzrf> how does DataKinds work
15:19:22 <soso> fack you
15:19:27 <soso> hahahahah'
15:19:29 <benzrf> octopuscabbage: print works in terms of the Show class
15:19:31 <Iceland_jack> octopuscabbage: not really, print uses show thuogh
15:19:32 <octopuscabbage> err own 'show' function
15:19:33 <Iceland_jack> @src print
15:19:33 <lambdabot> print x = putStrLn (show x)
15:19:35 <benzrf> octopuscabbage: but there's only one print
15:19:40 <Iceland_jack> octopuscabbage: you can think of it like that
15:19:52 <octopuscabbage> then how do i define how show works on it? does deriving show handle that automatically?
15:20:00 <Iceland_jack> benzrf: basically allows you to lift data constructors and types into the type and kind level
15:20:06 <Iceland_jack> octopuscabbage: it does
15:20:21 <benzrf> eeh
15:20:28 <Iceland_jack> you can define it yourself using
15:20:28 <Iceland_jack>     instance Show MyRecord where
15:20:28 <Iceland_jack>         show (MkRec a b c) = ...
15:20:33 <benzrf> sounds potentially mindbending p:
15:20:42 <octopuscabbage> ohhhhh i see now thanks
15:20:50 <soso> add my skype mob3334
15:20:50 <octopuscabbage> so if you do deriving it will automatically make it an instance of that?
15:20:53 <benzrf> are there GADKs?
15:21:00 <Iceland_jack> no
15:21:06 <byorgey> benzrf: not quite yet
15:34:25 <xeno_> so, what's wrong with http://pastebin.com/piApuY04 ? should be a simple question, given that I'm a total n00b
15:36:32 <riceandbeans> what's the biggest project any of you ever did in haskell?
15:36:45 <AlainODea> xeno_: missing | in the closing |] possibly.  I'm not well-versed in template haskell
15:37:46 <geekosaur> I see a hanging " in there, as does pastebin (ick) highlighting
15:38:33 <AlainODea> riceandbeans: TLS implementation for AMQP library.  It's not very big but it's a good value to weight ratio.  I mostly do many small tactical things
15:39:07 * benzrf sees an evangelization opportunity!
15:39:15 <benzrf> YO ALAIN HAVE YOU SEEN ZEROMQ
15:39:39 <AlainODea> benzrf: I have.  I want to be there already.  Learning it gradually
15:39:47 <benzrf> o cool
15:39:51 <riceandbeans> AlainODea: trying to think of a reason to push myself to learn me a haskell for great good
15:40:01 <benzrf> riceandbeans: what langs u know already?
15:40:27 <riceandbeans> benzrf: ruby, perl, python, some c, php
15:40:38 <riceandbeans> shell, if that counts
15:40:46 <AlainODea> riceandbeans: my biggest reason for Haskell: I don't like wasting my brain carrying around a type system when the language can do it so I can focus on real problems
15:40:57 <benzrf> riceandbeans: which of those do you know super well and not just a little of?
15:41:08 <riceandbeans> benzrf: I know ruby/perl the best of those
15:41:21 <riceandbeans> I probably know perl best, then ruby
15:41:29 <d3lxa> in xmonad is there mkXPrompt whose display and internal values can be specified instead of only String?
15:41:29 <benzrf> ok cool
15:41:37 <benzrf> riceandbeans: learn haskell its p great B-)
15:41:50 <riceandbeans> ulch
15:41:50 <benzrf> ruby & haskell are my #1 languages atm
15:41:57 <riceandbeans> I tried xmonad, couldn't do it
15:42:04 <riceandbeans> just too minimal
15:42:12 <riceandbeans> openbox is about as minimal as I go
15:42:30 <riceandbeans> I can't think of anything to do with haskell
15:42:39 <riceandbeans> all my current coding ideas I'm going to use ruby for
15:44:08 <AlainODea> riceandbeans: Haskell gives you the DRY aspects of Ruby and Perl while also giving you tests and defensive code directly and concisely via types
15:44:35 <riceandbeans> you say test, I think rspec
15:44:48 <k00mi> d3lxa: try #xmonad
15:45:00 <d3lxa> k00mi: ok, thx :)
15:51:53 <asfp> monochrom: subtyping is a core OO idea.  http://www.informs-sim.org/wsc68papers/1968_0007.pdf  <-- Introducing Simula 67.  See the example of an order, batch order, single order, and plate form a class hierarchy.
15:54:20 <benzrf> asfp: dont be absurd
15:54:29 <benzrf> asfp: oo = state + behavior packaged
15:55:14 <asfp> benzrf:?
15:55:28 <Iceland_jack> If you have a singular definition of OO it's not :)
15:56:21 <asfp> benzrf: the substitution principle is core OO, the idea that you can create a subclass which can be substituted for its parent class and is a subtype.
15:57:03 <benzrf> no, that's core java
15:57:06 <levi> "X is core OO" will almost always be challenged by some OO programmer for any value of X.
15:57:22 <asfp> benzrf: I just gave a reference to Simula 67 where this is presented.
15:57:28 <[swift]> asfp: you're actually hitting on a pretty old debate which has continued to rage for a long time because reasonable people disagree
15:57:34 <julianb> ls
15:57:39 <pjdelport> Object-oriented programming is programming based around objections?
15:58:04 <ReinH> Can we maybe not call people "absurd" when they present a reasoned argument and cite sources?
15:58:07 <[swift]> pjdelport: objection-based programming sounds great for law-related applications =)
15:59:00 <pjdelport> "A survey by Deborah J. Armstrong of nearly 40 years of computing literature identified a number of fundamental concepts, found in the large majority of definitions of OOP."
15:59:24 <[swift]> asfp: an alan kay quote on the matter: "OOP to me means only messaging, local retention and protection and hiding of state-process, and extreme late-binding of all things."
15:59:32 <pjdelport> Armstrong, _The Quarks of Object-Oriented Development_. In descending order of popularity, the "quarks" are: Inheritance, Object, Class, Encapsulation, Method, Message Passing, Polymorphism, Abstraction
15:59:41 <pjdelport> There you have it, according to the literature.
15:59:49 <[swift]> asfp: of course smalltalk *does* have inheritance, and many OO languages do not practice messaging or extreme late binding of all things
15:59:59 <asfp> benzrf: actually in this case it doesn't matter whether it's a core Java idea or a core OO idea, because my comment to monochrom was that disabling subtyping in java to emulate a language with no subtyping is suboptimal.
16:00:12 <pjdelport> (The main takeaway being that it's so messy that it took a survey of half a century of literature to get to that.)
16:00:20 <monochrom> hmm, you are still arguing this? :)
16:00:43 <Iceland_jack> I go to #haskell to argue about the definition of OO :)
16:00:51 <asfp> [swift]: I live in Europe, so I reject smalltalk. :-)
16:01:07 <monochrom> downcasting is not a core subtyping idea IMO
16:01:14 <[swift]> asfp: that i can't argue with =)
16:01:22 <monochrom> and I am merely disabling downcasting, really.
16:01:55 <monochrom> it is also easy to fix up my statements by "I'm disabling bad ideas".
16:02:42 <monochrom> then we need not argue whether bad ideas are core world-domination ideas or core world-destruction ideas.
16:32:20 <snizzo> in an function definition like this: [a+b | (a,b) <- xs]
16:32:33 <snizzo> the pipe what means? "Such as"?
16:32:59 <Nik05> its not a function definition its a list comprehension
16:33:19 <snizzo> oh yes, my bad
16:34:13 <snizzo> g1 z xs = [x|x<-xs, x!=z, y<-xs, y==x]
16:34:27 <snizzo> I'm trying to understand  this one
16:35:25 <snizzo> especially x|x<-xs
16:35:29 <Nik05> no idea what name it has
16:35:50 <Nik05> its comparable with set build notation in mathematics
16:36:17 <jaco60> snizzo : x, such x is drawn for xs ?
16:36:27 <jaco60> s/for/from
16:36:47 <snizzo> jaco60: ok. and same with y then?
16:36:54 <keko_> the left side of the pipe is what will go on the result list
16:36:55 <jaco60> yes
16:37:01 <Nik05> well it means you have a list with element x, x drawn from xs, x not z, y drawn from xs and y equal to x
16:37:33 <Nik05> x not z and y equal to x are predicates
16:37:41 <keko_> > [x + y | x <- [1, 2], y <- [10, 20]]
16:37:43 <lambdabot>  [11,21,12,22]
16:38:12 <snizzo> ahh
16:38:48 <snizzo> so every element is checked both for x not z and y equals x, right?
16:39:24 <Nik05> yes for all x in the list those predicates must hold
16:39:37 <jaco60> but != should be /=
16:39:57 <snizzo> ok, yep right :)
16:40:11 <Nik05> lets alias that...
16:41:19 <tristanStrange> hey all. anyone know how to make Gloss not redraw the background colour between frames?
16:41:25 <tristanStrange> is it even possible?
16:43:00 <phaazon> @hoogle [a] -> b
16:43:03 <lambdabot> Prelude head :: [a] -> a
16:43:03 <lambdabot> Data.List head :: [a] -> a
16:43:03 <lambdabot> Prelude last :: [a] -> a
16:51:15 <dwcook> tristanStrange: I don't think Gloss exposes a way to mess with that. Bug the author, perhaps, and/or send a pull request.
16:57:54 <tristanStrange> cheers dwcook
17:01:26 * hackagebot bit-array 0.1.0 - A bit array (aka bitset, bitmap, bit vector) API for numeric types  http://hackage.haskell.org/package/bit-array-0.1.0 (NikitaVolkov)
17:03:38 <benzrf> h
17:11:57 <octopuscabbage> what's the ghc command to get the c output?
17:17:01 <geekosaur> usually there isn't C output
17:17:08 <geekosaur> if you mean generated code
17:17:45 <geekosaur> I think -fvia-C is still secretly available, but you then need another option to retain the generated files --- and I don't know if anyone has tested that -fvia-C still generates valid code
17:18:04 <geekosaur> (the default is -fasm and the usual alternative is -fllvm)
17:20:49 <octopuscabbage> ah okay cool thanks that's what i was looking for
17:31:53 <octopuscabbage> how would i go about making a graph with edge weights?
17:35:14 <flazz> in ghc profile output what does the entries column mean?
17:43:01 <flazz> nm, entries in the call graph
17:52:27 <ryantrinkle> for Data.Map.mapKeysMonotonic, is it necessary that the function be monotonic over its entire domain, or only over the keys that the input map actually contains?
17:55:01 <jle`> ryantrinkle: i think the monotonic property is used to preserve the BST structure
17:55:28 <jle`> if that's it, then it should only matter that it's monotonic over the keys currently contained
17:55:40 <ryantrinkle> jle`: right, that's what i was thinking
17:55:47 <flebron> Are the theorems I get from Wadler's paper all the result of commutative squares of some natural transformations? Say, in f : [a] -> Int, is the free theorem the same as I'd get from considering f_a : []_a -> {Const Int}_a as a natural transformation between the [] and Const Int functors?
17:55:57 <ryantrinkle> and, presumably, it's not even *possible* for that function to detect nonomonotonicities outside that range
17:56:22 <ryantrinkle> so if i do Map.mapKeysMonotonic (^2), that should be fine as long as my keys are nonnegative
17:58:51 <jle`> ryantrinkle: should be.
18:00:14 <jle`> i guess as a thought experiment you could imagine wrapping your keys in a newtype wrapper
18:00:22 <jle`> and only allowing smart constructors/operations to keep the things nonnegative
18:00:33 <jle`> and so (^2) would be fine for that
18:02:20 <ryantrinkle> jle`: what i was thinking is that you can check the monotonicity over the set of keys in linear time
18:02:42 <ryantrinkle> which means that for constant-factor overhead compared with the existing function, you can have safety
18:02:45 <jle`> if the keys are sorted, yes
18:02:55 <jle`> which they are in this case
18:02:58 <ryantrinkle> right
18:03:25 <ryantrinkle> so, one could write, e.g., mapKeysMonotonicSafe :: (k -> k') -> Map k v -> Maybe (Map k' v)
18:03:32 <ryantrinkle> which would still be O(n)
18:04:06 <jle`> that sounds true to me
18:06:19 <tac_> When you have a !-style strict annotation, that just forces it to be weak-head normal form, right? Not deeply strict?
18:06:32 <hpc> tac_: yes
18:06:49 <hpc> if you need deep strictness, rnf or deepseq
18:06:56 <tac_> Just curious
18:31:32 * hackagebot ihaskell 0.4.1.0 - A Haskell backend kernel for the IPython project.  http://hackage.haskell.org/package/ihaskell-0.4.1.0 (gibiansky)
18:42:14 <GeraldCode> Hello, I am starting out with Yesod web framework..anyone have anything negative to say? warnings?
18:42:21 <GeraldCode> Havent tried snap or Haaps yet
19:16:30 <flaggy> hello. is there a function in haskell which will convert a float to a string with a certain precision? (something like "%.2f" % f in python)
19:16:51 <benbangert> flaggy: the printf?
19:17:31 <benbangert> flaggy: https://hackage.haskell.org/package/base-4.7.0.0/docs/Text-Printf.html
19:17:58 <flaggy> Hm, I thought printf would print, not convert to string
19:18:12 <flazz> flaggy: that would complicate things :)
19:18:16 <benbangert> well, it has to be converted to a string before it can print....
19:18:29 <zwer> flaggy it can do both :)
19:18:45 <flaggy> hm, I see, great, then :)
19:18:53 <zwer> result depends on the context it is used in, whether IO () or String is expected
19:19:09 <flazz> flaggy: check out the Numeric module
19:19:21 <flazz> not exactly printf but lots of number related stuff
19:26:34 <josiah14> quick question.  the operators >@> and <+> weren't covered in the LYAH book, but I see them in the XMonad source.  What do they mean?  Googling them and searching hoogle didn't turn up anything
19:27:04 <josiah14> ah, nvm, just found <+> on hoogle
19:27:09 <`erroneous> so i am confused about how to run a bunch of system commands stored in a list
19:27:37 <`erroneous> suppose i have ["echo 1", "echo 2"]
19:27:43 <`erroneous> i'd like to map system over that
19:27:58 <Iceland_jack> josiah14: <+> is just an old name for mappend, it's called <> in base
19:28:00 <Iceland_jack> :t (<>)
19:28:01 <lambdabot> Monoid m => m -> m -> m
19:28:02 <Iceland_jack> :t mappend
19:28:03 <lambdabot> Monoid a => a -> a -> a
19:28:46 <`erroneous> but trying the naive thing doesn't work ..
19:29:07 <Iceland_jack> `erroneous: you can use mapM_
19:29:10 <Lutin`> `erroneous: map it and then sequence the resulting [IO ExitCode] into one IO ExitCode
19:29:28 <Lutin`> Ah yeah forgot about that
19:29:31 <Iceland_jack> `erroneous: mapM_ is sequence . map, which Lutin` is suggesting
19:29:38 <Iceland_jack> (only forgetting the result)
19:29:43 <Iceland_jack> so sequence_ . map
19:29:44 <Iceland_jack> @src mapM_
19:29:44 <lambdabot> mapM_ f as = sequence_ (map f as)
19:29:54 <Lutin`> @src mapM
19:29:54 <lambdabot> mapM f as = sequence (map f as)
19:29:56 <`erroneous> okay i'll try mapM
19:29:57 <Lutin`> gotcha
19:29:57 <jle`> mapM_ f is sequence . map f
19:29:58 <Iceland_jack> sequence_ .: map.., sorry
19:30:04 <Lutin`> thanks Iceland_jack
19:30:04 <jle`> er, sequence_
19:30:19 <`erroneous> @Lutin` - that doesn't work - it doesn't print the output anymore
19:30:19 <lambdabot> Unknown command, try @list
19:30:20 <jle`> Lutin`: it might help to manually map and sequence it so you know what's going on
19:30:45 <`erroneous> for example: map (void $ system) ["echo 1", "echo 2"]
19:30:46 <jle`> sequence turns a list of IO actions and returns a new IO action that performs each one in the list in order and compiles the results
19:30:59 <`erroneous> in GHci results in no output, and just a list of [(), ()]
19:31:00 <Lutin`> Why void?
19:31:12 <Iceland_jack> `erroneous: Don't use void
19:31:24 <`erroneous> without void it doesn't compile :(
19:31:39 <rwbarton> that is not the right approach, slow down
19:31:46 <Iceland_jack> run: mapM system ["echo 1", "echo 2"]
19:32:00 <Iceland_jack> you should get a list of exit codes back
19:32:00 <`erroneous> ah
19:32:04 <`erroneous> indeed.
19:32:14 <`erroneous> thanks Iceland_jack
19:32:18 <Iceland_jack> Don't just insert arbitrary functions to get it to compile :)
19:32:24 <Lutin`> :P
19:32:33 <`erroneous> okay, my bad :)
19:32:35 <`erroneous> thanks!
19:32:38 <Welkin> haskell ain't javascript
19:33:14 <Iceland_jack> Yes I hate trying to satisfy Javascript's typecheck.. wait
19:34:01 <`erroneous> it'd be nice to understand why void $ system doesn't work over the list, then it works over a single item: void $ system "echo 1", say
19:34:11 <Iceland_jack> because they're not the same
19:34:23 <Iceland_jack> You can do
19:34:23 <Iceland_jack>     mapM (void . system)
19:34:25 <jle`> it's not (void $ system) "echo 1"
19:34:38 <jle`> f $ g x is not (f $ g) x
19:34:50 <jle`> this is one of the reasons why $ considered harmful
19:34:52 <`erroneous> what's not the same? why doesn't it work to map that function that works on single strings into a list of strings?
19:34:52 <Iceland_jack> `erroneous: but if you want to ignore the resulting exit code, void is not the way to do that
19:34:53 <jle`> (...by me)
19:35:00 <`erroneous> ah
19:35:09 <Iceland_jack> I just think $ is ugly
19:35:26 <jle`> yeah, same here
19:35:28 <rwbarton> function application always binds tighest
19:35:31 <Iceland_jack> If you want to ignore the outputs use mapM_
19:35:32 <Iceland_jack> ghci> mapM_ system ["echo 1", "echo 2"]
19:35:32 <Iceland_jack> 1
19:35:32 <Iceland_jack> 2
19:36:11 <jle`> f $ g x is f (g x) is (f . g) x
19:36:21 <`erroneous> awesome
19:36:32 <Maxdamantus> f $ g x is f (g x) is true
19:37:00 <josiah14> (<+>)
19:37:07 <Lutin`> void $ system uses the functor instance of functions and just gives you a function returning () doesn't it?
19:37:15 <josiah14> :t (<+>)
19:37:16 <lambdabot>     Ambiguous occurrence ‘<+>’
19:37:16 <lambdabot>     It could refer to either ‘Control.Arrow.<+>’,
19:37:16 <lambdabot>                              imported from ‘Control.Arrow’ at /home/lambda/.lambdabot/State/L.hs:36:1-20
19:37:18 <josiah14> hmm
19:37:19 <rwbarton> Lutin`: yes
19:37:31 <Lutin`> k
19:37:37 <Iceland_jack> @src void
19:37:37 <lambdabot> Source not found. Maybe you made a typo?
19:37:39 <josiah14> that's what I thought. it doesn't seem to be the same as <>
19:37:42 <jle`> Lutin`: um
19:37:44 <Iceland_jack> basically fmap (const ())
19:37:46 <jle`> no
19:37:54 <jle`> right?
19:38:00 <octopuscabbage> how do i bind the a tuple to two variables
19:38:03 <jle`> void $ system...ther eis nothing functory going on here
19:38:14 <octopuscabbage> for example x,y = (1,2)
19:38:15 <Iceland_jack> jle`: why do you say that?
19:38:20 <Lutin`> void is in Control.Monad.void
19:38:23 <Lutin`> void :: Functor f => f a -> f ()
19:38:23 <flazz> octopuscabbage: let (x,y) = (1,2)
19:38:25 <Lutin`> void = fmap (const ())
19:38:27 <josiah14> :t (>@>)
19:38:28 <lambdabot>     Not in scope: ‘>@>’
19:38:28 <lambdabot>     Perhaps you meant one of these:
19:38:28 <lambdabot>       ‘>>’ (imported from Control.Monad.Writer),
19:38:35 <Lutin`> unless you mean the void in Foreign something
19:38:52 <Iceland_jack> ‘void’ certainly requires a Functor because it uses fmap
19:38:54 <jle`> oh
19:38:56 <josiah14> that's intriguing, >@> is mentioned as an operator on Monads, but I can't find it anywhere
19:38:58 <Lutin`> But that one's deprecated
19:39:06 <jle`> yeah, sorry
19:39:19 <jle`> mixed something up in my head
19:39:26 <josiah14> (>@> is for object composition???)
19:39:35 <jle`> apologies
19:39:45 <Lutin`> no worries
19:39:46 <Iceland_jack> jle`: no problem yo :)
19:39:49 <pjdelport> josiah14: not >=> perhaps?
19:39:55 <Lutin`> we all do it haha
19:40:04 <pjdelport> :t (>=>)
19:40:05 <lambdabot> Monad m => (a -> m b) -> (b -> m c) -> a -> m c
19:40:10 <jle`> writing void $ system confused me
19:40:11 <Iceland_jack> josiah14's problems are one of the reasons why I dislike people defining their own operators
19:40:18 <jle`> because i thought you were referring to the ($)
19:40:25 <jle`> why write void $ system when you can write void system >_>
19:40:37 <rwbarton> jle`, because you're confused
19:41:00 <rwbarton> (not you, the hypothetical writer)
19:41:12 <Lutin`> We were commenting on why `erroneous's used of (void $ system) was not the same as (void . system)
19:41:19 <jle`> ah
19:41:22 <jle`> yes
19:41:23 <Lutin`> I just used $ because that's what he used
19:41:24 <jle`> all is clear
19:41:28 <Lutin`> np
19:41:36 * jle` experiences enlightenment
19:41:44 <josiah14> pjdelport: perhaps, I don't see it listed here: https://github.com/josiah14/haskline.git
19:41:47 <josiah14> oops
19:41:56 <josiah14> ignore that - unstarted project anyway
19:42:12 <josiah14> http://www.imada.sdu.dk/~rolf/Edu/DM22/F06/haskell-operatorer.pdf
19:42:33 <josiah14> having trouble switching between mac and linux keybindings
19:42:45 <pjdelport> josiah14: That looks like a (weird?) typo.
19:43:14 <josiah14> glad I'm not the only one that found that strange
19:43:34 <Lutin`> Pretty sure they meant (>=>) since that's monad composition
19:43:37 <josiah14> so <+> is old syntax for mapply??? but I found that operator in the Arrow type...
19:43:47 <Iceland_jack> josiah14: mappend
19:43:50 <josiah14> how should I interpret that in the XMonad source, then?
19:44:03 <Iceland_jack> josiah14: they're probably using it for a slightly tricky monoid instance, over functions
19:44:35 <jle`> :t (>@>)
19:44:36 <lambdabot>     Not in scope: ‘>@>’
19:44:36 <lambdabot>     Perhaps you meant one of these:
19:44:36 <lambdabot>       ‘>>’ (imported from Control.Monad.Writer),
19:44:47 <Iceland_jack> I'm guessing something like
19:44:47 <Iceland_jack>     Monoid m => Monoid (a -> m)
19:44:47 <Lutin`> <+> in XMonad is infix mappend
19:44:56 <Lutin`> http://hackage.haskell.org/package/xmonad-0.11/docs/XMonad-ManageHook.html#v:-60--43--62-
19:45:04 <Iceland_jack> I believe it's been mentioned three times now :)
19:45:20 <Lutin`> It's for composing ManageHooks
19:45:40 <josiah14> ick
19:45:45 <Iceland_jack> I'm talking over other people, should pack and get to bed
19:46:01 <Lutin`> Iceland_jack: np I was just giving the specific source
19:46:23 <Iceland_jack> Lutin`: no problem :) it's just 2:45 and I have a thing tomorrow
19:46:42 <josiah14> I don't necessarily like that now that <+> is part of the Arrow type http://hackage.haskell.org/package/base-4.7.0.0/docs/Control-Arrow.html#v:-60--43--62-
19:47:11 <Iceland_jack> josiah14: Part of the type?
19:47:24 <Iceland_jack> It's just a method of ArrowPlus
19:48:10 <josiah14> ahh, I'm seeing it now
19:49:14 <josiah14> sorry, this is my first time looking at Arrow and ArrowPlus.  Just realized they are Monoids, in which case <+> is probably mappend, but I need to think a bit more about it to be sure
19:50:37 <Iceland_jack> josiah14: If it's for ManageHooks it's using this Monoid instance
19:50:37 <Iceland_jack> > (concat <> concat) ["hello", "world"]
19:50:38 <lambdabot>  "helloworldhelloworld"
19:50:51 <Iceland_jack> > (head <> concat <> last) ["hello", "world"]
19:50:53 <lambdabot>  "hellohelloworldworld"
19:51:12 <rwbarton> did you find >@> in a real program?
19:51:36 <josiah14> no, that was just something I bumped into searching around for info on <+>
19:51:46 <rwbarton> oh ok
19:52:00 <josiah14> I just finished LYAH, so I am still at the 'dunno what I dunno' stage
19:52:52 <josiah14> figure reading source and asking questions is the fast track to knowledge
19:52:59 <Iceland_jack> good plan
19:53:20 <Iceland_jack> Although I don't think XMonad's source is the most legible there is
19:53:32 <rwbarton> it's also quite old at this point
19:55:04 <josiah14> what about Yi?
19:55:36 <Iceland_jack> josiah14: have you checked out Simon Marlow's book
19:55:54 <Iceland_jack> @google Parallel and Concurrent Haskell
19:55:55 <lambdabot> http://chimera.labs.oreilly.com/books/1230000000929
19:55:55 <lambdabot> Title: Parallel and Concurrent Programming in Haskell
19:56:05 <josiah14> I downloaded it to my kindle
19:56:13 <josiah14> on my list of things to read
19:56:20 <Iceland_jack> I would recommend reading it after LYAH
19:56:38 <josiah14> Real World Haskell was before Parallel for me
19:56:46 <Iceland_jack> It's clearly written and includes nice excerpts of code
19:57:08 <josiah14> i suppose switching the priority on those books would not be a problem
19:57:23 <Iceland_jack> shows you how to build chat servers etc., I recommend it over RWH
19:57:42 <josiah14> I'm glad I bought it, then
19:57:43 <jle`> P&CH was my own path after LYAH and it served me well
19:57:47 <jle`> - jle`
19:57:58 <Iceland_jack> Ringing endorsement
19:58:03 <octopuscabbage> did you just quote yourself
19:58:21 <Iceland_jack> No harm in quoting yourself.
19:58:21 <Iceland_jack> Iceland_jack
19:58:37 <jle`> well i was writing a testimony
19:58:44 <jle`> and i wanted to give proper credit
19:58:53 <jle`> er...i was quoting a testimony
19:58:56 <Iceland_jack> I wonder why I didn't put an em dash..
19:58:58 <Iceland_jack> No harm in quoting yourself.
19:58:58 <Iceland_jack> —Iceland_jack
19:59:08 <octopuscabbage> can i give a testimony too? i've never read the book but it seems kind of cool
19:59:11 <octopuscabbage> -octopuscabbage
19:59:37 <Iceland_jack> “that octopuscabbage seems to know what's up”
19:59:37 <Iceland_jack> —random consumer
19:59:56 <octopuscabbage> ya'll wanna write a book on haskell irc and just put our own testimonies on it
20:00:26 <Iceland_jack> I might by a book whose testimonies are all by the author just for the sheer cheek of it
20:00:31 <Iceland_jack> *buy
20:20:56 <nick_named> quit
20:21:39 * hackagebot http-client 0.3.3.2 - An HTTP client engine, intended as a base layer for more user-friendly packages.  http://hackage.haskell.org/package/http-client-0.3.3.2 (MichaelSnoyman)
20:21:41 * hackagebot http-client-tls 0.2.1.2 - http-client backend using the connection package and tls library  http://hackage.haskell.org/package/http-client-tls-0.2.1.2 (MichaelSnoyman)
20:21:43 * hackagebot http-conduit 2.1.2.3 - HTTP client package with conduit interface and HTTPS support.  http://hackage.haskell.org/package/http-conduit-2.1.2.3 (MichaelSnoyman)
20:21:45 * hackagebot mono-traversable 0.6.0.3 - Type classes for mapping, folding, and traversing monomorphic containers  http://hackage.haskell.org/package/mono-traversable-0.6.0.3 (MichaelSnoyman)
21:11:42 * hackagebot Proper 0.1.0.0 - An implementation of propositional logic in Haskell  http://hackage.haskell.org/package/Proper-0.1.0.0 (dillonhuff)
21:52:39 <Total_1mmersion> > toRational pi
21:52:41 <lambdabot>  884279719003555 % 281474976710656
21:52:57 <Welkin> > phi
21:52:58 <lambdabot>  Not in scope: ‘phi’
21:52:58 <lambdabot>  Perhaps you meant ‘pi’ (imported from Prelude)
21:53:02 <Total_1mmersion> Shouldn't that be impossible?
21:55:44 <joelteon> yep, you've discovered the greatest secret of haskell
21:55:52 <joelteon> we've computed a simple rational representation of pi
21:57:39 <joelteon> Total_1mmersion: I think that's actually the rational representation of 3.141592653589793
21:58:14 <joelteon> surprisingly, pi cannot be accurately represented by a floating-point number
21:58:29 <Total_1mmersion> haha, so is it a historical mistake of some kind that toRational takes a Real argument?
21:58:44 <joelteon> > toRational 1.5
21:58:45 <lambdabot>  3 % 2
21:58:49 <joelteon> no, because that works ok
21:58:58 <joelteon> and some people do use it for that reason
22:00:47 <Total_1mmersion> I see, but I wonder if there is a way to avoid the implication that toRational can take an irrational argument.
22:01:22 <Total_1mmersion> Of course pi represented as a Double or Float is not irrational
22:01:30 <joelteon> ok, in what form would you provide pi in the standard library?
22:04:28 <Total_1mmersion> Hmm, what if there were 2 Rational typeclasses which differed by representation: one represented as a Double and the other as a ratio of two Integers?
22:05:05 <Total_1mmersion> toRational would then convert from the Double representation to the ratio
22:05:22 <Lutin`> Reals aren't reals on computers :P
22:06:09 <kazagistar> in order to calculate the circumferance of the visible universe, given its radius, to an accuracy of of 1 plank distance, you need less then 500 digits
22:06:40 <kazagistar> basically, approximations are pretty ok
22:09:51 <Total_1mmersion> I'm not saying that pi should actually be defined to exact precision since that's impossible on a machine with finite memory
22:10:28 <Total_1mmersion> I'm just contemplating what it might be like to have pi in some typeclass like Irrational
22:10:55 <Lutin`> What would you actually gain from that though?
22:10:58 <Total_1mmersion> So that toRational wouldn't imply that it could convert an irrational to a rational
22:11:26 <kazagistar> it might be more useful to have it be in a typeclass like "Approximatable"
22:11:26 <Lutin`> pi is implied to be an approximation of the true value of pi
22:11:36 <Lutin`> Yeah I like that
22:11:41 <Total_1mmersion> Yeah, what kazagistar said
22:11:45 * hackagebot Proper 0.2.0.0 - An implementation of propositional logic in Haskell  http://hackage.haskell.org/package/Proper-0.2.0.0 (dillonhuff)
22:11:50 <begriffs> Total_1mmersion: an irrational could be represented as a lazy sequence of approximations maybe, like a Dedekind cut.
22:12:33 <kazagistar> I mean, in a practical sense, you want approximations you can do something useful with, as in, add, multiple, etc
22:13:03 <kazagistar> and then, at the end you can get however many decimal points
22:13:35 <kazagistar> for implementations, see http://www.haskell.org/haskellwiki/Exact_real_arithmetic
22:13:42 <Total_1mmersion> Just out of curiosity, as I haven't done it myself, when might you want to use toRational?
22:14:53 <Lutin`> Well you could use it with pi if you wanted to leverage the improved accuracy
22:15:21 <Lutin`> Since Integers are bound by memory instead of the floating point standard
22:15:25 <jle`> Total_1mmersion: Rational arithmetic is "exact", i guess...and it doesn't fall into those weird floating point subtraction and stuff errors
22:15:59 <Total_1mmersion> Oh, so if you were doing a bunch of divisions and stuff you wouldn't lose information like you would with floating points?
22:15:59 <jle`> but usually you'd want to jump into Rational as soon as possible in that case
22:16:09 <jle`> not just divisions but subtractions too
22:16:19 <jle`> and...everyhting else
22:16:22 <jle`> heh
22:16:27 <Total_1mmersion> probably even additions and multiplications too, yeah, hah
22:16:36 <Lutin`> Like 1.1-1
22:16:43 <Lutin`> Isn't 0.1 in floating point
22:16:53 <Total_1mmersion> > 1.1-1
22:16:54 <lambdabot>  0.10000000000000009
22:17:14 <Lutin`> Because the result is irrational in binary
22:17:28 <jle`> > 1.1 - 1 :: Rational
22:17:29 <lambdabot>  1 % 10
22:17:47 <kazagistar> > 0.1
22:17:48 <lambdabot>  0.1
22:18:04 * dwcook . o O ( You lose information with rational division too – The tree of applications isn't preserved. )
22:18:17 <jle`> hm, really?
22:18:57 <Total_1mmersion> Why would the tree of applications matter?
22:19:03 <kazagistar> how would you lose information?
22:19:17 <dwcook> It was only an idle thought and is probably irrelevant, just a curiosity :P
22:19:36 <Lutin`> Just that you don't know what the numbers you had before the division were unless you had one of them
22:19:48 <dwcook> ^
22:20:10 <Lutin`> I think Total_1mmersion meant losing precision instead of information though
22:20:20 <Lutin`> hmm
22:20:27 <Lutin`> > (1.1-1)+1
22:20:28 <lambdabot>  1.1
22:20:40 <Total_1mmersion> Oh, I understand now what you meant by losing information. In that sense you lose information with addition and multiplication and subtraction too
22:20:50 <Lutin`> > 0.10000000000000009 + 1
22:20:51 <lambdabot>  1.1
22:20:54 <Lutin`> magic
22:20:58 <Total_1mmersion> And yeah I was referring to precision
22:21:09 <kazagistar> and in that sense, you lose information with integer addition, so I am not sure if it a useful sense
22:21:43 <Lutin`> It's useful but not in the sense Total_1mmersion meant
22:22:03 <kazagistar> I guess considering isomorphisms to be the only lossless operations IS useful, but yeah, different
22:24:35 <Lutin`> the loss of information comes with floating points in that there are situations where even if you had one of the numbers, you couldn't guarantee what the other one was
22:24:48 <Lutin`> Because of the machine precision
22:25:04 <Lutin`> that was a weird sentence
22:25:07 <Lutin`> I should sleep now
22:25:09 <Lutin`> night all
22:25:56 <dwcook> kazagistar: I was thinking of it compared to the free magma, but it occurred to me that division doesn't exactly form a magma with the set in question either since it's partial on that set.
22:26:32 <kazagistar> ... my limited math betrays me, I only kinda know what I am talking about
22:26:46 <jle`> night Lutin`
22:26:59 <kazagistar> until someone says something like "free magma" and the best I can do is figure out that it is something mathy :P
22:27:24 <dwcook> kazagistar: A magma is a set S together with a binary operation on that set S×S→S.
22:27:35 <Zekka> A magma's just monoid without identity
22:27:39 <Zekka> er, wait
22:27:43 <Zekka> does it rquire associativity?
22:27:46 <Lutin`> nope
22:27:47 <Zekka> I think I'm thinking semigroup, never mind
22:27:53 <dwcook> kazagistar: Are you familiar with the mathematical sense of "free"?
22:28:28 <Lutin`> kazagistar: Welcome to #haskell where if you say you don't know something, prepare to learn it :D
22:29:13 <kazagistar> dwcook: a little, but I never felt like I could... do it myself? and I still haven't grokked the free monad
22:30:05 <dwcook> kazagistar: Yeah the free monad maybe isn't as easy to understand as some of the other free structures.
22:30:22 <dwcook> kazagistar: I bet you already know all about a particular free structure and don't even know it – lists are the free monoid.
22:30:24 <kazagistar> this one makes sense though
22:30:31 <kazagistar> now that I read about what a magma is
22:30:36 <Lutin`> basically, hand me a set and I can give you a binary operation on that set that makes it a magma
22:30:44 <Lutin`> that magma is the 'free magma'
22:30:52 <Lutin`> to be rough about it
22:31:14 <Lutin`> wait I misspoke
22:31:23 <kazagistar> dwcook: when you say "free" monoid, does that mean it is unique? or isomorphic to any other free monoid?
22:31:41 <Lutin`> dwcook can explain I'm too sleepy
22:31:45 <kazagistar> er, rather
22:31:49 <kazagistar> when you say "the
22:31:57 <dwcook> Lutin`: You might be overestimating my explanatory capabilities but I will do my best :P
22:32:28 <Lutin`> hehe
22:32:59 <Lutin`> kazagistar: Basically if you give me a set of a with no other info on that a
22:33:07 <dwcook> kazagistar: Well I don't know enough to answer either of those questions, but when we talk about a free monoid we're usually talking about a way to take Set onto Monoid in such a way that only the required monoid laws are satisfied.
22:33:11 <Lutin`> I can give you a list of a
22:33:21 <dwcook> kazagistar: It's "free" because all I need is a set and I can hand you such a monoid/magma.
22:33:42 <Lutin`> Because it's the most general structure that satisfies being a monoid without putting any constraints on the underlying set it is generated from
22:34:07 <dwcook> So, let's take this to the slightly more concrete
22:34:37 <dwcook> So the free monoid I said is lists
22:35:00 <dwcook> Monoids are required to have an identity element (the empty list) and an associative operation (concatenation)
22:35:33 <dwcook> And the structure of lists satisfies those exactly without doing other weird things
22:35:40 <dwcook> Let's look at a monoid that isn't free in this sense
22:35:56 <dwcook> Addition, as implied earlier, doesn't preserve the original numbers
22:36:17 <dwcook> If I take the result of 5+8, which is 13, and ask what numbers I originally put in, I wouldn't get one answer.
22:36:28 <kazagistar> a set would require a way to compare for equality
22:36:40 <kazagistar> so that wouldnt be free either?
22:36:50 <dwcook> Actually I'm not sure that's a great way to put it
22:36:57 <dwcook> What I just said, I mena
22:36:58 <dwcook> mean*
22:37:07 <dwcook> I'm not sure what you meant, kazagistar
22:37:48 <dwcook> Here's a better way to put it. If I add 1+2+3 to get 6, from that result I can't then ask what all the numbers added together were
22:38:12 <dwcook> but if I take the list [1, 2, 3], I _can_ ask for its elements
22:38:14 <joelteon> or
22:38:26 <joelteon> if, say, you shift the number 1237 right two bits
22:39:15 <dwcook> Yeah, then you don't even have all the original digits
22:39:26 <dwcook> So with the free magma, we can try figuring out what structure that should have
22:39:33 <kazagistar> but because it is a monoid, we have to forget order, so a tree would not work as a "free" monoid, or the monoid laws (associativity) would fail
22:39:55 <dwcook> A magma is a set S together with an operation S×S→S. That's all it is.
22:40:02 <dwcook> We can't do things like reassociate the operation
22:40:11 <kazagistar> gotcha
22:40:13 <dwcook> We can't come up with a specific element
22:40:28 <joelteon> so it's mappend?
22:40:29 <kazagistar> so the free magma is a binary tree, essentially?
22:40:40 <dwcook> kazagistar: Yep! More specifically?
22:40:57 <dwcook> (Where are the elements of S in the tree?)
22:41:11 <kazagistar> at the leaves
22:41:22 <dwcook> Exactly
22:42:20 <dwcook> Now let's try this: A semigroup is like a monoid except it lacks the identity law. What is the free structure of that?
22:42:47 <Lutin`> iirc it's a complete rooted binary tree
22:42:54 <dwcook> It's got associativity
22:43:18 <Lutin`> might not need that though
22:43:31 <Lutin`> I'm referring to the magma
22:43:34 <Lutin`> not the semigroup btw
22:43:41 <dwcook> Oh woop
22:43:58 <Lutin`> I'll let kaz answer this one :P
22:44:03 <dwcook> I'm not sure what "completely rooted" means
22:44:29 <Lutin`> complete, rooted
22:44:49 <Lutin`> rooted just means you have one node you consider the root
22:44:57 <dwcook> Yes, okay, I agree with that
22:45:31 <Cale> I disagree about complete
22:45:32 <Lutin`> complete means every level but the last is completely filled
22:45:52 <Lutin`> Yeah that could be unnecessary
22:45:57 <Cale> You can have things like a*(b*(c*d))
22:46:03 <kazagistar> im thinking about it, but it is not obvious to me yet... it seems like a list, but it cannot be empty?
22:46:09 <dwcook> kazagistar: precisely!
22:46:40 <Cale> As well as (((a*b)*c)*d)*(e*f)
22:46:50 <dwcook> Lutin`: Cale: Ah, I had the wrong conception of what "complete" meant
22:47:44 <Lutin`> yeah I'm wrong about complete
22:47:48 <Lutin`> just rooted
22:48:20 <kazagistar> so ... data SemiFree a = ConsSF a (SemiFree a) | PureSF a
22:48:39 <dwcook> kazagistar: Where'd you get PureSF from?
22:48:42 <dwcook> Oh
22:48:43 <dwcook> Never mind
22:48:45 <dwcook> I misread
22:48:50 <Lutin`> single element yeah
22:48:54 <dwcook> Yes, that looks like a reasonable definition
22:50:05 <dwcook> kazagistar: If you want to see how free constructions generalize, you could ask ##categorytheory. I'm sure the people there can explain it way better than I can.
22:50:24 <Lutin`> sleep now I sweat
22:50:27 <Lutin`> swear*
22:50:28 <dwcook> kazagistar: It might tense your brain a litte bit but it's kind of fun. :)
22:50:29 <Lutin`> night
22:50:33 <dwcook> Good night Lutin`
22:51:53 * hackagebot ghc-parser 0.1.2.0 - Haskell source parser from GHC.  http://hackage.haskell.org/package/ghc-parser-0.1.2.0 (gibiansky)
22:54:39 <dwcook> kazagistar: So, you mentioned the free monad. Obviously it's a monad, but do you know what sort of structure it maps onto monads?
22:55:12 <dwcook> Also if you get tired of this discussion feel free to stop me at any time. I'm just procrastinating on bedtime :)
22:55:13 <Lutinzzz> http://programmers.stackexchange.com/questions/242795/what-is-the-free-monad-interpreter-pattern
22:55:21 <Lutinzzz> I swear I'm done
22:55:36 <dwcook> So is Lutinzzz it seems
22:56:08 <kazagistar> dwcook: my tea is boiling, but that is the part I remember... its an AST, but I dunno the details :P
22:56:17 <Lutinzzz> kazagistar: Check that SO link out
22:56:26 <Lutinzzz> helped me get a grasp on it
22:57:16 <Lutinzzz> ooh tea that's a good idea
22:57:31 <dwcook> kazagistar: You seemed to grasp intuitively that the free semigroup in Haskell was * → *. I'm basically asking you if you know what it's parameterized over.
22:57:40 <dwcook> Enjoy your tea :)
22:58:05 <dwcook> s/it's/the free monad is/
22:58:30 <Zekka> dwcook: Is the free monad (* -> *) -> (* -> *) because monads are (* -> *)?
22:58:42 <Zekka> (kind Free k = k -> k)
22:59:04 <dwcook> Zekka: yep, that's the right kind. It's actually slightly more specific though
22:59:17 <dwcook> Namely it takes types of class Functor onto Monads
22:59:32 <Zekka> Can we assume that in another type system Functors would be a more specific kind?
22:59:38 <Zekka> (because we're really dealing with sets in math?)
23:00:16 <dwcook> The general mathematical notion of free monad is sort of at the fuzzy edge of my knowledge, so I'm not sure I could say
23:02:10 <Lutinzzz> I think free monad implies free functor
23:02:52 <dwcook> Yeah, though I would hardly doubt that there's a notion of free functor that doesn't also adjoin the monad stuff
23:03:12 <dwcook> Well, I sort of doubt it. I honestly don't have the knowledge to say
23:03:21 <dwcook> A good question would be: What's the underlying structure?
23:03:54 <Lutinzzz> Bam: data Free f a = Free (f (Free f a)) | Return a
23:04:08 <Lutinzzz> sry to ruin it I couldn't help myself
23:04:12 <dwcook> Looks right to me
23:06:53 * hackagebot cryptohash 0.11.6 - collection of crypto hashes, fast, pure and practical  http://hackage.haskell.org/package/cryptohash-0.11.6 (VincentHanquez)
23:07:22 <dwcook> I think one of the cool things about these free structures, though, is that you can "interpret" them to others of the same structure
23:07:34 <dwcook> With lists this is embodied with foldr, for example
23:09:06 <dwcook> Perhaps a more obvious example is the existence of mconcat, I think it's called
23:09:07 <dwcook> @type mconcat
23:09:11 <lambdabot> Monoid a => [a] -> a
23:09:30 <tcb> Hi. I'm trying to install dbus-0.10.8.But it fails to build with "lib/DBus/Transport.hs:202:72: Not in scope: `getPeerCred'"
23:10:35 <kazagistar> I still have mixed feelings about lists
23:10:36 <jle`> tcb: is that the whole error?
23:10:49 <tcb> jle`: yes
23:10:55 <Zekka> kazagistar: What's wrong with them?
23:10:57 <Cale> kazagistar: Lists are the things you loop over, basically.
23:11:07 <Zekka> Cale: s/List/Foldable
23:11:09 <jle`> i think of lists as just finite streams
23:11:23 <jle`> i don't think of them as...any sort of container anymore
23:11:23 <Cale> You don't want to use them for other things -- if you need random access, then they're just terrible
23:11:30 <tcb> http://paste.kde.org/pmafkndhr
23:11:41 <Cale> But they're the ideal structure for iterating over
23:12:02 <kazagistar> lists are great as long as they never exist in memory and are amortized, but yeah, I would prefer if I could ensure they were linear types and such
23:12:03 <yassine> slt tt les beaux et belles
23:12:22 <kazagistar> not amortized
23:12:28 <kazagistar> I meant elided or something
23:19:49 <haasn> I seem to remember Kleisli IO being an illegal Arrow. Why is this?
23:19:55 <haasn> Which law does it violate, again?
23:21:10 <jle`> there is someone here who believes that all Kleisli violate an extend set of sensible arrow laws
23:21:51 <Cale> haasn: It violates the condition that (f >>> g) *** (h >>> k) = (f *** h) >>> (g *** k)
23:21:53 <haasn> surely not Kleisli Identity
23:22:10 <jle`> (a *** b) >>> (c *** d) should equal (a >>> c) *** (b >>> d)
23:22:13 <Cale> Yeah, only Kleisli arrows of noncommutative monads will violate that law
23:22:14 <jle`> oah was it Cale
23:22:16 <jle`> yes
23:22:29 <jle`> so noncommutative monads like State
23:22:33 <Cale> right
23:22:48 <Cale> Because the effects of g and h will occur in the opposite order
23:23:13 <jle`> and...it's not apparent when looking at "arrow diagrams" in what order the effects will occur
23:23:18 <Cale> Without that law, you don't get the nice diagram language
23:23:21 <jle`> and so arrow diagrams become a useless thing
23:23:43 <Cale> Well, you can still have diagrams, but they require boxes to explicitly express which combinators were used
23:24:01 <Cale> and it's much more difficult to think about what will happen
23:24:12 <dwcook> I wonder if this could be taken as evidence that a commutative monad class would be useful. Unfortunately all the points for I can think of are balanced by points against. (1) Arrow could use it. But Arrow is seen as a poor abstraction. (2) The "bad" ListT could use it. But that too is seen as improper.
23:24:15 <jle`> diagram analysis becomes prettier
23:24:23 <jle`> er, less pretty and more burdensome
23:24:43 <jle`> dwcook: what would a commutative monad class contain?
23:24:47 <jle`> assuming you mean typeclass
23:24:59 <Cale> jle`: The same stuff Monad does, just with an additional law
23:25:11 <dwcook> jle`: I don't imagine the compiler could check on it, so, just laws. :)
23:25:11 <jle`> and so different (>>=) and return ... ?
23:25:17 <Cale> There aren't many examples of commutative monads
23:25:20 <dwcook> Yes, one law.
23:25:34 <jle`> then you couldn't use do notation
23:25:41 <jle`> unless you meant it as a subclass of Monad
23:25:41 <Cale> You could
23:25:50 <dwcook> jle`: class (Monad m) => CommutativeMonad m
23:25:52 <dwcook> That's it
23:25:54 <Cale> yeah, you'd just have it be a subclass of Monad with no methods
23:25:57 <jle`> ah yeah
23:26:00 <jle`> that's what i was asking
23:26:02 <jle`> what would it contain
23:26:04 <jle`> ...nothing?
23:26:06 <jle`> just the extra laws?
23:26:10 <dwcook> Yep
23:26:15 <Cale> Reader e is commutative, Writer w is commutative when w is a commutative monoid
23:26:22 <dwcook> You'd have to pinky swear to the compiler that it's a proper instance
23:26:27 <Cale> and Identity is commutative
23:26:29 <dwcook> but then again we do that to a degree with Functor and Monad and such
23:26:37 <davidfetter> what's purple and commutes?
23:26:39 <Cale> I don't know if there are many other good examples in use
23:26:46 <dwcook> davidfetter: An abelian grape!
23:26:49 <jle`> examples of typeclasses with nothing in them?
23:26:54 <davidfetter> ^5
23:26:55 <jle`> besides laws?
23:27:01 <jle`> technically one day MonadPlus will be one
23:27:02 <Lutinzzz> what's purple, commutes, and is worshipped twice a week?
23:27:02 <Cale> davidfetter: What's yellow and complete under the induced norm?
23:27:13 <davidfetter> zorn's lemon?
23:27:14 <Cale> er, under the induced metric, I should say :)
23:27:21 <dwcook> Lutinzzz: Edward Kmett. I lied about the purple.
23:27:23 <Cale> A Banananach space
23:27:25 <Lutinzzz> a finitely venerated abelian grape
23:27:27 <Lutinzzz> lol
23:27:30 <davidfetter> ouch
23:27:59 <Lutinzzz> Cale: What's an anagram of Banach-Tarski?
23:28:11 <jle`> oh i can guess
23:28:13 <Cale> Banach-Tarski Banach-Tarski?
23:28:15 <jle`> banach-tarski banach-tarski
23:28:16 <davidfetter> anything you want
23:28:18 <Lutinzzz> yeah lol
23:28:19 <jle`> >_>
23:28:21 <jle`> <_<
23:28:25 <dwcook> XD
23:28:31 <edwardk> only twice a week? i'm slipping
23:28:59 <jle`> how would i be able to go about life if i got pinged every hour like edwardk
23:29:04 <jle`> ah the curse of fame
23:29:23 * Lutinzzz sets up an autoping script
23:29:26 <Lutinzzz> Let's find out!
23:29:26 <edwardk> jle`: mute helps ;)
23:29:48 <jle`> but edwardk clearly does not mute
23:29:52 <jle`> how does he do it
23:29:56 <jle`> . o O ( imagines )
23:31:32 <edwardk> jle`: bots
23:32:29 <jle`> hm makes sense to me
23:32:34 <pdxleif> He's part robot?
23:32:38 <pdxleif> Are we talking to a bot, now?
23:32:40 <dwcook> It sort of reminds me of how I keep pinging poor [redacted] with the /bin/ls quote because it keeps being relevant
23:34:06 <Lutinzzz> pdxleif: That's like asking if Lassie was part dog
23:34:37 <edwardk> pdxleif: Yes. Haskell can do that!
23:35:34 <Cale> My cat is almost entirely composed of cat parts.
23:35:50 <kazagistar> edwardk, are you trying to pass the coturing test?
23:35:51 <dwcook> My cat is made of starstuff
23:36:15 <dwcook> That's why we've gotta have the A/C running almost constantly
23:36:18 <edwardk> Cale: almost?
23:40:27 <jle`> do you mean the coturing cotest
23:40:51 <Lutinzzz> codo coyou comean cothe coturing cotest?
23:40:53 <Lutinzzz> co
23:41:19 <edwardk> i think Lutinzzz just failed the cotest ;)
23:41:23 <jle`> bro do you even colift
23:41:48 <jle`> edwardk: idk that sounds like an authentic 12 year old russian to me
23:41:52 <Lutinzzz> cotime cofor cosleep
23:42:09 <Lutinzzz> conight coall
23:42:56 <jle`> goodnight Lutinzzz
23:43:04 <dwcook> The coturing test is where you try to convince a human that they're a computer
23:43:09 <dwcook> Good night again Lutinzzz
23:43:33 <dwcook> Depending on your definition of "computer" this could be easier or harder
23:47:44 <dwcook> Welp sleep sounds good about now to me too. Chaitos.
23:50:33 <zomg> > Depending on your definition of "computer" this could be easier or harder
23:50:35 <lambdabot>  <hint>:1:30: parse error on input ‘of’
23:50:41 <zomg> I thought it was common knowledge that computers say "beep bop"
23:50:43 <zomg> and robots as well
23:50:48 <zomg> so you just need to say "beep bop"
23:50:49 <zomg> =)
23:51:48 <zomg> http://nedroid.com/2010/10/evidence-of-robot/
23:51:49 <kazagistar> which permutations of co- is convincing humans that you are a computer?
23:54:06 <`error> another newbie question... i have a list of say strings, and i want to filter them by the ones for which `doesDirectoryExist` returns true
23:54:34 <`error> i naively try: existing <- filter (\s -> doesDirectoryExist s) ["a", "b", "c"]
23:54:37 <`error> and it hates me.
23:55:19 <pavonia> You need a monadic version of filter, have alook at
23:55:19 <eazar001> :hoogle doesDirectoryExist
23:55:24 <eazar001> @hoogle doesDirectoryExist
23:55:27 <lambdabot> System.Directory doesDirectoryExist :: FilePath -> IO Bool
23:55:31 <pavonia> @hackage monad-lops
23:55:31 <lambdabot> http://hackage.haskell.org/package/monad-lops
23:55:33 <pavonia> @hackage monad-lopps
23:55:33 <lambdabot> http://hackage.haskell.org/package/monad-lopps
23:55:37 <pavonia> @hackage monad-loops
23:55:37 <lambdabot> http://hackage.haskell.org/package/monad-loops
23:55:39 <pavonia> :S
23:55:50 <eazar001> lol
23:55:52 <eazar001> nice
23:56:15 <haasn> `error: another approach, without an external dependency like monad-loops, would be to use mapM
23:56:26 <pavonia> Arrr, and it doesn't even have filterM
23:56:28 <haasn> eg. mapM doesDirectoryExist ["a","b","c"] :: IO [Bool]
23:56:48 <haasn> Although on second thought that's probably not as useful
23:57:02 <haasn> oh, filterM is in base
23:57:08 <haasn> :t filterM -- `error
23:57:10 <lambdabot> Monad m => (a -> m Bool) -> [a] -> m [a]
23:57:23 <haasn> note that doesDirectoryExist :: String -> IO Bool
23:57:26 <haasn> Compare this to the regular filter:
23:57:28 <haasn> :t filter
23:57:29 <lambdabot> (a -> Bool) -> [a] -> [a]
23:57:47 <haasn> This is a type error because Bool and IO Bool are simply not the same type
23:58:13 <haasn> Your approach could have worked if doesDirectoryExist :: String -> Bool -- but that makes no sense, since it involves side effects
23:58:31 <codygman> How can you specify that one Type of a sum type should be ordered before the other with a custom typeclass?
23:59:21 <pavonia> Do you mean in a derived typeclass?
23:59:42 <codygman> pavonia: Well it would have to be a user defined typeclass right?
