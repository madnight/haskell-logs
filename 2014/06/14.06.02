00:20:14 <jle`> i think Tekmo's perspective on "lens is the new monad" is that it is the controversial tool that changes a lot of how we do things fundamentally, that resists wider spread adoption at first due to unfamiliarity
00:20:36 <jle`> but in the end will be considered an indispensible and familiar tool entrenched in the haskell vernacular and idiom
00:20:57 <jle`> that was my impression of his sentiment
00:26:31 <gamegoblin> @pl \s -> map (fmap f) (p s)
00:26:31 <lambdabot> map (fmap f) . p
00:26:37 * hackagebot fast-math 1.0 - Non IEEE-754 compliant compile-time floating-point optimisations  http://hackage.haskell.org/package/fast-math-1.0 (MikeIzbicki)
00:45:15 <frerich> ehamberg: Thanks for merging my patches to 9m.no :)
00:46:37 <ehamberg> frerich: you're very welcome. thanks for the patches! :)
00:48:01 <tero-> is using Data.Tree to represent abstract syntax tree of a grammar a bad idea? The alternative is to use algebraic data types to define the structure of the tree.
00:48:15 <Iceland_jack> tero-: Define your own type
00:48:44 <tero-> Iceland_jack: I've done that, but I find doing transformations and queries a bit tedious
00:48:55 <frerich> ehamberg: In hindsight, I guess it would've been nice to only actually include the 'selectText' function in the 'body' template if it's actually needed. Adding yet another argument to 'body' (like  '[Text]' which is a list of JavaScript snippets to add to the <script> section) seemed a little awkward somehow.
00:49:35 <frerich> ehamberg: It's a nice exercise for Hamlet though, I kinda enjoyed tinkering with it. :)
00:51:20 <ehamberg> frerich: yeah, I really like Hamlet. glad to see that the onload is only included if there is actually something there now (so no `onload=""` :-)
00:53:20 <frerich> ehamberg: Yes, so am I! It was a bit hidden, but I found that (IMHO somewhat arcane...) notation for doing conditional attributes. Another thing I noticed is that when "interpolating" variables as in #{v} you can apparently also specify some sort of 'type' with it, like '#{toJavascript v}'. Seemed interesting at first, but I couldn't quite see whether this actually helps with the'onload' use case given that the
00:53:20 <frerich>  string is supposed to end up as an attribute value anyway.
00:56:27 <tdammers> heh, one downside of the fact that type-safe compile-time templates *can* be done in Haskell is that everyone actually *does* things that way
00:56:42 <tdammers> and runtime template systems are kind of orphan childs
00:56:49 <jle`> tero-: have you looked at recursion schemes?
00:57:37 <jle`> https://hackage.haskell.org/package/recursion-schemes
00:57:50 <tero-> jle`: nope. looking into it now
00:57:53 <alpounet> tero-: look at biplate/uniplate
01:00:20 <spacekitteh> category theory question: ok so if Hom(1,A) is the set of constants in A, what is Hom(A,0)?
01:01:18 <tero-> alpounet: ok, will do
01:01:54 <gamegoblin> Trying to think of a good infix operator to represent the concept of forking a sequence of actions into two sequences. The specific application is in a parser combinator library in which the fork operator would take two parsers and proceed down both parse trees. Ideas? And just to note, I of course have a sensical english word function (and mplus), but I was looking for ideas for a symbolic infix operator.
01:03:05 <alpounet> tero-: in a few words, these are all for easily writing transformations on AST-like structures. they take some getting used to but work well. Note that 'lens' has a module to help with these stuffs -- I happened to use it when traversing HTML
01:03:24 <tdammers> gamegoblin: <|> maybe?
01:03:49 <gamegoblin> tdammers: I have <|> doing something slightly different to maintain compatibility with parsec and attoparsec
01:03:55 <tdammers> ah
01:03:59 <gamegoblin> It tries A, and if A fails, it tries B
01:04:13 <tdammers> yes, that's what it's supposed to do
01:04:15 <gamegoblin> Whereas A `mplus` B tries both A and B and gives you both branches
01:04:18 <tdammers> so what are you looking for?
01:04:26 <tdammers> parse both and combine them into something?
01:04:29 <gamegoblin> No no
01:04:42 <tdammers> (,) <$> leftBranch <*> rightBranch
01:04:47 <gamegoblin> I have a parsing library of my own, JustParse, which is very similar, but it returns all possible parses
01:04:48 <tdammers> something like that?
01:05:03 <gamegoblin> rather, it optionally returns all possible parses
01:05:11 <gamegoblin> similar to various regex engines
01:05:16 <tdammers> as a list?
01:05:36 <awestroke> is fmap for ((->) r) typed fmap :: (a -> b) -> (r -> a) -> (r -> b) ?
01:06:07 <gamegoblin> Errr no, my Parser type is a bit different than Parsec and Attoparsec
01:06:17 <gamegoblin> rather than being like Parser (Stream -> Result)
01:06:23 <gamegoblin> It’s Parser (Stream -> [Result])
01:06:31 <gamegoblin> so my mplus definition is just
01:06:51 <gamegoblin> mplus (Parser p1) (Parser p2) = Parser (\s -> p1 s ++ p2 s)
01:06:59 <lfairy> awestroke: fmap = (.)
01:07:01 <tdammers> yeah, get it
01:07:09 <awestroke> lfairy: yes, I know. that is not a type
01:07:17 <jle`> gamegoblin: (<|>) for [] is supposed to do that
01:07:34 <gamegoblin> I was just wondering if any of you had any clever ascii art for a fork infix operator
01:07:50 <jle`> <|> is "supposed" to mean just that, if you can return multiple results
01:08:11 <supki> awestroke: yes
01:08:21 <awestroke> great, thanks
01:08:32 <jle`> > Nothing <|> Just 7
01:08:33 <lambdabot>  Just 7
01:08:35 <jle`> > [] <|> [7]
01:08:36 <lambdabot>  [7]
01:08:39 <jle`> > [1,2] <|> [5,6]
01:08:41 <lambdabot>  [1,2,5,6]
01:08:51 <jle`> think of [1,2] as a successful parse of either 1 or 2
01:09:08 <awestroke> gamegoblin: ⋲
01:09:10 <alphonse23> anyone try liquidhaskell?
01:09:54 <jle`> <||> is all i got :|
01:10:12 <gamegoblin> jle`: I could use my mplus definition for <|> and it would still satisfy the laws afaik, but my definiton is different from [atto]parsec so I am maintaining compatibility with them
01:10:16 <gamegoblin> <||> is actually good
01:10:35 <jle`> > [1,2,3] `mplus` [4,5,6]
01:10:37 <lambdabot>  [1,2,3,4,5,6]
01:10:53 <jle`> i guess it does satisfy the laws, but it's kind of weird semantically
01:11:01 <jle`> but that' sup to you i guess
01:11:20 <tero-> alpounet: yes these general utilities require some digesting. thanks for the tip
01:11:25 <phadej> <|> === mplus
01:11:43 * hackagebot range-set-list 0.0.4 - Memory efficient sets with continuous ranges of elements.  http://hackage.haskell.org/package/range-set-list-0.0.4 (phadej)
01:11:48 <gamegoblin> phadej: does it have to be, though?
01:11:49 <jle`> what sort of purpose would "skip the second thing completely if the first thing as succesful results" serve
01:11:58 <jle`> gamegoblin: it does in the same sense that pure is return
01:12:10 <gamegoblin> jle`: That’s exactly what parsec and attoparsec do, though?
01:12:14 <jle`> the fact that they are different are historical accidents and they semantically mean the same thing
01:12:32 <jle`> gamegoblin: well, parsec and attoparsec can only return one result
01:12:37 <gamegoblin> If you do p1 <|> p2 in parsec it won’t touch p2 if p1 succeeds.
01:12:41 <jle`> so you can think of it as applying listToMaybe
01:12:41 <bzcat> :t isAscii
01:12:42 <lambdabot> Char -> Bool
01:12:50 <jle`> as a monoid homomorphism
01:12:59 <jle`> > listToMaybe ([1,2] <|> [5,6])
01:13:00 <lambdabot>  Just 1
01:13:03 <zzh_> gtk2hs question:  how come this works on labels but not on buttons?
01:13:03 <zzh_> font <- fontDescriptionFromString "sans normal 15"
01:13:03 <zzh_> widgetModifyFont buttonName (Just font)
01:13:08 <jle`> > listToMaybe [1,2] <|> listToMaybe [5,6]
01:13:10 <lambdabot>  Just 1
01:13:12 <phadej> gamegoblin: it kind is, if you want MonadPlus and Alternative instances to be compatible (in the same sense as Monad and Applicative are compatible)
01:13:17 <jle`> > listToMaybe [] <|> listToMaybe [1,2]
01:13:19 <lambdabot>  Just 1
01:13:30 <jle`> > listToMaybe ([] <|> [1,2])
01:13:32 <lambdabot>  Just 1
01:13:54 <jle`> so you can think of parsec/attoparsec as "doing exactly what you are doing, except only returning the first element in the end"
01:14:06 <bzcat> :t interact
01:14:07 <lambdabot> (String -> String) -> IO ()
01:14:15 <bzcat> :t filter isAscii
01:14:16 <lambdabot> [Char] -> [Char]
01:14:55 <phadej> btw, you can make a 'generic parser' by Parser (Stream -> (Stream, Alternative a))
01:15:12 <jle`> oh really?
01:15:14 <jle`> that's neat
01:15:25 <phadej> with Maybe you get single value parser, with [] - list you get all possible parses
01:15:25 <jle`> would it demonstrate this behavior ... ?
01:15:36 <jle`> it should
01:15:47 <phadej> Or I'm not sure if you need monadplus
01:15:57 <zwer> @src listToMaybe
01:15:57 <lambdabot> listToMaybe []        =  Nothing
01:15:57 <lambdabot> listToMaybe (a:_)     =  Just a
01:15:59 <bzcat> what would be the right predicate for getting rid of the crap you get from unix script?
01:16:22 <bzcat> i.e. backspaces and stuff
01:16:29 <bzcat> isPrintable?
01:16:42 <gamegoblin> in Data.Char there is an isPrint predicate
01:16:50 <gamegoblin> :t isPrint
01:16:50 <lambdabot> Char -> Bool
01:16:56 <bzcat> thanks
01:17:15 <gamegoblin> Which I think is just not . isControl
01:17:19 <gamegoblin> @src isPrint
01:17:19 <lambdabot> Source not found. :(
01:17:30 <gamegoblin> @src Data.Char.isPrint
01:17:31 <lambdabot> Source not found. :(
01:17:32 <bzcat> yikes. that didn't turn out well.
01:17:55 <gamegoblin> Beware of newlines ;)
01:18:04 <bzcat> I get [K[K[K[K too whatever that is
01:18:12 <bzcat> probably backspace
01:19:48 <bzcat> even when I run it through interact (filter isAscii) I get a terminal beep which is weird :P
01:19:54 <bzcat> wait
01:20:01 <bzcat> no it's not lol ._.
01:24:01 <jle`> > map (chr . (^2) . ord) "hello"
01:24:03 <lambdabot>  "\10816\10201\11664\11664\12321"
01:24:23 <jle`> is there a lens thingy that would like...let me inject (^2) into that chr . f . ord pipeline
01:24:29 <jle`> cause they are like...isomorphisms or something
01:25:00 <p0a> Hello I want a certain function f ::  ([a] -> b) -> [a] -> [b]. such that f g [x,y,z] = [g([x]), g([x,y]), g([x,y,z])]
01:25:02 <p0a> Should I implement f or is it standard?
01:25:49 <jle`> @hoogle ([a] -> b) -> [a] -> [b]
01:25:51 <lambdabot> Foreign.Marshal.Utils withMany :: (a -> (b -> res) -> res) -> [a] -> ([b] -> res) -> res
01:25:51 <lambdabot> Data.Generics.Aliases ext1Q :: (Data d, Typeable1 t) => (d -> q) -> (forall e. Data e => t e -> q) -> d -> q
01:26:02 <quchen> :t \g -> map g . tails -- p0a
01:26:03 <lambdabot> ([a] -> b) -> [a] -> [b]
01:26:26 <quchen> ('tails' includes a [] entry that you'll have to drop if you don't want it)
01:26:38 <magicman> Also, inits.
01:26:48 <quchen> Oh, right.
01:28:36 <p0a> quchen: thank you
01:28:53 <kazagistar> > init . inits "test"
01:28:54 <lambdabot>  Couldn't match expected type ‘a -> [a1]’
01:28:54 <lambdabot>              with actual type ‘[[GHC.Types.Char]]’
01:29:17 <quchen> That's   init . (inits "test")
01:29:25 <kazagistar> > init . inits $ "test"
01:29:26 <lambdabot>  ["","t","te","tes"]
01:29:35 <kazagistar> oh, I guess I got it backwards
01:32:30 <kazagistar> > map isDigit . tail . inits $ "123test"
01:32:31 <lambdabot>  Couldn't match type ‘[GHC.Types.Char]’ with ‘GHC.Types.Char’
01:32:32 <lambdabot>  Expected type: [GHC.Types.Char] -> [GHC.Types.Char]
01:32:32 <lambdabot>    Actual type: [GHC.Types.Char] -> [[GHC.Types.Char]]
01:32:44 <kazagistar> oh, derp
01:32:46 <kazagistar> screw it
01:32:48 <magicman> > map g . tail . inits $ [x,y,z] :: [Expr]
01:32:50 <lambdabot>  [g [x],g [x,y],g [x,y,z]]
01:33:02 <magicman> (because SimpleReflect magic)
01:33:13 <kazagistar> ... this is a magic I must learn
01:35:26 <magicman> Its main use-case is for messing around in ghci or lambdabot, I think. If you're using variables that aren't defined in the library, it'll be a scope error.
01:36:37 <kazagistar> magicman: ah, the magic is pretty straightforward  and mundane now that I looked at it
01:36:43 <jle`> > f
01:36:44 <lambdabot>  No instance for (GHC.Show.Show a0)
01:36:45 <lambdabot>    arising from a use of ‘M79237036734335200397324.show_M79237036734335200397...
01:36:45 <lambdabot>  The type variable ‘a0’ is ambiguous
01:36:45 <lambdabot>  Note: there are several potential instances:
01:36:45 <lambdabot>    instance [safe] GHC.Show.Show
01:36:46 * hackagebot range-set-list 0.0.5 - Memory efficient sets with continuous ranges of elements.  http://hackage.haskell.org/package/range-set-list-0.0.5 (phadej)
01:37:13 <magicman> Yeah. No actual reflection going on. Just cleverly named constants :p
01:37:35 <kazagistar> > x
01:37:41 <lambdabot>  can't find file: L.hs
01:38:34 <kazagistar> > [a, b]
01:38:36 <lambdabot>  [a,b]
01:38:43 <bzcat> what's a better way to write (\x -> any ($x) [p1,p2,p3,p4])
01:38:48 <jle`> > f :: Expr
01:38:50 <lambdabot>  f
01:39:10 <jle`> hm
01:40:00 <jle`> or ([p1,p2,p3] <*> pure x)
01:40:06 <jle`> not sure if that's better
01:40:11 <bzcat> yeah, I thought of that too
01:40:19 <awestroke> @pl (\x -> any ($x) [p1,p2,p3,p4])
01:40:20 <lambdabot> flip any [p1, p2, p3, p4] . flip id
01:40:41 <kazagistar> lolflop
01:40:44 <kazagistar> *flip
01:40:46 <edwardk> jle`: Numerc.Lens.exponentiating, but you can also just use something like: "hello" & traverse._Enum ^~ 2
01:41:33 <bzcat> eh, the lambda's fine
01:42:03 <jle`> bzcat: or . ap [p1,p2,p3] . pure
01:42:06 <jle`> :)
01:42:21 <p0a> so inits and tails is in Data?
01:42:26 <bzcat> psh :P
01:42:48 <bzcat> it looks nice but the lambda is a bit more clear
01:42:52 <p0a> How can I use Data?
01:42:54 <jle`> probably
01:42:57 <jle`> p0a: it's in Data.List
01:42:59 <kazagistar> p0a: Data.List... full paths are important
01:42:59 <jle`> import Data.List
01:43:06 <p0a> Thank you
01:43:28 <jle`> edwardk: hm.  so does _Enum do that "injecting f into toEnum . f .fromEnum" that i described earlier? is that an accurate way of saying how it works?
01:43:51 <jle`> also do you have lens on hilight or something
01:44:07 <edwardk> jle`: _Enum is an Iso, going back and forth between Int and an Enum (a bit of a lie, but its nice)
01:44:11 <edwardk> :t _Enum
01:44:12 <lambdabot>     Found hole ‘_Enum’ with type: t
01:44:12 <lambdabot>     Where: ‘t’ is a rigid type variable bound by
01:44:13 <lambdabot>                the inferred type of it :: t at Top level
01:44:19 <jle`> heh
01:44:35 <jle`> :t iso
01:44:36 <lambdabot> (Profunctor p, Functor f) => (s -> a) -> (b -> t) -> p a (f b) -> p s (f t)
01:44:40 <jle`> hm
01:44:54 <edwardk> anyways lets just make it up inline
01:45:00 <edwardk> :t iso toEnum fromEnum
01:45:01 <lambdabot> (Profunctor p, Functor f, Enum b, Enum a) => p a (f b) -> p Int (f Int)
01:45:06 <jle`> an Iso contains the "to" and the "from"...so...it contains the toEnum and the fromEnum
01:45:11 <jle`> wait
01:45:20 <edwardk> > "hello" & traverse.iso toEnum fromEnum +~ 1
01:45:22 <lambdabot>  Couldn't match type ‘GHC.Types.Char’ with ‘GHC.Types.Int’
01:45:22 <lambdabot>  Expected type: (b0 -> Data.Functor.Identity.Identity b0)
01:45:22 <lambdabot>                 -> GHC.Types.Char -> Data.Functor.Identity.Identity GHC.Types...
01:45:22 <lambdabot>    Actual type: (b0 -> Data.Functor.Identity.Identity b0)
01:45:23 <lambdabot>                 -> GHC.Types.Int -> Data.Functor.Identity.Identity GHC.Types.Int
01:45:31 <edwardk> > "hello" & traverse.iso fromEnum toEnum +~ 1
01:45:33 <lambdabot>  [*Exception: Prelude.Enum.().toEnum: bad argument
01:45:41 <jle`> so an isomorphism from Enum e to Int would have fromEnum as the forward and toEnum as the inverse
01:46:22 <jle`> > "hello" & traverse.iso fromEnum toEnum +~ 1
01:46:23 <lambdabot>  can't find file: L.hs
01:46:26 <jle`> > "hello" & traverse.iso fromEnum toEnum +~ 1
01:46:28 <lambdabot>  [*Exception: Prelude.Enum.().toEnum: bad argument
01:46:35 <jle`> hm
01:47:24 <jle`> > [1,2,3] & traverse . iso (+2) (-2) %~ id
01:47:25 <lambdabot>  Could not deduce (GHC.Num.Num (b0 -> b1))
01:47:26 <lambdabot>    arising from the ambiguity check for ‘e_112322’
01:47:26 <lambdabot>  from the context (GHC.Num.Num (b -> b1), GHC.Num.Num b)
01:47:26 <lambdabot>    bound by the inferred type for ‘e_112322’:
01:47:26 <lambdabot>               (GHC.Num.Num (b -> b1), GHC.Num.Num b) => [b1]
01:47:44 <p0a> mymap f = map f . tail $ inits
01:47:48 <p0a> why won't this work? :(
01:48:00 <edwardk> ah derp
01:48:05 <edwardk> :t iso toEnum fromEnum
01:48:06 <lambdabot> (Profunctor p, Functor f, Enum b, Enum a) => p a (f b) -> p Int (f Int)
01:48:07 <jle`> darn unary minus
01:48:11 <edwardk> :t simple.iso toEnum fromEnum
01:48:12 <lambdabot> (Profunctor p, Functor f, Enum b, Enum a) => p a (f b) -> p Int (f Int)
01:48:15 <edwardk> :t simple.iso toEnum fromEnum +~ 1
01:48:16 <lambdabot> Int -> Int
01:48:20 <edwardk> :t 'x' & simple.iso toEnum fromEnum +~ 1
01:48:21 <lambdabot>     Couldn't match type ‘Int’ with ‘Char’
01:48:21 <lambdabot>     Expected type: (Int -> Identity Int) -> Char -> Identity Int
01:48:21 <lambdabot>       Actual type: (Int -> Identity Int) -> Int -> Identity Int
01:48:23 <p0a> map (\x -> x) . tail $ inits [1,2,3] works fine
01:48:26 <edwardk> :t 'x' & simple.iso fromEnum toEnum +~ 1
01:48:31 <lambdabot> Char
01:48:34 <edwardk> > 'x' & simple.iso fromEnum toEnum +~ 1
01:48:37 <lambdabot>  'y'
01:48:37 <edwardk> silly me
01:48:43 <awestroke> p0a: try map f . tail . inits
01:48:43 <edwardk> > 'x' & simple.iso fromEnum toEnum ^~ 2
01:48:45 <lambdabot>  '\14400'
01:48:58 <edwardk> > "hello" & traverse.simple.iso fromEnum toEnum ^~ 2
01:48:59 <lambdabot>  "\10816\10201\11664\11664\12321"
01:49:07 <edwardk> simple keeps it from changing the type
01:49:11 <edwardk> :t iso fromEnum toEnum
01:49:12 <lambdabot> (Profunctor p, Functor f, Enum t, Enum s) => p Int (f Int) -> p s (f t)
01:49:17 <kazagistar> p0a: look at the types of { $ } and { inits }, and see why they dont match
01:49:19 <edwardk> :t iso fromEnum toEnum ^~ 2
01:49:20 <lambdabot> (Enum t, Enum s) => s -> t
01:49:26 <p0a> kazagistar: thank you
01:49:33 <p0a> awestroke: thank you too :)
01:49:33 <edwardk> notice how that can become any other instance of Enum?
01:49:39 <jle`> > [1,2,3] & traverse . simple . iso ((+) 2) ((-) 2) +~ 1
01:49:40 <edwardk> :t simple.iso fromEnum toEnum ^~ 2
01:49:41 <lambdabot>  [-2,-3,-4]
01:49:41 <lambdabot> Enum a => a -> a
01:49:50 <jle`> oops
01:49:55 <edwardk> heh
01:50:07 <jle`> > [1,2,3] & traverse . simple . iso (\x -> x+2) (\x -> x-2) +~ 1
01:50:09 <lambdabot>  [2,3,4]
01:50:11 <jle`> woo hoo
01:50:15 <jle`> oh i see what the error was now before
01:50:19 <edwardk> > [1,2,3] & traverse . simple . iso (+ 2) (subtract 2) +~ 1
01:50:21 <lambdabot>  [2,3,4]
01:50:21 <jle`> it infered the target enum as ()
01:50:23 <edwardk> yep
01:50:32 <jle`> yay i can make my own isos
01:50:34 <jle`> are prisms just isos
01:50:46 <edwardk> no but every iso is a valid prism
01:50:58 <edwardk> a prism is an iso that can fail to match in on direction
01:51:01 <edwardk> :t prism'
01:51:02 <lambdabot> (Choice p, Applicative f) => (b -> s) -> (s -> Maybe a) -> p a (f b) -> p s (f s)
01:51:04 <edwardk> :t iso'
01:51:05 <lambdabot>     Not in scope: ‘iso'’
01:51:06 <lambdabot>     Perhaps you meant ‘iso’ (imported from Control.Lens)
01:51:08 <edwardk> :t iso
01:51:09 <lambdabot> (Profunctor p, Functor f) => (s -> a) -> (b -> t) -> p a (f b) -> p s (f t)
01:51:12 <edwardk> :t prism
01:51:13 <jle`> oh
01:51:14 <lambdabot> (Choice p, Applicative f) => (b -> t) -> (s -> Either t a) -> p a (f b) -> p s (f t)
01:51:17 <edwardk> there
01:51:24 <edwardk> that is a better illusraton of the example
01:51:29 <jle`> don't you have one over a generic traversable
01:51:31 <edwardk> er of the difference
01:51:35 <edwardk> :t traverse
01:51:36 <lambdabot> (Traversable t, Applicative f) => (a -> f b) -> t a -> f (t b)
01:51:44 <edwardk> you mean that?
01:52:02 <edwardk> > _Left # 4
01:52:04 <lambdabot>  Left 4
01:52:09 <edwardk> > Left 4 ^? _Left
01:52:11 <lambdabot>  Just 4
01:52:13 <edwardk> > Right 4 ^? _Left
01:52:15 <lambdabot>  Nothing
01:52:17 <jle`> as in Traversable tr => (b -> t) -> (s -> tr a) -> p a (f b) -> p s (f s)
01:52:23 <edwardk> notice how _Left can fail to match?
01:52:28 <jle`> would that be useful in any way
01:52:37 <jle`> hm
01:52:42 <edwardk> its not coherent unfortunately with the laws
01:53:03 <jle`> > Right 4 & _Left *~ 2
01:53:05 <lambdabot>  Right 4
01:53:09 <jle`> > Left 4 & _Left *~ 2
01:53:11 <lambdabot>  Left 8
01:53:12 <jle`> :O
01:54:00 <jle`> i can use both iso and prims there because they both turn into a p a (f b) -> p s (f s) in the end huh.
01:54:03 <edwardk> a lens is saying: (s -> a, s -> b -> t)   or equivalently (s -> a, (s,b) -> t)   a prism is saying (b -> t, s -> Either a t) -- which is what you get if you take the pair of arrows defining a lens and build them in the dual category
01:54:21 <jle`> :t lens
01:54:21 <lambdabot> Functor f => (s -> a) -> (s -> b -> t) -> (a -> f b) -> s -> f t
01:54:29 <edwardk> and when p = (->) you get a lens or a traversal out of an iso and a prism respectively
01:54:38 <jle`> why isn't lens generic over p a (f b) -> p s (f t)
01:54:46 <jle`> why is it assuming p ~ (->) ?
01:54:58 <jle`> ...does that question even make sense?
01:55:00 <edwardk> because you want to be able to define lens using just prelude types
01:55:11 <jle`> me?
01:55:12 <edwardk> if you wanted to drop that we could simplify lens a bit, but at a huge social impact
01:55:22 <bzcat> @hoogle readFile
01:55:23 <lambdabot> Prelude readFile :: FilePath -> IO String
01:55:23 <lambdabot> System.IO readFile :: FilePath -> IO String
01:55:23 <lambdabot> Data.ByteString.Lazy.Char8 readFile :: FilePath -> IO ByteString
01:55:27 <edwardk> _2 f (a,b) = (,) a <$> f b -- is a lens
01:55:32 <edwardk> notice ow it needed nothing from `lens`?
01:55:33 <jle`> oh
01:55:38 <jle`> um
01:55:43 <jle`> but wouldn't it still be a lens
01:55:49 <bzcat> should I use the Lazy.Char8 for reading a file as a bytestring?
01:55:57 <jle`> if lens returned any profunctor
01:56:00 <edwardk> now, we could define lenses differenttly
01:56:15 <bzcat> I always get confused about Char8, Lazy, Word8 blah
01:56:15 <edwardk> :t Data.Profunctor.second'
01:56:17 <lambdabot> Data.Profunctor.Strong p => p a b -> p (c, a) (c, b)
01:56:24 <edwardk> we could define lenses like that
01:56:36 <edwardk> type Lens s t a b = forall p. Strong p => p a b -> p s t
01:56:45 <edwardk> type Iso s t a b = forall p. Profunctor p => p a b -> p s t
01:56:52 <edwardk> type Prism s t a b = forall p. Choice p => p a b -> p s t
01:56:58 <edwardk> its very clean.
01:57:00 <jle`> how pretty
01:57:22 <edwardk> but its harder to use, traverse isn't a traversal, constructing them is harder, you need more dependencies for basic use, etc.
01:57:34 <edwardk> its harder to write traversals and lenses etc
01:57:39 <jle`> hm
01:57:43 <jle`> i'll take your word for it
01:57:44 <merijn> edwardk: Is there an "slightly more advanced lens tutorial" somewhere yet? I feel I have a pretty ok grasp of the whole lens business, but the Traversal/Prism stuff is still lost on me
01:57:45 <edwardk> we call those 'pure profunctor lenses'
01:57:58 <edwardk> merijn: did you watch the NY haskell session?
01:58:09 <merijn> edwardk: If it was recent, then no?
01:58:12 <jle`> but i like that i can make my own lens/iso/prisms now for fun
01:58:15 <edwardk> merijn: its old
01:58:23 <jle`> and i don't have to rely on the ones pre-defined
01:58:28 <jle`> this changes everything.
01:58:32 <edwardk> https://www.youtube.com/watch?v=cefnmjtAolY
01:58:56 <merijn> bzcat: The answer to the question "should I use Char8?" is always "no"
01:59:00 <edwardk> jle`: the predefined ones are just to get you started / for common types
01:59:07 <bzcat> lol, okay :)
01:59:09 <merijn> edwardk: I think I did watch that one
01:59:16 <bzcat> makes it easier \o/
01:59:16 <jle`> how would i emulate something like
01:59:22 <jle`> > ala Sum foldMap [1,2,3]
01:59:23 <lambdabot>  6
01:59:29 <jle`> using an iso
01:59:40 <jle`> because i can make an isomorphism using iso Sum getSum
01:59:50 <bzcat> Deprecated: Use Data.ByteString.Lazy.Char8.putStrLn instead. (Functions that rely on ASCII encodings belong in Data.ByteString.Lazy.Char8) on http://hackage.haskell.org/package/bytestring-0.10.4.0/docs/Data-ByteString-Lazy.html
01:59:52 <merijn> bzcat: Basically, Char8 blindly assumes ASCII and will silently drop/truncate non-ASCII characters
01:59:54 <jle`> and i feel like i should be able to leverage that to do an ala thing
01:59:58 <edwardk> merijn: about 30 minutes in i start into traversals
02:00:09 <edwardk> :t _Wrapping Sum
02:00:10 <lambdabot> (Profunctor p, Functor f) => p (Unwrapped (Sum b1)) (f (Unwrapped (Sum b))) -> p (Sum b1) (f (Sum b))
02:00:27 <merijn> edwardk: Thanks, I'll check it out
02:00:28 <jle`> :t _Wrapping
02:00:29 <lambdabot> (Rewrapped t s, Rewrapped s t, Profunctor p, Functor f) => (Unwrapped s -> s) -> p (Unwrapped s) (f (Unwrapped t)) -> p s (f t)
02:00:30 <edwardk> Unwrapped (Sum b1) = b1
02:00:41 <jle`> that just looks like typeclass hackery
02:00:58 <jle`> you define a various wrapper/unwrapper instances for stuff
02:00:58 <edwardk> it is just a way to make a common class for hcking up those kinds of things
02:01:07 <jle`> but can i do it with my own custom shiny iso i just made?
02:01:07 <edwardk> yeah
02:01:11 <edwardk> pure convenience
02:01:13 <edwardk> yep
02:01:13 <jle`> :t iso Sum getSum
02:01:14 <lambdabot> (Profunctor p, Functor f) => p (Sum s) (f (Sum t)) -> p s (f t)
02:01:24 <edwardk> :t iso getSum Sum
02:01:25 <lambdabot> (Profunctor p, Functor f) => p a (f b) -> p (Sum a) (f (Sum b))
02:01:34 <edwardk> @let _Sum = iso getSum Sum
02:01:36 <lambdabot>  Defined.
02:01:38 <merijn> bzcat: The only reason Char8 really exists is to provide an IsString instance for ByteString to use with OverloadedStrings (but this *also* has the same silent truncation issue), so the only real usecase is "conveniently writing String like ASCII literals", i.e. if you're doing stuff like parsing HTTP/SMTP/etc.
02:01:46 <edwardk> > _Sum # 4
02:01:49 <lambdabot>  Sum {getSum = 4}
02:01:54 <jle`> :t (#)
02:01:55 <lambdabot> parse error on input ‘)’
02:01:58 <edwardk> > Sum 4^.Sum
02:01:59 <lambdabot>  Couldn't match type ‘Data.Monoid.Sum
02:01:59 <lambdabot>                         (a -> Control.Applicative.Const a a)’
02:02:00 <lambdabot>                with ‘Data.Monoid.Sum a0
02:02:00 <lambdabot>                      -> Control.Applicative.Const a (Data.Monoid.Sum a0)’
02:02:00 <lambdabot>  Expected type: Control.Lens.Getter.Getting a (Data.Monoid.Sum a0) a
02:02:02 <edwardk> > Sum 4^._Sum
02:02:04 <lambdabot>  4
02:02:10 <jle`> that's just not fair, lambdabot
02:02:12 <edwardk> :t ( # )
02:02:14 <lambdabot> AReview s t a b -> b -> t
02:02:40 <edwardk> works on prisms and isos and equalities and something weaker called a 'review'
02:02:45 <bzcat> merijn: all right :)
02:02:49 <merijn> bzcat: If you want to do actual binary IO, just use "normal" ByteString (Lazy or Strict is up to you) and if you want unicode IO, use Text (decoding from ByteString)
02:02:59 <jle`> > [1,2,3] & traverse . iso Sum getSum +~ 1
02:03:01 <lambdabot>  [2,3,4]
02:03:07 <bzcat> *nod*
02:03:19 <jle`> can i use _Sum to implement something like ala Sum foldMap ?
02:04:39 <k00mi> > over _Sum (+1) $ Sum 3
02:04:40 <lambdabot>  Sum {getSum = 4}
02:04:41 <jle`> hm. is there any way to project the to/from functions back out if i have an iso
02:04:58 <jle`> oh is that what (#) does
02:05:05 <jle`> :t (#) _Sum
02:05:05 <lambdabot> parse error on input ‘)’
02:05:11 <jle`> :t ( # ) _Sum
02:05:12 <lambdabot> b -> Sum b
02:05:19 <jle`> can i get the Sum b -> b
02:05:34 <Jaak_> :t getSum
02:05:35 <lambdabot> Sum a -> a
02:05:40 <jle`> i mean, from _Sum
02:05:45 <k00mi> :t view _Sum
02:05:46 <lambdabot> MonadReader (Sum b) m => m b
02:05:51 <jle`> :O is that what view does
02:06:01 <jle`> :t view _Sum `asApplidTo` Sum 1
02:06:02 <lambdabot>     Not in scope: ‘asApplidTo’
02:06:02 <lambdabot>     Perhaps you meant ‘asAppliedTo’ (line 148)
02:06:05 <jle`> :t view _Sum `asAppliedTo` Sum 1
02:06:06 <lambdabot> Num a => Sum a -> a
02:06:10 <jle`> :O
02:06:37 <jle`> > view (iso Sum getSum) (Sum 3)
02:06:39 <lambdabot>  Sum {getSum = Sum {getSum = 3}}
02:06:41 <edwardk> :t review _Sum
02:06:43 <lambdabot> MonadReader b m => m (Sum b)
02:06:47 <jle`> > review (iso Sum getSum) (Sum 3)
02:06:48 <edwardk> :t view _Sum
02:06:49 <lambdabot> MonadReader (Sum b) m => m b
02:06:49 <lambdabot>  3
02:06:58 <k00mi> :t view (from _Sum)
02:06:59 <lambdabot> MonadReader b m => m (Sum b)
02:07:07 <edwardk> :t view (re _Sum)
02:07:09 <lambdabot> MonadReader s m => m (Sum s)
02:07:09 <jle`> > iso Sum getSum # 3
02:07:10 <lambdabot>  3
02:07:27 <jle`> something went wrong
02:07:29 <jle`> > _Sum # 3
02:07:30 <edwardk> that used the Num instance for Sum a
02:07:31 <lambdabot>  Sum {getSum = 3}
02:07:34 <jle`> oh
02:07:36 <p0a> Why does this type declaration fail? strstr :: Eq a => [a] -> [a] -> Maybe Int
02:07:37 <jle`> wow
02:07:46 <merijn> p0a: Define "fail"
02:08:37 <p0a> could not deduce type (Num (Maybe Int)). I think the problem is that I have not defined the type of the function strstr_helper which is recursive and used in strstr.
02:08:43 <p0a> and its type can not be deduced
02:08:50 <excarna> p0a: how have you defined strstr
02:08:56 <Iceland_jack> p0a: the problem is that you're treating 'Just _' or 'Nothing' as a number
02:09:03 <p0a> Iceland_jack: indeed :)
02:09:20 <p0a> excarna: I will show you the code
02:09:25 <jle`> > let ala' i f x = view i (f (i # x)) in ala' _Sum foldMap [1,2,3]
02:09:27 <lambdabot>  Couldn't match type ‘a -> Control.Applicative.Const a a’
02:09:27 <lambdabot>                with ‘Data.Tagged.Tagged a0 (Data.Functor.Identity.Identity b1)’
02:09:27 <lambdabot>  Expected type: Control.Lens.Review.AReview s0 t2 a0 b1
02:09:27 <lambdabot>    Actual type: Control.Lens.Getter.Getting a s a
02:09:27 <lambdabot>  Relevant bindings include
02:09:33 <p0a> excarna: if you want, although I do believe I can solve this now
02:09:36 <Iceland_jack> So the type looks just fine
02:09:55 <jle`> > let ala' i f x = review i (f (i # x)) in ala' _Sum mconcat [1,2,3]
02:09:57 <lambdabot>  Couldn't match type ‘[[t]]’ with ‘Data.Monoid.Sum [t]’
02:09:57 <lambdabot>  Expected type: Data.Monoid.Sum [t] -> [t]
02:09:57 <lambdabot>    Actual type: [[t]] -> [t]
02:09:59 <p0a> excarna: http://lpaste.net/104971
02:10:51 <Iceland_jack> p0a: Why does it return -1?
02:11:06 <Iceland_jack> Don't you want 'Just (-1)'
02:11:11 <p0a> Iceland_jack: remnant of C coding. -1 is error value. I need to return Nothing
02:11:27 <p0a> ah, I was looking for Just.
02:12:50 <kazagistar> p0a: note, you can use "where" to declare things locally for the purpose of a single function, like strstr_helper
02:12:53 <merijn> p0a: FYI, I would rewrite line 7 to use guards instead of if-then-else
02:13:15 <p0a> thank you I will use them too
02:14:04 <p0a> kazagistar: strstr_helper foo bar baz where baz = 0 ?
02:14:22 <jle`> okay i got it this far, edwardk
02:14:23 <jle`> > let ala' i f x = (f ( i # ) x) in ala' _Sum foldMap [1,2,3]
02:14:24 <p0a> To give name to the constant 0?
02:14:25 <lambdabot>  Sum {getSum = 6}
02:14:36 <jle`> but if i put view i before that, it errors :/
02:14:41 <jle`> > let ala' i f x = view i (f ( i # ) x) in ala' _Sum foldMap [1,2,3]
02:14:42 <lambdabot>  Couldn't match type ‘a -> Control.Applicative.Const a a’
02:14:42 <lambdabot>                with ‘Data.Tagged.Tagged a0 (Data.Functor.Identity.Identity b1)’
02:14:42 <lambdabot>  Expected type: Control.Lens.Review.AReview s0 t2 a0 b1
02:14:42 <lambdabot>    Actual type: Control.Lens.Getter.Getting a s a
02:14:42 <lambdabot>  Relevant bindings include
02:14:59 <p0a> kazagistar: ah, inside strstr_helper. Okay, I understand, thanks :)
02:15:05 <jle`> > let ala' i f x = review i (f ( i # ) x) in ala' _Sum foldMap [1,2,3]
02:15:06 <lambdabot>  Occurs check: cannot construct the infinite type:
02:15:07 <lambdabot>    t ~ Data.Monoid.Sum t
02:15:07 <lambdabot>  Expected type: (t -> Data.Monoid.Sum t) -> [t] -> t
02:15:07 <lambdabot>    Actual type: (t -> Data.Monoid.Sum t) -> [t] -> Data.Monoid.Sum t
02:15:14 <jle`> but i can do
02:15:17 <edwardk> > ala Sum foldMap [1,2,3]
02:15:19 <lambdabot>  6
02:15:21 <jle`> > view _Sum (Sum 6)
02:15:22 <merijn> p0a: I would probably refactor that code like so: http://lpaste.net/104971
02:15:23 <lambdabot>  6
02:15:28 <edwardk> > au _Sum foldMap [1,2,3]
02:15:30 <lambdabot>  No instance for (GHC.Show.Show b0)
02:15:30 <lambdabot>    arising from a use of ‘M9942419686586694208872.show_M9942419686586694208872’
02:15:30 <lambdabot>  The type variable ‘b0’ is ambiguous
02:15:31 <lambdabot>  Note: there are several potential instances:
02:15:31 <lambdabot>    instance [safe] GHC.Show.Show
02:15:46 <jle`> edwardk: i'm trying to implement my own ala an iso instead of typeclass magic :(
02:15:54 <k00mi> au (_Unwrapping Sum) foldMap [1,2,3]
02:15:57 <k00mi> > au (_Unwrapping Sum) foldMap [1,2,3]
02:16:00 <lambdabot>  6
02:16:08 <jle`> _Unwrapping is typeclass magique
02:16:16 <kazagistar> p0a: vaugely like this: http://lpaste.net/104973, though it is not very important, it means you can use shorter names and such without worrying about conflicts
02:16:16 <k00mi> jle`: so is ala
02:16:30 <k00mi> if you call regular instances magic
02:16:33 <jle`> yeah, i want to write my own ala without typeclasses
02:16:38 <jle`> using only my iso
02:16:42 <jle`> i'm close :/
02:16:49 <edwardk> :t au
02:16:50 <jle`> > let ala' i f x = (f ( i # ) x) in ala' _Sum foldMap [1,2,3]
02:16:50 <lambdabot> AnIso s t a b -> ((s -> a) -> e -> b) -> e -> t
02:16:51 <lambdabot>  Sum {getSum = 6}
02:17:09 <jle`> hm
02:17:13 <merijn> p0a: hmm, previous one doesn't typecheck, this one should: http://lpaste.net/104972
02:17:23 <jle`> why didn't your au work then
02:17:32 <edwardk> we have ala/alaf that use the typeclass magic. au/auf that use an explicit iso
02:17:42 <jle`> > au _Sum foldMap [1,2,3]
02:17:43 <lambdabot>  No instance for (GHC.Show.Show b0)
02:17:43 <lambdabot>    arising from a use of ‘M28992245802508380868984.show_M28992245802508380868...
02:17:43 <lambdabot>  The type variable ‘b0’ is ambiguous
02:17:43 <lambdabot>  Note: there are several potential instances:
02:17:43 <lambdabot>    instance [safe] GHC.Show.Show
02:17:52 <jle`> > au _Sum foldMap [1,2,3] :: Int
02:17:54 <lambdabot>  Couldn't match type ‘Data.Monoid.Sum b0’ with ‘GHC.Types.Int’
02:17:54 <lambdabot>  Expected type: Control.Lens.Iso.AnIso
02:17:54 <lambdabot>                   (Data.Monoid.Sum b0) GHC.Types.Int b0 b0
02:17:54 <lambdabot>    Actual type: Control.Lens.Internal.Iso.Exchange
02:17:55 <lambdabot>                   b0 b0 b0 (Data.Functor.Identity.Identity b0)
02:18:20 <edwardk> :t au
02:18:21 <lambdabot> AnIso s t a b -> ((s -> a) -> e -> b) -> e -> t
02:18:24 <edwardk> :t au _Sum
02:18:26 <lambdabot> ((Sum a -> a) -> e -> b) -> e -> Sum b
02:18:28 <edwardk> :t au _Sum foldMap
02:18:29 <lambdabot> (Monoid b, Foldable t) => t (Sum b) -> Sum b
02:18:32 <edwardk> -- aha
02:18:38 <edwardk> :t au (from _Sum) foldMap
02:18:39 <lambdabot> (Foldable t1, Num t) => t1 t -> t
02:18:41 <edwardk> :t au (from _Sum) foldMap [1,2,3]
02:18:42 <lambdabot> Num t => t
02:18:45 <edwardk> > au (from _Sum) foldMap [1,2,3]
02:18:46 <lambdabot>  6
02:18:49 <jle`> :t from
02:18:49 <lambdabot> (Profunctor p, Functor f) => AnIso s t a b -> p t (f s) -> p b (f a)
02:18:55 <edwardk> from turns an iso around
02:19:00 <jle`> > ah
02:19:01 <lambdabot>  Not in scope: ‘ah’
02:19:02 <lambdabot>  Perhaps you meant one of these:
02:19:02 <lambdabot>    ‘a’ (imported from Debug.SimpleReflect),
02:19:02 <lambdabot>    ‘h’ (imported from Debug.SimpleReflect),
02:19:02 <lambdabot>    ‘ap’ (imported from Control.Monad.Writer)
02:19:05 <jle`> heh
02:19:06 <edwardk> > _Sum # 2
02:19:08 <lambdabot>  Sum {getSum = 2}
02:19:19 <jle`> > au (iso getSum Sum) foldMap [1,2,3]
02:19:21 <lambdabot>  No instance for (GHC.Show.Show b0)
02:19:21 <lambdabot>    arising from a use of ‘M13669173356914698979122.show_M13669173356914698979...
02:19:21 <lambdabot>  The type variable ‘b0’ is ambiguous
02:19:21 <lambdabot>  Note: there are several potential instances:
02:19:21 <lambdabot>    instance [safe] GHC.Show.Show
02:19:23 <edwardk> au wants it in the opposite order for some reason
02:19:28 <jle`> > au (iso Sum getSum) foldMap [1,2,3]
02:19:29 <lambdabot>  6
02:19:31 <kazagistar> p0a: also, that redundant if thing is saying that { if x == y then startsWith xs ys else False } could be written as { x == y && startsWith xs ys }
02:19:59 <jle`> > au . iso Product getProduct . foldMap $ [1,2,3]
02:20:00 <lambdabot>  Couldn't match expected type ‘Control.Lens.Internal.Iso.Exchange
02:20:00 <lambdabot>                                  a b a (Data.Functor.Identity.Identity b)
02:20:00 <lambdabot>                                -> Control.Lens.Internal.Iso.Exchange
02:20:00 <lambdabot>                                     a b s (Data.Monoid.Product (Data.Functor....
02:20:00 <lambdabot>              with actual type ‘[t0]’
02:20:00 <p0a> ah wow :)
02:20:13 <edwardk> ala = au . _Unwrapping
02:20:21 <jle`> > au . iso getSum Sum . foldMap $ [1,2,3]
02:20:23 <lambdabot>  Couldn't match type ‘Data.Monoid.Sum b0’
02:20:23 <lambdabot>                with ‘Data.Functor.Identity.Identity t’
02:20:23 <lambdabot>  Expected type: (t0 a0
02:20:23 <lambdabot>                  -> Control.Lens.Internal.Iso.Exchange a b s b0)
02:20:23 <lambdabot>                 -> Control.Lens.Iso.AnIso s t a b
02:20:24 <jle`> huh
02:20:32 <edwardk> those are all separate args
02:20:38 <jle`> oh yeah
02:20:41 <jle`> i'm silly.
02:20:45 <edwardk> > au (iso getSum Sum) foldMap [1,2,3]
02:20:47 <lambdabot>  No instance for (GHC.Show.Show b0)
02:20:47 <lambdabot>    arising from a use of ‘M24170662495851724869183.show_M24170662495851724869...
02:20:47 <lambdabot>  The type variable ‘b0’ is ambiguous
02:20:47 <lambdabot>  Note: there are several potential instances:
02:20:47 <lambdabot>    instance [safe] GHC.Show.Show
02:20:54 <edwardk> > au (iso Sum getSum) foldMap [1,2,3]
02:20:56 <lambdabot>  6
02:21:12 <edwardk> > au (from _Sum) foldMap [1,2,3]
02:21:14 <lambdabot>  6
02:21:15 <jle`> > Last (Just 3)
02:21:16 <lambdabot>  Last {getLast = Just 3}
02:21:20 <edwardk> au should expect its argument in the wrong order
02:21:34 <jle`> > au (iso Last getLast) foldMap [Just 5, Nothing, Just 1]
02:21:35 <lambdabot>  Just 1
02:21:42 <jle`> > au (iso Last getLast) foldMap [Just 5, Nothing, Just 1, Nothing]
02:21:43 <lambdabot>  Just 1
02:21:45 <jle`> woo hoo
02:22:33 <jle`> :t iso id id
02:22:34 <lambdabot> (Profunctor p, Functor f) => p a (f t) -> p a (f t)
02:22:38 <p0a> merijn: I like it. go is your recursive helpername?
02:22:42 <efg> i made a fart
02:22:43 <jle`> :t iso id id id
02:22:44 <lambdabot> Functor f => f t -> f t
02:22:46 <jle`> :t iso id id id id
02:22:47 <lambdabot> a -> a
02:22:54 <jle`> > iso id id id id 1
02:22:55 <lambdabot>  1
02:23:05 <merijn> p0a: Yeah, stuff like "go", "helper", etc. are common recursive helper names
02:23:11 <jle`> :t iso id id id id id id id id id
02:23:12 <lambdabot> a -> a
02:23:24 <jle`> is that supposed to be something profound
02:23:25 <Iceland_jack> and 'aux'
02:23:29 <merijn> p0a: Since the definition is only like four lines it doesn't make a lot of sense to use very long name
02:24:35 <jle`> hm
02:24:38 <jle`> :t prism
02:24:40 <lambdabot> (Choice p, Applicative f) => (b -> t) -> (s -> Either t a) -> p a (f b) -> p s (f t)
02:24:57 <merijn> p0a: In my experience many people prefer short names for local functions as they make it easier to see the "shape" of a function
02:24:59 <jle`> :t prism Sum (return . getSum)
02:25:00 <lambdabot> (Choice p, Applicative f) => p a (f b) -> p (Sum a) (f (Sum b))
02:25:13 <jle`> > au (prism Sum (return . getSum)) [1,2,3]
02:25:14 <lambdabot>  Couldn't match expected type ‘(Data.Monoid.Sum a0 -> a0) -> e -> b’
02:25:14 <lambdabot>              with actual type ‘[t0]’
02:25:24 <p0a> merijn: I agree!
02:25:29 <merijn> p0a: Also, note that I changed the argument order of your helper to be able to eliminate explicit argument passing
02:25:36 <merijn> p0a: Although I just realised a nicer way
02:25:53 <jle`> > 1 ^? prism Sum (return . getSum)
02:25:55 <lambdabot>  Just 1
02:26:12 <merijn> p0a: See the new annotation: http://lpaste.net/104971
02:26:22 <jle`> > [1,2,3] & traverse . prism Sum (return . getSum) *~ 2
02:26:24 <lambdabot>  [Sum {getSum = 2},Sum {getSum = 4},Sum {getSum = 6}]
02:26:47 <merijn> p0a: Since it's a local function it has access to the arguments of the "parent" function, which means you don't have to recursively pass the "word" argument
02:26:50 <jle`> hm
02:26:51 <p0a> merijn: splendid
02:27:03 <merijn> Although I did forget to remove "word" from the recursive call >.>
02:27:10 <jle`> > [Left 1, Right 1] & traverse ^? _Left
02:27:12 <lambdabot>  Couldn't match expected type ‘[Data.Either.Either a0 b0] -> b’
02:27:12 <lambdabot>              with actual type ‘Data.Maybe.Maybe b2’Couldn't match type ‘(a1 -...
02:27:12 <lambdabot>                with ‘Data.Either.Either b2 c0’
02:27:12 <lambdabot>  Expected type: Control.Lens.Getter.Getting
02:27:12 <lambdabot>                   (Data.Monoid.First b2) ((a1 -> f0 b1) -> t0 a1 -> f0 (t0 b1...
02:27:17 <jle`> ok i'm done for the night
02:27:18 <jle`> ty edwardk
02:28:17 <merijn> p0a: In general it's good practice (especially while learning) to take a second and refactor your code to be as clean as possible once it works. You'll find that this kind of refactoring is very easy in haskell, since so much stuff is pure and you can trivially dump it into it's own function :)
02:29:04 <jle`> p0a: also, you have a safeguard against "refactoring wrong"
02:29:09 <tdammers> also, if you screw up, the compiler yells at you
02:29:18 <jle`> if you mess up refactoring something big, the compiler will let you know
02:29:35 <jle`> in other languages, you'd have to wait a few minutes for all your unit tests to run
02:29:52 <jle`> fsvo few
02:30:00 <tdammers> while in Haskell, all you need to do is wait a few minutes for the compiler to do its thing
02:30:03 <tdammers> :D
02:30:16 * tdammers has somewhat ancient hardware
02:30:16 <lwm> and scream at you cryptically!
02:30:31 <sgronblo> jle`: or just run your code, in all possible situations :)
02:30:45 <tdammers> I think a super-widescreen monitor put in portrait orientation would be helpful for ghc error messages
02:30:52 <jle`> sgronblo: that too. throw it into production while you're at it
02:31:04 <merijn> tdammers: Hah, clearly you never write C++
02:31:05 <jle`> that's the best way to get a wide variety of possible input :)
02:31:05 <tdammers> sgronblo: 100% input coverage! Including all effects!
02:31:20 <lwm> ha ... tdammers: every error would be a 'one-liner'
02:31:22 <tdammers> merijn: I do, occasionally, but I try to go easy on the boost
02:31:31 <tdammers> lwm: no no no, *portrait* mode
02:31:43 <merijn> tdammers: I have never used boost and I still trivially get more than 3 screens worth of errors
02:31:51 <sgronblo> dynamic programming lovers say the darndest things
02:31:56 <lwm> haha, oh no
02:32:10 <tdammers> merijn: true that... templates, huh
02:32:13 <danilo2> Hello! :) In GHC there is now a function "natVal" which results in Int from type level natural value. Is it possible to somehow push Integer to the type level natural ? I assume it is not possible, but maybe there is some magic?
02:32:36 <lwm> :t natVal
02:32:37 <tdammers> merijn: although when I do use C++, one of the reasons is usually that I want run-time polymorphism
02:32:37 <lambdabot> Not in scope: ‘natVal’
02:32:49 <danilo2> lwm: http://hackage.haskell.org/package/base-4.7.0.0/docs/GHC-TypeLits.html
02:32:53 <tdammers> merijn: when templates cover all my needs, might as well use Haskell
02:33:09 <jle`> that's why we have unsafeCoerce, tdammers
02:33:22 <tdammers> ugh
02:33:30 <merijn> tdammers: I would, but then I first have to write haskell wrappers for all the C++ stuff and my supervisor is yelling at me for results :p
02:33:41 <tdammers> results shmesults
02:33:48 <tdammers> tell him you are non-strict
02:34:02 <tdammers> you'll get him the results when he needs tehm
02:34:24 <jle`> <supervisor> seq
02:34:31 <jle`> deepSeq
02:34:53 <tdammers> "My supervisor is going deepSeq on me, does that qualify as sexual harrassment?"
02:35:07 <jle`> sequal
02:36:45 <p0a> thank you everyone for the help
02:41:13 <AfC> How do you tell `cabal configure` which of several .cabal files in a directory to use?
02:41:51 <merijn> AfC: Having multiple cabal files per directory is not really supported
02:41:57 <merijn> AFAIK
02:42:06 <AfC> merijn: Oh.
02:42:16 <AfC> merijn: That would explain why it's not working.
02:42:27 <AfC> merijn: [thundering splat noise as that idea hits the floor]
02:43:21 <tdammers> symlinks TTR!
02:44:38 <tremon> yesod examples contain code like this: defaultLayout $(widgetFile "template"). How should I parse this? Is $() a delimited operator?
02:44:57 <merijn> tremon: $() is Template Haskell
02:45:23 <tremon> ahh... that explains why I couldn't find it in yesod's api
02:45:25 <merijn> tremon: Basically, widgetFile is a haskell function that is run at compile time to generate Haskell code, that generated code is then used
02:46:20 <tremon> I've seen TH before, just haven't worked with it. At least now I know where to look. thanks!
02:46:22 <merijn> tremon: See this very minimal tutorial: http://www.hyperedsoftware.com/blog/entries/first-stab-th.html
02:46:28 <tremon> will do
03:04:42 <danilo2> Hello! Woudl somebody be so nice and tell me why the following code does not compile? http://lpaste.net/104979 I'm trying to create an instance, which will use the natVal of a type.
03:06:01 <trap_exit> in haskell, how do I define a type that is a subset of strings
03:06:08 <trap_exit> that it can only take on the form "#000000" to "#ffffff"
03:06:14 <trap_exit> basically it's a string that encodes  RGB color
03:06:58 <danilo2> trap_exit: Make a datatype out of it and use OverloadedStrings
03:07:00 <tdammers> trap_exit: you don't. Instead, you define a more structured type and provide conversions to and from string
03:07:17 <tdammers> and, indeed, implement IsString to provide OverloadedStrings if desired
03:07:50 <trap_exit> hmm
03:07:54 <piezoid> trap_exit: data Color = RGB Word8 Word8 Word8, then define Read, Show and OverloadedStrings
03:08:09 <trap_exit> data Color = Color RInt RInt RInt
03:08:16 <trap_exit> where Rint is a integer restrictred between 0 and 255
03:08:22 <trap_exit> how do I restrict RInt to 0 - 255 ?
03:08:22 <tdammers> Rint ~ Word8
03:08:32 <tdammers> Word8 is the type you're looking for
03:08:40 <tdammers> it's an unsigned 8-bit integer
03:08:41 <mikeplus64> (in Data.Word)
03:08:45 <trap_exit> Suppose I'm in a fucked up world where colors go 0 to 254
03:08:50 <trap_exit> can I define "integer in [0,254] " ?
03:09:00 <tdammers> unfortunately, no
03:09:01 <trap_exit> (just out of courisity concerning power of Haskell types)
03:09:15 <tdammers> even the 8-bit restriction is kind of weak
03:09:26 <tdammers> > print (1024 :: Word8)
03:09:28 <lambdabot>  <IO ()>
03:09:35 <tdammers> > show (1024 :: Word8)
03:09:37 <lambdabot>  "0"
03:09:40 <piezoid> Word8 is bounded by the machine implementation, just like in C
03:10:08 <mikeplus64> trap_exit: you can define a type like that, but you'd probably end up relying on something not bound between 0 and 254
03:10:14 <piezoid> but the Bounded class give you minBound and maxBound
03:10:18 <zwer> > 260 :: Word8
03:10:20 <lambdabot>  4
03:10:40 <tdammers> Bounded does not enforce boundaries at compile time though
03:11:00 <trap_exit> okay, one more question
03:11:06 <trap_exit> is it good or bad style to have QuickChecks inside of each *.hs file
03:11:10 <trap_exit> or should tests be part of different files ?
03:11:15 <mikeplus64> you could ofc write data NotQuiteWord8 = W0 | W1 | W2 | ... | W254
03:11:23 <trap_exit> mikeplus64: lol
03:11:26 <tdammers> mikeplus64: that, or church encoding
03:11:30 <trap_exit> then overload +, - * /
03:11:32 <danilo2> Ok I solved my problem! we need to use KnowNat e => ...  predicate
03:11:33 <mikeplus64> or a smarter version of that
03:11:40 <Yuu_chan> They say that Word8 is stored as a full 4- or 8-byte Word, my childhood is ruined
03:11:58 <tdammers> stored, yes - processed, no
03:12:02 <dottedmag> trap_exit: Check this out: http://stackoverflow.com/questions/4557394/how-do-you-use-the-bounded-typeclass-in-haskell-to-define-a-type-with-a-floating/4557531#4557531
03:12:16 <frerich> trap_exit: A common way to enforce such invariants is to use what Haskell calls a 'Smart Constructor': http://www.haskell.org/haskellwiki/Smart_constructors
03:13:10 <tdammers> yeah - it's still runtime, but it's as close as you'll ever get, probably
03:13:14 <frerich> trap_exit: It doesn't get rid of the run-time checking, but it moves the check to the caller such that your type can assert that the values are all sane just because they have the right time.
03:13:28 <frerich> trap_exit: I.e. you can catch errors earlier (and supposedly in a place where you can handle them).
03:15:10 <trap_exit> frerich: noted, thanks!
03:15:13 <tdammers> I think the key here is that once you have such a value, you can safely assume that it is valid
03:15:22 <tdammers> the only place where it can break is when constructing the values
03:16:15 <tdammers> but never while working with them
03:16:15 <frerich> tdammers: Maybe the new type-level literals can be used as well (see http://hackage.haskell.org/package/base-4.7.0.0/docs/GHC-TypeLits.html ) but I have no experience with that kind of stuff.
03:16:15 <tdammers> me neither
03:16:58 * hackagebot tidal-vis 0.1.4 - Visual rendering for Tidal patterns  http://hackage.haskell.org/package/tidal-vis-0.1.4 (AlexMcLean)
03:17:00 * hackagebot kmeans-par 1.5.1 - Sequential and parallel implementations of Lloyd's algorithm.  http://hackage.haskell.org/package/kmeans-par-1.5.1 (vi)
03:19:10 <piezoid> with the probability example, (+) can break the invariant (<= 1), but not (*)
03:32:00 * hackagebot twhs 0.1.0.3 - CLI twitter client.  http://hackage.haskell.org/package/twhs-0.1.0.3 (ShinichiroSuzuki)
03:43:06 <wolverian> Gah, Hackage pain. Every time I google a package, Google gives me a link to a specific version of the package in question on Hackage. It'd be great if it gave a link to the generic package page instead, i.e. the latest version. Are there Hackage admins here that could possibly make that happen?
03:44:34 <k00mi> wolverian: google can't really change specific results
03:44:40 <k00mi> wolverian: do you know about hoogle/hayoo?
03:46:36 <Cale> wolverian: Depending on which browser you're using, you might be able to add the hackage search as a search engine, and add a keyword for it, so that you can type hp <packagename> or something
03:46:37 <wolverian> Yes. I was thinking there was some SEO magic that could be done.
03:47:27 <dottedmag> Well, one could generate sitemap which omits all specific package versions, and only includes generic ones.
03:47:30 <wolverian> There are some meta tags at least to indicate what the canonical version of a page is. Perhaps that could be used here.
03:47:47 <merijn> wolverian: It's been suggested before, but no one with the skills have had the time to work on it, I think
03:48:13 <wolverian> merijn: Ok, thanks.
03:48:34 <wolverian> D'oh, I just now realized the code is on GitHub.
03:48:43 <Cale> oh, also: https://github.com/statusfailed/hackage-fu
03:49:04 <Cale> This will at least put a warning and link to the latest version when you stumble on to an old hackage doc
03:49:14 <wolverian> Yar, but it's something everyone has to do.
03:49:20 <wolverian> It'd be nice to fix the root problem for everyone.
03:50:00 <wolverian> https://github.com/haskell/hackage-server/issues/198
03:50:00 <Cale> It would be nice if google could just figure this out
03:50:03 <Cale> :)
03:50:05 <merijn> wolverian: Well, hackage is open source, so if you have any idea on how to tackle it ;)
03:50:20 <wolverian> merijn: Right! I put it on my todo list.
03:50:55 <merijn> wolverian: Also, if you have constructive suggestions, but no time, you could try convincing someone in #hackage to work on it
03:51:23 <dottedmag> Has Leksah development stopped?
03:51:24 <hamid> anyone has ever tried this https://github.com/begriffs/haskell-vim-now ? :P
03:52:07 <dottedmag> Uhm, git repo is active, but it didn't have any releases for 1.5 years.
03:59:47 <madjestic> dottedmag last time I checked (about 6-8 months ago), it was at the stage of GUI transition to QML or some other web gui solution.  Other than that, not much has been going on recently (1.5 years)
04:01:27 <merijn> dottedmag: tbh, imo Leksah and Yi are mostly used for experimentation and not as much as real viable editors
04:01:35 <dottedmag> I see
04:01:50 * dottedmag is going back to his lovely Emacs
04:02:42 <madjestic> dottedmag yep, that's how it usually goes
04:03:39 <merijn> dottedmag: The vast majority of haskellers use vim/emacs, then there are some that use stuff like Sublime/TextMate/EclipseFP, but I would recommend just using whatever you're already comfortable with
04:05:21 <Tjr> what if you're not comfortable with any (advanced) editor?
04:05:34 <merijn> Tjr: Learn one :)
04:05:50 <Tjr> which one?
04:06:08 <Tjr> (not the emacs-versus-vi question, but which one is best for haskell)
04:06:08 <dottedmag> Tjr: some people would recommend Vim, some people would recommend Emacs.
04:06:10 <SuperMind> > Left 3
04:06:12 <lambdabot>  Left 3
04:06:21 <merijn> Tjr: I would say experiment and try which ones you like. Saying either "emacs" or "vim" is just a flamewar opinion :)
04:06:24 <dottedmag> Both are ok
04:06:54 <Tjr> so you're saying that no other editor is as popular / good / adapted to haskell as those two?
04:07:02 <merijn> Tjr: This text from the author of Vim applies to pretty much any editor: http://www.moolenaar.net/habits.html
04:07:08 <merijn> Tjr: Most likely not
04:07:14 <Tjr> ok
04:07:27 <SuperMind> Why is it that ghci and lambdabot have no problem showing Left 3, but if i compile main = print $ Left (3::Int) I get an error about ambiguous type variable?
04:08:21 <Yuu_chan> SuperMind: even with explicit :: Int?
04:08:25 <SuperMind> yes
04:08:26 <SuperMind> try it
04:08:31 <merijn> SuperMind: lpaste code + error?
04:08:44 <SuperMind> thats literally the whole program
04:08:57 <SuperMind> main = print $ Left (3::Int)
04:09:06 <merijn> SuperMind: Oh, nvm
04:09:11 <merijn> SuperMind: I see the problem :)
04:09:13 <dottedmag> SuperMind: It does not know the second type for Either
04:09:13 <k00mi> SuperMind: because the type is Either Int a
04:09:19 <SuperMind> oh
04:09:24 <k00mi> SuperMind: but GHCi has extended defaulting rules
04:09:30 <SuperMind> ok
04:09:51 <merijn> "main = print $ (Left 3 :: Either Int ())" this should work
04:10:44 <k00mi> SuperMind: you can do :set -XNoExtendedDefaaultRules in ghci and you will get the same error
04:11:19 <Tjr> merijn: thanks. Frankly, I had no idea that vim has such capabilities.
04:12:23 <merijn> Tjr: Basically, I would say that learning any "advanced" editor is a task that will take months. I think it took me 4-6 months to become proficient in vim and I imagine similar applies to emacs, but in hindsight the effort is totally worth it
04:12:27 <SuperMind> i use vim
04:12:32 <SuperMind> with syntastic
04:12:40 <quchen> Is there a list of GHCi defaulting rules? Is it something like "default Show ()" or whatever the default syntax is?
04:12:41 <tdammers> Tjr: bottom line is, both vim and emacs are *extremely* powerful, and worth learning
04:12:43 <Tjr> probably.
04:12:48 <dottedmag> Speaking of editors, how does one setup Emacs to navigate to source/documentation from symbol at cursor?
04:12:51 <tdammers> vim's strongest point is how commands compose
04:13:04 <tdammers> emacs' strongest point is how it's utterly programmable
04:13:06 <merijn> Tjr: You just want a tight loop of "1) do something 2) notice this seems inefficient 3) research a better way 4) integrate new way into workflow", regardless of which editor
04:13:11 <madjestic> Tjr out of the box they both kind of suck.  Look on the web for what setups people are using and what you can get out of it with a reasonable effort (stuff like autocomplete, code-highlighting, tags generation, extras).  One of the things that I like about vim is hothasktags (recursive tags generation).  One of the thigns that I like about emacs is "structured haskell mode" by Chriss Done.
04:13:28 <tdammers> madjestic: disagree; my vim setup is pretty vanilla
04:13:39 <Tjr> What kept be from learning them so far is (1) underestimating vim, (2) emacs commands are poorly matched to the macbook keyboard layout, (3) mathematica comes with its own editor.
04:13:52 <merijn> I agree with tdammers, I have a handful of plugins and they're fairly optional
04:14:02 <tdammers> "comes with its own editor" is a usability antipattern in my book
04:14:25 <merijn> tdammers: To be fair, mathematica's editor has interactive graph visualisations and plotting functionality
04:14:34 <merijn> It's pretty damn impressive
04:14:46 <Yuu_chan> I use Emacs for about two years and still can't get used to it
04:14:46 <merijn> In an utterly different way than programming editors are :)
04:15:17 <k00mi> dottedmag: hasktags
04:15:32 <k00mi> dottedmag: https://github.com/haskell/haskell-mode/wiki/Haskell-Interactive-Mode-Tags
04:15:33 <SuperMind> i'm a vim power user, except not with the script language
04:15:44 <dottedmag> k00mi: thanks
04:15:49 <SuperMind> so a power user minus minus i guess?
04:15:51 <merijn> k00mi: In my experience tags files didn't work too great for haskell source :\
04:16:10 <Tjr> merijn: so far, I never seem to get results for step 3 (partly because of the keyboard issue) ;-|
04:16:17 <heudebeu> There are several vim plugin packs on github for haskell
04:16:19 <quchen> Mathematica's editor is impressive to look at and abysmal to work with ಠ_ಠ
04:16:24 <tdammers> merijn: fair enough. just a general notion though - implementing your own editor when you could build useful features instead is a waste of manpower
04:16:33 <dottedmag> tdammers: Something like this one? http://www.gnu.org/software/auctex/img/preview-screenshot.png
04:16:51 <merijn> tdammers: Sure, but Mathematica's usecase is "interactive math and plotting", rather than 'text editing'
04:17:08 <merijn> tdammers: So I would argue it's sufficiently different from, say, vim
04:17:16 <k00mi> merijn: true, hothasktags is better
04:17:44 <SuperMind> vim is unique or i should say that class of editors as there are a bunch of vi editors.. but they are on their own due to the moded interface concept... probably some ui designers would consider it a misfeature in the abstract, but it reduces the number of keys
04:17:50 <merijn> k00mi: I've tried about 4 or 5 haskell tag generators, but I wasn't really happy with any of them. I'm now using hdevtools "jump to definition" which appears to work better, but not a lot
04:18:22 <SuperMind> yeah, i don't have that enabled either
04:18:25 <k00mi> never tried that, I should
04:18:36 <SuperMind> i've not found a satisfying haskell tag generator
04:18:49 <SuperMind> but i probably didnt try the ones you use
04:19:30 <madjestic> tdammers it depends on what you mean exactly by "pretty vanilla"
04:20:04 <dottedmag> Tags are quite limited by nature and get stale all the time. hdevtools looks much more promising.
04:20:12 <SuperMind> i used to use vanilla vim, and if i wanted some powerful browsing open lexah
04:20:14 * mstevens feels like there's room in the world for a new text editor, although I admit I'm a little fuzzy what I think it should be
04:20:37 <SuperMind> well there is yi
04:21:04 <mstevens> I thought acme had some interesting ideas
04:21:05 <SuperMind> which has both a vim and an emacs mode
04:21:17 <merijn> mstevens: wanna see what the bright new future of haskell-like languages will look like?
04:21:26 <mstevens> merijn: ...maybe?
04:21:28 <warpy> ah. it is the haskell ide discussion again
04:21:45 <SuperMind> but yi probably isn't featureful enough to satisfy either audience
04:21:47 <merijn> mstevens: This is experimental to the point of not being usable for actual coding, but really cool to check out: https://github.com/Peaker/lamdu
04:21:55 <k00mi> I have high hopes for lamdu
04:22:02 <Tjr> feature request: turn those recurring discussions into a wiki, and make an easy way to point to it
04:22:30 <mstevens> merijn: ooh it looks pretty
04:22:41 <k00mi> Tjr: there is probably a page on the haskell.org wiki
04:22:59 <Tjr> k00mi: your comment highlights the "easy way to point" part
04:23:03 <merijn> mstevens: I've played with it several months back and seen a couple demos since, it's progressing nicely :)
04:23:40 <k00mi> Tjr: go to haskell.org, enter "editor" in search field, click first result
04:23:41 <k00mi> not that bad
04:23:46 <merijn> mstevens: It's much cooler to see in use than just some screenshots, as the screenshots really can't show how it can interactively do stuff like type based autocompletion :)
04:23:50 <tdammers> madjestic: I usually just install vim-nox from debian, dump my .vimrc and a handful of custom ftplugin rc's, and that's about it
04:24:33 <BBShortcut> Hello
04:24:35 <tdammers> dottedmag: what's that, gvim with latex rendered inline?
04:24:54 <Tjr> k00mi: the nethack people have a bot in their channel, so that you can say "!wiki editor", and it pops up a link. The main advantage is that the newbie being told stuff, will know which link.
04:25:27 <merijn> lambdabot has the @where command for storing stuff
04:25:29 <merijn> Like
04:25:31 <merijn> @where dmr
04:25:31 <lambdabot> http://www.haskell.org/haskellwiki/Monomorphism_restriction
04:25:41 <k00mi> Tjr: we have that for hackage, I don't know about the wiki
04:25:41 <merijn> @where editor
04:25:42 <lambdabot> I know nothing about editor.
04:25:47 <merijn> Ah, so that doesn't anything
04:25:50 <merijn> *have
04:26:04 <m00nlight_> When I enable haskell-unicode-input-method in haskell mode, Why some unicode character has effect in haskell( ->, subscript etc) while some other give some error like(<=, ==)
04:26:08 <dottedmag> tdammers: Emacs
04:26:19 <dottedmag> tdammers: I think I saw Octave mode which renders graphs inline as well
04:27:10 <tdammers> ah, right
04:28:14 <k00mi> emacs is *much* more powerful in that way than vim
04:28:18 <SuperMind> why do the lambdu code snippets not look like haskell tho?
04:28:36 <k00mi> SuperMind: it's not exactly haskell
04:28:45 <k00mi> SuperMind: http://peaker.github.io/lamdu/ see "why not haskell"
04:29:01 <merijn> SuperMind: Because it's not haskell :)
04:29:45 <merijn> Hence why I said "haskell-like" languages. The language is heavily haskell inspired, but Peaker felt that sticking strictly to haskell would make lots of nice things complicated to do
04:30:20 <SuperMind> so, this is a language that only works in one editor
04:30:36 <SuperMind> everyone must use lambdu or else?
04:30:36 <k00mi> it doesn't "work" at all so far ;)
04:30:45 <merijn> SuperMind: It doesn't ever really work at all :)
04:30:51 <merijn> s/ever/even
04:30:54 <SuperMind> yes but in concept
04:31:29 <k00mi> yes, but it's very close to haskell
04:31:38 <merijn> SuperMind: The idea is that the compiler and editor are integrated, but yes, since it uses structural editing it wouldn't be possible to edit using a text editor
04:32:37 <merijn> Once we have a uniform format for structural editing it's conceivable people implement other structural editors. The main premise however is that "editing code as text is dumb", but you can't change that if one of your requirements is "I should still be able to use any text editor to edit my code"
04:32:40 <SuperMind> one can integrate the editor with the AST etc without having it completely disallow users of other editors.
04:33:07 <merijn> SuperMind: Can you?
04:33:12 <k00mi> it wouldn't be hard to have a "export to haskell" function
04:33:20 <merijn> I'm not so sure, but I'd love to be proven wrong :)
04:34:59 <tdammers> SuperMind: strictly speaking, emacs-lisp is also a language that only works in one editor
04:35:23 <jle`> labview
04:35:27 <jle`> visual basic?
04:35:28 <dottedmag> tdammers: ELisp VM happens to be the same as reference editor implementation.
04:35:41 <dottedmag> tdammers: one can edit ELisp using, say ed(1)
04:36:08 <tdammers> merijn: I have a pretty strong opinion, namely that being able to use your favorite editor for everything has higher priority than editing code as something that is not text
04:36:21 <dottedmag> But then one can edit Lamdu using hexedit.
04:36:46 <SuperMind> the way i envision it, you'd want a machine readable file format, likely to get the benefits spread to every developer, but you should be able to use any editor that can understand that format.  And if the editors ui is ascii text, because hey some people still prefer it wouldn't you know... then that would be fine.
04:37:06 <jle`> labview
04:37:21 <dottedmag> Smalltalk also.
04:37:37 <dottedmag> But then Smalltalk guys had to implement a whole set of tools inside their "world".
04:37:40 <jle`> agda
04:37:43 <jle`> (hehe)
04:37:49 <k00mi> you could easily save the ADT you edit in Lamdu as normal ASCII
04:37:59 <merijn> tdammers: Right and that's fine, but that just means your fundamental assumptions of what coding should be conflicts with people like me who like Lamdu
04:38:34 <dottedmag> Well, editing code is only one of activities.
04:38:42 <merijn> tdammers: Which is fine, but also means that any criticism on the front is essentially "useless" towards the desired goal
04:38:47 <dottedmag> Version control comes to mind immediately.
04:38:55 <SuperMind> i think there is a lot to be said for text as a file format tho
04:38:55 <tdammers> merijn: well, I just think the bigger context is important - writing and running code are just two use cases out of many
04:39:10 <merijn> dottedmag: The thing is Peaker is integrated structural version control into the editor
04:39:11 <tdammers> hah, dottedmag beat me to it ;D
04:39:25 <merijn> dottedmag: So rather than doing dumb things like diffing text you diff ASTs
04:39:41 <tdammers> and no, "you don't need it, because everything is integrated into the editor/language" is a horrible prospect
04:39:59 <k00mi> I think text is a horrible format for code
04:40:02 <merijn> tdammers: Structural editing and structural version control orthogonal issues
04:40:18 <merijn> tdammers: Lamdu just tries to do both
04:40:36 <tdammers> yes. and that violates DOTR
04:40:55 <merijn> tdammers: I'm all in favour of developing portable/non-application specific formats for these things. But developing those first requires learning WHAT we actually want
04:41:04 <merijn> And the only way to learn what we want is prototyping
04:41:06 <tdammers> but actually, being the multi-language guy I am, having one common interface to *all* programming languages is really a big deal for me
04:41:16 <SuperMind> i don't think you need to make the language look all funky and graphical just to get all these named benefits
04:41:20 <tdammers> don't get me wrong, I do see the advantages
04:41:27 <merijn> DOTR?
04:41:34 <tdammers> Do One Thing Right
04:41:40 <merijn> SuperMind: As I said, I'd love you to prove me wrong
04:41:50 <tdammers> someone with a beard thought that was a good idea some 40 years ago
04:41:59 <dottedmag> tdammers: We are stuck with enormous amount of tools working on plain text, so DOTR is not feasible.
04:42:11 <merijn> tdammers: The problem is that doing structural version control without understanding the actual actions done is *really* hard
04:42:11 <SuperMind> if it looks like a textual version, then when you do convert it to a text representation, its just as easy to understand because its the same language.
04:42:25 <tdammers> yes, I see the problem
04:42:28 <merijn> tdammers: It's really hard to imagine doing structural version control without integrating it into the editor
04:42:39 <tdammers> yes, I know
04:42:58 <dottedmag> merijn: One can present the output as a smartish text diff anyway.
04:42:59 <SuperMind> you can do that without making the language impossible to display in ascii
04:43:11 <merijn> dottedmag: You can present it yes, but you can't do it on text
04:43:13 <madjestic> tdammers right. By saying "pretty much vanilla" I am thinking of a default install of vim, and by default there's not much besides vim-shortcuts and some sort of default syntax highlighting.  That falls far from being a sufficient IDE.
04:43:29 <merijn> I, for one, am happy that Peaker and co are experimenting with something different
04:43:43 <tdammers> madjestic: I don't need an IDE. My OS is me DE, and stuff integrates well enough
04:43:47 <merijn> Poopoo-ing prototypes is easy, but without building prototypes we'll never find the right solution
04:43:56 <tdammers> merijn: sure sure, completely agree
04:44:03 <tdammers> merijn: and I'm glad this is happening
04:44:11 <madjestic> tdammers well some people do need an IDE
04:44:23 <tdammers> merijn: I'm just sceptical, and I'm not going to jump on this train until I see something that I think could work
04:44:39 <tdammers> madjestic: to compensate for what?
04:44:42 <dottedmag> IDE is indispensable when one is trying to learn the language by reading the code and everything on the screen is unknown.
04:45:04 <dottedmag> Then fast shortcuts to definitions/documentation are badly needed.
04:45:06 <nclarke> merijn: Is that true (need editor for structural version control)? One can edit in text but have the storage format as an AST. Diffs etc are all done on the structural format. Text might reformat slightly on save, but that's not a major problem
04:45:14 <madjestic> tdammers that's offtopic
04:45:36 <tdammers> madjestic: has been for a while
04:46:08 <tdammers> madjestic: I'm just saying that plain vim is pretty much all you need to successfully write Haskell programs
04:46:09 <nclarke> You need a slightly richer AST (or some subsidiary files) for things like comments
04:46:16 <merijn> nclarke: I'm not saying you NEED to integrate in the editor, I'm just saying that past attempts have been barely usable due to not knowing the semantics of the edit
04:46:28 <dottedmag> nclarke: reformatting problem is already tackled by many HTML-and-so-on-kinda-visual editors, so not a big deal.
04:46:37 <SuperMind> the idea of the editor being aware of the AST is good of course, and making use of that to do structural versioning and so on.. all this stuff is great, but the idea of making the language not look like ascii is dangerous, it could end up like html or something.
04:46:46 <tdammers> merijn: you know, I'd actually prefer an approach that uses text as the common denominator and implements structural features on top
04:47:17 <merijn> tdammers: That adds many difficulties, like needing to handle parse errors, etc.
04:47:19 <tdammers> merijn: that way, you could define a textual interchange format, write a library that exposes the AST and a parser/serializer pair
04:47:38 <tdammers> you're going to have to parse and serialize eventually anyway
04:47:42 <merijn> Why?
04:47:44 <hexagoxel> AST is a tree, file system is a tree. so save source-code as a directory structure instead of a single file. all the node-files can be simple ascii though :D
04:47:49 <dottedmag> merijn: once the code loaded in IDE, it does not need to handle parse errors. Text is just a serialization format then.
04:47:50 <tdammers> 'cause last time I checked, filesystems store bags-of-bytes, not AST
04:47:51 <hexagoxel> imports are just symlinks :D
04:48:24 <dottedmag> hexagoxel: all hail Plan9
04:48:29 <merijn> tdammers: That just requires serialisation/deserialisation
04:48:38 <nclarke> merijn: I'm not quite sure how you get the semantics of the edit anyway. When you make a change, that gets parsed, and the resulting AST is diffed. The diff engine needs to understand the semantics, but that doesn't really need to be in the editor if you don't want it there
04:48:41 <tdammers> merijn: deserialisation, parsing, same thing
04:49:06 <tdammers> my point is, if you do it that way, you can still have your structural editor, and you can provide structural diffs
04:49:08 <dottedmag> One can leverage compiler for that anyway.
04:49:17 <tdammers> but you can maintain DOTR and textual interfaces and all the other UNIX goodness
04:49:43 <dottedmag> Especially if language prescribes single layout, like Go.
04:50:03 <merijn> nclarke: The editor is structural, you don't parse changes
04:50:15 <merijn> nclarke: Changes are things like "insert functioncall" "rename variable"
04:50:21 <nclarke> tdammers: "textual interfaces" is the probably the worst "best" feature ever.
04:50:47 <madjestic> tdammers have you tried structured haskell mode?
04:50:48 <tdammers> nclarke: textual interfaces between applications, not necessarily for humans
04:50:48 <SuperMind> my concern is i think source code should be more like markdown than html if at all possible, and if you accentuate the divorce between the ascii and the display you're tempting fate.
04:50:50 <nclarke> merijn: Ah, sorry, second sentence was describing the way I would envision it with a standard text editor front end
04:51:13 <tdammers> madjestic: no - frankly, after previous endeavours with other languages, going minimalist is pretty much a conscious choice
04:51:25 <nclarke> tdammers: "Textual interface between applications" is equivalent to "I type everything as String -> String"
04:51:36 <tdammers> nclarke: yes. Between applications, that does make sense
04:51:59 <tdammers> nclarke: strongly-typed cross-application interfaces have been tried, and look what we got
04:52:03 <tdammers> SOAP anyone?
04:52:09 * hackagebot htiled 0.1.2.0 - Import from the Tiled map editor.  http://hackage.haskell.org/package/htiled-0.1.2.0 (m09)
04:52:18 <dottedmag> tdammers: PowerShell, actually.
04:52:44 <jle`> comiler errors are just runtime errors in my coding process
04:52:57 <tdammers> jle`: higher-runtimed programming?
04:53:16 <merijn> nclarke: Right, with a textual interface you have the same problem that just context free structural diffing has
04:53:24 * tdammers does big-O complexity analysis on development workflows all the time
04:53:44 <merijn> nclarke: Hence the desire to really have structural operations in the editor so you can actually have semantic operations and track those in your version control
04:53:56 <nclarke> merijn: I disagree, because we already have a solution to inferring semantics from text. Namely, the language parser
04:54:04 <tdammers> merijn: as long as you're diffing AST's, I don't see why the serialization format matters
04:54:34 <jle`> i like to be able to indent my code in weird and unreadable ways, so having things just be AST is against my interests
04:54:36 <merijn> tdammers: Heh, where did I say that? I don't dispute you could easily persist an AST as text
04:54:45 <merijn> tdammers: It's just "useless" engineering work in a prototype
04:54:46 <SuperMind> lol jle
04:55:00 <merijn> tdammers: I just said you don't want to actually *edit* said textual serialisation
04:55:07 <jle`> i also have all my equals sign make a staircase
04:55:11 <jle`> let x = ...
04:55:17 <jle`>     y  = ...
04:55:21 <SuperMind> lol
04:55:24 <jle`>     z   = ...
04:55:33 <tdammers> merijn: well, my train of thought goes such that if I were to tackle such a project, I'd start with designing a language that maps to and from AST as smoothly as possible, including comments and everything
04:55:39 <merijn> nclarke: I have an AST where a subtree is deleted and another is added, they're 90% similar, can I infer this is just a move + edit or just code written from scratch?
04:55:42 <tdammers> then I'd write a parser and a serializer for it
04:55:56 <tdammers> and then I'd tackle the various parts of the intended workflow, one by one
04:56:00 <merijn> nclarke: If you track operations in the editor you would know. If you don't track operations it's impossible to decide without guessing
04:56:06 <tdammers> structural editor, structural diffing, etc.
04:56:07 <SuperMind> jle`, you could try to use the the white space to do ascii art
04:56:16 <jle`> i do that too
04:56:18 <tdammers> I'd still keep the textual interchange format
04:56:25 <merijn> tdammers: Or you just design an AST first and don't worry about text for now
04:56:38 <tdammers> merijn: yes, but then you can't separate the parts out as easily
04:56:40 <merijn> tdammers: If the other parts work retrofitting a grammer for an AST can always be done
04:57:08 <mornfall> merijn: the only catch is, no-one came up with a good structural editing metaphor yet
04:57:09 <dottedmag> tdammers: merijn: What if there is VFS kernel module which accepts serialized ASTs and stores them as text on write and produces AST by invoking language parser on read?
04:57:27 <mornfall> dottedmag: how is that different from an editor doing it?
04:57:34 <mornfall> dottedmag: it still has the same problems
04:57:47 <tdammers> merijn: the difference is that if you start with the AST only, you need to implement the entire toolchain before it becomes useful
04:58:02 <dottedmag> mornfall: I'm providing a hypotetical argument to show there is no difference between storing in a text format or custom AST serialization.
04:58:11 <tdammers> whereas if you start with the serializer/deserializer, you can keep using your trusted textual tools and replace them with structural tools, one by one
04:58:58 <tdammers> dottedmag: mornfall: the difference is being able to use an interface between the various parts of the toolchain that can be stored in a filesystem as-is
04:59:01 <merijn> dottedmag: I know that, I'm just saying that adding a textual representation adds nothing interesting to the prototype
04:59:14 <dottedmag> merijn: right, then I agree.
04:59:15 <merijn> dottedmag: Imagine two identical prototypes, one with text serialisation and one without
04:59:24 <dottedmag> In the prototype it does not matter.
04:59:33 <merijn> dottedmag: They're equally neat as prototypes, so the text serialisation is wasted engineering
04:59:44 <r444> Tjr: doesn't really matter, if you're comfortable with editor itself
04:59:45 <tdammers> merijn: not to the prototype itself, no. It just means you have to build the entire prototype before it becomes useful.
04:59:52 <merijn> tdammers: Why?
05:00:01 * frerich kinda regrets not spending enough time working with any single programming language to be able to justify learning tools which specialize in those specific languages beyond a certain point. Vim + half a dozen addons seems to just hit the sweet spot for this use case, but you always end up envying what e.g. Visual Studio can do to C# or lamdu to pseudo-Haskell. :-}
05:00:03 <r444> oops, i haven't scrolled channel log
05:00:03 <dottedmag> tdammers: Prototypes don't have to be useful. They are prototypes.
05:00:06 <r444> so slow
05:00:31 <tdammers> dottedmag: they have to be useful enough to judge whether a real implementation would be useful
05:00:42 <nclarke> merijn: I guess there are two issues. One is the granularity of diffs - if you repeatedly parse, the "big replacement" problem is less serious. Second point - is there a major need to understand move+edit vs write from scratch? They seem too coarse-grained to be useful - one cannot easily define compositional rules, for example.
05:00:57 <dottedmag> tdammers: not necessarily by providing the whole experience. One might write a prototype to check the particular aspect of the language.
05:01:01 <r444> Guys, what's the main difference between haskell and idris? It's kind of a thing in my twitter updates.
05:01:07 <tdammers> dottedmag: fair point
05:01:07 <dottedmag> s/language/workflow/
05:01:09 <r444> I mean idris
05:01:14 <r444> idris this, idris that
05:02:37 <merijn> nclarke: To your second point, yes. Because it helps reduce merge conflicts. Imagine two concurrent branches editing a function foo. One person adds some code to foo, the other moves foo to a different part of the program and makes some non-conflicting changes to foo. If you lose the "move + edit" semantics you cannot deduce you can merge both
05:02:57 <merijn> r444: Idris is dependently typed
05:03:08 <m00nlight_> can anyone told me how to use all unicode character in haskell-unicode-input-method?
05:03:13 <Tjr> r444: you had me reading chat log for context, too. Frankly, if I were a happy believer in $EDITOR, then I wouldn't have asked :-)
05:03:39 <r444> Tjr: i responded then scrolled, sry
05:03:42 <merijn> r444: In a dependently typed language the type of a function can depend (hence the name) on the *value* of it's inputs
05:03:58 <nclarke> merijn: Well, you don't necessarily know you can do that anyway. But I take your point :-)
05:04:09 <merijn> r444: i.e. you could have a functio "foo" that takes an Int and returns a Char if the int is 2 and Bool if the Int is anything else
05:04:28 <SuperMind> m00nlight_, i'm not sure what you are asking. do you have some code you could lpaste or something?
05:04:35 <merijn> nclarke: Sure, I wouldn't automaticaly merge that, but generating a nice diff to show it would be nice and you'd lose that ability
05:04:36 * Tjr wonders why nobody has yet written a haskell program whose "variables" are types and "executiion" is the compiler.
05:04:48 <merijn> Tjr: Too late, it's been done
05:05:07 * Tjr lives under a rock.
05:05:19 <r444> merijn: i'll definitely look into dependant types, but on the first though it can get quite messy, no?
05:05:40 <frerich> Tjr: What do you mean, I thought a Haskell program *is* a program for the compiler which instructs it what kind of output to generate!
05:05:43 <m00nlight_> SuperMind: I enable haskell-unicode-input-method, but some character like (<- , ->) works fine, but some will give error message "Not in scope: ≤"
05:05:44 <SuperMind> idris has different trade offs
05:05:47 <nclarke> merijn: It's true that if the editor only allows semantically understood changes then that's stronger than my suggestion. I still think you can do a lot with AST-based diff+merge, even if inferred, than you can with text diff+merge
05:06:09 <nclarke> Especially if the changes are granular enough
05:06:44 <SuperMind> m00nlight_, ghc doesnt have support for that character even with the extension
05:06:50 <Tjr> frerich: clearly, we need to design a language intended to write haskell code automatically.
05:07:00 <m00nlight_> SuperMind: so only haskell-platform?
05:07:06 <Tjr> ;-)
05:07:28 <m00nlight_> http://www.haskell.org/haskellwiki/Unicode-symbols
05:07:31 <SuperMind> haskell platform uses ghc as the compiler
05:07:36 <merijn> r444: Well, yes, people are still figuring out how to do dependently typed languages that are usable. But GHC is getting more and more dependently typed extensions, so everything is moving in that direction
05:08:07 <m00nlight_> SuperMind: but some unicode is OK like (→)
05:09:15 <dottedmag> merijn: editor can store those changelogs somewhere, like git stores history stashed away.
05:09:25 <SuperMind> m00nlight_, i think i missunderstood you, you're talking about user defined symbols, i think the problem then is probably that the symbol is not recognized as a symbol
05:09:42 <dottedmag> So the (not prototype) system might use change info to provide better merging if available.
05:10:23 <m00nlight_> SuperMind: http://qph.is.quoracdn.net/main-qimg-2bc1482a281cef7c2521a34c6e2cd1e4?convert_to_webp=true
05:10:30 <r444> merijn:  frankly it sounds to me like i shouldn't worry too much about this matter for a few years at least :-)
05:10:47 <tdammers> dottedmag: I think the idea is that version control is integrated into the editor such that when you delete a function, the action gets recorded as such
05:10:48 <r444> it's still interesting thought
05:10:54 <m00nlight_> SuperMind: Like this picture, there is a lot of unicode symbol in the code
05:11:02 <tdammers> instead of taking two snapshots and deriving the actions from the differences
05:11:33 <dottedmag> tdammers: Exactly. Too bad existing version controls are exclusively text-oriented. Can one extend git to store this metainfo in commit objects?
05:12:04 <tdammers> dottedmag: no; the difference is more fundamental than whether text is your serialization format or not
05:12:06 <SuperMind> m00nlight_, what happens when you try to use ≤  ?
05:12:11 * hackagebot either 4.3.0.1 - An either monad transformer  http://hackage.haskell.org/package/either-4.3.0.1 (EdwardKmett)
05:12:27 <m00nlight_> SuperMind:     Not in scope: ‘≤’
05:12:31 <tdammers> the difference is that something like git doesn't hook into editor actions directly, it can only see the resulting state
05:12:48 <dottedmag> tdammers: I understand that. One will need to emit all the changes into VC directly from the editor.
05:12:58 <tdammers> yes
05:13:08 <tdammers> except that I wonder whether it'd be all that useful
05:13:12 <dottedmag> Which also means A Stream Of Completely Useless Commits.
05:13:26 <mstevens> Not that I particularly want to promote Eclipse, but it had a sort of auto-version-control thing where it'd record history for you forever even if you didn't have a VCS setup
05:13:28 <SuperMind> m00nlight_, that's not a unicode issue, that's the fact that it doesn't have that function defined
05:13:42 <warpy> why is hp moving to shake?
05:13:42 <tdammers> frankly, whether you deleted a method and then wrote a similar method elsewhere, or moved the method and modified it, doesn't interest me
05:14:11 <m00nlight_> But I thought it should map to some standard Haskell function, if I enable UnicodeSyntax
05:14:15 <tdammers> the benefit of structural diffing, to me, would be in a system that understands syntax a bit more than git does
05:14:48 <dottedmag> tdammers: hooking it might be more granular: editor spews out changelog somewhere, and it gets committed together with the code changes eventually.
05:14:56 <dottedmag> Version control / editor may use it for better diffing.
05:15:11 <tdammers> the stuff I'd want can be achieved with a language-aware diff tool, I think
05:15:12 <dottedmag> But revert to plain version comparison if there is no changelog.
05:15:40 <m00nlight_> SuperMind: But I thought it should map to some standard Haskell function, if I enable UnicodeSyntax
05:15:40 <dottedmag> Or, say, versions have syntax errors.
05:15:52 <tdammers> The information I'm after is "this new version has a function called foobar() that wasn't there before"
05:16:08 <tdammers> I don't care how it got there
05:16:13 <SuperMind> m00nlight_, just put a line somewhere in your file (≤) = (<=)
05:16:31 <tdammers> But I do care that a *function* was introduced
05:17:19 <SuperMind> m00nlight_, there are only a smalll set of automatic mappings defined here: http://www.haskell.org/ghc/docs/7.2.1/html/users_guide/syntax-extns.html
05:17:42 <jle`> m00nlight_: there's a library on hackage
05:17:51 <merijn> r444: I think dependent types are really cool to learn, but they're not directly practical right now. Although Idris goal is explicitly to make dependent types useful for haskell programmers
05:18:00 <jle`> that defines things like those unicode operators for you
05:18:04 <jle`> like not, el, etc.
05:18:13 <jle`> *elem
05:19:03 <m00nlight_> SuperMind: jle`: I install both base-unicode-symbol and containers-unicode-symbol
05:19:20 <SuperMind> and imported the module?
05:20:07 <SuperMind> m00nlight_, import Prelude.Unicode
05:20:55 <mbrock> re: semantic diffs, there's a Smalltalk version control system called Monticello that operates purely on Smalltalk structures (classes, methods, etc)
05:21:01 <m00nlight_> SuperMind: Thanks, import Prelude.Unicode works
05:21:07 <mbrock> some basic info: http://wiresong.ca/monticello/v2/docs/concepts.html
05:22:24 <mbrock> of course, Smalltalk's dynamic evaluation model discourages text-based tools. the concept of "source code" isn't even clearly defined
05:23:18 <SuperMind> i never learned smalltalk
05:23:34 <mbrock> it might be the polar opposite of Haskell :)
05:23:43 <SuperMind> heh
05:24:27 <pjdelport> Does that make Haskell big talk?
05:24:54 <alpounet> java would be "bigtalk"
05:25:05 <mbrock> or an Intimate Conversation
05:26:22 <SuperMind> i have wonder if it would be useful to have other languages running on ghc's rts
05:26:43 <SuperMind> so the integration would be seemless
05:26:55 <SuperMind> making haskell the new .Net hah
05:28:15 <tdammers> mbrock: the polar opposite of Haskell is PHP
05:31:33 <arj> can I somehow tell ghci to print the right hand side of type aliases instead of the alias name?
05:31:46 <arj> when evaluating :t someexpression
05:31:47 <benzrf> arj: press :i alias
05:31:53 <benzrf> arj: but otherwise probably not
05:31:54 <benzrf> u_u
05:32:31 <arj> benzrf: thanks.
05:32:58 <benzrf> arj: let me guess.... lens
05:33:43 <edwardk> I think lens must have killed benzrf's dog ;)
05:33:54 <arj> benzrf: hehe, no you are wrong ;-) I encoded a CPS transformation and write the terms in haskell to check if I did it correctly. it has nothing to do with haskell actually
05:34:14 <merijn> arj: Fortunately for you, benzrf is wrong, assuming you have a recent (7.6+) GHC
05:34:26 <arj> merijn: now I am currious
05:34:27 <merijn> arj: Use ":kind!" to fully evaluate a type
05:35:17 <merijn> For example ":kind! String" prints "String :: * = [Char]"
05:36:11 <arj> merijn: hmm but this only works on types. I wanted something to work on expressions, i.e. a :kind! that works on the level of :t
05:36:21 <BBShortcut> 3m
05:36:21 <benzrf> merijn: :O
05:36:31 <benzrf> :k!
05:36:34 <benzrf> :k
05:36:38 <benzrf> :k Int
05:36:39 <lambdabot> *
05:36:40 <benzrf> :k! Int
05:36:47 * benzrf slaps lambdabot around a bit
05:37:03 <arj> :kind! Int
05:40:09 <merijn> lambdabot doesn't support any of ":i" ":k" ":kind!", etc.
05:40:18 <merijn> In fact, the ":t" is just a hardcoded hack
05:42:15 * hackagebot jwt 0.3.0 - JSON Web Token (JWT) decoding and encoding  http://hackage.haskell.org/package/jwt-0.3.0 (StefanSaasen)
05:46:02 <benzrf> i had an observation
05:46:14 <benzrf> when i go on wikipedia and look at a page about math or something
05:46:24 <benzrf> there will be like 3 big concepts i have no idea about
05:46:32 <benzrf> so i click those links with the intentino of learning then coming back
05:46:36 <benzrf> then that happens recursively
05:46:47 <benzrf> so browsing wikipedia is like a recursively defined function
05:46:56 <benzrf> but my brain's stack is tiny :(
05:47:01 <benzrf> so it overflows very quickly
05:47:10 <benzrf> and i never return
05:47:32 <benzrf> otoh, if i already know what something is, that's vaguely remniscent of memoization of the function that the link is
05:47:38 <benzrf> i have the result cached in my brain
05:47:38 <benzrf> :v
05:48:44 <awestroke> benzrf: that's why there is simple.wikipedia.org/wiki/x
05:49:36 <benzrf> awestroke: but is there for the axiom of choice
05:49:38 <benzrf> q.q
05:49:52 <edwardk> benzrf: just keep drilling. if you don't come back up that's fine. eventualy you find something you cana fit in your head and learn. next time you do this exercise if you hit the level above that thing you can stop a level earlier
05:49:55 <benzrf> huh there is
05:50:00 <benzrf> edwardk: i know :-)
05:50:05 <awestroke> benzrf: http://simple.wikipedia.org/wiki/Axiom_of_choice ?
05:50:22 <benzrf> edwardk: that's how i know what a group isomorphism is
05:50:26 <benzrf> also irc help
05:50:31 <edwardk> benzrf: iterative deepening is a powerful tool. =)
05:50:47 <Yuu_chan> There is no http://simple.wikipedia.org/wiki/Monad !
05:50:53 <benzrf> hmmmmm
05:51:00 <benzrf> edwardk: it is really more like iterative shallowening
05:51:03 <edwardk> yeah
05:51:08 <pjdelport> ~ don't be shocked by the tone of my voice ~ check out my new axiom, axiom of choice ~
05:51:09 <edwardk> was going to say i guess its more or less the dual
05:51:12 <awestroke> Yuu_chan: I find the en.wikipedia article on monads simple enough
05:51:45 <edwardk> djdelport
05:52:19 <tdammers> First Law of Monad Tutorials: the difficulty in understand monads is proportional to the number of monad tutorials read
05:52:21 <benzrf> shit i have to go
05:54:31 <Philonous> tdammers, I always thought "monad tutorials" where a non-issue. But now I've actually met people who turned away from Haskell because they thought we couldn't explain a "core concept" like monads in a way that's understandable without a PhD. So it turns out Moand tutorials are actually doing real harm
05:54:52 <bitemyapp> Philonous: yeah, we know.
05:55:05 <bitemyapp> Philonous: that's why we mock monad tutorials, those that write them, and those thinking about writing them.
05:55:35 <bitemyapp> Philonous: the campaign of terror has been moderately successful in driving monad-tutorial authors underground, but our vigil will never end.
05:55:48 <Philonous> bitemyapp, It was clear to me that they are silly and misguided, but I didn't grasp that they are doing actual dammage.
05:56:09 <bitemyapp> Philonous: OTOH, everything about the pedagogic process has improved in the last several years
05:56:23 <bitemyapp> so, it doesn't really matter because you don't explain monads by themselves.
05:56:28 <bitemyapp> we know better. we know you start with functors.
05:56:33 <hayashi> monads are easy, they're just Venus flytraps
05:57:19 <nclarke> Which have eaten burritos
05:57:27 <Yuu_chan> In a space suit!
05:57:52 <awestroke> "A monad is just a monoid in the category of endofunctors, what's the problem?" <- wouldn't that be an applicative?
05:57:56 <nclarke> And everybody knows that space suits are just monoids in the category of endofunctors
05:58:25 <bitemyapp> awestroke: nope.
05:58:37 <bitemyapp> awestroke: there's no join on applicative.
05:58:46 <tdammers> Philonous: yes, exactly
05:59:04 <tdammers> for me, the epiphany came when I realize that "Monads are like ____" is detrimental
05:59:27 <tdammers> A monad is just a typeclass that provides bind, return and fail. That's all there is to it.
05:59:30 <phaazon_> hi!
05:59:33 <bitemyapp> tdammers: AGK
05:59:35 <bitemyapp> tdammers: no fail!
05:59:37 <nclarke> fail! fail!
05:59:39 <bitemyapp> tdammers: bad >:[
05:59:41 <tdammers> AAAAAAAAA
05:59:42 <tdammers> yeah
05:59:43 <tdammers> ok
05:59:44 <bitemyapp> tdammers: that's MonadPlus
05:59:46 <phaazon_> is there anyone using this https://hackage.haskell.org/package/data-reify-0.6/docs/Data-Reify.html ? I’d like to understand how to make an instance
05:59:49 <bitemyapp> tdammers: bad.
06:00:01 <merijn> phaazon_: Try packdeps.haskellers.com/reverse ?
06:00:07 <bitemyapp> raichoo1: recycling for efficiency?
06:00:12 <tdammers> fine, bind and return, and a wart we don't talk about
06:00:19 <bitemyapp> raichoo1: I see everything  *_*
06:00:20 <Philonous> tdammers, Well, bad analogies and misleading antropomorphisms seem to have a rich tradition in the OO world :>
06:00:22 <bitemyapp> tdammers: nope, still sucks.
06:00:24 <phaazon__> dammit timeout, anyone?
06:00:29 <raichoo1> raichoo1: huh?
06:00:32 <raichoo1> arg
06:00:51 <bitemyapp> tdammers: fmap, return, join.
06:00:56 <Yuu_chan> OO models the real world blah blah
06:00:58 <bitemyapp> tdammers: bind is a silly way to explain it.
06:01:12 <tdammers> bitemyapp: in hindsight, yes, probably
06:01:18 <Yuu_chan> So should burritos, er, monads
06:01:46 <raichoo1> bitemyapp: Nope just slightly amused that this topic still pops up ;)
06:01:49 <merijn> phaazon_: Try: packdeps.haskellers.com/reverse ?
06:02:09 <Adeon> where's the original burrito analogy
06:02:13 <phaazon__> merijn: thank you
06:02:16 <bitemyapp> bind's a useful operator, I use it all the time, but it's a misfit pedagogically and should be derived by the learner from fmap and join.
06:02:21 <tdammers> the burrito analogy always made the most sense to me
06:02:23 <merijn> bitemyapp: I disagree, bind is good because it shows why you can't "escape" a monad
06:02:25 <tdammers> until I understood it
06:02:25 <Adeon> and is there a inside-out turned burrito analogy for comonads
06:02:31 <Yuu_chan> @google monad burrito
06:02:32 <lambdabot> http://blog.plover.com/prog/burritos.html
06:02:32 <lambdabot> Title: The Universe of Discourse : Monads are like burritos
06:02:34 <bitemyapp> raichoo1: I teach Haskell, I'm immunized.
06:02:45 <merijn> bitemyapp: And it shows why not every Applicative can be a monad (i.e. Const a)
06:02:47 <edwardk> comonads are christmas trees
06:02:48 <phaazon__> merijn: I really think the single thing Haskell lacks is a proper way to represent entity semantics
06:02:58 <bitemyapp> merijn: ehhhh, that's not a good way to communicate that.
06:03:10 <Philonous> tdammers, "Monads are a neat abstraction that builds on the concepts of type classes, higher-kinded polymorphism and higher-order functions, and you should go and thoroughly understand those concepts before you ask what monads are, because otherwise the answer will be gibberish"
06:03:11 <raichoo1> bitemyapp: I do as well, however it still feels odd :D
06:03:12 <bitemyapp> merijn: I prefer the way Yorgey does it.
06:03:14 <merijn> bitemyapp: Not to communicate it, but to prove it
06:03:26 <bitemyapp> merijn: I'm concerned with pedaoggy.
06:03:29 <bitemyapp> ...pedagogy.
06:03:50 <edwardk> you can redecorate the tree with extend, changing out ornaments for other things, but you don't get to change its shape
06:03:51 <tdammers> Philonous: they're a neat abstraction, but you don't need to understand all that stuff to develop a good intuition about monads
06:04:16 <tdammers> edwardk: comonads are boyfriends
06:04:55 <edwardk> tdammers: no matter how many times you extend them you don't get to change the number of holes they have? I think that is a rather risque analogy.
06:05:04 <tdammers> hm hm
06:05:26 <merijn> Is it that time of the night/day? >.>
06:05:31 <tdammers> I was going to go with "you can decorate them, but you don't get to change their shape"
06:05:37 <edwardk> merijn: apparently i need more sleep ;)
06:05:45 <edwardk> tdammers; hahahaha
06:08:28 <Philonous> tdammers, Well, you definitely have to understand higher-order functions in order to understand (>>=). To understand why they make sense as an abstraction you need to be able to understand what higher-kinded polymorphism is. Maybe you don't need type classes to explain what a Monad is. But it definitely helps to understand them in the context of Haskell.
06:09:36 <merijn> My personal opinion is that one should first adequately cover 1) types, 2) typeclasses and 3) higher-order functions before Monads (in haskell) can make sense. And a lot of people get confused by monads by skipping one or more of those three
06:09:41 <bitemyapp> Philonous: >>= you mean?
06:10:20 <bitemyapp> merijn: products, sums, recursive types, parametricity, typeclasses, functor, applicative, monoid, monad.
06:10:42 <bitemyapp> merijn: semigroup, magma, alternative, contravariant, monadplus, etc etc etc
06:10:43 <merijn> Parametricity I would put under "adequately covering types"
06:11:02 <bitemyapp> merijn: yes but I'm being more effective at communicating.
06:11:05 <awestroke> is there something like "compare" for Eq?
06:11:23 <merijn> awestroke: Eh, == ? :p
06:11:38 <awestroke> I want "compare `on` fst" for eq
06:11:39 <Philonous> merijn, Heh, at least one who agrees with me :>
06:11:41 <merijn> awestroke: That question doesn't really make sense?
06:11:50 <merijn> awestroke: "(==) `on` fst"?
06:11:52 <Philonous> merijn, I just like to stress the "higher-kinded polymorphism" bit
06:11:58 <awestroke> ah, cool
06:12:02 <awestroke> :t on
06:12:03 <lambdabot> (b -> b -> c) -> (a -> b) -> a -> a -> c
06:12:12 <awestroke> oooh
06:12:19 * hackagebot cprng-aes-effect 0.1.0.2 - Run random effect using cprng-aes, a crypto pseudo number generator.  http://hackage.haskell.org/package/cprng-aes-effect-0.1.0.2 (ibotty)
06:12:21 * hackagebot log-effect 0.3.0.1 - An extensible log effect using extensible-effects  http://hackage.haskell.org/package/log-effect-0.3.0.1 (ibotty)
06:12:23 * hackagebot crypto-random-effect 0.2.0.3 - A random effect using crypto-random  http://hackage.haskell.org/package/crypto-random-effect-0.2.0.3 (ibotty)
06:12:23 <alpounet> awestroke: it's 'on' who's doing the magic, not compare. So you can use it in *many* situations
06:12:25 * hackagebot mysql-effect 0.2.0.2 - An extensible mysql effect using extensible-effects and mysql-simple  http://hackage.haskell.org/package/mysql-effect-0.2.0.2 (ibotty)
06:12:27 * hackagebot apiary-clientsession 0.9.0.1 - clientsession support for apiary web framework.  http://hackage.haskell.org/package/apiary-clientsession-0.9.0.1 (HirotomoMoriwaki)
06:15:34 <ozgura> when writing an Arbitrary instance for QuickCheck, how does one control the "depth" of the generated value?
06:15:43 <Yuu_chan> What's better, foldr ((+) `on` someField) 0 listOfRecords or sum $ map someField $ listOfRecords?
06:15:48 <ozgura> I am working on something like an expression ADT
06:16:19 <pjdelport> Yuu_chan: The latter, surely.
06:16:30 <ozgura> is `sized` the guy to use? (http://hackage.haskell.org/package/QuickCheck-2.7.5/docs/Test-QuickCheck.html#v:sized)
06:17:09 <pjdelport> Yuu_chan: foldl' instead of foldr if you *really* want the former.
06:17:17 <mbrock> ozgura: yes, that's probably what you want
06:17:19 <merijn> Yuu_chan: "sum . map someField $ listOfRecords"
06:17:24 <mbrock> ozgura: see http://www.cse.chalmers.se/~rjmh/QuickCheck/manual_body.html#15
06:17:57 <mbrock> ozgura: (the section below, "Generating Recursive Data Types", is exactly what you want)
06:18:01 <ozgura> mbrock: oh the example there is very helpful
06:18:03 <ozgura> yes that one
06:18:06 <ozgura> thanks!
06:18:31 <pjdelport> sum $ someField <$> listOfRecords
06:18:59 <Yuu_chan> merijn: is there a difference? I once used this form, then decided to write in more uniform way
06:19:37 <merijn> Yuu_chan: Yes, due to the associativity of . you can splice arbitrary sections of a (.) composition into their own name and things will work, the same does not hold for ($)
06:19:49 <merijn> There was nice blogpost illustrating this, but I can't find it
06:20:27 <merijn> In general I would say that you should replace only use one $ operator per expression, replacing pipelines of $ with . and a single $ at the end
06:20:29 <Yuu_chan> Interesting point
06:20:44 <merijn> s/replace//
06:20:48 <merijn> Typing is hard >.<
06:26:27 <tdammers> hence, structural code editing
06:26:31 * tdammers ducks
06:26:41 <Philonous> Wow, ghc now uses over 800MB of RAM. I used to be able to run 4 in parallel.
06:27:58 <awestroke> Philonous: some people have 16GB of RAM
06:28:06 <Philonous> I wish
06:28:15 <Philonous> I could run X and ghc at the same time!
06:28:24 <ciaranm> Mem:          503G        17G       486G         0B       1.6G        10G
06:28:40 <awestroke> ciaranm: what does that mean?
06:29:30 <ciaranm> awestroke: it means i have half a terabyte of RAM, and am suggesting that Philonous has a small epenis
06:29:50 <Philonous> ciaranm, I beg your pardon?
06:30:02 <awestroke> ciaranm: what's the command?
06:30:06 <ciaranm> awestroke: free -h
06:31:36 <awestroke> Philonous: you can get 1GB RAM sicks for 12$ (and free shipping) in the US
06:31:43 <awestroke> sticks* :)
06:32:47 <deweyvm> should i bother trying to get cabal/haskell running on a 256MB ram vps? cabal install cabal-install is taking about 10 hours and counting so far
06:33:27 <awestroke> deweyvm: I'd compile with static linking and just send the finished executable to the vps
06:33:59 <deweyvm> i'd probably just get a slightly nicer vps then, what would the minimum recommended memory be?
06:35:06 <deweyvm> like would 512 be enough or sohuld i go for a gig?
06:35:45 <merijn> deweyvm: For doing what?
06:35:56 <deweyvm> compiling programs with cabal
06:36:50 <merijn> 512 will probably be too small for bigger stuff like Yesod
06:37:09 <merijn> deweyvm: But you could just compile locally and just copy the binary to your VPS, thus avoiding the problem?
06:37:15 <deweyvm> yeah i might want to play with that too
06:37:21 <deweyvm> im on windows though
06:37:28 <deweyvm> on my local machine
06:37:38 <merijn> deweyvm: Install VirtualBox and a linux guest, compile in VM? :)
06:37:58 <deweyvm> i think id rather shell out $15 or something to play around for a month :P
06:38:22 <merijn> If you have a fairly recent machine (i.e. after 2006 I guess?) the virtualisation support should have it compiling at near full speed
06:38:43 <merijn> deweyvm: You can go much cheaper if you don't need a lot of RAM for compilation
06:38:56 * merijn is currently paying $4.50 or so a month for a VPS
06:39:02 <deweyvm> my current one was $12 for 6 months :D
06:39:14 <deweyvm> just gotta find those deals
06:39:26 <xmj> do you guys run off freebsd?
06:39:30 <deweyvm> okay, thanks for the tips!
06:39:41 <merijn> xmj: I used to
06:40:08 <xmj> merijn: can you run it on the 4.50 hoster?
06:41:12 <merijn> xmj: No, I really just wanted a VPS in the US to tunnel around region restricted sites, so I just went with the cheapest least-effort host. But I've seen plenty sub-10 FreeBSD hosts, so it should be possible to get a good price
06:41:42 <xmj> but but but
06:41:47 <xmj> i want to run 11 on it!
06:42:07 <merijn> xmj: I meant sub-10 dollar :)
06:42:07 <awestroke> It's be nice to be able to cross-compile haskell  to other architectures (assuming static linking). Like compiling an x32 executable from my x64 laptop
06:42:59 <xmj> aah
06:43:03 <Philonous> awestroke, I think you can, actually.
06:43:03 <xmj> sure.
06:43:16 <tdammers> lowendbox.com
06:43:21 <awestroke> Philonous: I can't find any information on it
06:43:40 <tdammers> lists the cheapest current vps deals
06:43:48 <merijn> tdammers: Yeah, that's where I got mine
06:43:48 <tdammers> and sometimes even dedicated boxes
06:44:08 <tdammers> they had a dedicated ARM server offer that was cheaper than many vps
06:44:25 <tdammers> IIRC the service went bonkers after just a few weeks though
06:46:25 <awestroke> Philonous: no hints in "man ghc". Can I dump llvm and send a .llvm file for later compilation maybe?
06:48:13 <Philonous> awestroke, I've never actually tried it. Have you seen https://ghc.haskell.org/trac/ghc/wiki/Building/CrossCompiling ?
06:48:34 <awestroke> ah
06:49:15 <piezoid> awestroke: ghc is making some speculation about register pinning, i think. (in registerised mode)
06:50:04 <rwbarton> Also, the sizes of everything.
06:50:14 <rwbarton> You can build a cross-compiler, though.
06:50:50 <awestroke> It'd be nice if ghc supported cross-compilation out of the box
06:51:10 <merijn> awestroke: It's work in progress
06:51:54 <awestroke> merijn: cool. Do you know where I can read more?
06:52:03 <rwbarton> an x86_64 -> i686 cross-compiler should "just work" if you build from source with the right configure options
06:52:05 <benzrf> is there an api for programatically using the ghci debugger
06:52:13 <benzrf> rwbarton: do you mean i386, or
06:52:24 <rwbarton> sure
06:52:41 <merijn> awestroke: The GHC wiki/trac
06:53:23 <rwbarton> awestroke, specifically that page Philonous linked above
06:54:06 <awestroke> rwbarton: Ah, yeah, I was thinking of reading about / following the internal discussions on the cross-compilation work
06:54:51 <rwbarton> oh
06:55:26 <merijn> awestroke: You can just subscribe to the ghc mailing lists
06:55:40 <merijn> awestroke: That and #ghc are the main avenues for keeping track of that stuff
06:57:42 <awestroke> merijn: thanks
06:57:53 <tdammers> meanwhile, I just have an i386 vm around for building
06:58:20 <tdammers> ssh kif 'cd devel/projectname; git pull && make && ./deploy.sh'
06:58:40 <tdammers> make coffee, come back, new version online
06:58:47 <tdammers> that's how development should be, always
07:00:09 <Philonous> tdammers, You could have a "deploy" branch and a cron job that automatically pulls from it, builds, runs tests and if they pass deploys ;)
07:00:10 <awestroke> tdammers: hmm I guess I could use a vagrant box
07:01:03 <crazydave> I have a rookie error with the FFI: I'm trying to call a c function and I'm getting the error "function_name not in scope"
07:01:49 <crazydave> I am thinking that ghc can't find the header file since it is in another directory .... how do I tell it where to look?
07:02:00 <alpounet> crazydave: do you have a foreign import somewhere? have you enabled the FFI extension?
07:02:49 <tdammers> Philonous: personally, I think using version control to trigger deployment is an anti-pattern
07:03:02 <crazydave> so I have {-# Language ForeignFunctionInterface #-} at the top of the file
07:03:12 <tdammers> it's fine to auto-deploy to a test server, but not production, IMO
07:03:35 <tdammers> anyway, this is for personal projects only
07:03:45 <crazydave> and also foreign import ccall unsafe "file.h function_name" c_function_name
07:04:33 <tdammers> for work stuff, the procedure is more like git pull, but using the wrong user, then sudo git pull, then curse, call me, chown everything to the correct user, git pull again, fix conflicts, then use a tool called BeyondCompare to manually copy the desired changes over
07:04:38 <rwbarton> crazydave: let's clarify
07:04:39 <tdammers> and don't get me started on databases
07:04:44 <rwbarton> there "function_name" needs to be the name of the C function
07:04:52 <alpounet> crazydave: if file.h isn't in a standard dir, you may want to give GHC the "-I/path/to/include/dir" option
07:04:59 <rwbarton> "c_function_name" is then the name of a Haskell function (or IO action)
07:05:01 <crazydave> auto-deploy to production on git check-in sounds like a great way to have people test their code before checking in
07:05:15 <crazydave> rwbarton: correct.  That's what I have
07:05:26 <rwbarton> can you paste the actual error?
07:06:24 <crazydave> Bvls.hs:3:9: Not in scope: `bvls'
07:06:33 <crazydave> bvls is the name of the C function
07:06:45 <rwbarton> you need to call c_bvls
07:06:48 <rwbarton> if that's how you imported it
07:07:14 <crazydave> hmm ... oh ... maybe a typo ... I knew that
07:07:48 <crazydave> oh, that's it :( ... oops ...
07:08:05 <crazydave> that was much simpler than all the other things I tried
07:21:30 <benzrf> hmmm
07:21:54 <benzrf> is there a way to get ghc to, given an unsafe IO function, never ever memoize the return value?
07:22:04 <benzrf> i.e. every single call should evaluate it
07:22:08 <benzrf> like functions in strict languages
07:22:15 <benzrf> *strict effectful langs
07:23:20 <alpounet> unsafe IO function? you mean something than calls unsafePerformIO to make the program believe it's a pure value?
07:23:26 <alpounet> s/than/that/
07:23:26 <benzrf> yeah
07:23:36 <alpounet> benzrf: then you shouldn't be using unsafePerformIO
07:23:41 <benzrf> i know =p
07:23:56 <benzrf> i'm trying to write an extremely evil program for tracing evaluation of structures
07:24:00 <Sculptor> gm haskell enthusiasts
07:24:11 <benzrf> so i need to cause evaluation of each expression to record its result, etc
07:24:31 <benzrf> the only 'reasonable' way to do that without causing massive type issues is by inserting sneaky IO
07:25:47 <benzrf> also, should i use seq or pseq to force the IO?
07:26:24 <merijn> benzrf: Rather than writing your own evil program
07:26:31 <merijn> benzrf: Have you looked at Debug.Trace?
07:26:37 <benzrf> it's different p:
07:29:41 <alpounet> well, benzrf, i think you can do what you're doing without getting that dirty
07:30:27 <benzrf> orly?
07:31:17 <benzrf> right now im planning on using implicit args and unsafe io to pass down the current expression context and modify it
07:31:19 <alpounet> benzrf: can you paste your code on lpaste? or send a link to a repo
07:31:22 <benzrf> this shits gonna be slooooooow
07:31:27 <benzrf> alpounet: i'm only planning, havent coded yet
07:32:03 <benzrf> odds are im never gonna write this
07:32:06 <benzrf> it'll be too much of a pain
07:32:09 <benzrf> q.q
07:32:53 <alpounet> also, ghci can help you figure out how the code is evaluated
07:33:13 <benzrf> yeah but there doesnt seem to be an API for it
07:33:14 <benzrf> p:
07:33:21 <dottedmag> Is haskell98 provided solely for non-hierarchical module names, or there is something else inside beside re-exporting names?
07:33:27 <awestroke> benzrf: rip the code out of ghci
07:34:23 <benzrf> awestroke: ew.
07:34:34 <benzrf> awestroke: isn't ghci tightly coupled to ghc and not api-based?
07:35:13 <awestroke> benzrf: I think it's kind of stand-alone, it uses haskell bytecode
07:35:24 <benzrf> hmmm
07:35:54 <benzrf> honestly anything i make is probably going to be worse than a toy
07:35:59 <alpounet> but Debug.trace next to your values can help you out when you need to understand what's evaluated when
07:36:13 <alpounet> and there are tools to visualize the evaluation of a haskell expression
07:36:13 <benzrf> no, this is about seeing the tree of expressions and subexpressions
07:36:17 <benzrf> not timing of evaal
07:36:18 <benzrf> *eval
07:36:25 <benzrf> i was talking about it before p:
07:37:00 <alpounet> benzrf: https://github.com/bmillwood/stepeval
07:37:07 <benzrf> ooh.
07:37:09 <alpounet> that may be of interest to you
07:43:00 <benzrf> basically this is what im thinking about http://lpaste.net/104985
07:43:15 <benzrf> brace yourself before looking
07:43:21 <benzrf> it's really, reallllly bad
07:51:54 <armlesshobo> benzrf: what are all those #'s for?
07:52:40 <benzrf> armlesshobo: name clash prevention
07:52:46 <benzrf> i figure most people dont use magic hashes
07:52:57 <armlesshobo> oh I see
07:53:16 <armlesshobo> did know if it was some sort of voodoo that I haven't learned about yet.
07:53:25 <zack__> hi
07:53:52 <armlesshobo> didn't know*
07:53:59 <armlesshobo> zack__: welcome :)
07:58:55 <ocharles> jle`: odd, I wonder why that is...
07:59:09 <shapr> hi zack__
08:00:26 <trap_exit> how does haskell compare with erlang for server side work?
08:00:32 <trap_exit> I feel taht in server when I want uptime
08:00:36 <trap_exit> erlang is better at code hot reloading
08:00:44 <trap_exit> but I don't know haskell in server side context very well
08:02:32 * hackagebot log-effect 0.3.0.2 - An extensible log effect using extensible-effects  http://hackage.haskell.org/package/log-effect-0.3.0.2 (ibotty)
08:04:45 <mbrock> trap_exit: there are ways to do hot reloading; check out http://www.cse.unsw.edu.au/~chak/papers/SC05.html
08:08:30 <mbrock> trap_exit: you can also design your server so that the connection-handling core is stable and minimal, and then calls out to the more frequently changing application code through some layer of dynamicity: either by using dynamic loading (as in that paper), or by communicating through (for example) a message bus
08:09:04 <klrr_> so a sum type is basically a type that can be several different types like Either or "data Foo = Bar Int | Quaz String", but what is a product type? is "data Foo = Foo Int Int" a product type? what is "data Foo = Foo Int Int | Bar String" then?
08:09:36 <trap_exit> hmm
08:09:43 <companion_cube> a polynomial type? :)
08:10:41 <Philonous> klrr_, If the type A has |A| members and the type B has |B| members then Either A B has |A| + |B| members.
08:11:01 <Philonous> klrr_, And the type (A,B) has |A| * |B| members
08:11:07 <frerich> klrr_: An example for a product type would be tuples
08:11:26 <Philonous> klrr_, I mean, the number of elements in A is |A|
08:11:45 <companion_cube> would you use ordinals for "the number of elements" in general?
08:12:42 <klrr_> so its so simple
08:12:43 <piezoid> |(Bool, Bool)| = 4, |Either (Bool, Bool) Bool| = 6
08:12:46 <mbrock> klrr_: generally, they're all called algebraic data types
08:12:52 <klrr_> why is it useful to talk about it that way?
08:13:08 <rwbarton> companion_cube: "number of things" -> cardinals
08:13:18 <mbrock> klrr_: there's some cool theory around them, for example it turns out that you can take derivatives of them, in the same way that you take algebraic derivatives of expressions like x^2 + x
08:13:50 <klrr_> deriviatives? like x(x+1)?
08:14:33 <piezoid> in Haskell 1 is ()
08:15:03 <klrr_> now youve lost me
08:15:23 <piezoid> the type 1, with one menbers
08:15:57 <klrr_> well, how is it different from any other type with one data consutrcctor?
08:16:05 <mbrock> klrr_: it's kinda heady stuff, especially the theoretic papers about it (by McBride and others), but here's a blog post that seems accessible: http://blog.lab49.com/archives/3011
08:16:06 <klrr_> oh i gtg sry, thanks for help
08:16:06 <Philonous> klrr_, The type () is sometimes written as 1 because it has 1 Element (there are many types with one element, but they all "behave like" ())
08:16:26 <Philonous> klrr_, It's not different, but those types are all isomorphic.
08:20:33 <trap_exit> does ghc have a java backend?
08:20:41 <trap_exit> is there a way to use java libs in haskell or does one have to go scala for that?
08:20:56 <geekosaur> there is not currently a java backend
08:21:52 <d3m1g0d-> does Haskell make sense in the industry ?
08:22:17 <crazydave> http://www.haskell.org/haskellwiki/Haskell_in_industry
08:22:51 <squimmy> hi, I'm a bit now to haskell and i was wondering how to do a thing:
08:23:27 <squimmy> I have a list and i want a function that iterates the list and returns a list of the elements that satisfy a predicate but performs some IO on the elements that don't satisfy the predicate
08:23:29 <d3m1g0d-> crazydave: ok, lets put it in another way - will Haskell take over the world ?
08:23:52 <squimmy> is this something I should be doing with a match on partition or is there a better way to do this?
08:24:51 <crazydave> squimmy: you want to think about splitting IO from your other logic in haskell
08:25:05 <hc> d3m1g0d-: yes, it will
08:25:06 <hc> ;p
08:25:21 <crazydave> squimmy: what you probably want to do is look at splitBy: to split the list in to two lists based on a predicate
08:25:38 <squimmy> I realise that the function will have to return an IO monad of the result, right?
08:25:42 <pjdelport> I think you want partition, not splitBy
08:25:48 <crazydave> then do what you want with those two lists (ie perform some IO on one of the lists)
08:26:32 <pjdelport> squimmy: Do you always want to perform those actions as an effect of obtaining the non-matching elements?
08:26:34 <crazydave> ah, you are right ... splitBy doesn't exist ... I was thinking of split
08:26:38 <pjdelport> You don't have to.
08:26:45 <squimmy> crazydave: thanks. it seems a little imperative so i thought maybe it wasn't the right way, but I guess it's hard to avoid making IO imperative
08:26:57 <danilo2> Hello! :) I've got a pure theoretical question - how would you name a type (or type system) which allows creating types, which can check if the value is correct (for example a function which results in type of "DivableBy2") ?
08:27:29 <crazydave> well that's the thing ... you want to do the partition in pure code and then you have TWO lists (which is why you partitioned them)
08:27:40 <squimmy> pjdelport: sure. for example lets pretend i want a function that takes in a list of integers and performs a map on all the positive integers, but writes all the negative ones to disk
08:27:43 <crazydave> and once you have that bit working you can do your IO
08:28:37 <squimmy> hmm. I was hoping to hide the IO from the caller and all they'd have to know is "some IO happened"
08:29:23 <squimmy> keeping code properly encapsulated gets a lot trickier when encapsulated code wants to do IO
08:29:27 <merijn> squimmy: "an IO monad of the result" is not really a sensible phrase
08:29:31 <Philonous> squimmy, You'd have to create an IO action that has to be explicitly called as such. You can't just make a (pure) function perform IO.
08:29:54 <merijn> squimmy: What should the function do with the mapped positive integers? Just return the new list?
08:30:02 <pjdelport> > let (xs,ys) = partition even [1..10] in mapM_ print xs >> return ys
08:30:03 <squimmy> merijn: correct
08:30:03 <lambdabot>  <IO [Integer]>
08:30:14 <pjdelport> squimmy: Something like that, basically
08:30:16 <merijn> What's wrong with: "[Int] -> IO [Int]"?
08:30:22 <squimmy> yeah, that looks very much like what i want
08:30:31 <squimmy> thank you very much :)
08:30:43 <merijn> squimmy: The IO can just do whatever it wants
08:33:36 <Toxmi> Hi, when I issue cabal update it says newer version is available and I issue cabal install cabal-install but after installing newer version, cabal update issue same warning it seems a problem with the path but I've already have .cabal/bin in my path ... I'm newbie to whole linux (and haskell) so excuse if the problem is very basic
08:34:14 <hexagoxel> danilo2: "dependent type"
08:34:18 <dottedmag> Toxmi: what does $ which cabal say?
08:34:52 <geekosaur> Toxmi, it's not enough to have it in your path, it should be *first* in your path
08:35:08 <Toxmi> cabal -V says 1.20.0.1 but .cabal/bin/cabal -V says 1.20.0.2
08:35:12 <dottedmag> Toxmi: is there .cabal/bin in $ echo $PATH?
08:35:15 <geekosaur> also you orobably need `hash -r` (most shells) or `rehash` (csh/tcsh) to make the shell see the new one
08:35:18 <Toxmi> yes
08:35:29 <geekosaur> (`which` will lie about that last)
08:35:47 <pjdelport> squimmy: FWIW, that seems like an odd thing to want to do. Usually you'll just want to do things like that partitioning in a pure way, and return the other elements in some other way to the parts of your program that are responsible for IO. (Unless it's for debugging, in which case you might want something like Debug.Trace?)
08:36:23 <Toxmi> /usr/local/sbin:/usr/local/bin:/usr/bin:/usr/local/texlive/2013/bin/x86_64-linux:/usr/bin/vendor_perl:/usr/bin/core_perl:/home/sadid/.cabal/bin:/home/sadid/.xmonad/bin:~/bin:/home/sadid/.cabal/bin:/home/sadid/.xmonad/bin:/home/sadid/.cabal/bin:/home/sadid/.xmonad/bin:~/bin:/home/sadid/.cabal/bin:/home/sadid/.xmonad/bin
08:36:30 <Toxmi> this is the echo $PATH
08:36:36 <bennofs> Toxmi: type -a cabal
08:36:42 <dottedmag> Toxmi: you'll need to move .cabal/bin to the beginning of the PATH
08:36:46 <geekosaur> [02 15:33] <geekosaur> Toxmi, it's not enough to have it in your path, it should be *first* in your path
08:37:06 <rwbarton> (also, it looks like you are setting your PATH in the wrong place)
08:37:09 <dottedmag> geekosaur: depends on whether which is built-in or a external tool.
08:37:39 <geekosaur> dottedmag, yes, I know, everyone wants which to be correct and will argue endlessly about how it is the correct one and the one to recommend to everyone yadayada
08:37:50 <Toxmi> geekosaur: ow oK, i'll fix it, thanks. actually I've a /usr/bin/cabal (the first in my path) .
08:38:00 <dottedmag> geekosaur: wha?
08:38:08 <geekosaur> I give up, `which` is the only comand to ever consider, if it lies then it's somneone something wehatever else's fault
08:38:28 <geekosaur> you're stepping on an argument I always lose
08:38:37 <geekosaur> because everyone wants to believe `which` is perfect
08:38:43 * dottedmag didn't know bash does not have which builtin
08:38:45 <geekosaur> `type` is the correct command because it is always reliable
08:38:58 <geekosaur> but it;s the wrong command because veryone wants it to be the wrong command
08:39:05 <geekosaur> so it's the wrong command
08:39:30 <Toxmi> I've /usr/bin/cabal in the path (the first) I don't know where this takes precedence...I've just edit bash profile...
08:39:52 <rwbarton> "(the first)" this is where it takes precedence.
08:41:46 <Toxmi> rwbarton: I don't know where /usr/bin/cabal has been set? it'snt in my home directory....I'll find it (I'm not familiar with linux)
08:41:55 <Toxmi> Thanks you guys I find the problem
08:42:05 <vamega> Hi.
08:42:06 <Pythonfant> I'm using the writer monad to track the comparisons needed by my mergesort implementation
08:42:12 <Pythonfant> however I'm getting a stackoverflow
08:42:16 <vamega> I was wondering what the best way to compose file paths is?
08:42:22 <Pythonfant> I looked into the >>= implementation and it doesn't seem to be tail recursive
08:42:25 <vamega> Should I just be working with strings?
08:42:28 <Toxmi> pandoc
08:42:32 <Pythonfant> Is there some tail recursive equivalent?
08:42:45 <geekosaur> Toxmi: the first place it's found in $PATH is the one that gets used. also editing .bash_profile does not update running shells
08:42:59 <rwbarton> :t (</>)
08:42:59 <lambdabot>     Not in scope: ‘</>’
08:43:00 <lambdabot>     Perhaps you meant one of these:
08:43:00 <lambdabot>       ‘<*>’ (imported from Control.Applicative),
08:43:05 <rwbarton> @hoogle (</>)
08:43:06 <lambdabot> System.FilePath.Windows (</>) :: FilePath -> FilePath -> FilePath
08:43:07 <lambdabot> System.FilePath.Posix (</>) :: FilePath -> FilePath -> FilePath
08:43:18 <vamega> thanks rwbarton
08:43:28 <rwbarton> I think FilePath is just a type synonym for String
08:43:39 <vamega> I was looking in the System.Directory documentation.
08:43:48 <vamega> And yes it is just a type synonym.
08:47:23 <Philonous> Uh "Module ‘Control.Monad.Catch’ does not export ‘MonadThow’" <-- Why would ghc say that?
08:47:37 * hackagebot force-layout 0.3.0.4 - Simple force-directed layout  http://hackage.haskell.org/package/force-layout-0.3.0.4 (BrentYorgey)
08:47:46 <lwm> ghc does what it wants :|
08:48:04 <glguy> Philonous: Because you spelled "Throw" wrong?
08:48:12 <geekosaur> did you typo that in channel or in the source?  ...that
08:48:19 <Philonous> glguy, AHHH, thanks a bunch.
08:48:26 <benzrf> lwm: [i think people calling it 'glorious' has gone to its head]
08:48:30 <Philonous> glguy, Would have taken me an hour to figure that one out :)
08:49:38 <lwm> benzrf: absolutely, remind me not to marvel at its creation while it's looking next time...
08:50:20 <sofancy> Hi, still quite a beginner here, so I'm getting a lot of warnings and I was wondering if there's any good way to do this: http://lpaste.net/104986 , been trying for an hour and I can't seem to find a good answer
08:51:54 <dgpratt> lambdabot made a cameo appearance on my local news :) http://wabi.tv/2014/06/01/civic-hackers-work-solve-community-problems/
08:55:25 <Philonous> sofancy, Your solution looks fine. If you want to get rid of the warnings you could either add type annotations (ugly) or write helper functions with more specific types
08:55:41 <rwbarton> @botsnack
08:55:41 <lambdabot> :)
08:56:25 <byorgey> lwm: that code looks reasonable.  Those warnings are just telling you that it doesn't know what intermediate types to use.  But the default choices are reasonable.
08:56:40 <byorgey> sorry, that was meant for sofancy, not lwm
08:58:25 <sofancy> Philonous: Ah, thanks, I'll write helper functions then
08:59:20 <brycelane_> Hi all, is there anything for haskell akin to the idris effects library?
08:59:40 <sofancy> byorgey: so warnings are telling me there are several types to use and it just picks one for me?
08:59:57 <byorgey> sofancy: right.
09:00:12 <sofancy> alright, thanks a lot byorgey & Philonous :)
09:00:51 <byorgey> sofancy: e.g. when you convert to some type using fromIntegral, take the log, and then the ceiling, any floating-point type would work while doing that intermediate log computation
09:00:56 <benzrf> asked this a bit ago
09:01:00 <benzrf> didnt get a real answer:
09:01:09 <benzrf> is there any formal basis for collections?
09:01:15 <benzrf> are they rooted purely in intuition?
09:01:16 <byorgey> sofancy: by default it picks Double which is probably what you want anyway.
09:01:52 <byorgey> sofancy: the other warning is about the type of the entire expression, and that warning will probably go away once you use that expression in some context where it can infer what type you want it to be
09:04:01 <benzrf> shit, wrong channel
09:04:43 <sofancy> byorgey: Ah, I get it now, thanks
09:04:49 <lwm> dgpratt: that hackathon looks pretty interesting, did you go?
09:04:57 <dgpratt> I did
09:05:10 <dgpratt> it was pretty interesting/fun :)
09:05:31 <dgpratt> alas, no Haskell was coded during the event :(
09:05:51 <sbidin> > let 2 + 2 = "haskell" in 2 + 2
09:05:52 <lambdabot>  "haskell"
09:06:02 <lwm> cool, pity about no haskell, it could have nearly been on topic then ;)
09:06:09 <dgpratt> :)
09:06:39 <byorgey> brycelane_: maybe http://hackage.haskell.org/package/extensible-effects ?
09:06:51 <byorgey> brycelane_: though I am not terribly familiar with the idris effects library
09:06:54 <armlesshobo> let getLine >>= putStrLn in 2 + 2
09:07:04 <armlesshobo> > let getLine >>= putStrLn in 2 + 2
09:07:05 <lambdabot>  <hint>:1:26: parse error on input ‘in’
09:08:00 <benzrf> armlesshobo: perhaps you mean
09:08:08 <brycelane_> byorgey: I'm not either. I've skimmed that, but decided to ask or risk getting lost in the black hole which is the internet. Thanks for the link
09:08:12 <benzrf> > (getLine >>= putStrLn) `seq` 2 + 2
09:08:13 <lambdabot>  4
09:09:15 <mbrock> Pythonfant: tail recursion doesn't work in the exact same way in the presence of lazy evaluation
09:09:16 <armlesshobo> benzrf: ahhh, no. I didn't do what I was thinking right
09:09:22 <sbidin> Why does (let 2 + 2 = "haskell" in 2 + 2) work? Does GHC just do a string replace and ignores doing any kind of semantic analysis?
09:09:29 <rwbarton> no
09:09:33 <mbrock> Pythonfant: are you using a strict Writer?
09:09:41 <byorgey> brycelane_: hehe, fair enough.  extensible-effects is a nice approach.  There is some debate in the community over the relative expressiveness of extensible-effects vs monad transformers.
09:09:43 <armlesshobo> > let (getLine >>= putStrLn) = 2 + 2 in (getLine >>= putStrLn)
09:09:44 <mbrock> Pythonfant: are you accumulating your results in a list?
09:09:44 <lambdabot>  <hint>:1:6: Parse error in pattern: getLine >>= putStrLn
09:10:03 <rwbarton> sbidin: there is a new function named (+) by the let that shadows the usual (+)
09:10:30 <armlesshobo> benzrf: i was trying to play on the idea of 'let 2+2 = "Haskell" in 2 + 2'
09:10:30 <rwbarton> which is defined for a single case, when both arguments are 2
09:10:30 <Pythonfant> mbrock: no I use the Sum monoid
09:10:42 <jle`> sbidin: are you aware of defining your own function inside a let expression?
09:10:44 <sbidin> rwbarton: Ah, of course. Thanks!
09:10:48 <rwbarton> > let 2 + 2 = "haskell" in 2 + (3 - 1)
09:10:49 <lambdabot>  "haskell"
09:11:05 <jle`> > let f 0 = 1; f n = n * f (n-1) in f 10
09:11:07 <lambdabot>  3628800
09:11:32 <jle`> so you're saying "when i call f on 0, it's 1; when i can f on n, it's n * f (n-1)
09:12:06 <jle`> > let f 2 2 = 5; f x y = x + y in f 2 2
09:12:08 <lambdabot>  5
09:12:19 <jle`> that's saying "when i call f with 2 and 2, it's 5; otherwise if i call it on x and y, it's x+y
09:12:27 <brycelane_> byorgey: I was hoping that idris modeled their effects package after some haskell lang extension. It looks really nice for the times you want to deal with local state. I'm just learning haskell, and that portion of it makes me sad.
09:12:32 <Pythonfant> mbrock: I just tried the strict version
09:12:37 <Pythonfant> still getting an stack overflow
09:12:41 <jle`> sbidin: we can define operators like this too
09:13:01 <jle`> > let (&*%) 2 2 = 5 in 2 $*% 2
09:13:02 <lambdabot>  Not in scope: ‘$*%’
09:13:03 <lambdabot>  Perhaps you meant ‘&*%’ (line 1)
09:13:07 <jle`> > let (&*%) 2 2 = 5 in 2 &*% 2
09:13:08 <lambdabot>  5
09:13:18 <jle`> we can shadow functions in let expressions
09:13:26 <jle`> > let length n = n*2 in length 5
09:13:28 <lambdabot>  10
09:13:32 <vlads> armlesshobo: you took too much braces:
09:13:33 <vlads> > let getLine >>= putStrLn = 2 + 2 in getLine >>= putStrLn
09:13:35 <byorgey> brycelane_: oh, perhaps I misunderstood the level of your question.  If you want to deal with local state in Haskell, that is very easy using the State monad.
09:13:35 <lambdabot>  4
09:13:43 <Pythonfant> mbrock: that's the code I'm using http://lpaste.net/104987
09:13:46 <sbidin> jle`: I understand, thanks. Shadowing (+) confused me since I've never seen it done before. I didn't even register it as a local function definition.
09:14:00 <byorgey> (for sufficiently large values of "very easy")
09:14:03 <jle`> > let 2 &*% 2 = 5 in 2 &*% 2
09:14:05 <lambdabot>  5
09:14:12 <byorgey> it does not require any extensions to the Haskell language at all.
09:14:34 <jle`> sbidin: but it is interesting that you say that it's like a "string replace", because in a lot of ways, that is how function evaluation kind of works in haskell
09:14:44 <brycelane_> byorgey: I understand that works well for perhaps one value, but how does that scale? I imagine either you need to bundle your state or deal with the sequential 'lifting'.
09:14:51 <vlads> > let 2 + 2 = 5 in 3 + 2 -- nevertheless, would fail, I guess
09:14:53 <lambdabot>  *Exception: <interactive>:3:5-13: Non-exhaustive patterns in function +
09:14:53 <jle`> almost like a literal find-and-replace
09:15:05 <jle`> > let _+_ = 5 in 3 + 2
09:15:07 <lambdabot>  5
09:15:16 <mbrock> oh, I guess strictness with Writer is kind of weird and tricky? making Pythonfant's problem most easily solvable by using State instead?
09:15:27 <mbrock> going by this thread: http://stackoverflow.com/questions/7720929/space-leaks-and-writers-and-sums-oh-my
09:16:18 <byorgey> brycelane_: right, if you want to layer multiple states, you can (1) bundle your states into a single record (2) deal with sequential lifting or (3) use something like extensible-effects to "label" each of the states differently
09:16:29 <Pythonfant> mbrock: hm ok, then I'll try using the state monad, thx for your help
09:16:57 <brycelane_> byorgey: I'm still learning, so perhaps that is rarely a concern in practice. I've also been curious about the runtime costs of the monad transformer pattern. Any insight?
09:17:01 <byorgey> brycelane_: (2) is very annoying of course.  however, (1) can be much nicer than you might think, especially in conjunction with the 'lens' package.
09:17:40 * hackagebot yesod-dsl 0.1.1.18 - DSL for generating Yesod subsite to manage an RDBMS;  http://hackage.haskell.org/package/yesod-dsl-0.1.1.18 (TeroLaitinen)
09:19:05 <byorgey> brycelane_: from what I understand, monad transformers can indeed sometimes impose a significant runtime overhead, which can be mitigated using a continuation-passing style.  I don't know how it compares to things like extensible-effects.
09:19:35 <mbrock> Pythonfant: maybe it's possible to fix up the Writer, or define a custom stricter Writer, I don't really know. but using State instead seems like the easiest thing -- unfortunately, since Writer expresses your needs more clearly
09:19:47 <mbrock> (perhaps some of the experts here have run into the issue?)
09:20:21 <Pythonfant> yep writer seemed like a perfect fit
09:20:32 <benzrf> @check \n -> n + 1 == n
09:20:34 <lambdabot>  *** Failed! Falsifiable (after 1 test):
09:20:34 <lambdabot>  0
09:20:35 <brycelane_> byorgey: If I understand it, the extensible-effects requires some interaction with the Typeable class, which I understand to achieve some of the goals of introspection/reflection.
09:20:50 <brycelane_> That is certainly a 0th order understanding from skimming.
09:20:55 <benzrf> @check \n -> n + 1 < 0 ==> n < 0
09:20:55 <lambdabot>  : -1: -1:Ambiguous infix expression
09:21:00 <benzrf> @check \n -> (n + 1 < 0) ==> n < 0
09:21:02 <lambdabot>  +++ OK, passed 100 tests.
09:21:14 <rwbarton> cool error message from lambdabot there
09:21:51 <hakujin> I have a strict HashMap from unordered-containers that I want to use for lookups deep in a function stack but wrapping everything in a ReaderT seems like a hassle. can I define the HashMap as a top level definition and assume it won't be GC'ed and recreated each time a function references it?
09:22:23 <benzrf> hakujin: probs
09:22:28 <benzrf> hakujin: idk
09:22:40 <rwbarton> hakujin, yes. if you are extra paranoid you can put a NOINLINE pragma on the top-level definition
09:22:49 <hakujin> rwbarton: thanks!
09:23:49 <rwbarton> that is, the only thing that could go wrong is if GHC decided to inline that top-level definition
09:24:15 <rwbarton> oh, and also make sure the top-level definition is not polymorphic
09:25:10 <byorgey> brycelane_: yes, Typeable allows you to carry around a runtime representation of types, which allows some introspection/reflection.
09:25:37 <byorgey> brycelane_: normally types are completely erased at compile time.
09:27:23 <rwbarton> brycelane_, in any case you shouldn't skip learning about monad transformers since they are used ubiquitously
09:28:06 <hexagoxel> Pythonfant: you tried "mergesort []" (on your existing implementation)
09:28:42 <Pythonfant> hexagoxel: obviously not :)
09:28:55 <hexagoxel> because.. that does not terminate, regardless of the Writer thing you use :)
09:29:32 <hexagoxel> or rather, it terminates with a stack overflow.
09:29:56 <Pythonfant> hexagoxel: right, but I didn't try that :)
09:30:06 <Pythonfant> so it can't be the problem here
09:30:46 <hexagoxel> Pythonfant: what did you try it on?
09:31:10 <Pythonfant> hexagoxel: all permutations with repetitions of the numbers [1..8]
09:32:27 <brycelane_> rwbarton: thanks for the tip. I've already skimmed the surface of transformers, just trying to find out if there is a 'better' way.
09:32:45 <hexagoxel> Pythonfant: well i still suggest to fix the [] case, even if it seems unlikely to be the cause
09:32:52 <Pythonfant> hexagoxel: already did that
09:39:54 <tristanStrange> hey all... what's the best host for a rally simple yesod application?
09:42:30 <hakujin> tristanStrange: if you're comfortable with a VPS, amazon will give you a free micro instance for a year
09:43:04 <tristanStrange> sounds good i think... is that EC2you're talking about?
09:43:10 <hakujin> tristanStrange: yep
09:43:32 <zomg> If you're deploying to EC2 you may wanna make sure you can compile on your local system for same OS as on EC2
09:43:47 <zomg> Eg. if you run a 64bit linux EC2, make sure you can compile locally to 64bit linux
09:43:57 <zomg> Yesod is pretty big and compiling all that on EC2 can take a while
09:44:28 <zomg> If you compile locally with static linking you can just copy the binary and it oughta work
09:45:25 <tommd> Or do it properly and make a .deb, .rpm or what have you.
09:46:14 <tristanStrange> thanks chaps... I'll take a look. You're not aware ofa good tutorial are you?
09:48:45 <S3thc0n> Hello everyone! Am I correct in thinking that 'Tying the knot' in Haskell depends on whatever the opposite of forward declaration is called? Is there any other way except using mutation?
09:51:08 <albeit> Is there anything like "(a -> b) -> [a] -> [(a,b)]", sort of a zipMap? Can't find anything with Hoogle...
09:51:46 <bennofs> :t \f -> map (id &&& f) -- don't know if that has a name
09:51:47 <lambdabot> (c -> c') -> [c] -> [(c, c')]
09:51:54 <glguy_> That isn't named afaik. [(x, f x) | x <- xs] is probably your best bet
09:52:18 <trap_exit> yo
09:52:18 <trap_exit> haskell
09:52:20 <trap_exit> server side
09:52:22 <albeit> glguy_: Ah that looks good, thanks
09:52:22 <trap_exit> how do I keep state?
09:53:53 <mmachenry> trap_exit: IORef, State, Database, IO in the filesystem, same ways you do in most of languages just well typed.
09:53:56 <deweyvm> if i have installed haskell platform on debian but i want a newer version of ghc, can i just go ahead and install it from source or will there be issues?
09:54:07 <hakujin> trap_exit: probably with a combination of TVars and a State Monad
09:54:15 <mmachenry> trap_exit: If it's concurrent state then MVar or STM.
09:54:30 <glguy_> deweyvm: You can have multiple versions of GHC installed at the same time as long as you put them in different directories
09:55:14 <deweyvm> glguy: great, thanks
09:55:37 <glguy> I suppose you can actually install them to the same place but then you have to decide which one gets the ghc symlink and its probably not a good idea to install your own GHC into the debian managed /usr
09:56:07 <trap_exit> when deciding between erland an dhaskek on the server side
09:56:10 <trap_exit> wha tmetrics should I be considering?
09:56:17 <hakujin> english
09:56:50 <hakujin> ;P
09:57:05 <glguy> trap_exit: You should pick the one that you know how to program in and that has the libraries you need and supports the features you need
09:58:14 <tommd> glguy: He should pick one he doesn't know how to program in, thus forcing himself to learn something new.
09:58:33 <glguy> yeah, you should also consider your goals for the project
09:58:48 <rwbarton> you should pick the one with worse features, so that you will be able to contribute to making them better!
09:58:49 * tommd has a winning strategy for being unproductive
10:00:06 <Philonous> So basically you should pick the one you would pick if you picked the one you should pick. There you go.
10:00:46 <pyon> Philonous: So basically evaluate "a = a".
10:07:46 * hackagebot d-bus 0.0.3 - Permissively licensed D-Bus client library  http://hackage.haskell.org/package/d-bus-0.0.3 (PhilippBalzarek)
10:11:36 <jophish> Is there a way to enable parallel computation in ghci?
10:11:40 <hakujin> fyi, Apple's WWDC is live now. link to a livestream on Apple's website
10:11:48 <shapr> yay?
10:12:54 <rwbarton> jophish, I suppose ghci +RTS -N should do it
10:14:03 <Axman6> yes yay
10:14:54 <Yuu_chan> What to do if I need to modify few lines in some installed cabal package? How to recompile it afterwards?
10:16:13 <madjestic> Yuu_chan did you try 'cabal install' from the root of the cabal dir?
10:16:16 <bennofs> Yuu_chan: do 'cabal install' in the directory where the cabal file of the package lives
10:16:40 <rwbarton> (and 'cabal unpack packagename' to get the tree in the first place)
10:17:04 <bennofs> Yuu_chan: also, if you use cabal sandboxes, you can also use the package in another project by doing 'cabal add-source /path/to/package/root' in that project
10:17:59 <Yuu_chan> Thanks, I'll try to.
10:24:43 <kini> anyone have a convenient way to do spellchecking of strings and comments in haskell files in emacs?
10:25:11 <kini> M-x ispell RET will have tons of spurious hits on variable names and things :)
10:25:25 <jophish> rwbarton: super! Thanks!
10:33:08 <benzrf> :t deepSeq
10:33:09 <lambdabot> Not in scope: ‘deepSeq’
10:33:12 <benzrf> :t deepseq
10:33:13 <lambdabot> Not in scope: ‘deepseq’
10:33:15 <benzrf> :{
10:35:40 <jfischoff> what is a good monad for dealing warnings that cause part of computation to abort
10:35:57 <benzrf> jfischoff: why not either
10:36:26 <benzrf> @src Free (>>=)
10:36:27 <lambdabot> Source not found. My brain just exploded
10:36:34 <benzrf> @src Maybe (>>=)
10:36:34 <lambdabot> (Just x) >>= k      = k x
10:36:34 <lambdabot> Nothing  >>= _      = Nothing
10:36:37 <benzrf> l-lame
10:36:39 <benzrf> :k FRee
10:36:41 <lambdabot> Not in scope: type constructor or class ‘FRee’
10:36:41 <jfischoff> I could use either, but that is not exactly what I am looking for
10:36:41 <benzrf> :k FreeFull
10:36:42 <lambdabot>     Not in scope: type constructor or class ‘FreeFull’
10:36:44 <benzrf> :k Free
10:36:45 <lambdabot>     Not in scope: type constructor or class ‘Free’
10:36:45 <lambdabot>     Perhaps you meant ‘Tree’ (imported from Data.Tree)
10:36:47 <benzrf> huh
10:37:02 <jfischoff> I want to be able to abort the whole computation and get an error
10:37:16 <Yuu_chan> jfischoff: what about exceptions?
10:37:17 <jfischoff> or say this “this is warning” keep going
10:37:23 <FreeFull> :k FreeF
10:37:24 <lambdabot> Not in scope: type constructor or class ‘FreeF’
10:37:29 <FreeFull> benzrf: I'm not a type constructor
10:37:35 <jfischoff> and also delimit parts of the computation that will abort
10:37:48 <benzrf> FreeFull: it was a tipo
10:37:52 <jfischoff> and after they abort that local error because part of the accumulated warnings
10:37:57 <FreeFull> You accidentally pressed tab?
10:38:00 <jfischoff> s/because/becomes
10:38:23 <rwbarton> "delimit parts of the computation that will abort" sounds like a separate operator
10:38:34 <jfischoff> it is like some mix of Either, Writer, and delimited continuations
10:39:47 <jfischoff> I mean I am writing the code by just juducious use of runEitherT etc
10:39:58 <jfischoff> but I imagine there is a more elegant way
10:40:11 <nh2> ho do I derive a typeable instance for a type to whose constructors I have no access?
10:40:58 <jfischoff> I imagine warnings many people have had to work with, and there is probably an nice monad out there that does my job better than I am
10:41:18 <benzrf> @src ($)
10:41:18 <lambdabot> f $ x = f x
10:41:25 <benzrf> f $ x = f x
10:41:27 <benzrf> ($) = id
10:41:31 <benzrf> hmmmmmmmm
10:42:24 <Yuu_chan> ($) f x = f x
10:42:29 <Yuu_chan> ($) f = f
10:42:33 <Yuu_chan> ($) =
10:42:44 <FireFly> modulo some subtle strictness difference, IIRC
10:42:50 * hackagebot statestack 0.2.0.3 - Simple State-like monad transformer with saveable and restorable state  http://hackage.haskell.org/package/statestack-0.2.0.3 (jeffreyrosenbluth)
10:43:02 * FireFly doesn't see why, though
10:45:05 <Nik05> is there some way to get the "size" of an integer? like how many bits are used, how many digits or somethign like that?
10:45:42 <pjdelport> Nik05: Yes, in a number of ways.
10:45:45 <tangentstorm> you can round up the base n logarithm to find out how many digits it requires in base n, Nik05
10:46:03 <Axman6> > logBase 2 (fromInteger 3745)
10:46:05 <pjdelport> Nik05: What's it for?
10:46:05 <lambdabot>  11.870750003346114
10:46:09 <Axman6> > logBase 10 (fromInteger 3745)
10:46:10 <lambdabot>  3.573451822035485
10:46:14 <rwbarton> do you need something fancier/more efficient than length (show n)?
10:46:21 <koala_man> Nik05: you mean the number itself or its in-memory representation?
10:46:28 <Nik05> > logBase 10 (fromInteger (10^1000)
10:46:29 <lambdabot>  <hint>:1:34:
10:46:29 <lambdabot>      parse error (possibly incorrect indentation or mismatched brackets)
10:46:29 <Nik05> > logBase 10 (fromInteger (10^1000))
10:46:32 <lambdabot>  Infinity
10:46:34 <benzrf> hmmmmmm
10:46:38 <Nik05> see that doesnt work
10:47:28 <tangentstorm> isn't there some kind of bigint type?
10:47:35 <Nik05> yes Integer...
10:47:40 <supki> > logBase 10 (10 ^ 1000) :: CReal
10:47:42 <lambdabot>  1000.0
10:47:50 * hackagebot monoid-extras 0.3.3.4 - Various extra monoid-related definitions and utilities  http://hackage.haskell.org/package/monoid-extras-0.3.3.4 (jeffreyrosenbluth)
10:48:08 <Nik05> supki what is CReal?
10:48:18 <rwbarton> that is possibly even less efficient than length . show
10:48:53 <Nik05> oh so log works on Integers?
10:50:07 <tangentstorm> ah yeah... i didn't realize you were talking about thousands of digits.
10:50:22 <Nik05> hm when i do it it doesnt work
10:50:46 <rwbarton> log doesn't work on Integer
10:50:55 <rwbarton> here the numeric literals are being inferred to CReal
10:51:05 <Nik05> > logBase 10 (10 ^ 10000) :: CReal
10:51:09 <lambdabot>  mueval-core: Time limit exceeded
10:51:11 <Nik05> then how does that work?
10:51:21 <rwbarton> > length (show (10^10000))
10:51:22 <lambdabot>  10001
10:51:26 <tangentstorm> it didn't!
10:51:43 <Axman6> > 10e100 :: Integer
10:51:45 <lambdabot>  No instance for (GHC.Real.Fractional GHC.Integer.Type.Integer)
10:51:45 <lambdabot>    arising from the literal ‘10e100’
10:51:47 <Axman6> :(
10:51:50 <Nik05> but with show it actually calculates all the digits, i only need a length
10:52:13 <poucet> > 10e100
10:52:15 <lambdabot>  1.0e101
10:52:51 <Axman6> 1e100 is Google's domain for most of its datacentres I think
10:52:52 * hackagebot dual-tree 0.2.0.4 - Rose trees with cached and accumulating monoidal annotations  http://hackage.haskell.org/package/dual-tree-0.2.0.4 (jeffreyrosenbluth)
10:52:54 * hackagebot active 0.1.0.15 - Abstractions for animation  http://hackage.haskell.org/package/active-0.1.0.15 (jeffreyrosenbluth)
10:52:56 * hackagebot command-qq 0.2.2.0 - Quasiquoters for external commands  http://hackage.haskell.org/package/command-qq-0.2.2.0 (MatveyAksenov)
10:54:35 <rwbarton> in ghc 7.8 integer-gmp exports sizeInBaseInteger
10:55:15 <rwbarton> alternately, you can use the definition of Integer. also relies on integer-gmp
10:56:36 <benzrf> hmmmm
10:56:37 <rwbarton> oh, both integer-* implementations implement integerLog2#
10:56:43 <Nik05> hm i got ghc 7.6
10:57:10 <rwbarton> oh
10:57:17 <rwbarton> > integerLogBase 2 (10^1000)
10:57:19 <lambdabot>  Not in scope: ‘integerLogBase’
10:57:25 <rwbarton> > GHC.Float.integerLogBase 2 (10^1000)
10:57:26 <lambdabot>  Not in scope: ‘GHC.Float.integerLogBase’
10:57:52 <rwbarton> you can use that I guess
10:57:53 * hackagebot diagrams-core 1.2 - Core libraries for diagrams EDSL  http://hackage.haskell.org/package/diagrams-core-1.2 (jeffreyrosenbluth)
10:57:55 * hackagebot diagrams-lib 1.2 - Embedded domain-specific language for declarative graphics  http://hackage.haskell.org/package/diagrams-lib-1.2 (jeffreyrosenbluth)
10:57:57 * hackagebot diagrams-cairo 1.2 - Cairo backend for diagrams drawing EDSL  http://hackage.haskell.org/package/diagrams-cairo-1.2 (jeffreyrosenbluth)
10:58:46 <rwbarton> @let import GHC.Float
10:58:47 <lambdabot>  Defined.
10:58:49 <rwbarton> > integerLogBase 2 (10^1000)
10:58:51 <lambdabot>  3321
10:58:53 <pjdelport> Nik05: What do you need it for?
10:59:25 <Nik05> pjdelport checking how many digits a number has :)
10:59:36 <pjdelport> Right, but what for?
10:59:44 <Nik05> well thats it
11:00:03 <Nik05> oh wait let me try something else :)
11:00:33 <kini> am I right that `cabal configure` can fail even though `cabal install` works fine?
11:00:36 <rwbarton> I don't think integerLogBase is guaranteed to be exactly correct
11:01:13 <kini> for example, `cabal configure` might fail with an unmet dependency, while `cabal install` will go ahead and actually install the dependency without complaining...?
11:02:18 <geekosaur> I think so, yes. `cabal configure` is intended for developers
11:02:24 <c_wraith> kini: yes, in that one specific case
11:02:48 <c_wraith> kini: if all the necessary packages are installed, cabal configure and cabal install will succeed in the same cases
11:02:54 * hackagebot diagrams-svg 1.1 - SVG backend for diagrams drawing EDSL.  http://hackage.haskell.org/package/diagrams-svg-1.1 (jeffreyrosenbluth)
11:02:56 * hackagebot diagrams-postscript 1.1 - Postscript backend for diagrams drawing EDSL  http://hackage.haskell.org/package/diagrams-postscript-1.1 (jeffreyrosenbluth)
11:03:23 <kini> c_wraith: odd. I see that in el-get, the build script for structured-haskell-mode is "cabal configure ; cabal install"
11:03:32 <kini> wouldn't it then be better to just have the build script be "cabal install" ?
11:03:55 <rwbarton> doesn't "cabal install" in fact throw away whatever "cabal configure" did
11:04:01 <c_wraith> kini: assuming that's the entirety of the two commands (no flags being passed around), then yes.
11:04:15 <kini> that is the entirety of the two commands... ok, I'll submit a pull request then. Thanks :)
11:04:25 <c_wraith> rwbarton: unless you use the flag that makes cabal install not build first, yes
11:06:16 <Okasu> How was that faster substitution for System.Random was called?
11:07:14 <c_wraith> there are a bunch.  Are you thinking of the mwc one?
11:07:37 <c_wraith> http://hackage.haskell.org/package/mwc-random
11:07:48 <c_wraith> It's by bos, that suggests it's probably good.
11:07:55 * hackagebot diagrams-rasterific 0.1 - Rasterific backend for diagrams.  http://hackage.haskell.org/package/diagrams-rasterific-0.1 (jeffreyrosenbluth)
11:07:57 * hackagebot diagrams-builder 0.5.0.11 - hint-based build service for the diagrams graphics EDSL.  http://hackage.haskell.org/package/diagrams-builder-0.5.0.11 (jeffreyrosenbluth)
11:07:59 * hackagebot diagrams-contrib 1.1.2 - Collection of user contributions to diagrams EDSL  http://hackage.haskell.org/package/diagrams-contrib-1.1.2 (jeffreyrosenbluth)
11:08:33 <Okasu> c_wraith: Ah, indeed. Thanks!
11:09:08 <exicer> Is there some way, using testframework and hunit, to have certain tests only run if a previous test passes?
11:12:55 * hackagebot diagrams-haddock 0.2.2.8 - Preprocessor for embedding diagrams in Haddock documentation  http://hackage.haskell.org/package/diagrams-haddock-0.2.2.8 (jeffreyrosenbluth)
11:15:37 <Ainieco> hello
11:15:49 * tangentstorm wonders if you can sprinkel something like a MaybeT on an HUnit monad.... :)
11:16:49 <Ainieco> is it a bad sign if one wants State Foo Foo?
11:17:50 * tangentstorm was just making that nonsense up but now thinks it may actually be the answer.
11:17:56 * hackagebot SVGFonts 1.4.0.3 - Fonts from the SVG-Font format  http://hackage.haskell.org/package/SVGFonts-1.4.0.3 (jeffreyrosenbluth)
11:18:15 <c_wraith> :t get
11:18:16 <lambdabot> MonadState s m => m s
11:18:23 <Ainieco> it just looks suspicious, sorry if i'm talking nonsense
11:18:43 <Ainieco> like if i'm misusing state
11:18:47 <tangentstorm> oh i was the one talking nonsense.
11:18:48 <c_wraith> I guess it doesn't show because of the MonadState abstraction
11:18:52 <geekosaur> not always, although it's a little suspicious --- it's the type of get, as just shown, but I can imagine cases where you want a copy of the state with some temporary modification
11:18:57 <c_wraith> But get :: State Int Int
11:19:06 <c_wraith> That's at least one possible type for get
11:19:34 <geekosaur> @. unmtl type get
11:19:35 <lambdabot> Plugin `compose' failed with: MultiParamTypeClasses is not enabled
11:19:38 <geekosaur> bah
11:21:19 <c_wraith> Ainieco: It's not bad, I'm not even sure it qualifies as suspicious most of the time.
11:22:12 <Ainieco> c_wraith: got it
11:22:56 * hackagebot diagrams-gtk 1.0.1.1 - Backend for rendering diagrams directly to GTK windows  http://hackage.haskell.org/package/diagrams-gtk-1.0.1.1 (jeffreyrosenbluth)
11:23:30 <tangentstorm> exicer: it looks like you can just call performTestCase directly and match on the resulty. http://hackage.haskell.org/package/HUnit-1.2.5.2/docs/Test-HUnit-Lang.html#v:performTestCase
11:24:22 <tangentstorm> doesn't look like hunit actually uses a monad internally though.
11:28:55 <vamega> Is there a function to combine a list of predicates into a single predicate if any predicate is true?
11:29:21 <vamega> I tried searching hoogle for [(a -> Bool)] -> [a] -> Bool
11:29:25 <vamega> But didn't find anything.
11:29:28 <exicer> tangentstorm: Cool, looks promising.
11:30:40 <byorgey> vamega: do you mean [a -> Bool] -> a -> Bool?
11:31:15 <vamega> Oh yes I did.
11:31:17 <vamega> That makes sense
11:31:27 <vamega> I was conflating two different approaches.
11:31:27 <vamega> THanks
11:32:32 <vamega> Alright, no results for [a -> Bool] -> a -> Bool either.
11:32:37 <vamega> I found any
11:32:48 <vamega> on the Foldable typeclass.
11:33:03 <vamega> But it doesn't seem to be what I want.
11:33:28 <rwbarton> you can just use the regular one
11:33:30 <rwbarton> :t any
11:33:30 <byorgey> @type \preds a -> any (map ($a) preds)
11:33:31 <lambdabot> (a -> Bool) -> [a] -> Bool
11:33:32 <lambdabot>     Couldn't match expected type ‘a -> Bool’ with actual type ‘[b]’
11:33:32 <lambdabot>     Relevant bindings include
11:33:32 <lambdabot>       preds :: [a1 -> b] (bound at <interactive>:1:2)
11:33:44 <rwbarton> any ($ x) fs
11:34:31 <byorgey> oh, right
11:34:36 <byorgey> @type \preds a -> any ($a) preds
11:34:38 <lambdabot> [a -> Bool] -> a -> Bool
11:36:46 <tangentstorm> so ($a) creates a function that passes a to another function?
11:36:54 <byorgey> tangentstorm: right
11:36:59 <tangentstorm> :t ($a)
11:37:00 <lambdabot> (Expr -> b) -> b
11:37:11 <byorgey> tangentstorm: ($) :: (a -> b) -> a -> b   is just infix function application
11:37:13 <tangentstorm> :t ($5)
11:37:14 <lambdabot> Num a => (a -> b) -> b
11:37:24 <c_wraith> tangentstorm: yes, though with certain extensions enabled, you probably want to put a space after the $
11:37:25 <tangentstorm> neat
11:37:28 <byorgey> ($a) is an operator section that partially applies it to its second argument
11:37:43 <byorgey> @type (getAny .) . mconcat . map (Any .)  -- more fancier
11:37:44 <lambdabot> [a -> Bool] -> a -> Bool
11:37:58 * hackagebot directory-layout 0.7.2.0 - Directory layout DSL  http://hackage.haskell.org/package/directory-layout-0.7.2.0 (MatveyAksenov)
11:38:33 <joelteon> :t or
11:38:34 <lambdabot> [Bool] -> Bool
11:47:59 * hackagebot heist 0.13.1.2 - An Haskell template system supporting both HTML5 and XML.  http://hackage.haskell.org/package/heist-0.13.1.2 (DougBeardsley)
11:49:25 <rogovski> :t modifyMVar_
11:49:26 <lambdabot> Not in scope: ‘modifyMVar_’
11:49:35 <rogovski> the docs for this and takeMVar say "...will replace the original contents of the MVar if an exception is raised during the operation. This function is only atomic if there are no other producers for this MVar". what does "no other producers" mean here?
11:50:48 <rwbarton> no other threads that might put the MVar
11:51:05 <rwbarton> without trying to get it first
11:52:50 <rwbarton> http://neilmitchell.blogspot.com/2012/06/flavours-of-mvar_04.html is a good read
11:53:43 <rogovski> thanks i'll give it read.
11:54:11 <MitchellSalad> rwbarton: throw that up on http://www.dohaskell.com :)
11:54:49 <jle`> :t \ps -> or . ap ps . pure
11:54:50 <lambdabot> [a -> Bool] -> a -> Bool
11:55:59 <jle`> > (or . ap [(> 4), even, (< 2)] . pure) 1
11:56:00 <lambdabot>  True
11:56:59 <jle`> hm
11:58:05 <lwm> ooh, dohaskell is cool
11:58:37 <MitchellSalad> thanks, been working on it for a couple weekends, it's pretty janky and the CSS is god awful but it works :P
11:59:08 <jle`> > (\x -> ala Any foldMap (($x) <$> [(> 4), even, (< 2)])) 1
11:59:10 <lambdabot>  True
11:59:42 <jle`> in some world, (or . ap ps . pure) is readable and neat
11:59:57 <jle`> maybe not this world :(
12:00:23 <lwm> MitchellSalad : next time I have some free time, I will see if I can add anything to those stylesheets
12:00:45 <MitchellSalad> right on
12:00:46 <lwm> although something about it just feels about right ... it is akin to haskell.org
12:02:25 <jomg> jle`: where does 'ala' come from?
12:02:49 <jle`> jomg: lens and there's also the standalone package that provides it
12:03:10 <jomg> ok, i need to look into lens anyway at some point
12:03:36 <jle`> it uses typeclasses basically, to define a wrapper/unwrapper for a given type
12:04:06 <jle`> so you pass in Any, and it knows using a typeclass to use getAny to unwrap the final result
12:04:15 <jomg> oh, that seems useful
12:04:46 <jle`> > ala Endo foldMap [(*3),(^2),(+4)] 7
12:04:48 <lambdabot>  363
12:04:51 <suls> MitchellSalad: thanks for this link! amazing collection!
12:04:52 <jomg> though i'd probably still write something like (or . ap ps . pure)
12:05:26 <jle`> i would use or.ap ps.pure only to avoid ($x)
12:05:35 <jle`> that idiom really bothers me for some reason :/
12:05:41 <joelteon> template haskell
12:05:43 <jle`> i think i am lone though
12:05:45 <jle`> alone
12:05:48 <jle`> ($ x)
12:06:05 <jle`> maybe i just think $ is an ugly operator
12:06:17 <Iceland_jack> jle`: It is :) but there are plenty of ways of getting rid of it
12:06:29 <MitchellSalad> suls: no prob, i literally just threw it up an hour ago so i would not say the collection is amazing yet, but i'll keep adding to it
12:06:30 <Iceland_jack> something as simple as
12:06:30 <Iceland_jack>     [ f x | f ← fs ]
12:06:30 <Iceland_jack> in the case of 'map ($ x) fs'
12:06:33 <jle`> yeah, hence my or . ap ps . pure
12:06:45 <jle`> to replace any ($ x) ps
12:06:50 <jle`> oh
12:06:52 <jle`> that's neat
12:07:11 <jle`> idk for that i'd probably do fs <*> [x]
12:07:21 <Iceland_jack> if you think that's clearer
12:07:25 <jle`> because i also don't like list comprehensions
12:07:31 <jle`> i'm very particular :|
12:07:37 <Iceland_jack> but I would vastly prefer 'any ($ x) ps' over 'or . ap ps . pure'
12:07:51 <jle`> or (ps <*> x)
12:07:56 <Iceland_jack> Both
12:08:03 <jle`> er, `or (ps <*> [x])`
12:08:13 <jle`> yeah, in real code i would probably use ($ x)
12:08:16 <andrewdeandrade> Out of curiosity, did anyone here just see the Apple demo for Swift about 15 minutes ago? Looks like they've learned a lot from Haskell in designing it (but with a far less terse syntax)
12:08:32 <jle`> but on my free time like now i try to imagine living in a world with no ($)
12:08:45 <Iceland_jack> you can always just write (\f -> f x) as well
12:08:47 <rwbarton> all of these rewritings violate the Say What You Mean principle
12:08:48 <Iceland_jack> instead of ($ x)
12:08:59 <rwbarton> that one is fine of course
12:09:01 <jle`> i like list comprehensions for stuff like [ x | Right x <- [Left 7, Right 8, Left 9] ] tho
12:09:13 <Iceland_jack> jle`: I find that things may be clear in isolation (i.e. tiny code snippets) but when you're working on huge pieces of code, things like 'or . ap ps . pure' will piss you off
12:09:27 <jle`> Iceland_jack: true; i agree with that sentiment
12:09:36 <jomg> Iceland_jack: but why would you use a lambda if you could just spend your time trying to figure out how to do it with higher-order functions? :P
12:09:44 <prinsen> Im using a generated apache thrift library, and haddock gives me the following type
12:09:47 <prinsen> listNotebooks :: (Protocol a2, Protocol a1, Transport t, Transport a) => (a2 t, a1 a) -> Text -> IO (Vector Notebook)
12:09:50 <jle`> i wouldn't write or . ap ps . pure in real code, but this hour is my time to imagine a better world
12:10:04 <prinsen> How would I create the tuple, what library functions exists?
12:10:12 <Iceland_jack> > (,) True 5
12:10:13 <lambdabot>  (True,5)
12:10:50 <jomg> uncurry (,) may well be the most useless function ever
12:11:18 <klrr_> :t uncurry (,)
12:11:19 <lambdabot> (a, b) -> (a, b)
12:11:27 <klrr_> id?
12:11:31 <c_wraith> Eh.
12:11:35 <c_wraith> id is more useful
12:11:41 <c_wraith> It's more polymorphic. :)
12:11:43 <Philonous> @type curry id
12:11:43 <merijn> You know what's cool?
12:11:44 <lambdabot> a -> b -> (a, b)
12:11:45 <fread2282_> can code be resumed after an exception is thrown?
12:11:46 <klrr_> > uncurry (,) (1,2)
12:11:47 <lambdabot>  (1,2)
12:11:47 <monochrom> uncurry (,) is nothing near safeFromJust
12:11:55 <klrr_> c_wraith: indeed :P
12:11:55 <merijn> > ('c',, 5) True -- tuple sections!
12:11:57 <lambdabot>  ('c',True,5)
12:12:12 <merijn> fread2282_: Define "resumed"
12:12:16 <klrr_> interesting, never seen that
12:12:20 <Iceland_jack> fread2282_: You can catch exceptions if that's what you're asking
12:12:36 <merijn> klrr_: It works with arbitrary complex partially applied tuples (if you enable the extension)
12:12:54 <klrr_> > (1,,,4) 2 3
12:12:55 <lambdabot>  (1,2,3,4)
12:13:01 <klrr_> merijn: thanks
12:13:19 <fread2282_> merijn: is when (whatever) error "error"; foo == whateverR <- whatever; if whatever then error "error" else foo
12:13:24 <merijn> fread2282_, Iceland_jack: Also, you can throw exceptions to other threads, so if you do that you will continue uninterrupted* of course
12:13:33 <jle`> :t uncurry (,,5)
12:13:34 <lambdabot> Num t => (a, b) -> (a, b, t)
12:13:51 <jle`> > (uncurry (,,3)) (1,2)
12:13:53 <lambdabot>  (1,2,3)
12:13:56 <merijn> fread2282_: Well error is hard to catch anyway
12:13:57 <jle`> hm
12:14:00 <merijn> fread2282_: Due to laziness
12:14:16 <jle`> uncurry (x,,) is like cons :)
12:14:18 <merijn> fread2282_: it really shouldn't be used for anything you intend to catch and handle
12:14:34 <merijn> > (1,,3,) 2 4
12:14:35 <jle`> > let cons x = uncurry (x,,) in cons 1 (2,3)
12:14:36 <lambdabot>  (1,2,3,4)
12:14:37 <lambdabot>  (1,2,3)
12:14:46 <jle`> > let cons x = uncurry (x,,) in 1 `cons` (2,3)
12:14:47 <lambdabot>  (1,2,3)
12:15:38 <merijn> fread2282_: To be precise 'error "foo"' only throws an error when it is forced, but that can happen anywhere outside of your handling code
12:15:44 <jomg> jle`: though, you'd need to define it for all different sizes of tuples for it to be of any use
12:16:01 <jle`> aw
12:16:05 <merijn> jomg: Tuples have a maximum size anyway (63, I believe)
12:16:16 <jomg> yea, tuples are kind of a pain
12:16:28 <jle`> tuples are useful for exactly what they are meant for :)
12:16:36 <jomg> they take up way too much space in haddock instance lists
12:17:18 <Philonous> Hmm, now the I have implemented prisms for the datatypes in my library I'm tempted to pull in lens so I can actually use them :
12:17:20 <Philonous> :>
12:17:33 <edwardk> hah
12:17:36 <jomg> jle`: i do wonder though whether it would be useful to have something like ((a, b), c) treated equally as (a, b, c)
12:18:03 <ab9rf> but they're not the same thing :)
12:18:14 <jle`> they are the same up to a unique isomorphism
12:18:15 <jomg> seems like it might make working with tuples easier, but i don't know whether it would always work
12:18:17 <Iceland_jack> jomg: Some EDSLs do the opposite
12:18:44 <jle`> the way tuples and uncurrying work sort of makes working with "monoidal functors" neat or something
12:18:49 <Iceland_jack> If you write '(a, b, c)' it automatically gets transformed into a core data type, something like (Pair (Pair a b) c)
12:18:55 <Philonous> jomg, (a,b,c) should be sugar for (a, (b,c)). Would make life much easier.
12:19:08 <Pythonfant> I'm getting some really strange behaviour when trying to calculate the worstcase of my mergesort for 8 elements. My function prints out a list and says it needed 17 comparsions for that but if I then run mergesort on that list again it tells me it needed 12 comparisons. code and output: http://lpaste.net/104990
12:19:15 <jle`> @let (**) = liftA2 (,) in uncurry (+) (Just 1  ** Just 2)
12:19:15 <lambdabot>  Parse failed: Parse error: in
12:19:20 <jle`> > let (**) = liftA2 (,) in uncurry (+) (Just 1  ** Just 2)
12:19:21 <lambdabot>  Couldn't match type ‘Data.Maybe.Maybe’ with ‘(,) (a, b)’
12:19:21 <lambdabot>  Expected type: ((a, b), a)
12:19:21 <lambdabot>    Actual type: Data.Maybe.Maybe aCouldn't match type ‘Data.Maybe.Maybe’ with...
12:19:21 <lambdabot>  Expected type: ((a, b), b)
12:19:21 <lambdabot>    Actual type: Data.Maybe.Maybe b
12:19:30 <jle`> > let (**) = liftA2 (,) in uncurry (+) <$> (Just 1  ** Just 2)
12:19:32 <lambdabot>  Just 3
12:19:40 <jomg> Philonous: though then you might need to always be careful about how you arrange nested tuples
12:19:51 <jle`> > let (**) = liftA2 (,) in (uncurry.uncurry) (\x y z -> x+y+z) <$> (Just 1  ** Just 2 ** Just 3)
12:19:53 <lambdabot>  Just 6
12:20:12 <jle`> > let (**) = liftA2 (,) in (uncurry.uncurry.uncurry) (\x y z i -> x+y+z*i) <$> (Just 1  ** Just 2 ** Just 3 ** Just 4)
12:20:14 <lambdabot>  Just 15
12:20:17 <jle`> i don't know what i am trying to prove anymore
12:20:26 <jomg> i don't either :)
12:20:35 <ab9rf> now i want curry
12:20:56 <jle`> :t curry
12:20:57 <lambdabot> ((a, b) -> c) -> a -> b -> c
12:20:58 <jle`> there ya go :)
12:21:21 <ab9rf> i was more thinking the spicy kind with maybe some chickpeas
12:21:29 <jomg> ab9rf: i actually had currywurst today
12:21:43 <jle`> :t fix (uncurry (,))
12:21:44 <lambdabot> (a, b)
12:21:48 <ab9rf> there's an indian lunch box place across the road....
12:21:59 <Philonous> Why must lens depend on TH. TH breaks cross-compilation.
12:22:00 <merijn> Pythonfant: Unrelated to your question (because I'm too tired to figure it out), why not simplify your mergesort? Right now you keep recursively splitting the list in halves, any easier way might be to just "map (:[]) list" to create a list of 1 element lists and then recursively merge pairs of those lists?
12:22:34 <Pythonfant> merijn: hm right I did not think of that
12:22:34 <c_wraith> Philonous: because TH's data structures are a pain to work with, and having lenses for them is really handy.
12:22:44 <Pythonfant> still that's not my mainproblem
12:23:18 <Pythonfant> it seems to work, at least the lists are sorted
12:23:22 <c_wraith> No one ever defaults to bottom-up mergesort, even though it's nearly always simpler.
12:23:54 <merijn> Pythonfant: Yeah, I know, it's just that after looking at your code for a few seconds I realised I'm too tired to attempt to help with your actual issue :)
12:24:21 <Pythonfant> merijn: hehe, good night then
12:25:10 <rwbarton> depending on template-haskell the library doesn't break cross-compilation (I think?), using the TemplateHaskell language extension does
12:27:23 <Philonous> rwbarton, Yes, but doesn't lens do that?
12:27:40 <luite> time for cross-compiler writers to get more clever :p
12:28:13 <rwbarton> Philonous: yes I think so
12:28:15 <jle`> the poor souls
12:28:22 <luite> (at budhac we built a proof of concept for running template haskell code for ghcjs through node.js)
12:28:59 <merijn> luite: You're an obscene person
12:29:09 <luite> :(
12:29:24 <merijn> I meant that in a good way :p
12:29:44 <luite> it will take a bit more time to implement the whole Quasi instance though, since there's persistent state between the splices in template-haskell-2.9.0.0
12:30:19 <Philonous> rwbarton, Yeah, seems like it. I just grepped the git repo for "LANGUAGE Templatehaskell" and it turns up in a few places
12:30:21 <luite> so we have to fire up a node.js servr for the whole module, and some protocol for reification to work
12:30:38 <Peaker> Apple launches a new ML clone??
12:30:50 <merijn> Peaker: What'd I miss?
12:31:02 <luite> fortunately there's still zurihac to finish this :)
12:31:25 <Peaker> merijn: The new "Swift" language by Apple.. from a *very superficial* skim, it seems to be yet-another-ML-clone, but I've not looked much yet :)
12:31:50 <Peaker> but they're emphasizing OO so maybe not, hmm
12:32:06 <hakujin> looks a lot like javascript from their examples
12:32:09 <hakujin> closures, etc
12:32:52 <c_wraith> Pythonfant: well, in simplest terms..  The reason is that that list isn't the worst-case input for mergesort
12:33:26 <c_wraith> Pythonfant: why do you assume it is?
12:33:33 <Pythonfant> c_wraith: I don't assume that
12:33:36 <Pythonfant> but my code says that
12:34:22 <c_wraith> Pythonfant: your code says that the worst-case, *when sorted* is those 8 elements.
12:34:47 <c_wraith> Pythonfant: you're not printing the input
12:35:53 <Pythonfant> I don't quite understand what you mean. I take all combinations with replicateM, then I map runWriter . mergesort over them so I have a list of tuples with the input and the number of comparisons and then I use maximumBy' to get the maximum
12:35:59 <Pythonfant> How am I not taking the input
12:36:49 <Watcher7> i love you
12:37:06 <Watcher7> Err, wrong channel.
12:37:38 <monochrom> you can love this channel :)
12:37:47 <Forgetaboutit> or Haskell
12:37:54 <c_wraith> Pythonfant: you're printing the result of runWriter . mergeSort over some input
12:38:05 * hackagebot rtlsdr 0.1.0.0 - Bindings to librtlsdr  http://hackage.haskell.org/package/rtlsdr-0.1.0.0 (adamwalker)
12:38:07 * hackagebot learn-physics 0.5 - Haskell code for learning physics  http://hackage.haskell.org/package/learn-physics-0.5 (ScottWalck)
12:38:08 <awestroke> Can anyone familiar with repa help me identify why this loop can sum 10000 numbers in ~300 processor cycles: http://lpaste.net/6982027049741320192
12:38:18 <awestroke> this function*
12:38:40 <benzrf> h
12:38:41 <Pythonfant> c_wraith: yes, I thought that was what I wanted
12:38:52 <c_wraith> Pythonfant: that's the *output*
12:39:01 <c_wraith> Pythonfant: but you're assuming it's the input
12:39:10 <Pythonfant> oh crap
12:39:19 <Pythonfant> got me :)
12:40:15 <rwbarton> oh, I'm getting that weird "Failed to load interface for ‘Data.Text’" "no package matching ‘text-1.1.1.3’ was found" error
12:40:31 <rwbarton> while doing 'cabal install void', which doesn't even have a dependency on text
12:40:43 <Pythonfant> c_wraith: thx for your help and sorry for being so stupid
12:42:12 <deni> is there a haskell weekly or something like that? or any kind of newsletter that you guys would suggest?
12:42:44 <tdammers> deni: if you subscribe to the haskell newletter, you'll get the weekly newsletter
12:42:58 <tdammers> s/newletter/mailing list/
12:43:02 <rwbarton> @where HWN
12:43:02 <lambdabot> Haskell Weekly News http://contemplatecode.blogspot.com/ For older posts, see http://sequence.complete.org/
12:43:21 <tdammers> plus a few dozen other daily messages :P
12:45:18 <deni> tdammers: but that's not the same is it? i mean, a mailing list set to weekly digest isn't the same as a newsletter
12:45:23 <athan_> Hey guys, I'm probably going to sound like an idiot, but are there any good introductory texts to recursion schemes and grammar encodings, like bnf? I'd really like some help with my brain exploding :)
12:45:26 <Forgetaboutit> How do I use lenses created with `makeClassy'?
12:46:03 <merijn> athan_: BNF is pretty easy, there's an RFC describing the extended BNF used in RFCs
12:46:19 <Forgetaboutit> I don't get the type `(HasFoo t, Functor f) => (Int -> f Int) -> t -> f t' means
12:46:24 <bernalex> Forgetaboutit: have you seen http://www.haskellforall.com/2013/05/program-imperatively-using-haskell.html ?
12:46:26 <merijn> athan_: Recursion schemes, I haven't found a good intro to
12:46:31 <bernalex> Forgetaboutit: also there's #haskell-lens
12:46:53 <Forgetaboutit> bernalex: No and no, but thank you :)
12:46:55 <athan_> merijn: Ahh wow, okay! Thank you!
12:47:06 <bernalex> merijn: athan_: yeah BNF is quite easy, and it's like UML in that everyone just uses "simplified" versions where they take what they need.
12:47:26 <monochrom> I think you need not worry about recursion schemes.
12:47:39 <bernalex> the simplified version used in the haskell report is nice. and it's explained well in the intro too.
12:48:30 <deni> rwbarton: so this is the official newsletter (official being used lightly here)? why blogger why oh why? XD any change to get that in my inbox somehow? or should i just use rss?
12:49:10 <monochrom> deni: the haskell weekly news is also posted to the haskell mailing list
12:49:15 <athan_> bernalex, merijn: Thank you for your input :), what would the complicated / complex versions be? I would really like to master languages. What direction should I go?
12:49:15 <deni> tdammers: just saw your comment "plus a few hundred message" :P
12:49:31 <tristanStrange> hey all... any one point me at a nice haskell'y weighted choose?
12:49:37 <deni> monochrom: that doesn't sound very nice XD
12:49:54 <monochrom> why is it not nice? you asked for inbox
12:49:56 <merijn> athan_: Most grammars are easy, the tricky is generating efficient parsers for them :p
12:50:03 <tristanStrange> where i can choose items from list with different probs for each item?
12:50:15 <deni> monochrom: yeah for one weekly mail....not a few thousand :D
12:50:35 <monochrom> what thousand? there were merely 41 messages in the past 30 days
12:50:37 <merijn> athan_: The complexity of most parser generators is not from the complexity of specifying grammars, but the complexity of "specifying grammars in a way that lets us generate efficient parsers"
12:50:44 <deni> monochrom: seriously?
12:50:48 <monochrom> yes
12:50:50 <joebobjoe> If I learn Haskell in college, will it help my job prospects?
12:50:53 <bernalex> merijn: grammars being easy is sort of vital I guess
12:50:57 <deni> monochrom: ok I did not anticipate that :D
12:51:07 <bernalex> joebobjoe: absolutely
12:51:10 <merijn> athan_: You can learn (E)BNF in like half an afternoon with the RFC spec, tbh
12:51:21 <Iceland_jack> joebobjoe: depends
12:51:25 <albeit> If I construct a lazy Text in one thread, place it in an MVar, and have another thread write it to a file, which thread actually does the work of evaluating the components of lazy Text?
12:51:26 <monochrom> 0.041 thousand messages
12:51:27 <deni> monochrom: tnx for that info
12:51:45 <merijn> albeit: the writing thread
12:51:47 <bernalex> Iceland_jack: joebobjoe: well, yeah, it depends on what job you want.
12:52:06 <albeit> merijn: Is there any way to  have the reading thread evaluate it?
12:52:18 <deni> monochrom: i get a lot of email really....and i subscribe to a lot of mailing lists and end up not reading any of it...then usbcribing after some time
12:52:21 <merijn> albeit: Yes, use strict Text :p
12:52:22 <rwbarton> reading thread?
12:52:34 <deni> monochrom: but if it's not that spamy then i guess it's fine
12:52:46 <albeit> merijn: Oh I thought you meant by writing thread the one that puts it in the MVar, gotcha now
12:53:00 <monochrom> the haskell mailing list is mostly announcements. and even then very few announcements appear. like I said, 41/30 messages per day
12:53:04 <albeit> merijn: Thats great then! Writing to file thread is what i need
12:53:06 <joebobjoe> Iceland_jack: I want to work on safe embedded systems.
12:53:06 * hackagebot directory-layout 0.7.3.0 - Directory layout DSL  http://hackage.haskell.org/package/directory-layout-0.7.3.0 (MatveyAksenov)
12:53:33 <monochrom> people seem to be more content to announce on reddit
12:54:36 <monochrom> this works great for me. it means that by ignoring reddit and just reading the haskell mailing list, I skip the lowest-common-denominator announcements
12:55:52 <Ainieco> does "put . f =<< get" State monad pattern is already abstracted in some library?
12:56:13 <dmj`> Ainieco: modify I think
12:56:20 <dmj`> @src modify
12:56:20 <lambdabot> Source not found. There are some things that I just don't know.
12:56:36 <dmj`> @src MonadState
12:56:36 <lambdabot> Source not found. And you call yourself a Rocket Scientist!
12:56:51 <dmj`> modify :: (MonadState s m) => (s -> s) -> m ()
12:56:51 <dmj`> modify f = do
12:56:51 <dmj`>     s <- get
12:56:52 <dmj`>     put (f s)
12:57:07 <monochrom> "modify" is right. find it alongside your State library
12:57:16 <monochrom> read the doc. always read the doc
12:57:27 <Ainieco> dmj`: thank you
12:57:31 <monochrom> read the doc from cover to cover. read the doc again from cover to cover.
12:57:43 <jle`> and then read it from cover to cover
12:57:49 <jle`> (you can't tell, but i swapped the cover's)
12:57:53 <jle`> (so the last cover is first)
12:58:02 <monochrom> yes, that is good too
12:58:07 * hackagebot rtlsdr 0.1.0.1 - Bindings to librtlsdr  http://hackage.haskell.org/package/rtlsdr-0.1.0.1 (adamwalker)
12:58:09 * hackagebot FontyFruity 0.3 - A true type file format loader  http://hackage.haskell.org/package/FontyFruity-0.3 (VincentBerthoux)
12:58:10 <jomg> jle`: just wanted to say "then read it backwards" :P
12:59:06 <dmj`> lambdabot is so condescending sometimes :(
13:00:01 <monochrom> don't call yourself a rocket scientist, and you're ok
13:01:21 <dmj`> ugh fine
13:02:36 <S3thc0n> Hello everyone! Am I correct in thinking that 'Tying the knot' in Haskell depends on whatever the opposite of forward declaration is called (a name is used before it is defined)? Is there any other way except using obvious mutation?
13:02:58 <vanila> recursion
13:03:02 <dmj`> http://www.haskell.org/haskellwiki/Tying_the_Knot
13:04:22 <tanmaig> Hi all. Is there a way to unregister a ghci package, and then reinstall the broken ones?
13:10:19 <marchelzo> is there a way to getLine and read at the same time?
13:10:46 <rwbarton> readLn
13:12:10 <marchelzo> rwbarton: thank you!
13:12:20 <marchelzo> my google-fu is weak
13:13:08 * hackagebot learn-physics-examples 0.5 - examples for learn-physics  http://hackage.haskell.org/package/learn-physics-examples-0.5 (ScottWalck)
13:13:53 <tanmaig> Hi all. Is there a way to unregister a ghci package, and then reinstall the broken ones?
13:14:51 <dmj`> tanmaig: ghc-pkg unregister <packagename>
13:15:04 <dmj`> tanmaig: you might need to force it if other packages depend on it
13:15:16 <dmj`> tanmaig: I recommend using a sandbox for doing something dangerous like this
13:15:28 <rwbarton> you can force it?
13:15:38 <rwbarton> I always just guess what order to unregister the dependant packages in
13:15:52 <dmj`> rwbarton: yea, w/ --force
13:16:00 <dmj`> it'll say something like (ignoring)
13:16:07 <dmj`> and you'll feel all dirty inside
13:16:30 <rwbarton> good to know
13:17:07 <rwbarton> I guess you can do it without --force and see what it will break and then unregister everything with --force and not have to guess the order
13:17:59 <dmj`> once a build works I just cabal freeze it, no more games
13:18:04 <jamiehannaford> is there any way to differentiate a variable's type after a pattern match?
13:18:20 <jamiehannaford> i'm working with binary trees on the yorgey course
13:18:45 <tanmaig> Um. I think I've totally screwed my compile up. I upgraded to the new version of aeson, and a bunch of other packages died.
13:18:55 <hseg> Weird. Found for the first time a piece of actual code that uses explicit layout: http://hackage.haskell.org/package/countable-0.1/docs/src/Data-Searchable.html
13:19:10 <Philonous> tanmaig, rm -rf ~/.ghc and start over?
13:19:17 <tanmaig> Is there a way to force a compile with a specific version of a package (if you have many)?
13:19:29 <tanmaig> Philonous: I guess, I'll do that if everything else fails.
13:19:49 <dmj`> tanmaig: cabal sandbox init. cabal install aeson-0.7.0.6 -j
13:19:59 <rwbarton> add it to the cabal install command line
13:20:11 <rwbarton> cabal install foo aeson-0.7.0.6
13:20:14 <Philonous> tanmaig,cabal install  --constraint="package-name == version"
13:20:17 <rwbarton> or cabal install foo --constrain .... that
13:20:20 <dmj`> jamiehannaford: can you show code? Pattern matching is how you differentiate the type, maybe I'm not understanding
13:20:33 <tanmaig> Philonous: Thanks, will, try that out.
13:21:13 <jamiehannaford> dmj` it's exercise 2 of http://www.seas.upenn.edu/~cis194/hw/04-higher-order.pdf
13:21:22 <jamiehannaford> code is here: https://gist.github.com/jamiehannaford/51bf3dc4dfe11e665e66
13:22:08 <jamiehannaford> so far it just appends to the right, creating a chain all the way up (1 leaf per level). I instead want each node to have 2 leaves instead of 1
13:23:09 * hackagebot Rasterific 0.3 - A pure haskell drawing engine.  http://hackage.haskell.org/package/Rasterific-0.3 (VincentBerthoux)
13:25:00 <dmj`> jamiehannaford: so you're attempting a simple binary search tree it seems
13:25:11 <dmj`> I shouldn't say simple, but a binary search tree
13:25:17 <jamiehannaford> mdj` but with a depth tracker
13:25:25 <jamiehannaford> dmj` ^
13:25:58 <jamiehannaford> i.e. a variable that tracks the height of the binary tree
13:27:12 <gdoteof> i have essentially a 'blackbox' process that i read/write to using pipes.  the problem is that some of the messages are above the 64k limit and when that happens the data can get interleaved (since there are multiple threads talkign to the same blackbox)
13:27:47 <gdoteof> apparently the way to fix this is using fcntl to increase the size of the pipe buffer, and i am wondering how i can do that within haskell
13:27:49 <dmj`> jamiehannaford: On leaf deletion you'd have to recalculate the depth at each node. So delete would lose logarithmic time
13:28:47 <pjdelport> gdoteof: interleaved?
13:29:13 <dmj`> jamiehannaford: so if you had data BST a = Empty | Node a (BST a) (BST a)
13:29:16 <pjdelport> Do you have multiple threads / processes writing to the same pipe? That's probably not safe regardless of what the buffer size is.
13:29:20 <gdoteof> pjdelport: right, the writes are only guaranteed to be atomic if they are below 64k
13:29:35 <dmj`> your insert could be: insert :: Ord a => a -> BST a -> BST a
13:29:46 <gdoteof> since there are multiple process writing to the same pipe, i sometimes end up with <message1.part1><message2><message2.part2>
13:30:13 <gdoteof> and the 'blackbox' process reads upto <message1.part1> and thinks it's the end of the input and bonks
13:30:15 <jamiehannaford> dmj` yeah, but I'm wondering how you differentiate inserting the new Node to the left or right of current tree
13:30:39 <rwbarton> gdoteof, probably it's more sensible to take a lock (e.g. MVar) when writing to the process
13:30:49 <pjdelport> gdoteof: It's only atomic below PIPE_BUF bytes, which is only guaranteed to be 512 bytes in POSIX, and apparently 4096 bytes in Linux.
13:30:55 <jamiehannaford> with normal binary trees, you can do a "greater than" operation against current tree's value. But with the yorgey version, you can't do that AFAIK
13:31:08 <dmj`> jamiehannaford: You'd need whatever you're inserting to be an instance of the Ord typeclass, this way you can use (<) and (>) to recursively find the position you'd need to insert at
13:31:11 <rwbarton> jamiehannaford: right
13:31:27 <rwbarton> jamiehannaford: you need to come up with some overall strategy for ensuring balanced-ness first
13:32:16 <dmj`> yea, let's decide what tree we want first, BST's aren't balanced
13:32:24 <jamiehannaford> rwbarton says here "A binary tree is balanced if the height of its left and right subtrees differ by no more than 1, and its left and right subtrees are also balanced"
13:32:39 <rwbarton> yes
13:32:53 <gdoteof> pjdelport: right sorry it is 4k.  64k is the size of the pipe not the size of the guaranteed atomic write.  in any case i am trying to increase the size of the guaranteed atomic write
13:32:57 <pjdelport> gdoteof: So it seems to be safe you need to fragment messages into PIPE_BUF-sized chunks, and reassemble them, if you want to be safe?
13:33:03 <gdoteof> rwbarton: i will look at mvar
13:33:35 <pjdelport> gdoteof: You probably can't increase that size without changing the kernel.
13:33:48 <dmj`> jamiehannaford: correct if that condition holds, yes. But nothing inhernent in the BST accomplishes that, for that type of balancing you'd need a 2-3 tree, AVL or Red-Black tree.
13:34:09 <dfranke> Hi, I made my first attempt at writing Template Haskell yesterday. It works, but it's ugly and I'm looking for style advice. http://lpaste.net/104997
13:34:28 <dfranke> I think I'm not probably not using the quoting facilities as well as I could.
13:34:29 <gdoteof> pjdelport: well the problem is that the "blackbox" would need to do the reassambling
13:34:50 <dfranke> s/I'm not probably not/I'm probably not/
13:34:51 <dmj`> jamiehannaford: if I have a binary search tree and I insert [ 1 .. 10 ] it will create a linked list basically
13:34:51 <shachaf> whoa, it's dfranke.
13:34:56 <jamiehannaford> dmj` hmmm, I'm not sure since this is a fairly basic course plus it says each node has 2 children.
13:34:58 <pjdelport> It doesn't look like you can avoid that without switching to a transport other than pipes.
13:35:07 <jamiehannaford> the data type is data Tree a = Leaf | Node Integer (Tree a) a (Tree a)
13:35:15 <gdoteof> the blackbox process works flawlessly if just one process is writing, its when two competing threads are both writing to the pipe it is reading from at the same time
13:35:31 <dfranke> shachaf: do I have some sort of notoriety here that I wasn't aware of?
13:35:38 <jamiehannaford> IDK if Integer can be used to dictate position
13:36:06 <pjdelport> gdoteof: Can you synchronize all the writing threads with a mutex? That would be the other solution.
13:36:40 <shachaf> dfranke: Notoriety here? I don't think so.
13:37:09 <gdoteof> pjdelport: yeah i think that is what rwbarton is suggesting
13:44:44 <gamegoblin> What’s the notation for qualified infix functions. Like X.<?> or what?
13:45:37 <alpounet> yeah
13:45:51 <rwbarton> and the prefix form is (X.<?>)
13:45:52 <Philonous> gamegoblin, Yes, just prepend with the module name and a dot. Like x Foo.<= y
13:45:57 <gamegoblin> K. vim jdefault ust highlights it strangely.
13:45:58 <alpounet> > (+1) Prelude.. (*2) $ 4
13:46:00 <lambdabot>  9
13:46:06 <dmj`> jamiehannaford: oh, he does want you to make a balanced tree, fun. Seems like the only operation he wants is insert. So just distribute evenly on insertion
13:46:07 <dmj`>  
13:46:07 <gamegoblin> vim default just*
13:47:21 <literon> good morning!
13:47:55 <literon> what is the practical difference between say Producer and Producer' (the latter having some existentially quantified types) of pipes in practice?
13:48:15 <gamegoblin> Do you live in East Asia or Australia? (morning)
13:48:33 <literon> kind of a habit, don't attribute too much to that
13:48:46 <benzrf> literon: afaict, Producer is a Producer, while Producer' is something that at least satisfies the requirements of being a Producer but may also have other properties
13:49:01 <benzrf> literon: similar to Getting vs Lens in lens
13:49:16 <benzrf> *where Producer' is like Getting
13:50:02 <literon> now I wanted to check those two.. can you guess what do you get if you google "getting lens" ?
13:50:03 <tanmaig> Is it possible to compile My.hs with a specific version of bytestring ?
13:51:51 <Philonous> I just realized I could use lens-family as a leighter-weight replacement for lens. It doesn't seem to do any TH.
13:52:14 <glguy> literon: If you don't already know what lens package's "Getting" is, it probably isn't worth figuring out just to make sense of "Producer"
13:53:13 * hackagebot texmath 0.6.6.2 - Conversion of LaTeX math formulas to MathML or OMML.  http://hackage.haskell.org/package/texmath-0.6.6.2 (JohnMacFarlane)
13:53:18 <ycomb> is it a problem to read and parse a 160kB JSOn file on an Android phone? ()i dont have it yet so trying to decide if it is the right way to go...
13:54:42 <ycomb> sorry, wrong chan
13:55:01 <pjdelport> ycomb: Just don't use the org.json stuff, it's dog slow. :)
13:55:30 <pjdelport> Any decent third-party library should do.</offtopic>
13:55:38 <lwm> can someone please explain this simple one for me ...
13:55:50 <lwm> :t map (\x -> x + 1) [1,2,3,4,5]
13:55:51 <lambdabot> Num b => [b]
13:55:55 <shachaf> literon: "forall" doesn't mean "existentially quantified" :-(
13:55:58 <lwm> :t (\x -> x + 1)
13:55:59 <lambdabot> Num a => a -> a
13:56:13 <pjdelport> lwm: What would you like to know?
13:56:14 <shachaf> "forall a. ...a..." is universally quantified. forall is a universal quantifier.
13:56:24 <lwm> pjdelport: the a -> b part, they are both taking ints
13:56:34 <lwm> the anon function takes an int, and gives back an int
13:56:44 <pjdelport> Right.
13:56:50 <lwm> ha ...
13:57:22 <hpc> ooh, new jhc
13:57:23 <literon> shachaf: Sorry for the wrong terminology. Could you explain why is universal quantification needed there? Or how does it relate to what benzrf told?
13:57:39 <pjdelport> lwm: In this case, "Num a => a -> a" means a function "a -> a", where a is any instance of Num (that is, a numeric type)
13:57:39 <hpc> their changelog makes me actually want to read through the code
13:58:35 <literon> I assume it means that the universally quantified types don't matter from the point of that Producer, since it doesn't use them?
13:58:41 <pjdelport> lwm: So it's not limited to being Int -> Int, it can also be Float -> Float, Double -> Double, etc.
13:59:19 <lwm> pjdelport: ah yes, got it that
13:59:23 <lwm> got that**
13:59:31 <literon> I would like to figure out which one should I use in my api, and what the consequences are.
14:02:23 <shachaf> literon: I don't know anything about pipes or about what benzrf says.
14:02:39 <lwm> pjdelport: soo, `a -> b` are both of the Num type class but are not using the same type variable ...
14:02:59 <literon> shachaf: no problem
14:03:08 <pjdelport> lwm: a -> b would be a different thing, yes. Where do you get that from in this case?
14:04:06 <lwm> :t map
14:04:07 <lambdabot> (a -> b) -> [a] -> [b]
14:04:12 <literon> benzrf: do you think I am right if I say that client code possibly wants Producer, while an api is better interms of Producer' to allow greater flexibility?
14:04:43 <lwm> :pjdelport: it's this (a -> b) part of the map type signature that gets me. I know how it works, but why is it not (a -> a)
14:06:21 <pjdelport> lwm: Oh, that's because map is more generic, on its own. (a -> b) means that map can work with a function from any type to any other type, with no further constraints.
14:06:26 <tangentstorm> because what if you want to map, say, int -> string?
14:06:38 <pjdelport> lwm: (Num a => a -> a) is a special case of (a -> b)
14:07:56 <pjdelport> lwm: So when you're passing you're function to map, you'r basically "setting" both a and b of map's signature to "Num a => a"
14:08:04 <pjdelport> your function, even
14:08:38 <lwm> pjdelport, tangentstorm: ahhhh right
14:08:44 <kazagistar> > map show [1,2,3]
14:08:45 <lambdabot>  ["1","2","3"]
14:08:51 <lwm> mindblown myself by eval'ing this
14:08:53 <lwm> > map (\x -> "a") [1,2,3,4,5]
14:08:54 <lambdabot>  ["a","a","a","a","a"]
14:09:03 <lwm> it makes sense now ...
14:09:18 <lwm> thanks guys
14:09:46 <lwm> right, `map show [1,2,3]` is a more practical example ;)
14:11:07 <zwer> note that you can shorten your initial example:
14:11:14 <zwer> > map (+1) [1,2,3]
14:11:16 <lambdabot>  [2,3,4]
14:11:47 <zwer> :t (+1)
14:11:48 <lambdabot> Num a => a -> a
14:12:07 <kazagistar> lwm: ping ^^
14:12:35 <lwm> zwer: sweeet
14:13:57 <tangentstorm> @src preds
14:13:57 <lambdabot> Source not found. Wrong!  You cheating scum!
14:14:06 <tangentstorm> rude.
14:14:54 <epta> teaching scum*
14:14:59 <benzrf> how do i use Uniplate
14:15:41 <ocharles> Hmm, I wonder where mm_freak has got to
14:15:46 <ocharles> @seen mm_freak
14:15:46 <lambdabot> /\/\M_fr34K
14:15:54 <ocharles> how very useful, lambdabot
14:15:55 <benzrf> @seen sdfjioij
14:15:55 <lambdabot> zdphJiOiJ
14:15:58 <benzrf> u wot
14:16:10 <fread2282> what's the current state of the art FRP library?
14:16:30 <ocharles> fread2282: it somewhat depends what you want to do
14:16:55 <ocharles> elm is *a* state of the art FRP library which is very suited for the web
14:17:12 <napping> I thought elm was more of a language.
14:17:22 <fread2282> ocharles: using it for a GUI app, but don't care much if it has support for the big toolkits or not
14:18:12 <Clint> netwire and reactive-banana are trendy
14:18:21 <ocharles> netwire is great, but perhaps not so great for GUIs
14:18:47 <ocharles> netwire is about FRP where you have well framed data where the data can change at your sample rate - e.g. 60fps simulations
14:18:49 <napping> I think the netwire author recommended reactive-banana for GUIs, for whatever that's worth. Have you seen ocharles' awesome netwire tutorial/example
14:18:53 <fread2282> GUI will probably just be console for now though
14:19:07 <ocharles> napping: why thank you :) I'm actually back in FRP mode atm, so I'm sure I'll have more to write soon
14:19:37 <ocharles> fread2282: perhaps sodium? that is push-based FRP
14:19:51 <ocharles> and very much in active development
14:23:15 <napping> Do you know when reactive-banana 0.9 might be out?
14:24:20 <ocharles> I don't, I don't really know anything about reactive-banana
14:24:25 <napping> I was going to try it for GUI stuff, but I was put off by the combination of a warning that it leaks space in dynamic cases, and that it will be fixed in 0/9
14:24:30 <fread2282> is FRP a good idea for my use case? I'm writing an irc client with a console UI for now
14:25:19 <napping> probably overkill
14:26:02 <napping> I'm just learning, but it seems best for GUI type things where you can have lots of little interactions all over the place and lots of stuff to update
14:26:06 <zomg> If you're writing it just an exercise it probably doesn't matter so much =)
14:26:39 <napping> a console-based IRC client gets all input from one nice place from the user, and probably serializes output into nice simple screens
14:26:57 <napping> maybe a touch of fanciness like updating a clock asynchronously
14:28:03 <seydar> howdy y'all, i'm writing an echo server and i'm now trying to rewrite it to use Data.Text. compile issues galore. http://lpaste.net/104998
14:28:27 <napping> ocharles: would netwire work without a fixed framerate if you didn't use any of the integral type of operations?
14:28:46 <heatsink> :t strip
14:28:47 <lambdabot> Not in scope: ‘strip’
14:29:33 <Clint> seydar: getting Strings from a network socket is probably a bad idea
14:30:05 <seydar> Clint: what would you recommend I do? how do I get Data.Text (or Data.ByteString)?
14:30:21 <dmj`> seydar: probably want to enable overloadeds strings if you haven't
14:30:39 <napping> seydar: you're still using I/O operations that expect strings. Check Data.Text.IO for Text versions of hPutStrLn and friends
14:30:56 <ocharles> napping: fine, but it still means it can end up recomputing things pointlessly. and you only respond to events at the time you sample input
14:31:12 <ocharles> so if you sample input once a second, then your application will on average have a response time of 500ms, which is horrifically noticable
14:31:42 <napping> I was thinking rather of poking it every time a GUI event came in
14:32:20 <ocharles> Hm
14:32:32 <seydar> dmj`: will do. why isn't that standard though?
14:32:45 <seydar> napping: thank you, that looks like it's my main issue
14:33:08 <ocharles> I guess you could do that, but you might be better ditching the time aspect entirely and just combining automaton arrows or something
14:33:16 <napping> somewhat related, I'd be interested in a purely discrete time FRP framework (pace Conal) in hopes of getting a better idea what kind of operational efficiency you can get
14:33:24 <ocharles> because at that point your probably only interested in locally stateful components, so maybe you could focus on that
14:33:25 <boliver> @help
14:33:25 <lambdabot> help <command>. Ask for help for <command>. Try 'list' for all commands
14:33:31 <napping> like how these guys are actually implemented and stuff
14:33:52 <napping> ocharles: well, the interesting bit is figuring out which other stateful components need to be updated when you drive one input
14:34:14 <napping> under the assumption that all/most of them don't have autonomous behavior over time
14:34:36 <boliver> @pl f xs = pure sum <*> sequence xs
14:34:37 <lambdabot> f = (pure sum <*>) . sequence
14:34:37 <napping> Then again, it wouldn't be surprising if netwire assumed everything had to be reevaluated at the frame rate
14:35:56 <boliver> @pl f xs = return sum `ap` sequence xs
14:35:56 <lambdabot> f = (sum `fmap`) . sequence
14:36:57 <ocharles> napping: Sure, so you can still use the same ideas as FRP. You are just ditching the idea of time
14:37:28 <napping> What I don't understand is how to efficiently implement FRP
14:38:06 <ocharles> With the above you just run the entire simulation when a UI-changing event happens, because you're assuming that components don't change on their own
14:38:46 <napping> Sure, but I'd hope that "run the entire simulation" would only need to actually evaluate the parts affected by the input
14:38:50 <boliver> @pl = (fmap sum) . sequence
14:38:51 <lambdabot> (line 1, column 1):
14:38:51 <lambdabot> unexpected "="
14:38:51 <lambdabot> expecting white space, "()", natural, identifier, lambda abstraction or expression
14:39:05 <boliver> @pl f = (fmap sum) . sequence
14:39:05 <lambdabot> f = fmap sum . sequence
14:39:25 <merijn> boliver: That's already pointfree, what did you expect to happen?
14:39:54 <l0cust> Hey, y'all. I am getting dependency errors trying to install cabal-dev
14:40:31 <merijn> l0cust: Pretty sure cabal-dev is deprecated now that recent cabals have build in sandboxing
14:40:37 <l0cust> ah okay
14:40:45 <ocharles> napping: oh right. it sort of would
14:40:57 <merijn> l0cust: 1.18 and later should have sandboxing built in
14:41:05 <l0cust> they do
14:41:13 <l0cust> or at least mine does
14:41:14 <ocharles> napping: i believe to get true push based reactivity you need push frp. have you read "Push-Pull Functional Reactive Programming", with `unamb`?
14:41:36 <boliver> @pl sum1 = foldr1 (\a b -> pure (+) <*> a <*> b)
14:41:36 <lambdabot> sum1 = foldr1 ((<*>) . (pure (+) <*>))
14:41:43 <napping> A while ago, I wasn't trying to follow it too closely
14:41:49 <merijn> I second Push-Pull FRP it's a good intro to "proper" FRP
14:41:57 <boliver> @pl sum1 = foldr1 ((<*>) . (pure (+) <*>))
14:41:58 <lambdabot> sum1 = foldr1 ((<*>) . (pure (+) <*>))
14:42:01 <napping> unamb was supposed to be an efficient implementation?
14:43:25 <napping> well, it wouldn't hurt to recheck the expected semantics even if that's all I get out of it
14:46:33 <augur> new Swift lang!
14:46:36 <augur> still no ADTs!
14:46:53 <seydar> it doesn't look like ghc is recognizing my OverloadedStrings pragma. do i need to run `ghc --make` differently?
14:47:27 <Philonous> seydar, No, {-# LANGAUGE OverloadedStrings #-} at the top of the source file should do the trick
14:47:32 <napping> seydar: the extension is just so you can write a Text literal as a plain string literal. How are you putting the pragma?
14:47:56 <platz> augur: Swift has algebraic data types
14:48:06 <augur> platz: does it? i couldnt find any
14:48:07 <Philonous> seydar, Alternatively, you can put OverloadedStrings into the default-extensions segment of your cabal file
14:48:27 <epta> @hoogle (a -> IO (p, s)) -> [a] -> IO [(p,s)]
14:48:28 <lambdabot> No results found
14:48:31 <epta> ?
14:48:34 <platz> augur: They call them "enums", but they're sums of products with associated types
14:48:51 <platz> and you can pattern match on them
14:49:42 <rwbarton> epta, you sometimes have to figure out the reasonable generalization yourself
14:49:49 <rwbarton> @hoogle (a -> m a) -> [a] -> m [a]
14:49:50 <lambdabot> Test.QuickCheck.Arbitrary shrinkList :: (a -> [a]) -> [a] -> [[a]]
14:49:50 <lambdabot> Prelude mapM :: Monad m => (a -> m b) -> [a] -> m [b]
14:49:51 <lambdabot> Control.Monad mapM :: Monad m => (a -> m b) -> [a] -> m [b]
14:50:02 <seydar> Philonous, napping: i have it in my source exactly as you guys have it
14:50:05 <rwbarton> er, the second type signature is even more reasonable of course
14:50:39 <Philonous> seydar, OK, so, what did you write, what did you expect to happen, what happened instead?
14:50:41 <augur> platz: their enums allow recursive definitions?
14:50:57 <seydar> Philonous: i'm getting this error: Couldn't match type `[Char]' with `T.Text'
14:51:09 <excarna> seydar: you probably want to `T.pack` the string
14:51:18 <Philonous> seydar, Can you please paste the offending code (into a pastebin? )
14:51:38 <Philonous> excarna, He's using OverloadedStrings, so this shouldn't be necessary
14:51:50 <seydar> http://lpaste.net/105000
14:52:02 <rwbarton> unless, as seems likely, the String involved is not a literal
14:52:45 <rwbarton> okay, so on line 26, [] is not a string literal...
14:52:59 <Philonous> seydar, Those problems don't seem to be connected to OverlaodedStrings
14:53:09 <excarna> nor is `line`
14:53:20 <rwbarton> indeed
14:53:50 <Philonous> seydar, You can't pattern match on an empty Text with []. You should either use Text.null or match on ""  (since Text, unlike String, isn't a list)
14:54:08 <seydar> i feel like a demented ten year old i'm so sorry
14:54:17 <Philonous> seydar, No need
14:54:38 <sbrg> demented ten year old
14:54:42 <sbrg> heh.
14:55:22 <seydar> ok so i replaced [] with "" because you're right, now that i'm not playing with String i can do "" (though couldn't i also use "" for String?)
14:56:09 <Philonous> seydar, in line 31 you're using the wrong hGetLine. The unqualified one gives back a String, you want TIO.hGetLine
14:56:12 <napping> Without OverloadedStrings you could only use "" for strings
14:56:41 <napping> [] is generically empty list, and String happens to be a list of characters
14:56:44 <seydar> Philonous: yep, just fixed that
14:56:44 <napping> [Char]
14:56:45 <Philonous> seydar, Yes, "" is overloaded (hence _Overlaoded_Strings)
14:57:03 <seydar> the final error is with `putStrLn $ show line`
14:57:35 <platz> augur: not sure
14:57:49 <Philonous> seydar, I this case it would be easiest to just use the regular old putStrLn
14:57:50 <augur> platz: no recursiveness, no true ADTs
14:57:51 <seydar> the issue is that show is String -> String, and I need some sort of T.show
14:58:20 * hackagebot diagrams 1.2 - Embedded domain-specific language for declarative vector graphics  http://hackage.haskell.org/package/diagrams-1.2 (BrentYorgey)
14:58:21 <Philonous> seydar, Or you have to convert back to Text first (replace show with (Text.pack . show))
14:59:13 <napping> If you don't want the "" and escaping, you could drop the show instead
14:59:25 <Philonous> seydar, Oh, btw, don't use head, head is evil. Pattern match on the list instead, even if you just leave out the empty case.
14:59:36 <rwbarton> it's an Int isn
14:59:37 <rwbarton> t it
14:59:49 <seydar> Philonous: kk, will do
15:00:03 <seydar> is there a show that takes Int -> Text?
15:00:16 <seydar> wait stop stand back i'm going to hoogle it
15:00:48 <Philonous> seydar, (Reason being that ghc will tell you where the pattern match failed when the list turns out to be empty, but with head it will only say that head failed, and leaves you guessing which one)
15:00:50 <napping> seydar: a case missing [] will at least give you an exception mentioning the line number in your code if it turns out it can be empty after all, head always just gives you an error from inside head
15:01:11 <rwbarton> plus pattern-matching looks nicer anyways
15:01:15 <seydar> welp that turned up nothing. i'm out of ideas. i'm looking for a replacement for show so that i don't have to use String anywhere
15:01:25 <rwbarton> let (cmd : args) = split $ T.strip line
15:01:27 <seydar> i feel icky mixing String and Text in my code
15:01:41 <napping> hmm, couldn't unamb be rather more efficient as a primitive?
15:02:01 <Philonous> seydar, Show isn't for pretty-printing anyway. If you still want to use it just T.pack the resulting String.
15:02:04 <rwbarton> seydar: I would just use T.pack . show
15:03:43 <seydar> Philonous: what would you say show is for then?
15:03:57 <merijn> seydar: Debugging
15:04:00 <rwbarton> btw, this use of foldr is strange
15:04:14 <seydar> rwbarton: that's my next question: TIO.hPutStrLn handle . T.pack . show . foldr (\b a -> a + (read b :: Int)) 0 . T.unpack $ inp
15:04:29 <seydar> it has been hit by the whole fucking ugly tree
15:04:35 <seydar> it needs some TLC
15:04:38 <rwbarton> why not sum and map read
15:04:40 <seydar> it needs loving parents
15:04:53 <merijn> seydar: Refactor into smaller pieces until readable :p
15:05:15 <rwbarton> following the Say What You Mean principle
15:05:26 <seydar> that's a good method
15:05:47 <seydar> how bad is it to mix String and Text (and ByteString) in a single piece of code? is that a no-no?
15:06:02 <merijn> seydar: It depends what you're doing really
15:06:13 <seydar> like with that whole last line, it would be simpler to just leave out Text and have the whole thing in String, but i feel guilty for mixing types
15:06:17 <rwbarton> it's not beautiful
15:07:03 <rwbarton> but it beats looking up what other random package includes an Int -> Text function
15:07:09 <merijn> seydar: FYI, I frequently write code uglier than that in my initial "get it to work" attempt, the next step once it works is to define lots of local functions for every logical piece of the pipeline and replace the pipeline
15:07:26 <ion> “How bad is it to mix Rational and Integer (and Set) in a single piece of code?” This also depends on what you’re doing.
15:08:02 <seydar> ion you just derailed my life by using actual quotes in an irc chat
15:08:10 <napping> Is hGetLine in any sense a good producer?
15:08:21 * hackagebot verilog 0.0.4 - Verilog parser and DSL.  http://hackage.haskell.org/package/verilog-0.0.4 (TomHawkins)
15:08:50 <seydar> this is my final version and i'm happy with it, but i know deep down that i'm mixing types: hPutStrLn handle . show . sum . map (read . T.unpack) $ args
15:09:26 <napping> That's not very wrong, and String and Text are decent types to mix - both properly represent unicode
15:10:52 <napping> I think the main reason to use Text over String is just for performance (in space or time), and perhaps some fancier unicode libraries expect Text
15:11:06 <Cale> seydar: Text and ByteString work together. You use Text for the abstract representation of the text, and convert to/from ByteString when loading and saving things to file or transporting them over the network. Strings are fine for smaller bits of text, and can be convenient for certain operations, even if they're a bit wasteful.
15:11:45 <kazagistar> lists in general are good when you are using them as iterators rather then collections
15:11:50 <Cale> yeah
15:11:51 <napping> if you just use a string as an intermediate, it's not necessarily any slower
15:12:39 <napping> hGetLine is doing something like reading a buffer and then returning a tricky lazily evaluated thing that makes list nodes and Chars as you read thej
15:13:27 <napping> if you transform it without handing on to the start of the string, all that stuff will be garbage collected in the first generation and it shouldn't be terribly more expensive than peeking into the buffer yourself
15:13:53 <seydar> whew ok
15:13:59 <seydar> glad to hear i'm not the scum of the earth
15:14:32 <napping> Well, it's like function calls and stuff, so maybe an order of magnitude slower than explicit pointers or something, but negligible if you're doing anything nontrivial with the data like parsing it
15:15:11 <kazagistar> if you want fast code, don't ever actually store a list representation, but you can use them for intermediates to be fused away... {  X.fromList . transform1 param1 . transform2 param2 . Y.toList  }
15:16:07 <seydar> so this is what I have now: http://lpaste.net/105002
15:16:39 <seydar> i don't really like that I have a `split` function to check for an empty input line (really an empty input would be "\r"), and i'm looking for ways to get rid of it
15:16:56 <kazagistar> seydar: you should look into those hlint errrors ;)
15:18:00 <napping> String is what, 14x bigger than Text for big strings?
15:18:22 * hackagebot active 0.1.0.16 - Abstractions for animation  http://hackage.haskell.org/package/active-0.1.0.16 (BrentYorgey)
15:20:46 <seydar> kazagistar: oh yeah, that's making this look a lot nicer
15:21:02 <seydar> unfortunately it suggested hPrint which apparently my GHC cannot find...
15:21:04 <napping> or is it 28x bigger on a 64-bit system?
15:21:33 <kazagistar> @hoogle hPrint
15:21:35 <lambdabot> System.IO hPrint :: Show a => Handle -> a -> IO ()
15:21:35 <lambdabot> Text.Printf hPrintf :: HPrintfType r => Handle -> String -> r
15:21:35 <lambdabot> Text.Printf class HPrintfType t
15:22:19 <rwbarton> it's 5 words per character before the small-character optimization
15:22:25 <napping> anyway, I suspect memory space is often the first practical need to switch to Text (if you're doing something that actually needs to hold on to text)
15:22:31 <rwbarton> which would be 20x text on 64-bit
15:22:50 <napping> isn't it 7x with the threaded runtime? I thought there were two words of header
15:23:00 <napping> reusing small chars would help, yes
15:23:37 <rwbarton> does the threaded runtime use an extra header word?
15:23:55 <seydar> why would ghc be saying "Not in scope: `hPrint'"?
15:23:59 <rwbarton> I think only profiling does
15:24:05 <benzrf> heyj:
15:24:08 <benzrf> *hey
15:24:26 <napping> I'll check https://ghc.haskell.org/trac/ghc/wiki/Commentary/Rts/Storage/HeapObjects
15:24:32 <benzrf> if i have an AST from HSE, is there a way to pass every node in it meeting certain criteria through a function?
15:24:35 <napping> ah, looks like it is just for profiling
15:24:40 <benzrf> i dont want to manually pattern match x.x
15:24:45 <rwbarton> in fact it has to have the same heap layout since it uses the same Haskell object code
15:24:48 <benzrf> too many variants
15:24:49 <rwbarton> the threaded runtime
15:25:13 <napping> right. Somehow I was thinking an extra work was used for the blackhole marks and stuff
15:25:26 <napping> but you should be able to swap that right over the info table pointer
15:25:33 <rwbarton> right
15:26:00 <napping> okay, so it's a mere 12x larger for ASCII
15:27:31 <kazagistar> benzrf: best I can say is that in OOPland, people call that the "visitor pattern"
15:27:34 <rwbarton> with the caveat that the small character optimization only kicks in once the GC sees the String
15:28:12 <rwbarton> but that normally shouldn't matter so much
15:28:50 <seydar> you guys are awesome, thank you all so much
15:28:51 <napping> benzrf: looks like you have Data *and* Generic instances
15:29:24 <kazagistar> are these optimizations [Char] specific, or would other small types or lazy/boxed collections benefit too?
15:29:39 <napping> you can use things like syb
15:30:15 <napping> lens's plated, uniplate, etc
15:31:14 <rwbarton> kazagistar: Int has a similar thing IIRC
15:32:39 <benzrf> well, that's normally for Functor
15:32:47 <benzrf> napping: oh, how i use those?\
15:33:24 * hackagebot fast-math 1.0.1 - Non IEEE-754 compliant compile-time floating-point optimisations  http://hackage.haskell.org/package/fast-math-1.0.1 (MikeIzbicki)
15:34:16 <rwbarton> kazagistar: https://github.com/ghc/ghc/blob/master/rts/sm/Evac.c#L556
15:34:36 <napping> benzrf: for syb, look at Data.Generics.Schemes.everywhere
15:35:28 <benzrf> o:
15:35:31 <benzrf> i have uniplate
15:35:35 <benzrf> should i use that?
15:35:42 <napping> that works too
15:36:16 <kazagistar> rwbarton: I see, interestign, looks like a special case (from my very limited understanding of that code
15:36:43 <napping> with all those different types, maybe syb would be easier
15:37:24 <napping> or transformBi, I guess
15:38:15 <rwbarton> I wonder if it would be worth it to do the same optimization for S# (from Integer)
15:40:58 <geardev> hello again #haskell!
15:41:13 <geardev> I have one question, then I hope to just idle for awhile
15:41:58 <geardev> I'm wanting to import items from one module into another, here is my attempt: https://pastee.org/mwnwr
15:42:00 <ion> How many minutes approximately?
15:42:17 <ion> Module names must begin with a capital letter.
15:42:18 <geardev> ion: 30 minutes to an hour or until I fall asleep
15:42:36 <monochrom> filename B.hs, module name B. similarly for A.
15:43:00 <monochrom> err, actually you can keep "a.hs".
15:43:15 <geekosaur> geardev: expanding on that, module names must have initial uppercase
15:43:16 <geardev> it works
15:43:22 <geardev> thanks ion
15:43:42 <geekosaur> otherwise it can't tell whether you're using a module name or trying to compose function b with function foo
15:43:42 <geardev> thanks geekosaur
15:43:54 <geekosaur> (. is a bit overloaded.)
15:44:36 <hpc> :t (. is a bit overloaded)
15:44:37 <lambdabot>     Not in scope: ‘is’
15:44:37 <lambdabot>     Perhaps you meant one of these:
15:44:37 <lambdabot>       ‘id’ (imported from Data.Function),
15:45:13 <monochrom> I offer to help
15:45:37 <monochrom> (.) :: Composable a b c => a -> b -> c
15:46:03 <monochrom> instance Composable Module ID ID where ... :)
15:46:32 <ion> (.) :: Composition a => a
15:46:40 <yac> is there a fucntion like getDirectoryCOntents but without the ./ and ../ ?
15:47:10 <monochrom> I think no
15:47:51 <hpc> filter them out
15:48:06 <Iceland_jack> better yet, delete them
15:48:10 <hpc> :D
15:48:13 <Iceland_jack> that saves on traversal
15:48:14 <geekosaur> heheh
15:48:27 <monochrom> delete files containing type errors, too :)
15:48:28 * geekosaur hands Iceland_jack old HP/UX
15:48:40 <hpc> (usually you can filter out anything starting with a dot, and it handily lets you ignore hidden files too)
15:48:46 <monochrom> I used HP/UX
15:50:16 <geardev> okay, one more question :P (sorry!) http://www.yesodweb.com/book/persistent where is the [persistLowerCast | ... |] syntax coming from?
15:50:32 <moghedrin> This may seem like a silly question, but how (in this case) would delete save the traversal?
15:50:34 <monochrom> it is called "quasi quote"
15:50:49 <geardev> monochrom: that is directed at me?
15:50:54 <monochrom> yes
15:51:19 <Iceland_jack> geardev: from Template Haskell
15:51:34 <ion> moghedrin: If the . and .. links are deleted from the filesystem, they are not there to be traversed.
15:52:10 <benzrf> dang this generic manipulation jazz is cool as shit
15:52:15 <geekosaur> moghedrin, it was a joke
15:52:21 <albeit> Is it possible to import modules with a specific filepath? Like "import ../foo/Bar"?
15:52:22 <moghedrin> Ah XD
15:52:24 <moghedrin> I see.
15:52:35 <albeit> (Or even absolute instead of relative)
15:52:41 <monochrom> no
15:52:46 <geekosaur> some systems (like the old HP/UX I mentioned) didn't have visible . and .. entries but hid them in the directory metadata. most unixlikes require them to stitch the filesystem tree together
15:52:51 <vanila> was curious about this new abstract post-modern form of jazz for a sec
15:53:01 <ion> albeit: ghc -i../foo or hs-source-dirs in foo.cabal
15:54:32 <albeit> ion: Ah perfect thanks
15:59:17 <benzrf> @hoogle IO [String]
15:59:18 <lambdabot> System.Environment getArgs :: IO [String]
15:59:18 <lambdabot> System.Posix.Env getEnvironmentPrim :: IO [String]
15:59:18 <lambdabot> GHC.Environment getFullArgs :: IO [String]
15:59:23 <benzrf> thx lambdabot
15:59:37 <fread2282> how do I split a conduit into two (doubling the output)?
16:02:57 <albeit> If I'm dealing with just guaranteed ASCII data, is there a good reason to use Text over ByteString?
16:06:39 <Cale> albeit: Well, Text has a better set of operations for actually working on text.
16:07:23 <Savannah18>  Hi! I give you some videos. I hope you like! http://bit.ly/1n6865e
16:07:53 <sipa> @where ops
16:07:53 <lambdabot> arjanb bos byorgey Cale conal copumpkin dcoutts dibblego dmhouse dolio dons edwardk elliott geekosaur glguy Heffalump Igloo jmcarthur johnw kosmikus Lemmih monochrom nyc Philippa Pseudonym quicksilver roconnor Saizan shachaf shapr sjanssen ski sorear SyntaxPolice xerox
16:08:00 <albeit> So if I'm reading from a network, it would still make sense to read in the data as ByteString, convert so the final values I need are in Text, do operations on the text, then finally convert it back to ByteString to send across the network?
16:08:21 <geekosaur> no point in summoning ops, they got nuked already
16:08:23 <yac> how do I [[String]] -> [String] ?
16:08:33 <benzrf> yac: concat
16:08:33 <yac> so [[1], [2]] -> [1,2]
16:08:35 <benzrf> :t concat
16:08:35 <lambdabot> [[a]] -> [a]
16:08:45 <sipa> geekosaur: yeah, saw it too late
16:09:16 <benzrf> yac: or perhaps you want map concat
16:09:24 <benzrf> :t map concat
16:09:25 <lambdabot> [[[a]]] -> [[a]]
16:09:56 <yac> thanks
16:10:16 <sipa> :t concat . map concat
16:10:17 <lambdabot> [[[a]]] -> [a]
16:10:33 <sipa> :t sum . concat . map concat
16:10:34 <lambdabot> Num c => [[[c]]] -> c
16:11:16 <ion> @type getSum . (foldMap . foldMap) Sum
16:11:17 <lambdabot> (Foldable t1, Foldable t, Num c) => t (t1 c) -> c
16:11:28 <benzrf> hmmmm
16:12:08 <ion> @type sumOf (folded . folded)
16:12:09 <lambdabot> (Foldable f1, Foldable f, Num a) => f (f1 a) -> a
16:12:22 <benzrf> is there a version of transformBi where you can also view the original version of the thing you're mapping?
16:13:11 <sipa> :t transformBi
16:13:12 <lambdabot>     Not in scope: ‘transformBi’
16:13:12 <lambdabot>     Perhaps you meant one of these:
16:13:12 <lambdabot>       ‘transform’ (imported from Control.Lens),
16:13:36 <fread2282> :t foldMap
16:13:37 <lambdabot> (Monoid m, Foldable t) => (a -> m) -> t a -> m
16:14:31 <fread2282> > foldMap (fmap Sum) [Just 1,Nothing,Just 3]
16:14:33 <lambdabot>  Just (Sum {getSum = 4})
16:15:14 <fread2282> :t mapMaybe
16:15:15 <lambdabot> (a -> Maybe b) -> [a] -> [b]
16:21:36 <benzrf> ok
16:21:55 <benzrf> so transformBi takes a function from a to a and applies it to all a's in a b
16:21:57 <benzrf> given proper instances
16:22:22 <benzrf> however, when i convert a given a, i may be operating on a version of it that has already been changed because a sub-a of it has been
16:22:41 <benzrf> i want to be able to view both the altered version that i'm changing and the original before any changes were made to the overall b
16:30:22 <mietek> Has anyone had issues building the singletons package on OS X?
16:30:27 <mietek> Or in general.
16:30:47 <mietek> "Please report this as a GHC bug:  http://www.haskell.org/ghc/reportabug
16:30:48 <mietek> "
16:31:20 <mietek> http://pastie.org/private/ak9odyhrgfqueirha7quug
16:32:03 <mietek> Full GHC panic: http://pastie.org/private/ajde0fjuy8cq3xzdd8xd2g
16:33:08 * geekosaur wonders if that's one of the things driving 7.8.3
16:33:14 <geekosaur> which is in testing at the moment
16:33:14 <Gurkenglas> > fix (>>= return)
16:33:16 <lambdabot>  No instance for (GHC.Show.Show (m0 a0))
16:33:16 <lambdabot>    arising from a use of ‘M557648283222267668021325.show_M5576482832222676680...
16:33:16 <lambdabot>  The type variables ‘m0’, ‘a0’ are ambiguous
16:33:16 <lambdabot>  Note: there are several potential instances:
16:33:16 <lambdabot>    instance [safe] GHC.Show.Show a =>
16:35:49 <benzrf> h-help q.q
16:36:04 <osfameron> is there a readable paper on "the efficient hedge-union algorithm" used by Data.Map and friends?
16:36:18 <osfameron> most of the references to said algorithm seem to point at Data.Map's source...
16:38:35 <osfameron> ah, "Implementing Sets Efficiently in a Functional Language" which I can read via citeseer, hurrah
16:39:25 <switchy> good hunting, osfameron!
16:39:46 <benzrf> g-good hunting
16:44:14 <heatsink> I can define a class CstList c ts ~ map c ts, but it seems like type inference has a hard time inferring constraints.
16:45:53 <heatsink> This is for working with constrained HLists.
16:45:54 <heatsink> Am I going about it the wrong way?
16:46:27 <enthropy> heatsink: you want to say that all elements of a list belong to the same class?
16:46:34 <heatsink> yes
16:46:49 <enthropy> or apply a polymorphic function to all elements of a HList?
16:47:28 <heatsink> Sometimes I want to apply a constrained polymorphic function to all elements
16:47:58 <heatsink> or generate a new HList of a particular type from a constrained polymorphic value
16:48:32 <enthropy> you have a class like http://hackage.haskell.org/package/HList-0.3.4.1/docs/Data-HList-FakePrelude.html#t:ApplyAB ?
16:49:26 <enthropy> I think the best you can do is to manually write out the constraints
16:49:38 <enthropy> which means writing an instance, or something like the Fun in that module
16:50:17 <heatsink> No, I have functions like mapList :: CstList c ts => (forall a. c a => f a -> g a) -> TList f ts -> TList g ts
16:52:15 <benzrf> is there a way to get uniplate to work outward-in
16:52:15 <benzrf> p:
16:52:24 <benzrf> instead of inward-out
16:52:25 <heatsink> I don't understand what the second parameter of Fun means
16:53:30 <enthropy> it says how to calculate the result type from the argument type
16:54:59 <enthropy> data Fun (cxt :: k1) (getb :: k2) = Fun (forall a. FunCxt cxt a => a -> FunApp getb a)
16:55:22 <kini> so I'm trying to use haskell-interactive-mode to load files from a cabal project into a repl and play with things and infer types and fun things like that, but the repl that gets loaded complains that it can't find any of my imports
16:55:50 <kini> there is an "hs-sources-dirs" directive in the .cabal file for this project. That is, the root of the project is different from the root of the module system of the project (which is in src/)
16:55:55 <kini> could that be what's tripping haskell-interactive-mode up?
16:58:04 <heatsink> It's polykinded
16:58:29 <heatsink> I didn't know type families could match on kinds
16:59:40 <enthropy> well without that it's annyoing to write '[C] when C will do
17:07:15 <heatsink> I'm afraid this is too much for me to understand
17:18:41 --- mode: ChanServ set +o glguy
17:19:13 --- mode: glguy set -ob+b glguy *!~*18@67.221.255.* *!*@67.221.255.*
17:23:31 <chirpsalot> Hmmmm. So, toList has to guarantee that the list from all sets that are equal is the same on an implementation, right?
17:24:04 <oscarb92> Hello
17:24:23 <chirpsalot> Regardless of how the set is built up? Otherwise it seems weird from a purity standpoint?
17:24:43 <rwbarton> It wouldn't be weird from a purity standpoint, but it would be weird from a semantic standpoint.
17:25:11 <chirpsalot> rwbarton: well, if you're suggesting that sets built in different orders with the same type are different values...
17:25:23 <chirpsalot> Then I suppose it's not weird from a purity standpoint.
17:25:58 <chirpsalot> Which arguably makes sense, but it still seems strange because that's not the point of a set.
17:26:25 <oscarb92> I'm trying to modify this code https://gist.github.com/wvandyk/3638996
17:26:41 <oscarb92> It returns a single solution for a given sudoku
17:27:10 <chirpsalot> rwbarton: wait... I'm looking at the implementation now.... toAscList t = foldr (:) [] t
17:27:14 <chirpsalot> Uh...
17:27:16 <oscarb92> But I'd like it to return many solutions, it that's the case for a given sudoku.
17:27:39 <chirpsalot> rwbarton: so I guess it is weird like that?
17:28:10 <rwbarton> chirpsalot: it's only weird because of our expectations about how a "Set" module ought to behave. Purity only means the implementation has to be deterministic and non-side-effecting and so on
17:28:22 <oscarb92> I've tried many things, but I'm not an expeeienced functional programmer
17:28:33 <oscarb92> Experienced*
17:28:36 <rwbarton> chirpsalot: it's represented as a balanced binary search tree, and the foldr there folds over the tree in a fixed order
17:28:48 <rwbarton> in particular the tree is in-order
17:28:58 <rwbarton> (being a search tree)
17:30:05 <oscarb92> I'd appreciate any help.
17:31:01 <kazagistar> what regex library should I use? that wiki page is scary...
17:31:25 <chirpsalot> rwbarton: I guess, yeah. But given that two sets defined in different orders would produce different lists?
17:31:44 <chirpsalot> rwbarton: wait, maybe they don't: Instance of Eq is defined as  t1 == t2  = (size t1 == size t2) && (toAscList t1 == toAscList t2)
17:32:08 <rwbarton> to clarify, they don't
17:32:08 <marchelzo> sudoku puzzles can't have multiple solutions as far as i know
17:32:30 <chirpsalot> rwbarton: oh, I see what you mean >_<. The binary search tree is folded in order as expected.
17:32:56 <rwbarton> toList (insert x (singleton y)) will equal toList (insert y (singleton x))
17:33:25 <kazagistar> oscarb92: in that sort of case, I often start by changing the type signature to be what I want it on the outside, and work my way in as it makes sense
17:33:27 <chirpsalot> rwbarton: yay :). Thanks. I was panicking a little.
17:34:16 <rwbarton> but, if toList returned the elements in the wrong order, it still wouldn't be a purity issue. toList (insert x (singleton y)) and (insert y (singleton x)) are a priori two unrelated expressions
17:34:23 <oscarb92> kazagistar: could you elaborate please?
17:34:29 <kazagistar> oscarb92: in other words, if you want mulitple solutions, change the outermost type signature to many solutions instead of one, and then use the type errors to guide what you need to change
17:34:54 <chirpsalot> rwbarton: I see what you mean -- they would technically be different values?
17:35:00 <rwbarton> but, it would of course be unsatisfactory from a data abstraction standpoint
17:35:06 <hpc> marchelzo: they can, if they aren't very good puzzles ;)
17:35:23 <gamegoblin> Are there any source code tools that will take my code and add the most general type signatures to my functions?
17:35:25 <marchelzo> hpc: fair enough
17:35:48 <chirpsalot> rwbarton: but yeah, it would be weird because you would expect f a == f b anywhere where a == b is true.
17:35:58 <rwbarton> insert x (singleton y) and insert y (singleton x) are, strictly speaking, different values already
17:36:37 <rwbarton> they have different representations and if you have access to the constructors of Set then you can distinguish them
17:36:52 <rwbarton> however if you only use the public Data.Set API, then you can't
17:37:36 <rwbarton> (except splitRoot, and maybe other things)
17:37:46 <chirpsalot> rwbarton: of course, but since you're pretending the binary tree is an actual set it would be a little strange in my mind :).
17:39:33 <rwbarton> right, so generally we consider them the same
17:39:47 <oscarb92> kazagistar: ok. Thanks.
17:53:43 * hackagebot diagrams-haddock 0.2.2.9 - Preprocessor for embedding diagrams in Haddock documentation  http://hackage.haskell.org/package/diagrams-haddock-0.2.2.9 (BrentYorgey)
17:55:06 <hunt> hey guys can you help me pick which design pattern is stronger? (http://lpaste.net/105003) as far as i can tell the class choice is more organizationally useful but more of a pain to code, and more verbose in general, although its hard to deny that it seems better
17:56:50 <hunt> something maybe feels wrong about the top one? something to do with hardcoding the datatype state into a class, i dont really know. suggestions would be really appreciated though
17:57:49 <hunt> please!
17:58:06 <heatsink> Would a typical program use several commands together?
17:58:50 <benzrf> what's the best way to create a visual tree representation
17:59:06 <benzrf> i'm looking at Data.Graphviz and it looks unpleasantly low-level to create graphs
17:59:43 <rwbarton> hunt, this is the classic "expression problem"
17:59:46 <rwbarton> @where expression problem
17:59:46 <lambdabot> I know nothing about expression.
17:59:48 <rwbarton> hm
18:00:47 <hunt> damn
18:01:02 <hunt> should i just leave it as ive got it? ive implemented it with the second choice
18:01:36 <benzrf> hunt: yes probly
18:01:41 <heatsink> It depends whether you need to do anything besides run a command
18:01:46 <hunt> heatsink: yes it parses a list of commands and then operates all of them on the state
18:01:58 <hunt> heatsink: its fairly straightforward
18:02:07 <hunt> heatsink: nothing too complex about how any of this is used
18:02:38 <heatsink> There is no need for a class.  You can just have data Command = Command (StateT (RenderState m Double) IO ())
18:02:52 <hunt> benzrf: how do i decide what the better option is? i guess i should choose the first if ive got a loosely defined data set
18:03:06 <hunt> heatsink: each command operates differently on the state, and potentially carries arguments
18:03:24 <hunt> heatsink: i dont really understand how ur solution provides an option for that :/
18:03:46 <heatsink> cube ts tr tm = Command $ do ...
18:04:01 <heatsink> ^ put in the arguments at construction time
18:04:32 <hunt> heatsink: hm my current system has commands as only storing the data essential to be executed by the program, and having those modify state
18:04:44 <hunt> heatsink: seems a little confusing to nest the state inside the command
18:04:57 <heatsink> It's not doing that
18:05:02 <hunt> o
18:05:09 <benzrf> hunt: why not store commands as functions
18:05:12 <hunt> myb what is it?
18:05:15 <benzrf> must they be a data type?
18:05:44 <hunt> benzrf: i guess i could do that, although this is really modeled on a similar application i saw someone else write, which had a command data type
18:06:01 <hunt> benzrf: it seemed really expressive and usable
18:06:18 <hunt> benzrf: also i liked how unintegrated parsing and execution were
18:06:38 <heatsink> As rwbarton was saying, this is the expression problem.  If you represent a command as data, you can examine it easily but it's hard to extend.  If you represent it with a function, you can extend it easily but it's hard to examine.
18:07:26 <heatsink> In your case, it sounds like the only thing you do with a command after building it is executing it.  That's easier to do with a function.
18:08:19 <hunt> heatsink: i suppose... i think id rather keep my system though; i really prefer keeping execution and parsing as segregated as makes sense, and i think this makes sense
18:11:09 <kazagistar> hunt: cube :: Transform Double ->  Transform Double ->  Transform Double -> Command.... its not clear from that API that "command" is really a function wrapper
18:11:46 <hunt> kazagistar: command isnt a function wrapper though, in my implementation, i think
18:12:00 <dsturnbull> that code looks a little unclear, mixing Cube and File for example seems a bit odd imo
18:12:28 <hunt> dsturnbull: well these are commands that are in the actual syntax of what im parsing :/
18:12:31 <genericpersona> kazagistar: too many parameters :)
18:12:58 <hunt> kazagistar: comman is something the program can execute
18:13:10 <genericpersona> what does cube do? and what's Transform Double?
18:13:10 <dsturnbull> hunt, maybe you can have multiple parsers for each group, and that would help with the clarity issue? and since each would be smaller, the tradeoffs would be subtly different, too
18:13:36 <kazagistar> you can basically have 3 layers... a "state machine" (functionality), a set of commands that construct state machine actions  (semantics), and a parser that only uses the visible semantics (parsing)
18:13:57 <genericpersona> functional programmers always break things down so well
18:14:09 <hunt> genericpersona: it creates a cube with three transformations which are definitely unclear, and adds the cube to the state
18:14:20 <genericpersona> how long did it take you until you felt pretty comfortable with haskell?
18:14:31 <genericpersona> hunt: so it's like a cube monad?
18:14:49 <hunt> genericpersona: no its no monad at all, its just a data type with some arguments in it
18:14:54 <genericpersona> they transform the cube by scaling its sides?
18:15:03 <hunt> genericpersona: a different function can run any command and add it to the state
18:15:06 <genericpersona> oh; i only said monad b/c you mentioned state
18:15:16 <hunt> genericpersona: when its executed it is executed in the state monad
18:15:21 <hunt> genericpersona: sorry that was my bad
18:15:24 <genericpersona> gotcha
18:15:32 <hunt> genericpersona: also im pretty newb myself
18:15:39 <genericpersona> ah, nice
18:15:42 <genericpersona> we gotta start somewhere
18:15:50 <genericpersona> but haskell is exciting
18:15:52 <hunt> dsturnbull: i have a parser for each command, but theyre ungrouped
18:15:57 <hunt> genericpersona: agreed thats why im doing it
18:15:59 <genericpersona> are you using Parsec?
18:16:09 <hunt> genericpersona: yea i just switched to it
18:16:17 <genericpersona> which is one of the coolest libraries i've ever seen
18:16:21 <hunt> genericpersona: i was using my own parser before and that got kind of unintelligble
18:16:26 <hunt> genericpersona: agreed its so pretty
18:16:28 <genericpersona> yeah, it's not an easy task
18:16:32 <kazagistar> I still don't feel comfortable with some bits of haskell, but I did make an assembly VM as one of my first projects a while back
18:16:35 <genericpersona> but there are well researched solutions for doing it
18:16:41 <genericpersona> kazagistar: that's bad ass
18:16:46 <genericpersona> how long did that take?
18:16:50 <hunt> kazagistar: in haskell? wtf
18:17:10 <genericpersona> kazagistar: did you use a lot of external libraries, i.e., not defined in the Prelude?
18:17:29 <kazagistar> no, no no
18:17:33 <kazagistar> I misexplained
18:17:44 <genericpersona> oh, lol
18:17:48 <genericpersona> we both thought in haskell
18:17:52 <genericpersona> :)
18:18:24 <kazagistar> I was in a class writing a compiler for a shitty, minimal pascal that would run on a virtual machine
18:18:31 <kazagistar> which was provided
18:18:44 <hunt> kazagistar: oh cool, my thing is for a graphics class
18:18:53 <hunt> kazagistar: haskells a good school language
18:18:58 <kazagistar> but the provided VM had hardcoded memory limits
18:19:28 <kazagistar> so in my copious spare time, I wrote a VM for the same assembly language in haskell
18:19:55 <genericpersona> awesome
18:20:02 <kazagistar> it took a few weeks, didnt really work properly, and is not very nice code, but it was fun and I learned a lot
18:20:03 <acar> nice
18:21:14 <genericpersona> that's the important part
18:21:16 <genericpersona> good shit
18:21:25 <genericpersona> i just recently did huffamn encoding in haskell
18:21:42 <genericpersona> and then i saw someone's legit code for doing that and learned a lot that way
18:21:44 <benzrf> hmmmmmm
18:21:47 <genericpersona> but it's still super new to me
18:22:03 <genericpersona> i tried learning haskell a few years ago but gave up after a month or so
18:22:14 <genericpersona> it's making more sense this time, thankfully
18:22:25 <benzrf> is there a way to indicate the type of an argument function, keeping implicit args
18:22:39 <genericpersona> benzrf: what do you mean?
18:22:46 <stephenmac7> Any way to run a java executable from Haskell, besides executing "java"
18:22:46 <benzrf> nvm
18:22:48 <genericpersona> if you indicate the type you indicate all the args
18:23:03 <genericpersona> stephenmac7: maybe by calling an external program
18:23:08 <genericpersona> build a jvm in haskell
18:24:03 <dsturnbull> building a vm in haskell (or any language you're learning) is one of my preferred techniques to come to grips with a new language or platform
18:24:03 <stephenmac7> So, basically, I have to use a subprocess
18:24:32 <kazagistar> and I chose this for haskell learning cause it seemed like a "non-haskelly" thing (strictness, arrays, "machine level") so it was a good way to evaluate its weak points (or so I hoped)
18:24:37 <dsturnbull> stephenmac7: you could make the java program listen on a socket, or write to a fifo, or write to a file, or write to a socket
18:24:51 <dsturnbull> kazagistar: i'm curious if you put the code up anywhere
18:25:35 <stephenmac7> dsturnbull: Never built a VM, much less in haskell
18:25:44 <kazagistar> dsturnbull: I haven't, and I am not sure where I put it to be honest, but I am sure I could find it
18:25:53 <stephenmac7> I'm just getting aquainted with it
18:26:24 <dsturnbull> stephenmac7: well, System.Process has a pretty good API for doing it in the subprocess way
18:26:40 <stephenmac7> That's what I'm looking at. I think I'll do it that way.
18:26:46 <kazagistar> dsturnbull: and it is very broken  and I kinda would want to rewrite parts of it from scratch, unless your purpose really is learning how new haskellers mess up :P
18:27:27 <dsturnbull> stephenmac7: it's basically..  (_, Just outputHandler, _, _) = (shell "java -jar blah.jar") { std_out = CreatePipe }
18:27:48 <dsturnbull> kazagistar: :)
18:28:51 <kazagistar> dsturnbull: I mean, if that IS your interest, it is my, I would be more then happy to dedicate my messups to science :P
18:29:11 <dsturnbull> i'm curious. i don't have anything to share back yet
18:30:32 <dsturnbull> i'm slowly porting the VM+assembler i wrote in C
18:31:12 <dsturnbull> which shows some interesting differences between flex+bison and parsec
18:33:19 <stephenmac7> Why does lines exist but not some type of splitter?
18:33:41 <kazagistar> my biggest mistake was underuse of strictness, which made errors really hard to debug, because it would be unclear which command actually caused the potential future error
18:33:47 <benzrf> hey
18:33:49 <benzrf> in Data.Graph
18:33:57 <benzrf> is there a way to make a tree graph from a list of lists
18:34:02 <benzrf> or something similar
18:34:09 <benzrf> i dont want to manually number everything +.+
18:34:18 <stephenmac7> Meaning, wouldn't it be easier to create a function that splits anything and then just define lines as split '\n'
18:38:08 <kazagistar> stephenmac7: well, lines does work differently then words I guess
18:38:12 <dsturnbull> stephenmac7: http://hackage.haskell.org/package/base-4.7.0.0/docs/src/Data-List.html#lines
18:38:17 <stephenmac7> It does.
18:38:39 <stephenmac7> But it would be nice to not have to install the split package every time I want to use splitAt
18:38:53 <stephenmac7> Especially since the code for it is already in Prelude
18:38:55 <dsturnbull> i think actually the words definition is clearer
18:39:20 <kazagistar> words is non-reversable though
18:39:23 <dsturnbull> a -> b -> [a] is meant to be simple enough in the core language that a general function is probably not worth it.. i guess
18:40:01 <stephenmac7> > unwords $ words "this    test"
18:40:03 <lambdabot>  "this test"
18:40:17 <benzrf> h-help
18:40:18 <enthropy> there's the story in the preamble for http://hackage.haskell.org/package/split
18:41:10 <enthropy> probably it's based on actual proposals that were rejected
18:41:30 <dsturnbull> hahahaha that saga is great
18:41:37 <stephenmac7> Interesting story
18:41:53 <stephenmac7> But it still doesn't explain why we don't have such an essential function as splitAt
18:42:39 <kazagistar> stephenmac7: because they could not agree to which of a dozen or more implementations to use
18:43:02 <stephenmac7> splitAt ',' "some,string"
18:43:02 <rwbarton> @hoogle splitAt
18:43:03 <lambdabot> Prelude splitAt :: Int -> [a] -> ([a], [a])
18:43:04 <lambdabot> Data.List splitAt :: Int -> [a] -> ([a], [a])
18:43:04 <lambdabot> Data.ByteString splitAt :: Int -> ByteString -> (ByteString, ByteString)
18:43:08 <stephenmac7> Seems pretty simple to me
18:43:48 * hackagebot attoparsec-enumerator 0.3.3 - Pass input from an enumerator to an Attoparsec parser.  http://hackage.haskell.org/package/attoparsec-enumerator-0.3.3 (JohnMillikin)
18:44:46 * BMeph thinks that the 'split' saga should end with the Supreme Council disbanding, due to disagreeing on what problem they should tackle next... >;)
18:45:08 <kazagistar> Eq => [a] -> [a] -> [[a]]   or   Eq => [a] -> a -> [[a]]  (each with words or lines semantics possible) or (a -> Bool) -> [a] -> [[a]] or whatever else
18:45:21 <trap_exit> I have a silly question. I want to setup my haskell code as follows: every *.hs file has a section dedicated to quickcheck, dictating the assertions of the file. Then, whenever I save a file, I want all quickcheks to be autorun
18:45:37 <benzrf> trap_exit: lol
18:45:41 <trap_exit> how do I run a quickchekc from commandline rather than ghci ?
18:45:42 <benzrf> trap_exit: how fast is your computer
18:45:44 <trap_exit> benzrf: ??
18:45:55 <trap_exit> benzrf: I have a 4 x quad core = 16 core machine with 128 GB of RAM
18:46:05 <trap_exit> each core is Xeon ~ 2 Ghz
18:46:12 <stephenmac7> 128 GB?
18:46:14 <benzrf> trap_exit: .... really
18:46:22 <trap_exit> benzrf: yes, ebay refurbished r900
18:46:39 <trap_exit> anyway, how do I setup quickcheck to auto run like that?
18:46:49 <stephenmac7> Don't you think 128 GB is a bit ridiculous?
18:46:58 * xenocons cough
18:47:09 <trap_exit> stephenmac7: when purhasing refurbished severs on ebay, you don't choose how much RAm the machine has
18:47:13 <xenocons> i think you should donate some of that ram to our protein folding work
18:47:28 <stephenmac7> Eh. Whatever.
18:47:30 <trap_exit> xenocons: the machines are ~ 1K on ebay
18:47:34 <trap_exit> don't you have government grants ?
18:47:36 <xenocons> nice
18:47:39 <Welkin> why did you need a server?
18:47:59 <trap_exit> for example: http://www.ebay.com/itm/Dell-PowerEdge-R900-4x-2-40GHz-Quad-Core-E7340-128GB-RAM-2x-73GB-Perc-6i-DRAC-/380906327034?pt=COMP_EN_Servers&hash=item58afc94bfa
18:48:03 <stephenmac7> rwbarton: Seems I got the name wrong
18:48:06 <trap_exit> I don't need a server, I just like it as a dev machine
18:48:07 <Welkin> most people seem to develop on tiny laptops these days
18:48:23 <stephenmac7> Welkin: And others dev on 4k tvs
18:48:25 <trap_exit> yeah, and this is cheaper than a laptop too
18:48:32 <trap_exit> it's just slightly less portable
18:48:34 <coppro> wheee I should rewrite this code to use the writer monad
18:48:37 <stephenmac7> Or at least as their monitors
18:48:46 <kazagistar> dunno, I dev on big screens and tiny laptops
18:52:04 <trap_exit> so anyway
18:52:09 <trap_exit> how do I setup quickcheks to autorun?
18:52:16 <trap_exit> I already have inotify ==> autocompile on emacs save
18:52:27 <genericpersona> fractals are recursive!
18:52:30 <trap_exit> I just need to add in a command which files up all quickchecks
18:56:08 <enthropy> trap_exit: maybe doctest is appropriate
18:57:26 <solirc> enthropy, trap_exit: Doctest is slow
18:57:44 <enthropy> otherwise you can collect up all your properties with one of http://hackage.haskell.org/package/QuickCheck-2.7.5/docs/Test-QuickCheck-All.html
18:58:08 <solirc> I also see it as a way to test examples in documentation.
18:58:24 <solirc> (say test that documentation is correct, not that code is correct)
19:00:00 <solirc> if you are not afraid of using Ruby: http://rubygems.org/gems/guard-haskell
19:06:35 <benzrf> h-help
19:06:41 <benzrf> why does nobody help me ;-;
19:10:08 <solirc> benzrf: What is your issue?
19:11:26 <benzrf> i need to construct a Data.Graph tree but the built in graph building functions all seem entirely too low-level
19:11:42 <benzrf> this may be an xy problem
19:11:47 <benzrf> i want to visualize a tree i have
19:12:02 <moghedrin> What sort of function are you looking for, just out of curiosity.
19:13:05 <benzrf> something that lets me make a tree out of nested lists
19:13:06 <benzrf> or
19:13:12 <benzrf> something isomorphic to nested lists
19:13:14 <benzrf> ish
19:13:20 <benzrf> actually, rose tree
19:13:40 <benzrf> i have what is basically a labelled rose tree
19:13:43 <benzrf> want to render it :v
19:15:22 <glguy_> http://hackage.haskell.org/package/containers-0.5.5.1/docs/Data-Tree.html has some drawing functions
19:16:06 <benzrf> :O
19:16:51 <benzrf> hmm
19:17:51 <enthropy> http://hackage.haskell.org/package/graphviz is another option
19:18:38 <benzrf> enthropy: yeah, i looked at ThatOtherPerson
19:18:39 <enthropy> it should be pretty straightforward to traverse your rose tree adding the edges to a fgl graph
19:18:40 <benzrf> *that
19:18:45 <benzrf> fgl?
19:18:49 <benzrf> i looked at that
19:18:55 <benzrf> it makes you manually pick node numbers D:
19:18:59 <benzrf> sure it's straightforward
19:19:04 <benzrf> doesnt mean its not a pain
19:19:28 <enthropy> even using a state monad to ease the pain?
19:20:17 <glguy_> http://hackage.haskell.org/package/fgl-5.5.0.1/docs/Data-Graph-Inductive-NodeMap.html is for when you're using fgl and don't want to worry too much about node numbers
19:20:34 <glguy_> iirc
19:21:38 <benzrf> manual state monad bullshit is still bullshit
19:21:38 <benzrf> >:(
19:22:20 <benzrf> ughhh this all looks like a tremendous pain
19:22:28 <benzrf> is there a graphviz way to draw Data.Tree?
19:22:37 <benzrf> or something to convert Data.Tree to fgl?
19:24:29 <kazagistar> enumerating a list of lists does not seem THAT bad...
19:24:36 <benzrf> wweh
19:24:48 <benzrf> it just feels utterly pointless is all
19:27:45 <arnoblalam> @pl (\_ -> 1)
19:27:46 <lambdabot> const 1
19:28:24 <arnoblalam> @pl (\_ ->)
19:28:24 <lambdabot> (line 1, column 7):
19:28:24 <lambdabot> unexpected ")"
19:28:24 <lambdabot> expecting lambda abstraction or expression
19:29:24 <kazagistar> there is no such thing as a function that yields nothing, as it would be pointless and never execute
19:29:49 <arnoblalam> ah this makes sense
19:30:11 <arnoblalam> but for real numbers, I can think of a function that for all inputs returns a null set...
19:30:47 <arnoblalam> is there any equivalent in haskell? perhaps (\_ -> Nothing)
19:30:52 <benzrf> None
19:30:55 <benzrf> or ()
19:30:59 <kazagistar> arnoblalam: an empty set?
19:31:25 <arnoblalam> yes, empty set
19:31:35 <moghedrin> [] could also work.
19:31:41 <moghedrin> *shrugs*
19:31:42 <arnoblalam> @pl (\_ -> ())
19:31:42 <lambdabot> const ()
19:33:23 <fiatjaf> this ghc/cabal/haskell platform is killing me
19:33:29 <kazagistar> arnoblalam: the point is, haskell is lazy, and is evaluated as needed, so a function whose output is not consumed somewhere will never be evaluated
19:34:40 <fiatjaf> someone explain me, please, why I can run simple haskell scripts, use ghci and stuff, but then, when I try to compile "the haskell platform" they say I don't have 'Prelude'?
19:34:48 <benzrf> yaay, copypastable code :-D  http://stackoverflow.com/questions/13355968/elegant-way-to-convert-a-tree-to-a-functional-graph-library-tree
19:35:43 <fiatjaf> besides that, I'm having a lot of other problems trying to start a simple webapp here.
19:37:44 <matematikaadit> fiatjaf: what command do you use for compiling. what exact error message did you get. can you reproduce that error with a simplified code that you could paste in here.
19:37:49 <fiatjaf> for example
19:37:50 <fiatjaf> http://pastie.org/9252067
19:38:04 <fiatjaf> thank you, matematikaadit
19:39:02 <fiatjaf> after failing to compile ghc and the haskell platform from the downloaded sources, I installed ghc and haskell-platform from ubuntu repositories
19:39:21 <fiatjaf> but my cabal refuses to work
19:40:02 <fiatjaf> should I return and try to compile everything again and then ask for help? or am I in a situation from which you can help me out?
19:41:07 <matematikaadit> fiatjaf: it seems that you got a dependency problem there.
19:41:25 <SuperMind> you could use a sandbox
19:41:41 <fiatjaf> my cabal doesn't have the sandbox command
19:42:07 <SuperMind> well, you could get a new one with cabal update; cabal install cabal-install
19:42:16 <fiatjaf> I've installed a cabal-1.20 from a ppa I've found, and it had the sandbox command, but it didn't work
19:42:23 <fiatjaf> whoa
19:42:26 <fiatjaf> good idea
19:42:34 <fiatjaf> ok, one more thing
19:43:07 <fiatjaf> should I use cabal as root? or not?
19:43:15 <CindyLinz> fiatjaf: did you set the path like /home/fiatjaf/.cabal/bin into your PATH environment variable?
19:43:24 <CindyLinz> fiatjaf: non-root is ok..
19:43:25 <fiatjaf> no
19:43:30 <SuperMind> i use non-root
19:43:56 <fiatjaf> well, it fails so much
19:44:00 <CindyLinz> fiatjaf: The (non-root) installed executables will be put there..
19:44:06 <SuperMind> nonroot is probably best, because of dependency issues anyway.
19:44:14 <Kaidelong> so what are the semantics of duplicate for Env?
19:44:21 <fiatjaf> based on that screenshot I tried to --force-reinstalls
19:44:34 <SuperMind> did --force-reinstalls fix it?
19:44:40 <fiatjaf> no
19:44:45 <fiatjaf> lots of packages failed
19:44:49 <fiatjaf> with ExitFailure 1
19:45:06 <fiatjaf> ok, I'm updating cabal-install. it seems to be working.
19:45:18 <Kaidelong> is duplicate   m =>> ask =>> extract =>> extract   the same as   m =>> extract ?
19:45:21 <fiatjaf> Failed to install Cabal-1.20.0.1
19:45:24 <fiatjaf> not.
19:45:26 <fiatjaf> hum.
19:45:38 <Kaidelong> duplicate m *
19:45:53 <CindyLinz> fiatjaf: sometimes the failure is caused by lacking some C library, such as zlib-dev, etc
19:46:04 <Kaidelong> IE does duplicate set the environment to the returned value of the Env?
19:46:23 <SuperMind> fiatjaf, might help apt-get build-dep cabal
19:46:44 <arnoblalam> kazagistar: But you could feed the output of a function that outputs an empty set to another function that can accept an empty set and output a real value
19:46:47 <arnoblalam> ?
19:47:05 <fiatjaf> trying it.
19:48:19 <SuperMind> @hoogle duplicate
19:48:20 <lambdabot> GHC.IO.Handle hDuplicate :: Handle -> IO Handle
19:48:21 <lambdabot> GHC.IO.Handle hDuplicateTo :: Handle -> Handle -> IO ()
19:48:24 <kazagistar> arnoblalam: right, but an empty set is still something. It has a type. It is an instance of that type.
19:48:40 <kazagistar> arnoblalam: for that we use ()
19:49:04 <SuperMind> @hoogle (=>>)
19:49:05 <lambdabot> No results found
19:50:07 <kazagistar> > (\_ -> 1) . (\_ -> ()) $ 23.1
19:50:09 <lambdabot>  1
19:50:29 <kazagistar> :t (\_ -> 1) . (\_ -> ())
19:50:30 <lambdabot> Num c => a -> c
19:51:54 <kazagistar> arnoblalam: if you are interested in mathy things and how it connects to types, and what exactly () is, http://chris-taylor.github.io/blog/2013/02/10/the-algebra-of-algebraic-data-types/
19:52:36 <glguy_> Kaidelong: Prelude Debug.SimpleReflect Control.Comonad.Env> runEnv (env e a =>> extract)
19:52:36 <glguy_> (e,a)
19:52:36 <glguy_> Prelude Debug.SimpleReflect Control.Comonad.Env> runEnv (duplicate (env e a) =>> ask =>> extract =>> extract)
19:52:36 <glguy_> (e,e)
19:53:04 <arnoblalam> thank you, kazagistar, will check it out
19:58:38 <Kaidelong> sad...
19:59:01 <Kaidelong> I wonder what a good name for such a comonad might be. Undo?
19:59:34 <Kaidelong> but looks like Env is not it, then
20:00:48 <trap_exit> for installation on a machine without internet access, is there a way to download all of cabal ?
20:01:14 <rwbarton> all of hackage?
20:01:24 <rwbarton> I think it's pretty easy to set up a local hackage mirror yes
20:02:31 <Kaidelong> I'm pretty sure Undo wouldn't violate the comonad laws
20:02:43 <Kaidelong> it would only change the behavior of ask and asks
20:02:49 <Kaidelong> not fmap or extend
20:04:26 <Kaidelong> oh no I see the problem now
20:04:59 <Kaidelong> duplicate cannot be well typed for what I'm thinking
20:06:31 <fiatjaf> well, CindyLinz, SuperMind, matematikaadit, I keep getting problems: http://pastie.org/9252111
20:06:59 <fiatjaf> I made a sudo apt-get build-dep cabal-install, then I added ~/.cabal/bin to my PATH
20:07:24 <fiatjaf> and got this on the end of my cabal install cabal-install
20:08:10 <fiatjaf> I set made a chmod -R 777 ~/.cabal
20:08:16 <fiatjaf> but it gave me the same thing
20:08:33 <fiatjaf> is this common? people getting these errors I'm getting?
20:08:55 <enthropy> did you actually type ~/ when you set PATH?
20:10:29 <fiatjaf> enthropy: no
20:10:40 <fiatjaf> I typed the whole path
20:11:08 <fiatjaf> but `which cabal` still gives me /usr/bin/cabal, is this ok?
20:11:24 <benzrf> it's finally working \o/
20:11:29 <benzrf> check out my evil hack http://imgur.com/a/BGBtg
20:11:44 <SuperMind> do you have permissions to your /tmp folder heh?
20:12:02 <enthropy> fiatjaf: and $HOME/.cabal/bin comes before /usr/bin in $PATH?
20:12:58 <SuperMind> do you ahve permissions to ~/.ghc ?
20:13:35 <fiatjaf> me, SuperMind?
20:13:39 <SuperMind> yes you
20:13:58 <SuperMind> the error message sounds like a file system permissions  issue
20:14:03 <fiatjaf> my /tmp is drwxrwxrwt
20:14:20 <fiatjaf> ghc is drwxrwxr-x
20:15:09 <SuperMind> its trying to register the package, using ghc-pkg and then quitting with a permission issue
20:15:35 <fiatjaf> well, I set 777 to ~/.ghc
20:15:37 <SuperMind> it compiled fine, but it wasn't able to register the library with ghc
20:15:39 <fiatjaf> let's see now
20:16:06 <ion> find ~/.ghc ~/.cabal '!' -uid "$(id -u)"
20:16:27 <fiatjaf> yes, enthropy. I answered you, but the message didn't go
20:16:46 <ion> Also, never chmod anything to 777 in general.
20:17:27 <SuperMind> could use chown -R fiatjaf:fiatjaf ~/.ghc ~/.cabal
20:18:06 <fiatjaf> ok, thank you.
20:18:26 <fiatjaf> I got a list of paths from this command, ion
20:18:47 <fiatjaf> well
20:18:53 <fiatjaf> now it worked
20:18:55 <fiatjaf> after the 777
20:19:11 <fiatjaf> Installed cabal-install-1.20.0.2
20:19:18 <SuperMind> cool
20:19:20 <SuperMind> now you have sandbox
20:19:24 <fiatjaf> I don't get it
20:19:37 <fiatjaf> where was the error
20:19:38 <fiatjaf> ?
20:19:45 <fiatjaf> .ghc was already owned by fiatjaf
20:19:47 <SuperMind> provided .cabal/bin is in your path in front of /usr/bin
20:19:58 <SuperMind> -R means recursive
20:20:02 <fiatjaf> yes, it is.
20:20:20 <fiatjaf> ok.
20:20:21 <fiatjaf> now
20:20:22 <SuperMind> i think that folder under .ghc had the wrong user
20:20:35 <fiatjaf> if I want to start a webapp with snap, what should I do next?
20:20:40 <SuperMind> but if you already ran chown then we'll never know :)
20:20:52 <fiatjaf> I haven't :P
20:21:27 <fiatjaf> you are right. ~/.ghc/package.conf.d is owned by root
20:22:41 <fiatjaf> how do I use the sandbox?
20:23:34 <matematikaadit> fiatjaf: do "cabal sandbox init" in your project folder
20:23:41 <SuperMind> no
20:23:49 <SuperMind> he wants to install snap in a sandbox
20:23:55 <SuperMind> i mean
20:23:58 <SuperMind> compile it
20:24:42 <SuperMind> so he'll want a shared sandbox
20:24:47 <fiatjaf> hm
20:24:53 <SuperMind> mkdir sharedsandbox
20:25:01 <SuperMind> cd sharedsandbox
20:25:15 <SuperMind> cabal sandbox init --sandbox
20:25:20 <SuperMind> cabal sandbox init --sandbox .
20:25:25 <SuperMind> that . was missing, sorry
20:25:40 <SuperMind> see under advanced usage here: http://coldwa.st/e/blog/2013-08-20-Cabal-sandbox.html
20:26:31 <ion> fiatjaf: The command listed all the paths under ~/.ghc and ~/.cabal not owned by you.
20:27:42 <SuperMind> fiatjaf, the command ion showed you should not show any thing, all those paths should be owned by you.
20:28:15 <SuperMind> use chown -R to fix it
20:29:55 <SuperMind> in the shared sandbox, you'll be able to compile all the dependencies of snap and snap in one environment and not have to worry about breakage of packages installed in your general cabal environment.
20:30:35 <SuperMind> could call it snap-sandbox i suppose
20:32:33 <SuperMind> or if you prefer, you could just unregister every would be broken package, and delete their folders from ./cabal/packages/hackage.haskell.org. essentially uninstalling them.
20:33:14 <SuperMind> i don't think cabal has an uninstall, so you have to do  that manually.
20:34:03 <SuperMind> ghc-pkg list shows a list of registered packages
20:34:14 <SuperMind> and ghc-pkg unregister name, unregisters it
20:35:33 <Kaidelong> http://www.haskell.org/haskellwiki/Hask how is ~ being used here?
20:35:42 <fiatjaf> well
20:36:24 <fiatjaf> can't I do a sandbox for my app and compile everything inside it?
20:36:36 <fiatjaf> I think this too much information
20:36:48 <fiatjaf> thank you very much, by the way, SuperMind
20:37:33 <fiatjaf> I don't know yet if I should use snap, yesod, happstack, scotty or what else
20:40:17 <SuperMind> cabal's a mess, someone will fix it eventually
20:40:22 <SuperMind> hehe
20:40:53 <fiatjaf> hehe, good to hear
20:47:46 <kazagistar2> "someone"
20:48:48 <SuperMind> as in, not me :P
20:54:03 * hackagebot here 1.2.4 - Here docs & interpolated strings via quasiquotation  http://hackage.haskell.org/package/here-1.2.4 (TaylorHedberg)
20:55:57 <crazydave> I have a problem with newArray (for marshalling an array between Haskell and C):
20:56:32 <crazydave>   a' <- newArray $ map realToFrac a
20:57:01 <crazydave> the map realToFrac is to convert a from [Double] to [CDouble]
20:57:29 <crazydave> The problem is that whenever I do this the first element gets replaced by 0.0 (I do this for multiple arrays... all the same ... same problem everywhere)
20:58:05 <crazydave> what am I doing wrong (I'm looking at Foreign.Marshal.Array and can't see why it would insert a 0)
20:58:48 <ion> I don’t know what the problem is exactly, but as a side note, you should be able to replace “map realToFrac a” with “coerce a” on GHC 7.8.
21:00:15 <crazydave> hmmm time to upgrade? 7.6.2 I'm on.  coerce seems good and makes the code easier to read.  So I'll fix that. But I'd rather have it work than be pretty!
21:00:53 <ion> Perhaps the bug is somewhere else than the line you pasted?
21:01:44 <crazydave> hmmm I have 4 lines of that (for different arrays) and then I call the C function (and first thing in the C function I do is print out the inputs for debugging purposes ...)
21:04:14 <rwbarton> maybe you got the binding wrong somehow?
21:04:21 <rwbarton> can you paste the whole Haskell function and C function?
21:04:54 <crazydave> okay ... error is else where ... I just newArray and then peeked at it and it is correct
21:05:04 <dsturnbull> did anyone see that article from william yager on go vs rust vs haskell?
21:05:18 <dsturnbull> just trying to find out if anyone saw it in blog form yet
21:05:54 <t4nk660> hello
21:06:03 <t4nk660> haskell
21:06:11 <ion> yes, this is haskell
21:06:27 <t4nk660> first time on irc
21:07:02 <t4nk660> nice
21:07:13 <t4nk660> how long have u been programing in haskell
21:07:53 <crazydave> http://lpaste.net/105004 that's the code.  I just put the C header as a comment in the haskell code so you can see what I'm trying to call
21:09:04 * hackagebot unification-fd 0.9.0 - Simple generic unification algorithms.  http://hackage.haskell.org/package/unification-fd-0.9.0 (WrenThornton)
21:11:48 <rwbarton> crazydave: uh, you should probably run the C action BEFORE freeing all the arrays
21:12:14 <crazydave> doesn't it run first?
21:12:20 <rwbarton> nope
21:12:31 <rwbarton> it runs here: "lift <- res"
21:12:41 <rwbarton> let just creates a name
21:12:49 <rwbarton> in this case, the name "res" for the action of calling the C function
21:13:28 <rwbarton> oh wait
21:13:31 <crazydave> is there a way to not have to free at all? as in Haskell can know that I can't access those pointers anymore?
21:13:49 <rwbarton> I didn't notice you imported your function without ... -> IO CInt
21:14:10 <rwbarton> you can use withArray I think
21:14:12 <ion> crazydave: You might want to use withArray.
21:14:13 <rwbarton> @hoogle withArray
21:14:14 <lambdabot> Foreign.Marshal.Array withArray :: Storable a => [a] -> (Ptr a -> IO b) -> IO b
21:14:14 <lambdabot> Foreign.Marshal.Array withArray0 :: Storable a => a -> [a] -> (Ptr a -> IO b) -> IO b
21:14:14 <lambdabot> Foreign.Marshal.Array withArrayLen :: Storable a => [a] -> (Int -> Ptr a -> IO b) -> IO b
21:14:26 <crazydave> no that worked ... even though I used rc in the let clause it gets thunked
21:14:37 <crazydave> oh I changed from IO CInt to CInt when trying to debug it
21:15:03 <rwbarton> haskell can't know those pointers aren't going to be accessed afterwards, since you pass them to the C function
21:15:05 <crazydave> I think it should be IO CInt (it returns an array in one of its parameters ... so definitely)
21:15:08 <rwbarton> which might squirrel them away somewhere
21:15:13 <rwbarton> yes, it should be
21:15:56 <crazydave> ah yep ... okay that makes sense. But withArray will work? I wasn't sure since its type seems to be for one array to be passed to a function
21:16:31 <rwbarton> you can use it repeatedly
21:16:54 <rwbarton> withArray (convert (concat a)) $ \a -> withArray (convert b) $ \b -> ...
21:16:57 <rwbarton> erm
21:17:01 <rwbarton> choose better variable names than that
21:17:08 <rwbarton> withArray (convert (concat a)) $ \a' -> withArray (convert b) $ \b' -> ...
21:17:32 <crazydave> ahhh ... okay lambda functions to link them
21:17:45 <crazydave> I wanted to use withArray but couldn't work out how to do it
21:19:22 <rwbarton> the explicit frees will work too, though
21:19:28 <rwbarton> but withArray is better style
21:19:36 <rwbarton> :t allocaArray
21:19:37 <lambdabot> Not in scope: ‘allocaArray’
21:19:41 <rwbarton> @hoogle allocaArray
21:19:42 <lambdabot> Foreign.Marshal.Array allocaArray :: Storable a => Int -> (Ptr a -> IO b) -> IO b
21:19:42 <lambdabot> Foreign.Marshal.Array allocaArray0 :: Storable a => Int -> (Ptr a -> IO b) -> IO b
21:19:47 <rwbarton> you can use this one for x
21:20:00 <crazydave> yeah, but why would I keep track of something when Haskell will do it for me
21:20:16 <crazydave> oh! even better
21:20:24 <crazydave> thanks, this is going to be much better
21:20:33 <crazydave> *deletes his entire file and starts again*
21:23:31 <Beelsebob> so I'm kinda intregued… what's you guys' opinion of Swift?
21:24:23 <gamegoblin> Gulliver’s Travels was a compelling read
21:24:44 <gamegoblin> But A Modest Proposal fell a little flat on me
21:25:06 <gamegoblin> Beelsebob: ;)
21:25:12 <Beelsebob> haha
21:25:53 <gamegoblin> But really, I am not a huge obj-c fan, so more options for ios is always good
21:26:11 <Beelsebob> yeh, I can support that opinion
21:26:20 <ion> I guess it’s good there’s a global standard for financial communication.
21:26:56 <gamegoblin> I’ll be interested to see how the community evolves around it. For example, obj-c folks tend to love long naming schemes. We’ll see how that turns out for Swift.
21:27:58 <ion> beelsebob: https://twitter.com/mwotton/status/473602506052759552
21:28:29 <Beelsebob> ion: hahahahahahahahaha
21:28:32 <Beelsebob> +1
21:29:23 * glguy remembers why he doesn't use Twitter
21:29:45 <augur> Beelsebob!
21:29:54 <Beelsebob> augur: !
21:29:57 <augur> #haskell-blah too
21:30:05 <augur> i think you know my opinions of swift :X
21:30:26 <Beelsebob> true, should probably take it to -blah
21:30:43 <Beelsebob> in the mean time.. wow, it's grown in here
21:35:57 <fragamus> is there a haskell package for convex optimization
21:40:19 <fread2282> fread2282hirc: yo
21:41:18 <dsturnbull> poor bloody swift.
21:41:39 <dsturnbull> anyone sensing a pattern of supergiant web companies with terrible linguistic skills?
21:42:11 <yogurt_truck> dsturnbull: I'm happy about it!
21:42:32 <yogurt_truck> dsturnbull: https://twitter.com/lambdatoast/status/473661671144423425
21:42:53 * yogurt_truck always staying positive!
21:43:31 <augur> dsturnbull: no what why
21:43:37 <yogurt_truck> (s/positive/passive aggressive/)
21:44:58 <dsturnbull> heh
21:45:13 <dsturnbull> augur: google and apple are releasing shit language after shit language
21:45:42 <dsturnbull> all the other semi-majors are java shops, as far as i can tell
21:45:51 <augur> dsturnbull: ah yes. they either dont know what they're doing, or they dont want to frighten the OO wheenies
21:45:52 <dsturnbull> but they don't really invent new ones
21:46:09 <yogurt_truck> not all "big" companies are releasing awfulness, though
21:46:19 <augur> also this is a convo for -blah
21:46:24 <dsturnbull> what makes microsoft almost capable of releasing decent languages, and the other two giants not?
21:46:29 <dsturnbull> roger
21:46:59 <yogurt_truck> microsoft has some of its research people working on cool languages such as Koka
21:47:01 <yogurt_truck> augur: ok
21:47:30 <kazagistar2> wait, what is wrong with swift (more then C# or something)?
21:47:49 <augur> kazagistar2: take it to blah!
21:48:09 <kazagistar2> aye aye
22:09:11 * hackagebot re2 0.1 - Bindings to the re2 regular expression library  http://hackage.haskell.org/package/re2-0.1 (JohnMillikin)
22:16:38 <ColonelJ> hi I'm a bit stuck with what seems like a really conceptually simple problem but not sure what the correct solution is
22:17:29 <ColonelJ> I have this dictionary, where the values stored in the dictionary take the dictionary as an argument, so that they can all access the dictionary if they need
22:17:57 <ColonelJ> problem here is (perhaps obviously) this gives you an infinite type since the type of the dictionary occurs in the dictionary values
22:19:24 <opqdonut> ColonelJ: you need to declare a type
22:19:44 <opqdonut> e.g. data MyMap = MyMap (Map String (MyMap -> Int))
22:20:23 <ColonelJ> that's kinda what I was thinking but thought it would be good to check, thanks
22:20:41 <ColonelJ> I'm actually not coding in haskell but a related language
22:20:48 <trap_exit> I have a bunch of *.hs files. How do I (1) define quickcheck tests in each file and (2) have "exec-all-quick-check" execute all quick checks ?
22:30:19 <ticktockman> Is this a bug? http://lpaste.net/105005
22:30:34 <rwbarton> yes
22:31:18 <rwbarton> can you provide a complete reproducer? it looks rather simpler than the current reproducer for this bug
22:32:02 <rwbarton> https://ghc.haskell.org/trac/ghc/ticket/9128
22:33:28 <rwbarton> now that I look more closely maybe it's not exactly the same bug
22:36:43 <gamegoblin> is there a cleaner way to write “case f x of [] -> b; y -> y”
22:39:59 <oscarb92> hello
22:40:24 <gamegoblin> Hola oscar
22:40:30 <oscarb92> Hola
22:40:33 <oscarb92> espaol?
22:40:55 <NemesisD> whats the more idiomatic way to indicate failure or everything being okay, Either e () or Maybe e
22:41:00 <gamegoblin> Yo puedo hablarlo, pero yo creo que este IRC prefiere ingles
22:41:14 <oscarb92> gamegoblin: it's ok
22:42:14 <ReinH> NemesisD: Er, Either is usually used as Either error a and Maybe as Maybe a
22:42:33 <ion> nemesisd: How about data Something a = Ok | Error a?
22:43:04 <gamegoblin> ion: That looks suspciously like a renamed Maybe
22:43:06 <carter> or Result a = Eww SomeException | Answer a
22:43:18 <ion> gamegoblin: Gee, really?
22:43:21 <oscarb92> I'm new at haskell programming and I'm trying recursive backtracking to solve sudoku grids. But I can't find a way for my code to return multiple solutions if they exist
22:43:32 <NemesisD> so maybe is not idiomatic when Just indicates the failure mode?
22:43:39 <gamegoblin> oscarb92: Do you have your code anywhere we can see it?
22:44:00 <ReinH> oscarb92: this is by far my favorite sudoku solution http://www.cs.dartmouth.edu/~cs8/F2009/examples/Sudoku.lhs
22:44:12 <ReinH> by Richard Bird, who is good at teaching functional algorithm design
22:44:59 <ReinH> NemesisD: Ah. Maybe http://hackage.haskell.org/package/errors-1.4.7/docs/Data-EitherR.html#t:EitherR
22:45:27 <oscarb92> Actually I'm trying to modify this code to have multiple solutions: https://gist.github.com/wvandyk/3638996
22:46:54 <oscarb92> I can't find a way to tell the solve function to continue solving after showing the first result
22:48:37 <oscarb92> I like that code because it won't require any other modules or using monads and that kind of stuff I still haven't figured out
22:49:27 <ReinH> neither does Bird's, except for an import of Data.List
22:51:07 <kazagistar2> so I assume my type changing strategy didnt work, oscarb92?
22:53:54 <oscarb92> hey kazagistar2, I think I didn't get it quite well. I mean, I change the return type, but I'm still have to find out how to make the function show multiple results
22:59:55 <kazagistar2> oscarb92: in any case, that code is not that great I think... it does not declare types for clarity, so it is unclear if something is a sudoku board or a different type of "int list"
23:00:13 <elixirz> Hiii
23:00:48 <elixirz> can anyone.see my typi
23:00:53 <elixirz> Hey bjz
23:01:07 <elixirz> Can u see my typing? :p
23:01:48 <oscarb92> kazagistar2, I know, but as I said, it's simple enough for me to undestand it.
23:01:57 <elixirz> Can anyone see my words?
23:02:15 <oscarb92> yes elixirz
23:02:34 <elixirz> Its quiet for so many people in here
23:02:56 <oscarb92> Yup
23:03:17 <elixirz> Jme and u active?ust
23:03:32 <elixirz> Woops. Just me and you active?
23:03:36 <matthias_goergen> What's the recommended automatic differentiation package?  ad?
23:04:17 * hackagebot hothasktags 0.3.2 - Generates ctags for Haskell, incorporating import lists and qualified imports  http://hackage.haskell.org/package/hothasktags-0.3.2 (LukePalmer)
23:07:21 <jaj> Hi, I want to interface a C function which takes a void pointer argument which is supposed to contain binary data. The C function is pure. I want to feed it a ByteString. How should I proceed?
23:07:42 <jaj> Can I convert ByteString to Ptr ()?
23:08:22 <mietek> Does anyone know how to pass an option to c2hs through an invocation of cabal repl?
23:08:47 <semigroup> I'm trying to figure out how to get the following equality constraint to typecheck properly, but I'm not sure what I'm doing wrong: intKey :: (Key entity ~ Int) => Entity entity -> Int.
23:08:56 <mietek> The obvious `cabal repl --c2hs-option=-k` fails with an odd error message
23:09:05 <mietek> There must be exactly one binding file (suffix .chs),
23:09:05 <mietek> and optionally one or more header files (suffix .h).
23:09:05 <mietek> Try the option `--help' on its own for more information.
23:09:14 <kazagistar2> jaj: http://stackoverflow.com/questions/17366776/passing-void-through-haskell ?
23:10:26 <semigroup> But I'm getting "inaccessible code in
23:10:27 <semigroup>       the type signature for
23:10:27 <semigroup>         intKey :: (Key entity ~ Int) => Intity entity -> Int
23:10:28 <semigroup> "
23:10:52 <semigroup> Anyone know how to accomplish something along these lines?
23:12:17 <rwbarton> jaj: you can use Data.ByteString.Internal.toForeignPtr and then withForeignPtr
23:14:03 <rwbarton> jaj: and I guess you can sensibly unsafePerformIO the whole thing
23:14:22 <rwbarton> if the C function is really pure
23:15:02 <jaj> rwbarton: thanks, that's what I was looking for! The C function is pure, it just calculates a checksum of the data and returns it
23:15:12 <rwbarton> right, OK
23:17:55 <rwbarton> semigroup: maybe you are seeing bug https://ghc.haskell.org/trac/ghc/ticket/7293 (wrong error location reported for inaccessible code)?
23:19:42 <semigroup> rwbarton, not sure how to determine whether that's the case for me or whether it's legitimate
23:20:03 <rwbarton> well I don't think "Inaccessible code in the type signature for ..." can make any sense
23:20:09 <rwbarton> there is no code in a type signature
23:20:51 <rwbarton> so probably you actually have an inaccessible case
23:21:12 <semigroup> import Database.Persist
23:21:13 <semigroup> key :: (Key entity ~ Int) => Key entity -> Int
23:21:13 <semigroup> key = entityKey
23:21:23 <semigroup> That's enough to trigger the issue for me
23:21:29 <rwbarton> uh, hmm
23:21:33 <rwbarton> what's the type of entityKey?
23:22:24 <semigroup> Err, sorry the above should have been:
23:22:29 <semigroup> key :: (Key entity ~ Int) => Entity entity -> Int
23:22:29 <semigroup> key = entityKey
23:22:32 <rwbarton> right
23:22:46 <semigroup> and entityKey :: Entity entity -> Key entity
23:22:50 <semigroup> Same issue though
23:26:07 <rwbarton> semigroup: oh
23:26:15 <rwbarton> type Key record = KeyBackend (PersistEntityBackend record) record
23:26:24 <rwbarton> newtype KeyBackend backend entity ...
23:26:32 <rwbarton> so Key entity can never be ~ Int
23:26:36 <semigroup> Ahhh
23:27:23 <semigroup> that'll do it
23:27:44 <semigroup> Thanks, I assumed Key was a type family
23:30:26 <Maxdamantus> Hmm .. just wondering, are there any experimentations with TH or something to enable something like: `foo (bar, baz?, qux)?` → `do{ baz' <- baz; tup' <- (bar, baz', qux); return (foo tup') }`?
23:30:30 <StoneCypher4k> how would you explain a costructure to someone with zero haskell background
23:31:29 <Maxdamantus> It wouldn't really work too well with curried functions.
23:36:00 <Maxdamantus> er, that transformation was wrong.
23:37:15 <Maxdamantus> do{ tup' <- do{ baz' <- baz; return (bar, baz', qux) }; return (foo tup') }
23:38:01 <lfairy> anyone know how to generate a build summary in cabal?
23:38:23 <enthropy> @hackage applicative-quoters
23:38:23 <lambdabot> http://hackage.haskell.org/package/applicative-quoters
23:39:21 * hackagebot beamable 0.1.1.1 - Generic serializer/deserializer with compact representation  http://hackage.haskell.org/package/beamable-0.1.1.1 (JohnLato)
23:40:22 <lfairy> ah, just found https://github.com/haskell/cabal/issues/1189
23:41:56 <enthropy> Maxdamantus: it's kind of like the `i` quasiquote in that package. I'm not so sure what the second ? means in `foo (bar, baz?, qux)?`
23:42:54 <Maxdamantus> The ? is there because `(bar, baz?, qux)` should be some `Monad m => m (_, _, _)`
23:43:46 <Maxdamantus> So it always relates to the operator it's directly under (the first one is under a tuple constructor, the second is under an application)
23:49:22 * hackagebot statistics 0.11.0.2 - A library of statistical types, data, and functions  http://hackage.haskell.org/package/statistics-0.11.0.2 (BryanOSullivan)
23:51:47 <Maxdamantus> Mm .. I see how QQ.Idiom relates to it.
23:52:05 <Maxdamantus> that one looks like it handles curried functions specifically.
23:53:22 <Maxdamantus> [i| subtract [1,2,3] [10,20,30] |] .. with the question mark system above, that'd be: (subtract [1, 2, 3]?)? [10, 20, 30]?
23:54:24 <Maxdamantus> 1. do{ a' <- [1, 2, 3]; return (subtract a') }? [10, 20, 30]?
23:54:47 <Maxdamantus> 2. do{ b' <- do{ a' <- [1, 2, 3]; return (subtract a') }; c <- [10, 20, 30]; return (b' c) }
23:56:24 <Maxdamantus> (Forgot to put ' on c, for consistency, not meant to indicate it's different somehow)
23:58:42 <Maxdamantus> This syntax is actually basically directly from Swift .. but in Swift it's strictly for "optional chaining" .. and I can't see in the documentation whether it works for anything other than field accesses and method calls (where the ? is on the receiver)
23:59:23 * hackagebot statistics 0.11.0.3 - A library of statistical types, data, and functions  http://hackage.haskell.org/package/statistics-0.11.0.3 (BryanOSullivan)
