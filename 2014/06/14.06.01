00:00:07 <bitemyapp> Ralith: yeah the humor was the real draw for me.
00:00:17 <bitemyapp> just a delightful read.
00:00:20 <Freeman42x> augur, is this http://i.imgur.com/HAqJBFv.png considered a paper? if not, maybe you should clarify to us what you are looking for
00:03:02 <augur> i want some good PLT things to read
00:03:14 <hunt> how do i do instance Show [my data type]?
00:03:17 <augur> or maybe theres are some new videos to watch??
00:03:25 <hunt> its giving me errors for saying instance Show [ADT] where
00:03:36 <augur> hunt: just define Show ADT
00:03:52 <augur> haskell has an instance     instance Show a => Show [a]
00:04:03 <hunt> theres no way to overload it for [] of my data type?
00:04:10 <augur> hunt: no
00:04:16 <hunt> dang
00:04:18 <augur> you can define your own special function tho
00:04:24 <hunt> oh hey
00:04:25 <hunt> sure
00:04:28 <augur> specialShow :: [ADT] -> Strong
00:04:30 <augur> String*
00:04:40 <hunt> although it wont auto run it in ghci
00:04:45 <hunt> so theres not much point
00:04:49 <augur> thats correct
00:05:00 <augur> no reason you cant call it yourself tho
00:05:05 <pqmodn_> newtype MyADT = MyADT [ADT]
00:05:07 <bitemyapp> hunt: hold up
00:05:10 <jle`> there is still a point...
00:05:13 <pqmodn_> then create your own Show MyADT
00:05:13 <bitemyapp> hunt: why can't you just show the list?
00:05:24 <augur> mm yes pqmodn_ has an idea
00:05:27 <bitemyapp> hunt: showing a list invokes the show instance of the things inside the list.
00:05:28 <hunt> this isnt serving a fcuntion
00:05:36 <hunt> im just trying to make the presentation neater
00:05:42 <hunt> so i can compare my results more easily
00:05:53 <hunt> im really just trying to add newlines after each element in the list
00:05:55 <jle`> you can make a presentation neater by using your custom show :)
00:06:00 <jle`> custom show method
00:06:03 <jle`> hm
00:06:04 <hunt> yea
00:06:05 <jle`> hey, what about showList
00:06:15 <hunt> but itd be maximally sleak if it ran in ghci naturaklly
00:06:54 <jle`> try looking into showList
00:06:55 <pqmodn_> you can use OverlappingInstances or something, but nobody advises that.
00:07:24 <jle`> but this is in general not recommended because it is recommended semantically that show be the inverse of read
00:07:37 <jle`> that it's like...some sort of haskell literal you could literally type into source code
00:07:45 <jle`> so this is sort of inherently hacky
00:08:02 <hunt> i just wanted to marvel at the beauty of my code :'(
00:08:08 <jle`> unless your showList instance can be read as [ADT]
00:08:16 <hunt> it dm anymore
00:08:18 <hunt> i give up
00:08:25 <hunt> goodnight haskell
00:08:43 <pqmodn_> hunt: http://book.realworldhaskell.org/read/using-typeclasses.html#id608550
00:08:45 <jle`> yeah, showList might be what you want.
00:08:46 * hackagebot Shellac-compatline 0.9.5.2 - "compatline" backend module for Shellac  http://hackage.haskell.org/package/Shellac-compatline-0.9.5.2 (RobertDockins)
00:08:46 * hackagebot LambdaShell 0.9.3 - Simple shell for evaluating lambda expressions  http://hackage.haskell.org/package/LambdaShell-0.9.3 (RobertDockins)
00:09:11 <jle`> it's a part of the Show typeclass and is used to specially print things in lists, like printing [Char] as a string
00:10:03 <jle`> http://hackage.haskell.org/package/base-4.7.0.0/docs/src/GHC-Show.html#showList
00:10:22 <jle`> there was a time when i thought that the Show instance of [Char] was a compiler-level hack
00:15:21 <jle`> but today is not that day
00:37:38 <sshine> I'm looking for something like '(a -> b) -> (Maybe a, Maybe a, Maybe a) -> Maybe (b, b, b)'
00:38:43 <sshine> \f (x,y,z) -> x >>= \x -> y >>= \y -> z >>= \z -> return $ f (x,y,z)
00:39:00 <sshine> but perhaps with fewer explicit binds :)
00:39:43 <Iceland_jack> your example doesn't match the given type does it
00:39:55 <Iceland_jack> It should be
00:39:55 <Iceland_jack>     return (f x, f y, f z)
00:39:55 <Iceland_jack> ?
00:40:07 <sshine> ah, right
00:40:31 <Iceland_jack> In any case you might be better off using lists, this is a very strange type because of the tuple
00:40:58 <Iceland_jack> @ty mapM :: (a -> Maybe b) -> [a] -> Maybe [b]
00:40:59 <lambdabot> (a -> Maybe b) -> [a] -> Maybe [b]
00:42:02 <shachaf> sshine: It seems to me that it makes sense as two functions: (a -> b) -> (Maybe a, Maybe a, Maybe a) -> (Maybe b, Maybe b, Maybe b), and (Maybe a, Maybe a, Maybe a) -> Maybe (a,a,a)
00:42:36 <Iceland_jack> map and sequence basically
00:42:44 <sshine> if I used lists
00:42:45 <Iceland_jack> I don't think it makes much sense with tuples anyway
00:43:24 <sshine> great, thanks. I'll do that.
00:43:43 <shachaf> There's probably a good way to do it with lens.
00:43:48 <shachaf> each._Just or so.
00:46:23 <shachaf> "use lists" is a bad idea if you already have tuples.
00:46:56 <shachaf> Well. Maybe not a bad idea, but suspicious.
00:47:00 <sshine> well, I like tuples because I've always got exactly three values.
00:47:33 <shachaf> Right. So ideally you don't want to lose type safety.
00:47:45 <shachaf> It may be more or less important to you depending on context.
00:47:47 <shachaf> :t sequenceOf each :: (Maybe a,Maybe a,Maybe a) -> Maybe (a,a,a)
00:47:48 <lambdabot> (Maybe a, Maybe a, Maybe a) -> Maybe (a, a, a)
00:48:20 <Iceland_jack> If type safety is really the reason you picked tuples and they're always going to be homogeneous, make a data type
00:48:36 <sshine> :t sequenceOf
00:48:37 <lambdabot> LensLike (WrappedMonad m) s t (m b) b -> s -> m t
00:48:52 <shachaf> :t over (each._ ("That's exactly the method," the Bellman bold
00:48:52 <shachaf> In a hasty parenthesis cried,
00:48:52 <shachaf> "That's exactly the way I have always been told
00:48:53 <lambdabot>     parse error (possibly incorrect indentation or mismatched brackets)
00:49:00 <shachaf> Er.
00:49:42 <sshine> that must be a new Haskell extension. :-P
00:49:43 <shachaf> :t over (each._Just) :: (a -> b) -> (Maybe a,Maybe a,Maybe a) -> (Maybe b,Maybe b,Maybe b)
00:49:44 <lambdabot> (a -> b) -> (Maybe a, Maybe a, Maybe a) -> (Maybe b, Maybe b, Maybe b)
00:53:44 <Kazagistar> now without the type annotations... for fun
00:53:57 <Kazagistar> :t sequenceOf each
00:53:58 <lambdabot> (Each s t (m b) b, Monad m) => s -> m t
00:54:08 <sshine> now that makes sense!
00:54:11 <Kazagistar> .... that was the most readable lens I have ever read
00:54:33 <Kazagistar> or shortest, at least
00:54:36 <shachaf> :t sequenceAOf each -- yay, Applicative
00:54:37 <lambdabot> (Each s t (f b) b, Applicative f) => s -> f t
00:57:28 <Kazagistar> :t (sequenceOf each .) . fmap
00:57:29 <lambdabot> (Each (f b1) t (m b) b, Functor f, Monad m) => (a -> b1) -> f a -> m t
00:57:55 <Kazagistar> hmm, not quite
01:09:21 <statusfailed> Weird, why is "cabal install semigroups" compiling Text when semigroups only depends on "base" and "nats"
01:11:05 <Kazagistar> statusfailed: mine claims a lot more deps then that...
01:11:31 <statusfailed> Kazagistar: I'm reading hackage: http://hackage.haskell.org/package/semigroups
01:11:33 <exicer> With the following, is there any way to not have to cast Nothing as Maybe String ?
01:11:39 <exicer> http://lpaste.net/104932
01:11:54 <statusfailed> Kazagistar: I'm getting more than just Text though
01:14:45 <statusfailed> exicer: without having compiled it, I guess there's nowhere else the type information can come from, right?
01:14:53 <Kazagistar> statusfailed: yeah, I dunno, but I can confirm the same thing
01:15:24 <statusfailed> Kazagistar: Weird! oh well haha :)
01:15:24 <exicer> statusfailed: Yeah. I guess the case is that I always know it is Nothing, so it seems inelegant to have to cast it as something..
01:15:47 <statusfailed> exicer: well a string-nothing is different to an Int-nothing
01:16:07 <exicer> I suspected as much.. just wondered if there were a way around it
01:16:14 <statusfailed> exicer: consider if you want to provide a default value for a maybe type
01:16:47 <exicer> statusfailed: What do you mean ?
01:17:22 <statusfailed> exicer: if you have (Nothing :: Maybe String), you can write (default :: Maybe String -> String) right?
01:17:43 <statusfailed> default might give you "" for strings
01:17:48 <statusfailed> 0 for ints, etc.
01:18:05 <statusfailed> but if "Nothing" didn't have any type information with it, then you couldn't write that
01:18:24 <exicer> statusfailed: Yeah true. In the case of Aeson it is always Null though
01:18:49 <exicer> er the Nothing value I mean
01:18:54 <exicer> I see your point though!
01:22:00 <statusfailed> exicer: I think you might be able to explicitly encode a Null with aeson if that's your goal
01:22:17 <statusfailed> exicer: you can construct a "Value" using "Null", and then encode it
01:23:10 <statusfailed> exicer: toJSON $ object [ "msg" .= Null ]
01:25:28 <exicer> statusfailed: Hmm, I suppose instead of ToJSON a => Maybe a I could just explicitly put a Value..
01:25:52 <exicer> Seems wrong somehow, though
01:26:11 <statusfailed> exicer: depends what you're doing- I think your way is probably best if you might want to pass a string there eventually
01:27:11 <exicer> statusfailed: Yeah, about half the time I would want to pass something in. I suppose I could explicitly make two functions, but that also seems wrong :p
01:27:28 <SonOfLilit> Hi, I'm looking for the source archive of haskell platform 2010.2
01:27:38 <SonOfLilit> Does anyone know where to find it?
01:27:53 <SonOfLilit> (the official site has a broken link)
01:30:45 <SonOfLilit> For the logs: It's at http://distfiles.pld-linux.org/distfiles/by-md5/9/d/9d1dd22a86bf2505591e6375f7dbe18e/haskell-platform-2010.2.0.0.tar.gz
01:35:30 <jle`> is there some sort of built in (String -> String) -> (Text -> Text)
01:35:39 <jle`> i mean it's just pack . f . unpack
01:35:55 <jle`> but i feel like the idiom is common enough that this would be useful as its own thing
01:36:25 <jle`> and also there might be a more performant implementation than just pack . f . unpack, at the low level
01:37:35 <xpikab> trying to install ghcjs. getting error: unrecognized 'install' option `--ghcjs-option=-XMagicHash'
01:38:08 <yitz> jle`: how could it be more performant without knowing more about f?
01:39:30 <jle`> yitz: ah yeah. i didn't think that through
01:47:44 <nawal> hey guys
01:47:48 <nawal> I'm a Haskell noob
01:47:59 <nawal> I managed to load a string from a file
01:47:59 <nawal> str <- readFile infname
01:48:05 <nawal> it has several lines of text
01:48:15 <nawal> I managed to split it into a list and print that
01:48:18 <nawal> putStr $ show (lines str)++"\n"
01:48:31 <nawal> I have a function parse :: [String] -> [Int]
01:48:50 <nawal> When I try to map that over the list of strings, I get an error
01:48:54 <nawal> let x = map parse (lines str)
01:49:05 <nawal> Couldn't match type `Char' with `[Char]'
01:49:08 <wto> > :t map
01:49:10 <lambdabot>  <hint>:1:1: parse error on input ‘:’
01:49:17 <wto> :t map
01:49:18 <lambdabot> (a -> b) -> [a] -> [b]
01:49:28 <nawal> ah good point :P
01:49:33 <wto> nawal: you see that the function you give to map should not operate on the list
01:49:37 <wto> but rather on the elements of the list.
01:49:57 <wto> nawal: so you probably want to have parse :: String -> Int and map that over the list instead
01:50:03 <Pythonfant> except if you pass a list of list of strings in
01:50:11 <wto> good point!
01:50:16 <nawal> Very good thank you :-D
01:51:19 <sshine> nawal, what are you trying to do?
01:52:13 <nawal> sshine, I'm reading a tutorial on writing a virtual machine, http://www.codeproject.com/KB/recipes/B32Machine1/VMCS.pdf
01:52:20 <nawal> And I want to do it in Haskell
01:52:40 <nawal> Basically read in a file of a made up assembly language, and spit out a made up machine code
01:53:01 <nawal> (i.e. I'm at the building an assembler stage, I'll do the VM in C)
01:53:44 <sshine> oh, pity. making a virtual machine using a state monad could be a fun exercise.
01:58:42 <sshine> nawal, what does the comma do in "STA ,X"?
01:59:23 <serutsubi> Hi, I've just started learning haskell. I'm trying to make a tictactoe game. Can someone take a quick look at my code to see if im on the right track? http://lpaste.net/7783720774719766528
01:59:49 <bobochimp1987aka> i need relestate logins to http://www.mls.com let me know if you have need all 50 states and citites  get at me hashjuices@gmail.com will pay $$$
01:59:54 <bobochimp1987aka> i need relestate logins to http://www.mls.com let me know if you have need all 50 states and citites  get at me hashjuices@gmail.com will pay $$$
01:59:55 <Iceland_jack> serutsubi: You are
02:00:05 <bobochimp1987aka> brad
02:00:24 <serutsubi> Iceland_jack: What about the warnings from Hlint?
02:01:01 <Iceland_jack> serutsubi: the first one is a minor issues
02:01:05 <serutsubi> Also, is that the best way to represent the board, the way I've done it?
02:01:39 <Freeman42x> is there something like skip while in Haskell? needs to return all elements from an array until 1 condition is met
02:01:54 <sshine> :t takeWhile
02:01:55 <lambdabot> (a -> Bool) -> [a] -> [a]
02:02:05 <Freeman42x> sshine, thank you :D
02:02:05 <Iceland_jack> Freeman42x: dropWhile?
02:02:11 <sshine> > takeWhile (< 5) [1,2,3,4,5,6,7]
02:02:13 <lambdabot>  [1,2,3,4]
02:02:25 <Freeman42x> for this problem: http://codeforces.com/problemset/problem/158/A
02:02:32 <Iceland_jack> serutsubi: So for the 'if then else' you don't put semicolons after the statements
02:02:34 <Freeman42x> I think takeWhile is what I need
02:02:45 <shachaf> Note that lists aren't arrays and people will get confused if you call them that.
02:03:01 <Iceland_jack> and for the 'isValid' you don't want 'if then else's to check for a boolean and then return a boolean
02:03:09 <Iceland_jack> that's the same as in other languages
02:03:26 <Iceland_jack> I.e. you wouldn't write
02:03:26 <Iceland_jack>     if x > 5 then True else False
02:03:26 <Iceland_jack> You'd just write
02:03:26 <Iceland_jack>     x > 5
02:03:30 <sshine> ('if X then True else False' is the same as 'X')
02:03:41 <nawal> sshine, I'm not sure, I wondered about that.
02:03:54 * hackagebot ghc-imported-from 0.2.0.5 - Find the Haddock documentation for a symbol.  http://hackage.haskell.org/package/ghc-imported-from-0.2.0.5 (CarloHamalainen)
02:04:13 <Iceland_jack> serutsubi: as for the representation I'd change the representation into a nested list
02:04:19 <serutsubi> Iceland_jack: Ah, thanks. I'm coming from C, so semicolons are everywhere
02:04:24 <sshine> nawal, so it looks like you could split things by linebreaks, then for each line split things by spaces, and then parse instructions that way... is that your strategy?
02:04:27 <Iceland_jack> and change the content from an Int to a special data type
02:04:41 <Iceland_jack>     data Cell = Empty | X | O
02:04:41 <serutsubi> Iceland_jack: Like [[Square]]
02:04:52 <Iceland_jack> Yes
02:04:53 <serutsubi> Iceland_jack: Oh, I see now
02:04:54 <slomo> hi! say i want to write some code that has a list of command handlers that take string input and output another string (toy example: http://lpaste.net/104933 ). this works fine, but how would i do the same if every handler has its own state of a different type (e.g. some having a Reader based state, some a State, some none at all)?
02:05:09 <nawal> sshine, more or less. I think I'll need to worry about labels too, and resolve these into offsets. I think I'll do a parse, and store a map of [String]->[Int]
02:05:36 <nawal> then a second pass, and replace the ints with the real value off the offset
02:05:59 <Iceland_jack> serutsubi: If you're from C you should be familiar with having too many return values, like strcmp returning 0, greater than and less than 0
02:06:07 <nawal> I swear I had a working version in python before, but the directory is now empty. bit rot. Or more likely, false memory.
02:06:16 <Iceland_jack> when you really only have three cases
02:06:16 <Iceland_jack>     data Ordering = Less | Equal | Greater
02:06:46 <sshine> nawal, I'd validate the assembler in a second pass and not worry about labels having been defined at first.
02:07:15 <serutsubi> Iceland_jack: Yep
02:08:16 <Iceland_jack> serutsubi: In that setup the initial board would be
02:08:16 <Iceland_jack>     initialBoard :: Board
02:08:16 <Iceland_jack>     initialBoard = [[e, e, e],
02:08:16 <Iceland_jack>                     [e, e, e],
02:08:19 <Iceland_jack>                     [e, e, e]]
02:08:29 <Iceland_jack> and you can set
02:08:29 <Iceland_jack>     e = Empty
02:08:29 <Iceland_jack>     x = O
02:08:32 <Iceland_jack>     o = O
02:08:34 <Iceland_jack> *x = X
02:08:48 <Iceland_jack> although it's probably better to use the constructors for X and O
02:08:50 <sshine> slomo, map (runHandler event) hs?
02:09:21 <bobochimp1987aka> i need relestate logins to https://www.flexmls.com let me know if you have need all 50 states and citites  get at me hashjuices@gmail.com will pay $$$
02:09:25 <serutsubi> Iceland_jack: I'm confused with this *x = X and x = O
02:09:31 <serutsubi> How does that make any sense?
02:09:51 <Iceland_jack> serutsubi: It's not important, just renaming
02:09:59 <Iceland_jack> it's more important for 'e = Empty'
02:10:06 <serutsubi> Oh, alright!
02:10:24 <Iceland_jack> of course there is a nicer way of writing what I just wrote: i.e. writing the entire board by hand
02:10:37 <Iceland_jack> > replicate 3 (replicate 3 ())
02:10:38 <lambdabot>  [[(),(),()],[(),(),()],[(),(),()]]
02:10:40 <awestroke> serutsubi: I think Iceland_jack mistyped x = O and then corrected h*self by saying *x = X
02:10:54 <Iceland_jack> yes
02:11:03 <serutsubi> Oh, that makes sense then, thanks
02:11:03 <jle`> oh i thought that was a pointer
02:11:04 <sshine> slomo, I'm not sure exactly what you mean by having a list of monadic handlers. will they be working independently of one another, or will they be stacked (i.e. not a list)?
02:11:05 <Iceland_jack> (replcating () with Empty)
02:11:31 <Iceland_jack> *replacing (I need to go to bed, it's 9 in the morning)
02:11:55 <serutsubi> Ok, I'll try that
02:12:11 <slomo> sshine: they will be independent of each other. the point is to have the handling of each event complete separated from everything else, but each handler possibly having its own state of a different type
02:12:20 <serutsubi> Iceland_jack: Drink all the coffee :)
02:12:32 <Iceland_jack> I don't drink coffee oddly enough :)
02:12:51 <serutsubi> Me neither, I've just heard programmers are addicted to it
02:12:52 <slomo> sshine: e.g. one could be like one of the functions in my example, another could count the number of times it was already called and return that
02:13:17 <slomo> sshine: how would runHandler work? is that something from an existing library?
02:13:30 <sshine> slomo, no, that's just pseudocode
02:13:44 <Iceland_jack> serutsubi: (you can then either write)
02:13:44 <Iceland_jack>     isValid n = 0 < n && n < 10
02:13:44 <Iceland_jack> or
02:13:47 <Iceland_jack>     isValid n
02:13:50 <Iceland_jack>       | 0 < n, n > 10 = True
02:13:54 <Iceland_jack>       | otherwise     = False
02:14:07 <serutsubi> Iceland_jack: Is guards considered a better practise than if-else?
02:14:11 <Iceland_jack> not really
02:14:11 <serutsubi> are*
02:14:38 <awestroke> serutsubi: I usually go with whatever looks prettiest for some given code
02:14:49 <Iceland_jack> I find the comma less attention-grabbing than && so if I have many conjunctions but not many enough to abstract out I may go with that
02:15:04 <serutsubi> I'll try to make some changes and see if it complies
02:15:04 <Iceland_jack> The only time when I miss Lisp
02:15:12 <Iceland_jack> and their (< 0 x 50 y 100)
02:15:22 <serutsubi> Iceland_jack: I kind of like the guards better, it looks cleaner imo
02:15:53 <SwashBuckla> oh I didn't know about both the comma and Lisp's way of including multiple conditions
02:15:58 <SwashBuckla> nice
02:16:15 <Iceland_jack> you can also do: all ($ n) [(> 0), (< 10)]!
02:16:19 <serutsubi> Lisp looks pretty strange, after what I've seen half the source are parenthese
02:16:39 <serutsubi> parentheses*
02:16:57 <SwashBuckla> is (< 0 x 50 y 100) the same as 0 < x < 50 < y < 100 ?
02:17:06 <Iceland_jack> SwashBuckla: well < is non-associative
02:17:15 <Iceland_jack> so it's the same as 0 < x && x < 50 && ...
02:17:22 <SwashBuckla> I see
02:17:35 <Iceland_jack> similar to how Python does it, but without it being a special case
02:18:37 <Iceland_jack> Writing
02:18:37 <Iceland_jack>     a < b < c < d
02:18:37 <Iceland_jack> in Python means
02:18:37 <Iceland_jack>     a < b && b < c && c < d
02:18:49 <Iceland_jack> I should say 'and'
02:19:03 <SwashBuckla> the comma as && feels uncomfortable to me, right now
02:19:18 <Iceland_jack> SwashBuckla: it's nicer if you have other things
02:19:26 <Iceland_jack> like pattern matching
02:19:52 <SwashBuckla> mm
02:20:04 <Iceland_jack>     foo a
02:20:04 <Iceland_jack>       | Just b <- lookup a table,
02:20:04 <Iceland_jack>         even b,
02:20:04 <Iceland_jack>         Just c <- lookup c table = b + c
02:20:10 <bobochimp1987aka> my cred---
02:20:12 <bobochimp1987aka>  * This is a JavaScript Scratchpad.
02:20:12 <bobochimp1987aka>  *
02:20:12 <bobochimp1987aka>  * Enter some JavaScript, then Right Click or choose from the Execute Menu:
02:20:12 <bobochimp1987aka>  * 1. Run to evaluate the selected text (Ctrl+R),
02:21:00 <Iceland_jack> SwashBuckla: I also just used it in some code
02:21:00 <Iceland_jack>     fromList xs
02:21:00 <Iceland_jack>       | [4,4,4,4] <- map length xs
02:21:00 <Iceland_jack>       = return ...
02:21:33 <Iceland_jack> slightly simplified, you'll find a lot of code like this in GHC
02:24:57 <serutsubi> I've made some changes that I believe are right, but now it doesn't compile. http://lpaste.net/7783720774719766528
02:25:23 <serutsubi> I think this shows that I don't understand the first 8 lines or so
02:25:56 <Iceland_jack> serutsubi: you need to add 'Board' to the initialBoard
02:26:40 <Iceland_jack> also you can't use 'putStrLn' on 'initialBoard' since putStrLn requires a String
02:27:00 <serutsubi> Like this: initialBoard = Board [[e,e,e],[e,e,e],[e,e,e]]
02:27:03 <Iceland_jack> yes
02:27:23 <Iceland_jack> Board is a function that has type
02:27:23 <serutsubi> Ah, yes. It said it expected a String
02:27:23 <Iceland_jack>     Board :: [[Cell]] -> Board
02:27:41 <Iceland_jack> so you can either use
02:27:41 <Iceland_jack>     print initialBoard
02:27:41 <Iceland_jack> and define a Show instance
02:27:45 <Kazagistar> :t all (uncurry (<)) . ap zip tail
02:27:46 <lambdabot> Ord b => [b] -> Bool
02:27:50 <Kazagistar> nailed it
02:28:01 <sshine> slomo, I have an idea... just a sec.
02:28:16 <Iceland_jack> or you can use your showBoard function for that
02:29:10 <bobochimp1987aka> i need relestate logins to https://www.flexmls.com let me know if you have need all 50 states and citites  get at me hashjuices@gmail.com will pay $$$
02:29:36 <serutsubi> Iceland_jack: It compiles now. However is it best to use print or a separate function as I prototyped
02:29:39 <serutsubi> ?
02:29:58 <Iceland_jack> serutsubi: normally 'Show' is meant to be an internal representation
02:30:22 <serutsubi> Iceland_jack: Like the actual visual of the board?
02:30:23 <Iceland_jack> you can easily achieve that by doing
02:30:23 <Iceland_jack>     data Cell = Empty | X | O deriving Show
02:30:24 <Iceland_jack>     data Board = Board [[Cell]] deriving Show
02:30:35 <Iceland_jack> no like not pretty printing
02:30:42 <serutsubi> I already did that :D
02:30:43 <Iceland_jack> but a lot of people use it for pretty printing
02:30:46 * serutsubi feels smart
02:30:56 <serutsubi> I see
02:31:00 <Iceland_jack> right, if you have the 'deriving Show' then you can simply do 'print initialBoard'
02:31:15 <serutsubi> Yep, that's what I did to make it compile
02:31:33 <bobochimp1987aka> i need relestate logins to https://www.flexmls.com let me know if you have need all 50 states and citites  get at me hashjuices@gmail.com will pay $$$
02:32:06 <serutsubi> I've seen in other programs that people start with module something, should I do that?
02:32:07 <Iceland_jack> but you might want to have it appear in a nicer way like
02:32:07 <Iceland_jack>      ␣ | X | ␣
02:32:07 <Iceland_jack>     ---+---+---
02:32:07 <Iceland_jack>      O | ␣ | ␣
02:32:10 <Iceland_jack>     ---+---+---
02:32:15 <Iceland_jack>      X | O | X
02:32:36 <Iceland_jack> serutsubi: If you plan on importing this from another file, otherwise the module becomes Main by default
02:32:58 <serutsubi> Yes, however I'm thinking of using numbers instead of ␣, so that the user can see where the choice is
02:33:09 <Iceland_jack> sounds like a good move
02:33:28 <serutsubi> Ok, so I prob. don't need a module thing then
02:33:58 <Iceland_jack> you can make that your own specific function
02:33:59 <Iceland_jack>     showBoard :: Board -> String -- rather than IO ()
02:33:59 <Iceland_jack> or you can make that the show instance, both are valid
02:34:30 <serutsubi> Make what a show instance?
02:34:39 <Iceland_jack> create your own specific show instance
02:34:54 <Iceland_jack>     instance Show Board where
02:34:54 <Iceland_jack>         show (Board cells) = ...
02:35:09 <Iceland_jack> then doing 'print someBoard' uses that definition
02:35:11 <serutsubi> I donæt think I've learnt about ths stuff
02:35:47 <Iceland_jack> serutsubi: the Show instance for Bool might be
02:35:47 <Iceland_jack>     instance Show Bool where
02:35:47 <Iceland_jack>       show True  = "True"
02:35:47 <Iceland_jack>       show False = "False"
02:35:52 <Iceland_jack> super simple right?
02:36:00 <serutsubi> Oh!
02:36:06 <Iceland_jack> If you choose the first one you could then do
02:36:06 <Iceland_jack>     printBoard :: Board -> IO ()
02:36:06 <Iceland_jack>     printBoard = putStrLn . showBoard
02:36:18 <serutsubi> It's like telling haskell how to display stuff
02:36:29 <Iceland_jack> yes, or how to turn them into Strings
02:36:45 <Iceland_jack> the 'printBoard' is analogous to how 'print' itself is defined
02:36:47 <Iceland_jack> @src print
02:36:47 <lambdabot> print x = putStrLn (show x)
02:37:18 <Iceland_jack> show turns them into strings and putStrLn outputs them
02:37:20 <Rc43> I have heard that "foldl" considered useless and I have to use foldl' when I want to use fodl. Is it common opinion?
02:37:31 <Rc43> I want strict fold.
02:37:56 <Dtgr> Rc43: http://www.well-typed.com/blog/90/
02:37:57 <serutsubi> Iceland_jack: Okay, let me see if I can manage to implement it
02:38:25 <Rc43> Dtgr, so is it common opinion? If yes, why there is no foldl' in prelude?
02:38:38 <Dtgr> Rc43: for historical reasons
02:38:49 <slomo> sshine: ok :) i think one of my problems is that i don't know what type such a generic handler should have... in general it would be String -> a -> (String, a), but how would i store these into a list when there are different as (e.g. one could be Int, one could be (), ...)
02:39:00 <Dtgr> that blog post explains some of the historical reasons behind it
02:39:09 <Rc43> Dtgr, ok, thanks
02:39:56 <sshine> slomo, well, I haven't circumvented that problem - I suppose a union type would do that.
02:41:58 <sshine> slomo, like type Handler a = String -> State a String, and data UHandler = IHandler (Handler Int) | SHandler (Handler String) | ... -- not sure if that's preferrable, though.
02:42:23 <slomo> sshine: hmm... but that would kind of defeat the purpose... i want each of these handlers to be in a separate module and the main module not know anything about them, other than somewhere building a list of them and then iterating over them on every event
02:42:34 <serutsubi> Iceland_jack: I'm not sure what to replace the dots with in "show (Board cells) = ...". And in this case what is cells?
02:43:08 <Iceland_jack> serutsubi: here we're pattern matching on 'Board' whose first argument has type [[Cell]]
02:43:22 <Iceland_jack> Recall the type of Board
02:43:22 <Iceland_jack>     Board :: [[Cell]] -> Board
02:43:53 <slomo> sshine: in e.g. java i would do this by having them all implement an interface with some kind of "String eval(String input);" method... that way the implementation details like how state is tracked or if at all would be completely hidden away
02:44:05 <Iceland_jack> serutsubi: If you define a person type as
02:44:05 <Iceland_jack>     data Person = Person Name Age
02:44:05 <Iceland_jack> then you can pattern match on that as such
02:44:05 <Iceland_jack>     getAge :: Person -> Age
02:44:08 <Iceland_jack>     getAge (Person _ age) = age
02:44:19 <Iceland_jack> since Person is a function
02:44:19 <Iceland_jack>     Person :: Name -> Age -> Person
02:44:39 <Iceland_jack> its former argument has type Name and latter, Age
02:45:05 <serutsubi> In the patternmatch the _ is just the rest of the junk we don't care about in that function?
02:45:09 <sshine> slomo, my initial thought is that maybe you can avoid this by composing your handlers rather than listing them.
02:45:10 <Iceland_jack> yes
02:45:14 <Iceland_jack> _ is a wildcard pattern
02:45:50 <serutsubi> Like the * in unix/bash or whatever it is?
02:45:51 <Iceland_jack> serutsubi: one example, if you want to match a singleton list you can do
02:45:51 <Iceland_jack>     isSingleton :: [a] -> Bool
02:45:51 <Iceland_jack>     isSingleton [_] = True
02:45:51 <Iceland_jack>     isSingleton _   = False
02:46:07 <Iceland_jack> eh, yes and no
02:46:13 <sshine> slomo, this way your final composed handler might have a type that reflects its components, but the individual handlers within don't need to have homogeinic state.
02:47:02 <sshine> slomo, I guess this is equivalent to having a huge handler with an n-tuple as state for n handlers.
02:47:19 <serutsubi> Iceland_jack: How come [_] doesn't match everything inside the list?
02:47:36 <Iceland_jack> _ matches everything, but only for the first element
02:47:42 <Iceland_jack> [_,_] would match lists of length 2
02:47:45 <Iceland_jack> [_,_,_] would match lists of length 3, …
02:47:52 <FireFly> [_] is sugar for _:[]
02:48:29 <serutsubi> Any more sugar now and I'll get diabetes...
02:48:29 <slomo> sshine: hmmm, that sounds like a possible approach. seems a bit weird though, but let me try that :)
02:48:37 <serutsubi> Jokes aside, I think I understand it now :)
02:49:01 <Iceland_jack> serutsubi: note that this can be useful for your game
02:49:15 <serutsubi> _ matches a single element then?
02:49:23 <Iceland_jack> yes
02:49:31 <FireFly> it matches any single value
02:49:33 <Iceland_jack> it's the same as using a free variable 'a' or 'b', ...
02:49:37 <Iceland_jack> and not using it
02:49:43 <sshine> slomo, I've never made functional event handlers, so I don't know how much it's worth :P
02:49:51 <Iceland_jack> You can match on the entire board
02:49:52 <Iceland_jack>     foobar (Board [[a, b, c], [d, e, f], [h, i, j]]) = ...
02:50:12 <Walther_> then again, if you're matching against a list of lists, _ can mean one of those lists, instead of one element, afaik
02:50:25 <Iceland_jack> yes but that's still an element
02:50:29 <Walther_> indeed
02:50:44 <serutsubi> How would I then match the third element in the second list?
02:50:45 <Walther_> just a ...higher dimension element
02:51:07 <sshine> slomo, in your Java analogy, if you ever wish to extract the values of the handler states, you need to parameterize of that type and you end up with the same problem (that your interface has a type parameter that might be different for individual handlers)... right?
02:51:07 <Iceland_jack> serutsubi:
02:51:07 <Iceland_jack>     foo (Board [_, [_,_,elt], _]) = ...
02:51:27 <serutsubi> Oh, that makes sense
02:51:51 <slomo> sshine: yes, but in my situation only the handlers ever have to extract their own state
02:52:12 <Iceland_jack> If you want to check the state of that you could do
02:52:12 <Iceland_jack>     foo (Board [_, [_, _, X], _]) = "X has third cell, second row"
02:52:12 <Iceland_jack>     foo (Board [_, [_, _, O], _]) = "O has third cell, second row"
02:52:15 <Iceland_jack>     foo (Board [_, [_, _, _], _]) = "nobody has it!
02:52:18 <serutsubi> I'm guessing it is redundant to make 9 functions each getting the value of a cell?
02:52:22 <Iceland_jack> yes
02:52:35 <Iceland_jack> you wouldn't actually write code like this, for the most part anyway
02:52:48 <Iceland_jack> if there is some highly specific pattern you want to test for it may make sense
02:53:07 <sshine> usually in nested data structures like syntax trees.
02:53:50 <slomo> sshine: another solution i thought of would be to use forkIO and Chans... and have the event producer write to a channel that all handlers are reading from, and then let them all write the output to a single channel from which the individual outputs are read and then something is done with them... but that also seems overly complicated for what i want to do ;)
02:53:53 <serutsubi> So this approach wouldn't work if I deceided to have a variable dimention on the board, right?
02:54:10 <Iceland_jack> That's right, these examples are more toy examples
02:54:18 <Iceland_jack> you can of course pattern match on variable length lists
02:54:30 <Iceland_jack> [a], [a,b], [a,b,c] are all syntactic sugar for that
02:55:01 <Iceland_jack>     [a]     = a:[]
02:55:01 <Iceland_jack>     [a,b]   = a:(b:[])
02:55:01 <Iceland_jack>     [a,b,c] = a:(b:(c:[]))
02:55:18 <Walther> You might want to look into making your own Data type
02:55:36 <Iceland_jack> > let [a, b, c] = "hi!" in [c, b, a]
02:55:37 <lambdabot>  "!ih"
02:55:42 <Walther> erm, data structure?
02:55:49 <Iceland_jack> > let a : b : c : [] = "hi!" in [c, b, a]
02:55:50 <lambdabot>  "!ih"
02:56:06 <serutsubi> Olala! I understand it :)
03:00:57 <Iceland_jack> serutsubi: Great!
03:13:29 <Ainieco> what is the best way for creating non-blocking game loops? currently my task is simple - i have Game record which is represent state of game and i just want to increment timee counter in it
03:13:59 <Freeman42x> any way to write LINQ like queries in Haskell piped from left to right instead of right to left? pseudocode eg., instead of: length . filter . skip someArray to have someArray skip filter length
03:14:13 <Ainieco> thinking about forkIO recursive loop with one callback which will be able to access Game inside that loop
03:14:21 <Ainieco> but not sure if it's a good way to do it
03:16:06 <pingu> Ainieco: you might want to look at netwire or something like that
03:16:30 <Ainieco> pingu: thanls for tip
03:16:34 <Ainieco> thanks*
03:18:01 <Kazagistar> Freeman42x: any particular reason why you would prefer to go that direction?
03:18:14 <pingu> Freeman42x: presumeably you could define a flip (.) operator. It seems like you're trying to shoehorne old habits into haskell though
03:18:25 <Ainieco> pingu: it doesn't looks like it's still maintained
03:18:26 <pingu> *shoehorn
03:18:31 <Iceland_jack>     (|>) = flip ($)
03:18:37 <Freeman42x> Kazagistar, pingu I kinda find it easier to read :)
03:18:53 <pingu> Freeman42x: which is all well and good if only you are ever touch your code
03:19:08 <Freeman42x> if I were from some right to left language, it might not seem that weird, but right now it reads weird to me :)
03:19:08 <pingu> you'll confuse other haskellers, though, who are used to reading right to left for composition
03:19:27 <pingu> Freeman42x: yeah, it's weird for most at first
03:19:30 <Kazagistar> Freeman42x: it wont seem less weird if you dont practice it
03:19:47 <Iceland_jack> > let (|>) = flip ($) in [1,2,3,4] |> join (++) |> map pure |> join |> sum
03:19:48 <lambdabot>  20
03:20:36 <pingu> Ainieco: I can't comment on that
03:20:49 <pingu> I know people are still using it
03:20:50 <Freeman42x> hehe, it looks cool though xD
03:21:14 <pingu> is netwire still mantained anyone?
03:21:26 <Freeman42x> thing is I am used to read from left to right and also to start from the beginning, not with the final operation
03:21:42 <pingu> Freeman42x: otherwise there's plenty of other FRPish things out there. netwire seems the most 'gamelike' to me, though
03:22:37 <Kazagistar> Freeman42x: most haskellers complain that lens is backwards, so you might find it more to your liking, but it is a bit complex
03:22:38 <pingu> Freeman42x: if you're interested in something new and slightly easier maybe: http://www.haskellforall.com/2014/04/model-view-controller-haskell-style.html
03:22:46 <edwardk> most?
03:22:53 <pingu> Freeman42x: disreguard, I meant Ainieco
03:23:02 <mbrock> slomo: does your basic problem reduce to wanting to have several stateful a -> a transformation functions, so that you can evaluate them all and gather their results?
03:23:15 <Kazagistar> edwardk: sorry, my bad. I meant "many" so as to be irrefutable :P
03:23:20 <mbrock> slomo: um, and with all the stateful things having different types of state?
03:23:49 <edwardk> I'll grant a vocal minority of at least 1 ;)
03:23:50 <Kazagistar> Freeman42x: why would you want to continue that habit of reading in the wrong direction in haskell though?
03:23:58 <Freeman42x> Kazagistar, is that flip part of lens?
03:24:14 <Freeman42x> Kazagistar, but why is it the `wrong direction`?
03:24:42 <Freeman42x> I mean, the parameters of functions still read to the right but the flow goes to the left, it is confusing :) IMO (TM)
03:24:51 <pingu> Freeman42x: mathematically, we're used to compisition being right to left
03:24:57 <pingu> i.e. f . g reads "f before g"
03:25:03 <edwardk> lens composes in the same direction as fmap, traverse, foldMap and the only direction it can, which happens to mean it precisely replicates with (.) the silly kind of (.) OOP people like. a happy accident ;)
03:25:05 <pingu> and haskell is still pretty academic in its heratige
03:25:19 <pingu> *heritage
03:25:48 <pingu> why can I correct my own spelling mistakes, but not just spell them right in the first place?
03:25:54 <jle`> Freeman42x: it will be less confusing after even a day or so
03:26:07 <Freeman42x> ok, but is there any... sensible reason why do it like that? :) left + right combined
03:26:09 <jle`> Freeman42x: there is no reason to bring in old habits into a new language with different idioms :)
03:26:18 <jle`> it'd be like if i wanted to use GOTO's in haskell
03:26:20 <Freeman42x> I agree, it is just that... ugh xD
03:26:29 <jle`> i mean...i could if i really wanted to, i guess
03:26:38 <jle`> becuase that's what reads easiest for me
03:26:44 <jle`> hm.
03:26:48 <jle`> i think the direction comes from
03:26:54 <jle`> (f . g) x = f (g x)
03:27:01 <pingu> Freeman42x: function composition is a pretty basic mathematical concept. That's where the left-right thing comes from.
03:27:04 <Freeman42x> at least this make people not create very long lines... since the reading starts there xD
03:27:07 <jle`> (f . g . h) x = f (g (h x))
03:27:10 <pingu> jle`: yes, that ^^
03:27:22 <Freeman42x> at the end of the line I mean
03:27:30 <jle`> haha :P
03:27:36 <pingu> If you were to do it backwards, you might as well start applying your functions backwards
03:27:38 <jle`> that's one way to look at it :)
03:27:53 <jle`> pingu: netwire is still maintained
03:28:01 <Freeman42x> yeah, that is the confusing part to me, if doing it backwards, at least go all the way ^^
03:28:13 <jle`> pingu: if you have specific questions, you can always ask here or on #haskell-game
03:28:22 <pingu> Ainieco: netwire is still maintained!
03:28:31 <jle`> oh, Ainieco
03:28:42 <Kazagistar> Freeman42x: we dont apply them backwards though, we apply them the same exact way as C or any imperative language
03:29:04 <jle`> if your function in C is foo(x) and bar(x), you'd say foo(bar(x))
03:29:10 <Freeman42x> yeah, functions are applied to the right, but composition flow goes to the left... ouch
03:29:12 <jle`> not ((x)bar)foo
03:29:33 <Freeman42x> I was saying I would have prefered if it was completely reversed
03:29:49 <jle`> hm?
03:29:50 <pingu> I would find such a patch to ghc amusing.
03:29:55 <pingu> -freverse-apply
03:29:55 <Freeman42x> right now reading is like jump jump jump
03:30:06 <jle`> (f . g . h) x = f (g (h x)) makes sense to me
03:30:08 <jle`> no jumping
03:30:19 <jle`> x goes to h goes to g goes to f
03:30:34 <jle`> the jumping happens when you use those weird left-right application/composition operators
03:30:37 <jle`> like (>>=)
03:30:42 <jle`> (>>=) is so awward
03:30:44 <jle`> awkward
03:30:50 <jle`> it is basically a flip ($)
03:31:03 <jle`> also, lambda syntax sometimes makes you want to go left-to-right, with the arrow
03:31:05 <pingu> jle`: you are aware of =<<?
03:31:08 <Freeman42x> well, let's say like so function2 $ param . function1 param param. eyes jump to function 1 then jump to params of it and then jump to function2 and then to params of it
03:31:14 <Freeman42x> it is a lot of going back and forward
03:31:17 <jle`> pingu: yes, but (>>=) still xists and is used in the wild
03:31:46 <jle`> Freeman42x: can you write that with actual functions
03:31:50 <jle`> it doesn't have to go back and forth
03:31:51 <Freeman42x> in C# LINQ or Scala or Java 8 the flow always reads to the right
03:32:17 <Kazagistar> jle`: that syntax looked like Forth to me, best stay away from there
03:32:20 <jle`> Freeman42x: what about foo(bar(x)) ?
03:32:32 <Freeman42x> what about it?
03:32:41 <jle`> that's to the left, isn't it?
03:32:46 <jle`> x goes to bar goes to foo
03:33:02 <Freeman42x> yeah
03:33:08 <jle`> i'm also not sure what function2 $ param function1 param param is supposed to be
03:33:18 <Freeman42x> but that is not what I was talking about :)
03:33:29 <jle`> if you use (.) and ($) you shouldn't ever need to jump around
03:33:30 <Freeman42x> me neither, beginner :D
03:34:54 <jle`> :)
03:34:57 <Ainieco> pingu: awesome! :)
03:35:01 <serutsubi> This is the current (non-compiling) version: http://lpaste.net/7783720774719766528. The compiler says something about multiple declarations of showBoard.
03:36:13 <pingu> serutsubi: the problem is that you already derived Show
03:36:18 <pingu> data Board = Board [[Cell]] deriving (Show)
03:36:27 <pingu> and you're trying to specify an instance of it again
03:36:27 <Freeman42x> jle`, for example this: print $ length . filter (> 0) $ takeWhile (>= scores !! (k - 1)) scores ,  eyes jump to end of line then what they are looking for is `takeWhile`... then jump to the right and analyze the parameters of `takeWhile`, then jump to the left to `filter` and then back again to the right to read the `filter` parameters. this is a lot of inefficient left-right jumping
03:36:43 <jle`> you shouldn't ever have to use more than one ($) per line/parentheses
03:36:57 <serutsubi> pingu: Oh, ok. I'm trying to make a show that displays it in a visual way. I can just remove deriving show then
03:36:58 <jle`> print . length . filter (> 0) . takeWhile (>= scores !! (k-1) $ scores
03:37:22 <Luke> I'm getting "codex.tags is not a valid tags table" in emacs when trying to use codex. anyone able to use codex from emacs?
03:37:25 <jle`> or print . length . filter (> 0) $ takeWhile (>= scores !! (k-1)) scores
03:37:27 <jle`> whatever is to your fancy
03:37:33 <pingu> serutsubi: correct
03:37:56 <jle`> and takeWhile only has one parameter
03:37:59 <jle`> the predicate
03:38:11 <sshine> :t takeWhile -- has two?
03:38:12 <lambdabot> (a -> Bool) -> [a] -> [a]
03:38:27 <jle`> you could read it as "'takeWhile (>= scores !! (k-1))' applied to 'scores'"
03:39:08 <jle`> and to make it even more readable you can say takeScores = takeWhile (>= scores !! (k-1)) and do
03:39:12 <Freeman42x> jle`, yeah, but my point is that you have to do a lot of left-right jumping, which you would not have to do in C# LINQ, Scala queryies with chaining, Java 8 etc
03:39:18 <jle`> (print . length . filter . takeScores) scores
03:39:25 <jle`> but ther eis no left to right jumping there
03:39:33 <jle`> it all reads one direction
03:40:01 <Freeman42x> uh xD I will make a drawing
03:40:18 <jle`> scores goes to takeScores which goes to filter (>= 0) which goes to length which goes to print
03:40:18 <Freeman42x> jle`, what is the final optimized expression? :)
03:40:19 <Kazagistar> Freeman42x: f x = g(h(j(x)))  ~  f x = g $ h $ j x  ~  f x = (g . h . j) x  ~  f x = g . h . j $ x  ~  f = g . h . j
03:40:20 <jle`> hm
03:40:31 <jle`> oh, do you mean that you jump from filter to (> 0)
03:40:44 <slomo> mbrcknl: maybe... each of them should get the original input, and the output of each of them should by accumulated in a list. but they all should be stateful but with different types of states
03:40:45 <Freeman42x> yes, and from takeWhile to the parameters
03:40:50 <jle`> print . length . filter (> 0) . takeScores $ scores
03:40:55 <Freeman42x> it is unneded back-jump
03:41:04 <pingu> Freeman42x: try reading each bit between compositions (.) as a whole "function"
03:41:09 <pingu> 'cause it is'
03:41:22 <Freeman42x> pingu, yeah, that would work
03:41:23 <jle`> i think i see your point, cause there is some slight eye jumping
03:41:36 <jle`> but it never bothered me for some reason
03:42:00 <pingu> whatever is between two dots should be a function from whatever's to the right to whatever's left.
03:42:03 <Freeman42x> that is what I meant, in other languages I mentioned you could always just move eyes to the right
03:42:22 <Freeman42x> when doing collection querying I mean
03:42:34 <pingu> Freeman42x: most other languages don't provide function composition, though.
03:42:34 <dottedmag> Freeman42x: You could always write code in C# or Java 8 which will require one to jump eyes.
03:42:36 <mbrock> slomo, sshine: something like this might work? http://lpaste.net/104937
03:42:48 <dottedmag> Freeman42x: You could write code in Haskell which does not require one to do so.
03:42:51 <pingu> and function composition is not a query language. it's not 'meant' to be any more than it is
03:43:02 <Freeman42x> dottedmag, yes, ofc, but the default in haskell :( uh
03:43:24 <pingu> Freeman42x: the default in maths ;)
03:43:37 <Freeman42x> well, it is not an excuse :)
03:43:40 <jle`> i really don't even notice the very slight jumping :|  my eyes just see filter (>0) as one unit subconsciously
03:43:54 <mbrock> slomo: note how the existential quantification allows `handlerA` to use an integer as a state without this affecting its type
03:44:17 <Freeman42x> anyway, silly argument, ignore what I just mentioned xD it's a slight disturbance compared to the huge beneifts
03:44:27 <Kazagistar> Freeman42x: why do you need to follow the flow from "input to output", when it is the output driving the lazy evaluation in the first place?
03:44:40 <mbrock> slomo: (I generalized from String -> String to a -> b)
03:44:47 <jle`> i guess that's another point. haskell is a pull-based language, not a push-based one
03:45:10 <jle`> so really the most "important" thing, evaluation-based, is the final function, the "f" in f . g . h $ x
03:45:21 <Freeman42x> Kazagistar, good question... dunno, not used to looking at lazy code. but usually when I try to understand something I start from the start and look at the steps which are done
03:45:23 <jle`> because f pulls from g, which pulls from h, which pulls from x
03:45:34 <Kazagistar> you read the compositions as a statement of what something "is"
03:45:42 <mbrock> jle`: that's also why >>= makes sense :)
03:46:01 <jle`> mbrock: hm, how so?
03:46:26 <jle`> Freeman42x: Kazagistar brings up another good point; functional programming makes you think less about "what happens to what and when" and more about "how things are"
03:46:57 <slomo> mbrock: thanks, i'll experiment a bit with that. i didn't understand what forall does, but maybe this can help me to understand :)
03:47:02 <jle`> in truth f . g . h . k . j $ x is not preferred
03:47:13 <Kazagistar> I say these things cause I went through the same struggles not so long ago :)
03:47:21 <jle`> instead you would say "let foo = f . g . h . k . j in foo x"
03:47:24 <Freeman42x> the thing is, if I look at the last operation, all I understand is that some operation is applied to some thin which I do not even know what it is
03:47:41 <Freeman42x> if I read from the beginning, when I get at that last part, I know what that `thing` represents
03:47:49 <jle`> or "let foo = f . g . h; bar = k . j in (foo . bar) x"
03:47:57 <mbrock> jle`: it makes the monadic ordering obvious. the explicit sequencing of effects is a big motivating thing behind monads so >>= seems like a very natural operator
03:48:30 <Freeman42x> can we get 6 more people so we can be 1337 :D
03:48:54 <Kazagistar> Freeman42x: I prefer "where" notation personally for that reason, since it motivates the local declarations before detailing them
03:49:11 <jle`> mbrock: but what i was saying sort of suggests the opposite, doesn't it?
03:49:30 <jle`> evaluation "starts with f" in f . g . h $ x
03:49:57 <Freeman42x> I still need to grasp basic concepts, like difference between let and where (except their positioning), and lots of other stuff
03:50:10 <Iceland_jack> Freeman42x: let is an expression
03:50:21 <Iceland_jack> > (let x = 5 in x + x) * 7
03:50:22 <lambdabot>  70
03:50:55 <Kazagistar> > take 15 . concat . map show $ [10,20..]
03:50:56 <lambdabot>  "102030405060708"
03:51:10 <Freeman42x> ah, so let also has a value, hmm. never seen it used like that though yet
03:51:13 <Iceland_jack> > take 15 (concatMap show [10,20,..])
03:51:14 <lambdabot>  <hint>:1:32: parse error on input ‘..’
03:51:19 <Iceland_jack> > take 15 (concatMap show [10,20..])
03:51:20 <lambdabot>  "102030405060708"
03:51:28 <Kazagistar> Iceland_jack: my bad :P
03:51:33 <Iceland_jack> > take 15 ([10,20..] >>= show)
03:51:35 <lambdabot>  "102030405060708"
03:52:17 <whoami_> \pl (\a->1==gcd 2 a)
03:52:21 <jle`> > take 5 . filter even . map ( (^2) . (+3) ) $ [1..]
03:52:23 <lambdabot>  [16,36,64,100,144]
03:52:57 <jle`> to start evaluating that, you look at take 5, which says "give me the first five elements, 'filter even'!"
03:53:06 <jle`> and `filter even` is like...ok, got it
03:53:24 <whoami_> @pl (\a->1==gcd 2 a)
03:53:24 <lambdabot> (1 ==) . gcd 2
03:53:25 <jle`> and it says "give me all you got, map...", and pops out items as soon as it sees things that are even
03:53:40 <mbrock> slomo: just FYI, you can also define it as "Handler s (State s (a -> b))" which in some ways could be more natural, but I think the two definitions are equivalent
03:53:44 <jle`> so filter asks map for everything one at a time, but only pops back out things that are even
03:53:48 <jle`> and map is all like
03:53:59 <jle`> er, map ((^2).(+3)) is all like
03:54:06 <jle`> "yo [1..], give me everything you got one at a time"
03:54:16 <jle`> and it pops out what it receives one at a time, with the function applied
03:54:26 <jle`> and [1..] is like "ok got it"
03:55:01 <jle`> and just pops out 1, 2, 3, 4...until map ((^2).(+3)) stops asking for stuff, which is when filter even stops asking for stuff, which is when take 5 stops asking for stuff
03:55:44 <jle`> once take 5 gets all 5, it stops asking for stuff from filter even, which stops asking for stuff from map ((^2).(+3)), which stops asking for stuff from [1..]
03:55:48 <jle`> i should probably sleep now :|
03:56:12 <jle`> anthropomorphising lazy functions in my head makes me some sort of insane i think
03:56:27 <dottedmag> Sounds like "This is the House That Jack Built".
03:56:56 <jle`> the key is that take 5 is the king and thing that makes everything happen
03:57:21 <Kazagistar> you forgot "[1..] looks in the Enum instance for Int and is all like 'enumFrom (1 :: Int)' generate me some valid data of the type you inferred magically!"
03:57:33 <jle`> if i did [1..] & map ((+3)>>>(^2)) >>> filter even >>> take 5
03:57:39 <jle`> it would be very weird
03:57:47 <Maxdamantus> I think anthropomorphicisation is meant to refer to animals, not functions.
03:57:48 <jle`> in the context of that narrative
03:57:58 <awestroke> I never liked anthropomorphic programming analogues...
03:58:12 <mbrock> I live with several domesticated functions
03:58:25 <mbrock> they're nice to me
03:58:32 <Kazagistar> morphismorphication?
03:58:50 <mbrock> and they're very predictable
03:58:55 <Maxdamantus> That's just taking out the human aspect.
03:59:08 <jle`> anthropomorphism applies to anything being given human characteristics
03:59:18 <Kazagistar> dang, I tried, but I dont know any latin whatsoever
03:59:25 <awestroke> anthropomorphism is not homomorphic
03:59:54 <awestroke> which can be problematic
03:59:55 <jle`> i can probably construct an anthropomorphic homomorphism
03:59:58 <Kazagistar> so it would be morphism antropomorphism
04:00:25 <jle`> good night all
04:00:33 <Kazagistar> lol gnight
04:01:44 <mbrock> the annual parade of anthropomorphic homomorphisms. we're abstract entities and that's cool
04:04:50 <halvorg> http://lpaste.net/6807322765280935936
04:05:01 <halvorg> can someone explain how that pattern isn't matched?
04:06:20 <Iceland_jack> halvorg: GHC can't tell whether your guards are exhaustive
04:06:20 <awestroke> halvorg: how could haskell know that those 3 options fully define the set of possible combinations?
04:06:27 <awestroke> Iceland_jack said it better
04:06:36 <Iceland_jack> so you'll need to add a catch-all clause
04:06:54 <halvorg> oh ofc. its the guards
04:06:57 <halvorg> I see, thanks
04:07:11 <halvorg> Thought it was the parameter matching
04:07:18 <trap_exit> Blah.hs has module name "Blah". What is should the module name of Foo/Bar.hs be?
04:08:37 <awestroke> trap_exit: module Foo.Bar
04:10:21 <trap_exit> awestroke: nice, thanks!
04:11:08 <Nik05> how would you get all k-combinations from a list?
04:12:59 <awestroke> > permutations [1,2,3,4,5] -- like that?
04:13:00 <lambdabot>  [[1,2,3,4,5],[2,1,3,4,5],[3,2,1,4,5],[2,3,1,4,5],[3,1,2,4,5],[1,3,2,4,5],[4,...
04:13:13 <Nik05> now those are permutations, i need combinations
04:13:19 <Nik05> no*
04:16:34 <awestroke> Nik05: I found this: http://stackoverflow.com/questions/21775378/get-all-possible-combinations-of-k-elements-from-a-list
04:17:16 <Nik05> thank you awestroke i think that is it
04:21:02 <Kazagistar> comb n = let comb
04:21:11 <Kazagistar> oops, wrong window haha
04:25:07 <Nik05> cool it works
04:30:23 <lwm> :t const
04:30:24 <lambdabot> a -> b -> a
04:30:56 <Sculptor> abba
04:31:18 <davnils> :t const . const
04:31:19 <lambdabot> a -> b -> b1 -> a
04:31:24 <davnils> almost.
04:31:36 <lwm> ha!
04:31:42 <Nik05> mapM (const cs) [1..k] gives you all k-combinations...(incl. repetition) :S
04:31:55 <awestroke> hmm... what's the typeclass that spells a o l?
04:34:10 * hackagebot stack-prism 0.1 - Stack prisms  http://hackage.haskell.org/package/stack-prism-0.1 (SjoerdVisscher)
04:34:12 * hackagebot haroonga 0.1.2.0 - Low level bindings for Groonga.  http://hackage.haskell.org/package/haroonga-0.1.2.0 (cosmo0920)
04:37:20 <trap_exit> data SvgGroup deriving (Eq) ; <-- how do I fix this to not be an error ?
04:38:16 <davnils> can you have equality without any value constructors?
04:38:27 <davnils> (==) denotes value level equality
04:39:42 <Maxdamantus> So you'd probably say a == a = True
04:39:53 <Maxdamantus> er .. _ == _ = True
04:40:41 <Maxdamantus> Hm. No, that's probably not very good.
04:41:03 <Maxdamantus> _ == _ = undefined
04:41:20 <davnils> hmm, yeah
04:41:54 <davnils> trap_exit: write an explicit "instance Eq SvgGroup" without pattern matching
04:42:25 <Maxdamantus> ahah .. I've got it: _ == _ | False = True
04:43:36 * Maxdamantus wonders if you're allowed to have a case expression with no members.
04:43:47 <Maxdamantus> > case 4 of {}
04:43:49 <lambdabot>  Empty list of alternatives in case expression
04:43:49 <lambdabot>    Use EmptyCase to allow this
04:43:56 <Maxdamantus> Meh, lame.
04:44:20 <Kazagistar> you mean, yay, it catches a programming error?
04:44:44 <Maxdamantus> I mean, meh, it's inconsistent.
04:48:38 <tac_> > let x :: Void; x = undefined in (case x of {}) :: Int
04:48:39 <lambdabot>  Not in scope: type constructor or class ‘Void’Empty list of alternatives in ...
04:48:39 <lambdabot>    Use EmptyCase to allow this
04:53:37 <Kazagistar> something something foolish consistancy something something little minds
04:59:11 <Redz> @hoogle xor
04:59:13 <lambdabot> Data.Bits xor :: Bits a => a -> a -> a
04:59:13 <lambdabot> package xorshift
04:59:13 <lambdabot> Graphics.Rendering.OpenGL.GL.PerFragment Xor :: LogicOp
05:00:03 <haasn> Maxdamantus: a == b = case a of {}
05:00:07 <haasn> or a == _ even
05:00:10 <haasn> cc davnils
05:00:19 <haasn> This requires EmptyCase or whatever extension
05:00:33 <davnils> bcc trap_exit
05:00:33 <haasn> But for values with no constructors, that is perfectly sane
05:01:03 <haasn> Oh, you already found the EmptyCase thing :)
05:01:11 <haasn> Anyway, that is the “de-facto” way to deal with Void cleanly
05:11:40 <trap_exit> suppose I ahve things like Foo/Bar.hs Foo/Dog.hs Foo/Cat.hs
05:11:48 <trap_exit> and Bar + Dog + Cat all arequire the same data declarations
05:11:59 <trap_exit> should I call it Foo/Data.hs or Foo/Types.hs or Foo/Internatls.hs ?
05:27:56 <slomo> mbrock: thanks again, needed some time to understand how i can move that to my exact problem but it gave me enough hints :)
05:30:54 <kliko> Good afternoon guys, I have a small question. I am using: http://hackage.haskell.org/package/matrix-0.3.1.0 and I would like to convert the matrix object into a double list, how should I do that? I thought there was a function for it
05:31:10 <kliko> signature of course is Matrix a -> [[a]]
05:31:36 <kliko> I think I'm overlooking something, since I thought I could use toList or something like that
05:32:20 <Reite> kliko: you can use Data.Foldable.toList
05:34:18 <kliko> oh thank you Reite
05:35:28 <kliko> hmm.. that would give me only [a]
05:36:30 <kliko> I thought it already had an implementation of Matrix a -> [[a]]
05:38:39 <tac_> Is a Foldable t just a type constructor that comes equipped with a dedicated map t a -> [a]?
05:41:12 <Reite> kliko: Yeah thats a bit strange
05:41:19 <pjdelport> kliko: Lacking an existing function, maybe you can get away with writing a small helper based on getRow / getCol?
05:41:28 <pjdelport> kliko: And file an issue for it to be added? :)
05:42:59 <kliko> Yeah, that is of course possible, however I really thought there was such function
05:43:16 <kliko> but maybe I was dreaming haha
05:44:38 <jfirth> hi. I was looking at http://stackoverflow.com/questions/19869019/how-to-represent-and-update-bidirectional-references-in-haskell and wondering if the accepted answer is a good / idiomatic way of representing the bidirectional relationship. Any thoughts? Apologies if there's a better place to ask.
05:45:49 <kliko> thanks guys for the help :D!
05:46:10 <pjdelport> jfirth: Probably? It depends a great deal on the eventual application, I would guess.
05:48:27 <Redz> do someone know about a version of the Network module with automatic reconnect?
05:49:10 <jfirth> pjdelport: k, thanks
05:49:45 <lechip> hello all, Im trying to understand if making this expresison ispossible data Unit = U and then assign a variable to it, say let a = U
05:52:23 <pjdelport> lechip: Yes, although you would omit the "let" when making a top-level binding in a module.
05:52:41 <pjdelport> You'd add it to make the binding in ghci, though.
05:52:55 <lechip> ah true, so if i wanted to make a of type Unit but be = to _|_ how would i do such a thing?
05:54:12 <merijn> lechip: Note that you never "assign" a variable to it
05:55:08 <merijn> lechip: You define a new name for an expression. "a = U" just says that you can use 'a' and 'U' interchangeably
05:55:32 <tac_> lechip: a = undefined?
05:56:03 <merijn> "a = undefined :: Unit", although that's a horrific thing to do
05:56:09 <lechip> yeah but making a stay of type Unit
05:56:16 <merijn> Alternatively, "a :: Unit; a = undefined"
05:56:34 <lechip> what if i do something like bot :: Foo bot = bot  a = bot
05:56:34 <merijn> lechip: What do you mean "stay of type Unit"?
05:56:46 <lechip> i meant bot :: Unit bot = bot  a = bot
05:56:53 <merijn> lechip: Then 'a :: Unit"
05:57:07 <lechip> ans it will smeantically mean _|_ right?
05:57:23 <lechip> semantically*
05:58:04 <merijn> Yes
05:58:13 <lechip> ahhh i think i understand now!
05:58:16 <lechip> aseomse
06:00:14 <tac_> merijn: how are both ways not horrific?
06:02:25 <merijn> tac_: Well, pre-7.8 the latter still has some merit in terms of incremental development
06:02:37 <merijn> But this trivial case is horrific regardless :p
06:02:54 <tac_> I'd argue that undefined is horrific always ;o
06:09:25 <haasn> merijn: a = a
06:10:16 <haasn> The most fundamental way I'd say to produce a _|_ is with a = let x = x in x
06:10:58 <haasn> Actually, I wonder what that translates to in Core
06:11:00 <tac_> undefined is nicer in that you can CTRL+f for it and the compiler need not be magical to see it is a bottom
06:11:11 <tac_> (even though GHC is magical)
06:11:38 <awestroke> let bottom = ⊥
06:12:07 <haasn> ah, with Rec { a = x; x = a }
06:12:25 <haasn> It can also do Rec { a = a }, if you just write “a = a”
06:13:01 <haasn> lechip: Of course, it also depends on what you mean by “= to _|_”
06:19:32 <McManiaC> is IO threadsafe in haskell? will it mess up if i have multiple threads wirting with hPut to one handle?
06:19:44 <McManiaC> writing*
06:24:35 <merijn> McManiaC: Define "mess up"
06:24:53 <merijn> McManiaC: Handles have read and write locks, so read and writes are atomic
06:25:21 <McManiaC> ok good
06:29:35 <mbrock> slomo: cool, glad it helped :)
06:38:21 <l4u_c> how do I add auto recompile on scotty?
06:38:38 <anna_> no idea
06:38:46 <anna_> i'm new to scotty too.
06:38:48 <anna_> ;)
06:40:49 <eevar> l4u_c: did you consider snap?
06:42:15 <l4u_c> eevar: yes, i can try snap too. But for some reasons, a recompilation on yesod took 10s.
06:42:42 <l4u_c> So I am checking if it's expected on haskell frameworks, or just yesod (or related libs)
06:46:23 <slomo> mbrock: http://lpaste.net/104941 btw :)
07:10:52 <Ainieco> is it okay to "unsafePerfomIO $ newMVar foo"?
07:11:08 <Ainieco> when my mvar is global for example
07:11:28 <hpc> Ainieco: take a guess from the name ;)
07:11:47 <hpc> you are not guaranteed that you only have one MVar after multiple uses
07:11:59 <tac_> Ainieco: Is it ok to promise your first-born to the devil?
07:12:07 <tac_> I believe the answers to both questions are the same ^^
07:12:12 <hpc> it might decide to re-execute the newMVar, or it might just crash
07:12:19 <Ainieco> ha-ha, got it
07:12:23 <hpc> or it might fire the missles
07:12:47 <hpc> a better idea for "global" variables is ReaderT
07:13:44 <hpc> and then "read" a mutable structure like MVar, tuple of MVars, etc
07:14:47 <hpc> that way, all your stuff stays in IO and the math gods don't smite you down
07:15:25 <tac_> smite and criticise is all we gods can do :<
07:17:39 <mbrock> slomo: that's quite nice!
07:27:38 <Ainieco> scotty question - i want all my actions have access to mvar(reading), how to do it? it's not straight forward for me because scotty action have type ActionM () but readMVar have IO a type
07:28:26 <Ainieco> so it seems i can readMVar inside scotty action
07:28:35 <Ainieco> i can't*
07:28:41 <l4u_c> so if scotty doesn't include auto recompile. what is the workflow?
07:30:40 <Ainieco> l4u_c: at start i'm putting my state into mvar and then all actions should have access to it to be able render somthing. it's not multiuser application, it just provides web interface
07:31:00 <Ainieco> l4u_c: does it make sense?
07:32:19 <mbrock> Ainieco: if ActionM has an instance of MonadIO, then you can use liftIO to run IO actions within an ActionM
07:32:55 <Ainieco> mbrock: thanks, trying that
07:33:15 <edsko> has anyone managed to build a 32-bit version of ghc for OSX?
07:34:14 <mbrock> Ainieco: sometimes very important functionality is "hidden" in class instances. with these important data types, it's often good to browse around the instance lists and see what's available
07:36:08 <Ainieco> mbrock: thank you for tip!
07:54:15 <Raydiation> >> scan + 0 [ 3 1 7 0 4 1 6 3]
07:54:31 <Raydiation> is there an interpreter?
07:54:52 <Saizan> > 1
07:54:54 <lambdabot>  1
07:55:00 <Raydiation> thanks
07:55:03 <Raydiation> > scan + 0 [ 3 1 7 0 4 1 6 3]
07:55:04 <lambdabot>  Not in scope: ‘scan’
07:55:04 <lambdabot>  Perhaps you meant one of these:
07:55:04 <lambdabot>    ‘scanl’ (imported from Data.List),
07:55:04 <lambdabot>    ‘BSC.scanl’ (imported from Data.ByteString.Char8),
07:55:04 <lambdabot>    ‘BSLC.scanl’ (imported from Data.ByteString.Lazy.Char8)
07:55:20 <Ainieco> if i have "foo = newMVar bar" at top level, will it return new MVar each time or only once and then it will return same mvar over and over?
07:55:30 <ReinH> Raydiation: lists need commas between elements
07:55:30 <Raydiation> > scanl + 0 [ 3 1 7 0 4 1 6 3]
07:55:31 <lambdabot>  can't find file: L.hs
07:55:53 <ReinH> infix operators need parens to be treated as values
07:55:54 <copumpkin> > scanl (+) 0 [3, 1, 7, 0, 4, 1, 6, 3] -- probably easier if you know the actual syntax
07:55:56 <lambdabot>  [0,3,4,11,11,15,16,22,25]
07:55:58 <monochrom> new mvar each time
07:56:32 <Ainieco> monochrom: oh, is there a way to "constantize" it?
07:56:39 <monochrom> no
07:57:57 <Raydiation> how do i add an instance declaration for scanl?
07:58:06 <Ainieco> monochrom: got it, so the only way is to have "foo <- newMvar bar" at the main?
07:58:09 <Raydiation> show $ scanl + 0 [ 3, 1, 7, 0, 4, 1, 6, 3] fails in the interpreter
07:58:12 <monochrom> yes
07:58:38 <copumpkin> Raydiation: I literally gave you the syntax that worked!
07:58:57 <copumpkin> if you use that, you won't need an instance declaration
07:59:05 <Raydiation> copumpkin: ty, missed it :)
07:59:20 <copumpkin> :)
08:00:00 <Raydiation> why is the neutral element appended to the list?
08:00:16 <Raydiation> the 0
08:00:40 <Raydiation> is this useful for generic scan algorithms?
08:01:08 <copumpkin> it's just the natural way to write it
08:01:13 <copumpkin> @src scanl
08:01:13 <lambdabot> scanl f q ls = q : case ls of
08:01:13 <lambdabot>     []   -> []
08:01:14 <lambdabot>     x:xs -> scanl f (f q x) xs
08:01:44 <tac_> What's tolower in Haskell again?
08:01:53 <ReinH> :t toLower
08:01:54 <lambdabot> Char -> Char
08:02:13 <tac_> toLower? Good enough
08:02:17 <copumpkin> I think Text might have a whole-Text one that does the weird things
08:02:21 <tac_> crap. I need Text-based one
08:02:38 <copumpkin> toLower :: Text -> Text
08:02:43 <copumpkin> right there in Data.Text
08:03:01 <tac_> ah good
08:03:08 <copumpkin> keep in mind that it might be different from map toLower
08:03:30 <ReinH> it operates on whole strings
08:03:36 <ReinH> rather than characters
08:09:02 <Nujabes> Hi all
08:10:02 <Nujabes> I'm getting a parse error on ghci: http://lpaste.net/104946
08:10:07 <Nujabes> Any help would be appreciated
08:11:35 <monochrom> look at how line 7 is misaligned. fix its alignment.
08:13:06 <Nujabes> Hey monochrom, line 7 is aligned correctly in my editor
08:13:38 <monochrom> not on lpaste, not on ghc. ghc sees what lpaste sees. your editor lies. configure your editor to not lie.
08:13:41 <bergey> avoiding tabs will make it easier to align things the way GHC expects
08:16:02 <Nujabes> I tried again using nano and it worked. Thanks guys!
08:18:33 <awestroke> > let 2+2=5 in 2+2
08:18:35 <lambdabot>  5
08:18:41 <l4u_c> Ainieco: how about recompiling the modified .hs files? should I do a cabal install each time?
08:19:10 <l4u_c> or can I run it via ghci ?
08:19:36 * hackagebot JsonGrammar 1.0 - Combinators for bidirectional JSON parsing  http://hackage.haskell.org/package/JsonGrammar-1.0 (MartijnVanSteenbergen)
08:20:18 <monochrom> there is "cabal build"
08:20:35 <ReinH> Yes
08:20:59 <ReinH> Note that running cabal install after cabal configure and cabal build will just run cabal configure and cabal build again
08:21:23 <monochrom> read my http://www.vex.net/~trebla/haskell/cabal-cabal.xhtml for more secrets
08:21:28 <ReinH> yes that
08:21:51 <ReinH> Most of my work in here is just poorly regurgitating things from monochrom's site
08:22:59 <l4u_c> ok thanks :)
08:25:10 <acar> thanks monochrom, great article :)
08:35:22 <acar> monochrom: is that http://www.vex.net/~trebla/haskell/index.xhtml your site? I found so many great introductory articles.
08:35:30 <monochrom> yes
08:35:37 <monochrom> thank you for choosing monochrom!
08:38:22 <Redz> i have a multiparameter class and one function did not use every parameter. i cant use this function because it cant resolve the unused type. what can i do?
08:38:45 <Ainieco> l4u_c: excuse me?
08:39:53 <Ainieco> is "over" a right function to apply function to field and then set result to field and return new recod?
08:43:05 <Carena18>  Hi! I give you some videos. I hope you like! http://bitly.com/1m3lLH3
08:43:56 <sipa> @where ops
08:43:57 <lambdabot> arjanb bos byorgey Cale conal copumpkin dcoutts dibblego dmhouse dolio dons edwardk elliott geekosaur glguy Heffalump Igloo jmcarthur johnw kosmikus Lemmih monochrom nyc Philippa Pseudonym quicksilver roconnor Saizan shachaf shapr sjanssen ski sorear SyntaxPolice xerox
08:44:05 --- mode: ChanServ set +o copumpkin
08:44:08 --- mode: copumpkin set +b *!~Carena18@67.221.255.55
08:44:08 --- kick: Carena18 was kicked by copumpkin (No. Bad.)
08:44:11 --- mode: copumpkin set -o copumpkin
08:44:13 <copumpkin> thanks sipa
08:45:36 <acar> monochrom: I'm glad that I found your site. Next time when a friend asking for reference in learning Haskell, I'll suggest them your site.
08:53:50 <Pythonfant> Why does (fmap . const) 1 Just 3 work, but fmap . const $ 1 just 3 tells me that a0, a1 are amiguous
08:54:16 <Rembane> 'cause with () you get a new function from fmap . const
08:54:18 <tac_> @type fmap . const
08:54:19 <lambdabot> Functor f => b -> f a -> f b
08:54:28 <haasn> Pythonfant: (fmap . const) 1 Just 3 is (((fmap . const) 1) Just) 3
08:54:36 <tac_> > (fmap . const) 1 Just 3
08:54:37 <hpc> your second version is (fmap . const) (1 Just 3)
08:54:37 <lambdabot>  1
08:54:54 <haasn> Pythonfant: fmap . const $ 1 just 3  is what hpc said, or (fmap . const) ((1 Just) 3)
08:55:06 <Pythonfant> ah ok
08:55:10 <Pythonfant> thx
08:55:23 <haasn> (Guessing you meant “Just”, not “just”)
08:55:37 <Pythonfant> :)
08:55:40 <Pythonfant> yep
09:03:55 <tristanStrange> leH1ll
09:04:19 <tristanStrange> erm excuse me...
09:04:42 * hackagebot eq 4.0.3 - Leibnizian equality  http://hackage.haskell.org/package/eq-4.0.3 (EdwardKmett)
09:04:44 * hackagebot parsers 0.11.0.2 - Parsing combinators  http://hackage.haskell.org/package/parsers-0.11.0.2 (EdwardKmett)
09:08:16 <tristanStrange> does haskell have the golden ratio lurking inside it anywhere?
09:08:31 <hpc> > φ
09:08:32 <lambdabot>  Not in scope: ‘φ’
09:08:34 <hpc> nope
09:08:47 <tristanStrange> not in any of the Math modules?
09:09:11 <tristanStrange> if such a thing exists... whats the best module reference to use?
09:09:13 <iota_> > (1.0 + sqrt 5.0) / 2.0 -- ?
09:09:15 <lambdabot>  1.618033988749895
09:09:29 <tristanStrange> where do you guys find your documentation?
09:09:38 <tristanStrange> cheers iota
09:10:44 <edwardk> > let fibs = 1:1:zipWith (+) fibs (tail fibs) in zipWith (/) (tail fibs) fibs !! 100
09:10:45 <lambdabot>  1.618033988749895
09:10:51 <edwardk> checks out
09:11:54 <acar> edwardk: nice :)
09:15:01 <tromp> > (iterate (\r -> 1+1/r) 1.0 ) !! 100
09:15:03 <lambdabot>  1.618033988749895
09:15:30 <tac_> @type iterate
09:15:30 <tromp> checks out
09:15:31 <lambdabot> (a -> a) -> a -> [a]
09:16:06 <tac_> > iterate sqrt 0.99
09:16:08 <lambdabot>  [0.99,0.99498743710662,0.9974905699336811,0.9987444968227265,0.9993720512515...
09:16:20 <tac_> err, wrong way I guess
09:16:23 <tac_> > iterate sqrt 0.5
09:16:24 <lambdabot>  [0.5,0.7071067811865476,0.8408964152537146,0.9170040432046712,0.957603280698...
09:17:06 <haasn> tristanStrange: Hayoo and hoogle, usually
09:17:13 <haasn> More the former than the latter for me
09:17:22 <edwardk> tromp: nice one
09:17:35 <tristanStrange> cheers haasn I'll take a look
09:17:35 <heatsink> @let fix f = iterate f 1.0 !! 1000
09:17:37 <haasn> Well, that covers the “finding” bit; if you know the package name on hackage you can just look up its documentation there
09:17:37 <lambdabot>  Defined.
09:17:43 <heatsink> > fix (1 + 1/r)
09:17:45 <lambdabot>  Ambiguous occurrence ‘fix’
09:17:45 <lambdabot>  It could refer to either ‘L.fix’, defined at L.hs:157:1
09:17:45 <lambdabot>                        or ‘Data.Function.fix’,
09:17:45 <lambdabot>                           imported from ‘Data.Function’ at L.hs:79:1-20
09:17:58 <heatsink> aww
09:18:00 <ReinH> fix is already a thing
09:18:03 <ReinH> @unlet
09:18:03 <lambdabot>  Define what?
09:18:23 <haasn> Ha, that gets completed to @let
09:18:37 <ReinH> :/
09:18:37 <heatsink> @help undefine
09:18:38 <lambdabot> undefine. Reset evaluator local bindings
09:18:50 <haasn> @untype Data.Function.fix
09:18:51 <lambdabot> (a -> a) -> a
09:19:09 <heatsink> @help unlet
09:19:09 <lambdabot> help <command>. Ask for help for <command>. Try 'list' for all commands
09:19:22 <haasn> @unslap ReinH
09:19:22 * lambdabot activates her slap-o-matic...
09:19:28 <ReinH> ...
09:19:30 <haasn> no, no, coactivate it!
09:19:39 <heatsink> @unhelp
09:19:39 <lambdabot> help <command>. Ask for help for <command>. Try 'list' for all commands
09:20:56 <Pythonfant> Apparently I'm again too stupid for haskells type system. Why is liftM2 id valid and why does it have this type. liftM2 takes a function that takes two arguments but id takes only one.
09:21:10 <haasn> :t id
09:21:11 <lambdabot> a -> a
09:21:17 <haasn> Pythonfant: ‘a’​ can be anything, for example ‘b -> c’
09:21:28 <c_wraith> what makes you think id only takes one argument?
09:21:32 <haasn> resulting int: id :: (b -> c) -> b -> c
09:21:39 <haasn> :t liftM2
09:21:40 <lambdabot> Monad m => (a1 -> a2 -> r) -> m a1 -> m a2 -> m r
09:21:43 <c_wraith> > id (+) 1 2 -- id takes 3 arguments
09:21:45 <lambdabot>  3
09:21:54 <haasn> Pythonfant: letting a1 = (b -> c); a2 = b and r = c, this gives us
09:22:03 <haasn> liftM2 id :: m (b -> c) -> m b -> m c
09:22:19 <Pythonfant> ah right
09:22:22 <Pythonfant> thx
09:22:51 <c_wraith> Pythonfant: note that ($) and id are the same function.  ($) just has a more restricted type.
09:23:27 <Pythonfant> and id is not right associative, right?
09:24:31 <awestroke> > take 10 . filter (/= 5) . map (+3) `id` [1..]
09:24:32 <lambdabot>  Precedence parsing error
09:24:32 <lambdabot>      cannot mix ‘GHC.Base..’ [infixr 9] and ‘GHC.Base.id’ [infixl 9] in the s...
09:28:41 <Ainieco> anyone familiar with "websockets" library around? how to properly handle client disconnection?
09:29:35 <carter> websocket is via http
09:29:46 * hackagebot free 4.8.0.1 - Monads for free  http://hackage.haskell.org/package/free-4.8.0.1 (EdwardKmett)
09:29:48 <carter> so even though its message oriented, you;'ll know when its not connected
09:29:49 <carter> afaik
09:31:31 <Ainieco> carter: when i'm trying to send something to closed conenction i'm getting "send: resource vanished (Broken pipe)" so i'd like to handle it somehow, not sure how tho
09:31:45 <Ainieco> i don't see any "close" functions for connection
09:32:13 <c_wraith> if you get that message, the connection is already closed
09:32:30 <c_wraith> All you need to do is cleanup in-process
09:33:04 <Ainieco> c_wraith: what do you mean by "cleanup in-process"?
09:33:44 <c_wraith> Ainieco: if you've allocated any local resources that aren't GC'd..  Any open files, graphics contexts, whatever
09:34:02 <Ainieco> c_wraith: ah, i see, thanks!
09:34:42 <Ainieco> c_wraith: is there any way to suppress that message?
09:34:46 * hackagebot free 4.9 - Monads for free  http://hackage.haskell.org/package/free-4.9 (EdwardKmett)
09:35:11 <c_wraith> Ainieco: catching the exception would suppress it.
09:35:44 <Ainieco> gotcha
09:39:26 <klrr_> how do i get sane indentation in haskell-mode? seriously the tab is aligning my cursor at the next constructor not under the =...
09:40:12 <ReinH> klrr_: use spaces
09:40:23 <ReinH> ah, never mind
09:44:47 * hackagebot either 4.3 - An either monad transformer  http://hackage.haskell.org/package/either-4.3 (EdwardKmett)
09:45:21 <Ainieco> how to catch exception inside "forever" and stop it? tried "catch . forever $ do" but got "Couldn't match expected type ‘IO ()’ with actual type ‘(e0 -> IO a0) -> IO a0’"
09:45:52 <coppro> :t catch
09:45:53 <lambdabot> Exception e => IO a -> (e -> IO a) -> IO a
09:45:54 <coppro> :t forever
09:45:55 <lambdabot> Monad m => m a -> m b
09:46:24 <coppro> Ainieco: You forgot to put a catch handler in
09:47:38 <Ainieco> coppro: ah, thanks
09:51:24 <Ainieco> why does (\(_ :: WS.ConnectionException) -> return ()) requires ScopedTypeVariables extension? i don't see anything facy about specifying function argument type explicitly..
09:51:34 <Ainieco> fancy*
09:54:49 * hackagebot attoparsec-expr 0.1.1.1 - Port of parsec's expression parser to attoparsec.  http://hackage.haskell.org/package/attoparsec-expr-0.1.1.1 (AdamBergmark)
09:55:17 <Ainieco> c_wraith: hm this actually doesn't suppresess "broken pipe" message:      WS.runServer "0.0.0.0" 9160 $ (flip catch (\(_ :: WS.ConnectionException) -> return ()) . websockets)
09:55:41 <Ainieco> c_wraith: what i'm doing wrong?
09:59:26 <geekosaur> Ainieco, you may need to trap / ignore a signal instead
10:00:09 <geekosaur> "broken pipe" could be an EPIPE OS error reflected as a Haskell exception... but it could also be the shell telling  you the program was killed by SIGPIPE
10:00:31 <geekosaur> if you ignore SIGPIPE using the POSIX signal facilities, you should be able to trap the exception
10:04:50 * hackagebot aeson-utils 0.2.2.1 - Utilities for working with Aeson.  http://hackage.haskell.org/package/aeson-utils-0.2.2.1 (AdamBergmark)
10:04:52 * hackagebot generic-aeson 0.1.0.3 - Derivation of Aeson instances using GHC generics.  http://hackage.haskell.org/package/generic-aeson-0.1.0.3 (AdamBergmark)
10:05:36 <Ainieco> geekosaur: just curious if that error is unhandled how can it affect haskell program? is it dangerous?
10:05:36 <Ainieco> geekosaur: as i understand you're saying that it's impossible to handle it from haskell, right?
10:05:56 <geekosaur> it is possible to handle it, if you ignore the signal
10:06:13 <tac_> generally, an unhandled error is just going to crash the program
10:06:27 <Ainieco> geekosaur: sorry but how can i ignore that signal?
10:06:48 <Ainieco> tac_: yeah but this is not the case, it just gives me a message and continues to work
10:06:54 <geekosaur> http://lambda.haskell.org/platform/doc/current/ghc-doc/libraries/unix-2.6.0.1/System-Posix-Signals.html
10:07:06 <geekosaur> ...huh, then it's not the signal
10:07:12 <Lily18>  Here some videos. I hope you like them! http://j.mp/RTQEFK
10:07:25 <geekosaur> that was fast :)
10:09:02 <Ainieco> geekosaur: when i'm closing browser which was connected to haskell websockets - i see "executable-name: send: resource vanished (Broken pipe)" in console, thats all. i still can reconect to webscokets just fine
10:09:50 * hackagebot rest-gen 0.13.1.1 - Documentation and client generation from rest definition.  http://hackage.haskell.org/package/rest-gen-0.13.1.1 (AdamBergmark)
10:10:10 <geekosaur> ok, that would be the exception and not the signal
10:11:03 <geekosaur> not sure I can help beyond that, I don't work with websockets (or web stuff in general)
10:11:30 <Ainieco> geekosaur: no problem, thanks anyway!
10:17:10 <McManiaC> why can't i write this? http://npaste.de/p/kx6W/
10:17:22 <McManiaC> i get the error
10:17:22 <McManiaC>     Expecting one more argument to ‘StreamT (First String) m’
10:17:22 <McManiaC>     Expected a type, but ‘StreamT (First String) m’ has kind ‘* -> *’
10:18:55 --- mode: ChanServ set +o monochrom
10:19:20 --- mode: monochrom set -b+b *!~Carena18@67.221.255.55 *!~*18@67.221.255.*
10:19:29 --- mode: monochrom set -o monochrom
10:20:28 <monochrom> on the right hand side of "=>", must have kind *
10:21:10 * haasn .oO(  (=>) :: Constraint -> * -> *  )
10:21:12 <haasn> :k (=>)
10:21:13 <lambdabot> parse error on input ‘=>’
10:21:22 <haasn> Shame
10:23:51 <qrada> anyone know if HFuse is still maintained? the github url on the hackage page no longer exists.. It fails to build in my ghc 7.8 environment. Are there any other haskell rivals to hfuse for fusefs?
10:24:25 <awestroke> Is this a sane definition of a generalized map_reduce? http://lpaste.net/5005032936009891840
10:24:34 <awestroke> type declaration* not definition
10:25:22 <ReinH> :t foldMap
10:25:22 <Ainieco> awestroke: isn't map reduce is just fold . map ?
10:25:23 <lambdabot> (Monoid m, Foldable t) => (a -> m) -> t a -> m
10:25:31 <glguy> I wouldn't expect the result to be a list
10:25:39 <tac_> Are there any conditions imposed on Foldable?
10:26:05 <tac_> Or is it simply a dedicated map T a -> [a] for a type constructor T?
10:26:37 <awestroke> Ainieco: that's sequential. the whole point of map reduce is the ability to parallelize it
10:27:52 <Polarina> I'm attempting to update one of my projects from using JuicyPixels 2.0 to 3.1, and I've had to update some parts of it. One part however, dealing with the comparison of images, became even more trickier to do.
10:27:54 <Polarina> Is there a smarter way to do what I'm doing here: http://codepad.org/dzE7XGng ?
10:28:01 <Ainieco> awestroke: parFoldl . parMap
10:28:28 <awestroke> :t parFoldl . parMap
10:28:29 <lambdabot> Not in scope: ‘parFoldl’
10:28:29 <lambdabot>     Not in scope: ‘parMap’
10:28:29 <lambdabot>     Perhaps you meant ‘para’ (imported from Control.Lens)
10:28:32 <ReinH> fold . map = foldMap
10:28:37 <ReinH> foldMap can be easily parallelized
10:29:30 * Ainieco thinks that "map reduce" as single buzzword was invented by java/hadoop bs
10:29:54 <awestroke> can foldMap trivially be parallelized across machines?
10:30:06 <ReinH> No. Can yours?
10:30:10 <awestroke> ReinH: yes!
10:30:18 <jmcarthur> Polarina: are you even sure that does what you want?
10:30:20 <ReinH> awestroke: where does it define network transport?
10:30:25 <ReinH> If yours can then so can foldMap
10:30:27 <pjdelport> awestroke: That looks like a reasonable type signature for MapReduce, yeah
10:30:36 <jmcarthur> Polarina: it looks like it's just doing a pointer equality to me, rather than what i would expect which is a value comparison
10:30:53 <awestroke> ReinH: On second thought, the return would be in IO
10:30:55 <jmcarthur> Polarina: that said, the lack of an Eq a constraint on either instance is suspicious to me
10:31:08 <Polarina> jmcarthur, occasional false positives are all right for what my code is doing.
10:31:09 <awestroke> pjdelport: thanks
10:31:10 <ReinH> fsvo trivially, it certainly can
10:31:22 <jmcarthur> Polarina: it would be false negatives though
10:32:08 <ReinH> The mapping can obviously be parallelized and the folding can be parallelized due to the monoidal structure.
10:32:30 <ReinH> doing so on multiple machines is a networking problem, not an algorithm design problem
10:32:46 <Polarina> jmcarthur, what I mean is that, two identical pictures equaling to false is all right for my code, it behaves correctly. Non-identical pictures comparing equal would be a problem.
10:32:52 <pjdelport> awestroke: I think your final result may have to be [(k2, v2)], rather than [(k2, v3)]
10:33:10 <Polarina> jmcarthur, I'm doing the comparison to save tons of additional work, so always assuming it's a new picture would kill performance.
10:33:20 <jmcarthur> Polarina: in any case, even if it works out okay for your particular use case, in general i am unhappy with being able to disinguish values which should otherwise be the same. i suppose these are orphan instances though?
10:33:40 <Polarina> jmcarthur, these are orphan instances, yes.
10:33:57 <jmcarthur> let me take a look at the new juicypixels types
10:34:29 <ReinH> you might actually say that foldMap is the essence of the map/reduce pattern
10:34:42 <pjdelport> awestroke: I'm not 100% sure if the reduce step can change the result type, or if they have to be homogeneous
10:34:45 <jmcarthur> Polarina: why the unsafeCoerce?
10:34:53 <awestroke> ReinH: That's just not true
10:35:20 <ReinH> awestroke: Well, it's widely regarded to be true, so I'm interested in why you think it isn't.
10:35:24 <awestroke> pjdelport: hmm. Yeah... Will have to investigate
10:35:33 <Polarina> jmcarthur, unsafeCast from Data.Vector.Storable complained about PixelBaseComponent not having a Storable instance.
10:36:00 <pjdelport> ReinH: MapReduce is a bit more specific; it's only foldMap if you ignore enough details. :)
10:36:04 <awestroke> ReinH: MapReduce has little to do with fold . map, it's a way to distribute work so that each reducing process has all the data it needs
10:36:14 <jmcarthur> Polarina: couldn't you just put a (Storable (PixelBaseComponent a)) constraint on the instance?
10:36:33 <ReinH> pjdelport: that's why I said it was the essence of map/reduce, not that it was equivalent
10:36:39 <jmcarthur> Polarina: in fact, if you do that, shouldn't it just be trivial to use the old code?
10:36:56 <dshad> can anyone explain why simple parser freezes? http://lpaste.net/104947
10:37:52 <jmcarthur> for that matter, i don't know how the old code worked without at least  (Storable (PixelBaseComponent a), Eq (PixelBaseComponent a)) =>
10:38:22 <jmcarthur> oh, JuicyPixels <2 didn't have that type family
10:38:25 <jmcarthur> it was just Word8
10:38:31 <Polarina> jmcarthur, adding a Storable constraint does not work, as some components do not seem to have that instance. { No instance for (Storable PixelRGBA8) }
10:38:42 <ReinH> MapReduce is a way of distributing the work done by foldMap
10:38:43 <jmcarthur> interesting. even 2.0 had that
10:39:24 <jmcarthur> Polarina: disgusting!
10:39:36 <Polarina> I know. :(
10:39:36 <jmcarthur> Polarina: clearly the right way to do this is to submit a patch to the maintainer :)
10:40:08 <jmcarthur> Polarina: the maintainer takes pretty good care of this package and should be pretty responsive
10:40:41 <monochrom> dshad: I am confused. how can "Parser $ Right" even have a type?
10:40:54 <monochrom> err nevermind, I see now
10:40:59 <Polarina> jmcarthur, I'll see if I can poke him.
10:41:45 <ReinH> And the monoidal structure of foldMap provides you with a way of doing the distribution correctly
10:41:53 <Polarina> jmcarthur, here's the code in question, if you're interested however. https://bitbucket.org/gunnii/implvz-client/src/ec42cb2f0aa0c481e73ddcaa7ea7d61958b9c970/Game/Implvz/Protocol.hs?at=master
10:42:05 <ReinH> so MapReduce definitely has more than a little to do with foldMap
10:42:50 <jmcarthur> Polarina: stylistically, i wouldn't use Eq for what you're doing, but would instead define an  unsafeIsSameImageInHeap  function
10:44:40 <jmcarthur> Polarina: or perhaps even putting it into IO so it doesn't have to be unsafe at all
10:45:45 <Polarina> jmcarthur, probably not a bad idea.
10:50:01 <monochrom> dshad: change "data" to "newtype". it matters.
10:51:42 <dshad> monochrom: why does it matter?
10:52:24 <c_wraith> Things created with data have constructors at runtime.  Things created with newtype don't
10:52:26 <monochrom> many factors accumulate to contribute to non-termination. you can break any one of them and re-gain termination.
10:52:45 <monochrom> factor #1 is you said "data".
10:53:58 <monochrom> factor #2 is you said "(Parser p2) . (Parser p1) = ..." meaning that the 1st argument is first evaluated until the ctor is seen. the 2nd argument is not even considered until after.
10:54:23 <hsnoob> hey guys
10:54:48 <monochrom> factor #3 is "recursiveParser = recursiveParser . whatever" meaning that recursiveParser is the 1st argument
10:55:15 <hsnoob> I could use a few pointers to understand what I need to do for this assignment
10:55:33 <monochrom> so now the computer has to keep expanding recursiveParser until the ctor is seen. that will never happen.
10:55:48 <hsnoob> I have a class such as class Seq s where    emptyS     :: s a
10:56:07 <hsnoob> and I need to implement an instance for arbitrary lists, so I did instance Seq [] where
10:56:27 <hsnoob> but I'm not understanding how can I actually use it after that
10:56:27 <dshad> monochrom: thx
10:56:36 <hsnoob> any pointers on what to read will be appreciated :)
10:57:00 <monochrom> I change "data" to "newtype" so that there is no ctor to talk about. then it is as though you wrote "p2 . p1 = \x -> p1 x >>= p2" which will cause no problem
11:00:11 <monochrom> alternatively "~(Parser p2) . (Parser p1) = Parser (\x -> p1 x >>= p2)" postpones figuring out the 1st argument so the computer goes ahead with the 2nd argument
11:01:09 <matheus23> I somehow can't $ cabal install Vec because of type errors. "The literal coverage condition fails in class 'SetDiagonal' for functional dependency: 'm -> v'"
11:03:34 <monochrom> hsnoob: the empty list is a great candidate for emptyS
11:04:07 <hsnoob> monochrom: yes, that I can do
11:04:13 <hsnoob> monochrom: my problem is then using it
11:04:40 <pqmodn_> length emptyS == 0
11:04:46 <monochrom> "emptyS ++ [True, False]" will give you [True, False]
11:04:52 <dshad> monochrom: is there any way to break factor 2?
11:04:57 <ycomb> what is a multichocie game called, trivia or quiz?
11:05:04 <monochrom> yes, I just said how recently
11:05:08 <ycomb> like one question, four choices, one right answer
11:05:33 <dshad> monochrom: is there any way to break factor 2?
11:05:51 <monochrom> did you see what I said about ~(Parser p2) ?
11:06:39 <hsnoob> http://sprunge.us/DJLT
11:06:49 <hsnoob> hopefully that makes my woes more understandable
11:07:13 <monochrom> let x = emptyS :: [Int]
11:07:47 <roconnor> Another way of breaking factor two is x . y = Parser (\x -> let (Parser p1) = x in p1 x >>= let (Parser p2) = y in p2
11:08:12 <hsnoob> monochrom: ah, I need to use the type and not the instance
11:08:14 * hsnoob headdesks
11:08:15 <pqmodn_> hsnoob: Seq is not a type, it doesn't have values as inhabitants
11:08:18 <hsnoob> thanks monochrom
11:09:22 <monochrom> I thought of using so many "let"s. at the end I realized that it's what ~ is for.
11:09:49 <roconnor> :)
11:09:51 <roconnor> fair
11:09:52 <dshad> thx guys
11:09:57 * hackagebot DiscussionSupportSystem 0.11.0.2 - Discussion support system  http://hackage.haskell.org/package/DiscussionSupportSystem-0.11.0.2 (minamiyama1994)
11:09:59 * hackagebot DiscussionSupportSystem 0.11.0.3 - Discussion support system  http://hackage.haskell.org/package/DiscussionSupportSystem-0.11.0.3 (minamiyama1994)
11:10:02 <johnw> the first time you really need ~ is a special time
11:10:33 <awestroke> :t (~)
11:10:34 <lambdabot> parse error on input ‘)’
11:10:37 <johnw> it's syntax
11:10:43 <johnw> foo ~(a, b) = b
11:10:50 <monochrom> I suppose there is merit in non-stricting the 2nd argument too. ~(Parser p1) . ~(Parser p2) = ...
11:10:51 <johnw> is equivalent to foo = snd
11:10:57 <awestroke> oh, lazy pattern matching?
11:11:00 <johnw> yeah
11:11:44 <roconnor> I remember once I replaced _ <- foo with () <- foo and it blew up my program :D
11:11:51 <monochrom> hehe
11:12:10 * monochrom ♥ nonstrictness and laziness
11:12:41 <jamie_h> can someone help me with 1.2 of http://www.seas.upenn.edu/~cis194/hw/04-higher-order.pdf
11:13:19 <jamie_h> I'm struggling to think of a suitable (a -> a) for `iterate'
11:13:30 <nisstyre> (+1) ?
11:14:19 <monochrom> what does "1.2" mean there?
11:14:32 <jamie_h> Exercise 1, question 2
11:15:03 <nisstyre> oh I see what your question is
11:15:06 <jamie_h> i.e. converting fun2 to point-free syntax
11:15:11 <nisstyre> jamie_h: well it just suggests using iterate
11:15:18 <nisstyre> you don't have to afaict
11:15:38 <nisstyre> is this the collatz sequence btw?
11:15:58 <yitz> jamie_h: write a non-recursive function that does the arithmetic transformation once
11:16:13 <roconnor> nisstyre: this function is returning the sum of all the even elements found in a collatz sequence.
11:16:19 <yitz> nisstyre: it is
11:16:23 <monochrom> is "fun2 = const 0" acceptable? :)
11:16:37 <yitz> @slap monochrom
11:16:38 * lambdabot decomposes monochrom into several parts using the Banach-Tarski theorem and reassembles them to get two copies of monochrom!
11:16:38 <jamie_h> yitz so use `iterate` to do the arithmetic?
11:16:41 <nisstyre> monochrom: maybe
11:16:56 <monochrom> I want two copies of monochrom too.
11:17:02 <roconnor> jamie_h: in fact, "this function is returning the sum of all the even elements found in a collatz sequence" basically tell you how to break your implementation into wholemeal programming.
11:17:06 <yitz> jamie_h: no write a non-recursive function to do the arithmetic. use iterate to repeat it many times.
11:17:25 <yitz> infinitely many times in fact
11:17:48 <monochrom> jamie_h: I want you to consider this alternative question. what list do you want to produce?
11:17:52 <yitz> then use takeWhile to take just the iterations you want off the front of the infinite list.
11:18:01 <aostiles> I'm trying to make my own custom GhcMonad (http://www.haskell.org/platform/doc/2013.2.0.0/ghc-api/GhcMonad.html#t:GhcMonad) but am having trouble making it an instance of ExceptionMonad (http://www.haskell.org/platform/doc/2013.2.0.0/ghc-api/Exception.html#t:ExceptionMonad). Has anyone had experience with this sort of thing?
11:18:08 <roconnor> jamie_h: (a) use iterate to make a collatz sequence (b) use takewhile to terminate the sequence at 1, (c) get all the even numbers, (d) add them up.
11:18:27 <monochrom> but roconnor has answered my question by (a)
11:18:35 <roconnor> sorry
11:19:05 <monochrom> don't worry. just maximizing re-use.
11:19:08 <ycomb> @type (~)
11:19:09 <lambdabot> parse error on input ‘)’
11:19:14 <ycomb> @type ~
11:19:15 <lambdabot>     parse error (possibly incorrect indentation or mismatched brackets)
11:19:29 <monochrom> ~ has no type. it's punctuation
11:19:34 <yitz> ycomb: it's pattern matching syntax
11:20:41 <monochrom> ~ is not covered in most tutorials. the only tutorial is A Gentle Introduction. even then, it is not explained in detail
11:21:00 <monochrom> at the end, I relied on the Haskell 2010 Report
11:22:44 <joelteon> @kind (~)
11:22:45 <lambdabot> k -> k -> Constraint
11:23:04 <yitz> monochrom: the first thing i ever read about haskell was the "gentle" introduction. i then knew formally what ~ was but had no idea how and why it really worked. the next thing i read was the report - after which i actually understood it.
11:23:06 <monochrom> that is not kind
11:23:51 <yitz> monochrom: so to speak
11:24:04 <roconnor> translating algorithms to wholemeal programming is actually a quite difficult task, and I do it a lot.
11:24:08 <monochrom> "that is not kind" refers to "@kind (~)" :)
11:24:36 <roconnor> It seems to be best to (1) take the written algorithm and write down in English what it is trying to do.
11:24:58 <roconnor> (2) Take the English description; ignore the code, and implement it in Haskell.
11:25:02 <joelteon> monochrom: what do you mean
11:25:18 <monochrom> it's a pun
11:25:24 <joelteon> oh, ok
11:25:32 <d3lxa> MultiMap has no Monoid instance, why is that so? is there an alternative?
11:26:41 <yitz> d3lxa: that's weird. why shouldn't it have a Monoid instance?
11:27:07 <d3lxa> (you mean should it have?)
11:27:38 <yitz> d3lxa: sure why not? unless i'm missing something.
11:27:38 <monochrom> yitz: some exercises in http://lpaste.net/100588 :)
11:27:39 <joelteon> no, why doesn't it
11:27:45 <joelteon> is what yitz is asking
11:27:49 <joelteon> is there a reason for it
11:28:18 <d3lxa> yitz: I was using Map with foldMap and noticed a single value per key is allowed, I switched to MultiMap, but there is no Monoid
11:29:44 <yitz> monochrom: ah that explains the use of the tilde for this. it looks like a rollercoaster track.
11:30:00 * hackagebot directory-layout 0.7.1.0 - Directory layout DSL  http://hackage.haskell.org/package/directory-layout-0.7.1.0 (MatveyAksenov)
11:31:44 <yitz> d3lxa: imho you should request one from the library author
11:32:19 <d3lxa> yitz: maybe I'm missing something https://hackage.haskell.org/package/multimap-1.2.1/docs/Data-MultiMap.html ?
11:36:32 <yitz> d3lxa: you're not missing something. that container type is missing something. not just Monoid - how about Functor, Eq, Ord, Show, Read, Foldable, NFData?
11:37:04 <d3lxa> yitz: isn't there an alternative full-fledge then?
11:37:19 <yitz> d3lxa: perhaps you're better off just using Map k (Set a)
11:37:47 <d3lxa> yitz: then foldMap won't work as expected because the Monoid instance does not call the inner Monoid mappend
11:38:13 <benzrf> NFData?
11:38:22 <yitz> d3lxa: ah. too bad.
11:38:32 <pqmodn_> d3lxa: newtype MyMultiMap k a = MyMultiMap (Map k (Set a))
11:38:34 <yitz> d3lxa: you might have to just newtype it then.
11:38:44 <pqmodn_> then define your own monoid, or define one for MultiMap instead
11:38:44 <yitz> benzrf: from the deepseq package
11:39:02 <d3lxa> yeah I see :)
11:39:24 <yitz> d3lxa: also you have to watch out for filling up your Map with empty sets.
11:39:56 <yitz> d3lxa: you really need Map k (NonEmptySet a)
11:39:58 <d3lxa> yitz: that's where I could just define my Monoid for MultiMap :) (for now I get Failed to load interface for `M' when I try to)
11:40:45 <yitz> d3lxa: you could actually use Map k (Data.List.NonEmpty.NonEmpty a) if you know that there won't be very many inhabitants of any given bucket.
11:41:41 <yitz> d3lxa: yes that's another way to go. i'm wondering though how much investment there was in this module given all the basic things that are missing.
11:42:10 <yitz> d3lxa: try emailing the author about all these things.
11:42:58 <ashnur> hi.  what’s the most high-profile application using haskell
11:43:00 <ashnur> ?
11:43:09 <ashnur> just being curious here. someone said it's pandoc
11:43:58 <benzrf> ashnur: i wouldve gone with xmonad
11:44:04 <benzrf> i do not know of pandoc
11:44:14 <geekosaur> depends on who you ask, really. pandoc, xmonad, yesod, git-annex come to mind
11:44:48 <ashnur> thanks, i was curious what else might be there
11:45:33 <platz> I think it's used in finance a lot where the application's aren't public
11:45:55 <yitz> ashnur: if you go with user base, then probably stuff that they are doing at facebook. but not much of the details are publicly know.
11:46:12 <d3lxa> geekosaur: git-annex?
11:47:00 <yitz> ashnur: anyway, the real answer is: the one you're about to write.
11:47:25 <ashnur> tbh, i was expecting much more :)
11:47:37 <zomg> we had a backend service running some things that were supporting something we ran on Mashable
11:47:39 <geekosaur> https://git-annex.branchable.com/ https://github.com/joeyh/git-annex
11:47:48 <zomg> I'd say that's reasonably high profile although nobody ever knew there was something running Haskell in the background
11:47:51 <zomg> :P
11:47:53 <ashnur> i mean it's quite an old language
11:47:55 <geekosaur> complicated by the fact that.. yes
11:48:15 <geekosaur> people use pandoc and git-annex without any realization they're in haskell. which in some ways is ideal and in others is unfortunate
11:48:39 <platz> http://www.haskell.org/haskellwiki/Haskell_in_industry
11:48:44 <hunt> what do you guys use for syntax highlighting in vim? i find the default to be kind of lackluster
11:48:47 <yitz> ashnur: most of that time it was a research language. it transitioned to a language used in industry only over the past couple of years.
11:49:07 <zomg> hunt: I think I just grabbed something that came up on top on google for 'vim haskell' :P
11:49:12 <zomg> seems to work good enough for me
11:49:27 <hunt> zomg: the stuff ive got barely highlights anything, you think you could get a link?
11:50:05 <zomg> I'll check my scripts dir and see if the files have any indication of what they are
11:50:11 <ashnur> yitz: i see, so I shouldn't count all of it's lifetime the same way
11:50:20 <hunt> zomg: thanks dude
11:50:55 <wolverian> vim2hs is nice
11:52:28 <zomg> hunt: looks like it's this https://github.com/wlangstroth/vim-haskell but it hasn't been updated in a while, so there might be better ones out there by now
11:54:16 <joeyh> geekosaur: can I just say how weird it is to have my code in that set? (tis my first haskell program after all, with attendant warts)
11:54:52 <geekosaur> indeed. but it definitely gets used
11:55:21 <geekosaur> for example at least 2 articles about it aggregated by planet freenode
11:56:21 <geekosaur> xmobar might also count as a stealth app --- people tend to think of it as being tied to xmonad, but in fact it gets a fair amount of use with all the minimalist window managers
11:57:00 <joeyh> well, 1st program after http://joeyh.name/blog/entry/haskell_baby_steps/
11:57:19 <jamie_h> yitz roconnor I came up with:  fun2' x = sum $ takeWhile (>0) $ filter even $ iterate collatz x
11:58:48 <jamie_h> idk if that's better or not for point-free syntax
11:59:52 <geekosaur> (as far as first programs go, there are *still* people running my first serious program --- apparently it's the undergrad bboard at the university of manchester. heavily modified of course; the world has changed a lot since 1985...)
12:00:55 <ashnur> yitz: btw, i would most definitely try to write something with haskell, if it wouldn't be so damn hard :)
12:01:09 <benzrf> j
12:01:20 <tommd> In the world of image processing: I desire to get the contours of a binary image using Repa.  It would be nice if I didn't have to implement a connected component analysis myself - does anyone knowledgeable of the Repa world have pointers to a code base for such operations?
12:01:50 <warpy> so which editor/ide do people here use for haskell?
12:02:04 <yitz> ashnur: it's actually not hard. people who learn it as their first language, as at many unis today, have no trouble. it's forgetting a lot of what you knew before that is hard.
12:02:07 <tommd> I ask in part for programmer efficiency but more due to the inefficiency of most my image processing repa code.
12:02:40 <platz> warpy: vim or emacs typically.  there are some some use sublime-text, or have tried the eclipseFP plugin, but i haven't tried them
12:02:50 <ashnur> yitz: i don't have too much to forget. although i worked with probably the worst popular languages there are (php/js)
12:03:00 <tommd> warpy: Most people I know in person use vim.  Some use emacs.  Online, I've heard of people using leksah and a few others (sublime).
12:03:16 <warpy> platz: i have been using sublime but with my project getting bigger, i am struggling more and more
12:03:23 <yitz> jamie_h: i'm not sure you can factor out the sum. the original recursive version feeds the partial sum back into itself for even numbers.
12:03:36 <ashnur> yitz: tbh, haskell is very nice and easy up until the point where it starts to be about category theory and all the type stuff
12:04:01 <yitz> jamie_h: but that's great style though, yes.
12:04:06 <warpy> ashnur: you dont need to know those to write most of haskell things
12:04:18 <platz> warpy: I would probably be a big sublime user if I found out about it earlier, but I'd already been converted
12:04:34 <platz> sublime pretty snappy
12:04:38 <warpy> platz: tommd: looks like i'll have to learn vim now
12:04:39 <serutsubi> I installed some haskell-plugins and now vim uses tabs instead of spaces. Anyone had similar problems?
12:04:39 <platz> "is"
12:04:41 <yitz> ashnur: i think you would really enjoy haskell. give it a try.
12:04:44 <benzrf> sublime is dum
12:04:48 <benzrf> vim is da shit
12:05:03 <benzrf> ashnur: >implying u need to know category theory to understand monads
12:05:06 <benzrf> ashnur: do you know C?
12:05:09 <ashnur> warpy: i don't aim for "most" things. that's somehow never a thing I care about. i usually write things which have a very specific niche and there are very few people who care about it
12:05:11 <platz> benzrf: lol, can't really disagree
12:05:14 <benzrf> ashnur: have you ever written asm?
12:05:14 <warpy> platz: it is difficult to use sublime if you project has more than 20 files and 1000 sloc
12:05:25 <zomg> ashnur: I don't know anything about category theory and I'm decent in haskell =) wouldn't worry too much about that stuff
12:05:36 <ashnur> yitz: i already tried, but i had to give up because i didn't feel i was progressing with it.
12:05:37 <StoneCypher4k> warpy: lol no it isn't
12:05:52 <yitz> jamie_h: to make it more "combinator style" (which happens to be also point-free in this case), change all of the $ to . and omit the x on both sides of the equation.
12:05:58 <warpy> StoneCypher4k: how? i find navigating between files very difficult
12:05:58 <ashnur> yitz: i will probably try it again some time in the near future, but I don't even know how to start it
12:06:00 <platz> warpy: why, is it just a plugin that is scanning the whole project or sublime itself?
12:06:00 <jamie_h> yitz not sure what you mean about "factor out the sum". it seems to work, but the rest of the list will be filled with 0s. is it safe to work with infinite lists like this?
12:06:07 <ashnur> benzrf: no, and I don't want to
12:06:11 <yitz> jamie_h: yes
12:06:16 <ashnur> benzrf: that's an answer to both c & asm
12:06:40 <benzrf> fft
12:06:45 <yitz> jamie_h: you checked that it always gives the same answer?
12:06:47 <benzrf> ashnur: have you done arithmetic
12:06:51 <StoneCypher4k> warpy: I don't know any way to respond to "how?" regarding your assertion.  if you said the moon was made of cheese, and i said "lol no it isn't," and you said "how?", i would be similarly reduced to the inability to answer because of the preposterousness of the question.
12:06:54 <benzrf> ashnur: do you know peano numbers
12:06:57 <warpy> platz: which plugin? i am not aware of any haskell sublime plugin for code navigation
12:07:08 <StoneCypher4k> warpy: if you find navigating a thousand lines of code difficult without vim, you are way, way too dependant on vim
12:07:09 <platz> warpy: idk I'm just guessing
12:07:15 <ashnur> funny thing is, i think i understand most of what monads are, i just can't use it
12:07:18 <Saizan> StoneCypher4k: be nice!
12:07:20 <ashnur> benzrf: yes
12:07:24 <yitz> oh i see. yeah. could be you *can* factor out the sum...
12:07:27 <StoneCypher4k> Saizan: i am being as nice as is warranted.
12:07:43 <ashnur> benzrf: i hear about peano (i have the vague feeling that i utterly disliked it)
12:07:49 <ashnur> heard*
12:08:24 <warpy> StoneCypher4k: maybe i am just used to fancy code navigations in other IDEs. i just wish there was a haskell IDE with similar features
12:08:27 <Saizan> StoneCypher4k: on #haskell we expect/warrant high niceness levels
12:08:29 <platz> ashnur: What I hear these days is to just get started using specific monads and forget that they are monads, and you'll see the abstractions after working through a few concrete examples
12:08:43 <benzrf> j
12:08:50 <jamie_h> yitz checked a lot and things seem to be the same. i just didn't like how fun2' 10 would end up with [10,5,16,8,4,2,1,0,0,0,0,0,0,0,0,0,etc.]
12:08:52 <benzrf> platz++
12:08:55 <StoneCypher4k> Saizan: see /msg and then keep it to yourself
12:09:42 <benzrf> if u can grok functors monads are peace of cake
12:09:46 <warpy> ashnur: write a bigger project, something practical
12:09:47 <benzrf> debatably
12:10:13 <StoneCypher4k> warpy: my opinion is that code navigation is a short term win and a long term dramatic loss
12:10:28 <warpy> StoneCypher4k: why do you think so
12:10:30 <ashnur> platz, benzrf for me it seems that there is a lot of unnecessary maintanence stuff when one has to deal with monads. I am not used to think about my values being wrapped into an unopenable box. it feels almost like quantum computing :)
12:11:03 <yitz> jamie_h: ?? the function you wrote above has type Int, not type [Int]
12:11:05 <pqmodn_> ashnur: that's not the case for identity, list, maybe, etc.
12:11:16 <platz> every time I think I understand functors, I come across something like SML modules and i'm like "here we go again!"
12:11:36 <jamie_h> yitz yes, I mean the above list I wrote would be passed in to sum
12:11:40 <ashnur> warpy: i only write practical things. what i said didn't imply that what I write it's not practical. i just wanted to say that it usually doesn't fit any of the common patterns and I have to invent a lot of things myself
12:11:47 <yitz> jamie_h: ah ok
12:11:53 <jamie_h> didn't know whether all those extra 0s could be avoided
12:12:19 <warpy> ashnur: ah. publish those so that other dont have to reinvent them :)
12:12:21 <yitz> jamie_h: they are automatically avoided. they won't be computed.
12:12:53 <StoneCypher4k> warpy: by metaphor is the best i can do.  you can train with a wooden shotput, and you'll throw further.  train that way for two years, and the guy with the iron weight will end up throwing much, much further.
12:13:05 <jamie_h> yitz okay. how i remove the "x"s from the start/end of the function? fun2'' x = sum . takeWhile (>0) . filter even $ iterate collatz x
12:13:14 <ashnur> warpy: it's not haskell, and I do publish everything on github (if not sooner, but at least when I finish them)
12:13:15 <yitz> jamie_h: use the delete key
12:13:30 <yitz> jamie_h: change the last $ also to a .
12:13:49 <warpy> StoneCypher4k: uh, that does not make much sense to me. are you saying that code navigation makes you "weaker"?
12:14:03 <jamie_h> yitz I'm sure I tried that earlier and it didn't work. thanks :)
12:14:12 <jamie_h> works fine now with . and no x's
12:14:18 <yitz> jamie_h: yay!
12:14:37 <Kazagistar> ashnur: its not that the box is unopenable, its that you can automate and hide the "unwrapping" step between existing "wrapping" steps
12:14:42 <yitz> jamie_h: great job. next problem...
12:14:51 <warpy> so how does one go about quickchecking logic that happens inside IO?
12:14:57 <benzrf> warpy: dont
12:15:05 <benzrf> warpy: why are you doing logic in IO anyway
12:15:09 <ashnur> Kazagistar: it's not what I can do, it's what I can't.
12:15:21 <ashnur> i am used to look at the values I mess with all the time
12:15:42 <zomg> warpy: there are plugins for vim to help with navigation, NERDTree can be used to get a view of the project, and I think you can use something like ctags to provide "jump to definition" type functionality
12:15:46 <warpy> benzrf: uh, because it requires external state
12:15:48 <jamie_h> yitz ha! i just want to savor the beauty of my function first :)
12:15:49 <ashnur> for example in js I have lots of console.log commands when I am writing, even when I write for tests, so I can see that I do
12:16:01 <yitz> ashnur: you can look at IO values. use putStrLn. use breakpoints in the ghci debugger.
12:16:11 <ashnur> that's not something i could do in haskell, and it's probably not even something i should think about
12:16:13 <benzrf> warpy: use a reader monad or somethin
12:16:14 <warpy> benzrf: i mean how does one test stateful logic
12:16:21 <benzrf> state monad?
12:16:27 <benzrf> what logic, exactly
12:16:27 <yitz> ashnur: you can also look at pure values for debugging - use Debug.Trace.
12:16:35 <warpy> state monad works with quickcheck?
12:16:36 <ashnur> well
12:16:40 <ashnur> when i try it again
12:16:40 <zomg> warpy: you would probably use something like HUnit rather than QuickCheck
12:16:48 <ashnur> i will come here anyway and ask you what should i do
12:16:50 <zomg> warpy: depending on what exactly you're testing
12:16:50 <yitz> ashnur: yes you can. i do it all the time.
12:16:57 <warpy> zomg: i check it out
12:18:08 <yitz> warpy: it might not be advisible to write a quickCheck property for lauchMissiles :: IO ()
12:18:41 <warpy> yitz: that right. what i am essential trying to test here is a state machine
12:18:54 <jmcarthur> platz: ML "functors" aren't the same as haskell or category theory functors
12:19:09 <yitz> warpy: why do that in IO? use a pure state monad.
12:19:12 <jmcarthur> platz: ML functors are just parameterized modules
12:19:21 <warpy> with quickcheck generating random state transitions and verifying state invariants
12:19:31 <warpy> yitz: because my state is in db
12:19:36 <yitz> ah
12:19:47 <platz> jmcarthur: well thats confusing
12:19:57 <jmcarthur> platz: i agree. no idea what they called them functors.
12:20:08 <warpy> yitz: but anyway, even if i move it to state monad, how do i test it
12:20:21 <ffffsa> hey, i'm just starting to use parsec and I'm not sure what's going on here: http://lpaste.net/1065772198649659392 I would expect to get an array of length 2 but I only get one result
12:21:29 <yitz> warpy: then you could use evalState or execState to write regular pure quickCheck properties
12:21:36 * StoneCypher4k <3 quickcheck
12:22:11 <platz> http://cs.stackexchange.com/questions/9769/what-is-the-relation-between-functors-in-sml-and-category-theory so it appears it's like "almost a functor, but not quite"
12:22:39 <jmcarthur> random access skew lists are pretty cool. in microbenchmarks, cons is almost as fast as normal list cons, still O(1), and you also get worst case logarithmic index. the microbenchmark is probably quite misleading though, because you probably hinder some higher level optimizations this way. also, it's spine strict, and while i can think of ways to make it a bit lazier, there isn't *much* to gain by doing it,
12:22:41 <jmcarthur> and it would add a lot more complexity.
12:22:55 <warpy> yitz: but the test needs to happen inside the state monad
12:23:01 <warpy> once i eval it, i get out of it
12:23:35 <StoneCypher4k> [12:12:14] <warpy> StoneCypher4k: uh, that does not make much sense to me. are you saying that code navigation makes you "weaker"?
12:23:37 <StoneCypher4k> ... essentially yes
12:24:03 <Rembane> Conan programming?
12:24:19 <jmcarthur> platz: yeah, many things can be seen as a real functor if you work hard enough, but what relationship this is between ML functors and categorical functors is more accidental than anything.
12:24:41 <jmcarthur> s/this is/there is/
12:24:48 <StoneCypher4k> warpy: i spent two years working with eclipse people.  i watched someone i hired turn into an eclipse person.  based on those events, i am strongly of the belief that editor support can remove one's own ability to do things directly.  i believe that active direct interaction with a codebase is a maintainable skill.
12:25:01 <PJBoy> Twey, http://codepad.org/nBkYYmWS <-- the function is expression at the bottom
12:25:04 <fread2282> what does fail do in RWS?
12:25:07 * hackagebot feldspar-language 0.7 - A functional embedded language for DSP and parallelism  http://hackage.haskell.org/package/feldspar-language-0.7 (AndersPersson)
12:25:09 * hackagebot feldspar-compiler 0.7 - Compiler for the Feldspar language  http://hackage.haskell.org/package/feldspar-compiler-0.7 (AndersPersson)
12:25:43 <warpy> StoneCypher4k: having worked 6 years on eclipse, i think you are wrong :)
12:26:00 <platz> jmcarthur: sure, makes sense
12:26:15 <warpy> having an IDE to streamline all the mundane things for you is a great convenience
12:26:17 <Twey> PJBoy: You mean primitive/expression_r2/expression_r/expression?
12:26:26 <yitz> @type runRWS
12:26:28 <lambdabot> RWS r w s a -> r -> s -> (a, s, w)
12:26:47 <zomg> StoneCypher4k: I find it hard to believe that things such as "jump to definition" would make you a worse coder :)
12:26:55 <fread2282> looks like error, but I'm not sure
12:27:12 <platz> warpy: I'd like of like to write haskell in Visual Studio, but thats just crazy talk
12:27:14 <yitz> @type runRWS fail
12:27:16 <lambdabot>     Couldn't match type ‘String -> m0 a0’ with ‘RWST r w s Identity a’
12:27:16 <lambdabot>     Expected type: RWS r w s a
12:27:16 <lambdabot>       Actual type: String -> m0 a0
12:27:52 <Twey> PJBoy: Also, have you considered using Parsec or something?
12:28:02 <warpy> platz: its not if visual stupid were to have great support for haskell
12:28:27 <Welkin> so many typos
12:28:31 <Welkin> or are they?
12:28:42 <fread2282> > runRWS (fail "ono")
12:28:44 <lambdabot>  No instance for (Data.Typeable.Internal.Typeable a0)
12:28:44 <lambdabot>    arising from a use of ‘M159544708299549079829741.show_M1595447082995490798...
12:28:44 <lambdabot>  The type variable ‘a0’ is ambiguous
12:28:44 <lambdabot>  Note: there are several potential instances:
12:28:44 <lambdabot>    instance Data.Typeable.Internal.Typeable Data.Dynamic.Dynamic
12:28:48 <warpy> anyway, i'll explore the vim and emacs haskell plugins. see if help me out
12:28:50 <fread2282> @type runRWS (fail "ono")
12:28:51 <lambdabot> Monoid w => r -> s -> (a, s, w)
12:28:51 <PJBoy> Twey, this was for coursework last year
12:28:58 <yitz> @type runRWS (fail " fread2282 ")
12:28:59 <PJBoy> Twey, I didn't consider using anything
12:28:59 <lambdabot> Monoid w => r -> s -> (a, s, w)
12:29:08 <fread2282> > runRWS (fail "o) () ()
12:29:09 <lambdabot>  <hint>:1:23:
12:29:09 <lambdabot>      lexical error in string/character literal at end of input
12:29:16 <warpy> hello lambdabot
12:29:25 <yitz> > runRWS (fail " fread2282 ")
12:29:26 <lambdabot>  No instance for (Data.Typeable.Internal.Typeable a0)
12:29:26 <lambdabot>    arising from a use of ‘M104912543632640612629785.show_M1049125436326406126...
12:29:26 <lambdabot>  The type variable ‘a0’ is ambiguous
12:29:26 <lambdabot>  Note: there are several potential instances:
12:29:26 <lambdabot>    instance Data.Typeable.Internal.Typeable Data.Dynamic.Dynamic
12:29:27 <tac_> Twey: PJBoy: My JSON fail ===> https://bitbucket.org/_tactics/sudlowbot/src/b9f365572a800075c991a03a46a172dcca36e610/Cat.hs?at=default
12:29:46 <yitz> > runRWS (fail " fread2282 ") () ()
12:29:48 <lambdabot>  *Exception:  fread2282
12:30:04 <yitz> > error " fread2282 "
12:30:06 <lambdabot>  *Exception:  fread2282
12:30:09 <PJBoy> so basically, I tend to avoid Haskell unless I need infinite lists for whatever reason
12:30:17 <yitz> fread2282: so it looks like it calls error
12:30:26 <fread2282> yep
12:30:49 * roconnor always uses infinite lists and/or infinite trees
12:31:29 <jmcarthur> yeah, codata is so sadly underused
12:31:30 <tac_> I avoid haskell precisely because I like to distinguish my finite lists from my infinite ones ;o
12:31:37 <mm_freak_> hi there
12:31:37 * yitz uses infinite list and trees often, but uses Haskell even when not using infinite lists and trees.
12:31:46 <roconnor> tac_: that's a better reason. :)
12:32:00 <jmcarthur> tac_: so what do you use instead? :)
12:32:08 <tac_> (more accurately, Haskell gets in my way due to library design choices and general whimsicality chosen in favor of regularity)
12:32:09 <jmcarthur> idris/agda/something?
12:32:21 * yitz avoids haskell when it's time for supper. sometimes.
12:32:24 <mm_freak_> data X a = X a a;  data Y a = Y1 | Y2 {-# UNPACK #-} !(X a)
12:32:28 <tac_> jmcarthur: I think in Agda, but mostly, I just avoid progrmaming as much as I can :P
12:32:31 <mm_freak_> does that actually embed the X in Y2?
12:32:36 <jmcarthur> tac_: fair enough
12:32:52 <c_wraith> I just answered a question on SO about MPTCs not working if a member doesn't use every type variable (and no FDs involved).  It made me wonder why GHC doesn't reject broken class definitions like that.  This seems easy enough to statically detect, with or without FDs
12:32:52 <mm_freak_> or will the indirection remain?
12:32:54 <yitz> tac_: dijkstra had the same policy
12:32:55 <tac_> I really like what Idris is doing for dependent types, but it's not the language for me, I dun think.
12:33:19 <tac_> yitz: Yes. I also enjoy writing things out by hand as opposed to using text editors and word processors, like he did.
12:33:24 <jmcarthur> i do tend to explicitly think of my lists as being either data or codata, so it is indeed a shame that i can't make a type level or at least syntactic distinction
12:34:17 <tac_> I think it's ironic in a way that haskellers like to brag about type safety... but their type system can't distinguish between the two ;X
12:34:44 <tac_> It's usually very important to know when you can exhaust your data!
12:35:01 <mm_freak_> tac_: haskell doesn't do termination checking, so the distinction would be useless
12:35:09 <tac_> yeah
12:35:17 <yitz> tac_: you can distinguish them now, by parameterizing your list type with a nat.
12:35:31 <jmcarthur> that's not really the same
12:35:33 <vova> Hi, I would like to help some Haskell open-source projects.  Does someone know the projects that need people?
12:35:40 <fread2282> vova: yi
12:36:03 <mm_freak_> vova: lots of projects do…  what's your level of experience?
12:36:13 <vova> I'm noob
12:36:21 <vova> :)
12:36:58 <yitz> jmcarthur: why not?
12:37:06 <jmcarthur> vova: a good way to get started here is to work on something of your own and then if you find a tool or library you are using is problematic or insufficient somehow, contribute a fix for it :)
12:37:18 <mm_freak_> vova: then it's probably best to start by writing something that you find useful/fun to write…  see what libraries you used, understand them, then offer your help
12:37:33 <Kazagistar> vova: 95% of projects need tutorials and example code, and documentation beyond "read this paper where all the details are different then in the software"
12:37:51 <Kazagistar> ... I'm not bitter <_<
12:38:11 <jmcarthur> yitz: i usually don't care exactly how long a list is, just that it's finite.
12:38:17 <mm_freak_> oh yes, documentation is always welcome and lots of projects need it
12:38:32 <yitz> jmcarthur: forall n. Nat n
12:38:35 <jmcarthur> yitz: so then i would have to use some existential wrapper around that parameterised list
12:38:39 <jmcarthur> yitz: and now i'm back where i was before
12:38:53 <mm_freak_> anyway, does core reveal unpacking?
12:38:55 <vova> Ok. Thank you for the answers.
12:39:00 <Welkin> I find there are a lot of good introduction materials for haskell, but not much to bridge the gap between introduction and useful programs
12:39:07 <c_wraith> jmcarthur: but you know it's finite. It'd require an infinite type for it to be infinite.
12:39:24 <Welkin> the sudoku solver is good
12:39:26 <mm_freak_> i've never actually used ghc-core
12:39:32 <Welkin> and the chess tutorial, even though it is in german
12:40:11 <warpy> Welkin: lambdabot code
12:40:19 <Welkin> write yourself a scheme in 48 hours seems promising as well, although I haven't run through it yet
12:40:28 <Welkin> where is lambdabot's source?
12:40:30 <yitz> Welkin: "the" sudoku solver? there is a wiki page with a big pile of sudoko solvers, iirc
12:40:44 <warpy> @google lambdabot github
12:40:45 <lambdabot> https://github.com/mokus0/lambdabot
12:40:52 <StoneCypher4k> i thought haskell had prolog style tree descent?
12:40:57 <StoneCypher4k> seems like a three liner if it does
12:41:21 <StoneCypher4k> or backtracking search or i'm sure you guys have a name for it i've never heard
12:41:31 <mm_freak_> StoneCypher4k: we have backtracking monads
12:41:45 <yitz> StoneCypher4k: StateT []
12:41:46 <warpy> StoneCypher4k: it is not fast enough just with backtracking
12:41:47 <StoneCypher4k> mm_freak_: does that roughly do what i think of as what prolog does?
12:41:54 <tac_> Is 'arr' method required for the Arrow class?
12:41:56 <StoneCypher4k> warpy: ... it ... is in prolog?
12:41:57 <tac_> @type arr
12:41:58 <lambdabot> Arrow a => (b -> c) -> a b c
12:41:59 <zomg> StoneCypher4k: You mean a Monoidal Treedic Arrow Traversal?
12:42:01 <tac_> err
12:42:03 <tac_> not arr
12:42:04 <tac_> first*
12:42:05 <StoneCypher4k> warpy: ... and prolog is not known for its speed
12:42:06 <tac_> @type first
12:42:07 <lambdabot> Arrow a => a b c -> a (b, d) (c, d)
12:42:09 <mm_freak_> StoneCypher4k: not quite…  backtracking monads do it in one direction, whereas prolog does it in both
12:42:16 <StoneCypher4k> zomg: i am so new to haskell that i can't even tell if you're joking :(
12:42:19 <Welkin> this one: http://www.cs.dartmouth.edu/~cs8/F2011/notes/11/Sudoku.lhs
12:42:26 <yitz> warpy: i wrote a sudoku solver with just StateT [] backtracking and it works fine.
12:42:27 <zomg> StoneCypher4k: good =)
12:42:27 <mm_freak_> tac_: yes
12:42:41 <StoneCypher4k> zomg: co-okay
12:42:45 <mm_freak_> tac_: you need Category, arr and first to get an arrow
12:42:45 <zomg> lol
12:42:53 <tac_> mm_freak_: doesn't it follow from the law first (arr f) = arr (f, id)?
12:43:00 <warpy> yitz: does it solve the 17 sudokus within a second?
12:43:14 <warpy> i mean 17 grid sudokus
12:43:20 <yitz> warpy: yes
12:43:29 <StoneCypher4k> .lhs?  ... on looking at it ... is that a formal notation for knuth's literate programming?  does lhs mean literate haskell?
12:43:32 <warpy> yitz: code please!
12:43:39 <hpc> StoneCypher4k: yes
12:43:42 <StoneCypher4k> nice.
12:43:55 <c_wraith> amusingly, there are two entirely different .lhs syntaxes that are supported
12:43:58 <mm_freak_> :t \f -> first (arr f)
12:44:00 <lambdabot> Arrow a => (b -> c) -> a (b, d) (c, d)
12:44:03 <mm_freak_> :t \f -> arr (f, id)
12:44:04 <lambdabot>     Couldn't match expected type ‘b -> c’
12:44:04 <lambdabot>                 with actual type ‘(t, a0 -> a0)’
12:44:04 <lambdabot>     Relevant bindings include f :: t (bound at <interactive>:1:2)
12:44:14 <mm_freak_> tac_: not quite =)
12:44:17 <StoneCypher4k> c_wraith: seems like one of them needs a fork called illiterate haskell then
12:44:35 <yitz> warpy: in fact, i generate puzzles by generating infinite lists and mapping the solver over them, then find the first that has the properties i want. there is no significant delay.
12:44:55 <mm_freak_> "arr (f, id)"…  arrows make side channels…  like RFID…  "arr (f, id)"
12:44:57 <mm_freak_> I SEE!
12:45:09 * hackagebot transformers-compat 0.3.3.2 - A small compatibility shim exposing the new types from transformers 0.3 and 0.4 to older Haskell platforms.  http://hackage.haskell.org/package/transformers-compat-0.3.3.2 (EdwardKmett)
12:45:11 <warpy> yitz: that seems interesting
12:45:11 * hackagebot transformers-compat 0.3.3.3 - A small compatibility shim exposing the new types from transformers 0.3 and 0.4 to older Haskell platforms.  http://hackage.haskell.org/package/transformers-compat-0.3.3.3 (EdwardKmett)
12:45:13 * hackagebot transformers-compat 0.3.3.4 - A small compatibility shim exposing the new types from transformers 0.3 and 0.4 to older Haskell platforms.  http://hackage.haskell.org/package/transformers-compat-0.3.3.4 (EdwardKmett)
12:45:15 <yitz> warpy: it's on the sudoku page on the haskell wiki. haven't looked at in years - it's probably very dated code.
12:45:24 <warpy> i'll check it out
12:45:57 <hpc> edwardk: why so many minor revisions at the same time?
12:46:24 <edwardk> hpc: tricking the backtracking solver
12:46:42 <edwardk> hpc: if they are flags then the backtracker gives up.
12:46:49 <edwardk> if they are separate versions it just solves it
12:47:14 <hpc> oh, weird
12:47:14 <yitz> edwardk: is this issue known to the cabal team?
12:47:19 <edwardk> so 0.3.3.2 is the version for transformers 0.2, 0.3.3.3 for transformers 0.3 and 0.3.3.4 transformers 0.4
12:47:31 <edwardk> yitz: yeah, kosmikus had put out a patch, but it wasn't enough
12:47:49 <edwardk> after he acknowledged that he was back to the drawing board snoyman pushed forward this proposal
12:47:58 <edwardk> and i took it as it is the best thing i've got to use now
12:48:07 <edwardk> and my solution has to work even on older cabal versions
12:48:09 <piezoid> hi
12:48:10 <yitz> edwardk: there is talk of finally using a true sat solver
12:48:29 <c_wraith> yitz: that unfortunately doesn't fix the "must work on old cabal" issue
12:48:31 <edwardk> If it takes long enough I'll just write one for it ;)
12:48:42 <edwardk> but like c_wraith says, doesn't help me for years
12:48:48 <piezoid> i'm having the same bug for a long time : packages depending on aeson doesn't compile
12:49:00 <piezoid> package having dependencies on Aeson keeps looking for Data/Aeson/Encode/ByteString.hi but the file doesn't exist
12:49:07 <warpy> why do so many libraries have these "Internal" modules? why not just not put them in the exposed-modules sections of cabal and be done with it?
12:49:08 <piezoid> the relevant interfaces are in Data/Aeson/Encode.dyn_hi instead
12:49:11 <hpc> bogosearch! pick a random set of package versions until one happens to work
12:49:26 <c_wraith> warpy: because not exposing them tends to make packages less useful.
12:49:51 <c_wraith> warpy: it turns out that it's often really useful to get into the internals of a package to do things that the creator didn't envision.
12:49:57 <yitz> hpc: for transitive deps, you first need to pick random sets of packages
12:50:01 <warpy> c_wraith: then why mark them as internal
12:50:06 <edwardk> warpy: there are often internal details that you mght not _want_ to expose because they can be used to break your invariants, but if you don't expose them then users get stuck and have to throw all your work out occasionally
12:50:07 <hpc> warpy: for instance, with bytestrings
12:50:21 <c_wraith> warpy: it's explicitly saying that "these are dangerous if misused"
12:50:38 <edwardk> warpy: I have a policy of exposing anything you could possibly need to work around me via an Internal module.
12:50:55 <edwardk> warpy: that way you are never crippled by having bought into one of my packages
12:50:55 <c_wraith> warpy: if people avoid the .Internal modules, they won't ever accidentally use a dangerous thing
12:51:07 <c_wraith> warpy: but if they *need* to use the dangerous things, they're available.
12:51:32 <jmcarthur> okay, fine, type level nats serve as a kind of termination checker as far as i can tell after all
12:51:38 <edwardk> warpy: they often expose bits and pieces of the API that have rough edges, lots of invariants, etc.
12:51:41 <hpc> and for verifying code correctness, you can grep ^import.*Internal$
12:51:47 <hpc> :P
12:52:06 <c_wraith> jmcarthur: oh good.  I was only like 70% sure of my assertion. :)
12:52:16 <jmcarthur> :)
12:52:26 <warpy> hmm. it makes sense.
12:53:28 <warpy> if i dont expose some module of my lib in cabal then i get undefined reference to `xyx_closure' error even though the other lib does not directly use this closure
12:53:32 <SuperMind> ffffsa, did you fi nd your issue?
12:53:53 <jmcarthur> warpy: that seems wrong...
12:54:20 <SuperMind> ffffsa, you have manyTill, that means to stop all parsing when it hits the end provided, you want to use just plain many
12:54:22 <warpy> if i put the module in the expose section in cabal, it works fine
12:54:24 <yitz> c_wraith, edwardk: must work on old cabal isn't as important as it used to be. anyone can build the latest cabal-install in a sandbox and use the resulting exe.
12:55:25 <jmcarthur> warpy: i've always thought this field wasn't strictly necessary, but what if instead of putting it in exposed-modules you put it in other-modules?
12:55:26 <yitz> SuperMind: ffffsa responded by exiting.
12:55:34 <edwardk> yitz: i deal a lot with people who work on debian, and other distributions to make sure my code works as widely as possible. still matters for a number of those environments
12:55:48 <edwardk> yitz: i agree it isn't an issue for a mainstream haskell dev.
12:55:58 <jmcarthur> warpy: but i want to emphasize that the behavior your describe is surprising to me
12:56:00 <warpy> jmcarthur: i have to tried it but why do i need to expose it at all
12:56:01 <jmcarthur> *you
12:56:08 <edwardk> but for one who just wants to install and run it with their platform's installers? makes a huge difference in availability
12:56:09 <jmcarthur> warpy: other-modules isn't exposing it
12:56:32 <jmcarthur> warpy: and i claim that you shouldn't have to expose it and something fishy is going on to get that error
12:56:33 <warpy> right, but why put it there anyway? i never understood the point of other-modules
12:56:53 <jmcarthur> i think part of the point is as a hint for cabal dist
12:57:01 <yitz> edwardk: after the new platform finally comes out - any day now - the number of such environments will start dropping fairly quickly.
12:57:11 <Welkin> new platform?
12:57:30 <yitz> Welkin: the next release of the haskell platform
12:57:40 <Welkin> I'm on an old one as it is
12:57:43 <Welkin> because of ubuntu
12:58:16 <yitz> Welkin: which ubuntu release are you on?
12:58:22 <Welkin> 12.04
12:58:32 <Welkin> I should probably upgrade to the new LTS 14.04
12:58:34 <edwardk> yitz: i still supply some support for ghc 7.0 ;)
12:59:36 <yitz> Welkin: yeah. anything newer than precise has the latest (quite old) platform)
13:00:12 <yitz> Welkin: and since precise is still supported, i'm not sure why it hasn't been backported there too. perhaps it's in backports?
13:00:46 <warpy> jmcarthur: i tried it, putting those modules in other-modules works. though i don't understand why
13:01:11 <yitz> edwardk: yeah i'm not sure what versions of ghc are available on centos 4 :)
13:01:35 <warpy> Welkin: you can get ghc 7.8 on precise. from the ghc ppa
13:01:41 <warpy> thats how i have it
13:01:47 <Welkin> which ppa is that?
13:02:02 <warpy> https://launchpad.net/~hvr/+archive/ghc
13:02:17 <yitz> warpy: in truth i just use the generic ghc tarball on ubuntu, and install HP from hackage.
13:02:46 <warpy> yitz: well, the deb is not very much more than a tarball
13:02:53 <yitz> right
13:03:11 <Welkin> thanks
13:03:27 <warpy> i installed the latest ghc deb from the ppa and use sandbox to hide all the old hp packages
13:05:53 <piezoid> i copied the missing ByteString.*hi to my ~/.cabal tree, but now I have undefined symbols during link phase...
13:06:23 <warpy> piezoid: use sandbox
13:07:42 <piezoid> it's realy close to a sandboxed build, i've recently cleaned .ghc .cabal
13:08:53 <ij> Are there function that have a kind something specific instead of *?
13:10:55 <dottedmag> ij: kinds by definition are either *, or <kind1> -> <kind2>
13:11:16 <ij> Are there any examples of the second one?
13:11:23 <triliyn> Maybe :: * -> *
13:11:35 <StoneCypher4k> [12:25:12] <zomg> StoneCypher4k: I find it hard to believe that things such as "jump to definition" would make you a worse coder :)
13:11:42 <StoneCypher4k> i'm not saying it'll make anyone a worse coder per se
13:11:42 <piezoid> oh, aeson master (0.8) solved the problem :)
13:12:04 <triliyn> dottedmag, ij: there are actually certain extensions that define kinds other than * and k1 -> k2
13:12:21 <StoneCypher4k> but just as i feel that getting used to a power drill means you won't be able to work with a hand crank drill as effectively anymore, i feel that working with editor X means you'll be less able to work with weaker editor F
13:12:22 <triliyn> ConstraintKinds has things like Functor Maybe :: Constraint
13:12:26 <triliyn> And then there's datakinds
13:12:41 <StoneCypher4k> and at the point that a thousand lines in a modern editor seems daunting, /then/ i begin to wonder if it has gone too far.
13:12:43 <dottedmag> triliyn: TIL. thanks.
13:12:43 <warpy> arent primitives a kind of their own
13:12:44 <triliyn> But every type that has values has kind *
13:12:47 <jomg> ij: no, functions always have kind *
13:12:47 <warpy> # kind?
13:13:05 <triliyn> oh, also that. I think that's also some weird GHC extension though
13:15:02 <slomo_> when using monads like Reader or State, are there any conventions for the name of the type "Reader a" and the type "a"?
13:15:17 <jophish_> Yo yo yo,
13:15:46 <jophish_> There used to be a list of all operators in Hackage which were longer than three characters. The link is now dead: http://sprunge.us/fVbT
13:15:50 <SuperMind> slomo_, what do you mean by conventions for the name? like hungarian notation?
13:15:59 <jophish_> Does anyone have a working link to this list?
13:16:03 <jophish_> It was pretty amusing
13:16:12 <ij> jomg: Thanks!
13:16:17 <jophish_> especially the xmonad operators which were essentially pretty diagrams
13:16:23 <pdxleif> For testing against multiple GHC version, travis-ci seems to support that natively? http://docs.travis-ci.com/user/languages/haskell/
13:16:31 <pdxleif> But there's also this: https://github.com/hvr/multi-ghc-travis
13:17:13 <jomg> ij: * means that some value has a concrete type (i.e. is not a type constructor or constraint)
13:17:24 <jomg> so value-level things always have kind *
13:17:46 <SuperMind> slomo_, One convention that is quite common is to use a "monad stack"... which is you have one monad for your app and it is is created by applying a bunch of monad transformers together... so type MyApp = ReaderT ...
13:18:06 <jomg> (to be more precise, * is the kind of conrete types)
13:18:11 <SuperMind> or rather type MyApp a =
13:18:28 <slomo_> SuperMind: i'm only talking about naming of the types :) i mean like "data WhateverEnvironment = ...", "type Whatever = Reader WhateverEnvironment"
13:18:33 <fread2282> slomo_: if you want to use lens, don't use a monad stack to avoid future pain
13:18:34 <oisin640> In terms of terribleness, how high is this on the scale? Should I rethink implementing the Num typeclass if I can't implement fromInteger: fromInteger i = error "Cannot create vector using fromInteger."
13:19:05 <SuperMind> slomo_, well i don't know of any specific convention for Reader a
13:19:21 <fread2282> oisin640: what's your Num instance do?
13:19:34 <oisin640> fread2282: It adds, subtract, multiplies vectors
13:19:40 <SuperMind> slomo_, why not leave it un-named?
13:19:57 <SuperMind> slomo_, that's sort of a convention
13:20:49 <slomo_> SuperMind: ok, thanks :)
13:21:53 <warpy> <fread2282> slomo_: if you want to use lens, don't use a monad stack to avoid future pain
13:21:55 <Eelis> DanielDiaz: thanks for HaTeX! i was able to use it to extract quotes from the C++ standard
13:22:04 <warpy> fread2282: what do you mean by that
13:22:08 <edwardk> ?
13:23:00 <fread2282> warpy: you can't write lenses that manipulate multiple parts of the stack
13:23:05 <fread2282> or use
13:23:07 <DanielDiaz> Eelis: you're welcome! :)
13:23:38 <warpy> fread2282: what is the alternative then
13:24:52 <fread2282> warpy: just using a State monad or being careful when desigining the non-state parts of your stack
13:25:34 <warpy> fread2282: i am not sure i understand. do you have a link which explains this?
13:27:12 <Cale> oisin640: Generally, fromInteger 0 should be the identity element for however you define (+) and fromInteger 1 should be the identity element for however you define (*). From there, it should satisfy fromInteger (n + m) = fromInteger n + fromInteger m
13:27:28 <Cale> (which should indicate how it ought to be defined for all the rest)
13:27:44 <Cale> If there are no identity elements, you probably don't want an instance of Num after all
13:27:54 <edwardk> fread2282: i don't know what you mean by 'write lenses tht manipulate multiple parts of the stack'
13:28:07 <edwardk> fread2282: can you give an example?
13:28:20 <edwardk> fread2282: speaking as both 'the lens guy' and 'the mtl' guy. =)
13:28:32 <fread2282> warpy: say you have a RWS input output state and you want to write a lens that uses the input to decide what to do to the state, or a lens that when setting writes some output. you can't
13:28:59 <edwardk> those aren't lenses
13:29:12 <fread2282> edwardk: exactly
13:29:15 <edwardk> lenses say how to find parts of a structure, not what to do with it
13:29:17 <Cale> oisin640: I don't know how you defined multiplication, but it's quite likely that fromInteger n ought to give the vector all of whose elements are fromInteger n
13:29:30 <edwardk> that i the purview of combinators you write the use or take lenses.
13:29:48 <edwardk> nothing keeps you from using lenses in a complex transformer stack, in fact they work very well together
13:30:18 <oisin640> Cale: The problem is I'm trying to write a type safe vector - and giving fromInteger i gives no intuition about how long the vector can be. So it doesn't know to create [0], [0, 0], ...
13:30:24 <edwardk> the best way i know to work around the 'two states' problem is to use classy lenses and just work in (HasFoo s, HasBar s, MonadState s m) => ...
13:30:27 <yitz> Cale: the image of fromInteger is likely to be discrete points along some one-dimensional subspace. but not necessarily that one.
13:30:43 <edwardk> er 'that is'
13:31:05 <Cale> yitz: It depends on the multiplication. If he's just doing elementwise multiplication, then what I suggested is probably right.
13:31:28 <Cale> (if not, then refer to my comment before that)
13:31:37 <fread2282> but you can only get so far if you want to use lens with a stack designed without lens in mind
13:32:15 <Cale> oisin640: Well, if the vector's length is encoded by the type, then you'll know how long it ought to be
13:32:25 <yitz> Cale: i don't think there's any guarantee that a Num instance is an integral domain. and even if so, there are plenty of other possible implementations. you're right that is often the simplest though.
13:32:59 <edwardk> fread2282: i would argue anything that uses two states wasn't designed, it was accreted, poorly. ;)
13:33:25 <Cale> yitz: fromInteger should be the unique (unital) ring homomorphism from Z to whatever (approximate?) ring it is that you're defining.
13:33:35 <yitz> Cale: for example, when working with finite fields, you use vector spaces whose multiplication definitely do not give rise to that particular implementation of fromIntegral.
13:33:48 <edwardk> fread2282: for the standard one state, one env, one writer, maybe several continuations/error configuration monad stacks everything works fine. those are the things the mtl is designed to support. for everything else you're just as fucked with lens as you are without it
13:34:39 <warpy> what is a practical use of writer monad
13:34:51 <edwardk> warpy: using up all your memory
13:35:02 <warpy> i have not yet used it in any real project
13:35:08 <Cale> yitz: you should always have that fromInteger 0 is the additive identity and fromInteger 1 is the multiplicative identity, and then that fromInteger is a homomorphism
13:35:33 <Cale> The term "monad stack" makes me sad
13:35:52 <warpy> edwardk: that is not very "practical" :)
13:36:05 <oisin640> Cale: I don't quite understand how you can go from an integer value to a vector of some undetermined length? http://lpaste.net/104953
13:36:08 <warpy> Cale: how about "monad pile"
13:36:16 <yitz> Cale: yes.
13:36:17 <Cale> warpy: The things being composed are not monads
13:36:25 <edwardk> Cale: i should have said transformer stack
13:36:36 <warpy> right
13:37:01 <warpy> so ya, is there a practical use to writer monad
13:37:11 <Cale> oisin640: You need an operation to reify your type level naturals
13:37:34 <yitz> hey i thought of a great new idea for a monad tutorial. monads are like smoke. then later we can talk about a "smoke stack".
13:37:52 <Nik05> can i make a type constructor that calls others functions to create the type?
13:38:08 <edwardk> warpy: yes, it can be used when you want to spit out an accumulated monoidal result as you do something else
13:38:34 <edwardk> and lazy writer can let you tie the knot and produce some infinite monoidal values you can't produce by other means monadically
13:38:37 <edwardk> but it is a niche use
13:39:00 <warpy> i see
13:39:05 <yitz> Nik05: type families do that, sort of.
13:39:53 <Nik05> yitz thats an extension?
13:40:07 <yitz> yes
13:41:15 <Cale> oisin640: actually, no you don't, you just need recursion
13:41:59 <oisin640> Cale: When do I stop recursing?
13:42:02 <yitz> warpy: one common use of writer i've seen is to collect elements of a tree that satisfy a stateful property
13:42:53 <warpy> what is a stateful property
13:43:19 <Cale> oisin640: I'll make a paste
13:43:48 <yitz> warpy: you keep track of some state as you traverse the tree, and the value of that state at any point in the traversal affects whether the node you are examining is included in the output.
13:44:56 <Cale> oisin640: see my annotation: http://lpaste.net/104953
13:45:04 <warpy> yitz: it kind of makes sense. i'll make a note of it
13:45:12 <Cale> Ah, I didn't end up using KindSignatures
13:45:16 * hackagebot lens 4.2 - Lenses, Folds and Traversals  http://hackage.haskell.org/package/lens-4.2 (EdwardKmett)
13:46:27 <oisin640> Cale: Oh - I didn't know you can break up instances like that!
13:46:50 <warpy> edwardk: is on fire today!
13:47:49 <edwardk> warpy: you should have been here back in 2012 when i had 50 releases a day some days ;)
13:48:19 <warpy> woah! what were you on then!?
13:48:28 <Welkin> pure cocaine
13:49:11 <edwardk> well, nowadays i have these things called 'users' and that causes me to exhibit this newfound tendency i hear is called 'restraint' ;)
13:49:50 <Welkin> edwardk, do you use haskell in your day job?
13:49:56 <edwardk> Not too much restraint, mind you. But enough. ;)
13:49:58 <Welkin> in fact, I wonder how many people here use it at work
13:49:59 <edwardk> Welkin: yeah
13:50:07 <jmcarthur> users can restrain themselves. this is what upper bounds on dependencies are for. ;)
13:50:18 <edwardk> Welkin: wasn't always the case, but for the last couple of years, we've been using it more and more
13:50:20 <warpy> i use haskell in my night job :P
13:50:45 <Welkin> it seems rare to find a company using it
13:50:59 <jmcarthur> there are at least quite a few people here using functional languages at work, if not haskell specifically
13:51:09 <Welkin> if they use a functional language, it seems more common to go for a jvm language like scala or clojure
13:51:12 <Welkin> unfortunately
13:52:08 <dottedmag> does XSLT count?
13:52:21 <warpy> ya, i was trying to sell haskell to a clojure guy today and he was like, i have no idea what you are talking about
13:52:31 <edwardk> I've decided to stop apologizing for how "Scala does the best it can given its constraints" and just do everything i can to make Haskell the language people can and should work in by addressing as many of its short-coming as I can.
13:52:54 <oisin640> Cale: That works great, thank you! My only question is if there is some way to not duplicate the definitions for (*) (+) (-) etc. for both of the instances of Num?
13:53:00 <|akh|> How can you construct a Network.HTTP.HTTP with a URL like "/index.html" and the host in the "Host" header? It seems the only valid URI contains both "http" and the host address.
13:53:31 <ReinH> warpy: talk to bitemyapp about that
13:53:59 <Cale> oisin640: They won't be duplicates
13:54:20 <Cale> oisin640: Your instances for the zero case will presumably give Nil every time
13:54:20 <oisin640> Cale: They'll all be Nil?
13:54:28 <warpy> ReinH: why bitemyapp?
13:54:28 <oisin640> Cale: Ah, ok, thanks!
13:54:50 <ReinH> because he's an ex clojure person
13:54:59 <Welkin> oisin640, you can thank people using Cale++
13:55:09 <Welkin> !karma Cale
13:55:16 <Welkin> hm, what was that again
13:55:20 <Welkin> @karma
13:55:20 <lambdabot> You have a karma of 2
13:55:23 <Welkin> @karma Cale
13:55:24 <lambdabot> Cale has a karma of 44
13:55:34 <oisin640> Cale++
13:55:37 <oisin640> @karma Cala
13:55:37 <Welkin> @karma Cale
13:55:37 <lambdabot> Cala has a karma of 0
13:55:38 <lambdabot> Cale has a karma of 45
13:55:39 <oisin640> @karma Cale
13:55:40 <lambdabot> Cale has a karma of 45
13:55:41 <ReinH> Low by an order of magnitude
13:55:44 <oisin640> Welkin: cheers
13:55:45 <Cale> The karma gets reset occasionally for whatever reason anyway
13:55:50 <|akh|> @karma
13:55:50 <lambdabot> You have a karma of 0
13:55:53 <yitz> @karma c
13:55:53 <lambdabot> c has a karma of 2
13:56:04 <Cale> It would be interesting to know what my karma from the beginning of time was :)
13:56:07 <yitz> c used to have the most karma of anyone. but they fixed that.
13:56:19 <Welkin> ahahha
13:56:26 <serutsubi> I see that there are some linear algebra libs for haskell. How would I go about implementing variable sized vectors?
13:56:32 <dottedmag> @karma C
13:56:32 <lambdabot> C has a karma of 2
13:56:55 <ReinH> serutsubi: use the vector lib
13:57:29 <mhic> Hi, I'm trying code from a book and I get the following issue in ghci: http://lpaste.net/3049548263309967360
13:57:36 <serutsubi> ReinH: Does it have the usual operations defined? Euclidian inner product etc?
13:58:34 <yitz> @type "a"
13:58:36 <lambdabot> [Char]
13:58:37 <yitz> @type 'a'
13:58:38 <lambdabot> Char
13:58:49 <yitz> mhic: those have different types
13:59:04 <mhic> yea, but why does the Char by itself version work in ghci and not in the function?
13:59:04 <ReinH> Ah. Maybe you want vector-space.
13:59:31 <mhic> I'm new, so kind of learning the language.
13:59:49 <yitz> mhic: because your function requires Strings, whereas head is polymorphic.
14:00:17 <glguy> mhic: [[Char]] means List of List of Char, Strings like "error" are actually [Char]. You can't apply firstOrEmpty to ['a','b'] because that ['a','b',] has type [Char]
14:00:24 <serutsubi> ReinH: That seems more like it :). Thanks
14:00:25 <glguy> while your function demands a [[Char]]
14:00:32 <yitz> @type head
14:00:33 <lambdabot> [a] -> a
14:00:40 <Welkin> mhic, it's always helpful to know how the functions like "head" work by looking at the source
14:00:40 <mhic> Hmm, I see.
14:00:47 <geardev> I have a basic question about contructing a new type
14:00:57 <Welkin> http://hackage.haskell.org/package/base-4.7.0.0/docs/Prelude.html#v:head
14:00:59 <albeit> Is there a function to convert Maybe a -> Either b a, with a provided b value if Maybe is Nothign?
14:01:05 <Welkin> http://hackage.haskell.org/package/base-4.7.0.0/docs/src/GHC-List.html#head
14:01:06 <geardev> let's say you type this into ghci: data Person = Person { name :: String, age :: Int }
14:01:25 <glguy> mhic: your function would either try to return a 'a' or "error" if it accepted your last input, but that wouldn't work because the two returns values have different types
14:01:31 <yitz> albeit: maybe (Left b) Right
14:01:32 <glguy> one being Char the other [Char]
14:01:53 <oisin640> serutsubi: There's also Vec, I think.
14:01:55 <tremon> where should I look for the list of datatype identifiers in yesod models?
14:02:02 <albeit> yitz: Ah clever, thanks
14:02:03 <geardev> now, I've seen that you can type `name (Person "adam" 26)` to construct a new person with name "adam" and an age of 26, but why do you have to type it like this?
14:02:19 <geardev> my intuition is to type: Person "Adam" 26
14:02:19 <mhic> Thanks for the info and response, I'll look at the docs.
14:02:26 <geardev> or Person ("Adam, 26)
14:02:33 <geardev> also, good evening everyone
14:02:53 <ReinH> geardev: the former gives the name of the person
14:04:47 <dottedmag> geardev: data Person = Person { name :: String, age :: Int } deriving Show, if you're confused by "No instance for (Show Person) arising from a use of `print'"
14:05:01 <ReinH> Person "Adam"
14:05:03 <glguy> geardev: That's just the way the language works, you can either use Person "Adam" 26 or Person { name = "Adam", age = 26 }
14:05:06 <ReinH> We
14:05:14 <glguy> to construct a value of that record
14:05:17 <ReinH> damn it autocorrect
14:07:14 <Kazagistar> geardev: { Person :: String -> Int -> Person }, { name :: Person -> String }, {Person "Adam" :: Int -> Person}, { Person "Adam" 26 :: Person }, { name (Person "Adam" 26) :: String}
14:07:23 <Rc43> Is there anybody familiar with "EasyPlot"?
14:07:34 <Rc43> It is home-made binding for gnuplot.
14:07:47 <Rc43> But I can't make it work as I want.
14:17:54 <Rc43> Oh, at least it has debug output of exuted command.
14:18:55 <spott> has anyone worked their way through "write you a haskell"?
14:19:40 <dagle> You don't mean a scheme?
14:20:04 <fread2282> is there any way I can tell cabal repl what module to load?
14:20:08 <dagle> I know about learn you a haskell and write you a scheme.
14:20:17 <dottedmag> This one? http://gergo.erdi.hu/blog/2013-02-17-write_yourself_a_haskell..._in_lisp/
14:20:22 * hackagebot xmonad-utils 0.1.3.3 - A small collection of X utilities  http://hackage.haskell.org/package/xmonad-utils-0.1.3.3 (LeifWarner)
14:20:59 <sshine> heh
14:21:34 <platz> has anyone done Diehl's "Implementing a JIT Compiled Language with Haskell and LLVM"?
14:21:43 <platz> been on my rader for when i get time
14:22:10 <geardev> Why does name function expect you to include an age. I'd like to just update the name without modifying the age.
14:22:11 <platz> http://www.stephendiehl.com/llvm/
14:22:43 <dottedmag> geardev: name function retrieves a name from a complete value.
14:22:55 <dottedmag> geardev: you have created a value and then returned a name from it.
14:23:26 <dagle> platz: I came to chapter 3 and then I remembered that I don't like compilers... or not enough, so I stoped.
14:23:27 <yitz> geardev: you can write: person { name = "Sam" }
14:23:39 <yitz> geardev: where person is an existing record
14:23:42 <piezoid> platz: it's an adaptation of the ocalm tutorial
14:23:49 <platz> dagle: hah
14:24:20 <albeit> If a value Foo = Foo String, is anyway to get the string? like "foo = Foo "Bar"; str = valOf foo"?
14:24:27 <platz> piezoid: right, just figure it has a little more haskell meat compared to the scheme one
14:24:38 <yitz> albeit: pattern match
14:24:55 <platz> i.e. includes monad transformers
14:25:11 <oisin640> Is there a way to define zipWith over a Functor? It seems like it only works on lists...
14:25:15 <geardev> Thanks everyone, I think I will need to revisit creating data types again
14:25:34 <yitz> albeit: either as an argument to a function, or in a pattern binding in a where or let clause, or in a case statement
14:27:01 <albeit> yitz: That would get verbose it seems for what I need... say I have a data constructor "data Entry = String Int String", and three instance of "data Tag = Foo String | Bar Int | Baz String"... is there no easy way to extrac the three values form the Tags to pass to Entry?
14:27:19 <yitz> > let Foo val = Foo " albeit " in val
14:27:20 <albeit> *data Entry = Entry String Int String
14:27:20 <lambdabot>  " albeit "
14:27:32 <Andrewmm> Hey guys, you can be advertised for free up to 22 million users sign up for free https://www.globallshare.com/en/2002959.html and maybe make some money :D Cheers!
14:27:41 <yitz> albeit: if it would be too verbose, you want to use record syntax
14:28:24 <kwmiebach> Hi, can you help me install  gtk2hs-buildtools? It sais it cannot find alex, but alex install runs fine: http://lpaste.net/1334241387322802176
14:29:10 <kwmiebach> my os is ubuntu 64 bit saucy
14:30:34 <ReinH> oisin640: can you define zipWith using fmap?
14:30:39 <kwmiebach> i started with apt-get install cabal and then did "cabal install cabal-install" - maybe this was wrong
14:31:13 <dottedmag> kwmiebach: is /root/.cabal/bin in your $PATH?
14:31:20 <dottedmag> Also, root. uhm.
14:31:29 <benzrf> dont be root
14:31:46 <oisin640> ReinH: (map (\a b -> f a b)) . zip?
14:31:52 <oisin640> fmap*
14:32:11 <ReinH> Can you define zip using fmap?
14:32:24 <dagle> yes
14:32:29 <kwmiebach> you mean i should install it under the user?
14:32:41 <dagle> yes
14:32:41 <benzrf> ReinH: no
14:32:49 <benzrf> but you can define it using the applicative instance for ziplist
14:32:59 <ReinH> (It's a rhetorical question)
14:33:04 <albeit> Can multiple data constructors for one datatype have the same field name? Like "data Foo = Bar { val :: Int} | Bar { val :: String}"?
14:33:10 <dottedmag> kwmiebach: Yes, but it won't change anything. You need to add $HOME/.cabal/bin to PATH anyway, as gtk2hs-buildtools looks for alex binary without absolute path.
14:33:16 <oisin640> ReinH: Oh - no :D
14:33:26 <ReinH> oisin640: ok then :)
14:34:29 <roconnor> edwardk: Have you ever studied NBE (Normalization by Evaluation)?
14:34:53 <ReinH> roconnor: hi!
14:34:57 <roconnor> hi
14:37:11 <ReinH> roconnor: I'm sitting on a plane with Mac Lane's Algebra and a pad of paper :) Good times.
14:37:32 <edwardk> roconnor: not to the extent that dolio has, but i get the gist of it
14:37:43 <benzrf> ReinH: do you keep channel logs?
14:38:05 <benzrf> ReinH: im trying to remember the nick of the guy i was talking about groups and stuff with in ##math night before last
14:38:06 <roconnor> edwardk: I'm rereading your Dec arctile on phoas.
14:38:22 <ReinH> benzrf: um. I don't really. :/
14:38:28 <benzrf> kk
14:38:39 <edwardk> roconnor: ah the profunctor split?
14:38:40 <benzrf> i just remember that you joined partway through p:
14:38:43 <ReinH> benzrf: started with a M?
14:38:47 <roconnor> edwardk: anyhow, the NBE method really feels like an invariant cata thing.
14:38:56 <benzrf> hmm
14:39:01 <roconnor> edwardk: reflect and reify have exactly the right inverse form
14:39:05 <benzrf> ah, found him, thanks :)
14:39:07 <edwardk> roconnor: *nods*
14:39:11 <roconnor> edwardk: Reflect is a type constructor equivalent to Place
14:39:39 <ReinH> benzrf: :)
14:39:42 <edwardk> roconnor: now that you mention it that sounds like my last 'aha moment' when i was thinking about NBE ;)
14:39:51 <kwmiebach> So how do i use cabal system wide? sudo cabal or just run it as a user who has sudo rights?
14:40:06 <roconnor> edwardk: I haven't entirely worked it out but I have little doubt it all fits together.
14:40:13 <exicer> How do people typically deal with databases in tests? I'm using persistent and testframework. After I run some unit tests it would be nice to clean up somehow.
14:41:04 <dottedmag> kwmiebach: cabal install --global. Though I am not sure where it places binaries built.
14:42:20 <roconnor> edwardk: NBE so far feels like a great choice.  It was redicously easy to implement, it has lazy semantics, and I didn't even have to write a substitution fuction, capture-avoiding or otherwise.
14:43:08 <roconnor> I'm currently debating whether I should even bother converting my AST to a PHOAS.
14:43:30 <ReinH> roconnor: interesting!
14:43:43 <edwardk> i don't tend to like PHOAS, preferring bound, but ymmv.
14:44:06 <roconnor> edwardk: what is the representation in bound?
14:44:25 <edwardk> bound is a generalized form of generalized debruijn
14:44:33 <edwardk> basically you get a monad transformer to capture names
14:44:44 <ReinH> how do I learn more about NBE?
14:45:03 <edwardk> and combinators to help you write the monad for capture-avoiding substitution and to abstract/instantiate
14:45:12 <edwardk> in my experience it forces me to think about names 'just enough'
14:45:19 <fread2282> I'm trying to change the writer [a] in a RWS to a Producer a from pipes and I changed RWS Window [Update] FBuffer a to Producer' Update (RWS Window () FBuffer) a in my newtype and now GHC's complaining that it can't make a derived instance of monad because it can't eta-reduce the representation enough with GND, what should I do to fix this? write the Monad instance by hand? order the transformers the other way?
14:45:23 <edwardk> https://www.fpcomplete.com/user/edwardk/bound
14:45:30 <roconnor> ReinH: I just read the wikipedia page and Filinski, Andrzej; Rohde, Henning Korsholm (2004). "A denotational account of untyped normalization by evaluation" (PDF). FOSSACS.
14:45:39 <edwardk> that goes through the general space of alternatives, and derives bound
14:46:30 <roconnor> edwardk: Since I haven't even used substitution, my only reason for leaving my plain old names approach in my AST is to perform at least a static phase of scope checking.
14:46:53 <edwardk> bound is basically bird & paterson following the nicer naming conventions of mcbride's 'i'm not a number, i'm a free variable' , wrapped up in a monad transformer
14:47:04 <roconnor> edwardk: that seems reasonable.
14:47:41 <edwardk> roconnor: the gist is you get to use a monad for your expression type, and traversable can walk the free variables in it
14:47:53 <edwardk> so you can do a lot with standard classes you already know
14:48:01 <edwardk> :t traverse (const Nothing)
14:48:03 <lambdabot> Traversable t => t a -> Maybe (t b)
14:48:10 <edwardk> can check for closed terms for instance
14:48:43 <kwmiebach> I removed my $HOME./cabal folder to start fresh, but now I cant use cabal anymore. How to get out of this?
14:49:31 <kwmiebach> cabal wants .cabal/bin/cabal but if I create an empty file there nothing works. How do I start fresh?
14:50:11 <roconnor> ReinH: NBE does the impossible, it converts denotational values back into syntax.
14:50:32 <roconnor> FP seems to peform a lot of impossible tasks lately.
14:50:36 <geekosaur> kwmiebach, if thats so then you must have initially installed it via the bootstrap mechanism; you'll need to do it again
14:51:32 <ReinH> roconnor: thanks
14:51:59 <geekosaur> per http://www.haskell.org/cabal/download.html grab the source tarball http://www.haskell.org/cabal/release/cabal-install-1.20.0.2/cabal-install-1.20.0.2.tar.gz and use its bootstrap.sh
14:52:08 <kwmiebach> geekosaur: ok that worked .)
14:52:27 <roconnor> ReinH: evalutation becomes (1) convert syntax into semantics
14:52:39 <roconnor> ReinH: convert semantisc into syntax
14:52:41 <kwmiebach> geekosaur: you mean the source install is preferred over ubuntus package?
14:52:49 <roconnor> ReinH: (2) convert semantisc into syntax
14:52:55 <roconnor> ReinH: done.
14:53:19 <ReinH> Huh.
14:53:29 <geekosaur> kwmiebach, if you only had that cabal binary then you were clearly not using ubuntu's package
14:53:45 <geekosaur> (possibly you first installed during the period when ubuntu didn't have a package)
14:55:27 * hackagebot airbrake 0.1.0.0 - An Airbrake notifier for Haskell  http://hackage.haskell.org/package/airbrake-0.1.0.0 (JoelTaylor)
14:56:26 <Saizan> roconnor: only works with fairly peculiar semantics though :)
14:57:10 <roconnor> Saizan: I didn't notice any issues that wouldn't work in other situations.
14:58:21 <Saizan> well, i just mean you have to include syntax itself into the semantics, the technique does scale to lots of languages though
14:59:51 <kwmiebach> I started fresh. Now almost everything seems to work, compiling a lot of packages, but from time to time this: cabal: /usr/local/share/doc: permission denied
15:00:45 <roconnor> Saizan: I sort of though that if we think of normal domains as some initial algebra (for an invariant functor) then these domain with the extra syntax bit is another algebra of the same functor.
15:01:10 <roconnor> Saizan: as so you can just use the unique arrow from the "inital" semantics to the "NBE" semantics.
15:01:26 <roconnor> Saizan: making evaluation into a 3 step process
15:02:07 <roconnor> Saizan: (1) compute standard semantics of your syntax.  (2) convert standard semantics to "syntax decorrated" NBE semantics.  (3) Convert NBE semantics to syntax.
15:02:08 <kwmiebach> I created /usr/local/share/doc/ with 777, now this: cabal: /usr/local/share/doc/transformers-0.4.1.0: inappropriate type
15:02:38 <geekosaur> why are you installing stuff globally
15:03:39 <roconnor> Saizan: I suppose I fused out that middle step by hand.  I hand my interpreter an algebra for my domain and say go.
15:04:01 <Saizan> roconnor: that'd be pretty cool, what functor would you use for e.g. STLC?
15:05:06 <roconnor> Saizan: my language was untyped, so for a typed calculus you'd want to have a typed indexed set of functors.    So let's see...
15:05:20 <Saizan> oh, LC would be fine too
15:07:03 <roconnor> so for untyped lambda calclus the functor is data UTC dom = UTC (dom -> dom)  which is maybe too trivial to be illuminating.
15:07:15 <roconnor> s/UTC/ULC/
15:07:22 <roconnor> (stupid fingers)
15:09:13 <kwmiebach> geekosaur: thanks a lot. I give up for today, will try again tomorrow. I need more time for this. :)
15:11:16 <roconnor> data STLC a dom where IntegerDom :: Integer -> STLC Integer dom; FunctionDom :: (dom a -> dom b) -> STLC (a -> b) dom
15:11:34 <roconnor> Saizan: I think the above is a GADT version of the functor
15:12:04 <roconnor> maybe I should flip the arguments
15:12:26 <roconnor> data STLC dom a where IntegerDom :: Integer -> STLC dom Integer; FunctionDom :: (dom a -> dom b) -> STLC dom (a -> b)
15:12:38 <roconnor> STLC :: (* -> *) -> (* -> *)
15:13:08 <roconnor> so taking the fixpoint of STLC gives you the standard initial algebra for semantics of the STLC.
15:14:28 <dolio> Going backward from U = U -> U to syntax is often a problem, though.
15:14:30 <oisin640> I am having a hard time writing a zipWith function for my Vector data type. The problem is that I am only able to define a partial function, when the vectors are of equal length. http://lpaste.net/104960 The commented out line is what I am struggling with defining with errors about the vector's dimension.
15:14:40 <Saizan> roconnor: right
15:15:52 <Saizan> so you're saying that the eval part is done through an algebra STLC NBE a -> NBE a
15:15:53 <roconnor> data NBEdom a = Synatx LambdaTerm | Semantics (STLC NBEdom a)
15:16:20 <roconnor> I'm flying by the seat of my pants here, but my claim is that NBEdom is an algebra of STLC.
15:16:44 <roconnor> nbeDomAlg :: STLC NBEdom a -> NBEDom a
15:17:21 <roconnor> er right
15:17:32 <roconnor> nbeDomAlg = Sematnics
15:17:34 <roconnor> heh
15:17:39 <roconnor> that was easier than I thought.
15:19:13 <roconnor> So you should be able to turn (Mu STLC a) into NBEDom a.
15:19:58 <roconnor> or, perhaps more simply, give the algebra to your inteperpreter so it creates (NBEDom a) directly instead of (Mu STLC a).
15:20:39 <dolio> Is Mu STLC supposed to be the syntax?
15:20:54 <Saizan> no, semantics
15:21:09 <dolio> Oh.
15:21:56 <Saizan> i feel like the contravariance is going to but you somewhere in all of this, but maybe i'm just an unbeliever
15:22:07 <Saizan> s/but/bite/
15:24:55 <roconnor> Saizan: I sort of agree; I can hardly believe it actually worked.
15:25:42 <mietek> Is it possible to say `cabal --config-file=foo` and still have cabal use $PWD/cabal.config ?
15:34:35 <Saizan> roconnor: i guess i can see how it works with a closed environment, because it's all going to be functions until you start folding NBEDom a into syntax
15:39:55 <zwer> I have been out of the loop.. what happened to truecrypt? :(
15:39:56 <zwer> did anything else surface besides the initial announcement?
15:40:20 <bitemyapp> zwer: this is #haskell :)
15:40:52 <zwer> wrong channel
15:44:54 <albeit> Is there any way to pattern match or case against another variable instead of a literal? Like "case key of val1 -> ; val2 ->"?
15:45:00 <roconnor> Saizan: as long as your enviroment is mapping identifiers to dom where dom is the type of the algebra you are fine.
15:45:46 <geekosaur> albeit: not like that, no. you may be looking for guards or MultiWayIf
15:46:20 <roconnor> Saizan: when you are just handed the algebra as your interface to dom, you, of course, cannot create any "syntax elements" of the domain.
15:46:31 <geekosaur> patterns match the shape of a type, you can't store that in a "variable" (and they're not variables)
15:46:32 <albeit> geekosaur: So in either case I would have to do "key==val1 ... key==val2" etc... making an explicit comparison?
15:46:54 <albeit> key / val1 / val2 are all Ints, if it matters
15:47:04 <geekosaur> yes. you're trying to treat pattern match case like an imperative value case
15:47:07 <geekosaur> and it's not
15:47:15 <albeit> Okay
15:47:28 <roconnor> Saizan: also, there is not way to pattern match on elements of dom, because you just have an algebra.
15:47:49 <Saizan> roconnor: if your environment maps to the algebra (something like NBEdom i expect you mean) you can't construct a Mu STLC a first
15:49:37 <roconnor> Saizan: well your environment maps to dom.  so if dom = Mu STLC then your environment should contain Mu STLC values.
15:50:05 <Saizan> right, so it'd be a closed environment
15:50:58 <roconnor> Ah yes
15:50:59 <roconnor> sure
15:51:20 <Saizan> but i guess you can lambda-lift your term instead, if you need to stay open
15:51:52 <roconnor> Saizan: So I also pass another set of operations on dom to the intepreter to handle things that are not constructors.
15:52:11 <roconnor> Saizan: this part of my intepreter is not so elegant.
15:53:20 <roconnor> Saizan: e.g. for STLC i need to pass (app :: dom (a -> b) -> dom a -> dom b)
15:53:32 <roconnor> in order to interpret applications.
15:54:28 <roconnor> when dom is (Mu STLC) then app is the obvious thing
15:54:55 <roconnor> when dom is NBEdom, then app needs to reflect syntax
15:54:56 <roconnor> e.g.
15:55:15 <roconnor> nbeApp :: NBEDom (a -> b) -> NBEDom a -> NBEDom b
15:55:46 <roconnor> nbeApp (Semantics f) (Semantics x) = Semantics (f x)
15:57:14 <roconnor> nbeApp (Syntax f) (Semantics x) = Syntax (APP f (reify x))
15:57:29 <roconnor> nbeApp (Syntax f) (Syntax x) = Syntax (APP f x)
15:57:30 <Saizan> right
15:57:55 <Saizan> that doesn't come just from the algebra
15:58:15 <roconnor> Er let me try again
15:58:39 <roconnor> nbeApp (Semantics f) x = f x
15:59:09 <roconnor> nbeApp (Sytnax f) x = reflect (APP f (reify x))
15:59:20 <roconnor> where reflect = Syntax
15:59:33 <roconnor> and reify is a complicated thingy.
16:00:19 <Saizan> btw i find it works much more nicely if you disallow syntax for types with eta rules
16:03:24 <Arnob> Hi all
16:03:32 <Arnob> I am having some problems building aeson
16:03:46 <Arnob> aeson-0.7.0.3 failed during the building phase. The exception was: ExitFailure 1
16:03:48 <roconnor> Saizan: so ... disallow sytax for functions?
16:03:53 <Arnob> Data/Aeson/Encode.hs:37:66:     Module `Data.Scientific' does not export `scientificBuilder'
16:04:26 <geekosaur> that one is known, IIRC, it's a version skew issue but I don't recall the fix off the top of my head
16:04:45 <Saizan> roconnor: yeah
16:05:11 <roconnor> Saizan: what does it mean to disallow syntax for functions?
16:05:38 <Arnob> geeoksaur: Was that regarding my aeson issue?
16:06:12 <geekosaur> yes
16:07:27 <Arnob> I assume I need to downgrade my version of scientific?
16:07:48 <Saizan> roconnor: data NBEdom a where IVal :: Integer -> NBEdom Integer; ISyn :: LambdaTerm -> NBEdom Integer; FunVal :: (NBEdom a -> NBEdom b) -> NBEdom (a -> b)
16:16:43 <roconnor> Saizan: And you can still write reify?
16:17:11 <bergey> Arnob: add a constraint scientific<0.3 in your cabal-install command
16:17:18 <Saizan> roconnor: yep
16:18:03 <bergey> Or upgrade whatever is keeping you from using aeson-0.7.0.6.  Or constrain to aeson-0.7.0.4, which indirectly constrains scientific.
16:18:40 <roconnor> normally I'd write reify (FunVal f) = do v <- fresh; return reify (f (reflect (var v)))
16:18:56 <roconnor> Saizan: but I cannot reflect (var v) with yours.
16:19:29 <Saizan> roconnor: you just have to eta-expand it, you do need to be able to pattern match on types though
16:20:30 <roconnor> eta expand what?
16:21:12 <Saizan> the reflection
16:21:15 <roconnor> Saizan: oh
16:21:27 <benzrf> hmmmmmmmm
16:21:33 <benzrf> is there anything like buddha still in existence
16:21:41 <roconnor> Saizan: I can almost see what you are getting at.
16:21:55 <benzrf> :t reify
16:21:56 <lambdabot> Not in scope: ‘reify’
16:22:00 <benzrf> :t fresh
16:22:01 <Saizan> roconnor: wrapping it in enough FunVal, according to the type
16:22:01 <lambdabot> Not in scope: ‘fresh’
16:22:03 <benzrf> h
16:22:30 <bitemyapp> benzrf: what?
16:22:39 <benzrf> bitemyapp: buddha as in the debugger
16:22:59 <benzrf> man, why isnt there a ghc api for controlled evaluation of expression graphs >:{
16:24:12 <roconnor> Saizan: so if I reify a function of type a -> (a -> b) -> b  I get
16:25:29 <roconnor> \a -> \f -> (\x -> f x) a
16:25:49 <roconnor> That doesn't seem so pretty :D
16:26:02 <roconnor> but I suppose that is eta-long beta-short normal form.
16:26:15 <roconnor> Saizan: okay
16:26:16 <Saizan> the last beta redex is going to be reduced
16:26:31 <roconnor> Saizan: reduced by who?
16:26:34 <awestroke> @pl \a -> \f -> (\x -> f x) a
16:26:35 <lambdabot> flip id
16:26:40 <roconnor> oh right
16:26:42 <Saizan> roconnor: by app
16:26:55 <roconnor> Saizan: I'll have to mediate on this.
16:26:59 <benzrf> awestroke: you know that \a -> \f is the same as \a f ->
16:27:00 <benzrf> right
16:27:15 <roconnor> Saizan: things are less beautiful in the untyped setting. ... big surprise.
16:27:22 <Saizan> roconnor: heh
16:27:34 <benzrf> wait crud im a moran
16:27:36 <awestroke> benzrf: yes
16:27:47 <benzrf> awestroke: i just saw you pl'ing ThatOtherPerson_
16:27:49 <benzrf> *that
16:27:52 <Saizan> roconnor: anyhow maybe it's actually ugly operationally, but it simplified my types
16:27:52 <benzrf> :p
16:27:55 <benzrf> automatic response
16:28:35 <awestroke> @pl flip $
16:28:35 <lambdabot> (line 1, column 7):
16:28:35 <lambdabot> unexpected end of input
16:28:35 <lambdabot> expecting white space or simple term
16:31:02 <roconnor> @pl flip ($)
16:31:03 <lambdabot> flip id
16:31:22 <JakeEhrlich> So I just realized that the identity function is the only inhabitant of type a -> a. What other types only have one inhabitant?
16:31:51 <Saizan> a -> b -> a :)
16:31:56 <roconnor> JakeEhrlich:  ()
16:32:42 <JakeEhrlich> Are there anymore interesting examples? Ones that are a) not constant and b) not just the identity type with extra stuff?
16:33:14 <JakeEhrlich> by not constant I mean not unit
16:34:04 <Cale> (a -> c) -> (b -> c) -> Either a b -> c
16:34:13 <roconnor> JakeEhrlich: ((a -> (b -> r) -> r) -> (a -> r) -> r) -> (a -> r) -> r
16:34:51 <zwer> JakeEhrlich (a, b) -> a
16:34:59 <JakeEhrlich> Those are good ones! I'll have to think about those.
16:35:16 <JakeEhrlich> zwer: That is basiclly a -> b -> a
16:35:34 <jmcarthur> :t uncurry const
16:35:35 <lambdabot> (c, b) -> c
16:35:35 <Arnob> Yep, that fixed it. Aeson 0.7.3 needs scientific < 0.3
16:36:07 <JakeEhrlich> :t const
16:36:08 <lambdabot> a -> b -> a
16:36:42 <JakeEhrlich> roconnor has the most interesting one. I'm still trying to figure it out
16:37:04 <roconnor> @djinn (a -> c) -> (b -> c) -> Either a b -> c
16:37:04 <lambdabot> f a b c =
16:37:05 <lambdabot>     case c of
16:37:05 <lambdabot>     Left d -> a d
16:37:05 <lambdabot>     Right e -> b e
16:37:18 <roconnor> @djinn ((a -> (b -> r) -> r) -> (a -> r) -> r) -> (a -> r) ->
16:37:19 <lambdabot> Cannot parse command
16:37:33 <jmcarthur> @djinn ((a -> (b -> r) -> r) -> (a -> r) -> r) -> (a -> r) -> r
16:37:33 <lambdabot> f a b = a (\ c _ -> b c) b
16:37:41 <roconnor> jmcarthur: aww you gave it away. :D
16:37:54 <JakeEhrlich> I looked too!
16:37:55 <jmcarthur> ... but you tried to!
16:38:06 <roconnor> heh
16:38:35 <jmcarthur> @. pl djinn ((a -> (b -> r) -> r) -> (a -> r) -> r) -> (a -> r) -> r
16:38:35 <lambdabot> f = join . (. (const .))
16:39:05 <JakeEhrlich> Is it decidable in general if a type has a unique inhabitant?
16:39:36 <jmcarthur> :t liftM join (flip liftM (liftM return))
16:39:36 <lambdabot> (Monad m1, Monad m) => (m (m1 a1) -> m a1 -> a) -> m a1 -> a
16:46:54 <dwcook> JakeEhrlich: I was curious about that too and managed to come onto the term "contractible" which in turn led to this http://nlab.mathforge.org/nlab/show/contractible+type
16:47:10 <benzrf> heyj:
16:47:12 <benzrf> *hey
16:47:35 <benzrf> what's the most widely-accepted way to read in a haskell file, parse it, do transformations, then use the transformed code?
16:47:44 <benzrf> can template haskell do that?
16:47:51 <benzrf> or does it require explicitly annotating the read file?
16:49:36 <benzrf> should i use Language.Haskell.Exts?
16:49:49 <JakeEhrlich> dwcook: Thanks! Reading now!
16:51:05 <trap_exit> I find myself needing to update a deeply nested data structure. I believe I need something called "lens". Can someone point me to a quick handons on tutorial?
16:51:20 <dwcook> JakeEhrlich: Disclaimer: There may not be a direct answer there, just the means to look for one.
16:51:21 <trap_exit> I care about getting something minimal working more than the deep categorical theoreis of how it's similar to XYZ algebra.
16:52:03 <JakeEhrlich> dwcook: I figured. It sounds pretty undecidable to me so my hopes are not up
16:53:18 <benzrf> trap_exit: fun fact: learning lens is like learning about haskell in the first place except maybe divide by 3
16:53:32 <trap_exit> ?
16:53:42 <benzrf> trap_exit: the basic idea of the part of it concerning lenses (and not prisms or traversals or whatever) is fairly simple though
16:53:46 <trap_exit> yeah
16:53:46 <dwcook> trap_exit: start here and follow whatever link in the description suits you. http://hackage.haskell.org/package/lens
16:53:50 <trap_exit> thet'ere s a getter and a setter
16:53:52 <trap_exit> and they compose
16:53:55 <benzrf> trap_exit: a lens is a 'pointer' to part of a structure
16:53:57 <benzrf> trap_exit: they compose
16:54:01 <benzrf> trap_exit: use over or set to modify
16:54:03 <benzrf> view to get
16:54:27 <benzrf> trap_exit: and dont look at the types or your head will explode
16:54:30 <benzrf> :t view
16:54:31 <lambdabot> MonadReader s m => Getting a s a -> m a
16:54:41 <benzrf> :t over
16:54:41 <trap_exit> data Doc = Doc Tag Attrs (Map Id Doc)
16:54:42 <lambdabot> Profunctor p => Setting p s t a b -> p a b -> s -> t
16:54:45 <trap_exit> the (Map Id Doc) = childs
16:54:50 <trap_exit> how do I get a lens for a key into childs
16:54:59 <trap_exit> i.e. say "view childs w/ key k"
16:55:01 <benzrf> ix
16:55:03 <trap_exit> or "set chidls w/ key k to value v"
16:55:11 <benzrf> but ix is a traversal or something
16:55:12 <benzrf> not a lens
16:55:24 <benzrf> trap_exit: why not just use the standard setting functions
16:55:34 <benzrf> doesnt sound like you need the Industrial Strength Bullshit(tm) of lens
16:55:44 <trap_exit> https://gist.github.com/tkxue/977ce046eaee8c87325d <-- whis is what I'm writing
16:55:52 <trap_exit> doc__set_child is not working yet
16:55:58 <trap_exit> how do I write doc__set_child and doc__get_child as lens ?
16:56:40 <benzrf> trap_exit: haskell has some built in sugar for 'updating' records
16:56:50 <trap_exit> I want to learn how to use lens.
16:57:03 <trap_exit> It matches Clojure's get-in, assoc-in, and udpate-in well
16:57:12 <trap_exit> I want to learn how to use lens. How do I write the above with lens? :-)
16:57:15 <benzrf> @let SomeRecordType = SomeRecord {field1 :: Int, anotherField :: String, yetAnotherField :: [String]}
16:57:15 <lambdabot>  Parse failed: NamedFieldPuns is not enabled
16:57:20 <benzrf> @let data SomeRecordType = SomeRecord {field1 :: Int, anotherField :: String, yetAnotherField :: [String]}
16:57:21 <lambdabot>  Defined.
16:57:26 <benzrf> trap_exit: check this out
16:57:30 <benzrf> oh wait crud
16:57:32 <trap_exit> benzrf: taking notes
16:57:35 <edwardk> trap_exit: assuming you had data Doc = Doc { _tag :: Tag, _attributes :: Attrs, _children :: Map Id Doc }; makeLenses ''Doc -- then you can use foo & children.at tag ?~ newvalue
16:57:38 <edwardk> er
16:57:39 <benzrf> @let data SomeRecordType' = SomeRecord {field1 :: Int, anotherField :: String, yetAnotherField :: [String]} deriving Show
16:57:40 <lambdabot>  .L.hs:152:24:
16:57:40 <lambdabot>      Multiple declarations of ‘SomeRecord’
16:57:40 <lambdabot>      Declared at: .L.hs:149:23
16:57:40 <lambdabot>                   .L.hs:152:24
16:57:40 <lambdabot>  
16:57:43 <benzrf> fff
16:57:46 <benzrf> @reset
16:57:46 <lambdabot> Say again?
16:57:50 <benzrf> @udnefine
16:57:50 <lambdabot> Maybe you meant: undefine define
16:57:53 <benzrf> @undefine
16:57:53 <lambdabot> Undefined.
16:58:01 <benzrf> @let data SomeRecordType = SomeRecord {field1 :: Int, anotherField :: String, yetAnotherField :: [String]} deriving Show
16:58:03 <lambdabot>  Defined.
16:58:04 <edwardk> foo & children.at someId ?~ someNewChild
16:58:05 <benzrf> ok, trap_exit
16:58:38 <trap_exit> wtf does "foo & children.at someId ?~ someNewChild" mean ?
16:58:42 <benzrf> > let aRecord = SomeRecord {field1 = 3, anotherField = "test", yetAnotherField = []} in aRecord {anotherField = "foo"}
16:58:44 <lambdabot>  SomeRecord {field1 = 3, anotherField = "foo", yetAnotherField = []}
16:58:47 <benzrf> trap_exit: ^^
16:58:53 <benzrf> trap_exit: you can 'update' a field like that
16:59:10 <edwardk> trap_exit: you asked how to do a big composite operation, so i told you how. there are lots of parts there to explore individually
16:59:12 <trap_exit> yes, but this is standard notation, and not lens, is it not?
16:59:14 <benzrf> trap_exit: edwardk is the author of lens; the code he wrote is incomprehensible lens gibberish ;)
16:59:22 <benzrf> trap_exit: i do not think you need lens
16:59:26 <benzrf> trap_exit: how well do you know haskell?
16:59:34 <trap_exit> I am familiar with COq (for typing)
16:59:36 <trap_exit> but new to Haskell
16:59:43 <benzrf> trap_exit: do you grok monads
16:59:46 <trap_exit> I feel that lens is the scalable solution
16:59:56 <edwardk> i am somewhat distracted, so i'm not going to bother arguing with benzrf at the moment ;)
16:59:58 <trap_exit> benzrf: I do not; lens is just a -> b and b -> a -> a
17:00:13 <trap_exit> edwardk: you two should box
17:00:17 <benzrf> trap_exit: do you grok monads
17:00:18 <edwardk> trap_exit: the lens package bundles that concept up in a funny way
17:00:21 <trap_exit> benzrf: no
17:00:25 <benzrf> don't learn lens yet. it is to powerful for your level of knowledge IMO
17:00:32 <trap_exit> no
17:00:34 <trap_exit> I wnat to use lens.
17:00:41 <Cale> benzrf: wtf
17:00:48 <benzrf> Cale: well
17:00:57 <benzrf> i guess learning to use lens trivially at the surface and not looking any deeper is OK
17:01:05 <benzrf> but then how will you read the types, or figure out the errors?
17:01:14 <benzrf> tsk tsk
17:01:22 <edwardk> benzrf: by asking on #haskell-lens and getting drawn in like everyone else? =)
17:01:35 <benzrf> edwardk: ah, but when i started i already understood most of the basic haskell Corey
17:01:39 <benzrf> *core
17:01:41 <benzrf> o=
17:01:44 <edwardk> trap_exit: have you seen SPJ's presentation on lenses?
17:01:47 <benzrf> edwardk: trap_exit is so new to haskell that he doesnt even grok monads yet
17:01:56 <bitemyapp> Haskell Corey Haines
17:01:59 <benzrf> i think he should get a better handle on the language before you smother him in profunctors
17:02:08 <bitemyapp> benzrf: profunctors are easier than monads.
17:02:13 <benzrf> w/e
17:02:15 <trap_exit> fuck it; I'm going to just read the types on https://hackage.haskell.org/package/lens and go from there
17:02:22 <benzrf> trap_exit: good luck m8 :^)
17:02:30 <edwardk> benzrf: i had no intention of smothering him in profunctors to explain the basic idea of what a lens is. relax.
17:02:35 <benzrf> kk
17:02:50 <Cale> benzrf: If he understands Coq, the types should not be a big deal for him
17:02:59 <bitemyapp> benzrf: I don't necessarily disagree with your point, but what makes lens non-trivial is the composition of many individually not-too-hard things (except for maybe traversals in the general case) into something that developed according to context and experience.
17:03:11 <edwardk> trap_exit: join #haskell-lens if you want straight answers rather than 'oh my god lenses are scary'
17:03:12 <platz_>  /win size 30
17:03:16 <bitemyapp> the way lens gets learned doesn't usually involve going through the experience the lens developers did.
17:03:40 <benzrf> trap_exit: you are jumping into a rabbit hole before you know how to run
17:03:41 <benzrf> >:(
17:03:56 <trap_exit> will join, after listening to https://skillsmatter.com/skillscasts/4251-lenses-compositional-data-access-and-manipulation#showModal?modal-signup-complete
17:03:58 <NemesisD> anyone know what an appropriate file would be for a program creating a log file?
17:03:58 <dwcook> Fortunately rabbit holes are a bit cramped for running
17:04:00 <edwardk> benzrf: and yes, if he knows coq, he should have no problem understanding how the types flow, even if the individual building blocks are exotic
17:04:05 <benzrf> f-fine
17:04:09 <benzrf> dwcook: >:P
17:04:11 <NemesisD> file mode* octal
17:04:22 * benzrf crawls back into his hole
17:05:06 <edwardk> benzrf: i can appreciate your caution, but you've basically been screaming run at the top of your lungs for the last 10 minutes and not dissuaded him, so let him learn without the noise ;)
17:05:30 <benzrf> ;-;
17:05:55 <bitemyapp> benzrf: actually, I'd like to reinforce that point. When I'm successfully moving somebody through a topic and people are either repeating what I'm saying in the channel or adding low-value noise it's pretty annoying.
17:06:05 <benzrf> =[
17:06:12 <bitemyapp> if you aren't making progress, contributing, and/or somebody else is ready to help them, just pass the baton.
17:06:19 <bitemyapp> benzrf: it's okay, I'm guilty of it too!
17:06:29 <bitemyapp> benzrf: we know you just want to help, but we should seek to improve how we help!
17:10:26 <piezoid> for me learning lenses is like learning emacs, I need a cheat sheet arround for a long period
17:11:47 <benzrf> blah
17:11:56 <benzrf> i keep trying to use _ instead of it in ghci
17:12:47 <piezoid> it would be nice to have a kind of Macro/TH TypeHole wich can reinterpret the unification error for a specific DSL
17:13:26 <benzrf> o:
17:13:29 <benzrf> that would be neat
17:21:43 <benzrf> grrrr
17:22:14 <benzrf> are there any haskell implementations that give an API for controlled graph reduction
17:31:20 <trap_exit> anyone here using Haste? I can "import Control.Lens" from ghci, but I can not "import Control.Lens" from a fiel I compile with Haste
17:32:00 <edwardk> trap_exit: i'm not terribly familiar with haste. i know luite has used lens extensively with ghcjs though
17:33:12 <trap_exit> I've heard that the code ghcjs generated contains an entire javascript runtime to simulate ghc's behavior
17:34:42 <edwardk> well, it can do a lot of impressive things
17:34:58 <edwardk> finalizers, etc.
17:35:17 <trap_exit> finalizers? as in code to run when an object is gc-ed ?
17:35:58 <edwardk> yeah
17:36:21 <edwardk> so you can do decent resource management right in ghcjs
17:36:33 <trap_exit> edwardk: I think this is what I will do.
17:36:41 <trap_exit> I will work through Simon Peyton Jones's talk, inside of Haste
17:36:52 <trap_exit> so I'll end up re-inventing Lens, and it'll be slow, but I'll have a deep understanding
17:36:58 <trap_exit> Thanks for all your help with getting me started. :-)
17:37:04 <edwardk> that'll get you to the idea of a lens
17:37:17 <edwardk> my new york talk can get you more about traversals
17:37:39 <edwardk> https://www.youtube.com/watch?v=cefnmjtAolY
17:37:49 <trap_exit> edwardk: I will watch your NY talk after that. :-)
17:37:52 <edwardk> might be a good place to pick up after SPK
17:37:54 <edwardk> er SPJ
17:38:06 <trap_exit> Cool, thanks again. :-)
17:46:48 <benbangert> if there's already a declaration for a Data.Binary Binarcy class impl, the only way I can 'override' it is by newtyping the thing I want to override and defining the Binary instance for it, yea?
17:47:17 <startling> benbangert: yeah.
17:49:57 <tenforward> hello
17:49:59 <wyager> Would anyone care to critique a draft of a blog post comparing Go to Haskell and Rust?
17:50:35 <bjz_> wyager: I would ask on irc.mozilla.org #rust
17:50:50 <wyager> I will ask there as well. But it’s equally about Haskell
17:51:05 <Maxdamantus> benbangert: you could just not import the instance and add another one, but it won't be used in places that use polymorphic definitions with that constraint that have included the original one.
17:51:21 <wyager> Rust is used as an example of an imperative hindley-milner based language, and Haskell is used as an example of a function hindley-milner based language
17:51:25 <Maxdamantus> I think that's considered a bad thing to do though.
17:51:41 <jle`> typeclass instancing "scopes" is a mess in general
17:52:12 <dsturnbull> wyager: i'd like to read it
17:52:19 <bjz_> wyager: good to know you are asking for advice
17:52:22 <platz_> imperative hindley-milner, kind of intriguing.
17:52:32 <bjz_> wyager: rather than just publishing
17:52:34 <ion> 1337 users
17:52:35 <NemesisD> woah. i'm getting a segfault install haskell-src-exts
17:52:37 <bjz_> wyager: <3
17:52:43 <jle`> i didn't realize that rust is like that
17:52:50 <wyager> bjz_: Thanks :) Want to read?
17:52:55 <jle`> i'd like to read the post once it's done, wyager
17:52:59 <jle`> link to blog?
17:53:01 <bjz_> wyager: can't right now - maybe later
17:53:22 <NemesisD> http://lpaste.net/104961
17:53:29 <bjz_> (heading out for dinner)
17:53:37 <bjz_> wyager: PM me the link
17:53:42 <wyager> jle`: yager.io
17:53:42 <Maxdamantus> Hm. What I said in my first line wasn't quite accurate—it's hard to describe.
17:53:50 <bjz_> wyager: it'll get lost in the scrollback
17:54:04 <rwbarton> NemesisD: https://ghc.haskell.org/trac/ghc/ticket/8768
17:54:14 <Maxdamantus> places that resolve the constraint with that type in polymorphic definitions .. or something.
17:54:29 <jle`> wyager: no rss feed? :'(
17:54:41 <wyager> jle`: I’d never thought about setting one up
17:54:43 <Maxdamantus> if they propagate the constraint on to you in their polymorphic definitions, you'll still be able to use your own instance.
17:54:45 <wyager> I write very infrequently
17:54:51 <wyager> only if I really care about something
17:54:56 <wyager> so it wouldn’t be a very interesting feed
17:55:26 <jle`> wyager: i'd just plop it onto my reader, you'll be a part of a stream of quality posts :)
17:55:38 <NemesisD> rwbarton: i'd prefer not to go through the rigamaroll of installing ghc from source. should i try another version of src-exts then?
17:59:04 <sveit> are there examples/are people familiar with doing ffi directly out to fortran code?
17:59:24 <sveit> or is it better to write a C interface?
17:59:27 <rwbarton> NemesisD: it's been reported with 1.15 also
17:59:33 <rwbarton> not sure what the best workaround is
17:59:49 <jle`> sveit: there's a fortran ffi?
17:59:58 <rwbarton> sveit, #numerical-haskell is familiar with it
18:00:48 <NemesisD> rwbarton: seems like i picked the wrong day to need stack traces
18:00:55 <carter> sveit: yup, as rwbarton
18:00:57 <carter> saids
18:01:09 <carter> sveit: basically you add a _ to the end of the name
18:01:16 <carter> and assume all the args are pointers to distinct values
18:01:26 <carter> and that "usually works"
18:01:26 <carter> :)
18:01:43 <bergey> NemesisD: When I was running into this bug, I realized I didn't actually need profiling for src-exts, I just had it turned on by default.
18:02:37 <NemesisD> rwbarton: 1.15.0 installed for me so i guess i'll count myself lucky
18:02:48 <rwbarton> huh, ok
18:02:52 <rwbarton> the gcc segfault is pretty random
18:03:00 <NemesisD> bergey: if you want to get stack traces for your code you need to have profiling for your dependencies though right?
18:03:06 <carter> what seg fault
18:03:22 <rwbarton> #8768
18:04:05 <carter> oh, is this the one thats bug in gcc 4.8?
18:04:48 <rwbarton> some version of gcc anyways
18:05:45 <benzrf> guuuuuuh
18:06:15 <benzrf> is there a haskell interpreter with an api that lets you work with value graphs
18:06:17 <benzrf> not just ASTs
18:06:21 <benzrf> *through its api
18:09:09 <carter> whats a value graph?
18:09:18 <benzrf> *expression graph maybe
18:09:26 <carter> benzrf: oh, have you seen the interpreter for Ermine?
18:09:30 <carter> its an STG style lang too
18:09:32 <benzrf> what is ermine?
18:09:37 <carter> @google ermine language
18:09:38 <lambdabot> https://github.com/ermine-language
18:10:15 <benzrf> basically i want to be able to control evaluation of an expression tree/graph
18:10:29 <benzrf> i.e. i have the representation of 'foo 1 2'
18:10:33 <carter> what does control mean
18:10:53 <benzrf> then i can use the api to expand that to 'zip [1, 2] "ab"'
18:11:02 <carter> ohhh
18:11:05 <benzrf> and say what i want expanded and what left in a thunk
18:11:17 <carter> you want an implementation of  small step oeprational semantics
18:11:19 <carter> for a lazy language
18:11:26 <carter> whats your use case?
18:11:28 <benzrf> for haskell, if that were possible
18:11:30 <benzrf> =[
18:11:33 <benzrf> carter: debugging of course
18:11:43 <carter> explain
18:11:48 <carter> you can kinda do that with GHCI afaik
18:11:52 <NemesisD> is there such a thing as putting breakpoints in your source code rather than interactively
18:11:54 <benzrf> with a truly awful interface
18:12:06 <benzrf> 'func a b c' returns the wrong value
18:12:11 <benzrf> ok, open the debugger
18:12:12 <carter> whats wrong mean
18:12:19 <benzrf> unexpected =p
18:12:21 <benzrf> expand 'func a b c'
18:12:24 <benzrf> get an expression
18:12:29 <benzrf> resolve parts of it
18:12:33 <benzrf> see which one looks wrong
18:12:39 <benzrf> dig deeper into there
18:12:40 <carter> whats wrong?
18:12:46 <benzrf> carter: you know what i mean!
18:12:48 <carter> nope
18:12:57 <carter> explain like i'm drunk but very lucid
18:13:01 <carter> i'm lucid and sober
18:13:05 <benzrf> basically like http://www.berniepope.id.au/docs/BerniePope.PhD.Thesis.pdf
18:13:05 <carter> but communicat explicitly
18:13:17 <benzrf> carter: i have a function that does not return what i expect
18:13:41 <jle`> benzrf: blasphemy, everyone knows thatif it typechecks, it's correct
18:13:58 <benzrf> therefore, i want to be able to interactively (and possibly gui-based) expand my function application to the body of the function
18:14:12 <benzrf> then evaluate different parts and see which one is producing a value other than what i would expect
18:14:18 <benzrf> http://www.berniepope.id.au/docs/BerniePope.PhD.Thesis.pdf is basically this
18:14:25 <benzrf> but the debugger it describes is defunct
18:14:26 <benzrf> q.q
18:14:43 <NemesisD> -xc doesn't give you line numbers :/
18:14:51 <benzrf> -xc?
18:15:03 <jle`> benzrf: youj mean like turn foldr (+) 0 [1,2,3] into 1 + foldr (+) 0 [2,3]
18:15:04 <NemesisD> +RTS -xc, i'm getting a mysterious thread blocked indefinitely somewhere
18:15:14 <jle`> benzrf: which turns into 1 + 2 + foldr (+) 0 [3]
18:15:15 <benzrf> jle`: something along those lines
18:15:32 <rwbarton> ghc-vis sort of does this too
18:15:32 <benzrf> jle`: but i can control how far and which parts?
18:15:35 <jle`> that'd be neat actually
18:15:36 <benzrf> ghc-vis?
18:15:40 <jle`> like you do it step-by-step
18:15:49 <rwbarton> yes, ghc-vis
18:15:58 <benzrf> again, reading http://www.berniepope.id.au/docs/BerniePope.PhD.Thesis.pdf and this is basically riffing off of that
18:16:35 <carter> benzrf: theres gonna be stack traces in 7.10
18:16:38 <jle`> like take 2 "hello" turns into 'h':take 1 "ello" turns into 'h':'e':take 0 "llo" into "he"
18:16:39 <benzrf> ew
18:16:41 <jle`> that'd be neat
18:16:47 <carter> yeah
18:16:52 <benzrf> jle`: i imagine a gui tool with a tree display
18:17:03 <benzrf> where you can click to expand or reduce nodes
18:17:04 <carter> will make my "die loudly with error "booooooo""  less shitty
18:17:11 <benzrf> and rewind and fast forward
18:17:31 <benzrf> jle`: reduction too though, not just expansion
18:17:36 <benzrf> so i write 'foo a b'
18:17:44 <benzrf> expand into 'some expr this is more complicated >>= stuff'
18:17:51 <carter> benzrf: jle`  i think osa1's GSOC is relevent
18:17:52 <carter> ask him
18:17:55 <benzrf> reduce 'some expr this is more complicated' to '3'
18:18:01 <benzrf> [3] >>= stuff
18:18:12 <benzrf> and i see that that's [3] and not [3, 4, 5]
18:18:13 <Iceland_jack> benzrf: You're talking about being in charge of the evaluation strategy yourself though
18:18:15 <benzrf> rewind
18:18:20 <benzrf> Iceland_jack: to some degree
18:18:22 <carter> benzrf: OOOO, HERMIT
18:18:26 <carter> @google haskell hermit
18:18:27 <lambdabot> http://hackage.haskell.org/package/hermit
18:18:27 <lambdabot> Title: Hackage: hermit: Haskell Equational Reasoning Model-to-Implementation Tunnel
18:18:28 <carter> use that
18:18:40 <carter> granted, you'll go mad
18:18:41 <carter> :)
18:18:44 <benzrf> well,
18:18:44 <benzrf> $ cabal install ghc-vis
18:18:46 <benzrf> oops
18:18:47 <benzrf> wrong paste
18:18:57 <benzrf> let me link you to bernie pope's thesis again =p
18:19:01 <carter> nope
18:19:02 <carter> not reading it
18:19:06 <carter> too much to read already :)
18:19:39 <benzrf> the basic idea is to take a reducible expression tree and let the user define criteria for what correctness means in a function
18:20:14 <benzrf> then do something like a git-bisect on the history of the graph as it's reduced and find where a reduction results in an 'incorrect' value
18:20:33 <benzrf> it apparently outlines a way to implement this in haskell using code rewriting to add interceptino
18:20:37 <benzrf> but i havent got that far in it
18:20:54 <benzrf> apparently there's even an implementation, but it doesnt seem to be on hackage
18:20:57 <benzrf> i found a man page for it
18:21:32 <benzrf> http://manned.org/buddha/4a1dd731
18:23:27 <juhp> does Cabal do --dynamic-too ?
18:25:09 <carter> yes
18:25:15 <carter> if you have 1.18 or 1.20
18:25:20 <carter> also older cabal sucks :)
18:26:32 <juhp> carter, let me check more
18:26:34 <benzrf> setup: The program 'gtk2hsC2hs' version >=0.13.8 is required but the version
18:26:34 <benzrf> found at /usr/bin/gtk2hsC2hs is version 0.13.6
18:26:34 <juhp> thanks
18:26:37 <benzrf> how do fix
18:27:06 <juhp> benzrf, install newer gtk2hs-buildtools?
18:27:25 <benzrf> aha, thats the package name
18:27:29 <benzrf> thanks :-)
18:27:30 <juhp> nod
18:27:56 <juhp> benzrf, sounds like a system file though?
18:28:30 <benzrf> juhp: its ok
18:28:44 <benzrf> i didnt have nonroot gtk2hs-buildtools
18:28:50 <benzrf> so it defaulted there
18:29:28 <juhp> ok - perhaps your package manager could also tell you the package name :)
18:29:47 <benzrf> juhp: hmmmmm?
18:31:08 <juhp> benzrf, eg "rpm -qf /usr/bin/gtk2hsC2hs" => gtk2hs-buildtools :)
18:31:15 <juhp> anyway np :)
18:32:26 <benzrf> juhp: *I* for one use glorious master race debian derivatives
18:33:07 <juhp> yeah i think the deb tools can do it too but I forget the invocation...
18:33:40 <benzrf> setup: The pkg-config package 'gtk+-2.0' is required but it could not be
18:33:47 <benzrf> found.
18:33:49 <benzrf> what do
18:34:27 <juhp> carter, is there a particular Cabal invocation needed trigger --dynamic-too ?
18:34:36 <carter> juhp: having 1.18 or 1.20
18:34:42 <carter> and not having an old ~/.cabal/config
18:34:44 <juhp> hehe - I have that
18:34:45 <juhp> okay
18:34:50 <juhp> thanks
18:35:21 <juhp> benzrf, same thing again ;)  I guess you need libgtk2-dev or something like that
18:35:33 <carter> if you have any TH going on, dynamic-too should hapen
18:35:43 <juhp> carter, only?
18:35:46 <carter> idk
18:35:47 <carter> i forget
18:35:54 <juhp> hmm
18:35:55 <carter> i just use 1.20 cabal install and a fresh cabal config
18:35:59 <carter> how fresh is your cabal config
18:36:02 <carter> cat it and lpaste it
18:36:13 <juhp> yeah that was the impression I got after grepping for dynamic-too
18:36:39 <juhp> carter, ah I meant Cabal not cabal :)
18:36:42 <juhp> doh
18:37:43 <juhp> I see ghc using dynamic-too when building but not anything else apparently - well I haven't looked hard
18:38:07 <juhp> carter, this is for package building not cabal installing :)
18:38:15 <carter> sound the same to me
18:38:49 <juhp> carter, perhaps - Setup vs cabal-install :)
18:38:59 <carter> your cabal config file stil matters
18:39:02 <carter> cat the fucker
18:39:07 <carter> and lpaste it
18:39:23 <benzrf> cat the fucker
18:39:28 <benzrf> lel
18:39:34 <juhp> ah okay Cabal uses ~/.cabal/config ?
18:39:39 <juhp> interesting
18:39:45 <carter> you have an old cbal config
18:39:47 <carter> i bet you
18:39:51 <carter> cat it
18:39:52 <juhp> okay
18:40:43 <juhp> is a newer .cabal/config compatible with older cabal too?
18:40:57 <carter> yup
18:41:01 <carter> well
18:41:03 <erikd> juhp: not always
18:41:07 <carter> why would you use older cabal?
18:41:13 <carter> :)
18:41:45 <juhp> I generally prefer to use system cabal :)
18:41:55 <juhp> dog-fooding and that
18:42:01 <carter> juhp:... you don't want parallel package builds/
18:42:05 <carter> do you hate yourself?
18:42:08 <carter> :)
18:42:30 <juhp> I look forward to running 1.18  with ghc-7.8 :)
18:42:46 <benzrf> >[  1 of 208] Compiling Graphics.UI.Gtk.ModelView.Sequence ( Graphics/UI/Gtk/ModelView/Sequence.hs, dist/build/Graphics/UI/Gtk/ModelView/Sequence.o )
18:42:55 <benzrf> >[  1 of 208]
18:42:56 <benzrf> >208
18:42:58 <carter> benzrf: cabal 1.20 has paralle package builds
18:42:59 <benzrf> :{
18:43:16 <carter> if you're on 7.8, you can also get parallel module builds
18:45:03 <tnks> hey guys, is there a way to get warnings on unnecessary imports?
18:45:14 <carter> yes
18:45:16 <carter> -wall
18:45:20 <carter> * -Wall
18:45:25 <carter> theres some pecific flag
18:45:26 <tnks> carter: oh cool, I didn't realize that Wall did that.
18:45:37 <tnks> does it do that by default?
18:45:41 <carter> jah
18:45:46 <tnks> okay, I missed that.
18:46:27 <marchelzo> what is the best way to do a list comprehension with two variables without doing every combination of the list elements. Like [ a+b | a<-[1,2,3], b<-[1,3,5] ] and only get back [2,5,8]
18:46:39 <pqmodn> zip
18:46:51 <marchelzo> instead of [2,4,6,3,5,7,4,6,8]
18:47:04 <marchelzo> ok thats what I am doing. I was just wondering if there was a better way
18:47:07 <marchelzo> thanks
18:47:08 <pqmodn> > zipWith (+) [1,2,3] [1,3,5]
18:47:10 <benzrf> marchelzo: zipWith
18:47:10 <lambdabot>  [2,5,8]
18:48:53 <rwbarton> there's also some parallel list comprehension thing that nobody uses as far as I know
18:49:14 <juhp> carter, well I regenerated .cabal/config and diffed - no significant differences
18:49:27 <benzrf> yo i installed ghc-vis
18:49:31 <juhp> anyway I'll try a bit harder i guess
18:49:34 <wyager> marchelzo: Are you familiar with Hoogle? It’s very useful for finding concise functions like zipWith
18:49:36 <benzrf> but
18:49:37 <benzrf> unknown command ':vis'
18:49:48 <wyager> You can type in the type signature of what you want and it will find a matching function
18:50:14 <wyager> in this case, you might try “(a -> a ->  a) -> [a] -> [a] -> [a]”
18:50:20 <marchelzo> I knew about zipWith, but the thing I'm actually trying to do is not just adding the elements. That was just a contrived example to explain what I was looking for.
18:50:42 <wyager> Although that doesn’t work...
18:51:15 <benzrf> marchelzo: you can use it with any binary func...
18:51:32 <pqmodn> @hoogle (a -> b -> c) -> [a] -> [b] -> [c]
18:51:34 <lambdabot> Prelude zipWith :: (a -> b -> c) -> [a] -> [b] -> [c]
18:51:34 <lambdabot> Data.List zipWith :: (a -> b -> c) -> [a] -> [b] -> [c]
18:51:34 <lambdabot> Control.Applicative liftA2 :: Applicative f => (a -> b -> c) -> f a -> f b -> f c
18:51:34 <wyager> Looks like you have to put a->b->c. That’s too bad
18:51:58 <wyager> I wish Hoogle would automatically try replacing “b” and “c” with “a"s
18:53:03 <pqmodn> it seems like sometimes it finds things that are more general than what i searched, other times it doesn't
18:53:49 <benzrf> oh wait im a moraon
18:53:55 <kadoban> Are there currently any haskell cross-platform GUI options out there? Windows/*nix especially? I'm not seeing much, especially anything that looks maintained...
18:54:03 <jle`> kadoban: html5+js :)
18:54:07 <jle`> hehe
18:54:12 <kadoban> :-/
18:54:43 <benzrf> kadoban: threepenny-gui
18:55:22 <kadoban> benzrf: seems kinda goofy though, web based? I'd like something that at least appears to be a normal GUI, using OS widgets and such
18:55:33 <kadoban> Maybe wxHaskell I guess?
18:58:58 <dsturnbull> gtk2hs looks alright
18:59:48 <cschneid> What's the name of the haskell bootstrap project template?
19:00:02 <cschneid> ie, setup a good cabal, test suite, etc.
19:00:09 <kadoban> Oh ya, I guess gtk can run on windows, can't it? That might work.
19:01:05 <dsturnbull> based on http://www.onikudaki.net/blog/archives/6 it looks decent, gui-wise and code-wise
19:01:24 <benzrf> eeehhh
19:02:04 <tommd> How many times do I compile 'text' in any given week?  The answer used to be zero, but now that cabal has sandboxes I find the answer is... a lot.
19:02:12 <benzrf> urgh
19:02:21 <benzrf> ghc-vis sezL
19:02:23 <benzrf> *
19:02:24 <benzrf> ghc-vis sez:
19:02:25 <benzrf> ghc: Error running utility program: Error messages from dot:
19:02:40 <jle`> tommd: haha.  i hear Nix OS is supposed to fix things like that
19:03:13 <kadoban> I was really hoping for something Qt in haskell, but that seems to have died :-/ Oh well, I guess I'll mess with gtk2hs and wxhaskell and see which seems easier. Maybe I'll check out threepenny-gui too, just because the code looks nice...don't think I can see myself selling clients on that one though most likely.
19:05:37 <jle`> ocharles: do you know that your blog never registers as an article for Pocket/ReadItLater? :/
19:06:01 <jle`> ocharles: i guess it's not your fault, but just wondering if you were aware
19:16:33 <fleecer> Hey peeps. Any tips/tricks/guidelines for learning Haskell? I'm currently following learnyouahaskell.com, but was curious about 'undocumented' tips and tricks
19:17:36 <fleecer> (bginfo: I feel comfortable with C, C++, Python, and Java)
19:17:37 <benzrf> fleecer: use ghci
19:17:42 <benzrf> hang around in this channel
19:17:45 <Iceland_jack> “There is no royal road to Haskell.”
19:17:54 <benzrf> don't expect it to be anything at all like what you've used before
19:18:01 <Iceland_jack> That being said, read a lot of code, read papers, hang around on r/haskell and #haskell
19:19:07 <benzrf> fleecer: if haskell seems harder than other languages, it is not because haskell is hard, but because the basic concepts in it are not shared with c/python/java
19:19:13 <kazagistar> fleecer: there are endless "tricks", a great way to find them is to write code, and ask for suggestions
19:19:16 <benzrf> so you have to learn more
19:19:20 <c_wraith> fleecer: I agree that hanging around here is a good idea, but keep in mind that people will often discuss things that make no sense to you. If you're curious, ask questions, but don't think you need to know those things. :)
19:19:21 <glguy> fleecer, The trick is to pick a project and learn enough to implement it
19:19:24 <spott> I asked this earlier, then got pulled away before I could continue:  Has anyone worked through "write a scheme in 48 hours"?
19:19:30 <Iceland_jack> benzrf: The two aren't exclusive
19:19:58 <benzrf> spott: i wrote a scheme in a little more than 48 hours but i didnt use that tutorial
19:20:01 <benzrf> ;)
19:20:35 <spott> you are a better CS than me...  I'm learning about writing interpreters using that tutorial
19:20:57 <spott> in scheme: (cons 1 2) -> (1 . 2), right?
19:21:22 <spott> but (+ (1 . 2)) is an error?
19:21:28 <platz> I'm also a little tired of people complaining about Haskell's syntax.  IMHO the syntax is pretty thin, but the semantics are another thing
19:21:28 <fleecer> Thanks y'all :) All of that follows what I normally try to do when learning something new. Should I be looking at any other resources than larnyouahaskell.com?
19:21:53 <benzrf> fleecer: the haskell wiki may be helpful but it tends to assume a higher level of knowledge than you have
19:22:08 <benzrf> fleecer: i recommend just reading lyah until you at *least* know what a functor is
19:22:17 <kazagistar> spott: functions are followed by a tail list of parameters, with a nil terminator
19:22:48 <kazagistar> (+ . ( 1 . ( 2 . () ) ) ) = (+ 1 2)
19:22:50 <platz> In laziness I think people just use syntax and semantics interchangeably
19:22:52 <fleecer> benzrf: Thanks a bunch. Do you know if there are any specific "guides" for moving from C/C++ to Haskell, or should I just google that?
19:22:54 <acar> flebron: alse see http://www.vex.net/~trebla/haskell/index.xhtml
19:23:01 <acar> ums wrong nick.
19:23:05 <benzrf> fleecer: just read lyah >.<
19:23:07 <Iceland_jack> fleecer: You should treat it like a new language
19:23:08 <flebron> :)
19:23:08 <platz> i.e. connotation
19:23:09 <acar> fleecer: alse see http://www.vex.net/~trebla/haskell/index.xhtml
19:23:14 <benzrf> fleecer: it doesnt matter which language you came from because it is equally differen
19:23:17 <benzrf> t
19:23:23 <acar> sorry flebron :)
19:23:43 <Iceland_jack> trying to find similarities with C or C++ will hurt more than it will help
19:24:00 <fleecer> Fair enough
19:24:02 <fleecer> Thanks again
19:25:33 <spott> kazagistar: ok... I guess I've got to look at my code again, cause that doesn't work...
19:26:01 * hackagebot mtl 2.2.1 - Monad classes, using functional dependencies  http://hackage.haskell.org/package/mtl-2.2.1 (EdwardKmett)
19:26:18 <spott> does anyone know if the "write yourself a scheme" located here: http://jonathan.tang.name/files/scheme_in_48/tutorial/overview.html has bugs?
19:26:22 <spott> it appears to
19:30:29 <pavonia> What bugs?
19:31:46 <kazagistar> spott: alternatively, post your code and maybe we can find the bugs in it?
19:33:23 <spott> kazagistar: I'll put it up on github... it is long enough that I'm not sure people would be willing to go through it
19:36:44 <spott> ok, here is the code: https://github.com/spott/scheme/tree/master
19:36:46 <kazagistar> is attoparsec not an "MonadPlus" transformer because performance, complexity,  inherent, or incidental reasons?
19:37:27 <spott> don't download it yet... it doesn't compile
19:38:05 <glguy> kazagistar: It appears to have a MonadPlus instance: http://hackage.haskell.org/package/attoparsec-0.12.0.0/docs/Data-Attoparsec-Types.html#t:Parser
19:38:49 <spott> ok, fixed
19:39:49 <kazagistar> glguy: right, but Parsec can "contain" arbitrary monads, like the mtl types
19:40:37 <kazagistar> spott: friendly hint, toss *.hi to your gitignore, or just grab one off the web ;)
19:41:02 <spott> kazagistar: yea, I was going to, I just hadn't gotten around to it
19:41:11 <spott> this was local until a few minutes ago
19:42:40 <kazagistar> spott: don't worry, I'm not judging, I am secretly just tring to check out your code and get the condensed version and maybe save myself some of those 48 hours :D
19:42:58 <spott> :)
19:43:44 <spott> kazagistar: I did some of the exercises before I decided to finish it and go back.  it is also currently a debug verion (it spits out the parsed code, then the code as it evaluates it)
19:43:54 <spott> *s/verion/version
19:45:13 <levi> Whee, I got my haskell Universal Machine implementation working.
19:45:30 <efg> what's Bryan O'Sullivan's nick?
19:46:04 <joelteon> bos
19:46:23 <efg> bos, you're boss, awesome book!
19:50:11 <spott> well, that answered my question:  the site that I quoted definitely has a bug in it...
19:50:33 <spott> the listings are different from the code in the text of the tutorial
19:51:50 <trap_exit> in Monads, why does >> exist? isn't >> always just >>= but ignoring the argument
19:51:52 <spott> and my code works!
19:53:01 <spott> trap_exit: exactly.
19:53:12 <kazagistar> trap_exit: sure, and thus those are different things, and are both useful
19:53:22 <Iceland_jack> trap_exit: Because it's useful, why does 'print' exist when it's just 'putStrLn . show'?
19:53:54 <Iceland_jack> same with 'all' and a thousand other definitions
19:53:54 <Iceland_jack> @src all
19:53:54 <lambdabot> all p =  and . map p
19:54:58 <kazagistar> the better question is why does >> exist when *> exists, and the answer is historical reasons :D
19:55:24 <Iceland_jack> If one were to make a Haskell bingo, one of the cells would definitely be 'Historical Reasons'
19:56:30 <jle`> print and putStrLn . show is different that >> and >>= I think
19:56:31 <benzrf> :{
19:56:46 <benzrf> >> is a method, noted
19:56:49 <jle`> because >> is actually in the Monad typeclass
19:57:03 <jle`> it'd be if print was in the Show typeclass
19:57:20 <Iceland_jack> jle`: sure, but the point is that it doesn't have to exist: fine use any of the useless methods then
19:57:24 <jle`> I think >> is there just to let people implement more performant versions
19:57:25 <Iceland_jack> why does (/=) exist
19:57:38 <jle`> sort of like mconcat
19:57:38 <benzrf> Iceland_jack: you cant define >>= in terms of >> though
19:57:52 <Iceland_jack> That's right, but you can define (/=) in terms of (==)
19:58:34 <cschneid> I have lots of data records that look like this: data DewPoint = DewPoint Int | DewPointMissing  -- data Temperature = Temperature Int | TemperatureMissing
19:58:41 <cschneid> is there a way to not have to prefix Missing on each one?
19:58:46 <cschneid> (I suppose, other than modules)
19:58:54 <jle`> I'd say that the reason >> is in Monad and not just a convenience function like print and ap is for possible performant implementations
19:59:08 <jle`> but that's a different question than was originally asked
19:59:19 <augur> jonsterling: theres a tension between the absolute, unchanging reference we get from true pointers to with global scope on the one hand, and an impure semantics on the other
19:59:19 <benzrf> Iceland_jack: hence why it's different o_O
19:59:26 <jle`> so I'm just rambling I guess :)
19:59:35 <Iceland_jack> benzrf: Yes, but not different in a way that's relevant to the question..
19:59:53 <augur> s/to with/with/
20:00:21 <jle`> cschneid: are you against using Maybe
20:00:49 <cschneid> jle`: `= Dewpoint Maybe Int`
20:00:50 <cschneid> ?
20:00:50 <augur> jonsterling: a pointer could just say _this here_, and always mean that there, but how do you do that purely without using memory addresses etc.? i dont know.
20:01:23 <cschneid> perhaps. It happens in more complex manners too. I'll just stick with specific naming for now to get it working, then refactor something nicer if it becomes a worry
20:01:57 <jle`> type Dewpoint = Maybe Int
20:02:05 <jle`> or newtype to keep type safety
20:02:17 <benzrf> Dewoiunt?
20:02:17 <augur> jonsterling: the HOAS approach does it of course by stealing pointers from the host language via variables but then you loose the ability to properly test equality etc.. what you'd like is actually to have pointers in both directions, so substitution can just follow them down to the vars and drop the value in
20:02:41 <benzrf> *Dewpoint
20:02:54 <jonsterling> augur: have you looked into nominal type theory?
20:03:03 <augur> jonsterling: a little bit, but i dont remember it much
20:03:07 <augur> (at all)
20:03:38 <kazagistar> on the note of similar things, I looked at the differences between monadplus and alternative, and I have no idea what "some" and "many" are supposed to do...
20:04:00 <benzrf> hmmm
20:04:18 <benzrf> > (++"foo") <|> (++"bar")
20:04:19 <lambdabot>  No instance for (Control.Applicative.Alternative
20:04:19 <lambdabot>                     ((->) [GHC.Types.Char]))
20:04:19 <lambdabot>    arising from a use of ‘Control.Applicative.<|>’
20:04:21 <benzrf> kk
20:08:09 <benzrf> :t fix
20:08:10 <lambdabot> (a -> a) -> a
20:08:13 <benzrf> :t fix const
20:08:14 <lambdabot>     Occurs check: cannot construct the infinite type: a ~ b0 -> a
20:08:14 <lambdabot>     Expected type: a -> a
20:08:14 <lambdabot>       Actual type: a -> b0 -> a
20:08:17 <benzrf> wait derp
20:08:27 <augur> > fix id
20:08:31 <lambdabot>  mueval-core: Time limit exceeded
20:08:36 <benzrf> @let infinite = const infinite
20:08:37 <lambdabot>  .L.hs:150:18:
20:08:37 <lambdabot>      Occurs check: cannot construct the infinite type: a ~ b -> a
20:08:38 <lambdabot>      Relevant bindings include infinite :: b -> a (bound at .L.hs:150:1)
20:08:38 <lambdabot>      In the first argument of ‘const’, namely ‘infinite’
20:08:38 <lambdabot>      In the expression: const infinite
20:08:39 <benzrf> aww.
20:09:06 <kazagistar> @doc infinite
20:09:07 <augur> benzrf: what are you trying to do? lol
20:09:07 <lambdabot> infinite not available
20:09:13 <benzrf> not much
20:10:04 <benzrf> :k Mu
20:10:05 <lambdabot> (* -> *) -> *
20:10:07 <benzrf> hmm
20:10:19 <benzrf> :t Mu
20:10:20 <lambdabot> Not in scope: data constructor ‘Mu’
20:10:23 <benzrf> :t Fix
20:10:24 <lambdabot> Not in scope: data constructor ‘Fix’
20:10:29 <benzrf> eh?
20:10:40 <augur> lambdabot has multiple personalities
20:11:16 <kazagistar> in any case, I think ill be avoiding monadplus in my code, and I am seriously considering abandoning return for pure as well
20:11:28 <augur> actually its probably that Mu isn't the constructor for Mu, benzrf
20:11:36 <augur> data Mu f = In (f (Mu f)) or something
20:11:36 <benzrf> augur: :I
20:11:38 <augur> @src Mu
20:11:38 <lambdabot> newtype Mu f = In { out :: f (Mu f) }
20:11:41 <benzrf> aha
20:11:42 <augur> see!
20:12:12 <benzrf> @let infinite = In infinite
20:12:13 <lambdabot>  .L.hs:150:15:
20:12:13 <lambdabot>      Kind incompatibility when matching types:
20:12:13 <lambdabot>        f :: * -> *
20:12:13 <lambdabot>        Mu f :: *
20:12:13 <lambdabot>      Expected type: f (Mu f)
20:12:17 <benzrf> oops
20:12:32 <benzrf> @let infinite = In (const infinite)
20:12:34 <lambdabot>  Defined.
20:12:36 <benzrf> sweet
20:12:38 <benzrf> :t infinite
20:12:38 <augur> > let infinite = In (out infinite) in infinite
20:12:39 <lambdabot> Mu ((->) b)
20:12:40 <lambdabot>  No instance for (GHC.Show.Show
20:12:40 <lambdabot>                     (f0 (Lambdabot.Plugin.Haskell.Eval.Trusted.Mu f0)))
20:12:40 <lambdabot>    arising from a use of ‘M84256852363473726023079.show_M84256852363473726023...
20:12:40 <lambdabot>  The type variable ‘f0’ is ambiguous
20:12:41 <lambdabot>  Note: there are several potential instances:
20:13:04 <benzrf> :t out infinite
20:13:05 <lambdabot> b -> Mu ((->) b)
20:13:24 <benzrf> :t out (out infinite 3)
20:13:24 <lambdabot> Num b => b -> Mu ((->) b)
20:13:35 <benzrf> :t out (out (out infinite 3) "foo")
20:13:36 <lambdabot>     No instance for (Num [Char]) arising from the literal ‘3’
20:13:36 <lambdabot>     In the second argument of ‘out’, namely ‘3’
20:13:36 <lambdabot>     In the first argument of ‘out’, namely ‘(out infinite 3)’
20:13:38 <benzrf> aw.
20:13:52 <benzrf> @check
20:13:52 <lambdabot>  <unknown>.hs: 1: 1:Parse error: EOF
20:13:55 <augur> ok, benzrf, maybe this is better done in a PM
20:13:59 <augur>  /msg lambdabot
20:14:03 <benzrf> right right
20:14:13 <benzrf> 1 more though p:
20:14:30 <augur> if you keep this up, the powers that be will get angry
20:14:30 <benzrf> wait meh
20:14:34 <benzrf> D=
20:15:47 <augur> jonsterling: do you know of any way to have point-like behavior without something like memory-addressed stuff?
20:16:17 <jonsterling> augur: Afraid I'm a little out of my depth there...
20:16:33 <augur> jonsterling: i was thinking maybe you could do something like have a special data type where you store your pointers/indices, and as you traverse through a structure itll automatically update them or something like that? dunno tho
20:16:38 <augur> jonsterling: out of your depth how!
20:19:06 <augur> jonsterling: what mcbride and brady (or was it loh? oh who knows) did for their tutorial DTP paper was to have some kind of index you carry with you and then shift your vars around by, or something like that
20:19:17 <aural> In a linux environment from command prompt, is there a way I can get a haskell command line to parse haskell code after I push enter?
20:19:32 <aural> something similar to http://codegolf.stackexchange.com/a/28794
20:20:49 <joelteon> hell
20:21:14 <augur> jonsterling: the problem i find with debruijn indices is that when you project things out of the env to check a var, you have to shift things around again and it gets all confusing
20:21:17 <zomg> aural: am I misunderstanding something but did you just describe ghci, linked to an answer mentioning ghci, and are still asking if it exists? =)
20:21:50 <aural> zomg: Thanks, I missed reference to `ghci`
20:21:54 <augur> if debruijn indices are a cyclon detector when implemented for the STLC, i cant fathom what they are for a DTP lang
20:22:11 <aural> I have never tinkered with haskell and shall experience first time doing so now. Thus, I'm fairly incompetent.
20:23:12 <zomg> aural: heh, ok :) yes `ghci` is the haskell interactive shell
20:24:50 <startling> augur, McBride, Loeh, and Swiersta I think
20:24:59 <startling> http://www.andres-loeh.de/LambdaPi/
20:25:20 <startling> using Maybe for de bruijn indices is nice.
20:25:32 <startling> @hackage bound -- or this
20:25:33 <lambdabot> http://hackage.haskell.org/package/bound -- or this
20:41:22 <benwiklund> hey guys
20:41:38 <bwiklund> quick question, kind of lost
20:41:55 <Iceland_jack> shoot
20:42:00 <bwiklund> how would i pass a file/network handle to hGetLine (or similar) and only read until a certain point
20:42:04 <bwiklund> this particular case, http headers
20:42:09 <bwiklund> i wanna stop when i get two newlines
20:42:19 <bwiklund> but the connection stays open because http
20:42:59 <Iceland_jack> You can use hGetLine twice
20:43:02 <Iceland_jack> brb
20:44:10 <bwiklund> not sure i follow
20:53:30 <napping> hGetLine doesn't close the Handle after it reads a line
21:03:49 <mariomystic> Is it possible to change axis in criterion graphs? Instead of time I want it to be a specific function of time like bytes/sec.
21:12:38 <fread2282> is there a better way to do SupplyM which is a State [a] that has next :: SupplyM a that takes the head of the list?
21:13:31 <napping> look at how the report stuff is implemented
21:14:33 <fread2282> napping: what report stuff?
21:17:01 <fread2282> I'm using it to implement a show-like function that turns my AST back into code
21:18:50 <fread2282> and the list is all possible variable names
21:18:54 <napping> that was another answer
21:19:00 <fread2282> ah
21:19:41 <napping> Do you want to know if there's a better way than doing that?
21:20:10 <fread2282> napping: yea, not sure the bust way to implement my ast -> code function
21:20:24 <napping> that seems pretty reasonable
21:21:08 <napping> you can apply that easily with traverse, if your AST type is a functor over the variable type
21:21:59 <napping> what kind of binding does your AST have?
21:22:10 <fread2282> napping: using ekmett's bound
21:23:36 <napping> Oh, I guess you'd just hit the free variables then
21:23:44 <fread2282> so it's a functor over the variable type but also has bound's Scope inside for bound variables
21:24:18 <napping> the other thing you can try is to run the list more like a stack, just picking names that don't shadow surrounding binders, but reusing names in sibling expressions
21:25:03 <napping> Or a bit of both, if you cache an (optional) user-supplied name at the binders, and try to use that
21:44:52 <hunt> mapM_ vs foldM?
21:45:48 <hunt> im wondering if i mapM_ an f:: String -> State blah blah, will the state accumulate as id expect?
21:46:03 <startling> hunt: yes.
21:46:10 <hunt> startling: goody
21:46:13 <hunt> thanks
21:46:25 <startling> hunt: well, as long as you expect the right thing. :)
21:46:45 <hunt> lol i expect that the applied to index 2 will carry the state from index 1
21:46:51 <startling> yeah.
21:54:27 <tpsinnem> hey -- anyone know of the 'singletons' package is something that people use in production?
21:55:35 <tpsinnem> or, in general are various 'fake dependent types' something that people use in production
21:57:35 <hunt> if i have a StateT _ IO (), how do i actually perform IO?
21:57:51 <hunt> it cant be modified into the state... do i return the io action?
21:57:57 <enthropy> @type runStateT
21:57:58 <lambdabot> StateT s m a -> s -> m (a, s)
21:58:23 <hunt> enthropy: i mean when im writing something of the type StateT _ IO (), how do i write IO into its functionality
21:58:47 <hunt> enthropy: i cant put it at do level because that just doesnt make sense
21:59:06 <ion> @type liftIO
21:59:08 <lambdabot> MonadIO m => IO a -> m a
21:59:08 <bzcat> liftIO?
21:59:19 <hunt> ah ok
21:59:26 <hunt> is that actually what im supposed to do?
21:59:32 <ion> @type StateT
21:59:33 <lambdabot> (s -> m (a, s)) -> StateT s m a
22:00:01 <kazagistar> @instances StateT
22:00:02 <lambdabot> Couldn't find class `StateT'. Try @instances-importing
22:00:26 <hunt> i suppose the m from liftio in this case would be StateT _ IO?
22:00:53 <ion> yes
22:01:34 <kazagistar> @instances-importing Control.Monad.State StateT
22:01:35 <lambdabot> Couldn't find class `StateT'. Try @instances-importing
22:01:48 <kazagistar> eh whatever
22:01:59 <pqmodn> @type modify
22:02:00 <lambdabot> MonadState s m => (s -> s) -> m ()
22:02:05 <pqmodn> @instances MonadState
22:02:06 <lambdabot> s (ContT r m), s (ErrorT e m), s (RWST r w s m), s (ReaderT r m), s (StateT s m), s (WriterT w m)
22:04:41 <hunt> ion: can you lift io in any monad?
22:05:06 <hunt> ion: and will it still perform the io?
22:05:07 <pqmodn> no, only MonaidIO instances
22:05:25 <hunt> ah ok
22:05:59 <pqmodn> since IO can only be executed when it's the outermost monad, liftIO just delegates upward until it finally hits the IO monad
22:06:20 <pqmodn> i beleive in the MonadIO instance for IO, liftIO is just id or something
22:08:23 <pqmodn> also, i think every instance of MonadIO has the same definition for liftIO = lift . liftIO (except IO itself, which is probably liftIO = id)
22:09:02 <Cale> I don't care for this way of picturing it
22:09:49 <Cale> What lift does in any case is to *add* whatever structure is necessary to turn an action of the original monad into an action of the transformed monad.
22:10:36 <ion> @type StateT
22:10:38 <lambdabot> (s -> m (a, s)) -> StateT s m a
22:11:09 <ion> hunt: An exercise: looking at the type of the function StateT, how to define liftIO for StateT?
22:11:29 <Cale> Oh, I was going to use it as an example, but an exercise is better still :)
22:11:46 <Cale> @type ReaderT
22:11:47 <lambdabot> (r -> m a) -> ReaderT r m a
22:12:17 <Cale> For ReaderT, we have  lift x = ReaderT (\r -> x)
22:14:30 <Cale> (for StateT, you'll need to do something a little more)
22:31:28 <kazagistar> Cale: ugh, I made a mistake somewhere I think... lift x = StateT (\s -> x >>= return (,s))
22:35:24 <spott> So, there are a whole bunch of different parser combinator libraries in Haskell... why? and what are the differences?
22:37:06 <startling> spott, parsec is the original. attoparsec is better at bytestrings, and faster. trifecta is the new cool thing, allows you to write abstracted parsers across trifecta, parsec and attoparsec (with the 'parsers' library), and gives really nice error messages.
22:37:45 <spott> polyparse is what?
22:38:08 <startling> I'm not sure.
22:38:11 <spott> trifecta sounds neat
22:38:55 <spott> thanks, that at least gives me something to think about
22:39:13 <spott> I've heard that parsec2 and parsec3 are out?  (or am I wrong?)
22:39:20 <spott> do I get those from cabal?
22:39:35 <startling> spott, yeah, but they're just the new versions of "parsec". yep.
22:40:07 <startling> spott: the short of it is that people write different libraries with different APIs and different emphases.
22:42:03 <spott> startling: makes sense... I'm going to attempt to write my own language, with a context free grammar... is trifecta a good option?
22:43:03 <startling> spott, parser combinator libraries in general make it hard to say "this language is context-free" (though you can only use Applicative if you want). I like trifecta. It may make more sense to learn parsec first, since parsec is largely the inspiration for this family of parser libraries.
22:43:10 <startling> (And there's more learning material out there for it).
22:43:58 <spott> I just finished "write yourself a scheme" which uses Parsec, so I'm "comfortable" with it
22:45:01 <spott> startling: I'm also not going to attempt to prove that my language is context free... I'm just going to attempt to write it as such.
22:48:24 <spott> startling: thanks for the help.  I'll give trifecta a shot.
22:50:19 <startling> scopedTV: no problem!
22:51:52 <startling> er, sorry
22:51:56 <startling> spott: no problem!
22:52:13 <kazagistar> trifecta seems to be more focused on syntax highlighting or parsing without much context?
22:52:35 <Cale> kazagistar: lift x = StateT (\s -> do v <- x; return (v,s))
22:53:04 <Cale> kazagistar: Or:  lift x = StateT (\s -> fmap (\v -> (v,s)) x)
22:53:28 <startling> kazagistar: not sure what you mean.
22:54:11 <Cale> kazagistar: If StateT were defined a bit more nicely, with the state component first in the pairs, then you could use  fmap ((,) s)
22:54:50 <kazagistar> Cale: aha! I knew there was something whacky about that ordering :D
22:55:39 <piezoid> hi
22:56:09 <piezoid> I'm writing a xml streaming parser with xml-conduit
22:56:27 <dolio> fmap (,s)
22:56:30 <dolio> With tuple sections.
22:56:30 <piezoid> so I use a inner state monad to update my structure
22:57:09 <piezoid> but when i go one level down (with the tag combinator for example) I want to change the state type to local data
22:57:23 <kazagistar> except I imagine it isn't important enough nor useful enough to swap the ordering of State tuples
22:57:31 <piezoid> but I don't see how ConduitM allow it
22:58:18 <piezoid> Data.Conduit.Lift allow somehow to change the inner monad, but there is no local state operator
22:59:07 <Cale> kazagistar: At this point, yeah :(
22:59:24 <Cale> kazagistar: You have this nice property that (,) s is a Functor for any type s
22:59:27 <dolio> s -> (a, s) is categorically correct, anyway. :)
22:59:32 <Cale> kazagistar: and that structure isn't being respected
22:59:43 <Cale> hm?
23:00:19 <dolio> The adjunction is usually presented as - × s ⊣ s -> -
23:00:26 <dolio> If I recall correctly.
23:00:40 <Cale> Well, of course s × - is *also* adjoint
23:00:46 <Cale> (it's isomorphic)
23:00:47 <dolio> Of course.
23:00:53 <piezoid> I'm thinking of streaming down a lens pointing at the current location, or producing update as monoids. Do yout think of a better solution ?
23:01:05 <Cale> The only real distinction comes about because in Haskell, we don't have type level lambdas
23:01:19 <Cale> (and even if we did, they wouldn't play very nicely with type classes)
23:01:38 <dolio> Actually, it might matter if you're doing it for something that isn't symmetric monoidal.
23:02:47 <napping> There's no - × s functor in Haskell, but s × - is available as a partial application
23:03:42 <napping> Cale: are you sure about type lambdas? Maybe if you could only define instances at type constructors things would work out
23:04:51 <Cale> napping: Well, if you could only define instances at type constructors, then you wouldn't be able to do the other instance :)
23:05:57 <napping> Those would overlap anyway
23:06:22 <napping> maybe instances at lambdas as long as the body is headed at a constructor application?
23:06:31 <hunt> guys
23:07:05 <napping> I was thinking more about whether we could allow type lambdas without breaking type classes completely, not getting this particular example working
23:07:09 <hunt> is there a way to parse numbers with parsec? im currently using the tokenized float for haskellDef to get floats, but that doesnt read negative numbers :'(
23:07:45 <ion> hunt: See Text.Parser.Token in the parsers package.
23:08:22 <napping> Is there any monoid for combining definitions by priority? something like (a, Set b), except you take the set with a greater a if they differ
23:08:58 <startling> napping: I don't think so. that's kind of tricky to say on the type level
23:09:07 <startling> you could do something Readerish, though
23:09:25 <napping> I meant as a separate data type
23:10:07 <startling> newtype Prefer a = Prefer ((a -> a -> a) -> a)
23:10:13 <startling> hm, you need a mempty too
23:10:24 <startling> newtype Prefer a = Prefer ((a -> a -> a) -> a -> a)
23:11:03 <startling> instance Monoid (Prefer a) where mempty = Prefer (\_ m -> m); mappend a b = Prefer (\f _ -> f a b)
23:11:58 <startling> (given that that function is a valid mappend wrt mempty)
23:12:05 <napping> that looks funny
23:12:25 <napping> I meant a fixed order
23:12:49 <napping> data Prefer priority a = Prefer priority (Set a)
23:13:10 <napping> then something like instance (Ord priority, Bounded priority, Ord a) => Monoid (Prefer priority a)
23:13:42 <startling> napping: there's no law that says minBound is actually a < everything else.
23:13:53 <pqmodn> you can remove the Bounded constraint if you have Maybe priority
23:14:41 <pqmodn> mempty = Prefer Nothing S.empty
23:15:20 <kazagistar> Default priority?
23:15:49 <pqmodn> minimum
23:15:54 <kazagistar> what you are looking for, really, is probably a semigroup not a monoid
23:16:45 <Inquisitive> Hi. Are there any machine vision libraries that are possible to install on windows? OpenCV bindings or otherwise?
23:17:30 <napping> it's a semigroup without a minimum bound, but I do want a monoid
23:17:48 <napping> but then again, the straight up replacement may not be right either
23:18:40 <napping> actually, Set is fine for what I need
23:19:30 <napping> It's a compiler type thing where multiple places can contribute attributes to a definition, but many might extend it without contributing anything
23:20:01 <napping> but right now the default is just based on the name, so a Set of the explicit overrides would be enough
23:20:49 <napping> and I really ought to complain if any of the explicit attributes conflict, even though some ways of specifying things are "more important" than others
23:45:12 <hunt> anyone still up?
23:45:33 <hunt> im wondering why people keep going on about how lens' are the new monads
23:45:42 <hunt> not necesarily a replacement but just revolutionary
23:48:32 <startling> I wouldn't say "lens' are the new monads"
23:48:49 <startling> I would say that writing programs in a lensy way is really nice.
23:49:07 <startling> Often you can express everything you need to do with a datatype as just a few lenses or traversals or what have you.
23:49:17 <startling> :t Control.Lens.text -- for exampl
23:49:18 <lambdabot>     Not in scope: ‘Control.Lens.text’
23:49:19 <lambdabot>     Perhaps you meant one of these:
23:49:19 <lambdabot>       ‘Control.Lens.set’ (imported from Control.Lens),
23:49:43 <startling> :t Data.Text.Lens.text -- for example ?
23:49:44 <lambdabot> (Data.Text.Lens.IsText t, Indexable Int p, Applicative f) => p Char (f Char) -> t -> f t
23:50:06 <enthropy> both inspire tutorials
23:50:12 <startling> that too.
23:50:25 <rootzlevel> is there a fast modular exponentiation function anywhere on hackage or GHC?
23:50:55 <startling> but 'text', with the combinators lens definies, sums up the whole API of the package 'text'.
23:51:10 <ion> rootzlevel: I don’t know if this is the best one, but i’ve seen one in http://hackage.haskell.org/package/arithmoi-0.4.1.0/docs/Math-NumberTheory-Moduli.html
23:52:20 <kadoban> rootzlevel: I used one in crypto-numbers once that seemed fine, but I didn't use it for much so I'm not sure if it's the best either.
23:53:07 <rootzlevel> ok, thanks
