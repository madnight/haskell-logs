00:02:23 <cbarrett> engage in what way?
00:03:39 <Maxdamantus> augur: just ask it.
00:04:01 <augur> Maxdamantus: ;P
00:04:13 <augur> cbarrett: create/move/rename files/folders
00:05:33 <cbarrett> augur: the functions in System.Directory and System.FilePath.
00:07:17 <cbarrett> You may also be interested in the Handle type.
00:08:42 <augur> ill give these a look, thanks :)
00:09:10 <cbarrett> When it comes to working with the *contents* of files, rather than the system for organizing files,  it is a bit muddier. You should look into ByteString and Text in addition to the included hGet<<Foo>> functions.
00:09:37 <augur> right now my main interest is just boring non-editing/reading stuff
00:09:47 <augur> i just need to poke files and nudge them around
00:10:03 <cbarrett> OK
00:10:20 <cbarrett> It's pretty clear then, the included functions are the standard way of doing things.
00:12:36 <augur> cbarrett: System.Directory mentions moving/renaming/deleting files but not creating them
00:12:47 <augur> is there a way to create files, or does haskell not have an analog of touch?
00:13:08 <cbarrett> It does. You will want to look into Handles.
00:13:15 <augur> aha ok
00:13:34 <cbarrett> http://hackage.haskell.org/package/base-4.7.0.0/docs/System-IO.html
00:15:31 <augur> also, secondarily, is there a way to have a value that is inspectable in put settings, but also mutable in impure settings?
00:15:44 <Qfwfq> @djinn Monad m => (a -> m b) -> m (a -> b)
00:15:44 <lambdabot> -- f cannot be realized.
00:15:46 <cbarrett> I'm not following
00:16:38 <augur> cbarrett: like. i need a type T such that T can be one of three things, say. and i want to be able to inspect this to see which it is without being impure
00:17:02 <augur> but at the same time, i need to be able to make this mutable in impure settings
00:17:43 <cbarrett> what are you trying to achieve?
00:18:04 <augur> its hard to explain, but, lets say
00:18:33 <augur> im creating a dual-mode logic, with propositional content on the one hand, and non-propositional uses on the other
00:19:13 <cbarrett> hm, hold on
00:19:15 <augur> propositionally, props like   `File x`  or   `Folder y`   need to be inspectable without pushing into IO (preferably)
00:19:37 <cbarrett> ah
00:19:39 <augur> but at the same time, it needs to be possible that if `x` is unspecified as a file, i can force `File x` to be true under the hood
00:19:49 <augur> when in an IO setting
00:20:19 <augur> so i need a data type which can be inspected/tested without invoking IO, but which cant be changed without invoking IO
00:20:23 <augur> is this possible?
00:20:41 <cbarrett> To a degree.
00:21:05 <augur> i would prefer not to use unsafePerformIO
00:21:08 <cbarrett> My approach would be to think not of the data but the functions you're dealing with.
00:21:21 <augur> elaborate?
00:21:26 <cbarrett> You have pure "actions", a -> b, but also monadic actions, a -> IO b.
00:21:32 <augur> yes
00:22:16 <augur> in some sense its like i need   isFile :: T -> Bool    and   makeFile :: T -> IO ()
00:22:20 <augur> or something of that nature
00:22:46 <augur> where `makeFile t` changes properties of T
00:22:52 <augur> ideally this should hold:
00:23:00 <cbarrett> aahhh
00:23:17 <augur> do { let x = someT ; print (isFile x) ; makeFile t ; print (isFile x) }
00:23:18 <augur> should print
00:23:19 <augur> f
00:23:23 <augur> False ... True
00:23:43 <cbarrett> augur: I would recommend an evaluation based approach then. Don't think about writing "makeFile" as an action. think about generating pure data that you can then *evaluate* in the IO context later on.
00:23:59 <augur> thats how im doing it
00:24:03 <cbarrett> So you might have a data constructor `MakeFile FilePath`
00:24:17 <cbarrett> As part of some larger ADT
00:24:18 <cbarrett> Hm
00:24:42 <augur> but i still need a representation of T that isFile be false one moment and true the next
00:24:55 <augur> without simultaneously requiring that i use IO to ask isFile
00:26:12 <cbarrett> i invite you to consider your definition of "moment" there.
00:26:30 <augur> ?
00:26:32 <cbarrett> To know facts contained within IO you must have some sequencing with respect to IO. it's the only way to ensure ordering in a call-by-need language.
00:26:42 <augur> yes
00:26:50 <augur> the moments are monadically chained
00:26:54 <xpika> can anyone simplify this function (\n -> sum $ map (2^) [1..n]) ?
00:27:16 <augur> xpika: why would you do that? its nice and clear
00:27:38 <xpika> augur: maybe there is tricks with logarithms to acheive it faster
00:28:00 <cbarrett> xpika: If you wish to eta-reduce, sum . map (2^) . enumFromTo
00:28:06 <cbarrett> *enumFromTo 1
00:28:07 <augur> well there's tricks with bit shifting but those are usually optimized in
00:28:12 <Zekka> xpica: Should be 2^(n-1) - 1, not counting special cases
00:29:03 <Zekka> for n <= 1 I think it's constant 1
00:29:08 <Zekka> er, no, it's not
00:29:15 <Zekka> for n < 1 it's constant 0
00:29:30 <cbarrett> augur: sorry, I need to slee
00:29:31 <cbarrett> +p
00:29:32 <cbarrett> g'night
00:29:37 <augur> cbarrett: well. now that i think about it, i might be able to get away with using forced IO for the predicates anyway
00:29:39 <augur> ok night cbarrett!
00:30:06 <augur> i'd prefer not to tho
00:30:07 <augur> hmm
00:30:16 <xpika> Zekka: thanks
00:45:13 <toki78> hey party people... you are the most intelligent guys I know, and you might like my implementation of an AI algorithm. try to beat this :
00:45:15 <toki78> http://toki.burn3r.de/cityfighter-in-playstore/cityfighter-for-html5.html
00:45:19 <toki78> impossible
00:56:27 <louisjb> morning
00:56:44 <fbrusch> hi!
00:57:35 <louisjb> I'm playing around with my little dicce game (newbie) and I've a couple of questions on it https://gist.github.com/LouisJB/1688bb14a46f00d4cbf2 1. when I replicateM on an action that uses a result of an earlier action that other action is not re-evaluated, is it possible to make that happen?
00:58:37 <louisjb> line +26 approximately - I'm just using this simple game as a learning exercise...
01:01:10 <enthropy> louisjb: you want what you have as 0 0 to get incremented?
01:01:44 <frerich> lousjb: Yeah, you can (have to) pull the 'rands' call into the action to replicate. I.e. have something like 'rs2 <- replicateM noOfRounds $ do { rnds2 <- rands; playround2 rnds2 0 0 }'
01:02:01 <louisjb> well, it's the rnds or rnds2 - I was hoping to get that re-evaled
01:02:47 <louisjb> frerich - ah! I see, got you, thanks!
01:04:07 <enthropy> rollDice :: Int => IO Int -- isn't supposed to be valid
01:04:27 <enthropy> for whatever reason it gets interpreted as "rollDice :: Int -> IO Int"
01:06:17 <louisjb> ah you mean => vs ->  ok, that's scala leaking through as a bad-habit
01:07:02 <louisjb> my other question for the moment is playerAPred x = x == PlayerA would you normally construct this pred as a where on the count line?
01:07:12 <louisjb> or how would that best be done, seems clunky as-is
01:07:32 <louisjb> or a lamba in a where?
01:08:20 <tocklime> louisjb: (==PlayerA) ?
01:08:25 <enthropy>  length [ () | PlayerA <- rs1 ] -- works too
01:08:29 <frerich> louisjb: That would commonly be just 'playerAPred = (== PlayerA)', in which case the definition doesn't really dad much value so you would drop it and just use 'count (== PlayerA) rs1' or so
01:08:57 <louisjb> right ok, thank you
01:09:59 <Kaidelong> is there any haskell library for dealing with push vs pull data flow and converting between the two with things like clocks and buffers?
01:10:06 <louisjb> and is it good practice to use printf, seems a bit c-ish, is there a prefered way to mix output of strings and other types for printing
01:12:26 <enthropy> there are alternatives that catch some errors at compile time
01:12:33 <enthropy> http://hackage.haskell.org/package/xformat is one of many
01:12:36 <frerich> louisjb: I think print/printf is just fine for your purpose.
01:12:59 <louisjb> thank you
01:16:03 <Kaidelong> what about pipes?
01:16:55 <Kaidelong> (I have a low level library that provides callbacks but another library that propogates by pulling from things)
01:19:00 <yitz> louisjb: my personal opinion is that yes, printf is clunky and c-ish. i would say builders are the idiomatic way to do that nowadays in haskell. the text library now has its own built-in builders.
01:20:52 <yitz> louisjb: other than that, the most popular series of builder libraries is blaze, which the text builders are inspired by.
01:21:29 <yitz> louisjb: there are some nice blaze libraries that are more targeted, such as blaze-html.
01:23:06 <louisjb> yitz - ok thanks, I'll take a look at builders. Do you have an example to perform in-line in say a print a builder style string construction?
01:23:19 <yitz> Kaidelong: yes you should look at pipes and conduits
01:26:13 <gustavn> Hey, I have a problem that I'd like to do as elegantly as possible
01:27:14 <gustavn> Let's say I have a list of integers. I want to get the product of every *unique* subset of them. How do I do that in Haskell?
01:28:03 <gustavn> Well, I guess you can reduce the problem to: What is the most elegant way of generating all the unique subsets of a list, where the list is ordered?
01:28:44 <vanila> you could first group the list so it's like  [[1], [2,2,2], [3,3], [4]]
01:29:20 <vanila> then replace each group like [x,x,x] with [[],[x],[x,x],[x,x,x]]
01:29:35 <vanila> and then use the list monad to generate all unique subsets
01:29:49 <tester3hg> hi guys, I'm stuck with writing a function 'splitleftmost', which splits the most left element of a BinTree? I want to write a end-recursion
01:30:10 <gustavn> Will generating subsets the normal way then generate only unique subsets? Or what are you talking about
01:30:57 <gustavn> Ooooh, are you talking about taking the cartesian product of the inits and then mapping a concatenation over those?
01:31:06 <vanila> yes exactly
01:31:26 <gustavn> So if x is my original list, it would look like:
01:31:51 <vanila> > map concat . sequence . map inits $ ["a","bbbb","cc"]
01:31:53 <lambdabot>  ["","c","cc","b","bc","bcc","bb","bbc","bbcc","bbb","bbbc","bbbcc","bbbb","b...
01:31:59 <gustavn> oh yeah
01:32:04 <yitz> louisjb: ok now i'm confused. the latest versions of the text library mark its built in builders as being "internal", not recommended for public use. searching through hackage, i don't find any obvious replacement.
01:32:19 <gustavn> vanila: But I would start from "abbbbcc"
01:32:22 <gustavn> So I would do
01:32:31 <yitz> louisjb: so unless someone here can clarify what is going on, i'm going to withdraw my recommendation.
01:32:36 <gustavn> > map concat . sequence . map inits . group $ "abbbbcc"
01:32:38 <lambdabot>  ["","c","cc","b","bc","bcc","bb","bbc","bbcc","bbb","bbbc","bbbcc","bbbb","b...
01:33:10 <gustavn> Wow, that's pretty cool. So that's every unique subset of those
01:33:22 * hackagebot distributed-process-p2p 0.1.3.0 - Peer-to-peer node discovery for Cloud Haskell  http://hackage.haskell.org/package/distributed-process-p2p-0.1.3.0 (AlexanderBondarenko)
01:33:57 <enthropy> yitz: http://hackage.haskell.org/package/formatting possibly?
01:34:12 <gustavn> Then this should be all factors of 100, shouldn't it?
01:34:16 <gustavn> > tail . map (product . concat) . sequence . map inits . group $ [2,2,5,5]
01:34:17 <lambdabot>  [5,25,2,10,50,4,20,100]
01:34:34 <enthropy> dunno what's special about "builder" I think it is just (ab)use of do notation
01:35:04 <gustavn> > tail . map product . sequence . scanl (*) 1 . group $ [2,2,5,5]
01:35:05 <lambdabot>  No instance for (GHC.Show.Show a0)
01:35:05 <lambdabot>    arising from a use of ‘M672956340108544873323400.show_M6729563401085448733...
01:35:05 <lambdabot>  The type variable ‘a0’ is ambiguous
01:35:05 <lambdabot>  Note: there are several potential instances:
01:35:05 <lambdabot>    instance [safe] GHC.Show.Show
01:35:43 <vanila> @let subsequences = map concat . sequence . map inits . group
01:35:46 <lambdabot>  Defined.
01:35:53 <vanila> > map product . subsequences $ [2,2,5,5]
01:35:55 <lambdabot>  Ambiguous occurrence ‘subsequences’
01:35:55 <lambdabot>  It could refer to either ‘L.subsequences’, defined at L.hs:156:1
01:35:55 <lambdabot>                        or ‘Data.List.subsequences’,
01:35:55 <lambdabot>                           imported from ‘Data.List’ at L.hs:85:1-16
01:35:59 <vanila> oops
01:36:10 <vanila> well I suggest splitting this into two parts like that
01:36:15 <gustavn> vanila: Wait, why doesn't this work too?
01:36:17 <gustavn> > tail . map product . sequence . scanl (*) 1 . group $ [2,2,5,5]
01:36:18 <lambdabot>  No instance for (GHC.Show.Show a0)
01:36:18 <lambdabot>    arising from a use of ‘M16986519383184409923441.show_M16986519383184409923...
01:36:18 <lambdabot>  The type variable ‘a0’ is ambiguous
01:36:18 <lambdabot>  Note: there are several potential instances:
01:36:18 <lambdabot>    instance [safe] GHC.Show.Show
01:36:39 <jle`> :t group
01:36:40 <lambdabot> Eq a => [a] -> [[a]]
01:36:56 <gustavn> :t sequence . scanl (*) 1
01:36:57 <lambdabot> (Num (m a), Monad m) => [m a] -> m [a]
01:37:07 <yitz> enthropy: that looks like its built on Text builders.
01:37:09 <gustavn> :t tail . map product
01:37:10 <lambdabot> Num a => [[a]] -> [a]
01:37:21 <yitz> enthropy: furthermore, its dependencies are broken - no upper bounds.
01:37:54 <yitz> enthropy: it claims to work with any version of text that will ever be released. but in fact, it doesn't appear that it will work with any recent version.
01:38:00 <gustavn> > tail . map product . sequence . scanl (*) 1 . group $ [2,2,5,5] :: [Integer]
01:38:01 <lambdabot>  No instance for (GHC.Num.Num [GHC.Integer.Type.Integer])
01:38:01 <lambdabot>    arising from a use of ‘GHC.Num.*’
01:38:20 <gustavn> what, isn't Integer an instance of Num?
01:38:35 <gustavn> > tail . map product . sequence . scanl (*) 1 . group $ [2,2,5,5] :: [Int]
01:38:37 <lambdabot>  No instance for (GHC.Num.Num [GHC.Types.Int])
01:38:37 <lambdabot>    arising from a use of ‘GHC.Num.*’
01:38:59 <yitz> enthropy: in summary - it appears to be an attempt at a printf-like thing built on text builders, and appears to be broken.
01:40:05 <yitz> @undef
01:40:05 <lambdabot> Undefined.
01:40:52 <gustavn> > tail . map product . sequence . map (scanl (*) 1) . group $ [2,2,5,5]
01:40:54 <lambdabot>  [5,25,2,10,50,4,20,100]
01:41:37 <enthropy> yitz: do you actually restrict yourself to libraries that follow PVP?
01:42:53 <enthropy> it isn't broken yet, in any case
01:42:55 <yitz> enthropy: no, due to fud that was going around, there are just too many libraries with broken dependencies. no way to avoid it now. just have to constantly fight with all the problems that causes. fortunately, cabal now has better tools to deal with that.
01:43:41 <Jei>  http://yle.fi/uutiset/viisi_laakaria_on_valviran_syynissa_epatyypillisen_kilpirauhashoidon_vuoksi/7291569 Valvira
01:43:44 <Jei>                 koittaa estää "vääränlaisen" koululääketieteen käytön taas kerran
01:43:52 <hayashi> wat
01:45:39 <yitz> enthropy: in what sense is it not broken? it looks to me like it won't build without cabal hacking.
01:46:05 <enthropy> it builds here
01:46:09 <Jei> ups, wrnog channel sorry
01:46:56 <MercurialAlchemi> Finnish is very easy to recognize
01:47:07 <MercurialAlchemi> It must compress very well :)
01:49:34 <r444> finnish have one word for "it doesn't happen to me, but it is so embarrassing", it must be pretty useful for sitcom-lovers
01:50:02 <frerich> :-)
01:51:01 <matheus23> seriously? I get a gcc segfault when trying to $ cabal install haskell-src-exts ? Anybody have that too?
01:51:48 <raichoo> matheus23: I recall compiling that yesterday. Worked for me.
01:52:02 <matheus23> raichoo: do you run archlinux?
01:52:06 <raichoo> yep
01:52:14 <matheus23> what version of gcc?
01:52:17 <MP2E> I'm running arch and it worked for me too, x86_64
01:52:24 <raichoo> 4.9.0 20140604
01:52:36 <MP2E> local/gcc-libs-multilib 4.9.0-4
01:52:43 <MP2E> gcc version 4.9.0 20140604 (prerelease) (GCC)
01:52:58 <matheus23> okay mine is 20140521 maybe updating helps
01:53:14 <MP2E> err not libs but it's the same pkgver anyway, -4 :P
01:53:25 * hackagebot formatting 4.1 - Combinator-based type-safe formatting (like printf() or FORMAT)  http://hackage.haskell.org/package/formatting-4.1 (ChrisDone)
01:55:57 <yitz> enthropy: ah, i see. Text builders *are* still a public API - but only for *lazy* text. ok that makes sense.
01:56:31 <yitz> enthropy: so yeah formatting still happens to compile, because that's what it uses. lucky. no guarantees with broken dependencies.
01:57:10 <yitz> louisjb: so i am re-instating my recommendation to use builders :)
02:06:40 <jle`> b 12
02:07:39 <bitemyapp> jle`: j8
02:08:13 <jle`> v.v
02:08:31 <bitemyapp> jle`: did I sink your battleship?
02:13:27 * hackagebot unix 2.7.0.1 - POSIX functionality  http://hackage.haskell.org/package/unix-2.7.0.1 (HerbertValerioRiedel)
02:18:44 <hunt> how do i check if a Ptr is null?
02:19:04 <hunt> i dont want to have to but my partner wrote shitty code and so now im stuck here and this is the only way i can meet my deadline
02:20:14 <hunt> i guess == nullPtr
02:21:18 <yitz> louisjb: you also might want to look at the text-format library. it's a library by bos that does printf-like things using haskell types.
02:21:44 <yitz> enthropy: have you looked at text-format? how do text-format and formatting compare?
02:22:46 <yitz> hunt: yeah, that sounds right. the Eq instance ought work for that :)
02:28:28 * hackagebot np-linear 0.1.1.1 - Linear algebra for the numeric-prelude framework  http://hackage.haskell.org/package/np-linear-0.1.1.1 (AriePeterson)
02:37:53 <chrisdone> yitz: fyi 'formatting' uses the text-format library underneath
02:38:33 <chrisdone> apart from the stringly typed "hello {}" stuff
02:38:43 <chrisdone> but it uses the efficient builders
02:41:39 <chrisdone> i didn't add any dependency versions because i don't know what range of dependencies it builds on. i use so little of the obscure API surface area that it'll probably build with rather a wide range of versions, so i'd rather just let it build with anything rather than restricting to just the single version i developed with until i have some data
02:42:50 <chrisdone> i wonder if anyone's written a tool that'll, within a sandbox, try to find the minimum dependencies for a project
02:45:09 <tdammers> my usual strategy with package versions is to test against the minimum viable version, and then constrain to the major version
02:45:31 <tdammers> then when / if people complain, I loosen or tighten the constraints as appropriate
02:45:32 <hunt> how do i check for nullPtr
02:45:35 <hunt> == doesnt work
02:45:48 <hunt> because all Ptrs == nullPtr apparently
02:46:14 <chrisdone> yitz: though i would probably modify your statement that "text" means "this project builds with any version of text", i think more specifically it means "this compiles with any version of text-format", because text-format depends on text
02:46:45 <chrisdone> (and text-format constraints text to >= 0.11.0.8)
02:47:13 <hunt> wait wtf
02:47:20 <hunt> why isnt nullPtr == 0x000000000
02:47:28 <hunt> im getgting nullPtr == the pointer im checking always
02:47:42 <hunt> is this a bug? my pointer is definitely not null
02:48:36 <chrisdone> hmm, which is more likely: your code is suspect, or the base library has a bug? =p
02:48:46 <hunt> chrisdone the library has a bug
02:48:47 <hunt> it does
02:48:53 <hunt> this only happesnw tih case notation
02:48:55 <hunt> when i use == its fine
02:49:04 <hunt> or maybe thats a feature
02:49:04 <hunt> idk
02:49:10 <hunt> point is its your fault chris
02:49:15 <chrisdone> λ> nullPtr == intPtrToPtr 0
02:49:16 <chrisdone> True
02:49:50 <chrisdone> ^ there's some evidence to suggest nullPtr == 0x000000000
02:49:52 <chrisdone> what's yours?
02:50:50 <Qfwfq> How'd I prove 'Monad m => Monad n => n (m b) -> m (n b)' can't be defined? I have the intuition, but lack a formalism.
02:51:52 <frerich> Qfwfq: Well assuming that you want to prove that it can be defined for any two monads, you'd just need to find a single counter-example.
02:51:58 <chrisdone> the Monad class provides no way m a -> a
02:52:45 <hunt> chrisdone: the following doesnt work: case randomPtr of nullPtr -> _; _ -> _
02:52:57 <Qfwfq> frerich: Yes.
02:52:58 <hunt> chrisdone: the nullPtr case will always match
02:53:25 <chrisdone> Qfwfq: Monad has no m a -> a, it only has a -> m a and m a -> (a -> m b) -> m b. so the question is how can you write that function with those two methods?
02:53:50 <chrisdone> hunt: i think you're confusing how patterns work here
02:54:08 <kartoffelbrei> hunt: of course it does. it binds the pointer to nullPtr and shadows the normal nullPtr you expect
02:54:21 <chrisdone> case <exp> of foo -> <body>  -- foo is a new binding, it doesn't refer to anything outside of the case
02:54:39 <chrisdone> case <exp> of x -> x == <exp>
02:54:44 <jle`> > let nullPtr = Nothing in case (Just x) of nullPtr -> "null!"
02:54:45 <lambdabot>  "null!"
02:55:34 <Qfwfq> chrisdone: I'm convinced, but that doesn't feel very proofy. How'd I combinatorally express all relations between 'a and m b' given those functions? Move the brackets around and apply flips?
02:55:38 <chrisdone> hunt: try something more like: case randomPtr of x | x == nullPtr -> …
02:55:57 <zwer> not in here it doesn't.. intPtrToPtr 1 == nullPtr => False
02:56:17 <jle`> Qfwfq: you can qualify it as an invariant
02:56:44 <chrisdone> Qfwfq: how do you prove that id :: a -> b is impossible?
02:57:15 <jle`> Qfwfq: invariant: if type P has one or more layers of m, you don't how an arrow to type Q with no layers of m
02:57:16 <Qfwfq> @type const 'a'
02:57:17 <lambdabot> b -> Char
02:57:34 <jle`> all of the functions in Monad preserve this invariant
02:57:50 <frerich> chrisdone: I feel pretty lame for suggesting to find a counter-example when showing how it cannot be done via the Monad functions is so much more elegant...
02:58:03 <Qfwfq> jle`: Oh, that's nice.
02:58:20 <Qfwfq> chrisdone: You can define that function if, given a type b, you can retrieve one of its values.
02:58:35 * hackagebot recursion-schemes 4.1 - Generalized bananas, lenses and barbed wire  http://hackage.haskell.org/package/recursion-schemes-4.1 (EdwardKmett)
02:58:37 <jle`> Qfwfq: no, it has to be defined for all b's
02:58:59 <jle`> f :: a -> b is fundamentally different than f :: a -> Char
02:59:04 <chrisdone> @djinn a -> b
02:59:04 <lambdabot> -- f cannot be realized.
02:59:11 <BoR0> @djinn a -> Char
02:59:11 <lambdabot> Error: Undefined type Char
02:59:12 <Qfwfq> forall b. Default b => (a -> b) is possible.
02:59:15 <BoR0> what's djinn
02:59:21 <jle`> the former is f :: forall a b. a -> b
02:59:38 <frerich> Qfwfq: It looks like in order to implement 'n (m b) -> m (n b)' you would need, at some point, to extract the 'b' from the 'm' monad and then stick it into 'n'. I.e. you'd need an "m a -> a" "extractor" and a "a -> n a" and "injector". The latter is 'return', but the former is... well - there is no such function.
02:59:40 <jle`> you can't have a function that returns a value of "whatever item you want from it"
02:59:58 <chrisdone> djinn is a theroem prover, given a type it tries to generate a program
03:00:13 <BoR0> @djinn a -> a
03:00:13 <lambdabot> f a = a
03:00:31 <jle`> if you had an foo :: a -> b, then you should be able to do, validly, foo 1 :: Int and foo 1 :: Char and foo 1 :: Void
03:00:36 <BoR0> @djinn m a -> (a -> m b) -> m b
03:00:36 <lambdabot> -- f cannot be realized.
03:00:37 <jle`> foo 1 :: Maybe Bool
03:00:45 <Qfwfq> I agree forall a b. a -> b can't be defined.
03:01:07 <chrisdone> BoR0: it doesn't know about type-classes
03:01:14 <BoR0> got it
03:01:44 <Qfwfq> Thanks!
03:02:37 <artyomkazak> @djinn Monad m => m a -> (a -> m b) -> m b
03:02:38 <lambdabot> f = (>>=)
03:02:50 <Qfwfq> Oh, I suppose I still haven't answered the question. "How do you prove that id :: a -> b is impossible". The intuition is: you could have a single term inhabiting more than one type.
03:02:55 <BoR0> @djinn Monad m => m a -> a
03:02:55 <lambdabot> -- f cannot be realized.
03:03:07 <Qfwfq> I don't think that's permitted by HM or whatever?
03:03:21 <chrisdone> artyomkazak: huh, no way. it knows type-classes. i've never seen that
03:03:35 <BoR0> @djinn Monad m => m a -> m b -> m b
03:03:35 <lambdabot> f a b = a >>= (\ _ -> b)
03:04:04 <chrisdone> @djinn Show a => a -> String
03:04:04 <lambdabot> Error: Undefined type String
03:04:09 <chrisdone> ah, forgot, no lists
03:04:23 <jle`> @djinn ((a -> r) -> r) -> (a -> ((b -> r) -> r)) -> ((b -> r) -> r)
03:04:23 <lambdabot> f a b c = a (\ d -> b d c)
03:04:37 <BoR0> @djinn (a -> a) -> a
03:04:38 <lambdabot> -- f cannot be realized.
03:04:59 <jle`> huh what do you know, it got (>>=) for Cont right
03:05:03 <jle`> wait
03:05:07 <abhiranjan>  Does adding Main module speeds a code?
03:05:31 <klrr_> is there any lens compatible lens library with less deps but provides (_1) and (_2)?
03:05:31 <jle`> yeah it did
03:05:56 <edwardk> klrr_: probably lens-family
03:05:58 <abhiranjan> I have two similar codes, only difference is that one is in Main module and other is without it.
03:06:12 <edwardk> http://hackage.haskell.org/package/lens-family-1.0.0/docs/Lens-Family2-Stock.html
03:06:13 <abhiranjan> First code runs very fast, as compare to code with Main module.
03:06:29 <klrr_> edwardk: thanks!
03:06:47 <jle`> i wonder why the module name is Family2
03:06:54 <jle`> it always struck me as a little weird
03:06:58 <klrr_> (i actually looked imported Lens.Family but it didnt import those functions since it was lens-family-core)
03:07:00 <edwardk> heh don't thank me yet. ;) i'll wait for you to bang your head on the ceiling of that for a while and come back to lens ;)
03:07:08 <matheus23> So now that I updated gcc ($ gcc --version: gcc (GCC) 4.9.0 20140604 (prerelease)) $ cabal install haskell-src-exts still doesn't work, because gcc segfaults... I'm on archlinux, I just updated all packages and everything is up to date
03:07:14 <klrr_> edwardk: haha
03:07:15 <abhiranjan> 1st code. http://lpaste.net/105660
03:07:24 <abhiranjan> 2nd code: http://lpaste.net/105659
03:07:44 <edwardk> jle`: sadly it is that naming convention that drove me to write lens in the first place. it just felt..bad
03:08:09 <jle`> ...but what is the convention?
03:08:41 <edwardk> ask roconnor. i figured Lens.Family.Core an Lens.Family would be the right module convention for it, but he disagreed at the time
03:08:43 <jle`> put the number of letters in the module name divided by three?
03:09:04 <jle`> ah
03:10:47 <jle`> is there a commonly used library for encoding/sending rest api-like requests
03:12:13 <kazagistar> whats a good argument parser? I tried GetOpt, but it requires a lot of extra work to make it do default arguments, additional verifications, etc
03:12:29 <Maior> kazagistar: optparse-applicative
03:12:33 <klrr_> options-applicative worked nice for idris
03:12:33 <bergmark> jle`: for writing clients?
03:12:41 <klrr_> optparse-applicative yes
03:12:50 <klrr_> it have some tiny drawbacks, but is overall very nice
03:12:51 <jle`> bergmark: yes
03:13:36 <klrr_> (if you have `many` parsers with defaults values you get kinda stuck, but you can work around if you add different arguments for default and non-default)
03:13:49 <bergmark> jle`: ok, then i don't know. we have http://silkapp.github.io/rest/ which generates clients but only for apis written in the same framework
03:14:32 <jle`> i just want to download my last.fm data
03:14:47 <bergmark> jle`: ah, ask chrisdone about that :-)
03:15:01 <jle`> and it offers an api where you send get requests with parameters in the ...
03:15:05 <jle`> what do you call it
03:15:27 <jle`> URL params
03:15:48 <alpounet> @google chris done last.fm
03:15:49 <lambdabot> http://chrisdone.com/posts/lastfm
03:15:49 <lambdabot> Title: Last.fm / scrobbling
03:15:58 <alpounet> jle`:  ^^^^^
03:17:38 <jle`> ty but it was also more of a learning project >>
03:17:40 <jle`> >_>
03:18:04 <jle`> hm oh there is a client
03:18:48 <jle`> ah he just used Network.Curl
03:19:01 <jle`> which was what i was going to do if i didn't find anything
03:19:13 <jle`> but thinking back i wonder what something on top of curl could even offer
03:19:21 <jle`> it's a pretty dead simple task i guess
03:21:20 <kazagistar> Maior, klrr_: thanks, that looks a bit more like what I was expecting, looks solid and minimal
03:21:37 <kazagistar> (minimal in code required to use, not in features or whatever)
03:25:08 <yitz> chrisdone: but that doesn't match the semantics of version dependencies. you aren't saying that.
03:26:32 <yitz> chrisdone: you are not saying "i don't know what versions it works with". you are saying "given what i know about this package, i believe it is reasonable to assume that all versions of it will work with my package for the forseeable future."
03:26:52 <matheus23> Something is _really_ wrong with cabal-install, isn't it?
03:27:58 <matheus23> *sigh* I can't cabal install darcs.
03:28:15 <klrr_> is there any function with this type: Monad m => (a -> m a) -> a -> m a ?
03:28:29 <klrr_> where a is a tree-like structure
03:28:31 <yitz> chrisdone: if you don't know anything about how version work for a dependent package, and no special considerations about how you are using it, then it makes sense to say is "it is reasonable to assume that it will work with my package at least up to the next breaking API change as determined by PVP."
03:28:32 <vanila> klrr_, id ?
03:28:34 <vanila> oh
03:28:37 <matheus23> because of a conflict "conflict: deepseq =>
03:28:37 <matheus23> array==0.5.0.0/installed-9f2..., darcs => array>=0.1 && <0.5"
03:28:38 <vanila> what do you want it to do exactly
03:29:25 <yitz> chrisdone: it used to be a problem to say that - even though it's the right thing to say - due to limitations in cabal. but now cabal is much more powerful than it used to be.
03:29:51 <klrr_> well, a is an AST i want to go through it, record state on some places (to count free variables to be precise) and when i find a lambda i want to change it to an application and record the lambda in the state so i can later move it to the top level with a generated name
03:30:23 <yitz> chrisdone: even if it turns out that your package works with much later versions of the dependency, people will not have trouble using them in the future. so now there is no reason not to tell the truth.
03:30:28 <klrr_> just wonder if there some general function for this
03:30:51 <klrr_> so i only have to define it for a, then just implement (a -> m a) and im done
03:31:47 <yitz> chrisdone: and there is good reason not to lie - because when you lie, you create a lot of inconvenience for people trying to use older versions of your package in the future, e.g., when they are trying to support products they released in the past using your package.
03:32:01 <klrr_> it is a traverse
03:32:03 <klrr_> i want
03:32:10 <klrr_> but i dont know how, since a is just a, not t a
03:34:30 <klrr_> :t traverse
03:34:31 <lambdabot> (Traversable t, Applicative f) => (a -> f b) -> t a -> f (t b)
03:34:44 <klrr_> (Exp -> LamLift Exp) -> Exp -> LamLift Exp
03:34:54 <klrr_> where Exp is a syntax tree
03:34:56 <klrr_> and
03:35:02 <klrr_> LamLift is a monad transformer
03:35:25 <yitz> klrr_: traverse is like mapM, except for Applicative instead of Monad, and for general containers, not just lists.
03:35:48 <klrr_> yes
03:36:36 <klrr_> :t fmap
03:36:37 <lambdabot> Functor f => (a -> b) -> f a -> f b
03:36:53 <yitz> klrr_: so you are saying that here Exp is your container?
03:37:55 <klrr_> yes
03:38:18 <yitz> klrr_: the (Exp -> LamLift Exp) term is something you want to apply recursively?
03:38:30 <klrr_> yes
03:38:42 * hackagebot wavy 0.1.0.0 - Process WAVE files in Haskell.  http://hackage.haskell.org/package/wavy-0.1.0.0 (RobertMassaioli)
03:38:44 * hackagebot http-kit 0.5.0 - A low-level HTTP library  http://hackage.haskell.org/package/http-kit-0.5.0 (SimonHengel)
03:38:52 <klrr_> i want to somehow "map" it over Exp
03:42:00 <yitz> klrr_: so f' exp = do { exp' <- f exp; cs <- mapM f $ children exp'; return exp' {children = cs} }
03:42:05 <yitz> klrr_: or something like that
03:42:22 <yitz> klrr_: so f' exp = do { exp' <- f exp; cs <- mapM f' $ children exp'; return exp' {children = cs} }
03:42:40 <yitz> (added a prime to the inner f)
03:44:00 <klrr_> thanks!
03:44:10 <yitz> klrr_: this is a really common idiom for trees. we could write a combinator for it in Data.Tree. i wonder if there is a satifying generalization of it.
03:46:51 <hayashi> Hmm.  I have a type Statement assignment expression compound body, where compound and body are of kind * -> * and are supplied recursively with the full statement type.
03:47:44 <hayashi> I'm trying to derive Read for this type, but falling flat when it comes to figuring out how to express the constraint that Read can be derived only if Read exists for ( compound a ) and ( body a ), when Read exists for a
03:47:48 <hayashi> Is this even possible!?
03:47:53 <hayashi> It sounds like going around and around and around in circles
03:47:57 <yitz> klrr_: really, this isn't a "traverse"; it's an "extend", from comonad. except we need a monadic (or applicative) version of that.
03:49:32 <hayashi> It's annoying that the compound and body types are ever so nearly fixed points, but the recursion isn't direct
03:49:43 <yitz> edwardk: (if you are around) what is a version of extend from comonad for when the result is applicative or monadic?
03:50:00 <hayashi> a compound'll take a statement which takes a compound which takes a statement which takes a compound and so on ad infinitum
03:50:20 <Kaidelong> @ty (fmap pure)
03:50:21 <lambdabot> (Applicative f1, Functor f) => f a -> f (f1 a)
03:50:58 <Kaidelong> oh wait, is extend =>>?
03:51:02 <Kaidelong> @ty (=>>)
03:51:03 <lambdabot>     Not in scope: ‘=>>’
03:51:03 <lambdabot>     Perhaps you meant one of these:
03:51:03 <lambdabot>       ‘>>’ (imported from Control.Monad.Writer),
03:51:09 <Kaidelong> @ty extend
03:51:10 <lambdabot> Not in scope: ‘extend’
03:52:58 <Kaidelong> (Exp -> LamLift Exp) -> Exp -> LamLift Exp is inhabited by id
03:54:51 <yitz> @type Control.Comonad.extend
03:54:52 <lambdabot> Control.Comonad.Comonad w => (w a -> b) -> w a -> w b
03:55:17 <yitz> the classic comonad is Data.Tree, so think of w as Data.Tree here
03:56:22 <yitz> in that case, extend, take a function on a subtree and applies it recursively across the tree. just what klrr_ wants - except klrr_ needs the result function to be in a monad.
03:57:04 <Kaidelong> well in haskell it's not possible to derive extend from monads in general but it is possible to derive monads from comonads
03:57:12 <yitz> (Comonad w, Applicative f) => (w a -> f b) -> w a -> f (w b)
03:58:03 <byorgey> Kaidelong: it is?
03:58:31 <Kaidelong> byorgey: I thought so? didn't edward make a newtype wrapper that did something to that effect?
03:58:41 <yitz> oh, byorgey ! hi ! do you know the answer to this question?
03:58:52 <byorgey> yitz: what's the question?
03:58:59 <byorgey> hi!
03:59:07 <hayashi> nvm, I've found a workaround by deriving instances for type synonyms that bake in appropriate values for those type parameters
03:59:20 <byorgey> Kaidelong: I don't know of any; then again edwardk has made a lot of things I don't know about
03:59:58 <yitz> byorgey: an analog for traverse, for comonads. just like traverse is like map except for when the result is applicative, we need extend for comonads except for when the result is applicative.
04:00:13 <Kaidelong> byorgey: Comonad inherits Functor so you could just use the free monad, actually
04:00:29 <klrr_> yitz: oh comonad, gotta look into that
04:00:58 <byorgey> Kaidelong: sure, but you can do that for *any* functor.  I wouldn't call that "deriving monads from comonads".
04:01:10 <byorgey> yitz: hmm, I don't know
04:01:13 <gustavn> > inits [1,2,3,4]
04:01:15 <lambdabot>  [[],[1],[1,2],[1,2,3],[1,2,3,4]]
04:01:17 <gustavn> > tails [1,2,3,4]
04:01:19 <lambdabot>  [[1,2,3,4],[2,3,4],[3,4],[4],[]]
04:02:18 <yitz> hayashi: when you say compound a and body a have Read instances - what is a? the same as assignment? the same as expression? something else?
04:02:18 <AlecTaylor> hi
04:02:27 <AlecTaylor> What's a good resource for learning Haskell?
04:02:45 <gustavn> alectaylor: http://learnyouahaskell.com/
04:02:49 <Kaidelong> what are you looking to learn?
04:02:52 <yitz> (Comonad w, Applicative f) => (w a -> f b) -> w a -> f (w b) -- byorgey, this is the type we want. you can add an additional constraint, analogous to Traversable.
04:03:13 <yitz> byorgey: cotraversable?
04:03:14 <AlecTaylor> Kaidelong: I want to utilise LLVM to create a bridge between different languages
04:03:26 <AlecTaylor> Quite a trivial process
04:03:35 <Kaidelong> AlecTaylor: you're basically writing a compiler then?
04:03:45 * hackagebot ampersand 3.0.2 - Toolsuite for automated design of business processes.  http://hackage.haskell.org/package/ampersand-3.0.2 (hanjoosten)
04:03:47 * hackagebot Agda 2.4.0.1 - A dependently typed functional programming language and proof assistant  http://hackage.haskell.org/package/Agda-2.4.0.1 (UlfNorell)
04:03:52 <AlecTaylor> But I want to give an example of calling Haskell code from a bunch of different languages
04:04:01 <klrr_> AlecTaylor: oh i think there is a tutorial about just that
04:04:06 <edwardk> byorgey: you _can_ use newtype Co w a = Co { runCo :: w (a -> r) -> r } -- to derive a monad from any comonad w, such that Co (Costate s) = State s, Co (Coreader e) = Reader e and Co (Cowriter e) = Writer e ;)
04:04:06 <AlecTaylor> Kaidelong: Not even! - I'm using someone else's compiler :P
04:04:12 <yitz> byorgey: the case we're thinking about is concretely is when you apply an operation recursively over a tree. comes up all the time.
04:04:15 <AlecTaylor> klrr_: Great, link?
04:04:28 <byorgey> edwardk: neat!
04:04:34 <klrr_> dont have it sorry, but it exists if you wanna google
04:04:57 <edwardk> byorgey: i wrote a series of articles on it, and showed that every comonad gives rise to not only a monad, but a monad transformer
04:04:59 <Kaidelong> klrr_: any idea what it was called?
04:05:00 <Kaidelong> http://www.stephendiehl.com/llvm/
04:05:17 <klrr_> oh ist that one
04:05:56 <Kaidelong> attn AlecTaylor
04:06:08 * byorgey googles it and adds it to his reading queue
04:06:14 <gustavn> let f (x:xs) = product (x:xs) : map (x :) (f xs)
04:06:20 <gustavn> > let f (x:xs) = product (x:xs) : map (x :) (f xs)
04:06:21 <lambdabot>  not an expression: ‘let f (x:xs) = product (x:xs) : map (x :) (f xs)’
04:06:22 <yitz> (Comonad w, Applicative f) => (w a -> f b) -> w a -> f (w b) -- edwardk, what is this called? you can add an additional constraint, analogous to Traversable.
04:06:31 <AlecTaylor> Thanks Kaidelong
04:06:34 <AlecTaylor> Will check that out
04:06:37 <gustavn> How do you make lambdabot remember definitions?
04:06:40 * AlecTaylor is also going through gustavn's link
04:06:48 <yitz> edwardk: extend, except for when the result is applicative
04:06:55 <Kaidelong> --@let
04:06:59 <AlecTaylor> I did a little Scala in uni, so it's mostly familiar
04:07:01 <gustavn> @let f (x:xs) = product (x:xs) : map (x :) (f xs)
04:07:02 <lambdabot>  .L.hs:157:44:
04:07:02 <byorgey> gustavn: try @let, or  let ... in ...
04:07:02 <lambdabot>      Ambiguous occurrence ‘f’
04:07:02 <lambdabot>      It could refer to either ‘L.f’, defined at .L.hs:157:1
04:07:02 <lambdabot>                            or ‘Debug.SimpleReflect.f’,
04:07:02 <lambdabot>                               imported from ‘Debug.SimpleReflect’ at .L.hs:11...
04:07:14 <gustavn> @let fff (x:xs) = product (x:xs) : map (x :) (fff xs)
04:07:15 <lambdabot>  .L.hs:157:40:
04:07:16 <lambdabot>      Occurs check: cannot construct the infinite type: a ~ [a]
04:07:16 <lambdabot>      Relevant bindings include
04:07:16 <lambdabot>        xs :: [[a]] (bound at .L.hs:157:10)
04:07:16 <lambdabot>        x :: [a] (bound at .L.hs:157:6)
04:07:25 <Kaidelong> gustavn could you PM lambdabot?
04:07:40 <gustavn> Kaidelong: Yeah, sorry! :)
04:07:45 <BinTreeProblems> hey, anyone want to help with tree folding ? I'm stuck in using my treefold correctly!
04:08:25 <edwardk> yitz: i don't believe that function can exist in general
04:08:47 <yitz> edwardk: could be not. but for trees it does, and it comes up all the time.
04:08:50 <edwardk> consider w = (->) e  where you have a Monoid on e.
04:09:02 <yitz> edwardk: that's the only interesting comonad that has this?
04:09:46 <edwardk> probably not the only interesting one, but you're going to need a lot from your comonad to make that go
04:09:53 <Kaidelong> @ty \f -> fmap (f: (Comonad w, Applicative f) => forall a. w a -> w f)) . Control.Comonad.duplicate
04:09:54 <lambdabot> parse error on input ‘=>’
04:10:02 <byorgey> BinTreeProblems: just ask your question and maybe someone will answer.  You can paste your code at lpaste.net
04:10:06 <Kaidelong> @ty \f -> fmap (f :: (Comonad w, Applicative f) => forall a. w a -> w f)) . Control.Comonad.duplicate
04:10:06 <gustavn> Now I'm interested: Does anyone know if this definition can be written more elegantly as a fold?
04:10:07 <lambdabot> parse error on input ‘)’
04:10:08 <gustavn> fff [] = []
04:10:08 <gustavn> fff (x:xs) = [product (x:xs)] : map (x :) (fff xs)
04:10:35 <Kaidelong> @ty \f -> fmap (f :: (Comonad w, Applicative f) => forall a. w a -> f a) . Control.Comonad.duplicate
04:10:36 <lambdabot>     Not in scope: type constructor or class ‘Comonad’
04:10:41 <Kaidelong> okay well
04:10:58 <Kaidelong> it seems like you just have a natural transformation applied to the contents of a duplicated comonad, there
04:11:07 <edwardk> (w a -> f b)  can be extended to w a -> w (f b)  so now all you need is a distributive law that lets you commute f out over w, which can be only done in general based on f if f is representable (isomorphic to (x -> _) for some x. or if we know more about w.
04:11:07 <Kaidelong> I'm pretty sure you can realize the type like that
04:12:42 <edwardk> ultimately you need w (f a) -> f (w a) -- which exists when w is traversable or f is distributive, pick your poison
04:12:58 <edwardk> for your tree example w is traversable
04:14:50 <BinTreeProblems> http://lpaste.net/105662 Hi can someone help me with these 2 functions?
04:15:37 <Yuu_chan> How to easily run mconcat in parallel?
04:19:24 <Yuu_chan> BinTreeProblems: when an element is in a tree>
04:19:55 <byorgey> BinTreeProblems: what have you tried?
04:20:05 <yitz> edwardk: w traversable makes perfect sense
04:20:07 <byorgey> BinTreeProblems: a good place to start is by writing out the type of 'f' on line 19
04:21:40 <Kaidelong> Yuu_chan: you can't, you'd need to write your own mconcat
04:21:53 <yitz> > let f xs@(x:xs') = [product xs] : map (x :) (f xs') in f [1..4]
04:21:55 <lambdabot>  [[24],[1,24],[1,2,12],[1,2,3,4]*Exception: <interactive>:3:5-51: Non-exhaust...
04:22:12 <Kaidelong> that mconcat will have different semantics unless mappend is commutative, too
04:22:31 <yitz> > let f xs@(x:xs') = [product xs] : map (x :) (f xs'); f _ = [] in f [1..4]
04:22:34 <lambdabot>  [[24],[1,24],[1,2,12],[1,2,3,4]]
04:23:52 <Yuu_chan> Kaidelong: what for commutativity is needed here?
04:24:50 <Kaidelong> the sort of approach that comes to mind is something like "mreduce [] = mempty ; mreduce (x:[]) = x ; mreduce (x:y:xs) = let v = x `mappend` y in let vs = mreduce xs in v `par` vs `pseq` mreduce (v:vx)"
04:25:16 <Kaidelong> Yuu_chan: because rather than traversing a list you're building a kind of tree structure and traversing that
04:25:45 <Kaidelong> you want ((x `mappend` y) `mappend` (z `mappend` w))
04:25:59 <Adeon> is there a divison that does `div` when dealing with integrals and (/) when dealing fractionals
04:26:06 <Yuu_chan> Kaidelong: yes, and associativity allows that IIRC
04:26:07 <Kaidelong> not the foldr version which is (x `mappend` (y `mappend` (z `mappend` w)))
04:26:07 <yitz> let f xs = zipWith (++) (inits xs) (map ((:[]) . product) $ tails xs) in f [1..4]
04:26:10 <yitz> > let f xs = zipWith (++) (inits xs) (map ((:[]) . product) $ tails xs) in f [1..4]
04:26:11 <lambdabot>  [[24],[1,24],[1,2,12],[1,2,3,4],[1,2,3,4,1]]
04:26:27 <Kaidelong> Yuu_chan: oh, you may be right, associativity may be enough yes
04:26:35 <yitz> > let f xs = init $ zipWith (++) (inits xs) (map ((:[]) . product) $ tails xs) in f [1..4]
04:26:37 <lambdabot>  can't find file: L.hs
04:26:50 <byorgey> Adeon: no
04:26:55 <Kaidelong> anyway you can try my naive mreduce implementation and see if it works
04:27:10 <yitz> > let f xs = init $ zipWith (++) (inits xs) (map ((:[]) . product) $ tails xs) in f [1..4]
04:27:11 <lambdabot>  [[24],[1,24],[1,2,12],[1,2,3,4]]
04:27:16 <Kaidelong> there may be a better one out there but it is different from mconcat
04:27:21 <Adeon> too bad
04:27:37 <yitz> gustavn: ^^ another way to write your function
04:27:45 <byorgey> Adeon: can you explain why you want that?
04:28:09 <Adeon> I'm cutting a rectangle in half and its numeric type is polymorphic
04:28:19 <gustavn> yitz: Cool, that looks easier to rewrite in point-free form
04:28:23 <gustavn> yitz: Thanks!
04:28:48 <tdammers> Adeon: integer division and fractional division are two different operations though
04:29:11 <Adeon> I know but for this particular operation it's sensible either way
04:29:19 <byorgey> Adeon: ah, I see.  So this will be specifically restricted to doing either  (`div` 2)   or  (/ 2) /
04:29:22 <byorgey> ?
04:29:25 <Adeon> yeah
04:29:36 <tdammers> but what if your polymorphic type supports both?
04:29:43 <Adeon> actually I think the types are restricted a bit so I may be able to go around this
04:29:52 <byorgey> Adeon: you could make your own class like  class Halvable a where  halve :: a -> a  and then make instance   Havlable Int,  Halvable Double, ... etc.
04:30:10 <tdammers> byorgey: except that this won't work for custom numeric types injected from elsewhere
04:30:16 <tdammers> unless they also implement Halvable themselves
04:30:45 <byorgey> tdammers: that's true.  I don't know whether that is actually an issue in Adeon's case.
04:30:46 <dottedmag> tdammers: Can one have an instance for every Fractional and every Integral?
04:30:51 <Kaidelong> byorgey: more elegant solution might be to make two overlapping instances for Fractional and Integral
04:31:02 <Kaidelong> you'd need a dangerous extension but nothing should implement both
04:31:13 <byorgey> Kaidelong: no, that wouldn't work
04:31:24 <byorgey> because instance selection does not look at the constraints
04:31:40 <byorgey> it would sometimes pick the wrong instance and give you an error
04:31:52 <Kaidelong> oh, that is sad
04:31:57 <gustavn> Is there any elegant solution to map one value through a pair of functions and get a pair back?
04:32:16 <yitz> @type (&&&)
04:32:17 <lambdabot> Arrow a => a b c -> a b c' -> a b (c, c')
04:32:19 <Kaidelong> maybe Data.Newtype can come to the rescue here
04:32:19 <Adeon> yes, &&&
04:32:52 <yitz> where you can think of "a" in that type as function application, (->)
04:32:57 <byorgey> > (succ &&& (*7)) 3
04:32:58 <gustavn> oh
04:32:59 <lambdabot>  (4,21)
04:33:06 <gustavn> Yeah, I get it
04:33:11 <gustavn> i think
04:33:19 <byorgey> gustavn: see my example above ^^^
04:33:48 <tdammers> gustavn: if you specialize a as (->), you can read the signature as (b -> c) -> (b -> c') -> (b -> (c, c'))
04:34:06 <tdammers> gustavn: does it make more sense that way?
04:34:08 <pjdelport> People sometimes use ~> for arrows, too.
04:34:17 <BoR0> yes it does make more sense that way
04:34:18 <gustavn> absolutely
04:34:49 <tdammers> it's still the same thing, just that we've substituted (->) for a
04:35:13 <tdammers> and the benefit of this is that it'll work for all arrows, not just functions
04:35:15 <BoR0> what is the purpose of writing it with Arrow a constraint?
04:35:49 <tdammers> you need the Arrow constraint to be able to actually write the function
04:36:03 <yitz> enthropy, chrisdone: anyway, i see now what formatting is. it's a nice library, thanks!
04:36:24 <tdammers> if it were just unconstrained a b c -> a b c' -> a b (c, c'), you wouldn't have a way to fan out and turn your b's into c and c' values
04:36:31 <hayashi> Aw, now I have orphan instances.
04:37:06 <BoR0> tdammers, aha, okay
04:37:42 <gustavn> tdammers: Aren't all functions arrows?
04:37:49 <chrisdone> fwiw i wrote some docs and examples https://github.com/chrisdone/formatting
04:38:09 <gustavn> tdammers: I thought being a function is a constraint on an arrow
04:38:19 <yitz> klrr_: so the conclusion is that what you want is f' = sequenceA . extend f
04:38:40 <klrr_> :t sequenceA . extend
04:38:41 <dottedmag> gustavn: So you've got a more generic function, which also works for function as a special case.
04:38:41 <lambdabot>     Not in scope: ‘sequenceA’
04:38:41 <lambdabot>     Perhaps you meant one of these:
04:38:41 <lambdabot>       ‘T.sequenceA’ (imported from Data.Traversable),
04:38:46 <byorgey> chrisdone: neat
04:38:47 <dottedmag> *for functions
04:38:48 * hackagebot formatting 5.0 - Combinator-based type-safe formatting (like printf() or FORMAT)  http://hackage.haskell.org/package/formatting-5.0 (ChrisDone)
04:38:49 <klrr_> :t T.sequenceA . extend
04:38:50 <lambdabot> Not in scope: ‘extend’
04:38:55 <klrr_> :t T.sequenceA . C.extend
04:38:56 <lambdabot> Not in scope: ‘C.extend’
04:39:14 <yitz> @type \f -> T.sequenceA . Control.Comonad.extend f
04:39:15 <lambdabot> (Control.Comonad.Comonad t, Traversable t, Applicative f) => (t a1 -> f a) -> t a1 -> f (t a)
04:39:44 <tdammers> gustavn: all functions are arrows, but not all arrows are functions
04:39:46 <byorgey> chrisdone: Holey Builder, batman!
04:39:58 <klrr_> yitz: thanks!
04:40:10 <tdammers> gustavn: by constraining it to Arrow rather than (->), it works on all Arrows, including but not limited to functions
04:40:10 <chrisdone> byorgey: haha
04:40:25 <yitz> chrisdone: there are actually nice examples right in the library itself
04:40:35 <edwardk> I wish we'd been able to better fit the holey stuff with lens
04:40:37 <gustavn> tdammers: You aren't constraining it though... ? You are making it more general
04:40:54 <chrisdone> yitz: =)
04:40:56 <gustavn> tdammers: It can't be a constraint because it still works on at least all regular functions
04:40:58 <BoR0> I guess it's more general in contrast to functions. there are a lot of "generals"  :)
04:41:18 <tdammers> gustavn: it's a constraint, but a less strict one than (->) would be
04:41:19 <chrisdone> yitz: thanks, was wondering if anyone would notice, i should probably point that module out
04:41:59 <tdammers> b -> c -- strictest constrained, (->) isn't polymorphic
04:42:10 <tdammers> a b c -- no constraint, a can be any type
04:42:27 <tdammers> Arrow a => a b c -- in between; a can be any type that satisfies Arrow constraint
04:42:41 <tdammers> the first one works *only* for functions
04:43:00 <tdammers> the second one would work for any type, but the function cannot be written in a meaningful way
04:43:13 <tdammers> the third one can be written, and works on all arrows, including functions
04:43:51 <gustavn> Okay so I rewrote my function in point-free style: fff = uncurry (zipWith (++)) . ((map ((:[]) . product) . tails) &&& inits)
04:44:09 <gustavn> @let fff = uncurry (zipWith (++)) . ((map ((:[]) . product) . tails) &&& inits)
04:44:10 <lambdabot>  .L.hs:149:1:
04:44:10 <lambdabot>      Multiple declarations of ‘fff’
04:44:10 <lambdabot>      Declared at: .L.hs:146:1
04:44:10 <lambdabot>                   .L.hs:149:1
04:44:13 <gustavn> @undefine
04:44:13 <lambdabot> Undefined.
04:44:15 <gustavn> @let fff = uncurry (zipWith (++)) . ((map ((:[]) . product) . tails) &&& inits)
04:44:17 <lambdabot>  Defined.
04:44:28 <gustavn> I'm not sure though, how to reverse the result
04:44:34 <gustavn> > fff [2,2,3]
04:44:36 <lambdabot>  [[12],[6,2],[3,2,2],[1,2,2,3]]
04:44:53 <gustavn> I want it to go in lexographical order
04:45:15 <tdammers> :t reverse
04:45:16 <lambdabot> [a] -> [a]
04:45:24 <tdammers> > reverse [1, 2, 3]
04:45:25 <lambdabot>  [3,2,1]
04:45:38 <gustavn> tdammers: Of course, but I want to do it in the function itself, and I can't seem to figure out where to do it
04:45:38 <tdammers> > reverse $ fff [ 2,2,3 ]
04:45:40 <lambdabot>  [[1,2,2,3],[3,2,2],[6,2],[12]]
04:45:50 <tdammers> just slap a `reverse .` in front?
04:46:08 <gustavn> tdammers: Yeah, but I'm sure it can be done by reorganizing stuff in the function itself
04:46:21 <gustavn> Look if I flip the two values around &&&:
04:46:32 <gustavn> @let fff = uncurry (zipWith (++)) . (inits &&& (map ((:[]) . product) . tails))
04:46:33 <lambdabot>  Defined.
04:46:38 <gustavn> > fff [2,2,3]
04:46:40 <lambdabot>  [[12],[2,6],[2,2,3],[2,2,3,1]]
04:48:50 * hackagebot MonadCatchIO-transformers 0.3.1.1 - Monad-transformer compatible version of the Control.Exception module  http://hackage.haskell.org/package/MonadCatchIO-transformers-0.3.1.1 (AriePeterson)
04:55:19 <danilo2> Hello! Is it possible in Haskell to increment or decrement Nat values (PolyKinds)?
04:56:26 <PDani> hi
04:56:44 <Maior> :i Nat
04:57:48 <PDani> I've read that ghc versions are tightly knit to the corresponding base versions, and they should be installed together. How do I know which ghc version is bound to which base version?
05:01:13 <Kaidelong> danilo2: all type level Nat values have kind * in the same way [Int] and Int both have kind * so I'm not sure polykinds would help. But you can use polymorphism to work with decrements and increments ala 'init :: Vec (Succ n) t -> Vec n t' and 'cons :: t -> Vec n -> Vec (Succ n) t'
05:01:57 <Kaidelong> Vec n t*
05:02:53 <Kaidelong> basically to make operations that work on all nats at the type level you need to be polymorphic over nats (as opposed to being monomorphic over a set)
05:03:38 <danilo2> Kaidelong: I think I found tghe answer - there are defined some type families in the GHC.Typelits package!
05:04:48 <danilo2> Kaidelong: Oh, they are not the thing I wanted. hmm defining all such successors by hand (for a lot of Nat - ints) would be a pain
05:13:53 * hackagebot aeson-qq 0.7.2 - JSON quasiquoter for Haskell  http://hackage.haskell.org/package/aeson-qq-0.7.2 (SimonHengel)
05:17:22 <Flonk> While reading up about `fix` someone on StackOverflow mentioned that writing fix `fix f = let x = f x in x` does not need any additional memory (while `fix f = f $ fix f` of course does). How come?
05:18:14 <vanila> fine
05:21:13 <yitz> PDani: for installing them, you don't usually need to know. base comes bundled with ghc itself.
05:22:47 <yitz> PDani: if anyway you want to know, there is probably a way to look that up on the ghc web site, but i don't know it.
05:23:19 <yitz> PDani: for versions of ghc that happened to have been the official supported version in a haskell platform release, you can look it up on the haskell platform web site.
05:28:16 <yitz> Flonk: it looks to me like the first version gives you a function directly, while the second version gives a thunk which, when evaluated, gives you a function. and that extra thunk will come up for each iteration.
05:33:49 <eroomde> Hi, I'm just about to get my feet wet with LYAH, and notice it recommends getting the Haskell Platform to start. At the risk of sounding a bit 'kids these days' it looks like it has stopped being updated in that there were fairly regular updates up to the latest advertised but nothing in 2014. Is that still the best place to get started or has it been superceded by something else?
05:34:50 <yitz> eroomde: there was a big delay, but a new version is coming out within the next few weeks.
05:35:09 <yitz> eroomde: for LYAH the old one should be just fine, and is easiest to install.
05:35:23 <eroomde> yitz, thank you very much
05:35:30 <eroomde> I'll download it now
05:38:56 * hackagebot stm-io-hooks 1.0.0 - STM with IO hooks  http://hackage.haskell.org/package/stm-io-hooks-1.0.0 (PeterRobinson)
05:40:58 <magnap> I have a number of functions in a module, all taking a configuration parameter (currently :: [Double], could be changed). I would prefer to somehow "initialize" them with a configuration once, and then be able to use them configured henceforth. Is this possible?
05:45:03 <lieven_> magnap: Data.Reflection perhaps?
05:46:02 <magnap> I was considering doing something with the Reader monad. Data.Reflection looks from a cursory glance way over my head.
05:46:35 <lieven_> the paper it's referring too is fairly readable
05:48:37 * magnap begins reading
05:51:18 <PDani> yitz: thanks. the concrete use-case is that a cabal package complains during installation about not having a specific version of base. So the input is the required version of base, and I should be able to determine which ghc do I need for it
05:51:27 <klrr_> anyone know any resource on lambda lifting? ive found several good explainations on wikipedia, haskell wiki and SO, but all of them seems to omit the part of finding the callees of a lambda so you can make sure they pass the (new) required arguments?
06:01:03 <yitz> PDani: yeah. i wish i knew where the exact answer could easily be looked up. but you can easily find the latest version of haskell platform that is supported, and use that.
06:02:32 <yitz> PDani: in addition - there are good chances that the library will actually work with recent ghc. you can try that with cabal install --allow-newer=base (i think that's the syntax.)
06:03:42 <yitz> magnap: you are right though that the Reader monad is the standard way to do that.
06:06:41 <magnap> yitz: Is there a way to use it "through" a module? The module in question exports a number of functions, all taking a configuration, which is first known at import.
06:10:34 <BoR0> > 1 + 1
06:10:35 <lambdabot>  2
06:11:07 <BoR0> > (take 348 $ repeat 'a') ++ "> 1+1" ++ (take 348 $ repeat ' ')
06:11:08 <lambdabot>  "aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa...
06:14:00 * hackagebot machinecell 1.0.1 - Arrow based stream transducers  http://hackage.haskell.org/package/machinecell-1.0.1 (HidenoriAzuma)
06:16:29 <danilo2> Hello! Would somebody be so nice and tell me why the instance declared in line 39 does not compile? If we comment it, everything else compiles ok. I've got some problem with Nat values and type operators here :( http://lpaste.net/105664
06:21:35 <rwbarton> danilo2: + is a type synonym family
06:22:37 <the-magnap> yitz: How could I use the Reader monad for such a purpose? If you have already answered, I'm sorry I, I missed it. I had a major dispute with my IRC client, and have now replaced it.
06:24:03 <rwbarton> danilo2: I don't think you can effectively induct on Nat anyways because the solver is very weak currently
06:25:04 <danilo2> rwbarton: Ah, but wait - what is type SYNONYM family? I do not rthink I've ever heard about it - or have I and right now I'm asking stupid questions?
06:26:18 <rwbarton> danilo2: just the same as a type family, as opposed to a data family
06:26:43 <rwbarton> I don't know why it doesn't just say "type family"
06:27:24 <rwbarton> but the idea is that if you have an instance of a type family, type instance Foo Int = Char, now Foo Int is a synonym for Char
06:29:02 * hackagebot Nomyx-Language 0.6.1 - Language to express rules for Nomic  http://hackage.haskell.org/package/Nomyx-Language-0.6.1 (CorentinDupont)
06:29:04 * hackagebot Nomyx-Core 0.6.1 - A Nomic game in haskell  http://hackage.haskell.org/package/Nomyx-Core-0.6.1 (CorentinDupont)
06:29:06 * hackagebot Nomyx-Web 0.6.1 - Web gui for Nomyx  http://hackage.haskell.org/package/Nomyx-Web-0.6.1 (CorentinDupont)
06:29:08 * hackagebot Nomyx 0.6.1 - A Nomic game in haskell  http://hackage.haskell.org/package/Nomyx-0.6.1 (CorentinDupont)
06:30:13 <rwbarton> at the moment I think (+) is effectively a type family with an infinite number of instances   type instance (+) 3 1 = 4 -- etc.
06:31:35 <joshc> the-magnap: there is an example of using the Reader monad here: http://www.haskell.org/haskellwiki/All_About_Monads#The_Reader_monad
06:32:15 <danilo2> rwbarton: Ok, thank you :)
06:39:29 <PDani> yitz: wow, thanks! I didn't know about that switch
06:40:15 <pjdelport> the-magnap: The Reader monad gives you an abstraction for things that read a value from a shared environment. You'll basically be building stuff around "ask".
06:40:53 <isomorphismes> tryhaskell.org <--- haha. It says do line
06:41:44 <pjdelport> the-magnap: You can use the usual functor/applicative/monadic combinators to compose bigger and bigger computations together, that all internally use ask and related functions to read the environment, and then at the end, run the whole thing with a certain environment value.
06:42:03 <pjdelport> the-magnap: Reader does the plumbing to propagate that through the whole computation, without explicit argument passing.
06:43:56 <the-magnap> joshc,pjdelport: Thanks for your help. I think I have an idea (at least a vague concept) of what to do from here. I might be back with more questions later :-)
06:48:03 <pjdelport> > let foo = (*2) <$> ask; bar = (+) <$> foo <*> ask in runReader bar 5
06:48:05 <lambdabot>  15
06:48:25 <pjdelport> the-magnap: There's a little example in applicative style. :)
06:48:54 <Maxdamantus>  > let foo = (*2) <$> ask; bar = (+) <$> foo <*> ask in bar 5
06:49:09 <Maxdamantus> > let foo = (*2) <$> ask; bar = (+) <$> foo <*> ask in bar 5
06:49:11 <lambdabot>  15
06:51:07 <the-magnap> pjdelport: I can make sense of that. Thank you!
06:53:07 <pjdelport> the-magnap: You can obviously use do syntax and everything else, too; you just say "ask" wherever you want the environment, and bind or apply to the resulting MonadReader functions as usual, to use their values.
06:54:28 <the-magnap> pjdelport: And I export "wrapper functions" around the Reader monad?
06:54:45 <pjdelport> the-magnap: Then there are some convenience helpers, like asks, which just applies a function to the environment. That's useful when your environment is a compound value, like a record or similar.
06:55:43 <pjdelport> the-magnap: Depends what you mean, but you probably shouldn't need a wrapper. You can export the function as-is.
06:56:45 <the-magnap> pjdelport: Wouldn't that require the importer of my module to also import Control.Monad.Reader?
06:57:00 <r444> isomorphismes: i literally lold @ your "do line" comment
06:57:02 <pjdelport> MonadReader values are actually just functions themselves, with the default instance, so you don't need runReader to use them.
06:57:35 <pjdelport> With the above examples, you can just say "foo 5" or "bar 5" instead.
06:58:13 <the-magnap> What if I wanted to export baz where baz = bar 5 ?
06:58:30 <pjdelport> the-magnap: You just do that. :)
06:58:34 <pjdelport> Nothing special needed.
06:59:10 <the-magnap> pjdelport: Thanks!
07:00:10 <Krakarn> :t let foo = (*2) <$> id; bar = (+) <$> foo <*> id in bar 5
07:00:12 <lambdabot> Num b => b
07:00:32 <pjdelport> the-magnap: If you ignore monad transformers and all the other machinery, the Reader monad is incredibly simple
07:03:38 <ironChicken> compiling with cabal, GHC says "Could not find module `Text.Parsec.String'; It is a member of the hidden package `parsec-3.1.5'." but parsec is installed, and it's in the build-depends list for my library
07:03:45 <ironChicken> any ideas why i'm getting this?
07:04:18 <f-a> which version is installed, ironChicken
07:04:46 <ironChicken> 3.1.3 via debian, and 3.1.5 via cabal/hackage
07:06:03 <cloudhead> given a monadic action (m (Maybe a)) is there a way to combine it with another action such that the second action will only run if the Maybe is a Just?
07:06:04 <f-a> :s ironChicken the module is present in both versions :s
07:06:39 <cloudhead> something like:  go >>= onlyJust >>= f
07:06:39 <ironChicken> i can see "-package-id parsec-3.1.3-6c6e21cb4ed4ef9d58fdf442940b152e" with cabal -v build
07:08:49 <Krakarn> :t \f g -> (f >>= (when . isJust)) g
07:08:50 <lambdabot> Monad m => (m () -> Maybe a) -> m () -> m ()
07:09:15 <cloudhead> oo
07:09:26 <Sculptor> hi
07:09:39 <Krakarn> I think
07:09:50 <cloudhead> hm but I'd need to pass the inner value too
07:10:17 <Krakarn> wait
07:10:23 <Krakarn> :t when
07:10:23 <lambdabot> Monad m => Bool -> m () -> m ()
07:12:04 <ironChicken> ah, nevermind. the executable target needed the build-depends too.
07:13:04 <Krakarn> cloudhead: no that should work
07:13:21 <noteventime> I haven't been doing much Haskell in a while, has there been some consensus on what lens implementation to use?
07:13:46 <cloudhead> noteventime: lens
07:14:05 <noteventime> cloudhead: Thanks, that's what I thought, but there were numerous mentions of lens-core still around
07:14:19 <Krakarn> > (\f g -> (f >>= when . isJust) g) (return $ Just 5) (print "asdf")
07:14:20 <MalteM> pl \ f a b -> filter (/= 0) $ unionWith f a b
07:14:21 <lambdabot>  <IO ()>
07:14:33 <Krakarn> > (\f g -> (f >>= when . isJust) g) (return $ Nothing) (print "asdf")
07:14:34 <lambdabot>  <IO ()>
07:14:38 <Krakarn> hmm well
07:14:41 <Krakarn> it works in the interpreter anyway :P
07:15:17 <MalteM> ?
07:16:27 <cloudhead> hm
07:16:39 <Krakarn> maybe that's the problem hehe
07:16:49 <cloudhead> well, print would need access to '5'
07:17:05 <Krakarn> ah
07:17:07 <notdan> hm, can somebody please explain to me the inefficiency of the Free monad
07:17:51 <notdan> I tried reading Edward's "Free Monads for less" but I still don't get it why the standard free monad implementation is not efficient
07:18:52 <Krakarn> :t (\f g -> do { x <- f; when (isJust x) (g $ fromJust x) })
07:18:53 <lambdabot> Monad m => m (Maybe s) -> (s -> m ()) -> m ()
07:20:13 <cloudhead> yea
07:20:16 <cloudhead> that looks more like it :D
07:20:40 <c_wraith> notdan: there was a question on SO about this in the last few days, but I'm having trouble tracking it down.
07:22:05 <c_wraith> notdan: ah, here it is:  https://stackoverflow.com/questions/24189983/left-recursion-of-in-haskell
07:22:24 <notdan> thanks
07:22:47 <benzrf> sweet i wrote a cruddy 0mq <-> pipes interface 8D
07:23:20 <tdammers> ♥ 0mq
07:25:37 <benzrf> tdammers: u know pipes?
07:26:32 <tdammers> pipes as in unix pipes?
07:26:38 <tdammers> probably not
07:33:53 <benzrf> tdammers: no as in haskell pipes package
07:34:21 <tdammers> yeah, figured by now
07:34:30 <tdammers> but no, haven't tried that one yet
07:34:38 <benzrf> o its bretty cool
07:34:54 <snyp> How do I have a generic newtype, that acts exactly like another generic type (like Maybe a, so mine will be MyMaybe a)
07:35:18 <benzrf> snyp: newtype MyMaybe a = MyMaybe (Maybe a)
07:35:54 <snyp> benzrf, that's the notation, or are there caveats?
07:36:36 <benzrf> snyp: that will define a newtype around Maybe
07:36:49 <snyp> ok
07:38:12 <snyp> benzrf, I get : Illegal type signature: ‘MyMaybe Int'
07:38:32 <snyp> let a :: (MyMaybe Int) = Just (100::Int)
07:38:35 <snyp> in ghci
07:38:52 <delrik> hi all
07:39:36 <delrik> actually. lets do this properly. map (\_ -> "hi") all
07:42:44 <alexander__b>  /b blah
07:42:50 <alexander__b> oops
07:47:01 <MalteM> @delrik did you mean “map (("hi " ++) . name) all”?
07:47:01 <lambdabot> Unknown command, try @list
07:47:13 <kartoffelbrei> MalteM: beat me to it
07:47:54 <MalteM> ? Ich glaub, da reicht mein Englisch nicht …
07:54:12 * hackagebot haskell-packages 0.2.4.1 - Haskell suite library for package management and integration with Cabal  http://hackage.haskell.org/package/haskell-packages-0.2.4.1 (RomanCheplyaka)
08:04:58 <benzrf> hey
08:05:07 <benzrf> why arent you allowed to instance by parameters by default
08:05:21 <benzrf> i.e.
08:05:30 <benzrf> instance SomeClass (Foo Int)
08:05:30 <benzrf> vs
08:05:31 <benzrf> instance SomeClass (Foo ())
08:06:21 <byorgey> benzrf: just because when the Haskell standard was first developed, type classes were an extremely new feature, and so the standard was extremely conservative in what sorts of classes and instances were allowed
08:06:52 <byorgey> and since then no one has bothered to codify the various standard extensions like FlexibleContexts and FlexibleInstances and put them in the standard
08:07:22 <byorgey> s/standard extensions/common extensions/
08:14:55 <osfameron> hasn't the standard been updated?
08:16:12 <dottedmag> It has, but those extensions eluded standardization.
08:16:52 <osfameron> ah
08:16:59 <quchen> @quote elliott conservative
08:17:00 <lambdabot> elliott says: An interesting exercise is to try and imagine a language revision more conservative than H2010.
08:20:38 <exicer> If a library exports a sum type, data Test = Test1 | Test2, can I create my own sum type that looks like data MyTest = Test | MyTest1 ?
08:20:48 <tdammers> exicer: yes
08:20:51 <tdammers> exicer: no
08:20:55 <exicer> :s
08:21:01 <tdammers> exicer: you can get MyTest = Test Test | MyTest1
08:21:26 <tdammers> and technically, you can get MyTest = Test | MyTest1
08:21:27 <exicer> Why is Test Test necessary ?
08:21:32 <tdammers> but's not what you want
08:22:07 <osfameron> and next haskell report is presumably due out 2022?
08:22:09 <tdammers> let me rephrase that
08:22:14 <exicer> Also, what do you mean by technically I can get that ? Why is it not what I want ?
08:22:19 <exicer> Sorry for so many questions :p
08:22:27 <tdammers> because it doesn't do what you think it does
08:22:45 <tdammers> in the original type, `Test` is a type name
08:23:00 <tdammers> but in the second type (`MyTest`), `Test` is a constructor
08:23:14 <exicer> tdammers: Okay
08:23:16 <tdammers> iow, the first one is a type-level identifier, the second one is a value-level identifier
08:23:22 <tdammers> they are completely unrelated
08:23:55 <exicer> tdammers: Right. But Test Test specifies it ?
08:24:13 <tdammers> in `Test Test`, the first `Test` is a value-level identifier for the constructor
08:24:27 <tdammers> the second `Test` specifies that the constructor takes one argument of type `Test`
08:24:41 <exicer> tdammers: Ah, okay.
08:25:05 <tdammers> if we adopt the (non-idiomatic) convention to tag type names with T and constructors with C, we get `data MyTypeT = TestC TestT | MyTest1C`
08:25:38 <dottedmag> exicer: so you'll get the following available values of type MyTest: Test Test1, Test Test2, Mytest1
08:25:51 <exicer> tdammers: Huh. So if I just left it as data MyTest = Test, what would happen ?
08:26:28 <dottedmag> exicer: It will be completely unrelated to type Test.
08:26:29 <tdammers> then `Test` at the value level would be a constructor of MyTest, and `Test` at the type level would be a completely unrelated type
08:26:50 <tdammers> types and values live in completely separate namespaces
08:26:50 <exicer> Okay, cool.
08:27:04 <tdammers> it's customary to use the same identifier for a type and its only or primary constructor
08:27:08 <tdammers> but that's not required
08:27:10 <tdammers> e.g.
08:27:23 <tdammers> data Tree a = Branch [Tree] | Leaf a
08:27:31 <tdammers> the constructors are named Branch and Leaf
08:27:53 <exicer> Another question - say the library exports a function that is Either Test a. If I am using Either MyTest a, will these be compatible ?
08:28:10 <dottedmag> exicer: no
08:28:16 <exicer> tdammers: I should probably re-read something about this.
08:28:26 <bernalex> tdammers: customary /= recommended. worth mentioning. I think it's stupid.
08:28:31 <bernalex> I'm with SPJ and use the Mk-prefix.
08:28:50 <tdammers> bernalex: idk, depends on what you're using the type for, I think
08:29:03 <tdammers> bernalex: and if you never export constructors anyway, it doesn't really matter
08:29:09 <bernalex> tdammers: I've always landed on the side of using prefixes
08:29:22 <tdammers> OTOH, most of base doesn't use prefixes
08:29:23 <bernalex> tdammers: 90% of the time it is useful when reading old code. the other 10% it doesn't hurt me.
08:30:11 <bernalex> note: I'm not super mad™ about this. I just *prefer* it.
08:30:48 <tdammers> idk, I prefer data Foo = Foo { _fooSomething :: Bar } for some reason
08:30:55 <tdammers> at least for data-record-ish types
08:31:26 <bernalex> I always disliked that. then I saw SPJ using Mk-everywhere, and actually quite liked it. I found it awkward/weird at first, but now I really always do it.
08:31:47 <Maior> Mk? got a link to an example please?
08:32:16 <exicer> bernalex: So you would do data MkTest = Test  ?
08:32:28 <tdammers> no, the other way around
08:32:29 <alpounet> the converse
08:32:32 <tdammers> data Test = MkTest
08:32:40 <exicer> Right right
08:32:45 <tdammers> Test is the type, MkTest is the "function" that, well, makes a Test value
08:32:53 <exicer> Okay makes sense :p
08:32:54 <dottedmag> Are the constructors the only construct in Haskell which allow a function-ish value to start with capital letter?
08:33:02 <exicer> I think that would have actually made stuff much clearer for me
08:33:05 <dottedmag> On values, not on types.
08:33:34 <napping> pretty close, but view patterns will as well
08:34:18 <bernalex> exicer: I think for newbies it's a lot better
08:34:28 <bernalex> exicer: I was very confused when I started out, because most tutorials & books use the same name
08:35:12 <tdammers> otoh, optimizing for newbie-friendliness too much yields python
08:35:15 <dottedmag> bernalex: basically beginners have to have syntax highlighting enabled to not to be confused.
08:35:20 <napping> dottedmag: https://ghc.haskell.org/trac/ghc/wiki/ViewPatterns
08:35:21 <exicer> bernalex: Yeah. I seem to remember lyah talking about this, but yeah, it was not obvious because everything always uses the same name
08:35:21 <jhance> I find it difficult to mix up Test and MkTest even if they are called the same... one is a type and one is a constructor, and you always know what context you are in so theres no ambiguity
08:35:24 <tdammers> (and with that, I'm off
08:35:26 <dottedmag> napping: Thanks, reading it
08:35:43 <napping> dottedmag: but that's pretty much for allowing you to pattern match as if things are constructors
08:36:17 <napping> It's not something you need to know, just that if you see LANGUAGE ViewPatterns, these might be involved too
08:38:36 <exicer> Is it a bad idea to have a relativley large sum type to represent the various errors that could occur while e.g. web scraping, and then run everything in EitherT ?
08:39:09 <napping> I don't know, is it?
08:39:20 <exicer> ?
08:39:24 <exicer> It was a question
08:39:28 <napping> Well, how big is "relatively large"?
08:39:39 <bernalex> napping: clearly, that is relative.
08:39:41 <napping> and do any subsets of the errors make sense on their own?
08:39:59 <exicer> I'm not sure, but say 10 or so constructors
08:40:24 <exicer> napping: I would think they all make sense on their own ?
08:40:48 <napping> I mean do you ever have places that want to handle (or maybe throw) just a subset of the errors?
08:41:12 <exicer> Ah, then yes. At least there would be database errors, and scraping errors
08:42:17 <napping> Then you *might* want something based on the same extensible exceptions stuff as in Control.Exception, whether or not you keep managing them in a monad transformer
08:42:46 <napping> independently, throwing real exceptions may be easier to do from inside code, if you have trouble getting everything into EitherT
08:42:47 <dottedmag> jhance: Sure, after 1+ years of reading Haskell code it happens.
08:43:10 <dottedmag> jhance: Not helpful for the beginner though.
08:43:21 <exicer> napping: I don't know anything about extensible exceptions. I guess I was just thinking that at the highest level it would be nice to have a do block that dealt with each "bit" failing properly.
08:43:48 <exicer> napping: I don't think I will be throwing exceptions - I was told this was a bad idea ?
08:44:36 <napping> It's probably clearer to use a transformer if you can.
08:44:59 <napping> I was just thinking that if you use functions that take callbacks in IO, or work inside pipes or whatever, it might be hard to get your ErrorT in there
08:45:05 <exicer> napping: My (possibly stupid) plan was to catch exceptions and convert them to my error type
08:45:35 <napping> Ah, "exceptions" was the package I was thinking of
08:45:41 <Para_> ah
08:45:48 <Para_> I've been staring at this for half an hour
08:45:57 <napping> Control.Exceptions explains how their exceptions are put together
08:46:06 <Para_> I've fixed 3 problems already, but there's one I can't find!
08:46:11 <napping> how the extensible exceptions are put together, that is.
08:46:31 <Para_> http://lpaste.net/105668
08:46:33 <exicer> napping: Hm, okay.
08:46:36 <Para_> does anybody know what the problem is?
08:46:51 <Para_> I don't know what ~ means in the signature
08:47:06 <napping> exicer: That's if you want to use the Control.Exceptions kind of machinery for managing different error types, but still do everything purely as a monad transformer
08:47:46 <napping> also, I think retrofitting any of these changes shouldn't be too hard
08:47:51 <Para_> (brb don't answer yet)
08:48:01 <napping> Para_: that's an equality constraint
08:48:17 <exicer> napping: I don't suppose you could point me to an example that does this kind of thing?
08:48:18 <jhance> Para_: n ~ (a0 -> c0) means that n is equivalent to (a0 -> c0).
08:49:10 <napping> exicer: that does which? Probably the Control.Exception haddocs
08:49:28 <exicer> napping: The purely as a monad transformer approach
08:49:39 <napping> In particular, the Exception class documentation includes some examples of making your own exception
08:49:51 <napping> Uh, just keep using ErrorT
08:50:08 <exicer> napping: Hah, okay.
08:50:08 <napping> http://hackage.haskell.org/package/exceptions-0.6.1/docs/Control-Monad-Catch.html
08:50:47 <napping> it's a type class for letting you use Control.Exception-style throw/catch/handle/try in different monads, and it's got an instance for ErrorT if you want
08:51:16 <benzrf> hmm
08:51:34 <exicer> napping: I was actually using EitherT before - is ErrorT significantly different ?
08:51:58 <napping> pretty sure it's not
08:52:22 <napping> I guess it just drops the stupid Error constraint?
08:52:47 <napping> and exceptions doesn't have a default instance, I guess
08:53:23 <napping> oh, I guess it puts it in the base monad, not as nice as I'd hoped
08:53:37 <napping> it's just the Either SomeException instance that directly lets you throw extensible exceptions in pure code
08:53:40 <exicer> napping: I have to confess, you have lost me a little bit
08:53:54 <benzrf> f a b c = action >>= \v -> f' v a b c
08:54:00 <benzrf> ^ is there a better way to do this :L
08:54:09 <napping> the biggest suggestion is just to keep doing what you were planning on doing, and ask again if you run into problems
08:54:21 <exicer> napping: Hah, ok fair enough.
08:54:26 <osfameron> oooo!  There's finally a kindle edition of TaPL
08:54:52 <napping> whether or not I've explained the things I'm talking about, it at least seems not too hard to retrofit therm
08:55:42 <benzrf> :t (>=>)
08:55:43 <lambdabot> Monad m => (a -> m b) -> (b -> m c) -> a -> m c
08:55:53 <benzrf> eeh
08:56:40 <benzrf> :t const getLine >=> flip hPutStr
08:56:41 <lambdabot>     Not in scope: ‘hPutStr’
08:56:42 <lambdabot>     Perhaps you meant one of these:
08:56:42 <lambdabot>       ‘BSC.hPutStr’ (imported from Data.ByteString.Char8),
08:56:47 <benzrf> :t const getLine >=> flip BSC.hPutStr
08:56:48 <lambdabot>     Couldn't match type ‘IO c’
08:56:48 <lambdabot>                   with ‘GHC.IO.Handle.Types.Handle -> IO ()’
08:56:48 <lambdabot>     Expected type: String -> IO c
08:56:50 <benzrf> o wait
08:57:32 <benzrf> :t let put2 a b = putStrLn (a ++ b) in const getLine >=> put2
08:57:34 <lambdabot>     Couldn't match type ‘IO c’ with ‘[Char] -> IO ()’
08:57:34 <lambdabot>     Expected type: String -> IO c
08:57:34 <lambdabot>       Actual type: [Char] -> [Char] -> IO ()
08:57:36 <benzrf> wweh
08:57:39 <napping> exicer: you might have to change what function you use to throw exceptions, and some type signatures, if you don't abstract over the details
08:57:48 <augur> goooood morning!
08:58:23 <napping> but that should also be a straightforward follow-the-type-errors fix, if you don't mind
08:58:42 <benzrf> bbl eh
09:05:54 <miguelnegrao_> hi
09:21:02 <Feuerbach> wasn't there a package that simplified inclusion of the git revision info into a haskell executable?
09:21:14 <Feuerbach> I can't find anything
09:27:38 <augur> anyone:   how can i do pure reads but impure writes for an IORef-like thing?
09:28:10 <zwer> you can't
09:28:45 <augur> zwer: i figure there's no way to truly do this, but im sure someone has had to address this sort of problem before, so im curious what people's solutions have been
09:28:56 <zwer> well depending on how loose your "like" definition is, State may do
09:29:02 <exicer> Could someone explain the significance of moving s <- liftIO getLine outside of the eitherT monad here: https://docs.google.com/presentation/d/1suMuLRo1xS5NxWn-L9lGHtVNpOH48F9ZnDyv5PyxEpI/edit?pli=1#slide=id.g3861696e3_0198 ?
09:29:22 <augur> no, i mean genuinely pure reads
09:29:40 <rwbarton> sounds sort of like IVar
09:29:48 <augur> rwbarton: ivar?
09:29:49 <rwbarton> @hackage ivar-simple
09:29:49 <lambdabot> http://hackage.haskell.org/package/ivar-simple
09:30:00 <sgk284> Hey all, just wondering if there is a more idiomatic way (preferably point-free) to write: foo fn gn obj = (fn obj, gn obj)
09:30:01 <augur> Ivar the Simple
09:30:14 <augur> 13th Tsar of Russia
09:30:30 <Maior> @pl \a b c = (a c, b c)
09:30:30 <lambdabot> (line 1, column 8):
09:30:30 <lambdabot> unexpected "="
09:30:30 <lambdabot> expecting pattern or "->"
09:30:33 <EvanR_> i think its interesting, after reading lambda the ultimate flame on Swift documentation, that we can refer simultaneously to immutable data and immutable variables ;)
09:30:36 <Maior> @pl \a b c -> (a c, b c)
09:30:36 <lambdabot> liftM2 (,)
09:30:50 <Maior> oop
09:30:51 <Maior> s
09:30:56 <augur> rwbarton: hm. not quite what i need, but its a good lead
09:31:20 <EvanR_> is an IVar holding an IORef immutable? hehe
09:31:25 <EvanR_> const pointer
09:31:37 <EvanR_> er, not really
09:32:14 <sgk284> @Maior heh awesome, thanks!
09:32:14 <lambdabot> Unknown command, try @list
09:32:37 <serjeem> I'm still a relative newbie in Haskell--how can I convince the typechecker that this function typechecks? https://gist.github.com/06bb0dff3c747cf57b4c
09:32:38 <Kaidelong> IVar seem like they implement a kind of linear logic
09:32:50 <Kaidelong> albeit not the kind you can use for making IO RT
09:33:03 <augur> rwbarton: i think i shall have to use unsafePerformIO :(
09:33:08 <serjeem> I've tried everything and it's starting to get convoluted and I'd bet there's an easy way that I'm just not seeing >_<
09:33:32 <Kaidelong> oh well not linear
09:33:35 <Kaidelong> I mean substructural
09:33:36 <serjeem> [the function is to be used in a SYB-style walk of an AST]
09:34:30 <zwer> augur why?
09:35:19 <augur> zwer: well, ultimately, because the reads i need to be able to do have to be out of my hands, on the other side of an interface with a plugin
09:36:13 <augur> zwer: i could wrap the entire thing in some IO-like type, but that would make things unnecessarily complicated
09:37:31 <Javran> is there a pragma to turn off "defaulting the following constraints to type ..." warning?
09:38:09 <zwer> augur and what do you expect to happen when you mutate the ref? do you expect your pure function to return the new value?
09:38:28 <benzrf> h
09:38:45 <benzrf> i made a little module for interfacing pipes with 0mq
09:38:48 <benzrf> 1 sec
09:40:32 <Para_> wait an equality constraint?
09:40:39 <Para_> (Sorry I had to step out of the room for a while)
09:40:57 <Para_> ohh
09:40:58 <Para_> never mind
09:42:43 <Tjr> Is there some kind of compiler support to catch blatant violations of the functor laws?
09:43:29 <Feuerbach> no
09:43:37 <rwbarton> you can derive Functor
09:43:51 <rwbarton> for ordinary types anyways
09:44:59 <Tjr> how does that work internally?
09:45:05 <Para_> (Can someone see whats wrong with my code - I've already looked at it for an hour) http://lpaste.net/105668
09:45:06 <tgeeky> presumably you could do that in LiquidHaskell?
09:45:23 <Para_> I'm trying to read the error message
09:45:51 <rwbarton> max doesn't take a pair
09:46:10 <Para_> :t max
09:46:11 <lambdabot> Ord a => a -> a -> a
09:46:14 <jhance> Para_: a ~ b means that a and b are equivalent types
09:46:21 <k00mi> Tjr: no, but for Functor, given parametricity, the second law follows from the first
09:46:34 <jhance> Para_: So the error message means you are treating that value as a function somewhere
09:46:48 <rwbarton> in practice I read this error message as "something is wrong with the types on line 9"
09:46:52 <Tjr> k00mi: I saw that in some blog post, which linked to an academic paper, and the paper didn't do at all what the blog post claimed.
09:46:54 <Para_> rwbarton - doesn't its signature indicate that it takes a pair?
09:47:02 <rwbarton> no
09:47:08 <tgeeky> :t fst
09:47:09 <lambdabot> (a, b) -> a
09:47:13 <rwbarton> that would be max :: (a,a) -> a
09:47:18 <pjdelport> Tjr: http://www.haskell.org/pipermail/haskell-prime/2007-March/002137.html perhaps?
09:47:18 <rwbarton> (with an Ord constraint)
09:47:28 <k00mi> Tjr: "free theoremes" is the keyword
09:47:37 <Para_> oh okay jhance, thanks. I'll try to find where.
09:47:57 <jhance> Para_: (fromIntegral . first_factor) n startAt is _highly_ suspicious
09:48:08 <rwbarton> Para_: well it's right here, at max
09:48:17 <Para_> yeah
09:48:19 <Para_> I didn't notice the comma
09:48:21 <jhance> Para_: Try fromIntegral $ first_factor n startAt
09:48:30 <haasn> Not every possible Functor instance can be derived, though, as my anecdotal experiments just showed
09:48:32 <Para_> I'm used to separating arguments by the comma so...
09:48:36 <rwbarton> Para_: max needs two arguments but you gave it only one; and you said the return type is n
09:48:53 <rwbarton> Para_: that's why it thinks n should be equal to a function type a0 -> c0, for the remaining argument
09:48:55 <Para_> and alright jhance, I'll try both, thanks
09:49:06 <Para_> ohhhh
09:49:07 <Para_> ok
09:49:10 <pjdelport> Tjr: http://repetae.net/computer/haskell/DrIFT/ and http://community.haskell.org/~ndm/derive/ may also be interesting
09:49:11 <Para_> and rwbarton
09:49:12 <Tjr> pjdelport: that's an interesting read.
09:49:14 <haasn> eg. data Foo a = Foo (B a X) where B is some Bifunctor
09:49:15 <rwbarton> in practice it's usually easier to find what you did wrong and then figure out why the compiler generated that particular error afterwards (if you care)
09:49:16 <Para_> alright, the error message makes sense now
09:49:42 <tgeeky> > primes
09:49:43 <lambdabot>  [2,3,5,7,11,13,17,19,23,29,31,37,41,43,47,53,59,61,67,71,73,79,83,89,97,101,...
09:49:58 <tgeeky> > first_factor 100 0
09:50:00 <lambdabot>  2
09:51:15 <genericpersona> why is a compiled version of hello world in haskell so large?
09:51:20 <Para_> jhance - out of curiosity, whats wrong with (fromIntegral . first_factor) n startAt?
09:51:29 <benzrf> check it oot https://gist.github.com/423aa5d99a2b5657fa59
09:51:34 <genericpersona> i just compiled hello world and it's 1.1 M while the equivalent in C++ is 7.9kb
09:51:40 <jhance> Para_: Whats the type of fromIntegral . first_factor?
09:51:43 <tgeeky> @type (\n startAt -> (fromIntegral . first_factor) n startAt)
09:51:44 <lambdabot> (Num (t1 -> t), Integral (a -> a), Integral a) => a -> t1 -> t
09:51:49 <haasn> genericpersona: GHC pulls in its own RTS and statically linked versions of all dependencies
09:51:54 <genericpersona> ah
09:52:04 <genericpersona> no wonder
09:52:08 <rwbarton> genericpersona: try with ghc -dynamic
09:52:12 <genericpersona> okay, one sec
09:52:24 <Iceland_jack> @google ghc large binary
09:52:26 <lambdabot> http://stackoverflow.com/questions/699908/making-small-haskell-executables
09:52:26 <lambdabot> Title: linker - Making small haskell executables? - Stack Overflow
09:52:36 <genericpersona> ah, now it's 17K
09:52:38 <tgeeky> Para_: ^^
09:52:38 <genericpersona> excellent
09:52:46 <genericpersona> thanks :)
09:52:53 <Tjr> Is "DrIFT" or "Derive" better / more recommended?
09:52:53 <tgeeky> @type (\n startAt -> (fromIntegral . first_factor) n startAt)
09:52:54 <lambdabot> (Num (t1 -> t), Integral (a -> a), Integral a) => a -> t1 -> t
09:53:01 <jhance> Para_: I might be wrong but I did type fromIntegral . (+) which should have the same type as fromIntegral . first_factor
09:53:11 <Para_> jhance, shouldn't it be Integral n, Num b => n -> n -> b
09:53:15 <genericpersona> tgeeky: what's the type of startAt?
09:53:29 <tgeeky> genericpersona: i didn't define it
09:53:33 <tgeeky> I just passed it in
09:53:33 <Para_> oh
09:53:48 <Para_> wait how can you pass it in if its pasted?
09:53:49 <genericpersona> and what's the type of first_factor?
09:53:54 <tgeeky> @type first_factor
09:53:55 <lambdabot> Integral s => s -> s -> s
09:54:03 <tgeeky> Para_: I used @let in lambdabot
09:54:13 <genericpersona> you should do fromIntegral . first_factor $ n startAt
09:54:31 <tgeeky> @type (\n startAt -> (fromIntegral . first_factor $ n startAt)
09:54:32 <lambdabot>     parse error (possibly incorrect indentation or mismatched brackets)
09:54:33 <tgeeky> @type (\n startAt -> (fromIntegral . first_factor $ n startAt))
09:54:34 <lambdabot> (Num c, Integral (s -> s), Integral s) => (t -> s) -> t -> c
09:55:01 <genericpersona> @type (\n startAt -> (fromIntegral . first_factor) $ n startAt)
09:55:02 <lambdabot> (Num c, Integral (s -> s), Integral s) => (t -> s) -> t -> c
09:55:06 <Para_> oh okay
09:55:19 <genericpersona> 'nah mean?!
09:55:28 <Para_> wait so its trying to find a function
09:55:38 <jhance> genericpersona: That treats n as a function though
09:55:56 <Para_> @type (\n startAt -> (fromIntegral $ first_factor n startAt)
09:55:57 <lambdabot>     parse error (possibly incorrect indentation or mismatched brackets)
09:55:58 <rwbarton> genericpersona, regarding executable size, now your executable depends on a bunch of dynamic Haskell libraries
09:56:00 <Para_> @type (\n startAt -> (fromIntegral $ first_factor n startAt))
09:56:01 <lambdabot> (Num b, Integral s) => s -> s -> b
09:56:11 <genericpersona> that looks more like it
09:56:13 <Tjr> pjdelport: any opinions on "DrIFT" versus "Derive" ?
09:56:22 <rwbarton> genericpersona: just like the C hello world depended on a bunch of dynamic C libraries
09:56:22 <Para_> okay, that works. I still have to figure out why the other chaining doesn't though
09:56:35 <jhance> Basically, be careful when composing functions if its really a function to a function (two-args)
09:56:42 <jhance> @type (fromIntegral . (+))
09:56:43 <lambdabot> (Num a, Num c, Integral (a -> a)) => a -> c
09:56:44 <Para_> @type (fromIntegral . first_factor)
09:56:45 <genericpersona> let comp = fromIntegral . first_factor in (\n startAt -> comp n startAt)
09:56:45 <lambdabot> (Num c, Integral (a -> a), Integral a) => a -> c
09:57:04 <genericpersona> @type first_factor
09:57:05 <lambdabot> Integral s => s -> s -> s
09:57:18 <Para_> okay, that makes sense
09:58:12 <genericpersona> rwbarton: true true
09:59:03 <Para_> @type (fromIntegral . ceiling)
09:59:04 <lambdabot> (RealFrac a, Num c) => a -> c
09:59:20 <Para_> @type (3/4)
09:59:21 <lambdabot> Fractional a => a
09:59:53 <Para_> fromIntegral . ceiling 3/4
10:00:09 <Para_> @type (fromIntegral . ceiling 3/4)
10:00:10 <lambdabot> (Num c, Integral (a -> b), Integral b, Fractional (a -> c)) => a -> c
10:00:35 <genericpersona> fromIntegral . ceiling 3/4 looks weird
10:01:13 <Para_> @type ((fromIntegral . ceiling) 3/4)
10:01:14 <lambdabot> Fractional a => a
10:01:17 <genericpersona> when you're using the composition operator, i.e., ., you should not supply all the actual parameters
10:01:37 <Para_> okay
10:01:38 <Para_> so
10:01:49 <Para_> @type (fromIntegral (ceiling 3/4))
10:01:50 <lambdabot>     Could not deduce (Integral a0) arising from a use of ‘fromIntegral’
10:01:50 <lambdabot>     from the context (Num b)
10:01:50 <lambdabot>       bound by the inferred type of it :: Num b => b at Top level
10:01:56 <tgeeky> @type (\n -> (fromIntegral . ceiling (n/ff)))
10:01:57 <lambdabot> (RealFrac ((t -> s) -> t -> c1), Num c1, Num c, Integral (s -> s), Integral (a -> b), Integral s, Integral b) => ((t -> s) -> t -> c1) -> a -> c
10:02:00 <tgeeky> @type ff
10:02:00 <genericpersona> the way you just did it w/ parens is the way it goes
10:02:01 <lambdabot> (Num c, Integral (s -> s), Integral s) => (t -> s) -> t -> c
10:02:14 <Para_> that could be part of the problem too
10:02:16 <tam1138> good morning
10:02:18 <genericpersona> @type fromIntegral . ceiling
10:02:20 <lambdabot> (RealFrac a, Num c) => a -> c
10:02:22 <benzrf> good afternoon tam1138
10:02:24 <Para_> good morning
10:02:24 <genericpersona> @type fromIntegral . ceiling $ (3/4)
10:02:25 <lambdabot> Num c => c
10:03:19 <Para_> agh
10:03:23 <Para_> still giving me an error
10:03:41 <tgeeky> @type ff
10:03:42 <lambdabot> (Num c, Integral (s -> s), Integral s) => (t -> s) -> t -> c
10:03:57 <Para_> oh
10:03:59 <Para_> thats a problem
10:04:06 <Para_> wait no never mind, I changed ff's definition
10:04:12 <tgeeky> what is it now?
10:04:16 <Para_> let ff = fromIntegral $ first_factor n startAt
10:04:23 <Para_> @type ff
10:04:24 <lambdabot> (Num c, Integral (s -> s), Integral s) => (t -> s) -> t -> c
10:04:28 <Para_> wait
10:04:31 <Para_> maybe it didn't change it then
10:04:32 <Para_> hm
10:04:38 <Para_> @let ff = fromIntegral $ first_factor n startAt
10:04:39 <lambdabot>  .L.hs:146:21: Not in scope: ‘first_factor’
10:04:39 <lambdabot>  
10:04:39 <lambdabot>  .L.hs:146:36: Not in scope: ‘startAt’
10:04:45 <tam1138> i'm using a function with the signature "Integral a => a -> Foo" and ghc -Wall complains when i give it a literal as an argument.  what's the clean way to deal with this?  seems unwieldy to litter ":: Int" everywhere.
10:04:45 <Para_> oh hm
10:04:49 <Para_> I'm not sure how to change it
10:04:54 <tgeeky> Para_: I have to re-define the other functions first
10:05:08 <Para_> do you just type them into here or how do you re-define them?
10:05:17 <Para_> (for lambdabot)
10:05:30 <tgeeky> Para_: I have been typing, in private message to lambdabot: @let <paste the fuction definition here>
10:05:35 <tgeeky> so, @let primes = ...
10:05:53 <Para_> ohh, okay. I should probably use private message too then
10:05:55 <tgeeky> @let ff n startAt = fromIntegral $ first_factor n startAt
10:05:57 <lambdabot>  Defined.
10:05:59 <tgeeky> @type ff
10:06:00 <lambdabot> (Num b, Integral s) => s -> s -> b
10:06:05 <tgeeky> that looks better, maybe
10:06:18 <Para_> wait ff doens't have arguments though?
10:06:30 <genericpersona> @let ff = fromIntegral . first_factor
10:06:31 <lambdabot>  .L.hs:154:1:
10:06:31 <lambdabot>      Multiple declarations of ‘ff’
10:06:31 <lambdabot>      Declared at: .L.hs:150:1
10:06:31 <lambdabot>                   .L.hs:154:1
10:06:37 <genericpersona> @let ff' = fromIntegral . first_factor
10:06:38 <lambdabot>  Defined.
10:06:44 <Para_> ohh never mind, it does
10:07:05 <Para_> ff is supposed to be the value that you get when you apply fromIntegral and first_factor to n and startAt
10:07:12 <tgeeky> @type ff'
10:07:13 <lambdabot> (Num c, Integral (a -> a), Integral a) => a -> c
10:07:15 <pjdelport> Tjr: No, afraid not; I've just read about them.
10:07:17 <Para_> I think that may be where I'm doing something wrong?
10:07:28 <Tjr> pjdelport: thanks
10:08:11 <Tjr> I wish there were a way to get rid of all that "fromIntegral" boilerplate.
10:08:35 <Tjr> or the genericFoo boilerplate.
10:08:38 <genericpersona> you can create a higher order function that will apply it
10:08:57 <genericpersona> @let fi f = fromIntegral . f
10:08:59 <pjdelport> Isn't there a generic prelude somewhere?
10:08:59 <lambdabot>  Defined.
10:09:12 <genericpersona> @let ff'' = fi first_factor
10:09:13 <lambdabot>  Defined.
10:09:28 <Tjr> genericpersona: for a moment I thought the function would operate on the parse tree and would therefore only need to be called once per module.
10:09:49 <Tjr> pjdelport: that sounds like a better fix.
10:10:10 <Para_> @type ff''
10:10:11 <lambdabot> (Num c, Integral (a -> a), Integral a) => a -> c
10:10:23 <Para_> @type first_factor
10:10:23 <sgk284> @pl filter ((== x) . fn) ys
10:10:24 <lambdabot> Integral s => s -> s -> s
10:10:24 <lambdabot> filter ((x ==) . fn) ys
10:11:02 <sgk284> @pl \fn x xs -> filter ((== x) . fn) xs
10:11:02 <lambdabot> (filter .) . flip ((.) . (==))
10:14:14 <Tjr> Maybe these libraries can also derive the boilerplate needed for optional named argument?
10:14:25 <ReinH> sgk284: keep x and eta reduce xs
10:15:36 <ReinH> keep x and fn, that is
10:15:41 <benzrf> coad gaolf
10:15:43 <genericpersona> so \fn x = filter ((== x) . fn)
10:15:48 <sgk284> @pl \x xs -> filter ((== x) . fn) xs
10:15:48 <lambdabot> filter . (. fn) . (==)
10:15:49 <Tjr> DrIFT processes standard Haskell scripts (suffix ‘.hs’) and literate scripts (suffix ‘.lhs’).
10:15:54 <Tjr> What is literate haskell?
10:16:04 * Tjr wonders about Haskell for illiterates.
10:16:08 <genericpersona> lol
10:16:14 <ReinH> @google literate haskell
10:16:15 <lambdabot> http://www.haskell.org/haskellwiki/Literate_programming
10:16:15 <lambdabot> Title: Literate programming - HaskellWiki
10:16:33 <genericpersona> the lambdabot is so badass
10:18:21 <rwbarton> does anyone still use derive (or DrIFT)?
10:20:13 <tgeeky> @let gpf' n startAt = max (ff) (gpf (ceiling (n/ff)) ff) where ff = first_factor n startAt
10:20:14 <lambdabot>  Defined.
10:20:24 <sgk284> ReinH: what do you mean by "eta reduce"?
10:20:27 <tgeeky> i forget what to do about the error when you try to use it, though:
10:21:01 <zzrg> Is there a nice way of using Haskell with the Google maps api?
10:21:13 <sgk284> ReinH: ah, nevermind I see what genericpersona did
10:21:14 <sgk284> thanks!
10:21:22 <tgeeky> > gpf' 145926144000 0
10:21:24 <lambdabot>  No instance for (GHC.Show.Show a0)
10:21:25 <lambdabot>    arising from a use of ‘M135454542720493105131845.show_M1354545427204931051...
10:21:27 <lambdabot>  The type variable ‘a0’ is ambiguous
10:21:29 <lambdabot>  Note: there are several potential instances:
10:21:31 <lambdabot>    instance [safe] GHC.Show.Show
10:21:39 <ReinH> @google eta reduce haskell
10:21:40 <lambdabot> http://www.haskell.org/haskellwiki/Eta_conversion
10:21:40 <lambdabot> Title: Eta conversion - HaskellWiki
10:22:00 <tgeeky> oops, gpf' -> gpf
10:22:17 <ReinH> Today I am a needlessly complex "let me google that for you" bot :)
10:22:19 <sgk284> incredible... I need to learn more about lambdabot
10:22:26 <sgk284> hahaha thanks
10:22:33 <ReinH> np
10:32:54 <sellout> Silly question, but is there an “official” color scheme for the Haskell logo? The site uses greyscale, but the favicon is blue/purple, and the Mac app is purple/reddish.
10:35:31 <bergmark> sellout: http://www.haskell.org/haskellwiki/Haskell_logos
10:38:03 <sellout> bergmark: So, my best guess from http://www.haskell.org/haskellwiki/Thompson-Wheeler_logo is “no”.
10:38:11 <sgk284> quick question, I have two functions with signatures: fn :: b -> [a] -> [a] and gn :: [a] -> [(b, c)].  I'd expect gn . fn to give something like b -> [a] -> [(b, c)], but that is failing badly
10:38:15 <sgk284> anyone have any pointers?
10:39:26 <jfischoff> sgk284: (->) is right associative
10:39:51 <jfischoff> fn :: b -> ([a] -> [a])
10:39:58 <jfischoff> fn :: b -> c
10:40:06 <jfischoff> :t (.)
10:40:07 <lambdabot> (b -> c) -> (a -> b) -> a -> c
10:40:24 <jfischoff> err fn :: a -> b there
10:40:34 <benzrf> :t (Category.._
10:40:34 <sgk284> jfischoff: ah, thanks
10:40:35 <lambdabot>     parse error (possibly incorrect indentation or mismatched brackets)
10:40:35 <benzrf> :t (Category..)
10:40:36 <lambdabot> Not in scope: ‘Category..’
10:40:40 <benzrf> wweh
10:40:41 <benzrf> :t (Category...)
10:40:42 <lambdabot> Not in scope: ‘Category...’
10:40:44 <benzrf> :t (Category....)
10:40:45 <lambdabot> Not in scope: ‘Category....’
10:40:48 <benzrf> ok :(
10:42:00 <fread2282> :t (>><)
10:42:01 <lambdabot>     Not in scope: ‘>><’
10:42:01 <lambdabot>     Perhaps you meant one of these:
10:42:01 <lambdabot>       ‘>>’ (imported from Control.Monad.Writer),
10:42:03 <fread2282> :t (>>>)
10:42:04 <lambdabot> Category cat => cat a b -> cat b c -> cat a c
10:42:10 <fread2282> :t (<<<)
10:42:11 <lambdabot> Category cat => cat b c -> cat a b -> cat a c
10:42:33 <benzrf> :t (Arrow..)
10:42:35 <lambdabot> Not in scope: ‘Arrow..’
10:44:40 <fread2282> @src (<<<)
10:44:40 <lambdabot> f <<< g = g >>> f
10:44:50 <fread2282> @src (>>>)
10:44:50 <lambdabot> Source not found. I feel much better now.
10:44:56 <fread2282> :(
10:44:59 <Desheng> :P
10:45:33 <Desheng> :t (>=>)
10:45:34 <lambdabot> Monad m => (a -> m b) -> (b -> m c) -> a -> m c
10:47:05 <Desheng> I wonder what (>>>) is used for
10:47:59 <dwcook> Desheng: composition of morphisms.
10:48:18 <dwcook> In (->) it's just flip (.)
10:48:36 <dwcook> (+1) >>> (*2) $ 10
10:48:39 <dwcook> > (+1) >>> (*2) $ 10
10:48:40 <lambdabot>  22
10:49:09 <dwcook> flip (.) (+1) (*2) $ 10
10:49:16 <dwcook> > flip (.) (+1) (*2) $ 10
10:49:17 <lambdabot>  22
10:51:05 <Para_> shit, projectEuler was hacked
10:51:06 <Para_> uhoh
10:51:35 <kini> > ?src ($!)
10:51:36 <lambdabot>  mueval-core: internal error: PAP object entered!
10:51:36 <lambdabot>      (GHC version 7.8.2 for x86_64_unknown_linux)
10:51:37 <lambdabot>      Please report this as a GHC bug:  http://www.haskell.org/ghc/reportabug
10:51:44 <kini> wat
10:51:52 <hayashi> did anyone see that F# 'railway oriented programming' thing that was just reinventing monads?  =p
10:52:03 <hayashi> well, reinventing Either, but still
10:53:18 <hayashi> monads are railways!  beats burritos I guess
10:53:26 <sellout> hayashi: It wasn’t reinventing them – F# has had monads, it’s just a monad tutorial that intentionally doesn’t use the term.
10:55:49 <hayashi> maybe
10:56:43 <nadirs> I agree with what sellout said, it's clear that the author knew that was talking about monads
10:57:45 <sellout> hayashi: http://fsharpforfunandprofit.com/about/#banned
10:59:20 <pjdelport> hayashi: That's like Deferred. :)
10:59:54 <sellout> I find it odd that he doesn’t use the (admittedly awkward) F# name for monads either – “computation expressions”, if only because it makes it harder for people who are sold on the idea to dig in further.
11:02:14 <jhance> So he wants to talk about monads but bans the word, makes sense
11:02:27 <jhance> Calling something a railway doesn't magically make it easier to understand
11:02:54 <orzo> heh
11:03:10 <orzo> i like how haskell uses a lot of math lingo
11:03:48 <jhance> I do too, especially because it doesn't even get in the way if you don't understand category theory...
11:03:58 <joelteon> yeah, you know, computation expressions.
11:04:05 <joelteon> expressions that involve computation.
11:04:09 <bergmark> i like those
11:04:17 <jhance> as opposed to expressions that don't involve computation?
11:04:21 <joelteon> exactly
11:04:24 <bergmark> yeah those are not my favs
11:05:16 <orzo> i don't believe i understand category thoery anymore, it was a class i took in gradschool years ago, but i left math and got a job coding
11:06:16 <orzo> back then there was no haskell that i was aware of
11:06:36 <bergmark> we didn't have the option to take CT :-(
11:06:56 <orzo> well i was in a math phd program breifly
11:07:33 <orzo> they didnt have any graduate level ct?  maybe your schooling was longer ago? heh
11:08:17 <benzrf> yooooooooo does anybody here 0mq but also pipes because if so i have the THING FOR YOU
11:09:27 <l0cust> So, issue
11:09:45 <l0cust> Getting weird compile error I can't understand
11:10:16 <l0cust> http://ix.io/cZD
11:10:54 <l0cust> code is here - https://github.com/pharpend/podium
11:11:10 <bergmark> l0cust: you have a string literal where a unit is expected
11:11:16 <orzo> No instance for (Data.String.IsString ()) <-- used literal string in place where the infered type is ()
11:11:30 <bergmark> l0cust: and since you have OverloadedStrings it tries to see if it can use the IsString instance
11:11:39 <l0cust> okay
11:11:45 <l0cust> I sort of understand
11:12:05 <bergmark> replace the string with ("foo"::String) and you'll get a better error message
11:13:44 <l0cust> okay.
11:14:02 <l0cust> I think it's a problem with the way I'm embedding arguments in blaze
11:14:13 <l0cust> http://lpaste.net/105672
11:15:04 <orzo> l0cust: maybe instead of 'return' you want 'toHtml'
11:15:22 <piezoid> l0cust: the type of strings literals is polymorphic : "foo" :: IsString a => a
11:16:41 <benzrf> piezoid: only if u enable that extn
11:17:20 <phaazon> hm, I wonder how good is reactive-banana
11:18:01 <l0cust> orzo: thank you
11:18:16 <l0cust> orzo: that I think solved the problem
11:18:23 <orzo> woohoo
11:18:28 <l0cust> Which of course leads to another problem
11:18:28 <orzo> it was mostly a guess
11:18:30 <l0cust> http://ix.io/cZE
11:18:39 <orzo> i've no exerpience with that library
11:21:05 <orzo> i'm not sure, maybe those () should be "" at line 56
11:21:08 <piezoid> l0cust: for the first error you can't 'return ()', maybe there is a H.empty or mempty ?
11:22:13 <l0cust> There's H.toHtml ""
11:22:16 <l0cust> which seems to work
11:22:23 <phaazon> from the doc (reactive-banana): “Moreover, there is currently no garbage collection for events that are created dynamically with Reactive.Banana.Switch.”. Does it mean… memory leaks?!
11:22:50 <l0cust> I'm getting a bunch of errors regarding overlapping instances
11:23:07 <orzo> did you make instances?
11:23:23 <rwbarton> phaazon: there's a big HashMap that holds the states of all the events and behaviors in your program
11:23:28 <l0cust> http://lpaste.net/105674
11:24:05 <l0cust> And here is the code http://lpaste.net/105674
11:24:06 <rwbarton> phaazon: items never get removed from that hash map, so if you are creating events dynamically then it will grow
11:24:17 <orzo> dont use the "", its type is too ambiguous
11:24:22 <orzo> try piezoid's suggestions
11:24:39 <zq-_-_-_> :k Maybe Void
11:24:40 <lambdabot> Not in scope: type constructor or class ‘Void’
11:24:51 <zq-_-_-_> @let data Void
11:24:52 <lambdabot>  Defined.
11:24:56 <zq-_-_-_> :k Maybe Void
11:24:57 <lambdabot> *
11:27:29 <l0cust> orzo: working on it
11:27:46 <phaazon> rwbarton: …
11:27:47 <phaazon> I see
11:27:57 <phaazon> unusable then…
11:28:13 <piezoid> l0cust: things like 'H.span ! A.class_ "icon-bar" $ return ()' typecheck alone for me
11:28:19 <rwbarton> phaazon: no
11:28:41 <rwbarton> you can write lots of programs that don't need that module, and only manage a finite number of events/behaviors
11:28:58 <l0cust> piezoid: I see what you're talking about
11:29:12 <l0cust> piezoid: the issue is, I need another package to get at mempty in blaze
11:29:16 <l0cust> and that's taking a while
11:29:19 <piezoid> l0cust: but 'H.toHtml ()' is wrong
11:30:48 <piezoid> l0cust: return () :: MarkupM () ~ Markup ~ Html is fine as mempty
11:31:08 <l0cust> okay, down to one error message
11:31:42 <l0cust> http://lpaste.net/105676
11:32:30 <piezoid> l0cust: Html is a monoid, you simply need to import Data.Monoid
11:34:11 <piezoid> l0cust: name e type for the toplevel definitions, it's good practice anyway
11:34:40 <l0cust> Okay, one more error message
11:34:44 <l0cust> http://lpaste.net/105678
11:34:55 <l0cust> And here's the source
11:34:56 <l0cust> http://lpaste.net/105679
11:40:48 <Ch0c0late> Is this a correct approach of returning a new list containing the elements from odd indices? http://hastebin.com/afadugipec
11:41:08 <Ch0c0late> *right approach
11:41:57 <shachaf> It works for finite lists, but it's pretty inefficient among other things.
11:42:12 <shachaf> Try writing a function that works for infinite lists too.
11:42:36 <Ch0c0late> Thanks.
11:42:57 <piezoid> Ch0c0late: use pattern matching to decompose two elements at the head of the list
11:43:17 <Guest72128> Hello, I'm new to haskell and I'm trying to define a data type that would allow me to manipulate tree structures with different data types for leafs
11:43:23 <Ch0c0late> Good idea piezoid. Thanks.
11:43:52 <Guest72128> for example, something like : Add (Var 'x') 2
11:44:01 <shachaf> Another popular way is to zip with a list of numbers and then filter on that.
11:44:22 <coppro> Guest72128: Do you have a specific leaf structure in mind (e.g. every second leaf must be an Int)
11:44:23 <pjdelport> Guest72128: Haskell is pretty good for that.
11:44:41 <Guest72128> coppro, there's nothing like that which is required
11:45:03 <Guest72128> My goal is to develop a symbolic calculator
11:46:03 <pjdelport> Guest72128: Feel free to ask questions or paste code!
11:46:15 <coppro> Guest72128: Then you should probably define a sum datatype for your leaves
11:46:43 <Geraldus> Hey folks does anyone know is it hard to install GHC 7.8.2 on Gentoo?
11:46:45 <coppro> like data Value = Var Char | IVal Integer
11:47:05 <piezoid> Guest72128: your example will fit in data Exp = Add Exp Exp | Var String | Lit Int
11:47:15 <coppro> (or you could do this directly in your tree: data Expression = Var Char | IVal Integer | Add Expression Expression
11:47:26 <Guest72128> Ok, I'll try that, thanks
11:47:39 <Guest72128> I was trying to get it all at once, probably a bad idea indeed
11:48:50 <chrisdone> does anyone know if it's possible in a cabal file to combine dependency versions of two different packages? e.g. (ghc == 7.8.* && haddock == 2.14.*) || (ghc == 7.6.* && haddock == 2.13.*) etc?
11:49:04 <Guest72128> Ok, I dont' get it, once again, sorry
11:49:16 <Iceland_jack> Guest72128: Do you know how to define data types in Haskell?
11:49:18 <Guest72128> I have this : data Exp = Var Char | IVal Int | Add Exp Exp
11:49:32 <Guest72128> which does not work when I do Add 3 4, for example
11:49:41 <chrisdone> my package uses haddock, haddock's own dependencies aren't strict enough to ensure that the right haddock version is installed when you try to use my package on a given GHC
11:49:42 <Iceland_jack> Guest72128: You need to wrap 3 and 4 in IVal
11:49:47 <dottedmag> Ch0c0late: you might find it easier to define both "even" and "odd" functions together, using each other. But it will be completely different solution then.
11:49:49 <Iceland_jack>     Add (IVal 3) (IVal 4)
11:50:04 <Guest72128> Oh of course
11:50:08 <Guest72128> I'm dumb
11:50:15 <piezoid> chrisdone: the internal representation in Cabal seems to be compatible, but I never seen nor used it
11:50:20 <Ch0c0late> dottedmag: Yes. Thanks.
11:50:30 <Iceland_jack> Guest72128: It's quite possible to do away with that and have
11:50:30 <Iceland_jack>       3 + 4
11:50:30 <Iceland_jack>     ⇒ Add (IVal 3) (IVal 4)
11:50:46 <Iceland_jack> but for now you'll have to write it out explicitly
11:50:57 <jle`> or instance Num Exp where fromInteger i = IVal (fromInteger i); (+) = Add
11:51:07 <chrisdone> perhaps one can write specific "if"s that activate on given GHC versions in the dependencies list?
11:51:10 <Iceland_jack> Yes that was what I was talking about
11:51:19 <jle`> oh i didn't see that
11:51:24 <jle`> but yeah you probably shouldn't do that at this point
11:51:52 <luite> chrisdone: the impl flag
11:52:11 <chrisdone> luite: how does that look?
11:52:24 <luite> chrisdone: might be useful, if impl(ghc>=7.2) or something
11:52:30 <Guest72128> Yea, to get that I do infixl 6 Add ... ?
11:52:36 <chrisdone> luite: aha! that'll do the trick! thanks
11:52:38 * chrisdone tries it
11:52:43 <Iceland_jack> Guest72128: You'll have to use backticks
11:52:49 <Iceland_jack>     infixl 6 `Add`
11:52:56 <Guest72128> or a symbol
11:52:59 <chrisdone> i have a test script which builds across the past 4 ghc versions and the minimum haddock version for each (after painstakingly testing each), so i want to encode that in my dependencies list
11:53:02 <Iceland_jack> you can also do that
11:53:16 <Iceland_jack>     infixl 6 .+
11:53:16 <Iceland_jack>     (.+) = Add
11:54:27 <Iceland_jack> and then
11:54:27 <Iceland_jack>     infixl 7 .*
11:54:27 <Iceland_jack>     (.*) = Mul
11:54:53 <chrisdone> ghc==7.8.* -> haddock==2.14.*, ghc==7.6.* -> haddock==2.13.*, ghc==7.4.* -> haddock==2.11.*, ghc==7.2.* -> haddock==2.9.*
11:54:59 <chrisdone> are the constraints that work for me
11:55:05 <augur> pfffbt
11:55:09 <robbins> In pattern matching, I don't understand how _ represents a generic variable (eg: how does x:y:_ represent a list of two or more).
11:55:17 <augur> so are there no ref types that allow pure reads but impure writes?
11:55:26 <Guest72128> yes, but then, how do you put those IVal again ?
11:55:26 <Iceland_jack> robbins: then you need to fully grasp how lists work
11:55:35 <Iceland_jack>     x:y:_
11:55:35 <Iceland_jack> is the same as
11:55:35 <Iceland_jack>     x:(y:_)
11:55:46 <chrisdone> augur: with linear types?
11:55:57 <augur> chrisdone: in haskell :P
11:55:58 <monochrom> "pure reads" would mean the same answer everytime
11:56:11 <int-e> Iceland_jack: yes
11:56:12 <augur> monochrom: yes, at least in pure contexts
11:56:13 <Guest72128> I mean, IVal or Var..
11:56:16 <Iceland_jack>     x:y:_
11:56:16 <Iceland_jack> can match 1:2:[] (list of two elements)
11:56:24 <Iceland_jack> but it can also match 1:2:3:[] (list of three elements)
11:56:34 <robbins> Iceland_jack: OK, so _ essentially says, we don't care about this element, but we want to make sure we have a list of > 2
11:56:36 <Iceland_jack> because the wildcard pattern _ would just match 3:[]
11:56:41 <monochrom> newtype Pure_Read_Impure_Write a = P a
11:56:48 <monochrom> pure_read (P a) = a
11:56:50 <chrisdone> augur: should it be unwritable once it's been written to?
11:56:54 <pjdelport> robbins: "_" isn't really special in that context; it could be "xs" or "rest" or anything else too.
11:56:59 <hayashi> I guess as I get older I appreciate Haskell's use of mathematical terminology, because Haskell is high-level and full of elegant abstractions and mathematics is all about the elegant abstractions =p
11:57:01 <chrisdone> augur: and unreadable until it's been written to? =p
11:57:02 <augur> monochrom: i need something that has the following property: I can read a value from it purely, so i can case on the value etc. and in a specific monadic context, i can write to it as well
11:57:05 <Iceland_jack> robbins: If you _only_ want lists of 2 elements you can use either of
11:57:05 <Iceland_jack>     a:b:[]
11:57:05 <Iceland_jack>     [a,b]
11:57:11 <Iceland_jack> the former is sugar for the latter
11:57:15 <monochrom> impure_write a = writeFile "/dev/null" (show a)
11:57:35 <augur> chrisdone: mm.. sort of, yes.
11:57:36 <Iceland_jack> but like pjdelport said, there is nothing special about _ here
11:57:39 <augur> chrisdone: basically here's what im doing
11:57:54 <robbins> pjdelport: I see! Thanks, so _ is an idiom?
11:57:59 <Iceland_jack> robbins: If you write
11:57:59 <Iceland_jack>     x:y:ys
11:57:59 <Iceland_jack> then it also matches lists of length 2, 3, 4, ...
11:58:18 <augur> chrisdone: take a predicate calculus type checker with primitive predicates, eg. File(_), Folder(_), etc.
11:58:23 <robbins> Iceland_jack: Surely that would only match a list of 3?
11:58:38 <Iceland_jack> robbins: no, because ys can be empty ([])
11:58:42 <Iceland_jack> and then it's only a list of 2 things
11:58:48 <augur> chrisdone: in type checking mode, it needs to be able to ask if   File(x)   is true or not, and this is just a test to see if x points to a file or not
11:58:49 <Iceland_jack> ys can also be infinite
11:59:01 <Iceland_jack> > let x:y:ys = "hi" in (x, y, ys)
11:59:03 <lambdabot>  ('h','i',"")
11:59:18 <Iceland_jack> > let x:y:ys = [1..10] in (x, y, ys) -- robbins
11:59:20 <lambdabot>  (1,2,[3,4,5,6,7,8,9,10])
11:59:20 <pjdelport> robbins: Yeah, it's just a convention for "this is unused". It's a *little* bit special in that compilers will also not give warnings about unused variables starting with _.
11:59:36 <pjdelport> But that's just a convenience thing.
11:59:51 <augur> chrisdone: but there is a second mode, a forcing mode, where you can say things like   MakeTrue:File(x)   which doesnt *ask* if x is a file, but instead _makes_ x a file, whenever x doesnt point to anything yet
12:00:27 <augur> chrisdone: so in the type checking mode, we just need to know whats true at a given moment, so its pure, but in the make-true mode, its impure because the whole mode is about changing truths
12:00:48 <Iceland_jack> robbins: First you need to completely understand the two basic forms that lists can have:
12:00:48 <Iceland_jack>     empty     lists: []
12:00:48 <Iceland_jack>     non-empty lists: x:xs
12:00:48 <Iceland_jack> before attempting something more complicated, this is a common source of confusion
12:00:56 <pjdelport> @src []
12:00:56 <lambdabot> data [] a = [] | a : [a]
12:01:03 <robbins> pjdelport: I think I've got it now, thanks. I'm finding it hard to grasp concepts on first reading.
12:01:16 <robbins> *In LYAH
12:01:26 <chrisdone> augur: you want to be able to read from the ref without a monadic context of any kind
12:01:29 <chrisdone> ?
12:01:30 <robbins> I think it was the _ idiom that confuses me
12:01:35 <robbins> *confused
12:01:39 <benzrf> bye
12:01:40 <augur> chrisdone: ideally
12:01:45 <Iceland_jack> robbins: Does this definition make sense (it pattern matches on lists and uses a wildcard pattern)
12:01:45 <Iceland_jack>     len :: [a] -> Int
12:01:46 <Iceland_jack>     len []     = 0
12:01:46 <Iceland_jack>     len (_:xs) = 1 + len xs
12:02:05 <augur> chrisdone: otherwise i have to wrap the entire type checking thing in a monad just to lift this behavior, which is otherwise absent from the type checker
12:02:23 <pjdelport> robbins: It may be easier to understand the more verbose way of defining lists: data List a = Nil | Cons a (List a)
12:02:48 <chrisdone> augur: perhaps have a type variable to indicate the read/writability?
12:02:54 <Iceland_jack> robbins: what pjdelport said, then the pattern
12:02:54 <Iceland_jack>     x:y:_
12:02:54 <Iceland_jack> would be
12:02:54 <Iceland_jack>     Cons x (Cons y _)
12:02:55 <pjdelport> robbins: That's structurally the same as what @src [] gave, only using names instead of punctuation.
12:02:58 <augur> chrisdone: how would that work?
12:03:27 <chrisdone> data Ref p a = Ref a
12:03:28 <chrisdone> readRef :: Ref Readable a -> a
12:03:28 <chrisdone> writeRef :: Ref ReadWritable a -> m a
12:03:51 <robbins> pjdelport: I haven't reached defining data types, yet. It's first later on LYAH, I think.
12:03:52 <augur> chrisdone: i dont know how that would work
12:04:05 <augur> chrisdone: i mean, what existing types support this?
12:04:06 <Tjr> Is there something that absolutely cannot  be done with the Applicative class, but can be done with monads?
12:04:27 <Iceland_jack> robbins: Focus on simple cases of pattern matching on lists
12:04:27 <pjdelport> robbins: Oh, okay. Don't worry too much about all the above, then; it should get clearer once you get to data types.
12:04:30 <Iceland_jack> like 'map'
12:04:31 <augur> chrisdone: thats the question, right -- what types exist currently for doing this sort of thing (if any)
12:04:31 <chrisdone> oh, my bad, missed a bit:
12:04:33 <Iceland_jack> @src map
12:04:33 <lambdabot> map _ []     = []
12:04:33 <lambdabot> map f (x:xs) = f x : map f xs
12:04:45 * hackagebot haskell-docs 3.0.2 - A program to find and display the docs of a name from a  given module.  http://hackage.haskell.org/package/haskell-docs-3.0.2 (ChrisDone)
12:05:07 <Tjr> I'm aware that "applicative" products of probabilities are independent, whereas monads make it easy for the second random variable to depend on the first.
12:05:22 <Tjr> However, that's not a proof it cannot be done in applicative.
12:05:25 <robbins> Iceland_jack: About 90% of the len function makes sense, it only stops when xs is zero, and you cannot match list with zero elements - is that the gist of it?
12:05:30 <pjdelport> Tjr: join, basically
12:05:33 <chrisdone> data Ref (p :: * -> *) a = Ref (p a)
12:05:34 <chrisdone> data Readable a = Readable a; data ReadWritable a = ReadWritable (IORef a)
12:05:34 <chrisdone> readRef :: Ref Readable a -> a; writeRef :: Ref ReadWritable a -> m a
12:05:38 <chrisdone> perhaps something like that?
12:05:51 <Tjr> pjdelport: what do you mean by join?
12:05:56 <pjdelport> :t join
12:05:57 <lambdabot> Monad m => m (m a) -> m a
12:05:59 <Iceland_jack> robbins: so reason about it on cases, we have two cases: length of the empty list and length of the non-empty list
12:05:59 <chrisdone> oh, i don't know if there are any existing types that do the above
12:06:16 <Iceland_jack> the length of the empty list is always 0, no bs: so we write
12:06:16 <Iceland_jack>     len [] = 0
12:06:23 <pjdelport> Tjr: That's basically what separates Monad from Applicative; Applicative can't let you do that.
12:06:31 <augur> chrisdone: but i need a single type in both places, not TWO types
12:06:58 <chrisdone> augur: how can you type-safely determine what's readable and what's writable without a different type to indicate it?
12:06:58 <Iceland_jack> the length of a non-empty list, well we _ignore_ the first element of the list (that's the underscore) and add one to the length of the _rest_ of the list
12:06:58 <Iceland_jack>     len (_:xs) = 1 + len xs
12:07:07 <Tjr> pjdelport: if you had an applicative functor equipped with an additional join, could you implemend >>= and return with it?
12:07:49 <Iceland_jack> Tjr: return = pure
12:07:50 <Iceland_jack> and
12:07:50 <Iceland_jack> :t \a f -> join (fmap f a)
12:07:51 <lambdabot> (Functor m, Monad m) => m a1 -> (a1 -> m a) -> m a
12:08:04 <pjdelport> Tjr: Yes, >>= is just fmap followed by join. (And pure is already return, yeah.)
12:08:22 <chrisdone> augur: or do you want some dirty unsafePerformIO stuff? =p
12:08:49 <augur> chrisdone: im going to HAVE to use dirt unsafePerformIO stuff i think
12:08:53 <chrisdone> hmm, perhaps:
12:09:01 * Tjr feels stupid.
12:09:07 <chrisdone> data Ref a = Ref a (IORef (Maybe a))
12:09:11 <chrisdone> your pure code reads from the first 'a'
12:09:13 <Ch0c0late> piezoid: Is this http://hastebin.com/yomububute what you meant?
12:09:26 <chrisdone> your impure code reads from the first 'a', or if there's been an update by impure code, the latter 'a'
12:10:03 <pjdelport> Tjr: Intuitively, you can think of Applicative as allowing you to compose together arbitrarily tree-structure-like function applications in the domain of the applicative functor, but it doesn't let one part of the tree depend on the result of another part of it: all the leaves are independent, in a certain sense.
12:10:08 <chrisdone> depends on the semantics you want for the impure part, i guess
12:10:20 <robbins> Iceland_jack: Thanks for all your help, I think I need a few minutes tot think about to grasp the concept.
12:10:26 <chrisdone> but if it's "do a bunch of pure code, then do a bunch of updates", that's one way to do it
12:10:34 <robbins> *to think about it
12:10:41 <Iceland_jack> robbins: no problem, could you write a function that checks if a function is empty?
12:10:42 <pjdelport> Tjr: Whereas Monad *does* allow that.
12:10:47 <Iceland_jack>     isEmpty :: [a] -> Bool
12:10:54 <augur> chrisdone: if there's been an update -- how would you know?
12:10:54 <Iceland_jack> *íf a list is empty
12:11:12 <chrisdone> augur: because the IORef would contain Just instead of Nothing
12:11:14 <Tjr> pjdelport: your example is closely related to my example of independet product versus joinings of probability measures
12:11:20 <piezoid> Ch0c0late: yes, but there is a exceeding ':' in the begining of your pattern
12:11:29 <robbins> empty :: [a] -> String
12:11:37 <Ch0c0late> piezoid: Yes. Saw that.
12:11:39 <robbins> empty [] = "Empty list"
12:11:39 <augur> chrisdone: and how would you make sure the pure code can see updates? i guess that sort of breaks the purity, but its only breaking purity in already impure contexts
12:11:41 <chrisdone> writeRef (Ref _ r) x = writeIORef (Just x)
12:11:42 <Iceland_jack> robbins: (not -> String, but -> Bool)
12:11:55 <augur> chrisdone: namely, those contexts where we're reading, then writing, then reading again
12:11:59 <chrisdone> augur: oh, okay, i thought you wanted to retain purity. pure code seeing updates makes no sense
12:12:08 <pjdelport> Tjr: Perhaps, yeah
12:12:08 <augur> chrisdone: it IS pure
12:12:19 <robbins> Iceland_jack: I could use guards, instead
12:12:28 <chrisdone> augur: then perhaps:
12:12:31 <Iceland_jack> robbins: Why? You can do it with pattern matching
12:12:37 <piezoid> Ch0c0late: f (:x:y:xs) = y : f xs -- y is not a list
12:12:46 <augur> chrisdone: the function itself is pure. but when you run it in an impure context, it behaves differently. which is unsurprising, because the context is impure
12:12:48 <Iceland_jack> robbins: (remember, there are only *two* patterns for lists: empty [] and non-empty x:xs)
12:12:57 <chrisdone> writeRef :: Ref a -> a -> Ref a
12:12:58 <chrisdone> writeRef (Ref _ r) x = do writeIORef r (Just x); return (Ref x r)
12:13:12 <piezoid> Ch0c0late: sorry, f (x:y:xs) = y : f xs
12:13:16 <robbins> Iceland_jack: x:xs = False
12:13:21 <augur> chrisdone: ?
12:13:22 <chrisdone> do r' <- writeRef r "Hello!"
12:13:23 <chrisdone>    giveToPureCode r'
12:13:25 <Iceland_jack> robbins: right
12:13:26 <Geraldus> Hey guys I have something strange happened. In my current project `which cabal` shows me /usr/local/bin/cabal. However it was another version from user folder used previously. It’s iteresting that outside sandbox and inside another one `which cabal` shows me executable from user folder. How can I recover my sandbox?
12:13:43 <Ch0c0late> piezoid: Yes. Thanks.
12:13:48 <Iceland_jack> let me clean that up a bit
12:13:48 <Iceland_jack>     isEmpty :: [a] -> Bool
12:13:48 <Iceland_jack>     isEmpty []     = True
12:13:48 <Iceland_jack>     isEmpty (x:xs) = False
12:13:55 <Iceland_jack> Does that make sense robbins?
12:13:55 <chrisdone> augur: i hmm, maybe not. that's all the ideas i have without unsafePerformIO
12:13:55 <augur> chrisdone: except the value itself has to be a ref
12:14:15 <Iceland_jack> robbins: And do you also agree that we aren't 'using' the variables 'x' and 'xs'?
12:14:33 <robbins> Iceland_jack: Yes, it makes more sense to me when using [x] instead of x:xs, but I guess I need to learn the idiom.
12:14:48 <Iceland_jack> robbins: [x] is different from x:xs
12:14:50 <robbins> Iceland_jack: Yes, only for pattern matching
12:14:50 <monochrom> [x] means x:[]
12:15:05 <augur> chrisdone: the only solution i could thing of was to bypass using predicates to test for truths entirely, and just have those be imported as axioms at the outset that can just be looked up
12:15:07 <chrisdone> [x] means return x
12:15:10 <monochrom> x:[] does not match 1:(2:[]) for example
12:15:14 * chrisdone runs away before he gets stabbed
12:15:15 <rwbarton> Tjr: btw, have you seen fsil? https://github.com/kryft/fsil
12:15:16 <Iceland_jack> [x] only matches a singleton list (list with one element), and like monochrom said it's the same as x:[]
12:15:17 <robbins> Iceland_jack: so, its [x,xs]?
12:15:26 <augur> chrisdone: but that gets more complicated when there are lots of synthetic facts
12:15:30 <monochrom> [x,xs] means x:(xs:[])
12:15:41 <Iceland_jack> robbins: no, I said lists only have *two* patterns: you should ignore all others until you understand those
12:15:49 <Iceland_jack> otherwise it will confuse :)
12:16:27 <Iceland_jack>     isEmpty :: [a] -> Bool
12:16:28 <Iceland_jack>     isEmpty []    = True     -- pattern one: empty list
12:16:28 <Iceland_jack>     isEmpty (_:_) = False    -- pattern two: non-empty list
12:16:37 <Zekka> robbins: It's like [x] ++ xs
12:16:47 <Zekka> or more simply, like x:xs
12:16:50 <Tjr> rwbarton: oooh, that looks very useful for what I have in mind! Thanks a ton.
12:17:09 <monochrom> yes, it's better off considering "[1,2,3]" as syntax sugar for now
12:17:22 <monochrom> s/syntax sugar/illusion/
12:17:22 <augur> cooks, kitchens
12:17:25 <robbins> Iceland_jack: That version makes more sense
12:17:43 <monochrom> too few cooks, too many kitchens. what to do?
12:17:54 <Iceland_jack> robbins: note that the second clause (_:_) can match *any* non-empty lists
12:18:02 <Iceland_jack> [1], [1,2,3], [1,2,3,4,5,5,6,3,5,4,...]
12:18:22 <Iceland_jack> > let x:xs = [1,2,3,4,5] in (x, xs)
12:18:23 <lambdabot>  (1,[2,3,4,5])
12:18:40 <Iceland_jack> robbins: note how 'x = 1' and 'xs = [2,3,4,5]'
12:20:08 <robbins> Iceland_jack: I do see that, so x:xs is binding x to the head of the list, right?
12:20:13 <Iceland_jack> yes exactly
12:20:16 <robbins> then the rest to xs
12:20:21 <Iceland_jack> robbins: It's important to note that when you write
12:20:21 <Iceland_jack>     [1,2,3,4,5,6]
12:20:21 <Iceland_jack> it's exactly the same as
12:20:24 <Iceland_jack>     1:2:3:4:5:6:[]
12:20:32 <Iceland_jack> which is just sugar for
12:20:32 <Iceland_jack>     1:(2:(3:(4:(5:(6:[])))))
12:21:08 <robbins> Iceland_jack: I think it's clicked for me, thanks.
12:21:12 <Iceland_jack> good :)
12:21:21 <Iceland_jack> (exactly the same, barring rank-N)
12:21:50 <Iceland_jack> robbins: So the way you'd write a list of two elements is
12:21:50 <Iceland_jack>     [a, b]
12:22:03 <Iceland_jack> and that's sugar for
12:22:03 <Iceland_jack>       a:b:[]
12:22:04 <Iceland_jack>     = a:(b:[])
12:22:13 <robbins> Iceland_jack: right
12:22:20 <Iceland_jack> so if you *only* want to match lists of length 2, you can use [a, b] or (a:b:[])
12:22:36 <Iceland_jack> robbins: using that, can you define a function that returns 'True' when the list is of length 2?
12:22:50 <robbins> Iceland_jack: Sure
12:23:25 <Iceland_jack> an obvious definition would be
12:23:25 <Iceland_jack>     lengthTwo :: [a] -> Bool
12:23:25 <Iceland_jack>     lengthTwo xs = length xs == 2
12:23:25 <Iceland_jack> but try doing it with pattern matching
12:24:12 <Iceland_jack> (the definition with pattern matching would also work with infinite lists)
12:24:48 * hackagebot http-conduit-downloader 1.0.18 - HTTP downloader tailored for web-crawler needs.  http://hackage.haskell.org/package/http-conduit-downloader-1.0.18 (VladimirShabanov)
12:25:14 <Tjr> Is there a way to get rid of the second set of parentheses?
12:25:14 <Tjr> fmap (+)  (Just 3) <*> Just 5
12:25:27 <Iceland_jack> Tjr: (+) <$> Just 3 <*> Just 5
12:25:30 <napping> How does the haskell-mode repl decide what to have in scope?
12:25:34 <Iceland_jack> > (+) <$> Just 3 <*> Just 5
12:25:35 <lambdabot>  Just 8
12:25:53 <shachaf> (+) <$> Just 3 <*> Just 5
12:25:59 <napping> I'd like to have a directory of files that are not really part of the project, but still open them up with the project files and each other accessible
12:26:06 <Tjr> ok, if I want it to stay an fmap, can I get rid of the parentheses?
12:26:20 <Iceland_jack> @src (<$>)
12:26:20 <lambdabot> f <$> a = fmap f a
12:26:21 <Iceland_jack> ;)
12:26:32 <napping> oops, I was just misspelling it
12:26:35 <Tjr> fmap (+) $  Just 3 <*> Just 5  --doesn't work
12:26:43 <Iceland_jack> > (+) `fmap` Just 3 <*> Just 5
12:26:45 <lambdabot>  Just 8
12:26:46 <Iceland_jack> if you must Tjr
12:26:48 <shachaf> Yes, because $ is the least sticky operator.
12:26:51 <jhance> Tjr: <$> is fmap
12:26:56 <shachaf> > fmap fmap fmap (+) Just 3 <*> Just 5 -- don't do this
12:26:57 <lambdabot>  Just 8
12:27:00 <Iceland_jack> haha
12:27:09 <shachaf> Parentheses aren't evil.
12:27:10 <Iceland_jack> you should just use (<$>)
12:27:10 <Tjr> yeah, I know <$> is fmap, sorry for choosing a misleading example
12:27:13 <monochrom> please don't go out of your way to get rid of parentheses.
12:27:22 * Tjr hates parentheses.
12:27:36 <Iceland_jack> Tjr: don't?
12:27:41 * Tjr won't touch lisp purely because of parentheses.
12:27:45 <Iceland_jack> That's silly
12:27:51 <monochrom> I know how to get rid of most parentheses. do you want to know?
12:28:11 <Iceland_jack> (+) has parentheses.. :)
12:29:16 <genisage> I want to know how to get rid of most parentheses
12:29:18 * jhance isn't sure why you would want to avoid <$> if you are going to use <*>
12:29:25 <Tjr> So the answers seem to be ways to reformulate the code with different operators / infix / synonyms that don#t need parentheses
12:29:38 <Iceland_jack> exactly, (<$>) and (<*>) go hand-in-hand
12:29:50 <monochrom> good, I am guaranteed an audience now :)
12:29:53 <Tjr> Maybe a better example would be something like:
12:30:09 <monochrom> so let's say you hate the parentheses in a*(b+c*(d+e))
12:30:47 <robbins> Iceland_jack: is2 :: [a] -> Bool is2 x:y:[] = True
12:30:48 <jhance> a*b + a*c*d + a*c*e
12:30:58 <monochrom> define operators <+>, <<+>>, <<<+>>>. they are all the same as +, except different precedences. <+> highest, <<+>> medium, <<<+>>> lowest
12:31:01 <Tjr> foldr (\x y -> if x >0 then y^x else x+y) (calculate 5) [1,,10]
12:31:02 <rwbarton> we need a new @pl: parentheses-less
12:31:13 <Iceland_jack> robbins: almost, you need parentheses around the pattern
12:31:24 <Iceland_jack> and you need a second clause for lists that are not of length 2
12:31:27 <moghedrin> monochrom: Seems a bit masochistic.
12:31:36 <Tjr> In the foldr example, and other things of that ilk, the parentheses around "calculate" bug me
12:31:41 <monochrom> define operators <*>, <<*>>, <<<*>>>. they are all the same as *, except different precedences. <*> highest, <<*>> medium, <<<*>>> lowest.
12:31:41 <Iceland_jack> robbins: mind if I fix it up for you?
12:31:43 <Tjr> more or less because it's repetitive typing
12:31:50 <robbins> Iceland_jack: Go ahead
12:32:00 <Iceland_jack>     is2 :: [a] -> Bool
12:32:00 <Iceland_jack>     is2 (x:y:[]) = True
12:32:00 <Iceland_jack>     is2 _        = False
12:32:12 <Iceland_jack> robbins: of course, you can write [x, y] for (x:y:[]) right?
12:32:23 <Iceland_jack> and since we're not using either elements we can use _ wildcard patterns for them
12:32:33 <monochrom> a*(b+c*(d+e)) = a <<<*>>> b <<+>> c <<*>> d <+> e
12:32:41 <Iceland_jack> so it becomes
12:32:41 <Iceland_jack>     is2 :: [a] -> Bool
12:32:41 <Iceland_jack>     is2 [_, _] = True
12:32:41 <Iceland_jack>     is2 _      = False
12:32:53 <Iceland_jack> 3 wildcards!
12:33:02 <robbins> Iceland_jack: Why do you have is2 _ for the third pattern?
12:33:06 <monochrom> yes moghedrin, IMO getting rid of parentheses is masochistic. I don't understand why humans will it. but humans, meh.
12:33:21 <Iceland_jack> robbins: because if something doesn't match first first pattern, it moves onto the second pattern
12:33:27 <monochrom> I only know that if they will it, I have a solution to sell.
12:33:56 <Iceland_jack>     is2 [_, _] = True   -- Lists of length 2
12:33:56 <Iceland_jack>     is2 _      = False  -- Lists of length NOT 2
12:34:08 <moghedrin> monochrom: Dial to 11, eh? ;D
12:34:23 <robbins> Iceland_jack: So it falls through like a case statement in C, for example
12:34:27 <genisage> I was just curious, I love using parentheses.
12:34:36 <Iceland_jack> robbins: yes pretty much
12:34:37 <Guest72128> Say I have an expression (a tree) and a list of transformations, like this :
12:34:40 <Guest72128> (Add a b) = (Add b a)
12:34:40 <Guest72128> (Add (Add a b) c) = (Add a (Add b c))
12:34:51 <dwcook> robbins: note that there are only two patterns there, not three. The first line is a type annotation.
12:35:20 <robbins> dwcook: Yes, of course
12:35:43 <Guest72128> how can I get, from a given expression A, a list (or set) of expressions in the neighborhood of A ?
12:35:47 <monochrom> I also happen to know how to get rid of all parentheses ever, not just most parentheses. do you what to know?
12:35:52 <Tjr> So fiddling with operator precedence is another solution to annoying parentheses.
12:35:57 <robbins> Iceland_jack: Thanks for all your help! You've been extremely patient with me
12:36:10 <Iceland_jack> Tjr: accepting parentheses is another good solution :)
12:36:27 <Iceland_jack> robbins: You're very welcome, don't hesitate with further questions
12:36:28 <Tjr> monochrom: you'll probably tell us something funny?
12:36:31 <monochrom> I should charge people money for this
12:36:40 <genisage> you could switch to using stacks for everything.
12:36:55 <genisage> If you use forth for example, you'll never need another parenthesis.
12:36:59 <benzrf> yo bitemyapp
12:37:01 <monochrom> I don't know whether it's funny. I only know it's sarcasm. do you want to know?
12:37:03 <benzrf> sup
12:37:14 <Tjr> Iceland_jack: I don't mind 2 sets of parentheses around the same type of thing, but doing something thrice is a cry to automate it
12:37:16 <Zekka> Did anyone show Tjr pointfree notation yet?
12:37:24 <Tjr> yes, doesn't apply here
12:37:26 <benzrf> Zekka: it would be pointless :3
12:37:36 <genisage> I also want to know how to get rid of all parens ever.
12:37:52 <benzrf> genisage: use $
12:38:16 * Tjr loves those guys on academic conferences who present theorems that pointless topology can always be represented as topology over a point set, unless something really exotic happens.
12:38:36 <jhance> If you spend all your time trying to get rid of parens you will never get anything done
12:38:58 <Zekka> I'm sympathetic because I don't really like parens either, but that mostly just extends to using $ when it doesn't obfuscate my code
12:39:00 <monochrom> defeat the progress brought by fortran. regress back to pre-1960. a*(b+c*(d+e)) = let tmp1 = d+e; tmp2 = c*tmp1; tmp3 = b+tmp2 in a*tmp3
12:39:40 <dwcook> monochrom: What did languages do before the sort of recursive expressions we have today?
12:39:42 <Tjr> monochrom: now make that more succinct than the parentheses version, and you've got a buyer.
12:40:04 <dwcook> monochrom: I mean, what would the grammar have looked like?
12:40:08 <monochrom> Tjr, I understand. make a perpetual machine, and I've got a buyer, too.
12:40:17 <Zekka> Tjr: Do you like Forth?
12:40:23 <Tjr> what#s forth?
12:40:30 <genisage> I like forth.
12:40:32 <benzrf> Tjr: a language
12:40:37 <benzrf> stack base
12:40:45 <genisage> But I wouldn't use it for anything complex.
12:40:50 <Zekka> I'm trying to find a good forth example
12:41:14 <Zekka> http://c2.com/cgi/wiki?ExampleForthCode <- there's some example code here
12:41:19 <Zekka> lots of math, no parens
12:41:21 <Tjr> genisage: you sold me ;-|
12:41:22 <monochrom> it was all 3-address commands or worse, dwcook. "tmp1 = d + e" or "add tmp1, d, e" or "add d by e to tmp1" etc. see old cobol.
12:41:51 <dwcook> How quaint.
12:41:53 <benzrf> god dang
12:42:17 <Tjr> More seriously, certain patterns crop up in code over and over. Sometimes, that's parentheses.
12:42:37 <jhance> let y = Just 3 in fmap (+) y $ Just 5, no parens except for the (+)
12:42:46 <genisage> Tjr: I also recommend bancstar, no parens in that one either.
12:42:52 <jhance> but obviously thats not clearer than using parens or using <$>
12:43:06 <Iceland_jack> jhance:
12:43:06 <Iceland_jack>     let plus x y = x + y in ... fmap plus y
12:43:07 <Iceland_jack> :)
12:43:21 <monochrom> take a compiler course. about the 3rd thing it teaches: how to decode fortran expressions back to 3-address commands. (and then it's easy to translate to asm)
12:43:59 <benzrf> compilers comschpilers
12:44:05 <monochrom> people really do not appreciate the leap forward by fortran
12:44:06 <Tjr> too bad you can't create an operator with even higher "stickiness" than function application
12:44:11 <benzrf> interpreters are sooooo much easier
12:44:22 <benzrf> especially AST-based ones
12:44:27 <jhance> Why would you want to? That would totally obfuscate code
12:44:49 <Iceland_jack> benzrf: Building chairs is also easier than constructing buildings
12:44:50 <benzrf> jjjjj
12:44:58 <benzrf> Iceland_jack: yeah, i dont sit on buildings
12:45:02 <benzrf> :-)
12:45:09 <Tjr> func (calculate 4) 5 6   --  or rather:
12:45:09 <Zekka> Tjr: When would that be more readable instead of less?
12:45:09 <Tjr> func calculate % 4 5 6
12:45:16 <Iceland_jack> Yes, and I'm sure you put your chairs inside other chairs :)
12:45:16 <Zekka> Ew
12:45:21 <Tjr> where a%b is (a b )
12:45:56 <benzrf>      
12:46:03 <benzrf> Tjr: disgusting
12:46:04 <Tjr> Ok, I guess I'm not going to make a lot of friends with that.
12:46:04 <dwcook> Tjr: I think record syntax is the only thing that binds tighter than function application.
12:46:06 <benzrf> use parens
12:46:54 <Zekka> Tjr: Wouldn't you need to write func calculate % 4 % 5 % 6?
12:47:06 <Zekka> Otherwise what stops it from parsing as func (calculate 4) 5 6?
12:47:18 <benzrf> Zekka: thats the point
12:47:19 <Tjr> Zekka: that's the intended behavoir.
12:47:19 <Zekka> (assuming left-associative (%))
12:47:21 <benzrf> it's what he wanted
12:47:28 <Zekka> Oh, I'm sorry, you're right
12:47:30 <monochrom> forth and RPN etc can omit parentheses because operator arities are known up front. doesn't work as well in haskell because arities are fluid. id's arity varies with context.
12:47:39 <Zekka> I'm not being useful
12:47:46 <benzrf> Zekka: disgusting
12:47:46 <jhance> func calculate 4 % 5 % 6 would be a nightmare because precendence would matter
12:47:49 <Tjr> func $ calculate 3 4 5 -- would do the trick for zekka's variant
12:48:16 <Zekka> I'm operating on zero sleep, you'll probably want ot disregard a lot of what I say
12:50:03 <monochrom> then again I may be wrong. how do you write these in forth? 1. "map id xs"  2. "map (id xs)"  3. "map (map id) xs"
12:50:22 <Tjr> what's "map id"?
12:50:29 <Zekka> monochrom: I'm not a forth programmer, you'd have to ask one
12:50:33 <Iceland_jack> @ty map id
12:50:34 <lambdabot> [b] -> [b]
12:50:36 <Zekka> Tjr: It maps the identity function over a list
12:50:40 <Zekka> > map id [1, 2, 3]
12:50:40 <monochrom> "map id" is function "map" applied to argument "id"
12:50:41 <lambdabot>  [1,2,3]
12:50:43 <Iceland_jack> @ty id :: [a] -> [a]
12:50:44 <lambdabot> [a] -> [a]
12:55:28 <Mathnerd314> so does GeneralizedNewTypeDeriving work with newtype X a = X a ?
12:56:01 <monochrom> I hope so.
12:56:02 <Mathnerd314> because I'm getting " cannot eta-reduce the representation type enough"
12:56:31 <rwbarton> what class are you trying to derive
12:56:46 <Mathnerd314> Monad
12:57:29 <rwbarton> what type are you trying to derive it from?
12:57:35 <rwbarton> this doesn't make sense
12:57:38 <genisage> monochrom 1. noop 2. noop 3. noop
12:57:46 <Mathnerd314> hmm, maybe I can't derive instance Monad a => Monad (X a)
12:57:55 <napping> you really shouldn't be able to
12:57:57 <monochrom> that has wrong kinds
12:57:57 <rwbarton> a has the wrong kind for starters
12:58:01 <napping> you'd need a return :: b -> X a b
12:58:16 <Mathnerd314> alright, I'm convinced
12:58:51 <monochrom> newtype X a b = X (a b) may have more luck
12:59:06 <napping> you get instance Monad a => Monad (X a) just fine
12:59:20 <Mathnerd314> yeah, that was what I had before. Then I said "why do I need this extra parameter?" :p
12:59:51 <Zekka> Mathnerd314: If you had type-level dot perhaps you could write it as newtype X a = X . a
12:59:53 <monochrom> the right hand side "X (a b)" is why. "X (a b)" does not mean "(X a) b"
13:00:20 <Zekka> but what Monochrom said -- you can't quite etareduce here
13:00:37 <Zekka> (eta reduction \a x -> b x becomes \a -> b)
13:03:23 <Tjr> What's an example of a functor that cannot be made applicative in any way?
13:03:42 <Iceland_jack> Tjr: Have you tried searching online?
13:03:53 <Iceland_jack> @google functor that isn't applicative
13:03:54 <lambdabot> http://stackoverflow.com/questions/7220436/good-examples-of-not-a-functor-functor-applicative-monad
13:03:54 <lambdabot> Title: haskell - Good examples of Not a Functor/Functor/Applicative/Monad? - Stack O...
13:04:02 <ion> tjr: Try implementing pure :: a -> Map k a
13:04:05 <Mathnerd314>  napping: so, how do I get instance Foo (a b) => Foo (X a b)?
13:05:21 <rwbarton> deriving Foo -- if Foo takes an argument of kind *
13:05:25 <Tjr> ion: in case k is not invertible, is that really a functor?
13:06:50 <Mathnerd314> rwbarton: ...when Foo has an associated type Y :: * -> * and I want Y (X a b) = Y (a b)
13:07:53 <ion> tjr: fmap :: (a -> b) -> Map k a -> Map k b
13:08:41 <Zekka> Tjr: How about (a, )?
13:09:01 <rwbarton> Mathnerd314: I think you're out of luck then
13:09:21 <Zekka> That makes for pure :: b -> (a, b)
13:09:42 <rwbarton> not sure whether this restriction is necessary
13:10:55 <ion> > pure 42 :: (String, Integer)  -- The equivalent constraint would be less useful with Map
13:10:57 <lambdabot>  ("",42)
13:11:07 <Mathnerd314> deriving instance Foo (a b) => Foo (X a b) where { type Y (X a b) = Y (a b) } :p
13:11:56 <Tjr> ion: suppose "k :: Int -> Int ; k x = if x >1 then x -1 else 0". Then the obvious implementation of fmap is not well-defined for "fmap (+ 1) (Map k [0])"
13:12:38 <Zekka> > pure 42 :: (Void, Integer)
13:12:39 <lambdabot>  No instance for (Data.Monoid.Monoid L.Void)
13:12:39 <lambdabot>    arising from a use of ‘Control.Applicative.pure’
13:13:07 <Zekka> Yeah, looks like applicative's only defined for a is a monoid, which makes intuitive sense when you think about how <*> should work
13:13:12 <exicer> Has anyone used the syncIO function from Control.Error ? Could anyone show me some exapmle code ?
13:13:14 <ion> > fmap (+1) (Map.fromList [("foo", 10), ("bar", 11)])
13:13:15 <lambdabot>  Not in scope: ‘Map.fromList’
13:13:15 <lambdabot>  Perhaps you meant one of these:
13:13:16 <lambdabot>    ‘M.fromList’ (imported from Data.Map),
13:13:16 <lambdabot>    ‘IM.fromList’ (imported from Data.IntMap),
13:13:16 <lambdabot>    ‘S.fromList’ (imported from Data.Set)
13:13:24 <ion> > fmap (+1) (M.fromList [("foo", 10), ("bar", 11)])
13:13:26 <lambdabot>  fromList [("bar",12),("foo",11)]
13:13:49 <benzrf> > pure 23
13:13:50 <lambdabot>  No instance for (GHC.Show.Show (f0 a0))
13:13:50 <lambdabot>    arising from a use of ‘M42477946465013410422135.show_M42477946465013410422...
13:13:50 <lambdabot>  The type variables ‘f0’, ‘a0’ are ambiguous
13:13:51 <lambdabot>  Note: there are several potential instances:
13:13:51 <lambdabot>    instance [safe] GHC.Show.Show a =>
13:13:57 <benzrf> > pure 23 :: (a, Int)
13:13:58 <lambdabot>  No instance for (Data.Monoid.Monoid a1)
13:13:58 <lambdabot>    arising from a use of ‘Control.Applicative.pure’
13:13:58 <lambdabot>  Possible fix:
13:13:58 <lambdabot>    add (Data.Monoid.Monoid a1) to the context of
13:14:00 <lambdabot>      an expression type signature: (a1, GHC.Types.Int)
13:14:03 <benzrf> > pure 23 :: (a :: Monoid a => a, Int)
13:14:05 <lambdabot>  <hint>:1:27: parse error on input ‘=>’
13:14:06 <benzrf> o:
13:14:21 <benzrf> > pure 23 :: (Monoid a => a, Int)
13:14:22 <lambdabot>  Illegal polymorphic or qualified type: Data.Monoid.Monoid a => a
13:14:22 <lambdabot>  Perhaps you intended to use ImpredicativeTypes
13:14:25 <benzrf> aw.
13:14:28 <Tjr> Zekka:  I think (a,) is applicative.
13:14:32 <rwbarton> monochrom: http://www.complang.tuwien.ac.at/forth/gforth/Docs-html/Execution-Tokens-Tutorial.html is relevant
13:14:37 <Zekka> Tjr: When a is a monoid, yes.
13:14:38 <benzrf> > pure 23 :: (String, Int)
13:14:40 <lambdabot>  ("",23)
13:14:45 <benzrf> cool
13:14:45 <Zekka> Tjr: But try defining an applicative for (Void,)
13:14:58 <benzrf> how does haskell do different show instances for [a] and String
13:15:06 <ion> benzrf: With an evil kluge.
13:15:09 <benzrf> how does it distinguish at rune time
13:15:25 <ion> Look at the list of methods in the Show class.
13:15:30 <rwbarton> monochrom: something like (1) xs ' id map (2) xs id map (3) xs :noname ['] id map ; map
13:15:48 <Lutin`> benzrf: Remember String is [Char] not [a]
13:15:49 <Zekka> @src Show
13:15:49 <lambdabot> class  Show a  where
13:15:49 <lambdabot>     showsPrec :: Int -> a -> ShowS
13:15:49 <lambdabot>     show      :: a   -> String
13:15:49 <lambdabot>     showList  :: [a] -> ShowS
13:15:56 <Tjr> Zekka: isn't a simply a constant in your functor?
13:16:15 <benzrf> ew
13:16:17 <Zekka> Tjr: Try constructing a constant of type Void
13:16:20 <benzrf> @src [a] show
13:16:20 <lambdabot> Source not found. Abort, Retry, Panic?
13:16:31 <benzrf> @src [a] showsPrec
13:16:31 <lambdabot> Source not found. And you call yourself a Rocket Scientist!
13:16:35 <benzrf> huh
13:16:42 <benzrf> @src [a] showList
13:16:42 <lambdabot> Source not found. stty: unknown mode: doofus
13:16:44 <benzrf> :\
13:16:45 <Zekka> You can't define pure without undefined, error, or unbounded recursion
13:16:46 <Tjr> what's Void anyway?
13:16:51 <Zekka> The type with no members
13:16:54 <ion> tjr: data Void;
13:17:11 <Zekka> It's an error for any function a -> Void to return
13:17:27 <benzrf> i've seen
13:17:32 <benzrf> newtype Void = Void Void
13:17:40 <benzrf> @let newtype Void = Void Viod
13:17:42 <lambdabot>  .L.hs:155:1:
13:17:42 <lambdabot>      Multiple declarations of ‘Void’
13:17:42 <lambdabot>      Declared at: .L.hs:153:1
13:17:42 <lambdabot>                   .L.hs:155:1
13:17:42 <benzrf> oops
13:17:48 <benzrf> @undefine
13:17:48 <lambdabot> Undefined.
13:17:51 <benzrf> @let newtype Void = Void Void
13:17:52 <lambdabot>  Defined.
13:17:52 <Lutin`> benzrf: What's the issue with Show you're having?
13:17:55 <Tjr> Zekka: in that case, "(Void,)" has a type signature but it not a well-defined functor.
13:17:58 <benzrf> Lutin`: nothin in particular
13:18:02 <benzrf> was just wonderin
13:18:08 <ion> benzrf: That’s a workaround to avoid requiring EmptyDataDecls.
13:18:13 <Tjr> nor applicative.
13:18:16 <Zekka> Tjr: Why isn't it a functor?
13:18:22 <Zekka> Functors don't require you to be able to actually construct them
13:18:23 <Lutin`> benzrf: There isn't an instance for Show String, just Show Char
13:18:23 <benzrf> ion: ah
13:18:29 <benzrf> Lutin`: i know
13:18:31 <Lutin`> and it uses showList to show the string
13:18:38 <benzrf> o:
13:18:41 <benzrf> huh?
13:18:41 <Tjr> because a functor is a map in the first place. Namely in haskell, the type constructor.
13:18:48 <benzrf> whats up w/ showList
13:18:50 <ion> benzrf: Note that the data constructor is not exported.
13:18:57 <benzrf> ion: kk
13:19:02 <Lutin`> it's part of the Show instance
13:19:08 <benzrf> > undefined :: Void
13:19:09 <lambdabot>  No instance for (GHC.Show.Show L.Void)
13:19:09 <lambdabot>    arising from a use of ‘M43320465834919338012270.show_M43320465834919338012...
13:19:10 <benzrf> :t Void
13:19:12 <lambdabot> Void -> Void
13:19:19 <benzrf> :t fix Void
13:19:20 <lambdabot> Void
13:19:24 <benzrf> i got one!
13:19:39 <l0cust> Okay, getting this error, can't figure out how to write an instance for FilterMonad
13:19:42 <l0cust> http://lpaste.net/105689
13:19:46 <benzrf> ah, so show for [a] is showList?
13:19:52 <Zekka> benzrf: I can get one too
13:19:53 <ion> Yes, bottom is a member of every type, including Void.
13:19:56 <benzrf> then there's a default impl for most, overriden for char?
13:20:01 <benzrf> > fix Void
13:20:02 <lambdabot>  No instance for (GHC.Show.Show L.Void)
13:20:02 <lambdabot>    arising from a use of ‘M18182319714944799902292.show_M18182319714944799902...
13:20:11 <Lutin`> benzrf: Yes showList :: [a] -> ShowS
13:20:15 <benzrf> coo
13:20:17 <Zekka> > :t let x = x in x :: Void
13:20:18 <lambdabot>  <hint>:1:1: parse error on input ‘:’
13:20:19 <Zekka> er
13:20:21 <Zekka> t let x = x in x :: Void
13:20:22 <benzrf> > showList "foo"
13:20:23 <lambdabot>  <[Char] -> [Char]>
13:20:23 <Zekka> :t let x = x in x :: Void
13:20:24 <lambdabot> Void
13:20:55 <Lutin`> > showList [1,2,3]
13:20:57 <lambdabot>  <[Char] -> [Char]>
13:21:01 <dottedmag> > fix Void
13:21:02 <lambdabot>  No instance for (GHC.Show.Show L.Void)
13:21:02 <lambdabot>    arising from a use of ‘M21801619212832260952355.show_M21801619212832260952...
13:21:06 <Zekka> Tjr: Maybe I'm thick, but I don't follow your reasoning
13:21:13 <benzrf> > showList "foo" "bar"
13:21:15 <lambdabot>  "\"foo\"bar"
13:21:17 <benzrf> heuh?
13:21:23 <Zekka> Why shouldn't (Void, ) be a functor?
13:21:23 <benzrf> whats the second for eh
13:21:29 <benzrf> > showList "foo" ""
13:21:31 <lambdabot>  "\"foo\""
13:21:41 <benzrf> > showList [1, 2, 3] ""
13:21:42 <Zekka> None of the Functor methods require  you to actually be ableto construct a member of the type you're demonstrating is a functor
13:21:43 <lambdabot>  "[1,2,3]"
13:21:58 <Lutin`> benzrf: type ShowS = String -> String
13:22:04 <benzrf> @let instance Show Void where showList _ _ = "VoidList!"
13:22:05 <lambdabot>  .L.hs:149:10: Warning:
13:22:05 <lambdabot>      No explicit implementation for
13:22:05 <lambdabot>        either ‘showsPrec’ or ‘show’
13:22:05 <lambdabot>      In the instance declaration for ‘Show Void’
13:22:05 <lambdabot>  
13:22:08 <benzrf> wenk
13:22:14 <ion> benzrf: You can combine ShowS values with (.) and get a String out of one by applying it to an empty list.
13:22:22 <benzrf> > [fix Void, fix Void, fix Void]
13:22:24 <lambdabot>  No instance for (GHC.Show.Show L.Void)
13:22:24 <lambdabot>    arising from a use of ‘M55671644653029880682439.show_M55671644653029880682...
13:22:29 <benzrf> >.<
13:22:50 <benzrf> @let instance Show Void where show _ = "Void"; showList _ _ = "VoidList!"
13:22:51 <lambdabot>  Defined.
13:22:54 <benzrf> > [fix Void, fix Void, fix Void]
13:22:56 <lambdabot>  VoidList!
13:22:57 <benzrf> coo
13:23:01 <dottedmag> @let newtype Void = Void Void deriving Show
13:23:02 <lambdabot>  .L.hs:153:1:
13:23:02 <lambdabot>      Multiple declarations of ‘Void’
13:23:02 <lambdabot>      Declared at: .L.hs:147:1
13:23:02 <lambdabot>                   .L.hs:153:1
13:23:02 <lambdabot>  
13:23:10 <Tjr> Zekka: in maths, a functor is a map (up to set theoretic complications) that happens to preserve arrows. So the map has to exist and be well-define. I suspect (but am not sure about it) that haskell has this "needs a map" lurkign in the background, e.g. as the type constructor function.
13:23:20 <dottedmag> @undefine Void
13:23:20 <lambdabot> There's currently no way to undefine just one thing.  Say @undefine (with no extra words) to undefine everything.
13:23:20 <benzrf> @let lambdabot = "lambdabot"
13:23:22 <lambdabot>  Defined.
13:23:34 <Lutin`> Oh got
13:23:37 <benzrf> @let data Trick = Trick
13:23:38 <lambdabot>  Defined.
13:23:38 <Lutin`> god*
13:23:40 <benzrf> @let sup = const Trick
13:23:42 <lambdabot>  Defined.
13:23:44 <Zekka> Tjr: I think I understand
13:23:48 <Lutin`> That showList instance is dirty
13:23:59 <benzrf> @let instance Show Trick where show _ = "I wish you'd go away."
13:24:00 <ion> > (showString "Just " . showsPrec 11 (Right 42)) []
13:24:00 <lambdabot>  Defined.
13:24:02 <lambdabot>  "Just (Right 42)"
13:24:04 <benzrf> > sup lambdabot
13:24:05 <lambdabot>  I wish you'd go away.
13:24:18 <Zekka> So you'd argue that this type is also not a functor? newtype ReallyStupid a = ReallyStupid ()?
13:24:30 <benzrf> Zekka: thats a functor
13:24:33 <ion> ReallyStupid is actually really useful
13:24:37 <Zekka> Even though you can define operations satisfying the functor laws for it?
13:24:46 <ion> Oh, wait. I misread. Sorry.
13:24:47 <benzrf> Zekka: you dont need the () there
13:24:54 <Zekka> benzrf: Oh yeah, you're right
13:24:58 <Tjr> Zekka: "None of the Functor methods require  you to actually be ableto construct a member of the type you're demonstrating is a functor" >> If you're arguing that, then there is no way to produce counterexamples to the applicative laws. So "(Void,)" still doesn't provide an example for a non-applicative functor.
13:25:04 <benzrf> Zekka: wait, you do if its a newtype
13:25:21 <Zekka> benzrf: My thought process was basically "this is a fancy alias for unit"
13:25:24 <Zekka> but it really d oesn't have to be
13:25:32 <benzrf> this is useful:
13:25:34 <Zekka> the newtype should compile to roughly the same thing as the data declaration without a ()
13:25:43 <benzrf> newtype Const c a = Const c
13:25:47 <benzrf> @Let newtype Const c a = Const c
13:25:48 <lambdabot>  Defined.
13:25:54 <benzrf> o wait
13:25:55 <benzrf> @undefine
13:25:55 <lambdabot> Undefined.
13:26:02 <rwbarton> Tjr: the point is you can't write pure. it's not an issue with the laws, it's prior to that
13:26:04 <benzrf> @Let newtype Const c a = Const {getConst :: c} deriving (Show, Eq)
13:26:05 <Zekka> Oh, yeah, I see
13:26:06 <lambdabot>  Defined.
13:26:08 <benzrf> > Const 3
13:26:09 <lambdabot>  Ambiguous occurrence ‘Const’
13:26:09 <lambdabot>  It could refer to either ‘L.Const’, defined at L.hs:147:21
13:26:09 <lambdabot>                        or ‘Control.Applicative.Const’,
13:26:09 <lambdabot>                           imported from ‘Control.Lens’ at L.hs:41:1-43
13:26:09 <lambdabot>                           (and originally defined in ‘base:Control.Applicative’)
13:26:12 <benzrf> weh
13:26:12 <Zekka> that's the "carry a value around and go through the motions" functor
13:26:16 <benzrf> Zekka: yep
13:26:19 <benzrf> it's handy in lenses!
13:26:31 <benzrf> you can applicativeify it if c is a monoid
13:26:31 <Zekka> And you could probably define a common typeclass with another functor which does not carry a value around and go through the motions
13:26:41 <Zekka> and then suddenly lenses
13:26:50 <Zekka> Oh, hold up, I have to run off
13:26:51 <benzrf> Zekka: huh?
13:26:59 <benzrf> Zekka: are you familiar with von Laarhoven lenses
13:27:07 <Zekka> benzrf: Only to the extent that I've used the lens library
13:27:26 <Zekka> benzrf: I'll be back later -- sorry to run off on you like this
13:27:27 <benzrf> so you know what '(a -> f b) -> s -> f t' means, then
13:27:28 <benzrf> ok
13:27:33 <Tjr> benzrf:  so how does the associative law (i.e. the monoid property) affect the existence of "pure"?
13:27:35 <benzrf> *van not von
13:27:39 <benzrf> Tjr: huh?
13:28:15 <Tjr> [22:24] benzrf: you can applicativeify it if c is a monoid
13:29:22 <benzrf> @let instance Monoid c => Applicative c where pure = const (Const mempty); (Const x) <*> (Const y) = Const (x <> y)
13:29:23 <lambdabot>  .L.hs:151:23:
13:29:23 <lambdabot>      Ambiguous occurrence ‘Const’
13:29:23 <lambdabot>      It could refer to either ‘L.Const’, defined at .L.hs:147:21
13:29:23 <lambdabot>                            or ‘Control.Lens.Const’,
13:29:23 <lambdabot>                               imported from ‘Control.Lens’ at .L.hs:41:1-43
13:29:39 <benzrf> @let instance Functor (Const c) where fmap = const id
13:29:40 <lambdabot>  .L.hs:150:19:
13:29:41 <lambdabot>      Ambiguous occurrence ‘Const’
13:29:41 <lambdabot>      It could refer to either ‘L.Const’, defined at .L.hs:147:1
13:29:41 <lambdabot>                            or ‘Control.Lens.Const’,
13:29:41 <lambdabot>                               imported from ‘Control.Lens’ at .L.hs:41:1-43
13:29:45 <benzrf> @let instance Functor (L.Const c) where fmap = const id
13:29:46 <lambdabot>  .L.hs:151:22:
13:29:46 <lambdabot>      Couldn't match type ‘a’ with ‘b’
13:29:46 <lambdabot>        ‘a’ is a rigid type variable bound by
13:29:48 <lambdabot>            the type signature for
13:29:49 <benzrf> blah
13:29:50 <lambdabot>              fmap :: (a -> b) -> L.Const c a -> L.Const c b
13:30:00 <benzrf> @let instance Functor (Const c) where fmap _ v = v
13:30:01 <lambdabot>  .L.hs:150:19:
13:30:01 <lambdabot>      Ambiguous occurrence ‘Const’
13:30:01 <lambdabot>      It could refer to either ‘L.Const’, defined at .L.hs:147:1
13:30:01 <lambdabot>                            or ‘Control.Lens.Const’,
13:30:01 <lambdabot>                               imported from ‘Control.Lens’ at .L.hs:41:1-43
13:30:04 <benzrf> @let instance Functor (L.Const c) where fmap _ v = v
13:30:05 <lambdabot>  .L.hs:151:20:
13:30:05 <lambdabot>      Couldn't match type ‘a’ with ‘b’
13:30:07 <lambdabot>        ‘a’ is a rigid type variable bound by
13:30:09 <lambdabot>            the type signature for
13:30:10 <rwbarton> please stop
13:30:11 <lambdabot>              fmap :: (a -> b) -> L.Const c a -> L.Const c b
13:30:11 * benzrf flips lambdabot
13:30:18 <benzrf> rwbarton: yeah im stopping
13:31:05 <shachaf> You should /msg lambdabot until you've figured out what you want to say, and only then say it in here, if at all.
13:31:06 <rwbarton> Tjr: a monoid has an identity element, which you use to implement pure
13:31:15 <rwbarton> there. didn't need to generate 20 lines of lambdabot errors
13:32:00 <ion> FWIW, lambdabot might as well not paste the error message on separate lines.
13:32:03 <Tjr> rwbarton: so you're saying "(a,)" is applicable whenever "a" is a nonempty typeclass?
13:32:30 <ion> “a” is a type
13:32:31 <rwbarton> you also need some multiplicative structure to define <*>
13:32:36 <rwbarton> also, what ion said
13:32:37 <shachaf> (e,) is Pointed whenever e is a nonempty type.
13:32:37 <benzrf> shachaf: right right
13:33:17 <Tjr> s/nonempty/admits-values/
13:33:19 <dwcook> Tjr: The reason Monoid a => (a ,) can be Applicative is because the Monoid constraint provides you with an exemplar :: a. Any other class from which you have a means of obtaining one of its members would also do. For example, Bounded.
13:33:42 <shachaf> dwcook: Applicative needs more than that.
13:34:42 <dwcook> Yeah, I was confusing "implementing Applicative" with "implementing pure".
13:34:59 <Tjr>    (<*>) :: f (a -> b) -> f a -> f b
13:35:27 <Tjr> apply the innter "a->b" to the inner "a". No need for a multiplicative structure, unless I'm totally wrong
13:35:41 <benzrf> Tjr: 'the inner'
13:35:46 <benzrf> >so many implications here
13:35:55 <benzrf> Tjr: what about:
13:35:58 <benzrf> - Const functor
13:36:01 <benzrf> - Reader functor
13:36:05 <benzrf> - List functor
13:36:13 <rwbarton> lucky we aren't talking about any of those
13:36:18 <benzrf> ATuin: discworld
13:36:19 <benzrf> ?
13:36:56 <rwbarton> Tjr: you need to also produce an r, if your f is f x = (r,x)
13:38:16 <Tjr> - List functor >> should be fine. Anything of type [a->b] (except the empty list) will have functions of type a->b inside.
13:38:30 <dwcook> Tjr: []
13:38:44 <dwcook> You did qualify it but you can't say "forget []"
13:39:05 <Tjr> Indeed, [] is a monad, and therefore applicative.
13:39:12 <Tjr> No couterexample here.
13:39:28 <Tjr> As for the need to produce an "r": just use the same one once and for all.
13:39:57 <willem> i am using QuickCheck to test my code and want to randomly generate n elements in (Double, Double) which satisfy a certain criterion (eg, points within some radius r). is this possible?
13:40:34 <Iceland_jack> willem: sure
13:40:37 <rwbarton> Tjr, now you violate an Applicative law
13:40:44 <rwbarton> (with "just use the same one once and for all")
13:40:59 <rwbarton> pure f <*> x = f <$> x
13:41:21 <Tjr> why is that a problem?
13:41:24 <Iceland_jack> willem: You can go about it two ways, generating random numbers and checking that they're within that radius or generating them such that they're guaranteed to be withing that radius
13:41:33 <jhance> Because one should follow the laws or you get sent to jail
13:43:05 <tam1138> i'm using a function with the signature "Integral a => a -> Foo" and ghc -Wall complains when i give it a literal as an argument.  what's the clean way to deal with this?  seems unwieldy to litter ":: Int" everywhere.
13:43:18 <shachaf> Turn off that warning.
13:43:33 <tam1138> can i do it on a function-by-function basis?
13:43:45 <willem> Iceland_jack: i also thought of those methods, but i want the radius to be possibly randomly generated as well, and if i generate random numbers and check if they are within the range, it's very likely less than n random points will be generated (if the points outside of the range are thrown away)
13:43:46 <shachaf> I don't think so.
13:44:06 <Iceland_jack> willem: that's easy as well, you pass the radius as an argument to the function
13:44:24 <shachaf> You can turn it off on a per-file basis.
13:44:33 <Iceland_jack> so you have something like
13:44:33 <Iceland_jack>     genPoint :: Double -> Gen (Double, Double)
13:44:33 <Iceland_jack>     genPoint radius = ...
13:44:36 <shachaf> I'm not really sure whether that warning should exist.
13:45:00 <shachaf> I suspect the main effect of it is that people end up not usingg -Wall and therefore miss real problems.
13:45:12 <tam1138> seems not unlikely
13:45:14 <tam1138> thanks
13:45:20 <willem> Iceland_jack: thank you, i will try that
13:45:36 <shachaf> Perhaps there should be -Wall and also -Weverything with extra warnings, clang-style.
13:45:51 <shachaf> (clang does it for a different reason, of course.)
13:46:20 <Iceland_jack> willem: a dumb implementation would be something like
13:46:20 <Iceland_jack>     genPoint radius = (,) <$> choose (-half, half) <*> choose (-half, half)
13:46:20 <Iceland_jack>       half = abs (radius `div` 2)
13:46:26 <Tjr> let { constant :: a ; instance Functor (a,) where { pure ::  x -> (a,x) ; pure x = (constant, x) ; (a1, f) <*> (a2, point) = (a2, f point) ; fmap f (a1,x) = (a1, f x) }
13:46:26 <Iceland_jack> but it doesn't give you uniform distribution
13:46:39 <tam1138> i don't suppose it's possible to have, eg, ~/.ghcrc that lists default compiler flags?
13:46:56 <shachaf> You can put them in a file, with {-# OPTIONS_GHC ... #-}
13:47:01 <shachaf> Or in a .cabal file.
13:47:07 <shachaf> Or in ~/.ghci to configure ghci and runghc.
13:47:11 <willem> Iceland_jack: hmm, i have been looking for a function like that "choose", thank you!
13:47:14 <tam1138> thanks shachaf
13:47:22 <shachaf> Nothing for ghc in general.
13:47:40 <willem> Iceland_jack: i will try to fix it such that it does generate points in a uniform random way
13:47:41 <hexagoxel_> shouldn't it at least be called Wall and Wmost or something? Wall and Weverything is terrible imo
13:47:48 <Iceland_jack> willem: sounds good :)
13:47:51 <tam1138> Wall and Wuseful
13:48:05 <willem> Iceland_jack: where does the function "choose" come from? :p
13:48:17 <Iceland_jack> willem: Test.QuickCheck
13:48:19 <hexagoxel_> or Wcommon
13:48:19 <Iceland_jack> *.Gen
13:48:23 <tam1138> the manpage describes a -Whelpful-errors, but that doesn't seem what we want
13:48:34 <tam1138> er, no, it's -fhelpful-errors
13:48:35 <rwbarton> Tjr: now you broke the other pure/<*> law instead
13:48:46 <willem> Iceland_jack: thanks
13:49:26 <sgk284> @pl \ fn gn x -> fn . gn x
13:49:26 <lambdabot> (.) . (.)
13:49:30 <Iceland_jack> it gets imported by Test.QuickCheck though willem
13:49:38 <Iceland_jack> willem: http://stackoverflow.com/questions/5837572/generate-a-random-point-within-a-circle-uniformly this may be useful
13:50:13 <willem> Iceland_jack: thank you again
13:50:34 <Tjr> rwbarton: ok, I see it now. "u <*> pure y = pure ($ y) <*> u" isn't satisfied.
13:51:47 <sgk284> \ fn gn x -> fn . gn x
13:52:18 <Iceland_jack> willem: It's well worth it going through the QuickCheck documentation, it has a whole host of features: including generating/shrinking and showing random functions (so you can test higher-order functions easily), monadic QuickCheck where you can test IO actions and functions in the ST monad and many more cool stuff
13:53:26 <nomeata> @src curry
13:53:26 <lambdabot> curry f x y = f (x, y)
13:55:12 <willem> Iceland_jack: you're right, i will do that
13:55:56 <Iceland_jack> http://mathworld.wolfram.com/DiskPointPicking.html this shows why you can't just do 'r cos' ...
13:55:59 <Iceland_jack> you're welcome
13:58:59 <marchelzo_> say I have a data type, Planet, and it has three fields. I want to have a sort of "constructor" (think OOP), so that I can pass it two things, say the radius and the density, and have it fill in the mass field automatically. Should I just create a function that does this, or is there a cleaner way?
13:59:03 <ATuin> benzrf: :)
13:59:14 <Iceland_jack> marchelzo_: function is the way to go
13:59:56 <benzrf> who is the #1 haskell guy
13:59:59 <marchelzo_> Iceland_jack: So generally whenever you make a data type like that, you'd make an accompanying function, like 'createPlanet' in my case?
14:00:01 <benzrf> marchelzo_: function
14:00:03 <dottedmag> marchelzo_: also, you don't need to fill the mass at the beginnig
14:00:04 <benzrf> f-f-function
14:00:07 <cschneid> bootstrapping a bare system - is cabal-install 1.20.0 stable?
14:00:17 <cschneid> and usable with 7.8.2
14:00:20 <Iceland_jack> if you think of it maintaining the relationship between mass and radius/density it's a "smart constructor"
14:00:22 <pjdelport> marchelzo_: You can just give it two fields, and calculate the others on demand.
14:00:48 <Iceland_jack> marchelzo_: sure, it's also possible to do what pjdelport unless you want the third field for caching
14:01:07 <pjdelport> Laziness should already give you reasonable caching, though. :)
14:01:09 <Iceland_jack> but ideally you'd want to hide the actual constructor if you can construct 'invalid' data
14:01:14 <tulcod> marchelzo_: your data constructor should take exactly the right amount of information to completely define the object
14:03:04 <marchelzo_> In the case that I wanted the third field to be something that requires a more complex computation than simply the mass, then would I be justified in having the function to construct it? Or should I still just have it calculated whenever I need it?
14:03:18 <benzrf> marchelzo_: depends on the use case
14:03:37 <rrradical> is there a good way to stack an IO and State monad in one function, but then have it call another function that only uses the State monad? or once I combine them for convenience sake, there's no way to separate them to limit IO?
14:03:49 <dottedmag> marchelzo_: Haskell is lazy, so by default one can calculate it, and only if proven to be a bottleneck it might be cached
14:04:13 <benzrf> rrradical: there is probably a function that converts from StateT over Identity to StateT over whatever
14:04:26 <benzrf> marchelzo_: it seems to me that you should not be storing redundant data
14:04:36 <benzrf> in cases where it is not critical for perf
14:04:36 <dottedmag> marchelzo_: But if you don't expose this field and provide it over a functional interface (e.g. mass :: Planet -> Real), then changing from calculation to caching will be invisible to the callers.
14:04:42 <l0cust> Can someone help me with this error, please? http://lpaste.net/105691
14:05:05 <Iceland_jack> /query willem
14:05:05 <Iceland_jack>                                              
14:05:05 <Iceland_jack>       
14:05:10 <Iceland_jack> bah
14:05:34 <benzrf> Iceland_jack: :^D
14:05:40 <l0cust> here's the relevant code http://lpaste.net/105692
14:05:53 <benzrf> l0cust: i am e%amining the code
14:06:12 <benzrf> l0cust: that's not the relevant code
14:06:14 <benzrf> thats the error again
14:06:23 <l0cust> yeah, I screwed up my command line fu
14:06:40 <l0cust> http://lpaste.net/105693
14:06:43 <rrradical> benzrf: oh, I see. I can't find it, but I could probably make my own. thanks
14:07:03 <benzrf> rrradical: :-)
14:07:09 <marchelzo_> dottedmag: Ok, thanks. Also this is sort of unrelated, but I often find myself using random types for numerical data. I'll have Int and Integer and (Num) all over the code. How do you know when writing functions what their signature should be?
14:07:15 <benzrf> rrradical: actually
14:07:17 <benzrf> now that i think about it
14:07:40 <benzrf> rrradical: most of the statet functions are polymorphic iirc
14:07:58 <benzrf> rrradical: if you aren't manually typing out 'Identity', it should work as-is if you annotate it as being polymorphic
14:08:01 <benzrf> (y)
14:08:14 <dottedmag> marchelzo_: Default type inferred by the compiler is often ok. Overriding is usually needed only if you know something compiler doesn't.
14:08:25 <pjdelport> marchelzo_: You should only be using Int if you're sure you won't be overflowing it.
14:08:37 <pjdelport> And use Integer when in doubt.
14:09:35 <rrradical> benzrf: oh interesting. I'll try that
14:09:59 <benzrf> :t state
14:10:00 <lambdabot> MonadState s m => (s -> (a, s)) -> m a
14:10:06 <benzrf> rrradical: polymorphic!!
14:10:11 <benzrf> :t get
14:10:12 <lambdabot> MonadState s m => m s
14:10:14 <benzrf> :t put
14:10:15 <lambdabot> MonadState s m => s -> m ()
14:10:17 <benzrf> !!!
14:10:30 <marchelzo_> pjdelport: Alright. I was looking at benchmarks for Haskell for a certain calculation, and by using Int instead of Integer the code became significantly faster, so I want to make sure I'm not using unnecessary data types
14:11:25 <marchelzo_> Isn't it considered bad practice to omit signatures for your functions in the source, though?
14:11:29 <dottedmag> marchelzo_: Knut's maxima that premature optimization is the root of all evil applies to Haskell too.
14:11:52 <pjdelport> marchelzo_: Yeah, Int is faster, but it's only valid if your numbers are inside its bounds.
14:11:55 <dottedmag> marchelzo_: It is. It's no harm that compiler infers exactly the same types.
14:12:41 <pjdelport> If performance is of concern, and you can't statically guarantee the numbers are in range, you can always have a wrapper that switches between Int and Integer versions of a function depending on bounds.
14:12:54 <l0cust> benzrf: any thoughts
14:13:04 <benzrf> l0cust: did u link the code
14:13:06 <benzrf> i didnt see
14:13:10 <pjdelport> That's actually something I've been wondering about: isn't there a better way for Haskell to do that kind of thing automatically?
14:13:20 <l0cust> benzrf: http://lpaste.net/105693
14:13:28 <dottedmag> pjdelport: Probably can be addressed by compiler somehow.
14:14:02 <dottedmag> Not sure about the speed of that stuff though -- Int is so much closer to the hardware.
14:15:09 <tam1138> i have a question about order of arguments in some Vty functions; since it's code-heavy, i posted it here: http://lpaste.net/105695, would appreciate any input
14:15:47 <tam1138> er, imagine apostrophes in the appropriate places on line 17
14:16:01 <benzrf> l0cust: Errorific
14:16:02 <benzrf> *er
14:16:08 <benzrf> you're passing a Sitemap to it
14:16:47 <l0cust> I should have mentioned that I'm sort of winging it based on http://www.happstack.com/docs/crashcourse/index.html#web-routes
14:17:01 <shachaf> tam1138: Sounds reasonable.
14:17:12 <tam1138> thanks
14:17:17 <shachaf> tam1138: Maybe it's meant to be used infix.
14:17:24 <shachaf> a `withForeColor` green
14:17:26 <tam1138> ah
14:17:33 <tam1138> that would make sense
14:17:35 <marchelzo_> so for the Planet, the radius will always be an integer. But if I try pi * radius, it results in a type error. I have to to fromIntegral radius. Would I be better off just storing radius as a Double?
14:17:35 <shachaf> a `withForeColor` green `withBackColor` blue -- if the fixity works out?
14:17:36 <tam1138> thank you!
14:17:37 <l0cust> benzrf: It's complaining that Sitemap isn't an instance of PathInfo
14:17:43 <l0cust> benzrf: but it is
14:17:47 <shachaf> Or (`withBackColor` blue) . (`withForeColor` green)
14:17:48 <l0cust> benzrf: which is confusing me
14:17:54 <benzrf> it says it wants a URL
14:17:56 <benzrf> not a sitemap
14:17:59 <benzrf> =.=
14:18:33 <tam1138> shachaf: yep, it does, thanks!
14:18:58 <l0cust> the $(derivePathInfo ...) stuff makes it a URL
14:18:58 <l0cust> or rather
14:19:13 <l0cust> one minute
14:19:14 <shachaf> tam1138: Of course, what it should really be is a lens. :-)
14:19:48 <shachaf> Hm, maybe that doesn't really work with vty's types.
14:20:05 <bitemyapp> johnw: solid comment. Totally agreed.
14:20:26 <bitemyapp> johnw: I also agree with 5outh about needing a spine/execution-graph visualization tool. It would help with my teaching a lot.
14:20:53 <johnw> bitemyapp: thanks!
14:21:04 <tam1138> shachaf: vty requires lens, so it might
14:21:22 <silasm> bitemyapp: like that animation project that showed evaluation of haskell-like functions? I forget the name of that.
14:21:29 <benzrf> hows it goin bitemyapp
14:22:12 <bitemyapp> silasm: if you find something, PLEASE ping the hell out of me with it.
14:22:42 <bitemyapp> silasm: right now I have to use silly ghci example and teach people how to infer strictness/laziness from implementation manually, then applying that to how the spine should look. Obnoxious.
14:22:59 <bitemyapp> > take 1 $ foldr (:) [] [1, 2, error "blah"]
14:23:01 <lambdabot>  [1]
14:23:02 <bitemyapp> ^^ stuff like that.
14:23:23 <bitemyapp> then showing what happens with the foldl version - drawing out the thunks and spines for each.
14:23:33 <bitemyapp> I don't like doing this manually, it's error prone.
14:24:04 <silasm> bitemyapp: iirc it was just the beginnings of a project and it was dead :/, but a quick search showed this: http://felsin9.de/nnis/ghc-vis/thesis/
14:24:16 <silasm> I don't remember if ghc-vis was what I was thinking of though
14:24:18 <bitemyapp> silasm: yeah I think I'd run into this before.
14:24:56 <bitemyapp> silasm: I'll try compiling it, see what happens.
14:25:03 <bitemyapp> silasm: I really wish ghci had something.
14:25:18 <silasm> bitemyapp: yeah, that'd definitely be neat.
14:25:37 <bitemyapp> silasm: there's https://hackage.haskell.org/package/vacuum too, but the Cairo dependency is fucking impossible to build.
14:25:42 <benzrf> bitemyapp: ghc-vis does work
14:25:46 <benzrf> but it bloooooows
14:25:51 <bitemyapp> benzrf: oh. sad-face.
14:25:55 <benzrf> i tried it and found it impossible to understand
14:26:05 <bitemyapp> benzrf: do you think it could be fixed up?
14:26:08 <benzrf> well
14:26:10 <bitemyapp> it at least works, that's pretty huge.
14:26:23 <benzrf> to be precise, there were like 3 types of nodes that didnt greatly differ, visually
14:26:26 <benzrf> iirc
14:26:34 <benzrf> and i saw no values listed
14:26:37 <wlhlm> benzrf: last time I tried to compile it, it didn't work (currently is only compatible with ghc-7.6)
14:26:47 <benzrf> 1 sec
14:27:14 <benzrf> uggggggh
14:27:19 <silasm> bitemyapp: idk, I remember seeing something that generated .gifs or something, but as I said it sadly seemed like vaporware and I can never remember the name.
14:27:26 <benzrf> i deleted all my packages since my last install of ghc-vis
14:27:31 <benzrf> i seem to be doing that periodically x.x
14:28:24 <wlhlm> benzrf: actually, ghc-vis itself might work, but it depends on ghc-heap-view, which is not compatible with ghc-7.8
14:29:10 <benzrf> :[
14:30:04 <bitemyapp> wlhlm: yep.
14:31:47 <exicer> What is the class for a monad that is in IO?
14:31:49 <wlhlm> bitemyapp: sadly...
14:32:51 <dbushenko> is it possible to use 'do' only for IO?
14:33:37 <benzrf> exicer: MonadIO
14:33:52 <benzrf> dbushenko: depending on what you mean: probably
14:34:25 <benzrf> bitemyapp: do u 0mq
14:34:59 <uniquenick> has anyone here used the windows API from haskell much?  I can't seem to list processes:  http://lpaste.net/105697
14:35:18 <bitemyapp> benzrf: Haven't had a reason to use it yet. Most socket work I've done has been protobufs or text.
14:35:24 <benzrf> o:
14:35:29 <benzrf> bitemyapp: lame!
14:35:30 <dbushenko> benzrf, thanks!
14:35:37 <bitemyapp> benzrf: o_O
14:35:55 <benzrf> bitemyapp: go learn 0mq so that i can show u this module i made
14:36:05 <benzrf> nobody else has expressed interest and i crave validation
14:36:06 <benzrf> ;-;
14:36:39 <bitemyapp> benzrf: show it to me anyway.
14:36:56 <benzrf> 0mq connected to pipes
14:36:58 <bitemyapp> benzrf: people didn't know Elasticsearch humored me and looked at Bloodhound anyway.
14:36:59 <benzrf> https://gist.github.com/benzrf/5e8badd35de28957401d
14:37:14 <benzrf> ^demo xample
14:37:42 <bitemyapp> benzrf: looks really cool. Can you process messages concurrently?
14:37:46 <bitemyapp> benzrf: what's X and Proxy?
14:37:46 <benzrf> hmm?
14:37:47 <Guest72128> Any idea about this ? https://stackoverflow.com/questions/24252596/neighborhood-of-a-mathematical-expression-using-haskell
14:37:51 <benzrf> bitemyapp: Pipes stuff
14:37:59 <bitemyapp> okay.
14:38:13 <benzrf> you get a few slightly-lower-level functions for making Proxies attached to 0mq sockets and a higher-level one that uses a typeclass to find the correct socket type to attach based on your pipe type
14:38:18 <benzrf> i used the latter there
14:38:38 <bitemyapp> benzrf: what I'm asking for is whether a mesg recv can be passed to a multi-threaded worker pool or not.
14:38:42 <benzrf> im thinking of making some kind of TH thing where you feed it a list of pipes and it generates a main that allows you to launch various different pipes from the cmdline
14:38:46 <benzrf> bitemyapp: oh
14:38:54 <benzrf> bitemyapp: 0mq allows that by default with push/pull
14:38:56 <bitemyapp> benzrf: as far as I knew pipes isn't concurrent by default, that's a separate library.
14:39:07 <bitemyapp> benzrf: errrr where's the thread pool? who's responsible for it?
14:39:12 <benzrf> you, i suppose
14:39:13 <bitemyapp> I'm oft wary of letting libraries control my threading.
14:39:16 <benzrf> well
14:39:16 <bitemyapp> where?
14:39:17 <benzrf> to be precise
14:39:20 <bitemyapp> How do I make it work with Pipes?
14:39:37 <benzrf> it's a fairly thin wrapper
14:39:44 <bitemyapp> benzrf: for future reference, asking me to look at your library is like going to a proctologist for a bandaid.
14:39:55 <benzrf> if you grab a pull Producer
14:40:08 <benzrf> running it several times on several threads will work, because it closes over the same socket
14:40:14 <benzrf> seriously, look into 0mq
14:40:26 <bitemyapp> benzrf: I know of 0mq and what it's for
14:40:28 <benzrf> kk
14:40:39 <benzrf> bitemyapp: mom's picking me up bbiab
14:42:40 <Tjr> :t  fmap (\a b -> (a,b) )  (+3) <*> (*100)
14:42:40 <Tjr> :t    (+3) <*> (*100)
14:42:41 <lambdabot> Num t => t -> (t, t)
14:42:41 <lambdabot>     Occurs check: cannot construct the infinite type: a ~ a -> b
14:42:42 <lambdabot>     Expected type: (a -> b) -> a
14:42:42 <lambdabot>       Actual type: (a -> b) -> a -> b
14:43:31 <Tjr> Why can haskell construct unconstructable types if they're given in context?
14:44:19 <Tjr> Better yet, what's my error of thought?
14:45:27 <bitemyapp> Tjr: the order of application is not what you think it is.
14:45:43 <pjdelport> Tjr: Note that that first example parses as (fmap (\a b -> (a,b) ) (+3))  <*>  (*100)
14:45:52 <bitemyapp> what they said ^^
14:48:01 <Lutin`> pjdelport: no the issue is that's not how it parses
14:48:07 <Lutin`> Oh wait
14:48:10 <Tjr> Ok, I see it now.
14:48:10 <Tjr> (<*>) :: (Applicative f) => f (a -> b) -> f a -> f b
14:48:10 <Tjr> but the first examples tries
14:48:10 <Tjr>  (<*>) ::  f (a ) -> f a -> f b
14:48:11 <Lutin`> nevermind
14:48:18 <Lutin`> misread
14:48:55 <pjdelport> Tjr: It's not that; (<*>)'s type doesn't change.
14:49:26 <Tjr> so basically (*3) <*> (+100) is never a legal operatoin
14:49:32 <pjdelport> It's just that the associativity is not the same.
14:49:39 <pjdelport> Right.
14:50:06 <bitemyapp> Tjr: assume the simplest possible source of error first.
14:50:13 * pjdelport Consider:
14:50:20 <pjdelport> :t fmap (\a b -> (a,b) )  ((+3) <*> (*100))
14:50:20 <bitemyapp> Tjr: this isn't Scala, the people on the Haskell Report didn't make it up as they went along.
14:50:21 <lambdabot>     Occurs check: cannot construct the infinite type: a ~ a -> t
14:50:21 <lambdabot>     Expected type: (a -> t) -> a
14:50:21 <lambdabot>       Actual type: (a -> t) -> a -> t
14:50:27 <pjdelport> Same error.
14:50:43 <Tjr> pjdelport: I did that before coming here.
14:51:06 <bitemyapp> Tjr: then how'd you miss that it was OoO?
14:51:09 <Tjr> without the right -assoc iative parents
14:51:39 <zq-_-_-_> holes are cool
14:51:40 <Tjr> bitemyapp: Sorry, I know neither Scala nor OoO
14:51:50 <Lutin`> OoO = Out of Order
14:51:58 <Lutin`> Or Order of Operations
14:52:31 <bitemyapp> Lutin`: latter
14:53:05 <Lutin`> Yeah first stopped making sense once it came out of my mouth :{
14:53:08 <Lutin`> :P*
14:54:09 <bitemyapp> Lutin`: happens to the best of us.
14:54:11 <pjdelport> Tjr: The reason (+3) <*> (*100) doesn't type check is that for the (r ->) Applicative, <*> expects a function of two arguments to the left, and of one argument to the rgiht.
14:54:46 <pjdelport> So e.g. this works:
14:54:46 <pjdelport> > (+) <*> (*100) $ 5
14:54:48 <lambdabot>  505
14:55:17 <pjdelport> (That's also why the other fmap you posted works.)
14:55:35 <Lutin`> Tjr: BTW why not use <$>?
14:55:53 <jhance> Tjr doesn't like <$>
14:56:09 <pjdelport> But with only one argument on the left, you're trying to unify a with (a -> b), which leads to that error.
14:56:52 <Tjr> Lutin`: tutorial code, I stripped out abstractions to get a minimal example for my stupidity
14:56:53 <zwer_u> uniquenick unfortunately th32SnapEnumProcesses code uses fixed size for ProcessEntry32 structure http://www.haskell.org/ghc/docs/7.0.3/html/libraries/Win32-2.2.0.1/src/System-Win32-Process.html#th32SnapEnumProcesses
14:57:04 <pjdelport> It might help to consider the type of <*> specialized for the (r ->) functor: (<*>) :: (r -> a -> b) -> (r -> a) -> (r -> b)
14:57:40 <zwer_u> since ProcessEntry32 does not have instance from Storable you would ideally write that instance yourself and then use sizeOf (undefined :: ProcessEntry32), or if you just want to get it working quickly check the size on your platform and use that
14:58:17 <genisage> is it ever possible to convince haskell to let you use the lambda (\x -> x x) ?
14:58:26 <uniquenick> zwer: the size is going to vary across windows versions, or just 32 bit vs 64 bit?
14:58:40 <genisage> without the annoying infinite type error
14:58:58 <BeardedCoder> I have a fixed length Conduit stream that I want to take x elements at a time from to do batch style operations until the stream is done. Any pointers? I'm not sure how to use isolate for this.
14:59:52 <Tjr> How come you know all this right away, despite the fact that LYAH says <*> is never used on ((->) r) ?
15:00:33 <pjdelport> genisage: Not in Haskell, no.
15:00:34 <zwer> uniquenick probably the latter, but I am not 100% sure.
15:00:48 <agsel> a theoretical question (not directly connected to Haskell): could someone point me how to show that a rule is deductible from axioms of inference system?
15:01:24 <pjdelport> Tjr: It says that?
15:04:02 <enthropy> genisage: adding a newtype there is cheating?
15:04:46 <genisage> nope, if you can define f x = x x or (\x -> x x) without an error, nothing's cheating
15:05:10 * hackagebot SHA 1.6.4.1 - Implementations of the SHA suite of message digest functions  http://hackage.haskell.org/package/SHA-1.6.4.1 (AdamWick)
15:06:19 <Lutin`> genisage: The issue is that (\x -> x x) implies an infinite type
15:06:36 <Lutin`> I'm not even sure how you would see it otherwise
15:06:46 <rwbarton> well this might count as cheating still
15:06:47 <rwbarton> :t let f :: (forall a. a) -> a; f x = x x in f
15:06:48 <lambdabot> (forall a1. a1) -> a
15:07:48 <Lutin`> rwbarton: Ah I see now
15:08:02 <benzrf> :t \x -> x x
15:08:04 <lambdabot>     Occurs check: cannot construct the infinite type: t1 ~ t1 -> t
15:08:04 <lambdabot>     Relevant bindings include x :: t1 -> t (bound at <interactive>:1:2)
15:08:04 <lambdabot>     In the first argument of ‘x’, namely ‘x’
15:08:18 <benzrf> :t id id
15:08:19 <lambdabot> a -> a
15:08:25 <genisage> rwbarton: cool, thanks.
15:08:39 <rwbarton> mine is quite useless of course
15:08:48 <benzrf> :t (\x -> x x ) :: (a -> a) -> a -> a
15:08:50 <lambdabot>     Couldn't match expected type ‘a1 -> a1’ with actual type ‘a1’
15:08:50 <lambdabot>       ‘a1’ is a rigid type variable bound by
15:08:50 <lambdabot>            an expression type signature: (a1 -> a1) -> a1 -> a1
15:08:57 <benzrf> -le eyeroll-
15:09:04 <augur> rwbarton: i solved my problem :)
15:09:11 <benzrf> :t (\x -> x x ) :: (forall a. a -> a) -> a -> a
15:09:12 <lambdabot> (forall a1. a1 -> a1) -> a -> a
15:09:15 <rwbarton> augur, oh?
15:09:59 <augur> rwbarton: instead of using values to represent the relevant information, im just going to lift it all into the propositional domain
15:10:08 <genisage> what is this (forall a. a) thing? Or what can I google to read about it?
15:10:21 <augur> genisage: what do you mean what is it
15:10:25 <augur> genisage: `forall a. a` is a type
15:11:10 <genisage> what type is it?
15:11:26 <enthropy> rwbarton: #9210 is interesting. I guess it means ghc-7.10 will reject even more instances
15:11:54 <rwbarton> enthropy, yeah...
15:12:00 <Lutin`> genisage: http://en.wikibooks.org/wiki/Haskell/Existentially_quantified_types
15:12:02 <augur> genisage: what do you mean what type is it?
15:12:07 <augur> genisage: like, what are it's inhabitants?
15:12:12 <genisage> yes
15:12:30 <augur> it has no inhabitants in total languages
15:12:39 <augur> in haskell it has effectively one inhabitant: bottom
15:12:48 <augur> tho you might say it actually has at least two
15:12:50 <genisage> Lutin`: thanks
15:13:03 <oisin620> I'm trying to parse a line using Parsec that looks like "f a1/b1/c1 a2/b2/c2 ..." and create an object from it where the object looks like: data Object = Object [a] [b] [c]. I'm a bit confused as to how to do this and would appreciate any advice.
15:13:17 <augur> no
15:13:37 <augur> genisage: what Lutin` linked to has nothing to do with this type
15:13:53 <Lutin`> augur: It was more just about the forall keyword
15:13:56 <Lutin`> sorry to confuse
15:14:13 <augur> genisage: ah, but, now what i see the context of benzrf's thing, i can say this: in the type that benzrf wrote, `forall a. a` isn't a thing.
15:14:23 <augur> genisage: the type in question is `forall a. a -> a`
15:14:29 <rwbarton> augur, look up further :)
15:14:32 <augur> genisage: you shouldnt read Lutin`'s link tho
15:14:40 <Lutin`> augur: Wait yes it does
15:14:40 <augur> genisage: what you should understand is what forall does
15:15:10 <genisage> augur: okay, what does it do?
15:15:25 <augur> genisage: `forall` quantifiers over types. so consider the following function:
15:15:36 <augur> genisage:   idInt :: Int -> Int  ;  idInt x = x
15:15:50 <augur> genisage: now consider this function:   idBool :: Bool -> Bool   ;   idBool x = x
15:16:03 <pjdelport> http://stackoverflow.com/q/3071136/444705 has some explanations of forall
15:16:12 <augur> genisage: now consider this function:   idListFloat :: [Float] -> [Float]   ;   idListfloat x = x
15:16:21 <augur> genisage: they all look awfully similar, right?
15:16:51 <genisage> yes
15:17:30 <genisage> but in this case you wouldn't need a forall would you? you can just say id' :: a -> a; id' x = x
15:17:30 <augur> genisage: the pattern is:   they all take a Thing to a Thing, whatever "Thing" happens to actually be
15:17:44 <augur> genisage: and they do it in the same way: they map x to x
15:17:56 <augur> genisage: ill get to that :)
15:18:13 <augur> genisage: in haskell, you can instead just write    id :: forall a. a -> a   ;   id x = x
15:18:33 <augur> and this function works for every type as the identity function
15:18:39 <Lutin`> I'm confused
15:18:46 <Lutin`> The link I posted goes over all of this
15:19:12 <augur> Lutin`: yes yes im sure it does but mixing in talk of existential types is unnecessarily confusing
15:19:12 * matematikaadit listening too...
15:19:19 <augur> genisage: that makes sense, yes?
15:19:22 <Lutin`> augur: Fair enough
15:19:35 <genisage> yeah
15:19:37 <augur> genisage: ill address the `a -> a` thing in a moment
15:19:57 <augur> genisage: ok so: `forall a. a -> a` is the type of the identity function. and maybe the type of other functions, who knows
15:20:17 <augur> genisage: so what if you want to have a function which takes a `forall a. a -> a` as argument?
15:20:27 <genisage> I think id is the only possible function that works for all types, but okay
15:20:38 <augur> genisage: that is, i want to define a function f, such that the ARGUMENTS have to be polymorphic like that
15:20:50 <genisage> Makes sense.
15:20:56 <augur> ( genisage: yes, indeed, in total languages thats correct about id being the only one :) )
15:21:09 <augur> genisage: so you could write   f :: (forall a. a -> a) -> Whatever
15:21:20 <augur> genisage: so now we cant do   f idInt   because idInt is not polymorphic
15:21:32 <augur> we can only apply f to the one true id function, not the smore specific functions
15:21:37 <augur> s/smore/more/
15:21:42 <augur> tho smores are good too
15:21:43 <augur> mm
15:22:00 <augur> genisage: does that still make sense?
15:22:06 <genisage> Yes, still following you.
15:22:17 <augur> genisage: thats all forall does.
15:22:43 <augur> genisage:   forall a. T   is a type that doesnt care about what you pick `a` to actually be
15:22:50 <augur> genisage: now, you're wondering about `a -> a`
15:23:26 <augur> in haskell, when you have prenex foralls like this:      foo :: forall a b c. someJunk     you dont need to write the forall a b c. part
15:23:31 <Lutin`> augur: Doesn't that f require RankNTypes
15:23:34 <genisage> okay, earlier somebody wrote (forall a. a) -> a, and I'm not entirely sure why (forall a. a) is meaningful. I can't think of a type that isn't itself
15:23:45 <augur> notice: the type of f does NOT have prenex forall, so you can't omit it
15:24:00 <augur> genisage: thats not what it means
15:24:07 <rwbarton> yes, lambdabot has RankNTypes
15:24:21 <augur> genisage: `forall a. a`   is "for any type, i am an element of that type"
15:24:34 <augur> genisage: just like "forall a. a -> a" says "for any type, i am a function from that type to itself"
15:24:53 <genisage> so (forall a. a) -> a is exactly the same as (forall a. a -> a)?
15:25:02 <augur> no
15:25:02 <benzrf> genisage: no
15:25:12 <augur> genisage: the first one has the forall inside the parens
15:25:13 <genisage> oh
15:25:16 <benzrf> genisage: the first a is scopedTV
15:25:18 <benzrf> *scoped
15:25:19 <augur> genisage: so the ARGUMENT must be foralled
15:25:26 <genisage> I misread your anser
15:25:27 <augur> genisage: the second one has the forall outside of the argument
15:25:30 <genisage> *asnwer
15:25:31 <Lutin`> Better way to think about it is (forall a. a) -> a1
15:25:33 <Zekka> The first one says that for a value that can be of any type, I can give you a value of some specific (polymorphic) type
15:25:34 <benzrf> genisage: so that's effectively a -> b
15:25:51 <augur> genisage: no its not effectively that either
15:25:53 <augur> whoops
15:25:55 <augur> benzrf: ^
15:25:59 <augur> tho it can be used to that effect
15:26:05 <Lutin`> So you're saying `forall b. (forall a. a) -> b` right?
15:26:14 <Lutin`> Effectively
15:26:17 <augur> ok ok ok too many cooks in the kitchen
15:26:26 <Lutin`> I'm asking you a question
15:26:47 <augur> me? a question about what
15:26:49 <platz> I
15:27:03 <genisage> Is there any value that can be interpreted as any type?
15:27:10 <augur> genisage: not really
15:27:18 <Lutin`> That (forall a. a) -> a is equivalent to forall b. (forall a. a) -> b?
15:27:18 <augur> genisage: `forall a. a` has no inhabitants at all
15:27:34 <rwbarton> Lutin`: yes, it is. just my keyboard only has the 'a' key
15:27:37 <platz> I've heard it described before as "basically a lambda in the type system", but the previously linked SO post makes it seem more complicated
15:27:55 <platz> when combined with other language extensions
15:28:21 <augur> platz: not quite
15:28:32 <Lutin`> rwbarton: haha
15:28:38 <augur> genisage: so you're cuing into something here:   forall a. a   has no elements!
15:29:06 <Lutin`> besides bottom?
15:29:09 * dwcook shifts uncomfortably.
15:29:22 <genisage> And did that make haskell short circuit something and not try to evaluate the type of (
15:29:24 <augur> Lutin`: besides bottom ;)
15:29:28 <genisage> \x -> x x)
15:29:44 <augur> genisage: who knows. lambda bot is weird :)
15:29:47 <augur> :t \x -> x x
15:29:48 <lambdabot>     Occurs check: cannot construct the infinite type: t1 ~ t1 -> t
15:29:48 <lambdabot>     Relevant bindings include x :: t1 -> t (bound at <interactive>:1:2)
15:29:48 <lambdabot>     In the first argument of ‘x’, namely ‘x’
15:29:59 <augur> genisage: see? lambda bot acknowledges that this function has no type
15:30:01 <benzrf> well you need a rank-2 type for it to work
15:30:06 <Lutin`> 'work'
15:30:07 <augur> and yet somehow it didnt do something crazy with the other one
15:30:10 <delphinas> can anyone tell where you guys use haskell ?
15:30:10 <augur> its mysterious
15:30:19 <benzrf> delphinas: on my computer :^)
15:30:19 <delphinas> specific cases
15:30:20 <augur> delphinas: on my computer!
15:30:22 <delphinas> no
15:30:22 <augur> benzrf: hahaha
15:30:23 <augur> <3
15:30:30 <augur> benzrf: great minds :D
15:30:34 <Zekka> delphinas: I use it for most of my general-purpose programming even though I don't get to use it at work
15:30:35 <matematikaadit> augur++
15:30:36 <delphinas> No I mean what for sorry
15:30:39 <augur> delphinas: in my imaginary startup
15:30:42 <d3lxa> in xmonad I've coded a move-to-tag with prompt but it doesn't react immediately, aynone has an idea: http://sprunge.us/XUPR did I screw up? thx
15:30:48 <delphinas> augur lol :D
15:30:50 <genisage> :t let f :: (forall a. a) -> a; f x = x x in f
15:30:50 <augur> genisage: does any of this make sense?
15:30:51 <lambdabot> (forall a1. a1) -> a
15:30:57 <benzrf> delphinas: programming
15:30:57 <Zekka> Lately I wrote a video game AI in it: http://github.com/Zekka/whidgle
15:31:10 <delphinas> benzrf obviously! :D I mean specific cases
15:31:16 <genisage> yes, everything up to the implementation details of lambdabot makes sense
15:31:23 <augur> genisage: the thing thats going on there really is
15:31:33 <enthropy> d3lxa: use windows instead of modify
15:31:37 <Zekka> I also wrote a programming language in it a while ago but I'm not working on it now because I feel like it needs a lot of retooling
15:31:37 <delphinas> Zekka interesting
15:31:42 <augur> genisage: because x can be any type you want, it can be   (forall a. a) -> (forall a. a)
15:31:48 <fread2282> has anyone played around withn using CPS to represent data?
15:31:58 <Zekka> fread2282: What, like with church encodings?
15:32:07 <augur> genisage: or it can be    forall b. (forall a. a) -> b
15:32:13 <augur> genisage: or it can be whatever the hell you like
15:32:17 <d3lxa> enthropy: trying right now, can you tell me what's wrong?
15:32:23 <augur> genisage: lets try this:
15:32:32 <Zekka> delphinas: I also wrote an IRC bot a while back -- not sure if I have any other public haskell projects
15:32:36 <augur> :t let f :: (forall a. a) -> Int ; f x = x x in f
15:32:37 <lambdabot> (forall a. a) -> Int
15:32:41 <augur> genisage: see?
15:33:28 <augur> genisage: the type words because    x :: forall a. a    so you pick a type, and x is in that type
15:33:45 <enthropy> d3lxa: xmonad only syncs it's state with X when you ask it to (which is what that windows function does...)
15:33:48 <genisage> alright, that makes sense. So in the first one we got haskell to accept it, but there's no argument we could feed it that would be the right type.
15:33:50 <Lutin`> The issue only arises when you try to use f ;)
15:33:57 <rwbarton> that is why I say it is cheating
15:34:03 <augur> genisage: yes, basically
15:34:08 <d3lxa> enthropy: so it does a refresh for me? that's it?
15:34:11 <augur> genisage: tho technically we can do this:
15:34:16 <Zekka> delphinas: If you want my opinion, Haskell's not really a language that's *for* anything specifically
15:34:20 <augur> :t let x = x in x
15:34:21 <lambdabot> t
15:34:31 <enthropy> d3lxa: yeah
15:34:35 <Zekka> I'd say in my experience it's about as capable for general purpose programming as Python, Ruby, Java, etc.
15:34:41 <augur> genisage: remember, prenex quantifiers can be droped, so this is the same as   forall t. t
15:34:48 <augur> genisage: notice we now have a value of that awful type
15:34:50 <d3lxa> enthropy: great, thank you very much! :)
15:34:52 <augur> genisage: also consider
15:34:53 <augur> :t undefined
15:34:54 <lambdabot> a
15:35:00 <augur> :t error "darn"
15:35:01 <lambdabot> a
15:35:23 <monochrom> haskell is for programming, specifically.
15:35:26 <Lutin`> What is the word for ()
15:35:28 <augur> genisage: haskell's non-termination and its error system give you two ways to make values of type   forall a. a
15:35:31 <augur> Lutin`: unit
15:35:32 <Lutin`> empty type/
15:35:34 <Lutin`> ah
15:35:38 <monochrom> I say this because haskell is, also specifically, not a computer algebra system
15:35:42 <augur> Lutin`: no, empty type is usually written Void
15:35:42 <Zekka> Lutin`: Empty type is Void
15:35:46 <Lutin`> that makes sense
15:35:49 <Lutin`> yeah
15:35:51 <dwcook> Lutin`: It's not empty, it has () as its only non-bottom value.
15:35:55 <augur> monochrom: what
15:35:55 <augur> lol
15:35:57 <delphinas> Zekka thanx for info. Haskell interests me as its purely functional so you can simply transform your ideas to code quickly
15:35:59 <Zekka> Unit is the exactly-one-thing type
15:35:59 <d3lxa> enthropy: I've tried the pasted version with an ending 'refresh' and it bugs, don't understand why :S
15:36:01 * Lutin` puts his foot in his mouth
15:36:18 <genisage> Alright, thanks for all of your help augur (and anybody else who contributed)
15:36:45 <monochrom> and I say that because a few mathy beginners expect [x | x<-[1..], x<2] = [1,2]. a computer algebra system can do that. haskell can't.
15:37:05 <monochrom> err typo. [1].
15:37:29 <augur> monochrom: constraint satisfaction
15:37:32 <augur> monochrom: always fun!
15:37:38 <Zekka> delphinas: If I were asked to explain why I like Haskell I'd probably go with the thousand-yard view approach and say that it's because it's about as expressive as Python but much better at checking whether my code is correct
15:37:38 <Lutin`> Or 'let x = 1/x + 1'
15:37:39 <augur> haskell can do it, just not like that :)
15:38:22 <benzrf> Zekka: 'about as'?
15:38:27 <benzrf> dont be silly :-O
15:38:29 <delphinas> Zekka so that means saves your time! :)
15:38:31 <Zekka> benzrf: Maybe a little more.
15:38:35 <benzrf> :-)
15:38:50 <Zekka> A lot of the stuff that's builtin in Python (in a way that's intuitively 'wrong') you have to make explicit in Haskell
15:39:02 <monochrom> "expressive" is subjective
15:39:05 <Zekka> so I find that oftentimes writing the same sort of code in Haskell will require me to say a little bit more
15:39:13 <enthropy> d3lxa: as in you have    "pushToWs = do modify ... ; refresh"?
15:39:20 <benzrf> Zekka: dont write the same sort of code then
15:39:25 <Zekka> but very little of what I have to say feels like boilerplate because while Python introduces a lot of syntax, pretty much everything you say in Haskell has actual meaning
15:39:30 <enthropy> d3lxa: it's probably better if we move this to #xmonad which is much less busy
15:39:31 <d3lxa> enthropy: yeah do (modify …) >> refresh
15:39:40 <Zekka> benzrf: Oh, I don't mean "same sort of code" in the sense that it literally says the same thing
15:39:45 <benzrf> o ok
15:39:59 <benzrf> Zekka: so tell me what do you know about van laarhoven lenses
15:40:12 <monochrom> I agree with "has actual meaning". it is a result of designing semantics before designing syntax.
15:40:15 <Zekka> but I mean that for instance, wrapping monad transformers often introduces a lot of extra text
15:40:23 <benzrf> mmaruseacph2:
15:40:24 <benzrf> *mm
15:40:27 <Zekka> benzrf: I'll start with what they accomplish
15:40:43 <augur> benzrf: i can tell you what i know about twanvl's lenses :)
15:40:45 <Zekka> they give you a pretty neat language for describing accessors compared to records
15:40:52 <Zekka> Next, types
15:40:56 <augur> benzrf: https://www.fpcomplete.com/user/psygnisfive/from-zipper-to-lens
15:41:05 <benzrf> augur: i already know em pretty ok
15:41:08 <benzrf> idk if Zekka does
15:41:13 <genisage> one other question, my ghc installation doesn't like having a '.' in a type. Is that stuff not part of standard haskell or is what I have out of date?
15:41:18 <augur> benzrf: oh well FINE
15:41:19 <Zekka> (s -> f t) -> a -> f b basically describes how we turn an operation from Ss to Ts into an operation from As to Bs
15:41:29 <Zekka> benzrf: I've used them but I'm pretty eager to learn a little more
15:41:30 <benzrf> Zekka: normally you use a/b for th einner
15:41:31 <benzrf> *the inner
15:41:34 <augur> zekka can read my post then if they want!
15:41:41 <Zekka> benzrf: Oh, did I get that backwards? Sorry about that
15:41:42 <augur> yeah, the better to write "stab" with
15:41:43 <benzrf> Zekka: do you unnerstand what the f is for?
15:41:44 <augur> crabstab
15:41:55 <Zekka> benzrf: It's a functor or applicative which carries the notion of getting or setting
15:42:02 <benzrf> kk cool
15:42:06 <benzrf> hence the use of Const
15:42:06 <platz> zipper to lens ... I love it when a plan comes together ;)
15:42:11 <Zekka> If I remember right it's usually either Const someValue or Identity
15:42:16 <benzrf> Zekka: yea
15:42:36 <augur> Const is get
15:42:39 <augur> Identity is set
15:42:41 <monochrom> most languages don't have semantics designed; often not even syntax. they grow by stream of consciousness: "oh I suddenly realize, wouldn't it be nice to patch up the language to support one more thing!" patches and patches compiling up. the semantics is an afterthought. it's a mess.
15:42:42 <dwcook> genisage: Alphanumeric identifiers cannot contain dots. Perhaps you're thinking of module qualifying syntax.
15:42:45 <augur> well
15:42:45 <Zekka> I don't know, though, exactly how the get/set operations are formulated in terms of those
15:42:47 <augur> identity is over
15:42:58 <augur> Zekka: read my post! :)
15:42:59 <augur> https://www.fpcomplete.com/user/psygnisfive/from-zipper-to-lens
15:43:09 <benzrf> > _1 Identity (3, 4)
15:43:11 <lambdabot>  Identity {runIdentity = (3,4)}
15:43:15 <benzrf> o wait
15:43:21 <benzrf> > _1 (Identity . (*5)) (3, 4)
15:43:23 <lambdabot>  Identity {runIdentity = (15,4)}
15:43:25 <benzrf> ^note
15:43:27 <Zekka> augur: Sure, although if benzrf wants to talk about things I'll humor him first
15:43:33 <benzrf> fine just read the article
15:43:36 <Zekka> because that's more interesting
15:43:37 <benzrf> ;-;
15:43:38 <augur> humoring benzrf is a good idea
15:43:42 <augur> he might go on a rampage
15:43:44 * benzrf sniffles
15:43:46 <Zekka> I shouldn't say "humoring"
15:43:55 <FireFly> augur: wait, your post?
15:44:01 <augur> FireFly: yes my post https://www.fpcomplete.com/user/psygnisfive/from-zipper-to-lens
15:44:04 <Zekka> I just mean that I personally prefer talking over concepts with people who know them than reading about them, because I have the option to do the second more often than the first
15:44:08 <monochrom> where as every addition to haskell goes through "what is its semantics? what is the overall semantics after adding this?" as one of the prerequisite questions
15:44:20 <Zekka> and because you can't say "I don't understand; can you give me another example?" to an article
15:44:20 <genisage> dwcook: :t let f :: (forall a. a) -> a; f x = x x in f worked in here with lambdabot but not locally in ghci
15:44:23 <FireFly> augur: I recognize that nick from reddit :p
15:44:33 <augur> FireFly: yes, thats my name on reddit
15:44:35 <Lutin`> genisage: That's because that type requires -XRankNTypes
15:44:35 <augur> and twitter
15:44:38 <FireFly> I see
15:44:40 <delphinas> monochrom nicely explained
15:44:42 <Zekka> But at the same time I'm trying to not act like I expect ben to explain more than he's interested in explaining
15:44:43 <benzrf> Zekka: the idea is that a Lens s t a b takes a function, then applies that function to the a subsection of an s, then it fmaps a function to reassemble a t around the b in the functor valu
15:44:45 <genisage> Lutin`: thanks
15:44:47 <dwcook> genisage: Enabling RankNTypes will do the trick.
15:44:47 <benzrf> e
15:44:48 <FireFly> I didn't make the connection
15:44:55 <augur> FireFly: but IRC is for hackers, so i use the name of a favorite hacker here!
15:44:56 <benzrf> Zekka: for example, _1 could be defined like this:
15:44:56 <Lutin`> genisage: This is what I meant to link earlier http://en.wikibooks.org/wiki/Haskell/Polymorphism
15:45:04 <Zekka> benzrf: Let me open up an lpaste and try expanding your _1 expression
15:45:14 <Lutin`> augur: That a better link? :)
15:45:18 <augur> Lutin`: yes
15:45:26 <benzrf> @let _1' f (a, b) = fmap (\new -> (new, b)) (f a)
15:45:27 <lambdabot>  Defined.
15:45:27 <Zekka> I'll keep reading but I'll do that in the background
15:45:31 <augur> Lutin`: existential types are a whole different ball of wax
15:45:34 <Lutin`> Yeah
15:45:41 <Lutin`> I didn't really read past the intro
15:45:45 <Lutin`> :X
15:45:50 <benzrf> Zekka: it applies the 1st arg to the subsection that it focuses on, then it fmaps the rest back around it
15:45:52 <augur> Lutin`: theyre relevant and related, but unnecessarily confusing at this stage
15:46:08 <benzrf> Zekka: the key point here is that by choosing an appropriate functor, you can control how the reassembly works
15:46:19 <benzrf> Zekka: with an Identity functor, it reassembles it as normal
15:46:23 <benzrf> so it's just over
15:46:28 <Zekka> And if it's const it doesn't actually change anything?
15:46:32 <benzrf> precisely
15:46:41 <benzrf> then you can pull what you stashed back out
15:46:42 <benzrf> for view
15:46:55 <Zekka> Hold up, let me try throwing together an example with const
15:46:58 <benzrf> kk
15:47:01 <benzrf> Const, not const :p
15:47:02 <Zekka> :t Const
15:47:03 <lambdabot>     Ambiguous occurrence ‘Const’
15:47:03 <lambdabot>     It could refer to either ‘L.Const’,
15:47:03 <lambdabot>                              defined at /home/lambda/.lambdabot/State/L.hs:147:21
15:47:07 <Zekka> Yeah, you're right, type-level const
15:47:07 <benzrf> @undefine
15:47:07 <lambdabot> Undefined.
15:47:10 <benzrf> :t Const
15:47:11 <lambdabot> a -> Const a b
15:47:27 <Zekka> > _1 (Const) (3, 4)
15:47:28 <lambdabot>  No instance for (GHC.Show.Show
15:47:28 <lambdabot>                     (Control.Applicative.Const t0 (b0, t1)))
15:47:28 <lambdabot>    arising from a use of ‘M27920372780552992975966.show_M27920372780552992975...
15:47:28 <lambdabot>  The type variable ‘t1’ is ambiguous
15:47:28 <lambdabot>  Note: there are several potential instances:
15:47:45 <Zekka> Does it implement a 'and then get the value out' typeclass in common with Identity?
15:48:16 <Zekka> > getConst $ _1 (Const) (3, 4)
15:48:18 <lambdabot>  3
15:48:48 <benzrf> :-)
15:48:53 <benzrf> other lens tricks:
15:49:01 <Zekka> My first thought when you're parameterizing these two similar operations over two different Functors is that you'd want to have something like that to wrap the endpoint in to hide the type-level wrapper
15:49:16 <Lutin`> So I can think of 'forall a.' as meaning '∀a∈ob(Hask)' ?
15:49:29 <benzrf> > _1 (map ($) [(+1), (+2), (+3)]) (4, 5)
15:49:31 <lambdabot>  Couldn't match expected type ‘t0 -> f b’
15:49:31 <lambdabot>              with actual type ‘[a0 -> a0]’
15:49:42 <benzrf> oh wait
15:49:51 <benzrf> > _1 (\v -> map ($ v) [(+1), (+2), (+3)]) (4, 5)
15:49:53 <Zekka> :t _1
15:49:53 <lambdabot>  [(5,5),(6,5),(7,5)]
15:49:54 <lambdabot> (Field1 s t a b, Functor f) => (a -> f b) -> s -> f t
15:50:08 <benzrf> Zekka: Field1 is a typeclass so that _1 works on multiple tuple types
15:50:09 <dwcook> benzrf: Bout to say, hint: map ($) = map id :)
15:50:11 <johnw> Lutin`: I believe so
15:50:21 <dwcook> Well, but with a stricter type
15:50:31 <shachaf> Lutin`: forall can quantify over all sorts of things.
15:50:33 <Zekka> benzrf: I actually just wanted to check if _1 was polymorphic the way I thought it was
15:50:37 <benzrf> Zekka: so if you use the List functor, you can get an array of possible versions after switching out the value
15:50:40 <benzrf> Zekka: kk
15:50:43 <Lutin`> shachaf: So not just types?
15:50:50 <johnw> shachaf: what's an example of another sort of thing?
15:50:55 <benzrf> brb
15:50:59 <dwcook> forall m. m a
15:51:02 <dwcook> m :: * -> *
15:51:11 <johnw> ah
15:51:12 <Zekka> :t _Just
15:51:13 <lambdabot> (Choice p, Applicative f) => p a (f b) -> p (Maybe a) (f (Maybe b))
15:51:14 <johnw> thanks!
15:51:23 <Lutin`> ah
15:51:26 <Zekka> benzrf: Now explain that one! (when you get back)
15:51:43 <johnw> forall (m :: Constraint)?
15:51:58 <Zekka> Actually, I expect p is usually (->) and then it gets pretty s imple
15:52:01 <Lutin`> Isn't * -> * in ob(Hask)?
15:52:12 <fragamus> http://lpaste.net/105703
15:52:18 <Zekka> But I was curious about how traversals worked
15:52:30 <Zekka> _Just (Identity . (*4)) (Just 1)
15:52:32 <dwcook> Lutin`: Where is its identity morphism?
15:52:35 <johnw> * -> * isn't an object in Hask, but a functor from Hask -> Hask
15:52:36 <Zekka> > _Just (Identity . (*4)) (Just 1)
15:52:37 <lambdabot>  Identity {runIdentity = Just 4}
15:52:41 <Lutin`> Aha
15:52:45 <Zekka> > _Just (Identity . (*4)) (Nothing)
15:52:47 <lambdabot>  Identity {runIdentity = Nothing}
15:52:52 <johnw> well, sorry, not a functor
15:52:53 <Lutin`> I'm still a Category Theory nub, forgive me :P
15:52:58 <fragamus> this is my quest
15:53:10 <fragamus> to understand the cont monad
15:53:16 <fragamus> no matter how hopeless
15:53:29 <johnw> fragamus: I was playing with Cont a lot these past two days
15:53:36 <Zekka> @src _Just
15:53:36 <lambdabot> Source not found.
15:53:42 <Athas> I wonder if it's possible to load all of GHC in GHCi...
15:53:54 <dwcook> johnw: Is it always a functor?
15:53:55 <fragamus> well im sorry you must have a headache johnw
15:53:57 <johnw> it occurred to me that Cont r a ~ Algebra ((->) a) r, which may be easier to fathom if you work out what that means
15:54:00 <johnw> dwcook: no, I misspoke
15:54:01 <dwcook> johnw: Oh, you corrected yourself
15:54:13 <Lutin`> fragamus: Have you seen http://blog.sigfpe.com/2008/12/mother-of-all-monads.html
15:54:30 <monochrom> fragamus: it looks to me the "package up" analogy is way off. I don't feel any packaging up in this example, or in Cont, or in monads in general.
15:54:35 <fragamus> yes it is referenced in my paste
15:54:43 <Lutin`> Ah sorry missed that
15:54:57 <dwcook> johnw: That makes me wonder what sort of thing it actually is though.
15:55:11 <johnw> dwcook: which thing, * -> *?
15:55:16 <dwcook> Yes.
15:55:22 <fragamus> well I hate not understanding it
15:55:34 <fragamus> with *all* of my hate
15:55:38 <johnw> in my simple-conduit library, the of Source has simplified down roughly to Cont (r -> m r) a, which is sufficient to express most streaming I/O pipelines
15:55:43 <johnw> s/the of/the type of
15:55:53 <monochrom> it is absolutely important to understand that article?
15:56:02 <Lutin`> Isn't * -> * a functor in the categorical sense of the word?
15:56:11 <dwcook> Is it just a function from concrete types onto concrete types?
15:56:18 <fragamus> i can't answer until I understand it lol
15:56:19 <johnw> Lutin`: it needs function mapping and laws
15:56:25 <monochrom> an abstract article like that requires a lot of concrete experience with many things to understand. Piaget's theory.
15:56:35 <Lutin`> ah yeah good point
15:56:56 <johnw> to be a functor
15:57:04 <Lutin`> Anyone have suggestions on some Category Theory books I should read with some good examples?
15:57:13 <Lutin`> johnw: Yeah you have to map arrows as well as objects
15:57:14 <johnw> otherwise it's just some kind of mapping from Hask to Hask, but what it maps, how, and why, is unknown
15:57:29 <johnw> though i suppose if it's * -> *, then by definition it can map all objects
15:57:38 <oisin620> I'm having a bit of trouble parsing a definition in Parsec (http://lpaste.net/105705). The first parse under `faceDefinition` works, but if it fails it doesn't attempt the next parser -- am I incorrectly using `<|>`?
15:58:04 <johnw> Lutin`: I like http://www.amazon.com/Conceptual-Mathematics-First-Introduction-Categories/dp/0521478170
15:58:08 <johnw> as a first book
15:58:28 <Lutin`> Alright I'll take a look
15:58:50 <johnw> there are also some gems on the Internet, but you'll have to sift through to find a style that appeals to you
15:58:54 <dwcook> oisin620: Just at a glance, you might be running into backtracking problems. Parsec doesn't backtrack automatically. Use try for that.
15:59:11 <Luke> I have a (data A a = A a) and a (data B a = B a) that are functors. Is there a way to make a functor for (A (B a)) ?
15:59:14 <johnw> * -> * is also the type of Foo in data Foo a = Foo
15:59:16 <johnw> s/type/kind
15:59:31 <johnw> Luke: use DeriveFunctor
15:59:43 <Luke> i am for the base types
15:59:44 <shachaf> Luke: Yes, you can define a Compose type.
15:59:45 <johnw> newtype AB a = AB (A (B a)) deriving Functor
15:59:53 <phaazon> hey, do you know whe Ross Patterson is here?
15:59:53 <johnw> or yeah, of course, Compose
15:59:53 <Luke> i have to make the new type to do it?
15:59:57 <dwcook> oisin620: Read the documentation for both Parsec's (<|>) and try.
16:00:04 <shachaf> But you can't have fmap :: (a -> b) -> A (B a) -> A (B b)
16:00:11 <johnw> type AB = Compose A B
16:00:13 <Luke> why not?
16:00:16 <oisin620> dwcook: Ah, I see - thanks!
16:00:25 <shachaf> Because it creates all sorts of ambiguity.
16:00:25 <Luke> shachaf: why doesn't that work
16:00:28 <Luke> ok
16:00:33 <phaazon> I see transformers is in version 0.4.x
16:00:35 <shachaf> fmap id :: A (B a) -> A (B a) -- which instance?
16:00:36 <Luke> so type system can't do it basically?
16:00:42 <phaazon> what’s broken?
16:00:47 <shachaf> The type system chooses not to do it.
16:01:29 <benzrf> Zekka: lens does annoyingly wacky shit with profunctors and type synonyms and what have u
16:01:31 <Zekka> Luke: Am I understanding that you want to automatically derive instance (Functor f, Functor g) => Functor (f . g)? (pseudocode)
16:01:32 <Luke> shachaf: your example would be (fmap . fmap) id a basically
16:01:42 <Luke> Zekka: yeah
16:01:56 <Zekka> benzrf: Yeah, I'm reading up on profunctors now although even though I understand what they are (and understood before) I don't get a strong intuition for them
16:02:00 <Lutin`> I wish I had a systemwide Latex mode
16:02:03 <phaazon> I really don’t like guys who update versions of their and don’t stick to the version guideline…
16:02:10 <phaazon> +libs
16:02:22 <Zekka> Luke: What if you only wanted to fmap one layer deep?
16:02:25 <fragamus> shachaf how does one approach an understanding of the cont monad
16:02:38 <Luke> Zekka: oh good point
16:03:04 <Luke> so the short answer is I have to make a new type
16:03:05 <shachaf> fragamus: Why are you asking me?
16:03:06 <Luke> no problem
16:03:07 <Luke> thanks
16:03:18 <Zekka> benzrf: I'm actually surprised at the sheer number of freakily abstract data types in Lens
16:03:20 <fragamus> because i dont know
16:03:21 <Zekka> you wouldn't think they'd have come up with that many
16:03:30 <Zekka> Luke: You can use fmap.fmap to fmap two layers deep
16:03:33 <Zekka> :t fmap.fmap
16:03:34 <lambdabot> (Functor f1, Functor f) => (a -> b) -> f (f1 a) -> f (f1 b)
16:03:40 <shachaf> Zekka: There aren't that many, are there?
16:04:07 <shachaf> A fair amount of lens is hacks rather than proper abstractions. E.g. Conjoined.
16:04:13 <shachaf> Useful hacks, but nevertheless.
16:04:17 <Zekka> shachaf: Do you want me to start listing? I can think of more Lens types than I can think of stdlib types
16:04:26 <Zekka> although I don't have an intuition for very many of them
16:04:44 <johnw> fragamus: implement Cont yourself
16:04:54 <Luke> Zekka: yeah I'm aware of fmap . fmap - i just wanted fmap = fmap . fmap but your point about which to use makes sense. thanks
16:04:54 <shachaf> Zekka: That's maybe due to a lack of abstraction if anything. :-)
16:04:58 <johnw> then implement it again without looking at your previously implementation
16:05:02 <Zekka> actually, that's a poor claim. I can think of more Lens types than I can think of stdlib typeclasses where Lens types seem general enough to act as typeclasses on their own
16:05:02 <Luke> afk
16:05:14 <johnw> use equational reasoning to prove that it's a functor, an applicative and a monad
16:05:16 <shachaf> We have Lens and Lens' -- two types instead of one.
16:05:18 <Zekka> ('act as typeclasses' is a sloppy way to put it)
16:05:28 <shachaf> The whole point of a big part of lens is not to use type classes.
16:05:52 <shachaf> Type classes aren't the thing that types turn into when they become sufficiently general.
16:06:22 <johnw> fragamus: for example, I did this here: https://github.com/jwiegley/notes/blob/master/misc/ContThoughts.hs
16:06:31 <Zekka> Right -- most of Lens seems to be sufficiently general type synonyms
16:07:29 <benzrf> yep
16:07:33 <benzrf> it bugs me >:{
16:07:39 <benzrf> type Getting r s a = (a -> Const r a) -> s -> Const r s
16:07:54 <benzrf> so now we can use view on any function that at least works with const
16:07:59 <Zekka> benzrf: Which is pretty straightforward
16:08:00 <benzrf> regardless of whether its general over functors
16:08:29 <Zekka> I was staring at the type for Prism earlier but I have a feeling it's better to start with traversals
16:08:38 <benzrf> Zekka: perhaps
16:08:43 <benzrf> Prism is annoying too :{
16:08:47 <johnw> There are always new insights to be gleaned.  For example, Cont r a is also a church-encoding for any single-value constructor
16:09:02 <benzrf>   (Choice p, Control.Applicative.Applicative f) =>
16:09:03 <benzrf>   p a (f b) -> p s (f t)
16:09:09 <augur> Compose f g a = Compose (f (g a))
16:09:10 <benzrf> oops, i mean
16:09:11 <benzrf> type Prism s t a b = (Choice p, Control.Applicative.Applicative f) => p a (f b) -> p s (f t)
16:09:11 <Zekka> Traversals are pretty straightforward although looking at the type doesn't immediately give you a strong intuition for the machinery
16:09:19 <augur> so much better than AB
16:09:19 <Zekka> benzrf: Right, it's a more general version of the Traversal
16:09:25 <Zekka> type Traversal s t a b = forall f. Applicative f => (a -> f b) -> s -> f t
16:09:26 <benzrf> choice defines
16:09:26 <benzrf>   left' :: p a b -> p (Either a c) (Either b c)
16:09:26 <benzrf>   right' :: p a b -> p (Either c a) (Either c b)
16:09:31 <benzrf> be back in a sec
16:09:34 <augur> oh did someone write that already?
16:09:41 <augur> ugh, stupid limechat not scrolling >_<
16:10:03 <zwer> > fmap fmap fmap (+10) [[1,2,3],[4,5,6]]
16:10:04 <lambdabot>  [[11,12,13],[14,15,16]]
16:10:33 <Zekka> > (fmap.fmap) (+10) [[1, 2, 3], [4, 5, 6]]
16:10:34 <lambdabot>  [[11,12,13],[14,15,16]]
16:10:50 <Zekka> (I like being able to count)
16:11:04 <Lutin`> Can @src give the source for a specific instance of fmap?
16:11:15 <benzrf> @src [] fmap
16:11:15 <lambdabot> fmap = map
16:11:28 <Lutin`> @src ((->) a) fmap
16:11:28 <lambdabot> Source not found. Maybe you made a typo?
16:11:44 <Lutin`> hmm
16:11:53 <Zekka> So, my first thought when looking at the sig for Traversal is this
16:12:35 <Lutin`> ah just
16:12:39 <Zekka> Actually, hold up
16:12:41 <Lutin`> @src (->) fmap
16:12:41 <lambdabot> fmap = (.)
16:12:51 <Zekka> I had a thought but I'm going to test it by trying to write an expansion in an lpaste
16:12:58 <benzrf> Zekka: lets talk aboot prisms
16:12:59 <benzrf>   left' :: p a b -> p (Either a c) (Either b c)
16:13:00 <benzrf>   right' :: p a b -> p (Either c a) (Either c b)
16:13:10 <benzrf> type Prism s t a b = (Choice p, Control.Applicative.Applicative f) => p a (f b) -> p s (f t)
16:13:13 <Zekka> benzrf: You don't want to talk about Traversals (which seem less general) first?
16:13:21 <benzrf> they're different, not less general
16:13:35 <Zekka> A traversal appears to be a prism for p is (->)
16:13:46 <benzrf> what you have here is a function that takes a profunctor over a and f b and gives a profunctor over s and f t
16:14:02 <Zekka> Right -- for any profunctor, not just ->?
16:14:05 <benzrf> yep
16:14:15 <benzrf> basically, you need to dimap things that go from s to a and from f b to f t
16:14:41 <benzrf> but note that you cannot count on having a concrete value for s!
16:14:48 <benzrf> in a lens, you may have one
16:14:53 <benzrf> because the profunctor is always ->
16:15:04 <Zekka> benzrf: So you'd say that the signature for a prism looks like dimapping some functions over the prism that comes in into the prism that comes out, correct?
16:15:06 <benzrf> so you can write a lambda or an extra arg to see what s you're acting on
16:15:08 <Zekka> er, profunctor*
16:15:09 <benzrf> Zekka: right
16:15:10 <benzrf> more or less
16:15:17 <Zekka> the profunctor that comes in, the profunctor that comes out
16:15:20 <benzrf> yea
16:15:33 <benzrf> review works by using something that holds onto the 2nd dimapped function
16:15:37 <Zekka> And unlike a lens, we don't know what profunctor we have
16:15:37 <benzrf> so then you can apply it backwards
16:15:45 * Lutin` is so lost
16:15:53 <benzrf> Zekka: prisms are guaranteed to have independent forward and backwards
16:16:01 <benzrf> take a lens like _1
16:16:13 <Zekka> Lutin`: This is material that's known for being kind of confusing
16:16:19 <benzrf> _1 f (a, b) = fmap (\v -> (v, b)) (f a)
16:16:21 <benzrf> ^right?
16:16:28 <Zekka> benzrf: Yeah, that looks like a fair definition
16:16:34 <benzrf> note that you need to have a value of s for this to work
16:16:41 <benzrf> if you couldnt see the tuple, you wouldnt be able to close over  b
16:16:53 <Zekka> Yeah, where s for this case is the argument of f?
16:16:53 <benzrf> you couldnt dimap something without knowing what b is
16:17:02 <benzrf> s is (a, b)
16:17:04 <benzrf> :t _1
16:17:05 <lambdabot> (Field1 s t a b, Functor f) => (a -> f b) -> s -> f t
16:17:06 <benzrf> oh wait
16:17:09 <benzrf> let's say
16:17:23 <benzrf> (a -> f b) -> (a, t) -> f (b, t)
16:17:32 <benzrf> s is (a, t)
16:17:42 <benzrf> you can see a value of type s in the definition for _1
16:17:49 <benzrf> that's the (a, b) you're dissecting
16:17:53 <Zekka> OK, so s for a lens is the structure being updated
16:18:07 <benzrf> notice that the function back closes over a value in the structure being operated on
16:18:14 <Zekka> for a prism it may be a structure but we don't know that because we're not in a function but in a Choice (a Profunctor)
16:18:22 <benzrf> this can *only work* because the profunctor is a function
16:18:25 <benzrf> take a lenstr
16:18:26 <benzrf> *lens
16:18:29 <benzrf> ugh i mean a prism
16:18:31 <benzrf> type Prism s t a b = (Choice p, Control.Applicative.Applicative f) => p a (f b) -> p s (f t)
16:18:43 <coppro> benzrf: are you sure you don't mean a Toric?
16:18:43 <benzrf> you *CAN'T SEE ANY VALUES OF s*
16:18:49 <Lutin`> benzrf: How long have you been working with Haskell?
16:18:50 <rwbarton> benzrf you need to remove your tab key
16:18:55 <benzrf> rwbarton: lol
16:19:02 <benzrf> Lutin`: idr, i think at least 2 yrs
16:19:03 <Zekka> Right -- the profunctor (even though I don't really know what some common profunctors are) doesn't necessarily have an s in it?
16:19:06 <rwbarton> or at least disable it
16:19:09 <benzrf> Zekka: well
16:19:10 <benzrf> to be precise
16:19:20 <coppro> (a Toric is a kind of Lens, for those unfamiliar with optometry)
16:19:27 <benzrf> (a -> f b) -> ((a, t) -> f (b, t))
16:19:30 <benzrf> ^this is the type of _1
16:19:33 <benzrf> now
16:19:40 <benzrf> since (->) is right-associative
16:19:42 <Zekka> coppro: Wait, is that "optometry" in the legitimate field of optometry sense or the "pun about Lens library" sense?
16:20:04 <benzrf> we can get away with shifting the (a, t) into an argument on the lhs
16:20:16 <benzrf> because (a -> f b) -> ((a, t) -> f (b, t)) is the same as (a -> f b) -> (a, t) -> f (b, t)
16:20:29 <Zekka> OK, I can see it
16:20:33 <benzrf> however!
16:20:35 <benzrf> type Prism s t a b = (Choice p, Control.Applicative.Applicative f) => p a (f b) -> p s (f t)
16:20:38 <Zekka> we're just substituting s andt for the tuple before and after
16:20:40 <benzrf> you CANNOT shift the s as an arg to the left
16:20:55 <benzrf> you have to transform an arbitrary profunctor/choice
16:20:58 <benzrf> NOT a function
16:21:01 <Zekka> Right, I think I understand
16:21:07 <benzrf> so you cannot write a lambda that gets to see the s
16:21:07 <coppro> Zekka: yes
16:21:15 <benzrf> or you can, but the s cannot leak outside of the lambdabot
16:21:17 <benzrf> *lambda
16:21:17 <octophore> what library has (>>>) ?
16:21:20 <benzrf> so the function back cannot close over it
16:21:25 <Zekka> So, my intuitive thought is that a profunctor probably gives us an fmap-style operation that lets us get inside its structure to see the hypothetical operation?
16:21:28 <jle`> octophore: it's in Control.Arrow in base
16:21:28 <coppro> Zekka: I'm making fun of the terminology of Lens by using terminology from optometry
16:21:29 <Zekka> (probably dimap?)
16:21:33 <octophore> thank you jle`
16:21:37 <benzrf> Zekka: dimap is the profunctor operation
16:21:38 <jle`> octophore: it's just flip (.), btw
16:21:39 <benzrf> :t dimao
16:21:40 <lambdabot>     Not in scope: ‘dimao’
16:21:40 <lambdabot>     Perhaps you meant ‘dimap’ (imported from Control.Lens)
16:21:40 <benzrf> p
16:21:42 <benzrf> ugh
16:21:44 <jle`> it's usually unidiomatic
16:21:45 <benzrf> :t dimap
16:21:46 <lambdabot> Profunctor p => (a -> b) -> (c -> d) -> p b c -> p a d
16:21:51 <jle`> except in specific cases
16:22:02 <benzrf> Zekka: you can write a lambda that gets to see the s
16:22:10 <benzrf> you submit it as the first arg to dimap
16:22:11 <Zekka> That's about what I expected. So dimap essentially lets us 'see into' the profunctor and map into it like we can with a functor?
16:22:12 <octophore> I really want to learn more about the maths behind it though, I saw the type signature for it earlier and it had a bunch of concepts I wasn't familiar with
16:22:23 <octophore> thanks for the tip
16:22:24 <jle`> octophore: ah
16:22:34 <benzrf> i like to think of a profunctor as looking something like this:
16:22:34 <jle`> :t (>>>)
16:22:34 <Zekka> the same way a functor lets us 'see into' the inner part and apply a function on it?
16:22:35 <lambdabot> Category cat => cat a b -> cat b c -> cat a c
16:22:41 <benzrf> <---o---->
16:22:43 <jle`> octophore: yeah...it's kind of unfortunately placed for learning purposes
16:22:46 <benzrf> or rather
16:22:50 <coppro> hmm... a Toric would really be a Lens that isn't just a Lens'
16:22:54 <Zekka> Like a seesaw?
16:22:56 <jle`> octophore: the Category typeclass generalizes over (->)-like things
16:22:56 <benzrf> b<---o--->c
16:22:57 <coppro> a Lens' should be called a Spherical :P
16:23:02 <benzrf> like, flowing outwards from a center
16:23:15 <jle`> octophore: so if you use (->) for cat, you get (a -> b) -> (b -> c) -> (a -> c)
16:23:16 <benzrf> then you can tack a function onto each side going in the same direction
16:23:25 <benzrf> so if you have a function (a <- b)
16:23:27 <benzrf> you can do
16:23:35 <benzrf> (a <- b)b<---o--->c
16:23:39 <benzrf> and on the other end
16:23:42 <benzrf> (a <- b)b<---o--->c(c -> d)
16:23:44 <octophore> forgive me if i'm way off base but is (->) the "category of morphisms in Hask"?
16:23:50 <benzrf> and now you have a and d on the ends
16:23:57 <Zekka> benzrf: But that doesn't seem to match the type of dimap
16:24:04 <Zekka> dimap takes an a -> b, not a b -> a, right?
16:24:06 <benzrf> note it's (a <- b)
16:24:08 <Zekka> That looks more like a bifunctor to me
16:24:14 <Zekka> I know, that's what I'm saying
16:24:14 <benzrf> which is really (b -> a)
16:24:20 <Zekka> :t bimap
16:24:21 <lambdabot> Bifunctor p => (a -> b) -> (c -> d) -> p a c -> p b d
16:24:34 <dagano> i'm reading bird's book and he has what looks like it should be pattern matching but ... is actually multiple definitions for a function. something like f ([],ys) = ... then next line f(xs,[]). can you do this?
16:24:53 <benzrf> dagano: yeah
16:24:58 <benzrf> that's quite common
16:24:59 <jle`> dagano: yes, it's syntactical sugar for f t = case t of ([],ys) -> ...
16:25:00 <Zekka> dagano: Yeah, you can include several patterns for a function and the result will be a function that tries each until one matches
16:25:07 <Zekka> What jle said is correct
16:25:19 <jle`> dagano: it actually is inspired from how piecewise defined functions are also written in maths
16:25:21 <jle`> fac 0 = 1
16:25:26 <dagano> it 'tries them' going down the code?
16:25:26 <jle`> fac n = n * fac (n-1)
16:25:33 <jle`> dagano: yes, same as for case statements
16:25:38 <dagano> k thanks
16:25:41 <Zekka> dagano: Yeah. It always tries the top one before the next, and so on
16:25:54 <Zekka> benzrf: Anyway, am I misunderstanding your analogy?
16:25:59 <benzrf> dimap :: b<---o--->c => (a <- b)b<---o--->c(c -> d)
16:26:12 <benzrf> notice that the arrow in (a <- b) is backwarsd
16:26:15 <benzrf> thats a function from b to a
16:26:17 <shachaf> johnw: Cont r a isn't a Church encoding for a unless you have forall r. in front.
16:26:18 <Zekka> Yes, you've pointed that out
16:26:20 <benzrf> ok
16:26:23 <Zekka> But dimap doesn't take a function from b to a, does it?
16:26:27 <benzrf> it does
16:26:28 <benzrf> :t dimap
16:26:29 <Zekka> :t dimap
16:26:29 <lambdabot> Profunctor p => (a -> b) -> (c -> d) -> p b c -> p a d
16:26:29 <rwbarton> note also benzrf switched b and a
16:26:29 <lambdabot> Profunctor p => (a -> b) -> (c -> d) -> p b c -> p a d
16:26:42 <benzrf> well, it's a to b
16:26:43 <shachaf> In which case there's no point in using Cont. The idea of Cont r is that r isn't foralled.
16:26:44 <dagano> ok actually ... so a question about scope then : if i have f ([],ys) and f(xs,[]), the second function has no idea about ys..right?
16:26:47 <Zekka> You're using functions from b to a and c to d to get from p b c to p a d, correct?
16:26:54 <jle`> dagano: yup
16:26:55 <johnw> shachaf: ah, yes, thank you
16:26:56 <rwbarton> wait ignore me
16:26:57 <benzrf> yes
16:26:57 <Zekka> But that type uses functions from a to b and c to d to get from p b c to p a d
16:27:04 <benzrf> no, b to a
16:27:06 <benzrf> look again
16:27:08 <benzrf> dimap :: b<---o--->c => (a <- b)b<---o--->c(c -> d)
16:27:09 <jle`> dagano: the Report is a pretty readable guide to this actually
16:27:19 <Zekka> (a -> b) -> (c -> d) -> p b c -> p a d
16:27:32 <Zekka> That is the type of dimap -- it doesn't seem to include a (b -> a)
16:27:37 <benzrf> oh wait hmm
16:27:40 <Lutin`> Zekka: his b and a are switched vs that type
16:27:45 <benzrf> fuck, i miswrote
16:27:52 <benzrf> i flipped causality
16:27:53 <Zekka> Yeah, I feel like you just described bifunctors
16:27:57 <Lutin`> dimap :: a<---o--->c => (b <- a)a<---o--->c(c -> d)
16:27:58 <benzrf> no i didnt
16:28:00 <subleq> this is something like how IO works, right? http://lpaste.net/105706
16:28:08 <benzrf> Zekka: i worded it in a different causaily
16:28:11 <benzrf> *causality
16:28:13 <rwbarton> you need an arrow coming out of the thing on the left
16:28:40 <phaazon> what do you call happstack’s architecture?
16:28:42 <phaazon> MVC?
16:28:43 <benzrf> wait i did describe bifunctors
16:28:44 <benzrf> FUCK
16:28:44 <phaazon> SEDA?
16:28:47 <benzrf> Zekka: sorry ;-;
16:28:49 <Zekka> Lutin`: But doesn't that map from p a c to p b d, not p b c to p a d?
16:28:51 <phaazon> I’m quite sure it’s not MVC
16:28:57 <phaazon> there’s no shitty controllers in there
16:28:57 <benzrf> Zekka: you were right, my brain was wack
16:29:00 <phaazon> there’re
16:29:01 <Zekka> benzrf: It's fine, no worries
16:29:01 <Lutin`> Zekka: idk I just switch variables
16:29:04 <benzrf> dimap :: b<---o--->c => (a -> b)b<---o--->c(c -> d)
16:29:07 <benzrf> ok do that :p
16:29:08 <Lutin`> Zekka: no clue wtf I said lol
16:29:19 <benzrf> Zekka: anyway
16:29:20 <Zekka> Lutin`: Looked to me like another version of bifunctors
16:29:26 <Lutin`> sure why not
16:29:27 <benzrf> THAT is how i like to think of profunctors
16:29:27 <benzrf> >.>
16:29:30 <rwbarton> you probably want to draw it as b-->o-->c
16:29:31 <Zekka> But benzrf's last signature looks correct to me
16:29:37 <benzrf> rwbarton: something like that yes
16:29:39 <benzrf> derp
16:29:52 * Lutin` doesn't know what (Bi/Pro)functor is yet
16:29:56 <benzrf> it does not matter
16:30:00 <phaazon> no one ?
16:30:06 <benzrf> my weird metaphor was not particularly useful anyway >.>
16:30:15 <Zekka> It hasn't really helped my intuition that much
16:30:24 <benzrf> Zekka: in general, the Profunctor in a Prism is usually something function-like anyway
16:30:34 <benzrf> i think there's a kleisli profunctor?
16:30:36 <Zekka> When I think of a contravariant functor though I think of a function that's defined in such a way that you get contrafmap :: (a -> b) -> f b -> f a
16:30:40 <benzrf> Zekka: yeah
16:30:46 <stepcut> happstack is really a collection of libraries which you can mix and match -- but it does not strongly enforce any particular architecture. You can use it for MVC, RESTful, etc
16:30:56 <benzrf> i was not thinking >.<
16:31:00 <Zekka> benzrf: I think there is, let me find it
16:31:07 <Zekka> @src (->) dimap
16:31:08 <lambdabot> Source not found. Whoa.
16:31:14 <Zekka> Oh you're no help
16:31:17 <benzrf> :k Kleisli
16:31:18 <lambdabot> (* -> *) -> * -> * -> *
16:31:20 <rwbarton> any Arrow is a profunctor
16:31:24 <Zekka> Er, wait, that's not kleisli
16:31:32 <Zekka> that's Hask
16:31:35 <Zekka> what am I thinking
16:31:37 <benzrf> :t dimap `asAppliedTo` (Kleisli putStrLN)
16:31:38 <lambdabot>     Not in scope: ‘putStrLN’
16:31:38 <lambdabot>     Perhaps you meant one of these:
16:31:38 <lambdabot>       ‘putStrLn’ (imported from Prelude),
16:31:39 <benzrf> :t dimap `asAppliedTo` (Kleisli putStrLn)
16:31:40 <lambdabot>     Couldn't match expected type ‘a -> b’
16:31:40 <lambdabot>                 with actual type ‘Kleisli IO String ()’
16:31:40 <lambdabot>     Possible cause: ‘Kleisli’ is applied to too many arguments
16:31:43 <benzrf> dang
16:31:43 <Zekka> @src Kleisli dimap
16:31:43 <lambdabot> Source not found. My mind is going. I can feel it.
16:31:51 <benzrf> :t dimap undefined undefined `asAppliedTo` (Kleisli putStrLn)
16:31:52 <lambdabot> Kleisli IO String () -> Kleisli IO a d
16:31:54 <benzrf> sweet
16:32:15 <benzrf> Zekka: anyway, Prism Profunctors are usually gonna be function-like, similar to Kleisli
16:32:21 <benzrf> so dont worry too hard about it :u
16:32:31 <benzrf> here's the main point
16:32:42 <benzrf> let's say you wanted to define _1 so that it fit type Prism s t a b = (Choice p, Control.Applicative.Applicative f) => p a (f b) -> p s (f t)
16:32:54 <benzrf> _1 bf = dimap ? ? bf
16:33:24 <Zekka> And our first mapping looked like an s -> f t, correct?
16:33:28 <benzrf> 1 sec
16:33:39 <benzrf> i only understand this a little better than you :p
16:33:47 <benzrf> (a -> f b) -> ((a, t) -> f (b, t))
16:33:54 <benzrf> swap out the arrows for prefix p's and we get
16:34:11 <benzrf> p a (f b) -> p (a, t) (f (b, t))
16:34:30 <benzrf> so the first dimap argument must be (a, t) -> a
16:34:34 <Zekka> So, we need (a, t) -> a and f b -> (b, t)
16:34:35 <benzrf> _1 bf = dimap fst ? bf
16:34:48 <Zekka> But I don't think we can define the second one
16:34:48 <benzrf> f b -> (b, t) is not realizable though!
16:34:58 <Zekka> So _1 makes a crappy Prism
16:35:00 <benzrf> we could only get ahold of a t in the first place because we could close over the 2nd argument
16:35:17 <Zekka> On the other hand, let's do a really useless one
16:35:18 <benzrf> but that was only an option because we had the specific operations available to functions
16:35:23 <Zekka> the identity prism!
16:35:24 <benzrf> not profunctors in general
16:35:34 <benzrf> do u see what i mean
16:35:38 <Zekka> (a -> f b) -> (a -> f b) becomes p a (f b) -> p a (f b)
16:35:44 <Zekka> benzrf: Right
16:35:48 <benzrf> :-)
16:35:52 <Zekka> And let's pretend we don't want to just use id
16:36:03 <shachaf> I feel like you're making your life complicated trying to understand prisms this way.
16:36:07 <Zekka> reallyDumbPrism pf = dimap id id pf
16:36:09 <benzrf> @let _Identity = dimap id id
16:36:11 <lambdabot>  Defined.
16:36:16 <benzrf> > preview _Identity 3
16:36:18 <lambdabot>  Just 3
16:36:19 <Lutin`> I need to brush up on my ring theory
16:36:21 <benzrf> :^)
16:36:33 <Zekka> shachaf: You have any thoughts?
16:36:35 <benzrf> now the question is
16:36:39 <Lutin`> I forgot what modules were :[
16:36:40 <benzrf> how do Prisms account for failure
16:36:48 <benzrf> :t preview
16:36:49 <lambdabot> MonadReader s m => Getting (First a) s a -> m (Maybe a)
16:37:18 <benzrf> ignore the MonadReader biz and just substitute in a regular function
16:37:21 <shachaf> I'm not really following the conversation so I don't know what your goal is.
16:37:31 <benzrf> that's just so that you can use preview in any ReaderT stack
16:37:46 <Zekka> shachaf: My initial goal was to figure out how the Applicative power could give you a Traversal instead of a Lens
16:37:51 <benzrf> type Getting r s a = (a -> Const r a) -> s -> Const r s
16:38:01 <Zekka> but benzrf thought profunctors were cool and wanted to start by talking about Prisms
16:38:10 <shachaf> Zekka: Were you at my lens talk last month? I think you mentioned it in here.
16:38:14 <Zekka> (I have a feeling that this is more difficult than talking about Traversals)
16:38:19 <benzrf> =)
16:38:28 <Zekka> shachaf: I missed it although my friends made it
16:38:39 <benzrf> Getting (First a) s a => (a -> Const (First a) a) -> s -> Const (First a) s
16:39:20 <benzrf> iirc, this can always unify with Prism
16:39:25 <benzrf> as long as you have a functor constraint
16:39:35 <benzrf> take a look at it
16:40:31 <benzrf> if you use p for ->
16:40:49 <benzrf> p a (Const (First a) a) -> p s (Const (First a) s)
16:40:51 <Zekka> benzrf: I'm looking it over -- I'll agree that any Prism' should also be a Getting (First a) s a
16:41:02 <benzrf> to dimap that you need
16:41:07 <benzrf> s -> a
16:41:09 <benzrf> and
16:41:19 <benzrf> Const (First a) a -> Const (First a) s
16:41:23 <benzrf> which is just id
16:41:56 <benzrf> @src preview
16:41:56 <lambdabot> Source not found. stty: unknown mode: doofus
16:41:59 <benzrf> pfft
16:42:32 <benzrf> shit i lost my train of thought
16:42:40 <benzrf> in the midst of yak shaving my mind stack overflowed
16:42:55 <Zekka> Alright, so basically with a Traversal you're dealing with a Getting parameterized over some monoid describing the behavior for multiple targets, correct?
16:43:02 <benzrf> not quite
16:43:09 <benzrf> monoids themselves do not play into traversals
16:43:19 <benzrf> they play into the Applicative instance for Const
16:43:31 <benzrf> and Traversals require applicative in order to traverse
16:43:36 <Zekka> Const is only an Applicative if parameterized over a monoid, correct?
16:43:40 <benzrf> right
16:43:44 <Zekka> (for about the same reason (a,) is only an applicative if a is a monoid?)
16:43:47 <benzrf> ya
16:44:02 <benzrf> type Traversal s t a b = Control.Applicative.Applicative f => (a -> f b) -> s -> f t
16:44:15 <Zekka> @src (^?)
16:44:15 <lambdabot> Source not found. I can't hear you -- I'm using the scrambler.
16:44:20 <Zekka> you're just useless
16:44:23 <benzrf> src uses a static db
16:44:24 <benzrf> -.-
16:44:30 <c_wraith> Zekka: you don't want to know, anyway? :P
16:44:38 <Zekka> c_wraith: It's fun!
16:44:54 <c_wraith> Zekka: well, actually, (^?) = preview   :)
16:45:01 <benzrf> a Traversal only differs from a Lens in that f must be applicative
16:45:09 <shachaf> flip preview
16:45:12 <Zekka> c_wraith: I knew it was headOf, I didn't know it was also preview
16:45:16 <benzrf> the key point is that since it may have multiple targets
16:45:21 <Zekka> benzrf: Right, I understood that
16:45:24 <c_wraith> shachaf: sorry. :)
16:45:27 <benzrf> it needs to be able to combine em
16:45:54 <Zekka> Right, and I understand that on a high level -- it's using applicative to combine the 'effects' associated with multiple targets
16:45:57 <benzrf> with Identity, you need no monoids
16:46:04 <benzrf> because it's actually applying the functions
16:46:12 <Zekka> (I hesitate to say 'effects' because it's not a monad, but I think it's an adequate description)
16:46:50 <shachaf> "effect" seems fine.
16:46:56 <benzrf> yep
16:47:21 <benzrf> interestingly...
16:47:34 <benzrf> the notion of a Traversal overlaps with the notion of a Traversable
16:47:38 <Zekka> s ^? l is defined as getFirst (foldMapOf l (First #. Just) s)
16:47:41 <Zekka> which is a little opaque
16:47:53 <benzrf> to apply a Traversal is really to sequence the target!
16:47:58 <wjad> Is there any math/other knowledge somebody should know before they start learning Haskell?
16:48:29 <benzrf> traverse in Lens is the same traverse as in Data.Traversable
16:48:34 <Zekka> wjad: I came in knowing pretty much nothing and I think I'm pretty average in terms of Haskell proficiency
16:48:37 <benzrf> wjad: math up to functions
16:48:37 <Zekka> so you're probably fine
16:48:47 <Zekka> (think 'high school algebra')
16:49:03 <wjad> functions like f(x) = stuff here
16:49:09 <benzrf> wjad: yea
16:49:10 <wjad> alright I think I'd be fine then
16:49:11 <wjad> thanks
16:49:12 <benzrf> but in haskell, f x = stuff here
16:49:14 <Zekka> :t foldMapOf
16:49:15 <lambdabot> Profunctor p => Accessing p r s a -> p a r -> s -> r
16:49:19 <Zekka> :t foldMap
16:49:19 <benzrf> oh great
16:49:20 <lambdabot> (Monoid m, Foldable t) => (a -> m) -> t a -> m
16:49:22 <benzrf> more synonyms
16:49:29 <benzrf> my brain is pooped q.q
16:49:44 <benzrf> Zekka: if you want to talk to people who actually know their stuff without spamming up this channel
16:49:48 <benzrf> i recommend #haskell-lens
16:50:05 <Zekka> Yeah, might not be a bad idea
16:50:13 <Zekka> For what it's worth I'm operating on very little sleep at the moment
16:50:19 <benzrf> nice o:
16:50:21 <Zekka> so it's difficult for me to say whether I'm missing the obvious
16:51:35 <shachaf> "spamming the channel" is an understatement.
16:51:52 <wjad> what's lens? I see it mentioned a lot in relation to haskell
16:51:59 <Zekka> Oh, I didn't mean to be rude if I was being
16:52:00 <shachaf> This sort of conversation should've gone to #-overflow long ago.
16:52:09 <benzrf> wjad: an enormous terrifying library
16:52:15 <benzrf> shachaf: how is that different from -blah
16:52:37 <Zekka> Next time I'm being impolite let me know earlier
16:57:20 <c_wraith> benzrf: -blah says haskell is offtopic.  -overflow is about "whoops, this was on-topic, but taking over the channel"
16:58:00 <benzrf> ah
16:58:01 <c_wraith> wjad: it's a library about formalizing composable data manipulation.
17:04:08 <wjad> Because Haskell is a functional language would it make it harder to learn an object-oriented language like java after being used to functional programming? sorry if the question is stupid
17:04:19 <benzrf> wjad: yes, but vice versa
17:04:52 <benzrf> wjad: and im guessing most people here learned imperative languages before doing haskell
17:05:16 <wjad> benzrf: so it would be harder after knowing haskell? or learning an object oriented language would make learning haskell harder
17:05:52 <benzrf> wjad: both
17:05:54 <benzrf> wjad: well
17:05:57 <benzrf> maybe it wouldnt make it harder
17:06:05 <wjad> benzrf: alright thanks
17:06:06 <benzrf> but it would introduce concepts that you have to forget
17:06:34 <alevy> `cabal updating` is exiting with error code 137 all of a sudden, anybody else seeing this?
17:07:04 <alevy> it's an old version (1.16) but i can't upgrade because I can't update my local index from hackage :/
17:07:22 <benzrf> ouch!
17:07:24 <johnw> 137 is usually code for "SIGKILL", often meaning you ran out of memory
17:07:34 <benzrf> johnw: i thought 9 wa
17:07:35 <benzrf> s
17:08:28 <johnw> 128 + 9 = 137
17:08:39 <johnw> 137 is just what -9 looks like in an unsigned word8
17:08:42 <alevy> johnw, ah, might be that
17:09:00 <johnw> alevy: thank the OOM for machine not dying :)
17:09:11 <alevy> yep
17:09:31 <alevy> it's on a tiny vm, but hadn't even thought of that... makes sense
17:10:17 <alevy> i have ~300MB free before running cabal update, but i suppose it's plausible cabal is buffering the whole index file in memory or something
17:10:24 * hackagebot spoon 0.3.1 - Catch errors thrown from pure computations.  http://hackage.haskell.org/package/spoon-0.3.1 (LiyangHu)
17:10:25 <alevy> time to turn on a swap file :)
17:13:06 <alevy> johnw: that was exactly it. thanks for the pointer!!
17:13:15 <johnw> alevy: been there before too many times :)
17:16:53 <Rotaerk_Web> any ideas on ways to simplify the buildShaders and buildProgramFromSource functions?  http://lpaste.net/105708
17:17:23 <Rotaerk_Web> it *looks* monadic, though I'm not sure if it's expressable with any existing monads or not
17:23:50 <Para_> Yes! finally got it to work!!
17:24:26 <delrik> hey anyone have an example of a case expression with guards?
17:24:26 <Para_> @pl (fromIntegral (ceiling ((fromIntegral n)/(fromIntegral ff))))
17:24:27 <lambdabot> fromIntegral (ceiling (fromIntegral n / fromIntegral ff))
17:25:09 <Rotaerk_Web> delrik: the first result of https://www.google.com/search?q=case+expression+with+guards+haskell
17:25:16 <saml_> > case 1 in { a | a < 0 -> 1; a | a>=0 -> 2 } -- delrik
17:25:17 <lambdabot>  <hint>:1:8: parse error on input ‘in’
17:25:22 <marchelzo_> does @pl just get rid of unnecessary parens?
17:25:27 <saml_> > case 1 of { a | a < 0 -> 1; a | a>=0 -> 2 } -- delrik
17:25:29 <lambdabot>  2
17:25:30 <Para_> no
17:25:36 <dwcook> If I have ListT IO Foo, what do I need in order to obtain ListT IO Void? In particular I'm using pipes's ListT and would like to use runListT :: (Monad m) => LisT m Void -> m () if possible.
17:25:36 <tulcod> can the haskell ffi call C "inline" functions from a header file?
17:25:38 <Para_> it makes something pointless
17:25:41 <saml_> you guard it with |
17:26:02 <Para_> marchelzo - it removes the arguments to see if you can make the function a composition of other functions
17:26:08 <marchelzo_> Para_: pointless as in not point-free?
17:26:09 <saml_> @wiki pointfree
17:26:09 <lambdabot> http://www.haskell.org/haskellwiki/pointfree
17:26:12 <delrik> cool! thx
17:26:13 <Para_> yess
17:26:15 <Para_> exactly
17:26:16 <Rotaerk_Web> I guarded your mom with |
17:26:20 <Para_> pointless as in point-free
17:26:26 <Para_> wait not exactl
17:26:29 <Para_> pointless as in point-free
17:26:41 <saml_> ^^ marchelzo_
17:26:48 <delrik> not possible, moms not part of the Bool typeclass.
17:27:03 <delrik> :t mom
17:27:04 <lambdabot>     Not in scope: ‘mom’
17:27:05 <lambdabot>     Perhaps you meant ‘mod’ (imported from Prelude)
17:27:31 <delrik> (lets ignore that fact thats not a valid TC)
17:28:11 <saml_> i don't think Bool is typeclass
17:28:41 <marchelzo_> @pl f x = x + 1
17:28:41 <lambdabot> f = (1 +)
17:29:02 <marchelzo_> wow; that's neat.
17:29:05 <Rotaerk_Web> so no suggestions for abstractions I can use to reduce the repetition of my code :(
17:29:23 <delrik> :i Bool
17:29:35 <delrik> is it not a ADT?
17:30:40 <delrik> duh -- wrecked.  sam1 mybad
17:31:11 <saml_> buildShaders :: Failure (Int, ShaderDescription, String) f => [ShaderDescription] -> IO (f [Shader])
17:31:17 <saml_> that type is crazy Rotaerk_Web
17:31:51 <saml_> i would think  buildShaders :: ShaderSpec -> Int -> [Shaders]
17:33:52 <Para_> @pl f a b c d = a b (c d)
17:33:53 <lambdabot> f = ((.) .)
17:34:01 <Rotaerk_Web> saml_: f [Shader] can't be losslessly reduced to [Shader]
17:34:12 <Para_> @pl f a b c d = (a b) (c d)
17:34:12 <lambdabot> f = ((.) .)
17:34:16 <Rotaerk_Web> and it must be wrapped in an IO, because building shaders is a action, not a computation
17:34:20 <Para_> @pl f a b c d = a $ b (c d)
17:34:21 <lambdabot> f = (. (.)) . (.) . (.)
17:34:25 <Para_> hah
17:34:34 <dsturnbull> are you trying to get boobs?
17:34:45 <Rotaerk_Web> go to the plastic surgeon for that
17:35:02 <kini> :t (&)
17:35:03 <lambdabot> a -> (a -> b) -> b
17:35:15 <kini> where is this operator from?
17:35:18 <Para_> I was trying to get an owl
17:35:23 <Rotaerk_Web> kini: Lens
17:35:28 <Rotaerk_Web> Control.Lens.Operators IIRC
17:35:32 <kini> ah, thanks :)
17:35:44 <Para_> @unpl ((.)$(.))
17:35:44 <lambdabot> (\ b c e f -> b c (e f))
17:35:54 <Para_> wtf thats what I did!
17:36:13 <Rotaerk_Web> @pl (\ b c e f -> b c (e f))
17:36:13 <lambdabot> ((.) .)
17:36:19 <Rotaerk_Web> one's flat
17:36:37 <Para_> ah yes
17:36:46 <Para_> btw Cale - I see you! "-- Note: @pl had nothing to do with the invention of this combinator. I constructed it by hand after noticing a common pattern. -- Cale"
17:37:15 <andkore> Anyone here interested in event sourcing? I'm trying to figure out how the read store can be made "schema-less", i.e. made so that it can be changed without dealing with tables.
17:37:45 <saml_> so you have  f :: Desc -> IO Shader;   and you want g :: [Desc] -> IO [Shader]
17:37:50 <saml_> i bet there's higher order function
17:38:05 <Rotaerk_Web> saml_: what f [Shader] provides is the ability to provide a *reason* for failure, and for the caller to decide how they want to handle the failure (i.e. as a Maybe, a list, an Either, etc)
17:38:16 <saml_> @hoogle (a -> m a) -> [a] -> m [a]
17:38:18 <lambdabot> Test.QuickCheck.Arbitrary shrinkList :: (a -> [a]) -> [a] -> [[a]]
17:38:18 <lambdabot> Prelude mapM :: Monad m => (a -> m b) -> [a] -> m [b]
17:38:18 <lambdabot> Control.Monad mapM :: Monad m => (a -> m b) -> [a] -> m [b]
17:38:50 <saml_> @hoogle Failure
17:38:52 <lambdabot> Test.QuickCheck.Test Failure :: Int -> Int -> StdGen -> Int -> String -> Bool -> [(String, Int)] -> String -> Result
17:38:52 <lambdabot> Test.QuickCheck Failure :: Int -> Int -> StdGen -> Int -> String -> Bool -> [(String, Int)] -> String -> Result
17:38:52 <lambdabot> package FailureT
17:38:54 <andkore> Why is that defined in both the Prelude and Control.Monad? Interesting.
17:39:22 <Rotaerk_Web> saml_: oh, it would be simpler if I all I needed was an IO Shader, but I need IO (f Shader)
17:39:34 <saml_> exactly
17:39:39 <Rotaerk_Web> or to make it a little more concrete for simplicity-sake, IO (Maybe Shader)
17:39:52 <saml_> maybe use monad transformer to create IOWithFailure
17:40:05 <Rotaerk_Web> hmm does such a thing already exist, I wonder
17:40:06 <saml_> i don't understand Failure actually. i will be misleading
17:40:52 <saml_> Failure is your custom class?
17:41:13 <Rotaerk_Web> no, it's part of http://hackage.haskell.org/package/failure-0.1.0/docs/Control-Failure.html
17:41:30 <Rotaerk_Web> justification for it is described here:  http://www.haskell.org/haskellwiki/Failure
17:41:32 <saml_> says it's deprecated
17:41:43 <saml_> https://hackage.haskell.org/package/failure
17:42:27 <Rotaerk_Web> oh interesting; deprecated in favor of exceptions
17:42:35 <Rotaerk_Web> that must've happened in the past few months
17:42:51 <saml_> error handling is ahrd
17:43:15 <Rotaerk_Web> I'll switch to using that and see how it goes
17:43:20 <Rotaerk_Web> I wonder *why* they deprecated it
17:43:22 <Rotaerk_Web> Failure was nice
17:43:36 <Rotaerk_Web> I was just confused as to why no one seemed to know about it, given that it was promoted on the haskell site
17:43:59 <saml_> i only know Error and Either  :P
17:45:09 <Rotaerk_Web> this exceptions one (http://hackage.haskell.org/package/exceptions) looks more sophisticated
17:45:28 <Rotaerk_Web> and it seems they provide monad transformers, so that might just solve my problem
17:48:45 <streep> the naive quicksort at http://en.literateprograms.org/Quicksort_(Haskell) is a little bit slow because it makes two passes through the list when partitioning.
17:48:45 <streep> can the compiler not optimize that, or is it just so rare the compiler doesn't bother?
17:51:13 <dwcook> streep: What transformation are you expecting the compiler to apply?
17:52:47 <Welkin> there is nothing on that page
17:53:00 <dwcook> streep: By the way, you can manually make a marginal improvement by using partition.
17:53:02 <dwcook> @type partition
17:53:03 <lambdabot> (a -> Bool) -> [a] -> ([a], [a])
17:53:04 <MP2E> strange, I see the examples
17:53:39 <streep> dwcook: i don't get why the compiler can't tell that the list comprehensions are the inverse of each other
17:54:02 <marchelzo_> Welkin: the last paren probably got cut off of the url
17:54:08 <streep> and, yeah, i read the improvements that do the partition "manually"
17:54:38 <dwcook> streep: Unfortunately it's not so simple - One might define an improper instance of Ord, and then the semantics would change under the "optimization" you might be thinking of.
17:55:05 <dwcook> (I use "improper" loosely.)
17:55:44 <dwcook> Actually it can be made specific – The compiler cannot ensure that an Ord instance defines a _total_ ordering, which is what Ord is meant for.
17:56:29 <enthropy> on that topic, there is no Set.unionWith
17:57:20 <enthropy> the best alternative is to use   Map k k, and then M.unionsWith?
17:59:05 <dwcook> enthropy: Map k k? Not Map k ()?
18:00:48 <streep> dwcook: ah, right. thanks
18:00:49 <enthropy> unionsWith :: (a -> a -> a) -> [Map k a] -> [Map k a]  probably does no dirty tricks to pick the 'k' that matches the 'a' that actually ends up in the Map
18:02:10 <enthropy> this is with an ord instance that has  K 1 "diff comment" == K 1 "a comment" equal True
18:03:34 <dagano> how can i implement set difference with filter . . something like f xs ys = filter (not elem ys) xs ?
18:03:50 <dagano> do i need a map somewhere?
18:04:23 <Rarrikins> dagano: filter (not . flip elem ys) or something
18:04:27 <dwcook> dagano: It looks like you have the right idea but what you wrote is ill-typed. Perhaps you meant (not . elem ys)
18:04:44 <Rarrikins> :t elem
18:04:45 <lambdabot> Eq a => a -> [a] -> Bool
18:04:53 <dwcook> @type Data.Map.elem
18:04:54 <lambdabot> Not in scope: ‘Data.Map.elem’
18:04:55 <dwcook> Err
18:04:58 <dwcook> @type Data.Set.elem
18:04:59 <lambdabot>     Not in scope: ‘Data.Set.elem’
18:04:59 <lambdabot>     Perhaps you meant ‘Data.List.elem’ (imported from Data.List)
18:05:14 <dwcook> Either way use the flip or not depending on the parameter order
18:05:29 <dagano> dwcook: oh yeah .. i was actually pseudocoding within the () .. which was dumb
18:05:50 <dagano> :t filter
18:05:51 <lambdabot> (a -> Bool) -> [a] -> [a]
18:06:07 <dwcook> That's Prelude.filter
18:06:25 <dwcook> Oh I found it
18:06:27 <dwcook> @type S.filter
18:06:28 <lambdabot> (a -> Bool) -> S.Set a -> S.Set a
18:06:30 <dwcook> @type S.elem
18:06:31 <lambdabot>     Not in scope: ‘S.elem’
18:06:31 <lambdabot>     Perhaps you meant one of these:
18:06:31 <lambdabot>       ‘F.elem’ (imported from Data.Foldable),
18:06:35 <dwcook> Oh well
18:06:45 <dagano> ok i know where to look i think
18:07:44 <glguy> dwcook: S.member
18:07:57 <Rarrikins> @hoogle a -> Map a -> Bool
18:07:57 <Rarrikins> @hoogle a -> Map a b -> Bool
18:07:59 <lambdabot> Did you mean: a -> Map a a -> Bool
18:07:59 <lambdabot> Prelude asTypeOf :: a -> a -> a
18:07:59 <lambdabot> Prelude (<) :: Ord a => a -> a -> Bool
18:08:00 <lambdabot> Data.Map.Lazy member :: Ord k => k -> Map k a -> Bool
18:08:00 <lambdabot> Data.Map.Strict member :: Ord k => k -> Map k a -> Bool
18:08:01 <lambdabot> Data.Map.Lazy notMember :: Ord k => k -> Map k a -> Bool
18:08:56 <dagano> if i'm working with lists .. .do i need to use some fcn in Set that setifies it?
18:09:01 <dwcook> There we go. So it ends up being f xs ys = filter (not . flip member ys) xs
18:09:14 <dwcook> dagano: Not if you don't want.
18:09:16 <dagano> :t flip
18:09:17 <lambdabot> (a -> b -> c) -> b -> a -> c
18:09:31 <glguy> filter (`notMember` ys) xs
18:09:36 <dwcook> dagano: I just assumed you were working with Data.Set since you said "set".
18:09:51 <dagano> fair assumption .. i misspoke
18:10:22 <glguy> > [1..10] \\ [3..5]
18:10:23 <lambdabot>  [1,2,6,7,8,9,10]
18:10:32 <glguy> \\ is list difference
18:11:44 <dagano> thanks .. yeah i was trying to implement it. having a bit of trouble
18:19:19 <delrik> how is concat different from unlines?
18:19:46 <Welkin> look at the source
18:19:49 <Welkin> @src unlines
18:19:49 <lambdabot> unlines = concatMap (++ "\n")
18:19:53 <Welkin> @src concat
18:19:54 <lambdabot> concat = foldr (++) []
18:20:17 <Welkin> unlines adds a newline
18:20:21 <athan_> delrik: concat is a monoidal operation, unlines is mainly meant for text collections
18:21:12 <delrik> athan_: could you elaborate on the monoidal aspect?
18:22:36 <athan_> delrik: Sure, do you know what a monoid is?
18:22:58 <delrik> I'm having a hard time seeing it as something other than a binary functor
18:23:10 <athan_> delrik: It's a generic algebraic structure. Strings just happen to satisfy the spec because implicitly, they are lists
18:23:49 <jle`> er
18:24:15 <athan_> delrik: It doesn't always have to be a functor, I think. I like to see it as a domain of entities that have a single, associative operation across them (`mconcat`)
18:24:36 <jle`> um
18:24:46 <Welkin> concat is just mconcat for strings, the way I see it
18:24:48 <jle`> the operator is mappend
18:24:56 <Welkin> er, mappend
18:25:00 <athan_> S.T. forall a. b. c. <- Monoids (a <> (b <> c) == (a <> b) <> c)
18:25:03 <delrik> athan_: so is there any intuitive reason why ulines isn't defined in terms of concat istead of foldr?
18:25:17 <athan_> herp
18:25:18 <athan_> sorry
18:25:36 <Welkin> @src unlines
18:25:36 <lambdabot> unlines = concatMap (++ "\n")
18:25:37 <jle`> monoids are just things you can combine/merge/squash... like integers with (+) or booleans with (||) or lists with (++)
18:25:40 <Welkin> it is
18:25:42 <jle`> with an identity
18:25:46 <athan_> delrik: Lazyness, I'm guessing. So it can work with streams.
18:26:00 <athan_> well, actually it's doing just fine
18:27:06 <delrik> athan_: I see, so it seems I've kinda juxtaposed the scope of a generic function (in this case concat) with a more specialised version .  I think what you said about lazyness kinda puts that into perspective.
18:27:39 <delrik> scope of application *
18:28:13 <jle`> what's your question exactly?
18:28:18 <delrik> athan_: thanks =)
18:28:37 <athan_> delrik: No problem! I hope it helps haha. This stuff can be pretty abstract :)
18:28:46 <delrik> jle': I was curios why unlines wasn't defined in terms of concat.
18:28:50 <jle`> delrik: it is :)
18:28:54 <jle`> ...isn't it?
18:29:00 <delrik> :t concat
18:29:01 <lambdabot> [[a]] -> [a]
18:29:03 <delrik> :t unlines
18:29:04 <lambdabot> [String] -> String
18:29:06 <delrik> :t concatMap
18:29:07 <lambdabot> (a -> [b]) -> [a] -> [b]
18:29:24 <jle`> @src concatMap
18:29:24 <lambdabot> concatMap f = foldr ((++) . f) []
18:29:29 <jle`> oh
18:29:44 <delrik> yeah, so i was a bit confused.
18:29:52 <jle`> i do'nt think there's any real difference between a concat implementation and a concatMap implementation
18:30:15 <jle`> both work wiht laziness the same way
18:30:21 <delrik> @src concat
18:30:21 <lambdabot> concat = foldr (++) []
18:30:31 <delrik> lo and behold =)
18:30:48 <jle`> i mean, in practice
18:31:00 <delrik> I felt the concatMap did an extra round of abstraction and I'm kinda not seeing why.
18:31:25 <delrik> sorry, unlines.
18:31:34 <delrik> @src unlines
18:31:34 <lambdabot> unlines = concatMap (++ "\n")
18:31:52 <delrik> well, actually. I kinda do now =)
18:32:00 <delrik> its much less code.
18:32:09 <jle`> ah
18:32:40 <delrik> and it goes inline w/ leveraging existing abstractions to yeild smaller more powerful functions, and its pointfree.
18:33:03 <jle`> i wonder if ghc optimizes both to the same thing
18:33:17 <delrik> maybe thats a function written more for GHC's happiness and not mine.
18:34:28 <delrik> @src foldr
18:34:28 <lambdabot> foldr f z []     = z
18:34:29 <lambdabot> foldr f z (x:xs) = f x (foldr f z xs)
18:36:12 <delrik> does the fact that foldr has to be unwound to retrieve a value make it succeptible to issues w/ stack frames? I'm still not too clear on how optimisation works at the tail end , nor am I too keen on how GHC's optimisations come into play in that arena.
18:36:50 <jle`> stack frames and tail end stuff isn't quite relevant in ghc's evaluation
18:37:07 <Para_> So I'm a beginner -- does anybody have ideas for simple stuff that I should program in Haskell, just to help me learn?
18:37:18 <Para_> I was doing Project Euler, but that's been hacked, so I'm kinda not sure what to do now
18:37:48 <jle`> Para_: have you been programming before?
18:38:04 <Para_> Yes
18:38:10 <Para_> I'm fairly competent with Python
18:38:20 <Para_> I just don't know what would be good practice with haskell
18:38:43 <PhineasRex> Para_: What kind of things have you programmed in python?
18:38:53 <silasm> Para_: compression was fun for me. I'd imagine encryption would be a good experience too if you're interested in that.
18:39:16 <Para_> silasm - I started haskell two days ago, am I ready for that already?
18:39:18 <Para_> and Phineas -
18:39:40 <Para_> an app that unwarps a picture based on a perspectivity mapping was my latest project
18:39:50 <Para_> but I've also been doing Linear regressions on many many timeseries
18:39:52 <Para_> and that type of thing
18:39:56 <silasm> Para_: depending on the algorithm you choose, it's not that bad. Though you might want to be ready to use monads beforehand.
18:40:09 <Para_> (PhineasRex)
18:40:46 <Para_> Uhm I wrote a pathfinding algorithm at some point (The RRT, was trying to do RRT* but I moved on to other things before I got a chance to complete it
18:40:47 <Para_> )
18:40:54 <Para_> (In addition to above)
18:41:20 <Para_> silasm Yeah I should probably get used to those before - I've heard about them being mentioned around here
18:41:34 <Para_> but I haven't done anything with them at all
18:41:45 <delrik> foldr (+) 0 [1..]
18:41:57 <jle`> Para_: have you read through LYAH, etc. ?
18:42:02 <delrik> so i ran that in my ghc after we started talking jle`, I got an overflow.
18:42:14 <jle`> delrik: not because of the call stack
18:42:22 <jle`> but because of unevaluated thunks
18:42:27 <delrik> interesting!
18:42:29 <silasm> Para_: I learned the state (and then ST when I wanted performance) monads along with lazy IO (though I'd personally recommend pipes/conduit instead) with LZ78 compression and found it easier than you might think.
18:42:58 <Para_> jle`, I'm reading through it now, but I was doing small stuff on the side to practice what I had read
18:43:08 <Para_> which is what I was sorta asking for
18:43:14 <jle`> there actually is no traditional "call stack" in haskell because of the way evaluation works :)  there are stack frames used in the underlying implementation and runtime system but they don't quite map directly to recursive functions and tail calls like in other languages
18:43:17 <delrik> so why'd it say stack overflow? doesnt that imply something to do w/ the call stack?
18:43:23 <Para_> and silasm - Okay, thanks. Is that in LYAH?
18:43:27 <silasm> compression is actually pretty nice because other than the input/output it's essentially a pure operation, but at the same time it really motivates haskell abstractions for managing state.
18:43:50 <jle`> Para_: how about a hangman game?
18:43:50 <silasm> @where pipes
18:43:50 <lambdabot> http://hackage.haskell.org/package/pipes
18:43:59 <Para_> just kidding, it is :)
18:44:06 <Para_> and alright, that sounds interesting!
18:44:25 <silasm> don't be afraid to ask for help though
18:44:36 <Para_> jle`, I have to think about how to do that functionally! That's a good example!
18:44:40 <silasm> I should mention I'd had /some/ experience beforehand.
18:45:01 <Para_> and silasm - that sounds good, I'll keep that in mind for when I finish LYAH or when I get to the monads section
18:45:05 <jle`> Para_: it's a good project I think because as you advance in haskell at every stage you'll approach the problem in a completely different way
18:45:18 <jle`> so it'd be nice to compare how you'd write one now
18:45:19 <silasm> Para_: yeah that's probably a good way to do it.
18:45:21 <Para_> I can keep rewriting it!
18:45:21 <jle`> and how you'd write one in two months
18:45:26 <Para_> yeah!
18:46:06 <Para_> while we're here though
18:46:21 <Para_> would someone mind critiquing the latest program that I wrote? (for style and idiomatic stuff and general stuff in general)
18:46:56 <Para_> http://lpaste.net/105710
18:47:04 <Welkin> @src foldr1
18:47:04 <lambdabot> foldr1 _ [x]    = x
18:47:04 <lambdabot> foldr1 f (x:xs) = f x (foldr1 f xs)
18:47:04 <lambdabot> foldr1 _ []     = undefined
18:47:05 <Para_> I know I have excess brackets in some places
18:47:13 <delrik> @src splitAt
18:47:13 <lambdabot> splitAt n xs           =  (take n xs, drop n xs)
18:47:26 <Welkin> > foldr1 (+) [1..5]
18:47:28 <lambdabot>  15
18:47:45 <jhance> Para_: don't break 80 cols, its hard to read long lines - separate them logically
18:48:00 <Para_> how can you break lines?
18:48:08 <Para_> like in the middle of function composition?
18:48:12 <jle`> you can move (.)'s
18:48:22 <jle`> foo = bar
18:48:25 <jle`>     . baz
18:48:31 <Para_> gotcha
18:48:31 <jle`>     $ x
18:49:03 <Welkin> so, another way to abuse $
18:49:09 <jhance> And remember that haskell is not lisp - don't write where ff = (first_factor n startAt)
18:49:17 <jhance> just ff = first_fac... will do
18:49:41 <Para_> so should I do ff = first_fac... on a separate line?
18:49:50 <Para_> wait no
18:49:51 <jhance> you have it on a separate line alwready
18:49:54 <Para_> I won't be able to do it
18:50:01 <jhance> I'm just saying you don't need parens
18:50:02 <Para_> I meant, independent of the declaration
18:50:04 <jle`> i usually put where definitions on the line after the where
18:50:08 <Para_> ohhh ok ok
18:50:32 <Para_> actually -- I think the parens are there because I was doing fromIntegral of that
18:50:34 <Para_> haha
18:50:41 <Para_> but alright, thanks
18:50:56 <jhance> then you would normally write fromIntegral $ ... rather than fromIntegral (...)
18:51:14 <dsturnbull> you could use $ to clarify a lot of that
18:51:15 <Para_> Okay
18:51:25 <Para_> Wait - let me re-write it
18:51:27 <jle`> i am a fan of parentheses but a lot of people use ($)
18:51:28 <Para_> to see if the style is better
18:51:37 <dsturnbull> but i think you could also break out a lot of functions to be defined in 'where'
18:52:16 <jhance> $ is nice because if you have complex expressions you have to right ... $ ... as (...) (...) and the two sets of parantheses leaves a bad aftertaste
18:52:45 <jhance> write* facepalms
18:53:23 <jle`> Para_: try max ff . flip greatest_prime_factor ff . fromIntegral . ceiling $ fromIntegral n / fromIntegral ff
18:53:29 <dsturnbull> heh, the lpaste.net site itself wanrs about redundant parens
18:53:51 <jle`> Para_: the main advantage isn't the lack of parentheses but rather the compositional style
18:54:28 <Para_> woah wait a second
18:54:50 <jle`> or even: max ff . flip greatest_prime_factor ff . fromIntegral . ceiling . (fromIntegral n /) . fromIntegral $ ff
18:54:59 <jle`> where you eventually drop the ($) is sort of up to you/personal style
18:55:06 <Para_> I can compose with a fraction?
18:55:11 <jle`> hm?
18:55:32 <Para_> also, why am I doing max ff . flip
18:55:46 <Para_> I'm not too clear on that
18:55:57 <jle`> function application binds first
18:56:08 <jle`> so that's (max ff) . (flip great_prime_factor ff) . ...
18:56:25 <Para_> ohhhhhhh
18:56:38 <jle`> the main advantage is that you can see the whole thing as compositions of functions, so you can "break it out"
18:56:39 <jle`> if you want
18:56:47 <Para_> like into different lines?
18:56:51 <jle`> into variables
18:56:59 <jle`> er, names
18:57:05 <jle`> let's say you find that fromIntegral . ceiling is useful
18:57:09 <delrik> jle`: you beast, I found the page on the haskell wiki =) dope.
18:57:12 <jle`> then you can say fic = fromIntegral . ceiling
18:57:14 <xpika> can someone tell me what use applicatives serve for the maybe data type?
18:57:15 <dagano> if i import qualified Data.Array as A .. can i get at Data.Array.ST just with A.ST ?
18:57:18 <Para_> ohhh
18:57:19 <jle`> max ff . flip greatest_prime_factor ff . fic . (fromIntegral n /) . fromIntegral $ ff
18:57:21 <Para_> makes code clearer
18:57:31 <jle`> you can just pull things out easily
18:57:56 <jle`> like lexically/text-ily
18:58:12 <jle`> if you think something like f.g.h is useful to name, you can just pull it out and drop it in
18:58:13 <Para_> I have to be especially careful to compose functions with two params though, don't I?
18:58:20 <Para_> wait never mind
18:58:22 <Para_> I see whats happening
18:58:23 <csabahruska> hi
18:58:28 <jle`> it's partial appication/currying
18:58:29 <Para_> wow that's cool
18:58:30 <jle`> hi csabahruska :)
18:59:14 <jle`> Para_: the take-home is that if you have something like f . g . h . i . j $ x, you can say "hey, h . i . j is useful on its own", and see that it's f . g . (h . i . j) $ x, and name it something like hij = h . i . j in f . g . hig $ x
18:59:22 <jle`> *hij
18:59:39 <jle`> you can't do that if you have f (g (h (i (j x))))
18:59:54 <jle`> and you can't do that if you had done f $ g $ h $ i $ j x
18:59:54 <csabahruska> Does TypeNats have Typeable instances?
18:59:57 <jle`> like a lot of enw people do
18:59:58 <Para_> being able to write it like that though takes quite a bit of practice I'm guessing - does it just come naturally as you write more code, or do you have to consciously say like "hmm how can I do this?"
19:00:33 <silasm> Para_: once you understand (.) it comes pretty naturally in my experience.
19:00:38 <pqmodn> @pl \x -> f (g (h (i (j x))))
19:00:38 <lambdabot> f . g . h . i . j
19:00:52 <Para_> I'm still not too clear on what exactly $ does
19:01:03 <jhance> @type ($)
19:01:04 <lambdabot> (a -> b) -> a -> b
19:01:08 <benzrf> @src ($)
19:01:08 <lambdabot> f $ x = f x
19:01:22 <silasm> $ is just function application with lowest precedence.
19:01:26 <jhance> Its just function applicaton.
19:01:41 <Para_> ah, so it lowers the precedence of a function application
19:01:47 <Para_> so you can compose functions first
19:01:55 <dsturnbull> i think of it like | in a shell
19:01:58 <Para_> before they are applied
19:02:02 <jle`> Para_: you get used to it...you basically start seeing things as function composition
19:02:12 <jle`> everyhting you do is just a series of function compositions
19:02:16 <jhance> function application is normally highest precedence, but $ is lowest, so its very useful
19:02:23 <jle`> i don't really think foo (bar (baz x))
19:02:37 <jle`> that is
19:02:39 <silasm> dsturnbull: I usually think of | as more analogous to (.) or (>>=) though...
19:02:54 <jle`> i don't think "foo applied to the application of bar to the application of baz to x"
19:02:55 <Maxdamantus> $ is also right-associative while normal function application is left-.
19:03:02 <jhance> | really has nothing to do with $
19:03:10 <jle`> instead, i think of it as "(foo . bar . baz) applied to x"
19:03:39 <jle`> shifting your mindset to that might help
19:04:03 <jle`> delrik: what page? :)
19:04:13 <Maxdamantus> > (+5) $ (*2) $ 3
19:04:14 <lambdabot>  11
19:04:15 <Para_> I'm trying to shift my thinking to that :)
19:04:20 <Maxdamantus> > (+5) (*2) 3
19:04:22 <lambdabot>  No instance for (GHC.Show.Show a0)
19:04:22 <lambdabot>    arising from a use of ‘M83519993501493654058856.show_M83519993501493654058...
19:04:22 <lambdabot>  The type variable ‘a0’ is ambiguous
19:04:22 <lambdabot>  Note: there are several potential instances:
19:04:22 <lambdabot>    instance [safe] GHC.Show.Show
19:04:25 <delrik> jle`:http://www.haskell.org/haskellwiki/Stack_overflow
19:04:28 <jle`> ah
19:04:36 <delrik> hiding in broad daylight lol
19:04:40 <jle`> haha yeah
19:05:02 <jle`> this is one of the many situations where i say that knowing another programming language before learning haskell actually hurts you rather than helps you
19:05:19 <Para_> what was the function for input again?
19:05:23 <Para_> takeLn?
19:05:39 <silasm> :t getLn
19:05:40 <lambdabot> Not in scope: ‘getLn’
19:05:40 <Para_> and yeah jle` - I'm not used to it at all
19:05:40 <jle`> getLine takes a line from stdin
19:05:46 <Maxdamantus> getLine
19:06:01 <silasm> whoops, what they said. I was just using it like 5 minutes ago...
19:06:03 <Para_> but I'm sorta trying to think of it sorta how I think in math classes
19:06:42 <jle`> that's a good way to look at it ;)
19:07:02 <delrik> I think it makes it all the more interesting.  I've been in Fail city ever since picking up haskell, and I'm loving it.
19:07:15 <Para_> yeah - just mappings!
19:08:41 <jhance> the best part is how hard it becomes to use other languages...
19:08:52 <Para_> uhoh
19:08:57 <Para_> this doesn't HELP with other languages?
19:09:11 <Para_> oh well
19:09:14 <jhance> For me, it makes me constantly wonder why theres no good Maybe type in other languages
19:09:24 <Para_> what does Maybe do again?
19:09:35 <jhance> @src Maybe
19:09:35 <lambdabot> data Maybe a = Nothing | Just a
19:09:35 <Para_> is it like error handling?
19:09:41 <silasm> jhance: Java has an option type now. Guess what? It too is nullable.
19:09:44 <rien> Para_: captures the idea that there might not be a value
19:09:55 <Para_> ah
19:09:55 <jhance> silasm: Just wonderful...
19:10:02 <rien> it enriches whatever type you give it with a new element: Nothing
19:10:25 <rien> but for that it needs to wrap all the elements of your type with Just
19:10:30 <Para_> I mean in python you can do the try: do_something_with_possibly_empty_list
19:10:39 <silasm> I literally ragequitted a channel the other day in a debate on option types vs. nullable pointers...
19:10:40 <Para_> except IndexError: handle_empty_list_case
19:10:44 <Para_> but its not super clean
19:10:54 <Welkin> @src Failure
19:10:54 <lambdabot> Source not found. I've seen penguins that can type better than that.
19:11:03 <rien> silasm: lol there's a defense for nullable pointers?
19:11:23 <silasm> rien: yes, it's called ignorance ;).
19:11:32 <jhance> it makes sense in non-garbage collected languages only
19:11:47 <Welkin> ignorance and religion are rampant in the programming world
19:11:47 <delrik> lolol
19:11:48 <jhance> not sure why Java chose to inherit that philosophy
19:12:34 <rien> you say that as if they planned for it to come out that way :)
19:12:41 <silasm> jhance: well they were complaining about it in rust. What does garbage collection have to do with it?
19:12:46 <jhance> its actually significantly harder to deal with nulls in imperative languages simply because you don't have the guarantee that it actually gets a value like you do in a functional language
19:13:16 <jhance> silasm: Well, if you have to do memory allocation by hand, theres nothing stopping me from int *ptr = (* ptr) 0; even if NULL doesn't exist
19:13:40 <jhance> I meant int * not * ptr in that cast
19:13:45 <silasm> jhance: ah.
19:14:07 <rien> jhance: I don't think that's right
19:14:29 <jhance> The problem with imperative languages is alot of them don't consider ifs as expressions
19:15:04 <rien> jhance: you could have a language where you need to do o = Object.new... and then to kill it you would do o.destroy, and you are now doing manual memory mgmt without the possibility of a null pointer?
19:15:27 <jhance> rien: Okay, then I should say not hand-forced memory management
19:15:31 <rien> I guess the null pointer would be "o" after doing "o.destroy"?
19:15:35 <jhance> rien: Ie, a language you could actually write a kernel in
19:15:37 <rien> I'm not sure I'm right :)
19:16:12 <jhance> Since like, even though its possible to use C++ to write a kernel, you have to define new/delete to use those operators. Otherwise you are stuck with defining your own function, ie kmalloc
19:16:29 <rien> jhance: you could achieve that (ie lack of runtime) with linear programming, which I know very little of
19:16:44 <jhance> The other problem with imperativev languages is that most of the older ones haven't realized that ifs are expressions
19:16:49 <rien> I mean, lack of runtime and no need for manual memory mgmt
19:17:02 <jhance> So instead of x = if c then a else b becomes if c then x = a else x = b
19:17:22 <rien> hmm that's a good point.
19:17:22 <jhance> And the compiler can't prove that some exception doesn't get thrown during the calculation of a or b, so x has to have some value before all of that
19:17:24 <benzrf> kmalloc?
19:17:35 <jhance> benzrf: Linux kernel-level malloc
19:17:41 <benzrf> o
19:18:33 <rien> can anyone offer their opinion on pattern calculus?
19:19:32 <Para_> question: If I have a string "3", how can I convert it to a number?
19:19:43 <benzrf> Para_: you could use read
19:19:44 <jhance> @src Read
19:19:44 <lambdabot> class Read a where
19:19:44 <lambdabot>   readsPrec    :: Int -> ReadS a
19:19:44 <lambdabot>   readList     :: ReadS [a]
19:19:44 <lambdabot>   readPrec     :: ReadPrec a
19:19:44 <lambdabot>   readListPrec :: ReadPrec [a]
19:19:46 <benzrf> why do you have such a string?
19:19:48 <Para_> or a string 53 too (so it occupies two spaces)
19:19:50 <jhance> okay that was really bad
19:19:51 <rien> Para_: read
19:19:54 <jhance> @type read
19:19:55 <lambdabot> Read a => String -> a
19:20:24 <Para_> okay :)
19:20:35 <Welkin> Para_, have you read Learn You A Haskell?
19:20:46 <Welkin> that is covered within the first few chapters
19:21:31 <Para_> I'm reading it now
19:21:33 <Welkin> it has lots of useful information like that
19:21:43 <Para_> I'm just trying to write a hangman program now
19:21:53 <Para_> so I can compare it to what I write in a month or two
19:22:54 <uniquenick> zwer_w, are you still around?  it turns out the size of a ProcessEntry32 on my machine is 296 just like th32SnapEnumProcesses has hardcoded
19:35:22 <benzrf> dang, what's the use of (~) in constraints
19:35:25 <benzrf> :k (~)
19:35:26 <lambdabot> k -> k -> Constraint
19:35:42 <benzrf> :k (=>)
19:35:42 <lambdabot> parse error on input ‘=>’
19:35:56 <benzrf> (=>) :: Constraint -> k -> k
19:36:25 <pavonia> type equivalence/unification
19:36:35 <benzrf> oh/
19:36:37 <benzrf> * oh?
19:36:45 <benzrf> how is that useful
19:36:55 <benzrf> why have (a ~ Foo) => a instead of Foo
19:37:10 <pavonia> You need it somethimes with type families when the compiler can't prove equality
19:37:17 <benzrf> hmmmmmmmmmm
19:38:40 <enthropy> if you have type family Foo a, you can't write   instance Eq (Foo a), but you can write instance Foo a ~ b => Eq b
19:39:56 <benzrf> -.-
19:40:01 <enthropy> or if it's in a type,    f :: (x ~ A Really Long Type) => x -> x
19:40:21 <enthropy> that one behaves like type x = A Really Long Type
19:40:46 <enthropy> I mean a type signature for a function
19:52:08 <uniquenick> can anyone help me figure out how to get listing processes on windows working?  http://lpaste.net/105697
19:54:51 <dmj`> uniquenick: what library are you using?
19:55:28 <benzrf> i need to sleep now
19:55:36 <dmj`> uniquenick: Win32 it seems..
19:55:38 <benzrf> bye
19:55:39 <uniquenick> System.Win32.Process
19:57:04 <lostman> does anyone have experience setting up haskell on nix? I'm running into problems with any library that depends c libraries. here's zlib for instance: 'zlib-0.5.4.1 ... <command line>: can't load .so/.DLL for: libz.so'
19:58:49 <dmj`> uniquenick: let me try really quick
19:59:19 <ab9rf> uniquenick: that appears to be a bug in the library
20:00:05 <ab9rf> uniquenick: that error means that the swSize member of the PROCESSENTRY32 was not properly set, causing winapi to reject the call
20:00:20 <ab9rf> uniquenick: contact the System.Win32.Process API maintainer
20:00:39 <ab9rf> er s/swSize/dwSize/
20:00:56 <uniquenick> it looks like it is being set though, it is doing a pokeByteOff with the size
20:01:43 <uniquenick> the size is hard coded to 296, but I checked and that's the right size on my machine at least
20:04:03 <dmj`> uniquenick: it worked fine for me, I have a list of the processes
20:04:27 <ab9rf> uniquenick: which version of windows are you trying this on?
20:04:55 <uniquenick> windows 7
20:05:45 <dmj`> uniquenick: I'm on server 2008. Can you try to escalate the privileges on your executable? Like right click and "Run as administrator"
20:06:18 <uniquenick> same error
20:06:28 <dmj`> what ghc version
20:06:38 <uniquenick> 7.6.3
20:06:39 <ab9rf> dmj`: even unescalated it should produce a constrained list
20:06:50 <ab9rf> i'm guessing that there's an alignment issue, but dunno
20:07:40 <dmj`> yea, I'm running unprivileged and it works fine on 7.8.2
20:08:50 <uniquenick> hmm, what happened to the haskell platform's twice a year releases?
20:09:40 <Para_> quick confirmation question: function application is left to right
20:09:42 <Para_> correct?
20:09:51 <Para_> :t f a b c
20:09:52 <lambdabot> FromExpr t => t
20:09:59 <Para_> agh
20:11:18 <dmj`> uniquenick: there are prebuilt binaries for windows
20:12:42 <jle`> Para_: f a b c is parsed as ((f a) b) c
20:12:50 <jle`> if that's what you're asking
20:13:31 <Para_> yep
20:13:32 <Para_> thanks
20:22:39 <newsham> whats the haskell extension called that lets you bring all of a struct arg's elements into scope?
20:22:53 <newsham> f Struct(...) = stuffhere    or something like that
20:23:39 <dmj`> RecordWildCards
20:24:00 <newsham> ty
20:25:39 <Para_> wait LYAH says that left folds do not work on infinite lists but right folds do... how can you call foldr on an infinite list? Where does it start?
20:26:00 <shachaf> At the beginning.
20:26:16 <zwer_w> uniquenick, in the earlier versions of Win32 package that function uses 556 as size of the ProcessEntry32 and that works in here. with 296 I get the same error as you, even though gcc that ships with haskell platform says 296 bytes for that structure. go figure.
20:26:33 <Hafydd> x1 `f` (x2 `f` (x3 `f` ...
20:27:43 <Hafydd> In foldr f z, `f` takes the place of :, and z takes the place of [].
20:28:33 <Para_> hm ok
20:28:51 <PhineasRex> Is it possible to pattern match against ListLike?
20:34:21 <uniquenick> zwer_w, 556 it is!  thanks
20:36:56 <enthropy> PhineasRex: there is http://www.haskell.org/ghc/docs/7.8.2/html/users_guide/type-class-extensions.html#idp23957616 but I don't think you can get a parameter from a multiparameter typeclass into a type family
20:37:30 <zwer_w> uniquenick, it worked for you as well?
20:37:47 <enthropy> instance ListLike xs x => IsList xs where type Item xs = ???
20:37:48 <uniquenick> yep
20:37:59 <PhineasRex> Hrm.
20:38:01 <enthropy> you can do all the specific cases though
20:38:14 <PhineasRex> I think I might just use view patterns.
20:38:36 <enthropy> you can put view patterns behind pattern synonyms
20:38:56 <PhineasRex> I did not know that.
20:38:59 <nisstyre> enthropy: would XMonadComprehensions conflict with polymorphic list literals?
20:38:59 <PhineasRex> Thanks.
20:39:57 <enthropy> nisstyre: you have a suspicion they do?
20:40:28 <nisstyre> enthropy: I guess it depends if you can do list comprehensions with them
20:40:33 <nisstyre> enthropy: maybe you could merge them though
20:43:23 <enthropy> shouldn't  " [ () | _ <- [1] ] :: (Num a, Monad m, IsList (m a)) => m ()" be a sensible interaction between the two?
20:43:51 <rwbarton> I think they are just unrelated, yeah. list/monad comprehensions have the |
20:45:51 <jle`> why does \_ -> always look so much better than const
20:46:12 <jle`> i guess with const you don't need the parentheses
20:46:25 <jle`> in certain situations
20:47:08 <chrisdone> what's a handy way to pass a to f :: a -> a -> a -> () where the number of -> is arbitrary but the a's are contiguous?
20:47:43 <pqmodn> not sure, but Text.Printf does something like that i think
20:47:49 <chrisdone> yup
20:48:19 <pqmodn> does f have a finite arity?
20:48:51 <chrisdone> no, the arity is arbitrary
20:49:15 <enthropy> "does pass a" mean like  \a -> f a a a a?
20:49:19 <chrisdone> but all the arguments will be the same type
20:49:22 <chrisdone> yeah
20:50:02 <orzo> hi
20:50:25 <pqmodn> maybe a type class, one instance for () which is the base case and one for (a -> b)?
20:50:36 <Rotaerk_Web> hmm I've been running into all sorts of error handling mechanisms ... so confused
20:51:18 <orzo> i'm wondering if this idea is already implemented elsewhere, http://jerkface.net/~joe/ParallelBranching.html
20:51:56 <orzo> the idea i'm refering to is more so the PMonad class than it is the AsyncM which is simply a demonstration
20:52:36 <orzo> sorry for the lack of documentation, but 'pif' is supposed to be a version of if that runs both branches simultaneously
20:52:40 <Rotaerk_Web> Control.Failure is deprecated, and says to use the "exceptions" package instead.  Control.Monad.Error is deprecated, and says to use Control.Monad.Except from the mtl package.  and there's also a control.monad-exception package
20:52:45 <Rotaerk_Web> what should I use !?
20:52:59 <Rotaerk_Web> control.monad.exception *
20:53:25 <Rotaerk_Web> I don't even want impure exceptions; just an abstraction of pure error-reporting (which encompasses Maybe, Either, etc)
20:55:34 <Rotaerk_Web> hmm the mtl package has a huge number of downloads; guess I'll use that
20:56:04 <chrisdone> http://hackage.haskell.org/package/resourcet-0.4.10/docs/Control-Monad-Trans-Resource-Internal.html#t:MonadThrow
20:56:07 <EvanR> i thought mtl was built in now
20:56:37 <Rotaerk_Web> chrisdone: great, another one :P
20:57:15 <Rotaerk_Web> EvanR: maybe it is; dunno.  I hadn't heard of it til now, but it looks pretty standard
20:57:34 <enthropy> chrisdone: I have a bad solution http://lpaste.net/105722
20:58:04 <enthropy> hmm, or maybe I'm wrong
20:58:08 <chrisdone> Rotaerk_Web: technically resourcet now uses the exceptions package
20:58:14 <chrisdone> Rotaerk_Web: http://hackage.haskell.org/package/resourcet-1.1.2.2/docs/Control-Monad-Trans-Resource.html#t:MonadThrow
20:58:16 <enthropy> nevermind
20:58:26 <chrisdone> rotaerk_web: so i'd recommend using that
20:58:49 <chrisdone> enthropy: hmm
20:59:06 <chrisdone> enthropy: ideally you want
20:59:23 <chrisdone> f (printf "%d%d%d" :: Int -> Int -> Int -> String) 1
20:59:36 <chrisdone> where 1 will be passed three times to printf
21:00:37 <Rotaerk_Web> hmm thanks
21:01:46 <Rotaerk_Web> though what surprises me is that you had to pull up some package to show me what to use; it just seems to me like this is ubiquitous need that the community would already have a consensus for
21:01:58 <levi> Heh.
21:02:01 <chrisdone> nope, it's undecided
21:02:50 <EvanR> use ContT !
21:02:56 <levi> If you don't need *exceptions*, there's http://hackage.haskell.org/package/errors
21:03:45 <levi> It's worth studying anyway, as it's sort of a gathering of error-management conventions that tend to crop up in various places.
21:04:28 <EvanR> i havent needed pure exceptions (exceptino maybe or either) up to this point, so maybe not an ubiquitous need
21:06:28 <levi> You have to deal with exceptions to make robust programs that do IO, but current style tends to keep them out at the impure edges of the program and use explicit Maybe/Either error handling in pure code.
21:07:19 <levi> You may be able to pawn the exception handling stuff off on already-robust IO libraries, too.
21:07:37 <enthropy> chrisdone: http://lpaste.net/105722
21:07:51 <enthropy> works without the (1::Int) annotation
21:08:45 <EvanR> im liking Control.Error
21:10:05 <Rotaerk_Web> levi: it seems to me to be ideal never to use maybe/either for reporting failures, but to use an abstraction that clarifies the intent
21:10:17 <Rotaerk_Web> a Nothing doesn't necessarily mean a "failure"/"error"
21:10:39 <Rotaerk_Web> also, if you use an abstraction, it allows the caller to make it whichever concrete type suits their needs
21:12:10 <EvanR> if only picking brand new types that clarifies the intent doesnt make you lose all compatibility with everyone elses code, like using Nat instead of Int for non negative numbers
21:13:51 <EvanR> but a lot of libraries export a Either-like thing specifically for that, Ok a or Error b
21:14:02 <EvanR> and a convert to either ;)
21:14:11 <Rotaerk_Web> in this case, the abstraction is a typeclass
21:14:21 <Rotaerk_Web> not another isomorphic ADT
21:14:29 <EvanR> and if theres 40 such type classes to choose from...
21:14:36 <Rotaerk_Web> well that's the status quo :P
21:14:39 <EvanR> its just like if you had 40 types isomorphic to Either
21:14:39 <Rotaerk_Web> hence my dilemma
21:15:02 <EvanR> what we need is a master type class class for error type classes
21:15:06 <EvanR> or two
21:15:24 <EvanR> to clarify intent
21:16:39 <EvanR> its pretty conventional for Left to be an error and Right to be success, KISS ;)
21:17:01 <chrisdone> enthropy: hmm i can't get it to work
21:17:16 <chrisdone> enthropy: f (\() -> ()) ()
21:17:22 <chrisdone> enthropy: should this work?
21:17:24 <levi> Rotaerk_Web: You can use 'type' to provide an alias for Either or Maybe, to clarify intent, but using those types for it is pretty well-established.
21:18:05 <Rotaerk_Web> what if you have some functions which report failure via Either, and others which report it via Maybe, and you want to monadically chain them
21:18:24 <levi> Rotaerk_Web: You apparently didn't look at the `errors` package I showed you very closely. :)
21:18:30 <EvanR> heh yeah
21:18:31 <EvanR> http://hackage.haskell.org/package/errors-1.4.7/docs/Control-Error-Util.html
21:18:38 <EvanR> hush, note
21:18:52 <chrisdone> enthropy: i get:                           Couldn't match type `b -> c' with `()' … When using functional dependencies to combine CD (a -> b -> c) (a -> r), …
21:19:06 <chrisdone> for: f ((\() -> ()) :: () -> ()) ()
21:19:19 * chrisdone wonders if this is a job for type families
21:19:48 <Rotaerk_Web> I see
21:19:50 <enthropy> right it works for   f (\() () -> () ) () ()
21:19:53 <Rotaerk_Web> hmm thanks
21:20:23 <levi> Using those cleaned up a lot of tricky logic in my code.
21:20:24 <enthropy> or I dunno
21:20:27 <chrisdone> enthropy: so then that's just normal printf
21:20:32 <enthropy> maybe the result type has to be different?
21:20:39 <chrisdone> hm
21:21:00 <enthropy> sorry, f ( \ () () -> () ) () :: () -- works
21:21:16 <chrisdone> doesn't work here. what GHC version?
21:21:17 <enthropy> it is too dumb to know it can't add any more arguments
21:21:38 * chrisdone checks his extensions
21:21:56 <enthropy> chrisdone: you have a type signature for the result?
21:22:08 <chrisdone> demo = f ( \ () () -> () ) () :: ()
21:22:20 <chrisdone> Couldn't match type `()' with `() -> ()' …
21:22:42 <chrisdone> i'm on ghc 7.6.2 here
21:23:00 <chrisdone> loading: http://lpaste.net/4153626970329972736
21:23:30 <enthropy> interesting, ghc-7.8 is happy with that fundep, but ghc-7.6 only works if you remove it
21:23:45 <chrisdone> :{
21:23:59 <enthropy> well no fundep works with ghc-7.8 too
21:26:31 <chrisdone> hmm it might do the trick, lemmie try
21:26:55 <enthropy> it should be possible to get this to work without needing the result type specified
21:28:33 <Rotaerk_Web> hmm k, I'll just go for simplicity and use Either/Maybe plus the errors package
21:28:54 <Rotaerk_Web> does make sense to do so given that *other* people's code will be using those types
21:30:23 <EvanR> that package reexports Safe which is great for avoiding errors ;)
21:31:02 <EvanR> hrm though it also adds brand new ways to crash
21:33:07 <chrisdone> enthropy: i don't see a way presently
21:35:19 <levi> EvanR: Which brand new ways to crash?
21:36:09 <EvanR> lookupJust, at, and the Def versions which simply let you use a string with error
21:36:19 <EvanR> things like that
21:36:30 <EvanR> abort
21:37:27 <EvanR> very "safe" ;)
21:43:48 <levi> So you get some unsafe things as well as success monads in `errors`.
21:44:55 <EvanR> they may not be reexported from safe, it says "partial functions are not reexported from other libraries"
21:45:59 * hackagebot warp 3.0.0.2 - A fast, light-weight web server for WAI applications.  http://hackage.haskell.org/package/warp-3.0.0.2 (MichaelSnoyman)
21:47:40 <enthropy> chrisdone: http://lpaste.net/105722
21:47:48 <enthropy> no result type annotation needed
21:49:26 <chrisdone> enthropy: oh lawdy
21:51:23 <chrisdone> enthropy: in my case the result type is concretely determined so your first simpler solution is maybe better
21:53:30 <chrisdone> hmm
21:55:26 <chrisdone> enthropy: i'm gonna get a nap, thanks for the ideas. it seems hard to make this function cleanly
21:56:19 <chrisdone> i want to be able to write apply (format (month % "/" % year)) date
21:56:19 <chrisdone> instead of format (month % "/" % year) date date
21:57:25 <chrisdone> except i would make it available like format ("Date: " % apply (month % "/" % year)) date
21:57:26 <chrisdone> or w/e
21:57:48 <chrisdone> ( referring to https://github.com/chrisdone/formatting#monday-1st-june-dates--times )
22:01:28 <chrisdone> otherwise right now you can do: format ("Date: " % later (\x -> bprint (month % "/" % year) x x)) date
22:01:29 <chrisdone> but i thought auto-collapsing that later (\x -> bprint …  x x) into apply … would be convenient
22:01:53 * chrisdone -> bed
22:06:02 * hackagebot authenticate-oauth 1.5 - Library to authenticate with OAuth for Haskell web applications.  http://hackage.haskell.org/package/authenticate-oauth-1.5 (MichaelSnoyman)
22:23:25 <snyp> Are type constructors, functions?
22:24:47 <snyp> umm no.. sorry i was a bit confused
22:25:05 <ski> type constructors can be type functions
22:25:28 <ski> e.g. `Maybe',`Either',`[]',`IO',`IORef' are type functions
22:25:30 <snyp> Why does Maybe have the kind * -> * ?
22:25:34 <snyp> What is 'applying' ?
22:25:40 <ski> while `Int',`Bool',`Char' are not type functions
22:26:07 <ski> well, perhaps it's better to first consider the case of the type constructor `[]'
22:26:24 <snyp> is applying like 'fixed' like cartesian coordinates ?
22:26:39 <snyp> (9, 1, x) is not fixed. But (9, 1, 2) is fixed
22:26:42 <ski> `[Foo]' is syntactic sugar for `[] Foo', so applying the type constructor `[]' to `Foo'
22:26:57 <ski> `[] Integer' is the type of "lists of integers"
22:26:57 <snyp> ski, hmm..
22:27:10 <ski> `[] Char' is the type of "lists of characters"
22:27:10 <snyp> ok
22:27:19 <ski> so `[]' could be thought of as "lists of"
22:27:23 <ski> lists of what ?
22:27:27 <ski> we haven't decided yet
22:27:41 <snyp> so not fixed
22:27:54 <ski> applying the type function `[]' to the type `Foo' means that we decide to have lists of `Foo's
22:28:02 <snyp> ah
22:28:37 <ski> now, possible values of type `Maybe Integer' are : `Nothing', and also `Just n', for any `Integer' `n'
22:28:54 <ski> possible values of `Maybe Bool' are : `Nothing', `Just False', `Just True'
22:29:00 <snyp> ya
22:29:08 <snyp> i think i sort of get it now
22:29:11 <snyp> thanks
22:29:20 <ski> we can think of `Maybe Bool' as "maybe a boolean", and of `Maybe Integer' as "maybe an integer"
22:29:31 <ski> so `Maybe' there is "maybe a ...", which is again incomplete
22:29:40 <snyp> yeah.
22:29:50 <ski> we haven't decided yet what the type of the maybe present value should be
22:30:46 <ski> so type functions like `[]',`Maybe',`Either',`IO',`IORef' are all incomplete, they're missing some extra type that we need to specify to make the combined type expression "whole"/complete : i.e. to specify an actual possible type of some value
22:30:54 <ski> i.e. a *concrete* type
22:31:08 <ski> concrete types have "kind" `*'
22:31:11 <ski> @kind Integer
22:31:12 <lambdabot> *
22:31:14 <ski> @kind Bool
22:31:15 <lambdabot> *
22:31:17 <ski> @kind Maybe Bool
22:31:18 <lambdabot> *
22:31:22 <ski> @kind [] Integer
22:31:23 <lambdabot> *
22:31:29 <ski> but incomplete types have other kinds
22:31:31 <snyp> @king Maybe
22:31:32 <lambdabot> Maybe you meant: ping kind
22:31:38 <snyp> @kind Maybe
22:31:39 <lambdabot> * -> *
22:31:40 <ski> @kind []
22:31:42 <lambdabot> * -> *
22:31:49 <snyp> hmmmmmmmm
22:31:50 <ski> @kind Either String Integer
22:31:51 <lambdabot> *
22:31:52 <ski> @kind Either String
22:31:53 <lambdabot> * -> *
22:31:53 <ski> @kind Either
22:31:54 <lambdabot> * -> * -> *
22:32:21 <Rotaerk_Web> hmm is it better to return an  IO (Either Foo Bar)  or an  EitherT Foo IO Bar
22:32:38 <ski> the `->' in the kind means that we have a type function, that expects us to specify some extra (here concrete) type, before possibly we have specified a concrete type
22:32:46 <Rotaerk_Web> it's *easier* to return the former; I have to explicitly prefix it with "EitherT" to get the latter
22:32:50 <snyp> ski, ah, that is why Functor instance for Either is 'instance Functor (Either a)' while for Maybe it's 'instance Functor Maybe' as Functor takes * -> * kinds
22:33:08 <snyp> Either requires 2 types to get fixed
22:33:14 <snyp> ski, i get it
22:33:20 <snyp> thanks a lot
22:33:20 <pavonia> Rotaerk_Web: It depends if you want you function to be a monadic combinator or not
22:33:25 <ski> the kind for `Either' has two `*'s to the left of two `->'s, so it expects us to prove two concrete types, before we have specified a full concrete type using `Either' -- such as `Either String Integer'
22:33:30 <Rotaerk_Web> hmm k
22:33:34 <snyp> mhm
22:33:37 <ski> snyp : yes, exactly
22:34:22 <ski> Rotaerk_Web : it depends on whether uses of it will prefer to see the one or the other
22:34:42 <Rotaerk_Web> yea I guess it's easy to convert back and forth
22:40:12 <l0cust> So
22:40:14 <l0cust> question
22:40:59 <l0cust> I have this source code - http://lpaste.net/105728
22:42:00 <l0cust> I would like to get things wrapped in the RouteT monad
22:42:15 <l0cust> inside Blaze's Monad
22:42:20 <l0cust> How do I do that?
22:43:19 <l0cust> My current method is to pass the unwrapped values as arguments
22:43:23 <l0cust> but that seems bad
22:43:45 <l0cust> or rather, verbose
22:47:11 <brrrrrrian> How can I find this function: (a -> b) -> Vector a -> [b]
22:47:28 <jle`> brrrrrrian: is that just map and toList ?
22:48:11 <brrrrrrian> jle`: yup
22:48:57 <brrrrrrian> jle`: so... Vector.map maps a function over the Vector producing a new Vector... and then I turn it into a list
22:49:09 <brrrrrrian> jle`: is there any way to avoid creating the intermediate vector?
22:49:17 <ski> @type \f -> map f . Data.Vector.toList
22:49:18 <lambdabot> (a -> b) -> Data.Vector.Vector a -> [b]
22:49:27 <ski> @type \f -> Data.Vector.toList . Data.Vector.map f
22:49:28 <lambdabot> (a1 -> a) -> Data.Vector.Vector a1 -> [a]
22:49:57 <ski> (the first one is `map' on lists)
22:51:04 <Lutin`> brrrrrrian: Vector is pretty good at fusion
22:51:33 <Lutin`> I wouldn't be surprised if it fuses that into one loop
22:52:17 <brrrrrrian> i have heard about fusion before, and tried to google, but i haven't found anything that explains basic fusion
22:52:39 <brrrrrrian> is there a standard reference for understanding fusion from the basics?
22:57:59 <kazagistar> brrrrrrian: the main thing to remember is that lists, if you use them right, dont actually exist. If you chain list operations, and have both the source and sink be a non-list, then they simple represent a stream of computation
22:59:15 <brrrrrrian> so what is a good resource to work through to build this intuition?
23:01:42 <levi> http://homepages.inf.ed.ac.uk/wadler/topics/deforestation.html
23:02:52 <pjdelport> brrrrrrian: The most simple example is the transformation of "map f . map g $ xs" into "map (f . g) $ xs"
23:03:24 <pjdelport> There, you can talk about "fusing" f and g together.
23:04:26 <brrrrrrian> how do you carry that forward into '.. and have both the source and sink be a non-list, then they simple represent a stream of computation'?
23:06:50 <pjdelport> brrrrrrian: That's an extension of the same idea. In the same way that fusion can avoid the unnecessary construction and deconstruction of intermediate lists, if you fuse a list generator and consumer together, you can avoid having an actual list entirely.
23:06:57 <pjdelport> And end up with just a loop.
23:08:54 <ski>   forall cons,nil.
23:08:59 <ski>     foldr cons nil (build (\cons nil -> ..cons..nil..))  =  ..cons..nil..
23:09:14 <brrrrrrian> map f . map g $ xs --> 'map g' is generator, 'map f' is consumer... so fuse f and g together...?
23:09:32 <ski> well, i suppose one can express it more formally like
23:09:44 <ski>   forall c,n,body.
23:09:56 <ski>     foldr c n (build body)  = body c n
23:10:04 <ski> brrrrrrian : that one is quite useful
23:10:05 <pjdelport> brrrrrrian: Well, in that case, something else is generating the source list xs, and something else is consuming the final list.
23:10:07 <ski> @type foldr
23:10:08 <lambdabot> (a -> b -> b) -> b -> [a] -> b
23:10:12 <ski> @type GHC.Base.build
23:10:13 <lambdabot> (forall b. (a -> b -> b) -> b -> b) -> [a]
23:10:29 <ski>   build body = body (:) []
23:10:51 <pjdelport> brrrrrrian: A better example would be something like: sum . map f . map g $ [1..10]
23:11:05 <ski> using the above law, we can avoid creating the intermediate list (that `build' would build, and which `foldr' would then take apart)
23:12:54 <jle`> map (+3) $ map (*2) [1,2,3]
23:12:56 <jle`> @src map
23:12:56 <lambdabot> map _ []     = []
23:12:56 <lambdabot> map f (x:xs) = f x : map f xs
23:13:00 <jle`> so that turns into
23:13:23 <jle`> map (+3) $ 2 : map (*2) [2,3]
23:13:25 <jle`> which turns into
23:13:39 <jle`> 5 : map (+3) (map (*2) [2,3])
23:13:43 <jle`> see, no intermediate lists
23:13:57 <ski> that's not quite what fusion is about
23:14:01 <Rotaerk_Web> hmm bimapEitherT lets me map both the left and right... is there something pre-existing that allows mapping just one
23:14:08 <Rotaerk_Web> i.e. just the left, in my case
23:14:14 <pjdelport> brrrrrrian: There, you can fuse not only f and g together, but the sum with the list enumeration, to end up with just a recursive loop, and no actual list.
23:14:34 <ski> jle` : those `:'s are intermediate, even if the whole intermediate list doesn't all exist at a single point in time
23:16:13 <jle`> ah i see
23:16:24 <jle`> so is fusion on the compiler step then?
23:16:38 <pjdelport> Yes.
23:16:54 * ski doesn't understand the question
23:17:26 <jle`> fusion happens at compile-time?
23:17:41 <brrrrrrian> so a consumer e.g. [a] -> a basically turns into a tight loop.. and hopefully any intermediate 'work' done in the consumer will fuse all the intermediate lists..?
23:17:49 <Rotaerk_Web> like maybe a mapLeftT or something
23:17:55 <Rotaerk_Web> hoogle doesn't even know about EitherT
23:19:27 <brrrrrrian> great, this is elegant
23:19:38 <brrrrrrian> fields :: (a -> b) -> V.Vector a -> [b]
23:19:44 <brrrrrrian> fields f v = map (\e -> f e) (V.toList v)
23:20:35 <pjdelport> brrrrrrian: Yeah. It's not completely magic, of course: in libraries, you'll usually see "is subject to fusion" for functions which fusion rules have been implemented.
23:20:51 <ski> jle` : yes
23:21:34 <pjdelport> For GHC, the things that list fusion are implemented for are listed here: https://www.haskell.org/ghc/docs/latest/html/users_guide/rewrite-rules.html#idp25473760
23:22:06 <ski> brrrrrrian : a consumer together with a producer (and possibly intermediate consumers-producers) will turn into a single loop -- at least assuming they are "good" list producers and "good list consumers
23:22:36 <ReinH> jle`: sup
23:22:42 <jle`> hi ReinH
23:23:02 <ReinH> jle`: I'm finally getting back into edmp a bit
23:23:03 <brrrrrrian> besides memorizing the fusion rewrite rules, is there any way to tell whether something fuses?
23:23:18 <brrrrrrian> for example, you have some complex piece of code that you can't fully inspect
23:23:23 <ski> brrrrrrian : perhaps look at Core ?
23:23:28 <pjdelport> dump the compiled core code, and check :)
23:23:33 <jle`> ReinH: i don't feel like i have the context to understand that
23:23:33 <ReinH> hmm, I just realized you probably aren't the same jle from that channel so never mind
23:23:47 <jle`> yeah there's another one floating around there
23:23:53 <jle`> i feel bad sometimes
23:23:57 <ReinH> jle`: heh
23:24:01 <jle`> but what can i do
23:24:09 <jle`> tell him i said sorry :)
23:24:13 <brrrrrrian> and from Core you can see whether lists truely 'exist' instead of being transformed into some tight loop?
23:24:57 <ski> if you're able to decipher the nest, yes
23:26:07 <pjdelport> brrrrrrian: Right.
23:26:07 <brrrrrrian> is it possible to get this information at run-time and somehow tell whether something is fused?
23:26:16 * hackagebot monadIO 0.10.1.4 - Overloading of concurrency variables  http://hackage.haskell.org/package/monadIO-0.10.1.4 (TrevorElliott)
23:26:18 * hackagebot orc 1.2.1.4 - Orchestration-style co-ordination EDSL  http://hackage.haskell.org/package/orc-1.2.1.4 (TrevorElliott)
23:26:55 <ski> the information probably isn't there at run-time
23:27:27 <brrrrrrian> man.. haskell is so great.. and referential transparency..
23:27:45 <brrrrrrian> i dont even know a fraction of it.. and it's so great already
23:27:55 <ski> hehe :)
23:28:16 <wollw> heh
23:28:30 * wollw just wishes he could use Haskell for his 16 bit MCU projects :\
23:28:30 <pjdelport> brrrrrrian: If you want a more expansive example, see this discussion: http://www.reddit.com/r/programming/comments/2h0j2/real_quicksort_in_haskell/c2h196
23:28:50 * wollw will settle for writing his simulator in Haskell.
23:29:50 <brrrrrrian> wollw: i started writing a PIC simulator to get a better understanding of State
23:30:02 <pjdelport> brrrrrrian: That takes a tree sort (which works by simply building and then flattening a binary search tree), and fuses (or deforests) it into a recursion which doesn't use an actual tree at all.
23:30:14 <wollw> cool
23:30:28 <brrrrrrian> wollw: would you use State? curious how you'd go about it
23:30:29 * wollw is working on a simulator for some sculpture stuff he's working on using MSP430s
23:30:40 <wollw> No idea, I don't mean a simulator in the traditional sense.
23:30:56 <wollw> This will be more OpenGL and graphs
23:30:57 <pjdelport> brrrrrrian: The fusion / deforestation is completely mechanical, and can in general be done for any data type that has a catamorphism and anamorphism.
23:31:22 <pjdelport> (foldr and unfoldr are the catamorphism and anamorphism for lists)
23:31:31 <brrrrrrian> pjdelport: mindasplode
23:33:28 * ski . o O ( hylomorphism )
23:33:40 <pjdelport> brrrrrrian: In general, there's a certain duality between any algebraic data structure and functional recursions that follow the same pattern.
23:34:24 <pjdelport> You can transform the data into a recursion, and vice versa.
23:35:15 <pjdelport> In the case of lists, [] corresponds to loops that terminate: that's why you'll sometimes see Haskell lists referred to as "reified loops".
23:35:29 <brrrrrrian> pjdelport: i am failing to see the tree structure here..
23:36:22 <brrrrrrian> pjdelport: a naive qsort creates a 'tree' of intermediate lists..?
23:38:29 <pjdelport> brrrrrrian: Not quicksort. The real point of that discussion thread is that the function that the Haskell example that's usually called quicksort actually isn't quicksort at all, but a deforested treesort.
23:41:17 * hackagebot wai-routing 0.9.1 - Declarative routing for WAI.  http://hackage.haskell.org/package/wai-routing-0.9.1 (ToralfWittner)
23:44:59 <brrrrrrian> catamorphism : fold / anamorphism : unfold
23:45:12 <brrrrrrian> not so scary anymore
23:45:50 <Rotaerk_Web> yay, collapsed my failable IO staircase
23:51:07 <pjdelport> brrrrrrian: http://lpaste.net/105729
23:51:33 <pjdelport> Does that make the tree structure clearer?
23:52:01 <begriffs> Does anyone have an example of a simple web server written with Warp 3?
23:53:59 <d3m1g0d-> trying to make my own DataList.and function implementation
23:54:07 <d3m1g0d-> and' :: (Bool a) => [a] -> a
23:54:08 <d3m1g0d-> fails ?
23:54:39 <pjdelport> d3m1g0d-: Can you paste your code on http://lpaste.net/new/haskell ?
23:54:59 <pavonia> Bool is not a type class but a type
23:55:13 <d3m1g0d-> http://lpaste.net/105730
23:55:43 <d3m1g0d-> ok, back to typeclasses
23:56:10 <pavonia> :t and
23:56:11 <lambdabot> [Bool] -> Bool
