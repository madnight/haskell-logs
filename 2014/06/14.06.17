00:01:27 <brrrrrrian> pjdelport: i think i see whats going on
00:01:47 <taruti> Is OverloadedRecordFields merged to HEAD?
00:02:28 <brrrrrrian> time for rest. thanks for your help tonight
00:03:04 <pjdelport> brrrrrrian: Cool. :)
00:03:47 <pjdelport> demolithion: Where do you get (Bool a) from? Did you write a Bool typeclass?
00:03:53 <pjdelport> err, d3m1g0d- -^
00:05:15 <pjdelport> d3m1g0d-: Your type signature should probably just be and' :: [Bool] -> Bool ?
00:05:30 <pjdelport> and' :: (Bool a) => [a] -> a means a very different thing
00:09:25 <frerich> Is there a name for the set of functions which can be defined using folds? I seem to recall some book referring to them as 'primitive recursive' functions but AFAIK the definition of primitive recursive recursive functions lacks the "One element at a time" part, e.g. a function consuming two elements at a time may well be primitive recursive but cannot be implemented using a fold -- does that sound right?
00:09:54 * hackagebot orc 1.2.1.4 - Orchestration-style co-ordination EDSL  http://hackage.haskell.org/package/orc-1.2.1.4 (TrevorElliott)
00:09:54 * hackagebot wai-routing 0.9.1 - Declarative routing for WAI.  http://hackage.haskell.org/package/wai-routing-0.9.1 (ToralfWittner)
00:30:21 <Scarlett21>  Hi! I give you some videos. I hope you like! http://j.mp/1lApOhD
00:44:47 <danilo2> Hello! Does somebody know how can I add additional contributor to the list of contributors on hackage in a library, where I'm the only contributor for now ?
00:49:01 <Qfwfq> Using a GHC pragma, can I attach a warning to a typeclass instance?
00:50:27 <dottedmag> danilo2: try #hackage
00:51:40 <danilo2> dottedmag: Exactly right now I found the solution - you can do this via the hackage website - under the package, there is a "maintainer corner", where you can log in and change the contributor list :)
00:51:44 <danilo2> dottedmag: thanks :)
00:54:56 * hackagebot algebraic 0.1.0.2 - General linear algebra structures.  http://hackage.haskell.org/package/algebraic-0.1.0.2 (Korri)
00:58:37 <matematikaadit> >let i = id; love = (<3); you = 1
00:58:44 <matematikaadit> > let i = id; love = (<3); you = 1
00:58:45 <lambdabot>  not an expression: ‘let i = id; love = (<3); you = 1’
00:59:03 <matematikaadit> > let i = id; love = (<3); you = 1 in i love you
00:59:05 <lambdabot>  True
01:11:00 <gamegoblin> :t mapM
01:11:56 <gamegoblin> Where is lambdabot :(
01:15:17 <gamegoblin> > 1+1
01:25:48 --- mode: asimov.freenode.net set +o ChanServ
01:26:35 * hackagebot pi-calculus 0.0.5 - Applied pi-calculus interpreter  http://hackage.haskell.org/package/pi-calculus-0.0.5 (renzyq19)
01:31:20 <levi> syllogismos: Check out ghc-vis
01:31:30 <osa1> anyone here has experience with jmacro? I'm trying to define something like [jmacro| fun args { `body` } |] but fun will be dynamically generated list. any ideas how to do that? as far as I can see I can't unquote something at that position.
01:33:41 <syllogismos_> levi: sorry internet got disconnected..
01:44:47 --- mode: asimov.freenode.net set +o ChanServ
02:04:38 <pepper_chico> guys, what's adviced or a good path for web programming in haskell? I'm learning it and reading some books/training material now first
02:05:13 <pepper_chico> afterwards I plan to put it in practice for some web related task
02:05:19 <JKup> so this is the mecca
02:06:01 <Kinnison> .win 73
02:06:11 <JKup> I have a question
02:07:04 <JKup> What are the best steps to take to get into server administration
02:07:29 <pepper_chico> right now I'm not even sure haskell can be nice for web
02:08:08 <jle`> pepper_chico: i use it for my blog
02:09:09 <pepper_chico> jle`, do you find it nice for the task, do you recommend a web framework?
02:10:01 <jle`> pepper_chico: what is your experience with web?
02:10:06 * hackagebot filelock 0.1.0.1 - Portable interface to file locking (flock / LockFileEx)  http://hackage.haskell.org/package/filelock-0.1.0.1 (AkioTakano)
02:10:44 <pepper_chico> jle`, not much, some js, server side go programming, general rest, http
02:11:44 <pepper_chico> (go == golang)
02:12:31 <jle`> pepper_chico: web probably isn't a good first or second haskell project, but it'd be a fun third or fourth :)
02:12:41 <jle`> it was my second project though and i had a lot of fun with it
02:12:45 <jle`> but
02:12:54 <jle`> there was a fair deal of frustration
02:13:48 <jle`> i think haskell is good for web :)
02:13:54 <jle`> it has a lot to offer
02:14:04 <jle`> such as strong type safety and high, compiled performance
02:14:39 <pepper_chico> =S, I know I'll find a trivial/easy path if I keep going with golang for that, but, I'd like to learn and try haskell for that. My only concern is whether the tooling for web stuff is actually good, or subpar
02:15:01 <jle`> client-wise, there are a lot of mature web frameworks
02:15:05 <jle`> er, server-wise
02:15:22 <jle`> yesod, snap, scotty, happstack ...
02:15:28 <jle`> there was a reddit post comparing them a few days ago i think
02:16:11 <JKup> -a fudge it -d
02:16:12 <pepper_chico> hmm, I've taken a short look at them already, although at this stage, I can really judge much
02:16:39 <pepper_chico> but there was one that was really strange
02:16:51 <pepper_chico> let's see if I find the link
02:17:07 <jle`> pepper_chico: in summary, i think there are a lot that haskell brings to the table for web and i would probably pick it for future web projects i do...but it's not the best way to get into haskell fast or learn haskell immediately
02:17:16 <jle`> it's different in that sense from ruby etc.
02:20:49 <pepper_chico> ah yes, I think I'm going with the books & exercises first before entering the haskell for the web world
02:21:10 <pepper_chico> ah, this was the weird one I had seen https://www.fpcomplete.com/school/to-infinity-and-beyond/older-but-still-interesting/MFlowDSL1
02:29:04 <darthdeus> ReinH: hey, I have a question about the latest haskellcast :)
02:30:11 <darthdeus> ReinH: in the soundcloud version here http://www.haskellcast.com/episode/007-chris-done-on-compiling-to-javascript-and-sql/ at around 56:04 chrisdone says "ideally i would be using ****, and everybody would be using ****" ... what is that word? I can't understand or find it
02:30:14 <darthdeus> sounds like "landu"?
02:33:04 <mmmm> @q lambdabot @pl
02:33:04 <lambdabot> Maybe you meant: queue-topic quit quote v @ ? .
02:33:32 <vhz> darthdeus: lamdu probably ? http://peaker.github.io/lamdu/
02:33:59 <darthdeus> vhz: oh awesome, tanks :)
02:36:44 <remdezx> Hello! I posted my question on #ghc, but I know here are haskell magicans too! I'm building an interpreter of some DSL over ghc-api. I need to interpret some haskell method call, let it be my_fun(b), where b is not showable. "GHC.runStmt" requires statement to be a string, but I cannot use "show" on the "b" result. Is it possible to pass a value to a statement some other way with ghc-api?
02:40:58 <danilo2> Hello! Is it possible somehow (even using some magic tricks) to write function with a signature of "IO [Int] -> [IO Int]" ?
02:41:25 <danilo2> Ok, the answer is no. We cannot determine its length
02:41:50 <jle`> danilo2: hm
02:41:54 <jle`> you can write a function with that signature
02:41:57 <jle`> without even cheating/using magic
02:42:12 <jle`> or anything unsafe
02:42:34 <danilo2> jle`: Ok, but that function would not be useful I think, or am I wrong?
02:42:43 <jle`> :P
02:42:49 <danilo2> jle`: heh :)
02:42:57 <jle`> f = const [] :: IO [Int] -> [IO Int]
02:43:06 <darthdeus> lol
02:45:23 <yitz> danilo2: if lhs is IO a for any a and rhs is not, the only way you'll get there (besides what jle` said, or _|_) is unsafePerformIO
02:46:06 <jle`> map return . unsafePerformIO
02:46:19 <yitz> there you go
02:46:25 <jle`> but that's probably also not what you want
02:46:49 <jle`> what would you want IO [Int] -> [IO Int] to even do?
02:47:16 <jle`> be able to "split up" the evaluation of each part of the list?
02:48:15 <danilo2> yitz, jle`: You are right - I was looking for solution to a broader problem and I limited it to this simple one - but of course it both usless as well impossible to do work well - it just shows me, that something is broken in my bigger problem :)
02:48:50 <yitz> remdezx: what statement do you want to run? if you know, why can't you build a string that represents it?
02:49:29 <pjdelport> danilo2: What's the broader problem?
02:50:31 <danilo2> pjdelport: I think I have to think about it. Thank you for your attention! :) If I do not come to a conclusion in a moment I will describe it :)
02:51:38 <remdezx> yitz: I need to run statement like "my_fun(b)" where b doesn't derive Show. This is why I cannot build a string that represent it.
02:52:11 <remdezx> yitz: "b" could be also an infinite list, problem is still the same.
02:55:08 <kazagistar> :t pure . fmap sum :: IO [Int] -> [IO Int]
02:55:09 <lambdabot> IO [Int] -> [IO Int]
02:55:48 <jle`> kazagistar: :)
02:56:14 <kazagistar> clearly not what is meant, but it works, so ha
02:56:45 <BoR0>  /query lambdabot
02:56:48 <BoR0> woops
02:56:52 <danilo2> kazagistar: heh :D
02:56:54 <jle`> kazagistar: it's more useful than mine :P
02:57:55 <BoR0> :D
02:57:56 <danilo2> jle`: You are right! I think we could even make a contest - who is able to write most usefull function with that signature :P
02:58:27 <kazagistar> somehow, I suspect we wont get far
02:58:39 <jle`> perhaps fmap length instead of fmap sum
02:59:25 <jle`> oh maybe const [getEpochTime]
02:59:30 <jle`> so it tells you the time :)
02:59:34 <Guest75667> what's the problem with this ? let deep f (x a b) = [f (x a b), (x (f a) b)]
02:59:53 <jle`> Guest75667: what is x a b ?
03:00:00 <jle`> a function application?
03:00:25 <Guest75667> (x a b) is a tree, f is a function
03:00:31 <jle`> a tree?
03:00:41 <Guest75667> like (Add 2 3)
03:01:04 <jle`> ah. you can't pattern match to bind the constructor itself...
03:01:12 <jle`> because how would you know how many arguments it takes?
03:01:28 <Guest75667> well... two ?
03:01:32 <Guest75667> a and b..
03:01:37 <jle`> but there could be another constructor that only takes 1
03:01:44 <jle`> and also
03:01:47 <jle`> er
03:01:50 <jle`> more importantly
03:01:51 <jle`> how would you know the type?
03:02:07 <jle`> data Expr = IntLit Int | CharLit Char
03:02:19 <jle`> foo f (y x) = f x
03:02:21 <Guest75667> well, haskell isnt supposed to be as general as possible when defining types ?
03:02:26 <jle`> what would the type of that be?
03:02:29 <jle`> what would the type of f be?
03:02:44 <Guest75667> but i get it, i guess
03:02:51 <jle`> because you'd want y to be either IntLit or CharLit
03:02:56 <jle`> x can be Int or Char
03:03:07 <jle`> and f has to somehow take both Int or Char
03:03:17 <pjdelport> Guest75667: Your function would have to be: deep f tree = ...
03:03:20 <jle`> s/both/either
03:03:53 <frerich> Guest75567: An arguably more mundane issue with 'let deep f (x a b)' is that in order to use pattern matching ("x a b") you'd use a data constructor, but "x" is not a data constructor because it's a lowercase character.
03:04:11 <Guest75667> pjdelport, yes, but I'm trying to figure out how I can apply transformations of a tree deep into its nodes instead of just the top level
03:04:30 <pjdelport> Guest75667: Recursion, generally.
03:04:33 <kazagistar> frerich: right, but it could be a variable that "stores" the data constructor, if the language permitted such a thing
03:04:51 <jle`> and we're showing why it'd be nonsensical to do so :)
03:04:59 <kazagistar> indeed
03:05:20 <kazagistar> at least, in a statically compiled language
03:05:37 <kazagistar> with principal types
03:05:44 <frerich> I *think* this is an XY problem really.
03:05:46 <pjdelport> Guest75667: The general approach to this is to write a fold for your tree: that lets you target any specific node type with a transformation function.
03:05:48 <Guest75667> and how do you define recursion in this case ? I was thinking about exposing parts of the tree, you know.. get some fundamental forms
03:06:03 <pjdelport> Guest75667: Can you paste your data type declaration so far?
03:06:37 <pjdelport> Guest75667: To give you an idea, the canonical fold for lists is foldr
03:06:38 <pjdelport> :t foldr
03:06:39 <lambdabot> (a -> b -> b) -> b -> [a] -> b
03:07:13 <pjdelport> Guest75667: You can interpret the first and second arguments to foldr as giving replacements for each of []'s constructors.
03:07:16 <Guest75667> this is what i have for now : http://pastebin.com/JeDkCpRX
03:07:41 <pjdelport> which means that "foldr (:) []" is the identity function for lists: it just replaces each constructor with itself
03:08:00 <pjdelport> Similarly, maybe is the fold for Maybe
03:08:02 <pjdelport> :t maybe
03:08:03 <lambdabot> b -> (a -> b) -> Maybe a -> b
03:08:11 <kazagistar> :t fold
03:08:12 <lambdabot> (Monoid m, Foldable t) => t m -> m
03:08:23 <pjdelport> and "maybe Nothing Just" is the identity fold for Maybes
03:08:36 <kazagistar> :t foldMap
03:08:37 <lambdabot> (Monoid m, Foldable t) => (a -> m) -> t a -> m
03:08:48 <kazagistar> :t foldrMap
03:08:49 <lambdabot>     Not in scope: ‘foldrMap’
03:08:49 <lambdabot>     Perhaps you meant one of these:
03:08:49 <lambdabot>       ‘foldMap’ (imported from Data.Foldable),
03:08:53 <pjdelport> Well, I say "fold", but I actually mean "catamorphism", to be more technical.
03:08:54 <kazagistar> eh
03:09:08 <pjdelport> That's distinct from the more generic Foldable and such.
03:10:41 <Guest75667> you have something i can read about folds ? i'm new to haskell. I think maybe I get it for lists
03:10:47 <frerich> Guest75667: There is some discussion about folding trees at http://www.haskell.org/haskellwiki/Fold#Tree-like_folds
03:10:49 <Guest75667> but that's not the case yet on trees
03:11:23 <remdezx> Is it possible to share objects with ghc session? maybe I could make some IORefs available both for my program runtime, and for for further ghc-api calls?
03:14:39 <yitz> Guest75667: ok looks pretty good so far. now what is this "deep" you are trying to write?
03:14:46 <yitz> what is it supposed to do?
03:15:25 <danilo2> Hello! Is it possbile in haskell to write some overlapping instances in such way, that typechecker would reject some of them if some predicates are not met?
03:15:44 <yitz> (it's so inefficient as to be impractical, but it makes sense, so worry about efficiency later...)
03:18:28 <yitz> danilo2: not in any simple way. perhaps you could use type families, type equality constraints,... why do want to do that?
03:21:15 <danilo2> yitz: I really need it for some deep magic. If you want, I can explain better the reasons, but it would take some time. Anyway, I want to reject instance if for example the constrain "Num a" is not met - do you have any idea how can we do it ?
03:23:05 <yitz> danilo2: no, not in any simple way, unless Num a is a superclass.
03:23:49 <danilo2> yitz: superclass? Coudl you elaborate on it a little more?
03:24:32 <tulcod> why has the hsc2hs hackage package not been updated since 2012? judging from git, there are new releases
03:24:36 <pjdelport> Guest75667: http://lpaste.net/105731
03:24:49 <yitz> danilo2: if the class is defined as class Num a => Foo a where ... then an instance will be rejected unless the type is an instance of Num.
03:25:11 <yitz> danilo2: that doesn't have anything to do with overlapping instances.
03:25:15 <pjdelport> Guest75667: That's a generic catamorphism / fold for your Exp type.
03:25:49 <pjdelport> You can see it takes three arguments: a replacement for each constructor, and then applies them, recursing where necessary.
03:25:51 <danilo2> yitz: ah, ok so it is not related to the problem - but thank you, now I know the term "superclass" in Haskell meaning
03:26:58 <pjdelport> Guest75667: You can define a catamorphism like that for any ADT; in this case, I called it "evalExp" because that's a natural interpretation for an expression tree.
03:27:00 <tulcod> oh, right, hsc2hs is part of ghc now...
03:27:40 <pjdelport> Guest75667: In the examples, you can see how passing the same constructors back in is just the identity transformation, but by varying how each node is interpreted, you can express many kinds of transformations.
03:27:54 <pjdelport> I gave examples for evaluating a whole tree, and replacing one node type.
03:28:03 <pjdelport> Guest75667: Does that help?
03:29:20 <pjdelport> Guest75667: If you want to know more about the theory of this, the canonical reference is "Functional Programming with Bananas, Lenses, Envelopes and Barbed Wire"
03:29:24 <pjdelport> http://eprints.eemcs.utwente.nl/7281/01/db-utwente-40501F46.pdf
03:29:57 <pjdelport> catamorphisms are the "bananas" in that title :)
03:31:03 <yitz> danilo2: yes. take note that it is quite different than the concept of "superclass" in OO language, even though superficially they appear similar.
03:31:35 <hseg> Hi. Can someone help me show that this fusion is correct/when this fusion is correct? foldl fusion seems insufficient: http://lpaste.net/105732
03:32:32 <yitz> remdezx: what part of the ghc api are you using?
03:34:33 <yitz> remdezx: it sounds like InteractiveEval. correct?
03:34:58 <kazagistar> hseg: have you seen this? https://hackage.haskell.org/package/list-fusion-probe
03:35:22 <yitz> remdezx: that is giving you access to the code that implements ghci, where a user types a string and ghci interprets it. so yes, it definitely needs to be a string.
03:35:51 <yitz> remdezx: but the string can include variable names if they are in scope
03:35:59 <yitz> remdezx: does that help?
03:36:21 <Kaligule> Happy Haskell to everyone!
03:39:17 <fuzzy_id> I'm trying to make
03:39:19 <fuzzy_id> newtype Log a b = MkLog {runLog :: (b -> (a, b))}
03:39:27 <fuzzy_id> an instance Functor:
03:39:35 <fuzzy_id> :t foo f (MkLog g) = MkLog (\x -> ((fst . g) x, (f . snd . g) x))
03:39:35 <fuzzy_id>  
03:39:36 <lambdabot> parse error on input ‘=’
03:39:50 <fuzzy_id> :t (foo f (MkLog g) = MkLog (\x -> ((fst . g) x, (f . snd . g) x)))
03:39:50 <fuzzy_id>  
03:39:51 <lambdabot> parse error on input ‘=’
03:39:57 <fuzzy_id> ergh
03:39:59 <hseg> kazagistar: Yes, but it's unrelated to my problem. I'm trying to reason about my code in order to write it more efficiently. So I'll do things like fuse f . foldl g z into foldl g' (f z), where f (g x y) = g' (f x) y, even if GHC is smart enough to figure it out.
03:40:18 <fuzzy_id> so i wanted to use foo as fmap
03:40:56 <fuzzy_id> but foo is of type (b -> b) -> Log a b -> Log a b
03:42:16 <fuzzy_id> can someone provide me a hint?
03:43:31 <kaih> Hi, I am using Codec.Picture (JuicyPixels) and I am unable to find a way to 'promote' an "Image PixelRGB8" to an "Image PixelRGBA16". So what I am looking for is something like:
03:43:33 <kaih> promoteImage :: Image PixelRGB8 -> Image PixelRGBA16
03:43:35 <kaih> Does someone know how to do that?
03:44:20 <klrr_> is (//) :: Set a -> Set a -> Set a a way to subsract X with Y ?
03:44:38 <klrr_> b
03:44:41 <klrr_> ups
03:45:35 <hseg> klrr_: You mean (\\)? yeah.
03:45:42 <klrr_> okey, thanks
03:46:14 <hseg> Any ideas regarding http://lpaste.net/105732 ?
03:48:03 <hseg> I'm being called away. See you later!
03:48:19 <pjdelport> kaih: Does promoteImage not work?
03:49:44 <kaih> pjdelport: no, it can only promote to an Image PixelRGBA8 not to an Image PixelRGBA16
03:50:02 * pjdelport tries to make sense of that diagram
03:50:17 * hackagebot fficxx-runtime 0.2 - Runtime for fficxx-generated library  http://hackage.haskell.org/package/fficxx-runtime-0.2 (IanWooKim)
03:50:19 * hackagebot HROOT-core 0.8 - Haskell binding to ROOT Core modules  http://hackage.haskell.org/package/HROOT-core-0.8 (IanWooKim)
03:50:21 * hackagebot HROOT-hist 0.8 - Haskell binding to ROOT Hist modules  http://hackage.haskell.org/package/HROOT-hist-0.8 (IanWooKim)
03:50:23 * hackagebot HROOT-math 0.8 - Haskell binding to ROOT Math modules  http://hackage.haskell.org/package/HROOT-math-0.8 (IanWooKim)
03:50:25 * hackagebot HROOT-graf 0.8 - Haskell binding to ROOT Graf modules  http://hackage.haskell.org/package/HROOT-graf-0.8 (IanWooKim)
03:51:00 <klrr_> if i use a qualified infix import like this Foo.($$$) will it be infix or not?
03:51:37 <tulcod> can i have cabal generate a file, which it then compiles?
03:51:55 <quchen> > 1 Prelude.+ 2 -- klrr_
03:51:56 <lambdabot>  3
03:52:07 <hpc> tulcod: you probably want template haskell
03:52:12 <hpc> or CPP
03:52:19 <tulcod> no, unfortunately i don't want that
03:52:44 <tulcod> i'm writing C bindinsg for a library that has a header containing a huge list of "static inline" functions
03:53:25 <tulcod> fortunately i have the list, but i'll need some kind of wrappers for those functions
03:53:38 <pjdelport> kaih: It looks like you can just write your own ColorConvertible instance
03:54:03 <hpc> tulcod: you want to parse the header and generate FFI definitions?
03:54:48 <tulcod> hpc: well i have an xml containing the list of functions, but since they're all defined "static inline" in the header file i can't bind to them directly using ccall
03:55:05 <tulcod> my hope was that i could use template haskell to generate a bunch of ccalls that way, but i'm getting linking errors
03:55:27 * hackagebot HROOT-io 0.8 - Haskell binding to ROOT IO modules  http://hackage.haskell.org/package/HROOT-io-0.8 (IanWooKim)
03:55:29 * hackagebot HROOT 0.8 - Haskell binding to ROOT RooFit modules  http://hackage.haskell.org/package/HROOT-0.8 (IanWooKim)
03:55:46 <tulcod> alternatively, can anyone point me in the right direction to writing more advanced Setup.hs ?
03:55:49 <hpc> i am fairly fuzzy on my C, but won't a static inline function cease to exist at all when it is compiled?
03:56:15 <hseg> The only fruitful path I see to fusing the code here: http://lpaste.net/105732 is to introduce a new datatype that represents nonempty lists and rewrite the code to use that datatype's version of foldl.
03:56:59 <kaih> pjdelport: ah ok, I will give it a go
03:57:18 <tulcod> hpc: yeah, that's the point
03:57:40 <tulcod> hpc: so the "foreign import ccall" compiles fine as haskell, but at the linking stage the function has disappeared
03:58:17 <pjdelport> kaih: Something like: instance ColorConvertible PixelRGB8 PixelRGBA16 where promotePixel (PixelRGB8 r g b) = PixelRGBA16 (r*257) (g*257) (b*257) maxBound
03:58:26 <pjdelport> (going by the rest of the code)
03:58:44 <pjdelport> With a {-# INLINE promotePixel #-} probably
03:59:33 <pjdelport> kaih: And maybe file a feature request for all the missing conversion combinations. :)
04:01:02 <hpc> tulcod: i still have a feeling there's some trick you can do with TH, since Q is an instance of MonadIO somewhere
04:01:05 <hpc> (iirc)
04:01:40 <d3m1g0d-> > any' :: (a -> Bool) -> [a] -> Bool
04:01:41 <lambdabot>  Not in scope: ‘any'’
04:01:42 <lambdabot>  Perhaps you meant one of these:
04:01:42 <lambdabot>    ‘any’ (imported from Data.List),
04:01:42 <lambdabot>    ‘BSC.any’ (imported from Data.ByteString.Char8),
04:01:42 <lambdabot>    ‘BSLC.any’ (imported from Data.ByteString.Lazy.Char8)
04:01:49 <tulcod> hpc: what do you mean?
04:02:36 <hpc> tulcod: so for instance, you could re-implement CPP #include, by having it read the file and dump that into the source code
04:02:51 <hpc> or do whatever other IO you want
04:02:55 <hpc> at compile-time
04:03:09 <tulcod> hpc: you mean cpphs, right?
04:03:36 <d3m1g0d-> guys, trying to write my own "any" function, but I can't get where I'm wrong
04:03:36 <d3m1g0d-> http://pastebin.com/jvugWhgb
04:03:40 <hpc> either one, #include works the same in both
04:04:22 <hpc> d3m1g0d-: in your (x:xs) case you are not passing the right number of params to any'
04:05:10 <d3m1g0d-> woooooops
04:05:20 <d3m1g0d-> thank you, sir
04:06:09 <hpc> easy mistake
04:06:16 <hpc> just wait until you start eliding parameters on purpose
04:07:16 <frerich> d3m1g0d-: I think the error message given by ghc should've hinted at the cause already, at least if I try it here I get
04:07:16 <frerich> Couldn't match expected type `Bool' with actual type `[a0] -> Bool'
04:07:16 <frerich> In the return type of a call of any'
04:07:16 <frerich> Probable cause: any' is applied to too few arguments
04:07:18 <tulcod> hpc: but in that case, i would have to use whatever program i would write to generate haskell / C source
04:07:20 <frerich> ...which seems spot-on.
04:07:50 <tulcod> hpc: so i might as well ask how i can generate source code that cabal can compile
04:08:21 <hpc> tulcod: so, suppose you have some sort of module Util.GenerateHs, and Util.GenerateC
04:08:48 <hpc> to generate YourPackage.FFI, you'd have YourPackage.FFI have something like
04:08:55 <d3m1g0d-> frerich: So far I'm under the impression that frequently enough Haskell gives irrelevant error messages
04:08:56 <hpc> (pretend i remember all the TH syntax here)
04:09:07 <hpc> import Util.GenerateHs
04:09:11 <hpc> import Util.GenerateC
04:09:22 <hpc> [| generateHs
04:09:29 <hpc>    generateC
04:09:31 <hpc> |]
04:09:33 <tulcod> $(generateHs)
04:09:38 <hpc> right
04:09:45 <tulcod> but surely generateC outputs C code?
04:10:08 <pjdelport> d3m1g0d-: GHC's error messages are pretty good most of the time.
04:10:20 <tulcod> how can you splice C code into haskell source?
04:10:29 <hpc> dunno, probably can't
04:10:32 <hpc> that was just an example
04:10:45 <Bynbo7> d3m1g0d-: you just don't know how to read them yet
04:11:07 <d3m1g0d-> you guys are probably right, I have a few days of experience with Haskell
04:11:23 <Axman6> d3m1g0d-: they are definitely intimidating though
04:11:30 <pjdelport> d3m1g0d-: It might take a while to understand what they mean, in context, but it's worth keeping at it.
04:11:41 <d3m1g0d-> i believe you
04:12:09 <pjdelport> They usually tell you what it expected, what it found instead, and where.
04:12:18 <pjdelport> So you have to figure out why that is.
04:12:23 <Axman6> which is usually all you need
04:12:28 <yitz> tulcod: we use both code generation and TH in some of our projects. what is it exactly that you are trying to do?
04:12:40 <pjdelport> Sometimes the context is wrong, sometimes the value is wrong: one of them has to be changed.
04:12:58 <tulcod> yitz: i want to bind a huge list of C functions which are defined (not declared) static inline in some header flie
04:13:19 <tulcod> yitz: luckily i can generate a list of functions, but simply binding to them using TH-generated ccalls gives linking errors
04:13:38 <tulcod> (since the inline functions "disappear" after copmilation)
04:14:49 <tulcod> yitz: so specifically, the C library exposes a header file containing the inline functions, and an xml file detailing those functions
04:17:19 <fuzzy_id> I'm trying to make
04:17:22 <fuzzy_id> newtype Log a b = MkLog (b -> (a, b))
04:17:30 <fuzzy_id> an instance of functor like so
04:17:36 <fuzzy_id> foo f (MkLog g) = MkLog (\x -> let (l,y) = g x in (l,f y))
04:17:45 <fuzzy_id> so foo shall be fmap
04:17:52 <fuzzy_id> but this is only type
04:17:58 <fuzzy_id> foo :: (b -> b) -> Log a b -> Log a b
04:18:47 <fuzzy_id> can someone hint me in the right direction, why i don't get this to be 'foo :: (a -> b) -> …'?
04:18:49 <Axman6> fuzzy_id: the function takes something of type b
04:19:15 <fuzzy_id> hmm?
04:19:19 <Axman6> "fmap" on MkLog (b -> (a, b)) needs to turn it into MkLog (c -> (a, c))
04:19:35 <fuzzy_id> yeah
04:19:48 <fuzzy_id> if i remove MkLog on the right hand side i get
04:19:51 <Axman6> which you won't be able to do without also having a function c -> b
04:19:56 <kaih> pjdelport: i endend up with:
04:19:58 <kaih> instance ColorConvertible PixelRGB8 PixelRGBA16 where
04:20:00 <kaih>     {-# INLINE promotePixel #-}
04:20:02 <kaih>     promotePixel (PixelRGB8 r g b) = PixelRGBA16 (promotePixel r) (promotePixel g) (promotePixel b) maxBound
04:20:07 <kaih> pjdelport++ many thanks
04:20:16 <fuzzy_id> almost the right thing
04:20:20 <yitz> tulcod: i think you could manage it with TH. but if you want to just generate the code - which very well may be simpler - here is a sample of how to do that: https://gist.github.com/23Skidoo/7930870
04:20:46 <fuzzy_id> confused
04:20:59 <Axman6> fuzzy_id: basically, you can't do what you want unless you have: foo :: (b -> c) -> (c -> b) -> Log a b -> Log a c
04:21:16 <tulcod> yitz: nice, thanks a lot. yeah, i would love to do it the pretty way, but i think this is just a limitation of ghc at the moment
04:21:35 <Axman6> because you've said that the type b is both the type that makes up the second element of the tuple AND the type of the value passed to the function which produces the tuple
04:22:21 <Axman6> so if you want to change the type of the second element of the tuple, you also need to change the type of the value passed into the function
04:22:43 <Axman6> foo :: (b -> c) -> (c -> b) -
04:22:46 <Axman6> bah
04:22:55 <Axman6> foo :: (b -> c) -> (c -> b) -> Log a b -> Log a c
04:23:49 <fuzzy_id> sry, i don't get this
04:23:50 <yitz> tulcod: i don't think there is a "pretty way". both the preprocessor way and the TH way (if you get that to work) involve considerable inherent ugliness.
04:23:55 <fuzzy_id> i want:
04:24:01 <Axman6> foo f g (Log h) = MkLog $\x -> let (a,b) = h (g x) in (a, f b)
04:24:10 <fuzzy_id> foo :: (b -> c) -> Log a b -> Log a c
04:24:16 <yitz> tulcod: in short: haskell isn't lisp
04:24:31 <Axman6> right, you cannot do that without also having a function of type c -> b
04:24:32 <tulcod> yitz: well IMO, so far all the ugly stuff i have stems from the C library being... you know, C
04:24:51 <yitz> tulcod: i guess you could look at it that way ;)
04:24:58 <fuzzy_id> ok
04:25:09 <fuzzy_id> i'll have to meditate over this for a while
04:27:00 <Axman6> fuzzy_id: what you seem to want is to be able to turn MkLog (b -> (a,b)) into MkLog (b -> (a,c)) but your type doesn't allow that since you said that the type of the function inside MkLog has an argument and result second value of the same type
04:27:02 <yitz> tulcod: ohhh - just noticed something. you'll probably want to copy that Setup.hs verbatim, except for the name of the pre-processor exe.
04:27:18 <yitz> tulcod: but mikhail licenced it gpl-3 !!
04:27:53 <yitz> tulcod: if that is an issue for you, you could probably ask him to re-license it for you.
04:28:29 <tulcod> well i think i'll need to make a few minor adjustments anyway, and besides, if he sues me over these 36 lines of code, i can take it
04:28:39 <yitz> heh
04:29:05 <tulcod> still have to think of a good solution anyway
04:29:12 <tulcod> i mean, having a preprocessor doesn't magically fix my problems
04:29:15 <yitz> tulcod: i would worry more about rms suing you over it than mikhail. and he would be ruthless. :)
04:29:16 <Axman6> @djinn (b -> c) -> (b -> (a,b)) -> (b -> (a,c)) -- this is doable
04:29:16 <lambdabot> Cannot parse command
04:29:22 <Axman6> @djinn (b -> c) -> (b -> (a,b)) -> (b -> (a,c))
04:29:22 <lambdabot> f a b c =
04:29:22 <lambdabot>     case b c of
04:29:22 <lambdabot>     (d, _) -> (d, a c)
04:29:23 <fuzzy_id> Axman6: right! got it!
04:29:27 <fuzzy_id> thanks a lot!
04:29:37 <remdezx> yitz: Yes, I'm using exactly that part and I know that I can use names of variables previously declared
04:30:04 <tulcod> yitz: like, what exactly do i want to preprocess? should i generate a .c file containing un-static'd functions?
04:30:15 <remdezx> yitz: But I need to make some of variables available both in my program and in ghc runtime
04:31:01 <yitz> tulcod: so there's a separate problem of referring to static functions in ffi? i didn't know that.
04:31:05 <tulcod> yitz: but then i might as well copy the file that generated the header file in the first place, and take out the part that says "static inline"
04:31:31 <tulcod> ugh. this is such a piece of shit.
04:31:51 <tulcod> yitz: referring to static functions is what this is all about
04:32:04 <remdezx> yitz: I'm considering creation of IORef to a Map in ghc runtime and then retreiving it, to use it to transfer variables from and to ghc runtime
04:32:14 <tulcod> "inline" is just a hint - that shouldn't be a problem. at worst, i just include the header files as c code to define the functions
04:32:19 <yitz> remdezx: i don't understand your whole use case. why do you have a "program" and "ghc runtime" that are different from each other? how does this whole thing work?
04:32:24 <tulcod> but "static" makes it nonlinkable
04:32:51 <yitz> remdezx: or rather, "fit together", not "work"
04:33:42 <yitz> tulcod: why is it not linkable? ghc has the header files, the functions are defined there. what's the problem?
04:34:20 <tulcod> yitz: "static" means exactly that you can't link to it from another object file
04:34:38 <tulcod> so i have to have a C file which uses these functions
04:35:21 <yitz> tulcod: "another" object file? what other object file is there? you're compiling this with ghc, right?
04:35:44 <tulcod> yitz: you compile c source files file by file to their respective object files
04:35:50 <tulcod> then link them together into an executable
04:36:32 <yitz> tulcod: ghc compiles the c source files and links to the object files.
04:36:56 <tulcod> right. so if a function is "static" in some c source, then it's not linkable
04:37:27 <yitz> tulcod: are you trying to compile it yourself using a c compiler and then hoping that ghc will somehow use the object file you created? that's not how ffi usually works.
04:37:33 <tulcod> no?
04:37:36 <tulcod> where did you read that?
04:38:18 <yitz> tulcod: no. just list the header files in the "c-bits" field in your cabal file. let cabal/ghc do the rest. it should all work out.
04:38:29 <yitz> tulcod: try it.
04:38:38 <tulcod> i have a C library, whose API consists of a header file which contains a bunch of static inline functions. i can't link to those functions from another object file (e.g. compiled haskell source) because they're static
04:39:10 <tulcod> yitz: it doesn't work out because the haskell source is compiled into one object, and the header files into another
04:39:21 <pjdelport> kaih: Oh, cool. Yeah, that should be better.
04:39:25 <tulcod> and the object compiled from the c source is virtually empty because the functions are all static
04:39:25 <yitz> tulcod: how does it work out in c?
04:39:38 <tulcod> yitz: you mean, how do C programs use this library?
04:39:41 <yitz> right
04:39:52 <syllogismos> echo :script C:\Users\Anil\AppData\Roaming\cabal\ghc-vis-0.7.2.3\ghci >> %APPDATA%\ghc\ghci.conf  its asking me to run this command after starting ghci, but it is giving me error what does the command do actually?
04:39:57 <tulcod> well whenever they call one of these functions, it is essentially inlined into the code
04:39:58 <remdezx> yitz: I'm trying to implement an interpreter for my own domain specific language. In my interpreter I interpret my language's expressions using ghc interpreter (via ghc-api) . Thats how my program and ghc interpreter works together
04:40:00 <tulcod> there's nothing to link to
04:40:02 <Krakarn> static functions in C are supposed to be the equivalent of private methods in OOP
04:40:14 <Krakarn> so you can only use them inside the file they're defined
04:40:32 <ij> Can haskell write type signatures for values of a completed progarm?
04:41:09 <Krakarn> when they're static inline they get copied to every instance of where they're called
04:41:11 <tulcod> yitz: so what i need is a piece of c code of (non-static!) wrappers to these functions. the wrappers call the static'd functions, and are themselves linkable
04:42:12 <yitz> tulcod: i see. so perhaps you do need to generate a stub c file that instantiates those functions, and a master header file that pulls everything in.
04:42:15 <tulcod> yitz: but template haskell + foreign import doesn't give me that
04:42:41 <yitz> tulcod: yeah, i can see now that TH doesn't look like the right way to go here :)
04:42:58 <Axman6> ij: if you turn on -Wall in GHC, it'll tell you every top level definition which does not have a type declaration too
04:42:59 <tulcod> yeah i think i need to generate some stub c
04:43:22 <tulcod> but from what? the xml file? the header file and some fancy sed'ing?
04:44:13 <tulcod> actually. maybe the latter isn't even that bad an idea
04:44:17 <yitz> tulcod: of course you could just write a separate program to generate what you need, and then write a shell script that runs that first and then cabal install. but it's nicer to be able to have it all happen from inside cabal.
04:44:23 <tulcod> i can just remove all "static inline" from the file
04:44:37 <yitz> tulcod: write a haskell program that does it
04:45:06 <tulcod> yeah i think i'll need to use the hooks either way
04:45:45 <siriusbtx> I am trying to create a monad but I keep getting errors on this: (>>=) (Default x) f = Default x
04:45:45 <tulcod> fuck it. i'm just gonna take the header file and remove all "static inline"s
04:45:51 <siriusbtx> Whats wrong with that?
04:45:59 <tulcod> it's an easy solution that might just work
04:46:26 <RchrdB> siriusbtx, what's your error?
04:46:44 <RchrdB> Pastebin your module and error message, please?
04:46:45 <siriusbtx>     Couldn't match expected type ‘b’ with actual type ‘a’
04:46:45 <siriusbtx>       ‘a’ is a rigid type variable bound by
04:46:45 <siriusbtx>           the type signature for (>>=) :: Test a -> (a -> Test b) -> Test b
04:46:56 <tulcod> yitz: thanks for your help :)
04:47:19 <yitz> remdezx: ok. why do you need ghc-api for this? to compile haskell-like code?
04:47:25 <RchrdB> siriusbtx, the pastebin is at http://lpaste.net/new/haskell
04:47:26 <yitz> tulcod: np gl
04:47:26 <siriusbtx> http://pastebin.com/vzrhViB1
04:48:01 <tulcod> yitz: (in case you were interested, i'm trying to write haskell bindings to wayland)
04:48:12 <yitz> tulcod: if this is a 3rd party library though, you'll have to do that every time. if you instrument it, it's automatic.
04:48:25 <yitz> tulcod: that's great! xmonad could use that :)\
04:48:31 <remdezx> yitz: Yes, my language is based on haskell internally. I'm sure about that I need ghc-api.
04:48:40 <tulcod> yitz: yeah, of course i'll take out the "static inline" using a hook - not manually
04:48:42 <RchrdB> siriusbtx, your problem is that the type of the parameter to the the (Default) constructor hasn't changed.
04:49:29 <siriusbtx> RchrdB: Thats what I want, how should I do that?
04:50:03 <RchrdB> siriusbtx, e.g. imagine (Default 123 :: Default Int) >>= (\v -> "an apple") -- the result of that expression is (Default String), but your implementation would try to put that Int value in there instead.
04:50:44 <yitz> remdezx: sure, just trying to understand what's going on. so you go back and forth? you pass in some string to ghc-api, run it, get back a result, do stuff with it, call ghc-apI again? or just once?
04:50:50 <RchrdB> Given what you have here, I think that you just can't have the type in the Default leg be the same as the type that is being passed through the Monad
04:51:10 <siriusbtx> RchrdB: kk ty
04:51:32 <roventa> yesterday i tryed this site www.SoccerTips4Sure.com and i won nice money
04:51:57 <remdezx> yitz: Yes, but as I written before these variables are not derivving Show or are infinite so they cannot be converted to a string
04:52:21 <RchrdB> siriusbtx, something like this: http://lpaste.net/105733
04:53:42 <siriusbtx> RchrdB: Ye thought about that, but I wanted d and a to be the same type :p
04:53:53 <darthdeus> hey guys, this is probably a noob question, but isn't every functor in haskell endofunctor?
04:53:55 <RchrdB> You can't very easily do that in the Monad constraint.
04:54:03 <siriusbtx> RchrdB: kk thx
04:54:03 <darthdeus> i mean if i understand correctly, endofunctors stay in the same category
04:55:41 <RchrdB> What you *can* do is apply constraint in a function like http://lpaste.net/105733
04:55:54 <pjdelport> darthdeus: Right.
04:56:28 <RchrdB> siriusbtx, er, you can apply that constraint in a function like runDefault in that paste.
04:56:45 <siriusbtx> RchrdB: k
05:00:00 <yitz> remdezx: sorry, computer was down for a few minutes
05:00:10 <remdezx> yitz: np
05:00:28 * hackagebot robots-txt 0.4.1.0 - Parser for robots.txt  http://hackage.haskell.org/package/robots-txt-0.4.1.0 (MarkWotton)
05:03:26 <yitz> remdezx: anyway, i don't see how an ioref would help. there doesn't seem to be any obvious way to share data between your program and the running GhcMonad, other than via strings.
05:04:00 <yitz> remdezx: or meta-information about what GhcMonad computed.
05:04:33 <yitz> remdezx: but the data objects themselves seem to live in a separate universe
05:06:59 <yitz> remdezx: instead of passing the data "b" from your program to GhcMonad, is there some way that you could run a calculation inside GhcMonad to construct "b" there?
05:08:47 <quchen> When I have a type "data Foo = Foo", Haddock refers to the type constructor in links. Is there a way I can generate a link to the data constructor?
05:09:17 <quchen> 'Foo' is the type constructed via the ''Foo' constructor ← Something like this
05:09:50 <remdezx> yitz: If there will be no other possibility I will try to construct it inside GhcMonad and operate on it via some ghc-api calls... But I was hoping that there will be some better way to do that
05:12:08 <remdezx> yitz: I could just make an interface to operate on this data structures inside GhcMonad if there is no other way....
05:21:37 <tristanStrange> hey all... is there a nice way of live-coding against gloss/haskell?
05:21:49 <tristanStrange> what would i need to set this up?
05:24:14 <davnils> tristanStrange: have you tried ghci? could be better, but it works.
05:25:22 <tristanStrange> davnils: I can't really work out how to get started... I'd really like to do modify animations on the fly
05:25:30 * hackagebot fficxx 0.2 - automatic C++ binding generation  http://hackage.haskell.org/package/fficxx-0.2 (IanWooKim)
05:25:59 <tristanStrange> when I launch main (my animation) the console becomes unresponsive
05:27:59 <davnils> I'm not too familiar with the details. make sure you're using -threaded and a separate thread.
05:28:36 <tristanStrange> wow... not heard of that stuff. sounds promissing.... I'll look around
05:28:40 <davnils> ah, that might be ignored by ghci (-O2 as well)..
05:29:15 <yitz> remdezx: yeah. it's sad. a different approach would be to use haskell-src-exts instead of ghc-api to parse the dsl expressions. but that would be a complete rewrite, and not simple.
05:31:08 <rwbarton> ghci is already using the threaded runtime
05:31:24 <davnils> ah!
05:31:28 <yitz> you're right that O2 is ignored though
05:31:57 <davnils> tristanStrange: try compiling separately with ghc -O2 ... and load the binary in ghci.
05:31:58 <rwbarton> if you type 'main' into ghci, it will wait until main finishes to let you enter more, just like any other IO action
05:32:16 <rwbarton> is that what you mean by unresponsive?
05:32:38 <remdezx> yitz: Thats right... Thanks for your help and time ;). I will also take a look at haskell-src-exts, maybe it will help me in some other cases ;)
05:32:55 <yitz> remdezx: np good luck :)
05:32:55 <f3st> remdezx: np good luck :)
05:33:01 <tristanStrange> rwbarton... thats what i've been doing
05:33:49 <rwbarton> well, so, you can try   forkIO main
05:33:53 <rwbarton> it will do something different at least
05:33:56 <rwbarton> hopefully :)
05:39:30 <tristanStrange> rwbarton: Amazing! I'm getting there now!
05:44:18 <tristanStrange> do any of you guys use Vim?
05:44:48 <tristanStrange> I'm using hdevtools atm.... is haskell-mode more powerful?
05:45:05 <tdammers> tristanStrange: I use vim, but none of the plugins
05:45:09 <tdammers> just vanilla vim
05:45:44 <tristanStrange> hmmm. I like built in help etc...
05:46:31 <atticus> Does anyone know the current state of hsSDL?
05:46:43 <tdammers> tristanStrange: why does it have to be built in?
05:53:13 <atticus> I'm asking about hsSDL because the current version isn't compatible with GHC 7.8.2, and I submitted a patch, but want to know if the maintainer is still alive and stuff. If anyone has any info, it would be greatly appreciated!
05:54:59 <danilo2> Hello! Is there in Haskell any function with signature of "(m a -> m b) -> (t m a -> t m b)" ? (where m is monad and t is monad transformer)
05:57:45 <atticus> @danilo2 I hoogled it and found Control.Monad.Trans.Identity.mapIdentityT which just lifts a monad into the identity transformer... other than that, not sure.
05:57:46 <lambdabot> Unknown command, try @list
05:57:49 <Axman6> danilo2: are you sure you want the m a there?
05:57:58 <atticus> danilo2: I hoogled it and found Control.Monad.Trans.Identity.mapIdentityT which just lifts a monad into the identity transformer... other than that, not sure.
05:58:54 <danilo2> Axman6: I'm pretty sure
05:59:00 <danilo2> atticus: hmm, ok, thank you
05:59:02 <Axman6> it seems like you want fmap, but I can see there might be cases where you need m a
05:59:24 <danilo2> Axman6: no, fmap will not help me here
05:59:35 <Axman6> what is m in your case?
05:59:58 <danilo2> Axman6: it's a general monad - it could be IO or my own one
06:00:03 <dottedmag> danilo2: Seems to be a separate function for each transformer.
06:00:25 <dottedmag> mapListT :: (m [a] -> n [b]) -> ListT m a -> ListT n b
06:00:29 <lieven_> something like liftA2 perhaps?
06:00:29 <dottedmag> etc
06:00:32 <Axman6> yeah it might not be possible for all monad transformers
06:01:18 <danilo2> Axman6, dottedmag: hmm, ok, thank you :) I'll think about it a little more now :)
06:01:51 <quchen> danilo2: mmorph might be worth having a look.
06:02:18 <quchen> hoist :: Monad m => (forall a. m a -> n a) -> t m b -> t n b
06:02:40 <danilo2> quchen: Oh! intersting! I've implemented a lot of mmorph functionality by myself as far as I see
06:02:43 <quchen> Oh, you're not changing base monads. Hmm.
06:03:33 <marchelzo_> What is going on here? s <- readFile "cipher1.txt"
06:03:35 <marchelzo_> cipher = (read ("[" ++ s ++ "]") :: [Int])
06:03:49 <marchelzo_> How do you cast type [String] to [Int]?
06:04:02 <dottedmag> :t read
06:04:03 <lambdabot> Read a => String -> a
06:04:07 <quchen> read does that. In a bad way.
06:04:20 <dottedmag> > read "[1, 2]" :: [Int]
06:04:22 <lambdabot>  [1,2]
06:04:22 <Axman6> marchelzo_: the string is being passed to read and it's turning it into a list of Int
06:04:44 <pjdelport> > read "[1,2,3]" :: [Int]
06:04:45 <marchelzo_> Oh.. I', sorry. I didn't know that the file "cipher1.txt" contained numbers and not words.
06:04:45 <lambdabot>  [1,2,3]
06:04:50 <Axman6> > let f s = (read ("[" ++ s ++ "]") :: [Int]) in f "2,3,4,5"
06:04:52 <lambdabot>  [2,3,4,5]
06:04:52 <marchelzo_> I just realized that.
06:05:01 <marchelzo_> Sorry for the confusion.
06:05:04 <quchen> See https://github.com/quchen/articles/blob/master/fbut.md#read on why you shouldn't use read.
06:05:24 <marchelzo_> quchen: Ok. does that article also suggest a solution?
06:05:57 <dottedmag> marchelzo_: it's easy to see yourself
06:06:19 <marchelzo_> yeah I did. I thought it was going to be a long article just about read.
06:10:35 * hackagebot amqp 0.9 - Client library for AMQP servers (currently only RabbitMQ)  http://hackage.haskell.org/package/amqp-0.9 (HolgerReinhardt)
06:11:13 <Guest75667> this does not compile ? data Complex = Num a => Complex { real :: a, img :: a}
06:11:37 <klrr_> is it possible to simply "head" a Set?
06:11:46 <vanila> data Complex a = Complex { real :: a, img :: a}
06:12:03 <Guest75667> but what if i want a to behave like numbers ?
06:12:15 <vanila> instance Num a => Num (Complex a) where ...
06:12:32 <ciaranm> given f :: a -> b, i can turn ((,) a) into ((,) b). under what conditions is this a natural transformation?
06:13:10 <vanila> ciaranm, a natural transformation between which functors?
06:13:37 <ciaranm> vanila: ((,) a) and ((,) b)
06:13:57 <quchen> :t S.findMin -- klrr_
06:13:58 <lambdabot> S.Set a -> a
06:13:59 <rwbarton> it's always a natural transformation
06:14:06 <ciaranm> ta
06:14:07 <klrr_> quchen: thanks
06:15:36 * hackagebot twitter-conduit 0.0.4 - Twitter API package with conduit interface and Streaming API support.  http://hackage.haskell.org/package/twitter-conduit-0.0.4 (TakahiroHimura)
06:19:40 <byorgey> ciaranm: every Haskell function whose type is of the form   forall c. F c -> G c  (for F and G functors) is automatically a natural transformation
06:20:18 <byorgey> even when F and G are not functors, an analogous generalization still holds
06:20:48 <ciaranm> is there an abstract nonsense reformulation of "theorems for free"?
06:21:24 <byorgey> ciaranm: yes, that's the "analogous generalization" I was referring to =)
06:21:34 <byorgey> it involves dinaturality
06:21:41 <ciaranm> byorgey: i mean, has it actually been written down anywhere?
06:22:10 <byorgey> ciaranm: good question.  To my knowledge it is only folklore.  I have never seen it written down formally.
06:22:22 <tulcod> "theorems for free" as in the paper?
06:22:25 <ciaranm> yup
06:22:44 <byorgey> I have an almost-finished blog post on the subject I should get around to finishing.  But even my blog post is not all that formal.
06:22:57 <ciaranm> i have been asked to explain to some algebra people "why computing scientists care about this category theory stuff". i suspect they're writing a grant proposal and they want a fake application.
06:23:12 <byorgey> haha
06:23:33 <malorie> is this the right place to ask about cabal issues?
06:23:41 <ciaranm> was thinking of giving them a fake, sanitised history of how wadler reinvented monads
06:24:18 <tulcod> ciaranm: there was a discussion on the types mailing list about how types entered programming after their mathematical introduction
06:24:29 <tulcod> may wanna have a look at that
06:24:33 <ciaranm> and build up to showing them the state monad, and then claiming that if you have that then just defining IO to exist is probably legitimate
06:24:34 <byorgey> because category theory and computing are about the same two central issues: composition and homomorphism
06:24:49 <byorgey> obviously that would have to be unpacked a lot and I doubt it's really the sort of thing they are looking for =)
06:24:57 <tulcod> http://lists.seas.upenn.edu/pipermail/types-list/2014/001745.html and further
06:25:10 <ciaranm> tulcod: ta
06:25:22 <byorgey> ciaranm: monads make a good example
06:25:39 <byorgey> malorie: sure
06:27:04 <malorie> byorgey: ok. so I'm trying to update cabal that came with the platform, but it fails with the following message: http://lpaste.net/105735
06:28:16 <rwbarton> malorie: the actual error(s) are somewhere above there
06:28:18 <rwbarton> hopefully
06:30:37 * hackagebot shadowsocks 1.20140617 - A fast tunnel proxy that help you get through firewalls  http://hackage.haskell.org/package/shadowsocks-1.20140617 (rnons)
06:31:14 <malorie> rwbarton: http://lpaste.net/105736 <- this is the complete output
06:32:23 <rwbarton> oh
06:32:26 <rwbarton> what OS is this?
06:32:30 <malorie> OSX
06:33:00 <rwbarton> this looks like the usual clang CPP issue
06:33:10 <atticus> wow, that is a disgusting error log
06:34:02 <malorie> I see. is there a known fix, or something?
06:34:41 <rwbarton> yeah, I'm sure if you just google for ghc osx clang or something you will find instructions
06:34:52 <malorie> alright. thanks
06:37:10 <osa1> how can I load test suite to cabal repl?
06:40:40 <supki> osa1: cabal repl $name
06:42:40 <fread2282> *operator
06:42:47 <fread2282> is there any way I can get constructor precedence (with GHC.Generics/Typeable/Data.Data)?
06:42:55 <fread2282> (but I only care about constructors)
06:56:01 <marchelzo_> If I have a Maybe Int, how can I print the Int without extracting it out? like fmap print (Just 3)
06:56:53 <lieven_> that would give you a Maybe (IO ())
06:57:22 <marchelzo_> lieven_: Yeah, so how would I get just an IO ()?
06:58:08 <lieven_> fromJust
06:58:28 <byorgey> no, fromJust is evil.
06:58:33 <tdammers> pattern-match
06:58:37 <tdammers> fromMaybe
06:58:37 <marchelzo_> i dont want an exception from Nothing
06:58:42 <tdammers> <|>
06:58:49 <byorgey> marchelzo_: what do you want the IO () to do in the case of Nothing?
06:58:59 <marchelzo_> byorgey: print Nothing
06:59:05 <marchelzo_> print "Nothing"
06:59:11 <byorgey> marchelzo_: oh, then just use print
06:59:27 <tdammers> byorgey: that'll print Just 3 as "Just 3", not "3"
06:59:30 <marchelzo_> But I don't want the "Just" printed
06:59:31 <byorgey> print (Just 3)
06:59:36 <nicodp> marchelzo_: maybe (print "Nothing") print (Just 3)
06:59:36 <tdammers> > print $ Just 3
06:59:38 <lambdabot>  <IO ()>
06:59:47 <tdammers> meh
06:59:54 <byorgey> ok, in that case, what nicodp said
07:00:12 <byorgey> except you might want  putStrLn "Nothing" instead of  print "Nothing"
07:00:17 <marchelzo_> yea
07:00:27 <byorgey> the latter will cause  \"Nothing\"  to be shown on the screen
07:00:48 <tdammers> putStrLn $ (show <$> theThing) <|> "Nothing"
07:00:53 <davnils> > fromMaybe "Nothing" $ fmap show (Just 2)
07:00:55 <lambdabot>  "2"
07:01:18 <tdammers> eh
07:02:17 <davnils> oh, better solution above.
07:03:06 <mr-> except it does not work :-P
07:04:18 <davnils> ah
07:04:49 <tdammers> putStrLn . fromMaybe "Nothing" $ show <$> Just 3
07:04:52 <tdammers> this should work
07:04:59 <tdammers> > fromMaybe "Nothing" $ show <$> Just 3
07:05:01 <lambdabot>  "3"
07:05:07 <tdammers> > fromMaybe "Nothing" $ show <$> Nothing
07:05:09 <lambdabot>  "Nothing"
07:05:22 <tdammers> but it's just the fmap solution with infix <$>
07:14:20 <Para_> genericLength == fromIntegral . length
07:14:30 <Para_> ahh
07:15:06 <shachaf> Unless you're using lazy naturals, fromIntegral . length is almost certainly better than genericLength.
07:15:11 <Tjr> err, does that imply that genericLength will mishandle a string that's longer than maxBound ::Int?
07:15:17 <Iceland_jack> Para_: not quite
07:15:17 <Iceland_jack> @src genericLength
07:15:17 <lambdabot> genericLength []    = 0
07:15:17 <lambdabot> genericLength (_:l) = 1 + genericLength l
07:15:29 <shachaf> Or a handwritten generic length function if you're using 32-bit GHC.
07:15:46 <Para_> wait what are lazy naturals?
07:15:57 <shachaf> data Nat = Z | S Nat
07:16:05 <Para_> also why is it not quite the same?
07:16:08 <benzrf> :t S
07:16:10 <lambdabot> Not in scope: data constructor ‘S’
07:16:11 <benzrf> :t Succ
07:16:12 <lambdabot> Not in scope: data constructor ‘Succ’
07:16:14 <benzrf> huh
07:16:15 <Para_> @src length
07:16:15 <lambdabot> Source not found. Where did you learn to type?
07:16:16 <pjdelport> Para_: http://www.haskell.org/haskellwiki/Peano_numbers
07:16:24 <fread2282> @src length
07:16:24 <lambdabot> Source not found. :(
07:16:24 <benzrf> @src genericLength
07:16:25 <lambdabot> genericLength []    = 0
07:16:25 <lambdabot> genericLength (_:l) = 1 + genericLength l
07:16:51 <shachaf> Please experiment with lambdabot in /msg unless you think the response is useful to the channel.
07:17:28 <pjdelport> Para_: genericLength isn't the same as fromIntegral . length for lists longer than maxBound :: Int
07:17:38 <fread2282> Para_: length computes length using GHC unboxed ints IIRC, fromIntegral then converts it to another numeric type
07:18:21 <Para_> ah okay, thanks
07:18:21 <Para_> :)
07:18:23 <fread2282> genericLength computes it directly on any numeric type at the expense of not using GHC unboxed ints
07:18:35 <pjdelport> And you don't need lazy integers for genericLength to be useful; genericLength :: [a] -> Integer is enough.
07:18:35 <shachaf> Unboxed ints aren't the important part.
07:18:57 <shachaf> pjdelport: You should never use genericLength with that type. Better to write your own.
07:19:17 <pjdelport> shachaf: Why not?
07:19:23 <benzrf> @src Integer
07:19:24 <lambdabot> data Integer = S# Int#
07:19:24 <lambdabot>              | J# Int# ByteArray#
07:19:28 <dottedmag> :t length
07:19:28 <benzrf> o.o
07:19:29 <lambdabot> [a] -> Int
07:19:33 <napping> the source shown above looks bad
07:19:43 <shachaf> The important thing is that length looks e.g. like this: length = go 0 where { go !a [] = 0; go !a (_:xs) = go (a+1) xs }
07:19:44 <benzrf> > genericLength (fix (1:)) > 10
07:19:49 <lambdabot>  mueval-core: Time limit exceeded
07:19:49 <lambdabot>  mueval: ExitFailure 1
07:20:03 <napping> at least for a strict number type a strict accumulator would be better
07:20:14 <benzrf> > (genericLength (fix (1:)) :: Integer0 > 10
07:20:15 <lambdabot>  <hint>:1:41: Illegal literal in type (use DataKinds to enable): 10
07:20:16 <benzrf> oops
07:20:18 <benzrf> > (genericLength (fix (1:)) :: Integer) > 10
07:20:24 <lambdabot>  mueval-core: Time limit exceeded
07:20:24 <lambdabot>  mueval: ExitFailure 1
07:20:24 <benzrf> tsk
07:20:29 <benzrf> > (genericLength (fix (1:)) :: Nat) > 10
07:20:31 <lambdabot>  Not in scope: type constructor or class ‘Nat’
07:20:32 <benzrf> > (genericLength (fix (1:)) :: Natural) > 10
07:20:34 <lambdabot>  True
07:20:36 <napping> the genericLength (_:l) = 1 + genericLength l form is only good if your + is lazy
07:20:36 <benzrf> NeatBasis:
07:20:37 <shachaf> Please experiment with lambdabot in /msg unless you think the responses are useful to the channel.
07:20:38 <benzrf> *neat
07:20:47 <shachaf> Dozens of errors aren't useful.
07:20:50 <NeatBasis> Yup?
07:20:57 <napping> even if the responses are going to be useful, please debug your imput in /msg
07:21:05 <shachaf> Yes.
07:21:35 <napping> Well, specifically because you seem to be having trouble with that
07:21:45 <pjdelport> shachaf: So you mean there should be a stricter genericLength?
07:21:52 <shachaf> Yes.
07:22:06 <shachaf> Well, "stricter" in the sense that I wrote above.
07:22:28 <shachaf> The way genericLength is written has an advantage if your number type is lazy naturals.
07:22:54 <shachaf> But for any other type it has a major disadvantage. It won't work for long lists.
07:22:56 <fread2282> there is, for Int and Integer Data.List has RULES to use a strict version
07:23:00 <shachaf> So it's not really all that generic.
07:23:45 <napping> Maybe some kind of fancier improving value would also work with genericLength, but yeah, it's not very generic
07:23:49 <shachaf> RULES only helps you in specific non-generic situations.
07:24:09 <fread2282> yep, Data.List should probably export the strict version
07:24:15 <shachaf> napping: I don't think anything else would.
07:24:31 <napping> on the other hand, if your list is too long for Int - even 32-bit Int - then whether you blow that stack or use a strict accumulator probably doesn't matter
07:24:38 <napping> it's not going to terminate either way
07:25:30 <shachaf> Which is why (fromIntegral . length) is probably better than genericLength in almost all cases in practice.
07:25:34 <napping> shachaf: I was thinking specifically of Conal's push-pull FRP paper - there's some kind of fancy representation of time as a tricky thing that knows a lower bound, secretly mutably updated behind the scenes, and has operations for comparing to bounds
07:26:03 <napping> but then again, null . drop n is good for testing if a list has a minimum length
07:26:29 <shachaf> Ah. Secretly mutating implementations (other than the one provided by GHC) I don't know about.
07:27:00 <napping> I'm not even sure if it would work with additions like that
07:28:21 <napping> in any case, I think the only useful thing to do with a lazy length is to compare with a lower bound
07:28:30 <napping> and for that null.drop n works fine
07:39:25 <edwardk> napping: you can also compare it with an upper bound, etc. ;)
07:40:06 <napping> I suppose I can at that
07:40:45 <napping> Hey, is there any documentation on the trifecta error types? It's own messages are very pretty, but I remember what I was running into long ago was wanting to give my own semantic errors with some of the same machinery
07:41:21 <edwardk> napping: i'm getting ready to do a rather large refactoring of trifecta, so if you can indicate what you want to do i can try to keep it in mind
07:42:25 <napping> Just things like "Type error - Blah inferred from <caret/span> conflicts with Blah inferred from <span2>", that sort of thing
07:44:01 <napping> I got a bit bogged down trying to trace how the parser itself deals with them
07:45:23 <edwardk> http://hackage.haskell.org/package/trifecta-1.4.2/docs/src/Text-Trifecta-Result.html#Err is the main type
07:45:45 * hackagebot type-hint 0.1 - Guide type inference with proxy values  http://hackage.haskell.org/package/type-hint-0.1 (MikhailVorozhtsov)
07:45:47 * hackagebot data-textual 0.3.0.1 - Human-friendly textual representations.  http://hackage.haskell.org/package/data-textual-0.3.0.1 (MikhailVorozhtsov)
07:45:49 * hackagebot network-ip 0.2.1.1 - Internet Protocol data structures  http://hackage.haskell.org/package/network-ip-0.2.1.1 (MikhailVorozhtsov)
07:45:53 <edwardk> footnotes are other fully rendered docs
07:47:09 <edwardk> so to do your error what i'd do is give on error that is a error with 'blah infrred from'   that has an attached rendering for the caret or span. and graft a footnote mde by renderng a similar 'note:' inferred from' with the rendering for span2
07:47:23 <edwardk> then you can have an Err or turn it into a Doc with explain
07:48:02 <napping> It's more the "rendering"
07:48:09 <napping> I guess you're supposed to go through doc?
07:48:14 <edwardk> yeah
07:48:24 <napping> I'm sure I could figure things out with a bit more poking around
07:48:39 <edwardk> The Rendering type is how you draw a line of code with carets/spans
07:48:54 <edwardk> that can be use to help build an Err, and then you can 'explain' an Err giving a Doc
07:48:57 <napping> but especially just adding comments explaining what the representation of Caret/Span/etc means would be nice - the tabs in Caret confused me for a while, for one
07:49:09 <edwardk> fair nuff
07:49:15 <napping> I'm not so much interested in producing errors during the parsing process
07:49:25 <edwardk> large part of why its undocumente is i've meant to go gut and rewrite large chunks of it for a year or two
07:49:47 <napping> rather I'm thinking the parser will return things annotated with Spanned and such, and then later semantic phases can make pretty error messages too
07:50:14 <tristanStrange> ok chaps.... anyone aware of how to go form an HTML colour string like FFEEDD to a Gloss Color?
07:50:16 <edwardk> the main thing you need to do is capture the caret during parsing
07:50:34 <edwardk> yeah
07:50:40 <danking> Hey all, I
07:50:45 * hackagebot yesod-auth-oauth 1.3.0 - OAuth Authentication for Yesod.  http://hackage.haskell.org/package/yesod-auth-oauth-1.3.0 (MichaelSnoyman)
07:51:28 <danking> I'd really like to parse a grammar which needs an LALR(2) parser. How dead is frown? Also, is this the only extant repository? https://github.com/strake/frown
07:51:54 <napping> happy glr mode should handle that too
07:52:06 <napping> if you're having trouble with frown
07:52:06 <danking> Oh really now?
07:52:08 <danking> Hmm.
07:52:19 <napping> yeah, you should be fine with the simple tree decoding if it's really unambiguous
07:52:45 <edwardk> this reminds me  should really finish valiant
07:54:09 <danking> Mmm.
07:54:13 <danking> I should make sure it really is unambiguous
07:54:25 <napping> So in Text.Trifecta.Rendering you're just supposed to use render?
07:55:28 <edwardk> yeah
07:55:46 <napping> Well, that explains why the other stuff is fairly mysterious
07:55:48 <edwardk> and you can 'addCaret' etc. to draw on the same line
07:56:18 <napping> Oh? well, what things render to a single line?
07:56:38 <edwardk> f you wanted to draw a line of code and put two spans on it, a caret, a fixit, tc.
07:56:40 <notdan> hm, am I right to say that there is an isomorphism between `Yoneda Endo` and `ContT a Maybe a`?
07:57:09 <edwardk> notdan: doesn't sound right
07:57:11 <napping> Sounds like that would require making Delta from scratch
07:57:40 <edwardk> you can use th delta from the other caret
07:57:59 <notdan> edwardk: ok, what does the following mean than: Yoneda Endo can be made into a monad -- the continuation passing style version of the Maybe monad!
07:58:19 <edwardk> you can also mash renderings together as  monoid
07:58:23 <napping> Ah, I guess you're supposed to use near yourself to see if they are on the same line
07:58:30 <edwardk> Yoneda Endo is isomorphic to Maybe
07:58:37 <napping> and never create a Delta yourself
07:58:43 <benzrf> what is the yoneda lemma anyeway
07:58:44 <benzrf> *anyway
07:59:15 <edwardk> Yoneda Endo a = forall r. (a -> r) -> r -> r     if you pass that Just and Nothing you get out a Maybe
07:59:21 <notdan> edwardk: can we express this isomorphism in haskell?
07:59:39 <notdan> oh
07:59:45 <edwardk> notdan: sure write foo :: Maybe a -> Yoneda Endo a    and bar :: Yoneda Endo a -> Maybe a
07:59:50 <edwardk> and show they are inverses on paper
08:00:00 <notdan> makes sense
08:00:03 <notdan> thanks
08:00:31 <edwardk> Codensity Endo gives you LogicT ;)
08:00:41 <benzrf> what's codensity ;-;
08:00:51 <benzrf> :k Codensity
08:00:52 <lambdabot>     Not in scope: type constructor or class ‘Codensity’
08:01:01 <edwardk> Codensity f a = forall r. (a -> f r) -> f r
08:01:02 <notdan> edwardk: yeah codensity still gives me headache
08:01:06 <edwardk> see my kan-extensions package
08:01:07 <quickezed> I'm trying to write the solution to a basic exercise of parsing a log file and constructing correct LogMessage types for each line. I feel as though my solution is horribly imperative with the let statements but honestly I don't have a good feel for this.
08:01:08 <notdan> wanted to start with something eaither
08:01:10 <quickezed> My code: http://lpaste.net/105739
08:01:12 <notdan> like Yoneda :)
08:01:19 <hellen_haskeller> anyone using haskell as a database?
08:01:25 <notdan> i do understand it in category theory.. but it takes to to apropriate it in haskell
08:01:36 <benzrf> edwardk: how is that different from Cont
08:01:40 <notdan> https://gist.github.com/co-dan/e290d83f783e73960ce6
08:01:41 <quickezed> Some feedback would be greatly appreciated.
08:01:46 <edwardk> benzrf: forall r.
08:01:49 <notdan> benzrf: http://comonad.com/reader/2011/free-monads-for-less/
08:01:51 <benzrf> edwardk: hmmm
08:01:54 <jhance> quickezed: Do you wish to not use parser combinators?
08:01:55 <notdan> benzrf: http://comonad.com/reader/2011/free-monads-for-less-2/
08:01:56 <edwardk> keeps you from calling callCC ;)
08:02:03 <benzrf> :t callCC
08:02:05 <lambdabot> MonadCont m => ((a -> m b) -> m a) -> m a
08:02:13 <edwardk> Cont r a ~ Codensity (Const r) a
08:02:25 <benzrf> h-heuh
08:02:37 <benzrf> ok
08:02:54 <benzrf> how is it different from 'IsomorphicTo a = forall r. (a -> r) -> r
08:02:55 <edwardk> Codensity f is often much bigger than f
08:03:01 <benzrf> edwardk: oh?
08:03:19 <edwardk> Codensity of ((->) e)  is  actually state!
08:03:26 <edwardk> forall r. (a -> e -> r) -> e -> r
08:03:30 <edwardk> pass it (,)
08:03:34 <edwardk> e -> (a, e)
08:04:03 <benzrf> 11:00 < benzrf> how is it different from 'IsomorphicTo a = forall r. (a -> r) -> r
08:04:13 <quickezed> jhance: I'm only beginning Haskell and am only using things I've come across so far. I'm working my way through these lectures (http://www.cis.upenn.edu/~cis194/lectures) and am only up to number 2.
08:04:16 <benzrf> also, that *is* isomorphic to its parameter, right?
08:04:20 <edwardk> yes
08:04:28 <benzrf> oooooh wait
08:04:32 <edwardk> but Yoneda f a = forall r. (a -> r) -> f r  is also isomorphic to its parameter
08:04:32 <benzrf> i didnt see that f is parameterized
08:04:34 * benzrf facepalms
08:04:44 <benzrf> hmm
08:04:44 <edwardk> Yoneda f a ~ f a
08:04:59 <edwardk> we can generalize this and get the notion of a right kan extension
08:05:11 <benzrf> Codensity f a = forall r. (a -> f r) -> f r
08:05:14 <benzrf> hmm
08:05:15 <edwardk> newtype Ran f g a = Ran { runRan :: forall r. (a -> f r) -> g r }
08:05:23 <benzrf> edwardk: i dont know what a kan is
08:05:40 <edwardk> its the 'f' there in the (a -> f r) ....  that gives Codensity its extra power of Yoneda
08:05:42 <fizruk> a name I think
08:05:46 * hackagebot data-textual 0.3.0.2 - Human-friendly textual representations.  http://hackage.haskell.org/package/data-textual-0.3.0.2 (MikhailVorozhtsov)
08:05:59 <edwardk> http://hackage.haskell.org/package/kan-extensions is the deep end of this topic ;)
08:06:02 <edwardk> but
08:06:19 <edwardk> http://comonad.com/reader/2008/kan-extensions/
08:06:21 <notdan> quickezed: it looks alright
08:06:28 <edwardk> http://comonad.com/reader/2008/kan-extensions-ii/
08:06:33 <jhance> quickezed: You can probably get rid of most of your explicit types when you read. The compiler can infer them because you later use them as arguments to a constructor
08:06:39 <notdan> quickezed: I, personally, wouldn't use list comprehension, but that's just my preference
08:06:40 <jhance> quickezed: As long as that constructor isn't super generic
08:06:52 <benzrf> i dont know what adjoints are either
08:06:52 <edwardk> http://comonad.com/reader/2008/kan-extension-iii/
08:07:00 <benzrf> ughh i dont have the time to dive down this rabbit hole
08:07:06 <notdan> benzrf: hehe
08:07:10 <napping> I'm trying to design some compiler stuff a bit more modularly
08:07:12 <benzrf> i mean, at this moment
08:07:17 <edwardk> f -| g "f is left adjoint to g" whenever (f a -> b) is isomorphic to (a -> g b)
08:07:19 * benzrf blocks advanced edwardk stuff from his brain
08:07:23 <edwardk> lets play with one
08:07:30 <jhance> quickezed: parse = map parseMessage . lines
08:07:36 <edwardk> (, e) -| (->) e
08:07:48 <edwardk> (a, e) -> b   is ismorphic to a -> (e -> b)
08:08:01 <edwardk> why? we can curry and uncurry
08:08:10 <quickezed> jhance: ah, thats much nicer.
08:08:58 <napping> I start with directed graph of module imports. I think everything I want to compute can be described as functions taking a module and possibly the final value from other "passes" and producing a value in a commutative monoid, then then the output of that pass/analysis at a module is the monoidal sum of all those intermediate values for modules reachable from the current module (taking into account cycles)
08:09:02 <edwardk> the notion of a kan extension is one of those 'deep insights' that drives category theory. you can't see all of it in haskell, but you can get a sense of how cool they are at least ;)
08:09:06 <Joy21>  Here some videos. I hope you like them! http://bit.ly/SQqhAX
08:09:30 <napping> edwardk: maybe you have some ideas about a design like that?
08:09:30 <quickezed> jhance: I wasn't too sure about my pattern matching in parseMessage in order to distinguish between the different log message types but couldn't think of any other way to do it.
08:09:46 <notdan> edwardk: do I need to "get" kan extensions before understanding Codensity and Church encoded free monads?
08:09:49 <napping> The main thing I don't see any way to start doing is writing that in a more modular way
08:09:52 <napping> notdan: nope
08:10:03 <notdan> ok that's good
08:10:21 <napping> I don't get kan extensions in any deep way, and Codensity makes plenty of sense
08:11:35 <fizruk> edwardk: i never get how adjunctions relate to optimal solutions, specifically, how it can be seen/used in Haskell, do you have pointers for that?
08:11:42 <edwardk> notdan: understanding it, and why Codensity f is bigger than f is key to understanding the issues in that space, the issues with various extensible effects proposals, etc.
08:11:42 <edwardk> notdan: it isn't strictly necessary to understand those simpler things
08:12:01 <jhance> quickezed: Don't worry too much about it, when you get more experienced you would write this with attoparsec or parsec anyway (probably with some strict io library like pipes or conduit)
08:12:16 <edwardk> fizruk: oh that the left adjoint is the most general solution to a problem and the right adjoint is the most complex problem it solves?
08:12:22 <jhance> quickezed: The pattern matching seems fine for what you want to achieve here
08:12:36 <quickezed> jhance: Ok sure thing. I had heard of parsec and figured that's what you'd use for real
08:12:44 <fizruk> edwardk: yeah that
08:12:47 <jhance> quickezed: Would use a more safe variant of `read` though
08:12:57 <quickezed> jhance: they way you left out the parameter  from "parse = map parseMessage . lines", is this called anything in Haskell, i.e. something I can search to read about?
08:13:00 <edwardk> fizruk: that view is useful when talking about optimization probems, but not so much about talking about types
08:13:23 <fizruk> edwardk: so not very useful when writing Haskell programs?
08:13:23 <jhance> quickezed: Point-free style
08:13:40 <quickezed> jhance: great, thanks
08:14:05 <jhance> @type readMaybe
08:14:07 <lambdabot> Not in scope: ‘readMaybe’
08:14:12 <jhance> @type Text.Read.readMaybe
08:14:13 <lambdabot> Read a => String -> Maybe a
08:14:29 <jhance> Use that instead of `read` and if it gives `Nothing`, you can return an `Unknown`
08:14:31 <edwardk> fizruk: well, i use the adjunction between rank and select all day long, i just don't get to use the cheesy little adjunction class i have for it ;)
08:14:39 <quickezed> jhance: ok cool, thanks!
08:14:51 <napping> I see how to make passes like that Applicative, but not how to share results between multiple clients
08:20:34 <tristanStrange> how does one pass a list as arguments to a function? think its called splatting in coffescript
08:21:57 <jhance> quickezed: Consider something like LogMessage <$> (Error <$> readMaybe e) <*> readMaybe t <*> return (unwords m)
08:21:58 <tdammers> tristanStrange: one doesn't, generally speaking
08:22:03 <benj_> case args of [a, b, c, d] -> f a b c d; _ -> default
08:22:32 <tdammers> what benj_ said, but the problem there is that list length isn't enforced at the type level
08:22:48 <benj_> it's rare you get a function that takes so many args of the same type, too
08:22:49 <tdammers> so you need to explicitly handle incorrectly-sized lists
08:22:54 <quickezed> jhance: ok thanks for the suggestion. I'll spend the rest of the afternoon digesting that :)
08:23:09 <tdammers> a somewhat more suitable data type would be a tuple
08:23:35 <nisstyre> tristanStrange: it actually came from lisp, and it's called (apply f xs), but it doesn't quite make sense in Haskell since Haskell does not really support variable arities
08:23:57 <hellen_haskeller> how does haskells record syntax compare to sql for performance?
08:24:10 <jhance> hellen_haskeller: Huh?
08:24:21 <tdammers> hellen_haskeller: the two cannot be compared because they are completely different things
08:24:39 <armlesshobo> hellen_haskeller: record syntax is to reference data in a value
08:25:11 <chrisdone> λ> formatTime defaultTimeLocale "%s" day → ""
08:25:11 <chrisdone> λ> formatTime defaultTimeLocale "%s" (UTCTime day 0) → "1402963200"
08:25:21 <chrisdone> this is why stringly-typed formatters suck
08:25:29 <jhance> quickezed: Thats an expression of the form String -> String -> String -> Maybe LogMessage
08:26:03 <hellen_haskeller> trying to compare how haskell can just replace the functions of sql for example
08:26:22 <dottedmag> functions of sql?
08:26:36 <hellen_haskeller> skip the need for a database programe
08:26:50 <jhance> jhance: So if you bind that to a function of e,t,m, then you can write something like maybe (Unknown l) return (f e t m) :: I'm sure theres a better way to write that, maybe probably isn't the best way
08:26:55 <armlesshobo> hellen_haskeller: http://lpaste.net/105740
08:27:13 <Maxdamantus> You used a database because you wanted records?
08:27:17 <jhance> quickezed: Or just case f e t of Nothing -> Unknown l otherwise -> Just t -> t
08:27:31 <jhance> quickezed: (ignoring that random otherwise that I put in there for some reason...)
08:28:04 * Maxdamantus wonders what interpreter that is.
08:28:04 <quickezed> jhance: ah ok, nice. that looks much more idiomatic than what I have.
08:28:21 <Maxdamantus> wait, that works in ghci?!
08:28:22 <jhance> hellen_haskeller: Are you thinking of compiling your database as haskell code or something? Cause don't
08:28:37 <atticus> ^lolz
08:28:43 <Maxdamantus> Has that always worked, or have I always just tried the wrong thing?
08:29:01 <jhance> Maxdamantus: It was added in the 7 line somtime
08:29:07 <Maxdamantus> Ah.
08:29:51 <atticus> jhance: I think hellen_haskeller is just looking for a haskell sql interface or something, which is kind of a difficult question to word possibly
08:30:05 <Maxdamantus> Since 7.4.1
08:30:11 <nisstyre> Maxdamantus: this also works http://lpaste.net/105741
08:30:47 <jhance> atticus: I guess he/she wants to skip SQL (at least on the dev end) and use a database directly from records? Which is possible using code-generation techniques... Idk the wording of the question is really weird
08:31:13 <benj_> let's all infer a different question and answer it
08:31:17 <benj_> I think you want acid-state!
08:31:22 <tristanStrange> cheers chaps!
08:31:30 <atticus> I agree with benj_
08:31:43 <atticus> are you looking for a monadic parser generator?
08:31:57 <jhance> parsers?!
08:32:00 <atticus> definitely try handsomesoup
08:32:19 <atticus> wait i thought the goal was to be confusing
08:32:53 <armlesshobo> hellen_haskeller: are you talking about interacting with a DB via Haskell?
08:33:04 <armlesshobo> because Haskell itself isn't a DBMS
08:33:44 <armlesshobo> i think "record syntax" threw you off, but it has nothing to do with DB.
08:34:45 <armlesshobo> hellen_haskeller: record syntax allows you to "get" data from a value
08:35:01 <napping> Is there a nice library for TypeRep-indexed maps?
08:36:46 <benzrf> napping: why are you doing that
08:38:14 <napping> mokus: Is dependent-map yours? There's a broken "Data.Dependent.Tag" in the haddocks
08:38:26 <quickezed> jhance: what does <$> mean?
08:38:39 <napping> benzrf: I want a type-indexed map
08:39:05 <benzrf> napping: gros
08:40:24 <Maxdamantus> @src (<$>)
08:40:25 <lambdabot> f <$> a = fmap f a
08:40:46 <quickezed> Maxdamantus: thanks, I'll remember src.
08:40:50 * hackagebot monad-gen 0.1.0.0 - A simple monad for generating fresh integers  http://hackage.haskell.org/package/monad-gen-0.1.0.0 (jozefg)
08:41:39 <quickezed> @src (<*>)
08:41:40 <lambdabot> Source not found. I feel much better now.
08:41:57 <BigTimothy> Hi there.  New to haskell here.  What's an elegant way to apply combine the output of two ( a -> Bool ) functions?  I could do \x -> ( f x ) & ( g x ).  But this seems clumsy to put as, say, an argument to a map.  Is there a better way?
08:42:01 <hexagoxel_> better remember hoogle
08:42:04 <Maxdamantus> (<*>) is defined separately for each `Applicative a` instance.
08:42:07 <jamie_h_> how can I pattern match a record? I want to check whether an element inside it is an empty list
08:42:19 <Gurkenglas> Is there an extension to hoogle or another bot that, given the type of a function a->b gives you an a, and then given a b gives you a function of that type that would map a to b?
08:43:03 <Gurkenglas> *that a to that b
08:43:19 <napping> BigTimothy: I doubt it's better, but you can do liftM2 (&&) f g
08:43:20 <jhance> quickezed: At your level, just think that the following are equivalent: f <$> a <*> b <*> c and a >>= \a' -> b >>= \b' -> c >>= \c' -> f a' b' c'
08:43:22 <Maxdamantus> @djinn a -> b
08:43:23 <lambdabot> -- f cannot be realized.
08:43:42 <jhance> quickezed: Very common structure, but if you are only 2 chapters in, I wouldn't try to understand (<*>)
08:43:47 <Maxdamantus> @djinn (a, a -> b) -> b
08:43:47 <lambdabot> f (a, b) = b a
08:43:59 <hexagoxel_> "given a b" -> dont use "a" as variable identifier :D
08:44:07 <jhance> quickezed: The monad equivalent of <*> is `ap`
08:44:15 <BigTimothy> napping: Interesting.  Isn't liftM2 for monads?  Where's the monad here?
08:44:32 <Fernandos> hi
08:44:33 <napping> The instance Monad (-> r) for readers
08:44:36 <Maxdamantus> liftM2 is different.
08:44:37 <geekosaur> jamie_h_, I think Foo { field=[] }
08:45:11 <napping> return v = \x -> v, m >>= f = \x -> f (m x) x
08:45:20 <quickezed> jhance: Haha ok thanks. I only have a very minimal understanding of monads so whilst i don't fully understand each part of the code I have a feeling for what is going on.
08:45:21 <armlesshobo> BigTimothy: i don't think so
08:45:40 <Gurkenglas> hexagoxel_, it was meant to mean "given some value of type b"
08:45:41 <hexagoxel_> Gurkenglas: but you can just input "a->b" to hoogle
08:45:50 * hackagebot hspec-attoparsec 0.1.0.0 - Utility functions for testing your attoparsec parsers with hspec  http://hackage.haskell.org/package/hspec-attoparsec-0.1.0.0 (AlpMestanogullari)
08:45:52 <Gurkenglas> hexagoxel_, that gives too many functions :>
08:46:23 <Gurkenglas> @djinn 23523 -> [23523]
08:46:23 <lambdabot> Cannot parse command
08:46:40 <jhance> quickezed: Instead of <$> and <*>, f <$> a <*> b <*> c is also Control.Applicative.liftA3 f a b c
08:46:44 <napping> BigTimothy: there's also Monoid, which has an instance that works pointwise if the result is a monoid
08:46:52 <jhance> quickezed: the <$>/<*> is a more flexible structure that extends to any number of args, tho
08:46:59 <Fernandos> Just asked my prof about the difference between Components and Modules. He couldn't really explain it. But said the difference maybe in the runtime- vs linking- phase integration. I thought they differ in their compositionality.
08:47:04 <napping> BigTimothy: except you can't just take Bool, you'd have to wrap in Any / All to pick the monoid
08:47:43 <napping> getAll (All . f <> All . g)
08:47:44 <Maxdamantus> @src liftA2
08:47:44 <lambdabot> liftA2 f a b = f <$> a <*> b
08:47:48 <napping> so no, I don't think there's a nicer way
08:47:49 <Maxdamantus> @src liftA3
08:47:49 <lambdabot> Source not found. Take a stress pill and think things over.
08:48:05 <Fernandos> pharmabot? ;)
08:48:11 <BigTimothy> napping:  Yeah.  Not much smaller, but still really interesting.  I'll have to think on these for a bit.
08:48:16 <jhance> @src Control.Applicative.liftA3
08:48:16 <lambdabot> Source not found. Whoa.
08:48:16 <armlesshobo> BigTimothy: what you have there seems clean anyway.
08:48:19 <Gurkenglas> :t foldr ($) 0 $ replicate 4 (\x->[x])
08:48:20 <lambdabot>     Occurs check: cannot construct the infinite type: t ~ [t]
08:48:20 <lambdabot>     Relevant bindings include x :: [t] (bound at <interactive>:1:29)
08:48:20 <lambdabot>     In the expression: x
08:48:32 <napping> If you're using a list comprehension you'll have a binding for x anyway
08:48:35 <quickezed> jhance: Ok great, thanks. I've got my reading set out for me :)
08:48:45 <fizruk> :t alaf
08:48:46 <lambdabot> (Rewrapped t s, Rewrapped s t, Profunctor p) => (Unwrapped s -> s) -> (p r t -> e -> s) -> p r (Unwrapped t) -> e -> Unwrapped s
08:49:00 <Fernandos> What is the difference between a Module and a Component in Haskell? Is there even a component concept?
08:49:04 <napping> Those sorts of things are nicer for slightly bigger stuff or things designed in advance to work with them, but a bit bigger here
08:49:18 <batz> Hey there, sry Im new to Haskell and have a question about record syntax. If I want to create multiple instances of a record from a list of entries, how is the syntax for this in Haskell?
08:49:22 <napping> Fernandos: is there a Compoent concept in any language?
08:49:50 <armlesshobo> batz: http://lpaste.net/105740
08:50:02 <Fernandos> napping: I don't know. Not an explicit one, that I know of (except webcomponents).
08:50:03 <armlesshobo> batz: record syntax allows you to create accessor functions to values
08:50:13 <armlesshobo> batz: you don't actually create records with record syntax
08:50:33 <napping> modules are a pretty explicit concept, especially the ML flavor that Haskell kind of follows
08:50:54 <batz> armlesshobo: yes, but I want to create multiple entries given a list of attributes
08:51:10 <armlesshobo> batz: you wouldn't use record syntax for that
08:51:27 <Fernandos> Modules in Haskell are comparable to packages in scala I guess, right?
08:51:43 <marchelzo_> can someone give me a hint on how to solve this? http://rosalind.info/problems/fibd/
08:52:01 <batz> armlesshobo: like this here: "let records = Record { attribute = list_of_attribute_values:[] }"
08:52:01 <Gurkenglas> Why doesn't this work?
08:52:04 <Gurkenglas> > foldr ($) 0 $ [\x->[x]]
08:52:05 <lambdabot>  Occurs check: cannot construct the infinite type: t ~ [t]
08:52:05 <lambdabot>  Relevant bindings include x :: [t] (bound at <interactive>:1:17)
08:52:33 <Gurkenglas> Scratch the second $
08:53:16 <fizruk> BigTimothy: note that you don’t need some parentheses: map (\x -> f x && g x) reads OK to me
08:53:24 <Maxdamantus> > let universe = undefined in [x | x <- universe, x `elem` [x]]
08:53:25 <lambdabot>  *Exception: Prelude.undefined
08:53:27 <batz> armlesshobo: list comprehension and "map" is also not the way to do it?
08:53:33 <Maxdamantus> er
08:53:43 <BigTimothy> fizruk:  Thanks! Good to know.
08:54:05 <fizruk> there’s nothing bad in lambdas, seriously ;)
08:54:15 <BigTimothy> Haha.  Okay.
08:54:18 <Maxdamantus> > let universe = undefined in [x | x <- universe, x `elem` x]
08:54:20 <lambdabot>  Occurs check: cannot construct the infinite type: t ~ [t]
08:54:20 <lambdabot>  Relevant bindings include x :: t (bound at <interactive>:1:34)
08:54:35 <armlesshobo> batz: does each record have a same number of attributes?
08:55:10 <hexagoxel_> BigTimothy: also, \x -> ((&&) `on` ($x)) f g
08:55:30 <batz> armlesshobo: No, indeed, I use one base list with "subsequences" of Data.List (the Attribute is a list itself)
08:55:47 <BigTimothy> Woah.
08:55:51 * hackagebot hspec-attoparsec 0.1.0.1 - Utility functions for testing your attoparsec parsers with hspec  http://hackage.haskell.org/package/hspec-attoparsec-0.1.0.1 (AlpMestanogullari)
08:55:52 <stack> is this http://www.cs.nott.ac.uk/~gmh/book.html  THE book to read ?
08:55:53 <BigTimothy> @src on
08:55:53 <lambdabot> (*) `on` f = \x y -> f x * f y
08:56:20 <fizruk> Gurkenglas: what would the result type be?
08:56:34 <armlesshobo> batz: yes you do? or no you don't?
08:57:10 <armlesshobo> batz: i don't think i know enough about what you have going on the really help you.
08:57:25 <batz> armlesshobo, OK, thank you
08:57:27 <batz> anyway :D
08:57:42 <rntz> Can anyone explain why ghc asserts there is a syntax error in this program: http://sprunge.us/CdWD?hs
08:57:58 <rntz> it claims line 13 has "possibly incorrect indentation or mismatched brackets"
08:58:03 <BigTimothy> @src ($)
08:58:03 <lambdabot> f $ x = f x
08:58:08 <fizruk> rntz: tabs/spaces?
08:58:09 <rntz> which is completely befuddling to me, because it's a perfectly ordinary instance declaration
08:58:14 <roelof> Im a absolute beginner in Haskell . Which test platform can I learn the best.  I know that the eclipse plugin uses HTF a lot ?
08:58:20 <Gurkenglas> fizruk, the result would be [0]
08:58:26 <fizruk> rntz: oh, you don’t have the RHS
08:58:35 <rntz> fizruk: nope, not tabs vs spaces.
08:58:36 <jhance> rntz: You didn't enable extension for GADT?
08:58:41 <rntz> oh, d'oy, me stupid
08:58:41 <fizruk> rntz: Isa List == Isa List = <definition here>
08:58:42 <monochrom> rntz: you have incomplete code. Isa List == Isa List = True
08:58:44 <armlesshobo> batz: i mean, if you're trying to create a value, then you'd use what you had above
08:58:48 * rntz stuck in prolog mode
08:58:58 <rntz> clearly I should only have to list the true cases! :P
08:59:02 <rntz> thanks!
08:59:08 <Gurkenglas> > foldr ($) 0 $ [\x->x+1]
08:59:10 <lambdabot>  1
08:59:11 <armlesshobo> Record { attribute = yourList }
08:59:11 <monochrom> in a theorem prover, I would agree.
08:59:19 <armlesshobo> batz: Record { attribute = yourList }
08:59:28 <Gurkenglas> > (\x->x+1) $ 0
08:59:30 <lambdabot>  1
08:59:31 <batz> armlesshobo: I know how to create one instance, but I wanted to automate that in order to create a list of instances
08:59:34 <Gurkenglas> > (\x->[x]) $ 0
08:59:35 <lambdabot>  [0]
09:00:20 <monochrom> "if I am the king of France is true, then I am bald is true" :)
09:01:52 <fizruk> Gurkenglas: foldr expects accumulator to have the same type thoughout folding, while you are wrapping it in a list every iteration
09:02:48 <Gurkenglas> fizruk, but the last result is allowed to be of another type? O_o
09:02:49 <armlesshobo> batz: [Record { attribute = x } | x <- [att0, att1]]
09:03:08 <fizruk> :t foldr
09:03:09 <lambdabot> (a -> b -> b) -> b -> [a] -> b
09:03:29 <fizruk> Gurkenglas: accumulator has the same type as result ^
09:04:00 <fizruk> Gurkenglas: so `foldr ($) 0` already tells you the type of the result
09:04:05 <fizruk> :t foldr ($) 0
09:04:06 <lambdabot> Num b => [b -> b] -> b
09:04:09 <Gurkenglas> Wait, I meant something else, which also was stupid, so nevermind that last question
09:04:14 <batz> armlesshobo: A, that may do the trick, thank you
09:04:16 <Maxdamantus> Gurkenglas: otherwise you'd have a type dependent on the number of elements in the list.
09:04:58 <Gurkenglas> Instead, let my :00:20 line be "Oh, right, should have noticed that myself, thanks"
09:05:13 <fizruk> Gurkenglas: as you can see `foldr ($) 0` expects a list of (b -> b) functions, so compiler is confused when you pass it (b -> [b]) function
09:05:56 <alcabrera> batz, armlesshobo: map (\x -> Record {attr = f x}) xs -- should also work
09:06:11 <roelof> Do someone use a test platform on Haskell  and if so, which one ?
09:06:40 <batz> alcabrera, armlesshobo: Just tested it both, both work great, thank you very muchg
09:07:05 <alcabrera> yay!
09:08:44 <armlesshobo> alcabrera: yes that too :)
09:09:04 <abaw> /?
09:09:18 <Gurkenglas> I think I assumed that if that was the problem, I would have gotten a type collision
09:09:19 <armlesshobo> batz: you're welcome. glad I can help.
09:11:11 <abaw> Hi, I want to ask a question about using Control.Error for error handling.
09:11:28 <abaw> I am learning to use EitherT to do the error handling
09:11:51 <abaw> But I was stuck with the function "withSocketsDo"
09:12:16 <abaw> I have a function f :: EitherT String IO ()
09:12:30 <abaw> But in f, I need to use withSocketsDo to perform some network operations
09:12:40 <abaw> while withSocketsDo has a type IO () -> IO ()
09:12:59 <abaw> How could I get back to EitherT String IO () after calling withSocketsDo???
09:13:01 <monochrom> it is safer to use withSocketsDo right at main
09:13:29 <abaw> So it means that I should assume withSocketsDo is always called at main
09:13:30 <monochrom> main = withSocetsDo (the rest of your program. all of it.)
09:13:39 <abaw> so other function does not need to call withSocketsDo at all, right?
09:13:57 <monochrom> the thing is some weird problem may happen if you call it the second time
09:14:24 <abaw> thanks for the information. I was not aware of that.
09:15:52 * hackagebot fences 0.1 - To be written  http://hackage.haskell.org/package/fences-0.1 (HansHoglund)
09:15:54 * hackagebot fences 0.1.1 - To be written  http://hackage.haskell.org/package/fences-0.1.1 (HansHoglund)
09:19:36 <yitz> ooo, now hans hoglund is also competing for simple name real estate on hackage. edwardk and chrisdone, look out!
09:20:54 * hackagebot purescript 0.5.2.4 - PureScript Programming Language Compiler  http://hackage.haskell.org/package/purescript-0.5.2.4 (PhilFreeman)
09:20:56 <bergmark> hah that's sketchy >:|
09:21:26 <yitz> bergmark: but transf, which it is replacing, looks like a great idea for a utility
09:23:36 <structuralist> Are `Fix F` and `exists x. (x, x -> F x)` isomorphic?
09:28:47 <Jefffrey> hello
09:33:18 <rwbarton> does cabal.sandbox.config completely override my .cabal/config?
09:34:12 <davd> Jefffrey: hello! feel free to ask a question.
09:34:21 <rwbarton> oh, perhaps it's cabal.config that would override ~/.cabal/config
09:34:28 <Lutin`> rwbarton: iirc it's passthrough
09:34:40 <rwbarton> hmm that doesn't seem to have worked either
09:34:41 <rwbarton> indeed
09:35:09 * rwbarton will just play games with mv-ing ~/.cabal/config around
09:35:22 <Lutin`> What are you needing to do?
09:35:29 <davd> [Q] anyone know a good intro to Martin-Löf theory? I only know some basic category theory and haskell.
09:36:44 <rwbarton> Lutin`: I want to install a package in a sandbox using the default ~/.cabal/config
09:36:50 <rwbarton> for reproducing a GHC bug
09:37:08 <rwbarton> however if I try --config-file /dev/null then it seems to also ignore my sandbox config
09:37:20 <rwbarton> or maybe the problem is that --config-file /dev/null just doesn't work
09:37:46 <rwbarton> anyways I just stashed away my customized config and let cabal make a new ~/.cabal/config
09:37:50 <abaw> @pl \a b -> return (a,b)
09:37:50 <lambdabot> (return .) . (,)
09:38:16 <Lutin`> davd: Maybe http://www.cse.chalmers.se/research/group/logic/book/book.pdf
09:39:04 <Geir_> part
09:39:25 <napping> Does anyone know how to tweak the help messages from optparse-applicative for subcommands?
09:39:48 <Yahweh> This is a math related question but somehow I think I would garner better responses here. Does anyone have any comments or suggestions about the way I serialized algebra here: http://lpaste.net/105742 ?
09:40:28 <napping> I'd like the help message if you didn't supply a command to include the list of commands (which I only get by default with -h), and to use a different line of description in the command list vs. as the "program description" for the help for the subcommand
09:42:37 <marchelzo_> Can someone give me a hint for solving this: http://rosalind.info/problems/fibd/ I have tried several different approaches but I just can't get it to work.
09:43:35 <cjay> Is there an idiomatic way to do partial application on "if then else"? Does everybody just define their own "if'"?
09:43:56 <Iceland_jack> cjay: there is a 'bool' function
09:43:59 <marchelzo_> This is what I have as of right now: http://lpaste.net/105743
09:44:16 <Iceland_jack>     Data.Bool.bool :: a -> a -> Bool -> a
09:44:43 <klrr_> :t bool
09:44:44 <lambdabot> a -> a -> Bool -> a
09:44:44 <benzrf> :t bool
09:44:45 <lambdabot> a -> a -> Bool -> a
09:44:47 <benzrf> oh
09:44:50 <klrr_> ha
09:44:52 <benzrf> bool 1 2 True
09:44:57 <benzrf> where is bool defined
09:44:58 <cjay> Iceland_jack: cool thanks
09:44:59 <benzrf> > bool 1 2 True
09:45:01 <lambdabot>  2
09:45:01 <klrr_> > bool 1 2 True
09:45:03 <lambdabot>  2
09:45:05 <benzrf> is it prelude?
09:45:09 <Iceland_jack> <Iceland_jack>     Data.Bool.bool :: a -> a -> Bool -> a -- benzrf
09:45:32 <benzrf> oh oops
09:45:35 <benzrf> >.<
09:47:13 <cjay> hmm that's not in the current platform yet
09:47:21 <Iceland_jack> it's in 7.8
09:47:58 <Lutin`> marchelzo_: You could use something like `type Age = Int; data RabbitPair = KitPair | AdultPair Age`
09:49:06 <marchelzo_> Lutin`: and then keep a list of RabbitPairs?
09:49:19 <Lutin`> Yeah
09:50:12 <marchelzo_> but how would I get to the next generation?, say I had [KitPair, AdultPair 2, AdultPair 1]
09:50:43 <marchelzo_> I would need to get to [KitPair, KitPair, AdultPair 2, AdultPair 1]
09:50:44 <Lutin`> Create some step function and map it over the list
09:50:54 <Lutin`> mapConcat
09:51:12 <Lutin`> I mean concatMap
09:51:14 <Jefffrey> davd: I've just answered mine by myself. But Thanks. :D
09:51:18 <Lutin`> :t concatMap
09:51:19 <lambdabot> (a -> [b]) -> [a] -> [b]
09:52:11 <marchelzo_> Lutin`: ah, that is the perfect function in this case. But there is still a problem. Iterating over the entire list every generation is really slow.
09:53:26 <marchelzo_> I'll try it and see, but the actual n and m that they give you for the problem are much larger than in the example, and I'm not sure if this method will work.
10:00:18 <Lutin`> marchelzo_: You could have the step function age more than one month
10:01:10 <dottedmag> What is Const type used for?
10:01:11 <marchelzo_> I like that idea.. not sure how to implement it correctly, though.
10:02:59 <dottedmag> Also, are Haskell's Functor and functors from cathegory theory different?
10:03:11 <S11001001> dottedmag: (Traversable f, Monoid b) => (a -> b) -> f a -> b
10:04:36 <dottedmag> S11001001: this one is a type of fold over a traversable structure. Not sure I understand how it is related either to Const or Functors.
10:05:04 <S11001001> dottedmag: among other things, Const is useful for the implementation of said fold
10:07:09 <zebr> has the module Control.Monad.State.Lazy moved?
10:07:21 <klrr_> (a -> f a) -> g a -> f a, anyone know such a function?
10:07:23 <zebr> i'm compiling some slightly-old code and it's not liking that
10:08:35 <klrr_> generalized concatMap
10:08:46 <klrr_> oh foldable
10:09:00 <klrr_> meh not really
10:09:41 <klrr_> is there any function like Data.Foldable.concatMap but the list and the t switched place?
10:10:39 <marchelzo_> How would I implement memoization in Haskell. Like for example, computing the nth fibonacci number without doing the same calculations over and over again.
10:10:58 <marchelzo_> The first period should be a question mark
10:11:00 <S11001001> klrr_: (a -> t b) -> [a] -> t b?
10:11:06 <klrr_> S11001001: yes
10:11:17 <S11001001> klrr_: do you have Monoid (t b)?
10:11:28 <klrr_> yes
10:11:32 <S11001001> klrr_: foldMap
10:11:50 <koala_man> marchelzo_: did you already look at google's wealth of memoized fibonacci haskell implementations?
10:11:52 <klrr_> awesome thanks
10:13:51 <Denommus> I have a list of strings, and I want to produce a dictionary which its index is each element of the list, and the value is how many times that element is repeated. How can I do that?
10:16:52 <Qfwfq> @type M.insertWith
10:16:53 <lambdabot> Ord k => (a -> a -> a) -> k -> a -> M.Map k a -> M.Map k a
10:17:12 <Daniela21>  Hi! I give you some videos. I hope you like! http://bitly.com/1lvQiSM
10:17:14 <marchelzo_> koala_man: ok, I am looking at http://stackoverflow.com/questions/11466284/how-is-this-fibonacci-function-memoized. How could I implement something similar for the rabbits thing?
10:18:37 <koala_man> marchelzo_: which rabbits thing?
10:19:18 <koala_man> Denommus: Qfwfq's function is a hint for you btw
10:19:20 <marchelzo_> http://lpaste.net/105747, this is my code. It takes really long to run for large inputs
10:19:24 <marchelzo_> koala_man:
10:20:05 <marchelzo_> I don't know how to make it faster, I was thinking I could implement some type of memoization but I'm not sure how.
10:21:50 <Denommus> Qfwfq: thanks
10:22:08 <benzrf> hows it goin Denommus
10:22:20 <Denommus> benzrf: all fine
10:22:32 <klrr_> is it possible to have overloadedstring in the repl?
10:22:50 <rwbarton> yes. :set -XOverloadedStrings
10:22:57 <rwbarton> or ghci -XOverloadedStrings
10:23:00 <klrr_> my god... thank you
10:23:12 <klrr_> is it possible to set in config?
10:23:22 <Qfwfq> Just write the :set line to .ghci.
10:23:33 <int-e> .ghci is just a script of ghci commands after all
10:23:42 <tulcod> which cabal hook should i use to generate a C source file that is to be compiled into my haskell library?
10:26:23 <int-e> tulcod: while preBuild looks closer to "the right thing", postConf provides more information. anyway I'd use one of those two
10:26:48 <tulcod> int-e: in that case, how do i find out where to write my C file to?
10:27:04 <tulcod> cause it seems like in postConf, dist/build doesn't exist yet, whereas preBuild isn't told which direcotry is the build dir
10:27:39 <tommd> edwardk: Why are all your package build types Custom when Simple appears sufficient for any modern configuration?
10:28:38 <Lutin`> marchelzo_: Instead of using a list of them, consider a tuple (KitPairs, AdultPairs)
10:29:46 <Lutin`> or actually a list [kits, adults2, adults3 .. adults m]
10:29:51 <int-e> tulcod: Distribution.Simple.BuildPaths has utility functions for that
10:30:06 <edwardk> tommd: take lens, the setup sets up a Build_doctest file for me that lets me know the package dependencies so that doctest works more portably. it also copies the Hierarchy.png image into the haddock dir
10:30:55 <edwardk> tommd: without it what happens is if the end user runs the test suite outside of a sandbox and has two versions of one of the deps installed and exposed in ghc-pkg then doctests break
10:31:02 <int-e> tulcod: but I'm not sure whether the case of a generated C file is covered nicely by that. I've not run into a case where I needed that
10:31:21 <edwardk> tommd: it is a minority problem, but a very real problem
10:31:57 <tulcod> int-e: umm... which function should i be looking at? they either take a FilePath or LocalBuildInfo
10:32:08 <tommd> edwardk: OK, that helps (FYI, in the middle of making libraries work on HaLVM and lens is slightly tricky).
10:32:10 <tommd> Thanks
10:32:26 <int-e> tulcod: for reference, autogenModulesDir lbi = buildDir lbi </> "autogen" -- where lbi :: LocalBuildInfo
10:32:30 <edwardk> tommd: do you have a stage2 build there?
10:32:37 <tommd> yep
10:32:50 <edwardk> tommd: ok, then its not hopeless, just tricky ;)
10:33:01 <tulcod> int-e: well yes, but like i said, "buildDir lb" doesn't exist yet during postConf
10:33:16 <int-e> tulcod: the postConf hook gets a LocalBuildInfo parameter.
10:33:21 <marchelzo_> Lutin`: you mean like [3, 4, 0] would be like 3 kits, 4 Adult 1s, and 0 Adult 2s ?
10:33:22 <int-e> hmm
10:33:27 <edwardk> i have other packages that actually need their custom builds for various technical reasons
10:33:38 <Lutin`> marchelzo_: Ahh just realized something
10:33:52 <edwardk> e.g. rounded uses it to build mpfr, etc.
10:34:05 <tommd> edwardk: actually no! I'm confusing the numbers 2 and 1...
10:34:31 <Lutin`> marchelzo_: So you can actually do this as a recurrence relation
10:34:33 <tommd> Most packages (yours included) function with Simple build, so that gets me limping.
10:35:07 <edwardk> tommd: then you're in for a world of pain. lens internally uses TH, which needs stage2. that said, debian has patches to make it build on stage1 in crippled form
10:35:25 <marchelzo_> Lutin`: That's what I tried originally. I couldn't figure out the relation, though. Or at least I wasn't implementing it correctly.
10:35:41 <marchelzo_> I tried to use recursion to do something similar to: http://stackoverflow.com/questions/17310051/fibonacci-rabbits-dying-after-arbitrary-of-months
10:35:49 <edwardk> and i've offered to take patches to modify it to run in stage1 if they don't cost us functionality (e.g. you can link against template-haskell, just not call use the TemplateHaskell extension)
10:35:54 <tommd> edwardk: Oh, was TH your worry?  No, awick has a work around that I am leveraging.
10:37:06 <edwardk> if you get stuck on any of my packages, take a look at the debian builds for them, they usually rip out just enough to make it stage1 friendly
10:37:18 <miquito> do I need to do one layout for each type of device? mdpi, hdpi,ldpi,xhdpi, xxhdpi? how do I tell android to use either? will it take from the appropriate folder based on device? so I just keep a layout with the same name in all my folders?
10:37:26 <marchelzo_> Lutin`: I have to go. I'll try to figure out how to do it. Thanks for the help, though.
10:37:33 <tommd> edwardk: Very good to know.
10:40:43 <luite> just wait one more week until i'm done with my run-th-on-node.js patches an you can run template haskell everywhere! =)
10:41:07 <tommd> ummm, ummmm... I am really trying hard to figure out if that is a joke or not.
10:41:43 <paintcan> i've heard node.js is fully graph database, so that's good news to me
10:43:06 <luite> tommd: it's not, but for now it only works on ghcjs. but it can be generalized to evaluating th outside the ghc process in different settings
10:45:46 <jonathan6> Hi, I'm new to haskell, but plan to use it for a project. In order to do that, I need to define a data type in some way such that I can use it easily. If I want some advice on how to do it, is this the right place to ask?
10:45:56 <luite> unless you treat js as some universal bytecode (ok i guess it actually might be one of the closest things we have, sadly) you might prefer to run some other type of code
10:46:04 * hackagebot fay 0.20.1.1 - A compiler for Fay, a Haskell subset that compiles to JavaScript.  http://hackage.haskell.org/package/fay-0.20.1.1 (AdamBergmark)
10:46:14 <prototrout> jonathan6: yes!
10:46:26 <jonathan6> prototrout: awesome :)
10:48:39 <jonathan6> What I'm going to do is basically to build a graph. The graph is built by taking an initial node, and a set of rules (functions) and apply the function to the nodes in order to create more. Each such node must store a "pointer" to the node it was created from. The bigger problem though, is that the content of a node is of different size, pretty muched described as Node = [Int] [String]
10:50:48 <jonathan6> Defining a type doing just that isn't too difficult, the problem is that the rules need to inspect specific objects in the [int] and [String] lists, and defining them in a simple way is the priority
10:56:22 <atticus> jonathan6: I wish I could give specific help, but don't have tons of time right now. As far as storing "pointers" to other nodes, you might want to google for recursive data types in Haskell. Learn You a Haskell has a good section on it where you build a sort of tree; you could likely expand the same thing to fit your graph situation.
10:59:22 <jonathan6> atticus: I'll look into that then, thank you
11:04:08 <Nik05> a question that just popped up in my head. function composition using . is "evaluated" from right to left. But the >>= is the other way around, isnt that inconsistent?
11:04:35 <exicer> If a monad has an instance of some class, and I then use that monad in a monad transformer, does the monad transformer have an instance of that class ?
11:04:38 <Nik05> well there is =<< but is that used as much as >>=?
11:04:44 <bergmark> Nik05: that's why i use =<< more frequently
11:05:21 <bergmark> Nik05: i imagine >>= is the default because it's closer to do notation
11:05:33 <Nik05> to what notation?
11:06:10 <bergmark> do x <- y; f x = y >>= f
11:06:16 <enthropy> exicer: only if you want to use methods from "some class" without using lift
11:06:18 <jhance> f . g $ x is f (g x) which keeps the order more logical, but it makes more sense to do >>= since its action sequencing not composition
11:06:49 <exicer> enthropy: If I can use them without lift, why would I ever use lift ?
11:07:06 <jle`> Nik05: i actually wrote a rather long thing on (>>=) vs. (=<<) in the context of (.) etc.
11:07:11 <jle`> http://blog.jle.im/entry/inside-my-world-ode-to-functor-and-monad#fn4
11:07:56 <jle`> and i'm sure you have encoutered "do notation"
11:07:57 <Nik05> ah cool thank you
11:08:00 <jle`> main = do
11:08:03 <Nik05> yes i have
11:08:06 <jle`>     str <- getLine
11:08:09 <jle`>     putStrLn str
11:08:36 <jle`> which gets desguared to getLine >>= \str -> putStrLn str
11:08:40 <rwbarton> back in the day people wrote
11:08:48 <rwbarton> main = getLine `bindIO` >>= \str ->
11:08:52 <rwbarton>        putStrLn str
11:08:59 <rwbarton> er, minus ">>="
11:09:12 <rwbarton> before we had a Monad type class
11:09:36 <t7> :t bindIO
11:09:37 <lambdabot> Not in scope: ‘bindIO’
11:09:46 <jle`> aesthetically, (>>=) is a lot more harmonious with lambda syntax and \ and ->
11:09:56 <jle`> f >>= \x -> g x y
11:09:58 <jle`> so pretty!
11:10:03 <enthropy> exicer: I dunno about your specific case, but sometimes you can't write an instance that just applies lift
11:10:03 <t7> pfff
11:10:11 <jle`> wheras (=<<) is a lot more harmonious with the do notation bind syntax
11:10:18 <jle`> x <- g y =<< f
11:10:22 <jle`> so pretty!
11:10:32 <enthropy> exicer: there is no   instance MonadState (StateT s (StateT t m)) t -- for example
11:10:36 <Nik05> hm ;p
11:10:57 <tulcod> in Setup.hs, can I always assume the pwd is the same as the location of Setup.hs?
11:11:15 <jle`> also it might be useful to draw the parallels betweein (=<<), (<=<), ($), and (.)
11:11:20 <exicer> enthropy: Ah, ok. Good to know.
11:11:31 <jle`> (=<<) is ($) for "monadic functions"; (<=<) is (.) for "monadic functions"
11:11:34 <Nik05> :t <=<
11:11:35 <lambdabot> parse error on input ‘<=<’
11:11:39 <Nik05> :t (<=<)
11:11:40 <lambdabot> Monad m => (b -> m c) -> (a -> m b) -> a -> m c
11:11:56 <Zekka> (where a monadic function is Monad m => a - m b and a non-monadic function is a -> b)
11:12:00 <Nik05> .t (.)
11:12:03 <jle`> thank you Zekka
11:12:06 <Nik05> :t (.)
11:12:07 <lambdabot> (b -> c) -> (a -> b) -> a -> c
11:12:11 <Nik05> sorry for the typos
11:12:26 <jle`> parentheses make it better
11:12:34 <bergmark> and <$> is also the same direction as ., =<<, and <=<
11:12:35 <jle`> (<=<) :: (b -> m c) -> (a -> m b) -> (a -> m c)
11:12:52 <jle`> ( . ) :: (b ->  c) -> (a ->  b) -> (a ->  c)
11:12:59 <jle`> so close
11:13:00 <Nik05> jle` lambdabot already gave those
11:13:09 <jle`> i tried with parentheses and alignment
11:13:11 <Qfwfq> I thought lambdabot had (.) defined as fmap?
11:13:13 <jle`> but my alignment skills failed me
11:13:21 <Nik05> :)
11:13:23 <rwbarton> Qfwfq: in the olden days, it did
11:14:04 <armlesshobo> i have yet to use kleisli arrows
11:14:04 <jle`> (=<<) :: (a -> m b) -> m a -> m b
11:14:14 <jle`> ($)   :: (a -> b) -> a -> b
11:14:27 <Zekka> (<$>)   :: (a -> b) -> f a -> f b
11:14:32 <Zekka> alignment =(
11:14:33 <Nik05> and >>= is the default...
11:14:37 <jle`> not "default"
11:14:42 <jle`> just the do notation desugaring
11:14:47 <jle`> i use (=<<) a lot more in practice
11:14:49 <toors> i understand how monads are helpful for effectful functions, but i am having a hard time understanding the purpose and usage of comonads. where should i start reading about them?
11:14:54 <Nik05> :info Monad
11:15:18 <jle`> toors: there's that edwardk tutorial series on cellular automata
11:15:24 <Zekka> toors: Personally, I just learned the types of the comonad operations until I found a usecase for them
11:15:38 <Nik05> isnt (>>=) part of the Monad class and isnt (=<<) just a function?
11:15:44 <jle`> oh yeah
11:15:48 <jle`> it's the default in that sense
11:15:49 <Zekka> (basically what I'm doing with profunctors now)
11:15:58 <jle`> but that doesn't really mean too much
11:16:05 <Nik05> no oke
11:16:05 <Qfwfq> toors: Have you read the sigfpe article on, I think cellular automata? Overton gave a talk on them at MHUG recently, there's a video somewhere.
11:16:09 <jle`> @src (=<<)
11:16:09 <lambdabot> f =<< x = x >>= f
11:16:31 <jle`> (>>=) was more used historically because of `bindIO`
11:16:45 <toors> thank you, im going to take a look at that now
11:17:38 <jle`> kleisli composition is useful the same time you'd use (.) over ($)
11:17:52 <jle`> if you have f $ g $ h $ x you *should* really be doing f . g . h $ x
11:18:05 <jle`> f =<< g =<< h =<< x can be f <=< g <=< h <=< x
11:18:07 <jle`> er
11:18:12 <jle`> f <=< g <=< h =<< x
11:18:33 <Nik05> huh
11:18:45 <jle`> nevermind
11:18:47 <jle`> that doesn't work >_>
11:18:56 <jle`> cause of associativity
11:18:58 <jle`> that sucks
11:19:00 <Nik05> :t (<=<)
11:19:01 <lambdabot> Monad m => (b -> m c) -> (a -> m b) -> a -> m c
11:19:05 <Nik05> :t (=<<)
11:19:06 <lambdabot> Monad m => (a -> m b) -> m a -> m b
11:19:16 <Qfwfq> :t flip (=<<) (.)
11:19:17 <lambdabot> (((a -> b1) -> a -> c) -> (b1 -> c) -> b) -> (b1 -> c) -> b
11:19:24 <phaazon> @pl fst . splitExtension . snd . splitFileName
11:19:24 <lambdabot> fst . splitExtension . snd . splitFileName
11:19:34 <phaazon> @hoogle fst . splitExtension . snd . splitFileName
11:19:36 <lambdabot> Parse error:
11:19:36 <lambdabot>   fst . splitExtension . snd . splitFileName
11:19:36 <lambdabot>        ^
11:19:38 <jle`> anyway you can "pull out" the f <=< g <=< h and name it fgh = f <=< g <=< h and use it in fgh =<< x
11:19:38 <tulcod> is there a reason cppProgram is not in cabal's default program database?
11:20:07 <maybefbi> what is the advantage of knowing yoneda lemma is true?
11:20:17 <statusfailed> Is there up to date documentation on netwire 5?
11:20:40 <notdan> maybefbi: meh
11:20:49 <phaazon> ok, takeBaseName
11:20:57 <maybefbi> notdan, meh?
11:21:02 <phaazon> > takeBaseName "lol/hihi/ahah/ohoh/foo.txt"
11:21:03 <lambdabot>  Not in scope: ‘takeBaseName’
11:21:05 <phaazon> .
11:21:05 <notdan> maybefbi: it's not hard to prove/know that it's true. the hardest part is to make sense of it
11:21:15 <notdan> i dont think it's a big deal
11:21:46 <dcoutts> tulcod: probably not, send us a patch
11:22:00 <maybefbi> how can i use Data.Functor.Yoneda?
11:22:15 <maybefbi> what are some use cases?
11:22:57 <syllogismos> after lot of fiddling i got to install ghc-vis package.. but when I actually use it in ghci, I'm getting this error "ghci: can't load .so/.DLL for: m (addDLL: could not load DLL)" which leads me to https://ghc.haskell.org/trac/ghc/ticket/3242
11:23:13 <syllogismos> what do?
11:23:49 <jle`> statusfailed: isn't it on the package docs?  you can also stop by haskell-game
11:24:13 <notdan> maybefbi: you can use it to "fuse" multiple fmap uses
11:24:28 <notdan> maybefbi: http://comonad.com/reader/2011/free-monads-for-less-2/
11:24:57 <notdan> maybefbi: so lowerYoneda . fmap f . fmap g . liftYoneda can be more efficient vs fmap f . fmap g
11:25:21 <notdan> because it doesnt traverse the strucutre twice
11:25:26 <maybefbi> notdan, hmm let me digest that
11:26:43 <tulcod> dcoutts: in general, what's the point of having this database? like, i know i want to use cppProgram, why do i need to request it from a list?
11:27:29 <dcoutts> tulcod: some programs have special ways to find them or to find their version
11:27:39 <dcoutts> or other special metadata
11:27:41 <tulcod> can i avoid using the database?
11:27:45 <dcoutts> sure
11:28:47 <tulcod> dcoutts: so how do i get a ConfiguredProgram?
11:29:00 <dcoutts> tulcod: so presumably you're writing a custom Setup.hs and using something like requireProgram to get a ConfiguredProgram
11:29:12 <yac> why is this threadDelay sscce not working https://gist.github.com/yaccz/adccd3dda21c68e148cf ?
11:29:14 <tulcod> yeah
11:29:17 <dcoutts> and so you need a Program value to start with
11:29:27 <tulcod> which is not working because cppProgram is not in the db
11:30:37 <rwbarton> yac: threadDelay takes microseconds (10^-6 second)
11:31:06 <yac> oh god
11:31:12 <yac> I confused it with milisecond
11:31:20 <yac> rwbarton: does the precision really is microsecond?
11:31:24 <dcoutts> tulcod: so I don't think you have to have added the program to the db before using requireProgram
11:31:41 <yac> I know linux systemcalls are precise to miliseconds at best
11:31:44 <tulcod> dcoutts: "setup: The program cpp is required but it could not be found"
11:31:57 <rwbarton> yac: the units are microseconds
11:32:07 <rwbarton> yac: the precision is whatever the OS guarantees (usually it makes no guarantees at all)
11:32:09 <dcoutts> tulcod: so you built the Program value using simpleProgram?
11:32:20 <tulcod> cppProgram is in your code
11:32:24 <tulcod> it's just not in the default database
11:32:29 <dcoutts> ah ok, you used that
11:32:30 <tulcod> but yes, it's constructed using simpleProgram
11:32:32 <yac> rwbarton: yeah, thanks I confused the units. Is there actually an OS that can provide microsecond resolution?
11:32:41 <yac> just curiosity
11:32:58 <dcoutts> tulcod: and just to check the obvious, is cpp on your $PATH?
11:32:58 <yac> also, should the function rather take a Microsecond than Int
11:33:03 <tulcod> dcoutts: yes
11:33:28 <rwbarton> yac: don't know
11:33:32 <rwbarton> yac: yes, it is an ugly API
11:33:39 <jhance> yac: urbit provides 2^-64 resolution, if thats good enough for you :P but it has to be supported by hardware sooo
11:33:44 <dcoutts> tulcod: ok, perhaps you do have to add it to the db first
11:33:55 <dcoutts> addKnownProgram :: Program -> ProgramDb -> ProgramDb
11:34:16 <yac> jhance: urbit.org ?
11:34:28 <jhance> yac: Having such high resolution is really more for calculations though, not for getting the current time...
11:34:47 <dcoutts> tulcod: yes ok, looks like requireProgram does in fact need it to be in the db
11:35:17 <Nik05> well thank you jle` :)
11:35:38 <jhance> yac: yes but you won't find much there (and it relies on unix atm so it really can't get anything better than milliseconds). weird project, but drifting off topic XD
11:35:55 <tulcod> dcoutts: didn't help
11:36:06 <jle`> Nik05: np!
11:36:22 <dcoutts> tulcod: show me the code you're trying
11:36:27 <luite> what's the best way to do something conditionally on windows / nonwindows in a Setup.hs ?
11:36:28 <tulcod> ok let me simplify it
11:37:04 <dcoutts> luite: look at Distribution.System.buildOS
11:37:48 <dcoutts> luite: as in if buildOS == Windows
11:38:17 <luite> dcoutts: ah tnx
11:38:39 <tulcod> dcoutts:
11:38:41 <tulcod> dcoutts: http://pastebin.com/BmCp5VsL
11:38:47 <tulcod> test.hs: user error (The program cpp is required but it could not be found)
11:39:10 <dcoutts> tulcod: ah ok so you still need to configure the program
11:39:18 <tulcod> what?
11:39:24 <notdan> maybefbi: https://gist.github.com/co-dan/c874b9624ef09399a2c7 maybe an example can help
11:39:35 <tulcod> dcoutts: so i need to get a ConfiguredProgram?
11:39:41 <dcoutts> tulcod: I thought you were using requireProgram
11:39:53 <tulcod> dcoutts: ok i don't care what i should be using. i just want to run cpp.
11:39:59 <dcoutts> tulcod: but from your current code, the simplest is to use...
11:40:04 <maybefbi> notdan, wow you wrote that just now?! thanks
11:40:47 <Eva_> hello, I have a custom module called Nat, in my working directory in a file nat.hs and I have another file, toto.hs which import Nat. But it says it cannot find module Nat.
11:40:49 <Eva_> why ?
11:40:59 <dcoutts> newdb <- configureProgram verbosity cppProgram (addKnownProgram cppProgram defaultProgramDb)
11:41:02 <dcoutts> tulcod: ^^
11:41:11 <rwbarton> Eva_: the filename should be Nat.hs
11:41:17 <Eva_> oh..
11:41:18 <Eva_> thanks
11:41:34 <dcoutts> tulcod: the configure step for programs is when we try to find them on the system (and sometimes other details too)
11:41:46 <tulcod> dcoutts: thanks, at least that executed
11:43:20 <dcoutts> tulcod: in the context of a Setup.hs it's also possible to list the custom program (or in this case cppProgram) in the hookedPrograms thing in the UserHooks
11:43:33 <dcoutts> tulcod: and then it'll automaitically get configured along with all the other programs
11:43:46 <tulcod> dcoutts: since you seem to be an expert on cabal, i'll ask again. the reason i'm doing all this is because i want to generate a C file to be linked into the haskell library. what's the cleanest way to do that?
11:44:12 <dcoutts> tulcod: in a Setup.hs sadly
11:44:33 <tulcod> dcoutts: what's the best hook?
11:44:35 <tulcod> where do i write to?
11:44:36 <tulcod> etc
11:45:00 <dcoutts> tulcod: probably the preBuild or buildHook
11:45:10 <tulcod> and then write into the source dirs?
11:45:16 <tulcod> or is there a smart way to write into dist/build?
11:45:20 <maybefbi> notdan, all those beta-reduction steps you showed are done by the compiler?
11:46:19 <dcoutts> tulcod: in buildHook you have access to the LocalBuildInfo which has the correct dist/build dir
11:47:01 <tulcod> dcoutts: but it's only created somewhere deep in defaultBuildHook
11:47:38 <dcoutts> tulcod: the dist dir itself is made in the configure step
11:47:40 <maybefbi> notdan, wow so with yoneda lemma i can write a higher order function that fuses an arbitrary number of fmaps
11:48:02 <dcoutts> tulcod: it'd be ok to make it
11:53:47 <evancz> has anyone experienced this trojan ( http://www.ebel-computing.de/JSPWiki/Wiki.jsp?page=VServer%20Trojan ) while using Snap?
11:54:01 <evancz> I can't tell if I messed up or if it's my tools...
11:55:50 <statusfailed> jle`: not really? there's this: http://hub.darcs.net/ertes/netwire
11:56:01 <yac> are Exception -s wrong in haskell?
11:56:02 <statusfailed> but it doesn't seem to work
11:56:03 <zomg> evancz: a 0-day vulnerability in Struts seems quite unlikely to affect a completely different stack
11:56:06 <statusfailed> i'll hop on haskell-game
11:56:32 <jle`> statusfailed: how about the haddocks?
11:56:34 <yac> I noticed Exception class must be Typeable and afaik Typeable is kind of a crutch to workaround the type system
11:56:35 <jle`> on hackage?
11:57:38 <jle`> yac: "wrong" ?
11:58:03 <prototrout> yac: Generally you want to avoid exceptions whenever possible (and it's almost always possible) in Haskell. I wouldn't say they're "wrong" so much as having surprising behavior.
11:58:10 <statusfailed> jle`: They seem more like API documentation to me? Not quite so much "here is what stuff is"
11:58:16 <jle`> ah
11:58:27 <jle`> so do you mean like some sort of tutorial/book?
11:58:36 <yac> prototrout: but I like the concept of automatically propagating errors up the stack
11:58:48 <jle`> yac: what stack?
11:59:01 <yac> sorry, I am probably using this wrong
11:59:09 <jle`> exceptions in Haskell have well-defined semantics and intended usages
11:59:14 <yac> I mean, I have a function that is called 4 functions deep
11:59:16 <jle`> you have first-class errors in haskell though
11:59:22 <jle`> using Either
11:59:23 <jle`> for pure code
11:59:28 <yac> I can return Either there but then I have to handle the Either at every of those functions
11:59:42 <statusfailed> jle`: yes, but I just figured out I'm missing OverloadedStrings
11:59:43 <statusfailed> :)
11:59:52 <statusfailed> that's at least part of the reason that the darcs tutorial doesn't work for me
11:59:53 <prototrout> yac: You can use fmap to automatically lift non-Either-handling functions into Either-handling ones
12:00:06 <yac> oh, interesting
12:00:10 <jle`> fmap, (>>=), etc.
12:00:11 <prototrout> yac: or >>= to combine multiple Either-returning functions
12:00:14 <rwbarton> not really automatically
12:00:16 <jle`> to work with Either values as if they were normal values
12:00:24 <S11001001> better than automatically
12:00:28 <yac> thanks!
12:00:33 <rwbarton> in that you have to write fmap etc. all over your code
12:00:38 <S11001001> notwithstanding suggestions that   should be <*>
12:01:08 <prototrout> OK rwbarton I exaggerated a bit. But I meant it in the sense of "not having to write the case statements explicitly"
12:01:10 * hackagebot dson-parsec 0.4.1.0 - DSON parser.  http://hackage.haskell.org/package/dson-parsec-0.4.1.0 (alvare)
12:02:23 <jle`> yac: i wrote a piece about it --- http://blog.jle.im/entry/inside-my-world-ode-to-functor-and-monad ; basically using the combinators in haskell you can leave values in Either and be able to work with them using normal functions, other failable functions, etc., as if they were just normal values, having all the normal value tools you always had
12:03:01 <jle`> that being said Haskell does have IO exceptions
12:03:14 <jle`> which exist specifically in IO/runtime as a runtime tool
12:03:30 <jle`> by Haskell i mean GHC
12:03:52 <jle`> these things are meant to handle things like io errors -- bad disk reads, interrupts, etc.
12:04:03 <jle`> *not* for bad pure function calls
12:04:19 <jle`> think of IO exceptions as tools for working with IO
12:04:26 <jle`> and not as a general way to report errors/exceptions
12:04:44 <jle`> maybe exceptions is a loaded word
12:04:56 <jle`> . o O ( maybe every word is loaded )
12:05:07 <yac> luite: nice, I feel like I finally understand fmap
12:05:14 <yac> luite: sorry, ^ was for jle`
12:05:17 <yac> :)
12:05:35 <jle`> :)
12:05:40 <Para_> I'm not sure I really understand - what benefits do type parameters offer over defining a type with no parameters?
12:05:51 <yac> jle`: yes, I'm dealling with network IO now
12:06:10 * hackagebot language-c-quote 0.8.0 - C/CUDA/OpenCL/Objective-C quasiquoting library.  http://hackage.haskell.org/package/language-c-quote-0.8.0 (GeoffreyMainland)
12:06:21 <yac> but it doesn't raise by itself
12:06:31 <jle`> Para_: what do you mean?
12:06:36 <jle`> data Maybe a = Nothing | Just a ?
12:06:52 <Para_> yeah -- I'm reading LYAH
12:06:55 <Para_> and the example they use
12:07:10 <Para_> data Car a b c = Car { company :: a                        , model :: b                        , year :: c                         } deriving (Show)
12:07:18 <Para_> vs data Car = ...
12:07:21 <Para_> without the a b c
12:07:42 <jle`> you'd have data Car = Car { company :: String, model :: Int ... }
12:07:50 <jle`> it's a bit silly in this example alone to parameterize
12:08:03 <Iceland_jack> Para_: In the 'Car' example it doesn't make sense
12:08:08 <jle`> but you'll run into other much more useful examples later
12:08:10 <Para_> do you have an example where parametrizing makes sense?
12:08:14 <Iceland_jack> but imagine lists or trees: you don't want to have to define
12:08:17 <Para_> because I just don't understand any motivation here
12:08:32 <jle`> data Tuple a b = TupleUp a b
12:08:35 <jle`> heh.
12:08:42 <jle`> or data Maybe a = Nothing | Just a
12:08:54 <jle`> so you can have Maybe Int, Maybe Bool, Maybe String
12:09:02 <jle`> :t Just "hello"
12:09:03 <lambdabot> Maybe [Char]
12:09:04 <Iceland_jack>     data IntList  = EmptyIntList  | ConsIntList  Int  IntList
12:09:04 <Iceland_jack>     data BoolList = EmptyBoolList | ConsBoolList Bool BoolList
12:09:04 <Iceland_jack>     data ...
12:09:06 <jle`> :t Just False
12:09:07 <lambdabot> Maybe Bool
12:09:18 <jhance> Every functor in existance
12:09:22 <Para_> couldn't you do that without parametrizing the type doing?
12:09:24 <jle`> yeah, instead of MaybeInt = NothingInt | JustInt Int
12:09:29 <Para_> ahhhhh
12:09:36 <Para_> ahh okay Iceland_jack
12:09:36 <Irina21>  Here some videos. I hope you like them! http://j.mp/1pdP5zv
12:09:38 <jle`> MaybeString = NothingString | JustStringString
12:09:40 <Para_> so its just to make stuff more general
12:09:44 <Iceland_jack> Para_: yes
12:09:54 <jle`> also you can define neat functions like
12:09:59 <Para_> alright, thanks :)
12:10:00 <Iceland_jack> Para_: let's imagine that you want to point with x and y coordinates
12:10:01 <jle`> mapMaybe :: (a -> b) -> Maybe a -> Maybe b
12:10:05 <Iceland_jack> *want a point
12:10:13 <jle`> where otherwise you could only do
12:10:20 <Iceland_jack> and maybe you start with
12:10:20 <Iceland_jack>     data Point = Point Double Double
12:10:22 <jle`> mapMaybeIntString :: (Int -> String) -> MaybeInt a -> MinaybeInt String
12:10:25 <jle`> er
12:10:29 <Iceland_jack> but later on you want to allow points of Int's as well
12:10:32 <jle`> MaybeInt -> MaybeString
12:10:57 <Iceland_jack> instead of creating
12:10:57 <Iceland_jack>     data PointDouble = PointD Double Double
12:10:58 <Iceland_jack>     data PointInt    = PointI Int    Int
12:11:11 <Iceland_jack> you can do
12:11:11 <Iceland_jack>     data Point a = Point a a
12:11:40 <Iceland_jack> then you can define functions that work on *both* points of Int's and Double's
12:11:43 <Para_> and stuff stays generally the same
12:11:52 <Para_> okay! I got it now
12:11:57 <Para_> thanks both of you
12:11:59 <jle`> i think the fact that you can define generic functions is one of the more powerful things
12:12:02 <Para_> it helped
12:12:08 <Iceland_jack> Para_: This function works *both* on Point's of Ints and Doubles
12:12:08 <Iceland_jack>     addPoints (Point a b) (Point c d) = Point (a + c) (b + d)
12:12:11 <Iceland_jack> Para_: yw
12:12:23 <jle`> compare mapMaybe :: (a -> b) -> Maybe a -> Maybe b, to mapMaybeIntString :: (Int -> String) -> MaybeInt -> MaybeString
12:12:38 <Iceland_jack> Para_: You've worked with lists right?
12:12:39 <Para_> also
12:12:39 <jle`> if you do'nt parameterize maybe, you'll have to create separate mapMaybeXY for every possible combination
12:12:43 <Iceland_jack> Lists are parameterized
12:12:46 <Para_> yes Iceland_jack
12:12:50 <jle`> not to mention you'd also have to write every MaybeX
12:12:50 <Para_> what do you mean?
12:12:59 <Iceland_jack> Para_: They just have a special syntax
12:13:01 <Iceland_jack> @ty []
12:13:02 <lambdabot> [t]
12:13:03 <Para_> is there a way to go from Maybe a -> a?
12:13:03 <Iceland_jack> oops
12:13:12 <Iceland_jack> Para_: yes, but not safely
12:13:14 <Iceland_jack> @kind []
12:13:15 <lambdabot> * -> *
12:13:31 <jle`> Para_: i suggest you try to write one yourself with pattern matching
12:13:36 <Iceland_jack> Para_: when you write
12:13:36 <Iceland_jack>     length :: [a] -> Int
12:13:36 <Iceland_jack> the '[a]' thing is a parameterized type
12:13:46 <Iceland_jack> You can think of it as
12:13:46 <Iceland_jack>     [a] = [] a
12:13:47 <Para_> ohhh
12:13:52 <jle`> and you'll see why it's a bit weird
12:13:55 <Iceland_jack> and if you replace '[]' with List it makes sense
12:14:07 <Iceland_jack>     data List a = Empty | Add a (List a)
12:14:12 <Para_> a function with Maybe a -> a jle`?
12:14:14 <Iceland_jack> is the same as the usual Haskell definition
12:14:16 <ion> Liast = List a
12:14:18 <jle`> Para_: yeah
12:14:29 <jle`> foo (Just x) = x
12:14:33 <jle`> foo (Nothing) = ... ?
12:14:52 <jle`> a lot of people use fromMaybe where you provide a default
12:14:53 <ParahSailin> :t fromJust
12:14:53 <lambdabot> Maybe a -> a
12:15:03 <jle`> fromMaybe _ (Just x) = x
12:15:06 <jle`> fromMaybe d Nothing = d
12:15:11 <Iceland_jack> Para_: you can specify a 'default' return value
12:15:12 <Iceland_jack>     foo :: Maybe a -> a -> a
12:15:12 <Iceland_jack>     foo (Just x) _       = x
12:15:12 <Iceland_jack>     foo Nothing  default = default
12:15:24 * Iceland_jack is basically echoing jle`
12:15:38 <Para_> :)
12:15:39 <Para_> alrigh
12:15:43 <Para_> thank you guys
12:15:58 <Iceland_jack> Para_: btw you can also use Hoogle
12:15:59 <Iceland_jack> @hoogle Maybe a -> a
12:16:00 <lambdabot> Data.Maybe fromJust :: Maybe a -> a
12:16:00 <lambdabot> Data.Maybe fromMaybe :: a -> Maybe a -> a
12:16:00 <lambdabot> Data.Monoid First :: Maybe a -> First a
12:16:09 <Iceland_jack> > fromJust (Just "this works but....")
12:16:11 <lambdabot>  "this works but...."
12:16:18 <Iceland_jack> > fromJust Nothing   -- ((((this doesn't))))
12:16:20 <lambdabot>  can't find file: L.hs
12:16:26 <Iceland_jack> > fromJust Nothing   -- ((((this doesn't))))
12:16:27 <lambdabot>  *Exception: Maybe.fromJust: Nothing
12:16:48 <Iceland_jack> So 'fromJust' is a _partial_ function because it's output is not defined for 'Nothing'
12:17:40 <Para_> hmm okay, makes sense
12:17:41 <Para_> thanks
12:17:43 <Iceland_jack> (so don't use 'fromJust' without a good reason)
12:17:55 <Para_> agh
12:17:55 <Iceland_jack> Para_: You can ask the same question about [a]
12:17:58 <Para_> gotta go
12:18:00 <Iceland_jack> is there a function
12:18:00 <Iceland_jack>     [a] -> a
12:18:04 <Iceland_jack> take care :)
12:18:05 <Para_> and yeah
12:18:06 <Para_> head
12:18:10 <Para_> but its not safe
12:18:11 <Iceland_jack> yes, and head is also partial
12:18:12 <Para_> :)
12:18:12 <Iceland_jack> yes
12:18:25 <Para_> okay thanks for the help!
12:19:41 <witz> damn, jizzed my pants
12:19:44 <prototrout> An impartial function treats you no better or worse than any other programmer.
12:19:45 <witz> haskell is *that* good
12:20:43 <Iceland_jack> witz: cut that out
12:21:03 <witz> i'm already jizzed up
12:21:10 <Iceland_jack> @where ops
12:21:10 <lambdabot> arjanb bos byorgey Cale conal copumpkin dcoutts dibblego dmhouse dolio dons edwardk elliott geekosaur glguy Heffalump Igloo jmcarthur johnw kosmikus Lemmih monochrom nyc Philippa Pseudonym quicksilver roconnor Saizan shachaf shapr sjanssen ski sorear SyntaxPolice xerox
12:21:15 --- mode: ChanServ set +o dcoutts
12:21:25 <witz> there
12:21:25 <witz> in the corner, doing some azzrapes
12:21:33 --- mode: ChanServ set -o dcoutts
12:22:36 <witz> yeah baby
12:22:41 --- mode: ChanServ set +o dcoutts
12:22:43 <witz> right in the <zz
12:22:46 --- mode: dcoutts set +b witz!*@*
12:23:17 --- mode: ChanServ set -o dcoutts
12:26:12 * hackagebot data-reify 0.6 - Reify a recursive data structure into an explicit graph.  http://hackage.haskell.org/package/data-reify-0.6 (CarterSchonwald)
12:36:47 <genisage> Are there any functions in prelude that would satisfy a Num (a->a) constraint? Or would I have to look elsewhere/create my own?
12:37:17 <geekosaur> :t negate
12:37:18 <lambdabot> Num a => a -> a
12:37:23 <f-a> genisage: satisfy in which sense?
12:37:44 <Iceland_jack> genisage: are you talking about
12:37:44 <Iceland_jack>     Num (a -> a)     (which is a Constraint) or
12:37:44 <Iceland_jack>     Num a => a -> a  (which is a type)
12:37:56 <genisage> The first
12:38:06 <geekosaur> oh, I see
12:38:12 <geekosaur> prelude won't
12:38:14 <Iceland_jack> genisage: Then it doesn't quite make sense, functions don't 'satisfy' constraints in that way
12:38:31 <Iceland_jack> if you want to define functions as numbers you can import libraries that do that or define it yourself though
12:38:34 <geekosaur> what are you actually trying to do?
12:38:39 <augur> anyone know about a type system for enforcing executability of IO programs? e.g. ensuring sufficient disk space, etc.?
12:39:06 <l0cust> is there a way to use pandoc with quasiquotes
12:39:18 <geekosaur> augur, that sounds halting-problem-ish to me?
12:39:27 <l0cust> I want to write some markdown, have it output as html 5
12:39:41 <Iceland_jack> augur: sounds similar to the resource constraint monad
12:39:57 <augur> Iceland_jack: is it at the type level?
12:40:02 <augur> geekosaur: why?
12:40:07 <genisage> I was just messing around in ghci and the type of map map [(+2), (-2+)] had that constraint in its type
12:40:08 <Iceland_jack> No
12:40:14 <augur> Iceland_jack: :(
12:40:26 <augur> Iceland_jack: i need something at the type level so that it typechecks only if its executable
12:40:27 <genisage> I'm not trying to do anything but figure out more about haskell's types
12:41:02 <prototrout> augur: How are you going to check the runtime environment for sufficient disk space during compile-time?
12:41:20 <Iceland_jack> genisage: that type basically means you're on the wrong path, do you want to know why you get that type or something else?
12:41:32 <augur> prototrout: that's a good question. :)
12:41:42 <geekosaur> or, if you are saying you want some kind of type-level assertion that X space is available, do you plan a proof that whatever you are using it with will hold to that limit?
12:42:03 <geekosaur> because *that* part is what seems unlikely to me
12:42:56 <genisage> What I would really like to know is why that constraint shows up when I use [(+2), (-2)], but not when I use [(2+), (2-)]
12:43:07 <Iceland_jack> ah so that's the actual question
12:43:20 <Iceland_jack> genisage: it has to do with negation
12:43:21 <augur> geekosaur: what i was thinking was merely some kind of type-level preconditions and post-truths
12:43:29 <Iceland_jack> :t (+2)
12:43:30 <lambdabot> Num a => a -> a
12:43:31 <Iceland_jack> :t (-2)
12:43:32 <lambdabot> Num a => a
12:43:44 <Iceland_jack> genisage: note the different types, the former (+2) is a section (a function)
12:43:51 <Iceland_jack> the latter is a regular number
12:43:51 <genisage> DX I'm dumb
12:43:56 <augur> geekosaur: like, for a copy action, you have a precondition that there is enough space to make the copy, and the post-truth is that the amount of free space is now lower by so much
12:44:11 <Iceland_jack> genisage: :)
12:44:13 <Iceland_jack> :t [(+2), (-2)]
12:44:14 <lambdabot> (Num (a -> a), Num a) => [a -> a]
12:44:23 <genisage> Completely missed that, thanks.
12:44:49 <Iceland_jack> So the reason why you get
12:44:49 <Iceland_jack>     “Num a” and “Num (a -> a)”
12:44:49 <Iceland_jack> is because you're telling GHC that your list contains numbers, but also a function
12:44:58 <geekosaur> augur, so for the counter-case there, let's say you are doing a format conversion (think iconv). can you assert the final size before processing the file, if you are going from iso8859-1 to utf8?
12:45:55 <augur> geekosaur: who knows. im not saying it would be absolutely enforced, im just looking for the tools that make it possible to make such statements if you wanted
13:04:24 <marchelzo_> I'm trying to implement http://stackoverflow.com/questions/17310051/fibonacci-rabbits-dying-after-arbitrary-of-months in Haskell
13:04:41 <marchelzo_> This is what I have: http://lpaste.net/105752  but it gives different output
13:04:58 <marchelzo_> I don't know why
13:07:00 <marchelzo_> Sorry I figured it out, had an off by one error.
13:19:31 <flazz> if i'm constantly taking a list and making lists of lists, and then compounding it, is that somewhat co-monadic in nature?
13:20:34 <flazz> s/constantly/repeatedly
13:22:21 <tulcod> wow
13:22:46 <pjdelport> flazz: define compounding?
13:23:13 --- mode: asimov.freenode.net set +o ChanServ
13:24:17 <armlesshobo> hey guys, sup?
13:24:27 <flazz> in my case i'm grouping groups; groupBy ... groupBy ... groupBy
13:24:37 <armlesshobo> hi i'm new to haskell
13:25:10 <imalsogreg> armlesshobo: Hey.
13:27:06 <armlesshobo> i'm guessing some have join/part messages hidden
13:27:17 <armlesshobo> netsplit is happening
13:28:54 <benzrf> whos the #1 haskell guy
13:28:57 <benzrf> is it spj
13:29:02 <benzrf> is it philip wadler
13:29:21 <cow_2001> does anyone know how to make `$ yesod devel` bind to 127.0.0.1 and not 0.0.0.0?
13:29:45 <Iceland_jack> You've asked that before benzrf, that question doesn't have a single answer
13:29:45 <benzrf> cow_2001: try checking the flags
13:29:51 <benzrf> Iceland_jack: ok
13:29:58 <benzrf> cow_2001: worst case scenario u can make forwarding
13:30:43 <yac> hm, I'm getting an error I can't decipher
13:31:18 <yac> https://gist.github.com/yaccz/de73a024f47b1ac350f6
13:31:21 <yac> what is this about?
13:31:57 <Iceland_jack> yac: you need to specify the exception
13:32:37 <Iceland_jack> so you can't just do
13:32:38 <Iceland_jack> @ty catch (putChar 'a') (\_ -> putStrLn "error!")
13:32:39 <lambdabot>     No instance for (Exception e0) arising from a use of ‘catch’
13:32:39 <lambdabot>     The type variable ‘e0’ is ambiguous
13:32:39 <lambdabot>     Note: there are several potential instances:
13:33:06 <Iceland_jack> but you can do
13:33:06 <Iceland_jack> @ty catch (putChar 'a') (\(SomeException _) -> putStrLn "error!")
13:33:06 <Iceland_jack> for catching all exceptions, which you generally shouldn't do
13:33:07 <lambdabot> IO ()
13:33:21 <yac> hum
13:33:25 <yac> ah
13:34:07 <Iceland_jack> yac: if you do
13:34:07 <Iceland_jack>     ghci> :i Exception
13:34:07 <Iceland_jack> you should get a list of possible exceptions
13:34:18 * Desheng is ecstatic at just having made use of mapM for the first time
13:34:19 <yac> I don't care what the exeption is
13:34:31 <yac> i just need to print ex it
13:34:37 <Iceland_jack> yac: Is it a toy example?
13:34:51 <Iceland_jack> if you really don't care you can just do
13:34:51 <Iceland_jack>     (\(SomeException ex) -> print ex)
13:35:05 <yac> I'm getting it's applied to too many arguments
13:35:36 <Iceland_jack> are you sure
13:35:36 <Iceland_jack> @ty \(SomeException ex) -> print ex
13:35:37 <lambdabot> SomeException -> IO ()
13:35:43 <yac> oh wait
13:36:17 * hackagebot hspec-webdriver 0.2.2 - Write end2end web application tests using webdriver and hspec  http://hackage.haskell.org/package/hspec-webdriver-0.2.2 (JohnLenz)
13:36:43 <yac> it's even worse now
13:36:47 <Iceland_jack> how?
13:37:32 <yac> oh wait. it's cool
13:37:34 <Peaker> Hey, I'm reading http://www.grabmueller.de/martin/www/pub/AlgorithmW.pdf -- I'm confused about https://github.com/wh5a/Algorithm-W-Step-By-Step/blob/master/AlgorithmW.lhs#L163
13:37:40 <yac> if I remove the type signature which I hve wrong
13:37:45 <yac> thanks
13:37:49 <Iceland_jack> no prob
13:37:55 <yac> the error is pretty cryptoc tough
13:38:01 <Iceland_jack> agreed
13:38:05 <Peaker> any algorithm W / HM inference expert abound? :)
13:38:07 <yac> yay it works
13:38:07 <Iceland_jack> ghci> catch (evaluate (0 `div` 0)) (\DivideByZero -> print DivideByZero >> return 0)
13:38:08 <Iceland_jack> divide by zero
13:38:08 <Iceland_jack> 0
13:38:25 <yac> let's slap it at production
13:38:47 <Peaker> It seems that all substitutions are being applied on the expressions being type-checked prior to creating the substitutions. This means that all unifications will generate substitutions with the most up-to-date variables in them. This means there's no point in re-applying the old substitutions on them -- which is what that line does?
13:39:08 <yac> Iceland_jack: you just pushed some code into production lol
13:39:25 <Iceland_jack> yac: I hope not :)
13:40:23 <yac> Iceland_jack: you sure did mate
13:42:03 <yac> oh well, there's one more thing I need to take care of
13:42:38 <nicksanford> msg knyon whats up?
13:43:01 <geekosaur> "oops"
13:49:26 <jonathan6> Hi, if I need ordered lists with unique elements, is there such a type in haskell?
13:50:20 <osfameron> you could use a Set?
13:51:03 <jonathan6> ordered sets then?
13:51:37 <armlesshobo> i love me some ordered sets
13:51:43 <armlesshobo> all ordered n stuff
13:53:24 <dwcook> jonathan6: A probably naive way that comes to mind is to use a newtype of lists and export as the only insert operation a function that inserts iff the element doesn't already exist in the list. This will run you O(n) but I'm not entirely sure a Set would do better in this case.
13:53:28 <osfameron> I think sets require Ord don't they?
13:53:28 <jonathan6> Or am I wrong to think that finding an element in a set would be O(n)?
13:53:42 <dwcook> Finding an element in a Set with Ord is O(log(n))
13:53:52 <dwcook> But then you have to think about reordering elements
13:54:05 <osfameron> "The implementation of Set is based on size balanced binary trees"
13:54:21 <osfameron> it should be pretty efficient, I'd have thought
13:54:36 <jonathan6> ah, so basically set already does what I want it to do. That's nice
13:54:48 <dwcook> The problem then would be encoding the ordering
13:55:01 <bergmark> jonathan6: you can also newtype the elements in the set if you want a custom ordering
13:55:28 <dwcook> jonathan6: If I understand correctly, you want an arbitrary ordering, not based solely on the actual elements?
13:55:49 <dwcook> You did say a lsit with unique elements, and lists have arbitrary orderings
13:55:52 <dwcook> list*
13:56:02 <jonathan6> actually, I will only do two things with the structure, add new elements and check for existence of elements. So all I need is to keep it unique cheaply, and to find things cheap
13:56:27 <dwcook> That would seem to make it easier
13:56:30 <dwcook> I think your best bet is Set
13:56:57 <jonathan6> thanks for the help
13:58:04 <marchelzo_> why is it that these two functions both run at the same speed? http://lpaste.net/105754
13:59:20 <dwcook> marchelzo_: How is memoize defined?
13:59:54 <marchelzo_> I don't know. I didn't implement it but as far as I know it's used pretty widely.
14:00:10 <dwcook> I've never heard of it
14:00:18 <dwcook> Is it from this memoize package?
14:00:20 <marchelzo_> It just keeps track of the values of functions for certain inputs.
14:00:27 <marchelzo_> Yes
14:01:06 <quchen> marchelzo_: slowFib calls fib, not slowFib.
14:01:15 <dwcook> Ah, good catch :)
14:01:16 <quchen> It's not recursive, and it's pretty much the same function.
14:01:17 <marchelzo_> quchen: hahaha
14:01:22 <marchelzo_> quchen: thanks
14:01:51 <pjdelport> The sneaky other kind of typing error.
14:03:41 <benzrf> how do i make a ghci hooks thing
14:03:46 <benzrf> like how ghc-vis does
14:09:08 <moghedrin> @src whileM
14:09:08 <lambdabot> Source not found. You type like i drive.
14:09:30 <moghedrin> :t whileM
14:09:31 <lambdabot> Not in scope: ‘whileM’
14:20:38 <Peaker> Hah! so the original paper had this bug!
14:20:45 <Peaker> I debugged this for many hours...
14:21:25 <benzrf> Peaker: ow :(
14:21:33 <Peaker> I extended AlgorithmW-step-by-step with some nice record polymorphism
14:21:45 <benzrf> ok how do i get a file to be copied along with my pkg when it instal
14:22:00 <Peaker> or rather, with simple structural records. had a weird bug -- eventually realized it is this silly bug
14:22:10 <Peaker> AlgorithmW step-by-step gets its "composeSubsts" parameters flipped!
14:22:38 <Peaker> (new substs need to apply to old ones, not the other way around)
14:22:53 <Peaker> (new substs already include the old ones because old substs always apply to the types before unification)
14:24:24 <danking> Hi all, I'm having cabal woes. I have a library, an executable, and a test-suite. Each one has its own folder. The test-suite depends on three modules which are "exposed-modules" in the library. The name of the project (scientific-pl) is
14:24:28 <pjdelport> Peaker: There's a peculiar mix of anger and joy in making a discovery like that, eh?
14:25:03 <danking> listed in build-depends for the test-suite. Unfortunately, I still get a ld error at link time claiming that a symbol from one of the library modules is not existing.
14:25:10 <Peaker> pjdelport: mostly joy :)  we've been having lots of type system difficulties in Lamdu, and I think we're finally on the right track again
14:25:52 <danking> The only other bit of info I have is that the missing symbol is referenced from a module which I list under "other-modules" of the test-suite. Symbols referenced from the "test-module" don't seem to have any trouble being resolved. Any ideas what could be the problem?
14:28:29 <frerich> Peaker: Are you aware of a screencast showing lamdu in action?
14:42:24 <Para_> Okay -- so I'm confused. I thought haskell was purely functional... whats with all of this "do" stuff?
14:42:36 <shachaf> "purely functional" doesn't really mean anything.
14:42:51 <shachaf> Haskell is a general-purpose language. It supports "imperative programming", whatever that is.
14:42:56 <pjdelport> Para_: do is just syntax sugar for monadic binding.
14:43:24 <Para_> oh
14:43:25 <Para_> hmm
14:43:26 <Para_> okay
14:43:33 <pjdelport> Which is purely functional (for some reasonable value of that term).
14:43:48 <Para_> I just didn't expect to see something so similar to a "do this then that then that etc"
14:44:28 <zwer_g> @undo do x <- getLine; y <- getLine; putStrLn (x + y)
14:44:28 <lambdabot> getLine >>= \ x -> getLine >>= \ y -> putStrLn (x + y)
14:45:05 <pjdelport> Para_: do syntax cat actually mean many different things depending on the underlying monad, but the the underlying values remain referentially transparent, or "pure".
14:45:14 <zwer_g> Para_ that is what do desugars to
14:45:34 <pjdelport> Para_: Instead of side effects, Haskell's IO gives you first-class effects.
14:45:51 <zwer_g> > do x <- [1,2,3];  y <- [4,5,6]; return (x,y)
14:45:52 <lambdabot>  [(1,4),(1,5),(1,6),(2,4),(2,5),(2,6),(3,4),(3,5),(3,6)]
14:45:54 <shachaf> sigh
14:46:12 <Para_> hm
14:46:29 <Para_> okay
14:46:33 <Para_> I guess that's valid
14:46:52 <Para_> I just didn't expect it I suppose -- I thought using 'do' would be discouraged
14:47:01 <Iceland_jack> Para_: Why?
14:47:07 <Lutin`> Para_: Do syntax still has functions underlying it, it's just convenient syntax
14:47:18 <Para_> Yeah I guess so
14:47:19 <Iceland_jack> 'do' has nothing to do with side-effects mind you
14:47:31 <dottedmag> Despite the name, heh.
14:47:41 <shachaf> An imperative program written using IO is a lot like an imperative program written using C.
14:47:44 <jle`> Para_: do is just syntactic sugar, so it has nothing to do with imperative/functional
14:48:02 <shachaf> It's discouraged if your goal is not to write an imperative program. That's a your-goal thing, not a language thing.
14:48:12 <jle`> putStrLn "hello" represents an IO action.
14:48:17 <Para_> just using it to say "do this" then "do that" seems a bit less abstracted than composing functions - but if its syntactic sugar then I take back what I said
14:48:21 <jle`> it's an actual, normal object
14:48:28 <jle`> just like a list, or an Int
14:48:33 <jle`> just an 'inert' object/thing
14:48:41 <pjdelport> Para_: zwer_g's example is using do in the list monad, which (at first approximation) works like writing a list comprehension.
14:48:50 <jle`> the magic is that if you have two IO ()'s, you can "combine" them to make a new "big IO ()"
14:48:58 <jle`> using (>>)
14:49:03 <jle`> it's not "magic", it's just a very useful interface
14:49:20 <Para_> I have to read more into monads and that stuff
14:49:21 <jle`> so i can say (>>) (putStrLn "hello") (putStrLn "world")
14:49:24 <pjdelport> Para_: It's more accurate to say that it's *IO* that gives it the meaning of "do this then do that"
14:49:26 <jle`> this has nothing to do with monads, really
14:49:45 <Para_> isn't IO done through monads?
14:49:47 <jle`> this is more of a useful API for IO
14:49:48 <pjdelport> And IO is just another kind of value; you can use it without monadic syntax or od.
14:49:51 <pjdelport> do, even
14:49:51 <jle`> no, IO is done through IO
14:49:51 <Para_> and pjdelport - that makes sense
14:49:53 <jle`> the IO data typ
14:49:55 <Para_> oh
14:49:55 <jle`> e
14:49:58 <Para_> I'm lost
14:50:03 <Para_> (As in I was lost)
14:50:05 <frerich> jle`: It may well be that ‘do’ is just syntactic sugar, but I think it does have a lot to do with the programming paradigm. If you use ‘do’, you get a very strong feeling of writing the program as a sequence of steps because the ‘bind’ applicaitons are hidden. Without do, it’s a much less imperative style.
14:50:18 <Para_> this still means that I need to figure out what monads actually are
14:50:22 <jle`> don't worry about it
14:50:28 <benzrf> frerich++
14:50:29 <benzrf> bbloom:
14:50:31 <jle`> figuring out what they are is a lot less useful/important than people make it out to be
14:50:31 <benzrf> *bbl
14:50:45 <pjdelport> Para_: Rather forget about monads; they're not the important thing.
14:50:53 <jle`> just know that IO () has a convenient interface for combining IO actions
14:51:13 <pjdelport> IO is its own thing: a data type for effects.
14:51:21 <jle`> the fact that tehy're called (>>), (>>=), and return aren't really important
14:51:22 <jonathan6> I had a solution to a problem that relied on lists. I was suggested here to use Set instead, as it fits the purpose better. Right now I'm merging from list to Set, but I can't figure out how to translate something like: [(f x) | x <- list] into something equivalent sets. Anyone?
14:51:34 <jle`> (the main benefit is that you can do generic functions over all monads, but that's not a big deal yet)
14:51:56 <jle`> an IO object is just a normal data thingy
14:52:02 <jle`> like a list or an ADT or an Int, etc.
14:52:06 <jle`> it "represents an IO action"
14:52:19 <Para_> okay
14:52:21 <Para_> :)
14:52:23 <jle`> so putStrLn "hello" is an object that describes, internally, the act of printing "hello" to stdout
14:52:29 <jle`> alone, this isn't too useful
14:52:34 <frerich> jonathan6: There are ‘map’ and ‘filter’ functions for sets, so you could use ’S.map f mySet’
14:52:41 <jle`> putStrLn "world" is an object that describes printing out "world" to stdout
14:52:50 <jle`> and then you have a function andThen :: IO () -> IO () -> IO ()
14:52:56 <frerich> jonathan6: (assuming you did ‘import Data.Set as S')
14:53:04 <jle`> andThen takes two IO objects and returns a "new" one that describes doing both one after the other
14:53:12 <jle`> so if you did
14:53:19 <jle`> andThen (putStrLn "hello") (putStrLn "world")
14:53:22 <jle`> :: IO ()
14:53:35 <jle`> that gives you a new IO object that describes the act of printing "hello" and then "world" to stdout
14:53:35 <jonathan6> frerich: that would work if 'f' was a function (a -> a), but since f is a function 'a -> [a]', map doesn't really do it :P
14:53:44 <jle`> it's actually a pretty neat interface
14:53:49 <Para_> oh hm thats neat
14:53:51 <Para_> yeah
14:53:52 <jle`> it's similar to the semicolon in bash
14:54:00 <jle`> so anyways, what do you do with an IO ()?
14:54:08 <jle`> well, you can "name" it 'main'
14:54:10 <dottedmag> > Data.Set.Monad.empty
14:54:11 <jle`> and then compile it
14:54:12 <lambdabot>  Not in scope: ‘Data.Set.Monad.empty’
14:54:25 <jle`> and then GHC will interpret/execute whatever IO () is named main and turn it into a program and execute/interpret it
14:54:33 <frerich> jonathan6: Why not? with [f x | x <- list] you’d get a list of lists, so you would get a set of lists with Data.Set.map, no?
14:54:42 <jle`> but you assemble an IO () using smaller IO ()'s, with 'andThen' and other combinators
14:54:54 <dottedmag> jonathan6: You can use set-monad package to get a monadic set and then MonadComprehensions to enable comprehensions over arbitrary monads.
14:55:12 <pjdelport> Para_: The key insight is that constructing an IO action is functionally pure: it's just a value that you can put in list, pass around, or do anything with. It doesn't execute or cause side effects on its own.
14:55:23 <Qfwfq> What's bind for Set? union . map?
14:55:36 <jle`> andThen is a specialized version of (>>), btw
14:55:38 <Para_> hmm okay
14:55:44 <jle`> :t (>>) `asAppliedTo` putStrLn "hello"
14:55:45 <lambdabot> IO () -> IO b -> IO b
14:56:01 <jle`> if (>>) is a bash semicolon
14:56:02 <Para_> :t >>
14:56:04 <lambdabot> parse error on input ‘>>’
14:56:04 <jle`> then (>>=) is a bash pipe
14:56:13 <pjdelport> Para_: All you ever do is take small IO actions and compose them together into bigger IO actions, until you have your whole imperitave program, which is conventionally main. That combined IO action will get run, but constructing it is pure and predictable.
14:56:13 <Para_> :t (>>)
14:56:14 <lambdabot> Monad m => m a -> m b -> m b
14:56:16 <jle`> it is just like (>>), except it passes on the result to the next thing
14:56:27 <jle`> so you'd do
14:56:31 <jle`> getLine >>= putStrLn
14:56:52 <jonathan6> frerich: I was unclear before, the "list" is what would be a set in my case. I.e., instead of creating a list of lists from a list, I would create a list of sets from a set
14:57:10 <Para_> wait - I know what a bash pipe does
14:57:14 <Para_> but what does a semicolon do?
14:57:18 <Lutin`> jonathan6: so the type of f is a -> [a]
14:57:21 <jle`> it chains it without passing things on
14:57:25 <dottedmag> Para_: do something, then ignore output and do something else.
14:57:27 <jonathan6> Lutin`: yes
14:57:30 <Para_> ah ok
14:57:33 <jle`> try echo "hello"; echo "world"
14:57:49 <jle`> and compare to putStrLn "hello" >> putStrLn "world"
14:58:00 <jonathan6> Lutin`: or it is, but I would change it to a -> Set a. I'm changing all lists to sets in an existing program
14:58:33 <Para_> its the same
14:58:40 <Para_> okay
14:58:52 <jle`> but the important thing to remember is that (>>) and (>>=) are pure functions
14:59:08 <jle`> putStrLn "hello" >> putStrLn "world" return *the same IO ()* every time
14:59:20 <jle`> getLine >>= putStrLn returns "the same IO ()" every time
14:59:36 <Lutin`> jonathan6: You can use map and fold
14:59:42 <Para_> okay - it might print something different because of different inputs
14:59:46 <Para_> but its the same IO ()
14:59:46 <jle`> now...when you actually *run* the IO (), it might behave different every time
14:59:46 <dottedmag> Para_: Monads are basically the syntactic constructs for producing arbitrary pipelines using arbitrary commands (input->output), semicolons and pipes.
15:00:05 <jle`> but it's still the same IO ()
15:00:06 <dottedmag> Para_: But the twist is semicolons and pipes are programmable.
15:00:12 <jle`> "compiled to the same IO ()"
15:00:21 <Para_> okay
15:00:35 <Para_> side question - why does IO have the parentheses after it?
15:00:43 <dottedmag> Para_: for IO they mean one thing (sequence, passing output to input), for List or Maybe they mean something else
15:00:43 <Iceland_jack> Para_: that's the type it 'returns'
15:00:45 <Para_> and alright dottedmag, thanks
15:00:46 <Iceland_jack> @ty ()
15:00:47 <lambdabot> ()
15:00:58 <Iceland_jack> So () confusingly has type ()
15:00:58 <Iceland_jack>     () :: ()
15:01:00 <jle`> IO () is sort of like a return type of void
15:01:02 <jle`> in other languages
15:01:06 <jonathan6> Lutin`: You're the second one to suggest it. I'll assume that you must be correct, and that I did something wrong when I tried before. I'll try again :) thank you
15:01:07 <jle`> IO Int computs an Int
15:01:12 <jle`> IO String computes a String
15:01:15 <jle`> :t getLine
15:01:16 <lambdabot> IO String
15:01:28 <Para_> ahhh ok
15:01:30 <jle`> IO () computes a... ().  but contains side-effects in the process of that computation
15:01:32 <Lutin`> jonathan6: you could also use fold and union
15:01:34 <jle`> so it's like return type void
15:01:48 <Para_> and what do you mean by contains side effects?
15:01:51 <jle`> you can think of IO String as instructions for a computer to compute a string
15:02:04 <Lutin`> jonathan6: But I'm not sure if that would be faster
15:02:09 <Para_> as in, it might compute a different string
15:02:13 <Para_> ?
15:02:15 <jle`> and IO () as instructions for a computer to compute a  ()...but the instructions to the computer sneak in things like 'in the process, print something to stdout'
15:02:27 <dottedmag> Para_: putStrLn "foo" has type IO (), which means it always compute () , but the side-effect is printing "foo".
15:03:00 <Para_> ahhh okay got it
15:03:07 <Para_> thanks
15:03:12 <jle`> i like to think of an IO a as a little chunk of assembly/C code...and so IO () is a little chunk of assembly/c code that might do arbitrary things as long as it returns a () in the end
15:03:46 <jonathan6> Lutin`: it's faster than converting a set to a list, apply the function f and convert the result back into a set :)
15:03:52 <jle`> when you compile haskell with ghc there is actually sort of a "direct translation" of a given IO () to a real chunk of assembly...that is, you can think of GHC as a function IO () -> Assembly
15:04:07 <pjdelport> Para_: Are you just starting to learn Haskell, by the way?
15:04:57 <Para_> pjdelport - two days ago :)
15:05:08 <jle`> so the assembly that it generates cna really do arbitrary things as long as it returns a () in the end
15:05:11 <jle`> like...launch missiles
15:05:20 <Para_> and that seems like an intuitive way to think of it, I'll think of it like that!
15:05:25 <pjdelport> jle`: Well, Haskell compiles *all* your functional code to some chunks of machine code; IO just imposes an order on certain bits of it. :)
15:05:27 <genericpersona> if a function evaluates to IO String for example, how do you access that String value and leave behind the IO part?
15:05:40 <jle`> genericpersona: you can't
15:05:53 <jle`> there is no "string value" inside an IO String
15:05:56 <genericpersona> so once something's been tainted w/ IO it can never go back?
15:06:00 <jle`> just like there is no string value inside the ls binary
15:06:01 <Lutin`> jonathan6: Can you figure that fold out yourself?
15:06:09 <jle`> @quote ls
15:06:09 <lambdabot> applicative says: Even if no one else understands me, still, the Glasgow Haskell Compiler understands me
15:06:14 <pjdelport> genericpersona: You can't do it by escaping IO; instead, you use operations like fmap or bind to operate on it.
15:06:19 <genericpersona> ah
15:06:28 <jle`> genericpersona: IO String isn't a string value that is tagged by IO
15:06:32 <jle`> the string in IO String doesn't exist
15:06:37 <jle`> so you can't "get it out"
15:06:55 <jle`> Para_: first-class actions is somethign i really like about Haskell :)
15:06:56 <genericpersona> what do you mean it doesn't exist? didn't you say that after the IO actions a string ultimately results?
15:07:15 <Lutin`> genericpersona: At runtime
15:07:21 <Iceland_jack> @quote shachaf /bin/ls
15:07:21 <lambdabot> shachaf says: getLine :: IO String contains a String in the same way that /bin/ls contains a list of files
15:07:22 <jle`> genericpersona: yes, but haskell code doesn't execute
15:07:27 <jle`> it evaluates
15:07:37 <jonathan6> Lutin`: I might. May I ask you if I fail? It's just two lines of code :)
15:07:38 <jle`> er...that is a rather unhelpful way to say it
15:07:40 <genericpersona> i don't understand the difference i suppose
15:07:41 <jle`> sorry
15:07:43 <genericpersona> :)
15:07:47 <Lutin`> jonathan6: Go for it :)
15:08:00 <pjdelport> genericpersona: One way to think of IO String is that it's a "future" or "deferred" string. When you say something like f <$> someIOString, it's a bit like adding a callback to it.
15:08:17 <jle`> genericpersona: it's like math, it can perform pure equations and calculations and reductions
15:08:32 <jle`> when you solve something like 1 + 4 in math, it doesn't cause any side effects (abstractly)
15:08:42 <jle`> you have an IO String...that's what it *is*
15:08:48 <genericpersona> sure, but to have a useful program you need some side effects
15:08:51 <jle`> it's an object that represents the action of producing a string
15:09:03 <jle`> what you can do is you can assemble and compose IO () objects
15:09:06 <Iceland_jack> genericpersona: yes, and those side-effects take place when you execute/run that action
15:09:08 <pjdelport> genericpersona: You need effects. You don't need them to be *side* effects.
15:09:08 <genericpersona> i understand the point of marking it as IO to indicate that any number of side effects might occur
15:09:17 <jle`> genericpersona: that's not acctaully the point, really
15:09:22 <genericpersona> what's the point?
15:09:28 <jle`> first class actions
15:09:33 <Para_> wait so jle - if you have an IO string and you want to do stuff with it, the type signatures for the functions applied to it have to be IO String instead of string?
15:09:43 <jle`> Para_: you can apply normal functions to IO String's
15:09:53 <jle`> using fmap :: (a -> b) -> (IO a -> IO b)
15:09:59 <jle`> you can promote any normal function into a function on IO objects
15:10:03 <Iceland_jack> Para_: Let's say that we want to read a line from input, and reverse it
15:10:04 <geekosaur> genericpersona, think of it this way: something like getLine is a pure value representing an opcode to a runtime interpreter
15:10:14 <Para_> oh okay
15:10:14 <Iceland_jack> @ty fmap reverse getLine
15:10:15 <lambdabot> IO [Char]
15:10:17 <geekosaur> you do not control when that interpreter does its thing
15:10:28 <Iceland_jack> 'reverse :: String -> String' is lifted to 'IO String'
15:10:37 <Iceland_jack> to produce another 'IO String'
15:10:51 <jle`> the "point" of Haskell code is to assemble one giant IO () --- that is, one giant blob of opcode/assembly/c--
15:11:00 <jle`> you assemble that giant IO () using pure, sideffectless functions
15:11:02 <genericpersona> was there a moment when all of this suddenly clicked for you?
15:11:11 <jle`> and then GHC compiles it to the assembly
15:11:15 <jle`> and then your *computer*, your CPU
15:11:16 <geekosaur> i fyou want to feed a pure value to that interpreter, you use `return` which attaches the pure value to another special runtime opcode. and at that point you "lose control" of the value; the interpreter is not under your control
15:11:18 <jle`> runs that resulting compiled thing
15:11:28 <Qfwfq> Relatedly: is "there's no naked term on the right-hand side of the monad interface's functions" a valid proof that "Monad m => m a -> a" can't be constructed?
15:11:41 <Para_> okay Iceland_jack :)
15:11:44 <genericpersona> okay, but let's assume i want a random Int but i want to pass that randomly generated Int to a pure function; i can't do this, right?
15:12:02 <Para_> just the last question before I go eat --
15:12:04 <MP2E> You can, by "lifting" the function with fmap
15:12:06 <Iceland_jack> genericpersona: you can do this
15:12:19 <Iceland_jack>     n <- randomInt
15:12:19 <Iceland_jack>     pureFunction n
15:12:26 <genericpersona> ah
15:12:26 <jle`> genericpersona: you do'nt have a random Int, you have "a object representing a way to produce a random int"
15:12:29 <jle`> right?
15:12:33 <genericpersona> which is do notation which is shorthand for bind?
15:12:34 <Qfwfq> @type f = extract :: Comonad m => Monad m => m a -> a -- obvs.
15:12:35 <lambdabot> parse error on input ‘=’
15:12:39 <jle`> an IO Int isn't a random int
15:12:41 <Qfwfq> @type extract :: Comonad m => Monad m => m a -> a -- obvs.
15:12:42 <pjdelport> Qfwfq: For that it can't be costructed using the monad interface in general, yes. Individual Monad instances can go outside that, of course.
15:12:42 <lambdabot> Not in scope: ‘extract’
15:12:42 <lambdabot>     Not in scope: type constructor or class ‘Comonad’
15:12:45 <jle`> an IO Int is comuter instructions to produce a random Int
15:12:49 <geekosaur> from that point on you do things by building more opcodes telling the interpreter that, when it executes the program you are building for it, it should do <whatever> to the value it's working with. but you can't at any point tell it to execute the program up to that point and give you the value
15:12:56 <jle`> and lets's ay i have a function (*2), which multiplies an Int by two
15:13:01 <Para_> because fmap takes a function to another function, if you have f . g . h :: a -> b, you can then do fmap . f . g . h :: IO a -> IO b
15:13:01 <jle`> i can "transform my instructions"
15:13:04 <genericpersona> jle`: okay
15:13:08 <geekosaur> all you can do is feed it another opcode saying "when you get such and such value, do this to it"
15:13:15 <jle`> that is, if i have an IO Int, i can "transform it into a new IO Int"
15:13:22 <jle`> hm, (*2) might be a bad example
15:13:27 <jle`> if i have an IO Int, instructions to produce an Int
15:13:27 <Qfwfq> pjdelport: Yay
15:13:30 <jle`> and i have show :: Int -> String
15:13:36 <jle`> i can "transofrm" my IO Int into an IO String
15:13:38 <genericpersona> geekosaur: ah, that kinda helps
15:13:51 <jle`> i can turn my IO Int --- instructions to rpoduce an Int --- into an IO String --- instructions to produce a string
15:13:52 <pjdelport> Para_: You would spell that like: fmap (f . g . h) someThing
15:13:53 <jle`> using fmap
15:14:00 <jle`> fmap :: (Int -> String) -> (IO Int -> IO String)
15:14:10 <jle`> "fmap show" is an *IO Transformer*
15:14:12 <Para_> ah right, because its application, not composition
15:14:16 <jle`> it turns an IO producing an Int
15:14:19 <jle`> into an IO producing a String
15:14:29 <Para_> alright thanks guys, I'll be back later!
15:14:35 <Qfwfq> I don't know how to prove that 'f :: a -> b' is only inhabited by _|_; my intuition is: a function is a table, and we don't have any terms in the co-domain without Enumerable, Default, etc.
15:14:37 <jle`> it turns your little chunk of instructions to produce an int, into a little chunk of instructions ot produce a string
15:14:46 <jle`> Qfwfq: where would that `b` come from...?
15:14:59 <Qfwfq> jle`: Precisely!
15:15:27 <jle`> f :: a -> b has to produce an item of any type requested by the caller
15:15:35 <jle`> same as x :: a
15:15:42 <jle`> so if the caller wants an Int, it has to return an Int
15:15:48 <Qfwfq> jle`: But I mean, I want a formalism in which I can prove that by deduction I guess.
15:15:49 <jle`> if it wants a Void.... it has to return a Void
15:15:56 <dottedmag> And the only value which exists in any type is bottom.
15:16:09 <Qfwfq> undefined :: forall a. a
15:16:10 <jle`> think about if the caller wants a Void
15:16:15 <jle`> data Void
15:16:19 <jle`> Void has no member
15:16:26 <jle`> so if i say f 1 :: Void
15:16:37 <jle`> well...that's saying that f 1 has to return somehing of something that has no member
15:16:58 <jle`> it's impossible to generate an arbitrary b for any type because not every type even has a member!
15:17:16 <dottedmag> jle`: one can argue that it might be bottom for types with members and something else for other types.
15:17:20 <Qfwfq> Oh, that's cool. We can have empty data types with 7.8
15:17:22 <dwcook> This sounds like two problems: a -> b is inhabited by _|_, and a -> b is uninhabited by anything besides _|_.
15:17:36 <dwcook> The first is trivial to show with the axiom _|_ :: forall a. a
15:18:06 <jle`> genericpersona: thinking of fmap, etc. as IO transformers made it click for me; and how you would apply "pure" functions to IO
15:18:27 <genericpersona> i appreciate the tutorial
15:18:51 <Qfwfq> dwcook: Well, we have that by ad absurdum I think.
15:19:00 <napping> dwcook: is the easiest way to show the second to assume you have something of type (forall a b . a -> b) in WHNF and consider the typing judgement?
15:19:13 <Qfwfq> dwcook: a -> b desugars to forall a b. a -> b, and we can define b as Void such that a -> b can't be defined.
15:19:39 <dwcook> Qfwfq: We don't have a -> b can't be defined, we already found an inhabitant of it
15:19:48 <dwcook> napping: I don't know
15:19:59 <Qfwfq> dwcook: Or rather, the only inhabitant is const undefined, because undefined is the only inhabitant of Void.
15:21:15 <napping> actually, isn't const _|_ a non-bottom element?
15:21:19 <dwcook> I think it is
15:21:31 <napping> so there's two - and that approach works nicely:
15:22:01 <napping> an -> in WHNF must and could be a lambda, which leaves us asking how we can have a,b,x::a |- e::b for any e
15:22:23 <napping> so any bottom gives us \_ -> undefined as another inhabitant
15:22:29 <dwcook> It looks like we've _disproved_ that _|_ is the only inhabitant of a -> b
15:22:38 <Qfwfq> Neat! :D
15:23:33 <dwcook> Hmm, though if anything I'd want to look at the assertion that const _|_ ≠ _|_
15:23:47 <napping> > const undefined `seq` ()
15:23:49 <lambdabot>  ()
15:23:58 <dwcook> Ignoring tricky things like seq, can we prove that?
15:24:13 <dwcook> Granted, seq _does_ exist
15:24:21 <napping> What's the problem?
15:24:30 <jle`> hm
15:24:39 <jle`> i fear i was incorrect in my reasoning then, sorry
15:24:40 <napping> I said const _|_ is (reduces to) an expression of type a -> b which is in WHNF
15:24:58 <napping> and there are also things like let x = x in x which clearly have no WHNF
15:25:18 <napping> I'm not claiming you can distinguish them in the language without seq
15:25:40 <napping> reasoning about typing derivations like that is pretty syntactic
15:25:47 <dwcook> Yeah, I'm thinking you can't. But of course seq is part of the system we're working in
15:26:44 <napping> Well, if some things like this are indistinguishable from _|_ despite having a WHNF, then proving there are not even any things with a WHNF of a particular form is stronger
15:27:15 <napping> so the body leaves you trying to fill in a,b,x::a |- ?? :: b
15:27:27 <napping> and um, I guess we're done?
15:28:06 <Qfwfq> Done and Qfwfq needs to read more denotational semantics
15:28:16 <dwcook> This seems like another one of those examples that makes Haskell a lousy formal system :)
15:28:40 <napping> _|_ tends to make most things lousy formal systems
15:28:59 <Lutin`> jonathan6: Get it yet? :)
15:29:00 <jonathan6> Lutin`: ok, so now I'm in a position where I can't seem to solve it. With my own type 'C' I have a help function f' :: C -> Set C, and I'm trying to define f :: Set C -> Set C, such that f s = map f' s. But this doesn't work, since f' is expected to return only C and not Set C
15:29:09 <jonathan6> timing :)
15:29:11 <dwcook> More specifically, e :: forall a. a does.
15:29:23 <dwcook> For some e
15:29:33 <napping> done by considering what typing rule we could possibly be using
15:29:42 <marchelzo_> Doesn't memoize from Data.Function.Memoize go against the idea of not having side effects?
15:30:07 <Iceland_jack> marchelzo_: Why do you say that?
15:30:38 <marchelzo_> Iceland_jack: because when you call the function for the second time with the same argument, the computer does something totally different
15:30:48 <marchelzo_> The first call must cause it to update some table
15:31:06 <Iceland_jack> marchelzo_: same thing happens when you force a thunk
15:31:09 <Lutin`> Yes so you need a function let's call it unionMap :: Ord b => (a -> Set b) -> Set a -> Set b
15:31:11 <Iceland_jack> but it's not visible to the user
15:31:14 <napping> when you let x = fib 50 in print x >> print x you also do something totally different the first and second times you force x
15:31:43 <marchelzo_> Iceland_jack: I'm new to Haskell; I'm not sure what forcing a thunk is.
15:31:55 <Lutin`> jonathan6: That is what you need to write
15:31:56 <Iceland_jack> marchelzo_: basically what napping is talking about
15:32:12 <napping> There's no promise about how much time or memory something takes
15:32:14 <Iceland_jack> when you define
15:32:15 <Iceland_jack>     x = 4 + 10
15:32:15 <Iceland_jack> Haskell doesn't necessarily compute 'x'
15:32:34 <napping> just that every time you refer to it you either always wait forever, or always eventually get the same answer
15:32:37 <Iceland_jack> if you say
15:32:37 <Iceland_jack>     print x
15:32:38 <Iceland_jack> at some future point, 'x' will be computed
15:32:41 <akater> So, thanks to non-strictness, one can pass to a function the overall state of the program, or maybe the overall state of OS?
15:32:41 <Lutin`> jonathan6: Using S.foldr and S.union
15:33:05 <Lutin`> jonathan6: And S.empty
15:33:15 <jonathan6> Lutin`: ok, I should manage to do such a thing :)
15:33:27 <akater> Is this the proper Haskell approach: suppose I have 6 tabs opened, and a table of 30000 columns in each tab. I can pass this whole data structure (tabs, tables inside them ,a nd whatever else) to a function, and since function only uses a tiny bit of data, this doesn't cause allocation of huge chunk of memory, or waste of CPU cycles?
15:33:42 <Iceland_jack> akater: sure
15:34:54 <marchelzo_> what does print x >> print x do?
15:34:57 <Iceland_jack> marchelzo_: http://conal.net/blog/posts/elegant-memoization-with-functional-memo-tries this might be interesting
15:35:01 <Iceland_jack> marchelzo_: it just prints x twice
15:35:01 <napping> prints x twice
15:35:11 <Iceland_jack> it's the same as
15:35:11 <Iceland_jack>     do print x
15:35:11 <Iceland_jack>        print x
15:35:13 <Lutin`> marchelzo_: Oh hey you're back :)
15:35:21 <marchelzo_> Lutin`: yeah :)
15:35:48 <Iceland_jack> marchelzo_: This paragraph is very relevant to your question :)
15:35:48 <Iceland_jack>     Perhaps surprisingly, memoization can be implemented simply and purely functionally in a lazy functional language. Laziness allows the implementation to build the memo table once and for all, filling in all the results for the function at all domain values. Thanks to laziness, the values don’t actually get computed until they’re used. As usual with lazy data structures, once a component has been evaluated, future accesses come for
15:35:49 <Iceland_jack>     free.
15:35:50 <pjdelport> marchelzo_: The better way to understand it is in terms of referential transparency: Haskell makes no guarantee about whether a function will be slow or fast to evaluate, but it *does* guarantee that you'll always get the same result.
15:36:40 <pjdelport> marchelzo_: A violation of referential transparency is if the function returned "5" and then later "10" for the same input.
15:36:54 <pjdelport> memoizing doesn't cause the latter.
15:37:23 <Iceland_jack> pjdelport: I think marchelzo_ is thinking that memoization must update some table internal to the function
15:37:33 <Iceland_jack> like you'd normally implement it
15:37:37 <marchelzo_> pjdelport: Yeah I understand that it conserves referential transparency, but I was just wondering about side effects. I guess Iceland_jack's paragraph there clears it up though.
15:37:41 <jle`> macron: it returns a new IO() that represents printing x twice
15:37:48 <napping> marchelzo_: you can define things like an infinite tree containing all the answers
15:37:50 <pjdelport> Iceland_jack: Well, you can do that and stay referentially transparent too, if you wanted to. :)
15:38:03 <Lutin`> marchelzo_: Have you figured out the recurrence relation yet?
15:38:05 <jle`> nvm i jumped in at the wrong time
15:38:06 <napping> let nats n = Node n (nats (2*n)) (nats (2*n+1))
15:38:13 <Iceland_jack> pjdelport: indeed :)
15:39:04 <marchelzo_> Lutin`: Yes. I solved that one. The answer ended up being very big. I think the recurrence relation  is the way to go on that one.
15:39:09 <pjdelport> marchelzo_: In that case, evaluation doesn't count as a side effect. (Or more generally, if your program can't observe it, it doesn't count as a side effect.)
15:39:14 <benzrf> @let nats n = Node n (nats (2*n)) (nats (2*n+1))
15:39:16 <lambdabot>  .L.hs:151:10:
15:39:16 <lambdabot>      Couldn't match expected type ‘Forest a -> Forest a’
15:39:16 <lambdabot>                  with actual type ‘Tree a’
15:39:16 <lambdabot>      Relevant bindings include
15:39:16 <lambdabot>        n :: a (bound at .L.hs:151:6)
15:39:18 <benzrf> perhaps!
15:39:18 <Lutin`> marchelzo_: Ah okay, which one are you on now?
15:39:25 <benzrf> :t Node
15:39:27 <lambdabot> a -> Forest a -> Tree a
15:39:28 <benzrf> o:
15:39:36 <marchelzo_> Lutin`: but once you solve it, you are able to see other people's solutions and I saw one that used memoize, that's how I found out about it.
15:39:42 <benzrf> @let nats n = Node n [(nats (2*n)) (nats (2*n+1))]
15:39:43 <lambdabot>  .L.hs:151:18:
15:39:44 <lambdabot>      Couldn't match expected type ‘Tree a -> Tree a’
15:39:44 <lambdabot>                  with actual type ‘Tree a’
15:39:44 <lambdabot>      Relevant bindings include
15:39:44 <lambdabot>        n :: a (bound at .L.hs:151:6)
15:39:47 <benzrf> ok
15:39:54 <marchelzo_> Lutin`: I haven't tried the next one yet, I had stuff to do.
15:40:05 <benzrf> oh wait wow
15:40:11 <Lutin`> marchelzo_: Ah memoize using fix?
15:40:16 <artyomkazak> can I somehow export a CPP #define from a module?
15:40:46 <Lutin`> jonathan6: If you get stuck I solved it
15:41:00 <marchelzo_> Lutin`: fix?
15:41:03 <marchelzo_> :t fix
15:41:05 <lambdabot> (a -> a) -> a
15:42:09 <Lutin`> marchelzo_: http://www.haskell.org/haskellwiki/Memoization#Memoizing_fix_point_operator
15:42:18 <Zekka> fix is \a -> a (fix a), right?
15:42:21 <marchelzo_> http://lpaste.net/105754 is the solution I am referring to. It's really short.
15:42:21 <Zekka> @src fix
15:42:22 <lambdabot> fix f = let x = f x in x
15:42:37 <Iceland_jack> Zekka: that definition is more complicated that it has to for efficiency
15:42:43 <Iceland_jack> it could be
15:42:43 <Iceland_jack>     fix f = f (fix f)
15:43:00 <Zekka> Iceland_jack: Got it. That was the only sane way I could think of to implement a function of that type
15:43:35 <jonathan6> Lutin`: I'll take it :) I'm more in this for the results than the way of reaching them
15:43:55 <benzrf> :t fix \s f -> f (s f)
15:43:57 <lambdabot> parse error on input ‘\’
15:44:01 <benzrf> :t fix $ \s f -> f (s f)
15:44:02 <lambdabot> (t -> t) -> t
15:44:09 <benzrf> O:
15:44:10 <benzrf> :t fix
15:44:11 <lambdabot> (a -> a) -> a
15:44:14 <benzrf> oh right
15:44:28 <benzrf> doesnt that mean that fix is isomorphic to a
15:44:31 <Zekka> :t fix fix
15:44:31 <jle`> :t fix id
15:44:33 <lambdabot>     Occurs check: cannot construct the infinite type: a ~ a -> a
15:44:33 <lambdabot>     Expected type: (a -> a) -> a -> a
15:44:33 <lambdabot>       Actual type: (a -> a) -> a
15:44:33 <lambdabot> a
15:44:46 <benzrf> jjjjjjjjj
15:44:48 <benzrf> oops
15:44:51 <Lutin`> Oh yeah forgot about Data.Function.Memoize
15:44:59 <benzrf> > fix id :: integral
15:45:01 <benzrf> > fix id :: Int
15:45:03 <lambdabot>  mueval-core: Time limit exceeded
15:45:05 <lambdabot>  mueval-core: Time limit exceeded
15:45:10 <benzrf> lambdabot: oh u
15:45:15 <Lutin`> jonathan6: unionMap f = S.foldr (S.union . f) S.empty
15:45:20 <Iceland_jack> @ty fix :: ((a -> b) -> (a -> b)) -> a -> b
15:45:21 <lambdabot> ((a -> b) -> a -> b) -> a -> b
15:45:39 <benzrf> > fix undefined
15:45:41 <lambdabot>  *Exception: Prelude.undefined
15:45:45 <Iceland_jack> > fix (\f n -> if n == 0 then [] else n : f (n-1)) 15
15:45:46 <lambdabot>  [15,14,13,12,11,10,9,8,7,6,5,4,3,2,1]
15:45:47 <benzrf> i dont know what i expected
15:45:52 <jle`> > fix error
15:45:54 <lambdabot>  "*Exception: *Exception: *Exception: *Exception: *Exception: *Exception: *Ex...
15:45:56 <Iceland_jack> > fix show
15:45:57 <jle`> obligatory
15:45:58 <lambdabot>  "\"\\\"\\\\\\\"\\\\\\\\\\\\\\\"\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"\\\\\\\\\\\\\...
15:45:59 <benzrf> huhehuehuh
15:46:00 <Iceland_jack> doubly so
15:46:05 <shelf> beautiful
15:46:11 <benzrf> > take 20 $ fix show
15:46:13 <lambdabot>  "\"\\\"\\\\\\\"\\\\\\\\\\\\\\\"\\\\\\\\\\"
15:46:19 <benzrf> easily compute powers of 2!!!
15:46:22 <benzrf> i mean 3
15:46:26 <benzrf> wait
15:46:28 <Lutin`> > fix (1337:)
15:46:28 <benzrf> 2 + 1 maybe
15:46:30 <lambdabot>  [1337,1337,1337,1337,1337,1337,1337,1337,1337,1337,1337,1337,1337,1337,1337,...
15:46:35 <jle`> hm
15:46:52 <benzrf> 1, 3, 7...
15:46:55 <jle`> > map length . group . take 100 $ fix show
15:46:57 <lambdabot>  [1,1,1,3,1,7,1,15,1,31,1,37]
15:47:09 <benzrf> oh pow 2 - 1
15:47:17 <benzrf> :t grp
15:47:18 <Iceland_jack> benzrf: also note that \\ is only \
15:47:19 <lambdabot> Not in scope: ‘grp’
15:47:20 <benzrf> :t group
15:47:22 <lambdabot> Eq a => [a] -> [[a]]
15:47:23 <benzrf> Iceland_jack: im aware
15:47:32 <jonathan6> Lutin`: thank you :) Worked like a charm
15:48:05 <conal> is hackage uploading broken? i'm getting "500 Internal Server Error"
15:48:18 <jle`> > (zipWith (+) <*> tail) . map length . group . take 100 $ fix show
15:48:20 <lambdabot>  [2,2,4,4,8,8,16,16,32,32,38]
15:48:29 <napping> pcapriotti: did you write optparse-applicative?
15:49:54 <jle`> > (zipWith (+) <*> tail) . map length . group . take 1023 $ fix show
15:49:56 <lambdabot>  [2,2,4,4,8,8,16,16,32,32,64,64,128,128,256,256,512,512]
15:50:22 <benzrf> whoah
15:50:38 <benzrf> :t zipWith (+)
15:50:39 <lambdabot> Num c => [c] -> [c] -> [c]
15:50:43 <benzrf> wait derp
15:50:46 <Lutin`> @define dropEveryOther (a:b:xs) = a:(dropEveryOther xs)
15:50:47 <lambdabot>  .L.hs:151:1: Warning:
15:50:47 <lambdabot>      Pattern match(es) are overlapped
15:50:47 <lambdabot>      In an equation for ‘dropEveryOther’:
15:50:47 <lambdabot>          dropEveryOther (a : (b : xs)) = ...
15:50:47 <lambdabot>  
15:50:53 <phaazon> do you guys have performance hint about Free?
15:50:58 <Zekka> benzrf: I thought that was a pretty cool use of Applicative
15:51:00 <Lutin`> Oh
15:51:01 <benzrf> yeah
15:51:04 <phaazon> I read something really… disturbing yesterday…
15:51:08 <benzrf> phaazon: oh?
15:51:10 <phaazon> it would be really poor in performance
15:51:12 <Lutin`> if you define in PM it defines globally
15:51:22 <phaazon> benzrf: let me find it
15:51:36 <Lutin`> > dropEveryOther $ map length . group $ fix show
15:51:40 <lambdabot>  mueval-core: Time limit exceeded
15:51:42 <benzrf> > let fib = zipWith (+) <*> tail $ (1:1:fib) in fib
15:51:44 <lambdabot>  [2,3,5,8,13,21,34,55,89,144,233,377,610,987,1597,2584,4181,6765,10946,17711,...
15:51:48 <phaazon> it’s disturbing because I’ve discovered a great use case for Free on this morning :)
15:51:49 <Zekka> experimented a little bit -- it allows you to turn a binary function into a unary function where the second argument is atransformation of the first argument
15:51:51 <Lutin`> > dropEveryOther $ map length . group . take 100 $ fix show
15:51:53 <lambdabot>  [1,1,1,1,1,1*Exception: L.hs:151:1-55: Non-exhaustive patterns in function d...
15:51:57 <Lutin`> woops
15:51:57 <phaazon> I *love* that abstraction
15:52:26 <Lutin`> > dropEveryOther . tail $ map length . group . take 200 $ fix show
15:52:28 <lambdabot>  [1,3,7,15,31,63*Exception: L.hs:151:1-55: Non-exhaustive patterns in functio...
15:52:30 <jle`> phaazon: fortunately it is not too hard to absorb Free directly into your data type if you have access to the underlying representation
15:52:48 <Lutin`> @undefine
15:52:49 <lambdabot> Undefined.
15:53:17 <phaazon> benzrf: http://ro-che.info/articles/2014-06-14-extensible-effects-failed.html , see the benchmark
15:53:43 <Iceland_jack> > dropEVERYOTHER . tail $ map length . group . take 200 $ fix show
15:53:44 <lambdabot>  [1,3,7,15,31,63,73]
15:54:05 <benzrf> good lord
15:54:08 <phaazon> maybe it’s not the same “free monad”?
15:57:22 <fread2282> Free Maybe == Nat, right?
15:57:37 <jle`> that's cute
15:57:58 <Zekka> benzrf: Found an interesting fib based on earlier eperimentation and @pl
15:58:11 <jle`> wouldn't it be Fix Maybe ?
15:58:12 <Zekka> > ap id (fix . ((zipWith (+) <*> tail) .)) ([1, 1]++)
15:58:14 <lambdabot>  [1,1,2,3,5,8,13,21,34,55,89,144,233,377,610,987,1597,2584,4181,6765,10946,17...
15:58:33 <quchen> fread2282: Free Maybe has two zeros, Pure () and Roll Nothing
15:58:53 <phaazon> Roll?
15:59:02 <quchen> The other constructor of Free
15:59:05 <benzrf> @hoogle tempfile
15:59:05 <quchen> Free Maybe Void should be Nat I think
15:59:07 <phaazon> Free
15:59:07 <lambdabot> System.IO openBinaryTempFile :: FilePath -> String -> IO (FilePath, Handle)
15:59:07 <lambdabot> System.IO openBinaryTempFileWithDefaultPermissions :: FilePath -> String -> IO (FilePath, Handle)
15:59:07 <lambdabot> System.IO openTempFile :: FilePath -> String -> IO (FilePath, Handle)
15:59:10 <benzrf> Zekka: ap is (<*>) fyi
15:59:14 <phaazon> it’s Free, not Roll
15:59:14 <athan> fread2282: That's a good one!
15:59:17 <benzrf> Zekka: also that's terrifying
15:59:22 <quchen> It's whatever you call it
15:59:22 <phaazon> :i Free
15:59:30 <benzrf> phaazon: lambdabot has no :i
15:59:32 <benzrf> ;-;
15:59:34 <phaazon> oops
15:59:36 <phaazon> yeah I know
15:59:37 <phaazon> :D
15:59:39 <benzrf> :k Free
15:59:40 <Zekka> benzrf: Yeah, I just copypasted \bot's @pl
15:59:40 <lambdabot>     Not in scope: type constructor or class ‘Free’
15:59:40 <lambdabot>     Perhaps you meant ‘Tree’ (imported from Data.Tree)
15:59:43 <benzrf> :t Free
15:59:44 <fread2282> quchen: on right, what's Free w/o Roll called?
15:59:45 <lambdabot> Not in scope: data constructor ‘Free’
15:59:48 <benzrf> :t Roll
15:59:50 <lambdabot> Not in scope: data constructor ‘Roll’
16:00:00 <benzrf> fread2282: identity ?
16:00:03 <quchen> Free without Roll is Identity with a dummy parameter ;-)
16:00:05 <artyomkazak> another question: can I hide a re-exported module
16:00:07 <benzrf> Zekka: q.q
16:00:07 <akater> Passing the entire state to functions is not recommended to advanced Haskell users?
16:00:16 <phaazon> Prelude Control.Monad.Free> :i Free
16:00:16 <phaazon> data Free f a = Pure a | Free (f (Free f a))
16:00:19 <benzrf> akater: depends on the context eh
16:00:36 <fread2282> bleh, without Pure
16:00:40 <Zekka> benzrf: i originally wrote it using an intermediate lambda but it was big and complicated
16:00:45 <Zekka> and I thought it would be cooler without the lambda
16:00:47 <benzrf> hrm
16:00:48 <Zekka> or at least scarier
16:00:53 * benzrf shudders
16:01:00 <phaazon> fread2282: Fix
16:01:26 <phaazon> Fix f a = Fix (f (Fix f a))
16:01:30 <benzrf> spooky, scary point free fibs are coming for you tonight alright
16:01:42 <jle`> i'm sure ap id is reducable to something
16:01:44 <jle`> :t ap id
16:01:45 <benzrf> [sung to the tune of spoopy scary sceletons[
16:01:45 <lambdabot> ((a -> b) -> a) -> (a -> b) -> b
16:02:00 <benzrf> jle`: do you mean (id <*>)
16:02:01 <benzrf> :-)
16:02:10 <jle`> no, not that :P
16:02:15 <jle`> soething simplor
16:02:28 <jle`> hm
16:02:40 <benzrf> ap id = (id <*>) in any well-behaved monad
16:02:45 <jle`> i mean
16:02:49 <jle`> something without monad/applicative
16:02:51 <phaazon> @index Fix
16:02:51 <lambdabot> bzzt
16:02:55 <benzrf> @index
16:02:56 <lambdabot> bzzt
16:02:58 <jle`> something without <*> or ap
16:02:59 <benzrf> -.-
16:03:01 <benzrf> @karma
16:03:02 <lambdabot> You have a karma of 1
16:03:03 <Zekka> benzrf: I just learned something
16:03:05 <benzrf> swoogity
16:03:06 <Zekka> I thought ap was in Control.Applicative
16:03:06 <benzrf> Zekka: ?
16:03:07 <phaazon> @hoogle Fix
16:03:08 <lambdabot> Control.Monad.Fix module Control.Monad.Fix
16:03:08 <lambdabot> Data.Fixed module Data.Fixed
16:03:08 <lambdabot> Data.Fixed data Fixed a
16:03:13 <Zekka> apparently it's not
16:03:15 <benzrf> no, ap is monadic (<*>)
16:03:27 <benzrf> @src (<$>)
16:03:27 <lambdabot> f <$> a = fmap f a
16:03:29 <phaazon> where the hell is Fix
16:03:32 <benzrf> hmmmmm
16:03:41 <benzrf> Zekka: same as how liftA is applicative fmap
16:03:44 <benzrf> @src liftA
16:03:45 <lambdabot> liftA f a = pure f <*> a
16:03:57 <benzrf> @src ap
16:03:58 <lambdabot> ap = liftM2 id
16:04:01 <Zekka> benzrf: Right, I just checked the type
16:04:03 <benzrf> kk
16:04:23 <Lutin`> Zekka: Or
16:04:25 <Lutin`> > fix (([1,1]++) . ap (zipWith (+)) tail)
16:04:27 <lambdabot>  [1,1,2,3,5,8,13,21,34,55,89,144,233,377,610,987,1597,2584,4181,6765,10946,17...
16:04:33 <benzrf> n-nope
16:04:54 <Zekka> Lutin`: That one's actually nearly readable
16:05:16 <jonathan6> I've received a lot of help here tonight, but I would want to bother with another question. It's an easy but a bit long question: http://pastebin.com/yZpKtkqA (I'm explaining it rather precisely). I believe the question is so stupid, that it might be worthwhile actually reading it though :)
16:05:19 <benzrf> wait, how is that lazy o.o
16:05:22 <benzrf> o nvm
16:05:23 <Zekka> > fix (([1,1]++) . (zipWith (+) <*> tail))
16:05:25 <lambdabot>  [1,1,2,3,5,8,13,21,34,55,89,144,233,377,610,987,1597,2584,4181,6765,10946,17...
16:06:04 <benzrf> jonathan6: awful idea
16:06:07 <benzrf> what's wrong with the lists?
16:06:42 <phaazon> jonathan6: I read “java”
16:06:44 <phaazon> stopped reading.
16:06:46 <phaazon> :D
16:06:47 <joseph07> jonathan6: pattern matching lists isn't so bad (op1:op2:op3:...)
16:07:21 <benzrf> @hoogle tempFile
16:07:22 <lambdabot> System.IO openBinaryTempFile :: FilePath -> String -> IO (FilePath, Handle)
16:07:22 <lambdabot> System.IO openBinaryTempFileWithDefaultPermissions :: FilePath -> String -> IO (FilePath, Handle)
16:07:22 <lambdabot> System.IO openTempFile :: FilePath -> String -> IO (FilePath, Handle)
16:07:23 <Iceland_jack> jonathan6: You can create new patterns irrespective of the internal representation with pattern synonyms
16:07:26 <jonathan6> phaazon: :) I know I know, there's reasons for that
16:07:27 <benzrf> hmmmmm
16:07:35 <benzrf> @hoogle tempfilename
16:07:36 <lambdabot> No results found
16:07:41 <benzrf> q.q
16:07:43 <jle`> jonathan6: you can still pattern match
16:07:45 <jonathan6> joseph07: except I wouldn't know how long that pattern would be
16:07:46 <benzrf> @hoogle IO FilePath
16:07:47 <lambdabot> Did you mean: :: IO FilePath
16:07:47 <lambdabot> package filepath-io-access
16:07:49 <benzrf> @hoogle :; IO FilePath
16:07:50 <lambdabot> Parse error:
16:07:50 <lambdabot>   :; IO FilePath
16:07:50 <lambdabot>    ^
16:07:52 <benzrf> gaah
16:07:53 <jle`> you just match on every option
16:07:55 <benzrf> @hoogle :: IO FilePath
16:07:56 <lambdabot> System.Posix.Terminal getControllingTerminalName :: IO FilePath
16:07:56 <lambdabot> System.Directory getCurrentDirectory :: IO FilePath
16:07:56 <lambdabot> System.Directory getHomeDirectory :: IO FilePath
16:07:58 <benzrf> alright
16:07:59 <fread2282> :k *
16:08:00 <lambdabot> parse error on input ‘*’
16:08:01 <benzrf> thats not helpful
16:08:04 <jonathan6> Iceland_jack: jle` how would it work?
16:08:05 <benzrf> fread2282: do you mean sort
16:08:07 <jle`> Foo (x:y:[]) is matching on your original
16:08:09 <benzrf> * does not have a kind
16:08:11 <benzrf> it *is* a kind
16:08:12 <fread2282> benzrf: no
16:08:12 <jle`> Foo (x:y:z:[]) is matching on three
16:08:20 <phaazon> what do you need with IO FilePath benzrf ?
16:08:24 <benzrf> phaazon: tempfile
16:08:33 <benzrf>       
16:08:34 <Iceland_jack> jonathan6: http://www.reddit.com/r/haskell/comments/24fvyz/pattern_synonyms_for_dates_and_an_irc_bot/ you can check this out
16:08:52 <Iceland_jack> but basically if you want to create a pattern that matches 'Just Nothing' you can do
16:08:52 <Iceland_jack>     pattern JN = Just Nothing
16:08:54 <jonathan6> jle`: still, I could pattern match on the list, but I don't know beforehand if I need the third or the 100:th item
16:09:02 <phaazon> benzrf: openTempFile?
16:09:07 <benzrf> heuh
16:09:14 <benzrf> i need to give it a path for that dont it
16:09:15 <benzrf> *i
16:09:31 <phaazon> sorry, WAT
16:09:32 <phaazon> :D
16:09:45 <Zekka> Iceland_jack: You're making me want to update to GHC7.8 now
16:09:54 <Iceland_jack> Zekka: great ;)
16:09:59 <joseph07> jonathan6: were you planning on creating a data type with 100 arguments and pattern matching on that?
16:10:12 <phaazon> benzrf: you want a function that genarates a temporary file and returns back the of the created file?
16:10:16 <phaazon> I know happstack does that
16:10:18 <Zekka> I actually wrote an IRC bot and ran into a 'patterns are huge and scary' problem
16:10:19 <jonathan6> joseph07: if I would generate them, then yes
16:10:21 <phaazon> not sure it’s in base though
16:10:22 <joseph07> jonathan6: you don't lose any pattern-matching ability by using a list
16:10:26 <joseph07> jonathan6: even in that case
16:10:32 <phaazon> +name
16:10:35 <Iceland_jack> Zekka: what do you mean?
16:10:58 <Zekka> Iceland_jack: I actually ran into the same problem the author of the article used as an example and could have solved it the same way
16:11:21 <Zekka> https://github.com/Zekka/gekko/blob/master/Gekko/Bot/Commands/HelloWorld.hs <- look at this sample command for an example
16:11:44 <Zekka> Line 15 could be made greatly simpler with some clever patterns
16:11:59 <Iceland_jack> Zekka: Yes no doubt!
16:13:18 <jonathan6> joseph07: you're right. I kind of fucked up asking that question. Trying to make it understandable, I abstracted away an important issue :P sorry to waste your and everyone else's time there
16:13:32 <Iceland_jack> Zekka: something like
16:13:32 <Iceland_jack>     pattern Message nick channel <- IRCMessage (Just (getNick -> nick)) "PRIVMSG" (channel:_)
16:13:42 <joseph07> jonathan6: no problem! just waiting for our QA servers to come back online
16:13:56 <Iceland_jack> that way you also avoid calling 'getNick' in the actual body, but it forces it to be unidirectional
16:14:17 <Zekka> Iceland_jack: That's not a bad idea at all
16:14:52 <Zekka> minding that I'd probably want to expose the whole source in some cases (which would be not too hard to do)
16:15:09 <Iceland_jack> yes you can use a new pattern for that if you want
16:15:23 <akater> Lisp preconception ahead: so why isn't Haskell homoiconic?
16:15:38 <Zekka> Yeah. There's not an obvious way to throw it into the composite pattern?
16:15:40 <benzrf> akater: what do you mean?
16:15:45 <Zekka> pattern Message nick hostmask message, for instance?
16:15:47 <benzrf> akater: why *should* it be homoiconic?
16:15:52 <Iceland_jack> or exposing a record where you can do
16:15:52 <Iceland_jack>     Message Foo{nick} channel -> ...
16:15:56 <benzrf> akater: do you mean why doesnt it use sexprs?
16:15:59 <benzrf> or wat
16:16:05 <Zekka> Iceland_jack: Oh yeah, there's a good thought
16:16:22 <Zekka> and then I could replace getNick with a function that returns such a record in your description
16:16:23 <akater> benzrf: I don't want to write several lines of import. In a language I'm familiar with I can write something like “map import packages”.
16:16:35 <benzrf> akater: that's not a homoiconicity issue
16:16:44 <benzrf> that's a matter of import being special syntax instead of a function
16:17:07 <benzrf> akater: ruby isnt homoiconic, but it uses a normal method for importing, so you could do something similar
16:17:24 <c_wraith> being special syntax rather than a function means that imports can be statically analyzed.
16:17:32 <c_wraith> Man, python imports are annoying that way.
16:18:00 <Iceland_jack> then you can create something like
16:18:01 <Iceland_jack>     privMsg chan msg handle = sendMessage "PRIVMSG" [chan, msg] handle
16:18:01 <Iceland_jack> and using it as
16:18:04 <Iceland_jack>     sayHey (Message nick chan) handle = True <$ privMsg chan ("Hello, " ++ nick ++ "!") handle
16:18:07 <Iceland_jack>     sayHey _                   _      = False
16:18:13 <Zekka> akater: When you say you want Haskell to be homoiconic, do you mean "I want to transform code as data", or "I want code to look like a fundamental data structure", or what?
16:18:16 <akater> benzrf: OK! 1) How do I avoid repeating? Or is it a bad idea? 2) Why is this not a homoiconicity issue? I thought I can do it in Mathematica precisely because it's homoiconic.
16:18:41 <c_wraith> akater: as far as I can tell, homoiconicity is the enemy of code reuse.
16:18:44 <Iceland_jack> Zekka: I removed one paramter, as a matter of style I would make it constant when updating the Command record
16:19:08 <benzrf> akater: homoiconicity just means that the AST for code is the same kind of structure that code commonly operates on
16:19:35 <Zekka> I'd point out that Haskell does let you inspect the AST -- it's just really ugly to do so
16:19:44 <Iceland_jack> Zekka: So you can do
16:19:44 <Iceland_jack>     _result = const sayHey
16:20:14 <Zekka> Iceland_jack: That's fair -- I'm actually forgetting what that parameter does
16:20:39 <Iceland_jack> Zekka: trigger arguments I guess
16:20:44 <Zekka> Oh, right -- it's what comes out of the trigger function as a string list
16:21:09 <Zekka> This is old code -- I really should rewrite that to use ExistentialQuantification instead of just dropping into types like [String]
16:22:07 <Zekka> I never intended to use it for much -- I only rewrote it because my friend was rewriting his own bot in C# and didn't believe Haskell was good for very much
16:22:16 <akater> Zekka: For sure inspecting AST is ugly: it's always ugly when it's not Lisp. :-) But still, my argument for homoiconicity still holds: I don't like seeing anything repeated in the program text.
16:22:55 <Zekka> akater: Well, in the specific case you brought up, you actually can avoid repetition by packaging all your imports into one module
16:22:56 <Iceland_jack> akater: Haskell takes a different approach to that, a more principled approach but both are valid
16:23:19 <Zekka> It defines x-level functions for a variety of compiletime objects
16:23:35 <Zekka> i.e., type synonyms are approximately type-level functions (with caveats!!!!)
16:23:37 <Iceland_jack> Coming from the Lisp community, macros were the silver bullet for everything
16:23:59 <Zekka> Pattern synonyms are not-really-but-something-like pattern-level functions
16:24:14 <Iceland_jack> Zekka: it's interesting that you should mention pattern-level functions
16:24:45 <Zekka> Iceland_jack: Why's that?
16:24:49 <Iceland_jack> I've been wondering how to reconcile pattern algebras and first-class patterns with Haskell
16:25:10 <Iceland_jack> been meaning to write a proposal for it
16:25:33 <Zekka> I've run into a few usecases where first-class patterns would have been nice but I couldn't think of any typesafe way to implement them
16:25:55 <Iceland_jack> There is so much cool stuff you can get with 'pattern families' you wouldn't believe it
16:25:58 <Zekka> if you aren't careful you get 'We want polymorphism over types with a constructor that looks a certain way'
16:26:00 <Iceland_jack> simple to implement
16:26:09 <Zekka> and so far I don't think Haskell's type system readily supports such a thing
16:26:29 <Zekka> Although you could likely express such a relationship with typeclasses
16:26:55 <Iceland_jack> well there are different ways you can define higher-order patterns, but I don't think they're as readily interesting as pattern families
16:27:18 <Zekka> Well, what *is* a pattern family?
16:27:47 <Zekka> (By the way, it might be a good idea to move to another channel - was chewed out earlier for having drawn-out conversations in here and not in #-overflow)
16:28:00 <Iceland_jack> sure
16:28:35 <akater> benzrf: Why should improt be special syntax? :-) It doesn't differ much “why Haskell should be homoiconic”, and I can't expect this to lead anywhere. It's merely an Occam's razor: if functions are enough why use special syntax?
16:28:57 <Zekka> akater: I think it's so that the compiler can determine in advance how to build your project
16:29:07 <Zekka> by determining what the dependencies of each thing are with a minimum of effort
16:29:15 <Zekka> not that that's necessarily an argument that it must be, but I think that's the reason
16:29:26 <akater> Zekka: Yes, that's the reason I suspected: homoiconicity contradicts static type checking.
16:29:48 <tulcod> fuck yeah. it works. IT'S ALIVE!!
16:30:12 <Zekka> It's not really typechecking in this case although not knowing what everything depends on in advance could break typechecking
16:30:16 <benzrf> akater: so that you can import from outside IO
16:30:21 <benzrf> akater: imports are not pure
16:30:49 <benzrf> akater: also, import being standalone has NOTHING to do with homoiconicity
16:30:54 <Zekka> for instance there's no guarantee that you'd have all your instances at time of evaluating codeat compiletime if imports could occur during analysis
16:30:54 <benzrf> pls understnad that -.-
16:30:57 <benzrf> *understand
16:31:03 <Zekka> I'll point out that Haskell, like I said, lets you inspect the syntax tree
16:31:07 <Zekka> But it specifically *doesn't* allow you to modify imports
16:32:00 <benzrf> how do i make cabal install load files
16:32:03 <benzrf> into places
16:32:13 <benzrf> share files or somethin
16:32:17 <c_wraith> and that's because imports being known statically is *really really really really really (and really) good*
16:32:35 <Zekka> benzrf: I think you have to specify data-dir,but I don't remember what else
16:32:43 <benzrf> shiz
16:32:49 <benzrf> hmm
16:33:08 <benzrf> can my code find out what the cabal data dir is
16:33:12 <benzrf> is there a function for that
16:33:27 <c_wraith> look in the appropriate Paths module
16:33:34 <c_wraith> they are generated automatically by cabal
16:34:30 <benzrf> aha
16:34:35 <benzrf> Paths module?
16:34:45 <tulcod> akater: the people who made haskell didn't do so by picking every generalization and abstraction they could
16:34:45 <c_wraith> the name is based on your package name
16:34:57 <tulcod> akater: it's based on mathematical principles. and those tend to be rather abstract.
16:35:03 <benzrf> c_wraith: ?
16:35:28 <c_wraith> benzrf: http://www.haskell.org/cabal/users-guide/developing-packages.html  search for "Paths_"
16:35:33 <benzrf> ah, thanks
16:35:45 <benzrf> is there a way to ensure the permissions on the copied-over file?
16:36:00 <c_wraith> the only thing I can think of is some sort of custom Setup.hs
16:36:07 <akater> benzrf: Zekka: Iceland_jack: All right, since I still don't know the definition of IO, I have to think about it. Thank you!
16:36:12 <benzrf> :\
16:36:30 <tulcod> benzrf: well that's not quite a surprise - file permissions are OS-specific
16:36:33 <benzrf> u know what ill just hardcode the stuff
16:36:37 <Zekka> akater: Sorry if I wasn't of more help
16:36:39 * benzrf rolls eyes
16:36:46 <benzrf> ok u know what no thats the wrong approach
16:36:58 <benzrf> tulcod: ghci wont load scripts that are world-writable
16:37:08 <benzrf> so i wanna make sure about this x.x
16:37:21 <tulcod> why would it install data files world-writable?
16:37:55 * benzrf shrugs
16:37:58 <benzrf> it did for ghc-vis!
16:38:10 <benzrf> oh wait
16:38:12 <benzrf> not world-writable
16:38:14 <benzrf> but group-writable
16:38:20 <benzrf> that seems to be the issue -.-
16:38:31 <benzrf> cmon ghci stop being so goddamn paranoid!!
16:38:37 <benzrf> is there a way to turn off the paranoia
16:38:50 <tulcod> ghci --no-paranoia
16:39:28 <benzrf> wait
16:39:29 <benzrf> The Paths_pkgname module is not platform independent so it does not get included in the source tarballs generated by sdist.
16:39:34 * benzrf facepalms
16:39:38 <benzrf> gaah
16:39:48 <benzrf> so it wont work with hackage
16:39:57 <benzrf> ok fuck this im hardcoding it and having it dump it as a temp file
16:40:01 * benzrf gnashes his teeth
16:40:03 <c_wraith> benzrf: no, study more
16:40:08 <benzrf> c_wraith: huh?
16:40:18 <c_wraith> benzrf: you specify them as data files in your cabal file
16:40:33 <benzrf> wha?
16:40:33 <c_wraith> benzrf: cabal sdist packages them up
16:40:35 <tulcod> benzrf: also, ghci doesn't complain here when laoding a chmod 0777 file
16:40:41 <yac> apparently my code https://github.com/yaccz/hs-sutka/blob/master/src/Main.hs depends on LANG environemnt variable
16:40:44 <benzrf> tulcod: no, for the ghci-script
16:40:59 <benzrf> c_wraith: specify what now?
16:41:09 <c_wraith> benzrf: where the data files get dumped is what's specified in the Paths_ module
16:41:37 <yac> something to do with the regex matching
16:41:39 <benzrf> oooooooooooooooooooooh i see
16:41:48 <benzrf> it will still generate it on build?
16:41:55 <benzrf> it just isnt listed from source in sdist?
16:42:02 <c_wraith> it copies them out of the tarball
16:42:15 <c_wraith> (generated by cabal sdist)
16:42:16 <benzrf> yes
16:42:22 <benzrf> i need runtime knowledge of the file location
16:42:23 <benzrf> -.-
16:42:46 <benzrf> The Paths_pkgname module is not platform independent so it does not get included in the source tarballs generated by sdist.
16:42:54 <tulcod> benzrf: i'm not sure what hte problem is? the Paths_ thing generated by cabal tells you where it installed the data files
16:42:58 <benzrf> The Paths_pkgname module is not platform independent so it does not get included in the source tarballs generated by sdist.
16:43:07 <c_wraith> benzrf: it sounds like you're going about this backwards
16:43:08 <tulcod> why would you want that?
16:43:16 <benzrf> so that it is usable from hackage
16:43:30 <tulcod> then it's not data files
16:43:33 <c_wraith> benzrf: back up a few dozen steps
16:43:36 <benzrf> ok
16:43:53 <benzrf> i want to package a ghci script that my program references when launching a custom ghci
16:44:00 <c_wraith> and?
16:44:06 <benzrf> therefore, i need to package the script as a data file
16:44:07 <c_wraith> add it as a data-file in your .cabal file
16:44:10 <akater> tulcod: Lots of people say Haskell is very math-heavy. Honestly, my impression is 1) it turns off potential users; 2) it's not really math-heavy: not so much is defined in terms of well-known mathematical structures. 1) is far more important, though.
16:44:10 <benzrf> and my program needs to know its path
16:44:26 <c_wraith> then it will get included by cabal sdist and copied into the Paths_ location on installation
16:44:32 <benzrf> but
16:44:33 <benzrf> The Paths_pkgname module is not platform independent so it does not get included in the source tarballs generated by sdist.
16:44:45 <c_wraith> that module is created ON INSTALLATION
16:44:48 <tulcod> akater: math turning people off is only a good thing :-/
16:44:49 <benzrf> oh.
16:44:50 <c_wraith> please read that a dozen times
16:45:04 * benzrf facepalms
16:45:32 <tulcod> akater: regarding 2. yeah. the best quote about haskell is that you don't /need/ to know category theory to learn haskell, which is appropriate because it's absolutely not essential, but you see a lot more links between stuff if you do
16:45:57 <Zekka> akater: But it does use mathematical structures which don't have a history in programming, doesn't it?
16:46:10 <Zekka> What would you say i.e. Applicative is?
16:46:24 <dwcook> Applicative was only retrofitted to the mathematics, from what I hear
16:46:25 <tulcod> *e.g.
16:48:51 <marchelzo_> Does anyone know of a function that groups elements of lists in blocks that satisy a condition? Like if the condition was (\x -> head x /= 'a') and you give it the list ["abc", "bcd","cde","abe","ghc"] and it gives back ["abcbcdcde", "abeghc"].
16:49:04 <marchelzo_> s/satisy/satisfy
16:49:15 <jle`> partition
16:49:24 <marchelzo_> i knew it had to exist already
16:49:25 <marchelzo_> thanks
16:49:42 <akater> tulcod: Of course, it's obvious Haskell was desinged with great care. It's great. If homoiconicity is not included, there is probably a reason. For some enchanted guys like me, the question is why /not/ to include it. :-)
16:49:51 <jle`> oh
16:49:59 <jle`> i'm not sure if that's what you want
16:50:01 <jle`> also look at groupBy
16:50:14 <marchelzo_> jle`: ok
16:50:21 <tulcod> akater: that's the wrong way to approach the issue
16:50:48 <yac> how can I set LANG from within running haskell program?
16:50:53 <tulcod> akater: you might as well ask why haskell didn't include OOP, dynamic types, pointers, macros, ...
16:50:57 <yac> and putEnv isn't working
16:51:34 <tulcod> akater: the central idea to mathematics is that you *restrict* yourself to a certain language. and for programming, that language better be rich enough.
16:51:49 <tulcod> akater: turns out that category theory is quite a rich basis, so it is one of the major building blocks of haskell
16:52:46 <tulcod> akater: why is import not part of the AST? because that question doesn't make sense in the language we're using here
16:53:13 <tulcod> now, if it were a practical addition to haskell as a programming language, that would change the matter, but as a matter of fact it doesn't
16:53:29 <akater> tulcod: Nobody knows what the central idea of mathematica is. I think it's about constantly improving the language and making it more general, not resticting. But I'm not sure if this is not off-topic. :-)
16:53:37 <marchelzo_> jle`: Yeah groupBy does pretty much exactly what I was looking for. ty
16:53:42 <tulcod> akater: how do you know that nobody knows? :-/
16:54:07 <benzrf> akater: i think you are confusing homoiconicity with first class functions
16:54:15 <benzrf> and common operations as functions
16:54:37 <akater> benzrf: Maybe. The language I like arguably doesn't have functions at all.
16:54:40 <Zekka> I think what he's really wondering is why Haskell separates compiletime and runtime operations at all
16:55:55 <akater> Zekka: That's a difficult part. I'm not sure I understand what people mean whe they say “compile time”. I don't expect anyone to explain me now. :-) I don't get it for a couple of years by now.
16:56:07 <c_wraith> akater: are you aware of static analysis?
16:56:17 <Zekka> akater: When you try to run a haskell program, haskell first converts it to a machine representaiton
16:56:25 <Zekka> that's called compilation
16:56:32 <Zekka> (rather, GHC, the Haskell compiler, does)
16:57:13 <akater> tulcod: OOP is useless; I don't know what dynamic types are; pointers are hard to formalise (but they probably should be).
16:57:15 <tulcod> Zekka: you're suggesting some kind of JIT, of which i'm not away
16:57:16 <benzrf> akater: see there's this thing 'compiling'
16:57:28 <tulcod> akater: woah
16:57:32 <Zekka> tulcod: I am?
16:57:37 <benzrf> akater: which is when you take a program in some language and convert it to some other form
16:57:39 <Zekka> I didn't realize I was doing that
16:57:44 <benzrf> usually something machine-executable
16:57:47 <tulcod> Zekka: "when you're trying to run, it'll compile it just so that you can run it" :)
16:57:56 <Zekka> tulcod: Oh, you're right.
16:57:56 <benzrf> akater: i assume youve mostly used interpreted languages
16:58:09 <akater> benzrf: Only one, actually.
16:58:24 <Zekka> Which one? I'm going to assume it's a Lisp.
16:58:30 <tulcod> php
16:58:34 <benzrf> ewwwwww
16:58:34 <Zekka> (surprise me and say Io)
16:58:37 <akater> benzrf: Common Lisp is compiled. :-)
16:59:03 <hpc> tulcod: have i got the package for you!
16:59:13 <akater> benzrf: Mathematica / Wolfram language. I've tried Python, JS, Delphi (usedit for a while), C… it was awful experience.
16:59:24 <tulcod> hpc: hm?
16:59:30 <hpc> http://hackage.haskell.org/package/acme-php -- :P
16:59:35 <tulcod> ah :P
16:59:51 <akater> benzrf: I understand what compilation is. I don't understand what “compile time” is.
16:59:51 <benzrf> akater: it was an awful experience because you did not learn the language
16:59:59 <benzrf> akater: compile time is the time when something is compiled
17:00:32 <c_wraith> akater: Have you heard of static analysis?  (this question is relevant)
17:00:35 <tulcod> hpc: i love the entire Acme collection :)
17:00:38 <jfischoff> http://en.wikipedia.org/wiki/Compile_time
17:00:56 <benzrf> tulcod: have you seen acme-inator
17:00:59 <benzrf> it's brilliant
17:01:15 <dagano> Data.Redis or hedis? are they the same?
17:01:25 <tulcod> haha
17:02:20 <akater> benzrf: No, it was because it was hard to do everything. With Mathematica everything was simple. But it's not compiled, so I decided to go here.
17:02:47 <c_wraith> akater: static analysis is the process of discovering something about a program as possible *without* running it.  Haskell is intentionally designed to make it possible to discover a lot about a program without running
17:02:49 <benzrf> akater: no, it was because you were expecting something different from what it was and decided that it was hard because it wasnt what you thought
17:03:00 <tulcod> benzrf: amen
17:03:02 <benzrf> tulcod: brilliance depends on knowledge of phineas + ferb
17:03:11 <tulcod> benzrf: again amen
17:03:14 <akater> benzrf: No, it's because these languages don't have a central idea (except for C). But that's just opinions, I'm not sure I'm not flooding uselessly.
17:03:22 <benzrf> akater: top lel
17:03:26 <tulcod> akater: dude
17:03:29 <jle`> akater: on one level, you can think of Haskell as a "code generator"
17:03:34 <jle`> it "generates assembly code"
17:03:38 <jle`> or "generates C-- code"
17:03:40 <jle`> or javascript code
17:03:44 <jle`> in a "type-safe" way
17:03:47 <tulcod> if you don't understand something, just ask people to explain it. don't go around preaching that it was stupid in the first place
17:03:58 <akater> c_wraith: That's what brought me here.
17:04:10 <jle`> in the generation process, it is careful to ensure that waht it generates will be as "correct" as possible
17:04:18 <jle`> so it disallows "incorrect" generations, using a type system
17:04:33 <benzrf> akater: you are acting awfully know-it-all for somebody with comparatively little programming knowledge & experience
17:04:44 <tulcod> jle`: to be fair some other languages are theoretically more successful in that
17:05:05 <jle`> it might help to explain what compile-time means
17:05:34 <jle`> wb c_wraith
17:06:10 <jle`> you missed a message directed at you
17:06:15 <akater> benzrf: I merely have lots of opinions. I don't expect anyone to agree. I'm here to learn, not to waste your time, and I didn't want this all to start. :-(
17:06:25 <c_wraith> jle`: darn video driver updates.  silly windows
17:06:51 <benzrf> akater: perhaps you have opinions, but you are asserting them over those of people with more salient knowledge
17:07:00 <benzrf> which is kind of obnoxious
17:07:19 <Zekka> akater: Although don't let that stop you from asking questions
17:07:25 <Zekka> because most of the people here like answering questions
17:07:42 <jle`> Mathematica is not a "code generator" language --- code generation is not a part of the semantic model.  rather it is like an "interpreted" language --- commands are interpreted "live" by some program written to interpret instructions
17:07:46 <benzrf> akater: part of the problem is how your first question was phrased, i think
17:07:54 <tulcod> akater: it's not bad to have unfounded opinions, but you shouldn't be surprised when people will fiercely disagree with you - especially on the internet
17:08:25 <jle`> wow such h8
17:08:31 <jle`> i definitely jumped in the middle of something >_>
17:08:34 <benzrf> akater: you didnt say 'how can i cut down on boilerplate in my imports', you said 'why doesnt haskell support the one true way of metaprogramming that will let me cut down on my import boilerplate'
17:08:50 <Iceland_jack> Normally #haskell is acts respectful even though people fiercely disagree
17:09:01 <Iceland_jack> s/is /
17:09:03 <akater> jle`: Everything is a code generator. BTW, does anybody in Haskell community has a goal to mathematically formalise models of x86 / ARM / ... architectures from which (coupled with from program text, of course) native code [that is optimal in some sense] would be derived?
17:09:08 <c_wraith> akater: The real problem is that you don't listen to the answers.  You just ignore them and say that you are the only one who knows anything.
17:09:08 <benzrf> akater: which got people a bit argumentative p;
17:09:38 <jle`> akater: it's a matter of semantics, not necessarily implementation
17:09:40 <Zekka> akater: How is that distinct from what the Haskell compiler already does?
17:09:55 <benzrf> c_wraith: it seems almost like an XY problem, but with opinions instead of approaches
17:10:06 <Iceland_jack> akater: you might be interested in type assembly language (TAL)
17:10:08 <Iceland_jack> *typed
17:10:09 <Zekka> I'm assuming what you're trying to ask is "is there a math model which gives us a higher-level language to express the semantics of native-code programs so that we can generate optimal code for them?"
17:10:28 <akater> jle`: I understand the difference of course. I wouldn't join this chat otherwise, I guess. )
17:10:46 <benzrf> Zekka: i think it was 'is there a way to formalize CPUs in such a way that a generic code generator can understand them and optimize for em'
17:11:20 <tulcod> akater: optimal compilation is essentially an unsolvable problem
17:11:31 <levi> akater: I think there's a group planning to do those sorts of things, but not necessarily with Haskell. But the goal is more to be correct than optimal.
17:11:36 <Zekka> benzrf: What's meant by 'a generic code generator'?
17:12:09 <benzrf> Zekka: something that parses formalized CPUs and generates for TheMoonMaster
17:12:10 <benzrf> *them
17:12:15 <benzrf> which seems kinda infeasible
17:12:52 <Zekka> Oh, I see, you mean 'something that takes a description of a CPU and compiles from an intermediate language to their assembly language, as well as possible?'
17:12:52 <benzrf> but akater seems to be asking about formalizations of CPUs used to generate bytecode, which would imply the existence of something to understand the formalizations
17:13:08 <benzrf> Zekka: something like that i think
17:13:10 <benzrf> akater: is that right?|
17:13:11 <Zekka> er, to the CPU's assembly language*
17:13:26 <akater> Zekka: For example, to assembly, yes. With or without intermediate layers.
17:13:52 <akater> Zekka: But “as well as possible” varies, obviously.
17:13:56 <Zekka> Well, when I say assembly I just mean the language of the CPU
17:14:01 <MP2E> So kinda like a compiler-compiler? That takes a description of a source language and an assembly code target and generates a compiler with the information given
17:14:06 <MP2E> note that it is in no way efficient :P
17:14:14 <Zekka> and when I say "intermediate language" I mean that such a code generator probably must take some description of the program
17:14:34 <Zekka> and that it might not be the language the user enters code in, but a representation of the code the user wrote in another language
17:14:48 <Zekka> So I'm basically thinking of an LLVM equivalent parameterized over CPU descriptions
17:15:03 <benzrf> cool
17:15:03 <akater> Iceland_jack: Thanks, I bookmarked it. )
17:15:13 <benzrf> that would have to be awfully smart :\
17:15:31 <hpc> isn't llvm that exact thing?
17:15:46 <benzrf> the curse of programming: that which is general is inefficient, and that which is efficient is specific
17:15:48 <Zekka> hpc: Pretty much
17:16:01 <Zekka> Except for LLVM, a CPU description is just a code generator for that CPU, if I'm not mistaken
17:16:13 <Zekka> it's not an instruction set and 'you're on your own, kiddo!'
17:16:21 <Zekka> which is what I think akater would be interested in
17:16:33 <tulcod> hpc: afaict, llvm is just a library of internal representation transformers
17:16:51 <tulcod> ie optimizers
17:17:09 <tulcod> anything to actually interface with programming languages or target languages is a plugin
17:17:23 <Zekka> I basically mean that LLVM carries descriptions of a CPU the same way  GCC is a description of the C programming language
17:17:24 <benzrf> tulcod: sounds beautiful
17:17:26 <akater> It was a tangential question, about architecture formalisation.
17:17:36 <levi> CPUs are not terribly different from one another in the languages they interpret.
17:17:54 <akater> I understand it's hard, and is probably a separate field of research.
17:18:07 <Iceland_jack> akater: It is, are you familiar at all with how the GHC compiler works?
17:18:14 <levi> Partial evaluation and Futamura projections are an interesting tangential notion: http://en.wikipedia.org/wiki/Partial_evaluation#Futamura_projections
17:18:18 <benzrf> akater: you know what you have
17:18:19 <benzrf> akater: hubris!
17:18:23 <Iceland_jack> You may be interested in Core
17:18:26 <benzrf> akater: congratulations :)
17:18:28 <Zekka> whee, hubris
17:18:32 <Zekka> join the hubris club
17:18:52 <Iceland_jack> join :: Hubris (Hubris a) -> Hubris a..
17:19:02 <benzrf> (⊙ω⊙)
17:19:14 <benzrf> http://www.ebbits.net/strip/2014.06.06 hubris
17:19:24 <Zekka> (return :: (Hubris a -> a)) Club
17:19:41 <akater> Iceland_jack: No! I'm in process of setting up interactive environment now.
17:20:10 <Iceland_jack> akater: Haskell is compiled to a very small language based on System FC, a model of computation
17:20:22 <Iceland_jack> which then gets optimized during various optimization passes
17:20:35 <Zekka> Hubris is more of a comonad than a monad, though,/ given that with effort and dedication, you can surely escape its effects
17:20:49 <jle`> it is easier to enter it than exit it
17:20:58 <Iceland_jack> jle`: I could easily exit it
17:21:07 <Iceland_jack> sorted
17:21:13 <hpc> i just reset to a continuation where i never entered it
17:21:18 <Iceland_jack> akater: ( http://blog.ezyang.com/img/ghc-pipeline.png )
17:21:39 <identity> pattern synonyms aren't in 7.6.3?
17:21:44 <Iceland_jack> nope
17:21:45 <hpc> that image is out of date
17:21:49 <identity> :(
17:21:52 <identity> i should update
17:21:58 <Iceland_jack> hpc: it's good enough for akater
17:22:02 <Iceland_jack> identity: first appeared in 7.8
17:22:05 <benzrf> must comonads be cofunctors too?
17:22:07 <akater> Iceland_jack: Oh, great, thank you!
17:22:12 <edwardk> cofunctor = functor
17:22:16 <benzrf> edwardk: how so
17:22:24 <Iceland_jack> benzrf: you're just flipping the arrows
17:22:28 <tulcod> hpc: what's changed, roughly/
17:22:28 <benzrf> oh i see
17:22:30 <akater> Iceland_jack: I was wondering what c-- was. )
17:22:32 <edwardk> fmap takes arrows to arrows: (a -> b) |-> (f a -> f b) -- turn them around
17:22:35 <Zekka> Yeah, when I flip the arrows in fmap I get a different version of fmap
17:22:47 <hpc> C-- is no longer a pass
17:22:50 <benzrf> wrong arrows in my brain
17:22:53 <edwardk> (a <- b) |-> (f a <- f b)   now flip visually
17:23:00 <benzrf> o.O
17:23:04 <edwardk> (b -> a) |-> (f a -> f b)
17:23:07 <edwardk> now alpha rename
17:23:10 <benzrf> :p
17:23:15 <edwardk> (a -> b) |-> (f a -> f b)
17:23:22 <Zekka> Do you mean (f b -> f a) on the right hand side?
17:23:26 <benzrf> Zekka: he does
17:23:27 <edwardk> yeah
17:23:34 * edwardk is sloppy ;)
17:24:01 <edwardk> anyways when someone says 'cofunctor' they clearly haven't thought it through
17:24:10 <edwardk> there is a notion of a contravariant functor
17:24:32 <Zekka> A contravariant functor is one that gives you (a -> b) -> (f b -> f a), correct?
17:24:36 <edwardk> but (a -> b) -> f b -> f a   is very different than flipping all the arrows around
17:24:37 <edwardk> yeah
17:24:53 <edwardk> that is more of a 'twist'
17:25:08 <ddere> cofunctor is the same thing as a functor
17:25:39 <levi> That's what edwardk just established.
17:25:42 <edwardk> exactly
17:25:48 <ddere> someone probably already pointed that out but i didnt read the full discussion
17:25:57 <ddere> and again im still behind the curve
17:26:00 <Zekka> The discussion was of why cofunctor is the same thing as functor
17:26:02 <benzrf> categorically the morphisms go the other way about
17:26:06 <bergmark> cofunctor sounds cooler tho
17:26:17 <edwardk> some folks use cofunctor to say contravariant functor, but they are bad and should feel bad ;)
17:26:45 <benzrf> @let class Cofunctor f where cofmap :: (b -> a) -> (f b -> f a)
17:26:47 <lambdabot>  Defined.
17:26:47 <benzrf> it's different!
17:27:00 <edwardk> benzrf: =P
17:27:09 <akater> Zekka: formalising architecture is extremely interesting and rather ambitious but for now I'm more interested in merely writing useful, fast and non-greedy programs in Haskell. )
17:27:18 <edwardk> @let instance Functor f => Cofunctor f where cofmap = fmap
17:27:19 <lambdabot>  Defined.
17:27:27 <benzrf> yoooooo i was about to do that with a newtype
17:27:32 <benzrf> FreeCofunctor
17:27:54 <benzrf> edwardk: you got the a's and the b's mixed up eh
17:28:02 <Zekka> Let's see, one good contravariant functor would be newtype FirstArg b a = FirstArg (a -> b), yes?
17:28:04 <levi> akater: The ARM architecture is pretty well-specified, if you want to look at CPU specifications.
17:28:31 <Zekka> I don't have a really great intuition for them
17:28:38 <edwardk> Zekka: yes
17:28:56 <tulcod> levi: MIPS
17:29:01 <Zekka> contrafmap = flip (.)?
17:29:18 <Zekka> er, we're under a newtype so we can't quite do that
17:29:24 <edwardk> Zekka: data Predicate a = Predicate (a -> Bool); data Comparison a = Comparison { runComparison :: a -> a -> Ordering }; etc.
17:29:27 <levi> Well, MIPS is well-specified but not as widely used these days.
17:29:37 <edwardk> @hackage contravariant
17:29:38 <lambdabot> http://hackage.haskell.org/package/contravariant
17:29:43 <Zekka> edwardk: Oh, yeah, I can see it when the b is concrete
17:29:43 <benzrf> @let FreeContra f b a = FreeContra {unFreeContra :: f a b}
17:29:43 <lambdabot>  Parse failed: NamedFieldPuns is not enabled
17:29:44 <akater> Thank you all! I didn't really want this flame talk to happen.
17:29:47 <edwardk> Zekka: ^- look there for several of them
17:29:52 <benzrf> heuh?
17:29:58 <edwardk> Zekka: the one you made is called 'Op' in that package
17:29:58 <tulcod> levi: no, but it's more of an academic CPU arch because it's even simpler and even less useful than ARM
17:30:15 <tulcod> levi: like, ARM is not quite as simple as MIPS
17:30:26 <levi> Yeah.
17:30:32 <benzrf> @let FreeContra f b a = FreeContra (f a b)
17:30:34 <lambdabot>  .L.hs:153:1: Not in scope: data constructor ‘FreeContra’
17:30:34 <lambdabot>  
17:30:34 <lambdabot>  .L.hs:153:20: Not in scope: data constructor ‘FreeContra’
17:30:34 <lambdabot>  
17:30:34 <lambdabot>  .L.hs:153:32:
17:30:41 <benzrf> oh shit im a idiot
17:30:46 <tulcod> many proof of concept CPU design related stuff is done in MIPS
17:30:46 <benzrf> @let newtype FreeContra f b a = FreeContra {unFreeContra :: f a b}
17:30:48 <lambdabot>  Defined.
17:31:12 <benzrf> oh wait
17:31:28 <benzrf> thats just for Profunctors
17:31:40 <Zekka> benzrf: Trying to define a 'free contravariant functor' newtype for a covariant functor?
17:31:49 <benzrf> Zekka: no im not an idiot :P
17:31:59 <simon> what language feature or library in Haskell will do something like F#'s Type Providers?
17:32:11 <Zekka> er, you're right, profunctor if I'm not mistaken
17:32:35 <benzrf> @let instance Profunctor p => Contravariant (FreeContra p b) where contramap f (FreeContra p) = FreeContra (lmap f p)
17:32:37 <lambdabot>  Defined.
17:32:40 <benzrf> NeatBasis:
17:32:42 <benzrf> *neat
17:33:01 <Zekka> And I suspect you  could do the same with rmap for covariant?
17:33:09 <benbangert> so if I wanted to do an HMAC with SHA256.... what packages/arrangement should I be lookin for?
17:33:11 <simon> they seem like a combination of the Readable typeclass and attoparsec. but I'm not sure.
17:33:14 <benzrf> Zekka: well, Profunctor is already a superclass of Functor innit
17:33:21 <benzrf> @src Profunctor
17:33:22 <lambdabot> Source not found.
17:33:25 <benzrf> lame!
17:33:29 <Zekka> benzrf: They ought to be, I think
17:33:46 <Zekka> same reason that Bifunctor is a superclass of Functor
17:33:48 <c_wraith> simon: there's nothing really like Type Providers, from my quick read of the functionality - I might be wrong, though.
17:34:08 <c_wraith> simon: you seem to be suggesting they're really just parsers for a data format?
17:34:15 <simon> c_wraith, I can't determine exactly how typesafe they are and how much they're just smart parsers.
17:34:24 <Zekka> @let instance Profunctor p => Contravariant p where contramap f p = lmap f p
17:34:25 <lambdabot>  .L.hs:159:42:
17:34:25 <lambdabot>      Expecting one more argument to ‘p’
17:34:25 <lambdabot>      The first argument of ‘Contravariant’ should have kind ‘* -> *’,
17:34:25 <lambdabot>        but ‘p’ has kind ‘* -> * -> *’
17:34:25 <lambdabot>      In the instance declaration for ‘Contravariant p’
17:34:41 <Zekka> oh, hold up
17:34:42 <c_wraith> simon: well, I'm far from an expert - but if they're creating new types at runtime, haskell has nothing like that.
17:34:46 <Zekka> I haven't accounted for the other argument
17:34:55 <benzrf> Zekka: you need to flip them
17:34:56 <benzrf> hence the newtypw
17:34:56 <Zekka> right, that's why the newtype was necessary
17:34:58 <benzrf> *newtype
17:35:02 <c_wraith> simon: far from an F# expert, that is.  I'm only moderate distance from haskell expert. :)
17:35:19 <benbangert> cryptohash seems to be the 'best' option for HMAC with the SHA funcs I'm lookin for. am I missing anything else?
17:35:22 <Zekka> benzrf: Yeah, for a moment I thought 'wait, what's the purpose of the newtype?' and decided to see if I could define it without
17:35:57 <benzrf> Zekka: i had a brain fart and when i was writing the newtype i was thinking of bifunctors and not profunctors
17:36:02 <benzrf> hence the f instead of the p
17:36:31 <Enigmagic> benbangert: that's what i'd use
17:37:05 <c_wraith> simon: since F# integrates with the .net environment, I know it is in fact capable of creating new types at runtime.
17:37:14 <simon> c_wraith, having read http://stackoverflow.com/questions/4711537/f-type-providers-how-do-they-work , it seems that they're also some part template programming.
17:38:24 <c_wraith> simon: it looks to me like it's something like a framework for writing handlers for IDL-like stuff.
17:38:41 <simon> c_wraith, IDL?
17:38:48 <c_wraith> simon: interface description language
17:38:50 <Enigmagic> c_wraith: seems like it could be done with template haskell, no?
17:39:08 <c_wraith> Enigmagic: at compile-time, yes.  My interpretation of type providers is that they can work at runtime.
17:39:17 <enthropy> template haskell is just one stage
17:39:23 <simon> Enigmagic, it depends on whether a type provider can be specified at runtime.
17:40:01 <Enigmagic> for what? dynamic invoke?
17:40:04 <simon> Enigmagic, I don't know if that's possible, though. if not, it seems very much like template haskell.
17:41:12 <c_wraith> simon: an IDL is a formalized method for defining a wire format for data.  the IDL is use used to create data types to represent that data in an appropriate form in various languages, by preprocessors.
17:41:48 <c_wraith> simon: type providers appear to be supporting that use case with a pluggable interface for handling many definition formats
17:41:58 <simon> c_wraith, hm.
17:42:11 <simon> I have to read the original paper. these MSDN pages confuse me.
17:43:55 <c_wraith> simon: this is all conjecture on my part as far as their purpose.  It *seems* right, but I could be incredibly wrong. :)
17:44:15 <c_wraith> (seems right is a very dangerous trap, isn't it?)
17:44:17 <simon> c_wraith, right.. thanks. :)
17:44:24 <Letchik> http://www.haskell.org/tutorial/arrays.html
17:44:44 <Letchik> In the line index       :: (a,a) a -> Int is it a typo?
17:44:54 <c_wraith> Letchik: yes
17:44:57 <c_wraith> it's missing a ->
17:45:09 <Cale> :t index
17:45:11 <lambdabot> Ix a => (a, a) -> a -> Int
17:45:13 <levi> I rarely am able to get much of use out of MSDN pages. :/
17:45:41 <simon> levi, I think the authors might be too detached from the readers.
17:45:52 <Cale> Kind of amazing that there are still typoes in the Gentle Intro
17:46:00 <Cale> That thing is over a decade old
17:46:05 <c_wraith> is that page part of the Gentle Intro?
17:46:13 <c_wraith> oh, yes it is
17:48:33 <levi> This seems to explain what type providers *are* a bit more clearly: http://www.developerfusion.com/article/145919/an-introduction-to-f-type-providers/
17:49:53 <levi> It seems from the description there that you could do that sort of thing with Template Haskell.
17:53:07 <c_wraith> hmm.  that description does seem to imply they're mostly intended to be used statically rather than dynamically
17:53:39 <benbangert> so, relatively recently, the bytestring package on hackage went wacko
17:53:52 <benbangert> if you go to http://hackage.haskell.org/package/binary-0.7.2.1/docs/Data-Binary.html, and click 'ByteString' anywhere, hackage says its not found
17:54:03 <benbangert> that worked within the last week (I recall doing clicking it)
17:54:21 <c_wraith> benbangert: Sounds like an OPTIONS_HADDOCK pragma got removed, or haddock is ignoring it now
17:54:43 <benbangert> oh, well, now all of hackage is unavailable, so we'll see when its back
17:55:08 <c_wraith> benbangert: the .Internal modules should have an OPTIONS_HADDOCK pragma indicating they're not the home location for documentation of things defined in them
17:55:34 <c_wraith> benbangert: but what you're describing is that everything is attempting to link to the .Internal module location
17:55:41 <akater> Zekka: “I think what he's really wondering is why Haskell separates compiletime and runtime operations at all” — I understand what static typing is for: security, no bugs except hardware failure or access blocked by another agent… besides, this seems to be the only legitimate way to reason about programs. So no, the issue has a different origin.
17:56:05 <benbangert> c_wraith: ah, well, a *ton* of packages use ByteString that link to that, so breaking it is kind of horribly bad
17:56:40 <c_wraith> benbangert: yeah, it needs to be fixed.  I'm not sure what the underlying problem is.  But you should report it as an issue!
17:57:01 <benbangert> c_wraith: ah, where's the issue tracker for hackage?
17:57:16 <kazagistar> "this seems to be the only legitimate way to reason about programs" be careful of closing your mind...
17:57:22 <Zekka> akater: Yes, but I think you're still expecting operations like import which are hard to implement at runtime in a language with native code compilation, to have identical semantics to runtime operations
17:57:25 <c_wraith> I'm not even sure if it's a hackage issue or a bytestring issue
17:57:28 <c_wraith> It could be either
17:57:44 <c_wraith> (heck, it could be a haddock issue)
17:57:56 <c_wraith> I'd file it as an issue on bytestring, though
17:58:01 <benzrf> @hoogle [String] -> IO ExitCode
17:58:04 <lambdabot> System.Process rawSystem :: String -> [String] -> IO ExitCode
17:58:04 <lambdabot> System.Cmd rawSystem :: String -> [String] -> IO ExitCode
17:58:04 <lambdabot> System.Process system :: String -> IO ExitCode
17:58:06 <gamegoblin> c_wraith: I just joined — what’s the bytestring issue?
17:58:19 <benzrf> is System.Cmd part of base
17:58:26 <benzrf> is System.Process, for that matter?
17:58:52 <akater> Zekka: Yes, it's clear that having impure “import” in a program is a lot of trouble.
17:58:54 <c_wraith> gamegoblin: (apparently, since I haven't tested it myself) links to the ByteString type all point to nonexistant pages
17:59:18 <c_wraith> akater: it doesn't even need to be impure
17:59:30 <gamegoblin> c_wraith, huh, no issue for me going to http://hackage.haskell.org/package/bytestring-0.9.2.1/docs/Data-ByteString.html#t:ByteString
17:59:42 <Zekka> akater: Sorry ifI seem a little distracted by the way
17:59:48 <Zekka> explaining some code to a friend on another channel
17:59:51 <simon> benzrf, it seems not. http://hackage.haskell.org/package/base-4.2.0.1
17:59:57 <c_wraith> akater: even pure computations can't be statically analyzed.
18:00:00 <gamegoblin> Oh but wait, this does fail https://hackage.haskell.org/package/bytestring-0.10.0.2/docs/Data-ByteString.html#t:ByteString
18:00:01 <levi> Huh, looking at a discussion about Type Providers on LtU led me to this weird little language: http://journal.stuffwithstuff.com/2010/10/29/bootstrapping-a-type-system/
18:00:12 <gamegoblin> Clicking to it from the Parsec page yields a nonexistent page
18:00:37 <benbangert> c_wraith: k, filed the issue with the bytestring package
18:00:46 <simon> benzrf, they're part of "process" rather than "base". http://hackage.haskell.org/package/process-1.2.0.0
18:00:48 <gamegoblin> I think it’s a hackage problem
18:00:59 <gamegoblin> Or haddock or something
18:01:11 <c_wraith> benbangert: there might not be a possible fix other than "every other package needs to trigger a new documentation build"
18:01:31 <c_wraith> benbangert: which is an unfortunate flaw in the current state of hackage
18:01:57 <levi> akater: Types aren't just about bugs/errors/safety, though.
18:02:34 <benzrf> dang
18:02:37 <benbangert> c_wraith: at the very *least*, someone running hackage should insert a manual redirect if need be
18:03:12 <akater> Zekka: I think it would be wonderful, though probably hard to achieve. :-)
18:03:43 <benbangert> c_wraith: pardon my cynicism, but given the insanely smart ppl PhD's cooking up so many of these things, it seems just a wee silly that such trivial things like "links that work" would..... not work. ;)
18:03:48 <gamegoblin> c_wraith and benbagert: I think I found the issue. This one version of bytestring has no generated docs: http://hackage.haskell.org/package/bytestring-0.10.0.2 It’s not the newest version
18:04:09 <gamegoblin> All the other versions seem to have docs
18:04:23 <c_wraith> benbangert: unfortunately, PhDs don't help solve fiddly engineering problems. :)
18:04:30 <gamegoblin> But I think a lot of libraries (such as parsec) link to 0.10.0.2
18:04:38 <benbangert> c_wraith: lol, no kiddin
18:05:01 <levi> c_wraith: Well, they 'help' in a rather indirect way, hopefully.
18:05:11 <benbangert> gamegoblin: yea, I could've sworn I've clicked on these links in the past few weeks and they did work....
18:05:14 <gamegoblin> With the current state of hackage, can they go back and generate docs for that one version?
18:05:25 <c_wraith> I'm sure they can do it manually, at worst
18:06:00 <benbangert> gamegoblin: were all of these linked so specifically? http://hackage.haskell.org/package/uuid-1.3.3/docs/Data-UUID.html doesn't link to ByteString right
18:06:13 <benbangert> gamegoblin: the cryptohash links to ByteString are broke, etc.
18:06:32 <gamegoblin> benbagert: if you notice, they link to a specific version
18:06:39 * hackagebot vector-space 0.8.7 - Vector & affine spaces, linear maps, and derivatives  http://hackage.haskell.org/package/vector-space-0.8.7 (ConalElliott)
18:06:39 <gamegoblin> benbangert: the 0.10.0.2 version
18:06:44 <gamegoblin> which is the broken one
18:07:01 <akater> levi: What else then? Formalising human knowledge about the world in a computable manner?
18:07:03 <conal> hackage uploading now working again.
18:07:04 <gamegoblin> There are like 20 versions on hackage, and they all have docs except 0.10.0.2
18:07:37 <benbangert> gamegoblin: well, http://hackage.haskell.org/package/attoparsec-0.12.1.0/docs/Data-Attoparsec-ByteString.html
18:07:38 <gamegoblin> benbangert: but unfortunatelly a lot of high profile libraries link to 0.010.0.2 (presumably because it was released for a decent amount of time or something)
18:07:45 <benbangert> attoparsec was released within the past week
18:07:53 <benbangert> surely that guy knows how to link his docs? ;)
18:08:13 <levi> akater: Types can be used as tools for reasoning and specification, yeah.
18:08:32 <akater> Zekka: Fell free to get distracted, of course. IRC flow is obviously very chaotic.
18:08:36 <gamegoblin> benbangert: You can specify which version of a library you are using. If the .cabal file specifies 0.10.0.2 the docs generate it
18:08:57 <marchelzo_> how can I get the intersection of a bunch of lists
18:09:03 <marchelzo_> like [[a]] -> [a]
18:09:06 <benbangert> I'm still betting that those links *did* work until very recently
18:09:16 <akater> Zekka: However, if homoiconicty is not there because it's hard to achieve, so Haskell designers didn't think it's worth trying to, then it's a state of things that is completely different from “it's not needed / it's a wrong thing to do”. :-) Everything is needed if it makes people happier, even if those are Lisp users or OOP fans.
18:09:27 <benzrf> hmmmm
18:09:29 <Zekka> marchelzo_: Naively, foldr1 intersect
18:09:33 <Zekka> but there may be a better way
18:10:01 <marchelzo_> Zekka: ah, thanks. I should have thought of that. I think this will work in my case.
18:10:14 <Zekka> I didn't know if you meant "just any way" or "a really fast way"
18:10:23 <Zekka> intersect is in Data.List, by the way
18:10:24 <gamegoblin> benbangert: But I did just go look at the .cabal file of attoparsec and it just says “bytestring”, unless ghc < 7.4 then it’s bytestring < 0.10.4.0   This is some deep voodoo with hackage, haddock, and bytestring. I suspect there is some crazy mess.
18:10:28 <drangus> [swift]: around?
18:10:34 <gamegoblin> Either way, I have learned to really dislike haddock
18:12:06 <akater> Zekka: Anyway, “the designers didn't want to implement homoiconicity because it's hard and probably unnecessary” is a completely legitimate answer to the initial question, I'd be happy eith it. The only other option, I suspect, is “…because it's theoretically impossible”.
18:12:40 <Zekka> akater: Personally I think that the type system at least allows for something that behaves kind of like imports at runtime
18:12:56 <Zekka> Loading a function from an outside source should just be OutsideSource -> IO (a -> b) after all
18:12:56 <marchelzo_> Zekka: Would there be a difference in speed between foldl1 intersect and foldr1 intersect?
18:13:03 <bergmark> anyone know a good way to detect character encoding?
18:13:10 <hpc> bergmark: BOM
18:13:15 <Zekka> marchelzo_: I don't have a terribly strong intuition for how this case would behave with laziness
18:13:21 <Zekka> but foldr1 is lazier than foldl1
18:13:25 <hpc> if you don't have a BOM you're fucked and just have to guess
18:13:27 <drangus> [swift]: ping me when you get back
18:13:47 <bergmark> hpc: i think i have to assume i'm fucked :-(
18:14:04 <hpc> :(
18:14:15 <hpc> usually it's going to be ascii or utf-8
18:14:28 <Zekka> akater: The issue I think is that if what objects/types are available at compile time in the sense Haskell usually makes them available isn't known at the time you're executing code, then things get really weird
18:14:39 <hpc> what is the source of your data?
18:14:40 <bergmark> or whatever excel exports to csv in my case :_)
18:14:48 <[swift]> bergmark: web browsers use the algorithm described here: http://www.whatwg.org/specs/web-apps/current-work/multipage/parsing.html#determining-the-character-encoding
18:14:52 <Gurkenglas> @src intersect
18:14:52 <lambdabot> intersect = intersectBy (==)
18:14:59 <Zekka> A Haskell module is not a Haskell program that generates the compilable output, although TemplateHaskell brings you pretty close
18:15:00 <Gurkenglas> @src intersectBy
18:15:00 <lambdabot> intersectBy eq xs ys = [x | x <- xs, any (eq x) ys]
18:15:07 <Gurkenglas> That makes it easy
18:15:15 <hpc> bergmark: you can pick the encoding when you save, iirc
18:15:23 <Zekka> You can load code at runtime in such a way that doesn't step on the toes of the names Haskell's already resolved/instances Haskell's already aware of, etc.
18:15:39 <Zekka> but Haskell wants those things to be known as early as possible -- hence it wants to know what imports what as soon as it possibly can
18:15:39 <[swift]> bergmark: it sounds like you have something other than HTML, but the 'prescanning' algorithm they use is something you may be able to adapt to your use case
18:15:49 <bergmark> [swift]: thanks, i wonder if that's what http://hackage.haskell.org/package/charsetdetect does
18:16:05 <hpc> and assuming this is on the right half of microsoft's spotty unicode support pie chart, a BOM will be present if it's unicode
18:16:21 <bergmark> i don't think that one is very reliable though :D :(
18:16:26 <bergmark> λ> detectEncodingName "안녕ééäö"
18:16:26 <bergmark> Just "windows-1255"
18:17:21 <[swift]> bergmark: didn't look at the code, but quite possibly. the standard algorithm has baked in assumptions that it's looking at html, though, so you might need to substitute different assumptions
18:17:24 <tel> Is there an FRP Hello World? I'm experimenting with the different FRP libraries and would like to try something to get my feet wet in eah
18:17:44 <[swift]> bergmark: (it looks for character sequences it knows are very common in html documents, as expressed in different encodings)
18:18:11 <bergmark> hpc: if need be i'll have to tell users to pick the encoding themselves, but i'd like to figure this out for them if we can
18:18:20 <levi> akater: I think the design of the syntax was pretty strongly based on the ML tradition, which you can trace back to Peter Landin's ISWIM language. He doesn't seem to have been a fan of Lisp syntax.
18:19:29 <bergmark> [swift]: thanks!
18:19:30 <benzrf> i dont swim
18:19:35 <tel> Or, even better, is there any good comparison of the FRP libraries
18:19:49 <bergmark> i'll probably experiment a bit and see what kind of madness i can expect
18:19:49 <tel> I see netwire, elerea, reactive-banana, and sodium as potentially interesting
18:19:52 <akater> Zekka: Yes, that looks like the most plausible explanation. I like it much more than “why should it be there?”. :-)
18:20:06 <Zekka> I'm tempted to suggest that it's for the best that Haskell doesn't have Lisp-style syntax
18:20:11 <benzrf> [swift] why not [haskell]
18:21:01 <Zekka> because I think that representing the language as a typesafe data structure instead of nested instances of a single fundamental data structure could potentially be useful and interesting
18:21:08 <drangus> benzrf: hey, i've been using this nick for almost 20 years. i'm gonna claim priority over apple here =)
18:21:22 <Zekka> and I think that that's more possible in a language with syntax that's not self-similar than in a language with syntax that's highly self-similar
18:21:38 <Zekka> (even though TemplateHaskell isn't exactly typesafe and doesn't constrain you to things that represent valid Haskell programs at all)
18:21:59 <[swift]> benzrf: whoops, what drangus said. (that's a second account i have open to test znc push notifications. i'm getting confused here!)
18:22:35 <marchelzo_> is there a subsequences function that gives actual subsequences that appear in the original sequence?
18:22:45 <marchelzo_> rather than the subsequence from Data.List
18:22:55 <levi> tel: I haven't done much with FRP in Haskell. Is there something in particular you want to do with it?
18:23:00 <bergmark> haha, this is the first thing i read "Excel sucks handling CSVs. For instance, using Spanish locale, CSV is borked as it doesn't seem to think the C in CSV stands for comma- Spain uses the comma as the decimal separator and it seems to take precedence."
18:23:19 <tel> levi Partly just want to learn how to use it in practice. Color it more as curiosity for the moment
18:23:38 <tel> In time perhaps more
18:24:40 <levi> tel: Pick the one with the easiest-to-grok tutorial then. :)
18:26:38 <tel> levi I may go with that, but I was hoping there'd be a nice application that's self-contained, uses many FRP concepts, and takes just maybe an hour or two to implement
18:26:47 <tel> And then kick the tires on all of the libraries
18:26:49 <tel> using it
18:27:11 <benzrf> tel: banana has a nice slot machine implementation
18:27:53 <tel> benzrf Cool, I'll take a look
18:27:57 <tel> thanks
18:28:59 <akater> Zekka: You juxtapose “typesafe data structure” to “nested fundamental data structure”. I also suspect these contradict with each other. But nobody seems to know for sure, right? (I've made some Google search, and I'm yet to see a discussion of technical kind, and not of a kind we've had here earlier.)
18:29:43 <benzrf> akater: what?
18:29:54 <Zekka> benzrf: I think I was unclear
18:30:05 <benzrf> data BTree a = Leaf a | Branch (BTree a) (BTree a)
18:30:22 <Zekka> Basically, I think in a typesafe language it's good to have a syntax where the types in the AST prevent you from nesting incompatible nodes
18:30:46 <Zekka> When syntax is made out of a fundamental data structure like sexprs I think it's much harder to do this
18:31:15 <benzrf> oh i see
18:31:38 <nisstyre> Zekka: well, that's much harder when you want to do a lot of desugaring, because then you must have completely type-safe transformations
18:31:40 <akater> benzrf: I mean, discussions on homoiconicity and Haskell, seem to always be discussions about personal habits and not about abstract concepts.
18:31:48 <nisstyre> desugaring or resugaring actually
18:32:07 <bergmark> if haskell was sexprs it wouldn't have to parse into a syntax tree without more information, and it wouldn't have to parse all sexprs
18:32:16 <Cale> nisstyre: You probably want completely type safe transformations anyway
18:32:25 <Zekka> nisstyre: Why's that harder?
18:32:36 <Zekka> I'm confused by why you wouldn't want to have type-safe transformations
18:33:04 <nisstyre> Cale: probably but it's just a bit more tricky when you are also trying to do other things like bootstrap your compiler, or whatever
18:33:05 <Zekka> surely I *should* be able to convert any instance of do-notation into a valid monadic expression, right?
18:33:24 <qtplatypus> benzrf: WRT your BTree structure how do you do searches/other fuctions on such a type?
18:33:44 <Zekka> qtplatypus: Pattern matching, presumably? I'm not sure what you're asking
18:33:57 <nisstyre> Zekka: well yeah, okay, but that does require you to write the compiler in a type-safe language
18:34:00 <octopuscabbage> i have a nooby question. how would one go about getting a list of lines from standard input (i know the amount i want to get)
18:34:17 <octopuscabbage> additionally, how do i bind the result of a function to a name in a do block
18:34:18 <Zekka> nisstyre: Yeah, point in that case.
18:34:31 <hpc> :t \n -> forM [1..n] getLine
18:34:33 <lambdabot>     Couldn't match expected type ‘a -> m b’
18:34:33 <lambdabot>                 with actual type ‘IO String’
18:34:33 <lambdabot>     Relevant bindings include n :: a (bound at <interactive>:1:2)
18:34:38 <benzrf> hpc: no, replicateM
18:34:50 <hpc> :t forM
18:34:51 <lambdabot> Monad m => [a] -> (a -> m b) -> m [b]
18:34:51 <Zekka> Or const getLine!
18:34:53 <benzrf> octopuscabbage: use a regular let in a do block
18:34:57 <hpc> gah
18:35:00 <benzrf> octopuscabbage: except you dont need an in
18:35:02 <benzrf> for example
18:35:07 <Zekka> octopuscabbage: Is the function a -> m b or a -> b?
18:35:11 <octopuscabbage> ohhhh i see okay, that's for binding to a nname correct?
18:35:11 <hpc> i am sleepy
18:35:12 <benzrf> do {let a = 1; some; stuff;}
18:35:20 <nisstyre> Zekka: you might find this interesting https://www.cs.cmu.edu/~rwh/papers/closures/tr.pdf
18:35:21 <octopuscabbage> which function zekka?
18:35:23 <benzrf> octopuscabbage: for lines, do 'replicateM 10 getLine'
18:35:28 <benzrf> octopuscabbage: replicateM is from Control.Monad
18:35:33 <benzrf> :t replicateM
18:35:34 <lambdabot> Monad m => Int -> m a -> m [a]
18:35:39 <benzrf> @src replicateM
18:35:40 <lambdabot> replicateM n x = sequence (replicate n x)
18:35:42 <Zekka> octopuscabbage: The one whose return value you want to name
18:35:53 <Zekka> Because unboxing a monadic value in do notation uses <-
18:35:59 <octopuscabbage> a -> b (essentially)
18:36:05 <Zekka> just defining a name without unboxing uses let
18:36:08 <Zekka> Then you probably want let, yeah.
18:36:23 <akater> Zekka: Just in case you're interested: in Mathematica language, when AST has “incompatible structure”, then nothing happens. That is, no evaluation at all. It's not an error (!), it's the absence of *any* action by interpreter altoghether. I mention it just because it doesn't seem to be a well-known eval model.
18:36:24 <octopuscabbage> is that lazy or does it force it?
18:36:39 <Zekka> akater: That is kind of odd, really
18:36:48 <Zekka> not sure if I'm personally a fan of it, is there a good reason to do it that way?
18:37:09 <Zekka> I usually don't like languages that continue in the presence of invalid input instead of somehow erroring out
18:37:33 <akater> Zekka: But I can write analogue of “foldl f z [a b c]” and get the result without defining f, x, a, b, c.
18:37:34 <nisstyre> Zekka: sometimes you might want to report as many errors as possible
18:37:48 <octopuscabbage> can i have multiple let bindings in a single do block?
18:37:50 <nisstyre> Zekka: so that they don't have to re-rerun the compiler to learn about them
18:37:59 <akater> Zekka: IMO it helps when you study, immensely.
18:38:28 <Zekka> nisstyre: That's a valid point although I'll argue that by the time you've run into errors initially there's not very muchguarantee any further errors you find are accurate
18:38:57 <Zekka> see for instance the c compiler's "you missed a semicolon and now I will complain about literally every token in your entire program because I think they're all supposed to be on the previous line"
18:39:13 <akater> Zekka: It makes things like what this http://www.haskell.org/haskellwiki/Fold#Examples easier.
18:39:22 <nisstyre> Zekka: yeah, good error reporting is hard in parsers
18:39:26 <Zekka> akater: But why not use an undefined-analogue instead where your intent is explicit?
18:39:29 <akater> *cross out “what”
18:39:35 <nisstyre> some are unspeakably bad at it
18:39:37 <Zekka> I'm a little confused
18:39:49 <Zekka> What would foldl even return in that case?
18:40:32 <akater> Zekka: Why to? I want to see how Fold works. I write Fold[ f, x, {a,b,c}]. I get f[f[f[x, a], b], c]
18:41:03 <Zekka> akater: Printing an evaluation tree? That doesn't sound like "nothing happening".
18:41:12 <octopuscabbage> is the difference between . and $ that . is lazy?
18:41:22 <akater> Zekka: Well, Fold itself doesn't “Print”. :-)
18:41:25 <c_wraith> octopuscabbage: no, the difference is that they do different things
18:41:32 <c_wraith> octopuscabbage: they don't even have the same type
18:41:41 * hackagebot vampire 0.1.2.0 - Analyze and visualize expression trees.  http://hackage.haskell.org/package/vampire-0.1.2.0 (benzrf)
18:41:45 <benzrf> sweet
18:42:41 <Zekka> akater: Does it always print an evaluation tree?
18:42:41 <akater> Zekka: Actually, when I wanted to know how foldr works, I wrote an implementation in Mma to see it. I understand there are peculiarities about evluation order, so I can't see the difference between foldl and foldl' this way but still… it's quite neat.
18:43:41 <akater> Zekka: Well, if it works in the default environment it could draw a red dick instead of Disk[]
18:43:48 <akater> *disk
18:43:52 <akater> oops
18:43:59 <Zekka> Don't worry, I knew what you meant
18:44:36 <Zekka> By the way, you might be interested in benzrf's vampire package
18:44:57 <Zekka> it prints trees representing what Haskell has to do to evaluate an expression
18:45:14 <Welkin> an AST?
18:45:27 <Zekka> Welkin: It doesn't represent syntax
18:45:48 <Zekka> benzrf: Do you still have the example images you showed me? I think they're better than an explanation
18:46:22 <benzrf> Zekka: mmm 1 sec
18:46:27 <benzrf> i should make a new album actually
18:46:33 <benzrf> i added a new command line doohickey
18:46:35 <benzrf> 1 sec
18:46:42 <Lutin`> You should add documentation ;)
18:46:56 <akater> Zekka: I'll check it out!
18:47:42 <octophore> is GHC 7.6.3 known to have problems compiling Hoogle? (i.e. for cabal, i.e. so I can install lambdabot locally)
18:48:46 <benzrf> Lutin`: docu is for losers
18:49:01 <benzrf> Real Programmers can figure it out from the --help and the type signatures
18:49:02 <benzrf> >:D
18:49:34 <mirpa> benzrf: noooo....
18:50:24 <Welkin> real programmers code in binary using rocks on a desert plane
18:50:33 <Welkin> or plain
18:50:49 <dsturnbull> real programmers subcontract out to other programmers via amazon mechanical turk
18:51:03 <mirpa> ah... I have Emacs, there is mode for that
18:51:09 <dsturnbull> hahaha
18:52:49 <hpc> integer programmers code on turing tape
18:53:14 <Welkin> what about qubits?
18:53:43 <Gurkenglas> benzrf, --help for haskell functions? I usually tried to figure it out from the type
18:54:03 <levi> akater: I think there's something like that built into lambdabot.
18:54:06 <Gurkenglas> How do you find the --help?
18:54:13 <benzrf> Gurkenglas: vampire comes with a command line tool
18:54:19 <levi> Zekka, akater: Also, look at ghc-vis
18:54:22 <Gurkenglas> Never heard of vampire
18:54:27 <benzrf> it's my thingy
18:54:49 <benzrf> 1 sec p:
18:55:02 <levi> > foldr (+) 0 [1, 2, 3, 4]
18:55:03 <lambdabot>  10
18:55:11 <levi> Hmm.
18:55:40 <Gurkenglas> foldr ($) 0 [(*2),(+1),(*2),(+1)]
18:55:41 <octopuscabbage> is there a way to get an integer from std input
18:55:44 <Gurkenglas> > foldr ($) 0 [(*2),(+1),(*2),(+1)]
18:55:46 <lambdabot>  6
18:56:07 <Zekka> levi: This looks cool, thanks!
18:56:20 <benzrf> http://imgur.com/a/SazkC
18:56:24 <benzrf> Gurkenglas: ^
18:56:40 <Zekka> octopuscabbage: Why not use readLn :: IO Integer?
18:56:52 <Gurkenglas> Is it better than http://www.compileonline.com/compile_haskell_online.php ?
18:57:26 <Gurkenglas> (Which tends to derp out for too large computations sometimes, and sometimes needs a few extra clicks on the compilation button to do anything)
18:57:43 <Zekka> Gurkenglas: This doesn't seem to do anything in common with what vampire does
18:57:52 <Lutin`> benzrf: Why base<4.7 :[
18:58:09 <benzrf> its what i have installed i guess
18:58:13 <benzrf> i could change it
18:58:31 <benzrf> Lutin`: you could just clone the repo, edit the base req, and cabal install
18:58:37 <benzrf> cabal whines if you dont give a constraint on base
18:58:54 <Gurkenglas> Oh, I only saw the first image and couldn't draw much info from it ._.
18:58:54 <Lutin`> Yeah that's what I'm doing now
18:59:23 <levi> > foldr f x [1, 2, 3, 4, 5]
18:59:25 <lambdabot>  f 1 (f 2 (f 3 (f 4 (f 5 x))))
18:59:29 <levi> Ah, there we go.
18:59:44 <levi> > foldl f x [1, 2, 3, 4, 5]
18:59:46 <lambdabot>  f (f (f (f (f x 1) 2) 3) 4) 5
18:59:50 <dsturnbull> what does '>' do... expand your expression?
18:59:55 <akater> Oh, great.
18:59:59 <Welkin> it evaluates it
18:59:59 <benzrf> dsturnbull: evaluate it
19:00:00 <levi> It passes it to lambdabot for evaluation
19:00:07 <Gurkenglas> > 2+2
19:00:08 <benzrf> :t f
19:00:09 <lambdabot>  4
19:00:09 <lambdabot> FromExpr a => a
19:00:12 <akater> > foldl f x [a,b,c]
19:00:14 <lambdabot>  f (f (f x a) b) c
19:00:21 <Zekka> :t f
19:00:22 <lambdabot> FromExpr a => a
19:00:23 <benzrf> dsturnbull: f is some kind of magic that logs the applications
19:00:25 <dsturnbull> oh i see
19:00:27 <benzrf> i dont fucking know how it works
19:00:31 <benzrf> :t a
19:00:32 <lambdabot> Expr
19:00:34 <benzrf> wtf
19:00:38 <benzrf> what's this shit
19:00:38 <Gurkenglas> :t g
19:00:39 <lambdabot> FromExpr a => a
19:00:40 <benzrf> i dont know
19:00:41 <dsturnbull> :t p
19:00:42 <Gurkenglas> :t x
19:00:42 <lambdabot> Expr
19:00:43 <lambdabot> Expr
19:00:44 <dsturnbull> hahah
19:00:46 <Gurkenglas> o.o
19:00:53 <akater> Yes, that's what I'd love to see in the interface I'm setting up.
19:00:54 <Zekka> :t f x
19:00:55 <lambdabot> FromExpr t => t
19:00:59 <levi> http://twanvl.nl/blog/haskell/simple-reflection-of-expressions
19:01:00 <Gurkenglas> @hoogle FromExpr a => a
19:01:02 <lambdabot> Warning: Unknown class FromExpr
19:01:02 <lambdabot> Prelude undefined :: a
19:01:02 <lambdabot> Test.QuickCheck discard :: a
19:01:08 <benzrf> > a + b
19:01:08 <Welkin> > foldr1 (foldl1 g [1..5]) ['a'..'e']
19:01:10 <lambdabot>  a + b
19:01:10 <lambdabot>  can't find file: L.hs
19:01:22 <benzrf> @let f a b = a + b * b
19:01:23 <Welkin> er
19:01:24 <lambdabot>  Defined.
19:01:27 <benzrf> > f c d
19:01:29 <lambdabot>  Ambiguous occurrence ‘f’
19:01:29 <lambdabot>  It could refer to either ‘L.f’, defined at L.hs:163:1
19:01:29 <lambdabot>                        or ‘Debug.SimpleReflect.Vars.f’,
19:01:29 <lambdabot>                           imported from ‘Debug.SimpleReflect’ at L.hs:112:1-26
19:01:29 <lambdabot>                           (and originally defined in ‘simple-reflect-0.3.2:De...
19:01:36 <benzrf> > Debug.SimpleReflect.f c d
19:01:38 <lambdabot>  No instance for (GHC.Show.Show a0)
19:01:38 <lambdabot>    arising from a use of ‘M422286455148141056730863.show_M4222864551481410567...
19:01:38 <lambdabot>  The type variable ‘a0’ is ambiguous
19:01:38 <lambdabot>  Note: there are several potential instances:
19:01:39 <lambdabot>    instance [safe] GHC.Show.Show
19:01:45 <benzrf> oh
19:01:48 <benzrf> > L.f c d
19:01:50 <lambdabot>  c + d * d
19:01:55 <benzrf> nooooooo im obsolete
19:01:57 <levi> See the blog post I linked to for an explanation.
19:02:39 <dsturnbull> levi: that's really nifty.
19:02:42 <akater> levi: I will.
19:03:16 <Gurkenglas> > sum [0,0..]
19:03:21 <lambdabot>  mueval-core: Time limit exceeded
19:03:42 <Gurkenglas> > [0,0..] == [0,0..]
19:03:46 <lambdabot>  mueval-core: Time limit exceeded
19:03:49 <Welkin> benzrf, how do you generate the images?
19:04:15 <Gurkenglas> @let fib 0 = 1
19:04:18 <lambdabot>  Defined.
19:04:19 <Gurkenglas> @let fib 1 = 1
19:04:20 <lambdabot>  Defined.
19:04:23 <Welkin> > sum [1..]
19:04:27 <lambdabot>  mueval-core: Time limit exceeded
19:04:38 <Gurkenglas> @let fib n = fib (n-1) * fib (n-2)
19:04:39 <lambdabot>  Defined.
19:04:44 <Gurkenglas> >fib 10
19:05:09 <Gurkenglas> Did I break it?
19:05:13 <Gurkenglas> > fib 10
19:05:15 <lambdabot>  1
19:05:20 <Zekka> Gurkenglas: No, you missed a space
19:05:21 <benzrf> Welkin: graphviz
19:05:23 <Gurkenglas> @let fib n = fib (n-1) + fib (n-2)
19:05:24 <lambdabot>  .L.hs:164:1: Warning:
19:05:24 <lambdabot>      Pattern match(es) are overlapped
19:05:24 <lambdabot>      In an equation for ‘fib’: fib n = ...
19:05:24 <lambdabot>  
19:05:24 <lambdabot>  <no location info>:
19:05:32 <Gurkenglas> @unlet fib
19:05:32 <lambdabot>  Parse failed: TemplateHaskell is not enabled
19:05:40 <Gurkenglas> How did that go?
19:05:50 <Gurkenglas> > fib 308467834673
19:05:54 <lambdabot>  mueval-core: Time limit exceeded
19:05:59 <Gurkenglas> > fib 2000
19:06:01 <benzrf> Welkin: i copypasted some code from stackoverflow to convert my rose trees into fgl graphs, then i used the graphiz package to display those
19:06:03 <lambdabot>  mueval-core: Time limit exceeded
19:06:08 <Gurkenglas> > fib 100
19:06:12 <lambdabot>  mueval-core: Time limit exceeded
19:06:19 <Gurkenglas> > fib 40
19:06:19 <benzrf> inefficient fibs tsk
19:06:23 <lambdabot>  mueval-core: Time limit exceeded
19:06:23 <Lutin`> Gurkenglas: I think ur fibs is broke
19:06:36 <Gurkenglas> Doesn't matter I just want to see how deep it can recurse
19:06:50 <benzrf> pretty fuckin deep
19:06:59 <Welkin> until it runs out of memory
19:07:10 <levi> You can talk to lambdabot privately if you want to play with it.
19:07:19 <Gurkenglas> Also I hoped it would recognize by itself that it already computed that thunk
19:07:28 <Lutin`> @define fibs = fix (([1,1]++) . ap (zipWith (+)) tail)
19:07:30 <lambdabot>  Defined.
19:07:35 <Zekka> Gurkenglas: No, Haskell doesn't optimize that way by default
19:07:38 <Lutin`> > fibs !! 1000
19:07:40 <lambdabot>  7033036771142281582183525487718354977018126983635873274260490508715453711819...
19:08:01 <Welkin> > fibs !! 9999999999999999
19:08:05 <lambdabot>  mueval-core: Time limit exceeded
19:08:05 <Gurkenglas> @define fibbies = 1:zip (1:fibbies) fibbies
19:08:06 <Zekka> or rather GHC doesn't
19:08:07 <lambdabot>  .L.hs:159:24:
19:08:07 <lambdabot>      Occurs check: cannot construct the infinite type: a ~ (a, b)
19:08:07 <lambdabot>      Expected type: [a]
19:08:07 <lambdabot>        Actual type: [(a, b)]
19:08:07 <lambdabot>      Relevant bindings include
19:08:10 <Lutin`> > fibs !! 2000
19:08:12 <lambdabot>  6835702259575806647045396549170580107055408029365524565407553367798082454408...
19:08:18 <Lutin`> > fibs !! 5000
19:08:20 <lambdabot>  6276302800488957086035253108349684055478528702736457439025824448927937256811...
19:08:20 <Gurkenglas> @define fibbies = 1:zipWith (+) (1:fibbies) fibbies
19:08:22 <lambdabot>  Defined.
19:08:23 <Lutin`> damn sone
19:08:29 <Gurkenglas> >fibbies !! 5000
19:08:33 <Gurkenglas> Lets let them fight
19:08:36 <Gurkenglas> > fibbies !! 5000
19:08:38 <lambdabot>  1015527125487728271973716941667558936756065641738270254518642166382348739585...
19:08:45 <Gurkenglas> Wait what
19:08:51 <Zekka> Gurkenglas: I'm pretty sure your definition is incorrect
19:09:05 <Zekka> Actually, wait
19:09:07 <Gurkenglas> Oh right probs one of us is offset by 1
19:09:10 <Zekka> on second thought, no, it looks right
19:09:15 <Gurkenglas> > fibbies !! 4999
19:09:17 <lambdabot>  6276302800488957086035253108349684055478528702736457439025824448927937256811...
19:09:18 <Zekka> > take 20 fibbies
19:09:20 <lambdabot>  [1,2,3,5,8,13,21,34,55,89,144,233,377,610,987,1597,2584,4181,6765,10946]
19:09:28 <Zekka> You're offset by one, yeah
19:09:29 <Gurkenglas> Yea mine starts with 1 1
19:09:40 <Gurkenglas> Now have them fight out who goes further
19:10:03 <Gurkenglas> Private you say? Lemme see.
19:10:06 <Lutin`> @define phi = (1 + sqrt 5)/2
19:10:07 <lambdabot>  Defined.
19:10:58 <Lutin`> @define fibClosed n = (phi^n-(1-phi)^n)/(sqrt 5)
19:10:59 <lambdabot>  Defined.
19:11:06 <Lutin`> fibClosed 99999999
19:11:10 <Lutin`> > fibClosed 99999999
19:11:12 <lambdabot>  Infinity
19:11:14 <Lutin`> lol
19:11:24 <Lutin`> slight setback
19:11:25 <Gurkenglas> Mine goes up to like 140000
19:11:30 <Lutin`> > fibClosed 5000
19:11:32 <lambdabot>  Infinity
19:11:38 <Lutin`> @undefine fibClosed
19:11:38 <lambdabot> There's currently no way to undefine just one thing.  Say @undefine (with no extra words) to undefine everything.
19:11:45 <Lutin`> bollocks
19:11:49 <Gurkenglas> Use another identifier
19:11:53 <Lutin`> @undefine
19:11:54 <lambdabot> Undefined.
19:11:57 <Gurkenglas> refjzbhoztrhzuebhoebtzu
19:12:05 <Gurkenglas> @undefine Lutin'
19:12:05 <lambdabot> There's currently no way to undefine just one thing.  Say @undefine (with no extra words) to undefine everything.
19:12:42 <Gurkenglas> > (\n->(phi^n-(1-phi)^n)/(sqrt 5)) 1
19:12:43 <benzrf> :t fibClosed
19:12:44 <lambdabot>  Not in scope: ‘phi’
19:12:44 <lambdabot>  Perhaps you meant ‘pi’ (imported from Prelude)Not in scope: ‘phi’
19:12:44 <lambdabot>  Perhaps you meant ‘pi’ (imported from Prelude)
19:12:44 <lambdabot> Not in scope: ‘fibClosed’
19:13:01 <benzrf> oh
19:13:02 <Lutin`> benzrf: The issue is it's floating point
19:13:14 <Gurkenglas> > (\phi,n->(phi^n-(1-phi)^n)/(sqrt 5)) ((1 + sqrt 5)/2) 1
19:13:16 <lambdabot>  <hint>:1:6: parse error on input ‘,’
19:13:16 <Lutin`> I'd need an irrational type
19:13:22 <Lutin`> that uses an Integer backing
19:13:24 <Gurkenglas> > (\phi n->(phi^n-(1-phi)^n)/(sqrt 5)) ((1 + sqrt 5)/2) 1
19:13:26 <lambdabot>  1.0
19:13:56 <Gurkenglas> >sqrt 5
19:13:58 <Gurkenglas> > sqrt 5
19:14:00 <lambdabot>  2.23606797749979
19:14:08 <Gurkenglas> :t sqrt 5
19:14:10 <lambdabot> Floating a => a
19:14:17 <Lutin`>  > map ((\phi n->(phi^n-(1-phi)^n)/(sqrt 5)) ((1 + sqrt 5)/2)) [1..]
19:14:23 <Lutin`> oops
19:14:26 <Lutin`> > map ((\phi n->(phi^n-(1-phi)^n)/(sqrt 5)) ((1 + sqrt 5)/2)) [1..]
19:14:28 <lambdabot>  [1.0,1.0,2.0,3.0,5.0,8.0,13.0,21.0,34.0,54.99999999999999,89.0,143.999999999...
19:14:45 <hyPiRion> Can't you guys just look at http://www.haskell.org/haskellwiki/The_Fibonacci_sequence ? :p
19:15:05 <Gurkenglas> Well I actually just wanted to test whether it did that kind of optimiziation.
19:15:27 <Lutin`> It's the closed form version of the fibonacci sequence
19:15:40 <Lutin`> If you do it with a symbolic language it computes in near constant time
19:15:48 <octopuscabbage> a function that takes an IO string doesn't have to also produce an IO a correct?
19:16:40 <Lutin`> well
19:16:50 <Lutin`> You can't do anything with the IO String unless it does
19:17:42 <Gurkenglas> It's supposed to. IO about says "I have done something dirty to get this.", you shouldn't be able to use it without keeping telling it. That's at least how I understood that.
19:17:47 <enthropy> is somebody familiar with using -XNoMonoLocalBinds together with -XTypeFamilies? The ghc manual is pretty vague " type inference becomes less predicatable if you do so. (Read the papers!) "
19:18:02 <Lutin`> There is no safe function of type 'IO a -> a'
19:18:03 <dsturnbull> hoogle IO String -> String
19:18:12 <dsturnbull> how does hoogle work here?
19:18:18 <Lutin`> @hoogle a -> a
19:18:21 <lambdabot> Prelude id :: a -> a
19:18:21 <lambdabot> Data.Function id :: a -> a
19:18:21 <lambdabot> GHC.Exts breakpoint :: a -> a
19:18:27 <dsturnbull> @hoogle IO a -> a
19:18:27 <lambdabot> Foreign.Marshal unsafeLocalState :: IO a -> a
19:18:28 <lambdabot> System.IO.Unsafe unsafePerformIO :: IO a -> a
19:18:28 <lambdabot> Foreign unsafePerformIO :: IO a -> a
19:18:43 <Lutin`> ***BUT DO NOT USE THOSE UNLESS YOU ARE AN EXPERT PLZ***
19:18:52 <Gurkenglas> @src breakpoint
19:18:52 <lambdabot> Source not found. stty: unknown mode: doofus
19:19:05 <dsturnbull> generally you want to do it the other way. fmap can lift your function into the IO monad so you can use the IO String
19:19:08 <geekosaur> using those without knowing what you are doing WILL break your program
19:21:05 <Lutin`> You should only really use those if you're working with FFI
19:21:33 <gamegoblin> What’s an elegant way to delete the nth element from a list?
19:21:35 <mirpa> is there "modulo" (fmodf()) for Float/Double?
19:21:51 <nisstyre> gamegoblin: filter
19:21:58 <nisstyre> wait, sorry no
19:22:10 <nisstyre> I forgot the nth part
19:22:14 <gamegoblin> heh
19:22:25 <nisstyre> Data.List probably has something but that is in general not a great idea
19:22:31 <gamegoblin> tbh I’m surprised insert and delete into lists aren’t in prelude.
19:22:32 <nisstyre> since it's O(n) in time
19:22:34 <gamegoblin> They are very small lists
19:22:43 <gamegoblin> Data.List does not have it
19:23:02 <mirpa> Data.Fixed.mod' it is
19:23:05 <nisstyre> gamegoblin: the problem is that the list might not be big enough as well
19:23:28 <gamegoblin> nisstyre: I have to use a list regardless, because I can’t impose Ord or Eq constraints
19:23:30 <Lutin`> mirpa: That's fixed point not floating point
19:23:46 <mirpa> Lutin`: thank's
19:23:48 <Lutin`> mirpa: Oh wait
19:23:54 <Lutin`> Nevermind it works on Reals
19:24:09 <Gurkenglas> fromMaybe . zipWith ($) ((replicate (n-1) Just) ++ [Nothing] ++ repeat Just)
19:24:12 <Gurkenglas> :t fromMaybe . zipWith ($) ((replicate (n-1) Just) ++ [Nothing] ++ repeat Just)
19:24:14 <lambdabot>     Couldn't match expected type ‘Int’ with actual type ‘Expr’
19:24:14 <lambdabot>     In the first argument of ‘(-)’, namely ‘n’
19:24:14 <lambdabot>     In the first argument of ‘replicate’, namely ‘(n - 1)’
19:24:17 <mirpa> Lutin`: seems fine
19:24:27 <Lutin`> mirpa: Yeah it works fine I just read the package name
19:24:28 <nisstyre> gamegoblin: maybe you should use a different data structure
19:24:40 <Gurkenglas> :t removenth n = fromMaybe . zipWith ($) ((replicate (n-1) Just) ++ [Nothing] ++ repeat Just)
19:24:41 <lambdabot> parse error on input ‘=’
19:24:45 <gamegoblin> nisstyre: Such as?
19:24:55 <Gurkenglas> :t \n -> fromMaybe . zipWith ($) ((replicate (n-1) Just) ++ [Nothing] ++ repeat Just)
19:24:56 <lambdabot>     Couldn't match expected type ‘b -> Maybe b’
19:24:56 <lambdabot>                 with actual type ‘Maybe a0’
19:24:56 <lambdabot>     In the expression: Nothing
19:25:07 <Gurkenglas> :t \n -> fromMaybe . zipWith ($) ((replicate (n-1) Just) ++ [const Nothing] ++ repeat Just)
19:25:09 <lambdabot> Int -> [b] -> Maybe [Maybe b] -> [Maybe b]
19:25:09 <dsturnbull> nisstyre: why should it be O(n)? you don't have to modify the list, you could defer doing anything until you iterate over it, in which case, just skip past the one you 'deleted'?
19:25:17 <gamegoblin> nisstyre: I need to delete arbitrary elements, but I cannot impose Eq or Ord constraints.
19:25:27 <nisstyre> dsturnbull: yeah true enough
19:25:28 <Lutin`> dsturnbull: Because it's a linked list
19:25:45 <Lutin`> But yeah I guess that would work too
19:25:57 <dsturnbull> if it's a linked list, you already have O(n)
19:26:57 <gamegoblin> So really though, ideas for an elegant delete nth index? All i’ve got so far is “let (a,b) = splitAt n xs in a ++ tail b”
19:27:00 <dsturnbull> i'd be surprised if ghc doesn't already do things like that
19:27:09 <gamegoblin> Which works, but I was wondering if anything is better in terms of clarity and speed
19:27:23 <dsturnbull> gamegoblin: do you know that it's slow?
19:27:39 <gamegoblin> dsturnbull: Speed isn’t *really* an issue — mainly clarity"
19:27:46 <Welkin> gamegoblin, do you play a lot of RPGs?
19:27:51 <dsturnbull> fundamentally, that code is a fairly small amount of pointer arithmetic
19:28:02 <gamegoblin> Welkin: Not really, why?
19:28:24 <Welkin> your name conjures images of medieval fantasy
19:28:33 <Welkin> and table top games
19:28:41 <gamegoblin> Welkin: Game Goblins is the name of a table top gaming shop in my home town
19:28:51 <Lutin`> You might as well just do
19:28:57 <dsturnbull> gamegoblin: write it as a function, then you can have slightly uglier code that implements the perfectly clear function signature
19:29:40 <Lutin`> @define dropAt n l = (take n l) ++ (drop (n+1) l)
19:29:41 <lambdabot>  Defined.
19:29:52 <Lutin`> dropAt 2 [1..]
19:29:54 <Lutin`> > dropAt 2 [1..]
19:29:57 <lambdabot>  [1,2,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29...
19:30:07 <gamegoblin> Welkin: So I guess my name is pretty related to that. I was just having trouble thinking of a username a year and change ago and went with it.
19:30:27 <gamegoblin> Welkin: I played D&D in high school
19:31:04 <Welkin> I never played D&D but wanted to
19:31:06 <Lutin`> dsturnbull: That should have the behavior you mentioned
19:31:31 <dsturnbull> Lutin`: yes i think you're right
19:31:39 <dsturnbull> haskell rules
19:31:52 <Gurkenglas> I've been trying to get to play it but the rounds I'm signing up for always end up cancelled just in time
19:33:41 <dsturnbull> i wasn't thinking lazily before
19:34:00 <dsturnbull> of course dropAt is O(0) because it's deferred until you do something with it anyway
19:34:41 <Lutin`> Eh
19:34:46 <Gurkenglas> ...that doesn't sound right. Don't you still have to do it later?
19:35:00 <Lutin`> technically still O(n) because it does add a slight cost based on the length of the list
19:35:15 <Lutin`> you do have to keep track of where in the list you are
19:35:26 <Lutin`> But it should be a very tiny constant
19:36:10 <Gurkenglas> Oh, but then it gets eaten up by other O(n)s, got it
19:37:35 <Welkin> any operation on a list will be O(n)
19:37:45 <Welkin> unless the list is represented as a tree
19:37:54 <Lutin`> prepending is O(1)
19:38:02 <Welkin> okay, true Lutin`
19:38:04 <Lutin`> a single element
19:38:40 <Gurkenglas> two elements too
19:39:52 <Gurkenglas> Eh, that one was too troll-like.
19:40:26 <octopuscabbage> is it considered poor form to something as follows  http://lpaste.net/105767
19:40:40 <Lutin`> That's like saying concatenating a list of size 1000 and size 1000 is constant time because I know the sizes
19:40:42 <Lutin`> lol
19:42:28 <Lutin`> O notation is about asymptotic behavior, not a specific case
19:42:34 <tgeeky> octopuscabbage: there's not enough information there to decide; but no, there is nothing wrong with it
19:42:47 <Welkin> octopuscabbage, what is String and [String]?
19:42:56 <Welkin> you can create type synonyms
19:43:32 <octopuscabbage> That was mainly my question. Given that I have defined a base type synonym, is it 'acceptable' to also define a name for a collection of that type
19:43:51 <octopuscabbage> or should i be more explicit with using [Worker
19:43:55 <octopuscabbage> [Worker]*
19:44:03 <octopuscabbage> This is mainly a code style question
19:44:42 <Gurkenglas> As far as I understood it you want an extra type if not all theoretically possible [Worker] lists should be a Workers
19:44:51 <Lutin`> octopuscabbage: Oh no that's fine
19:45:05 <Lutin`> type synonyms are ubiquitous in Haskell
19:45:21 <octopuscabbage> Thanks Lutin'
19:45:27 <octopuscabbage> I'm not sure I understand what you mean Gurkenglas
19:46:16 <akater> levi: Thank you for the link on reflection. That's one wonderful introductory example in my case!
19:46:42 <Gurkenglas> IntegerFrom1To10 = Int      (but I have no idea whether that intuition was gathered correctly. (It might also have been read somewhere... I simply queried my brain what type constructs are good for and that's what it said))
19:48:16 <levi> You can implement a queue with *two* lists and get amortized constant time enqueue and dequeue operations.
19:48:17 <monochrom> I don't like type synonyms. but if you're already making some, I'm sure you have good judgement in how far you go. it's a subjective and very private judgement.
19:49:11 <octopuscabbage> monochrom: i was mostly asking because i've never used some large library and thought there might be a specific length to go when defining types
19:49:36 <Gurkenglas> Yup, that was a first-semestre university exercise
19:50:37 <monochrom> and damn English. it's judgment.
19:51:00 <c_wraith> levi: don't you have to be a little careful with that in a persistent setting?
19:51:23 <c_wraith> levi: I seem to recall those details were the focus of the first section of Okasaki's thesis
19:52:44 <monochrom> yes, watch out for re-using the same value. but there is a solution using laziness.
19:53:12 <c_wraith> In particular, if you pop from a queue with an empty front several times in a row, the work in the reverse isn't shared.
19:53:27 <c_wraith> Okasaki outlined two different strategies for fixing that with laziness
19:54:57 <c_wraith> Which more or less worked out to "partially evaluate the next reverse in operations preceding it."
19:55:01 <c_wraith> But they're clever.
19:55:21 <levi> I implemented the one where you fuse the reverse and append operations into a 'rotation' operation and perform it lazily when the right-end becomes longer than the left-end.
19:55:46 <levi> Walking through it with ghc-vis is pretty interesting.
19:56:30 <c_wraith> oh.  That one's partially evaluating the reverse in operations after it.  That'd be the banker's queue, wouldn't it?
19:56:50 <octopuscabbage> if i do something like list !! n and n = 1 is that the first element in the list or is 0 the first element
19:56:59 <c_wraith> 0 is the first element
19:57:04 <octopuscabbage> ty
19:57:07 <c_wraith> But beware of !! in general
19:57:13 <levi> The rotation operation performs one step of the reverse accumulation every time you force the front of the queue by removing the first element; by the time you reach the end of what was the left-end list, the reverse is complete.
19:57:19 <c_wraith> It often is an indicator of very slow code.
19:58:02 <nisstyre> c_wraith: it can be useful if you have set up your list as the result of a search algorithm or something
19:58:12 <c_wraith> !! in a loop is *definitely* an indicator of slow code.
19:58:15 <nisstyre> and you know it's "infinite"
19:58:34 <nisstyre> or as an approximation of something
19:58:35 <c_wraith> nisstyre: I'm not saying it's useless.  Just that you'd better know what you're doing if you use it
19:58:42 <nisstyre> yeah true
19:58:52 <octopuscabbage> good thing i have no idea what i'm doing then
19:59:07 <c_wraith> octopuscabbage: lists are so-named because they're singly-linked lists.
19:59:21 <levi> Haskell has all sorts of nice data structures, so you don't have to confine yourself to lists.
19:59:23 <c_wraith> octopuscabbage: the !! operation has to traverse the whole list
19:59:30 <monochrom> "rotate when the right one is longer than the left one" is the one that ensures amortized O(1) time in the face of persistence.
19:59:32 <octopuscabbage> i understand that, the list is only of length 3 so i'm not particularly worried
19:59:33 <Zekka> Well, not the whole list
19:59:42 <c_wraith> it might be the whole list!
19:59:46 <Zekka> (!! n) unconses nodes
19:59:47 <nisstyre> octopuscabbage: if the list is always length 1 then use a tuple
20:00:03 <octopuscabbage> fine it's a tuple now
20:00:16 <c_wraith> octopuscabbage: in general, prefer traversing the list in a single pass to using !!
20:00:22 <monochrom> "at each operation, perform one step of reverse" is the one that gives you O(1) worst-case time, no amortization necessary
20:00:25 <Zekka> er, unconses n nodes*
20:01:12 <octopuscabbage> say i have a list of length 3 and i want to unpack them into 3 variables in a let clause how would i go about doing that, because that's what i'm doing
20:01:27 <octopuscabbage> (i know they're not really variables but it's the nomenclature i'm used to)
20:01:35 <Zekka> let [x, y, z] = list in ?
20:01:35 <nisstyre> octopuscabbage: let (a:b:c:[]) = xs in ...
20:01:45 <rwbarton> it's the nomenclature we use too
20:01:47 <octopuscabbage> ty
20:01:48 <nisstyre> or with the [a,b,c] notation
20:02:13 <octopuscabbage> really? let bindings are referred to as variables in haskell???
20:02:25 <nisstyre> octopuscabbage: they're bound variables
20:02:40 <nisstyre> octopuscabbage: forget the notion of "variable" in most imperative langs
20:03:09 <octopuscabbage> ah, i'm just saying that because i've only heard them referred to as bindings,
20:03:26 <rwbarton> well, the ... binding is a binding
20:03:27 <monochrom> octopuscabbage, "variable" in haskell is in the same sense as "variable" in logic, i.e., identifier and/or placeholder. that is it. not state.
20:03:31 <nisstyre> octopuscabbage: they are variables. Think of variables in Haskell as more like substitution
20:03:33 <rwbarton> the thing it bound is a variable
20:03:35 <hunt> hey guys im having a lot of trouble picking a web framework
20:03:41 <hunt> im currently set on using spock
20:03:45 <hunt> but i cant find any got documentation
20:03:51 <hunt> no "getting-started"
20:03:55 <Welkin> never heard of spock
20:03:57 <Welkin> sounds cool
20:04:06 <hunt> it replaced scotty-session
20:04:07 <nisstyre> bound variables are the ones you can find the value of using let/where/parameters and free ones are ones that can be (possibly) found by looking in the environment
20:04:08 <octopuscabbage> hunt: might i reccomend writing your own using mustache templating
20:04:08 <Welkin> check out scotty and yesod
20:04:14 <hunt> soo scotty is ruled out
20:04:24 <hunt> octopuscabbage: no time, im in a big rush
20:04:34 <hunt> Welkin: no sessions
20:04:41 <hunt> Welkin: the scotty session package is dead
20:04:45 <Zekka> hunt: I can't speak for Scotty, but Yesod has sessions
20:05:10 <hunt> Zekka: its incompatible with the modern libs i have installed on my computer, it doesnt work with the latest conduit etc.
20:05:15 <octopuscabbage> i understand the concept of bound variables mathemtically somewhat,  just thought they would only refer to variables bound at the call of a function, not in an internal clause
20:05:39 <nisstyre> octopuscabbage: in pure lambda calculus yes, a bound variable is just a parameter
20:05:40 <Zekka> Well, you can rewrite any let binding as a function call if that helps you think about it
20:05:47 <Lutin`> ^
20:05:52 <monochrom> I would really like to say "constant" instead of "variable". :)
20:05:53 <nisstyre> Haskell augments LC with things like let and where though
20:05:55 <nisstyre> and case
20:05:56 <hunt> gyus! anyone know about spock? or have suggestions that will actually install
20:06:07 <Zekka> let x = y in becomes (\x ->) y
20:06:27 <octopuscabbage> ah i see now zekka, that makese a lot of sense now
20:06:41 <octopuscabbage> so it's essentially just syntactic sugar for a small lambda function?
20:07:07 <qtplatypus> octopuscabbage: Yes
20:07:07 <copumpkin> Zekka: not always true
20:07:12 <hunt> guysssssss
20:07:13 <Zekka> I don't know how GHC compiles it but if that helps you think about it, it works the same way in every case Ican think of
20:07:18 <hunt> please
20:07:18 <Zekka> copumpkin: When isn't it true?
20:07:26 <monochrom> but if I say "identifier" then you can't possibly misunderstand me
20:07:38 <copumpkin> > let x = 5 in (x :: Int, x :: Double)
20:07:39 <octopuscabbage> hunt: i can't help LC questions are more interesting :P
20:07:39 <lambdabot>  (5,5.0)
20:07:44 <Zekka> hunt: I've only worked with yesod -- I can't really recommend anything else ingood conscience
20:07:51 <copumpkin> > (\x -> (x :: Int, x :: Double)) 5
20:07:51 <rwbarton> or if the let binds a pattern
20:07:52 <lambdabot>  Couldn't match expected type ‘GHC.Types.Double’
20:07:52 <lambdabot>              with actual type ‘GHC.Types.Int’
20:07:54 <Zekka> copumpkin: That's true
20:08:12 <rwbarton> > let (x,y) = undefined in 5
20:08:12 <octopuscabbage> hunt: if you're in a time crunch why are you using a language without a well defined web framework?
20:08:13 <lambdabot>  5
20:08:23 <copumpkin> tildes help there
20:08:26 <rwbarton> but that could be rewritten to a lazy pattern I suppose
20:08:32 <hunt> octopuscabbage: some of the stuff is already written in haskell, but not the serving of pages
20:08:43 <dolio> (\x -> e1) e2 becomes let x = e2 in e1
20:08:44 <Zekka> > (\(x, y) -> 5) undefined
20:08:46 <lambdabot>  *Exception: Prelude.undefined
20:08:47 <levi> monochrom: Well, I should have said that it delays one step of the reverse-accumulate for each removal from the queue.  I did do the lazy-amortized version.
20:08:55 <Zekka> rwbarton: Pattern match forces evaluation, correct?
20:09:11 <Zekka> or at least enough evaluation to see if it matches that pattern?
20:09:13 <geekosaur> unless it's irrefutable
20:09:22 <levi> Zekka: Yes, when the pattern match looks into the structure.
20:09:35 <nisstyre> Zekka: not exactly true though
20:09:49 <octopuscabbage> hunt: what kinds of stuff?
20:09:51 <Zekka> nisstyre: When isn't it true?
20:09:57 <nisstyre> Zekka: let is different because it creates fresh type variables for each instantiation
20:10:10 <nisstyre> let f' x = let g x = x in (g x, g "a")
20:10:15 <Lutin`> Also doesn't work with the definition of fix
20:10:19 <octopuscabbage> hunt: also why did you start a web project without knowing a way to even serve it?
20:10:23 <hunt> octopuscabbage: idk its possible to do a total re write but i committed myself to haskell already
20:10:24 <Zekka> Oh, I thought you meant in reference to "pattern match forces evaluation"
20:10:28 <hunt> octopuscabbage: i knew there were ways in haskell
20:10:32 <Zekka> Copumpkin already covered let behavior
20:10:35 <nisstyre> that is not the same as let f x = (\g -> (g x, g "a")) (\x -> x)
20:10:37 <hunt> octopuscabbage: this is a school project anyways quality isnt first priority
20:10:52 <nisstyre> Zekka: oh missed that
20:10:56 <hunt> octopuscabbage: i was more interested in learning about haskell then making another web software
20:11:06 <flebron> Tangentially related to Haskell but, I'm looking at Girard-Reynolds lambda calculus. Is this a correctly written typing rule? "\alpha, \Gamma |- t : \tau    =>   \Gamma |- (\Lambda \alpha.t) : \forall \alpha . \tau
20:11:12 <octopuscabbage> hunt: i still say your best bet is going to be grabbing mustache and grabbing some sort of http library and working with those
20:11:22 <octopuscabbage> hunt: because it sounds like you have business logic written already
20:11:49 <octopuscabbage> and it's going to take you a while to get that business logic to interface with any sort of web application
20:12:05 <nisstyre> Zekka: anyway, in Scheme you can desugar let to lambda, but Haskell's type system would make that less useful
20:12:56 <dolio> flebron: \alpha being on the left in the first rule is a little weird. But other than that, it's fine.
20:13:07 <dolio> First judgment, even.
20:13:29 <flebron> dolio: Would \alpha be implicitly something of the form "x : \sigma" for some x and \sigma?
20:13:33 <Lutin`> Haskell let is like Scheme letrec
20:13:54 <dolio> No, it's just a variable.
20:13:56 <levi> You can always ask ghc to spit out the Core it desugars things to.
20:14:27 <dolio> Girard-Reynolds doesn't have higher kinds, I think. So type variables don't need annotations.
20:14:27 <monochrom> I love "let". it's so lazy. :)
20:14:52 <Lutin`> Or read http://www.haskell.org/onlinereport/exps.html
20:15:02 <flebron> dolio: G-R does need terms to be annotated with the types of variables, IIRC.
20:15:06 <monochrom> dolio, does Girard-Reynolds refers to System F?
20:15:24 <dolio> monochrom: I think so.
20:15:34 <dolio> flebron: That's term variables being annotated with types.
20:15:40 <flebron> But nothing can |- something if it's not a judgment, can it? I mean, what else could \alpha be? You can't do much with \Gamma \cup {x}, x itself isn't a judgment.
20:15:41 <dolio> alpha is a type variable.
20:15:47 <Lutin`> And http://www.haskell.org/onlinereport/decls.html#function-bindings
20:16:17 <dolio> monochrom: It's specifcally a Church-style System F, though.
20:16:24 <dolio> Presumably.
20:16:26 <flebron> So what will the \Gamma that types an expression have in it, both things of the form "x : \sigma" and things of the form "\sigma"?
20:17:47 <octopuscabbage> does anyone have experience with haskell and arduino?
20:18:14 <dolio> flebron: It will have x : t, where x is a term variable and t is a type. And \alpha, where \alpha is a type variable.
20:18:31 <flebron> dolio: Can t be a type variable as well?
20:18:36 <Lutin`> octopuscabbage: Do you mean running Haskell on the Arduino?
20:18:45 <dolio> Type variables are types. But not all types are variables.
20:18:57 <octopuscabbage> Lutin' Yes.
20:19:27 <Lutin`> Yeah...can't do that yet
20:19:38 <dolio> flebron: The weird part of your rule is that when you write 'alpha , Gamma' usually stuff in Gamma is allowed to refer to alpha.
20:19:52 <dolio> And if it does, it's wrong to pull it into a quantifier.
20:19:57 <octopuscabbage> Lutin': Ah okay, that's understandable, just had one laying around and wanted to see if i could
20:20:12 <flebron> dolio: Which quantifier would that be?
20:20:22 <octopuscabbage> Lutin': and I'm writing a fairly large, semi functionally designed program for it so using haskell would be nice
20:20:30 <dolio> The Lambda and the forall.
20:20:43 <Lutin`> octopuscabbage: I mean there might be something that compiles a restricted version of Haskell to C that could run on it
20:20:47 <Lutin`> But GHC won't run on it
20:21:03 <levi> Or a Haskell-hosted DSL to C.
20:21:07 <Lutin`> There is a package that will let you remote control it
20:21:12 <Lutin`> levi: Yeah that too
20:21:24 <Lutin`> Aha
20:21:26 <Lutin`> http://hackage.haskell.org/package/atom
20:22:00 <Lutin`> This actually looks pretty sexy
20:22:00 <flebron> dolio: Oh, you mean \tau could refer to \alpha?
20:22:03 <dolio> α, x : α ⊢ x : α  ==> x : α ⊢ (Λα. x) : ∀α. α   <--- this is bad
20:22:12 <flebron> Precisely :)
20:22:56 <octopuscabbage> Lutin' seems interesting, i'll look into it. I recently saw a paper on haskell for robotics which is why I'm asking, and i think this is one of the libraries they used
20:23:43 <taktoa> fwiw I'm working on getting haskell to compile for the TI Stellaris Launchpad, a $13 80 MHz ARM dev board
20:23:53 <taktoa> going to use ajhc probably, or maybe atom
20:24:27 <levi> Those are two very different things.
20:24:35 <dolio> So usually the rule would be written:  Γ, α ⊢ e : τ  ==>  Γ ⊢ (Λα. e) : ∀ α. τ
20:24:35 <taktoa> yes
20:24:51 <taktoa> atom and ajhc are different ways of approaching the same problem
20:24:54 <octopuscabbage> also, is there an arm implementation of ghc?
20:25:05 <dolio> If α is all the way to the right, there's nothing you have to worry about referring to it.
20:25:06 <octopuscabbage> or a haskell compiler in general
20:25:12 <taktoa> no, but ajhc can generate C code that will compile on ARM
20:25:27 <taktoa> if performance suffers for the ajhc approach I would use atom
20:25:31 <levi> taktoa: I'd say they're different ways of approaching different problems, but I guess it depends on how you define the problem.
20:25:44 <dolio> And then you'd have rules about when you can rearrange your contexts or something.
20:25:58 <Rotaerk_Web> guys is there a more standard solution to what I invented !> for here:  http://lpaste.net/3151850407160971264
20:26:02 <taktoa> atom will definitely work, but ajhc is probably a more programmer-friendly system
20:26:07 <hunt> two things
20:26:07 <hunt> first
20:26:27 <hunt> spock and spock-worker are incompatible. you cant cabal install Spock and then cabal install Spock-Worker
20:26:28 <hunt> second
20:26:39 <hunt> i installed Spock, but Web.Spock cant be found by ghci
20:26:42 <hunt> thats the important problem
20:26:53 <hunt> please help!
20:26:59 <Zekka> hunt: Have you tried the installation process in a sandbox?
20:27:07 <flebron> dolio: So the reason for having it to the right is to make \Gamma not contain \alpha?
20:27:14 <dolio> Yes.
20:27:14 <hunt> Zekka: this is in a sandbox
20:27:28 <Zekka> Next, are you sure the version of Spock you're using provides Web.Spock?
20:27:42 <Zekka> hunt: Did you cabal install spock; cabal install spock-worker, or did you cabal install spock spock-worker?
20:27:53 <Zekka> The latter will try to pick a mutually compatible suite of packages
20:28:02 <dolio> flebron: If you were doing System Fω, you'd need to annotate type variables with their kinds.
20:28:06 <hunt> Zekka: ah i did them separately
20:28:08 <dolio> So the rule would look like:
20:28:18 <hunt> Zekka: i dont actually need spock-worker i just thought that was lame that they were incompatibel
20:28:32 <Lutin`> hunt: The author just updated Spock to version 0.6
20:28:37 <Lutin`> spock-worker has not yet been updated
20:28:49 <hunt> Lutin`: ah understood. Why is Web.Spock invisible  though?
20:29:02 <hunt> It really is giving me issues that ghci/ghc cant find Web.Spock
20:29:08 <dolio> Γ, α : κ ⊢ e : τ  ==> Γ ⊢ (Λ(α : κ). e) : ∀(α : κ). τ
20:29:32 <Zekka> Just looking now
20:29:37 <octopuscabbage> how does folding work on an odd length list?
20:29:39 <dolio> Where κ stands in for a kind.
20:29:39 <Zekka> That's weird
20:29:54 <octopuscabbage> oh duh nvm
20:29:59 <octopuscabbage> i forgot how fold works momentarily
20:30:03 <Lutin`> hunt: Please document all your steps and the exact errors you are getting
20:30:13 <dolio> In System F, the only kind is *, so it's usually omitted.
20:30:41 <flebron> dolio: Ah, makes sense :) And \alpha is still required to not be in \Gamma there, correct?
20:30:47 <Zekka> Are you trying to compile a program that uses it or something?
20:30:48 <zomg> I wonder if Ferry Corsten is secretly a mathematician
20:30:56 <Zekka> Because if that program's in a cabal project you need to put spock in the dependencies
20:31:00 <hunt> Lutin`: my friends getting these errors or something
20:31:01 <dolio> flebron: Yeah.
20:31:09 <Zekka> Maybe they didn't configure it right
20:31:25 <hunt> Basically: cabal sandbox init; cabal install Spock; ghci; :m Web.Spock; Couldnt be found anywhere searched exhaustively yada yada
20:31:38 <hunt> Lutin`: ^
20:31:40 <hunt> Zekka: ^
20:31:41 <pavonia> Rotaerk_Web: Seems to be the simpliest way here
20:31:51 <hunt> Zekka: im trying to use it myself
20:31:58 <Rotaerk_Web> k, thanks
20:32:08 <Lutin`> jesus so many dependencies
20:32:09 <flebron> dolio: Thanks! :)
20:32:16 <dolio> No problem.
20:33:21 <Zekka> hunt: Let me check something
20:33:22 <hunt> Lutin`: yea i know it took me > 3 minutes to install
20:33:22 <hunt> Zekka: alright hurry back ;)
20:33:22 <Zekka> hunt: Try running cabal repl
20:33:35 <Zekka> er, wait, if you're not in a cabal project that won't work
20:33:37 <hunt> Zekka: yea that works though
20:33:42 <Zekka> Oh, it does work?
20:33:44 <hunt> how do i use ghc
20:33:59 <hunt> ghc doesnt see it  however
20:34:05 <Zekka> If you're in a cabal project? cabal build/sdist/etc.
20:34:14 <Zekka> ghc doesn't know about sandboxes, cabal has to tell it about it
20:34:19 <hunt> Zekka: also, it doesnt work in subdirectories
20:34:19 <Zekka> Er, to clarify, cabal *some verb*
20:34:33 <hunt> Zekka: this sucks gah
20:34:34 <Zekka> Actually, sdist doesn't invoke ghc anyway, don't know why I mentioned it
20:34:40 <Lutin`> hunt: If you're in a sandbox use `cabal repl`
20:34:42 <hunt> there should be a cabal ghc
20:34:50 <hunt> Lutin`: but what about subdirectories of the sandbox?
20:35:05 <Zekka> Lutin`: I think you also need a cabal project in the sandbox directory
20:35:18 <Lutin`> Zekka: Not for repl
20:35:22 <monochrom> cabal make me a sandwich? :)
20:35:29 <Zekka> Really? Cabal complains about that for me (1.18.0.3)
20:35:30 <Lutin`> Just tried ghci in sandbox it didn't find the module
20:35:35 <Lutin`> cabal repl worked
20:35:54 <hunt> any chances of getting a cabal ghc
20:35:56 <Lutin`> I'm on 1.20.0.2
20:36:10 <hunt> its way more convenient then having to set up a cabal file for my sandboxes
20:36:16 <Zekka> Oh, on 1.20 it works fine
20:36:21 <Lutin`> hunt: ghc -no-user-package-db -package-db .cabal-sandbox/*-packages.conf.d
20:36:40 <Lutin`> See http://dev.stephendiehl.com/hask/
20:37:10 <hunt> ok
20:37:22 <hunt> ill just set up the cabal rile
20:37:22 <Zekka> Lutin`: Isn't it usually wrong to invoke ghc manually on a cabal project, though?
20:37:22 <levi> Assuming you have a sandbox set up, you can do 'cabal sandbox exec sh' and get a shell where the environment is set up to use the sandbox by default.
20:37:24 <hunt> thats a mouthful
20:37:38 <monochrom> if cabal doesn't need a cabal file, then it is not cabal. :)
20:38:05 <path[l]> @pl merge s1 (s2, g) = (s1:s2, g)
20:38:05 <lambdabot> merge = (`ap` snd) . (. fst) . ((,) .) . (:)
20:38:41 <Zekka> :t first (s1:)
20:38:41 <Lutin`> Zekka: Yeah I mean if you're just toying around it's not the worst thing in the world
20:38:42 <lambdabot>     Not in scope: ‘s1’
20:38:42 <lambdabot>     Perhaps you meant one of these:
20:38:42 <lambdabot>       ‘s’ (imported from Debug.SimpleReflect),
20:38:47 <qrada> hey, having a quickcheck dependency hell problem in my cabal sandbox.. anyone know what to do here: One of my dependencies is QuickCheck ==2.7.* etc.. When I cabal install, I get: rejecting ... (global constraint requires ==0.1.0.0) .. If i try that version, it won't build either
20:38:47 <Zekka> :t \s1 -> first (s1:)
20:38:48 <lambdabot> a -> ([a], d) -> ([a], d)
20:39:06 <Zekka> path[l]: Might be best to start by trying to simplify that
20:39:12 <Zekka> @pl \s1 -> first (s1:)
20:39:12 <lambdabot> first . (:)
20:39:17 <Zekka> (if you *really* want the point-free)
20:39:50 <path[l]> Zekka: I dont understand what you’re saying, but I’m listening.
20:40:06 <Lutin`> :t first
20:40:07 <lambdabot> Arrow a => a b c -> a (b, d) (c, d)
20:40:10 <path[l]> :t first
20:40:11 <lambdabot> Arrow a => a b c -> a (b, d) (c, d)
20:40:12 <Zekka> path[l]: What Lambdabot just spit out should be equivalent to what youwere trying to write
20:40:12 <path[l]> ah
20:40:18 <Lutin`> good ol arrows :)
20:40:33 <Zekka> first turns an Arrow (think 'function') from a to b into an arrow from (a, c) -> (b, c)
20:40:40 <path[l]> ah
20:40:59 <path[l]> the type signature is not very clear to me though
20:41:07 <Lutin`> path[l]: Replace a with (->)
20:41:13 <monochrom> it's very general type
20:41:16 <Zekka> a is usually (->)
20:41:38 <monochrom> (b -> c) -> (b,d) -> (c,d) is the special case you're using
20:41:40 <Zekka> The type's just general that way so that it can work with i.e. monadic functions
20:41:41 <mzero> qrada: can you put the output from cabal install --verbose=2 into lpaste?
20:41:43 <path[l]> ok, I understand. And it’s in some sort of prefix notation
20:41:48 <Zekka> Yeah.
20:41:56 <Zekka> It's in prefix notation just like you normally use with types
20:42:02 <Zekka> (->) is a type-level operator so you can write it in infix
20:42:11 <path[l]> ah cool
20:42:11 <Zekka> Arrow a => a b c -> a (b, d) (c, d)
20:42:13 * hackagebot uri-templater 0.1.0.0 - Parsing & Quasiquoting for RFC 6570 URI Templates  http://hackage.haskell.org/package/uri-templater-0.1.0.0 (IanDuncan)
20:42:20 <octopuscabbage> why is [[String].[String],String] an illegal type?
20:42:21 <qrada> mzero: sure 1sec
20:42:22 <Zekka> ((->) b c) -> ((->) (b, d) (c, d))
20:42:32 <mzero> Heh - it Arrow is a very general type... that nobody ever uses with anything other than (->)
20:42:33 <Zekka> (b -> c) -> ((b, d) -> (c, d))
20:42:34 <path[l]> thanks, now it makes more sense :)
20:42:36 <Lutin`> @src (->) Arrow
20:42:37 <lambdabot> Source not found. Whoa.
20:42:40 <Lutin`> @src -> Arrow
20:42:41 <lambdabot> Source not found. I don't think I can be your friend on Facebook anymore.
20:42:44 <Zekka> mzero: Pretty much
20:42:48 <Lutin`> Aww no Arrow source
20:42:53 <Zekka> Even though in theory it might be useful with Monads at least
20:42:57 <monochrom> what would [[String],[String],String] mean?
20:42:58 <mzero> octopuscabbage:  what is that period doing in there?
20:43:06 <Zekka> (I've never actually seen anyone use it with Kleisli, probably because the newtype wrapper's a little bulky)
20:43:13 <Zekka> monochrom: It looks like a garbled list of tuples to me
20:43:16 <mzero> and the outer brackets... did you mean parens
20:43:22 <Lutin`> octopuscabbage: Lists are homogenous
20:43:28 <Lutin`> meaning all elements have the same type
20:43:31 <mzero> did you mean   ([String], [String], String)
20:43:33 <octopuscabbage> Oh shit, you're right
20:43:48 <octopuscabbage> Wait can tuples be non-homogenus?
20:43:52 <Lutin`> Yes
20:43:53 <Zekka> Lutin`: Although you can cheat it using Data/ExistentialQuantification!
20:43:53 <mzero> YES!
20:43:58 <Zekka> er, data*
20:44:03 <Lutin`> Zekka: Shhh
20:44:16 <mzero> > ("Hello", 42)
20:44:17 <lambdabot>  ("Hello",42)
20:44:30 <jle`> mzero: i like other arrows :'(
20:44:30 <mzero> @type ("Hello", 42)
20:44:31 <lambdabot> Num t => ([Char], t)
20:44:33 <jle`> so much h8
20:44:42 <monochrom> use existential type still gets you homogeneous lists
20:44:59 <jle`> tuples give you arbitrary combinations of types
20:45:01 <Zekka> monochrom: Yeah, they're technically homogeneous but they accomplish what you *meant* to do with heterogeneous lists
20:45:02 <jle`> it's pretty neat
20:45:22 <Zekka> as in, if you say "what I need is a heterogeneous list, man!" you probably actually *want* a list of an existential type
20:45:46 <qrada> mzero: http://hastebin.com/ikatomurik.vhdl
20:45:56 <qrada> thanks for taking a look
20:46:21 <qrada> don't think i've ever dealt with this global constraint issue
20:47:20 <mzero> qrada: you are trying to build QuickCheck from source in a sandbox?
20:48:10 <qrada> is that a prob? I have most of my .cabal's like that.. itll build into the .cabal-sandbox and then I can import from my code in src/*.hs etc
20:48:29 <dwcook> What's an input that will give me a Left from http://hackage.haskell.org/package/text-1.1.1.3/docs/Data-Text-Encoding.html#v:decodeUtf8-39- ?
20:49:21 <octopuscabbage> does anyone have a good naming convention for cases when you have do so something like this: http://lpaste.net/105768 it's for cases when you write an extra internal function just because you have to supply it some initial value
20:49:24 <mzero> well... er... then I'm a bit at a loss as to what is causing that... I mean QuickCheck should required QuickCheck!
20:49:25 <qrada> this is the first time i've run into an issue with a sandbox (if it's in fact an issue)
20:49:26 <Zekka> dwcook: Do you want me to cook up some invalid utf8 input real quick?
20:49:40 <dwcook> Zekka: Worth a shot.
20:49:43 <Zekka> or is this a deeper question?
20:49:55 <dwcook> No, I just want to give that function some input that will make it fail.
20:50:04 <dwcook> I want to ensure my handling does what it ought to.
20:50:22 <Zekka> dwcook: I don't know how to actually create a Bytestring offhand but try the byte 0b10101010
20:50:35 <Zekka> That's not an acceptable opening string for a UTF-8 character so it should die
20:50:46 <Zekka> (Character 170)
20:50:54 <qrada> mzero: dno.. i'm just trying to import Test.QuickCheck from an executable.. I imagine cabal install would build quickcheck library into .cabal-sandbox/* and I could import.. but something seems wrecked.. that global constraint ==0.1.0.0 i've never seen before
20:51:19 <monochrom> I'm looking at wikipedia's utf-8 article, it does seem 10101010 is invalid
20:51:26 <path[l]> I have another question if someone can help. I’m trying to do something with HSpec and QuickCheck to try out both approaches. When working with HSpec, one of my functions calls error in a specific case. In order to do this I wrote the code as follows ——> (evaluate.force) (parseGlob "[abc-\\]") `shouldThrow` (errorCall "could not parse set in glob”).
20:51:40 <dwcook> Though I might need to be more specific – I want netcat to send an invalid utf8 sequence to my network program.
20:51:40 <monochrom> (unless preceded by something specific)
20:51:53 <qrada> oh
20:51:55 <Zekka> dwcook: So have netcat send it?
20:52:02 <qrada> mzero, are you saying the directory i'm in, iscausing a conflict somehow
20:52:03 <dwcook> Yeah, I don't know how to generate an invalid input
20:52:07 <Zekka> (It looks like Haskell makes it unsurprisingly difficult to pull a ridiculous bytestring out of thin air)
20:52:14 * hackagebot yesod-core 1.2.17 - Creation of type-safe, RESTful web applications.  http://hackage.haskell.org/package/yesod-core-1.2.17 (MichaelSnoyman)
20:52:18 <qrada> im in a test dir of src/QuickCheck, that's just for me to code small quickcheck tests in it etc..
20:52:18 <monochrom> put it in a file (use a hex editor). tell netcat to send it.
20:52:24 <qrada> it's not the actual quickcheck
20:52:26 <qrada> hmm
20:52:27 <kyagrd> has anyone had problems using cabal-dev ghci reloading?
20:52:29 <Zekka> Can't you tell nethack to send bytes and then send 170?
20:52:31 <dwcook> monochrom: Good idea.
20:52:38 <Zekka> er, netcat*
20:52:40 <mzero> qrada: I guessing your project is "ToyBox" and I'm wondering why you have a separate sandbox for just QuickCheck below it?
20:52:45 <qrada> lmfao
20:52:58 <mzero> oh
20:52:59 <qrada> that's what is happening
20:53:08 <monochrom> because if netcat reads you from the terminal, the terminal already ensures valid utf-8 probably
20:53:17 <mzero> rather than use the existing sandbox up above?
20:53:39 <mzero> in ToyBox? why not just have multiple executable targets in your main cabal to have them for your tests
20:53:45 <solirc> path[l]: Hey!
20:53:45 <qrada> ya ToyBox is just a top level dir for me to mess around with tons of haskell libraries etc.. so i have multiple sandboxes within ToyBox, ie, ToyBox/src/Lens, ToyBox/src/Pipes etc..
20:53:46 <Lutin`> qrada: Yeah try not to name your cabal projects after existing projects lol
20:53:54 <mzero> but in anycase, I can't imagine where this global constraint is coming from
20:54:04 <mzero> AH
20:54:05 <solirc> path[l]: I saw your question the other day in #hspec, but you left before I could reply.
20:54:06 <path[l]> hi solirc
20:54:07 <mzero> got it
20:54:10 <path[l]> ooh cool
20:54:11 <Lutin`> mzero: Yeah lol
20:54:18 <qrada> ya i plan on having TONS of stuff tho so that .cabal would be huge
20:54:26 <qrada> awesome, this explains it.. i knew it would all circle back to me being a nub
20:54:30 <qrada> thanks folks
20:54:37 <mzero> now... hmmmm.... what is the cabal file for your tests look like?
20:54:40 <Lutin`> qrada: You could call them LibraryBox
20:54:52 <mzero> I'm wondering if you are getting bit by the QuickCheck 1 and QuickCheck 2 naming issues
20:54:52 <Lutin`> QuickcheckBox
20:54:58 <qrada> mzero: well i'm not tying in cabal's test suite for this
20:55:12 <qrada> nto for this specific project within the toybox
20:55:12 <mzero> right - but you do have a .cabal file for your tests, yes?
20:55:16 <mzero> hpaste it, please?
20:55:28 <Lutin`> qrada: Do you have a Quickcheck.cabal in your directory?
20:55:36 <mzero> oh? Then how are you building it?
20:55:39 <qrada> it's Install.cabal in there
20:55:41 <qrada> ya
20:55:46 <qrada> custom Install.Cabal
20:55:47 <Rotaerk_Web> is there a safe equivalent of readFile
20:55:50 <qrada> but.. the project name is QuickCheck
20:55:51 <qrada> in that cabal
20:55:55 <qrada> that's what is wrecking it
20:55:56 <mzero> AH
20:55:57 <Lutin`> Yeah don't do that
20:55:57 <qrada> :f
20:55:59 <qrada> :f
20:56:00 <mzero> you are confusing cabal
20:56:02 <qrada> ya
20:56:04 <Lutin`> :P
20:56:12 <Lutin`> The version 0.1.0.0 gave it away
20:56:24 <mzero> "My project is called QuickCheck... and it depends on a project called QuickCheck..."
20:56:24 <Lutin`> I don't think you would have that version of QuickCheck installed
20:56:42 <Rotaerk_Web> something that has a String -> IO (Maybe String) signature rather than throwing an exception
20:56:50 <Rotaerk_Web> (or an Either signature)
20:57:06 <Lutin`> Rotaerk_Web: You can catch the exception
20:57:07 <mzero> saddly no, but it is easy to build one with catch
20:57:18 <qrada> ya.. for examples i have Pipes in my Install.cabal for my Pipes dir.. but the dependency is 'pipes', so i didn't run into an issue so far with anything else
20:57:36 <octopuscabbage> Rotaerk_Web: There's probably a fileExists function, just write something using that
20:57:51 <Lutin`> qrada: I Would just call them like QuickCheckToyBox or something
20:57:59 <Lutin`> qrada: I Would just call them like QuickCheckSandbox or something
20:58:05 <Lutin`> whoops didn't mean to do that
20:58:07 <mzero> qrada: the pattern should be:   in dir   explore-foo    have explore-foo.cabal    that names the package explore-foo, version 0.1.0.0    and depends on foo
20:58:07 <qrada> ya
20:58:08 <Rotaerk_Web> there might be another reason for the read to fail besides file non-existence though; catch is probably the more generalized answer
20:58:22 <qrada> i just named it QuickCheckSandbox
20:58:25 <qrada> it's good now
20:58:26 <qrada> heh :F
20:58:29 <Rotaerk_Web> like a lock or something
20:58:32 <Lutin`> !next
20:58:38 <Lutin`> Oh wrong channel
20:58:43 <octopuscabbage> Rotaerk_Web Oh yeah, I suppose that's true.
20:58:45 <Lutin`> :$
20:58:50 <mzero> actually, it would be best to only catch IOExceptions there, methinks.... at least that is what I do when "fixing" those kinds of Prelude functions
20:59:51 <kyagrd> Can lazy state in mtl use a lot of memory?
21:00:27 <kyagrd> I just made my type inference using lazy state just used alomost 2GB memory :)
21:01:16 <dwcook> echo `cat /dev/random | head -c 8` | netcat localhost 12345 # ended up being pretty handy :)
21:01:17 <octopuscabbage> haskell has STM in ghc right?
21:01:17 <monochrom> lazy anything can use a lot of memory. eager anything can use a lot of memory.
21:01:52 <octopuscabbage> does one have to enable it with anything besides --threaded?
21:02:04 <mzero> Rotaerk_Web: something like
21:02:04 <mzero> readFileE f = catch (Right `fmap` readFile f) (\e -> return $ Left $ (show :: IOException -> String) e)
21:02:14 * hackagebot yesod-test 1.2.3.1 - integration testing for WAI/Yesod Applications  http://hackage.haskell.org/package/yesod-test-1.2.3.1 (MichaelSnoyman)
21:02:15 <Lutin`> kyagrd: http://book.realworldhaskell.org/read/profiling-and-optimization.html
21:02:55 <Rotaerk_Web> trying to think of whether there's any reason it shouldn't be converted to a string first
21:03:06 <Rotaerk_Web> can't think of any reason I would want to procedurally handle WHY the file-read failed
21:03:13 <Lutin`> mzero: You can do (\(IOException e) -> ... )
21:03:14 <mzero> or if you prefer
21:03:15 <mzero> readFileE f = catch (Right `fmap` readFile f) (\e -> return $ Left $ (e :: IOException))
21:03:16 <monochrom> I hate the false dichotomy anyway.
21:03:18 <Rotaerk_Web> just report it back to the user
21:03:33 <akater> What triggers hackagebot?
21:03:34 <Rotaerk_Web> what's the "E" at the end represent?
21:03:45 <Zekka> Out of curiosity, is there a name for this in the stdlib? http://hackage.haskell.org/package/acme-dont-1.1/docs/Acme-Dont.html
21:03:47 <mzero> Lutin`: I don't think so
21:03:54 <kyagrd> Lutin`: I should definitely try profiling ... after I fix the bug I'm working on.
21:03:55 <monochrom> the true dichotomy is: if you assume eager tools to be lazy, you will use a lot of memory. if you assume lazy tools to be eager, you will use a lot of memory.
21:03:55 <Zekka> I feel like it could be useful if you wanted to parameterize a function over what to do with a monadic action
21:03:55 <mzero> this isn't C    :-)
21:04:13 <monochrom> in short, PEBKAC uses a lot of memory.
21:04:13 <Zekka> (compare typesig of `don't` with typesigs of `forever` and `when`)
21:04:17 <mzero> Rotaerk_Web: just to distinguish it from readFile.... for me E = Either
21:04:22 <Rotaerk_Web> ah k
21:04:36 <akater> hackagebot posts whenever somebody uploads something at http://hackage.haskell.org/package ?
21:04:41 <mzero> Rotaerk_Web: you may not want to hand why... but you might want to report it
21:04:43 <Lutin`> mzero: ah I've just seen people do that
21:04:51 <mzero> hence the call to   show
21:04:59 <Zekka> There's probably a simpler function that can do the same
21:05:02 <Rotaerk_Web> mzero: yea definitely at least return a string
21:05:07 <GeraldCode> hello, I have been studying Haskell for the past 2 motnhs..*done it before also)..my question is..is it fair to say that explicit monads are only really useful in a strict functional lnague like Haskell? That is..were monads implemented in functional langs from category theory in order to simpulate things in imperative languages?
21:05:08 <Rotaerk_Web> can't think of a good reason not to just do that
21:05:20 <GeraldCode> So there is o point in explicitly creating them in imperative langs?
21:05:29 <Zekka> I guess if not you can just define it as (>> return ())
21:05:39 <monochrom> it is not fair to say that
21:05:44 <GeraldCode> ok
21:05:46 <mzero> Rotaerk_Web: then      readFileE f = catch (Right `fmap` readFile f) (\e -> return . Left . show $ (e :: IOException))
21:05:52 <Zekka> GeraldCode: Well, languages that aren't purely functional have been using monads for flow control for a while
21:05:54 <GeraldCode> Can you help me understand why it is not fair?
21:05:59 <Zekka> They just don't know it
21:06:04 <Rotaerk_Web> thanks, mzero
21:06:09 <GeraldCode> zekka, yes, thats what I mean..they use them implicitly right?
21:06:10 <mzero> Lutin`: with some extension I can't remember turned on you can say    (\(e :: IOException) -> ....)
21:06:13 <Zekka> Sometimes they even explicitly recreate the typesigs -- look at promises, for instance
21:06:25 <GeraldCode> So why implement them explicitly in imperative langs ( I see lots of tutorials for monads in imperative langs)
21:06:32 <monochrom> there are more useful monads than there are imperative models
21:06:35 <mzero> I actually have this handy function lying around in my toolbox:
21:06:48 <Welkin> what are examples of monads in imperative languages?
21:06:48 <mzero> catchIO :: IO a -> (Exception.IOException -> IO a) -> IO a
21:06:54 <mzero> catchIO = Exception.catch
21:07:10 <mzero> (with   import qualified Control.Exception as Exception   )
21:07:11 <GeraldCode> Welkin, I have read dozens of tutorials for them in the past weeks..for php, python, ruby, you name it
21:07:22 <GeraldCode> Maybe, State, everything
21:07:25 <dwcook> Zekka: "You're using monads but don't even know it" kind of avoids the practical point of monads. They are an abstraction and languages besides Haskell don't tend to leverage it.
21:07:26 <mzero> Welkin: control flow!
21:07:39 <Zekka> GeraldCode: By implement explicitly, do you mean "write code that has types that correspond to Monad" or "write code that literally says it's using Monad"?
21:07:57 <jle`> i would think, has a monadic interface
21:08:05 <GeraldCode> Zekka, I mean defining a class in PHP called Monad, or in Python...then subclassing Maybe and List etc
21:08:07 <Zekka> dwcook: That's true,, but I'm trying to argue even from the standpoint of 'a type with the typesigs provided by Monad is useful', which is something I don't think some people realize
21:08:10 <zomg> GeraldCode: I think monads can be convenient to solve the same problems in imperative langs, but they lose some of the expressiveness you have in Haskell
21:08:24 <zomg> And in many cases, they become very cumbersome to use in those languages
21:08:39 <dwcook> I would say expressiveness is exactly the reason we don't tend to see monads in other languages – Many/most other languages can't express them properly.
21:08:51 <mzero> GeraldCode: have you ever used short-circuit operators in an imperative language?
21:08:59 <GeraldCode> mzero of course!
21:09:00 <Zekka> GeraldCode: Personally I think it  could be useful but it would probably be less so because most of what I see in imperative languages is a few specific types that provide a clumsy monadic interface
21:09:13 <Rotaerk_Web> mzero: hmm looks like there's a catchIOError function which does the same thing
21:09:13 <Zekka> the language rarely seems to observe this
21:09:20 <GeraldCode> zekka, well I was thinking it could provide more structure
21:09:26 <GeraldCode> for something really loose like PHP
21:09:26 <dwcook> (Arguably Haskell can't either, but that's another argument)
21:09:31 <Rotaerk_Web> mzero: IOError is an alias for IOException
21:09:33 <mzero> GeraldCode: did you ever once find yourself in a situation where you thought "dang, I can't define my own short circuit operators"?
21:09:36 <sellout> I’m trying to get off Haskell Platform – is there still no good way to remove it?
21:09:41 <monochrom> Maybe and [] are useful monads universally. orthogonal to imperative vs not-imperative.
21:09:42 <jle`> i don't know, i'd think a lot of languages can provide useful monadic interfaces even with a less expressive type system
21:09:53 <Lutin`> Rotaerk_Web: No IOError is the data constructor for IOExceptions
21:10:03 <GeraldCode> mzero, hmm..im not sure actually
21:10:10 <Rotaerk_Web> Lutin`: http://hackage.haskell.org/package/base-4.7.0.0/docs/System-IO-Error.html#t:IOError
21:10:20 <Rotaerk_Web> says it's just an alias, there
21:10:25 <Rotaerk_Web> am I looking at the wrong thing
21:10:34 <Lutin`> derp
21:10:36 <Lutin`> no I'm blind
21:10:38 <Lutin`> sorry
21:10:49 <GeraldCode> dwcook, so you would say that expressiveness is the reason?
21:10:53 <mzero> well think about it -- those built-in, non-extensible short circuit operators are SOOOOPER convienent.... wouldn't it be nice to have that kind of stucture in other situations?
21:10:56 <Zekka> I think cutting the wheel-reinvention and expressing all monads under the same interface would save a lot of work in those cases, but I don't think there's enough monads in imperative programming or enough of a bias towards techniques that trivially turn into monads to justify it for a lot of people
21:10:58 <GeraldCode> I like good expressiveness..which is why I like haskjell
21:11:02 <mzero> those are monadic combinators....
21:11:09 <Lutin`> F# has monads, but they call them 'computation expressions'
21:11:10 <GeraldCode> but my job isnt haskell.I want to apply haskell principles to my job
21:11:20 <Zekka> So I think for it to be worthwhile you might have to change a lot of other things too
21:11:22 <mzero> and hence why people build monadic libraries (full or partial) in imperative languages
21:11:23 <Rotaerk_Web> oh, and there's also a tryIOError :: IO a -> IO (Either IOError a)
21:11:30 <dwcook> GeraldCode: There isn't a single reason. Another thing is that you can go all day pointing at arbitrary concepts and asking why most languages don't have that. Monad is just another one of those things.
21:11:31 <GeraldCode> hmm ok
21:11:55 <mzero> sellout: if you are on Mac OS X, there is program installed with the Platform: uninstall-hs
21:11:57 <mzero> run it
21:11:57 <GeraldCode> ok, can I ask this without sounding like Im trolling?
21:12:01 <Rotaerk_Web> C#'s LINQ syntax is monadic, but super ugly... not very GOOD an monadic
21:12:02 <Zekka> If you changed those other things I think it would be a mild net gain in expressivity but at that point you might be best off just using Haskell
21:12:08 <Rotaerk_Web> at*
21:12:11 <GeraldCode> Do you use Monads in imperative work?
21:12:19 <GeraldCode> explicit
21:12:20 <Zekka> Rotaerk_Web: LINQ is anothe good example
21:12:26 <jle`> monads have nothing to do with imperative/functional/declarative
21:12:29 <kyagrd> Monad transformers are lovely and dreadful at the same time.
21:12:39 <dmj`> F# doesn't have higher kindedness, so I don't think you can do monad transformers
21:12:41 <dwcook> GeraldCode: Yes, I use Monad in my Haskell, which in many cases is imperative. :)
21:12:49 <GeraldCode> lol good one
21:12:51 <Zekka> GeraldCode: In languages other than Haskell I use types with signatures that correspond to the types in the Monad typeclass, but I've never seen any of them called monads
21:12:52 <GeraldCode> ok fair enough
21:13:06 <jle`> many languages already offer a monadic interface for []
21:13:08 <mzero> GeraldCode: sure - plenty of C++ and Java libraries have something like Maybe, usually called Option or Optional  ... and I see code that uses it
21:13:24 <Zekka> In Haskell I write code that's pretty imperative because of monads if you want me to echo dwcook's sentiment
21:13:24 <kyagrd> Monad transformer library sometimes can bite you when you are using packages that use different versions of mtl and transformers
21:13:29 <GeraldCode> ok
21:13:41 <GeraldCode> hmm
21:13:58 <dwcook> Zekka: I wasn't saying my code was imperative by virtue of Monad, simply that parts of my code are written in an imperative style and I also happen to use Monad there
21:13:59 <Zekka> kyagrd: Difficulties of layering State in mtl make me very sad =( -- in general I like it OK though
21:14:05 <GeraldCode> my motivation here is that I want more reliable PHP code (yes that is my job, started out in C++ and C doing drivers!)
21:14:17 <mzero> And I have seen a lot of C and C++ code that builds a monadic-like framework for parsing
21:14:25 <dmj`> kyagrd: I think mtl re-exports a lot of transformers now
21:14:34 <Zekka> dwcook: I'm not quite sure I understand your argument. When I say I'm writing "imperative" Haskell, I'm using monads to manage effects
21:14:42 <Zekka> What do you mean when you say you're writing imperative Haskell?
21:14:50 <dwcook> For an example of a subjectively "non-imperative" style that uses Monad, look at chains of composed Kleisli arrows
21:15:06 <monochrom> the [] monad is most useful when [] is lazy. functional vs imperative is the false dichotomy. lazy vs eager is the true dichotomy. you don't use the [] monad elsewhere because elsewhere is eager.
21:15:09 <kyagrd> Zekka: things might have been better if we had better records in GHC
21:15:23 <jle`> monochrom: ah
21:15:31 <Zekka> Usually when I'm asking myself "is this code imperative" I think "is it using something that looks like State?"
21:15:34 <dwcook> Zekka: That's a good question, actually.
21:15:45 <Zekka> So whenever I think "imperative Haskell" I think of a specific kind of monadic code
21:15:48 <dwcook> Zekka: I'm not sure there _is_ a good definition of "imperative".
21:15:52 <Zekka> kyagrd: Amen to that.
21:15:56 <jle`> folds can be thought of as imperative :)
21:16:03 <jle`> well
21:16:05 <jle`> certain uses of fold
21:16:13 <Lutin`> "In computer science, imperative programming is a programming paradigm that describes computation in terms of statements that change a program state. In much the same way that imperative mood in natural languages expresses commands to take action, imperative programs define sequences of commands for the computer to perform."
21:16:19 <Lutin`> Is that a bad definition? ^
21:16:22 <Zekka> dwcook: More broadly, I take imperative to mean "changes in state shared between operations"
21:16:22 <octopuscabbage> jle' but you can always express a fold as a recursive function?
21:16:27 <dwcook> I think when I think "imperative" I most often think "using do notation". Pretty arbitrary of me :P
21:16:27 <mzero> Well, GeraldCode alas my day job is writing Python (at present), but I pull many ideas from Haskell into my code, monads being only a small part of it since, frankly, they generally a hairy mess in Python...
21:16:36 <jle`> octopuscabbage: the implementation is not the point
21:16:37 <Zekka> Lutin`: I'd argue it's a little bit too general
21:16:41 <dwcook> So in other words I think of "imperative" as _how_ you express something
21:16:42 <jle`> it's the paradigm/problem solving approach
21:16:51 <Zekka> dwcook: Well, yes, and I'd say the same
21:16:53 <jle`> if you solve your problem by repeatedly modifying some sort of state
21:16:58 <jle`> that's an imperative approach
21:17:09 <Zekka> After all, you can factor a lot of things that don't use State into State, and a lot of things that use State into not State
21:17:10 <jle`> a lot of folds are expressions of imperative approaches to solving problems
21:17:16 <Zekka> It's just an extra parameter and extra return-value
21:17:31 <kyagrd> ONLY IF we had better redords, we can have (State R1 a) and (State R2 a) and we can simply have (State R a) where R collects feilds of both R1 and R2
21:17:35 <Zekka> And I'd say folds look a lot like a specical case of that pattern a lot of the time
21:17:48 <jle`> i think a lot of people say fold is functional just because it is a higher order function
21:17:48 <GeraldCode> mzero, coool...I do take many things..like trying to ref transperency, etc
21:18:02 <kyagrd> We don't have to do silly linear stacking of StateT s just for conceptually flat State merging
21:18:06 <GeraldCode> But I am actually tyrying to write a mini framework that models haskell
21:18:08 <Rotaerk_Web> weird... tryIOError is in System.IO.Error, but hoogle doesn't know about it
21:18:16 <Zekka> More specifically, I'd say that folds look a lot like State where there's no return value -- only collected effects
21:18:21 <dmj`> kyagrd: in State s a, the type of s can't change
21:18:27 <Lutin`> mzero: I feel you, brother. My day job is mostly working with Django.
21:19:05 <GeraldCode> Pproblem is..PHPs functional support is very weak
21:19:05 <GeraldCode> even now that it has lambdas
21:19:05 <jle`> Zekka: well
21:19:05 <kyagrd> dmj': there are good ways of handling records in type system
21:19:05 <GeraldCode> for example..php lambdas are not equivalent to normal functions
21:19:05 <jle`> you need to be able to branch on your state
21:19:05 <GeraldCode> they are not interchangeable
21:19:05 <GeraldCode> so I am thinking about giving it up
21:19:05 <dwcook> GeraldCode: Yes, PHP is a particularly weak language for using functional style.
21:19:08 <jle`> which might be hard to do with a fold
21:19:11 <GeraldCode> might tell my boss I want to start doing scala
21:19:26 <dwcook> PHP technically doesn't even have first-class functions, if I recall.
21:19:28 <Zekka> jle`: I'll clarify, I think folds are less powerful, but still similar
21:19:37 <GeraldCode> dwcook , oh they do now
21:19:40 <GeraldCode> in a sense
21:19:47 <GeraldCode> but you cant interchange them with normal functions
21:19:48 <dwcook> That qualifier worries me :)
21:19:49 <Lutin`> Technically function objects
21:19:50 <Rotaerk_Web> actually, if you hoogle:  IO a -> IO (Either IOError a)   it gives you "try" as the first result.  clicking that try leads you to the System.IO.Error page, which contains no "try", but does have tryIOError
21:19:54 <Rotaerk_Web> seems a bit out of sync
21:19:55 <dmj`> Lutin`: good movie
21:20:14 <Lutin`> dmj`: lol
21:20:14 <path[l]> Hi, I’m trying to use QuickCheck with some code I wrote. I understand that the first step is to implement the Arbitrary instance for my type. Is there a way for me to test the generator after that and see some sample arbitrary instances?
21:20:22 <mzero> Lutin`: refactoring Python.... like sending your code off to Mordor: but you only find out if it fell off the rope bridge into the abyss after you wait 2 years for it to return and it doesn't....
21:20:26 <jle`> path[l]: yes
21:20:28 <jle`> um
21:20:30 <jle`> ...
21:20:38 <jle`> i forgot what it is at the moment
21:20:39 <Lutin`> mzero: Do you use PyCharm?
21:20:45 <Zekka> jle`: What's the way of putting it? I think folds aren't isomorphic, but homomorphic to State.
21:20:55 <mzero> path[l]: in practice you often don't have to implement Arbitrary
21:21:26 <monochrom> jle`: I wrote an algorithm for N-queen in haskell. it hinged on the [] monad as "nondeterministic choice, implemented by DFS and backtracking". (I also added forward constraint propagation, so it is not a really dumb exhaustive search.) if you just ask it for the first solution, it's very fast and lean. if you ask it for all solutions, but you make sure to throw away one solution before asking for the next, it's also fast and lean.
21:21:33 <kyagrd> dmj': we can have a type system that for R = {x::A,y::B}, R1 = {x::A}, all functions (f::R1 -> T) can also be applied to R values as well as R1 values
21:21:43 <mzero> for example, if you can construct your Thing from, say, a [Int] - then make your properties take [Int] and simply call   makeThingFromInts  inside first thing
21:21:56 <mzero> Lutin`: no
21:22:15 <Lutin`> mzero: I normally hate bulky IDEs but it's become invaluable to me
21:22:32 <Lutin`> And it has built-in Emacs bindings and a really nice Vim plugin
21:22:45 <mzero> alas, I'm inside Google -- we have our own pile of tools..... and requirements... that making using things like that untennable
21:22:52 <Lutin`> Ah okay
21:23:10 <Lutin`> Yeah I'm just in a 16 person dev shop that they try to call a startup
21:23:18 <Lutin`> Google would be nice... :(
21:23:52 <monochrom> then one day, I found that someone else wrote similar code in SML. by "similar" I mean a syntactic translation of my Haskell code in SML. that means semantically different, i.e., lazy vs eager. it's the [] monad but used in an eager language. the author reports: "this uses merely several hundred megs of memory and takes merely several minutes". that's the eager [] monad for him!
21:23:53 <dmj`> kyagrd: In the system you describe x would be ambiguous
21:23:58 <Zekka> mzero: Really? I'd heard they were pretty agnostic as far as that osrt of thing goes
21:24:15 <Zekka> from what I heard, you take on projects in Google-approved languages, but they don't care about OS/editor
21:24:17 <mzero> well... sure... IF you can get it integrated with all the stuff it needs to work with
21:24:23 <path[l]> mzero:  let me share my code so that I can make sure I’m not asking an xy question
21:24:33 <Zekka> Yeah, that' true -- I also hear Google provides a whole lot of tooling
21:24:50 <Zekka> (One of my friends works on Chromecast)
21:25:12 <monochrom> so what happens is that the eager [] monad has to compute all solutions, and keep all of them in memory, before it can tell you the first solution, and it's really hard to throw away solutions you no longer need.
21:25:20 <mzero> path[l]: happilly - use lpaste
21:26:05 <kyagrd> dmj': it's not necessarly ambiguous, records types are treated as collection of constraints
21:26:18 <monochrom> "can eager monads use a lot of memory?" yes
21:26:35 <path[l]> mzero: so I’m testing the two functions here http://lpaste.net/105771. (This is some glob matching code). I thought the right way to test them would be to generate an arbitrary [Glob], and write functions to generate a GlobString from a [Glob] and test that parseGlob (genGlobString (random [Glob])) = [Glob] and then somethin similarly for matchGlob
21:26:52 * monochrom hates "can laziness use a lot of memory?"  answer: PEBKAC can use a lot of memory.
21:27:20 <bugreporter> hi, I installed haskell on my windows box yesterday. Later I had a problem with my python configuration...I tested a few CAD packages and now it seems everithing is messed up...sight. Well, to make the situation better i want to report the following haskel bug on windows:
21:27:25 <Zekka> monochrom: I think it's worth mentioning though that it's a little harder to tell if what you're doing will use huge amounts of memory with lazy code
21:27:41 <Zekka> an algorithm that doesn't use a lot of memory in testing may suddenly use a lot of memory elsewhere when you use it differently
21:27:49 <bugreporter> Because of the messed up python config I checked the paths
21:27:59 <jle`> Zekka: the difference is the semantics of the computation
21:28:03 <monochrom> yes, I agree laziness is harder. but I hate giving it all the blame.
21:28:03 <bugreporter> I mean PATH variable on windows
21:28:25 <Zekka> jle`: Well, yes, it changes the semantics, but for computations where it doesn't obviously change the meaning it may still change the behavior
21:28:41 <monochrom> I hate thinking of laziness as a foe, just as I hate thinking of static types as a foe.
21:28:41 <dmj`> kyagrd: if you overloaded the record fields then yes, haskell records out of the box won't allow you to do that
21:28:43 <Zekka> Personally I don't think laziness is actually that hard to reason about, but I understand when people express concerns
21:28:56 <Zekka> and I think it's pretty useful, and even necessary
21:28:58 <bugreporter> It has four entries on my Win 7, two are not existing
21:29:08 <kyagrd> dmj': see http://www.haskell.org/haskellwiki/Extensible_record for pointers
21:29:15 <Zekka> Stuff like the IO monad makes much less sense when talking about evaluation order
21:29:16 <mzero> path[l]: that's not unreasonable... and writing the Arbitrary instance for Glob will be instructive.... but
21:29:27 <octopuscabbage> The way I see it laziness is only a problem when you forget it's there
21:29:31 <Zekka> Well, no, I shouldn't say that
21:29:40 <monochrom> my response to "I understand when people express concerns" is: I understand that human psychology needs scapegoats.
21:29:44 <mzero> I'm not sure I'd go to the effort to test parseGlob - it is rather straight forward, and hard to imagine being wrong
21:29:48 <Zekka> It depends on if you think of IO as a magic Identity or a magic State
21:29:55 <hunt> how do i render hamlet files and pass arguments to the file?
21:30:01 <hunt> i cant find any documentation...
21:30:02 <Zekka> As a magic Identity it's confusing, but not as a magic State
21:30:04 <mzero> parseSet is a bit hairy
21:30:13 <jle`> IO is neither a magic identity or a magic state ...
21:30:17 <jle`> it's just a normal data type
21:30:21 <kyagrd> dmj': I'm not talking about GHC's current records. Was just wishing it were better (and there are establisehd theories for that).
21:30:21 <jle`> like Maybe or []
21:31:12 <path[l]> mzero: yeah, honestly this is more about learning than anything else :). I’m trying to figure out how to write the Arbitrary instance for Glob and see some of the generated values to understand what I did
21:31:20 <dmj`> kyagrd: yea, I feel your pain, I have to prefix a lot of my record names with letters to disambiguate.
21:31:37 <bugreporter> C:\Program Files (x86)\Haskell Platfrm\2013.2.0.0\mingw\bin  has a typo
21:31:46 <Zekka> jle`: Usually when I think about IO I think about it as a type that does magic when you unbox it (along the lines of runIdentity or runStateT)
21:31:55 <Zekka> I don't think this metaphor really carries through all that well though
21:32:03 <bugreporter> nobody interested on the info?
21:32:10 <path[l]> mzero: I’m not even sure where to start. For example, I’d like to generate an instance for SetType. I want to get a working arbitrary instance for SetType and see that it generates literals and ranges and so on
21:32:20 <jle`> Zekka: that's a dangerous way to look at it
21:32:28 <Zekka> even though that's how most monads/monad transformers work (you unwrap the newtype and then do something interesting with the thing inside that encompasses the actual behavior)
21:32:29 <jle`> Zekka: especially when there as a perfectly safe/fine way to look at it
21:32:37 <jle`> that doesn't involve any mental games
21:32:42 <jle`> and is actually accurate, semantically
21:32:43 <Lutin`> bugreporter: You can file a bug report at https://github.com/haskell/haskell-platform
21:32:51 <jle`> and is accurate for all situations :)
21:32:55 <Zekka> jle`: Yeah, I think you're right
21:33:05 <mzero> you could easily, say, take   [Either Char (Char, Int)]   and generate a list of ranges from that
21:33:07 <jle`> except for unsafePerformIO but that's just cheating >_>
21:33:18 <Zekka> It's an easy intuition because like I said, that's how you interact with most monads
21:33:29 <Zekka> well, I shouldn't say most
21:33:32 <jle`> hm
21:33:35 <bugreporter> Thanks Lutin. May I say, that on the Main Haskel page .org I was unable to find a link to the source and/or Bug report site? Perhaps you have more feedback.
21:33:40 <jle`> i guess that is true
21:33:41 <Zekka> It's how you interact with Reader, Writer, State, and so on
21:33:55 <mzero> well - here's the deal.... we need to think - what properties are we actually trying to say are true about what....
21:34:08 <Zekka> If you've got an explanation that plays to the same intuition but doesn't lead you to make wrong assumptions, I'd be interested
21:34:23 <Zekka> I doubt there's a very good one though, probably best to stick to accurate ones
21:34:52 <Lutin`> bugreporter: under haskell.org/platform/ there's a link on the side that says "Problems?" but the bug report takes you to Trac which tells you to go to GitHub
21:34:55 <path[l]> mzero: the way I thought about it was. One property was that given a globarray — a string generated from it should be parsed correctly. The other was, given a globarray —a  string generated that should be matched by the pattern, is indeed matched by the pattern
21:35:16 <Zekka> It's pretty easy to think of main being surrounded by some internal function that runStateTs it and runs the real world through
21:35:30 <mzero> Lutin`: (all irony respectfully taken) - can you file a bug about that?
21:35:33 * mzero ducks
21:35:38 <Zekka> er, runState*
21:35:57 <jle`> Zekka: yeah but it leads to a lot of bad intuitions :/
21:36:06 <Lutin`> mzero: Yeah can do
21:36:25 <mzero> path[l]: those are decenent ideas, for testing matchGlob
21:36:35 <Zekka> jle`: I don't mean "easy" in the sense that it should be that way
21:36:37 <Lutin`> mzero: It's on the wiki so I can just change it
21:36:43 <jle`> ah
21:36:45 <jle`> yeah
21:36:50 <jle`> that's how i was told of it first
21:36:58 <mzero> how about things like     given a char and an Int      c* should parse to a GlobPattern that matchs   replicate n c
21:36:59 <jle`> and that's how i understood it as first
21:37:00 <Lutin`> mzero: Oh wait no wiki account
21:37:04 <Zekka> as in "it's an inadeuacy of Haskell that it doesn't work that way" or "it's so close that there's not a reason to describe it another way"
21:37:12 <mzero> no no - report the bug on GitHub!
21:37:22 <Zekka> It's really just a type system hack if I'm not mistaken
21:37:30 <Lutin`> mzero: Yeah, doing so now
21:37:50 <Zekka> monads are a good tool to compose computations that have the ability to result in values so it made sense to use them for IO
21:38:14 <enthropy> Zekka: that model doesn't represent concurrency
21:38:43 <[swift]> my haskell has gotten rusty, apparently. say i have "do { v <- foo a <$> bar b <*> baz c ; return $ Just v }". is there a clean way to push the 'Just' wrapper into the first expression?
21:38:48 <dwcook> jle`: What bad intuitions in particulare are you alluding to?
21:38:48 <Zekka> enthropy: Which is frustrating because, from a type standpoint, I'm not sure how to respect concurrency
21:38:51 <dwcook> particular*
21:38:57 <mzero> path[l]:      propAnyInRange c1 c2 = all (matchGlob (parseGlob $ [ '[', c1, '-', c2, ']') . (:[])) [c1..c2]
21:39:00 <Zekka> it's often not observable
21:39:02 <jle`> the problem with that model is that it falls apart fast and there is another model/intuition that doesn't fall apart
21:39:18 <Zekka> let's say you defined doConcurrently :: m a -> m b -> m (a, b)
21:39:21 <jle`> and is actually how IO is described semantically
21:39:38 <Zekka> Surely it's possible to implement both concurrent and unconcurrent versions of that function which have the same type
21:39:40 <Welkin> [swift], do you use swift?
21:39:40 <[swift]> "Just . foo a <$> bar b <*> baz c" doesn't typecheck, alas
21:39:52 <mzero> I think, path[l]  this is the better way to think about --- given strings or characters (and perhaps ints)   think of pairs of GlobPatterns and Strings that they should match (or perhaps not match)
21:39:54 <Zekka> So it's very hard to observe concurrency as far as I can tell
21:40:12 <Welkin> has anyone used swift with haskell?
21:40:41 <dsturnbull> Zekka: you know it's concurrent if it's not within the same monad, don't you?
21:40:46 <[swift]> Welkin: nope. this nick is attracting more attention since apple announced it =)
21:41:00 <Zekka> dsturnbull: Can you explain what you mean?
21:41:06 <Welkin> well, it's also a type of bird
21:41:10 <Welkin> as well as a pokemon attack
21:41:25 <[swift]> and a major trucking company
21:41:45 <jle`> where is monochrom's io tutorial
21:41:48 <Zekka> One of my friends has been working on a programming language named Swift for the last two years
21:41:53 <jle`> it is my favie :'(
21:41:54 <Zekka> he's not happy
21:42:04 <Zekka> (It's not the programming language called Swift that's even older than that)
21:42:08 <jle`> but merijn keeps on linking to my dinky IO explanation and it's slightly embarassing
21:42:09 <path[l]> mzero: hmm
21:42:11 <Welkin> there are three languages named "Swift"
21:42:12 <[swift]> Zekka: is it the one that apple links to from the main swift page?
21:42:25 <enthropy> Zekka: what do you mean by observe? main = do forkIO (print "xxxxxx"); print "yyyyyyy" -- interleaves things
21:42:26 <jle`> but i respect merijn so i guess he must believe in me or something
21:42:32 <[swift]> it's a pretty good name for a programming language.. not surprised it's been used multiple times before
21:42:33 <Zekka> [swift]: It's a proprietary language without much web presence that he's planning to release in a while
21:42:40 <mgaut72> !MBspeak
21:42:43 <Zekka> enthropy: Yes, but your Haskell program can't see it directly, can it?
21:42:53 <Welkin> proprietary?
21:42:54 <jle`> Zekka: yes, there are ways to talk between threads
21:42:54 <Zekka> If forkIO wasn't concurrent your haskell program would see the same thing, wouldn't it?
21:42:56 <Welkin> what's the point then?
21:43:07 <dwcook> jle`: I believe you'll find those articles under the name Albert Lai. That is, as far as I recall, his real name.
21:43:21 <Zekka> Welkin: He plans (or at least planned) tostart selling it about six months from now
21:43:48 <Zekka> He's been promoting it among game developers for a while and he's worried he's going to lose some of hte goodwill he's accumulated
21:44:03 <mzero> path[l]: ? how'z'bout:    propStarMattersNot s = matchGlob ("abc*def") ("abc" ++ s ++ "def")
21:44:11 <Zekka> jle`: It mostly puts me off because there's not a clear indication in the type of what's going on
21:44:11 <Lutin`> mzero: Done
21:44:21 <mzero> Lutin`: thanks
21:44:30 <Zekka> I'm aware that you can talk between threads, but a version that runs one thread, then the other, will have the same type
21:44:45 <path[l]> mzero: does that mean s will get generated … oh I see
21:44:45 <mzero> path[l]: I think a dozen or so of those will easily cover your code better than trying to come up with Arbitrary instances...
21:44:48 <Zekka> it will obviously do the wrong thing if your program relies on that ability, but in a well-typed fashion
21:44:48 <Rotaerk_Web> hmm... I'm realizing how much of a pain it is to report errors in the form of Either MyError Result, because you then have to create an ADT for every failable function, many of which will overlap (have common error-reasons)
21:44:48 <path[l]> hmm
21:44:51 <dwcook> jle`: http://www.vex.net/~trebla/haskell/IO.xhtml
21:45:04 <Rotaerk_Web> is there a ... solution to that
21:45:10 <mzero> path[l]: yes, s :: String, and those will just be randomly generated (including the sneaky "" string!)
21:45:11 <enthropy> Zekka: ok well you could have two threads race to fill a MVar, if you want some variable in haskell whose value will depend on which thread finishes first
21:45:19 <kyagrd> Speaking of lazyness, I've learn't that trace can sometimes give you the feel whether lazyness is being your enemy.
21:45:34 <enthropy> but I think you should include what's printed to stdout when you talk about "is this program equal to another"
21:45:47 <hunt> guys
21:45:48 <hunt> please
21:45:48 <kyagrd> Cause tracing output of some state variables actually forces them.
21:45:50 <mzero> Rotaerk_Web: you could just cop out to SomeException
21:45:52 <hunt> how do i render a hamlet file
21:45:53 <mzero> or just String
21:46:04 <hunt> i have hamletFile "..."
21:46:06 <Lutin`> mzero: Found a couple more dead links, I'll makes issues about those too
21:46:06 <enthropy> after all, that's the way you can tell what the program actually does
21:46:08 <hunt> but that gives me a type Q
21:46:09 <jle`> Zekka: the main point i'm trying to make is that there's no reason to try to justify the State RealWorld view and twist it to make sense when there is another perfectly valid, very understandable, semantically correct, well-explaining, and intuitive explanation/model
21:46:11 <hunt> but that gives me a type Q Exp
21:46:14 <mzero> okay - thanks, Lutin`
21:46:15 <hunt> which i have no idea how to render
21:46:23 <mzero> they could go in one issue, though
21:46:25 <Lutin`> No problem
21:46:26 <enthropy> jle`: what is it
21:46:28 <Lutin`> Ah alright
21:46:42 <Zekka> enthropy: I'm trying to argue that with most monads it's self-evident what's happening when you look at types
21:46:46 <dwcook> jle`: Would that be the "IO-as-free-monad" view?
21:47:06 <jle`> IO as data and first class statements
21:47:08 <Zekka> With concurrency it's self-evident what's happening when you look at effects, or even when you look at values -- but unlike most monads, it's not evident when you look at types
21:47:24 <Zekka> I'm still reading jle`'s link for what it's worth
21:47:27 <octopuscabbage> What's the most popular functional web framework pattern? I can't imagine it's MVC?
21:47:45 <path[l]> mzero:  cool, thanks
21:47:55 <Maxdamantus> String -> IO ()
21:47:57 <mzero> welcome, path[l]
21:47:59 <Rotaerk_Web> mzero: my primary concern with that approach is the possibility of a scenario that wants to handle the different error reasons in different ways...
21:48:12 <zomg> octopuscabbage: "reactive" is probably the latest buzzword. MVC-style patterns work well though
21:48:16 <Rotaerk_Web> though ...
21:48:19 <Zekka> enthropy: I'm not saying it's not observable, only that it's not observable the way the behaviors of other monads are
21:48:26 <Rotaerk_Web> I guess I can't think of a concrete example of that
21:48:26 <mzero> well... if you don't have the use case yet... you might be over-designing
21:48:38 <Rotaerk_Web> true
21:48:42 <Zekka> If you have get and put, then -- without error/recursion tomfoolery, you *must* have State
21:48:46 <octopuscabbage> zomg: could you give me a quick rundown of what a reactive framework looks like?
21:48:55 <Zekka> because otherwise there's no way to get the value expoed by get
21:49:00 <mzero> but technically, it is really hard to know ALL the possible errors an IO function can throw
21:49:28 <zomg> octopuscabbage: frankly I'm not that familiar with the pattern myself either... the Elm language is probably the most practical example of reactive design for the web currently
21:49:45 <Rotaerk_Web> hmm k
21:49:54 <octopuscabbage> zomg: well okay, i think i saw a talk on it earlier, i might go back and watch that
21:49:55 <Lutin`> mzero: Done and done
21:49:56 <mzero> so, perhaps it is reasonable, in a given app, to compromise and have something like:   data SystemError = F
21:49:57 <mzero> er
21:50:08 <Rotaerk_Web> F-er !?
21:50:08 <jle`> Zekka: fwiw i wrote this post a while ago ( http://blog.jle.im/entry/the-compromiseless-reconciliation-of-i-o-and-purity ) and there's a lot i'd change if i were to write it today >_> but it sort of explains the basics of this view and also the advantages of thinking of it this way
21:50:13 <Rotaerk_Web> *cough*
21:50:22 <Lutin`> mzero: I read that as SystemF = Error
21:50:27 <Lutin`> good chuckle there haha
21:50:31 <mzero> data SystemError = SEPermissions | SETimeout | SENameError | SEOther IOException
21:50:41 <Zekka> jle`: For what it's worth this so far seems like a pretty adequate literal explanation of what I'm pretty sure everyone who works with Haskell knows IO actually does
21:50:46 <bugreporter> Lutin: I just filed a bug report about the PATH variable. Another user seemed to have the issue also. So I attached my case too as image. Thanks! and all best
21:51:37 <jle`> Zekka: hm? i'm not even sure if i am making up the disagreement between us in our heads
21:51:42 <Adeon> IO works by carefully passing around the state of the universe
21:51:48 <Zekka> I don't think there's a disagreement here
21:51:52 <jle`> Adeon: that's exactly the view that we are trying to avoid
21:51:53 <mzero> thanks for that report, bugreporter  - looks nasty
21:51:56 <path[l]> mzero: when I DO define an arbitrary instance of something, how can I just get a few in ghci to see hat it’s donig
21:51:58 <jle`> that the state of the universe model falls apart fast
21:52:12 <jle`> and that's not actually how IO behaves semantically
21:52:16 <Zekka> Mostly I explained the intuition and where it came from, and a bit about why it's hard to dispel (because some of the common counterexamples don't show up in types)
21:52:24 * mzero rummages around for some sample code
21:52:27 <jle`> ah
21:52:28 <Zekka> I think jle`'s taken to assuming that this means I'm a fan of it
21:52:55 <jle`> my apologies then
21:52:56 <enthropy> path[l]: there's a "sample :: Show a => Gen a -> IO ()"
21:53:02 <jle`> that's what i get for watching tv and being on irc :)
21:53:10 <jle`> i owe you a high five
21:53:12 <jle`> o/
21:53:12 <Zekka> No worries, it's fine
21:53:15 <Zekka> \o
21:53:19 <jle`> ty
21:53:32 <path[l]> enthropy: can you explain to me how I use it? :)
21:53:35 <jle`> i do wonder why it's so prevalent
21:53:42 <jle`> i am not sure i understand your type argument
21:53:51 <jle`> but i'll think it through and reread it
21:54:05 <Zekka> Like I said, probably because the way you use reader, writer, state intuitively seems like it should be how you use IO
21:54:22 <Zekka> it seems as if something from the outside world should be unwrapping your IO and then doing something with the newtype underneath
21:54:24 <enthropy> path[l]: well you've presumably defined one particular "arbitrary :: Arbitrary a => Gen a"
21:54:26 * [swift] wonders why mapMaybeM is tucked away in the MonadUtils "backwards compatibility" package
21:54:29 <Zekka> er, the real type underneath
21:54:34 <jle`> hm
21:54:40 <jle`> yes
21:54:44 <Zekka> Like, it feels like it should be a thin newtype wrapper because it only wraps one value and that value is always there
21:54:44 <jle`> IO is very much unlike most common Monads
21:54:50 <enthropy> path[l]: so it's just a matter of   sample (arbitrary :: Gen Glob) -- or whatever your type is
21:54:55 <jle`> people often say "how do I get the String out of IO String"?
21:54:59 <Zekka> The way it has a value in it but you can't get the value out *looks* like State
21:55:11 <path[l]> enthropy: aha, that worked, thank you
21:55:31 <Zekka> In addition, cases where you're doing *weird things* in IO that can't be explained by operations on a value -- usually concurrency -- don't always show up in type
21:55:34 <jle`> it doesn't help that GHC implements it as State RealWorld for some reason
21:55:44 <Zekka> for most standard concurrency primitives it's possible to define a non-concurrent version that has the same type
21:55:56 <bugreporter> quit
21:56:01 <Zekka> Obviously it doesn't have the same behavior, but the type is the same
21:56:04 <jle`> don't leave bugreporter
21:56:06 <jle`> aw
21:56:16 <Zekka> unlike Reader, where if you can implement ask, you definitely have Reader (or, well, you might have State, because ask's type is similar to get's)
21:56:46 <mzero> path[l]: also check out  the function   sample' :: Gen a -> IO [a]
21:57:08 <path[l]> mzero: ah
21:57:11 <Zekka> So you can't define IO', which is literally State RealWorld, and then demonstrate that it's impossible to define concurrency operations
21:57:19 * hackagebot yesod-bin 1.2.10.3 - The yesod helper executable.  http://hackage.haskell.org/package/yesod-bin-1.2.10.3 (MichaelSnoyman)
21:57:21 * hackagebot yesod-form 1.3.11 - Form handling support for Yesod Web Framework  http://hackage.haskell.org/package/yesod-form-1.3.11 (MichaelSnoyman)
21:57:22 <Zekka> because you can define them -- they just do the wrong thing in a way that's hard to observe
21:57:23 * hackagebot yesod-websockets 0.1.1.2 - WebSockets support for Yesod  http://hackage.haskell.org/package/yesod-websockets-0.1.1.2 (MichaelSnoyman)
21:57:50 <jle`> hm
21:57:59 <Zekka> From what I hear you can even define them using a different transformer stack to do the *right* thing, although changing the transformer stack makes it observable in type and the point's moot
21:58:15 <Zekka> (See here: http://www.haskellforall.com/2013/06/from-zero-to-cooperative-threads-in-33.html )
21:58:49 * mzero >>= bed
21:58:53 <mzero> night all
21:59:00 <Zekka> return $ Good night.
21:59:16 <jle`> mzero >>= bed = mzero
21:59:18 <jle`> so
21:59:21 <Lutin`> lol
21:59:25 <jle`> (>>= bed) = id
21:59:49 <Lutin`> wat
21:59:50 <jle`> so...you should still be here :(
21:59:56 <Zekka> Is bed const?
22:00:03 <jle`> Lutin`: er sorry, not quite
22:00:06 <jle`> mzero >>= bed = mzero
22:00:06 <Zekka> er, wait
22:00:12 <Zekka> that's not const unless you generalize to Arrow
22:00:15 <jle`> (>>= bed) acts like id in this case
22:00:17 <jle`> when applied to mzero
22:00:28 <jle`> it's a part of the MonadPlus laws
22:00:31 <jle`> mzero >>= f = mzero
22:00:37 <Zekka> what am I saying
22:00:47 <Zekka> Yeah, you're right, I'm making two mistakes
22:00:52 <brrrrian> hellllllo #haskell !
22:00:58 <Zekka> one, I'm forgetting the monadplus laws, and two, I'm forgetting the signature of const
22:01:01 <jle`> hello brrrrian
22:01:03 <Lutin`> Good evening
22:01:05 <Zekka> what I'm *trying* to say is return
22:02:04 <jle`> bed >>= mzero is not necessary mzero
22:02:06 <jle`> so
22:02:10 <jle`> maybe that should make more sense
22:02:12 <jle`> oh
22:02:13 <jle`> mzero =<< bed
22:02:51 <brrrrian> what kind of data type is this?  data Foo :: Bar -> * -> * where Blah :: a -> Bar t a
22:03:02 <jle`> brrrrian: it's GADT syntax
22:03:07 <jle`> are you familiar with it?
22:03:18 <brrrrian> no, not really
22:03:31 <jle`> oh
22:03:41 <enthropy> looks like there's an error there
22:04:03 <enthropy> data Foo :: * -> * where ...
22:04:07 <jle`> i was going to say, me neither :)
22:04:15 <brrrrian> but what is the asterisk?
22:04:20 <enthropy> data Foo :: * -> * where Blah :: a -> Foo t a
22:04:31 <enthropy> oops
22:04:44 <enthropy> data Foo :: * -> * -> * where Blah :: a -> Foo t a
22:04:54 <brrrrian> I am trying to understand "Model" here: https://github.com/ekmett/time-series/blob/master/src/Data/Time/Series/Model.hs
22:04:59 <jle`> brrrrian: it's a Kind signature
22:05:02 <jle`> :k Maybe
22:05:05 <lambdabot> * -> *
22:05:21 <Zekka> brrrrian: Basically, it says that if you feed it two parameters of kind * then it'll turn into a *
22:05:25 <jle`> Maybe takes a * (a type) and returns a * (a new type)
22:05:27 <Zekka> where * means 'Haskell type'
22:05:33 <jle`> :k Either
22:05:35 <lambdabot> * -> * -> *
22:05:47 <jle`> Either takes two *'s  (haskell type) and returns a new *
22:05:49 <Lutin`> * means a lifted type
22:05:57 <jle`> ^^
22:06:00 <brrrrian> naive question that I could just google but... why use * instead of just a type variable?
22:06:26 <Zekka> brrrrian: Well, * is basically a type in this context
22:06:36 <Zekka> not a type variable but a type
22:06:43 <Lutin`> brrrrian: It comes from System F, which is a basis of the Haskell type system
22:06:50 <Zekka> Think of it as the signature of the type-level function described by Foo
22:06:53 * enthropy prefers "data Model (t :: Timing) (a :: *) where"
22:07:10 <Lutin`> iirc that is
22:07:19 * hackagebot yesod-bin 1.2.11 - The yesod helper executable.  http://hackage.haskell.org/package/yesod-bin-1.2.11 (MichaelSnoyman)
22:08:31 <brrrrian> not a type variable but a type...
22:08:51 <Zekka> brrrrian: Think of it as a type which any Haskell type is a member of
22:09:10 <Zekka> the same way 1, 2, and 3 are all Ints, Int, Float, and String are all *s
22:09:27 <Zekka> Maybe is not a *, but a (* -> *) -- it needs a *, like Int or Float, to become a *, like Maybe Int or Maybe Float
22:09:29 <joelteon> It's the set of all types.
22:09:34 <joelteon> err wait.
22:09:36 <joelteon> That's totally wrong.
22:09:40 <MP2E> a type variable is still on the type level, * is on the kind level. Which is kinda like the 'type of types'
22:09:44 <joelteon> Wait no, that's totally right.
22:09:45 <brrrrian> so why couldn't it be written as: data Model :: (t :: Timing) -> a where ...
22:09:48 <joelteon> * is the set of all types.
22:09:53 <joelteon> (->) isn't a type.
22:09:57 <joelteon> I am right after all.
22:10:01 <Lutin`> * is any member of the set of all types
22:10:18 <Lutin`> well all proper/lifted types
22:10:28 <orzo> monad implies a kind of time dependence
22:10:33 <Zekka> Lutin`: What's the difference between a lifted and an unlifted type?
22:10:37 <orzo> does applicative?
22:10:43 <josiah14> I've been searching around but not finding anything on this
22:10:45 <Lutin`> Doesn't include types of kind (* -> *) and unboxed types
22:10:52 <Zekka> orzo: What do you mean 'time dependence'?
22:11:05 <josiah14> I'm in ZSH, and from GHCI, i can see the System vars (such as PATH)
22:11:08 <joelteon> I don't think (* -> *) is a type though, it's a type constructor.
22:11:09 <orzo> or of computation
22:11:13 <orzo> order
22:11:16 <Zekka> Functors, Applicatives, and Monads all provide context for their values, where 'time dependence' is at least one kind of context
22:11:19 <joelteon> There is no value of type "Maybe".
22:11:20 <Zekka> Oh, order
22:11:22 <josiah14> but not the ZSH shell vars (such as PROMPT and PS1)
22:11:31 <Lutin`> http://www.haskell.org/ghc/docs/7.4.1/html/users_guide/kind-polymorphism-and-promotion.html
22:11:35 <orzo> does applicative leave the order of computation more free?
22:11:36 <path[l]> could someone explain to me what my parse error here is http://lpaste.net/105772
22:11:38 <josiah14> is there a lib for that or do I need to build one
22:11:40 <enthropy> joelteon: there's another counterexample. That Timing kind there has types that are not kind *
22:11:47 <Zekka> This is something I don't have a strong intuition for so let me try to find a way to explain it
22:11:53 <joelteon> Right, I forgot about data kinds.
22:11:57 <Lutin`> josiah14: (* -> *) is the kind of a unary type constructor
22:12:03 <jle`> orzo: monads are not necessarily about sequencing
22:12:16 <jle`> orzo: but yes Applicative letes you combine computaitons that do not depend on eachother
22:12:35 <josiah14> Lutin`: what does that have to do with my question about accessing ZSH vars from haskell?
22:12:42 <Lutin`> Oh whoops
22:12:45 <Lutin`> I meant joelteon
22:12:46 <Zekka> What (>>=) really does is let computations depend on the effects of other computations
22:12:52 <Zekka> Applicatives don't have that
22:12:58 <joelteon> josiah14: do you mean environment variables?
22:12:59 <jle`> orzo: you can think of in a way that as Monad with only (>>), so nothing depends on the previous thing
22:13:06 <Zekka> I guess that's how I'd get into what you're getting at
22:13:10 <josiah14> joelteon: yes, sorta
22:13:17 <joelteon> sorta?
22:13:17 <jle`> (i don't think it's actually Monad with only (>>), but it's an example >_>)
22:13:18 <enthropy> path[l]: line 9 needs to line up with the x above
22:13:42 <josiah14> but I can access the PATH var, which is a System level var, using System.Environment.getEnv
22:13:45 <path[l]> aha, thanks :)
22:13:49 <jle`> :t (*>)
22:13:51 <lambdabot> Applicative f => f a -> f b -> f b
22:13:53 <Zekka> Applicatives let you deal with computations that are in contexts
22:13:54 <josiah14> but I can't access PS1 or PROMPT
22:13:57 <jle`> :t (<*>)
22:13:58 <Zekka> but those computations don't themselves affect the context
22:13:59 <lambdabot> Applicative f => f (a -> b) -> f a -> f b
22:14:03 <josiah14> which are used for configuring the shell
22:14:13 <joelteon> josiah14: that's because your .zshrc sets those variables.
22:14:13 <Zekka> There's no Applicative f => (a -> f b) -> f a -> f b
22:14:20 <josiah14> i.e. changing it's colors' fonts, status line, etc
22:15:03 <joelteon> I actually don't think those variables are visible to programs you run.
22:15:03 <josiah14> so I would need bindings to ZSH to access them from Haskell
22:15:05 <joelteon> I'm not sure why.
22:15:09 <Rotaerk_Web> yea I think instead of creating, for each failable function, an ADT to represent all the ways it can fail, I will just use Control.Monad.Catch stuff from the exceptions package.
22:15:29 <Zekka> Rotaerk_Web: I'd personally use Either with such an ADT
22:15:39 <joelteon> josiah14: You could use PROMPT="$PROMPT" ./my_program
22:15:55 <joelteon> I'm guessing there's a good reason PROMPT isn't visible to programs by default
22:16:03 <Lutin`> josiah14: Have you tried System.Environment.getEnvironment
22:16:09 <josiah14> well, I need to be able to manipulate PROMPT
22:16:15 <Rotaerk_Web> Zekka: the biggest problem with that many of those ADTs will overlap or contain each other
22:16:20 <Lutin`> josiah14: I assume that's what you're using
22:16:20 <brrrrian> why would you want to use kinds instead of type variables?
22:16:23 <joelteon> josiah14: I'm not sure that's possible.
22:16:24 <Rotaerk_Web> and coming up with unique names for all of them is a nightmare
22:16:28 <josiah14> yes, i did Lutin` - in order to view all the vars Haskell knows about
22:16:30 <joelteon> Why do you want to do this in haskell?
22:16:41 <josiah14> it has to be
22:16:48 <joelteon> why?
22:16:49 <josiah14> Powerline does it with Python
22:16:55 <josiah14> so I'm sure Haskell can handle it
22:17:07 <joelteon> The only powerline I know of is a vim plugin.
22:17:37 <josiah14> joelteon: Powerline grew into more than that.  It plugs into Vim, Emacs, Bash, Zsh, Tmux...
22:17:44 <Rotaerk_Web> Zekka: one function might fail for reasons A, B, or C, another for B or D; another might call the first one and the second one, thus failing due to A, B, C, or D
22:18:12 <Zekka> Rotaerk_Web: Yeah, I'm not sure of what a great way to handle this would be -- I can think of a few options, but they're not all simple
22:18:16 <orzo> i'm trying to do interesting things with Monad, but I'm blocked because I can't chase down code paths.  I would like to chase every possible branch and cumulate the result into a non-dependent variable
22:18:33 <Rotaerk_Web> Zekka: only thing I can think of is data types a la carte, but that's ...
22:18:46 <joelteon> josiah14: isn't the powerline prompt configured in the powerline-specific configuration file?
22:19:02 <Lutin`> josiah14: I don't powerline has direct access to shell variables
22:19:20 <joelteon> I would think it would set the PROMPT variable and exec the shell.
22:19:20 <Zekka> orzo: I don't quite understand your problem, can you clarify?
22:19:23 <orzo> it seems like it should be possible, but because bind is represented as a function rather than something that actually encodes the dependence, i cant do it
22:19:30 <joelteon> I don't think it can modify the PROMPT from within the shell.
22:19:46 <josiah14> could be, I spent some time reading the code last night but didn't get down to actually figuring out how they override the shell prompt
22:20:12 <joelteon> so if you want to write a Haskell wrapper for your shell, you'll need to do something similar.
22:20:19 <Rotaerk_Web> Zekka: I'm thinking if I go with *pure* exceptions (i.e. I don't throw something that would let the application crash, but I just use, say, an "Either SomeException Result")
22:20:22 <joelteon> If you're interested in Haskell shells, you might look at chrisdone's 'hell'
22:20:23 <orzo> imagine if your Monad instance could access the syntax representation of the function passed to the bind operator
22:20:46 <Rotaerk_Web> Zekka: and then in a scenario where I need specific errors to match against, I can wrap it and define an ADT
22:20:59 <Rotaerk_Web> tailored to that use-case
22:21:01 <josiah14> I might look into that
22:21:20 <Zekka> Rotaerk_Web: That was one of the thoughts I had -- it's not that pretty but it would work
22:21:21 <josiah14> it might be an easier first project than wrapping the shell in a haskell lib to get things done
22:21:26 <Lutin`> joshc: Yeah you have to write a zsh script
22:21:31 <Zekka> oh I just threw up a little in my mouth
22:21:35 <Rotaerk_Web> lol
22:21:38 <Zekka> but I don't think it was related to your strategy, so it's probably fine
22:21:38 <josiah14> I'm not exactly sure how complicated that would get
22:21:39 <Lutin`> You can't change shell variables from another process
22:21:46 <orzo> Zekka: well i started thinking down this path because i had in mind some kind of monad that would fetch and cache urls, but i wanted the computation to be pure, and have it accumulate a list of urls that will need fetching
22:21:47 <Lutin`> josiah14: Look at powerline-python
22:21:49 <joelteon> oh, that's right.
22:21:57 <Lutin`> https://github.com/carlcarl/powerline-zsh/blob/master/README.md at the bottom
22:21:59 <joelteon> The only way you can get variables from an external source is by using the 'source' primitive.
22:22:08 <Zekka> orzo: It sounds kind of like you want Writer
22:22:45 <Zekka> (probably Writer [URL])
22:23:19 <Lutin`> joelteon: Well you can set environment variables
22:23:26 <Lutin`> but those are different from shell variables
22:23:59 <josiah14> aaaahh
22:24:00 <Welkin> environment vriables are great for storing API keys
22:24:03 <Welkin> variables*
22:24:09 <Welkin> and passwords
22:24:25 <Lutin`> shell variables like PROMPT and PS1 are internal to the shell, they can't be modified by another process
22:24:33 <brrrrian> [] has kind * -> * .. and [Int] has kind * .. could ([] a) not be represented by a type variable hence why you would need to program with kinds ?
22:24:47 <Lutin`> Welkin: lol
22:25:11 <orzo> that's not quite sufficient, because whenever the computation adds a URL, it also adds a new input to the pure computation, and if we use Monad class, which URLs the ocmputation depends on can depend on the results of prior downloaded urls.  If i could chase down all code paths, i could keep a collection of all URLs that might be necessary, but I'd need access to the syntax tree of the function
22:25:17 <orzo> passed to bind rather than an opague black-box sort of function
22:25:42 <Zekka> orzo: I don't quite follow -- what do you mean by "chase down all code paths"?
22:25:58 <Zekka> If you used Writer running a code path would add all its URLs to the kept monoid
22:26:03 <Zekka> if you used State you'd have access to those URLs
22:26:48 <Lutin`> orzo: Sounds like you want the list monad
22:27:14 <Zekka> Lutin`: Oh, I just realized -- you're right, it's possible that is what he means
22:28:12 <orzo> no, i want access to the code of (a -> m b) so that I can determine all possible urls that might be used
22:28:31 <Lutin`> let me read up
22:28:36 <Zekka> How exactly is it determined what all the possible URLs are?
22:29:06 <Zekka> Is it determined on alternate code paths -- like, there's a point where you branch and pick up a bunch of URLs, and you want access to the results of both branches afterwards?
22:29:23 <Rotaerk_Web> Zekka: though... just ran into a reason where it might make sense to use an ADT for specific functions:  if your error needs to report information that is ONLY relevant in the context of that function.
22:29:30 <Zekka> I strongly suspect access to the syntax tree is not what you want
22:29:38 <orzo> um
22:29:49 <jle`> is -O2 preferred over -O3?
22:29:59 <joelteon> for what purpose
22:30:01 <Zekka> Rotaerk_Web: Yeah. You could always wrap it with a handler that matches exceptions specific to that function or otherwise rethrows as your more general type, though
22:30:13 <Rotaerk_Web> For instance, I'm writing a function that takes a list of GL shader sourcecode, and builds a program... it can fail due to shader compilation error, but I want to report the index of *which* shader failed.  this bit of info is not relevant to, say, a ShaderCompilationError coming from a function that compiles *one* shader
22:30:14 <Zekka> you could even use typeclasses to abstract around it
22:30:15 <joelteon> if we're talking compile speed, -O1 is preferred over -Ox
22:30:36 <Rotaerk_Web> hmmm
22:31:16 <Lutin`> orzo: So the idea is you'd have a function that takes a URL and gets all the URLs on that page?
22:31:22 <Lutin`> s/gets/returns
22:31:51 <enthropy> brrrrian: you can have "data Model (t :: Timing) a where", which is one less kind signature
22:32:19 <jle`> joelteon: for general compilation of scripts
22:32:42 <orzo> If I had access to all the URLs that might be necessary, i can go do that IO up front, prefetching and such.  Then run a pure computation on the result.  My thinking right now is more theoretical than practical.  I'm not looking for advice on the best way to go about caching urls, i'm asking a what-if.  Theoretically, a function is a relationship, not a black-box thunk.  Theoretically, a monad
22:32:48 <orzo> interface could do what i'm saying
22:33:45 <Zekka> So has your question moved over to "can a Haskell program inspect its own syntax tree?"
22:33:49 <joelteon> jle`: you're not likely to get much better performance out of O2 over O1
22:33:54 <joelteon> let alone O3
22:33:55 <enthropy> brrrrian: you could get rid of the Timing kind signature, if instead of "data Timing = Timing1 | Timing2", you had  data Timing1; data Timing2
22:33:57 <Zekka> Because that's pretty much the intuition behind free monads
22:34:05 <joelteon> except in some very speciic cases but I cannot remember those for the life of me
22:34:06 <orzo> what's a free monad
22:34:07 <joelteon> ask #ghc
22:34:12 <enthropy> but that's not so safe
22:34:22 <enthropy> jle`: ghc only goes up to -O2
22:34:28 <Zekka> They're generic functor-to-monad conversions that you can interpret into other monads like IO
22:34:30 <enthropy> unless things have changed recently
22:34:39 <Zekka> But they don't impose a restriction on how you interpret them, so you can interpret them more than one way
22:34:40 <Enigmagic> enthropy: not true, my ghc goes up to -O11
22:34:45 <AfC> orzo: http://www.haskellforall.com/2012/07/purify-code-using-free-monads.html
22:34:48 <Zekka> Gabriel Gonzales writes about them a lot, let me find one of his articles
22:34:49 <Zekka> oh wait
22:34:52 <joelteon> O-leven
22:34:53 <Zekka> there's an article by the guy I mentioned
22:35:04 <Enigmagic> joelteon: ;-)
22:35:09 <orzo> the article afc pasted?
22:35:13 <Zekka> Yeah
22:35:15 <Lutin`> orzo: I think the others and I may be confused on what you truely want to accomplish
22:35:54 <jle`> enthropy: really?
22:36:03 <jle`> good to know
22:36:04 <brrrrian> here is a good free monad example: http://programmers.stackexchange.com/questions/242795/what-is-the-free-monad-interpreter-pattern
22:36:22 <enthropy> jle`: it doesn't hurt to be like Enigmagic
22:36:32 <orzo> sounds interesting, thanks
22:38:57 <Zekka> orzo: I'll be back later, but free monads went through a burst of popularity recently so there's probably a lot of people here capable of explaining them
22:41:11 <twoolie> hi guys, a few months ago I saw someone post a link to a project that uses Yesod as a base, and builds a TH/YAML REST framework on top. Anyone remember what it's called?
22:41:26 <twoolie> google is not being helpful :(
22:42:23 <hunt> wtf
22:42:34 <hunt> on hackage in the time package it says UTCTime is an instance of show
22:42:43 <hunt> but in my own ghci UTCTime is only an instance of Eq and Ord
22:42:48 <hunt> i have time 1.4.2
22:43:59 <hunt> why would this happen
22:44:12 <Enigmagic> hunt: what does `:info! UTCTime` show?
22:44:43 <Enigmagic> doh
22:45:07 <hunt> doh what?
22:45:10 <Enigmagic> assuming you're on ghc 7.8.x :-)
22:45:15 <hunt> yes i am
22:45:28 <enthropy> did you hide things (the Show class) from Prelude?
22:45:52 <hunt> nope
22:45:53 <Enigmagic> :info! shows all instances, not just those that are in scope
22:45:57 <hunt> it works when i cabal repl
22:46:01 <hunt> in my sandbox
22:46:05 <hunt> but otherwise its no good
22:46:17 <path[l]> hi, can someone help me with syntax http://lpaste.net/105776. I’m trying to write an arbitrary instance for GlobPattern
22:47:09 <Enigmagic> hunt: can you paste the :info! output for UTCTiem?
22:47:16 <hunt> ah it works
22:47:25 <hunt> i was only importing Data.Time.Clock
22:47:34 <hunt> the Show instance is in Data.Time.LocalTime
22:47:39 <hunt> i imported Data.Time to solve
22:48:01 <enthropy> blame the orphans
22:48:11 <Lutin`> hunt time-1.4.2 doesn't have a Show instance
22:49:53 <Lutin`> Or maybe it does hidden somewhere
22:50:01 <path[l]> for some reason it assumes the type is [Char], but I’m returning instances of Char ...
22:51:58 <flebron> Using Rank2Types, how could I type twice, such that twice f x = f (f x), so twice head [[1]] = 1?
22:53:12 <pavonia> path[l]: Are you sure the list argument to listOf is correct?
22:53:27 <path[l]> oh I see what you mean
22:53:54 <joelteon> :t join (.)
22:53:56 <lambdabot> (c -> c) -> c -> c
22:54:13 <joelteon> :t \ f x -> f (f x)
22:54:13 <lambdabot> (t -> t) -> t -> t
22:54:51 <path[l]> thanks
22:54:54 <path[l]> that was dumb
22:55:05 <joelteon> i see your point flebron
22:55:07 <enthropy> > let twice :: (forall a. [a] -> a) -> [[a]] -> a; twice f x = f (f x) in twice head [[1]]
22:55:09 <lambdabot>  1
22:55:21 <flebron> Right, so that's the case of head. What's the general one?
22:55:21 <path[l]> pavonia:  thanks :)
22:55:24 <flebron> (Is there one?)
22:55:47 <pavonia> no problem
22:56:11 <ion> > let once :: (forall a b. a -> b) -> a -> b; once f x = f x in once head [1]
22:56:13 <lambdabot>  Couldn't match type ‘a’ with ‘[b1]’
22:56:13 <lambdabot>    ‘a’ is a rigid type variable bound by
22:56:13 <lambdabot>        a type expected by the context: a -> b1 at <interactive>:1:63
22:56:13 <lambdabot>  Expected type: a -> b1
22:56:13 <lambdabot>    Actual type: [b1] -> b1
22:56:33 <flebron> You'll be hard pressed to find a "forall a b. a -> b" that isn't unsafeCoerce :p
22:56:40 <flebron> Or undefined and its ilk
22:56:42 <ion> Just joking
22:57:43 <Lutin`> hunt: The show instance is defined in time-1.4.2:Data.Time.LocalTime.LocalTime
22:57:58 <Lutin`> Not sure if that affects your issue
22:58:02 <Lutin`> Oh derp
22:58:11 <hunt> Lutin`: lol u missed my message
22:58:14 <Lutin`> My window was scrolled up and I didn't see it
22:58:17 <hunt> Lutin`: sorry i just saw this
22:58:23 <hunt> Lutin`: couldve stopped you sooner
22:58:28 <Lutin`> np
22:58:34 <Lutin`> I need sleep
22:58:36 <Lutin`> lol
22:58:38 <Lutin`> Night guys
23:01:11 <brrrrian> is there a term for this: defining an instance of a typeclass where deeper in the implementation you call the same function you're defining
23:01:47 <enthropy> flebron: probably the "general" solution is class Apply f x y where apply :: f -> x -> y; then   twice f = apply f . apply f
23:01:59 <enthropy> which is also not very good
23:02:44 <enthropy> brrrrian: recursion?
23:02:55 <ion> Almost recursion? :-P
23:02:58 <brrrrian> e.g. instance MyTypeclass Foo where doit (Foo a b) = Bar (doit a) (doit b)
23:03:18 <brrrrian> enthropy: yeah, i guess recursion...
23:03:23 <flebron> I think it's not going to be doable within Hindley/Milner, since Rank2Types already is outside that.
23:03:53 <Enigmagic> brrrrian: look at Data.Traversable
23:06:02 <ion> I guess if you think of the type class member as a function dependent of the implicit type parameter with just multiple cases instead of multiple functions, you could call it recursion.
23:07:42 <brrrrian> ion: is that how you would describe the difference btwn 'recursion' and 'Traversable'?
23:08:04 <brrrrian> e.g. the 'data Tree a' example in Data.Traversable
23:09:30 <ion> Uh, i don’t see how “recursion” and “Traversable” are things you can compare.
23:09:37 <brrrrian> wait I dont think I understand what you said
23:10:01 <ion> The Tree example in the documentation is an example of what you asked about, yes.
23:14:28 <hunt> what does this error mean? http://lpaste.net/105777
23:15:03 <hunt> is this a TemplateHaskell thing
23:16:49 <hunt> i have 0 chacnce of debugging this on my own
23:16:55 <hunt> i dont know what this means and neither does google
23:17:08 <hunt> please someone! be my miracle
23:17:17 <hunt> once more: http://lpaste.net/105777
23:18:09 <Enigmagic> hunt: yes, it's template haskell related. https://github.com/yesodweb/shakespeare/blob/master/Text/Hamlet.hs#L264
23:18:35 <hunt> Enigmagic: how do i figure out what of the template haskell is failing?
23:19:31 <taruti> Is there a library or examples for embedding ghci/ghc-api repl into a gtk2hs gui?
23:19:33 <hunt> er, how do i provide a url renderer? would youo knkow Enigmagic
23:19:59 <Enigmagic> hunt: i don't know, i haven't used yesod in any real capacity before
23:20:22 <hunt> Enigmagic: im not using yesod, this is straight hamlet, so it shouhld be somewehere in Text.Hamlet
23:20:30 <hunt> Enigmagic: but thanks for the help
23:24:57 <Enigmagic> hunt: ok.. so
23:25:25 <hunt> Enigmagic: so... i havent figured it out yet? what do you mean?
23:25:30 <Enigmagic> shamlet specifies htmlRules, which has both the renderers set to Nothing: https://github.com/yesodweb/shakespeare/blob/master/Text/Hamlet.hs#L292
23:25:57 <hunt> Enigmagic: i dont think i mean to use URL interpolation but im not sure why its being used
23:26:48 <Enigmagic> hunt: what happens if you use hamlet instead of shamlet?
23:27:32 <hunt> Enigmagic: it begins to require a ([Char] -> [t0] -> a0)
23:27:41 <hunt> Enigmagic: i have no idea why
23:28:39 <arileo> Hi! I'm a haskell newbie. When I'm reading a haskell program, sometimes I see a lot of imports. I am wondering how I can quickly figure out what function comes from which input. Or short of that, if there is some way to read or search through the functions defined by each package on my system from a command line interface. Is this possible? Sort of like help(pkg_name) or dir(pkg_name) or pkg_name.__filename__ in python.
23:28:57 <hunt> arileo: hoogle
23:28:59 <hunt> @where hoogle
23:29:00 <lambdabot> http://haskell.org/hoogle – See also Hayoo, which searches more packages: http://holumbus.fh-wedel.de/hayoo/hayoo.html
23:29:11 <Zekka> arileo: Yeah, it sounds like you're dscribing Hoogle pretty much to a T
23:29:13 <Enigmagic> hunt: no idea either.
23:29:34 <arileo> Ah, very cool. Okay. Thanks...
23:29:50 <hunt> Enigmagic: damn... i dont know what i should do. i  think its coming from the file im trying to readm because shamletFile has no problem with other of my .hamlet templates
23:30:14 <Zekka> arileo: POssible difference is that Hoogle, unliek Python's help, isn't interactive
23:30:17 <Zekka> it's much more like dir than help
23:31:38 <Enigmagic> hunt: trim the file down and add in each potential offender?
23:32:11 <Enigmagic> it's like bisect but slower ;-)
23:32:31 <pavonia> arileo: You can also load the module into GHCi and use ":browse <module>" to list the functions and types defined in a module, or ":info <identifier>" to get information for a function/type
23:32:38 <hunt> Enigmagic:  yea i did that
23:32:48 <hunt> Enigmagic: the problem comes from using"@" and a variable inside
23:33:00 <hunt> Enigmagic: which i suppose is a call to the url interpolater
23:33:01 <arileo> Zekka: Thanks!
23:33:01 <arileo> pavonia: Ah! Awesome!
23:34:52 <arileo> Another question. In my ghci.conf file, I use `:set prompt "λ "` and `:set +m`. But during line continuation (due to the :set +m), the prompt seems to go back to its default setting. Any ideas?
23:36:24 <arileo> ... for example, this seems to happen https://gist.github.com/anonymous/0309ec45bc5286e44e07
23:37:25 <orzo> what's free versus non-free in context of free monads?
23:38:16 <kasnjtzschta> the monads
23:38:23 <orzo> no, i mean the words meanings
23:38:45 <orzo> googling "free" isn't exactly a good way to find that definition
23:39:16 <Enigmagic> orzo: have you read about free monoids?
23:39:25 <orzo> i read http://www.haskellforall.com/2012/07/purify-code-using-free-monads.html
23:39:36 <orzo> he didn't define the term free and non-free, though he used it in comments
23:39:45 <orzo> oh free monoids
23:39:48 <orzo> no, i haven't
23:40:10 <arileo> Another question: I am using the HTTP library (Network.HTTP.simpleHTTP; part of the srouce: http://hackage.haskell.org/package/HTTP-4000.2.17/docs/src/Network-Stream.html#Result). In particular, I am using the Network.HTTP.simpleHTTP function, which returns rsp :: Network.Stream.Result (Response String). I'm trying to understand: is there a great way to "cast" this type to [char]?
23:40:40 <arileo> Ah! `show` perhaps?
23:40:50 <orzo> i see what a free monoid is from wikipedia
23:41:42 <Enigmagic> orzo: the basic idea is that a free monad or monoid or whatever is that it can turn a type like 'a' into a monoid or monad.
23:42:20 <Enigmagic> orzo: a simple example of a free monoid is a list. if you start with some type, like an Integer, if you wrap it in a List you get a monoid for free.
23:42:31 <ReinH> @google free object
23:42:32 <lambdabot> http://en.wikipedia.org/wiki/Free_object
23:42:33 <lambdabot> Title: Free object - Wikipedia, the free encyclopedia
23:42:44 <pavonia> arileo: What GHC version are you using?
23:42:54 <arileo> $ ghc --version
23:42:54 <arileo> The Glorious Glasgow Haskell Compilation System, version 7.6.3
23:44:30 <pavonia> arileo: It's a bug that should be fixed in newer GHC versions
23:44:48 <pavonia> namely 7.8.1
23:44:56 <arileo> pavonia: Ah.... okay.
23:48:55 <chrisdone> yitz: i was just reading your reply that i missed http://ircbrowse.net/browse/haskell?q=yitz+chrisdone
23:49:14 <chrisdone> yitz: such strange rhetoric, very propagandaesque
23:49:44 <roelof> As a absolute beginner is it wise to learn haskell and also learn to use a test framework ?
23:50:05 <l0cust> roelof: most test frameworks require that you know a little about monads
23:50:08 <l0cust> roelof: so no
23:50:32 <l0cust> roelof: Haskell has a really nice testing library called quickcheck
23:50:47 <l0cust> roelof: instead of making you write unit tests
23:50:52 <roelof> oke, then I wait on learning HTF till I know the basic about monads ?
23:51:04 <l0cust> roelof: you just give it properties that have to hold
23:51:28 <l0cust> roelof: yes
23:51:38 <roelof> oke, I will google on quickcheck
23:51:42 <Welkin> roelof, read Learn You a Haskell
23:51:44 <l0cust> htf uses it
23:51:48 <l0cust> !where lyah
23:51:52 <roelof> 10cust thanks
23:51:52 <Welkin> @lyah
23:51:52 <lambdabot> Unknown command, try @list
23:51:56 <Welkin> @google lyah
23:51:57 <lambdabot> http://learnyouahaskell.com/
23:51:57 <lambdabot> Title: Learn You a Haskell for Great Good!
23:51:59 <l0cust> @where lyah
23:51:59 <lambdabot> http://www.learnyouahaskell.com/
23:52:04 <l0cust> there we go
23:52:13 <l0cust> it's ! in #archlinux, and @ here
23:52:16 <l0cust> I always forget
23:52:22 <roelof> Im using now programming haskell as learning book
23:52:35 <l0cust> roelof: what's your prior experience
23:52:42 <l0cust> roelof: do you know any other languages?
23:53:10 <roelof> a little ruby
23:53:15 <l0cust> okay
23:53:37 <l0cust> lyah assumes you know imperative programming (normal, non-mathy) really well
23:53:50 <l0cust> I've heard good things about programming haskell
23:53:55 <l0cust> lyah is a great book tho
23:54:01 <roelof> oke, I looked at it earlier and I miss there the exercises
23:54:13 <l0cust> hm?
23:54:15 <Welkin> there are also a lot of useful essays on haskell
23:54:30 <Welkin> http://yannesposito.com/Scratch/en/blog/Haskell-the-Hard-Way/
23:54:30 <l0cust> Welkin: don't scare him off, we haven't quite roped him in yet
23:54:41 <Welkin> that is a nice overview of the language
23:54:51 <chrisdone> yitz: you have your own specific idea about how version dependencies work by “PVP” and go on to say thinking or behaving otherwise is to be a liar. i don't really care about that as this is the internet and people say militant and mean things because they're tapping little plastic buttons and looking at a rectangular screen, but i thought you might want to know how it comes off
23:56:03 <arileo> I apologize that this a is a terribly newbie question, but what is the distinction between "=" and "<-"? And why can I do things like "let x=1" and "y<-return 1"? Which is preferable?
23:56:22 <Welkin> <- is used in do notation
23:56:31 <Zekka> arileo: Very short version -- let is an assignment and <- is sugar for >>=
23:56:38 <Zekka> Did that help or do you want the long version?
23:56:39 <chrisdone> arileo: the former is probably preferable as it states intent
23:56:49 <arileo> Oh man, haha. Long version would be great : )
23:56:58 <l0cust> arileo: you just made a terrible mistake
23:57:06 <arileo> run-oh
23:57:09 <l0cust> okay, so there are these things called monads
23:57:15 <chrisdone> x <- return 1 might imply you intend to make the calculation of '1' to be monadic at some point
23:57:15 <Zekka> Basically, when you're sequencing operations using a monadic type, you often end up dealing with a value that's wrapped in that type
23:57:31 <l0cust> arileo: how much do you know about monads
23:57:40 <Zekka> You can apply further monadic operations to values wrapped inside monads, but only using a special function called >>=
23:57:42 <arileo> Very little
23:57:45 <l0cust> okay
23:57:50 <chrisdone> then it's time to hit the book!
23:57:50 <Zekka> And <- is a way of making >>= look like an assignment
23:57:53 <Zekka> Do you want the very long version?
23:57:59 <Welkin> this is helpful
23:58:00 <Welkin> http://www.cs.nott.ac.uk/~gmh/monads
23:58:04 <l0cust> arileo: Imagine you have an unruly prisoner
23:58:09 <chrisdone> oh god
23:58:10 <chrisdone> hahaha
23:58:10 <l0cust> He's in his jail cell
23:58:13 <chrisdone> you guise stop =p
23:58:20 <arileo> I'm listening! : D
23:58:22 <l0cust> you don't want him to leave
23:58:25 <Zekka> It helps if you understand that monads are basically burritos
23:58:27 <l0cust> go out into public
23:58:34 <l0cust> Zekka: fuck off with the burritos
23:58:35 <Zekka> I think chris even did a comic on the subject
23:58:38 <chrisdone> arileo: good luck, they're about to flood you with bad analogies
23:58:46 <notdan>  hm, can someone please help me out with my ghc-mod/emacs installation?
23:58:51 <notdan> I cant get flymake to work
23:58:52 <chrisdone> l0cust: watch your language, sir!
23:58:52 <Zekka> Actually I was going to flood him with typesigs
23:58:52 <l0cust> i was about to ask what everyone's terrible monad analogy is
23:58:54 <arileo> Zekka: Why not chimichangas?!
23:59:07 <notdan> I enable flymake-mode, and run it
23:59:10 <notdan> but it doesnt show any errors
23:59:15 <Zekka> arileo: It's a old gag, monads are supposedly hard to explain and a lot of explanations start with really dumb analogies like "monads are like burritos"
23:59:15 <Welkin> "A monad is just a monoid in the class of endofunctors"
23:59:17 <l0cust> chrisdone: been watching trailer park boys all day, my apologies
23:59:25 <l0cust> arielo
23:59:25 <roelof> both thanks. I will hit the books now and try to understand haskell
23:59:29 <l0cust> arileo: there we go
23:59:37 <Zekka> Let's start, do you know what a functor is?
23:59:37 <l0cust> arileo: okay, you have your prisoner
23:59:45 <chrisdone> notdan: i don't use flymake, but i've used flycheck which worked. maybe you can try that after exhausting flymake possibilities
23:59:50 <Zekka> Or we can go with Locust's attempt at analogizing it first, although I have a feeling it won't work very well
23:59:57 <Zekka> because monads aren't really that muchc like prisoners in jail cells
