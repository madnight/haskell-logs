00:01:45 <gamegoblin> jle`: Thanks for recommending the <||> notation for my forking operator. It looks really nice.
00:01:51 <enthropy> [i| subtract [1,2,3] [10,20,30] |] would probably be   subtract [1,2,3]? [10,20,30]?
00:02:02 <Maxdamantus> No.
00:02:12 <Maxdamantus> subtract [1,2,3]? wouldn't be a function.
00:02:13 <jle`> gamegoblin: np :)
00:02:47 <Maxdamantus> it would be something like: [Int -> Int]
00:02:54 <gamegoblin> Is there a cleaner way to write “case f x of [] -> y; z -> z”
00:02:54 <enthropy> well doesn't it look better that way?
00:03:11 <gamegoblin> The z -> z is what looks weird to me. But I don’t want to do _ -> f x since that would recompute f x?
00:03:17 <Maxdamantus> Yes, but illogical.
00:03:28 <Maxdamantus> That's why QQ has a special encapsulating syntax for it.
00:04:41 <jle`> gamegoblin: you could bind f x somewhere else.  but i don't think that version is too bad
00:05:04 <gamegoblin> jle`: yeah I could do it in a let, but that looks equally funny to me. Hrmm.
00:05:29 <jle`> hm
00:05:48 <Tordek> I know this is kind of the same question of "what are monads for?", but... what are comonads for?... i.e., in what scenario do they make things easier to build/understand?
00:06:31 <enthropy>  [i| f (pure w) x y (pure z) |]  would be translated to   f w x? y? z
00:06:55 <edwardk> Tordek: i use them for lots of little things. https://www.fpcomplete.com/user/edwardk/cellular-automata/part-1 https://www.fpcomplete.com/user/edwardk/cellular-automata/part-2 https://www.fpcomplete.com/user/edwardk/conquering-folds
00:06:58 <enthropy> dunno what is illogical about considering the whole expression when doing the translation
00:07:14 <edwardk> https://www.fpcomplete.com/user/edwardk/parallel-crc
00:07:46 <Maxdamantus> enthropy: `a b c` isn't meaningfully a "whole expression"
00:07:58 <Maxdamantus> enthropy: it might be part of `a b c d`
00:08:12 <Tordek> edwardk: awesome, thanks!
00:08:16 <edwardk> tordek: lenses are comonad coalgebras for a particular comonad, traversals are comonad coalgbras of a particular comonad that turns out to be useful for implementing the harder kinds of combinators using them we use in lens
00:08:38 <Maxdamantus> (pure a) <*> b <*> c
00:08:42 <augur> Maxdamantus: sure its a whole expression!
00:08:47 <Maxdamantus> (pure ((pure a) <*> b <*> c) <*> d)
00:08:48 <augur> Maxdamantus: just of a different type :)
00:08:52 <jle`> enthropy: fromMaybe y . liftA2 (<$) id listToMaybe $ f x
00:08:54 * hackagebot statistics 0.11.0.2 - A library of statistical types, data, and functions  http://hackage.haskell.org/package/statistics-0.11.0.2 (BryanOSullivan)
00:08:54 * hackagebot statistics 0.11.0.3 - A library of statistical types, data, and functions  http://hackage.haskell.org/package/statistics-0.11.0.3 (BryanOSullivan)
00:09:13 <Maxdamantus> You need to reason about some specific entire application chain.
00:09:14 <jle`> enthropy: or fromMaybe y . ap (<$) listToMaybe $ f x :)
00:09:16 <Maxdamantus> not part of it.
00:09:38 <edwardk> Tordek: in general you won't structure your whole program around a comonad, but you might use lots of little comonadic things to hold onto context or extra information
00:09:43 <enthropy> jle`: is that gamegoblin problem?
00:09:58 <jle`> enthropy: oh sorry, gamegoblin
00:10:02 <jle`> not sure why i typed your name
00:10:32 <gamegoblin> I am confused now
00:10:45 <jle`> your case f x of [] -> y; z -> z
00:10:58 <gamegoblin> Oh yes, what about it?
00:11:03 <jle`> fromMaybe y . ap (<$) listToMaybe $ f x
00:11:10 <gamegoblin> ohh
00:11:11 <jle`> don't do that in real code though >_>
00:11:21 <gamegoblin> Yeah that is.. no thanks
00:11:36 <jle`> actually the version with liftA2 isn't too not-understandable
00:11:56 <jle`> :t liftA2 (<$) id listToMaybe
00:11:57 <lambdabot> [b] -> Maybe [b]
00:13:08 <gamegoblin> Hrm… I think I’ll leave it as is for now. Applicatives Functors scare me. I can handle Alternative, but I have never been able to glance at Applicatives and immediately see what they mean.
00:13:46 <jle`> (liftA2 f g h) x  == f (g x) (h x)
00:13:49 * hackagebot vector 0.10.9.3 - Efficient Arrays  http://hackage.haskell.org/package/vector-0.10.9.3 (BryanOSullivan)
00:14:07 <jle`> > liftA2 (,) (*2) (+3) 9
00:14:09 <lambdabot>  (18,12)
00:14:39 <Maxdamantus> enthropy: I guess a simple way to demonstrate the difference would be: [i| a b c|] vs. [i| (a b) c]
00:14:44 <jle`> > let f = (,) <$> (*2) <*> (+3) in f 9
00:14:45 <lambdabot>  (18,12)
00:14:49 <Maxdamantus> er, missed a | at the end.
00:14:55 <Maxdamantus> Those should be different anyway.
00:15:22 <Maxdamantus> The first one is: `pure a <*> b <*> c` while the second is `pure (a b) <*> c`
00:15:34 <Maxdamantus> Presumably .. I haven't actually tried running the QQ thing.
00:15:45 <enthropy> it could go either way I guess
00:15:58 <enthropy> probably it does the "right" thing
00:16:08 <Maxdamantus> I gave two expressions.
00:16:16 <Maxdamantus> and the logical desugarings of both.
00:16:58 <z0d> hello
00:17:02 <jle`> hi z0d
00:17:04 <p0a> Hello this is my code using Parsec: http://lpaste.net/105006  I get an error: Not in scope: type constructor or class `Parser'. I follow this tutorial, http://legacy.cs.uu.nl/daan/download/parsec/parsec.html
00:18:31 <enthropy> Maxdamantus: I mean it would be reasonable for it to have a pass to convert (AppE (ParensE (AppE (VarE a) (VarE b))) (VarE c)) to (AppE (AppE (VarE a) (VarE b)) (VarE c))
00:18:57 <enthropy> but it doesn't according to the source code http://hackage.haskell.org/package/applicative-quoters-0.1.0.8/docs/src/Control-Applicative-QQ-Idiom.html#i
00:19:26 <gamegoblin> p0a: That’s a very old tutorial (2001). In general, though, you can leave off Parsec type signatures (at least until you get the hang of it) and let the compiler do the work for you
00:20:32 <jle`> 2001 was 13 years ago, wow
00:21:44 <gamegoblin> That’s like 1000 years in internet time
00:21:45 <Maxdamantus> 10 months earlier and it would've been the previous millenium.
00:24:01 <p0a> I think write yourself a Scheme is a good tutorial
00:24:17 <p0a> I will follow this instead. Thanks for noting about 2001
00:33:46 <jle`> so if you have i = iso to from
00:33:48 <jle`> view i = to
00:33:56 <jle`> what is the function that yields from?
00:34:17 <tdammers> write yourself a scheme is awesome
00:34:50 <tdammers> not for everyone, but if you're in the target audience, it's great
00:37:15 <pingu> I'd personally like this list: http://hackage.haskell.org/package/base-4.7.0.0/docs/System-IO-Error.html
00:37:32 <pingu> To include a timeout IOErrorType
00:37:46 <pingu> am I looking in the wrong place?
00:38:08 <pingu> I just want an Exception e => e representing a generic timeout
00:39:05 <pingu> oh look, there is one. TimeExpired, it just isn't documented.
00:45:20 <mietek> Is it possible to load an additional .ghci file in GHCi at runtime?
00:51:43 <welltyped> There are a lot of nice resources on types and type systems like TAPL but is there any introductory material on type checking?
00:53:19 <lieven_> welltyped: something like http://web.cecs.pdx.edu/~mpj/thih/TypingHaskellInHaskell.html ?
00:53:50 <welltyped> Ah I'd heard of that but haven't looked into that in detail
00:54:26 <welltyped> I was thinking along the lines of books or teaching material, since I don't think TAPL covers type checking at all (or not much at least)?
00:54:56 <welltyped> But I guess I could just read papers on HM and bidirectional type checking, and Typing Haskell in Haskell
00:55:41 <mietek> welltyped: have you seen https://github.com/tomprimozic/type-systems ?
00:56:02 <welltyped> I have not! Thanks
00:56:20 <mietek> I have it on my list of things to work through whenever I have some vacation.
00:59:06 <welltyped> Most places just reference papers, I guess that's the best place to learn
01:02:47 <Kaidelong> oh I should read that
01:03:10 <Kaidelong> I'm hopefully headed to Maseeh College pretty soon so with luck I'll get a chance to work with Mark Jones
01:10:09 <snyp> What is recommended tabs or spaces, for haskell code?
01:10:38 <Iceland_jack> snyp: spaces
01:10:40 <tdammers> snyp: spaces
01:10:44 <snyp> ok
01:10:46 <StoneCypher4k> ascii VTB
01:11:03 <Iceland_jack> I use '␣'
01:11:40 <tdammers> I use &nbsp;
01:11:57 <StoneCypher4k> ebcdic record select 2
01:12:08 <StoneCypher4k> big-endian
01:12:41 <jle`> snyp: spaces
01:16:51 <frerich> Hm, "Swift is the result of the latest research on programming languages" does trigger my curiosity.
01:17:08 <jle`> frerich: read through the book, it's a nice exposition
01:17:21 <jle`> borrows a lot from ideas incubated in haskell
01:18:00 <tdammers> jle`: don't they all?
01:19:02 <jle`> tdammers: :) unfortunately, nto enough
01:19:04 <jle`> do
01:19:40 <jle`> i think for a lot of programmers this might be their first time seeing type inference and ADT's
01:19:47 <Enigmagic> Go takes ideas from Data.Int and Data.Word
01:20:06 <welltyped> Enigmagic: which ideas?
01:20:17 <Enigmagic> addition and subtraction? :_)
01:20:22 <jhbecares> when can I omit parameters in functions? suppose I have f x y z = whatever and then g x y z = f (x+1) y z, and g'' x = f (x+1). how can I tell that g and g'' are exactly the same and well constructed if I don't have all the parameters?
01:20:27 <welltyped> ..I see
01:21:03 <opqdonut> jhbecares: look at the types
01:21:16 <Iceland_jack> Yes basically, look at the types
01:21:29 <jhbecares> but if I have to infere the type myself...?
01:21:45 <opqdonut> since f :: Int -> a -> b we have f (x+1) :: a -> b, and thus g :: Int -> a -> b
01:21:52 <opqdonut> jhbecares: you can ask ghci, for instance
01:21:54 <Iceland_jack> (they're not _exactly_ the same in terms of efficiency though)
01:22:12 <opqdonut> you need to know the type of f anyway if you're invoking int
01:22:23 <jhbecares> Oh Iceland_jack which one would be more efficient then?
01:22:54 <Iceland_jack> jhbecares: depends on how you plan on invoking it, it's not super important unless you're doing some performance sensitive stuff
01:23:40 <jhbecares> ok thank you both! Iceland_jack opqdonut
01:23:51 <Iceland_jack> GHC basically inlines functions when 'definition' is fully applied
01:24:44 <Iceland_jack> so you can write the same function as
01:24:44 <Iceland_jack>     f     = g
01:24:44 <Iceland_jack>     f x   = g x
01:24:44 <Iceland_jack>     f x y = g x y
01:24:47 <Iceland_jack>     f = \x y -> g x y…
01:25:07 <jhbecares> even if I have like... 10 parameters?
01:25:20 <Iceland_jack> jhbecares: What do you mean? If you have 10 parameters you're doing something wrong anyway
01:25:27 <jhbecares> yeah I know
01:25:49 <jhbecares> I mean you can just omit it if you have it both sides?
01:25:55 <Iceland_jack> yeah basically
01:26:00 <jhbecares> I see
01:26:37 <Iceland_jack> If you have addition (+) and want to rename it as 'plus' you can do any of
01:26:38 <Iceland_jack>     plus     = (+)
01:26:38 <Iceland_jack>     plus a   = (a +)
01:26:38 <Iceland_jack>     plus a b = a + b
01:28:08 <Iceland_jack> You can read more about the inlining here https://www.haskell.org/ghc/docs/latest/html/users_guide/pragmas.html
01:28:15 <Iceland_jack> under section 7.20.6
01:28:37 <jhbecares> ok thanks a lot
01:28:41 <Iceland_jack> if you're interested, it's not necessary by any means
01:35:02 <jaj> with FFI, can peek into a struct that is returned onto the stack by a C function (i.e. it is not a pointer)
01:38:47 <merijn> jaj: No
01:39:02 <merijn> At least, I haven't found a way :)
01:41:08 <jaj> merijn: thanks :)
01:44:10 <merijn> jaj: So I would just copy the stack result to the heap and then pass a pointer to that to the FFI
01:44:33 <jaj> merijn: yes that's what I was about to do
01:45:01 <piezoid> hi
01:45:06 <piezoid> basic lenses question : how do i define a lens (prism ?) for a Maybe fields ?
01:45:19 <piezoid> myFieldL._Just is close but don't set the field if it's Nothing
01:46:13 <athan_> piezoid: Could you always return a Just on the setter?
01:47:52 <piezoid> i could, but i was hopping to find something easier to use, I've a lot of record deeply nested, with some of them optional
01:48:37 <athan_> Is the container a collection? Maybe you could remove entries that are Nothings?
01:48:43 <piezoid> it's the result of an xml parse, you can imagine how messy it is...
01:49:06 <athan_> I would definitely reduce it into a flat tree
01:49:13 <athan_> that you can (basically) jquery upon
01:49:35 <athan_> so you could fold across it and just construct a rose tree
01:49:49 <athan_> piezoid: hxt?
01:50:26 <piezoid> xml-conduit, i need a streaming parse, the file is huge
01:50:51 <athan_> hmm
01:51:10 <piezoid> I can flatten the tree with empty Texts istead of Nothings
01:51:50 <piezoid> preview (myMabeTextField._Just) already return ""
01:53:34 <athan_> piezoid: So, the Maybe wraps up each node?
01:54:59 <piezoid> athan_: no the tree have fixed structure with some recuring optional subtree (like name/description pairs)
01:55:58 <supki> > (Nothing, 2) & _1 ?~ 1
01:55:59 <athan_> did you write the parser?
01:55:59 <lambdabot>  (Just 1,2)
01:56:26 <athan_> supki: To the rescue!
01:56:31 <piezoid> athan_: something like <description><name>TheName</name><desc>TheDesc</desc></description> can be found almost anywhere
01:56:48 <piezoid> athan_: I already write some parts of it
01:56:56 <supki> > (Just 1, 2) & _1.non 0 -~ 1
01:56:57 <lambdabot>  (Nothing,2)
01:57:00 <supki> > (Just 1, 2) & _1.non 0 +~ 1
01:57:02 <lambdabot>  (Just 2,2)
01:57:14 <crazydave> is there a cabal room for cabal questions? Or perhaps just a place to yell/type in all caps about dependencies?
01:58:55 <alpounet> crazydave: here is fine
01:59:10 <alpounet> crazydave: #hackage too
01:59:17 <lwm> I think you have #cabal as well
01:59:20 <augur> :t non
01:59:21 <lambdabot> (Profunctor p, Functor f, Eq a) => a -> p a (f a) -> p (Maybe a) (f (Maybe a))
01:59:40 <augur> @src non
01:59:41 <lambdabot> Source not found. My pet ferret can type better than you!
01:59:43 <augur> blegh
01:59:58 <merijn> To be fair, most "cabal issues" nowadays are not really cabal issues but "my complex dependency tree was broken by an upstream maintainer and now cabal is lost"
02:00:24 <augur> :t Just 1 & _1.non 0
02:00:26 <lambdabot>     Couldn't match type ‘(->) a0’ with ‘Maybe’
02:00:26 <lambdabot>     Expected type: Maybe (f a0) -> Maybe a0 -> f (Maybe a0)
02:00:26 <lambdabot>       Actual type: (a0 -> f a0) -> Maybe a0 -> f (Maybe a0)
02:00:26 <piezoid> crazydave: just a guess: did you tried --allow-newer ? it helped me a lot with the dependency problems related transformer on 7.8 install
02:00:32 <augur> whoops
02:00:36 <augur> :t Just 1 & non 0
02:00:37 <lambdabot>     Couldn't match type ‘p a’ with ‘Maybe’
02:00:37 <lambdabot>     Expected type: Maybe (f a) -> p (Maybe a) (f (Maybe a))
02:00:37 <lambdabot>       Actual type: p a (f a) -> p (Maybe a) (f (Maybe a))
02:00:42 <supki> augur: non x is an isomorphism between a and (Maybe a sans x)
02:00:49 <augur> supki: ?
02:00:50 <mr-> Also, these dependency trees are staggeringly complex in the sense that they don't even fit in memory..
02:00:54 <crazydave> no I tried install yesod-platform yesod-bin and it barfed
02:00:55 <merijn> piezoid: That's a rather dangerously broad solution to try if you dunno what it does
02:01:21 <merijn> Ah, yeah, yesod's dependencies are particularly hairy
02:01:28 <piezoid> merjin: ok --allow-new --dry-run first then :)
02:01:34 <merijn> What did it barf on?
02:01:53 <crazydave> unknown package ghc ? what?
02:02:01 <piezoid> the schaffold template recommend to use per-project sandboxes
02:02:25 <piezoid> scaffold*
02:02:37 <crazydave> next goal: ghc (dependency of yesod-bin-1.2.9.4)
02:02:38 <crazydave> fail (unknown package: ghc)
02:04:03 * hackagebot TCache 0.12.0 - A Transactional cache with user-defined persistence  http://hackage.haskell.org/package/TCache-0.12.0 (AlbertoCorona)
02:04:48 <merijn> crazydave: Which GHC version?
02:05:29 <crazydave> I'm on 7.6.2 as that is the haskell platform on OpenSuse
02:06:15 <_0xAX> Hello All
02:06:36 <Taneb> Hi, _0xAX
02:06:48 <merijn> I suspect "Yet Another Linux Package Manager Bollocksing Up Cabal's Package Database", but I'm not sure
02:07:50 <_0xAX> Has haddock API? For example if i have .hs file with some haddock markup, can i access this markup in runtime? I mean get content of this markup, midule name and etc...
02:08:40 <crazydave> merijn: there's an acronym for everything these days.  it is installing yesod-platform so I'll see how that goes and maybe it will do yesod-bin pain free after rather than at the same time.
02:09:33 <merijn> _0xAX: Haddock markup is just comments, so no
02:09:51 <merijn> _0xAX: What would you do with that?
02:10:17 <crazydave> might be useful in ghci for loaded modules
02:11:00 <_0xAX> merijn: nothing now, just a qestion, i thought maybe in future, anyway thank you for reply
02:11:03 <merijn> You could try accessing the locally installed docs based on fully qualified name from GHCI
02:15:48 <edwardk> piezoid: you use 'non' when you need to walk through nested optional fields
02:16:15 <edwardk> > (1,Nothing)^._2.non 0 +~ 1
02:16:17 <lambdabot>  Could not deduce (GHC.Num.Num
02:16:17 <lambdabot>                      (Control.Lens.Setter.ASetter s t a0 a0))
02:16:17 <lambdabot>    arising from the ambiguity check for ‘e_11201’
02:16:17 <lambdabot>  from the context (GHC.Num.Num
02:16:17 <lambdabot>                      (Control.Lens.Setter.ASetter s t a a),
02:16:19 <edwardk> > (1,Nothing) & _2.non 0 +~ 1
02:16:21 <lambdabot>  (1,Just 1)
02:16:31 <edwardk> > (1,Just 4) & _2.non 0 -~ 4
02:16:33 <lambdabot>  (1,Nothing)
02:17:06 <piezoid> edwardk: thanks :)
02:17:09 <edwardk> piezoid: so if you need to go through several of them fooField.non whatevervalueit'llneverhave.barField.non whatever, etc.
02:19:05 * hackagebot vector 0.10.10.0 - Efficient Arrays  http://hackage.haskell.org/package/vector-0.10.10.0 (HerbertValerioRiedel)
02:23:50 <augur> edwardk: i dont understand how that second non example works
02:24:03 <augur> > (1,Just 4) & _2.non 0 -~ 4
02:24:05 <lambdabot>  (1,Nothing)
02:24:09 <augur> > (1,Just 4) & _2.non 0 -~ 3
02:24:11 <lambdabot>  (1,Just 1)
02:24:23 <augur> > (1,Just 4) & _2 -~ 3
02:24:25 <lambdabot>  No instance for (GHC.Show.Show a0)
02:24:25 <lambdabot>    arising from a use of ‘M703160442667774791329717.show_M7031604426677747913...
02:24:25 <lambdabot>  The type variable ‘a0’ is ambiguous
02:24:25 <lambdabot>  Note: there are several potential instances:
02:24:25 <lambdabot>    instance [safe] GHC.Show.Show
02:24:35 <augur> whoops, shouldve seen that coming
02:24:45 <augur> > (1,Just 4) & _2.non 3 -~ 1
02:24:47 <lambdabot>  (1,Nothing)
02:24:49 <augur> > (1,Just 4) & _2.non 3 -~ 2
02:24:51 <lambdabot>  (1,Just 2)
02:24:56 <augur> how weird
02:25:30 <augur> i dont like that behavior at all
02:27:30 <piezoid> augur: 'non v' check with Eq that the value is /= v : 'you treat the domain as being Maybe (a sans v).'
02:27:37 <sgronblo> is that perl code or? :)
02:27:52 <augur> piezoid: i have no idea what that means
02:29:34 <piezoid> augur: when you set a value through 'non v', the value v is assumed equivalent (and set as) to Nothing
02:30:08 <augur> piezoid: i dont see how that connects up with the behavior
02:31:24 <augur> piezoid: i mean, it's treating it as nothing only after the change? thats bizare. i dont get what the meaning of non x is
02:31:40 <augur> > (1,Just 4) & _2.non 4 +~ 3
02:31:42 <lambdabot>  (1,Just 7)
02:32:09 <augur> and it's not checking it before hand. its only somehow concerned with the value after the change
02:33:57 <piezoid> 'non v' access the value saying that a value should be stored as Nothing if equal to v or Just theValue otherwise
02:34:08 <Tordek> I'm trying to run a program, but I keep getting "site: Prelude.chr: bad argument: 3678336"
02:34:29 <shachaf> It sounds like there's a problem with the program.
02:34:35 <merijn> Tordek: It means your passing a bad argument to chr?
02:34:43 <Tordek> but it was working literally 10 seconds ago
02:34:43 <piezoid> it cannot check before hand because the resuld would be partial if it rejected Just 4
02:34:48 <augur> piezoid: thats just super weird for me. what is the definition of non?
02:34:52 <augur> @hoogle non
02:34:54 <lambdabot> Control.Exception.Base nonExhaustiveGuardsError :: Addr# -> a
02:34:54 <lambdabot> Control.Exception.Base nonTermination :: SomeException
02:34:54 <lambdabot> package non-empty
02:34:54 <Tordek> all I did was update the... thingie
02:34:58 <Tordek> tha package, hakyll
02:35:07 <piezoid> > (1, Nothing) & _2.non 4 +~ 3
02:35:09 <lambdabot>  (1,Just 7)
02:35:18 <merijn> > fromEnum (maxBound :: Char) :: Int
02:35:20 <lambdabot>  1114111
02:35:37 <augur> piezoid: ok wow i dont even know what that means..
02:35:48 <augur> lens is the weirdest library ive ever encountered
02:35:50 <shachaf> I recommend applying the usual debugging procedure until you figure out what's wrong.
02:36:07 <shachaf> Hard to say more with what we know.
02:36:18 <Tordek> Google says it's probably a .hi whose ABI doesn't match, but I reinstalled everything... xmonads works, tho ;[
02:37:12 <Tordek> ah, it was a messy cache folder; sorry to disturb
02:37:29 <piezoid> augur: I guess, it can be defined with iso, (==) and maybe
02:37:46 <augur> piezoid: ill take your word for it
02:37:46 <edwardk> augur: non (x :: a) is the isomorphsm between Maybe (a except for x) and a
02:37:56 <augur> edwardk: people keep saying that
02:38:25 <augur> edwardk: and i neither know quite what is meant, nor how the translates into the whacky behavior that it produces
02:38:42 <edwardk> > M.fromList [(1,M.fromList [(2,3)])] & at 1 . non mempty . at 3 +~ 1
02:38:44 <lambdabot>  No instance for (GHC.Show.Show a0)
02:38:44 <lambdabot>    arising from a use of ‘M741938956307243102029988.show_M7419389563072431020...
02:38:44 <lambdabot>  The type variable ‘a0’ is ambiguous
02:38:44 <lambdabot>  Note: there are several potential instances:
02:38:44 <lambdabot>    instance [safe] GHC.Show.Show
02:38:48 <edwardk> > M.fromList [(1,M.fromList [(2,3)])] & at 1 . non mempty . at 3.non 0 +~ 1
02:38:50 <lambdabot>  fromList [(1,fromList [(2,3),(3,1)])]
02:38:59 <edwardk> > M.fromList [(1,M.fromList [(2,3)])] & at 1 . non mempty . at 2.non 0 -~ 3
02:39:01 <lambdabot>  fromList []
02:43:27 <piezoid> augur: non v = iso (fromMaybe v) (\x -> if x == v then Nothing else Just v)
02:44:11 <augur> :t iso
02:44:13 <lambdabot> (Profunctor p, Functor f) => (s -> a) -> (b -> t) -> p a (f b) -> p s (f t)
02:44:31 <augur> oy gevalt
02:44:49 <augur> @src fromMaybe
02:44:49 <lambdabot> fromMaybe d x = case x of {Nothing -> d;Just v  -> v}
02:45:09 <piezoid> well the Iso type is not helping...
02:45:22 <augur> no i get the type, its just hard to put it into context
03:04:02 <JagaJaga> Guys! Do smone know library with a function which result is a string naming current kb layout? :)
03:05:48 <welltyped> JagaJaga: You can always use 'readProcess' from System.Process for that
03:07:56 <welltyped> it's quick and easy if you need some information that utilies provide
03:07:57 <welltyped>     ghci> readProcess "uname" [] ""
03:07:57 <welltyped>     "Linux\n"
03:14:11 <JagaJaga> welltyped: yeah, sure, but it's not a nice way :)
03:14:52 <jmcarthur> what would be an example of a "nice" way?
03:15:21 <welltyped> There's nothing inherently un-nice about using command-line utilities
03:16:03 <welltyped> but if you can find it in a library then that's fine
03:17:52 <JagaJaga> welltyped: yeah, you are right. In my opinion - nice way is to use xlib... Well, gonna continue my search! thx anyway
03:18:32 <welltyped> JagaJaga: I mean you should definitely use 'getDirectoryContents' rather than 'ls' :)
03:19:07 <nclarke> JagaJaga: xlib only gives you the X kb layout
03:26:45 <bitemyapp> welltyped: don't think I've seen a corporate entity help somebody in IRC before.
03:27:23 <welltyped> Yes I should pick a different nick
03:27:40 <welltyped> Was about to leave anyway
03:28:52 <Iceland_jack> jin_jin: (You're here!)
03:33:16 <JagaJaga> nclarke: that's what i need
03:33:36 <bitemyapp> welltyped: who are you?
03:33:42 <bitemyapp> Iceland_jack: you're here!
03:34:33 <welltyped> bitemyapp: I'm actually Iceland_jack :) using a different computer
03:34:46 <bitemyapp> welltyped: that is hella confusing. cheers :)
03:34:51 <welltyped> wanted to ask some questions and ended up chatting as two users
03:35:00 <Iceland_jack> there we go…
03:35:21 <bitemyapp> cust.tele2.se ? The Iceland is a lie!
03:35:41 <Iceland_jack> Real Icelanders live in Sweden
03:39:02 <dottedmag> Iceland_jack: do you use your right to talk Icelandic to Swedish authorities?
03:39:12 <dottedmag> But that's offtopic
03:40:44 <sgronblo> just add -ur to the end of all the words, easy
03:41:13 <merijn> So Swift is essentially OCaml/F# for iOS?
03:41:22 <Iceland_jack> dottedmag: Is that a right? I usually remove the -urs
03:42:08 <bitemyapp> merijn: calling it equivalent to OCaml is an insult to OCaml.
03:42:13 <bitemyapp> and I *don't* like OCaml.
03:42:29 <dottedmag> Iceland_jack: there is something called Nordic Language Convention.
03:42:44 <sgronblo> i thougth swift seemed pretty awesome for a mainstream language
03:42:58 <nclarke> Sounds like it's similar to F# but with C-like syntax
03:43:03 <nclarke> And new stupid names for everything
03:43:18 <merijn> Well, F# itself is already pretty similar to OCaml
03:43:18 <bitemyapp> sgronblo: I'm getting ready to put up public bounties for corporate compiler hackers to claim if they read a fucking white paper.
03:43:31 <Iceland_jack> dottedmag: I might if I want to be a nuisance
03:44:14 <sgronblo> i was trying to find out who was behind swift, but couldnt
03:44:16 <dottedmag> Iceland_jack: :) I see. I was hard enough to learn Norwegian. And now all those Swedes talk Swedish here!
03:44:22 <dottedmag> *It was
03:44:31 <nclarke> merijn: But without the module system, higher-rank types etc. Which sounds pretty similar to this Swift thing
03:44:46 <bitemyapp> nclarke: buh-buh-buh muh type providurs
03:45:33 * nclarke goes to look up type providers
03:45:44 <nclarke> (I have heard the term, but never looked into it)
03:46:22 <bitemyapp> nclarke: your database state now decides if your build fails or not :P
03:46:30 <bitemyapp> nclarke: imagine template haskell that talked to your database.
03:46:35 <nclarke> Huh. So basically dependently-typed functors? (In the sense of an OCaml functor)
03:47:13 <bitemyapp> nclarke: ...dependently typed?
03:47:31 <raichoo> uh uh uh. Someone said "dependent types" \o/
03:47:51 <bitemyapp> raichoo: are these dependent types? http://msdn.microsoft.com/en-us/library/hh361033.aspx
03:47:56 <bitemyapp> my inclination is "no"
03:48:03 <bitemyapp> it looks like a scaffolding mechanism.
03:48:20 <bitemyapp> tempted to write something evil in Haskell just to be an arse.
03:48:33 <nclarke> Sounded like the module implementation can depend on values, but I may have it wrong
03:48:49 <merijn> hmm
03:48:57 <merijn> Optional looks strictly worse than Maybe :\
03:49:02 <bitemyapp> merijn: yes.
03:49:32 <bitemyapp> merijn: 'structure preserving map' not a thing, apparently.
03:49:41 <raichoo> bitemyapp: I'd vote "no" on these as well. But I guess it's a matter of how you cog your head.
03:50:27 <bitemyapp> nclarke: I wasn't aware F# had modularity at all.
03:51:46 <nclarke> bitemyapp: Neither was I, but this sounded like it to me. A type provider sounded like a module implementation, something using a type provider sounded like a functor
03:52:25 <bitemyapp> nclarke: all that aside, I just have a really hard time taking a build that depends on database state seriously.
03:52:54 <bitemyapp> your type information and buildability are bound up in hidden, out-of-band mutable state.
03:53:39 <snyp> http://ideone.com/ePhK07
03:53:42 <snyp> whats wrong?
03:54:20 <frerich> snyp: Plain functions may not start with an uppercase letter.
03:54:27 <nclarke> Does it actually access the DB during build, then?
03:54:34 <frerich> snyp: Or rather, plain variables such as functions
03:54:41 <snyp> oh
03:54:49 <bitemyapp> nclarke: why else would it need the db conn string?
03:54:57 <snyp> (and yeah i should remove the ',' before 9)
03:55:28 <nclarke> I'd assumed it might be some kind of schema identifier.
03:55:32 <bitemyapp> snyp: you can't putStrLn a character.
03:55:40 <alpounet> you can putChar it
03:55:44 <alpounet> I think
03:55:53 <bitemyapp> er sorry
03:55:53 <alpounet> @hoogle putChar
03:55:54 <lambdabot> Prelude putChar :: Char -> IO ()
03:55:54 <lambdabot> System.IO putChar :: Char -> IO ()
03:55:54 <lambdabot> System.IO hPutChar :: Handle -> Char -> IO ()
03:55:55 <bitemyapp> I said that wrong
03:55:56 <bitemyapp> alpounet: no
03:55:58 <bitemyapp> I said it wrong
03:56:04 <bitemyapp> alpounet: you can't putStrLn an Integer
03:56:08 <alpounet> ah
03:56:10 <bitemyapp> snyp: ^^
03:56:13 <nclarke> But I see. Interesting, but yes, as you say, slightly scary
03:56:26 <bitemyapp> snyp: if you're not show'ing the data yourself or have a string already, just use print. It uses the show typeclass for you.
03:57:01 <bitemyapp> nclarke: it's a mad scientist experiment I'd like to see done with Persistent in Haskell via TH or something, but the idea of using it as a common mechanism for dealing with db abstractions is nuts to me.
03:57:18 <bitemyapp> nclarke: I want code defining my db schema as a sanity check *against* the state which I do *not* trust as a source of truth.
03:57:30 <bitemyapp> maybe .NET companies have DBAs that are more competent than their coders?
03:58:26 <Philonous> Wait what, they actually query the DB during build? O_o
04:00:16 <snyp> bitemyapp, i see
04:01:14 <bitemyapp> > putStrLn 10
04:01:15 <lambdabot>  No instance for (GHC.Num.Num GHC.Base.String)
04:01:15 <lambdabot>    arising from the literal ‘10’
04:01:17 <bitemyapp> > print 10
04:01:19 <lambdabot>  <IO ()>
04:01:22 <bitemyapp> ...
04:01:28 <bitemyapp> you get the idea.
04:01:51 <Philonous> instance Num String where fromInteger = show
04:02:29 <bitemyapp> Philonous:  >:[
04:03:47 <Iceland_jack> Philonous: that's silly, obviously you should define Num a => IsString a and use overloaded strings
04:04:17 * hackagebot shellmate 0.1.6 - Simple interface for shell scripting in Haskell.  http://hackage.haskell.org/package/shellmate-0.1.6 (AntonEkblad)
04:04:27 <Philonous> Iceland_jack, Yeah, except that won't work because of instance overlap.
04:04:43 <Iceland_jack> Undecidable~
04:05:15 <Philonous> No, instances aren't merely undecidable but inconsistent.
04:05:27 <Philonous> these instances*
04:05:30 <Iceland_jack> ah right
04:05:57 <Philonous> (Undecidable is when the instance head isn't larger than the body, AFAIK)
04:06:11 <Philonous> So ghc can't guarantee that type checking terminates
04:06:50 <Philonous> Oh, actually, this is the case here. Never mind.
04:10:41 <bitemyapp> raichoo: http://itu.dk/people/drc/pubs/dependent-type-providers.pdf
04:11:07 <raichoo> bitemyapp: I know that paper, I was there when david started the project :P
04:11:35 <snyp> is there a head for tuples?
04:11:57 <bitemyapp> raichoo: have a recommended set theory book?
04:12:47 <raichoo> bitemyapp: I'm not that much into set theory, more into type theory. There are some great lectures by bob harper on the net.
04:13:21 <raichoo> bitemyapp: There is also "Type Theory and Functional Programming" which I can highly recommend.
04:14:09 <haasn> snyp: what would it do?
04:14:26 <bitemyapp> raichoo: hum. I've been liking Harper's PFPL but felt like I needed to backtrack and learn some set theory - I don't know any math.
04:15:22 <raichoo> bitemyapp: Steve Awodey's "Category Theory" is also a great book. If you want to have something more abstract.
04:15:41 <snyp> haasn, head (1, 2) = 1
04:16:03 <mr-> :t fst
04:16:04 <lambdabot> (a, b) -> a
04:16:09 <snyp> o
04:16:51 <bitemyapp> raichoo: thanks for the suggestions.
04:17:12 <raichoo> bitemyapp: Dunno if that helps. I sure hope it does ^^
04:17:25 <raichoo> bitemyapp: Where are you located at anyway?
04:21:04 <bitemyapp> raichoo: Texas, I've been awake all night.
04:22:16 <raichoo> bitemyapp: oh boy ^^. Ok so the chances of hanging around dropped drastically. ^^
04:22:49 <bitemyapp> raichoo: sorry I'm a little blinkered - hanging around?
04:23:30 <Yuu_chan> bitemyapp: are you the author of Bloodhound?
04:23:31 <raichoo> raichoo: arg, hanging out ^^ Chatting over a cup of tea/coffee/whatever.
04:23:45 <bitemyapp> Yuu_chan: yis
04:23:55 <bitemyapp> Yuu_chan: please for the love of god, tell me you have a bug report. Something.
04:24:22 * hackagebot influxdb 0.3.0 - Haskell client library for InfluxDB  http://hackage.haskell.org/package/influxdb-0.3.0 (MitsutoshiAoe)
04:24:31 <Yuu_chan> bitemyapp: I'm using it right now, big thanks ^^ But I wanted to ask a couple of questions.
04:25:01 <bitemyapp> I might cry.
04:25:10 <bitemyapp> Yuu_chan: please do.
04:26:02 <Yuu_chan> At first, when a single document is added with an empty DocId, it's generated randomly, which is great. But in a bulk the id really becomes an empty string.
04:26:48 <bitemyapp> hrm. nuts.
04:27:11 <Yuu_chan> I had to hack the library a bit.
04:27:46 <bitemyapp> Yuu_chan: what'd you need to change? Would you be willing to file issues or PRs on github?
04:29:04 <Yuu_chan> bitemyapp: in mkMetadataValue, probably it's unnecessary to add "_id" .= docId when docId is empty.
04:30:24 <Yuu_chan> Then, I'd want to make ranged datetime filters, but unsure if it's possible.
04:30:49 <bitemyapp> Yuu_chan: I'd have to study the docs again and think about it. Is an empty DocId when you're punting to Elasticsearch for DocId generation?
04:30:57 <bitemyapp> Yuu_chan: for bulk.
04:32:58 <Yuu_chan> bitemyapp: I'm not sure which is a right way (having a very little Elastic experience), but with a fix proposed above it indeed generates a random DocId for each document in a bulk.
04:34:08 <dottedmag> bitemyapp: missing _id causes DocId to be generated in ES.
04:34:16 <dottedmag> Not sure about empty one.
04:34:18 <bitemyapp> Yuu_chan: so, basically, the current API forces the user to generate their own DocIds. The reason for this is that ordinarily you don't want to use ES's id generation.
04:34:30 <bitemyapp> not in production use-cases anyway
04:34:39 <bitemyapp> you want to generate your own UUIDs.
04:34:39 <dottedmag> bitemyapp: why is that? Just curious.
04:34:54 <bitemyapp> I'm not saying I won't change it, but you want to think very carefully about it and read up on split-brain.
04:34:59 <bitemyapp> dottedmag: split brain merge.
04:35:10 <bitemyapp> dottedmag: auto-inc means data loss on cluster rejoin after partition/split-brain.
04:35:20 <bitemyapp> UUID means read-repairable duplicates with natural key.
04:35:30 * bitemyapp has fixed a lot of broken ES indexes :(
04:35:59 <bitemyapp> disadvantage to UUIDs? they probably bloat the index relative to the auto-inc ids. Lower node contention though.
04:36:32 <bitemyapp> OTOH, drains entropy pool on client nodes.
04:36:42 <bitemyapp> pretty small externalities for not losing data, IMO.
04:37:26 <Yuu_chan> dottedmag: the matter of question was that an empty DocId results in a missing _id in a single put query, but stays an empty string in a bulk.
04:38:18 <Yuu_chan> = an incosistency.
04:38:45 <dottedmag> Yep
04:38:51 <bitemyapp> it's definitely an API wrinkle I'm not happy with.
04:39:10 <merijn> Does anyone know of an explanation of CoWriter?
04:39:27 <bitemyapp> merijn: https://github.com/bitemyapp/learnhaskell#comonads
04:39:29 <merijn> I'm looking at the code, but I'm mystified by what it attempts
04:39:46 <bitemyapp> Yuu_chan: do you have a github account?
04:39:46 <Yuu_chan> I'd probably use an auto-inc id, but don't know how to implement them correctly in a multithreaded client.
04:39:53 <Yuu_chan> bitemyapp: nope
04:39:59 <merijn> bitemyapp: I was reading those slides, hence why I was asking for an explanation :p
04:40:09 <bitemyapp> welp.
04:40:22 <bitemyapp> merijn: http://hackage.haskell.org/package/comonad-4.2/docs/Control-Comonad-Trans-Traced.html
04:41:23 <merijn> bitemyapp: Yes, but that doesn't tell me WHY the implementation of extend for CoWriter is the way it is
04:41:37 <merijn> The actual implementation is opaque enough that I only see it typechecks
04:41:44 <merijn> I'm just not sure what the hell it attempts to do
04:42:48 <Yuu_chan> bitemyapp: could you please answer about ranged time filters?
04:43:00 <bitemyapp> oh, sorry.
04:43:03 <dottedmag> bitemyapp: FWIW ES also uses UUIDs https://github.com/elasticsearch/elasticsearch/blob/master/src/main/java/org/elasticsearch/action/index/IndexRequest.java#L607
04:43:21 <merijn> For that matter, I looked at Store before and I have no idea what Store does either
04:43:44 <merijn> There's plenty of explanations for the usual Monads, but this seems conspicuously absent for the "standard" comonads
04:44:06 <bitemyapp> dottedmag: cool, I don't remember it being so back when I used ES in prod.
04:44:25 <dottedmag> Probably changed since then, yes.
04:44:33 <bitemyapp> dottedmag: walking back the history to see if I can verify
04:44:48 <bitemyapp> hrrrm. id(Strings.randomBase64UUID()); even in 0.90
04:44:52 <merijn> Actually, scratch that, Store makes some sense to me
04:46:01 <bitemyapp> dottedmag: hrm, yeap, no idea what i was thinking of. I need sleep.
04:46:05 <bitemyapp> sorry about that.
04:46:17 <dottedmag> Changed post-0.18.0
04:46:26 <bitemyapp> dottedmag: oh was that it?
04:46:32 <bitemyapp> dottedmag: how'd you find it?
04:46:36 <bitemyapp> Yuu_chan: as for ranged date filters...let me check the docs.
04:46:56 <dottedmag> bitemyapp: C-g a in Emacs vc-mode, tracing to the version where there is no UUID generation in the file.
04:47:17 <bitemyapp> dottedmag: brill. Thanks. I was worried I had a very faulty memory or was an ignoramus there for a bit ;_;
04:47:20 <dottedmag> But the code has moved somewhere else, not yet found whahow it behaved back then.
04:47:36 <bitemyapp> or maybe I still am an ignoramus. anyway.
04:47:40 <bitemyapp> ranged date filters
04:49:06 <bitemyapp> Yuu_chan: so, we're getting antediluvian here again
04:49:35 <bitemyapp> well wait, let me finish hunting for what I have in mind first.
04:49:50 <Yuu_chan> bitemyapp: thanks for extending my vocabulary %)
04:50:02 <bitemyapp> least I can do.
04:50:17 <dottedmag> bitemyapp: traced it back to the beginning of the history -- first change I found is changing string UUID representation to base64.
04:50:56 <bitemyapp> dottedmag: then yeah, my eggs were scrambled.
04:51:08 <bitemyapp> Yuu_chan: https://gist.github.com/chrismale/4115758 - date range filtering is supposed to be based on numeric_range
04:51:55 <bitemyapp> hrm, but now i see something about string formatted dates.
04:52:44 <bitemyapp> Yuu_chan: http://www.elasticsearch.org/guide/en/elasticsearch/reference/current/query-dsl-range-query.html for number/date fields, the query is a NumericRangeQuery
04:52:49 <bitemyapp> that's based on query though, not filter.
04:53:46 <bitemyapp> Yuu_chan: in http://www.elasticsearch.org/guide/en/elasticsearch/reference/current/query-dsl-range-filter.html they allude to the use of date math expressions.
04:53:53 <dottedmag> IIRC I perused http://www.elasticsearch.org/guide/en/elasticsearch/reference/current/query-dsl-range-filter.html
04:54:00 <dottedmag> oops :)
04:54:27 <Yuu_chan> and... how to convert the UTC datetime into a number?
04:54:34 <dottedmag> ISO date format is nicely sortable though.
04:54:47 <bitemyapp> Yuu_chan: it's supposed to do that for you, if the mapping knows the date format.
04:54:52 <bitemyapp> Yuu_chan: http://www.elasticsearch.org/guide/en/elasticsearch/reference/current/mapping-core-types.html#date
04:54:58 <dottedmag> I remember using "gte": "2014-01-01Z", "lt": "2014-01-02Z"
04:54:59 <bitemyapp> Yuu_chan: so it's just a UTC long if your mapping is correct.
04:55:12 <bitemyapp> dottedmag: maybe they dispatch the same formatting -> UTC long translation there?
04:55:28 <dottedmag> Hmm. Yes, if the field has the correct mapping.
04:55:30 <bitemyapp> I may need to add support for that.
04:55:43 <bitemyapp> actually, I don't really do anything with Mappings at the moment.
04:55:52 <bitemyapp> I leave it to the user to define the JSON.
04:56:36 <bitemyapp> that aside, a more flexible type is needed for range queries.
04:56:42 <bitemyapp> even if I'm not going to type-check the mapping.
04:56:54 <dottedmag> Yuu_chan: as long as the field has the "data" type mapping, you can throw in any valid date string format and it will be processed correctly.
04:57:09 <dottedmag> s/"data"/"date"/
04:57:27 <Yuu_chan> bitemyapp: but Ranges from Bloodhound wrap only Doubles, right?
04:58:00 <bitemyapp> Yuu_chan: presently, yes.
04:58:25 <bitemyapp> I'd need to make the Double into a sum type.
04:58:50 <bitemyapp> RangeValue = NumRange Double | DateRange DateFormatString …
04:59:03 <bitemyapp> currently, you can generate the UTC num yourself.
05:00:14 <Yuu_chan> bitemyapp: in which format? timestamp.nanoseconds?
05:01:11 <bitemyapp> Yuu_chan: I think it's milliseconds since epoch.
05:01:32 <bitemyapp> can you even store epoch nanoseconds in a long?
05:02:04 <Yuu_chan> Why long?
05:02:20 <bitemyapp> long max size is 9,223,372,036,854,775,807
05:03:04 <Yuu_chan> I know, but what uses long?
05:03:25 <Hermit> I've been wondering, is it possible to use type-literals as code values?
05:03:28 <bitemyapp> Yuu_chan: they're Java longs. Elasticsearch uses them to store dates.
05:03:36 <Hermit> and if so, how?
05:04:11 <bitemyapp> Hermit: what's a type literal?
05:04:36 <Hermit> Symbols as provided by -XDataKinds
05:04:47 <Hermit> err, anything actually
05:04:50 <Hermit> but I'm interested in symbols
05:05:31 <Yuu_chan> bitemyapp: thanks for your support!
05:05:37 <bitemyapp> Yuu_chan: np.
05:05:50 <bitemyapp> Yuu_chan: sorry I'm not a savvier operator :)
05:06:03 <bitemyapp> Yuu_chan: I'll file github issues now before I forget on these design flaws.
05:06:08 <Hermit> I'm kind of puzzled. I believe this could be done with some typefamily/gadt hackery, but I'm not well versed in any of those yet
05:06:20 <Yuu_chan> Btw, I use all of that in a prototype at my main job
05:06:26 <bitemyapp> Hermit: are you sure?
05:06:50 <xnyhps> Hermit: You mean like http://hackage.haskell.org/package/base-4.6.0.1/docs/GHC-TypeLits.html#g:2 ?
05:06:57 <Hermit> not really, just a hunch
05:07:06 * Hermit checks link
05:07:23 <merijn> Hermit: It requires some fairly ugly hacks
05:07:44 <bitemyapp> merijn: do you know a motivating example for this sort of thing?
05:08:00 <merijn> Hermit: GHC does type erasure, so type information is not available at runtime, so it uses some typeclass hacks to reify type literals at the value level
05:08:06 <merijn> bitemyapp: What sort of thing?
05:08:09 <Hermit> merijn: as I'd expect, but still, I'd like to do it
05:08:16 <bitemyapp> merijn: type literal manip in terms.
05:08:29 <merijn> Hermit: You want to look base-4.7 docs
05:08:39 * Hermit is
05:08:51 <merijn> bitemyapp: That's the wrong way of thinking about it
05:08:58 <Hermit> merijn: (thanks for pointing it out anyways)
05:09:04 <merijn> bitemyapp: What people wants it to have types influence the code path
05:09:20 <bitemyapp> merijn: you mean, in a more sophisticated way than typeclass dispatch?
05:09:26 <bitemyapp> merijn: and sum-type pattern matching?
05:09:38 <bitemyapp> sum inhabitant I guess, you get my meaning.
05:09:45 <bitemyapp> a lot of sum type values are proxies for types.
05:10:48 <merijn> bitemyapp: I mean in the way of I have a type family "Foo :: Nat -> *", but to write code that actual returns the proper type for "Foo 5" I need to know that the Nat is '5' at the value level
05:11:14 <bitemyapp> merijn: ah, cool.
05:11:41 <Yuu_chan> Yay, Hourglass already provides nifty functions to convert between time representations
05:13:05 <Hermit> xnyhps: right (sorry for the late reply and thanks)
05:14:28 * hackagebot matrix 0.3.1.1 - A native implementation of matrix operations.  http://hackage.haskell.org/package/matrix-0.3.1.1 (DanielDiaz)
05:14:35 <bitemyapp> Yuu_chan: oh cool! thanks for mentioning that :)
05:19:28 * hackagebot aeson-qq 0.6.0 - Json Quasiquatation for Haskell.  http://hackage.haskell.org/package/aeson-qq-0.6.0 (SimonHengel)
05:19:30 * hackagebot usb-id-database 0.4.0.9 - A database of USB identifiers  http://hackage.haskell.org/package/usb-id-database-0.4.0.9 (RoelVanDijk)
05:20:42 <dagle> Does haskell have an convention for naming modules and their paths?
05:20:55 <bitemyapp> dagle: there are known categories people tend to use.
05:21:15 <bitemyapp> dagle: http://hackage.haskell.org/packages/
05:21:40 <bitemyapp> dagle: my elasticsearch client begins with "Database" because it's in the Database category.
05:21:43 <dagle> Under what would you put a module that parses xml formats?
05:21:56 <dagle> format*
05:22:19 <bitemyapp> dagle: Text
05:22:46 <bitemyapp> dagle: http://hackage.haskell.org/packages/ I did cmd-f "XML" and used the highest density category to pick Text :P
05:23:00 <bitemyapp> dagle: however
05:23:06 <bitemyapp> dagle: this is about entire library categorization
05:23:24 <bitemyapp> dagle: you wouldn't ordinarily do this within a leaf application.
05:23:40 <bitemyapp> dagle: for example, if the XML was getting parsed for config, I'd put it under AppName.Config
05:23:51 <bitemyapp> that it's from XML is immaterial.
05:24:05 <Yuu_chan> Ew. *** Exception: Database/Bloodhound/Types/Instances.hs:(128,3)-(197,39): Non-exhaustive patterns in function toJSON
05:24:15 <Philonous> dagle, Those "Data" "Control" "Text" etc. prefixes don't actually do anything except making you type more, so I'm leaving them out more and more.
05:24:15 <dagle> This is a module for parsing XmlTv.
05:24:28 <bitemyapp> Yuu_chan: sigh, sorry.
05:24:34 <bitemyapp> Yuu_chan: what'd you use?
05:24:44 <bitemyapp> all else fails, I'll do a sweep of -Wall
05:24:45 <efg> christ, my farts smells horrible today
05:24:56 <dagle>  Also, I hate xml.
05:25:10 <efg> i hate haters
05:25:13 <dagle> :)
05:25:24 <Philonous> dagle, Often they are inconsisten anyway. It's Control.Applicative for applicative functors but Data.Profunctor for profunctors. What gives.
05:25:37 <dagle> :)
05:25:40 <Yuu_chan> bitemyapp: Teehee, there is no clause for QueryRangeQuery
05:25:44 <Maior> is there any form of mechanism for dealing with namespace clashes?
05:26:00 <Maior> e.g. if some cad creates their own Control.Applicative
05:26:07 <dagle> Maior: qualified imports
05:26:19 <Maior> dagle: I don't see how they help
05:26:32 <dagle> Aha.
05:26:33 <benzrf> Maior: i assume dagle answered before your example
05:26:34 * bitemyapp facepalms
05:26:37 <dagle> I was reading it all wrong.
05:26:38 <bitemyapp> Yuu_chan: sorry ;_;
05:26:39 <Philonous> Maior, package imports. import "some-silly-package" Control.Applicative
05:26:47 <benzrf> bitemyapp: look what i made http://imgur.com/a/BGBtg
05:26:49 <bitemyapp> uno momento
05:26:50 <Maior> Philonous: oooh that exists? awesome, thanks
05:26:52 <merijn> Maior: Or, you know, don't use packages that do that :p
05:27:28 <Philonous> Maior, Yes, needs an extension, though (-XPackageImports IIRC)
05:27:30 <Maior> merijn: I've learnt never to underestimate the willingness / obliviousness of some people to causing pain and suffering
05:27:33 <Maior> Philonous: excellent, cheers
05:27:37 <bitemyapp> benzrf: whoa
05:27:44 <bitemyapp> benzrf: how?
05:27:48 <amatsu> Could someone take a look at this snippet for me? http://lpaste.net/105014
05:27:49 <benzrf> bitemyapp: trust me
05:27:51 <benzrf> you don't wnt to know
05:27:59 <bitemyapp> benzrf: tell me how.
05:28:07 <amatsu> actually nvm
05:28:16 <benzrf> bitemyapp: it's called Vampire because of what it would do to your computer if you used it on anything more significant than my example
05:28:22 <benzrf> 1 sec let me find the code
05:29:26 <alpounet> benzrf: niiice
05:29:35 <Yuu_chan> benzrf: very fancy!
05:29:54 <Philonous> Flashy!
05:30:39 <Yuu_chan> Er... Graphy!
05:31:00 <Hermit> bitemyapp: un* ;-)
05:31:17 <bitemyapp> Hermit: ?
05:31:23 <benzrf> bitemyapp: you may want to brace yourself
05:31:23 <benzrf> bitemyapp: http://bpaste.net/show/334946/
05:31:33 <Hermit> bitemyapp: the spanish expression
05:31:40 <bitemyapp> it can't be that ba
05:31:45 <bitemyapp> ...
05:32:14 <bitemyapp> benzrf: ...
05:32:18 <Yuu_chan> bitemyapp: -fwarn-incomplete-patterns :-P
05:32:30 <bitemyapp> Yuu_chan: does -Wall include that?
05:32:44 <benzrf> bitemyapp: :^)
05:33:03 <bitemyapp> benzrf: 5/5 for sheer bloody-mindedness.
05:33:10 <bitemyapp> seriously. wow.
05:33:20 <bitemyapp> benzrf: are you going to turn that into a utility/library?
05:33:27 <benzrf> bitemyapp: im proud thx
05:33:29 <benzrf> bitemyapp: i might
05:33:37 <Yuu_chan> benzrf: line 58 tears my screen apart
05:33:37 <benzrf> but i cant imagine it could possibly be useful irl
05:33:50 <benzrf> Yuu_chan: it's a literal i pasted from ghci
05:33:52 <benzrf> ;)
05:33:55 <bitemyapp> benzrf: will you be at lambdajam?
05:34:04 <benzrf> whats that
05:34:11 <bitemyapp> so that's probably a no.
05:34:16 <bitemyapp> benzrf: Chicago FP conference
05:34:31 <benzrf> ah
05:34:35 <benzrf> when is it?
05:34:50 <bitemyapp> benzrf: http://www.lambdajam.com/
05:35:26 <benzrf> bitemyapp: can you try running it against a call to map with a function defined in a vampire'd module
05:35:39 <benzrf> i think it would create multiple function children with the expr filled in
05:35:53 <benzrf> but i cant run it from here because lately i've been doing dev over ssh -X since my laptop broke and im stuck on a chromebook
05:35:56 <bitemyapp> not immediately but I'll jot a note to try it.
05:35:59 <benzrf> :-)
05:38:40 <benzrf> bitemyapp: lambdajam looks cool
05:39:06 <benzrf> bitemyapp: now that i know it exists i will try to convince my parents that a trip to chicago is warranted
05:39:31 * hackagebot twitter-types 0.3.20140601 - Twitter JSON parser and types  http://hackage.haskell.org/package/twitter-types-0.3.20140601 (TakahiroHimura)
05:43:44 <Yuu_chan> bitemyapp: what if I get my own Github account and make a pull request?
05:44:32 * hackagebot eternal 0.0.5 - everything breaking the Fairbairn threshold  http://hackage.haskell.org/package/eternal-0.0.5 (Heather)
05:44:40 <bitemyapp> Yuu_chan: if you have code to PR, I'd take it seriously.
05:45:43 <Yuu_chan> bitemyapp: I'm planning to implement that missing RangeQuery stuff
05:46:33 <bitemyapp> Yuu_chan: if you're willing to do it :)
05:47:06 <Yuu_chan> I need it in my app...
05:48:56 <bitemyapp> Yuu_chan: it's on the docket, https://github.com/bitemyapp/bloodhound/issues/9
05:49:56 <bitemyapp> Yuu_chan: if you want it immediately, just write it and PR it. If you can wait, I'll do it.
05:54:54 <Tehnix> anyone ever experience cabal getting killed when you tried to update?
05:56:43 <bergmark> Tehnix: a one time thing or does it happen all the time for you?
05:56:58 <Tehnix> all the time
05:57:25 <Tehnix> managed to update on root though, but that doesn't help my normal user much (unless I start copying files..)
05:57:40 <Tehnix> it's on version 1.16
05:58:24 <Tehnix> dunno if that might cause it, but can't get it updated unless I get the recent list from hackage since 1.16 is the latest on my distro :/
05:59:45 <bergmark> Tehnix: can you check the HTTP response it gets?
06:00:55 <Tehnix> hmm, it seems like it gets it downloaded, and then gets klled immediately after "Updatng the index cache file..."
06:05:04 <bitemyapp> Tehnix: how much memory do you have on the computer you're doing that on?
06:05:07 <bitemyapp> Tehnix: is that a VPS?
06:05:50 <benzrf> i was unable to compile Language.Haskell.Exts on my VPS
06:05:56 <benzrf> it kept getting OOM killed ;-;
06:06:00 <benzrf> or so i assume
06:06:03 <benzrf> *was told
06:06:07 <bitemyapp> benzrf: it was - turn swappiness to 100
06:06:16 <bitemyapp> and make certain you have a large enough swap partition.
06:06:23 <benzrf> eh
06:06:34 <benzrf> i'll just stick to not doing haskell when im not at home
06:09:08 <benzrf> i should have a new laptop within a week or two though :>
06:09:22 <benzrf> ext. warranty actually came through \o/
06:09:50 <bitemyapp> benzrf: congrats :)
06:10:28 <Tehnix> bitemyapp: VPS, yeah. Has about 512 MB I think + some swap. I haven't experienced the problem before, and root was able to update though
06:10:58 <Tehnix> this is just 'cabal update' though, no compiling
06:11:35 <Yuu_chan> @hoogle Value -> String
06:11:37 <lambdabot> Warning: Unknown type Value
06:11:37 <lambdabot> Network.BufferType buf_toStr :: BufferOp a -> a -> String
06:11:37 <lambdabot> Prelude show :: Show a => a -> String
06:13:16 <bitemyapp> Tehnix: turn up swappiness.
06:13:20 <bitemyapp> Yuu_chan: Value is Aeson.
06:13:34 <bitemyapp> Value is the sum type of possible JSON values.
06:14:35 * hackagebot aeson-qq 0.6.1 - Json Quasiquatation for Haskell.  http://hackage.haskell.org/package/aeson-qq-0.6.1 (SimonHengel)
06:16:34 <Yuu_chan> bitemyapp: I know, I wnated a function to serialize it
06:16:43 <Yuu_chan> Found encode.
06:18:33 <danilo2> Hello! We have in haskell predicates indicating that something is equal to other thing (like a~b=> ...) Is there an opposite predicate (telling, that a is NOT b)? (to reject instance if it was matched?)
06:19:11 <merijn> danilo2: No, but you can write something like that using 7.8's closed type families
06:20:00 <absence> does haskell have a top type?
06:20:23 <danilo2> merijn: I do not want to use closed type families here. I want to crwate a default instance if no one was matched before - I've managed to write one, but If programmer uses the function wih wrong arguemnts, we get context reduction stackoverflow - which is an ugy error and I want to prevent it from happenning
06:20:25 <Sonderblade> absence: what's a top type?
06:20:48 <merijn> danilo2: If you don't want to use closed type families you're SOL
06:22:10 <danilo2> merijn: I can't. (I woudl like to), but the instances I'm writing are used to convert between some coordinate spaces and we want users to be able to define cusotm coordinate spaces. Using closed type families prevents them to do so. Btw what "SOL" means?
06:22:20 <Philonous> Sonderblade, I think it's a type T so that x::T holds for all values x.
06:23:27 <merijn> danilo2: Shit Outta Luck
06:23:46 <danilo2> merijn: Look, here is an example - there are 3 coordinate systems: Cartesian, Polar and UV. If we define conversions from and to cartesian, other conversions are done automatically, but If you enable the commented line below (which is calling a function with WRONG args) you get stack overflow while typechecking
06:24:34 <absence> Sonderblade: a type of which all other types are subtypes, i.e. the oposite of bottom (which i guess is "undefined"?)
06:25:15 <Philonous> absence, Haskell doesn't support subtyping and there is not top type.
06:25:23 <Philonous> s/not/no
06:26:23 <Philonous> absence, Strictly speaking, there isn't even a bottom type (since _|_ is a member of every type)
06:26:45 <merijn> danilo2: It's simple, there is no type inequality constraint and the only way to write one is using closed type families
06:27:00 <merijn> danilo2: So if you don't want to/can't use closed type families you're screwed
06:30:23 <absence> Philonous: that makes sense. thanks!
06:30:46 <danilo2> merijn: I understand - could you tell me if you see any way to use closed type families in the example I posted? http://lpaste.net/105019
06:33:08 <Yuu_chan> Can't get the millisecond-based time query work :(
06:34:30 <Yuu_chan> Philonous: unboxed types don't include _|_ IIRC
06:34:59 <Philonous> Yuu_chan, Are those standard Haskell?
06:35:25 <Yuu_chan> Er... no.
06:35:58 <Philonous> So, technically speaking, I was still correct ^_^
06:41:28 <Yuu_chan> Philonous: must a bottom type be a "largest common subtype"?
06:41:44 <Yuu_chan> Or just to have no values?
06:42:05 <Yuu_chan> I'm thinking about EmptyDataDecls
06:42:09 <jfischoff> I’m struggling to wrap my head around MonadTransControl
06:42:28 <bennofs> jfischoff: have you read the blog post on the yesod blog?
06:42:43 <jfischoff> does it cover writing the instances for it?
06:43:25 <bennofs> jfischoff: http://www.yesodweb.com/book/monad-control It explains how it "works", so you should be able to write an instance for it afterwards I think
06:43:45 <jfischoff> specifically I have a newtype FooT r w m a = FooT (ReaderT r (WriterT w m) a)
06:44:14 <jfischoff> I’m assuming I can compose the liftWith’s to make a new instance, but the type tetris is not as obvious as I would expect
06:46:21 <jfischoff> the blog is out of date AFIACT
06:46:43 <jfischoff> the types are different now
06:47:38 <jfischoff> bennofs: do you know of a up to date resource? or perhaps an example of someone using it on newtyped transformer stack?
06:48:15 <bennofs> jfischoff: the definition of MonadTransControl in the article contains "liftControl :: Monad m => (Run t -> m a) -> t m a", which is "liftWith" from the current package
06:48:40 <jfischoff> Run is different
06:48:49 <t7> How many different ways are there to seperate a set into two (provided the set has even number of elements)?
06:48:50 <bennofs> oh, I see, sorry
06:49:01 <t7> need some kinda combinatoin equation
06:49:41 * hackagebot HUnit-Plus 0.3.4 - A test framework building on HUnit.  http://hackage.haskell.org/package/HUnit-Plus-0.3.4 (emc2)
06:50:38 <nomeata> Can this work: http://hdiff.luite.com/cgit/diagrams-gtk/diff/?id=1.0.1.1&id2=1.0.1 ?
06:50:42 <benzrf> t7: i think another way to put that would be 'how many subsets does a set have that are half its size'
06:50:53 <t7> no i don't even need that no
06:50:57 <t7> now*
06:51:09 <t7> my game tree complexity is 2^n+1 i think
06:51:18 <nomeata> The build-depends get more permissive, so stuff that compiled before is still allowed, but adjustDia seems to be called with a different type
06:51:24 <benzrf> t7: no, ways to split a set in 2 is ways to pick half of the set
06:51:33 <benzrf> t7: because then the remainder forms the other half
06:51:35 <chrra> jfischoff: Here's an example: lpaste.net/105025
06:51:58 <benzrf> oh wait, yeah it's what i just said div by 2
06:51:58 <benzrf> sounds to me like factorial truncated halfway down
06:52:13 <benzrf> i.e.
06:52:40 * shapr hops cheerfully
06:52:43 <jfischoff> chrra: thanks!
06:52:43 <shapr> Good morning #haskell!
06:52:45 <benzrf> product [(size set / 2)..(size set)]
06:52:47 <benzrf> or something
06:52:48 <shapr> It's a beautiful day for code!
06:52:59 <benzrf> gmorning shapr
06:53:01 <jfischoff> yes it is
06:53:04 <benzrf> shapr: wanna see something truly evil
06:53:08 <Maior> :t product
06:53:09 <lambdabot> Num a => [a] -> a
06:53:27 <Philonous> shapr, West coast?
06:53:33 <shapr> benzrf: sure?
06:53:42 <shapr> Philonous: Nah, central time, but my work lets me show up whenever
06:54:58 <Philonous> shapr, Haha, ok. I just knew it's 10am in Washington DC because of internet radio. (It's 4pm over here)
06:55:31 <shapr> Philonous: Where do you write your Haskell code?
06:55:50 <Philonous> shapr, You mean my location? Germany.
06:56:18 <shapr> Oh cool, I was just hanging out with a friend from Berlin this past weekend.
06:57:14 <benzrf> shapr: rated '5/5 for sheer bloody mindedness' by such luminaries as bitemyapp, i present... Debug.Vampire! http://imgur.com/a/BGBtg
06:57:22 <Philonous> So he, like Kennedy, is a jelly-filled doughnut.
06:59:12 <shapr> benzrf: that's nifty and doing something interesting, that's for sure!
06:59:29 <benzrf> shapr: you would not say that if you saw the implementation :-)
06:59:40 <shapr> I sort of want to now :-)
06:59:52 <jamie_h> I'm trying to implement a xor function using folds, and keep running into an error
07:00:00 <jamie_h> xor :: [Bool] -> Bool
07:00:00 <jamie_h> xor = odd . foldl (\acc x -> if x == True then 1 else 0) 0 [True,False]
07:00:12 <jamie_h> error is: No instance for (Num ([Bool] -> b0)) arising from the literal `1'
07:00:19 <benzrf> jamie_h: what would that even do
07:00:21 <benzrf> :t xor
07:00:22 <lambdabot> Bits a => a -> a -> a
07:00:42 <jamie_h> benzrf it's an exercise with folds
07:00:57 <benzrf> :t odd
07:00:58 <lambdabot> Integral a => a -> Bool
07:01:02 <shapr> benzrf: Is the Vampire code on github?
07:01:14 <benzrf> no, i wrote it yesterday
07:01:14 <benzrf> it's in this paste http://bpaste.net/show/334946/
07:01:26 <jamie_h> benzrf surely foldl with 0 as a starting accumulator should return an Integral?
07:01:43 <Philonous> > foldr (/=) False [True, True, False]
07:01:45 <lambdabot>  False
07:01:50 <Philonous> > foldr (/=) False [True, True, False, True, False]
07:01:50 <benzrf> :t odd . foldl (\acc x -> if x == True then 1 else 0) 0 [True,False]
07:01:52 <lambdabot> (Num (a -> b), Integral b) => a -> Bool
07:01:52 <lambdabot>  True
07:02:00 <benzrf> :t odd . foldl (\acc x -> if x == True then 1 else 0) 0
07:02:01 <lambdabot> [Bool] -> Bool
07:02:13 <benzrf> jamie_h: you have a spurious [Bool] at the end there ;)
07:02:47 <benzrf> shapr: it's called Vampire because of what it would probably do to your computer if you tried to use it with anything nontrivial
07:02:55 <benzrf> :-)
07:02:58 <jamie_h> benzrf thanks - got it working :)
07:03:36 <benzrf> =)
07:04:26 <shapr> benzrf: whoa, you're using implicit params?
07:05:26 <benzrf> shapr: commenting on that and not the unsafePerformIO or the rewriting of every expr?
07:05:42 <shapr> There's are many things to comment on in that code :-)
07:05:51 <shapr> I just don't see implicit params very much these days.
07:06:06 <benzrf> shapr: but yes, it's the only practical way i found to smuggle the current expr context into all of the functions without major type fuckery
07:06:33 <shapr> I have seen implicit params go horribly wrong in a variety of ways in the past.
07:06:48 <benzrf> is there any non-horribly-wrong way to do this?
07:06:49 <benzrf> =)
07:07:07 <shapr> benzrf: turn it into a PhD project and get funding to do it right :-P
07:07:47 <shapr> benzrf: still, it's a really cool hack, congrats!
07:07:57 <benzrf> thx
07:08:14 <benzrf> shapr: i was loosely inspired by somebody else's phd project actually
07:08:36 <shapr> benzrf: My idea for an evil hack to do runtime code reloading was to implement it inside the Template Haskell loop where you still have access to all the types...
07:08:52 <shapr> benzrf: that is, the entire program would run inside the TH compile time stage
07:08:59 <benzrf> goodness
07:09:09 <benzrf> this isnt runtime code reloading though
07:09:16 <benzrf> it's expression tree visualization
07:09:17 <benzrf> :-)
07:09:34 <shapr> Sure, I was just trying to think of cool hacks.
07:09:45 * hackagebot yaml-light-lens 0.3.1.1 - Lens interface to yaml-light.  http://hackage.haskell.org/package/yaml-light-lens-0.3.1.1 (AnthonyCowley)
07:09:48 <benzrf> i might actually do something to allow more fine-grained control over what's tracked/wrapped and turn this into a proper utility
07:09:51 <benzrf> or at least
07:09:51 <benzrf> toy
07:10:38 <shapr> benzrf: you have a working proof of concept, go for it!
07:10:43 <benzrf> :O
07:14:44 <hler> hi
07:15:07 <hler> does the Haskell platform on MacOSX include an editor? Or it's "just" GHC + libraries?
07:15:29 <Maior> hler: what editor were you expecting?
07:16:06 <hler> Maior: I don't know, I just installed Haskell for the first time
07:16:37 <Maior> hler: I would not expect an editor
07:16:43 <benzrf> hmmm
07:16:45 <benzrf> @where project
07:16:45 <lambdabot> I know nothing about project.
07:16:57 <`^_^v> use vim, its a lot better than any alternative *leaves*
07:17:26 <hyPiRion> Maior: Yeah, there is no editor bundled. Usually people use whatever they came with
07:17:37 <hler> okay, that's fine with me
07:17:38 <hler> thanks
07:17:49 <hyPiRion> whoops, replied to wrong person
07:17:53 <benzrf> hler: use vim!!!!
07:17:53 <benzrf> vim's the shit :-D
07:18:02 <benzrf> hler: if you install ghc-mod and get the Syntastic plugin for vim, you can have syntax checking in ur editor without a fullscale IDE
07:18:08 <benzrf> hler: also type checking, etc
07:18:12 <benzrf> general correctness checking
07:18:16 <merijn> hler: Most people here just use vim/emacs, I'd use whatever you're already comfortable with
07:19:20 <hler> I know and have both. I'll give ghc-mode a go
07:19:21 <benzrf> @where project setup
07:19:21 <lambdabot> I know nothing about project.
07:19:25 <benzrf> hmm
07:19:37 <benzrf> is there a guide to setting up a project to put on hackage
07:19:52 <quchen> The Cabal user's guide?
07:21:14 <benzrf> and how to use cabal
07:21:40 <merijn> "cabal init", follow instructions
07:21:59 <uggwar> anyone know where to fetch hdevtools that builds on 7.8.2?
07:22:32 <benzrf> @where cabal
07:22:32 <lambdabot> http://www.haskell.org/cabal
07:22:38 <benzrf> oh
07:22:39 <benzrf> haha
07:24:03 <heudebeu> clone github repo, merge the pull request and build and install hdevtools
07:25:18 <heudebeu> this pull request https://github.com/bitc/hdevtools/pull/28/files
07:25:27 <uggwar> heudebeu: thanks!
07:30:04 <mpgaillard> hello, does anybody understand how take is implemented in haskell? For example if I have this code:
07:30:12 <mpgaillard> repeat' :: a -> [a]
07:30:13 <mpgaillard> repeat' x = x:repeat' x
07:30:27 <mpgaillard> and then I do take 5 (repeat 3)
07:30:49 <shapr> @src take
07:30:50 <lambdabot> take n _      | n <= 0 =  []
07:30:50 <lambdabot> take _ []              =  []
07:30:50 <lambdabot> take n (x:xs)          =  x : take (n-1) xs
07:30:52 <tdammers> lazy evaluation
07:30:58 <mpgaillard> why does it work? Why doesn't repeat 3 get executed first infinitely
07:31:07 <phadej> call-by-need vs. call-by-value
07:31:13 <phadej> or lazy vs. strict evaluation
07:31:15 <lwm> what tdammers said
07:31:38 <Philonous> mpgaillard, Haskell lists are more like generators than like lists in other languages.
07:31:38 <tdammers> I'm from the not-so-distant future!
07:31:57 <zomg> I remember being confused about lazy evaluation, but once you get how it works it lets you do certain things more easily which is pretty nice =)
07:32:28 <matematikaadit> mpgaillard: http://www.seas.upenn.edu/~cis194/lectures/06-laziness.html
07:32:29 <byorgey> nomeata: oh, you're right, the build-depends is too permissive, it should have  diagrams-core and diagrams-lib >= 1.2
07:32:43 <mpgaillard> thanks a lot for the explanation
07:32:59 <byorgey> nomeata: thanks for the catch, I'll upload a fixed version
07:33:06 <mpgaillard> I am trying to understand it
07:33:08 <nomeata> byorgey: great, thanks!
07:33:18 <byorgey> maybe we should deprecate 1.0.1.1 on Hackage too?  Not sure who to talk to about that
07:36:54 <heudebeu> should hdevtools be forked? because the owner hasn't contributed anything to github in the last 5 months?
07:38:46 <shapr> heudebeu: you could ping the maintainer and NMU it if there's no response
07:39:33 <frerich> heudebeu: I tend to just fork stuff and ping the maintainer at the same time. In case he responds, I submit a pull request.
07:39:48 * hackagebot diagrams-gtk 1.0.1.2 - Backend for rendering diagrams directly to GTK windows  http://hackage.haskell.org/package/diagrams-gtk-1.0.1.2 (BrentYorgey)
07:43:00 <heudebeu> there are actually allready some people who have forked it
07:48:01 <heudebeu> i'll ping the maintainer and do a nmu (non maintainer upload) if he doesn't respond
07:48:17 <heudebeu> it's an important tool
07:50:50 <shapr> heudebeu: yay!
08:02:24 <benzrf> :t (=>)
08:02:25 <lambdabot> parse error on input ‘=>’
08:02:28 <benzrf> :t (==>)
08:02:28 <lambdabot> Testable prop => Bool -> prop -> Property
08:03:05 <benzrf> @check \v -> v ==> v
08:03:07 <lambdabot>  +++ OK, passed 100 tests.
08:03:13 <benzrf> :t (!=>)
08:03:14 <lambdabot>     Not in scope: ‘!=>’
08:03:14 <lambdabot>     Perhaps you meant one of these:
08:03:14 <lambdabot>       ‘>=>’ (imported from Control.Monad.Writer),
08:03:16 <benzrf> hmm
08:03:18 <benzrf> :t (!==>)
08:03:20 <lambdabot>     Not in scope: ‘!==>’
08:03:20 <lambdabot>     Perhaps you meant ‘==>’ (imported from Lambdabot.Plugin.Haskell.Eval.Trusted)
08:03:22 <benzrf> :t (/=>)
08:03:23 <lambdabot>     Not in scope: ‘/=>’
08:03:24 <lambdabot>     Perhaps you meant one of these:
08:03:24 <lambdabot>       ‘/=’ (imported from Data.Eq),
08:03:27 <benzrf> ehamberg:
08:03:29 <benzrf> *eh
08:03:34 <benzrf> oh wait that would be pointless
08:03:39 <benzrf> :t (<==>)
08:03:40 <lambdabot>     Not in scope: ‘<==>’
08:03:40 <lambdabot>     Perhaps you meant ‘==>’ (imported from Lambdabot.Plugin.Haskell.Eval.Trusted)
08:03:43 <benzrf> no iff?
08:04:33 <benzrf> @check \v -> v * 0 == 0
08:04:35 <Maxdamantus> @check \v -> (v :: Bool) == v
08:04:35 <lambdabot>  +++ OK, passed 100 tests.
08:04:37 <lambdabot>  +++ OK, passed 100 tests.
08:04:41 <benzrf> hmm
08:05:05 <benzrf> @check \v -> fmap id v == v
08:05:07 <lambdabot>  No instance for (Test.QuickCheck.Arbitrary.Arbitrary (f0 b0))
08:05:07 <lambdabot>  arising from a use of ‘Lambdabot.Plugin.Haskell.Check.ShowQ.myquickcheck’ Th...
08:05:16 <benzrf> @check \v -> fmap id (v :: Just a) == v
08:05:17 <lambdabot>  Not in scope: type constructor or class ‘Just’
08:05:17 <lambdabot>  A data constructor of that name is in scope; did you mean DataKinds?
08:05:21 <benzrf> @check \v -> fmap id (v :: Maybe a) == v
08:05:21 <benzrf> derp
08:05:22 <lambdabot>  Couldn't match type ‘a’ with ‘()’
08:05:22 <lambdabot>  ‘a’ is a rigid type variable bound by an expression type signature: Data.May...
08:05:24 <benzrf> aw.
08:05:45 <benzrf> @check \v -> map id v == v
08:05:46 <lambdabot>  +++ OK, passed 100 tests.
08:06:01 <benzrf> @check \v -> v >>= id == v
08:06:02 <lambdabot>  Couldn't match expected type ‘a0 -> a0 -> b0’
08:06:02 <lambdabot>  with actual type ‘GHC.Types.Bool’ Relevant bindings include v :: a0 -> a0 (b...
08:06:10 <benzrf> @check \v -> (v >>= id) == v
08:06:12 <lambdabot>  Occurs check: cannot construct the infinite type: b0 ~ m0 b0
08:06:12 <lambdabot>  Expected type: m0 b0 Actual type: m0 (m0 b0) Relevant bindings include v :: ...
08:06:19 <benzrf> @check \v -> (v >>= return) == v
08:06:20 <benzrf> gah
08:06:21 <lambdabot>  No instance for (Test.QuickCheck.Arbitrary.Arbitrary (m0 b0))
08:06:21 <lambdabot>  arising from a use of ‘Lambdabot.Plugin.Haskell.Check.ShowQ.myquickcheck’ Th...
08:06:24 <benzrf> q.q
08:06:59 <Rose18>  You can find funny videos here. http://bit.ly/1kml8Nf
08:07:48 <aspidites> i think that's the first time i've seen spam on freenode...ever
08:08:03 <merijn> aspidites: Naah, it happens fairly regularly
08:08:07 <Maior> aspidites: fortunate :P
08:08:23 <Maxdamantus> That site (or at least that domain) has been spammed frequently recently.
08:09:09 <zomg> urlshorteners are pretty commonly used when spamming as it allows them to mask the real domain, which could be blocked by automatic spam detectors
08:09:49 <benzrf> what does 'Include documentation on what each field means' mean
08:10:16 <quchen> data Either a b = Left a -- ^ First field \n Right b -- ^ Second field
08:10:22 <tdammers> benzrf: try it
08:11:01 <quchen> ?check \xs -> xs == reverse xs -- Careful with defaulting!
08:11:03 <lambdabot>  <hint>:1:80:
08:11:03 <lambdabot>  parse error (possibly incorrect indentation or mismatched brackets)
08:11:09 <quchen> ?check \xs -> xs == reverse xs
08:11:11 <lambdabot>  +++ OK, passed 100 tests.
08:11:30 <aspidites> ah quickcheck integration? neat
08:13:27 <benzrf> by 'fields' does it mean every defined symbol, every exported symbol, or what?
08:13:32 <benzrf> accessors?
08:13:52 <tdammers> benzrf: just say "no"
08:13:56 <tdammers> :D
08:14:20 <benzrf> just say no to fields?
08:14:28 <tdammers> that too
08:14:32 <tdammers> fields: not even once
08:14:41 <quchen> Coding with Void
08:14:44 <quchen> A book by tdammers
08:14:44 <tdammers> I mean say no to including documentation
08:15:05 <tdammers> I recently read a blog called underengineering
08:15:13 <tdammers> I'd like to take it a step further
08:15:18 <tdammers> un-engineering
08:15:27 <tdammers> "ungineering", if you will
08:15:35 <quchen> Software ungeneering, for when Brainfuck is too expressive
08:15:39 <benzrf> look, if computers can fill in the blanks for my code so that it runs, why can't they just write it in the first place
08:16:06 <Maxdamantus> unengineering sounds like reverse-engineering, which is basically engineering.
08:16:10 <tdammers> brainfuck is baroque
08:16:44 <tdammers> just give the user notepad and some learning resources
08:16:53 <tdammers> then the software writes itself!
08:16:56 <benzrf> what does '
08:16:57 <benzrf> ☐
08:16:57 <benzrf> ☐
08:16:58 <benzrf> oops
08:17:01 <benzrf> wrong paste o_O
08:17:03 <benzrf> 'Include documentation on what each field means'
08:17:06 <benzrf> ^what does this mean?!
08:17:38 <tdammers> it means cabal peppers your .cabal file with extra documentation comments
08:17:46 <benzrf> ooh.
08:17:51 <quchen> Oh, when using Cabal.
08:17:54 <benzrf> i will go with yes because this is my first time using cabal p:
08:17:56 <quchen> That might have been useful information to know.
08:18:10 <tdammers> quchen: it's one of the questions "cabal init" asks
08:18:53 <quchen> Hmm I think I did 'cabal init' once, and ever since then I copied my .cabal file and edited it in the new location
08:19:27 <quchen> But I remember it painting this nice picture of the versioning policy in the generated file.
08:19:40 <benzrf> how does cabal integrate with Git
08:19:47 <benzrf> does it?
08:20:08 <quchen> Git integrates with files, a Cabal project is a collection of files.
08:20:22 <benzrf> right right
08:21:38 <jamie_h> does anybody know about sundaram's sieve? why is the third number to be excluded 10 and not 12?
08:22:27 <lwm> I just found this absolute gem of an article -> http://www.aosabook.org/en/ghc.html
08:22:43 <jamie_h> actually - no worries :)
08:22:49 <lwm> which brings me to the question ... what was the first implementation of GHC written in
08:23:06 <benzrf> lwm: haskell, i would assume
08:23:10 <benzrf> that's what it's in
08:23:20 <vamega> Hi.
08:23:26 <hvr> benzrf: so it bootstrapped itself out of nothing? :)
08:23:31 <vamega> I'd like to use a value in the IO monad for a guard.
08:23:43 <vamega> Is there a normal way to do this?
08:23:52 <lwm> yeah, what hvr said ...
08:23:54 <quchen> lwm: I think it was C.
08:24:06 <benzrf> wait
08:24:09 <benzrf> was ghc the first haskell impl?
08:24:14 <hvr> otoh, there could have been another existing Haskell compiler
08:24:15 <benzrf> i thought others came before it
08:24:20 <hvr> or interpreter
08:24:22 <lwm> quchen: really?  any links?
08:24:46 <lwm> I see this RTS component of GHC is in C ...
08:24:53 * hackagebot hourglass 0.2.0 - simple performant time related library  http://hackage.haskell.org/package/hourglass-0.2.0 (VincentHanquez)
08:25:07 <benzrf> lwm: well, it'd have to be wouldnt iteratee
08:25:08 <benzrf> *it
08:26:04 <napping> I think the first Haskell compilers were written in a lisp and a lazy ML dialect
08:26:31 <lwm> napping: woah there, this is getting interesting
08:26:37 <mr-> ask wikipedia: GHC originally started in 1989 as a prototype, written in LML (Lazy ML) by Kevin Hammond at the University of Glasgow.
08:26:56 <mr-> [citation needed]
08:27:01 <napping> http://research.microsoft.com/en-us/um/people/simonpj/papers/history-of-haskell/index.htm
08:27:14 <companion_cube> lazy ML? sounds tough
08:27:20 <vamega> Anyone know how I could write this?
08:27:21 <vamega> http://lpaste.net/105028
08:27:41 <vamega> The tpes don't quite match up. since the guard expects a Bool while I'm giving it an IO bool.
08:27:55 <lwm> napping: nice link, thanks!
08:28:50 <rwbarton> vamega, it's better to just do the getDirectoryContents and catch whatever exception means the directory didn't exist
08:28:50 <lwm> napping: this is a serious resource ... there goes my printer ink
08:29:20 <rwbarton> vamega: as a general principle
08:29:22 <quchen> vamega: You cannot use an IO Bool inside a guard. You'll have to use >>= to branch on a monadic value.
08:29:37 <benzrf> hmm
08:29:43 <benzrf> what with all these view pattern extensions and what nottc
08:29:44 <benzrf> *not
08:30:06 <benzrf> i think we should find a generic way to insert various function sugars like guards into normal exprs
08:30:18 <benzrf> wait, you can have guards in a let can't you
08:30:25 <napping> or cases
08:30:30 <rwbarton> vamega: other than that, though, just use "do e <- doesDirectoryExist path; if e then getDirectoryContents path else return []"
08:30:46 <napping> uh, does that work?
08:30:55 <benzrf> vamega: or you could make it take a bool and bind it !
08:31:04 <benzrf> vamega: *make it a helper taking a bool
08:31:17 <benzrf> > let a | 3 > 4 = "wut" | 4 > 3 = "ok" in a
08:31:18 <lambdabot>  "ok"
08:32:33 <benzrf> wow, GHC is older than i am
08:32:59 <benzrf> were there any haskell reports before 98
08:33:13 <Maxdamantus> Maybe Swift's `‹exp›?`syntax could be incorporated into guards.
08:33:14 <zomg> Yeah, GHC is just 2 years younger than I am :P
08:33:25 <zomg> at least guessing from wikipedia's initial release page anyway =)
08:33:27 <darthdeus> how can i make something like   (try many1 alphaNum <|> many1 (char '_')) ? but in a smarter way
08:34:17 <lwm> benzrf: April 1990. The Haskell version 1.0 Report was published (125
08:34:17 <lwm> pages), edited by Hudak and Wadler. At the same time, the
08:34:20 <benzrf> darthdeus: why not many1 (alphaNum <|> char '_')
08:34:26 <benzrf> lwm: shit mangaba_leitosa
08:34:28 <benzrf> *man
08:34:28 <darthdeus> benzrf: awesome :P
08:34:31 <darthdeus> thanks
08:34:33 <benzrf> haskell is old-ish
08:34:57 <benzrf> for a language still popular today
08:35:15 <tdammers> as compared to C? Or JavaScript?
08:35:29 <napping> vamega: probably safer to just call getDirectoryContents and catch an exception: handleJust (guard . isDoesNotExistError) (\_ -> return []) (getDirectoryContents "foo")
08:35:35 <tdammers> (although I must admit that haskell feels significantly younger)
08:35:41 <benzrf> tdammers: js probably
08:35:45 <benzrf> C is an anachronism >:o
08:36:03 <tdammers> C is a glitch in the matrix :D
08:36:24 <benzrf> of course the matrix has glitches
08:36:27 <benzrf> it's written in C
08:36:28 <benzrf> tsk
08:36:41 <benzrf> did i ever mention that i figured out the nature of reality
08:36:51 <lwm> this paper is amazinnnnnngggg
08:36:52 <vamega> napping thanks for the info.
08:36:56 <benzrf> superpositioned particles are unevaluated thunks
08:36:58 <vamega> I've not really looked into exceptions yet
08:37:05 <benzrf> and entanglement is reference equality
08:37:11 <benzrf> because forcing one thunk forces the other :-)
08:37:18 <napping> vamega: well, that's just how getDirectoryContents reports a missing directory.
08:37:23 <vamega> So I'm going to avoid it initially.
08:37:25 <henrixh_> Hi, I have a question about paralell programming. I am first year computer engineering student trying to wrap my head around haskell. Currently I'm trying to write a paralell buddhabrot renderer. In order to render it, one need to do a lot of read and writes on random places in a mutable array. I got this working reasonably well with one thread, but my attempt at paralellism is failing. Any suggestions for how to read/write concurren
08:37:54 <rwbarton> vamega: the way you are doing it is, in general, bad because the directory might be removed between the time you call doesDirectoryExist and the time you call getDirectoryContents
08:37:54 <benzrf> also, under one interpretation of QM, stochastic particle behavior is actually deterministic, but is a function of the state of the entire universe
08:37:55 <frerich> "buddhabrot"? Hah!
08:38:01 <benzrf> clearly we're implemented in haskell using comonads!
08:38:06 <vamega> Yeah, I realize the race condition exists.
08:38:10 <rwbarton> ok
08:38:16 <vamega> But for what I'm doing it's not a problem.
08:38:23 <vamega> I'm still picking this up.
08:38:34 <vamega> I'll write a first version.
08:38:52 <vamega> Then once I look up exceptions I'll modify it to be race condition free
08:39:15 <henrixh_> http://en.wikipedia.org/wiki/Buddhabrot
08:39:34 <rwbarton> henrixh_: you got cut off after "how to read/write concurren"
08:39:40 <dagano> can someone google this for me ? : how can i get ghci to expand decimals rather than printing in scientific notation?
08:39:55 * hackagebot learn-physics-examples 0.5.0.1 - examples for learn-physics  http://hackage.haskell.org/package/learn-physics-examples-0.5.0.1 (ScottWalck)
08:40:19 <henrixh_> oh darn. Well, I'd like to modify a mutable array concurrently
08:40:39 <Jaxan> henrixh_: you can have an array per thread?
08:40:57 <rwbarton> what kind of array is it?
08:41:00 <Jaxan> henrixh_: or make buffers with points in parallel, and render those points sequential
08:41:09 <frerich> henrixh_: Can you use some divide & conquer approach, i.e. you divide the array into separate parts such that reads & writes only always happen in the same part, and then one thread processes one part?
08:41:44 <henrixh_> each thread must have read/write access to the entire array at all times
08:42:19 <Jaxan> I would generate a buffer per thread, and let OpenGL do the rendering
08:42:55 <henrixh_> in my attempt I just use a MArray and a paralell map for generating the data
08:43:03 <mangaba_leitosa> benzrf: no shit
08:43:04 <rwbarton> is it an unboxed array?
08:43:23 <henrixh_> this works nice singlethreaded, but GC kills it when it's multithreaded
08:43:27 <darthdeus> what's the best way to split a String by a Char into [String]?
08:43:32 <darthdeus> i can't seem to find anything in prelude
08:43:47 <frerich> darthdeus: Data.List.Split is the one-stop shop for all your splitting needs.
08:44:02 <napping> darthdeus: from the "split" package, IIRC
08:44:11 <darthdeus> ah awesome :) thanks guys
08:44:41 <henrixh_> Ill try Jaxans idea about a buffer per thread and joining them together at the end. Thanks for the help!
08:44:57 * hackagebot trivial-constraint 0.3.0.0 - Constraints that any type, resp. no type fulfills  http://hackage.haskell.org/package/trivial-constraint-0.3.0.0 (leftaroundabout)
08:45:00 <napping> plain MArray? An unboxed array should have significantly better GC performance
08:45:37 <henrixh_> As previously stated, Im new to haskell, but I think it's a plain MArray
08:45:45 <napping> because the GC doesn't need to rescan all the pointers all the time (and it's not very clever about it either)
08:45:53 <jamie_h> can you define temporary vars or functions in a list comprehension?
08:46:04 <henrixh_> I'll try using a boxed...
08:46:10 <napping> check out the vector or repa packages
08:46:13 <darthdeus> and for joining the [String] together with a separator back to [String]?
08:46:13 <henrixh_> sorry, unboxed :P
08:46:24 <frerich> darthdeus: 'intercalate' can do that.
08:46:25 <rwbarton> and every thread will contend on the info pointer and the card table
08:46:34 <henrixh_> bud can you get random access using repa?
08:46:52 <monochrom> > [ f x | x<-[0..1], let f n = n + 1]
08:46:52 <napping> see, with generational garbage collection, you hopefully just have to touch the first generation to collect it
08:46:54 <lambdabot>  [1,2]
08:47:06 <platz> anyone know of a good reference for learning MVectors?
08:47:17 <napping> but if you have mutable pointers in the old generation, maybe it was mutuated to point into the nursery, and that's the only reference that keeps something alive
08:47:20 <platz> or just look at hackage :)?
08:47:20 <monochrom> I learned MVectors from the doc
08:47:27 <platz> hah, ok
08:47:43 <napping> so every minor GC also has to scan all old-generation pointers that were updated, more or less
08:47:51 <henrixh_> Ah
08:48:05 <napping> and on top of that, mutable arrays are kind of rare so GHC isn't particularly clever about how much of an MArray needs to be rescanned
08:48:21 <jamie_h> thanks monochrom
08:48:39 <napping> note a thunk is a different story because it can't evaluate down to something that the original delayed form didn't have a pointer
08:48:44 <henrixh_> I will tyr it out! Thanks napping!
08:49:16 <napping> also, repa does some kinds of parallelism itself, but probably not like you need. Unboxed vector sounds best
08:49:45 <napping> rwbarton: isn't the info pointer only read while updating an array?
08:50:14 <benzrf> bbl
08:50:16 <rwbarton> hmm there's no way to atomically modify an element of an array is there?
08:50:17 <jamie_h> monochrom what if i want to use "f" in a filter/predicate?
08:50:28 <napping> hmm, I think there are some prims to do that
08:50:31 <henrixh_> Oh darn, sorry, apparently I'm already using unboxed arrays
08:50:35 <napping> but it probably doesn't matter
08:50:53 <henrixh_>  arr <- newArray (0,size*size) 0 :: IO (IOUArray Int Int)
08:50:56 <monochrom> > [ x | x <- [0..1], let f n = n==0, f x ]
08:50:57 <lambdabot>  [0]
08:50:58 <rwbarton> napping: I think when you write to a mutable array you also have to set the info pointer to the dirty array info pointer
08:51:18 <napping> even if you are writing into an already-dirty array?
08:51:25 <rwbarton> well, then you have to read the pointer :P
08:51:34 <rwbarton> I think it just does an unconditional write
08:51:39 <napping> yeah, but that's not contention, should be cacheable
08:51:49 <napping> oh, a write would be a bit worse
08:51:57 <jamie_h> monochrom ha, magic. I love Haskell :)
08:52:01 <napping> more cache contention than actually blocking, but okay
08:52:18 <rwbarton> yeah, I meant contend as in cache contention
08:52:35 <napping> well it would if it's a simple write then
08:52:49 <monochrom> not so much haskell being magical, more about popular languages imposing artificial limitations
08:52:56 <napping> henrixh_: if you're already using an unboxed array I wouldn't expect GC to be too much worse with threads
08:52:56 <rwbarton> anyways that's only for boxed arrays
08:53:09 <rwbarton> yeah I would be curious to see the whole program
08:53:42 <napping> you are compiling with optimizations, right?
08:53:50 <henrixh_> Here is the relevant code http://lpaste.net/105031
08:54:11 <henrixh_> Probably horrible code, but I'm getting better :P
08:54:26 <henrixh_> using -O3
08:54:52 <dagano> how can i get ghci to expand decimals rather than printing in scientific notation?
08:55:05 <monochrom> > [ x | x<-[0..1], let {f 0 = True; f 1 = False}, f x]
08:55:07 <lambdabot>  [0]
08:55:17 <napping> I think only up to -O2 is different, but anything should be enough to do strictness analysis, which is usually enough for arithmetic. Not sure with those pairs running around, though
08:55:29 <napping> dagano: it just uses Show, I don't know how to replace that
08:55:36 <sveit> in the haskell FFI, since Double is an instance of storable, why wouldn't I use that instead of CDouble?
08:55:36 <glguy> Turn it up to 11: http://www.haskell.org/ghc/docs/latest/html/users_guide/options-optimise.html#optimise-pkgs
08:56:15 <napping> sveit: CDouble is guaranteed to match a C double argument
08:57:17 <rwbarton> henrixh_: oh I see, you're using par not concurrency
08:57:18 <rwbarton> hmm
08:57:31 <napping> oh, that's going to be weird, if it works at all
08:57:32 <henrixh_> It did compile using -O11, but suprisingly it isn't any faster :P
08:57:36 <rwbarton> I think it could work
08:57:54 <rwbarton> but maybe not really
08:58:07 <napping> at best it's computing in parallel a linked list of points to insert, and then walking it to insert them
08:58:19 <rwbarton> right, or maybe several linked lists
08:58:29 <rwbarton> unfortunately the representations of those lists are huge
08:58:32 <napping> and that will make it impossible to fuze away the lists
08:58:42 <napping> looks like you're just picking random points
08:58:50 <napping> so run preformPass in a few different threads
08:58:59 <napping> should that be performPass?
08:59:04 <henrixh_> Yes, I might need to get better at explaining my problems...
08:59:25 <napping> random points is fine, I just didn't realize it went like that rather than systematically exploring inputs
08:59:35 <napping> that makes it easier just to run a bunch of copies, so it's fine/good
08:59:55 <henrixh_> Yes it should be performPass, I'm swedish.
09:00:00 <napping> and the rng stuff is a bit suspicious
09:00:12 <napping> "pre-form" is vaguely plausible too
09:00:32 <napping> well, as a word. perform is right here
09:00:36 <henrixh_> So, could it work by computing a mutable array per thread, then adding them together?
09:00:41 <napping> that too
09:00:56 <rwbarton> yes that sounds best
09:00:58 <napping> but I was thinking of just letting a bunch of threads draw their own points and bang on the same array
09:01:05 <napping> maybe losing some updates in the process, but whatever
09:01:21 <henrixh_> napping, can you do that? How?
09:01:37 <rwbarton> tradeoff there is potential cache contention on the shared array, vs having to add up the arrays at the end
09:01:46 <napping> uh, just forkIO (performPass arr) will run a new thread
09:01:46 <rwbarton> plus the non-atomicity
09:01:51 <napping> and they'll all update the same array
09:02:06 <napping> rwbarton: it's a graphics thing that's already approximately rendering a fractal
09:02:07 <z0d> after installing ghc-mod with cabal, how do you set it up in vim?
09:02:24 <rwbarton> right
09:02:30 <henrixh_> I don't care about loosing some updates,  but I don't really understand how.
09:02:47 <napping> If two threads do the read before either does the write, you lose 1
09:02:49 <rwbarton> do you know about concurrency vs. parallelism?
09:02:50 <p0a> Hello I am trying to learn some Parsec. Some tutorials use Text.Parsec and others use Text.ParserCombinators.Parsec. Which is the correct one?
09:02:51 <henrixh_> Starting new threads doing IO on the same array?
09:03:07 <napping> well, performPass modifies whatever array you pass
09:03:08 <henrixh_> Yes, I do.
09:03:26 <napping> so if you start several threads running performPass on the same array, they'll try to update the same array
09:03:50 <napping> now you get some data races and lost updates and all that, but I don't think you really care
09:04:09 <napping> Depending on your image size vs. cache size and stuff, it might even be faster to use separate arrays
09:04:16 <napping> and it's certainly more correct
09:04:50 <henrixh_> That actually sounds like it would work... In imperative languages, that is how I would have done it from the beginning...
09:05:24 <henrixh_> Thank you for your help napping, I'll get to it after dinner!
09:05:38 <rwbarton> BTW I wonder how well accumArray fuses
09:05:44 <rwbarton> or whether it is just better without fusion
09:06:02 <p0a> btw can I pass command line arguments and compile code on fpcomplete?
09:06:19 <napping> you can almost always just do whatever you'd do in an imperative language, as long as you write code in IO
09:06:23 <rwbarton> you don't actually need an explicit mutable array for this computation, since the pattern is captured in a library function
09:06:27 <rwbarton> :t accumArray
09:06:28 <lambdabot> Ix i => (e -> a -> e) -> e -> (i, i) -> [(i, a)] -> Array i e
09:06:46 <napping> ooh, that should work pretty nicely
09:07:09 <napping> twiddle things around a bit so you only use one random number generator and take points two at a time
09:07:31 <napping> and glance at the Core to make sure lists fused away
09:08:44 <merijn> p0a: Text.Parsec is the "new" hierarchy, Text.ParserCombinators is older, so it's best to use the former, although the latter should still work
09:09:11 <p0a> thank you
09:12:47 <davidthomas> cabal freeze is supposed to record what I most recently built with, right?
09:13:22 <davidthomas> or does it just calculate everything fresh?
09:13:36 <napping> I'd guess the second
09:13:44 <darthdeus> is there a way i can force evaluation of an unused expression?
09:13:53 <darthdeus> well not unused, but of something that wouldnt get evaluated otherwise
09:14:03 <merijn> darthdeus: Why would you want that?
09:14:15 <darthdeus> merijn: for debugging purposes mostly
09:14:51 <merijn> What exactly did you want to use it for during debugging?
09:15:12 <davidthomas> is there any way to restrict it to particular versions?  Passing it the same command line I pass to cabal install doesn't seem to work...
09:15:21 <napping> davidthomas: it should be the same unless you've run cabal update in between, or built with extra options
09:15:48 <darthdeus> merijn: i have a value bound in a do block which doesn't get evaluated normally, because i haven't written the code that uses it yet
09:15:50 <alpounet> danilo2: there's seq, or equivalently bang patterns: http://alpmestan.com/posts/2013-10-02-oh-my-laziness.html mentions it
09:16:00 <darthdeus> merijn: but i still want to evaluate it
09:16:12 <davidthomas> napping: well, I'm specifying a specific version of pandoc, and it's producing a freeze file with a different version :-\
09:16:39 <napping> davidthomas: looks unfortunate
09:16:42 <danilo2> alpounet: Hmm, thank you for the link, but It was supposed to address me? :)
09:16:45 <darthdeus> it seems that if i do   void $ return a; that doesn't evaluate it either
09:17:00 <alpounet> woups
09:17:04 <napping> it really should take all the constraint options, or remember from the last build, or something
09:17:18 <alpounet> darthdeus: see what I said above
09:17:25 <danilo2> :)
09:17:35 <darthdeus> alpounet: ah, thanks :)
09:18:47 <ReinH> darthdeus: you want something like a do { a <- ma; return (a `seq` someOtherVal) } to force a when someOtherVal is evaluated
09:19:00 <lwm> herixh: /quit
09:19:08 <lwm> oh woops ... ignore :|
09:19:26 <napping> davidthomas: wow, that's really annoying. cabal configure -v lists the selected versions and takes the flags you want
09:19:49 <alpounet> darthdeus: it's easy to get confused with these matters, but the core idea is that we have 'seq' that will evaluate values to WHNF. Bang patterns are a syntactical shortcut for 'seq': f !x = 4 just means f x = x `seq` 4. And we can have strict fields in data types, which use the same idea
09:20:01 * hackagebot squeeze 1.0.4.2 - A file-packing application.  http://hackage.haskell.org/package/squeeze-1.0.4.2 (AlistairWard)
09:20:35 <darthdeus> bang patterns are only for pattern matching, right?
09:20:39 <darthdeus> ReinH: that works, thanks :)
09:21:07 <ReinH> seq is hard to reason about :)
09:21:19 <rwbarton> there's also "evaluate" if you want to evaluate something at a particular time in an IO do block
09:21:23 <rwbarton> @hoogle evaluate
09:21:24 <lambdabot> Control.Exception.Base evaluate :: a -> IO a
09:21:24 <lambdabot> Control.Exception evaluate :: a -> IO a
09:21:24 <lambdabot> Control.OldException evaluate :: a -> IO a
09:21:30 <ReinH> rwbarton: oh nice
09:22:27 <kazagistar> and there is always deepseq...
09:23:20 <alpounet> darthdeus: bang patterns can be used whenever you define something. f !x = ... or let (!a, b) = (undefined, 4) in ... or case foo of { (a, !b, !c) -> ... } etc
09:23:49 <darthdeus> hmmm, awesome
09:24:02 <rwbarton> what does that "let" example do exactly
09:24:06 <rwbarton> > let (!a, b) = (undefined, 4) in 5
09:24:08 <lambdabot>  5
09:24:09 <rwbarton> > let (!a, b) = (undefined, 4) in b
09:24:11 <lambdabot>  *Exception: Prelude.undefined
09:24:17 <rwbarton> ok that's what I figured
09:24:23 <alpounet> yup
09:24:51 <shapr> What's the best way to get ghc 7.8 on debian/unstable? Install the package from experimental?
09:25:02 <davidthomas> napping: putting together my cabal.config with a line of bash :-P
09:25:04 <napping> shapr: install the binaries
09:25:07 <davidthomas> join is my friend
09:25:21 <shapr> napping: eh, I guess I could do that
09:25:29 <napping> That's what I always do
09:26:22 <napping> easier than messing with sources and maybe accidentally getting other experimental stuff, if you just want ghc
09:28:31 <napping> conal: have you considered implementing unamb as a primitive operation?
09:29:08 <conal> napping: yes. i suspect it'll be necessary for speed (and maybe correctness).
09:29:28 <conal> napping: not something i wanted to take on by myself.
09:30:17 <napping> I wouldn't know, but it might be a reasonable introduction to RTS hacking
09:30:26 <conal> napping: sure. might be.
09:30:51 <ReinH> napping: That implies that there is such a thing as a reasonable introduction to RTS hacking ;)
09:32:18 <davnils> so.. anyone working on type level lenses?
09:33:42 <awestroke> davnils: how would that work?
09:34:25 <davnils> well it's probably non-trivial
09:34:38 <ReinH> davnils: what would they do?
09:35:00 <enthropy> davnils: look at HList or Vinyl?
09:35:18 <davnils> shall be read!
09:58:00 <darthdeus> http://stackoverflow.com/questions/24020739/what-is-a-correct-way-of-doing-countid-in-esqueleto-and-yesod
09:58:54 <bergmark> i have a count function somewhere
10:04:29 <benzrf> hmmm
10:04:37 <benzrf> is there a tool i can run over a github url to get haddock
10:04:45 <albeit> How can I convert a strict Bytestring to a lazy Bytestring? (Final goal is a lazy Text)
10:05:34 <glguy> albeit: Data.ByteString.Lazy.fromStrict
10:06:30 <albeit> glguy: Argh, for whatever reason Googling brings me to an old version of Data.ByteString.Lazy that doesn't have fromStrict. Thanks glguy
10:06:53 <coppro> albeit: yeah, don't trust google
10:06:55 <coppro> try hayoo
10:06:56 <glguy> Just type: hackage.haskell.org/package/____________
10:07:07 <glguy> you need for magic search tools
10:07:15 <glguy> or to expose yourself to hackage's package list
10:07:25 <coppro> @hayoo Data.ByteString.Lazy
10:07:26 <lambdabot> Unknown command, try @list
10:07:26 <SrPx> > data Tree = Node Tree Tree | Leaf Int; fold f g (Tree a b) = f (fold f g a) (fold f g b); fold f g (Leaf a) = g a; depth = (+ 1) . (fold max (const 1)); main = putStrLn (depth (Node (Node 1 2) 3))
10:07:28 <lambdabot>  <hint>:1:1: parse error on input ‘data’
10:07:41 <glguy> No need for*
10:08:10 <SrPx> Is my code above correct for depth?
10:08:58 <bergmark> darthdeus: answered
10:12:35 <kazagistar> there should be a "newest version of this code" button on hackage
10:13:01 <ReinH> kazagistar: I found a chrome extension for that
10:13:15 <ReinH> called hackage-fu
10:13:23 <ReinH> https://github.com/statusfailed/hackage-fu
10:13:55 <jfischoff> its in the chrome play store
10:13:58 <kazagistar> ... um, that does not seem like a very good solution
10:14:05 <jfischoff> no it is not
10:14:14 <jfischoff> but it does happen to work great
10:14:23 <awestroke> does hackage-server accept pull requests?
10:14:33 <kazagistar> not for firefox or other users?
10:14:48 <jfischoff> sort of, I think that the current github is ahead of the server a bit
10:14:54 <jfischoff> so yes
10:15:04 <jfischoff> but I’m not sure how often the server is updated
10:15:20 <jfischoff> https://github.com/haskell/hackage-server
10:15:28 <jfischoff> there is also #hackage I think
10:15:49 <kazagistar> I mean, right now I can click "contents" and then the newest version, and then the source file again
10:16:03 <jfischoff> yeah it is not very user friendly
10:17:54 <platz> I like hackage-fu a lot
10:18:55 <sveit> is there a convention on choosing from the seemingly huge amounts of array packages? i.e. vector vs all the built-in haskell arrays vs repa vs ...? also, is vector implemented in terms of haskell's built-in arrays or is it completely it's own?
10:19:47 <kazagistar> isnt this what keeps software shitty? instead of solving the problems directly, we build another layer on top of the problems to hide them :P
10:19:59 <fiatjaf_> I'm running `cabal install yesod` and I'm getting: "Loading package entropy-0.3 ... linking ... ghc: /home/fiatjaf/.cabal/lib/i386-linux-ghc-7.6.3/entropy-0.3/HSentropy-0.3.o: unknown symbol `cpu_has_rdrand'"
10:20:48 <jfischoff> kazagistar: yes, yes it is
10:21:38 <bergmark> fiatjaf_: try installing yesod-platform instead
10:22:08 <bergmark> it lists entropy 0.2.2.4 instead of 0.3 as the dependency
10:22:51 <fiatjaf_> ok, I successfully installed yesod-bin and created a project with `yesod init`, inside it cabal is apparently managing to install everything he needs.
10:23:11 <kazagistar> thus I will boycott hackage-fu for moral reasons, until I care enough to fix the problem directly. Hah!
10:23:12 <enthropy> sveit: if you need multiple dimensions, that rules out vector (though repa arrays can use vector IIRC)
10:24:49 <bergey> sveit: My impression is: vector is well-liked, and array is not.  vector is the usual choice for 1D data.  repa is officially experimental (like many things Haskell), and certainly not as stable (as in, API changes, not crashes).
10:25:41 <rwbarton> array is fine
10:25:45 <geekosaur> array is low level stuff generally used in implementations of useful higher level tools like vector
10:25:49 <rwbarton> I don't really understand all the array-hate/vector-love
10:26:00 <geekosaur> you can use it directly but it's more fiddly since it's lower level
10:26:20 <enthropy> the types in array are easier than those in repa
10:26:48 <yac> what happens when you zip Either and FilePath?
10:27:04 <yac> it appears it adds the FilePath intho the Either's right
10:27:09 <yac> and I can't get it out
10:27:10 <ReinH> yac: what do you mean?
10:27:28 <rwbarton> hopefully you get a type error?
10:27:31 <enthropy> zip is for lists, unless you're talking about some other definition?
10:27:45 <yac> yeah, I've got a  [Either]
10:27:54 <ReinH> yac: show us some code
10:28:10 <ReinH> because zip just tuples two lists together.
10:28:16 <ReinH> It doesn't care what the contents are
10:28:40 <ReinH> :t zip
10:28:41 <lambdabot> [a] -> [b] -> [(a, b)]
10:28:55 <ReinH> zip works for any a and b so it can't do anything special for Either or FilePath
10:30:26 <pavonia> @hoogle Traversable t => t a -> t b -> t (a, b)
10:30:27 <lambdabot> Data.ByteString.Builder.Prim (>*<) :: Monoidal f => f a -> f b -> f (a, b)
10:30:27 <lambdabot> Data.Sequence zip :: Seq a -> Seq b -> Seq (a, b)
10:30:28 <lambdabot> Prelude zip :: [a] -> [b] -> [(a, b)]
10:31:08 <yac> ReinH: https://gist.github.com/yaccz/293d2fdc889557d559f1
10:31:24 <gdoteof_> per rwbarton's suggestion yestereday, i am using MVar to control flow to a named pipe to ensure atomic writes.  there are a variety of these pipes, and I have a `type Locks = Map String (MVar ())` to maintain them.  however, that Map is used/modified by different threads; so I actually am (trying) using an IORef (Map String (MVar ()))
10:31:59 <Darwin226> Hey. So Set elements are always unique, right? How does it know what 'equals' means?
10:32:02 <gdoteof_> but i am having problems creating MVars to add to the map inside of atomicModifyIORef'
10:32:22 <gdoteof_> http://lpaste.net/105035
10:32:50 <sveit> geekosaur: so vector is implemented in terms of array?
10:32:55 <ReinH> yac: Yes, that zipped ecsvs with args.
10:32:59 <rwbarton> gdoteof_, use a(nother) MVar :)
10:33:17 <geekosaur> I don't recall if vector is, but there are certainly other things implemented on top of Array
10:33:24 <rwbarton> vector is actually implemented with the same underlying GHC primitives as Array
10:33:41 <gdoteof_> rwbarton: i was definitely thinking that.. but shouldn't an IORef work?
10:33:48 <rwbarton> well, vector supports other kinds of data storage too
10:33:51 <mmachenry> rwbarton: MVar's are like violence. If it doesn't fix your problem it's because you're not using it enough.
10:34:38 <rwbarton> gdoteof_: hmm, I guess it should, can't you create the MVar before you modify the IORef?
10:34:52 <jfischoff> mmachenry: same with transformer stacks
10:36:02 <ReinH> yac: So why do you think zip is doing something unusual?
10:36:49 <yac> well, I'm getting Either Text.Parsec.Error.ParseError CSV, String and don't know how to work it
10:37:03 <ReinH> yac: No you aren't
10:37:07 <ReinH> That's not a valid type.
10:37:12 <ReinH> You're getting a tuple.
10:37:13 <nadirs> @ty Data.Set.insert --Darwin226
10:37:14 <lambdabot> Ord a => a -> S.Set a -> S.Set a
10:37:17 <ReinH> A list of tuples, in fact.
10:37:30 <ReinH> You're getting [(Either ParseError CSV, String)]
10:37:40 <gdoteof_> rwbarton: oh yeah i totally could
10:37:54 <nadirs> Darwin226: and `class Eq a => Ord a where ...`
10:38:19 <Darwin226> nadirs: I see. Is there a way I can make a set use my own compare function?
10:38:19 <rwbarton> you can't do IO "inside" atomicModifyIORef' because you'd have to "hold" the IORef for an indefinitely long time
10:38:22 <rwbarton> which doesn't make sense
10:39:04 <ReinH> yac: Why did you zip them if you don't want to have a list of tuples?
10:40:17 <nadirs> Darwin226: I don't think so. Since Data.Set functions take instances of `Eq` type class they already have their definition of equality. (full disclosure: I'm a beginner so I might very well be wrong :P)
10:41:24 <moghedrin> Darwin226: If you want to do that, you can use Data.Map instead.
10:41:40 <Darwin226> moghedrin: How is that the same?
10:43:06 <ReinH> Darwin226: you can use a newtype wrapper to provide your own instances
10:43:25 <moghedrin> Darwin226: Oooh. I like ReinH's answer much better.
10:43:27 <nadirs> ReinH: nice!
10:43:36 * moghedrin is still a newb at this, lol
10:44:06 <heebee> Hi, why is the following accepted by GHC? 'mempty 1 2 3:: M.Map Int Int' ?
10:44:23 <heebee> I can add as many arguments as I like after the 'mempty', what's going on?
10:44:39 <enthropy> there is an instance Monoid b => Monoid (a -> b) where mempty = const mempty
10:44:54 <Darwin226> ReinH: I suspected I could but this doesn't really fit what I want. I want uniqueness in the set based on some loose idea of equivalence. I don't want to implement equality itself that loosely
10:45:24 <ReinH> Darwin226: you're only defining equality for the newtype, not for the underlying type
10:45:24 <heebee> enthropy: aah, I see
10:45:31 <heebee> enthropy: yeah, that'd do it, thanks!
10:47:07 <Darwin226> ReinH: So basically I alias a type, make my own equality on it and then use it instead of the aliased type?
10:47:30 <ReinH> Darwin226: right, you use it for set membership, and then unwrap to get the underlying type back
10:47:45 <ReinH> it's not an alias, though, it's a newtype wrapper
10:47:54 <ReinH> an alias would be `type', which doesn't do what you want
10:48:20 <nadirs> I've been trying to figure out this exercise in Typeclassopedia (→ http://www.haskell.org/haskellwiki/Typeclassopedia#Laws_2): can I use the original "Interchange" law to solve it? If not, can you point me to some public solution of that exercise?
10:49:13 <nadirs> I found someone's solution on Github but I'm not sure it's valid
10:49:13 <ReinH> nadirs: sure you can
10:49:42 <nadirs> ReinH: ok, I wasn't sure if it required you to not use that specific law. Thanks!
10:50:18 <carp_> Hi, I've got a question about elemIndex, namely: why can't it return Integer?
10:50:45 <rwbarton> @hoogle elemIndex
10:50:46 <lambdabot> Data.List elemIndex :: Eq a => a -> [a] -> Maybe Int
10:50:46 <lambdabot> Data.ByteString.Char8 elemIndex :: Char -> ByteString -> Maybe Int
10:50:46 <lambdabot> Data.ByteString.Lazy.Char8 elemIndex :: Char -> ByteString -> Maybe Int64
10:51:17 <rwbarton> looks like there is no genericElemIndex
10:51:36 <ReinH> carp_: what happens if the element isn't in the list?
10:51:38 <Darwin226> ReinH: I'm not sure I get what I need to do here. Do I have to explicitly unwrap to get my underlying type every time I get an element out of my set?
10:51:53 <ReinH> Darwin226: yes, but you can abstract that easily
10:52:07 <carp_> @ReinH: It runs forever.
10:52:08 <lambdabot> Unknown command, try @list
10:52:29 <ReinH> carp_: so it would be a partial function
10:52:42 <ReinH> well, it would be a bottom of some sort, but not necessarily non-termination
10:52:45 <Darwin226> ReinH: How? Wouldn't that mean I have to provide alternate implementations of all of the Set's functions just to hide the fact I'm working with wrappers?
10:53:04 <rwbarton> I'm confused
10:53:14 <rwbarton> carp_: elemIndex returns Maybe Int which is different from Integer in two ways
10:53:17 <joshc> seems odd, what if your crazyElemIndex was given an empty list?
10:53:22 <rwbarton> (1) Int vs Integer, (2) Maybe vs not
10:53:29 <rwbarton> which are you asking about (or both?)
10:53:41 <ReinH> carp_: So it wouldn't be non-termination, it would be an error.
10:53:55 <ReinH> And we don't need a runtime exception when we have Maybe to represent "zero or one" values.
10:53:56 <carp_> @rwbarton: just the Int vs Integer part.
10:53:56 <lambdabot> Unknown command, try @list
10:54:13 <carp_> I hadn't considered the runtime part of things.
10:54:52 <rwbarton> Okay
10:55:00 <ReinH> It's Int vs Integer because:
10:55:02 <ReinH> > maxBound Int
10:55:03 <rwbarton> All the index-y list functions use Int
10:55:03 <lambdabot>  Not in scope: data constructor ‘Int’
10:55:04 <lambdabot>  Perhaps you meant one of these:
10:55:04 <lambdabot>    ‘In’ (imported from Lambdabot.Plugin.Haskell.Eval.Trusted),
10:55:04 <lambdabot>    ‘InR’ (imported from Lambdabot.Plugin.Haskell.Eval.Trusted)
10:55:10 <ReinH> > maxBound :: Int
10:55:12 <lambdabot>  9223372036854775807
10:55:24 <ReinH> is a pretty big list.
10:55:48 <rwbarton> because it's faster, and normally you don't have a list whose length is larger than the maximum Int anyways (especially on 64-bit systems as ReinH points out)
10:55:48 <carp_> Hahah, that answers it, then. Thanks for the help!
10:56:20 <rwbarton> though it's in principle possible thanks to laziness
10:56:30 <ReinH> True
10:57:06 <ReinH> if your list comes is produced by a guarded recursion, for isntance
10:57:09 <ReinH> s/comes //
10:58:27 <ReinH> Still, I think it's a pretty safe decision ;)
11:00:13 * hackagebot bound 1.0.3 - Making de Bruijn Succ Less  http://hackage.haskell.org/package/bound-1.0.3 (EdwardKmett)
11:10:15 <quchen> repeat 1 -- longer than max_int
11:11:34 <ReinH> quchen: boom :)
11:13:29 <Forgetaboutit> Is there a lens operator to cons onto a list?
11:13:44 <ReinH> :t cons
11:13:45 <lambdabot> Cons s s a a => a -> s -> s
11:13:55 <edwardk> not onto a list targeted by a lens
11:14:10 <edwardk> you can use %~ (x:)    of cours though
11:14:17 <ReinH> edwardk: but there should be ;)
11:14:22 <edwardk> ReinH: no.
11:14:31 <rwbarton> the naming scheme wouldn't work!
11:14:35 <ReinH> edwardk: It should be <|~ :p we've been over this
11:14:38 <quchen> ReinH, rwbarton: The use of unboxed types in Data.List is probably something that would be hard to achieve using Integer, so I'm going to guess that's the reason
11:14:46 <Forgetaboutit> edwardk: thanks, much better than <>~ [x]
11:15:01 <edwardk> ReinH: it violates conventions. foo +~ bar is foo %~ (+ bar)    so the cons operator would break that convention
11:15:07 <edwardk> <>~ [x] is appending
11:15:17 <quchen> And :~ is illegal :-(
11:15:27 <ReinH> edwardk: fine :p
11:15:30 <Forgetaboutit> I know, but I don't mind the order :)
11:18:24 <benzrf> @let data Assign var val = var := val
11:18:25 <lambdabot>  Defined.
11:18:32 <benzrf> oh wait shit
11:18:35 <benzrf> @undefine
11:18:35 <lambdabot> Undefined.
11:18:45 <benzrf> @let data Assign var val = var := val deriving (Show, Eq, Ord)
11:18:46 <lambdabot>  Defined.
11:18:54 <benzrf> > "foo" := 3
11:18:56 <lambdabot>  "foo" := 3
11:19:45 <benzrf> :t set
11:19:46 <lambdabot> ASetter s t a b -> b -> s -> t
11:19:48 <benzrf> hmm
11:19:51 <benzrf> :t (.=)
11:19:52 <lambdabot> MonadState s m => ASetter s s a b -> b -> m ()
11:20:54 <benzrf> hmmmmmmmm
11:21:19 <benzrf> shit
11:22:42 <benzrf> @undefine
11:22:42 <lambdabot> Undefined.
11:23:18 <tgeeky> benzrf: lambdabot supports private messages for all functions
11:23:31 <benzrf> right right
11:25:47 <benzrf> :t (.=)
11:25:48 <lambdabot> MonadState s m => ASetter s s a b -> b -> m ()
11:25:55 <benzrf> @hoogle MonadState s m => ASetter s s a b -> b -> m ()
11:25:56 <lambdabot> Warning: Unknown type ASetter
11:25:57 <lambdabot> No results found
11:26:00 <benzrf> lame!
11:26:07 <benzrf> what's the prefix version of (.=), if any?
11:27:05 <moghedrin> set
11:27:10 <moghedrin> Errr.
11:27:11 <moghedrin> No.
11:27:17 <moghedrin> assign
11:27:21 <gamegoblin> How would I implement the regex “a[ab]+a” in Parsec or Attoparsec?
11:28:17 <albeit> Is there a concise way to do Map a (Maybe b) -> Map a b? Right now I'm doing a filter then map..
11:28:49 <rwbarton> :t Map.alter
11:28:50 <lambdabot>     Not in scope: ‘Map.alter’
11:28:50 <lambdabot>     Perhaps you meant ‘M.alter’ (imported from Data.Map)
11:28:52 <rwbarton> :t M.alter
11:28:53 <lambdabot> Ord k => (Maybe a -> Maybe a) -> k -> M.Map k a -> M.Map k a
11:28:56 <rwbarton> :t M.adjust
11:28:56 <lambdabot> Ord k => (a -> a) -> k -> M.Map k a -> M.Map k a
11:28:59 <rwbarton> argh
11:29:06 <rwbarton> what's the other one
11:29:09 <rwbarton> :t M.update
11:29:09 <lambdabot> Ord k => (a -> Maybe a) -> k -> M.Map k a -> M.Map k a
11:29:23 <rwbarton> oh but those only affect one key, sorry
11:29:49 <albeit> Yeah I just need to convert any elements that are (a, Just b) to (a,b)
11:30:03 <albeit> And throw out all (a, Nothing)s
11:30:07 <Iceland_jack> albeit: that about using filter?
11:30:11 <warpy> :t M.map
11:30:12 <lambdabot> (a -> b) -> M.Map k a -> M.Map k b
11:30:17 <warpy> use that ^
11:30:17 <gamegoblin> :t M.mapMaybe
11:30:18 <lambdabot> (a -> Maybe b) -> M.Map k a -> M.Map k b
11:30:33 <rwbarton> actually use that ^
11:30:36 <albeit> Iceland_jack: Yeah I'm doing a filter with isJust then a map with pattern match on Just right now... but it seem sugly
11:30:39 <warpy> :t M.map . fromJust
11:30:40 <lambdabot> Maybe (a -> b) -> M.Map k a -> M.Map k b
11:30:58 <quchen> :t M.mapMaybe id -- .
11:31:00 <lambdabot> M.Map k (Maybe b) -> M.Map k b
11:31:04 <benzrf> bleh
11:31:17 <warpy> actually that would work
11:31:23 <albeit> Ah thats what I'm looking for, thanks gamegoblin quchen
11:31:38 <warpy> what happened benzrf
11:31:42 <benzrf> @let data Assign var val = var := val deriving (Show, Eq, Ord)
11:31:44 <lambdabot>  Defined.
11:31:48 <benzrf> warpy: bad assumptions
11:31:59 <croyd> gamegoblin: check out the `many1` combinator
11:32:16 <benzrf> @let let' (l := v) = l .= v
11:32:17 <lambdabot>  Defined.
11:32:28 <benzrf> edwardk: check it out:
11:32:29 <warpy> benzrf: ah yes. i am also having a bad case of bas assumptions today
11:32:38 <benzrf> :t runState
11:32:39 <lambdabot> State s a -> s -> (a, s)
11:32:54 <gamegoblin> croyd: Just many1 by itself won’t do it
11:32:58 <quchen> benzrf: Lambdabot supports private sessions too
11:33:06 <benzrf> oh wait shit
11:33:12 <benzrf> that doesnt work right cuz of fixity
11:33:17 * benzrf sobs
11:33:52 <benzrf> > runState (do {let' $ _1 := 3; let' $ _2 := 5}) (1, 2)
11:33:54 <lambdabot>  ((),(3,5))
11:34:32 <croyd> gamegoblin: something like `char 'a' >> many1 (oneOf "ab") >> char 'a'`
11:34:49 <gamegoblin> croyd: that will fail. Try it on “aba”
11:35:01 <gamegoblin> croyd: The many1 is greedy and will consume the final ‘a’ that the last “char ‘a’” is looking for
11:35:27 <croyd> gamegoblin: ok ok
11:37:48 <croyd> gamegoblin: how about `between`?
11:38:21 <gamegoblin> Nope, same problem.
11:38:29 <zq> hm
11:38:38 <gamegoblin> croyd: between just do “open >> between >> close” so same issue
11:38:38 <zq> @hoogle String -> Int
11:38:40 <lambdabot> Test.HUnit.Base Label :: String -> Node
11:38:40 <lambdabot> Prelude error :: [Char] -> a
11:38:40 <lambdabot> Prelude length :: [a] -> Int
11:39:32 <zq> not exactly haskell-centric, but anyone know a decently uniform function that maps from short char sequences to an integer in [0, N) for a selectable N?
11:40:00 <gamegoblin> zq: Can you give an example?
11:40:17 * hackagebot haggis 0.1.2.0 - A static site generator with blogging/comments support  http://hackage.haskell.org/package/haggis-0.1.2.0 (TychoAndersen)
11:40:30 <gamegoblin> zq: By uniformly maps do you mean a hash, or...?
11:40:33 <warpy> :t :=
11:40:35 <lambdabot> parse error on input ‘:=’
11:40:44 <warpy> ...
11:40:54 <zq> gamegoblin: let { myhash :: String -> Int -> Int; myhash "Bob" n = realhash "Bob" `rem` n; }
11:40:55 <hayashi> :t (:=)
11:40:56 <lambdabot> var -> val -> Assign var val
11:41:02 <zq> gamegoblin: yes, like a hash function
11:41:07 <zq> in fact it is a hash func
11:41:23 <zq> i thought about something like libketama but no
11:41:40 <gamegoblin> Does it need to be cryptographically secure or just be somewhat unformly distributed?
11:41:48 <Forgetaboutit> @pl (\a -> a & foo &~ (+1))
11:41:48 <lambdabot> (line 1, column 17):
11:41:48 <lambdabot> unexpected "~"
11:41:48 <lambdabot> expecting white space or simple term
11:42:00 <zq> the latter
11:42:08 <zq> i'd never use such a thing for crypto
11:42:12 <gamegoblin> So you want to go from [Char] -> Int ?
11:42:28 <zq> see the signature i gave for myhash
11:42:38 <zq> i'd like to be able to modulo the output but still be uniform
11:43:08 <gamegoblin> Ah ok. Well if your output is uniform, your output modulo whatever should still be uniform. Let me see if I can whip up a little function. Gimme a few.
11:43:43 <quchen> ?hackage hashable -- This might be relevant.
11:43:43 <lambdabot> http://hackage.haskell.org/package/hashable -- This might be relevant.
11:43:52 <zq> well if you're doing something fancy like xoring ascii chars
11:44:20 <gamegoblin> Yes I was going to do to an xor and bit shift based hash on their ascii values
11:44:21 <zq> then "uniform" could be over the range of [0, M) where gcd(N, M) = 1 or something
11:44:26 <zq> then the modulo isn't uniform
11:44:32 <Forgetaboutit> @pl (\a -> a & (foo &~ (+1)))
11:44:32 <lambdabot> (line 1, column 19):
11:44:33 <lambdabot> unexpected '~'
11:44:33 <lambdabot> expecting simple term
11:44:46 <Forgetaboutit> @pl (\a -> a & (foo %~ (+1)))
11:44:47 <lambdabot> (line 1, column 19):
11:44:47 <lambdabot> unexpected '~'
11:44:47 <lambdabot> expecting simple term
11:45:18 * hackagebot hquery 0.1.1.0 - A query language for transforming HTML5  http://hackage.haskell.org/package/hquery-0.1.1.0 (TychoAndersen)
11:45:20 * hackagebot haggis 0.1.2.1 - A static site generator with blogging/comments support  http://hackage.haskell.org/package/haggis-0.1.2.1 (TychoAndersen)
11:45:30 <gamegoblin> zq: you can just scale it down to a range rather than modulo
11:45:48 <fread2282> @pl (\a -> a & foo %~ (+1))
11:45:48 <lambdabot> (line 1, column 17):
11:45:49 <lambdabot> unexpected "~"
11:45:49 <lambdabot> expecting white space or simple term
11:46:02 <Forgetaboutit> fread2282: I don't get what the issue is ...
11:46:33 <zq> gamegoblin: how, exactly? the output of xor-shift would be [0, 256), right? how do you go from that to, say, [0, 13)?
11:47:01 <rwbarton> @pl (\a -> a & foo % (+1))
11:47:02 <lambdabot> (% (1 +)) . (& foo)
11:47:04 <gamegoblin> zq: The output of a non-dead-simply xor-shift-op hash would be the range of all Ints
11:47:09 <rwbarton> Forgetaboutit: I think @pl's parser is just wrong
11:47:28 <fread2282> @pl (\a -> a & (over foo  (+1)))
11:47:29 <lambdabot> (& over foo (1 +))
11:47:57 <Forgetaboutit> fread2282: Thanks, I already doubted my memory
11:48:20 <kazagistar> pl uses a parser different from the GHC parser?
11:48:39 <gamegoblin> zq: so you can modulo by the next highest power of two over your N, and then do some floating point math and rounding to scale it down to your exact N
11:49:09 <carter> or do a bitwise AND with a mask
11:49:39 <zq> carter: that'd only work if N is a power of 2
11:49:46 <zq> or rather 2^k-1
11:49:51 <gamegoblin> carter: the compiler *should* do that for you if N is a power of two
11:49:52 <carter> zq: you can do a fixup
11:49:58 <zq> a what
11:50:05 <carter> just use mod :)
11:50:13 <zq> no.
11:50:19 <zq> see above, mod is non-uniform
11:50:24 <zq> think of rand() % N
11:51:23 <carter> number theory is tricky
11:51:33 <carter> generate a stream of unbiased bits
11:51:38 <carter> use that
11:52:25 <gamegoblin> zq: halfway done, few more minutes...
11:54:02 <edwardk> benzrf: cute. i actually use := in a monad i have for functional hybrid modeling
11:54:21 <jamie_h> if type classes are a fairly similar concept to interfaces, would "instance"s be analogous to abstract classes?
11:56:05 <pdxleif> "instances"s would be analogous to "implements Foo"
11:56:16 <pdxleif> You're thinking Java interfaces?
11:56:30 <benzrf> typeclasses are actually very similar to java interface
11:56:30 <benzrf> s
11:57:01 <benzrf> the main difference is that you choose which argument indicates the implementatino
11:57:08 <benzrf> *implementation
11:57:12 <Forgetaboutit> except that you can't implement them for existing classes
11:57:28 <hiptobecubic> Forgetaboutit, ?
11:57:45 <benzrf> hiptobecubic: you must declare that you are implementing an interface at class decl
11:57:50 <Forgetaboutit> hiptobecubic: in Java, you can't implement IFoo for a foreign class
11:57:53 <benzrf> hiptobecubic: while haskell allows orphan instances
11:58:12 <hiptobecubic> oh, yes. I thought you were implying the other way around
11:58:40 <gamegoblin> zq: finished has, making the little scaling stuff now
11:58:45 <gamegoblin> zq: Hash*
11:58:54 <pdxleif> Also, typeclass instances can have constraints on type params
11:59:01 <pdxleif> And you can derive them
12:00:20 * hackagebot bytes 0.14.0.1 - Sharing code for serialization between binary and cereal  http://hackage.haskell.org/package/bytes-0.14.0.1 (EdwardKmett)
12:00:22 * hackagebot hashable-extras 0.2.0.1 - Higher-rank Hashable  http://hackage.haskell.org/package/hashable-extras-0.2.0.1 (EdwardKmett)
12:02:06 <hiptobecubic> edwardk, when are higher order hashables needed in polymorphic recursion?
12:02:31 <edwardk> hiptobecubic: try writing a syntax tree using Bound, then make it Hashable.
12:02:52 <carter> try?
12:02:53 <edwardk> wrote it because i needed it ;)
12:03:11 <edwardk> all of ermine needs those classes
12:03:26 <warpy> pdxleif: well, you can sort of do that in java too using generics
12:04:07 <fvdb_> Hello I came form c++, clangcomplete and vim.
12:04:07 <fvdb_> Now i want to learn some haskell.
12:04:14 <fvdb_> In the moment i am reading the books real world haskell and learn you a haskell.
12:04:22 <pdxleif> warpy: I was thinking of how the Monoid instance for Option a has a Monoid constraint on a - Java has something similiar?
12:04:33 <edwardk> fvdb_: those offer a good starting point
12:04:55 <fvdb_> My Question is:
12:04:56 <fvdb_> Should I switch to emacs or should i stay with vim.
12:04:56 <fvdb_> An IDE is not my first choice.
12:05:05 <warpy> pdxleif: sure, you can put constraints on generic type parameters of the interfaces
12:05:13 <pdxleif> fvdb_: I think vim is fine for Haskell.  It's what I use.
12:05:15 <gamegoblin> zq: did you want [0, N) or (0, N] or [0, N] or what?
12:05:20 * hackagebot semigroupoids 4.0.2.1 - Semigroupoids: Category sans id  http://hackage.haskell.org/package/semigroupoids-4.0.2.1 (EdwardKmett)
12:05:22 * hackagebot tpdb 0.9.6 - Data Type for Rewriting Systems  http://hackage.haskell.org/package/tpdb-0.9.6 (JohannesWaldmann)
12:05:25 <warpy> fvdb_: use vim. it is what most haskell people use
12:05:35 <pdxleif> The syntax highlighting should be fine.  There's add-ons you can get, like syntastic, youcompleteme, etc...
12:05:47 <pdxleif> But you should be able to keep using vim like you do w/ c++.
12:06:12 <Forgetaboutit> pdxleif: class Option<A extends Monoid<?>> { ... } -- super ugly though
12:06:14 <carter> fvdb_: whatever your favorite editor is, use
12:06:25 <fvdb_> Ok thank you. This is what i wanted to hear.
12:06:25 <warpy> i want to witness a day when edwardk does not publish a package to hackage
12:06:26 <pdxleif> wow, learn something new every day
12:06:37 <zq> gamegoblin: [0, N). don't kill yourself over it, Data.Hashable.hash with some floating point scaling is okay, too
12:06:52 <hiptobecubic> warpy, be careful what you wish for
12:06:52 <gamegoblin> zq: Just finished. Let me test.
12:07:13 <warpy> hiptobecubic: come on, he deserves a vacation ...
12:07:22 <edwardk> fvdb_: i write everything in vim
12:07:25 <edwardk> warpy: i don't ;)
12:07:34 <benzrf> edwardk++
12:07:37 <benzrf> vim \o/
12:08:44 <hiptobecubic> edwardk, has type-inspection been smoothed out yet? I gave up on it a few months ago and haven't revisited it.
12:08:59 <edwardk> type-inspection?
12:09:16 <edwardk> warpy: i'm takng one after zurihac for a few days =)
12:09:16 <hiptobecubic> edwardk, as in "tell my the type of the expr under the cursor"
12:09:20 <hiptobecubic> "tell me*"
12:09:29 <fread2282> fvdb_: emacs can be more powerful and I hear evil mode is good
12:09:38 <edwardk> hiptobecubic: i'm given to understand ghc-mod can do that nicely
12:09:59 <edwardk> see begriffs haskell vim defaults
12:10:00 <warpy> edwardk: ah great!
12:10:06 <edwardk> https://github.com/begriffs/haskell-vim-now
12:10:08 <hiptobecubic> fread2282, it probably does alright, but the vim plugin ecosystem is enormous
12:10:18 <fread2282> ghc-mod does vim? then nevermind
12:10:20 <gamegoblin> zq: give this a whirl http://lpaste.net/105037
12:10:31 <fread2282> hiptobecubic: the emacs package ecosystem is also large
12:10:43 <gamegoblin> zq: A whole lot of that can be inlined, but I wanted to make it super readable
12:11:03 <zq> ls
12:11:24 <gamegoblin> zq: It’s the DJB hash function
12:13:03 <gamegoblin> zq: If you are super considered about speed, the multiplication by 33 can be replaced by a bitshift of 5 and an addition. I’m not sure if GHC will make that optimization for you or not.
12:14:09 <rwbarton> the LLVM backend might
12:15:18 <zq> iirc, rem is faster for unsigned
12:15:21 <zq> than mod
12:15:39 <hiptobecubic> benchmark, folks
12:16:03 <ReinH> If you are super considered about speed, measure whatever is slow and find out why it is slow
12:16:05 <ReinH> then fix that
12:16:54 <zq> yes, but rem is never slower than mod
12:17:47 <gamegoblin> I’m just saying that on all modern architectures I know about, a bitshift and addition is cheaper than a multiplication, and the modification to the code is minimal. I just left it as a multiplication for readability.
12:18:41 <gamegoblin> h*33 vs (h << 5) + h
12:18:54 <gamegoblin> Not << because this is Haskell, not C, but you get the idea
12:20:23 <nicoo> gamegoblin: LLVM is probably better at that kind of optimizations than you
12:20:51 <zq> gamegoblin: using floor instead of round?
12:21:22 <gamegoblin> nicoo: For C I’m sure of it, I have never really explored the internals of the GHC -> ASM chain
12:21:46 <gamegoblin> zq: If you use round it’ll be [0, N], I believe
12:22:41 <nicoo> gamegoblin: AFAIK, if you use the LLVM backend and your integers are unboxed, it should get optimized. If they aren't unboxed, the gain in unboxing is probably greater that the gain in removing a multiplication :]
12:22:59 <zq> 7.8.2 dpesm
12:23:07 <zq> doesn't work with 3.5, anyway
12:23:25 <gamegoblin> zq: Hm what?
12:23:28 <jhbecares> is the following data Top a b = E | C a a | D a b     a correct definition? I was said that it was incorrect, but for ghc it seems to be fine...
12:23:29 <roconnor> is (Functor (p a)) => ... a valid Haskell 98 constraint where p and a are variables?
12:24:10 <zq> gamegoblin: disregard, keyboard focus issues
12:24:17 <gamegoblin> roconnor: I think you need multiparamtypeclasses extension
12:24:59 <gamegoblin> Or… Actually I’m not sure if I’m parsing your question correctly
12:25:00 <rwbarton> roconnor: I think not
12:25:10 <jomg> gamegoblin: probably not multiparam-typeclasses (since p a is in parentheses), but maybe flexiblecontexts
12:25:23 <warpy> hah this! https://github.com/maxpow4h/swiftz
12:25:28 <gamegoblin> jomg: you are correct. I almost always use them together and get them mixed up.
12:25:38 <warpy> "Swiftz is a Swift library for functional programming."
12:26:11 <roconnor> gamegoblin: Functor isn't a multiparameter type class.
12:26:29 <gamegoblin> roconnor: yes I just realized that, see jomg’s comment
12:26:52 <roconnor> ghc hasn't complained.
12:27:16 <rwbarton> hmm
12:27:34 <roconnor> my langauge features listed are only PatternGuards and DeriveFunctor, both which shouldn't apply.
12:29:04 <gamegoblin> zq: did that hash function work for you?
12:29:08 <rwbarton> oh, maybe I'm wrong
12:29:40 <roconnor> Haskell report says class is either a qtycls tyvar or a qtycls (tyvar atype1 ... atypen)
12:30:00 <roconnor> and an atype can be a tyvar
12:30:01 <rwbarton> in fact this is given as a valid type as an example: (Eq (f a), Functor f) => (a -> b) -> f a -> f b -> Bool
12:30:04 <roconnor> so it looks like I'm good
12:30:07 <rwbarton> yeah
12:30:16 <albeit> Do forkIO threads spawned from a  single thread remain on a single core, or are they able to use all available cores?
12:30:19 <rwbarton> maybe I was thinking of the rules for instances
12:30:21 <roconnor> I can't beleive I haven't used this sort of constrain in 10 years.
12:30:23 * hackagebot pipes-vector 0.5.3 - Various proxies for streaming data into vectors  http://hackage.haskell.org/package/pipes-vector-0.5.3 (BenGamari)
12:30:35 <ReinH> roconnor: heh
12:30:46 <roconnor> maybe I have and haven't noticed.
12:30:51 <roconnor> but it feels weird.
12:31:03 <Maerten> Hi, what's the easiest way to find the right packages names, if all i have is a list of 'import <module>' statements
12:33:50 <sveit> does something like 'f (Just a) = Right a' copy a or no?
12:33:56 <enthropy> Maerten: if you can compile the file, cabal init makes a list of packages in the build-depends
12:34:18 <jomg> albeit: afaik, if you want it to use multiple cores, you have to compile it with -threaded and run with +RTS -N<number of cores> -RTS
12:34:20 <enthropy> there's also `ghc-pkg find-module Foo.Bar`, if the thing is installed
12:34:37 <rwbarton> sveit, no. not normally
12:34:50 <Maerten> enthropy: thanks, i'll remember that. problem is now, i had to reinstall haskell-platform so i can't compile because i have to manually install all packages again
12:35:27 <Maerten> enthropy: right now i just do 'runhaskell program.hs', copy the error "Could not find module `Text.Show.Pretty'" and google that
12:35:37 <Forgetaboutit> cabal complains with <command line>: can't load .so/.DLL for: /usr/lib/gcc/x86_64-unknown-linux-gnu/4.9.0/../../../../lib/libncurses.so (-lncursesw: cannot open shared object file: No such file or directory). However, the file is definitely there. What's going on?
12:35:56 <ReinH> @hoogle Text.Show.Pretty
12:35:57 <lambdabot> package pretty
12:35:57 <lambdabot> package pretty-class
12:35:57 <lambdabot> package pretty-hex
12:35:58 <dino-> Maerten: I've also had ok results by using DuckDuckGo's !hackage bang like:  !hackage Text.CSV
12:36:32 <michaelt> roconnor:  hugs accepts it http://ideone.com/ZKpBI5
12:36:35 <Maerten> ReinH: thanks, it had to be pretty-show though
12:36:43 <Maerten> dino-: thanks i'll check that out
12:39:14 <roconnor> michaelt: ty
12:40:27 <rwbarton> Forgetaboutit: note that what cabal said it couldn't open was ncurses*w*
12:40:34 <rwbarton> probably libncurses.so is a linker script
12:40:58 <Forgetaboutit> rwbarton: Hm, what is a linker script?
12:41:12 <rwbarton> well, try reading /usr/lib/gcc/x86_64-unknown-linux-gnu/4.9.0/../../../../lib/libncurses.so
12:41:36 <Forgetaboutit> `INPUT(-lncursesw)'
12:41:39 <geekosaur> Forgetaboutit, something of a long story, it's a text file which tells the linker what to do, in this case it is a textual redirect to the actual libncurses
12:41:41 <geekosaur> yes, that
12:42:13 <geekosaur> but unless you have ghc 7.8 (and possibly even then still) it's using a built-in linker which doesn't understand linker scripts
12:42:58 <Forgetaboutit> geekosaur: I have GHC 7.8.2. What do I need to do then?
12:43:51 <rwbarton> it sounds like you don't have libncursesw installed
12:44:20 <Forgetaboutit> But I have, it's in /usr/lib/libncursesw.so
12:44:29 <geekosaur> rwbarton, it's a linker script
12:44:48 <geekosaur> wait
12:44:51 <geekosaur> hm
12:45:48 <Forgetaboutit> can I force cabal to use the correct path for the lib?
12:46:07 <awestroke> Applicative should have a non-infix (<*>) alias, like functor has both fmap and (<$>), as ((<*>) g) modifies (lifts?)  g from f (a -> b) to (f a -> f b) in a sense... ((<*>) g) is ugly
12:46:22 <geekosaur> cabal has no idea what is going on, ghc is doing it
12:46:46 <geekosaur> I would consider replacing the linker script with a symlink to the correct library
12:47:04 <Forgetaboutit> ugh, that's kind of ugly but should work
12:47:13 <shapr> awestroke: create a pull request? :-)
12:47:19 <geekosaur> if I parse the path right, /usr/lib/libncurses.so should be a symlink to /usr/lib/libncursesw.so
12:47:29 <Forgetaboutit> I hope it doesn't mess up my Arch Linux :)
12:47:37 <Forgetaboutit> geekosaur: exactly
12:47:45 <geekosaur> and, really they should get with the modern era, the libncursesw stuff went away years ago when ncurses merged unicode support
12:50:06 <Forgetaboutit> geekosaur: Yeah, that fixed it. Thanks!
12:50:57 <rwbarton> I guess something had a hard-coded full path to libncurses.so
12:51:42 <rwbarton> well, obviously, given the whole /usr/lib/gcc/x86_64-unknown-linux-gnu/4.9.0/../../../../lib/ thing
12:52:27 <Forgetaboutit> rwbarton: It could also be auto-hardcoded ;)
12:53:03 <rwbarton> right
12:53:19 <rwbarton> I mean it wasn't found using a library path
12:53:47 <henrixh_> @ the people who helped me earlier: I ended up spawning multiple threads all using the same MArray. Works wonders! Thank you!
12:54:39 <rwbarton> cool
12:54:44 <rwbarton> now do it using separate arrays for comparison :)
12:55:18 <heebee> How do I propagate errors from one monad into another? Let's say I'm in the IO monad and I do something that returns a failure in the Either monad. Should I just call fail with the error message in IO?
12:57:30 <awestroke> heebee: if that makes sense in your program
12:58:52 <heebee> awestroke: it feels a little awkward, is there a general pattern that would be better used instead?
12:59:09 <awestroke> heebee: are you in main, or what are you doing?
12:59:21 <heebee> awestroke: maybe I should use (IO (Either String a))?
12:59:34 <heebee> awestroke: no this isn't in main, this is in some module
13:00:21 <awestroke> heebee: you could make a transformer stack on ErrorT
13:00:54 <taktoa> anyone have a good config for yi that mimics nano?
13:01:02 <heebee> awestroke: ah, ok, need to learn more about these monad transformers :)
13:01:18 <taktoa> the CUA keymap doesn't have things like c-k/c-u for cut and paste lines
13:01:47 <awestroke> heebee: they are magical monad combinators that just works, make an ErrorT IO a type alias and use it in your function
13:03:30 <heebee> awestroke: cool, will do. If I now get back that Either, how do I make that part of the outer monad? Can I just use these in with the do notation or bind?
13:03:54 <rwbarton> no, you need to convert
13:05:07 <awestroke> heebee: there's runErrorT if you want to get the result from your monad stack into a normal IO monad, then you get an IO (Either e a) result  in your case
13:05:46 <heebee> awestroke: great, that's just what I need, thanks a bunch!
13:06:15 <henrixh_> rwbarton, no, not this time around. I'm off to the next project, planning to write a pathtracer in haskell. Doing the buddhabrot program in order to play around and learn from trial and error. Pathtracing and a buddhabrot are somewhat similar, so it's a nice excercise.
13:07:02 <rwbarton> heebee: note you only really gain from doing this if you have a pattern where you do a series of IO (Either a b)-type operations and want to bail when one of the IO actions returns a Left
13:07:12 <acowley> So, with the new-ish singletons, all my singletons code is broken.
13:07:27 <acowley> If I have a type whose kind is [Nat], how can I bounce that down to [Int]?
13:07:47 <acowley> It used to be map fromIntegral (fromSing (sing :: Sing xs))
13:07:54 <heebee> rwbarton: right, thanks, yeah. I need to short-circuit if there's some error in the Either monad
13:08:00 <rwbarton> heebee: if you just want a single operation, or you want to do different processing in the Left case, then it's most convenient to just stick with IO (Either a b)
13:08:05 <rwbarton> okay
13:11:25 <acowley> In some of my code bases I roll my own singletons pieces to avoid this, do other people do that or do most folks use the singletons package?
13:11:48 <acowley> I feel like I'm paying a complexity tax here
13:14:10 <exicer> If I'm using a uuid from Data.UUID to identify a unique url, is it necessary to check that it doesn't already exist? Or are they guarenteed to be unique ?
13:15:09 <awestroke> exicer: there are probably fewer uuid colissions than there are RAM corruptions from background radiation
13:15:29 <acowley> Okay, eliminating the singletons dep was much faster
13:15:34 <exicer> awestroke: Hah, ok cool
13:16:04 <Fuuzetsu> are your programs not radiation ready?
13:16:30 <acowley> Anyone know if adjunctions' upper bound on mtl is needed?
13:16:41 <acowley> I'm letting it loose, but worried I'll trip a bug
13:17:05 <awestroke> exicer: https://en.wikipedia.org/wiki/UUID#Random_UUID_probability_of_duplicates
13:20:31 * hackagebot Hclip 3.0.0.0 - A small cross-platform library for reading and modifying the system clipboard.  http://hackage.haskell.org/package/Hclip-3.0.0.0 (JensThomas)
13:35:17 <albeit> Is there a way to test if something was constructed using a data constructor for a record? I can match on Foo{}, but can I test equality on Foo{}?
13:35:30 <benzrf> albeit: heuh?
13:35:48 <benzrf> albeit: you mean if 2 have the same constructor?
13:36:42 <albeit> benzrf: Yes... I want to check if an object bar is made using Foo, if "data Bar = Foo String | Baz String"
13:36:53 <Tjr> albeit: like this?
13:36:53 <Tjr> f :: Either a b -> Boolean ; f Right x = True, f Left x = False
13:37:30 <albeit> Well, yes, I can match, but I was wondering if its possible without matching
13:37:39 <benzrf> albeit: why bother?
13:37:49 <benzrf> albeit: just write a convenience function that matches
13:38:31 <albeit> Well, in the example above, I want [Bar] -> [Bar], where all the resulting Bars are Foo _
13:39:12 <benzrf> albeit: filter isBar
13:39:18 <benzrf> * isFoo
13:39:42 <Tjr> albeit: you can cut out the explicit function by using Cases, but I'm not aware of a way to go without matching.
13:39:43 <albeit> And I have to define isFoo right? I have that now, just wondering if there was a cleaner way.
13:41:29 <Tjr> albeit:  IIRC Cases barobject { Foo _ -> True ; Baz _ -> False}
13:42:29 <Tjr> albeit: filter that over the list to get from " Bar -> Boolean" to "[Bar] -> [Bar]"
13:42:34 <albeit> Tjr: Ah I didn't realize Cases /= case... what's the package called? Having trouble finding it
13:42:44 <Tjr> it's in learn you a haskell
13:42:56 <Tjr> Sorry, I'm just a newbie trying to feel useful
13:42:59 <enthropy> Cases would be a constructor
13:43:48 <Tjr> albeit: sorry, it's "case", not "Cases"
13:44:12 <enthropy> albeit: if you actually have that Bar, probably it's best to write   \bars -> [ s  | Foo s <- bars ]
13:44:47 <enthropy> or maybe    \bars -> [ foo | bar <- bars, Foo{} <- [bar] ]
13:44:49 <Tjr> enthropy: genius
13:44:52 <enthropy> oops
13:45:00 <enthropy> or maybe    \bars -> [ bar | bar <- bars, Foo{} <- [bar] ]
13:45:59 <hiptobecubic> > [bar | [bar@(Just s) <- [Nothing, Just 2]]
13:46:01 <lambdabot>  <hint>:1:22: parse error on input ‘<-’
13:46:04 <hiptobecubic> dang
13:46:11 <hiptobecubic> > [bar | bar@(Just s) <- [Nothing, Just 2]]
13:46:13 <lambdabot>  [Just 2]
13:47:23 <albeit> enthropy hiptobecubic Just what I'm looking for, thanks
13:47:55 <haasn> > catMaybes [Nothing, Just 2, Just 3]
13:47:57 <lambdabot>  [2,3]
13:48:06 <haasn> oh
13:48:17 <hiptobecubic> haasn, need it for other types
13:48:31 <albeit> Yep, pretty much a generalies catMaybes / lefts / rights
13:50:12 <ttll> hi
13:50:42 <byorgey> hi ttll
13:51:41 <ttll> what's the best way to run a testGroup with cabal?
13:52:00 <ttll> or just the tests defined in a file
13:54:55 <byorgey> ttll: if the tests are listed as a test suite in the .cabal file, you can do  cabal configure --enable-tests ; cabal test
13:55:22 <byorgey> ttll: or are you asking how to create a test suite in the .cabal file?
13:58:24 <ttll> I just want to run a particular test that is listed in "other-modules:"
13:59:21 <byorgey> ttll: in that case cabal will not help you.  if the module with the tests has a 'main', you can just  runhaskell Module/With/Tests.hs
13:59:21 <heatsink> What exactly is the test?  Is it a function?
13:59:47 <ReinH> byorgey: cabal run might help
13:59:52 <bergmark> ttll: test groupus and modules are not necessarily 1-to-1
14:00:00 <byorgey> ReinH: ah, good point
14:01:34 <ttll> the module just exports tests :: [Test]
14:01:54 <ttll> and has no main function
14:04:43 <ttll> there is a tests/Main.hs that concatenates all the tests of the submodules
14:04:57 <bergmark> ttll: run it in ghci and do `runTestTT tests'
14:06:35 <kadoban> ttll: If it's using test-framework or something you should be able to do runhaskell tests/Main --help / --select-tests / --list-tests, if that helps.
14:07:35 <moghedrin> Is there any sort of function that takes an arbitrary function and returns the number of parameters it takes?
14:07:51 <sipa> yes
14:07:54 <sipa> :t const 1
14:07:55 <lambdabot> Num a => b -> a
14:07:58 <geekosaur> heh
14:08:10 <geekosaur> the concept of number of parameters is kinda loose in haskell
14:08:33 <teknokratsevilla> since functions are "curried"... basically you always have only one parameter
14:08:51 <sipa> for example, how many arguments does 'id' take?
14:08:56 <sipa> > id 1
14:08:57 <lambdabot>  1
14:09:01 <sipa> 1 argument!
14:09:06 <sipa> > id (+) 2 3
14:09:08 <lambdabot>  5
14:09:13 <sipa> 3 arguments!
14:09:15 <geekosaur> what would this function produce for http://lambda.haskell.org/platform/doc/current/ghc-doc/libraries/base-4.6.0.1/Text-Printf.html#v:printf ?
14:09:17 <sipa> > id
14:09:18 <lambdabot>  No instance for (Data.Typeable.Internal.Typeable a0)
14:09:18 <lambdabot>    arising from a use of ‘M11500377772629073656041.show_M11500377772629073656...
14:09:18 <lambdabot>  The type variable ‘a0’ is ambiguous
14:09:18 <lambdabot>  Note: there are several potential instances:
14:09:18 <lambdabot>    instance Data.Typeable.Internal.Typeable Data.Dynamic.Dynamic
14:09:36 <teknokratsevilla> id ((+) 2) 3)
14:09:42 <teknokratsevilla> > id ((+) 2) 3)
14:09:44 <lambdabot>  <hint>:1:13: parse error on input ‘)’
14:09:53 <teknokratsevilla> > id (((+) 2) 3)
14:09:55 <lambdabot>  5
14:10:12 <teknokratsevilla> that's wha really happens
14:11:01 <neektza1> In typeclassopedia, under Functor, there's "((,) e)". Could someone explain what exactly what that is please
14:11:03 <geekosaur> no, I think that's wrong
14:11:20 <geekosaur> (((id (+)) 2) 3)
14:11:46 <geekosaur> id applies to (+), producing (+); this applies to 2, producing (2+); then that applies to 3
14:11:55 <jfischoff> what happens if a thread is waiting on putting something into an MVar and it gets a ThreadKilled exception thrown to it? Is it killed immediantly?
14:12:09 <Fuuzetsu> neektza1: it just means a pair with type of the first (left) element already known
14:12:20 <geekosaur> neektza1: (,) is a tuple constructor, which is partially applied here
14:12:24 <geekosaur> :t (,)
14:12:25 <lambdabot> a -> b -> (a, b)
14:12:31 <teknokratsevilla> > id (+)
14:12:33 <lambdabot>  <Integer -> Integer -> Integer>
14:13:01 <teknokratsevilla> > (id (+)) 2
14:13:01 <neektza1> Thanks
14:13:03 <lambdabot>  <Integer -> Integer>
14:13:10 <beo_> @pl paths (Node n xs) = map (\x -> n : (concat $ paths x)) xs
14:13:10 <lambdabot> (line 1, column 20):
14:13:11 <lambdabot> unexpected " "
14:13:11 <lambdabot> expecting operator
14:13:15 <moghedrin> Hmmm. Okay. Good point.
14:13:29 <Enigmagic> jfischoff: the comments in PrimOps.cmm seem to think the exception will be delivered after the put is complete
14:13:39 <jfischoff> :o
14:14:04 <jfischoff> uhh now I need to actually check that
14:14:07 <Enigmagic> jfischoff: https://github.com/ghc/ghc/blob/master/rts/PrimOps.cmm#L1357
14:14:07 <beo_> @pl f (Node n xs) = map (\x -> n : (concat $ f x)) xs
14:14:08 <lambdabot> (line 1, column 16):
14:14:08 <lambdabot> unexpected " "
14:14:08 <lambdabot> expecting operator
14:14:35 <beo_> @help
14:14:36 <lambdabot> help <command>. Ask for help for <command>. Try 'list' for all commands
14:14:40 <beo_> @list
14:14:41 <lambdabot> What module?  Try @listmodules for some ideas.
14:14:44 * jfischoff is reading
14:15:06 <beo_> @help list
14:15:07 <lambdabot> list [module|command]. Show commands for [module] or the module providing [command].
14:15:23 <geekosaur> teknokratsevilla, a strict language would evaluate the way you said, but for laziness to work Haskell must evaluate outside in and produce partially applied functions as it goes
14:15:49 <Iceland_jack> @pl f n xs = map (\x -> n : (concat $ f x)) xs
14:15:49 <lambdabot> f = fix ((map .) . flip ((.) . (:)) . (join .))
14:16:40 <piezoid> while looking at Core output, how do you now if a data field is unpacked ?
14:17:31 <shachaf> You can look at whether a constructor exists.
14:19:05 <piezoid> shachaf: I don't see any data Type
14:20:29 <piezoid> shachaf: but there is a $WCons, it pattern match on W8# so I think Word8s gets unpacked
14:21:22 <shachaf> If it's matching on W8# then it's probably not being unpacked.
14:24:06 <guesting> How can I get the full name of a function when profiling a program with "-hc"? Right now it would have functionRightHe... and cuts off so I can't read the function if it's long and bound
14:25:32 <piezoid> shachaf: mmh... the declaration is 'data IP = IP !Word8 !Word8 !Word8 !Word8' on 7.8, too much fields ? I'll try to add explicit UNPACKs
14:25:58 <quchen> guesting: There's a flag to increase the amount of characters logged from the trace I think, hold on a second.
14:26:05 <quchen> s/trace/SCC/
14:26:27 <guesting> quchen: I hope so. I tried looking for it but I didn't do a good job of finding a flag apparently
14:27:33 <jfischoff> the type checker is barfing: with actual type `IO *** Exception: <stderr>: hPutChar: invalid argument (invalid character). Any ideas?
14:28:06 <benzrf> jfischoff: context?
14:28:24 <benzrf> jfischoff: are you using unicode in tyes
14:28:26 <benzrf> *types
14:28:36 <jfischoff> that’s my guess, but not on purpose
14:28:47 <jfischoff> I wasn’t sure if someone had run into this before
14:29:51 <yac> what should I use for unit testing?
14:30:08 <jfischoff> well tasty over test-framework
14:30:32 <kadoban> yac: test-framework is pretty cool IME, but I haven't used anything else in Haskell really.
14:30:51 <jfischoff> and the tasty-th or hspec I guess
14:31:23 <jfischoff> tasty-th uses HUnit for unit testing
14:31:25 <yac> right now I'm looking at Hunit as it fell first from google search
14:31:41 <jfischoff> what are you familiar with?
14:31:47 <yac> nothing
14:31:50 <quchen> guesting: -l20  -- 20 characters length
14:31:59 <quchen> guesting: See here, http://www.haskell.org/ghc/docs/latest/html/users_guide/hp2ps.html
14:32:01 <yac> oh well, nothing from haskell. I'm familiar with unittest and nosetests from python
14:32:06 <guesting> quchen GREAT! Thank you!
14:32:17 * jfischoff looks up nosetests
14:32:37 <guesting> quchen--wait, that's for hp2ps, but it's cut short in the hp file so I don't think that would do much...
14:32:37 <quchen> guesting: Maybe I was too quick reading that, the -l option might not be what you want. But if it's not, it surely can be found on that page.
14:32:49 <quchen> Hmm.
14:32:51 <yac> oh and I used quickcheck somewhere but I don't know why as the purpose was unit tests. I guess I did not look for unit testing specifically on google when searching for that back then
14:33:11 <quchen> Well it's something there! I remember it being awful to find. Digging on …
14:34:08 <guesting> quchen haha ok
14:34:24 <jfischoff> yac: there is an example of my unit testing setup: https://github.com/jfischoff/generic-maybe/blob/master/tests/tasty.hs
14:34:49 <jfischoff> yac: here is hspec http://hspec.github.io/
14:35:07 <jfischoff> I’m thinking of trying out hspec myself
14:36:18 <bitemyapp> jfischoff: I use HSpec and love it dearly.
14:36:24 <bitemyapp> jfischoff: also the author is the COOLEST PERSON ever.
14:36:36 <jfischoff> well therefore ;)
14:36:45 <kadoban> yac: Whatever you use, check into QuickCheck, it's cool as hell. Most of the frameworks I assume will let you use it.
14:36:47 <bitemyapp> jfischoff: no seriously, massively helpful and productive.
14:36:49 <bitemyapp> yac: https://github.com/bitemyapp/bloodhound/blob/master/tests/tests.hs
14:36:54 <guesting> quchen: Unfortunately I don't think it's there, I would need the flag when running the program so the hp file has the long name
14:36:56 <quchen> guesting: -L
14:36:57 <yac> thanks. I'm gonna give hspec a shot
14:36:59 <quchen> http://www.haskell.org/ghc/docs/latest/html/users_guide/prof-heap.html#rts-options-heap-prof
14:37:05 <quchen> "Sets the maximum length of a cost-centre stack name in a heap profile. Defaults to 25. "
14:37:06 <AlexeiMoiss> How can I get rid of code duplication in here ?
14:37:12 <jfischoff> bitemyapp: yeah that’s a good point
14:37:20 <yac> kadoban: I tried it, did not like it much. But probably jsut because I'm not familiar with the concept and a newbie to haskell
14:37:25 <Fuuzetsu> AlexeiMoiss: In where?
14:37:27 <guesting> quchen: YES! THAT'S IT!
14:37:31 <guesting> quchen: Thank you!
14:37:33 <yac> I'd like something just for regular unit testing now
14:37:45 <AlexeiMoiss> Cann I paste code here ?
14:37:49 <kadoban> yac: Ah, I thought it was the neatest thing ever :-/
14:37:53 <Fuuzetsu> AlexeiMoiss: use a paste service, such as lpaste
14:38:01 <AlexeiMoiss> data Cell a = End | Next a (Cell a) (Cell a) (Cell a) (Cell a)  instance (Show a) => Show (Cell a) where 	show End = "" 	show c@(Next _ _ _ _ End) = showLine c 		where 			showLine End = "" 			showLine (Next v _ _ r _) = (show v)++" "++(showLine r) 	show c@(Next _ _ _ _ b) = (showLine c) ++ "\n" ++ (showLine b) 		where 			showLine End = "" 			showLine (Next v _ _ r _) = (show v)++" "++(showLine r)
14:38:09 <AlexeiMoiss> Sorry, first time :)
14:38:11 <yac> kadoban: well it does look cool, it's that I don't need it now.
14:38:19 <Fuuzetsu> yac: you could embed QC properties into Haddock comments and use something like doccheck
14:38:22 <Fuuzetsu> (or is it doctest)
14:38:22 <kadoban> yac: Fair enough
14:38:45 <Fuuzetsu> https://github.com/sol/doctest-haskell#readme
14:39:09 <Fuuzetsu> AlexeiMoiss: please put it on a paste service so we can actually read it ;)
14:39:37 <quchen> AlexeiMoiss: The go-to pastebin here is lpaste,
14:39:39 <quchen> @where paste
14:39:40 <lambdabot> Haskell pastebin: http://lpaste.net/
14:40:06 <quchen> It even suggests code improvements automatically (powered by HLint) :-)
14:40:07 <AlexeiMoiss> http://lpaste.net/105042
14:40:23 <AlexeiMoiss> Do I just paste the url of lpaste? I never used it
14:40:40 <rwbarton> yes, like you did
14:41:39 <AlexeiMoiss> I just want to show a 2 dimensional structure
14:42:10 <Fuuzetsu> AlexeiMoiss: just move showLine out of the class definition
14:42:37 <AlexeiMoiss> Yes, I can, but I wanted to keep it hidden from the rest of the code
14:42:50 <quchen> AlexeiMoiss: You can simply float out the "showLine" definitions to the top level, http://lpaste.net/105043
14:43:28 <Fuuzetsu> no can do if you want to avoid duplication, move it out to top level and don't export it to other modules
14:43:56 <yac> I need a `drop 1 $ take 2`  is there something better?
14:43:57 <rwbarton> or, if you wanted to for some reason, you could rewrite as "show c = case c of { ... } where showLine End = "" ..."
14:44:24 <quchen> AlexeiMoiss: You can hide that piece of code by not exporting it. It'll still be globally visible within in the module, but not from other modules.
14:44:35 <rwbarton> I guess that wasn't very clear
14:44:42 <AlexeiMoiss> Is it not a bad practice to expose functions outside the context they are used in ?
14:45:21 <quchen> AlexeiMoiss: You should probably minimize the amount of globally available things, but that's a very soft guideline.
14:45:27 <Fuuzetsu> AlexeiMoiss: Eh, not really, you can't really misuse it in any way. If it really bothers you then you can do what rwbarton suggested and use a case expression instead
14:45:41 <kadoban> AlexeiMoiss: Somewhat, but it tends not to matter inside a module, especially if you give it a good name and if it's usable more than once.
14:46:41 <rwbarton> http://lpaste.net/105044 is what I meant to say
14:47:41 <yac> hey, I like the hspec
14:47:44 <AlexeiMoiss> Haven't thought of case, was trying to achieve that with let ... in
14:47:54 <yac> just got my first test failing and I'm satisfied with the reporting
14:48:04 <yac> as well as the test writing
14:48:12 <yac> jfyi jfischoff
14:49:30 <quchen> AlexeiMoiss: If you show us the desired input/output maybe we can do some more here.
14:49:42 <AlexeiMoiss> Right, now as I understand, I need to research ShowS and get rid of those double pluses, is that right ? But pls don't paste me a solution, because I want to learn it by doing it myself.
14:49:47 <quchen> Right now the function is a bit convoluted because the user doesn't know what the fields of a Cell mean.
14:51:46 <AlexeiMoiss> I wanted to represent a bounded 2d structure, that's what that Cell thing is - a value and left, top, right and bottom
14:52:18 <quchen> Ah, like a quad tree?
14:52:41 <AlexeiMoiss> Nah, like a 2d array
14:54:30 <kadoban> AlexeiMoiss: What you have is more like a 2D doubly linked list though, just throwing that out there.
14:54:59 <AlexeiMoiss> Basically, I've decided to participate in Al Zimmerman's Alphabet City http://www.azspcs.net/Contest/AlphabetCity and to write my program in Haskell in order to learn the language. So Cell is an abstract square in the scrubble board
14:55:00 <quchen> It's more like a tree with four children per node right now.
14:55:52 <quchen> Ooooh. Well then that data representation is probably not that good at all. How about a Vector (Vector a)?
14:56:01 <quchen> Or in the naive case, [[a]]
14:56:07 <quchen> That is, a list of rows
14:56:14 <kadoban> AlexeiMoiss: Yeah, that's certainly not the representation I'd use for that
14:56:54 <AlexeiMoiss> Yes, you can say that. What I was trying to express is that "A cell holds 'something' and has a cell or nothing to the left, top, right and bottom of it'
14:59:07 <AlexeiMoiss> But lists can only be processed in one direction. I was concerned with that fact
14:59:57 <AlexeiMoiss> I"ll read about Vectors, haven't used them, yet
15:00:33 <quchen> They're pretty similar to lists, API wise.
15:01:23 <AlexeiMoiss> but what about ShowS, guys? Am I right in understanding that '++'s in show should be replaced with ShowS? I've read about it, but couldn't quite grasp it
15:02:10 <ReinH> Or a Store comonad ;)
15:02:14 <quchen> ♥
15:02:19 <ReinH> or, you know, just an array
15:02:34 <quchen> ShowS is very similar to using DList to concatenate things. It's an optimization, not something strictly required to make things work here.
15:03:01 <quchen> Also note that Show is not for prettyprinting, https://github.com/quchen/articles/blob/master/fbut.md#show-is-not-for-prettyprinting
15:05:09 <AlexeiMoiss> quchen: hmm, interesting point
15:05:32 <dagle> Never leave ghci running without limits... 32GB ram later.
15:29:40 <sshine> what is ShowS?
15:32:06 <codyreichert> sshine, here's a decent SO thread on it: http://stackoverflow.com/questions/9197913/what-is-the-shows-trick-in-haskell
15:42:30 <tayacan> Is there a nice way to create a file if it doesn't exist? Opening it in WriteMode and closing it again seems a bit inelegant.
15:44:03 <pavonia> You could explicitly check if it exists and wrieFile an empty string otherwise
15:45:36 <tayacan> I guess.
15:50:14 <tayacan> Hmm. I don't have a pattern in my head for how to do something like the following in a functional language: if (x) { y; } z;
15:52:01 <pavonia> In a monadic context you can use "when"
15:52:04 <pavonia> :t when
15:52:05 <lambdabot> Monad m => Bool -> m () -> m ()
15:52:34 <pavonia> when x y >> z
15:53:40 <tayacan> pavonia, thanks! I actually knew that "when" existed, I'd just forgotten - like, I haven't coded enough haskell that it's a thing-that-lives-in-my-head yet.
15:54:30 <chirpsalot> Hmmm... Can you use this with forkIO to timeout a process? https://hackage.haskell.org/package/base-4.1.0.0/docs/System-Timeout.html basically I want to launch a student program from Haskell and make sure it finishes within a certain amount of time. Figured I would ask in case there was a better way, I guess.
15:54:58 <zwer> it is trivial to implement with if-then-else
15:55:05 <zwer> to implement when*
15:55:11 <zwer> @src when
15:55:11 <lambdabot> when p s = if p then s else return ()
15:56:15 <geekosaur> chirpsalot, I would use a process instead of a thread (what do you do if the program is itself multithreaded? also there are potential issues with shared resources between the two) and use a timer to abort that subprocess
15:56:54 <incccp> wxwidgets or gtk2hs?
15:57:03 <geekosaur> how exactly you do that depends on the OS, since the details of killing processes differ
16:00:13 <tayacan> zwer, true
16:16:22 <akurilin> Is there a function in base that can turn a Data.List into a Data.Map based on a function I give it? I'm basically looking for a groupBy that returns a map
16:16:41 <zwer> :t M.fromListWith
16:16:43 <lambdabot> Ord k => (a -> a -> a) -> [(k, a)] -> M.Map k a
16:17:28 <akurilin> In my case I don't actually have pairs, but I can always do a map pass first and add the key to each item in the list
16:17:36 <akurilin> and then I can run what you have above
16:18:14 <pavonia> akurilin: What should your values in the map look like?
16:18:18 <akurilin> I'm trying to simulate this: http://clojuredocs.org/clojure_core/clojure.core/group-by
16:18:53 <akurilin> pavonia: they're records that I want to group into a map by the value of a certain field
16:36:24 <Eduard_Munteanu> Anyone heard of enterprise {architecture,messaging,integration,design patterns} etc. in software? How much of a buzz factor is there?
16:37:19 <sshine> "enterprise" is pretty buzz.
16:37:44 <Eduard_Munteanu> There seems to be a fair bit of work in the field, but reading a bit about it seems to talk about "old" things under new names, e.g. RPC as enterprisey servicey something.
16:38:35 <heatsink> Its connotations have more to do with business than technology
16:38:36 <Eduard_Munteanu> Well, let's take something a bit more concrete... ActiveMQ.
16:39:16 <sshine> enterprise resource planning (ERP) is a pretty acknowledged term. (I know they do research related to that at my university.)
16:39:18 <Eduard_Munteanu> They, along with other stuff in the "message queue" paradigm which also seems a bit buzzy, seem to be involved in this.
16:39:37 <sshine> (mostly about formalizing business contracts and processes)
16:39:52 <Eduard_Munteanu> sshine: I suppose I see the point there.
16:41:08 <Profpatsch> Are there solutions for the excercises on Typeclassopedia? http://www.haskell.org/haskellwiki/Typeclassopedia
16:41:27 <Eduard_Munteanu> I also see Amazon offering something related to messaging in AWS, I don't know much about it but I wonder what sort of applications buy into this sort of stuff.
16:42:28 <sshine> Eduard_Munteanu, the "Enterprise Integration Patterns" book that the ActiveMQ people refer to seems UML-like
16:43:14 <infinity0> why is :type fmap^9 the same as :type fmap^13, ^17, ^21 etc, but :type fmap and :type fmap^5 are different?
16:43:31 <infinity0> :type fmap
16:43:37 <infinity0> aw, no bot
16:44:14 <zwer> > let groupMapBy f xs = M.fromListWith (++) $ zip (map f xs) (map (:[]) xs) in groupMapBy length ["a", "aa", "bb"]
16:44:16 <lambdabot>  fromList [(1,["a"]),(2,["bb","aa"])]
16:44:22 <zwer> ^^ akurilin
16:44:29 <infinity0> > :type fmap
16:44:30 <lambdabot>  <hint>:1:1: parse error on input ‘:’
16:44:39 <zwer> :t fmap
16:44:41 <lambdabot> Functor f => (a -> b) -> f a -> f b
16:45:10 <infinity0> :t fmap fmap fmap fmap fmap
16:45:11 <lambdabot> Functor f => (a1 -> b) -> (a -> a1) -> f a -> f b
16:45:13 <infinity0> :t fmap fmap fmap fmap fmap fmap fmap fmap fmap
16:45:15 <infinity0> :t fmap fmap fmap fmap fmap fmap fmap fmap fmap fmap fmap fmap fmap
16:45:15 <lambdabot> (Functor f3, Functor f2, Functor f1, Functor f) => f (f1 (f2 (a -> b))) -> f (f1 (f2 (f3 a -> f3 b)))
16:45:16 <lambdabot> (Functor f3, Functor f2, Functor f1, Functor f) => f (f1 (f2 (a -> b))) -> f (f1 (f2 (f3 a -> f3 b)))
16:45:17 <infinity0> :t fmap fmap fmap fmap fmap fmap fmap fmap fmap fmap fmap fmap fmap fmap fmap fmap fmap
16:45:18 <lambdabot> (Functor f3, Functor f2, Functor f1, Functor f) => f (f1 (f2 (a -> b))) -> f (f1 (f2 (f3 a -> f3 b)))
16:45:22 <infinity0> what gives?
16:45:49 <infinity0> (and why aren't they all like :type fmap)
16:45:49 <sshine> :t let fap = fmap in fap fap fap
16:45:50 <lambdabot> (Functor f1, Functor f) => (a -> b) -> f (f1 a) -> f (f1 b)
16:47:01 <dmwit> Suppose I write newtype D = D (D -> D). Is there an implementation of "observe :: D -> Bool" which sometimes returns True and sometimes returns False?
16:47:01 <Eduard_Munteanu> :t fmap . fmap . fmap
16:47:02 <lambdabot> (Functor f2, Functor f1, Functor f) => (a -> b) -> f (f1 (f2 a)) -> f (f1 (f2 b))
16:47:53 <akurilin> zwer: whoa, that's awesome
16:48:26 <akurilin> I was trying to figure out how to deal with start with an empty list without doing a foldl
16:49:04 <dmwit> infinity0: I actually think I saw a blog post about that a while back...
16:52:21 <dmwit> can't seem to find it now
16:52:23 <StoneCypher> i think i just figured out my first valid haskell joke
16:52:34 <StoneCypher> "yo momma so fat her scale measures in co-pounds"
16:53:12 <infinity0> dmwit: ah i found this http://stackoverflow.com/questions/8736995/fun-with-repeated-fmap trying to decode it now
16:53:19 <infinity0> also interesting that the pattern only emerges for k>=2
16:53:45 <shachaf> StoneCypher: This joke is not valid in #haskell.
16:53:58 <StoneCypher> shachaf: ... aw :(
16:54:14 * StoneCypher thought he finally understood co.
16:54:40 <Eduard_Munteanu> dmwit: hmm, interesting... if I'm not mistaken, D ~ _|_, so there's just one such observe, so perhaps you simply have to ask if *the* observe returns false and true.
16:54:44 <hpc> does anyone remember the name of the package that defines a relational calculus for odbc-style backends?
16:55:03 <hpc> the up to date one, not takusen
16:55:17 <Eduard_Munteanu> hpc: not esqueleto, right?
16:55:29 <dmwit> Eduard_Munteanu: How do you show D ~ _|_?
16:55:34 <dmwit> I, too, believe this.
16:55:52 <hpc> oh, that is up to date
16:56:00 * hackagebot Win32-services 0.2.4 - Windows service applications  http://hackage.haskell.org/package/Win32-services-0.2.4 (MichaelSteele)
16:56:02 <Eduard_Munteanu> dmwit: I'm not sure, but notice D isn't strictly positive, might be helpful.
16:56:38 <LordBrain> Is there a wiki page on how using type families reduces inference over multiparam with fundep?
16:56:40 <dmwit> It's the standard way of embedding untyped lambda calculus in Haskell.
16:56:43 <Eduard_Munteanu> You shouldn't even be able to define it in, say, agda.
16:56:55 <dmwit> But if you can't leave the untyped lambda calculus, it doesn't seem like a very useful embedding. =P
16:57:00 <hpc> oh, i was thinking of the TH from one of the web frameworks
16:57:12 <dmwit> Eduard_Munteanu: Definitely can't define it in any language which has termination checking.
16:57:30 <Eduard_Munteanu> Yeah, not even talk about it.
16:58:12 <sshine> StoneCypher, I hear jokes get more entertaining when you explain them. care to? :)
16:58:27 <StoneCypher> i thought co-pounds would reveal the infinite series of pounds
16:58:35 <StoneCypher> i thought i was accusing one's momma of being infinitely fat.
16:59:24 <Eduard_Munteanu> One's momma leaves a trail of pounds behind, and we call that momma productive. :P
17:00:16 <LordBrain> i came here on the wrong day
17:00:26 <trap_exit> without using template ahskell (which Haste does not support) -- is there a way to say: "run all quick check tests in all of my *.hs files" ?
17:00:41 <trap_exit> I find it weird that it's not obvious to say "run all quick check tests"
17:00:55 <zq> gamegoblin: it looks okay, but i ended up going Data.Hashable and fp scaling
17:01:00 * hackagebot idris 0.9.13 - Functional Programming Language with Dependent Types  http://hackage.haskell.org/package/idris-0.9.13 (EdwinBrady)
17:01:07 <Iceland_jack> trap_exit: sequence_ [test1, test2, ...]
17:01:07 <zq> gamegoblin: thanks for trying, though
17:01:31 <trap_exit> Iceland_Jack: yeah that requires manually listing all the tests
17:01:46 <trap_exit> I'd prefer it to automatically recognize that all things starting with qc_ ... are quick chek tests and just run them
17:01:56 <Iceland_jack> You need TH for that
17:02:13 <Iceland_jack> or you can run it through an external shell script
17:02:31 <trap_exit> okay
17:02:34 <trap_exit> I like external shell script
17:02:38 <trap_exit> is there a sample external shell script
17:02:44 <trap_exit> I am using haste, which makes TemplateHaskell not an option
17:04:08 <Iceland_jack> http://hackage.haskell.org/package/quickcheck-script
17:05:06 <trap_exit> Iceland_jack: wonderful, thanks~!
17:06:34 <trap_exit> does this http://hackage.haskell.org/package/quickcheck-script use hugs or ghci?
17:06:41 <trap_exit> coments say ghci, but source code has "hugs" in it
17:06:58 <LordBrain> the hackage page says ghci
17:07:56 <trap_exit> yeah, but quickcheck.hs has "hugs" in the comments
17:10:08 <LordBrain> looks like the runhugs is commented out
17:10:23 <LordBrain> is that what you mean?
17:12:36 <p0a> I have this code, http://lpaste.net/105047. I get the error: Not in scope: type constructor or class `Parser'
17:15:51 <quchen> p0a: The Parser types are defined in submodules so you can use Parsec with different input types (such as String or Text). You have to import Text.Parsec.Text to get the appropriate Text parser type, for example.
17:17:36 <p0a> thanks that fixed it
17:17:44 <LordBrain> p0a, avoid using head directly... use some safer equivalent
17:18:16 <p0a> now I have other errors in the code
17:18:17 <LordBrain> i know you're just making this to learn, but i got bit because i ran your code without input
17:18:21 <p0a> I think I need to find a more up to date tutorial
17:18:33 <p0a> oh it worked for you?
17:18:43 <LordBrain> it compiled
17:18:56 <p0a> originally the code used !! 0 which I looked up and replaced with head :P
17:19:32 <LordBrain> oh
17:19:35 <LordBrain> well neither is good
17:19:47 <p0a> yeah [] !! 0 also gives an error
17:20:17 <LordBrain> well, you could just handle the empty case really, with some usage statement.
17:20:22 <LordBrain> in this situation
17:21:03 * hackagebot texmath 0.6.6.3 - Conversion of LaTeX math formulas to MathML or OMML.  http://hackage.haskell.org/package/texmath-0.6.6.3 (JohnMacFarlane)
17:21:11 <LordBrain> like if null args then putStrLn "Usage: p0a File"
17:21:16 <LordBrain> else do
17:21:42 <quchen> I think pattern matching is the way to go here, not using null.
17:21:48 <p0a> Couldn't match type `[Char]' with `Data.Text.Internal.Text' on line 11
17:21:55 <p0a> Don't you get this error? Because I do
17:22:15 <LordBrain> what?
17:22:20 <LordBrain> oh
17:22:32 <LordBrain> you i used import Text.Parsec.String
17:22:41 <LordBrain> not .Text
17:22:55 <p0a> ah
17:23:03 <LordBrain> you import the module corresponding to your input type
17:24:04 <p0a> trying to learn it all at the same time sorry
17:24:10 <LordBrain> np
17:24:47 <LordBrain> you could have chose to change your input type, bytestrings or text would be more efficient
17:27:54 <LordBrain> {-# LANGUAGE OverloadedStrings #-} will make it so you can write those other types as literals using the "" syntax... you'd still need to use the monoid operator <> for concat, and don't use any colons in pattern matching.
17:36:05 * hackagebot vinyl 0.4 - Extensible Records  http://hackage.haskell.org/package/vinyl-0.4 (JonSterling)
17:36:28 <jonsterling> Heh.
17:44:55 <brisbin> i find that i have to re-specify all the same dependencies in my library, executable, and test sections of the cabal file. am i doing it wrong?
17:57:23 <Enigmagic> brisbin: yes
17:57:40 <brisbin> thanks. is there a document i can consult to find the correct way?
17:57:51 <Enigmagic> brisbin: did you add a dependency on your library in the executable and test sections?
17:58:12 <brisbin> i've tried that yes, and library code fails unable to find modules
17:59:01 <Enigmagic> brisbin: okay, step two is to move your lib/exe/test code into their own directories and specify them using hs-source-dirs
17:59:08 <Enigmagic> brisbin: take a look at https://github.com/alphaHeavy/llvm-general-typed/blob/master/llvm-general-typed-pure/llvm-general-typed-pure.cabal
17:59:12 <brisbin> i have src and test
17:59:23 <brisbin> and src/main.hs for the executable
17:59:40 <Enigmagic> brisbin: move the executable into a different directory..
17:59:43 <brisbin> nice, that's what i expected to be able to do
18:00:52 <brisbin> sorry have to step away unexpectedly, will try again later
18:00:54 <brisbin> thanks for the pointers Enigmagic
18:01:02 <Enigmagic> brisbin: np, good luck.
18:04:16 <guesting> Is there a reason why "map (splitOn ",") [BIG list of strings]" would lead to a linear memory leak (that I can see in hp2ps using profiling)?
18:04:34 <guesting> "splitOn" is from the Data.List.Split library
18:09:54 <benzrf> :t filterM
18:09:54 <tadworthington> Hey, I’m pretty much brand new to Haskell and FP (well, we covered FP a bit when I was in college, but that was a lifetime ago!)  I’ve been reading several books, and have come up with my first effort at a program.  Is this a good place to ask for opinions/critique on my code?
18:09:55 <lambdabot> Monad m => (a -> m Bool) -> [a] -> m [a]
18:10:00 <benzrf> sweet.
18:11:03 <Fuuzetsu> tadworthington: as good as any, you should post your code to a pastebin site or post a repository if it's a bigger project
18:11:27 <tadworthington> I have a pastebin - it’s a pretty small program (about 50 lines).
18:11:30 <Fuuzetsu> whether anyone who's willing to have a look is on atm is another question; if it's a lot of code then perhaps mailing lists are the best
18:11:34 <Fuuzetsu> ah, post the link then
18:11:57 <tadworthington> It’s an attempt at a solution to the Jumble newspaper puzzle.
18:11:58 <tadworthington> http://pastebin.com/viPWMYSd
18:12:19 <Fuuzetsu> ugly headers
18:12:24 <tadworthington> There is a flaw, and if you run the code you’ll notice it immediately.
18:12:31 <Fuuzetsu> also you can use -- * and have nice Haddock headers ;)
18:12:54 <tadworthington> I’ll remember that :-D
18:13:24 <tadworthington> Haddock headers seem pretty cool.
18:13:35 <tadworthington> (looking at haskell.org documentation page)
18:14:32 <Fuuzetsu> hm, for the accessors I'd say that if you're going to have accessors anyway, you should have use the record syntax to begin with
18:14:58 <tadworthington> Ah, right - I read about them somewhere.  Would have saved me some code.
18:16:04 <Fuuzetsu> yes, for example type Board … could become data Board = Board { boardWidth :: Int, boardSquares :: [Square] }
18:16:54 <tadworthington> Excellent - exactly the type of advice for which I am looking.
18:17:19 <Fuuzetsu> I'm not quite sure what the intended results are meant to be ;P
18:17:25 <Fuuzetsu> *JumbleList> search test1 "RADE"
18:17:26 <Fuuzetsu> [[((1,2),'R'),((1,1),'A'),((2,2),'D'),((1,3),'E'),((1,2),'R'),((1,1),'A'),((2,2),'D'),((1,3),'E'),((1,2),'R'),((1,1),'A'),((2,2),'D'),((1,3),'E'),((1,2),'R'),((1,1),'A'),((2,2),'D'),((1,3),'E'),((1,2),'R'),((1,1),'A'),((2,2),'D'),((1,3),'E')]]
18:17:34 <tadworthington> Yep, that’s the error.
18:17:59 <tadworthington> I get the correct results (showing the cells and the letters), but multiple copies.
18:18:39 <kadoban> tadworthington: I like your labelled code sections, that's pretty nice.
18:18:54 <tadworthington> I would like that to read [((1,2),’R’), ((1,1),’A’), ((2,2),’D’), ((1,3),’E’)]
18:18:58 <Alison18>  Here some videos. I hope you like them! http://bit.ly/1rJEjom
18:19:15 <tadworthington> Thanks, kadoban!
18:19:25 <Fuuzetsu> Alison18's link is NFSW, porn site.
18:19:26 <aspidites> ok, so twice in one day. I guess I did speak too soon
18:19:48 <tadworthington> Man, are those porn trolls *everywhere*?!
18:19:57 <tadworthington> I mean, really, on a Haskell IRC channel?
18:19:59 <tadworthington> Geez....
18:20:00 <aspidites> i've only noticed them today
18:20:16 <Fuuzetsu> tadworthington: you could probably replace the big list in neighbours with a list comprehension
18:20:26 <Fuuzetsu> tadworthington: it doesn't happen often
18:20:31 <aspidites> apparently when scraping for targets it mistook functional for fucktional
18:20:46 <tadworthington> NIce one, aspidites :-)
18:20:46 <zomg> I'm always curious about these irc spammers... Like.. what kind of clickthrough rate they get
18:20:48 <Fuuzetsu> are porn sites a burrito
18:21:12 <zomg> I mean is it actually worth the time and effort to spam on irc, where a significant portion of users are experienced enough to not fall for spam links
18:21:15 <tadworthington> Ok, so replace the list in neighbours with a list comprehension.  I’ll look at that.
18:21:44 <tadworthington> I could, of course, just filter out the duplicates, but I’d rather understand what I’m doing wrong.
18:21:57 <kadoban> zomg: You could test that out by spamming a site with just a counter XD
18:22:05 <zomg> hah =)
18:23:57 <Fuuzetsu> tadworthington: [getSquareFromPos brd (x - x', y - y') | x' <- [ -1, 0, 1 ] , y' <- [ -1, 0, 1 ]]
18:23:58 <Fuuzetsu> something like that
18:24:01 <Fuuzetsu> could probably be nicer
18:24:11 <aspidites> i wonder if anyone's ever invented a spam spam bot? as in it does a reverse look up of the origin of the original spam and spams that domain, perhaps with articles about why spamming is bad
18:24:42 <Fuuzetsu> aspidites: it's futile considering the spammers either don't care or are using zombies anyway
18:25:33 <tadworthington> Wow, that *really* reads better than that long list I have for the neighbors.  I need to practice list comprehensions a bit more - they feel very familiar to me from all the math classes I took :-)
18:26:27 <Fuuzetsu> they are meant to
18:28:02 <benzrf> exiterror for my friend trying to cabal install http
18:28:09 <benzrf> could be missing a system lib
18:28:11 <benzrf> which one?
18:29:02 <Fuuzetsu> try googling it with the error number, there should be an answer
18:31:27 <benzrf> <command line>: cannot satisfy -package-id mtl-2.1.2-94c72af955e94b8d7b2f359dadd0cb62
18:31:57 <Fuuzetsu> that doesn't sound like a missing system lib but like a fucked install of something
18:32:02 <Fuuzetsu> how is he installing packages?
18:32:06 <benzrf> cabal install
18:32:11 <benzrf> i dont know his preexisting condition
18:32:17 <benzrf> i wrote him a script and it needs http
18:32:18 <benzrf> :I
18:32:26 <tadworthington> Thanks for the help, Fuuzetsu!
18:32:29 <Fuuzetsu> tadworthington: np
18:33:09 <Fuuzetsu> benzrf: I imagine his ghc-pkg check is going to cry
18:33:16 <kholdstare> Hey everyone! I'm wondering if there are any conduit/pipes users here? I have a few questions regarding their uses in threaded/concurrent settings
18:34:06 <Fuuzetsu> I believe the remedy for those is nuking your .cabal/.ghc and trying again
18:35:12 <dwcook> kholdstare: probably best just to ask. If someone knows, they may answer.
18:35:32 <dwcook> (I've used pipes with concurrency before and may or may not be able to answer.)
18:35:32 <hunt> so i need to be rendering stuff on the fly to a buffer, and thats stored in a state. how expensive is it to write to this buffer in specific slots if its an array?
18:35:45 <kholdstare> thanks dwcook. ill try
18:36:13 <hunt> currently im just rewriting the whole buffer as a list, which is really expensive but easy to work with
18:36:47 <hunt> eventually this buffer has to be made into a storable array so opengl can dispaly it, i dont know what the right pipeline is for this
18:37:25 <djahandarie> 9*
18:37:35 <djahandarie> Sorry, cat.
18:38:05 <GeraldCode> hello, this is just a curiosity question. I tried searching for source code in prelude, but didnt see it.  How is fromInteger defined for the Integer type? Is this actually done in C and not in Haskell?
18:38:35 <Fuuzetsu> GeraldCode: do you mean fromIntegral?
18:38:51 <GeraldCode> Actually I found from Integral..it is a composite of fromInteger and some other function
18:39:02 <Fuuzetsu> ah, I see
18:39:34 <Fuuzetsu> fromInteger is a function in the Num typeclass
18:39:47 <benzrf> method ;)
18:39:49 <Fuuzetsu> this means it's defined on per-instance basis
18:39:53 <Fuuzetsu> benzrf: please
18:39:58 <kholdstare> I'm using conduits to listen on a socket and transform data in a pipeline ( pretty simple so far). Eventually I want to commit this processed data to a database. So I have a thread handling database commands and the conduit drains its data through an STM channel. However the data is very granular and I want to chunk the database commits. Questions: 1. Does this sound like a good architecture? 2. Any existing approaches to chunki
18:40:15 <GeraldCode> yeah. true Fuuzetsu.  I was wondering how the Integer instance handles it
18:40:27 <GeraldCode> because I dont see how you can take a concrete type and make it an abstract type
18:40:33 <GeraldCode> if that is the right wordf
18:40:55 <Fuuzetsu> GeraldCode: but for Integer it would be ‘id’
18:41:07 <Fuuzetsu> fromInteger :: Integer -> a
18:41:18 <GeraldCode> hmmm
18:41:22 <Fuuzetsu> but for the Integer instance, a ~ Integer so fromInteger :: Integer -> Integer
18:41:54 <GeraldCode> I get this in ghci : fromInteger :: Num a => Integer -> a
18:42:02 <GeraldCode> what am I missing here?
18:42:13 <GeraldCode> to me it looks like I am taking a concrete Integer and getting something abstract
18:42:49 <Fuuzetsu> no, you're getting what you ask for as long as it's an instance of Num
18:43:14 <GeraldCode> How would you code that if you were doing it from scratch..just for the hell of it
18:43:22 <GeraldCode> the implementation of fromInteger for the Integer instance
18:43:28 <Fuuzetsu> :t let x :: Double; x = fromInteger 7 in x
18:43:30 <lambdabot> Double
18:43:39 <dwcook> GeraldCode: You don't go from a concrete type to an abstract type, you instantiate the abstract one to a concrete one first.
18:43:54 <GeraldCode> right. thats what I thought
18:43:55 <Fuuzetsu> in that case, we see that we're asking for Double and Double *is* an instance of Num and so that particular implementation is used
18:44:18 <dwcook> GeraldCode: Though as it happens a lot of code can work perfectly fine without instantiating them.
18:44:28 <GeraldCode> right
18:44:41 <GeraldCode> You both make perfect sense
18:44:57 <GeraldCode> but I am just confused as to how this is implemented (just for my own curiosity) for the Integer instance
18:45:08 <GeraldCode> I don't like having no idea how something works..I like to at least have SOME idea
18:45:12 <Fuuzetsu> :t let fromIntegerToDouble :: Integer -> Double; fromIntegerToDouble x = fromInteger x in fromIntegerToDouble
18:45:14 <lambdabot> Integer -> Double
18:45:54 <Fuuzetsu> GeraldCode: for Integer instance, fromInteger x = x
18:45:58 <Fuuzetsu> why would it be anything else?
18:46:06 <Fuuzetsu> there might be some magic there for performance, I don't know
18:46:12 <Fuuzetsu> but this would be the from-scratch-no-magic way
18:46:12 <GeraldCode> because I tried something similar
18:46:30 <GeraldCode> maybe I just screwed up my code
18:46:35 <GeraldCode> let me take another look
18:46:48 <Fuuzetsu> see bottom of http://hackage.haskell.org/package/base-4.7.0.0/docs/src/GHC-Num.html
18:46:51 <Fuuzetsu> it is precisely what I said it was
18:47:21 <GeraldCode> Fuuzetsu, ,check this out..just 2 lines:  foo2::Num a => Integer -> a   AND foo2 x = x
18:47:38 <GeraldCode> This won't compile..."Could not deduce (a ~ Integer)"
18:47:46 <GeraldCode> Is this not similar?
18:47:55 <Fuuzetsu> yes, because your function says something else than the type signature
18:48:41 <Fuuzetsu> your signature says that given an integer, it will give back a value of any type you ask for as long as it is an instance of Num but your function says that it will take an Integer and return an Integer
18:48:58 <Fuuzetsu> so GHC is complaining: you said you'll return anything at all as long as it's part of Num but you're returning an Integer only!
18:49:16 <Fuuzetsu> :t let foo2 :: Num a => a -> a; foo2 x = x in foo2
18:49:18 <lambdabot> Num a => a -> a
18:49:18 <GeraldCode> ok that makes sense
18:49:19 <Fuuzetsu> works however
18:49:29 <GeraldCode> thanks
18:49:32 <Fuuzetsu> no problem
18:49:45 <nisstyre> I have a question about the import syntax, what is the use-case for importing only instances?
18:49:52 <nisstyre> i.e. import Foo ()
18:50:08 <Fuuzetsu> nisstyre: when Foo defines some instances you want to use but you never refer to anything there explicitly
18:50:26 <Fuuzetsu> say some values might be of type Bar but you never refer to Bar explicitly
18:50:26 <nisstyre> Fuuzetsu: hm okay, how often does that need arise?
18:50:29 <nisstyre> I'm curious
18:50:33 <oaulakh> can i make ai virtual personality with haskell?
18:50:40 <GeraldCode> hah
18:50:47 <Fuuzetsu> not that often but it can happen, it's mostly there if you want to import only the things you actually use
18:50:51 <nisstyre> Fuuzetsu: okay so you might need it so your program type checks right?
18:51:01 <nisstyre> that is the main use-case right?
18:51:04 <Fuuzetsu> @faq Can Haskell allow us to make ai virtual personality?
18:51:04 <lambdabot> http://www.haskell.org/haskellwiki/FAQ
18:51:08 <Fuuzetsu> what
18:51:12 <Fuuzetsu> you guys
18:51:13 <Fuuzetsu> why
18:51:38 <Fuuzetsu> nisstyre: yes, say we have intermediate values of Bar and we know there's a Monoid instance
18:51:39 <Fuuzetsu> hm
18:51:45 <nisstyre> Fuuzetsu: yeah
18:51:49 <Fuuzetsu> consider foo x y = x <> y
18:51:51 <dwcook> oaulakh: it's computationally powerful enough for it, although that task in particular is certainly non-trivial.
18:51:51 <nisstyre> that is the conclusion I came to
18:51:58 <nisstyre> I just wanted to see if that was the intended use-case
18:51:59 <Fuuzetsu> where x and y are always Bar
18:52:05 <Fuuzetsu> right
18:52:10 <Fuuzetsu> (that's a shitty example)
18:52:31 <GeraldCode> Fuuzetsu, when you code in other languages besides Haskell, do you find yourself implementing things like Monads and functors?
18:52:45 <Fuuzetsu> GeraldCode: Yes, if possible
18:52:47 <GeraldCode> I see tutorials everywhere for monads in Javascript..Java..C..even PHP
18:52:58 <GeraldCode> interesting..I have been considering taking some haskell into my web work
18:52:58 <Fuuzetsu> if not possible then I usually implement something which behaves like them, maybe already instantiated
18:53:10 <nisstyre> GeraldCode: using a monad does not require you to know that you're using a monad
18:53:11 <GeraldCode> ok good to know..so people actually do it
18:53:19 <nisstyre> linked lists are monads, C programmers have been using those for decades
18:53:25 <GeraldCode> nisstyre, right
18:53:29 <dwcook> GeraldCode: Unfortunately, not many languages' type systems are powerful enough for a "proper" monad abstraction.
18:53:46 <GeraldCode> right
18:53:49 <dwcook> I know from playing with monads in JS that it is somewhat laborious to work with.
18:53:49 <Fuuzetsu> GeraldCode: You should not set out to your Python program or whatever with ‘I'm going to implement monads’, you should rather think ‘damn I could really use Maybe’ so you go and make that
18:53:53 <oaulakh> okkk
18:54:02 <GeraldCode> ah ok
18:54:24 <GeraldCode> dwcook, I dont mind laborious as much as I used to, if it means I can make easier to understand code i suppose
18:54:26 <nisstyre> fyi I have tried implementing Maybe in Python and never found a satisfactory solution
18:54:33 <oaulakh> but can we do it with already made bots and then scripting to complete process tasks?
18:54:46 <GeraldCode> I just went on a one month coding spree to do a project that someone else dropped the ball on
18:55:03 <GeraldCode> and as always when you dont design it turns hard to understand
18:55:21 <GeraldCode> I am thinking I could do better in these stressful situations with a paradigm like functional
18:56:13 <Fuuzetsu> oaulakh: Are you asking whether there are libraries already made for that particular task? Then no, I don't think there are any really complete libraries in any language yet.
18:56:24 <Fuuzetsu> Depending on your definition of AI and problem at hand
18:56:26 <dwcook> GeraldCode: whether it makes code easier to understand in other languages is also a question to be asked
18:56:32 <GeraldCode> true
18:57:18 <oaulakh> i know
18:57:27 <Fuuzetsu> Then what are you asking?
18:57:32 <oaulakh> but can we make it on our own
18:57:37 <oaulakh> and if yes
18:57:49 <oaulakh> then which language would you prefer
18:57:54 <Fuuzetsu> Yes, there is nothing that Haskell does that somehow specifically stops you from doing so.
18:58:14 <Fuuzetsu> I don't know which language I'd prefer, I'm not an AI researcher. Definitely not LISP though ;P
18:58:39 <GeraldCode> Why does LISP have more AI credentials than say Prolog?
18:58:41 <crazydave> lisp is AI language of choice.  Might explain why you aren't an AI researcher
18:58:46 <GeraldCode> I havent researched it, but on its face that seems odd
18:58:47 <Welkin> it doesn't
18:59:02 <Fuuzetsu> GeraldCode: because people like crazydave exist
18:59:04 <Welkin> lisp is used for AI because of tradition
18:59:09 <GeraldCode> ah hah
18:59:24 <oaulakh> then one more question can i control hardware with haskell
18:59:37 <Welkin> I dislike tradition
18:59:45 <Welkin> I'm going to use Haskell for AI
19:00:01 <crazydave> you will need to write some of your code in C to control hardware.  but depending on what you mean by control the answer is yes
19:00:20 <Welkin> it depends on the device you are using
19:00:21 <Fuuzetsu> oaulakh: Yes. There is a guide somewhere how to write kernel modules if you want to. I think someone is porting a *BSD to Haskell too and they had some progress recently. If all else fails you have FFI to C.
19:00:23 <crazydave> Welkin: I think haskell is better than lisp and would be well suited to AI (not that I'm an AI researcher)
19:00:33 <Welkin> you don't *have to*  write in C
19:00:42 <Welkin> in fact, you can write in assembly
19:00:47 <crazydave> you should only need the lowest levels in C
19:01:00 <Samoi> I have two lists of strings of the same size and I want to add the first string in each list together, second in each list together, and so on
19:01:06 <crazydave> okay, mr pedant, assembly could be used instead.  Good luck with the FFI to assembly
19:01:09 <Fuuzetsu> crazydave: Why do you need anything in C? What makes C somehow different from Haskell for this aspect?
19:01:12 <Samoi> can I do it using map and foldr?
19:01:30 <Welkin> the microcontroller must support the language you are using
19:01:32 <Fuuzetsu> What exactly makes Haskell incapable of reading in streams of bytes?
19:01:39 <oaulakh> hahhahha
19:01:43 <Welkin> it usually comes with all the boilerplate you need
19:01:43 <oaulakh> then i will
19:02:22 <crazydave> Fuuzetsu: well that's why I said it depends what you mean by control ... if you need to interface at low levels then you are going to need to be inside the OS
19:02:54 <Fuuzetsu> I'll wait for clarification of the type of control then.
19:03:17 <Fuuzetsu> FTR things like House exist (even if dead)
19:03:24 <crazydave> Fuuzetsu: it is possible for the OS to provide you functions to read and write to a hardware register and thus write your controller in haskell.  Indeed all the logic can be in haskell
19:04:14 <crazydave> there's even possibility of using haskell to write device drivers in Minix (as device drivers are user space programs there). but that's the exception rather than the rule
19:04:24 <Fuuzetsu> great then we agree
19:04:34 <Fuuzetsu> hey, I never said it's a common thing or it should be done
19:04:39 <Fuuzetsu> merely that it's not somehow incapable
19:04:49 <sjy_> if you can/want to load the haskell runtime into memory, sure
19:05:15 <Fuuzetsu> how heavy is the runtime nowadays?
19:06:41 <sjy> hello world is 1.4mb on disk for me
19:07:21 <Fuuzetsu> seems high
19:07:24 <Fuuzetsu> pretty sure you can go thinner
19:07:30 <Welkin> are you high?
19:07:31 <crazydave> but is that statically linked? ldd and see what shared libs it pulls in
19:11:14 <benzrf> @hoogle m Bool -> m a -> m a -> m a
19:11:15 <lambdabot> Control.Exception.Base bracket_ :: IO a -> IO b -> IO c -> IO c
19:11:15 <lambdabot> Control.Exception bracket_ :: IO a -> IO b -> IO c -> IO c
19:11:15 <lambdabot> Control.OldException bracket_ :: IO a -> IO b -> IO c -> IO c
19:11:19 <benzrf> meh
19:11:53 <benzrf> @hoogle m Bool -> m () -> m ()
19:11:53 <lambdabot> Data.Generics.Aliases ext0 :: (Typeable a, Typeable b) => c a -> c b -> c a
19:11:54 <lambdabot> Control.Monad unless :: Monad m => Bool -> m () -> m ()
19:11:54 <lambdabot> Control.Monad when :: Monad m => Bool -> m () -> m ()
19:11:58 <benzrf> lame!
19:12:00 <Fuuzetsu> :t liftM2 (\p x y -> if p then x else y)
19:12:01 <lambdabot> Monad m => m Bool -> m a2 -> m (a2 -> a2)
19:12:07 <Fuuzetsu> :t liftM3 (\p x y -> if p then x else y)
19:12:08 <lambdabot> Monad m => m Bool -> m r -> m r -> m r
19:12:25 <Fuuzetsu> I know what you're looking for ;P
19:12:29 <benzrf> @let ifM c a = c >>= flip when a
19:12:31 <lambdabot>  Defined.
19:12:32 <benzrf> :t ifM
19:12:33 <lambdabot> Monad m => m Bool -> m () -> m ()
19:12:35 <benzrf> coo
19:12:44 <benzrf> ooh thanks
19:12:55 <benzrf> liftM3 if', perhaps
19:12:57 <benzrf> :t if'
19:12:58 <lambdabot>     Not in scope: ‘if'’
19:12:58 <lambdabot>     Perhaps you meant one of these:
19:12:58 <lambdabot>       ‘ifM’ (line 152), ‘f'’ (imported from Debug.SimpleReflect)
19:13:01 <benzrf> hmm, not standard
19:13:02 <Fuuzetsu> if' is not a thing
19:13:06 <benzrf> lame!
19:13:08 <Fuuzetsu> BUT IT SHOULD
19:13:12 <Fuuzetsu> nudge nudge
19:13:21 <benzrf> @hoogle Bool -> a -> a -> a
19:13:22 <lambdabot> Data.Time.Calendar.MonthDay monthAndDayToDayOfYear :: Bool -> Int -> Int -> Int
19:13:22 <lambdabot> Graphics.Rendering.OpenGL.GL.Tensor Vertex3 :: a -> a -> a -> Vertex3 a
19:13:22 <lambdabot> Graphics.Rendering.OpenGL.GL.Tensor Vector3 :: a -> a -> a -> Vector3 a
19:13:23 <Fuuzetsu> go make noise on libraries@
19:13:25 <benzrf> pfft
19:13:29 <benzrf> libraries@?
19:13:35 <Fuuzetsu> the mailing list
19:13:42 <benzrf> eeeeh
19:14:44 <Fuuzetsu> enjoy the 2 week bikeshead on why it shouldn't be if'
19:15:16 <Fuuzetsu> it'd probably be easier to just ask for ifM
19:15:29 <Fuuzetsu> bikeshed*
19:15:31 <benzrf> ;-;
19:15:43 <benzrf> b-bikeshedding
19:15:50 <vanila> bool and boolM
19:16:00 <benzrf> :t liftM3 (\p x y -> if p then x else y)
19:16:01 <lambdabot> Monad m => m Bool -> m r -> m r -> m r
19:16:10 <benzrf> :t liftM (\p x y -> if p then x else y)
19:16:11 <lambdabot> Monad m => m Bool -> m (t -> t -> t)
19:16:13 <benzrf> hmm
19:16:38 <benzrf> :t liftM2 (\p x y -> if p then x else y)
19:16:40 <lambdabot> Monad m => m Bool -> m a2 -> m (a2 -> a2)
19:16:44 <benzrf> o:
19:17:48 <Fuuzetsu> dependently typed liftM when
19:26:13 <vanila> "dependently typed liftM"?
19:26:27 <vanila> :t liftM
19:26:28 <lambdabot> Monad m => (a1 -> r) -> m a1 -> m r
19:27:18 <Fuuzetsu> liftM that takes a natural number >= 1 and gives you the proper type
19:27:34 <Fuuzetsu> rather than having liftM, liftM2 … liftMN hardcoded
19:27:42 <vanila> hmm
19:28:00 <benzrf> oh man
19:28:13 <benzrf> the lambdajam website says 'lambajam' in its title
19:29:20 <athan> benzrf: Is it like a foam party?
19:29:29 <Fuuzetsu> not even lamda so they can't blame it on alternative spelling
19:29:53 <vanila> Fuuzetsu, can it be done in haskell?
19:31:07 <Fuuzetsu> vanila: not properly, no, for some idea of ‘can be done’
19:31:13 <Fuuzetsu> we can try to emulate of course
19:31:16 <vanila> im trying
19:31:36 <Fuuzetsu> vanila: look at attempts to emulate printf in Haskell
19:31:59 <Fuuzetsu> IIRC Oleg has some stuff
19:32:50 <Fuuzetsu> (it should be an easier case of that)
19:41:22 <JakeE> for paralell haskell if I need to evaluate an ordered collection (like a list) in parell what is the best structure to use?
19:42:07 <athan> Fuuzetsu: Did you see that idris type-safe printf? I want to make a haskell port with gadt's + datakinds
19:42:58 <Fuuzetsu> no I didn't but I know how to write one in Agda so it's probably not much different
19:43:15 <Fuuzetsu> athan: there are some papers on printf in Haskell, you could check those out
19:43:27 <Fuuzetsu> http://okmij.org/ftp/typed-formatting/
19:43:35 <Fuuzetsu> the fun part is when you want to use Haskell98 or something ;P
19:45:36 <athan> Fuuzetsu: Hmm...  |||  So, you're trying to make a n-ary liftM automatically coerce? ._.
19:46:20 <Fuuzetsu> nothing of the sort!
19:46:43 <athan> ><
19:46:55 <Fuuzetsu> just want liftM to be able to take a (n : ℕ) >= 1 that will then give me the n-ary lifting function
19:47:24 <augur> so
19:47:26 <Fuuzetsu> I don't actually need this, I just mentioned this a bit above
19:47:35 <augur> i wonder if anyone has considered implementing Idris's ! in Haskell
19:48:02 <Fuuzetsu> you can parametrise Vec by type level naturals and make !
19:48:27 <augur> Fuuzetsu: er...
19:48:35 <augur> idris's bang is for monads :P
19:49:20 <augur> foo !mx !my  ==  do { x <- mx ; y <- my ; foo x y }
19:49:22 <athan> Fuuzetsu: Yeah sorry, I just saw something really intriguing. I'm still not at that level yet :)
19:49:42 <Fuuzetsu> augur: oh, sorry, assumed it was ! for Vecs or !! for lists
19:49:51 <benzrf> @let data S where One :: S Void; S :: (S a)-> S (S a)
19:49:52 <lambdabot>  .L.hs:151:18: Not in scope: type constructor or class ‘Void’
19:49:59 <benzrf> @let data Void
19:50:01 <lambdabot>  Defined.
19:50:02 <benzrf> @let data S where One :: S Void; S :: (S a)-> S (S a)
19:50:02 <lambdabot>  .L.hs:153:16:
19:50:03 <lambdabot>      ‘S’ is applied to too many type arguments
19:50:03 <lambdabot>      In the type ‘S Void’
19:50:03 <lambdabot>      In the definition of data constructor ‘One’
19:50:03 <lambdabot>      In the data declaration for ‘S’
19:50:17 <benzrf> @let data S a where One :: S Void; S :: (S a) -> S (S a)
19:50:18 <lambdabot>  Defined.
19:50:28 <benzrf> :t S (S One)
19:50:29 <lambdabot> S (S (S Void))
19:50:30 <Fuuzetsu> benzrf: it's nicer to just make ℕ and then require (with singletons or else) that the function takes (S n)
19:50:38 <benzrf> hmm?
19:50:50 <Fuuzetsu> defining naturals from one sucks ;P
19:50:57 <benzrf> oh
19:51:04 <benzrf> kk
19:51:09 <benzrf> true dat
19:51:15 <Fuuzetsu> you should use a type family there anyway
19:51:20 <benzrf> oh hmm yeah
19:51:23 <benzrf> i always forget type fams
19:51:31 <benzrf> @undefine
19:51:31 <lambdabot> Undefined.
19:51:38 <benzrf> whats the synt again
19:52:17 <augur> benzrf: what are you trying to do
19:52:52 <benzrf> @let type family Peano a
19:52:52 <lambdabot>  Parse failed: Parse error: EOF
19:52:56 <benzrf> pfft
19:53:00 <Fuuzetsu> don't do it with lambdabot ;P
19:53:04 <benzrf> Fuuzetsu: you were wroooong
19:53:17 <augur> benzrf: what are you trying to do!
19:53:24 <Fuuzetsu> augur: define naturals I think
19:53:38 <vanila> How do you write liftMn+1 using liftMn?
19:54:31 <Fuuzetsu> benzrf: www.cis.upenn.edu/~eir/papers/2012/singletons/paper.pdf‎
19:55:14 <augur> vanila: liftMn :: (a0 -> ... -> an -> an+1 -> b) -> m a0 -> ... -> m an -> m (an+1 -> b)
19:55:26 <benzrf> Fuuzetsu: l-later
19:55:54 <Fuuzetsu> vanila: the idea is that type of liftM : (n : ℕ) { n ≥ 1 } → LiftMType
19:56:12 <athan> Fuuzetsu: Can I have some? :)
19:56:13 <augur> so probably:   liftMn+1 f x0 ... xn xn+1 = do { f' <- liftMn x0 ... xn ; liftM f' xn+1 }
19:56:23 <Fuuzetsu> athan: some what?
19:56:37 <athan> nevermind, sorry!
19:56:55 <Fuuzetsu> vanila: disregard I misread what you asked
19:56:58 <augur> vanila: iinm, liftMn f x0 ... xn = return f `ap` x0 `ap` ... `ap` xn
19:57:00 <athan> The link didn't work at first. Thought you shared a fast one haha
19:57:53 <Fuuzetsu> just one more Mario Kart cup and I'm free from this evil
19:58:09 <Fuuzetsu> wrong channel
19:58:16 <vanila> hahha
19:59:51 <augur> Fuuzetsu: dependent liftM can work for n = 0 too you know!
19:59:56 <augur> Fuuzetsu: liftM 0 = return!
20:00:06 <Fuuzetsu> augur: fair enough
20:00:18 <augur> actually i needed a return in mine too
20:00:25 <augur> the general pattern is quite nice because of that, tho
20:00:26 <vanila> http://pastebin.com/raw.php?i=vhtK2nNk
20:00:29 <vanila> Here's a problem
20:00:55 <vanila> to go from liftMn to liftMn+1, I actually have to use something that's just liftM for (->) already
20:01:58 <augur> liftM[ 0 ] = return ; liftM[ suc n ] = \f mx -> liftM[ n ] (mx >>= return . f)
20:02:00 <augur> or something like that
20:02:02 <augur> i dont know :x
20:02:08 <Fuuzetsu> I feel terrible for even mentioning liftM now, you guys could be doing something useful ;P
20:02:15 <augur> vanila: yes, thats correct
20:02:22 <augur> vanila: but you're going from liftMn to liftMn+1
20:02:29 <augur> so its ok to use liftMn to do that
20:04:40 <augur> liftMn+1 f x0 ... xn xn+1 = {! liftMn f x0 ... xn :: m (an+1 -> b) !}
20:05:01 <augur> liftMn+1 f x0 ... xn xn+1 = do { f' <- liftMn f x0 ... xn :: m (an+1 -> b) ; {! f' :: an+1 -> b !} }
20:05:21 <augur> liftMn+1 f x0 ... xn xn+1 = do { f' <- liftMn f x0 ... xn :: m (an+1 -> b) ; {! liftM f' xn+1 :: m b !} }
20:05:30 <augur> liftMn+1 f x0 ... xn xn+1 = do { f' <- liftMn f x0 ... xn :: m (an+1 -> b) ; liftM f' xn+1 }
20:06:43 <augur> or    liftMn+1 f x0 ... xn xn+1 = liftMn f x0 ... xn >>= \f' -> liftM f' xn+1
20:06:44 <augur> or better yet
20:07:02 <augur> liftMn+1 f x0 ... xn xn+1 = liftMn f x0 ... xn `ap` xn+1
20:07:37 <augur> :t ap
20:07:38 <lambdabot> Monad m => m (a -> b) -> m a -> m b
20:07:47 <augur> ok good, im not loopy. :p
20:08:51 <augur> Fuuzetsu: one thing i dont like about dependent types is that they make variadic functions possible but tedious
20:09:20 <augur> "variadic", actually more generally, adicity-polymorphic
20:09:25 <augur> consider for instance generic composition
20:09:34 <augur> you'd like to be able to write   f .[ n ] g
20:10:56 <augur> where (.[_]) : forall b c. (b -> c) -> forall n. forall a0 ... an. (a0 -> ... -> an -> b) -> a0 -> ... -> an -> c
20:11:24 <augur> but this is a pain in the but to write
20:12:21 <Fuuzetsu> yes, hence the area of research where we make dependent types more usable to programmers
20:12:56 <crazydave> and get rid of zipWithN et al and replace with variadic zipWith?
20:13:49 <augur> i wonder if some auxiliary things could make it easier to use, actually...
20:14:03 <augur> hmm
20:26:46 * hackagebot influxdb 0.3.0.1 - Haskell client library for InfluxDB  http://hackage.haskell.org/package/influxdb-0.3.0.1 (MitsutoshiAoe)
20:27:25 <akurilin> question: is there a base lib implementation of comparison of two rationals?
20:27:29 <hunt> if i need to eventually ship an array off to a foreign process am i better off just using Foreign arrays in the first palce?
20:27:36 <akurilin> that takes an epsilon in account?
20:27:38 <akurilin> so I don't have to write my own
20:31:16 <hunt> anybody?
20:31:36 <hunt> i dont know how hard it is to move my array to Foreign so id rather figure this out upfront
20:31:44 <bitemyapp> hunt: Storable?
20:31:48 <hunt> bitemyapp: yea
20:32:19 <bitemyapp> hunt: yeah I've not done anything with FFI so I'm useless here, sorry :|
20:32:29 <hunt> bitemyapp: lol damn
20:37:27 <hunt> idk does anyone else know anything about arrays and foreign arrays and marshalling the two?
20:43:59 <crazydave> hunt: use whatever you want internally, it isn't hard to wrap a list to a Foreign Array and I assume similar for other data structures
20:44:48 <crazydave> hunt: and using Foreign Array internally seems like a bad idea (basically do your own memory management rather than relying on haskell to do it all for you ... hmmm ... have fun!!!)
20:48:45 <hunt> crazydave: agreed, although i havent found anything thatll allow me to convert to storable?
20:51:17 <enthropy> hunt: maybe the word you want is "Storable"
20:51:39 <augur> does the current haskell platform include GHC 7.8?
20:51:54 <mzero> it will soon
20:51:55 <mzero> this month
20:51:59 <enthropy> such as http://hackage.haskell.org/package/vector-0.10.10.0/docs/Data-Vector-Storable.html#g:36
20:51:59 <mzero> but currently, no
20:52:02 <augur> ok, ill have to wait for that then
20:53:09 <hunt> enthropy: so i should use vector internally and not array?
20:53:58 <enthropy> there's a Data.Array.Storable that offers the same kind of thing
20:54:31 <hunt> enthropy: ah ok, brilliant. are the benefits of vector v array the ssame in haskell as elsewhere?
20:54:39 <enthropy> in those cases you have memory managed by ghc's RTS, but you can get a pointer to that array
20:56:10 <mzero> augur: as in, hang with what you've got (current platform?) and wait to upgrade until later? yeah - it won't be long - I have it building on my machine pretty near done - so betas in about two weeks max
20:56:24 <mzero> maybe as early as next Monday
20:56:32 <augur> mzero: yes
20:56:44 <augur> mzero: oh, you do the platform download?
20:57:05 <mzero> I'm the release manager for the platform, and the packager for the OS X version
20:57:35 <augur> mzero: neat!
20:58:24 <hunt> so wait is it more efficient to use vector or array?
20:58:35 <genericpersona> probably depends on what you're doing
20:59:14 <genericpersona> what do you mean by vector? you mean haskell's built-in List type?
20:59:41 <genericpersona> or is there some haskell vector i'm not aware of
21:01:56 <mzero> There is Vector
21:02:00 <mzero> from package   vector
21:02:02 <mzero> @package vector
21:02:03 <lambdabot> http://hackage.haskell.org/package/vector
21:02:42 <mzero> use that if you need speed
21:03:25 <mzero> Vector is faster than Array - and Data.Vector.Unboxed the fastest.... but be sure you need it
21:03:51 <chirpsalot> geekosaur: oh, forkIO is a thread? I just assumed it was like... Fork :|. Guess the type is pretty blatant. (process timeout question from a while ago).
21:05:49 <chirpsalot> Looks like the System.Process stuff is more what I want.
21:06:45 <TallerGhostWalt> has Control.Concurrent not been setup to use the new IO Manager yet?
21:06:51 * hackagebot HLearn-distributions 1.0.0.2 - Distributions for use with the HLearn library  http://hackage.haskell.org/package/HLearn-distributions-1.0.0.2 (MikeIzbicki)
21:07:11 <TallerGhostWalt> I have been trying to track down a terrible file descriptor limit in acid-state
21:07:22 <TallerGhostWalt> 1024 max (regardless of OS Settings)
21:09:49 <mzero> forkIO is a haskell thread -- not a Posix thread, too... btw
21:11:33 <chirpsalot> mzero: I wasn't really thinking about Posix threads at the moment, but I would probably have assumed that later down the road... So good to know :).
21:11:51 <mzero> remember that Haskell threads are super cheap
21:12:30 <chirpsalot> I don't actually know anything about them.
21:12:56 <chirpsalot> Like "Erlang" cheap? I have just heard a lot about Erlang having "the cheapest threads in town!"
21:13:09 <TallerGhostWalt> lol
21:13:25 <TallerGhostWalt> That thread is so cheap!... How cheap is it
21:13:31 <mzero> chirpsalot: yes - that cheap
21:15:15 <fread2282> what alternatives are there to acid-state?
21:16:53 <TallerGhostWalt> I dunno but I might want to soon
21:17:00 <TallerGhostWalt> I am getting tired of this file descriptor thing
21:17:57 <fread2282> I wanlt something that can manage very big data structures that for a given run will be mostly unneeded
21:18:04 <fread2282> locally
21:18:12 <mzero> chirpsalot: check out slide 3 in http://slidedeck.io/etrepum/haskell-for-erlangers-2014
21:18:35 <mzero> Erlang process = 2.6k each.... Haskell 1.3k
21:19:06 <fread2282> mzero: memory use?
21:19:12 <hunt> wtf! why isnt Data.Vector in base?
21:19:13 <mzero> yeah
21:19:16 <chirpsalot> mzero: the Control.Concurrent documentation says that only one thread can execute at a time?
21:19:17 <TallerGhostWalt> mzero: but what about the IO manager?  is it getting wins there because of that
21:19:24 <mzero> no - one per CPU
21:19:35 <chirpsalot> "...The downside of having lightweight threads is that only one can run at a time"
21:19:36 <TallerGhostWalt> in 7.8.2?
21:19:49 <mzero> TallerGhostWalt: not sure what you mean
21:19:50 <TallerGhostWalt> or earlier?
21:20:02 <chirpsalot> mzero: ah... But isn't that the case with everything? Processes and all?
21:20:28 <fread2282> chirpsalot: you need to run haskell with +RTS -Nn where n is the number of native threads you want
21:20:33 <mzero> not sure what you mena, chirpsalot
21:20:35 <copumpkin> The downside of having lightweight threads is that only one can run at a time, so if one thread blocks in a foreign call, for example, the other threads cannot continue. The GHC runtime works around this by making use of full OS threads where necessary
21:20:36 <dmj`> chirpsalot: that's not true
21:20:48 <copumpkin> chirpsalot: why not read the next sentence?
21:20:49 <mzero> oh - yes, of course, only one thing per CPU core
21:20:52 <fread2282> chirpsalot: it runs one lightweight thread per native thread at a time
21:21:59 <chirpsalot> mzero: I mean that only one thing can execute on a CPU at a time whether or not it's a thread, or process, or whatever... I mean, I guess they mean that the lightweight threads can't be interrupted, so if something blocks it's stuck?
21:22:28 <TallerGhostWalt> mzero: nm
21:22:55 <hunt> can someone vouch for Data.Vector before i add it as a dependency?
21:23:06 <TallerGhostWalt> hunt: vouch?
21:23:10 <hunt> er vouge?
21:23:13 <fread2282> chirpsalot: depends what it's blocking on
21:23:34 <chirpsalot> fread2282: oh?
21:23:38 <TallerGhostWalt> it is a good package, but watch out on the foldl into a list, can generate ridiculous long compile times
21:23:42 <hunt> idk indicate that it really is quality and i can trust it/should use it instead of base options
21:23:43 <mzero> hunt - it is part of Haskell Platform - I think you are safe to depend on it!
21:23:43 <dmj`> are there any updated web framework benchmarks that use 7.8.2?
21:23:52 <hunt> mzero: ah great thanks
21:23:56 <mzero> (which is part of the reason the Platform exists!)
21:24:22 <fread2282> chirpsalot: the IO manager makes IO schedule another haskell thread, and there are different ways to call into C
21:28:03 <fread2282> chirpsalot: the IO manager can reschedule on GC
21:31:36 <carter> hunt: Vector is a very stable package
21:31:56 <carter> hunt: even though i may be getting  few patches in soon
21:31:58 <carter> its very very stable
21:32:21 <fread2282> chirpsalot: rather on alloc
21:32:22 <hunt> carter: excellent, im looking forward to the immense speedups when i get it working
21:32:37 <carter> hunt: its ok to write imperative code in haskell using vector too
21:32:43 <carter> though stream fusion can be a big win
21:32:47 <carter> hunt: whats your use case?
21:33:55 <NemesisD> hey folks. i'm not sure why but i'm having a hard time figuring out how i'd generate depth-first paths through an n-ary tree?
21:34:19 <carter> what dat adefn?
21:34:43 <NemesisD> ive got something like data Tree a = Node a [Tree a], trying to write something treePaths :: Tree a -> [[a]]
21:35:35 <carter> ahhh
21:35:41 <carter> NemesisD: so the suffixes would be shared?
21:35:51 <carter> i mean prefixes
21:35:56 <carter> erm
21:36:03 <carter> yes
21:36:15 <carter> NemesisD: build the paths in reverse, so the prefixes would be shared
21:36:19 <carter> and walk around using a zipper?
21:36:54 * hackagebot HLearn-classification 1.0.1.3 -   http://hackage.haskell.org/package/HLearn-classification-1.0.1.3 (MikeIzbicki)
21:37:15 <NemesisD> i'm actually going to be porting this algorithm back to ruby. i started writing it in haskell because i thought i'd have an easier time of it
21:37:19 <hunt> carter: im writing a basic renderer for my graphics class
21:37:30 <carter> NemesisD: zippers
21:37:39 <hunt> carter: im using the vector to buffer my pixels and then hand over to opengl
21:37:51 <carter> oh
21:38:09 <hunt> carter: currently using lists everywhere, which is extremely slow
21:38:21 <benzrf> woot
21:38:21 <hunt> carter: like 5fps or something
21:38:25 <benzrf> i think
21:38:29 <dmj`> NemesisD: http://lpaste.net/105053
21:38:29 <carter> lists would do that
21:38:52 <benzrf> that this is my first haskell project im actually taking partially seriously
21:39:22 <benzrf> as opposed to some fun little hack sort of thrown together without caring too much about setting up a repo or anything
21:39:25 <dmj`> at least I believe that's dfs for a rose tree
21:40:04 <hunt> carter: in my case, where im going to be updating a lot of pixels at once, what do you think would be the best way to do that with vectors? i know mass update exists but it doesnt seem like it would actually avoid the pitfalls of lists because i still have to run through the list for every pixel change
21:40:13 <benzrf> sleeping now good night yall
21:40:15 <benzrf> bye
21:40:19 <carter> hunt: imperative mutable vectors :)
21:40:19 <benzrf> bye
21:40:26 <carter> Storables probably
21:40:33 <hunt> carter: does it need to be mutable? its not changing size
21:40:51 <carter> hunt: .... you can write, not just read
21:41:00 <NemesisD> dmj`: hmm. my use case is a bit different. say i have a tree (a [(b [c d])]), i'd expect [[a, b, c], [a, b, d]]. let me see if i can modify that dfs
21:41:09 <hunt> carter: yea why not have it be immutable though?
21:41:17 <carter> hunt: dpends
21:41:55 * hackagebot async-extras 0.1.1.0 - Extra Utilities for the Async Library  http://hackage.haskell.org/package/async-extras-0.1.1.0 (JonathanFischoff)
21:42:39 <glguy> NemesisD: something like this? let paths (Node a []) = [[a]]; paths (Node a xs) = map (a:) (concatMap paths xs)
21:42:48 <glguy> paths (Node 1 [Node 2 [], Node 3[]])
21:42:48 <glguy> [[1,2],[1,3]]
21:46:03 <NemesisD> glguy: oh man thats it. i don't know why i was having such a hard time
21:46:24 <NemesisD> embarassingly, i spent about an hour fiddling with different ways to do this
21:48:13 <fread2282> is there a way to check if something is a thunk?
21:49:03 <roboguy_> fread2282: like in ghci?
21:49:15 <roboguy_> you can do that with :sprint (and :print) in ghci
21:49:28 <hunt> carter: if i start out with a non storable vector is it problematic to convert it to storable?
21:49:30 <fread2282> roboguy_: no not in ghci
21:49:40 <roboguy_> fread2282: what's your use case?
21:49:44 <kadoban> fread2282: ghc-vis maybe?
21:50:13 <rwbarton> there is a magic GHC function for it yes
21:50:45 <carter> hunt: write ALL Your codes using Data.Vector.Generic and you'll be vine
21:50:47 <carter> *fine
21:51:30 <fread2282> is there some container type I should be using instead of [(a,Bool)]?
21:51:40 <hunt> carter: is it still fast?
21:51:49 <carter> if it isn't, file a bug
21:51:59 <carter> hunt: note that i'm saying "write the algorithm as generic"
21:52:10 <carter> not "use boxed stuff"
21:52:16 <carter> use Unboxed to start with
21:52:20 <carter> then move to storable
21:52:41 <roboguy_> fread2282: maybe. what are you doing with it and what is a?
21:52:42 <kadoban> fread2282: I don't think that's an answerable question without knowing something of the relationship between the As and the Bools.
21:54:29 <fread2282> the bool is if a is active. when it is True, a will be actively modified
21:54:42 <roboguy_> what does active mean?
21:55:40 <fread2282> roboguy_: different things, but mostly that it will be used and modified
21:56:05 <roboguy_> fread2282: why do you need to know if it's active? what do you do with that information?
21:56:45 <kadoban> fread2282: What operations do you perform on the data structure? Do you lookup the Bool associated with a certain 'a'? Do you add/remove elements from the list? Are the 'a's unique?
21:57:55 <fread2282> realized I should probably be storing the Bool somewhere else, so nevermind
22:00:40 <fread2282> should I be using an OrderedList type?
22:00:49 <platz> unfortunately vectors seem to be terrible at append/prepend
22:00:58 <platz> or is there a trick around this
22:01:05 <platz> pre-allocating chunks?
22:01:06 <mzero> no - that is the trade off for speed
22:02:32 <roboguy_> fread2282: well, that again depends on what you're doing with it. what operations do you want to do the most to it?
22:03:08 <dibblego> how might I ask lambdabot to join #nicta-course channel?
22:03:14 <fread2282> roboguy_: long list of data sorted by time, mostly accesing data near the head and consing
22:03:59 <roboguy_> fread2282: it's always going to be sorted? what about a heap?
22:04:38 <roboguy_> or, I should say, a priority queue
22:04:55 <carter> dibblego: ask  int-e:
22:05:05 <dibblego> thanks
22:05:12 <dibblego> int-e: ping
22:09:37 <TallerGhostWalt> ugh well I was really hoping the whole file descriptors problem I have been having wasn't inherent to acid-state
22:09:41 <TallerGhostWalt> but I think it is
22:10:02 <TallerGhostWalt> built a test repo with everything else stripped out and getting the same result
22:12:09 <koala_man> dibblego: oy m8
22:12:16 <dibblego> omfg it's koala_man!
22:16:29 <fread2282> hashset doesn't have a hashable instance :(
22:17:46 <roboguy_> fread2282: you want to hash an entire hashset?
22:18:17 <fread2282> roboguy_: i want to store the HashSet in a HashSet, so yes
22:19:06 <roboguy_> fread2282: why?
22:19:38 <roboguy_> it seems like it'd probably be a pain to make sure that there are no duplicate HashMaps
22:19:46 <roboguy_> I mean HashSets
22:20:18 <kadoban> That really seems like quite a strange thing to do
22:30:36 <roboguy_> that too
22:33:55 <fread2282> roboguy_: I guess I could just use normal lists or Sequences
22:34:56 <fread2282> I was using sets because I thought that enforcing the uniqueness was a good idea
22:35:03 <roboguy_> fread2282: maybe that's a good idea, but what do you want to do with it? you said it needs to stay sorted right? that makes me think of priority queues
22:35:30 <kadoban> Yeah, your description before really really suggested a priority queue...
22:35:41 <fread2282> roboguy_: the sorted list is separate, I'm just using a normal list
22:36:04 <fread2282> it's a log, not a queue btw
22:40:25 <augur> if you had to pick one thing that you think OO does well but pure FP doesn't do well, what would that be?
22:41:31 <dmj`> null reference exceptions
22:41:35 <roboguy_> augur: does subtyping count or should it be something more concrete?
22:41:39 <dmj`> really good at that
22:41:46 <augur> dmj`: haha
22:41:53 <fread2282> augur: FP doesn't have to suck at it, but haskell's records suck
22:41:55 <augur> roboguy_: OO doesnt doing subtyping well :P
22:42:04 <augur> roboguy_: but what specifically did you have in mind?
22:42:12 <augur> fread2282: in what ways?
22:42:13 <roboguy_> augur: well, I'm not sure that Haskell can do subtyping at all
22:42:24 <roboguy_> in the sense of OO anyway
22:42:34 <augur> roboguy_: it doesnt do subtyping on ADTs, but rather on type classes
22:42:39 <augur> "subtyping"
22:43:07 <roboguy_> augur: yeah, but there's no good way to express "A is a subtype of B", given types A and B
22:43:28 <roboguy_> that's the main thing I can think of off the top of my head
22:43:45 <augur> roboguy_: do you have a concrete example of this? like, what you'd like to write, but cant?
22:44:52 <roboguy_> augur: a GUI system. it's hard to express a hierarchy of different objects. maybe a function (like something that manipulates a form) can take any type of object and we want to be able to use "subtypes" like textfields, radio buttons, etc
22:44:58 <sfffffd> I'm matching on value constructors in 'case'.  Is there a thing similar to as-patterns, so I could do: case foo of { Right v1@[(ValueConst Foo _ _)] -> print $ head v1; _ -> print "got nothing" }?
22:45:21 <augur> roboguy_: i think you'd end up using type classes for those tho
22:45:31 <roboguy_> augur: yeah you do, but it's not pretty
22:45:39 <augur> example?
22:46:52 <fread2282> augur: big programs need nasty namespacing or prefixing, the syntax is ugly, they aren't first-class items
22:47:07 <fread2282> augur: you can't overload stuff on them
22:47:18 <roboguy_> augur: you end up with a lot of empty type classes. gtk2hs is an example of this
22:47:30 <roboguy_> sfffffd: as-patterns work normally in case expressions
22:47:55 <sfffffd> roboguy_: Could you provide an example?  It fails for me.
22:47:57 <roboguy_> sfffffd: although I'm not sure what you're asking, now that I reread this
22:48:03 <augur> roboguy_: i'll look at gtk2hs
22:48:36 <augur> fread2282: fair enough
22:49:57 <fread2282> OverloadedRecordFields fixes some of it
22:50:11 <roboguy_> sfffffd: http://lpaste.net/105056
22:50:26 <roboguy_> granted, subtyping doesn't seem to come up too much in FP
22:50:29 <fread2282> NoRecordSyntax + a replacement is also good
22:50:35 <augur> fread2282: yeah, i was about to say :)
22:50:45 <augur> fread2282: what about the syntax do you dislike?
22:51:25 <fread2282> augur: it feels completely out of place with the rost of haskell and nested updates are hard compared to lens/OOP
22:51:41 <augur> roboguy_: can you point me to some gtk2hs code that you thing is exemplary of this problem?
22:51:53 <fread2282> s/rost/rest/
22:52:03 <augur> fread2282: how do you mean out of place?
22:52:06 <roboguy_> augur: this kind of thing happens a lot http://hackage.haskell.org/package/gtk-0.12.5.7/docs/Graphics-UI-Gtk-Multiline-TextBuffer.html#t:TextBufferClass
22:52:27 <roboguy_> an empty type class plus castTo...
22:52:32 <augur> i dont use records at all, really, so my experience with them, and with update syntax, isnt up to snuff :p
22:52:57 <roboguy_> sfffffd: what are you trying to do specifically?
22:54:05 <fread2282> augur: IMO the rest ofhaskell looks clean, but record syntax feels almost like boilerplate
22:54:11 <augur> roboguy_: why does that happen at all? the only reason i could see doing it is if you're defining a subclass, but there are no methods defined, so why?
22:54:12 <roboguy_> lenses do help some with the record stuff but there are still some issues that will hopefully be worked out eventually
22:54:16 <fread2282> augur: personal opinion though
22:56:22 <roboguy_> augur: it's so you can have a "subtype" of TextBuffer. an example that's further down the object hierarchy would be http://hackage.haskell.org/package/gtk-0.12.5.7/docs/Graphics-UI-Gtk-Misc-Viewport.html#t:ViewportClass
22:56:46 <augur> fread2282: do you mean the nested record update in the first answer http://stackoverflow.com/questions/7365425/is-there-a-haskell-idiom-for-updating-a-nested-data-structure
22:57:29 <augur> roboguy_: but whats the point of a subtype that isn't introducing new functionality? that seems useless
22:57:50 <fread2282> augur: yep
22:57:54 <augur> fread2282: ok
22:58:28 <augur> fread2282: i wonder why nested record update couldn't be done with an accessor chain
22:58:34 <roboguy_> augur: the type class doesn't introduce the new functionality, it exists only to try to express the sub type relationship
22:58:56 <fread2282> augur: lensns are generic accessor-like things
22:58:58 <roboguy_> augur: it can with lenses, which look quite a bit nicer than nested record updates (in my opinion)
22:59:00 <fread2282> *lenses
22:59:47 <augur> fread2282: yes thats true, but they also require special support to derive lenses automatically
22:59:48 <fread2282> augur: they're in the second part of that answer
23:00:23 <fread2282> augur: eh, nobody uses non-GHC compilers and TH isn't that bad
23:00:24 <augur> fread2282: im more curious why it couldnt be possible to add better update syntax to haskell directly
23:00:50 <fread2282> augur: why add better syntax when we can do it in user code?
23:01:11 <augur> roboguy_: well i think expressing a subtype relation like that is a bit silly.. i mean, even in OO, it seems silly to define   class Foo : Bar {}
23:01:24 <augur> fread2282: because its _not_ in user code
23:01:40 <augur> felipe_: TH is not user code, its a whole complex preprocessor gadget
23:01:53 <sfffffd> roboguy_: nevermind, it works now.
23:02:20 <glguy> TH is a shortcut and not necessary for using lenses
23:02:21 <roboguy_> augur: but what if you want to make a function that will work on any Bin?
23:02:25 <fread2282> augur: true, but then why not just add compiler support for deriving lenses?
23:02:26 <augur> glguy: i know that
23:02:35 <augur> glguy: but it IS necessary to derive lenses automatically
23:03:06 <glguy> Why's that?
23:03:15 <augur> glguy: what?
23:03:23 <glguy> Why is it necessary to do it automatically?
23:03:58 <augur> roboguy_: anything that's a bin is also its superclass, if the class for bin is empty, so why make a function that only works on bins?
23:04:08 <augur> glguy: because thats what computers are for.
23:04:29 <augur> glguy: if the user/programmer is writing something that the computer can do for them, something has gone wrong
23:04:32 <roboguy_> augur: I'm not sure I understand
23:04:33 <glguy> I agree it can be a good idea, but I don't think that's what necessary means
23:05:03 <augur> glguy: sorry, i think we miscommunited
23:05:20 <augur> glguy: "it" was referential: that is, i meant "but TH IS necessary to ..."
23:05:22 <fread2282> augur: but what's wrong with TH?
23:05:23 <glguy> yeah, misunderstanding resolved :)
23:05:35 <roboguy_> I mean, what if you want doSomethingBinRelated :: (*something to say 'a' is Bin or a subtype of Bin*) => a -> a
23:05:43 <glguy> I don't think it's an improvement to bake something into GHC that could be done reasonably in TH
23:05:44 <augur> fread2282: TH is shady and dangerous :P
23:05:54 <augur> roboguy_: no whatim saying is, this is silly and useless:
23:05:56 <fread2282> augur: so are compilers
23:06:00 <glguy> It's admitting failure when you have to resort to changing the compiler
23:06:01 <augur> class Foo a => Bar a {}
23:06:08 <roboguy_> augur: yeah, but that's not my point
23:06:08 <augur> doToBar :: Bar a => a -> blah
23:06:15 <roboguy_> that's missing the point of the type class I think
23:06:28 <roboguy_> the type class expresses the "(*something to say 'a' is Bin or a subtype of Bin*) =>" constraint
23:06:47 <augur> roboguy_: i know what
23:07:01 <augur> roboguy_: but why bother doing that, since the type class adds no new functionality?
23:07:09 <augur> consider the Foo Bar example i gave
23:07:16 <augur> the class Bar adds nothing
23:07:29 <augur> so the Bar a constraint is over-specific
23:08:08 <augur> anything that is a Bar a is also Foo a, and you can swap out the Bar constraint for a Foo one, and leave the definition unchanged
23:08:30 <roboguy_> augur: if you think of type classes like logic programming predicates, then "Bar a =>" says that "a" satisfies the predicate "Bar" and in this case the predicate means that "a" is a subtype of something related to "Bar". I'm not saying it's a good way to do this, but this is pretty much how subtyping has to be expressed in haskell
23:08:32 <augur> fread2282: indeed compilers are, but i'd rather one dangerous thing than two :)
23:08:36 <augur> roboguy_: i know that
23:08:49 <roboguy_> augur: you get some things that are (for some reason) outside the type class that work on "Bar a =>" which is where the functionality comes in
23:08:49 <augur> roboguy_: but what im saying is, vacuous subtyping is unnecessary
23:08:58 <roboguy_> well maybe
23:08:59 <roboguy_> I'm not sure
23:09:17 <fread2282> augur: doing record stuff in the compiler is just as dangerious and shady as doing it in TH
23:09:27 <augur> roboguy_: there is literally nothing you can do with   f :: Bar a => Baz   that you cant do with   f :: Foo a => Baz
23:09:36 <roboguy_> fread2282: well, to be fair, TH can do some dangerous stuff like IO
23:09:36 <augur> roboguy_: except restrict usage unnecessarily
23:09:41 <augur> roboguy_: its too specific
23:10:12 <augur> fread2282: yes, but having TH is overkill
23:10:24 <roboguy_> augur: there's a whole list of functions that operate on, for example, " ViewportClass self => " though. so you can use those
23:10:49 <roboguy_> I know the usual intuition about type classes doesn't make sense here, but that's my point: it's hard to express this kind of thing well in haskell
23:11:01 <augur> roboguy_: yes, but if you swappwed the ViewportClass constraint for a BinClass constraint they would all STILL work
23:11:07 <fread2282> augur: having compiler support for loads of differend sugars is more overkill
23:11:19 <augur> fread2282: maybe maybe
23:11:59 <augur> i'd say it's less overkill, because its constrained. TH lets you go wild with all sorts of other whacky things. compiler support doesnt
23:12:13 <roboguy_> augur: no, you can't use, for example "viewportGetHAdjustment :: ViewportClass self => self -> IO Adjustment" with something that you just know is BinClass
23:12:27 <roboguy_> you need a ViewportClass or higher up
23:12:33 <augur> roboguy_: most assuredly you can
23:12:39 <augur> roboguy_: thats the beauty of parametricity
23:13:12 <augur> roboguy_: because the ViewportClass class adds no new functionality, viewportGetHAdjustment cannot depend on anything specific to self's ViewportClass behavior
23:13:24 <augur> because there IS no ViewportClass behavior
23:13:26 <augur> its vacuous
23:13:49 <roboguy_> augur: hold on, I'll give you an example
23:13:51 <fread2282> augur: but having code in a well-known and tested library is just as safe as having it in the compiler
23:13:57 <roboguy_> oh god, if cabal doesn't freak out on me
23:14:07 <augur> roboguy_: perhaps an idealized simple example that isnt related to GTK2HS?
23:14:15 <glguy> Th code is typechecked
23:14:30 <augur> fread2282: i suppose thats true
23:14:36 <roboguy_> augur: well, gtk2hs uses some magic which is the tricky part. that's why the parametricity intuition doesn't work how you'd expect necessarily
23:14:42 <roboguy_> sort of
23:14:48 <roboguy_> it's all internal magic though
23:14:48 <augur> roboguy_: im skeptical of this
23:14:54 <glguy> Putting it in the compiler " lets you go wild with all sorts of other whacky thing"
23:14:58 <fread2282> and lens is probably getting more contributers these days than GHC
23:15:06 <roboguy_> augur: I definitely understand the skepticism
23:15:54 <augur> roboguy_: theres really no way you're getting around parametricity with this one
23:16:28 <roboguy_> augur: gtk2hs cheats. hold on, let me see if I can install this and make a good concrete example
23:17:08 <augur> roboguy_: its not gtk2hs that im concerned about. its haskell. the haskell code itself cannot depend on ViewportClass-specific functionality because there _is none_
23:17:27 <roboguy_> augur: http://hackage.haskell.org/package/gtk-0.12.5.7/docs/Graphics-UI-Gtk-Misc-Viewport.html#g:5
23:17:38 <roboguy_> those are all ViewportClass specific
23:17:49 <augur> roboguy_: i beg to differ :)
23:18:02 <augur> roboguy_: the types make the Viewportclass specific, but the _implementation_ cannot
23:18:15 <roboguy_> augur: right, but the types are what are exposed not the implementation
23:18:24 <augur> roboguy_: you can replace the ViewportClass constraint with a BinClass constraint and it would still work
23:18:27 <roboguy_> and the implementation can be, with the right magic
23:18:42 <roboguy_> http://hackage.haskell.org/package/gtk-0.12.5.7/docs/src/Graphics-UI-Gtk-Misc-Viewport.html#viewportGetHAdjustment
23:19:17 <augur> roboguy_: (toViewport self)
23:19:37 <fread2282> augur: it's gtk+. not haskell types
23:19:53 <fread2282> it's calling into C
23:20:24 <roboguy_> yeah. the weird type class stuff is an attempt to replicate the "class hierarchy" of gtk
23:20:26 <augur> but what is in the C code that these type classes are replicating?
23:21:00 <roboguy_> you can make OO-like stuff in C and that's what they did with gtk
23:21:07 <augur> roboguy_: yes but what i mean is
23:21:13 <augur> is ViewportClass also a class in the C code?
23:21:31 <augur> and if so, is it also a vacuous class?
23:21:54 <roboguy_> hmm I feel like there's a miscommunication here
23:22:25 <hamishmack> augur: https://developer.gnome.org/gtk3/3.10/GtkViewport.html
23:23:19 <hunt> is there a function for Data.Vector that takes a vector, a vector of indices and takes a value and puts that value at all those indices in the first vector?
23:23:38 <hunt> seems unneccessarrily inefficient to generate an n-length vector in this case
23:24:52 <augur> hamishmack: im not sure why functionality all of that functionality is missing from the Haskell class!
23:25:32 <roboguy_> augur: it's separated out into those functions that are external to the type class. I'm not totally sure why though
23:25:41 <roboguy_> I guess because there is only one implementation
23:26:05 <augur> roboguy_: but tthats my point, right: those functions are functions that are part of the class definition
23:26:14 <augur> roboguy_: all subclasses of GtkViewport have to implement them
23:26:25 <augur> roboguy_: so if you subclass it, you have to have them
23:26:37 <augur> roboguy_: but you cant subclass ViewportClass and say the same thing
23:26:48 <roboguy_> augur: I think the calls to the C code + the internal unsafe casting takes care of using the multiple (C) implementations
23:26:53 <augur> roboguy_: the Viewport type has those, maybe, but it cant be subclassed at all
23:27:11 <roboguy_> anyway, my point is that this is bad haha
23:27:21 <augur> roboguy_: but, GTK2HS is trying to mirror GTK, so maybe it makes sense
23:27:37 <augur> roboguy_: the real point im trying to make is, Haskell isnt the problem here, haskell does subtypes just fine
23:28:10 <augur> roboguy_: the problem is that the GTK2HS translation doesnt need any of that, because GTK is fixed, insofar as the GTK2HS design is concerned
23:29:06 <roboguy_> augur: I've never seen subtypes done well in haskell... I've only seen subclasses
23:29:18 <augur> roboguy_: except GtkViewport _is_ a subclass
23:29:26 <augur> OO subtyping is subclassing
23:29:33 <augur> which haskell's type classes can mirror fairly nicely
23:29:36 <roboguy_> not in the haskell sense of subclassing
23:29:43 <hamishmack> you cannot create a subtype of a Gtk type in haskell (at least not easily), but normally that is not necessary.
23:29:54 <roboguy_> augur: in OO, classes are types
23:29:55 <augur> hamishmack: i know that
23:30:00 <roboguy_> in haskell classes are not types
23:30:08 <roboguy_> they are classes of types
23:30:11 <augur> hamishmack: what im saying is, if the GTK people added a subclass or two, it would be a problem
23:30:16 <augur> roboguy_: yes i know that
23:30:24 <augur> roboguy_: but that doesnt change the issue
23:31:35 <hamishmack> augur: It would just need to be added in here… https://github.com/gtk2hs/gtk2hs/blob/master/gtk/hierarchy3.list
23:31:40 <roboguy_> augur: well, if you can write a good subtype hierarchy in haskell that would be pretty nice. I tried that before and it didn't work out and (like I said) I've never seen a good way to do it
23:32:18 <augur> hamishmack: how? there is no common ViewportClass interface for all subclasses of GtkViewport to go through!
23:33:13 <augur> hamishmack: there is no _generic_ specification of, say, viewportGetHAdjustment, what there is is a speification in terms on only one type: Viewport
23:34:12 <augur> hamishmack: which means if you add a new subtype, you cant easily update GTK2HS because the very definition of that function is via Viewport, which ISNT sufficient in isolation
23:34:42 <augur> hamishmack: the point of typeclasses is to define the interface. the correct way to translate GtkViewport would be to put those methods into the ViewportClass declaration
23:35:02 <augur> roboguy_: well i'd like to see an example of why it doesnt work
23:35:19 <augur> roboguy_: because the GTK2HS example isnt one
23:35:21 <fread2282> augur: that's questionable when there's only one implementation
23:35:25 <roboguy_> augur: it's hard for me to prove that it doesn't work. I've just never seen it work and I've heard people talk about it a good amount
23:35:36 <augur> fread2282: there's only one implementation _now_. but GTK might change
23:35:49 <augur> fread2282: defining it like this is fragile
23:36:11 <roboguy_> augur: it would be better if you could give me an example of how it could work I think
23:36:15 <augur> roboguy_: how about you construct an example of where OO gets it right but haskell doesnt? just something simple
23:36:32 <augur> and ill do my best to show you what i think is the right way to implement it!
23:37:33 <roboguy_> well, if it *is* true that there isn't a good way to represent subtypes in Haskell (maybe I *am* wrong about that though), then OO is better at expressing things that are most easily expressed as subtype relations
23:37:39 <fread2282> augur: it's impossible to predict all of the possible changes to gtk
23:37:45 <augur> fread2282: precisely!
23:38:02 <augur> fread2282: which is why the suggestion im making is better, because its not prone to breaking when GTK changes
23:38:04 <hamishmack> How could Gtk add a new GtkViewport that you could not call gtk_viewport_get_hadjustment on (bad example as it is depricated)?
23:38:30 <fread2282> but those functions are all just calling toViewport before calling out to C
23:38:48 <augur> hamishmack: Gtk could, but to do that in haskell wouldnt work so hot. you'd have to convert down to a Viewport value, then back up to the new type
23:38:53 <coppro> roboguy_: use a record type with functions, rather than a typeclass
23:38:54 <fread2282> hamishmack: why don't you require the user to call toViewport in their code?
23:39:12 <roboguy_> coppro: that would help, but there's no way to subtype data types in haskell
23:39:33 <augur> roboguy_: yes i agree. i just want to see an example of an OO class hierarchy that takes advantage of the subclassing structure, but which you think Haskell cant replicate nicely
23:39:40 <roboguy_> coppro: oh, you mean like prototype based OO? I've heard of that suggestion before, that's probably the best idea I've seen actually
23:39:40 <coppro> roboguy_: not directly, no
23:39:44 <augur> roboguy_: it ought to be simple enough to provide, if its true that it exists
23:40:06 <fread2282> roboguy_: yea but you don't get the nice implicit passing andt resolution that type classes get
23:40:29 <coppro> roboguy_: now, you're talking about a very fundamental problem of programming language design whose name I cannot remember
23:40:37 <roboguy_> coppro: the expression problem?
23:40:41 <coppro> roboguy_: yes that one
23:40:53 <coppro> roboguy_: but in the more limited cases, usually the OO idiom is to have "interfaces" which are just abstract sets of functions
23:41:24 <coppro> so you can replicate this in Haskell as data FooI a = { doSomething :: a -> Int, doSomethingElse :: [a] -> (a, Bool) }
23:41:28 <augur> coppro: which is what abstract classes and type classes both probid! :)
23:41:32 <roboguy_> augur: well, the GUI example seems natural. basic GUI objects have sizes and positions. some of them have text, etc
23:41:41 <augur> roboguy_: yes
23:42:01 <augur> class ThingWithSizeAndPosition a where { size :: a -> Size, position :: a -> Position }
23:42:03 <roboguy_> coppro: right, that always seemed to me to be the best way to express that
23:42:12 <coppro> that's because it is :)
23:42:21 <augur> class ThingWithSizeAndPosition a => TThingWithText a where { text :: a -> Text }
23:42:26 <augur> roboguy_: problem solved!
23:42:30 <roboguy_> there are some serious problems with expressing them as type classes thoguh
23:42:37 <augur> such as?
23:42:39 <roboguy_> you can't have a list of GuiObjects
23:42:43 <fread2282> coppro: interfaces are type classes
23:42:59 <augur> thats true, roboguy_. well, sort of.
23:43:13 <coppro> fread2282: not necessarily.
23:43:23 <coppro> it depends on exactly what you're trying to do
23:43:24 <danilo2> Hello! Does anybody know where is the "Constraint" type defined? (I want to use it like here: http://www.haskell.org/ghc/docs/7.4.1/html/users_guide/constraint-kind.html)
23:43:34 <augur> roboguy_: you need heterogeneous lists, which you can do in haskell with existential types. and then you're only able to use the GuiObject interface, as expected
23:43:39 <enthropy> danilo2: GHC.Exts
23:43:46 <roboguy_> augur: right
23:43:57 <fread2282> coppro: some OO languages don't do function polymorphism. but otherwise yes
23:43:58 <augur> roboguy_: which is precisely what you want to do
23:44:03 <roboguy_> wait, do existential types work for that
23:44:07 <augur> roboguy_: yes!
23:44:23 <danilo2> enthropy: thank you!
23:45:10 <coppro> fread2282: no, because of things like Haskell not allowing heterogeneous lists. Sometimes the more expressive way is to use the record type
23:45:20 <coppro> unfortunately, I am zoning out on a good example atm
23:45:57 <augur> i believe you can do this in haskell:   data HCList c = Nil | forall a. c a => Cons a (HCList c)
23:46:00 <augur> roboguy_: ^
23:46:13 <augur> then you can do   HCList GUIObjectClass
23:46:25 <roboguy_> augur: yeah, but then you need a special type and you can't use any of the old container types
23:46:33 <roboguy_> so you do run into some issues
23:46:47 <augur> roboguy_: you need a special type in, say, C# too
23:46:51 <augur> Array<GUIObject>
23:47:06 <roboguy_> augur: I don't know about C#, but that's not the case in C++
23:47:22 <roboguy_> you can have a normal array of anything
23:47:27 <augur> roboguy_: you can probably make an C++ array of whatever you want, sure, but then you dont have type safety
23:47:48 <augur> roboguy_: your list isnt known to be a list of GuiObjects, so you have no way to enforce that you only use GuiObject methods
23:47:52 <coppro> roboguy_: no you don't
23:47:58 <coppro> roboguy_: [forall a. a]
23:48:12 <augur> yeah, you could also do that i guess
23:48:14 <jle`> with ImpredicativeTypes, right?
23:48:17 <roboguy_> augur: my point is, you can't do something simple like this http://lpaste.net/105059
23:48:20 <augur> [forall a. GuiObject a => a]
23:48:45 <augur> roboguy_: thats because your type is wrong
23:48:50 <roboguy_> augur: that doesn't work either
23:48:51 <augur> test :: [forall a. Countable a => a]
23:49:00 <roboguy_> augur: neither of those values have that type
23:49:12 <augur> oh yes thats right, sorry
23:49:26 <augur> well anyway, you can still do it the way i said
23:49:27 <roboguy_> unfortunately, it's just not possible as far as I know
23:49:40 <roboguy_> but, like I said, you need to rewrite all the code for any container you might need
23:49:42 <augur> which is analogous to the generics method of doing it
23:49:50 <roboguy_> you can't use HashSet, HashMap, Vector, Sequence, etc
23:49:52 <augur> Array<Countable> vs HCList Countable
23:49:58 <augur> roboguy_: no you cant
23:50:02 <augur> roboguy_: but you cant do that in C++ either!
23:50:09 <roboguy_> augur: uh... yes you can...
23:50:12 <augur> no you cant
23:50:19 <roboguy_> give me an example...
23:50:30 <augur> roboguy_: you think you can, so you give the example! :)
23:50:33 <roboguy_> I can make a std::vector of whatever I want
23:50:37 <roboguy_> for instance
23:50:38 <augur> roboguy_: yes you can
23:50:42 <augur> but you lose type safety
23:50:51 <roboguy_> how so?
23:51:06 <crazydave> I can't do anything in C++ so I wouldn't argue for that being a good reason for haskell not being able to do something
23:51:14 <augur> roboguy_: you can try to call a count method on all of the objects, but you can never be sure that your values are countable
23:51:32 <roboguy_> augur: right, but there's no reason that can't be type safe in haskell
23:51:38 <roboguy_> it's just not possible, it turns out
23:51:40 <augur> roboguy_: right nothing
23:51:43 <augur> right is the whole point
23:51:46 <Maerten> Hi, i just installed the haskell-platform package for OSX, and already the first caball install fails: cabal: Error: some packages failed to install: conduit-1.1.4 failed during the building phase. The exception was: ExitFailure 1
23:51:46 <roboguy_> ?
23:52:00 <augur> roboguy_: you can do the type-unsafe version in haskell too using boring HLists
23:52:06 <roboguy_> Maerten: paste the full error log here http://lpaste.net/
23:52:11 <augur> roboguy_: data HList = Nil | forall a. Cons a HList
23:52:22 <Maerten> roboguy_: ok i will
23:52:26 <Cale> Maerten: That's never the real error message, you'll want to look up to where it tried to build conduit and find out what went wrong there
23:52:27 <enthropy> what is the point of that HList over [Dynamic]?
23:52:29 <roboguy_> augur: it's not type safe if from the type "Countable a => [a]" we can only use Countable methods on it
23:52:39 <roboguy_> not type-*unsafe*
23:52:46 <Cale> enthropy: HList keeps track of the types of the elements
23:52:46 <augur> roboguy_: i dont know what you're saying now
23:52:51 <Cale> (statically)
23:52:56 <augur> roboguy_: suffice it to say: you can do what you are talking about in haskell
23:53:00 <augur> in the ways i just said
23:53:02 <enthropy> Cale: augur's definition?
23:53:12 <Cale> oh
23:53:18 <roboguy_> augur: unfortunately I can't think of a good way to explain what I'm thinking right now. probably getting too late
23:53:19 <Cale> No, I was thinking of the actual HList library
23:53:20 <augur> Cale: HList is   data HList = Nil | forall a. Cons a HList
23:53:35 <augur> roboguy_: i know what you're thinking of
23:53:38 <Maerten> is this the right error log -> ./cabal-dev/logs/build.log ?
23:53:41 <augur> roboguy_: you mean you can have just an array of objects
23:53:46 <Cale> augur's HList is isomorphic to Nat
23:54:02 <augur> Cale: only if you dont use unsafe coerces :)
23:54:24 <coppro> roboguy_: see section 4 of http://www.haskell.org/haskellwiki/Heterogenous_collections
23:54:31 <enthropy> you could at least have some sanity and have some runtime type checking with Typeable
23:55:05 <augur> Cale: but thats my point, really -- the unsafe way of using HList is just like using heterogeneous arrays in your favorite OO language
23:55:24 <Maerten> roboguy_: http://lpaste.net/105060
23:55:25 <Cale> Well...
23:55:30 <Maerten> doesn't look too helpful to me though
23:55:35 <augur> Cale, roboguy_: and the safe way of doing arrays in OO-lang is the safe way of using HCList in haskell
23:55:48 <Cale> augur: In most OO languages you get exceptions rather than segfaults for bad casts
23:56:00 <augur> Cale: true
23:56:15 <Cale> (well, you actually get undefined behaviour here in the case of Haskell using unsafeCoerce)
23:56:17 <augur> Cale: ok so maybe we need semisafeCoerce :: a -> Maybe b
23:56:18 <augur> :P
23:56:28 <Cale> But if you did what you did with Typeable/Dynamic, then it'd be about the same
23:56:39 <Cale> type HList = [Dynamic]
23:56:42 <roboguy_> I still think that type classes are probably the wrong way to do subtyping in haskell (not to say that there is necessarily a right way). you run into the existential antipattern
23:57:03 <Cale> augur: That's what Typeable is for, btw
23:57:06 <Cale> :t cast
23:57:08 <lambdabot> (Typeable b, Typeable a) => a -> Maybe b
23:57:11 <hunt> can i convert a vector to a storable vector?
23:57:13 <augur> roboguy_: the existential isnt an antipattern at all
23:57:24 <crazydave> Maerten: copy all the output from when you ran cabal install ... including that line which says ExitFailure 1.  But the real error will be up higher.
23:57:31 <augur> roboguy_: its the correct pattern to express precisely what you want in a type safe way, cheaply
23:57:38 <Cale> hunt: by making a new StorableVector, yes
23:57:49 <hunt> Cale: isnt there a convert function though
23:57:55 <Maerten> crazydave / roboguy_: i might have a problem with the current gcc, get all kinds of """warning: missing terminating ' character [-Winvalid-pp-token]""" warnings.. i'll install another gcc with homebrew first, and see if that solves the problem
23:58:20 <hunt> Cale: does that mean i have to pretty much duplicate the entire vector?
23:58:24 <roboguy_> rwbarton: warnings probably aren't causing the problem
23:58:38 <Cale> hunt: Yes, you have to
23:58:49 <hunt> Cale: also does that mean i have to use storable vector everywhere throughout my code? it doesnt seem to support all the functions general vector does
23:58:49 <roboguy_> augur: why not just make it a data type though?
23:58:57 <Cale> hunt: The important point about StorableVector is that it's laid out in a special way in memory to make FFI nicer
23:58:58 <augur> roboguy_: why not make what a data type?
23:59:08 <roboguy_> augur: the type class. along these lines http://lukepalmer.wordpress.com/2010/01/24/haskell-antipattern-existential-typeclass/
23:59:15 <augur> roboguy_: you can do both
23:59:23 <hunt> Cale: damn, so i should be operating on a storable vector always?
23:59:30 <Cale> hunt: It depends?
23:59:36 <augur> roboguy_: oh THAT?
23:59:40 <roboguy_> yeah
23:59:41 <hunt> Cale: if im rendering it eventually, it contains pixels
23:59:42 <augur> roboguy_: but thats what type classes are!
23:59:58 <augur> roboguy_: thats how type classes are implemented
