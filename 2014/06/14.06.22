00:00:51 <cstanfill> anyone know why I would be getting 'permission denied:  <file descriptor: 9>: permission denied' when I try to cabal update?
00:01:28 <xpika> cstanfill: sudo
00:02:06 <cstanfill> I don't have sudo on the box
00:02:21 <cstanfill> it downloads the hackage package list to /home/cstanfill/.cabal/packages/hackage.haskell.org/00-index.tar.gz
00:02:34 <cstanfill> and then just pauses and fails with that cryptic error
00:03:00 <cstanfill> so it's presumably not trying to install globally either
00:09:58 <mirpa> cstanfill: you might try 'strace' to find out what file is causing your problems
00:09:59 * hackagebot hsignal 0.2.5 - Signal processing and EEG data analysis  http://hackage.haskell.org/package/hsignal-0.2.5 (VivianMcPhail)
00:13:38 <cstanfill> mirpa: mm, good idea
00:19:09 <cstanfill> mirpa: .... it may have been a disk quota issue
00:23:11 <cstanfill> yep. okay, that was dumb
00:25:50 <boo1ean> Hi all, I'm trying to figure out with lambda calculus reading this article http://palmstroem.blogspot.com/2012/05/lambda-calculus-for-absolute-dummies.html could someone point me out why does "0 :⇔ λ sz.z"? is it our assumption or logical fact?
00:27:29 <lfairy> boo1ean: you can define zero as anything you want, but that definition turns out most useful
00:27:33 <Maxdamantus> boo1ean: it's an encoding of zero.
00:27:40 <Geraldus> Hey folks! Need help with Haskell and debian. I’ve preinstalled Debian 7 on my VPS (I believe it is called wheezy), when I installing haskell platform I’m getting GHC 7.4.1. I’ve tried to build 7.6.3, but it fails with error. Is it related to Debian version? Maybe I should stick with Debian 7?
00:28:16 <Maxdamantus> boo1ean: but it's part of a general pattern of encoding natural numbers.
00:28:16 <boo1ean> lfairy: I'm glad to hear that! thanks! :)
00:28:48 <lfairy> boo1ean: np :) you'll see why it's useful as you learn more
00:28:57 <boo1ean> Maxdamantus: thanks, things are getting little bit cleaner now :)
00:29:29 <Maxdamantus> I think the first thing shown should be the encoding for booleans.
00:30:45 <mirpa> Geraldus: What sort of build error?
00:31:49 <Geraldus> mirpa: http://dpaste.com/19KB2ZE
00:32:12 <Maxdamantus> > let true = \a b -> a; false = \a b -> b; and = \l r -> l r l; or = \l r -> l l r in (true `or` false) True False
00:32:14 <lambdabot>  Occurs check: cannot construct the infinite type:
00:32:14 <lambdabot>    t2 ~ t2 -> t3 -> t1
00:32:14 <lambdabot>  Relevant bindings include
00:32:14 <lambdabot>    r :: t3 (bound at <interactive>:1:71)
00:32:14 <lambdabot>    l :: t2 -> t3 -> t1 (bound at <interactive>:1:69)
00:32:18 <Maxdamantus> Bleh.
00:32:40 <Maxdamantus> Yeah, plain Church encodings like infinite types.
00:33:22 <Maxdamantus> Hm. That shouldn't be required for booleans.
00:34:09 <lfairy> Maxdamantus: and and or call an argument with itself
00:34:21 <lfairy> that should make an infinite type
00:34:24 <Maxdamantus> Ah, of course.
00:36:47 <Maxdamantus> > let true = \a b -> a; false = \a b -> b; and, or :: (forall a. a -> a -> a) -> (forall a. a -> a -> a) -> (forall a. a -> a -> a); and = \l r -> l r l; or = \l r -> l l r in (true `or` false) True False
00:36:49 <lambdabot>  True
00:36:56 <Maxdamantus> \o/
00:37:11 <Maxdamantus> > let true = \a b -> a; false = \a b -> b; and, or :: (forall a. a -> a -> a) -> (forall a. a -> a -> a) -> (forall a. a -> a -> a); and = \l r -> l r l; or = \l r -> l l r in (false `or` false) True False
00:37:12 <lambdabot>  False
00:38:37 <mirpa> Geraldus: do you have enough memory? ... there is "killed" in your output which means that something terminated your compilation
00:39:14 <Geraldus> mirpa: I should check, I have only 512MiBs on my VPS (
00:39:39 <phunehehe> hi guys silly question: how is `a . b $ c` a better style than `a $ b $ c`?
00:40:26 <phadej> Maxdamantus: sooner or later you'll run into: http://stackoverflow.com/questions/21259931/how-to-work-with-higher-rank-types
00:41:02 <Maxdamantus> phadej: yes. I just fixed it by declaring `and` and `or` as having rank-2 types.
00:41:58 <phadej> Maxdamantus: i meant, the problem, you cannot instantiate higher-order-types in haskell (though you can in core)
00:42:30 <phadej> there is kosmikus comment on the top answer
00:43:26 <phadej> and system f unification is not-so-easy
00:46:47 <mirpa> phunehehe: '.' is visually less noisy perhaps? 'a $ b $ c' is like 'a ( b c )' while 'a . b $ c' is like '(a . b) c'
00:47:18 <Maxdamantus> Maybe it's because it's easier to refactor `foo c = a . b $ c` into `foo = a . b`
00:47:52 <haasn> In these situations, I use a $ b c
00:49:06 <mirpa> not to mention >>> etc
00:52:02 <phunehehe> haasn: that was too obvious of an example :) what I have is more like a x $ b y $ c z
00:54:01 <phunehehe> mirpa: isn't the point of . and $ to eliminate noisy brakets? in that way they are kinda the same
00:54:25 <haasn> phunehehe: Yes, a x . b y $ c z is how I would write it
00:54:29 <haasn> contrast a x . b y . c $ z
00:54:33 <haasn> which also seems to be popular
00:54:53 <haasn> I guess it depends on the semantics of it, whether the c is “closer” to the z or the a x . b y
00:54:57 <haasn> No general rule applies
00:55:17 <mirpa> phunehehe: there are more ways how to write it - I might rather use (c >>> b y >>> a x) z
00:55:46 <haasn> z & c & b y & a x
00:56:08 <phunehehe> haasn: how about a x $ b y $ c z vesus a x . b y $ c z? hlint suggests that the later is more popular for some reason
00:57:05 <haasn> I don't like more than one $
00:57:13 <haasn> $ looks too ugly and noisy
00:57:22 <haasn> keep your $$$ out of my software ;)
00:57:31 <phunehehe> woa what's this weird >>> category thing
00:57:42 <haasn> (>>>) = flip (<<<) and (<<<) = (.)
00:57:50 <haasn> and (.) is.. a generalization of (.)
00:58:47 <mirpa> and you can read it left to right >>> being visual help - with '.' I sametimes get lost
00:59:07 <haasn> My rule of thumb is to keep things flowing in the “same direction” throughout a line
00:59:20 <haasn> eg. (f >>> g) x would be bad, but x & f >>> g would be okay
00:59:35 <haasn> meanwhile, (f . g) x is okay but x & f . g would be bad
00:59:42 <mirpa> return . Just is better than Just >>> return
00:59:49 <mirpa> etc, etc
00:59:49 <haasn> return . return
01:04:07 <phunehehe> what's this & thing you are talking about?
01:04:23 <phunehehe> hoogle has a few results for it but nothing looks relevant
01:06:09 <phunehehe> (c >>> b y >>> a x) z
01:06:28 <phunehehe> c z >>> b y >>> a x
01:07:01 <phunehehe> so many ways to say the same thing it's hard to decide
01:10:21 <mirpa> phunehehe: You might want to prefer '.', I am using NetWire library which is using arrows so I incline to >>>. Use what you can read after several months later.
01:10:40 <mirpa> which is build using arrows
01:12:00 <phunehehe> that's cool :D
01:13:10 <Lutin`> It might just be the lisper in me but I'd just do: a x (b y (c z))
01:13:14 <phunehehe> coming from Python whose moto is "there should be *one* way to do it"
01:14:03 <phunehehe> Lutin: I did that until I heard that brackets are noisy
01:14:06 <Lutin`> ofc not the most immediately refactorable
01:14:18 <Lutin`> But it depends on the context in which you're using it
01:14:30 <mirpa> Lutin`: with good alignmet it could be readable too - why not
01:15:06 <phunehehe> I think for now, the noise level goes () > $ > .
01:16:16 <k00mi> I find parens to be the most readable and easiest to refactor
01:16:38 <Lutin`> The issue only comes for most when you get too many
01:17:16 <k00mi> oh it's a very common issue
01:17:20 <Lutin`> I prefer parens in most situations because they're the least cognitive burden
01:18:49 <Lutin`> But they definitely have their drawbacks
01:19:25 <hunt> good morning haskell
01:19:33 <Lutin`> good night haskell
01:19:35 <Lutin`> lol
01:19:43 <Lutin`> 4 AM I should probably sleep
01:19:46 <hunt> is anyone working on anything cool thats not a library?
01:19:48 <hunt> Lutin`: me too
01:20:16 <Lutin`> gf and I broke up earlier though after almost 3 years
01:20:27 <Lutin`> so I'm kind of trying to just distract myself
01:20:28 <hunt> Lutin`: oh no, thats awful
01:20:44 <hunt> Lutin`: You should probably sleep, and then distract yourself with friends or family or something tomorrow
01:20:46 <Lutin`> yeah it's tough, needed to happen though
01:20:50 <pepper_chico> hey, looking around at this, it seems `div` 3 vs shiftR 1 can make a difference in a program?... I was so used to this kind of optimization in c/c++ to always happen (http://stackoverflow.com/questions/8659345/why-is-this-simple-haskell-algorithm-so-slow?rq=1)
01:20:57 <Lutin`> Sounds like a plan
01:21:00 <Lutin`> night guys
01:21:09 <hunt> Lutin`: good luck getting through it Lutin`, good night
01:21:28 <pepper_chico> 4am, here is 5h20m
01:21:40 <pepper_chico> I should too...
01:21:46 <pepper_chico> anyway...
01:21:53 <lfairy> pepper_chico: Haskell div has different semantics to x86 div
01:22:07 <phunehehe> Lutin`: thanks and good ... morning
01:22:17 <pepper_chico> ops, I meant `div` 2
01:24:02 <lfairy> oh right
01:24:03 <hunt> pepper_chico: weird that ghc doesnt optimize that out
01:24:11 <pepper_chico> ok but... because of that semantics, I should then be aware to go back ages and write shift 1 to divide by 2 because it matters, like in von-newman times
01:24:28 <mirpa> pepper_chico: you should always verify such optimizations - there might be something else that will make your optimization useless
01:24:41 <Lutin`> `div` uses repeated subtraction or addition
01:24:52 <Lutin`> oh wait
01:24:55 <lfairy> yeah, pepper_chico did you try quot?
01:25:00 <hunt> @src div
01:25:00 <lambdabot> Source not found. And you call yourself a Rocket Scientist!
01:25:02 <lfairy> Lutin`: I don't think so
01:25:12 <pepper_chico> ah ok, I meant, even quot!
01:25:15 <lfairy> it's probably just a branch on positive/negative
01:25:15 <Lutin`> it's in GHC.Int
01:25:16 <pepper_chico> in that article
01:25:19 <pepper_chico> it's mentioned
01:25:26 <Lutin`> ((x# `minusInt64#` y#) `minusInt64#` intToInt64# 1#) `quotInt64#` y#
01:25:30 <hunt> @src quot
01:25:30 <lambdabot> Source not found. I've seen penguins that can type better than that.
01:25:31 <pepper_chico> div -> quot -> shift
01:25:37 <pepper_chico> =/
01:26:06 <hunt> so guys, any cool non-lib haskell projects you/someone else is working on?
01:26:25 <lfairy> I'm writing yet another IRC bot
01:26:33 <lfairy> it probably counts as a library though
01:26:34 <pepper_chico> @src shiftR
01:26:35 <lambdabot> Source not found.
01:26:37 <mirpa> hunt: what is cool these days?
01:26:38 <pepper_chico> meh
01:26:49 <hunt> mirpa: whatever you think is cool
01:26:52 <Lutin`> pepper_chico: Since these are GHC internals lambdabot probably doesn't cache
01:26:59 <Lutin`> anyways bed for realz
01:27:00 <Lutin`> night
01:27:05 <mirpa> is FRP cool?
01:27:08 <hunt>  night Lutin`
01:27:10 <pepper_chico> haxl?
01:27:18 <hunt> mirpa: maybe, whats frp? free-range programmers?
01:27:37 <mirpa> nah - functional reactive programming
01:27:53 <hunt> lfairy: what kind of irc bot?
01:28:10 <Total_1mmersion> hunt, I recently finished a compiler from a subset of Java to MIPS. I'm learning the Helm game engine at the moment with the hopes of making a little 2D airplane fighting game.
01:28:10 <hunt> mirpa: im not sure that counts as "not a library" but that sounds cool
01:28:28 <lfairy> hunt: an extensible one
01:28:35 <lfairy> I'm still working out the design
01:28:57 <lfairy> but it'll be kinda like xmonad, a bunch of plugins on top of a small core
01:29:17 <hunt> lfairy: that sounds like ietd be really fun to make if i could actually use it for anything
01:29:22 <pepper_chico> the prospect of shiftR mattering in calculations compared to div/quot annoys me....
01:29:31 <Total_1mmersion> hunt, Helm uses FRP
01:30:07 <hunt> Total_1mmersion: oh, its not haskell?
01:30:16 <hunt> Total_1mmersion: i dont say that because of FRP, i looked on the website
01:30:34 <Total_1mmersion> hunt, yes it is Haskell
01:30:46 <hunt> Total_1mmersion: my bad
01:31:16 <Total_1mmersion> no problem, maybe you were confused by "inspired by Elm" on their front page
01:32:47 <hunt> Total_1mmersion: yea
01:35:49 <hunt> Total_1mmersion: this seems like a really cool environment to learn
01:36:00 <hunt> Total_1mmersion: seems like a pretty different experience from what ive had with haskell so far
01:48:02 <slomo> is there already a function for "stringSep f s l = f (head l) ++ foldr (\a b -> s ++ f a ++ b) "" (tail l)" ? i.e. map all list elements to strings, concatenate them and in between them put a separator?
01:49:33 <hunt> do you think itd be possible to reimplment vim in haskell, where keys are bound to a VimAction monad which operates in a way kind of like parsec. For example, you might write the function d to first have a m <- getMotion, or something such, and then do your stuff?
01:49:46 <hunt> this sounds to me like a good way to make a really easily extensible vim
01:50:54 <mirpa> slomo: not sure - perhaps Data.List.intercalate?
01:51:33 <gienah> hunt: you could start with yi - it has some vim key bindings
01:51:51 <boo1ean> In case when we express "1 = λ sz.s(z)" what role do parentheses play here?
01:52:06 <hunt> gienah: yea ive tried it once, i dont know much about it. do you think itd be possible to implement my style of extendability on top of yi?
01:52:15 <slomo> mirf: hmm, i think i can build something around it at least :) thanks
01:52:19 <hunt> gienah: or a good idea?
01:52:19 <gienah> hunt: yes
01:52:28 <gienah> hunt: sure, if you like
01:55:08 <lfairy> slomo: intercalate
01:55:48 <lfairy> whoops, realized someone already answered :)
01:56:11 <jle`> hunt: i think you are describing instead some sort of interpreter monad interface ... ?  it sounds interesting
01:56:22 <jle`> hunt: whether or not you can implement vim in haskell is a different story altogether
01:56:41 <jle`> (you can implement vim in many things, having that sort of interpreter monad interface doesn't make a difference :))
01:57:01 <Total_1mmersion> hunt, in about 30 minutes I was able to put together a "game" where I could move a square around with WASD in around 8 lines of code. So far I'm really excited because it's the first time that I am picking up a library so quickly.
01:57:33 <hunt>    Total_1mmersion lol 8 lines of code, thats awesome. defnitely going to schedule in checking that out for tomorrow after playing 12 hours of xcom
01:58:01 <hunt> jle`: it does sound cool right? im gonna try and figure out specifically how it would work, and then ill come back and share
01:58:02 <haasn> Total_1mmersion: Which library?
01:58:04 <Total_1mmersion> I have base-4.6.0.1 and I want base-4.7.0.0, but cabal install base-4.7.0.0 throws errors
01:58:04 <mirpa> Total_1mmersion: using Helm?
01:58:06 <hunt> but first, sleep
01:58:07 <Total_1mmersion> rejecting: base-4.7.0.0 (only already installed instances can be used)
01:58:09 <t0k> howdy
01:58:13 <Total_1mmersion> haasn, mirpa, Helm
01:58:23 <jle`> hunt: that sort of interface does sound interesting. let me know how it works out :)
01:58:30 <haasn> Total_1mmersion: Whoa, haven't seen it before. Thanks!
01:58:58 <Total_1mmersion> haasn, np =) it looks really cool, so if you're into game development, definitely check it out
01:59:13 <mayski> woop nice
01:59:27 <mayski> I'm kinda looking for something I could use for a little roguelike
01:59:43 <mayski> basically just... curses really
02:00:42 <lfairy> Total_1mmersion: umm... base is really tightly coupled with everything. Don't reinstall it
02:00:54 <hunt> the only reason callback hell is an issue is because each function independantly calls itself asynchronously (in js)... why not have an async(f) function, and then write the contents synchronously?
02:01:13 <Total_1mmersion> lfairy, could I just reinstall the entire Haskell Platform to update it all?
02:01:24 <hunt> isnt callback hell literally the same problem as threading?
02:01:31 <slomo> lfairy: mirpa: "intercalate s (map f l)" is what i want, much shorter and easier to read ;) thanks
02:01:34 <lfairy> Total_1mmersion: just delete ~/.ghc
02:01:43 <lfairy> slomo: :)
02:01:58 <Tjr> if True dothis else dothat --- Does the compiler or the runtime decide which if-branch to take?
02:02:18 <Total_1mmersion> lfairy, then cabal install base-4.7.0.0? I really want ($>), lol
02:02:31 <haasn> Tjr: depends
02:02:41 <lfairy> Total_1mmersion: oh no no no. base comes with ghc. you can't change one without changing the other
02:02:45 <haasn> I'm pretty sure GHC will inline that into “dothis”
02:02:55 <Tjr> haasn: on what? How would I task the compiler with it?
02:03:11 <lfairy> Tjr: it works exactly as it would in any other language
02:03:23 <haasn> On the implementation, perhaps on compiler flags; I'm pretty sure it will be statically eliminated if you enable optimization (-O setting)
02:03:30 <Tjr> other languages support a preprocessor.
02:03:34 <haasn> Maybe even without it. If in doubt, check GHC's output with -ddump-simpl
02:04:06 <haasn> Also depends on whether you're in interpreted or compiled mode
02:04:36 <lfairy> Tjr: if-then is part of the syntax. it's just a pattern match. so it'll decide at runtime, unless the branch is optimized out
02:05:13 <Tjr> Is there a way to guarantee that an if-the-else (or some similar funcitonality) is optimized away at compile time?
02:05:19 <haasn> Tjr: I checked it with “main = if True then putStrLn "foo" else putStrLn "bar"”; this gets compiled to the same result as “main = putStrLn "foo"” even without optimization enabled, in GHC
02:05:30 <haasn> Tjr: The only bottom-line guarantee is to inspect the result
02:05:41 <mirpa> slomo: try using hlint - I've learned about intercalate this way
02:05:42 <Tjr> ok, thank you
02:05:46 <haasn> If you want to inline code at compile time and know for *certain* that you're getting what you want, you could use a template haskell splice
02:05:59 <lfairy> or fancy stuff with the type system
02:06:01 <haasn> eg. if your condition is more complicated than “if True”
02:06:18 <slomo> mirpa: my own implementation was apparently too complicated for it to detect that it does the same as intercalate :)
02:06:25 <haasn> but rather “if someComplicatedComputationDependingOnOtherKnownConstants”
02:06:45 <haasn> (But at that point you also have to make sure you're getting a benefit from eliminating the branch)
02:06:45 <Tjr> that's what I had in mind
02:07:35 <osfameron> can you annotate that ypu want the complicated ex[ressipn evaluated as far as possible at compile time?
02:07:52 <haasn> Not to my knowledge (in GHC)
02:08:09 <haasn> You can use {-# INLINE #-} pragmas though, which are tangential but can achieve similar things
02:08:40 <haasn> By telling GHC to aggressively inline the bits of the computation you're interesting in, it could result in a form that GHC will recognize and auto-reduce for you
02:08:55 <osfameron> ah
02:09:54 <t0k> wtf , damn shitty connection
02:09:58 <haasn> (GHC will also inline some things on its own. It's complicated)
02:13:46 <Total_1mmersion> Is it just me, or is the fact that Parsec redefines some functions like <|>, many, and optional from Control.Applicative confusing?
02:14:11 <johnw> does it redefine them, or just re-export them?
02:15:17 <haasn> It redefines them with a less general type
02:15:22 <haasn> its <|> is actually mplus
02:15:48 <haasn> But its “many”, among others, is custom defiend
02:16:42 <Total_1mmersion> but "optional" isn't just a less general type, it's actually different behavior. "optional" from Parsec returns (), whereas "optional" from Control.Applicative returns f (Maybe a)
02:16:48 <Total_1mmersion> @type optional
02:16:50 <lambdabot> Alternative f => f a -> f (Maybe a)
02:17:02 <Total_1mmersion> @type Text.Parsec.optional
02:17:04 <lambdabot> Text.Parsec.Prim.Stream s m t => Text.Parsec.Prim.ParsecT s u m a -> Text.Parsec.Prim.ParsecT s u m ()
02:17:31 <haasn> Oh, yes; I was just about to look that up. That answers my next question: Whether the two have identical behavior
02:18:24 <mirpa> osfameron: haasn: seems like TemplateHaskell is way howto eval constant expressions during compilation: http://www.reddit.com/r/haskell/comments/1kpu1h/can_haskell_programs_be_compiled_such_that_the/
02:19:04 <haasn> “Your compile times will be worse.” cute
02:19:21 <haasn> mirpa: I'm surprised that works, to be honest
02:20:08 <mirpa> it is run time trade-off
02:20:24 <haasn> I'd have expected you to need (x `seq`) as well, but I guess maybe [| |] splices are already strict?
02:21:37 <haasn> Oh, it works via its own type-specific class?
02:22:34 <haasn> Looks like it works for Int, Integer, Char, Bool, lists, Maybe, Either and tuples up to length 7
02:23:14 <haasn> And those are (strict) functions to produce rigid source code representing exactly those values
02:23:31 <mirpa> (I never used TH)
02:26:09 <haasn> I use TH but never the [| |] things. I could never figure out how those worked
02:26:49 <jamiehannaford> for scanl - is there any way to return some kind of empty value if a binary function results in a false?
02:27:05 <jamiehannaford> so if it gets to a part of a list where the binary function fails, stop the scan
02:27:17 <Total_1mmersion> How do you parse between 3 and 6 occurrences of a parser in Parsec? Something like the regex hello{3,6}
02:28:04 <haasn> Total_1mmersion: In theory: do p; p; p; optional (p *> optional (p *> ...))
02:28:32 <haasn> I don't know if there's a better way
02:28:38 <Total_1mmersion> yeah, that would work, but I would like to capture the whole string at the same time
02:28:51 <Total_1mmersion> the whole match, I mean
02:29:14 <haasn> I would probably refactor this by writing a helper function for “at most n times”
02:29:47 <haasn> Maybe that already exists somewhere? If that returns a list, then you could easily return both with something like liftM2 (++) (replicateM 3 hello) (atMost 3 hello)
02:30:59 <Total_1mmersion> Good idea, I was thinking along the lines of monadically replicating too. There is "count" from Parsec that looks close
02:35:26 <boo1ean> Is expression "ab" means that "a" is applied to "b", kinda function "a" is called with argument "b" ?
02:36:13 <slomo> with map, is it possible to omit an element from the result list? like map some of the list elements to Just something and some others to Nothing, but without going via Maybe and cleaning all Nothings from the list afterwards
02:36:33 <boo1ean> what kind of relations between terms a and be in expression ab?
02:37:45 <boo1ean> I'll get a mindblow soon, is it ok? or I need to forget lambda-calculus forever?
02:38:20 <Reite> slomo: I think you are looking for mapMaybe
02:38:57 <slomo> Reite: exactly :) thanks, i was only looking in Data.List
02:39:02 <boo1ean> is abc is the same as a(bc) ?
02:40:29 <Pythonfant> boo1ean: without a space it will be interpreted as one variable
02:40:39 <Pythonfant> a b c is a(b c)
02:41:14 <haasn> In any LC I've seen, a b c is (a b) c
02:41:42 <Pythonfant> ah ofc
02:41:46 <boo1ean> mmm
02:41:56 <Pythonfant> sry still waking up
02:42:03 <boo1ean> is λfgx.f(gx) the same as λfgx.fgx ?
02:42:09 <haasn> No
02:42:20 <haasn> It's the same as λfgx.(fg)x though
02:42:58 <haasn> “a b”, or “ab” if you prefer single letter names without spaces, means “a applied to b”
02:43:02 <taruti> Can GHC concurrency be set programmatically e.g. "+RTS -N4"?
02:43:15 <xpika> to confirm, guards can't be nested in haskell?
02:43:38 <haasn> (in LC, a and b are functions. In other functional languages like in Haskell, a is a function and b could be anything as long as it's type-correct)
02:43:39 <Hafydd> What does it mean for guards to be nested?
02:44:03 <xpika> func a | p1 a | p2 a = 3
02:44:19 <haasn> You can write that as func a | p1 a, p2 a = 3
02:44:38 <haasn> or func a | p1 a && p2 a
02:45:07 <haasn> (If I understood your intent correctly)
02:45:29 <haasn> (If I didn't, perhaps you meant func a | p1 a || p2 a = 3)
02:45:53 <Hafydd> I don't see the benefit of "nesting" guards in that way, or how it would generalise to multiple sub-guards.
02:46:18 <Hafydd> But, no, I suppose standard Haskell doesn't have such a feature.
02:46:49 <boo1ean> haasn: does it comes from the assumption that all functions are unary, hence we can work only with pairs?
02:47:12 <haasn> boo1ean: Exactly
02:47:30 <haasn> in LC there is no syntax form other than unary application and unary abstraction
02:47:53 <boo1ean> haasn: ohh, god, little bit cleaner, thanks :)
02:48:47 <Total_1mmersion> haasn, atMost n p = (catMaybes . takeWhile isJust) <$> replicateM n (optional p)
02:53:56 <haasn> Total_1mmersion: I think that's really dangerous
02:54:17 <Total_1mmersion> Is there a shorter way to turn [Just 3, Just 4, Nothing, Just 5] into [3, 4] than (catMaybes . takeWhile isJust)?
02:54:21 <Total_1mmersion> haasn, why?
02:54:44 <haasn> Total_1mmersion: I'm no parsec expert but something tells me this sets you up for exponential runtime if parsec first decides to check the “Just Nothing Nothing” route, then the “Nothing Just Nothing” route, then the “Nothing Nothing Just” route, then the “Just Just Nothing” route; etc.
02:54:46 <haasn> backtracking every time
02:54:57 <haasn> until it gives up
02:55:27 <zomg> Total_1mmersion: just plain catMaybes [Just 1, Just 2,....] should do
02:55:41 <Total_1mmersion> haasn, ohh you might be onto something there
02:55:47 <zomg> oh nevermind, it actually behaves differently from your example
02:56:06 <Total_1mmersion> zomg, yeah, it simply strips Nothings
02:56:47 <zomg> I think your example is probably about as short as it'll get since it has that specific behavior
02:56:54 <Total_1mmersion> yeah probably
02:57:37 <haasn> Total_1mmersion: This is why I deliberately picked the optional (p *> optional (p *> ...)) nesting, since it first tries the first p; and only if that succeeds does it lock that in and try the second p
02:57:41 <haasn> But it can still backtrack at any step of the way
02:57:51 <haasn> But this way you only get linear behavior
02:58:01 <haasn> Either you get Nothing; or Just (p, Nothing), or Just (p, Just (p, Nothing))
02:58:14 <haasn> And it only has to try at most n cases to give up
02:58:22 <Total_1mmersion> I see
02:58:56 <xpika> does anyone else think uncurry and curry are the wrong way around
02:59:20 <xpika> i would have thought curry (+) $ (1,2) => 3
02:59:21 <Total_1mmersion> haasn, but the (optional p) in mine isn't wrapped with "try", so how could it backtrack?
02:59:37 <haasn> Oh, good point
03:00:13 <haasn> I guess failure will be linear instead of constant; if the first ‘p’ in your example fails; it won't backtrack but it will move on to the next one, and then the next one, and let them all fail over and over
03:00:24 <haasn> In my nesting; the first failure will cause the entire rest to not even be tried
03:00:39 <haasn> But yes, if you avoid ‘try’ that shouldn't be as much of an issue
03:00:41 <Total_1mmersion> Hmm, I'm not so sure it'll even go to the next one because of laziness
03:01:11 <haasn> Total_1mmersion: Side effects are not lazy
03:01:15 <mirpa> xpika: sometimes - I write it in Emacs and it shows its type so I know whether to curry or uncurry
03:01:29 <haasn> const () <$> replicateM n (action) -- will still perform action n times, even if you ignore the result
03:03:50 <haasn> xpika: “curry” takes a function and “curries” it; “uncurry” takes a curried function and turns it into a “non-curried” function
03:03:53 <haasn> I think they make sense
03:04:08 <haasn> (where non-curried means uses tuples/pairs for multiple arguments)
03:05:12 <Total_1mmersion> haasn, ah you are right... take 3 <$> replicateM 3000000 (return "hi") is pretty slow
03:05:41 <haasn> Total_1mmersion: Also, in your example, ‘p’ itself could be defined as “p = try ...”
03:06:09 <haasn> Wait, I think optional always succeeds
03:06:37 <haasn> optional p = (p >> return ()) +++ return ()
03:07:58 <haasn> so, actually, replicateM 10 (optional p) will just try parsing p 10 times in a row, and the first ‘m’ will succeed with the other ‘n-m’ simply falling into the return () path
03:08:46 <haasn> If you wrap p inside ‘try’, eg. (optional (try p)) then the last n-m are prevented from accidentally consuming the input stream
03:08:49 <haasn> But if they succeed, they succeed
03:08:55 <haasn> To undo any of that, you'd have to put a try outside the replicateM
03:09:17 <haasn> Alright, I think replicateM (optional p) would be a good way to go
03:09:23 <haasn> and catMaybes = catMaybes . takeWhile isJust in this scenario
03:09:38 <haasn> (But I could be mistaken. Test it!)
03:11:19 <ninja_code> is there something like datomic for haskell?
03:11:26 <ninja_code> where the query language is written in ahskell
03:11:29 <ninja_code> and the querys are executed outside of the database
03:11:37 <ninja_code> where the databse just basically does only transaction handling
03:13:39 <Peaker> hey, does anyone remember if parsec's user-provided state is backtracked or not?
03:13:59 <Total_1mmersion> haasn, I found takeM from the monadlist package and it evidently works as we intend
03:14:02 <Total_1mmersion> > takeM 3 (replicate 3000000 (return "hi")) :: Maybe [String]
03:14:03 <lambdabot>  Not in scope: ‘takeM’
03:14:03 <lambdabot>  Perhaps you meant one of these:
03:14:03 <lambdabot>    ‘take’ (imported from Data.List),
03:14:03 <lambdabot>    ‘Seq.take’ (imported from Data.Sequence),
03:14:03 <lambdabot>    ‘BSLC.take’ (imported from Data.ByteString.Lazy.Char8)
03:14:13 <haasn> takeM?
03:14:27 <Total_1mmersion> That expression returns Just ["hi","hi","hi"]
03:14:34 <Total_1mmersion> Yeah, takeM http://hackage.haskell.org/package/monadlist-0.0.2/docs/Control-Monad-ListM.html
03:15:01 <haasn> From the looks of it, takeM n (repeat a) is just replicateM n a
03:15:10 <haasn> or sequence (take n $ repeat a)
03:15:21 <haasn> or sequence (replicate n a)
03:16:11 <Total_1mmersion> oh, nevermind that's not the behavior we want is it?
03:16:26 <haasn> It just doesn't seem to offer anything new
03:21:52 <lessless_> hi folks! by some occasion my ghci do not have a :show language function
03:21:57 <lessless_> how can this be?
03:24:52 <taruti> Is there a nice way of generating a combined criterion html-report with various "+RTS -N<x>"?
03:27:32 <pavonia> lessless_: :show languages?
03:29:42 <lessless_> pavonia, yes! is this just a difference of the versions?
03:30:39 <pavonia> I don't know, I thought it has always been "languages"
03:30:49 <lessless_> I'm following Beginning Haskell by Apress - and if the book is based on the newer version maybe I should upgrade :\
03:31:20 <boo1ean> how do I read expression "abc" in terms of application terminology?
03:32:00 <lessless_> In the book output is slightly different: it has a "base language" string and flags are also prepended by "with the following modifiers:"
03:33:27 <pavonia> boo1ean: What do you mean?
03:33:59 <boo1ean> pavonia: example: S :⇔ λ abc.b(abc)
03:34:14 <boo1ean> "ab" I read as "a" applied to "b"
03:34:55 <pavonia> "abc" is "(ab)c", I think
03:41:11 <Total_1mmersion> haasn, I believe this custom function has the right behavior. Any ideas on how to make it more concise? http://lpaste.net/106037
03:45:40 <IvoryTower> Would anyone be able to check my understanding of purity? In both math and Haskell the input(s) to a pure function always map to the same output. This is a one-to-one or many-to-one mapping. In math, a relation differs from a function in that they also have one-to-many mappings. One input or set of inputs could map to more than one output. This is like reading a file from a disc. You might get the file, or you might nothing. Woul
03:45:57 <IvoryTower> Additionally, would it be correct to say that Haskell takes all the possible outputs to a relation and wraps them up in a monad to create a one-to-one mapping, thus making the relation into a pure function.
03:46:17 <IvoryTower> lol, that totally didn't copy correctly, let me try again
03:46:27 <IvoryTower> Would anyone be able to check my understanding of purity? In both math and Haskell the input(s) to a pure function always map to the same output. This is a one-to-one or many-to-one mapping. In math, a relation differs from a function in that they also have one-to-many mappings. One input or set of inputs could map to more than one output. This is like reading a file from a disc. You might get the file, or you might nothing.
03:46:33 <IvoryTower> Would it be accurate to say that Haskell calls relations impure functions? Additionally, would it be correct to say that Haskell takes all the possible outputs to a relation and wraps them up in a monad to create a one-to-one mapping, thus making the relation into a pure function.
03:52:36 <boo1ean> is it okay if LC is hard to understand from scratch? :)
03:55:37 <Aetherspawn-> IvoryTower: well
03:55:51 <Aetherspawn-> the exact definition of "pure" is often a topic of debate
03:56:21 <IvoryTower> Aetherspawn-: lol, I was wondering if I might get that answer
03:56:28 <Aetherspawn-> but lots of people are happy to stop at "given the same arguments, will always return the same value" in the sense that it doesn't really matter from what environment it was called
03:57:04 <Aetherspawn-> whereas a monad, while really being "pure", simulates side effects (actually though, the arguments just change, so they're still technically pure)
03:57:55 <Aetherspawn-> The IO monad actually has a value that literally pretends to be the entire state of the real world
03:58:02 <Aetherspawn-> that the compiler assumes to have changed each time
03:58:33 <IvoryTower> that technically pure part is what I've just come to notice. It seems to me that a monad is just polishing a turd (in a manner of speaking). deep underneath, it's still impure
03:59:08 <alpounet> the IO monad is
03:59:24 <alpounet> but you won't find any impurity in Maybe :)
04:01:08 <IvoryTower> I see that. The way I see the Maybe monad is that it's a relation which has been wrapped up. I know that I'll be getting the Maybe monad back, but I don't know what it'll carry. It almost kind of seems like a slight of hand trick really
04:03:04 <alpounet> IvoryTower: don't mix impurity and monads. the concept of monad doesn't entail anything about impurity, it's really about parametrized types enabling some precise classes of computations
04:03:41 <alpounet> (in the haskell world, at least)
04:06:52 <zwer> Aetherspawn-, putStrLn "Hello" returns the same value (same IO ()) for the same input ("Hello"). where does the world state come into the play?
04:07:39 <teakay> hey guys
04:07:41 <Total_1mmersion> zwer, getLine can return different values
04:07:51 <zwer> Total_1mmersion how?
04:08:21 <IvoryTower> would it be correct to equate monads with relations (in the mathematical sense) since they both have a one-to-many mapping (ie: the Maybe monad might return Just or Nothing for one input)
04:08:32 <Total_1mmersion> zwer do { l1 <- getLine; l2 <- getLine; print (l1 ++ l2) }
04:08:52 <Hafydd> No, it wouldn't.
04:09:36 <IvoryTower> lol, damn
04:09:44 <Total_1mmersion> IvoryTower, Bool isn't a monad but a function which returns a bool might return True or False for one input
04:10:03 <Total_1mmersion> What purity means is that if you call that function again with the same arguments, it will return the same result
04:10:17 <zwer> Total_1mmersion getLine is the value itself, it doesn't return anything. it isn't a function
04:10:39 <teakay> in the parsers lib: I notice ekmett pushed the attoparsec upper bound dependency up to 0.13 for v0.11.0.2 ie attoparsec  >= 0.11.2  && < 0.13 (https://github.com/ekmett/parsers/commit/a6392f3547daa3fced8268e786d506aa639419a5)
04:10:40 <IvoryTower> I get the definition of purity quite well, I'm just trying to better define impure function
04:11:38 <teakay> however on hackage v0.11.0.2 still has the dependency attoparsec (>=0.11.2 && <0.12) (http://hackage.haskell.org/package/parsers-0.11.0.2)
04:12:13 <teakay> Am I missing something there?  Pretty new to hackage
04:13:45 <Total_1mmersion> zwer, maybe, I don't know how IO and getLine are implemented. I think the world state matters even with putStrLn because there might be a function like "getTerminalText" which would depend on what was printed to the terminal by putStrLn.
04:14:10 <corgifex> putStrLn doesn't print
04:14:18 <Total_1mmersion> so putStrLn must change the world state in order for getTerminalText to pick that up
04:14:25 <corgifex> no, haskell is pure
04:15:02 <deni> can anyone explain the use case for the left and right functions from Control.Arrow....i'm having a really hard time grasping what they do
04:15:17 <identity> :t left
04:15:18 <lambdabot> ArrowChoice a => a b c -> a (Either b d) (Either c d)
04:15:47 <Total_1mmersion> So what does putStrLn do? I've heard IO things are more like descriptions of actions to be performed, is that closer to what you're thinking, corgifex?
04:16:13 <corgifex> Total_1mmersion: putStrLn takes a string and returns corresponding IO action
04:16:18 <corgifex> +a
04:16:53 <identity> deni: It looks like left applies a function to an Either if it's Left, and right does the same for Right
04:16:55 <alpounet> Total_1mmersion: the trick is in how IO actions are executed, not in their types. It's just IO getting a special treatment here
04:16:58 <identity> > left (+1) (Left 3)
04:17:00 <lambdabot>  Left 4
04:17:04 <identity> > left (+1) (Right 3)
04:17:05 <lambdabot>  Right 3
04:17:15 <identity> > right (+1) (Left 3)
04:17:16 <lambdabot>  Left 3
04:17:18 <teakay> yea, and the same for eg tuples
04:17:21 <identity> > right (+1) (Right 3)
04:17:23 <lambdabot>  Right 4
04:17:49 <corgifex> > first show (1, 'x')
04:17:50 <lambdabot>  ("1",'x')
04:19:21 <deni> identity: i see....tnx.
04:19:47 <corgifex> > left length (Right 2)
04:19:49 <lambdabot>  Right 2
04:19:52 <deni> identity: so it's just shorthand for a case notation really right?
04:21:45 <ninja_code> IO () effects world state
04:22:33 <corgifex> > let x = putStrLn "hello" in length [x, x, x]
04:22:34 <lambdabot>  3
04:24:28 <zwer> and this would still not print anything even if haskell wasn't lazy and x was fully evaluated by length
04:25:31 <zwer> because `putStrLn "hello"' doesn't print anything, it just constructs a value (of IO () type)
04:25:32 <corgifex> x is freshly constructed so I'd expect it to be fully evaluated, even in Haskell
04:26:51 <zwer> > let x = undefined in length [x, x, x]
04:26:52 <lambdabot>  3
04:27:24 <pavonia> What is freshly constructed supposed to mean?
04:27:51 <joshkirklin> why is StateT s (Rand g) not an instance of MonadRandom?
04:27:56 <corgifex> hard to explain, but I know it when I see it
04:27:56 <teakay> deni: you could achieve the same with a case yea, but left/right are obviously more composable, and apply to all instances of the arrow class
04:28:54 <deni> teakay: got it.
04:30:34 <teakay> actually, i was talking about first/second
04:30:40 <teakay> not left and right
04:35:08 <mirpa> divMod (-3) 2 == (-2,1); quotRem (-3) 2 == (-1,-1) ...weird - is div/mod usefull for negative numbers at all?
04:35:24 * hackagebot spe 0.3 - Combinatorial species lite  http://hackage.haskell.org/package/spe-0.3 (AndersClaesson)
04:37:02 <Total_1mmersion> How do you write a parser for Parsec which accepts at most n characters?
04:37:51 <corgifex> runParser p . take n
04:39:38 <Total_1mmersion> Oh sorry, I meant "accept at most n parsers" but I thought it sounded awkward. If they were always 1 character, that would work.
04:40:36 <identity> mirpa: the greatest multiple of 2 *less* than -3 is -2.
04:40:47 <hexagoxel_> joshkirklin: RandomGen g => instance MonadRandom (StateT s (Rand g)), right?
04:40:49 <identity> > divMod (-9) 4
04:40:51 <lambdabot>  (-3,3)
04:40:55 <statusfailed> Is there an example of a lambda calculus interpreter in haskell?
04:41:44 <identity> eh, that is, (-2) * 2 = -4.
04:41:54 <corgifex> Total_1mmersion: what do you mean?
04:42:42 <Total_1mmersion> corgifex, atMost :: Int -> Parser a -> Parser [a]
04:43:05 <pavonia> statusfailed: Have you looked on hackage? I bet there are several
04:43:18 <Total_1mmersion> parse (atMost 3 (char '.')) "" "....." should return "..."
04:43:50 <identity> Total_1mmersion: Then what is wrong with using take first?
04:43:56 <corgifex> atMost n p | n <= 0 = return [] | otherwise = liftM2 (:) p (atMost (n - 1) p) <|> return []
04:44:16 <Total_1mmersion> identity, the parser passed in might consume more than 1 character.
04:44:34 <identity> aah.
04:44:39 <pavonia> catMaybes <$> replicateM n (optional p)?
04:45:38 <mirpa> identity: nice explanation
04:46:14 <Total_1mmersion> corgifex, awesome thanks
04:46:40 <deni> I'm having an issue with this: http://dpaste.com/0C85J4N on line 52...the types don't add up somehow and I'm obviously doing something very wrong
04:47:30 <Total_1mmersion> pavonia, I want the parser to stop on the first failed parse
04:48:15 <deni> basically i'm parsing a file and trying to make sure that it has all the desired components i need (ie. id and secret)
04:48:23 <pavonia> Total_1mmersion: All subsquent parsers should fail too if one fails
04:49:17 <Total_1mmersion> pavonia, oh great, that's even nicer!
04:49:27 <Total_1mmersion> thanks =)
04:49:58 <pavonia> deni: What is the type of makeApiKeyProps?
04:52:04 <deni> pavonia: it should be Map String String -> Either String ApiKeyProperties
04:52:32 <pavonia> :t return $ Right "foo"
04:52:33 <lambdabot> Monad m => m (Either a [Char])
04:52:54 <pavonia> Right already is return for the Either monad
04:53:04 <statusfailed> pavonia: found some haha thanks :)
04:53:38 <Pythonfant> > return "foo" :: Either a [Char]
04:53:40 <lambdabot>  Right "foo"
04:54:31 <deni> pavonia: not sure what you mean? so i don't need the return or I don't need the Right constructor?
04:55:23 <pavonia> yes
04:56:46 <deni> pavonia: so i either use return or the constructor?
04:56:59 <pavonia> yes
04:57:28 <pavonia> I suggest to use return for readability
04:57:40 <mirpa> Is there quotRem' in spirit of Data.Fixed.divMod' (note negative nums) eg. 'quotRem' (-3.1) 2 == (-1,-1.1)'?
05:00:29 <deni> pavonia: like this: http://dpaste.com/0PXT7JF
05:00:34 <deni> pavonia: still doesn't compile though
05:00:54 <pavonia> Yeah, line 3 still has several errors
05:01:38 <Total_1mmersion> pavonia, it turns out that catMaybes <$> replicateM n (optional p) will optionally try p n times, even if the first attempt fails.
05:01:56 <deni> pavonia: this is what i get: http://dpaste.com/2DA7C32
05:02:10 <nadirs> mirpa: there is a `quotRem` → http://hackage.haskell.org/package/base-4.7.0.0/docs/Prelude.html#v:quotRem
05:02:37 <nadirs> mirpa: ah sorry, misread the question
05:03:10 <pavonia> Total_1mmersion: Is that a problem? Like are you using a ParserT with a custom monad?
05:04:07 <pavonia> deni: The result of "parseFromFile file name" is Either ParseError [(String, String)], right?
05:04:19 <deni> pavonia: yes
05:04:47 <pavonia> And the first thing you do on a Right value is "fmap Map.fromList" which won't work
05:04:50 <Total_1mmersion> pavonia, well it's simply inefficient
05:05:01 <Total_1mmersion> I'm not using a custom monad
05:05:27 <deni> pavonia: the fmap is redundant here right?
05:05:27 * hackagebot spe 0.3.1 - Combinatorial species lite  http://hackage.haskell.org/package/spe-0.3.1 (AndersClaesson)
05:05:44 <pavonia> deni: yes
05:05:48 <deni> cause it's not in a monad any more. I can just do Map.fromList then
05:06:38 <pavonia> Total_1mmersion: Have you tried corgifex' suggestion?
05:06:59 <Total_1mmersion> pavonia, yes and it works nicely.
05:07:19 <pavonia> Okay
05:07:39 <lessless_> what do you use as editor/ide - vim/sublime/eclipseFP ?
05:07:47 <Total_1mmersion> vim
05:08:23 <deni> pavonia: and the left value can't be just a string literal right. it should be something along the lines of '\_ -> "Something went wrong"' but that complaings as well
05:09:18 <pavonia> That should work
05:09:36 <deni> pavonia: the "should work" is for me?
05:09:44 <pavonia> Yep :)
05:09:53 <deni> pavonia: http://dpaste.com/1RAPT2K
05:10:08 <deni> i thinkg it has something to do with OverloadedString again..and how it can't unify
05:10:27 <pavonia> What does your function look like?
05:11:18 <deni> pavonia: parseFromFile file name >>= return . either (\_ -> "Parse Error" :: String) (makeApiKeyProps . Map.fromList)
05:12:03 <Para_> Hey! I have a function that I wrote (thats not too complicated) that is compiling fine, but I seem to have a logic error and I can't find it. Here is the function in question: http://lpaste.net/106051 Its supposed to go through a list of points, and if two points are too close to one another (in the y axis), then it removes both of them and connects the two points on either side
05:12:17 <pavonia> deni: Now your left and right types don't match anymore
05:12:24 <Para_> In small test cases, it seems to work, but I've been passing it bigger ones and it stops working as well
05:13:28 <pavonia> deni: The result type of makeApiKeyProps is Either something, and the result type of "Parse Error" is String
05:15:34 <mreh> running a haskell script as sudo seems to return no output
05:15:41 <mreh> I've narrowed it down to my haskell script
05:15:50 <mreh> works fine with any other bash script I'm running
05:16:23 <mreh> could there be something in my environment stopping it returning anything
05:17:09 <pavonia> mreh: What does your script look like?
05:19:19 <mreh> pavonia, it's a shelly script
05:19:28 <mreh> put I've tried just a simple putStrLn
05:20:02 <mreh> it also works on the command line
05:20:13 <mreh> I should say I'm invoking it from php's exec()
05:21:39 <deni> pavonia: i don't understand
05:22:14 <deni> pavonia: the return type of makeApiKeyProps should be Either String ApiKeyProperties as well the parent's function
05:22:35 <mreh> actually, it seems to be a Shelly thing
05:23:40 <deni> pavonia: so I'm calling the lambda func in case of ParseError and returning a string...and in case if it's not a ParseError i call the makeApiKeyProps . Map.fromList which should return ApiKeyProperties or a String
05:28:59 <pavonia> deni: Not makeApiKeypros returns an Either
05:29:05 <pavonia> *No,
05:31:08 <Total_1mmersion> Has anyone done lazy matching with Parsec? I found an implementation of lazyMany, but it appears to take 2 parsers and I'm not sure why.
05:34:40 <deni> pavonia: that's what i said..makeApiKeyProps is Either String ApiKeyProperties
05:34:50 <deni> pavonia: not sure how to use this then....
05:35:32 <pavonia> Yeah, but the other argument of either doesn't have this type
05:35:49 <pavonia> :t either
05:35:50 <lambdabot> (a -> c) -> (b -> c) -> Either a b -> c
05:36:02 <pavonia> It need to have the same result type c
05:37:41 <deni> pavonia: i see, i'm not sure how to accomplish that in the lambda function then....
05:38:23 <deni> pavonia: should I perhaps use right instead of either cause I need to call makeApiKeyProps only if there was not parse error?
05:39:20 <pavonia> You could do that, but then the result type would be Either ParseError something
05:39:54 <deni> pavonia: could I then wrap my Left clause in the makeApiKeyProps function into a ParseError?
05:40:19 <yitz> deni: you should do that if you want this to be a pure function, where you don't specify here what to do in case of a parse error, but just report it back to the caller.
05:40:54 <pavonia> deni: What do you mean by Left clause?
05:41:01 <yitz> deni: if you want to decide right here what to do with a parse error, this whole thing is probably going to have to be in the IO monad. not sure if that's what you want.
05:41:26 <deni> pavonia: in getKey k config...
05:41:59 <deni> yitz: umm it already is in the IO monad as it's reading from a file
05:42:17 <deni> yitz: i can't get rid of IO even if i wanted to
05:42:39 <pavonia> The easiest is to just use "either (\_ -> Left $ "Parse Error") ..."
05:44:00 <gregory> Kaidelong: how was your pork?
05:44:40 <deni> pavonia: i'm confused with having to use Left here as i have return before that....and we said that it's either use return or the Left/Right constructors
05:45:19 <pavonia> But only in that do-block
05:45:55 <boo1ean> is that eq valid "s(nsz) = s((ns)z)" ?
05:46:58 <deni> ah so I need to use it inside the lambda regardless
05:47:09 <deni> still a bit fuzzy on that one...guess it needs to sink in first
05:47:36 <lyxia> boo1ean: Are you asking about how successive applications are bracketed?
05:48:10 <yitz> deni: generally one would read the file as a separate step somewhere closer to the top level of the program, and then pass the stream read from the file into a pure function that does the parsing.
05:48:34 <boo1ean> lyxia: I'm trying to figure out sequence of application
05:49:38 <yitz> deni: then you get the result back that tells you what IO action needs to be done in response: report a parse error and quit, use the ApiKey to continue some further interaction with the user, etc.
05:49:39 <corgifex> a b c parses as (a b) c
05:49:45 <deni> yitz: i'm still struggling how to do that....as it's not exactly composable...cause the function does return something wrapper in an IO....
05:50:12 <lyxia> boo1ean: what corgifex said ^
05:50:41 <yitz> deni: did you paste some of your code? i see a paste above, but it's only an error message.
05:51:06 <boo1ean> cool, thanks!
05:51:16 <yitz> deni: did you paste some of your code? i see a paste above, but it's only an error message.
05:52:53 <yitz> @type \a b c -> a b c
05:52:55 <lambdabot> (t1 -> t2 -> t) -> t1 -> t2 -> t
06:08:39 <deni> yitz: i did....sec
06:09:40 <deni> yitz: http://dpaste.com/01Q56SG
06:10:25 <dff33> How can I "convert" a function into a Conduit?
06:10:35 <deni> yitz: and i'm not sure IO is best suited at the top for me...i was actually seeing it more at the bottom and then perhaps use monad transformers or something to make it less painfull
06:11:28 <dff33> For instance, I want to "convert" foo 42 = "42" :: Int -> String into foo :: Conduit Int (ResourceT IO) String
06:11:28 <deni> still don't know anything about all that stuff....so learning....but i'm trying to kinda get the big picture of things first...and then dive in into the details of each part as i need it
06:12:23 <deni> yitz: for now i guess read config is kinda at the top level....and that's user facing function as well
06:14:01 <yitz> deni: ok i see you're using parseFromFile. so that makes sense.
06:16:40 <yitz> deni: so then for example you might have two steps in the do block of your main that do something like: eProps <- readConfig fname; props <- either (const $ error "Oops") id
06:17:05 <yitz> oops wait
06:17:26 <yitz> deni: eProps <- readConfig fname; props <- either (const $ error "Oops") id eProps
06:18:38 <yitz> deni: or if you want to be fancy: props <- readConfig fname >>= either (const $ error "Oops") id
06:20:20 <yitz> deni:  foo >>= return . bar is more simply written: fmap bar foo
06:20:27 <yitz> deni: or: bar <$> foo
06:21:38 <yitz> deni: i was referring to "parseFromFile file name >>= return . "
06:22:24 <deni> yitz: the thing is then i need to write that every time...and i'm doing to use that readConfig function in every other function
06:22:37 <deni> yitz: i don't want to write the error handling code every time...
06:22:52 <yitz> deni: ok, you should be able to generalize that pretty easily with a function.
06:23:14 <yitz> deni: the function should take as its parameters the parts of that processing that change each time.
06:23:34 <yitz> deni: i only see that one example so it's hard for me to say what.
06:25:35 * hackagebot spe 0.4 - Combinatorial species lite  http://hackage.haskell.org/package/spe-0.4 (AndersClaesson)
06:27:03 <deni> yitz: yeah i need to think about it as well
06:27:04 <deni> yitz: tnx
06:40:05 <cariveri> hi. how do I auto produce type signatures and documentation?
06:45:36 * hackagebot music-util 0.13 - Utility for developing the Music Suite.  http://hackage.haskell.org/package/music-util-0.13 (HansHoglund)
06:45:41 <yitz> cariveri: first, you need to have the program haddock installed. if you don't you can get it from hackage.
06:46:22 <yitz> cariveri: then type the command cabal haddock inside your project directory
06:47:33 <cariveri> yitz: I did. Im about to issue "cabal init" wich generates .cabal and setuph.hs file necessary for haddock to work as it seems.
06:49:10 <Geraldus> hey folks! I have debian 7 running on XEN VPS. I’ve installed Haskell Platform and then `cabal install cabal-install`. Now I believe I should change my PATH, I have new cabal in /root/.cabal/bin, I’ve tried to edit both `/etc/login.desc` and `/etc/environment`, but `which cabal` still shows me cabal from /usr/bin (
06:54:02 <hexagoxel_> Geraldus: you are aware that PATH is initialized only when you open a (new) shell session, or when you explicitly tell your shell to (re-)process a startup script (?)
06:54:10 <zomg> > /root
06:54:11 <zomg> :x
06:54:11 <lambdabot>  <hint>:1:1: parse error on input ‘/’
06:54:47 <zomg> Geraldus: easiest way would probably to be just edit your bashrc or whatever
06:54:57 <hexagoxel_> i have no idea what the "correct" file for system-wide PATH setup on debian is..
06:55:18 <cariveri> yitz: cabal init aborted with a "...src/bak/Database does not exist" message . you know what I can do?
06:55:24 <zomg> hexagoxel_: it doesn't seem right to have it under /root if it's supposed to be system wide anyway
06:55:36 <hexagoxel_> hmm true
06:55:45 <Geraldus> hexagoxel_: I’ve even tried to reboot my server. No results )
06:55:47 <yitz> cariveri: you anyway want to do cabal init. cabal automates a lot of what you need to do when building a haskell project.
06:56:17 <hexagoxel_> what happens when you put an inaccessible directory in path? :S
06:56:22 <zomg> Geraldus: if you want to have it only for the current user, just put something like export PATH=$PATH:/path/to/cabal/bin into your shell configuration
06:56:28 <cariveri> yitz: key. but how to get rid of that abortion ?
06:56:37 <Geraldus> zomg: I have only root access for now, so I believe I should create a user and reinstall GHC and Platform to thing go smooth?)
06:56:38 <yitz> cariveri: i have never heard of cabal init failing before.
06:56:56 <yitz> cariveri: can you give more details?
06:57:12 <zomg> Geraldus: yeah generally it's not recommended to use a system as root, but I don't see any reason why it wouldn't work if you don't care about that =)
06:57:34 <cariveri> yitz: it seems it finds that there once was a backup directory bak/ which should not be part of the program. I removed that directory.
07:11:24 <Trollinator> zomg: some applications refuse to run as root
07:12:44 <deweyvm> is there a way to check if N bytes can be read without forcing the whole input and without involving the IO monad (like with 'try') in the Get monad?
07:12:51 <deweyvm> are left to be read*
07:13:15 <zomg> Trollinator: true
07:20:40 <GeoffTK> Hey guys, noob questions coming your way.  I am still learning haskell and am trying to work through some message signature stuff.
07:21:39 <GeoffTK> So basically, I have a function that will take two tuples of Int's  and then return true if the product of the first one is greater than the product of the second one.  What would that signature look like?
07:21:46 <GeoffTK> I have this: sortFunction :: Num a => (a, a) -> (a, a) -> Bool
07:22:08 <identity> that looks correct.
07:22:27 <GeoffTK> I am getting this error though: Could not deduce (Ord a) arising from a use of `<' from the context (Num a)
07:22:51 <GeoffTK> is there anyway for me to explicitly set those to Int instead of Num a =>
07:23:05 <identity> Ah, yes. That is because you are saying that a is an instance of Num, but for your to be able to compare them, you also need it to be an instance of Ord
07:23:17 <identity> Yes. Remove Num a => and replace a with Int.
07:23:54 <GeoffTK> so something like this; sortFunction :: (Int, Int) -> (Int, Int) -> Bool
07:24:03 <jomg> GeoffTK: or you could make Num a => ... into (Num a, Ord a) => ...
07:24:09 <identity> Exactly like that.
07:24:40 <haasn> (You might also be interested in -> Ordering rather than -> Bool; if you want to use it for sorting as the name implies)
07:24:54 <haasn> :t comparing $ productOf both
07:24:56 <lambdabot> (Data.Bitraversable.Bitraversable r, Ord a, Num a) => r a a -> r a a -> Ordering
07:25:05 <haasn> Oh Bitraversable, how I love you
07:25:53 <GeoffTK> Originally I was working with sortBy, but could not for the life of me figure it out.  so I figured I would start simpler
07:25:57 <liqu0ric1> why isn't Ord a prerequisite for Num?
07:26:09 <GeoffTK> but thanks guys, that all makes perfect sense
07:26:21 <corgifex> liqu0ric1: complex numbers
07:26:35 <haasn> liqu0ric1: How do you compare complex numbers, or linear transformations, or functions, or any other sort of thing that can be a perfectly valid Num instance?
07:27:10 <liqu0ric1> ok, makes sense
07:27:36 <jomg> for Nums that are also Ord, there's Real i guess
07:27:37 <xpika> is there a natural numbers data type?
07:27:47 <identity> GeoffTK:  The simplest way would be to simply define a function tupleProduct (x,y) = x * y and then use sortBy (comparing tupleProduct) ..
07:28:37 <haasn> tupleProduct = uncurry (*)
07:28:50 <identity> didn't want to confuse him with uncurry
07:28:56 <zwer> you mean curry?
07:29:05 <zwer> oh no, it is uncurry
07:29:21 * haasn .oO( Maybe xpika was on to something )
07:32:33 <Adeon> is there a typeclass that's like Alternative but without 'empty'
07:32:36 <Adeon> like a semigroup
07:32:39 <Adeon> if that makes sense
07:34:43 <bennofs> Adeon: http://hackage.haskell.org/package/semigroupoids-4.0.2.1/docs/Data-Functor-Alt.html
07:36:07 <Adeon> interesting
07:36:08 <Adeon> thanks
07:41:58 <Para_> Hey guys -- if I'm trying to apply a function to a list until the list doesn't change length, is there a way to do this?
07:44:39 <l0cust> Para_: f | length s == something = someFunction | otherwise = anotherFunction
07:44:44 <l0cust> Para_: pattern guards
07:45:07 <Para_> oh hm
07:45:11 <Para_> that should work
07:45:17 <Para_> I didn't think of that!
07:45:33 <Para_> wait
07:45:45 <Para_> never mind
07:46:22 <l0cust> :t uncurry
07:46:23 <lambdabot> (a -> b -> c) -> (a, b) -> c
07:54:18 <yitz> Para_: except that way repeatedly traverses the entire list to count it
07:54:46 <Para_> my implementation isn't exactly working either
07:54:47 <Para_> hmm
07:55:38 <yitz> Para_: it would be better if you have some information about the function you are applying that can help you decide that the list won't change anymore.
07:56:22 <Para_> maybe determining if the list won't change isn't a good way to go about it --
07:56:29 <Para_> I'm writing a smoothing function
07:56:38 <Para_> that takes a list of pairs
07:56:56 <Para_> and iteratively goes over them, removing pairs at a time if they are too close together
07:57:06 <Para_> the thing is that if I remove a pair, I don't know how I can "go back"
07:57:29 <Para_> to see if the previous point before the pair is far enough from the next point
07:57:38 <Para_> so essentially when I remove a pair, I start just checking them in pairs
07:57:47 <Para_> here is my code before the attempt of the length thing
07:58:04 <Para_> http://lpaste.net/106060
07:59:30 <avaritia> is it intended when i'm getting type error at runtime?
07:59:46 <Para_> ?
08:00:57 <Para_> any ideas?
08:01:26 <avaritia> I made haskell notice that types mismatch at runtime while using fromJust and mplus. judging from the type signatures it shouldnt happen hmf
08:03:06 <benzrf> avaritia: go on
08:04:52 <yitz> Para_: here is an example of something kind of similar (newton's method):
08:04:56 <yitz> > let stable (x:xs@(x':_)) | x == x' = x | otherwise = stable xs; isqrt n = stable . iterate (\y -> (y*y + y + n) `div` (y + y)) $ n `div` 2 in isqrt 2500
08:04:57 <lambdabot>  50
08:05:23 <Para_> hm ok let me look at that really quickly
08:05:54 <bennofs> is there a datatype that is like [Either a b], but such that a Left is never followed by another Left?
08:06:07 <avaritia> benzrf: http://lpaste.net/8114666980042080256 it gives me "rays: cant convert vector from int"
08:06:24 <yitz> bennofs: ever, or just immediately?
08:06:37 <bennofs> yitz: immediately
08:06:48 <avaritia> benzrf: it's obviously wrong but i think that should be detected at compile time since its Maybe (Vector3D,Object) vs Maybe (Int,Object)
08:07:03 <Para_> oh hmm
08:07:06 <Para_> that seems like it could work
08:07:08 <Para_> let me try it
08:09:15 <avaritia> benzrf: or am I wrong?
08:09:38 <yitz> bennofs: data E a b = R b (E a b) | L a b (E a b) | LNil a | Nil
08:09:39 <benzrf> bennofs: you could probably make a gadt
08:09:40 <Cale> bennofs: data X a b = E | L a (Y a b) | R b (X a b); data Y a b = E' | R' b (X a b)
08:09:41 <benzrf> whats your use case
08:10:13 <yitz> Cale: let's look in the log to see whose got in first
08:10:54 <bennofs> yitz, Cale: that could work. Is that type maybe already defined somewhere?
08:11:00 <Cale> bennofs: no
08:11:18 <yitz> Cale: beat you by at least one second
08:11:54 <yitz> but Cale was probably looking the other way at the moment and started several seconds later...
08:12:17 <Cale> At least, I would bet against anyone else ever having defined that type.
08:12:27 <benzrf> bennofs: use case?
08:12:54 <Cale> (in a released library)
08:13:15 <Para_> let stable (x:xs@(x':_)) | x == x' = x | otherwise = stable xs
08:13:18 <Para_> :t stable . iterate
08:13:19 <lambdabot>     Not in scope: ‘stable’
08:13:19 <lambdabot>     Perhaps you meant one of these:
08:13:19 <lambdabot>       ‘state’ (imported from Control.Monad.State),
08:13:26 <benzrf> Para_: use @let
08:13:30 <Para_> @let stable (x:xs@(x':_)) | x == x' = x | otherwise = stable xs
08:13:32 <lambdabot>  Defined.
08:13:34 <Para_> :t stable . iterate
08:13:35 <lambdabot>     Couldn't match type ‘a -> [a]’ with ‘[c]’
08:13:35 <lambdabot>     Expected type: (a -> a) -> [c]
08:13:35 <lambdabot>       Actual type: (a -> a) -> a -> [a]
08:13:40 <Para_> ^
08:13:48 <Para_> oh
08:13:53 <Para_> :t stable
08:13:54 <lambdabot> Eq a => [a] -> a
08:13:55 <Para_> :t iterate
08:13:56 <lambdabot> (a -> a) -> a -> [a]
08:14:08 <Para_> I'm not quite sure why it isn't matching
08:14:20 <benzrf> in erlang reusing a variable means that both spots must match
08:14:24 <benzrf> i kinda like that
08:14:42 <benzrf> but i guess in haskell that would require an Eq constraint or something
08:15:03 <Hafydd> "both spots"?
08:15:13 <benzrf> Hafydd: for example
08:15:19 <yitz> Para_: you need to supply the first function parameter to iterate
08:15:28 <Para_> oh
08:15:29 <Para_> gotcha
08:15:36 <benzrf> stable (x:xs@(x:_)) = x
08:15:44 <benzrf> stable (x:xs) = stable xs
08:16:07 <benzrf> oh wait
08:16:09 <benzrf> that can be just
08:16:18 <benzrf> stable (x:x:xs) = x
08:16:24 <benzrf> stable (x:xs) = stable xs
08:16:34 <benzrf> ^valid erlang if you adjusted for syntax
08:16:42 <benzrf> but haskell does not let that happen
08:16:55 <Hafydd> Oh, I see.
08:17:04 <Hafydd> Yes, I've wanted that kind of thing before.
08:17:13 <yitz> benzrf: in the past people suggested a haskell extension like that, but when you try to nail the exact semantics it ends up not being worth it. i forget the details.
08:17:29 <benzrf> stable([X|X|Xs]) -> X; stable([X|Xs]) -> stable(Xs).
08:17:30 <yitz> benzrf: but if you can figure out how to make it fly - great!
08:17:31 <benzrf> ^ i think
08:17:36 <benzrf> yitz: :\
08:17:47 <benzrf> yitz: i was thinking just an equality constraint
08:17:58 <benzrf> say, an implicit guard clause after the pattern
08:18:20 <yitz> benzrf: so you want to make the Eq class magical, with this special syntax?
08:18:23 <benzrf> hmm, i guess by the time it proceeds to guards, you're already assuming the pattern matched
08:18:27 <benzrf> yitz: see that's the problem
08:18:33 <benzrf> hence why i said eh
08:18:35 <Para_> agh, its returning nothing now!
08:18:38 <benzrf> 11:14 < benzrf> but i guess in haskell that would require an Eq constraint or something
08:19:02 <benzrf> then again, there ARE already magical classes
08:19:09 <benzrf> [foo..bar] uses enum, right
08:19:11 <benzrf> *Enum
08:19:13 <bennofs> yitz: inferred Eq class. That's just like using do notation and requiring Monad
08:19:20 <yitz> Para_: it wouldn't be so bad to return nothing if the return type were Maybe :)
08:19:37 <Para_> Its returning nothing, even though it should be returning stuff
08:19:43 <Para_> (so there's a logic error somewhere
08:19:45 <Para_> )
08:19:55 <Para_> haha
08:20:05 <yitz> benzrf: well yes, but Enum exist pretty much just for that. Monad is also magical, for do notation.
08:20:24 * benzrf waves yitz away
08:20:37 * yitz waves back cheerfully
08:20:37 <benzrf> hmm
08:20:50 <benzrf> btw ghci bug report
08:20:58 <benzrf> if i :set +m and then :set prompt
08:21:06 <benzrf> continuation lines dont get their prompt updated
08:21:27 <yitz> benzrf: oh ugh
08:21:56 <benzrf> this is an issue because sometimes i :set +m to test out do-notation stuff in ghci more conveniently
08:22:08 <benzrf> but then i get blasted with a 10000000000-char prompt from all my imports
08:22:30 <yitz> benzrf: did you actually submit the bug report?
08:23:05 <benzrf> no
08:23:06 <bennofs> benzrf: there is a :set prompt2
08:23:11 * benzrf headdesks
08:23:13 <benzrf> bennofs: i did not know this
08:23:26 <benzrf> it doesnt tab complete
08:23:31 <benzrf> no wait
08:23:35 <benzrf> Some flags have not been recognized: prompt2, Haskell|
08:23:38 <benzrf> what version do you need?
08:23:53 <bennofs> benzrf: 7.8 I think
08:24:00 <bennofs> let me try
08:24:01 <benzrf> bah
08:24:07 <benzrf> my sucky vps still has 7.4
08:24:13 <benzrf> oh well
08:25:12 <benzrf> ok yea
08:25:25 <benzrf> when guards fail it falls through to the next pattern
08:25:33 <benzrf> recurring variable rewriting should be fairly trivial
08:25:54 <benzrf> oh wait
08:26:03 <benzrf> i guess youd need to nest guards if there were already guards on the function?
08:26:19 <bennofs> benzrf: just &&
08:26:51 <benzrf> hmmmmmmm
08:26:53 <benzrf> ok
08:27:00 <benzrf> pattern with recurring vars, no guards:
08:27:13 <benzrf> rewrite all but the first recurring var to have suffixes or something
08:27:19 <benzrf> then add a guard comparing equality
08:27:25 <benzrf> when it has guards already
08:27:34 <benzrf> prefix them with that, &&
08:27:39 <benzrf> simple
08:27:52 <benzrf> how i write ghc extensions
08:29:05 <Iceland_jack> benzrf: Get the GHC source and modify it
08:29:31 <benzrf> gros
08:29:52 <l0cust> Hey, does anyone by chance have Miran Lipovača's email address?
08:29:59 <l0cust> I can't find it anywhere on the interwebs
08:30:16 <l0cust> He's the author of LYAH
08:30:37 <l0cust> ah
08:30:38 <Iceland_jack> benzrf: You seem to be talking about implementing non-linear patterns
08:30:49 <l0cust> he has it poorly encoded in lyah
08:30:51 <l0cust> never mind
08:32:19 <benzrf> Iceland_jack: nonlinear patterns?
08:32:43 <Iceland_jack> Where a variable is used twice
08:32:49 <benzrf> o
08:32:57 <benzrf> yea
08:33:11 <benzrf> why 'nonlinear'?
08:34:41 <t4nk277> gsjgspfosf
08:34:41 <yitz> benzrf: it's a general term from lambda calculus, by analogy with algebra where a multiplicative term with a variable occuring more than once is non-linear.
08:39:49 <benzrf> ah
08:40:09 <benzrf> hmmm
08:40:46 <benzrf> if each guard were rewritten to have the comparison at the beginning, would ghc be smart enough to only calculate it once?
08:40:56 <benzrf> alternatively, is there a way to nest guards?
08:41:17 <Iceland_jack> benzrf: The issue with that is having to assume a lot of properties about the possibly user-defined Eq instance
08:42:27 <benzrf> oh?
08:42:30 <Iceland_jack> it's not an unreasonable feature though but it makes things complicated
08:42:52 <benzrf> what kinda properties?
08:45:25 <Iceland_jack> benzrf: For example, what happens if a variable occurs more than twice in a pattern
08:45:40 <benzrf> compare all of them for equalit
08:45:41 <benzrf> y
08:45:50 <benzrf> oh i see, that assumes transitivity?
08:45:53 <Iceland_jack> Yes
08:45:56 <Iceland_jack> also, in which order?
08:46:19 <benzrf> meh, an Eq instance that isnt transitive isnt worth much in my book
08:46:20 <Iceland_jack> The order determines the evaluation order for more than 2 variables
08:46:33 <benzrf> true :S
08:46:46 <Iceland_jack> benzrf: like floating point numbers? :)
08:46:52 <benzrf> bah
08:47:01 * bennofs hates FP numbers
08:47:11 <Iceland_jack> Incurring an Eq constraint made some peope uncomfortable, but I don't think that's such a big deal
08:47:19 <bennofs> they always break alll the nice features
08:48:07 <Iceland_jack> I don't think it's an unreasonable feature, in applications such as type checking it would be very nice to have
08:48:33 <Iceland_jack> I'm currently developing an extention that would work very well with non-linear patterns, but alas
08:48:52 <Iceland_jack> *extension
08:50:09 <benzrf> is there a guide to writing ghc exts
08:50:12 <benzrf> i cant find one
08:50:24 <benzrf> kinda wanna try writing a naive version of this for fun
08:50:32 <benzrf> inb4 "AHAHA HE THINKS WRITING GHC EXTS COULD BE FUN"
08:50:38 <Iceland_jack> :)
08:50:50 <Iceland_jack> Read through GHC and see where other similar extensions are located
08:50:54 <benzrf> im tryin
08:51:04 <benzrf> hoping there's something that points it out for me >:[
08:51:18 <benzrf> i tried searching for 'TupleSections' on the GH to see if i could find a sourcefile for it
08:51:49 <Iceland_jack> I believe Haskell's predecessor had non-linear patterns but nobody cared about them enough to keep them in Haskell
08:52:11 <benzrf> pooh
08:52:38 <benzrf> seriously is there no guide to writing extensions at all
08:52:47 <benzrf> or even a listing of where to look for something to use as a basis
08:53:21 <Iceland_jack> Writing an extension is working with GHC, so you can look up guides for working with GHC instead
08:53:38 <benzrf> man
08:54:51 <benzrf> why is there *puppet* in the ghc repo?
08:54:54 <benzrf> of all things
08:55:20 <benzrf> oh github just misinterpreted the extension
08:57:47 <benzrf> bluh
08:57:52 <benzrf> Iceland_jack: just gimme a hint man
08:58:08 <benzrf> all i can find is writing plugins -.-
08:58:59 <Iceland_jack> Have you searched online?
08:59:00 <Iceland_jack> @google how to implement a GHC extension
08:59:01 <lambdabot> http://www.haskell.org/ghc/docs/latest/html/users_guide/data-type-extensions.html
08:59:01 <lambdabot> Title: 7.4.�Extensions to data types and type synonyms
08:59:15 <Iceland_jack> @google how to implement a haskell extension
08:59:16 <lambdabot> http://stackoverflow.com/questions/21644287/how-to-implement-a-haskell-extension
08:59:16 <lambdabot> Title: ghc - How to implement a Haskell extension? - Stack Overflow
08:59:37 <Iceland_jack> I'm doing a million things atm, sorry
08:59:48 <Iceland_jack> I would just get the source and jump in
09:00:28 <benzrf> gah
09:00:35 <benzrf> i ggoogled ghc ext
09:00:39 <benzrf> not haskell ext
09:02:30 <benzrf> Iceland_jack: yeah that SO question has no info on how to write ghx exts
09:02:34 <benzrf> i dont think there's a single guide on the internet
09:02:54 <nick_named> If I have a string of Haskell code, is there a library that will allow me to evaluate it?
09:03:04 <geekosaur> hint
09:03:10 <geekosaur> or write to ghc-api directly but ugh
09:03:29 <geekosaur> @hackage hint
09:03:29 <lambdabot> http://hackage.haskell.org/package/hint
09:03:31 <Iceland_jack> Then go with my second suggestion :) writing an extension is not a common activity and it has the same effect as writing normal GHC code
09:03:49 <Iceland_jack> So search for 'how to get started with GHC dev' or something and jump in
09:04:20 <benzrf> bwaa
09:04:36 <Iceland_jack> I'm not sure what you expected
09:04:39 * benzrf puts on armor and prepares for pain
09:04:43 <benzrf> Iceland_jack: >.>
09:05:32 <nick_named> geekosaur: Thanks, hint looks like it will probably work, I'm looking to implement the recursion theorem
09:14:53 <avaritia> benzrf: so hmm what do you think about my issue? is it error of mine or did i find a bug in the compiler?
09:15:23 <benzrf> oh
09:15:32 <benzrf> i didnt actually look at it, i bet it's over my head
09:15:34 <benzrf> can you relink
09:16:15 <avaritia> benzrf: i'm a newbie in this so i doubt it http://lpaste.net/8114666980042080256 line 13
09:16:25 <benzrf> oh
09:16:34 <benzrf> don't use fromJust
09:16:36 <benzrf> it's partial
09:16:40 <avaritia> benzrf: basically fromJust $ Maybe (a,b) `mplus` Maybe (c,b)
09:16:48 <benzrf> oh i see
09:16:50 <avaritia> yes but haskell fails to recognize that a != b
09:16:53 <avaritia> meh
09:16:55 <avaritia> a!=c
09:17:09 <benzrf> what's your error?
09:17:36 <avaritia>  "rays: cant convert vector from int" at runtime
09:17:55 <avaritia> i think that should've been caught at compile time?
09:18:06 <monochrom> why should 100000 have type Vector3D?
09:18:13 <avaritia> it doesnt
09:18:33 <benzrf> avaritia: uh
09:18:38 <benzrf> you're asserting that it does
09:18:40 <avaritia> but the point is that ghc shouldve realised it at compile time?
09:18:43 <monochrom> so what is it doing in Just (100000,voidO) of type Maybe(Vector3D,Object)
09:18:45 <benzrf> oh
09:19:01 <benzrf> avaritia: is Vector3D an instance of Num?
09:19:07 <benzrf> you know that numeric literals are polymorphic, right?
09:19:09 <avaritia> yes
09:19:15 <avaritia> hmm
09:19:27 <benzrf> :t 3
09:19:28 <lambdabot> Num a => a
09:19:37 <benzrf> :t 100000
09:19:38 <lambdabot> Num a => a
09:19:46 <benzrf> this can be unified with Vector3D
09:19:54 <benzrf> avaritia: did you define fromInteger for it?
09:20:08 <avaritia> benzrf: well no , that explains a lot, thanks
09:20:11 <benzrf> :p
09:20:31 <benzrf> careful what youre throwing around with Num instances
09:25:31 <hemanth> is there a formal definition of a function?
09:25:50 <hemanth> as in it's signature
09:25:56 <toki78> Hi
09:26:10 <toki78> Axman6, I think, I prettified it a bit
09:26:59 <pjdelport> hemanth: What do you mean?
09:29:20 <benzrf> hemanth: pls elaborate
09:30:05 <hemanth> might sounds silly hmm.. say in C: it's like <return_value> function { <return> }
09:30:27 <geekosaur> :t map
09:30:28 <lambdabot> (a -> b) -> [a] -> [b]
09:30:33 <hemanth> if you were to represent a function in a finite chart, it would be like?
09:30:36 <geekosaur> ^ that's a function signature
09:30:59 <geekosaur> or as you'd write it in code:      map :: (a -> b) -> [a] -> [b]
09:31:13 <corgifex> hemanth: that's not C
09:31:16 <hemanth> cool, geekosaur
09:31:27 <hemanth> corgifex, heh heh
09:31:58 <geekosaur> these signatures are often inferrable and therefore optional, but it helps debugging to provide them so some Haskell programmers always provide them
09:32:16 <geekosaur> (except in certain pathological cases... like xmonad's layoutHook >.> )
09:32:43 <hemanth> so there are different types of functions?
09:32:57 <geekosaur> I don't understand the question
09:33:02 <corgifex> why are we talking about functions specifically?
09:33:22 <hemanth> Generalising we could say: `let functionName param1 param2....paramN = defination`
09:33:36 <corgifex> also, the C syntax for a declaration is something like <typey_words> <pseudo_expression> ;
09:33:51 <geekosaur> it's not that the layoutHook is a different type of function, it's that xmonad uses types in complex ways and the type of a layout hook is very complex as a result
09:34:31 <geekosaur> it's fairly easy to figue them out, but they're painfully long
09:36:57 <hemanth> if you were to represent a function like http://push.cx/wp-content/uploads/2009/06/whitespace.png, then it would be?
09:37:12 <hemanth> geekosaur,  corgifex, benzrf  ^
09:37:32 <corgifex> what's that?
09:37:54 <dwcook> hemanth: I haven't read the context but that's a parser. You can implement it with libraries like parsec
09:37:54 <mzero> ... a Parser?
09:37:59 <corgifex> ... a diagram for ants?
09:38:11 <Iceland_jack> heh
09:39:00 <corgifex> what do the lines mean? what about the other lines?
09:39:31 * hemanth shudders
09:39:31 <dwcook> Branching lines are, roughly, (<|>), and sequencing is, roughly, (>>)
09:39:49 <mzero> the diagram is a once common way to express language syntax, called a railroad diagram first made popular by Pascal
09:39:52 <dwcook> Although there's also repetition indicated in there
09:40:00 <benzrf> i prefer BNF myself
09:40:06 <benzrf> hemanth: do you know BNF?
09:40:16 <dwcook> hemanth: This is from the JSON specification, isn't it?
09:40:19 <benzrf> parsec is kind of like writing BNF, but nicer
09:40:21 <corgifex> aah
09:40:26 <benzrf> also you control what kind of data structure comes out
09:40:30 <benzrf> parsing is naturally monadic :-D
09:40:31 <corgifex> why are some of the terminals circles and others boxes?
09:40:51 <hemanth> benzrf, yes normal forms
09:41:02 <mzero> as an aside, makeTokenParser, from Text.Parsec.Token can be used to generate this parser, along with several other commonly used parsers for programming language constructs
09:41:15 <dwcook> corgifex: I suppose the literal ones are circles and the descriptions boxes
09:41:17 <hemanth> dwcook, yes sir!
09:41:54 <mzero> JSON, is spec'd by RFC 4627, and is written in 80 column ASCII, and certainly doesn't have any diagrams in it!
09:41:57 <hemanth> trying to find the standard way to learn and explain functions, doing https://github.com/hemanth/haskell-rascal so far :)
09:42:26 <dwcook> mzero: Well, this is more like an informal specification from http://json.org/
09:42:27 <corgifex> \x -> B is a function of parameter x with body B
09:42:48 <dwcook> I think
09:43:07 <dwcook> Hmm, I don't see it on that page though
09:43:25 <corgifex> I wasn't aware JSON had comments
09:43:32 <mzero> I think you'll find the formal spec does not admit comments
09:43:40 <hemanth> >> let square n = n * n
09:43:42 <dwcook> Oh true, maybe it's JavaScript?
09:43:49 <dwcook> hemanth: What language is this actually from?
09:43:49 <hemanth> >> :t square
09:43:50 <corgifex> javascript has more whitespace
09:44:03 <dmwit> ?let square n = n * n
09:44:05 <lambdabot>  Defined.
09:44:05 <dmwit> :t square
09:44:06 <lambdabot> Num a => a -> a
09:44:17 <mzero> True, ECMAScript has these kinds of comments... but warning, you can't parse ECMAScript with a BNF (and with Parsec) alone
09:44:37 <corgifex> just watch me
09:44:48 <benzrf> mzero: pretty sure you can parse ecmascript with parsec
09:44:50 <hemanth> dwcook, those are from the book the good parts
09:44:52 <derekv>  I am fully confused trying to use a writer monad
09:44:57 <benzrf> monadic parsers can be context-sensitive :-)
09:45:00 <l0cust> I should have known better than to mention Haskell in #python
09:45:06 <derekv> I can read the examples
09:45:07 <dwcook> Ah, so JS it seems
09:45:11 <mzero> you can if you ignore semicolon insertion
09:45:11 <Zekka> l0cust: What happened?
09:45:22 <l0cust> Zekka: someone asked me what it was
09:45:23 <dwcook> and a possibly informal specification
09:45:23 <Philonous> l0cust, Yes, you should have ;)
09:45:24 <corgifex> mzero: what's the problem with semicolon insertion?
09:45:26 <Zekka> Also, Derek -- any particular points of confusion or do you just want the long view of what Writer does/how it works?
09:45:34 <mzero> corgifex: Knowing when to insert one!
09:45:39 <Zekka> It's pretty straightforward but if you're like me it wasn't immediately obvious
09:45:46 <dwcook> mzero: Can't you just backtrack?
09:45:48 <l0cust> Zekka: explained it, someone got angry, set out to prove everything I said wrong
09:45:49 <corgifex> mzero: when required
09:46:05 <hemanth> Num a => a -> a, in words?
09:46:12 <Zekka> l0cust: Prove what wrong? "Haskell is a purely functional language"? "Haskell is statically typed"?
09:46:14 <monochrom> ECMAScript alllows users to omit some semicolons and the computer puts them back
09:46:24 <mzero> I once had a long conversation with Mark Miller about this topic .... and to be frank I can't remember all the details, but I understood that it had very complex subtly
09:46:28 <l0cust> Zekka: Well, the runtime is dynamic
09:46:33 <l0cust> Zekka: because it's C
09:46:39 <corgifex> wat
09:46:40 <Philonous> l0cust, That does mean you win, though. (For whatever that's worth. )
09:46:49 <monochrom> yes, every "do what I mean" scheme is complicated and nasty
09:46:51 <derekv> Zekka it's just usage … give me a minute I'll do an lpaste
09:46:53 <Zekka> l0cust: I don't follow.
09:46:55 <corgifex> l0cust: you're wrong about everything
09:47:01 <dwcook> mzero: https://es5.github.io/#x7.9
09:47:03 <l0cust> corgifex: explain
09:47:22 <l0cust> The Haskell runtime is written in C
09:47:28 <corgifex> l0cust: there is no Haskell runtime
09:47:36 <l0cust> *the ghc runtime
09:47:40 <dmwit> oooo, pedantic'd!
09:47:45 <corgifex> but Zekka was talking about Haskell
09:47:51 <corgifex> about its type system, specifically
09:47:54 <mzero> dwcook: yes - that looks a little hard to express directly in Parsec to me
09:47:55 <dmwit> I wonder what you meant by "dynamic".
09:47:55 <benzrf> my current favorite bit-o-pedantry is euler vs venn diagrams
09:47:59 <dmwit> That's a word that has no good definition.
09:48:07 <derekv> http://lpaste.net/106064
09:48:09 <dwcook> mzero: Hard maybe. I'm not convinced it can't be done though.
09:48:14 <Zekka> Although I'm guilty of saying "Haskell" when I mean "GHC" specifically, in this case I was talking about its type system
09:48:15 <mzero> fair enough
09:48:18 <corgifex> a strongly weak language
09:48:20 <dmwit> My current favorite is type constructor vs. type.
09:48:21 <darthdeus> is there a single character operator that can be redefined?
09:48:24 <Zekka> which is static in that you can determine the type of everything at compile-time
09:48:24 <dwcook> mzero: Either way, we can probably agree it's not a beginner problem. :)
09:48:29 <l0cust> darthdeus: 0
09:48:30 <darthdeus> or are all of the valid operator chars taken?
09:48:31 <monochrom> I think it's alright to mention haskell in #python, or python in #haskell. but if someone gets angry at you, walk away, just walk away.
09:48:37 <l0cust> darthdeus: %
09:48:38 <Zekka> derekv: Peeking
09:48:42 <l0cust> darthdeus: ~
09:48:43 <dmwit> Zekka: Are you sure about that?
09:48:44 <derekv> I'm trying to see if writer or writerT is a cleaner approach than passing around IO monad
09:48:45 <corgifex> darthdeus: ?
09:48:46 <mzero> but it might be so convoluted that it will be easier to use Parsec and some outer level mechanism....
09:48:49 <l0cust> darthdeus: !
09:48:50 <hemanth> thank you guys!
09:48:55 <l0cust> darthdeus: @
09:48:56 <Zekka> dmwit: When can't you?
09:48:57 <l0cust> darthdeus: #
09:49:03 <darthdeus> ha, thanks :)
09:49:05 <dmwit> Zekka: Would it surprise you to learn that, even in H98, some things need explicit type signatures to type-check...?
09:49:07 <dwcook> monochrom: I got the impression from that wiki page comparing Python and Haskell that Pythonists were okay with Haskell
09:49:12 * hemanth takes a break and will be back with some more silly questions :D 
09:49:13 <benzrf> > 3 # 4
09:49:14 <lambdabot>  Could not deduce (GHC.Num.Num
09:49:14 <lambdabot>                      (Control.Lens.Review.AReview s0 t a0 b0))
09:49:14 <lambdabot>    arising from the ambiguity check for ‘e_134’
09:49:14 <lambdabot>  from the context (GHC.Num.Num
09:49:14 <lambdabot>                      (Control.Lens.Review.AReview s t a b),
09:49:16 <corgifex> l0cust: I'm skeptical of ~ and @
09:49:18 <benzrf> hmm
09:49:19 <benzrf> :t (#)
09:49:20 <lambdabot> parse error on input ‘)’
09:49:25 <Zekka> dmwit: No. Are there any cases that don't involve the monomorphism restriction?
09:49:25 <benzrf> u wot
09:49:26 <dmwit> Zekka: Would it surprise you to learn that, even in H98, sometimes class dictionaries cannot be statically inferred...?
09:49:29 <edwardk> > _Left # 4
09:49:30 <lambdabot>  Left 4
09:49:32 <dmwit> Zekka: There are, yes.
09:49:33 <corgifex> Zekka: yes
09:49:36 <edwardk> > _Left._Left # 4
09:49:37 <lambdabot>  Left (Left 4)
09:49:39 <Zekka> Well, that actually would surprise me, can you give an example?
09:49:40 <benzrf> coo
09:49:42 <bennofs> :t review
09:49:43 <lambdabot> MonadReader b m => AReview s t a b -> m t
09:49:45 <derekv> Zekka: line 13 and 19-21 is where i'm struggling right now
09:49:49 <bennofs> (#) = review
09:49:52 <corgifex> inb4 polymorphic recursion
09:49:57 <dwcook> Zekka: Some values don't have a most general type. This can happen when you get GADTs involved, for example
09:50:16 <corgifex> :t read . show
09:50:17 <lambdabot> (Show a, Read c) => a -> c
09:50:23 <jmcarthur> other way
09:50:25 <corgifex> :t show . read
09:50:26 <lambdabot> String -> String
09:50:31 <l0cust> Alright, enough arguing for me. I've gotta get back to work https://www.youtube.com/watch?v=qUmHKHbQe80
09:50:35 <l0cust> bye
09:50:35 <jmcarthur> ah defaulting
09:50:37 <Zekka> derekv: Alright, two things offhand
09:50:42 <dmwit> Zekka: http://stackoverflow.com/a/11422333/791604
09:50:56 <Zekka> dmwit: I'll look in a moment
09:50:56 <jmcarthur> > show . read $ "()"
09:50:58 <lambdabot>  "()"
09:51:19 <monochrom> @type show . read
09:51:20 <lambdabot> String -> String
09:51:29 <monochrom> err, nevermind
09:51:30 <Zekka> derekv: First of all, I thnk 'obituate' would be clearer as this: tell (name character ++ " has died.")
09:51:35 <mzero> defaulting in lambdabot ≠ defaulting in HS spec
09:52:05 <mlen> Hi, can you help me to get some code with GHC.TypeLits working? I'm probably missing something obvious. Unfortunately googling doesn't help a lot. Here's the snippet: https://gist.github.com/mlen/23f61025c385f8538539
09:52:11 <Zekka> Second, I think line 13 says something slightly different from what you mean
09:52:20 <derekv> Zekka: oh yea I should change that thanks for pointing it out (I think i was having too much fun there with the composition operator)
09:52:21 <dmwit> Zekka: Although that answer doesn't touch on it explicitly, you can try writing the example from it without type signatures and see what happens.
09:52:34 <Maxdamantus> @check \a -> (read . show) a == a
09:52:36 <Zekka> fmapping your function over a list gets you a list of actions -- it doesn't actually do the actions
09:52:36 <lambdabot>  +++ OK, passed 100 tests.
09:52:49 <Zekka> You probably want mapM
09:52:54 <Zekka> :t fmap
09:52:55 <lambdabot> Functor f => (a -> b) -> f a -> f b
09:52:59 <Zekka> :t sequenceM
09:53:01 <lambdabot>     Not in scope: ‘sequenceM’
09:53:01 <lambdabot>     Perhaps you meant one of these:
09:53:01 <lambdabot>       ‘sequence’ (imported from Control.Monad.Writer),
09:53:03 <Zekka> :t sequence
09:53:04 <lambdabot> Monad m => [m a] -> m [a]
09:53:11 <Zekka> :t mapM
09:53:12 <lambdabot> Monad m => (a -> m b) -> [a] -> m [b]
09:53:18 <mlen> The basic idea is to make a stack that fails to compile when you try to pop from empty stack. I know how to get it done w/o TypeLits, but translating it naively doesn't seem to work :)
09:53:28 <derekv> zekka I had been trying different things, I had started with mapM but i'm having trouble getting the types right
09:53:43 <Zekka> So mapM is like sequencing after you fmap a function that gives you a monad action
09:53:55 <Maxdamantus> @src mapM
09:53:55 <lambdabot> mapM f as = sequence (map f as)
09:54:08 <Zekka> dmwit: Reading now, preparing to be shocked and amazed
09:54:31 <corgifex> there's a simpler example
09:54:44 <Zekka> derekv: It's possible there's something I don't see but I feel like your code ought to work once you change that
09:55:05 <Zekka> Try changing that and if things explode come back
09:55:31 <corgifex> > let foo :: (Show a) => n -> a -> String; foo n x | n <= 0 = show x | otherwise = foo (n - 1) (x, x) in foo 3 'x'
09:55:33 <lambdabot>  Could not deduce (GHC.Classes.Ord n)
09:55:33 <lambdabot>    arising from a use of ‘GHC.Classes.<=’
09:55:33 <lambdabot>  from the context (GHC.Show.Show a)
09:55:33 <lambdabot>    bound by the type signature for
09:55:33 <lambdabot>               foo :: GHC.Show.Show a => n -> a -> GHC.Base.String
09:55:42 <corgifex> heh
09:55:50 <corgifex> > let foo :: (Show a) => Int -> a -> String; foo n x | n <= 0 = show x | otherwise = foo (n - 1) (x, x) in foo 3 'x'
09:55:52 <lambdabot>  "((('x','x'),('x','x')),(('x','x'),('x','x')))"
09:55:52 <derekv> Zekka ok brb
09:56:04 <benzrf> Zekka: no, mapM is like sequencing after /mapping/
09:56:09 <corgifex> building types at runtime
09:56:11 <benzrf> sequencing after fmapping is like sequenceA
09:56:13 <benzrf> :t sequenceA
09:56:14 <lambdabot>     Not in scope: ‘sequenceA’
09:56:14 <lambdabot>     Perhaps you meant one of these:
09:56:14 <lambdabot>       ‘T.sequenceA’ (imported from Data.Traversable),
09:56:16 <benzrf> :t T.sequenceA
09:56:17 <lambdabot> (Traversable t, Applicative f) => t (f a) -> f (t a)
09:56:23 <dwcook> @src mapM
09:56:23 <lambdabot> mapM f as = sequence (map f as)
09:56:23 <benzrf> oops
09:56:24 <Zekka> benzrf: Oh silly me, thinking Traversably again
09:56:25 <benzrf> i meant uh
09:56:29 <benzrf> that other function .>.
09:56:35 <Zekka> @src T.mapM
09:56:35 <lambdabot> Source not found. And you call yourself a Rocket Surgeon!
09:56:47 <Zekka> er, does Traversable not provide that? I could have sworn it did
09:56:48 <dmwit> :t T.traverse
09:56:49 <lambdabot> (Traversable t, Applicative f) => (a -> f b) -> t a -> f (t b)
09:57:03 <Zekka> oh, under a different name
09:57:05 <benzrf> lol
09:57:17 <Zekka> :t T.forM
09:57:18 <lambdabot> (Traversable t, Monad m) => t a -> (a -> m b) -> m (t b)
09:57:32 <dmwit> forM and mapM should have the same intuition.
09:57:35 <dmwit> Just different argument order.
09:58:08 <Zekka> Right, although apparently Traversable doesn't provide general mapM, although it provides traverse which seems to be mapM for Applicative instead of Monad
09:58:40 <benzrf> Zekka: mapM *should* be applicative
09:58:42 <benzrf> it's all u need
09:58:54 <Zekka> benzrf: But in the current GHC version Monads aren't necessarily Applicative
09:58:56 <dmwit> :t T.mapM
09:58:57 <lambdabot> (Traversable t, Monad m) => (a -> m b) -> t a -> m (t b)
09:59:05 <dmwit> ...what do you mean, Traversable doesn't provide mapM?
09:59:07 <Zekka> so it's possible (and pretty likely) that it will scream at you
09:59:13 <Zekka> dmwit: Oh. When I @srced I found nothing
09:59:21 <Zekka> which caused me to assume that I remembered wrong
09:59:35 <dmwit> Well, the @src database is woefully incomplete.
09:59:35 <dwcook> Unfortunately @src and :t use different databases
09:59:59 <corgifex> Zekka: @src just asks a random text file in lambdabot
09:59:59 <dwcook> Well, the unfortunate part is more like what dmwit said
10:00:06 <corgifex> it's not the actual library code
10:00:28 <Zekka> Oh. I guess I can understand that given that a lot of stdlib definitions are pretty counterintuitive
10:00:37 <derekv> :t tell
10:00:38 <lambdabot> MonadWriter w m => w -> m ()
10:00:53 <Zekka> and that when someone @srces something they probably actually want something that just explains intuitively what the function does
10:01:53 <dmwit> I don't really think that's the explanation.
10:02:01 <dmwit> I think it's more like "nobody cares enough to fix it".
10:02:36 <dmwit> I certainly don't. =P
10:02:39 <derekv> Zekka:  I think I almost got it, I'm misusing tell somehow
10:03:04 <Zekka> derekv: Really? I didn't feel like there was anything obviously wrong with it
10:03:08 <Zekka> What does the typechecker say about obituate?
10:03:45 <derekv> Zekka yea, needs to be something more like "tell [ myString ]"
10:03:58 <Zekka> derekv: Oh, you're right! I didn't even catch that.
10:04:27 <derekv> Zekka: so I was using WriterT correctly (almost) =P
10:04:30 <Zekka> You're right. For [a] mappend is [a] -> [a] -> [a], so clearly you'd need to be mappending a string
10:04:47 <Zekka> er, [String]
10:05:34 <Ch0c0late> Wanna print all possible rotation of a string. As an instance "abcd" has 4 rotations bcda, cdab, dabc, abcd. Any suggestion? Please note that I do not want solution.
10:05:51 <Maxdamantus> > permutations "abcd"
10:05:53 <lambdabot>  ["abcd","bacd","cbad","bcad","cabd","acbd","dcba","cdba","cbda","dbca","bdca...
10:05:55 <benzrf> bad Maxdamantus
10:05:59 <Zekka> Maxdamantus: He doesn't want that
10:06:01 <Maxdamantus> Oh, rotations.
10:06:02 <benzrf> that's not what Ch0c0late wants anyway
10:06:14 <dmwit> class Container a where type Elem a; singleton :: Elem a -> a; tell' :: (MonadWriter w m, Container w) => Elem w -> m (); tell' = tell . singleton
10:06:31 <Zekka> I'd personally start by thinking about how I can get the next rotation of a string based on the current one
10:06:33 <benzrf> Ch0c0late: im not sure how to hint you without giving a solution
10:06:35 <dmwit> Somebody should stick that in a library and put it up on Hackage. I'd depend on it just about every time I used MonadWriter.
10:07:05 <dmwit> Ch0c0late: You might like the "inits" and "tails" functions.
10:07:08 <dmwit> > inits "abcd"
10:07:10 <lambdabot>  ["","a","ab","abc","abcd"]
10:07:12 <Ch0c0late> benzrf: Wanna write the code by myself and the only thing I need is a piece of advice.
10:07:14 <dmwit> > tails "abcd"
10:07:15 <lambdabot>  ["abcd","bcd","cd","d",""]
10:07:28 <Ch0c0late> dmwit: Tried it out but wasn't helpful.
10:07:35 <dmwit> What did you try?
10:07:42 <benzrf> > zipWith (++) (heads "abcd") (tails "abcd")
10:07:43 <lambdabot>  Not in scope: ‘heads’
10:07:43 <lambdabot>  Perhaps you meant one of these:
10:07:43 <lambdabot>    ‘reads’ (imported from Prelude), ‘head’ (imported from Data.List),
10:07:43 <lambdabot>    ‘BSC.head’ (imported from Data.ByteString.Char8)
10:07:49 <benzrf> > zipWith (++) (inits "abcd") (tails "abcd")
10:07:51 <lambdabot>  ["abcd","abcd","abcd","abcd","abcd"]
10:07:58 <benzrf> oops
10:08:06 <benzrf> > zipWith (++) (tails "abcd") (inits "abcd")
10:08:09 <lambdabot>  ["abcd","bcda","cdab","dabc","abcd"]
10:08:13 <dmwit> benzrf: "I do not want a solution"
10:08:18 <benzrf> oops
10:08:28 <corgifex> > zipWith pure (iterate (\(x : xs) -> xs ++ [x]) "abcd") "abcd"
10:08:30 <lambdabot>  ["abcd","bcda","cdab","dabc"]
10:08:36 <Ch0c0late> benzrf: I wanted to do the same thing. I did r (x:xs) = tails xs ++ inits xs
10:08:38 <dmwit> corgifex: cute
10:08:50 <Iceland_jack> > filter (`isInfixOf` take 100 (cycle "abcd")) (permutations "abcd")
10:08:52 <lambdabot>  ["abcd","bcda","dabc","cdab"]
10:08:52 <Iceland_jack> :)
10:08:55 <corgifex> Ch0c0late: what about the x, though?
10:08:56 <benzrf> Ch0c0late: you need to zipwith
10:09:00 <Zekka> benzrf: Hey, yours looks the same as mine
10:09:07 <benzrf> :t isInfixOf
10:09:08 <lambdabot> Eq a => [a] -> [a] -> Bool
10:09:14 <Zekka> except I got rid of the extra with tail
10:09:16 <Ch0c0late> corgifex: Yeah. It's kinda useless, I think.
10:09:20 <dmwit> > map (take 4) (cycle "abcd")
10:09:22 <lambdabot>  Couldn't match type ‘GHC.Types.Char’ with ‘[a]’
10:09:22 <lambdabot>  Expected type: [[a]]
10:09:22 <lambdabot>    Actual type: [GHC.Types.Char]
10:09:38 <Iceland_jack> > cycle "abcd"
10:09:40 <lambdabot>  "abcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabc...
10:09:44 <dmwit> > map (take 4) . tails . cycle $ "abcd"
10:09:46 <lambdabot>  ["abcd","bcda","cdab","dabc","abcd","bcda","cdab","dabc","abcd","bcda","cdab...
10:09:58 <dmwit> > iterate tail (cycle "abcd")
10:09:59 <lambdabot>  ["abcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdab...
10:10:08 <dmwit> dmwit--
10:10:18 <Maxdamantus> > zipWith take [1..4] repeat (cycle "abcd")
10:10:19 <lambdabot>  Couldn't match expected type ‘[GHC.Types.Char] -> t’
10:10:20 <lambdabot>              with actual type ‘[[a0]]’Couldn't match expected type ‘[[a0]]’ w...
10:10:45 <Maxdamantus> > zipWith (take 4 . drop) [1..4] $ repeat (cycle "abcd")
10:10:46 <lambdabot>  Couldn't match type ‘[a0]’ with ‘[GHC.Types.Char] -> c’
10:10:46 <lambdabot>  Expected type: [a0] -> [GHC.Types.Char] -> c
10:10:47 <lambdabot>    Actual type: [a0] -> [a0]Couldn't match type ‘[a1] -> [a1]’ with ‘[a0]’
10:10:47 <lambdabot>  Expected type: GHC.Types.Int -> [a0]
10:10:47 <lambdabot>    Actual type: GHC.Types.Int -> [a1] -> [a1]
10:10:51 <Maxdamantus> Bleh. Dunno.
10:10:57 <Zekka> > (init ((zipWith (++) . tails) <*> inits)) "abcd"
10:10:58 <lambdabot>  Couldn't match expected type ‘[GHC.Types.Char] -> t’
10:10:58 <lambdabot>              with actual type ‘[a0]’Couldn't match expected type ‘[a1 -> a0]’
10:10:58 <lambdabot>              with actual type ‘[a2] -> [[a2]] -> [[a2]]’Couldn't match expect...
10:10:58 <lambdabot>              with actual type ‘[a3] -> [[a3]]’
10:11:06 <corgifex> you're all fired
10:11:09 <Zekka> > (init . ((zipWith (++) . tails) <*> inits)) "abcd"
10:11:11 <lambdabot>  ["abcd","bcda","cdab","dabc"]
10:11:16 <Zekka> hurray for garbled pointfree
10:11:18 <benzrf> :t zipWith (++) <$> heads <*> tails
10:11:20 <lambdabot>     Not in scope: ‘heads’
10:11:20 <lambdabot>     Perhaps you meant one of these:
10:11:20 <lambdabot>       ‘reads’ (imported from Prelude), ‘head’ (imported from Data.List),
10:11:24 <benzrf> :t zipWith (++) <$> inits <*> tails
10:11:25 <lambdabot> [a] -> [[a]]
10:11:27 <benzrf> :-)
10:11:31 <benzrf> wait lets compare lengths
10:11:46 <Zekka> Oh, that's actually pretty elegant
10:11:47 <benzrf> @let cycles1 = zipWith (++) <$> inits <*> tails
10:11:50 <lambdabot>  Defined.
10:11:58 <benzrf> @let cycles2 l = zipWith (++) (inits l) (tails l)
10:12:00 <lambdabot>  Defined.
10:12:02 <benzrf> marginally shorter!!
10:12:18 <benzrf> @let cycles3 = liftA2 (zipWith (++)) inits tails
10:12:19 <lambdabot>  Defined.
10:12:22 <benzrf> in between
10:12:26 <Maxdamantus> > zipWith ((take 4 .) . drop) [0..3] $ repeat (cycle "abcd")
10:12:28 <lambdabot>  ["abcd","bcda","cdab","dabc"]
10:12:38 <benzrf> Maxdamantus: gross
10:12:49 <corgifex> > words "abcd bcda cdab dabc"
10:12:51 <Maxdamantus> I know.
10:12:51 <lambdabot>  ["abcd","bcda","cdab","dabc"]
10:12:52 <hiptobecubic> I didn't realize Rust was so haskelly
10:13:03 <Zekka> I'm pretty sure it's now well-established that function-as-Applicative is where it's at
10:13:16 <benzrf> hells yeah
10:13:20 <benzrf> Zekka: o/
10:14:31 <Zekka> By the way, yours is slightly incorrect
10:14:36 <Zekka> > (zipWith (++) <$> tails <*> inits) "abcd"
10:14:38 <lambdabot>  ["abcd","bcda","cdab","dabc","abcd"]
10:14:42 <benzrf> nyeh
10:14:42 <Zekka> it includes one duplicate
10:14:54 <benzrf> tail .
10:15:00 <Zekka> > (init <$> (zipWith (++) <$> tails <*> inits)) "abcd"
10:15:01 <derekv> https://github.com/DerekV/rpg/blob/master/Main.hs ok so this is cool (if I say so myself) .. i wrote something in haskell =P
10:15:02 <lambdabot>  ["abcd","bcda","cdab","dabc"]
10:15:24 * benzrf prepares to lecture derekv on whats wrong with his dumb code
10:15:52 * derekv gets out notepad for notes
10:16:08 <Ch0c0late> benzrf: Thanks for the solution. But feel guilty because I had to solve the question by myself. I think I should represent my first solution r (x:xs) = tails xs ++ init xs in order to follow the honor of code.
10:16:19 <benzrf> Ch0c0late: you need to zipWith
10:16:21 <benzrf> not directly apply
10:16:24 <benzrf> ur doin it wrong
10:16:24 <yitz> > fix $ flip (zipWith ((!!) . flip delete "abcd")) (randomRs (0,2) $ mkStdGen 0) . ('a' :)
10:16:25 <lambdabot>  can't find file: L.hs
10:16:28 <derekv> I want to be doing less in monadland
10:16:31 <yitz> > fix $ flip (zipWith ((!!) . flip delete "abcd")) (randomRs (0,2) $ mkStdGen 0) . ('a' :)
10:16:32 <lambdabot>  "dcabcbacbadbacdbdabacabdbdcadbdcdcbcdbdbacdbcacbdcababacbdbacdbdabdcbdcabac...
10:16:39 <benzrf> derekv: but monadland is the best country
10:16:46 <benzrf> show some patriotism!
10:17:07 <Zekka> Personally I think monadland's a pretty good place to be if it expresses your intent
10:17:19 <corgifex> > zipWith (liftM return (zipWith (return ask) "abcd")) (tails (join mappend "abcd")) "abcd"
10:17:19 <jmcarthur> step one: stop using WriterT.
10:17:20 <lambdabot>  ["abcd","bcda","cdab","dabc"]
10:17:25 <Zekka> if you're composing a bunch of functions that all update a data structure then you probably mean State
10:17:31 <benzrf> derekv: fyi you can just say 'show = action'
10:17:34 <benzrf> point-free baby
10:17:40 <dmwit> > let f x = chr (ord 'a' + x) in [[f (m `mod` 4) | m <- [n..n+3]] | n <- [0..3]]
10:17:40 <jmcarthur> reason: transformer stacks are basically just overrated
10:17:41 <lambdabot>  ["abcd","bcda","cdab","dabc"]
10:17:56 <Maxdamantus> > ["abcd","bcda","cdab","dabc"]
10:17:57 <benzrf> ur mum is overrated
10:17:58 <lambdabot>  ["abcd","bcda","cdab","dabc"]
10:18:10 <Zekka> Ch0c0late: There's a lot of ways to express it although IMHO benzrf's is one of the clearest
10:18:22 <jmcarthur> especially when used explicitly rather than wrapped up into some more relevant interface
10:18:23 <Zekka> so you probably won't have too much trouble coming up with a new definition
10:18:28 <Ch0c0late> Zekka: Yes. Thanks.
10:18:35 <corgifex> > (\x -> zipWith (liftM return (zipWith (return ask) x)) (tails (join mappend x)) x) "abcd"
10:18:37 <lambdabot>  ["abcd","bcda","cdab","dabc"]
10:18:43 <corgifex> @pl (\x -> zipWith (liftM return (zipWith (return ask) x)) (tails (join mappend x)) x)
10:18:43 <lambdabot> join (ap (zipWith . fmap return . zipWith (return ask)) (tails . join mappend))
10:18:47 <benzrf> derekv: just skimming this looks pretty neat
10:18:48 <corgifex> perfect
10:19:13 <dmwit> :t chunksOf
10:19:14 <lambdabot> Int -> [e] -> [[e]]
10:19:26 <darthdeus> .strlen any tips on shortening this further?:) mapM(\x->putStrLn$if|x`mod`15==0->"FizzBuzz"|x`mod`3==0->"Fizz"|x`mod`5==0->"Buzz"|otherwise->(show x))[1..101]
10:19:31 <dmwit> > take 4 . map (take 4) . chunksOf 5 . cycle $ "abcd"
10:19:33 <lambdabot>  ["abcd","bcda","cdab","dabc"]
10:19:40 <darthdeus> without the .strlen :p
10:19:49 <derekv> benzrf:  cool, changed
10:20:03 <dmwit> darthdeus: There's like a whole wiki page on fizzbuzz, isn't there?
10:20:11 <hiptobecubic> yes
10:20:37 <dmwit> I'm *shocked* that there is not a fizzbuzz golf section.
10:20:50 <benzrf> hnmm
10:20:59 <Zekka> Actually, benzrf's is a pretty rare case of the function Applicative instance being clear and not confusing
10:21:01 <corgifex> > join (ap (liftM zipWith (liftM (liftM return) (zipWith (return ask)))) (liftM tails (join mappend))) "abcd"
10:21:03 <lambdabot>  ["abcd","bcda","cdab","dabc"]
10:21:08 <benzrf> i propose HQ9+F
10:21:11 <corgifex> you were saying?
10:21:12 <benzrf> where F = fizzbuzz
10:21:19 <benzrf> gah
10:21:26 <Zekka> and it's suitably reactive, which is after all the buzzword these days
10:21:33 <Lutin`> > [max(show x)(concat[n|(f,n)<-[(3,"Fizz"),(5,"Buzz")],mod x f==0])|x<-[1..100]]
10:21:34 <lambdabot>  ["1","2","Fizz","4","Buzz","Fizz","7","8","Fizz","Buzz","11","Fizz","13","14...
10:22:07 <pavonia> darthdeus: otherwize == True
10:22:26 <darthdeus> pavonia: awesome :P
10:22:30 <darthdeus> dmwit: hehe, didn't know that
10:22:49 <yitz> Lutin`: ugh, truncated before 15
10:22:57 <corgifex> @unpl join (ap (liftM zipWith (liftM (liftM return) (zipWith (return ask)))) (liftM tails (join mappend)))
10:22:57 <lambdabot> (((liftM zipWith (liftM (liftM return) (zipWith (return ask)))) >>= \ d -> (liftM tails (mappend >>= \ i -> i)) >>= \ c -> return (d c)) >>= \ a -> a)
10:23:10 <Lutin`> > drop 14 [max(show x)(concat[n|(f,n)<-[(3,"Fizz"),(5,"Buzz")],mod x f==0])|x<-[1..100]]
10:23:11 <lambdabot>  ["FizzBuzz","16","17","Fizz","19","Buzz","Fizz","22","23","Fizz","Buzz","26"...
10:23:20 <pavonia> > if | True -> 1
10:23:21 <lambdabot>  <hint>:1:1: Multi-way if-expressions need MultiWayIf turned on
10:23:23 * benzrf covers his eyes
10:23:33 <dmwit> ?let {-# LANGUAGE MultiWayIf #-}
10:23:33 <lambdabot>  Parse failed: Parse error: EOF
10:23:36 <dmwit> bummer
10:23:37 <benbangert> Does anyone know why Data.Binary's ByteString serialization writes the length of the bytestring as an Int (which is a signed Int64)?
10:23:49 <benzrf> @let {-# LANGUAGE MultiWayIf #-}
10:23:49 <benbangert> It seems a bit silly since a bytestring doesn't need the negative precision....
10:23:49 <lambdabot>  Parse failed: Parse error: EOF
10:23:53 <benzrf> @let {-# LANGUAGE MultiWayIf #-} foo = 3
10:23:53 <lambdabot>  Parse failed: Parse error: foo
10:23:56 <benzrf> dang
10:24:06 <derekv> is it a pretty typical approach for a game to have a sort of object graph representing game state and then functions which trasnform it to a new state?
10:24:19 <dmwit> benbangert: That does seem silly.
10:24:34 <dmwit> benbangert: Not specifying a bit width also seems problematic.
10:24:39 <phil> hey everybody! I'm currently trying to learn haskell. could someone explaine me pls why "findKey key xs = snd . head . filter (\(k,v) -> k == key ) $ xs" only works with $ at the and and not with whitespace?!
10:24:51 <benzrf> phil: precedence
10:24:55 <yitz> benbangert: maybe because it was slightly simpler to write, and you'll never need that extra bit of precision for any real-life bytestring?
10:24:59 <Zekka> derekv: I'd lift it to the type using the State monad but that's the essence of how you do it
10:25:02 <Lutin`> Why don't they just use words :X
10:25:11 <benzrf> phil: given 'foo . bar . baz $ quux'
10:25:13 <benzrf> it parses as
10:25:20 <benzrf> (foo . bar . baz) $ (quux)
10:25:24 <dmwit> phil: http://stackoverflow.com/q/940382/791604
10:25:27 <benzrf> without the dollor it parses as
10:25:34 <benzrf> foo . bar . (baz quux)
10:25:37 <benzrf> which is the wrong semantics
10:25:41 <benzrf> or some such
10:25:52 <benbangert> yitz: maybe, just seemed odd, I have to write my own version anyways in this case
10:26:20 <dmwit> derekv: Sounds pretty normal to me.
10:26:33 <Lutin`> benbangert: What for?
10:27:16 <benbangert> Lutin`: cause my binary protocol says that a string's length will be an unsigned 4-byte (Word32)
10:27:32 <ReinH> Woo another Haskell Cast in the bank
10:27:33 <Lutin`> Ah makes sense
10:27:41 <Maxdamantus> > drop 14 [max$show x$concat[n|(f,n)<-[(3,"Fizz"),(5,"Buzz")],mod x f==0]|x<-[1..100]]
10:27:41 <Lutin`> ReinH: :D Yay
10:27:42 <lambdabot>  Couldn't match expected type ‘[GHC.Types.Char] -> s’
10:27:42 <lambdabot>              with actual type ‘[GHC.Types.Char]’
10:27:55 <yitz> benbangert: isn't that binary equivalent to using an Int?
10:28:04 <yitz> benbangert: or rather an Int32
10:28:08 <yitz> ah
10:28:13 <Lutin`> yitz: Those are signed
10:28:32 <yitz> Lutin`: the sign is always zero so there is no difference in the serialization
10:28:45 <phil> benzrf: okay i get that but since filter takes a function and a [a] i thought filter function xs should work fine ...
10:28:47 <Lutin`> err
10:29:05 <benzrf> phil: it does
10:29:06 <yitz> but benbangert needs 32 bits, not what Int happens to be
10:29:08 <benzrf> but it doesnt compose
10:29:19 <pjdelport> > ap (map . ap (flip . ((<$>) .) . ap ((.) . (.) . (!!)) ((. (+)) . (.) . flip mod . length)) (enumFromTo 1 . length)) (enumFromTo 1 . length) "abcd"
10:29:21 <lambdabot>  ["cdab","dabc","abcd","bcda"]
10:29:22 <benzrf> > head . [1, 2, 3]
10:29:23 <benbangert> yitz: yup, not a biggie, easy enough to write my own
10:29:24 <lambdabot>  Couldn't match expected type ‘a -> [c]’ with actual type ‘[t0]’
10:29:28 <Lutin`> Maxdamantus: $ breaks that
10:29:41 <benzrf> phil: you cant compose a function with the result of another function unless said result is also a function
10:29:56 <Maxdamantus> Yeah, I was being stupid.
10:30:52 <Lutin`> Oh hey shortened by two chars
10:31:01 <Lutin`> > [max(show x)(join[n|(f,n)<-[(3,"Fizz"),(5,"Buzz")],mod x f==0])|x<-[1..100]]
10:31:03 <lambdabot>  ["1","2","Fizz","4","Buzz","Fizz","7","8","Fizz","Buzz","11","Fizz","13","14...
10:31:51 <Maxdamantus> > [max(show x)$join[n|(f,n)<-[(3,"Fizz"),(5,"Buzz")],mod x f==0]|x<-[1..100]]
10:31:52 <lambdabot>  ["1","2","Fizz","4","Buzz","Fizz","7","8","Fizz","Buzz","11","Fizz","13","14...
10:31:58 <dmwit> mod x f<1
10:31:58 <Maxdamantus> can do that at least.
10:32:07 <Lutin`> heh yeah
10:32:19 <benzrf> :t max
10:32:20 <lambdabot> Ord a => a -> a -> a
10:32:27 <benzrf> > max "abc" "def"
10:32:29 <lambdabot>  "def"
10:32:35 <benzrf> ooooooooooooooohhhhh
10:32:37 <Lutin`> > [max(show x)$join[n|(f,n)<-[(3,"Fizz"),(5,"Buzz")],mod x f<1]|x<-[1..100]]
10:32:38 <benzrf> cuute
10:32:39 <lambdabot>  ["1","2","Fizz","4","Buzz","Fizz","7","8","Fizz","Buzz","11","Fizz","13","14...
10:32:41 <Lutin`> benzrf: Yeah :)
10:32:48 <Lutin`> max "3" "Fizz"
10:32:54 <Lutin`> > max "3" "Fizz"
10:32:55 <lambdabot>  "Fizz"
10:33:04 <Lutin`> > max "4" ""
10:33:06 <lambdabot>  "4"
10:33:09 <benzrf> x`mod`f
10:33:21 <Lutin`> doesn't save chars
10:33:26 <benzrf> oh
10:33:55 <Lutin`> > [max(show x)$join[n|(f,n)<-[(3,"Fizz"),(5,"Buzz")],mod x f<1]|x<-[1..]]
10:33:56 <lambdabot>  ["1","2","Fizz","4","Buzz","Fizz","7","8","Fizz","Buzz","11","Fizz","13","14...
10:34:05 <Lutin`> Infinite fizzbuzz!
10:34:06 <dmwit> $join[n|...] = [m|...,m<-n] -- doesn't change the character count, though
10:34:29 <Lutin`> I changed from concat to join
10:34:31 <qrada> is there an FRP channel?
10:35:11 <dmwit> ah, but!
10:35:14 <dmwit> if you do that transformation
10:35:21 <dmwit> you can swap the argument order to max and use $ instead of ()
10:35:34 <pavonia> > [show x`max`join[n|(f,n)<-[(3,"Fizz"),(5,"Buzz")],mod x f<1]|x<-[1..]]
10:35:35 <lambdabot>  ["1","2","Fizz","4","Buzz","Fizz","7","8","Fizz","Buzz","11","Fizz","13","14...
10:35:41 <phil> benzrf: am i trying to do that?  i think i'm getting sth wrong here..   snd . head . filter funct $ xs is the same as snd(head(filter(func,xs))) right ?
10:35:50 <Sculptor> fizz buzz scheme repeats after 15 lines
10:36:35 <dmwit> > [max[m|(f,n)<-[(3,"Fizz"),(5,"Buzz")],mod x f<1,m<-n]$show x|x<-[1..]]
10:36:37 <lambdabot>  ["1","2","Fizz","4","Buzz","Fizz","7","8","Fizz","Buzz","11","Fizz","13","14...
10:37:24 <corgifex> phil: no
10:37:48 <corgifex> snd (head (filter funct xs))
10:38:09 <corgifex> via (snd . head . filter funct) $ xs
10:38:25 <benzrf> phil: i think you are confused
10:38:32 <benzrf> foo(bar, baz) is NOT the same as foo bar baz
10:38:41 <benzrf> the former is calling foo with 1 arg that is a tuple
10:38:53 <Lutin`> :t filter
10:38:54 <lambdabot> (a -> Bool) -> [a] -> [a]
10:39:13 <Lutin`> You can read that as (a -> Bool) -> ([a] -> [a])
10:39:25 <yitz> > [["FzBz","Fz","Bz",show n]!!(y*2`mod`3+y`mod`5)|n<-[1..],let y=n^4]
10:39:27 <lambdabot>  ["1","2","Fz","4","Bz","Fz","7","8","Fz","Bz","11","Fz","13","14","FzBz","16...
10:39:35 <phil> okay that makes sence
10:39:42 <benzrf> yitz: you left out the i and u
10:40:00 <benzrf> is this prelude-only?
10:40:04 <yitz> benzrf: to avoid truncation before 15
10:40:08 <yitz> yes
10:40:29 <Lutin`> but with the vowels it's longer
10:40:44 <benzrf> then why have a z
10:40:47 <benzrf> just use F and B
10:40:56 * hackagebot quickcheck-property-monad 0.2.2 - quickcheck-property-monad  http://hackage.haskell.org/package/quickcheck-property-monad-0.2.2 (BennoFuenfstueck)
10:41:00 <Lutin`> and imo less generalizable
10:41:10 <yitz> Lutin`: yes, 8 characters longer
10:41:17 <Lutin`> > [show x`max`join[n|(f,n)<-[(3,"Fizz"),(5,"Buzz"),(7,"Baz")],mod x f<1]|x<-[1..]]
10:41:19 <lambdabot>  ["1","2","Fizz","4","Buzz","Fizz","Baz","8","Fizz","Buzz","11","Fizz","13","...
10:41:29 <yitz> Lutin`: (including the extra z's that were also omitted)
10:41:34 <benzrf> [(3,"Fizz"),(5,"Buzz"),(7,"Baz")]
10:41:50 <benzrf> zip[3,5,7]["Fizz","Buzz","Baz"]
10:41:59 <Lutin`> Oho!
10:42:05 <yitz> if we're golfing, it's shorter without the let
10:42:36 <dmwit> > length "[show x`max`join[n|(f,n)<-[(3,\"Fizz\"),(5,\"Buzz\"),(7,\"Baz\")],mod x f<1]|x<-[1..]]"
10:42:37 <lambdabot>  80
10:42:41 <benzrf> if we had ruby-style words literals
10:42:54 <yitz> > [["FizzBuzz","Fizz","Buzz",show n]!!(n^4*2`mod`3+n^4`mod`5)|n<-[1..]]
10:42:55 <benzrf> zip[3,5,7]%w[Fizz Buzz Baz]
10:42:56 <lambdabot>  ["1","2","Fizz","4","Buzz","Fizz","7","8","Fizz","Buzz","11","Fizz","13","14...
10:42:56 <phil> benzrf: if i don't use $ it trys to pass xs as the parameter to func and not as "second" paraneter to filter, is that the problem ?
10:43:03 <dmwit> > length "[max[m|(f,n)<-[(3,\"Fizz\"),(5,\"Buzz\"),(7,\"Baz\")],mod x f<1,m<-n]$show x|x<-[1..]]"
10:43:03 <benzrf> phil: huh?
10:43:04 <lambdabot>  80
10:43:26 <corgifex> phil: no, the filter func xs part is fine.
10:44:16 <Ch0c0late> :t getContents
10:44:17 <lambdabot> IO String
10:44:42 <phil> corgifex: http://lpaste.net/106069  well the first one is fine, the second one doesn't compile at all
10:45:00 <yitz> > length "[[\"FizzBuzz\",\"Fizz\",\"Buzz\",show n]!!(n^4*2`mod`3+n^4`mod`5)|n<-[1..]]"
10:45:01 <lambdabot>  69
10:45:05 <corgifex> phil: yes, I know
10:45:14 <Lutin`> I like
10:45:14 <dmwit> > length "[show x`max`join[n|(f,n)<-[(3,\"Fizz\"),(5,\"Buzz\")],mod x f<1]|x<-[1..]]"
10:45:16 <lambdabot>  70
10:45:40 <phil> corgifex: so how could it be right ?
10:46:06 <corgifex> phil: what is "it" in your question?
10:47:03 <phil> corgifex: you wrote the filter func xs part is fine. so how could that be fine if it doesn't compile?
10:47:17 <bibu> Hi, I'm using hdevtools in vim, and it cannot find a dependency, but ghc compiles the module fine
10:47:20 <corgifex> phil: because the rest of the code is wrong
10:47:30 <bibu> What am I doing wrong?
10:47:39 <corgifex> phil: your code is more than just filter func xs
10:48:12 <Lutin`> phil: function application has higher precedence than function composition
10:49:40 <Lutin`> snd . head . filter func $ xs is equivalent to (snd . head . (filter func)) xs
10:49:40 <phil> corgifex: jeahr but why do i need function application ? filter takes a function and a list... func is the function and xs the list ..i don't see whats the problem
10:49:57 <corgifex> phil: filter func xs is fine
10:50:02 <corgifex> there is no problem there
10:50:12 <Lutin`> snd . head . filter func xs is equivalent to snd . head . (filter func xs)
10:50:16 <corgifex> I can repeat that until you believe me
10:50:17 <Lutin`> They are not the same
10:50:35 <Zekka> Anyone know how to express (<$>) for (->) pointfree in terms of const and (<*>)? I get as far as (<$>) = ((<*>) <$> const) , but that's obviously circular
10:50:48 <Lutin`> :t filter True []
10:50:49 <benzrf> Zekka: uh
10:50:50 <lambdabot>     Couldn't match expected type ‘a -> Bool’ with actual type ‘Bool’
10:50:50 <lambdabot>     In the first argument of ‘filter’, namely ‘True’
10:50:50 <lambdabot>     In the expression: filter True []
10:50:51 <Zekka> (<$>) f = ((<*>) const f) isn't circular but thatincludes a lambda expression
10:50:53 <benzrf> (<$>) is fmap
10:50:54 <Lutin`> woops
10:50:57 * hackagebot hopenpgp-tools 0.7.1 - hOpenPGP-based command-line tools  http://hackage.haskell.org/package/hopenpgp-tools-0.7.1 (ClintAdams)
10:50:57 <Zekka> benzrf: I know
10:51:05 <benzrf> and it does not include a lambda
10:51:06 <pjdelport> phil: I annotated your paste.
10:51:13 <benzrf> o i see what you mean
10:51:16 <Zekka> Context is that I was showing him how pure/(<*>) for functions are equivalent to K/S
10:51:51 <pjdelport> phil: http://lpaste.net/106069 Do you see the difference in how the two versions parse?
10:51:57 <benzrf> well
10:52:09 <Zekka> so I was trying to show off the Applicative instance for functions and realized there didn't seem to be a terribly neat way of defining (<$>) for the reason I described
10:52:26 <benzrf> fmap in terms of (<*>) is
10:52:36 <benzrf> fmap f g = pure f <*> g
10:52:40 <corgifex> <$> = \f x -> const f <*> x
10:52:46 <Zekka> benzrf: Right, I get that, and simplified from there
10:52:50 <phil> pjdelport: yes i see it, and for some reason the second ,which doesn't compile looks right to me o.O?
10:52:54 <pjdelport> phil: In the first version, you're passing xs to the *entire* pipeline on the left. In the second, you're passing it only to filter, not the rest (which is an error).
10:52:55 <Zekka> corgifex: I stipulated pointfree intentionally
10:52:55 <benzrf> fmap f g = const f <*> g
10:52:57 <corgifex> <$> = \f -> (<*>) (const f)
10:53:11 <Zekka> I'm trying to express it purely using S K and I, without introducing extra lambda expressions
10:53:23 <benzrf> i dont think S has a name in haskell
10:53:24 <Zekka> You're covering the same ground I covered
10:53:25 <corgifex> <$> = (<*>) (pure <*>) const
10:53:33 <Zekka> benzrf: Yes it does, it's (<*>) for functions
10:53:37 <Zekka> @src (->) (<*>)
10:53:37 <lambdabot> (<*>) f g x = f x (g x)
10:53:38 <benzrf> oic
10:53:52 <corgifex> :t (<*>) (const (<*>)) const
10:53:53 <lambdabot> (a -> b) -> (b1 -> a) -> b1 -> b
10:54:02 <corgifex> \o/
10:54:02 <pjdelport> phil: Why does it look right to you? The error in the second example is not with filter, it's with the "." compositions.
10:54:06 <Zekka> corgifex: Oh, good one!
10:54:17 <Lutin`> :t (.)
10:54:18 <lambdabot> (b -> c) -> (a -> b) -> a -> c
10:54:24 <benzrf> corgifex: ew
10:54:39 <corgifex> :t ap (const ap) const
10:54:40 <lambdabot> (a -> b) -> (b1 -> a) -> b1 -> b
10:55:49 <phil> pjdelport:aaaaaaahhh .. :) i think i'm beginning to understand
10:56:42 <pjdelport> phil: In the first version, (snd . head .  filter (\(k,v) -> k == key)) is an entire compound function, composed of smaller functions and (.)
10:57:25 <benzrf> @. djinn ty (.)
10:57:25 <lambdabot> Plugin `compose' failed with: Unknown command: "ty"
10:57:30 <benzrf> @. djinn type (.)
10:57:32 <lambdabot> f a b c = a (b c)
10:57:38 <benzrf> @pl f a b c = a (b c)
10:57:38 <lambdabot> f = (.)
10:57:42 <benzrf> bad lambdabot!
10:57:47 <pjdelport> phil: Whatever you call it with (xs in this case) gets passed through (filter (\(k,v) -> k == key)), then (head), then (snd).
10:57:57 <yitz> @slap lambdabot
10:57:57 * lambdabot pushes lambdabot from his chair
10:58:27 * benzrf beats lambdabot to death with his own implementation in unlambda
10:58:33 <yitz> oh noes a gender-specific @slap response. who's in charge of lambdabot these days?
10:58:35 <Lutin`> phil: head . filter func xs is like saying benzrf but lambdabot is right..
10:58:39 <Lutin`> whoops
10:58:50 <Lutin`> benzrf: but lambdabot is right..
10:58:51 <benzrf> hmph
10:59:00 <Zekka> benzrf: Be honest, that's a pretty good definition
10:59:03 <benzrf> :p
10:59:05 <pjdelport> phil: It's a common idiom in Haskell to build function "pipelines" like that, by saying: foo . bar . baz $ x
10:59:21 <pjdelport> phil: Which is equivalent to (foo (bar (baz x)))
10:59:29 <benzrf> MY bot triggers on '* somebody [NO SPACES HERE]s [BOT'S NICK][MORE TEXT]'
10:59:32 <yitz> we wouldn't want women in this channel to feel that they are being excluded from being pushed off their chair
10:59:41 <benzrf> i.e.
10:59:41 <corgifex> @let data Lam = Var String | App Lam Lam | Abs String Lam deriving (Eq, Ord, Read, Show)
10:59:45 <lambdabot>  Defined.
10:59:48 <benzrf> 01:59  * benzrf pushes bROBOT off a ledge
10:59:48 <benzrf> 01:59  * bROBOT pushes benzrf off a ledge
10:59:50 <phil> pjdelport: so i have to partial apply all the functions in a composition ?
11:00:17 <pjdelport> phil: Not necessarily. They just have to be functions to begin with. :)
11:00:39 <benzrf> :t reduce
11:00:40 <lambdabot> Expr -> Expr
11:00:42 <benzrf> heuh
11:00:45 <benzrf> > reduce f
11:00:48 <lambdabot>  f
11:00:50 <benzrf> > reduce (f a)
11:00:52 <pjdelport> phil: The problem with the second version is that (filter (\(k,v) -> k == key) xs) is not a function; it's a list. (that is, it's the result of filter)
11:00:52 <lambdabot>  f a
11:01:26 <pjdelport> phil: So you can't use (.) with it.
11:01:32 <Lutin`> > reduce (f (g a))
11:01:34 <lambdabot>  No instance for (GHC.Show.Show t0)
11:01:34 <lambdabot>    arising from a use of ‘Debug.SimpleReflect.Vars.f’
11:01:34 <lambdabot>  The type variable ‘t0’ is ambiguous
11:01:34 <lambdabot>  Note: there are several potential instances:
11:01:34 <lambdabot>    instance [safe] GHC.Show.Show
11:01:42 <Lutin`> woops
11:01:55 <yitz> > reduce ((f * f - 1) `div` (f + 1))
11:01:56 <pjdelport> phil: You *can* say: (snd (head (filter (\(k,v) -> k == key) xs)))
11:01:57 <lambdabot>  (f * f - 1) `div` (f + 1)
11:02:17 <pjdelport> phil: Note that there are no . compositions in there any more: it's just plain application.
11:02:49 <phil> pjdelport: aaah ok... so if my last function in the composition takes 2 parameter and the last one is no function i just partial apply it and pass that last parameter to the entire pipeline?
11:02:51 <pjdelport> phil: But also note how much harder it is to read than: snd . head . filter (\(k,v) -> k == key) $ xs
11:03:24 <Lutin`> @src reduce
11:03:24 <lambdabot> reduce _ 0 = undefined
11:03:24 <lambdabot> reduce x y = (x `quot` d) :% (y `quot` d)
11:03:24 <lambdabot>     where d = gcd x y
11:03:34 <Kanisterschleife> hi
11:04:32 <Lutin`> Wrong reduce
11:05:42 <benzrf> @let reduceLam v@(Var _) = v; reduceLam a@(Abs _ _) = a; reduceLam (App (Abs p b) a) = reduceLam (subst p a b)
11:05:43 <lambdabot>  .L.hs:164:42:
11:05:43 <lambdabot>      Couldn't match expected type ‘Lam’ with actual type ‘Sym a0’
11:05:43 <lambdabot>      In the first argument of ‘reduceLam’, namely ‘(subst p a b)’
11:05:43 <lambdabot>      In the expression: reduceLam (subst p a b)
11:05:43 <lambdabot>  
11:05:45 <benzrf> oh wait
11:05:47 <benzrf> :t subsg
11:05:48 <benzrf> :t subst
11:05:49 <lambdabot>     Not in scope: ‘subsg’
11:05:49 <lambdabot>     Perhaps you meant ‘subst’ (imported from Data.Number.Symbolic)
11:05:50 <lambdabot> (Num a, Eq a) => String -> Sym a -> Sym a -> Sym a
11:05:52 <benzrf> lame!
11:05:55 <corgifex> > let delam (Var x) = x; delam (App a b) = App (delam a) (delam b); delam (Abs v t) = elim v (delam t); elim v (Var x) = Var (if v == x then "I" else x); elim v (App a b) = App (App (Var "S") (elim v a)) (elim v b) in delam $ App (Abs "x" (Var "x")) (Var "x")
11:05:56 <lambdabot>  Couldn't match type ‘L.Lam’ with ‘[GHC.Types.Char]’
11:05:56 <lambdabot>  Expected type: GHC.Base.String
11:05:56 <lambdabot>    Actual type: L.LamCouldn't match type ‘[GHC.Types.Char]’ with ‘L.Lam’
11:05:57 <lambdabot>  Expected type: L.Lam
11:05:59 <lambdabot>    Actual type: GHC.Base.StringCouldn't match type ‘[GHC.Types.Char]’ with ‘L...
11:06:06 <corgifex> my emperor
11:07:17 <Lutin`> benzrf: Ah reduce is just for numbers
11:08:05 <Lutin`> https://github.com/jwiegley/lambdabot-1/blob/master/show/SimpleReflect.hs
11:08:53 <simpson> Hey! Does anybody who has worked with Wadler's prettier printer (or any similar library with the same sort of API) have a good solution for pretty-printing languages that require braces but only when not indented?
11:09:01 <simpson> e.g. pretty-printing Haskell or E.
11:09:01 <benzrf> @let substLam s d (Var v)  d; substLam s d (App f a) = App (substLam s d f) (substLam s d a); substLam s d (Abs a b) | s == a = Abs a b | otherwise = Abs a (substLam s d b)
11:09:01 <lambdabot>  Parse failed: TemplateHaskell is not enabled
11:09:04 <benzrf> oops
11:09:20 <benzrf> @let substLam s d (Var v) | s == v = d | otherwise = Var v; substLam s d (App f a) = App (substLam s d f) (substLam s d a); substLam s d (Abs a b) | s == a = Abs a b | otherwise = Abs a (substLam s d b)
11:09:22 <lambdabot>  Defined.
11:09:25 <third3ye> McFarlane? John McFarlane? Creator of gitit? Ping?
11:09:58 <corgifex> @let delam (Var x) = Var x; delam (App a b) = App (delam a) (delam b); delam (Abs v t) = elim v (delam t); elim v (Var x) | v == x = Var "I" | otherwise = App (Var "K") (Var x); elim v (App a b) = App (App (Var "S") (elim v a)) (elim v b)
11:10:00 <lambdabot>  Defined.
11:10:19 <benzrf> > substLam "x" (Var "y") (App (Var "x") (Abs "x" (Var "x")))
11:10:21 <lambdabot>  App (Var "y") (Abs "x" (Var "x"))
11:10:27 <benzrf> coo
11:10:33 <benzrf> @let reduceLam v@(Var _) = v; reduceLam a@(Abs _ _) = a; reduceLam (App (Abs p b) a) = reduceLam (substLam p a b)
11:10:35 <lambdabot>  Defined.
11:10:41 <benzrf> hows that
11:10:59 * hackagebot hcltest 0.3.2 - A testing library for command line applications.  http://hackage.haskell.org/package/hcltest-0.3.2 (BennoFuenfstueck)
11:11:44 <corgifex> > Abs "f" (Abs "g" (Abs "x" (App (Var "f") (App (Var "g") (Var "x")))))
11:11:47 <lambdabot>  Abs "f" (Abs "g" (Abs "x" (App (Var "f") (App (Var "g") (Var "x")))))
11:11:53 <corgifex> > delam $ Abs "f" (Abs "g" (Abs "x" (App (Var "f") (App (Var "g") (Var "x")))))
11:11:54 <lambdabot>  App (App (Var "S") (App (App (Var "S") (App (Var "K") (Var "S"))) (App (App ...
11:12:06 <benzrf> > reduceLam (App (Abs "x" (Var "x")) (Var "y"))
11:12:08 <lambdabot>  Var "y"
11:12:35 <benzrf> > reduceLam (App (Abs "x" (App (Var "x") (Var "x"))) (Abs "x" (App (Var "x") (Var "x"))) )
11:12:39 <lambdabot>  mueval-core: Time limit exceeded
11:12:42 <benzrf> i dont know what i expected
11:12:49 <benzrf> > delam (App (Abs "x" (App (Var "x") (Var "x"))) (Abs "x" (App (Var "x") (Var "x"))) )
11:12:51 <lambdabot>  App (App (App (Var "S") (Var "I")) (Var "I")) (App (App (Var "S") (Var "I"))...
11:12:58 <benzrf> what
11:13:03 <benzrf> oh i see
11:13:06 <benzrf> coool
11:14:43 <BluePeppers> Hullo, trying to write a Setup.hs to deal with some protobuf files. How can I add a source directory to the Distribution.Simple.LocalBuildInfo? Or is that even possible?
11:14:44 <corgifex> > let shrink (Var v) = v; shrink (App a b) = "(" ++ shrink a ++ ")(" ++ shrink b ++ ")"; shrink (Abs v t) = "\\" ++ v ++ "." ++ shrink t in text . shrink . delam $ Abs "f" (Abs "g" (Abs "x" (App (Var "f") (App (Var "g") (Var "x")))))
11:14:46 <lambdabot>  ((S)(((S)((K)(S)))(((S)(((S)((K)(S)))(((S)((K)(K)))((K)(S)))))(((S)(((S)((K)...
11:14:53 <corgifex> well, that's not crazy at all
11:14:53 <third3ye> Call for John McFarlane, creator of gitit, have a question or two... for instance: how does one go about making user registrations recognise ssh auth keys? Is there an implementation for this at all?
11:15:11 <Kanisterschleife> I am trying to learn about the encoding of recursive algebraic data types given the functionality of parametric polymorphism in the exampl of rooted binary trees. You can see my code so far on http://pastebin.com/8wUnhjDS -- unfortunately, the function application "x initial_module" at the end gives a type error I cannot fix. Can somebody help?
11:15:22 * third3ye flips and tosses a sign stating "Johny McFarlane" up and down
11:15:34 <benzrf> *Johnny?
11:15:40 <third3ye> Gold4cash...! I mean; McFarlane...!
11:16:13 <third3ye> benzrf: https://github.com/jgm
11:16:48 <Kanisterschleife> I would like to explicitly specialize the type parameter z in x :: BT a == forall z. ((BTAlg a z) -> z) -> z to BT a, but I don't know how to do this.
11:18:40 <Smilex> http://lpaste.net/106076 <- How could I make such a type, with careless Ptrs like that? With that I get "a undefined"
11:18:53 <benzrf> Kanisterschleife: i dont know the context but im going to hazard that you may need ExistentialQuantification and/or RankNTypes
11:19:31 <corgifex> Smilex: in general, you don't
11:19:36 <corgifex> what's your use case?
11:20:11 <Smilex> corgifex: It's the type of a foreign (C) FunPtr. That Ptr is for a C struct
11:20:38 <corgifex> so why not use a more specific type?
11:20:42 <Kanisterschleife> benzrf: I already use RankNTypes and ImpredicativeTypes
11:20:55 <Smilex> corgifex: I don't know what the type would be?
11:21:19 <benzrf> Kanisterschleife: do you use ExistentialQuantification
11:21:46 <corgifex> o_O
11:23:04 <Kanisterschleife> benzrf: yes
11:28:39 <Smilex> corgifex: how would Haskell know about C structs? I don't want to use things like c2hs
11:29:59 <Dtgr> Smilex: you can of course type by hand the stuff that c2hs generates for you
11:30:44 <joelteon> can't you just use .hsc for that?
11:31:02 * hackagebot tpdb 0.9.8 - Data Type for Rewriting Systems  http://hackage.haskell.org/package/tpdb-0.9.8 (JohannesWaldmann)
11:31:36 <Lutin`> Smilex: Maybe http://therning.org/magnus/archives/315 would help
11:32:16 <Smilex> Dtgr: Well I decided to go for a getter/setter approach
11:32:39 <Smilex> so that Haskell never really needs to know the internals of the C lib
11:35:35 <Smilex> Lutin`: Thanks, but my idea was to abstract away the C stuff from the scripting as much as possible.
11:35:54 <Smilex> I might be shooting myself in the foot with this approach, but so far it's worked quite well
11:39:26 <Lutin`> Yeah I just don't see a good reason to totally ignore the internals of the C lib
11:39:50 <Lutin`> If you don't want to get in too deep you could at least have some sort of exchange struct
11:42:31 <Ch0c0late> How to get content of input line by line and then send them to a function and then print them out? main = do; n <- readLn :: IO Int; input <- getContents
11:42:38 <luite> is there a way to tell a command like "cabal install ./a ./b" to only use already installed dependencies for everything, fail if any dep is not yet installed?
11:43:02 <Lutin`> Smilex: Do you not want a Haskell data type to represent the C struct?
11:43:52 <Ch0c0late> Let's say we have a function a l = [x | x <- l].
11:44:20 <Ch0c0late> Dunno what's the problem of this piece of code? putStrLn $ show $ rotate $ map read $ lines inputdata
11:44:36 <Ch0c0late> Dunno what's the problem of this piece of code? putStrLn $ show $ a $ map read $ lines inputdata
11:45:10 <BluePeppers> Ch0c0late, is inputdata IO String or String? you might need to lift the whole thing prior to application
11:45:39 <Smilex> Lutin`: No, I just want a Haskell type that can use a Ptr (a)
11:45:53 <Geraldus> Hey friends. I’m confused a bit. I want to build GHC 7.8.2 on my debian 7, I have GHC 7.6.3 for now. I can figure out what should I download from GHC download page? Should I select source distibution not binaries, right? )
11:45:56 <Ch0c0late> BluePeppers: Yes. It's string. Assume reading it from stdin.
11:46:17 <Geraldus> * i can’t  figure out
11:46:39 <tulcod> Smilex: the haskell equivalent of void* is Ptr ()
11:46:53 <Smilex> tulcod: ah
11:46:56 <Smilex> thanks
11:47:13 <tulcod> Smilex: but if the C type has a richer type, you really should ask yourself if you want to use that instead
11:48:18 <Smilex> tulcod: Yeah, I went with a name_get_member() approach.
11:48:47 <Lutin`> Ch0c0late: Is each line in the input the same type?
11:48:57 <Ch0c0late> Yup.
11:49:21 <tulcod> Smilex: haskell can deal with function pointers. and FFI is fundamentally about C internals, so htere's no way around dealing with bits - the best way to deal with it is to make some other library (e.g. c2hs) do it for you
11:50:43 <tulcod> Smilex: by the way, it's not much harder to deal with pointers to struct than with pointers to void
11:50:49 <Smilex> tulcod: Well I'm a bit worried about other languages maybe not having such functionality
11:50:56 <Lutin`> Ch0c0late: Well for one putStrLn . show = print
11:51:11 <tulcod> Smilex: what do you mean?
11:51:39 <Smilex> tulcod: It currently works without c2hs, I just wanted a convenience type and wasn't sure how to do it
11:51:52 <tulcod> why don't you want to use c2hs?
11:52:53 <Smilex> tulcod: Well my C library currently exposes all relevant members of structs with getter and setter functions, just because I didn't want to rely on the existence of software that can do C to other language bindings
11:53:26 <tulcod> if you are dealing with a language that can't bind to C structures, you should not be binding to C at all
11:53:38 <Lutin`> Ch0c0late: The issue is that read doesn't know what type to read
11:53:50 <Ch0c0late> Ah!
11:53:59 <geekosaur> if you don't need to actually access the structure but just work with opaque pointers, you could use Ptr () or (for better typing) define your own types (e.g. data SomeOpaquePointer = SomeOpaquePointer) and use those
11:54:27 <tulcod> geekosaur: newtype MyStruct = Mystruct (Ptr Mystruct) seems to be popular
11:54:28 <Smilex> tulcod: that's quite the statement. If the language can pass around pointer addresses, then currently it can use the library
11:54:46 <tulcod> geekosaur: gives you access to the underlying pointer address, for better or worse
11:54:52 <derekv> a little surprised that head is not [a] -> Maybe a
11:55:23 <dwcook> derekv: head should generally be avoided for basically that reason. Try pattern matching instead.
11:55:36 <tulcod> derekv: https://hackage.haskell.org/package/safe-0.3.4/docs/Safe.html
11:56:17 <derekv> dwcook: ah yea, should have thought of that
11:56:23 <derekv> tulcod: thanks for link
11:56:45 <derekv> actually head is less surprising then tail
11:57:15 <tulcod> Smilex: what languages are you hoping will  bind to your C library?
11:57:21 <Lutin`> derekv: Why's that?
11:57:32 <derekv> because tail [] = [] is typical in other languages and shouldn't be less surprising than an error
11:57:44 <xeno_> how can I get this to work: https://github.com/jankroken/scl/blob/master/haskell/parser.hs ? - I'm getting "Couldn't match expected type `IO (IO b0)' with actual type `str0 ->  Either ParseError [Char]'" - I'm a n00b, so could you tell me what goes on?
11:57:46 <dwcook> derekv: drop 1 behaves that way.
11:57:47 <Smilex> tulcod: I'm currently experimenting with Haskell, but as many as possible really
11:57:54 <tulcod> derekv: if tail [] = [], then what is length []  ?
11:57:55 <rien> derekv: if that were the case, recursion would never stop in haskell.
11:58:02 <dwcook> > map (drop 1) [[], [a], [a, b]]
11:58:03 <lambdabot>  [[],[],[b]]
11:58:05 <Smilex> Would help a lot when I want to test a new language
11:58:39 <tulcod> Smilex: i don't know of any language that can bind to C pointers and call C functions, but cannot access C structs
11:58:55 <pavonia> xeno_: return result
11:58:57 <tulcod> Smilex: and again, if it can't, maybe you shouldn't be binding that language
11:59:08 <derekv> > length []
11:59:10 <lambdabot>  0
11:59:16 <tulcod> Smilex: third, i don't think the success of your library will depend on how many languages can bind to it
11:59:49 <derekv> rien: I don't see how throwing an error helps, you still need to put in your base case
12:00:06 <rien> derekv: I agree that throwing an error is not the best thing to do. :)
12:00:08 <Smilex> tulcod: It's not really supposed to be a successful language. I'd just hope that I could hear about some programming language, make some bindings and then experiment with it that way, rather than from nothing
12:00:11 <xeno_> pavonia: that was not enough, now I get ouldn't match expected type `IO b0' with actual type `str0 -> Either ParseError [Char]'
12:00:52 <pavonia> xeno_: Yes, parseString doesn't return an IO action
12:01:00 <Smilex> tulcod: But yeah, I'm not so sure I went the correct way about it. I'll most likely just use c2hs, thanks!
12:01:19 <xeno_> pavonia: yeah, I got it now...
12:01:23 <zq> is there a cabal shell yet?
12:01:26 <zq> what's the hold up man
12:01:27 <pavonia> xeno_: What is getContents supposed to do there?
12:01:30 <zq> cabal sandbox shell*
12:01:36 <educated_idiot> is it possible to learn and apply Category Theory (esp. to API design) without knowing abstract algebra (group theory for instance)?
12:01:46 <xeno_> pavonia: get the parse result, it's Either a parse error or a string
12:02:08 <xeno_> I just dropped result <- and replaced that with a direct return
12:02:09 <tulcod> educated_idiot: yes. but many areas of math give context for it which can be very helpful
12:02:10 <xeno_> worked ok
12:02:15 <pavonia> :t getContents
12:02:17 <lambdabot> IO String
12:02:23 <tulcod> educated_idiot: algebra, topology, logic, set theory, they all help
12:02:58 <dwcook> xeno_: Are you aware how do syntax desugars?
12:03:24 <dwcook> xeno_: The translation box here describes it http://www.haskell.org/onlinereport/haskell2010/haskellch3.html#x8-470003.14
12:03:26 <educated_idiot> tulcod: thanks, I've heard that CT is a generalization of parts of abstract alg.
12:03:41 <zq> oh okay never mind
12:03:43 <dwcook> That should give you a better intuition of how to write do expressions if you understand the translation
12:03:47 <tulcod> educated_idiot: that's one of the things it is, yes
12:04:14 <tulcod> educated_idiot: i was taught that category theory is the linguistics of mathematics. but applications in computer science don't really fit in that point of view
12:06:05 * hackagebot nanomsg-haskell 0.2.2 - Bindings to the nanomsg library  http://hackage.haskell.org/package/nanomsg-haskell-0.2.2 (IvarNymoen)
12:10:24 <Smilex> Is either of c2hs or hsc2hs better than the other? Mostly in terms of documentation
12:14:11 <tulcod> Smilex: i think most people use c2hs. for most purposes, it's more advanced, but hsc2hs can do some minute things c2hs can't (and probably vice versa)
12:14:12 <maximum_yellow> Hey guys, so I'm looking at Graphics.X11.Xlib.Misc and I can't help but think that the type signature is off. In particular, it has ButtonMask in place of KeyMask, I suspect
12:14:19 <tulcod> Smilex: i'd guess you'll want to use c2hs.
12:14:29 <Smilex> tulcod: ok thanks
12:14:40 <maximum_yellow> erm, of grabKey that is
12:16:26 <rudi_s> Hi. I'm new to haskell and want to parse a number (as String) and convert it to a Maybe Int so I can catch invalid input. How can I do this? I found readMaybe, but that's not available in my older ghc version. Thanks.
12:17:16 <geekosaur> maximum_yellow, you could file a bug report against it but I think it's only cosmetic --- both are actually Word32
12:17:39 <zwer> rudi_s use reads or readMay from safe package
12:17:51 <maximum_yellow> geekosaur: right, yeah, I suspect as much.
12:18:02 <maximum_yellow> gah, suspected.
12:18:06 <rudi_s> zwer: safe package?
12:18:33 <zwer> http://hackage.haskell.org/package/safe
12:21:06 <rudi_s> zwer: Perfect, thank you.
12:22:21 <rudi_s> Btw. is there a command line tool (if possible for offline use) which helps me to find functions? When I read code I often stumble over functions and have difficulties finding them.
12:22:36 <xeno_> dwcook: I'm partially aware, but I don't have it in my head - gonna check the link - thanks :)
12:23:34 <tulcod> rudi_s: hoogle has an offline variant i think
12:23:42 <tulcod> but that's definitely the tool you want to use - online or offline
12:24:28 <rudi_s> tulcod: Thanks. I'll look into hoogle.
12:24:30 <staley070> I am getting this error when trying to cabal install plugins: "src\System\Plugins\Consts.hs:39:23: lexical error in string/character literal at character 'P' Failed to install plugins-1.5.4.0"
12:24:38 <staley070> what can I do?
12:25:29 <rudi_s> Can ghci display function documentation?
12:26:25 <geekosaur> rudi_s: not out of the box. see http://www.haskell.org/haskellwiki/GHC/GHCi#GHCi_on_Acid
12:26:41 <geekosaur> although that may not build nicely at this point
12:26:44 <staley070> I found question being asked about this in 2012.. so there is a broken version of plugins on hackage since then?
12:27:00 <ryantm> I am trying to go through John Hughes paper http://www.cse.chalmers.se/~rjmh/afp-arrows.pdf but when I write printFile = readFile >>> print, GHC has a compiler error compiling this https://gist.github.com/ryantm/e0a94ebcc2e89bbc4add : "No instance for (Show (IO String)) arising from a use of print" is >>> in Control.Arrow defined differently from how it is in that paper?
12:27:33 <geekosaur> I'm not sure plugins is currently maintained
12:27:34 <rudi_s> geekosaur: Thanks, will have a look.
12:27:50 <tulcod> ryantm: maybe you watn to use putStrLn instead?
12:28:19 <tulcod> ryantm: (print = putStrLn . show   i think)
12:28:29 <geekosaur> ryantm, does it actually say print? and it doesn't provide its own?
12:28:35 <geekosaur> (because what tulcod said)
12:29:41 <ryantm> I updated the gist to show the full compiler error https://gist.github.com/ryantm/e0a94ebcc2e89bbc4add
12:30:32 <geekosaur> yes
12:30:36 <geekosaur> as we just told you
12:31:00 <rgrinberg> how would I implement a simply tcp server in io streams? I see http://hackage.haskell.org/package/io-streams-1.1.4.6/docs/System-IO-Streams-Network.html but don't i need to call accept on a socket and get a handle first?
12:31:07 * hackagebot paymill 0.0.0 - This is an unofficial client for the Paymill API  http://hackage.haskell.org/package/paymill-0.0.0 (darthdeus)
12:31:25 <geekosaur> mm, I think that is a typo since the paper talks about the print that actually exists
12:31:36 <geekosaur> and uses it
12:31:50 <geekosaur> it should be using putStr
12:31:58 <geekosaur> (here)
12:32:21 <geekosaur> the next usage, on the other hand, wants to print a number and is correct
12:32:34 <geekosaur> btu this should be readFile >>> putStr
12:33:07 <ryantm> Is there a bot in this channel that can evaluate that? That still doesn't work for me, I can post it in a gist.
12:34:04 <ryantm> https://gist.github.com/ryantm/50e07bd69cb248d0a65b
12:34:49 <geekosaur> bots here won't do IO
12:34:53 <vanila>  Couldn't match type ‘IO String’ with ‘[Char]’
12:35:07 <geekosaur> hm, that makes sense
12:35:19 <geekosaur> so I wonder what he was trying to say there
12:35:20 <vanila> you should use >>=
12:35:23 <geekosaur> yeh
12:35:25 <vanila> :t readFile >>= putStr
12:35:26 <lambdabot>     Couldn't match expected type ‘IO String’
12:35:26 <lambdabot>                 with actual type ‘FilePath -> IO String’
12:35:26 <lambdabot>     Probable cause: ‘readFile’ is applied to too few arguments
12:35:27 <heatsink> :t (>>>)
12:35:28 <lambdabot> Category cat => cat a b -> cat b c -> cat a c
12:35:29 <geekosaur> but the paper is about arrows
12:35:32 <vanila> lol I failed
12:35:36 <vanila> sorry
12:35:45 <vanila> :t \name -> readFile name >>= putStr
12:35:47 <heatsink> :t readFile >=> putStr
12:35:47 <lambdabot> FilePath -> IO ()
12:35:48 <lambdabot> FilePath -> IO ()
12:35:54 <geekosaur> maybe the line isn't intended to be anything but an example
12:36:07 * hackagebot haskell-token-utils 0.0.0.1 - Utilities to tie up tokens to an AST  http://hackage.haskell.org/package/haskell-token-utils-0.0.0.1 (AlanZimmerman)
12:36:13 <pavonia> :t (>=>)
12:36:15 <lambdabot> Monad m => (a -> m b) -> (b -> m c) -> a -> m c
12:36:42 <heatsink> :t (.)
12:36:43 <lambdabot> (b -> c) -> (a -> b) -> a -> c
12:42:20 <Martty> what would be a good channel to ask about correctness of concurrent programs? (using basic ipcs and pseudocode)
12:44:25 <heatsink> Are you interested in proving correctness, or making code that's likely to work as intended?
12:45:01 <Martty> heatsink: ive code but im not sure if its correct
12:45:36 <tulcod> i am processing a small xml file and need to extract different (but related) kind of output for different stages of my program. i think it would be prettiest if i write one function to process the xml, but I can only imagine outputting a very complicated datatype. are arrows a neat solution for this? (since I don't know them yet)
12:45:46 <heatsink> If you're not trying to prove anything, it's a programming topic that you can ask about in the channel for that programming language
12:45:57 <heatsink> Proofs are more in the realm of CS theory
12:46:30 <Martty> ah.. the problem is that its independent of the language.. and those channels usually focus on the language itself, not algorithms let alone using the OS' concurrency mechanisms
12:46:41 <platz> is kmett's reducers library the same in spirit as Clojure's reducers?
12:47:00 <platz> envious of those reducers
12:49:04 <Smilex> http://lpaste.net/106085 <- Does anyone recognise that error when working with c2hs?
12:50:29 <tulcod> Smilex: you don't need to write the Storable instance if you're using c2hs
12:50:45 <tulcod> or there are prettier ways to do it, anyway
12:51:05 <tulcod> Smilex: http://blog.ezyang.com/2010/06/marshalling-with-get-and-set/
12:51:59 <tulcod> Smilex: i think it's complaining about the type of your ptr
12:52:20 <tulcod> Smilex: what's your c header?
12:53:34 <Smilex> tulcod: https://github.com/Smilex/hyd_engine/blob/master/include/texture.h <- I've only changed the naming of things, but otherwise this one is exactly the same
12:54:21 <tulcod> Smilex: ah. it's supposed to be "struct SDL_Texture" rather than just "SDL_Texture"
12:54:45 <gipp> Question about QuickCheck properties and constrained types:
12:54:47 <gipp> http://lpaste.net/843364343792795648
12:54:50 <Smilex> tulcod: Isn't it a typedef from SDL?
12:55:04 <gipp> basically, how do I make a property for a constrained type? And why can't I wrap a constrained type in a newtype?
12:55:11 <tulcod> Smilex: if you define a struct in C, then "struct" is part of its name
12:55:24 <tulcod> Smilex: unless it was actually a typedef
12:55:25 <tulcod> which it isn't
12:55:38 <tulcod> Smilex: a "type definition" is not a "typedef"
12:55:47 <tulcod> well, one is the other, but not vice versa
12:56:00 <Smilex> tulcod: I'm not defining SDL_Texture
12:56:08 <tulcod> no. SDL_Texture is not defined
12:56:11 <tulcod> nowhere
12:56:13 <tulcod> not in SDL
12:56:15 <tulcod> not in your code
12:56:17 <tulcod> nowhere
12:56:43 <tulcod> Smilex: "SDL_Texture" != "struct SDL_Texture"
12:57:20 <Smilex> tulcod: How how I managed to compile and draw stuff with this code then?
12:57:31 <tulcod> i don't know?
12:57:46 <tulcod> Smilex: care to share what exactly you complied?
12:57:55 <phadej> gipp: the types in QuickCheck need to be monomorphic
12:58:52 <Smilex> tulcod: https://github.com/Smilex/hyd_engine <- this whole project
12:59:06 <Smilex> but I've got a lot of changes locally, which I'm preparing to push
12:59:11 <tulcod> Smilex: i don't knwo. the point is, just add "struct" in front of that line
12:59:24 <gipp> phadej: so no way to generalize? I'd just have to write separate properties for any given m, n?
12:59:47 <Smilex> tulcod: Yeah I did, and now it made a couple of new files, but it still has the #peek, #poke, etc. stuff
13:00:15 <tulcod> Smilex: the easiest way to compile stuff with c2hs in it is by setting up a proper cabal project
13:00:49 <Smilex> tulcod: Well I just want to see if it works first
13:01:23 <tulcod> Smilex: it's not that difficult to setup a cabal project... you'll probably save time if you have to compile at least 5 times (which you do)
13:01:51 <tulcod> Smilex: and either way you'll have to do it anyway
13:01:55 <phadej> gipp: this is a simple example https://gist.github.com/phadej/02bc85bb55905b943d1e, did I understood you problem right?
13:02:22 <phadej> gipp: but yes, you can't abstract over types
13:02:57 <Smilex> tulcod: but I'm wary of things that make things in anyway difficult for basic things. What I'm saying is that I will absolutely drop c2hs and never look back, if it is in anyway annoying from the start
13:03:21 <tulcod> Smilex: haskell tends to be annoying for very good reasons...
13:03:26 <gipp> phadej: yeah, that's a simpler example. thanks for the clarification
13:04:03 <alket> hi , im new to haskell , are 3D games possible , like RTS one for instance ?
13:04:17 <luite> sure
13:04:37 <Smilex> tulcod: so far I've found that Haskell is logical. c2hs gives no output, which I assume means that it worked, however all it did was just add a few comments. This does not seem logical
13:04:39 <alket> but with good performance etc.
13:04:47 <tulcod> Smilex: i am not recommending you to use c2hs because i am a fanboy or whatever. in the long run, it does actually help you write clean code quickly. yeah, there is a learning curve, but it's the best solution we have so far
13:04:48 <phadej> Guest41807: I updated a gist. You can specify the property once, but then you need to type-cast it to monomorphic versions to be able to quickcheck them
13:04:56 <phadej> gipp: I updated a gist. You can specify the property once, but then you need to type-cast it to monomorphic versions to be able to quickcheck them
13:05:16 <tulcod> Smilex: well all of this peek and poke stuff is not c2hs, it's hsc2hs, i think
13:05:24 <tulcod> so it probably isn't picked up by c2hs
13:05:33 <phadej> gipp: That's how you'd test eg. Monoid laws. Specify them for a Monoid, but test for your type.
13:05:48 <Smilex> tulcod: oh. Well that would explain things
13:06:14 <tulcod> Smilex: this is a great tutorial series on c2hs http://blog.ezyang.com/2010/06/the-haskell-preprocessor-hierarchy/
13:07:00 <Smilex> yeah, I'm reading it now thanks
13:08:06 <gipp> phadej: Yeah, I figured this would be the case. Just wanted to double-check if there was some way of abstracting over it that I was missing. These are dimension-indexed matrices and vectors, so I guess I can just pick some big dimension and assume there are no special cases beyond that. Unfortunate.
13:09:51 <phadej> gipp: the situation you start to miss dependent types :)
13:10:58 <luite> alket: yes, in theory at least. there are some game engines that work, and have reasonably good performance. if you're aiming for something along the lines of high profile console games, pushing the limits of the hardware, you get into uncharted territory, you might need to customize things like memory management
13:11:16 <gipp> phadej: learning Haskell is already enough of a distraction from my actual work in ML/stats, trying my best not to give in to the Agda temptation or I'll never get anything done.
13:12:09 <BluePeppers> I’m trying to get an S3 object’s contents as a Bytestring, using the aws package. It gives me a conduit: Source IO ByteString. How can I get the IO BytesString from that? write a sink or something?
13:13:02 <c_wraith> BluePeppers: Yeah, that's the normal way.
13:13:37 <gipp> BluePeppers: ConduitCombinators.sinkList will grab everything
13:13:55 <gipp> BluePeppers: i'm assuming that's a conduit source and not something else, I've never used that package
13:14:02 <rien> how do I set the timeout in http-conduit?
13:14:08 <BluePeppers> gipp, ty. I’ll give it a go :)
13:14:38 <Lutin`> Man I need to learn conduit
13:14:58 <vova> Could someone help me with searching the module. I need to auth (post request), download the web.page (https), save cookie.
13:15:00 <phadej> gipp: brief exposion to more powerful typesystems got me appreciate the relative easiness of Haskell one. But maybe not the best idea, while still learning the basic language.
13:15:18 <c_wraith> BluePeppers: Data.Conduit.List.consume is also a sink that'd help.  You'd need to concat the resulting list, but it'd be what you need
13:16:22 <tulcod> what is the strength of HXT versus the simple xml package?
13:16:27 <tulcod> when should i use either?
13:16:45 <c_wraith> I've never used HXT.  It scares me.
13:16:54 <vova> Network.HTTP have all listed features except https. Please asist
13:17:28 <tulcod> vova: "Technically, it is not a protocol in and of itself; rather, it is the result of simply layering the Hypertext Transfer Protocol (HTTP) on top of the SSL/TLS protocol, thus adding the security capabilities of SSL/TLS to standard HTTP communications."
13:17:42 <Lutin`> Anyone here use ghcmod-vim?
13:17:42 <tulcod> vova: so find a SSL/TLS package
13:17:50 <Lutin`> my indent seems to not be working
13:18:13 <vova> Lutin: Thank you
13:18:37 <Lutin`> ^ tulcod
13:19:03 <gipp> Lutin`: yeah, I was just having the same problem setting up a new environment. http://github.com/vim-scripts/haskell.vim worked for me
13:20:06 <gipp> oh wait that's the wrong one
13:20:23 <gipp> Lutin`: https://github.com/kana/vim-filetype-haskell
13:20:26 <Lutin`> gipp: Did you also modify your tab to be like on the wiki
13:20:41 <Lutin`> Ah cool
13:20:43 <Lutin`> thanks
13:20:49 <davd> vova: wreq is quite nice and supports SSL (by using the tls package)
13:21:10 * hackagebot vty 5.1.1 - A simple terminal UI library  http://hackage.haskell.org/package/vty-5.1.1 (CoreyOConnor)
13:21:48 <c_wraith> davd: wreq is really nice, but there's a learning curve implied.
13:21:52 <Lutin`> gipp: Yay thanks, and it works with Vundle!
13:22:30 <gipp> Lutin`: no prob. Weirdly, I didn't have that problem last time I set up vim, and never had to use that package before. Not sure what changed
13:22:42 <Lutin`> Yeah idk either
13:23:36 <BluePeppers> Oh lord I do not understand conduit
13:24:26 <c_wraith> BluePeppers: so, you do something like source $$ sink
13:24:48 <BluePeppers> So if I connect my source to consume, I get a list of the things that have gone through the pipe? Then why cannot I not do `sourceFile “/tmp/test.hs” $$ consume`?
13:25:06 <BluePeppers> Or at least, why can I do that, but why is the resulting type not IO [ByteString]?
13:25:52 <c_wraith> BluePeppers: what is the resulting type?
13:25:55 <napping> BluePeppers: I think the general idea is that a stream of ByteString flows down the conduit, and are handled (by side effect) as they go
13:26:12 <BluePeppers> MonadResource [ByteString]
13:26:16 <napping> gathering them all up to return as an ordinary list would kind of defeat the purpose of streaming processing in potentially constant memory
13:26:38 <napping> IIRC there's a sink named toList or something that will gather than return them if that's what you want
13:26:39 <BluePeppers> napping, but I want to use constant memory. I don’t want to use conduit, I’m trying to get my data out of it
13:26:45 <gipp> BluePeppers: runResourceT (should be exported by conduit)
13:27:10 <c_wraith> napping: consume is the sink that converts things into a list
13:27:18 <gipp> :t runResourceT
13:27:19 <lambdabot> Not in scope: ‘runResourceT’
13:27:23 <gipp> bah
13:27:31 <napping> oh, then hooking things up to consume should be giving you a list of items, somehow
13:27:31 <BluePeppers> that works, thanks
13:27:42 <BluePeppers> makes sense. I guess I was ignoring resource cleanup and stuff
13:28:00 <gipp> yeah, just an extra monadic context you have to strip off is all
13:28:03 <c_wraith> looks like sourceFile is in ResourceT IO, which means, yeah
13:28:27 <Lutin`> Anyone have some good material on getting my head around conduit
13:28:32 <Lutin`> never used it before
13:28:37 <BluePeppers> https://www.fpcomplete.com/user/snoyberg/library-documentation/conduit-overview
13:28:40 <rien> Lutin`: it's pretty straightforward from the docs
13:28:54 <Lutin`> I understand the whole sink, conduit, source but I guess I just need to learn the types and oeprators
13:28:55 <rien> Lutin`: http://hackage.haskell.org/package/http-conduit-2.0.0.2/docs/src/Network-HTTP-Conduit.html
13:29:13 <gipp> It's not that tough, it just has complex-looking type signatures you have to get past
13:29:17 <rien> Lutin`: oh wow you're far ahead than me then, and I can use it for simple tasks
13:29:19 <napping> Lutin`: dunno about conduit, but I found the latest pipes tutorial pretty good, and I think it's a lot of the same basic ideas: http://hackage.haskell.org/package/pipes-4.1.2/docs/Pipes-Tutorial.html
13:30:02 <napping> ah, if you're after conduit details that's a bit basic. I think the biggest difference between the two is that conduit gives the rest of a pipeline a chance to run a cleanup action when things terminate, and something about leftovers
13:30:20 <Lutin`> Well I eventually wanted to use csv-conduit for something, but got caught up in the semantics of actually using conduit
13:30:41 <Lutin`> Oh should I say syntactics
13:30:52 <gipp> you should probably say syntax :)
13:31:13 <Lutin`> words, man..
13:33:29 <Eduard_Munteanu> I'm trying to reason about process-conduit's conduitProcess and it seems racy: it checks for output, then awaits input to feed the process.
13:33:59 <Lutin`> Well now that I have vim indentation setup I can actually code without spending all my time pressing the spacebar lol
13:34:01 <c_wraith> Eduard_Munteanu: that does sound unreliable.
13:34:02 <Lutin`> thanks for that gipp
13:34:41 <Eduard_Munteanu> But await is "blocking", and if the process had no output but it will have shortly after, and it will block for it to be read, then it seems it could block forever.
13:35:11 <Eduard_Munteanu> Is there any way to handle input and output in a concurrent fashion with conduit?
13:36:21 <Eduard_Munteanu> I'm thinking conduits are unsuitable for this purpose, unless converted to actual threads pushing / pulling data around.
13:36:59 <wolfspaw> From "Algorithms ... a functional approach" => "Note also that the type conversion is defined in terms of the source type
13:36:59 <wolfspaw> here Int rather than the target type (such as Float) that would be usually used in other
13:36:59 <wolfspaw> languages.  The rationale for this choice is explained in the Haskell report."
13:37:05 <Eduard_Munteanu> http://hackage.haskell.org/package/process-conduit-1.1.0.0/docs/src/Data-Conduit-Process.html#conduitProcess
13:37:22 <wolfspaw> I could not find this rationale on the report, and I'm curious. What is the rationale?
13:37:44 <Eduard_Munteanu> wolfspaw: what conversion?
13:38:04 <wolfspaw> (refeering to fromInt instead of the usual imperative to!Float for example)
13:41:14 <wolfspaw> average_source_conversion xs = (sum xs) / fromInt (length xs)
13:41:14 <wolfspaw> average_dest_conversion xs = (sum xs) / toFloat (length xs)
13:41:41 <wolfspaw> What is the rationale for using source conversion, instead of destination conversion? The book mentions that the rationale is described on the haskell report 98 but I could not find
13:41:46 <wolfspaw> and I was curious xD
13:42:24 <ion> That will traverse the list twice.
13:42:35 <begriffs> I'm writing an app that needs command line arguments to specify what port it will run on, what its database is etc. What is the easiest library I could use? (The arguments can have default values as well.)
13:42:37 <ion> How is fromInt not “imperative” while toFloat is?
13:43:04 <Eduard_Munteanu> begriffs: optparse-applicative is rather alright
13:43:37 <Eduard_Munteanu> ion: perhaps a-la "(float) foo"?
13:43:54 <ion> That is imperative?
13:44:04 <begriffs> Eduard_Munteanu: cool, that's the one I've been looking at. That and getOpt, but I wasn't sure what people tend to use.
13:44:05 <monochrom> begriffs: my https://github.com/treblacy/random-read contains a realistic example of optparse-applicative
13:44:10 <Eduard_Munteanu> Just common in certain imperative languages.
13:44:22 <wolfspaw> I expressed badly, what I mean was that in most languages the conversions are made in relation to the destiny type (toFloat) while in haskell it's using a different approach of making conversions in relation to the source type (fromInt). And the book author mention that there's a reason for that, but does not tell it ; - ;
13:45:23 <monochrom> see how I define my own "-prob=3/1000" argument syntax and I actually check it and give my own error messages
13:45:32 <Eduard_Munteanu> By the way, how do you express options without arguments in optparse-applicative? Something like "program (--dothis | --dothat)"
13:45:43 <ion> fromIntegral cares more about the type of the input than the type of the output.
13:45:51 <begriffs> monochrom: oh thanks, it has defaults and everything!
13:46:20 <Eduard_Munteanu> begriffs: it also generates help messages rather nicely
13:48:01 <monochrom> Eduard_Munteanu: it seems that "switch" helps
13:48:19 <Eduard_Munteanu> Ah, thanks.
13:49:27 <Lutin`> Man I love quickcheck :)
13:49:29 <wolfspaw> ion: hm, I see. So, it's better for type-checking.
13:50:11 <oisin620> As a learning exercise, I'm attempting to write a rope library: http://lpaste.net/106097 However, I recently came across http://blog.ezyang.com/2010/08/strings-in-haskell/ and it's left me a bit confused. Should I not _ever_ be using type String = [Char]? What textual representation should I use my Ropes on?
13:50:59 <ion> oisin620: Would Text be okay?
13:51:21 <Eduard_Munteanu> oisin620: usually Data.Text for text-like stuff, and ByteString for binary data or encoded text.
13:51:43 <oisin620> Eduard_Munteanu: encoded meaning - UTF-?
13:51:54 <mmmm> Is there an easy way to see where a function is imported from?
13:52:13 <c_wraith> oisin620: sure.  anything where it's explicitly about a sequence of bytes, rather than characters
13:52:25 <ion> oisin620: In any encoding
13:52:27 <oisin620> But is Data.Text not encoded?
13:52:30 <Eduard_Munteanu> oisin620: yes, for example if you don't care how the data is encoded
13:53:01 <ion> oisin620: Text encoded internally using some opaque encoding you don’t need to care about, text in a ByteString is a blob of bytes you’ll need to handle properly.
13:53:03 <Eduard_Munteanu> oisin620: ByteString is encoding-agnostic, Text isn't.
13:53:05 <c_wraith> oisin620: Data.Text has an internal format.  But it's irrelvevant
13:53:25 <Eduard_Munteanu> You need to decode a ByteString to make a Text from it.
13:53:50 <oisin620> I see...
13:54:10 <oisin620> Ok, that makes sense, thank you :)
13:54:21 <c_wraith> oisin620: in case you are curious, the internal format is UTF-16.  But if you ever actually see that in the Text api, the API is broken.
13:58:40 <Eduard_Munteanu> I wish ConduitM was MonadBaseControl IO. :(
14:00:37 <mvc1> hey, jw what library you guys would recommend for working with JSON
14:00:47 <mvc1> there seem to be quite afew
14:00:48 <ion> aeson
14:01:25 <mvc1> ion: any reason? I looked at it and it seems to be pretty sane
14:01:49 <Eduard_Munteanu> mvc1: it's pretty easy to bind JSON to datatypes, one reason.
14:02:07 <Eduard_Munteanu> Also Generic-deriving instances.
14:02:20 <mvc1> Eduard_Munteanu: ok, I'm sold
14:02:38 <Eduard_Munteanu> I wish there was something like that for XML.
14:04:08 <Eduard_Munteanu> (although the semantics are different, e.g. attributes vs elements, children vs properties)
14:04:32 <mvc1> Eduard_Munteanu: I imagine it'd be a similar process to build a library for xml
14:05:07 <Eduard_Munteanu> I suspect it's doable too, but not quite straightforward.
14:05:18 <Eduard_Munteanu> JSON is more like a datatype than XML.
14:05:49 <mvc1> True, XML better maps to a tree
14:05:53 <Eduard_Munteanu> XML is essentially more like a tree, yeah.
14:05:56 <mvc1> haha
14:05:57 <mvc1> yep
14:07:35 <mvc1> I'm working on a toy project atm to represent Ecmascript AST's compatable with Mozilla's parser API
14:07:44 <mvc1> which returns and consumes json
14:19:56 <alkimome> Hey people
14:20:03 <Eduard_Munteanu> Hi, alkimome
14:20:26 * Eduard_Munteanu thinks machines in this channel feel left aside
14:20:56 <alkimome> Someone has being talking about haskell for a long time for me, and I'm curious about it uses and applications
14:21:05 <alkimome> differences to other programming languages
14:25:03 <Eduard_Munteanu> alkimome: it might help to ask more specific questions
14:25:22 <Eduard_Munteanu> Anything in particular you want to know about?
14:27:44 <rien> alkimome: the main difference from other languages is that haskell's abstractions are mathematically inspired (to sya the least)
14:27:49 <rien> say*
14:28:46 <Lutin`> Anything wrong with `map f = foldr ((:).f) []` ?
14:29:22 <Eduard_Munteanu> Lutin`: no
14:29:41 <Lutin`> Alright thanks.
14:30:23 <Lutin`> I guess you can't really do filter as a right fold
14:30:50 <Eduard_Munteanu> Lutin`: sure you can
14:31:15 * hackagebot tsession 0.1 - A Transaction Framework for Web Applications  http://hackage.haskell.org/package/tsession-0.1 (FlorianMicheler)
14:31:25 <Lutin`> Oh wait
14:31:42 <Lutin`> you'd just return the right if the predicate is false on the left
14:31:48 <Eduard_Munteanu> Yep.
14:32:04 <darthdeus> what outputs smaller JS, haste or fay?
14:32:22 <Lutin`> Would there be a better way to do that besides (\a b -> if p a then a:b else b)
14:33:03 <Eduard_Munteanu> Lutin`: that seems alright
14:33:07 <ninja_code> what's the best haskell alternative to torch7? (scientific computing)
14:33:26 <ninja_code> haskell sucks, it doesn't have a cool scientific computing library (torch7) like luajit does :-)
14:33:36 <mietek> @unpl return . join
14:33:36 <lambdabot> (\ c -> return (c >>= \ d -> d))
14:34:39 <gipp> ninja_code: so is it just a coincidence that you bring up torch7 while it's top link on HN?
14:35:10 <ninja_code> gipp: no, I was thinking of playing around with deep neural nets,
14:35:20 <ninja_code> then saw torch7, was reminded of that
14:35:32 <ninja_code> and started wondering: what's the haskell alternative
14:35:36 <ninja_code> thus, these two events are not only corelated
14:35:38 <ninja_code> but one caused the other
14:35:44 <mietek> @unpl foo >>= return . join
14:35:44 <lambdabot> (foo >>= \ c -> return (c >>= \ d -> d))
14:36:32 <mietek> I have no idea what this means.
14:36:47 <mietek> Isn't  \d -> d  the same as id?
14:36:59 <Lutin`> man everything is folds
14:37:10 <Lutin`> well most list operations
14:37:38 <Lutin`> (++) is just flip (foldr (:))
14:37:40 <Eduard_Munteanu> :t ?foo >>= return . join
14:37:41 <lambdabot> (?foo::m (m1 (m1 a)), Monad m1, Monad m) => m (m1 a)
14:38:26 <Lutin`> Oh wow didn't know about ?
14:38:31 <mietek> That's nice.
14:38:52 <Eduard_Munteanu> Lutin`: implicit arguments, "abused" for lambdabot purposes
14:39:10 <Lutin`> Is that an extension?
14:39:11 <gipp> ninja_code: there's a few neural net libraries out there, none of them particularly good.
14:39:15 <mietek> So how would you rewrite  return . join  in less pointless style?
14:39:18 <Eduard_Munteanu> Lutin`: yes
14:39:40 <gipp> ninja_code: I'm working on one as a hobby project, oddly enough. Nothing like functional yet, just something I'm doing for fun
14:40:00 <Eduard_Munteanu> mietek: (>>= return . join) === fmap join
14:40:03 <ninja_code> is there n oway
14:40:09 <ninja_code> to just wrap all of luajit/torch7 in an IO monad?
14:40:21 <Eduard_Munteanu> :t liftM join ?foo
14:40:23 <lambdabot> (?foo::m (m1 (m1 a)), Monad m1, Monad m) => m (m1 a)
14:40:51 <mietek> Eduard_Munteanu: so is that also  join <$> foo  then?
14:40:59 <Eduard_Munteanu> mietek: yep
14:41:25 <Lutin`> ninja_code: There's https://hackage.haskell.org/package/hslua
14:41:36 <Lutin`> but not sure about luajit compatibility
14:41:39 <Eduard_Munteanu> mietek: generally, (>>= return . f) = (f <$>)
14:41:48 <mietek> Right.
14:42:26 <Eduard_Munteanu> (well, liftM to be entirely correct)
14:42:45 <Lutin`> well if applicative was a superclass of monad...
14:43:02 <Eduard_Munteanu> Functor, rather.
14:43:33 <Lutin`> Relevant CCC : http://ro-che.info/ccc/21.html
14:43:39 <Eduard_Munteanu> Monad m => Applicative m  is a bit more controversial.
14:44:09 <Lutin`> Yeah I know was just making a joke lol
14:44:10 <Eduard_Munteanu> Cool, I missed some of the recent ones.
14:44:30 <Eduard_Munteanu> Heh.
14:45:17 <Lutin`> The only real question, is do timelords even sleep?
14:45:34 <Lutin`> ugh that comma is in the wrong place
14:45:46 <Lutin`> should be in the bin
14:46:16 * hackagebot tsession-happstack 0.1 - A Transaction Framework for Happstack  http://hackage.haskell.org/package/tsession-happstack-0.1 (FlorianMicheler)
14:48:10 <Tjr> you got me hooked on CCC.
14:48:28 <mietek> Eduard_Munteanu: http://lpaste.net/106109
14:48:33 <Tjr> The static typing / dynamic typing one is also neat, but it's missing a circle "people who don't want typing to get in their way"
14:48:43 <mietek> So — what's the difference between foo and bar?
14:50:25 <Lutin`> Should I avoid using (flatten .) . map?
14:50:30 <Lutin`> It makes sense to me :X
14:50:47 <Eduard_Munteanu> mietek: baz x can only be 'return Nothing', mind
14:50:58 <eazar001> @hoogle flatten
14:50:59 <dwcook> Lutin`: Will it continue making sense to whoever needs to be looking at the code?
14:51:01 <lambdabot> Data.Tree flatten :: Tree a -> [a]
14:51:01 <lambdabot> Data.Graph flattenSCC :: SCC vertex -> [vertex]
14:51:01 <lambdabot> Data.Graph flattenSCCs :: [SCC a] -> [a]
14:51:27 <Lutin`> I guess (\f -> flatten . map f) would be better
14:51:47 <mietek> Eduard_Munteanu: I may have simplified a little bit too far
14:51:58 <Eduard_Munteanu> mietek: so  return Nothing >>= return . join  ===  join (Nothing :: Maybe (Maybe a))  ===  Nothing
14:52:03 <Lutin`> Technically this flatten = concat, but it's for my own list type
14:52:04 <Eduard_Munteanu> Er, return Nothing.
14:52:06 <Lutin`> doing the NICTA course
14:52:20 <mietek> Eduard_Munteanu: that's going even further too far ;)
14:52:36 <mietek> Eduard_Munteanu: basically what I'm asking is, isn't  >>= return . join  a no-op?
14:52:39 <eazar001> :src concatMap
14:52:49 <eazar001> @hoogle concatMap
14:52:49 <lambdabot> Prelude concatMap :: (a -> [b]) -> [a] -> [b]
14:52:49 <lambdabot> Data.List concatMap :: (a -> [b]) -> [a] -> [b]
14:52:49 <lambdabot> Data.Foldable concatMap :: Foldable t => (a -> [b]) -> t a -> [b]
14:53:01 <napping> mietek: no, f >>= return == f
14:53:01 <dwcook> Lutin`: Does it give rise to a Monad? You could use join instead :)
14:53:16 <Lutin`> dwcook: Not yet
14:53:23 <napping> m >>= return . f ~= fmap f m
14:53:42 <mietek> And  fmap join  ?
14:53:58 <napping> I don't see how that can possibly be the same thing as id = fmap id
14:54:17 <Eduard_Munteanu> mietek: still no
14:54:37 <napping> The closest I can see is that join doesn't do too much for free monads
14:54:40 <mietek> In a maze of twisty little abstractions, all alike.
14:54:51 <dwcook> > north
14:54:53 <lambdabot>  Not in scope: ‘north’
14:54:55 <dwcook> :(
14:55:01 <Lutin`> > look
14:55:02 <lambdabot>  Not in scope: ‘look’
14:55:02 <lambdabot>  Perhaps you meant ‘loop’ (imported from Control.Arrow)
14:55:43 <Lutin`> man now I want to play Zork
14:55:57 <Eduard_Munteanu> :t (join <$>)
14:55:58 <lambdabot> (Functor f, Monad m) => f (m (m a)) -> f (m a)
14:55:59 <dwcook> Was that Zork?
14:56:04 <napping> Adventure, I think
14:56:11 <joelteon> :t (fmap join <$>)
14:56:12 <lambdabot> (Functor f1, Functor f, Monad m) => f (f1 (m (m a))) -> f (f1 (m a))
14:57:15 <napping> mietek: It's not that bad. At worst, you are in a maze of little twisty abstractions, all different. Much easier, that one
14:58:39 <Eduard_Munteanu> > join <$> [Just Nothing, Just (Just 4), Nothing]
14:58:40 <lambdabot>  [Nothing,Just 4,Nothing]
14:58:53 <eazar001> > get lamp
14:58:54 <lambdabot>  can't find file: L.hs
14:59:13 <Eduard_Munteanu> > join <$> [[[]]], [[4]], [[4,5,6]]]
14:59:15 <lambdabot>  <hint>:1:16: parse error on input ‘,’
14:59:17 <mietek> http://lpaste.net/106111
14:59:21 <mietek> So this is the non-simplified code
14:59:25 <Eduard_Munteanu> > join <$> [[[]], [[4]], [[4,5,6]]]
14:59:27 <lambdabot>  [[],[4],[4,5,6]]
14:59:31 <mietek> This is the Process monad from distributed-process
14:59:39 <mietek> Which as far as I can see, just derives the Functor instance
14:59:41 <napping> mietek: join is equivalent to >>= id
14:59:44 <Lutin`> dwcook: It is pitch black.
14:59:59 <Lutin`> You are likely to be eaten by a grue.
15:00:09 <mietek> So when I just remove the ">>= return . join", it typechecks
15:00:13 <mietek> Which worries me for some reason
15:00:19 <mietek> Because I have no idea what I'm removing
15:00:25 <napping> that looks correct, what was return . join there?
15:00:41 <mietek> If you mean "why", then that's my question, too.
15:00:41 <napping> If you had something like Process (Maybe (Maybe a)), and didn't want the duplicate Maybe
15:00:52 <mietek> The joys of legacy code.
15:00:56 <mietek> Did you know Haskell can do legacy code?
15:00:57 <napping> then tacking on >>= return . join would collapse the layers, making either fail
15:01:08 <napping> I can only guess that callAt changed
15:01:29 <mietek> Interesting.
15:01:42 <napping> join :: m (m a) -> m a
15:01:55 <napping>  the only thing it does is flatten together two layers of the same monad
15:02:13 <mietek> Yeah, that would make sense.
15:02:17 <napping> Uh, I guess you could instantiate callAt so the "b" gets instantiated to Maybe of something
15:02:28 <napping> using it return Process (Maybe (Maybe b))
15:02:34 <napping> then you could concievably want to join it
15:02:35 <Eduard_Munteanu> x >>= f = join (fmap f x)
15:02:57 <napping> but I don't know what exactly it's supposed to be deserializing there
15:03:19 <pjdelport> (>>= return . join)  ==  liftM join  isn't it?
15:03:20 <Eduard_Munteanu> Yeah, maybe it used to.
15:03:37 <Eduard_Munteanu> pjdelport: yes
15:03:41 <pgib> Hello. I got angry at the newspaper today and my first useful Haskell program to solve "Jumble" (scrabbled word) puzzles as a learning experience.  Please comment on http://lpaste.net/106112
15:03:55 <Eduard_Munteanu> Hi pgib.
15:04:08 <pgib> In particular, anything I can improve regarding performance or style. Maybe I'm too reliant on case statements? Maybe my IO is nasty. Dunno..
15:04:52 <napping> optparse-applicative is just an applicative. Is there any especially nice way to require/complain about acceptable combinations of arguments?
15:05:11 <napping> pgib: I don't see anything particularly awful
15:05:27 <dwcook> pgib: Looks good for the most part. I might be missing something, but it seems like you have an unreachable case on line 30.
15:05:29 <napping> If it's solving puzzles from the newspaper I doubt performance is an issue
15:05:37 <dwcook> pgib: Woops, never mind.
15:06:01 <pgib> Cool. That is good to hear so far :)
15:07:24 <napping> I'd probably drop interactFile
15:07:37 <napping> either just use interact, or inline it
15:08:29 <napping> sorting will be a bit better than this, I think
15:08:30 <Eduard_Munteanu> pgib: or you could use 'partition . (==)' instead of 'extract'
15:08:45 <napping> isPermutation x y = sort x == sort y
15:09:02 <napping> you don't have to take quadratic time if you have Ord
15:09:31 <napping> and then maybe explicitly hoist the (sort word) yourself, if you like
15:10:10 <napping> If you're not on windows, piping the file through your program with the shell is easy
15:11:01 <pgib> hmm, sure, I'll compare with sorting and just a basic equality test
15:12:50 <napping> I'd slightly prefer [word] <- getArgs (or [word,filename] <- getArgs)
15:12:59 <napping> just so it does explode rather than silently ignoring arguments
15:13:05 <pgib> Woot. I'm almost twice as fast as the simple  sort x == sort y solution
15:13:22 <pgib> (on my machine with a butt-load of other assumptions)
15:13:30 <napping> Isn't it a matter of milliseconds either way?
15:13:44 <ReinH> napping: but half as many of them!
15:13:58 <lordsab> Could someone please help me out? I'm trying to build coroutine-object-0.2.0.0, but it throws up this error: http://lpaste.net/106104. My system: GHC 7.8.2, cabal 1.20.0.0 on Arch Linux.
15:14:11 <pjdelport> pgib: Might want to lift the "sort word" part out to make sure it's being shared instead of re-sorted for every candidate word?
15:14:14 <napping> I'd worry about that once I could read even tens of newspapers per second :)
15:14:17 <pgib> ~0.24s vs ~0.41s  (running compiled program through `time`)
15:14:17 <Eduard_Munteanu> pgib: asymptotically (large inputs) sorting should be better
15:14:29 <Eduard_Munteanu> pgib: did you turn on -O?
15:14:48 <napping> oh yeah, -O is critical if you care at all about speed
15:15:08 <Eduard_Munteanu> (or even correctness in some cases :( )
15:15:14 <napping> ?!
15:15:15 <lambdabot> Maybe you meant: v @ ? .
15:15:23 <pgib> I don't necessarily care, it is more an exploration in to how these different strategies -may- playout in practice
15:16:01 <Eduard_Munteanu> napping: I think things like sum are implemented as foldl (+) 0, which blow the stack without -O, for example.
15:16:17 <sdde12s> Has anyone used the incremental-parser package?
15:16:18 <pgib> Same general performance with -O and -O3
15:16:26 <augur> is the new haskell platform out?
15:16:30 <Eduard_Munteanu> pgib: there's no -O3, just -O2
15:18:32 <mietek> @unpl flip $ foldl' $ flip foo
15:18:32 <lambdabot> (\ b c -> foldl' (\ e f -> foo f e) c b)
15:18:40 <mietek> Man.
15:19:22 <pgib> anyway. thanks guys
15:19:41 <napping> Huh, what's BindP in optparse-applicative's Parser for?
15:20:38 <Eduard_Munteanu> napping: likely to generate help messages, I think
15:21:23 <Eduard_Munteanu> napping: consider how (<|>) and AltP would be used to generate "(--foo X | --bar Y)"
15:21:30 <sccrstud92> :pl f x = x
15:21:36 <sccrstud92> @pl f x = x
15:21:36 <lambdabot> f = id
15:21:48 <sccrstud92> @pl f x = fmap ( $ f x) x
15:21:48 <lambdabot> f = fix (fmap . flip id =<<)
15:22:34 <sccrstud92> :t flip id
15:22:34 <pjdelport> pgib: Another way to write it: isPermutation xs ys = length xs == length ys && xs \\ ys == []
15:22:35 <lambdabot> b -> (b -> c) -> c
15:22:52 <napping> Well, I'd like some kind of guard
15:22:57 <napping> like (a -> Bool) -> Parser a -> Parser a
15:23:19 <sccrstud92> and guard doesn't work?
15:23:27 <napping> some way to make a local failure on logical conditions, without breaking the applicative structure that lets it make nice help
15:23:28 <pjdelport> pgib: That might or might not be faster than sorting, and you'll probably want the length guard for sorting too.
15:23:35 <napping> sccrstud92: not a Monad
15:24:17 <pgib> pjdelport don't need length guard for sorting since == implies it
15:24:31 <Eduard_Munteanu> napping: if predicate then ... else fail "..." ?
15:24:35 <pjdelport> pgib: For performance, not correctness. :)
15:24:41 <Eduard_Munteanu> Oh, not a monad. :)
15:24:57 <pjdelport> pgib: There's no need to actually go through with sorting both lists if the lengths don't match.
15:25:05 <pgib> pjdelport. I mean.. if the strings are different lengths than == would fail too
15:25:18 <pjdelport> pgib: Right, but it will fail slowerly.
15:25:32 <pgib> pjdelport ok sure, yeah, I see
15:25:38 <napping> Eduard_Munteanu: for good reasons, but I'd like a little bit more
15:25:55 <pgib> (but that isn't for correctness)
15:26:01 <pjdelport> And the majority of words won't have a matching length, so that guard will avoid a *huge* amount of sorting.
15:26:34 <benbangert> on a default OSX Mavericks with GHC 7.6.3, how many IO's should I be able to forkIO without having socket/maxfile issues?
15:26:46 <Eduard_Munteanu> napping: maybe you can use {abort,info}Option and (<|>)
15:26:50 <napping> benbangert: all of them
15:27:12 <pgib> ok cool, the subset performs comparable to my original one
15:27:22 <benbangert> napping: well, they all run, but I get lots of "connect: resource vanished (Connection reset by peer)"
15:27:26 <napping> forkIO doesn't take any file handle resources, only if those threads do IO
15:27:27 <benbangert> after a mere 140 of them
15:27:34 <benbangert> right, the threads do open a websocket though
15:27:48 <pjdelport> pgib: The next optimization step would be looking at bytestrings, probably.
15:27:48 <napping> hmm, all to the same place?
15:27:51 <benbangert> yup
15:27:57 <Eduard_Munteanu> napping: check ulimit
15:27:59 <napping> isn't there a limit there?
15:28:03 <benbangert> yea, already upped it
15:28:06 <Eduard_Munteanu> Er, benbangert.
15:28:12 <benbangert> upped ulimit to 16k
15:28:38 <Eduard_Munteanu> benbangert: for file descriptors?
15:28:43 <napping> I thought there was some crazy small limit like 5 concurrent XMLRpcRequest connections from one client, maybe something similar applies to websockets?
15:29:20 <Eduard_Munteanu> benbangert: it might be a good idea to use a pool of connections, though
15:29:30 <benbangert> it can do 100 of them without any issues
15:29:47 <napping> anyway, it's nothing to do with whether you run it in forkIO
15:29:51 <benbangert> Eduard_Munteanu: this is a websocket server, its supposed to hold hundreds of thousands of these at once :)
15:29:58 <benbangert> yea, this feels like an OSX issue
15:30:07 <Eduard_Munteanu> Ah.
15:30:22 <luite> yeah OS X has around 255 files ulimit
15:30:24 <luite> default
15:30:27 <napping> well, unless possibly epoll/kqueue/whatever is broken
15:30:41 <napping> and forkIO is the only convenient way to be waiting on that many sockets at once
15:30:58 <benbangert> yea, I was using forkIO to spin up the load tester as well
15:31:14 <napping> then 2*140 is about where you would hit 255
15:31:16 <benbangert> I should note, the errors are on the load tester making the connections, there are no errors I can see on the server
15:31:32 <benbangert> and when I try to do a few thousand it can get into the 700-900 connection range
15:32:25 <Eduard_Munteanu> benbangert: on Linux at least, the sys admin can set policies on limits that the user can't override with a plain ulimit call.
15:32:43 <Eduard_Munteanu> benbangert: check if that's the case
15:32:45 <benbangert> yea, both my server/tester are on my osx machine
15:32:46 <napping> What do you mean "when you try to do a few thousand"?
15:32:50 <tulcod> i think it's a pretty exciting idea that haskell uses all these advanced ideas like monads and arrows and laziness and higher order stuff, but is still pretty efficient
15:33:03 <napping> I'd imagine you fork a new thread when you get a connection request
15:33:05 <benbangert> napping: when I tell it to fire off a few thousand tester IO's
15:33:13 <benbangert> napping: I'm referring to the load tester
15:33:21 <napping> huh, maybe you have some kind of race condition that drops connections
15:33:40 <benbangert> none of these IO op's use anything shared that I can see
15:33:40 <napping> Are you sure those 700/900 are all actually concurrent?
15:33:43 <Eduard_Munteanu> tulcod: to be fair, many other languages perform poorly because they're interpreted.
15:34:04 <benbangert> napping: I see them all pinging
15:34:11 <napping> If so, then any failures around 140 are from your application, not OS stuff
15:34:19 <napping> like they try to stay connected and constantly ping?
15:34:22 <benbangert> yup
15:34:27 <tulcod> Eduard_Munteanu: the fact that such a high level language can be compiled is a feat on its own
15:34:37 <benbangert> the ones that don't make it, die immediately at startup, they don't get to the pinging point
15:34:45 <napping>  okay, then if you run it at 140 and stuff fails (under the same ulimit settings), it's probably something you are doing
15:34:55 <lordsab> Could someone please help me out? I'm trying to build coroutine-object-0.2.0.0, but it throws up this error: http://lpaste.net/106104. My system: GHC 7.8.2, cabal 1.20.0.0 on Arch Linux.
15:34:59 <napping> or perhaps some bugs in IO libraries, but that's less likely
15:35:15 <benbangert> well, when I put it really high, I get: failed to create OS thread: Cannot allocate memory
15:35:30 <Eduard_Munteanu> benbangert: I suspect "resource vanished" means something else
15:35:31 <napping> yeah, each thread does take memory and you'll run out eventually
15:35:33 <benbangert> and it dies, which kinda sucks. I'd hope that it would just stop trying, not that it'd let me blow up so easily
15:35:44 <napping> huh, OS thread?
15:35:45 <Eduard_Munteanu> benbangert: like a closed file descriptor
15:35:47 <napping> that's weird
15:35:49 <tulcod> lordsab: sounds like you should contact the author
15:36:01 <napping> you should never have more than number of cores or so
15:36:12 <napping> unless something is sadly making foreign function calls
15:36:29 <xeno_> so, I have (parseFile top filename ) which is of the type "parser => filename -> IO (Either ParseError [Char])", and I try to retur just the either part, throug doing "do return expression" or "do result <- expression ; return result" - but still it returns the full type (IO too) - why?
15:36:47 <napping> But still, if you can have 700 load threads pinging away, you shouldn't see any out of 140 failing
15:37:02 <lordsab> tulcod: OK, then. I thought someone could at least confirm if it's really an issue with the software
15:37:14 <lordsab> tulcod: Thanks anyway.
15:37:19 <Eduard_Munteanu> xeno_: you can't get only the Either out
15:37:40 <Eduard_Munteanu> xeno_: i.e. there's no IO (Either ...) -> Either ... function
15:37:54 <tulcod> lordsab: unless you forced cabal to ignore something, it should either build correctly or give an earlier "dependency error" or whatever
15:38:24 <Eduard_Munteanu> xeno_: return there works on the IO monad, not Either.
15:38:30 <napping> xeno_: you're still doing IO to run the parser, so it's still in the type. Just do result <- myParser; ... wherever you want to use the result
15:38:37 <benbangert> napping: yea, there's some weirdness, I can't say I entirely trust OSX on this either, though I was able to get my golang version to handle several thousand before it ran into similar OSX limit issues
15:39:00 <xeno_> napping: that is what I'm doing, and the IO stays...
15:39:30 <napping> xeno_: as well it should. If you're doing IO in something, there will be an IO in the type
15:39:37 <begriffs> I'm creating a binary from one big source file but I'd like to split the code up into a few files/modules. Anyone have a sample cabal config for doing this kind of thing? The docs I've seen seem to be written about making libraries such as you would find on Hackage, but I am making just a binary that will happen to have code in multiple files.
15:39:40 <xeno_> Eduard_Munteanu: so once I'm in the IO monad, I stay in the IO monad?
15:39:41 <lordsab> tulcod: I didn't know that, thank you
15:39:43 <napping> benbangert: maybe try linux?
15:39:49 <Eduard_Munteanu> xeno_: yes
15:40:00 <benbangert> napping: yea, I have some AWS instances around, I'll try one of them
15:40:03 <benzrf> napping: i'd just like to interject for a moment
15:40:05 * benzrf ducks
15:40:17 <napping> benbangert: I thought every OS was finally properly using epoll/watever for network IO was well
15:40:34 <Eduard_Munteanu> begriffs: use 'cabal init' to get one
15:40:38 <benbangert> napping: afaik, GHC 7.8 has a totally new IO scheduler that does not use epoll/kqueue/etc
15:40:40 <napping> IIRC windows used to make separate blocking foreign calls for some socket stuff
15:40:44 <benbangert> napping: so I'll try that one :)
15:41:00 <napping> no, it still uses one big old epoll/kqueue call for everything anybody is waiting on
15:41:16 <benbangert> mio does?
15:41:30 <napping> the IO schedular bit is how making apparently blocking IO calls in a Haskell thread ends up registering a file descriptor in the big epoll, and how it gets woken once the result it back
15:41:41 <napping> maybe mio includes something else like per-core epoll calls
15:41:50 <begriffs> Eduard_Munteanu: here's what I've got so far (everything in Main.hs) https://github.com/begriffs/dbapi/blob/master/dbapi.cabal
15:42:27 <pgib> hmm.. I know there is some way to pattern match a list ctor as x:xs, but then still be able to reference the original list. How does that go?
15:42:31 <xeno_> Eduard_Munteanu: so if I have xyxxy = IO (Foo) and I wanna call toBar that takes a Foo and creates a bar, will bar <- toBar(xyzzy) or something work out?
15:42:39 <mietek> Does anyone know what could cause "thread blocked indefinitely in an STM transaction"?
15:42:50 <Eduard_Munteanu> begriffs: oh, you mean modules? You can simply create module files and import them with that exact cabal file, or add them to exposed-modules if they need to be exposed.
15:42:50 <mietek> Especially in relation with distributed-process
15:42:54 <mietek> But even on its own
15:43:09 <AlainODea> xeno_: you get the value of your either in an IO context (possibly in main or some other IO a function) and then you can hand it to another pure function from there
15:43:11 <napping> mietek: if your STM transaction "retry"s on it, and no live thread has any reference to any of the STM vars to ever change that
15:43:41 <napping> xeno_: do myFoo <- xyzzy; return (toBar myFoo) will have type IO Bar
15:43:45 <Eduard_Munteanu> xeno_: if toBar is not an IO function, then you can do   bar <- toBar <$> xyxxy
15:44:02 <mietek> napping: hm
15:44:19 <begriffs> Eduard_Munteanu: do I just create src/Module1/Module1.hs, src/Module2/Module2.hs and then say other-modules: Module1, Module2 ?
15:44:54 <napping> mietek: It's not much specific to STM, think also forkIO $ do v <- newMVar (); takeMVar v; takeMVar v
15:45:00 <napping> you'll get a similar error
15:45:06 <slroberts> pgib: all@(head:tail) = [1,2,3]
15:45:07 <napping> you're blocked, and no runnable threads could ever unblock you
15:45:15 <mietek> Yeah.
15:45:17 <Eduard_Munteanu> begriffs: that would make for Module1.Module1, not Module1.
15:45:32 <napping> It's just that the notion of blocked is maybe a touch tricker for STM
15:45:38 <napping> but I think the implementation is very similar
15:45:57 <napping> when you block on an MVar, the thread record is taken off of the run queues and instead put on a list in the MVar
15:46:05 <napping> and then it's all ordinary garbage collection from there
15:46:12 <Eduard_Munteanu> begriffs: A.B.C is searched in A/B/C.hs
15:46:27 <begriffs> Eduard_Munteanu: Ah I see, thanks.
15:46:32 <napping> Your thread is no longer a GC root, and if the MVar could be garbage collected, you know nothing runnable has a reference to the MVar
15:46:56 <mietek> Right, thanks.
15:46:57 <napping> and then I think the runtime is nice and wakes your thread up by throwing an exception to it instead of just collecting it
15:47:03 <Eduard_Munteanu> begriffs: other-modules isn't strictly necessary, though
15:47:15 <napping> pretty nifty way of doing things
15:48:17 <napping> Eduard_Munteanu: maybe using the alternative and the always-failing options I could express some things
15:48:43 <napping> probably any tricky verification maybe ought to be reported after argument parsing anyway
15:51:10 <Eduard_Munteanu> napping: maybe you can include some hidden always-fail options and re-run the parser after verification, in case the error messages are more consistent then.
15:51:44 <napping> Eduard_Munteanu: I'm thinking of conditions like requiring / forbidding options from being provided if other options are provided
15:52:22 <napping> I'll probably try modifying the library myself at some point anyway, there are various tweaks to help generation I don't see how to get otherwise
15:53:03 <napping> in general about changing text/metavars between brief and full help, or subcommand help and main help
15:53:53 <AlainODea> xeno_: doThing :: IO Bar ; doThing = do { foo <- xyxxz ; return (toBar foo) } (braces and semicolons only needed if single line, assuming toBar :: Foo -> Bar)
15:54:21 <xeno_> AlainODea: I tried, doesn't work
15:54:53 <AlainODea> xeno_: lpaste an error and I'll see if I can decipher it :)
15:55:09 <pjdelport> pgib: It helps to read the @ in "foo@(x:xs)" as "as" (like "foo as x:xs")
15:55:36 <napping> Eduard_Munteanu: oh, letting the completer for one option access values of other options might be interesting too
15:55:41 <Eduard_Munteanu> They're even called as/at-patterns.
15:55:49 <Eduard_Munteanu> Hm.
15:55:50 * rockerman guess whos it?;)
15:56:33 <napping> Current example, I have one argument that's a filename, and an optional flag that names a declaration in that file
15:56:40 <xeno_> AlainODea: sorry, worked - just a screwup elsewhere
15:57:01 <napping> might be nice to actually tab compelete among declarations in the file if you've already given the argument
15:57:01 <AlainODea> xeno_: awesome.  I'm glad it worked for you
15:57:25 <xeno_> next question: what does =<< do?
15:57:43 <Eduard_Munteanu> xeno_: it's just a flipped >>=
15:57:51 <pjdelport> xeno_, AlainODea: You can also write that applicatively as: doThing = toBar <$> xyxxz
15:57:55 <zwer> @src (=<<)
15:57:55 <lambdabot> f =<< x = x >>= f
15:58:45 <AlainODea> pjdelport: good point! I wasn't sure how to express that
15:59:06 <Eduard_Munteanu> xeno_: it's nicer when you write things application-style, like 'f =<< x' which looks more like 'f x' than 'x >>= f'
15:59:12 <napping> (<$>) is just an operator name for "fmap"
16:00:35 <AlainODea> xeno_: =<< binds the output of one action to the input of another.  Its one of the things that actually happens when do is de-sugared
16:02:42 <AlainODea> xeno_: you can write monadic IO actions without do using return, =<< and friends directly. This is true of any instance of Monad actually
16:03:46 <ReinH> AlainODea: I think you mean >>=
16:03:50 <xeno_> AlainODea: so x =<< f is (io x) => (io f(x)) ?
16:04:08 <AlainODea> ReinH: yep. I do.  I need to read before I post :D
16:06:09 <AlainODea> xeno_: more general than that.  It can be used on any Monad.  List, Maybe, Either are examples. There are many others
16:07:59 <joshkirklin> can someone explain to me why StateT a IO is not an instance of MonadRandom?
16:08:41 <napping> I don't think any transformers bother to lift MonadRandom
16:08:59 <joshkirklin> http://hackage.haskell.org/package/MonadRandom-0.1.13/docs/Control-Monad-Random-Class.html#t:MonadRandom
16:09:22 <joshkirklin> am I correct in saying that page shows that it is lifteD?
16:10:20 <napping> oh, it looks like it does
16:10:26 <AlainODea> xeno_: I'm probably not helping :D Hopefully I haven't terribly confused things
16:10:28 <napping> Did you importa that instance?
16:10:42 <xeno_> AlainODea: you were helping :)
16:11:01 <joshkirklin> I'm fairly certain I did, but I still get "No instance for (MonadRandom (StateT Int IO))" etc.
16:11:11 <napping> wait, no
16:11:23 <napping> those instances are saying that RandT of a MonadState is still a MonadState and so on
16:11:49 <napping> or no, the ones from Control.Monad.Random.Class do seem to be what you need
16:11:55 <napping> what are you importing?
16:11:56 <pjdelport> xeno_: Have you read a general introduction to Haskell IO yet?
16:12:11 <xeno_> pjdelport: not yet
16:12:33 <joshkirklin> I have "import Control.Monad.Random" (and control.monad.random.class). Do I have to explicitly import the instances?
16:12:54 <napping> no, just the module
16:12:56 <napping> that's weird
16:13:16 <napping> the haddocks certainly claim MonadRandom m => MonadRandom (StateT s m)
16:14:01 <pjdelport> xeno_: That will probably help most; try http://book.realworldhaskell.org/read/io.html
16:14:33 <AlainODea> xeno_: http://www.haskell.org/haskellwiki/Typeclassopedia was very helpful for me. As was http://homepages.inf.ed.ac.uk/wadler/papers/marktoberdorf/baastad.pdf
16:14:42 <joshkirklin> oh well, thanks for the help, I guess I can just manually define the instance for now
16:14:46 <pjdelport> xeno_: You don't actually have to worry too much about what a monad is, or anything like that: just learn how IO works, on its own.
16:15:08 <napping> ah, no instance MonadRandom IO
16:15:44 <pjdelport> xeno_: Just think of it as a type that lets you compose imperative actions together in a functional way.
16:16:12 <pjdelport> xeno_: Then a little bit of http://adit.io/posts/2013-04-17-functors,_applicatives,_and_monads_in_pictures.html might also help.
16:16:12 * Iloiny is trying to solve a challenge on hackerrank, where an int T is given first and then T lines of strings follow. Any clues how? (if T wasn't given, getContents would do fine)
16:16:17 <napping> joshkirklin: it works if I'm careful to import the right StateT
16:16:18 <AlainODea> pjdelport: agreed. Wadler's paper explains Monads in terms of the relevant software engineering problems they can solve
16:16:47 <pjdelport> xeno_: Functor is the really important type class; Applicative and Monad just add to it. So try to understand Functor, first.
16:17:05 <xeno_> phadej: I'm gonna read through Real World Haskell pretty soon (already read through Learn You A Haskell, but it's a while ago, so forgot too much)
16:17:37 <joshkirklin> napping: which StateT is that?
16:17:40 <AlainODea> xeno_: https://github.com/bitemyapp/learnhaskell " don't sweat the stuff you don't understand immediately. Just keep moving."
16:17:47 <xeno_> nice cartoons btw :)
16:18:03 <AlainODea> best advice I've ever read on learning anything
16:18:39 <napping> joshkirklin: I passed -package mtl-2.1.3.1, which is the exact package the "StateT" link from the MonadRandom haddock page went to
16:19:06 <joshkirklin> interesting
16:19:09 <xeno_> AlainODea: yeah, that's what I'm doing - I could just pause everything and read through Real World Haskell... but it's more efficient to make this kind of head bumps first, and then read it properly next to it..
16:19:33 <napping> I'm not even sure why I have MonadRandom package installed, actually, but I guess it was compiled against an earlier hidden mtl
16:19:44 <napping> dunno, reinstall stuff and see if it works better
16:19:47 <napping> this is pretty strange
16:20:11 <joshkirklin> mmk, will do, thanks again
16:21:24 * hackagebot haeredes 0.4.1 - Confirm delegation of NS and MX records.  http://hackage.haskell.org/package/haeredes-0.4.1 (MichaelOrlitzky)
16:22:18 <benbangert> napping: welp, on a centos box, it got up to a bit over 14k connections before some errors
16:24:31 <benbangert> Oooo, 17k connections, bunch of various errors
16:25:23 <augur> hmmmm
16:25:50 <napping> Would that perhaps be when you passed 2^14 open sockets?
16:26:23 <augur> question: how can i use parsec to parse something that's ambiguous on the left? like, if i use just <|> to separate alternatives, then "a -> b" parses as 'a'
16:26:39 <napping> left factor
16:26:43 <augur> ?
16:26:45 <napping> or backtrack with try
16:26:53 <augur> try doesnt change it
16:27:02 <napping> put the long one first, and wrap in try
16:27:16 <augur> ?
16:27:24 <napping> or like do x <- string "a"; tail <- optional (string " -> b"); return ...
16:27:36 <augur> uh..
16:27:42 <napping> string "a" <|> string "a -> b" will always grab the a and succeed
16:27:46 <augur> obviously i dont mean just a and b, napping
16:27:55 <benbangert> napping: so its all about kernel tuning. I found an article about running 1 million connections, as soon as I changed my sysctl settings, I can now rather easily handle 25k connections at once
16:28:01 <napping> string "a -> b" <|> "string "a" will get "a -> b" okay, but on "a" it will say a parse error
16:28:19 <augur> napping: thats not really a solution
16:28:20 <napping> try (string "a -> b") <|> string "a" will backtrack if it gets some characters into the long alternative before failing
16:28:30 <napping> obviously I don't just mean a and b either
16:28:33 <augur> anyone else? im writing a parser for a haskell-like language
16:28:40 <napping> that's what you get with Parsec
16:29:15 <napping> Either factor the grammar so you don't put the choice until after you've parsed the shared part, or increase backtracking with "try"
16:29:31 <napping> You're not going to get a different answer by asking anyone else, that's what Parsec gives you
16:29:34 <ninja_code> in haskell, is it possible to have a _glboal_ top level definition with type MVar
16:29:35 <augur> napping: try didnt help
16:29:44 <ninja_code> or is it not, becuase all MVar constructors have type IO MVar
16:29:45 <napping> What are your alternatives?
16:29:50 <napping> Is one always shorter?
16:29:51 <mzero> you need to reverse the alternatives for try to work
16:29:57 <napping> <|> commits to the left alterative if it succeeds
16:30:00 <mzero> that is, match the longer version, before matching the prefix
16:30:13 <napping> if it's always a prefix of the other one it will never try the long one
16:30:21 <mzero> try parseRightArrowForm <|> parseSimple
16:30:26 <augur> ok
16:30:50 <napping> while long <|> short tends to fail on the short input, because parsec also commits to an alternative by default if it's successfully consumed any characters
16:31:05 <napping> try long <|> short means "if you fail anywhere in long, backtrack to the choice and try short"
16:31:31 <napping> benbangert: what did you change?
16:31:47 <benbangert> napping: I set these sysctl options from here: http://blog.caustik.com/2012/08/19/node-js-w1m-concurrent-connections/
16:32:04 <mzero> though, most parsers eventually end up with:     do { s <- parseSimple ; parseRightArrowTo s <|> return s }
16:32:27 <benbangert> napping: still upping it, still ok.... holding 35k connections now without a prob
16:32:29 <mzero> this is because if parseSimple is expensive (!) then you'd prefer not to do it twice
16:32:59 <napping> benbangert: huh, okay. Maybe you need something like that for OS X, or maybe you're supposed to buy an Xserve if you want to host anything serious from OS X?
16:33:26 <benbangert> napping: course, I can't open more than ~ 60k, cause can only use so many ports per IP
16:34:17 <benbangert> napping: but on linux, I no longer see any OS thread allocation errors, at all. just the occasional resource vanished thing, which is fine
16:34:55 <benbangert> yea, not bad, was able to open 51k connections locally without too much issue
16:38:35 <AlainODea> napping: Xserve is discontinued. OS X is not a server OS and really shouldn't be used as one. It's very heavily optimized towards interactive workloads. Develop on OS X, deploy on FreeBSD, Linux, etc. Not Illumos... yet ;) (I'm working on it)
16:39:15 <pgib> slroberts: meant to get back to you. thanks, that makes perfect sense
16:39:58 <augur> napping, mzero: how do i deal with things like application and ->'s associativity?
16:39:59 <slroberts> pgib: no worries. hope it helps
16:40:37 <mzero> augur: are you parsing type signatures, so -> associates to the right
16:40:38 <mzero> ?
16:40:46 <augur> mzero: yes, and terms too
16:40:49 <napping> check out buildExpressionParser for associtivity and precedence
16:41:28 <mzero> buildExpressionParser works well, but if you want to see how you'd do it yourself...
16:41:30 <napping> and maybe some of the stuff in the Combinator module like chain{r,l}[1]
16:41:39 <napping> for applications
16:41:47 <augur> mzero: yes, lets see how to do it :D
16:41:59 <augur> napping: ok. ill look at that
16:42:17 <napping> I guess it's permutations you *really* don't want to build yourself
16:42:38 <mzero>    parseType = do { t <- parseSimpleType ; try (parseRigthArrow t) <|> return t }
16:43:21 <mzero>     parseSimpleType t = do { string "->" ; r <- parseType ; return $ FunType t r }
16:43:47 <napping> looks like mzero will help, I've got to go.
16:43:50 <mzero> er
16:43:59 <mzero>     parseRightArrow t = do { string "->" ; r <- parseType ; return $ FunType t r }
16:44:02 <mzero> (silly me)
16:44:52 <mzero> does that make sense, augur
16:45:29 <augur> mzero: and i presume you'd also do
16:46:06 <augur> parseSimpleType = ... <|> parenthesized parseType
16:46:28 <mzero> yes
16:50:28 <augur> hrmph
16:50:31 <augur> this is really tricky
16:50:38 <cstanfill> I can't seem to get cabal to install hsx2hs-0.13.0
16:50:43 <cstanfill> src/Language/Haskell/HSX/Transform.hs:997:5: Not in scope: data constructor `PExplTypeArg
16:50:48 <cstanfill> ^ any insights at all?
16:58:22 <AlainODea> cstanfill: possible bad bounds on haskell-src-exts. Are you on GHC 7.8?
16:58:28 <cstanfill> 7.6
16:59:06 <AlainODea> cstanfill: strange. Let me try to install it
16:59:22 <cstanfill> AlainODea: that was kind of what I was figuring. I'm installing an earlier haskell-src-exts now, which will take about ten million years while this ghc swaps itself silly
17:00:19 <AlainODea> If you have an cabal 1.20+ you can use the -j8 option to use 8 threads (assuming you have 8 hardware threads available)
17:00:46 <cstanfill> don't think I do -- this is a very teeny cloud host
17:01:01 <cstanfill> the issue is more the 700MB of ram
17:01:17 <cstanfill> more threads would probably just make it swap even harder
17:01:45 <AlainODea> ouch :S
17:01:52 <AlainODea> very likely
17:02:25 <AlainODea> if the host is the same arch and OS as you you can build locally and upload
17:02:39 <AlainODea> It's a bit here be dragon's territory though
17:03:43 <cstanfill> this is on amazon ec2 so it wouldn't be hard to transfer the image to a non-free host for a few hours while I build all this stuff and then transfer it back to the weenie host
17:03:54 <cstanfill> but I'm not in much of a rush
17:04:03 <AlainODea> I can install 0.13.1 without problems in a cabal sandbox
17:04:41 <cstanfill> 0.13.1 works fine, it was .0 that was the problem, and that's what the stuff I'm installing is bounded on, it seems
17:05:29 <cstanfill> I could also potentially mess with the cabal file for whatever actually has the dependency but I've never done that before
17:05:30 <AlainODea> cstanfill: you can download the source for the packages with the strict bounds and fix it
17:05:43 <cstanfill> yeah that might be easier
17:05:59 <AlainODea> I'm happy to help either way
17:07:33 <augur> mzero: this is hanging:
17:07:34 <augur> parse (chainl1 ((Var . Variable) <$> many letter) (spaces>> return App)) "(unknown)" "f x"
17:10:30 <mzero> does spaces accept zero spaces?
17:10:45 <benzrf> mzero: yes
17:10:45 <mzero> if so, then the parser is always seeing a viable op
17:10:55 <mzero> so, can't here
17:10:57 <augur> mzero: ahh ok
17:11:18 <mzero> but then   "(f)(a)"   is probably meant to be an application too, no?
17:11:34 <mzero> the right thing to do here is to remove whitespace at a different level
17:11:40 <augur> ?
17:11:49 <mzero> and then application is simple the fold over    many1 term
17:11:56 <augur> ??
17:12:25 <mzero> a common approach is to define all your lowest level atom parsers as "tokenizing" parsers - which (usually) means that they snarf up all whitespace after them
17:12:39 <augur> i dont follow
17:12:59 <mzero> rather than define       identifier = many1 letter      (for example)
17:13:07 <mzero> you do     identifier = many1 letter <* spaces
17:13:19 <augur> i see
17:13:28 <mzero> though, this i common enough that you may do      tok = (<* spaces)
17:13:36 <mzero> and have      identifier = tok $ many1 letter
17:14:35 <mzero> I find "snarf all white space (and subsequent comments)" is the easiest way to handle thigns ... though of course you need to start by snarfing all leading ws in the input
17:14:49 <mzero> er, "snarf all trailing white space..."
17:14:57 <augur> ?
17:16:37 <mzero> anytime you parse a lexeme (like a numeric constant, and identifier, a parenthesis -- what would be a token in a lex/yacc style system)   -- you also parse all following whitespace (including comments)
17:16:59 <mzero> so        integer = tok $ many1 digit
17:17:22 <augur> but whats this about "thought of course ..."
17:17:25 <mzero> where       tok = (<* whitespace)          and       whitespace = ....    whatever you like here
17:18:07 <mzero> oh... well, since the source can have whitespace at the start and at the end, the top level parse needs to start by parsing off the leading whitespace....
17:18:18 <augur> oh yes, ok. sure
17:18:24 <mzero> that's all
17:26:30 * hackagebot spe 0.5 - Combinatorial species lite  http://hackage.haskell.org/package/spe-0.5 (AndersClaesson)
17:31:04 <bb010g> Running GHCi with -XRankNTypes and Text.Parsec & Control.Applicative imported, :k (forall s u m . ParsecT s u m) returns * -> * and :k Applicative returns (* -> *) -> Constraint. However, :k Applicative (forall s u m . ParsecT s u m) errors with Illegal polymorphic or qualified type: forall s u (m :: * -> *). ParsecT s u m and I can't figure out wh
17:31:04 <bb010g> y.
17:31:55 <butts> also
17:32:11 <cstanfill> christ
17:32:19 <Gurkenglas> It would be so cool if I could take long single-line expressions and have them displayed in such a way that each pair of brackets moves its contents one line lower, recursively.
17:32:39 <cstanfill> just trying to install hsx2hs-0.13.0 is nigh impossible
17:33:46 <bb010g> Anyone know why that's happening?
17:33:56 <benzrf> bb010g: you arent sacrificing enough goats
17:34:01 <benzrf> add more to the bonfire and try again
17:34:52 <bb010g> It does say "Perhaps you intended to use ImpredicativeTypes", but I don't think it does what I want to do.
17:36:24 <AlainODea> cstanfill: cabal install thingwithbaddependency --allow-newer=hsx2hs
17:36:30 <AlainODea> I think
17:36:38 <benzrf> bb010g: it might be sheep and not goats
17:36:40 <cstanfill> hm
17:36:43 <benzrf> bb010g: add another lamb, duh
17:36:49 <benzrf> ( ͡° ͜ʖ ͡°)
17:37:02 <bb010g> NVM, I did need ImpredicativeTypes...I'm confused.
17:37:38 <quchen> ImpredicativeTypes is said to be broken though, but I don't know in what way. Maybe ask Merijn about this. (He's not online right now.)
17:37:53 <quchen> So be a bit careful with it.
17:38:42 <bb010g> I'm trying to give ParsecT a Monoid instance.
17:39:56 <cstanfill> AlainODea: my cabal is not new enough
17:39:58 <benzrf> bb010g: it already has altnerative
17:40:01 <benzrf> *alternative
17:40:16 <bb010g> It's for Data.Foldable
17:40:38 <AlainODea> cstanfill: make it new enough :D (cabal install cabal-install ; export PATH=$HOME/.cabal/bin/)
17:40:56 <quchen> bb010g: And "asum" does not do what you want?
17:41:24 <quchen> It's kind of like mconcat, but for Alternatives.
17:41:28 <quchen> And Foldables.
17:42:31 <bb010g> quechen: How is that more general than concat? All Alternatives are Monoids anyway. (Given an instance, of course.)
17:44:03 <benzrf> :t asum
17:44:04 <lambdabot>     Not in scope: ‘asum’
17:44:04 <lambdabot>     Perhaps you meant one of these:
17:44:04 <lambdabot>       ‘F.asum’ (imported from Data.Foldable),
17:44:08 <benzrf> :t F.asum
17:44:10 <lambdabot> (Foldable t, Alternative f) => t (f a) -> f a
17:44:34 <quchen> Alternative and Monoid are different things, they act on different kinds.
17:44:37 <bb010g> Also, why does something like Functor have kind (* -> *) -> Constraint, but Monoid have kind * -> Constraint?
17:44:41 <cdk> @pl \xs -> zip xs (tail xs)
17:44:42 <lambdabot> ap zip tail
17:44:45 <bb010g> :t F.concat
17:44:46 <lambdabot> Foldable t => t [a] -> [a]
17:45:09 <bb010g> Oh...functors vs lists.
17:45:31 <benzrf> bb010g: what"
17:45:38 <benzrf> there are no functors involved
17:45:46 <bb010g> :t F.fold
17:45:48 <lambdabot> (Monoid m, Foldable t) => t m -> m
17:46:26 <bb010g> benzrf: The Functor under the Alternative.
17:46:47 <quchen> Functor and Applicative and Alternative all have the same kinds.
17:46:59 <quchen> Monoid (capital M) has nothing to do with any of them.
17:47:27 <quchen> Mathematically you can see a monoid in Alternative, but as far as Haskell is concerned that's irrelevant.
17:47:39 <quchen> (lower-case m.)
17:48:36 <bb010g> quchen: So that's why the Typeclassopedia page says "which have a monoid structure" and not "which are monoids"?
17:48:50 <augur> ahahaaa mzero :)
17:48:55 <mzero> ?
17:49:10 <augur> mzero: progress :)
17:49:11 <cstanfill> AlainODea: --allow-newer --constraint="hsx2hs==0.13.1." seems to be working
17:49:20 <mzero> good to hear
17:49:24 <quchen> bb010g: Yes. Note that it says *m*onoid structure, and not *M*onoid structure.
17:49:27 <Lutin`> lol
17:49:31 <Lutin`> I guess this works
17:49:36 <Lutin`> lengthGT4 (_:._:._:._:._:._) = True
17:49:54 <quchen> Lutin`: not . null . take 4
17:49:55 <Lutin`> lengthGT4 _ = False
17:50:25 <Lutin`> Oh they did define take already
17:50:27 <bb010g> quchen: So, there's no way to generally derive a Monoid instance from a type that has an Alternative instance.
17:50:34 <Lutin`> This would probably be faster
17:50:38 <Lutin`> but yeah
17:50:47 <jle`> bb010g: Alternative is not compatible with haskell Monoid
17:50:53 <jle`> wrong Kind
17:51:24 <quchen> Lutin`: Maybe it wouldn't be faster, but I imagine writing "lengthGT20" is a bit tedious with pattern matching.
17:51:33 <Lutin`> Well yeah
17:51:45 <ReinH> There is a difference between "a monoid" and the Haskell typeclass Monoid.
17:52:02 <quchen> bb010g: Alternative is probably what you want when you're looking for "*->* kinded monoid thing".
17:52:34 <augur> mzero: helped for me to write out the various forms and figure out what sort of thing could go where
17:53:38 <AlainODea> cstanfill: winning :)
17:53:46 <mzero> good - left factoring grammars in your head can be way tricky - paper is good1
17:54:05 <augur> mzero: basically, to figure out the forms that are unproblematic -- x _ Prop One <> <E,E> Entity Event (E) -- from the forms that were problematic -- fst E, snd E, (x : E) -> E, E -> E, (x : E) * E, E * E, \(x : E) -> E
17:56:22 <AlainODea> ReinH: ask a category theorist about the fail function in Monad :D (or don't, because it's embarassing)
17:56:39 <ReinH> There is no fail
17:56:46 <quchen> fail?
17:56:51 <ReinH> Exactly
17:57:04 <AlainODea> http://hackage.haskell.org/package/base-4.7.0.0/docs/Prelude.html#v:fail
17:57:13 <ReinH> AlainODea: lalalala can't hear you
17:57:14 <AlainODea> Oh... I get jokes :)
17:57:44 <Lutin`> quchen: That doesn't work
17:57:51 <Lutin`> take 4 [1] = [1]
17:57:51 <cstanfill> guh. that type signature is upsetting
17:58:19 <Lutin`> You mean drop 4?
17:58:25 <quchen> Maybe. It's late.
17:58:30 <Lutin`> njp
17:58:32 <Lutin`> np*
17:58:33 <quchen> :>
18:01:32 * hackagebot mongoDB 2.0 - Driver (client) for MongoDB, a free, scalable, fast, document  DBMS  http://hackage.haskell.org/package/mongoDB-2.0 (GregWeber)
18:02:00 <AlainODea> cstanfill: yep. I'd like a good alternative to it in my own code. I've used it directly recently out of inexperience and I felt dirty for it. `either fail return` with BinStrict.Get. I want to find something better
18:13:34 <augur> mzero: hm. last puzzle: (a -> b) -> c parses as a -> b
18:14:01 <augur> same for * and mixed uses
18:14:01 <mzero> are you checking that it parsed all the input?
18:14:08 <cstanfill> AlainODea: :\
18:14:16 <augur> mzero: oh, no. doh. :)
18:14:27 <mzero> but all that is going to show you is that it doesn't parse at all
18:14:36 <augur> ?
18:15:00 <mzero> are you are parsing the parenthesis?
18:15:04 <augur> yes
18:15:09 <AlainODea> cstanfill: terrible isn't it. I should be using MaybeT or something similar to handle failure explicitly and non-hackishly
18:15:10 <mzero> er, with what
18:15:18 <cstanfill> yeah prolly
18:16:12 <AlainODea> cstanfill: or less radically, just allow the either value out to the calling code so it can make the decision, which is actually easily donw
18:16:15 <augur> mzero: first i have    halfFun = do { a <- simpleExpression ; tok (string “->”) ; b <- expression ; return $ Fun (Scope Dummy a b) }
18:16:32 <mzero> right by in simpleExpression - how do you handle the parens
18:16:38 <augur> mzero: and also,   simpleExpression = ... <|> (char '(' *> expression <* char ')')
18:16:49 <mzero> right! see - didn't eat the trailing space after the )
18:16:51 <augur> oh but i need to tok that
18:16:55 <mzero> so     tok $ char ')'
18:16:58 <augur> doh
18:17:02 <ReinH> mzero: hi
18:17:20 <augur> mzero: :)
18:17:21 <augur> <3
18:17:25 <mzero> augur: if you made your top level parse, end with <* eof    then you'd get an error message if all the input wasn't consumed
18:17:34 <mzero> Hello, ReinH
18:17:53 <augur> mzero: \o.
18:17:55 <augur> \o/
18:17:58 <augur> i think im done :D
18:18:19 <mzero> heh
18:18:29 <mzero> woot!
18:18:34 <augur> mzero: oh, one last thing
18:18:41 <augur> how can i make * higher than ->?
18:18:48 <augur> a * b -> c == (a * b) -> c
18:18:53 <mzero> mean, bind tighter?
18:18:55 <augur> yeah
18:19:08 <mzero> then it needs to be matched from within simpleExpression
18:19:13 <Eduard_Munteanu> augur: parsec?
18:19:25 <augur> i put an explicit parse of a tuple type inside the simple -> parser, mzero
18:19:28 <augur> but thats not working
18:19:29 <mzero> and so, then you end up with a sequence of ever tighter parsers
18:19:31 <augur> Eduard_Munteanu: yep
18:19:47 <mzero> augur: perhaps now would be good to lpaste your code
18:19:53 <augur> mzero: ok
18:20:00 <augur> be warned, its ugly :x
18:20:24 <Eduard_Munteanu> Generally, Happy is better at expression parsing.
18:20:31 <Eduard_Munteanu> FWIW.
18:21:11 <mzero> well.... that is a matter of taste, really
18:21:20 <mzero> buildExpressionParser in parsec is lovely
18:21:22 <mzero> in my view
18:21:24 <l0cust> apparently lpaste doesn't work for moderately large files
18:21:34 <augur> mzero: http://lpaste.net/106120
18:21:37 <mzero> in any case, here augur wanted to learn how it works by building it directly
18:21:46 <Eduard_Munteanu> Ah.
18:22:22 <l0cust> The socket times out
18:22:48 <mzero> augur: where is the * being parsed?
18:23:01 <augur> mzero: sigmas
18:23:02 <l0cust> Here is the file I was trying to paste - http://ix.io/d66
18:23:06 <l0cust> (NSFW text)
18:23:22 <augur> mzero: oh wait, i removed that part :X
18:23:29 <augur> i removed the parse in half pi
18:23:33 <augur> lemme put it back in x3
18:24:41 <augur> mzero: ok fixed, still not working. halfPi has tries for fullSigma and halfSigma
18:24:51 <augur> it still parses   a * b -> c   as a * (b -> c)
18:27:47 <mzero> so - the common form, if you have two operators    %  and @   (say) and you want % to parse tighter than @  is to do this:        exprTop = chain1 exprMiddle (string "@" >> return AtNode)
18:28:06 <mzero> exprMiddle = chain1l exprLower (string "%" >> return PctNode)
18:28:14 <mzero> exprLower = ... lower terms ...
18:28:22 <darthdeus> is there an alternative to hsenv (https://github.com/Paczesiowa/hsenv)? it doesn't want to compile on 7.8.2 :\
18:28:28 <mzero> that is, you need an explicit parsing level for each level of precedence
18:28:39 <darthdeus> which is kinda funny because I wanted to use it to compile 7.8.2 incompatible things
18:29:32 <augur> mzero: hm. ok
18:30:37 <ReinH> darthdeus: cabal has sandboxes now
18:30:55 <darthdeus> ReinH: yeah but i need ghc 7.6
18:31:05 <ReinH> you can just change your PATH though
18:31:17 <darthdeus> what about ~/.cabal?
18:31:30 <darthdeus> and ~/.ghc
18:31:32 <mzero> augur: the problem is in halfSigma and fullSigma, you call expression -- which is going to include -> epxressions
18:31:45 <ReinH> darthdeus: probably not
18:32:04 <mzero> in fact - it allows everything
18:32:16 <mzero> you need to order all your expressions from tightest to loosest
18:32:24 <fuzzyhorns> what is a f-algebra?
18:32:36 <mzero> each one can call only those things that are tighter than it
18:32:53 <mzero> typically, this is done so that you only need to call the one directly more tighter, and that's all
18:33:16 <augur> mzero: right, but if thats inside the halfPi, wont the halfPi fail? so shouldnt the halfPi backtrack?
18:34:03 <mzero> well, if nothing else,    a * b -> c -> d     isn't going to do what you think
18:34:08 <AlainODea> fuzzyhorns: have you seen https://www.fpcomplete.com/user/bartosz/understanding-algebras ?
18:34:09 <augur> hm
18:34:30 <fuzzyhorns> AlainODea: thats what im reading right now :c
18:35:11 <mzero> augur: - it is hard to reason about a parser where all levels are in one expression parser ... and everything has try's everywhere
18:35:31 <augur> mzero: i wish i knew how to make it better :(
18:35:53 <mzero> (also, try definging      symbol = tok . string     and use that everywhere!     symbol "("   for example
18:36:07 <augur> mzero: point
18:36:32 <mzero> is the order of operations, from loosest to tightest that is listed in expression?
18:36:35 * hackagebot Proper 0.3.0.0 - An implementation of propositional logic in Haskell  http://hackage.haskell.org/package/Proper-0.3.0.0 (dillonhuff)
18:36:36 <fuzzyhorns> i guess i am not understanding the part about Expr as a self-similar fractal
18:37:20 <augur> mzero: ??
18:37:25 <AlainODea> fuzzyhorns: ah. I'm also still at a bit at a loss, but I thought I point to what I was pointed to :)
18:37:38 <fuzzyhorns> hehe yeah :)
18:38:33 <foobarbaz> Hi guys, bit of a silly questoin
18:38:40 <foobarbaz> What's the difference between map and fmap/
18:39:03 <Eduard_Munteanu> foobarbaz: fmap is a generalization of map to things other than lists
18:39:18 <fuzzyhorns> Eduard_Munteanu: very concise :)
18:39:19 <Eduard_Munteanu> foobarbaz: for example, trees.
18:39:29 <mzero> do you have a BNF of this language?
18:39:34 <luvpancakes> foobarbaz: you can use fmap instead of map :)
18:40:08 <mzero> gotta run... dinner
18:40:12 <augur> mzero: ehhh. not quite. :)
18:40:30 <benzrf> foobarbaz: also Maybe, functions, and IO actions
18:40:32 <foobarbaz> is `f a` a higher order type then?
18:40:40 <benzrf> foobarbaz: f a is not
18:40:40 <benzrf> f is
18:40:42 <foobarbaz> higher kinded type*
18:45:29 <foobarbaz> benzrf: is that a higher kinded type?
18:45:53 <benzrf> f is
18:46:28 <Eduard_Munteanu> foobarbaz: for [a], f = []
18:49:16 <foobarbaz> cool, thanks
18:56:22 <gamegoblin> Mmmm my program is spending 80% of its time in GC… time to hunt for memory issues...
19:00:01 <benzrf> gamegoblin: OH BOY WHAT FUN
19:04:17 <gamegoblin> benzrf: I KNOW THIS IS HOW I LOVE SPENDING MY SUNDAY EVENINGS
19:04:39 <benzrf> \o/
19:10:58 <Eduard_Munteanu> Is there a Conduit-like thing using MVars or similar to do async streaming I/O?
19:13:11 <ReinH> Eduard_Munteanu: there's pipes-concurrency
19:13:38 <benzrf> Eduard_Munteanu: you could also hook up pipes to 0mq :-3
19:13:50 <benzrf> [which i wrote a tiny module for]
19:14:31 <Eduard_Munteanu> Er, that's not my intended use. I'm merely trying to get a better process-conduit.
19:14:40 <benzrf> what's process-conduit
19:14:59 <Eduard_Munteanu> Lets you spawn external processes and treat them as conduits.
19:15:25 <benzrf> u-use 0mq
19:15:48 <Eduard_Munteanu> benzrf: I don't see how 0mq helps here.
19:16:05 <benzrf> it ALWAYS helps
19:16:11 <augur> i wonder why we dont explain monads as "flattenable" things
19:16:15 <benzrf> if you need things to communicate then use 0mq
19:16:16 <benzrf> duh
19:16:18 <augur> thats precisely on the nose what they are
19:16:44 <augur> probably we like the bind notation best
19:16:45 <Eduard_Munteanu> augur: just closure operators, amirite? :)
19:16:58 <augur> Eduard_Munteanu: that too :)
19:17:02 <benzrf> flattenable functors, even
19:17:10 <augur> but flattenable is a nice intuitive idea for many people
19:18:18 <benzrf> perhaps
19:18:38 <benzrf> can monads be used to flatten Pointed?
19:18:43 <benzrf> :y
19:18:49 <augur> ?
19:19:28 <benzrf> a pune, or play on word
19:19:29 <benzrf> s
19:19:36 <augur> oh i see
19:19:50 <benzrf> :k Pointed
19:19:52 <lambdabot>     Not in scope: type constructor or class ‘Pointed’
19:19:54 <benzrf> oh
19:19:59 <Eduard_Munteanu> benzrf: if you mean I should be using a known protocol to get message boundaries, then I guess you have a point
19:20:16 <benzrf> Eduard_Munteanu: well i mean 0mq is handy for connecting things async in general
19:20:22 <benzrf> Eduard_Munteanu: how are you currently doing it?
19:21:24 <Eduard_Munteanu> benzrf: I just want to get a conduit-like thing for spawning tools like netpbm's and sending/receiving data from them.
19:21:33 <benzrf> netpbm?
19:21:39 * hackagebot validations 0.1.0.2 - A nice way to define field validations in Haskell.  http://hackage.haskell.org/package/validations-0.1.0.2 (mavenraven)
19:21:58 <Eduard_Munteanu> benzrf: yes, e.g. pnm2png (image conversion from PNM to PNG)
19:21:59 <benzrf> how does conduit differ from pipes anyway
19:22:02 <benzrf> Eduard_Munteanu: ah
19:22:08 <benzrf> i see what you mean
19:22:09 <Eduard_Munteanu> Not very sure.
19:22:22 <benzrf> you want to treat spawned processes as pipes ok
19:22:24 <benzrf> err
19:22:25 <benzrf> conduit
19:22:26 <benzrf> s
19:23:11 <Eduard_Munteanu> benzrf: yes, but on the nose that is broken because you can't do non-blocking awaits or handle input/output in a parallel fashion, it seems impossible.
19:23:32 <Eduard_Munteanu> process-conduit is racy because it takes turns between reading the output and writing input.
19:24:28 <benzrf> Eduard_Munteanu: i do know that pipes-concurrency allows you to connect pipes async or somethin
19:27:18 <Eduard_Munteanu> Right now I'm making a   data StreamerT i o m a = StreamerT (ReaderT (MVar i, MVar o) m a) ...
19:27:43 <Eduard_Munteanu> Along with  (=$~) :: MonadBaseControl IO m => => Conduit a b m -> StreamerT b c m r -> StreamerT a c m r
19:27:57 <Eduard_Munteanu> And stuff like that.
19:29:17 <enthropy> Fuuzetsu: (or other haddock people). Does the markup for anchors work? http://www.haskell.org/haddock/doc/html/ch03s08.html#idp1371107572
19:29:33 <Eduard_Munteanu> Then I'll have a   processStreamer :: MonadBaseControl IO m => String -> [String] -> StreamerT ByteString ByteString m ExitCode   or something
19:30:00 <enthropy> I write "Data.HList.CommonMain#TIP" in my .hs file, and get "Data.HList.CommonMain#TIP" showing up in the html
19:30:28 <thetallguy> not a haskell question, but does anyone know of a simple equation editor that spits out mathml?
19:30:49 <thetallguy> Researching for my father, and the state of software for math has me in despair
19:31:22 <Eduard_Munteanu> thetallguy: I think Pandoc can convert LaTeX to MathML
19:31:50 <Eduard_Munteanu> (Mentioning Pandoc also makes it ontopic. :P)
19:31:52 <thetallguy> Eduard_Munteanu: excellent suggestion, thanks
19:31:57 <gamegoblin> So I configured a library of mine with “runhaskell Setup.hs configure --enable-library-profiling --ghc-option=-auto-all” and installed it, but when I try to compile an executable that uses it with -prof, it says “perhaps you haven’t installed the profiling libraries"
19:31:59 <gamegoblin> Ideas?
19:32:02 <thetallguy> Eduard_Munteanu: bonus
19:38:09 <l0cust> Hey, so I'm trying to figure out Aeson
19:38:48 <l0cust> Here's my code http://lpaste.net/106125
19:39:17 <l0cust> When I try to read a file, which is valid, with Aeson's eitherDecode, I get this
19:39:21 <enthropy> gamegoblin: maybe it's complaining about a different library missing profiling libs. Maybe the copy you ended up installing didn't use those flags?
19:39:24 <l0cust> Left "when expecting a (), encountered Object instead"
19:39:35 <Welkin> I'm attempting to add escaped characters to my scheme parser, but it doesn't seem correct
19:39:37 <Welkin> code here http://lpaste.net/106126
19:39:51 <l0cust> I've never used aeson before, so not sure how it works
19:40:35 <enthropy> gamegoblin: usually you'd have a --user in there, so that runhaskell Setup install will go into your home
19:40:43 <Eduard_Munteanu> l0cust: what is the input JSON?
19:41:20 <l0cust> Eduard_Munteanu: http://ix.io/d6a
19:41:24 <l0cust> (NSFW text)
19:41:34 <l0cust> That's the compressed version, which is what it's interpreting
19:41:37 <gamegoblin> enthropy: thanks that did the trick
19:42:02 <l0cust> Eduard_Munteanu: here's the prettier version: http://ix.io/d66
19:43:07 <Welkin> is anyone familiar with Parsec?
19:43:22 <benzrf> Welkin: everyone
19:43:26 <benzrf> everyone is familiar with parsec
19:43:30 <Eduard_Munteanu> l0cust: you don't seem to be looking inside the "pornography" object
19:43:42 <Welkin> well then, tell me if this is correct: http://lpaste.net/106126
19:43:45 <l0cust> Eduard_Munteanu: ah, I see
19:43:55 <l0cust> Eduard_Munteanu: well, now I feel stupid
19:44:52 <gamegoblin> Welkin: It could be made a little prettier with the `between` combinator. Still looking though, one sec.
19:45:58 <gamegoblin> @pl \a b -> f a >> return b
19:45:58 <lambdabot> (. return) . (>>) . f
19:46:25 <gamegoblin> Welkin: do you have reason to suspect it isn’t correct?
19:46:33 <Eduard_Munteanu> x <$ char c   would be better
19:46:38 <Welkin> well, it's hard for me to test it and I get strange outputs
19:47:44 <gamegoblin> WIthout testing, it looks correct to me, but there may be some subtle error I’m missing.
19:48:43 <Welkin> if I just give it a "\n" or "\"" it freaks out
19:49:20 <Welkin> says: unexpected "\\", expecting "\""
19:49:33 <gamegoblin> Welkin: That’s because you’re probably giving it [ ‘\n’ ] rather than [ ‘\\’, ’n’ ]
19:49:40 <gamegoblin> Feed it “\\n”
19:49:53 <Welkin> same issue
19:50:20 <Eduard_Munteanu> Welkin: well, it expects something between quotes
19:50:53 <dsturnbull> and then make sure you don't use gamegoblin's non-ascii quotes, because that'll break it too
19:50:53 <Eduard_Munteanu> Welkin: so try "\"\\\"\"" ("\"")
19:51:14 <gamegoblin> dsturnbull: I really need to figure out out to change the setting in my IRC client :P
19:51:30 <gamegoblin> Eduard has probably found the problem
19:51:54 <Welkin> Eduard_Munteanu, that worked
19:52:12 <Welkin> so does "\"\""
19:52:28 <Welkin> why though?
19:52:36 <gamegoblin> Welkin: Because your parser expects the string to contain quotes
19:52:49 <gamegoblin> Welkin: So you have to put quotes inside your string.
19:53:02 <Welkin> it works fine with just "hello"
19:53:26 <gamegoblin> Welkin: “hello” or “\”hello\””
19:53:35 <Welkin> just "hello"
19:54:01 <gamegoblin> Errr it sounds like it shouldn’t…? Since the first parser in the do block is looking for a char ‘“‘
19:55:10 <sie> Could I use a Functor abstraction to touch just a part of weirdData :: [String, Int(from 0 to n)] list? To get (+1) <$> weirdData :: [String, Int(1 to n+1)]?
19:55:16 <Welkin> here is the whole thing: http://lpaste.net/106126
19:55:40 <Welkin> I take the string from the command line and feed it to parseExpr
19:55:57 <Welkin> er, read Expr
19:56:03 <gamegoblin> Welkin: I suspect when you just feed it “hello” it interprets that as an atom, not a string
19:56:11 <Welkin> oh
19:56:41 <Welkin> so then there is no problem
19:56:44 <Welkin> I suppose
19:56:48 <gamegoblin> Nope
19:56:57 <Welkin> well, that was a fun couple hours
19:57:00 <Eduard_Munteanu> sie: if you mean [(String, Int)], then that is made of functors, it's f (g Int) for f = [], g = (,) String, so you need two fmaps.
19:57:11 <gamegoblin> Welkin: Next time, use Debug.Trace or something
19:57:12 <Welkin> thank you gamegoblin and Eduard_Munteanu
19:57:17 <Welkin> never used it
19:57:46 <gamegoblin> Welkin: Something I like to do is import Debug.Trace and then define “help = flip trace”
19:58:03 <gamegoblin> Welkin: Then you use it like “blah blah my line of code here `help` “testing”
19:58:19 <gamegoblin> So you just stick it at the end of your line used as an infix function
19:58:28 <gamegoblin> Print debugging haskell style
19:58:35 <Welkin> inside the function that needs debugging?
19:58:38 <gamegoblin> Yes
19:58:43 <Eduard_Munteanu> sie: however, I'd rather write that as   map (second (+1))
19:59:26 <l0cust> Eduard_Munteanu: Alright, I made some changes, different errors
19:59:31 <l0cust> Eduard_Munteanu: Here's the new code - http://lpaste.net/106131
19:59:34 <gamegoblin> Welkin: So you could stick it inside of your string parser right after the char ‘“‘ line like ` char ‘“‘ `help` “is this line evaluating?” `
19:59:47 <gamegoblin> Welkin: And then you would see that when you feed it “hello” that line never even gets called
20:00:02 <l0cust> Eduard_Munteanu: Here's the JSON
20:00:22 <l0cust> http://ix.io/d62
20:00:48 <l0cust> (NSFW Text)
20:01:07 <sie> Eduard_Munteanu, Hmm, but I still could newtype my List (,) String Int and do it without the "second", no?
20:01:53 <Eduard_Munteanu> l0cust: in 'parseJSON (Object v) = ...' you don't really have an object as input, but a list. Just make an instance for PhraseTree, and you automatically get one for PhraseList.
20:02:07 <Welkin> I must not be using it right...
20:02:17 <Welkin> I don't see any trace showing up
20:02:25 <Eduard_Munteanu> sie: with  newtype Weird a = Weird [(String, a)]   yes
20:03:26 <l0cust> Eduard_Munteanu: tried that, still getting same error
20:03:28 <gamegoblin> Welkin: Then that line of code is probably not being called
20:03:47 <ReinH> gamegoblin: or at least that expression is not being evaluated
20:03:49 <sie> Awesome! I will try it out, this seems like such a badass way of doing it.
20:03:51 <Welkin> I added it to the atom parser too
20:03:51 <sie> Eduard_Munteanu, thanks
20:03:53 <Eduard_Munteanu> l0cust: can you pastebin the code of that attempt?
20:04:16 <l0cust> Eduard_Munteanu: http://lpaste.net/106133
20:04:22 <gamegoblin> Welkin: Paste it please
20:04:38 <gamegoblin> But ReinH is right, if you never evaluate the thunk it also won’t get printed
20:05:30 <Welkin> http://lpaste.net/106126
20:06:02 <Eduard_Munteanu> l0cust: what error?
20:06:33 <l0cust> Eduard_Munteanu: http://lpaste.net/106135
20:06:39 <Eduard_Munteanu> l0cust: and are you sure you're calling aeson at the right type, i.e. PhraseList, not PhraseTree?
20:06:53 <gamegoblin> Welkin: Your code doesn’t require atom to be evaluated. If your case drops through to the _, atom will never get evaluated and the trace will never print. Put your trace on the first line of the parser after letter <|> symbol
20:06:55 <l0cust> Eduard_Munteanu: how do you mean?
20:07:43 <Eduard_Munteanu> l0cust: eitherDecode there is probably defaulting to some type you don't want, provide a type signature
20:07:59 <Eduard_Munteanu> l0cust: eitherDecode x :: PhraseList
20:07:59 <Welkin> gamegoblin, still the same result
20:08:08 <Eduard_Munteanu> Er, Either String PhraseList
20:08:26 <knapper_tech> what's a great HTML/CSS/JS fragmentation library?  I only need to insert data into templates and support template nesting etc
20:08:30 <Eduard_Munteanu> It probably picks ().
20:08:30 <gamegoblin> Welkin: Is it printing “No match” or “Found value” at least?
20:08:35 <Welkin> Found Value
20:09:07 <Eduard_Munteanu> knapper_tech: the shakespeare ones are alright (hamlet, cassius, julius)
20:09:27 <Eduard_Munteanu> knapper_tech: see Yesod
20:09:30 <gamegoblin> Welkin: How about you change your Right _ -> “Found Value” to Right x -> show x and see what happens
20:09:35 <l0cust> Eduard_Munteanu: Now getting this Left "mzero"
20:09:47 <l0cust> So, it's almost getting there
20:09:52 <l0cust> but not parsing quite correctly
20:10:11 <l0cust> Eduard_Munteanu: In case I forget to later, thank you very much for your help. I greatly appreciate it
20:10:20 <Welkin> Found Value: Atom "hello"
20:10:21 <Welkin> haha
20:10:22 <Eduard_Munteanu> Sure, alright.
20:10:43 <gamegoblin> Welkin: And did it print out the trace also?
20:10:55 <Welkin> no
20:11:03 <gamegoblin> Welkin: Paste your current code again please
20:11:13 <Welkin> it prints out the messages when I feed it "\"hello\""
20:11:39 <gamegoblin> Welkin: I think it’s because the fixity of <|> is higher priority. Change it to (letter <|> symbol) `help`
20:11:58 <gamegoblin> Welkin: So the the <|> is encapsulated by the parens
20:12:24 <Welkin> http://lpaste.net/106126
20:12:32 <Eduard_Munteanu> l0cust: ah, I see the issue...
20:12:54 <gamegoblin> Welkin: Change line 50 to “first <- (letter <|> symbol) `help` "This is an Atom" with the parens and see if it works
20:13:04 <Welkin> okay
20:13:16 <Welkin> it works now for the Atom
20:13:21 <Welkin> for the String it still prints both lines
20:13:24 <l0cust> Eduard_Munteanu: any ideas
20:13:27 <Eduard_Munteanu> l0cust: wait no...
20:13:27 <l0cust> ?
20:13:39 <Eduard_Munteanu> l0cust: are you sure there's no instance for Tree already?
20:13:40 <gamegoblin> Welkin: What do you mean both lines?
20:13:51 <Welkin> look at the bottom of the source: http://lpaste.net/106126
20:13:52 <l0cust> Eduard_Munteanu: not sure
20:13:55 <Welkin> I put the output in a comment
20:14:22 <l0cust> Eduard_Munteanu: http://www.haskell.org/hoogle/?hoogle=aeson%20tree
20:14:24 <Eduard_Munteanu> l0cust: there is
20:14:41 <gamegoblin> Welkin: That’s because parseExpr tries to parse atom first. So it tries that first parser, fails, then goes on to parse a string
20:14:49 <Welkin> okay
20:14:49 <l0cust> Eduard_Munteanu: Okay, what should I do?
20:14:54 <gamegoblin> Welkin: But that first line of Atom gets evaluated still
20:15:23 <gamegoblin> Welkin: Anyway, so that’s an easy form of print debugging I use from time to time. It’s a nice backdoor into the IO monad.
20:15:34 <Welkin> yes, very much so
20:15:37 <Welkin> thanks for the help
20:15:45 <Eduard_Munteanu> l0cust: either newtype it and drop TypeSynonymInstances, or restructure your JSON as { rootLabel: <your Phrase>, forest: <list of nested Tree> }
20:16:30 <l0cust> Eduard_Munteanu: newtype what exactly?
20:17:04 <Eduard_Munteanu> l0cust: newtype PhraseTree = PhraseTree (Tree Phrase)
20:19:01 <l0cust> Eduard_Munteanu: okay, what does that accomplish?
20:20:05 <Eduard_Munteanu> l0cust: the problem is there's already an instance of FromJSON for Tree and you don't want to use that, unless you go for the 2nd option above
20:21:44 * hackagebot unix-time 0.3.0 - Unix time parser/formatter and utilities  http://hackage.haskell.org/package/unix-time-0.3.0 (KazuYamamoto)
20:21:54 <l0cust> Eduard_Munteanu: ah, okay
20:22:10 <l0cust> Eduard_Munteanu: How do I pattern match against my phrase?
20:22:24 <l0cust> Eduard_Munteanu: that was confusing. How do I write the pattern match?
20:24:50 <solidus-river> i just got the least helpfull compiler error i've ever seen come out of ghc
20:24:55 <solidus-river> i suspect templatehaskell has something to do with it
20:25:00 <solidus-river> http://lpaste.net/106140
20:25:48 <solidus-river> all it seems to tell me is ... somethign went wrong somehwere near somethign that doesnt look wrong
20:25:59 <Eduard_Munteanu> l0cust: if you write a  fromPhraseTree :: PhraseTree -> Tree Phrase   function, then you can do   fromJSON (Object v) = PhraseTree <$> (Node <$> (Phrase <$> v .: ... <*> v .: ...) <*> (fromPhraseTree <$> v .: "forest"))
20:26:42 <MP2E> solidus-river : there's no comma at the end of line 7
20:26:44 <Eduard_Munteanu> Er, map fromPhraseTree
20:27:21 <gamegoblin> solidus-river: comma missing after GLDouble
20:27:25 <gamegoblin> darn MP2E beat me to it
20:28:42 <solidus-river> gamegoblin: MP2E aye, drrrp, yeah that made everythign work
20:28:46 <solidus-river> thanks for lending your eyes
20:29:52 <solidus-river> i didn't look at the line it was talking about
20:33:56 <bb010g> Is there a way to enforce constraints on code at compile time? For example: I have a constant named dviBufSize that I want to ensure is a multiple of 8. How would I have GHC ensure that?
20:35:23 <gamegoblin> bb010g: use Idris or Coq or something ;)
20:35:41 <MP2E> bb010g : look into dependent types, that could make the type-checker enforce it's a multiple of 8
20:35:46 <Eduard_Munteanu> bb010g: either TH or typelevel nats should be able to do that
20:36:17 <bb010g> Eduard_Munteanu: The problem is converting to and from the type level, though.
20:36:35 <Eduard_Munteanu> bb010g: you can use singleton types for that
20:36:42 <MP2E> ^ use the singleton library :>
20:36:43 <bb010g> Eduard_Munteanu: Could you give a TH example? I haven't looked into it much.
20:36:58 <rwbarton> amusingly this is easy to do in C
20:37:45 <l0cust> Eduard_Munteanu: I did something sort of similar - http://lpaste.net/106141
20:37:50 <Eduard_Munteanu> bb010g: not off the top of my head
20:37:53 <l0cust> Eduard_Munteanu: but still not working - getting mzero
20:38:06 <l0cust> Eduard_Munteanu: oops
20:38:41 <l0cust> Eduard_Munteanu: nope, still not working
20:38:55 <Eduard_Munteanu> l0cust: did you provide a type signature for decodeEither?
20:39:15 <l0cust> *Text.Trojan.Phrase> import Data.ByteString.Lazy as L
20:39:15 <l0cust> *Text.Trojan.Phrase L> x <- L.readFile "res/phraselists/pornography.json"
20:39:15 <l0cust> *Text.Trojan.Phrase L> (eitherDecode :: L.ByteString -> Either String [PhraseAlmostTree]) x
20:39:18 <l0cust> Left "mzero"
20:39:19 <solidus-river> hmm, i'm confused about how to use lenses
20:39:32 <solidus-river> i've read a ton on them but its still not clear
20:39:41 <Eduard_Munteanu> l0cust: that can't work, it uses the Tree instance, use PAT
20:40:00 <Eduard_Munteanu> l0cust: er, my bad.
20:41:11 <Eduard_Munteanu> l0cust: replace mzero by   fail "PAT must be an object"   and see if that's the failure.
20:41:21 <Eduard_Munteanu> l0cust: I have to go now, good luck.
20:41:26 <l0cust> Eduard_Munteanu: thanks
20:41:47 <augur> any parsec experts know what i should read to be a l33t parsec coder person
20:42:45 <gipp> I just got GHC to say "my brain exploded" without knowing about it
20:42:49 <gipp> had a nice chuckle at that one
20:42:58 <Eduard_Munteanu> ogadts
20:46:06 <solidus-river> http://lpaste.net/106143
20:46:19 <solidus-river> so does invader^.position not return a Point?
20:46:33 <solidus-river> oh i guess if it returns a Point i dont have to unwrap it from a monad that should jsut be a let binding
20:47:33 <solidus-river> hmm, it doesnt like let bindings
20:48:39 <Maxdamantus> bb010g: you could also just take values that are meant to be multiplied by 8.
20:48:58 <Maxdamantus> Then the result of multiplying them by 8 will always be divisible by 8.
20:49:25 <solidus-river> nvm, i'm stumbling through this stuff and its making more sense
20:49:26 <Eduard_Munteanu> Indeed.
20:49:41 <knapper_tech> Eduard_Munteanus what's a reason I would use Yesod's Shakespear libraries over just Heist?
20:49:48 <solidus-river> Whats a good way to convert from Double to GLdouble
20:50:00 <jle`> solidus-river: is GLdouble a Fractional?
20:50:01 <Eduard_Munteanu> knapper_tech: dunno, haven't used Heist.
20:50:04 <jle`> if so you can use realToFrac
20:50:09 * Eduard_Munteanu really goes now
20:51:59 <c107bh> Are there any jokes written in Haskell?
20:52:19 <c107bh> I know GNU has some written in C in its "humor collection."
20:52:26 <platz> unsafePerformIO
20:52:28 <sie> If a newtype of [(String, Int)] has its own functor instance, can I then still use the List functor instance of it?
20:52:41 <begriffs> Is there a way to override the "module Foo does not export bar" error?
20:53:08 <jle`> sie: what functor instance do you mean?
20:53:25 <jle`> also you can't make that a Functor
20:53:42 <sie> Why not?
20:54:17 <brrrrian> hellllllllo #haskell !
20:54:18 <jle`> one way to look at it is that you need to be able to appy any (a -> b) to a functor object
20:54:24 <jle`> hi brrrrian :)
20:54:37 <jle`> sie: but your thing can only seen to apply certain functions
20:55:29 <jle`> String can't be a Functor, for instance (heh)
20:55:35 <brrrrian> If anyone has some time, could you please take a look at this request for a code review of a 9 line function?  http://codereview.stackexchange.com/questions/54993/merging-time-series
20:55:39 <jle`> neither can Int or (String, Int)
20:55:54 <jle`> nor [(String, Int)]
20:56:03 <bb010g> Related question: is there a way to generate a compile-time error based of off a pure function f returning Bool operating on constants?
20:56:05 <jle`> (String,) can be a Functor
20:56:15 <jle`> (abusing tuple sections)
20:56:46 <sie> What about newtype Weird a = [(String, a)]
20:56:47 * hackagebot simple-sendfile 0.2.15 - Cross platform library for the sendfile system call  http://hackage.haskell.org/package/simple-sendfile-0.2.15 (KazuYamamoto)
20:57:14 <dwcook_> bb010g: You're going to have to be clearer. Under what circumstance would the error be generated?
20:57:37 <jle`> sie: yes, that can be a Functor
20:58:27 <jle`> well
20:58:29 <jle`> if you had teh Constructor
20:58:31 <jle`> ofc
20:58:35 <gamegoblin> Huh just got 25% speedup by inlining (>>=). Didn’t think it would be so significant.
20:59:29 <benbangert> oh space leak, how awesome art thou
20:59:56 <gamegoblin> Was previously spending 80% of time in GC
20:59:59 <benbangert> this seems pretty dang basic, kinda disappointing its leaking memory like mad
21:00:30 <jle`> sie: and it looks like GHC derives the proper Functor instance
21:00:41 <jle`> sie: because actually there is only one possible Functor instance
21:02:41 <platz> brrrrian: I wonder if there is a way to operate on just one list instead of two lists so you could just use a fold instead of explicit recursion
21:02:58 <augur> my parsec parser isnt precedenting properly :(
21:03:29 <cstanfill> any way in ghci to figure out where a function came from?
21:03:29 <dwcook_> augur: Paste code?
21:03:33 <cstanfill> oh :i
21:03:33 <cstanfill> durr
21:03:48 <bb010g> dwcook_: Something like {-# ENSURE (foo < 42) && ((foo - bar) `mod` 3 == 0) #-}. Not too complex, but complicated enough to not want to do at the type level. (Unless mod and other operations got easier.)
21:03:57 <augur> dwcook_: i dont know how to precedent prperly, so its not really useful to post it
21:04:03 <augur> dwcook_: i dont know what im doing is the problem :x
21:06:00 <dwcook_> augur: Someone gave good advice earlier about the outermost using the innermost. Did you have trouble with that?
21:06:49 <brrrrian> platz: do you mean just concatenating the two lists and sorting them, and then run a fold that would deal with duplicate `Day's and accumulate the `snd' of the pair?
21:07:09 <augur> dwcook_: i dont fully understand it :(
21:07:19 <brrrrian> platz: someone posted a response that has to do with converting to a Map and then using unionWith
21:07:24 <augur> dwcook_: i take it you're a parsec whiz?
21:07:59 <brrrrian> platz: that seems neat, but then I would be curious to see what the implementation of Map.unionWith does because I am primarily interested in "how" to do it
21:10:27 <dwcook_> augur: I wouldn't call myself a whiz but I think if you give me a few minutes I can fumble together a grammar with precedence
21:10:56 <platz> brrrrian: Map would be interesting too; I've seen maps simplify things before.  Not sure for your case though
21:12:47 <brrrrian> platz: actually, I don't think Map.unionWith would do it... I can't express the accumulator this way...
21:12:51 <solidus-river> how come in lenses %~ and %= expect a function of a -> a
21:12:56 <augur> dwcook_: http://lpaste.net/106145
21:13:01 <augur> thats the grammar im aiming for
21:13:04 <solidus-river> what if i want ot use those for something else
21:13:33 <augur> dwcook_: oh plus haskell-like constant names for other things not defined there
21:14:10 <augur> dwcook_: the problem is that i cant figure out how to make non-dependent -> interact with * correctly
21:14:15 <augur> thats the only part im stuck on
21:14:39 <dwcook_> augur: The trick is to write the grammar with the precedence rules built-in rather than noted separately
21:15:05 <augur> how
21:15:28 <dwcook_> Digging for a piece of my code where I did something similar
21:16:08 <augur> i tried having the rule for non-dep -> mention the * rule, but that didnt help
21:17:09 <l0cust> Okay, having an odd issue with aeson
21:18:08 <dwcook_> augur: So, this is simpler than the grammar you have in mind, but I wrote something like this: addition = do { a <- multiplication ; token '+' ; b <- addition ; return (a + b) } <|> multiplication
21:18:23 <l0cust> When I give my library this - http://ix.io/d62
21:18:27 <l0cust> it doesn't work
21:18:29 <augur> dwcook_: yes, ive seen this before
21:18:30 <l0cust> (NSFW text)
21:18:43 <dwcook_> multiplication = do { a <- parenthesization ; token '*' ; b <- multiplication ; return (a * b)
21:18:46 <dwcook_> And so on
21:18:53 <augur> dwcook_: hmm
21:19:01 <dwcook_> Oh woops
21:19:02 <l0cust> But, thiys one works http://ix.io/d6f
21:19:05 <l0cust> *this
21:19:07 <dwcook_> multiplication = do { a <- parenthesization ; token '*' ; b <- multiplication ; return (a * b) } <|> parenthesization
21:19:21 <dwcook_> augur: Does that help?
21:19:23 <l0cust> Here's the library - http://lpaste.net/106146
21:19:38 <l0cust> and the test - http://lpaste.net/106147
21:19:42 <dwcook_> augur: That's not Parsec, by the way, but the concepts should be roughly the same. You might need to throw in some try
21:19:46 <augur> dwcook_: so i guess what i should do is something like   function = do { a <- pair ; string "->" ; b <- pair ; return (Fun a b) }
21:20:34 <augur> dwcook_: and then    pair = try do { a <- simpleExp ; string "*" ; b <- simpleExp ; return (Pair a b) } <|> simpleExp
21:20:38 <dwcook_> augur: Well, but do you want to chain ->?
21:20:41 <augur> where simeplExp has the parens thing in it?
21:20:46 <augur> dwcook_: chain??
21:20:51 <dwcook_> augur: a -> b -> c
21:21:01 <augur> you mean for associativity? yes
21:21:02 <dwcook_> augur: The expression you just wrote doesn't permit that, it seems
21:21:04 <l0cust> Any ideas?
21:21:13 <dwcook_> augur: Note how my a and b are different parsers
21:21:41 <augur> dwcook_: oh sorry, you had <|> in addition too
21:21:48 <augur> dwcook_: oh i see yes ok
21:21:58 <augur> dwcook_: yes i see. lemme try that.
21:22:03 <dwcook_> augur: If I'm remembering this correctly it gives rise to left-associative addition and multiplication
21:24:42 <solidus-river> using lenses how do you apply a funciton over a traversal
21:24:43 <solidus-river> i thought it was
21:24:55 <solidus-river> structure.substructre %~ function
21:25:01 <solidus-river> but thats giving me all sorts of wierd type errors
21:25:05 <solidus-river> er
21:25:18 <solidus-river> structure.substructure.traversed %~ function
21:26:12 <solidus-river> oh i guessi could use to
21:27:58 <gamegoblin> If I define a function in a `where` clause, can I still pragma inline it?
21:31:38 <dwcook_> augur: Note that the way I wrote those parsers is analogous to how you might write a grammar that includes the associativity rules baked in.
21:31:39 <l0cust> ah fuck my json is bad
21:31:53 <brrrrian> OK, I mistakenly posted to codereview.stackexchange.com but I don't think I will get enough eyes on it there... reposted here: http://stackoverflow.com/questions/24358392/a-better-way-to-merge-two-association-lists-with-accumulator
21:32:49 <brrrrian> i love haskell
21:33:02 <dwcook_> augur: addition = multiplication ('+' addition) ; multiplication = parenthesization ('*' multiplication) ; ...
21:33:06 <brrrrian> actually... i love programming with types...
21:33:47 <nisstyre> brrrrian: consider using a map rather than an alist
21:33:55 <nisstyre> then you can just use the union function for maps
21:38:29 <brrrrian> nisstyre: how does a union aid in using an accumulator
21:38:57 <nisstyre> brrrrian: it doesn't, but if the goal is to merge two mappings from keys to values it might be useful
21:39:21 <nisstyre> brrrrian: the idiomatic haskell is to avoid types like [(a,b)] and use things that encode more information
21:39:23 <brrrrian> nisstyre: I want to merge two mappings in addition to using an accumulator
21:39:24 <nisstyre> like Map
21:39:46 <nisstyre> brrrrian: there might by a way of doing that using Monoid instances
21:40:57 <nisstyre> brrrrian: oh unionWith might be what you want
21:41:13 <nisstyre> unionWith :: Ord k => (a -> a -> a) -> Map k a -> Map k a -> Map k a
21:41:20 <nisstyre> I think that's what you need
21:42:11 <brrrrian> so... foo [(a1,0), (a3,4)] [(a2,1), (a4,8)] would produce [(a1,0), (a2,1), (a3,5), ...and so on]
21:42:22 <nisstyre> I think so yeah
21:42:28 <brrrrian> nisstyre: see how `snd' of the pair is an accumulator?
21:42:51 <nisstyre> brrrrian: I understand, it's a fold
21:43:09 <begriffs> I'm struggling to construct a query with postgresql-simple..."select * from NAME" where NAME is determined by a function argument. Using "?" binding is not available for this field. Anyone have an idea of how to build the query?
21:43:40 <brrrrian> nisstyre: so it's like a union on `fst' but an accumulator on `snd'...
21:43:58 <nisstyre> brrrrian: oh wait yeah
21:44:10 <solidus-river> man this is hard to wrap my head around
21:44:14 <solidus-river> i have a lens that has a list of lenses
21:44:32 <solidus-river> i want to travers over the list and use the item in the traversal as an input to the function that is traversing them
21:44:35 <nisstyre> brrrrian: let me write some example code and you can see if it does what you want
21:44:45 <solidus-river> and i feel like this could be something with traverse but maybe not
21:47:55 <edwardk> i wish i could actually partially apply  (=>) :: Constraint -> * -> *
21:48:36 <carter> edwardk: wasn't  goldfire talking about that on trac recently?
21:48:41 <edwardk> was he?
21:48:44 <edwardk> where?
21:48:46 <platz> learn functional programming = use accumulators; learn haskell = avoid accumulators
21:49:09 <carter> edwardk: lemme try to find the ticket
21:49:32 <ion> > foldl' (\accumulator x -> accumulator + x) 0 [10..20]
21:49:34 <lambdabot>  165
21:49:51 <platz> ion: well thats true
21:49:54 <abstract-alf> Hey all
21:50:46 <carter> https://ghc.haskell.org/trac/ghc/ticket/9115#comment:4
21:50:51 <carter> edwardk: https://ghc.haskell.org/trac/ghc/ticket/9115#comment:4
21:51:43 <ion> edwardk: edwardk: https://ghc.haskell.org/trac/ghc/ticket/9115#comment:4
21:52:06 <carter> ion: ?
21:52:09 <edwardk> ion: that is something a bit weaker
21:52:17 <ion> carter: I just saw a pattern. :-)
21:52:32 <Clint> is there some way to mark an entire module as deprecated?
21:52:48 <ion> iterate ("edwardk: "++) "http://…"
21:53:29 <edwardk> hrmm
21:53:46 <solidus-river> ok, i refactored to make the problem easier but i'm still not getting the types right, maybe i need to look more at traversals?
21:54:01 <edwardk> if we take (:=>) :: Constraint -> * -> *   as a newtype wrapped around (=>)  then i can define its indexed left adjoint which looks like a pair with a dictionary
21:54:15 <solidus-river> if i have a lens that has a list and i want to view the traversal over that list in the lens and feed it as an argument into a function is there a way to do that with a lens traversal?
21:54:41 <edwardk> and it works because (:=>) is corepresentable by Dict
21:55:42 <edwardk> solidus-river: you're starting to get into two pass territory
21:55:58 <solidus-river> edwardk: how so?
21:56:08 <edwardk> but you can do tricky things with partsOf
21:56:09 <gamegoblin> to have a function declaration with strictness annotations, like f !x = … , do I need any extension enabled?
21:56:13 <solidus-river> edwardk: le tme see if i can come up with a dumb way of doing it and make a pastie
21:56:19 <edwardk> you want all the targets of the traversal and then to replace the list in the target?
21:56:24 <edwardk> or you just want to get all the targets out?
21:56:53 <edwardk> > ([1..5],[1..10])^..both.folded.filtered even
21:56:55 <lambdabot>  [2,4,2,4,6,8,10]
21:57:04 <edwardk> > ([1..5],[1..10])^.partsOf (both.folded.filtered even)
21:57:06 <lambdabot>  [2,4,2,4,6,8,10]
21:57:13 <edwardk> > ([1..5],[1..10]) & partsOf (both.folded.filtered even) %~ reverse
21:57:13 <nisstyre> brrrrian: should it also sort by the keys first?
21:57:14 <lambdabot>  Could not deduce (Data.Functor.Contravariant.Contravariant
21:57:15 <lambdabot>                      Data.Functor.Identity.Identity)
21:57:15 <lambdabot>    arising from a use of ‘Control.Lens.Fold.folded’
21:57:15 <lambdabot>  from the context (GHC.Real.Integral t)
21:57:15 <lambdabot>    bound by the inferred type of
21:57:22 <edwardk> > ([1..5],[1..10]) & partsOf (both.traverse.filtered even) %~ reverse
21:57:24 <lambdabot>  ([1,10,3,8,5],[1,6,3,4,5,2,7,4,9,2])
21:57:26 <nisstyre> brrrrian: otherwise the whole thing is kind of undefined
21:57:52 <edwardk> gamegoblin: BangPatterns
21:58:18 <abstract-alf> :t partsOf
21:58:20 <lambdabot> Functor f => Traversing (->) f s t a a -> LensLike f s t [a] [a]
21:58:34 <edwardk> > (1,2)^.partsOf traverse
21:58:36 <lambdabot>  [2]
21:58:40 <edwardk> > (1,2)^..traverse
21:58:42 <lambdabot>  [2]
21:58:53 <edwardk> x^..l = x^.partsOf l
21:58:57 <edwardk> but you can write back to partsOf
21:59:11 <edwardk> > (1,2) & partsOf traverse %~ reverse
21:59:13 <lambdabot>  (1,2)
21:59:17 <edwardk> > (1,2) & partsOf both %~ reverse
21:59:18 <lambdabot>  (2,1)
21:59:23 <jle`> being able to traverse over tuples makes me feel like i'm in python again
21:59:42 <abstract-alf> what feeling is that?
21:59:48 <Lutin`> wot
21:59:54 <ion> A pain behind your eyes
21:59:56 <Lutin`> :t (1,2) & partsOf both %~ ?reverse
21:59:57 <lambdabot> (?reverse::[t] -> [t], Num t) => (t, t)
22:00:32 <ion> > ((1,2),(3,4)) & partsOf (both . both) %~ reverse
22:00:33 <Lutin`> Oh yeah that makes sense from the above
22:00:34 <lambdabot>  ((4,3),(2,1))
22:01:13 <Lutin`> I wonder what core that compiles to..
22:01:15 <abstract-alf> that is some god damn wizardry
22:01:22 <haasn> Lutin`: only one way to find out
22:01:31 <Lutin`> to ghc-core!
22:01:34 <solidus-river> edwardk: i just want to get the targets of the traversal out and put them into a list
22:01:43 <solidus-river> sorry i've been trying to get anything to compile for an lpaste
22:01:47 <solidus-river> withotu success, readin ghte backlog
22:01:50 <edwardk> solidus-river: just use ^..
22:01:56 <edwardk> > (1,2)^..both
22:01:58 <lambdabot>  [1,2]
22:03:12 <solidus-river> edwardk: http://lpaste.net/106152
22:03:19 <solidus-river> is what i'm trying to do with it
22:03:21 <solidus-river> so its already a list
22:03:27 <solidus-river> but i want to do an fmap over the list
22:03:38 <edwardk> > game^..invaders
22:03:40 <lambdabot>  Not in scope: ‘game’Not in scope: ‘invaders’
22:03:47 <edwardk> notice 2 dots
22:03:56 <solidus-river> why do i need the two dots if they are already a list?
22:04:08 <edwardk> you have a couple of problems here
22:04:09 <solidus-river> and then is there a way i can do that with a traversal instaed of getting them out and maping over them?
22:04:22 <edwardk> first of all the action you're getting is a list not an IO action
22:04:38 <edwardk> i assume R.render is an IO action?
22:04:43 <solidus-river> aye, i only have it compiling without invaders or bullets in the mix
22:04:51 <solidus-river> the R.render $ game^.hero works fine
22:05:04 <solidus-river> yeha, R.render is a Renderable -> IO ()
22:05:18 <nisstyre> brrrrian: this is what I got http://ideone.com/gcsc7n
22:05:35 <nisstyre> ideone messed up the colouring
22:05:43 <nisstyre> is it correct you think?
22:05:44 <haasn> Lutin`: something ugly, apparently
22:05:50 <edwardk> render game = do mapMOf invaders R.render game; mapMOf bullets R.render game; R.render $ game^.hero
22:06:08 <edwardk> er
22:06:14 <edwardk> render game = do mapMOf_ invaders R.render game; mapMOf_ bullets R.render game; R.render $ game^.hero
22:06:20 <edwardk> that way you don't try to edit the list
22:06:22 <haasn> It doesn't look significantly optimized other than the fact that the Identitys are stripped from %~
22:06:27 <edwardk> :t mapMOf_
22:06:28 <lambdabot> (Profunctor p, Monad m) => Accessing p (Sequenced r m) s a -> p a (m r) -> s -> m ()
22:06:58 <haasn> but it deconstructs the tuple (apparently, twice?), recombines it using the applicative instance; passes that to partsOf with reverse
22:07:03 <haasn> nothing magic like \(a,b) -> (b,a)
22:07:18 <solidus-river> edwardk: interesting, so no way to do it with a .traversed or .traverse and a .to?
22:07:52 <edwardk> ^.. is going to compute a list. you can then traverse that list , but you have to actually walk it with IO
22:07:54 <Lutin`> haasn: holy crap
22:08:04 <edwardk> mapMOf_   does precisely that
22:08:04 <haasn> What happens when you try mapMOf_ (invaders <> bullets)
22:08:13 <Lutin`> This core is rediculous
22:08:15 <edwardk> it takes something you know how to do on a list and generalizes it to work with an arbitrary traversal
22:08:57 <edwardk> haasn: partsOf destroys performance sadly
22:09:10 <edwardk> haasn: because it has to do polymorphic recursion, etc.
22:09:10 <haasn> Oh, type error
22:09:20 <haasn> Unless Invader ~ Bullet
22:09:57 <Lutin`> There's a couple things that just don't make sense though
22:10:18 <solidus-river> mapMOf_ invaders R.render game
22:10:25 <haasn> :t mapMOf_ (_1 <> _2) Just (1,2)
22:10:26 <lambdabot> Maybe ()
22:10:31 <solidus-river> fails with no instance of Renderable [Invaders]
22:10:36 <Lutin`> Oh I see
22:10:45 <solidus-river> game^.invaders :: Game -> [Invaders]
22:11:15 <haasn> > execWriter $ mapMOf_ (_1 <> _2) tell ("hello","world")
22:11:17 <lambdabot>  "helloworld"
22:11:21 <Lutin`> So many nested case statements :X
22:12:35 <solidus-river> but my bullets already returns a list
22:12:46 <solidus-river> so shouldn't i just be mapping over game^.bullets
22:12:49 <solidus-river> or game^.invaders
22:12:57 <solidus-river> or thats the error i'm getting
22:13:08 <haasn> solidus-river: mapMOf_ (invaders.folded)
22:13:32 <haasn> edwardk: Hmm, in situations like these, should I go for folded, each or traverse?
22:14:02 <solidus-river> http://lpaste.net/106154
22:14:19 <haasn> (Seems like the only way to find out for sure is with a benchmark)
22:15:27 <solidus-river> hmm, <> isn't even in scope, where does that come from (not in Lens
22:15:28 <solidus-river> )
22:16:22 <solidus-river> i gues si'm still confused about what traversals do
22:16:25 <solidus-river> how come something like
22:16:26 <ion> Data.Monoid
22:16:37 <solidus-river> game.invaders.traverse.to R.render is invalid
22:17:12 <haasn> “game” isn't a traversal, composing it with one (or something similar) makes no sense
22:17:13 <ion> “No instance for (Renderable [Invader])” has nothing to do with lens
22:17:28 <haasn> “game” is the value that you apply your traversal *to*
22:17:40 <haasn> (or do something else with, using that traversal; eg mapMOf_)
22:19:33 <solidus-river> Invader is a lens as well
22:19:49 <solidus-river> so i would be trying to apply the .traversal to each [Invader[
22:19:51 <solidus-river> so i would be trying to apply the .traversal to each [Invader]
22:19:55 <solidus-river> but maybe thats traversed?
22:20:42 <solidus-river> ok so traverse just makes a traversal from an array
22:20:47 <solidus-river> what does traversed do
22:20:50 <solidus-river> :t traversed
22:20:52 <lambdabot> (Indexable Int p, Traversable f, Applicative f1) => p a (f1 b) -> f a -> f1 (f b)
22:26:08 <abstract-alf> say I've got a sudoku board full of numbers (it's a solved puzzle) and I want to clear random squares of the board so the player can fill them in.  I'm imagining just generating a random list of lenses and then iterating over said list, applying a set operation to each lens in sequence.  Is there a better approach?
22:29:03 <abstract-alf> my board is modeled as [[Maybe Int]].  An empty square is Nothing.  I can get a lens to a particular square with (ix rowNumber) . (ix colNumber)
22:30:04 <abstract-alf> hmmm.. so I want to somehow generate a lens that points to multiple squares, where I can apply a single operation to all of those squares simultaneously
22:32:39 <abstract-alf> or is it a traversal that I want (I don't really understand traversals yet)?
22:33:15 <MP2E> It's exactly a traversal that you want
22:33:43 <abstract-alf> MP2E: how can I combine my multiple lenses into a traversal?
22:39:42 <MP2E> abstract-alf : from the looks of it, one way would be to make a lens that returns every square you want to deal with as a list and then use the traverse function
22:40:00 <MP2E> I'm a bit new to lenses myself :P
22:40:15 <MP2E> err traversed is the function you want
22:41:35 <abstract-alf> hmm, no sign of that function here: https://hackage.haskell.org/package/lens-1.4/docs/Control-Lens.html
22:41:40 <abstract-alf> :t traversed
22:41:41 <lambdabot> (Indexable Int p, Traversable f, Applicative f1) => p a (f1 b) -> f a -> f1 (f b)
22:41:48 <MP2E> that's an ancient lens version
22:41:50 <MP2E> 1.4
22:42:05 <abstract-alf> oh, shizer
22:42:21 <abstract-alf> 4.2 is current?
22:42:24 <MP2E> yep
22:44:08 <abstract-alf> what's the difference between traverse and traversed?
22:46:55 <MP2E> traversed actually traverses over a structure, traverse is more like fmap in that it applies an action to each part of the structure
22:47:03 <MP2E> traversed is a bit more flexible, basically
22:47:10 <abstract-alf> ah, ok
22:49:07 <haasn> abstract-alf: traversed is indexed, traverse isn't
22:49:12 <haasn> that's the only difference
22:55:21 <abstract-alf> haasn: I saw earlier in this chat to use (^..) for traversals..
22:55:25 <abstract-alf> > [('a',1),('b',2),('c',3)] ^.. (traverse . _2)
22:55:26 <lambdabot>  [1,2,3]
22:55:42 <abstract-alf> how can I write that expression without (^..)
22:55:42 <abstract-alf> ?
22:55:55 <glguy> the combinator for that is "toListOf"
22:56:08 <glguy> > toListOf (folded . _2) [('a',1),('b',2),('c',3)]
22:56:10 <lambdabot>  [1,2,3]
22:56:22 <glguy> and you don't need a traverse in this case, just a fold will do
22:56:46 <abstract-alf> what if I want to modify that element instead of read it?
22:56:56 <MP2E> folding will still work
22:57:17 <abstract-alf> over (folded . _2) ('a',1),('b',2),('c',3)]
22:57:19 <abstract-alf> oops
22:57:30 <abstract-alf> > over (folded . _2) [('a',1),('b',2),('c',3)]
22:57:31 <glguy> You can't set through a fold
22:57:31 <lambdabot>  Couldn't match type ‘(->) a0’ with ‘[]’
22:57:32 <lambdabot>  Expected type: a0 -> (GHC.Types.Char, t0)
22:57:32 <lambdabot>    Actual type: [(GHC.Types.Char, t0)]
22:57:38 <abstract-alf> > over (folded . _2) (+1) [('a',1),('b',2),('c',3)]
22:57:40 <lambdabot>  Could not deduce (Data.Functor.Contravariant.Contravariant
22:57:40 <lambdabot>                      Data.Functor.Identity.Identity)
22:57:40 <lambdabot>    arising from a use of ‘Control.Lens.Fold.folded’
22:57:40 <lambdabot>  from the context (GHC.Num.Num t)
22:57:40 <lambdabot>    bound by the inferred type of
22:57:53 <abstract-alf> > over (traverse . _2) (+1) [('a',1),('b',2),('c',3)]
22:57:55 <lambdabot>  [('a',2),('b',3),('c',4)]
22:58:01 <abstract-alf> wahoo!
22:58:12 <abstract-alf> ok, what's the operator version of that expression?
22:58:44 <edwardk> > [('a',1),('b',2),('c',3)] & traverse._2 +~ 1
22:58:44 <glguy> over is %~, but over _ (+1) is (+~ 1), but over is just fine
22:58:46 <lambdabot>  [('a',2),('b',3),('c',4)]
22:59:41 <abstract-alf> > [('a',1),('b',2),('c',3)] & traverse._2 %~ (+1)
22:59:43 <lambdabot>  [('a',2),('b',3),('c',4)]
22:59:45 <abstract-alf> ok
23:00:05 <glguy> > [('a',1),('b',2),('c',3)] & mapped._2 %~ (+1)
23:00:07 <lambdabot>  [('a',2),('b',3),('c',4)]
23:00:21 <abstract-alf> :t traverse
23:00:22 <lambdabot> (Traversable t, Applicative f) => (a -> f b) -> t a -> f (t b)
23:00:23 <abstract-alf> :t mapped
23:00:25 <lambdabot> (Settable f1, Functor f) => (a -> f1 b) -> f a -> f1 (f b)
23:00:48 <abstract-alf> yeah, I don't understand those types yet
23:00:58 <abstract-alf> what's the difference between mapped and traverse here?
23:01:03 <jle`> is `over` a lens idiom?
23:01:18 <abstract-alf> jle`, I suppose it's like fmap
23:01:29 <edwardk> jle`: yes
23:01:31 <jle`> oh sorry, unrelated to what you guys were talking to
23:01:42 <jle`> it was in reference to some pipes code i was reading
23:01:50 <glguy> abstract-alf: mapped works on any functor for updates, traverse only works on Traversables for updates
23:01:56 <glguy> and mapped is potentially more efficient
23:02:02 <jle`> i feel like pipes is going to be the library that forces everyone to learn lens
23:02:19 <abstract-alf> so, you can use mapped on Maybe, Either, IO ?
23:02:53 <dwcook_> jle`: How are you seeing them being used together?
23:03:10 <abstract-alf> > Just 5 & mapped +~ 5
23:03:12 <lambdabot>  Just 10
23:03:20 <abstract-alf> > Nothing & mapped +~ 5
23:03:21 <lambdabot>  Nothing
23:05:33 <begriffs> I'm trying to trick a library. It creates a newtype called Query to enforce that forces you to use OverloadedStrings to construct Query literals. It is intentionally trying to block me from constructing from ByteString. I want to trick it though. What do I do?
23:06:12 <glguy> ?type fromString
23:06:14 <lambdabot>     Not in scope: ‘fromString’
23:06:14 <lambdabot>     Perhaps you meant one of these:
23:06:14 <lambdabot>       ‘BSLC.fromStrict’ (imported from Data.ByteString.Lazy.Char8),
23:07:21 <jle`> dwcook_: https://groups.google.com/d/msg/haskell-pipes/dnPmpEhDUnU/uoWGTdidZB0J
23:07:59 <abstract-alf> > let board = [[Just 1, Just 2, Just 3],[Just 4, Just 5, Just 6],[Just 7, Just 8, Just 9]]
23:08:01 <lambdabot>  not an expression: ‘let board = [[Just 1, Just 2, Just 3],[Just 4, Just 5, J...
23:08:10 <abstract-alf> figured not...
23:08:16 <begriffs> glguy: this is how the type is built http://hackage.haskell.org/package/postgresql-simple-0.4.2.3/docs/src/Database-PostgreSQL-Simple-Types.html#Query
23:09:42 <begriffs> I wonder if it is even possible to overcome this problem or if Haskell is just too strict.
23:10:31 <abstract-alf> [[Just 1, Just 2, Just 3],[Just 4, Just 5, Just 6],[Just 7, Just 8, Just 9]] & traverse.traverse .~ Nothing
23:10:34 <abstract-alf> > [[Just 1, Just 2, Just 3],[Just 4, Just 5, Just 6],[Just 7, Just 8, Just 9]] & traverse.traverse .~ Nothing
23:10:35 <lambdabot>  [[Nothing,Nothing,Nothing],[Nothing,Nothing,Nothing],[Nothing,Nothing,Nothing]]
23:11:03 <glguy> begriffs: You just use the "fromString" method of "IsString"
23:11:30 <dwcook_> jle`: The base pipes library seems not to use any lens-like things though.
23:11:47 <glguy> begriffs: and that module appears to export the Query constructor
23:11:52 <abstract-alf> now, say I have a list of compound list indexes... [(1,1),(2,1),(3,3)]... how can I set Nothing only at those coordinates of my original list?
23:11:55 <abstract-alf> > [[Just 1, Just 2, Just 3],[Just 4, Just 5, Just 6],[Just 7, Just 8, Just 9]] & traverse.traverse .~ Nothing
23:11:57 <lambdabot>  [[Nothing,Nothing,Nothing],[Nothing,Nothing,Nothing],[Nothing,Nothing,Nothing]]
23:12:01 <jle`> dwcook_: ah. perhaps not. but i think the non-base pipes libraries use lenses here and there throughout
23:12:07 <jle`> and base lens is pretty minimal
23:12:12 <pjdelport> begriffs: You can just construct the query directly with a bytestring, can't you?
23:12:23 <jle`> i doubt you can do too much with just base lens
23:12:27 <pjdelport> begriffs: It doesn't hide the constructors.
23:13:04 <abstract-alf> am I looking for a prism?
23:13:07 <pjdelport> begriffs: Just make sure that your ByteString is UTF-8 encoded.
23:13:42 <begriffs> So "select * from foo" gets automatically coerced into Query, but not "select * from " ++ x   (where x is a ByteString)
23:16:12 <dwcook_> begriffs: Is there a Monoid instance for this newtype?
23:16:55 <dwcook_> begriffs: Yep, looks like. Why not use that?
23:17:18 <pjdelport> begriffs: If you want to insert a table name like that, shouldn't you be using the library's Identifier type to make sure it's quoted right?
23:17:25 <dwcook_> Or that
23:17:58 <pjdelport> begriffs: The newtype is there precisely to prevent the kind of error you're making by trying to concatenate an identifier unquoted. :)
23:18:18 <begriffs> It gets cryptic when I try to concatenate: Couldn't match expected type ‘[a0]’ with actual type ‘BL.ByteString’
23:18:27 <glguy> > set ((traversed <.> traversed) . indices (`elem` [(1,1),(2,1),(3,3)])) Nothing [[Just 1, Just 2, Just 3],[Just 4, Just 5, Just 6],[Just 7, Just 8, Just 9]]
23:18:29 <lambdabot>  Couldn't match expected type ‘(a0
23:18:29 <lambdabot>                                 -> Data.Functor.Identity.Identity (Data.Maybe...
23:18:29 <lambdabot>                                -> p0 (Data.Maybe.Maybe a2) (Data.Functor.Iden...
23:18:29 <lambdabot>              with actual type ‘[i0]’Couldn't match expected type ‘GHC.Arr.Arr...
23:18:29 <lambdabot>              with actual type ‘(t0, t1) -> GHC.Types.Bool’
23:18:35 <glguy> [[Just 1,Just 2,Just 3],[Just 4,Nothing,Just 6],[Just 7,Nothing,Just 9]]
23:18:41 <glguy> (in non-outdated lens)
23:19:03 <glguy> That's about the closest I could think of without multiple passes, one for each index
23:19:42 <begriffs> nor will it convert a ByteString when asked such as myByteString :: Query. That also is a could not match expected type error.
23:21:00 <pjdelport> begriffs: I think you probably have to say something like "select * from ? where ...", and pass the table name as an Identifier parameter.
23:21:21 <begriffs> pjdelport: yeah, I would ordinarily use question marks in my queries and let it get quoted, but in this case I don't know the name of the table I am selecting from and I am not allowed to use a question mark there.
23:21:30 <begriffs> "select * from ?"
23:22:00 * hackagebot JustParse 2.1 - A simple and comprehensive Haskell parsing library  http://hackage.haskell.org/package/JustParse-2.1 (grantslatton)
23:22:31 <pjdelport> begriffs: I'm not familiar with the library, but there is an Identifier type, which you almost certainly should be using somehow.
23:22:32 <begriffs> It's seems like a case where I have to bend the rules. The more general context is that I am making a server that creates a REST API for an arbitrary database, so it introspects the database then creates routes that read from various tables.
23:22:52 <augur> any parsecers around? :(
23:23:14 <pjdelport> begriffs: If ?-parameters isn't the way, there must be some other way in the library.
23:23:35 <begriffs> pjdelport: postgres itself does not allow a question mark in the table name because its planner could not prepare a query like that.
23:24:01 <pavonia> augur: The answer to that question is of type Maybe Bool
23:24:01 <pjdelport> begriffs: I know, but does the library handle that if you pass an Identifier as parameter?
23:24:10 <augur> pavonia: :)
23:24:22 <dwcook_> True, False, FileNotFound
23:25:22 <begriffs> dwcook_: I tried using mappend but still got stuck. ("select * from" `mappend` tableName) has trouble because it can't coerce tableName to a Query hence can't append it to the other query.
23:25:33 <abstract-alf> glguy, thanks. that works for me in ghci.  is lambdabot using an older version of lens?
23:25:58 <dwcook_> begriffs: "Coercing" is probably understanding something wrong. How is tableName defined?
23:25:58 <pjdelport> begriffs: Oh, there is a ToField instance for Identifier. That's what you should be using, I'm sure.
23:29:20 <pjdelport> begriffs: Ergh. It actually looks like the library doesn't pass ?-parameters to PostgreSQL at all, if I read this right.
23:29:54 <pjdelport> begriffs: So yeah, you should definitely just be passing the table name as a ? parameter with an Identifier value.
23:30:55 <begriffs> pjdelport: I think I tried that, but let me try again.
23:31:56 <pjdelport> begriffs: That's a really surprising design choice for the library, though.
23:32:08 <abstract-alf> > [[Just 1, Just 2, Just 3],[Just 4, Just 5, Just 6],[Just 7, Just 8, Just 9]] & ((traversed <.> traversed) . indices (`elem` [(1,1),(2,1),(3,3)])) .~ Nothing
23:32:09 <lambdabot>  Couldn't match expected type ‘(a1
23:32:10 <lambdabot>                                 -> Data.Functor.Identity.Identity (Data.Maybe...
23:32:10 <lambdabot>                                -> p0 (Data.Maybe.Maybe a0) (Data.Functor.Iden...
23:32:10 <lambdabot>              with actual type ‘[i0]’Couldn't match expected type ‘GHC.Arr.Arr...
23:32:10 <lambdabot>              with actual type ‘(t0, t1) -> GHC.Types.Bool’
23:32:20 <abstract-alf> lambdabot using an older version of lens?
23:32:56 <abstract-alf> I get [[Just 1,Just 2,Just 3],[Just 4,Nothing,Just 6],[Just 7,Nothing,Just 9]]
23:32:56 <abstract-alf>  in ghci
23:33:06 <begriffs> pjdelport: now it fails at runtime with a sql error. Here's the function I'm working on https://gist.github.com/begriffs/7772f023272303d567b1
23:33:51 <pjdelport> begriffs: You need to tag the table name with the Identifier newtype, or it won't be quoted correctly.
23:34:17 <pjdelport> begriffs: So that should be (Only $ Identifier table), I'm guessing.
23:35:00 <pjdelport> Without Identifier, it will be quoted as an SQL string literal instead.
23:37:16 <haasn> :t indices -- abstract-alf
23:37:17 <lambdabot> Ix i => Array i e -> [i]
23:37:23 <haasn> :t Lens.indices
23:37:24 <lambdabot> (Indexable i p, Applicative f) => (i -> Bool) -> Optical' p (Indexed i) f a a
23:37:35 <begriffs> pjdelport: Not in scope: data constructor ‘Identifier’
23:37:49 <pjdelport> begriffs: You'll have to import it from Types.
23:38:06 <pjdelport> Just out of interest to the channel: is there a Haskell PostgreSQL library that doesn't use client-side interpolation?
23:39:01 <pjdelport> HDBC?
23:41:12 <begriffs> Ah, it is QualifiedIdentifier that I can use.
23:42:58 <pjdelport> You only need QualifiedIdentifier if you're passing a schema, too. I assume it does the same thing as Identifier if you leave out the schema, though.
23:45:35 <Qfwfq> How would you define 'combinator'? Is it a specific class of function? With what property?
23:49:36 <augur> Qfwfq: theres no real definition
23:49:37 <begriffs> pjdelport: thanks a lot, that would have taken me forever to figure out.
23:49:53 <pjdelport> No problem. :)
23:50:39 <pavonia> Something you can combine into another combinator
23:51:05 <abstract-alf> glguy: thanks again for `set ((traversed <.> traversed) . indices...` expression
23:51:20 <abstract-alf> you've set me off in the exact direction I needed to go
23:54:26 <Welkin> is there a function like readHex for binary?
23:56:34 <centrinia> :t readInt
23:56:36 <lambdabot> Num a => a -> (Char -> Bool) -> (Char -> Int) -> ReadS a
23:57:23 <Welkin> yes, but to convert binary into decimal
23:57:48 <redtricycle> I'm using .cabal file to manage my program, how do I organize some subrouties into a re-usable library?
23:58:06 <immersion> Welkin, readInt will let you parse a number in any base. Just pass appropriate functions for (Char -> Bool) and (Char -> Int)
23:58:30 <immersion> Welkin, check out the doc http://hackage.haskell.org/package/base-4.7.0.0/docs/Numeric.html#v:readInt
23:58:36 <centrinia> > readInt 2 (`elem` "01")  (fromJust . (`elemIndex` "01")) "1011"
23:58:38 <lambdabot>  [(11,"")]
23:59:01 <redtricycle> I can use other libraries by putting them in build-depends, but how do I call my own libraries?
23:59:24 <centrinia> @let readBin = readInt 2 (`elem` "01")  (fromJust . (`elemIndex` "01"))
23:59:27 <lambdabot>  Defined.
23:59:45 <Welkin> thank you
