00:05:22 <crazydave> I'm trying to understand the snapframework and there's a lot of "this is just a monad transformer" which if I knew what a monad transformer was I might be able to understand.  Is there a good tutorial on monad transformers?
00:05:44 <crazydave> I vaguely understand what a monad is but not nearly well enough to explain it to someone else
00:22:00 <sofancy> crazydave, http://book.realworldhaskell.org/read/monad-transformers.html they also have pages on monads
00:23:23 <jle`> crazydave: this was the paper that finally made it click for me --- http://www.cs.virginia.edu/~wh5a/personal/Transformers.pdf
00:24:04 <crazydave> ah, alright thanks.  I've read bits of that book before.  And I've read up on monads before but just enough to understand how to do IO mostly.  So definitely need more!
00:24:41 <crazydave> that paper looks comprehensive too.  So good ... I've got reading to do!
00:25:02 <jle`> crazydave: cheers :)
00:53:31 * hackagebot dson 0.1.0.0 - Haskell DogeScript Object Notation Parser  http://hackage.haskell.org/package/dson-0.1.0.0 (lcycon)
00:53:33 * hackagebot dson 0.2.0.0 - Haskell DogeScript Object Notation Parser  http://hackage.haskell.org/package/dson-0.2.0.0 (lcycon)
00:58:32 * hackagebot dson 0.2.0.1 - Haskell DogeScript Object Notation Parser  http://hackage.haskell.org/package/dson-0.2.0.1 (lcycon)
00:59:52 <frerich> I really enjoy how people are cranking out those Haskell packages, but I am a bit worried when I see things like this 'dson' upload which seems to have zero documentation or examples. Isn't that actually cluttering Haskell, making harder to find the relevant stuff?
01:00:03 * frerich occasionally wished there was some kind of review/approval process
01:06:56 <Enigmagic> i think the same thing about the internet sometimes ;-)
01:11:14 <orzo> haddock documentation should be wikified and authors could just pull from the wiki back into their code
01:11:32 <ion> hear, hear
01:12:08 <dsturnbull> what's wrong with dson? "parseDson :: String -> Maybe DSON" seems pretty well documented
01:12:18 <somedude> Does anyone know if the mathlink package is still being maintained?  Cabal is giving me hell (conflict: mathlink => base>=4.0 && <4.3) and it looks like the project hasn't been touched since 2009...
01:21:20 <jle`> yeah i'm not sure how much more documented you can get
01:21:46 <orzo> we should have a c-to-haskell compiler
01:22:48 <xpikab> the sequence data structure has a faster append than the list type. is there any structer which has a faster fmap?
01:23:48 <fizruk> xpikab: what do you mean?
01:24:13 <pavonia> Faster than O(n)?
01:24:17 <orzo> you realize that fmap on a list doesnt imply an order-n pass oover the list, right?
01:24:31 <orzo> i mean, if you dont use the whole list
01:24:39 <orzo> due to laziness
01:24:54 <xpikab> > map (reverse) [[1,2],[3,4],[5,6]
01:24:55 <lambdabot>  <hint>:1:33:
01:24:55 <lambdabot>      parse error (possibly incorrect indentation or mismatched brackets)
01:25:03 <xpikab> > map (reverse) [[1,2],[3,4],[5,6]]
01:25:04 <lambdabot>  [[2,1],[4,3],[6,5]]
01:25:12 <xpikab> something that does that faster
01:25:32 <orzo> i believe sequence does reverse faster
01:25:33 <orzo> heh
01:26:03 <orzo> isnt sequence reverse O(1) ?
01:26:06 <xpikab> reverse is just an example
01:26:23 <xpikab> im iterested in the map generally
01:26:36 <fizruk> orzo: docs says it’s O(n)
01:28:20 <orzo> well its trivial to implement an O(1) reverse, isnt it?  Just have a flag that changes which side is right and which side is left
01:28:37 <fizruk> xpikab: map in generally is efficient (per se) and it fuses with other maps (and some other transformations): map f . map g = map (f . g)
01:28:50 <fizruk> xpikab: i don’t know what else do you want
01:29:50 <quchen> You can't have O(1) reverse because lists are singly linked; to access the last element, you have to walk the entire list.
01:30:18 <orzo> seems strange to even bother exporting a "reverse" that os O(n) when the caller would be better off keeping a flag around
01:30:53 <orzo> quchen: Data.Sequence.Seq.  Not list
01:31:45 <fizruk> orzo: seems though that Seq.reverse is lazy
01:34:22 <orzo> there shuld be a tool to migrate a c program into haskell by compiling it into something you can work with
01:35:01 <orzo> it should attempt to find folds and maps
01:35:31 <bjornars> that should be trivial once we solve halting
01:35:34 <Enigmagic> there should be a tool that takes discussions on irc about software and turns them into real software
01:35:38 <orzo> heh
01:36:03 <orzo> well it can find simple cases of folds and maps i guess
01:36:06 <lwm> haaaaa
01:36:39 <orzo> well if i'm the only one who would want such a tool, i'm certinaly not gonna put any devel effort into it
01:39:32 <merijn> orzo: Considering the difficulty most C compilers have to detect even trivial vectorisation, I think you may be overestimating how "simple" this is :)
01:40:07 <orzo> alright, maybe it wont find any folds and maps
01:40:17 <lieven_> to be fair, C compilers have a difficult task because everything can be aliased to everything. fortran compilers historically have been much better at this.
01:40:20 <orzo> but it will make haskell you can work with
01:40:28 <merijn> lieven_++
01:40:30 <orzo> probably a lot of monad code that is close to the original c
01:40:42 <dsturnbull> yeah, everything will be IO :)
01:40:45 <orzo> ya
01:40:47 <merijn> C is a terrible language for high performance, tbh
01:40:48 <orzo> but thats something
01:41:45 <orzo> ghc is not good at extending c programs
01:41:53 <dsturnbull> merijn: how so?
01:41:53 <orzo> it assumes your main program is haskell
01:41:55 <merijn> orzo: I think doing this automatically will be very hard, but gradually refactoring from C to haskell should be doable. Just call your C code via the FFI
01:42:16 <orzo> yes, well, ive linked haskell modules into c before
01:42:26 <dsturnbull> merijn: i would say that performance is reasonably easy to achieve, but let's not talk about stability or security
01:42:28 <orzo> and it was a pita due to the fact that ghc wants to be the build system
01:42:37 <merijn> dsturnbull: Aliasing issues and lack of proper arrays means optimising numerical code is stupid hard in C
01:42:55 <merijn> dsturnbull: Fortran is orders of magnitude better than C for high performance numerical code
01:43:13 <orzo> maybe the right fix is to make it easier to write portions of a program (not main) in haskell
01:43:16 <dsturnbull> merijn: true. i speak only of general purpose, syscall-heavy work. for numerical, i assume you acn overcome it with gpus now?
01:43:20 <arj> is there an online pastebin like page that includes an interpreter?
01:43:37 <mT37m> hey guys, can the following expression be rewritten so it doesn't need that lambda anymore: filter (\a -> (fst a) == 2.0) [(2,5),(4,9), ...] ? thanks
01:43:39 <merijn> dsturnbull: Yes, but you still don't want to write your GPU code in C :)
01:43:48 <merijn> dsturnbull: There's a reason nVidia has a fortran compiler :)
01:43:53 <quchen> arj: codepad.org, ideone.com
01:44:06 <orzo> i guess you could have main = c_main
01:44:09 <orzo> heh
01:44:30 <merijn> orzo: Cabal already supports non haskell main functions
01:44:38 <dsturnbull> merijn: i didn't realise that. do you know if the haskell cuda compiler is reasonable?
01:44:40 <merijn> orzo: I have a cabal project lying around with a C main file
01:44:46 <fizruk> :t (== 2.0) . fst   -- mT37m
01:44:47 <lambdabot> (Fractional b, Eq b) => (b, b1) -> Bool
01:44:54 <quchen> mT37m: Every expression can be written to not have any lambdas.
01:45:05 <mT37m> fizruk: oh, of course. thanks :)
01:45:17 <merijn> dsturnbull: For real work? Probably not, although purely functional can definitely work for numerical stuff
01:46:13 <merijn> dsturnbull: I have some colleagues working on a purely functional language for matrix programming and they get some pretty impressive speedup on "naive" code, usually close to hand-optimised C. They support compilation to CUDA and OpenCL too, although that's all very experimental
01:46:36 <merijn> dsturnbull: It's still a bit hit-and-miss though, performance can be terrible if some important optimisations don't kick in
01:46:47 <orzo> merijn: so you have a big c program with say 200 source files organized in subtrees with automake as a build system, you can just drop cabal in now?
01:47:10 <dsturnbull> merijn: does haskell miss anything that fortran can do in that regard?
01:47:20 <merijn> orzo: Cabal supports custom build hooks, it even ships with autoconf build hooks for C code
01:48:41 * hackagebot typeparams 0.0.2.0 - Lens-like interface for type level parameters; allows unboxed unboxed vectors and supercompilation  http://hackage.haskell.org/package/typeparams-0.0.2.0 (MikeIzbicki)
01:49:18 <merijn> dsturnbull: Yeah, there's no real focus on doing vector/matrix stuff efficiently. There's some good libraries and carter is working on more stuff, but haskell doesn't have a built-in notion of arrays that the compiler use to optimise. Fortran on the other hand has support for arrays in the compiler, which means that if you do things like for loops multiplying arrays the compiler can trivially do this in parallel
01:49:42 <dsturnbull> merijn: right, what i mean is if the type system can express everything equally
01:49:50 <merijn> dsturnbull: I'm pretty sure you could extend haskell to have array primitives, I just don't think it's a high priority for people
01:49:58 <dsturnbull> because i assume ghc will eventually become a behemoth that optimises damn near everything
01:51:14 <merijn> dsturnbull: If the question is "would it be possible to have strongly typed/haskell-like languages with proper array support like fortran?" then the answer is "yes, definitely" if they question is "is this likely to happen in GHC/haskell any time soon?" then I would say "no"
01:52:07 <merijn> orzo: So it's definitely possible to just have automake build your C stuff and have cabal link it into the resulting application
01:52:46 <arj> quchen: thanks!
01:53:03 <merijn> orzo: The simplest would be to have a C main file, your haskell code and compile all remaining C code to a library (using automake or whatever) and then have cabal link the main file, your haskell code and the library together
01:53:48 <lwm> damn that would be cool
01:54:37 <merijn> orzo: Having automake build your main file too would probably make this pretty complex to do, but if your okay with cabal compiling your main file but not anything else this should be pretty easy?
01:56:10 <merijn> orzo: Alternatively, you could use cabal to build a haskell library and link that into your automake build system?
02:14:41 <elspru> what is that feature called where can only declare a variable once?
02:15:22 <nclarke> There's 'warn-shadowing'
02:15:27 <nclarke> Is that what you mean?
02:15:31 <frerich> elspru: "immutability"?
02:15:40 <miguelnegrao> hi
02:15:47 <m09> values instead of variables in that case btw
02:16:06 <frerich> m09: Yeah, and "define" instead of "declare" in the Haskell context.
02:16:19 <elspru> so immutable values?
02:17:15 <sipa> i'd say values are by definition immutable; if you modify the value 1, it's not 1 anymore
02:17:22 <sipa> </nitpick>
02:17:24 <frerich> elspru: I don't think I remember having heard people talk about "immutable values" when talking about Haskell.
02:17:58 <sipa> but haskell "variables" are really just names for a (at runtime known) value
02:18:21 <frerich> elspru: Is this an (expected?) question of some sort of examn or test or something?
02:18:37 <elspru> right, so what do you call it then?  say i do several transfomrations, let a = 2+2; let b = a+2.
02:18:39 <miguelnegrao> I'm trying the examples for parallel programming from RWH but using their source code, the list sorting example is slower with -N4 then -N1... any idea what's happening here ?
02:19:03 <m09> miguelnegrao: do you compile with -threaded?
02:19:06 <elspru> well I'm coding in assembly, in the functional programming style, I would just like to express that the variables have only been assigned once.
02:19:38 <t7> @hoogle Bool -> m ()
02:19:40 <lambdabot> Control.Monad guard :: MonadPlus m => Bool -> m ()
02:19:40 <lambdabot> Network.BSD setHostEntry :: Bool -> IO ()
02:19:40 <lambdabot> Network.BSD setNetworkEntry :: Bool -> IO ()
02:19:44 <shachaf> elspru: Maybe "static single assignment" form is relevant to you, depending on what you mean by variable.
02:19:53 <elspru> I could say single-assignment I guess, just I thought there was a term for it in Haskell.
02:19:53 <miguelnegrao> ghc -threaded -O2 --make SortMain
02:19:54 <miguelnegrao> yes
02:20:02 <t7> @hoogle unless
02:20:02 <lambdabot> Control.Monad unless :: Monad m => Bool -> m () -> m ()
02:20:12 <m09> miguelnegrao: and how do you launch your program?
02:20:12 <miguelnegrao> or actually sometimes is faster, sometimes not...
02:20:25 <miguelnegrao> m09: ./SortMain +RTS -N1 -RTS 700000
02:20:31 <m09> ok
02:20:39 <t7> > unless True (Just ())
02:20:41 <lambdabot>  Just ()
02:20:47 <t7> > unless Fale (Just ())
02:20:48 <lambdabot>  Not in scope: data constructor ‘Fale’
02:20:48 <lambdabot>  Perhaps you meant ‘False’ (imported from Data.Bool)
02:20:49 <t7> > unless False (Just ())
02:20:51 <lambdabot>  Just ()
02:21:13 <miguelnegrao> m09: it's a 4 core , core i7
02:22:11 <m09> so which sort is it exactly? There are several examples
02:22:34 <miguelnegrao> m09: testFunction = parSort2 2
02:22:38 <m09> k
02:23:15 <miguelnegrao> m09: sometimes is faster, but not much. 6.312149 vs 6.312149 for 900000 elements
02:23:34 <miguelnegrao> m09: sorry 6.312149 vs 6.565122
02:23:57 <m09> yup it's not stellar indeed. And with N2?
02:24:00 <miguelnegrao> shouldn't the difference be bigger ?
02:24:22 <miguelnegrao> 6.884156
02:24:49 <miguelnegrao> code from http://examples.oreilly.com/9780596514983/rwh-examples2.zip
02:25:14 <m09> I'll check on my machine and tell you if I have the same results
02:25:27 <miguelnegrao> m09: and btw, I've pinned all cores at 2.0GHz (linux here)
02:25:53 <miguelnegrao> m09: examples/ch24
02:27:29 <m09> yup on my machine results are also very similar. On 8 cores it's even way worse
02:28:01 <m09> RWH is getting (a bit) old so maybe some of the insights given in this chapter are no longer relevant
02:28:31 <m09> btw on this topic, http://chimera.labs.oreilly.com/books/1230000000929 by Simon Marlow is really awesome
02:28:38 <m09> I enjoyed it cover to cover
02:28:45 * hackagebot linux-mount 0.2.0.1 - Mount and unmount filesystems  http://hackage.haskell.org/package/linux-mount-0.2.0.1 (NicolaSquartini)
02:29:10 <miguelnegrao> m09: ok, it's still kind of the standard to learn this kinds of things... a bit disapointment that it's not so straightforward to get good performance...
02:29:20 <miguelnegrao> m09: I'll check that one
02:30:20 <miguelnegrao> m09: thanks for checking this
02:30:52 <m09> miguelnegrao: btw did you try to profile the program with ThreadScope?
02:31:11 <miguelnegrao> m09: nope...
02:31:40 <m09> you might want to, it's an amazing tool to understand what's happening in a parallel program
02:31:44 <m09> http://www.haskell.org/haskellwiki/ThreadScope
02:33:22 <t7> would be nice if there was syntax for this:    foo >>= \x -> case x of      so i could just do     mcase foo of
02:34:05 <FireFly> isn't there sugar for \x -> case x of ... ?
02:34:27 <Qfwfq> LambdaCase
02:35:31 <Qfwfq> Can't mcase without a TH case representation, I don't think.
02:36:26 <miguelnegrao> m09: yes it's interesting. I see bits of work on all cores separated by bits where only one core is running the gc.
02:36:29 <Qfwfq> But '-XLambdaCase', 'foo >>= \case { a -> b; c -> d }' works.
02:37:27 <miguelnegrao> m09: at one point the gc is running for 1.5s !!!
02:37:37 <merijn> miguelnegrao: Which GHC version?
02:37:38 <m09> huh
02:37:54 <miguelnegrao> m09: 7.6.3
02:38:35 <merijn> There were some changes to make the GC scale better on multicores, but I think those were in 7.8?
02:39:38 <t7> @hoogle a -> b -> a
02:39:39 <lambdabot> Prelude const :: a -> b -> a
02:39:40 <lambdabot> Data.Function const :: a -> b -> a
02:39:40 <lambdabot> Prelude seq :: a -> b -> b
02:41:19 <miguelnegrao> ok, thanks everyone !
02:42:16 <m09> too bad, he left just when I noticed that almost all the sparks were GC(d
02:42:19 <m09> GC'd
02:42:29 <m09> anyway :(
02:46:57 <t7> @hoogle Maybe a -> Either a ()
02:46:58 <lambdabot> Prelude Left :: a -> Either a b
02:46:58 <lambdabot> Data.Either Left :: a -> Either a b
02:46:59 <lambdabot> Prelude Right :: b -> Either a b
02:50:37 <Yuu_chan> :t maybe (Right ()) Left
02:50:38 <lambdabot> Maybe a -> Either a ()
02:52:34 <KorriX> Hello! Is there any lens version of uncurry function?
02:53:00 <KorriX> I'd like to uncurry atan2 $ V2 10 10 -- V2 is from linear library
02:53:19 <FireFly> you got a reply in the channel you just left..
02:53:52 <KorriX> Javran: I lost my internet connection. Could you repost?
02:54:51 <KorriX> Javran Thanks
02:55:45 <Yuu_chan> Someone mentioned lens and edwardk wasn't summoned!
02:56:01 <hayashi> Yuu_chan: we didn't do the appropriate summoning ritual
02:58:48 * hackagebot ekg-core 0.1.0.1 - Tracking of system metrics  http://hackage.haskell.org/package/ekg-core-0.1.0.1 (JohanTibell)
02:58:50 <KorriX> Javran: Ok, but uncurried works only for tuples
02:59:16 <KorriX> Javran: I'd like something for other types working with lens
03:06:11 <sofancy> should i always avoid foldl in favor of foldl'?
03:08:57 <hpc> sofancy: there are some cases where foldl will produce a defined value and foldl' will not
03:09:28 <hpc> in general, you will want to prefer foldl', yes
03:09:53 <heudebeu> unless you are working with infinite lists?
03:10:04 <hpc> foldl will already choke on infinite lists
03:10:16 <sofancy> hpc, alright, thanks. do you have any example where foldl would be better?
03:11:09 <hpc> yeah, sec
03:11:11 <hpc> :t foldl
03:11:12 <lambdabot> (b -> a -> b) -> b -> [a] -> b
03:11:31 <hpc> > foldl const 0 [undefined]
03:11:33 <lambdabot>  0
03:11:37 <hpc> > foldl' const 0 [undefined]
03:11:39 <lambdabot>  0
03:11:56 <hpc> > foldl const 0 (0:undefined)
03:11:58 <lambdabot>  *Exception: Prelude.undefined
03:12:01 <hpc> hmm
03:12:19 <hpc> @src foldl
03:12:19 <lambdabot> foldl f z []     = z
03:12:19 <lambdabot> foldl f z (x:xs) = foldl f (f z x) xs
03:12:23 <hpc> @src foldl'
03:12:23 <lambdabot> foldl' f a []     = a
03:12:23 <lambdabot> foldl' f a (x:xs) = let a' = f a x in a' `seq` foldl' f a' xs
03:12:45 <hpc> hmmmmm
03:13:48 <crazydave> hpc: you need the undefined later
03:14:21 <crazydave>  > foldl const 0 [0, undefined, 1, 2]
03:14:41 <hpc> > foldl const 0 [0, undefined, 1, 2]
03:14:43 <lambdabot>  0
03:14:46 <hpc> > foldl' const 0 [0, undefined, 1, 2]
03:14:47 <lambdabot>  0
03:14:57 <hpc> > foldl (flip const) 0 [0, undefined, 1, 2]
03:14:59 <lambdabot>  2
03:15:06 <hpc> > foldl' (flip const) 0 [0, undefined, 1, 2]
03:15:08 <lambdabot>  *Exception: Prelude.undefined
03:15:12 <hpc> there we go!
03:15:24 <hpc> sofancy: found it!
03:15:49 <sofancy> hpc, ooh, i see now
03:15:57 <crazydave> ahhh yes, has to be lazy in its FIRST param
03:16:42 <sofancy> hpc: thanks :)
03:16:48 <crazydave> then the `seq` will blow up foldl' but foldl will happily return a result
03:17:06 <crazydave> "blow up" is the correct technical term :)
03:17:15 <hpc> sofancy: also, as a disclaimer, strictness is a tricky thing and don't take anything i say as an absolute rule until you have a better understanding of it
03:22:41 <t7> @hoogle a -> Maybe b -> Either a b
03:22:42 <lambdabot> Text.Parsec.Prim runP :: Stream s Identity t => Parsec s u a -> u -> SourceName -> s -> Either ParseError a
03:22:42 <lambdabot> Text.Parsec.Prim runParser :: Stream s Identity t => Parsec s u a -> u -> SourceName -> s -> Either ParseError a
03:22:42 <lambdabot> Text.ParserCombinators.Parsec.Prim runParser :: GenParser tok st a -> st -> SourceName -> [tok] -> Either ParseError a
03:22:55 <t7> anyone know a function like that?
03:23:10 <t7> if b is Just then return Right b
03:23:18 <t7> else Left a
03:34:42 <FireFly> @ty maybe
03:34:42 <lambdabot> b -> (a -> b) -> Maybe a -> b
03:35:01 <FireFly> maybe (const x) Right
03:35:44 <FireFly> @pl \x -> maybe (const x) Right
03:35:44 <lambdabot> flip maybe Right . const
03:40:07 <sofancy> t7: http://lpaste.net/105164 like that? or maybe i don't understand
03:42:55 <FireFly> Just like that
03:43:09 <FireFly> although I think t7 was looking for something built-in
03:44:28 <mikusp> Hi. Most tutorials about writing Haskell bindings to foreign code write foreign function signatures using types from Foreign.C.Types, e.g. CInt -> CInt -> CInt -> CDouble. Is there any difference if I used vanilla Haskell types in foreign import declaration?
03:44:33 <t7> i have   fromMaybe (Left a) (Right <$> b)    :(
03:45:52 <ryankask> Hi everyone. I'm new to Haskell and I created a server  that listens for HTTP requests like "/complete/apple" and it will return a JSON list of words that start with apple. I put the project here https://github.com/ryankask/rievaulx/tree/master/src .. the problem is I'm getting a bunch of stack overflows and want figure out why
03:45:54 <Philonous> Argh, having to reflect values between types and value land by hand is so tedious...
03:49:09 <t7> is asymmetric unification a thing in type inference?
03:49:19 <ryankask> the stack overflows only happen when the server is running. If I do the lookups in GHCi, it works as expected
04:01:29 <quchen> ryankask: Your insertMany function looks like it could overflow for large lists.
04:01:52 <quchen> You're using foldl', but all that is forcing is the outermost constructor of your tree repeatedly.
04:04:04 <ryankask> quchen: thanks for having a look. it's strange because it doesn't always cause errors. for some prefixes, it works (it also works in GHCi).
04:04:27 <quchen> Maybe your input list isn't as long in GHCi?
04:08:56 <ryankask> well, it's the same list of words. I don't balance the list at all and instead randomize the words before inserting them. because it only happens when I search for certain prefixes, might it have something to do with this function: https://github.com/ryankask/rievaulx/blob/master/src/Rievaulx.hs#L67
04:09:16 <ryankask> with the list concatenation?
04:11:56 <quchen> What's that function supposed to do anyway?
04:12:39 <ryankask> it finds all the words in the tree
04:14:16 <chip2n> Sup guys. What would be the easiest way to monitor a file in Haskell for changes? I got some logs from another program, each of which gets appended to a single log file. Can you do this with the io-streams package?
04:15:10 <ryankask> getPrefixTree tree "apple" will find the tree that has all the words that start with "apple", then collect returns the complete words in that tree. kind of confusing i guess
04:15:35 <osa1_> chip2n: we have inotify bindings if that works.
04:15:42 <ryankask> maybe it's better to helicopter up... is there a standard course of action when a stack overflow occurs?
04:16:41 <quchen> Oh, you have a trie and you want to specify a prefix, then retrieve a list of all the things in the trie that start with that prefix
04:17:26 <osa1> chip2n: if you search for "watcher" on hackage there are several packages related with filesystem watching
04:17:32 <ryankask> quchen: yes, this is what I was reading: http://igoro.com/archive/efficient-auto-complete-with-a-ternary-search-tree/
04:18:13 <t7> it worx >:)
04:18:32 <t7> partial type inference for system-F
04:19:11 <chip2n> osa1: I'll check inotify and the watcher stuff on Hackage out, thanks :)
04:21:42 <quchen> ryankask: By the way, pattern match on the result of `compare` here, https://github.com/ryankask/rievaulx/blob/master/src/Rievaulx.hs#L27
04:22:02 <quchen> Works even for evil Ord instances.
04:22:48 <blikken> Can I use a module as a first-class value?
04:23:03 <quchen> No.
04:23:10 <blikken> aww, ok
04:23:38 <quchen> Would sometimes be neat though.
04:23:55 <quchen> It would probably also make people send modules over concurrent communication channels and things like these ;-)
04:24:10 <blikken> :)
04:24:37 <blikken> Would be nice to adapt modules to typeclasses if they implement the right interface
04:27:11 <ryankask> quchen: can you clarify? is that something like ``case compar x v of LT -> ... `` etc?
04:27:53 <merijn> blikken: You might want to look into OCaml's module system if you think things are that like interesting. They do have first class modules that can be parameterised
04:28:10 <Philonous> ryankask, That's what was meant
04:28:57 <Profpatsch> What Emacs packages do you use for Haskell development?
04:29:32 <quchen> ryankask: Yes, like that.
04:30:10 <Profpatsch> E.g. I’d like to have a shortcut for automatically inserting the inferred type (should be handy with parsec).
04:30:29 <quchen> ryankask: Your current implementation requires two comparisons in case of equality, and the use case for Ordering is precisely this anyway.
04:30:46 <ryankask> quchen: that's interesting, thanks!
04:31:17 <blikken> merijn: yeah, it's module system is pretty powerful. I'm happy with haskell though, it's not a huge deal, you can always work around it easily with typeclasses etc
04:31:30 <blikken> merijn: it's one of those things where you go "oh wouldn't that be nice..."
04:32:08 <quchen> blikken: It's a hobby of most haskellers to occasionally dream about parameterized modules :-þ
04:32:41 <silver> :D
04:32:48 <silver> yeah :<
04:34:06 <blikken> :)
04:34:41 <Maxdamantus> Are the first class-modules closures that have types based essentially on their positions in the source code?
04:34:56 <Profpatsch> Anyone here who uses Emacs for development?
04:35:09 * Maxdamantus looks.
04:35:36 <blikken> I was wondering, I'm still fairly new to haskell, but I often find that I start out with some non-monadic code, and then later I determine that I want to parameterize it over some monad. I then have to go in and rewrite/adapt large parts of a module to make it monadic
04:36:11 <blikken> Is that just typical newbie behaviour, or is this typical?
04:36:33 <Philonous> blikken, You should only have to change it of you want to use the monadic effects inside that code
04:36:56 <hayashi> does remind me of how I often end up writing list-specific things, then realising they generalise to monoids and that simplifies a lot of code
04:37:55 <blikken> Philonous: yeah, that's what I'd hope. Basically my problem is that I have some monadic code, which is used by other purely computational code
04:38:18 <blikken> Philonous: specifically I'm using streams, and the input may actually need some effects (e.g. read from disk)
04:38:41 <Kaidelong> @hoogle (a -> b) -> Kleisli m a b
04:38:42 <lambdabot> No results found
04:38:49 <blikken> Philonous: the rest, map, filter etc, doesn't really care about this, but it needs to sequence the results
04:38:57 <Kaidelong> @hoogle (a -> b) -> (a -> m b)
04:38:58 <lambdabot> Prelude ($) :: (a -> b) -> a -> b
04:38:58 <lambdabot> Data.Function ($) :: (a -> b) -> a -> b
04:38:58 <lambdabot> Prelude ($!) :: (a -> b) -> a -> b
04:39:23 <Philonous> blikken, Streaming libraries allow you to do just that
04:39:30 <Philonous> blikken, like pipes / conduits
04:39:44 <blikken> Philonous: yeah I tried those, but the performance was atrocious
04:39:53 <Kaidelong> blikken: also if you can make a pure function at all you don't actually need the effects there, you can compose it into what you do need the effects for
04:40:02 <Kaidelong> using fmap
04:40:57 <blikken> Kaidelong: I think the problem is with stream composition: some computational stream pulls from another stream by calling it with its state
04:41:20 <blikken> Kaidelong: but that stream itself is monadic, e.g. because it does some I/O
04:41:49 <blikken> So I rewrote everything to 'do result = step state ; return $ case result of ...'
04:41:58 <blikken> instead of 'case step state of ...'
04:42:08 <blikken> Can I avoid that?
04:42:13 <Kaidelong> result <- step state, surely?
04:42:20 <blikken> sorry, yes
04:42:52 <Kaidelong> well it depends on what sort of effect model you have going but if you could just make step a pure function why add effects to it?
04:43:01 <Kaidelong> what effects did you add?
04:43:17 <Kaidelong> you might be looking for something like
04:43:18 <blikken> it needs to stream data from disk, basically
04:43:37 <anon_555> hi guys can i get all the builtin functions in Haskell like takeWhile
04:43:41 <Kaidelong> result <- state; return $ case (step result)
04:43:46 <blikken> So I have a "source" which reads from disk, and then a bunch of stream processing functions, and then potentially a "sink" that sinks back to disk
04:44:16 <Kaidelong> or result <- step <$> state ; return $ case result
04:44:29 <Kaidelong> unless step really *is* a kleisli arrow
04:44:56 <Kaidelong> IE, step needs to do some effects
04:45:02 <blikken> Kaidelong: ah, so propagate the monad in the state
04:45:23 <blikken> Kaidelong: this still propagates everywhere though: your child's state is part of your state
04:45:26 <bahamas> anon_555: search what Prelude contains. I assume that's what you mean
04:45:45 <blikken> Kaidelong: e.g. if my streaming function has state 's', then I'll probably return (s, childState)
04:45:55 <anon_555> bahamas what to do to look in prelude
04:45:56 <Kaidelong> well it's relatively common pratice to use pure functions to step a state in an impure context
04:46:01 <klugez> anon_555: http://hackage.haskell.org/package/base-4.7.0.0/docs/Prelude.html
04:46:02 <Kaidelong> it's how people make haskell games, generally
04:46:35 <ectospasm> I'm getting the following when trying to update a key in my XMonad configuration.  I don't know how to get [Window] from Window (my haskell is perennially rusty)
04:46:37 <ryankask> quchen: thanks for your help. given that I haven't had any issues, I'm wondering if it has to do with this: https://github.com/ryankask/rievaulx/blob/master/src/Rievaulx/Web.hs#L25
04:46:44 <ryankask> *issues in GHCi
04:46:52 <ectospasm> http://paste.debian.net/103723/
04:48:36 <frerich> ectospasm : Try '([killWindow])', i.e. wrap killWindow with square brackets.
04:48:59 <frerich> ectospasm: Those '()' are unnecessary, by the way.
04:49:06 <ectospasm> I did, and I got a different error, let me paste it.
04:49:16 <blikken> Kaidelong: interesting, do you know any specific project that does such a think, for inspiration?
04:50:06 <blikken> Kaidelong: I can see how to push the monad into the state, but I only see how every stepper would still need to sequence these together
04:50:32 <Kaidelong> blikken: do you know about Functors?
04:50:37 <Kaidelong> @ty fmap
04:50:38 <lambdabot> Functor f => (a -> b) -> f a -> f b
04:50:45 <Kaidelong> @ty liftM --specialized fmap
04:50:46 <lambdabot> Monad m => (a1 -> r) -> m a1 -> m r
04:50:49 <ectospasm> http://paste.debian.net/103726/ << frerich
04:51:04 <blikken> Kaidelong: hmm or maybe not
04:52:30 <blikken> Kaidelong: yeah this could work if I seperate out the monadic part from the computational part
04:52:43 <blikken> Kaidelong: right now the computational part calls some stepepr function directly
04:53:06 <blikken> So perhaps it should instead be wrapped in some function that does that and provides it with the result
04:54:09 <Kaidelong> the trendy thing to do seems to use monads applicatively whenever possible with <$> and <*>
04:54:35 <Axman6> I think you mean to use Applicatives ;)
04:54:38 <Kaidelong> I'm not sure what do think of it, apparently it's more functional or something
04:54:48 <Kaidelong> @ty ap
04:54:49 <lambdabot> Monad m => m (a -> b) -> m a -> m b
04:55:03 <Kaidelong> we don't need no applicatives!
04:55:05 <frerich> ectospasm: Ah!
04:55:13 <Kaidelong> although that is what WrappedMonad is for IIRC
04:55:28 <Axman6> I think for some times it's possible to have an optimsed Applicative instance which is handy in some cases
04:55:30 <frerich> ectospasm: Does '(mapM_ killWindow)' work better?
04:55:40 <ectospasm> frerich: let me try
04:55:47 <frerich> ectospasm: I wonder whether that new XMonad version doesn't just have something like 'killWindows'
04:56:21 <frerich> ectospasm: The error means that you used to have to provide something which takes (probably kills?) a single window, and now it expects something which takes a list of them (I suppose, to kill them all)
04:57:14 <ectospasm> (mapM_ killWindow) compiles... let's see if it works.
04:57:28 <ectospasm> Works beautifully!  Thanks!
04:57:31 <frerich> This is Haskell, what do you expect!
04:57:35 <frerich> It compiled after all.
04:58:16 <ectospasm> yeah, but I may have constructed the operations wrong, or ifWindows wasn't the proper operation I needed.
04:58:34 <ectospasm> Does Haskell prevent logic errors?
04:59:10 <frerich> ectospasm: Disclaimer - I have never used XMonad myself. I just took the error message and then used mapM_ to massage what you have into what it wants. I don't know whether it actually does the right things still :}
04:59:28 <ectospasm> In this case, it did
05:01:31 * frerich is abit annoyed that he first suggested [killWindow], which he wouldn't have done if he had just read the error message more closely.
05:02:32 <ectospasm> in #xmonad they either laugh, cry, or scold me for not being fluent in Haskell.  I would need to take a class on it for that, I can't seem to teach it to myself.  I learn just enough to do what I want in XMonad, then quickly forget it.
05:02:52 <merijn> ectospasm: Have you looked at Learn You a Haskell?
05:03:45 <ectospasm> yeah, it's tl;dr.  I get lost about the third or fourth chapter.
05:04:13 <frerich> ectospasm: I guess some would consider it worthwhile to learn Haskell, but in practice I would hope that XMonad can be useful and configurable even if you don't have to learn a bloody programming language for it :)
05:04:17 <ectospasm> Does it have exercises at the end of each chapter?  I can't remember.
05:04:21 <merijn> ectospasm: Real World Haskell's intro is denser, but it skips over some basic, IMO
05:04:54 <ectospasm> I do have both of those bookmarked.
05:07:55 <anon_555> f = [x <- takewhile even x]   This is not right but what you call this type of thing in Haskell
05:08:54 <Axman6> a list comprehension?
05:10:53 <Reite> Ding
05:14:26 <remdezx> Hello all! In my program I'm creating multiple child processes, how can I kill them when parent is killed?
05:15:16 <remdezx> I'm trying to do it platform independent so handling posix signals does not really apply
05:16:34 <pjdelport> remdezx: The concept of child processes and process killing are somewhat platform dependent to begin with, so you can't avoid things like POSIX signals in the POSIX case.
05:16:51 <pjdelport> remdezx: You'll need to work with them, or with a library that abstracts them.
05:18:05 <ectospasm> frerich: thanks for the help! Ciao!
05:18:08 <remdezx> pjdelport: hmmm... probably you're right... do you know such a library that works on windows too?
05:18:20 <pjdelport> Not offhand, but someone might.
05:18:47 <remdezx> pjdelport: I will try to find it, thanks a lot!
05:21:08 <archblob> can a type syn appear anyware in a type class declaration ? if so, can someone give me an example ?
05:21:13 <pjdelport> remdezx: http://hackage.haskell.org/package/process is a starting point perhaps
05:24:01 <remdezx> pjdelport: I'm currently using this library for process management, but there is no way to kill children when parent is killed. I need to find another library for that ;)
05:25:29 <Faucelme> remdezx: there is the function terminateProcess
05:26:14 <Faucelme> perhaps you could bracket the "executeProcess" call and call "terminateProcess" in the finally clause.
05:27:10 <remdezx> Faucelme: Oh, that's both interesting and simple. I will try it :)
05:28:37 <hexagoxel> archblob: Show contains "show::a -> String", String is synonym
05:29:11 <archblob> hexagoxel, yes methods
05:29:18 <archblob> hexagoxel, thank you
05:29:20 <Faucelme> remdezx: see the implementation of function "executeX" here: http://hackage.haskell.org/package/process-streaming-0.0.1.1/docs/src/System-Process-Streaming.html#execute
05:29:57 <Faucelme> remdezx: it does something of the sort, but it is a bit obscured by other stuff.
05:31:04 <hexagoxel> archblob: apart from the methods, you could have synonyms in a constraint i guess
05:31:33 <remdezx> Faucelme: I see... I will try to do something similiar and test how it's working :)
05:31:43 <remdezx> Faucelme: thanks a lot!
05:34:08 <archblob> hexagoxel, how so , i think only with ConstraintKinds ?
05:36:24 <benzrf> :k (=>)
05:36:25 <lambdabot> parse error on input ‘=>’
05:36:27 <benzrf> lame!
05:36:33 <benzrf> :k Num a => a
05:36:34 <lambdabot> *
05:36:47 <Kaidelong> I think English speakers pronounce "Kittens" differently from "Mittens" with regard to the i, but they can't tell they do
05:36:52 <benzrf> i demand that types are proper expressions and (=>) :: Constraint -> * -> *!
05:36:57 <Kaidelong> wrong channel
05:36:58 <benzrf> :k a -> blikken
05:36:59 <lambdabot> Not in scope: type variable ‘a’
05:36:59 <benzrf> oops
05:36:59 <lambdabot> Not in scope: type variable ‘blikken’
05:37:08 <benzrf> :k forall a b. a ->  b
05:37:09 <lambdabot> *
05:37:35 <hexagoxel> archblob: class WriterT String m => FooMonad m where
05:38:25 <hexagoxel> needs FlexibleContexts (..?)
05:39:10 <archblob> hexagoxel, thank you
05:43:37 <athan> Hey guys, I'm getting a couple "Non type-variable argument in the constraint" errors when I compile yesod with the latest GHC. Any ideas? :x
05:51:50 <anon_555> let a = 5 gives error in hugs
05:52:16 <athan> anon_555: Is it top-level?
05:52:34 <anon_555> just typing in hugs >
05:53:40 <athan> anon_555: Just for laughs, try `let a = 5 :: Integer`
05:54:08 <athan> anon_555: What's the error, exactly?
06:00:15 <Kaidelong> the real question here is why are you using Hugs
06:00:52 <wavewave> hi
06:04:13 <remdezx> Faucelme: it looks like I could kill handle Ctrl-C with simple "finally", but it does not work with SIGTERM
06:04:32 <donnobot> N00b here, trying to install snap.
06:04:56 <donnobot> getting these installation errors:
06:05:06 <remdezx> *ah, mistake without "kill"
06:05:19 <donnobot> snap-0.13.2.6 depends on aeson-0.7.0.3 which failed to install.
06:05:27 <t7> what do you call a subset with at least one element
06:05:29 <donnobot> heist-0.13.1.2 depends on aeson-0.7.0.3 which failed to install. lens-4.1.2.1 depends on aeson-0.7.0.3 which failed to install.
06:05:50 <haasn> t7: non-empty subset?
06:07:23 <t7> @hoogle Set (Set a) -> Set a
06:07:24 <lambdabot> Data.Set deleteMax :: Set a -> Set a
06:07:24 <lambdabot> Data.Set deleteMin :: Set a -> Set a
06:07:24 <lambdabot> Control.Monad join :: Monad m => m (m a) -> m a
06:07:32 <hayashi> edwardk: sorry to badger, but will there be an updated version of recursion-schemes in hackage soon that builds on ghc7.8?  currently I'm having to use git HEAD =p
06:07:40 <t7> why SPJ? why!?
06:07:46 <t7> why no set concat
06:08:36 <copumpkin> set concat?
06:08:40 <hayashi> aw
06:08:52 <bennofs> donnobot: try --constraint="aeson >= 0.7.0.5" or --constraint="scientific < 0.3"
06:09:12 <copumpkin> t7: union :: Ord a => Set a -> Set a -> Set a or unions :: Ord a => [Set a] -> Set a ?
06:09:34 <bennofs> :t S.unions . S.toList
06:09:35 <t7> unions takes a list :s
06:09:35 <lambdabot> Ord a => S.Set (S.Set a) -> S.Set a
06:09:52 <copumpkin> you want a Set of Sets?
06:09:54 <t7> whos idea was that? show me the commit log
06:09:54 <donnobot> thanks bennofs will do
06:10:02 <copumpkin> it seems pretty reasonable to me
06:12:23 <t7> @hoogle [a] -> Bool
06:12:24 <lambdabot> Prelude null :: [a] -> Bool
06:12:24 <lambdabot> Data.List null :: [a] -> Bool
06:12:24 <lambdabot> Prelude all :: (a -> Bool) -> [a] -> Bool
06:17:15 <donnobot> bennofs doesn't seem to recognize the commands, the constraints go after which command?
06:17:25 <bennofs> donnobot: cabal install
06:24:11 * hackagebot hoauth2 0.4.0 - hoauth2  http://hackage.haskell.org/package/hoauth2-0.4.0 (HaishengWu)
06:24:13 * hackagebot log-effect 0.4.0.0 - An extensible log effect using extensible-effects  http://hackage.haskell.org/package/log-effect-0.4.0.0 (ibotty)
06:30:01 <imalsogreg> donnobot: Any luck?
06:34:38 <Axman6> :t concat
06:34:38 <lambdabot> [[a]] -> [a]
06:37:19 <dbushenko> are there any good haskell examples of real programs with IO ?
06:38:01 <Axman6> that's a pretty odd question. Basically any haskell program?
06:38:04 <imalsogreg> dbushenko: Good examples for what purpose?
06:38:20 <dbushenko> I just don't understand how to organise a program with IO
06:38:35 <dbushenko> its seems like IO spreads like a virus to lots of functions
06:38:41 <dbushenko> since I can't wrap it
06:38:47 <imalsogreg> dbushenko: Ahh I see :)
06:40:51 <Axman6> dbushenko: IO should be used for input and output only in general. Everything else should be pure
06:40:54 <imalsogreg> dbushenko: How to think purely when you're designing... let me see if I can think of any programs that would be good examples of separating the pure stuff from IO...   Are you looking for big ("real") programs, or will little programs where you can see more of the architecture at once?
06:40:54 <bennofs> dbushenko: maybe just start writing your program with IO everywhere, and then try to extract out pure parts? For example, if you see yourself doing let ... = ... very often in a do block, you could extract that into a pure function.
06:40:58 <Axman6> as a general rule
06:41:57 <dbushenko> imalsogreg, would be betrer if you shown me smaller programs since I'm a newbie
06:42:14 <imalsogreg> dbushenko: There is a micro-parable in the QuickCheck wiki page: http://www.haskell.org/haskellwiki/Introduction_to_QuickCheck1
06:42:53 <dbushenko> imalsogreg, thanks
06:43:00 <dbushenko> may be something more?
06:43:12 <dbushenko> bennofs, good point, thanks!
06:43:58 <dbushenko> bennofs, but what to do if in some pure function I understand that I need values from DB or file? does that mean that I have to refactor all the call chain which leads to this function?
06:44:55 <imalsogreg> dbushenko: Sure, looking around...  (have you read Learn You a Haskell yet?)
06:45:16 <dbushenko> imalsogreg, yep, though I stuck in the middle and switched to other books
06:45:31 <bennofs> dbushenko: you can write the function that operates on the data as a pure function taking the inputs as arguments and returning an output, and then write another function that does the "plumbing" by getting the required data from the DB and passing it to the pure function and processing the result
06:46:52 <albeit> Is there a way using "cabal build" to compile a specific file (and its dependencies)?
06:47:36 <dbushenko> imalsogreg, yep, you were right about 'learn you a haskel for greater good'
06:47:44 <dbushenko> there are the examples I was looking for
06:47:45 <dbushenko> thanks!
06:47:49 <imalsogreg> dbushenko: Maybe it would help if we take a look at some of the function you've written that are too IOish?
06:52:04 <imalsogreg> dbushenko: np. Good luck :) There's nothing wrong with getting stuck, leaving LYAH, writing some code, coming back a week later, etc etc
06:53:36 <dbushenko> :-) thanks!
06:54:36 <Eduard_Munteanu> Is there an XML lib that allows binding XML documents to datatypes a-la aeson?
06:55:55 <firebird1> what is side effect in functional programming language?
06:56:58 <Eduard_Munteanu> firebird1: things like input/output, mutating some state and so on
06:57:17 <firebird1> here http://learnyouahaskell.com/introduction#about-this-tutorial
06:57:43 <firebird1>  in purely functional languages, a function has no side-effects.
06:58:14 <firebird1> i'm from js background i dont get it
06:58:30 <Eduard_Munteanu> firebird1: yes... in other words, evaluating the function zero, one or many times makes no difference.
06:59:15 <Eduard_Munteanu> firebird1: printing "Hello world" would have side-effects for example, but a function which squares a number doesn't.
07:00:54 <Eduard_Munteanu> firebird1: "side" here refers to something else than the return value... a pure function simply takes in arguments and returns a value, without other effects.
07:01:32 <Eduard_Munteanu> Pure functions are much like functions in math.
07:01:47 <Or1> how does printing "hello world" have side-effects?
07:01:54 <firebird1> ^
07:01:56 <merijn> Or1: It prints "hello world"?
07:02:29 <merijn> Or1: Note Eduard_Munteanu's remark that "evaluating the function zero, one or many times makes no difference"
07:02:48 <merijn> Or1: Evaluating a functions that prints "hellow world" multiple times would print that string multiple times
07:03:04 <merijn> Or1: So clearly there's a difference between evaluating once and evaluating multiple times
07:03:22 <Or1> oh got it now
07:03:28 <oleo> is a function not taking any args side-effect free ?
07:03:42 <merijn> oleo: There's no such thing as a function not taking arguments :)
07:03:43 <Or1> and squaring a number multiple times?
07:03:54 <merijn> Or1: Well, lemme give a concrete example
07:03:54 <oleo> huh ?
07:04:15 * hackagebot log-effect 0.4.0.1 - An extensible log effect using extensible-effects  http://hackage.haskell.org/package/log-effect-0.4.0.1 (ibotty)
07:04:17 <merijn> Or1: Compare "foo + foo" and "let x = foo in x + x"
07:04:31 <Or1> merijn: ok
07:04:43 <asmyers> oleo: Something that doesn't take arguments is a constant value
07:04:45 <merijn> Or1: Suppose I wrote that in python and "foo" printed something, then the first and second would have "different" effects, right?
07:05:05 <heatsink> oleo: getLine is an IO action.  It takes no arguments.  It is not side effect free.  It reads one line of input.
07:05:11 <Or1> ok
07:05:15 <oleo> ok
07:05:18 <merijn> Or1: "side-effect free" basically means, both of those expressions must do the exact same thing
07:05:41 <Or1> K
07:05:54 <merijn> Or1: If "foo" has no side effects, then logicall evaluating "foo" twice and adding the results must be the same as evaluating foo once and adding the result to itself
07:06:03 <Or1> true
07:06:35 <firebird1> so unbelivable
07:06:37 <merijn> Or1: As a result, a haskell compilers is allowed to realise that "foo + foo" can be optimised by evaluating foo only once, since the compiler *knows* foo has no side effects
07:06:43 <albeit> Whenever I compile something that imports lens, it outputs a bunch of "Loading package xyz ... linking ... done" to the console... is there a way to disable this?
07:07:05 <merijn> Or1: A C compiler, on the other hand, cannot perform that optimisation, because it can never be sure that running foo twice is the same as once
07:07:33 <pjdelport> getLine is side-effect free, in the sense that's is a first-class effect (as opposed to a "side" effect)
07:07:39 <Or1> makes sense now.
07:08:29 <merijn> Or1: This blogpost is fairly good at explaining how it's possible to do IO in a side-effect free language like haskell: http://blog.jle.im/entry/the-compromiseless-reconciliation-of-i-o-and-purity
07:08:40 <Or1> all goes back to immutablility right?
07:08:43 <pjdelport> This means you can do anything with it that you can do with any other first-class value, like saying: replicate 10 getLine !! 9
07:08:48 <asmyers> getline is also side-effect free in the sense that it is a constant value that happens to be an IO action
07:08:59 <pjdelport> You don't have to worry about when or where evaluation happens; it remains referentially transparent.
07:09:27 <pjdelport> And you're not duplicating a line that's read, you're just working with the IO action as a plain value.
07:09:38 <Or1> merijn: cool link, thanks!
07:09:43 <merijn> Or1: immutability is part of making everything side-effect free, yes. If a variable can change value than changing that value is a side-effect
07:09:54 <pjdelport> Only when the effect is run by main (or your REPL) does getLine actually read something.
07:10:16 <Or1> :)
07:10:36 <firebird1> my head hurts
07:10:45 <merijn> @quote gloss.over
07:10:46 <lambdabot> cjeris says: Cale: I like how you conveniently gloss over the part where your head explodes.
07:10:51 <merijn> :)
07:11:00 <merijn> firebird1: It takes some getting used to :)
07:11:56 <Or1> firebird1: if you new with haskell as I am, try out https://github.com/bitemyapp/learnhaskell
07:13:11 <albeit> When I cabal build, how can I prevent it from generating profiling .p_o files?
07:13:29 <heatsink> configure with --disable-library-profiling
07:13:49 <heatsink> or --disable-executable-profiling if it's a program
07:14:23 <albeit> heatsink: Ah great, thanks
07:21:40 <albeit> Is there a clever way to do the pattern "do val <- f; g; return val;"?
07:22:18 <supki> f <* g
07:22:43 <albeit> Oh nifity, okay
07:26:51 <yitz> albeit: you can control whether profiling libraries are built by default in your ~/.cabal/config file
07:40:15 <BBShortcut> Hello, I am looking for some code that uses HTTP or http-client hackages, do you know what codes may I read?
07:44:20 * hackagebot stable-tree 0.0.2 - Trees whose branches are resistant to change  http://hackage.haskell.org/package/stable-tree-0.0.2 (tsuraan)
07:47:31 <mikusp> Why it is forbidden by documentation of Data.Vector.Storable to modify underlying data using function unsafeToForeignPtr or unsafeWith? I'd like to pass a pointer to Vector's data to foreign C++ function that will modify it. Is there any safe way of doing that?
07:48:23 <bitemyapp> mikusp: that's scary mate :)
07:48:33 <merijn> mikusp: Well, if you do that your haskell code will think the data is unmodified even though you did change it
07:48:57 <mikusp> I know it's dangerous territory :)
07:49:08 <merijn> mikusp: So haskell code that was compiled to work on the "old" data will suddenly be seeing the "new" data, imagining the million ways that can go wrong is an exercise for the reader
07:50:46 <mikusp> merijn: do you see any way to do it safely? Maybe using a newly allocated copy of a vector?
07:51:55 <rpr> I am curious, what is haskell's function call overhead compared to call overhead in C?  both when calling native haskell functions and C functions? I don't know how to benchmark haskell code
07:53:36 <Axman6> By Haskell I assume you mean GHC's. It's not really that easy to compare though, GHC doesn't ever really use the 'call' instruction, it's all tail calls with a stack on continuations (I think)
07:53:46 <rpr> yes ghc
08:01:22 <merijn> Axman6: Yeah
08:01:35 <merijn> rpr: What question are you actually trying to answer?
08:01:54 <Axman6> rpr: C calls have two forms in GHC, safe and unsafe (I can't remember how they differ though)
08:02:07 <Axman6> hmm, is it safe and unsafe?
08:03:32 <merijn> Axman6: Three actually
08:03:37 <Axman6> rpr: http://ezyang.com/jfp-ghc-rts-draft.pdf might give you some info (it's a pretty rough draft but there's plenty of info in it)
08:03:38 <merijn> safe, unsafe and interruptible
08:03:48 <bennofs> Is there a way to make a file not depend on cabal_macros.h, if that file uses CPP for other things?
08:04:41 <merijn> Axman6: safe runs in a separate OS thread and thus has more overhead than unsafe. Unsafe runs directly in the haskell thread, meaning the haskell thread will be blocked until the foreign call returns (this will also prevent global GC! As that relies on freezing the haskell thread, which can't be done while running foreign code!)
08:06:31 <merijn> And interruptible is for foreign calls that can be interrupted using signals (like "sleep") allowing haskell to interrupt a foreign call using exceptions
08:08:34 <rpr> merijn I am not answering any questions I asked a question :)
08:08:46 <Tjr> @help
08:08:46 <lambdabot> help <command>. Ask for help for <command>. Try 'list' for all commands
08:09:48 <merijn> rpr: You are, there is a question you have which you are attempting to answer by answering "what is haskell's function call overhead compared to call overhead in C?"
08:09:59 <merijn> rpr: The problem is that that comparison makes very little sense
08:10:08 <rpr> merijn I was just curious
08:10:15 <Axman6> rpr: that's a pretty rude response to someone who're trying to help you
08:10:32 <Tjr> How do I find out what this "mappend" function is, as used in http://hackage.haskell.org/package/base-4.6.0.0/docs/Data-Foldable.html#t:Foldable ?
08:10:44 <rpr> rude? I was clarrifying if he misread earlier conversation, which was a while ago
08:11:07 <merijn> rpr: If it's just curiosity then the answer is simply: "This comparison makes very little sense because the way haskell is mapped to machine code is very different from how C is mapped to machine code"
08:11:35 <Tjr> >mappend
08:11:39 <merijn> rpr: It may be more instructive to read up on how haskell code is translated to machine code, that may serve you better in terms of having a performance intuition
08:11:41 <Tjr> @mappend
08:11:41 <lambdabot> Unknown command, try @list
08:12:07 <Axman6> yes rude, often when trying to answer a question you need to ask questions in return. "I'm not answering questions" is a pretty rude thing to say in my opinion
08:12:38 <ajcoppa> Tjr: hoogle will show you what mappend is
08:12:43 <merijn> Axman6: I think he just misread my "answer" as me assuming he asked another question before this one
08:12:43 <ajcoppa> i can tell you more if you like
08:13:52 <merijn> rpr: This is a very readable (if a bit outdated) paper on how to compile something like haskell: https://research.microsoft.com/apps/pubs/default.aspx?id=67083
08:14:48 <Tjr> ajcoppa: got it :-)
08:14:58 <ajcoppa> sweet
08:15:34 <rpr> ok it seems there's a major confusion goin on.. I was responding to this, thinking merijn thought I was answering a question instead of asking one:  <merijn> rpr: What question are you actually trying to answer?
08:15:57 <merijn> rpr: In practice Haskell gets translated to Core (GHC's internal representation), which in the end gets translated to STG (the Spineless Tagless G-machine from the title, although current STG is rather different from that paper) which gets compiled to Cmm which is a "minimal portable assembler" used by GHC which then gets translated to native code
08:16:10 <nisstyre> there's a lot to functional compilers, one important part is closure conversion
08:16:11 <merijn> rpr: FWIW, I got your remark
08:16:47 <nisstyre> that is the process of eliminating free variables, since languages like C don't have a native concept of non-global free variables
08:16:54 <merijn> rpr: If you know basic assembler then Cmm is rather boring and "obvious", it's Core and STG that are interesting for understanding performance of haskell code :)
08:16:56 <Axman6> rpr: ah right, misunderstandings on several fronts then. sorry for the accusation =)
08:18:32 <Tjr> merijn: that's an interesting paper. I chuckled at "treating the C compiler as a portable assembler".
08:18:46 <rpr> Axman no problem. anyway, it seems like the answer to my question is more complex than I thought it would be.  the fact that I keep getting disconnected and losin answers doesn't help either
08:18:51 <Tjr> merijn: Does that mean it's possible to get readable C code out of haskell?
08:19:12 <merijn> Tjr: Cmm is not C
08:19:26 <nisstyre> Tjr: I would not count on it, unless you like seeing superfluous code just to call a simple function
08:19:30 <Axman6> Tjr: GHC used to produce C code, but it was far from readable
08:19:33 <merijn> Tjr: Cmm is C minus minus and it *is* portable assembler, like LLVM
08:19:59 <merijn> Tjr: GHC *used* to use C as portable assembler and the backend still exists for bootstrapping on new architectures, but it's deprecated
08:20:14 <benzrf> heyj:
08:20:17 <benzrf> *hey
08:20:20 <benzrf> i'm reading http://www.haskell.org/haskellwiki/Category_theory/Natural_transformation
08:20:26 <benzrf> and what's Homc?
08:21:13 <Tjr> benzrf: can't find it, where is homc?
08:21:13 <phaskell> No symbol 'homc' found anywhere.
08:22:16 <benzrf> Hom with subscript c
08:22:18 <benzrf> *C
08:22:25 <benzrf> in the first section
08:22:29 <benzrf> point 3
08:22:30 <nclarke> Ah. Hom_C(X,Y) is the set of C-morphisms between objects X and Y
08:22:52 <merijn> Tjr: See this page for info on Cmm https://ghc.haskell.org/trac/ghc/wiki/Commentary/Compiler/CmmType
08:23:16 <nclarke> Well, strictly I guess it's usually a class, rather than a Set.
08:23:28 <benzrf> heuh
08:24:18 <anon_555> filter Char.isLower "Hello Wolrd" not working
08:24:38 <Axman6> you'll need Data.Char
08:24:44 <nclarke> E.g. If C == Set, and X = {1} and Y = {1,2} then Hom_C(X,Y), has two members, {(1->1),(1->2)}
08:25:27 <anon_555> filter Char.isLower "Hello Wolrd"
08:25:31 <anon_555> still not working
08:25:42 <genericpersona> anon_555: filter isLower "Hello World"
08:25:42 <Axman6> ...
08:25:48 <genericpersona> after doing import Data.Char
08:25:52 <genericpersona> stop being silly
08:25:55 <nclarke> > filter isLower "Hello World"
08:25:57 <lambdabot>  "elloorld"
08:26:00 <anon_555> working thank you
08:26:04 <anon_555> and what does map do
08:26:17 <Axman6> why don't you read its documentation
08:26:24 <genericpersona> applies a function every element of a list and returns a new list w/ its result
08:26:33 <genericpersona> map (+1) [1..3] = [2,3,4]
08:26:51 <nclarke> > map toLower "Hello World"
08:26:53 <lambdabot>  "hello world"
08:27:07 <anon_555> and in what type of case do we need foldr
08:27:09 <genericpersona> nice, lambdabot is awesome :)
08:27:15 <genericpersona> anon_555: lots of cases
08:27:32 <genericpersona> anon_555: read this paper http://www.cs.kent.ac.uk/people/staff/dat/miranda/whyfp90.pdf
08:27:47 <anon_555> genericpersona thank you
08:27:51 <anon_555> i will
08:27:58 <Tjr> anon_555: foldr and foldl are basically the equivalent of for-loops in other languages.
08:28:03 <genericpersona> it shows how foldr is a generalization of recursing through a list while accumulating a value
08:28:10 <anon_555> oh really
08:28:23 <anon_555> i thought it does simple simplification
08:28:36 <genericpersona> foldr is equivalent to reduce in other languages
08:28:39 <genericpersona> it isn't quite a for loop
08:28:41 <nisstyre> Tjr: for loops don't do accumulation though
08:28:48 <anon_555> Tjr can you give me the example of for loop in c implemented in foldr in haskell
08:28:56 <Axman6> nisstyre: eh?
08:29:00 <nisstyre> except accumulation of the number of iterations
08:29:15 <nisstyre> but they don't let you specify an accumulation function or anything
08:29:29 <Tjr> nisstyre: for loops have potential side effects. The accumulator captures this part of the global world state if you translate an imperative style for loop into funcitonal programming
08:29:39 <Axman6> for(...) { foo = bar(foo,arr[i]);}?
08:29:54 <nisstyre> Tjr: that's different from saying "foldr is like a for loop", not all for loops have to have accumulation
08:30:10 <nisstyre> Haskell has actual ways of doing for loops
08:30:52 <genericpersona> foldr (+) 0 [1..5] == int acc = 0; for (int i = 0; i < 5; i++) acc += arrOfInts[i]; return acc
08:31:11 <Tjr> nisstyre: if your for loop doesn't need state, then just make the function given to foldr ignore one of its arguments.
08:31:36 <Tjr> (or use map, but the point is to demonstrate that foldr and for are similar concepts.)
08:31:59 <sveit> i have a function (a -> IO b) and a type Maybe a, what is a good way to apply this function within the IO monad?
08:32:13 <sveit> i.e. i need to end up with IO (Maybe b)
08:32:25 <sveit> I could go through the unwrapping, but are there pre-built combinators for this?
08:32:55 <merijn> sveit: Yes!
08:33:06 <merijn> :t Data.Traversable.mapM
08:33:07 <lambdabot> (Traversable t, Monad m) => (a -> m b) -> t a -> m (t b)
08:33:27 <merijn> :t Data.Traversable.mapM (undefined :: a -> IO b) (undefined :: Maybe a)
08:33:28 <lambdabot> IO (Maybe b)
08:33:59 <sveit> ah thanks! wasn't expecting that since the 'normal' mapM is defined on lists
08:34:02 <nisstyre> T.sequence $ f <$> a
08:34:20 <albeit> merijn: When you're using undefined there, is "undefined" just an alias for like "c", or is it actually undefined?
08:34:22 <merijn> sveit: Data.Foldable and Data.Traversable have generalised versions of stuff like mapM which work on more than just lists :)
08:34:40 <nisstyre> or mapM, didn't know Traversable had that
08:34:50 <merijn> albeit: undefined is an alias for "bottom", the crashing/infinite looping term
08:34:54 <merijn> :t undefined
08:34:55 <lambdabot> a
08:35:03 <sveit> merijn: should I just use the generic versions in Data.Foldable/Traversiable by default? also side-question, how can I expect types like 'Maybe' to be traversable? lists/vectors make sense, but maybe?
08:35:13 <Axman6> i.e.: non-returning
08:35:52 <merijn> sveit: The module has a list of implementations, Traversable is basically "fmap on steroids"
08:36:01 <merijn> > undefined
08:36:03 <lambdabot>  *Exception: Prelude.undefined
08:36:31 <merijn> albeit: undefined can have any type and is thus useful to illustrate types (like just now) without needing to actually construct values of the appropriate type
08:36:41 <merijn> In 7.8 TypedHoles should be more useful than undefined, though
08:37:17 <merijn> sveit: There's no real reason to not use the more generic version (well, you'd need to import those which unnecessary if you just want to work on lists)
08:37:43 <merijn> sveit: There are some vague plans to move Foldable/Traversable into Prelude if benchmarks show there's no performance regression for lists
08:37:46 <albeit> merijn: So is undefined/bottom a particularily exceptional value in Haskell, or is it possible to make other values a member of any type?
08:38:14 <merijn> albeit: It is possible to make other values a member of any type, but they will always either 1) crash or 2) infinite loop :p
08:38:20 <merijn> :t let x = x in x
08:38:21 <lambdabot> t
08:38:25 <merijn> :t let x = x in x :: Int
08:38:26 <lambdabot> Int
08:38:28 <byorgey_> /quit
08:38:28 <merijn> :t let x = x in x :: Bool
08:38:29 <lambdabot> Bool
08:38:38 <merijn> > let x = x in x :: Int
08:38:42 <lambdabot>  mueval-core: Time limit exceeded
08:39:43 <nisstyre> :t let f x = f x in ((f (4 :: Int)) :: String)
08:39:44 <lambdabot> String
08:40:02 <nisstyre> > let f x = f x in ((f (4 :: Int)) :: String)
08:40:06 <lambdabot>  mueval-core: Time limit exceeded
08:40:17 <albeit> Interesting.. so it would never really be used in a real program, its just a clear way of "breaking" haskell without actually breaking it...?
08:40:31 <albeit> For the purposes of illustration?
08:41:05 <nisstyre> albeit: it's useful when you want your program to typecheck even though it's unfinished
08:41:11 <merijn> albeit: Well, it's sometimes used in obscure situations where you need to pass a value of a certain type
08:41:34 <nisstyre> albeit: and if you give it a parameter like I did then you can make it throw exceptions with a message
08:41:39 <merijn> albeit: For example "sizeOf :: Storable a => a -> Int" <- this doesn't use 'a', the 'a' is just there to decide the typeclass instance
08:41:43 <merijn> So you can do
08:41:44 <nisstyre> of course the actuall 'error' doesn't infinite loop
08:41:49 <merijn> > sizeOf (undefined :: Int)
08:41:51 <lambdabot>  Not in scope: ‘sizeOf’
08:41:51 <lambdabot>  Perhaps you meant one of these:
08:41:51 <lambdabot>    ‘IM.size’ (imported from Data.IntMap),
08:41:51 <lambdabot>    ‘M.size’ (imported from Data.Map),
08:41:51 <lambdabot>    ‘S.size’ (imported from Data.Set)
08:41:52 <blikken> GIven a Data.Vector.Unboxed, how can I extract a pointer to the memory contents?
08:42:33 <merijn> albeit: And as nisstyre points out I usually write programs by writing "foo :: SomeType; foo = undefined" and writing a bunch of types like that without code and then I go back later to actually implement them
08:42:45 <merijn> albeit: That way you can typecheck your program before actually implementing all of it
08:42:59 <nisstyre> :t error
08:43:00 <lambdabot> [Char] -> a
08:43:05 <albeit> Ah clever! Got it, thanks
08:43:08 <nisstyre> > error "This is an error"
08:43:09 <lambdabot>  *Exception: This is an error
08:43:34 <albeit> > error "Error" == undefined
08:43:35 <lambdabot>  *Exception: Error
08:43:59 <merijn> albeit: In 7.8 there is a better way, if you write down a variable starting with a _ on the right hand of a function it will keep compiling and produce an error with the type of that variable after type checking
08:44:12 <merijn> albeit: This avoids the problem of forgetting to replace all your "undefined" :)
08:44:20 <nisstyre> > let a = [error "Error!", undefined] in 4
08:44:21 <lambdabot>  4
08:44:40 <augur> merijn: i feel like the proxy thing is a hack to get certain kinds of vaguely dependent-y-but-not-quite things
08:44:58 <merijn> augur: Proxy is different to my example, though
08:45:13 <augur> merijn: i dont mean proxy itself, i just mean this dummy-value approach
08:45:17 <merijn> augur: The problem is that "sizeOf :: Storable a => Int" <- how do you select which Storable instance?
08:45:17 <augur> where you give a value only for its type
08:45:34 <augur> merijn: like, why isn't it just sizeOf :: (a :: *) -> Storable a => Int
08:45:35 <augur> you know?
08:45:48 <merijn> augur: That question makes no sense
08:45:56 <augur> not in haskell it doesnt
08:46:02 <augur> but in principle it does
08:46:11 <augur> actually in haskell it makes sense too, sort of
08:46:20 <augur> the underlying language is _precisely_ that
08:46:29 <merijn> Anyway, it's weekend :)
08:46:34 <augur> sizeOf has a type argument and a Storable a argument
08:46:51 <augur> its just the surface language that prevents us from using types as arguments explicitly
08:47:30 <augur> if haskell let you explicitly give the type argument in a forall, you could do it without the dummy value
08:48:28 <augur> haskell's surface syntax actually is less capable than the underlying brand of System-F, which has type lambdas. so its a curious thing where the underlying language would let you do it, if only they'd expose it
08:48:47 <nisstyre> merijn: you could always use maxBound or minBound at least for instances of Bounded, I'm sure the compiler is smart enough to notice you never use it, and it won't get evaluated either way
08:49:06 <merijn> nisstyre: That only works for Bounded a
08:49:08 <Maxdamantus> a type argument would make it rank-2.
08:49:10 <Maxdamantus> well, an actual argument for the type.
08:49:32 <merijn> augur: You're right, but I don't think it's a big issue in haskell :)
08:49:36 <merijn> And now, weekend!
08:49:45 <augur> merijn: im not saying it is, but it leads to a weird pattern
08:49:52 <augur> where you write   foo (undefined :: A)
08:49:57 <augur> when you should just write foo A
08:52:08 <augur> i dont know what the syntax for it ought to be but i think it'd be nice to have that, rather than having to use these dummy values
08:52:52 <glguy> augur: The normal solution to avoiding dummy values is to use a proxy, so "sizeOf :: proxy a -> Int"
08:52:58 <glguy> sizeOf (Proxy :: Proxy Int)
08:53:23 <augur> glguy: i know, but thats also a dummy value
08:53:38 <augur> the value exists solely to specify the type
08:53:48 <augur> because types can be written at the value level except via annotations
08:54:16 * bennofs wants the (:: x) syntax to mean (\a -> a :: x)
08:54:18 <augur> but the problem is ONLY with haskell's surface syntax, its not a problem with the core language, which does have value-level types
08:55:03 <bennofs> the nice effect is that this also can be used as a proxy, so you can write foo (:: A)
08:55:06 <augur> actually i dont know if the underlying language actually has type lambdas, they might be eraseable, so who knows
08:55:12 <augur> but in principle it does :p
08:55:53 <augur> bennofs: how is that usable as a proxy??
08:56:10 <augur> if (:: A) == (\x -> x) :: A -> A
08:56:19 <augur> then foo wont work will it
08:56:24 <glguy> unify proxy with ((->)A)
08:56:27 <augur> maybe prefix it
08:56:28 <glguy> and then you have proxy A
08:56:30 <bennofs> augur: foo :: proxy a -> ...
08:56:33 <augur> (:: A) foo
08:56:40 <bennofs> augur: let proxy be a type variable
08:57:06 <glguy> augur: With the proxy pattern you use type variable proxy in the negative positions
08:57:07 <augur> bennofs: eh
08:57:11 <augur> i dont like that solution
08:57:29 <augur> i think it makes more sense to just expose the underlying core type lambdas
08:57:31 <bennofs> augur: a few libraries already do that. It allows you to use [] or Maybe as proxies
08:58:18 <augur> but you need a good notation that isnt conflicting
08:58:46 <bennofs> augur: also, it allows you to use (:: x) for things like (:: Int) . read too
08:59:10 <augur> again that would be specifiable with exposed type lambdas
08:59:56 <augur> i'd much rather   read@Int   or something
09:00:04 <augur> sizeOf@Int
09:00:05 <augur> etc
09:00:33 <augur> or use the agda notation and let you write   read{Int}, sizeOf{Int}
09:01:26 <augur> as i said, the real problem is deciding a notation and writing the parser modification
09:02:03 <augur> because the underlying terms are already there, its just not available to us as haskell coders. which is really a shame
09:04:55 <Maxdamantus> I think it'd be better to make @ a syntax for transient "type"-qualified expressions.
09:05:13 <Maxdamantus> @Foo :: @Foo
09:05:13 <lambdabot> Maybe you meant: yow todo do
09:05:50 <Maxdamantus> which would just be a type with a single value.
09:05:56 <rwbarton> augur: there is one other issue -- if a value has multiple type parameters, how do you know what order to specify them in
09:06:11 <augur> Maxdamantus: ?
09:06:32 <Maxdamantus> sizeOf @Int
09:06:48 <Maxdamantus> class Sizable a where sizeOf @a -> Integer
09:06:55 <Maxdamantus> or whatever sizeOf is (I haven't heard of it)
09:06:56 <augur> rwbarton: thats a good question. you'd have to have named parameters maybe? like i said, the problem is on the syntax side, not the core side :)
09:07:26 <rwbarton> there is a trac page about this proposal
09:07:31 <augur> rwbarton: oh? link!
09:07:41 <Maxdamantus> @Int in a type expression would express a type derived from Int with one value.
09:07:41 <lambdabot> Maybe you meant: wn let
09:07:44 <rwbarton> https://ghc.haskell.org/trac/ghc/wiki/TypeApplication
09:08:01 <Maxdamantus> and @Int in a value expression would express the single value with that type.
09:08:26 <Maxdamantus> WHAT!&>@^
09:08:31 <Maxdamantus> They used the exact same character?
09:09:34 * hackagebot stable-tree 0.1.0 - Trees whose branches are resistant to change  http://hackage.haskell.org/package/stable-tree-0.1.0 (tsuraan)
09:10:52 <augur> Maxdamantus: well its an obvious choice
09:11:35 <augur> Maxdamantus: it more or less is a conventional way of saying what the specification of a forallt ype is
09:11:44 <Maxdamantus> Hm. It's a bit different to what I said anyway.
09:11:45 <augur> if you have f :: forall a. B
09:12:06 <augur> theres a sort of convention that f specified for a = A is f at the type A
09:12:17 <mirf> ey up sexy devs
09:12:19 <augur> so f@A or f @A is natural
09:12:37 <mirf> 'ey, even
09:12:49 <augur> ey up?
09:12:50 <augur> well
09:12:57 <mirf> I came here on a the wave
09:12:57 <augur> now we know mirf's from yorkshire
09:13:02 <mirf> yaay
09:13:06 <mirf> correct augur :)
09:13:14 <mirf> it was a Tidal wave...
09:13:28 <augur> mirf: i dont think there are many other yorkshirese on here
09:13:32 <mirf> lol
09:13:37 <mirf> tht's OK
09:13:40 <mirf> I came for the functions
09:13:50 <augur> but they better be yorkshirese functions!
09:13:54 <mirf> lol
09:14:07 <Maxdamantus> I'm not sure why it integrates it with type families.
09:14:08 <augur> wheres that yorkshire airlines video...
09:14:11 <mirf> yes, there must be whippets
09:14:29 <Maxdamantus> Why not just make `@Bool` a type expression as well as a .. value expression?
09:14:43 <augur> ahh there we go
09:14:45 <augur> mirf: https://www.youtube.com/watch?v=wPjJFv1NDBg
09:15:18 <Maxdamantus> Oh, it doesn't, nvm.
09:15:51 <Maxdamantus> It's not actually preventing you from trying to destructure something like @Bool, is it?
09:16:10 <Maxdamantus> case @Bool of { True -> False; False -> True }
09:16:20 <mirf> hahahah
09:16:25 <mirf> lovely stuff augur :D
09:17:12 <mirf> it's funny cos it's true
09:17:19 <Maxdamantus> That's why it should involve a new type.
09:17:41 <hactor> Hey folks, I'm new to Haskell, and I'm especially impressed with the arbitrary precision ints, floats and rationals supported.
09:17:41 <augur> mirf: also: #haskell-blah
09:17:59 <augur> mirf: so we can be off topic without being off topic
09:18:00 <hactor> Now... I'm curious those of you who write a lot of Haskell code, how do you use rationals, or do you?
09:18:35 <augur> :t (/)
09:18:36 <lambdabot> Fractional a => a -> a -> a
09:18:43 <augur> @hoogle Fractional
09:18:44 <lambdabot> Prelude class Num a => Fractional a
09:18:44 <lambdabot> Test.QuickCheck.Arbitrary arbitrarySizedFractional :: Fractional a => Gen a
09:18:44 <lambdabot> Test.QuickCheck arbitrarySizedFractional :: Fractional a => Gen a
09:18:53 <augur> ugh. no links. >_<
09:18:56 <augur> i always forget this
09:19:11 <augur> http://hackage.haskell.org/package/base-4.7.0.0/docs/Prelude.html
09:19:40 <augur> hactor: http://hackage.haskell.org/package/base-4.7.0.0/docs/Data-Ratio.html#t:Ratio
09:22:21 <augur> so rwbarton: it seems like this is a current, actual extension you can use?
09:23:27 <rwbarton> no
09:23:35 <augur> rwbarton: oh :(
09:23:35 <hactor> augur, thanks, but I still don't understand the practical use.
09:23:44 <augur> hactor: what do you mean?
09:23:48 <rwbarton> there's all kinds of loony proposals on the trac :P
09:24:02 <augur> rwbarton: ok. well thats unfortunate. someone should add it. it'd be nice
09:24:36 * hackagebot vty 5.1.0 - A simple terminal UI library  http://hackage.haskell.org/package/vty-5.1.0 (CoreyOConnor)
09:27:45 <napping> Hi. Can't chat much today. Does anyone know a library that will do DAG-reachability on modest size graphs (think module imports) significantly better than fgl?
09:28:22 <geekosaur> might do better asking on the haskell-cafe mailing list
09:28:33 <geekosaur> especially if you can't hang around on irc for answers
09:29:21 <napping> I can hang around, just can't take much time to chat today :)
09:32:15 <napping> I'm almost certain containers:Data.Graph.reachable will be serviceable for now, and I'll just continue coding with that.
09:34:34 <napping> actually, I might be able to complain about nontrivial non-treen-ness and use LCA
10:02:08 <joelteon> has anyone here used music-suite?
10:14:28 <hactor> augur, I mean how is it really used in real apps?
10:15:57 <augur> hactor: depends on the app
10:16:01 <augur> in most real apps its not
10:16:29 <hactor> all right.
10:17:20 <firebird1> >5==5&&not 6
10:17:48 <augur> hactor: but sometimes you need arbitrary-precision integers and arbitrary-precision rationals, so its there in case you do
10:17:56 <augur> scientific and mathematical work is more in that direction, i think
10:18:22 <hactor> augur, all right. I'm just wondering if I need to support this for a general purpose serialization format. I guess not.
10:18:50 <StoneCypher> hactor: how often do you need them in languages which don't have them?
10:18:51 <augur> hactor: general purpose serialization format in what sense?
10:19:08 <StoneCypher> hactor: also it's not general purpose if it picks and chooses which basic things it supports
10:19:37 <hactor> augur, passing data between languages
10:19:43 * hackagebot libjenkins 0.4.3.0 - Jenkins API interface  http://hackage.haskell.org/package/libjenkins-0.4.3.0 (MatveyAksenov)
10:20:09 <firebird1> >5==5&&not 6
10:20:10 <hactor> StoneCypher, that's the big question - is the set of rational numbers a "basic thing". As for other languages. If you don't have it, you won't use it obviously
10:20:11 <firebird1> No instance for (GHC.Num.Num GHC.Types.Bool)
10:20:12 <firebird1> arising from the literal `6'
10:20:12 <firebird1> Possible fix:
10:20:12 <firebird1> add an instance declaration for (GHC.Num.Num GHC.Types.Bool)
10:20:15 <augur> hactor: well, then you need to figure out the common stuff between languages and focus on that
10:20:36 <firebird1> i dont understand possible fix
10:20:36 <StoneCypher> hactor: people use things their languages don't provide all the time
10:20:47 <hactor> StoneCypher, what?
10:21:02 <StoneCypher> "if you don't have it, you won't use it obviously"
10:21:03 <hactor> Anyway.
10:21:08 <StoneCypher> c++ does not have graphics of any kind, for example
10:21:17 <StoneCypher> and yet they're sufficiently important that people make it work.
10:21:18 <hactor> Yes, if you have no native rational number, you can't use a native rational number.
10:21:23 <StoneCypher> lol what
10:22:02 <hactor> Why do you need to bother hitting those keys and then enter to be wasting my time if you can't say anything productive. I'll never know.
10:22:08 <StoneCypher> wow.
10:22:33 * StoneCypher was trying to teach you a way to look at things, but, okay, apparently it's unwanted.
10:22:55 <hactor> My question was how useful are rational numbers.
10:23:05 <hactor> You can always emulate it with a tuple of two integers.
10:23:12 <StoneCypher> i wouldn't want to waste your time explaining the answer you got.  good day
10:23:16 <hactor> But native support in my case is extra effort.
10:23:40 <hactor> StoneCypher, good day. And I mean it.
10:25:00 <enthropy> I think Double is used more often: Rational can be slow because it has to find and divide out common factors in two Integers that can become rather large, and it doesn't support lots of operations
10:25:52 <hactor> enthropy, yup. Doubles are approximate, but close enough most of the time.
10:25:54 <jomg> firebird1: i think it's because 6 can represent any type that's an instance of Num
10:26:08 <hactor> enthropy, I do feel the nerd joy in being able to express *precisely* 1/3
10:26:17 <hactor> enthropy but I think and think and I see no real use for it much
10:26:23 <jomg> firebird1: since not needs a bool, it's checking whether the 6 could also be a bool and since it isn't, it complains
10:26:28 <savanni> firebird1: the error message you are seeing is basically saying "you have `6`, which is a member of class Num, but you are using it as a Bool.  Bool is not part of Num."  i.e., you are using a number where only a boolean is allowed.
10:26:40 <enthropy> http://hackage.haskell.org/package/cyclotomic
10:26:53 <savanni> firebird1: what do you want that line of code to do?
10:28:05 <firebird1> savanni >5==5&&not 6 RESULTS in False
10:28:48 <hactor> enthropy, math. It kicks ass.
10:28:59 <solidus-river> what does adding ! before a type indicate
10:29:03 <merijn> firebird1: In lambdabot you mean?
10:29:07 <solidus-river> like whats the difference between :: Int and :: !Int
10:29:09 <savanni> firebird1: but I'm don't understand what that means.  Are you asserting that 5 is not 6?
10:29:12 <merijn> solidus-river: Google BangPatterns
10:29:36 <quchen> merijn: That's not a BangPattern, it's a type-level strictness annotation. It's standard Haskell!
10:29:39 <enthropy> hactor: I don't think we have a good story for arbitrary-precision Floats though
10:29:44 * hackagebot snap 0.13.2.7 - Top-level package for the Snap Web Framework  http://hackage.haskell.org/package/snap-0.13.2.7 (DougBeardsley)
10:29:45 <firebird1> not 6 means not True
10:29:52 <merijn> quchen: Oh, before a type, I didn't read :p
10:30:03 <rwbarton> "Five equals five, and not six." seems perfectly clear to me :P
10:30:06 <merijn> "not 6" means type error
10:30:24 <hactor> enthropy, well we do.
10:30:28 <albeit> > not 6
10:30:29 <lambdabot>  No instance for (GHC.Num.Num GHC.Types.Bool)
10:30:30 <lambdabot>    arising from the literal ‘6’
10:30:31 <jomg> yea, no automatic typecast in haskell
10:30:41 <hactor> enthropy, it's often useful to compute at a higher precision than your final result.
10:31:01 <hactor> enthropy, floating point math is a bit lossy due to its nature. Error accumulates with a lot of intermediate computations.
10:31:29 <copumpkin> hactor: there's the precision package, but it's still a WIP
10:31:32 <copumpkin> @hackage precision
10:31:32 <lambdabot> http://hackage.haskell.org/package/precision
10:31:36 <copumpkin> err
10:31:39 <copumpkin> what did we call it again
10:31:42 <enthropy> hactor: I mean something that does something like http://hackage.haskell.org/package/numbers-3000.2.0.1/docs/Data-Number-CReal.html, but isn't painfully slow
10:31:45 <hactor> Aight, copumpkin, will check this
10:31:53 <copumpkin> https://github.com/ekmett/rounded
10:31:55 <copumpkin> that's it
10:32:06 <enthropy> @hackage compensated
10:32:06 <lambdabot> http://hackage.haskell.org/package/compensated
10:32:12 <savanni> firebird1: okay, not 6 is a c-ism which can't apply here.  If you just want not true, you write `False`.  If you're comparing something to 6, it would be `(not (x == 6))` or `(x /= 6)`.  Or, to get C semantics, `(x == 0)`
10:32:38 <solidus-river> merijn: hmm
10:32:59 <merijn> solidus-river: Disregard my remark, I misread your question and answered wrong :)
10:33:46 <merijn> "data Foo = Foo !Int" <- this is a strictness annotation, it means that "Foo x" is implemented as "x `seq` Foo x"
10:34:57 <solidus-river> :t seq
10:34:58 <lambdabot> a -> b -> b
10:35:22 <merijn> "seq" is magic and it's type won't tell you much
10:35:24 <solidus-river> so its saying that x is around before the call is made to Foo?
10:35:36 <solidus-river> isn't that inherently the case?
10:35:51 <solidus-river> heh, so what magic does seq do
10:36:19 <merijn> solidus-river: Seq says "IFF 'x' and 'y' are not bottom, then after evaluating "seq x y", both 'x' and 'y' will be evaluated"
10:36:48 <solidus-river> and not bottom can be thought of as fully evaluated to concrete types?
10:37:10 <firebird1> why 'True' not 'true' why not small case
10:37:15 <savanni> merijn: wait... y, also?  Also, I thought x only got evaluated to the first constructor.  Or maybe the next.
10:37:19 <merijn> I don't know what concrete types means, but the "fully evaluated" is wrong
10:37:33 <merijn> solidus-river: Also, "evaluated" means "evaluated to WHNF"
10:37:53 <merijn> savanni: 'x' and 'y' both get evaluated to WHNF
10:38:14 <merijn> savanni: "WHNF" roughly being equal to "the first constructor"
10:38:15 <solidus-river> hmm, is it easy to express whats different between WHNF and EBNF?
10:38:17 <ReinH> firebird1: because True is a type constructor.
10:38:18 <savanni> firebird1: I assume because Bool in haskell is implemented as `data Bool = True | False`, meaning that True and False are both constructors and thus required to be capitalized by the rules of the language.
10:38:26 <ReinH> firebird1: you could define true = True, but you cannot pattern match on it
10:38:53 <merijn> solidus-river: EBNF is Extended Bacchus Naur Form, which is a way of writing grammars, WHNF is Weak Head Normal Form
10:38:53 <savanni> merijn: "WHNF" is a kinda slippery concept for me, but in retrospect having both x and y evaluated to that degree makes sense.
10:39:00 <solidus-river> merijn: awesome, taht explanation of WHNF was clear
10:39:04 <merijn> solidus-river: The two literally have nothing in common except letters
10:39:05 <firebird1> i dont understand anything in haskell
10:39:11 <firebird1> just weird language
10:39:16 <solidus-river> firebird1: than ask the most basic question and build from there :D
10:39:41 <solidus-river> merijn: kk, when you say Weak Head Normal Form it becomes much more clear what that is than WHNF :P
10:39:42 <firebird1> solidus-river, yea
10:39:47 <ReinH> firebird1: It's almost like unfamiliar things seem strange until they become familiar.
10:40:19 <merijn> solidus-river: I'm not good at explaining that, but you should be able to google for more in-depth explanation
10:40:23 <ReinH> firebird1: but acknowledging that it is not very similar to languages you are already familiar with is a good first step :)
10:41:42 <kini> there has got to be a better way to figure out what type ghc has inferred for an expression than to type "if True then expression else _" and then let ghc tell me about the hole
10:42:14 <merijn> kini: "expression `asTypeOf` _"?:)
10:42:25 <kini> wow that's so much better :P
10:42:26 <copumpkin> [expression, _]
10:42:42 <kini> copumpkin: that's the least horrific one so far :D
10:42:54 <copumpkin> well, you'll want to ask for the head of it for it to sitll work
10:43:06 <Or1> firebird1: #haskell-beginners
10:43:15 <savanni> In that particular instance, you might be able to get away with just `:t expression` since you know both expression and the hole have to match.
10:43:17 <kazagistar> presumably, IDEs would do that, assuming any exist that have ghci integration...
10:43:27 <jomg> merijn: is the type you get from :t in ghci different from the one ghc will infer?
10:43:38 <merijn> jomg: Sometimes
10:43:40 <copumpkin> GHC might instantiate some things based on context
10:43:42 <kini> is ghci integration good enough? ghci can only tell me stuff about top level expressions
10:43:49 <firebird1> is this compound statement ?  5/=4
10:44:08 <merijn> kini: hdevtools lets you query types of expressions via vim/emacs plugins
10:44:09 <kini> firebird1: that's a boolean expression meaning "five is not equal to four"
10:44:22 <kini> merijn: but hdevtools doesn't support cabal
10:44:24 <ReinH> firebird1: you might want to start with an introduction to Haskell
10:44:27 <ReinH> @where LYAH
10:44:27 <lambdabot> http://www.learnyouahaskell.com/
10:44:37 <merijn> kini: I know :(
10:44:39 <kini> :(
10:44:45 * hackagebot git-annex 5.20140606 - manage files with git, without checking their contents into git  http://hackage.haskell.org/package/git-annex-5.20140606 (JoeyHess)
10:44:46 <ReinH> firebird1: it will explain the syntax and how expressions are constructed, etc
10:44:47 <hiptobecubic> > let 5 = 5 / 4 in 5
10:44:48 <kini> also it looks like it has been abandoned (?)
10:44:48 <firebird1> ReinH, i'm learning from there
10:44:49 <lambdabot>  5
10:45:16 <ReinH> > let 5 /= 4 = True in 5 /= 4
10:45:17 <kini> the flycheck devs decided to stop supporting it for now (or at least to shunt it off into a third-party package) because they didn't see evidence of active maintenance of hdevtools
10:45:18 <lambdabot>  True
10:45:37 <kini> I'm glad you agree, lambdabot :P
10:45:38 <hiptobecubic> > 5 /= 4
10:45:41 <lambdabot>  True
10:45:43 <ReinH> > let 5 == 4 = True in 5 == 4 -- omg what is happening
10:45:44 <lambdabot>  True
10:45:55 <hiptobecubic> > let 5 = 4 in 5
10:45:57 <lambdabot>  5
10:46:04 <savanni> ReinH: Indeed.  omg what is happening???
10:46:08 <kini> > let x = x in x
10:46:12 <lambdabot>  mueval-core: Time limit exceeded
10:46:20 <ReinH> savanni: I am shadowing the definition of == in the let
10:46:25 <hiptobecubic> > let True = False in True
10:46:26 <lambdabot>  True
10:46:27 <firebird1> even though i'm learning from LYAH it just so different from other lang syntax
10:46:34 <hiptobecubic> BORING
10:46:34 <kini> > let 5 == 4 = True in 4 == 5
10:46:36 <lambdabot>  *Exception: <interactive>:3:5-17: Non-exhaustive patterns in function ==
10:46:37 <savanni> ReinH: Oh... cool!  (also, evil)
10:46:50 <albeit> > let True+False = True in True+False
10:46:52 <lambdabot>  True
10:47:08 <ReinH> let 2 + 2 = 5 in 2 + 2 -- Orwellian!
10:47:10 <ReinH> > let 2 + 2 = 5 in 2 + 2 -- Orwellian!
10:47:11 <albeit> That is so odd...
10:47:12 <lambdabot>  5
10:47:56 <kini> merijn: actually, I haven't tried hdevtools since it doesn't support cabal, but can it really give you types of expressions buried deep inside the code, under lambdas, inside do blocks, etc.?
10:48:11 <solidus-river> firebird1: what language are you coming from?
10:48:15 <solidus-river> firebird1: whats the most familiar to you?
10:48:40 <firebird1> solidus-river, i'm from functional language javascript
10:49:12 <ReinH> Well, it has functions at least.
10:49:35 <ReinH> Although they don't behave like functions.
10:49:46 <solidus-river> firebird1: javascript is not functional
10:50:06 <firebird1> solidus-river, its functional
10:50:14 <benzrf> is there a rectangle monad
10:50:22 <benzrf> and/or rectangle data structure
10:50:23 <ReinH> Depending on your definition of "functional"
10:50:23 <solidus-river> firebird1: yeah it works
10:50:26 <bennofs> at least it's not dysfunctional .... :>
10:50:32 <solidus-river> :P
10:50:34 <ReinH> If your definition includes "has things called functions that behave like functions" then no
10:50:42 <savanni> You can pass functions around as first-class data types.
10:50:59 <firebird1> ^
10:51:10 <ReinH> But then that leaves you with basically Haskell and a few other less-mainstream langauges.
10:51:25 <kini> by "behave like functions" do you mean "are referentially transparent"
10:51:31 <bennofs> javascript is arguably more functional than many other languages, or at least allows to be used in such a style better
10:51:35 <yogurt_truck> s/functional language javascript/language that allows you to do higher-order programming javascript/
10:51:37 <glguy_> Functional programming is more than first-class functions
10:51:48 <companion_cube> it's also emphasis on immutability
10:51:53 <ReinH> kini:  I would start with accept "always provide the same output for a given input"
10:52:07 <kini> isn't that what referentially transparent is
10:52:35 <ReinH> referential transparency is about substitutability
10:52:43 <yogurt_truck> firebird1: JS is literally one of the worse languages for functional programming. You literally cannot assume that even the expression `x + y` won't launch missiles, etc.
10:52:51 <ReinH> an expression is RT if it can be replaced with its value without altering the behavior of a program
10:53:02 <yogurt_truck> literal literally literally!
10:53:08 <kini> sure, but can you ever have "always provide the same output for a given input" without referential transparency or vice versa
10:53:15 <kini> I suppose it depends on what you mean by "provide output"
10:53:54 <ReinH> purity implies RT, I'm not sure about the other way
10:54:35 <firebird1> yogurt_truck, i would accept it as worst language but this phrase what is emphasis on " for functional programming You literally cannot assume that even the expression `x + y` won't launch missiles, etc."
10:54:51 <firebird1> my english is bad
10:55:06 <savanni> firebird1: it's a hyperbolic way of saying that in Javascript you cannot trust even something as simple as `x + y` to do what you expect.
10:55:37 <firebird1> i agree on that
10:57:54 <companion_cube> yogurt_truck: so + is overloadable in JS?
10:58:03 <ReinH> A more practical barrier to functional programming in JS is the difficulty of currying and uncurrying functions
10:58:13 <ReinH> It's all well and good to be able to pass around functions as first-class values
10:58:25 <ReinH> but if you can't define a curried function, that facility becomes less important
10:58:54 <ReinH> Higher order functions become less useful without ubiquitous currying
10:59:01 <yogurt_truck> companion_cube: JS objects have a `.valueOf` and a `.toString` method, that may get called for `x` and/or `y` in for example the expression `x + y`. Moreover, you have a `.prototype` semantics that allows anyone, anywhere, to set those methods for _all_ the objects, at any point, globally
10:59:04 <ReinH> or partial application
10:59:26 <companion_cube> hmm, sounds.... yuck
10:59:47 * hackagebot cpsa 2.3.4 - Symbolic cryptographic protocol analyzer  http://hackage.haskell.org/package/cpsa-2.3.4 (JohnRamsdell)
11:01:17 <ReinH> You can write JS in such a way that you can define var mapTimes2 = map(function(x){x*2}) and then apply it to an array. No one really does this because the language has no built-in facility for partial application. It is flexible enough to let you write it as a library, though, so there's that.
11:01:45 <benzrf> heyj:
11:01:48 <benzrf> *hey
11:02:13 <benzrf> where may i find a grid monad
11:02:20 <ReinH> benzrf: what is a grid monad?
11:02:24 <benzrf> 2d list
11:02:29 <ReinH> what does it do as a monad?
11:02:34 <benzrf> Grid (Grid a) -> Grid a
11:02:35 <kadoban> In short, JS isn't really functional, it's just more functional than C/C++/Java/whatever other languages people are commonly comparing it to.
11:02:47 <yogurt_truck> ReinH: those are actually trivial things to achieve. Also there actually is a built-in facility for partial application
11:02:47 <benzrf> ReinH: i suppose that would rely on length :\
11:02:49 <benzrf> *size
11:03:05 <ReinH> yogurt_truck: What is this built-in facility?
11:03:08 <yogurt_truck> ReinH: but there's other awful problems that make even HOP clumsy in JS
11:03:36 <yogurt_truck> ReinH: Function.prototype.bind
11:03:47 <ReinH> benzrf: newtype Grid a = Grid [[a]]; instance Functor Grid where fmap f (Grid a) =  Grid $ fmap (fmap f) a
11:03:52 <ReinH> benzrf: what would the monad do?
11:04:11 <benzrf> ReinH: i was thinkin that a grid of grids becomes a gridaphobe
11:04:12 <benzrf> *grid
11:04:17 <ReinH> yogurt_truck: how does bind allow partial application?
11:04:17 <benzrf> 2d concat
11:04:21 <benzrf> 02:01 < benzrf> ReinH: i suppose that would rely on length :\
11:04:47 * hackagebot format-status 0.2.0.0 - A utility for writing the date to dzen2.  http://hackage.haskell.org/package/format-status-0.2.0.0 (georgerogers42)
11:05:05 <ReinH> benzrf: so concatMap for grids
11:05:11 <yogurt_truck> ReinH: by letting you partially apply functions? I don't understand the question
11:05:23 <yogurt_truck> do you mean the syntax?
11:05:30 <ReinH> yogurt_truck: can show me an example of using bind for partial application?
11:05:49 <yogurt_truck> ReinH: i.e. (function (x, y, z) { return x + y + z}).bind(undefined, 20, 20)(2) == 42
11:06:01 <benzrf> ReinH: yea
11:06:20 <benzrf> ReinH: like the reverse of an image comonad
11:07:03 <yogurt_truck> sorry, less Perl-y: `var f = function (x, y, z) { return x + y + z}; var g = f.bind(undefined, 20, 20); g(2) == 42`
11:07:41 <ReinH> yogurt_truck: That isn't partial application though
11:08:06 <ReinH> partial application would be f(1,2)(3)
11:08:16 <ReinH> you can use bind to implement partial application
11:08:22 <ReinH> or f(1)(2)(3)
11:08:29 <ReinH> Ah.
11:08:39 <ReinH> Sorry. That's partial application, but not currying.
11:08:45 <bennofs> ReinH: you can write a curry function in javascript though, so that curry(f)(1)(2)(3) = f(1,2,3) I think
11:08:53 <ReinH> bennofs: yes, I said that it's implementable
11:09:01 <ReinH> I said that it isn't provided by the language
11:09:16 <ReinH> which means no one actually does this in practice
11:09:24 <ReinH> they just write clever blog posts about the fact that you *can* do this ;)
11:09:38 <Hodapp> I guess that's better than calling it a Design Pattern and writing a book about how they're awesome.
11:09:41 <yogurt_truck> ReinH: ah ok. Yes, functions are not curried. And it's indeed a pain. But people do use this in practice (I certainly do).
11:09:58 <ReinH> yogurt_truck: full ack :)
11:10:40 <ReinH> bennofs: concatMap takes a list of lists and turns them into a list. This list has length of sum (map length xs).
11:10:54 <ReinH> bennofs: concatGrid :: Grid (Grid a) -> Grid a, what does it do?
11:11:00 <ReinH> how large is the resulting grid?
11:11:01 <bennofs> ReinH: you mean benzrf ? :)
11:11:07 <ReinH> bennofs: yes sorry
11:11:11 <ReinH> benzrf: ^
11:11:48 <ReinH> you can use sequence to turn Grid [a] into [Grid a], but that isn't join.
11:12:09 <ReinH> that's turning a "grid of choices" into a "choice of grids"
11:12:44 <benzrf> ReinH: er.
11:12:50 <benzrf> given a grid of grids
11:12:52 <benzrf> makes a normal grid?
11:13:03 <benzrf> glues together each grid?
11:13:13 <benzrf> 02:01 < benzrf> ReinH: i suppose that would rely on length :\
11:13:18 <ReinH> you want concatGrid to turn an NxM grid of N'xM' grids into an (N*N')x(MxM') grid
11:13:32 <ReinH> You'd need typelevel nats to do it safely, at leaset, I think
11:14:10 <benzrf> yeltzooo: yeah
11:14:11 <benzrf> * ReinH
11:14:16 <benzrf> ;-;
11:14:21 <ReinH> So it could be done but it would take a bit of machinery and probably be annoying to work with
11:14:46 <ReinH> It also doesn't seem to be a very useful monad
11:15:02 <benzrf> hmmm
11:15:07 <benzrf> true i suppose =p
11:15:11 <ReinH> a function Grid [a] -> Grid a seems more useful
11:15:19 <ReinH> er Grid [a] -> [Grid a]
11:15:26 <ReinH> which is sequence . map sequence iirc
11:15:35 <ReinH> it's in Bird's Sudoku solution
11:16:15 <bennofs> ReinH: that looks like Traversable Grid and sequenceA
11:16:31 <ReinH> yep
11:17:05 <ReinH> so per usual, Functor and Traversable instances are generally useful for containers with structure ;)
11:22:00 <bitemyapp> Does something like this http://jafingerhut.github.io/cheatsheet-clj-1.3/cheatsheet-tiptip-cdocs-summary.html exist for Haskell?
11:22:51 <c_wraith> bitemyapp: there are a couple things..  let me look
11:23:07 <ReinH> that's quite nice
11:23:22 <c_wraith> hmm.  http://dev.stephendiehl.com/hask/ is similar in spirit, but missing the "compact" portion
11:23:25 <michaelt> http://cheatsheet.codeslower.com/CheatSheet.pdf in theory
11:23:28 <bitemyapp> ReinH: yeah, they need the goal/data structure oriented organization.
11:23:35 <ReinH> c_wraith: I love that link
11:23:48 <ReinH> bitemyapp: yeah it's quite nice. Also search.
11:23:51 <bitemyapp> c_wraith: I love his guide, but that's a very different thing.
11:23:54 <bitemyapp> ReinH: yep.
11:24:00 <ReinH> bitemyapp: please do implement :)
11:24:05 <bitemyapp> michaelt: closer, but needs to be a web page with search and I don't like the organization.
11:24:14 <bitemyapp> michaelt: in fact, I remember this cheat sheet now
11:24:14 <ReinH> So no. No it doesn't exist.
11:24:16 <ReinH> Fix that.
11:24:19 <bitemyapp> michaelt: I wrote a PR correcting this cheat sheet.
11:24:24 <bitemyapp> because it had a number of mistakes.
11:24:30 <bitemyapp> yeah, I'll have to write my own.
11:24:42 <bitemyapp> ReinH: I bet I could even break out sub-categories in the cheatsheet via parametricity.
11:24:52 <ReinH> stahp
11:24:58 <bitemyapp> ReinH: "these are all valid implementations for this type, here's what each does"
11:25:01 <bitemyapp> ReinH: what?
11:25:07 <ReinH> sub-categories? :p
11:25:10 <ReinH> wat r u doing
11:25:31 <bitemyapp> ReinH: I wasn't trying to be punny, I mean the cheat-sheet spatial layout.
11:26:02 <benzrf> hey
11:26:04 <ReinH> bitemyapp: ah. Ok. That makes sense.
11:26:06 <benzrf> given f and g
11:26:16 <benzrf> is there a way to more beautifully get
11:26:20 <ReinH> bitemyapp: usually via parametricity there aren't very many valid implementations for a type
11:26:23 <benzrf> (>>= f . (>>= g))
11:26:43 <ReinH> f >=> g ?
11:26:52 <benzrf> eeeh
11:26:57 <ReinH> what's the type of this thing?
11:26:57 <benzrf> seems wrong somehow p:
11:27:04 <c_wraith> the fish operators are great
11:27:10 <michaelt> oh, the one c_wraith linked really is nice.
11:27:12 <benzrf> @hoogle
11:27:13 <bennofs> :t \f g -> (>>= f . (>>= g))
11:27:13 <benzrf> oops
11:27:13 <lambdabot> No query entered
11:27:13 <lambdabot> Try --help for command line options
11:27:14 <lambdabot> (Monad m1, Monad m) => (m1 b1 -> m b) -> (a -> m1 b1) -> m (m1 a) -> m b
11:27:19 <bennofs> :O
11:27:21 <ReinH> you think that composing monadic computations with the monadic computation composition operator is wrong? :p
11:27:27 <c_wraith> michaelt: there's a ton of great info there - it's just not compact. :)
11:27:32 <benzrf> ReinH: diff kind of comp
11:27:40 <ReinH> Ah hmm
11:28:03 <michaelt> yeah. it needs to start with how to call ghc with optimization flags
11:28:10 <benzrf> meh doesnt rly matter
11:28:10 <ReinH> benzrf: oh, you're switching monads
11:28:12 <bitemyapp> ReinH: there are at least 4 implementations of: Num a => a -> a -> a
11:28:34 <ReinH> bitemyapp: right, you get more implementations *as the types become less uniform* :p
11:28:37 <haasn> there are at least an infinite number of them :p
11:28:45 <stephenmac7> How would I go about performing a procedure using FRP?
11:28:48 <c_wraith> there are also at most an infinite number of them!
11:28:57 <ReinH> which infinite number?
11:29:05 <haasn> the smallest one
11:29:06 <bitemyapp> three of: Eq a => [a] -> [a] -> [a]
11:29:09 <bitemyapp> ReinH: right!
11:29:11 <ReinH> haasn: winner
11:29:24 <bitemyapp> ReinH: I want to make the pattern manifest in the presentation.
11:29:31 <benzrf> ReinH: i am not actually
11:29:50 * hackagebot stable-tree 0.2.0 - Trees whose branches are resistant to change  http://hackage.haskell.org/package/stable-tree-0.2.0 (tsuraan)
11:29:51 <ReinH> benzrf: er?
11:29:57 <benzrf> er hm
11:29:59 <ReinH> Mum a is finite
11:30:15 <bitemyapp> my Mum is large and contains multitudes, yes.
11:30:18 <rwbarton> what a helpful package description there
11:31:00 <aviran>  Hey, a little off topic,  lim n->inf n/log(n)^2 equals infinity... can i assume that O(n + log(n)^2) = O(n) ?
11:31:13 <benzrf> @hoogle (m a -> m (m a)) -> (a -> m a) -> m (m a) -> m (m a)
11:31:14 <lambdabot> No results found
11:31:17 <benzrf> kk
11:31:53 <michaelt> rwbarton: do you mean the stable-trees package?
11:31:58 <ReinH> benzrf: wait, it's finite, wtf
11:32:00 <rwbarton> yes
11:32:08 <ReinH> benzrf: stahp lying :p
11:32:22 <joelteon> aviran: i think you can
11:32:27 <benzrf> ReinH: huh?
11:32:35 <michaelt> rwbarton, the haddocks don't build either
11:32:50 <rwbarton> I think just because it is brand new
11:33:01 <ReinH> benzrf: Er, Num a => a has infinitely many inhabitants right? Because of lazy nats?
11:33:19 <benzrf> hmm?
11:33:42 <int-index> Why do lens compose backwards? I mean, what is the rationale behind it, except that it looks OOP-ish?
11:33:55 <michaelt> int-index: it follow from the type
11:33:58 <jle`> int-index: "compose backwards" ?
11:34:00 <glguy_> They look backwards because your intuition for them is backwards
11:34:03 <jle`> "backwards" ?
11:34:06 <jle`> pls explain
11:34:25 <ReinH> benzrf: There are x^x functions of type Num a => a -> a where x is the number of inhabitants of Num a => a
11:34:43 <glguy_> (a -> f b) -> (s -> f t) --- They take a function on "inner" types and lift it to work on "outer" types
11:35:00 <jle`> there is only one arrow for the Num instance of ()
11:35:11 <int-index> jle`: consider this
11:35:12 <int-index> view _1 . view _2 :: (c, (a,b)) -> a
11:35:15 <benzrf> int-index: its how the type works
11:35:21 <int-index> view (_1 . _2)    :: ((b,a) ,c) -> a
11:35:30 <benzrf> int-index: look @ this
11:35:36 <int-index> Instead, I'd expect them to be the same
11:35:56 <benzrf> (map . fmap) (+2) [Just 1, Nothing, Just 5]
11:36:00 <benzrf> > (map . fmap) (+2) [Just 1, Nothing, Just 5]
11:36:02 <lambdabot>  [Just 3,Nothing,Just 7]
11:36:03 <ReinH> benzrf: well there are X^X functions from X to X
11:36:08 <benzrf> int-index: why is map . fmap backwards??
11:37:20 <int-index> benzrf, nice point. I need to digest it
11:37:20 <ReinH> benzrf: that's the best explanation I've seen yet. Well done. :)
11:37:32 <benzrf> ReinH: i cant take credit p:
11:37:39 <benzrf> ReinH: i saw it somewhere else, idk where
11:37:49 <jle`> there was a reddit post on it a couple months ago i think
11:37:56 <ReinH> benzrf: fine, I take it back
11:37:58 <jle`> not to take away credit to benzrf where it is deserved
11:38:05 <ReinH> nope, none is deserved
11:38:11 <ReinH> credit descinded
11:38:14 <ReinH> rescinded
11:38:20 <rwbarton> or consider
11:38:22 <glguy_> int-index: (over _2 . over _1) succ (1,(2,3))  === (over (_2 . _1) succ) (1,(2,3))
11:38:23 <rwbarton> :t over _1 . over _2 :: (x -> y) -> ((a,x),b) -> ((a,y),b)
11:38:24 <lambdabot> (x -> y) -> ((a, x), b) -> ((a, y), b)
11:38:25 <rwbarton> :t over (_1 . _2) :: (x -> y) -> ((a,x),b) -> ((a,y),b)
11:38:26 <lambdabot> (x -> y) -> ((a, x), b) -> ((a, y), b)
11:38:39 <glguy_> rwbarton: Quit looking at my terminal ;-)
11:39:06 <int-index> makes sense now, thank you
11:39:29 <jle`> ReinH: wait
11:39:35 <jle`> Num a => a -> a -> a
11:39:45 <jle`> a -> a might have X^X inhabitants
11:39:49 <jle`> but if all you know is Num
11:39:52 <ReinH> right
11:39:58 <jle`> you can only use methods from the Num typeclass
11:40:13 <ReinH> jle`: why?
11:40:16 <ReinH> why can't I use id?
11:40:18 <jle`> so you can only use (+), (*), (-), negate, abs, signum, fromInteger
11:40:22 <jle`> oh yeah
11:40:40 <jle`> well, from the Num typeclass, and normal parametric functions >_>
11:40:40 <ReinH> And even with that restriction, I have:
11:40:44 <ReinH> f a b = neg a
11:40:49 <ReinH> f1 a b = neg (neg a)
11:40:55 <ReinH> f2 a b = neg (neg (neg a))
11:40:56 <ReinH> ...
11:40:58 <jle`> hm
11:41:05 <rwbarton> how about f a b = fromInteger 0
11:41:10 <rwbarton> f1 a b = fromInteger 1
11:41:21 <jle`> i did not think this through
11:41:56 <jle`> but also there aren't many functions f :: a -> a -> a hat are out there, are there?
11:42:02 <jle`> besides const and id
11:42:10 <jle`> and id.id
11:42:14 <jle`> >_>
11:42:17 <ReinH> Heh
11:42:21 <ReinH> > id id id id id id id 1
11:42:22 <lambdabot>  1
11:42:38 <jle`> still there are some reduction laws you can play with
11:42:53 <jle`> but i guess fromInteger can give you infinitely many integers, so
11:42:54 <ReinH> Now, if you want to look at the size up to equivalence
11:43:27 <ReinH> so forall a. g(a) = h(a) => g = h
11:43:50 <jle`> won't be replying cause i have to run, but feel free to continue
11:45:03 <ReinH> up to that equivalence you get the usual size of a function space X -> Y = Y^X
11:46:15 <ReinH> |Y|^|X|, that is
11:57:34 <enthropy> are you supposed to use mtl-2.1.3.1 instead of mtl-2.2.1 if you also want to depend on the ghc-api?
11:57:58 <enthropy> since the ghc package seems to depend on transformers-0.3
11:58:53 <bennofs> enthropy: probably. If you depend on the GHC API, prepare to have to depend on outdated versions of libraries (Cabal, binary, transformers, etc)
12:00:40 <michaelt> does ghc-7.8 use transformers-0.3 still?
12:02:18 <rwbarton> yes
12:03:08 <michaelt> thats what I figured I'm using some pre-release version.
12:03:35 <michaelt> enthropy: maybe you can figure out what is going on with 'transformers-compat' and evade things that way
12:09:22 <n-dolio> rwbarton: By the way, with regard to our conversation yesterday, contravariant functors have about the same problem.
12:09:33 <n-dolio> You can't write a normal fold for them.
12:09:47 <joelteon> anyone know if Hans Hoglund, the guy who wrote music-suite, ever comes in here?
12:09:58 <n-dolio> So what are they?
12:10:43 <rwbarton> n-dolio: yeah
12:10:45 <hexagoxel> any function Rational->String that does 4%3 => "1 1/3"
12:11:28 <n-dolio> It seems like initial algebra semantics is not the right thing to model them.
12:12:16 <n-dolio> But I don't know what kind of universal operation captures what you can do with them.
12:13:15 <rwbarton> also it's hard to have any simple intuition for these things because I don't think any non-trivial contravariant functor that you can define in Haskell has a fixed point in sets (for cardinality reasons)
12:13:17 <n-dolio> Like, if you have both algebra and coalgebra like things, you can fold a negative type. But I don't know if that's necessary or just sufficient.
12:14:32 <n-dolio> Well, I have better intuition for Haskell-like types anyway.
12:15:27 <n-dolio> Talking about sets doesn't get me more intuition. :)
12:15:56 <carter> jle`: no clue
12:16:05 <carter> joelteon: no clue, email him
12:16:14 <carter> the ammount of docs to start with is improessive
12:16:17 <carter> i'm jealous
12:17:02 <rwbarton> n-dolio: well, it's a least a better behaved category than any of the categories of domains AFAIK
12:17:23 <rwbarton> granted, Fix (\a. a -> r) is going to be a pretty non-intuitive thing no matter how you manage to model it
12:17:44 * rwbarton should actually read that book on domain theory some day, instead of just skimming through it
12:17:59 <joelteon> yes, there are significant bugs though
12:18:00 <n-dolio> I guess it's clear that you're not going to be doing any kind of straight forward recursion on N ~\= (N -> Bool) or something.
12:18:24 <n-dolio> Because when you match on the constructor for an N, you get an N -> Bool, which isn't something you can call yourself recursively with.
12:18:29 <n-dolio> You don't have additional Ns.
12:23:37 <n-dolio> rwbarton: I was trying earlier to covariantize things, and seeing if that would work.
12:24:00 <n-dolio> Like, data Co f a = forall e. Co (e -> a) (f e)
12:24:06 <rwbarton> right
12:24:14 <n-dolio> Then Fix f = Fix (Co f (Fix f))
12:24:28 <n-dolio> Which you can easily fold, if you have a Co f algebra.
12:24:43 <n-dolio> But, I think you've just pushed the problem to writing the algebra.
12:25:18 <rwbarton> yeah, a Co f algebra is a totally different thing than an f algebra
12:25:24 <rwbarton> they are only related "globally"
12:25:54 <n-dolio> Or, if you have the normal Fix, then Fix f and Fix (Co f) are not obviously isomorphic.
12:25:57 <rwbarton> like having a Co f algebra for every type is the same as having an f algebra for every type, or something
12:26:03 <n-dolio> Unless f is a functor.
12:26:57 <n-dolio> So that is not how you make sense of negative types.
12:29:58 <michaelt> hexagoxel: it shouldn't be hard to construct one, no?
12:34:24 <michaelt> > let numbers n = let x = denominator n in (numerator n `quotRem` x, x) ; pretty ((a,b),c) = show a ++ " " ++ show b ++ "/" ++ show c in pretty $ numbers (361 % 360)
12:34:26 <lambdabot>  "1 1/360"
12:34:35 <rwbarton> n-dolio: Actually, this gets closer to the core of my original question, which wasn't really about Fix
12:34:35 <hexagoxel> michaelt: sure, already did. still expected that Data.Ratio defines it
12:34:56 <n-dolio> rwbarton: I gathered.
12:35:04 <rwbarton> n-dolio: if g is a functor then giving a polymorphic function forall a. Co f a -> g a is the same as giving a polymorphic function forall a. f a -> g a, right?
12:35:18 <n-dolio> I assume the question is, "what does this thing I wrote down mean?"
12:36:09 <n-dolio> If g is a functor?
12:37:16 <n-dolio> I guess either f or g could be a functor for that to work out.
12:37:19 <rwbarton> well, I have for any f, forall a. f a -> Co f a
12:37:28 <rwbarton> ah, sure
12:37:59 <hexagoxel> michaelt: thanks anyway :)
12:38:06 <rwbarton> let's say I define a category Hask(* -> *) whose objects are type constructors of kinds * -> * and whose morphisms f ~> g are polymorphic functions forall a. f a -> g a
12:38:18 <rwbarton> inside that, I have a full subcategory of functors (and natural transformations)
12:39:06 <michaelt> hexagoxel: I think it must fail that rule Fairbourne or Fairweather or whaterver, about easy to define functions.
12:39:08 <rwbarton> Co is a coreflection onto this subcategory
12:40:56 <rwbarton> my question is basically: what "semantic" category is this picture supposed to remind me of? as in any honest-to-goodness category that I can write down as a mathematical object
12:42:41 <rwbarton> for example, I could say that Haskell types remind me of sets, and type constructors that are functors remind me of functors from Set to Set
12:43:25 <rwbarton> but then I don't know what I should take as the analogue of Hask(* -> *), that contains {functors from Set to Set} as a full subcategory but also contains things like contravariant functors
12:45:19 <d3lxa> how is this possible it's well type compile-time: http://sprunge.us/RFbh (end up with Exception: No match in record selector)?
12:47:05 <michaelt> it's well-typed, its just that b is a terrible function
12:47:19 <shergill> is there some resource which elaborates on hask the category?
12:48:03 <shergill> or is there a google-able characterization of it (using category theory terms)?
12:49:32 <d3lxa> michaelt: is there a good reason this is allowed then? it sure seem to lead to bad design, isn't it?
12:50:01 <michaelt> d3lxa: yes, it's horrible, but I think there are use cases.  I felt the same as you when I first saw it.
12:51:52 <d3lxa> michaelt: do you have something in mind? it would be better then to separate the types of A and B, then merge them with a black box right?
12:51:53 <michaelt> d3lxa: in lens and prism land, they can get most of the desired effects without that kind of partiality, I'd think
12:53:04 <d3lxa> michaelt: this design seems better, isn't it http://sprunge.us/TSPj ?
12:53:54 <d3lxa> (moreover A and B don't share anything at all at the end)
12:56:30 <shergill> answering my own question <http://www.haskell.org/haskellwiki/Hask> provides good pointers
13:00:13 <n-dolio> rwbarton: Functions from sets to sets?
13:02:03 <n-dolio> I.E, every functor F : Sets -> Sets has a component (under certain formulations) F_0 that is a function from sets to sets.
13:02:38 <n-dolio> (Ignoring size issues.)
13:02:44 <rwbarton> n-dolio: then {functors & natural transformations} isn't a full subcategory
13:03:31 <rwbarton> if I start with a functor, and then "forget" to the bigger category by throwing away the action on morphisms, and then I consider morphisms between two of those, they're nonparametric polymorphic functions
13:03:51 <n-dolio> Well, that's because sets suck. :)
13:05:48 <rwbarton> I'm happy to replace Set, but I'd have the same problem with endofunctors of any category, if I pass to endofunctors from the discretized category
13:06:45 <n-dolio> Yes. Polymorphic type theory has a notion of uniformity built into it.
13:07:02 <n-dolio> That category theory tries to graft on to something without it with natural transformations.
13:09:40 <n-dolio> So all polymorphic things are uniform in the right way to be natural when you start considering the functorial structure.
13:10:46 <rwbarton> right, so I read a little bit about relational parametricity and I tried working in a category of sets and relations
13:12:13 <rwbarton> where we can say that an endofunctor is, uh, a "function functor", if it takes function-like relations (a R b = (b == f(a))) into function-like relations
13:13:15 <rwbarton> I can't quite tell whether it's working, though
13:13:31 <michaelt> d3lxa have you looked at the way prisms are used in the lens library? _Right and _Left, for example, are a bit like your original a and b, as if it was data Either x y = Left {_Left :: x} | Right {_Right :: y}
13:13:34 <n-dolio> Dunno.
13:14:10 <d3lxa> michaelt: I read recently about prism, yeah :D fancy stuff, a lens should suffice here right?
13:14:35 <d3lxa> so you propose to use Either instead of this kind of pattern?
13:15:08 <michaelt> d3lxa: the original D was like Either Int Int
13:15:24 <michaelt> > > over (traverse . _2 . _Right) (10^) [(False,Left "hello"), (True, Right 13)]
13:15:25 <lambdabot>  <hint>:1:1: parse error on input ‘>’
13:15:30 <michaelt> > over (traverse . _2 . _Right) (10^) [(False,Left "hello"), (True, Right 13)]
13:15:32 <lambdabot>  [(False,Left "hello"),(True,Right 10000000000000)]
13:16:27 <michaelt> > (Right 1 ^? _Left, Right 1 ^? _Right)
13:16:29 <lambdabot>  (Nothing,Just 1)
13:16:34 <michaelt> and so on
13:18:02 <d3lxa> michaelt: yes that's right, I got this code from a guy comparing scala and haskell, to say the original is not type-safe, but surely it's a weird design where one has Either, etc, Lens
13:18:09 <michaelt> d3lxa: so instead of using those partial record accessors, you would derive a prism for data D = A Int | B Int , _A and _B rather than a and b, then theres a pile of sensible uses
13:18:50 <albeit> > _Right  (Right 5)
13:18:52 <lambdabot>  Could not deduce (Data.Profunctor.Choice Data.Either.Either)
13:18:52 <lambdabot>    arising from a use of ‘Control.Lens.Prism._Right’
13:18:52 <lambdabot>  from the context (Control.Applicative.Applicative f,
13:18:52 <lambdabot>                    GHC.Num.Num (f b))
13:18:52 <lambdabot>    bound by the inferred type of
13:19:42 <michaelt> d3lxa: I just mentioned Either because the library already exports _Left and _Right which are its (somewhat remote) equivalents, for the somewhat similar case of Either a b , which is a sum type like your D
13:20:02 <albeit> > (Right 5) ^._Right
13:20:06 <lambdabot>  No instance for (GHC.Show.Show a0)
13:20:08 <lambdabot>    arising from a use of ‘M68841597660200838527640.show_M68841597660200838527...
13:20:10 <lambdabot>  The type variable ‘a0’ is ambiguous
13:20:12 <lambdabot>  Note: there are several potential instances:
13:20:15 <lambdabot>    instance [safe] GHC.Show.Show
13:20:16 <kini> "y <- foo ; f x y" can be written more concisely as "f x =<< foo", but is there some way to do "x <- foo ; g x y" without using flip?
13:20:55 <rwbarton> well, (`g` y) =<< foo
13:20:57 <albeit> kini: Maybe "g <$> foo <*> pure y"?
13:21:41 <michaelt> > Right "hello" ^. _Right
13:21:42 <lambdabot>  "hello"
13:22:04 <rwbarton> or you can use the lens placeholder operator
13:22:16 <rwbarton> g ?? y =<< foo (not sure of precedence, might nede more parens)
13:22:23 <michaelt> > Left "hi"  ^. _Right
13:22:25 <lambdabot>  ()
13:22:45 <rwbarton> these are basically just flip in other clothing though
13:23:01 <pavonia> :t  Left "hi" ^. _Right
13:23:02 <lambdabot> Monoid b => b
13:23:44 <bitemyapp> empty abuse.
13:23:49 <kini> <albeit> kini: Maybe "g <$> foo <*> pure y"?
13:23:50 <kini> is that actually the same type though?
13:23:52 <pavonia> :t Left 123 ^. _Left
13:23:53 <lambdabot> (Monoid a, Num a) => a
13:23:53 <michaelt> >  Left "hi" ^. _Right :: Sum Int
13:23:55 <lambdabot>  Sum {getSum = 0}
13:24:16 <bitemyapp> > Left "hi" ^. _Right :: [Int]
13:24:18 <lambdabot>  []
13:24:46 <kini> oh, I guess it is
13:24:49 <kini> missed the "pure" there
13:25:03 <rwbarton> it still isn't
13:25:08 <rwbarton> you need a join outside
13:25:22 <albeit> :t join
13:25:22 <michaelt> d3lxa: so the naive 'accessor' use will not type check unless it can give a Monoid as a result for the bad cases
13:25:23 <lambdabot> Monad m => m (m a) -> m a
13:25:28 <albeit> Ah
13:25:57 <kini> :t \foo g y -> flip g y =<< foo
13:25:57 <kini> :t \foo g y -> g <$> foo <*> y
13:25:58 <lambdabot> Monad m => m a -> (a -> b1 -> m b) -> b1 -> m b
13:25:58 <rwbarton> you can tell it's different, since you can't write (>>=) using the Applicative class functions
13:25:58 <lambdabot> Applicative f => f a1 -> (a1 -> a -> b) -> f a -> f b
13:26:22 <kini> oops, forgot the "pure" again, but I see where the join is necessary
13:26:26 <kini> there's no m in the (a1 -> a -> b)
13:26:46 <rwbarton> right
13:27:16 <kini> (`g` y) =<< foo is indeed just flip in other clothing :)
13:27:37 <hexagoxel> but so is (=<<)
13:27:37 * kini sighs
13:27:38 <kini> I guess I'll just write a two-line do block, it'll be more readable anyway
13:27:51 <kini> =<< is eminently readable though :) (imo)
13:28:30 <kini> actually, why isn't =<< the base form with >>= being derived?
13:29:01 <bitemyapp> kini: good question.
13:30:31 <velpro> what would you guys recommend as a haskell http stack?
13:30:33 <bennofs> kini: probably because >>= feels more natural when translating from do notation
13:30:40 <kini> bitemyapp: silly answer: because the haskell logo backwards looks dumb :P
13:30:42 <velpro> im planning on having a rest services and serving static files
13:30:51 <velpro> currently i do everything with yesod
13:31:10 <bitemyapp> kini: yeah lets go with that.
13:31:20 <kini> bennofs: I guess there is that... but I thought do notation was just a "lapse" into imperative-style programming, so why would we base conventions on it?
13:31:22 <bitemyapp> velpro: is there a problem with Yesod?
13:31:46 <velpro> bitemyapp: i have a feeling it will be a bit too resource expensive and slow for static files
13:31:51 <kini> I asked a question on stackoverflow a long time ago about the order of nesting in list comprehensions, and "because it fits with do notation" was the answer I got there too
13:32:00 <bitemyapp> velpro: don't prematurely optimize pls :|
13:32:09 <velpro> well
13:32:09 <bennofs> kini: do a <- x; b <- y; c <- z; return $ a + b + c translating this to x >>= \a -> y >>= \b >>= z >>= \c -> return $ a + b + c is easy, I don't really know how to translate it using (=<<)
13:32:11 <bitemyapp> velpro: wait until you can measure something and prove there's a real problem.
13:32:19 <bitemyapp> velpro: and if you're about to link techempower, don't.
13:32:26 <velpro> bitemyapp: ?
13:32:30 <bitemyapp> velpro: those benchmarks are based on the 7.4 version of the compiler which is freakin' ancient.
13:32:43 <bitemyapp> velpro: can you even define what 'performance' means here?
13:32:48 <kini> (reference: http://stackoverflow.com/questions/10399577 )
13:32:50 <velpro> bitemyapp: all i really need to do is 2 things
13:32:55 <bitemyapp> velpro: static files could get served by nginx iwth anything dynamic being the yesod app.
13:32:56 <velpro> rest services and static files
13:33:00 <bennofs> kini: >>= fits better with lambdas. Lambdas take the argument first, then the body.
13:33:02 <rwbarton> bennofs, well, write everything backwards and add lots of parentheses
13:33:10 <bitemyapp> velpro: okay, so what's the problem?
13:33:13 <jxv> velpro, redirect nginx or whatever your using for static files. That's what yesod suggests anyways.
13:33:21 <velpro> ah ok
13:33:22 <bennofs> rwbarton: yeah, but that makes my head hurt :P
13:33:22 <rwbarton> both of which are quite annoying
13:33:22 <hexagoxel> we need a reverse polish do-notation!
13:33:27 <kini> bennofs: that's true
13:33:31 <velpro> what about the rest services
13:33:37 <velpro> ive heard a lot about fastcgi
13:33:41 <velpro> is it worth looking into?
13:35:28 <piezoid> velpro: Yesod is fine for rest services. For small and api only applications, i tend use scotty.
13:35:56 <velpro> ok then ill just go with yesod for rest and nginx for static
13:36:02 <bitemyapp> velpro: good :)
13:36:10 <velpro> thanks :)
13:36:24 <hexagoxel> kini: if a monad describes a sequence of actions, i do not think that writing them left-to-right (and top-to-bottom) is a "lapse into imperative-style" that should be avoided
13:36:30 <rwbarton> I think the actual history is that at some point (with "monadic IO", but before "Monad") people were writing programs like     putStrLn "What's your name?" `thenIO`    getLine `bindIO` \name ->    putStrLn ("Hello, " ++ name)
13:36:52 <kini> hexagoxel: but does a monad describe a sequence of actions? :P
13:36:56 <rwbarton> and then thenIO, bindIO were generalized into (>>), (>>=) and made part of a class
13:37:04 <bennofs> kini: in the case of IO, yes
13:37:22 <shachaf> GHC code still had some instances of "thenFoo" that didn't use Monad, last time I looked.
13:37:43 <jxv> kini, a monad describes an interdependent relationship between the inner and outer data types.
13:38:06 <piezoid> velpro: yesod's static subsite seems to be quite fast too : http://www.yesodweb.com/blog/2010/08/static-file-optimizations
13:38:14 <pejo> Are people workng on a new Haskell Platform? The homepage still claims the next release is 2013 something, and the github repository hasn't had any commits for quite some time.
13:38:22 <bitemyapp> pejo: don't use Platform.
13:38:24 <rwbarton> pejo, yes
13:38:27 <bitemyapp> pejo: what OS/distro are you on?
13:38:50 <pejo> bitemyapp, I'm incompetent. A platform would be stellar.
13:39:01 <bitemyapp> pejo: I have an easy way to install it for you
13:39:09 <bitemyapp> pejo: I teach Haskell. just answer my question. What os/distro are you on?
13:39:12 <velpro> piezoid: i have a feeling its a lot more overhead than something like nginx
13:39:20 <bitemyapp> pejo: platform is broken and the maintainers refuse to fix it. Until they do, simple bindist is the way to go.
13:39:53 <pejo> bitemyapp, I'm not interested in supporting random bindists from god knows where.
13:40:03 <z0d> I installed the bindist on OSX, but installing Cabal wasn't easy. it required some manual fix
13:40:04 <bitemyapp> pejo: sigh. they're not random bin dists.
13:40:05 <jxv> kini, this image https://s3.amazonaws.com/VincentToupsScreencasts/monadic-bind.png may be helpful.
13:40:11 <bitemyapp> pejo: tell me the OS or distro you're on.
13:40:37 <ion> jxv: Not sure if sincere
13:40:42 <bitemyapp> jxv: dafuq
13:40:50 <jxv> taken from: http://dorophone.blogspot.com/2011/05/hyperturtle-monad-makes-pretty-pictures.html
13:41:03 <ajcoppa> dafuq indeed
13:41:16 <kini> jxv: I think I have a general fuzzy understanding of what a monad is. bitemyapp had a long twitter thread recently where he shot down various definitions of monads, though, so now I don't even know anymore, lol
13:41:41 <l0cust> That actually makes pretty good sense, if you already understand monadic binds
13:41:44 <pejo> bitemyapp, I'm on OSX. Colleagues are on ancient ubuntus. Some machines are running anceint releases of RHEL. I don't know what versions of Windows people use.
13:41:53 <rwbarton> A warm fuzzy understanding?
13:42:02 <kini> sure, haha
13:42:16 <ion> l0cust: Surprisingly most monad tutorials also make sense after you already grok monads. :-P
13:42:21 <bitemyapp> pejo: http://ghcformacosx.github.io/ https://launchpad.net/~hvr/+archive/ghc
13:42:28 <bitemyapp> pejo: etrepum maintains the former, hvr the latter.
13:42:42 <bitemyapp> pejo: next time, don't second guess somebody trying to help you. Just answer the question, *then* ask about what's on offer.
13:42:57 <pejo> rwbarton, any tentative release plans written down anywhere, or do you happen to know what is planned?
13:43:15 <rwbarton> pejo, I get a lot of emails about it that I don't read very carefully :)
13:43:18 <bennofs> bitemyapp: well, I'm not so sure if that view is really so non-controvers. What do you do on windows?
13:43:29 <rwbarton> so, I imagine so
13:43:43 <bitemyapp> bennofs: https://github.com/bitemyapp/learnhaskell#windows-and-other-linux-users
13:44:00 <bitemyapp> bennofs: platform on windows is primarily needed for things people often find annoying to build with mingw like OpenGL.
13:44:02 <jxv> kini, I wouldn't attempt monads until you understand typeclasses and functors.
13:44:13 <bitemyapp> bennofs: I don't give a flying fuck about that for people just beginning to learn Haskell.
13:44:20 <jxv> typeclasses especially
13:44:29 <kini> I'm pretty sure I understand typeclasses and probably functors too
13:44:29 <bitemyapp> functor, applicative, monoid are all needed.
13:44:44 <bitemyapp> bennofs: they can sort that out later. Initially, builds need to "just work" - platform fails at this. hard.
13:44:58 <bitemyapp> bennofs: I'll recommend platform when platform decides to give a fuck about beginners.
13:45:01 <l0cust> Monads are actually pretty simple
13:45:10 <l0cust> Brian Beckman has a very good lecture explaining them
13:45:11 <bitemyapp> bennofs: and stop burying their head in the sand.
13:45:21 <rwbarton> pejo: there's a mailing list: http://projects.haskell.org/pipermail/haskell-platform/
13:45:24 <bitemyapp> l0cust: I watched that and it seemed ignorant to me.
13:45:31 <l0cust> oh, it most certainly is
13:45:38 <bitemyapp> so why is it "good"?
13:45:47 <bitemyapp> he's bad at explaining monads and doesn't really understand them himself.
13:45:47 <rwbarton> http://projects.haskell.org/pipermail/haskell-platform/2014-March/002843.html is the start of a thread that is still ongoing...
13:45:49 <l0cust> If you can get through the microsoft propaganda, his explanation of the core concept works
13:46:29 <bitemyapp> l0cust: dubious.
13:46:53 <l0cust> for instance, he claims that f# performs better than haskell
13:46:54 <velpro> tbh i think the best way to learn any language is to just write code
13:47:06 <bitemyapp> mostly, but you do need to understand principles.
13:47:10 <velpro> monads are trivial to grasp after you've actually written some code using them
13:47:13 <bitemyapp> you don't learn principles by cargo-culting.
13:47:16 <bitemyapp> velpro: wrong!
13:47:19 <l0cust> velpro: with most languages, that's true. With Haskell, the best way to learn is by watching lectures on category theory
13:47:19 <bennofs> bitemyapp: what's so wrong about platform for beginners?
13:47:25 <velpro> bro
13:47:27 <bitemyapp> bennofs: are we really going to have this conversation?
13:47:33 <velpro> u dont need to know any category theory to know haskell
13:47:35 <bitemyapp> bennofs: I'm not having this conversation if you're not interested in fixing it.
13:47:48 <bitemyapp> bennofs: are you interested in fixing Platform and convincing the primary maintainers they're fucking up?
13:47:50 <velpro> simon peyton jones doesnt even know category theory
13:48:07 <bennofs> bitemyapp: oh ok no. Was just curious
13:48:08 <bitemyapp> velpro: "bro" - I've seen people cargo-cult through monads without understanding them tons of times.
13:48:20 <bitemyapp> velpro: I teach Haskell and I've talked to enough people that "know" Haskell to know better.
13:48:25 <bitemyapp> bennofs: because you'll have to do the latter before you can do the former.
13:48:42 <velpro> bitemyapp: there is really only so much you can say about monads
13:48:52 <velpro> repeating it wont really bring new info to light
13:48:57 <bitemyapp> lol
13:49:05 <l0cust> The box explanation in lyah is shallow, but sort of works
13:49:07 <napping> bitemyapp: have you written down the problems you see anywhere?
13:49:09 <bitemyapp> bennofs:
13:49:14 <bitemyapp> l0cust: the box explanation is *broken*
13:49:22 <bitemyapp> napping: I gave up after talking to the main Platform maintainer.
13:49:34 <bitemyapp> napping: that conversation convinced me it was hopeless and left me despondent enough that I'm just doing damage control.
13:49:44 <bitemyapp> I am going to keep re-routing people to things that work until Platform works.
13:49:48 <velpro> theres every little from category theory actually in haskell other than names and some laws that some classes should follow
13:50:14 <bitemyapp> velpro: cargo-culting through monads is not the same as simply "not knowing category theory"
13:50:24 <bitemyapp> velpro: there's this really big space in between I like to call, "knowing FP"
13:50:33 <velpro> my point is there is a lot of over-complication of monads online
13:50:44 <bitemyapp> velpro: yeah. we know. Thanks.
13:51:02 <rrradical> is there a good example somewhere of how to instance Read in a custom way? I'd like to read and write my type like "4#3". I guess I implement readsPrec, but I can't find a good example of how to do that
13:51:07 <bitemyapp> blah blah burrito hyuk hyuk blah blah
13:51:12 <bitemyapp> it stopped being funny years ago
13:51:13 <velpro> wut
13:51:27 <bitemyapp> rrradical: newtype
13:51:33 <l0cust> guys guys guys
13:51:36 <napping> rrradical: you might want to use ReadP
13:51:43 <l0cust> a monad is just a monoid over the category of endofunctors
13:51:56 <bitemyapp> rrradical: newtype the string, then implement Read for the newtype (and show)
13:52:15 <napping> bitemyapp: they already have a custom type and are asking how to implement Read
13:52:27 <pejo> rwbarton, hm. They seem to .. discuss versions.
13:52:55 <napping> rrradical: Text.ParserCombinators.ReadP/ReadPrec has a pretty similar interface to other parser combinators, and can be run as a ReadS
13:53:07 <rrradical> napping: thanks I'll check that out
13:53:20 <napping> or maybe you should just write a nice parser and not worry about a Read instance?
13:53:33 <rwbarton> pejo: I think/hope they are waiting for GHC 7.8.3 which should be released Real Soon Now
13:53:43 <rwbarton> which fixes a number of nasty bugs in 7.8.2
13:54:39 <somedude> Does anyone know if the mathlink package is still being maintained?  Cabal is giving me hell (conflict: mathlink => base>=4.0 && <4.3) and it looks like the project hasn't been touched since 2009...
13:54:43 <rrradical> napping: I'm pretty new to all this. You're saying instancing Read isn't the typical way to go?
13:55:26 <napping> That depends what you are doing, but maybe not
13:55:42 <napping> read doesn't give you any useful syntax error messages or anything
13:56:29 <pejo> rwbarton, is that the post RC2-bug you're talking about?
13:56:52 <napping> pejo: the StableName one seems pretty big
13:57:24 <napping> rrradical: for playing with stuff in ghci you can just type in values
13:57:37 <napping> Show is very useful for looking at values you get back
13:57:38 <rwbarton> the one Simon mentioned is one of them, but there are others in the runtime system
13:57:42 <rwbarton> like the one napping mentioned
13:57:46 <enthropy> rrradical: you can probably get by ignoring the Int that's the precedence, and just use Text.ParserCombinators.ReadP
13:57:50 <rwbarton> oh wait, sorry
13:58:01 <enthropy> rrradical: finally having   readsPrec _ = readP_to_S myParser
13:58:08 <rwbarton> the post RC2 bug was fixed in 7.8.2 I think
13:58:27 <napping> Read isn't a very nice interface for reading anything very big, because parses just fail
13:58:30 * rwbarton got confused with the different 2s
13:58:58 <napping> Read+Show is maybe okay as a vaguely human-readable serialization format
13:59:46 <rwbarton> pejo: I'm talking about these: http://www.haskell.org/pipermail/ghc-devs/2014-June/005108.html
14:00:19 <exicer> What would be an appropriate way to store html downloaded from ~1000 web pages? The idea being that they can later be procesed etc.
14:00:44 <rwbarton> oh, and other fixes that are alreeady merged into 7.8
14:00:55 <napping> bitemyapp: so you're not interested in even saying what's wrong with the platform? I don't use it myself, but I don't know of any reason not to suggest it to people getting started off linux
14:01:24 <rwbarton> bitemyapp: have you written down somewhere what the problems are?
14:01:38 <bitemyapp> napping: I did say what's wrong - to the primary maintainer.
14:01:59 <bitemyapp> napping: if they're not interested in the *problem* they're definitely not going to be interested in *causes* of that problem or the *solution*
14:02:09 <rrradical> napping: ok thanks, that makes sense
14:02:10 <bitemyapp> rwbarton: why would I waste my time like that when I have people I could be teaching Haskell?
14:02:27 <bitemyapp> rwbarton: I've already talked to him, he doesn't care. He's intransigent. Can't be reasoned with.
14:02:43 <copumpkin> you can still convince others not to use it, if you give reasons
14:02:44 <bitemyapp> rwbarton: http://ghcformacosx.github.io/ is us routing around the damage.
14:02:52 <bitemyapp> copumpkin: I don't have any problem doing so.
14:02:58 <napping> I just don't understand why you'd try to steer people away from it, without even explaining to other people helping people start, why they might also steer other people away from it
14:03:04 <bitemyapp> I don't give a damn what experts use.
14:03:17 <napping> Look, do you think I should stop recommending it or not?:
14:03:25 <bitemyapp> napping: to beginners? Yes.
14:03:28 <napping> why?
14:03:37 <rwbarton> your whole behavior is indistinguishable from someone who just doesn't like the HP maintainer for some reason
14:03:41 <bitemyapp> napping: people that can debug Cabal issues? That's fuzzier.
14:04:02 <bitemyapp> rwbarton: I don't really care what you think and I'm not alone in my recognition of the problem.
14:04:16 <bitemyapp> I'm averse to having this conversation in public.
14:04:34 <velpro> why
14:04:40 <bitemyapp> velpro: because peanut gallery.
14:04:49 <velpro> uwotm8?
14:04:57 <bitemyapp> ^^ case in point
14:05:07 <velpro> 1v1 irl fgt
14:05:37 <merijn> velpro: This is not 4chan, reddit or whatever. Please maintain a minimum amount of civility and good manners
14:05:45 <albeit> Is there anywhere that lists the problems with Platform so beginners know to not use it?
14:05:55 <bitemyapp> rwbarton: I didn't have a problem with the maintainer until they needed the needs of beginners were unimportant, despite ostensibly wanting the Platform to be the universal way to use GHC Haskell.
14:06:13 <bitemyapp> rwbarton: that kind of irrational intransigence rubs me the wrong way.
14:06:22 <bitemyapp> until they decided*
14:06:27 <velpro> those are some big words bro
14:06:35 <bitemyapp> napping: query?
14:06:51 <napping> "query"?
14:06:57 <bitemyapp> napping: irssi PM is /query
14:06:58 <Eelis> bitemyapp: i think the problem is you keep complaining without saying what the complaint is
14:07:05 <napping> huh, I use msg
14:07:07 <velpro> intransigency: the trait of being intransigent; stubbornly refusing to compromise
14:07:19 <bitemyapp> napping: it opens a permanent window for the conversation that way.
14:07:22 <pejo> bitemyapp, I'm rather curious what's wrong with it as well. It has always worked for me.
14:07:28 <bennofs> bitemyapp: I'd help steering beginners away from platform, but they probably want to hear reasons why they shouldn't use the platform. I don't know any. You seem to have some reasons
14:07:42 <bitemyapp> napping: anyway, kosher to PM?
14:07:42 <benzrf> > '\255'
14:07:44 <lambdabot>  '\255'
14:07:45 <napping> sure
14:07:50 <benzrf> ^ is this literally the byte 255
14:07:56 <rwbarton> no
14:07:59 <benzrf> oh shit
14:08:02 <rwbarton> it is the Unicode character 255
14:08:02 <benzrf> what is it then?
14:08:05 <benzrf> >.<
14:08:08 <kini> U+00FF
14:08:18 <copumpkin> benzrf: very different
14:08:22 <benzrf> ;p
14:08:27 <copumpkin> no, I'm not kidding :)
14:08:33 <benzrf> i know the diff
14:08:38 <benzrf> i read joel's article :3
14:08:44 <Eelis> heh, "the platform is bad and should be avoided but i'll only tell selected people why in privmsg" o_O
14:09:18 <velpro> 'the platform is sucks - everyone already knows why so i will only repeat it to people in secret'
14:09:24 <geekosaur> probably because they're tired of being told why rails-style development means you don't have an ecosystem, you have a sewer complete with alligators
14:09:31 <benzrf> > 0x4
14:09:33 <lambdabot>  4
14:09:34 <velpro> 'cause everyone else is a stupid part of a "peanut gallery"'
14:09:34 <geekosaur> who needs anything to work with anything else?
14:09:37 <benzrf> > 0x50
14:09:38 <lambdabot>  80
14:09:41 <benzrf> > chr 0x50
14:09:42 <lambdabot>  'P'
14:09:45 <benzrf> hmm
14:09:48 <benzrf> where is chr from?
14:09:54 <jxv> Data.Char
14:09:57 <benzrf> huh
14:10:02 <bennofs> velpro: maybe napping can enlighten us later :)
14:10:08 * hackagebot tamper 0.3.5.0 - An HTML templating system similar to Blaze, implemented as a monad transformer of sorts  http://hackage.haskell.org/package/tamper-0.3.5.0 (TobiasDammers)
14:10:09 <velpro> idk man
14:10:15 <velpro> will we be able to grasp the deep concepts?
14:10:48 <velpro> maybe i should go read a math book to prepare myself
14:11:14 <jxv> velpro, I'm inclined to believe it's about eq not iq.
14:11:22 <bennofs> I mean, he probably just doesn't want to get caught in yet another Platform is bad vs Platform is the best fight, and if he doesn't give arguments, nobody can argue against either. I can understand that a bit
14:11:41 <vhz> ^^ exactly this
14:11:47 <velpro> well, its such a unimportant and useless discussion to begin with
14:12:35 <velpro> why start ranting about it and then refuse to back up your rant
14:13:20 <velpro> i was genuinely intereseted in why he thought it was bad
14:16:17 * geekosaur senses the battle is lost anyway, we are rails! unstructured development and libraries incompatible with anything else is the future!
14:17:10 <benzrf> hmmm
14:18:30 <geekosaur> yes, I really love the idea that if I want to combine framework X with framework Y for some project, I can;t because they use incompatible versions of some common dependency because trying to keep stuff in sync is obviously stupid
14:19:06 <vhz> geekosaur: tell that to the gatekeepers of base/HP/.. that are integrating things at a pathetic rate
14:19:07 <rwbarton> ultimately the problem is that people are addicted to breaking things
14:19:11 <merijn> geekosaur: Isn't GHC supposed to get the ability to use multiple versions of the same library in the near future
14:19:17 <geekosaur> it's already happening thanks to folks who know the rails way is best. it'll happen more, especially if they've decided to take their arguments private so they can't be refuted
14:19:30 <merijn> vhz: So, step up and volunteer your time to help testing and integrating?
14:19:37 <geekosaur> this is obviously the best thing ever for the haskell community, billions of rails-like fiefdoms all incompatible with each other
14:19:48 <merijn> vhz: People run this thing in their spare time and unpaid
14:19:53 <benzrf> hmmmm
14:19:58 <benzrf> how do i output a Word8
14:20:07 <benzrf> like, send it to stdout
14:20:09 <merijn> vhz: If you want a higher pace you have two options: 1) pay someone 2) offer to volunteer yourself
14:20:09 * hackagebot tamper 0.3.5.1 - An HTML templating system similar to Blaze, implemented as a monad transformer of sorts  http://hackage.haskell.org/package/tamper-0.3.5.1 (TobiasDammers)
14:20:18 <benzrf> @hoogle Word8 -> IO ()
14:20:19 <lambdabot> GHC.IO.Buffer writeWord8Buf :: RawBuffer Word8 -> Int -> Word8 -> IO ()
14:20:19 <lambdabot> Graphics.Rendering.OpenGL.GL.StateVar ($=) :: HasSetter s => s a -> a -> IO ()
14:20:19 <lambdabot> Graphics.Rendering.OpenGL.GL.StateVar ($=!) :: HasSetter s => s a -> a -> IO ()
14:20:21 <merijn> benzrf: Use show?
14:20:31 <benzrf> derp.
14:20:35 <benzrf> @hoogle ByteString -> IO ()
14:20:36 <lambdabot> System.Posix.Env.ByteString putEnv :: ByteString -> IO ()
14:20:36 <lambdabot> Data.ByteString putStr :: ByteString -> IO ()
14:20:36 <lambdabot> Data.ByteString.Char8 putStr :: ByteString -> IO ()
14:20:45 <merijn> Or BS, yeah
14:21:17 <Fuuzetsu>     In the use of `morallyDubiousIOProperty'
14:21:18 <Fuuzetsu>     (imported from Test.QuickCheck.Property):
14:21:18 <Fuuzetsu>     Deprecated: "Use ioProperty instead"
14:21:23 <Fuuzetsu> oh you guys
14:21:34 <benzrf> glash
14:21:37 <vhz> merijn: so provided I want to add a library foo, I just have to dedicate time for testing and integration ? right ?
14:22:07 <benzrf> what is the simplest way to take some generated numbers from 0 to 255 and output bytes
14:22:09 <benzrf> >.<
14:22:09 <vhz> merijn: there won't be endless bikeshedding about the benefits of x,y,z or how to use something else, etc ?
14:22:15 <merijn> vhz: Well, and convince "the community" the quality is up to a certain standard
14:23:09 <Fuuzetsu> benzrf: do you just want to get a random Word8?
14:23:13 <z0d> I'm trying to install ghc-mod on OSX with GHC 7.8.2 and I get "setup: The program "happy" version >= 1.17 is required but it could not be found.
14:23:27 <z0d> it is requires by haskell-sec-extra
14:23:48 <merijn> z0d: Cabal can't track programs (yet?), so you'll have to manuall "cabal install happy"
14:24:00 <Fuuzetsu> benzrf: Word8 has Random instance you know
14:24:01 <vhz> merijn: well, back to square 1 then. it's not about testing and integration ..
14:24:06 <z0d> merijn: thanks
14:24:17 <Fuuzetsu> :t randomIO :: IO Word8
14:24:18 <lambdabot> IO Word8
14:24:35 <merijn> vhz: To get into the Platform? No. But if you don't want to be in the platform that's all irrelevant
14:24:56 <merijn> The platform is supposed to be a well-tested, integrated, curated starting point
14:25:11 <merijn> It is *not* intended to include every single library ever
14:25:19 <benzrf> @hoogle Word8 -> IO ()
14:25:20 <lambdabot> GHC.IO.Buffer writeWord8Buf :: RawBuffer Word8 -> Int -> Word8 -> IO ()
14:25:20 <lambdabot> Graphics.Rendering.OpenGL.GL.StateVar ($=) :: HasSetter s => s a -> a -> IO ()
14:25:20 <lambdabot> Graphics.Rendering.OpenGL.GL.StateVar ($=!) :: HasSetter s => s a -> a -> IO ()
14:25:23 <benzrf> hmm
14:25:38 <merijn> If you test you package and do your testing/integration then what's the problem with just putting it on hackage?
14:25:51 <pejo> benzrf, lambdabot answers to @hoogle in messages as well
14:26:18 <vhz> merijn: there's quite a bit of leeway between every single package, and packages that are commonly used in the community ..
14:26:20 <benzrf> right...
14:26:26 <benzrf> blagh
14:26:50 <joseph07> benzrf: Do you want something like 00000010 for 2 etc?
14:27:00 <benzrf> its OK
14:27:02 <benzrf> i got it
14:27:30 <merijn> vhz: Sure, but if your package is only used by a handful of people, then why force it upon everyone installing the platform? And if it's used by tons of people, then campaigning to put it into platform shouldn't be that hard
14:28:15 <vhz> "campaigning"
14:28:19 <joseph07> :t Data.ByteString.cons
14:28:20 <lambdabot> Word8 -> BSC.ByteString -> BSC.ByteString
14:28:30 <vhz> I'ld rather do something useful and fun than doing that..
14:29:07 <merijn> vhz: Right, so then don't get your package in the platform? What's the problem?
14:29:30 <merijn> I'm not really seeing the issue you're complaining about? Things work just fine if you're not in the platform
14:29:37 <vhz> merijn: well, the problem is that the package doesn't cater to many people in the first place ..
14:30:00 <merijn> vhz: Which package?
14:30:06 <vhz> oops sorry, platform
14:30:21 <merijn> I disagree, almost everyone I know uses the platform
14:30:38 <vhz> merijn: we probably don't know the same people :)
14:30:44 <geekosaur> evidently
14:30:54 <merijn> Maybe it's not useful to you, fine, but why ruin it for everyone that's happy with it?
14:31:13 <joseph07> :t Data.ByteString.putStr . pack . fmap fromIntegral
14:31:15 <lambdabot>     Not in scope: ‘pack’
14:31:15 <lambdabot>     Perhaps you meant one of these:
14:31:15 <lambdabot>       ‘BS.pack’ (imported from Data.ByteString),
14:31:22 <geekosaur> yes, I still love hearing how the platform is the source of all the world's ills and that having to fork your own copy of some dependency so you can make it compatible with every fiefdom you're playing with is the proper way to do things
14:31:22 <vhz> merijn: I'm not changing anything about the platform. so I don't see how I'ld be ruining it ...
14:31:28 <tristanStrange> hey all. which JSON parser do you chaps recommend? I'm after something really simple
14:31:29 <joseph07> :t BS.putStr . BS.pack . fmap fromIntegral
14:31:30 <lambdabot> Integral a => [a] -> IO ()
14:31:31 <tristanStrange> ?
14:31:35 <geekosaur> always nice to have to maintain your own copy of everything you use
14:31:41 <merijn> vhz: Well, which discussion are we having then?
14:31:45 <z0d> tristanStrange: eason or jsongrammar
14:31:49 <z0d> aeson*
14:31:55 <geekosaur> because its actual developer isn't catering to your particular fiefdoms but someone else's
14:32:07 <geekosaur> and fiefdoms are clearly the right way to do things
14:32:11 <pejo> tristanStrange, I used aeson to output. Worked like a charm.
14:32:12 <gilligan_> evening
14:32:28 <tristanStrange> cheers guys! ill take a peek at aeson
14:33:01 <vhz> merijn: well, why the platform is not adequate or something like that.
14:35:23 <merijn> vhz: If you oppose community discussion and campaigning for the changes you'd like to see, then you are unlikely to have any control over where things go
14:35:59 <merijn> vhz: I get rather doing something else with your time, but don't blame the people trying to improve the situation for not listening to you if you don't try and make yourself hear
14:37:24 <vhz> merijn: Well, if people were actually more inclined to have discussion, instead of going in protective mode, then that would make sense
14:38:02 <merijn> vhz: There's plenty of open discussion on the platform mailing list and the libraries mailing list
14:38:28 <merijn> I wouldn't expect that kind of discussion here, though. As most people involved will either not be online here during the time of the discussion or to busy for IRC
14:39:19 <benzrf> yo is there a tool i can use to find out what's eating up most of my program's running time
14:40:03 <bennofs> benzrf: that's called profiling. GHC has an integrated profiler
14:40:16 <bennofs> benzrf: do you use cabal to build your project?
14:40:36 <benzrf> bennofs: naw, it's single-file
14:40:46 <pejo> benzrf, you can get some basic statistics with RTS parameters. Otherwise compile your program for profiling.
14:40:53 <benzrf> pejo: how ?
14:41:01 <bennofs> benzrf: ok, then use -prof -rtsopts -fprof-auto as args for GHC
14:41:42 <benzrf> othx
14:41:52 <benzrf> >X-style flags
14:41:52 <benzrf> ick
14:41:58 <bennofs> benzrf: then run with +RTS -sstderr (to get statistics. useful to see if the GC is a problem, because it shows time spent in GC) or +RTS -p (this will create a progname.prof with percentages for each function)
14:42:38 <benzrf> >    Perhaps you haven't installed the profiling libraries for package `base'?
14:42:39 <lambdabot>  <hint>:1:73: parse error on input ‘?’
14:42:41 <benzrf> >    Perhaps you haven't installed the profiling libraries for package `base'?
14:42:42 <lambdabot>  <hint>:1:73: parse error on input ‘?’
14:42:43 <benzrf> :{
14:42:59 <bennofs> ew ... where have you got GHC from?
14:43:08 <benzrf> im on ARM
14:43:11 * benzrf crioes
14:43:12 <benzrf> *cries
14:43:19 <benzrf> shitty craptop chromebook
14:43:24 <benzrf> lubuntu crouton
14:43:25 <benzrf> q.q
14:43:53 <bennofs> benzrf: maybe try installing libghc-base-prof
14:44:04 <benzrf> warranty people promised that i'd get my new laptop coupon within uh
14:44:06 <benzrf> a week ago
14:44:23 <bennofs> benzrf: not sure if that pkg exists or if profiling works on ARM at all
14:44:41 <napping> A summary: Let us suppose that solving a cabal problem (except by completely blowing away a directory) is too much for beginners. Strictly sandboxing everything can completely avoid that. But then, having stuff in the global package db gets in the way, and in any case prebuilt packages are useless
14:44:52 <benzrf> its installing :u
14:45:47 <bennofs> benzrf: or maybe ghc-prof if that doesn't work.
14:46:19 <benzrf> shit
14:46:23 <benzrf> rootfs                                                        9.9G  4.6G  4.9G  49% /
14:46:37 <monochrom> is that bad?
14:46:39 <bennofs> looks pretty ok
14:47:13 <monochrom> are you think "it's bad because I can only put on 4 more versions of GHC"? :)
14:47:46 <benzrf> monochrom: :P
14:48:01 <benzrf> i've only been using it for like 2-3 weeks
14:48:42 <monochrom> disk usage over time is a logistic curve. don't worry.
14:50:12 * hackagebot threadscope 0.2.4 - A graphical tool for profiling parallel Haskell programs.  http://hackage.haskell.org/package/threadscope-0.2.4 (MikolajKonarski)
14:50:36 <benzrf>     Could not find module `System.Random'
14:50:36 <benzrf>     Perhaps you haven't installed the profiling libraries for package `random-1.0.1.1'?
14:50:39 <benzrf> grrr
14:50:40 <johnw> so, if anyone is bored with Euler, I have a better coding task that will help teach the basics and higher-order functions...
14:50:56 <glguy_> benzrf: Fix your .cabal/config so that that never happens again
14:51:01 <monochrom> hehe
14:51:06 <benzrf> glguy_: not using cabal atm :u
14:51:16 <benzrf> bbl guys
14:51:16 <bennofs> benzrf: did you install any packages with cabal??
14:51:20 <benzrf> bennofs: oh
14:51:26 <genisage> johnw: what is it?
14:51:32 <rwbarton> could have installed them through the package manager
14:51:36 <johnw> so, I'm re-implementing conduit in terms of much simpler types
14:51:50 <glguy_> rwbarton: weird :)
14:51:52 <johnw> which means I've got about 100 very basic functions, like scanlC, which need to be reimplemented in terms of these simpler types
14:52:07 <johnw> the translation is nearly mechanical, but does require some awareness of what's going on
14:52:11 <bitemyapp> johnw: uni-directional?
14:52:15 <napping> can anybody remind me why packages ever break?
14:52:22 <johnw> yes, uni-directional, no leftovers
14:52:25 <johnw> and it doesn't use monads
14:52:33 <johnw> it's about 47% faster than conduit in simple examples that I've tested using criterion
14:52:35 * bitemyapp rubs chin and hums
14:52:42 <johnw> plus, it doesn't use $= or $$; just plain function application
14:52:46 <bitemyapp> johnw: well, it was the laggard in the benchmarks Gabriel did anyway right?
14:53:05 <latro`a> :t ($$)
14:53:05 <johnw> i don't know
14:53:05 <lambdabot> Doc -> Doc -> Doc
14:53:12 <bitemyapp> johnw: this sounds appealing, can you contrast it with Machines?
14:53:14 <johnw> my library is purely "composition of monadic folds"
14:53:19 <johnw> it's much more basic than that even
14:53:20 <johnw> let me show you
14:53:33 <napping> there's a unique package-id, what can't disambiguate based on that?
14:53:35 <johnw> https://github.com/jwiegley/simple-conduit/blob/master/Conduit/Simple.hs#L40
14:53:39 <teakay> Hey guys. Can I ask an esqueleto related question in here?
14:53:44 <johnw> teakay: sure
14:54:32 <johnw> bitemyapp: right now I'm trying to prove-by-implementation that this library is sufficiently expressive to covers at least 90% of the full conduit's use basic cases
14:54:45 <johnw> basic use cases
14:55:00 <bitemyapp> johnw: it *looks* clean to me, but I didn't know Pipe/Conduit/etc internals that well.
14:55:04 <johnw> I still have to do zipsources and zipsinks, but I have a thought in mind for approaching that, but passing a continuation in the fold argument
14:55:12 <johnw> s/but/by
14:55:12 <bitemyapp> johnw: especially Conduit. Tho' I do recall liking reading pipes code a bit better :)
14:55:13 * hackagebot dson 0.3.0.0 - Haskell DogeScript Object Notation Parser  http://hackage.haskell.org/package/dson-0.3.0.0 (lcycon)
14:55:23 <johnw> bitemyapp: this code could be switched to pipes interface very easily
14:55:29 <johnw> I only picked conduit because of my familiarity with it
14:55:41 <johnw> so I'm not tied to it either way
14:55:50 <bitemyapp> johnw: uh sure, I'm not trying to bikeshed, sorry. I just saying it's readable to an ignoramus like me who mostly didn't know Conduit.
14:56:00 <johnw> my thought is that such a basic library, even though it isn't as expressive as pipes or conduit, may be useful exactly because of that lack of expression
14:56:14 <bitemyapp> johnw: I'm a fan of things like this.
14:56:21 <napping> Does it leave out cleanup actions compared to conduit?
14:56:25 <bitemyapp> johnw: it could be useful not just practically but also pedagogically.
14:56:26 <johnw> it has cleanup actions
14:56:34 <johnw> deterministic resource handling (*without* ResourceT)
14:56:42 <johnw> does not use monad transformers
14:56:44 <bitemyapp> that was the bit I was going to ask about.
14:56:48 <bitemyapp> cleanup and prompt finalization.
14:56:52 <johnw> has upstream notification of termination
14:56:57 <johnw> of allows early termination by downstream consumers
14:57:04 <johnw> s/^of/and
14:57:25 <rwbarton> it uses at least one monad transformer, on the line you linked to :P
14:57:31 <johnw> oh, yes, internally
14:57:34 <rwbarton> ah
14:57:48 <johnw> I could have avoided that too
14:57:54 <johnw> by using m (Either r r) instead of EitherT r m r
14:57:58 <johnw> but the latter was just plain convenient
14:58:02 <napping> johnw: what did you cut from Data.Conduit.Internal.Pipe, other than leftovers?
14:58:07 <johnw> what i mean is that the Conduit type *itself* is not a transformer
14:58:33 <johnw> napping: I cut leftovers and the fact that Conduit is a full monad transformer, which lets you express lots of cool stuff that this library can't
14:58:45 <stepkut> does GHCi 7.8 have a way to tell the RTS to kill all background threads?
14:58:46 <johnw> at the cost of needing ResourceT, et al
14:59:42 <johnw> so, at this point, I was looking for help implementing all of these trivial combinators
14:59:44 <bitemyapp> stepkut: it's something you have to code in.
15:00:01 <stepkut> bitemyapp: right. I was hoping they had 'fixed' that :)
15:00:01 <johnw> it takes me about 30s per combinator, but there's a lot of them and I would love help
15:00:36 <napping> stepkut: without the main thread exiting?
15:00:45 <napping> oh GHC*i*
15:01:00 <stepkut> yeah
15:01:48 <bitemyapp> johnw: I could if you're willing to teach me how it works.
15:01:57 <johnw> excellent, I'd be happy to
15:02:00 <johnw> this channel, or privmsg?
15:02:04 <bitemyapp> johnw: or at least toss some examples into the README.
15:02:17 <johnw> check out the several functions I've already implemented
15:02:21 <johnw> and you should start to see the pattern
15:02:27 <bitemyapp> johnw: you have me for the next 30-60 minutes, #haskell-overflow?
15:02:31 <johnw> sure
15:04:20 <Fuuzetsu> ><monochrom> are you think "it's bad because I can only put on 4 more versions of GHC"? :)
15:04:25 <Fuuzetsu> h-hey that's a valid concern!
15:04:52 <Fuuzetsu> I used to have like 20 versions in my ~
15:07:03 <monochrom> 20 is a bit extreme :)
15:09:54 <Fuuzetsu> I only have 8 now but I'll get rid of them soon
15:12:46 <funnyTime> hi, I need to test functions from a module but some are privates is it possible to include them ?
15:14:38 <pavonia> If they aren't exported, no
15:15:26 <joseph07> funnyTime: One thing you could do is have a top level module that just re-exports functions more restrictively
15:16:09 <joseph07> funnyTime: If you think to yourself, users of my package shouldn't see these functions, but other modules (e.g. testing) in my package should be able to see these functions
15:20:16 * hackagebot wai-predicates 0.6 - WAI request predicates  http://hackage.haskell.org/package/wai-predicates-0.6 (ToralfWittner)
15:20:18 * hackagebot wai-routing 0.8 - Declarative routing for WAI.  http://hackage.haskell.org/package/wai-routing-0.8 (ToralfWittner)
15:20:36 <funnyTime> joseph07 : ok thank and I need to run my test in that way      runghc -i/home/usr/app/src  MainTest.hs,         do you know a better way to inlcude src in test
15:22:25 <tristanStrange> how does one use the DerveGeneric extension?
15:22:40 <tristanStrange> ^DeriveGeneric
15:22:55 <tristanStrange> I've got {-# LANGUAGE DeriveGeneric #-}
15:22:56 <Fuuzetsu> http://www.haskell.org/haskellwiki/GHC.Generics
15:23:02 <tristanStrange> at the top of my page
15:23:16 <Fuuzetsu> simply add ‘deriving Generic’ to your data type
15:24:41 <fread2282> tristanStrange: data Foo a = Foo a deriving Generic
15:24:48 <tristanStrange> Fuuzetsu: I've done that
15:25:07 <tristanStrange> i get:  Not in scope: type constructor or class `Generic'
15:26:06 <Fuuzetsu> import GHC.Generics IIRC
15:27:13 <tristanStrange> thats fixed it! cheers!
15:27:26 <tristanStrange> and makes a bit more sense!
15:29:12 <Fuuzetsu> funnyTime: Common pracitces involve using .Internal module which users aren't meant to (but are able) to import and stick your private stuff in there or using CPP to conditionally export the private functions depending on whether or not you're running the tests
15:29:22 <Fuuzetsu> practices*
15:31:08 <johnw> cool, bitemyapp found that simple-conduit allows for a very convenient way to print the contents of a file in constant space without using lazy I/O: mapM_C Prelude.putStrLn (sourceFile "file")
15:34:36 <bitemyapp> johnw: and it was my first guess and "just worked"
15:34:43 <bitemyapp> johnw: muy impressed.
15:35:40 <bitemyapp> johnw: if this goes well, I could make this library into a nice "You could've invented streaming IO"
15:35:48 <Fuuzetsu> I hope one day I'll make up my mind about which IO library to use and properly learn
15:36:29 <benzrf>     Could not find module `System.Random'
15:36:32 <benzrf>     Perhaps you haven't installed the profiling libraries for package `random-1.0.1.1'?
15:36:37 <benzrf> what do i install +.+
15:36:50 <bitemyapp> benzrf: was random installed with prof?
15:36:55 <Fuuzetsu> profiling libraries for random ;P
15:37:25 <Fuuzetsu> are you using cabal or your package manager? There is a cabal flag to install with profiling and your package manager probably has -prof variant
15:38:00 <bitemyapp> benzrf: the way I'd do it (maybe this is more complicated to some) is cabal unpack random of the version you want, add prof flags, install, then add-source to the other thing I was doing.
15:38:12 <bitemyapp> benzrf: that or figure out if enabling prof at the top level enables it for all deps with reinstall.
15:38:15 <mr_yogurt> I find it funny that this channel has twice as many users a the c++ channel even though c++ is more widespread
15:38:20 <mr_yogurt> *as the, not a the
15:38:43 <benzrf> bitraten: eeek
15:38:46 <Fuuzetsu> I'm sure the C++ users are busy writing Real World™ code
15:38:51 <benzrf> Fuuzetsu: cabal
15:39:10 <sipa> i'm sure the average C++ developer is just less of an irc nerd :P
15:39:12 <sipa> *ducks*
15:39:12 <benzrf> i just want to profile my code ;-;
15:39:13 <monochrom> many C++ users have not heard of irc. Stroustrup certainly haven't.
15:39:22 <chirpsalot> mr_yogurt: it's because the C++ channels are hostile as hell.
15:39:37 <dolio> There are people who haven't heard of IRC?
15:39:46 <benzrf> chirpsalot: probably because they spend their time writing C++
15:39:49 <mr_yogurt> I've been on them, and I find that the only hostile one is ##c++. The others aren't really that hostile
15:39:52 <benzrf> that would make anybody hostile :^)
15:39:59 <bitemyapp> mr_yogurt: ##C is worse.
15:40:06 <bitemyapp> ##C is the Mos Eisley of programming channels.
15:40:07 <mr_yogurt> I've not been to ##c
15:40:09 <chirpsalot> And also it's not really an... "interesting" language, so maybe it doesn't have much of a cult following as a result?
15:40:11 <Fuuzetsu> benzrf: heh, when I want to just profile my code I spent the next few days trying to build GHC with profiling, it wasn't pretty
15:40:11 <bitemyapp> mr_yogurt: keep it that way.
15:40:21 <sveit> generally speaking, if some typeclass implies another typeclass, is it better to require the other typeclass or implement default instances?
15:40:23 <benzrf> >tfw
15:40:23 <bitemyapp> chirpsalot: "cult"
15:40:32 <benzrf> Fuuzetsu: how do i reinstall random with profiling
15:40:34 <bitemyapp> benzrf: hahahaha, you okay mate?
15:40:47 <chirpsalot> Like, I feel like most people that write C++ are just like "well, my favourite video game was written in C++ therefore I will write C++", but they probably don't really care much about the language?
15:40:51 <benzrf> bitemyapp: trying to figure out why my code is so goddamn slow
15:40:53 <bitemyapp> benzrf: --cabal-install-arg='--enable-library-profiling'
15:40:54 <Fuuzetsu> cabal install random --enable-library-profiling IIRC
15:41:01 <bitemyapp> er woops.
15:41:04 <monochrom> sveit: require the other typeclass
15:41:04 <bitemyapp> benzrf: what Fuuzetsu said.
15:41:07 <benzrf> haha
15:41:09 <bitemyapp> benzrf: disregard, OP is idiot.
15:41:15 <genisage> ##c++-basic is nice, but usually dead.
15:41:37 <mr_yogurt> Well, knowing a language that is widespread is fairly useful. I don't see many job offers for people who know haskell :P
15:41:44 <benzrf> man i remember when i got into an argument with Fuuzetsu on 4chan about whether python was superior to haskell for any purpos
15:41:45 <chirpsalot> bitemyapp: ##c didn't used to be so bad. At least it usually consisted of people that were arrogant, but at least correct.
15:41:47 <benzrf> *purpose
15:42:08 <monochrom> you dabbled in 4chan?!
15:42:12 <Fuuzetsu> don't get into arguments with me
15:42:12 <benzrf> i still do
15:42:14 <sveit> monochrom: even if the implied typeclass is strictly more general?
15:42:17 <benzrf> why do you think i just write '>tfw'
15:42:21 <monochrom> that is like "I was a gangster"
15:42:36 <benzrf> *wrote
15:42:45 <mr_yogurt> You guys talk about haskell like it is not frustrating in any way whatsoever and it never has problems. Is that true?
15:42:58 <monochrom> yes sveit. my answer stands.
15:43:03 <benzrf> mr_yogurt: no
15:43:07 <Fuuzetsu> it's frustrating when you want to rebuild all your libs with profiling
15:43:10 <mr_yogurt> Or are you just taking the "haskell doesn't problems, the universe does" approach
15:43:10 <bitemyapp> mr_yogurt: I'm having an email conversation with somebody about flaws in Haskell pedagogy.
15:43:12 <benzrf> mr_yogurt: but frankly every language has issues
15:43:24 <bitemyapp> mr_yogurt: we know it's frustrating, we just don't think complaining necessarily yields improvement.
15:43:35 <bitemyapp> mr_yogurt: *critique* does, but that requires analysis.
15:43:36 <benzrf> mr_yogurt: many of the bad parts of haskell have corresponding bad parts in other languages
15:43:39 <benzrf> i.e.
15:43:44 <Fuuzetsu> define bad parts
15:43:48 <Fuuzetsu> ensue lazy IO argument
15:43:50 <mr_yogurt> I have no experience with haskell. Yet.
15:43:56 <bitemyapp> Fuuzetsu: gooby pls no
15:44:03 <bitemyapp> mr_yogurt: https://github.com/bitemyapp/learnhaskell
15:44:08 <benzrf> static typing can occasionally be a pain for some kinds of refactoing
15:44:11 <benzrf> *refactoring
15:44:17 <bitemyapp> benzrf: really? it's been great for me :P
15:44:23 <Fuuzetsu> mr_yogurt: it's best to try it and judge it for yourself then rather than listening to the joksters in here
15:44:24 <bitemyapp> mr_yogurt: nobody's saying it's perfect, but other languages don't have as much to offer.
15:44:28 <benzrf> otoh, dynamic typing allows your refactoring to break things without you noticing
15:44:37 <bitemyapp> benzrf: an understatement if I ever heard one.
15:44:40 <chirpsalot> benzrf: you say that like it wouldn't be a pain to refactor in a dynamic language.
15:44:48 <benzrf> chirpsalot: it could be less ;)
15:44:50 <bitemyapp> benzrf: you basically just can't ever refactor a non-trivial dyn-lang codebase. It's absurd.
15:44:53 <benzrf> it depends on the refactor
15:45:08 <monochrom> mr_yogurt: haskell doesn't have really big problems. the universe doesn't either. every frustration is my own problem
15:45:09 <Fuuzetsu> hardly less, it just makes it that much more difficult to find any changes you need to make
15:45:13 <bitemyapp> not without absurd amounts of labor input and testing.
15:45:31 <bitemyapp> mr_yogurt: seriously though, just follow my guide: https://github.com/bitemyapp/learnhaskell
15:45:41 <chirpsalot> benzrf: I don't think that would usually be the case. In theory most of the time you have to change the same stuff, no? Dynamic typing just lets you get away with it for longer.
15:45:41 <bitemyapp> mr_yogurt: there's a learners specific channel at #haskell-beginners as well.
15:45:43 <Fuuzetsu> I hope it involves burritos
15:45:52 <bitemyapp> Fuuzetsu: burrito-free zone.
15:45:59 <bitemyapp> Fuuzetsu: prejudiced against burritos.
15:46:08 <benzrf> >mfw reinstalling random would break half of my packages
15:46:12 * benzrf sinks to his knees
15:46:16 <Fuuzetsu> hm I think I bought some burritos this morning, I should have those
15:46:22 <Fuuzetsu> thanks Haskell
15:46:30 <Fuuzetsu> benzrf: use a sandbox
15:46:41 <mr_yogurt> What does haskell have to offer that imperative languages do not? I'm making you guys work harder to persuade me to learn haskell :P
15:46:43 <benzrf> Fuuzetsu: orite
15:47:15 <joelteon> mr_yogurt: functional programming
15:47:16 <Fuuzetsu> mr_yogurt: I don't think we're here to persuade anyone
15:47:27 <bitemyapp> mr_yogurt: you could waste more time discussing why you should learn Haskell than it would take to learn Haskell.
15:47:40 <mr_yogurt> Well, you guys do an awfully good job of it if you aren't trying
15:47:57 <bitemyapp> mr_yogurt: and any allusions to magical powers are going to pale in comparison to the experience of obtaining them. https://github.com/bitemyapp/learnhaskell
15:48:01 <benzrf> mr_yogurt: don't drink too much kool-aid!
15:48:08 <bitemyapp> mr_yogurt: did I mention magical powers are involved?
15:48:11 <jxv> mr_yogurt, explicit structures and concepts which helps me reason about my code
15:48:29 <benzrf> hmmm, do i have to do something to get cabal-install to use my new sandbox
15:48:46 <merijn> mr_yogurt: Also, why would I spend my time trying to convince you to learn haskell? Either learn it or don't, it's the same to me. Coming here and demanding people convince you seems a bit entitled
15:48:48 <bitemyapp> mr_yogurt: I have an article on why I use Haskell here: http://bitemyapp.com/posts/2014-04-29-meditations-on-learning-haskell.html
15:49:01 <bitemyapp> merijn: that's why I write articles and FAQs.
15:49:03 <benzrf> mr_yogurt: learn haskell !
15:49:06 <bitemyapp> merijn: write once, spam forever!
15:49:06 <benzrf> it will blow your mind
15:49:09 <benzrf> -boom-0~
15:49:11 <bitemyapp> benzrf: into red paste.
15:49:14 <bitemyapp> benzrf: atomized...
15:49:17 <bitemyapp> booooooom
15:49:21 <Fuuzetsu> bitemyapp: Lenses + CT section is the biggest one there
15:49:42 <bitemyapp> Fuuzetsu: hrm?
15:49:42 <benzrf> mr_yogurt: if you learn haskell you can write things like
15:49:43 <benzrf> scale x y = (>>= replicate y . (>>= replicate x))
15:49:52 <benzrf> mr_yogurt: for scaling up 2d lists!
15:50:15 <Fuuzetsu> bitemyapp: in that GitHub repo
15:50:16 <mr_yogurt> That looks confusing. Probably because I have no haskell experience.
15:50:21 <benzrf> mr_yogurt: naturally
15:50:23 <Fuuzetsu> also for some reason http://bitemyapp.com/posts/2014-04-05-grokking-sums-and-constructors.html is under Dependent Types section
15:50:23 <luz1e> mr_yogurt, you're not doing a good job at persuading people to persuade you to learn haskell
15:50:29 <Fuuzetsu> Dependent typing*
15:50:30 <mr_yogurt> True
15:50:39 <mr_yogurt> That was more of a joke
15:50:41 <benzrf> mr_yogurt: how would you write a 2d-list scaling function in *your* language?
15:50:42 <benzrf> -smug-
15:50:46 <bitemyapp> > (>>= Prelude.replicate 2 . (>>= Prelude.replicate 2)) [[1], [2]]
15:50:48 <lambdabot>  [[1,1],[1,1],[2,2],[2,2]]
15:50:54 <bitemyapp> > (>>= Prelude.replicate 5 . (>>= Prelude.replicate 5)) [[1], [2]]
15:50:55 <lambdabot>  [[1,1,1,1,1],[1,1,1,1,1],[1,1,1,1,1],[1,1,1,1,1],[1,1,1,1,1],[2,2,2,2,2],[2,...
15:50:59 * bitemyapp claps with delight
15:51:01 <luz1e> mr_yogurt, same
15:51:10 <benzrf> mr_yogurt: check it
15:51:10 <bitemyapp> @karma+ benzrf
15:51:10 <lambdabot> benzrf's karma raised to 1.
15:51:26 <pejo> mr_yogurt, you can stick to the simple parts of the language, it's what I do.
15:51:28 <Fuuzetsu> what do you have against [x | FruitApple x <- exampleData ] bitemyapp
15:51:32 <benzrf> > let scale x y = (>>= replicate y . (>>= replicate x)) in scale 3 4 ["abc", "def", "ghi"]
15:51:33 <lambdabot>  ["aaabbbccc","aaabbbccc","aaabbbccc","aaabbbccc","dddeeefff","dddeeefff","dd...
15:51:44 <benzrf> :-)
15:51:51 <bitemyapp> Fuuzetsu: I'm kinda prejudiced against list comprehensions.
15:51:52 <benzrf> mr_yogurt: what language do you use atm?
15:51:58 <benzrf> bitemyapp: i never use em myself
15:52:01 <bitemyapp> Fuuzetsu: I might feel better about them when monad comprehension becomes the default.
15:52:04 <mr_yogurt> What do you mean by scaling function? Scale as in multiply each element by a scalar?
15:52:09 <mr_yogurt> Also, I use C++ atm.
15:52:12 <bitemyapp> Fuuzetsu: it's a lot of functionality (IMO) in one syntax.
15:52:35 <bitemyapp> yayyyy we have logging in #haskell-beginners!
15:53:06 <mr_yogurt> It looks like by scale you mean make the 2D list 4x as big with each element replaced by 4 of said element
15:53:51 <bitemyapp> mr_yogurt: hey
15:53:54 <bitemyapp> mr_yogurt: hey you there
15:53:58 <mr_yogurt> yes yes I am
15:53:59 <mr_yogurt> Why
15:54:02 <bitemyapp> mr_yogurt: https://github.com/bitemyapp/learnhaskell
15:54:19 <Fuuzetsu> notice me senpai
15:54:22 <mr_yogurt> I went there already
15:54:30 <bitemyapp> mr_yogurt: but you're still talking.
15:54:40 <mr_yogurt> Because you guys are talking
15:54:42 <bitemyapp> mr_yogurt: go learn.
15:54:57 <bitemyapp> Fuuzetsu: LOL
15:55:01 <benzrf> Fuuzetsu: senpai will never notice you
15:55:35 <bitemyapp> benzrf: http://www.youtube.com/watch?v=6jfkZQNw9U4
15:56:04 <bitemyapp> benzrf: http://i.imgur.com/3ZqWLTi.png
15:56:04 <benzrf> >pewdiepie
15:56:17 <benzrf> bitemyapp: /r/tsunderesharks
15:56:33 <merijn> None of this seems particularly Haskell related
15:56:34 <Fuuzetsu> wow, I immediatelly regret my decision to watch that
15:56:39 <Fuuzetsu> I have to make sure to purge it from my /tmp
15:56:41 <bitemyapp> benzrf: oh my god
15:57:23 <Fuuzetsu> yes, go to -blah if you want to continue (please don't continue)
15:59:37 <mr_yogurt> why is bitemyapp promoting his own stuff. is it trustworthy.
16:00:13 <Fuuzetsu> mr_yogurt: the beginner links look fine, might also want to scroll down to secondary material section
16:00:38 <bitemyapp> mr_yogurt: because it works
16:00:48 <bitemyapp> mr_yogurt: and I want you to use your time efficiently.
16:00:59 <Fuuzetsu> sounds like you're selling something bitemyapp
16:01:08 <benzrf> mr_yogurt: what language[s] do you already knw
16:01:10 <benzrf> *know
16:01:31 <bitemyapp> Fuuzetsu: I just want people to learn Haskell without wasting time, fuck me right?
16:01:36 <mr_yogurt> I know a bit of c++ and java. I can't say I completely "know" any language atm.
16:02:16 <phmltyp> Does anyone know of a simple HOAS evaluator for a Haskell-like Core language?
16:02:17 <benzrf> mr_yogurt: ouch
16:02:58 <benzrf> mr_yogurt: do you understand the concept of a function from maths?
16:03:05 <mr_yogurt> yes yes I do
16:03:12 <mr_yogurt> input x, get f(x) back
16:03:20 <Fuuzetsu> bitemyapp: just saying what it looks like, don't scare the poor guy away
16:03:20 <benzrf> mr_yogurt: do you understand the idea of using a function as a value?
16:03:29 <benzrf> mr_yogurt: i.e., pass a function to a function, get back a new function
16:03:39 <bitemyapp> Fuuzetsu: I was being jocular, no offense taken or intended :)
16:03:45 <mr_yogurt> Not that. That is a new concept. Yay.
16:03:53 <bitemyapp> Fuuzetsu: it's not about selling something, I mostly just want them to go learn
16:03:55 <mr_yogurt> Maybe not entierly new
16:03:55 <benzrf> mr_yogurt: shit it's useful
16:03:57 <bitemyapp> Fuuzetsu: rather than bopping around IRC
16:03:59 <mr_yogurt> Just mostly new
16:04:06 <bitemyapp> Fuuzetsu: I'd be happy to give them a different link if that's desired.
16:04:08 <benzrf> mr_yogurt: the classic example is the 'map' function
16:04:10 * Fuuzetsu is boping around IRC
16:04:16 <benzrf> mr_yogurt: it takes a function and a list, and applies the function to each item in the list
16:04:16 <bitemyapp> > map (+1) [0, 1, 2]
16:04:17 <Fuuzetsu> I'm sure I'm meant to be coding something
16:04:18 <lambdabot>  [1,2,3]
16:04:22 <bitemyapp> Fuuzetsu: you aren't demanding other peoples' time.
16:04:27 <mr_yogurt> I've heard of the concept of passing in function a to function b, but not getting function c back from that
16:04:33 <benzrf> mr_yogurt: ah
16:04:36 <benzrf> mr_yogurt: well you should be fine :-)
16:04:48 <benzrf> mr_yogurt: you already understand about 1/3 of the core concepts of haskell
16:04:54 <benzrf> congrats!
16:05:08 <mr_yogurt> although I've never actually used said concept in practice
16:05:11 <Fuuzetsu> I'll recompile GHC I guess
16:05:13 <benzrf> mr_yogurt: of course, that doesn't make you 1/3 of the way to understandin the pervasive idioms
16:05:16 <benzrf> ;)
16:05:17 <bitemyapp> Fuuzetsu: hahaha, why?
16:05:38 <Fuuzetsu> how will I stay on the bleeding of the bloody edges if I don't?
16:05:41 <benzrf> just because you get functions, ADTs, pattern matching, and typeclasses doesn't mean you instantly grasp monads
16:05:48 <Fuuzetsu> bleediest*
16:05:49 <benzrf> but it means you're equipped to :-)
16:06:34 <bitemyapp> Fuuzetsu: are they fixing GND in 7.8.3?
16:07:18 <Fuuzetsu> don't roles fix that
16:07:28 <bitemyapp> Fuuzetsu: I wasn't aware of it.
16:07:54 <pejo> phmltyp, there's libraries available for building your own if you're interested in that, but I'm not sure they qualify as simple
16:09:48 <Fuuzetsu> I mostly care about 7.8.3 vs 7.8.2 because I get to push out a bugfix in Haddock that covers my mistake
16:09:59 <Fuuzetsu> although there are some nasty bugs fixed in GHC itself
16:10:33 <benzrf> bluh
16:10:42 <benzrf> how do i invoke ghc in a sand box
16:10:52 <Fuuzetsu> why do you need to?
16:11:07 <bitemyapp> I'm laughing and tearing up a bit, because I understand exactly how benzrf feels right now.
16:11:13 <benzrf> because im trying to profile my 1-file program
16:11:16 <bitemyapp> benzrf: the sandbox is just a package-db.
16:11:17 * benzrf flips a table
16:11:29 <bitemyapp> benzrf: point GHC at the package-db if you insist on not writing a cabal file.
16:11:32 <benzrf> how
16:11:34 <Fuuzetsu> you can specify GHC_PACKAGE_PATH
16:11:35 <benzrf> q.q
16:11:35 <Fuuzetsu> or just use cabal
16:11:38 <benzrf> ok
16:12:12 <Fuuzetsu> example snippet from sandboxed yi script: export GHC_PACKAGE_PATH=$HOME/programming/yi/yi/.cabal-sandbox/i386-linux-ghc-7.6.3-packages.conf.d:$GHC_PACKAGE_PATH
16:12:13 <Fuuzetsu>  
16:12:39 <Fuuzetsu> then it should see it properly
16:12:57 <benzrf> thanks :-)
16:13:05 <benzrf> whaddya know, it compiled!!!
16:13:06 <benzrf> \o/
16:13:17 <bitemyapp> benzrf: :)
16:13:27 * Fuuzetsu waits for benzrf to complain about inability to profile multiple settings at once
16:13:30 <Fuuzetsu> that really pisses me off
16:14:37 <benzrf> shit
16:14:55 <benzrf> accidentally ^C'd in the terminal running my ssh -X
16:15:07 <benzrf> oh good i reconnected in time for my bouncer to not nickchange
16:15:26 <bitemyapp> benzrf: and people wonder why I just use irssi + screen.
16:15:39 <Fuuzetsu> I used to use irssi and screen but it was PITA
16:16:02 <bitemyapp> ez-pz for me. Everybody's different :)
16:16:03 <benzrf>    1,195,677,048 bytes allocated in the heap
16:16:05 <benzrf> uwot
16:16:11 <bitemyapp> ^^ hahahahaha
16:16:18 <benzrf> how do you even
16:16:18 <bitemyapp> benzrf: I'd like to know how you did that.
16:16:24 <Fuuzetsu> that's total
16:16:26 <benzrf> bitemyapp: poor planning
16:16:43 <bitemyapp> benzrf: incidentally, that's leaner than the total bytes allocated for a "hello world" in Clojure.
16:16:50 <benzrf> meh heh heh
16:16:52 <bitemyapp> The More You Know.
16:17:11 <benzrf> my friend wrote a program that generates a ppm of randomly colored squares for wallpaper usage
16:17:13 <Fuuzetsu> that's some low standard of comparison
16:17:22 <mr_yogurt> Is it possible to write a game with haskell?
16:17:25 <benzrf> i decided to rewrite it in haskell to demonstrate its superiority
16:17:29 <Fuuzetsu> mr_yogurt: sure
16:17:30 <benzrf> this is what i wrote:
16:17:34 <mr_yogurt> I want to see an example
16:17:39 <benzrf> http://bpaste.net/show/350684/
16:17:55 <Fuuzetsu> mr_yogurt: look for ‘game’ on Hackage I suppose
16:17:56 <benzrf> i feel like i made a naive assumption there somewhere
16:18:29 <Fuuzetsu> I found ‘Chimera’ the other day but that's not on Hackage. Also see http://www.haskell.org/haskellwiki/Game_Development
16:18:46 <Fuuzetsu> Actual example www.youtube.com/watch?v=0jYdu2u8gAU
16:20:13 <Fuuzetsu> (the recording is choppy but the actual game ran ~60FPS as seen in the corner)
16:20:34 <bernalex> what ml would you guys recommend? I don't know either. I have read and written tiny things in SML and OCaml, but I don't *know* either of them.
16:21:01 <bernalex> I want to teach myself one of them a bit more properly to broaden my horizon. :-]
16:21:41 <benzrf> ok so what precisely is wrong with my program
16:21:53 <benzrf> how did it use a gigbte
16:22:05 <kadoban> bernalex: Look them up on wikipedia and see which looks fun. Or if you want the biggest challenge/broadest horizons, see which one looks the least comfortable.
16:22:34 <bernalex> kadoban: they all look kind of too similar, and wikipedia isn't great for resources. I'd probably like to just go with the one with the best learning resources available.
16:22:46 <bitemyapp> bernalex: MLton or OCaml.
16:22:46 <bernalex> + one that isn't completely experimental or dead
16:22:54 <kadoban> fair enough
16:23:08 <bernalex> bitemyapp: never used mlton -- never even heard of it. read a little bit of ocaml.
16:23:11 <Fuuzetsu> benzrf: section 5.4 of the GHC manual is on memory profiling
16:23:19 <bernalex> I was really shocked when I first read ocaml. it was my first functional language.
16:23:20 <benzrf> :|
16:23:21 <bitemyapp> bernalex: the differences aren't that important IMO.
16:23:29 <bernalex> it did... not look like c++ lol.
16:23:47 <benzrf> Fuuzetsu: care to glance at my code and look for obvious horrible mistakes p:
16:23:50 <bernalex> bitemyapp: ocaml is by far more popular, so I guess I'll pick that simply because of resources/help/etc
16:24:49 <Fuuzetsu> benzrf: Uh sure although I'm kind of doing few things at once atm
16:24:53 <benzrf> kk
16:24:54 <Fuuzetsu> I'm not a performance guru
16:24:57 <benzrf> yeah
16:25:01 <bitemyapp> bernalex: that's a good reason, but I wanted to offer options.
16:25:07 <benzrf> but im probably making an obvious mistake
16:25:46 <Fuuzetsu> post whole project (cabal files etc) so I can sandbox it
16:25:52 <Fuuzetsu> also test inputs and all that
16:25:53 <benzrf> Fuuzetsu: that's the whole thing ;p
16:25:56 <bitemyapp> benzrf: what are you loading into it?
16:26:02 <benzrf> ./wp 60 1920 1080
16:26:09 <Fuuzetsu> benzrf: post link?
16:26:17 <benzrf> Fuuzetsu: i did http://bpaste.net/show/350684/
16:26:24 <Fuuzetsu> oh didn't see
16:27:52 <benzrf> it says almost all the time was spent in toBytes
16:30:14 <Fuuzetsu> why is nix so good
16:30:28 <Fuuzetsu> just sandboxed it all with profiling libs &c ;)
16:30:45 <Fuuzetsu> which compiler version by the way
16:30:48 <Fuuzetsu> 7.6.3?
16:30:58 <benzrf> y
16:30:58 <Fuuzetsu> what RTS options?
16:31:05 <benzrf> +RTS -p
16:31:10 <benzrf> wait
16:31:17 <benzrf> +RTS -sstderr for the gigrbyte one
16:31:18 <Fuuzetsu> what compiler options?
16:31:27 <benzrf> -prof -rtsopts -fprof-auto
16:32:10 <Fuuzetsu> 601,280,828 bytes allocated in the heap
16:32:10 <Fuuzetsu>       69,563,604 bytes copied during GC
16:32:11 <Fuuzetsu>          281,296 bytes maximum residency (63 sample(s))
16:32:12 <Fuuzetsu>           70,848 bytes maximum slop
16:32:14 <Fuuzetsu>                2 MB total memory in use (0 MB lost due to fragmentation)
16:32:48 <benzrf> whmmm
16:32:50 <benzrf> *hmmm
16:33:06 <benzrf> Fuuzetsu: how long'd it take to run
16:33:13 <benzrf> i feel like i shouldnt be loading the whole thing in memory at once
16:33:29 <benzrf> @hoogle putWord
16:33:30 <lambdabot> No results found
16:33:32 <benzrf> @hoogle putChar
16:33:32 <lambdabot> Prelude putChar :: Char -> IO ()
16:33:32 <lambdabot> System.IO putChar :: Char -> IO ()
16:33:32 <lambdabot> System.IO hPutChar :: Handle -> Char -> IO ()
16:33:42 <benzrf> @hoogle Word8 -> charliekilo
16:33:43 <Fuuzetsu>  
16:33:43 <Fuuzetsu> real    0m0.614s
16:33:43 <lambdabot> Unsafe.Coerce unsafeCoerce :: a -> b
16:33:43 <lambdabot> Prelude id :: a -> a
16:33:43 <lambdabot> Data.Function id :: a -> a
16:33:43 <Fuuzetsu> user    0m0.500s
16:33:45 <Fuuzetsu> sys     0m0.025s
16:33:46 <benzrf> @hoogle Word8 -> Char
16:33:46 <lambdabot> Unsafe.Coerce unsafeCoerce :: a -> b
16:33:46 <lambdabot> Control.OldException throwDyn :: Typeable exception => exception -> b
16:33:46 <lambdabot> Data.Generics.Text gshow :: Data a => a -> String
16:33:49 <Fuuzetsu> piping the gibberish to /dev/null
16:33:51 <benzrf> Fuuzetsu: faster than me eh
16:33:54 <Lutin`> Anyone here worked on wai before?
16:34:01 <Fuuzetsu> well, redirecting
16:34:43 <benzrf> Fuuzetsu: why not into display?
16:34:43 <benzrf> ;-)
16:34:58 <Lutin`> Or should I say warp
16:35:21 <Fuuzetsu> because it's ugly and shifts the profiling output
16:35:27 <benzrf> o
16:35:45 <Fuuzetsu> time for some graphs I guess
16:37:05 <genisage> can somebody explain why one would use "concat . map concat" instead of "concat . concat"? They seem to remove the same two levels of nested-ness, just in different orders.
16:38:22 <benzrf> genisage: oh hmmm
16:38:53 <benzrf> i think i was doing something different at first
16:38:54 <benzrf> then switched
16:38:58 <benzrf> and didnt change
16:40:29 <benzrf> ooh i think that actually dramatically increased perf
16:40:31 <benzrf> hhuh
16:40:37 <benzrf> :t BS.concat
16:40:38 <lambdabot> [BSC.ByteString] -> BSC.ByteString
16:40:41 <benzrf> coo
16:41:17 <benzrf> is it faster to concat then pack, or map pack then BS.concat?
16:41:37 <genisage> Try it and see?
16:42:27 <genisage> I'm leaning slightly towards the former
16:43:02 <benzrf> ehamberg:
16:43:03 <benzrf> *eh
16:44:22 <benzrf> hmmm yeah the latter is much slower
16:44:36 <Fuuzetsu> benzrf: http://fuuzetsu.co.uk/images/1402098159.png
16:45:05 <benzrf> heuh
16:45:12 <benzrf> i get almost all the time spent in toBytes
16:45:19 <benzrf> well
16:45:20 <benzrf> it inherits
16:45:29 <Fuuzetsu> http://fuuzetsu.co.uk/images/1402098214.png
16:45:40 <Fuuzetsu> but we don't care about time but space
16:46:00 <benzrf> space too d:
16:46:05 <benzrf> >went to http://fuuzetsu.co.uk/
16:46:08 <benzrf> >giant pic of animu
16:46:10 <benzrf> weeeeeeeeeeeb
16:46:13 <Fuuzetsu> deal with it
16:46:50 <benzrf> my friend decided to make the user@host a word on his new install
16:46:55 <monochrom> @type concat . concat
16:46:57 <lambdabot> [[[a]]] -> [a]
16:47:02 <monochrom> @type concat . map concat
16:47:03 <lambdabot> [[[a]]] -> [a]
16:47:05 <benzrf> and he completely squandered it on 'ab@axial'
16:47:12 <benzrf> who even knows what abaxial mean
16:47:14 <benzrf> s
16:47:22 <benzrf> he couldve gone for 'wee@boo'!
16:47:43 <Fuuzetsu> monochrom: good call
16:47:53 <benzrf> Fuuzetsu: yeah i changed that
16:47:56 <monochrom> interesting. that's a natural transformation saying they are equal
16:47:58 <benzrf> it made it a lot faster o=
16:47:59 <Fuuzetsu> -200MB on heap
16:51:10 <Fuuzetsu> you'll probably have to gut that scale
16:52:14 <benzrf> :I
16:57:43 <_Vi> How to add "hprotoc" pre-build step in Cabal project to generate Haskell sources from *.proto files?
17:02:00 <enthropy> _Vi: probably you'd have to set the build-type: Custom, and then write some code to do such a thing in the Setup.lhs
17:02:11 <enthropy> or maybe it's possible to get ghc to call that preprocessor
17:02:26 <enthropy> with flags like -pgmF hprotoc -F
17:02:33 <_Vi> enthropy, hprotoc reads a non-Haskell file and generates multiple Haskell sources from it.
17:03:10 <_Vi> Can it be done portably?
17:03:50 <Fuuzetsu> no idea how to get lower memory without changing the algorithm, I give up
17:04:19 <enthropy> @type concatMap concat
17:04:20 <lambdabot> [[[b]]] -> [b]
17:06:36 <enthropy> _Vi: Setup.lhs stuff can be portable
17:07:06 <_Vi> enthropy, Means depending on executable that is installed by "cabal-install".
17:08:17 <Fuuzetsu> @hoogle Monad m => a -> m b -> m a -> m b
17:08:19 <lambdabot> Control.Monad liftM3 :: Monad m => (a1 -> a2 -> a3 -> r) -> m a1 -> m a2 -> m a3 -> m r
17:08:19 <lambdabot> Control.Exception.Base bracket_ :: IO a -> IO b -> IO c -> IO c
17:08:19 <lambdabot> Control.Exception bracket_ :: IO a -> IO b -> IO c -> IO c
17:08:33 <Fuuzetsu> @hoogle Monad m => (a -> m b) -> m a -> m b
17:08:35 <lambdabot> Prelude (=<<) :: Monad m => (a -> m b) -> m a -> m b
17:08:35 <lambdabot> Control.Monad (=<<) :: Monad m => (a -> m b) -> m a -> m b
17:08:36 <lambdabot> Prelude (>>=) :: Monad m => m a -> (a -> m b) -> m b
17:08:43 <Fuuzetsu> …I guess
17:10:09 <pavonia> Hhm, is there no standalone binary of Pandoc for Windows?
17:10:54 <Lutin`> Have you tried the Pandoc web page?
17:11:29 <Festisio> I am trying to merge a list of lists == it works for everything except pairs -- any ideas? http://lpaste.net/1918987243209359360
17:11:32 <Lutin`> http://johnmacfarlane.net/pandoc/ -> http://johnmacfarlane.net/pandoc/installing.html -> https://github.com/jgm/pandoc/releases -> https://github.com/jgm/pandoc/releases/download/1.12.4.2/pandoc-1.12.4.2-1-windows.msi
17:11:54 <bernalex> bitemyapp: yeah thanks, appreciate it
17:12:08 <pavonia> Lutin`: Yes, but there's only an installer package, I'd prefer a single binary for a command line tool
17:12:18 <Lutin`> Ooh sorry
17:12:28 <Lutin`> I need sleep :[
17:12:38 <pavonia> No worries :)
17:13:35 <sveit> anyone using structured-haskell-mode in emacs? i think there is a bug in instance and function guard indentation
17:13:40 <Lutin`> You could always extract the binary from the msi file
17:13:42 <sveit> but I may have a poor set-up
17:16:23 <pavonia> Lutin`: Ah, there's msciexec already installed that seems to be able to extract it. I'll try that, thanks!
17:17:52 <bitemyapp> anyone have any resources on golfing in Haskell?
17:24:18 <Lutin`> pavonia: If you haven't done it yet, I installed to a location in a sandbox and zipped up the files
17:24:32 <Lutin`> That way you definitely won't have anything installed
17:25:04 <Lutin`> pavonia: http://www.solidfiles.com/d/8b487e7c4b/pandoc-1.12.4.2-1-windows-standalone.zip
17:25:48 <pavonia> Lutin`: Thanks, already got it working with msciexec :)
17:25:55 <Fuuzetsu> just spotted this in code ‘fontRef <- newIORef undefined’ ;(
17:25:58 <Lutin`> k np
17:26:04 <Fuuzetsu> isn't there like newEmptyIORef or something?
17:28:47 <bms1> Fuuzetsu: MVar?
17:28:49 <bms1> http://www.haskell.org/ghc/docs/latest/html/libraries/base/Control-Concurrent-MVar.html
17:34:33 <bitemyapp> Fuuzetsu: that is evil.
17:36:04 <tristanStrange> hey all. any one know how to easily convert hexcolours like "1234FF" to a Data.Colour?
17:36:59 <Enigmagic> Fuuzetsu: newIORef undefined
17:37:44 <Fuuzetsu> well we write to it right after so it's not a huge problem
17:37:56 <Lutin`> tristanStrange: To a Data.Colour.SRGB yes
17:37:57 <Cale> tristanStrange: sRGB24read ?
17:38:24 <Enigmagic> Fuuzetsu: there is always mfix..
17:39:29 <Fuuzetsu> mfix?
17:39:30 <Fuuzetsu> :t mfix
17:39:31 <lambdabot> MonadFix m => (a -> m a) -> m a
17:39:39 <Fuuzetsu> heh
17:40:00 <Fuuzetsu> > mfix (return :: a -> [a])
17:40:04 <lambdabot>  mueval-core: Time limit exceeded
17:40:29 <Fuuzetsu> I think I can stick a default value in there
17:41:42 <tristanStrange> brilliant thanks cale/Lutin: sRGB24reads
17:42:40 <pavonia> Is there a way to find out what GHC packages are still present on the drive but aren't registered in the package list anymore?
17:45:33 * hackagebot music-util 0.12 - Utility for developing the Music Suite.  http://hackage.haskell.org/package/music-util-0.12 (HansHoglund)
17:54:35 <geekosaur> not really
17:54:49 <geekosaur> "I removed the package records, how do I know what packages I had?"
17:55:00 <geekosaur> restore from backup
18:08:47 <Enigmagic> pavonia: sure
18:09:01 <Enigmagic> pavonia: here's a terrible one liner: find ~/.cabal/lib/x86_64-osx-ghc-7.8.2 -type d -maxdepth 1 -mindepth 1 | xargs basename | xargs -I{} sh -c "ghc-pkg list --simple {} | grep -q '[a-z]' || echo {}"
18:09:48 <Enigmagic> pavonia: all you really need to do is look for directories under your .cabal/lib folder that don't have entries in the ghc-pkg list output
18:13:11 <pavonia> Enigmagic: And removing directories that aren't listed by ghc-pkg can't break anything?
18:13:54 <Enigmagic> pavonia: assuming cabal put them there it is safe to remove them
18:14:46 <Enigmagic> pavonia: ghc's only way of finding packages is through ghc-pkg. if a package isn't in the list it's not going to be available for compiling either..
18:14:47 <pavonia> Okay
18:15:02 <Enigmagic> pavonia: one exception: if you're using dynamic linking
18:15:55 <pavonia> Hhm, I think I'm not
18:16:08 <Enigmagic> pavonia: compiled applications might reference libraries that are in there. if you are and are worried about it, move them first and see if anything breaks before you delete them.
18:16:38 <Enigmagic> pavonia: k, if you're just using static linking it should be fine to delete them.
18:16:59 <pavonia> Moving them first is a good idea
18:20:15 <yaymukund> is there a cleaner way to get the n-tuples of a list? I've got one working implementation here, but it feels like it could be improved: https://gist.github.com/yaymukund/4e269161e71d9201d88b
18:21:18 <enthropy> > chunksOf 3 [1 .. 10]
18:21:20 <lambdabot>  [[1,2,3],[4,5,6],[7,8,9],[10]]
18:21:40 <yaymukund> enthropy: not quite what I'm looking for, but that seems close
18:22:01 <yaymukund> I want [1,2,3], [2,3,4], ... [8,9,10]
18:22:44 <enthropy> > map (take 3) $ iterate (drop 1) [1 .. 10]
18:22:46 <lambdabot>  [[1,2,3],[2,3,4],[3,4,5],[4,5,6],[5,6,7],[6,7,8],[7,8,9],[8,9,10],[9,10],[10...
18:22:58 <Iceland_jack> enthropy: except for the last 3
18:23:07 <Iceland_jack> > tails [1..10] -- also
18:23:08 <lambdabot>  [[1,2,3,4,5,6,7,8,9,10],[2,3,4,5,6,7,8,9,10],[3,4,5,6,7,8,9,10],[4,5,6,7,8,9...
18:23:28 <enthropy> yeah fixing that will take another function
18:23:31 <yaymukund> oo
18:23:54 <enthropy> > takeWhile ((==) 3 . length) $ map (take 3) $ iterate (drop 1) [1 .. 10]
18:23:55 <lambdabot>  [[1,2,3],[2,3,4],[3,4,5],[4,5,6],[5,6,7],[6,7,8],[7,8,9],[8,9,10]]
18:24:09 <Iceland_jack> calculating the length of each list?
18:24:23 <enthropy> it's just a constant factor :p
18:24:44 <Iceland_jack> they matter
18:24:50 <yaymukund> okay, so there's no magic function that I'm overlooking haha
18:24:52 <Iceland_jack> also it's not constant
18:26:09 <copumpkin> > tails [1..10]
18:26:11 <lambdabot>  [[1,2,3,4,5,6,7,8,9,10],[2,3,4,5,6,7,8,9,10],[3,4,5,6,7,8,9,10],[4,5,6,7,8,9...
18:26:29 <enthropy> Iceland_jack: "take 3" is "3" operations, so why should a "length" that is also 3 operations not be a constant factor?
18:26:40 <yaymukund> tails looks like it could be very helpful
18:26:43 <enthropy> > tails [1 .. 3]
18:26:45 <lambdabot>  [[1,2,3],[2,3],[3],[]]
18:29:26 <bitemyapp> @djinn (a, b) -> (a, b) -> (b, b)
18:29:27 <lambdabot> f (_, a) (_, b) = (b, a)
18:43:18 <nexx> > length [1..]
18:43:22 <lambdabot>  mueval-core: Time limit exceeded
18:45:41 * hackagebot http-encodings 0.9.3 - A library for encoding and decoding bodies of HTTP messages  http://hackage.haskell.org/package/http-encodings-0.9.3 (AndreyChudnov)
18:46:34 <yaymukund> thanks all, I ended up going with https://gist.github.com/yaymukund/4e269161e71d9201d88b
18:47:53 <yaymukund> I need to learn more about haskell memory allocation
18:48:00 <yaymukund> that feels like a big, scary gap
18:50:35 <Festisio> goons
19:00:42 * hackagebot haxy 1.0 - A simple HTTP proxy server library  http://hackage.haskell.org/package/haxy-1.0 (AndreyChudnov)
19:27:34 <Lutin`> yaymukund: I found some notes from someone who took the CS 240 - Functional Systems In Haskell that seems to cover a lot of points that might help to reason about your programs http://stanford.edu/~adebray/240h_notes.pdf
19:28:07 <yaymukund> Lutin`: thank you for the link. I'm taking a look now.
19:28:11 <Lutin`> Not sure how much it would help but figured I'd throw it your way
19:28:39 <yaymukund> definitely, I appreciate it. this looks like my level :o)
19:29:03 <Lutin`> Criterion is definitely a nice library
19:32:27 <dfranke_> every time GHC raises a spurious warning about inexhaustive pattern matches I feel like I have a point of honor in need of settlement :-/
19:34:22 <dfranke> (relatedly, I hope #8779 gets implemented soon)
19:50:00 <voxpopuli> what's the best way to represent a 2d table of given numbers that I'll want to index into, as in project euler problem 11: https://projecteuler.net/problem=11
19:50:54 <matematikaadit> voxpopuli: Array
19:51:21 <augur> matematikaadit: whats your username mean
19:51:51 <voxpopuli> matematikaadit: could you point me to an example of how I would actually initialize the array? I can only find ones where they initialize from a list comprehension or something
19:52:02 <matematikaadit> augur: matematika + adit
19:53:00 <augur> whats adit?
19:53:16 <matematikaadit> augur: my name.
19:53:34 <augur> aha!
19:54:13 <matematikaadit> voxpopuli: http://hackage.haskell.org/package/array-0.5.0.0/docs/Data-Array.html#g:2
19:55:32 <matematikaadit> voxpopuli: using array, you could create one using a list of associations.
19:55:40 <matematikaadit> :t array
19:55:41 <lambdabot> Ix i => (i, i) -> [(i, e)] -> Array i e
19:56:21 <rwbarton> or if you already have a list in the proper order you can use listArray
19:56:27 <rwbarton> :t listArray
19:56:28 <lambdabot> Ix i => (i, i) -> [e] -> Array i e
19:57:48 <matematikaadit> > array (1, 3) [(1, 'a'),(2, 'b'), (3, 'c')]
19:57:49 <lambdabot>  array (1,3) [(1,'a'),(2,'b'),(3,'c')]
19:59:09 <matematikaadit> > listArray (1,3) ['a'..'c']
19:59:11 <lambdabot>  array (1,3) [(1,'a'),(2,'b'),(3,'c')]
19:59:19 <voxpopuli> how does that look if the array is 2d?  what do the indices become, tuples?
20:01:05 <ab9rf> depends on how you choose to implement the array
20:03:05 <rwbarton> voxpopuli: yes
20:03:34 <ab9rf> you can also do the array-of-arrays strategy, but that usually isn't what you want
20:04:24 <Lutin`> matematikaadit: Of adit.io?
20:04:54 <matematikaadit> Lutin`: umm... no.
20:05:07 <Lutin`> Oh lol
20:05:17 <Lutin`> Just wondering
20:05:29 <Lutin`> Guess there's another haskeller out there named adit
20:07:39 <ab9rf> i wonder if i'm going to regret letting cabal install aeson 0.7
20:16:02 <donnobot> hello haskellteers
20:16:14 <donnobot> trying to install snap
20:16:30 <donnobot> getting this message: snap-0.13.2.7 depends on lens-4.1.2.1 which failed to install
20:18:19 <Lutin`> Why did  lens-4.1.2.1 fail to install?
20:18:45 <donnobot> lens-4.1.2.1 failed during the building phase. The exception was: ExitFailure 1
20:19:00 <ab9rf> heh
20:19:06 <crazydave> not that I can help in particular: but you might want to add OS, version of ghc you are using.  And paste the full output here:http://lpaste.net
20:19:11 <ab9rf> welcome to cabal hell
20:19:16 <crazydave> the real error will be up further
20:19:34 <donnobot> lol yes
20:19:54 <voxpopuli> matematikaadit et al: thanks, think I got something usable
20:20:55 <ab9rf> i find that bourbon makes installing cabal packages much easier
20:20:59 <ab9rf> or at least less irritating
20:21:58 <donnobot> enough output to make anyone's head spin http://lpaste.net/105226
20:22:35 <donnobot> i thought the whole idea of snap was it installed in a snap
20:23:21 <mightybyte> donnobot: That sounds like it's a lens issue.
20:23:34 <glguy> Loading package base ... <command line>: can't load .so/.DLL for: /Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX10.9.sdk/usr/lib/libiconv.dylib (dlopen(/Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX10.9.sdk/usr/lib/libiconv.dylib, 9): no suitable image found.  Did find:
20:23:34 <glguy> 	/Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX10.9.sdk/usr/lib/libiconv.dylib: mach-o, but wrong filetype)
20:23:50 <glguy> Looks like your GHC installation is broken and lens is tripping on that when trying to use TH
20:24:38 <donnobot> oh...try reinstalling GHC?  i did it through Brew
20:25:07 <donnobot> was following this guy: http://frontendandvodka.com/installing-haskell-snap-on-osx-mavericks-with-homebrew/
20:25:36 <glguy> I think those instructions are probably out of date now that GHC 7.8.2 is out
20:25:36 <Welkin> use @lpaste
20:25:39 <Welkin> @lpaste
20:25:40 <lambdabot> Haskell pastebin: http://lpaste.net/
20:26:28 <mightybyte> donnobot: I find that I'm usually better off not using brew to install GHC.
20:26:35 <glguy> On OS X I always just install the binary from haskell.org/ghc
20:26:50 <mightybyte> donnobot: I just download it from http://www.haskell.org/ghc/ and install it manually.
20:26:59 <mightybyte> glguy: lol, you beat me to it.
20:27:29 <Lutin`> Strange...does GHC require Unix shared objects instead of Mach dynamic libraries?
20:28:16 <donnobot> ok...will give that the ole college try.
20:30:18 <donnobot> after 2 days of fiddling with this that was the closest i came
20:30:46 <Welkin> why not just run on linux?
20:30:53 <Lutin`> Try asking in GHC if installing the binary doesn't help
20:30:55 <Welkin> run it in a vm if you want to use osx
20:31:00 <glguy> Your other option is to just install the haskell platform
20:31:06 <glguy> it tends to more or less work
20:31:06 <mightybyte> osx works fine for me
20:31:10 <Lutin`> #ghc that is
20:31:12 <donnobot> is it just a matter of updating GHC and it should work?
20:31:18 <mightybyte> Nooooo, the haskell platform causes problems for me.
20:31:41 <donnobot> i tried to install the haskell platform...that didn't go well
20:31:48 <glguy> Oh, maybe that doesn't work any more with the new xcode?
20:32:12 <mightybyte> donnobot: There appears to be a bit of hidden knowledge that us experienced Haskellers that slipped through tutorials somehow.  But yes, it should just work once you have a clean GHC and cabal-install.
20:32:31 <glguy> When I start a new OS X I do binary GHC install, cabal-install bootstrap, blow away the stuff cabal-install bootstrap installed without docs or profiling or dynamic
20:32:44 <mightybyte> There is the osx mavericks fix that you have to apply after the clean install though.
20:32:46 <Lutin`> donnobot: What is your GHC version? `ghc --version`
20:32:51 <glguy> and then install all the stuff I need... It's not super newbie friendly
20:33:02 <glguy> You don't need a mavericks fix for 7.8.2 afaik
20:33:04 <Welkin> why are there so many issues with osx and windows?
20:33:26 <glguy> Welkin, there aren't any more issues than on Linux now, the install process is the same for both
20:33:33 <donnobot> ghc 7.6.3
20:33:44 <Lutin`> ah
20:33:58 <glguy> 7.6.3 stopped working on current OS X because of changes that happened in XCode 5
20:34:05 <glguy> and the fixes are included in 7.8.2
20:34:06 <Lutin`> Yeah afaik you should be on 7.8 if you're on Mavericks
20:34:06 <donnobot> ahhhh
20:34:24 <donnobot> i'll install 7.8.2
20:34:47 <Welkin> why would an IDE give you problems with a language?
20:35:07 <Lutin`> it comes with an SDK that includes libraries
20:35:09 <glguy_> Xcode isn't just an ide
20:35:49 <Lutin`> Might be related to https://github.com/Homebrew/homebrew/issues/20546#issuecomment-26927570
20:36:02 <Lutin`> But yeah upgrading to 7.8 should fix it
20:36:17 <donnobot> ok guys. thats for the advice. going to throw in the towel for tonight. i'm hopeful for tomorrow
20:36:46 <Welkin> is there something special about xcode?
20:36:48 <rwbarton> aha yeah, that makes sense
20:37:11 <Gurkenglas> Given an Enum type, how do I get a list that enumerates its values?
20:37:34 <Gurkenglas> (the "canonical" list, preferably)
20:37:36 <rwbarton> Welkin: Xcode is what provided /Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX10.9.sdk/usr/lib/libiconv.dylib, I guess, based on the filename
20:37:51 <enthropy> > [minBound .. maxBound] :: [Bool]
20:37:52 <lambdabot>  [False,True]
20:38:31 <Gurkenglas> enthropy, That requires that it is bounded
20:38:42 <rwbarton> yes
20:38:44 <rwbarton> consider Integer
20:38:49 <glguy_> That's as close as you can get
20:38:57 <Welkin> I have never developed for osx
20:39:10 <Welkin> is xcode required to use the osx sdk?
20:39:11 <Gurkenglas> Hrrrm. Well I could assume Num but I don't like it
20:39:12 <popx> [toEnum 1 ..]
20:39:18 <Lutin`> > [minBound..] :: [Bool]
20:39:20 <lambdabot>  [False,True]
20:39:49 <enthropy> @type enumFrom
20:39:50 <lambdabot> Enum a => a -> [a]
20:39:57 <glguy_> Gurkenglas, you can't do it with just enum
20:39:59 <Lutin`> Aww man
20:40:04 <Gurkenglas> enthropy, thanks!
20:40:11 <Gurkenglas> Waaaait.
20:40:15 <Gurkenglas> nvm <.<
20:40:28 <Lutin`> Bounded isn't build from BoundedBelow BoundedAbove
20:40:36 <Gurkenglas> popx, that still requires bounded. Wait, why?
20:40:44 <Gurkenglas> :t [minBound ..]
20:40:46 <lambdabot> (Enum t, Bounded t) => [t]
20:40:50 <enthropy> probably popx is closest
20:40:55 <Lutin`> toEnum 1 doesn't require bounded
20:41:06 <popx> it's not a nice solution
20:41:12 <rwbarton> there might not even be a toEnum 1
20:41:16 <Lutin`> You'd want toEnum 0 though
20:41:16 <Gurkenglas> :t [toEnum 1 ..]
20:41:17 <lambdabot> Enum t => [t]
20:41:33 <rwbarton> also this misses all the negative Integers, for example
20:41:39 <glguy_> And 0
20:41:40 <rwbarton> there aren't really clear laws for Enum
20:41:51 <rwbarton> heck, even Double is Enum
20:41:58 <popx> you really want bounded Gurkenglas...
20:42:03 <Gurkenglas> Grr. Why would you make an Enum typeclass and not force it to give an enumeration
20:42:20 <glguy_> Yeah, it's just a hack that exists for [..] Syntax
20:43:23 <Lutin`> Why would you necessarily want a finite enumeration?
20:43:26 <Gurkenglas> Ah well, may just make it specialized for Integer to add to the sting that it isn't maximally elegant
20:43:39 <Gurkenglas> Lutin', I didn't say it has to be finite
20:44:13 <Lutin`> Well how would you want to enumerate Integers?
20:44:15 <rwbarton> you might want to define a new class altogether
20:44:23 <rwbarton> class GimmeAllTheValues a where theValues :: [a]
20:44:40 <glguy_> Maybe not such a short name though
20:44:48 <rwbarton> haha
20:44:53 <Lutin`> ([1..], [..0]) ?
20:45:00 <Gurkenglas> Lutin', use any enumeration that catches all Integers. For example [0,1,-1,2,-2,...]
20:45:06 <rwbarton> class GimmeAllTheValues_Please
20:45:14 <Gurkenglas> Or [0,1,2,3,-1,4,5,6,-2,7,8,...].
20:45:24 <glguy_> When are we getting [..0] syntax?
20:45:31 <Lutin`> Yeah there isn't
20:45:35 <Lutin`> yet
20:45:45 <rwbarton> glguy_, right after we get snoc lists added to Prelude
20:45:54 <glguy_> Weee
20:46:02 <Lutin`> lol
20:46:05 <Gurkenglas> Hmm for a list of all values I'd like the syntax [..]
20:46:23 <Lutin`> The issue is that's not a well defined operation
20:47:14 <Gurkenglas> Lots of operations shouldn't be assumed as well-defined beyond their axioms
20:48:36 <enthropy> there's no instance Alternative ((->) r)?
20:49:10 <glguy_> No, but I did want it this week :)
20:49:52 <enthropy> glguy_: enough to make a proposal?
20:50:03 <rwbarton> wait, how would that work?
20:50:31 <Lutin`> Gurkenglas: Eh I see where you're coming from
20:50:51 <enthropy> rwbarton: if you're asking me: http://lpaste.net/105227
20:51:45 <glguy_> I think I convinced myself that it didn't make sense
20:51:45 <glguy_> How would you define empty
20:51:57 <enthropy> const empty
20:52:03 <rwbarton> doesn't this not compile?
20:52:07 <Lutin`> Gurkenglas: There should be some sort of function defined like `enumeration :: (Enum a) => Naturals -> [a]
20:52:24 <Lutin`> woops a not [a]
20:52:25 <enthropy> oops it doesn't
20:52:27 <Gurkenglas> You mean -> a
20:52:42 <Lutin`> Yeah sorry, it's late
20:53:32 <Gurkenglas> Hmkay I'd be about as fine with that as with [..].
20:53:48 <Gurkenglas> Wait why the `?
20:53:56 <Lutin`> Oh meant to end the backtick
20:54:25 <Gurkenglas> ???
20:54:31 <Lutin`> Just a habit from bash
20:55:20 <Lutin`> and markdown, meant to surround in backticks to imply it was code
20:56:16 <Gurkenglas> Ahkthx
20:57:15 <Lutin`> It might be that they didn't want to include that in the class since there's an infinite number of ways to write that for countably infinite sets
20:57:47 <Lutin`> Not sure
20:58:18 <Gurkenglas> I bet that lots of operations can be defined in order to fulfill their axioms in more than one way
20:59:13 <Lutin`> I wouldn't bet against that
20:59:34 <Lutin`> Just trying to help shed some light to alleviate frustration
20:59:54 <Gurkenglas> Just trying to spread frustration to sow the seed for future interface changes
21:01:49 <Lutin`> Fair enough, I can get behind that
21:02:09 <Lutin`> something something Applicative superclass of Monad
21:04:09 <rwbarton> predicted to land in HEAD "very, very soon"
21:31:03 <isomorphismes> since haskell seems to handle data types nicely
21:31:16 <isomorphismes> has anyone ever used dimensional analysis either for play or in an actual application?
21:31:32 <isomorphismes> like the thing in high school chemistry/physics where you check your units at the end to make sure they make sense
21:31:39 <isomorphismes> is that useful at all in a real programming context?
21:34:42 <Gurkenglas> The last two lines are very much on the spot for Haskell, but I don't know dimensional analysis so soz.
21:35:39 <nexx> I would say it is kind of type checking
21:35:45 <nexx> *like
21:37:12 <rwbarton> there are libraries for dimensional analysis in Haskell, like http://hackage.haskell.org/package/dimensional-tf
21:37:29 <enthropy> http://www.haskell.org/haskellwiki/Physical_units lists more
21:37:45 <rwbarton> whether anyone actually uses them, I don't know :)
21:38:25 * enthropy used dimensional a bit in the ghc-6.8 days
21:39:45 <enthropy> isomorphismes: at first it probably takes longer to fix an error / convince the type checker that what you're doing is correct
21:40:48 <enthropy> if you have a formula like  b*(a/b)**(1/3), it'll take some rearrangement
21:44:14 <crazydave> the package looks pretty good ... eg type of (*) :: Num a => Dimensional v d a -> Dimensional v d' a -> Dimensional v (Mul d d') a
21:44:44 <crazydave> i.e. you just multiply two things together and it will work out the type that it returns
21:44:55 <rwbarton> enthropy: how would you deal with a cube root like that?
21:45:22 <rwbarton> oh, there is a special cbrt function
21:45:37 <crazydave> like this: (^) :: (Fractional a, NumType n) => Dimensional v d a -> n -> Dimensional v (Pow d n) a
21:45:54 <crazydave> raise a dimension to a power ... taken care of already
21:45:58 <enthropy> anyways, you can choose to avoid resources that have equations written like http://wins.engr.wisc.edu/teaching/mpfBook/chapter9/img21.gif
21:46:01 <rwbarton> yes, and one with a reified type parameter too
21:46:11 <crazydave> not just cube root  but _any_ power
21:46:29 <enthropy> crazydave: n has to be an integer there
21:46:31 <rwbarton> that one is for integer powers
21:46:37 <rwbarton> but there's also (^/) :: (Floating a, NumType n) => Dimensional v d a -> n -> Dimensional v (Root d n) a
21:46:39 <crazydave> there's nroot also
21:47:11 <crazydave> perhaps n still has to be an integer for nroot ... but it will handle any normal physical task
21:47:39 <crazydave> raising something to the power of pi might be impossible ... but then that really falls outside the scope of dimensional analysis
21:48:08 <rwbarton> yeah, I'm not sure that could ever arise physically
21:48:23 <crazydave> looks like a good package if you want to make sure your physics/chem/engineering equations are all sound
21:48:47 * enthropy prefers dimensional to dimensional-tf
21:49:18 <enthropy> the difference being that inference of the units only goes forwards in the -tf version
21:49:39 <crazydave> might even make sure that you don't use pounds per square inch versus Newtons and forcing a rocket to explode
21:50:10 <crazydave> I trust you enthropy: I haven't used it ... that there is an even better package is good too.
21:50:25 <enthropy> so :type \ x y -> (x * y) `asTypeOf` (1 *~ metre), will be able to tell you about the type of 'x' once you fix the type of 'y'
21:50:41 <enthropy> it's a trade-off
21:50:51 <enthropy> the -tf version looks prettier
21:51:41 <rwbarton> maybe injective type families will fix that! maybe
21:51:54 <crazydave> ah, but you get type inference.  whereas the -tf version needs the type of x and y or it won't know the type of x * y because it calculates it
21:52:22 <crazydave> I think I prefer the -tf version .... you should know what type your inputs are!
21:53:04 <ab9rf> my poor computer, having to recompile _everything_ it seems
21:53:06 <crazydave> but I haven't used it so perhaps in practice the dimensional package is better
21:53:33 <rwbarton> I don't think the author of either package will be offended if you use the other one.
21:53:47 <enthropy> they have the same author
21:53:50 <rwbarton> :)
21:54:02 <enthropy> which is the joke I guess
21:54:29 <crazydave> that was my guess .... just had to check to get the joke
22:11:31 <WraithM> I feel like I need to do this every couple of months, but I always forget. Is there a function that has type :: m Bool -> m () -> m (), which is basically when, only the boolean value is in a monad?
22:12:25 <Gurkenglas> @hoogle m Bool -> m () -> m ()
22:12:26 <lambdabot> Data.Generics.Aliases ext0 :: (Typeable a, Typeable b) => c a -> c b -> c a
22:12:26 <lambdabot> Control.Monad unless :: Monad m => Bool -> m () -> m ()
22:12:26 <lambdabot> Control.Monad when :: Monad m => Bool -> m () -> m ()
22:12:50 <WraithM> Yeah, hoogle doesn't come up with much
22:13:16 <WraithM> @hoogle Monad m => m Bool -> m () -> m ()
22:13:17 <lambdabot> Control.Monad unless :: Monad m => Bool -> m () -> m ()
22:13:17 <lambdabot> Control.Monad when :: Monad m => Bool -> m () -> m ()
22:13:17 <lambdabot> Prelude (>>) :: Monad m => m a -> m b -> m b
22:13:34 <glguy__> The closest in the standard libraries is "when"
22:13:54 <Gurkenglas> You're only getting a part of what can be found via Google->Hoogle
22:25:39 <WraithM> :t \f x -> f >>= (`when` x)
22:25:40 <lambdabot> Monad m => m Bool -> m () -> m ()
22:25:47 <WraithM> that's really annoying to write
22:25:58 <WraithM> I mean, I could define it
22:26:04 <WraithM> and I'm sure it is else where
22:26:09 * hackagebot snaplet-i18n 0.0.5 - snaplet-i18n  http://hackage.haskell.org/package/snaplet-i18n-0.0.5 (HaishengWu)
22:27:04 <rwbarton> there was a discussion about adding it recently
22:30:22 <rwbarton> ... it seems like msot people were in favor and then it got forgotten about?
22:40:45 <johnw> WraithM: that function is in monad-extras btw
22:40:53 <johnw> you can say: om when x $ print "Foo"
22:40:56 <johnw> or use whenM
22:41:09 <johnw> rwbarton: I felt like it was getting bikeshedded to death
22:41:53 <WraithM> johnw: Thanks! Yeah, I feel like I asked this question a couple of months ago, and I think you responded with the exact same response, lol
22:46:12 * hackagebot handle-like 0.0.0.1 - HandleLike class  http://hackage.haskell.org/package/handle-like-0.0.0.1 (YoshikuniJujo)
22:46:47 <lispy> Hello
22:47:01 <lispy> How flows the code in the rivers of Haskell?
22:47:30 <lispy> What machinations of category theory have we wrought on the world of computation this day?
22:48:43 <johnw> lispy: :)
22:52:59 <lispy> johnw: how are things? Fighting the good fight and implementing that which must be implemented? Sowing the seeds of functional programming? Reaping the benefits of purity?
22:53:08 <johnw> haha
22:53:14 <johnw> I'm working on my simple-conduit library
22:53:19 <johnw> care to review the upcoming blog post?
22:53:46 <rrradical> Just wrote my first non-trivial haskell program. If anyone wants to critique I'd appreciate it: http://lpaste.net/105228 (It annotates a time sheet text file with time deltas)
22:54:23 <lispy> rrradical: congrats
22:54:24 <Gurkenglas> @pl \f x -> f >>= (`when` x)
22:54:25 <lambdabot> (. flip when) . (>>=)
22:54:33 <lispy> rrradical: what was your first non-trivial haskell program?
22:55:11 <lispy> rrradical: do you know of hledger? It's different and solves a different problem yet it's related enough that I figured I should mention it
22:56:54 <rrradical> lispy: nope...interesting. I did it mostly as an exercise, but hledger may actually be pretty useful for me in the end :P
22:57:20 <lispy> Oops. I read that as "second non-trivial" so I asked a stupid question :)
22:57:43 <abh> rrradical: cant you derive Ord for Time
22:57:47 <lispy> rrradical: I don't really like using type aliases.
22:57:54 <abh> it seems like that would work
22:58:06 <lispy> rrradical: I always have a hard time articulating why and I do sometimes use them.
22:58:23 <abh> lispy: saving typing
22:58:36 <lispy> rrradical: my basic complaint is that they don't add any type safety but they can make code harder to read due to the indirection.
22:59:01 <rrradical> abh: oh, by default it treats the first item with higher precedence?
22:59:12 <abh> when you have type Parser = Config -> Text -> IO (Maybe Result)
22:59:29 <abh> rrradical: yes
23:00:29 <abh> rrradical: also, you shouldnt derive Read but make stringToTime the read implementation
23:00:30 <rrradical> abh: oh cool. that works great
23:00:36 <abh> for symmetry with Show
23:01:31 <abh> rrradical: timeToInteger should be name timeToMinutes 'cause thats what it does
23:02:04 <rrradical> abh: I actually spent a long time looking for info on instancing Read, but couldn't figure out readsPrec
23:03:00 <rrradical> can I just say read = stringToTime ?
23:05:05 <rrradical> "`read' is not a (visible) method of class `Read'"
23:07:02 <abh> ok. i admit i dont know how to do this
23:07:43 <rrradical> lispy: I guess it makes sense to me that if I change the implementation of Minute to something else, I might not have to change all of the Int's to something else. Maybe that's not a great argument though...
23:08:43 <rrradical> abh: haha. well at least it's not just me. I seriously googled for like 30 minutes at least
23:09:04 <abh> better not use read at all
23:09:12 <abh> what are you reading from
23:11:06 <dmj`> rrradical: i'd try readMaybe
23:11:24 <dmj`> > readMaybe "2014-06-07 06:08:45.715125 UTC" :: Maybe UTCTime
23:11:25 <lambdabot>  Not in scope: type constructor or class ‘UTCTime’Not in scope: ‘readMaybe’
23:11:27 * hackagebot snaplet-mongodb-minimalistic 0.0.6.12 - Minimalistic MongoDB Snaplet.  http://hackage.haskell.org/package/snaplet-mongodb-minimalistic-0.0.6.12 (PetrPilar)
23:12:08 <lispy> rrradical: in that case a newtype would be better
23:12:28 <rrradical> lispy: oh ok, makes sense
23:13:26 <rrradical> abh: what's the source of the data? just stdin
23:14:16 <lispy> rrradical: using a type alias here makes it so that you wouldn't have to change the type signatures, ubt if you end up depending on any type class instances you'd still have work to do (possibly even changing the signatures).
23:14:23 <rrradical> dmj`: I think I need a Read instance in order to use readMaybe
23:14:53 <lispy> rrradical: if you use a newtype wrapper then you control precisely which instances get shared and it's a distinct so you can't 'accidentally' compose it with a normal Int.
23:16:10 <rrradical> lispy: ah I see. thanks
23:16:48 <abh> and you can easily upgrade a newtype to a data
23:16:54 <abh> without breaking much
23:23:28 <rrradical> thanks for all your comments. gonna hit the hay now. good night!
23:27:16 <isomorphismes> rwbarton: Gurkenglas nexx enthropy cool thanks
23:29:39 <isomorphismes> Gurkenglas: like area needs to be in square feet, not cubic feet or feet. But it could be in square yards either.
23:33:04 <Gurkenglas> Hmmm. You could make one Applicative per unit type, then find a way to equate Force 2 to Mass Acceleration 2 and Acceleration Mass 2 etc... but I bet the library developers came up with something better than that
23:36:30 * hackagebot handle-like 0.0.0.2 - HandleLike class  http://hackage.haskell.org/package/handle-like-0.0.0.2 (YoshikuniJujo)
23:36:32 * hackagebot equational-reasoning 0.2.0.3 - Proof assistant for Haskell using DataKinds & PolyKinds  http://hackage.haskell.org/package/equational-reasoning-0.2.0.3 (HiromiIshii)
23:41:31 * hackagebot handle-like 0.0.0.3 - HandleLike class  http://hackage.haskell.org/package/handle-like-0.0.0.3 (YoshikuniJujo)
23:45:13 <isomorphismes> Gurkenglas: The GA link seems more like what one wants. Seems it should be done at a "higher level" (ideally)
23:46:02 <isomorphismes> Theoretically this question should apply to "US Dollar" As well
23:46:12 <isomorphismes> just wonder if that's the kind of thing Haskell does for me
23:46:32 * hackagebot monomorphic 0.0.3.2 - Library to convert polymorphic datatypes to/from its monomorphic represetation  http://hackage.haskell.org/package/monomorphic-0.0.3.2 (HiromiIshii)
