00:00:39 <kazagistar> unsafeCoerse readLn :: String -- SEEMS LIKE IT SHOULD WORK AMIRITE?
00:00:43 <CindyLinz> undefined is too long.. I need xxx to replace it.. XD
00:01:01 <kazagistar> cause I heard unsafePerformIO is bad
00:01:15 <tdammers> nah... the "unsafe" part is a decoy
00:02:03 <ninja_code> to make long story short, Haste.JSON.decodeJSON fixed all performance problems
00:02:15 <ninja_code> apparently parsing json is much much faster than read
00:02:28 <tdammers> main = unsafePerformIO . runRWST do { unsafeCoerce (const JavaScript.Undefined) :: PHP } $ undefined undefined
00:02:37 <tdammers> what could possibly go wrong?
00:03:25 <kazagistar> ... hmm, maybe I should just figure out how to to improve hoogle's matching heuristic (since it is open source) instead of just bitching about it
00:03:30 <kazagistar> naw, not as fun
00:04:01 <kazagistar> ninja_code: its probably written in attoparsec is why :P
00:04:24 <ninja_code> kazagistar: do you have stock invested in attoparsec ?
00:04:26 <ninja_code> or did you write attoparsec
00:04:42 <kazagistar> haha no
00:04:48 <tdammers> it's quite simple, really
00:04:52 <tdammers> read works on Strings
00:05:03 <tdammers> which means there's unicode and linked-list overhead *everywhere*
00:05:13 <ninja_code> wtf
00:05:14 <ninja_code> strings are linked list
00:05:14 <tdammers> Aeson uses attoparsec, which works on bytestrings
00:05:15 <ninja_code> where each node = a single char ?
00:05:18 <tdammers> yes
00:05:30 <kazagistar> actually, its written in C, because it is using the browser json parse when possible, apparently
00:05:31 <tdammers> a single *unicode* char, that is
00:05:47 <tdammers> which means 32 bits
00:06:01 <ninja_code> is this becuase haskell was beaint erlang on benchmarks
00:06:09 <ninja_code> so the haskell devs were like, well, to be fair, we should make strings lists of chars ?
00:06:14 <tdammers> no
00:06:21 <tdammers> it's bad, but not as bad as it sounds
00:06:30 <tdammers> String is a *lazy* list of characters
00:06:43 <arw> ninja_code: its because String = [Char] is actually very nice to program for.
00:07:07 <ninja_code> al right
00:07:12 <ninja_code> because a list of chars is too fast
00:07:13 <kazagistar> ninja_code: the devs provided Text for when you actually want performant strings and dont need the same lazyness
00:07:20 <ninja_code> so let's make it a list of functions which generates the chars
00:07:35 <arw> ninja_code: one could perhaps argue for a very special case in the compiler, but that would be ugly. if performance is necessary, there are other types like ByteString
00:07:45 <tdammers> as long as you just iterate over it once, it boils down to a loop at the machine level, and you just have one character and a thunk for the rest of the string in memory
00:09:04 <zRecursive> magic
00:09:19 <kazagistar> :t ['a','c'..'z']
00:09:20 <lambdabot> [Char]
00:09:22 <tdammers> anyway, there are several string-like types, and for all but the most trivial textbook cases, you're expected to pick the most appropriate one
00:09:32 <kazagistar> > ['a','c'..'z']
00:09:33 <lambdabot>  "acegikmoqsuwy"
00:11:01 <kazagistar> > 'a':'b':[] == "ab"
00:11:02 <lambdabot>  True
00:12:14 <zRecursive> :t (\\)
00:12:15 <lambdabot> Eq a => [a] -> [a] -> [a]
00:12:35 <kazagistar> :t pack "test"
00:12:36 <lambdabot>     Not in scope: ‘pack’
00:12:36 <lambdabot>     Perhaps you meant one of these:
00:12:36 <lambdabot>       ‘BS.pack’ (imported from Data.ByteString),
00:12:40 <kazagistar> ah
00:14:05 <kazagistar> :t (S.\\)
00:14:06 <lambdabot> Ord a => S.Set a -> S.Set a -> S.Set a
00:14:16 <kazagistar> zRecursive: ^^
00:15:08 <zRecursive> @hoogle S.Set
00:15:08 <lambdabot> Data.Set module Data.Set
00:15:09 <lambdabot> Data.Set data Set a
00:15:09 <lambdabot> System.Posix.Files.ByteString SetOwnerAndGroupIsRestricted :: PathVar
00:15:12 <kazagistar> infix set difference
00:15:26 * hackagebot cabal-install 1.20.0.3 - The command-line interface for Cabal and Hackage.  http://hackage.haskell.org/package/cabal-install-1.20.0.3 (JohanTibell)
00:15:45 <sgronblo> So could someone enlighten me on how Show is kind of like a serializable that you are not supposed to use for serialization?
00:16:27 <dsturnbull> sgronblo: you can't encode what type the string represents
00:16:34 <kazagistar> sgronblo: it is meant for debugging
00:17:10 <dp_wiz> hackagebot: > No changelog available -- grrr...
00:17:26 <sgronblo> kazagistar: but somebody here (i think) was also saying it was supposed to be formatted in a way that you can even read it back into a value?
00:17:47 <gamegoblin> Is there a way to make a function of type a -> IO b that basically works like “If a is showable, print it, otherwise, print ‘not showable’ “ ?
00:19:58 <kazagistar> sgronblo: as long as you import the function that would do so unqualified
00:20:05 <gamegoblin> sgronblo: Consider serializing the integer 2,000,000,000 via Show. It takes 10*8 = 80 bits (8 bits per ascii character, 10 characters). This number could be represented as an Int in 32 bits. Using show is a waste of space, and deserializing with `read` or even [atto]parsec is slow.
00:21:08 <MP2E> hmm, I think I may have gotten myself stuck in cabal hell :V
00:21:19 <gamegoblin> MP2E: Throw your computer out the window now
00:21:25 <gamegoblin> MP2E: Just start from scratch
00:21:28 <MP2E> http://pastebin.com/NJiq7jec
00:21:32 <tdammers> right... I think I know why it's not working
00:21:33 <MP2E> and lol :P
00:21:52 <tdammers> apparently, manipulating the right tables instead of the wrong ones makes all the difference
00:22:00 <kazagistar> show $ unions [M.singleton 1 "bob", M.singleton 2 "fred]
00:22:08 <kazagistar> > show $ unions [M.singleton 1 "bob", M.singleton 2 "fred]
00:22:09 <lambdabot>  <hint>:1:57:
00:22:09 <lambdabot>      lexical error in string/character literal at end of input
00:22:14 <gamegoblin> tdammers: I don’t believe you.
00:22:24 <kazagistar> show $ unions [M.singleton 1 "bob", M.singleton 2 "fred"]
00:22:31 <kazagistar> ARG
00:22:35 <kazagistar> > show $ unions [M.singleton 1 "bob", M.singleton 2 "fred"]
00:22:36 <lambdabot>  Not in scope: ‘unions’
00:22:36 <lambdabot>  Perhaps you meant one of these:
00:22:36 <lambdabot>    ‘IM.unions’ (imported from Data.IntMap),
00:22:36 <lambdabot>    ‘M.unions’ (imported from Data.Map),
00:22:36 <lambdabot>    ‘S.unions’ (imported from Data.Set)
00:22:45 <kazagistar> I suck at this demo thing
00:22:47 <tdammers> gamegoblin: yeah, it was a long shot really, but I tried anyway
00:22:55 <kazagistar> > show $ M.unions [M.singleton 1 "bob", M.singleton 2 "fred"]
00:22:57 <lambdabot>  "fromList [(1,\"bob\"),(2,\"fred\")]"
00:23:22 <tdammers> does lambdabot require the "show"?
00:23:27 <tdammers> > M.singleton
00:23:28 <lambdabot>  No instance for (Data.Typeable.Internal.Typeable a0)
00:23:28 <lambdabot>    arising from a use of ‘M66684946127256369557180.show_M66684946127256369557...
00:23:28 <lambdabot>  The type variable ‘a0’ is ambiguous
00:23:28 <lambdabot>  Note: there are several potential instances:
00:23:28 <lambdabot>    instance Data.Typeable.Internal.Typeable Data.Dynamic.Dynamic
00:23:29 <tdammers> eh
00:23:30 <kazagistar> > fromList [(1,"bob"),(2,"fred")]
00:23:31 <lambdabot>  can't find file: L.hs
00:23:36 <tdammers> > M.singleton (1, "foobar)
00:23:37 <lambdabot>  <hint>:1:25:
00:23:37 <lambdabot>      lexical error in string/character literal at end of input
00:23:41 <tdammers> > M.singleton (1, "foobar")
00:23:42 <tdammers> lol
00:23:42 <lambdabot>  No instance for (Data.Typeable.Internal.Typeable a0)
00:23:42 <lambdabot>    arising from a use of ‘M8489340991555596977226.show_M8489340991555596977226’
00:23:43 <lambdabot>  The type variable ‘a0’ is ambiguous
00:23:43 <lambdabot>  Note: there are several potential instances:
00:23:44 <lambdabot>    instance Data.Typeable.Internal.Typeable Data.Dynamic.Dynamic
00:24:07 <tdammers> > M.singleton (1, "foobar") :: M.Map Int String
00:24:09 <lambdabot>  Couldn't match expected type ‘Data.Map.Base.Map
00:24:09 <lambdabot>                                  GHC.Types.Int GHC.Base.String’
00:24:09 <lambdabot>              with actual type ‘a0
00:24:09 <lambdabot>                                -> Data.Map.Base.Map (t0, [GHC.Types.Char]) a0’
00:24:30 <tdammers> I give up
00:24:44 <tdammers> oh wait
00:24:51 <tdammers> > M.singleton 1 "foobar" :: M.Map Int String
00:24:52 <lambdabot>  fromList [(1,"foobar")]
00:25:10 <kazagistar> how helpful, right?
00:25:11 <tdammers> so hmm, explicit `show` isn't needed, yay
00:25:16 <kazagistar> yeah
00:25:27 * hackagebot dwarf-el 0.2.1 - Parser for DWARF debug format.  http://hackage.haskell.org/package/dwarf-el-0.2.1 (EyalLotem)
00:25:29 * hackagebot dwarfadt 0.3 - High-level wrapper around the dwarf library  http://hackage.haskell.org/package/dwarfadt-0.3 (EyalLotem)
00:25:35 <kazagistar> but this does not quite eval properly:
00:25:40 <kazagistar> > fromList [(1,"foobar")]
00:25:41 <lambdabot>  Not in scope: ‘fromList’
00:25:41 <lambdabot>  Perhaps you meant one of these:
00:25:41 <lambdabot>    ‘IM.fromList’ (imported from Data.IntMap),
00:25:41 <lambdabot>    ‘M.fromList’ (imported from Data.Map),
00:25:41 <lambdabot>    ‘S.fromList’ (imported from Data.Set)
00:25:56 <kazagistar> it cannot identify the type
00:26:14 <kazagistar> because the imports are qualified
00:26:27 <kazagistar> so it is "not quite serialized" in that way
00:27:12 <tdammers> that's a different issue though
00:27:52 <tdammers> the imports *have* to be qualified if you want to have all those modules in scope
00:39:53 <jle`> is there any reason that lens-family doesn't have review
01:13:00 <Kaidelong> does GHC provide any concept of weak references?
01:13:17 <Kaidelong> I ask purely out of curiousity; I don't have an application in mind
01:15:19 <corgifex> http://hackage.haskell.org/package/base-4.7.0.0/docs/System-Mem-Weak.html
01:15:23 <corgifex> @hoogle weak
01:15:24 <lambdabot> System.Mem.Weak module System.Mem.Weak
01:15:24 <lambdabot> System.Mem.Weak data Weak v
01:15:24 <lambdabot> System.Mem.Weak deRefWeak :: Weak v -> IO (Maybe v)
01:41:47 <jle`> @tell Kaidelong I believe that sodium etc. use it to manage their stuff
01:41:47 <lambdabot> Consider it noted.
02:07:55 <georgy2> is there any environment that will show show function signature right after I typed the function name in the source?
02:09:15 <Okasu> georgy2: IIRC haskell-mode can do that to some extent, might be wrong.
02:09:30 <Okasu> (haskell-mode for emacs)
02:09:49 <georgy2> I am using it and I don't see it. perhaps I didn't set it up correctly
02:10:34 <Okasu> georgy2: C-c C-t
02:10:53 <Okasu> When you cursor is on function name.
02:11:36 <georgy2> "ghc-mod not found"
02:12:09 <horsey_> someone assure me that i should really learn haskell
02:12:17 <jle`> georgy2: is ghc-mod installed?
02:12:22 <jle`> horsey_: you should really learn haskell :)
02:12:25 <horsey_> i feel like learning something new, and haskell and functional programming in general feels interesting
02:12:32 <jle`> not just interesting
02:12:32 <Okasu> Yeah, you need to install some dependencies.
02:12:33 <jle`> but useful
02:12:53 <horsey_> i have a very object-oriented background in programming
02:13:03 <jle`> horsey_: that's o k
02:13:06 <horsey_> will i have a hard time settling my problem-solving to this functional mode?
02:13:20 <jle`> you will have a hard time if you try to apply what you know about imperative programming
02:13:28 <horsey_> and furthermore, what kind of stuff do you guys do with haskell?
02:13:34 <tdammers> horsey_: you need to bring a bit of open-mindedness to the table
02:13:36 <jle`> if you forget all of the intuition you carry, then you will have a not-so-hard time
02:13:48 <Okasu> General purpose stuff. :)
02:14:08 <jle`> the main difficulty you will encounter is when your old intuitions lead you to the wrong things
02:14:11 <fxr> horsey_: for me network security stuff...
02:14:21 <jle`> i do scientific computing and game programming
02:14:36 <horsey_> game programming, yuss
02:14:58 <tdammers> horsey_: web applications, mostly, but also compilers, a music notation thing, and some toy stuff
02:15:20 <jle`> i dabble in web too but that just means a blog engine that i go in and edit every couple of months
02:15:25 <jle`> haskell is very good at maintainability
02:15:38 <fxr> jle`: except cabal hell
02:15:39 <jle`> like exceptionally, surprisingly, exceedingly, unexplainably good
02:15:49 <jle`> well, maintaining your actual code ;)
02:15:58 <horsey_> do you use some framework for web dev? i kind of have this thing for creating stuff on my own, and using a framework on my own projects is not fun
02:16:08 <jle`> horsey_: what is your web background?
02:16:10 <fxr> I am using snap-server
02:16:22 <jle`> i use scotty, which is very minimal
02:16:24 <horsey_> i've whipped a few frameworks of my own in php
02:16:34 <jle`> it mostly just provides a routing dsl
02:16:39 <horsey_> and of course used a lot of javascript on the client side
02:16:39 <jle`> but the rest is up to you
02:16:55 <jle`> haskell compiles to javascript too :)
02:17:26 <jle`> with scotty you basically just set up your routes as functions that return web pages
02:17:35 <jle`> and off ya go
02:17:43 <fxr> I am using haste-compiler for the frontend stuff
02:17:53 <horsey_> this sounds all so promising
02:18:05 <horsey_> i recently started learn you a haskell for great good
02:18:07 <horsey_> can you recommend it?
02:18:13 <jle`> it was my own path
02:18:16 <jle`> some people recommend others
02:18:22 <tdammers> horsey_: the haskell-to-javascript route is kind of rough still - it works, but it's not easy
02:18:28 <tdammers> lyah is good
02:18:34 <jle`> https://github.com/bitemyapp/learnhaskell -- horsey_
02:18:56 <tdammers> @where rwh
02:18:56 <lambdabot> http://www.realworldhaskell.org/blog/ http://book.realworldhaskell.org/read/
02:19:02 <tdammers> that's what I used
02:19:05 <tdammers> Real World Haskell
02:19:09 <tdammers> a bit dated, I think
02:19:15 <tdammers> but it focuses on real-world programming
02:19:18 <tdammers> (duh)
02:19:32 <tdammers> you might like it, coming from a pragmatic background in programming
02:19:41 <jle`> hm where's that SO post about the aspects about rwh that you should watch out for for being dated
02:19:41 <tdammers> also, scotty, yay!
02:19:41 <georgy2> isn't realworldhaskell is a bit outdated?
02:19:42 <tdammers> love it
02:19:58 <jle`> here ya go http://stackoverflow.com/a/23733494/1651941
02:20:21 <jle`> i wouldn't recommend it myself but a lot of people like it
02:20:27 <horsey_> thanks, bookmarked those all
02:20:37 <jle`> i like Simon Marlow's Parallel and Concurrent Programming in Haskell after LYAH
02:21:00 <jle`> it's about parallel and concurrent programming specifically, but...more importantly it is a well written book about how to approach a given real world problem in haskell
02:21:03 <horsey_> one more question about web dev (actually more of the backend stuff)
02:21:10 <jle`> the methodology and approaches and stuff
02:21:11 <georgy2> reading LYAH first is a good approach IMO
02:21:18 <jle`> and what idiomatic code looks like
02:21:28 <horsey_> is it possible for me to build a backend application in haskell, that i use through ajax in javascript?
02:21:45 <horsey_> or am i climbing the tree completely ass-backwards this way?
02:21:46 <jle`> but yeah i've heard great things about that byorgey course http://www.seas.upenn.edu/~cis194/lectures.html
02:21:51 <jle`> horsey_: that's possible
02:22:19 <jle`> horsey_: it's how they do it in the ruby, python world, etc.
02:22:45 <jle`> i started out that way but i mostly use compile-to-javascript languages now
02:22:49 <fxr> horsey_: you can do it with type-safety with haskell
02:22:54 <jle`> much safer
02:22:57 <jle`> less bugs
02:23:00 <jle`> more maintainable
02:23:43 <horsey_> ok, i'm 95% certain i'll use all my free time this weekend on reading more on haskell, and actually doing stuff with it
02:23:44 <jle`> you'll find those are among the best things that haskell offers
02:23:52 <jle`> safety and maintainability
02:24:00 <jle`> and performance of course, if you are coming from php
02:24:02 <jle`> heh
02:24:09 <horsey_> but i just need to let go of my imperative / oop mindset
02:24:22 <jle`> horsey_: it'll get beaten out of you with time ;)
02:24:24 <horsey_> i'll of course be doing imperative / oop a lot at my job, but..
02:24:30 <horsey_> haha i hope not completely
02:24:35 <jle`> fwiw i don't have too much trouble switching back and forth
02:24:43 <jle`> most of my colleagues use C++ and fortran and python, etc.
02:24:49 <jle`> and i don't have problems jumping back in
02:24:53 <jle`> ...too much problems.
02:25:09 <jle`> *dont have too much problems
02:25:16 <jle`> most of my own personal research and work is in haskell
02:25:46 <horsey_> is this something "math-oriented", your research?
02:26:10 <jle`> it's along some sort of intersection between applied math and physics/engineering
02:26:26 <horsey_> cool
02:26:55 <horsey_> i'm one of those types who would really like to be better at math in general, but just can't find the time from all more concrete stuff.. like game programming
02:26:57 <jle`> yeah i have fun :)  haskell is good for mathsy stuff
02:27:56 <jle`> horsey_: yeah time is a big deal
02:28:09 <jle`> :/
02:28:12 <jle`> if only we all had unlimited time
02:28:28 <horsey_> or learned faster you know
02:28:36 <horsey_> but i'd like to thank you all that chimed in
02:28:37 <jle`> nah
02:28:41 <jle`> the journey is half the fun ;)
02:28:48 <horsey_> well that's true too
02:29:04 <jle`> if you ever get frustrated while learning haskell
02:29:08 <jle`> here is what always helped me
02:29:27 <jle`> you will undoubtedly be comparing your adeptness at haskell with your adeptness at x language, or x paradigm
02:29:36 <jle`> but then consider how long it took you to get that good at imperative programming
02:29:41 <jle`> to where you are now
02:29:46 <jle`> five years maybe?
02:29:56 <horsey_> something like this maybe
02:30:05 <jle`> you might get frustrated a month down the line
02:30:19 <jle`> instead of comparing how good you are at haskell to how good you are at imperative progrmaming
02:30:28 <jle`> (which is a bit of an unfair comparison ;)  1 month vs 5 years)
02:30:38 <jle`> compare it to when you had been programming imperatively for 1 month
02:30:54 <jle`> and you'll find you'll actually be pretty well off
02:31:06 <horsey_> i hope so
02:31:13 <horsey_> i try not to be too harsh on myself in general
02:31:24 <horsey_> too much stress inhibits learning after all!
02:31:32 <jle`> good strategy :)
02:31:37 <jle`> #haskell is always here for any help
02:31:43 <jle`> there's also #haskell-beginners
02:31:52 <jle`> but you can ask beginner questions here too
02:32:03 <jle`> and #haskell-game if you ever get into game programming
02:32:22 <horsey_> cool
02:32:36 <horsey_> i think the beginners channel will be best for me :D but i try not to ask too much
02:32:43 <horsey_> thank you
02:32:47 <horsey_> you've been extremely helpful
02:33:01 <horsey_> and now, i gotta hurry back to php
02:33:04 <jle`> no problem!  glad to help
02:33:08 <jle`> oh yeah there's also the haskell reddit
02:33:11 <jle`> haha. have fun back in php land
02:33:13 <jle`> :)
02:33:27 <horsey_> :D i can appreciate the humour
02:33:31 <horsey_> ok, take care
02:33:33 <horsey_> bye
02:34:07 <georgy2> since beginners questions are welcome in here what is the purpose of #haskell-beginners
02:35:05 <tdammers> jle`: PHP is plenty fast... if you can accept code that is horribly and utterly incorrect
02:35:24 <frerich> georgy2: I have no idea, IMHO the Haskell community in general (and #haskell in particular) is very friendly towards beginners asking "silly" questions. So asking anything Haskell'ish in here is just fine.
02:36:13 <jle`> georgy2: i think there was some mini drama a couple months back about beginner questions being lost in the noise during the busier hours
02:36:51 <jle`> i don't really see it happening that often, but enough people perceived it to be true that they decided to open up #haskell-beginner together
02:36:59 <jle`> bitemyapp can correct me if this was not the real story
02:37:19 <jle`> i think he is from the states though so he probably won't answer any time soon
02:39:06 <tero-> are there enough non-beginners in #haskell-beginner to answer the questions?
02:39:38 <tdammers> seeing how I had never heard of -beginner, it could probably use some PR
02:40:01 <jle`> i probably just spend way too much time here and on twitter
02:40:02 <jle`> >_>
02:41:06 <jle`> and i should probably be off now, it's almost 3 am.  night all
02:42:43 <jonashw> hmmm
02:58:04 <mmmm> Are there any tools to take an XML file and turn it into a haskell datastructure in a sensible way?
03:00:11 <simon> Did you see http://www.haskell.org/haskellwiki/HXT/Conversion_of_Haskell_data_from/to_XML ?
03:03:48 <mmmm> I want to have to avoid dropping into IO to read the file so want something which generates a static hs file
03:05:30 <simon> that was actually my impression. I thought it was on that page, but apparently not.
03:06:39 <quchen> I guess what you want is a preprocessor that converts XML to Haskell then.
03:06:41 <simon> mmmm, it sounds like you want something like an XML Type Provider (F# terminology)
03:07:05 <quchen> You should be able to do this with TH, or you can write the program yourself and chain it before compilation.
03:07:35 <simon> quchen, the question is, has anyone done this with Template Haskell already.
03:09:26 <quchen> It's fairly easy, actually. Write your XML parser, unsafePerformIO it, and then splice it into your actual code.
03:09:38 <quchen> Kind of like this: https://github.com/quchen/articles/blob/master/useful_techniques.md#poor-mans-supercompiler
03:09:43 <quchen> But with IO involved.
03:10:43 * hackagebot hooks-dir 0.1.0.0 - run executables in a directory as hooks  http://hackage.haskell.org/package/hooks-dir-0.1.0.0 (ibotty)
03:11:42 <quchen> Actually, there is no need to unsafePerformIO: TH has its own "runIO" function.
03:13:11 <zwer_t> for running IO at compile time?
03:15:43 <quchen> Yes
03:21:44 <kazagistar> muhahahaha
03:28:06 <jarold> in swift one can shorten lambda expression by referencing arguments by their position. ($1 > $1). do you think this would be useful in haskell? obviously for this example haskell is much nicer, just (>), but for more complex examples it could be an improvement over a lambda syntax
03:28:30 <jarold> ($1 > $2), even
03:29:20 <hpc> how do you write const in that notation?
03:30:16 <jle`> i can't imagine a "complex" situation where a lambda would be less expressive
03:30:21 <jarold> I don't know if just ($2) would work, I don't have a swift compiler. but no reason why ($2) couldn't be made to work
03:30:40 <hpc> that would not be const, it would be flip const
03:31:10 <jle`> lambdas are also less common in haskell, where compositional reasoning is often preferred over pointful rasoning
03:31:32 <quchen> Those two aren't mutually exclusive.
03:31:36 <jarold> jle it wouldn't be more expressive but more concise in some cases
03:31:37 <vanila> jarold, how do you delimit the bindings
03:32:06 <Yuu_chan> @google de bruijn notation
03:32:07 <pjdelport> jarold: Between operator slices and combinators, there's probably very little need for something like that.
03:32:08 <lambdabot> http://en.wikipedia.org/wiki/De_Bruijn_notation
03:32:08 <lambdabot> Title: De Bruijn notation - Wikipedia, the free encyclopedia
03:32:14 <quchen> FWIW Mathematica has similar syntax, and it's pretty cool to write, and pretty awful to read once you're using more than 2 variables.
03:32:39 <jle`> quchen: not mutually exclusive yes...perhaps i should have said something like compositional reasoning is available and a part of culture for many situations to augment pointful reasoning.
03:32:46 <jle`> jarold: in what cases?
03:33:53 <jle`> if you get complex enough that you can't use function composition, at that point i think having the extra "->" of lambda syntax doesn't really make too much of a difference
03:35:23 <jle`> hm but i guess it might be concise for something like (\x y -> g (f x y)) to be written as (g . f $1) instead of (\x -> g . f x).
03:35:29 <jarold> jle here is one off the top of my head. (\x y -> foo y z x)  (foo $2 z $1)
03:35:50 <jle`> ah for the weird flips
03:36:18 <jarold> I don't think named variables add anything to the readability there, but they add noise
03:36:18 <vanila> jarold, how does it know where $1 and $2 are bound
03:37:01 <quchen> Simple integration using "lambda placeholder" syntax: If[Abs[#3 - #2] <= #4, (#3 - #2) #1[(#2 + #3)/2], #0[#1, #2, (#2 + #3)/2, #4] + #0[#1, (#2 + #3)/2, #3, #4]] &;
03:37:24 <jle`> ah mathematica
03:37:24 <quchen> In other words, sometimes it's better to have names in lambdas. Very rarely is it better to not have them.
03:37:54 <vanila> I don't think you've thought this idea through
03:38:20 <quchen> Anonymous functions are fine, anonmyous function arguments are usually awkward, except for simple cases like "1 < 3", which are just as readable with lambdas, and occur quite rarely.
03:38:23 <jarold> vanila I don't know exact semantics in swift, or if I am even getting the syntax right. but syntax in swift does not really matter. I think clojure has something similar too
03:39:00 <jle`> there was a haskell implementaiton that was on the reddit not too ong ago i think
03:39:11 <vanila> jarold, you need a way to delimit bindings
03:39:27 <pjdelport> jle`:  (\x y -> g (f x y))  ===  let (.:) = (.).(.) in g .: f
03:39:47 <pjdelport> http://hackage.haskell.org/package/composition-1.0.1.0/docs/Data-Composition.html defines a number of these
03:41:03 <pjdelport> concatMap = concat .: map
03:41:14 <jle`> pjdelport: yeah, but that's not quite an ideal solution either.  introducing ad-hoc operators from a library on hackage
03:41:28 <jle`> that aren't even universally used
03:41:44 <pjdelport> jle`: Well, they're trivial enough to define inline at the top of your module or somewhere.
03:41:59 <pjdelport> if you end up needing them a few times
03:42:44 <jle`> still, non standard ad hoc operators :/
03:42:46 <pjdelport> It would be really nice if at least (.:) makes it to the Prelude or a standard utility library, though.
03:42:53 <jle`> if it was in Prelude i would not mind
03:43:07 <pjdelport> jle`: Eh, (.) is was non standard and ad hoc until it gained common currency. :)
03:43:35 <jle`> well, it's standard in haskell, de facto and "de jure" :P
03:44:03 <jle`> at least today
03:44:22 <jle`> if 80% of people reading my code will take a moment to scratch their head when they see (.:)
03:44:33 <jle`> then why not just write the whole thing, and lose none of the expressibility
03:44:38 <jle`> and make 100% of people able to read it without pausing
03:44:39 <vanila> jle`, (.:) was popularized by conal
03:45:03 <pjdelport> jle`: Hence more evangelization needed!
03:45:13 <jle`> perhaps i am a part of the problem :)
03:45:15 <jle`> heh
03:45:40 <jle`> maybe i need to be the change i want to see in the world
03:45:53 * jle` dreams
03:45:59 <pjdelport> dot = (.).(.) was also a popular spelling for a while, i think
03:46:44 <pjdelport> jle`: Anyway, the nice thing is that they're very memorable, once you know the pattern: you just compose (.) together up to the number of arguments you want
03:46:57 <pjdelport> so (.).(.) for two, (.).(.).(.) for three, etc.
03:48:00 <frerich> Funky, I never noticed that.
03:48:37 <pjdelport> I've only ever used (.).(.) myself, though.
03:49:41 <jarold> which one is more readable? ignore for a moment that we could use flip, we are comparing two lambda syntaxes.  (f $2 $1)  (\x y -> f y x). I think that explicit positional arguments convey the meaning better than having to manually parse positions by the name of the arguments
03:50:00 <jarold> it is more concise too
03:50:40 <hpc> jarold: but it's not totally expressive; you can't write const
03:50:41 <jle`> "ignore for a moment that we could use flip"
03:50:50 <jle`> well... the whole point against it is that we can use higher order functions
03:50:52 <jle`> instead of lambdas
03:50:53 <hpc> and we would just use flip
03:51:09 <jle`> haskell lets us avoid lambdas completely in many cases by using higher order functions and function combinators
03:51:29 <jarold> jle` that is not a point against it. you would use alternative syntax when using higher order functions gets too messy and you are forced to use a lambda
03:52:08 <jle`> not a point against it, but it means that you can't use an example that is trivially replaceable with a higher order function ;)
03:52:23 <jle`> your \x y -> foo y z x was a nice point i think
03:52:40 <jle`> there are the (??) operators
03:52:44 <quchen> @pl \a b c -> [a,b,c]
03:52:45 <lambdabot> (. ((. return) . (:))) . (.) . (:)
03:52:46 <jle`> i wonder if they help with that
03:52:52 <quchen> Here's an example of where pointful is useful.
03:53:09 <jle`> that's a good example
03:53:18 <frerich> I think  the response by lambdabot is fairly "pointful", too.
03:53:30 <jle`> until we get list sections
03:53:38 <jle`> [,,] :: a -> a -> a -> [a]
03:53:41 <jle`> ;D
03:53:45 <quchen> We don't even have standard tuple sections yet.
03:54:14 <Trollinator> what do you think is nicer, flip foo bar or (`foo` bar)?
03:54:29 <pavonia> the latter
03:54:35 <Trollinator> why?
03:54:51 <pavonia> Because I don't like flip
03:54:57 <hpc> what is foo?
03:55:05 <Trollinator> a placeholder
03:55:27 <hpc> it matters what it is though
03:55:34 <quchen> > (`subtract` 1) 3 -- ;-)
03:55:35 <lambdabot>  -2
03:55:37 <pjdelport> Trollinator: Assuming you know operator sections, it's much easier to see how (`foo` bar) x expands to (x `foo` bar).
03:55:41 <hpc> if it's something like (/), definitely the latter because the infix form makes sense
03:56:00 <hpc> if it's something like readsPrec, definitely the former
03:56:14 <hpc> because i definitely don't want to try and read that in an infix context
03:56:17 <frerich> Trollinator: I'd vote for the latter. In fact, many functions are specifically written to be used like that, e.g. "isPrefixOf"
03:56:30 <quchen> `runState`
03:56:34 <pjdelport> hpc: Functions, too! e.g. (`map` xs)
03:56:35 <hpc> really, the important part of that is not flip vs not flip, but `` vs not ``
03:56:54 <pavonia> Good point, hpc
03:57:15 <Trollinator> hpc: i agree
03:57:26 <hpc> :t readsPrec -- have fun reading that with ``
03:57:27 <lambdabot> Read a => Int -> ReadS a
03:58:11 <augur_> three layers of monadic effects has led me to write
03:58:13 <augur_> fmap (fmap sequence_) . fmap sequence . sequence $ map (commandToIO sys wm) cmds
03:58:16 <pavonia> :t flip readsPrec
03:58:17 <lambdabot> Read a => String -> Int -> [(a, String)]
03:58:21 <augur_> i should compress this a bit :x
03:58:37 <Trollinator> I have no idea what that means.
03:58:55 <hpc> Trollinator: it reads with precedence (think, fixity declarations)
03:58:55 <frerich> Sometimes an alias can make infix usage a lot more viable though, e.g. if you have 'times = replicate' then you can write "3 `times` 'a'" :-)
03:59:03 <hpc> it's used to add parenthesization
03:59:30 <hpc> :t (`flip` ?x)
03:59:31 <lambdabot> (?x::b) => (a -> b -> c) -> a -> c
03:59:32 <pavonia> augur_: You can join the two fmaps
03:59:39 <Trollinator> frankly, I have a feeling that monad stacks/transformers are quite horrible.
03:59:40 <augur_> pavonia: yeah, i just did that
04:00:05 <pavonia> :t sequence
04:00:06 <lambdabot> Monad m => [m a] -> m [a]
04:00:08 <Trollinator> I think we need more language support to control effects.
04:00:37 <augur_> Trollinator: i probably just need to define a single monad for this stack of things
04:00:44 <jle`> augur_: mapM
04:00:49 <augur_> jle`: ?
04:00:55 <jle`> you use sequence . map f
04:00:59 <jle`> which is just mapM f
04:01:06 <jle`> unless i missed something
04:01:09 <Trollinator> augur_: but I personally don't *want* to do that…
04:01:10 <zwer_t> it is
04:01:21 <augur_> jle`: ah well. i prefer to keep it this way conceptually
04:01:22 <augur_> for now
04:01:23 <zwer_t> @src mapM
04:01:23 <lambdabot> mapM f as = sequence (map f as)
04:01:32 <augur_> :t mapM
04:01:33 <lambdabot> Monad m => (a -> m b) -> [a] -> m [b]
04:01:47 <ion> augur: What is the concrete type of your expression to the left from $?
04:02:09 <augur_> ion: you mean of   fmap (fmap sequence_) . fmap sequence . sequence   ?
04:02:09 <ion> (I’m just curious)
04:02:15 <jle`> augur_: recently i have been fond of doing
04:02:21 <jle`>   (fmap . fmap) sequence
04:02:28 <jle`> . fmap      sequence
04:02:29 <augur_> ion: good question!
04:02:31 <jle`> .            sequence
04:02:31 <augur_> :t fmap (fmap sequence_) . fmap sequence . sequence
04:02:32 <lambdabot> (Functor f1, Functor f, Monad m, Monad f1, Monad f) => [f (f1 (m a))] -> f (f1 (m ()))
04:02:33 <Trollinator> The problem is that it makes haskell look bad. People look at these hoops they have to jump through, and they don't see the benefits of being purely functional.
04:02:34 <jle`> to get a nice pyramid
04:02:38 <jle`> pyramid effect
04:03:00 <augur_> ion: so its   [IO (Result (WorldState ()))] -> IO (Result (WorldState ()))
04:03:13 <augur_> ion: basically im just sequencing down through three layers of effects
04:03:15 <jle`> i don't like fmap (fmap f . g) that much
04:03:20 <ion> augur: Okay
04:03:25 <augur_> like i said, i can probably just create a new monad for that
04:04:20 <zwer_t> jarold you can't write const with that syntax, so it can't be a replacement for lambda
04:05:47 * hackagebot cpphs 1.18.5 - A liberalised re-implementation of cpp, the C pre-processor.  http://hackage.haskell.org/package/cpphs-1.18.5 (MalcolmWallace)
04:06:10 <jarold> sure, but it is not meant to replace lambda. languages that have such a syntax also have plain lambda with named arguments
04:06:16 <augur_> ion: im sure all of my code is ugly :x
04:07:00 <augur_> ion: i have an expression type but i dont use a monadic approach to substitution, which no doubt is why i have enormous case statements
04:07:07 <augur_> at least in some places
04:07:16 <augur_> but thats ok! its clearer for me, which is important
04:08:43 <Vay21>  Hi! I give you some videos. I hope you like! http://bit.ly/VqlcSh
04:10:14 <systemfault> nobody is stupid enough to open that link kthx
04:11:26 <ion> Spam bots also don’t read responses.
04:11:41 <pjdelport> augur_: How about something like this?
04:11:55 <pjdelport> _3level f g h = (fmap . fmap) h . fmap g . f
04:12:07 <augur_> pjdelport: haha :)
04:12:18 <pjdelport> sequence3_ = _3level sequence sequence sequence_
04:12:20 <augur_> better to define sequence3, no?
04:12:30 <augur_> just raw, without that intermediate thing, i mean
04:12:55 <pjdelport> augur_: Well, this way you can easily have sequence3 = _3level sequence sequence sequence too
04:13:20 <Maxdamantus> > [f g h, (fmap . fmap) h . fmap g . f]
04:13:22 <lambdabot>  Could not deduce (GHC.Show.Show a1)
04:13:22 <lambdabot>    arising from a use of ‘Debug.SimpleReflect.Vars.f’
04:13:22 <lambdabot>  from the context (Debug.SimpleReflect.Expr.FromExpr (f1 a2),
04:13:22 <lambdabot>                    Debug.SimpleReflect.Expr.FromExpr (f (f1 b)),
04:13:22 <lambdabot>                    Debug.SimpleReflect.Expr.FromExpr (f a3),
04:13:55 <jpf> what is "~>" (without the quotes). This is the first time that I've seen it, i.e.: http://www.stephendiehl.com/posts/monads.html ?
04:14:10 <pjdelport> jpf: Arrow syntax?
04:14:33 <jle`> jpf: it's just an infix operator
04:14:37 <jle`> he is using it at the type level
04:15:01 <jle`> like saying (~>) a b c = c a b
04:15:38 <jle`> like how you can say let x ~> y = x + (y^2) at the data level...if that's a valid operator
04:15:43 <jle`> > let x ~> y = x + y^2
04:15:44 <lambdabot>  not an expression: ‘let x ~> y = x + y^2’
04:15:51 <jle`> > let x ~> y = x + y^2 in 1 ~> 2
04:15:52 <lambdabot>  5
04:16:20 <knapper_tech> Need some heist docs without snap
04:16:40 <jpf> so it applies the last two types as an argument to the first type? okay
04:17:43 <jle`> yeah
04:18:04 <jle`> so id :: (a ~> a) c means id :: c a a
04:18:10 <Javran> hi, I want to find articles that summarize the failure of OOP, do you have some?
04:19:10 <abstract-alf> does mapM essentially expand to a bunch of chained >>= calls?
04:19:28 <hpc> @src mapM
04:19:28 <lambdabot> mapM f as = sequence (map f as)
04:19:32 <hpc> @src sequence
04:19:32 <lambdabot> sequence []     = return []
04:19:32 <lambdabot> sequence (x:xs) = do v <- x; vs <- sequence xs; return (v:vs)
04:19:32 <lambdabot> -- OR: sequence = foldr (liftM2 (:)) (return [])
04:19:43 <hpc> yes
04:19:52 <abstract-alf> woh, it's super neat that you can pull up the source like that
04:20:04 <hpc> it doesn't work for everything
04:20:13 <hpc> and it's usually not what the actual source is
04:21:17 <abstract-alf> :t liftM2
04:21:18 <lambdabot> Monad m => (a1 -> a2 -> r) -> m a1 -> m a2 -> m r
04:21:22 <abstract-alf> :t (>>=)
04:21:23 <lambdabot> Monad m => m a -> (a -> m b) -> m b
04:21:28 <phaazon> yes !
04:21:31 <phaazon> http://hackage.haskell.org/package/monad-journal-0.2.1.2/docs/Control-Monad-Journal-Class.html
04:21:36 <phaazon> documentation is now there!
04:21:37 <phaazon> :)
04:22:43 <abstract-alf> man, that sequence declaration is really concise
04:23:17 <jle`> mapM_ f [x,y,z] is void (f x >> f y >> f z), if that is kinda what you are asking
04:23:18 <pjdelport> abstract-alf: Are you familiar with how foldr (:) [] is the identity fold?
04:23:45 <pjdelport> abstract-alf: And how liftM2 and return are basically just the 2-ary and nullary lifting operators?
04:24:15 <abstract-alf> pjdelport, ok, I can see that
04:24:39 <pjdelport> abstract-alf: So in a very real sense foldr (liftM2 (:)) (return []) is just the identity fold lifted into the monad.
04:24:48 <abstract-alf> so return [] to start with a minimum-context zero value
04:25:15 <abstract-alf> and then foldr (liftM2 (:)) to pull every other value into the context too
04:25:39 <abstract-alf> wild stuff
04:26:01 <pjdelport> abstract-alf: So just like foldr (:) [] picks apart the individual "atoms" of the list and then reassembles them precisely in-place,
04:26:05 <zebr> hi all. i'm trying to think of a more abstract description for a haskell function so that my maths isn't littered with function calls and cons operators and all that. what i have is `takeWhile (/= x) ys`, where x may occur in ys multiple times. my first thought was a transitive relation so i can just say 'forall w. w < x' but that doesn't work for repeats.
04:26:18 <zebr> (sorry if this is a bit of a weird question. :p)
04:26:26 <pjdelport> foldr (liftM2 (:)) (return []) does the same thing, but picks it apart, lifts the parts into the monad, and then reassembles them precisely in-place.
04:26:33 <jle`> abstract-alf: sequence_ can be foldr (>>) (return ())
04:26:34 <pjdelport> :t sequence
04:26:35 <zebr> anyone know what i could use to describe that kind of function? it's monotonic, at least.
04:26:35 <lambdabot> Monad m => [m a] -> m [a]
04:26:46 <pjdelport> So that makes it easier to see what the type signature is doing, too.
04:27:17 <abstract-alf> yes, indeed
04:27:19 <abstract-alf> thanks
04:37:06 <zebr> i suppose if you have a relation that is neither symmetric nor antisymmetric, that might work
04:41:53 <pjdelport> zebr: I'm not sure what exactly you're asking.
04:44:21 <pjdelport> Are you looking for a replacement for takeWhile?
04:45:41 <zebr> pjdelport: a purer mathematical definition of it. i think i've found one using preorders. i think.
04:46:05 <tdammers> "purer"? srsly?
04:46:37 <frerich> @src takeWhile
04:46:37 <lambdabot> takeWhile _ []                 =  []
04:46:37 <lambdabot> takeWhile p (x:xs) | p x       =  x : takeWhile p xs
04:46:37 <lambdabot>                    | otherwise =  []
04:47:10 <pjdelport> zebr: Ah, so you mean "forall w. w < x" abstractly where < means something like "occurs before x" in that list?
04:47:53 <zebr> tdammers: in the sense that i don't want to, in an abstract description of an algorithm, define linked lists and takeWhile and all that if i don't have to
04:47:57 <zebr> pjdelport: yeah
04:48:59 <frerich> zebr: I'm not a mathematician, but would expressing it as a list comprehension do? E.g. "takeWhile p xs would be "[x | x <- xs, p x]"
04:49:24 <frerich> Except, that's not the same thing...
04:49:36 <zebr> yeah, not quite
04:49:55 <pjdelport> zebr: Well, since < is already defined in terms of the whole list, can you say something like "forall w. x ∉ successors(w)" ?
04:50:00 <zebr> right now i have { y | x \ngeq y \geq x } where \geq is a preorder. so you have something that is before an x but not after an x
04:51:25 <pjdelport> err, x ∉ predessecors(w), even
04:51:56 <pjdelport> zebr: If that's what the preorder relation means, they're probably the same thing.
04:52:24 <pjdelport> zebr: You probably only need x \ngeq y, though, to have the same semantics as takeWhile?
04:52:30 <zebr> pjdelport: ahh, you're right - you don't need to specify that it's before an x. so you can just say { y | x \ngeq y ].
04:52:33 <zebr> yeah :) thanks a lot.
04:53:45 <pjdelport> "predecessors". Man, my typing.
05:05:14 <knapper_tech> what's a fast way to find out where names came from in example code?
05:05:44 <michaelt> fpcomplete.com/hoogle
05:07:03 <knapper_tech> :: Splice Application
05:09:35 <michaelt> knapper_tech: hm, there are a few Splice types around..., is this a snap module?
05:09:51 <knapper_tech> snap's heist
05:09:58 <knapper_tech> heist's splice
05:11:59 <michaelt> I see, 'Application' then is probably not a library type, but part of the site being constructed
05:12:30 <simon> knapper_tech, sometimes external libraries are not indexed on hoogle. then you can often find them on hayoo!: http://holumbus.fh-wedel.de/hayoo/hayoo.html
05:13:28 <knapper_tech> type Splice n = HeistT n n Template
05:14:14 <knapper_tech> hahaha  damnit.
05:25:49 <systemfault> Haskell noob here, what editor do you guys use to write it? I thought of emacs but I was wondering what package to use.
05:26:07 <Taneb> I use emacs with haskell-mode and ghc-mod
05:26:25 <Trollinator> There is an editor called Yi
05:26:30 <Trollinator> and there's leksah
05:26:48 <Trollinator> I don't haven't used either.
05:26:54 <Trollinator> -don't
05:27:09 <simon> systemfault, I switched from Vim to Emacs when I started writing Haskell. I use both editors today, but mainly Emacs for writing Haskell.
05:27:57 <systemfault> Taneb: Any of the two modes is your favorite?
05:28:01 <identity> systemfault: vim here.
05:28:04 <identity> emacs works fine.
05:28:24 <identity> (vim is obviously better, huehue)
05:28:52 <benzrf> o/
05:29:25 <luzie> i use vim but emacs is more powerful
05:29:47 <systemfault> Emacs users, what mode?
05:30:01 <systemfault> haskell-mode? Or there’s something better.
05:30:06 <Taneb> systemfault, they work together
05:30:15 <systemfault> Ah
05:30:30 <systemfault> (Failed to mention that I’m also a emacs noob)
05:30:39 <systemfault> Taneb: Thank you
05:30:48 <Trollinator> vi's notion of “modes” is utterly braindead. I keep forgetting I'm not in insert mode, I start typing and something stupid happens.
05:31:12 <Trollinator> and I've seen it happen to others.
05:31:35 <benzrf> Trollinator: nice job living up to your nick
05:31:38 <benzrf> (y)
05:32:24 <luzie> leaving your vi in insert mode isn't nice
05:32:35 <Trollinator> I haven't even begun to troll.
05:32:45 <benzrf> who would do that to a poor innocent vi ):
05:32:50 <systemfault> Trollinator: Must be why you’re still allowed on the channel :P
05:33:09 <identity> "I don't know how to use X therefore X is bad."
05:33:20 <benzrf> identity: thats my motto
05:33:25 <Trollinator> anyway, editor advocacy should probably go to haskell-blah
05:33:50 <Trollinator> It has nothing to do with not knowing how to use it. I do.
05:34:09 <ninja_code> in http://www.infoq.com/interviews/armstrong-peyton-jones-erlang-haskell ... Simon Peyton Jones mentioned that "telling the world about the greatness of laziness" as a main motivation of Haskell.
05:34:18 <ninja_code> I don't understand this point. Where can I read up more about it?
05:34:27 <ninja_code> I want to understand why laziness is desirable
05:34:47 <benzrf> ninja_code: it allows certain optimizations and infinite data
05:34:50 <benzrf> it's pretty cool
05:34:53 <benzrf> it can also cause space leaks >.>
05:34:59 <ninja_code> yes.
05:35:02 <ninja_code> I would like to read up more about it.
05:35:07 <ninja_code> Perferably longer than an irc chat session.
05:35:11 <ninja_code> Is there a book or paper? :-)
05:35:22 <Trollinator> laziness is desirable because it keeps you honest.
05:35:31 <identity> I kept trying to explain the greatness of laziness to my mother back in the day
05:35:33 <identity> it didn't pan out
05:35:39 <benzrf> identity: :[
05:35:49 <Trollinator> No side-effect nonsense in pure functions! lazyness makes that intractable.
05:35:52 <simon> ninja_code, as far as I understand, lazy semantics are essential to purification of side effects.
05:35:56 * hackagebot rados-haskell 3.0.2 - librados haskell bindings  http://hackage.haskell.org/package/rados-haskell-3.0.2 (ChristianMarie)
05:36:14 <ninja_code> simon: are you simon peyton jones?
05:36:17 <systemfault> I was reading about laziness… I understand that laziness is really good but was it a good idea to make it the “default”?
05:36:22 <sshine> I'm another Simon. :)
05:36:50 <Trollinator> simon: not really. purity can be done without laziness.
05:36:52 <systemfault> (You guys can’t probably count the number of times someone asked that question here)
05:36:59 <benzrf> @let kleene alpha = [1..] >>= flip replicateM alpha
05:37:01 <lambdabot>  Defined.
05:37:03 <benzrf> :t kleene
05:37:03 <lambdabot> [a] -> [[a]]
05:37:04 <ninja_code> sshine: yeah, I don't think side effects require laziness
05:37:21 <benzrf> > kleene ['a'..'z']
05:37:22 <lambdabot>  ["a","b","c","d","e","f","g","h","i","j","k","l","m","n","o","p","q","r","s"...
05:37:31 <benzrf> > drop 500 $ kleene ['a'..'z']
05:37:32 <lambdabot>  ["sg","sh","si","sj","sk","sl","sm","sn","so","sp","sq","sr","ss","st","su",...
05:37:37 <sshine> Trollinator, you mean to say that handling side-effects in monads can be done with strict evaluation semantics? I've read in Wadler's "Comprehending Monads" that the Str(ict) monad does in fact not obey the monad laws.
05:37:42 <benzrf> ninja_code: just look through that list
05:37:50 <benzrf> you'll find info about laziness there somewhere
05:37:51 <benzrf> ;)
05:37:58 <ninja_code> benzrf: what list?
05:38:05 <identity> > kleene myRoom
05:38:07 <lambdabot>  Not in scope: ‘myRoom’
05:38:09 <identity> :(
05:38:13 <benzrf> ninja_code: kleene ['a'..'z']
05:38:21 <benzrf> oh wait, better add spaces too
05:38:27 <sshine> ninja_code, the infinite list of words that benzrf generated :P
05:38:38 <benzrf> > kleene (' ':['a'..'z'])
05:38:40 <lambdabot>  [" ","a","b","c","d","e","f","g","h","i","j","k","l","m","n","o","p","q","r"...
05:38:45 <benzrf> > drop 100000 $ kleene (' ':['a'..'z'])
05:38:47 <lambdabot>  ["dacs","dact","dacu","dacv","dacw","dacx","dacy","dacz","dad ","dada","dadb...
05:38:52 <identity> You can also just look through the digits in pi -- you'll find anything you want there. including this conversation.
05:38:54 <benzrf> now we're getting somewhere!
05:39:10 <benzrf> identity: ah, but the joke is that i used laziness to calculate parts of that list
05:39:13 <benzrf> =3
05:39:46 <ninja_code> ah
05:39:47 <ninja_code> I get it
05:39:48 <ninja_code> the joke is
05:39:53 <benzrf> without laziness you cannot safely define the kleene star without having to pass a specification of which part to slice off
05:39:56 <ninja_code> we should report benzrf to the MPAA / RIAA :-)
05:40:00 <benzrf> o no
05:40:03 <luzie> ninja_code: http://www.cs.indiana.edu/pub/techreports/TR44.pdf
05:40:04 <identity> ninja_code: haha
05:40:05 <ninja_code> since taht list includes all movies ever created
05:40:18 <identity> Who do we report for pi then?
05:40:25 <benzrf> identity: god
05:40:29 <sshine> ninja_code, we can claim he knew about their legal terms, since they're hidden inthere somewhere, too.
05:40:35 <ninja_code> luzie: hmm, interesting
05:40:41 <benzrf> > find $ kleene (' ':['a'..'z'])
05:40:42 <lambdabot>  Couldn't match expected type ‘a -> GHC.Types.Bool’
05:40:43 <lambdabot>              with actual type ‘[[GHC.Types.Char]]’
05:40:43 <benzrf> oh wait
05:40:43 <ninja_code> sshine: I want you to be my lawyer.
05:40:45 <benzrf> :t find
05:40:46 <lambdabot> (a -> Bool) -> [a] -> Maybe a
05:40:47 <Trollinator> sshine: Monads have nothing to do with side effects, except that IO happens to be a monad.
05:40:55 <ninja_code> luzie: interesting this goes back to a scheme paper
05:40:58 <benzrf> > find (=="put the bunny back in the box") $ kleene (' ':['a'..'z'])
05:41:03 <lambdabot>  mueval-core: Time limit exceeded
05:41:06 <benzrf> dang it lambdabot
05:41:07 <benzrf> be faster!
05:41:11 <identity> > find (== "cake") $ kleene ['a' .. 'z']
05:41:13 <lambdabot>  Just "cake"
05:41:16 <benzrf> O:
05:41:17 <identity> the cake is not a lie.
05:41:38 <sshine> ninja_code, http://stackoverflow.com/a/355535/235908
05:41:43 <benzrf> > kleene [0..9]
05:41:44 <lambdabot>  [[0],[1],[2],[3],[4],[5],[6],[7],[8],[9],[0,0],[0,1],[0,2],[0,3],[0,4],[0,5]...
05:42:02 <Trollinator> sshine: anyway, I don't know the theoretical details. I just know there's at least one pure, eager language with monadic IO.
05:42:07 <identity> > find (== "banana") $ kleene ['a' .. 'z']
05:42:11 <lambdabot>  mueval-core: Time limit exceeded
05:42:11 <Trollinator> namely idris (http://idris-lang.org)
05:42:13 <identity> meh.
05:42:15 <ninja_code> sshine: noted, thanks!
05:42:21 <identity> lambdabot: get more time.
05:42:41 <Boreeas> > find (== "banana") $ drop 10000 $ kleene ['a' .. 'z']
05:42:44 <lambdabot>  mueval-core: Time limit exceeded
05:42:48 <sshine> Trollinator, right. monads are a convenient syntax, and it happens to be the use of abstract types that provides the compile-time analysis guarantees for allowing in-place memory updates.
05:43:05 <identity> > product $ map ord "banana"
05:43:07 <lambdabot>  1082247643400
05:43:10 <benzrf> sshine: monads are not a syntax
05:43:12 <identity> ah ..
05:43:23 <benzrf> identity: :o
05:43:25 <identity> > product $ map (\c -> ord c - ord 'a') "banana"
05:43:26 <lambdabot>  0
05:43:35 <identity> durr
05:43:46 <identity> > product $ map (\c -> ord c - ord 'a' +1 ) "banana"
05:43:48 <lambdabot>  392
05:43:51 <ccapndave> Hey everyone
05:43:54 <sshine> benzrf, expressing '\s -> (a, s)' as 'ST a' is :)
05:44:29 <ccapndave> I have a function which folds a list into a tuple using: winLineWins = map $ foldl' matcher (Nothing, 0)
05:44:49 <ccapndave> (The list itself is the missed out argument
05:45:12 <benzrf> @let digitString' acc [] = acc; digitString' acc (n:ns) = digitString' (acc * 10 + n) ns; digitString = digitString' . reverse
05:45:13 <ccapndave> Now I am trying to filter out all results where the second element of the tuple is less than 3
05:45:14 <sshine> benzrf, from Comprehending Monads: The key idea here is the use of abstract data type. Monad comprehensions are not essential for this to work, they merely provide a desirable syntax.
05:45:14 <lambdabot>  Defined.
05:45:23 <benzrf> > map digitString $ kleene [0..9]
05:45:24 <lambdabot>  No instance for (Data.Typeable.Internal.Typeable a0)
05:45:24 <lambdabot>    arising from a use of ‘M808625100130105012911396.show_M8086251001301050129...
05:45:24 <lambdabot>  The type variable ‘a0’ is ambiguous
05:45:24 <lambdabot>  Note: there are several potential instances:
05:45:24 <lambdabot>    instance Data.Typeable.Internal.Typeable Data.Dynamic.Dynamic
05:45:30 * benzrf punches lambdabot 
05:45:32 <benzrf> :t digitString
05:45:33 <lambdabot> Num [a] => [a] -> [[a]] -> [a]
05:45:38 <benzrf> oops
05:46:03 <ccapndave> I can't figure out the syntax though.  Tried winLineWins = filter (>2) $ map $ foldl' matcher (Nothing, 0) and all combinations of . and $ thereof and the types always fail
05:46:07 <benzrf> @let nonBrokenDigitString = digitString' 0 . reverse
05:46:08 <lambdabot>  Defined.
05:46:13 <benzrf> > map nonBrokenDigitString $ kleene [0..9]
05:46:14 <lambdabot>  [0,1,2,3,4,5,6,7,8,9,0,10,20,30,40,50,60,70,80,90,1,11,21,31,41,51,61,71,81,...
05:46:18 <benzrf> :-O
05:46:20 <sshine> ccapndave, map takes two arguments, the first being a function. you're feeding it with one, being a list.
05:46:32 <sshine> ccapndave, or rather, whatever is the output of foldl'.
05:46:50 <ccapndave> Sorry - matcher is a function and the list argument is normalized away
05:47:17 <ccapndave> sshine https://gist.github.com/ccapndave/1fce0dc3f0fc87bb6ea4 specifically
05:47:37 <Boreeas> :t sort
05:47:38 <lambdabot> Ord a => [a] -> [a]
05:47:46 <t7> Write 1,000,000 as the product of two numbers; neither of which contains any zeroes.  <- my brute force solution is taking too long
05:47:47 <ccapndave> sshine And WinLineMatch is a tuple
05:47:55 <Boreeas> > sort $ map nonBrokenDigitString $ kleene [0..9]
05:47:59 <lambdabot>  mueval-core: Time limit exceeded
05:48:04 <t7> > head [ (x ,y) | x <- [1..100000], y <- [1..100000], x * y == 1000000, notElem '0' (show (x * y))]
05:48:08 <lambdabot>  mueval-core: Time limit exceeded
05:48:26 <t7> its not even correct!
05:48:30 <ccapndave> winLineWins = filter (\a => True) $ map $ foldl' matcher (Nothing, 0)
05:48:34 <ccapndave> Why wouldn't this work?
05:49:17 <benzrf> ccapndave: you want ->, not =>
05:49:28 <ninja_code> in haskell, is it possible to define aa function called Cat->Name ?
05:49:29 <benzrf> lambda terms use regular arrows, not fat arrows
05:49:31 <sshine> ccapndave, this translates into filter (\a => True) (map (foldl' matcher (Nothing, 0)))
05:49:37 <ninja_code> or is "->" not allowed to be part of a var name
05:49:42 <benzrf> ninja_code: it is not
05:49:51 <benzrf> you could use catToName
05:49:52 <ninja_code> benzrf: is there a way to hack around this via unicode>
05:50:03 <ccapndave> winLineWins =  filter (\a -> True) $ map $ foldl' matcher (Nothing, 0)
05:50:09 <benzrf> ninja_code: maybe
05:50:09 <benzrf> why
05:50:12 <sshine> ccapndave, what you probably want is: filter (const True) . map something . foldl' matcher (Nothing, 0)
05:50:32 <identity> →
05:50:38 <identity> eh, that was supposed to be an arrow
05:50:43 <identity> u+2192
05:50:47 <sshine> identity, it looks like an arrow.
05:50:48 <ccapndave> sshine Where something is the input to the function?
05:50:53 <luzie> > let cat→name = 2 in cat→name
05:50:53 <benzrf> identity: your client sux @ unicode
05:50:54 <lambdabot>  <hint>:1:8: parse error on input ‘→’
05:50:57 * hackagebot babylon 0.3 - An implementation of a simple 2-player board game  http://hackage.haskell.org/package/babylon-0.3 (PedroVasconcelos)
05:50:57 <identity> sshine: doesn't display correctly for me for some reason I guess
05:51:01 <ccapndave> sshine the input is a list of things, each of which needs to be folded and filtered
05:51:08 <identity> benzrf: apparently so
05:51:17 <sshine> ccapndave, where something is some function that you map with. you have to map with a function, and the result of (foldl' matcher (Nothing, 0)) is not a function.
05:51:49 <sshine> ccapndave, now, I don't really know what this function is supposed to do, so it's difficult for me to tell what something should be. :)
05:52:04 <ccapndave> sshine Ah - matcher is the function I am folding with, and (foldl' matcher (Nothing, 0)) is the function I am mapping with
05:52:10 <sshine> ccapndave, why do you map across it if all you need is to filter and fold it?
05:52:28 <sshine> ccapndave, ah.
05:52:40 <ccapndave> So basically the fold calculates some stats on an element
05:52:49 <ccapndave> And there are an array of these, so I want to do that to each of them
05:52:57 <ccapndave> And now I want to filter out certain values too
05:53:00 <sshine> ccapndave, try and post a piece of code and an error message.
05:53:16 <sshine> ccapndave, you mean a list of these, right?
05:53:23 <ccapndave> SOrry
05:53:25 <ccapndave> List :)
05:53:49 <ccapndave> I'll post all the code
05:54:43 <ccapndave> sshine https://gist.github.com/ccapndave/1fce0dc3f0fc87bb6ea4
05:55:00 <ccapndave> sshine So this error only occurs when I add the filter (\a -> True) $ on line 50
05:55:04 <ccapndave> Otherwise the types are all fine
05:55:43 <sshine> ccapndave, use a . instead of a $
05:55:54 <sshine> filter (\a -> True) . map $ foldl' matcher (Nothing, 0)
05:56:16 <sshine> otherwise, filter (\a -> True) takes as argument a function.
05:56:23 <ccapndave> Couldn't match expected type `[a0]' with actual type `[a1] -> [b0]'
05:56:48 <sshine> sorry. filter (\a -> True) . (map $ foldl' matcher (Nothing, 0))
05:57:08 <ccapndave> Ah!
05:57:21 <ccapndave> sshine Thankyou :)
05:57:25 <sshine> you're welcome!
05:57:30 <ccapndave> Haskell does my head it
05:57:33 <ccapndave> in
05:57:43 <ajcoppa> are you sure filter (\a -> True) is going to do what you want?
05:57:47 <sshine> @pl filter (\a -> True) . (map $ foldl' matcher (Nothing, 0))
05:57:48 <lambdabot> filter (const True) . map (foldl' matcher (Nothing, 0))
05:57:56 <ccapndave> Ah no, I am going to put a real filter in there
05:58:01 <Trollinator> use `const True` instead of `\a -> True`
05:58:01 <ccapndave> This was just to get the types to match
05:58:03 <ajcoppa> okay cool
05:58:33 <srhb> ccapndave: You could use undefined for that purpose, too. :)
05:58:53 <ccapndave> srhb Like filter undefined
05:58:54 <ccapndave> ?
05:58:57 <srhb> ccapndave: Yes.
05:58:58 <sshine> yeah, sticking 'undefined' into places where you can't be bothered to even figure out the type seems helpful ;)
05:59:03 <ccapndave> ah cool
05:59:05 <srhb> ccapndave: undefined has any type you would like.
05:59:08 <ccapndave> I didn't even know undefined was a thing
05:59:16 <srhb> Of course, it will throw an error if you ever run it.
05:59:18 <sshine> well, it isn't.
05:59:18 <sshine> ;)
05:59:30 <srhb> sshine: Instant rimshot for you!
05:59:32 <srhb> ;)
05:59:39 <ccapndave> :)
05:59:48 <sshine> srhb, did you see my latest (and first) xmonad plugin?
05:59:54 <srhb> sshine: I did not. Link?
06:00:17 <Peaker> why do "cabal configure", "cabal build" and "cabal install" take so long to do nothing? :(
06:01:23 <sshine> srhb, https://gist.github.com/sshine/5c41d40fab6375810229 :)
06:01:26 <latk> I've been learning clojurescript, since the bindings to reactjs via om seem nice.. but man, does it feel like a step backwards from haskell. I didn't realise how much I would miss type signatures :s.
06:01:42 <latk> Are any of the haskell -> js languages mature enough to use in production ?
06:02:01 <rwbarton> Peaker: well I don't know about "configure", but building parses all your files, to see what modules they depend on, and then checks whether those modules have changed
06:02:13 <srhb> sshine: Nice, that looks useful.
06:02:24 <sshine> srhb, http://shine.eu.org/tmp/ss.png -- colors are ugly. it shows my "statusbar" quickly for a couple of seconds when I switch workspace.
06:02:49 <Peaker> rwbarton: should be a few milliseconds at worst?
06:03:09 <srhb> sshine: All I can see is that your fonts aren't properly AA'd in Firefox :<
06:03:10 <rwbarton> I have no idea
06:03:44 <rwbarton> it's not clear to me how much code you are talking about or how efficient the GHC parser is (normally it isn't the bottleneck anyways)
06:04:08 <sshine> srhb, I didn't even think about that. my font looks quite fine in the terminal.
06:04:22 <srhb> sshine: ok ;-)
06:04:36 <Peaker> cabal configure takes 1474ms ; cabal build takes 3430ms!
06:04:44 <Peaker> on a project with dozens of modules
06:05:14 <rwbarton> well cabal configure always does the same thing I think
06:05:15 <Peaker> 3.5 secs every time I test my changes is a lot!
06:05:23 <rwbarton> I mean it doesn't care about your old configuration at all
06:05:27 <Peaker> (in addition to the actual ghc build work)
06:06:41 <Okasu> Peaker: You can try out http://neilmitchell.blogspot.de/2014/06/announcing-ghc-make.html .
06:06:42 <srhb> sshine: No idea, mine already is. I don't recall doing anything special.
06:07:20 <Peaker> Okasu: thanks
06:09:14 <rwbarton> if you use CPP, I see from building lens with -v3 after it is already built, it has to run CPP on all the modules that use it
06:10:11 <rwbarton> also if you have vanilla, profiling, shared libraries on you could turn off all but one
06:10:56 <rwbarton> oh and it runs the link step every time, I wonder if that's actually slow
06:11:28 <c_wraith> I think it is.
06:12:29 <Peaker> rwbarton: this stuff is really important to the development cycle length -- which has a huge effect on productivity IMO
06:12:47 <rwbarton> fix it :)
06:12:53 <rwbarton> I think you have a lot of things to fix if you care this much
06:13:08 <rwbarton> just from watching the output of -v3 as it scrolls
06:13:51 <rwbarton> but yeah, ghc-make might work well for you since it uses timestamps to decide what to rebuild
06:17:07 <Ankhers> Is it possible, with aeson, to parse two or more data structures into a single JSON object?
06:19:08 <ccapndave> Can I drop out of a foldl' early?
06:19:21 <benzrf> ccapndave: no
06:19:23 <srhb> ccapndave: Not without building your own foldl'
06:19:24 <benzrf> you can never leave
06:19:26 <ccapndave> Or should I use a hand rolled recursive function
06:19:27 <benzrf> yuo're hear forevr
06:19:40 <srhb> Ankhers: Since data Foo = Foo Bar Baz -- yes.
06:19:58 <c_wraith> benzrf: dunno, I might go deaf eventually
06:20:44 <Ankhers> srhb: Is there a way to parse it so that it does not create a multi-tiered json structure though?
06:21:11 <srhb> Ankhers: As far as I know aeson, doesn't that just depend on the ToJSON instance?
06:21:55 <Ankhers> srhb: Yes. I just don't know if it possible, and if it is, I wouldn't know how to go about attempting it.
06:22:51 <srhb> Ankhers: Consider data Foo = Foo Int Int. instance ToJson Foo where toJSON (Foo x y) = object [ "z" .= x+y ]
06:24:13 <Ankhers> srhb: I think it just clicked. Thanks.
06:24:18 <srhb> Ankhers: Coolies. :)
06:30:40 <zwer_t> ccapndave what are you trying to do?
06:32:12 <mbrock> ccapndave: this Q/A might help: http://stackoverflow.com/questions/7464208/folding-across-maybes-in-haskell
06:32:51 <mbrock> ccapndave: (if you want to drop out with a value, just use Either instead of Maybe)
06:33:37 <ccapndave> aha
06:34:00 <ccapndave> Hmm its not quite the Maybe situation
06:34:33 <ccapndave> I want to fold until I get to a certain point (indicated by a case in my predicate function), at which point that's the result so no point carrying on
06:34:38 <ccapndave> In fact it breaks my algorithm to carry on
06:35:23 <benzrf> ccapndave: you could write your own folding func
06:35:27 <ccapndave> Maybe best to just use an old school recursive function instead of a higher order function?
06:35:57 <srhb> ccapndave: Are you sure you need foldl'?
06:36:01 <ccapndave> Nope
06:36:07 <srhb> ccapndave: Can you use foldr?
06:36:09 <Okasu> ccapndave: http://youtu.be/vgk-lA12FBk
06:36:11 <mbrock> you should be able to get by with just exploiting laziness
06:36:29 <Okasu> RE: recursive function vs higher order function?
06:36:32 <ccapndave> foldr doesn't work
06:36:40 <zwer> why not?
06:36:42 <srhb> ccapndave: OK, then you're better off writing your own function.
06:36:49 <ccapndave> ok
06:37:12 <ccapndave> zwer That's a good question
06:37:17 <ccapndave> zwer Because I tried it and it doesn't ;)
06:37:36 <ccapndave> Its matching symbols from left to right, so probably some subtlety based around that
06:37:47 <zwer> you can easily flip the arguments around
06:37:54 <Cale> ccapndave: Perhaps write the thing recursively and then figure out how to write it as some sort of fold or whatnot
06:37:56 <lyxia> You could use scanl then find
06:37:57 <zwer> > foldr (&&) True [True, False, undefined]
06:37:58 <lambdabot>  False
06:38:00 <ccapndave> Ah, it compiles but the algorithm doesn't work
06:38:25 <ccapndave> lyxia I am worried about performance if I do anything too fancy
06:38:37 <ccapndave> I'll go the recursive route I reckon
06:38:42 <srhb> ccapndave: Don't do that before you actually know what's costly. :-)
06:38:45 <ccapndave> Then as you say, maybe it can be optimized
06:39:22 <ccapndave> zwer What is that?
06:39:48 <ccapndave> zwer Oh I see
06:39:50 <Cale> ccapndave: zwer gave an example of foldr ending early
06:39:50 <zwer> it stops before evaluating undefined, unlike foldl which wouldn't do that
06:40:07 <ccapndave> zwer undefined would need to be in the list though
06:40:13 <srhb> No, it's not undefined that's the magic
06:40:17 <ccapndave> Oh
06:40:20 <srhb> It's the fact that && is lazy in its right argument
06:40:21 <Cale> > foldl (&&) True [True, False, undefined]
06:40:22 <lambdabot>  False
06:40:34 <Cale> However:
06:40:38 <ccapndave> Oh right, because once && is false there is no way back
06:40:41 <ccapndave> Clever compiler
06:40:41 <srhb> yes.
06:40:45 <srhb> It's not the compiler.
06:40:51 <Cale> > foldr (&&) True (True : False : undefined)
06:40:53 <srhb> Well, of course it is, but no. :PO
06:40:53 <lambdabot>  False
06:40:53 <ccapndave> Clever IRC bot?
06:40:57 <Cale> > foldl (&&) True (True : False : undefined)
06:40:59 <lambdabot>  *Exception: Prelude.undefined
06:41:09 <srhb> It's the fact that && is lazy in its right-hand argument. That's all there is to it.
06:41:12 <Cale> ^^ that illustrates the difference a bit better
06:41:27 <srhb> > False && undefined
06:41:28 <lambdabot>  False
06:41:40 <srhb> > True && undefined
06:41:41 <lambdabot>  *Exception: Prelude.undefined
06:41:42 <ccapndave> My function isn't lazy in its right hand argument
06:41:48 <Cale> Well, it's also that foldr f z (x:xs) immediately gives control to f
06:41:59 <ccapndave> I suppose I could add an extra item onto the accumulator to say if its finished or not
06:42:03 <ccapndave> Seems messy though
06:42:29 <srhb> It's hard to answer without knowing what's going on. :)
06:42:59 <ccapndave> srhb Its matching symbols on a fruit machine from left to right
06:43:23 <ccapndave> So KKKJ2 would stop as soon as it gets to the J, and return (K, 3)
06:43:38 <ccapndave> Also there are wild cards so **KJ2 would also return (K, 3)
06:43:45 <srhb> I see.
06:44:00 <ccapndave> I have now written this algorithm in 3 different languages with 4 different algorithms ;)
06:44:08 <ccapndave> Some are pretty, some are fast
06:44:10 <ccapndave> None are both so far
06:44:34 <srhb> What would JKJKJ return?
06:44:38 <srhb> (J,1)?
06:44:54 <frerich> ccapndave: Would *K*J return (K, 3) or (K, 2)?
06:45:05 <ccapndave> (K, 3)
06:45:26 <_xvilka> hi! So Haskell Platform is not updated twice? http://trac.haskell.org/haskell-platform/wiki/ReleaseTimetable ?
06:45:27 <ccapndave> The algorithm I am using right now is to have a 'flavour', which is the first found non-wild symbol
06:45:29 <frerich> ccapndave: I suppose **** is impossible? And ***J Would be (J, 4)?
06:45:35 <srhb> I see.
06:45:54 <ccapndave> Yup, ***J6 would be (J, 4)
06:46:02 <ccapndave> And **** is Nothing
06:46:17 <albeit> Is there a cleaner way to do something like this? "foo <- f; if g foo then return Nothing else ...."
06:46:28 <ccapndave> Scala was the prettiest, but unfortunately very slow
06:47:00 <Cale> _xvilka: There was a long delay in the release of GHC which might have messed with the schedule for HP.
06:47:02 <identity> :t maybe
06:47:03 <lambdabot> b -> (a -> b) -> Maybe a -> b
06:47:11 <identity> hmm
06:47:12 <ccapndave> A combination of collectFirst to figure out the flavour, then takeWhile to get the matches
06:47:23 <ccapndave> But that involves going through the list twice
06:47:42 <srhb> Yeah, rather than that you might just increase a counter for each wild-card before a flavour
06:47:43 <benzrf> identity: maybe default applyToJust
06:47:51 <napping> ccapndave: what are you trying to do?
06:47:52 <ccapndave> If there is some Haskell lazy magic that can find the flavour and count the matches at the same time I haven't figure it out
06:47:56 <benzrf> > maybe "no number" show (Nothing
06:47:56 <srhb> napping: Look up.
06:47:57 <benzrf> > maybe "no number" show (Nothing)
06:47:57 <lambdabot>  <hint>:1:32:
06:47:58 <lambdabot>      parse error (possibly incorrect indentation or mismatched brackets)
06:47:59 <lambdabot>  "no number"
06:48:01 <benzrf> > maybe "no number" show (Just 34)
06:48:03 <lambdabot>  "34"
06:48:32 <srhb> ccapndave: (Consecutive * or symbol, Maybe Flavour) is a start
06:48:56 <ccapndave> What is that?
06:49:11 <srhb> ccapndave: Well you just count as long as you have the same symbol.
06:49:18 <srhb> ccapndave: (* always counting as the same symbol)
06:49:31 <ccapndave> Right
06:49:42 <srhb> ccapndave: Once you get a real symbol, you have a Just Flavour. Then you keep going until you run out of symbols that count as that one.
06:49:48 <ccapndave> Exactly
06:49:51 <tantalus> Hi!
06:49:52 <ccapndave> That's how it works right now
06:49:58 <srhb> ccapndave: Goodie.
06:50:07 <tantalus> Has anyone of you managed to install the LLVM bindings for Haskell?
06:50:11 <tantalus> I'm getting a strange error:
06:50:13 <napping> I don't know what matching fruit symbols means
06:50:15 <ccapndave> But I sort of wonder if there is some super smart functional way to do it in 8 characters or something
06:50:31 <tantalus> checking whether the C++ compiler works... no configure: error: in `/tmp/llvm-base-3.2.0.2-18382/llvm-base-3.2.0.2': configure: error: C++ compiler cannot create executables
06:50:40 <tantalus> then cabal exits with an error code
06:50:44 <srhb> napping: It was discussed further up. It's a slot machine. We're counting number of identical consecutive flavours (including wildcards) from the left
06:50:47 <ccapndave> right now I have a case statement pattern matching flavours and symbol types (which will work fine)
06:51:01 <napping> Well, you can get an early exit from foldr
06:51:10 <srhb> Yes, we discussed that as well. :)
06:51:12 <napping> Is it only matching from the left, or the longest run, or what?
06:51:17 <ccapndave> Only from the left
06:51:22 <ccapndave> So 3JJJ3 is nothing
06:51:39 <napping> I don't have history past 8:16
06:51:47 <_xvilka> Cale: thats sad, on linux computers i'm installing from the gentoo haskell overlay, while on windows haskell platform is pretty useful rather than installing ghc&so on
06:52:33 <rwbarton> tantalus: which LLVM bindings are you trying to install?
06:52:40 <rwbarton> tantalus: also, do you have a C++ compiler installed?
06:53:01 <tantalus> yes, gcc is installed on my system
06:53:17 <tantalus> I tried installing llvm-base
06:53:22 <tantalus> because I want access to LLVM.Core
06:54:17 <tantalus> wait, I think I've been too hasty
06:54:31 <tantalus> I'm now installing g++ and will see whether this solves the problem
06:54:45 <rwbarton> hmm, I encountered an unrelated error
06:55:11 <rwbarton> tantalus: there is also a channel #haskell-llvm you can ask questions on
06:55:30 <tantalus> rwbarton: thanks! I didn't know about that channel
06:58:11 <napping> ccapndave: you might try foldM over either
06:58:56 <ccapndave> napping I'm afraid I don't know that one
06:59:23 <ccapndave> Never used Either, only Maybe
06:59:56 <mmmm_> Is there a library for dealing with Hex -> Char conversion?
07:00:24 <napping> are stars invalid?
07:00:28 <napping> numbers, rather
07:01:01 <zwer> mmmm_ do you meant Int -> Char? Hex is not a type
07:01:07 <zwer> @hoogle Int -> Char
07:01:09 <lambdabot> Data.Char chr :: Int -> Char
07:01:09 <lambdabot> Data.Char intToDigit :: Int -> Char
07:01:09 <lambdabot> Data.Text index :: Text -> Int -> Char
07:01:42 <zwer> > chr 0x20
07:01:44 <lambdabot>  ' '
07:02:28 <rwbarton> mmmm_, give an example input/output
07:02:54 <mmmm_> chr works
07:04:46 <identity> mmmm_: there's also readHex from Numeric
07:05:03 <identity> > readHex "ff" :: [(Int, String)]
07:05:05 <lambdabot>  [(255,"")]
07:05:35 <napping> ccapndave: http://lpaste.net/106334
07:05:43 <identity> map (chr . fst) $ readHex "30313233" :: [(Int, String)]
07:05:48 <identity> > map (chr . fst) $ readHex "30313233" :: [(Int, String)]
07:05:50 <lambdabot>  Couldn't match type ‘GHC.Types.Char’
07:05:50 <lambdabot>                with ‘(GHC.Types.Int, GHC.Base.String)’
07:05:50 <lambdabot>  Expected type: [(GHC.Types.Int, GHC.Base.String)]
07:05:50 <lambdabot>    Actual type: [GHC.Types.Char]
07:05:51 <ccapndave> napping Thanks!
07:05:53 <identity> durr
07:06:00 <mmmm_> > readHex "00024" :: [(Int, String)]
07:06:00 <identity> > map (chr . fst) $ readHex "30313233" :: String
07:06:02 <lambdabot>  [(36,"")]
07:06:03 <lambdabot>  can't find file: L.hs
07:06:29 <mmmm_> thanks I should be able to get things to work now
07:07:28 <ccapndave> napping I came up with http://lpaste.net/106335
07:07:55 <napping> huh
07:07:56 <identity> ccapndave: That's pretty impressive to do while napping
07:08:18 <napping> do digits break runs entirely, or can they score?
07:08:53 <ccapndave> napping Actually there aren't really digits, there are just symbols (with an index) and wild symbols
07:08:53 <ccapndave> data Symbol  = WildSymbol Int | NormalSymbol Int deriving (Eq, Show, Ord)
07:09:03 <ccapndave> The index of the
07:09:05 <ccapndave> oops
07:09:11 <ccapndave> The index of the WildSymbol is irrelevant for now
07:09:18 <napping> ah, okay. I was wondering if it was necessary to generalize a bit and have some characters break unconditionally
07:09:40 <ccapndave> napping There is lots of stuff in your code that I don't understand
07:10:26 <frerich> ccapndave: I think I missed some part of the discussion, is there some challenge about traversing the input string only exactly once or why do you use manual recursion?
07:10:28 <ccapndave> It looks neat as hell though
07:10:28 <napping> which? The mplus in compat is just being fancy and saving cases
07:10:57 <ccapndave> napping Bear in mind you are dealing with someone who still doesn't know what a monad is
07:11:04 * hackagebot stm-containers 0.1.0 - Containers for STM  http://hackage.haskell.org/package/stm-containers-0.1.0 (NikitaVolkov)
07:11:12 <napping> It could expand out like Nothing f2 = Just f2; f1 Nothing = Just f1; (Just c1) (Just c2) | c1 == c2 = Just c1
07:11:37 <napping> Maybe a raw foldr solution would be a bit easier to see
07:11:58 <frerich> Is there a function which maps '[]' to Nothing and any non empty list to Just the list?
07:12:01 <napping> but the foldM :: (a -> b -> m a) -> a -> [b] -> m a runs your accumulator over the lists
07:12:07 <napping> except it uses the Monad m
07:12:29 <ccapndave> Where the monad is Maybe here
07:12:30 <ccapndave> Is that right?
07:12:33 <napping> and for Either, it's just Right v >>= f = f v; Left e >>= _ = Left e
07:12:37 <napping> no, Either is the important one
07:12:50 <napping> so if your accumulator ever produces a Left, it doesn't bother to go any farther
07:13:12 <ccapndave> Where does it say that?
07:13:23 <ccapndave> Or is that what foldM does
07:13:26 <napping> in the instance Monad (Either a) in some library somewhere
07:13:41 <ccapndave> Oh ok
07:13:48 <napping> foldM f x [] = return x; foldM f x (b:bs) = do x' <- f x b; foldM f x' bs
07:13:59 <napping> basically I'm just getting an early-exit fold by specializing foldM
07:14:06 <ccapndave> I see
07:14:55 <rwbarton> it's not truly early-exit though with Either, you need a CPSed version
07:15:07 <napping> Isn't it?
07:15:29 <rwbarton> hmm
07:15:36 <frerich> ccapndave: I probably miss something but wouldn't http://lpaste.net/106337 do?
07:15:53 <napping> It surely is with Either
07:15:57 <rwbarton> maybe it depends on how the >>=s are associated and maybe foldM has them the right way
07:16:10 <napping> now it may not be as efficient as a continuation-passing version
07:16:48 <napping> and it's probably fine if it inlines enough, because the Either is returning straight into the case
07:16:54 <rwbarton> :T Right 2 >> Right 4
07:16:56 <rwbarton> :t Right 2 >> Right 4
07:16:57 <lambdabot> Num b => Either a b
07:17:12 <napping> rwbarton: I typed equations for foldM and >>= on either above, you can see it should work
07:17:23 <ccapndave> frerich What does (flavour:rest') <- maybeList rest do?
07:17:37 <rwbarton> > foldM (\acc b -> if b == 3 then Left "oh no" else Right acc) 0 [0..]
07:17:39 <lambdabot>  Left "oh no"
07:17:40 <albeit> If I have a datatype "data Foo = Bar | Baz String", how can I check in an if statement (not pattern matching) that foo :: Foo was constructed with Baz?
07:17:43 <ccapndave> napping Your algorithm looks cool, but its way over my head :)
07:17:44 <rwbarton> ok I'm convinced
07:17:57 * ccapndave has no idea what either of you are discussing
07:17:59 <rwbarton> hmm, what's the one that doesn't work
07:18:13 <frerich> ccapndave: It figures out the flavour character to use unless there is no flavour character at all in which case the whole thing (everything below) becomes 'Nothing'
07:18:57 <frerich> ccapndave: If 'span' doesn't find any non-wildcard characters, 'rest' is an empty list. maybeList turns that into Nothing which (since I'm in the Maybe monad) means that everything below will be Nothing as well
07:19:56 <ccapndave> frerich hmm
07:20:11 <mbrock> albeit: derive Eq and (== Bar)
07:20:17 <ccapndave> frerich It actually probably would work
07:20:42 <ccapndave> Thanks
07:20:51 <ccapndave> The key to this whole Haskell thing seems to be Monads
07:20:57 <albeit> mbrock: No way to test against Baz? Issue is I have multiple "Baz"s... like "Foo = Bar | Baz String | Lorem Int | Ipsum String Int"
07:21:02 <frerich> ccapndave: I wouldn't have needed to use monads, no.
07:21:06 <mbrock> albeit: oh sorry, misread
07:21:58 <mbrock> albeit: you might find some use for pattern synonyms
07:22:41 <pjdelport> ccapndave: The key to Haskell is ADTs and type classes. :)
07:22:49 <pjdelport> (Monads and the rest of the zoo are just a corollary.)
07:23:36 <ccapndave> Well, I'll keep plugging away with FP whenever I get an opportunity :)
07:24:19 <frerich> ccapndave : I added an annotation to http://lpaste.net/106337 which does the same thing as my previous suggestion, without any monads.
07:24:29 <frerich> ccapndave : The only reason I used a monad was to get away without writing an 'if' ;-)
07:24:34 <pjdelport> albeit: The only way you can do that is something like: isBaz (Baz _) = True; isBaz _ = False
07:24:51 <napping> ccapndave: here are thing expanded out and simplified a bit http://lpaste.net/106334
07:25:12 <napping> well, everything *except* foldM expanded out and simplified
07:26:06 <ccapndave> frerich I understand that one
07:26:10 <mbrock> it's a nice use case for foldM
07:26:25 <frerich> ccapndave : That's always the most important thing :-)
07:26:43 <ccapndave> napping And I think I understand that one too :)
07:27:11 <ccapndave> Thanks yall
07:27:21 <napping> here's a touch more http://lpaste.net/106334
07:27:45 <napping> Expanding the foldM, and throwing in Debug.Trace so you can be sure it's not looking at more characters
07:28:01 <napping> well, I guess that doesn't quite show it's not inspecting the spine of the list, but it's a decent check
07:28:07 <mbrock> you started out with a foldl, but wanted some additional semantics for the composition, and that's just what you get with the monadic variants (foldM, mapM, filterM, etc)
07:28:45 <napping> ccapndave: now see how much sense you can make going back up :)
07:28:58 <napping> It's all basically just using more generic library stuff that happened to have the right behavior defined
07:29:02 <ccapndave> I'm going to have to read these all a bit more
07:29:04 <ccapndave> :)
07:29:21 <napping> like mplus on Maybe keeps a value if either argument is Just and only gives Nothing otherwise
07:29:34 <ccapndave> I haven't got to mplus yet in my learnmeahaskell
07:29:36 <napping> so f1 `mplus` f2 worked to combine two assumed-compatible fruits
07:29:40 <ccapndave> I've just got to mappend
07:29:59 <napping> It's not really much different
07:30:03 <ccapndave> The chapter on Applicative Functoids (?) made my brain explode and I couldn't get any further
07:30:43 <napping> It's not even a particularly big use
07:31:00 <ccapndave> Do you guys have backgrounds in mathemetics?
07:31:02 <mbrock> ccapndave: at some point, you might want to look into the Typeclassopedia
07:31:04 <napping> it's much like mappend, but left biased
07:31:06 * hackagebot stm-containers 0.1.1 - Containers for STM  http://hackage.haskell.org/package/stm-containers-0.1.1 (NikitaVolkov)
07:31:25 <napping> well, it's a type class for things which are monads and have mplus :: m a -> m a -> m a
07:31:28 <ajcoppa> ccapndave: a background in math helps but isn't required at all
07:31:30 <napping> and mempty :: m a
07:31:40 <napping> so more or less like Monoid (m a)
07:31:47 <mbrock> ccapndave: not much. Haskell helped me develop some more interest for algebra
07:32:12 <napping> except it just happens the instance for Maybe is Monoid a => Monoid (Maybe a), using (Monoid a) to squish together the contents of the a values
07:33:02 <napping> maybe and either are just library functions for cases over those types
07:33:34 <ccapndave> (Copy pasted into my Haskell - to reread - document...)
07:35:07 <mbrock> ccapndave: it's not just that Haskell uses some algebraic terms, it's also that pure programming is very similar to algebra, since it's all about combining values and inventing useful value-oriented abstractions...
07:37:44 <alex94nts> now that you're talking about it, could you please recommend me some introductory book about category theory?
07:37:58 <pjdelport> Programming is just applied algebra, and those who ignore established theory are doomed to reinvent it, poorly.
07:39:20 <mbrock> ccapndave: Functor/Applicative/Monad/Monoid are fun and useful because they correspond to some very widely useful patterns of combining/transforming values
07:39:28 <augur> pjdelport: beep
07:39:39 <pjdelport> augur: pong (briefly!)
07:39:47 <augur> oh, well, ill bug you later then :)
07:40:02 <pjdelport> augur: Now's fine. :)
07:40:04 <mbrock> ccapndave: sort of like the patterns from OO (Visitor, Container, etc), but more value-oriented and mathematical :)
07:40:10 <augur> pjdelport:
07:40:12 <augur> << psygnisfive
07:40:24 <ccapndave> mbrock I have no problem with conceptualising OO stuff :)  This stuff is a bit harder
07:40:53 <napping> The OO stuff is pretty wonky mathematically. You get into coalgebras and stuff
07:41:15 <ccapndave> Never tried to look at OO mathmatically
07:41:15 <augur> pjdelport: i agree with you that the evaluative component is pure, but i think it's unnecessary to go so far as to say Haskell has no side-effects because of this
07:41:22 <ccapndave> Wouldn't know how to start :)
07:41:32 <mbrock> ccapndave: it's generally easier to focus on concrete examples of the typeclasses, then you start to see how they work as instances of the general classes...
07:41:36 <napping> It's not to hard to sorta-kinda understand why those things mostly sorta-kinda work, but actually being confident is harder
07:41:49 <ccapndave> We did some lambda calculus at university - I remember it as a class in which I understood nothing...
07:42:07 <mbrock> ccapndave: for example, if you look at the type of (>>=), the monadic bind operator, then it's very general
07:42:10 <mbrock> :t (>>=)
07:42:11 <lambdabot> Monad m => m a -> (a -> m b) -> m b
07:42:11 <augur> yes, the side effects are on the other side of the executor barrier, but haskell necessarily includes the other side of the barrier, it's not just a pure LC
07:42:34 <pjdelport> augur: Oh, I agree Haskell has no side effects, of course (unsafePerformIO, for example), but the IO type itself does not involve side effects.
07:42:56 <pjdelport> augur: The point is that what's executed on the other side of the barrier isn't Haskell.
07:43:01 <mbrock> but actually, (>>=) is overloaded for all the different monad types
07:43:14 <pjdelport> augur: In the same way that the machine code that Haskell gets compiled to isn't Haskell.
07:43:15 <augur> pjdelport: i have to disagree. whats on the other side of the barrier is as much haskell as this side
07:43:17 <mbrock> :t (>>=) :: Maybe a -> (a -> Maybe b) -> Maybe b
07:43:18 <ccapndave> mbrock As fmap is overloaded for different Functor types
07:43:18 <lambdabot> Maybe a -> (a -> Maybe b) -> Maybe b
07:43:52 <mbrock> that type is easier to understand :)
07:43:56 <mbrock> ccapndave: yeah, exactly
07:44:04 <augur> pjdelport: i mean, by the same reasoning then, haskell doesnt even have IO, which is an absurd conclusion to draw
07:44:35 <pjdelport> augur: No, it has IO. IO is a data type.
07:44:36 <augur> the point of the monadic approach is not to deny the existence of the effects, but to reify them and make them first-class rather than implicit
07:45:03 <pjdelport> augur: Right, but nowhere in that process do *side* effects enter the picture.
07:45:56 <augur> pjdelport: well the notion of "side effects" is fuzzy and imprecise anyway. but going by the standard usage, IO is a side effect, and the fact that when you run a haskell program, you can do IO, means to the average programmer, haskell has side effects
07:46:03 <ajcoppa> ccapndave: people are going to accuse me of being a broken record soon, but i highly recommend the NICTA course when you're ready to dive deep into functors/applicatives/monads
07:46:20 <tdammers> pfff... not this discussion again...
07:46:26 <tomejaguar> Can someone explain how TH affects definition dependencies within a single module?  I have ' ... use foo ...; $(TH splice); foo = ...' and it doesn't like that.
07:46:32 <tdammers> haskell-the-programming-toolchain can do side effects
07:46:34 <augur> actually there was a good discussion on twitter a few weeks ago about just what "effects" and "purity" actually were
07:46:41 <pjdelport> augur: Composing IO values is just normal functional programming in Haskell.
07:46:46 <tdammers> haskell-the-core-language can or cannot, depending on where you draw the line
07:46:52 <ccapndave> ajcoppa I'll check it out.  I'm really finding the learnyouahaskell one very confusing
07:47:05 <pjdelport> augur: "side effects" is as precise in Haskell as in any other language: unsafePerformIO has side effects, for example.
07:47:06 <augur> pjdelport: sure is! doesn't mean it doesnt have side effects, it just means haskell's figured out how to do that sensibly :)
07:47:12 <ccapndave> ajcoppa Wait, do I have to go to Australia for this?
07:47:14 <ajcoppa> i like LYAH for general exposure, but reinforcing the knowledge you get there by doing exercises is really important
07:47:15 <ajcoppa> nah
07:47:16 <ajcoppa> https://github.com/NICTA/course
07:47:22 <frerich> ccapndave: In case it matters, you can be very productive and have a hell of a good time with Haskell even without knowing anything about maths at all (like me, I never had any math education after high school). :-}
07:47:26 <pjdelport> augur: No, it means you have IO *instead* of side effects. :)
07:47:43 <ccapndave> ajcoppa Phew
07:47:51 <augur> afk
07:48:01 <ajcoppa> the course is pretty challenging and will turn your brain into mush, then reform it better :)
07:48:11 <ajcoppa> ask here or in #haskell-beginners when you run into speed bumps
07:48:22 <ccapndave> ok
07:48:33 <ccapndave> I did the Coursera Scala FP course
07:48:37 <ccapndave> It was very good
07:48:37 <pjdelport> But yeah, what tdammers said (and i have to get going to catch a bus, so be back later!)
07:54:32 <knapper_tech> What's a way to search for sequences of functions from type A to type B?
07:55:55 <dmj`> maybe hoogle
08:01:17 <athan> If you have a functor (CT speak) from type A to type B, could you derive a lens for B if given one for A?
08:01:19 <Pythonfant> ajcoppa: I'm just looking at the nicta course and I'm a bit confused. Is one just supposed to go in a random order through the files in source and solve the exercises or is there some additional courseware that gives you instructions on what to do in which order and so on
08:01:41 <ajcoppa> Pythonfant: the README has some instructions on the order of modules
08:02:06 <ajcoppa> under the section called "Progression"
08:02:28 <Pythonfant> oh right, I missed that
08:03:07 <Pythonfant> Where is this intro module mentioned in the readme?
08:03:41 <ajcoppa> not sure what you mean. it tells you to read through Course.Id, Course.Optional, and Course.Validation
08:03:46 <ajcoppa> then start implementing in Course.List
08:04:35 <Pythonfant> ajcoppa: getting started point 4 “The Intro module does not contain exercises. Its purpose is to demonstrate the structure of a project. ”
08:05:11 <joshc> knapper_tech: what do you mean?  you have a list of functions, [a -> b]?  how would you expect to sequence them?
08:06:31 <knapper_tech> joshc: I have a, need b, and have all of Haskell to choose from.  How can I search for some composition that obtains a -> b
08:06:38 <knapper_tech> I guess that's it.  Hoogle.
08:11:09 * hackagebot sql-simple 0.1.0.0 - common middle-level sql client.  http://hackage.haskell.org/package/sql-simple-0.1.0.0 (HirotomoMoriwaki)
08:11:11 * hackagebot sql-simple-sqlite 0.1.0.0 - sqlite backend for sql-simple  http://hackage.haskell.org/package/sql-simple-sqlite-0.1.0.0 (HirotomoMoriwaki)
08:11:13 * hackagebot sql-simple-postgresql 0.1.0.0 - postgresql backend for sql-simple  http://hackage.haskell.org/package/sql-simple-postgresql-0.1.0.0 (HirotomoMoriwaki)
08:14:36 <albeit> Need some pointers on where to start for a problem... I'm reading streaming data from a socket, and need to parse it with attoparsec, and "deliever" a result when a certain character is hit in the stream, then parse the next result... any packages I should look at?
08:14:49 <enthropy> jle`: I put it in https://github.com/aavogt/ErrorProp
08:18:22 <augur> pjdelport, tdammers: haskell-the-core-language is not what we program in ;)
08:19:01 <athan> albeit: I want to say this one... http://hackage.haskell.org/package/conduit-extra-1.1.1/docs/Data-Conduit-Attoparsec.html
08:19:59 <augur> anyone have a good tutorial on precedence in parsec
08:20:06 <napping> augur: I think one can reasonably quibble whether effects are "side" effects once you've got them organized in IO
08:20:33 <napping> but I hope everyone agrees you need something of a semantics of the effects of IO to reason about programs doing IO
08:21:20 <dmj`> albeit: I know the function you want
08:21:47 <dmj`> albeit: parseFromStream, takes a parser, a socket and returns a Maybe or Either result, then you can evaluate it
08:22:29 <dmj`> takes an InputStream ByteString, easy enough to convert a socket to InputStream tho
08:23:01 <dmj`> oh, It just throws an exception in IO, no Either or Maybe
08:23:06 <dmj`> http://hackage.haskell.org/package/io-streams-1.1.4.6/docs/System-IO-Streams-Attoparsec.html
08:23:22 <napping> augur: have you seen the non-Haddock documentation at http://legacy.cs.uu.nl/daan/download/parsec/parsec.html
08:23:50 <albeit> dmj`: Any reason you recommend that over a pipes / conduits solution?
08:26:28 <Colombiana> hola hombres
08:26:37 <napping> augur: It has a nicer general overview, and the "Expressions" section may help a bit
08:26:53 <benzrf> pipes is neat
08:27:02 <benzrf> but i dont know other libs
08:27:41 <enthropy> augur: maybe you have a sane grammar and can re-associate things after you've parsed?
08:28:48 <dmj`> albeit: IMO it is simpler, has less deps, and seems well-tested
08:28:57 <dmj`> albeit: also pipes people helped with it
08:29:00 <dmj`> http://snapframework.com/blog/2013/03/05/announcing-io-streams
08:30:06 <Pythonfant> @pl (\x acc -> acc + 1)
08:30:06 <lambdabot> const (1 +)
08:32:09 <dmj`> \socket parser -> socketToStreams >>= \(is, _) -> parseFromStream parser is >>= print
08:32:11 <tdammers> augur: it is, but it's only one level of what we're doing :D
08:32:22 <albeit> dmj`: Did you switch to io-streams for your projects from pipes/conduits/others?
08:34:13 <augur> napping: i think ive seen it. the problem is that there's no explanation of how precedences map in general to the parsers, no general principles to guide parser construction
08:34:40 <Colombiana> live colombiana chat: http://colombiana.lsl.com
08:34:44 <napping> Do you mean how it's translated into parsers?
08:35:17 <augur> napping: yeah
08:35:23 <dmj`> albeit: Am using snap for this project, snap-1.0 will replace enumerator with io-streams. Would like to stick with one iteratee library if possible, to lessen dep hell and install time. If this was yesod would probably use conduits instead
08:35:38 <napping> augur: I think you just have to hit the source then: http://hackage.haskell.org/package/parsec-3.1.5/docs/src/Text-Parsec-Expr.html#buildExpressionParser
08:37:50 <dmj`> \socket parser -> socketToStreams socket *
08:37:51 <dmj`>  
08:39:40 <augur> napping: basically im writing a parser for a simple dependently typed lambda calculus, and the problem im confronting is that * and -> arent associating right, even when i write my parser with baked-in precedence
08:39:44 <augur> and i dont know how to make it work
08:40:20 <napping> well, then you are probably baking in the precedence wrong. Maybe try something super simple?
08:40:51 <augur> napping: yeah, thats my plan right now
08:41:12 <napping> have you tried the ExpressionParser module? I'd be very surprised if that's giving you wrong precedence
08:41:40 <augur> i dont know how to use that at all
08:42:24 <napping> well, you could type in the examples and try to make little changes, if you really have no idea at all how to start
08:43:59 <monochrom> my http://www.haskell.org/haskellwiki/Parsing_expressions_and_statements has examples
08:44:55 <monochrom> AssocLeft and AssocRight exist
08:45:54 <monochrom> for handwritten cases, chainl and chainr exist. or start with sepBy or many, then use foldl or foldr yourself.
08:46:43 <enthropy> http://lpaste.net/106359 is an example of fixing it up after the fact
08:52:35 <smash> hello everyone, ok to ask a question about Haskell data types?
08:54:25 <alex94nts> smash: sure
08:55:27 <smash> if i have a data type like: data Any = A Int | B Int, is there a way to filter a list on the constructor? get a list of A only
08:55:33 <smash> for example
08:56:11 <alex94nts> yes, you can use "case of" and foldl
08:56:34 <napping> huh?
08:56:48 <napping> I'd say just a plain filter or list comprehension should do
08:56:54 <napping> [a | a@(A _) <- myList]
08:57:11 <S11001001> lens: compose the list traversal with the A prism, then fold :)
08:57:42 <alex94nts> as you see there's always more than a way to do it :)
08:57:49 <smash> excelent
08:58:00 <napping> If you want a list back, I don't see why you would use foldl at all
08:58:00 <smash> already have a solution that works perfectly
08:58:12 <smash> thank you all
08:58:19 <napping> one little trick is borrowing a touch of record syntax
08:58:25 <napping> [a | a@A{} <- myList]
08:59:14 <napping> even if you didn't declare your type with record syntax, you can write that to just match the A constructor without having to count _
08:59:31 <napping> You just need A _, but when it gets bigger like A _ _ _ _ or whatever you might not want to bother
09:01:37 <mossplix> I cant seem to grok this type synonym   >> type ReadS a = String -> [(a, String)]
09:02:21 <MP2E> heh ghc is using a ton of RAM while compiling haskell-src-exts and -fno-spec-constr and -fno-liberate-case don't seem to be helping things at all.. any recommendations? :S
09:02:23 <monochrom> do you grok String -> [(a, String)] ?
09:02:46 <mossplix> yap
09:03:07 <mossplix> how would you use it in a data constructor
09:03:33 <monochrom> I don't understand the question
09:03:55 <mossplix> data Rx= Rx {foo::ReadS}
09:04:05 <monochrom> yes, that's legal code
09:04:15 <monochrom> no, not legal
09:04:25 <monochrom> data Rx= Rx {foo::ReadS Int}  perhaps
09:04:39 <smash> thks again everyone for suggestion
09:05:48 <mossplix> thanks! monochrom  that works
09:17:34 <phaazon> @hoogle Either e a -> EitherT e m a
09:17:34 <lambdabot> Warning: Unknown type EitherT
09:17:34 <lambdabot> No results found
09:17:48 <phaazon> @hoogle Writer w a -> WriterT w m a
09:17:48 <lambdabot> No results found
09:17:56 <phaazon> :t writer
09:17:58 <lambdabot> MonadWriter w m => (a, w) -> m a
09:18:38 <phaazon> :t hoistEither
09:18:39 <lambdabot> Not in scope: ‘hoistEither’
09:19:06 <phaazon> isn’t there a package for that?
09:19:11 <phaazon> MonadBase, maybe?
09:21:16 * hackagebot lens-family-core 1.0.1 - Haskell 98 Lens Families  http://hackage.haskell.org/package/lens-family-core-1.0.1 (RussellOConnor)
09:21:18 * hackagebot lens-family 1.0.1 - Lens Families  http://hackage.haskell.org/package/lens-family-1.0.1 (RussellOConnor)
09:21:26 <alkabetz> You want the 'either' package: http://j.mp/1jnv18p
09:22:27 <phaazon> no I don’t alkabetz
09:22:56 <phaazon> I’m looking for a generic way of lifting the monad into its transformer version
09:23:02 <phaazon> like Writer -> WriterT
09:23:06 <phaazon> Reader -> ReaderT
09:26:06 <johnw> fmap WriterT (x :: Writer w a)
09:26:13 <johnw> @unmtl WriterT w m a
09:26:14 <lambdabot> m (a, w)
09:26:21 <johnw> ah, n/m
09:26:53 <johnw> @unmtl Writer w a
09:26:53 <lambdabot> (a, w)
09:26:53 <johnw> just WriterT . return should do it
09:28:05 <pietervdvn> Hi everyone!
09:28:05 <pietervdvn> Does someone know a good constraint based programming lib?
09:29:35 <phaazon> johnw: yeah
09:29:38 <phaazon> EitherT . return
09:29:43 <phaazon> ReaderT . return
09:29:44 <phaazon> and so on
09:29:50 <johnw> yep
09:29:59 <phaazon> I just wondered whether it was possible to wrap that in a typeclass
09:30:06 <johnw> it's just a newtype wrapper in each case that provides behavior through its instances
09:30:23 <phaazon> something that states a “t m a” transformer can be built from its internal original monad
09:30:41 <phaazon> because for instance
09:31:03 <phaazon> newtype EitherT e m a = EitherT (m (Either e a))
09:31:17 * hackagebot clckwrks-cli 0.2.12 - a command-line interface for adminstrating some aspects of clckwrks  http://hackage.haskell.org/package/clckwrks-cli-0.2.12 (JeremyShaw)
09:31:25 <phaazon> class MonadHoist t i where…
09:31:34 <phaazon> instance MonadHoist EitherT Either where…
09:31:39 <phaazon> something like that
09:31:55 <phaazon> well, no
09:31:58 <phaazon> better:
09:32:12 <phaazon> class MonadHoist t i | t -> i where
09:32:49 <phaazon>   hoist :: i -> t
09:32:55 <phaazon> or that kind of stuff :)
09:32:58 <phaazon> i a -> t a
09:33:03 <phaazon> I don’t know exactly
09:33:19 <johnw> phaazon: https://gist.github.com/404013f1ffde11842813
09:33:42 <phaazon> yep!
09:33:44 <phaazon> that :)
09:33:46 <johnw> actually, there's is something sexier lurking here...
09:33:48 <phaazon> does it exist yet?
09:33:51 <johnw> no
09:33:54 <johnw> or, maybe
09:33:55 <phaazon> johnw: MonadBase?
09:34:13 <johnw> um
09:34:17 <johnw> this is called "lift" hahaha
09:34:24 <phaazon> ?
09:34:28 <phaazon> what is called lift?
09:34:28 <johnw> :t lift (x :: Writer w a)
09:34:29 <lambdabot>     Couldn't match type ‘Expr’ with ‘WriterT w1 Identity a1’
09:34:29 <lambdabot>     Expected type: Writer w1 a1
09:34:29 <lambdabot>       Actual type: Expr
09:34:41 <phaazon> no johnw
09:34:42 <johnw> :t lift (x :: Writer w a) :: WriterT w m a
09:34:43 <phaazon> it’s not lift
09:34:43 <lambdabot>     Couldn't match type ‘Expr’ with ‘WriterT w2 Identity a2’
09:34:44 <lambdabot>     Expected type: Writer w2 a2
09:34:44 <lambdabot>       Actual type: Expr
09:34:52 <johnw> lift :: MonadTrans t => forall m a. Monad m => m a -> t m a
09:35:00 <johnw> ah
09:35:02 <johnw> I see what you mean
09:35:03 <phaazon> the m here
09:35:07 <johnw> right
09:35:07 <phaazon> is not Either
09:35:09 <phaazon> it’d be IO
09:35:11 <phaazon> or that kind of stuff
09:35:23 <phaazon> the idea is to lift the internal
09:35:31 <rwbarton> note that some (but not all) transformers also permit (m a -> n a) -> t m a -> t n a
09:35:50 <phaazon> rwbarton: sounds like MonadTranscontrol
09:35:52 <phaazon> Control*
09:35:55 <rwbarton> and Writer = WriterT Identity etc.
09:36:04 <rwbarton> and there is Identity a -> n a
09:36:14 <phaazon> rwbarton: I’m interested in t m a -> t n a
09:36:17 * hackagebot clckwrks-plugin-page 0.3.4 - support for CMS/Blogging in clckwrks  http://hackage.haskell.org/package/clckwrks-plugin-page-0.3.4 (JeremyShaw)
09:36:33 <phaazon> @hoogle (Monad m,Monad n,MonadTrans t) => t m a -> t n a
09:36:33 <lambdabot> Data.Graph.Inductive.Graph nmap :: DynGraph gr => (a -> c) -> gr a b -> gr c b
09:36:33 <lambdabot> Control.Category (.) :: Category cat => cat b c -> cat a b -> cat a c
09:36:33 <lambdabot> Control.Category (<<<) :: Category cat => cat b c -> cat a b -> cat a c
09:36:37 <rwbarton> I'm sure it is in one or more packages on hackage somewhere
09:36:48 <johnw> this feels like a higher-order monad actually
09:36:49 <phaazon> I bet it’s monad-control!
09:37:22 <rwbarton> I don't really think so
09:37:44 <rwbarton> MonadTransControl is something more complicated
09:37:49 <rwbarton> this is just saying that 't' is functorial in 'm'
09:39:01 <phaazon> rwbarton: I’ve seen that signature somewhere
09:39:03 <phaazon> I’m pretty sure
09:39:07 <phaazon> but where…
09:39:20 <phaazon> maybe in layers
09:39:21 <rwbarton> indeed
09:39:36 <johnw> phaazon: what about this: https://gist.github.com/3ebbcf2559ea7e4c3458
09:39:52 <johnw> not sure what the value is though
09:40:14 <bitemyapp> jle`: there was no drama, I just didn't want noise in #haskell
09:40:27 <bitemyapp> jle`: beginner questions are hella boring.
09:40:41 <phaazon> johnw: I have no idea what you’re doing
09:40:42 <phaazon> :D
09:40:44 <bitemyapp> jle`: I created #haskell-beginners for that reason and because I wanted a concentrated channel of mostly people following my course or the aftermath thereof.
09:40:50 <phaazon> rwbarton: I remember now
09:40:56 <johnw> phaazon: we have the structure of a monad is the category of functors here
09:40:57 <ajcoppa> #haskell-beginners is great and i like having it
09:40:59 <benzrf> bitemyapp: beginner questions are fun!
09:40:59 <phaazon> it was edward that gave me the link
09:41:00 <johnw> s/is/in
09:41:06 <benzrf> they are easy to answer
09:41:09 <phaazon> there were functions like hm
09:41:10 <phaazon> embed
09:41:18 * hackagebot clckwrks-plugin-bugs 0.7.4 - bug tracking plugin for clckwrks  http://hackage.haskell.org/package/clckwrks-plugin-bugs-0.7.4 (JeremyShaw)
09:41:20 * hackagebot ircbot 0.6.1 - A library for writing irc bots  http://hackage.haskell.org/package/ircbot-0.6.1 (JeremyShaw)
09:41:57 <johnw> or maybe bind' should be (m a -> t o a) for another o...
09:42:37 <rwbarton> transformers even mentions this functoriality
09:42:41 <phaazon> http://hackage.haskell.org/package/comonad-4.2/docs/Control-Comonad-Hoist-Class.html
09:42:51 <rwbarton> All of the monad transformers except ContT are functors on the category of monads: in addition to defining a mapping of monads, they also define a mapping from transformations between base monads to transformations between transformed monads, called mapXXXT. Thus given a monad transformation t :: M a -> N a, the combinator mapStateT constructs a monad transformation mapStateT t :: StateT s M a -> StateT s N a
09:42:55 <phaazon> arf, it’s comonad, not monad
09:43:06 <rwbarton> but doesn't include a class for these
09:43:29 <marchelzo_> I am trying to use matchRegex against a really big string and it returns Just [] despite there being matches in the string. How can I overcome this?
09:43:36 <marchelzo_> from Text.Regex
09:43:41 <marchelzo_> pls no Parser
09:43:48 <phaazon> my god
09:43:57 <phaazon> edward has something like 50 libs on hackagedb :–’
09:46:16 <rwbarton> phaazon: oh, here is one https://hackage.haskell.org/package/mmorph-1.0.0/docs/Control-Monad-Morph.html
09:46:23 <haskdev> ls
09:47:20 <rwbarton> oh right, I forgot you need the higher-rank type in hoist
09:47:33 <phaazon> hoist :: Monad m => (forall a. m a -> n a) -> t m b -> t n b
09:47:34 <phaazon> great!
09:47:50 <phaazon> yeah
09:47:55 <phaazon> there’s embed as well
09:48:00 <pgib> Hey guys, here is a pattern I keep getting killed on. What is the right way to handle  Just versus Nothing in this case? http://lpaste.net/106362
09:48:00 <phaazon> it’s that one I was looking for :)
09:48:02 <johnw> well, for the transformers version of "Writer", that will work
09:48:06 <marchelzo_> ignore my earlier question, I didn't realize parens were necessary in order to have the matches returned
09:48:09 <johnw> because n is fixed at Identity there
09:48:33 <johnw> but if you were working with the non-transformers version, it wouldn't
09:48:41 <pgib> oh, and idx, is supposed to be i. Corrected: http://lpaste.net/106363
09:48:45 <johnw> so it works by coincidence of an implementation detail of transformers
09:49:41 <rwbarton> pgib: simplest is findCycle (x:xs) = case i of ... where i = ...
09:49:45 <rwbarton> also, don't shadow i like this, that's confusing
09:50:00 <rwbarton> you probably really want findCycle (x:xs) = case findIndex (==x) xs of ...
09:50:16 <pgib> right, I just didn't know the syntax.. I would have done something like i == Just i'
09:51:18 * hackagebot clckwrks-plugin-ircbot 0.6.10 - ircbot plugin for clckwrks  http://hackage.haskell.org/package/clckwrks-plugin-ircbot-0.6.10 (JeremyShaw)
09:51:26 <pgib> so guards do not do any pattern matching and case statements do?
09:51:32 <Tjr> Are you trying to reverse the "cycle" function?
09:51:38 <zwer> pgib don't do that, it requires Eq constraint
09:51:48 <rwbarton> pgib: that's correct
09:52:08 <rwbarton> the body of a guard is just an expression of type Bool
09:52:22 <rwbarton> maybe you can have several expressions, I forget
09:52:23 <pgib> zwer then how else to determine "Nothing" construction versus "Just a"
09:52:31 <rwbarton> there's an extension that lets you do pattern matching in guards
09:52:41 <rwbarton> pgib, case
09:52:56 <zwer> pgib isJust, but I would likely use case instead. are you trying to check if x is Nothing or Just a?
09:53:15 <monochrom> pattern matching is how to tell apart Nothing from Just. read my http://www.vex.net/~trebla/haskell/crossroad.xhtml
09:53:17 <zwer> or idx?
09:53:27 <pgib> monochrom: But I can't do pattern matching here :(
09:53:49 <monochrom> I thought rwbarton just showed you how
09:54:01 <pgib> monochrom, oh I thought you suggested pattern matching
09:54:16 <monochrom> yes, I suggested and still suggest pattern matching.
09:54:24 <monochrom> and so did rwbarton.
09:54:29 <Yuu_chan> bitemyapp: Hello! Do you want another Bloodhound bug-report?
09:54:31 <pgib> I'm confused.. Give me a moment to change the code
09:54:41 <pgib> Too much talk, not enough work
09:54:45 <monochrom> "case" is pattern matching too.
09:54:53 <benzrf> "case" is the only pattern matching
09:54:57 <benzrf> anything else is sugar
09:55:26 <monochrom> yeah I don't understand where people get the idea "f (x:xs) =... is pattern matching, case is not"
09:55:27 <pgib> oh, I thought you were suggesting Pattern Matching as an alternative to everyone else (including me) who suggested it earlier
09:56:06 <pgib> so, that's where i got confused, monochrom. I thought you were saying "Forget what they said, use pattern matching!"  appologies
09:56:23 <albeit> Using attoparsec, I have a function "p = Parser (Foo, Bar)". I want to continue parsing the provided bytestring with p until the Foo value satisfies some condition, and return a Parser [(Foo, Bar)].  How can I do that?
09:56:47 <monochrom> anyway my article also uses "case". it's plain as day.
09:57:08 <mmmm_> albeit: In parsec that would manyTill, try searching for that
09:57:13 <pgib> I got it
09:57:54 <albeit> mmm_: I don't see how manyTill would work, because it runs a test action on the remaining bytestring, but I want to test what I just parsed
09:57:57 <simukis_> https://gist.github.com/nagisa/34b384f3b8d8b88ee6a0 can somebody explain why this happens? Is that a bug?
09:58:05 <pgib> I suppose case just feels dirty to me for some reason. So, I like to make sure I'm not missing something when I feel like i use case for everything.
09:58:11 <benzrf> @hoogle whileM
09:58:11 <lambdabot> No results found
09:58:47 <benzrf> @hoogle (a -> m Bool) -> m a -> m [a]
09:58:47 <lambdabot> Control.Monad filterM :: Monad m => (a -> m Bool) -> [a] -> m [a]
09:58:47 <lambdabot> Test.QuickCheck.Arbitrary shrinkList :: (a -> [a]) -> [a] -> [[a]]
09:58:47 <lambdabot> Prelude mapM :: Monad m => (a -> m b) -> [a] -> m [b]
09:58:50 <benzrf> hmmm
09:59:01 <benzrf> @hoogle until
09:59:01 <lambdabot> Prelude until :: (a -> Bool) -> (a -> a) -> a -> a
09:59:04 <benzrf> :\
09:59:23 <zwer> @hoogle monad-loops
09:59:23 <lambdabot> package monad-loops
09:59:23 <lambdabot> package monad-loops-stm
09:59:32 <benzrf> oh i guess i want (a -> Bool) anyway
09:59:35 <zwer> @where monad-loops
09:59:35 <lambdabot> I know nothing about monad-loops.
09:59:54 * benzrf exits
10:01:12 <simukis_> this really baffles me as I see no reason for this to fail and it fails ONLY when all three functions in the constructor are replaced.
10:02:10 <rwbarton> it's because when you replace all the functions, the type of the result is unrelated to the type of renderOptions
10:02:28 <rwbarton> so it doesn't know what type 'str' to pick for renderOptions
10:02:53 <simukis_> rwbarton: but even if I specialise it with :: RenderOptions String it doesn’t work either.
10:02:58 <johnw> monad-loops is highly useful
10:03:01 <rwbarton> simukis_: it = ?
10:03:20 <rwbarton> simukis_: the type of the result is not the issue
10:03:30 <rwbarton> simukis_: the type of the subexpression 'renderOptions' is the issue
10:03:41 <simukis_> renderOptions { optEscape = id, optMinimize = const True, optRawTag = const True } :: RenderOptions String
10:03:59 <rwbarton> it's like the show . read problem
10:04:21 <rwbarton> what should the type of renderOptions be?
10:04:26 <rwbarton> record updates are allowed to change the type
10:06:07 <albeit> Think I found it...
10:06:14 <albeit> @hoogle unfoldWhileM
10:06:14 <lambdabot> No results found
10:06:25 <albeit> unfoldWhileM :: Monad m => (a -> Bool) -> m a -> m [a]
10:06:38 <simukis_> rwbarton: I’m aware of that, but if expression is of type `RenderOptions a` and I specialise a to String *after* the record update, basically asking it to pick String instance of StringLike…
10:07:03 <rwbarton> you specified the type of the WHOLE expression
10:07:29 <rwbarton> consider this function
10:07:34 <albeit> Ah shoot but it discards the final value... anyone know if there is an unfoldWhileM that keesp the final value?
10:07:40 <rwbarton> \r -> r { optEscape = id, optMinimize = const True, optRawTag = const True }
10:07:47 <simukis_> rwbarton: oh *facepalm*
10:07:49 <simukis_> i got it!
10:07:51 <simukis_> thanks!
10:07:53 <Elliott21>  Here some videos. I hope you like them! http://j.mp/1pSIevZ
10:07:57 <rwbarton> admittedly it's quite annoying in this case
10:11:20 * hackagebot clckwrks-plugin-media 0.6.9 - media plugin for clckwrks  http://hackage.haskell.org/package/clckwrks-plugin-media-0.6.9 (JeremyShaw)
10:14:55 <quchen> What's the best way to get the TypeRep of something Typeable without having a value of said type at hand? I'm looking for something like "Typeable a => TypeRep", is that possible somehow?
10:16:12 <quchen> With ScopedTypeVariables, this looks like it might work, but it's a bit hacky:  foo :: forall a. Typeable a -> TypeRep; foo = typeOf (undefined :: a)
10:16:20 * hackagebot clckwrks-plugin-ircbot 0.6.11 - ircbot plugin for clckwrks  http://hackage.haskell.org/package/clckwrks-plugin-ircbot-0.6.11 (JeremyShaw)
10:16:32 <rwbarton> or you can use (undefined :: proxy a) with the polykinded version
10:16:39 <k00mi> quchen: there is a Data.Typeable.Proxy
10:17:32 <quchen> k00mi: What package is that from?
10:17:44 <rwbarton> also, you can't call your 'foo', for the same reason that you wanted to write your 'foo'
10:17:47 <k00mi> it's in base
10:17:57 <quchen> rwbarton: "Proxy :: Proxy a" might be cleaner, no?
10:18:08 <rwbarton> if you prefer
10:18:27 <quchen> k00mi: I don't see it in base, http://hackage.haskell.org/package/base-4.7.0.0
10:18:34 <quchen> Or do you mean Proxy, like rwbarton?
10:18:51 <k00mi> http://hackage.haskell.org/package/base-4.7.0.0/docs/Data-Typeable.html#g:6
10:19:14 <quchen> Ah, I thought you referred to a module, not the Proxy type.
10:20:27 <bonobo123> > Data.Map.fromList [(1,1),(1,2)]
10:20:28 <lambdabot>  Not in scope: ‘Data.Map.fromList’
10:21:28 <dwcook> > M.fromList [(1,1),(1,2)] -- bonobo123
10:21:30 <lambdabot>  fromList [(1,2)]
10:21:42 <bonobo123> thx
10:21:46 <dwcook> lambdabot has sort of unpredictable imports sometimes
10:22:01 <bonobo123> > M.unions (map (curry M.singleton) [(1,1),(1,2)])
10:22:03 <lambdabot>  Couldn't match type ‘b0
10:22:03 <lambdabot>                       -> a0 -> Data.Map.Base.Map ((t0, t1), b0) a0’
10:22:03 <lambdabot>                with ‘Data.Map.Base.Map k a’
10:22:03 <lambdabot>  Expected type: (t0, t1) -> Data.Map.Base.Map k a
10:22:03 <lambdabot>    Actual type: (t0, t1)
10:22:17 <bonobo123> M.unions (map (uncurry M.singleton) [(1,1),(1,2)])
10:22:20 <jfischoff> what is “slop” in a GHC gc context?
10:22:30 <bonobo123> > M.unions (map (curry M.singleton) [(1,1),(1,2)])
10:22:31 <lambdabot>  Couldn't match type ‘b0
10:22:31 <lambdabot>                       -> a0 -> Data.Map.Base.Map ((t0, t1), b0) a0’
10:22:31 <lambdabot>                with ‘Data.Map.Base.Map k a’
10:22:31 <lambdabot>  Expected type: (t0, t1) -> Data.Map.Base.Map k a
10:22:31 <lambdabot>    Actual type: (t0, t1)
10:22:38 <bonobo123> > M.unions (map (uncurry M.singleton) [(1,1),(1,2)])
10:22:40 <lambdabot>  fromList [(1,1)]
10:22:55 <jfischoff> what does “bytes lost to slop” mean?
10:23:05 <bonobo123> fromList is right-biased, unions is left-biased… not nice
10:23:51 <rwbarton> @google ghc slop
10:23:52 <lambdabot> https://ghc.haskell.org/trac/ghc/wiki/Commentary/Rts/Storage/Slop
10:24:58 <jfischoff> thanks
10:35:07 <albeit> dmj' (and others): Using io-streams, specifically parseFromStream with attoparsec, if there is nothing in the InputStream, and I call parseFromStream, will it block until something is added to the InputStream?
10:39:11 <kini> this is odd... I have a cabal project that depends on only base, filepath, hakyll, and MissingH (with no versions specified)
10:39:11 <kini> but when I do `cabal install --dry-run`, I get some ancient version of pandoc (1.6.0.1), whereas when I do `cabal install --dry-run base filepath hakyll MissingH` I get the latest version of pandoc (1.12.4.2)
10:39:14 <kini> what's going on?
10:43:16 <supki> kini: do you have hakyll installed already?
10:43:40 <kini> I'm using a sandbox and I have almost nothing installed outside of it except ghc
10:43:47 <supki> cabal will try not to reinstall anything unless you explicitly tell it
10:43:50 <tomejaguar> Is there any way of telling GHC "Yes I know there are overlapping instances and you can't choose between them but just pick any one I don't care"?
10:43:50 <kini> (and whatever is bundled into ghc)
10:44:06 <rwbarton> hopefully cabal is not trying to upgrade base
10:44:16 <rwbarton> oh filepath comes with ghc also
10:44:18 <bitemyapp> sigh, nuts.
10:44:28 <bitemyapp> I hate it when people leave.
10:44:48 <joelteon> tomejaguar: that doesn't make sense
10:44:53 <tomejaguar> Why not?
10:44:53 <rwbarton> tomejaguar: I found a bug that works like that
10:45:03 <tomejaguar> rwbarton: Can I exploit the bug ...
10:45:11 <rwbarton> I don't know, maybe!
10:45:35 <tomejaguar> If there's more than one instance I "know" they are the same thing
10:45:46 <tomejaguar> I just want it to pick one because it really doesn't matter
10:45:53 <napping> oh, I replied in haskell-lens
10:46:11 <napping> it sounds like you want to try IncoherentInstances
10:46:16 <rwbarton> kini: so probably the former is using the filepath that you have installed and the latter is installing a new one in the sandbox?
10:46:21 <napping> I hesistate to say you actually *want* IncoherentInstances
10:46:45 <rwbarton> is that actually what IncoherentInstances does?
10:47:37 <rwbarton> oh, maybe
10:47:50 <napping> do you have example code, if it's not "working"
10:48:03 <rwbarton> oh what kind of error are you getting?
10:48:20 <tomejaguar> Actually, I know there is never more than one instance for the same type
10:48:37 <napping> you claimed that even with IncoherentInstances you get some error complaining about overlapping instances
10:48:40 <rwbarton> but...
10:48:43 <edwardk> Incoherent instances are bad and using them should make you feel bad ;)
10:48:50 <tomejaguar> "Overlapping instances for ..."
10:48:53 <kini> rwbarton: no, `cabal install` in my repo doesn't even want to install filepath...
10:49:03 <rwbarton> kini: right because it comes with ghc
10:49:04 <napping> Incoherent instances are bad and using them should make you feel incoherent ;)
10:49:12 <johnw> edwardk: let's rename it to KittenMurderer
10:49:22 <edwardk> johnw: you have core libraries approval
10:49:34 <napping> tomejaguar: I can help no more without seeing the example where IncoherentInstances doesn't work
10:49:34 <tomejaguar> I have `instance Foo a => Bar a where ...` and I have some `instance Bar Whatever`.  But `Whatever` is never an instance of `Foo` so it feels like I should be OK.
10:49:35 <kini> rwbarton: but the latest version of filepath is 1.3.0.2 which is what I have installed, according to `cabal info`
10:49:50 <rwbarton> hm
10:50:03 <rwbarton> then I don't know
10:50:10 <edwardk> tomejaguar: that isn't how instances work
10:50:21 <tomejaguar> edwardk: What do you mean?
10:50:33 <edwardk> tomejaguar: when you have instance Foo a => Bar a -- the existence or non-existence of Foo is _never_ a selection criterion.
10:50:55 <edwardk> it looks strictly at the right hand side of the rule. Bar a    -- says 'yep, a uniies with the type i have and then goes looking for Foo a
10:51:00 <tomejaguar> Sure but in this case I don't care.  Even if there are two instances I just want it to pick one.
10:51:03 <edwardk> it never _ever_ backtracks
10:51:03 <tomejaguar> Arbitrarily.
10:51:08 <edwardk> no you can't
10:51:13 <tomejaguar> Why not?
10:51:24 * hackagebot lens-family-core 1.1.0 - Haskell 98 Lens Families  http://hackage.haskell.org/package/lens-family-core-1.1.0 (RussellOConnor)
10:51:26 * hackagebot lens-family 1.1.0 - Lens Families  http://hackage.haskell.org/package/lens-family-1.1.0 (RussellOConnor)
10:51:31 <edwardk> lets back up and explain what IncoherentInstances _can_ do
10:51:39 <edwardk> and then you can see why it isn't appropriate to this case
10:51:45 <tomejaguar> That sounds like fine thing for me to learn :)
10:51:56 <edwardk> instance selection is done _entirely_ on the heads of the instances
10:52:33 <napping> note "and then you can see why it isn't appropriate to this case" can be correctly said before know what "this case" is
10:52:56 <edwardk> Given a request for Bar (X Y Z) we look around for the instances of Bar that would unify with that type.
10:53:40 <edwardk> then we can rewrite all the uses of Bar (X Y Z) inside the body into uses of the simpler dictionaries in Bar's body.
10:53:50 <danilo2> Hello All! :) I've got a very basic question, but still I'm feeling a little confused right now. I've got a closed type family (I think the problem is the same with open ones) : http://lpaste.net/106365 But GHC does not compile the 3-line example. I understand why - the "b" parameter does not always has the same kind - anyway - is it possible to write type families which operate on arguments with different kinds?
10:54:05 <edwardk> consider -- instance Quux X, Quaffle a => Bar (X a b)
10:54:15 <napping> tomejaguar: this compiles with just OverlappingInstances, I don't know what example you have in mind: http://lpaste.net/106366
10:54:28 <edwardk> now we've rewritten the constraint Bar (X Y Z) into a need for Quux X, and Quaffle Y.
10:54:32 <edwardk> Bar is out of the picture
10:54:35 <edwardk> never to be seen again
10:54:47 <napping> whether or not Quux X and Quaffle Y exist
10:54:49 <edwardk> we can't backtrack to go try another pass if we find out Quaffle Y doesn't exist
10:54:54 <edwardk> we're done with Bar
10:54:59 <edwardk> Why?
10:55:00 <tomejaguar> napping: Interesting.  I was simplifying, obviously.  I wonder what's different in my case.  It's an MPTC.
10:55:15 <rwbarton> danilo2: i don't know what the kinds of Value and IC are; but do you have PolyKinds on?
10:55:17 <edwardk> Because if we can backtrack then someone adding an instance anywhere in any module anywhere in your program can change the meaning of code in an unrelated module!
10:55:36 <edwardk> The open world assumption requires that we not do backtracking on instance resolution
10:55:39 <napping> well, IncoherentInstances is the biggest hammer that exists for forcing GHC to stop complaining about type classes and instead spit out an executable that does something senseless
10:55:47 <tomejaguar> edwardk: Are you saying what happens depends on the order in which GHC comes across the instances?
10:55:48 <edwardk> otherwise semantics will silently change based on addition of new instance constraints
10:55:49 <jkarni> edwardk: but isn’t that the case with overlapping instances too?
10:55:54 <danilo2> rwbarton: I'm sorry, of course, I annotated the code! Brb
10:55:54 <edwardk> reasoning ceases to be monotonic
10:56:11 <edwardk> overlapping instances and orphans are immiscible as well
10:56:11 <jkarni> edwardk: I’ve just been having this CWA discussion on haskell-cafe…
10:56:16 <danilo2> rwbarton: PolyKinds does not help here
10:56:49 <edwardk> tomejaguar: i'm saying it matters that the meaning of your code an change, you could say 'whether or not an instance exists' becomes a predicate available to you in the language
10:56:54 <rwbarton> danilo2: well I didn't think about what you are actually doing, but "type family (:>>) a (b :: k) where" makes it compile
10:56:57 <jkarni> edwardk: Aha, I didn’t know you couldn’t have orphans with overlappinginstances
10:57:01 <rwbarton> i.e. explicitly polykinded
10:57:15 <edwardk> tomejaguar: that is a predicate that changes its answer when a new instance is added to your code
10:57:24 <edwardk> you require a closed world for that to be able to get a consistent answer
10:57:28 <edwardk> that is bad
10:58:13 <zq> man
10:58:17 <tomejaguar> So what does IncoherentInstances say about all this?
10:58:19 <edwardk> instance Foo a => Bar a where fooExist = True; class Trivial a; instance Trivial a; instance Trivial a => Bar a where fooExists = False
10:58:19 <zq> why aren't cabal sandboxes relocatable
10:58:27 <edwardk> IncoherentInstances are about a different problem
10:58:38 <edwardk> say you have class Foo a b
10:58:47 <edwardk> instance Foo Int a; instance Foo a Int
10:58:57 <edwardk> both of those are valid reductions for Foo Int Int
10:58:59 <danilo2> rwbarton: oh, it works indeed. Hmm, what does mean (b :: k) here? I'm feeling very curious right now and I'm going to read again about PolyKinds - I've never met example like that
10:59:09 <edwardk> incoherent instances say 'pick one i don't care'
10:59:16 <danilo2> rwbarton: Or I am simply missign something obvious :)
10:59:18 <edwardk> but it doesn't require backtracking regardless
10:59:45 <tomejaguar> What about two different instances for 'Foo Int Int'?
10:59:51 <haasn> edwardk: What happens in that scenario with OverlappingInstances?
11:00:14 <edwardk> haasn: neither one is more specific
11:00:23 <edwardk> if you have an extra instance Foo Int Int -- then it can reduce
11:00:34 <haasn> So we still get an ambiguous resolution error (without that one)?
11:00:40 <edwardk> IncoherentInstances says 'i'm not interesting in resolving critical pairs myself'
11:00:49 <edwardk> yes
11:01:07 <edwardk> the notion here btw- is exactly the same notion that arises when talking about critical pairs in Knuth-Bendix style completion, fwiw
11:01:08 <edwardk> =)
11:01:25 * hackagebot clckwrks-dot-com 0.3.9 - clckwrks.com  http://hackage.haskell.org/package/clckwrks-dot-com-0.3.9 (JeremyShaw)
11:01:51 <napping> haasn: OverlappingInstances only picks an instance if there is a most general one
11:02:29 <napping> most specific, rather
11:02:54 <edwardk> one of the things i intend to work on at Hac Boston this year is on adding a NoOrphans extension that you can use to say that all the classes defined in that module can never ever have orphans defined for them anywhere. then overlapping instances (for those classes) and SafeHaskell can coexist
11:03:15 <edwardk> it is, in my eyes the first step towards fixing the problems that Backpack has, etc.
11:03:42 <rwbarton> yeah, currently OverlappingInstances are already incoherent
11:04:11 <rwbarton> I guess technically ordinary instances are too
11:04:12 <napping> can't you still have different instances visible in different places from the data type side of non-orphan declarations?
11:04:22 <edwardk> well, IncoherentInstances are about whether you're willing to make an ambiguous choice
11:04:28 <tomejaguar> OK so I do have a most specific instance, so I wonder why it doesn't work.
11:04:35 <haasn> All of this discrimination against orphans :(
11:04:50 <napping> NoOrphans sounds like a reasonable approach for Haskell.
11:05:15 <napping> I wonder how well it could work to have hidden type parameters tracking which instances are used, to get similar coherence
11:05:38 <edwardk> the goal is to either show that that doesn't change the answer that would be produced or provide a concrete counter example
11:06:15 <edwardk> i'm remarkably ambivalent about which outcome we get
11:06:43 <napping> I think you could still have a general Bar a => Foo a instance delcared with the class and solve some constraint with that
11:06:51 <edwardk> if we get a nice story for overlapping instances with NoOrphans then, say, semigroups can shed most of its dependencies and replace them with instance Monoid m => Semigroup m  -- that overlaps
11:06:52 <rwbarton> tomejaguar: you defined these overlapping instances yourself?
11:06:54 <Black0range> Hey guys I'm trying to get the haskell platfrom up and running on mac but it keeps complaining on the command line tools (which i've installed) are there any othe ways to install it?
11:06:58 <napping> and then later on declara a data type T and a Foo T instance, where it would give a different answer
11:07:08 <edwardk> so that users either define a custom Semigroup instance with the data type at the definition site, or they get the behavior of their monoid as a fallback
11:07:47 <edwardk> napping: it is distinctly possible that that attack works
11:07:47 <tomejaguar> rwbarton: I did.
11:08:10 <napping> you could export doSomething :: (Bar a) => ...; doSomthing = ... use Foo a ...
11:08:18 <edwardk> the initial version of this was to do something more baroque, the current version of the proposal is based on a simplification that richard eisenberg came up with to my original problem statement
11:08:29 <edwardk> if we can show that we need more machinery then we may have to build more machinery
11:08:56 <napping> you'd need to go a bit farther to get the use of Foo a inside of doSomething to conflict
11:09:05 <edwardk> exactly
11:09:06 <napping> ah, smuggle the dictionary out in an existential
11:09:18 <napping> I think that does it?
11:09:29 <napping> brb, making counterexample
11:09:35 <edwardk> possibly, this is the attack vector i've been playing with as well =)
11:09:48 <lispy> Really we should start calling the dictionary contraband in the context of existentials
11:11:26 * hackagebot github-types 0.1.0.0 - Type definitions for objects used by the GitHub v3 API  http://hackage.haskell.org/package/github-types-0.1.0.0 (wereHamster)
11:11:51 <tomejaguar> #haskell has taken an advanced turn all of a sudden
11:12:07 <haasn> edwardk: Would it be reasonable to make NoOrphans the default for future Haskell versions, independent of *Instances?
11:12:19 <edwardk> haasn: depends on if it works
11:12:31 <edwardk> haasn: if it does work, then there is the question of how to deal with the packaging problem, etc.
11:12:37 <edwardk> there are second and third order knock-on consequences
11:12:56 <edwardk> you kind of want to have a story for how to deal with the cases where people really _do_ want orphans
11:13:07 <edwardk> which speaks to a packaging problem, like backpack
11:13:13 <haasn> Also, how does OverlappingInstances work with NoOrphans and MultiParamTypeClasses? Can you have something like (C T a b) and (C x I I) overlap in a way that the former gets picked somewhere and the latter gets picked somewhere else?
11:13:18 <edwardk> not sure its solvable for _Haskell_ this way
11:13:39 <edwardk> but it is an interesting research direction for languages
11:14:02 <haasn> It's definitely useful for safe haskell
11:14:18 <haasn> safe haskell was never a part of the standard nor required for all packages; since sometimes you simply can't guarantee it
11:14:18 <edwardk> dcoutts: ping
11:14:40 <haasn> But having the *provable* property that your package is safe-inferred even if it uses overlappinginstances would be useful for safety checking
11:16:54 <napping> edwardk: http://lpaste.net/106368
11:17:08 <edwardk> napping: the main usecase i have for it is for splitting classes like Monad, Monoid, etc. which are okay with incoherence, but yeah i expect the attack works
11:17:37 <napping> if "coherent" returning False is working, then yes it does
11:17:44 <dcoutts> edwardk: pong
11:17:55 <edwardk> dcoutts: gsoc review due ;)
11:18:06 <dcoutts> edwardk: ah yes
11:18:18 <edwardk> chasing everyone down over the next few hours
11:18:40 <dcoutts> thanks for the reminder
11:21:05 <deni> bitemyapp: dude you're killing me with all these awesome links.....it just keeps piling on, i can't possibly read all of it :P
11:24:33 <bitemyapp> deni: you'll live.
11:24:56 <johnw> you can't read them all, but you can certainly read some; the trick is picking the right some
11:25:03 <wz1000> Is it ok if I represent a listlike data stucture as a function? Will it lead to huge performance losses? How does GHC handle functions with a large number of  patterns?
11:25:19 <johnw> wz1000: sure you can, there are libraries on Hackage that do so
11:25:50 <johnw> for example: http://hackage.haskell.org/package/fmlist-0.8/docs/Data-FMList.html
11:26:28 * hackagebot bugzilla 0.2.1.1 - A Haskell interface to the Bugzilla native REST API  http://hackage.haskell.org/package/bugzilla-0.2.1.1 (sethfowler)
11:26:37 <deni> bitemyapp: btw the mic is kinda bad on the screencast thingy
11:26:43 <dcoutts> edwardk: submitted.
11:26:45 <deni> bitemyapp: just saying
11:26:48 <edwardk> thanks!
11:27:39 <wz1000> I just wrote a number of function operating on 'type FList a = Int -> Maybe a'
11:27:55 <benzrf> wz1000: interesting...
11:28:23 <benzrf> that *is* isomorphic to [] isnt it
11:28:32 <benzrf> well no
11:28:37 <benzrf> wz1000: that could allow holes
11:28:38 <bitemyapp> deni: I said as much in the post. I know.
11:28:46 <bitemyapp> deni: I'm going to start monitoring my audio when I record.
11:28:53 <bitemyapp> lessons learned and all that.
11:28:59 <bitemyapp> deni: my second ever screencast. :)
11:29:12 <napping> wz1000: what are you doing with it?
11:29:31 <napping> what kinds of functions did you need to write especially for it?
11:29:53 <wz1000> I'm just experimenting and doing cool stuff like 'lst . (+1)'
11:30:02 <benzrf> wz1000: neat
11:30:09 <benzrf> map is just compo :o
11:30:59 <wz1000> napping: basically, trying to emulate actual lists
11:31:04 <johnw> edwardk: the tests for 'folds' seem to fail because hlint reports an "error" (aka style suggestion)
11:31:13 <edwardk> then fix it ;)
11:31:21 <johnw> fair enough
11:31:22 <napping> A lot of things are probably instances from more general stuff like monoids and such
11:31:22 <wz1000> benzrf:  Yeah, it's very cool
11:31:35 <johnw> commit bit plz?
11:33:37 <johnw> you should have an ekmett organization :)
11:35:27 <wz1000> napping: benzrf: repeat is const :O
11:35:55 <wz1000> well, kind of
11:36:10 <deni> bitemyapp: it's going on the watch list. i'll definetly appreciate better audio next time. keep up the good work.
11:37:44 <deni> bitemyapp: btw question, do you use deriveJSON often or do you write you're own parseJSON functions?
11:42:19 <bitemyapp> deni: were you looking at the Bloodhound video?
11:43:02 <deni> bitemyapp: "how to write typesafe haskell code" is the one i was looking at
11:43:10 <bitemyapp> deni: I didn't talk about JSON in that talk.
11:43:22 <sinelaw> who said JSON?
11:43:23 <deni> bitemyapp: sorry, that question is unrelated to the video
11:43:26 <bitemyapp> deni: JSON is almost never in Haskell convention or the nicest possible structure, so I usually write a manual instance with some exceptions.
11:43:34 <bitemyapp> deni: I demonstrate this process in the other video on that account!
11:43:44 <bitemyapp> deni: I highly recommend the first video I posted.
11:43:55 <deni> bitemyapp: i mostly used deriveJSON but I'm seeing that it's quite limited
11:44:05 <deni> bitemyapp: tnx. will check it out
11:44:33 <bitemyapp> deni: generics and TH are great for JSON when they work, but I don't like uglying up my Haskell records to suit the JSON.
11:44:50 <bitemyapp> deni: it works better when the JSON is based on the Haskell type rather than vice versa.
11:44:54 <robbins> I hate to ask such a basic question on #haskell, although I can't get this snippet to compile (project euler, problem 14). http://lpaste.net/4622114280626454528. I have a feeling, I shouldn't be taking the length.
11:45:00 <bitemyapp> When you have to follow somebody else's lead, writing your own instances is better.
11:45:19 <johnw> robbins: what is the error?
11:45:54 <johnw> that longestCollatz function looks wrong
11:45:58 <johnw> I think you want a "$ map" in there
11:46:01 <johnw> instead of "map"
11:46:29 <robbins> johnw: http://lpaste.net/106370
11:48:18 --- mode: asimov.freenode.net set +o ChanServ
11:48:23 <monochrom> wait, "then g" and "else g"?
11:48:23 <lambdabot> Num a => Maybe a -> (a -> Maybe b) -> Maybe b
11:48:23 * benzrf claps
11:48:23 <benzrf> lambdabot: u there bro
11:48:24 <wz1000> then f, sorry
11:48:40 <wz1000> no, Just evaluate f
11:48:50 <wz1000> then g is correct
11:48:50 <benzrf> wz1000: you just said it's Nothing
11:48:56 <monochrom> alright then what johnw said, except I am inclined to the >=> version
11:48:59 <benzrf> :t (>>=)
11:49:01 <lambdabot> Monad m => m a -> (a -> m b) -> m b
11:49:06 <benzrf> wz1000: inspect the above type
11:49:20 <benzrf> consider if m were Maybe
11:50:26 <Pythonfant> Is there some foldr equivalent that can be terminated?
11:50:44 <Pythonfant> So it doesn't run through the whole list in all cases
11:50:50 <johnw> either use foldM over MaybeT
11:51:07 <johnw> (or EitherT) or use an Either fold value
11:51:17 <coppro> Pythonfant: what do you mean by "terminated?"
11:51:19 <johnw> although the latter will still run through the spine of the list
11:51:40 <coppro> Do you want the calculation to stop at some point and give you a partial list?
11:51:45 <coppro> or is just an efficiency concern?
11:52:04 <Pythonfant> coppro: I want to immediately return a value if a certain condition is met while folding through the list
11:52:19 <johnw> foldM (\acc x -> if P x then return (x : acc) else left ()) [] xs :: EitherT () m [a]
11:52:23 <johnw> Pythonfant ^^
11:52:27 <Pythonfant> johnw: thx
11:52:38 <coppro> yeah, that's what you wan
11:52:40 <coppro> *want
11:52:44 <johnw> Pythonfant: you can encode this much more elegantly using simple-conduit
11:52:50 <johnw> since that's essentially what simple-conduit *is*
11:52:55 <johnw> just an EitherT based foldM
11:53:08 <wz1000> Wait, if 'f' fails, doesn't >>= cause the whole operation to fail?
11:53:18 <johnw> http://hackage.haskell.org/package/simple-conduit
11:53:31 <Pythonfant> I'll take a look
11:53:46 <johnw> if you describe what you're doing, I'll translate it into SC combinators
11:53:47 <wz1000> Oh,i i'm looking for flip (>>=)
11:54:01 <johnw> =<<
11:54:13 <geekosaur> you mean (=<<) ?
11:54:28 <Pythonfant> johnw: thx butu I guess the point of the nicta course is to use what is already provided and learn to implement it yourself
11:54:36 <johnw> oh, then don't use simple-conduit
11:54:39 <johnw> I thought this was for real code
11:55:12 <johnw> anyway, the reason to use foldM+EitherT is because you want to take advantage of the Either monad's ability to "short-circuit with a value"
11:55:26 <johnw> you can also just use plain Either as well, if you don't need a monad underneath
11:55:45 <johnw> foldM (\acc x -> if P x then return (x : acc) else Left ()) [] xs :: Either () [a]
11:55:49 <Pythonfant> yep I think I got that
11:55:57 <johnw> nice
11:56:30 <Pythonfant> so foldM (\acc x -> if P x then return (x : acc) else Nothing) [] xs :: Maybe [a] should do the same for maybe right?
11:57:05 <johnw> yes, just no "exit value"
11:58:43 <wz1000> I don't see how monads solve my problem. I want (\x -> if x == 1 then Just 4 else Nothing) `something` (\x -> if x == 3 then Just 7 else Nothing )
11:58:43 <wz1000> to evaluate to Just 4 when given 1 or Just 7 when given 3, Nothing otherwise
11:59:22 <johnw> ah
11:59:34 <johnw> you want something based around <|>
11:59:35 <johnw> one sec
11:59:37 <Shockk> hello, I had a quick question - I just wondered if there was any more elegant way to do what I'm doing in this snippet of code: https://gist.github.com/shockkolate/c42613238b009314d632
12:01:46 <AlainODea> attoparsec question - is `_ <- char ':'` or `skip (== ':')` preferred?
12:01:56 <adelbertc> any suggestions for a good xmpp/jaber library?
12:02:03 <johnw> wz1000: https://gist.github.com/b042e3b252e93deaa960
12:02:20 <jle`> bitemyapp: ah i see
12:02:23 <johnw> in fact, you only need liftA2
12:02:39 <napping> Shockk: looks fairly decent
12:02:54 <napping> maybe something fancy with lens
12:03:03 <johnw> gist updated
12:03:56 <Nahiyan> I have two quintuples, (a,b,c,d) and (x,y,z,w). I would like the calculate the number of times each respective component is equal, e.g. a=x or b=y
12:04:02 <Shockk> ah I see, thanks
12:04:10 <jle`> Nahiyan: any reason why you can't use a list?
12:04:24 <Nahiyan> well no, just thought it would seem nicer
12:04:24 <johnw> those are quadruples
12:04:31 <Nahiyan> ah okay
12:04:44 <Nahiyan> I was confused whether it was quin or quad
12:05:20 <wz1000> How do you pronounce <|>?
12:05:29 <deni> bitemyapp: i know exactly what you're talking about..."uglying haskell records" I mean.
12:05:41 <deni> bitemyapp: seems i'm going to have to write my own instances
12:05:49 <joshc> wz1000: "or" ?
12:05:53 <johnw> wz1000: "alternatively" maybe?
12:05:57 <Nahiyan> using list comprehensions would yield each possible combination, not component-wise
12:06:02 <johnw> or just 'or'
12:06:06 <Nahiyan> and I'm not sure how to add EQs
12:06:10 <wz1000> thanks
12:06:15 <bitemyapp> deni: right.
12:06:16 <dwcook> @type zipWith
12:06:17 <lambdabot> (a -> b -> c) -> [a] -> [b] -> [c]
12:06:18 <Nahiyan> wait, I think I know
12:06:22 <dwcook> Nahiyan, seems like the function you want, and on lists
12:06:27 <dwcook> if I understood correctly
12:06:57 <dwcook> To be clear - you want, for each pair of components in the same position, to add 1 to a total if they're equal, 0 otherwise?
12:07:02 <Nahiyan> yes
12:07:11 <Trollinator> length (filter id) [a == x, b == y, c == z, d == w]
12:07:43 <dwcook> @type length . filter id . zipWith (==)
12:07:44 <lambdabot>     Couldn't match type ‘[b] -> [Bool]’ with ‘[Bool]’
12:07:44 <lambdabot>     Expected type: [b] -> [Bool]
12:07:44 <lambdabot>       Actual type: [b] -> [b] -> [Bool]
12:07:47 <dwcook> Woops
12:07:52 <dwcook> Oh of course
12:08:29 <dwcook> > (\xs ys -> length . filter id $ zipWith (==) xs ys) [1, 2, 3, 4] [1, 0, 0, 4]
12:08:31 <lambdabot>  2
12:08:39 <Nahiyan> :O
12:08:47 <dwcook> You don't have to write it exactly that way
12:08:53 <dwcook> For that matter that lambda I'd write as a binding
12:08:55 <Nahiyan> what is the use of filter id? Does not filter take a condition value EQ GT or LT?
12:09:00 <Trollinator> sorry, length (filter id [a == x, b == y, c == z, d == w])
12:09:03 <dwcook> @type filter id
12:09:04 <lambdabot> [Bool] -> [Bool]
12:09:13 <dwcook> filter id takes a list of Bools and returns only all the Trues
12:09:20 <Nahiyan> ahhh
12:10:08 <Nahiyan> can $ be used everywhere . can?
12:10:11 <dwcook> No
12:10:22 <dwcook> They are, for the large part, not interchangeable
12:10:29 <dwcook> (.) is function composition, ($) is function application
12:10:33 <dwcook> @type (.)
12:10:34 <lambdabot> (b -> c) -> (a -> b) -> a -> c
12:10:35 <dwcook> @type ($)
12:10:36 <lambdabot> (a -> b) -> a -> b
12:10:50 <Trollinator> ($) is just a fancy way to write id.
12:10:52 <Trollinator> for functions
12:10:55 <dwcook> The cases where you can replace one with another to get the same result are basically puns
12:10:55 <Nahiyan> I do not understand type definitions hmm
12:11:07 <Nahiyan> puns?
12:11:55 <dwcook> It's (almost) a coincidence, basically
12:11:57 <Trollinator> id $ id  is the same as id . id. That's really the only example I can think of where they're interchangeable
12:12:02 <Nahiyan> oh
12:13:01 <dwcook> Nahiyan, anyway, it's important to understand types. If you need help with that, feel free to ask
12:13:22 <dwcook> For example, let's look at the type of ($). In fact let's make it more explicit
12:13:32 <dwcook> ($) :: forall a b. (a -> b) -> a -> b
12:13:35 <Trollinator> basically the type system is why we use haskell.
12:13:43 <dwcook> The foralls are implied, you don't (always) have to write them
12:14:01 <Nahiyan> okay
12:14:01 <dwcook> Anyway that says, for any given types a and b, you give me a function from a onto b, and I'll give you a function from a onto b
12:14:22 <dwcook> You can alternatively read that, with a little bit more imagination, as: You give me a function from a onto b, and an a, and I'll give you a b.
12:14:25 <Nahiyan> I think I understand
12:14:44 <AlainODea> what is the idiomatic way to ignore a character in attoparsec? 1) char ':' 2) _ <- char ':' 3) skip (== ':')
12:14:44 <dwcook> Cool. Does (.) make sense?
12:14:52 <Nahiyan> like f(a) = b, 5a + 3 = b?
12:15:06 <dwcook> Nahiyan, I'm not sure what you're illustrating there
12:15:26 <dwcook> I should note the primary reason we use ($) is because of its fixity and associativity
12:15:38 <Nahiyan> uh
12:15:43 <dwcook> It binds very loosely
12:15:50 <dwcook> So you can often omit parens using it, for example
12:16:04 <dwcook> a (b (c d)) could be written a $ b $ c d
12:16:26 <dwcook> There's also a way to think of that in terms of composition
12:16:28 <Nahiyan> yes but isn't that equal to a . b . c d?
12:16:39 <dwcook> Not quite
12:16:43 <dwcook> It's a . b .c $ d
12:16:48 <dwcook> or (a . b . c) d if you prefer
12:17:18 <Nahiyan> ahh partial functions yes I think I understand a bit
12:17:31 <dwcook> Not sure what you mean about partial functions
12:18:24 <Nahiyan> well since c is a partial function with one more parameter needed, b is composited with c, it still needs that parameter
12:18:30 <cstanfil1> partially applied functions you mean?
12:18:36 <Nahiyan> yes that
12:18:36 <levi> Key fact: Function application is the *highest precedence* operation. Forgetting this is common and leads to much head-scratching until it becomes ingrained.
12:18:38 <dwcook> AlainODea, in general, we prefer writing "x" instead of "_ <- x" in do expressions.
12:18:41 <silasm> Nahiyan: there's a big difference between 'partial' and 'partially applied'
12:18:53 <dwcook> Well, there's also record syntax
12:18:57 <AlainODea> dwcook: perfect. Thanks :)
12:19:08 <Nahiyan> I suppose
12:19:27 <cstanfil1> partial functions mean they're not defined on every input
12:19:29 <levi> "partial function" <- usually means "partially defined", i.e. undefined for some elements of its domain.
12:19:33 <Nahiyan> oh
12:19:43 <Nahiyan> I did not know that name
12:19:48 <dwcook> Yeah, I took it to mean "partially applied" but I still wasn't sure what you meant
12:20:09 <dwcook> It should be noted that Haskell only has functions of a single parameter
12:20:25 <dwcook> Every function has precisely one parameter
12:20:43 <silasm> > head [] -- partial
12:20:47 <lambdabot>  *Exception: Prelude.head: empty list
12:20:53 <silasm> > safeHead [] -- total
12:20:57 <dwcook> You can think of functions as having more than one parameter but only if you understand they really only have one :)
12:20:59 <lambdabot>  Not in scope: ‘safeHead’
12:21:02 <silasm> or not
12:21:34 <cstanfil1> silasm: what's :t safeHead? [a] -> a -> a?
12:21:48 <silasm> cstanfil1: [a] -> Maybe a
12:21:48 <dwcook> [a] -> Maybe a isn't it?
12:21:52 <cstanfil1> ah! okay
12:22:06 <dwcook> The safe package does provide something [a] -> a -> a if I recall though
12:22:10 <rwbarton> "safe" is the wrong word
12:22:28 <Trollinator> Hoogle doesn't know safeHead
12:22:34 <dwcook> Anyway, standard disclaimer about pattern matching often being preferable, yadda yadda
12:22:42 <tdammers> headMay and headDef
12:22:59 <Trollinator> and besides, I don't even see the point in a “safeHead” that returns a Maybe.
12:23:04 <tdammers> they're both "safe" as in "total"
12:23:27 <tdammers> Trollinator: well, if a Maybe is acceptable, then headMay is what you'd want
12:23:37 <deni> are there any helper functions that will let me do a double/tripple/... fmap of a function?
12:23:46 <deni> it for instance i have something wrapper in IO Mabe
12:23:48 <deni> *maybe
12:23:54 <dwcook> deni, you mean like fmap . fmap?
12:23:54 <deni> *wrapped
12:23:56 <MP2E> fmap . fmap
12:23:59 <deni> dwcook: yeah
12:24:01 <dwcook> @type fmap . fmap
12:24:02 <lambdabot> (Functor f1, Functor f) => (a -> b) -> f (f1 a) -> f (f1 b)
12:24:04 <dwcook> I'd just use that
12:24:18 <deni> dwcook: i'm currently using that yes
12:24:29 <deni> was wondering if there is something shorter
12:24:37 <dwcook> Also consider lens, I guess
12:24:42 <dfeuer> I think    uncons :: [a] -> Maybe (a, [a])     is better, but it's not in a standard library that I know of.
12:24:55 <dwcook> The primary spokesperson/author for it is on this channel and is quite helpful
12:26:05 <Trollinator> lens? that domain specific language for producing type error messages?
12:26:06 <deni> dfeuer: that's was directed at me or ?
12:26:22 <deni> hahah nice nick Trollinator
12:26:24 <edwardk> with hask we can use it to produce kind error messages too
12:26:51 <deni> dwcook: the issue i'm facing it that i have to write fmap (fmap _myFun) v
12:26:55 <deni> it's kinda ugly
12:26:59 <dfeuer> Probably cstanfill?
12:27:36 <cstanfill> dfeuer: hm?
12:28:20 <dfeuer> cstanfill, you asked about safeHead. I was suggesting the use of uncons for safe list handling.
12:28:26 <cstanfill> ah
12:28:36 <cstanfill> I was just curious
12:29:16 <dfeuer> uncons x = case x of {[] -> Nothing; (h:t) -> Just (h,t)}
12:29:19 <deni> dwcook: also I don't thinkg I'm ready to ask edwardk questions just yet :P
12:29:29 <cstanfill> yeah I figured
12:29:50 <MP2E> ah crap, how do I use xmonad with cabal sandboxes? And by that, I mean when it's trying to compile my config it fails because it can't find xmonad's includes
12:29:57 <edwardk> deni: fmap.fmap is about as short as you're going to get
12:30:15 <quchen> :t listToMaybe -- = safeHead
12:30:16 <lambdabot> [a] -> Maybe a
12:30:38 <dwcook> let (.) = fmap in (.) . (.) -- :P
12:31:04 <levi> MP2E: You might try doing a 'cabal exec sh' to get a shell with the sandbox config in the environment.
12:31:08 <dfeuer> You could   iterate (.) fmap !! n
12:31:15 <quchen> Nope
12:31:18 <mendozao> So I want to learn functional programming techniques so that I can apply them to my javascript programs - since you folks use this style a lot do you have any book recommendations on functional programming?
12:31:20 <dwcook> Different types, no?
12:31:38 <dfeuer> dwcook, you're probably right.
12:32:05 <dwcook> You could probably cobble together something like that with existential quantifiers
12:32:56 <cstanfill> dfeuer: that seems like it would result in some kind of infinite type error
12:33:11 <cstanfill> unless it was entirely frivolous :p
12:33:14 <dfeuer> Wait, don't you mean   fmap f . fmap f ?
12:33:17 <levi> mendozao: You could try 'Learn You a Haskell' and then use Purescript or a Haskell-to-JS compiler instead of Javascript. Javascript is not really very friendly to functional programming.
12:33:49 <MP2E> levi : that worked, thanks
12:33:57 <tnks> mendozao: I'm a bit frustrated by all the books out there, but there was a time I liked Graham Hutton's Programming in Haskell book.
12:33:58 <dfeuer> What the heck is fmap . fmap ?
12:34:11 <albeit> :t fmap . fmap
12:34:12 <lambdabot> (Functor f1, Functor f) => (a -> b) -> f (f1 a) -> f (f1 b)
12:34:14 <MP2E> dfeuer: it pushes a function two levels down into a structure into of one
12:34:24 <dfeuer> Ah, I see.
12:34:35 <cstanfill> :t fmap `asTypeOf` (fmap . fmap)
12:34:36 <lambdabot>     Occurs check: cannot construct the infinite type: a ~ f0 a
12:34:36 <lambdabot>     Expected type: (a -> b) -> a -> b
12:34:36 <lambdabot>       Actual type: (a -> b) -> f0 a -> f0 b
12:34:40 <tnks> the problem I have is that I've learned Haskell clumsily through so many weird sources (starting with the Gentle Introduction) that I've lost perspective of what it's like to learn Haskell from scratch.
12:35:02 <MP2E> instead of one*
12:35:03 <MP2E> heh
12:35:04 <MP2E> whoop
12:35:06 <mendozao> thanks for the suggestions guys
12:35:13 <cstanfill> is there not a Functor instance for composition? I don't know how you'd write one
12:35:18 <cstanfill> syntactically
12:35:25 <cstanfill> but it seems entirely sound
12:35:53 <quchen> data Compose f g x = Compose (f (g x)); instance (Functor f, Functor g) => Functor (Compose f g) where …
12:36:21 <cstanfill> well but that requires that you write the Compose out
12:36:26 <mendozao> Thing is - I don't necessarily have a need to learn Haskell - I just want to pickup some useful concepts of functional programming
12:36:31 <dwcook> cstanfill, as opposed to what?
12:36:48 <mendozao> frustrating that there isn't much out there for JS
12:37:01 <dwcook> mendozao, Eloquent JavaScript will give you some as it applies to JS.
12:37:12 <quchen> dwcook: -XAutoDeriveEverythingCruiseMode ;-)
12:37:17 <cstanfill> :P
12:37:37 <MP2E> should be called -XCruiseControl :P
12:38:41 <tdammers> mendozao: FP concepts didn't really "click" for me until I learned Haskell
12:39:02 <cstanfill> dwcook: I dunno. I guess that method is probably slick enough
12:39:29 <levi> mendozao: Partly that is because Javascript only has a bare minimum of support for functional programming, and it very much goes against the grain of the language.  You can sort of apply some of the concepts, but they are far more powerful when used in the context of a language that is designed around them.
12:39:39 <dwcook> cstanfill, it's probably the best we can expect given the design of Haskell, I guess
12:39:43 <cstanfill> yeah
12:40:04 <cstanfill> there's something similar in Data.Functor.Compose with a newtype doing the same thing
12:40:32 <cstanfill> (apparently)
12:40:41 <mendozao> silly question, how you highlight a person's name when responding to them?
12:40:54 <quchen> Tab does that in many clients
12:40:56 <MP2E> type their name exactly as is, or easier, type the first few letters and hit tab
12:41:02 <quchen> mendo<tab> → mendozao
12:41:05 <int-e> mendozao: you don't. many clients do it automatically
12:41:19 <mendozao> quchen: test
12:41:36 <dwcook> Note that there were two questions inferred here: How do you automatically type someone's name? How do you make someone's client tell them "Hey, someone's talking to you"?
12:41:52 <MP2E> I answered both ;)
12:42:00 <quchen> Step 1. Call yourself fmap. Step 2, be automatically talked to.
12:42:04 <MP2E> hahaha
12:42:05 <dwcook> quchen, XD
12:42:07 <mendozao> tab key is useful thanks guys
12:42:39 <tdammers> levi: I wouldn't say it goes against the grain - it's just a lot less obvious when you see it in JS than when you see it in Haskell or ML or some such
12:43:18 <quchen> Using JS to learn FP is like learning to ride a bicycle under water. Can be done.
12:43:32 <benzrf> quchen: nice
12:43:50 <quchen> It would probably be easier to use JS to implement Haskell and then use that to learn FP ;-)
12:44:00 <hiptobecubic> As far as i can tell, the only thing "functional" about JS is the support for HOF
12:44:11 <benzrf> quchen: how about, using an amphibious car to learn how to sail
12:44:17 <dwcook> It's also got limited support for immutability
12:44:35 <hiptobecubic> so does C
12:44:39 <tdammers> dwcook: limited? more like, hardly any
12:45:22 <dwcook> tdammers, aren't those synonymous? :P
12:45:22 <tdammers> hiptobecubic: C at least makes mutability somewhat explicit
12:45:22 <jle`> hiptobecubic: it has lambdas
12:45:22 <mendozao> wish there was a resource to just show me the concepts
12:45:22 <mendozao> without any language tied to it
12:45:22 <dwcook> mendozao, did you check out the book I suggested?
12:45:22 <dwcook> Oh
12:45:22 <quchen> tdammers: By using characters for things that are mutable, and whitespace for things that are not? :-x
12:45:22 <mendozao> dwcook: yes, it only has a small chapter on it
12:45:24 <jle`> lambdas and first-class objects
12:45:26 <mendozao> wanted a bit more meat
12:45:26 <jle`> er
12:45:28 <jle`> first-class functions
12:45:30 <dwcook> Unfortunately it's hard to express these concepts unattached in a manner that they're still easy to grasp
12:45:34 <nexx> is learning to ride a bicyle that hard? I would imaging you woudn't fall easily
12:45:42 <dwcook> Not to mention there is a wide variation on what is considered functional programming
12:45:47 <tdammers> quchen: variables are passed by-value, always
12:45:47 <dwcook> It will vary from community to community
12:45:52 <hiptobecubic> sure
12:45:57 <tdammers> quchen: if you get a pointer, whatever it points to is mutable
12:46:10 <hiptobecubic> but by that reasoning, python also counts, which is ridiculous
12:46:19 <tdammers> quchen: but if it's not a pointer, the mutability is local to the current scope
12:46:37 <jle`> it might be the idioms too
12:46:44 <joelteon> is there a library like Text.Printf that produces Texts?
12:46:44 <Marquis> hello haskellers, i need your help. I want to use the shuffle' function from the System.Random.Shuffle library (which has the type : shuffle' :: RandomGen gen => [a] -> Int -> gen -> [a]). I want to use the shuffle' function within another function that does and may not get the RandomGen. So i need to generate the RandomGen within the function. How is that possible?
12:46:45 <jle`> javascript is full of hof idioms
12:46:57 <jle`> almost all idiomatic javascript involves h.o.fs
12:47:03 <rwbarton> even lisp would count!
12:47:13 <hiptobecubic> tdammers, you can have const pointers to consts as well
12:47:33 <dwcook> Marquis, you cann't generate randomness from within a pure function. But you may thread a RandomGen through it from another source, such as IO
12:47:36 <dfeuer> Marquis, "does and may not"?
12:47:36 <ij> Marquis, You'll have to give something more to it, if you want it to not be the same.
12:47:42 * quchen suggests renaming HOF to F and introducing LOFs to other language terminology.
12:47:52 <benzrf> quchen: :3
12:48:04 <dwcook> Marquis, you can also pick an arbitrary RandomGen purely, but it will be the same one every time :P
12:48:29 <vova> hi, could someone help me with the authorization using cookie? If it's possible please send me the link to the code example.
12:49:12 <jle`> link to obligatory xkcd
12:49:12 <dfeuer> I think there's also a case to be made for using unsafePerformIO to seed random number generators for Las Vegas, but not Monte Carlo, algorithms.
12:49:18 <ij> jle`, return 4?
12:49:24 <jle`> http://xkcd.com/221/
12:49:57 <tdammers> vova: we'll need a bit more information I'm afraid
12:51:35 <dfeuer> It may also make sense to use unsafePerformIO to implement parallel algorithms that use nondeterministic concurrency internally.
12:52:08 <vova> I send POST request with the login&password to the server (Network.Client). Server responds me with the cookie. I send GET request with these cookies.
12:52:14 <quchen> It makes sense to use unsafePerformIO if the algorithm is demonstrably pure and using IO cannot be avoided internally. See the FFI for example.
12:52:47 <jle`> i think it depends on the semantics too
12:53:10 <quchen> Are Vegas algorithms pure? Hardly. Explicit generator or IO it is.
12:53:11 <vova> But It seems that the server does not get them or they are truncated somehow ... I do not know.
12:53:19 <ij> Does IO internally use unsafePerformIO?
12:53:28 <dwcook> Marquis, one thing you could do is build your computation on functions that look like this: (RandomGen gen) => … -> gen -> (result, gen) (where … is whatever parameters beside the gen you need)
12:53:33 <rwbarton> why is it not pure?
12:54:02 <dwcook> Marquis, this is also equivalent to using the State type, which gives you certain compositional advantages
12:54:04 <Marquis> let me explain further. i want to use kmeans as algorithm and give a partition function as argument like this (Int -> [a] -> [[a]]). but i would like to use the shuffle function so i can permute my input.
12:54:08 <rwbarton> there are lots of pure functions whose runtime is rather unpredictable
12:54:20 <quchen> rwbarton: Well, if you feed it a generator it is pure of course. But someone said that unsafePerformIO-ing that generator is alright for some reason.
12:54:25 <cstanfill> not sure if I should be glad that `unsafePerformIO $ getStdGen  >>= (return . fst . next)` always returns the same thing it did the first time in ghci
12:54:43 <rwbarton> yes, it's fine to do so
12:54:47 <cstanfill> (not that I'd ever do that for real)
12:54:59 <rwbarton> well
12:55:08 <dfeuer> quaestor, Las Vegas algorithms are ones that give the same results regardless of the random numbers generated, but may do so more or less quickly.
12:55:21 <rwbarton> it's a bit tricky I guess
12:56:24 <cstanfill> oh wait, getStdGen vs. newStdGen
12:56:48 <hiptobecubic> blargglglewarr
12:57:17 <quchen> Hmm, it seems like I've been calling the wrong thing "Vegas algorithm" for about 4 years. The more you know
12:58:20 <Rc43> Are intersection types connected to type classes?
12:58:28 <dwcook> Marquis, in short, I think promoting your entire computation to use State would make the most sense. For the parts of it that don't require the randomness, you can use State's return and liftM and such to write them purely but still compose them with stateful computations.
12:59:14 <jle`> Marquis: if you are only shuffling once
12:59:19 <jle`> then no need for any monads
12:59:27 <Lutin^> Has anyone done any webscraping in Haskell?
12:59:44 <tdammers> vova: what are you trying to do? what does your code look like so far? where are you stuck?
12:59:45 <jle`> just use IO to get the stdgen
12:59:52 <Lutin^> Looking into Selenium at the moment as it seems to be one of the only options unless I want to write phantom.js bindings
12:59:55 <jle`> write your pure StdGen -> Result function
13:00:05 <jle`> and use fmap to turn it into an IO StdGen -> IO Result function
13:00:13 <jle`> voila
13:01:35 * hackagebot pipes-text 0.0.0.12 - Text pipes.  http://hackage.haskell.org/package/pipes-text-0.0.0.12 (MichaelThompson)
13:02:34 <AlainODea> Lutin^: https://rawgit.com/ndmitchell/tagsoup/master/tagsoup.htm
13:02:38 <dwcook> Marquis, please voice your concerns and confusions here rather than in PM. jle`'s given you good advice for example
13:03:22 <Lutin^> AlainODea: Yeah I looked at that but I basically need something with a javascript engine
13:03:26 <Lutin^> As it's a dynamic page
13:03:33 <AlainODea> Ah okay.
13:04:08 <vova> tdammers: I'm trying to download the page. Web-site requires the authorization. And It's seems ok, I get the cookies. But seems they are truncated or so
13:04:46 <napping> is there a lower-precedence version of . ?
13:05:10 <vova> tdammers: POST -> cookies -> GET -> failed ("You can not allow to read this page")
13:05:50 <om-foxy> Has anyone seen the package `hs-nombre-generator` on Hackage?  There is a web site hard coded and I don't speak the language it is written in.  I'm just wondering whether this is a dodgy package.
13:06:34 <Lutin^> Man today is a scraping day
13:07:28 <rwbarton> Lutin^: do you need to interact with the page, or just wait for js onload or similar to populate it?
13:07:54 <ccapndave> I have a function into which I can't pass a seed, but I need to get a random number in there.  Is there a hacky way to get a random number?
13:08:06 <vova> tdammers: I'm using Network.Client module.
13:08:20 <darthdeus> is there an easy way to check if something is tail recursive?
13:08:40 <Lutin^> rwbarton: I'm disabling JS to see if I can still interact with it
13:08:48 <Lutin^> It's for my Universities website
13:08:53 <Lutin^> Trying to scrape course listings
13:09:12 <AlainODea> Lutin^: it looks like Charles Strahan was considering a Haskell port of Capybara. That would be amazing if it exists somewhere.
13:09:37 <AlainODea> Lutin^: what's the site address. I can make a quick assessment of what a static scraper can do
13:09:50 <Lutin^> Well it looks like Selenium comes with Haskell bindings
13:10:07 <Lutin^> lol poo
13:10:14 <Lutin^> I can't even get to the main page without JS
13:12:10 <napping> Shockk
13:12:14 <napping> seems to have left
13:12:36 <napping> and here I was ready with a scary lens solution
13:12:43 <wz1000> If I have a function with a large number of patterns, does pattern matching run in constant or linear time?
13:13:14 <rwbarton> it depends
13:13:18 <Lutin^> AlainODea: omg seriously they use javascript to generate the login form :X
13:13:21 <napping> If it's a lot of constructors for the same data type it should be faster than liner
13:13:28 <Cale> wz1000: The first pattern to match wins, but there are things which happen to decompose nested patterns into simpler ones
13:13:30 <rwbarton> it might also be in between
13:13:41 <jle`> Marquis: do you know about typeclasses?
13:13:44 <napping> if it's more like Z / S Z / S (S Z)/ S (S (S Z)) it just simply takes linear work
13:13:50 <AlainODea> Lutin^: Such JavaScript. Very dynamic. Many bugs. Wow. Doge U.
13:14:00 <tdammers> vova: not an expert on that one, sorry
13:14:06 <tdammers> vova: maybe someone else can help out
13:14:21 <Lutin^> AlainODea: Like it's literally just document.writeln(html)
13:14:21 <AlainODea> Lutin^: terrible. They must have a flat file or course calendar somewhere
13:14:31 <Marquis> i know a bit about them, have used them but i am not very fluent
13:14:34 <vova> tdammers: Ok, thank you for trying to help.
13:14:39 <wz1000> I'm looking at cases like f 0 = ..., f 1 = ..., f 2 = ... and so on until f _ = Nothing
13:14:52 <rwbarton> that will use binary search most likely
13:15:02 <jle`> really?
13:15:06 <napping> That's a bit special because it's literals rather than constructors
13:15:10 <rwbarton> assuming those are Ints
13:15:14 <napping> I don't know about that, maybe just compile and see
13:15:15 <Marquis> yes
13:15:18 <rwbarton> or some other plain old integer type
13:15:30 <wz1000> Yes, those are ints.
13:15:37 <jle`> check the core
13:15:52 <napping> Oh yeah, there's probably no good way to compile that as a function of a type like (Num a , Eq a) => a -> ...
13:16:27 <wz1000> Wow, GHC actually optimises that?
13:16:33 <Marquis> i tried to make a typeclass for that, BUT i can not put an 'a' in the declaration
13:16:54 <napping> jle`: I was wondering more what kind of assembly you get from a pattern match on a type with many constructors, whether it's a jump table or what. Core it too high level for that
13:17:04 <rwbarton> for a type with many constructors you get a jump table
13:17:11 <Lutin^> AlainODea: They have a static course listing, but the schedule is done through form submissions
13:17:24 <Lutin^> AlainODea: Might be able to just replay the network requests
13:18:30 <AlainODea> Lutin^: very likely. Unless they are generating a nonce for each form you should be able to replay POSTs including the login you need to obtain a cookie for the rest
13:18:54 <jle`> napping: ah yeah. you're right
13:18:55 <Pythonfant> ajcoppa: thx for recommending (and creating?) the nicta course, I now worked through list, functor and applicative and it's a lot of fun
13:19:00 <jle`> or
13:19:03 <jle`> i suspect you'd be right
13:19:05 <ajcoppa> Pythonfant: excellent!
13:19:13 <ajcoppa> keep pushing. it gets even more fun
13:19:32 <ajcoppa> i didn't create the course -- tony morris (dibblego in here) and [mth] did
13:19:50 <Pythonfant> then thx to them :)
13:23:57 <Lutin^> AlainODea: yeah this is rediculous
13:24:09 <Lutin^> Almost 5 redirects on login
13:24:24 <ccapndave> Hey everyone - no matter how many time I call this function, it always returns the same value https://gist.github.com/ccapndave/619816e4e0e12deb8e1e
13:24:34 <ccapndave> Shouldn't the unsafe time be updating constantly?
13:25:04 <wz1000> Wow, I forgot to close GHCi, and it just ate up 13 gigs of ram and forced X to swap
13:25:04 <dfeuer> Lutin^, I'm not the least bit surprised. Universities rarely seem to realize that they have intelligent undergrads in their CS departments who could write good code; they just contract it out to craptastic companies.
13:25:23 <sharyari> Hi. I'm implementing something with the HashSet datatype, (I assume it's similar to HashMap). But still lookups seem to be rather slow. I'm in a situation where perfect hashing would be possible, is there a way to change the hash function used?
13:25:42 <rwbarton> ccapndave, welcome to unsafePerformIO
13:25:47 <rwbarton> this is a perfect example of how not to use it
13:25:51 <ccapndave> rwbarton I see :)
13:26:12 <Lutin^> And they generate a UUID serverside that they put as a constant in a javascript function that they use to send with the form
13:26:13 <ccapndave> rwbarton I'm in a bit of a pickle though, as this score function is being called from a library I didn't write and therefore I *can't* pass in a random sequence or anything
13:26:20 <Lutin^> Looks like Selenium it is
13:26:28 <ccapndave> rwbarton http://hackage.haskell.org/package/GA-1.0/docs/GA.html
13:26:31 <rwbarton> what type is it supposed to have?
13:26:36 * hackagebot th-build 0.4.0.0 - More convenient construction of TH ASTs  http://hackage.haskell.org/package/th-build-0.4.0.0 (DanielSchuessler)
13:26:55 <ccapndave> rwbarton They pass seeds into all the functions except for score, but I actually need a seed for score since I score by running a simulation
13:27:10 <ccapndave> rwbarton I need a random int to be a seed for a generator
13:27:39 <rwbarton> it looks like you can choose a monad to run everything in
13:28:09 <ccapndave> Its running in IO
13:28:18 <ccapndave> That's why I need to put the return $ in there, right?
13:28:19 <hexagoxel> wz1000: did you ctrl-c some evaluation before? i think i have had memory leaks after that before, but not otherwise
13:28:19 <dfeuer> ccapndave, yeah, don't do that. More context needed.
13:28:33 <rwbarton> well in that case what you wrote is completely wrong :)
13:28:46 <wz1000> hexagoxel: yes, i did
13:28:46 <ccapndave> That does not surprise me ;)
13:28:49 <rwbarton> you want score :: IO (Maybe Integer) or something?
13:29:10 <ccapndave> https://gist.github.com/ccapndave/af2f874b605122ce9608
13:29:16 <ccapndave> Here is the real function
13:29:24 <ccapndave> IO (Maybe Double)
13:29:38 <rwbarton> so the real type of score is?
13:29:49 <rwbarton> something -> something -> IO (Maybe Double)?
13:29:54 <dfeuer> ccapndave, no. Just ... no.
13:30:30 <rwbarton> then just use do notation or whatever and build an IO action that reads the time and builds a seed etc.
13:30:31 <ccapndave> rwbarton something -> SlotMachine -> IO (Maybe Double)
13:30:58 <ccapndave> I'm allowed to use do?
13:31:05 <ccapndave> I thought that was only allowed in main
13:31:22 <rwbarton> aha
13:31:24 <rwbarton> yes
13:31:29 <dfeuer> ccapndave, do is allowed any time you're building a Monad.
13:31:41 <rwbarton> for now we can stick to IO
13:32:39 <Lutin^> AlainODea: Have you ever used selenium?
13:32:42 <Lutin^> This is beautiful...
13:32:49 <dugan> Is there any way I can achieve dynamic like behavior such as this? http://lpaste.net/106372
13:32:56 <hiptobecubic> selenium is a pretty cool guy
13:33:09 <dfeuer> That's probably reasonable for now, rwbarton. But yes, do can be used to put together IO actions *anywhere*
13:33:13 <corgifex> dugan: lenses!
13:33:34 <ccapndave> Oh hooray
13:33:38 <ccapndave> Thanks everyone :)
13:33:43 <dugan> corgifex: yeah I am aware of those, but I didn't really want to make them a dependency
13:33:51 <ccapndave> https://gist.github.com/ccapndave/af2f874b605122ce9608
13:33:54 <ccapndave> That's a bit nicer eh
13:34:02 <rwbarton> yes
13:34:03 <jle`> dugan: what are you asking?
13:34:15 <AlainODea> ccapndave: nice refactor :)
13:34:23 <rwbarton> "unsafePerformIO action" basically means "I don't care when or how many times action gets run"
13:34:42 <dfeuer> Much better, yes.
13:34:45 <merijn> ccapndave: Do notation is a really simple syntactic sugar which is usable anywhere and also for other things than IO, a good explanation is: https://en.wikibooks.org/wiki/Haskell/do_Notation
13:34:48 <rwbarton> your action was a constant (getPOSIXTime) so ghc figures, why not just run it once when it is first needed
13:34:48 <ccapndave> i.e. circumventing the requirement that inputs are deterministic
13:35:02 <dugan> jle`: Well I was wondering if I could achieve behavior similar to that in the lpaste I just put up. I don't HAVE to get it working that way, but I thought it would be nice...
13:35:05 <ccapndave> Holy crap
13:35:09 <ccapndave> I think my application might be working
13:35:28 <jle`> dugan: similar in what way...?
13:35:35 <jle`> what's wrong with how you have it set up now?
13:35:46 <corgifex> it doesn't work
13:35:51 <jle`> ah
13:36:05 <jle`> yes that would be a good answer
13:36:10 <dfeuer> There are ways to make unsafePerformIO behave, but they seem to be very brittle in general, and there isn't generally any guarantee that what works in one version of GHC will work in the next.
13:36:14 <dugan> yeah, because at compile time, it sees that "field" doesn't exist
13:36:31 <jle`> you might be able to use lens-family if you want, but lens isn't thaaat bad to pull in
13:37:06 <jle`> you can write "lenses from scratch" if you really want
13:37:22 <ccapndave> Arghh!
13:37:24 <ccapndave> It works!
13:37:27 <dugan> jle` yeah, its no big deal really. I was just wondering if I could do it with some data/typeable magic
13:37:31 <dugan> or something... : )
13:37:33 * ccapndave dances with joy
13:38:00 <jle`> dugan: you can do it using generic/data magic perhaps
13:38:03 <jle`> but
13:38:06 <jle`> really this is the sort of use case where lens shines
13:39:17 <jle`> one thing you can do to is to make data Updater s t b = Updater { update :: s -> b -> t }
13:39:50 <jle`> and _bar = Updater (\foo newbar -> foo { bar = newbar })
13:39:53 <jle`> then you can do
13:39:58 <jle`> update _bar foo 2
13:40:00 <jle`> ;)
13:41:16 <jle`> dugan: you'd have to write your own Updaters manually..and also your Updaters don't compose too nicely.  but.
13:41:31 <jle`> it basically gives you the syntax you want :)
13:41:48 <dugan> jle` Thats a handrolled lens setup right?
13:42:07 <jle`> sort of kind of
13:42:22 <dugan> okay, well I'll give it a whirl
13:42:26 <dugan> thanks
13:43:16 <jle`> a lens has both an update and a "get".  and faculties so that you can compose them nicely
13:44:23 <jle`> if you use lens-family, you can make them
13:44:44 <jle`> if you are really afraid of the dependencies for some reason
13:45:00 <chrisdone> lol
13:45:30 <chrisdone> jle`: you talk like cabal hell is some weird far away issue
13:45:57 <chrisdone> who even has dependency issues?? (゜。゜)
13:46:29 <jle`> chrisdone: welll i was specifically trying to make a point about type system offering maintainability benefits >_______>
13:46:50 <jle`> i probably shouldn't have generalized that to 'code in haskell is maintainable, period'
13:48:08 <jle`> dugan: you can say `foo = lens bar (\foo newbar = foo { bar = newbar })` to get a lens that does what you want
13:48:21 <jle`> (the firs tthing is the "getter", the second thing is the "setter")
13:49:34 <jle`> dugan: er sorry, _bar = lens bar (\foo newbar -> foo { bar = newbar })
13:49:50 <jle`> dugan: then you can do set _bar 2 foo to do what you want
13:50:15 <napping> ccapndave: unsafePerformIO isn't telling the compiler "side effects, please", it's telling it "I'm using IO in a way that you are too stupid to see is actually pure"
13:50:56 <ccapndave> napping Oh I see - hence why it thought it was a constant
13:51:01 <Lutin^> AlainODea: With Selenium you install a Firefox addon and basically just do what you want to automate, and it records it and you can play it back and export to Ruby, Python, Java and C#
13:51:14 <Lutin^> So I have it working in Python just need to turn into Haskell :)
13:51:16 <napping> and then it goes "Hmm, I don't quite see how that getTimeOfDay call is pure, but I guess I'll trust you. No need to call it more than once if it's pure"
13:51:39 <AlainODea> Lutin^: nice!
13:52:05 <Lutin^> And it actually just 'drives' the browser to do the scraping
13:52:22 <Lutin^> Not as headless as I'd like, but a lot more robust for site testing, which is what it's for :P
13:54:29 <AlainODea> Lutin^: https://hackage.haskell.org/package/webdriver
13:54:54 <Lutin^> Yeah I know, reading the docs for it already :)
14:09:26 <sharyari> Does anyone know if one can change the hash function used by datastructures with hashing, in this case HashSet?
14:09:40 <joelteon> yes; no
14:09:51 <joelteon> yes I know, and no you can't unless you want to write your own.
14:09:56 <napping> It's using a typeclass?
14:09:58 <napping> You could maybe newtype
14:10:05 <joelteon> and by "your own" I mean your own HashSet
14:10:52 <joelteon> oh, well, maybe you could use a newtype wrapper, yeah
14:10:54 <sharyari> Then I guess I'm screwed :P
14:11:00 <joelteon> yeah, do that
14:11:18 <napping> Do you want to provide a different hash?
14:11:27 <sharyari> Ok. I'm new to haskell, just been doing this a few days. What would I google for, if I want to use a newtype wrapper? :)
14:11:28 <napping> If you want to dynamically provide a hash, that gets tricky
14:11:46 <napping> you'd just go newtype MyType = MkMyType OldType
14:12:09 <sharyari> ok, but how does that help?
14:12:15 <napping> and then write instance Hashable MyTable where hash (MyType oldVal) = .. something *way* better than the existing instance for OldType ...
14:12:21 <napping> if the problem is just a mising/bad hash
14:12:24 <sharyari> ah
14:12:47 <sharyari> well thank you for the help then
14:13:23 <napping> are you trying to do something fancier than that?
14:14:32 <napping> what was that library edwardk did for threading values?
14:14:41 <chrisdone> constraints?
14:14:50 <napping> Ah, I think "reflection"
14:15:11 <napping> https://www.fpcomplete.com/user/thoughtpolice/using-reflection#dynamically-constructing-type-class-instances
14:16:20 <napping> If it's really necessary to pick a hash function at runtime, for perfect hashing or something, you could maybe do it that way
14:17:35 <napping> To put it another way, that nicely packages some code that abuses GHC's internals enough to pass ordinary values where type class dictionaries would be expected
14:17:55 <corgifex> the blackest of magics
14:18:07 <napping> yeah, using unsafeCoerce to turn a => into a -> is pretty black
14:18:30 <MP2E> I didn't even know you could do that o.o
14:18:39 <cstanfill> oh my
14:18:53 <napping> maybe a few shades lighter than getting a Ptr and poking around at heap representations yourself, but definitely up there
14:18:57 <corgifex> to be fair, the older implementation doesn't construct dictionaries manually
14:19:31 <napping> I tried some code like that, but ran into too many segfaults between working attempts to ever take it seriously
14:23:25 <dfeuer> edwardk, why define Additive as a subclass of Functor with additive group operations, rather than subclassing some sort of Group?
14:23:59 <edwardk> dfeuer: this is going to take a bit =)
14:24:31 <edwardk> dfeuer: the group would be nice and precisely what it should mean.. and utterly useless in the presence of polymorphic recursion, etc.
14:24:42 <dfeuer> edwardk, I also don't quite understand why a vector would be a Functor in general.
14:24:51 <edwardk> lets define what a vector space is
14:25:01 <edwardk> and we'll see the functoriality of it in passing
14:25:05 <ASHPrime> Evening friends
14:25:25 <edwardk> all vector spaces are 'free' vector spaces
14:25:32 <edwardk> this is one of the classical results of linear algebra.
14:25:44 <dfeuer> "Free" goes over my head.
14:25:50 <implementation> is it possible to execute template haskell on one machine and dump the result simple haskell code, such that i can compile that on another machine?
14:25:56 <edwardk> this means that lots of things you have to put up with when talking about modules, certain exotic kinds of modules, don't exist when you say you're building over a field.
14:26:21 <edwardk> here it just means that a vector space is always equivalent to r^n for some field r and some 'basis set' n.
14:26:30 <edwardk> R^2 etc are familiar to you
14:26:34 <dfeuer> Ah, are you talking about the fact that every finite-dimensional vector space is isomorphic to tuples of scalars?
14:26:45 <edwardk> but i'm saying even if its infinite
14:26:50 <carter> napping: MP2E  cstanfill  the 7.8 version of the reflection code has more baked int support right edwardk ?
14:26:55 <edwardk> it has the form n -> r   for some choice of n
14:27:09 <edwardk> n may be an infinitely big scary set
14:27:22 <edwardk> you may have to invoke classes rather than sets
14:27:28 <dfeuer> Youch.
14:27:29 <napping> carter: I have no idea, I was just vaguely recalling the edwardk et. al had packaged up the unsafeCoerce dictionary hack
14:27:42 <edwardk> but we can think of it abstractly as a function that given an element of the basis set i can tell you a coefficient for it
14:27:43 <carter> napping: i'm *saying* ghc 7.8 has built in support for the proxy hack
14:27:49 <carter> or part of it at least
14:28:14 <edwardk> carter: we can handle KnownNat n => Reifies n Integer  -- in current reflection
14:28:31 <carter> i was thinking more of the proxy# stuff that was added
14:28:42 <carter> edwardk: btw, the bug fix + cabal test prs are ready
14:28:43 <carter> :)
14:28:43 <edwardk> dfeuer: but the key here is that all vector spaces can look like (e -> r) for some basis e. (switching notation)
14:28:49 <carter> about to open the vector master pr
14:29:04 <edwardk> carter: for vector stuff, ping dolio
14:29:06 <dfeuer> edwardk, I must still be missing something; in general, applying a linear transformation, applying a function to each component, and then reversing the transformation does not give back the same thing as just applying the function to each component, right?
14:29:08 <carter> yup
14:29:47 <edwardk> dfeuer: i never said that it did. just said that you can view Complex a     as either   (a,a)  or as Bool -> a
14:29:50 <dfeuer> OOK.
14:29:54 <dfeuer> Go on.
14:29:55 <edwardk> there representations are equivalent
14:30:03 <edwardk> er these representations
14:30:24 <dfeuer> OK.
14:30:35 <edwardk> so that all vector spaces have this form is actually a deep result
14:30:43 <edwardk> we talk about the dual of a vector space a lot too
14:30:45 <edwardk> what is that?
14:31:01 <edwardk> the dual of a vector space is its set of 'linear functionals'
14:31:14 <dfeuer> Yeah, I never quite understood that stuff.
14:31:26 <edwardk> given a vector space V, V*    is   the space of functions from V -> R
14:31:38 <edwardk> you know what a dot product is?
14:32:05 <dfeuer> An inner product?
14:32:08 <edwardk> yes
14:32:12 <vanila> ho so the functional V -> R is just the dotproduct of that vector with the one you pass in
14:32:14 <edwardk> was using the term you see first =)
14:32:19 <vanila> and you can recover the original vector with it
14:32:21 <edwardk> dot :: V -> V -> R
14:32:34 <edwardk> takes a pair of vectors and gives back a scalar
14:32:39 <edwardk> curry it
14:32:44 <Sculptor> fair trade
14:32:50 <edwardk> and apply it to a vector
14:32:52 <edwardk> and you get V -> R
14:33:06 <cstanfill> though you can only do this if the first argument is finitely, uh, supported?
14:33:07 <edwardk> but we said vector spaces have that form...
14:33:13 <dfeuer> Wait, what?
14:33:14 <carter> edwardk: pinged him on the GH
14:33:24 <dfeuer> Sorry, my linear algebra is ... not good.
14:33:31 <edwardk> so we can make a _dual_ vector space, (e -> r) ->_L r   where the arrow is required to be linear
14:33:31 <gamegoblin> @pl \a -> $ \b -> f c b a
14:33:32 <lambdabot> (line 1, column 7):
14:33:32 <lambdabot> unexpected "$"
14:33:32 <lambdabot> expecting lambda abstraction or expression
14:33:50 <sharyari> napping: Could you perhaps explain again how the newtype thing would word? I don't seem to be able to define instance hashable
14:33:50 <gamegoblin> @pl \a -> f $ \b -> g c b a
14:33:50 <lambdabot> f . flip (g c)
14:34:18 <napping> sharyari: Is the problem that you want to use a key but don't like the existing hash on the key?
14:34:22 <edwardk> just trying to show that this trick works even when the 'e' in e -> r   is big.
14:34:39 <edwardk> (Bool -> r) -> r          is big, but using linearity makes it small again.
14:35:24 <edwardk> (Bool -> r) ->_L r   is my way of saying that arrow is linear in that f (ax + b) = a*f(x) + f(b)
14:35:25 <sharyari> napping: Yes, if I know what I'm doing atleast
14:35:45 <napping> I think you should just be able to define a new key type as a newtype of an existing type and give an instance
14:35:56 <dfeuer> I might sort of understand?
14:35:59 <edwardk> so if i multiply the vector i hand you by 2 you have to multiply the answer you give me by 2
14:36:12 <napping> like newtype BadString = BadString String; instance Hashable BadString where hasWithSalt _ _ = 12
14:36:29 <edwardk> we we can go back and play with this a bit
14:37:14 <edwardk> dot :: (e -> r) -> (e -> r) -> r  -- has to take a vector (e -> r)    and give you back a linear functional (e -> r) ->_linear r
14:37:40 <napping> sharyari: is that enough?
14:37:44 <dfeuer> OK.
14:37:47 <edwardk> dot being the inner product on the space
14:38:15 <dfeuer> So you're saying that a curried dot product produces linear functionals.
14:38:26 <edwardk> and then if your basis is finite you can show that using linearity   the dual of the dual of a vector space is the same as the original
14:38:30 <edwardk> yes
14:38:35 <dfeuer> In an infinite-dimensional space, does it produce all of them?
14:38:38 <edwardk> but that uses the finiteness of the basis
14:39:20 <sharyari> napping: Yes. I must have made some syntactical error, but I can't really see what it would have been. Thanks a lot :)
14:39:53 <ParahSailin> hm, so jhc actually reduces the computation core graph into imperative code in the compile stage?
14:40:13 <napping> sharyari: Great. What type had a bad hash?
14:40:28 <edwardk> this gets tricky when you talk about infinite dimensional cases. the classic definition of a free vector space carries a side condition that (e -> r)  gives a non-0 r  at finitely many places, where i prefer instead to use a more constructive version where i eliminate that condition, say that (e -> r) is a' possibly infinite free vector space'  and move the finiteness condition to where it works.  saying that the covectors    (e ->
14:40:28 <edwardk>  r) ->_linear r    can  only inspect (e -> r)  at finitely many places... which holds if that function always terminates ;)
14:40:52 <dfeuer> That's way over my head.
14:40:58 <dfeuer> For now.
14:41:01 <edwardk> (e -> r) -> r  has to give an answer
14:41:14 <edwardk> to do so it has to 'probe' the vector (e -> r)
14:41:19 <edwardk> and ask about certain choices of 'e'
14:41:29 <edwardk> i'm saying if we want the program to run it can only ask finitely many questions
14:41:36 <dfeuer> True.
14:41:45 <edwardk> once you say that then yes
14:42:03 <edwardk> but the ability to go back from V** -> V   can fail in the infinite case
14:42:09 <napping> sharyari: If there just wasn't an instance you don't need the newtype at all. If there was a poor hash, it would be nice to file a bug.
14:42:10 <edwardk> we can go V*** -> V*
14:42:17 <edwardk> there is a monad you get here, etc.
14:42:39 <edwardk> its analogous to double negation elimination in logic vs. escaping Cont in Haskell.
14:42:39 <dfeuer> Maybe I should come back and ask about this once I finish reading Aluffi.
14:43:07 <dfeuer> Because I feel like I'm missing an awful lot of what you're saying.
14:43:08 <ParahSailin> edwardk: so whats going on with ermine these days
14:43:20 <edwardk> @djinn ((a -> r) -> r) -> a
14:43:20 <lambdabot> -- f cannot be realized.
14:43:27 <edwardk> @djinn (((a -> r) -> r) -> r) -> a -> r
14:43:27 <lambdabot> f a b = a (\ c -> c b)
14:43:37 <edwardk> ParahSailin: still making headway on the compiler
14:43:57 <edwardk> dfeuer: anyways, the point of all that was just to say 'all vector spaces look like functions'
14:44:04 <edwardk> dfeuer: so far so good at least up to that?'
14:44:21 <dfeuer> I think so, yes, once you've chosen a basis.
14:44:37 <edwardk> ParahSailin: we're currently cleaning up the typechecker to support classes, etc.
14:44:45 <edwardk> ok, now lets talk about functors for a bit =)
14:45:09 <edwardk> in category theory there is a certain kind of very well behaved functor we call a 'corepresentable' functor.
14:45:35 <edwardk> that is a fancy way of saying there exists an x   such that forall a.       f a  is isomorphic to (x -> a)
14:45:46 <ParahSailin> edwardk: any place i could contribute?
14:45:54 <vanila> out of nowhere yoneda??
14:45:58 <edwardk> ParahSailin: are you in #ermine ?
14:46:18 <edwardk> most of the build bot spam goes there
14:46:53 <edwardk> we're getting ready to actually write the module parser, etc. once we have that it'll actually be more than the guts of an awesome typechecker ;)
14:47:04 <edwardk> at that point it'll be much easier to onboard help =)
14:47:07 <dfeuer> f a is isomorphic to the class of morphisms from x to a? What is f?
14:47:10 <Lutin^> edwardk: Do you have any suggestions on category theory, linear algebra, or analysis books to read? Trying to build up a reading list for my last couple years in my Math/CS bachelors
14:47:19 <ParahSailin> edwardk: Ermine.Core.Compiler is where cabal seems to die building it, is that what you guys are working on?
14:47:36 <edwardk> ParahSailin: are you on 7.8.2?
14:47:47 <edwardk> we use 7.8 extensively now
14:48:03 <edwardk> you should be able to check out and build on 7.8, or we'd consider that a bug
14:48:11 <ParahSailin> edwardk: ah, i have it installed, but its not my default
14:49:05 <edwardk> Lutin^: category theory? start with lawvere and schanuel's conceptual mathematics if you're starting cold, awodey if you know more or find it too slow. http://www.youtube.com/user/TheCatsters are amazing. eugenia is fun to listen to and is very very deeply involved with this stuff
14:49:20 <edwardk> i love categories for the working mathematician but it is an acquired taste
14:49:39 <edwardk> for linear algebra and analysis i'd have to raid my bookshelf
14:50:04 <Lutin^> Right now most of my strength is in groups and rings, and I'd have a little grasp on category theory but nothing I would consider concrete
14:50:18 <Lutin^> You can just take a picture of the bookshelf and I'll duplicate it haha
14:51:08 <Lutin^> Thanks for the cat theory recommendations, I'll check them out
14:51:21 <edwardk> Lutin^: i have a lot of books ;)
14:51:42 <Lutin^> hehe I can imagine
14:52:14 <Lutin^> Well let me know if you can think of any more books, including CS books. WOuld be greatly appreciated
14:52:36 <dfeuer> edwardk, so how does this relate to functors?
14:53:46 <Lutin^> Oh Aluffi's at FSU
14:53:54 <edwardk> dfeuer: ok. so back to representability
14:54:09 <edwardk> a representable functor is nice, it can have all the properties (->) x   has
14:54:40 <edwardk> e.g. Functor, Applicative, Monad,  its a Comonad if x is a monoid, MonadReader, etc.
14:55:25 <edwardk> all vector spaces look like e -> n for some basis, but Covector r a = (e -> r) -> r   can be inefficient for large matrix operations, etc. so we need a way to memoize the intermediate results
14:55:42 <tnks> what does "representable" mean?
14:55:44 <edwardk> so we look for a data structure that is the tuple we want
14:56:15 <edwardk> here i mean exists x. forall a. f a is isomorphic to  x -> a -- which is technically corepresentability
14:56:23 <Lutin^> tnks: gives some insight http://en.wikipedia.org/wiki/Representable_functor
14:56:31 <edwardk> representability is exists x. forall a. f a is isomorphic to a -> x    for a contravariant functor
14:56:57 <tnks> ah, cool.
14:57:01 <edwardk> but abstractly the notion of representability is that ability to slop everything to one side
14:58:06 <edwardk> ok, all vector spaces look like (n -> r)    and for some choices of 'n' there can be a functor that has representation n.     so i represent vector spaces as those functors.
14:58:14 <edwardk> well, not for some choices of 'n'
14:58:25 <edwardk> because (->) n   is a functor that has representation n !
14:58:59 <edwardk> so i just compose those two isomorphisms, all vector spaces are free (e -> r)    and (e -> r) ~ f r
14:59:09 <edwardk> so all my vector spaces are functors
14:59:13 <edwardk> rather
14:59:33 <edwardk> all my vector spaces are functors applied to a field
14:59:37 <dfeuer> OK, edwardk, I give up. For now. I will come back once I have a little more category theory in my head. May I suggest that you add an explanation and/or a link to an explanation to the documentation for the module? Even if I can't understand such an explanation today, it may be useful for me later and for others now.
15:00:20 <edwardk> dfeuer: i'm more than open to better documentation. i had never intended to release linear. it was part of an old physics package i was playing with and acowley jumped up and down and demanded a copy of it
15:00:31 <edwardk> so it wound up on hackage because he wanted to make robots fly and see things with it
15:01:07 <tnks> edwardk: literaly make robots fly and see things?
15:01:07 <dfeuer> Well, if you think its design makes some sort of theoretical sense, edwardk, then it will probably turn out to be a good thing to have around.
15:01:19 <edwardk> nowadays linear is basically about using this notion of representability and a canonical choice of representation that you can get through lens
15:01:33 <edwardk> tnks: yes.
15:01:55 <dfeuer> The one last question ... why isn't it a subclass of Group?
15:02:57 <edwardk> tnks: http://www.youtube.com/watch?v=Zlt6EJVdUN8 http://www.youtube.com/watch?v=YQIMGV5vtd4 http://vimeo.com/77164337
15:03:04 <edwardk> Group woud include the final argument
15:03:58 <edwardk> you want Additive f,   so we can talk about 'f' independent of the argument type its tabulating
15:04:03 <napping> so Additive is really for vector spaces?
15:04:10 <dfeuer> Oh, so this gets into some sort of undecidable instance thing?
15:04:14 <edwardk> because i represent matrices as f (g a)
15:04:26 <edwardk> no, its about polymorphic recursion
15:04:35 <edwardk> when i want to talk about jets of derivatives, etc.
15:05:02 <dfeuer> Whoosh (the sound of that going over my head). Time for me to go jump in the pool before it gets dark.
15:05:03 <edwardk> Cofree f a = a * (f (a * f (a * ...      uses one choice of argument but when i unzip it to get a Jet i get
15:05:16 <edwardk> Jet f a = a :- Jet f (f a)     which looks like
15:05:26 <edwardk> a :- f a :- f (f a) :- f (f (f a)) :- ...
15:05:46 <edwardk> that polymorphically recurses on the argunent
15:05:49 <edwardk> er argument
15:05:58 <edwardk> and that is something i do a lot of when working with automatic differentiation, etc.
15:06:09 <edwardk> a version of this that i can't use with AD is useless to me
15:06:14 <edwardk> so yes, i could write the group thing down
15:06:19 <edwardk> but it'd make the library useless to me
15:06:23 <edwardk> and i actually use my code ;)
15:06:25 <napping> maybe just calling it Additive rather than Vector or Space or something is the confusing part
15:06:28 <dfeuer> Thank you very much for attempting to explain this, even though it didn't exactly work.
15:06:59 <napping> sounds like you distinctly don't want general abelian groups
15:07:30 <edwardk> napping: i've done work on trying to make nice algebra in haskell. i gave up for now ;)
15:08:00 <edwardk> for linear-algebra using the standardish classes? Additive stays out of the way of the names for things folks use this crap with. Vector is a pretty well used library and linear even uses it internally.
15:08:07 <edwardk> Space makes me uncomfortable
15:11:19 <Lutin^> me too, too many aliens
15:11:49 <edwardk> nah, not enough
15:13:36 <ij> Does IO use unsafePerformIO inside? Or it's a compiler thing and has no need for a unsafePerformIO
15:13:41 <ij> +?
15:13:58 <joelteon> ij, not exactly
15:14:16 <joelteon> the way IO is implemented and the way unsafePerformIO is implemented are similar
15:15:04 <joelteon> at least in GHC; I don't even know if unsafePerformIO is in the language standard
15:15:07 <edwardk> the fact that even if you left the earth now you 40% of the observable universe has already 'redded out' and everything is getting farther away faster and faster due to dark energy
15:15:07 <joelteon> although I'd think it would be
15:15:17 <geekosaur> IO is just baton-passing to accomplishg sequencing. unsafePerformIO magics up a baton out of nowhere and then poofs it again
15:15:48 <joelteon> ij, imagine Data.Maybe only exported Maybe and none of its constructors; you wouldn't be able to pattern match on Maybe a and get "Just a" or "Nothing" out of it
15:15:51 <geekosaur> which breaks sequencingm also because it claims to be pure the compiler is allowed to assume it will always produce the same value
15:15:52 <joelteon> that's sort of how IO is
15:16:03 <geekosaur> s/m/,/
15:16:24 <joelteon> IO is just an ordinary everyday haskell datatype whose constructor isn't exported so you can't mess with it yourself
15:16:25 <geekosaur> unsafePerformIO is not in the standard as such. unsafeLocalState is part of FFI
15:16:36 <geekosaur> (and is a variant of unsafePerformIO)
15:16:37 <jle`> joelteon: semantically.  but perhaps not at the implementation level
15:16:39 <merijn> joelteon: Sure you can!
15:16:52 <joelteon> well, if you import GHC.Prim or whatever it is
15:16:54 <merijn> @hackage acme-realworld
15:16:54 <lambdabot> http://hackage.haskell.org/package/acme-realworld
15:16:57 <merijn> ;)
15:17:11 <edwardk> Lutin^: literally nothing we do can affect 97% of what we can see in the night sky, even if you left on a ship at the speed of light today
15:18:34 <silasm> edwardk: so space is mostly immutable?
15:19:19 <edwardk> silasm: yep
15:20:27 <ij> joelteon, Thank you for the insight.
15:21:18 <Lutin^> ParahSailin_: Engine builds for me on 7.8.2
15:22:19 <joelteon> ij: actually, if you run GHCi and type :i IO, you can see what the implementation looks like
15:22:34 <Lutin^> Ermine*
15:25:28 <ij> joelteon, Didn't tell me too much, but one day I'll probably understand it.
15:25:42 <ij> Today, though, is State and IOStateArrow day for me.
15:26:54 <joelteon> If you look closely, you'll notice similarities between the implementation of IO and the State monad.
15:27:14 <joelteon> Or, well, StateT and IO
15:27:18 <joelteon> State is just a wrapper around StateT
15:28:51 <ij> Can I get a wiki account just for signing up for one?
15:56:19 <gaze__> hey folks. How to I get ghc/ghci to find other modules when referred to as a.b.c? More precisely say I have modules defined a.b.c and a.b.d, and I get "Could not find module a.b.c" when loading a.b.d, but c.hs and d.hs are both in the directory src/a/b. What am I missing
15:57:30 <joelteon> gaze__: ghc -isrc ...
15:57:45 <joelteon> it's either -isrc or -Isrc, but I think it's lowercase i
15:58:29 <pavonia> or start GHCi in src/
15:58:34 <joelteon> or that
15:58:37 <dfeuer> Does acme-realworld actually do something useful? I really want to read the (c) Joseph Adams at the top as (c) Douglas Adams.
15:59:40 <merijn> dfeuer: Define useful :)
16:00:03 <merijn> dfeuer: Anything in the ACME category is janky jokes at best and horrifically dangerous at worst :p
16:00:12 <dfeuer> merijn, frankly, I'm surprised those functions even compile.
16:01:00 <merijn> dfeuer: Oh, they compile fine, they just defeat almost every single safety control GHC has and I'm pretty sure that using them will cause your programs to behave "interesting" ;)
16:02:14 <dfeuer> merijn, does the hypothetically function do anything more than some exception handling?
16:02:18 <dfeuer> of some sort?
16:04:34 <merijn> dfeuer: No clue, look at the source? :)
16:08:41 <ij> I got told that State is made out of StateT. What monad type would be passed to StateT under the hood, when I use simply State?
16:08:50 <merijn> ij: Identity
16:09:05 <merijn> ij: "newtype Identity a = Identity { runIdentity :: a }"
16:09:47 <merijn> > Identity 5 >>= Identity . (+3)
16:09:48 <jle`> perhaps more relevantly, Identity a >>= f = f a
16:09:50 <lambdabot>  Identity {runIdentity = 8}
16:10:47 <jle`> maybe more neatly written as
16:10:52 <jle`> f =<< Identity a === f a
16:11:26 <merijn> Or better yet "f >=> g === g.f"
16:11:57 <jle`> really?
16:12:04 <merijn> Sure
16:12:19 <merijn> well
16:12:23 <merijn> Conceptually
16:12:25 <jle`> :t (<=<) `asAppliedTo` (undefined :: a -> Identity b)
16:12:26 <lambdabot> (b -> Identity c) -> (a -> Identity b) -> a -> Identity c
16:12:40 <jle`> :t (.) `asAppliedTo` (undefined :: a -> Identity b)
16:12:41 <lambdabot> (b -> Identity b1) -> (a -> b) -> a -> Identity b1
16:12:43 <jle`> ah
16:12:58 <jle`> `f =<< Identity a = f a` is true literally :)
16:13:09 <merijn> Kleisli composition for identity is just function composition
16:13:47 <jle`> :t (C..) `asAppliedTo` (undefined :: Kleisli Identity a b)
16:13:48 <lambdabot> Kleisli Identity b c -> Kleisli Identity a b -> Kleisli Identity a c
16:14:16 <jle`> um i'm not sure what that was supposed to show
16:14:22 <merijn> :)
16:14:49 <jle`> in an ideal world i wonder if we could just make identity's go away...like assume everything has an implicit identity around it
16:15:16 <jle`> so them fmap f x = f x for x :: Identity a
16:15:22 <jle`> i wonder how useful it'd be
16:15:26 <ij> May I alter ghci's prompt to make the import list somehow less annoying?
16:15:58 <merijn> ij: You can specify custom prompts, I forget how. Consult the GHC manual :)
16:16:01 <jle`> ij: a lot of people use λ:
16:16:14 <jle`> :set prompt <prompt>
16:16:18 <silasm> :set prompt "foobar" in .ghci
16:16:18 <jle`> you can put that in your ~/.ghci
16:16:24 * merijn uses "λ "
16:16:42 <kini> does happy depend upon itself, somehow? I can't see how or where it does, but I'm mysteriously unable to build it on a particular VM...
16:18:12 <kini> In particular the build log says "Building happy-1.19.3..." "Preprocessing executable 'happy' for happy-1.19.3..." "setup: The program happy is required but it could not be found"
16:18:33 <ij> Nice, the lambda+colon looks good.
16:21:23 <sharyari> Question. I had a working program, using a lot of bytestrings. I then added a newtype wrapper for [ByteString], and wrapped/unwrapped whereever the compiler gave me errors. Now when I run the program, I get main: <<loop>>. Is there something with my approach that was dangerous? And how can I get more information on why this is failing?
16:21:46 <merijn> sharyari: You have an infinite loop somewhere in your code
16:22:02 <orzo> turn on profiling
16:22:13 <sharyari> merijn: But I havn't actually changed the code, other than renaming a type
16:22:29 <rwbarton> well, apparently you have
16:22:32 <pavonia> kini: Have you tried to install an older version of happy first?
16:22:33 <sharyari> orzo: I have, but I'm not sure how I would use it to trace this type of error
16:22:39 <merijn> sharyari: newtype is not renaming, newtypes do change behaviour in some subtle ways
16:22:52 <kini> pavonia: no, should I?
16:23:22 <pavonia> kini: I would try it
16:23:25 <kini> I mean, if I try it and it works, that doesn't help me justify doing that in our production build script :P
16:23:36 <sharyari> merijn: I remember seeing some explanation of that, now when you mention it. I'll check that out
16:23:50 <orzo> i've not used profiling in a bit, but there's a bunch of tools to try. put cost centers where you think it might be getting stuck and see if hte profiler agrees
16:23:51 <kini> I mainly want to figure out how to diagnose the message "setup: The program happy is required but it could not be found" in the log of cabal trying to install happy
16:24:29 <rwbarton> are you sure that you're not trying to install something else that requires happy
16:24:39 <rwbarton> and then happy gets installed to a directory that's not on the PATH?
16:25:06 <kini> cabal install --dry-run happy-1.19.3 shows mtl-2.1.3.1 and happy-1.19.3
16:25:14 <kini> mtl-2.1.3.1 installs into the sandbox just fine
16:25:31 <orzo> debug prints too, just tarck it down, and let us know
16:25:32 <pavonia> happy actually has .ly files in its source code
16:26:25 <ij> http://www.haskell.org/haskellwiki/Arrow has a "import Control.Arrow" and http://www.haskell.org/haskellwiki/State_Monad has nothing about imports there.
16:26:51 <ij> Would you agree that it would be nice to have a line that says what to import from where in the tops of wiki of specific modules?
16:28:10 <rwbarton> yes
16:28:10 <merijn> ij: I guess so, although most things should be findable using Hoogle
16:28:14 <orzo> sharyari: did you change a 'data' declaration to a 'newtype' ? Because that probably has different strictness behavior
16:28:23 <merijn> ij: Feel free to add them ;)
16:30:34 <pavonia> kini: Can't you just install the Haskell Platform in your VM which already includes happy?
16:31:09 <kini> pavonia: no, this tarball is supposed to build on machines with a limited selection of things
16:31:13 <ij> merijn, I requested an account already and Thomas already sent me details.
16:31:43 <kini> we are already building our own ghc locally, for example, lol (we require at least 7.4 natively on the target machine but we build 7.8.2 using that)
16:31:51 * hackagebot purescript 0.5.2.5 - PureScript Programming Language Compiler  http://hackage.haskell.org/package/purescript-0.5.2.5 (PhilFreeman)
16:32:43 <sharyari> orzo: No, I'm using "newtype E = E {unwrap :: [ByteString]} deriving (Show, Eq, Ord)
16:32:47 <sharyari> to be exact
16:33:26 <pavonia> kini: What versions of cabal-install and Cabal are you using?
16:33:30 <merijn> sharyari: Use Debug.Trace to try and figure out where it goes wrong?
16:34:21 <dfeuer> The Haskell Platform is supposed to get a new release at the end of this month, but the mailing list hasn't gotten a single message since the 11th. I must say I'm a bit skeptical.
16:34:39 <toki78> Hi
16:34:49 <toki78> I think, I solved the SAT problem
16:34:51 <rwbarton> it's waiting on ghc 7.8.3 I believe
16:34:51 <toki78> ??
16:34:58 <toki78> http://toki.burn3r.de/html5-projects/binary-decision-diagrams.html
16:35:23 <toki78> I know it sound crazy
16:35:34 <toki78> I loosened the structural rules for BDDs
16:35:45 <toki78> and voila !
16:35:56 <sharyari> merijn: havn't used that before, so I'm trying to figure that out :P
16:36:09 <toki78> each literal not occuring in the solution is "dont care"
16:36:24 <merijn> sharyari: Basically, it lets you insert (horribly unsafe) print statements in your code for debugging :p
16:37:12 <sharyari> I'm just getting empty strings :/
16:38:15 <jle`> i like to say that it lets you peek into what ghc is evaluating and when :)
16:38:19 <dfeuer> toki78, what are you talking about?
16:39:18 <toki78> dfeuer, I convert DIMCAS CNF to a BDD
16:39:34 <toki78> the walk from the bottom leave up to the top
16:40:08 <toki78> yields the solution
16:40:24 <toki78> dfeuer, of course take a leave with 1
16:41:26 <toki78> dfeuer, this is so hot !
16:41:36 <toki78> I can implement this for ersatz
16:41:45 <toki78> to chech if it really works
16:42:18 <dfeuer> toki78, what are you talking about? What is your objective? What have you accomplished?
16:42:41 <toki78> dfeuer, SAT in O(<2^n)
16:42:48 <dfeuer> Riiiiight.
16:42:50 <sharyari> hehe
16:43:08 <toki78> dfeuer, can you present me a hard instance
16:43:17 <toki78> dfeuer, I will feed it into my solver
16:44:06 <dfeuer> toki78, no. Partly because I don't know enough about the problem, but also because different solvers consider different cases "hard".
16:44:42 <toki78> dfeuer, I see
16:44:56 <pavonia> So P = NP, or what?
16:45:10 <toki78> YOOO
16:45:20 <toki78> but only if the algo is not buggy
16:45:21 <dfeuer> But no amount of benchmarking will do it for you, toki78. You need an actual proof. A proof in EXTREME DETAIL.
16:45:46 <toki78> dfeuer, I coded the factorization problem into SAT
16:46:03 <silasm> dfeuer: curry howard isomorphism ;)
16:46:22 <toki78> dfeuer, if the algo's solution is a * b = c ,then the algo woroks
16:46:28 <silasm> though I kid, of course.
16:46:55 <toki78> ion, are you on ?
16:47:06 <toki78> ion, I want to port this to ersatz
16:47:26 <dfeuer> silasm, I would accept any formally verified proof, if someone's previously published the formal theorem in some proof verification language....
16:48:26 <vanila> proof of what?
16:49:03 <silasm> ion: yeah, that's the joke. my point was "his program is a proof", but the question is "what is it claiming?", which probably isn't much without dependent types.
16:49:28 <dfeuer> Alternatively, if toki78's proof is sufficiently well-accepted after publication to win them the Turing Award, then that would convince me too.
16:49:48 <ReinH> silasm: A program is a proof that "claims" that its type is inhabited. :p
16:49:53 <silasm> whoops, meant for that to go to dfeuer
16:49:56 <toki78> dfeuer, I implement it now for ersatz
16:50:34 <ReinH> If you want to talk about what the program "means" you can talk about denotational semantics.
16:51:57 <silasm> ReinH: so the strength of the claim (and the corresponding proof) is dependent on how expressive the type is ;).
16:52:29 <ReinH> silasm: I'm not sure what you mean by "strength".
16:52:36 <toki78> can anyone explain me the ersatz solver class ?
16:52:56 <athan> is there a way to make a cabal sub-sandbox? Like a sandbox tree?
16:53:24 <merijn> athan: You can link other sandboxes into an existing one
16:53:41 <silasm> ReinH: well if the type is [a] -> [a], and the function is sorting, that's a relatively weak claim compared to (xs : [a]) -> Sorted (Permutation xs)
16:53:51 <athan> merijn: Really? How?!?
16:54:02 <merijn> athan: "cabal sandbox add-source"
16:54:15 <silasm> ReinH: maybe "strength" isn't the right word, but hopefully you get the idea.
16:54:27 <joelteon> :t uncurry (fmap (,))
16:54:29 <lambdabot> (b -> a, b) -> b1 -> (a, b1)
16:54:34 <joelteon> man, that's not right
16:54:35 <merijn> athan: That's kinda the point of sandboxes, you can have them use non-standard local versions of packages
16:54:40 <joelteon> :t uncurry (fmap . (,))
16:54:41 <lambdabot> Functor f => (a, f a1) -> f (a, a1)
16:54:48 <joelteon> there we go, THAT'S strength
16:54:53 <dfeuer> Is it possible to convince lambdabot to actually evaluate things?
16:55:01 <joelteon> > 1
16:55:02 <lambdabot>  1
16:55:04 <joelteon> there you go
16:55:07 <athan> merijn: Ahh that's wonderful. Do I just supply the path to the project's directory then?
16:55:17 <kini> rwbarton, pavonia: acfoltzer helped me figure out what was going on with happy depending on itself
16:55:18 <kini> as pavonia mentioned, there are .ly files in the happy source tarball, but their corresponding generated .hs files are shipped too... and I was trying to build happy using `cabal sandbox add-source` to its unpacked tarball, rather than donwloading it from hackage, and that meant the .hs files got cleaned away before the build started
16:55:18 <merijn> athan: So, suppose you're working on pandoc and a dependency of pandoc, you can use add-source in the pandoc sandbox to tell it to use your locally hacked up pandoc dependency dir
16:55:30 <kini> and then of course cabal wanted to regenerate those .hs files but couldn't without happy
16:55:40 <merijn> athan: Check "cabal help sandbox"
16:55:42 <athan> merijn: Beautiful :) (how did you know I was working on pandoc? :P)
16:55:43 <rwbarton> aha
16:55:51 <athan> thank you man
16:56:01 <merijn> athan: I used it for pandoc myself :)
16:56:10 <merijn> athan: Just point it at the dir with cabal, iirc
16:56:20 <merijn> if not, you'll have to google some sandbox docs
16:56:34 <kini> so I guess one solution is to change the .cabal file for happy to mention these precious autogenerated .hs files as extra haskell source files that cabal should know about, and thus preserve when copying for the purposes of sandbox add-source
16:56:57 <rwbarton> does cabal have some built-in knowledge about happy?
16:56:58 <athan> merijn: Thank you so much, this just made my day
16:57:20 <merijn> athan: Without this sandboxes would be kinda useless ;)
16:57:24 <rwbarton> that it's supposed to use happy when it sees a .ly file?
16:57:40 <kini> rwbarton: https://github.com/haskell/cabal/blob/8a4fe9a8f06e77931ec6b400f17dc8daa9dc0f7d/Cabal/Distribution/Simple/PreProcess.hs#L604
16:57:47 <pavonia> kini: Ah, thanks for explaining. I found https://github.com/haskell/cabal/issues/1777 but it doesn't say what the actual problem is
16:57:50 <rwbarton> I see
16:58:32 <athan> merijn: V: I'm not very smart about these kinds of things... intended purposes...
16:58:39 <athan> have you read the closed cartesian comic?
16:58:55 <athan> I'm pretty sure I was the guy that said "Whoah, these arrows look like functions!"
16:59:06 <merijn> :)
16:59:28 <dfeuer> @type h
16:59:29 <lambdabot> FromExpr a => a
16:59:31 <dfeuer> @type t
16:59:31 <lambdabot> Expr
16:59:33 <dfeuer> Huh?
16:59:41 <merijn> dfeuer: That's so you can do
16:59:47 <merijn> > foldl f z [a,b,c,d]
16:59:49 <lambdabot>  f (f (f (f z a) b) c) d
16:59:54 <rwbarton> > h x
16:59:55 <lambdabot>  No instance for (GHC.Show.Show a0)
16:59:55 <lambdabot>    arising from a use of ‘M203672412341798653719790.show_M2036724123417986537...
16:59:55 <lambdabot>  The type variable ‘a0’ is ambiguous
16:59:55 <lambdabot>  Note: there are several potential instances:
16:59:55 <lambdabot>    instance [safe] GHC.Show.Show
17:00:06 <rwbarton> huh
17:00:27 <rwbarton> oh i see
17:00:41 <Iceland_jack> > h x :: Expr
17:00:43 <lambdabot>  h x
17:00:45 <dfeuer> What are Expr and FromExpr?
17:00:48 <rwbarton> it doesn't know how many args h is supposed to have, but it knows in your example f was supposed to have 2 args because foldl
17:00:55 <merijn> dfeuer: Horrific typeclass abuse :)
17:01:00 <merijn> I forget the library
17:01:02 <Iceland_jack> they're not a part of Haskell, they're a part of lambdabot
17:01:40 <dfeuer> That reminds me of Okasaki's RPN calculator EDSL.
17:01:45 <Cale> They're things defined in this package http://hackage.haskell.org/package/simple-reflect
17:01:51 <Cale> They are definable in Haskell :)
17:02:22 <Iceland_jack> Sure, I just don't want anyone to mistake them for parts of the language
17:05:03 <rwbarton> toki78: what's going on with this input: 1 -2 0   -1 2 0   3 0
17:05:18 <joelteon> > f a ⊗ g
17:05:20 <lambdabot>  f a ⊗ g
17:05:23 <joelteon> awesome
17:05:39 <joelteon> > a ⊗ g ⊕ b @@ b ⊕ a
17:05:41 <lambdabot>  Precedence parsing error
17:05:41 <lambdabot>      cannot mix ‘Debug.SimpleReflect.Vars.⊕’ [infix 6] and ‘Debug.SimpleRefle...
17:05:42 <toki78> rwbarton, let me chack
17:05:59 <joelteon> ooh, can't mix non-associating operators
17:06:12 <rwbarton> :t (⊗)
17:06:13 <lambdabot> Expr -> Expr -> Expr
17:06:13 <toki78> rwbarton, x2 = dont care
17:06:34 <rwbarton> that's not really right is it
17:06:40 <rwbarton> it has to be the same as x1
17:07:45 <toki78> rwbarton, I hope the simplifier does not do too much :)
17:07:48 <jle`> > foldr f z [a,b,c,d]
17:07:53 <lambdabot>  f a (f b (f c (f d z)))
17:07:58 <toki78> rwbarton, I will check this
17:08:06 <jle`> hm
17:08:52 <pavonia> > foldr (⊗) z [a,b,c,d]
17:08:53 <lambdabot>  a ⊗ (b ⊗ (c ⊗ (d ⊗ z)))
17:09:57 <rwbarton> toki78: here's one it claims is satisfiable but it isn't  1 -2 0 -1 2 0 1 -3 0 -1 3 0 2 3 0 -2 -3 0
17:10:17 <toki78> rwbarton, thanks a lot for bug reports !
17:11:56 * hackagebot spe 0.5.1 - Combinatorial species lite  http://hackage.haskell.org/package/spe-0.5.1 (AndersClaesson)
17:12:04 <dfeuer> Iceland_jack, don't worry; I was never under the impression that those horrors were part of the language.
17:12:08 <toki78> rwbarton, is that 2 time the equivalence and once the antivalence ?
17:12:39 <rwbarton> right
17:15:33 <toki78> rwbarton, for this it works :
17:15:33 <toki78> 1 2 -3 0
17:15:34 <toki78> 1 2 3 0
17:15:34 <toki78> 1 -2 -3 0
17:15:34 <toki78> 1 -2 3 0
17:15:51 <toki78> rwbarton, this made me so happy
17:20:35 <toki78> rwbarton, the and() funciton does not work, I guess
17:23:54 <ReinH> wait, where is ⊗ defined?
17:25:18 <AshyIsMe> woah, how do you type that?
17:25:22 <AshyIsMe> and pronounce it?
17:25:40 <ReinH> In context it's usually pronounced "times"
17:25:51 <silasm> ReinH: http://hackage.haskell.org/package/simple-reflect-0.3.2/docs/Debug-SimpleReflect-Vars.html
17:25:58 <ReinH> in LaTeX it's \otimes
17:26:13 <rwbarton> the hoogle interface doesn't like fancy Unicode characters at all :(
17:26:17 <ReinH> silasm: oh I didn't know SimpleReflect defined those all of those. Awesome.
17:26:17 <AshyIsMe> is there an alt key for it on mac?
17:26:24 <ReinH> AshyIsMe: I have no idea :D
17:26:24 <rwbarton> web interface that is
17:26:35 <AshyIsMe> ReinH: ah ok, so you're just pasting it?
17:26:44 <ReinH> AshyIsMe: yep
17:27:44 <rwbarton> whoops, http://hackage.haskell.org/package/simple-reflect-0.3.2/docs/src/Debug-SimpleReflect-Vars.html is served with the wrong encoding too!
17:27:56 <rwbarton> or is it?
17:28:08 <rwbarton> served with the right encoding but double utf-8 encoded?
17:28:49 <toki78> rwbarton, now check again !
17:30:38 <ij> It somehow seems that an argument that is a data type might just really be an object that implements in its own unique category. Is that a completely wrong thought?
17:31:11 <rwbarton> toki78: ok, now it's easy to generate exponentially sized BDDs like 1 -4 0 -1 4 0 2 -5 0 -2 5 0 3 -6 0 -3 6 0
17:31:36 <ReinH> ij: It seems a bit out of context.
17:31:49 <toki78> rwbarton, okay :)
17:32:29 <toki78> rwbarton, give me 5 minutes
17:32:46 <rwbarton> you know if it takes you exponentially longer to come up with each new version, it no longer counts as polynomial time
17:33:45 <lessless> folks, what does that mean:  "The inner lists inside the outer lists need not to be of the same length (so they are not equivalent to arrays of multiple dimensions)" ? [["a","b"],["a","c"]] wroks just fine and size of the inner lists is equal to the size of outer list
17:34:02 <ij> ReinH, Okay. It seems that too much clutter comes when I go from "A -> B" to "Aish a => a -> B". Isn't it so similar that it could be "Aish -> B"?
17:34:33 <Iceland_jack> ij: Aish and A have different kinds
17:34:51 <Iceland_jack> A is a type, Aish is a type class, Aish a is a constraint
17:34:52 <rwbarton> lessless: "need not to be" isn't the same as "need to not be"
17:34:59 <rwbarton> (it's also not very good English)
17:35:22 <lessless> ah yeah
17:35:31 <lessless> it;s just 03:34 here :)
17:35:38 <lessless> need to go to sleep better :)
17:35:45 <lessless> details are out of my attention
17:36:06 <lessless> just not have so much time to dedicate it to haskell :)
17:36:51 <gamegoblin> Is there any way to express the sentiment “if t is showable, show t, otherwise, some default string” or does the type system make that impossible
17:37:03 <dfeuer> rwbarton, it's perfectly good English, actually, illogical though it may be.
17:37:36 <pavonia> lessless: Reduce the amount of other things to do, so you have more time to spend on Haskell :)
17:38:05 <rwbarton> I would say "need not be" and consider what is written incorrect
17:38:14 <rwbarton> maybe it varies with dialect
17:38:31 <gamegoblin> If you’re prescriptivist, “to not be” is grammatically incorrect due to split infinitive
17:38:54 <rwbarton> or hmm, maybe it is actually okay and means the opposite of what the writer intended
17:38:58 <ij> Iceland_jack, Okay, they do have different kinds. But couldn't you say that A is just something that is Aish, wouldn't that make everything more regular?
17:39:04 <rwbarton> and I just misparsed it because I knew what the writer intended
17:39:45 <Iceland_jack> ij: They're completely different things
17:39:50 <gamegoblin> I’d say “doesn’t need to be” or “does not need to be”
17:39:52 <silasm> ij: how would you express (Aish a, Aish b) => a x -> b x, then?
17:40:01 <[swift]> gamegoblin: i'm pretty sure the whole split infinitive thing is more of an affectation than a real rule
17:40:17 <[swift]> gamegoblin: it's the linguistic equivalent of holding out your pinky when you lift your teacup
17:40:22 <gamegoblin> [swift]: Like I said, only if you’re a prescriptivist grammarian
17:40:47 <gamegoblin> It’s a victorian attempt to make english more latin-like
17:41:25 <rwbarton> yeah I take back what I said originally, "need not to be" is only wrong if you meant "don't need to be"
17:41:54 <ij> silasm, Aish x -> Aish b?
17:42:51 <Iceland_jack> ij: Do you know what type classes do?
17:42:55 <dfeuer> rwbarton, I didn't notice the superfluous "to".
17:43:08 <silasm> ij: do the two instances need to be the same, or can they be different? (honestly I should have just said (Aish a, Aish b) => a -> b)
17:43:15 <xenomachina> Hello. Noob q here: I was looking at http://hackage.haskell.org/package/base-4.7.0.0/docs/src/GHC-Base.html#Functor and saw `(<$)`. I tried using it in ghci but was told "Not in scope: `<$'"
17:43:28 <activeaspect> im having some problems getting ByteString funcs to play nicely with eachother... ive got -- B.unpack . B.replace "." (B.pack "/") and it complains -- Couldn't match type ‘Data.ByteString.Lazy.Internal.ByteString’ with ‘B.ByteString’
17:43:36 <ij> Iceland_jack, By having a type constraint, type checker checks whether Aish a => a implements Aish. Right?
17:44:17 <Iceland_jack> Whether 'a' is an instance of Aish, yes
17:45:04 <Iceland_jack> so a type class is more like a set of types that satisfy it (ignoring multiparameter type classes that are more like n-relations)
17:45:31 <ij> Yes, so A is something that is only in Aish constraint.
17:45:42 <Iceland_jack> so a type class is not a function, it doesn't make sense to write
17:45:42 <Iceland_jack>     foo :: Show -> String
17:45:42 <Iceland_jack> because there is no inhabitant of 'Show'
17:45:48 <Iceland_jack> because it's not a type
17:46:37 <athan> what's a good function that throws an error if a file isn't found, preferably of the type :: FilePath -> IO ()?
17:47:14 <Iceland_jack> @hoole fileExist
17:47:15 <lambdabot> System.Posix.Files fileExist :: FilePath -> IO Bool
17:47:15 <lambdabot> System.Posix.Files.ByteString fileExist :: RawFilePath -> IO Bool
17:47:15 <lambdabot> System.Directory doesFileExist :: FilePath -> IO Bool
17:47:24 <Iceland_jack> why on Earth would you want an error?
17:47:37 <athan> derp
17:47:38 <Iceland_jack> not nice to work with :)
17:47:42 <athan> I'm being lazy :P
17:47:44 <rwbarton> openFile?
17:47:48 <silasm> heh
17:47:49 <athan> but not semantically pure
17:48:13 <ij> athan, error — you mean `error "bad thing happened"'?
17:48:24 <zugz> I reinstalled cabal, and it's forgotten about packages I installed previously. There's a way to make it see them again, but I've forgotten what it is and can't find it... help appreciated
17:48:25 <rwbarton> why do you care whether the file exists, in this case?
17:48:26 <athan> ij: yep!
17:48:27 <ReinH> athan: you generally don't want to check if a file exists before doing something
17:48:33 <ReinH> well
17:48:38 <activeaspect> anyone familiar with the byteString mismatch im seeing?
17:48:41 <ReinH> not generally, there are specific cases when that's a bad idea
17:48:45 <athan> ReinH: I mean, I'd rather have a _nice_ error haha
17:48:59 <lewis1711> technically, all haskell functions only take one argument, right? they essentially take in something and output something - which may be another function. is this correct?
17:49:08 <athan> thanks guys
17:49:10 <dwcook> lewis1711, correct.
17:49:41 <athan> lewis1711: Except you can't over apply functions legally in haskell
17:49:49 <rwbarton> I would say it's generally a bad idea
17:49:50 <lewis1711> over apply?
17:50:09 <dwcook> I don't see anything in that statement that implied applying a non-function should be possible
17:50:18 <athan> lewis1711: You can do partial application, but not over application, if that makes sense
17:50:51 <dwcook> athan, ironically, your reasoning makes it sound like you're thinking of functions as being able to have a number of parameters besides one
17:51:06 <lewis1711> athan, yeah that does make sense. but I mean at the end the output will be a value not a function
17:51:13 <athan> dwcook: Im imagining a peano stack
17:51:19 <athan> :/
17:51:20 <dwcook> lewis1711, all functions are values. Not all values are functions.
17:51:37 <lewis1711> non-function values? I don't know the correct term. atoms?
17:51:58 <dwcook> lewis1711, fortunately, we often don't need to distinguish functions from non-function values.
17:52:02 <athan> lweis1711: Basically, yeah. Anything without a type signature with a (->) in it
17:52:29 <benzrf> oh joy
17:52:36 <benzrf> is somebody trying to invent lisp-style apply again
17:52:47 <lewis1711> unless of course... "non-function values" are themselves functions, like int is just () -> Int
17:52:58 <lewis1711> benzrf, not I (:
17:53:17 <dwcook> lewis1711, I used "non-function values" to mean "values that are not functions" as opposed to "values that are not necessarily functions"
17:53:33 <ij> Iceland_jack, What I'm saying is — everything could be defined by constraints. Why wouldn't that be a good idea?
17:54:18 <ij> or couldn't it?
17:54:26 <rwbarton> at some point you have to actually pick some types
17:54:42 <benzrf> rwbarton: nonsense
17:54:49 <athan> benzrf: oop... was that me?
17:54:59 <lessless> what is the difference between or and || ?
17:55:01 <Iceland_jack> ij: You can try to define a type class for each one of your types and you'll see :)
17:55:07 <benzrf> lewis1711: or is not (||)
17:55:08 <benzrf> :t or
17:55:09 <lambdabot> [Bool] -> Bool
17:55:09 <Iceland_jack> lessless: Or takes a list
17:55:09 <zugz> nevermind, I think I'm thinking of ghc-pkg recache
17:55:14 <benzrf> * lessless
17:55:20 <benzrf> > True || False
17:55:22 <lambdabot>  True
17:55:27 <benzrf> > or [True, False, True]
17:55:28 <lambdabot>  True
17:55:35 <ReinH> you can implement or in terms of ||
17:55:37 <Iceland_jack> (||) is a special case of 'or'
17:56:15 <Iceland_jack>     or     = foldr (||) False
17:56:15 <Iceland_jack>     a || b = or [a, b]
17:56:23 <lessless> alright,  I see
17:56:26 <ij> Iceland_jack, I'll think about it, but you're saying it wouldn't work?
17:56:26 <lessless> thak you
17:56:54 <xenomachina> Does anyone know why <$ (from Functor) is "not is scope"?
17:57:10 <Iceland_jack> ij: It would work, it would just be horrible to work with and needlessly ambigious
17:57:13 <lewis1711> what's the whole "all functions take one argument and are curried by default" thing called?
17:57:29 <pavonia> xenomachina: Isn't that from Control.Applicative?
17:57:35 <dwcook> lewis1711, some people call that "automatic currying".
17:57:43 <dwcook> I don't know if it is has a technical name.
17:57:49 <rwbarton> ij: do you know the "show . read problem"?
17:59:11 <xenomachina> pavonia: according to http://hackage.haskell.org/package/base-4.7.0.0/docs/src/GHC-Base.html#Functor it's in Functor, and I can use fmap no problem, but ghci says <$ isn't in scope.
17:59:24 <ij> rwbarton, Yes, I doesn't seem like a threat to the idea.
17:59:27 <rwbarton> ij: described here for instance http://stackoverflow.com/a/7076342/190376
17:59:34 <rwbarton> it means you can never compose any functions in your scheme
17:59:40 <Iceland_jack> A threat to what idea?
17:59:52 <pavonia> xenomachina: What base version are you using?
18:00:18 <rwbarton> you will always have an intermediate type which is only bounded by constraints, and otherwise inaccessible
18:00:49 <xenomachina> pavonia: how do I find out?
18:00:52 <ij> Iceland_jack, That everything could be defined by a constraint.
18:00:58 <rwbarton> xenomachina: oh you mean it's in the Functor class. but exporting the class does not necessarily export all its members
18:01:16 <rwbarton> Prelude only exports the Functor class with fmap exported, not (<$)
18:01:32 <rwbarton> because adding new names exported by Prelude is bad
18:01:35 <Iceland_jack> Constraints are weaker than concrete types
18:01:56 <pavonia> xenomachina: "ghc-pkg list base"
18:02:18 <ij> Iceland_jack, Constraint to one type is as strong as a type.
18:02:24 <xenomachina> rwbarton: I see. Is there a way I can access <$ ?
18:02:29 <ij> Or type is a one-type constraint.
18:02:31 <Iceland_jack> ij: ...are you serious?
18:02:34 <rwbarton> import it from Data.Functor or Control.Applicative
18:02:38 <pavonia> rwbarton: How can you use the function if it is not exported?
18:03:05 <rwbarton> ij: you can already write A -> B as (a ~ A, b ~ B) => a -> b
18:03:06 <ij> Iceland_jack, No, I just don't know any better.
18:03:10 <rwbarton> ij: but what's the point?
18:03:55 <rwbarton> in fact, type checking/unification works by collecting constraints like these
18:04:33 <athan> Would a (haskell) arrow be the cartesian product of a morphism between two types?
18:04:49 <athan> ie: A -> B == Arrow A B?
18:05:19 <ij> Iceland_jack, Why are you asking?
18:05:55 <Iceland_jack> Sorry, was wondering if it was a serious question: I shouldn't be IRCing at this hour
18:06:53 <ij> Newness goes hand in hand with silly questions.
18:07:06 <xenomachina> rwbarton: How does one determine what to import to get at something found via Hoogle? The page I linked says it's "GHC-Base".
18:08:58 <xenomachina> pavonia: thanks. FWIW, base-4.6.0.1
18:09:20 <rwbarton> on the list of hoogle results it shows Data.Functor and Control.Applicative as the modules that the results live in
18:09:56 <rwbarton> or if you click on a result it will take you to the module that exports it
18:10:05 <rwbarton> if you go all the way to the source link then you will get the module that defines it
18:13:42 <jle`> was bored and made a Num (a -> a) instance where foldr ($) 0 [1,2,3,4] = 10
18:14:25 <kwf> "Of course, there should be some kind of soundness proof here, but who cares?"
18:14:34 <kwf> From an old, old GADTs paper: http://web.cecs.pdx.edu/~sheard/papers/silly.pdf
18:19:00 <jle`> now made a Enum instance that makes foldr ($) 0 [1..4] = 10
18:20:34 <ReinH> jle`: the actual Num instance for Num b => a -> b is pretty useful
18:20:53 <ReinH> well, not actual as in "defined in the Prelude" or anything
18:20:55 <jle`> ReinH: yeah, i know.
18:20:57 <ReinH> but the obvious one
18:21:05 <jle`> probably the lawful one too
18:21:07 <jle`> ;)
18:21:31 <jle`> but i think there are basically an endless combination of Applicative-of-(->)-typey instances for (a -> b)
18:21:38 <jle`> why not make one that makes no sense
18:22:46 <phaazon> I feel so sad
18:22:52 <phaazon> vector doesn’t compile on ARM
18:22:56 <jle`> :(
18:23:00 <phaazon> it even generates a ghc panic
18:23:01 <jle`> ...does array?
18:23:07 <phaazon> I don’t know jle`
18:23:12 <phaazon> it’s not up to me
18:23:24 <phaazon> I’m using happstack server, which uses aeson, which uses vector
18:23:37 <jle`> oh, just trying to figure out where the problem really is
18:23:40 <rwbarton> there's a lobotomized version of vector in the debian repo I think
18:23:41 <phaazon> I think it’s a common issue
18:23:51 <phaazon> lobotomized?
18:23:51 <rwbarton> with the annotations removed
18:23:55 <phaazon> ah!
18:23:59 <phaazon> what are annotations?
18:24:19 <rwbarton> a weird pragma-like thing
18:24:30 <rwbarton> in this case it enables some optimization
18:24:33 <rwbarton> I don't know how big a deal it is
18:24:37 <phaazon> oh
18:24:40 <phaazon> you mean like
18:24:43 <rwbarton> but, it should compile and work without
18:24:45 <phaazon> {- UNBOXED -}
18:24:46 <phaazon> ?
18:24:51 <rwbarton> a bit like that yeah
18:24:56 <jle`> array always felt super unportable to me when i look at the source
18:24:56 <phaazon> ok
18:25:12 <phaazon> gonna try the vector from apt then
18:25:21 <phaazon> it’s horrible :D
18:25:22 <rwbarton> are you still using ghc from apt?
18:25:23 <Lutin^> What backend are you using?
18:25:30 <jle`> but it's listed as portable so.
18:25:34 <phaazon> I don’t like using cabal with apt…
18:25:36 <phaazon> rwbarton: yeah
18:25:49 <phaazon> ghc, ghc-doc, ghc-prof from apt
18:26:01 <phaazon> the rest from hackage directly through cabal
18:26:06 <rwbarton> jle`: well, hmm
18:26:15 <rwbarton> the implementation itself is clearly not portable
18:26:25 <rwbarton> OTOH the package is part of the Haskell 2010 report
18:26:46 <rwbarton> at least some parts are, anyway
18:27:03 <rwbarton> so in that sense it's portable in that if you have a program that uses array then you can expect to be able to port it to any compiler
18:27:14 <jle`> ah. i wasn't aware of that
18:27:28 <jle`> that makes sense
18:27:32 <phaazon> libghc-vector-space-points-dev
18:27:38 <phaazon> that?
18:27:54 <rwbarton> is there a libghc-vector-dev?
18:27:55 <jle`> so if the arm ghc is a report-abiding ghc, then it should have array working.  and vector should be the problem
18:28:12 <phaazon> rwbarton: yes
18:28:31 <phaazon> Package: libghc-vector-dev
18:28:31 <phaazon> Source: haskell-vector
18:28:31 <phaazon> Version: 0.9.1-2
18:29:55 <phaazon> it’s something I often find quite ugly, apt vs. cabal
18:30:00 <phaazon> or pacman vs. cabal
18:30:03 <phaazon> or whatever vs. cabal
18:38:10 <ASHPrime> Well guys, been fun lurking, goodnight!
18:40:44 <pepper_chico> guys, I've deleted my .ghc directory and now, ghc-pkg list is listing just a handful of packages from original ghcformacosx, and nothing related to cabal installed ones
18:41:24 <pepper_chico> what should I do, I'm not sure I should start it all over with everything I cabal install sandboxed
18:41:54 <lfairy> pepper_chico: I think that's what's supposed to happen
18:41:56 <phaazon> you are screwed, abort mission, warning, abort mission
18:42:07 <lfairy> .ghc is the directory that contains your installed packages
18:42:37 <lfairy> so yeah, reinstall them
18:42:43 <phaazon> woah, 3:41 AM
18:42:45 <phaazon> I better go…
18:42:48 <pepper_chico> =/
18:43:18 <phaazon> how have you even done that :D
18:43:23 <phaazon> « rm -rf .ghc »
18:43:30 <phaazon> « oh sh*t! »
18:43:32 <phaazon> :D
18:43:37 <pepper_chico> it was muuuuuch worst than that
18:43:42 <pepper_chico> you can't imagine....
18:43:50 <phaazon> « rm -rf ~ »
18:43:51 <phaazon> « lulz »
18:44:14 <pepper_chico> I've heard it was no problem to remove the .ghc file to solve dependency issues
18:44:22 <phaazon> :D
18:44:25 <pepper_chico> s/file//directory
18:44:34 <pepper_chico> then... accidentally
18:44:39 <pepper_chico> I've typed
18:44:50 <pepper_chico> rm -rf * .ghc/*
18:44:53 <pepper_chico> shit!!
18:44:59 <phaazon> this is my advice:
18:45:02 <pepper_chico> it was for a brief moment
18:45:14 <phaazon> echo "alias rm=rm -i" >> ~/.zshrc
18:45:14 <pepper_chico> but now, I dunno what has gone
18:45:16 <phaazon> or .bashrc
18:45:18 <phaazon> or whatever
18:45:56 <lfairy> also, install everything in a sandbox
18:45:57 <Lutin^> Well I guess deleting all your packages would fix dependency issues
18:46:00 <pepper_chico> I've done that before, but this is a somewhat newer system installation
18:46:04 <phaazon> yeah
18:46:06 <lfairy> so you never need rm -r ~/.ghc in the first place
18:46:12 <Lutin^> Nothing to depend on
18:46:13 <phaazon> in a sandbox packages won’t go in ~/.ghc
18:46:14 <Lutin^> lol
18:46:19 <phaazon> but in .cabal-sandbox
18:46:39 <eazar001> lfairy: that is good advice
18:46:45 <pepper_chico> and what I don't like about rm -i is that sometimes I want to remove a directory, but don't want to get recursive confirmations
18:47:07 <dmwit_> pepper_chico: 'rm' when you don't want the -i.
18:47:20 <dmwit_> pepper_chico: Also, removing .ghc is not a big deal. Just reinstall whatever packages you need.
18:47:22 <lfairy> eazar001: it's amazing how the answer to pretty much every dependency problem is "use a sandbox"
18:47:45 <eazar001> lfairy, yea it seems that way, it definitely feels wrong, but it does admittedly save my ass
18:47:55 <lfairy> dmwit_: phaazon recommended alias rm=rm -i earlier
18:48:23 <eazar001> my advice is if you are in ~/ always think five times and type slowly when typing 'rm'
18:48:41 <eazar001> permissions are too lax in home
18:48:45 <pepper_chico> the sad thing regarding this sandbox thing is that, should I use sandbox for everything I install, any binary or dependency that depends on other stuff, it's gonna produce a lot of duplicates
18:49:05 <pepper_chico> and symlinking binaries in sandboxed directories is annoying
18:49:07 <pepper_chico> it seems
18:49:12 <dmwit> lfairy: Yes, and 'rm' prevents an alias from expanding.
18:49:13 <eazar001> pepper_chico: minimize overhead with *shared* sandboxes
18:49:31 <eazar001> you don't necessarily have to duplicate everything n^a times
18:49:32 <lfairy> dmwit: oh, I see. You're quoting it :D
18:50:33 <eazar001> pepper_chico: for things that require a lot of dependencies, i think twice before a "system" install
18:50:56 <pepper_chico> it's funny from other point of view I know, but from my POV, ;_:
18:50:59 <eazar001> if i do a non-sandbox installation, I think "can i easily remove it, and do i need consistent access to it"
18:51:03 <pepper_chico> what have gone?
18:51:09 <pepper_chico> ....
18:51:24 <phaazon> 03:47 < pepper_chico> the sad thing regarding this sandbox thing is that,  should I use sandbox for everything I install, any binary  or dependency that depends on other stuff, it's gonna  produce a lot of duplicates
18:51:30 <phaazon> I personnally like that
18:51:33 <phaazon> with add-source
18:51:42 <phaazon> it’s perfectly useable :)
18:51:43 <phaazon> usable*
19:03:17 <ninja_code> omg
19:03:25 <ninja_code> haskell makes code refactoring enjoyable
19:03:29 <ninja_code> this is amazing
19:03:37 <ninja_code> I added a new field to a datatype
19:03:40 <ninja_code> got a bunch of type errors
19:03:48 <ninja_code> and those type errors basically = a todo list of what I need to fix
19:04:11 <Iceland_jack> ninja_code: glad to see your excitement :)
19:05:44 <sshine> ninja_code, yes, getting a list of errors before you run the program becomes a habit.
19:05:46 <dwcook> ninja_code, you mean compared with errors amounting to weird runtime behavior, like you might get in a dynamically typed language?
19:06:08 <ninja_code> dwcook: yeah, like in clojure (my previous favorite langauge)
19:06:10 <ninja_code> I would edit the code
19:06:14 <ninja_code> run it, get a weird error
19:06:19 <ninja_code> then be like "wtf, how did I even get to this place"
19:06:26 <ninja_code> then put in lots of printlns dumping out variable values
19:06:36 <ninja_code> and realize "oh, 5 function calls earlier, something went wrong"
19:06:45 <ninja_code> wherehas haskell is like "dude, function foo won't work"
19:06:49 <bygone> The ghc errors have a tendency to be really long. It's always scary to compile and get pages of getting grilled by ghc.
19:06:55 <ninja_code> and I'm like "ah, that's eaxctly where the error would start"
19:07:02 <dwcook> Although to be fair a lot of that isn't so much the unityping as the approach to handling errors by returning weird values
19:07:24 <ninja_code> bygone: I've never had more than 10 errors at once
19:07:34 <ninja_code> I setup emacs, so taht on save, a inotify event is fired, and ghc compiles on _every file save_
19:07:50 <Welkin> emacs auto-saves
19:08:16 <ninja_code> yes, it recompiles on auto-saves too
19:08:23 <ninja_code> though autosaves are once every 5 mins
19:08:33 <ninja_code> and I tend to write a function in less than 5 mins, so autosave triggers are not very often
19:09:02 <bygone> Haskell is good at "if it compiles, it ships" because that's basically a garauntee that it works right.
19:09:06 <bygone> Rust is the same way.
19:09:31 <ninja_code> really Rust is like ahskell w/o the laziness?
19:09:46 <Iceland_jack> Rust is very different from Haskell
19:10:00 <bygone> Not really. It's more like C with Haskell's type system.
19:10:06 <Welkin> Rust is a replacement for areas where C is normally used
19:10:13 <dwcook> bygone, I think that might be overstating it, unfortunately. Haskell's types aren't quite restrictive enough in some circumstances. For example, there's a huge variety of IO () that do a huge variety of things and may or may not be correct.
19:10:18 <Welkin> low level systems programming
19:11:26 <ninja_code> so basically
19:11:28 <ninja_code> Rus is C++ done right?
19:11:39 <Iceland_jack> yes :)
19:11:52 <bygone> It's kind of a replacement for more than C. I've been researching it, and it has the capability to replace a LOT of system level / userland code.
19:12:09 <pepper_chico> I don't think so, I expect Rust web stuff be on the hype for it, since it was created for servo, and C is not that a language of the web
19:13:05 <bygone> When C++ is this generation's COBOL, Rust will be that generation's C++.
19:13:16 <pepper_chico> ninja_code, I see almost as it, c++ done right
19:13:21 <dwcook> bygone, of course I'm not saying I know of a language whose type system *is* sufficient for the compiles→works claim. I think that's still an open problem. :)
19:13:33 <ninja_code> dwook: Coq
19:13:52 <dwcook> ninja_code, can that be used as a general-purpose programming language?
19:14:05 <pepper_chico> but with a lot more stuff beyond c++, inheritance from ML languages
19:14:17 <ninja_code> dwcook: yes, see Adam Chlipala's work with "bedrock"
19:15:26 <dolio> It's not possible to have a language where compiles -> works.
19:15:41 <dolio> Because compiling doesn't ensure that you haven't specified the problem incorrectly.
19:16:11 <bygone> dolio: Yeah, but in a year of using Haskell making the compile->work assumption has only screwed me once.
19:16:18 <bygone> But BOY can that screw you. Bye-bye database :*
19:16:31 <Welkin> it works for your specification of the problem
19:16:36 <pepper_chico> is there a good tutorial regarding haskell sandbox, I'm thinking of starting it all over again, the installation etc
19:16:38 <Welkin> in that context, if it compiles it works
19:16:40 <ninja_code> so Haskell prevents you from shooting yourself in the foot
19:16:45 <ninja_code> but when you do, you nuke the entire local town
19:16:49 <pepper_chico> shared sandboxes etc
19:16:51 <athan> Does anyone here have good experience with HXT? I'm having trouble making a logical or (<+>) without duplicating the selections
19:16:57 <glguy_> In coq your types are complicated enough that you can have bugs in them :)
19:17:24 <ninja_code> yeah, you can encode undecidable propositions in COq's type system
19:17:31 <ninja_code> Coq is actually what got me into haskell
19:18:24 <Welkin> why were you using coq?
19:20:49 <_ahg> Hi folks, I am having trouble getting Yesod installed on my Debian machine. After having dependency problems with postgresql, I tried to "start afresh" by deleting ~/.cabal and ~/.ghc, and now I'm in worse shape than before.
19:21:14 <_ahg> I successfully did "cabal install yesod-platform," but my system doesn't seem to have a yesod executable anywhere
19:21:30 <_ahg> and if I try "cabal install yesod-bin," it tells me that it's already installed
19:22:23 <bygone> _ahg: It should be in your local cabal directory.
19:22:27 <bygone> Look in .cabal/bin
19:22:31 <_ahg> My questions are twofold: 1) Is there a straightforward way to fix this mess (I don't mind if it takes a long time to download/compile packages) and 2) what is the 'correct' way to do a 'burn it to the ground and start over' on my haskell packages?
19:22:36 <_ahg> it is not in .cabal/bin
19:22:41 <bygone> Ah, shoot.
19:22:57 <benzrf> _ahg: the correct way is to rm -rf ~/.{ghc,cabal}
19:23:01 <benzrf> IME
19:23:24 <_ahg> benzrf: that's good to know--that's what I did, and I'm glad that I have the option to do it again
19:23:48 <_ahg> .cabal/bin contains several yesod-associated executables (e.g. warp, json2yaml)
19:23:49 <ReinH> _ahg: this might be helpful http://www.vex.net/~trebla/haskell/cabal-cabal.xhtml
19:23:51 <_ahg> but no yesod
19:24:02 <_ahg> ReinH: Thanks, on my way
19:25:51 <benzrf> _ahg: you may want to cabal update && cabal install cabal-install
19:25:52 <benzrf> after burning
19:26:22 <athan> Does anyone know where ArrowPlus is defined?
19:26:32 <athan> :t (Control.Arrow.<+>)
19:26:33 <lambdabot> ArrowPlus a => a b c -> a b c -> a b c
19:26:42 <Iceland_jack> athan: you can do :i ArrowPlus
19:26:49 <Iceland_jack>     ghci> :info ArrowPlus
19:27:02 <athan> oh! Thanks, sorry about that
19:27:12 <Welkin> @info ArrowPlus
19:27:12 <lambdabot> ArrowPlus
19:27:16 <Iceland_jack> No problem!
19:27:25 <Welkin> or just use hoogle
19:27:40 <_ahg> benzrf: I just rm -rf ~/.ghc and ~/.cabal, then tried cabal update, but cabal no longer exists on my system
19:27:48 <benzrf> > show <+> (show . reverse)
19:27:49 <lambdabot>  Ambiguous occurrence ‘<+>’
19:27:49 <lambdabot>  It could refer to either ‘Control.Arrow.<+>’,
19:27:49 <lambdabot>                           imported from ‘Control.Arrow’ at L.hs:36:1-20
19:27:49 <lambdabot>                        or ‘Text.PrettyPrint.HughesPJ.<+>’,
19:27:49 <lambdabot>                           imported from ‘Text.PrettyPrint.HughesPJ’ at L.hs:1...
19:27:50 <Iceland_jack> if you in GHCi and haven't added hoogle search to your .ghci you should use :i
19:27:56 <benzrf> > show Control.Arrow.<+> (show . reverse)
19:27:57 <lambdabot>  can't find file: L.hs
19:28:06 <benzrf> _ahg: http://sadtrombone.con/
19:28:08 <benzrf> oops
19:28:09 <benzrf> _ahg: http://sadtrombone.com/
19:28:11 <_ahg> haha
19:28:16 <Welkin> ...what?
19:28:17 <benzrf> > show Control.Arrow.<+> (show . reverse)
19:28:18 <lambdabot>  Could not deduce (Control.Arrow.ArrowPlus (->))
19:28:18 <lambdabot>    arising from a use of ‘Control.Arrow.<+>’
19:28:18 <lambdabot>  from the context (GHC.Show.Show a)
19:28:18 <lambdabot>    bound by the inferred type of
19:28:18 <lambdabot>             it :: GHC.Show.Show a => [a] -> GHC.Base.String
19:28:25 <benzrf> > show Control.Arrow.<+> (reverse . show)
19:28:26 <lambdabot>  Could not deduce (Control.Arrow.ArrowPlus (->))
19:28:26 <lambdabot>    arising from a use of ‘Control.Arrow.<+>’
19:28:26 <lambdabot>  from the context (GHC.Show.Show a)
19:28:26 <lambdabot>    bound by the inferred type of
19:28:28 <lambdabot>             it :: GHC.Show.Show a => a -> GHC.Base.String
19:28:31 <benzrf> huh
19:28:36 <benzrf> what *IS* an instance
19:28:41 <_ahg> benzrf: so, now I guess I have questions for #debian?
19:28:52 <benzrf> _ahg: do you have haskell-platform installed
19:28:58 <benzrf> _ahg: oh
19:29:01 <benzrf> whats the command error
19:29:25 <_ahg> benzrf: "bash: cabal: command not found"
19:29:38 <benzrf> _ahg: have you tried opening a new shell from scratch
19:29:43 <benzrf> it may have hashed the location
19:29:56 <_ahg> benzrf: just tried, no difference
19:29:58 <benzrf> ah wait
19:30:00 <benzrf> wrong error
19:30:01 <benzrf> -.-
19:30:10 <benzrf> 10:27 < benzrf> _ahg: do you have haskell-platform installed
19:30:11 <benzrf> 10:27 < benzrf> _ahg: do you have haskell-platform installed
19:30:13 <benzrf> oops
19:30:29 <_ahg> benzrf: yes
19:30:49 <benzrf> _ahg: how very odd
19:31:02 <benzrf> try 'which cabal'f
19:31:04 <_ahg> benzrf: ghc and ghci seem to be in working order
19:31:05 <benzrf> no f oops
19:31:16 <_ahg> benzrf: which cabal produces no output
19:31:18 <_ahg> it's gone
19:31:21 <benzrf> kk
19:31:27 <benzrf> well isnt that some shit
19:31:29 <dwcook> _ahg, what's your PATH?
19:32:25 <_ahg> dwcook: /usr/local/bin:/usr/bin:/bin:/usr/games:/home/ahg/bin:/home/ahg/.cabal/bin
19:32:41 <_ahg> though at the moment, /home/ahg/.cabal does not exist
19:33:14 <dwcook> Seems to be in order. Not sure what the problem would be
19:33:49 <_ahg> dwcook: well, I just deleted .ghc and .cabal from /home/ahg
19:33:58 <_ahg> I presume that cabal was in /home/ahg/.cabal/bin
19:34:04 <dwcook> _ahg, yes but if haskell-platform is installed then so should be cabal-install
19:34:23 <_ahg> right
19:34:43 <_ahg> attempting some apt-get purge/apt-get install invocations--could be a while
19:34:55 <dwcook> _ahg, first try `aptitude why cabal-install`
19:36:04 <_ahg> dwcook: too slow--apt-get install cabal-install has resulted in /usr/bin/cabal existing
19:36:12 <dwcook> Oh okay
19:36:27 <dwcook> So does it find the command now?
19:36:32 <_ahg> I hadn't seen aptitude why before--good to know
19:36:40 <_ahg> dwcook: yes, I'm updating it now
19:36:44 <dwcook> It just explains why the package is isntalled or tells you that it isn't
19:37:26 <dwcook> Oh, I might have misunderstood it somewhat though, woops
19:38:03 <dwcook> Orrr I misread its output XD Okay everything is as it should be
19:38:53 <_ahg> dwcook: yes, at the moment I think I understand what the state of my system is. upgrading to the latest cabal.
19:40:11 <_ahg> Is it good practice to operate in cabal sandboxes all the time, like before I even install yesod-platform?
19:42:37 <_ahg> dwcook: I have just updated cabal. /usr/bin/cabal is version 1.14.0, whereas ~/.cabal/bin/cabal is version 1.20.0.1. Should I cp from .cabal/bin to /usr/bin, or set up a symbolic link, or..?
19:49:09 <dwcook> _ahg, probably best put $HOME/.cabal/bin before /usr/bin in your path
19:49:40 <_ahg> dwcook: thanks, sounds reasonable
19:52:41 <hellenkanion> Can someone explain bits of the code to me out here:http://hackage.haskell.org/package/prizm-0.3.1.1/docs/src/Data-Prizm-Color.html Im very new to haskell and don't really understand what is going on there. Specifically in the interpolate function
19:56:30 <glguy_> hellenkanion: Note that: data CIELCH a = CIELCH !a !a !a
19:56:47 <glguy_> A CIELCH a is just a 3 a's
19:57:07 <hellenkanion> glguy_: ok...
19:57:09 <glguy_> The operations
19:57:11 <glguy_> ?type (<$>)
19:57:12 <lambdabot> Functor f => (a -> b) -> f a -> f b
19:57:25 <glguy_> for this type just apply the function on the left to all three of the values
19:58:12 <glguy_> CIELCH a b c <*> CIELCH x y z = CIELCH (a x) (b y) (c z)
19:58:20 <_ahg> ReinH: This link is very informative, thanks again.
19:58:24 <glguy_> So the expressions like this: (+) <$> a' <*> a
19:58:33 <glguy_> are just doing pairwise addition
20:00:35 <hellenkanion> glguy_: Ok. Got it. Tell me if Im understanding correctly: it takes two values a and b, and in the first line subtracts component wise b from a.
20:01:00 <ReinH> _ahg: np
20:01:11 <hellenkanion> glguy_: then I dont understand what (*w') is?
20:01:27 <glguy_> (* w') is a function that multiplies its argument by w'
20:01:33 <glguy_> ?type (* 5)
20:01:34 <lambdabot> Num a => a -> a
20:01:40 <glguy_> > (* 5) 10
20:01:42 <lambdabot>  50
20:02:45 <hellenkanion> glguy_: ok.
20:03:06 <glguy_> http://lpaste.net/5808585750467313664
20:03:52 <glguy_> I just did that in the text-editor, so it could be off a bit, but either way that expanded version might help you see what's going on
20:04:45 <hellenkanion> glguy_: Whoa! that is great! Makes a lot more sense now. Did you do that manually? Is there an expansion tool that I could use to do this?
20:05:08 <glguy_> I don't know of a tool to do it, but the code probably would have been clearer if it was written like that in the first place
20:05:45 <hellenkanion> glguy_: Right. Thanks a lot though. It feels great to finally get it. I'd been staring at it for about 40 mins
20:06:46 <glguy_> http://hackage.haskell.org/package/prizm-0.3.1.1/docs/src/Data-Prizm-Types.html
20:06:51 <glguy_> You can see the Functor and Applicative instances here
20:09:35 <hellenkanion> glguy_: Right.
20:12:31 <hellenkanion> glguy_: Im looking at the comments. And it says the left color is multiplied by 25% if w is 25 and the right with 75. However in the expansion nothing is multiplied by the 100-25 value. Am I missing something, or the comment is incorrect?
20:16:03 <glguy_> it adds a percentage of the difference back to th first one
20:20:05 <_ahg> alright, I have a working yesod executable. Thanks all for your help
20:21:21 <hellenkanion> glguy_: got it. Thanks.
20:26:42 <darthdeus> https://github.com/faylang/fay/issues/408
20:26:49 <darthdeus> if anyone has any clue
20:37:19 * hackagebot clone-all 0.1.0.0 - Clone all github repositories from a given user  http://hackage.haskell.org/package/clone-all-0.1.0.0 (NoonSilk)
20:42:19 * hackagebot infer-upstream 0.1.0.0 - Find the repository from where a given repo was forked  http://hackage.haskell.org/package/infer-upstream-0.1.0.0 (NoonSilk)
20:42:21 * hackagebot rados-haskell 3.0.3 - librados haskell bindings  http://hackage.haskell.org/package/rados-haskell-3.0.3 (ChristianMarie)
21:31:57 <Kaidelong> so I've been thinking about how haskell thinks about set and I'm wondering what stops this solution
21:32:12 <Kaidelong> newtype Set k = Map k k deriving Monad
21:32:39 <Kaidelong> err
21:32:55 <Kaidelong> Set { getSetRepr :: Map k k }
21:32:57 <Kaidelong> I mean
21:36:51 <Kaidelong> oh no it won't work as a newtype
21:36:59 <Kaidelong> it *would* work as a type synonym though
21:38:25 <Kaidelong> this is actually an example where inheritance polymorphism may be helpful, you could usefully implement Map k k as Map k () with a derived type and upcasting can make it look like Map k k
21:38:49 <jle`> Kaidelong: what is that a solution for?
21:39:16 <Kaidelong> jle`: the problem that Set needs specialized fmap and concat because of its constraint
21:39:51 <Kaidelong> if you just use maps instead and just allow a type synonym set
21:40:00 <Kaidelong> you can use fmap and join just fine
21:40:19 <jle`> Map isn't a Monad, is it?
21:40:57 <Kaidelong> oh, I guess it isn't, but at least you get functor
21:41:08 <jle`> and what would the functor instance be..?
21:41:10 <jle`> map over the keys?
21:41:15 <Kaidelong> map over the values
21:41:26 <jle`> without changing the keys?
21:41:29 <Kaidelong> yes
21:41:47 <jle`> but fmap can change the type
21:41:56 <Kaidelong> but fmap doesn't care about the type of the keys
21:42:05 <jle`> but it won't be Map k k
21:42:16 <Kaidelong> yeah but because it's just a type synonym
21:42:30 <Kaidelong> you end up unifying with (a -> b) -> Set a -> Map a b
21:42:56 <jle`> but doesn't your type synonym say Set a = Map a a?
21:42:56 <kini> I'm hacking on an old haskell program and some files have some lines indented with tabs and some lines indented with spaces -- is it common practice to clean this up?
21:43:27 <jle`> or newtype
21:43:29 <Kaidelong> jle`: expand the synonym and you just get (a -> b) -> Map a a -> Map a b
21:43:32 <Kaidelong> newtype wouldn't work
21:43:40 <jle`> ah
21:43:42 <dmj`> <div class="input-group margin-bottom-sm">
21:43:42 <dmj`>   <span class="input-group-addon"><i class="fa fa-envelope-o fa-fw"></i></span>
21:43:42 <dmj`>   <input class="form-control" type="text" placeholder="Email address">
21:43:42 <dmj`> oh shit sorry
21:43:54 <jle`> so when you fmap your Set...you go out of Set
21:43:57 <jle`> into Map
21:44:00 <Kaidelong> yeah
21:44:16 <Kaidelong> that does work in general but I guess it doesn't solve the problem of needing a specific fmap for sets
21:44:38 <Kaidelong> I have been thinking of this because I think people have sets all wrong
21:44:45 <ezrios> is there anything like quickcheck for C++?
21:44:59 <jle`> kini: sed?
21:45:05 <jle`> kini: oh
21:45:12 <kini> hm?
21:45:14 <ezrios> kini: if you have vim, :set expandtab :retab
21:45:23 <Kaidelong> sets are not collections, they're logic programs and you can iterate over them when they're constructed, you shouldn't need a separate set type, you should be able to use sets as types and vice versa
21:45:28 <ezrios> I think haskell style is to only ues spaces
21:45:30 <Kaidelong> although I'm pretty sure haskell cannot hope to do this
21:45:39 <kini> no, I know *how* to clean it up, I'm just asking whether there's a community consensus as to whether I should do that or not
21:45:44 <jle`> ah
21:45:48 <jle`> well, is it your program?
21:45:49 <Kaidelong> they're constructive*
21:45:50 <kini> nope :)
21:45:51 <jle`> or is it a part of a larger code base
21:45:58 <jle`> like, at work or something
21:45:58 <kini> otherwise I wouldn't have to ask of course haha
21:46:00 <jle`> or an open source project
21:46:06 <kini> (it's the happy parser)
21:46:08 <ezrios> kini: does the project have a style guide?
21:46:13 <jmcarthur> Kaidelong: your type synonym doesn't work unless you're willing to let fmap just turn it into a map
21:46:14 <jle`> if other people will be working on it, then you should probably ask the maintainers
21:46:14 <kini> (which is ancient)
21:46:19 <Kaidelong> the intersection of two sets is the most general unifier for them and the union of two sets is its disjunction
21:46:25 <Kaidelong> jmcarthur: that's exactly what it does, yes
21:46:54 <jle`> kini: if your plan is to push a patch to happy, i would probably ask the happy people
21:46:57 <jmcarthur> Kaidelong: something that actually works would be to add a an associated constraint family to Functor
21:47:04 <kini> jle`: fair enough
21:47:06 <Kaidelong> Oleg's solution
21:47:08 <jmcarthur> s/a an/an/
21:47:18 <jmcarthur> not oleg's thing, afaik
21:47:21 <jle`> as for if it's common practice...i'm sorry, i can't really answer.  tabs are not preferred in genral
21:47:24 <Kaidelong> oh just on his website?
21:47:34 <jmcarthur> isn't oleg's (now quite old) thing just restricted monads?
21:47:39 <kini> thanks jle`
21:47:54 <Kaidelong> he builds it from restricted functor
21:48:02 <jle`> this isn't restricted functor/restricted monad
21:48:09 <jmcarthur> there's also a way to do a sort of Cont transformation on Set to get a real monad, but you lose some efficiency
21:48:38 <Kaidelong> anyway I'm not really looking to "solve the problem" so much as I'm wanting to just make sure there really is no good solution
21:48:51 <Kaidelong> because I'm thinking Map k k is a bad approach to implementing Set k
21:48:58 <jle`> the constraint kinds/type family solution is rather nice i think
21:49:02 <jmcarthur> Kaidelong: anyway, my original suggestion is something like this:     class Functor f where type C f; fmap :: (C f a, C f b) => (a -> b) -> f a -> f b
21:49:21 <jmcarthur> s/type C f/type C f a/
21:49:32 <Kaidelong> however this is essentially what haskell sets are
21:50:34 <Kaidelong> the problem is that it's the naive approach to getting the two things people want out of sets, being able to produce its elements, having each element occur only once, having subset and superset comparisons, and having a membership test
21:50:40 <Kaidelong> two things?
21:50:58 <Kaidelong> I guess I was originally thinking just "get its elements and test membership"
21:51:36 <Kaidelong> I think there is a better approach to sets and I sort of have it worked out but I don't know if haskell can implement it in a sane way
21:51:56 <jmcarthur> Kaidelong: it's well known that sets have a couple ways of looking at them. one is as a collection, which yields a semantics where elements are in covariant position. the other is as a predicate, which yields a semantics where elements are in contravariant position.
21:52:31 <jmcarthur> Kaidelong: Set happens to be the former
21:52:52 <Kaidelong> jmcarthur: but we don't get covariance out of it, anyway, so why not try to get contravariance at least?
21:53:20 <jmcarthur> Kaidelong: it's still covariant.
21:53:34 <Kaidelong> jmcarthur: how do I make fmap for haskell sets?
21:53:46 <jmcarthur> Kaidelong: it's because of Functor, not because of Set
21:53:57 <jmcarthur> Kaidelong: i already showed you what Functor should look like to support Set
21:54:04 <Kaidelong> oh constrained functors
21:54:17 <jmcarthur> still functors, though
21:54:21 <Kaidelong> well yeah maybe having constrained functors by default is a better approach
21:54:39 <Kaidelong> you just need to add a typeclass "class Universal" and then add an "instance Universal t"
21:56:07 <jmcarthur> not sure where you are going with this Universal type class
21:56:43 <Kaidelong> so that you can make functors that don't actually require a constraint
21:56:57 <jmcarthur> oh, i think you maybe missed the correction i made to that immediately after saying it
21:57:05 <jmcarthur> you don't need anything like Universal
21:57:12 <jmcarthur> () :: Constraint   is a thing
21:57:19 <Kaidelong> oh okay
21:57:20 <Kaidelong> neat
21:57:46 <jmcarthur> i think you might even be able to give it a default in the class definition? not so sure there
21:59:27 <augur> is there a good way to pattern match on Data.Map?
21:59:36 <augur> like, for key-value pairs?
21:59:50 <augur> or, is there a good matchable kv-pair type?
22:00:24 <jmcarthur> Kaidelong: yup, you can even use that as a default, so you don't have to say it explicitly if you don't need to add any constraints in the instance:  class Functor f where type C f a :: Constraint; type C f a = (); fmap :: (C f a, C f b) => (a -> b) -> f a -> f b
22:00:59 <jmcarthur> augur: well, there's pattern synonyms now. or are you asking if a good function to use to define such a pattern synonym exists already?
22:01:12 <augur> jmcarthur: neither :)
22:01:39 <augur> im looking to see if Data.Map, or some other type, exists so that you can write pseudo-record-like things as patterns
22:01:54 <augur> where the keys arent fixed
22:02:25 <augur> like, i want to write something like   foo ({ "a" => a, "b" => b }) = ...
22:02:39 <augur> where the type of the argument is something like Map String Int, say
22:02:42 <augur> or whatever
22:03:16 <augur> i could match on toList, but thats kind of ugly, so i was wondering if there's a better answer
22:04:22 <jmcarthur> augur: so you're rejecting a pattern synonym like  foo (ToList [("a", a), ("b", b)]) = ...  just because it's not so pretty?
22:04:37 <augur> jmcarthur: no, because its not extensible
22:04:40 <jmcarthur> augur: you could always make another sort of pattern for tuples that looks more like an arrow
22:04:48 <jmcarthur> what do you mean by extensible?
22:05:04 <augur> yes, i can define ONE pattern synonym, but i want the whole generic slew of them
22:05:16 <augur> so that i can match on arbitrary map patterns
22:05:29 <jmcarthur> example?
22:05:38 <augur> well, who says foo has to look at just "a" and "b"
22:05:45 <augur> maybe in another branch it looks at just "x"
22:05:51 <augur> and in another it looks at "d", "e", and "f"
22:05:52 <augur> etc etc
22:05:56 <jmcarthur> that seems totally supported to me...
22:05:57 <Kaidelong> haskell could probably do contrasets pretty easily so long as you don't require the ability to generate elements
22:06:00 <augur> jmcarthur: really?
22:06:11 <augur> jmcarthur: maybe i should read more about pattern synonyms :x
22:06:23 <jmcarthur> augur: it's just a pattern synonym defined as a view pattern with toList or somesuch
22:06:43 <augur> jmcarthur: another problem tho is that the toList thing presupposes some kind of sorting, and that's kind of unpleasant
22:07:10 <jmcarthur> there may be a way, but i want to play around a bit
22:07:27 <jmcarthur> Kaidelong: yeah, that's just   type Set a = a -> Bool   :P
22:07:39 <augur> this is kind of a problem from with modularity in haskell, i feel. probably in other languages too, but i think proper module systems can address it better because of how they have to export pattern matching
22:09:03 <jmcarthur> i have never used a module system that concerns itself with pattern matching at all. or are you actually talking about some sort of row typing?
22:09:21 <augur> jmcarthur: proper modularity requires that you dont have dependence on implementation
22:09:30 <jmcarthur> yup
22:09:41 <augur> jmcarthur: so you cant care what the constructors are, so you cant pattern match on data
22:10:32 <augur> jmcarthur: so proper modularity needs to export pseudo-constructors and pattern match/recursion functions (ie functions like `maybe`) which the system uses to implement pattern matching
22:11:13 <augur> i dont know of any language that _actually_ does this except maybe epigram, because it requires that you have a semi-non-core notion of matching
22:12:17 <jmcarthur> even in haskell you can choose what to export. in many MLs you can separate signatures from implementations.
22:12:26 * hackagebot locators 0.2.4.2 - Human exchangable identifiers and locators  http://hackage.haskell.org/package/locators-0.2.4.2 (AndrewCowie)
22:12:31 <augur> yes but thats missing the point, jmcarthur
22:12:50 <jmcarthur> i see tying that to pattern matching a merely syntactic matter
22:12:56 <augur> choosing not to export constructors prohibits pattern matching entirely
22:13:08 <augur> what i want is matching, but without dependence on constructors
22:13:15 <augur> rather, dependence on functional structure
22:13:40 <augur> the case of Data.Map is a good example
22:13:54 <augur> you cant/dont-want to access the actual constructors
22:14:00 <augur> the representation for Data.Map is irrelevant
22:14:05 <augur> its a k-v map
22:14:19 <augur> but you still would like to be able to pattern match on it elegantly
22:15:38 <jmcarthur> would be nice to be able to define a pattern synonym like this:   pattern Member k v <- (Map.lookup k -> Just v)
22:15:51 <augur> eh
22:16:02 <jmcarthur> just came up while i was playing around
22:16:12 <jmcarthur> not trying to say it would solve the problem you are describing
22:16:52 <jmcarthur> would mean you have to give k in the pattern to use in the lookup
22:17:23 <jmcarthur> could maybe be generalized to some sort of list of such patterns, and then you don't have to match all mapping just to match on any of them
22:17:28 <jmcarthur> *mappings
22:18:07 <augur> well i just want to match keys really
22:18:17 <jmcarthur> anyway, i'm generally not too bothered by the Data.Map example, since there isn't some set of virtual constructors i can think of that would capture its semantics anyway
22:18:31 <augur> what do you mean
22:19:23 <augur> the obvious natural pseudo-constructors for Data.Map are   empty :: Map k v   and   insert :: k -> v -> Map k v
22:20:11 <Kaidelong> insert is poorly named
22:20:14 <Kaidelong> why not singleton
22:20:16 <augur> of course you'd want to sugar. instead of empty, {}, and instead of    insert k v (insert k' v' ...)   write   { k = v, k' = v', ... }
22:20:30 <augur> Kaidelong: because its not a singleton?
22:20:51 <augur> insert k v empty   is a singleton, sure, but in the same way that  x:[]  is a singleton
22:20:51 <Kaidelong> it's a singleton map? I'm pretty sure singleton is an overloaded word
22:20:58 <jmcarthur> to me, it makes the most sense if the set of exposed constructors are syntactically sufficient to express any operation that makes sense for the model. however, i now realize that empty and insert are indeed sufficient
22:21:02 <Kaidelong> oh then maybe you gave the wrong type
22:21:05 <jmcarthur> Kaidelong: the type augur gave is incomplete
22:21:11 <augur> Kaidelong: oh sorry, i left out
22:21:17 <augur> insert :: k -> v -> Map k v -> Map k v
22:21:18 <augur> :x
22:21:31 <jmcarthur> well, sufficient if they are bidirectional
22:21:52 <jmcarthur> e.g. i should be able to use the "insert" pattern to remove elements as well
22:22:00 <jmcarthur> oh but wait, weirdness happens
22:22:35 <benbangert> so yea, if whoever deleted the docs for bytestring-0.10.0.2 on hackage could undo that, would be pretty damn sweet
22:22:46 <benbangert> an insane amount of hackage docs are broke that all link to ByteString cause of that
22:22:47 <augur> jmcarthur:    remove rem (insert k v m) = if rem == k then m else insert k v (remove rem m)
22:23:13 <jmcarthur> Insert k v m = Insert k' v' m'     -- the m on the left might not be equal to the m' on the right
22:23:30 <augur> jmcarthur: thats correct
22:24:15 <jmcarthur> err, i meant for k == k' and v == v'
22:24:47 <augur> so you mean   insert k v m = insert k v m'   --/-->   m = m'
22:24:48 <augur> ?
22:25:00 <jmcarthur> i am being a bit imprecise
22:25:04 <jmcarthur> let me try again
22:25:06 <augur> thats true. if k shadows in m, but not m', thats true
22:25:32 <jmcarthur> say Insert can be used both for construction (on the right) and destruction (on the left)
22:25:36 <augur> for instance    insert "a" 0 empty = insert "a" 0 (insert "a" 1 empty)
22:26:02 <jmcarthur> exactly
22:26:43 <augur> i would say the "right" thing to do for insert is to flush the old definitions. so if you implement Map k v as [(k,v)] then insert has to filter first
22:26:43 <jmcarthur> i guess the equality isn't wrong, but this is weird to think about
22:26:55 <augur> but thats ok
22:27:11 <augur> you can define sensible induction principles, they just need to be defined over the flushed things
22:28:22 <augur> something like this:     mapInd : {K V : Set} -> (P : Map K V -> Set) -> P empty -> ((k : K) -> (v : V) -> (m : Map K V) -> P (flush k m) -> P (insert k v m)) -> (m : Map K V) -> P m
22:29:20 <augur> that way no matter what m is, the inductive step cannot expect that P holds for m directly, but rather it holds for m whether it has key k or not
22:29:53 <augur> that way if insert flushes too -- insert k v m = insertRaw k v (flush k m)
22:30:27 <augur> then you can just pattern match trivially, and the m argument in the pattern will always be the same no matter what
22:30:58 <augur> case insert "a" 0 empty of insert "a" 0 m -> ...
22:31:09 <augur> and   case insert "a" 0 (insert "a" 1 empty) of insert "a" 0 m -> ...
22:31:17 <augur> with bind m to "empty" in both cases
22:42:42 <jle`> i love the type system
22:42:59 <jle`> i can go back into a project i haven't touched in half a year and be confident that my changes don't break anything
22:46:30 <nisstyre> jle`: assuming cabal hasn't fucked up anything
22:46:51 <nisstyre> so assuming you used a sandbox correctly
22:47:04 <jle`> i sandbox and carefully pick my ghc versions
22:47:12 <jle`> but i am also referreing specifically to changes in code :|
22:47:27 <nisstyre> oh I thought you meant whether your code breaks or not during builds
22:48:27 <jle`> oh i meant that i can make architecture changes
22:48:37 <jle`> or like small minor changes to small parts of the system
22:48:42 <jle`> in the source code
22:48:53 <jle`> and if the types match up i can be more or less sure that the thing works
22:49:47 <nisstyre> jle`: assuming you've used the type system to its full potential ;)
22:50:09 <nisstyre> (nothing is stringly typed, etc)
22:50:29 <jle`> i try my best ^.^
22:57:29 * hackagebot rados-haskell 3.0.4 - librados haskell bindings  http://hackage.haskell.org/package/rados-haskell-3.0.4 (ChristianMarie)
23:09:01 <AshyIsMe> is there a way to serialise a Data.HashMap.Strict to string or ByteString?
23:14:55 <jle`> AshyIsMe: is there a Binary or Serializeable instance?
23:16:03 <AshyIsMe> doesn't look like it
23:16:13 <AshyIsMe> there's toList and fromList functions
23:16:23 <AshyIsMe> maybe i can use those
23:16:42 <AshyIsMe> the hashmap should always be fairly small so im not too worried about performance
