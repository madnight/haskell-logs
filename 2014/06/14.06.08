00:00:04 <kosmikus> enthropy: yes, I can do it, by special-casing the one-element case
00:00:20 <Maxdamantus> Mm .. “uses an amount of space that is "close" to the information-theoretic lower bound”
00:00:24 <kosmikus> enthropy: not sure if it's worth it, but in my toy example it works
00:00:32 <Maxdamantus> This uses the amount of space that is the information-theoretic lower bound.
00:01:08 <Maxdamantus> but you can't modify things in-place.
00:01:09 <enthropy> kosmikus: does that also cover    get `asTypeOf` (StateT s (Reader r) s')?
00:02:49 <kosmikus> enthropy: currently not, but I don't see why it couldn't be extended to do this
00:02:50 <ReinH> carter: your FACE is a bijection.
00:03:04 <carter> ReinH: i'll tell my ex that when we next hang out
00:03:07 <carter> :)
00:03:11 <kosmikus> enthropy: thanks for these questions. they're a useful direction for further investigation.
00:03:18 <ReinH> Hah
00:04:31 <kosmikus> enthropy: so in the original approach, I was just looking for a "StateT" of the right type, but we could just first look for all the "StateTs", and then treat the case where there's a single one differently from the case where there are multiple ones
00:13:23 <matematikaadit> so in order to understand what is the difference between `StateT s [] a` and `ListT (State s) a` I create this snippet: http://lpaste.net/105268 please tell me If I got something wrong.
00:14:01 <kosmikus> enthropy: yes, it works :)
00:17:01 <matematikaadit> From what I see. in `ListT (State s) a`, we have one shared state for every branching. But in `StateT s []`, we got multiple state for some branching. Am I right?
00:17:44 <corgifex> I haven't looked at your code but your description sounds vaguely right
00:20:55 <matematikaadit> I mean in `StateT s []`, the state is being reset.
00:44:44 <funfunctor> whats the issue here? https://gist.github.com/victoredwardocallaghan/2e1c24ff43462f1af4a5
00:44:54 <funfunctor> I get     Parse error: naked expression at top level
00:44:55 <funfunctor>     Perhaps you intended to use TemplateHaskell
00:45:13 <shachaf> importi
00:45:31 <shachaf> Does the error message really not include a line number?
00:46:40 <funfunctor> ah just spotted it
00:46:45 <funfunctor> yes thanks shachaf :)
00:46:53 <funfunctor> shachaf: no it didn't
00:47:31 <corgifex> I find that hard to believe
00:48:10 <shachaf> When I ghci that file I get a line number.
00:48:20 <shachaf> Maybe you have something odd going on with GHC.
00:48:44 <shachaf> You should get it fixed, because the line number is often the most useful information in the error message.
00:50:27 <funfunctor> corgifex: belief has nothing to do with fact
00:50:42 <enthropy> hmm, is there a way to get ghc-7.8 to display kind variables like 7.6 used to?
00:50:48 <corgifex> funfunctor: screenshot?
00:51:26 <ion> “funpunctor”
00:52:03 <funfunctor> old ghc on solaris, not surprised
01:03:17 <exicer> How would you write a function to parse a string into a time datetime, where the string can take on a number of different formats ?
01:06:26 <matheus23> wow. I just got a segfault
01:22:56 <dagle> exicer: UTCTime?
01:23:02 <dagle> oh
01:23:08 <exicer> dagle: What do you mean ?
01:23:35 <dagle> Missed that "type DateTime = UTCTime"
01:23:37 <exicer> I may actually want to parse it into Day, looking more closely :p
01:23:59 <exicer> I posted the question on stackoverflow: https://stackoverflow.com/questions/24104266/parsing-multiple-date-formats-in-haskell
01:24:17 <dagle> exicer: Look at parseTime, I used it yesterday when I wanted to parse dates from strings.
01:25:47 <SuperMind> Anyone familiar with jhc/ajhc ?
01:26:26 <SuperMind> i just installed it, and it doesn't work out of the box, because i guess it needs libraries built first.. but i'm unclear where to find those libraries that the internet says it comes with
01:30:46 <SuperMind> http://lpaste.net/105274 <-- this is what i get when i try
01:50:33 <andkore> Does anyone know how to make EclipseFP use tabs instead of spaces?
02:03:18 * hackagebot bytes 0.14.0.2 - Sharing code for serialization between binary and cereal  http://hackage.haskell.org/package/bytes-0.14.0.2 (EdwardKmett)
02:13:12 <anon_555> How do you read this my_length :: Num a => [t] -> a
02:13:16 <anon_555> or understand it
02:13:24 <anon_555> my_length is a function
02:13:36 <johnw> Given a list of anything, return a number
02:14:15 <johnw> although, the type is not enough to tell you what it really does, as it could also be "const 0"
02:15:21 <anon_555> what can be parameter give one example please
02:15:36 <johnw> can you rephrase your question?  I didn't understand
02:15:37 <dramforever> [1,2,3]
02:15:51 <dramforever> did you mean that?
02:16:11 <anon_555> Prelude> my_length [1,2,3]
02:16:11 <anon_555> *** Exception: <interactive>:29:5-39: Non-exhaustive patterns in function my_length
02:16:16 <anon_555> it gives this
02:17:01 <dramforever> anon_55,5 it's not a problem with the type. let's the definition
02:17:06 <nschoe> anon_555, you may have forgotten the base case of recursion (i.e. empty or singleton list)
02:17:14 <dramforever> the -> see the
02:18:05 <Rufflewind> why does "let (y, d) = (0, 1) in 1 % (y + d) :: Rational" cause a type ambiguity in 'y' and 'd'?
02:19:05 <dramforever> Rufflewind, a Rational can have any numerator and denominator as long as it's a integet
02:19:30 <enthropy> @src Rational
02:19:31 <lambdabot> type Rational = Ratio Integer
02:19:47 <dramforever> oh sorry
02:20:15 <anon_555> i am trying in terminal
02:20:24 <anon_555> let my_length [] = 0
02:20:27 <dramforever> @type 1 % (y+d)
02:20:29 <lambdabot> Ratio Expr
02:20:29 <anon_555> like this
02:20:37 <anon_555> will it replace if i define the function again
02:21:11 <nschoe> anon_555, what result do you get with `my_length [4]' ?
02:21:15 <dramforever> yes, just think that ghci is a big interactive do
02:21:28 <Mon_Ouie> anon_555: You can use a semi colon to have multiple definitions in one line
02:21:34 <dramforever> @type 1%(0+1)
02:21:35 <lambdabot> Integral a => Ratio a
02:21:38 <anon_555> *** Exception: <interactive>:29:5-39: Non-exhaustive patterns in function my_length
02:21:42 <Mon_Ouie> let f [] =  0; f (x:xs) = …
02:22:21 <enthropy> Rufflewind: is that the whole example?
02:22:35 <Rufflewind> enthropy: it's the smallest that reproduces the problem
02:22:47 <dramforever> Rufflewind, you see this
02:22:56 <dramforever> @type 1%(0+1)
02:22:57 <lambdabot> Integral a => Ratio a
02:22:59 <nschoe> anon_555, see : it seems your definition doesn't take one-element lists into account, so when you call it with a long list and eventually it breaks down to calling your function with a list containing one element, it fails
02:23:07 <Rufflewind> enthropy: you'll have to use -Wall to see the warning though
02:23:26 <nschoe> anon_555, are you familiar with recursion ?
02:23:30 <Rufflewind> dramforever: I have (:: Rational) which is supposed to fix a ~ Integer
02:23:31 <anon_555> yes
02:23:55 <nschoe> anon_555, so you understand what I mean by `base case` ?
02:24:16 <enthropy> let bound things are generalized. You can do "case (0,1) of (y, d) -> 1 % (y + d) :: Rational" if you want y and d to be monomorphic
02:24:24 <anon_555> ok for o or empty list
02:24:41 <anon_555> nschoe and what is => symbol in haskell
02:25:21 <dramforever> anon_555, it's a class constraint, but u have to know aboit typeclasses
02:25:50 <anon_555> ok
02:25:52 <nschoe> anon_555, it is a type constraint : my_length :: Num a => [t] -> a says that the type that will be returned by your function will be an instance of Num
02:26:11 <Rufflewind> enthropy: hrm I see, that would explain why it went away when I disabled NoMonomorphismRestriction
02:26:21 <Rufflewind> enthropy: thanks!
02:28:55 <dramforever> oh, I don't know if it's right to ask here, but how to disable window resizing with GLUT
02:30:09 <dramforever> it seems that GLFW has window hints which can be used
02:34:43 <anon_555> how does (x:xs) matches the non-empty list
02:34:45 <anon_555> sirs
02:35:19 <dramforever> anon_555 it doesn't
02:36:05 <anon_555> why isn't it the way to pattern match the non-empty list
02:36:12 <dramforever> @src []
02:36:12 <lambdabot> data [] a = [] | a : [a]
02:36:47 <dramforever> anon, it is
02:36:58 <nschoe> dramforever, actually (x:xs) doest match the *non*-empty list, right ?
02:37:12 <dramforever> yes
02:37:44 <nschoe> I think you read "the empty list" instead, right ?
02:38:23 <nschoe> anon_555, (x:xs) will match the non empty-list as following : `x` will be bound to the head of the list (i.e. the first element) and `xs` will be bound to the tail, i.e the rest of the list
02:38:48 <dramforever> hate English..I tried to say that x:xs *is* a way to match *non*-empty lists
02:39:16 <nschoe> anon_555, for instance, (x:xs) will match [1,2,3] as follows : `x` will be bound to `1` and `xs` will be bound to [2,3]
02:39:18 <dramforever> wait x:xs doesn't??? match???
02:39:53 <dramforever> nschoe [1,2,3] is a non-empty list
02:40:04 <nschoe> dramforever, yes, and ?
02:40:25 --- mode: ChanServ set +o shachaf
02:40:37 --- mode: shachaf set -bo *!*@nl4x.mullvad.net shachaf
02:40:38 <dramforever> you said it doesn't match
02:41:35 <nschoe> dramforever, ho I'm stupid, sorry I did mean to write "does" rather than "doesn't"
02:42:10 <shachaf> f-a: For what it's worth, one way to avoid this would be to get a Freenode cloak for your account so your hostname looks like unaffiliated/f-a rather than an actual hostname.
02:42:15 <shachaf> But I think it should be fine for now.
02:42:48 <f-a> thanks for the tip shachaf , I will lookg into it
02:43:12 <dramforever> let's forget about all this **** and conclude that (x:xs) for non-empty lists and [] for empty lists
02:45:12 <matheus23> readIORef gives me a segfault. What should I do?
02:45:47 <matheus23> everything is type-correct. No unsafecoerce/unsafePerformIO or whatever (at least on my side of the code)
02:45:58 <dramforever> give us your full code
02:46:23 <matheus23> hm... it's not that easy. You'd need to read through it, but well, there you go:
02:46:44 <dramforever> hey wait
02:47:02 <dramforever> put it on a pasting site and give us a url
02:48:49 <matheus23> dramforever: well... as I said. It's not that easy
02:49:14 <matheus23> dramforever: Segfault seems to occur here: https://github.com/matheus23/GameSystem/blob/master/GLFWInput.hs#L63
02:49:30 <f-a> my question: I have a problem which could be elegantly solved by State and List monads ( |s -> ([a], s)| ). Reading the documentation of ListT (in Control.Monad.List) there is written " Note: this does not yield a monad unless the argument monad is commutative. "). And state is very much non commutative. How can I solve this (i.e. get the functionalities of both monads)? I could write my own instance, but for sure someone else solved this problem before me.
02:52:06 <shachaf> Would the handwritten Monad instance be valid?
02:52:13 <dramforever> f-a : How about StateT and list
02:52:27 <shachaf> @google ListT done right
02:52:29 <lambdabot> http://www.haskell.org/haskellwiki/ListT_done_right
02:52:29 <lambdabot> Title: ListT done right - HaskellWiki
02:52:43 <shachaf> ☝ might work for you, depending on what behavior you're trying to get
02:53:21 <Philonous> f-a, If you want branching / backtracking, LogicT is probably a better choice anyway: http://hackage.haskell.org/package/logict
02:53:29 <f-a> dramforever: I think StateT would lead to s -> [(a,s)]
02:53:45 <matheus23> dramforever: Maybe a little explanation about what's going on could help: I have a (more or less) global "inputRef :: IORef UserInput" which I need to pull mouse positions from. And GLFW provides callbacks for mouse position updates. The line I gave you is from the callback where the IORef should be read and afterwards be written to, but it doesn't seem to work :/
02:55:27 <shachaf> There are many different things that could be going wrong.
02:55:56 <shachaf> It sounds like you're doing all sorts of FFI things so I'd imagine that's where the issue is.
02:56:18 <dramforever> matheus23, did you know modifyIORef
02:56:55 <dramforever> matheus23, did you know $~ and $~! also works for IORef s?
02:57:07 <matheus23> uh, no
02:59:23 <f-a> thanks shachaf and Philonous , will look into that.
02:59:47 <dramforever> matheus23 can you show me where did you call mousePos?
03:00:53 <matheus23> dramforever: the stack goes like this:
03:00:54 <matheus23> I register all kinds of callbacks: https://github.com/matheus23/GameSystem/blob/master/GLFWInput.hs#L84
03:00:54 <matheus23> Which happens upon creating a window: https://github.com/matheus23/GameSystem/blob/master/GLFWWindow.hs#L49
03:00:54 <matheus23> Which happens in the main method: https://github.com/matheus23/GameSystem/blob/master/Main.hs#L18
03:01:03 <matheus23> (going down to top)
03:02:20 <matheus23> dramforever: thanks for that modifyIORef gem, btw. :) It works (type-compiles), but obviously doesn't fix my segfault ^^
03:03:53 <dramforever> maybe it is a strictness issue. try get inputRef >>= print in the mouse callbacl
03:04:13 <dramforever> callback, and see the value each time
03:04:40 <dramforever> oh, get is in Graphics.UI.GLFW
03:04:56 <nschoe> dramforever, sorry got called elsewhere, thanks for cleaning up the mess with empty lists ^^
03:05:22 <dramforever> you are welcome :)
03:06:08 <matheus23> dramforever: are you sure? It doesn't seem to find GLFW.get?
03:06:18 <dramforever> ok
03:06:30 <dramforever> maybe getIORef
03:06:56 <matheus23> well... there is readIORef, but I don't know whether you mean that?
03:07:51 <dramforever> yes....ok...
03:08:26 <matheus23> dramforever: and that fails, because readIORef fails. So my line now was "readIORef inputRef >>= print", but the problem is that it doesn't even get to print it, because readIORef already segfaults :(
03:09:06 <dramforever> oh..I thought you said input fails..
03:10:07 <matheus23> I also tried out atmoicModifyIORef... but this doesn't seem to help (I'm not that good when it comes to multithreading... I just now that the callbacks happen in another thread and yeah...)=
03:12:42 <dramforever> matheus23, where did you poll events?
03:13:01 <dramforever> it seems that you disabled auto-polling
03:13:16 <matheus23> dramforever: in the main thread in my game loop: https://github.com/matheus23/GameSystem/blob/master/GameLoop.hs#L32
03:13:21 <matheus23> huh? auto-polling, what's that?
03:15:07 <dramforever> I think you disabled the "glfw feature" ... forget about it...
03:15:25 <matheus23> ah I get what you mean, google helped me with this one :D
03:15:57 <matheus23> dramforever: true, I disabled autopolling: https://github.com/matheus23/GameSystem/blob/master/GLFWWindow.hs#L38
03:16:04 <dramforever> you have this in your code GLFW.disableSpecial GLFW.AutoPollEvent
03:16:06 <dramforever> yes
03:16:36 <dramforever> sorry, but still did not see any event polling code...
03:17:50 <matheus23> dramforever: I don't poll events, that's the thing.
03:18:30 <matheus23> basically, GLFW.swapBuffers, which draws the back buffer to screen also polls events (usually, if I didn't disable polling >.> (commented out that line now))
03:18:57 <matheus23> upon polling events those callbacks are called (I think?)
03:19:12 <dramforever> what if you change mousePos to undefined what happens and where they happen
03:20:11 <dramforever> so that you can tell me where GLFW calls mpusePos
03:20:39 <matheus23> I didn#t test it but I'm pretty sure it'll cry here: https://github.com/matheus23/GameSystem/blob/master/GLFWInput.hs#L84
03:21:34 <matheus23> quite strangely, key input works flawlessly
03:21:46 <dramforever> oh and how about putStrLn "Ah I'm failing"
03:23:53 <matheus23> dramforever: in mousePos, right in front of readIORef, that prints. But just right when readIORef is executed, the program segfaults
03:24:30 <dramforever> wait how come you use Position in the type and GL.Position in the definition?
03:26:52 <dramforever> matheus23 can you try to readIORef inputRef >>= print wherever you get events?
03:27:24 <matheus23> dramforever: because due to the import "import Graphics.Rendering.OpenGL as GL" Types are imported as normally, but constructors need prefix (afaik?)
03:27:37 <matheus23> dramforever: already tried that, it doesn't print anything, because it segfaults
03:27:53 <dramforever> ok, maybe isolate this to a small program that segfaults?
03:28:24 <matheus23> dramforever: yeah. I think that's the best idea for now. I'll try :)
03:28:28 * hackagebot simple-conduit 0.2.0 - A simple streaming library based on composing monadic folds.  http://hackage.haskell.org/package/simple-conduit-0.2.0 (JohnWiegley)
03:28:30 <dramforever> "key input also works" so that how about printing the result in the key inpit code
03:29:11 <Kaidelong> has anyone played with the idea of higher order typeclasses?
03:29:24 <johnw> like type classes for kinds?
03:29:43 <dramforever> type classes classes?
03:29:49 <avaritia> hey guys is there in haskell something with signature of Maybe a -> MaybeT m a ?
03:30:00 <Kaidelong> I was more thinking of a problem I've been working on where it'd be useful to have a typeclass that for any typeclass turns its methods of type r into methods of type a -> r
03:30:06 <Kaidelong> kind of like reader
03:30:08 <johnw> avaritia: MaybeT $ return mx
03:30:15 <johnw> avaritia: I have wanted that same function a zillion times
03:30:33 <_deepfire> shouldn't hoogle be able to answer this question?
03:30:40 <avaritia> johnw: i see that i'm not alone ^^, thanks
03:30:51 <avaritia> _deepfire: hoogle says there isnt such thing
03:31:27 <Kaidelong> @hoogle (MonadTrans m) => m Identity a -> m n a
03:31:29 <lambdabot> Did you mean: MonadTrans m => m (Identity m) a -> m n a
03:31:30 <lambdabot> Data.Graph.Inductive.Basic grev :: DynGraph gr => gr a b -> gr a b
03:31:30 <lambdabot> Data.Map.Lazy deleteMax :: Map k a -> Map k a
03:31:34 <johnw> I'd just define mayhap = MaybeT . return
03:32:25 <Kaidelong> it seems a function of that type should exist somewhere
03:32:37 <johnw> it does: in my dreams
03:33:24 <johnw> http://stackoverflow.com/questions/8684252/how-to-inject-a-maybe-value-into-maybet
03:33:28 * hackagebot Nomyx 0.6.0 - A Nomic game in haskell  http://hackage.haskell.org/package/Nomyx-0.6.0 (CorentinDupont)
03:33:50 <_deepfire> one thing that perplexes me to no end, is how hoogle _still_ continues to claim that 'catch' is available
03:34:12 <johnw> oh
03:34:17 <johnw> avaritia: see http://hackage.haskell.org/package/MaybeT-transformers-0.2/docs/Control-Monad-Maybe.html
03:34:18 <_deepfire> ..in base Prelude, base System.IO.Error
03:34:23 <johnw> they define it there as `maybeT`
03:34:36 <matheus23> dramforever: Without moving the mouse into the window: "UserInput {window = WindowInput {closed = False, width = 800, height = 600}, mouse = MouseInput {x = 1142, y = -347}, keys = KeyInput {down = fromList []}}"
03:35:12 <dramforever> matheus23, then move in and segfault?
03:35:21 <matheus23> yep
03:35:53 <_deepfire> I understand that there is no simple solution to signal deprecation to hoogle, but...
03:36:06 <_deepfire> it really hurts sometimes
03:36:19 <avaritia> johnw: thank you
03:37:36 <_deepfire> maybe hoogle output could be complemented by version qualifiers -- "since version X" or "until version Y"
03:37:56 <Kaidelong> @djinn ((a -> b) -> a) -> a
03:37:56 <lambdabot> -- f cannot be realized.
03:38:29 <Kaidelong> that's what I thought
03:48:30 * hackagebot folds 0.6.1 - Beautiful Folding  http://hackage.haskell.org/package/folds-0.6.1 (EdwardKmett)
03:48:31 <Kaidelong> wikipedia says callCC can be used to implement COMEFROM, but isn't that exactly what it is?
03:48:32 * hackagebot Nomyx-Core 0.6.0 - A Nomic game in haskell  http://hackage.haskell.org/package/Nomyx-Core-0.6.0 (CorentinDupont)
03:48:34 * hackagebot Nomyx-Web 0.6.0 - Web gui for Nomyx  http://hackage.haskell.org/package/Nomyx-Web-0.6.0 (CorentinDupont)
03:48:36 * hackagebot Nomyx-Language 0.6.0 - Language to express rules for Nomic  http://hackage.haskell.org/package/Nomyx-Language-0.6.0 (CorentinDupont)
04:07:15 <_deepfire> chrisdone, ping
04:08:54 <_deepfire> chrisdone, 1. "Show me the money" didn't accept `let (_, (a : _)) = (10, "abc") in a` as an answer
04:10:16 <bitemyapp> chrisdone: I couldn't really tell if there was a difference when I tried http://chrisdone.com/posts/making-ghci-fast
04:10:29 <bitemyapp> chrisdone: is -fobject-code supposed to be in my GHC flags in Cabal?
04:10:54 <_deepfire> chrisdone, 2. sometimes, when getting stuck, one could want to go to a previous slide
04:12:24 <ironChicken> if i want to have a "read-only" (or peek-only) Storable instance, is it sufficient just not to provide a poke implementation?
04:12:54 <Axman6> poke = error "Data.Foo.Bar.poke: Not implemented"
04:13:12 <ironChicken> Axman6: ah ok, thanks
04:13:35 <hpc> isn't something like that the default for nonspecified class methods?
04:14:21 <_deepfire> There's no way around the minimum type class requirement, AFAIUI
04:16:17 <ironChicken> hpc: it looks like the default implementation of poke is pokeElemOff ptr 0
04:22:55 <hpc> ah, that makes sense then
04:25:12 <ozkar> hello
04:26:12 <ozkar> ping.
04:26:18 <johnw> hi
04:26:28 <bitemyapp> ozkar: hi
04:26:39 <bitemyapp> ozkar: IRC is a roughly asynchronous thing that waxes and wanes.
04:26:52 <bitemyapp> ozkar: you should get used to tossing stuff out there, checking periodically, and mostly just kinda "being around" and waiting.
04:27:03 <bitemyapp> ozkar: especially if you have a very specific question that less than hte majority present could answer.
04:28:11 <ozkar> not sure if a bot.
04:28:31 <SwashBuckla> Form W-8BEN: Has anyone filled one out before?
04:28:47 <SwashBuckla> (offtopic, admittedly)
04:29:28 <ozkar> bitemyapp: i know, its just that its 6:30am ~ish on USA so maybe people are sleeping.
04:30:08 <ozkar> was thinking if anyone know of a design pattern on functional programming equivalent to nesting loops on imperative programming?
04:30:25 <ozkar> the problem i am trying to solve is really simple indeed, print all ipv4 ips.
04:30:45 <SwashBuckla> ozkar: nested maps
04:30:49 <ozkar> the best i could think is nested maps but it isnt elegant.
04:31:05 <ozkar> SwashBuckla: [ [ [ [1..255] ] ] ] :(
04:31:07 <fragamus> > let foo = "blah" in show foo
04:31:09 <lambdabot>  "\"blah\""
04:31:31 <ozkar> this channel has a ghci interpreted via lambdabot?
04:31:31 <fragamus> can someone tell me how to pretty print that foo
04:31:36 <klrr_> is there any haskell indentation for haskell-mode that dont require manual indendation? (i.e if i hit RET at a place where it makes no sense to indent to the module decleration three lines above it shouldnt indent to it and such annoying things)
04:31:41 <dottedmag> ozkar: [(i,j,k,l) | i<-[0,1..255], j<-[0,1..255], k<-[0,1..255], l<-[0,1..255]]
04:31:51 <ozkar> of course, list comprehentions.
04:31:59 <SwashBuckla> that too :)
04:32:00 <ozkar> i feel like a tool now.
04:32:46 <ozkar> i already hada function that given a quadruple (is that the correct word for a 4 value tuple?) it will pretty print the ip.
04:32:50 <fragamus> i need foo but without quotes
04:32:55 <fragamus> > let foo = "blah" in show foo
04:32:57 <lambdabot>  "\"blah\""
04:33:02 <ozkar> > 2+3
04:33:04 <lambdabot>  5
04:33:42 <ozkar> nice, so it is a ghci interpreter embedded? any security flaws?
04:33:57 <ozkar> can you import modules? issue a quit command?
04:34:06 <dottedmag> ozkar: it's sandboxed
04:34:38 <dottedmag> ozkar: http://www.haskell.org/haskellwiki/Lambdabot
04:34:39 <d3lxa> is this possible in TH to get the lists of record accessors for a certain data? I lack docs on the subject
04:35:43 <klrr_> how do you guys indent code without going mad? am i using emacs wrong or do litterally people indent code manually in haskell-mode?
04:35:54 <bitemyapp> klrr_: what indent mode are you using?
04:36:00 <klrr_> i tried all of them
04:36:05 <bitemyapp> klrr_: tried SHM?
04:36:06 <ozkar> i just tab :\ on vim
04:36:16 <bitemyapp> klrr_: https://github.com/chrisdone/structured-haskell-mode
04:36:23 <klrr_> bitemyapp: it didnt work, might try it again though
04:36:38 <klrr_> but i tried it when it was really new so, thanks for highlighting
04:38:08 <ozkar> dottedmag: ty, very nice.
04:40:58 <dottedmag> fragamus: let foo = "blah" in foo, probably
04:41:24 <dottedmag> fragamus: why do you need show to convert string to string?
04:41:26 <klrr_> bitemyapp: it still indents my cursor in inpractical places :?
04:41:33 <klrr_> :/*
04:41:45 <dottedmag> klrr_: probably because those are still allowed according to the syntax? Not sure though.
04:42:37 <klrr_> i see why it indents my code (since i have a module decleration above) but i dont see why someone would implement that into the mode (why would someone want to indent the cursor on a random line after module decleration?)
04:43:25 <klrr_> and its not like its one backspace and its gone, no i have to delete each space it produces
04:43:27 <fragamus> doh
04:44:59 <dottedmag> klrr_: TAB should loop through all available indentation positions, doesn't it do that?
04:45:12 <klrr_> it does
04:45:27 <dottedmag> Not ideal anyway, yes.
04:46:41 <_deepfire> how does one ensure that ghc-mod picks up the dependency versions specified in the .cabal file?
04:47:01 <bitemyapp> _deepfire: make certain it's up to date.
04:47:12 <bitemyapp> _deepfire: but it's not just the cabal versions, you need to be using sandboxes.
04:47:18 <bitemyapp> _deepfire: are you using sandboxes?
04:47:52 <_deepfire> bitemyapp, I've no idea how to make ghc-mod (as employed by haskell-mode of emacs) to use sandboxes..
04:48:07 <bitemyapp> _deepfire: you don't have to do anything. I said all you had to do was make certain ghc-mod was up to date.
04:48:19 <bitemyapp> use sandboxes, use the latest ghc-mod.
04:48:36 <bitemyapp> kazu didn't add sandbox support until 4.0 and it didn't really work until 4.1.0 AFAICR
04:48:38 <_deepfire> bitemyapp, should cabal-installing ghc-mod ensure that?
04:48:55 <bitemyapp> _deepfire: I don't know what version you cabal installed, you may not have updated your cabal package index recently enough.
04:49:48 <_deepfire> ghc-mod-4.1.1 here,hmm
04:55:53 <ozkar> dottedmag: http://lpaste.net/6595180410542489600
04:55:54 <ozkar> ty
04:56:17 <ozkar> dont understand why my do is redundant though...
04:57:08 <ozkar> >prtin
04:57:34 <dp_wiz> ozkar: because you only have one expression in that do block, "mapM"
04:58:35 <dottedmag> mapM_ putStrLn $ map ip2text ipRanges
04:58:39 * hackagebot machinecell 1.0.0 - Arrow based stream transducers  http://hackage.haskell.org/package/machinecell-1.0.0 (HidenoriAzuma)
04:58:46 <dottedmag> main = ...
04:59:22 <ozkar> i really like using wheres makes me feel 1337
04:59:53 <ozkar> dp_wiz: the main is already monadic?
05:00:12 <dottedmag> :t main
05:00:12 <dp_wiz> sure it is: main :: IO ()
05:00:13 <lambdabot>     Not in scope: ‘main’
05:00:13 <lambdabot>     Perhaps you meant ‘min’ (imported from Data.Ord)
05:00:49 <ozkar> dp_wiz: didnt knew that.
05:00:50 <dottedmag> ozkar: For the added 1337 you might want to define Show instance for IP, then you won't need map ipt2text
05:01:05 <ozkar> dottedmag: awww yeahhh, great idea.
05:11:17 <ozkar> http://lpaste.net/4429179565096566784 better?
05:16:04 <dottedmag> ozkar: even simpler: main = sequence_ $ map print ipRanges
05:16:28 <ozkar> :t sequence_
05:16:29 <lambdabot> Monad m => [m a] -> m ()
05:16:36 <dottedmag> ozkar: http://hackage.haskell.org/package/base-4.7.0.0/docs/src/System-IO.html#print
05:17:33 <dottedmag> so, it is main = mapM_ print ipRanges
05:17:52 <ozkar> where does the \n comes from?
05:18:08 <dottedmag> print is putStrLn . show
05:18:28 <jophish> lambdabot can return the type of expressions. Is there a library which has a function expressionType :: String -> IO String
05:18:33 <ozkar> mmm, i see.
05:18:42 <jophish> @type id id
05:18:43 <lambdabot> a -> a
05:19:14 <dottedmag> @hoogle a -> IO a
05:19:16 <lambdabot> Control.Exception.Base evaluate :: a -> IO a
05:19:17 <lambdabot> Control.Exception evaluate :: a -> IO a
05:19:17 <lambdabot> Control.OldException evaluate :: a -> IO a
05:19:26 <dottedmag> :t return
05:19:28 <lambdabot> Monad m => a -> m a
05:19:59 <ozkar> f = "string" ; return () ?
05:20:25 <dottedmag> ozkar: return () is of type IO ()
05:24:18 <ozkar> how can i get the warnings the paste has on ghc?
05:25:44 <ion> Install hlint and run it against the source file.
05:26:45 <ozkar> allright, thanks a lot guys.
05:26:55 <ozkar> a lot of nice tips.
05:27:16 <bitemyapp> ozkar: what editor do you use?
05:27:53 <ozkar> bitemyapp: vim
05:28:12 <bitemyapp> ozkar: you can setup vim to let you call hlint inside the buffer
05:28:44 <bitemyapp> there's an auto-installer here: https://github.com/begriffs/haskell-vim-now
05:28:44 <thoughtpolice> ghc-mod will do that for you and works on vim these days, I believe. quite convenient.
05:28:48 <ozkar> does anyone know hows haskell support on OpenBSd by any reason?
05:29:15 <bitemyapp> My dotfiles have ghc-mod + vim + hlint integration too - github.com/bitemyapp/dotfiles
05:29:23 <dottedmag> ozkar: ghc is in ports on OpenBSD
05:29:25 <bitemyapp> no reason to do that nonsense manually.
05:29:53 <jrm2k6> Hi guys, whats wrong with this? https://gist.github.com/jrm2k6/bbce4aeb9e4fd46e2f86
05:30:11 <jrm2k6> I take this from an example where the person is using many1 digit
05:30:17 <jrm2k6> so it should be the same for letter/char
05:30:42 <dottedmag> jrm2k6: char expects an argument, IIRC
05:30:53 <jrm2k6> hm
05:31:02 <dottedmag> jrm2k6: probably you meant anyChar
05:31:28 <jrm2k6> dottedmag: anyChar or letter raises the same issue.
05:31:53 <dottedmag> :t anyChar
05:31:53 <ion> jrm2k6: Btw, Text.ParserCombinators.Parsec is there for backward compatibility, but Text.Parsec is the recommended module to import.
05:31:54 <lambdabot> Not in scope: ‘anyChar’
05:33:08 <dottedmag> jrm2k6: are you sure the error message is the same?
05:33:34 <jrm2k6> dottedmag: https://gist.github.com/jrm2k6/ad3e1397d99860013f3e
05:33:54 <jrm2k6> I guess I am scared now because the error message are much more complicated compared to what i am used for when playing with haskell ahah
05:34:48 <dottedmag> Uhm, that's beyond my comprehension of Haskell so far.
05:35:10 <bitemyapp> jrm2k6: it's not usually like that
05:35:24 <bitemyapp> jrm2k6: it's a side effect of having dived into something Parsec related.
05:35:54 <jrm2k6> bitemyapp: i wouldnt call diving the fact of trying to parse a word on a line but i see what you mean
05:35:54 <jrm2k6> :)
05:36:03 <jrm2k6> I am looking at this http://therning.org/magnus/archives/289
05:36:08 <ion> jrm2k6: Try adding the type signature :: Parser Foo (where Foo is the type of ActivityElem bar).
05:36:12 <jrm2k6> but i am afraid it might be getting too old
05:36:37 <ion> jrm2k6: Import Text.Parsec.String for the Parser type.
05:36:53 <jrm2k6> ion: isnt it the issue coming from the many1 anyChar?
05:37:44 <jrm2k6> ion, wow adding the signature seems to be the trick
05:37:52 <ion> I don’t see your source code, only the error, so i’m speculating about things you might want to try.
05:37:55 <jrm2k6> ok i need to work more on it to fully understand.
05:40:12 <ion> jrm2k6: {-# LANGUAGE NoMonomorphismRestriction #-} would probably have removed the problem as well, but i prefer adding top-level type signatures anyway.
05:40:32 <jrm2k6> yes, i ve heard that it is better to do it, and force myself to do so.
05:42:25 <ion> jrm2k6: The monomorphism restriction made the compiler want to pick a concrete type for a top-level definition that takes no parameters, but there were no defaulting rules for something with the type of many1 anyChar.
05:43:10 <jrm2k6> ion: I see, thanks!
05:43:18 <jrm2k6> I prefer type signatures anyway
05:48:44 * hackagebot yampa-glfw 0.1.0.0 - Connects GLFW-b (GLFW 3+) with the Yampa FRP library  http://hackage.haskell.org/package/yampa-glfw-0.1.0.0 (_deepfire)
05:48:46 * hackagebot HTTP 4000.2.4 - A library for client-side HTTP  http://hackage.haskell.org/package/HTTP-4000.2.4 (DuncanCoutts)
06:00:48 <south> Hello everyone
06:01:07 <byorgey> hi south
06:01:58 <south> Does anyone have a second to help me out with a cabal issue? (getting the package to upload with docs)
06:06:58 <bergey> south: I've just been debugging a related issue, and trying to figure out how to manually upload docs.  I'm happy to help if I know the answer.
06:07:11 <snyp> whats the diff between guards and 'case of' ?
06:07:40 <matematikaadit> snyp: you can patten match in case of
06:07:53 <south> @bergey That's great! I can't see any difference between my current project's cabal file and an older one that links to docs
06:07:53 <lambdabot> Unknown command, try @list
06:08:05 <bergey> which package?
06:08:08 <snyp> matematikaadit, so case of is more general than guard?
06:08:21 <south> This is the one I'm working on
06:08:21 <south> https://hackage.haskell.org/package/Bang
06:08:50 <bergey> It's not well documented, but you can see the build reports at http://hackage.haskell.org/package/Bang-0.1.0.1/reports/
06:10:28 <matematikaadit> snyp: guard just for an Bool expression
06:11:04 <bergey> In particular, it looks like hmidi failed to install.  I don't know why.
06:11:07 <south> Ah, could it be due to the dependency failure?
06:11:33 <snyp> matematikaadit, oh. ok
06:11:35 <snyp> thanks
06:12:20 <south> Hmm
06:13:29 <bergey> south: the reports for hmidi say that it's build failed.  I don't know why it has Haddocks anyway - maybe the author uploaded them manually?
06:14:57 <south> Ah, I think I know what the issue is then
06:15:25 <south> I need to contact the maintainer I think, I think I'm using a manually downloaded version of the package that had fixes for the new Base
06:15:56 <south> Thanks for your help, bergey!
06:16:14 <bergey> Great.  There's some explanation https://github.com/haskell/hackage-server/issues/145 of how to trigger documentation rebuilds (if a newer version of hmidi doesn't require a version dump in your package), or how to manually upload docs.  I haven't tried either step, though.
06:16:48 <Algebr> Is the RTS in charge of doing garbage collection/memory allocation?
06:17:20 <anon_555> Do we need to import IO
06:17:25 <anon_555> is it essential
06:20:00 <Axman6> anon_555: well, it's part of the Prelude, but you don't necessarilly need to use it directly
06:22:17 <anon_555> Could not find module `Random'
06:22:19 <south> bergey: Great, thanks! hmidi has a pretty generous license so I think I can just stick the new version directly in the package
06:22:21 <anon_555> why is this error
06:22:23 <Axman6> anon_555: but basically, to do any real work, you need to do some level of IO, even if it is just to print out the result of a pure computation
06:22:48 <south> anon_555: You probably want System.Random
06:22:48 <Axman6> anon_555: it looks like you're using an old tutorial.
06:22:54 <Axman6> @hoogle randomR
06:22:55 <lambdabot> System.Random randomR :: (Random a, RandomGen g) => (a, a) -> g -> (a, g)
06:22:55 <lambdabot> System.Random randomRIO :: Random a => (a, a) -> IO a
06:22:56 <lambdabot> System.Random randomRs :: (Random a, RandomGen g) => (a, a) -> g -> [a]
06:23:02 <anon_555> Could not find module `IO'
06:23:17 <Axman6> anon_555: what tutorial are you using
06:23:24 <anon_555> i am using Yet Another haskell tutorial
06:23:32 <Axman6> yeah that's quite old
06:23:33 <bergey> south: I just found build logs, too: http://hackage.haskell.org/package/hmidi-0.2.1.0/reports/1/log
06:23:39 <Axman6> a lot has changed since that was written
06:23:40 <Philonous> Haddock does not support tables, does it?
06:24:03 <anon_555> Which is good
06:24:33 <south> bergey: That's awesome, much more informative
06:25:06 <south> bergey: Thanks for all your help!
06:25:27 <bergey> south: Sure
06:27:03 <anon_555> what should i use instead of import Random
06:27:06 <anon_555> any new version
06:27:11 <anon_555> library in haksell
06:27:19 <Axman6> System.Random, like south told you
06:28:18 <anon_555>  Could not find module `System.Random'
06:28:20 <snyp> How do I pass [Char] to a value constructor that expects a String ?
06:28:31 <anon_555> Axman6 still error
06:28:34 <Axman6> snyp: they're the same thing
06:28:40 <Axman6> @src String
06:28:40 <lambdabot> type String = [Char]
06:29:18 <corgifex> could it be that the random package isn't installed?
06:29:47 <corgifex> pragma-: I don't think I have that code anymore
06:30:51 <snyp> Axman6, oh.. sorry the error was something else. nvm
06:33:09 <Axman6> anon_555: also, please remember we're not paid to be here to answer every question or resolve every evert minor error you have. Please have a go at googling problems before asking here
06:33:23 <pragma-> corgifex: :(
06:33:24 <Axman6> we're happy to help, but you need to put in some effort too
06:34:07 <anon_555> Axman6 don't come in temper brother i know we all are not paid here i googled it and asking here if you don't have time then please ignore me
06:34:18 <anon_555> others may answer brother
06:34:24 <Algebr> lol
06:36:25 <corgifex> server-side ignore > client-side ignore
06:41:02 <Pythonfant> I've got a list of tuples with (key,value) how can I turn that into a list where key is the index of value in the list?
06:41:17 <EvanR> Map.fromList
06:41:43 <corgifex> Pythonfant: hmm, I'd probably start by sorting the list
06:41:44 <EvanR> that wont be a list though
06:41:54 <corgifex> Pythonfant: how are you going to deal with gaps?
06:42:04 <Axman6> Pythonfant: you can already use the lookup function if you want
06:42:09 <Axman6> :t lookup
06:42:10 <lambdabot> Eq a => a -> [(a, b)] -> Maybe b
06:42:58 <Pythonfant> corgifex: not really a problem as this is just to test an algorithm and there shouldn't be a gap. I won't use it in production
06:43:01 <EvanR> its interesting that list lookup is culturally more acceptable than list index (!!) ;)
06:43:11 <EvanR> i guess !! is partial
06:43:34 <corgifex> if there won't be a gap: map snd . sort
06:43:48 <Axman6> Pythonfant: do you want f [(key1, val1),(key2, val2)] to become [(1,val1), (2,val2)]?
06:44:25 <Axman6> if so, you can use f xs = zipWith (\i (_,v) -> (i,v)) [0..] xs
06:44:30 <Pythonfant> no I want [(0,1),(2,4),(1,42)] to become [1,42,4]
06:44:35 <Pythonfant> corgifex: oh right
06:44:36 <Pythonfant> thx
06:45:00 <d3lxa> in TH I need the data constructors, how can I use constrFields or reify? code http://sprunge.us/NhNg any idea, please?
06:45:11 <EvanR> > sort [(0,1),(2,4),(1,42)]
06:45:12 <lambdabot>  [(0,1),(1,42),(2,4)]
06:45:25 <Axman6> oh, what about map snd . sortBy (comparing fst)
06:45:40 <Axman6> > map snd . sortBy (comparing fst) $ [(0,1),(2,4),(1,42)]
06:45:41 <lambdabot>  [1,42,4]
06:45:51 <corgifex> ok, yeah. technically more general
06:45:57 <Pythonfant> Axman6: afaik the default compare sorts first by the start of the tuple
06:46:04 <EvanR> sort already is comparing fst, in this case it works, but its good to know how to sortBy something else
06:46:06 <Pythonfant> s/start/first value/
06:46:14 <Pythonfant> ofc
06:46:28 <Axman6> Pythonfant: sure, but if the second value isn't comparable, then my solution will still work
06:46:43 <EvanR> > sort [(0,1),(2,undefined),(1,42)]
06:46:45 <Axman6> but map snd . sort also works
06:46:45 <lambdabot>  [(0,1),(1,42),(2,*Exception: Prelude.undefined
06:46:56 <EvanR> haha
06:47:22 <EvanR> lazy
06:48:03 <Axman6> that would've failed sooner if there were equal keys in the list
06:48:16 <EvanR> he assured us in so many words there werent
06:48:51 * hackagebot Bang 0.1.0.2 - A Drum Machine DSL for Haskell  http://hackage.haskell.org/package/Bang-0.1.0.2 (5outh)
06:48:52 <EvanR> dependently typed data haa
06:50:09 <south> bergey: So this time, I don't get a build report. http://hackage.haskell.org/package/Bang-0.1.0.2
06:50:23 <south> (weird)
06:56:04 <_deepfire> evidently dated type
06:58:53 * hackagebot Bang 0.1.0.3 - A Drum Machine DSL for Haskell  http://hackage.haskell.org/package/Bang-0.1.0.3 (5outh)
07:00:16 <mp> hello, I have a quastion about yesod and persistent: I'm fetching entities with selectList and I get [Entity Foo]; so each item om list is/has an entityKey with entityVal; how do I extract numeric identifier of entity from Key, so I can put it in a href?
07:01:28 <mp> should I just a) use #{entityKey fooEntity} and b) use #FooId in routes?
07:02:43 <mp> or @{FooDetailsR (entityKey fooEntity)}?
07:04:32 <Axman6> mp: you'd usually have a route specified to take a FooId, so /random/#FooId FooR GET POST, then you'd use @{FooR fooID} to make the type safe route
07:04:39 <Axman6> mp: yeah, the latter
07:06:41 <Axman6> mp: have a look at https://github.com/axman6/BelSES/blob/master/Handler/Users.hs#L26 and https://github.com/axman6/BelSES/blob/master/templates/users.hamlet#L10
07:07:42 <bergey> south: The github thread I linked above explains that the empty-list build report happens when Cabal couldn't find a set of package versions that works.  Maybe it happens in other circumstances as well, I don't know.  It is annoying, for sure.
07:08:33 <south> bergey: It actually showed up later for some reason. The build failed for a different reason this time. Kind of frustrating since it all builds properly locally
07:08:48 <south> I hate having to upload a bunch of new minor version bumps
07:08:54 * hackagebot Bang 0.1.0.4 - A Drum Machine DSL for Haskell  http://hackage.haskell.org/package/Bang-0.1.0.4 (5outh)
07:09:08 <int-index> Is it guaranteed that ['a'..'z'] equals "abcdefghijklmnopqrstuvwxyz" on any machine with any encoding?
07:09:18 <south> As evidenced by hackagebot here
07:13:32 <mp> Axman6: thanks :)
07:15:16 <ion> int-index: Encoding isn’t really relevant here. All Haskell source code is in UTF-8 and 'a' and 'z' unambiguously map to certain Unicode codepoints.
07:16:45 <dottedmag> ion: encoding like underlying machine encoding like EBCDIC, probably.
07:17:15 <dottedmag> int-index: ranges over Char are defined on Unicode codepoints, so yes.
07:17:18 <ion> dottedmag: All Haskell source code is interpreted in UTF-8 independent of locale settings AFAIK.
07:17:21 <Axman6> ion: Char is a UTF-16 codepoint or something isn't?
07:17:27 <Axman6> USC-16?
07:17:32 <Axman6> i dunno, something
07:17:33 <ion> axman6: No, an Unicode codepoint.
07:17:56 <ion> UTF-16 is an encoding you can convert [Char] into if you want to. Both are representations of sequences of Unicode codepoints.
07:18:18 <elben> For a function type a -> b, why do people say that there are |b|^|a| possible values? say |a| = 3, |b| = 4
07:18:27 <Axman6> hmm, but I thought there were utf-8 codepoints that weren't representable as Chars
07:18:46 <corgifex> Axman6: what's a "utf-8 codepoint"?
07:18:50 <dottedmag> Axman6: there aren't "UTF-8 codepoints"
07:18:57 <dottedmag> Axman6: UTF-8 is a byte-serialization of Unicode.
07:19:12 <Axman6> bleh, ok
07:19:33 <dottedmag> Axman6: Chars are integers, denoting a position in alphabet.
07:20:01 <int-index> ion, dottedmag, thank you. C++ wasn't so friendly in this regard
07:20:17 <corgifex> elben: 64
07:20:19 <int-index> it was safer to hardcode the range
07:20:46 <rwbarton> is there any haskell compiler for a system whose native encoding is EBCDIC anyways
07:22:28 <int-index> rwbarton: you can use any encoding of your choice on Linux AFAIK
07:22:50 <geekosaur> I don't think clefos counts, quite :)
07:23:27 <elben> corgifex: there’s something i’m misunderstanding here. if data a = X | Y | Z, data b = S | T | U | V, i only see 12 possible values
07:24:15 <corgifex> elben: what's one such value?
07:24:25 <dottedmag> elben: there are |b|^|a| possible functions.
07:24:43 <int-index> elben: in this case a value is a mapping from a to b (i.e. a function)
07:25:04 <elben> so would X -> S be considered a value?
07:25:13 <Philonous> elben, A function has to select a value from B for _each_ of the Elements in a. So it has 4 possibilities to choose for X, 4 (independent) ones to choose for Y and 4 for Z
07:25:22 <dottedmag> elben: yes, functions are values
07:25:32 <snyp> How is defining functions inside an instance of a typeclass different from defining a function that specfies the typeclass of the arguments? are the two different ?
07:25:37 <Axman6> elben: for each value in a, there are in this case 4 possible outputs in b
07:25:45 <int-index> But you're right, there are 12 possible tuples of type (a, b) in this case. This is why a tuple is called a product type (:
07:25:58 <Philonous> elben, No, X->S is just one "branch" of a function. A function has to give back a value for each input
07:25:58 <int-index> and there is 3+4=7 possible values of Either a b
07:25:58 <Axman6> so the type a -> b has a^b possible values
07:26:08 <int-index> that's why Either is a sum type
07:28:28 <snyp> uh.. i think i get it. you can have different definitions for each instance of a typeclass.
07:28:36 <elben> I’m getting mixed answers here.. So if there are b^a = 4^3 = 64 possible values, show me the 12th value (in some ordered permutation) and the 64th value
07:28:51 <Philonous> snyp, A class member has to (or at least can) be implemented explicitly for each instance of that class. A function with a constraint on one of it's arguments implicitly uses one of those implementations.
07:29:10 <south> bergey: I eventually got it working by manually pushing docs using the script at the end of this: http://fuuzetsu.co.uk/blog/posts/2014-01-06-Fix-your-Hackage-documentation.html
07:29:20 <snyp> Philonous, ah
07:29:36 <rwbarton> elben: here are two values. {X -> S, Y -> S, Z -> S}, {X -> S, Y -> S, Z -> T}
07:30:15 <rwbarton> or in haskell the second one could be written "f X = S; f Y = S; f Z = T"
07:30:16 <int-index> elben, you can't really show a function... in this case a function can be represented by a table, but it's too big for this chat
07:30:54 <snyp> Philonous, typeclasses and constraining types are both two ways of parametric polymorphism right?
07:31:04 <snyp> *constraining argument types
07:31:31 <int-index> rwbarton: ok, not too big. but that's just two examples
07:31:56 <Philonous> elben, I hope this makes it a bit clearer : http://lpaste.net/105295
07:32:20 <elben> rwbarton: ahhh got it, thank you. i misunderstood the meaning of possible functions
07:32:54 <elben> I was thinking “how many different types can I pass into some function f w/ type a -> b” which is a simple product
07:33:20 <elben> Philonous: thanks. muhc clearler
07:33:42 <int-index> elben: you can pass only one type A to a function with type A -> B
07:33:50 <int-index> and get a value of type B
07:34:51 <randomclown> what's the best way of turning [(1,2), (2,0), (1,3)] into [(1, [1,3]), (2, [0])]
07:35:23 <elben> yes you’re right. i meant type a being x | y | z
07:35:26 <randomclown> (an edge list into adjacency list0
07:35:30 <Axman6> :t groupBy
07:35:31 <lambdabot> (a -> a -> Bool) -> [a] -> [[a]]
07:35:44 <randomclown>  [(1, [2,3]), (2, [0])]* typo
07:35:47 <sshine> snyp, typeclasses are also typesafe overloading. the types over which they cover don't need to be parameterised.
07:36:06 <Axman6> > groupBy ((==) `on` fst) . sort $ [(1,2), (2,0), (1,3)]
07:36:07 <lambdabot>  [[(1,2),(1,3)],[(2,0)]]
07:36:19 <randomclown> Axman6: yea but thats O(n^2)
07:36:24 <randomclown> 10k elements will kill it
07:36:37 <randomclown> need it to be under 1 second
07:36:50 <Axman6> how is it O(n^2)?
07:37:06 <Axman6> sort is O(n log n), groupBy is O(n)
07:37:12 <sshine> snyp, (I am not sure if parametric polymorphism covers all use-cases of typeclasses.)
07:37:16 <randomclown> You're sorting a list
07:37:21 <randomclown> not an array
07:37:26 <Axman6> which is O(n loh n)
07:37:27 <snyp> sshine, i see
07:37:40 <randomclown> need an O(n) way
07:37:43 <Axman6> Data.List.sort is definitely O(n log n)
07:37:44 <randomclown> there's no point sorting it anyway
07:37:53 <Axman6> is it already ordered?
07:37:56 <randomclown> no
07:38:03 <randomclown> it doesn't need to be ordered
07:38:06 <corgifex> then there is a point
07:38:14 <Philonous> snyp, Actually, I think they are instances of Ad-Hoc polymorphism
07:38:18 <randomclown> why does an adjacency list need to be ordered?
07:38:19 <ab9rf> you can't get that in O(n) unless the data structure premaintains the data
07:38:28 <jrm2k6> https://gist.github.com/jrm2k6/fa9685638d07c0e67845 How can I debug this?
07:38:49 <corgifex> randomclown: why do you think this algorithm is O(n^2)?
07:39:01 <Axman6> > M.toList . M.fromListWith (++) . map (id ||| return) $ [(1,2), (2,0), (1,3)]
07:39:03 <lambdabot>  Couldn't match type ‘(t0, t1)’
07:39:03 <lambdabot>                with ‘Data.Either.Either (k, [a]) [a]’
07:39:03 <lambdabot>  Expected type: (t0, t1) -> (k, [a])
07:39:03 <lambdabot>    Actual type: Data.Either.Either (k, [a]) [a] -> (k, [a])
07:39:11 <Axman6> > M.toList . M.fromListWith (++) . map (id &&& return) $ [(1,2), (2,0), (1,3)]
07:39:13 <lambdabot>  [((1,2),[(1,2)]),((1,3),[(1,3)]),((2,0),[(2,0)])]
07:39:18 <Axman6> hmmm...
07:39:18 <randomclown> corgifex: O(n log n) is still O(n^2) :)
07:39:27 <dottedmag> what?
07:39:28 <ab9rf> that operation cannot be done in less than O(n lg n) without amortizing the cost back to construction
07:39:28 <Axman6> what?
07:39:35 <corgifex> randomclown: what
07:39:47 <ab9rf> randomclown: O(n lg n) is not O(n^2)
07:40:12 <Axman6> :t (&&&)
07:40:13 <lambdabot> Arrow a => a b c -> a b c' -> a b (c, c')
07:40:14 <randomclown> an algorithm that's O(n lg n) is also O(e^x)
07:40:15 <Axman6> :t (***)
07:40:16 <lambdabot> Arrow a => a b c -> a b' c' -> a (b, b') (c, c')
07:40:20 <randomclown> O(n) notation is for worst case
07:40:27 <Axman6> > M.toList . M.fromListWith (++) . map (id *** return) $ [(1,2), (2,0), (1,3)]
07:40:28 <randomclown> I'm being pedantic here, hence the :)
07:40:29 <lambdabot>  [(1,[3,2]),(2,[0])]
07:40:40 <sshine> snyp, constraining types (of which I know even less) are a way to restrict the computational domain. they allow for parameterised types, but I don't know if they're "a way of"...
07:41:03 <Axman6> randomclown: Data.List.sort is O(n log n) in the worst case
07:41:04 <corgifex> randomclown: just because every algorithm in O(n log n) is also in O(n^2) doesn't mean that O(n log n) = O(n^2)
07:41:05 <randomclown> Axman6: are you implying (++) is not O(n)?
07:41:11 <ab9rf> randomclown: the only way to get it below O(n lg n) is to store the data in something other than a list
07:41:14 <Axman6> no?
07:41:35 <Axman6> but it's O(1) in this case because the first list is always length 1
07:41:38 <ab9rf> with the data in a list, youhave to iterate the list, and then iterate the remainder of the list for each element of the list.
07:41:46 <sshine> Axman6, which means that Data.List.sort is also O(e^n) :)
07:41:56 <randomclown> Axman6: that's still n^2 worst case though
07:41:59 <snyp> sshine, hmm
07:42:14 <Axman6> randomclown: how? you keep making assertions without and proof
07:42:25 <matematikaadit> > foldl ((+).(*10)) 0 [4,5,2,7]
07:42:27 <lambdabot>  4527
07:42:42 <randomclown> Axman6: you are asking why wrapping a O(n) operation in another O(n) operatin is O(n^2)
07:43:04 <Axman6> which O(n) operation
07:43:10 <randomclown> the list has n elements
07:43:13 <Axman6> yes
07:43:40 <randomclown> [(1,2), (1,2), (1,3), (1,4), (1,5)]
07:43:51 <Axman6> fromListWith (++) is O( n log n) because the (++) here is O(1) as the first argument is always length 1
07:44:11 <randomclown> so you'd have done [1] + [2], then [1,2] + [3], [1,2,3] + [4], ...
07:44:17 <Axman6> no
07:44:26 <Axman6> that's not what's happening, look
07:44:40 <Axman6> > M.toList . M.fromListWith (++) . map (id *** return) $ [(1,2), (2,0), (1,3), (1,4),(1,5)]
07:44:42 <lambdabot>  [(1,[5,4,3,2]),(2,[0])]
07:45:17 <Axman6> you could implement it with foldr if you wanted to have some form of stability in the result
07:46:27 <randomclown> Axman6: why is the first argument always 1?
07:46:32 <randomclown> length 1*
07:47:51 <Axman6> because the function passed to fromListWith is used to update the current value as (\new old -> f new old), or in our case, new ++ old. notice each element in the list is being placed at the front
07:48:02 <Axman6> > map (id *** return) $ [(1,2), (2,0), (1,3), (1,4),(1,5)]
07:48:03 <lambdabot>  No instance for (GHC.Show.Show (m0 t0))
07:48:03 <lambdabot>    arising from a use of ‘M82132550689392659567061.show_M82132550689392659567...
07:48:03 <lambdabot>  The type variables ‘m0’, ‘t0’ are ambiguous
07:48:03 <lambdabot>  Note: there are several potential instances:
07:48:03 <lambdabot>    instance [safe] GHC.Show.Show a =>
07:48:17 <Axman6> > map (id *** return) $ [(1,2), (2,0), (1,3), (1,4),(1,5)] :: [(Int,[Int])]
07:48:18 <lambdabot>  [(1,[2]),(2,[0]),(1,[3]),(1,[4]),(1,[5])]
07:48:23 <randomclown> hm ok
07:49:11 <Axman6> and if there's no ordering of the elements in the input, we can't do any better without mutation.
07:49:37 <Axman6> if you need mutation, then you may need the ST monad. you'll also need to know the minimum and maximum keys you'll need
07:49:44 <Axman6> s/need/encounter/
07:49:59 <randomclown> alright cool
07:50:16 <Axman6> (though, you could use the unordered-containers package to make it run faster)
07:50:18 <Axman6> eh?
07:50:38 <randomclown> as long as it's not n^2 should be able to get it in
07:51:26 <corgifex> why do you care about runtime complexity?
07:51:31 <Axman6> do you want the solution using mutation?
07:51:53 <Axman6> it's still a pure function, just uses safe mutation internally
07:52:32 <randomclown> corgifex: because that's what matters
07:52:39 <corgifex> randomclown: matters for what?
07:52:43 <randomclown> everything
07:52:46 <corgifex> how?
07:52:48 <FireFly> No it's not
07:53:04 <Axman6> randomclown: for someone who's asking for help, you're pretty rude to the poeople giving it to you
07:53:43 <randomclown> Didn't realise I was
07:53:59 * hackagebot tamarin-prover 0.8.6.1 - The Tamarin prover for security protocol analysis.  http://hackage.haskell.org/package/tamarin-prover-0.8.6.1 (SimonMeier)
07:53:59 <randomclown> but I find it odd people don't care about time complexity
07:54:07 <corgifex> I find it odd you care
07:54:08 <randomclown> that's the very essence of programming is it not?
07:54:11 <corgifex> hence I asked you why
07:54:12 <Axman6> no
07:54:14 <Axman6> it is not
07:54:19 <corgifex> and you're refusing to give an answer
07:54:23 <randomclown> Well if you go on codeforces
07:54:29 <Axman6> I say this as someone who loves to optimise the crap out of my programs
07:54:31 <randomclown> and the solution is clearly asking for a O(n) solution
07:54:39 <Axman6> then write one
07:54:40 <randomclown> and the test case has input size of 10k
07:54:42 <Axman6> I've told you how
07:54:49 <corgifex> ... so?
07:54:53 <randomclown> and you write a n^2
07:55:03 <randomclown> and you're not going to get it accepted because it'd take more than one second
07:55:04 <Axman6> urgh, no, I didn't
07:55:08 <corgifex> randomclown: bullshit
07:55:11 <randomclown> corgifex: that's my answer to you
07:55:21 <corgifex> runtime complexity has nothing to do with how long it'll take
07:55:27 <randomclown> corgifex: hahahaha
07:55:29 <Axman6> my algorithm is O(n log n) and if you try it on different input sizes you will see that fact
07:55:55 <corgifex> you can have an O(n^2) algorithm that takes 20ms and an O(1) algorithm that takes 2 years
07:56:14 <Axman6> randomclown: no one uses the matric multiplication algorithms with the lowest worst case runtime because their constant factor for reasonable sized matrices is massive
07:56:14 <ab9rf> there's no way to do that in less than O(n lg n) without making unstated assumptions about the data
07:56:35 <Axman6> ab9rf: there is if you have a mutable array
07:56:36 <randomclown> Axman6: right but those are edge cases
07:56:45 <ab9rf> Axman6: hm, ok, yeah, that might work
07:56:46 <Axman6> ab9rf: but randomclown isn't interested in hearing how to do that
07:57:00 <Axman6> randomclown: no, they're really not. they pop up all the time
07:57:03 <randomclown> Axman6: now you're making assumptions
07:57:36 <Axman6> no i'm not, I offered to show you how to do it and you ignored me several times. clearly you don't want to know
07:58:22 <randomclown> If I was really desparate I'd use IOArrays and friends
07:58:30 <Axman6> that'd be dumb
07:58:30 <ab9rf> Axman6: and i now see how to do it with a mutable array in O(n), thanks
07:58:38 <Axman6> it's a pure operation, there's no need for IO
07:58:53 <randomclown> you can use ST too
07:59:06 <Axman6> ab9rf: no worries. it's a pretty trivial extension from the version using Data.Map anyway
07:59:09 <randomclown> the IO array is just a wrapper around ST anyway
07:59:37 <randomclown> and the IO's probably faster since you an read input AND put it in the array at the same time
07:59:52 <randomclown> instead of reading it, saving it and feeding it back into ST
07:59:52 <dottedmag> Is it just me or randomclown is someone else in disguise trying to test the reaction of this channel on rude people?
07:59:59 <ab9rf> hehe
08:00:00 <dottedmag> *just me thinking
08:00:13 <Axman6> yeah, there's been plenty of them today, it's quite odd
08:00:16 <randomclown> I still don't get how I come off as rude
08:00:26 <randomclown> we have a discussion aboud algorithm complexity
08:00:26 <ab9rf> you come across as argumentative
08:00:46 <corgifex> and a bit ignorant
08:00:46 <Axman6> and you make assertions and ignore people who tell you you're wrong, when you clearly are
08:00:49 <Axman6> that's rude
08:00:50 <ab9rf> you're here to win an argument, not here to learn
08:01:07 <Axman6> and you seem to be here just to waste our time too
08:01:17 <randomclown> No, you're wasting your time here
08:01:25 <ab9rf> its our time to waste, not yours
08:01:28 <Axman6> yes, I definitely am
08:01:36 <teknokratsevilla> that's rude, randomclown ^
08:01:42 <Axman6> heh
08:02:04 <randomclown> You chose to come here on your free will to help people
08:02:11 <ab9rf> hell, i mostly lurk here because most of the people here know more than i do, so i just read and slowly absorb
08:02:15 <dottedmag> Ignoring random clowns on the channel never was so, uhm, literal.
08:02:15 * kalusn fetches the popcorn and looks forward to the show
08:02:37 <corgifex> >implying I'm here to help people
08:02:43 <sshine> could you turn down the hostility a little?
08:02:43 <Jeanne-Kamikaze> I wake up from my siesta and see this
08:02:45 <Axman6> randomclown: why did you ask the question to begin with if you didn't want the answer?
08:02:47 <randomclown> >opinions
08:02:48 <teknokratsevilla> good job and great channel
08:03:36 <randomclown> I think it's the channel
08:03:48 <teknokratsevilla> channel is great
08:03:53 <randomclown> I've been here years ago, and it was good
08:04:08 <randomclown> but now it's filled with people who are trying to out-smug each other
08:04:10 <randomclown> reddit was right
08:04:17 <corgifex> ok, now that's just trolling
08:04:26 <Axman6> and now you've come back and had several people tell you're being rude and argumentative, and it's the channel's fault
08:04:38 <teknokratsevilla> just ignore the troll
08:04:42 <randomclown> I felt it was a civil dicussion
08:04:48 <randomclown> but evidently you didn't
08:05:00 <corgifex> randomclown: hmm, are you me?
08:05:02 <Axman6> well perhaps you should reread it
08:05:46 <randomclown> English not my first language
08:05:59 <Jeanne-Kamikaze> are you trying to analyse the complexity of lazy code ?
08:06:03 <Axman6> ha
08:06:07 <Axman6> excellent excuse
08:06:23 --- mode: ChanServ set +o corgifex
08:07:15 <ab9rf> been on freenode for three years and you haven't learned civil behavior yet?
08:07:34 <teknokratsevilla> actually, complexity is always the worst case, so lazyness= strictness, so end of the discussion
08:11:20 <Jeanne-Kamikaze> I beg to disagree
08:12:17 <Axman6> how so?
08:14:01 * hackagebot directed-cubical 0.1.2.0 - Finite directed cubical complexes and associated algorithms  http://hackage.haskell.org/package/directed-cubical-0.1.2.0 (mmisamore)
08:15:47 <jrm2k6> https://gist.github.com/jrm2k6/fa9685638d07c0e67845 I don't know the exact reason why it fails, anybody can give me a hint on how i should check that
08:34:04 * hackagebot keystore 0.1.1.0 - Managing stores of secret things  http://hackage.haskell.org/package/keystore-0.1.1.0 (ChrisDornan)
08:38:19 --- mode: corgifex set -o corgifex
08:41:16 <aspidites> what is the equivalent of ghc --info for cabal if i'm trying to find out which c compiler was used for my project?
08:42:47 <meditans> hi, anyone here is familiar with threepenny-gui?
08:45:48 <bennofs> aspidites: you could search if you find that information inside dist/setup-config. Also, cabal build -v2 should show the commands cabal uses, so you should see the c-compiler command too
08:54:00 <jrm2k6> If I have a IO (StringTemplate ByteString), how can I get the StringTemplate ByteString in it?
08:54:13 <hpc> you don't
08:54:22 <hpc> whatever it is you wanted to do with it has to be brought into IO
08:54:31 <hpc> so for instance, if you have
08:54:49 <hpc> f :: StringTemplate ByteString -> ByteString
08:54:55 <hpc> you would want to do
08:55:28 <hpc> do {template <- getStringTemplate; let out = f template; printLine out} -- or something like that
08:56:39 <jrm2k6> hm ok
08:56:41 <jrm2k6> let me think :)
08:58:40 <bennofs> Or shorter: printLine . f =<< getStringTemplate
09:01:15 <exicer> I've been reading about parsec, and they mention the "looking ahead" when using try a <|> try b etc
09:01:32 <jrm2k6> https://gist.github.com/jrm2k6/1350dbddfbac532bd762 But if I want to pass the IO around, how can I use it to render the template
09:01:43 <exicer> This isn't mentioned when talking about applicatives.. presumably it is necessary when using *> as well ?
09:01:43 <aspidites> o
09:02:00 <exicer> er
09:02:10 <exicer> Wait that might not make sense
09:02:28 <ab9rf> jrm2k6: i think you're looking for liftM here, but i'm not sure
09:02:34 <jrm2k6> hm
09:03:06 <jrm2k6> i have to say i am a bit lost. IO and monads have never been something clear to me
09:03:43 <ab9rf> if yo uhave an IO a and you want an IO b and have a function f :: a -> b, then you want liftM to lift f into the IO monda
09:03:46 <ab9rf> monad
09:04:08 <aspidites> thanks bennofs -- i got distracted
09:04:22 <ab9rf> but i'm not sure that's what you want here.. don't really understand what you're trying to do
09:04:27 <aspidites> for whatever reason it seemed like a good idea to make ghc's python scripts usable with python 3
09:05:14 <ab9rf> aspidites: we all have dreams
09:05:22 <aspidites> ab9rf: i'm almost done actually
09:05:30 <jrm2k6> ab9rf: i get a template in the first function, i want to give it to another function to render it
09:06:29 <jrm2k6> ab9rf: so loadActivityStringTemplate just check that the template file exists and loads its content, now, I want to give it to the render method.
09:06:45 <ab9rf> jrm2k6: what's the type signature of the render method?
09:06:55 <jrm2k6> Stringable a => StringTemplate a -> a
09:07:24 <jrm2k6> and loadActivity returns IO (StringTemplate ByteString)
09:07:35 <jrm2k6> loadActivityStringTemplate i mean
09:08:10 <jrm2k6> so I thought the <- would unbox it from the IO, and I would just be able to use it with render, as it should get the value of type StringTemplate ByteString
09:08:13 <ab9rf> jrm2k6: are you happy with ending up with an IO ByteString
09:08:37 <jrm2k6> I am ending up with a IO StringTemplate
09:08:44 <jrm2k6> or i am missing something?
09:09:03 <ab9rf> StringTemplate is a type constructor, IO StringTemplate is an incomplete type
09:12:15 <ab9rf> well, i'm assuming that, since you used StringTemplate as a type constructor :)
09:12:25 <jrm2k6> hm
09:13:09 <jrm2k6> Ok yes
09:13:14 <jrm2k6> StringTemplate is a type constructor
09:13:38 <jrm2k6> but the function loadActivityStringTemplate returns a IO (StringTemplate ByteString) right?
09:13:56 <aspidites> done
09:14:10 * hackagebot refcount 0.1.2 - Container with element counts  http://hackage.haskell.org/package/refcount-0.1.2 (BenFoppa)
09:14:13 <aspidites> i suppose the smarter thing would have been to compile ghc first to make sure i got even that working
09:14:19 * aspidites shrugs
09:14:27 <ab9rf> jrm2k6: that's the type signature you gave it.  i don't know what the typesig of getStringTemplate is in your code
09:15:14 <jrm2k6> ab9rf: STGroup a -> Maybe (StringTemplate a)
09:15:32 <jrm2k6> i m just using the getStringTemplate from Text.StringTemplate
09:15:57 <sshine> @pl \t -> t^._1 == x || t^._2 == x
09:15:58 <lambdabot> (line 1, column 10):
09:15:58 <lambdabot> unexpected "_"
09:15:58 <lambdabot> expecting white space or simple term
09:16:22 <ab9rf> jrm2k6: if you take what comes from that and use (liftM render) on it, you'll end up with an IO ByteString
09:16:40 <ab9rf> liftM will lift the render operation over the IO monad
09:16:54 <ab9rf> and you'll end up with a IO ByteString.
09:17:04 <jrm2k6> hm ok
09:17:10 <jrm2k6> checking. (still blurry :))
09:21:27 <jrm2k6> ab9rf: you mean something like that: getActivityStringTemplate tpl =  liftM render (setAttribute "name" "MyActivity" tpl)
09:22:50 <ab9rf> jrm2k6: you'd have to lift the setAttribute call as well
09:23:07 <jrm2k6> ab9rf: i m trying just with render, i removed the setAttribute
09:23:10 <jrm2k6> just to see how it works
09:23:29 <ab9rf> e.g. liftM render $ liftM setAttribute "name" "MyActivity"
09:23:43 <ab9rf> there's probably a prettier way to do that
09:23:53 <ab9rf> i need more coffee
09:24:11 * hackagebot map-syntax 0.1 - Syntax sugar for defining maps  http://hackage.haskell.org/package/map-syntax-0.1 (DougBeardsley)
09:24:30 <ab9rf> hm, actually the setattribvute has to come before the render
09:25:21 <jrm2k6> there is not way to use only one liftM for both?
09:25:44 <ab9rf> yes, you can compose both and then lift the composition
09:27:28 <jrm2k6> liftM (render . setAttribute "thing" "mything") tpl
09:27:31 <jrm2k6> something like that
09:28:10 <ab9rf> that's the general ide, not sure if the composition is correct
09:28:40 <jrm2k6> it is
09:28:44 <jrm2k6> it seems to be working.
09:28:56 <jrm2k6> I am always seeing IO stuff as boxes
09:29:10 <ab9rf> don't try to take things out of the box
09:29:20 <jrm2k6> containing something, that you can just look and put back in it, but never take it forever with me
09:29:22 <ab9rf> instead, use liftM to reach into the box
09:29:25 <jrm2k6> childish analogy.
09:29:45 <jrm2k6> liftM = take off the cover of the box.
09:30:25 <ab9rf> this is usually when someone starts talking about burritos
09:30:49 <ab9rf> or that may just be because i'm hungry
09:31:26 <jrm2k6> ahah
09:31:35 <jrm2k6> wait is my liftM analogy correct?
09:31:49 <jrm2k6> I feel like it is more than just lifting the cover of the IO box
09:31:51 <ab9rf> jrm2k6: does it help you understand what's going on?
09:32:19 <jrm2k6> kind of, I have issues having a representation of liftM in the boxes analogy
09:36:22 <benzrf> liftM fmap
09:36:37 <benzrf> jrm2k6: dont use analogies
09:36:42 <benzrf> try out some monads in your code
09:36:47 <benzrf> eventually you will get a feel for what a monad is
09:36:55 <ski> jrm2k6 : if i had to give such an analogy, i'd more think of `liftM'/`fmap'/`(<$>)' as pushing the given function inside the "box", and then applying the function inside it
09:37:08 <jrm2k6> ski: that makes sense
09:37:11 <benzrf> i have a decent feel for it and quite frankly i dont think i have a good way of describing that feel
09:37:14 <benzrf> >tfw
09:37:15 <ski> (btw, this has more to do with functors than with monads)
09:37:16 <jrm2k6> benzrf: I see
09:37:24 <benzrf> jrm2k6: anyway, focus on functors first
09:37:29 <benzrf> if you can grok functors, monads become much easier
09:37:31 <jrm2k6> yes manipulating is better than imagining it but.
09:37:33 <jrm2k6> OK
09:37:40 <jrm2k6> Thanks for the advice guys!
09:37:44 <benzrf> np!
09:37:46 <sveit> is the last optimization here: http://www.haskell.org/haskellwiki/Performance/Data_types still applicable? (enumerations -> enum int types)?
09:37:49 <ab9rf> point.  monads made a lot more sense once i understood applicatives and functors
09:39:13 * hackagebot process-streaming 0.3.0.0 - Streaming interface to system processes.  http://hackage.haskell.org/package/process-streaming-0.3.0.0 (DanielDiazCarrete)
09:41:01 <jrm2k6> can you use a let in a do block?
09:41:07 <ab9rf> yes
09:41:18 <south> Is there a way to specify local package dependencies in cabal files?
09:41:50 <ski> > do let {x = 2} in return x    :: [] Integer
09:41:51 <lambdabot>  [2]
09:41:57 <ski> > do let {x = 2}; return x    :: [] Integer
09:42:00 <lambdabot>  [2]
09:42:03 <aspidites> just submitted a patch to the ghc project, yay
09:42:07 <south> i.e if I have a cabal package in some sub-directory of my main project, can I set it as a dependency?
09:42:16 <aspidites> i'd be more excited if it were actually for ghc itself though :P
09:43:41 <south> Right now it looks like the only way to do this is with sandboxes :(
09:56:23 <jrm2k6> Is this correct?
09:56:35 <jrm2k6> https://gist.github.com/jrm2k6/6cd99d735c4d734bc159
09:56:53 <jrm2k6> it seems like the pattern matching block is not doing anything within my do block, but no error is raised
09:57:16 <sveit> is it faster to do data T = A | B or newtype T = T Int deriving (Eq,Ord,Enum) and have (a:b:_) = [T 1 ..]?
09:59:07 <corgifex> jrm2k6: elements <- return ... better written as let elements = ...
09:59:31 <jrm2k6> corgifex: thanks
09:59:32 <corgifex> jrm2k6: you're defining nameActivity but you're not doing anything with it
09:59:49 <corgifex> compare: let foo = print 42
10:00:03 <corgifex> that defines foo as an IO action but you still need to run it
10:00:13 <jrm2k6> corgifex: yes i ve updated the gist https://gist.github.com/jrm2k6/6cd99d735c4d734bc159
10:00:53 <jrm2k6> the 'in' keyword is problematic
10:01:29 <jrm2k6> oops indentation issue maybe
10:06:09 <benzrf> sveit: does it matter?
10:06:36 <benzrf> i assume any difference would be negligible
10:08:14 <gilligan_> evening
10:08:52 <ReinH> sveit: don't worry about it
10:09:07 <aspidites> i didn't think you were supposed to use in when using lets inside a do
10:09:39 <jrm2k6> aspidites: it seems to be working using in.
10:09:46 <geekosaur> you can use let ... in
10:09:48 <jrm2k6> How would you use it?
10:10:00 <geekosaur> it's often easier to use the special form but it's not necessary
10:10:54 <aspidites> is there some rule that says its better to not use the special form in certain cases?
10:11:06 <aspidites> or rather, is there any benefit to not using it?
10:11:09 <ReinH> I think the in needs to be indented
10:11:51 <ReinH> aspidites: it might be more readable in certain cases, although I haven't found any
10:12:38 <ReinH> There is a difference in scope
10:13:44 <ReinH> let .. in is a a self-contained expression, the special form makes the binding available for the rest of the do block
10:18:51 <ski>   main = do
10:19:01 <ski>     arg:_ <- getArgs
10:19:12 <ski>       defs <- openFile (head args)
10:19:34 <ski>     let elements = parse parseActivityName "Error" defs
10:19:53 <ski>     case elements of
10:21:17 <ski>       Right (ActivityElem nameActivity) -> do
10:21:39 <ski>         getActivityStringTemplate (loadActivityStringTemplate nameActivity)
10:21:50 <ski>       Left  _                           -> putStrLn "Error"
10:22:09 <ski> (deindent the `openFile' command somewhat)
10:22:15 <ski> jophish : i'd try something like that
10:22:23 <ski> err
10:22:27 <ski> jrm2k6 ^
10:22:49 <jrm2k6> woot
10:22:50 * ski ought to learn to double-check nick-expansion before sending
10:23:06 <ski> er, and by `openFile (head args)', i mean `openFile arg'
10:23:10 <jrm2k6> yep
10:23:13 <jrm2k6> i see
10:23:26 <ski> also, you don't need to name `elements' if you don't want to
10:23:34 <ski> you could use `case parse parseActivityName "Error" defs'
10:24:12 <ReinH> ski: uh, maybe use lpaste?
10:26:32 <ski> (i don't think there's much point in using `error' here. perhaps you want to use `throwIO' or `exitFailure' or `exitWith (ExitFailure ...)' instead)
10:26:56 <ski> ReinH : perhaps, except jrm2k6 didn't use it
10:27:11 <jrm2k6> sorry yes, i ve been only using gist
10:27:17 <jrm2k6> will be more careful for next time.
10:28:57 <lyxia> the issue isn't gist/lpaste but 8 lines of code on IRC vs a link.
10:29:48 <aspidites> ok thanks ReinH
10:36:02 <benzrf> does optparse-applicative or anything like it have support for subcommands
10:36:11 <benzrf> all i can find on the topic is https://hackage.haskell.org/package/options-0.1.1/docs/Options.html
10:36:15 <benzrf> but its very TH
10:36:47 <bennofs> benzrf: it does
10:37:50 <bennofs> benzrf: https://github.com/pcapriotti/optparse-applicative#commands
10:38:00 <benzrf> ah, thanks :-)
10:40:15 <tikitu> Hi folks, noob here (getting into Haskell after quite some Python experience).
10:40:35 <tikitu> I’m wondering if there is some consensus about import style:
10:41:12 <tikitu> looking at code online I often wonder “where did that come from?” because of no “import Some.Model (x, y, z)” style.
10:42:08 <ski> one can use `import qualified Some.Model as SM', and then use `SM.x'
10:42:34 * ski sometimes does it like `import Some.Model (x, y, z)' (sometimes with type signatures in comments), though
10:42:39 <tikitu> Yup. What I wonder is, I’m tending to qualify or explicit-import everything,
10:42:52 <ski> sounds fine to me
10:42:54 <tikitu> is that something I’m gonna have to unlearn as I get more comfortable?
10:43:00 <agibiansky> It depends on the package I think - some packages are meant to be imported qualified (especially ones that redefine base symbols)
10:43:00 <Fuuzetsu> what's an idiomatic way to map over a sequence with Data.Vector? Say I have ‘map foo [1 .. 10]’ but I want a vector not a list, how do I generate the [1 .. 10] vector?
10:43:20 <agibiansky> For example, vector is usually imported qualified V I think, and so on
10:43:27 <Fuuzetsu> oh
10:43:30 <Fuuzetsu> :t V.generate
10:43:31 <agibiansky> But I think it's fairly common to just use unqualified imports for many packages
10:43:31 <lambdabot> Not in scope: ‘V.generate’
10:43:36 <Fuuzetsu> :t Data.Vector.Generate
10:43:37 <lambdabot>     Not in scope: data constructor ‘Data.Vector.Generate’
10:43:38 <Fuuzetsu> :t Data.Vector.generate
10:43:39 <lambdabot> Int -> (Int -> a) -> Data.Vector.Vector a
10:43:57 * ski would have called that function `tabulate' ..
10:43:59 <Fuuzetsu> :t Data.Vector.generate 10 (\i -> show i)
10:44:00 <lambdabot> Data.Vector.Vector String
10:44:03 <Fuuzetsu> > Data.Vector.generate 10 (\i -> show i)
10:44:05 <tikitu> hoogle would be the go-to to find stuff I don’t recognise then?
10:44:05 <lambdabot>  Not in scope: ‘Data.Vector.generate’
10:44:20 <sshine> :t Data.Vector.map
10:44:21 <lambdabot> (a -> b) -> Data.Vector.Vector a -> Data.Vector.Vector b
10:44:35 <agibiansky> If you can't find it, Hoogle, yeah, but I definitely do prefer to import everything explicitly
10:44:52 <agibiansky> Long argument lists are annoying, but preferable to  not knowing if something is defined by the user code or by library code
10:45:13 <agibiansky> The exceptions IMHO are things that are sorta "prelude-y"
10:45:16 <Fuuzetsu> sshine: the problem is how to generate the vector to map over but it seems generate will do exactly what I need
10:45:27 <agibiansky> Things maybe like lens and whatnot, where you just want a kitchensink
10:45:30 <jrm2k6> is there a way to write a ByteString to a file http://lpaste.net/105298
10:45:33 <tikitu> Any tools to make that easier? (My emacs haskell-mode knows the type signature for lots of stuff that’s not explicitly imported yet, so it should be possible.)
10:45:35 <sshine> agibiansky, so do I. the need becomes apparent for me when I reach 20+ imports and I can't remember what comes from what.
10:46:04 <meoblast001> yay
10:46:07 <meoblast001> i'm already in #haskell :D
10:46:27 <eyebloom> I’ve been trying for a bit to understand the foreign function interface in terms of creating a callback for the haskell SDL2 bindings. I created this toy code to illustrate the basic problem I’m having trying to send a callback to the API…
10:46:42 <eyebloom> http://lpaste.net/105299
10:47:59 <merijn> eyebloom: What's the actual question about that code? :)
10:48:25 <eyebloom> I get an error that mkTimerCallBack is not in scope.
10:48:52 <eyebloom> I’m trying to understand how the FFI creates a wrapper that I can use.
10:49:01 <merijn> eyebloom: oh
10:49:04 <merijn> eyebloom: I see the error
10:49:30 <merijn> You're trying to export a haskell function that is not defined, the correct way to define a "wrapper creation" function is:
10:49:37 <byteoverfl0w> ./list
10:49:53 <merijn> eyebloom: "type OutFun = Ptr () -> CInt -> Ptr IntPtr -> IO (); foreign import ccall "wrapper" mkOutFun :: OutFun -> IO (FunPtr OutFun)"
10:50:21 <jrm2k6> How do you transform a Data.ByteString.Lazy.Internal.ByteString to a [Char] ?
10:50:24 <merijn> eyebloom: So you *import* the C function called "wrapper" (this is part of GHC's FFI), and name it "mkOutFun"
10:50:34 <tikitu> agibiansky: thanks, good to get me started
10:50:36 <merijn> jrm2k6: Decode to Text, convert Text to String
10:50:48 <jrm2k6> merijn: checking
10:50:50 <jrm2k6> thanks
10:50:50 <avaritia> could someone explain to me why haskell doesnt like the type of (return . mapMaybe id) =<< (sequence . Prelude.map runMaybeT) ? The types on the both sides of =<< seem to match and yet i'm getting an error
10:50:55 <merijn> jrm2k6: See Data.Text.Encoding
10:51:01 <jrm2k6> cool.
10:51:23 <corgifex> >>= return . better written as liftM
10:51:35 <merijn> jrm2k6: You might need the lazy version of that to work with lazy ByteString, but that should be in the same package
10:51:39 <corgifex> also, the RHS is a function
10:51:51 <corgifex> why are you trying to =<< a function
10:51:55 <jrm2k6> merijn: thank you
10:52:24 <ski> eyebloom : `generate_user_event' is missing arguments. and calling `whileEvents' recursively inside a `withForeignPtr' looks a bit suspicious (if nothing else, the following `return ()' then seems a bit worthless)
10:52:28 <merijn> corgifex: Could be "(->) r" monad
10:53:39 <avaritia> corgifex: damn i hoped =<< will work as . , thanks
10:55:40 <eyebloom> ski: I see, this is just a toy version.
10:56:03 <ski> @type liftM (mapMaybe id) . sequence . Prelude.map Control.Monad.Trans.Maybe.runMaybeT
10:56:04 <lambdabot> Monad m => [Control.Monad.Trans.Maybe.MaybeT m b] -> m [b]
10:56:06 <ski> @type liftM catMaybes . mapM Control.Monad.Trans.Maybe.runMaybeT
10:56:07 <lambdabot> Monad m => [Control.Monad.Trans.Maybe.MaybeT m a] -> m [a]
10:56:18 <ski> avaritia : ^ ?
10:56:55 <ski> avaritia : `(<=<)' is a bit more like `(.)', i suppose
10:56:58 <ski> @type (.)
10:57:00 <lambdabot> (b -> c) -> (a -> b) -> a -> c
10:57:01 <ski> @type (<=<)
10:57:03 <lambdabot> Monad m => (b -> m c) -> (a -> m b) -> a -> m c
10:57:46 <ski> @type return . mapMaybe id <=< sequence . Prelude.map Control.Monad.Trans.Maybe.runMaybeT
10:57:47 <lambdabot> Monad m => [Control.Monad.Trans.Maybe.MaybeT m b] -> m [b]
10:58:38 <puchdapixel> does anyone know how to get the haskell documentation into a linux application called devhelp? or other nice way to have searchable offline documentation?
10:58:44 <ski> but it's better to use `liftM`/`fmap'/`(<$>)' here
11:02:49 <Rufflewind> is there a reason why cabal is installing stuff in cabal/i386-blah-blah instead of just cabal? (is this a change introduced recently?)
11:04:13 <geekosaur> afaik it's always supposed to do that and then if it's an executable drop a symlink in .cabal/bin?
11:04:29 <geekosaur> it's been doing that forever
11:04:54 <Rufflewind> the root cabal directory is littered with packages on my system :(
11:05:35 <geekosaur> that sounds wrong
11:06:10 <geekosaur> although you could make it do that with a .cabal/config, maybe yours is from an ancient version before things were split by arch etc.?
11:07:14 <jrm2k6> http://lpaste.net/105300 I got this warning, and the file is not created unfortunately. Any idea how i can remove this warning?
11:08:08 <corgifex> jrm2k6: it literally tells you how
11:08:31 <jrm2k6> but if i want to remove it by changing the code, not using a flag
11:08:56 <corgifex> yes
11:09:00 <corgifex> IT LITERALLY TELLS YOU
11:09:27 <corgifex> also, you're solving the wrong problem because the warning indicates a real problem in your code
11:09:29 <jrm2k6> ok
11:09:37 <corgifex> so you shouldn't be trying to remove the warning
11:09:42 <corgifex> you should be trying to fix the code
11:11:16 <jrm2k6> oh i think i see, my main needs to return IO(), but the do statement in my fucntion will terminate after the liftM
11:11:57 <pavonia> :t void
11:11:59 <lambdabot> Functor f => f a -> f ()
11:15:46 <aspidites> has anyone been successful installing and updating haskell platform in wine?
11:15:49 <RedNifre> Good evening everyone.
11:16:42 <eyebloom> merijn: Here’s a slightly modified version that shows I don’t quite unders why new userEvent on line 38 doesn’t seem to have type IO (Ptr SDL.Event)… http://lpaste.net/105299
11:17:13 <aspidites> i'm having issues setting path to recognize local files BEFORE system ones, so the old version of cabal is being seen before the new one
11:17:35 <taruti> Any nice libraries for having mutable events like "do this IO() in 15 seconds" with an extra "clear all pending events"?
11:18:18 <aspidites> wait..there appears to be a sys.reg file (not sure how to access it from regedit). lets see if i can edit manuall
11:18:21 <aspidites> manually*
11:18:45 <carter> o/
11:19:07 <RedNifre> Could you be so kind and peer review my brain? I mostly know OOP languages and some low level languages and a bit of aspect oriented programming and wanted to know about functional programming. I pondered both Scala and Haskell, Scala seems more practical while Haskell seems more pure. So my plan is to learn Haskell and if I fail to use it productively I might learn Scala and use it Haskell style or something. Does this make sense?
11:19:24 * hackagebot template-haskell 2.8.0.0 -   http://hackage.haskell.org/package/template-haskell-2.8.0.0 (HerbertValerioRiedel)
11:19:37 <aspidites> found it
11:19:44 <eizo> aspidites: why do you need haskell on wine?
11:20:03 <aspidites> eizo: because i want to compile for windows from linux
11:20:18 <aspidites> and the instructions for building a cross-compiler are...yeah
11:20:29 <aspidites> plus they even recommend using wine
11:20:41 <eizo> ok
11:20:48 <jrm2k6> I have an issue with that but I dont know how to fix it. I know the second liftM is bad but how should i do it?
11:21:32 <corgifex> =<<
11:21:58 <jrm2k6> corgifex: ? is it for me?
11:22:05 <corgifex> yes
11:22:17 <RedNifre> Just started Haskell a moment ago. For practicing, I want to write a function that removes an element from a list. Why can't I declare it like this? removeFromList x (x:xs) = xs
11:22:40 <corgifex> because haskell doesn't let you use the same name twice in a single pattern
11:22:45 <RedNifre> As in "If you want to remove an element from a list where that element is at the start, the result is the tail of the list"
11:23:06 <corgifex> you can write foo x (y : ys) | x == y = ...
11:23:24 <RedNifre> hmm... okay.
11:23:31 <geekosaur> RedNifre, patterns match structure, not values. `x (x:xs)` does not mean that the same value is in both places
11:23:35 <pavonia> jrm2k6: What's the type of byteStringToString?
11:23:35 <aspidites> :t removeFromList (x:xs) = xs
11:23:36 <lambdabot> parse error on input ‘=’
11:23:40 <geekosaur> it tries to bind `x` to both patterns
11:23:42 <aspidites> :t let removeFromList (x:xs) = xs
11:23:43 <lambdabot> <no location info>:
11:23:43 <lambdabot>     not an expression: ‘let removeFromList (x:xs) = xs’
11:24:01 <benzrf> :t let removeFromList (x:xs) = xs in removeFromList
11:24:02 <lambdabot> [t] -> [t]
11:24:10 <RedNifre> That's what I intented, but I guess I can't hide if else in the declaration...
11:24:18 <geekosaur> not like that, no
11:24:25 * hackagebot request-monad 0.1.0.0 - A transformer for generic requests  http://hackage.haskell.org/package/request-monad-0.1.0.0 (nahiluhmot)
11:24:28 <jrm2k6> byteStringToString
11:24:29 <jrm2k6>   :: Data.ByteString.Lazy.Internal.ByteString -> String
11:24:30 <RedNifre> Also, what's with the brackets around (x:xs)? What are they for?
11:24:30 <jrm2k6> pavonia:
11:24:32 <geekosaur> xconstructors will work that way because they're structure. arbitrary values like that, no
11:24:33 <jrm2k6> oops
11:24:39 <corgifex> RedNifre: precedence
11:24:57 <jrm2k6> pavonia: Data.ByteString.Lazy.Internal.ByteString -> String
11:25:02 <corgifex> RedNifre: otherwise that line parses as (removeFromList x x) : xs = ...
11:25:24 <geekosaur> precedence in patterns is the same as it is in expressions, even though some expression-like things dont work in patterns
11:25:36 <geekosaur> because it's dumb to have to learn two different sets of precedence rules
11:25:42 <pavonia> jrm2k6: So you can simply use writeFile (nameActivity++".java") (byteStringToString content)
11:25:57 <corgifex> foo x (((== x) -> True) : xs) = xs
11:26:03 <jrm2k6> but i need to liftM too
11:26:07 <jrm2k6> cause content is an IO
11:26:29 <pavonia> jrm2k6: Oh, I see
11:26:42 <jrm2k6> i try to understand what does (=<<) do
11:26:46 <jrm2k6> :t =<<
11:26:47 <lambdabot> parse error on input ‘=<<’
11:26:50 <jrm2k6> oops
11:26:53 <ab9rf> :t (=<<)
11:26:55 <lambdabot> Monad m => (a -> m b) -> m a -> m b
11:27:10 <ab9rf> :t liftM
11:27:11 <lambdabot> Monad m => (a1 -> r) -> m a1 -> m r
11:27:16 <pavonia> jrm2k6: But you can also use do-notation: con <- contents; writeFile ...
11:27:17 <ab9rf> the two are very similar
11:27:29 <pavonia> jrm2k6: where writeFile uses con
11:27:39 <jrm2k6> pavonia: true.
11:27:41 <RedNifre> so... (removeFromList x y) : xs = ... means... that a list that starts with the result of that method equals... wait... does this mean that whenever a list changes during run time, it checks whether it matches that declaration and then overrides the list with what's right of the = ?
11:28:22 <jrm2k6> ab9rf: very similar, but i m trying to find an example
11:28:30 <corgifex> RedNifre: no, it's an error
11:28:35 <ab9rf> RedNifre: lists don't change at runtime in haskell.
11:28:44 <monochrom> "(removeFromList x y) : xs = ..." makes no sense, of course.
11:28:59 <corgifex> RedNifre: it would mean the ... part is a list and the tail will be bound to xs, but (removeFromList x y) is not a valid pattern for the head
11:29:17 <corgifex> so at that point the parser should complain
11:29:33 <monochrom> "removeFromList x (y : xs) = ..." is required to keep the syntax consistent
11:29:56 <monochrom> that is, grammar for the LHS is as similar to grammar for the RHS as possible
11:30:17 <corgifex> > let foo (x : xs) = (x, xs) in foo "hello"
11:30:19 <RedNifre> Hah, I imagined it like this: bla x = "c"   ...   bla x:xs = "Deleted!" ...  "crazy!" == "Deleted!" equals true
11:30:19 <lambdabot>  ('h',"ello")
11:30:20 <phaskell> !;!!!!!!||||***================*****||||!!!|||**
11:30:20 <phaskell> !!||||||||!!!!!!!;!!!!!!!!!!!!!!!!!!!|||||****==
11:30:20 <phaskell> |||||****||||||||||||||||||||||||||||||*****====
11:30:20 <phaskell> ||||************||||***********|||********======
11:30:20 <phaskell> ==========***************************=====@@@@@@
11:30:21 <phaskell> ===@@@@$$$$$@@@@@@@@@@@@@@@@@@@@@@$$$$$$$@@@@@@@
11:30:21 <phaskell> ||***===============@@@@@@@@@@==============@@@@
11:30:22 <phaskell> ||***=============@@$$$=**@@@$!!==========@@@@@@
11:30:22 <phaskell> |||**=============@$$@@*;!:,:!=!!========@@@@@@@
11:30:23 <phaskell> ||****=====@@@@@@@@=@$|*!,:;=$|;|**====@@@@@@@@@
11:30:23 <phaskell> =====@**@$$@@@@@@@@@$@*!:,:|@=*=@==@$$$$$$$$$$$$
11:30:24 <phaskell> ****=====@@@@@@@@@@$$$$=!!!|**==@@==@@@@@@@@@@@@
11:30:24 <phaskell> ======@@@@@@@@@@@@@@$$$***|||!*=@==@@@$$$$$$$$$$
11:30:25 <phaskell> ===|*=*@@@@@@@@@@@$$$$@$$$$$==@@@@$$$$$$$$$$$$$$
11:30:28 --- mode: ChanServ set +o corgifex
11:30:35 --- kick: phaskell was kicked by corgifex (phaskell)
11:30:41 <ab9rf> d'oh
11:31:05 <RedNifre> ...but I agree that this would be very insane, so an error is fine ;)
11:32:26 <corgifex> RedNifre: if you're going that way, bla x : xs = "Deleted!" would bind "eleted!" to xs and 'D' to bla x
11:33:07 <monochrom> you can certainly argue: on the LHS, since "f x : xs = ..." can only mean one sensible thing, it could be allowed. yes. so now I have to learn two grammars. do you want it?
11:33:16 <corgifex> and if it really ran bla as a function, it would expand to "c"
11:33:24 <corgifex> and trying to match 'D' with "c" is a type error
11:33:39 <corgifex> (Char vs String)
11:33:43 <RedNifre> Oh, right. Should be bla x = 'c' instead
11:34:26 * hackagebot template-haskell 2.7.0.0 -   http://hackage.haskell.org/package/template-haskell-2.7.0.0 (HerbertValerioRiedel)
11:34:28 * hackagebot template-haskell 2.6.0.0 -   http://hackage.haskell.org/package/template-haskell-2.6.0.0 (HerbertValerioRiedel)
11:34:57 <corgifex> but it doesn't do that because lowercase identifiers in patterns are variables bound by the pattern, not things defined elsewhere whose value is used
11:35:25 * ski annotated <http://lpaste.net/105300> with "some successive versions"
11:35:25 * hvr .oO(nobody seems to care about hvr's TH uploads...)
11:35:28 <ski> jrm2k6 ^
11:35:31 <corgifex> e.g. you can say x = 42; foo x = ... but the x in foo binds a new variable, it doesn't match with 42
11:35:53 <jrm2k6> Thanks ski
11:35:57 <jrm2k6> checking right now
11:36:44 <RedNifre> Okay, guess I'll read "Learn you a Haskell" a bit more before asking more questions. Thanks for the explanation, it's a lot clearer now.
11:36:56 <ski> RedNifre : asking questions here is fine
11:37:09 <corgifex> but so is reading! :-)
11:37:24 <corgifex> I guess you still need to read, even if you ask here
11:37:29 --- mode: corgifex set -o corgifex
11:37:34 <RedNifre> So if "xs" is a convention for "some x", should I declare bla x (y:xs) or bla x (y:ys) and why?
11:37:42 <jrm2k6> ski: ok so in my case i tried to see too complicated
11:37:54 <jrm2k6> just the regular do <- notation would have been enough
11:37:55 <ski> no, "xs" is plural of "x" : "zero or more `x's"
11:37:57 <corgifex> xs is the plural of x
11:38:14 <RedNifre> so bla x (y:ys), huh?
11:38:20 <corgifex> item : items
11:38:22 <ski> RedNifre : `bla x (y:ys)' might be nicer, but it's up to you
11:38:43 <RedNifre> I meant "many x" as plural of x :)
11:38:44 <RedNifre> ys it is.
11:39:07 <corgifex> some or many?
11:39:21 <ski> @type some
11:39:22 <ski> @type many
11:39:22 <lambdabot> Alternative f => f a -> f [a]
11:39:23 <lambdabot> Alternative f => f a -> f [a]
11:39:26 * hackagebot template-haskell 2.5.0.0 -   http://hackage.haskell.org/package/template-haskell-2.5.0.0 (HerbertValerioRiedel)
11:39:29 <corgifex> and now I realize "some" is more than "many" in parsec
11:41:04 <jrm2k6> How do you write the type siognature for a function using Data.ByteString.Lazy.Internal.ByteString
11:41:12 <jrm2k6> it says it is not defined
11:41:33 <jrm2k6> not in scope i mean
11:42:27 <corgifex> I'd start with import qualified Data.ByteString.Lazy as BS
11:42:33 <corgifex> then ... :: BS.ByteString
11:43:00 <jrm2k6> thanks corgifex
11:43:40 <corgifex> wait, does that exist?
11:43:53 <corgifex> ah, it does
11:43:56 <exicer> What is the easiest way to convert Int -> Text  ?
11:44:44 <RedNifre> So is this chat only for Haskell, or also for functional programming in general?
11:44:46 <jrm2k6> qualified is just used to be able to name it as you want right?
11:44:53 <corgifex> I've never used Text but I suspect something like fromString . show would work
11:45:23 <pqmodn> jrm2k6: http://www.haskell.org/haskellwiki/Import
11:45:29 <corgifex> jrm2k6: no, qualified means you need to use qualified names to access the identifiers in the module
11:46:15 <corgifex> jrm2k6: import Data.ByteString.Lazy as BS would still work but in addition to BS.ByteString (a qualified name (containing a module name)) you could also use ByteString (a plain (unqualified) name)
11:46:30 <corgifex> the trouble with unqualified imports is that you can get name clashes
11:46:33 <RedNifre> The "No moving parts" aspect of Haskell seems nice, but how would you implement a game like chess, where the fun is that you have to see how your opponent mutates the state of the game and where the move sequence will lead to?
11:47:07 <corgifex> e.g. Data.ByteString.Lazy.length would conflict with Prelude.length
11:47:11 <jrm2k6> corgifex: ok, if there is a Bytestring in some othermodule, that would be ambiguous
11:47:15 <jrm2k6> Yes
11:47:22 <jrm2k6> I have seen the case with head for example
11:47:27 <RedNifre> I mean, if I imagine it functionally I see it as "Input the board, including which rook has moved, and you turn. The output will be the new board, which your opponend can use to run this program again with his own move"
11:47:27 <corgifex> right
11:47:48 <jrm2k6> but what I did was just importing a specific function instead of the whole module
11:47:52 <RedNifre> But that would be cheating, since the sequential mutable state stuff would happen in the player's head, sort of. Right?
11:47:57 <jrm2k6> here the issue is that i wanna use the whole type for y signature
11:48:08 <asante> RedNifre: i guess you would use the state monad or something for that
11:48:09 <jrm2k6> thats why i need a qualified import i think
11:48:10 <corgifex> oh, right: import Data.ByteString.Lazy (ByteString) should also work
11:48:45 <mr-> RedNifre: there's no cheating.. it's just passing the state along (The state monad would do the same)
11:49:00 <jrm2k6> corgifex: it does.
11:49:17 <ski> RedNifre : FP is general is also ok, afaiac
11:49:24 <jrm2k6> woohoo, i am done with the first tiny part of my parser/code generation using StringTemplate
11:49:28 * hackagebot template-haskell 2.4.0.1 -   http://hackage.haskell.org/package/template-haskell-2.4.0.1 (HerbertValerioRiedel)
11:49:29 <corgifex> "State monad" is a fancy name for a function s -> (a, s)
11:49:33 <jrm2k6> Not so easy!
11:49:47 <corgifex> i.e. a function that takes a state and returns a result along with a (modified) state
11:50:00 <RedNifre> Hm....
11:50:20 <corgifex> (and what I just said is a category error because "monad" isn't the function itself but the class of types s -> (_, s))
11:50:56 <RedNifre> But the idea of "No side effects" is kinda removed, if that state changes internally at run time, invisible to the players... I guess the "no side effects" is only needed when programming, not during runtime, huh?
11:51:25 <corgifex> eh?
11:51:25 <RedNifre> As in "The binary has state, but the source code doesn't"?
11:51:32 <ski> RedNifre : yes, whether the "side" is present or not in "side effects" is relative to the language in which you're working
11:53:16 <ski> RedNifre : the "side" part lies in how you can express yourself in the language, and *especially* in how you can *reason* about programs in the language
11:53:23 <RedNifre> I meant that in a chess program in Haskell, the players wouldn't see whether they can do castleing since that flag is hidden in a monad, but in the source code, you'd see that whether or not a particular move is allowed always checks the castleing flag that is passed as a parameter. Therefore, the runtime has hidden state, but the source code hasn't. Right?
11:53:55 <corgifex> monads aren't magic
11:53:59 <ski> what does "the runtime has hidden state" mean ?
11:54:28 * hackagebot template-haskell 2.4.0.0 -   http://hackage.haskell.org/package/template-haskell-2.4.0.0 (HerbertValerioRiedel)
11:54:31 * hackagebot template-haskell 2.3.0.1 -   http://hackage.haskell.org/package/template-haskell-2.3.0.1 (HerbertValerioRiedel)
11:54:32 * hackagebot template-haskell 2.3.0.0 -   http://hackage.haskell.org/package/template-haskell-2.3.0.0 (HerbertValerioRiedel)
11:54:33 <RedNifre> I mean that the chess player's don't have to input whether or not they are allowed to do castleing. That's a hidden state.
11:54:35 * hackagebot template-haskell 2.2.0.0 -   http://hackage.haskell.org/package/template-haskell-2.2.0.0 (HerbertValerioRiedel)
11:54:45 <corgifex> chess in particular is super pure: no hidden state, no randomness
11:55:00 <corgifex> oh, different meaning of "hidden state"
11:55:11 <barrucadu> They don't have to input whether they can castle or not, because that can be computed from the layout of the board - which they do input (albeit slowly)
11:55:31 <corgifex> yeah, the castling flag can be represented explicitly
11:55:32 <RedNifre> Nope.
11:55:42 <sshine> RedNifre, since the source code for your chess monad is part of the source code and uses a state monad, it "has state".
11:55:44 <RedNifre> You are not allowed to do castleing if you moved your rook away and back.
11:56:01 <corgifex> yes, and that can be put into the data structure you're using for the game
11:56:30 <corgifex> you're already creating new game states based on how the players move their pieces
11:56:42 <RedNifre> Yes, though not in the user input. Therefor it has no side effects from a programmer's point of view, but it has side effects from the user's point of view, which is totally fine.
11:56:43 <corgifex> tracking whether castling is allowed isn't harder
11:57:10 <sshine> RedNifre, using states and monads to describe a problem computationally is not the same as run-time side-effects like I/O.
11:57:13 <corgifex> are you talking about I/O in general?
11:57:48 <corgifex> because at runtime a player may input a move, and then your program has to react to it, but Haskell itself has no notion of side effects / input
11:57:57 <sshine> RedNifre, if a program receives input from the user, it has side-effects, not just "from the user's point of view".
11:58:30 <ski> sshine : i would say it has effects, not side-effects
11:58:34 <sshine> RedNifre, even then, you may describe the problem of playing chess using a state monad that is pure (i.e. does not touch IO itself).
11:58:39 <sshine> ski, ok.
11:59:33 <ski> (because all of Haskell is pure (not counting unwarranted uses of `unsafePerformIO' or the like), including the `IO'-parts)
12:03:24 <k0ral> Is there anything close to an Alternative instance of the Either monad ? Using the <|> combinator on Either values would be most convenient
12:05:27 <ski> > Left "a" <|> Right 1 :: Either String Integer
12:05:29 <lambdabot>  Right 1
12:06:57 <Fuuzetsu> isn't there an indexable type class somewhere?
12:07:01 <k0ral> > Control.Applicative.empty :: Either String String
12:07:03 <lambdabot>  Left ""
12:07:06 <Fuuzetsu> hm lens probably has something
12:07:09 <k0ral> > Control.Applicative.empty :: Either Integer String
12:07:10 <lambdabot>  No instance for (Control.Monad.Trans.Error.Error
12:07:11 <lambdabot>                     GHC.Integer.Type.Integer)
12:07:11 <lambdabot>    arising from a use of ‘Control.Applicative.empty’
12:07:17 <k0ral> hmm
12:07:26 <RedNifre> So I wrote a "smallest" function, which works. But why can't I declare it as smallest :: [Ord] -> Ord ?
12:07:34 <ReinH> Fuuzetsu: IndexedTraversable, etc?
12:07:50 <benzrf> ReinH: Ord isnt a type
12:08:02 <ReinH> benzrf: er. :p
12:08:07 <ReinH> benzrf: I am aware ;)
12:08:12 <ReinH> RedNifre: Ord isn't a type.
12:08:13 <Fuuzetsu> Indexable looks promising
12:08:23 <barrucadu> RedNifre: "Ord" isn't a type, it's a typeclass, which is a way of defining a type which has an ordering
12:08:35 <RedNifre> Ah, I think I get it.
12:08:36 <benzrf> ReinH: wrong person >.<
12:08:39 <benzrf> typed R^I
12:08:40 <ReinH> benzrf: :)
12:08:48 <benzrf> * re^I
12:09:14 <barrucadu> ReinH: It's always important to be reminded of these things, you never know when you'll forget :p
12:09:24 <ReinH> barrucadu: :)
12:09:38 <RedNifre> The problem is that input and output might be two different types of Ord, right? So I have to specify that I mean the same Ord, i.e. (Ord a) => [a] -> a
12:10:03 <benzrf> RedNifre: no, the problem is the Ord is not a type
12:10:06 <barrucadu> The problem is that Ord isn't a type, so you can't use it as a type variable
12:11:03 <RedNifre> ...but "Ord a" means "something that inherits from the abstract type Ord" (in Java speak)?
12:11:24 <benzrf> RedNifre:
12:11:25 <benzrf> no
12:11:36 <benzrf> more like something that implements the interface Ord
12:11:52 <benzrf> but haskell's "interfaces" cannot be used in the same context as its types
12:11:54 <benzrf> unlike java
12:11:58 <rwbarton> also you left out part of the sentence
12:12:03 <rwbarton> "Ord a" means "a is something that ..."
12:12:04 <RedNifre> I just started Haskell moments ago, so I kinda think of it in terms of Java. I.e [Ord] -> Ord is wrong because it's like <? extends Ord> ... <? extends Ord> where you actually want <T extends Ord> ... <T>?
12:12:16 <benzrf> RedNifre: no
12:12:18 <benzrf> 03:09 < benzrf> but haskell's "interfaces" cannot be used in the same context as its types
12:12:34 <RedNifre> Hm. I guess I have to think for a moment.
12:12:41 <benzrf> RedNifre: in java SomeInterface and SomeClass are interchangeable
12:12:43 <k0ral> actually, on my ghci, Left "a" <|> Right 1 doesn't work
12:12:45 <benzrf> RedNifre: in haskell they are not
12:12:49 <k0ral> ski: ^
12:13:03 <rwbarton> in other words you should read your type as "for any type a, if a is something that can be compared for order, then I give you a function [a] -> a"
12:13:07 <benzrf> RedNifre: in haskell, "interfaces" may only be used in constraints
12:13:20 <benzrf> which go on the LHS of a =>
12:13:50 <k0ral> ski: Could not deduce (Alternative (Either [Char]))
12:16:28 <k0ral> it seems to me that one could easily define an instance (Monoid a) => Alternative (Either a)
12:16:35 <benzrf> p:
12:16:50 <benzrf> k0ral: why the monoid?
12:17:09 <benzrf> k0ral: empty must have type 'f a'
12:17:19 <benzrf> wait hold o
12:17:20 <benzrf> n
12:17:28 <benzrf> > empty
12:17:30 <lambdabot>  No instance for (GHC.Show.Show (f0 a0))
12:17:30 <lambdabot>    arising from a use of ‘M421249113511905544210587.show_M4212491135119055442...
12:17:30 <lambdabot>  The type variables ‘f0’, ‘a0’ are ambiguous
12:17:30 <lambdabot>  Note: there are several potential instances:
12:17:30 <lambdabot>    instance [safe] GHC.Show.Show a =>
12:17:32 <k0ral> benzrf: to be able to define Alternative.empty = Left mempty
12:17:34 <benzrf> eh
12:17:37 <benzrf> oh right.
12:17:40 <benzrf> derp
12:18:00 <benzrf> > empty :: Either a b
12:18:01 <lambdabot>  No instance for (Control.Monad.Trans.Error.Error a1)
12:18:02 <lambdabot>    arising from a use of ‘Control.Applicative.empty’
12:18:02 <lambdabot>  Possible fix:
12:18:02 <lambdabot>    add (Control.Monad.Trans.Error.Error a1) to the context of
12:18:02 <lambdabot>      an expression type signature: Data.Either.Either a1 b1
12:18:05 <benzrf> eech
12:18:10 <benzrf> > empty :: Either String b
12:18:11 <lambdabot>  Left ""
12:18:14 <benzrf> ok
12:18:18 <benzrf> > empty :: Either (Sum Int) b
12:18:19 <lambdabot>  No instance for (Control.Monad.Trans.Error.Error
12:18:19 <lambdabot>                     (Data.Monoid.Sum GHC.Types.Int))
12:18:19 <lambdabot>    arising from a use of ‘Control.Applicative.empty’
12:18:23 <k0ral> doesn't work in my ghci
12:18:24 <benzrf> o.o
12:19:41 <RedNifre> I guess I can't use two different Ords in a function declaration, right?
12:20:12 <barrucadu> You can: (Ord a, Ord b) => ...
12:20:22 <ReinH> :t undefined :: (Ord a, Ord b) => a -> b
12:20:23 <lambdabot> (Ord b, Ord a) => a -> b
12:20:47 <RedNifre> But how is that different from Ord -> Ord ?
12:21:00 <rwbarton> well, there is no such thing as "Ord -> Ord"
12:21:05 <rwbarton> so that's the difference
12:21:08 <k0ral> benzrf: and also to define Left a <|> Left b = Left (a mappend b)
12:21:09 <pqmodn> ord is not a type. (->) takes two arguments, which must be types.
12:21:22 <pqmodn> @kind (->)
12:21:23 <lambdabot> * -> * -> *
12:21:28 <pqmodn> @kind Ord
12:21:29 <lambdabot> * -> Constraint
12:21:40 <rwbarton> use the same rule as before
12:21:54 <rwbarton> "for any types a and b, if a is an instance of Ord and b is an instance of Ord, then I give you a function a -> b"
12:22:23 <RedNifre> Is this just to make the code more clear, or is there a reason why "Ord -> Ord" doesn't mean the same as "(Ord a, Ord b) => a -> b"?
12:22:47 <ReinH> RedNifre: because Ord is not a type and can't appear in places where a type is expected
12:23:27 <ab9rf> RedNifre: if you could do Ord -> Ord, then how would you distinguish between (Ord a) => a -> a and (Ord a, Ord b) => a -> b?
12:23:33 <pqmodn> you can place multiple constraints on a type. (Ord a, Show a, Read a) => a -> String
12:25:04 <Festisio1> test
12:25:08 <ab9rf> fail
12:25:17 <Festisio1> damn -- must be computer error
12:25:28 <ab9rf> computers never make errors
12:25:39 <RedNifre> That's what I mean, it's just verbose to be unambiguous. Which is fine. (In Java, Ord->Ord means (Ord a, Ord b) => a -> b, so I guess I had that in my head)
12:25:39 <Festisio1> P60?
12:25:52 <matematikaadit> RedNifre: it's like saying I wanna a->b, but not any a->b, I want that a->b which a and b are the instances of Ord
12:26:04 <ab9rf> RedNifre: don't confuse typeclasses with Java classes.  they are not the same thing.
12:27:45 <RedNifre> How do typeclasses differ from Java interfaces? How does (Ord a, Show a, Read a) differ from <T implements Ord, Show, Read>?
12:28:23 <ab9rf> RedNifre: java interfaces, especially when used as qualifiers on generic types, are fairly close to haskell typeclasses.
12:28:56 <ab9rf> but you can't use a haskell typeclass as a type itself the way you can in java
12:29:11 <ab9rf> this is probaby because java had interfaces before it had generics.
12:29:35 * hackagebot quickspec 0.9.4 - Equational laws for free  http://hackage.haskell.org/package/quickspec-0.9.4 (NickSmallbone)
12:29:36 <rwbarton> @quote dog.house
12:29:36 <lambdabot> rwbarton says: A type class is not a type just like a dog house is not a dog.
12:29:45 <RedNifre> I'm through the first type and typeclasses section of "Learn you a Haskell" now. I imagine it like a hierarchy, maybe with multiple inheritance. Like Integral and Floating inherit from Num or something like that.
12:29:53 <ab9rf> in java, an interface type is really a constrained generic type
12:30:08 <ab9rf> RedNifre: put aside inheritance thinking.
12:30:49 <ab9rf> it's natural for OO programmers to do that, but it's prone to erroneous thinking
12:30:50 <ReinH> RedNifre: It's best to start by assuming that they are not at all alike.
12:30:56 <RedNifre> Sooo... there's an unordered set of typeclasses and every concrete type is in at least one of them?
12:31:04 <ab9rf> RedNifre: no
12:31:04 <deweyvm> System.IO.UTF8.getLine is reporting end of file for a utf-8 string... am i doing something wrong?
12:31:09 <matematikaadit> IIRC SPJ said that typeclass is an adhoc parametric polymorphism
12:31:18 <ab9rf> RedNifre: there's no guarantee a type is an instance of any typeclasses
12:31:40 <ab9rf> and a type can be an instance of arbitrarily many typeclasses
12:31:49 <RedNifre> Okay.
12:32:01 <rwbarton> also, there is a hierarchy of sorts, though it's not very important
12:32:19 <rwbarton> the hierarchy is only between different type classes
12:32:25 <ab9rf> yeah, you get a hierarchy when a typeclass declares that derives another typeclass
12:32:29 <benzrf> RedNifre: to be precise, it is possible to put constraints on typeclass decls
12:32:34 <benzrf> RedNifre: that is to say, you can do this:
12:32:42 <benzrf> class Functor f => Applicative f
12:33:01 <benzrf> RedNifre: which means that any type that instances Applicative must also be an instance of Functor
12:33:26 <RedNifre> Ah, so I guess there's class Num f => Ord f, or something like that?
12:33:32 <benzrf> no
12:33:36 <benzrf> Ord does not imply Num
12:33:47 <benzrf> what about:
12:33:54 <benzrf> data Size = Small | Medium | Large
12:33:54 <RedNifre> right, I meant it the other way around.
12:33:56 <hexagoxel> "public interface IApplicative extends IFunctor { ... }"
12:34:11 <benzrf> RedNifre: that's an Ord, but not a NUm
12:34:12 <benzrf> *Num
12:34:15 <hexagoxel> i think, the inheritance aspect alone does exist in java as ewll
12:34:16 <benzrf> RedNifre: oic
12:34:21 <benzrf> RedNifre: i am not sure actually
12:34:25 <rwbarton> Num does not imply Ord either
12:34:29 <benzrf> i'm pretty sure you can Num something and not make an Ord instance
12:34:35 * hackagebot airbrake 0.2.0.0 - An Airbrake notifier for Haskell  http://hackage.haskell.org/package/airbrake-0.2.0.0 (JoelTaylor)
12:34:37 <deweyvm> nvm its hGetContents thats choking
12:34:42 <rwbarton> for example, complex numbers are Num but not Ord
12:34:45 <RedNifre> Which number does not have a natural ordering?
12:34:47 <benzrf> RedNifre: it's kind of like inheritance, in the sense that you can always use fmap on Applicatives
12:35:14 <matematikaadit> RedNifre: I think you are still thinking "inheritance" thing....
12:35:18 <benzrf> RedNifre: but really all that's going on is that the type system can deduce that Applicative instances also instance Functor
12:35:24 <benzrf> RedNifre: you still write, i.e.
12:35:30 <ab9rf> benzrf: Num doesn't imply ordering, iirc
12:35:31 <benzrf> instance Functor Foo where ...
12:35:37 <benzrf> instance Applicative Foo where ...
12:35:43 <RedNifre> I think that numbers are things that can be compared and it's possible to get an answer that is either < or = or >, so why aren't Nums Ords?
12:35:55 <pqmodn> no, complex numbers don't have an ordering
12:35:55 <rwbarton> RedNifre: I gave an example already, complex numbers
12:35:56 <benzrf> RedNifre: aforementioned Complex, for example
12:35:59 <matematikaadit> @src Num
12:36:00 <lambdabot> class  (Eq a, Show a) => Num a  where
12:36:00 <lambdabot>     (+), (-), (*)           :: a -> a -> a
12:36:00 <lambdabot>     negate, abs, signum     :: a -> a
12:36:00 <lambdabot>     fromInteger             :: Integer -> a
12:36:00 <ReinH> Num can't imply ordering because you can write instances of Num that cannot be instances of Ord
12:36:13 <ReinH> for example the Num b => Num (a -> b) instance
12:36:18 <RedNifre> ah, sorry rwbarton. I missed that one.
12:36:25 <RedNifre> Point taken.
12:36:39 <benzrf> > (+1) * (+2)
12:36:40 <lambdabot>  No instance for (Data.Typeable.Internal.Typeable a0)
12:36:40 <lambdabot>    arising from a use of ‘M319927675076138030910847.show_M3199276750761380309...
12:36:40 <lambdabot>  The type variable ‘a0’ is ambiguous
12:36:40 <lambdabot>  Note: there are several potential instances:
12:36:40 <lambdabot>    instance Data.Typeable.Internal.Typeable Data.Dynamic.Dynamic
12:36:42 <benzrf> interesting
12:36:54 <ab9rf> > (+1) * (+2) :: Int
12:36:56 <lambdabot>  Couldn't match expected type ‘GHC.Types.Int’
12:36:56 <lambdabot>              with actual type ‘a0 -> a0’Couldn't match expected type ‘GHC.Typ...
12:36:57 <lambdabot>              with actual type ‘a1 -> a1’
12:37:02 <ab9rf> oh, yeah
12:37:03 <ReinH> benzrf: it's basically fmap and liftA2 on everything but it isn't a part of Prelude
12:37:12 <benzrf> ReinH: i assumed the former :o
12:37:24 <benzrf> ReinH: when you put it that way, couldnt you write Reader instances for every typeclass p:
12:37:27 <ReinH> Conal has one http://hackage.haskell.org/package/NumInstances
12:37:29 <benzrf> in that fashion
12:37:30 <matematikaadit> :t (+1) * (+2)
12:37:31 <lambdabot> (Num (a -> a), Num a) => a -> a
12:37:32 <ab9rf> benzrf: not really
12:37:39 <benzrf> ab9rf: oh?
12:37:51 <rwbarton> RedNifre: but for a positive example, take class Eq a => Ord a
12:37:51 <ab9rf> aspidites: ignore that, i have no idea why i said that
12:37:52 <matematikaadit> I don't know that you could multiply a function.
12:38:10 <matematikaadit> > (+1) * (+2) $ 1
12:38:11 <lambdabot>  No instance for (GHC.Show.Show a0)
12:38:12 <lambdabot>    arising from a use of ‘M494352041190435166110900.show_M4943520411904351661...
12:38:12 <lambdabot>  The type variable ‘a0’ is ambiguous
12:38:12 <lambdabot>  Note: there are several potential instances:
12:38:12 <lambdabot>    instance [safe] GHC.Show.Show
12:38:19 <matematikaadit> > (+1) * (+2) $ 1 :: Int
12:38:19 <ReinH> matematikaadit: you can if its codom is multiplyable
12:38:21 <lambdabot>  No instance for (GHC.Num.Num (GHC.Types.Int -> GHC.Types.Int))
12:38:21 <lambdabot>    arising from a use of ‘GHC.Num.*’
12:38:23 <ReinH> but it isn't a part of Prelude
12:38:55 <ReinH> the instance is instance Num b => Num (a -> b) where (+) = liftA2 (+), etc and is defined, e.g., http://hackage.haskell.org/package/NumInstances-1.3/docs/src/Data-NumInstances-Function.html
12:38:59 <ab9rf> > (+1) * (+2) $ (*2) 1
12:39:01 <lambdabot>  No instance for (GHC.Show.Show a0)
12:39:01 <lambdabot>    arising from a use of ‘M294120885702909142310934.show_M2941208857029091423...
12:39:01 <lambdabot>  The type variable ‘a0’ is ambiguous
12:39:01 <lambdabot>  Note: there are several potential instances:
12:39:01 <lambdabot>    instance [safe] GHC.Show.Show
12:39:02 <pqmodn> from calculus, [f+g](x) = f(x) + g(x)
12:39:10 <RedNifre> Hm. So, if I want to implement a "removeFromList" function, Ord is actually wrong because it doesn't work for complex numbers. What's the typeclass for "can be compared to be equal or not equal"?
12:39:10 <ab9rf> > (+1) * (+2) $ (*2) $ 1
12:39:12 <lambdabot>  No instance for (GHC.Show.Show a0)
12:39:12 <lambdabot>    arising from a use of ‘M275843032576864156210946.show_M2758430325768641562...
12:39:12 <lambdabot>  The type variable ‘a0’ is ambiguous
12:39:12 <lambdabot>  Note: there are several potential instances:
12:39:13 <lambdabot>    instance [safe] GHC.Show.Show
12:39:17 <ReinH> Ok. can we stop trying to multiply functions now please?
12:39:22 <rwbarton> RedNifre, Eq
12:39:22 <ab9rf> heh
12:39:23 <ReinH> It isn't in Prelude or lambdabot
12:39:44 <benzrf> @let instance Num b => (a -> b) where (+) = liftA2 (+); (*) = liftA2 (*); negate = fmap negate; abs = fmap abs; signum = fmap signum; fromInteger = fmap fromInteger
12:39:44 <lambdabot>  Parse failed: Illegal instance declaration
12:39:57 <benzrf> @let instance forall a. Num b => (a -> b) where (+) = liftA2 (+); (*) = liftA2 (*); negate = fmap negate; abs = fmap abs; signum = fmap signum; fromInteger = fmap fromInteger
12:39:57 <lambdabot>  Parse failed: Illegal instance declaration
12:40:02 <benzrf> >:[
12:40:15 <ab9rf> we love to make lamdbabot jump abooot
12:40:16 <benzrf> @let instance Num b => forall a b. (a -> b) where (+) = liftA2 (+); (*) = liftA2 (*); negate = fmap negate; abs = fmap abs; signum = fmap signum; fromInteger = fmap fromInteger
12:40:16 <lambdabot>  Parse failed: Illegal instance declaration
12:40:20 <RedNifre> thanks
12:40:20 <benzrf> lambdabot you suck
12:40:23 <ReinH> λ> (+1) * (+2) $ 2
12:40:23 <ReinH> 12
12:40:29 <benzrf> wenk
12:40:41 <RedNifre> Why do I have to type "let" in ghci but not when writing a script?
12:40:49 <benzrf> RedNifre: ghci is weird
12:41:03 <ReinH> RedNifre: because the ghci environment is a modified IO do block
12:41:08 <carter> yup
12:41:24 <ReinH> So you have to write things like you would inside main = do ...
12:42:22 <ski> k0ral : perhaps try importing `Data.Either' or `Control.Monad.Error'
12:42:44 <ReinH> Anyone do much with free monad transformers? I'm trying to figure out how to write a free monad that has access to state, but neither StateT of Free nor FreeT of State seem like what I want.
12:42:46 <eyebloom> I’m having a lot of issues trying to use the foreign functino interface for my first time with the SDL2 bindings and looking for a little guidance. This program below compiles but either ends in a segmentation fault or outputs “schedule: re-entered unsafely. Perhaps a 'foreign import unsafe' should be 'safe’?”  http://lpaste.net/105305
12:42:55 <eyebloom> Any help is appreciated…
12:43:03 <carter> ReinH: why not?
12:43:17 <benzrf> ReinH: do you even lift, bro?
12:43:20 <carter> eyebloom: how long is the ffi call?
12:43:29 <eyebloom> I’m not sure
12:43:31 <benzrf> eyebloom: i hear theyre looking for functinos with the LHC
12:43:57 <carter> eyebloom: any function call that takes more than 1 microsecond should be marked "safe" rather than unsafe
12:43:58 <RedNifre> "Learn you a Haskell" states that adding type declarations is good practice. This surprises me, I thought the idea is that the compiler can figure it out by himself?
12:43:59 <ReinH> carter: I want to parameterize over the choice of the underlying monad, so it sounds like I want StateT SomeState SomeFreeMonad a, but then I also want my free monad to have access to state
12:44:15 <carter> ReinH: is there a FreeT
12:44:19 <ReinH> There is
12:44:28 <ReinH> But FreeT wouldn't let me do IO
12:44:29 <eyebloom> I think mine is marked as safe
12:44:30 <ReinH> right?
12:44:35 <carter> why not?
12:44:35 <RedNifre> For example, I didn't add a type declaration to my little "removeFromList" function, which is good, since I might have chosen Ord if rwbarton hadn't told me about Eq.
12:44:42 <eyebloom> Should it be marked as unsafe?
12:45:01 <davnils> RedNifre: not in all cases, but typically, yes. they do serve as documentation however on the top-level definitions, which is really useful.
12:45:02 <ReinH> carter: well, it wouldn't let me parameterize over the choice of monad so I could write an interpreter (monad morphism) that both performs IO and has access to state
12:45:09 <k0ral> ski: I guess what I want is actually the new Except transformer: (Functor m, Monad m, Monoid e) => Alternative (ExceptT e m)
12:45:22 <ReinH> if I use Free I can't access the state in StateT, if I use FreeT I can't write a monad morphism to IO
12:45:28 <carter> why not
12:45:29 <ReinH> carter: at least that's what it seems like
12:45:33 <eyebloom> Oh one more important thing: I get the warning “clang: warning: argument unused during compilation: '-nodefaultlibs’” when I compile
12:45:34 <ReinH> carter: I guess I'm wrong then?
12:45:35 <RedNifre> davnils I don't understand. Couldn't the compiler output the documentation instead? What's the harm in not adding type declarations?
12:45:36 <ski> RedNifre : it's often nice to first not add a type signature, and then ask the interactor about the most general inferred type, then inserting that one (or maybe a more restricted one) (perhaps after some cosmetic reformatting/renaming) as the type signature
12:45:39 <eyebloom> I’m on OSX Mavericks
12:45:42 <carter> ReinH: you just need to have a monadIO instance
12:45:54 <ski> RedNifre : .. or first writing the intended type signature, then commenting it out and doing the above
12:46:02 <carter> eyebloom: what time scale is "iNTERVAL = 1000"
12:46:21 <eyebloom> it’s arbitrary
12:46:24 <carter> no
12:46:28 <carter> thats not a time scale
12:46:31 <ReinH> carter: Well, if I have FreeT BaseF  (State s) a then I don't have IO at the base of my transformer stack
12:46:33 <davnils> RedNifre: in that case you can use ghci to infer the most general type. it's done since its comfortable to have type signatures in the code when reading.
12:46:48 <eyebloom> I think for SDL its miliseconds
12:46:51 <carter> ok
12:46:54 <carter> that must be safe then
12:46:57 <carter> can't use safe
12:46:59 <carter> or i'll kill you
12:47:00 <carter>  :)
12:47:02 <ski> RedNifre : if you have a bug in your code, it might still type check without your type signature (and then later the error will perhaps be detected somewhere else, where the type checker notes that something isn't right)
12:47:11 <hexagoxel> RedNifre: (regarding interfaces vs type classes) you might be interested in http://www.haskell.org/haskellwiki/OOP_vs_type_classes#Type_classes_are_like_interfaces.2Fabstract_classes.2C_not_classes_itself
12:47:20 <ReinH> if I have StateT s (Free BaseF) a then I don't have access to state
12:47:34 <hexagoxel> and the paragraph above that one, if you are interested in the implementation
12:47:41 <carter> ReinH: write a monad transformer...
12:47:43 <ski> RedNifre : i.e., writing an explicit type signature functions as a double check, and also helps the type checker to guess more accurately as to the real location of the bug
12:47:50 <ReinH> carter: what kind of monad transformer?
12:47:55 <ReinH> Er, what type?
12:47:59 <ReinH> I know what kind...
12:48:00 <carter> one thats composed of FreeT + StateT
12:48:02 <eyebloom> carter: But that’s just the duration of the callback generator
12:48:06 <carter> ok
12:48:16 <ReinH> carter: How does that help?
12:48:32 <eyebloom> the callback itself is very brief I believe
12:48:37 <carter> you could write MonadIO m => FreeStateT m
12:48:44 <carter> you could write MonadIO m => MonadIO ( FreeStateT m)
12:48:46 <RedNifre> ski I'm too new to Haskell to imagine a case where a too broad function would be a problem. Can you give me an example where you'd have to restrict the declaration to prevent a bug?
12:48:48 <ReinH> I need a free base monad if I want to transform it into IO
12:48:54 <carter> ReinH: why
12:49:02 <ReinH> Because IO has to be at the base of the stack
12:49:14 <ski> RedNifre : not to prevent a bug. to *detect* a bug (or detect it more accurately)
12:49:14 <carter> ReinH: how is that NOT what i just showed you
12:49:36 <ReinH> carter: because I don't want FreeT m or FreeStateT m, I need m to be free
12:49:38 <RedNifre> like what?
12:49:44 <carter> why
12:49:46 <ReinH> carter: let me give you a concrete use case
12:49:48 <carter> k
12:50:11 <ski> RedNifre : iow, if you write a type signature, you will more often (and earlier) get a type error, and so you will probably catch your errors earlier, and start looking for them in the code nearer to their actual location
12:50:19 <ReinH> carter: I'm writing a game, the game state is kept in State or StateT, I want to use a free monad to encapsulate game commands (movement, etc) and rendering / displaying / printing / IO
12:50:20 <carter> eyebloom: try doing an unsafe call too
12:50:36 <carter> ReinH: oh, so you run an interpreter at the end
12:50:40 <ReinH> In order to handle game commands it needs to be "above" State in the stack so it has access to state.
12:50:42 <ReinH> carter: right
12:50:47 <ski> (of course not all errors are type errors, but a perhaps surprisingly large class of them are)
12:50:49 <ReinH> in order to do IO it has to be below State in the stack
12:50:50 <carter> so IO doesn't amtter
12:50:50 <rwbarton> eyebloom: apparently waitEvent is doing an unsafe call to sdl
12:50:53 <ReinH> these seem mutually incompatible
12:50:54 <carter> ReinH: no,
12:50:56 <carter>  you have no IO
12:50:57 <eyebloom> That has no effect.
12:50:58 <ReinH> carter: it does when I write the interpreter
12:51:11 <eyebloom> Is it possible that the type defined in the binding is wrong?
12:51:16 <carter> eyebloom: ooo
12:51:20 <carter> try capi not ccall
12:51:31 <ReinH> Whatever structure I start with, I need a monad morphism to one with IO at the base if I want to interpret it as an IO action
12:51:41 <carter> @hacakge mmorph ?
12:51:41 <lambdabot> http://hackage.haskell.org/package/mmorph ?
12:51:43 <rwbarton> specifically an unsafe call to SDL_PumpEvents, I presume this ends up calling your callback function
12:51:44 <matematikaadit> RedNifre: Have you read this http://www.seas.upenn.edu/~cis194/lectures/03-rec-poly.html#total-and-partial-functions especially the end part.
12:51:58 <carter> ooooo, that'd be bad
12:52:06 <ReinH> carter: interpreting the free monad is a monad morphism
12:52:14 <ReinH> I don't mean anything from mmorph speifically
12:52:34 <carter> eyebloom: yeah, rwbarton  has a good point
12:52:36 <RedNifre> Ah, I think I understand. So if the compiler complains that I might call a function with a missmatched type and I'm sure that I'm not doing that, I declare the type of my functions explicitely and then see which other functions might call those with the wrong type... but still, doesn't this mean that it's fine to add declarations lazily, only when the compiler errors seems to make no sense?
12:52:51 <eyebloom> I don’t understand exactly.
12:52:56 <RedNifre> matematikaadit thanks
12:53:07 <ReinH> RedNifre: Yes, but type declarations also serve as documentation
12:53:13 <ReinH> so there are other good reasons for making them explicit
12:53:20 <rwbarton> eyebloom: here is the rule
12:53:41 <RedNifre> How does type declaration serve as documentation? Can't the compiler simply show me which declarations it infered, thus writing the documentation for me?
12:53:46 <ReinH> RedNifre: Haskell developers can learn a lot about the behavior of a function from its type
12:53:50 <rwbarton> eyebloom: if you hand a C function a function pointer to a Haskell function (produced by a foreign import "wrapper")
12:53:59 <eyebloom> yes
12:54:13 <rwbarton> eyebloom: another C function is only allowed to call that function if it was invoked through a safe foreign import
12:54:16 <matematikaadit> RedNifre: you're free to add declaration lazily. The type system is there to serve you, they're there not to serve the compiler.
12:54:17 <ReinH> RedNifre: there's a philosophical difference between what *you* claim a type to be and what the compiler claims it to be ;)
12:54:36 <rwbarton> because the RTS needs to do some setup to handle the transition back into Haskell
12:54:48 <rwbarton> an unsafe call does literally no setup, it is a call instruction
12:55:00 <ReinH> carter: so I think I'm in a catch 22 where I need Free to be bother at the top and bottom of my stack at the same time :/
12:55:10 <ReinH> carter: I'm going to write a minimal example and see if that helps
12:55:21 <ReinH> s/bother/both
12:55:22 <carter> ReinH: write a fused monad transformer
12:55:26 <rwbarton> eyebloom: that's why you saw "schedule: re-entered unsafely"
12:55:33 <ReinH> carter: what is a fused monad transformer?
12:55:41 <eyebloom> rwbarton: I see. I’m assuming that SDL.init is setting up a thread and SDL.addTimer is adding the callback to an internal queue
12:55:42 <carter> a big ole one thats one big monadT
12:55:51 <carter> rather than composed of litterl tings
12:55:52 <ab9rf> if you have two monads, you can fuse them into a single monad and use that
12:56:07 <RedNifre> I'm not convinced. But I'll read matematikaadit's link first. brb
12:56:13 <matematikaadit> " In other languages, the type system serves the needs of the compiler. In Haskell, it serves you."
12:56:25 <ReinH> carter: Maybe this is actually solved by having a FreeT for commands and a Free for rendering and decoupling the two.
12:56:29 <rwbarton> eyebloom: well, it's the C implementation in sdl itself that does those things, yeah
12:56:31 <ReinH> i.e. punting on my stated problem completely ;)
12:56:35 <triliyn> RedNifre: if you tried to use compiler-inferred types as documentation, that would document what you WROTE, not what you MEANT
12:56:39 <ab9rf> ReinH: sometimes punting is best
12:57:02 <ReinH> The comman interpreter shouldn't actually care about how rendering is being performed
12:57:04 <eyebloom> rwbarton: So I’m just not sure where I’m doing the unsafe call. If that makes any sense.
12:57:04 <ab9rf> ReinH: if you run into a type issue implementing your code, there's a decent chance that your code is wrong :)
12:57:04 <ReinH> *command
12:57:23 <hexagoxel> RedNifre: a common workflow is to write the type signatures for a set of functions, but provide no implementation yet (using "undefined" as body); then, implement the functions. thinking about types first is a good test of the design of your code.
12:57:33 <ReinH> Ah Haskell, once again you are smarter than I am
12:57:38 <rwbarton> eyebloom: you're (well, the SDL haskell library is) doing it in SDL.waitEvent
12:57:56 <RedNifre> triliyn right, but I'd check it, say "Yes, I'll agree with nearly all of this, except those two, let me make those specific... rest can remain like that". And if I compile again, it should give me an alert of the kind "The implied declaration of those methods changed, please reviem them" and again I say "sure, those are fine, that one isn't, so I specify that, done!".
12:57:56 <rwbarton> eyebloom: which looks like this: waitEvent = loop where loop = do { pumpEvents; ... }
12:58:04 <rwbarton> eyebloom: foreign import ccall unsafe "SDL_PumpEvents" pumpEvents :: IO ()
12:58:08 <ski> RedNifre : "doesn't this mean that it's fine to add declarations lazily, only when the compiler errors seems to make no sense?" -- if you please. some people do that (to a greater or lesser extent)
12:58:51 <eyebloom> rwbarton: I see, my code is significantly different from that.
12:59:04 <triliyn> RedNifre: that actually sounds like it would be a nice development assistance tool, but I don't think we have one
12:59:15 <triliyn> You can kind of do part of it with :t in ghci though
12:59:18 <eyebloom> rwbarton: I’d also note that I’m trying to use the SDL2 bindings
12:59:25 <ski> RedNifre : however, in some cases the type error might *never* appear (instead giving you differing behaviour, because of different type class instances being used) until you enter the type signatures you expect
12:59:26 <eyebloom> which are fairly new
12:59:39 <rwbarton> http://hackage.haskell.org/package/SDL-0.6.5/docs/src/Graphics-UI-SDL-Events.html#waitEvent
12:59:42 <rwbarton> oh
12:59:57 <eyebloom> Yeah sorry.
13:00:09 <triliyn> But thinking about types before you write your code is useful too
13:00:09 <eyebloom> I should have made that more explicit.
13:00:16 <rwbarton> what package is that (and why does it use the same module names??)
13:00:26 <rwbarton> well I guess it's handy if they're mostly compatible
13:00:26 <eyebloom> One moment
13:00:26 <hexagoxel> if you enable the right warning, ghc will print the types of any top-level-functions without a type signature
13:00:44 <eyebloom> rwbarton: https://hackage.haskell.org/package/sdl2-1.1.0
13:01:07 <rwbarton> weird. why doesn't hoogle find this package
13:01:18 <eyebloom> Not sure.
13:01:57 <RedNifre> matematikaadit I read your link, it's terrifying! I think a lot less of Haskell now :(
13:02:30 <rwbarton> ok, well, hmm. now waitEvent is just a foreign import of SDL_WaitEvent, and I think safe is the default
13:02:35 <rwbarton> are you sure you're using sdl2? :)
13:02:36 <ski> RedNifre : what's terrifying about it ?
13:02:44 <RedNifre> This is also something that surprised me in the "Learn you a Haskell" tutorial. Why write functions that raise errors?
13:02:44 <eyebloom> So far I hadn’t had to much trouble with this library.
13:02:56 <RedNifre> Well, it says that functions like head can crash
13:03:08 <ab9rf> > head []
13:03:10 <lambdabot>  *Exception: Prelude.head: empty list
13:03:12 <eyebloom> I think so, it’s installed on my system
13:03:21 <rwbarton> eyebloom: if you can get it to segfault, you can try running inside gdb, and check what C function(s) the path back into haskell is through
13:03:26 <RedNifre> ab9rf Rigth, but why does that compile?
13:03:30 <rwbarton> eyebloom: well, they do have the same module names
13:03:31 <RedNifre> This makes absolutely no sense to me.
13:03:45 <RedNifre> I thought the idea of Haskell was that it works because you can't compile nonsensical code.
13:03:46 <ab9rf> RedNifre: because there's no difference in _type_ between [] and [1]
13:03:49 <barrucadu> RedNifre: The types all match, why wouldn't it compile?
13:04:09 <RedNifre> The types are wrong, head should only accept nonempty lists as input.
13:04:14 <ab9rf> (well, there is actually.... [] is [a] and [1] is [Int])....
13:04:20 <ab9rf> RedNifre: there's no type for "nonempty list"
13:04:21 <pqmodn> :t head
13:04:22 <lambdabot> [a] -> a
13:04:30 <pqmodn> says nothing about non-empty
13:04:38 <RedNifre> Right. I think that is the problem.
13:04:54 <RedNifre> Why does that function declare that it can handle a type that it can't? I don't understand.
13:05:05 <ab9rf> RedNifre: head isn't total
13:05:12 <eyebloom> rwbarton: On my system it’s lldb but I’ll give it a shot.
13:05:31 <matematikaadit> :t []
13:05:32 <lambdabot> [t]
13:05:38 <ab9rf> RedNifre: there's no way in the type system to say "lists, but only if they're not empty"
13:05:41 <RedNifre> Then why does head declare itself as total? (Not sure I know the definition of "total")
13:05:50 <matematikaadit> RedNifre: the type of [] is [a]
13:06:01 <ski> `head' doesn't declare itself as total
13:06:04 <matematikaadit> :t [1]
13:06:05 <lambdabot> Num t => [t]
13:06:10 <apples> erm, you can represent a non-empty list in the type system
13:06:14 <ski> (there is no way to indicate totality in the type system)
13:06:18 <matematikaadit> :t ['c']
13:06:18 <apples> with (a, [a])
13:06:19 <lambdabot> [Char]
13:06:32 <ab9rf> apples: meh
13:06:47 <ski> ab9rf : with refinement types, there would be
13:06:56 <ab9rf> apples: and then you need all sort of transformers....
13:07:03 <RedNifre> Why isn't it head (x:a) = x ? How would that accept [] ?
13:07:14 <ski> it doesn't
13:07:18 <matematikaadit> RedNifre: because the type of [] is [a]
13:07:18 <ski> that's why it's partial
13:07:24 <ab9rf> RedNifre: it doesn't.  [] does not match (x:a)
13:07:53 <matematikaadit> RedNifre: I sugest you to read http://www.seas.upenn.edu/~cis194/lectures.html as introductory to haskell.
13:07:53 <ab9rf> the "head [] = error ..." definition is simply to give a more useful error message than a pattern matching failure
13:08:19 <RedNifre> is that a compile error or a runtime error?
13:08:29 <ab9rf> RedNifre: pattern match errors are runtime
13:08:33 <jmcarthur> sadly
13:08:43 <RedNifre> That is extremely disappointing.
13:08:44 <ab9rf> ski: yeah, i'm aware
13:08:46 <jmcarthur> but you can get a warning
13:08:50 <jmcarthur> -Wall enables it
13:09:01 <ab9rf> yeah, some pattern match problems will generate warnings
13:09:01 <jmcarthur> you coudl also turn warnings into errors
13:09:04 <apples> RedNifre, if you're really worried, you can use something like listToMaybe
13:09:07 <apples> :t listToMaybe
13:09:08 <lambdabot> [a] -> Maybe a
13:09:14 <Nik05> can i do something like foo a:b@(x:y) = ?
13:09:25 <RedNifre> So, if I don't have a type that matches my function, I use the next bigger type and throw errors for the values of that type that I don't support? Really?
13:09:39 <rwbarton> Nik05: yes
13:09:41 <pqmodn> wat
13:09:55 <rwbarton> Nik05: it needs more parens though
13:09:56 <jmcarthur> RedNifre: "bigger type"?
13:09:57 <Nik05> hm ok ghc says Parse error
13:10:00 <ab9rf> RedNifre: "next bigger type"?
13:10:04 <barrucadu> RedNifre: If it makes sense for your use-case, you can define a new type
13:10:06 <rwbarton> Nik05: foo (a:b@(x:y))
13:10:07 <Nik05> ah ok, thank you :)
13:10:15 <jmcarthur> RedNifre: with -Wall the compiler would tell you
13:10:15 <pqmodn> > listToMaybe [1]
13:10:16 <lambdabot>  Just 1
13:10:18 <pqmodn> > listToMaybe []
13:10:20 <lambdabot>  Nothing
13:10:28 <barrucadu> If you know that you're dealing with non-empty lists and only non-empty lists, then you can do that
13:10:59 <matematikaadit> RedNifre: I think you misunderstand that. Are you keep thinking the type of empty list ([]) isn't the same as the type of non empty list, like [4]?
13:13:01 <RedNifre> matematikaadit No, it's fine that [] means "An empty list of whichever type you want".
13:13:04 <ab9rf> matematikaadit: it's technically an enclosing type, since [] is less constrained than [4] :)
13:13:32 <rwbarton> maybe try strings
13:13:35 <benzrf> > listToMaybe [1, 2]
13:13:36 <lambdabot>  Just 1
13:13:39 <benzrf> eh
13:13:53 <benzrf> @src listToMaybe
13:13:53 <lambdabot> listToMaybe []        =  Nothing
13:13:54 <lambdabot> listToMaybe (a:_)     =  Just a
13:14:00 <jmcarthur> listToMaybe is just a total head
13:14:12 <ab9rf> RedNifre: if you want a specifically typed empty list, you can do "[] :: [Char]"
13:14:18 <RedNifre> I agree with what's at the very end of this link: http://www.seas.upenn.edu/~cis194/lectures/03-rec-poly.html#total-and-partial-functions
13:14:19 <ab9rf> > [] :: [Char]
13:14:21 <lambdabot>  ""
13:14:42 <ab9rf> which amusingly prints an empty string because String is [Char] :)
13:14:51 <RedNifre> I don't want a specifically typed empty list, I want a head function that only accepts nonempty lists. Like in that link from matematikaadit http://www.seas.upenn.edu/~cis194/lectures/03-rec-poly.html#total-and-partial-functions
13:14:52 <benzrf> > []
13:14:53 <lambdabot>  []
13:14:56 <benzrf> interesting
13:15:12 <benzrf> RedNifre: you want a dependently typed language, then
13:15:15 <johnw> RedNifre: what about data-checked?
13:15:24 <ab9rf> RedNifre: a function that only accepts nonempty lists would be nontotal.  haskell does not have dependent types
13:15:28 <RedNifre> However, I don't see the point of the Maybe solution. When would I want to call a function with something it can't handle and react to that during runtime?
13:15:51 <benzrf> RedNifre: you want a dependently typed language, then
13:16:03 <ab9rf> RedNifre: listToMaybe is total, it can handle every possible value of its domain
13:16:08 <ski> RedNifre : sounds like you want refinement types .. or perhaps what benzrf said
13:16:10 <RedNifre> I'm too new to all this to understand what you are saying. Could you explain nontotal and dependently typed?
13:16:16 <rwbarton> yes you really want refinement types
13:16:42 <johnw> head :: Checked IsNonEmpty [a] -> a; then you can run: mx <- check xs [1]; case mx of Nothing -> return (); Just x -> head x
13:17:06 <johnw> you just move the Maybe checking from the point of consumption (i.e., headMay) to the point of production
13:17:08 <triliyn> I think refinement types are better than dependent types for this particular purpose
13:17:11 <ryantrinkle> is there a way to get the readsPrec that "deriving" would have derived, without actually using "deriving"?
13:17:30 <triliyn> Because the only obvious way I know of to prove that a list is non-empty in something like Idris is to already know the first element
13:17:37 <ski> RedNifre : "dependently typed" is this somewhat complicated thing (it allows you to specify an exact mathematical specification of your function. e.g. so that a sorting function won't type check unless it actually sorts the input) -- it's probably better to not go that much into at the moment
13:18:04 <jmcarthur> ryantrinkle: i think this question needs a little context. hard to guess what's actually allowed for the solution.
13:18:30 <apples> RedNifre, nontotal (or partial) just means that there are input values for which the function isn't defined
13:18:37 <johnw> data IsNonEmpty = IsNonEmpty; instance Property IsNonEmpty [a] where holds IsNonEmpty [] = False; holds IsNonEmpty _ = True
13:18:39 <RedNifre> I'm not sure that's what I would want. The solution in the link (declaring a Type NonEmptyList and a head function that takes a NonEmptyList as input) seems nice.
13:18:43 <ryantrinkle> jmcarthur: well, basically, i'd like to write a custom Read instance for a datatype, but i'd like to base it on the normal Read instance
13:18:57 <ryantrinkle> if i use deriving, it creates the instance, which means i can't write my own
13:18:59 <ski> RedNifre : in most programming languages, any expression could fail to compute a value, e.g. because they fail to terminate, or because they reach some kind of undefined/exceptional condition
13:19:16 <jmcarthur> ryantrinkle: you could always using deriving on some internal representation and then use a newtype wrapper
13:19:17 <RedNifre> ski sure, but some of these cases are easier to prevent than others.
13:19:23 <ski> RedNifre : we'd say that such an expression is undefined, or partial
13:19:41 <benzrf> ski: is your nick any relation to the SKI calculus
13:19:42 <ski> RedNifre : in some cases, the expression might or might not be partial, depending on the actual values of free variables in it
13:19:47 <ski> benzrf : yes
13:19:53 <ryantrinkle> jmcarthur: yeah, i suppose that'll have to be the way; just adds some cruft
13:20:03 <benzrf> heh
13:20:15 * enthropy has a question regarding translating FD into TF http://stackoverflow.com/questions/24110410/
13:20:17 <RedNifre> (Please note that English is not my native language and that I'm not a mathematician, so I might have to ask about the meaning of many special words)
13:20:20 <rwbarton> ryantrinkle: you could probably also use the derive package
13:20:45 <ski> RedNifre : we say a function is partial if calling it may yield a partial expression
13:20:47 <rwbarton> ryantrinkle: and do some postprocessing on the resulting code (ew)
13:20:48 <RedNifre> ...but undefined or partial is always meant in relation to a concrete type, right? E.g. it's fine that + doesn't work with strings, right?
13:20:57 <pqmodn> 1 / 0
13:20:59 <pqmodn> > 1 / 0
13:21:01 <lambdabot>  Infinity
13:21:02 <mp> how do I make hashable value (usable in unordered-containers hash map) from persistent's Key (as returned from entityKey x)?
13:21:02 <ab9rf> RedNifre: + isn't defined on lists.
13:21:04 <ryantrinkle> rwbarton: hahaha yeah, "ew" sounds right
13:21:08 <ski> RedNifre : yes, all this assumes that the program has already type-checked
13:21:08 <pqmodn> > 1 / 0 :: Int
13:21:10 <lambdabot>  No instance for (GHC.Real.Fractional GHC.Types.Int)
13:21:10 <lambdabot>    arising from a use of ‘GHC.Real./’
13:21:16 <jmcarthur> enthropy: afaik, TFs don't quite subsume FDs
13:21:26 <ski> RedNifre : for a program that doesn't type-check, we simply claim that it is meaningless
13:21:38 <ab9rf> it's not a "well-formed program"
13:21:51 <jmcarthur> enthropy: before i even looked at your question i guessed it would be about a bidirectional FD relationship :)
13:21:53 <ReinH> A program that doesn't type check isn't a program in any reasonable sense :p
13:21:58 <ReinH> It's a text file.
13:21:59 <RedNifre> "doesn't type-check" means "the type can't be inferred"?
13:22:07 <pqmodn> no
13:22:10 <triliyn> It means "there is a type error"
13:22:14 <triliyn> Such as:
13:22:15 <triliyn> > head 5
13:22:17 <lambdabot>  No instance for (GHC.Show.Show a0)
13:22:17 <lambdabot>    arising from a use of ‘M273746873905299204711596.show_M2737468739052992047...
13:22:17 <lambdabot>  The type variable ‘a0’ is ambiguous
13:22:17 <lambdabot>  Note: there are several potential instances:
13:22:17 <lambdabot>    instance [safe] GHC.Show.Show
13:22:18 <enthropy> jmcarthur: well it works 99% of the time, just the TF is too lazy
13:22:25 <triliyn> ...er, numeric literals >.>
13:22:28 <triliyn> > head 'c'
13:22:29 <lambdabot>  Couldn't match expected type ‘[a]’
13:22:29 <lambdabot>              with actual type ‘GHC.Types.Char’
13:22:38 <triliyn> (Ignore the "head 5" one)
13:22:48 <ab9rf> lambdabot has weird definitions of numbers
13:22:48 <pqmodn> RedNifre: many languages don't have type inference, but still have type checking (C, Java, etc)
13:22:52 <ab9rf> > head (5::Int)
13:22:54 <lambdabot>  Couldn't match expected type ‘[a]’ with actual type ‘GHC.Types.Int’
13:22:59 <ski> RedNifre : for an expression that fails to evaluate to a (normal) value, we say that its "value" is "bottom" or "undefined", written ⌜⊥⌝, or `_|_' in ascii
13:23:17 <ski> RedNifre : so bottom is the "value" of a "valueless expression"
13:23:43 <ski> RedNifre : now note that some *parts* of an expression may evaluate to a bottom without the *whole* expression doing so
13:23:48 <RedNifre> So the head of [] is bottom and whenever you get a bottom you should abort the program?
13:23:51 <ski> > length [0,1,undefined]
13:23:53 <lambdabot>  3
13:24:03 <ski> RedNifre : yes
13:24:15 <RedNifre> Now I think it's all about compromises.
13:24:18 <ski> if you get a bottom, then you basically have a bug in your program
13:24:21 <jmcarthur> RedNifre: well, not necessarily abort, unless you actually evaluated it
13:24:26 <RedNifre> Right
13:24:36 <pqmodn> > length [head []]
13:24:37 <lambdabot>  1
13:24:49 <jmcarthur> RedNifre: bottom is one of haskell's sneakier side effects (yes, a real side effect)
13:24:53 <RedNifre> interesting
13:25:20 <ski> RedNifre : because Haskell uses non-strict evaluation, bottoms can not only result from calling functions, but may be passed as arguments and results, and stored in data structures
13:25:31 <RedNifre> So I thought about 1/0. I guess / is Num -> Num -> Num?
13:25:42 <jmcarthur> :t (/)
13:25:44 <lambdabot> Fractional a => a -> a -> a
13:25:47 <jmcarthur> close :)
13:25:49 <ski> @type (/) :: Double -> Double -> Double
13:25:50 <lambdabot> Double -> Double -> Double
13:25:57 <ski> @type (/) :: Float -> Float -> Float
13:25:58 <lambdabot> Float -> Float -> Float
13:25:59 <briennetheblue> > div 1 0
13:26:01 <lambdabot>  *Exception: divide by zero
13:26:01 <jmcarthur> RedNifre: there's also quot and div
13:26:02 <ski> @type (/) :: Rational -> Rational -> Rational
13:26:04 <lambdabot> Rational -> Rational -> Rational
13:26:08 <benzrf> RedNifre: you can be a Num without having division
13:26:28 <benzrf> RedNifre: Num is only for integer-likes afaict
13:26:37 <benzrf> :t quot
13:26:38 <lambdabot> Integral a => a -> a -> a
13:26:40 <jmcarthur> benzrf: Num is more general
13:26:42 <benzrf> :t div
13:26:43 <lambdabot> Integral a => a -> a -> a
13:26:44 <ab9rf> > length $ take 30 (repeat error)
13:26:45 <ski> no, `Double' is also in `Num', e.g.
13:26:46 <lambdabot>  30
13:26:48 <jmcarthur> benzrf: Integral is for integer-likes :)
13:26:56 <benzrf> o
13:27:05 <jmcarthur> benzrf: i guess Num does have fromInteger
13:27:07 <benzrf> ski: i mean the operations of integer-likes
13:27:12 <jmcarthur> benzrf: but no toInteger, at least
13:27:13 <hexagoxel> the whole tree of "numeric" type classes is a bit confusing in haskell :)
13:27:14 <benzrf> ski: not to say it's limited to that
13:27:21 <RedNifre> Anyways, my first thought about 1/0 was that the declaration should be Fractional -> NonZeroFractional -> Fractional, but I guess having too specific types means that you do all the work at compile time, which is impossible...
13:27:37 <ab9rf> Num has fromInteger, (+), (-), negate, signum, and abs iirc
13:27:37 <jmcarthur> RedNifre: well, you *could* do it that way
13:27:38 <ski> RedNifre : not impossible, but somewhat more work, yes
13:28:02 <ski> (depending on what you mean by "do all the work at compile time")
13:28:02 <rwbarton> RedNifre: suppose now I define a function "f a = 1 / (a-1)". what should the type of that be
13:28:05 <triliyn> RedNifre: it's difficult and standard haskell doesn't try to do it, but refinement types and dependent types are two different approaches to this
13:28:06 <pqmodn> alternatively, you can use Maybe or Either to handle the error at runtime
13:28:07 <jmcarthur> it would have to be something like     Fractional a => a -> NonZero a -> a
13:28:40 <ski> (and dependent types are much more powerful than refinement types. refinement types is a kind of subtyping)
13:28:44 <Nik05> if i have a foo (a@(b:c)) = does this also pattern match against empty lists and lists with one element?
13:28:45 <hexagoxel> there is a balance between "how much the type system can express" and "how much work (for the programmer) writing all the types and proofs"
13:28:46 <dottedmag> How about f a = a / (a-1)?
13:28:59 <ski> Nik05 : not empty lists
13:29:12 <jmcarthur> hexagoxel: but it's totally fair game to argue about where the line is! :)
13:29:14 <dottedmag> Eh, the same. f a = 1 / (a * (a-1))
13:29:16 <ReinH> carter: Unfortunately, my plan doesn't work :/
13:29:19 <ski> Nik05 : also (perhaps somewhat confusingly) that can be written as `foo a@(b:c) = ...'
13:29:21 <Nik05> oh right sorry, asking too quick :)
13:29:24 <jmcarthur> haskell has its own line
13:29:37 <ab9rf> i seem to recall that type inferencing with either refinement types or dependent types runs into difficulties
13:29:41 * hackagebot resource-pool 0.2.3.0 - A high-performance striped resource pooling implementation  http://hackage.haskell.org/package/resource-pool-0.2.3.0 (BasVanDijk)
13:29:41 <Nik05> ski why can i now leave the brackets out?
13:29:47 <RedNifre> rwarton that's what I mean, you would need infinitely many types and for things like f a b = 1/(a-b) you would have to check every combination of a and b at compile time.
13:30:15 <jmcarthur> ab9rf: i don't know much about refinement types. i am familiar with the subtyping of ocaml polymorphic variants, which i'm guessing is similar. ocaml seems to infer those types just fine.
13:30:27 <ski> Nik05 : `<id>@<pat>' *both* binds the given value to `<id>' and matches it to `<pat>' (possibly binding more variables, in case that match succeeds)
13:30:38 <triliyn> Type inference is technically undecidable with both, yes. Because for example, you can't tell the difference between 1 :: Int and 1 :: {x : Int | x < 0}
13:30:47 <ski> Nik05 : because the `@' "syntactic operator" binds tighter than function application
13:30:50 <triliyn> And the problem is similar for dependent types
13:30:57 <ab9rf> jmcarthur: it's been three or four years since i looked at this.  i though it was either provably undecidable in some cases, or running into NP-completeness
13:31:15 <jmcarthur> ah, it sounds like refinement types allow some sort of predicate. i can see why that would have similar problems with type inference to dependent types
13:31:33 <Nik05> right ski but foo a:@b(c:d) wasnt allowed
13:31:46 <ab9rf> jmcarthur: but i don't recall which or the specifics.  i'm just a hacker, not a compiler theorist :)
13:32:04 <ski> Nik05 : otoh, if you had said `foo ~(b:c) = ...', then it would have matched empty lists as well (and if you then tried to access `b' or `c', it would *then* yield a pattern-match failure. this is known as a lazy/irrefutable/"delayed" pattern)
13:32:16 <ski> Nik05 : what would `:@' mean there ?
13:32:20 <ab9rf> i vaguely recall that the halting problem cropped up
13:32:28 <RedNifre> so... in an ideal world, the program would be verified for every possible input during compile time, with spontaneously made up types like FractionalThatIsNotFive and we would never get errors... but since we don't have that, we pick the best matching type and throw errors or maybes or maybe declare our own type if it's feasible. Hm...
13:32:39 <Nik05> sorry ski :b@(
13:32:46 <ski> Nik05 : perhaps you meant `foo (a:b@(c:d))' ?
13:32:58 <ski> @type let foo (a:b@(c:d)) in (a,b,c,d) in foo
13:32:59 <lambdabot> parse error on input ‘in’
13:33:02 <Nik05> yes why does that need brackets but foo a@(b:c) doesnt?
13:33:06 <ski> @type let foo (a:b@(c:d)) = (a,b,c,d) in foo
13:33:07 <lambdabot> [t] -> (t, [t], t, [t])
13:33:24 <rwbarton> Nik05, same reason foo (a:b) needs parentheses but foo a doesn't
13:33:29 <ski> <ski> Nik05 : because the `@' "syntactic operator" binds tighter than function application
13:33:39 <ab9rf> > let foo (a:b@(c:d)) = (a,b,c,d) in foo "xy"
13:33:40 <lambdabot>  ('x',"y",'y',"")
13:33:49 <Nik05> aaah right ok :)
13:33:50 <ski> (but `:' doesn't bind tighter than function application)
13:34:12 <ski> ("looser" or what would be the appropriate term ?)
13:35:04 <Nik05> i just wrote a small parser, executed it and tried out some stuff. And it worked for some things i thought it would break :P
13:36:08 <Nik05> when you get an exception in a pattern match or in a case expression, does it continue to try to find a match without an exception?
13:36:43 <dmwit> It will try matching all patterns in order.
13:36:47 <dmwit> You only get an exception if none match.
13:37:09 <Francis49> hello dear friends
13:37:19 <ab9rf> if, once it's matched a pattern, the matching code generates an error or exception, it does not move on to other patterns.
13:37:36 <Nik05> well i got a case expression which also calls the function read and that read probably gave an exception but it doesnt throw an exception to me
13:37:49 <rwbarton> or if the process of matching a pattern causes an exception to be evaluated, then it doesn't continue with other patterns
13:37:54 <ski> Nik05 : don't call `read'
13:38:00 <dmwit> :t reads
13:38:01 <lambdabot> Read a => ReadS a
13:38:09 <hexagoxel> RedNifre: note that "non-terminating computation" is also bottom, which brings us to the halting problem; so you cannot prevent any bottom, no matter how powerful the typing system
13:38:13 <dmwit> type ReadS a = String -> [(a, String)]
13:38:16 <merijn> dmwit: Pfft, Text.Read.readMaybe
13:38:19 <ski> > read "123barf" :: Integer
13:38:21 <lambdabot>  *Exception: Prelude.read: no parse
13:38:26 <dmwit> I am very "meh" about readMaybe.
13:38:28 <ski> > (reads :: ReadS Integer) "123barf"
13:38:29 <lambdabot>  [(123,"barf")]
13:38:33 <dmwit> It doesn't seem useful to me.
13:38:34 <merijn> hexagoxel: You can, just not in a Turing complete language
13:38:44 <merijn> hexagoxel: Which, btw, there are hacks for too
13:38:53 <dmwit> Also, if you are writing a parser, and calling any variant of read, you are doing it wrong.
13:39:00 <Nik05> oh wait it does throw an exception :)
13:39:01 <ab9rf> heh, really
13:39:22 <merijn> hexagoxel: For example, Agda is a total language, which means it proves every function terminates (assuming you don't use "unsafe" features to bypass it)
13:40:02 <RedNifre> hexagoxel. Right. I guess my issue is with the granularity of the types. My initial reaction was that not having a type for NonEmptyList that can be used for head is a shortcoming, but I'm not sure where to draw the line anymore. Guess I'll finish the tutorial before I complain about details again ;)
13:40:04 <ski> > let foo str = case [x | (x,"") <- reads str] of [x] -> Just x; _ -> Nothing; map foo ["123barf","456"]
13:40:06 <lambdabot>  <hint>:1:78: Parse error in pattern: map
13:40:16 <ski> > let foo str = case [x | (x,"") <- reads str] of [x] -> Just x; _ -> Nothing in map foo ["123barf","456"]
13:40:18 <lambdabot>  [Nothing,Nothing]
13:40:21 <Francis49> chrisdone, hello friend, can you give me some help?
13:40:26 <Nik05> > (reads :: ReadS Integer) "barf"
13:40:27 <lambdabot>  []
13:40:29 <ab9rf> RedNifre: we could have required that lists be nonempty but then other things become ugly
13:40:31 <ski> > let foo str = case [x | (x,"") <- reads str] of [x] -> Just x; _ -> Nothing in map foo ["123barf","456"] :: [Maybe Integer]
13:40:33 <lambdabot>  [Nothing,Just 456]
13:40:41 <hexagoxel> merijn: hmm interesting, i did not know that about agda.
13:41:02 <RedNifre> ab9rf No, I was thinking about separate types for lists and nonEmptyLists
13:41:03 <rwbarton> RedNifre, that's a reasonable reaction and a reasonable conclusion :)
13:41:04 <dmwit> RedNifre: We have a type for non-empty lists. It's (a, [a]).
13:41:22 <ab9rf> RedNifre: you can do that if you wish
13:41:26 <pqmodn> heaumer: also subsets of SQL (without recursive CTEs, and regular expressions)
13:41:36 <ski> RedNifre : it can be seen as a shortcoming, yes. most of the other programming languages (with ststic type systems) are worse here, though ;)
13:41:55 <dmwit> RedNifre: or data NonEmpty a = NonEmpty a [a], which has benefits of its own
13:42:12 <ab9rf> although then what's the type of head . head? :)
13:42:29 <pqmodn> NonEmpty (NonEmpty a)
13:42:50 <dottedmag> One could have List1 / List2 / List3 / ... ;) But then how to type (++) ?
13:43:17 <benzrf> dottedmag: dependent typing!!!
13:43:23 <benzrf> also, type-level naturals
13:43:26 <benzrf> ;)
13:43:33 <benzrf> :t S
13:43:34 <ab9rf> benzrf: heh
13:43:34 <lambdabot> Not in scope: data constructor ‘S’
13:43:37 <benzrf> hmm
13:43:39 <benzrf> i did this before...
13:43:42 <ski> dottedmag : `_++_ : {A : Set} -> {m n : Nat} -> Vector A m -> Vector A n -> Vector A (m + n)' :)
13:44:22 <benzrf> @let data S n where Z :: S Void; S :: S n -> S (S n);
13:44:23 <lambdabot>  .L.hs:174:16: Not in scope: type constructor or class ‘Void’
13:44:26 <benzrf> bluh
13:44:28 <benzrf> @let data Void
13:44:31 <lambdabot>  Defined.
13:44:31 <benzrf> @let data S n where Z :: S Void; S :: S n -> S (S n);
13:44:33 <lambdabot>  Defined.
13:44:34 <rwbarton> the trouble with this approach is you cook up a new type for every kind of information about your list, and then you can't use any of your old functions
13:44:50 <benzrf> :t S (S (S Z))
13:44:51 <ski> benzrf : pervert
13:44:51 <lambdabot> S (S (S (S Void)))
13:44:58 <dottedmag> Well, introducing a bunch of lifters would help ;)
13:45:02 <benzrf> mmmm
13:45:17 <ab9rf> tuples are bad enough :)
13:45:32 <rwbarton> you still have to explicitly write the conversions in your program, and pay a run-time cost
13:45:44 <matematikaadit> [03:40:23] <ab9rf> although then what's the type of head . head? :) <--- head . head :: [a] -> [a], but headNonEmpty :: NonEmpty a -> [a] :D
13:46:05 <pqmodn> > head.head -- [[a]]
13:46:07 <lambdabot>  No instance for (Data.Typeable.Internal.Typeable c0)
13:46:07 <lambdabot>    arising from a use of ‘M456931775568214768612137.show_M4569317755682147686...
13:46:07 <lambdabot>  The type variable ‘c0’ is ambiguous
13:46:07 <lambdabot>  Note: there are several potential instances:
13:46:07 <lambdabot>    instance Data.Typeable.Internal.Typeable Data.Dynamic.Dynamic
13:46:09 <pqmodn> @type head.head
13:46:11 <lambdabot> [[c]] -> c
13:46:13 <benzrf> @let data Sized s a where SNil :: Sized (S Void) a; SCons :: a -> Sized s a -> Sized (S s) a;
13:46:15 <lambdabot>  Defined.
13:46:26 <rwbarton> head . head is too easy, try head . tail
13:46:30 <benzrf> @let c = SCons
13:46:31 <pqmodn> right
13:46:32 <lambdabot>  Defined.
13:46:34 <benzrf> no wait
13:46:36 <ab9rf> yeah, head.tail is what i meant, my bad
13:47:02 <benzrf> :t 1 `c` 2 `c` 3 `c` SNil
13:47:04 <lambdabot>     Ambiguous occurrence ‘c’
13:47:04 <lambdabot>     It could refer to either ‘L.c’,
13:47:04 <lambdabot>                              defined at /home/lambda/.lambdabot/State/L.hs:182:1
13:47:07 <benzrf> oy
13:47:18 <ab9rf> poor lambdabot
13:47:19 <dottedmag> rwbarton: Supercompilation may probably help to reduce the runtime cost / code bloat.
13:47:27 <benzrf> @let (=:) = SCons
13:47:29 <lambdabot>  Defined.
13:47:35 <benzrf> :t 1=:2=:3=:SNil
13:47:36 <lambdabot> (Num (Sized s1 a), Num (Sized s (Sized (S s1) a)), Num a) => Sized (S (S Void)) (Sized (S s) (Sized (S s1) a))
13:47:39 <benzrf> o_O
13:47:48 <dottedmag> but well, it's not serious.
13:47:49 <benzrf> goodness
13:48:01 <benzrf> @let infixr :=
13:48:02 <lambdabot>  .L.hs:185:10:
13:48:02 <lambdabot>      The fixity signature for ‘:=’ lacks an accompanying binding
13:48:09 <benzrf> @let infixr =:
13:48:11 <lambdabot>  Defined.
13:48:13 <benzrf> :t 1=:2=:3=:SNil
13:48:14 <lambdabot> Num a => Sized (S (S (S (S Void)))) a
13:48:17 <benzrf> :-D
13:48:42 <Francis49> by all friends
13:48:52 <matematikaadit> well. sorry. I'm wrong. head . head :: [[a]] -> a, and headNonEmpty :: NonEmpty a -> a
13:49:12 <pqmodn> NonEmpty (NonEmpty a) -> a
13:49:21 <benzrf> @let sHead :: Sized (S (S s)) a -> a
13:49:22 <lambdabot>  .L.hs:187:1:
13:49:22 <lambdabot>      The type signature for ‘sHead’ lacks an accompanying binding
13:49:23 <benzrf> oops
13:49:37 <benzrf> @let sHead :: Sized (S (S s)) a -> a; sHead (SCons h _) = h
13:49:39 <lambdabot>  Defined.
13:49:47 <matematikaadit> yes. as pqmodn said.
13:49:50 <benzrf> > sHead (1=:2=:3=:SNil)
13:49:52 <lambdabot>  1
13:49:55 <benzrf> > sHead SNil
13:49:56 <lambdabot>  Couldn't match type ‘L.Void’ with ‘L.S s0’
13:49:56 <lambdabot>  Expected type: L.Sized (L.S (L.S s0)) a
13:49:56 <lambdabot>    Actual type: L.Sized (L.S L.Void) a
13:50:00 <benzrf> :_O
13:50:28 <pqmodn> :t sHead.sHead
13:50:29 <lambdabot> Sized (S (S s1)) (Sized (S (S s)) c) -> c
13:51:01 <pqmodn> S (S n) to represent 1 is kinda strange
13:51:12 <benzrf> pqmodn: lambdabot doesnt have type familes :T
13:51:52 <pqmodn> -- @let data S n where Z; S :: n -> (S n);
13:52:22 <benzrf> pqmodn: then how can i tell Z from S something
13:52:29 <benzrf> Z :: S Void
13:52:45 <pqmodn> ah
13:52:46 <benzrf> with yours, Z is polymorphic to S anything
13:53:27 <merijn> Why not "data Nat = Z | S Nat"?
13:53:38 <benzrf> merijn: type-level
13:53:46 <benzrf> @let sTail :: Sized (S (S n)) a -> Sized (S n) a; sTail (SCons _ t) = t
13:53:48 <lambdabot>  Defined.
13:53:54 <merijn> benzrf: DataKinds
13:53:54 <benzrf> :t sTail . sTail
13:53:55 <lambdabot> Sized (S (S (S n))) a -> Sized (S n) a
13:53:56 <merijn> Problem solved
13:54:05 <benzrf> merijn: does lambdabot have that
13:54:27 <enthropy> > undefined :: a Just
13:54:29 <lambdabot>  Not in scope: type constructor or class ‘Just’
13:54:29 <lambdabot>  A data constructor of that name is in scope; did you mean DataKinds?
13:54:45 <benzrf> enthropy: wut
13:54:48 <benzrf> oh
13:54:49 <merijn> @let Foo a = Foo
13:54:50 <lambdabot>  .L.hs:190:1:
13:54:50 <lambdabot>      My brain just exploded
13:54:50 <lambdabot>      I can't handle pattern bindings for existential or GADT data constructors.
13:54:50 <lambdabot>      Instead, use a case-expression, or do-notation, to unpack the constructor.
13:54:50 <lambdabot>      In the pattern: Foo L.a
13:54:52 <benzrf> eenteresting
13:55:15 <enthropy> benzrf: it means the extension isn't enabled
13:55:17 <benzrf> r.i.p. in pizza lambdabot
13:55:28 <benzrf> enthropy: oki
13:55:49 <enthropy> seems like your project is too big to fit into this channel anyways
13:56:44 <benzrf> > sTail (3=:4=:SNil)
13:56:45 <lambdabot>  No instance for (GHC.Show.Show (L.Sized (L.S (L.S L.Void)) a0))
13:56:45 <lambdabot>    arising from a use of ‘M409827823065810570312467.show_M4098278230658105703...
13:56:45 <lambdabot>  The type variable ‘a0’ is ambiguous
13:56:45 <lambdabot>  Note: there are several potential instances:
13:56:45 <lambdabot>    instance GHC.Num.Num GHC.Types.Double
13:56:53 <benzrf> oh crud
13:57:02 <benzrf> curse my past sef
13:57:06 <pqmodn> sHead.sTail $ (3=:4=:SNil)
13:57:10 <pqmodn> > sHead.sTail $ (3=:4=:SNil)
13:57:12 <lambdabot>  4
13:57:35 <benzrf> @let sizedToList SNil = []; sizedToList (SCons h t) = h:t
13:57:36 <lambdabot>  .L.hs:205:20:
13:57:36 <lambdabot>      Couldn't match expected type ‘t’ with actual type ‘[t0]’
13:57:36 <lambdabot>        ‘t’ is untouchable
13:57:36 <lambdabot>          inside the constraints (t1 ~ S Void)
13:57:36 <lambdabot>          bound by a pattern with constructor
13:57:43 <benzrf> cant touch this
13:58:02 <benzrf> @let sizedToList SNil = []; sizedToList (SCons h t) = h:(sizedToList t)
13:58:03 <lambdabot>  .L.hs:205:20:
13:58:04 <lambdabot>      Couldn't match expected type ‘t’ with actual type ‘[t0]’
13:58:04 <lambdabot>        ‘t’ is untouchable
13:58:04 <lambdabot>          inside the constraints (t1 ~ S Void)
13:58:04 <lambdabot>          bound by a pattern with constructor
13:58:05 <benzrf> dang
13:59:03 <exicer> I have a datatype: data Test = Test1 | Test, and a list of [Test]. Can I reduce that list to just one Test somehow ?
13:59:03 <benzrf> :t \(SCons h t) -> h:(sizedToList t)
13:59:04 <lambdabot> Not in scope: ‘sizedToList’
13:59:18 <benzrf> :t fix \x (SCons h t) -> h:(x t)
13:59:19 <lambdabot> parse error on input ‘\’
13:59:23 <benzrf> :t fix $ \x (SCons h t) -> h:(x t)
13:59:24 <lambdabot>     Could not deduce (s ~ S s)
13:59:24 <lambdabot>     from the context (t1 ~ S s)
13:59:24 <lambdabot>       bound by a pattern with constructor
13:59:31 <benzrf> eeeh
13:59:47 <benzrf> :t let stl (SCons h t) = h:(stl t) in stl
13:59:48 <lambdabot>     Could not deduce (s ~ S s)
13:59:48 <lambdabot>     from the context (t4 ~ S s)
13:59:48 <lambdabot>       bound by a pattern with constructor
13:59:54 <corgifex> benzrf: please stop
13:59:56 <benzrf> i do not understand the issue, lambdabot
14:00:02 <benzrf> corgifex: soz
14:00:17 <corgifex> exicer: const [Test]
14:00:51 <exicer> corgifex: So I just apply const to the list ?
14:00:57 <corgifex> no
14:01:09 <exicer> :t const
14:01:10 <lambdabot> a -> b -> a
14:01:12 <corgifex> oh, maybe const Test
14:02:50 <benzrf> exicer: what do you mean by 'reduce it to one Test'
14:06:22 <exicer> benzrf: Well the datatype could be recursive, so I would like them to be "squashed together" into one
14:06:40 <jophish> Is there a near way of using V
14:06:43 <corgifex> Bool is not recursive
14:06:57 <corgifex> and your Test is isomorphic to Bool
14:07:01 <benzrf> corgifex++
14:07:11 <exicer> oops, it should be data Test = Test1 | Test Test
14:07:25 <benzrf> Test Test Test
14:07:25 <jophish> Is there a neat way of using Vinyl (or something like it) with Nats instead of Symbols for the record field tags?
14:07:30 <jophish> jonsterling: ^
14:07:33 <corgifex> ok, that's ~ [()]
14:07:43 <benzrf> exicer: that is just a natural number
14:07:46 <exicer> corgifex: What does that mean ?
14:07:49 <benzrf> exicer: *whole number
14:07:57 <benzrf> exicer: also known as a list of ()
14:08:09 <jophish> The motivation being describing vertices to OpenGL, where streams are numbered, rather than named
14:08:12 <exicer> Why is that a list of () ? I'm sorry, I don't understand :(
14:08:19 <benzrf> exicer:
14:08:34 <benzrf> data List a = Nil | Cons a List
14:08:36 <corgifex> exicer: because it's a list without real elements
14:08:49 <benzrf> data Test = Nil | Cons Test
14:08:54 <benzrf> when you rename the constructors
14:08:58 <jophish> Vinyl-gl names the attribute streams and requires the user to use named rather than numbered streams
14:09:00 <benzrf> exicer: making it a list without items
14:09:06 <benzrf> or put another way, a list of the same item
14:09:08 <jophish> It would be nice to be able to number them instead
14:09:42 <exicer> Hmm
14:10:09 <exicer> Okay, so the reason I'm doing this is for an attoparsec parser
14:10:25 <corgifex> the only real information stored in that structure is how many Tests you pass before reaching Test1
14:10:28 <corgifex> i.e. the length of the list
14:11:28 <benzrf> Test is isomorphic to (+1)
14:11:36 <benzrf> aka S
14:11:57 <exicer> I would like to be able to recursivley parse something
14:13:19 <bergey`> jophish: The parameters in your shaders don't have names?
14:13:43 <jophish> bergey`: the uniforms (usually) do. Vertex streams aren't often bound by name
14:13:59 <RedNifre> If guards are like a long if else chain, why would I ever use if and not always guards?
14:14:05 <Nik05> so im doing this exercise from CIS 194 and i want you to write an parse. The one i was talking about earlier. Can someone give me some advise on this? http://lpaste.net/5940055859039043584
14:14:11 <jophish> in (layout location=0) vec4 position; // for example
14:14:17 <Nik05> *a parse
14:14:35 <Nik05> *parser, sorry i should watch when to press return
14:14:39 <corgifex> Nik05: how much are you paying?
14:14:46 <Nik05> corgifex nothing :P
14:14:58 <corgifex> yeah, then you can do it yourself
14:15:16 <Nik05> do what myself?
14:15:19 <Krakarn> can I define a function a -> b in terms of another function a -> a?
14:15:28 <corgifex> Nik05: write a parser
14:16:05 <Nik05> well i already wrote something. Just wanted to know if im in the right way of writing haskell programs
14:16:18 <Nik05> and how to correctly use read or not use read
14:16:28 <corgifex> except what you said was "I want you to write a parser"
14:16:51 <Nik05> sorry typos... it wants you to write a parser
14:18:42 <corgifex> you shouldn't use unwords
14:18:57 <corgifex> > unwords (words "a                  b")
14:18:59 <lambdabot>  "a b"
14:19:00 <corgifex> not the same string
14:19:04 <ski> Krakarn : you need to specify more context
14:19:39 <Krakarn> ski: I want my function a -> b not necessarily return a different type
14:19:53 <Krakarn> is that not possible?
14:19:55 <corgifex> @hoogle readMaybe
14:19:57 <lambdabot> Data.Graph.Inductive.Internal.Thread threadMaybe :: (i -> r -> a) -> Split t i r -> SplitM t j i -> SplitM t j a
14:19:57 <lambdabot> Data.Graph.Inductive.Internal.Thread threadMaybe' :: (r -> a) -> Split t i r -> Split t j (Maybe i) -> Split t j (Maybe a)
14:20:02 <corgifex> :-(
14:20:28 <ski> Krakarn : still too vague a question :/
14:20:36 <Nik05> ah right corgifex guess i need to rewrite it completly
14:20:37 <ski> Krakarn : what are you trying to do ?
14:21:11 <ski> (Krakarn : or, if you prefer, you could ask in #haskell.se, though there's not as many others in there which might otherwise barge in and help as well)
14:21:40 <Nik05> ah corgifex when i give parseMessage an argument i can ofcourse just use that too in the helper function
14:21:56 <corgifex> right
14:22:51 <yaymukund> is there a strong convention for naming "private" methods in haskell? for instance, isprime_ in this example: http://stackoverflow.com/a/1140825/1207223
14:23:50 <enthropy> having a separate module called Foo.Internal is probably the stronger convention
14:23:50 <hpc> you would probably use isPrime' instead
14:24:00 <hpc> or an internal module
14:24:07 <corgifex> "isPrime prime"
14:24:30 <hpc> > let isPrime prime = True in isPrime 2 -- it works!
14:24:32 <lambdabot>  True
14:25:11 <yaymukund> oo, I've seen the tick' before in examples
14:25:21 <yaymukund> well, I"m literally doing euler so I don't want to get fancy just yet
14:25:29 <yaymukund> doing euler problems*
14:25:31 <yaymukund> heh
14:26:03 <yaymukund> enthropy, hpc, corgifex: thanks!
14:28:07 <yitz> yaymukund: adding primes to variable names isn't considered fancy. it's done constantly.
14:28:26 <yitz> yaymukund: whereas in the middle of variables is less common, even though allowed.
14:28:32 <juliohm> Is there any program that can be implemented in Lisp that cannot in Haskell? I'm watching some lectures on Lisp programming and they talk a lot about "creating new languages", I can't see how it is different than pattern matching in Haskell.
14:28:42 <corgifex> isPrime prime prime' = isPrime' prime' prime
14:28:45 <corgifex> well that's not confusing at all
14:28:56 <geekosaur> juliohm, no
14:29:06 <yitz> > let don't = False in don't
14:29:08 <lambdabot>  False
14:29:09 <Nik05> ok thank you corgifex i will try to rewrite it :)
14:29:20 <yaymukund> yitz: no, I meant splitting things up into modules
14:29:29 <corgifex> juliohm: in theory, all languages are computationally equivalent
14:29:31 <juliohm> geekosaur, so Lisp has nothing special as people usually say?
14:29:37 <yaymukund> yitz: I went with appending  a prime
14:29:38 <geekosaur> and sounds like they're just talking about DSLs, which Haskell excels at
14:29:49 <yitz> yaymukund: oh that. right, that's mainly for published libraries. i wouldn't bother with that for euler.
14:29:51 <corgifex> in practice, languages differ a lot
14:29:54 <geekosaur> Lisp's schtick is that its source form is the same as its abstract syntax tree
14:30:00 <juliohm> I heard Lisp is one of the most powerful languages out there because of a feature for creating new languages
14:30:03 <yaymukund> yitz: :D
14:30:12 <corgifex> juliohm: that's just macros
14:30:21 <Fuuzetsu> can I have something like Map C (Lens' A B) or even [Lens' A B] without ImpredicativeTypes?
14:30:22 <geekosaur> on the one hand, this does make some things easier
14:30:33 <geekosaur> on the other, people do not think int erms of abstract syntax trees
14:30:38 <juliohm> corgifex, that's exactly what I thought
14:31:03 <juliohm> geekosaur, could you please elaborate?
14:31:27 <corgifex> they don't?
14:31:42 <geekosaur> I grant that *you* might
14:31:43 <exicer> corgifex: bergey` I'm trying to do something similar to this: https://stackoverflow.com/questions/6404788/making-attoparsec-parsers-recursive
14:32:09 <exicer> The first answer suggests that it is possible to do [Expression] -> Expression
14:32:19 <exicer> Is this not the same as what I was suggesting? Any if not, why ?
14:32:55 <juliohm> corgifex, I don't know the formal definitions of lambda calculus, I don't know how macros and pattern matching differ, if at all
14:33:03 <juliohm> For me, all look the same
14:33:09 <corgifex> exicer: that completely depends on the definition of Expression
14:33:27 <corgifex> juliohm: I don't see what macros have to do with pattern matching
14:33:32 <exicer> corgifex: Ah, you are right - it is data Expression = ConsExpr Expression Expression | EmptyExpr
14:33:56 <corgifex> exicer: i.e. Tree ()
14:34:13 <juliohm> corgifex, in C we write #define FOO BAR and then the preprocessor matches FOO and replaces by BAR
14:34:19 <exicer> corgifex: ..yeah that makes sense
14:34:20 <juliohm> it's sort of pattern matching no?
14:34:23 <exicer> corgifex: Oops
14:34:25 <corgifex> juliohm: not at all
14:34:42 <juliohm> a limited matching I agree
14:34:50 * hackagebot stm 2.1 - Software Transactional Memory  http://hackage.haskell.org/package/stm-2.1 (HerbertValerioRiedel)
14:34:50 <juliohm> It doesn't work as regexps
14:34:54 <corgifex> juliohm: that's a completely different meaning of "pattern matching"
14:35:04 <corgifex> also of macros
14:35:15 <juliohm> corgifex, what is the meaning of pattern matching you have in mind?
14:35:30 <enthropy> Fuuzetsu: make a  Map C (ALens' A B)  instead
14:36:12 <corgifex> juliohm: the standard haskell/ML meaning, inspecting and destructuring values of algebraic data types
14:36:30 <juliohm> anyways, they all look very similar to me
14:36:46 <juliohm> and till now, Lisp has nothing special as a language
14:36:57 <corgifex> except for macros
14:36:59 <blaenk> is there a bot command to rewrite function composition with explicit lambdas?
14:37:07 <corgifex> @do f . g
14:37:08 <lambdabot> f . g
14:37:09 <juliohm> corgifex, what is special about Lisp macros?
14:37:12 <ski> @unpl f . g
14:37:13 <lambdabot> (\ c -> f (g c))
14:37:19 <ski> @help unpl
14:37:19 <lambdabot> pointful <expr>. Make code pointier.
14:37:22 <blaenk> thanks
14:37:32 <blaenk> @do fmap . const
14:37:33 <lambdabot> fmap . const
14:37:49 <blaenk> @unpl fmap . const
14:37:49 <lambdabot> (\ d -> fmap (\ _ -> d))
14:38:23 <ski> it decided to unfold the `const' application as well
14:38:27 <corgifex> juliohm: Perl source filters work on the character stream level. C macros work on tokens (and they're very limited: they basically replace a sequence of tokens by another sequence of tokens). Lisp macros are full Lisp functions that transform syntax trees into other syntax trees
14:38:52 <juliohm> interesting
14:39:12 <blaenk> yeah that's what I was thinking it'd be thought of as, the multiple arguments with function composition tripped me up though
14:39:32 <blaenk> is there a section in the manual I can read about the rules for that? that is, what happens when you use function composition and it takes two arguments
14:39:46 <blaenk> so for example, (<$) :: a -> f b -> f a, for (<$) = fmap . const
14:39:50 * hackagebot stm 2.1.1.0 - Software Transactional Memory  http://hackage.haskell.org/package/stm-2.1.1.0 (HerbertValerioRiedel)
14:39:50 <ski> juliohm : MetaML and MetaOCaml also allows one to operator on syntax trees (but in a typed setting. it is impossible to write code that generates type-incorrect code)
14:39:52 <juliohm> corgifex, and what is the advantage of such macros? Any example?
14:39:52 <corgifex> blaenk: every function takes exactly one argument
14:39:52 * hackagebot stm 2.1.1.2 - Software Transactional Memory  http://hackage.haskell.org/package/stm-2.1.1.2 (HerbertValerioRiedel)
14:40:00 <qrada> hey, wondering if I can use parsec's language/token modules via ByteString.. everything is defined as String inside of Text.Parsec.Token and Text.Parsec.Language etc. OverloadedStrings shouldn't be able to 'override' that right? any idea on how I could use parsec's language module with ByteStrings?
14:40:07 <blaenk> so right there, how would I know that the first argument applies to const, but then the second doesn't also apply to const? I mean, const does take two arguments no?
14:40:25 <ski> juliohm : macros that operate on characters or tokens are very brittle
14:40:26 <juliohm> ski, corgifex , what Lisp macros can do that Haskell cannot?
14:40:42 <benzrf> juliohm: TH that doesnt suck
14:40:42 <benzrf> ;)
14:40:43 <corgifex> Haskell has "macros" in the form of Template Haskell
14:40:50 <ski> juliohm : with Lisp macros, you can define new binding forms
14:41:12 <blaenk> to rephrase, in fmap . const, it takes two arguments, why aren't both apply to const? instead it seems const gets one, and then the next argument is for fmap
14:41:29 <blaenk> that's what I would expect, but I'm not sure what the rules are that dictate this
14:41:34 <ski> @src (.)
14:41:35 <lambdabot> (f . g) x = f (g x)
14:41:35 <lambdabot> NB: In lambdabot,  (.) = fmap
14:41:49 <ski>   (fmap . const) x = fmap (const x)
14:41:55 <juliohm> Thanks ski benzrf corgifex , I'll read about Template Haskell
14:42:06 <corgifex> juliohm: http://www.gigamonkeys.com/book/macros-standard-control-constructs.html http://www.gigamonkeys.com/book/macros-defining-your-own.html
14:42:08 <juliohm> benzrf, Template Haskell sucks?
14:42:11 <blaenk> thanks ski, I'll analyze that a bit
14:42:28 <juliohm> It sucks as much as C++ templates?
14:42:35 <ski>   (fmap . const) x y = ((fmap . const) x) y
14:42:37 <corgifex> it's unrelated to C++ templates
14:42:38 <ski>                      = ((fmap . const) x) y
14:42:40 <doomlord_1> not like c++ templates
14:42:44 <ski>                      = (fmap (const x)) y
14:42:47 <ski>                      = fmap (const x) y
14:42:48 <doomlord_1> they should call it 'macro haskell'
14:42:51 <blaenk> perfect, thanks ski!!!
14:42:56 <ski> (sorry, accidentally repeated one step)
14:43:16 <blaenk> yep noticed. thanks again
14:43:17 <corgifex> blaenk: the most important thing is: f x y = (f x) y
14:44:51 * hackagebot stm 2.1.2.0 - Software Transactional Memory  http://hackage.haskell.org/package/stm-2.1.2.0 (HerbertValerioRiedel)
14:44:58 <blaenk> yeah, thanks, I should've just regrouped the composition like ski did, but forgot to
14:45:07 <ski> juliohm : template Haskell has a somewhat unwieldy feel
14:45:09 <julianb> Hi!. I currently have a few typeclasses, and I'd like to keep a list of data types implementing that type class (in the same way you would with OOP). Reading on the subject, it seems people go for existential quantification; however, I'd like to avoid doing that, is there any way to do so?
14:45:24 <ski> blaenk : anyway, every function in haskell always takes exactly one argument
14:45:51 <blaenk> yep, I know that, it's just I had to see it regrouped like you did it to realize which functions were getting the arguments
14:45:51 <ski> juliohm : a list of data types or a list of values of some various data types ?
14:46:08 <julianb> ski, a list of values of some various data types, actually
14:46:20 <monochrom> I would use existential quantification, or no type class at all
14:46:58 <ski> juliohm : the alternatives to existential quantification are "closures", and, to a lesser extent, sum types
14:47:11 <juliohm> I think I'm not prepared to absorb such concepts yet, but I'll revisit them in the future
14:47:17 <ski> er
14:47:21 <ski> julianb ^
14:47:22 <julianb> I've thought about the no type class at all idea, but the problem is that one type could instance multiple typeclasses, and I'd like to avoid having maybes around
14:47:32 <enthropy> @let showableList :: [ (( forall a. Show a) -> r) -> r ]; showableList = [\k -> k 'a', \k -> k (), \k -> k "k"]
14:47:33 <lambdabot>  .L.hs:191:31:
14:47:33 <lambdabot>      Expected a type, but ‘Show a’ has kind ‘Constraint’
14:47:33 <lambdabot>      In the type signature for ‘showableList’:
14:47:33 <lambdabot>        showableList :: [((forall a. Show a) -> r) -> r]
14:47:38 <ski> juliohm : sorry, my remark above wasn't intended for you
14:47:50 <enthropy> @let showableList :: [ (forall a. Show a => a -> r) -> r ]; showableList = [\k -> k 'a', \k -> k (), \k -> k "k"]
14:47:51 <juliohm> ski, no problem :)
14:47:51 <lambdabot>  .L.hs:191:17:
14:47:51 <lambdabot>      Illegal polymorphic or qualified type: forall a. Show a => a -> r
14:47:51 <lambdabot>      Perhaps you intended to use ImpredicativeTypes
14:47:51 <lambdabot>      In the type signature for ‘showableList’:
14:47:51 <lambdabot>        showableList :: [(forall a. Show a => a -> r) -> r]
14:48:00 <monochrom> I do not understand "one type could instance multiple typeclasses", especially when there is no typeclass.
14:48:19 <ski> julianb : i can't follow your reasoning there
14:48:30 <ski> julianb : please provide more context
14:48:58 <monochrom> @quote monochrom river
14:48:59 <lambdabot> monochrom says: You are to send a boolean, a character, and an integer across the river. The list for transporting across the river can hold 3 items, in fact any number of items you like, but they must all be of the same type. On the bright side, after crossing the river, the boolean, the character, and the integer need only be put on show. How
14:48:59 <lambdabot> many trips do you need? Solution: one trip, [show the_boolean, show the_character, show the_integer]
14:49:04 <doomlord_1> can template-haskell roll accessors for the same named field on different records (well the records would have to have the name prefixed)
14:49:27 <carter> doomlord_1: i think make classy in lens does that
14:49:39 <carter> @google makeclassy lens hackage
14:49:40 <lambdabot> http://hackage.haskell.org/package/lens-2.6/docs/Control-Lens-TH.html
14:49:40 <lambdabot> Title: Control.Lens.TH
14:49:51 * hackagebot d-bus 0.1.0 - Permissively licensed D-Bus client library  http://hackage.haskell.org/package/d-bus-0.1.0 (PhilippBalzarek)
14:50:03 <ski> julianb : that monochrom quote (and it's more complicated variants) are what i meant by the "closures" alternative
14:50:31 <julianb> well, I have a typeclass Source and RList, each of which providing methods for retrieving different data from the web. Now, I'd like to be able to have a data type WebsiteA which is a Source and a RList, and a data type WebsiteB which is only a Source, and be able to "search" them by type class
14:50:45 <corgifex> why have typeclasses?
14:51:10 <ski> what do you mean by "\"search\" them by type class" ?
14:51:17 <julianb> well, because there might be some methods WebsiteB does not provide, but WebsiteA does
14:52:51 <julianb> ski, well, I want to poll every website which provides Source's methods, or I might want to poll every website which provides RList's methods
14:55:00 <Francis49> hello friends
14:55:09 <joelteon> can I get timing information from GHCi for how fast :r takes?
14:55:51 <jeroko> Hi, I'm trying to parse big binary files (dumps of a network protocol), which library do you recommend, Data.Binary.Get or Data.Attoparsec.Binary?
15:01:57 <benzrf> jeroko: parsing binary is like the definition of attoparsec
15:02:00 <benzrf> i am not sure what dbg is
15:02:44 <benzrf> jeroko: it looks like dbg is for very low level efficient imperative-ish parsing
15:02:47 <benzrf> from what i see
15:02:49 <RedNifre> So I'm reading about "let" in the "Learn you a Haskell" tutorial and it talks about variables. But aren't the things in let constants? I mean, they only get defined once in the bindings and don't seem to get changed after that...?
15:03:09 <benzrf> RedNifre: in haskell 'variables' just refer to bound names
15:03:09 <corgifex> RedNifre: that's what variables are :-)
15:03:13 <benzrf> they do not actually vary
15:03:17 <corgifex> consider a math
15:03:19 <benzrf> RedNifre: they are similar to variables in maths
15:03:21 <briennetheblue> it's variable in the maths sense of variable i.e. f(x) = blah blah
15:03:23 <corgifex> f(x) = 2 * x + 1
15:03:28 <RedNifre> Ah, I see. Thanks.
15:03:31 <corgifex> x doesn't change, but it's not a constant either
15:03:47 <RedNifre> Is there a math name for the imperative variables that change?
15:04:34 <monochrom> function
15:04:35 <corgifex> abomination
15:04:39 <yaymukund> lol
15:04:49 <Kaini> summation index? :P
15:04:53 * hackagebot mtl 2.0.0.0 - Monad classes, using functional dependencies  http://hackage.haskell.org/package/mtl-2.0.0.0 (HerbertValerioRiedel)
15:04:55 * hackagebot mtl 2.0.1.0 - Monad classes, using functional dependencies  http://hackage.haskell.org/package/mtl-2.0.1.0 (HerbertValerioRiedel)
15:05:09 <corgifex> nah, a summation index is still locally bound
15:05:23 <Kaini> hmm true
15:05:42 <yaymukund> I don't know of such variables in math
15:06:11 <yaymukund> though I am far from a mathematician
15:08:29 <ski> julianb : hm
15:09:54 * hackagebot mtl 2.1 - Monad classes, using functional dependencies  http://hackage.haskell.org/package/mtl-2.1 (HerbertValerioRiedel)
15:09:55 * hackagebot mtl 2.1.1 - Monad classes, using functional dependencies  http://hackage.haskell.org/package/mtl-2.1.1 (HerbertValerioRiedel)
15:10:10 <RedNifre> So pattern matching requires the function's name on every line and guards require a boolean, i.e. "== x" on every line. Is there something like Ruby's hash where I can define a hashmap easily? Or maybe something like a select case statement?
15:10:59 <monochrom> there is a "case" expression. I don't understand what is hashmap doing in this question.
15:11:49 <monochrom> "f [] = 0; f (x:xs) = 1" is sugar for "f y = case y of {[] -> 0; x:xs -> 1}".
15:12:09 <corgifex> which is sugar for f = \y -> case y of [] -> 0; x : xs -> 1
15:12:16 <yaymukund> if I have a haskell program `maximum (take 10000 [1,3..])`. In a language like ruby, I'd be able to do this without ever holding more than two integers in memory (the max and the number I'm currently checking). is that also how the haskell version works?
15:12:20 <corgifex> it's sugarcubes all the way down
15:12:45 <monochrom> yes
15:13:04 <corgifex> @src maximum
15:13:05 <lambdabot> maximum [] = undefined
15:13:05 <lambdabot> maximum xs = foldl1 max xs
15:13:11 <yaymukund> oo
15:13:15 <corgifex> is that strict enough?
15:13:18 <yaymukund> lovely
15:13:45 <yaymukund> corgifex: thanks. never thought of reading the source. that makes it pretty clear
15:14:05 <corgifex> be careful; @src is not the real source
15:15:05 <ski> RedNifre : pattern matching does not require boolean guards
15:15:21 <RedNifre> ski right, but pattern matching requires the function's name on every line
15:15:26 <corgifex> yeah, but guards require a boolean
15:15:29 <ski> no, not if you use `case'
15:15:57 * ski considers the repeating of the function name a feature, not a bug
15:16:09 <RedNifre> that's why I asked and monochrom already pointed that out, I'm reading about it right now :)
15:17:12 <ski> corgifex : "variable" vs. "constant" in math is a bit of a strange distinction
15:17:30 <ski> julianb : you need to store somewhere the information about who provides what
15:17:35 <shachaf> I,I variable function
15:18:05 * ski sees it like more of a spectrum than like a binary distinction
15:19:27 <julianb> ski, exactly. I'd like to have multiple lists with who provides what. The problem with using a data type is that I would need to use Maybe in pretty much every field of the value constructor
15:19:39 <RedNifre> Huh. So "otherwise" in guards is just True... then why can I use otherwise in a case string of where it seems to mean "any other string"?
15:20:13 <corgifex> RedNifre: because it's just a random identifier that gets bound to a value in a pattern
15:20:17 <ski> julianb : perhaps you could use a GADT ..
15:20:29 <corgifex> > case 21 of print -> print * 2
15:20:31 <lambdabot>  42
15:20:39 <ski> RedNifre : in a `case', `otherwise' is just a locally bound variable name, see what corgifex said
15:20:40 <corgifex> (this is not the print function)
15:21:09 <ReinH> > case Nothing of foo -> foo -- RedNifre
15:21:11 <lambdabot>  Nothing
15:21:15 <julianb> ski, how so?
15:21:24 <ReinH> > case Nothing of otherwise -> otherwise -- same thing
15:21:26 <lambdabot>  Nothing
15:21:28 <monochrom> RedNifre: "otherwise" is not a reserved word. it is an identifier.
15:21:33 <RedNifre> ah, so my code is accidentally correct? :)
15:21:40 <corgifex> yes
15:21:40 <ReinH> you are defining an identifier called "otherwise", not using the one already defined
15:21:54 <corgifex> if you're not using the name, consider _ instead
15:22:46 <RedNifre> Go has this feature that it won't compile if you have unused variables. Is there a compiler flag for that in Haskell?
15:22:50 <zwer> > case 2 of { 1 -> "one"; _ -> "not one" }
15:22:51 <lambdabot>  "not one"
15:23:06 <shachaf> GHC has a warning for it.
15:23:12 <shachaf> You can get all warnings with -Wall
15:23:18 <monochrom> not for haskell. for a specific compiler such as ghc
15:23:53 <RedNifre> I'm currently doing everything in ghci which just loads "OK" without warning.
15:24:12 <ski> julianb : maybe something like `data SiteCapability :: * -> * where HasSource :: Source a => SiteCapability a; HasRList :: RList a => SiteCapability a', and then use a list of type `[exists a. (a,[SiteCapability a])]' or something like that
15:25:37 <ski> julianb : then if you match on a value `HasSource' in that list, then you (and the type checker) knows that you can apply methods from `Source' to the value of type `a'
15:26:08 <julianb> ski, hey, that's a good idea!. I'll look more into it
15:26:18 <julianb> thanks a lot
15:26:39 <ski> julianb : i'm not sure whether it fits your situation (since i'm not quite sure about yuor requirements). but it's perhaps an idea to look into
15:27:21 <dmj`> RedNifre: try running "ghci -Wall"
15:28:44 <RedNifre> dmj Thanks. Also, you can change in in ghci with :set -Wall or :set -w
15:29:24 <ski> RedNifre++
15:29:45 <ski> for telling others the answer to a question you figured out yourself, but which might not be that obvious
15:29:56 * hackagebot Bang 0.1.0.6 - A Drum Machine DSL for Haskell  http://hackage.haskell.org/package/Bang-0.1.0.6 (5outh)
15:30:07 <ski> @karma RedNifre
15:30:07 <lambdabot> RedNifre has a karma of 1
15:30:28 <ski> @help karma+
15:30:28 <lambdabot> karma+ <nick>. Increment someone's karma
15:31:33 <RedNifre> Thank you!
15:31:52 <RedNifre> Did you increment my karma twice? Was I at -1 before?
15:32:26 <RedNifre> Ah, I guess ++ is just a shortcut for karma+
15:33:13 <RedNifre> For a beginner like me, I guess it's best to go with -Wall for a while... or are there any warnings that should only be read in very special cases?
15:33:24 <drupzky> Hi, can you please tell me how can I do that ideomatically? http://pastebin.com/CmYk1zcX
15:33:44 <ski> it's a shortcut, yes
15:33:56 <drupzky> branching on multiple boolean expressions without nesting ifs
15:34:47 <ReinH> RedNifre: you might try hlint as well
15:34:53 <platz> RedNifre: can you case on the expression 'a < b'
15:35:27 <platz> ah but that doesn't take care of the == case
15:35:32 <drupzky> yes....
15:35:33 <ski> drupzky : instead of `c' you can use `()'
15:35:33 <whaletechno> drupzky: use compare
15:35:38 <ski>   case a `compare` b of
15:35:40 <ski>     GT -> Do Something
15:35:45 <ski>     LT -> Do Something Else
15:35:48 <drupzky> ahh
15:35:49 <ski>     EQ -> Do something completely different
15:35:52 <drupzky> yes ski
15:35:53 <whaletechno> das it
15:35:56 <drupzky> thank you, didn't think of that
15:36:59 <drupzky> but anyway, there is not something like as case', which would expect Boolean expressions right where the normal case expects a pattern match or is there?
15:38:08 <coppro> s/win 13
15:38:50 <corgifex> drupzky: http://www.haskell.org/ghc/docs/latest/html/users_guide/syntax-extns.html#multi-way-if
15:39:01 <ski> drupzky : as i said, i tend to use `case () of () | ... -> ... | ... -> ...' in that case
15:39:15 <ski> (or `_' instead of the latter `()', in case you prefer)
15:39:30 <joelteon> so do I have to actually build an executable with profiling to get it to use multiple cores?
15:39:34 <joelteon> does that have any kind of performance overhead?
15:39:53 * ski hasn't tried multi-way-`if'
15:40:25 <corgifex> joelteon: no, yes
15:40:37 <joelteon> ok, so +RTS -N isn't necessary?
15:40:49 <RedNifre> platz what do you mean?
15:41:03 <hpc> you just need to compile with -threaded
15:41:12 <corgifex> joelteon: what?
15:41:19 <joelteon> oh, -threaded
15:41:21 <joelteon> duh.
15:41:26 <platz> RedNifre: nvm, ski gave the answer I was looking for
15:41:27 <joelteon> haha ok, never mind me
15:42:04 <hpc> joelteon: you might want to try installing the output of ghc-man-completion
15:42:11 <hpc> it's quite handy for getting compilation arguments right
15:43:37 <drupzky> corgifex: Thank you
15:43:41 <drupzky> ski: thank you too :)
15:45:00 <ReinH> ski: also there's multiway if, or just writing another function with guards
15:47:23 <dreams> What is a good book on denotational semantics? (That uses lambda or typed lambda)
15:49:55 <_deepfire> how does one debug emacs+ghc-mod not picking up .cabal component version information ?
15:50:11 <ski> dreams : you could perhaps also try asking in #coq ior #agda
15:50:21 <dreams> ski: thanks.
16:03:17 <nemesist> hi, how come this doesn’t work if ‘a’ is Floating (says I need to put Eq)? let lucky7 :: (Integral a) => a -> String; lucky7 7 = “yea”; lucky7 _ = "nah"
16:05:38 <dfranke> nemesist: it needs an Eq instance to determine whether the "7" pattern matches.
16:06:41 <nemesist> dfranke: oh ok, so if I want to pattern match an object It needs to be be in Eq?
16:07:28 <dfranke> nemesist: some yes, some no, but numbers yes.
16:08:54 <nemesist> dfranke: so Integral is a subclass of Eq, but Floating isnt’?
16:09:27 <dfranke> nemesist: correct.
16:09:33 <nemesist> ok thanks
16:10:00 * hackagebot syb 0.4.2 - Scrap Your Boilerplate  http://hackage.haskell.org/package/syb-0.4.2 (JosePedroMagalhaes)
16:10:08 <RedNifre> So, how long does it take before you can be productive in Haskell?
16:10:24 <dfranke> nemesist: however, all the Prelude instances of Floating are also instances of Eq.
16:11:01 <dfranke> nemesist: which, really, is an abuse. Floating point equality is not an equivalnce relation (NaN != NaN).
16:14:05 <Francis49> hello friends
16:14:09 <dmj`> RedNifre: http://stackoverflow.com/questions/1012573/getting-started-with-haskell
16:14:10 <dfranke> RedNifre: about a month. After that, your productivity will gradually drop off as you start spending all your time proving things in the type system rather than writing code that does things :-)
16:14:31 <Francis49> isomeane know how to install the gd library?
16:14:35 <ski> dreams : blame IEEE 754
16:14:51 <ski> er
16:14:54 <ski> dfranke ^
16:18:38 <Francis49> bye
16:23:39 <RedNifre> are partially applied functions a real thing, or are they more like a bookmark where computation only starts after you filled in all the blanks?
16:25:51 <RedNifre> Ah, way too late. Good night!
16:27:18 <_deepfire> RedNifre, computation certainly doesn't start earlier than its result is requested
16:28:06 <_deepfire> ..unless, that is, you specifically request eager evaluation
16:30:02 <RedNifre> But if the function is like this: bla a b c = if c==5 ... then the partially applied functions can't really do anything since everything depends on the last parameter...
16:30:44 <_deepfire> RedNifre, ah, so you mean eager partial evaluation
16:30:52 <enthropy> RedNifre: if you take "f x = let y = g x in \z -> z+y", and define "h = f 1", it'll (probably) share the (g 1)
16:31:19 <ski> RedNifre : note that "partial application" is distinct from "partial evaluation". "partial application" means that you apply a function to only some actual parameters, but not all; it doesn't entail any computation being done/shared before/between later applications supplying the remaining parameters
16:31:49 <ski> RedNifre : "partial evaluation" on the other hand is about simplifying partial applications (and other expressions) before knowing the values of all parameters
16:32:10 <RedNifre> ah, so "partial application" does actually really mean "sort of like a bookmark for a function where you have to fill the gaps before anything happens"
16:32:28 <ski> yes
16:32:32 <enthropy> but if you write  f x z = let y = g x in z+y, the (g 1) shouldn't be shared
16:32:39 <ski> if you define
16:32:47 <ski>   bla a b c = if c == 5 then ... else ...
16:32:50 <ski> then this is sugar for
16:32:56 <ski>   bla = \a b c -> if c == 5 then ... else ...
16:32:58 <ski> which is sugar for
16:33:06 <ski>   bla = \a -> \b -> \c -> if c == 5 then ... else ...
16:33:31 <ski> and so `bla 3' will evaluate to `\b c -> if 3 == 5 then ... else ...'
16:33:43 <RedNifre> I didn't learn \ yet, what's that?
16:34:18 <ski> er, actually i mixed up your `a' and `c'
16:34:27 <ski> if we assume you had said instead
16:34:33 <ski>   bla a b c = if a == 5 then ... else ...
16:34:53 <ski> then `blah 3' will evaluate to `\b c -> if 3 == 5 then ... else ...', as i said
16:34:57 <ski> (or perhaps it's nicer to think of it as evaluating to `let a = 3 in \b c -> if a == 5 then ... else ...')
16:35:25 <ski> RedNifre : `\x -> ..x..' means : the function (value) that, *when* given an argument (call it `x'), computes `..x..'
16:35:38 <ski> RedNifre : so \x -> x^2' e.g. is the squaring function
16:36:05 <ski> > let square x = x^2 in [square x | x <- [0 .. 9]]
16:36:07 <lambdabot>  [0,1,4,9,16,25,36,49,64,81]
16:36:12 <ski> > let square x = x^2 in map square [0 .. 9]
16:36:14 <lambdabot>  [0,1,4,9,16,25,36,49,64,81]
16:36:21 <ski> > let square = \x -> x^2 in map square [0 .. 9]
16:36:23 <lambdabot>  [0,1,4,9,16,25,36,49,64,81]
16:36:32 <ski> > map (\x -> x^2) [0 .. 9]
16:36:34 <lambdabot>  [0,1,4,9,16,25,36,49,64,81]
16:36:49 <RedNifre> does \ mean something like an anonymous function, similar to the blocks in ruby?
16:37:16 <ski> > map f [a,b,c]        :: [Expr]
16:37:18 <lambdabot>  [f a,f b,f c]
16:37:25 <ski> > map (\x -> x + 2) [a,b,c]        :: [Expr]
16:37:27 <lambdabot>  [a + 2,b + 2,c + 2]
16:37:32 <ski> RedNifre : yes
16:38:08 <RedNifre> All this is extremely fascinating. :)
16:38:08 <ski> `\x -> x^2' would sometimes be known as an "anonymous function", just like `[0,1,2,3]' could be known as an "anonymous list"
16:38:29 <ski> values do not necessarily have to be named
16:38:33 <ski> and functions are values
16:38:56 <ski> sometimes a value is known under one name in one part of the program, and under another name in another part
16:38:58 <RedNifre> but how does \ differ from let?
16:39:14 <ski> therefore it doesn't, in *general*, make sense to ask "what's the name of this function ?"
16:39:23 <ski> `\x -> x^2' is an expression
16:39:59 <ski> in `let square = \x -> x^2 in ..square..' (as well as in `let square x = x^2 in ..square..'), the part between the `let' and the `in' is a declaration
16:40:10 <_deepfire> RedNifre, let binds values to the names, lambda does not
16:40:21 <RedNifre> ah, okay.
16:40:22 <ski> yes
16:40:45 <_deepfire> let x = 1 in x + x === (\ x -> x + x) 1
16:40:57 <ski> `\' ("lambda") specifies a name that a value may *later* (when the function value is applied) be bound to
16:41:31 <RedNifre> So, with normal functions I can fill in the parameters from left to right and by writing it as (`bla` second) I can leave the first parameter open... can I set arbitrary parameters? Like bla ? 2 ? 4 5 ? ?
16:41:32 <ski> so it decouples the naming from the providing of the value
16:42:15 <ski> this also means that, since you can apply the function (value) multiple times, to possible distinct values, the name (above `x') may (in each of these distinct applications) stand for *different* values
16:42:31 <ski> hence `x' is called a "variable", since the values it *may* be bound to can vary
16:42:52 <ski> (also note that variable binding has nothing to do with assignment)
16:43:13 <RedNifre> and what's the ===? I think I heard that Haskell doesn't distinguish between equals and identity?
16:43:24 <ski> RedNifre : you can use `\a b c d -> bla a 2 b 4 5 c d' :)
16:43:34 <_deepfire> it was my silly way of describing equivalence
16:43:41 <_deepfire> not valid Haskell
16:43:42 <ski> RedNifre : `===' is just _deepfire's way of writing `=', meaning "is equal to"
16:44:34 <_deepfire> equality is not the same as equivalence, which I meant to imply
16:44:44 <RedNifre> if functions in haskell don't get redefined, why aren't they declared with ==? As in "I only write true things in my source file, so this function is really this"?
16:44:48 <ski> then what did you mean by "equivalence", here ?
16:45:25 <_deepfire> a higher kind of sameness than merely value equality
16:45:33 <RedNifre> ah, the === didn't refer to the output of the statement, it refered to the source code, right?
16:45:38 <_deepfire> yes
16:45:43 <ski> RedNifre : `==' means "compute a boolean value expressing whether two values are equal". `=' means "two things are claimed to be equal"
16:46:01 <_deepfire> ski, structural equivalence, if you wish
16:46:07 <ski> _deepfire : i don't follow
16:46:39 <ski> by "higher" perhaps you mean "coarser" or maybe otherwise "finer" ?
16:47:25 <_deepfire> ski, basically, the kind of equivalence that allows a compiler is freely allowed to rewrite one form into another, generally
16:47:41 <_deepfire> a botched sentence, but you get the idea
16:47:44 <ski> (or maybe you want to make the distinction between things that are extensionally equal, and things that can be finitely *proved* to be so .. ?)
16:47:57 <RedNifre> I'm not convinced. If there are no "variables" in the sense of things that change value later, it seems fine to use == everywhere.
16:48:46 <ski> RedNifre : in Haskell source `... == ...' is an expression, while `... = ...' is a declaration. they belong to different syntactic categories
16:49:07 <ski> RedNifre : while it would be possible to write both with `=' (as SML does), they would still mean different things
16:49:07 <_deepfire> ski, yes, extensionality was what I had in mind
16:49:22 <RedNifre> But how are those different syntactic categories in a language that doesn't have mutable state?
16:49:23 <ski> RedNifre : .. otoh, in Mercury, `=' *is* used for both, and *does* mean the same thing
16:49:37 <ski> RedNifre : i don't understand
16:49:54 <ski> _deepfire : extensionality as opposed to what ?
16:49:57 <RedNifre> say I declare a function like bla == 5
16:50:04 <RedNifre> That is a boolean expression
16:50:06 <ski> (intensionality ?)
16:50:20 <ski> RedNifre : where is the function in there ?
16:50:45 <RedNifre> sorry, had to look something up
16:50:50 <_deepfire> ski, now you're basically sending me to google stuff : -)
16:51:02 <ski> _deepfire : is that a bad thing ? ;)
16:51:22 <_deepfire> ski, not at all, but it's nearing 4am over here : -)
16:51:35 <RedNifre> okay, better example: "fiveMore x == x + 5" (Instead of "fiveMore x = x + 5")
16:51:42 <RedNifre> Now, that's a boolean expression...
16:51:57 <RedNifre> also, I'm not a liar, so the compiler should trust me when I say that in my code.
16:52:40 <RedNifre> Now, when I write "fiveMore 2", the compiler could reason, that based on the axiom that "fiveMore x == x + 5", "fiveMore 2" must be 7.
16:52:50 <ski> RedNifre : yes, but allowing `let fiveMore x == x + 5 in ..fiveMore..' would suggest `let y > 2 && y < 3 in ..y..' would also be allowed, since `y > 2 && y < 3' is also a boolean expression
16:53:36 <ski> RedNifre : i'm not saying that what you're suggesting would be unthinkable (because logic programming languages does something like this), just that this is not how functional programming tends to function
16:53:38 <RedNifre> Sure, but the compiler could proove that you are lying.
16:53:46 <ski> lying ?
16:54:05 * ski was assuming `2' and `3' here could e.g. be floating-point numbers or rationals
16:54:06 <RedNifre> your later axioms are in contradiction to your earlier axioms.
16:54:34 <ski> (if you prefer, you may assume i had typed `y > 2.0 && y < 3.0' or `y > 2 && y < 7' instead)
16:55:05 * hackagebot matrix 0.3.3.0 - A native implementation of matrix operations.  http://hackage.haskell.org/package/matrix-0.3.3.0 (DanielDiaz)
16:55:22 <RedNifre> what I mean is, I completely understand the distinction of = and == in imperative languages where variables really do change. But I don't see how it's necessary in Haskell.
16:55:33 <ski> the point here is that `y' (if we take the last amendation) would be constrained to be one of the numbers between `2' and `7' (exclusively)
16:55:52 <RedNifre> oh sorry, I read it wrongly.
16:55:54 <ski> (if we assume we're talking about integers, then the possible values for `y' would be `3',`4',`5',`6')
16:56:20 <ski> so `y' would then not be completely determined, it would just be (partially) *constrained*
16:56:44 <ski> Constraint Logic Programming (a subparadigm of Logic Programming) can express things like these
16:57:16 <Cale> RedNifre: In Haskell, (==) is a function which tests two values for equality, producing a Boolean result, while = is not a function, it is part of the syntax of declarations.
16:57:21 <ski> but, in typical Functional Programming, variables have a completely determined value
16:58:04 <RedNifre> Cale I understand that.
16:58:27 <Cale> So, I'm not sure what you're confused about then :)
16:59:19 <ski> (also in Haskell, `(==)' isn't guaranteed by the Haskell language to compute equality, though the implied law / proof condition on the type class `Eq' does express that intent. otoh in Mercury the `=' predicate *is* guaranteed by the language to compute equality)
16:59:33 <Cale> Right
16:59:39 <RedNifre> ski In your example with let, y isn't defined completely. Or you could interpret as a range...
17:00:07 <ski> RedNifre : yes ?
17:00:11 <stephenmac7> Is it possible to catch an exception (like a ParseError from parsec) and return a predetermined value?
17:00:43 <Cale> RedNifre: Is your question about why it might be important to test things for equality at runtime at all?
17:00:45 <RedNifre> ski I'm not sure I understand what you mean with "let y > 2 && y < 3". Do you mean to define the value of y?
17:00:50 <RedNifre> Cale no.
17:01:26 <ski> RedNifre : since `let y > 2 && y < 3 in ..y..' evidently doesn't define/determine/pin down `y', it can't be used to define the value of `y', no
17:01:36 <ski> (and i didn't meant it to, either)
17:01:54 <RedNifre> ski what did you mean with that code?
17:02:27 <ski> RedNifre : the point is that `y > 2 && y < 7' is a valid boolean expression. if your boolean expression `fiveMore x == x + 5' is allowed after `let', then why wouldn't my one be ?
17:02:49 <ski> (RedNifre : that by the way isn't (necessarily ;) a rhethorical question)
17:02:56 <numberto> problem installing cabal-dev. I am on archlinux. Here is the error I get: http://pastie.org/9272029
17:03:35 <ski> RedNifre : i didn't mean anything in particular about the code, except to give an example with an ostensibly valid boolean expression after `let', but where it's perhaps not so clear how to evaluate the `let'-`in' expression
17:04:37 <RedNifre> Well, the part after let is there to name things that you want to use in the in part. In your example it doesn't name new things so it's useless to the in part?
17:05:05 <ski> RedNifre : yes, but how should that intuition be formalized in the language specification ?
17:05:40 <ski> not to mention, how should a language implementation (such as an interpreter or a compiler) be expected to check that
17:05:43 <ski> ?
17:05:44 <RedNifre> Ah, you mean it should not be possible to write statements that go to waste?
17:06:15 <ski> iow, how could an implementation detect which boolean expressions are allowable, and which aren't ?
17:06:55 <RedNifre> It doesn't really need to, it's already possible to write dead code, right?
17:07:09 <ski> separating out the syntactic class of (value) definitions out from propositions (which are not quite, but sortof, the same as boolean expressions) is one way to do this
17:07:52 <RedNifre> how are those not the same in Haskell, if you read function definitions as true statements?
17:08:01 <numberto> can somebody please explain how to install cabal-dev?
17:08:11 <ski> RedNifre : i don't follow. how would `let y > 2 && y < 7 in y*y' compute ? or otherwise, if the implementation doesn't allow it to be computed, then how would the implementation check that it shouldn't be allowed to be computed ?
17:08:56 <RedNifre> It simply returns y*y
17:09:18 <RedNifre> but y isn't defined in the let part, it's defined somewhere else
17:09:30 <ski> what does `if (let y > 2 && y < 7 in y*y) > 4 then "yes" else "no"' evaluate to ?
17:09:31 <RedNifre> If you only have that one statement the compiler should complain that y is undefined
17:09:39 <ski> ok
17:09:48 <ski> how should it determine when to complain ?
17:10:33 <RedNifre> example y = if(let... that's fine because y is defined as a paremeter
17:10:48 <RedNifre> example x = if(let... isn't because y is not defined.
17:12:08 <RedNifre> Do you understand what I mean?
17:13:38 <Cale> I don't! In particular, I'm really unsure what the evaluation mechanism for the language you're proposing would look like.
17:14:46 <RedNifre> Easy, in my source file, the boolean expressions that connect function names to function bodies are read as true axioms, while boolean expressions in if statements get evaluated.
17:14:46 <Cale> If you just have a bunch of Boolean expressions which are meant to be regarded as true, that doesn't give any sort of direction in which evaluation should proceed.
17:15:43 <ski> RedNifre : i think you might be interested to look into LP and CLP
17:16:00 <RedNifre> oneMore x == x + 1; if(oneMore 5 == 7) ... The first is read as a true statement, the second one gets checked.
17:16:13 <ski> .. and perhaps also Logic/Functional Programming, like Curry and Escher
17:16:29 <Cale> I would recommend implementing this language -- either it'll help you to explain to others what it is that you mean, or at least it'll help to understand what makes this sort of approach difficult.
17:17:22 <ski> RedNifre : btw, note that you really want something like `forAll (\x -> oneMore x == x + 1)', to be explicit, than the non-closed `oneMore x == x + 1'
17:17:59 <ski> (whether you have to explicitly write that in the source or not is irrelevant here. the point is that you *conceptually* have to think about such quantifiers)
17:18:16 <RedNifre> ski I don't understand, could you elaborate?
17:18:50 <Cale> RedNifre: How does your language know that x is not just some constant?
17:19:06 <ski> RedNifre : what Cale said
17:19:07 <Luke> what's the cabal channel again?
17:19:23 <RedNifre> Ah, good point :)
17:19:32 <Cale> (and we're simultaneously defining a property of x, a property of oneMore and a property of +)
17:19:53 <ski> (Cale : depends on how you look at it ;)
17:20:08 * hackagebot bus-pirate 0.5 - Haskell interface to the Bus Pirate binary interface  http://hackage.haskell.org/package/bus-pirate-0.5 (BenGamari)
17:20:45 <RedNifre> if x is defined as 4 somewhere else, oneMore 5 would be undefined... yes, I think I understand why `forAll (...' would be needed...
17:21:18 <Cale> RedNifre: Well, x might be defined by this statement, as the value for which oneMore x happens to be equal to x + 1
17:21:24 <RedNifre> ...and the shortcut for writing `forAll(\x...' would be "=" ;)
17:22:37 <RedNifre> ski, do you agree that `forAll (\x -> oneMore x == x + 1)' would be a valid way to get rid of "=" ?
17:22:55 <Luke> I want to have a cabal file with a library section and executable section but share the build-deps section. right now I have the build-deps in the library section and the executable section depends on the library section but it seems to want me to repeat all the build-deps in both. is there a wiki page which describes how to do this?
17:23:12 <Cale> RedNifre: It's still unclear that what you're writing there is meant to be used as a reduction rule
17:23:21 <ski> RedNifre : only if you can explain how to give a meaning to the former (in general, not just to that particular boolean expression) :)
17:23:34 <Cale> RedNifre: If I come across some expression later, such as 6 + 1, why not rewrite that into oneMore 6?
17:23:56 <Cale> Is == meant to be directional?
17:24:08 <RedNifre> no, you could declare functions in reverse
17:24:15 <RedNifre> x + 1 == oneMore x
17:24:32 <RedNifre> execution would be a lot like formal verification
17:25:01 <ski> RedNifre : again, you might be interested in looking into Logic Programming
17:25:09 * hackagebot pipes-interleave 0.2 - Interleave and merge streams of elements  http://hackage.haskell.org/package/pipes-interleave-0.2 (BenGamari)
17:25:15 <ski> RedNifre : there's e.g. ##prolog and #mercury on this network
17:25:19 <RedNifre> replacing 6 + 1 or even 7 with oneMore 6 doesn't get you anywhere so that path is not taken? Hm....
17:25:39 <dmj`> Luke: you cannot do that
17:25:42 <RedNifre> Thanks, I'll check them out later.
17:26:31 <dmj`> Luke: you must specify both, so your best bet is to re-export the imports from the library
17:26:54 <RedNifre> You could see "=" as a "==" with a hint added for the runtime that states "only reduce the left side to the right side, not the other way around"
17:27:00 <dmj`> Luke: every import must have a dependency associated with it
17:27:11 <Fuuzetsu> @hoogle fixM
17:27:11 <Fuuzetsu> where is fixM defined?
17:27:12 <Fuuzetsu> :t fixM
17:27:12 <lambdabot> No results found
17:27:13 <lambdabot>     Not in scope: ‘fixM’
17:27:13 <lambdabot>     Perhaps you meant ‘fix’ (imported from Data.Function)
17:27:18 <Cale> RedNifre: In Haskell, declarations are followed in a particular direction in an attempt to reduce expressions into what's called weak head-normal form, or WHNF. A term is in WHNF if it is either a lambda term, or it is a data constructor applied to some arguments.
17:27:49 <Fuuzetsu> hm, I swear it was just defined the other day
17:28:05 <benzrf> :t fix
17:28:06 <lambdabot> (a -> a) -> a
17:28:16 <Cale> RedNifre: The usefulness of having something in WHNF is that a case expression can match on it (in the case that it's a constructor), or the function can be immediately applied (in the case that it's a function)
17:28:16 <benzrf> hmm
17:28:23 <benzrf> @src fix
17:28:23 <lambdabot> fix f = let x = f x in x
17:28:29 <RedNifre> I'm afraid I'm too new to Haskell to understand that yet (started today). I'll copy&paste that one into my file of things to look up later :)
17:28:39 <benzrf> @let fixF f = let x = fmap f x in x
17:28:41 <lambdabot>  Defined.
17:28:42 <benzrf> eeh?
17:28:44 <benzrf> :t fixF
17:28:45 <lambdabot> Functor f => (a -> a) -> f a
17:28:48 <benzrf> oh wait
17:29:04 <benzrf> Fuuzetsu: what type would fixM have
17:29:27 <ctangent> would anybody recommend any interesting projects to do/look at for a haskell newbie?
17:29:28 <Cale> :t mfix
17:29:29 <lambdabot> MonadFix m => (a -> m a) -> m a
17:29:32 <benzrf> @let fixA f = let x = x >>= f in x
17:29:33 <lambdabot>  Defined.
17:29:34 <Fuuzetsu> oh it's mfix
17:29:36 <benzrf> oh wait derp
17:29:37 <benzrf> :t fixA
17:29:38 <lambdabot> Monad m => (a -> m a) -> m a
17:29:41 <benzrf> eeh
17:29:41 <Fuuzetsu> in Control.Monad.Fix
17:29:42 <RedNifre>  I'm fascinated by all this and will continue to learn Haskell. But, it's way too late already. Thank you very much for your help and have a good night :)
17:29:52 <bitemyapp> RedNifre: https://github.com/bitemyapp/learnhaskell
17:29:55 <bitemyapp> RedNifre: good luck :)
17:29:57 <bitemyapp> ddellacosta: hi
17:30:09 * hackagebot optimization 0.1.5 - Numerical optimization  http://hackage.haskell.org/package/optimization-0.1.5 (BenGamari)
17:30:11 <benzrf> @src mfix
17:30:11 <lambdabot> Source not found. Just what do you think you're doing Dave?
17:32:30 <benzrf> hnmmmmmmmm
17:32:30 <Fuuzetsu> why is LambdaCase so good
17:32:34 <benzrf> how could mfix be useful
17:32:37 <benzrf> Fuuzetsu: whats that
17:32:41 <Fuuzetsu> wow
17:32:54 <Fuuzetsu> how do you not know about LambdaCase our saviour benzrf
17:33:11 <Fuuzetsu> it lets you do stuff like foo >>= \case …
17:33:12 * benzrf cries in shame
17:33:17 <Fuuzetsu> instead of x ← foo; case x of …
17:33:24 <Fuuzetsu> also stuff like foo = \case …
17:33:28 <Fuuzetsu> instead of foo x = case x of …
17:33:30 <Fuuzetsu> and tons of stuff
17:33:34 <Fuuzetsu> it composes too!
17:33:35 <benzrf> o-O
17:33:37 <benzrf> neato
17:34:28 <benzrf> > fix (\x case 1 -> 1; n -> n * x (n - 1)) 3
17:34:30 <lambdabot>  <hint>:1:9: parse error on input ‘case’
17:34:33 <benzrf> eh
17:34:58 <benzrf> > fix (\x -> \case 1 -> 1; n -> n * x (n - 1)) 3
17:34:59 <lambdabot>  <hint>:1:13: parse error on input ‘case’
17:35:04 <Lutin`> > fix (\x -> case x of { 1 -> 1; n -> n * x (n - 1) }) 3
17:35:05 <lambdabot>  Occurs check: cannot construct the infinite type: t ~ a0 -> t
17:35:05 <lambdabot>  Relevant bindings include
17:35:05 <lambdabot>    n :: a0 -> t (bound at <interactive>:1:32)
17:35:05 <lambdabot>    x :: a0 -> t (bound at <interactive>:1:7)
17:35:06 <benzrf> well it works in ghci, you butt
17:35:10 * hackagebot wkt 0.2 - Parsers and types for Well-Known Text data  http://hackage.haskell.org/package/wkt-0.2 (BenGamari)
17:35:19 <benzrf> Lutin`: you miss the point ;)
17:35:33 <Lutin`> No I don't
17:35:41 <Lutin`> http://www.haskell.org/ghc/docs/7.6.1/html/users_guide/syntax-extns.html#lambda-case
17:35:57 <Lutin`> I doubt lambdabot has -XLambdaCase on
17:35:58 <Cale> > fix (\x -> \y -> case y of { 1 -> 1; n -> n * x (n - 1) }) 3
17:35:59 <ski> Fuuzetsu : it's sad that (afaiui) it has been present in the MLs from the start, but only recently added to Haskell :/
17:36:00 <lambdabot>  6
17:36:14 <Cale> Lutin`: You used the other lambda instead of adding a new one
17:36:20 <benzrf> Lutin`: enable ALL the exntsns!!!
17:36:22 <Lutin`> Cale: Oh derp
17:36:46 <benzrf> :i HasThisBeenTurnedOnYet
17:36:56 * benzrf whacks lambdabot's chassis
17:37:07 <ski> @info benzrf
17:37:08 <lambdabot> benzrf
17:37:21 <Lutin`> Modified wrong code :P
17:37:24 <benzrf> @info do ur mom
17:37:24 <lambdabot> ur mom
17:37:30 <Lutin`> Cale: Thanks for the catch
17:37:35 <Cale> benzrf: You mean, did anyone implement that yet?
17:37:42 <benzrf> Cale: ya
17:37:46 <bitemyapp> @info State
17:37:46 <lambdabot> State
17:37:48 <bitemyapp> hrm.
17:37:52 <benzrf> @info -> @undo
17:37:53 <lambdabot> <unknown>.hs: 1: 1:Parse error: ->
17:37:59 <benzrf> hence
17:38:01 <benzrf> @info do ur mom
17:38:01 <lambdabot> ur mom
17:38:07 <Luke> dmj`: the only import I have in the executable is the library i mentioned though cabal seems to be requiring me to bring in all the deps the library pulls in as well
17:38:09 <benzrf> :^)
17:38:37 <ski> @palomer
17:38:37 <lambdabot> Pfft
17:42:11 <benzrf> fix only works for recursion because of lazy eval right?
17:42:12 <benzrf> @palomer
17:42:12 <lambdabot> Blargh!
17:42:15 <benzrf> o_o
17:42:15 <benzrf> o_o
17:42:16 <benzrf> @palomer
17:42:17 <lambdabot> That's nuts!
17:42:23 <stepkut> I am making a quick and dirty console app under linux and need to track key_up versus key_down events -- what is a good choice of library ?
17:42:26 <benzrf> no lambdabot youre the one what is nuts
17:42:29 <stepkut> SDL seems like overkill.. vty maybe?
17:44:04 <ski> @help palomer
17:44:04 <lambdabot> palomer. Sound a bit like palomer on a good day.
17:44:28 * ski actually thought palomer was a nice (though perhaps sometimes a little grumpy) chap
17:44:44 <Cale> Yeah
17:45:06 <Cale> @keal
17:45:06 <lambdabot> evaluating expressions is ALL haskell does?????
17:45:09 <ski> (but then perhaps i tend to think that most people are mostly nice, at least in here, so perhaps my opinion doesn't really count)
17:45:24 <benzrf> hmm
17:45:28 <ski> benzrf : yes, but you can define a cbv `fix'
17:45:40 <benzrf> cbv?
17:45:44 <ski> call-by-value
17:45:47 <benzrf> oh
17:46:03 <ski>   fix f x = f (fix f) x
17:46:15 <ski> (doesn't really work for mutual recursion, though)
17:46:35 <benzrf> ski: how is that 'call by value'
17:46:45 <ski> by itself, it's not
17:47:00 <ski> but it will work in a cbv setting, while `fix f = f (fix f)' won't
17:47:01 <benzrf> > let fix f x = f (fix f) x in take 10 $ fix (1:)
17:47:03 <lambdabot>  Couldn't match expected type ‘[a]’ with actual type ‘t1 -> t0’Couldn't match...
17:47:03 <lambdabot>  Expected type: (t1 -> t0) -> t1 -> t0
17:47:03 <lambdabot>    Actual type: [a0] -> [a0]
17:47:08 <benzrf> lame!
17:47:11 <benzrf> > let fix f x = f (fix f) x in fix (1:)
17:47:12 <lambdabot>  Couldn't match type ‘[a0]’ with ‘t1 -> t’
17:47:12 <lambdabot>  Expected type: (t1 -> t) -> t1 -> t
17:47:13 <lambdabot>    Actual type: [a0] -> [a0]
17:47:14 <benzrf> eh.
17:47:19 <ski> (obviously this `fix' doesn't work for non-functions)
17:47:27 <benzrf> :t let fix f x = f (fix f) x in fix
17:47:28 <lambdabot> ((t1 -> t) -> t1 -> t) -> t1 -> t
17:47:33 <benzrf> :t fix
17:47:34 <lambdabot> (a -> a) -> a
17:47:36 <benzrf> tsk
17:47:58 <benzrf> ok so anyway
17:48:08 <benzrf> i was thinking of how a reactive server could work
17:48:22 <bitemyapp> benzrf: reactive isn't well defined.
17:48:26 <benzrf> FRP ;p
17:48:33 <benzrf> in the style of reactive-banana
17:48:40 <bitemyapp> there we go.
17:48:41 <benzrf> if you wanna get specific
17:48:58 <benzrf> i was pondering how response routing could work
17:49:21 <benzrf> hmmm
17:49:24 <benzrf> maybe something like
17:49:33 <benzrf> Event of requests incoming
17:49:40 <benzrf> no wait
17:49:52 <benzrf> Event (source, req)
17:50:08 <benzrf> then have something like
17:50:16 <benzrf> respond = fmap . first
17:50:26 <benzrf> and you get an Event (dest, resp)
17:50:35 <benzrf> assuming respond is a function from req -> resp
17:50:50 <benzrf> better yet, have a Behavior (req -> resp) and use that
17:51:08 <benzrf> is that a sane approach
17:51:09 <pavonia> stepkut: Are you looking for something like haskeline/readline?
17:52:15 <benzrf> oh wait i meant fmap . second
17:52:18 <benzrf> derp
17:52:40 <stepkut> pavonia: hmm -- no, haskeline is really about history and command completion -- I really just want to tell if the enter key is up or down
17:52:58 <pavonia> Oh, okay
17:54:10 <stepkut> when the enter key is down, I want to shoot giant flames -- when the enter key is up -- the fire should stop :)
18:12:31 <Fuuzetsu> what's a good fast creation + membership check structure?
18:12:56 <Fuuzetsu> like, faster membership check than list
18:15:43 <sgronblo> Fuuzetsu: tree, hashtable or binary search?
18:16:21 <Fuuzetsu> thought so
18:58:35 <EvanR> are top level TVars safe? are they culturally acceptable?
18:59:17 <enthropy> just don't make them with atomically
18:59:41 <EvanR> speaking of the newTVarIO thing
19:00:02 <EvanR> unsafePerformIO newTVarIO
19:00:17 <Axman6> with NOINLINE
19:00:28 <EvanR> hrm
19:03:14 <EvanR> why NOINLINE?
19:03:55 <fryguybob> EvanR: If the toplevel TVar is inlined you will get different TVars created.
19:03:59 <ski> to make sure exactly one is made ?
19:04:21 <ski> also, don't make a polymorphic `TVar'
19:04:45 <EvanR> i must be misunderstanding inlining
19:04:52 <Fuuzetsu> does someone know whether either free-game or JuicyPixels let me flip a Bitmap horizontally? I can't find anything to do it with
19:05:43 <Fuuzetsu> maybe I can scale by negative number or something
19:05:49 <ion> evanr: You could use http://hackage.haskell.org/package/safe-globals-0.1.1/docs/Data-Global.html
19:06:25 <EvanR> haha awesome
19:06:56 <EvanR> next i will need a GOTO monad and soon we will come full circle
19:06:57 <m09> Fuuzetsu: in Simon Marlow's book on parallel and concurrent haskel he uses image rotation as an example in chapter 5, with the repa lib. Maybe you can use repa as well
19:07:11 <ion> evanr: ContT
19:07:34 <Fuuzetsu> m09: I don't want to write it myself which is why I'm asking around ;)
19:08:04 <enthropy> @hackage JuicyPixels-repa
19:08:04 <lambdabot> http://hackage.haskell.org/package/JuicyPixels-repa
19:10:27 <EvanR> Data.Global uses template haskell
19:10:30 <EvanR> hmm
19:11:11 <EvanR> pretty cool though
19:12:23 <EvanR> "This library does not prevent the software design problems caused by global state."
19:12:36 <benzrf> hue
19:12:44 <EvanR> no warranty or implied merchantability
19:17:45 <kholdstare_> Hi! I have a question about Handles/Sockets in haskell. If I turn a Socket into a Handle, can I read from it on one thread and write to it in another? Will it cause any problems?
19:18:48 <kholdstare_> If not, is there an libary/abstraction that can help with that?
19:18:54 <kholdstare_> library*
19:19:07 <EvanR> you can read in one thread and write in another
19:19:17 <kholdstare_> sweet
19:19:33 <kholdstare_> that's what I wanted to hear. Simplifies things a lot
19:19:36 <kholdstare_> Thank you!
19:19:52 <fragamus> :t iterate
19:19:53 <lambdabot> (a -> a) -> a -> [a]
19:23:19 <zwer> > iterate (+1) 0
19:23:21 <lambdabot>  [0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,2...
19:23:37 <benzrf> > fix (1:)
19:23:39 <lambdabot>  [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1...
19:23:47 <benzrf> > take 10 $ fix (1:)
19:23:48 <lambdabot>  [1,1,1,1,1,1,1,1,1,1]
19:23:49 <benzrf> hmm
19:23:53 <EvanR>  last (fix (1:))
19:23:54 <EvanR>   1
19:23:56 <EvanR> ;)
19:24:00 <Fuuzetsu> @src iterate
19:24:00 <lambdabot> iterate f x =  x : iterate f (f x)
19:24:01 <benzrf> o=
19:24:12 <EvanR> limit (fix (1:))
19:24:20 <benzrf> :t limit
19:24:21 <lambdabot> Not in scope: ‘limit’
19:24:24 <benzrf> interesting
19:24:43 <ski>   iterate f x = xs where xs = x : map f xs  -- another possible implementation of it
19:25:00 <ski> (could also be written as `iterate f x = x : map f (iterate f x)')
19:25:04 <Fuuzetsu> can you implement it with fix?
19:25:28 <ski> of course you could turn it into `iterate f x = fix (\xs -> x : map f xs)', yes
19:25:47 <Fuuzetsu> didn't mean like that but sure
19:25:49 <ski> @type let iterate f x = fix ((x :) . map f) in iterate
19:25:50 <lambdabot> (a -> a) -> a -> [a]
19:26:06 <ski> ok. then how did you mean like ?
19:26:28 * ski notes hdevalence|away is away
19:26:30 <Fuuzetsu> no, don't worry, that's fine
19:27:45 <benzrf> :t second
19:27:46 <lambdabot> Arrow a => a b c -> a (d, b) (d, c)
19:27:49 <benzrf> hmmmm
19:27:50 <glguy_> let iterate f = fix (\self x -> x : self (f x))
19:28:40 <fragamus> asdf :: [Blah] -> IO [Blah]
19:28:48 <Fuuzetsu> fmap = second for tuples
19:28:57 <fragamus> I need to do something similar to iterate with my asdf
19:29:10 <EvanR> asdf = return?
19:29:26 <fragamus> no
19:29:36 <fragamus> it does a transformation on Blah
19:29:47 <fragamus> on [Blah]
19:29:51 <Fuuzetsu> :t mapM
19:29:52 <lambdabot> Monad m => (a -> m b) -> [a] -> m [b]
19:30:08 <fragamus> no like iterate
19:30:13 <fragamus> :t iterate
19:30:14 <lambdabot> (a -> a) -> a -> [a]
19:30:35 <Fuuzetsu> but iterate produces [a] so surely you would end up with IO [[Blah]] or whatever
19:30:43 <fragamus> but maybe put a finite limit on number of iterations
19:31:05 <Fuuzetsu> :t mfix
19:31:06 <lambdabot> MonadFix m => (a -> m a) -> m a
19:31:54 <flebron> Hi. Was there a way to say, without existential quantification, that a function will return a type t instance of some typeclass T, but not name which type it actually is?
19:32:01 <ski> hm, `\x -> fix (\g_x -> f x g_x)  =  fix (\g x -> f x (g x))'
19:32:05 <flebron> (And not meaning "the caller choses", but "the function choses")
19:32:07 <benzrf> flebron: i do not think so
19:32:20 <EvanR> flebron: rank N?
19:32:27 <EvanR> or is that the same thing
19:32:28 <benzrf> oh wait
19:32:32 <benzrf> EvanR: i thought it was
19:32:34 <benzrf> perhaps i am wrong
19:32:41 <joelteon> @pl \g x -> f x (g x)
19:32:41 <lambdabot> ap f
19:32:50 <flebron> EvanR: How would that go?
19:33:04 <joelteon> :t fix . ap
19:33:04 <lambdabot> Monad m => m (a -> a) -> m a
19:33:05 <EvanR> flebron: by putting an inner forall
19:33:15 <EvanR> thinking
19:33:16 <flebron> Isn't that the same as existential quantification?
19:33:26 <EvanR> maybe
19:33:34 <ski> Fuuzetsu : "fmap = second for tuples" -- almost
19:34:01 <ski> flebron : CPS with rank-2
19:34:24 <flebron> The semantics I'm after are a list of things, each of which can be a member of one or two typeclasses (fixed), and I'd want something like filterMembersOfTypeclass1 :: MixedList -> [Something which is of typeclass1]
19:35:01 <benzrf> flebron: you're doing it wrong
19:35:03 <flebron> I suppose my structure could be composed of 3 lists, the things which are members of one, the other, or both?
19:35:14 <ski> flebron : `frob :: forall a. Foo a => T a -> exists b. Bar a b => U a b' can be represented as `frobWith :: forall a o. Foo a => T a -> (forall b. Bar a b => U a b -> o) -> o'
19:35:16 <benzrf> flebron: you're doing it very wrong
19:35:35 <EvanR> haskell reflection lib ;)
19:35:36 <flebron> benzrf: That's possible (it's actually not my code, was just asked if it was doable without existential quantification :))
19:36:06 <Fuuzetsu> ski: Almost how? Is this about a = (->)
19:36:20 <EvanR> theres rankN polymorphism, then theres existential data, not sure which is quantification
19:36:29 <ski> sorry, s/exists b. Bar a b =>/exists b. Bar a b *>/
19:36:34 <fragamus> I have refined my question:   I need something that performs a monadic action a fixed number of times and uses the output as input:    Monad m => Int -> (a -> m a) -> a -> m a
19:36:38 <flebron> data Foo = forall a. Foo a => a
19:36:53 <ski> flebron : by julianb ?
19:37:04 <ski> Fuuzetsu :
19:37:07 <flebron> Hahaha indeed!
19:37:08 <ski> @src (,) fmap
19:37:09 <lambdabot> fmap f (x,y) = (x, f y)
19:37:28 <ski> @src (->) second
19:37:29 <lambdabot> second f = id *** f
19:37:34 <ski> @src (***) second
19:37:35 <lambdabot> Source not found. Take a stress pill and think things over.
19:37:42 <ski> er
19:37:45 <ski> @src (->) (***)
19:37:46 <lambdabot> (f *** g) ~(x,y) = (f x, g y)
19:37:50 <ski> so, that gives
19:38:14 <ski>   (second f) ~(x,y) = (x,f x)
19:38:26 <ski> the difference is in the `~'
19:38:39 <Fuuzetsu> didn't know it used irrefutable
19:38:41 <ski> (well, s/f x/f y/)
19:39:26 <Lutin`> Weird
19:39:31 <benzrf> @hoogle ByteString -> String
19:39:33 <lambdabot> Data.ByteString.Char8 unpack :: ByteString -> [Char]
19:39:33 <lambdabot> Data.ByteString.Lazy.Char8 unpack :: ByteString -> [Char]
19:39:33 <lambdabot> Data.ByteString.Char8 head :: ByteString -> Char
19:39:50 <Lutin`> My ping to freenode right now is crazy high
19:40:28 <EvanR> Text is King
19:40:59 <copumpkin> EvanR: boringmode
19:41:38 <EvanR> coboring
19:42:29 <ski> semi-near star-autonomous coboring
19:45:09 <ab9rf> coboling?
19:51:49 <benzrf> > do 3
19:51:50 <lambdabot>  3
19:51:51 <benzrf> hmmm
19:52:19 <EvanR> :t do 3
19:52:20 <lambdabot> Num a => a
19:52:33 <ab9rf> > do 'a'
19:52:34 <lambdabot>  'a'
19:52:54 <EvanR> > do { 'a' }
19:52:56 <lambdabot>  'a'
19:53:32 <ion> > do do do do do do do do do do do do batman
19:53:34 <lambdabot>  batman
19:55:00 <mayski> nice
19:55:10 <benzrf> watman
19:55:19 <EvanR> > batman
19:55:20 <lambdabot>  Not in scope: ‘batman’
19:55:21 <lambdabot>  Perhaps you meant ‘atan’ (imported from Prelude)
19:55:23 <benzrf> u wot
19:55:34 <benzrf> > do do do do do do do do do do do do batman
19:55:36 <lambdabot>  Not in scope: ‘batman’
19:55:36 <lambdabot>  Perhaps you meant ‘atan’ (imported from Prelude)
19:55:40 <benzrf> ion: 2sneaky
19:55:49 <benzrf> ion: did you think you could get away with it
19:55:56 <EvanR> it was just another race condition
19:55:59 <EvanR> to the bat mobile
19:56:04 <benzrf> !!!!
19:56:32 <enthropy> @let batman = text "batmat"
19:56:35 <lambdabot>  Defined.
19:57:26 <ab9rf> batmat?
19:57:28 <ab9rf> what's a batmat?
19:58:01 <EvanR> http://www.pureoverclock.com/wp-content/uploads/2013/10/inwin-batmat-front-pic.jpg
19:58:29 <EvanR> the cat was fat on the batmat
19:58:39 <ab9rf> EvanR: my kids have that book
19:59:00 <EvanR> the cat shat on the batmat
20:01:43 <ski> > do let{}; let in catwoman
20:01:45 <lambdabot>  batman
20:02:12 <ski> @type catwoman
20:02:14 <lambdabot> Batman
20:02:36 <ab9rf> ha
20:02:55 * ab9rf thinks you people need to get out more
20:02:59 <benzrf> ab9rf: :^)
20:03:21 <benzrf> ski: wait, how is that valid synax?
20:03:25 <benzrf> *syntax
20:03:28 <benzrf> > let in 3
20:03:29 <lambdabot>  3
20:03:31 <benzrf> oh huh
20:03:49 <ski> why wouldn't it be ?
20:04:06 <ski> > let _ = "" in ()
20:04:07 <lambdabot>  ()
20:04:25 <ski> > let (reverse -> s) = "hello" in s
20:04:27 <lambdabot>  "olleh"
20:07:24 <ski> > let ((repeat 0 /\/) . map succ -> ns) = ns in ns
20:07:25 <lambdabot>  [0,1,0,2,0,1,0,3,0,1,0,2,0,1,0,4,0,1,0,2,0,1,0,3,0,1,0,2,0,1,0,5,0,1,0,2,0,1...
20:07:49 <benzrf> *** Exception: user error (accept: can't perform accept on socket ((AF_INET,Stream,6)) in status Bound)
20:07:52 <benzrf> wtf
20:08:37 <benzrf> :t /\/
20:08:38 <lambdabot> parse error on input ‘/\/’
20:08:50 <benzrf> > repeat 0 /\/
20:08:51 <lambdabot>  <hint>:1:13:
20:08:52 <lambdabot>      parse error (possibly incorrect indentation or mismatched brackets)
20:08:55 <benzrf> wtf
20:09:10 <ski> @type (/\/)
20:09:11 <lambdabot> [a] -> [a] -> [a]
20:09:17 <benzrf> ohhhh thats a section
20:09:22 <benzrf> shit i feel sillt
20:09:24 <benzrf> *silly
20:09:29 <ski> it's an infix operator
20:09:38 <benzrf> i mean the code sample is a section
20:09:43 <benzrf> i completely failed to parse that
20:09:49 <benzrf> anyway what the shit is this
20:09:49 <benzrf> *** Exception: user error (accept: can't perform accept on socket ((AF_INET,Stream,6)) in status Bound)
20:09:50 <ski> > "hello" /\/ "world"
20:09:51 <lambdabot>  "hweolrllod"
20:10:19 * ski doesn't know very much about sockets :/
20:10:28 * hackagebot mvc 1.0.1 - Model-view-controller  http://hackage.haskell.org/package/mvc-1.0.1 (GabrielGonzalez)
20:11:01 <glguy> Benzf did you listen on it
20:11:50 <benzrf> glguy: i bound it
20:11:58 <glguy> Iirc you bind, then listen, then accept
20:12:26 <benzrf> used http://hackage.haskell.org/package/network-simple-0.4/docs/Network-Simple-TCP.html#v:bindSock
20:12:29 <benzrf> :\
20:14:04 <glguy> Benzf, I've never bothered using that package instead of normal network but try calling listen on the socket before you accept
20:14:11 <EvanR> yurg, low level sockets
20:14:35 <benzrf> glguy: the listen in there is for binding a callback as well
20:14:48 <EvanR> watch out for NetBSD not allowing shared ipv4 and ipv6 listing!
20:15:32 <benzrf> what's the default kwd do
20:16:43 <glguy> Benzf either use that library's listen directly or use its bindSock followed by the real listen
20:17:02 <glguy> Benzf it controls type defaulting
20:17:10 <benzrf> glguy: ooooooh
20:20:59 <gamegoblin> Any advice on when to use the inline pragma?
20:21:28 <gamegoblin> Was going through the source for attoparsec and it seems like just about everything has inline stuck on it
20:25:38 <benzrf> sweet
20:25:57 <benzrf> just made a little mini thing for simple reactive tcp servering
20:26:10 <benzrf> :-)
20:28:38 <benzrf> *ReactiveTCP> let echoCount inputs = fmap (\count input -> show count ++ "\n" ++ input) (accumB 0 $ (+1) <$ inputs)
20:28:41 <benzrf> *ReactiveTCP> serveReactive echoCount "9001"
20:28:44 <benzrf> :-)
20:31:00 <glguy> Gamegoblin: generally you shouldn't use it unless you've understood what effect it will have on GHC and you've run benchmarks to show yourself it is helping
20:52:13 <EvanR> can i has a sqrt for Pico
20:53:27 <benzrf> :t sqrt
20:53:28 <lambdabot> Floating a => a -> a
20:54:24 <EvanR> http://hackage.haskell.org/package/FixedPoint-simple-0.5/docs/Data-FixedPoint.html
20:54:27 <EvanR> noice
20:55:15 <ion> evanr: I was about to mention http://hackage.haskell.org/package/arithmoi-0.4.1.0/docs/Math-NumberTheory-Powers-Squares.html but the one you found seems better since it handles the scaling.
20:55:33 * hackagebot handle-like 0.0.0.6 - HandleLike class  http://hackage.haskell.org/package/handle-like-0.0.0.6 (YoshikuniJujo)
20:56:46 <djapo> could haskell be used to write a vector based video codec?
20:57:46 <ab9rf> of course
20:59:30 <sccrstud92> whats the website where you upload profile information and it makes a nice graph?
21:01:13 <dmj`> sccrstud92: http://www.chartjs.org/ ?
21:03:03 <EvanR> :t sin
21:03:04 <lambdabot> Floating a => a -> a
21:03:24 <sccrstud92> dmj`: i dont see anywhere to upload
21:03:24 <johnw> :t virtue
21:03:26 <lambdabot> Not in scope: ‘virtue’
21:04:29 <rwbarton> oh you mean ezyang's site
21:04:44 <rwbarton> http://heap.ezyang.com/
21:05:13 <benzrf> :t virtue
21:05:14 <lambdabot> ItsOwnReward
21:05:20 <dmj`> sccrstud92: you don't upload, info is embedded in the url
21:06:04 <sccrstud92> dmj`: i dont think its the right thing
21:06:53 <dmj`> sccrstud92: maybe it's not. The data is in json. What do you mean profile info?
21:07:12 <sccrstud92> dmj`: .hp file generated by ghc
21:07:22 <dmj`> oooohhhh lol my bad
21:07:25 <dmj`> hp2ps
21:07:36 <sccrstud92> that is a local program
21:07:44 <sccrstud92> there was a website you could upload it to
21:07:48 <rwbarton> http://heap.ezyang.com/
21:07:49 <sccrstud92> instead
21:07:59 <sccrstud92> oh thanks rw
21:07:59 <dmj`> ^
21:08:05 <sccrstud92> didnt realize u were talking to me
21:09:20 <sccrstud92> neat huh http://heap.ezyang.com/view/3e85fafcf2f43bf880a9324171041a71ea1dee9f#form
21:12:49 <djapo> has anyone used haskell to write a video codec?
21:13:22 <EvanR> sccrstud92: what is *
21:13:35 <sccrstud92> im not sure
21:13:42 <EvanR> and blackhole
21:14:05 <dmj`> what is ARR_WORDS
21:14:22 <EvanR> really i have no idea what im looking at :)
21:14:31 <sccrstud92> i think ARR_WORDS is w/e data structue is backing the Data.Array library
21:14:55 <dmj`> bunch of shark fins
21:15:15 <dmj`> here's mine: http://heap.ezyang.com/view/c4ac14098350283a882bfaa678026ce2d9bea194
21:15:23 <EvanR> stacked charts are annoying
21:15:31 <dmj`> snap profiling, the spikes seem to be where request data is returned
21:15:43 <dmj`> lots of arr_words
21:17:13 <dmj`> Is there a guide that explains the heap profiling breakdown? Maybe I'm blind but the ghc user guide doesn't seem to describe much
21:18:37 <sccrstud92> im only looking at the ghc guide
21:18:54 <sccrstud92> memory isnt really a problem for me right now. im profiling because its too slow
21:19:16 <sccrstud92> what is the best way to get timing info for a program?
21:19:35 <dmj`> sccrstud92: criterion is good for benchmarking things
21:20:09 <crazydave> I just like running with +RTS -prof, that gives a fairly nice report
21:24:57 <sccrstud92> crazydave: the report is helpful to me usually, but i just cant find anything to improve on
21:25:27 <sccrstud92> crazydave: most of the time spent appears to be doing math, which i cant really speed up
21:26:25 <EvanR> either do math faster or dont do as much math ;)
21:26:39 <EvanR> if thats the bottleneck
21:26:55 <crazydave> sccrstud92: what do you mean "doing math"?  Inside those functions? Do they have high alloc percentages as well: that can show that you need strictness as haskell is allocating lots of thunks unsure of whether it will need it or not
21:27:22 <crazydave> also, it is very unlikely that the maths is your bottle neck.  Computer calculation speed is crazy fast
21:28:37 <sccrstud92> crazydave: the thing is the array is recursively defined, so i cant make it completely strict
21:29:47 <crazydave> hmmm so then the problem is much more likely to be the recursive definition than the maths.  i.e. you aren't stuck on raw computation speed
21:31:51 <sccrstud92> im mapping a function over a list and building an array from that list
21:32:01 <johnw> sccrstud92: can you link to some code?
21:32:04 <sccrstud92> the function im mapping uses values from the array
21:32:56 <johnw> there are so many possible determinants when it comes to speed; processing the array in the wrong order can cause frequent cache invalidation which murders performance too
21:33:30 <altern> Hi all! I need to split string "x.x.x"  with attoparsec using full stop as a delimiter. How could I do that?
21:33:32 <sccrstud92> http://lpaste.net/105312
21:33:46 <sccrstud92> altern look at sepBy
21:33:57 <johnw> altern: see "sepBy"
21:34:15 <sccrstud92> johnw: http://lpaste.net/105312
21:34:43 <johnw> why use interact and map + pack + show?  Just parse the input, and then print each solution with mapM_
21:35:49 <crazydave> do you need to use Integer in all your maths or is Int big enough?
21:36:02 <johnw> right, Int is much faster
21:36:48 <sccrstud92> Int is not big enough
21:37:05 <sccrstud92> if I use a fixed size
21:37:20 <sccrstud92> i need to do intermediate mod operations over the courase of the computation
21:37:20 <orzo> my integer is 5 times larger than average
21:37:36 <orzo> not bragging, just a fact
21:38:15 <sccrstud92> johnw: because it was easier than restructuring my code
21:38:19 <johnw> sccrstud92: do you really need all the intermediary Arrays when computing 'trees'?
21:38:37 <sccrstud92> sccrstud92: as opposed to what?
21:38:47 <crazydave> also, can you paste the profile output: at least that will show us where all the time is spent!
21:39:02 <johnw> as opposed to memoizing
21:39:12 <johnw> if you are reusing certain indices, then I understand
21:39:33 <johnw> but if you are computing the array elements in order to use only a few a single time...
21:39:46 <sccrstud92> pofile http://lpaste.net/105313
21:40:18 <johnw> oh, huh
21:40:27 <sccrstud92> johnw: imagine a triangular array
21:40:46 <sccrstud92> lets say a lower triangular array
21:40:54 <sccrstud92> each element in the array
21:41:18 <sccrstud92> depends on all the elements in the column above it, and all the element in the row to its right
21:41:19 <johnw> can you tell me if this has any impact, changing ans to:
21:41:29 <johnw> ans (i, j) | i > j = Pair 0 0
21:41:29 <johnw> ans x = answerArray ! x
21:41:30 <johnw>  
21:42:34 <johnw> and move "l = size xs" out to the outer where clause
21:42:53 <johnw> all four of those, in fact
21:43:58 <sccrstud92> lol i just tried recompiing and now it cant find Data.Attoparsec.Combinator for some reason
21:44:06 <johnw> your values really won't fit in an Int64?
21:44:06 <sccrstud92> but i can load into ghci
21:44:20 <johnw> if you could use Int64, you could also switch to unboxed arrays
21:44:22 <sccrstud92> really
21:45:29 <johnw> and I imagine you aren't profiling with the trace statement still in there?
21:46:54 <sccrstud92> correct
21:47:22 <crazydave> moving the mod to intermediate steps and using Int64 will be faster also
21:48:03 <crazydave> (is that possible .... how is my maths ... is (a-b) mod c == (a mod c - b mod c) mod c?
21:48:15 <sccrstud92> yes its possible
21:48:26 <sccrstud92> its only multiply and divides
21:48:35 <sccrstud92> multiply and adds*
21:48:42 <monochrom> it is correct
21:48:55 <sccrstud92> any reason why ghhc can't find Data.Attoparsec.Combinator
21:49:52 <rwbarton> You're going to have to be way more specific.
21:50:16 <sccrstud92> alpha_beta_bst_arr.hs:6:8:
21:50:17 <sccrstud92>     Could not find module `Data.Attoparsec.Combinator'
21:50:17 <sccrstud92>     Perhaps you haven't installed the profiling libraries for package `attoparsec-0.11.3.4'?
21:50:17 <sccrstud92>     Use -v to see a list of the files searched for.
21:50:48 <shachaf> Perhaps you haven't installed the profiling libraries for package `attoparsec-0.11.3.4'?
21:51:21 <benzrf> sccrstud92: youre trying to do profiling?
21:51:23 <benzrf> god help your soul
21:51:29 <sccrstud92> yes
21:51:37 <sccrstud92> and if i reinstall that breaks things
21:51:46 <sccrstud92> then reinstalling those things breaks the originals
21:51:49 <sccrstud92> according to cabal
21:51:55 <sccrstud92> but i cant compile it anyway
21:52:00 <sccrstud92> so i might as well
21:55:33 <sccrstud92> its looking for cabal\attoparsec-0.11.3.4\ghc-7.6.3\Data\Attoparsec\Combinator.p_hi
21:55:42 <sccrstud92> instead of cabal\attoparsec-0.11.3.4\ghc-7.6.3\Data\Attoparsec\Combinator.hi
21:55:53 <rwbarton> Yes, since you're building with profiling
21:56:21 <sccrstud92> i see
21:56:31 <sccrstud92> but it worked before
21:56:40 <sccrstud92> so what happened to the profiling library lol
21:56:50 <rwbarton> Your guess is much better than ours
21:56:59 <sccrstud92> flew away?
21:58:54 <oisin640> I'm having a bit of trouble with dependent types - would someone mind taking me a look at my code (and errors) and letting me know why my implementation of vmmult (vector x matrix) code is throwing the bottom two errors? http://lpaste.net/105314
21:59:30 <sccrstud92> screw this im gonna watch game of thrones
22:00:05 <sccrstud92> johnw: crazydave: thanks for your help. im gonna try unboxed vectors with word64
22:07:03 <ozkar> hello people :)
22:07:58 <johnw> sccrstud92: let us know how it goes!
22:08:31 <johnw> oisin640: can you tell me which lines in your paste match up to the lines in the errors?
22:08:56 <johnw> ah, n/m, figured it out
22:09:11 <oisin640> johnw: Ah, sorry, just the middle part
22:09:16 <johnw> :t transpose
22:09:17 <lambdabot> [[a]] -> [[a]]
22:09:20 <Cale> oisin640: Well, there's no way the type signature for vmmult could possibly be correct
22:09:43 <Cale> oisin640: (what's that g variable doing there?)
22:09:54 <benzrf> hows it hangin ozkar
22:10:18 <oisin640> Cale: I thought it would make it so g didn't depend on m or n, and could be anything.
22:10:36 <Cale> oisin640: It does. It means the caller of vmmult gets to decide what g is
22:10:57 <Cale> oisin640: When surely you want vmmult to decide this
22:11:01 <ski> perhaps `n' was meant instead of `g' ?
22:11:06 <Cale> (yeah, you want it to be n)
22:11:10 <oisin640> Cale: So the signature should be ... -> Vector n e I guess
22:11:12 <oisin640> Yeah
22:11:22 <Cale> But yeah, that's not the only problem
22:14:10 <Cale> I think you need a Succ somewhere... What happens when m is Zero and n is not?
22:14:42 <oisin640> It should also return an EmptyVector (aka n goes to 0?), I think.
22:15:09 <Cale> Why?
22:15:13 <Cale> n might not be 0
22:15:43 * hackagebot stable-tree 0.3.0 - Trees whose branches are resistant to change  http://hackage.haskell.org/package/stable-tree-0.3.0 (tsuraan)
22:15:46 <oisin640> I'm not sure type-wise, but logically that would be like have 0 rows and n columns
22:15:50 <Cale> You have  EmptyMatrix :: Matrix Zero (Succ (Succ Zero)) e  after all
22:15:54 <Cale> yes
22:16:38 <Cale> I suppose you can give the zero vector
22:16:41 <crazydave> which must be being multiplied by the empty vector .... which is an unusual calculation to be making
22:17:41 <Cale> Given that this is like applying a linear map R^0 -> R^n to some element of R^0 (which must be the zero vector), the result must again be a zero vector -- that's fine, but it's a special case here.
22:20:07 <crazydave> talking of maps, isn't this function just map (dot v) over the columns of m? And wouldn't that be easier?
22:21:22 <oisin640> crazydave: Yes, but my fmap is defined as operating on each of the elements in a matrix - not on each row or column...
22:21:26 <oisin640> which is probably a mistake
22:22:12 <Cale> Oh, I guess you'll have already done that via the definition of dot
22:22:28 <Cale> (which you left out of your paste in an attempt to make it hard to test this code)
22:22:49 <oisin640> Cale: Ah, yeah, sorry. I can throw the whole thing up if you want - I just wanted to leave out most of the irrelevant stuff
22:22:57 <oisin640> of which dot isn't. :P
22:23:16 <crazydave> dot :: Num e => Vector m e -> Vector m e -> e
22:23:24 <Maxdamantus> Hmm .. are definitions in instances guaranteed to be evaluated at most once for each instance?
22:23:48 <Maxdamantus> (assuming `Show [Int]` is a different instance to `Show [Double]`)
22:24:07 <Cale> oisin640: But yeah, your first problem is that knowing that the matrix is an empty matrix doesn't guarantee that the result should be an empty vector.
22:24:17 <Cale> (it just guarantees that the result is a zero vector)
22:24:43 <oisin640> Cale: I'm not quite sure of the distinction between zero and empty?
22:25:02 <Cale> oisin640: 0 :> 0 :> EmptyVector  is also a zero vector
22:25:08 <oisin640> ah
22:25:51 <oisin640> But I want to make the distinction that _ x EmptyMatrix -> EmptyVector
22:26:43 <Maxdamantus> I'm going to suspect the answer is no, because ghci doesn't have that behaviour.
22:26:51 <Maxdamantus> s/suspect/guess/
22:27:56 <Cale> oisin640: But that's just not true -- it's not well-typed a lot of the time, first of all.
22:28:36 <Cale> oisin640: If the matrix is 0 by 2, for instance, then the result should be a vector with 2 elements.
22:29:48 <oisin640> Cale: A 0 x 2 matrix doesn't really make much sense to me though. How can there be two columns in no rows?
22:31:05 <crazydave> oisin640: Because you are using a reduction to get there iteratively
22:31:18 <Cale> oisin640: Well, it would be a representation of a linear map from a zero dimensional vector space to a 2-dimensional vector space
22:31:35 <Cale> oisin640: Which is a perfectly reasonable sort of thing
22:32:07 <Cale> also, your type for EmptyMatrix implies that it's possible
22:32:21 <Cale> EmptyMatrix isn't of type  Matrix Zero Zero e
22:32:30 <Cale> It's Matrix Zero c e
22:32:39 <Cale> (which is appropriate, actually)
22:33:50 <oisin640> I guess I have a hard time imagining how the function would resolve to an EmptyMatrix and a non-EmptyMatrix at the same time? How can the type definition account for that?
22:34:10 <oisin640> at the same time meaning within the 2+ patterns
22:34:17 <benzrf> bye
22:35:45 * hackagebot stable-tree 0.3.1 - Trees whose branches are resistant to change  http://hackage.haskell.org/package/stable-tree-0.3.1 (tsuraan)
22:35:46 <Cale> oisin640: Well, the type of your function is presumably  (Num e) => Vector m e -> Matrix m n e -> Vector n e  right?
22:35:54 <Cale> That seems sensible enough to me
22:36:30 <Cale> oisin640: So, what if we apply it with m = Zero and n = Two
22:37:19 <Cale> For instance   vmmult EmptyVector EmptyMatrix :: Vector Two Double
22:37:40 <Cale> Note that here  EmptyMatrix :: Matrix Zero Two Double
22:37:52 <oisin640> Then _ EmptyMatrix = EmptyVector fails
22:37:54 <oisin640> ?
22:38:01 <Cale> Right, that doesn't typecheck
22:38:38 <Cale> Because  EmptyVector :: Vector Zero e, which doesn't unify with  Vector Two Double
22:38:46 <Cale> because Zero is not equal to Two
22:38:50 <oisin640> Right
22:40:29 <oisin640> How can you account for that, though? I don't know how to pattern match any more specifically than EmptyMatrix, since that's all the constructor is
22:40:45 * hackagebot dbmigrations 0.8 - An implementation of relational database "migrations"  http://hackage.haskell.org/package/dbmigrations-0.8 (JonathanDaugherty)
23:05:08 <sccrstud92> johnw: crazydude: got it working with Word64 and liberal sprinklings of modular arithmetic
23:08:24 <johnw> faster?
23:15:10 <sccrstud92> yup
23:15:11 <solidus-river> hey all, i has an IO (DirTree (FilePath, blah)) and i want to fmap over the DirTree how do i get rid of the IO
23:15:19 <solidus-river> do i have to lift every thing
23:15:29 <sccrstud92> lik 3-4x
23:17:02 <Krakarn> :t fmap . fmap
23:17:03 <lambdabot> (Functor f1, Functor f) => (a -> b) -> f (f1 a) -> f (f1 b)
23:17:36 <oisin640> Cale: Thanks for your help - I think I've got it working now :)
23:22:30 <zRecursive> :src fmap
23:22:47 <zRecursive> @src fmap
23:22:47 <lambdabot> Source not found. I can't hear you -- I'm using the scrambler.
23:28:14 <ab9rf> good ol' cabal hell
23:28:29 <ski> zRecursive : it's overloaded, since it's a class method
23:28:38 <ski> @src Maybe fmap
23:28:38 <lambdabot> fmap _ Nothing       = Nothing
23:28:38 <lambdabot> fmap f (Just a)      = Just (f a)
23:28:41 <ski> @src [] fmap
23:28:41 <lambdabot> fmap = map
23:28:45 <ski> @src (,) fmap
23:28:45 <lambdabot> fmap f (x,y) = (x, f y)
23:28:52 <ski> @src (->) fmap
23:28:52 <lambdabot> fmap = (.)
23:29:03 <zRecursive> ski: ok
23:35:03 <jle`> :t fmap fmap fmap
23:35:04 <lambdabot> (Functor f1, Functor f) => (a -> b) -> f (f1 a) -> f (f1 b)
23:36:33 <altern> Hi guys. I am stuck again
23:36:41 <altern> Cannot make this thing work: http://lpaste.net/105320
23:36:47 <jle`> > fmap fmap fmap (*2) (Just (Right 3))
23:36:48 <lambdabot>  Just (Right 6)
23:37:01 <jle`> why do we even have (.) :)
23:37:01 <altern> Error: Couldn't match expected type `attoparsec-0.11.3.4:Data.Attoparsec.Internal.Types.Parser                                     BS.ByteString String'                 with actual type `BS.ByteString -> Parser BS.ByteString'     In a stmt of a 'do' block: d1 <- string     In the expression:       do { d1 <- string;            char '.';            d2 <- string;            char '.';            .... }
23:37:36 <jle`> altern: do you expect line 16 to do?
23:38:17 <jle`> and 18 and 20, for that matter
23:38:24 <altern> jle`: I want to parse string "1.2.3"
23:38:44 <jle`> why can't you do str <- string "1.2.3"
23:38:53 <jle`> do you know what the `string` function does?
23:39:11 <ski> altern : you're missing arguments to `string' in `parseV'. perhaps you meant to call `stringToVC' there instead ?
23:39:54 <ab9rf> you want something other than 'string' there
23:40:33 <matematikaadit> :t fmap
23:40:34 <lambdabot> Functor f => (a -> b) -> f a -> f b
23:40:40 <altern> ski: right! I should use stringToVC
23:43:49 <platz>  /quit
23:45:53 * hackagebot threads 0.5.1.2 - Fork threads and wait for their result  http://hackage.haskell.org/package/threads-0.5.1.2 (BasVanDijk)
23:46:54 <altern> ski: I have made it work: http://lpaste.net/105325
23:47:07 <altern> ski: but I have another question
23:47:37 <jle`> @src realToFrac
23:47:37 <lambdabot> realToFrac = fromRational . toRational
23:47:45 <altern> ski: how could I parse into arbitrary number of split elements? for example "1.2.3.4.5"
23:48:02 <ski> altern : `sepBy' ?
23:48:40 <altern> ski: I cannot find decent example with sepBY that I could reuse :(
23:48:46 <ski> @hoogle sepBy
23:48:47 <lambdabot> Text.ParserCombinators.ReadP sepBy :: ReadP a -> ReadP sep -> ReadP [a]
23:48:48 <lambdabot> Text.Parsec.Combinator sepBy :: Stream s m t => ParsecT s u m a -> ParsecT s u m sep -> ParsecT s u m [a]
23:48:48 <lambdabot> Text.ParserCombinators.Parsec.Combinator sepBy :: Stream s m t => ParsecT s u m a -> ParsecT s u m sep -> ParsecT s u m [a]
23:49:07 <rrradical> watching some haskell code compile-- it's crazy how few warnings get generated compared to C/C++ code
23:49:12 <altern> this is from another module
23:49:19 <altern> not attoparsec
23:49:52 <altern> is it ok if it's not attoparsec?
23:50:05 <ski> which combinator parsing library are you using ?
23:50:15 <Lutin`> :( I know this is off topic but does anyone have a really fast USB stick they'd recommend?
23:50:21 <ski> rrradical : sounds nice
23:51:08 <Lutin`> laptop hd died and I had to install to a usb drive but I can barely use cabal because my write speed maxes out at about 8 MB/s
23:51:16 <altern> ski: attoparsec (import Data.Attoparsec.Char8)
23:52:46 <ab9rf> Lutin`: find one that supports usb 3.0, and make sure your computer also supports 3.0
23:53:29 <Lutin`> Yeah I know just asking around for recommendations
23:53:37 <ab9rf> flash memories are ridiculously fast, the speed limitation on USB sticks is the USB interface, not the memory chip
23:53:41 <ski>   Data.Attoparsec.Combinator.sepBy1 :: Alternative f => f a -> f s -> f [a]
23:54:09 <Lutin`> the bottleneck tends to be the USB interface on the drive
23:54:40 <Lutin`> I've reached 400MB/s when connected to a friend's external SSD on this laptop
23:54:56 <Lutin`> I'll take this elsewhere though, thanks
23:55:54 * hackagebot primitive 0.1 - Wrappers for primitive operations  http://hackage.haskell.org/package/primitive-0.1 (HerbertValerioRiedel)
23:55:56 * hackagebot primitive 0.2 - Wrappers for primitive operations  http://hackage.haskell.org/package/primitive-0.2 (HerbertValerioRiedel)
23:55:58 * hackagebot primitive 0.2.1 - Wrappers for primitive operations  http://hackage.haskell.org/package/primitive-0.2.1 (HerbertValerioRiedel)
23:56:00 * hackagebot primitive 0.3 - Wrappers for primitive operations  http://hackage.haskell.org/package/primitive-0.3 (HerbertValerioRiedel)
23:56:02 * hackagebot primitive 0.3.1 - Wrappers for primitive operations  http://hackage.haskell.org/package/primitive-0.3.1 (HerbertValerioRiedel)
23:56:03 <ski> hm, something like `chainr1' would be nicer, i think
23:56:08 <ski> @hoogle chainr1
23:56:09 <lambdabot> Text.ParserCombinators.ReadP chainr1 :: ReadP a -> ReadP (a -> a -> a) -> ReadP a
23:56:09 <lambdabot> Text.Parsec.Combinator chainr1 :: Stream s m t => ParsecT s u m a -> ParsecT s u m (a -> a -> a) -> ParsecT s u m a
23:56:10 <lambdabot> Text.ParserCombinators.Parsec.Combinator chainr1 :: Stream s m t => ParsecT s u m a -> ParsecT s u m (a -> a -> a) -> ParsecT s u m a
23:58:33 <ski>   ds <- sepBy1 stringToVC (char '.')
23:59:01 <ski>   let vs = map VersionCompound ds
23:59:42 <ski>   return (foldr1 (\(VersionCompound vc) -> Version vc) vs)
