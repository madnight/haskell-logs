00:06:24 <bstrie> howdy folks, I have a purely theoretical question that may very well be heresy :)
00:06:58 <bstrie> specifically, I'm wondering if anyone has ever devised a haskell program that is entirely pure, but communicates with the outside world via predictably heating up the CPU in certain patterns
00:07:09 <Zer000> so I wanted to define my own multiplication function, as seen in this lecture on haskell https://www.youtube.com/watch?v=WmB8LOK3_R8#t=2944 but when I do "let mult :: Num a => a -> a -> a; mult (x+1) y = y + (mult x y)" in ghci it gets angry at my x+1 pattern match
00:07:34 <StoneCypher4k> bstrie: it's easy to make output pure
00:07:34 <shachaf> bstrie: Doesn't seem very difficult.
00:07:44 <pingu> bstrie: if you're being serious, I do recall someone doing this for another reason
00:08:03 <shachaf> Zer000: Yes, (n+k) patterns were deprecated and no longer exist in the latest version of the Haskell standard.
00:08:09 <pingu> something along a certain chipset emitting various noises when decrypting data
00:08:17 <shachaf> Instead, write mult x y = y + mult (x-1) y
00:08:36 <pingu> bstrie: http://www.extremetech.com/extreme/173108-researchers-crack-the-worlds-toughest-encryption-by-listening-to-the-tiny-sounds-made-by-your-computers-cpu
00:09:16 <Zer000> shachaf: oh ok, thanks.
00:09:40 <bstrie> pingu: right, side channel attacks are what gave me the idea :P
00:10:00 * hackagebot apiary-clientsession 0.10.0 - clientsession support for apiary web framework.  http://hackage.haskell.org/package/apiary-clientsession-0.10.0 (HirotomoMoriwaki)
00:10:00 * hackagebot apiary-authenticate 0.10.0 - authenticate support for apiary web framework.  http://hackage.haskell.org/package/apiary-authenticate-0.10.0 (HirotomoMoriwaki)
00:10:12 <pingu> right. well acoustic seems way better than heat, if you wanted to do this ;)
00:10:22 <pingu> I would at least find it amusing.
00:11:12 <pingu> bstrie: unfortunately such a program would never 'communicate', it would always be one way
00:11:27 <pingu> communicate in a bi-directional sencse
00:11:29 <pingu> *sense
00:11:48 <pharaun> should make your cpu say "SOS" help i'm being abused
00:13:40 <bstrie> pingu: perhaps we could get an incredibly precise cosmic ray emitter and directly flip bits in the CPU registers in order to communicate
00:14:03 <ab9rf> heh
00:14:52 <bstrie> that will at last abolish that you need a degree in category theory in order to do I/O in haskell
00:14:55 * hackagebot warp 3.0.0.2 - A fast, light-weight web server for WAI applications.  http://hackage.haskell.org/package/warp-3.0.0.2 (MichaelSnoyman)
00:14:57 * hackagebot yesod-platform 1.2.12.2 - Meta package for Yesod  http://hackage.haskell.org/package/yesod-platform-1.2.12.2 (MichaelSnoyman)
00:15:03 <bstrie> as proven, a degree in particle physics will also suffice
00:15:42 <shachaf> sigh
00:19:56 * hackagebot http-conduit 2.1.2.2 - HTTP client package with conduit interface and HTTPS support.  http://hackage.haskell.org/package/http-conduit-2.1.2.2 (MichaelSnoyman)
01:23:26 <cow_2001> snap vs. yesod. i know a bit of django.
01:23:49 <cow_2001> what're the ups and downs?
01:24:32 <taktoa> yesod has type safe urls but you have to deal with template haskell
01:26:22 <cow_2001> i have use gaping holes in my webdev knowledge
01:26:45 <cow_2001> s/use/huge/
01:30:08 * taktoa transfers himself from the conversation from #haskell-blah
01:30:14 <cow_2001> hihi
01:30:20 <taktoa> cow_2001: mconcat is concat
01:30:26 <cow_2001> yeah
01:30:44 <cow_2001> generalized for monoids
01:31:05 <taktoa> anyway CGI is the easiest thing to do with haskell but obviously not very fast
01:31:26 <taktoa> scotty is good but you don't live in it
01:31:34 <taktoa> happstack is a step up from scotty
01:31:41 <taktoa> snap is a step up from happstack
01:31:51 <taktoa> and yesod stands at the top, probably
01:32:09 <taktoa> not saying any of these are better than any others
01:32:44 <taktoa> more that higher complexity apps should probably use higher complexity frameworks
01:35:31 <Welkin> scotty is like flask/sinatra (so bare bones; batteries not included)
01:35:46 <cow_2001> what's a left fold enumeration O_O
01:35:47 <Welkin> I like flask, but have yet to use scotty
01:36:38 <pdxleif> I use straight WAI
01:37:15 <pharaun> me too as well, straight wai + yesod routing
01:38:53 <pingu> mutt
01:39:01 <pingu> ... let's try the other terminal then.
01:39:16 <Welkin> pinguman!
02:05:45 <zomg> cow_2001: at least in my experience, Yesod is probably reasonably easy to understand from a Django background. You define similar things as you'd define when working in Django, although it does work slightly differently in places
02:05:56 <zomg> cow_2001: never used Snap so can't really say about that
02:36:10 <d3lxa> I would like to generate some random Char's, should I use System.Random or something else? non-critical app
02:40:35 <Tjr> d3lxa: what are you concerned about? predictable not-so-random random number generators?
02:41:08 <d3lxa> System.Random is too cumbersome, I have to keep the generator etc
02:41:33 <Tjr> if all you ever want is once infinite list of random numbers, then just
02:41:33 <d3lxa> I can run in IO, so I would prefer having something with side effect that keeps track the generator for me
02:42:25 <d3lxa> Tjr: I'm concerned about the difficulty of use, I just need a function of IO a that returns a new random value each time :D if possible
02:42:28 <Tjr> call getStdGen once, stuff it into randoms, and only ever pass the resulting list around
02:42:47 <Tjr> then randoms seems to be what you're looking for
02:43:03 <quchen> :t randomIO -- d3lxa
02:43:04 <lambdabot> Random a => IO a
02:43:05 <Tjr> unless I misundertand you
02:43:42 <quchen> randomIO is very slow, and the Random instances are not very well distributed as far as I've heard though.
02:47:16 <d3lxa> quchen: I don't mind for now, it's exactly what I needed
02:47:53 <d3lxa> Tjr: thus I would need to pass around the list, that's not so convenient
02:48:28 <piezoid> Tjr: RandT in MonadRandom is a StateT passing around the genrator, if that's what you want
02:53:04 <Tjr> piezoid: good to know
02:54:53 <d3lxa> In fact I need to get a random [a] of length n from a list of possible distinct choice [a] (or let say Set a), I thought randomIO can do it but it's not as convenient as RVar: choice :: [a] -> RVar a, then run it into some Monad like IO? I'm not sure, any advice?
02:57:42 <d3lxa> seems I can use randomRIO: http://rosettacode.org/wiki/Pick_random_element#Haskell
02:57:46 <d3lxa> is this fine?
02:58:35 <Iceland_jack> d3lxa: If you want to operate in IO sure
02:59:24 <d3lxa> Iceland_jack: yes
03:03:07 <Ainieco> hello
03:03:13 <Cale> hi
03:03:41 <Ainieco> i'd like to try out roverloaded record fields but having hard time to build adamgundry's ghc version
03:03:56 <Ainieco> "./sync-all -r http://git.haskell.org get" fails: fatal: repository 'https://github.com/adamgundry/packages/Cabal.git/' not found
03:04:15 <pharaun> quchen: got a recommendation for a better rand?
03:04:48 <pharaun> been eyeballing the crypto-rand api ones, or the one that consumes from /dev/urandom but i'm not sure
03:05:25 <Ainieco> am i misusing "sync-all -r"?
03:05:46 <Ainieco> eveyrthinhg but cabal was cloned successfully it seems
03:06:40 <cow_2001> how do you port from django to yesod one bit at a time?
03:08:18 <zomg> cow_2001: in theory you could probably set up a proxy to tunnel requests depending on which URLs you've migrated
03:08:35 <zomg> but in practice it can be more difficult for example if you have an authentication system in place
03:09:30 <cow_2001> -_-
03:09:32 <cow_2001> oh god
03:11:22 <zomg> worth noting that you'd face the same issues no matter what you were migrating to, so it's not a yesod/haskell specific problem
03:12:56 <Tjr> > let { rnd-select :: (Num n, Ord n) => [a] -> n -> IO (Maybe [a]) ; rnd-select _ _ = return Nothing }
03:12:57 <lambdabot>  <hint>:1:7:
03:12:58 <lambdabot>      Invalid type signature: rnd - select :: (Num n, Ord n) =>
03:12:58 <lambdabot>                                              [a] -> n -> IO (Maybe [a])
03:12:58 <lambdabot>      Should be of form <variable> :: <type>
03:13:48 <Tjr> What's wrong with my type signature?
03:14:26 <Tjr> > let { rnd-select :: (Num n, Ord n) => n -> IO (Maybe [a]) ; rnd-select  _ = return Nothing }
03:14:27 <lambdabot>  <hint>:1:7:
03:14:27 <lambdabot>      Invalid type signature: rnd - select :: (Num n, Ord n) =>
03:14:28 <lambdabot>                                              n -> IO (Maybe [a])
03:14:28 <lambdabot>      Should be of form <variable> :: <type>
03:14:34 <k00mi> Tjr: the problem is the minus
03:14:43 <cow_2001> zomg: that's true
03:14:51 <Tjr> thank you
03:15:09 <Tjr> what characters are allowed in variable names?
03:15:51 <taktoa> abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789'_
03:16:08 <taktoa> plus any other unicode characters considered to be letters and not symbols
03:17:28 <gamegoblin> Any idea why Show is a superclass of Num?
03:17:53 <aristid-ic_> gamegoblin: which ghc version are you using?
03:18:09 <quchen> Num doesn't have any superclasses in 7.8 anymore.
03:18:12 <gamegoblin> aristid-ic_: just as defined in haskell 98
03:18:24 <gamegoblin> ah ok didn’t know it changed
03:31:42 <Ainieco> how to provide ToJSON instance for sum type "data Foo = Bar | Baz"?
03:33:02 <Ainieco> oh, i guess i'll just use show
03:34:18 <quchen> Ainieco: Derive Generic for your type, then it's "instance toJSON Foo"
03:34:30 <quchen> (The Aeson docs mention this.)
03:34:58 <simon> http://hackage.haskell.org/package/aeson-0.6.1.0/docs/Data-Aeson.html#t:ToJSON - there's an example, too
03:35:03 <random99> Hi!
03:35:22 <random99> Is there a way to issue a command within a haskell program that clears the screen?
03:35:35 <simon> random99, in ghci, you mean?
03:35:41 <random99> yes, in ghci
03:35:50 <Ainieco> quchen: okay, but is there a way to do it without dervice generic?
03:35:52 <simon> random99, it depends on your terminal emulator. but try Ctrl+L
03:36:01 <random99> I've written a prototype of a game and I would like to clear the screen after each move
03:36:14 <random99> no, I want to have this in the main game loop
03:36:16 <simon> random99, oh, so from a program.
03:36:21 <random99> yes
03:36:25 <random99> sorry if I wasn't clear before
03:37:12 <simon> well, there's a terminal control code for clearing the screen. you can either print this directly, or you can use a library that puts it in a convenience function.
03:37:39 <simon> a control code is just a sequence of bytes of which the first ones are nonprintable.
03:38:00 <simon> maybe the ncurses package is useful here.
03:38:09 <simon> even though it does a lot more than that.
03:39:33 <simon> random99, http://en.wikipedia.org/wiki/ANSI_escape_code#CSI_codes
03:40:22 * hackagebot chatty 0.5.5.0 - Some monad transformers and typeclasses to simplify I/O on a transformer stack.  http://hackage.haskell.org/package/chatty-0.5.5.0 (implementation)
03:40:24 * hackagebot chatty 0.5.5.1 - Some monad transformers and typeclasses to simplify I/O on a transformer stack.  http://hackage.haskell.org/package/chatty-0.5.5.1 (implementation)
03:41:45 <simon> random99, http://forum.codecall.net/topic/59142-how-to-clear-the-console-screen-with-ansi-any-language/ is more specific.
03:41:50 <allsystemsarego> @hoogle clearScreen
03:41:52 <lambdabot> No results found
03:42:17 <allsystemsarego> http://haddocks.fpcomplete.com/fp/7.4.2/20130829-168/ansi-terminal/System-Console-ANSI.html#v:clearScreen
03:42:29 <allsystemsarego> random99, ^
03:43:02 <random99> I found a simpler solution: putStr "\ESC[2J"
03:43:32 <Tjr> I'm writing something that needs random numbers. Is there a better way than to pass the RandomGen around in the pure code?
03:43:56 <taktoa> Tjr: unfortunately no
03:44:01 <taktoa> not as far as I know
03:44:15 <Tjr> I mean, this looks kind of ugly:
03:44:15 <Tjr> func :: RandomGen a -> (RandomGen, a) ; func g x = (g', output)
03:44:31 <simon> is a RandomGen deterministic?
03:44:38 <Tjr> simon: yes
03:44:58 <zomg> Tjr: you could just make a new randomgen whenever. Or use a reader or whatever
03:44:58 <pjdelport> Tjr: You can use things like Reader and other monads to pass it around.
03:45:11 <Tjr> simon: that means, if you pass the same random seed, then you get the same results. Which is handy if you're testing whether a patch broke something.
03:45:36 <simon> Tjr, sure. or if you really need random numbers within your pure code and don't want to taint it, right? :)
03:45:45 <Tjr> ok, so my intuition wasn't quite wrong that you guys had already encountered this problem :-)
03:46:01 <simon> Tjr, then you only need to seed it outside.
03:46:06 <pjdelport> Tjr: http://book.realworldhaskell.org/read/monads.html has a bit about using State for this.
03:47:04 <Rc43> Hello.
03:47:05 <Tjr> pjdelport: noted, I'll look into that once I've got the bare bones working.
03:47:13 <pjdelport> Tjr: You might want to paste your code, too. As a rule of thumb, it's better to factor your code so that direct dependencies on randomness is minimized, rather than going to a lot of effort wiring randomness through code that doesn't strictly need it.
03:47:29 <Rc43> I cannot install tf-random-0.5, it throws exception "hGetContents: invalid argument".
03:47:39 <Rc43> What can be wrong?
03:48:27 <pjdelport> Tjr: So it's a bit like IO or other taint-y things: try to make the majority of your code pure, with only a small backbone of code that coordinates the randomness that's getting passed to the pure code.
03:49:12 * Tjr likes to ask the important things first.
03:49:12 * Tjr is working on the code right now.
03:50:01 <jamiehannaford> if I have: data JoinList m a = Empty | Single m a | Append m (JoinList m a) (JoinList m a), and instance Buffer (JoinList (Score, Size) String) where fromString :: String -> b - how can I invoke that in the GHCI?
03:50:20 <jamiehannaford> fromString "foo!" :: Buffer (JoinList (a,b) c)   ?
03:50:47 <shachaf> jamiehannaford: Is this some sort of fancy monoidal summary fingery tree sort of thing?
03:50:59 <shachaf> jamiehannaford: THe idea of OverloadedStrings is that you can just type "foo" :: YourType
03:51:08 <shachaf> After you enable the extension, that is. The same way numbers work.
03:51:19 <jamiehannaford> yeah, it's to do with monoids - but it's not overloaded, you have a function called fromString
03:51:33 <jamiehannaford> which converts a string type into a Buffer
03:52:25 <Tjr> If I "split" a "RandomGen", can that leat to cryptographic vulnerabilities?
03:52:44 <shachaf> jamiehannaford: Oh, wait, you defined your own class.
03:52:52 <Tjr> For example, suppose somebody observes one half of the split perfectly, can they deduce something about the other half?
03:52:53 <jamiehannaford> shachaf shall I paste it so it's clearer? what's the pastebin that people use in here?
03:52:55 <shachaf> There's a standard library class with a method fromString.
03:53:04 <shachaf> jamiehannaford: hpaste.org
03:53:10 <shachaf> jamiehannaford: But I think what you said should be fine.
03:53:12 <rob566> someone put this site here yesterday WWW.SoccerTips4Sure.com and i said to try it,and yes i won, it is the first time when i win some money
03:53:34 <Tjr> dead channel ops, wow you're fast.
03:53:37 <shachaf> 4Sure
03:53:41 <Tjr> s/dead/dear/
03:53:52 <zomg> probably automatic spam detection
03:53:53 <shachaf> K-Lined is network ops, not channel ops
03:54:42 <quchen> Tjr: System.Random is not cryptographic. In other words, assume it is fully compromised for all instances.
03:55:17 <Tjr> quchen: does haskell have something safe, like the mersenne twister?
03:55:21 <quchen> In addition to that, the docs for the StdGen instance even mention that it's just a wacky hack.
03:55:47 <shachaf> Mersenne twister is not cryptographically secure.
03:55:52 <haasn> How much are you willing to rely on Haskell being safe?
03:55:53 <pjdelport> MT isn't cryptographic either
03:57:18 <jamiehannaford> shachaf http://lpaste.net/4480066569547808768
03:57:22 <Tjr> I just want to get into the habit of using the best RandomGen available.
03:57:32 <Tjr> It's only practise code for now
03:57:41 <pjdelport> Tjr: That depends entirely on how you define "best".
03:57:41 <shachaf> jamiehannaford: What's the question?
03:57:51 <jamiehannaford> shachaf how can I execute fromString "foo" in GHCI
03:57:59 <jamiehannaford> it expects some kind of type hint
03:58:06 <pjdelport> Tjr: The design goals of cryptographic PRNGs and other PRNGs are very different.
03:58:09 <shachaf> You gave a suggestion.
03:58:15 <shachaf> I said that that suggestion looks fine.
03:58:24 <shachaf> Did something happen when you tried it?
03:58:27 <Tjr> pjdelport: by "best" I mean a random number generator that does not expose me to avoidable attacks
03:58:45 <pjdelport> Tjr: Cryptographic attacks?
03:58:45 <jamiehannaford> I don't know what to type after the ::
03:58:56 <shachaf> Oh, I see now.
03:58:58 <shachaf> I misread.
03:59:04 <shachaf> Type whatever type you want.
03:59:04 <haasn> launchMissiles attacks?
03:59:14 <shachaf> "foo" :: JoinList (Score, Size) String
03:59:16 <pjdelport> Tjr: It depends somewhat on what your threat model is, and how the rest of your cryptosystem looks.
03:59:21 <shachaf> If that's the type you want the whole thing to have.
04:00:02 <pjdelport> Tjr: Have you read e.g. https://en.wikipedia.org/wiki/Cryptographically_secure_pseudorandom_number_generator and other CSPRNG theory?
04:00:28 <jamiehannaford> shachaf got it now, thanks. the problem was I kept on including "Buffer" in the type hint
04:00:46 <jamiehannaford> which is wrong because that's the name of the instance, not the type right?
04:00:49 <Tjr> pjdelport: Not sure about that. I just know all those horror stories about physicists simulating a gas, just to discover their RNG has initialized the gas atoms all on 3 hypersurfaces.
04:00:56 <shachaf> Buffer is the name of the class.
04:01:01 <shachaf> It's the same deal when you use numbers.
04:01:10 <shachaf> You write (5 :: Int) when you want 5 as an Int.
04:01:26 <jamiehannaford> but Int is an type instance of a type class right?
04:01:37 <toki78> Hi
04:01:38 <shachaf> Int is an instance of many classes.
04:01:46 <toki78> now I vahe a real question
04:01:46 <shachaf> 5's type is "Num a => a"
04:01:46 <jamiehannaford> got it
04:01:51 <pjdelport> Tjr: Oh, that's an entirely different kind of analysis, yes. You don't need a CSPRNG, then, just a good PRNG. You might need some numerical analysis to see which PRNG is suited for your problem domain, but any reasonable one (like MT) will probably do.
04:01:52 <quchen> Tjr: Simulating Navier-Stokes and getting a couple of different values out of nowhere are very different applications.
04:02:10 <toki78> what does that mean : hurls.hs:28:18:
04:02:10 <toki78>     Illegal polymorphic or qualified type:
04:02:10 <toki78>       forall a. RLFunctionInterpolator a => a
04:02:13 <jamiehannaford> so you can't use Buffer because that's a class that *lots* of types can possibly use
04:02:14 <toki78> ??
04:02:44 <toki78> In the data declaration for `RLQ0Agent'
04:03:08 <toki78> no polymorphis in data types ??
04:04:26 <Tjr> pjdelport: thanks, the next-bit test is what I'd like to get right.
04:05:02 <pjdelport> Tjr: For simulations, probably not, actually.
04:05:09 <Tjr> why not?
04:05:32 <toki78> http://pastebin.com/dJwDnNU2
04:05:35 <toki78> please help
04:05:44 <pjdelport> Tjr: You're not faced with a cryptographic adversary, so whether reversing the RNG is polynomial or not isn't relevant.
04:06:07 <pjdelport> Tjr: The next-bit test is more nuanced and technical than "the RNG is predictable".
04:06:25 <notdan> toki78: can you enable RankNTypes?
04:06:39 <toki78> notdan, what is that, and why ?
04:06:47 <f-a> little I know about poly types, but have you tried compiling the suggested flags?
04:07:00 <pjdelport> Tjr: *Any* PRNG is reversible given unlimited resources; the difference between a CSPRNG and non-CS PRNG is mainly about whether a real-life adversary trying to crack a cryptosystem can practically do it or not.
04:07:05 <Tjr> pjdelport: http://taeb-nethack.blogspot.de/2009/03/predicting-and-controlling-nethacks.html >> even in gaming, people will try to attack the PRNG
04:07:10 <pjdelport> Tjr: If you're not building a cryptosystem, that's irrelevant.
04:07:14 <notdan> toki78: http://www.haskell.org/haskellwiki/Rank-N_types
04:07:21 <toki78> f-a, no polys in structures ???
04:07:53 <Tjr> pjdelport: I guess it's also relevant if I'm doing monte carlo simulations. So I might as well learn the correct way.
04:08:53 <pjdelport> Tjr: For simulations, other properties are important; e.g. https://en.wikipedia.org/wiki/Monte_Carlo_method#Monte_Carlo_and_random_numbers
04:08:56 <toki78> notdan, looking at my code : isn't this standard haskell ??
04:09:58 <pjdelport> Tjr: So e.g. using a CSPRNG is meaningless and incorrect if you don't sample and scale it correctly.
04:10:33 <toki78> notdan, the problem is that I want to add this to hackage, and I don't know, if hackacge supports special flags
04:11:00 <Tjr> pjdelport:  true, however that dependency doesn't mean that I should be using a bad PRNG.
04:11:06 <f-a> add {-- at the beginning on the file
04:11:12 <f-a> with the needed extension
04:11:12 <f-a> s
04:11:37 <toki78> f-a, cool idea
04:11:44 <Tjr> For what I have in mind, low-discrepancy doesn't really matter.
04:11:47 <pjdelport> Tjr: Right; I'm trying to say that a good PRNG for your purposes is not about whether it's cryptographic or not.
04:12:49 <Tjr> In Sawilowsky's list, only two points are about the RNG: pass tests for randomness, and long “period”. Shouldn't both be relevant in a cryptographic sense?
04:12:49 <toki78> f-a, {-- -XRankNTypes -}
04:12:50 <toki78>  ??
04:13:10 <Axman6> toki78: you need {-# LANGUAGE FooExtn #-}
04:13:33 <f-a> no, {-# L- what Axman6 said
04:13:34 <toki78> Axman6, {-# LANGUAGE  XRankNTypes#-}
04:13:46 <f-a> missing a space
04:13:56 <pjdelport> Tjr: Not really, no.
04:14:21 <f-a> and drop the X
04:14:54 <Tjr> pjdelport: so you're saying a cryptographic PRNG can be a bad PRNG for simulation purposes (disregarding the low-discrepancy aspect)?
04:15:02 <pjdelport> Yes.
04:15:20 <toki78> f-a, Axman6 looks good, now I have other error messages, thats OK, thx !!
04:15:38 <pjdelport> Tjr: It will also probably be much slower, because it's optimizing for an entirely orthogonal set of goals.
04:15:39 <f-a> I see, but that should be an 'usual' error message. Happy coding!
04:15:58 <Tjr> I don't mind it being slow righ tnow
04:16:49 <pjdelport> Tjr: You should almost certainly just be using a good implementation of something like MT, or another widely-used PRNG for simulations.
04:19:13 <toki78> I don't get this code compiled
04:19:52 <Axman6> Tjr: if you'd like to know a bit more about the different between CPRNGs and PRNGs, I think the second week of this course covers it: https://class.coursera.org/crypto-preview/lecture
04:20:42 <toki78> http://pastebin.com/WqUKpCt3
04:20:45 <toki78> please help
04:21:01 <Axman6> but if you're doing simulation of some physical system or something, then you probably don't want a CPRNG
04:21:25 <toki78> cryptic errors
04:22:32 <toki78> if some one wants to contribute a real-world example, I would be grateful
04:23:10 <Axman6> toki78: is newRLQ0Agent :: (RLFunctionInterpolator b => b) -> [Double] -> Bool -> a really the type you want?
04:23:22 * Tjr decides to continue coding and leave the PRNG question open for now.
04:23:52 <toki78> Axman6, dont know ... formerly ::  newRLQ0Agent :: (RLFunctionInterpolator b) => b -> [Double] -> Bool -> a
04:24:04 <toki78> Axman6, doenst compile either
04:24:16 <Axman6> that looks more along the lines of what you probably want
04:24:34 <Axman6> also newRLFunctionInterpolator :: b -> a is a very strange type
04:24:52 <toki78> Axman6, why ?
04:25:08 <toki78> Axman6, the explanation is in the comment above
04:25:11 <Axman6> what is the point of b? why not have the type be newRLFunctionInterpolator :: () -> a or newRLFunctionInterpolator :: a
04:25:24 <Axman6> but it must work for _any_ b
04:25:32 <Axman6> there is no restriction on it
04:25:47 <toki78> Axman6, I assume, that implementing instances need seperate parameters
04:26:05 <toki78> "extended parameter set"
04:26:16 <Axman6> but that says that each instance need to be able to produce an a when given something of absolutely any type of all
04:26:48 <toki78> Axman6, okay right
04:27:08 <Axman6> s/of/at
04:27:19 <jamiehannaford> how can I use pattern matching to differentiate between a list and a list of lists (both of unknown length) ?
04:27:22 <toki78> Axman6, how to code an instance,which needs extra params ?
04:27:33 <Axman6> toki78: what are the extra params?
04:27:54 <toki78> Axman6, some instances need no learning rate, some do
04:28:51 <quchen> jamiehannaford: Lists and list of lists have different types.
04:29:05 <quchen> [] is an empty list, [[]] is a list containing a single element, namely an empty list.
04:29:29 <toki78> Axman6, something else : how will this code make it into hackage ?
04:29:44 <toki78> Axman6, after i completetd it
04:29:51 <Tjr> how do I make a data type so that the compiler guarantees it can only ever contain Doubles between 0 and 1?
04:29:57 <Axman6> you could use TypeFamilies to specify what the type of b is there: class Foo a where\ntype FooParams a :: *\n newRLFunctionInterpolator :: FooParams a -> a
04:30:32 <toki78> Axman6, cool idea
04:30:52 <Axman6> then you can make instances which say: instance Foo Bar where\n type FooParams Bar = (Int,Bool)\nnewRLFunctionInterpolator (int,bool) = ...
04:30:52 <quchen> Tjr: The easy way of ensuring this is newtyping Double, and only exporting a smart constructor that ensures all values are in the desired range.
04:31:08 <Tjr> (yes, that's a waste of entropy for random probabilities, but for argument's sake)
04:31:34 <toki78> Axman6, would you be willing to complete my Hurls module ?
04:31:40 <Tjr> quchen: thanks
04:31:41 <Axman6> no
04:31:50 <toki78> okay
04:32:05 <toki78> I would have put it on github
04:32:29 <Axman6> no, if I completed, I would have put it on github :\
04:32:51 <Tjr> without replicating the [] class, is there a way to make the compiler guarantee that my function will only ever get an infinite list passed as argument?
04:33:05 <Axman6> Tjr: no
04:33:13 <quchen> [] is a type (constructor), not a class.
04:33:19 <hpc> data Stream a = Cons a (Stream a)
04:36:08 <Axman6> toki78: what is the code supposed to do anyway?
04:36:25 <pjdelport> Tjr: Depending on how strongly you're concerned with uniformity, you might not want to use doubles.
04:36:45 <pjdelport> Floating-point is a non-uniform representation by design.
04:36:51 <toki78> Axman6, an Q learning agent
04:36:53 <Tjr> pjdelport: indeed, I've changed it to Int already
04:37:07 <toki78> Axman6, pre-Alpha state
04:37:11 <Axman6> toki78: what is that?
04:37:26 <Tjr> (which is marignally better because there's not parametric way to make the spacing finer)
04:37:28 <hpc> pjdelport: it's uniform if you limit yourself to only values with the same exponent bits
04:37:34 <toki78> Axman6, RL agents can learn find a solution for generic problems
04:37:38 <pjdelport> Tjr: Then the next important thing is scaling it correctly for you application.
04:37:41 <pjdelport> your, even
04:37:46 <hpc> which for double is 52 bits
04:39:02 <hpc> at very close to zero, it's uniform for the nearest two exponent bits, because of normalization
04:40:38 <pjdelport> hpc: Right, but I meant it's not uniform for ranges like the above.
04:41:40 <hpc> yeah :P
04:42:23 <toki78> feel free to work on it : https://github.com/toki78/HURLS
04:42:50 <Tjr> speaking of scaling.
04:43:45 <Tjr> In my application, I'm going to need a sequence of Booleans where probability{ x = True } is given.
04:44:34 <Tjr> The wasteful way is to roll a number from LowerBound::Int to UpperBound::Int, and see if it's above or below (-LowerBound::Int + UpperBound::Int ) * probability.
04:44:44 <Tjr> However, that looks like a waste of entropy.
04:44:50 <Tjr> Is there a better way?
04:46:20 <darthdeus> is it a good practice to write IsString instance for newtype wrappers?
04:46:27 <darthdeus> newtype wrappers on strings to be specific
04:47:03 <hpc> depends on why you are wrapping over String
04:48:00 <darthdeus> I just have like 4 types which are essentially strings, but I made type aliases for them so that the signatures are more human readable
04:48:12 <darthdeus> but then I thought I should maybe wrap them in a newtype so I dont mix them together
04:48:55 <hpc> probably a good thing to do then, but i doubt it will be useful
04:49:14 <pjdelport> Tjr: If you can give the probability as a rational, you can do it by only taking as much entropy as the denominator.
04:49:20 <hpc> people will end up using raw String in their code, then pass it to your code as foo (FooString str)
04:49:31 <hpc> and then your code will be immediately unwrapping again for internal use
04:49:39 <pjdelport> Tjr: But if you're using a PRNG, entropy is free, so there's no reason not to just use however much you need. That's the whole point of an efficient PRNG. :)
04:50:08 <darthdeus> hpc: this is mostly for internal purposes, so that I don't have to wrap it everywhere in tests
04:50:39 <Tjr> So you're saying I'd have to worry about that only if I'm using actual randomness, or perhaps a cryptographic PRNG, right?
04:52:33 <toki78> okay thanks to all for you help
04:52:35 <toki78> bye
05:07:22 <steveo_> why are non-exhaustive pattern matched allowed? is there an example where you would want to miss some matches?
05:07:31 <steveo_> *matches
05:07:38 <pjdelport> :t head
05:07:39 <lambdabot> [a] -> a
05:08:01 <f-a> use -Wall steveo_
05:08:17 <pjdelport> steveo_: Sometimes, you know and can prove that only a certain subset of patterns can match, even if the Haskell type system can't prove it.
05:08:39 <Axman6> steveo_: there are plenty of times when you know that certain patterns aren't possible, so matching them could only result in something like a call to error anyway
05:08:47 <pjdelport> For example, using head to unpack a (:) inside a context that already checked that it's not []
05:09:22 <chrisdone> liquid types!
05:09:32 <f-a> indeed, having [a] -> a head fully matched, how would you write head [] = ?
05:09:33 <quchen> > (map head . group) [1,2,3,3,3,3,4,5,5,5,5,6,6,6,6,6] -- safe.
05:09:35 <lambdabot>  [1,2,3,4,5,6]
05:09:43 <quchen> Hey Chris!
05:09:50 <chrisdone> hey quchen
05:10:30 <steveo_> is avoiding to explicitly give undefined or error in those rare instances enough to offset the bugs caused by non-exhaustive patterb matches?
05:12:03 <chrisdone> see also http://community.haskell.org/~ndm/catch/
05:12:18 <Axman6> if you can provide a meaningful result for all possible patterns, then it's definitely frowned upon not to do so. and most haskell users will use -Wall during development do avoid these problems
05:12:27 <pjdelport> steveo_: It depends. It's more accurate to say that Haskell's type system can't always fully prove whether a given pattern match is actually exhaustive or not. You can manually prove that many uses of head are actually exhaustive, for cases where only the (:) constructor can possibly appear.
05:13:01 <pjdelport> As a rule of thumb, you'll always want a comment explaining why partial functions like that are safe in context.
05:13:44 <quchen> pjdelport: What's an example of an un-exhaustiveness-checkable type?
05:13:48 <quchen> Or pattern
05:14:17 <ion> group should be :: [a] -> [NonEmptyList a]
05:14:42 <pjdelport> And yeah, it's often a better idea to avoid the partiality with better types. For example, if you have a Maybe value that's known to be a Just, not a Nothing, unpack it rather than passing the Just around.
05:15:03 <pjdelport> quchen: How do you mean?
05:15:48 <quchen> pjdelport: You said that "Haskell's type system can't always fully prove whether a given pattern match is actually exhaustive or not". Is there an example for this?
05:15:56 <steveo_> pjdelport: I dont understand your argument. haskell cant detect all non-exhaustive pattern matches, therefore lets silently ignore all those it cant detect?
05:15:57 <chrisdone> regarding using partial functions, i think this quote sums it up nicely:
05:15:58 <chrisdone> Always code as if the person who ends up maintaining your code is an axe-wielding psychopath who knows where you live.
05:16:10 <f-a> Amen.
05:16:11 <steveo_> all those it CAN detect, even
05:16:42 <quchen> chrisdone: Two solutions. A) write sane code, B) be the scarier psychopath.
05:17:24 <chrisdone> quchen: perhaps both, just to be safe
05:18:10 <pjdelport> quchen: I just mean things like your example, and many others. Haskell can't necessarily prove whether a use of head is actually safe or unsafe without doing whole-program analysis or much trickier things.
05:18:51 <pjdelport> steveo_: I'm not saying anything should be silently ignored. I'm saying that detecting it is hard to begin with. :)
05:19:43 <pjdelport> That's why it's common to turn warnings on for non-exhaustive pattern matches. And the reason they're warnings instead of errors is that it's not easy to prove that they are errors.
05:20:44 <quchen> pjdelport: Oh, then I misread you. I thought you said that Haskell cannot check whether patterns are exhaustive or not.
05:21:20 <f-a> are there types for which GHC is unable to decide wheter a function is partial or not?
05:21:32 <steveo_> pjdelport: but would it not be better to eer on the safe side and assume they are bugs, and require you to explicitly state they arent (with undefine or whatever)?
05:21:33 <f-a> *whether
05:22:03 <pjdelport> quchen: Oh, right. I intended to mean "exhaustive" in the more general sense that "head xs" is exhaustive iff you've proven that xs is not [].
05:22:25 <yitz> f-a: the general problem of checking whether a function is partial or not in a turing complete language is called the "halting problem".
05:22:48 <yitz> f-a: it is easy to show that it is impossible to solve it in principle.
05:23:11 <quchen> pjdelport: I think "totality checking" is the right word here.
05:23:12 <steveo_> and ghc does not even warn you about it by default. I dont understand why
05:23:27 <pjdelport> steveo_: Yes; that's why libraries like http://hackage.haskell.org/package/safe exist.
05:23:46 <pjdelport> quchen: Right.
05:24:54 <pjdelport> steveo_: To give you an idea of how this can be hard, consider functions on Integer, where you have an infinite number of constructors. Proving whether a given function is exhaustive or not for all possible input integers can become arbitrarily complex (or in fact unprovable even in theory).
05:25:02 <yitz> pjdelport: there's no need for the "safe" library nowadays in my opinion. there are more straightforward ways of avoiding partial functions with the usual functions and types.
05:25:46 <yitz> pjdelport: e.g., use Data.List.NonEmpty instead of regular lists when you feel the need for head, init, tail, etc.
05:26:27 <yitz> pjdelport: and make copious use of Maybe and the many convenient combinators that come with it: maybe, fromMaybe, mapMaybe, catMaybes, listToMaybe, maybeToList...
05:26:39 <Axman6> steveo_: I think the real reason is that sometimes partial functions are useful. Haskell is not so much a language whose goal is to be the safest it can be, it just happens to do a lot of things safely by default
05:26:41 <f-a> pjdelport: a function accepting Integers (with an 'a' in pattern match) is not partial. (it can blow up in a gazillion ways, but still not partial)
05:26:45 <f-a> and *maybe*
05:26:55 <yitz> pjdelport: and of course the Monoid, Monad, and Alternative instances of Maybe.
05:27:10 <steveo_> pjdelport: unless you dont have "catch all" section when pattern matching integer your pattern match is not exhaustive. or am I missing something?
05:27:35 <steveo_> Axman6: but you could still have the with explicit undefine
05:27:52 <yitz> steveo_: if your data type is Data A = B | C | D, just match all three constructors. no need for a catch-all.
05:28:12 <Axman6> steveo_: perhaps, but the result is exactly the same, an exception is thrown telling you the same thing
05:28:15 <f-a> I guess he's referring to an Integer like type
05:28:15 <pjdelport> steveo_: You can have guards on the pattern matches that require arbitrarily complex number theory to prove that they are total in combination.
05:28:50 <steveo_> yes, I was talking about Integer
05:29:22 <pjdelport> As f-a points, out, it depends a bit on whether you consider such guards part of the pattern or not, and at what level you consider them partial or not.
05:29:37 <pjdelport> (+6+I'm speaking a bit more loosely.)
05:29:57 <f-a> indeed _ = undefined is quite... partial
05:30:19 <pjdelport> (Sorry, my cat typed the +6+ :)
05:30:28 <Axman6> heh
05:30:33 <yitz> steveo_: f n | isDifferenceOfTwoPrimes n = ... -- ok, do we need another equation?
05:31:02 <pjdelport> Exactly. :)
05:31:03 <steveo_> pjdelport: that is a good point. but still, is it a good idea that just because ghc cant detect all non-exhaustive pattern matches that it does not report as errors (or even warnings by default) those that it can?
05:31:11 <Axman6> that clearly matches all numbers n
05:31:52 <pjdelport> steveo_: Well, it would simply be wrong to report them as errors if they aren't.
05:32:27 <yitz> steveo_: you mean as opposed to warnings?
05:32:40 <pjdelport> And whether they're reported as warnings or not by default is a fiddly preference. GHC happens not to, but you can make it report them by default just as easily. So if you're concerned about them, that's what you should do. :)
05:32:54 <Axman6> steveo_: people have been using Haskell safely for 25-30 years with that being the default and it hasn't been a huge cause of errors
05:32:58 <steveo_> pjdelport: is that worse than a silent bug?
05:33:23 <f-a> fact is that when happens, it's quite annoying Axman6
05:33:33 <steveo_> especially when it would be rare and very easy to fix (with explicit undefine)
05:33:38 <f-a> now I always |case| head and the like
05:33:42 <pjdelport> steveo_: It's just one of an unlimited number of kinds of silent bugs that GHC can't reliably detect and report in general.
05:33:45 <Axman6> f-a: sure, don't write code like that then :P
05:33:48 <pjdelport> It's clever, but it's not magic.
05:33:53 <f-a> haha true Axman6
05:34:02 <yitz> personally i recommond turning on those warnings, and paying attention to the warnings when they occur (i.e., fix the code to remove the warning, don't just say "never mind that one, i know it's ok")
05:34:04 <pjdelport> steveo_: You can enable many warnings, but then you have to sift through the false positives too.
05:34:49 <f-a> well, you had to look at it closely at least, and you are aware it's a false positive
05:35:16 <Axman6> sometimes you're just using a pattern match to deconstruct a value you know has a certain form, it would be inconvenient to need to specify the _ case everytime just to throw an exception
05:35:17 <f-a> (I mean, warnings help you)
05:35:53 <f-a> a one liner which could save your back to be honest
05:36:02 <steveo_> pjdelport: yes, I have. I prefer false positives over silent bugs, and cant see why people behind the ghc dont feel the same. does not seem to be in the spirit of haskell, that usually values correctness over convenience
05:36:12 <f-a> we're not lisper, (at least I am not), not used to see things blow up at runtime
05:36:29 <yitz> Axman6: if that happens, ghc is telling you that your code is badly desinged. or that this "pattern match" should return a Maybe. one or the other.
05:37:29 <f-a> steveo_: still, many many tutorials / videos + every haskell app I compiled myself have -Wall on, suggest -Wall on or the like. I guess someone had to call the shot and having to add -Wall was considered a minor annoyance.
05:39:01 <f-a> I wonder how other languages (compilers/interpreters rather) handle warnings (if mandatory or else)
05:46:31 <pjdelport> steveo_: It's always a tradeoff. Here's some interesting discussion, perhaps: http://www.reddit.com/r/haskell/comments/8l5ud/should_ghc_wall_be_the_default/c09nisz
05:47:18 <pjdelport> steveo_: doliorules mentions Neil Mitchell's four test examples: three of the four are unsafe, but -Wall only gives a warning about the safe one, and not for the unsafe ones.
05:48:42 <Para_> I'm having trouble finding the error here (the error message is n the paste): http://lpaste.net/105623 I'm sure its an easy fix, but I thought the fromIntegral would fix the issue I'm having, but its not.
05:48:46 <Para_> so I'm not quite sure how to fix it
05:48:50 <pjdelport> steveo_: In other words, a dedicated tool like http://community.haskell.org/~ndm/catch/ does a much better job than -Wall
05:50:37 * hackagebot wai-predicates 0.7 - WAI request predicates  http://hackage.haskell.org/package/wai-predicates-0.7 (ToralfWittner)
05:51:19 <f-a> Para_:
05:51:23 <f-a> > :t sqrt
05:51:25 <lambdabot>  <hint>:1:1: parse error on input ‘:’
05:51:29 <f-a> err
05:51:36 <Para_> :t sqrt
05:51:37 <lambdabot> Floating a => a -> a
05:51:40 <f-a> :P
05:51:43 <f-a> thanks
05:51:43 <Para_> I don't think you need the >
05:51:44 <Para_> :)
05:51:50 <Para_> okay, so you need a Floating
05:52:01 <Para_> :t fromIntegral
05:52:02 <lambdabot> (Num b, Integral a) => a -> b
05:52:13 <Para_> yeah, so it makes an integral into a Num
05:52:28 <Para_> and floating is a subclass/type (Not sure of the terminology) of Num, isn't it?
05:52:42 <Tjr> what's the version of "fst" that works on triples?
05:52:54 <Axman6> there is none, use pattern matching
05:52:57 <f-a> well, (Floating b, Integral b, Num c) => b -> c
05:53:07 <Axman6> well, there's probably a lens, but... just pattern match
05:53:33 <Para_> wait what do you mean?
05:53:42 <Para_> :t sqrt . fromIntegral
05:53:43 <lambdabot> (Integral a, Floating c) => a -> c
05:53:50 <f-a> Tjr: if you *really* want it, look into lenses. But again, pattern matching (a simple lambda like \(a,_,_) -> a) is way more clean
05:54:11 <Para_> wait
05:54:18 <Para_> :t >
05:54:19 <lambdabot> parse error on input ‘>’
05:54:23 <Para_> :t (>)
05:54:24 <lambdabot> Ord a => a -> a -> Bool
05:54:29 <Para_> ohhhh
05:54:30 <Para_> ok
05:54:34 <f-a> ^^d good boy
05:54:35 <Tjr> prolly I'll reorganize my code to use (first, (second, third )) -- still better than an extra lambda
05:54:37 <Para_> so everything needs to be the same typ
05:54:38 <Para_> type
05:54:39 <Para_> :)
05:54:54 <Axman6> Tjr: I don't agree :\
05:55:07 <f-a> Tjr: you mean, write your own accessors?
05:55:15 <Tjr> what are acessors?
05:55:28 <f-a> first (a,_,_) = a
05:55:30 <yitz> @botsnack
05:55:30 <lambdabot> :)
05:56:04 <Axman6> first is already a well known function that doesn't do that, I wouldn't use that name
05:56:37 <f-a> if you really want to get that way, use lenses
05:56:52 <f-a> they have something like (forgot ysntax) tup ^ _1
05:56:54 <Para_> thanks f-a :)
05:57:04 <f-a> you helped yourself Para_ ^^d
05:57:09 <yitz> Tjr: when you start needing to ask questions like that, it probably means that you should define a meaningful datatype instead of an n-tuple.
05:57:16 <Para_> I'd been stuck with this for like an hour
05:57:27 <Para_> I thought that Haskell did type coercion automatically so I never really thought of it
05:57:30 <Tjr> yitz: I need it only for a fold
05:57:36 <Para_> @pl (\p -> (sqrt . fromIntegral $ n) > fromIntegral p)
05:57:36 <lambdabot> (sqrt (fromIntegral n) >) . fromIntegral
05:58:06 <f-a> * ^.
05:58:18 <Para_> hm?
05:58:30 <f-a> correcting my previous post (on lenses)
05:58:31 <yitz> Tjr: yeah sometimes i do use throw-away tuples. but if it starts getting even the slightest bit messy, it's really not hard to define a data type.
05:58:32 <Para_> ah
05:58:53 <edwardk> > (1,2,3)^._1
05:58:55 <lambdabot>  1
05:59:14 <edwardk> > (1,2,3) & _1 +~ 2
05:59:15 <lambdabot>  (3,2,3)
06:00:48 <Para_> :t revers
06:00:49 <lambdabot>     Not in scope: ‘revers’
06:00:49 <lambdabot>     Perhaps you meant one of these:
06:00:49 <lambdabot>       ‘reverse’ (imported from Data.List),
06:00:50 <Para_> :t reverse
06:00:51 <lambdabot> [a] -> [a]
06:17:29 <Tjr> Is there a version of div that returns only positive remainders?
06:18:08 <PragCypher> https://gist.github.com/PragmaticCypher/7c887ead785c46c398e9
06:18:45 <f-a> div doesn't return reminders, Tjr . `rem` does!
06:18:50 <f-a> > rem 7 (-3)
06:18:52 <lambdabot>  1
06:19:04 <Tjr> >mod 7 (-3)
06:19:29 <Tjr> > mod 7 (-3)
06:19:31 <lambdabot>  -2
06:19:53 <Tjr> thanks
06:19:58 <f-a> you are welcome
06:20:16 <f-a> check the prelude to see how they are defined
06:21:35 <PragCypher> sorry wrong msg channel :|
06:23:31 <tristanStrange> hey all. what's the best graphics library for someone coming from a processing background?
06:24:15 <Cale> tristanStrange: I dunno. Gloss is a pretty nice way to get stuff on the screen quickly, but it's somewhat simplistic as it stands.
06:24:54 <tristanStrange> cheers Cale. I'll take a peek
06:25:00 <Cale> It probably depends on what exactly you're trying to get done
06:25:24 <Cale> There are bindings to OpenGL and such. There's a lovely library called "diagrams" for static 2D graphics.
06:25:58 <tristanStrange> I'm after something that I can do interactive/animation type things in really...
06:26:01 <cloudhead> tristanStrange: I agree with the Gloss recommendation
06:26:04 <tristanStrange> diagrams is fun tho
06:26:16 <cloudhead> it's easy to get started with it
06:26:58 <cloudhead> And the closest thing I can think of to processing in functional land
06:27:15 <cow_2001> what's up with helm
06:27:42 <cow_2001> gloss is amazing :|
06:28:15 <tristanStrange> sweet. gloss it is then! cheers guys!
06:29:51 <Tjr> how do I make a "where" span accross guards?
06:30:04 <Cale> Tjr: It already does
06:30:40 <Tjr> it doesn't, sadly
06:30:41 <Tjr> http://lpaste.net/105625
06:30:42 <cow_2001> give your guards walkie talkies so they can all be updated at once with regard to "where"
06:30:56 <Cale> Tjr: Don't pattern match more than once
06:31:10 <Cale> Tjr: where spans multiple guards, but not multiple pattern matches
06:31:19 <Tjr> there's no pattern matching going on here
06:31:22 <yitz> tristanStrange: there is also a binding to libgd
06:31:38 <Cale> Tjr: i.e. replace the second and third "rnd_select rands n list" with whitespace
06:31:52 <Tjr> Cale: ok, thanks, now I understand
06:32:14 <ClaudiusMaximus> Tjr: i annotated your paste with cale's suggestion
06:33:19 <Tjr> thanks, that "works" as in fails elsewhere :-)
06:52:10 <Tjr> http://lpaste.net/105627
06:52:34 <Tjr> How do I make a "member function" (inside a where) take the same polymorphic type "n" as the parent function?
06:54:43 <Tjr> > let { f:: (Num n) => n -> n ; f x = x + boo x where {boo :: n -> n ; boo y = 2*y } }
06:54:44 <lambdabot>  not an expression: ‘let { f:: (Num n) => n -> n ; f x = x + boo x where {boo...
06:55:13 <Tjr> how do I force "boo" to have the same type as "f"?
06:55:53 <Tjr> > let { f:: (Num n) => n -> n ; f x = x + boo x ;  where {boo :: n -> n ; boo y = 2*y } }
06:55:54 <lambdabot>  <hint>:1:50: parse error on input ‘where’
06:56:53 <Tjr> > let { f:: (Num n) => n -> n ; f x = boo x  where {boo :: n -> n ; boo y = y } }
06:56:54 <lambdabot>  not an expression: ‘let { f:: (Num n) => n -> n ; f x = boo x  where {boo ::...
06:57:13 <Tjr> > let { f:: (Num n) => n -> n ; f x = boo x  where { boo y = y } }
06:57:15 <lambdabot>  not an expression: ‘let { f:: (Num n) => n -> n ; f x = boo x  where { boo y...
06:57:20 <Tjr> > let { f:: (Num n) => n -> n ; f x = boo x  where  boo y = y  }
06:57:22 <lambdabot>  not an expression: ‘let { f:: (Num n) => n -> n ; f x = boo x  where  boo y ...
06:57:56 <Tjr> > let { f:: (Num n) => n -> n ; f x = boo x  ;  boo y = y  }
06:57:57 <lambdabot>  not an expression: ‘let { f:: (Num n) => n -> n ; f x = boo x  ;  boo y = y  }’
06:58:01 <Cale> Tjr: You could just leave out the type signature, or else turn on the ScopedTypeVariables extension and add a "forall n." to the type of rnd_select
06:58:47 <Tjr> The type signature is the purpose, for debugging
07:00:21 <Cale> Then yeah, you'll want to add {-# LANGUAGE ScopedTypeVariables #-} to the top of your file
07:00:48 * hackagebot wai-route 0.2 - Minimalistic, efficient routing for WAI  http://hackage.haskell.org/package/wai-route-0.2 (romanb)
07:01:17 <Tjr> Cale: thanks. You can read minds :-)
07:09:17 <Tjr> how do I convert an Int into an (Integral n, Ord n) => n ?
07:09:50 <ion> fromIntegral
07:09:54 <hpc> @src Num
07:09:54 <lambdabot> class  (Eq a, Show a) => Num a  where
07:09:54 <lambdabot>     (+), (-), (*)           :: a -> a -> a
07:09:54 <lambdabot>     negate, abs, signum     :: a -> a
07:09:54 <lambdabot>     fromInteger             :: Integer -> a
07:10:05 <Tjr> thank you
07:10:05 <hpc> @src Integral
07:10:05 <lambdabot> class  (Real a, Enum a) => Integral a  where
07:10:05 <lambdabot>     quot, rem, div, mod :: a -> a -> a
07:10:05 <lambdabot>     quotRem, divMod     :: a -> a -> (a,a)
07:10:05 <lambdabot>     toInteger           :: a -> Integer
07:10:17 <hpc> do you get Ord out of that too?
07:10:31 <jhance> Yes
07:10:48 <jhance> Well, I would think so
07:10:59 <jhance> Assuming Ord a => Real a
07:11:04 <zwer> Num does not require Ord, not sure about Integral
07:11:19 <hpc> yeah, Real depends on Ord
07:11:49 <hpc> Tjr: you should hopefully get a warning about Ord being a pointless constraint, btw
07:11:50 <ion> > (fromIntegral :: (Integral n, Ord n) => Int -> n) 42 > 0
07:11:52 <lambdabot>  True
07:12:00 <Tjr> hpc: nope
07:12:16 <Tjr> haskell is very much not perfect when it comes to math
07:12:34 <klrr_> if i have an AST and wanna apply a function across all some thing X, is it a Traversable instance for the AST i want?
07:13:58 <c_wraith> woo!  Type-level nats being Typeable has just gone into 7.9.  Ah, the future, where GHC is a better place than it is now...
07:14:20 <klrr_> or is it simply fmap i want?
07:15:17 <ion> You can add additional constraints to fromIntegral, it doesn’t care. It’s you the caller who in the end will provide a concrete type that will have to match the constraints.
07:15:19 <steveo_> will new haskell platform come with ghc 7.8 or will it wait for new major version?
07:16:33 <yitz> steveo_: 7.8.3
07:16:51 <yitz> steveo_: it has waited quite long enough
07:17:04 <steveo_> when is the release expected?
07:17:28 <yitz> right now hoping about end of this month
07:17:43 <steveo_> great
07:18:58 <Tjr> ion: :-)
07:20:41 <Tjr> > stdGen <- getStdGen
07:20:42 <lambdabot>  not an expression: ‘stdGen <- getStdGen’
07:21:30 <Tjr> :t getStdGEn
07:21:31 <lambdabot>     Not in scope: ‘getStdGEn’
07:21:31 <lambdabot>     Perhaps you meant one of these:
07:21:31 <lambdabot>       ‘getStdGen’ (imported from System.Random),
07:21:32 <Tjr> :t getStdGen
07:21:33 <lambdabot> IO StdGen
07:21:49 <Tjr> > do stdGen <- getStdGen
07:21:50 <lambdabot>  The last statement in a 'do' block must be an expression
07:21:50 <lambdabot>    stdGen <- getStdGen
07:22:12 <Tjr> > do stdGen <- getStdGen ; return stdGen
07:22:14 <lambdabot>  No instance for (Data.Typeable.Internal.Typeable
07:22:14 <lambdabot>                     System.Random.StdGen)
07:22:14 <lambdabot>    arising from a use of ‘M28710635283370176297479.show_M28710635283370176297...
07:22:34 <steveo_> are overloaded record fields part of 7.8.3?
07:23:02 <Tjr> > stdGen
07:23:03 <lambdabot>  Not in scope: ‘stdGen’
07:23:25 <Tjr> Why does GHCI give me a stdGen, but not lambdabot?
07:23:37 <pjdelport> Tjr: You can /query lambdabot, by the way. :)
07:24:13 <ion> tjr: Btw, use newStdGen instead of getStdGen.
07:24:37 <ion> tjr: lambdabot does not let you do IO or other dangerous things.
07:25:01 <Tjr> ok, so lambdabot already has a stdGen.
07:25:14 <Tjr> hence new
07:26:00 <steveo_> does newStdGen not serve a different purpose than getStdGen?
07:26:09 <Tjr> indeed
07:26:14 <Tjr> new... clones one
07:26:29 <Tjr> get... copys the one from the default system entropy pool
07:26:43 <yitz> > take 20 . randomRs (1,10) $ mkStdGen 12345
07:26:45 <lambdabot>  [4,2,1,10,6,4,5,8,10,9,10,7,4,1,8,7,8,2,2,7]
07:27:00 <ion> Two invocations of getStdGen can return the same generator.
07:27:08 <Tjr> mk... makes a deterministic random number generator, which is what I'd like to avoid
07:27:50 <steveo_> why would you need two though?
07:28:09 <Tjr> because people told me I'm not allowed to use get..
07:28:25 <Tjr> and told me to use new
07:29:17 <yitz> steveo_: getStdGen gives you a repeatable generator within each run of your program. mkStdGen is repeatable always, even across different runs. newStdGen is different every time, even with the same run.
07:29:51 <steveo_> I fetch one stdgen with getStdGen and that is it, I keep reusing stdgen returned from the random functions. is that not how youre suppose to do it? newStdGen only seems useful for parallel work
07:30:24 <yitz> steveo_: newStdGen is useful in ghci too.
07:30:55 <Tjr> steveo_: I'd do it that way, too, except that getStdGen isn't accessible
07:31:15 <toki78> hi http://pastebin.com/DcWXpYdx --- I changed my code a bit -- and I still do not understand the error
07:32:30 <cow_2001> can you install yesod in ~/.cabal and still use cabal sandbox?
07:32:46 <toki78> interpolar maches b, doesn't it ?
07:35:34 <Tjr> This works with lambdabot, but not with GHCI. Ambiguous type variable `a' in the constraint:  `Random a'
07:35:34 <Tjr> > take 1 . randoms $ mkStdGen 10
07:35:34 <Tjr> How do I fix that?
07:35:36 <lambdabot>  [-2776415066813205131]
07:36:21 <zwer> fix what?
07:36:24 <c_wraith> Tjr: you provide GHC enough information to figure out what type you mean
07:36:37 <c_wraith> Tjr: ghci guesses when it doesn't have enough information
07:36:47 <c_wraith> Tjr: GHC does not guess, because it doesn't want to be wrong
07:36:47 <pjdelport> Tjr: monomorphism restriction
07:36:52 <c_wraith> pjdelport: no it's not
07:37:06 <c_wraith> pjdelport: it's ExtendedDefaulting
07:37:09 <yitz> toki78: why are using such complicated types?
07:37:13 <pjdelport> Tjr: If you set :set -XNoMonomorphismRestriction, ghci should work
07:37:17 <yitz> *you
07:37:34 <pjdelport> c_wraith: It's not? Disabling the DMR makes it work for me.
07:37:58 <toki78> yitz, I don't know how to do it more simply
07:37:58 <Tjr> pjdelport: indeed, it doesn't complain anymore
07:38:05 <c_wraith> pjdelport: it needs to be monomorphic to print it
07:38:44 <Tjr> and in the example with randomRs, the type of the interval bounds were enough to make it print, right?
07:39:16 <yitz> toki78: your definition for RLQ0Agent only allows undefined (or error) as the value of rlfInterpolator
07:39:38 <c_wraith> Tjr: yeah, when you provide bounds, that pins down the type
07:39:45 <yitz> toki78: whereas in that instance declaration you are trying to assign it a specific value
07:40:51 <toki78> yitz, why "undefined " ?
07:41:26 <toki78> yitz, the record should accept any instance,which is a interpolator
07:41:28 <klrr_>  what is considered best to use, mtl or transformers if you simply want State monad?
07:41:37 <klrr_> or is State in base?
07:43:00 <yitz> toki78: but interpolator is a type class. so what do you mean be "is an interpolator"? a data item can't be an interpoator, only a type can be one.
07:44:00 <toki78> yitz, I mean, the record field should receive any data, for which interpolator is implemented
07:44:28 <toki78> yitz, must it be a concrete instance ?
07:45:19 <yitz> toki78: are you trying to emulate OO concepts in haskell? that's possible, but complicated, and not idiomatic. usually you really want a totally different approach.
07:45:54 <toki78> yitz, yes, I am an OOer
07:46:01 <yitz> toki78: a type class in haskell is a very differnt concept than a "class" in OO.
07:46:18 <yitz> toki78: it's kind of like an interface. but not exactly.
07:46:41 <toki78> yitz, what would be the haskell approach for this ?
07:48:17 <toki78> yitz, in java : class RLQAgent { FunctionInterpolator interpolator, State previousState... and so on
07:48:28 <augur> i wonder if its possible to define san infinite number in haskell, and have haskell print only up to some precision
07:49:05 <toki78> augur, infinitely high or infinitely precise ?
07:49:17 <augur> infinitely precise, sorry
07:49:32 <yitz> toki78: perhaps data RLQAgent = RLQAgent Interpolater State ...
07:49:55 <yitz> toki78: i have to run now tho. hope others will pick up on this...
07:50:06 <toki78> yitz, that might be the solution, I will try
07:50:22 <toki78> yitz, thx a lot, bye
07:52:05 <yac> how do I get a group match from regex?
07:54:00 <c_wraith> augur: absolutely.  CReal is basically that - its precision is sort of limited artificially by choice of representation, but that could be fixed.
07:54:01 <yac> http://pastebin.blesmrt.net/show.php?id=11594 this is all I could get so far
07:54:30 <augur> c_wraith: well what i was thinking was, something analogous to infinite lists in haskell
07:54:40 <augur> where you can compute an arbitrary prefix of them
07:54:50 <c_wraith> augur: CReal does give you an arbitrary prefix
07:55:00 <augur> interesting!
07:55:42 <augur> actually i suppose whats necessary for what im thinking isnt an arbitrary prefix.. hmm
07:55:58 <augur> oh, then what i intend is definitely possible, yes
07:56:47 <toki78> still the same problem
07:56:50 <toki78> :(
07:57:23 <c_wraith> augur: a better representation for your purposes might be a list of successively improving intervals. (and some rule such as "the interval is at least cut in half every step" to prove it converges)
07:57:47 <augur> c_wraith: actually i just realized that a converging series was more appropriate
07:58:04 <c_wraith> augur: well there you go. :)
07:58:34 <augur> c_wraith: so if you did   let s = s0 : map step s in s !! n   you get arbitrarily close to the answer you want
07:59:12 <augur> so probably there's a good case for making that a pattern   series base step = let s = base : map step s in s
08:00:00 <c_wraith> augur: just be sure that your internal representation in step doesn't lose precision. Integer and Rational all the way!
08:00:08 <augur> indeed
08:00:22 <augur> :t \base step -> let s = base : map step s in s
08:00:23 <lambdabot> a -> (a -> a) -> [a]
08:00:44 <augur> wait, this is pretty close to being an unfold
08:00:58 <c_wraith> actually, it's iterate
08:01:06 <c_wraith> well, flip iterate
08:01:11 <augur> is it? hm
08:01:17 <augur> :t iterate
08:01:18 <lambdabot> (a -> a) -> a -> [a]
08:01:23 <augur> @src iterate
08:01:23 <lambdabot> iterate f x =  x : iterate f (f x)
08:01:41 <augur> aha
08:02:30 <c_wraith> an unfold might be a better represntation, though.
08:02:43 <c_wraith> because then you can have internal state that isn't part of the output list
08:02:50 <augur> indeed
08:03:21 <augur> not using numeric types would be good tho
08:03:36 <augur> you wouldnt have to just make a number more precise, but anything at all
08:03:37 <monochrom> @type unfoldr
08:03:38 <lambdabot> (b -> Maybe (a, b)) -> b -> [a]
08:03:56 <augur> @hoogle (b -> (a,b)) -> b -> [a]
08:03:58 <lambdabot> No results found
08:04:14 <augur> hm. streamUnfold!
08:04:17 <c_wraith> yep
08:04:21 <hexagoxel> toki78: you can use existential quantification, i think. no promise that that would be good design, though
08:04:27 <augur> but it doesnt exist. alas!
08:04:36 <augur> @hoogle Stream
08:04:36 <lambdabot> Network.HTTP.Stream module Network.HTTP.Stream
08:04:36 <lambdabot> Network.Stream module Network.Stream
08:04:36 <lambdabot> GHC.IO.Device Stream :: IODeviceType
08:04:41 <augur> eesh
08:09:27 <yac> hm
08:09:41 <yac> I'm using Network.HTTP to get a webpage witih getResponseBody
08:09:56 <yac> but when I try to regexp it, it fails on utf character not matching
08:10:09 <yac> but the body response is String
08:10:22 <yac> when I test the regexp on sscce on ghci it works
08:13:44 <benzrf> why are you using regex
08:15:26 <yac> benzrf: because it's the simplest way
08:15:42 <benzrf> yac: how new are you to haskell
08:24:55 <yitz> yac: there are a number of parser libraries in haskell that most people feel are much simpler, more powerful, and safer than regexes. so regexes are not very popular here.
08:25:27 <yitz> yac: but we do have full support for regexes, mostly via bindings to standard c libs like pcre, for backporting, etc.
08:26:16 <toki78> Hi
08:26:20 <Cale> hello
08:26:20 <dfeuer> Can anyone explain how to write clear Haskell code that will reliably be made branchless?
08:26:20 <toki78> it works :)
08:26:26 <yitz> toki78: hi i'm back. oh great!
08:26:33 <toki78> look at this,
08:26:52 <yitz> dfeuer: map over a list instead of looping
08:27:10 <Cale> dfeuer: I doubt that's reasonable to attempt
08:27:14 <toki78> yitz, http://pastebin.com/BpsQbLnL
08:27:31 <toki78> yitz, look that you don't fall off the chair
08:27:45 <toki78> yitz, the code is even more complicated now
08:28:00 <d3lxa> anyone has had a problem with Warp behind lighttpd (proxy)? got problems with chunked encoding, anyone?
08:28:06 <Cale> dfeuer: At least, if I understand what you mean by "branchless"
08:28:45 <toki78> yitz, my first bigger project, and such big problems :)
08:28:47 <Cale> dfeuer: I suppose if you unbox everything
08:28:49 <dfeuer> yitz, I don't think that makes any sense. Cale, it's certainly possible to write *unclear* code that will do so using all sorts of crazy stuff with Data.Bits, and it's also possible to write clear code that GHC/LLVM will make branchless if it feels like it,
08:29:07 <dfeuer> but the question is what sorts of rules to follow to ensure the latter.
08:29:44 <Cale> dfeuer: Every thunk is a code pointer, so if code is branchless, it can't enter any thunks.
08:29:50 <toki78> yitz, the RankNTypes are not necessary
08:30:33 <dfeuer> Cale, I'm talking about the small, rather than the large. Specifically, I'm currently thinking about divMod and an alternative, "Euclidean" divMod.
08:31:03 <yitz> dfeuer: ah you mean branchless in the object machine code?
08:31:43 <dfeuer> yitz, yes.
08:31:52 <identity> Does someone know of a decent library that display trees / generate graphviz dot files for display?
08:32:07 <yitz> toki78: like i said, if you try to write haskell in OO style, you are in for complexity. there's rarely any good reason to do that.
08:32:09 <Cale> Well, is entering a code pointer necessarily a branch, or only conditional jumps count?
08:32:40 <Cale> er, bbiab
08:32:41 <dfeuer> Cale, I was specifically thinking about conditional jumps.
08:32:48 <ReinH>  M
08:32:53 <yitz> toki78: i'm also an OO programmer - but not when i'm writing haskell :)
08:32:54 <ReinH>   
08:32:59 <toki78> yitz, yepp, but I do not know, how to do it without OO
08:33:41 <ReinH> toki78: what are you trying to do?
08:33:58 <dfeuer> toki78, I don't know what you're working on, but some problems are more suitable for functional programming and others for OO. It's always possible to do them another way, but it may not be much fun.
08:34:44 <toki78> I am implementing a RL library for Haskell with NeuralNets and stuff like that
08:34:56 <yitz> toki78: RL?
08:35:19 <toki78> yitz Reinforcement Learning -- the best AI algorithm, I know
08:35:46 <jmcarthur> i used to do the OO thing as well, but honestly, i now can't think of any problems for which it is well suited. :\
08:36:02 <jmcarthur> also, functional programming and OO programming are not mutually exclusive
08:36:44 <jmcarthur> i also disagree that OO is so hard to do in Haskell
08:37:29 <jmcarthur> but you have to be used to FP in haskell first
08:37:58 <toki78> how to generate float randoms ?
08:38:07 <jmcarthur> :t random
08:38:08 <lambdabot> (Random a, RandomGen g) => g -> (a, g)
08:38:11 <toki78> (f,seed) = randomF seed ?
08:38:23 <toki78> jmcarthur, thx
08:39:10 <klrr_> what are the other uses of Lens besides record types?
08:46:02 * hackagebot data-endian 0.1 - Endian-sensitive data  http://hackage.haskell.org/package/data-endian-0.1 (MikhailVorozhtsov)
08:51:34 <yitz> jmcarthur: i didn't say it's hard. though as you say, it is if you're not comfortable with fp yet. i said it adds complexity. unneeded complexity, almost always.
08:53:53 <yitz> klrr_: lens freaks use them for any kind of traversal or zip, as well as getters and setters, over any kind of collection of data.
08:54:05 <edwardk> =P
08:54:07 <yitz> klrr_: they probably also use them to make breakfast
08:55:05 <edwardk> klrr_: i use them to edit maps, sets, act as constructors, provide generic zippers into things, to term rewriting, swap out type variables for a different type in a syntax tree, etc.
08:56:01 <toki78> this is, what I wanted, and it compiles !! *yeah*
08:56:01 <klrr_> that last thing sounds very interesting
08:56:05 <toki78> https://github.com/toki78/HURLS/blob/master/Hurls.hs
08:56:06 <edwardk> lenses for breakfast could be interesting. i mean with them you could in theory make an omelette without breaking the eggs with the right lens ;)
08:56:29 <zomg> edwardk: this is starting to sound like quantum physics
08:57:02 <edwardk> i was mostly flashing back to the first atrocity archives book with that comment, but that could work ;)
08:57:02 <toki78> edwardk, it works now :)
08:57:32 <edwardk> toki78: i'd recommend changing: data (RLFunctionInterpolator a) => RLQ0Agent a = RLQ0Agent {  to data RLQ0Agent a = RLQ0Agent {
08:57:39 <edwardk> you get no benefit from the DataTypeContext
08:58:02 <edwardk> and you give up the ability to make a Functor, Foldable, Traversable, etc.
08:58:30 <ReinH> +1 there's a reason it's deprecated.
08:58:44 <edwardk> you can keep the constraint on the instance, as that is where the constraint is used, but there is no point in just randomly making a user pass you a dictionary you aren't going to use when constructing one
08:59:22 <benzrf> RLFunctionInterpolator
08:59:22 <benzrf> wtf
08:59:23 <klrr_> this might be too much to ask, but is there some general way of taking a data constructor in a syntax tree and "move it to the top" using another constructor?
08:59:38 <toki78> edwardk, is that better practice ?
08:59:45 <benzrf> klrr_: what do you mean by 'move it to the top'
08:59:51 <edwardk> by far
09:00:07 <toki78> edwardk, so I use, what you posted
09:00:14 <edwardk> yeah
09:00:22 <edwardk> change that one line, nothing else changes
09:00:26 <edwardk> everything still works
09:00:30 <toki78> edwardk, do I need RnakNTypes any more ?
09:00:39 <benzrf> toki78: if u still have the constraint, yes
09:00:43 <klrr_> well, i got two datatypes, a list of definitions or "top level expressions", then i have a datatype representing the actual AST of the code, i want to move some data constructors in the AST (lambdas to be precies) to the list of definitions datatype
09:00:49 <edwardk> you're not using it now
09:01:05 <benzrf> toki78: ignore me edwardk has more context
09:01:25 <benzrf> klrr_: can you paste a miminal example
09:01:49 <klrr_> benzrf: sure
09:03:15 <toki78> benzrf, okay :)
09:04:14 <toki78> Hurls.hs:47:14:
09:04:15 <toki78>     Cannot use record selector `rlfInterpolator' as a function due to escaped type variables
09:04:21 <toki78> edwardk, ?
09:05:09 <klrr_> benzrf: https://gist.github.com/klrr/a82734b05a528e5441db
09:05:42 <edwardk> toki78: all i changed was to data RLQ0Agent a = RLQ0Agent {
09:05:46 <edwardk> and it works fine
09:05:55 <edwardk> no other lines change other than deleting the use of DatatypeContexts
09:06:20 <toki78> edwardk, but the constrint is important
09:06:25 <edwardk> no, it isn't
09:06:30 <edwardk> its important at the _use_ site
09:07:02 <toki78> edwardk, it must be ensured, that this class is implemented for a
09:07:04 <edwardk> it oesn't get store in the object. it merely becomes an ugly invariant you have to pass to the constructor that promptly gets ignored, not stored for later use
09:07:06 <klrr_> benzrf: i could do this with some recursion and state, just wonder if it have some general way like so many things do in haskell ;)
09:07:26 <edwardk> toki78: please just change that one line, leave the constraint on the instance, and you'll see it works. the constraint is in plac for the instnce.
09:07:38 <toki78> aah
09:07:42 <edwardk> instance RLFunctionInterpolator a => RLQAgent (RLQ0Agent a) a where -- still requires the instance.
09:08:14 <edwardk> you can now have any sort of RLFunctionInterpolator you want, you can make a Functor for it, Foldable, Traversable instances, etc.
09:08:16 <toki78> edwardk, cool ! works !
09:08:23 <edwardk> it can participate in lots of standard classes now
09:08:52 <edwardk> before with the constraint every single combinator you wanted to write for it had to be a one-off deal
09:08:56 <toki78> edwardk, how can I contribute this to hackage / cabal ?
09:09:36 <edwardk> you can write a package for it. mght make sense to just throw it on github as it is your sort of first fumblings in this direction and you may find a better API later on as you get more experience
09:10:30 <toki78> edwardk, so I leave it on github
09:10:43 <toki78> and contribute later, when more experienced
09:10:49 <edwardk> e.g. storing the seed in the RLQ0Agent may not be the best design. perhaps you should merge the [Double] and Bool into a single data type, etc.
09:11:05 <toki78> ok
09:11:20 <edwardk> there are a lot of designs to explore
09:11:35 <Cale> toki78: In my experience, you can do OO just fine in Haskell, but type classes don't usually factor into it so much.
09:11:45 <edwardk> i tend to push stuff up to hackage as it becomes more mature and once i've built a couple of things on top to test that I like the design
09:12:06 <edwardk> toki78: it is probably worth going through the motion of cabal'izing the package so you know how thoug
09:12:16 <toki78> edwardk, yes, good practice.. I need a GTK exmple program first
09:12:30 <deni> hmm so i have this function: readConfig :: SourceName -> IO (Either ParseError Config)
09:12:30 <edwardk> i do tend to burn through a half dozen APIs before i find one i'm happy with thoug
09:12:33 <edwardk> though
09:13:00 <deni> it reads a config files that has an apikey.id and apikey.secret in it..and it either succeeds or it fails.
09:13:02 <Cale> toki78: The usual thing is just forming objects as records with function fields, and whose "private" members are simply parameters to the functions which construct those records. There's a pure translation where you have methods that would otherwise alter the object simply return a new version of the object (by recursively applying the function you're defining to construct it in the first place)
09:13:15 <toki78> edwardk, well, I use lots of depricated extensions -> also bad ?!?
09:13:36 <Cale> toki78: Or of course, if you want to use mutation, you can have methods which involve IO actions
09:13:43 <edwardk> if the extension is deprecated it is probably worth studying the reason
09:13:50 <deni> now i have a wrapper around that function. where i want to catch Left vs. Right and exit early cause there's no point in running the program further if the config file was unable to be parsed
09:13:58 <deni> am i thinking about this right?
09:14:18 <mzero> deni - yes, except "catch" isn't quite the right word
09:14:24 <edwardk> we don't do that very often and so when we do it isn't without reason ;)
09:15:03 <Cale> Linear implicit parameters?
09:15:11 <mzero> "case" would be the right word (and construct) or "either"
09:15:12 <monochrom> edwardk: did you know: there was a Eurasia / East Asia thing to RecursiveDo and DoRec
09:15:16 <Cale> What other extensions are deprecated?
09:15:17 <deni> mzero: so Either is also lazy and will only blow up further down the line if i don't exit early myself?
09:15:41 <mzero> as in      readConfig >>= either reportError computeWithConfig
09:15:42 <Tjr> I tried to do exercise apple in http://tonymorris.github.io/blog/posts/20-intermediate-haskell-exercises/
09:15:46 <deni> i'm asking cause i somehow got the impression that either is special ie. not lazy
09:15:52 <monochrom> many years ago, RecursiveDo (supported mdo) was deprecated in favour of DoRec (supported rec).
09:15:56 <edwardk> monochrom: that is probably the closest thing to random bikeshedding we ever had =)
09:16:00 <Cale> deni: Either is not special
09:16:05 <Tjr> It asks for the Applicative's  <*> for a given monad.
09:16:13 <Cale> deni: It's simply defined as  data Either a b = Left a | Right b
09:16:13 <deni> Cale: oh ok. tnx
09:16:21 <mzero> no, either, like almost everything you'll find is "lazy" in it's arguments
09:16:29 <benzrf> whats mdo
09:16:32 <mzero> but....      the bind          readConfig >>= either a b
09:16:40 <Tjr> However, ghci doesn't like my solution, and I can't find one that doesn't use lots of other concepts.
09:16:53 <Tjr> How can <*> be expressed in terms of >>= and return?
09:16:55 <monochrom> then, apparently, in ghc 7.?, RecursiveDo was changed to support both mdo and rec, so now DoRec is deprecated in favour of RecursiveDo
09:16:59 <benzrf> Tjr: simply
09:17:00 <benzrf> @src ap
09:17:00 <lambdabot> ap = liftM2 id
09:17:04 <Cale> monochrom: lol
09:17:09 <toki78> okay, I am satisfied for today's work, and go offline ... Thanks a TON to all of you
09:17:11 <mzero> in order to find the rest of the IO computation, the bind (>>=) will demand an IO value, which will demand that either pull apart the Either value from readConfig
09:17:16 <monochrom> we're now at war with East Asia! Eurasia is now our ally!
09:17:17 <mzero> in order to choose between a or b
09:17:21 <fread2282> @src liftM2
09:17:21 <lambdabot> liftM2 f m1 m2 = do { x1 <- m1; x2 <- m2; return (f x1 x2) }
09:17:25 <benzrf> monochrom: *eastasia
09:17:25 <Tjr> benzrf: and what are liftM2 and ap, in terms of >>= and return?
09:17:27 <benzrf> and not 'now'
09:17:33 <benzrf> we're now => we are
09:17:41 <benzrf> Tjr: ap is the function i just sourced
09:17:45 <benzrf> :t ap
09:17:46 <lambdabot> Monad m => m (a -> b) -> m a -> m b
09:17:54 <benzrf> @src ap
09:17:54 <lambdabot> ap = liftM2 id
09:17:57 <mzero> er, "pull apart" might be better phrased "examine"
09:17:59 <benzrf> @src liftM2
09:18:00 <lambdabot> liftM2 f m1 m2 = do { x1 <- m1; x2 <- m2; return (f x1 x2) }
09:18:35 <deni> mzero: understood. makes sense.
09:18:37 <Tjr> what are those do-style arrows in terms of >>= and return?
09:19:09 <Cale> Tjr: do { v <- x; <stmts> } = x >>= \v -> do { <stmts> }
09:19:14 <benzrf> @undo do { x1 <- m1; x2 <- m2; return (f x1 x2) }
09:19:14 <lambdabot> m1 >>= \ x1 -> m2 >>= \ x2 -> return (f x1 x2)
09:19:26 <Cale> Tjr: do { x ; <stmts> } = x >> do { <stmts> }
09:19:47 <Tjr> so, putting it all together:
09:19:54 <Cale> Tjr: do { let { <decls> } ; <stmts> } = let { <decls> } in do { <stmts> }
09:20:04 <Cale> and finally as a base case: do { x } = x
09:20:42 <Tjr> app :  (Monad m) => m (a -> b) -> m a -> m b
09:20:53 <benzrf> *ap
09:20:54 <mzero> BTW, deni: if you prefer, you can do       do { ...  r <- readConfig; case r of Left err -> ....; Right conf -> ..... }
09:21:18 <deni> mzero: was just about to ask that :)
09:21:24 <mzero> if the two cases are small, that might be easier (or might not be) than defining functions for the two cases and using either
09:21:24 <Cale> I generally find myself later replacing clever uses of the either function with case expressions
09:21:54 <mzero> the generated code, and execution are essentially identical (if not exactly identical)
09:21:57 <Tjr> app mfunc ma = liftM2 id mfunc ma = do { x1 <- mfunc; x2 <- ma; return (id x1 x2) } = ...
09:22:06 <Cale> If you think you might adjust the code later, using case is often a bit easier to manipulate.
09:22:44 <Cale> Tjr: btw, mfunc there typically will not be a function
09:23:02 <Cale> (though there is a Monad instance for functions)
09:23:14 <benzrf> @undo do { x1 <- mfunc; x2 <- ma; return (id x1 x2) }
09:23:14 <lambdabot> mfunc >>= \ x1 -> ma >>= \ x2 -> return (id x1 x2)
09:24:01 <Tjr> =app mfunc ma = mfunc >>= \x1 -> (ma >>= \x2 -> (return id x1 x2)
09:24:11 <dfeuer> Cale, for example,  if a < 0 then 0 else a   should be (and probably is) transformed to something vaguely like  a `xor` (a `shiftR` (finiteBitSize (undefined::Int) - 1)) but it's not clear to me when more complicated expressions will be.
09:24:16 <benzrf> Tjr: it's ap
09:24:17 <benzrf> not app
09:24:43 <Tjr> ap is predefined something, app is my <*> to avoid conflicts
09:25:12 <Tjr> <*> mfunc ma = mfunc >>= \x1 -> (ma >>= \x2 -> (return id x1 x2)
09:25:22 <Tjr> that should be it, right?
09:25:52 <monochrom> "mfunc <*> ma" or "(<*>) mfunc ma"
09:25:54 <Tjr> mfunc is of type m (a -> b)
09:26:26 <Tjr> (<*>) :: m (a->b) -> m a -> m b ;
09:26:26 <Tjr> (<*>) mfunc ma = mfunc >>= \x1 -> (ma >>= \x2 -> (return id x1 x2)
09:28:01 <benzrf> @let data MaybeAFunctor a = forall a. Eq a => MaybeAFunctor [a]
09:28:03 <lambdabot>  Defined.
09:28:29 <Tjr> thank you
09:28:58 <vr2mx> hello (:
09:29:13 <benzrf> @let instance Functor MaybeAFunctor where fmap f (MaybeAFunctor l) = let new = map f l in if l == new then MaybeAFunctor new else MaybeAFunctor (reverse new)
09:29:15 <lambdabot>  .L.hs:151:29:
09:29:15 <lambdabot>      Could not deduce (a1 ~ a)
09:29:15 <lambdabot>      from the context (Eq a1)
09:29:15 <lambdabot>        bound by a pattern with constructor
09:29:15 <lambdabot>                   MaybeAFunctor :: forall a a. Eq a => [a] -> MaybeAFunctor a,
09:29:19 <benzrf> oh crud
09:29:22 <benzrf> foiled again!
09:30:40 <deni> mzero: This doesn't work quite well with the types: http://dpaste.com/1N3TCCA
09:31:17 <mzero> ...looking...
09:31:19 <deni> mzero: the last function getApiKeyProperties i mean
09:31:37 <deni> i'm starting to dislike the do notation btw
09:32:20 <mzero> deni:  line 62:   Left e -> Left e
09:32:32 <mzero> and on 63     -> Right $ ApiKey....
09:32:45 <mzero> you need to wrap up the two possible results in the Either that you are goign to return
09:32:50 <mzero> and....    on 61
09:32:57 <mzero> return $ case ....
09:33:12 <mzero> BUT, in this case you might do
09:33:23 <Cale> dfeuer: hi
09:33:36 <mzero> readConfig credFile >>= either Left (Right . buildAPIKeyProps)
09:33:57 <Cale> dfeuer: But what if a isn't yet evaluated?
09:33:58 <dfeuer> To quote myself, Cale,  for example,  if a < 0 then 0 else a   should be (and probably is) transformed to something vaguely like  a `xor` (a `shiftR` (finiteBitSize (undefined::Int) - 1)) but it's not clear to me when more complicated expressions will be.
09:33:59 <mzero> and defined (in a where clause) buildAPIKeyProps config = ApiKeyProperties....
09:34:29 <Cale> dfeuer: Well, I suppose you can do that anyway
09:34:33 <dfeuer> That's a separate issue, Cale, isn't it?
09:34:56 <dfeuer> Unboxing is a whole separate stage.
09:34:59 <Cale> Yeah, I guess if you know it's an Int
09:35:40 <Cale> I'm not sure whether I'd expect the latter to perform as well. Are you sure that it does?
09:35:53 <Cale> Maybe it ends up being optimised better
09:36:21 <Cale> But there are a lot of 'ifs' involved in that :)
09:36:37 <dfeuer> I'm not sure that it does, Cale, but it uses very few operations, and they're unconditional, so I'm pretty confident it does.
09:36:52 <hiptobecubic> If I want to use stackage but only in a sandbox, what gets edited? .cabal.sandbox.config?
09:37:07 <dfeuer> (and they're inherently cheap--no divisions or even multiplications)
09:37:16 <Cale> If the expression gets fully specialised to Int and the implementations of xor etc. get inlined
09:37:24 <dfeuer> Yes, of course.
09:37:34 <Cale> xor is really a function of an additional parameter: the typeclass dictionary
09:38:05 <dfeuer> I understand what you're saying, I believe, but yes, I'm talking about the case where it's fully specialized and unboxed.
09:38:31 <klrr_> is there any Int to Text function?
09:38:33 <Cale> Anyway, the only way to be sure is to look at the compiler output
09:38:44 <Cale> With -ddump-simpl and -ddump-asm and stuff
09:38:52 <Cale> klrr_: pack . show
09:39:36 <dfeuer> Unfortunately, compiler output is very hard to read, especially when you're like me and don't really know how to read asm at all.
09:39:48 <deni> mzero: okay now i have this: http://dpaste.com/12QRRTC
09:40:24 <deni> mzero: but now it's complaining that Couldn't match type ‘Either ParseError b0’ with ‘IO (Either ParseError ApiKeyProperties)’Expected type: ParseError -> IO (Either ParseError ApiKeyProperties) (on line 6)
09:40:46 <deni> and on line 7: Couldn't match type ‘Maybe a’ with ‘[Char]
09:40:52 <deni> mzero: ^
09:40:53 <mzero> you need the "return" in there somewhere
09:40:58 <Cale> dfeuer: For the most part, I'd only start to worry about this sort of thing once profiling revealed that it was the part of my program which was slow
09:41:10 <mzero> deni see: http://dpaste.com/1RRTY22
09:41:36 <Cale> dfeuer: and at that point, maybe I'd consider looking at the core and helping the compiler along in its job of unboxing things
09:41:53 <deni> mzero: lookin
09:42:13 <mzero> deni - notice that you have a value of type   Either a b    and you need   IO (Either a b)     the simplest way to handle that is to     return (... the value ....)
09:44:18 <mzero> also, deni: notice how I have the where clause formatted - it is a where clause over the whole declaration of getApiKeyProperties, not over just that one expression
09:44:49 <Cale> dfeuer: I have somewhat of a hard time imagining that the presence or absence of branch instructions would usually make or break the performance of a Haskell program -- there's enough other stuff going on that I'd usually expect the effect of things like failed branch predictions to be negligible. I could be very wrong though!
09:45:33 <klrr_> :t flip . evalStateT
09:45:34 <lambdabot> StateT a ((->) b) a1 -> b -> a -> a1
09:46:55 <Cale> It's typically only if you were writing some tight inner loop that you'd have to worry about that kind of thing, and if you were really that worried, it might be worth just using LLVM or something to do runtime compilation for you.
09:47:03 <dfeuer> Cale, I would imagine it would only matter under sufficiently pleasant conditions, like mapping over a big Vector.
09:47:20 <dfeuer> But people sometimes do that.
09:47:41 <deni> mzero: yeah that's a stupid mistake on my part. forgetting return i mean. but still it's not compiling. readConfig credFile >>= return $ right makeApiKeyProp it giving me "Couldn't match expected type ‘(Either d0 (Map.Map k0 a0) -> Either d0 ApiKeyProperties) -> IO (Either ParseError ApiKeyProperties)’ with actual type ‘IO (Either ParseError Config)"
09:47:56 <deni> s/it/is/
09:47:58 <dfeuer> Yes, the tight inner loop market is my target for this particular line of thinking, Cale.
09:48:23 <mzero> looks like your definition of makeApiKeyProp is suspect - did you leave off 'config' parameter ?
09:49:05 <deni> mzero: http://dpaste.com/067MP6Z
09:49:49 <mzero> ah...      return . right makeApiKeyProp
09:50:12 <mzero> . vs $
09:50:26 <c_wraith> mzero: in that case, isn't fmap a better solution?
09:50:41 <path[l]> hi, can someone help me with my usage of deepseq. I’m trying to test some code that throws an error and with hspec I was asked to write the code as “(evaluate.force) (parseGlob "[abc-\\]") `shouldThrow` (errorCall "could not parse set in glob”)”, but when I import deepSeq I get “No instance for (NFData Glob) arising from a use of `force'"
09:50:43 <mzero> c_wraith: I offered that in my dpaste as an option
09:50:52 <c_wraith> mzero: ah, ok
09:50:54 <mzero> I'd say it is six of one...
09:51:22 <deni> mzero: six of one?
09:51:27 <mzero> if you want to emphasize the IO ordering and flow, then   >>= return .    is okay
09:51:28 <c_wraith> deni: half dozen of the other
09:51:36 <mzero> six of one, half dozen of the other
09:51:56 <mzero>     a >>= return . f        vs.      f `fmap` a       or     f <$> a
09:52:38 <mzero> If I'm doing a simple extraction of a value from the thing computed by a,  then I tend to do the fmap versions... if f is a more complex expression, I tend to do the   >>= return .    version
09:52:52 <deni> mzero: c_wraith ok i think I've got it...the difference/similarity with the 3 notations.
09:53:13 <c_wraith> deni: actually, that expression means that the difference isn't significant.
09:53:14 <deni> mzero: c_wraith return seems more appropriate in a do notation (in my beginner mind that is)
09:53:15 <mzero> It is a readability call, I think - I don't think there is a reason for a hard line rule in this case
09:53:28 <mzero> then do it (pun intended)
09:53:33 <deni> :d
09:53:36 <deni> :D
09:54:01 <mzero> it is true, as you gain experience, you get more comfortable with things like   fmap'ing over monadic actions like IO
09:54:32 <mzero> and once you get used to   <$> ... <*>   you never want to go back!
09:54:38 <deni> mzero: oh i do that a lot.....i'm just not sure about the whole applicative thing seeing as some monads are subsets of applicative and some are not.....i understand with the new ghc that's going to change
09:55:04 <deni> (i'm not sure subset is the right word...but you get what i'm saying)
09:55:15 <mzero> uhm, eventually GHC's base will clean up the heirarchy... but basically every common Monad is Applicative
09:55:20 <mzero> so, in practice it isn't a worry
09:55:25 <deni> nice to know
09:56:11 <c_wraith> mzero: eventually is actually the next major version. So...  Soon!
09:56:25 <mzero> for some value of soon.... ;-)
09:56:27 <c_wraith> ...  where soon = "probably within a year"
09:56:41 <deni> mzero: one more questions about the code though.....Map.lookup "apiKey.id" config is apparently returning a Maybe String and the ApiKeyProperties constructor expects a String...i'm guessing this is beacuse of my parsing mechanics somehow...but now sure
09:57:00 <deni> c_wraith: i was just about to ask that you clarify soon :D
09:57:06 <luite> yeah ICFP is too soon
09:57:07 <geekosaur> supposedly they're going to annual releases. considering that the most recent one took ~ 6 months longer than intended to come out at all... we'll see
09:57:16 <geekosaur> (which was on a 6 month schedule)
09:57:17 <deni> but yes i'm aware that it's in the works
09:58:15 <deni> even from my noob perspective that makes sense...relationship between applicative and monad...and i've just learned about these things likes 1-2 months ago
09:58:16 <enthropy> is there some reason people prefer (data G :: * -> * where) to  (data G' (x :: *))?
09:58:22 <c_wraith> there was some talk of making 7.10 smaller and trying to push it out fast (in comparison)
09:58:45 <c_wraith> enthropy: naming variables is hard.
09:58:58 <enthropy> well you already name them when you define the constructors
09:59:04 <deni> mzero: I guessing that catMaybes is the culprit but i'm not entirely sure
09:59:10 <mzero> deni: of course lookup is going to return a Maybe --- what if the key isn't in the map
09:59:15 <enthropy> so we have      GCon :: x -> G x
09:59:24 <mzero> so... I have a fix for that ... dpasting in a sec...
10:00:36 <deni> mzero: ah so it's lookups fault...darn that makes total sense now that you've said id
10:00:39 <deni> *it
10:03:03 <deni> mzero: what comes to mind is to pattern match on those values....but that seems ugly....I suppose you have a better solution
10:04:52 <mzero> that would be fine.... but two things 1) you are going to have to change the left side type from ParseError to String.. becuase if the key is missing, it isn't a ParseError, but you can generate a string error message
10:05:10 <mzero> and 2) Either e  is a monad, and applicative, so ......
10:06:01 <mzero> http://dpaste.com/3HMDB0S
10:09:34 <deni> mzero: I'm trying to think of a way to get this stuff checked while parsing
10:10:03 <deni> mzero: ie. i wan't the parser to throw a parseerror if the config file doesn't have the 2 properties "apiKey.id" and "apiKey.secret"
10:10:14 <deni> mzero: not sure if that has something to do with dependant types or not
10:10:19 <mzero> that seems difficult since I imagine you don't require them in either order
10:10:42 <deni> mzero: yes the file can have either secret or id line first
10:10:53 <deni> mzero: if that's what you meant?
10:10:56 <mzero> why focused on ParseError --- it is limited
10:11:01 <mzero> yes, that is what I meant
10:11:21 <mzero> whereas Either String a   where a Left value means "error" is a standard idiom
10:11:43 <deni> mzero: i'm just tinkering here...but it seemed natural to have the parser report somehow that the config file didn't satisfy the type ApiKeyProperties that needs both id and secret
10:11:52 <mzero> That is to say, I don't think the absence of apiKey.id is really a parsing problem.. hence not a ParseError
10:12:01 <deni> mzero: i see
10:12:11 <mzero> Ah - perhaps you need readConfig  to change it's type
10:12:24 <mzero> readConfig :: Either String ApiKeyProperties
10:13:07 <mzero> then it encapsulates the use of a parser to get the values, and includes the structural checks on the parsed data (both values are present)... and builds a domain specific value (ApiKeyProprties)
10:14:08 <mzero> If you plan on having many other types of config... all using the same parser, and hence a Map of Strings to Strings.....
10:14:11 <deni> but then i don't get the getApiKeyProperties properties function right? cause that's exactly what it's doing
10:14:40 <deni> mzero: actually the config file is set....i don't plane on having any other kinds of config files.
10:14:43 <mzero> well, here's the thing.... you've threaded IO through two functions that dont' really need them
10:14:51 <mzero> so then....
10:15:03 <mzero> readConfig :: String -> Either String ApiKeyProperties
10:15:23 <mzero> and       getApiKeyProperties :: IO (Either String ApiKeyProperties)
10:15:32 <mzero> think about that refactoring......
10:15:45 <mzero> and then... consider replacing getApiKeyProperties with......
10:16:04 <mzero>      withApiKeyProperites :: (ApiKeyProperties -> IO ()) -> IO ()
10:16:36 <mzero> NOW you can write your code to just assume (and take as an arg) the ApiKey.... and let the wrapper withApiKeyProperties do the work of erroring out
10:16:58 <mzero> AND, you've made the hard data manipulation (parse, build a config) all pure
10:18:23 <deni> mzero: this has been most helpful....i will have to try and think about this (as i'm new to haskell)....but I'm late for a function (damn you haskell :D) so I'll try and catch you later when I this stuff get's more clear in my head
10:18:36 <deni> mzero: tnx again man.
10:18:40 <mzero> excellent.... just follow the types - later
10:18:44 <deni> later
10:46:50 <Ch0c0late> Just to experiment Type Variables, TypeClasses, and Class Constraints let's say we want to have a function that takes two values say n1 and n2 and returns the n1^n2. Is this definition correct? ** :: Num a => a -> a -> a
10:48:12 <dmj`> @typ (**)
10:48:13 <lambdabot> Floating a => a -> a -> a
10:48:43 <monochrom> @type (^)
10:48:44 <lambdabot> (Num a, Integral b) => a -> b -> a
10:48:50 <monochrom> @type (^^)
10:48:51 <lambdabot> (Integral b, Fractional a) => a -> b -> a
10:49:00 <monochrom> pick one
10:49:15 <Ch0c0late> Thanks.
10:49:22 <monochrom> or pick another example altogether
10:50:44 <davidthomas> Ch0c0late: In principle, "(**) :: Num a => a -> a -> a" makes some conceptual sense as something you might want to express, but I don't think you can actually write it.
10:51:06 <hiptobecubic> Is anyone using stackage from a sandbox?
10:51:11 <hiptobecubic> or at all, really
10:51:28 <Ch0c0late> davidthomas: Could you explain why?
10:51:42 <monochrom> Num does not give you enough tools
10:51:55 <davidthomas> Ch0c0late: If all you know about the type, a, is that it is Num, then all you can use is that fact
10:52:29 <Ch0c0late> Ah!
11:09:59 <wz1000> If you inspect the kind of a typeclass, you get (Something) -> Constraint. What exactly is a constraint(What kind(heh) of thing is it?) and what else can come in place of 'Constraint' in a kind?
11:12:29 <yitz> wz1000: anything that can be on the comma-separated list of items to the left of => in a type signature.
11:13:36 <rwbarton> or even an entire list of items
11:13:48 <wz1000> Where is Constraint defined?
11:14:26 <rwbarton> well you can import it from GHC.Exts
11:14:49 <wz1000> yitz: rwbarton: Can you give me an example of a kind like that?
11:15:45 <rwbarton> Constraint is a kind
11:15:53 <rwbarton> but for example  Eq Int :: Constraint
11:16:02 <rwbarton> so  Eq :: * -> Constraint
11:16:29 <rwbarton> now you could write a type that uses this kind of thing
11:16:54 <rwbarton> data ConstrainedList c = Empty | forall t. c t => Cons t (ConstrainedList c)
11:17:02 <Ch0c0late> Can I say that one of the usage of Class Constraints is making the declaration shorter? Let's see a :: Int -> [Int] -> [Int] and a :: Integral a => a -> [a] -> [a]
11:17:09 <rwbarton> note here c is used as a variable that ranges over things of kind * -> Constraint
11:17:14 <rwbarton> such as Eq
11:18:38 <monochrom> rwbarton: that list allows "Cons True (Cons () Empty) :: ConstraintedList Eq", doesn't it?
11:18:52 <rwbarton> yes
11:19:06 <monochrom> heterogeneous lists scare me :)
11:19:30 <rwbarton> an existential antipattern factory
11:19:46 <monochrom> "a bool, an int, and a unit want to cross the river..." :)
11:23:33 <monochrom> class constraints don't make declarations shorter
11:23:54 <monochrom> perhaps more general, but not shorter
11:25:11 <monochrom> @type monoy
11:25:12 <lambdabot> Not in scope: ‘monoy’
11:26:17 <Ch0c0late> How to break this line into some small parts? putStrLn $ show $ len $ map (read :: String -> Int) $ lines inputdata
11:27:04 <Cale> Well, putStrLn . show = print
11:29:10 <larsrh> I'm trying to understand some RTS behaviour ... I'm stracing a program compiled with -rtsopts -threaded, but running it with +RTS -N1 -RTS. Still, strace indicates that there are 3 threads being created.
11:29:19 <larsrh> (it shows three "clone" syscalls)
11:29:41 <larsrh> also happens when I don't specify any rtsopts at runtime
11:31:07 <monochrom> I am not sure what "part" means. but you're looking at (print . len . map (read :: String -> Int) . lines) inputdata
11:31:40 <monochrom> alternatively you're looking at print (len (map (read :: String -> Int) (lines inputdata)...)
11:32:20 <larsrh> If I compile without -threaded, I only get one thread
11:32:21 <monochrom> IOW you're looking at either "(f . g . h) x" or "f (g (h x))"
11:32:45 <monochrom> in general, get rid of $'s to see real structure
11:35:31 <Ch0c0late> Yes.
11:36:51 <wz1000> So i was looking at the definition of Eq, and noticed it had to have a separate instance for tuples having up to 15 elements. Isn't there a more concise and general way to define it? A tuple of 16 elements is not an instance of Eq.  I keep seeing ugliness when dealing with tuples, for eg over here: http://hackage.haskell.org/package/tuple-0.2.0.1/docs/Data-Tuple-Select.html
11:39:23 <Cale> wz1000: Nobody uses tuples larger than pairs and the occasional triple anyway
11:39:24 <f-a> wz1000: are you *really* using a tuple of 16 elements?
11:39:43 <wz1000> No, but it's ugly.
11:39:52 <Cale> wz1000: If you're using anything larger, you're always better off defining a proper data type
11:40:15 <Cale> It'd be possible to write Template Haskell code to generate the instances, but there's really not much need.
11:40:56 <dolio> Not always. But most of the time.
11:41:23 <Cale> Well, the only excuse I can imagine is if you were generating Haskell code somehow.
11:41:43 <Cale> It might be easier to generate tuples than to generate additional data declarations
11:41:58 <dolio> I have code that uses a 5-tuple.
11:42:17 <f-a> dolio: can you describe in which setting (if that is possible, of course)
11:42:17 <dolio> It needs to do two traversal that can't be fused together because of ordering reasons.
11:42:26 <dolio> But it needs to pass data from the first traversal to the second.
11:42:29 <dolio> 5 things.
11:42:48 <wz1000> I know, but its like saying that we shouldn't care about ancient history since it doesn't matter to us.
11:42:58 <dolio> And it'd be silly to define a new data type just for the intermediate step in that one function.
11:43:37 <f-a> wz1000: I don't know what you are trying to achieve. If you look at the definition of a tuple, you will instantly get why it is impossible to generalise such functions, given haskell type system.
11:43:42 <rwbarton> I wrote a program that uses a 5-tuple just today!
11:44:08 <f-a> pentaplet?
11:44:16 <Cale> wz1000: What do you mean by that?
11:44:56 <Cale> wz1000: Each length of tuple is an entirely separate datatype, unrelated to the others.
11:45:22 <tester12341> @type map
11:45:23 <lambdabot> (a -> b) -> [a] -> [b]
11:45:31 <Cale> They just happen to have similar (and built-in) syntax.
11:46:40 <f-a> indeed, think of them as:
11:46:49 <tester12341> @pointless f xs = reverse $ map (+1) xs
11:46:49 <lambdabot> f = reverse . map (1 +)
11:47:02 <f-a> data Tuplet = Tuplet a b -- etc.
11:47:03 <wz1000> Cale: Why not apply the 'deriving' magic to tuples?
11:47:07 <augur> tuplet
11:47:07 <augur> :3
11:47:33 <f-a> ahah what's the correct way to name a two spaces tuple
11:47:37 <f-a> duplet
11:47:42 <f-a> diaplet
11:47:46 <f-a> dyad
11:47:59 <Cale> wz1000: There's nowhere in particular that the tuple types are defined in order for the deriving declarations to be attached.
11:48:02 <f-a> wz1000: it seems it would only be used for that particular data type
11:48:13 <Cale> (since they're built-in)
11:48:13 <tester12341> @pointless g ys = map (\x -> negate (sqrt x)) ys
11:48:14 <lambdabot> g = map (negate . sqrt)
11:48:42 <Cale> If they were just being defined in the Prelude, then sure, we'd just use deriving (Eq, Ord, ...)
11:49:14 <wz1000> Why not automagically make all tuples derive 'Eq', since deriving is already magic?
11:49:30 <cloudhead> Is there a nice way to modify a single node in a tree-like data structure? Ideally with Lens?
11:49:31 <Cale> Where does the code for the instances go?
11:49:48 <edwardk> cloudhead: sure. depends on the tree of course
11:50:04 <cloudhead> edwardk: at the moment it's nested maps
11:50:24 <cloudhead> Node (Map Id Node)
11:50:27 <cloudhead> something like that
11:50:36 <edwardk> > M.fromList [(1,M.fromList [(2,3)])] & at 1.non mempty . at 2.non 0 +~ 1
11:50:38 <lambdabot>  fromList [(1,fromList [(2,4)])]
11:50:40 <wz1000> Where does the code for an instance of any type that derives Eq go?
11:50:44 <edwardk> > M.fromList [(1,M.fromList [(2,3)])] & at 2.non mempty . at 4.non 0 +~ 1
11:50:46 <lambdabot>  fromList [(1,fromList [(2,3)]),(2,fromList [(4,1)])]
11:50:46 <Cale> I suppose GHC could do that and generate it for up to 15-tuples or something and put that in the Prelude module as a special case
11:51:14 <Cale> wz1000: In the module where the type is declared
11:51:14 <edwardk> at x.non someDefault works pretty well
11:51:20 <cloudhead> interesting
11:51:23 <ReinH> edwardk: non is so good
11:51:29 <tester12341> @pointless h p zs = length (filter p zs)
11:51:29 <lambdabot> h = (length .) . filter
11:51:46 <cloudhead> edwardk: so the problem is I need to "find" the node, given an id, by traversing the tree
11:51:47 <edwardk> you can make tries with it very easily with a little bit of foldr etc.
11:51:55 <ReinH> tester12341: how about length . filter p
11:52:14 <cloudhead> ie: I can't be manually descending it
11:52:22 <cloudhead> it might be dozens of levels deep
11:52:23 <edwardk> ok, add an indexed traversal to nodes indexed by their keys, then use traverse.index 4  -- or whatever
11:53:13 <edwardk> you have some kind of global uniqueness of Id's property you are enforcing?
11:53:15 <cloudhead> so essentially I need to implemnt Index and  Traversal for Node?
11:53:18 <cloudhead> yes
11:53:32 <tester12341> hey guys, can someone explain to me why e n = take n [1..] is e = flip take [1..]??
11:53:50 <Cale> tester12341: Do you know what flip is?
11:53:51 <edwardk> yeah 'itraversed' is an indexed traversal for a Map. so you just need to add the _Node isomorphism to the front of it to get one level
11:54:02 <Cale> tester12341: flip f x y = f y x
11:54:21 <edwardk> then you can decide how to deal with keys or chains of Id's or whatever you want from there
11:54:28 <cloudhead> ah I see
11:54:44 <edwardk> _Node.itraversed   is an indexed traversl of the immediate sub-nodes of a nod
11:54:46 <edwardk> er node
11:54:50 <Ch0c0late> Oh my God! What's happening? I have a function f arr = sum ([x | x <- arr, odd x]) and when I run some benchmark on it the running time for three test cases were .02, .03, and .02 respectively. But when I added f :: Integral a => [a] -> a the same test cases running time grows each with with 1/100th or .01. What's going on?
11:55:16 <edwardk> instance Plated Node where plate = _Node.traverse  -- can be used for syntax tree rewrites, etc.
11:55:42 <cloudhead> ok cheers, I'm going to look into all this, might come back for help :)
11:56:28 <mzero> tester12341:     consider       e n = (flip take) [1..] n
11:56:35 <mzero> do you see why that works?
11:56:42 <hpc> Ch0c0late: can you better describe what you are doing?
11:57:47 <Cale> Ch0c0late: Try f :: [Integer] -> Integer
11:57:51 <Ch0c0late> Why the running time is different?
11:58:01 <Ch0c0late> hpc: Why the running time is different?
11:58:57 <Cale> Ch0c0late: How are you doing the timing?
11:59:23 <pjdelport> Also, how are you generating the input?
11:59:51 <Ch0c0late> Just have two different *.hs and then run them simultaneously on the same machines. The input is in a text file.
11:59:59 <Ch0c0late> *machine
12:00:25 <Cale> Ch0c0late: I mean, are those times generated by running the same test hundreds of times and averaging the results?
12:00:27 <Cale> Or just once?
12:00:51 <pjdelport> Ch0c0late: Depending on how you do things, the reading and parsing may be interleaved with the summing, and that can have a significant effect on the timing.
12:01:22 <Cale> pjdelport: Well, supposedly the only change in the program is the type signature
12:02:14 <monochrom> a factor of 1/100 is not big enough to be unquestionably non-noise
12:02:16 <Ch0c0late> Cale: Averaging the result.
12:02:29 * monochrom wins a triple-negation trophy!
12:02:57 <FireFly> you win a triple-negated trophy
12:03:23 <Cale> Ch0c0late: Did you try my alternate type signature for f?
12:03:41 <Ch0c0late> Not yet. Going to try it out.
12:04:34 <Cale> If there really is a difference in the generated code, it's probably due to GHC defaulting the thing to Integer.
12:06:50 <glaebhoerl> could someone refresh me on what the precise problem is with instance declarations for polymorphic types (`instance Foo (forall a. Bar a)` etc.), or refer me to an explanation?
12:07:04 <glaebhoerl> I don't have a use case, I'm just seeking greater understanding for unrelated purposes
12:13:02 <Ch0c0late> Cale: Second one is yours. http://hastebin.com/sebitokoti.coffee
12:15:10 <larsrh> How do I find out what Haskell function performs a syscall?
12:15:18 <larsrh> there's something calling clock_gettime
12:16:32 <larsrh> could be the RTS clock -- some way to disable that?
12:16:41 <f-a> that would be most impure. I guess you want something like System.Process ?
12:16:58 <f-a> oh sorry I misread.
12:18:35 <geekosaur> larsrh, my guess is it's the runtime calling that
12:18:51 <geekosaur> `+RTS -V0` options may help
12:19:03 <Ch0c0late> Cale: Any idea?
12:19:11 <geekosaur> if you really need it to not do that (why? unless you're using ghc 7.4 in which case it's a known bug)
12:25:50 <larsrh> geekosaur: doesn't work unfortunately
12:26:23 <geekosaur> then I suspect you need to ask in #ghc (if anyone's around there)
12:26:33 <geekosaur> or ask on the glasgow-haskell-users mailing list
12:26:48 * hackagebot language-gcl 0.1 - Something similar to Dijkstra's guarded command language  http://hackage.haskell.org/package/language-gcl-0.1 (StijnVanDrongelen)
12:26:48 * hackagebot compdata 0.8.1.2 - Compositional Data Types  http://hackage.haskell.org/package/compdata-0.8.1.2 (PatrickBahr)
12:27:17 <larsrh> geekosaur: Do you know of any debugger for Haskell? If I could step through a call stack I could try to narrow down when/where it happens
12:28:01 <geekosaur> larsrh, debuggers typically don't handle Haskell very well at all
12:28:36 <geekosaur> as such nobody's really bothered to try to write one specifically for ghc-generated code.
12:29:22 <rwbarton> could just try gdb
12:29:44 <rwbarton> the call is likely from C anyways
12:29:45 <chrisdotcode> happy father's day, #haskell
12:30:29 <klrr_> chrisdotcode: is it fathers day??
12:30:32 <klrr_> crap.
12:30:36 <chrisdotcode> klrr_: indeed. in the US
12:30:56 <klrr_> okey forgot about that :P thanks for telling
12:39:27 <ttll_> hi
12:39:45 <f-a> 'lo
12:40:07 <Guest41923> Hey, I'm working with HLearn and trying to get LinearClassifier working, but I keep getting the error "Couldn't match type ‘Vector’ with ‘HLearn.Algebra.LinearAlgebra.Vector’" but the one in HLearn is just a newtype
12:40:33 <Guest41923> And it doesn't export any constructors publicly, so I can't figure out how to get the types to resolve
12:40:53 <f-a> maybe some other module reexports it?
12:41:26 <ttll_> so I have a list of [Either a b] and I want a function that returns 'Either a [b]' (the first Left or all Rights)
12:41:46 * hackagebot data-r-tree 0.0.4.0 - R-Tree is a spatial data structure similar to Quadtrees or B-Trees.  http://hackage.haskell.org/package/data-r-tree-0.0.4.0 (SebastianPhilipp)
12:41:58 <Iceland_jack> @ty sequence :: [Either a b] -> Either a [b]
12:41:58 <lambdabot> [Either a b] -> Either a [b]
12:41:59 <Black-Heaven> Hi all, I have an design question: I have three datatypes (Wish, Fact, Action), each one have a role, modeled by a typeclass (Observable, Deltable, Performable). For the moment I have three functions : observe :: FileWish -> [FileFact] / plan :: FileWish -> [FileFact] -> [FileAction] / perform :: FileWish -> [FileAction] -> IO () As you see, I mush make one datatype per kind of thing. First I thought using https://www.fpcomplete.com/school/t
12:42:09 <ttll_> I know how to do this manually but I think I'm missing something
12:42:22 <Iceland_jack> ttll_: Does 'sequence' do what you want?
12:42:36 <Iceland_jack> > sequence [Left 5, Right 'a']
12:42:38 <lambdabot>  Left 5
12:42:47 <Iceland_jack> > sequence [Right 'a', Right 'b', Right 'c']
12:42:49 <lambdabot>  Right "abc"
12:42:51 <ttll_> yes, exactly
12:43:09 <ttll_> I need to improve my hoogle-fu it seems
12:43:38 <cehteh> DanielDiaz: the gprolog author?
12:44:49 <ttll_> thanks Iceland_jack
12:46:38 <Guest41923> oh I thin that it uses Data.Vector.Generic which possibly is able to cast around newtypes, I'm trying it out now
12:46:52 <argiopetech> Is anyone aware of a way to call differentiable functions with explicit type signatures (from Numeric.AD)? I can hack something up with e.g., (fst . diff'), but there's a pretty significant performance penalty. There don't appear to be any functions to unAD values.
12:47:12 <coppro> getProtocolByName: does not exist (no such protocol name: tcp)
12:47:15 <coppro> what.
12:47:54 <joshc> Black-Heaven: your question was cut in the middle of the fpcomplete URL.
12:50:36 <Lutin`> morning all
12:53:27 <Guest41923> Yeah just had to use Vector.Generic.convert, thanks guys
12:56:48 <cloudhead> is there no way to implement Traversable with a type of kind '*'?
12:58:21 <hiptobecubic> Is there any particular benefit to use a giant case statement instead of a map for something like this? http://hackage.haskell.org/package/GoogleTranslate-0.0.5/src/Language/Translate/Google.hs
12:58:46 <dwcook> cloudhead: Taken literally, there is no way. However, you can still implement analogous operations without them being methods of Traversable.
12:58:56 <dwcook> cloudhead: Why do you think you want such an instance?
12:59:20 <cloudhead> dwcook: hmm, well, I'm trying to make my type traversable via lenses
12:59:33 <willem> i have a cabal project in a directory A, which in turn contains a directory B. both contain a file F and A/B/F.hs imports A/F.hs. how can i load A/B/F.hs into "cabal repl"?
13:00:00 <cloudhead> it's a node of a tree
13:00:55 <cloudhead> essentially I'd like to have a function which returns a lens into the tree
13:00:59 <Lutin`> willem: You can do `cabal repl B.F`
13:01:02 <dwcook> cloudhead: a possibly better question might be: How can I perform operations like these particular lenses perform without having an appropriate Traversable instance? You'd have to mention what operations you want though. And I personally am not that familiar with lens.
13:01:21 <Lutin`> willem: Or use the other flags like --with-PROG
13:01:27 <Lutin`> willem: See `cabal repl --help`
13:01:43 <cloudhead> right, the main operation would be modifying an individual node
13:02:00 <Lutin`> Or if you just want to import it in the repl you can just `:m +B.F
13:02:08 <exicer> Is there a way to use postgres-simple to return, from a query, [(SomeType, Int)], if you have defined fromRow for SomeType ?
13:02:26 <willem> Lutin`: thank you
13:03:07 <dwcook> hiptobecubic: One advantage I notice is there's no messing with Maybe.
13:03:34 <dwcook> hiptobecubic: Ah, never mind, they just include the "Nothing" in the type.
13:04:50 <cloudhead> dwcook: type Root = Node; modify :: Id -> (Node -> Node) -> Root -> Root
13:05:32 <dwcook> cloudhead: Sorry, I can't really help you with lens. Maybe try #haskell-lens?
13:05:42 <edwardk> cloudhead: you don't need Traversable, just a Traversal.
13:05:57 <Lutin`> ^ the guy to ask haha
13:05:59 <edwardk> cloudhead: what parts are you trying to get to in what structure?
13:06:20 <Lutin`> edwardk: I swear you have lens as a highlight word
13:06:23 <cloudhead> edwardk: how do I get a Traversal though?
13:06:24 <cloudhead> haha
13:06:44 <edwardk> cloudhead: both f (a,b) = (,) <$> f a <*> f b  -- is a traversal of both halves of an either
13:07:10 <edwardk> _2 f (a,b) = (,) a <$> f b -- traverses the second half (it is actually a lens because it only uses (<$>) not (<*>) and/or pure.
13:07:28 <cloudhead> edwardk: I have a tree structure, nodes have a unique id; I need a function :: Id -> Root -> Lens    essentially
13:07:31 <Black-Heaven> joshc: ho, sorry
13:07:59 <cloudhead> ie: return a lens to a node with a specific Id, so I can modify it/view it
13:08:07 <Black-Heaven> https://www.fpcomplete.com/school/to-infinity-and-beyond/pick-of-the-week/type-families-and-pokemon but hey use only one typeclass. Is their a way to provide a type/data family which imply to be an instance of an other typeclass? Thanks in advance for your advices.
13:08:31 <edwardk> you want instead Id -> Lens -- te lens itself gets passed the root
13:08:38 <edwardk> but its not a Lens
13:08:47 <edwardk> you don't have a guarantee the Id is in the tree!
13:09:12 <edwardk> so it can be a traversal at best, or a lens to Maybe Node if you have a single level, etc.
13:09:15 <coppro> anyone know why I'm getting
13:09:22 <coppro> getProtocolByName: does not exist (no such protocol name: tcp)
13:09:51 <f-a> where is that from coppro
13:10:05 <coppro> f-a: I'm not sure precisely. I *think* it's from smtp-mail
13:10:09 <coppro> I'm trying to send an email
13:10:20 <coppro> it's the only actual network code in this so that's the most likely culprit
13:10:27 <edwardk> e.g. at :: Int -> Lens (IntMap a) (IntMap b) (Maybe a) (Maybe b) -- lets you insert or delete an Id, but it can only do so because the Id has a canonical place it should be put
13:10:51 <coppro> it's in /etc/protocols
13:10:54 <edwardk> when you just have a free form soup of Ids in nested maps you've underconstrained the problem too much
13:11:07 <cloudhead> edwardk: I see :/
13:11:46 <cloudhead> edwardk: but given a node which exists in a tree, I should be able to get a lens from that, right?
13:11:49 * hackagebot hoogle 4.2.33 - Haskell API Search  http://hackage.haskell.org/package/hoogle-4.2.33 (NeilMitchell)
13:11:52 <edwardk> if there is exactly one place where an Id can occur then you can make a full lens that can 'create' missing Ids, using either the non trick or something else.
13:12:01 <edwardk> what you want is really a traversal
13:12:04 <edwardk> that is safer
13:12:17 <edwardk> then you can use it with singular to assert you know better that its actually present
13:12:49 <f-a> coppro: http://www.haskell.org/pipermail/haskell/2002-March/009063.html does this helps? is that similar to your case?
13:13:58 <cloudhead> edwardk: I think I understand, I should be able to do the same operations as with lenses right?
13:14:07 <cloudhead> except it'll perform them in a different way
13:14:08 <edwardk> fetch i = deepOf (_Node.traversed) (_Node.ix i) -- should probably do it. that'll traverse all of the nodes labeled i that aren't contained in other nodes labeled i recursively
13:14:25 <edwardk> now if you _know_ the key is in there you can use singular (fetch i)
13:14:45 <edwardk> (if you know its in there exactly in one place
13:15:54 <edwardk> deepOf t p -- will recursively walk using t as long as p keeps returning an empty set of targets, whenever p returns leaves it'll take those and stop recursing in that part of a tree
13:16:07 <edwardk> deep = deepOf plate
13:16:28 <edwardk> so if you add instance Plated Node where plate = _Node.traversed
13:16:36 <edwardk> then this code is 'deep (_Node.ix i)'
13:17:18 <cloudhead> hmmm
13:17:25 <cloudhead> and the return type of `fetch`
13:17:32 <cloudhead> is like a lens?
13:17:48 <cloudhead> what I mean is, if I call fetch once, can I use it to modify the value?
13:17:56 <andrea_> what means IO ()
13:18:04 <andrea_> why not only IO
13:18:30 <edwardk> fetch :: Id -> Traversal' Node Node
13:18:40 <cloudhead> andrea_: Monads always have an underlying type, in this case '()'
13:18:49 <zwer> IO has a kind of * -> *, so one argument has to follow it
13:18:54 <zwer> one type*
13:19:02 <f-a> andrea_: IO is a monad, and the ki- what cloudhead and zwer said
13:19:04 <edwardk> foo & fetch 3 %~ ...   replace ... with the Node -> Node function you want to edit with, etc.
13:19:13 <edwardk> that will work even if there are multiple targets or not
13:19:15 <f-a> imagine it as a "IO action that doesn't have a result attached"
13:19:24 <coppro> f-a: yeah, my system was in a broken state. I fixed installing and it worked. Thanks
13:19:27 <edwardk> foo^..fetch 3 will give you all the nodes labeled 3 not contained in a node labeled 3
13:19:33 <f-a> good job coppro
13:19:50 <cloudhead> edwardk: ok, great
13:19:52 <andrea_> putStrLn, main, etc has return type IO ()
13:20:32 <f-a> indeed andrea_ , because they *perform* some impure IO action but don't *return* anything.
13:20:34 <cloudhead> edwardk: thanks a lot, I will try to manage from here
13:20:39 <edwardk> cloudhead: if you want to make the global claim the value is present and has only one target you can use 'singular (fetch i)'
13:20:44 <edwardk> k
13:20:50 <f-a> check the signature of readFile, something which indeed returns something, andrea_
13:20:59 <andrea_> f-a, ok they return nothing,
13:21:00 <cloudhead> ok
13:23:17 <andrea_> are IO mona and state monad similar ?
13:23:25 <Peaker> andrea_: nope
13:23:41 <f-a> well, they are both monads :P
13:23:47 <andrea_> lol
13:24:09 <f-a> IO monads allows you to perform impure stuff
13:24:15 <f-a> state monad allows you to carry state
13:24:38 <andrea_> in a state monade i can do impure stuff , ok ?
13:25:23 <andrea_> with pun, get, etc
13:25:27 <andrea_> put, get
13:25:59 <f-a> no
13:26:01 <f-a> a state monad is a convenient way to express stateful computation
13:26:01 <f-a> instead of having functions like funa para state, funb par state
13:26:17 <Peaker> andrea_: State s a ~= s -> (s, a)      which is just a pure function.    IO a   is a very large sum type at best, or has no real implementation outside of RTS magic at worst
13:26:27 <f-a> indeed
13:26:37 <andrea_> with a state monad it is posible to programm imperative, right ?
13:26:44 <Peaker> andrea_: No
13:26:52 <f-a> it is just possible to pass state
13:26:59 <f-a> imaginine a function with signature
13:27:13 <f-a> fun :: SomeState -> Int -> (SomeState, Int)
13:27:21 <f-a> ^-- would you call this impure?
13:27:22 <f-a> no
13:27:36 <f-a> State is a convenient way to "hide" (pardon the word) that
13:27:52 <andrea_> with do notation it looks like imperative
13:28:05 <f-a> that's why I dislike do notation ;)
13:28:17 <andrea_> ok
13:28:19 <f-a> try rewriting a simple State function using >> and >>=
13:28:43 <f-a> and better yet, look at the instance of State!
13:28:50 <f-a> you will see how it goes
13:30:06 <andrea_> which type does a state manipulating function return ?
13:31:20 <f-a> State s a
13:31:34 <andrea_> ok
13:31:38 <f-a> which, unwrapped, is s -> (a, s)
13:31:48 <f-a> (look at my previous example, looks the same, isn't it?)
13:32:27 <andrea_> which is the correct type of o state manipulation function, not only the return value
13:32:53 <f-a> stateFun :: State s a
13:32:58 <f-a> if it takes parameters
13:33:09 <f-a> stateFun :: b -> State s a
13:33:14 <f-a> s is the state type
13:33:18 <andrea_> only a return value, no parameters ?
13:33:20 <f-a> a the 'return' type
13:33:47 <f-a> nope
13:33:55 <__sebastian___> creating strict versions of modules is black magic
13:34:42 <f-a> andrea_: State s a is |newtype State s a = s -> (a, s)|
13:34:43 <andrea_> f-a, b -> State s a , what is b here ?
13:35:09 <f-a> if your stateful function takes a parameter, b is the parameter
13:35:28 <andrea_> ok
13:35:29 <f-a> addToState 3 <-- :: Int -> State Int ()
13:35:34 <andrea_> i tried this
13:36:25 <andrea_> not all haskell interpreter/compiler can do this, i think
13:36:40 <andrea_> only ghs can do this, ok ?
13:36:43 <f-a> no
13:36:47 <f-a> every compiler should
13:36:48 <andrea_> ghc
13:36:52 * hackagebot tidal 0.4.4 - Pattern language for improvised music  http://hackage.haskell.org/package/tidal-0.4.4 (AlexMcLean)
13:36:55 <f-a> given you imported Control.Monad.State
13:36:55 <DanielDiaz1> cehteh: no, I am not. Daniel Díaz is a fairly common name...
13:37:03 <latro`a> did you import Control.Monad?
13:37:04 <f-a> or whatever module you need to import
13:37:05 <latro`a> @ and
13:37:08 <latro`a> @ andrea_
13:37:09 <andrea_> hugs shows an error
13:37:17 <f-a> relay the error.
13:37:18 <andrea_> ghc : no error
13:37:20 <cehteh> DanielDiaz1: thought so, just asking to be sure :)
13:37:58 <geardev> Hello!
13:38:04 <f-a> good day
13:38:09 <geardev> hi f-a
13:38:31 <geardev> it's been awhile for me
13:39:16 <geardev> my question today: why do people say that the module system for haskell is limited? would someone mind comparing the module system of haskell to python or javascript? are these languages' module even more so limited? what are some decent module systems available?
13:39:18 <andrea_> f-a: is it possible to adapt imperative algoithms to functional paradigm ?
13:39:38 <dwcook> andrea_: Yes.
13:39:40 <f-a> andrea_: it is very possible to *adapt* them
13:39:41 <Peaker> geardev: usually that is made in reference to SML or other languages which have support for first-class modules
13:39:52 <Fuuzetsu> :t zipWith ($)
13:39:53 <lambdabot> [b -> c] -> [b] -> [c]
13:39:56 <Peaker> geardev: in Haskell, modules are really only namespace containers
13:39:57 <Fuuzetsu> @hoogle [b -> c] -> [b] -> [c]
13:39:59 <lambdabot> Control.Applicative (<*>) :: Applicative f => f (a -> b) -> f a -> f b
13:40:00 <lambdabot> Control.Applicative (<**>) :: Applicative f => f a -> f (a -> b) -> f b
13:40:00 <lambdabot> Prelude map :: (a -> b) -> [a] -> [b]
13:40:11 <andrea_> i want adapt the dlx , exact cover algorithm ( donald knuth)
13:40:56 <Peaker> geardev: in SML, modules are functions from modules/types to such containers.  You can parameterize modules and pass them as arguments to other modules, etc.
13:41:08 <andrea_> it's a backtracking algorithm
13:41:40 <andrea_> my ide was to use state monads
13:41:47 <Peaker> geardev: one example mode of use of this is sort of dependency injection, where instead of importing stuff you need, hard-coding the implementation you're using, you can take the module implementing the functionality you need as an argument
13:42:29 <f-a> andrea_: knowing absolutely 0 about that particular algo, if you need Stateful computation, then use the State Monad
13:43:40 <geardev> Peaker: thanks peaker!
13:45:05 <andrea_> thanks for the help
13:45:28 <f-a> good luck in your quest andrea_ . Try to search a bit, maybe someone else implemented it already
13:46:00 <andrea_> f-a: i want program easy problems to learn haskell
13:46:34 <dwcook> andrea_: You might also be interested in ST, which lets you use self-contained impure computations in such a way that they are extensionally pure.
13:46:34 <bjorkintosh> andrea_, arithmetic :)
13:46:50 <solidus-river> andrea_: things in haskell have to be functoinally pure, but using StateT and Store you can have all the impure mutatable state you want within a function ;)
13:47:02 <f-a> andrea_: go through Real World Haskell http://book.realworldhaskell.org/read/ and then some project euler
13:47:03 <solidus-river> also, i can't type
13:47:23 <dwcook> Strictly speaking StateT and Store are also pure
13:47:27 <andrea_> f-a: this book is too much difficult for me
13:47:33 <f-a> then wait
13:47:38 <andrea_> i own a book im my motherlanguage
13:47:39 <f-a> http://learnyouahaskell.com/
13:47:44 <f-a> are you italian andrea_ ?
13:47:47 <f-a> becuase I am too.
13:47:56 <andrea_> f-a, yes this book is better for me
13:48:00 <Tjr> "Fry your brain with haskell - fast."
13:48:03 <andrea_> i am german
13:48:06 <f-a> Learn you a haskell is incredibly nice
13:48:12 <f-a> and gentle
13:48:14 <f-a> and everything
13:48:22 <f-a> go through it and graduate yourself in Haskell
13:48:24 <f-a> for great good
13:48:30 <andrea_> f-a, learn youhasskel , is good , i read it
13:48:34 <f-a> ohh
13:48:37 <f-a> okie
13:48:58 <f-a> http://www.haskell.org/haskellwiki/H-99:_Ninety-Nine_Haskell_Problems <-- then bite those
13:49:10 <andrea_> real haskell, some chapter are ok, but its incredible difficult im my opinion
13:49:27 <f-a> and try to read a bit of RWH again, I found it easier after reading LYAH
13:49:32 <croyd> andrea_: check out the resources here https://github.com/bitemyapp/learnhaskell
13:49:35 <andrea_> yes the haskell problems are nice
13:50:19 <andrea_> what about the speed of haskell ?
13:50:28 <argiopetech> I went through RWH till 1-2 chapters after Monads, at which point I realized I didn't grok monads. Came back after LYAH with great success.
13:50:29 <PragCypher> andrea_: why are you interested in haskell?
13:50:38 <darthdeus> is there a combinator that takes two actions, runs both and throws away both?
13:50:41 <PragCypher> just being curious
13:50:46 <darthdeus> something like    void $ a >> b
13:50:47 <JagaJaga> guys, trying to create my own parser generator. It works well, but trying to check my grammar for regexes, and it seems that it is not LL(1). Can smone helps to make it LL(1)? I will be very grateful.
13:50:48 <andrea_> i think its a very interesting language
13:51:10 <andrea_> nof for job
13:51:14 <andrea_> not for job
13:51:15 <taktoa> LR > LL though isn't it?
13:51:37 <JagaJaga> i think it's LL(k) k > 1
13:51:52 <f-a> try solve some PE too, andrea_
13:52:02 <andrea_> PE ?
13:52:07 <f-a> project euler
13:52:09 <dwcook> darthdeus: Doubtful. I'd just use the functions you mentioned.
13:52:10 <andrea_> what does it mean
13:52:12 <argiopetech> darthdeus: That sounds like something that would be hanging out in Control.Arrow.
13:52:14 <andrea_> ok
13:52:28 <argiopetech> Though you'll probably still have to call void. I'd just use >>.
13:52:36 <andrea_> i salved a diaophantic equation with haskell
13:52:38 <darthdeus> ok, thanks guys :)
13:52:40 <andrea_> solved
13:52:41 <JagaJaga> cause my first sets is intersected
13:52:56 <f-a> keep solving stuff, it's all in the chops
13:53:00 <solidus-river> hmm, wonder what a better initial test of frp libs for gaming is
13:53:03 <f-a> *good for the chops
13:53:04 <solidus-river> space invaders or tetris
13:53:19 <f-a> solidus-river: dig dug
13:53:29 <solidus-river> f-a: wh dig dug?
13:53:32 <solidus-river> *why
13:53:45 <f-a> for sentimental reasons :P
13:53:56 <solidus-river> :P
13:54:16 <argiopetech> f-a: Bah, got to go The NewZealand Story.
13:54:22 <argiopetech> +with
13:54:48 <andrea_> i must go
13:54:50 <andrea_> bye
13:54:58 <f-a> ciao
13:55:20 <f-a> what, argiopetech ?
13:55:53 <argiopetech> Later arcade game by Taito. More sentimental (for me) than Dig Dug. ;)
13:56:08 <f-a> ohhhh, I am going to check it, thanks.
13:56:28 <argiopetech> Many hours of life wasted. Good times.
13:56:47 <f-a> "time you enjoy wasting is not wasted" :)
13:57:45 <argiopetech> I won't contest that point.
14:05:58 <ion> I had that on Amiga.
14:14:32 <dmwit> tommd: Hah, yeah! I'm coming out quite soon... mid-July. Can't wait!
14:16:58 * hackagebot tidal 0.4.5 - Pattern language for improvised music  http://hackage.haskell.org/package/tidal-0.4.5 (AlexMcLean)
14:21:50 <Rufflewind> is Monad fail is going to stick around or will it be removed in the future?
14:29:23 <argiopetech> Rufflewind: It isn't part of the Functor-Applicative-Monad proposal, so I imagine it will be around for at least a few more major version bumps.
14:37:02 * hackagebot Spock 0.6.0.0 - Another Haskell web framework for rapid development  http://hackage.haskell.org/package/Spock-0.6.0.0 (AlexanderThiemann)
14:44:29 <fread2282> does anyone actually use Read?
14:46:36 <rwbarton> of course
14:46:46 <f-a> why shouldn't we
14:47:39 <klrr_> fread2282: poor mans DB? ;) (readDB = read $ readFile "db"; writeDB = writeFile "db" . show)
14:48:32 <cloudhead> is binary-strict supposed to work with GHC 7.8?
14:48:50 <cloudhead> I can't get it to compile
14:49:02 <klrr_> meh fmap read it should be...
14:50:14 <pjdelport> klrr_: ITYM read <$>
14:50:31 <fread2282> klrr_: or use binary
14:51:06 <fread2282> f-a: why would you?
14:51:31 <klrr_> yeah
14:51:51 <klrr_> oh i didnt <$> is prounounced "binary"? i always say fmap :P
14:52:00 <f-a> it's quick, it's handy
14:52:03 <fread2282> klrr_: lol
14:52:21 <klrr_> didnt know*
14:52:30 <fread2282> f-a: it's slow, it has horrible (no) error messages
14:52:53 <fread2282> > read "a" :: Int
14:52:55 <lambdabot>  *Exception: Prelude.read: no parse
14:53:11 <f-a> yeah, for quick and dirty stuff
14:53:21 <joelteon> > read "()"
14:53:22 <lambdabot>  ()
14:53:26 <fread2282> f-a: like what?
14:53:38 <f-a> i.e. two days ago I was reading an input file from a project euler problem
14:53:41 <f-a> it was like:
14:53:48 <klrr_> > read "(::) 1 []"
14:53:49 <lambdabot>  *Exception: Prelude.read: no parse
14:53:51 <f-a> MALON,BORG,FELT
14:53:53 <f-a> etc. etc.
14:53:57 <klrr_> > (::) 1 []
14:53:58 <lambdabot>  <hint>:1:2: parse error on input ‘::’
14:54:01 <klrr_> oh
14:54:05 <joelteon> :: is syntax, not an operator
14:54:06 <klrr_> im thinking idris lol
14:54:13 <klrr_> > read "(:) 1 []"
14:54:14 <f-a> (++ "]") . ("[" ++)
14:54:14 <lambdabot>  *Exception: Prelude.read: no parse
14:54:16 <fread2282> > read "(:) 1 []"
14:54:17 <lambdabot>  *Exception: Prelude.read: no parse
14:54:18 <joelteon> oh, right
14:54:30 <f-a> and then read it to [String]
14:54:35 <klrr_> > (:) 1 []
14:54:37 <lambdabot>  [1]
14:54:40 <f-a> (it was ẅith "s too, actually)
14:54:50 <klrr_> > read "1:2:3:4:[]"
14:54:51 <fread2282> :t parse
14:54:51 <lambdabot>  *Exception: Prelude.read: no parse
14:54:52 <lambdabot> Not in scope: ‘parse’
14:54:57 <f-a> I didn't know of an alternative
14:55:06 <f-a> well, parsec
14:56:33 <fread2282> a Read-like class built on parsec would be nice, but IMO Read itself should die
14:56:49 <joelteon> we already have ReadP
14:56:54 <f-a> then how I could import that list?
14:57:04 * hackagebot cabalg 0.2.4 - alias for cabal install from given git repo  http://hackage.haskell.org/package/cabalg-0.2.4 (DmitryMalikov)
14:59:53 <fread2282> f-a: what you did but instead of read use parse readParsec "" and match on the resulting Either
15:00:03 <argiopetech> `(char '"' *> takeTill (== '"') <* char '"') `sepBy'` (char ',')` isn't that bad...
15:00:19 <argiopetech> (that's attoparsec syntax, btw)
15:00:43 <f-a> it's like dieting
15:00:48 <f-a> you need cheat days
15:00:53 <fread2282> readp's still slow
15:01:17 <argiopetech> I wouldn't know about dieting (...) but I'll admit to overusing `read`.
15:01:21 * fread2282 wonders if Read could be written using GHC.Generics
15:01:46 <argiopetech> If it goes out to the public or it feels slow, I'll rewrite as a proper attoparsec parser.
15:02:01 <argiopetech> But until then, I load lots of multiple-hundred MB files with read.
15:03:48 <f-a> fread2282: good luck in your quest (if I may point to a more evident blemish in our armor: N+K patterns). For now, goodnight!
15:10:21 <geekosaur> n+k is history now though
15:17:41 <benzrf> in pipes
15:17:54 <benzrf> when i say 'producer >-> consumer'
15:18:09 <benzrf> every time the consumer awaits, the producer is run from the beginning again, right?
15:18:56 <enthropy> if it's like conduit, the producer doesn't have to repeat stuff like opening a file
15:19:16 <enthropy> though the detail depends on how you write producer
15:28:49 <quchen> benzrf: Yes, conceptually every await is matched with one yield.
15:29:35 <quchen> The producer isn't necessarily run from the beginning again. each [1,2] is similar to yield 1 >> yield 2, which is a producer with two yields.
15:29:49 <benzrf> nope its parallel
15:29:51 <benzrf> yea
15:29:55 <benzrf> im confused tho
15:30:01 <benzrf> im reading the coder
15:30:02 <benzrf> *code
15:30:05 <benzrf> it seems wrong x.x
15:30:14 <quchen> Code of what
15:30:43 <burz> Hey guys, I was wondering if you know what the Parsec error "unexpected ()" means
15:32:30 <benzrf> quchen: of pipes!
15:33:03 <quchen> I don't think there's anything parallel in pipes.
15:34:48 <benzrf> http://bpaste.net/show/375641/ <- quchen
15:35:11 <phaazon> hi
15:36:30 <phaazon> @hoogle (a -> m b) -> [a] -> m [b]
15:36:32 <lambdabot> Prelude mapM :: Monad m => (a -> m b) -> [a] -> m [b]
15:36:32 <lambdabot> Control.Monad mapM :: Monad m => (a -> m b) -> [a] -> m [b]
15:36:32 <lambdabot> Control.Monad forM :: Monad m => [a] -> (a -> m b) -> m [b]
15:36:38 <phaazon> ok, fair enough, now:
15:36:46 <phaazon> @hoogle (a -> m [b]) -> [a] -> m [b]
15:36:46 <lambdabot> No results found
15:37:07 <phaazon> @let concatMapM = fmap concat . mapM
15:37:09 <lambdabot>  Defined.
15:37:15 <phaazon> :t concatMapM
15:37:16 <lambdabot> (a1 -> [a]) -> [a1] -> [a]
15:37:28 <phaazon> wat
15:37:28 <quchen> benzrf: As soon as one of the connected pipes finishes, the entire thing returns. Your consumer never finishes, but the producer does (after two values).
15:37:41 <Mathnerd314> so what's an example of a Traversable that isn't Applicative, or an Applicative that isn't Traversable?
15:38:06 <phaazon> why has constraint disappeared?
15:38:17 <benzrf> quchen: yes i know
15:38:29 <benzrf> but based on the code it seems like each await should start threefour from scratch o.o
15:39:40 <rwbarton> phaazon:  you composed wrong
15:40:17 <hexagoxel> phaazon: because m is []
15:40:32 <quchen> benzrf: I don't see why the code looks like that. But that's a matter of opinion I guess.
15:40:46 <benzrf> no, i mean the Pipes source
15:41:07 <hexagoxel> :t fmap (=<<) . mapM
15:41:08 <lambdabot> (a1 -> a -> b) -> [a1] -> [a] -> [b]
15:41:28 <hexagoxel> well oops
15:41:32 <benzrf> zipWith?
15:41:33 <benzrf> :-)
15:41:42 <benzrf> :t fmap (=<<) .: mapM
15:41:43 <lambdabot>     Not in scope: ‘.:’
15:41:43 <lambdabot>     Perhaps you meant one of these:
15:41:43 <lambdabot>       ‘.’ (imported from Data.Function),
15:41:47 <benzrf> -.-
15:42:04 <benzrf> @let (f .: g) x y = f (g x y)
15:42:06 <lambdabot>  Defined.
15:42:08 <benzrf> :t fmap (=<<) .: mapM
15:42:09 <lambdabot>     Couldn't match type ‘[b1]’ with ‘a -> m b’
15:42:09 <lambdabot>     Expected type: (a1 -> f b1) -> [a1] -> f (a -> m b)
15:42:09 <lambdabot>       Actual type: (a1 -> f b1) -> [a1] -> f [b1]
15:42:09 * hackagebot wai-routing 0.9 - Declarative routing for WAI.  http://hackage.haskell.org/package/wai-routing-0.9 (ToralfWittner)
15:42:10 <phaazon> :t fmap (return . concat) . mapM
15:42:11 <lambdabot> Monad m => (a1 -> [a]) -> [a1] -> m [a]
15:42:13 <benzrf> or not i guess
15:42:31 <phaazon> :t fmap (fmap concat) . mapM
15:42:32 <lambdabot> (Functor f, Monad f) => (a1 -> f [a]) -> [a1] -> f [a]
15:42:46 <benzrf> oic i misread the code
15:42:48 <benzrf> >.<
15:59:23 <benzrf> pipes is pretty sweet 8D
16:01:28 <hexagoxel> :t (liftM join .) . mapM
16:01:29 <lambdabot> Monad m => (a1 -> m [a]) -> [a1] -> m [a]
16:02:58 <benzrf> once you start doing composition sections i stop trying to understand
16:03:54 <enthropy> \f -> liftM join . mapM f -- straightforward
16:04:12 <benzrf> meh
16:04:20 <shachaf> :t liftM liftM liftM liftM (liftM liftM) liftM join mapM -- why go the straightforward route?
16:04:20 <lambdabot> Monad m => (a1 -> m [a]) -> [a1] -> m [a]
16:04:31 * benzrf screams
16:04:44 <benzrf> why liftM join
16:04:47 <benzrf> why not join
16:04:58 <benzrf> oic
16:05:36 <fread2282> what's the advantage of doing instance a ~ b => Foo (Bar a) as compared to instance Foo (Bar b) ?
16:06:00 <enthropy> fread2282: none if that's actually the instance
16:06:10 <benzrf> enthropy: i assume b is a stand in for a specific type
16:06:36 <fread2282> yep
16:06:43 <enthropy> but if you have something like  class C a b,    instance (a ~ b) => C a b {- matches more often than -}   instance C a a
16:07:01 <fread2282> why do I see instance a ~ Char => IsString [a] ?
16:07:14 <fread2282> instead of instance IsString [Char]
16:07:35 <enthropy> because it lets ( fromString [] ) decide the empty list there has type [Char]
16:08:28 <fread2282> ahh
16:08:32 <enthropy> rather than waiting for you to write an annotation that says it contains Char, before picking the instance
16:08:51 <enthropy> @type fromString
16:08:52 <lambdabot>     Not in scope: ‘fromString’
16:08:52 <lambdabot>     Perhaps you meant one of these:
16:08:52 <lambdabot>       ‘BSLC.fromStrict’ (imported from Data.ByteString.Lazy.Char8),
16:09:30 <enthropy> oops, I butchered that example a bit
16:09:51 <enthropy> but I guess you see the point?
16:10:24 <enthropy> fromString :: IsString a => String -> a -- so pretend my point was about fixing the result type
16:10:51 <enthropy>  fromString "blah" `asTypeOf` [] -- decides ([] :: [Char])
16:11:00 <rwbarton> or  length (fromString "blah")
16:12:13 * hackagebot language-gcl 0.2 - Something similar to Dijkstra's guarded command language  http://hackage.haskell.org/package/language-gcl-0.2 (StijnVanDrongelen)
16:12:17 <rwbarton> or any []-only function like ++ really, it means your old String code can still work without annotations as long as it isn't overly polymorphic
16:16:09 <shachaf> IsString has that instance now?
16:16:12 <shachaf> Is that new in HEAD?
16:18:05 <enthropy> funny how such a technique takes something like a decade to become legitimate
16:18:12 <chrisdotcode> when are we getting OverloadedRecordFields? :D
16:18:37 <benzrf> :t fromString
16:18:38 <lambdabot>     Not in scope: ‘fromString’
16:18:38 <lambdabot>     Perhaps you meant one of these:
16:18:38 <lambdabot>       ‘BSLC.fromStrict’ (imported from Data.ByteString.Lazy.Char8),
16:18:42 <benzrf> heuh
16:31:27 <tristanStrange> where do examples get installed to when you grab them with cabal?
16:31:36 <tristanStrange> do we only get the executables this way?
16:31:43 <tristanStrange> what if I'm after the source?
16:32:21 <shachaf> You can get the source if you're after it.
16:32:55 <shachaf> cabal unpack will even download and extract them for you.
16:33:06 <shachaf> ...Them, the packages.
16:34:48 <solidus-river> hey all, i'm having trouble installing lens, in particular aeson fails with a problem related to Scientific changing what it's modules export?
16:35:04 <tulcod> should i report this as a bug? http://pastebin.com/Mi0XqYMr
16:35:29 <solidus-river> http://lpaste.net/105638
16:35:39 <benzrf> solidus-river: have you tried removing every package and starting over
16:35:49 <dwcook> tulcod: Yes, panics are always unintentional.
16:35:54 <solidus-river> benzrf: what do yo umean by that?
16:36:05 <solidus-river> benzrf: i am using sandbox's
16:36:12 <benzrf> oh
16:37:09 <mzero> that should work in a sandbox - unless you've got some package installed globally that isn't part of GHC or the Platform... do you think you might have installed something like builder or scientific non-sandboxed?
16:37:42 <mzero> you can run  "ghc-pkg list" to find out -- put it in an lpaste
16:37:47 <solidus-river> mzero: i might have but not on purpose, how can i check?
16:37:49 <solidus-river> oh
16:37:56 <mzero> :-)
16:40:48 <hcaulfield57> Could someone show me how to make a array of arrays? I'm a bit stumped
16:41:03 <solidus-river> oh my
16:41:07 <solidus-river> help! O_O
16:41:11 <solidus-river> http://lpaste.net/105639
16:41:23 <hellen_haskeller> anz
16:41:43 <solidus-river> :t [[]]
16:41:44 <lambdabot> [[t]]
16:41:52 <solidus-river> hcaulfield57: ^
16:42:21 <hcaulfield57> I don't get it
16:42:26 <solidus-river> :t [[2]]
16:42:27 <lambdabot> Num t => [[t]]
16:42:36 <hellen_haskeller> pardon...anyone here using haskell as a database and what windows interface is in fasion?
16:42:44 <solidus-river> :t [[2,3,6],[1,8,3],[18]]
16:42:45 <lambdabot> Num t => [[t]]
16:43:00 <phoniel> Hey guys! I've just installed haskell-platform, then done cabal update, then cabal install cabal-install. When I look at cabal --version, I find I have version 1.20.0.2, but when I check ghc-pkg, I find that cabal's version is 1.16. Why is haskell using a lower version of cabal than I've installed?
16:43:03 <solidus-river> hcaulfield57: thats an array of arrays :)
16:43:15 <hcaulfield57> solidus-river: It's a list of list :)
16:43:26 <solidus-river> hcaulfield57: :X
16:43:29 <mzero> phoniel: I can help you in a min. as soon as I'm off the phone
16:43:31 <geekosaur> phoniel, they're different htings
16:43:49 <solidus-river> i have no clue what to do about all those problems iwth my packages
16:43:52 <geekosaur> `cabal --version` shows you the version of the cabal command, which hackage calls cabal-install
16:44:15 <geekosaur> `ghc-pkg` is showing you the version of the cabal library that ships with ghc, which hackage calls `Cabal`
16:44:55 <geekosaur> (the library predates the command by many years)
16:45:08 <hcaulfield57> Anyone know how to make an Array of Arrays
16:45:20 <coppro> hcaulfield57: Array (Array a)?
16:45:32 <geekosaur> hcaulfield57, you don't normally. you can make multidimensional Arrays though
16:45:34 <hcaulfield57> coppro: Yea, but an example of how to make one?
16:45:45 <dwcook> hcaulfield57: You can make Arrays with tuple limits, that's probably a better idea.
16:45:51 <geekosaur> (you *can* do it but there may be reasons not to)
16:45:52 <coppro> hcaulfield57: As geekosaur said, you generally don't
16:45:58 <dwcook> Not that you _can't_ make an Array of Arrays, it's probably just more laborious.
16:46:29 <dwcook> Well I guess I'm an echo :P
16:46:30 <tulcod> can i use $(..) in ghci?
16:46:31 <hcaulfield57> Well, I can easily make an Array of lists, but I was thinking why not use Arrays of Arrays?
16:46:36 <solidus-river> hcaulfield57: i cant test now because my haskell installation is foobar'd
16:46:46 <solidus-river> but i'd guess something like
16:46:50 <hcaulfield57> I'm trying to index values from hdbc
16:46:57 <tulcod> like, can i during runtime define a type using the AST?
16:47:05 <solidus-river> newArray (1,10), $ newArray (1,10) 37
16:47:10 <hcaulfield57> solidus-river: that was me awhile ago.
16:47:20 <phoniel> what I'm confused by is that that I have a project cloned from git, and it has a .cabal configuration file, and what I understand is called a sandbox, but when I try cabal install --only-dependencies I get a message that looks like "
16:47:21 <solidus-river> newArray (1,10) $ newArray (1,10) 37
16:47:24 <solidus-river> hcaulfield57: ^ that work?
16:47:30 <dwcook> hcaulfield57: Because it's easier to have an Array (Foo, Bar) Baz than an Array Foo (Array Bar Baz).
16:47:31 <phoniel> Resolving dependencies...
16:47:31 <phoniel> cabal: Could not resolve dependencies:
16:47:31 <phoniel> trying: hart-0.1.0.0
16:47:31 <phoniel> rejecting: base-4.6.0.1/installed-8aa... (conflict: hart => base>=4.7 && <4.8)
16:47:31 <phoniel> rejecting: base-4.7.0.0, 4.6.0.1, 4.6.0.0, 4.5.1.0, 4.5.0.0, 4.4.1.0, 4.4.0.0,
16:47:34 <phoniel> 4.3.1.0, 4.3.0.0, 4.2.0.2, 4.2.0.1, 4.2.0.0, 4.1.0.0, 4.0.0.0, 3.0.3.2,
16:47:36 <phoniel> 3.0.3.1 (global constraint requires installed instance)
16:47:37 <geekosaur> tulcod: there are some limitations (the bytecode backend, used by both ghci and TH, is not reentrant) but I think some things work?
16:47:48 <hcaulfield57> solidus-river: Is that from the standard array library?
16:47:53 <hcaulfield57> I don't have newArray
16:48:01 <geekosaur> phoniel: you can't upgrade base, and that hart package version isn't compatiblre with your ghc as a result
16:48:12 <solidus-river> hcaulfield57: http://www.haskell.org/haskellwiki/Arrays
16:48:16 <tulcod> cause i'm trying: Prelude> $([d|data Bla = Bla|])    which doesn't seem to work ("Couldn't match type [Dec] with Exp")
16:48:17 <geekosaur> (base is wired into your ghc installation, only way to upgrade it is to upgrade ghc)
16:48:37 <geekosaur> that seems wromng to me
16:48:43 <phoniel> So is the solution to my problem upgrading ghc?
16:48:51 <tristanStrange> cheers shachaf
16:48:52 <tulcod> (although that does work top level in a compiled haskell file)
16:48:54 <geekosaur> [d|...] is a quasiquote, doesn't need $( _
16:48:58 <geekosaur> er $( )
16:49:21 <tulcod> geekosaur: well i'm trying to write "data Bla = Bla" in a complicated way
16:49:32 <tulcod> like, define that Bla datatype using TH
16:49:34 <geekosaur> oh, ok, then the problem is that ghci has to specially recognize data declarations, but it can't when it's generated by TH
16:49:42 <hcaulfield57> solidus-river: I was looking at immutable Data.Array moduel
16:49:44 <geekosaur> `data` is special syntax to GHCI
16:49:50 <tulcod> ah right, that makes sense
16:50:16 <tulcod> is there any way to get it working after all or is this a limitation of ghci?
16:50:25 <dwcook> hellen_haskeller: What do you mean by using it as a database? Are you looking for database bindings or something else?
16:50:36 <geekosaur> limitation of ghci, I think
16:51:04 <geekosaur> since it is treating `data` as a special command in this case, and TH doesn't generate GHCI special commands, it generates ASTs --- and ghci doesn't know what to do with such an AST
16:51:09 <hcaulfield57> hellen_haskeller: I've been using HDBC to connect to a Sqlite database for a program I'm working onw.
16:51:28 <geekosaur> in theory ghci could be modified to support it, but I suspect it'd be a fair amount of work
16:51:54 <solidus-river> how can i tell if base 4.6.0.1 is correct?
16:52:02 <solidus-river> i think that migh tbe my problem
16:52:05 <geekosaur> since it doesn't currently expect an expression to produce an AST
16:52:09 <solidus-river> what do i do to get onto the latest base
16:52:17 * hackagebot simple 0.10.0.1 - A minimalist web framework for the WAI server interface  http://hackage.haskell.org/package/simple-0.10.0.1 (AmitLevy)
16:52:46 <geekosaur> solidus-river, as I said to phoniel earlier, base is wired into ghc so you need to upgrade ghc
16:52:59 <phoniel> how does one upgrade ghc?
16:53:02 <solidus-river> geekosaur: i understand but i'm lost on these errors
16:53:08 <solidus-river> like what base to what version of ghc, is that even my problem?
16:53:12 <solidus-river> it wa sjust a wild guess
16:53:16 <solidus-river> pretty much 0 logic behind it
16:53:26 <solidus-river> phoniel: depends on your system
16:53:36 <dwcook> phoniel: One way is to download from here and follow any relevant instructions https://www.haskell.org/ghc/download
16:53:37 <phoniel> ubuntu 13.10
16:53:54 <geekosaur> 4.6.0.1 isn't even latest base, I think; it's ghc 7.6.3 (I'm looking at the haskell platform haddocks)
16:53:55 <solidus-river> phoniel: you need to uninstall apts version and compile from source i think
16:54:29 <dwcook> phoniel: solidus-river: Compiling isn't necessary, there are binaries available from the link above.
16:54:43 <solidus-river> geekosaur: i'm on 2013.2.0.0
16:54:47 <geekosaur> yep 4.6.0.1 goes with ghc 7.6.3
16:54:51 <solidus-river> geekosaur: of the haskell platform
16:55:12 <dwcook> (Besides, you need GHC to compile GHC, so uninstalling it beforehand wouldn't work. :)
16:55:23 <solidus-river> yeah i'm on 7.6.3
16:55:39 <solidus-river> but is that why these arent installing?
16:55:41 <Mathnerd314> edwardk: so why is there both http://hackage.haskell.org/package/vector-space and from http://hackage.haskell.org/package/linear ?
16:56:15 <geekosaur> actually the only real breakage I see there is data-default
16:56:34 <edwardk> vector-space has slightly different design goals than linear. linear was written originally as part of a toy physics package. i eventually split out the lens parts of it into lens
16:56:39 <geekosaur> the other packages are broken because data-default is
16:57:23 <geekosaur> (all the haddock errors are noise; they mean there is missing local documentation)
16:57:26 <edwardk> but linear is about exploring the fact that every vector space is a free vector space "(e -> r) for some basis e", so we can use representable functors "(f r ~ e -> r) for some e" to represent them.
16:57:41 <phoniel> Once I have the binary, do I have to uninstall ghc?
16:58:03 <edwardk> vector-space lets you make monomorphic modes, but as a result you can't use the vector-of-vectors as matrix encoding linear uses throughout
16:58:10 <edwardk> also linear covers sparse cases
16:58:11 <geekosaur> solidus-river, so you need to reinstall data-default, then reinstall the other packages because they depend on it
16:58:24 <geekosaur> (that is, the other packages it tells you are broken, xmonad etc.)
16:58:40 <edwardk> i released linear originally because acowley wanted to use it for a bunch of robotics
16:58:46 <solidus-river> geekosaur: hmm, is ther ea utility to do that?
16:58:54 <solidus-river> *there
16:59:06 <edwardk> but because of the structure of vector-space i couldn't use it
16:59:08 <mzero> oy- that was a long phone call... but back
16:59:12 <geekosaur> I don'tthink there's currently a convenient way to do so. but it's only 4 packages
16:59:25 <mzero> now, er, someone having trouble with cabal install cabal-install and still having the old one on the path?
16:59:40 <geekosaur> cabal install --reinstall data-default X11 X11-xft xmonad xmonad-contrib
17:00:11 <mzero> phoniel: the likely issue is that whereever cabal put the binary of the new cabal, that dir isn't on your PATH
17:00:12 <geekosaur> it will warn you about breakage but the only packages that would be broken by reinstalling are the ones you already have to reinstall anyway because theuy
17:00:16 <geekosaur> er. they're already broken
17:00:40 <geekosaur> phoniel, mzero: also note `hash -r` to make the shell see new stuff on $PATH
17:00:49 <mzero> true dat
17:01:19 <geekosaur> (but that won't hep if it didn't install in a dir currently on $PATH, or if the newly installed command is later on $PATH than the one the shell knows about)
17:01:32 <gspr> I have a bunch of numeric data in many relatively big (~50 MB) files. In a pure computation I will need on the order of 1% of the data from a few of these files. Is there a good way to attack this problem without loading the files into memory or coupling my computation to IO? So far I can only think of mmap...
17:01:45 <mzero> phoniel: if you are on Mac, this is, alas, common, as ~/bin isn't on the PATH by default
17:01:48 <solidus-river> man, this channel is popular today
17:01:51 <phoniel> Okay! I'm going to uninstall and put in the binary, and then come back to you guys!
17:02:05 <phoniel> (that is, the newer version of ghc)
17:02:06 <mzero> uninstall?
17:02:15 <mzero> er - because you need 7.8.x?
17:02:21 <mzero> that seems like a big pain!
17:02:34 <phoniel> I'm apt-get autoremove'ing haskell-platform
17:02:36 <gspr> (Let's say the files are structured enough that finding the needed data, though not O(1), is a matter of relatively simple seeking - no heavy parsing)
17:02:43 <phoniel> what's a better option?
17:03:03 <phoniel> I'm a little on the n00b side of things
17:03:06 <mzero> well, if you need 7.8 - nothing, as there is no platform for 7.8 (yet)
17:03:24 <mzero> if you don't need 7.8, then... well... it is a fair bit of work to build it up by scratch
17:03:34 <mzero> if you do need 7.8 --- well, you've got some work
17:03:37 <mzero> :-P
17:04:46 <phoniel> Hmmmm.... :/
17:04:56 <phoniel> How much work we talkin?
17:05:05 <mzero> sorry - I missed a bunch of context - is the only problem that you can't get the newer cabal install?
17:05:18 <kadoban> The compilation from source was pretty painless last I did it.
17:05:54 <kadoban> At least on ubuntu derived, I just used this: https://gist.github.com/ion1/2815423
17:06:02 <mzero> if you hand install GHC 7.8.2 from the bindist tarball (so you are not building GHC yourself... that's painful) ... then there is a short, but manual, bootstrap procedure to get cabal (the command) installed
17:06:11 <Fuuzetsu> anyone with haskell-cafe admin rights? There's this e-mail address that sends back an auto-message to every posting
17:06:26 <Fuuzetsu> would be cool if they could take them off the list for a bit
17:06:47 <phoniel> Guys I just want to code
17:06:52 <phoniel> Why is this so hard?
17:07:00 <mzero> heh... sorry....
17:07:01 <phoniel> SOMEONE GIVE ME SPIRITUAL ADVICE!
17:07:11 <Fuuzetsu> become one with the λ
17:07:18 <tulcod> phoniel: give up. it's never gonna work like you want it to.
17:07:23 <solidus-river> phoniel: first you need to fully observe where the intuition of "i just want to code" came from
17:07:29 <solidus-river> then we can talk about the fallacies involved
17:08:25 <solidus-river> phoniel: in all seriousness, why do you need 7.8?
17:08:27 <bergmark> phoniel: installing the binary distribution of GHC is pretty easy, just make sure you keep a cabal binary around
17:08:29 <solidus-river> 7.6 is fine
17:08:32 <solidus-river> for most things
17:08:37 <mzero> if you don't need 7.8.... I say stay with the platform and 7.6.3... and then just install the newer cabal (we just need to get it on your path)
17:09:44 <phoniel> solidus-river: I'm just muddling around trying to get cabal install to work
17:10:03 <phoniel> because I can't work on the package I got from git without that
17:10:05 <enthropy> Fuuzetsu: I replied with a complaint to that person. I guess that didn't work
17:10:08 <phoniel> as far as I know
17:10:19 <mzero> ah
17:10:26 <Fuuzetsu> enthropy: did you just get another automated message back?
17:10:37 <mzero> well, in all likelyhood - when you did    cabal install cabal-install    all was just peachy
17:10:47 <mzero> the executable was somewhere under   ~/.cabal
17:10:51 <enthropy> dunno I just made a filter to block everything from there
17:11:12 <mzero> all you needed to do was symlink or move it into someplace on your path (usually ~/bin)
17:11:14 <solidus-river> phoniel: whatas the problem your running into specifically?
17:11:17 <Fuuzetsu> I will if no one here can remove them from the list
17:11:40 <phoniel> My friend is explaining "cabal-hell" to me right now
17:12:22 <joelteon> cabal hell is when cabal emits any error message, right?
17:12:45 <hpc> usually cabal hell is when you have butterfly dependencies
17:12:48 <bergmark> joelteon: it seems to be the common usage of the term... :-o
17:12:48 <Mathnerd314> edwardk: ah, in linear you can write type M22 a = V2 (V2 a) but in vector-space there's no such notion of composition. What about tensors? Does linear do tensor products etc.?
17:12:53 <phoniel> He says it's when dependencies have no real solution
17:13:22 <solidus-river> phoniel: you should be sandboxing everything
17:13:29 <phoniel> This is sandboxed
17:13:35 <solidus-river> phoniel: although i guess that doesnt fully save you since i'm running into problems iwth cabal now
17:13:41 <phoniel> okay, here's the sequence of events:
17:13:48 <solidus-river> lpaste it! :)
17:13:52 <solidus-river> if you haven't already
17:13:55 <solidus-river> or pastie or whateer
17:14:15 <edwardk> Mathnerd314: linear has a Covector type that can be used. it models the notion that a linear functional has the form (e -> r) ->_L r  --   where ->_L is a linear function. this is basically Cont limited to not call callCC by th fact that callCC violates linearity
17:14:24 <jasonkuhrt> What is the ++ operator in haskell called?
17:14:44 <edwardk> Mathnerd314: given the Covector r   monad anything you can write with that monad using (>>=), return, <*> etc. are all linear maps
17:14:48 <solidus-river> jasonkuhrt: cons
17:14:55 <solidus-river> wait, no
17:14:55 <edwardk> Mathnerd314: those operations correspond to tensoring, etc.
17:14:57 <phoniel> solidus-river: http://lpaste.net/105641
17:15:01 <phoniel> :)
17:15:32 <hpc> jasonkuhrt: append
17:15:41 <edwardk> jasonkuhrt: "plusplus" ;)
17:16:20 <solidus-river> phoniel: your depending on on text 0.11.3.1 which needs array 0.4 but your package is requiring array >= 0.5
17:16:25 <solidus-river> phoniel: one of those has to change
17:16:42 <jasonkuhrt> : ) thanks guys, its because I am writing a library that bases itself initially upon haskell prelude, but unlike haskell, ++ is not a valid function name
17:16:46 <Mathnerd314> edwardk: isn't covector also at http://hackage.haskell.org/package/algebra-3.1/docs/Numeric-Covector.html#t:Covector ?
17:17:04 <jasonkuhrt> Oh, its a library in another language, not haskell
17:17:05 <orzo> Does UTCTime have a Read instance?  The docs says it does at https://hackage.haskell.org/package/time-1.4.0.1/docs/Data-Time-Clock.html#t:UTCTime
17:17:21 <orzo> But the compiler says no and i dont know whre the instance is defined
17:17:33 <edwardk> Mathnerd314: same type, different library.
17:17:50 <edwardk> Mathnerd314: linear doesn't use an alternate numerical tower like algebra does
17:17:54 <orzo> is there a way to navigate to instance sources from haddock?
17:17:59 <edwardk> just makes the best of the one we have
17:18:54 <solidus-river> phoniel: that make sense?
17:19:09 <solidus-river> phoniel: maybe your hart.cabal is being too specific
17:20:06 <phoniel> solidus-river: I've just changed the array dependency in hart.cabal and I'm trying to install --only-dependencies atm
17:20:24 <phoniel> solidus-river: I'm maintaining a cautious optimism
17:20:54 <enthropy> the --allow-newer is probably easier than adjusting the .cabal file
17:21:37 <solidus-river> phoniel: thats the spirit! i've moved from cautious optimism to cautious pessimism
17:25:55 <solidus-river> ok, i've resolved the scary issues with ghc
17:26:06 <solidus-river> but aeson-0.7.0.3 still fails with the same erorr about scientific
17:26:14 <solidus-river> http://lpaste.net/105642
17:26:33 <Mathnerd314> edwardk: ok. and I guess there's https://github.com/ekmett/linear/issues/17 which hasn't been fixed yet...
17:27:00 <phoniel> solidus-river: aeson-0.7.0.3 won't install
17:27:01 <edwardk> its more that we're not sure we want to fix it
17:27:19 <solidus-river> phoniel: for you or for me or in general
17:27:29 <edwardk> it doubles the API, carries a lot of complications, basically turns that half of the API into vector-space, etc.
17:27:44 <phoniel> solidus-river: for both of us, apparently
17:27:46 <edwardk> in exchange you get a bit more efficiency
17:27:56 <solidus-river> phoniel: heh, cool! were seeing the same break
17:28:05 <solidus-river> maybe aeson 0.7.0.3 is broken?
17:28:51 <solidus-river> phoniel: is your error regaurding Data.Scientific as well?
17:28:54 <Rotaerk_Web> In this code (http://lpaste.net/105643), I have a list of ShaderDescriptions, and I want to run buildShaderFromSource on them one at a time, but stop if any of them fail
17:29:02 <Rotaerk_Web> having trouble figuring out how to express that
17:29:09 <phoniel> [ 9 of 12] Compiling Data.Aeson.Encode ( Data/Aeson/Encode.hs, dist/build/Data/Aeson/Encode.o )
17:29:12 <phoniel> Data/Aeson/Encode.hs:37:66: Module `Data.Scientific' does not export `scientificBuilder'
17:29:23 <phoniel> Is that the problem you're having, solidus-river?
17:29:24 <Mathnerd314> edwardk: ok. I'm still reading the discussion, but it sounds like it might be easier to add more combinators to vector-space than to change linear...
17:29:31 <solidus-river> phoniel: hmm, well, we can both reproduce it then
17:29:32 <solidus-river> yeah
17:29:46 <solidus-river> phoniel: is yours due to a dependency from lens 4.2?
17:30:09 <edwardk> Mathnerd314: well, there are reasons to consider it. to support hmatrix-style data types, sparse, morton ordered dense vectors, etc.
17:30:10 <phoniel> solidus-river: how would I check that?
17:30:27 <solidus-river> phoniel: paste the output of the cabal install deps command
17:30:33 <solidus-river> er, the one you've ben running
17:30:34 <edwardk> Mathnerd314: until i can see how to do it right, i'm just not doing anything
17:31:02 <phoniel> solidus-river: the output is quite long....
17:31:02 <Mathnerd314> edwardk: so the discussion mentions 'tabulate'... what/where is that?
17:31:03 <phaskell> No symbol 'that' found anywhere.
17:31:15 <edwardk> tabulate is in representable-functors
17:31:19 <solidus-river> phoniel: which is what lpaset or pastebin is for :)
17:31:42 <edwardk> Data.Functor.Rep
17:32:37 <Mathnerd314> edwardk: yeah. I realized I should have used hayoo right after I asked that :-)
17:33:57 <solidus-river> phoniel: explicitly require aeson == 0.7.0.6
17:34:03 <solidus-river> or require aeson >= 0.7.0.6
17:34:13 <phoniel> solidus-river: http://lpaste.net/105644
17:34:30 <phoniel> In my hart.cabal package? (Where hart is the name of my project)
17:34:37 <solidus-river> phoniel: yeah
17:36:01 <Rotaerk_Web> hmm Control.Failure doesn't seem to provide a way for me to check if it's a failure without forcing it into a concrete type
17:36:44 <Rotaerk_Web> oh I see.. nm
17:37:22 <solidus-river> phoniel: let me know if that works, it resolved the problem for me
17:40:02 <phoniel> solidus-river: trying again with the new aeson >= 0.7.0.6
17:42:34 <fread2282> @src fromIntegral
17:42:34 <lambdabot> fromIntegral = fromInteger . toInteger
17:43:30 <phoniel> solidus-river: worked!
17:43:32 <benzrf> :t fromInteger
17:43:33 <lambdabot> Num a => Integer -> a
17:43:35 <benzrf> :t fromIntegral
17:43:36 <lambdabot> (Num b, Integral a) => a -> b
17:43:40 <benzrf> hmm
17:43:54 <phoniel> solidus-river: from whence did you get the idea to require aeson to be higher than 0.7.0.6?
17:45:43 <solidus-river> phoniel: for me it was being required by lens 4.2 i went to hackage and checked what requirements lens-4.2 was puting on aeson wiht was just that it was >= 0.7.*, I checked aeson's page on hackage and found that 0.7.0.6 was the latest and figured maybe it was better checked / more up to date with the current state of haskell libraries
17:46:36 <solidus-river> phoniel: 0.7.0.3 probably hasn't been built by anyone who cared to fix things since Data.Scientific changed its exports
17:47:16 <solidus-river> phoniel: or they kept it that way for compatability, but they should have added a hard requirement on Data.Scientific to it
17:47:33 <Zer000> I was in ghci and wanted did this: 'let h = repeat $ putStrLn "Hello World"' but now I don't know of any way to actually print a bunch of hello worlds, since I don't know how to execute a type IO () to actually do the action...
17:47:52 <Zer000> (so my desired result was a flood of "Hello World" in an infinite loop
17:47:53 <Zer000> )
17:49:34 <benzrf> Zer000: in ghci, if an expression is an IO action, it will execute it
17:49:36 <benzrf> otherwise, it will print it
17:49:38 <ReinH> Zer000: well, if you have a list of IO actions like:
17:49:45 <ReinH> :t repeat (undefined :: IO ())
17:49:45 <benzrf> Zer000: for example...
17:49:46 <lambdabot> [IO ()]
17:49:56 <ReinH> you also have sequence
17:49:58 <ReinH> :t sequence
17:49:59 <lambdabot> Monad m => [m a] -> m [a]
17:50:04 <benzrf> Prelude> 3
17:50:04 <benzrf> 3
17:50:04 <benzrf> Prelude> putStrLn "foo"
17:50:04 <benzrf> foo
17:50:21 <ReinH> so combining them gives you:
17:50:21 <benzrf> Zer000: notice that the latter ran the action instead of displaying it
17:50:29 <benzrf> ReinH: Zer000's issue is running an action they have
17:50:30 <ReinH> :t sequence (repeat (undefined :: IO ()))
17:50:31 <lambdabot> IO [()]
17:50:42 <ReinH> or, since you don’t care about the result, you can use sequence_
17:50:44 <benzrf> oh i see what u mean
17:50:45 <ReinH> :t sequence_ (repeat (undefined :: IO ()))
17:50:46 <lambdabot> IO ()
17:50:49 <benzrf> i misread repeat as forever
17:51:12 <ReinH> Zer000: notice that you can figure this out just from the type of sequence or sequence_
17:51:19 <ReinH> and the type of repeat someAction :)
17:51:58 <ReinH> in fact, once you figure out that you need to turn a value of type Monad m => [m a] into a value of type Monad m => m (), you can ask hoogle if there’s something that will do that for you
17:52:07 <ReinH> @hoogle Monad m => [m a] -> m ()
17:52:09 <lambdabot> Prelude sequence_ :: Monad m => [m a] -> m ()
17:52:09 <lambdabot> Control.Monad sequence_ :: Monad m => [m a] -> m ()
17:52:09 <lambdabot> Data.Foldable sequence_ :: (Foldable t, Monad m) => t (m a) -> m ()
17:52:10 <Zer000> ReinH: what's sequence?
17:52:12 <benzrf> =D
17:52:14 <ReinH> which will give you sequence_
17:52:32 <ReinH> Zer000: look it up :)
17:52:33 <benzrf> Zer000: sequence takes a list of actions and gives you 1 action resulting in the results of all of the actions in the list
17:52:36 <benzrf> that is
17:52:42 <benzrf> [m a] -> m [a]
17:53:08 <Zer000> oh. so that's like foldl >> [IO a] ?
17:53:17 <benzrf> Zer000: sequence_ is
17:53:22 <ReinH> Zer000: well, that’s a type error
17:53:23 <benzrf> Zer000: sequence keeps the results
17:53:37 <benzrf> ReinH: i assume they mean foldl1
17:54:08 <ReinH> sequence is total
17:54:13 <benzrf> tru
17:54:23 <Zer000> ok thanks guys
17:54:28 <ReinH> Zer000: what do you use as the initial value for the foldl you just wrote?
17:54:44 <Zer000> what if I just want to print the first hello world out of my infinite list of them though?
17:55:59 <ReinH> :t head (repeat (putStrLn "foo”)) — Zer000
17:56:00 <lambdabot>     lexical error in string/character literal at end of input
17:56:08 <ReinH> :t head (repeat (putStrLn "foo”)) -- Zer000
17:56:09 <lambdabot>     lexical error in string/character literal at end of input
17:56:13 * ReinH needs to turn autocorrect off :(
17:56:31 <Para_> Hey guys - is there a way to convert from a Float to a Real or something?
17:56:44 <Para_> just something that I can apply ceiling to?
17:56:51 <copumpkin> Real?
17:56:58 <ReinH> :t head (repeat (putStrLn "foo")) -- Zer000
17:56:59 <lambdabot> IO ()
17:57:05 <copumpkin> :t realToFrac
17:57:06 <lambdabot> (Real a, Fractional b) => a -> b
17:57:23 <ReinH> Zer000: but how do you fix your foldl above?
17:57:28 <Para_> I mean I have a float right now
17:57:37 <ReinH> Zer000: let's work through it
17:57:42 <ReinH> you can figure it out from the types
17:57:42 <Para_> :t ceiling
17:57:43 <lambdabot> (RealFrac a, Integral b) => a -> b
17:57:50 <Zer000> ReinH: so I started with "let h = repeat $ putStrLn "hello world"
17:57:54 <Zer000> in ghci
17:58:02 <benzrf> so whats up with MVars
17:58:09 <ReinH> > let h = repeat (pustStrLn "hello world") in head h
17:58:11 <lambdabot>  Not in scope: ‘pustStrLn’
17:58:11 <lambdabot>  Perhaps you meant one of these:
17:58:11 <lambdabot>    ‘putStrLn’ (imported from Prelude),
17:58:11 <lambdabot>    ‘BSC.putStrLn’ (imported from Data.ByteString.Char8),
17:58:11 <lambdabot>    ‘BSLC.putStrLn’ (imported from Data.ByteString.Lazy.Char8)
17:58:15 <ReinH> > let h = repeat (putStrLn "hello world") in head h
17:58:17 <lambdabot>  <IO ()>
17:58:19 <benzrf> how i get global var in IO q.q
17:58:31 <copumpkin> benzrf: you have to use unsafePerformIO
17:58:37 <copumpkin> benzrf: if you do that, mark it as noinline
17:58:41 <ReinH> benzrf: please don't ask that question :p
17:58:57 <ReinH> You probably don't *want* a global variable in IO
17:59:02 <benzrf> yea i know
17:59:09 <benzrf> but im writing a thing for 0mq w/ pipes
17:59:10 <Zer000> ReinH: so can I run some kind of foldl on the list 'h' to print out all my hello worlds? Like "foldl (>>) h" would that work was my question
17:59:15 <benzrf> and i want a global 0mq context
17:59:20 <benzrf> on the backend
17:59:30 <ReinH> Zer000: yes, but your suggestion doesn't type check so let's fix that
17:59:30 <copumpkin> ick
17:59:37 <benzrf> otherwise the user needs to do the boilerplate of acquiring and supplying one
17:59:44 <benzrf> and otherwise holding onto it
18:00:04 <ReinH> Zer000: you said ` foldl >> [IO a]', so let's try that
18:00:14 <ReinH> > foldl >> [putStrLn "hello world"]
18:00:15 <lambdabot>  Couldn't match expected type ‘[a0]’
18:00:15 <lambdabot>              with actual type ‘(b0 -> a1 -> b0) -> b0 -> [a1] -> b0’
18:00:20 <ReinH> Zer000: so let's fix that
18:00:22 <ReinH> :t foldl
18:00:23 <lambdabot> (b -> a -> b) -> b -> [a] -> b
18:00:30 <benzrf> ReinH: they just left off the parens :P
18:00:37 <ReinH> benzrf: they did not
18:00:46 <benzrf> oh?
18:00:48 <ReinH> Zer000:  you're missing the second argument, the `b' that serves as the initial value for the fold
18:00:50 <ReinH> compare:
18:00:56 <ReinH> > foldl (+) 0 [1,2,3]
18:00:57 <lambdabot>  6
18:00:58 <zwer> no accumulator's initial value either
18:01:07 <Zer000> ReinH: ah! right that missing default argument is where I got confused
18:01:12 <ReinH> Zer000: so let's work through that
18:01:25 <ReinH> so you are folding using (>>), right?
18:01:31 <Zer000> yes
18:01:39 <ReinH> let's plug the type of (>>) into foldl and figure out what we need for the initial value
18:01:42 <ReinH> :t (>>)
18:01:43 <lambdabot> Monad m => m a -> m b -> m b
18:01:52 <Zer000> can we use "return ()" to get IO ()?
18:01:56 <ReinH> Zer000: yes :)
18:01:56 <Zer000> and just have that as the defualt?
18:02:04 <ReinH> Zer000: but let's work through why
18:02:08 <Para_> @hoogle float
18:02:10 <lambdabot> Text.PrettyPrint.HughesPJ float :: Float -> Doc
18:02:10 <lambdabot> Text.PrettyPrint float :: Float -> Doc
18:02:10 <lambdabot> Language.Haskell.TH.PprLib float :: Float -> Doc
18:02:18 <ReinH> Zer000: so (>>) needs to unify with b -> a -> b
18:02:24 <bergmark> "Could not match expected type NotInferedU with Unit"
18:02:31 <bergmark> woops
18:02:33 <ReinH> Zer000: what type must this application of (>>) be then?
18:02:57 <Zer000> IO () -> IO()?
18:03:09 <Zer000> maybe i misunderstood the question
18:03:13 <ReinH> Zer000: what's the most general type?
18:03:23 <ReinH> (>>) is Monad m => m a -> m b -> m b
18:03:28 <ReinH> but the folding function must be b -> a -> b
18:03:33 <ReinH> so "solve for" a and b
18:03:44 <ReinH> m a -> m b -> m b <=> b -> a -> b
18:04:01 <ReinH> the only way that can happen is if m b ~ m a, so you get m a => m a => m a
18:04:01 <benzrf> just flip it eh
18:04:14 <benzrf> :t flip (>>)
18:04:15 <lambdabot> Monad m => m b -> m a -> m b
18:04:19 <benzrf> ^.^
18:04:29 <ReinH> right, but we aren't using it flipped
18:04:35 <ReinH> and flipping it would have rather different behavior
18:04:48 <benzrf> oh right
18:04:50 <benzrf> haha
18:04:59 <benzrf> how about (<*) then
18:05:04 <Zer000> ReinH: hang on so foldl only works on a function (a -> b -> a) and this is NOT the same as a function (IO a -> IO b -> IO a)?
18:05:33 <benzrf> Zer000: flipping (>>) would make it run in reverse order
18:05:35 <ReinH> Zer000: foldl works with a function b -> a -> b, but these are type variables
18:05:53 <ReinH> Zer000: but notice that (>>) is m a -> m b -> m b, not m a -> m b -> m a
18:06:04 <ReinH> this implies that a ~ b
18:06:12 <ReinH> since you have m b in the same position as both a and b
18:06:18 <Zer000> a is related to be? is that how you read a ~ b?
18:06:34 <ReinH> a is equivalent to b, a unifies with b
18:06:43 <ReinH> basically a and b are the same
18:06:58 <ReinH> but we also know that we want the result to be IO (), right? Or at least m () for some monad m
18:07:03 <ReinH> since we want to throw away the results
18:07:14 <ReinH> :t foldl
18:07:15 <lambdabot> (b -> a -> b) -> b -> [a] -> b
18:07:24 <ReinH> this means that b ~ Monad m => m ()
18:07:47 <Zer000> yeah but since our whole list is of type IO () then >> will result in a type IO (), why doesn't foldl like that?
18:07:52 <ReinH> which means that our folding function actually needs to have type Monad m => m () -> m () -> m (), and also means that our initial value has to be of type Monad m => m ()
18:08:05 <ReinH> Zer000: and there's only one way to construct a value Monad m => m ()
18:08:13 <ReinH> and that's return ()
18:08:21 <ReinH> so the initial value *has to be* `return ()'
18:08:24 <ReinH> (or undefined)
18:08:38 <ReinH> (there are actually two ways to construct such a value, and one of them is undefined)
18:09:00 <ReinH> (or any bottom)
18:09:01 <benzrf> why cant i just have a static global var initialized with IO ;=;
18:09:13 <ReinH> benzrf: you can, you probably just don't want one
18:09:23 <benzrf> ReinH: what else do you recommend then
18:09:24 <ReinH> benzrf: what's the difference between that and constructing a value inside main?
18:09:37 <benzrf> ReinH: it's used behind the scenes for the api i intend to make
18:09:41 <benzrf> 0mq pipes
18:09:53 <benzrf> 0mq socket constructors take a 'context' value
18:10:03 <benzrf> i wanted to make a global context and then auto use that
18:10:06 <ReinH> Zer000: anyway the point of that was that you can use algebraic reasoning about the types to prove that the initial value has to be `return ()' (or bottom) :)
18:10:11 <benzrf> to prevent having to manually create and pass one around
18:10:18 <ReinH> not even algebraic, just equational reasoning
18:10:18 <benzrf> you rarely want more than one context in 0mq
18:10:30 <ReinH> benzrf: just let the consumer construct the context in main
18:10:52 <benzrf> what if you make multiple pipes with sockets though
18:10:56 <ReinH> the only thing worse than using magic unsafePerformIO global values is forcing your consumers to use one without realizing it :p
18:11:17 <Zer000> ReinH: thank you for that explanation
18:11:22 <benzrf> b-but it adds annoying boilerplate
18:11:23 <benzrf> q.q
18:11:32 <ReinH> benzrf: oh noes.
18:11:45 <benzrf> boilerplate is 4 lusers
18:12:39 <ReinH> benzrf: it's almost as if we have developed various abstractions for dealing with such boilerplate in a principled way
18:12:47 <Zer000> err this may be silly by why do the folding functions even need a starting value, why can't they just take the first two?
18:12:54 <benzrf> fie
18:12:55 <ReinH> Zer000: what do they do on the empty list?
18:13:01 <benzrf> Zer000: there are versions that take first 2
18:13:08 <benzrf> :t foldl1
18:13:09 <lambdabot> (a -> a -> a) -> [a] -> a
18:13:16 <Zer000> oh
18:13:23 <benzrf> Zer000: but they are partial functions so watch out!
18:13:33 <ReinH> Zer000: foldl1, which works on non-empty lists, just uses the first element as the initial value for foldl ;0
18:13:36 <ReinH> @src foldl1
18:13:36 <lambdabot> foldl1 f (x:xs) = foldl f x xs
18:13:36 <lambdabot> foldl1 _ []     = undefined
18:13:55 <benzrf> Zer000: also, they only work with accumulators of the same type as the list items
18:13:57 <Zer000> the heck is undefined?
18:14:06 <benzrf> Zer000: look:
18:14:20 <ReinH> Zer000: http://www.haskell.org/haskellwiki/Bottom
18:14:24 <benzrf> > foldl ((++) . show) "" [1, 2, 3, 4]
18:14:26 <lambdabot>  No instance for (GHC.Num.Num [GHC.Types.Char])
18:14:26 <lambdabot>    arising from the literal ‘1’
18:14:32 <benzrf> hmmmm??
18:14:46 <ReinH> :t (++) . show
18:14:47 <lambdabot> Show a => a -> [Char] -> [Char]
18:14:52 <benzrf> oic
18:14:57 <benzrf> > foldr ((++) . show) "" [1, 2, 3, 4]
18:14:58 <lambdabot>  "1234"
18:15:08 <benzrf> Zer000: you cannot do that ^ with foldl1
18:15:10 <benzrf> *foldr1
18:16:28 <Para_> two quick questions:
18:16:34 <benzrf> Para_: supki
18:16:35 <benzrf> *sup
18:16:42 <ReinH> benzrf: sure you can :p
18:16:46 <ReinH> > show $ foldl1 (\x y -> 10 * x + y) [1,2,3,4]
18:16:47 <lambdabot>  "1234"
18:16:48 <Para_> whats considered better practice if you need to append something to a list: reverse, prepend, reverse
18:16:50 <Para_> or append?
18:16:55 <Para_> via ++
18:17:07 <ReinH> Para_: if you are doing this a lot, you shouldn't use a list
18:17:07 <Para_> (because I'd heard that you generally don't want to do ++, but I'm not sure if that's true)
18:17:13 <ReinH> something like Data.Sequence would be better
18:17:15 <argiopetech> ReinH++
18:17:30 <Para_> alright
18:17:33 <Para_> and question 2
18:17:34 <ReinH> Para_: but, if you can do a bunch of prepends then reverse at the end, that can be ok
18:17:46 <Para_> okay :)
18:17:56 <Para_> question 2: Suppose I want to create a list that has elements with a certain property
18:18:03 <gspr> I have a bunch of numeric data in many relatively big (~50 MB) files. In a pure computation I will need on the order of 1% of the data from a few of these files. Is there a good way to attack this problem without loading the files into memory or coupling my computation to IO? So far I can only think of mmap...
18:18:05 <solidus-river> how do you search through a package for a function using hackage
18:18:05 <Para_> and have a function return the first element, it is exists
18:18:08 <argiopetech> There are always difference lists too.
18:18:08 <Para_> or something else if it doesn't
18:18:27 <Para_> is there an error-catching thing with head
18:18:37 <ReinH> Para_: there is a safe version of head that returns a Maybe
18:18:38 <gaze__> if I'm writing a serious thing that requires that I represent trees of arithmetic operations, what's the preferred way to do it? Tagless final interpreters seem pretty popular these days.
18:18:38 <Para_> or should I try to use context matching with guards or something else?
18:18:58 <ReinH> you can then use fromMaybe if you want to replace the Nothing with some default value
18:19:08 <ReinH> or `maybe' if you want to do something a bit more complicated
18:19:22 <Para_> :t fromMaybe
18:19:23 <lambdabot> a -> Maybe a -> a
18:19:24 <ReinH> @hoogle [a] -> Maybe a
18:19:27 <lambdabot> Data.Maybe listToMaybe :: [a] -> Maybe a
18:19:27 <lambdabot> Data.List find :: (a -> Bool) -> [a] -> Maybe a
18:19:27 <lambdabot> Prelude head :: [a] -> a
18:19:44 <ReinH> @hackage safe
18:19:44 <lambdabot> http://hackage.haskell.org/package/safe
18:19:46 <Para_> would you say that's better than context matching?
18:20:09 <Para_> @hoogle Float -> Real
18:20:09 <lambdabot> Warning: Unknown type Real
18:20:09 <lambdabot> Unsafe.Coerce unsafeCoerce :: a -> b
18:20:09 <lambdabot> Control.OldException throwDyn :: Typeable exception => exception -> b
18:20:16 <Para_> @hoogle Float -> RealFrac
18:20:17 <lambdabot> Warning: Unknown type RealFrac
18:20:17 <lambdabot> Unsafe.Coerce unsafeCoerce :: a -> b
18:20:17 <lambdabot> Control.OldException throwDyn :: Typeable exception => exception -> b
18:20:26 <ReinH> Para_: type classes are not types
18:20:43 <ReinH> @hoogle (Float a, Real b) => a -> b
18:20:44 <lambdabot> Warning: Unknown class Float
18:20:44 <lambdabot> Unsafe.Coerce unsafeCoerce :: a -> b
18:20:44 <lambdabot> Prelude ($) :: (a -> b) -> a -> b
18:20:49 <ReinH> oh, Float is, duh
18:20:52 <Para_> ohhhh
18:20:57 <ReinH> @hoogle Real b => Float -> b
18:20:58 <lambdabot> Unsafe.Coerce unsafeCoerce :: a -> b
18:20:58 <lambdabot> Prelude id :: a -> a
18:20:58 <lambdabot> Data.Function id :: a -> a
18:21:06 <Para_> wait
18:21:09 <Para_> yeah
18:21:18 <Para_> :t id
18:21:19 <lambdabot> a -> a
18:21:24 <Para_> id 5
18:21:30 <Para_> >id 5
18:21:47 <Para_> why is id a useful function?
18:21:58 <benzrf> Para_: in conjunction with other higher order functions
18:22:01 <Para_> doesn't it just return the argument you pass to it?
18:22:01 <haasn> Para_: Because it can be passed to other functions
18:22:02 <ReinH> It's useful in higher... yes
18:22:10 <haasn> For example:
18:22:13 <haasn> :t foldr (.) id
18:22:14 <lambdabot> [b -> b] -> b -> b
18:22:42 <Para_> what would foldr (.) id do?
18:22:47 <Para_> just compose functions?
18:22:48 <ReinH> (the endomorphism monoid, a.k.a. Endo)
18:22:54 <haasn> :t foldr (.) id [f,g,h] x
18:22:55 <lambdabot> Expr
18:22:57 <haasn> > foldr (.) id [f,g,h] x
18:22:58 <lambdabot>  f (g (h x))
18:23:05 <solidus-river> why isnt hsSDL2 on hackage
18:23:07 <solidus-river> hmm
18:23:08 <Para_> got it
18:23:12 <solidus-river> i don't know how to judge which to uses
18:23:12 <Para_> okay thanks
18:23:14 <solidus-river> *use
18:23:16 <ReinH> > foldr (.) id [(+1),(*2)] $ 1
18:23:18 <lambdabot>  3
18:23:22 <solidus-river> theres hsSDL2 on github and then SDL2 on hackage
18:23:35 <solidus-river> anyone used either of these / have an opinion?
18:23:45 <zwer> > foldr (.) id [(+1),(*2)] 1
18:23:47 <lambdabot>  3
18:23:53 <haasn> :t foldr id
18:23:54 <ReinH> > foldr (.) id [tail, map toUpper] $ "hello"
18:23:54 <lambdabot> b -> [b -> b] -> b
18:23:55 <lambdabot>  "ELLO"
18:24:24 <haasn> > foldr id x [f,g,h]
18:24:25 <lambdabot>  f (g (h x))
18:24:28 <haasn> cute
18:24:39 <ReinH> Para_: sometimes you want to control the behavior of another function by passing it a function. `id' is a convenient "do nothing" or "leave unchanged" behavior.
18:24:44 <haasn> foldr (.) id = flip (foldr id) ?
18:24:58 <Lutin`> ReinH: Isn't that a useless use of $
18:25:01 <Para_> :t foldr
18:25:02 <lambdabot> (a -> b -> b) -> b -> [a] -> b
18:25:03 <ReinH> Lutin`: looks like it
18:25:19 <ReinH> Lutin`: force of habit I guess :(
18:25:26 <Lutin`> np I do it too
18:25:28 <haasn> Para_: ($) is actually another example of id, but with a different type signature
18:25:34 <Para_> :t $
18:25:35 <lambdabot>     parse error on input ‘$’
18:25:35 <lambdabot>     Perhaps you intended to use TemplateHaskell
18:25:38 <ReinH> :t ($)
18:25:38 <haasn> :t ($)
18:25:39 <lambdabot> (a -> b) -> a -> b
18:25:39 <lambdabot> (a -> b) -> a -> b
18:25:40 <Lutin`> :t ($)
18:25:41 <lambdabot> (a -> b) -> a -> b
18:25:43 <Lutin`> lol
18:25:47 <ReinH> heh
18:25:47 <Para_> haha nice guys
18:25:57 <Para_> hm
18:26:00 <Para_> okay
18:26:05 <haasn> ($) can be useful because of its low precedence, you can use it to group things differently easily
18:26:06 <ReinH> its main advantage over `id` is its lower precedence
18:26:18 <haasn> Maybe I should just let ReinH do the talking and go eat :p
18:26:23 <Para_> :P
18:26:30 <ReinH> (and the fact that `id` is a weird way to write function application)
18:26:31 <Lutin`> > f $ g $ h x
18:26:33 <lambdabot>  Could not deduce (GHC.Show.Show s0)
18:26:33 <lambdabot>    arising from a use of ‘Debug.SimpleReflect.Vars.f’
18:26:33 <lambdabot>  from the context (Debug.SimpleReflect.Expr.FromExpr t)
18:26:33 <lambdabot>    bound by the inferred type of
18:26:33 <lambdabot>             it :: Debug.SimpleReflect.Expr.FromExpr t => t
18:26:41 <Lutin`> what am I doing
18:26:47 <haasn> Lutin`: (f g) (h x)
18:26:49 <ReinH> Lutin`: I have no idea
18:27:02 <knappador> cabal --allow-newer worked (had some minor, minor version increments outside bounds).  Now, how do I put this in my package cabal?  Guess I don't because then I would allow it inside a hackage package potentially?
18:27:11 <solidus-river> maybe life would be happier if i used glfw instead
18:27:16 <ReinH> > succ $ 1
18:27:18 <lambdabot>  2
18:27:19 <ReinH> > succ `id` 1
18:27:21 <lambdabot>  2
18:27:29 * hackagebot SVGPath 1.1.2 - Parsing the path command of SVG  http://hackage.haskell.org/package/SVGPath-1.1.2 (RohanDrape)
18:27:31 <ReinH> `id` is a weird way to write function application. ;)
18:27:58 <Lutin`> (id succ 1)
18:28:04 <Lutin`> LISP TIME
18:28:20 <Lutin`> jesus I'm loopy
18:28:27 <Lutin`> :x
18:28:36 <benzrf> @hoogle ByteString -> String
18:28:36 <lambdabot> Data.ByteString.Char8 unpack :: ByteString -> [Char]
18:28:37 <lambdabot> Data.ByteString.Lazy.Char8 unpack :: ByteString -> [Char]
18:28:37 <lambdabot> Data.ByteString.Char8 head :: ByteString -> Char
18:32:30 * hackagebot wai-app-file-cgi 3.0.0 - File/CGI/Rev Proxy App of WAI  http://hackage.haskell.org/package/wai-app-file-cgi-3.0.0 (KazuYamamoto)
18:32:32 * hackagebot mighttpd2 3.1.0 - High performance web server on WAI/warp  http://hackage.haskell.org/package/mighttpd2-3.1.0 (KazuYamamoto)
18:38:09 <aspidites1> anyone on gentoo here? i've enabled the haskell overlay but am having trouble getting ghc 7.8
18:38:46 <aspidites1> i followed this -> https://github.com/gentoo-haskell/gentoo-haskell/blob/master/README.rst but i'm still unable to see the masked versions
18:38:46 <argiopetech> aspidites: I am, but I install from source.
18:39:10 <aspidites1> argiopetech: ah. hmm :\
18:39:56 <argiopetech> aspidites1: Only because I haven't used it. I get more consistent results with source, cabal-install, and some custom scripts.
18:40:55 <aspidites1> i figured i'd do as i did in arch and only track ghc and cabal-install through the distro, using cabal for everything else
18:41:27 <aspidites1> that may be naiive thouch, cosidering i've only been on gentoo for 3 days
18:42:32 <argiopetech> ghc-7.6.3-r1 is the latest in the main repos. I generally don't use overlays, so...
18:42:39 <argiopetech> I think the main repo is okay.
18:42:50 <argiopetech> (generally)
18:43:25 <enthropy> if I have a CPP macro that expands out to (708 > 707) is there some way to put that in a string literal?
18:43:59 <argiopetech> enthropy: Have it expand to "(708 > 707)", you mean?
18:44:09 <enthropy> yeah
18:44:32 <argiopetech> #define THING \"(708 > 707)\" doesn't work?
18:44:52 <argiopetech> (I can't remember how CPP handles quotations either...)
18:44:58 <enthropy> yeah that'd work, except I have  #define THING (__GLASGOW_HASKELL__ > 707)
18:45:07 <Hafydd> enthropy: https://gcc.gnu.org/onlinedocs/cpp/Stringification.html#Stringification
18:46:30 <argiopetech> Ah... That's a bit more sticky.
18:46:38 <Hafydd> TWSS
18:46:45 <argiopetech> Multi-pass macro expansion.
18:47:32 <benzrf> Guest____: FIX YOUR CONNECTION
18:47:40 <argiopetech> Actually, that's single pass. Should work with the stringification link above.
18:48:47 <chewnoxbranca> erlang
18:48:50 <chewnoxbranca> bah
18:48:54 <Hafydd> The benefits of RTFM are amazing.
18:51:03 <zq-_-_-_> hm
18:51:27 <zq-_-_-_> > data M :: * where { m :: Bool -> M; }
18:51:29 <lambdabot>  <hint>:1:1: parse error on input ‘data’
18:51:38 --- mode: ChanServ set +o copumpkin
18:51:47 <zq-_-_-_> > {-# LANGUAGE GADTs, KindSignatures #-} data M :: * where { m :: Bool -> M; }
18:51:49 <lambdabot>  <hint>:1:40: parse error on input ‘data’
18:51:55 <benzrf> @let data M :: * where { m :: Bool -> M; }
18:51:55 <lambdabot>  Parse failed: Parse error: m
18:51:58 <benzrf> hmm
18:52:04 <zq-_-_-_> lambdabot: why are you being such a hardass
18:52:06 <benzrf> @let data M :: * where m :: Bool -> M
18:52:06 <lambdabot>  Parse failed: Parse error: m
18:52:39 <aspidites1> coming from arch, main repos seem to lag behind
18:52:45 <aspidites1> for instance, firefox 24...
18:52:55 --- mode: copumpkin set +b G*!~textual@c-98-210-157-141.hsd1.ca.comcast.net$##fix_your_connection
18:53:10 <aspidites1> which is why i've started using overlays, and for firefox i got to 30, but i still don't understand why its not giving me access to ghc 7.
18:53:16 <aspidites1> 7.8*
18:53:32 <zq-_-_-_> i feel like i'm missing very obvious
18:54:35 <bgamari> What is * in a heap profile?
18:57:05 <enthropy> Hafydd: looks like ghc runs cpp with that stuff disabled
18:58:03 <triliyn> zq-_-_-_: data constructors must begin with a capital letter
18:58:14 <zq-_-_-_> triliyn: yeah, too much idris
18:58:16 <triliyn> @ let data M :: * where {M :: Bool -> M; }
18:58:20 <enthropy> http://lpaste.net/105648
18:58:27 <triliyn> whoops, I added a space
18:59:11 <gaze__> is there a way to do open types in haskell?
18:59:33 <c_wraith> gaze__: sort of.  data families are sort of open types.
18:59:40 <benzrf> whats the point of the kind signature therealklanni
18:59:43 <benzrf> *there
18:59:47 <gaze__> hmmm... okay
18:59:56 <c_wraith> gaze__: though really, knowing what you want to do would make it easier to provide advice.
19:02:58 <Lutin`> I don't understand why you'd leave Arch for Gentoo :[
19:06:03 <therealklanni> wat?
19:09:16 <cschneid> Does anybody use the `cassy` package for cassandra access?  I can't figure out how to use it to get a full listing of a keyspace (select * from table equivalent).
19:09:31 <cschneid> I know that's not normal cassandra usage, but we have a small bit of data that I just want all of.
19:10:54 <cschneid> I want to use: http://hackage.haskell.org/package/cassy-0.6/docs/Database-Cassandra-Basic.html#v:getMulti -- but I can't figure out what could go in the KeySelector argument
19:12:27 <haasn> aspidites: For mixing Gentoo and Haskell I'd personally recommend adding the haskell overlay (see also #Gentoo-Haskell for support) and using portage for everything; it comes with GHC 7.8 among all other versions you'd ever need
19:12:34 * hackagebot ghc-mod 4.1.3 - Happy Haskell Programming  http://hackage.haskell.org/package/ghc-mod-4.1.3 (KazuYamamoto)
19:12:39 <haasn> I don't use cabal-install at all, I consider it harmful
19:12:48 <genericpersona> damn, so true
19:12:56 <genericpersona> i've had dependency hell with cabal before
19:13:09 <genericpersona> but it feels like cabal's gotten better
19:14:41 <haasn> zq-_-_-_: You also can't define things in @run (which is what the > prefix is an alias for); it's not like GHCi at all - it only evaluates Haskell expressions
19:22:54 <juanpablo_> Am I right in thinking that in relation to category theory fmap is a functor, but members of the typeclasses themselves aren't?
19:23:20 <shachaf> There are lots of ways to define functors.
19:23:41 <shachaf> In the most popular one, you might say that e.g. (Maybe, fmap :: (a -> b) -> Maybe a -> Maybe b) is a functor.
19:24:58 <copumpkin> you could say that Maybe is the functor and fmap is the proof that it is
19:25:03 --- mode: copumpkin set -o copumpkin
19:25:04 <gaze__> hey guys. What's the favorite way these days to represent a typed expression tree?
19:25:28 <gaze__> seems like tagless final interpreters are pretty popular these days
19:26:14 <juanpablo_> But the type members of the typeclasses aren't functors, right?
19:26:18 <juanpablo_> fmap itself is a functor
19:26:31 <shachaf> You could say that (fmap :: (a -> b) -> Maybe a -> Maybe b) is a functor, but that would be an unusual definition.
19:26:46 <shachaf> In the style of http://ncatlab.org/nlab/show/single-sorted+definition+of+a+category
19:27:54 <juanpablo_> Ok, now I'm confused. I have been thinking of typeclasses as the objects in the category of typeclasses
19:27:57 <juanpablo_> Am I right?
19:28:15 <ReinH> juanpablo_: what is the category of type classes?
19:28:40 <PhineasRex> juanpablo_: What would the arrows be in that category?
19:28:52 <juanpablo_> functors? I'm kind of confused
19:29:20 <rwbarton> let's start over
19:29:31 <juanpablo_> I'd certainly appreciate that
19:29:44 <rwbarton> the category people are talking about when they talk about category theory and Haskell is the following:
19:30:06 <rwbarton> its objects are types. like, ordinary types that have values. (not type constructors like Either)
19:30:46 <rwbarton> a morphism from an object A to an object B is, well, A and B are types and it's a function A -> B
19:31:19 <juanpablo_> So morphisms in Haskell are just functions?
19:31:21 <sgronblo> morphismal programming
19:31:37 <ReinH> juanpablo_: morphisms in the category just described are functions, yes
19:32:01 <ReinH> (it's also common to ignore bottoms when dealing with this category)
19:32:09 <sgronblo> but there exists some categories where morphisms are not functions?
19:32:13 <juanpablo_> But it seems that fmap can be seen as a functor, since it follows the axioms of a functor in cateogry theory
19:32:18 <ReinH> sgronblo: yes
19:32:25 <juanpablo_> Morphism are more general than functions
19:32:29 <rwbarton> this category is often called Hask, to be specific, but also if you see a word like "functor" or "monad" without other context, assume it means on Hask
19:32:33 <ReinH> sgronblo: category theory is, in fact, an algebra of such abstract functions.
19:32:45 <sgronblo> so its not just about being a math hipster :)
19:32:58 <benzrf> fuck u prophile
19:32:59 <ReinH> sgronblo: it is also probably about that for some people ;)
19:32:59 <benzrf> i lost the game
19:33:06 <coppro> I lost the game :(
19:33:08 <ReinH> benzrf: hahaha aaaand so did I
19:33:10 <juanpablo_> So fmap is a functor? I mean it must follow the definition of functor from category theory
19:33:10 <akater> “a morphism from an object A to an object B is, well, A and B are types and it's a function A -> B” — any function that can be represented by Haskell definitions? Or is it irrelevent?
19:33:18 <ReinH> juanpablo_: so what is a functor in category theory?
19:33:27 <rwbarton> ok, let's go through the definition, yes
19:34:12 <coppro> akater: In the category Hask, the morphisms *are* the functions, by definition. They're just different names for the same thing
19:34:48 <juanpablo_> A functor
19:34:48 <juanpablo_> A functor "maps" objects and morphisms from a category into another category
19:34:59 <ReinH> we've implied it, but the identity morphism is `id' and composition is (.)
19:35:04 <benzrf> juanpablo_: ok, so what are the objects and morphisms in Hask?
19:35:14 <coppro> sgronblo: category theory is all about being a math hipster. And also proving things without knowing anything about the field you're proving them in
19:35:21 <benzrf> juanpablo_: note that Functor is only for endofunctors (functors from a category to itself)
19:36:25 <ReinH> if objects are types and morphisms are functions then a functor in Hask must map types onto some other object and functions onto some other morphism in another category
19:36:36 <sgronblo> i was wondering recently, why the name return was given to the return function in monad? couldnt the haskell creators figure out that this was going to confuse "normal" programmers for decades to come?
19:37:02 <ReinH> But since we just want to deal with types and functions, we want an *endofunctor* that maps back onto the same category
19:37:04 <joelteon> excellent question, sgronblo
19:37:20 <juanpablo_> Yes, and then fmap maps the morphisms from one typeclass into the morphisms of another typeclass
19:37:20 <juanpablo_> so fmap appears to be a functor
19:37:20 <juanpablo_> But I'm not sure that's the case
19:37:20 <juanpablo_> ok so Functor is actually Endofunctor?
19:37:52 <ReinH> juanpablo_: so an endofunctor on Hask needs to map types to types and functions to functions
19:37:58 <ReinH> in a way that preserves identities and composition
19:38:11 <juanpablo_> And the endofunctor itself is fmap?
19:38:12 <ReinH> juanpablo_: the type mappings are type constructors
19:38:20 <ReinH> the function mapping is fmap
19:38:43 <ReinH> specifically, the type mappings are types of kind * -> * that are instances of Functor
19:38:58 <juanpablo_> fmap is the function that maps types to other types while preserving id and .
19:39:01 <juanpablo_> I mean, it seems more accurate to say that fmap is a functor, not the typeclass
19:39:04 <ReinH> and the function mapping is the instance of fmap for that type
19:39:21 <ReinH> juanpablo_: the typeclass is not a functor
19:39:30 <ReinH> instances of the typeclass are functors
19:39:34 <rwbarton> akater: are you asking for example, are the functions from Integer to Integer ALL the functions from the integers to the integers, or only the ones we can actually implement in Haskell?
19:39:45 <pavonia> gaze__: I'm not sure if I get all the terms right, but the preferred way are fixpoint data types (μ types) with cata- and anamorphisms in my expression
19:40:05 <akater> coppro: I get it but definition of this kind is only useful when you already have an idea of what Hask is. :-) You can't say “Grp is a category of groups”, and expect it to be self-explanatory: groups should probably be defined first, with definition of group morphism following naturally from the definition of group. So, I just expect Haskell functions to be defined in a similar manner. And since there is an obvious fact that any Haskell function is 
19:40:05 <akater> lang, I expect a certain equivalnce to arise somewhere.
19:40:13 <ReinH> for instance we have the type constructor Maybe which sends a type `a' to `Maybe a', and its definition of fmap
19:40:17 <benzrf> juanpablo_: what maps objects to objects?
19:40:25 <juanpablo_> Wouldn't fmap from the typeclass be a functor, and not instances of the typeclass?
19:40:26 <benzrf> in a Functor instance, i mean
19:40:33 <benzrf> juanpablo_: a functor has 2 parts
19:40:35 <akater> rwbarton: something like that; see my last message
19:40:42 <benzrf> objects -> objects and morphisms -> morphisms
19:40:46 <ReinH> juanpablo_: fmap only maps functions to functions
19:40:48 <benzrf> fmap sends morphisms to morphism
19:40:49 <benzrf> s
19:40:55 <ReinH> a functor must also map objects to objects
19:40:57 <benzrf> but you need something that sends objects to objects too
19:40:58 <rwbarton> akater: you got cut off after "any Haskell function is" and before "lang, "
19:41:21 <juanpablo_> so what sends objetcts to objects in Haskell functors?
19:41:25 <ReinH> juanpablo_: the type constructors
19:41:29 <ReinH> of kind * -> *
19:41:32 <ReinH> that are instances of Functor
19:41:37 <benzrf> juanpablo_: in Hask, the objects are types
19:41:44 <ReinH> they send types to types
19:41:45 <akater> rwbarton: “any Haskell function is some expression in Haskell lang, so I expect an equivalnce between expressions and morphosms to appear somewhere”
19:41:46 <Rotaerk_Web> is it common/standard to use Control.Failure?  the fact that it doesn't let me test for success/failure is making me reconsider just using Either
19:41:46 <benzrf> therefore, types -> types are type constructors
19:42:02 <benzrf> >the fact that it doesn't let me test for  success/failure
19:42:04 <benzrf> whut?
19:42:15 <serjeem> I'm brainfarting, is there any way (besides type classes) to write the uniqueNames function in this gist: http://goo.gl/pEOcFN ? I'm trying to uniquely rename all the variables in a Language.C function using Uniplate
19:42:33 <Rotaerk_Web> benzrf, it doesn't have something that lets me test for failure, as far as I can tell; at least not without forcing it to a concrete type like Maybe
19:42:43 <rwbarton> akater: ok. so for one thing, we need equality between functions to be extensional: f = g if for every x, f x = g x
19:42:50 <benzrf> Rotaerk_Web: huh???
19:43:01 <Rotaerk_Web> are you saying I'm wrong?
19:43:01 <benzrf> i dont know what any of that means x.x
19:43:05 <Welkin> Rotaerk_Web, is that not what Maybe is for?
19:43:25 <rwbarton> akater: because we need composition to be associative: (f . g) . h = f . (g . h)
19:43:29 <juanpablo_> so the data declaration, together with fmap are the functor?
19:43:33 <serjeem> Language.C has a bunch of mutually recursive datatypes, where there CDeclr is a declarator type and CVar is an expression type
19:43:41 <benzrf> juanpablo_: the type constructor, to be precise
19:43:55 <rwbarton> akater: so morphisms aren't simply Haskell expressions
19:44:00 <ReinH> juanpablo_: the type constructor together with the implementation of fmap (and the assumption that it satisfies the functor laws)
19:44:16 <benzrf> juanpablo_: next up: natural transformations!!!
19:44:22 <juanpablo_> ah okay. that makes more sense.
19:44:24 <benzrf> :^D
19:44:32 <Rotaerk_Web> Welkin: Maybe is one way of expressing failure, sure; Control.Failure is a typeclass implemented by Maybe and other things
19:44:35 <juanpablo_> Natural transformations still bends my brain haha
19:44:36 <ReinH> juanpablo_: so for instance Functor Maybe where fmap _ Nothing = Nothing; fmap f (Just x) = Just (f x), Maybe is the object mapping and fmap is the arrow mapping
19:44:37 <akater> rwbarton: Thank you. I better think about this on my own now. :-)
19:44:52 <Rotaerk_Web> so the "huh?"s are making me think Control.Failure is *not* common
19:45:27 <Rotaerk_Web> benzrf: what exactly didn't make sense about what I was saying?
19:46:05 <Welkin> what is the best source for an introduction to category theory and lambda calculus?
19:46:26 <ReinH> Welkin: How much abstract algebra have you done?
19:46:29 <Welkin> a book or a series of article
19:46:40 <Welkin> abstract algebra?
19:46:43 <benzrf> Rotaerk_Web: i just didnt understand what you meant
19:46:48 <Rotaerk_Web> Control.Failure is a Monad, so you can build a success with "return", and it adds a method "failure" for building a failure; but it doesn't offer something for checking whether a given abstract value is a failure/success
19:46:49 <juanpablo_> My end goal is understanding Yoneda's Lemma proof
19:46:54 <ReinH> Welkin: I'd recommend Awodey's _Category Theory_
19:47:04 <benzrf> ooooooooooh i see
19:47:12 <benzrf> i thought you were talking about Either when you said:
19:47:12 <Welkin> I haven't done really any abstract math, just engineering level diff eq/linear algebra stuff
19:47:18 <benzrf> 10:40 < Rotaerk_Web> benzrf, it doesn't have something that lets me test for failure, as far as I can tell; at  least not without forcing it to a concrete type like Maybe
19:47:24 <benzrf> Rotaerk_Web: which confused me greatly
19:47:29 <ReinH> Welkin: and Lawvere's _Conceptual Mathematics_
19:47:48 <Rotaerk_Web> oh, no; I'm tempted to switch from Failure to Either simply because it gives me a way to test for this
19:47:56 <benzrf> why use failure?
19:48:22 <Rotaerk_Web> the reason for using it is that the caller can decide how the failure is reported, i.e. as a list, a Maybe, an Either, an exception
19:48:52 <Rotaerk_Web> it's also kind of more clear, intention-wise, than Either
19:49:03 <Rotaerk_Web> and actually, I think I know what I'll do...
19:49:17 <benzrf> Rotaerk_Web: ah, i see
19:49:35 <ReinH> Welkin: Actually, Awodey's Algebra is a surprisingly good introduction to category theory by way of the rest of abstract algebra ;)
19:49:39 <ReinH> er
19:49:41 <ReinH> Mac Lane's Algebra
19:49:42 <ReinH> sorry
19:49:42 <benzrf> Rotaerk_Web: your usage of 'reconsider' misled me
19:50:02 <ReinH> Welkin: This has the added benefit of teaching you abstract algebra
19:50:04 <juanpablo_> I understand natural transformations are the morphisms in Cat, but I have no intuition on it whatsoever
19:50:04 <juanpablo_> so I'm kind of stuck and #haskell might be offtopic for that :)
19:50:05 <benzrf> 'reconsider using Either' made me think you were using Either
19:50:05 <Rotaerk_Web> I should've said "reconsider using Failure, and instead use Either"
19:50:14 <benzrf> juanpablo_: i didnt know that part!
19:50:15 <Welkin> ReinH, so, three books?
19:50:22 <benzrf> i would have assumed that functors are
19:50:26 <ReinH> Welkin: I've got more if 3 isn't enough ;)
19:50:30 <benzrf> juanpablo_: as i understand it
19:50:43 <ReinH> Welkin: Conceptual Mathematics is a pretty gentle introduction to CT
19:50:55 <juanpablo_> Don't trust me that much haha my understanding of NT is terrible haha
19:50:58 <benzrf> juanpablo_: given categories C and D and functors F : C -> D and G : C -> D
19:51:09 <Welkin> thank you for the suggestions
19:51:14 <ReinH> Awodey's is a pretty standard text but assumes a bit more mathematical maturity
19:51:33 <benzrf> juanpablo_: then natural transformation n : F -> G will map an object X in C to a morphisms between F(X) and G(X) in D
19:51:58 <ReinH> Mac Lane's Algebra takes a category theoretical approach to abstract algebra and, as such, is actually a pretty good intro to category theory.
19:52:17 <Welkin> ReinH, Mac Lane has too many books; what is the proper title?
19:52:26 <benzrf> juanpablo_: so if F(X) is A and G(X) is B, n(X) will be a morphism from A to B
19:52:28 <juanpablo_> Apparently what I stated (i.e functors are the morphisms in Cat) is only valid for the category of small categories
19:52:41 <ReinH> Welkin: it also prepares you for his Categories for the Working Mathematician, which is really the standard CT book, but requires a fair amount of mathematical maturity
19:52:41 <benzrf> if n is a natural transformation from F to G
19:52:58 <ReinH> Welkin: "Algebra" ;) http://www.amazon.com/Algebra-Chelsea-Publishing-Saunders-Lane/dp/0821816462
19:53:17 <benzrf> juanpablo_: in haskell this shows up as functions of the form 'f a -> g a' where f and g are concrete Functors
19:53:37 <juanpablo_> benzrf: any example of such function in Haskell?
19:53:42 <benzrf> maybeToList
19:53:42 <dwcook> juanpablo_: Well, Cat is exactly the category of small categories.
19:53:49 <benzrf> juanpablo_: applying the transformation becomes unifying the type with a monomorphic one
19:53:56 <benzrf> :t maybeToList
19:53:57 <lambdabot> Maybe a -> [a]
19:54:38 <benzrf> given an object a, maybeToList gives a morphism from Maybe a to [a]
19:54:56 <benzrf> there are a few natural transformation laws
19:54:59 <benzrf> having to do with composition
19:55:00 <dwcook> To be more explicit you could write forall a. Maybe a -> [a]
19:55:06 <ReinH> for all a, in fact ;)
19:55:11 <ReinH> dwcook: :p
19:55:41 <benzrf> juanpablo_: note that the object is NOT the argument to maybeToList
19:55:42 <juanpablo_> Oh I thought Cat was a bit more general. I guess restricting it to small categories makes everything easier
19:56:04 <zq-_-_-_> XKindSignatures is pretty useless without GADTs
19:56:05 <benzrf> if you think of maybeToList as a natural transformation, applying the transformation to an object corresponds to unifying a with a monomorphic type
19:56:09 <ReinH> juanpablo_: it also nicely sidesteps Russel's Paradox-like problems ;)
19:56:11 <zq-_-_-_> so why separate the two?
19:56:12 <dwcook> juanpablo_: It's to avoid a paradox much like "the set of all sets".
19:56:16 <juanpablo_> the morphism is the argument of maybeToList?
19:56:20 <ReinH> dwcook: stahp :p
19:56:27 <dwcook> ReinH: no u!
19:56:32 <ReinH> dwcook: <3
19:56:37 <dwcook> ReinH: <3
19:56:42 <benzrf> juanpablo_: 10:53 < benzrf> if you think of maybeToList as a natural transformation, applying the transformation to an  object corresponds to unifying a with a monomorphic type
19:56:43 <zq-_-_-_> zq-_-_-_: <3
19:56:48 <ReinH> dwcook: Ok looks like you've got this handled
19:56:57 <dwcook> ReinH: No that's okay, I'm going off to do something else now
19:57:23 <dwcook> MUDs don't write themselves after all
19:57:41 <juanpablo_> Let me google monomorphic haha
19:58:51 <gaze__> hey, I have a kinda general computer sciencey problem that might be phrased nicely in terms of a nondeterministic monad
19:58:58 <ReinH> dwcook: ooooh!
19:59:04 <ReinH> dwcook: you should talk to edwardk about that btw
19:59:11 <ReinH> dwcook: are you writing a MUD in Haskell?
19:59:18 <gaze__> say I have a dag that represents an expression tree
19:59:20 <dwcook> ReinH: Yes. Is edwardk as well?
19:59:32 <ReinH> dwcook: not atm but he's got a history with MUDs
19:59:41 <ReinH> pretty interesting stuff
19:59:52 <zq-_-_-_> holy shit i just defined a length-typed vector
19:59:57 <ReinH> dwcook: iirc he even wrote a multiplayer Z-Machine clone or something
20:00:01 <dwcook> ReinH: Okay, I pinged him in #haskell-game
20:00:05 <ReinH> dwcook: cool
20:00:06 <dwcook> Huh, neat
20:00:27 <gaze__> and I wish to select instructions to implement the expression tree... so a multiply, the instruction, might consume a multiply node, but I might aslo have a multiply accumulate which might be appropriate and eat more of the tree
20:00:54 <gaze__> does anyone with more CS experience know what this boils down to?
20:01:02 <gaze__> something like graph covering?
20:01:24 <athan_> What's the best way to inject compiler / linker options to objects that you need to link against? I'm having trouble with curlc.o and '-fPIC' for the curl package
20:01:34 <gaze__> or... graph... pattern matching with costs
20:02:13 <athan_> zq-_-_-_: Lemme see!
20:02:43 * hackagebot dynamic-graph 0.1.0.1 - Draw and update graphs in real time with OpenGL  http://hackage.haskell.org/package/dynamic-graph-0.1.0.1 (adamwalker)
20:03:44 <zq-_-_-_> athan_: data Nat = Z | S Nat ; data Vector :: * -> Nat -> * where { Nil :: Vector a Z; Cons :: a -> Vector a n -> Vector a (S n) }
20:03:56 <zq-_-_-_> x{datakinds,kindsigs,gadts} of course
20:04:30 <athan_> zq-_-_-_ :P, have you studied Omega?
20:04:43 <zq-_-_-_> athan_: nicht
20:04:52 <athan_> If you didn't take this from that, you might find it gold :)
20:04:54 <zq-_-_-_> i'm working through agda and idris, though
20:05:25 <athan_> zq-_-_-_: Definitely look at it, it's got some great ideas (I think you've already invented most of them!)
20:05:58 <juanpablo_> How can maybeToList be a natural transformation if it returns a concrete type instead of a type constructor?
20:06:36 <serjeem> How could I combine two monadic transformations over different types into a single transformation over a mutually recursive type, using Uniplate? I've tried using type classes and have had no luck :/
20:07:20 <serjeem> [trying to write a function that alpha-renames a C function]
20:07:29 <juanpablo_> benzrf: How can maybeToList be a natural transformation if it returns a concrete type instead of a type constructor?
20:08:23 <juanpablo_> I mean, shouldn't a natural transformation return a functor?
20:08:31 <athan_> juanpablo_: Maybe :: * -> *, [] :: * -> *
20:08:52 <athan_> sorry, [a] :: *->*
20:09:13 <athan_> it's easier if we use `data List a = Nil | Cons a (List a)`
20:09:38 <enthropy> athan_: cc-options: -fPIC if you have a cabal file
20:10:22 <enthropy> assuming that c file is actually part of a haskell package
20:10:55 <athan_> juanpablo_: I like your style of thinking, though :) I think you're right, you might be looking for a type family!
20:11:16 <athan_> enthropy: Thank you. I'll research!
20:11:46 <juanpablo_> athan_: thanks. I really need to start reading the natural transformations chapter instead of reading Wikipedia articles :)
20:12:02 <athan_> juanpablo_: You and me both :x
20:12:20 <athan_> juanpablo_: What book?? :)
20:14:30 <juanpablo_> athan_: Simmons. I just have some experience with abstract algebra and set theory, so most examples go oer my head
20:14:32 <athan_> enthropy: Success! Thank you!
20:15:16 <juanpablo_> Gotta wake up early for work tommorrow. Bye everybody! I learned a lot!
20:26:22 <serjeem> I have resolved, finally, that the C AST is just too awful to be cute with, and that it's time to suck it up and write a nasty big recursion.
20:28:00 <athan_> serjeem: What parts of it are giving you trouble? Are you trying to use Alex/Happy?
20:29:14 <enthropy> is there an existing newtype AgedMap k v = AgedMap (Seq (Map k v)) that behaves like   Map (Int, k) v?
20:30:36 <serjeem> athan_: I'm using Language.C and Uniplate, trying to write a function that alpha-renames everything in some C function
20:31:36 <serjeem> athan_: but variable declarations and expressions are two totally different datatypes, which seems to make it impossible to write without hammering out a bunch of boilerplate recursion anyway
20:31:55 <Joe_knock> Hello functional programmers.
20:32:23 <benzrf> hello Joe_knock
20:32:36 <athan_> serjeem: :/ I wish I had good advice to give, sorry!
20:33:23 <Joe_knock> I have a use-case situation, where I would like some advice about the use of functional programming vs. OO
20:33:46 <Zekka> Joe_knock: Can you describe it?
20:34:27 <serjeem> athan_: It's all good! Thanks :)
20:35:55 <enthropy> serjeem: I'm not sure about uniplate, but with syb you can do something like   everywhere (mkT $ \ (d @ CFunDef {}) -> rename "x" "y" d )
20:36:03 <enthropy> where rename -- is another call to everywhere
20:36:22 <enthropy> that changes the ident names
20:36:35 <enthropy> serjeem: is that what you're trying to do?
20:36:36 <Joe_knock> I am trying to build out a REST API that will communicate with mobile devices, a web frontend, and possibly some integrated functionality using mobile technology (ie. making an automated call from the system). The single biggest concern I have, is that this is a "mission-critical" application, meaning that lives do depend upon it. So it needs to have an uptime of 99,7%. Most of the data will be I/O intensive, but there will be
20:36:36 <Joe_knock>  future growth where computation will be necessary on incoming data as well. Would haskell work for this or would erlang be a better option?
20:37:36 <ab9rf> Joe_knock: language for this is largely irrelevant, getting two and two thirds nines is a matter of hardware and networking, not underlying software implementation :)
20:38:14 <ab9rf> Joe_knock: i can get three nines out of code cobbled together using PHP and mysql, you don't need good software for that
20:38:33 <Joe_knock> ab9rf: Would a functional language not benefit from multi-threaded processing and efficient utilization of hardware?
20:38:52 <ab9rf> Joe_knock: are you talking about efficiency, or reliability?
20:39:17 <ab9rf> Joe_knock: a good programmer can write efficient, reliable code in any language.
20:39:26 <solidus-river> :t $=
20:39:27 <lambdabot> parse error on input ‘$=’
20:39:34 <solidus-river> hmm
20:39:50 <Joe_knock> ab9rf: I should have mentioned that this service may likely scale up to over 500,000 concurrent users per demographic.
20:39:59 <Zekka> ab9rf: That's true, but I don't think it's necessarily true in a useful way
20:40:33 <athan_> :t ($=)
20:40:34 <lambdabot>     Not in scope: ‘$=’
20:40:34 <lambdabot>     Perhaps you meant one of these:
20:40:34 <lambdabot>       ‘$!’ (imported from Prelude), ‘/=’ (imported from Data.Eq),
20:40:38 <Zekka> Haskell reduces programmer error more than PHP does in my experience because of its type system and lack of side effects, but I'd agree that it's not really a language problem that determines whether he's going to get three nines
20:40:46 <Zekka> athan_: Are you looking for the one from pipes?
20:40:52 <athan_> solidus-river: Conduit?
20:41:12 <ab9rf> Joe_knock: so that means you need to plan for multiple worker boxes and load balancing.  that's mainly a systems engineering and network engineering problem.
20:41:20 <solidus-river> athan_: GLFW-b
20:41:22 <athan_> Zekka: ask solidus-river :P
20:41:28 <solidus-river> looks like its setting a store
20:41:29 <Zekka> athan_: Oh, my mistake
20:41:33 <solidus-river> or ST
20:41:43 <Joe_knock> Okay, so my use-case is more a hardware and networking concern.
20:41:45 <athan_> solidus-river: I like to set up a `cabal repl` for specific stuff :)
20:41:50 <Zekka> I can't actually find that operator in Pipes
20:41:53 <Zekka> I could have sworn it was in there
20:42:18 <Zekka> Maybe I am thinking of Conduit
20:42:19 <ab9rf> Joe_knock: largely, yes.  i'm mainly a systems engineer and as far as we're concerned we don't care how the applicaiton box services requests, we just provision enough of them to handle the load
20:42:23 <solidus-river> oh... my... lord...
20:42:29 <solidus-river> i had no clue there was a cabal repl command that did that
20:42:31 <athan_> Joe_knock: It depends on where the bottlenecks are. Those are where the important codez will be
20:42:34 <Zekka> http://hackage.haskell.org/package/OpenGL-2.9.2.0/docs/Graphics-Rendering-OpenGL-GL-StateVar.html#v:-36--61- <- Is this your operator?
20:42:36 <athan_> like where all the nodes meet
20:42:36 <solidus-river> i've just been running ghci and using :load
20:42:39 <Joe_knock> Perhaps I haven't done as much research, but isn't Erlang useful for distributed systems? Would that not impact the systems engineering planning?
20:42:42 <solidus-river> that is a great command
20:42:48 <lfairy> solidus-river: works with sandboxes too
20:43:02 <Joe_knock> ab9rf: ^^
20:43:03 <athan_> solidus-river: `cabal unpack` is another favorite :)
20:44:21 <ab9rf> Joe_knock: for the most part it doesn't matter much; most web apps are fairly readily implemented with multiple independent workers.  all you need is some sort of shared state storage for session data, and arbitration for persistent data resources
20:44:42 <Zekka> solidus-river: Just so you know, I found that operator using hoogle
20:44:42 <ab9rf> Joe_knock: erlang has no real great advantage in this area because web workers processes are rarely cooperative
20:44:56 <Zekka> if you don't know about hoogle you should probably start using it because it's really great
20:45:05 <athan_> Joe_knock: I think you need to diagnose your notion of software strength. I think you need more principal than a particular language. But, IMO, Haskell > all ;)
20:45:45 <Joe_knock> ab9rf: Thank you so far for the enlightening advice. Perhaps I then need to ask, will I benefit from using a static-typed language over something like Python/Ruby for a mission-critical app?
20:46:01 <ab9rf> Joe_knock: i don't know, i don't know enough about your experience and background
20:46:33 <athan_> Joe_knock: Are you looking for node recovery and distribution of tasks? Or resillience against attacks? Or fast / low-memory operations in a single machine?
20:46:33 <ab9rf> Joe_knock: i'd avoid ruby for "mission critical" because ruby's runtime is so ludicrously dog-slow
20:46:40 <Joe_knock> athan_ : Good point. I guess I was just trying to optimize the software-side of things to ensure that the hardware isn't drudging along a bohemoth of inefficiency.
20:46:46 <Zekka> My gut reaction is that if your app is nontrivial Haskell is likely to be more reliable than most dynamically typed languages, like I said
20:46:51 <athan_> Joe_knock: Speed, at the cost of your fingers (from the typing)
20:47:00 <ab9rf> Joe_knock: but that might not be a problem if your ruby code isn't going to be the performance bottleneck
20:47:12 <athan_> Joe_knock: check out Yesod!!!
20:47:15 <ab9rf> Joe_knock: don't optimize the solution until you have a solution
20:47:42 <athan_> ab9rf: <---- gold advice right there
20:47:59 <ab9rf> Joe_knock: don't try to resolve the bottlenecks in your environment until you have an environment.
20:48:15 <athan_> 90% of programming is planning and thinking
20:48:17 <ab9rf> Joe_knock: that'll show up in pre-deployment stress testing, and you can deal with it then
20:48:25 <Joe_knock> athan_ : The communication between mobile app and REST API is where most communication will happen. The web application will be used simply for "pushing" data fed from mobile devices. As far as what data will be coming in?  It will just be the GPS-location of the device.
20:48:48 <solidus-river> Zekka: awesome, thats it
20:48:57 <athan_> Joe_knock: Look up Warp, WAI, and WebSockets
20:48:58 <ab9rf> Joe_knock: from what i've heard from you your major bottleneck is going to be the persistent datastore
20:49:04 <Joe_knock> ab9rf: Again, brilliant advice.
20:49:16 <solidus-river> Zekka: i wish there was a way i could get Hoogle in cli form
20:49:22 <solidus-river> but i've never thoguh to google for hoogle cli
20:49:26 <solidus-river> so maybe it exists
20:49:28 <Zekka> solidus-river: Pretty sure you can
20:49:30 <Zekka> try cabal install hoogle
20:50:00 <ab9rf> Joe_knock: do you have any target SLAs?
20:50:05 <athan_> Joe_knock: Latency is an issue? Or do you just need good concurrency so your server never stops taking in the messages?
20:50:21 <Joe_knock> ab9rf: Yes, the persistent data is critical in that it must always feed data when receiving a "POST" and must perpetually be feeding automated "GET" requests to the web application.
20:50:36 <ab9rf> Joe_knock: you said that this system is intended to "save lives", are there maximum response times or other metrics that must be met?
20:50:39 <athan_> I cheat sometimes... and just come here to /msg lambdabot @hoogle... :p
20:50:47 <solidus-river> lol
20:51:15 <solidus-river> i wish lambdacube would get their latest stuff on hackage
20:51:20 <solidus-river> i dont understand why they dont have it there
20:51:38 <solidus-river> is there a mini war going on between git and hackage that they are trying to be in?
20:52:14 <ab9rf> Joe_knock: by 'persistent datastore' i'm referring to the backend database.  if there's going to be a high volume of writes, you'll probably end up bottlenecking against ACID-based locking issues
20:52:17 <athan_> Joe_knock: You can send/recieve with extremely compact, binary data with websockets
20:52:22 <Joe_knock> ab9rf: As far as saving lives goes, the vital part is that requests coming in must never be lost and must be fed to the appropriate web applications within the GPRS coordinates. So say, I stay in Bronx, NY. This data must reach the web app of certain individuals within bronx, NY.
20:52:31 <athan_> I'm trying to write a new web design framework under this method
20:52:35 <athan_> minimal communications
20:52:42 <athan_> and dynamic front-end construction
20:52:42 <athan_> idk
20:53:25 <ab9rf> Joe_knock: "must never be lost" means you need to build a transactional system and probably have to store transactions in a persistent datastore when they're received so that if a worker fails during a transaction it can be restarted on a new worker
20:53:31 <athan_> it's weird. I don't know if it will ever be correct, but I've seen a lot of other people do similar things. I saw this one guy make an operating system in a javascript runtime :x
20:53:52 <ab9rf> Joe_knock: even then you'll still occasionally lose a transaction
20:54:20 <Joe_knock> ab9rf and athan_ Your advice is proving really helpful. I am starting to see how my use-case doesn't explicitly require an FP language.
20:54:29 <Zekka> athan_: That actually reminds me, I had a really silly open-ended question I wanted to ask about
20:54:46 <ab9rf> Joe_knock: my advice n language chouce is that you should choose a language that your development team is comfortable with.
20:55:09 <Joe_knock> ab9rf: I guess Java would be the choice then.
20:55:15 <ab9rf> Joe_knock: there are very few use cases that absolutely demand a specific language
20:55:39 <Zekka> I don't have much skill in low-level programming but a lot of my friends are interested in operating system development and compiler design -- I'd like to share the interest but in the past I've been turned off because it's hard to determine whether code is correct, or if code is incorrect, why it is
20:55:55 <Joe_knock> I really wanted to experiment with Nimrod, but the team itself comprises of people skilled in Java.
20:55:56 <ab9rf> Zekka: hehe, ain't that the truth
20:56:03 <athan_> Joe_knock: I would study haskell if correctness and assurance is important to you, still
20:56:14 <Zekka> I was wondering if anybody in FP had worked on checking the correctness of assembly language and C code, or coming up with alternatives that are still pretty close to the metal which are better at that sort of thing
20:56:16 <ab9rf> Joe_knock: asking the development team to learn a new language is generally asking for failure
20:56:46 <Zekka> (I'm still pissed off because I wrote a bootloader and my friends looked at it, showed it to their friends, and none of htem could figure out what was wrong with it, yet it still didn't work)
20:56:51 <athan_> Zekka: Well, there's QEMU, and possibly a wrapper
20:57:04 <Joe_knock> athan_ and ab9rf: You guys are definitely correct in that the most familiar language is a normal first-choice. I was just trying to determine whether the use-case of OO would be fatally wrong in my situation, which doesn't seem to be the case here.
20:57:31 <athan_> Joe_knock: The think I really like about Haskell / FP is how modular it is
20:57:35 <Zekka> athan_: I'm confused, what does that have to do with what I asked? Obviously you can test code on qemu, but unit-testing isn't the same as demonstrating correctness or isolating incorrectness
20:57:40 <athan_> It's like the UNIX philosophy in a language itself
20:57:58 <Zekka> In a typesafe language like Haskell I don't have to unittest my code to prove that the vast majority of wrong code I write really is wrong
20:58:12 <ab9rf> Joe_knock: that said, a well-written Haskell app will probably handle three to ten times the service volume of a java-based app, and is more likely to e correct.
20:58:21 <athan_> Zekka: I agree, but I believe that qemu may still have something good to offer- it's VM
20:58:41 <ab9rf> Joe_knock: if you can get the programming talent you need to implement in haskell, you'll probably get a more reliable product; the problem will be finding the talent
20:58:42 <athan_> I think this is where we would have to construct the symbolic proofs
20:58:46 <athan_> but I have no idea, honestly
20:58:55 <Joe_knock> "three to ten times the service volume" - So efficiency wise, haskell wins against Java.
20:58:56 <athan_> I would really like to see something like this emerge
20:59:18 <athan_> (unless linux already has some form of testing suite... (it's gotta))
20:59:23 <Zekka> athan_: I've been tempted to do drafting (since I know a little bit about compiler design but not very much) for a typesafe C-like language
20:59:38 <ab9rf> Zekka: ow, you just made my brain hurt
20:59:50 <Joe_knock> ab9rf: I assumed that due to the nature of the application where it is mostly I/O, that we could skip on major experience, as complexity is limited.
20:59:51 <Zekka> one of my friends is a wheel-reinventor and wants to come up with his own C replacement
21:00:16 <ab9rf> Joe_knock: well, all the metrics i've seen for haskell app frameworks is that they're much more efficient anr robust than the comparable java frameworks
21:00:28 <athan_> Zekka: Me too!!! I think that's a great idea, but I'm unsure where it should go
21:00:33 <athan_> have you seen any stack-based languages?
21:00:43 <athan_> they have a virtual stack, but they're still very mechanistic
21:00:45 <Zekka> athan_: Yeah, I think concatenative programming is an interesting start
21:01:08 <ab9rf> Joe_knock: they're also less flexible, and i'm not sure how well either snap or yesod handle being run as a worker pool
21:01:15 <Zekka> especially since if I'm not mistaken they're pretty easy to compile compared to i.e. Haskell
21:01:21 <Joe_knock> ab9rf: I will have to speak to the team about this. We will likely be restrained by resources for a significant period of time, so maximising on efficiency will be key.
21:01:45 <Zekka> I don't really think Joy or Forth is very pretty, of course
21:01:50 <ab9rf> Joe_knock: "three nines" and "restrained on resources" are mutually incompatible
21:02:08 <athan_> yeah, me neither
21:02:19 <ab9rf> the only way to get three nines is redundancy redundancy and redundancy
21:02:39 <Joe_knock> ab9rf: That is true. But I want to maximise on the software side so that I can redirect more resources to the systems-engineering/networking issues
21:03:31 <ab9rf> Joe_knock: waste of energy.  the thing is, once you get to the redundancy to handle three nines, your software stack can actually be fairly crap and the load balancing and failover will deal with your software farting
21:04:45 <ab9rf> you'll probably run the workers either on cheap commodity hardware or on virtual hosts; either way, the cost of adding another worker box is minimal
21:04:49 <Joe_knock> ab9rf: Good points again. I've added this channel to my auto-join list. I hope to see you around again, to discuss things. Thanks for the advice.
21:05:38 <ab9rf> hm, has anybody written haskell interfaces for the amazon EC2 stack yet? :)
21:05:46 <Joe_knock> athan_: Thank you as well.
21:06:00 <ab9rf> it's been a year or so since i looked at AWS
21:15:27 <snardbafulators> guys  I need some advice here on how to resolve this compile error that I am getting in terminal
21:15:30 <snardbafulators> http://i.imgur.com/eizzhMx.jpg
21:21:29 <Crockeo> snardbafulators: *sigh* I will admit, a funny attempt at trolling, but still trolling.
21:26:32 <mayski> nice..
21:27:45 <knappador> Anyone know a heist example not using Snap?
21:27:55 --- mode: ChanServ set +o copumpkin
21:27:59 --- mode: copumpkin set +b *!~tinytim@200.79.255.125
21:27:59 --- kick: snardbafulators was kicked by copumpkin (No. Bad.)
21:28:01 --- mode: copumpkin set -o copumpkin
21:28:12 <knappador> I found one, but it's compiling badly even after I got past import errors.
21:28:13 <knappador> https://www.fpcomplete.com/school/to-infinity-and-beyond/older-but-still-interesting/compiled-heist-insight-with-no-snap-in-sight
21:28:48 <knappador> I might want just a snap example
21:28:53 <knappador> i mean heist
21:28:58 <knappador> instead of compiled heist
21:29:15 <knappador> trying to get to hello world with importing a template and starting to do basic fragment/substitution
21:31:29 <benzrf> heyj:
21:31:32 <benzrf> *hey
21:31:48 <benzrf> in pipes, is there a version of (>->) that's push-based instead of pull-based
21:31:56 <benzrf> i.e. the upstream one is on control by default
21:32:02 <napping> yeah
21:32:06 <benzrf> whats it called
21:32:14 <napping> I think it's not in the usual module
21:32:19 <benzrf> yea
21:32:43 <benzrf> `foo >>~ const bar' discards the first output
21:32:45 <napping> oh, looks like I lost haddocks/pipes when reinstalling stuff
21:32:51 <benzrf> i could do something like
21:33:01 <benzrf> foo >>~ \v -> yield v >-> bar
21:33:05 <benzrf> but that feels overkill and wrong
21:35:23 <napping> looks like you've found the right operatons
21:37:10 <benzrf> gluh
21:37:15 <napping> >>~
21:37:55 <napping> what's the downstream component supposed to do when the upstream one first pushes a vaule?
21:39:49 <benzrf> oic what you mean
21:40:04 <benzrf> eeeeh
21:40:07 <napping> That's why a lot of the Pipes.Core stuff has functions
21:40:13 <benzrf> :I
21:40:30 <napping> If you're dealing with the general Proxy stuff, there might have been an upstream request with the label
21:40:44 <benzrf> meh
21:40:51 <benzrf> im to tired too do this
21:40:55 <benzrf> its past midnight
21:40:58 <benzrf> and i have school tomorrow x.x
21:41:06 <benzrf> x.x
21:41:09 <benzrf> x.x
21:41:11 * benzrf sleeps
21:41:15 <benzrf> bye
21:45:55 <solidus-river> is there a way to map fromIntegral over a tuple of Integrals?
21:46:04 <solidus-river> fmap seems to apply to only the last in the tuple
21:52:29 <enthropy> > over each show (1,2,3)
21:52:32 <lambdabot>  ("1","2","3")
21:52:57 <pdxleif> is that some lens stuff?
21:53:06 <enthropy> yes
21:53:28 <enthropy> over each show (1,2 :: Double,3 :: Int) -- doesn't work
21:53:56 <dwcook> @type each
21:53:57 <lambdabot> (Each s t a b, Applicative f) => (a -> f b) -> s -> f t
21:54:01 <Welkin> > over each show (1,2,3.0)
21:54:03 <lambdabot>  ("1.0","2.0","3.0")
21:54:08 <dwcook> I think there's only a relevant instance for tuples of the same type
21:54:25 <dwcook> @type over
21:54:26 <lambdabot> Profunctor p => Setting p s t a b -> p a b -> s -> t
21:55:16 <enthropy> > (1,2,3) & each %~ show -- if you prefer symbols
21:55:18 <lambdabot>  ("1","2","3")
21:58:25 <pavonia> So will the next Haskell Platform release inlcude lens?
21:59:21 <enthropy> it wouldn't be sane to have an instance of Each for tuples with different element types
22:00:31 * enthropy guesses you'd call that class Some
22:11:45 <dwcook> I guess you'd need some sort of type product to do that?
22:17:01 <enthropy> you can do something like http://hackage.haskell.org/package/HList-0.3.4.1/docs/Data-HList-FakePrelude.html#t:ApplyAB
22:18:07 <enthropy> or you things like   instance Some (x,a) (y,a) x y; instance Some (a,x) (a,y) x y
22:18:49 * enthropy wonders if that would work
22:19:34 <enthropy> it's probably the same as what you get with tinplate
22:20:23 <enthropy> hmm, except you get to change the result type
22:32:17 <solidus-river> how come some constructors whine at me when trying to explicitly import them from Graphics.Rendering.OpenGL?
22:33:07 <jle`> solidus-river: which ones? how are you importing them?
22:33:16 <jle`> what is the error?
22:33:22 <solidus-river> jle` incoming lpaste
22:36:14 <solidus-river> http://lpaste.net/105657
22:36:16 <solidus-river> jle`: ^
22:36:58 <jle`> solidus-river: what happens if you put al the imports on one import statement
22:37:17 <Crockeo> In the first import, you're importing it as "import Graphics.Rendering.OpenGL (Color3, ... Triangles, ...)"
22:37:29 <Crockeo> Instead of PrimitiveMode(Triangles)
22:37:30 <solidus-river> jle`: the same thing, i just split it out while trying to debug
22:38:03 <solidus-river> i'll put em all on the same line, it doesnt help though, (..) doesnt work either
22:38:20 <solidus-river> only seems to be happy if i dont qualify any imports from it
22:38:46 <jle`> i don't see any qualified imports
22:39:00 <Crockeo> solidus-river: is the code you've been using at first "import Graphics.Rendering.OpenGL  (Color3, Vertex3, Vector3, GLdouble, Triangles, color, vertex)" verbatim?
22:39:23 <Crockeo> And shouldn't it be, "import Graphics.Rendering.OpenGL  (Color3, Vertex3, Vector3, GLdouble, PrimitiveMode(Triangles), color, vertex)"
22:39:27 <solidus-river> oooooh, i have it doubled there
22:39:43 <solidus-river> :X
22:39:45 <Crockeo> (and then delete the second import!)
22:40:06 <solidus-river> i'm curiouse, i'm using GLFW and it has a data type Key
22:40:16 <solidus-river> and an accessor on it that is Key'Escape
22:40:23 <solidus-river> is ' an inline function here?
22:40:31 <jle`> solidus-river: it's a normal character
22:40:34 <ab9rf> no, it'sjust a characer
22:40:40 <ab9rf> the symbol nam eis "Key'Escape"
22:40:45 <jle`> you know how people sometimes like to add a prime to variable names
22:40:47 <jle`> x, x'
22:40:50 <jle`> foo, foo'
22:41:03 <jle`> ' is treated as a normal alphanum, like _
22:41:15 <solidus-river> jle`: ah, how come it gets imported when i say Key(..)
22:41:23 <jle`> Key is the type
22:41:27 <jle`> Key'Escape is the constructor
22:41:32 <solidus-river> is Key'Escape an alias to an instance of Key then?
22:41:37 <ab9rf> it's a constructor
22:41:51 <ab9rf> it constructs an instance of the type
22:41:52 <jle`> like import Maybe(Just, Nothing)
22:42:20 <Crockeo> Key could be defined as: data Key = Key Key'Escape, for all we know! (I mean there's obviously other stuff there)
22:42:26 <solidus-river> oh, i get it
22:42:31 <Crockeo> Er, data Key = Key'Escape *
22:42:44 <jle`> this is also not an accessor
22:42:55 <solidus-river> that seems like a wierd way of organizing things
22:43:02 <Crockeo> Anyone here at all familiar with the lens library?
22:43:13 <Crockeo> I've been trying my hand at picking it up but it's all a little daunting.
22:43:16 <ab9rf> solidus-river: it's fairly typical in haskell, although it takes a while to get used to
22:43:24 <jle`> data Maybe a = Just a | Nothing gives you Just and Nothing as constructors, and also Just and Nothing as "destructors"
22:43:30 <jle`> but neither are accessors
22:43:45 <ab9rf> yeah, ifyou wan tan accessor you have to define that yourself
22:43:53 <jle`> or use record syntax
22:43:59 <dmj`> Crockeo: there is #haskell-lens
22:44:17 <jle`> data Maybe a = Just { fromJust :: a } | Nothing
22:44:19 <Crockeo> dmj`: Thank you! I didn't know that. (It explains why conversation about lens has died down so much in here!)
22:44:51 <ab9rf> i need a cheeseburger
22:44:53 <jle`> solidus-river: you see it alot where you would use an Enum type in other languages
22:45:01 <jle`> the apostrophe is a little weird though I'll admit
22:45:24 <jle`> i would have done something like data Key = KEscape | KEnter | KSpace | ...
22:45:28 <jle`> or some other naming convention
22:45:46 <jle`> but the apostrophe is one way you can chose to name your constructors
22:45:56 <solidus-river> ab9rf: lens are hard to wrap your head around, this is the article that finally did it for me https://www.fpcomplete.com/user/tel/lenses-from-scratch
22:46:17 <dwcook> Does a Handle's NewlineMode affect bytestring's hGetLine?
22:46:23 <solidus-river> jle`: yeah, i was familiar with enumerators being written like that but I had never seent the ' in there
22:46:37 <Crockeo> solidus-river: Thanks for the link! Time to learn about lenses :D
22:46:51 <jle`> solidus-river: ah. yeah, i guess it's just another ol naming convention
22:47:18 <jle`> apostrophes in the middle of identifiers is still weird for me
22:48:20 <dwcook> I notice that "Binary-mode Handles do no newline translation at all." How do I determine whether my Handle is binary-mode? I obtained it from network's accept.
22:49:50 <dwcook> Ah, found it, hGetEncoding should do it.
22:49:55 <solidus-river> ab9rf: be warned though, that article definitly didn't just make things click for me, i read about half way, then read about Store, Comonads, Coalgebras, Monomorphisms, then went back to the article, then read more on catamorphisms and then i got it
22:50:23 <solidus-river> i dont think catamorphisms are related, i'm still a little fuzzy on them
22:51:15 <jle`> ab9rf: the lens homepage has a very accessible tutorial for using lens practically
22:51:23 <jle`> like not even difficult at all
22:51:28 <jle`> very straightforward
22:51:45 <jle`> it should work for you up until the point you get your first type error ;)
22:53:00 <solidus-river> so its good practice to explicitly import things from modules that aren't prelude
22:53:13 <solidus-river> but what do you do when you have an import tuple thats a gazillion things long
22:53:27 <solidus-river> trying to think up how to make the import not take up a ton of space but also not look bad
22:53:44 <jle`> i don't think it's common to expicitly import constructors
22:53:59 <Hafydd> Why is it good practice to explicitly import things?
22:54:47 <solidus-river> Hafydd: well, I think it is because i guess i'm new to a lot of these libraries
22:55:07 <solidus-river> Hafydd: it helps a ton while trying to understand a new code base if everything is explicitly imported
22:55:08 <enthropy> if those modules change and stop exporting things you need
22:55:29 <Hafydd> I suppose it might, but only if the list were short enough to be readable.
22:55:49 <enthropy> you get an error that tells you where it used to come from, and not that one of the modules used to provide it
22:57:12 <jle`> i suau/b 14
22:57:15 <jle`> oops sorry
23:10:58 <solidus-river>     ortho (negate ratio) ratio (negate 1.0) 1.0 1.0 (negate 1.0)
23:11:12 <solidus-river> is there no cleaner way of negating values when passing them into functions?
23:11:21 <solidus-river> trying to say -1.0 throws a type fit
23:11:31 <solidus-river> but (negate 1.0) is fine
23:11:41 <solidus-river> although ridiculously verbose
23:12:23 <Zekka> solidus-river: Does (-1.0) not work? (with parens)
23:13:06 * hackagebot yesod-auth 1.3.1.1 - Authentication for Yesod.  http://hackage.haskell.org/package/yesod-auth-1.3.1.1 (MichaelSnoyman)
23:13:32 <jle`> > let x = 6.0 in -x
23:13:34 <lambdabot>  -6.0
23:14:01 <Zekka> > negate (-1.0)
23:14:03 <lambdabot>  1.0
23:14:09 <Zekka> It seems to have let me pass it to a function there
23:14:10 <solidus-river> hmm so (-6.0) works but -6.0 fails with a type problem
23:14:24 <jle`> solidus-river: yes
23:14:24 <solidus-river> > negate -1.0
23:14:24 <Zekka> solidus-river: It thinks you're trying to subtract 6.0 from the function
23:14:25 <lambdabot>  No instance for (Data.Typeable.Internal.Typeable a0)
23:14:25 <lambdabot>    arising from a use of ‘M369119092527195112921819.show_M3691190925271951129...
23:14:25 <lambdabot>  The type variable ‘a0’ is ambiguous
23:14:25 <lambdabot>  Note: there are several potential instances:
23:14:25 <lambdabot>    instance Data.Typeable.Internal.Typeable Data.Dynamic.Dynamic
23:14:28 <jle`> it's rather annoying isn't it
23:14:33 <Zekka> It reads it as "negate - 1.0"
23:14:57 <jle`> it treats (-) as an infix operator when there are no parentheses
23:15:03 <jle`> > (+) 5 -6
23:15:05 <lambdabot>  No instance for (Data.Typeable.Internal.Typeable a0)
23:15:05 <lambdabot>    arising from a use of ‘M618348454270853508021831.show_M6183484542708535080...
23:15:05 <lambdabot>  The type variable ‘a0’ is ambiguous
23:15:05 <lambdabot>  Note: there are several potential instances:
23:15:05 <lambdabot>    instance Data.Typeable.Internal.Typeable Data.Dynamic.Dynamic
23:15:10 <jle`> > (+) 5 (-6)
23:15:12 <lambdabot>  -1
23:15:24 <solidus-river> hmm, i guess i'd prefer it if infix operators required a space on either side
23:15:28 <jle`> the former is read as (+) 5 - 6
23:15:41 <solidus-river> it would fix the problem of lenses looking wierd and the ambiguity i had earlier iwth what Key'Escape was
23:15:44 <solidus-river> *with
23:16:27 <solidus-river> but parens are fine
23:18:15 <LuxuryMode> Anyone here know anything about the yorgey course? Am I allowed to use prelude functions for the homework? I used ++ and reverse and I'm not sure if I'm supposed to.
23:19:16 <shachaf> byorgey might know.
23:20:00 <shachaf> I imagine that you're allowed to use Prelude functions if it doesn't say otherwise, because it would be odd to forbid them. But I haven't read it.
23:23:53 <LuxuryMode> shachaf thanks
23:25:29 <Fuuzetsu> is corgifex mauke?
23:26:34 <Fuuzetsu> because his library is being contested for upload rights  on libraries@ so someone should probably let him know
23:38:48 <schlegel> uh weird
23:38:53 <schlegel> Are services down?
23:47:10 <u_> >pf id
23:47:12 <u_> > pf id
23:47:14 <lambdabot>  Not in scope: ‘pf’
23:47:14 <lambdabot>  Perhaps you meant one of these:
23:47:14 <lambdabot>    ‘pi’ (imported from Prelude),
23:47:14 <lambdabot>    ‘f’ (imported from Debug.SimpleReflect),
23:47:14 <lambdabot>    ‘p’ (imported from Debug.SimpleReflect)
23:47:30 <Zekka> @pf id
23:47:30 <lambdabot> Maybe you meant: pl bf
23:47:33 <Zekka> @pl id
23:47:33 <lambdabot> id
23:58:52 <augur> whats the One True Way to engage the filesystem?
