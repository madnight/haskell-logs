00:00:09 <ski> it feels a bit silly to unwrap like that, but i think it could possibly work
00:00:16 <ski> altern : try it ?
00:03:20 <altern> ski: yep! it works! thanks a lot
00:05:56 * hackagebot hashable 1.2.2.0 - A class for types that can be converted to a hash value  http://hackage.haskell.org/package/hashable-1.2.2.0 (JohanTibell)
00:05:58 * hackagebot hashable 1.2.1.0 - A class for types that can be converted to a hash value  http://hackage.haskell.org/package/hashable-1.2.1.0 (JohanTibell)
00:06:00 * hackagebot hashable 1.2.0.10 - A class for types that can be converted to a hash value  http://hackage.haskell.org/package/hashable-1.2.0.10 (JohanTibell)
00:06:02 * hackagebot hashable 1.2.0.9 - A class for types that can be converted to a hash value  http://hackage.haskell.org/package/hashable-1.2.0.9 (JohanTibell)
00:06:04 * hackagebot hashable 1.2.0.8 - A class for types that can be converted to a hash value  http://hackage.haskell.org/package/hashable-1.2.0.8 (JohanTibell)
00:07:18 <ski> hm
00:08:48 <ski> @type let foldr1 :: (a -> r -> r) -> (a -> r) -> ([a] -> r); foldr1 cons sing [a] = sing a; foldr1 cons sing (a:as) = cons a (foldr1 cons sing as) in foldr1
00:08:49 <lambdabot> (a -> r -> r) -> (a -> r) -> [a] -> r
00:09:10 <ski> it would be nicer to use that one here
00:09:16 * hackagebot hashable 1.2.0.5 - A class for types that can be converted to a hash value  http://hackage.haskell.org/package/hashable-1.2.0.5 (JohanTibell)
00:09:16 * hackagebot hashable 1.2.0.6 - A class for types that can be converted to a hash value  http://hackage.haskell.org/package/hashable-1.2.0.6 (JohanTibell)
00:09:40 <ski> then one could say `foldr1 Version VersionCompound ds' instead
00:10:05 * ski ponders what a reasonable alternate name for this `foldr1' could be
00:11:52 <Axman6> foldererROne
00:17:59 <testerr> Hello, all! Is this where pandoc devs and users hang out?
00:19:12 * hackagebot primitive 0.4 - Wrappers for primitive operations  http://hackage.haskell.org/package/primitive-0.4 (HerbertValerioRiedel)
00:19:14 * hackagebot primitive 0.4.0.1 - Wrappers for primitive operations  http://hackage.haskell.org/package/primitive-0.4.0.1 (HerbertValerioRiedel)
00:19:16 * hackagebot primitive 0.4.1 - Wrappers for primitive operations  http://hackage.haskell.org/package/primitive-0.4.1 (HerbertValerioRiedel)
00:19:18 * hackagebot primitive 0.5 - Primitive memory-related operations  http://hackage.haskell.org/package/primitive-0.5 (HerbertValerioRiedel)
00:19:20 * hackagebot primitive 0.5.0.1 - Primitive memory-related operations  http://hackage.haskell.org/package/primitive-0.5.0.1 (HerbertValerioRiedel)
00:19:31 <Axman6> possibly, but if you have a question you should probably ask it
00:26:36 <dfg888> selling intim
00:29:13 * hackagebot primitive 0.5.1.0 - Primitive memory-related operations  http://hackage.haskell.org/package/primitive-0.5.1.0 (HerbertValerioRiedel)
00:44:15 * hackagebot wai 3.0.0 - Web Application Interface.  http://hackage.haskell.org/package/wai-3.0.0 (MichaelSnoyman)
00:44:34 <joelteon> poor hackagebot
00:49:16 * hackagebot wai-app-static 3.0.0 - WAI application for static serving  http://hackage.haskell.org/package/wai-app-static-3.0.0 (MichaelSnoyman)
00:49:18 * hackagebot wai-conduit 3.0.0 - conduit wrappers for WAI  http://hackage.haskell.org/package/wai-conduit-3.0.0 (MichaelSnoyman)
00:49:20 * hackagebot http-reverse-proxy 0.3.1.8 - Reverse proxy HTTP requests, either over raw sockets or with WAI  http://hackage.haskell.org/package/http-reverse-proxy-0.3.1.8 (MichaelSnoyman)
00:49:22 * hackagebot wai-eventsource 3.0.0 - WAI support for server-sent events (deprecated)  http://hackage.haskell.org/package/wai-eventsource-3.0.0 (MichaelSnoyman)
00:49:24 * hackagebot wai-extra 3.0.0 - Provides some basic WAI handlers and middleware.  http://hackage.haskell.org/package/wai-extra-3.0.0 (MichaelSnoyman)
00:54:26 * hackagebot wai-frontend-monadcgi 3.0.0 - Run CGI apps on WAI.  http://hackage.haskell.org/package/wai-frontend-monadcgi-3.0.0 (MichaelSnoyman)
00:54:28 * hackagebot wai-handler-fastcgi 3.0.0 - Wai handler to fastcgi  http://hackage.haskell.org/package/wai-handler-fastcgi-3.0.0 (MichaelSnoyman)
00:54:30 * hackagebot wai-handler-launch 3.0.0 - Launch a web app in the default browser.  http://hackage.haskell.org/package/wai-handler-launch-3.0.0 (MichaelSnoyman)
00:54:32 * hackagebot wai-test 3.0.0 - Unit test framework (built on HUnit) for WAI applications. (deprecated)  http://hackage.haskell.org/package/wai-test-3.0.0 (MichaelSnoyman)
00:54:34 * hackagebot wai-websockets 3.0.0 - Provide a bridge betweeen WAI and the websockets package.  http://hackage.haskell.org/package/wai-websockets-3.0.0 (MichaelSnoyman)
00:59:36 * hackagebot warp 3.0.0 - A fast, light-weight web server for WAI applications.  http://hackage.haskell.org/package/warp-3.0.0 (MichaelSnoyman)
00:59:38 * hackagebot warp-tls 3.0.0 - HTTP over SSL/TLS support for Warp via the TLS package  http://hackage.haskell.org/package/warp-tls-3.0.0 (MichaelSnoyman)
00:59:40 * hackagebot yesod 1.2.6 - Creation of type-safe, RESTful web applications.  http://hackage.haskell.org/package/yesod-1.2.6 (MichaelSnoyman)
00:59:42 * hackagebot yesod-bin 1.2.10 - The yesod helper executable.  http://hackage.haskell.org/package/yesod-bin-1.2.10 (MichaelSnoyman)
00:59:44 * hackagebot yesod-core 1.2.16 - Creation of type-safe, RESTful web applications.  http://hackage.haskell.org/package/yesod-core-1.2.16 (MichaelSnoyman)
01:04:46 * hackagebot yesod-eventsource 1.1.1 - Server-sent events support for Yesod apps.  http://hackage.haskell.org/package/yesod-eventsource-1.1.1 (MichaelSnoyman)
01:04:48 * hackagebot yesod-form 1.3.10 - Form handling support for Yesod Web Framework  http://hackage.haskell.org/package/yesod-form-1.3.10 (MichaelSnoyman)
01:04:50 * hackagebot yesod-persistent 1.2.3 - Some helpers for using Persistent from Yesod.  http://hackage.haskell.org/package/yesod-persistent-1.2.3 (MichaelSnoyman)
01:04:52 * hackagebot yesod-static 1.2.4 - Static file serving subsite for Yesod Web Framework.  http://hackage.haskell.org/package/yesod-static-1.2.4 (MichaelSnoyman)
01:04:54 * hackagebot yesod-test 1.2.3 - integration testing for WAI/Yesod Applications  http://hackage.haskell.org/package/yesod-test-1.2.3 (MichaelSnoyman)
01:08:28 <pepper_chico> is there a way to define typed constants? I'm getting warnings in lines were the numbers don't have a defined type: http://bl.ocks.org/anonymous/raw/bc091544fb6efe843ab7
01:09:24 <pepper_chico> something like 1u?
01:09:52 <corgifex> what warning?
01:09:56 * hackagebot yesod-websockets 0.1.1 - WebSockets support for Yesod  http://hackage.haskell.org/package/yesod-websockets-0.1.1 (MichaelSnoyman)
01:22:47 <jle`> is there a performance penalty for realToFrac to convert a type to its own type (like id)?
01:23:38 <dmj``> why is a haskell library outputting files with the extension .p_o?
01:24:21 * hackagebot yesod-platform 1.2.12 - Meta package for Yesod  http://hackage.haskell.org/package/yesod-platform-1.2.12 (MichaelSnoyman)
01:24:23 * hackagebot yesod-bin 1.2.10.1 - The yesod helper executable.  http://hackage.haskell.org/package/yesod-bin-1.2.10.1 (MichaelSnoyman)
01:26:02 <crazydave> There is a default for Haskell of [Integer, Double] meaning that undefined constants are taken to be Integer (when they have no decimal point) or Double (when they do).  You can even turn this default off which would give you _errors_ where you now have warnings.  It is the Haskell compiler telling you that it cannot infer the type of the literal to be Int/Integer/Word32/etc and so is defaulting to Integer.
01:27:49 <dmj``> crazydave: was that for me?
01:28:38 <jle`> crazydave: i know that ghc-mod gives me a warning when any defaulting is performed
01:35:11 <taruti> What is currently the web framework making it easy to serve some dynamic content with as few lines as possible that works with ghci?
01:41:31 <merijn> taruti: I don't think any of them are really designed to work in ghci
01:42:45 <merijn> dmj``: .p_o are profiled binary objects
01:43:43 <dmj``> merijn: ahhh :) I see, thank you
01:44:16 <taruti> ghci is so nice for interactive things, but reloading makes global state go into a limbo
01:45:43 <taruti> is it possible to have a hook "run this IO() before reloading" in ghci?
01:48:29 <dmj``> taruti: what are you trying to do
01:49:23 <dottedmag> "Upload" link from Hackage homepage is broken (the one in navbar is ok). Where should I report it?
01:49:41 <taruti> dmj``: using ghci (+emacs) as a platform for interactive performances, generating&playing audio, and want to generate live html-content as well.
01:50:21 <dmj``> taruti: cool
01:51:56 <taruti> I think I can tie emacs to call my "reset-things-before-reload" action on reload, if not possible natively.
01:52:43 <dottedmag> Found the bug reporting instructions on Hackage website.
01:52:59 <pavonia> dottedmag: You could also try #hackage
01:55:22 <dottedmag> pavonia: thanks
02:00:27 <gilligan_> what's a good way in haskell to check if an external program is installed at runtime ? say I want to check on start if hoogle or hasktags is installed
02:01:54 <dmj``> do { res <- doesFileExist "/Users/user/cabal/bin/hasktags"; when res $ putStrLn "exists" }
02:03:49 <jle`> is it good practice to have a Show instance for a parametric type only be valid for types in a type signature
02:04:37 <jle`> parameterized
02:04:50 <gilligan_> dmj``, that will only work on OSX / only if i know where the program is installed and is thus rather limited
02:04:52 <bennofs> jle`: do you have an example?
02:05:18 <jle`> bennofs: instance Fractional a => Show (Foo a) where ...
02:05:42 <dmj``> gilligan_: you could use a filepath library that works across posix systems. getHomeDirectory </> "filename" would be cross platform
02:05:47 <jle`> Foo can contain anything, but only things that are Fractional can be shown
02:06:07 <jle`> in reality semantically Foo shouldn't really hold anything other than a Fractional, and all functions on Foo require it to be fractional
02:06:23 <bennofs> jle`: And Show a => Show (Foo a) doesn't work?
02:06:43 <jle`> bennofs: no because the show function does things with a that require it to be Fractional
02:06:47 <jle`> ...as an example
02:06:49 <jle`> say it was Real
02:06:54 <gilligan_> dmj``, still i think it'd probably be better to check if RandomProgram is in path and executable or just execute it and see if i get an error
02:06:57 <jle`> which is a more plausible example
02:07:22 <bennofs> jle`: also, the result of `show a` should be valid haskell code. If that is satisfied, I don't see why that instance should be bad
02:07:31 <jle`> maybe instance RealFrac a => Show (Foo a) where show (Foo x) = show (round x)
02:07:54 <jle`> would be a full example
02:08:00 <jle`> yeah, everything still is typesafe
02:08:30 <jle`> it jsut feels slightly weird
02:08:49 <jle`> my example probably should be instance (Show a, RealFrac a) => Show (Foo a) where show (Foo x) = show (round x)
02:10:21 <bennofs> jle`: but that means that if I put the output of `show a` in GHCi, I won't get 'a' back.
02:10:43 <jle`> bennofs: well
02:10:59 <jle`> let's pretend the type constructor isn't exported, and a function constructing it is
02:11:05 <jle`> and that function rounds the number when it stores it
02:11:17 <jle`> so Foo (round x) is identical to Foo x
02:11:25 <jle`> makeFoo = Foo . round
02:11:30 <jle`> so
02:11:44 <jle`> instance (Show a, RealFrac a) => Show (Foo a) where show (Foo x) = "makeFoo " ++ show (round x)
02:12:12 <bennofs> I think that would be ok, it is similar to how Data.Map is shown as fromList [...]
02:12:41 <jle`> hm ok
02:12:56 <jle`> thanks :)
02:19:13 <meditans> threepenny-gui question: is there the possibility to retrieve the content of, for example, a list? The library is full of WriteAttr, and I don't know how to
02:19:39 <meditans> turn them in meaningful Attrs
02:31:31 <fuzzy_id> i don't understand the purpose of System.Posix.Files.isSymbolicLink
02:31:58 <fuzzy_id> i applied it to a symlink (well, it's FileStatus) and it returned False
02:32:24 <fuzzy_id> the doc says "Checks if this file is a symbolic link device." but i never heard of that
02:32:43 <fuzzy_id> is there an alternative function?
02:34:33 * hackagebot warp 3.0.0.1 - A fast, light-weight web server for WAI applications.  http://hackage.haskell.org/package/warp-3.0.0.1 (MichaelSnoyman)
02:34:56 <killy9999> http://lpaste.net/105332
02:35:13 <killy9999> I'm getting this not-in-scope error with arrow do-notation and let-bound function
02:35:21 <killy9999> any suggestions what I'm doing wrong?
02:35:56 <supki> fuzzy_id: how did you get its FileStatus?
02:36:16 <fuzzy_id> isSymbolicLink <$> getFileStatus f
02:36:40 <supki> getFileStatus returns FileStatus for the file link points to
02:36:48 <Philonous> killy9999, arrows can't depend on computed data.
02:37:00 <fuzzy_id> oh
02:37:18 <supki> fuzzy_id: use getSymbolicLinkStatus instead
02:37:23 <Philonous> killy9999, Since "fun" doesn't depend on the input argument you can just float it out of the proc, though
02:37:29 <fuzzy_id> ok, my fault
02:37:37 <fuzzy_id> misread the docs :()
02:37:58 * killy9999 thinks about Philonous explanation
02:38:13 <gilligan_> dmj``, findExecutable :: String -> IO (Maybe FilePath)
02:38:20 <gilligan_> dmj`` ;-}
02:38:24 <Philonous> killy9999, Sorry, what I said was utterly misleading: I meant: arrows cannot depend on data computed _int the same arrow-computation_
02:38:46 <killy9999> Philonous: where do I have such a dependency?
02:39:00 <killy9999> I don't see it
02:39:35 <Philonous> killy9999, You don't, not really, but the let belongs to the arrow-do block, so it's not in scope between the arrow-heads
02:39:57 <Philonous> killy9999, Move the let in front of the proc and you're fine
02:40:09 <ski> or use `where'
02:40:20 <Philonous> That works too, for the same reason
02:41:45 <killy9999> that makes sense
02:41:47 <killy9999> thanks
02:42:05 <Philonous> killy9999, The point is, arrows can't change they course of the computation depending on intermediary data. You need ArrowChoice for a limited form of branching or ArrowApply for a general case (but ArrowApply is equivalent to a Monad, so you could just use that)
02:42:23 <Philonous> s/a Monad/Monad
02:43:02 <Walther> Hakyll seems to replace spaces in the urls with %20. While perhaps semantically correct, it makes the urls a bit untidy and less readable by the users; is it possible to (easily) change this default to say, a hyphen?
02:43:21 <killy9999> Philonous: thanks. I'm still groking arrows
02:43:39 <killy9999> well, actually I'm trying to understand how desugaring is implemented
02:43:40 <killy9999> in GHC
02:49:35 * hackagebot d-bus 0.1.1 - Permissively licensed D-Bus client library  http://hackage.haskell.org/package/d-bus-0.1.1 (PhilippBalzarek)
02:54:12 <dottedmag> Walther: seems to be hardcoded: http://jaspervdj.be/hakyll/reference/src/Hakyll-Web-Html.html#toUrl
02:59:55 <meditans> http://stackoverflow.com/questions/24117788/mixing-threepenny-gui-and-statet
03:08:40 <johnw> Walther: you could make your own route function
03:08:55 <johnw> Walther: do you have spaces in the actual file names?
03:09:08 <Walther> johnw: nod, ended up just naming my posts/* manually with s/\s/-/g
03:09:22 <johnw> I was going to suggest that :)
03:10:04 <Walther> a) lazier in the current state to just rename those than to write a comprehensive replacing function b) the replacing function would probably run into edge cases anyway so it's probably safer to just hyphenate manually
03:16:47 <yitz> Walther: sounds like it would be a nice feature though. why not suggest it? https://github.com/jaspervdj/Hakyll/issues
03:17:18 <yitz> Walther: or just write it, and submit a pull request.
03:17:35 <Walther> hm, let's see :)
03:19:24 <Walther> yitz: gah, it uses escapeURIString, which is imported from Network.URI
03:21:38 <Gurkenglas> http://lpaste.net/105335
03:22:08 <Gurkenglas> So apparently that code is too slow (replacing the 48 with much lower values makes it runnable)
03:22:37 <Gurkenglas> How is that so? I see only quadratically many different values being computed
03:23:35 <Gurkenglas> (Also please make any comments on style you can think of)
03:24:02 <Gurkenglas> (System.Environment is automatically inserted by that compile haskell online site)
03:24:32 <Gurkenglas> (Also how is that $ at 6:13 redundant?)
03:24:40 * hackagebot http-client 0.3.3.1 - An HTTP client engine, intended as a base layer for more user-friendly packages.  http://hackage.haskell.org/package/http-client-0.3.3.1 (MichaelSnoyman)
03:24:42 * hackagebot http-conduit 2.1.2.1 - HTTP client package with conduit interface and HTTPS support.  http://hackage.haskell.org/package/http-conduit-2.1.2.1 (MichaelSnoyman)
03:29:40 * hackagebot instrument-chord 0.1.0.9 - Render Instrument Chords  http://hackage.haskell.org/package/instrument-chord-0.1.0.9 (AlanHawkins)
03:32:23 <yitz> Walther: sure, that's the standard URI parser. but i'm sure you can work around that.
03:33:42 <Walther> yitz: Well, I'm not all that sure. Punching in a manual "optionally, convert spaces to hyphens first and then use the standard uri parser" could result in some funky business
03:34:15 <Walther> potentially break some (obscure/edge case) things
03:34:41 * hackagebot http-reverse-proxy 0.4.0 - Reverse proxy HTTP requests, either over raw sockets or with WAI  http://hackage.haskell.org/package/http-reverse-proxy-0.4.0 (MichaelSnoyman)
03:34:43 * hackagebot keter 1.3.1 - Web application deployment manager, focusing on Haskell web frameworks  http://hackage.haskell.org/package/keter-1.3.1 (MichaelSnoyman)
03:34:45 * hackagebot vector 0.1 - Efficient Arrays  http://hackage.haskell.org/package/vector-0.1 (HerbertValerioRiedel)
03:34:59 <yitz> Walther: well in any case you would probably need to keep track of file paths and URLs separately at that point, wouldn't you? that anyway might not be such a bad idea...
03:35:07 <cow_2001> what's a good GUI toolkit a newbie can experiment with quickly without much hassle?
03:35:41 <yitz> cow_2001: perhaps threepenny-gui
03:36:03 <cow_2001> yitz: I'll look into that, thank you!
03:36:51 <johnw> why did hackagebot announce vector-0.1?
03:36:52 <cow_2001> there should be more newbie oriented toolkits :|
03:37:03 <johnw> the latest is 0.10.11.0
03:37:07 <yitz> for a more traditional desktop gui, there's also a haskell binding for qt light. the name slips my mind at the moment...
03:37:29 <sipa> johnw: it was just updated
03:37:38 <johnw> ah
03:38:29 <yitz> sipa: edited dependency bounds perhaps?
03:38:50 <funfunctor> why do we need liftM ? Isn't a functor already a Monad?
03:39:20 <johnw> funfunctor: :)
03:39:28 <johnw> within the next year, it will be
03:39:33 <yitz> cow_2001: oh, qt *quick. and it's called hsqml. http://hackage.haskell.org/package/hsqml
03:39:37 <johnw> and I think you mean, isn't a monad already a functor
03:39:42 * hackagebot vector 0.2 - Efficient Arrays  http://hackage.haskell.org/package/vector-0.2 (HerbertValerioRiedel)
03:39:44 * hackagebot vector 0.4 - Efficient Arrays  http://hackage.haskell.org/package/vector-0.4 (HerbertValerioRiedel)
03:39:45 <funfunctor> johnw: oh sweet
03:39:46 * hackagebot yesod-bin 1.2.10.2 - The yesod helper executable.  http://hackage.haskell.org/package/yesod-bin-1.2.10.2 (MichaelSnoyman)
03:39:48 <funfunctor> yes
03:40:09 <funfunctor> what is MichaelSnoyman nick? does he hang here?
03:40:12 <johnw> I look forward to not using liftM anymore, and being able to use <$>
03:40:14 <johnw> snoyberg
03:40:15 <yitz> funfunctor: liftM is now just a specialization of fmap, but it has been in existence for a lot longer than fmap.
03:40:19 <johnw> he's not on IRC very often
03:40:28 <cow_2001> snoyberg is :D
03:40:40 <funfunctor> hehe thanks guys
03:41:26 <cow_2001> yitz you are a good person. :|
03:41:26 <funfunctor> I'm just writting a mini compiler in Haskell at the moment using Parsec, I think I managed to get the REPL prompt to sort of work
03:41:32 <cow_2001> yitz: thanks!
03:41:42 <yitz> cow_2001: thanks for the compliment!
03:42:00 <johnw> yitz: I wanted to talk with you more about conduits and async exceptions
03:42:09 <johnw> did you have any examples in mind where you think simple-conduit would fail?
03:43:08 <yitz> johnw: i would have to work to come up with one, not being intimately familiar with the innards of conduit.
03:43:30 <johnw> since I'm only using bracket, I would be extremely interested to know of loopholes in my formulation
03:43:50 <yitz> johnw: but i had a lot of discussions with snoyberg when this was all being developed, so i know how central that was to the design.
03:44:05 <johnw> yes, he and I have discussed async exceptions on many occasions
03:44:13 <yitz> johnw: and how that was a major point of differents between conduits and pipes in the early days
03:44:18 <johnw> right
03:44:20 <yitz> *difference
03:44:43 * hackagebot vector 0.4.1 - Efficient Arrays  http://hackage.haskell.org/package/vector-0.4.1 (HerbertValerioRiedel)
03:45:07 <johnw> in simple-conduit, you only have nested function invocation, with brackets appearing a various levels.  This eliminates all of the flexibility you get in conduit with ResourceT, such as tryC, catchC, etc.  It's very restricted, but should therefore be immune to those issues
03:45:27 <yitz> johnw: i'm sure that snoyberg would be delighted to discuss this point, and would be able to come up with examples on the spot.
03:45:36 <johnw> yes, I'm pretty sure he would be able to
03:45:42 <yitz> johnw: he probably didn't see your post. you should ping him about it.
03:46:01 <johnw> I linked him in an e-mail
03:46:06 <johnw> he's probably busy this week
03:46:16 <yitz> johnw: could be.
03:47:24 <yitz> johnw: aha. so if you limit the model like that, it seems plausible that you could indeed avoid some of the complexity.
03:47:42 <johnw> yes, in terms of dealing with exceptions, I was a bit dismayed by just how limited it became
03:48:05 <johnw> but in exchange I can write things like: mapM_C print (sourceFile "foo")
03:48:15 <johnw> without having to liftIO or runResourceT
03:48:58 <johnw> it's really quite braindead; but surprisingly covers many of my conduit use cases!
03:49:42 <johnw> though certainly not all
03:49:43 * hackagebot typeparams 0.0.3.0 - Lens-like interface for type level parameters; allows unboxed unboxed vectors and supercompilation  http://hackage.haskell.org/package/typeparams-0.0.3.0 (MikeIzbicki)
03:50:15 <yitz> johnw: why is wrapping it in a lift so bad? truthfully, as a user i find conduits quite simple. a lot of work went into pushing the required complexity away from the commonly used parts of the interface.
03:50:45 <johnw> it's not bad per se
03:50:58 <johnw> I just like not having to work in a transformer sometimes
03:51:42 <johnw> and I'm a big fan of conduit, don't get me wrong
03:52:23 <johnw> but if simple-conduit is all you need, there are some benefits
03:53:23 <yitz> johnw: in any case, it's great to share explorations of the design space. io is not trivial, and our steadily increasing understanding of it is one of the main driving forces behind the growth of haskell.
03:53:32 <k0ral> lens-4.2 cannot be built without integer-gmp; is there any way to work around it ? I have installed GHC with integer-simple because of problems using libgnutls
03:54:02 <johnw> yitz: that's a good insight
03:54:05 <yitz> k0ral: why does lens need integer-gmp specifically? that sounds weird.
03:54:21 <johnw> doesn't integer-gmp install with GHC itself?
03:54:45 <yitz> johnw: yes. it's the default implementation of Integer.
03:55:06 <k0ral> yitz: lens-4.2 depends on scientific >= 0.3, which depends on integer-gmp
03:55:19 <yitz> johnw: ghc now allows you to replace it with a different implementation that is not gpl-encumbered.
03:55:26 <k0ral> johnw: unless you tell GHC not to, as I did
03:55:37 * yitz looks at scientific...
03:57:28 <k0ral> and it's not so much about gpl-encumbering; it's because the garbage collector messes up with the memory allocation of integer-gmp
03:58:01 <k0ral> I've got segmentation faults using libgnutls with integer-gmp-GHC, while everything works fine with integer-simple-GHC
04:00:09 * ski annotated <http://lpaste.net/105335> with "style"
04:00:12 <ski> Gurkenglas ^
04:00:30 <Gurkenglas> thx
04:01:44 <yitz> k0ral: aha. it uses it in Math.NumberTheory.Logarithms.
04:02:51 <yitz> k0ral: woah. that's really bad.
04:03:21 <yitz> k0ral: wait you have your own ffi binding to libgnutls?
04:04:29 <k0ral> yitz: I'm using webkitgtk3, which makes use of libgnutls
04:04:49 <yitz> k0ral: perhaps you could convince edwardk to add a flag that omits scientific
04:05:08 <funfunctor> alright, time for tips on how I am screwing things up? https://gist.github.com/victoredwardocallaghan/3e107f8415a75e6f2197
04:05:29 <funfunctor> how can I re-write line 61 to be a bit nicer
04:07:09 <k0ral> yitz: I've opened an issue on lens' github, let's see what edwardk thinks of it
04:07:30 <bennofs> funfunctor: why does evalString return IO String? Maybe it should just return String? Then you can also drop the 'return'
04:07:40 <yitz> k0ral: no obvious mention of gnutls in the webkitgtk3 cabal file
04:07:50 <yitz> k0ral: i see you've dug pretty deep into this already
04:08:28 <bennofs> funfunctor: eh, does that even typecheck?
04:09:18 <funfunctor> bennofs: almost.. readExpr has the wrong signature
04:09:35 <yitz> k0ral: interactions with tls that cause segfaults are a big deal. you should definitely also bring this urgently to the attention of the "gtk2hs team"
04:09:46 * hackagebot cabal-lenses 0.2 - Lenses and traversals for the Cabal library.  http://hackage.haskell.org/package/cabal-lenses-0.2 (DanielTrstenjak)
04:11:35 <k0ral> yitz: already did in http://sourceforge.net/p/gtk2hs/mailman/gtk2hs-users/thread/20140515065151.GA8342%40mystik/
04:14:29 <funfunctor> bennofs: if evalString does not return  IO String then what about evalAndPrint ?
04:15:33 <bennofs> funfunctor: evalAndPrint expr = putStrLn $ evalString expr  (or pointfree: evalAndPrint = putStrLn . evalString)
04:16:04 <funfunctor> oh yea I should eta-reduce some stuff later
04:16:50 <funfunctor> thanks
04:19:48 * hackagebot cabal-cargs 0.7 - A command line program for extracting compiler arguments from a cabal file.  http://hackage.haskell.org/package/cabal-cargs-0.7 (DanielTrstenjak)
04:20:18 <yitz> k0ral: wow. this is awful.
04:21:35 <yitz> k0ral: someone really needs to fix this in gmp. it's not just a haskell problem. gmp is used a lot in crypto. i can image security vulnerabilities all over the internet because of this.
04:21:43 <yitz> *imaging
04:21:46 <yitz> *imagine
04:23:29 <k0ral> I can't understand the intricacies of this issue, I can only try to reach smart-enough people that can fix it
04:24:54 <yitz> k0ral: it's not *that* intricate. this gmp issue has been known for years; it's the reason behind a major change in ghc that allows you to use a different implementation for Integer.
04:25:23 <bennofs> yitz: this is a GHC problem though, not a GMP problem, right?
04:25:25 <yitz> k0ral: the problem is that gmp is just so good that you can't just get rid of it. otherwise, we would.
04:25:35 <hpc> what other implementations of Integer are there?
04:25:44 <yitz> bennofs: it's a ghc problem caused by a gmp problem.
04:25:53 <k0ral> yitz: that I had figured out
04:26:01 <yitz> bennofs: an inherent major design problem in gmp.
04:26:10 <bennofs> yitz: what's the GMP problem? That there is only a global allocation function?
04:26:31 <dottedmag> bennofs: yes
04:27:05 <dottedmag> Looks like every second language runtime out there sets it to its own callback: http://codesearch.debian.net/search?q=mp_set_memory_functions
04:27:08 <yitz> bennofs: that you register the memory allocation function, replacing malloc, with a global static function pointer shared by all users of libgmp.
04:28:08 <yitz> dottedmag: python took the other route - they have their own big integer library.
04:29:49 * hackagebot d-bus 0.1.2 - Permissively licensed D-Bus client library  http://hackage.haskell.org/package/d-bus-0.1.2 (PhilippBalzarek)
04:32:03 <k0ral> couldn't the scientific package offer 2 alternate set of dependencies, one with integer-gmp, the other with integer-simple ?
04:32:15 <k0ral> sets*
04:32:37 <yitz> k0ral: yes, that would also make sense.
04:32:53 <jophish> Is there a nice list of haskell/category theory jargon somewhere?
04:33:02 <jophish> wikipedia has a small glossary
04:33:44 <yitz> jophish: Mac Lane, Categories for the Working Mathematician. (just joking)
04:34:04 <bennofs> jophish: typeclassopedia? Or more advanced?
04:34:19 <jophish> I'm trying to think of a good domain name :)
04:34:33 <jophish> monad.io is taken :)
04:36:40 <bennofs> jophish: applicative IO is better anyway :)
04:37:17 <yitz> jophish: have you seen the wiki page, and the wikibook chapter? http://www.haskell.org/haskellwiki/Category_theory and http://en.wikibooks.org/wiki/Haskell/Category_theory
04:37:28 <jophish> bennofs: taken too :|
04:37:47 <jophish> The best I've come up with is morphi.sm
04:37:50 <jophish> iso.morphi.sm
04:38:03 <jophish> yitz: I'll take a look, thanks!
04:38:07 <corgifex> m.onad.io
04:38:27 <yitz> jophish: good news! adjunction.io is available.
04:38:33 <dottedmag> mon.ad. Pricey.
04:39:14 <corgifex> my files have a .kan extension
04:41:02 <bennofs> mono.id :)
04:41:12 <jophish> bennofs: (That was secretly be best one)
04:41:21 <jophish> not available until august though
04:41:27 <jophish> my*
04:41:48 <corgifex> mona.de is sadly taken :-)
04:42:08 <jophish> bennofs: I think that .id has a minimum length of 5 characters anyway :(
04:42:33 <yitz> jophish: hard to tell whether functori.al is taken. albania doesn't have a whois service for their tld.
04:42:37 <bennofs> jophish: where do you check if a domain is free
04:42:39 <bennofs> ?
04:42:46 <Nik05> how would one found out whats wrong when ghc says "parse error on input 'foo'" ? :P
04:42:50 <jophish> yitz: you have to be albanian too
04:42:59 <jophish> bennofs: whois usually
04:43:04 <corgifex> Nik05: what's the line number?
04:43:10 <bennofs> whois mono.id times out for me
04:43:16 <yitz> jophish: i take it you weren't thinking of relocating in the near future.
04:43:19 <jophish> domai.nr is pretty good too
04:43:22 <Nik05> ghc doesnt like this... parseMessage line = let type = parseType line
04:43:28 <jophish> yitz: not to albania
04:43:40 <corgifex> Nik05: that doesn't contain "foo"
04:43:44 <jophish> A friend of mine managed to get genderneutr.al somehow though
04:43:46 <corgifex> Nik05: show real code and real errors
04:43:51 <Nik05> sorry it says error on type
04:44:03 <corgifex> Nik05: 'type' is a keyword
04:44:10 <Nik05> oh right haha
04:44:29 <yitz> Nik05: use typ or typpe or type' or something
04:45:30 <corgifex> > let tyрe = 42 in tyрe
04:45:31 <lambdabot>  42
04:45:56 <Nik05> huh how does that work?
04:46:02 <funfunctor> bennofs: https://gist.github.com/victoredwardocallaghan/3e107f8415a75e6f2197 why does it complain that I don't have a instance of 'show' ?
04:46:08 <yitz> corgifex: haha. my faulty font doesn't kern that correctly, so it gave you away.
04:46:10 <dschoepe> Nik05: look closely at the p :)
04:46:26 <Nik05> no i dont see it
04:46:29 <bennofs> funfunctor: what line does it complain on?
04:46:31 <corgifex> > let tуpe = 2; tyрe = 3 in tyрe + tуpe
04:46:33 <lambdabot>  5
04:46:37 <FireFly> Oh you
04:46:49 <funfunctor> bennofs: line 61
04:47:02 <funfunctor>  No instance for (Show EtaVal) arising from a use of ‘show’
04:47:07 <Nik05> but what did you do corgifex ?
04:47:12 <FireFly> Nik05: insidious Unicode characters I'm guessing
04:47:17 <bennofs> funfunctor: because you do `show found`, found :: EtaVal, and EtaVal is not an instance of Show
04:47:19 <Nik05> oh ok
04:47:28 <FireFly> > ord 'р'
04:47:30 <lambdabot>  1088
04:47:46 <corgifex> > 'у'
04:47:48 <lambdabot>  '\1091'
04:47:49 <bennofs> funfunctor: show :: Show a => a -> String   -- if a is EtaVal, Show EtaVal must be satisfied
04:48:12 <yitz> let ǝdʎʇ = 42 in ǝdʎʇ
04:48:15 <yitz> > let ǝdʎʇ = 42 in ǝdʎʇ
04:48:17 <lambdabot>  42
04:49:34 <FireFly> let type = id; ǝdʎʇ = flip type in 1 `ǝdʎʇ` id
04:49:40 <FireFly> er, >
04:49:42 <corgifex> > let ᴛʏᴘᴇ = 42 in 42
04:49:43 <lambdabot>  42
04:49:51 * hackagebot wai-app-file-cgi 2.0.5 - File/CGI/Rev Proxy App of WAI  http://hackage.haskell.org/package/wai-app-file-cgi-2.0.5 (KazuYamamoto)
04:50:31 <funfunctor> bennofs: ah ah
04:52:54 <Nik05> cool corgifex looks like my parser now works correctly :)
04:53:02 <corgifex> sweet
04:53:24 <yitz> Nik05: did you use corgifex's unicode hack?
04:53:33 <Nik05> no yitz :)
04:53:36 <yitz> :)
04:55:12 <funfunctor> bennofs: ok I got something sort of working, thanks
04:57:37 <Nik05> could you give me another advise on my "parser" ? :) http://lpaste.net/5940055859039043584
04:58:04 <Nik05> it looks really messy, how to improve that?
04:58:34 <bennofs> jophish: foldi.ng
04:58:45 <jophish> bennofs: ooh, good one
04:59:10 <bennofs> not sure how to get a ng domain though :p
04:59:19 <funfunctor> Nik05: check out Parsec, that is what I am using
04:59:47 <jophish> bennofs: nigeria, about 200$/year
04:59:54 <bennofs> oh :P
05:00:12 <Nik05> thats out of my reach (joke :D)
05:00:23 <fprivacy> There's a Text type which case-folds comparisons.  Anyone remembers what it is called?
05:00:57 <Nik05> but funfunctor this was just an exercise just a simple parser, dont think you would need Parsec for that
05:01:03 <hexagoxel> Nik05: replace "if null .." with pattern matching; also more pattern matching at top level
05:01:43 <Nik05> how would i pattern match that?
05:01:54 <hexagoxel> and by top level i mean parseType
05:02:38 <Nik05> oh you mean parseType 'I':rest = ?
05:02:39 <funfunctor> Nik05: I just said "check out" ;)
05:02:50 <Nik05> thank you funfunctor :)
05:03:13 <hexagoxel> Nik05: case level of { [] -> ..; (levelhead:_) -> .. }
05:03:32 <Nik05> oh ok thank yiu
05:03:44 * ski 'd replace `(levelhead:_)' there with `levelhead:_', simply
05:04:53 * hackagebot mighttpd2 3.0.6 - High performance web server on WAI/warp  http://hackage.haskell.org/package/mighttpd2-3.0.6 (KazuYamamoto)
05:06:16 <Nik05> wow it still compiles
05:06:46 <hexagoxel> Nik05: parseType ('I':_:rs) = (Just Info, rs)
05:07:00 <Nik05> yep thats what i just did :)
05:07:55 <Nik05> but i guess i would need to do 'I':rs, because if the char after I is not a space it would be invalid
05:08:10 <Nik05> ok maybe the parser doesnt really work correctly
05:08:32 <hexagoxel> well you did "drop 2"
05:08:38 <hexagoxel> dunno why :)
05:08:55 <Nik05> to drop the space too, but thats not really correct if it isnt a space
05:10:10 <bennofs> jophish: pure.ly
05:10:34 <jophish> .ly, exotic
05:10:48 <bennofs> oops, also pretty expensive :p
05:11:22 <dottedmag> pure.io is taken
05:11:50 <PragCypher> is it possible to run a .hs file within a haskell sandbox without integrating it within the .cabal file?
05:12:02 <PragCypher> *cabal sandbox
05:15:06 <hexagoxel> PragCypher: "cabal repl" + ":l MyNonIntegratedModule" ?
05:16:23 <dottedmag> isomorphi.sm. Pricey.
05:17:07 <yitz> k0ral: https://github.com/basvandijk/scientific/issues/15
05:17:47 <supki> PragCypher: cabal exec -- runhaskell file.hs  with new enough cabal-install
05:18:04 <supki> PragCypher: or you can pass -package-db option manually
05:18:25 <Nik05> wow hexagoxel this is getting a lot cleaner, thank you
05:18:40 <Nik05> and also looks kind of redundant :P
05:21:30 <PragCypher> supki: this works thank you
05:23:25 <Nik05> would you guys use Maybe or just a list?
05:26:51 <yitz> Nik05: usually if you need a Maybe, use Maybe. you can easily convert back and forth using listToMaybe and maybeToList from Data.Maybe.
05:27:25 <Nik05> http://lpaste.net/5940055859039043584 how did i do revising?
05:29:17 <ski> Nik05 : could a valid `line' in `parseMessage' be `"I"' or `"W"' or `"E"' ?
05:29:30 <Nik05> no
05:29:44 <Nik05> well then its Unknown
05:30:07 <ski> could the line end directly after the `TimeStamp', with no extra character after it ?
05:30:45 <Nik05> maybe :P
05:31:06 <xxx-man> ski: hi
05:32:56 <cow_2001> how do I tell threepenny not to listen to 0.0.0.0?
05:34:40 <Nik05> ski but does it look good? :)
05:35:38 <Nik05> i can even remove more
05:35:51 <k0ral> yitz: thank you !
05:48:14 <yitz> cow_2001: right, i don't see any obvious way to configure that. anyway, the standard thing to do with browser-based guis is to use a reverse proxy.
05:51:07 <matematikaadit> A year of functional programming http://japgolly.blogspot.com.au/2014/06/a-year-of-functional-programming.html
05:51:47 <hexagoxel> Nik05: lines 74-78 can be shortened.
05:52:53 <Nik05> hexagoxel yes already done :) let is redundant
05:54:58 * hackagebot http-reverse-proxy 0.4.0.1 - Reverse proxy HTTP requests, either over raw sockets or with WAI  http://hackage.haskell.org/package/http-reverse-proxy-0.4.0.1 (MichaelSnoyman)
05:55:23 <Nik05> like this right hexagoxel ?
05:56:36 <hexagoxel> Nik05: and the case-expression effectively has type [a] -> [b] (although you do not specify anything for n>1), so .. (hint, hint)
05:56:54 <yitz> cow_2001: if you want to modify threepenny gui to allow modifying the bind address directly, you would do it in src/Graphics/UI/Threepenny/Internal/Driver.hs
05:57:29 <Nik05> hexagoxel i dont see what to do. it goes from [(a, b)] -> [(c, b)]
05:58:02 <Nik05> oh list comprehension or somethign?
05:58:08 <yitz> cow_2001: near line 120, config = Snap.setPort ... etc. you would add to that list of settings: Snap.setBind addr
05:58:45 <hexagoxel> :t map . first
05:58:46 <lambdabot> (b -> c) -> [(b, d)] -> [(c, d)]
05:58:50 <ski> Nik05 : sorry, got side-tracked a bit
06:00:47 <matematikaadit> "Scala is a gateway drug to Haskell", then "Haskell is a gateway drug to ..."?
06:01:06 <Nik05> hexagoxel first?
06:01:26 <hexagoxel> :t Control.Arrow.first
06:01:27 <lambdabot> Arrow a => a b c -> a (b, d) (c, d)
06:02:22 <hexagoxel> (in this case, a is (->))
06:02:29 <Nik05> :S
06:03:03 <Nik05> ok i get it with (->) but wow :P
06:03:26 <nbouscal> matematikaadit: Agda
06:03:32 <nbouscal> matematikaadit: and/or Idris
06:03:37 <Nik05> its magic hexagoxel
06:03:50 <Nik05> oh and why doesnt reads return a Maybe instead of a list?
06:04:24 <nbouscal> :t Data.Bifunctor.first
06:04:26 <lambdabot> Bifunctor p => (a -> b) -> p a c -> p b c
06:04:43 <nbouscal> (alternatively)
06:04:48 <Nik05> and (a, b) is a bitfunctor?
06:04:52 <Nik05> bi*
06:04:53 <matematikaadit> list of successes
06:04:53 <nbouscal> yep
06:04:59 * hackagebot cabal-bounds 0.6 - A command line program for managing the bounds/versions of the dependencies in a cabal file.  http://hackage.haskell.org/package/cabal-bounds-0.6 (DanielTrstenjak)
06:05:13 <matematikaadit> no success means empty list
06:05:39 <Nik05> but can the list have more than one element?
06:07:21 <c_wraith> Nik05: people thought there might be ambiguous parses, where you can possibly parse an expression in multiple ways.  So, a list.
06:07:30 <c_wraith> Nik05: it turned out that's basically never true, though
06:07:45 <c_wraith> Nik05: At least for the uses the Read class has
06:08:03 <Nik05> ok :)
06:10:08 * ski annotated <http://lpaste.net/5940055859039043584> with "style"
06:10:10 <ski> Nik05 ^
06:10:20 <ski> that's based on one of your older revisions, though
06:10:31 <xpika> what is the difference between Ptr and ForeignPtr
06:10:32 <xpika> ?
06:11:41 <Nik05> nbouscal Data.Bifunctor not found
06:12:00 <nbouscal> Nik05: it's in the bifunctors package. there's talk about moving it into base, but it has not happened yet
06:12:31 <Nik05> ok thank you
06:13:31 <ski> xpika : foreignly managed references, possibly with finalizers. see <http://www.cse.unsw.edu.au/~chak/haskell/ffi/ffi/ffise5.html#x8-300005.5>
06:15:01 * hackagebot hsimport 0.4 - A command line program for extending the import list of a Haskell source file.  http://hackage.haskell.org/package/hsimport-0.4 (DanielTrstenjak)
06:15:05 <Nik05> wow someone edited the paste
06:16:09 <ski> Nik05 : i annotated the paste, not edited it
06:16:18 <Nik05> thank you ski :)
06:16:46 <xpika> ski: thankyou
06:17:11 <Nik05> how do you like it now ski? its now only 15 lines
06:17:32 <nbouscal> Is there currently any way of instantiating e.g. Functor on a datatype with kind [*] -> *? I'm guessing not yet?
06:17:56 <ski> Nik05 : i'll first make the second annotation i had in mind, before responding
06:19:00 <nbouscal> Seems related to PolyKinds and the changes with Typeable, but I haven't been able to find much via google.
06:19:41 <haasn> Is there an easier way to recreate a sandbox (including all sources) than “cabal sandbox list-sources; cabal sandbox delete; cabal sandbox init; cabal sandbox add-source ...; cabal sandbox add-source ...; ...” ?
06:19:48 <haasn> Something like “cabal sandbox clean” would be great
06:20:50 <nbouscal> haasn: I usually pipe list-sources into a .sh file and add in "cabal sandbox add-source" before each. would be nice if there were a faster way
06:20:51 <funfunctor> how can I handle backspaces properly in my REPL here? https://gist.github.com/victoredwardocallaghan/d255e08677a1f2351087
06:20:55 <xxx-man> ski: hi
06:21:32 <yitz> nbouscal: and even that doesn't work if there are snapshot sources. you just need to record the original add-source commands and repeat them.
06:22:22 <Philonous> funfunctor, Maybe try haskeline? http://hackage.haskell.org/package/haskeline
06:25:05 <funfunctor> Philonous: I can't this is for a embedded system
06:26:00 <haasn> Hmm, it gets better; now I've recreated my sandbox including all add-source dependencies but they don't seem to actually get tracked!
06:26:08 <haasn> I can change the upstream dependency, re-run “cabal repl” and it won't get updated
06:26:30 <haasn> I thought I remember reading something about a bug like that, but I can't find it. How do I work around?
06:26:54 <Philonous> haasn, I think you need to cabal-build to grab the new source dependency
06:27:00 <Philonous> cabal build I mean
06:27:02 <haasn> Also, for some reason, if I try re-running “cabal install --only-dependencies” then it tries *downgrading* mtl
06:27:06 <haasn> For some inexplicable reason. Huh?
06:27:50 <haasn> Weird, at least it works now; after the downgrade stuff
06:28:00 <haasn> I don't understand why it didn't do that the first time
06:30:29 <funfunctor> Philonous: I *think* it has something to do with buffering
06:31:03 <yitz> haasn: yeah there are some bugs. what version of cabal are you using?
06:31:57 <yitz> haasn: it always works to rm -r cabal.sandbox.config .cabal-sandbox and then cabal sandbox init
06:32:36 <yaymukund> "it's better to split longer list comprehensions across multiple lines, especially if they're nested"
06:32:40 <yaymukund> does anyone have any examples of this?
06:32:59 <funfunctor> Philonous: ok runhaskell works so its to do with GHCIi being NoBuffering
06:33:26 <nbouscal> yaymukund: honestly if I had a multi-line list comprehension I probably wouldn't use a list comprehension, but that's a style choice
06:33:58 <Philonous> funfunctor, hSetBuffering stdin LineBuffering then?
06:34:03 <yaymukund> https://gist.github.com/yaymukund/24f7489b0c18c4c1e5a0 that's my erroring code
06:34:08 <yaymukund> if I join it into one line, it works
06:34:21 <funfunctor> Philonous: i'm only using GHCIi for debuggering so it does not matter
06:34:35 <funfunctor> I was just wondering wtf was going on..
06:34:44 <yaymukund> nbouscal: I might not either, but I'd like to know how to
06:34:58 <yitz> yaymukund: indent after the let
06:35:54 * ski annotated <http://lpaste.net/5940055859039043584> with "refactoring"
06:35:58 <ski> Nik05 ^
06:36:01 <Nik05> thank you ski
06:37:31 <yitz> yaymukund: lines following let horizontals = [ must be indented more than "horizontals", otherwise a spurious ';' gets inserted
06:37:57 <Nik05> ok i will try to find out what you did with that do notation
06:38:40 <yaymukund> yitz: oooo
06:38:43 <yaymukund> yitz: thanks
06:39:03 <xxx-man> ski: there?
06:39:08 <yitz> yaymukund: also the ] needs to be indented more because of the do block.
06:39:22 <albeit> With lens, how I can I do "foo <- _bar <$> gets _baz", where _baz is a record field of the state we are in, and _bar is a record field of _baz?
06:40:39 <nbouscal> foo <- ask $ baz.bar
06:40:43 <nbouscal> (i think)
06:40:52 <nbouscal> wait, sorry, use $ ask.baz.bar
06:41:02 <nbouscal> foo <- use $ ask.baz.bar
06:41:02 <yitz> albeit: nothing special about lens here. just foo <- gets $ _bar . _baz
06:42:02 <yitz> nbouscal: if it's a reader and not a state, you would use asks $ _bar . _baz
06:42:52 <albeit> yitz: Thanks
06:47:06 <albeit> If I am checking a conditional within a stateful computation with a function like :: FooState Bool, is there any way to incorporate that Bool value into a when/unless statement in another stateful function?
06:47:38 <albeit> Right now I'm just doing "cond <- getCond; when (foo && bar && cond) ...."
06:48:19 * ski annotated <http://lpaste.net/5940055859039043584> with "further refactoring"
06:48:22 <ski> Nik05 ^
06:48:45 <yitz> albeit: that's usually the right thing to do.
06:50:39 <albeit> Okay
06:52:48 <wlhlm> Hi, can I force cabal to install a package despite of unmet dependencies?
06:53:25 <albeit> Another thing, just for style, what is "better"? "foo <- g <$> bar" or "b <- bar; let foo = g b"?
06:54:35 <madjestic> wlhlm: that would not have much sense, would it?  Unsatisfied dependencies mean that compiler will be unable to link stuff and therefore unable to compile the package.
06:56:54 * ski annotated <http://lpaste.net/5940055859039043584> with "an alternative"
06:56:58 <ski> Nik05 ^
06:57:34 <ski> Nik05 : ok, that was what i had in mind ..
06:59:49 <wlhlm> madjestic: My problem is with the version of a dependency. The package might work with the newer dependency, but simply hasn't been updated, so I thought that I could at least try it.
07:00:12 <ski> Nik05 : now, with your "First revision", since you use patterns like  'I':r  rather than  'I':_:r  , you won't drop the character following the initial `I',`W' or `E' -- i'm not sure whether this is what you wanted -- i was assuming that your original `drop 2 s' was correct (so dropping both the `I'/`W'/`E' character, *and* the following one (if any, though there must be one, or `parseTime' will fail))
07:00:34 <madjestic> wlhlm: you could download the source, hack the .cabal file (loosen the dependency)
07:00:49 <madjestic> and then run cabal istall in the root cabal dir
07:00:56 <ski> Nik05 : otherwise, moving the `Maybe' outside of the tuple type is what i would have suggested as well (and in fact did)
07:01:11 <wlhlm> (I'm trying to install ghc-vis with ghc-7.8)
07:01:30 <wlhlm> madjestic: ok, I try it...
07:02:12 <madjestic> wlhlm: that may work, or you will see more stuff broken (if the dependency range is justified)
07:05:30 <ski> Nik05 : for your "Second revision", i see you unfolded `parseTime' into `parseMessage', which works fine (at least if you don't introduce the state monad to remove some more boilerplate)
07:07:19 <ski> Nik05 : also i see you changed from `String -> Maybe (...,String)' to `String -> [(...,String)]' (which would then correspond to `StateT String [] (...)') for correspondence with the type of `reads' -- this is fine
07:07:22 <Maxdamantus> So, it turns out the 172557488054163490617032809th string is "hello".
07:07:51 <yaymukund> yay! I did it and refactored my multi-line list comprehension into a single line
07:07:58 <Maxdamantus> and the 172557488054163490617032809th list of strings is [["\157315","\2497","\STX","","",""],["\1559","!","\NUL","",""],["\NUL","","\NUL","",""],["","","",""],[""],[],[""]]
07:08:03 <ski> Nik05 : however, in both your first and second revision, you have forgotten the final `drop 1' on the remaining input -- perhaps this was intended, i don't know
07:09:28 <supki> wlhlm: latest cabal-install has --allow-newer
07:11:03 <wlhlm> supki: that sounds interestings, I'll try!
07:17:33 <Nik05> ski guess its a bug
07:19:13 <yitz> Maxdamantus: looks like a list of list of strings to me
07:20:20 <Nik05> ski im going to preprarw food now, will read your annotations after eating. thanks for all tje help
07:23:09 <Maxdamantus> yitz: er, yes, list of list of strings.
07:23:37 <Maxdamantus> and actually, that was assuming people start counting from 0 .. which they don't, unfortunately.
07:24:32 <yitz> > let fromRadix b = sum . zipWith (*) (iterate (*b) 1); c = fromIntegral $ length [(minBound :: Char)..maxBound] in fromRadix c $ map (fromIntegral . fromEnum) "hello" -- Maxdamantus, my count is different
07:24:33 <lambdabot>  171016796159495393330397288
07:25:46 * ski annotated <http://lpaste.net/5940055859039043584> with "using the list monad instead of the `Maybe' monad (under `StateT String')"
07:25:47 <wlhlm> supki: thank you very much, it worked!
07:25:49 <ski> Nik05 ^
07:26:02 <Maxdamantus> Your one is probably wrong.
07:26:13 <Maxdamantus> *Count> fromPos 172557488054163490617032809 :: String
07:26:13 <Maxdamantus> "hello"
07:27:06 <Maxdamantus> (counting from "", "\0", "\1", "\2", ..)
07:27:52 <Maxdamantus> are you sure you're including the strings of length 4 and less?
07:28:00 * Maxdamantus tries to understand the formula.
07:30:29 <Maxdamantus> Yeah, you're not.
07:30:44 <Maxdamantus> You're calculating how far "hello" is away from "\0\0\0\0\0"
07:31:02 <Maxdamantus> *Count> toPos "hello" - toPos "\0\0\0\0\0"
07:31:03 <Maxdamantus> 171016796159495393330397288
07:31:30 <yitz> > let toRadix b = map (`mod` b) . takeWhile (>0) . iterate (`div` b); c = fromIntegral $ length [(minBound :: Char)..maxBound] in map (toEnum . fromIntegral) $ toRadix c 171016796159495393330397288 :: String -- Maxdamantus, no it looks right
07:31:32 <lambdabot>  "hello"
07:31:58 <Maxdamantus> It's easy to demonstrate that it's wrong.
07:32:06 <Maxdamantus> > let fromRadix b = sum . zipWith (*) (iterate (*b) 1); c = fromIntegral $ length [(minBound :: Char)..maxBound] in fromRadix c $ map (fromIntegral . fromEnum) "\0\0\0\0\0"
07:32:08 <lambdabot>  0
07:32:11 <yitz> > fromEnum (maxBound :: Char) -- perhaps this is the reason we differ
07:32:13 <lambdabot>  1114111
07:32:21 <Maxdamantus> "\0\0\0\0\0" isn't the first string.
07:32:21 <ski> @let fromRadixYitz b = sum . zipWith (*) (iterate (*b) 1); c = fromIntegral $ length [(minBound :: Char)..maxBound]
07:32:23 <lambdabot>  Defined.
07:32:24 <Maxdamantus> "" is.
07:32:39 <yitz> Maxdamantus: ah i see
07:35:48 <yitz> > let fromRadix b = sum . zipWith (*) (iterate (*b) 1); c = fromIntegral $ length [(minBound :: Char)..maxBound]; bump (x:xs) = succ x : xs in fromRadix c . map (fromIntegral . fromEnum) $ bump "hello"
07:35:50 <lambdabot>  171016796159495393330397289
07:36:04 <dottedmag> :t bump
07:36:05 <lambdabot> Not in scope: ‘bump’
07:36:14 <dottedmag> ah, right.
07:36:50 <yitz> > let fromRadix b = sum . zipWith (*) (iterate (*b) 1); c = fromIntegral $ length [(minBound :: Char)..maxBound]; bump (x:xs) = succ x : xs in fromRadix c . map (fromIntegral . fromEnum) $ bump "\0\0"
07:36:52 <lambdabot>  1
07:37:17 <yitz> hmm. i guess i need to bump the end, which is the high-order digit
07:37:48 <yitz> > let fromRadix b = sum . zipWith (*) (iterate (*b) 1); c = fromIntegral $ length [(minBound :: Char)..maxBound]; bump xs = init xs ++ [succ $ last xs] in fromRadix c . map (fromIntegral . fromEnum) $ bump "\0\0"
07:37:49 <lambdabot>  1114112
07:37:55 <yitz> > let fromRadix b = sum . zipWith (*) (iterate (*b) 1); c = fromIntegral $ length [(minBound :: Char)..maxBound]; bump xs = init xs ++ [succ $ last xs] in fromRadix c . map (fromIntegral . fromEnum) $ bump "\0"
07:37:57 <lambdabot>  1
07:38:07 <yitz> > let fromRadix b = sum . zipWith (*) (iterate (*b) 1); c = fromIntegral $ length [(minBound :: Char)..maxBound]; bump xs = init xs ++ [succ $ last xs] in fromRadix c . map (fromIntegral . fromEnum) $ bump "hello"
07:38:09 <lambdabot>  172557486671275688790917224
07:38:40 <Maxdamantus> "\0\0" should be 1114113
07:39:38 <yitz> > let toRadix b = map (`mod` b) . takeWhile (>0) . iterate (`div` b); c = fromIntegral $ length [(minBound :: Char)..maxBound]; unbump xs = init xs ++ [pred $ last xs] in unbump . map (toEnum . fromIntegral) $ toRadix c 172557486671275688790917224 :: String
07:39:40 <lambdabot>  "hello"
07:42:38 <yitz> > let fromRadix b = sum . zipWith (*) (iterate (*b) 1); c = fromIntegral $ length [(minBound :: Char)..maxBound]; bump xs = init xs ++ [succ $ last xs] in (+1) . fromRadix c . map (fromIntegral . fromEnum) $ bump "hello"
07:42:40 <lambdabot>  172557486671275688790917225
07:43:20 <yitz> > let toRadix b = map (`mod` b) . takeWhile (>0) . iterate (`div` b); c = fromIntegral $ length [(minBound :: Char)..maxBound]; unbump xs = init xs ++ [pred $ last xs] in unbump . map (toEnum . fromIntegral) . toRadix c . subtract 1 $ 172557486671275688790917225 :: String
07:43:22 <lambdabot>  "hello"
07:43:29 <yitz> Maxdamantus: do we agree now?
07:43:36 <Maxdamantus> No.
07:43:51 <Maxdamantus> It should be 172557488054163490617032809.
07:44:34 <yitz> Maxdamantus: what's wrong with my algoritm now?
07:44:45 <Maxdamantus> I don't know.
07:44:50 <Maxdamantus> > let toRadix b = map (`mod` b) . takeWhile (>0) . iterate (`div` b); c = fromIntegral $ length [(minBound :: Char)..maxBound]; unbump xs = init xs ++ [pred $ last xs] in unbump . map (toEnum . fromIntegral) . toRadix c . subtract 1 $ 0 :: String
07:44:51 <lambdabot>  "*Exception: Prelude.init: empty list
07:45:40 <corgifex> > let toRadix b = map (`mod` b) . takeWhile (>0) . iterate (`div` b); c = fromIntegral $ length [(minBound :: Char)..maxBound]; unbump xs = init xs ++ [pred $ last xs] in unbump . map (toEnum . fromIntegral) . toRadix c . subtract 1 $ 1 :: String
07:45:42 <lambdabot>  "*Exception: Prelude.init: empty list
07:45:49 <yitz> Maxdamantus: i'm skipping the empty string, and adding one to the count.
07:46:12 <yitz> > let toRadix b = map (`mod` b) . takeWhile (>0) . iterate (`div` b); c = fromIntegral $ length [(minBound :: Char)..maxBound]; unbump xs = init xs ++ [pred $ last xs] in unbump . map (toEnum . fromIntegral) . toRadix c . subtract 1 $ 1 :: String
07:46:13 <exicer> I'm trying to use the inClass function in attoparsec. I want to include a-z, A-Z, -, and '
07:46:13 <lambdabot>  "*Exception: Prelude.init: empty list
07:46:19 <yitz> > let toRadix b = map (`mod` b) . takeWhile (>0) . iterate (`div` b); c = fromIntegral $ length [(minBound :: Char)..maxBound]; unbump xs = init xs ++ [pred $ last xs] in unbump . map (toEnum . fromIntegral) . toRadix c . subtract 1 $ 2 :: String
07:46:20 <Maxdamantus> I'd just use the first function you had and the binomial theorem to figure out how many elements there are before the strings with that length.
07:46:21 <lambdabot>  "\NUL"
07:46:22 <exicer> I can't get - or ' to be included, however.
07:46:49 <Maxdamantus> "\NUL" should be 1, not 2.
07:47:17 <yitz> Maxdamantus: my claim is that you are just reinventing radix notation by doing so.
07:47:19 <corgifex> exicer: inClass "-'a-zA-Z"
07:47:33 <exicer> corgifex: This is what I have.. maybe I'm making some other mistake
07:47:35 <yitz> Maxdamantus: why? "" is 1, "\0" is 2.
07:47:48 <Maxdamantus> If you're counting from 1.
07:48:02 <Maxdamantus> but I suspect using that recursively is what's making it wrong.
07:48:29 <Maxdamantus> Oh, maybe it's not recursive.
07:48:32 <exicer> corgifex: It works for ', but not -
07:49:26 <hunt> when i try and install ghc-mod with Library-Profiling: True, ghc segfaults
07:49:39 <Maxdamantus> yitz: keep in mind that you have to distinguish between "\0\1" and "\1"
07:49:42 <hunt> i do this because im trying to cabal install world --reinstall, because i wanted to profile my project
07:49:56 <hunt> and in haskell when you want to prolfile your project you have to reinstall every library
07:50:02 <yitz> > let fromRadix b = sum . zipWith (*) (iterate (*b) 1); c = fromIntegral $ length [(minBound :: Char)..maxBound]; bump xs = init xs ++ [succ $ last xs] in (+1) . fromRadix c . map (fromIntegral . fromEnum) $ bump "\1"
07:50:04 <lambdabot>  3
07:50:08 <yitz> > let fromRadix b = sum . zipWith (*) (iterate (*b) 1); c = fromIntegral $ length [(minBound :: Char)..maxBound]; bump xs = init xs ++ [succ $ last xs] in (+1) . fromRadix c . map (fromIntegral . fromEnum) $ bump "\0\1"
07:50:10 <lambdabot>  2228225
07:50:11 * hackagebot constrained-normal 1.0.2 - Normalised Deep Embeddings for Constrained Type-Class Instances  http://hackage.haskell.org/package/constrained-normal-1.0.2 (NeilSculthorpe)
07:50:14 <corgifex> exicer: according to the source it should work
07:50:24 <yitz> > let fromRadix b = sum . zipWith (*) (iterate (*b) 1); c = fromIntegral $ length [(minBound :: Char)..maxBound]; bump xs = init xs ++ [succ $ last xs] in (+1) . fromRadix c . map (fromIntegral . fromEnum) $ bump "\1\0"
07:50:26 <lambdabot>  1114114
07:50:49 <exicer> corgifex: Hmm. I'm pretty sure I'm doing something stupid then, but I can't work out what.
07:55:11 * hackagebot request-monad 0.2.0.0 - A transformer for generic requests  http://hackage.haskell.org/package/request-monad-0.2.0.0 (nahiluhmot)
07:55:47 <yitz> > let fromRadix b = sum . zipWith (*) (iterate (*b) 1); c = 1 + fromIntegral $ length [(minBound :: Char)..maxBound]; bump xs = init xs ++ [succ $ last xs] in (+1) . fromRadix c . map (fromIntegral . fromEnum) $ bump "hello"
07:55:48 <lambdabot>  No instance for (GHC.Show.Show a0)
07:55:49 <lambdabot>    arising from a use of ‘M683932260141974608026375.show_M6839322601419746080...
07:55:49 <lambdabot>  The type variable ‘a0’ is ambiguous
07:55:49 <lambdabot>  Note: there are several potential instances:
07:55:49 <lambdabot>    instance [safe] GHC.Show.Show
07:56:09 <yitz> > let fromRadix b = sum . zipWith (*) (iterate (*b) 1); c = (+1) . fromIntegral $ length [(minBound :: Char)..maxBound]; bump xs = init xs ++ [succ $ last xs] in (+1) . fromRadix c . map (fromIntegral . fromEnum) $ bump "hello"
07:56:11 <lambdabot>  172558106205691110052921878
07:56:50 <yitz> no it was right the first time.
07:58:00 <yitz> > let fromRadix b = sum . zipWith (*) (iterate (*b) 1); bump xs = init xs ++ [succ $ last xs]; toNum :: Char -> String -> Integer; toNum c = (+1) . fromRadix ((+1) . fromIntegral $ fromEnum c) . map (fromIntegral . fromEnum) . bump in toNum maxBound "hello"
07:58:02 <lambdabot>  172557486671275688790917225
07:58:30 <yitz> > let fromRadix b = sum . zipWith (*) (iterate (*b) 1); bump xs = init xs ++ [succ $ last xs]; toNum :: Char -> String -> Integer; toNum c = (+1) . fromRadix ((+1) . fromIntegral $ fromEnum c) . map (fromIntegral . fromEnum) . bump in toNum '\2' "\0\0"
07:58:32 <lambdabot>  4
08:11:02 <yitz> Maxdamantus: ok found the bug. since i'm succ'ing the hi-order digit, i'm not counting strings whose last character is maxBound.
08:11:52 * Maxdamantus will probably contribute his general mechanism for it as his first hackage package.
08:12:16 <yitz> Maxdamantus: go for it!
08:13:12 <Maxdamantus> Bijections between possibly infinite ranges of natural numbers and anything reducable to finite/non-finite sum/product types.
08:13:37 <Maxdamantus> Found a similar library on hackage that did it, but only for finite ones.
08:13:43 <benzrf> :t optional
08:13:44 <lambdabot> Alternative f => f a -> f (Maybe a)
08:13:49 <benzrf> @src optional
08:13:49 <lambdabot> optional v = Just <$> v <|> pure Nothing
08:13:52 <benzrf> interesting
08:13:53 <Maxdamantus> and another similar library that generated a list of values for countable types.
08:13:54 <yitz> Maxdamantus: cool - general diagonalization.
08:14:06 <benzrf> :t (&)
08:14:07 <lambdabot> a -> (a -> b) -> b
08:14:09 <yitz> Maxdamantus: that package could actully be useful in practice.
08:14:13 <Maxdamantus> It only does diagonalisation when both types in the product are infinite.
08:15:41 <yitz> @check \ f x -> (f $ x) == (x & f) -- benzrf
08:15:43 <lambdabot>  <hint>:1:66:
08:15:43 <lambdabot>  parse error (possibly incorrect indentation or mismatched brackets)
08:15:51 <yitz> @check \ f x -> (f $ x) == (x & f)
08:15:53 <lambdabot>  can't find file: L.hs
08:16:02 <yitz> huh?
08:16:33 <Maxdamantus> I was actually thinking about it as a possible form of program optimisation.
08:16:33 <yitz> that just worked a minute ago. did someone redefine something?
08:16:42 <Maxdamantus> but only for finite types.
08:16:52 <yitz> @undef
08:16:53 <lambdabot> Undefined.
08:16:56 <yitz> @check \ f x -> (f $ x) == (x & f)
08:16:57 <lambdabot>  +++ OK, passed 100 tests.
08:17:06 <benzrf> sweet
08:17:20 <Maxdamantus> er, types with finite numbers of values.
08:17:21 <benzrf> wait, how does QuickCheck create arbitrary functions O.O
08:18:01 <Maxdamantus> I think it's just Haskell picking a type.
08:18:08 <Maxdamantus> NoMonomorphismRestriction, maybe.
08:18:15 <lwm> lambdabot is heroic
08:18:15 <yitz> @check \ f x y -> f x y == flip f x y
08:18:16 <davnils> @check undefined
08:18:17 <lambdabot>  +++ OK, passed 100 tests.
08:18:18 <lambdabot>  No instance for (Test.QuickCheck.Property.Testable prop0)
08:18:18 <lambdabot>  arising from a use of ‘Lambdabot.Plugin.Haskell.Check.ShowQ.myquickcheck’ Th...
08:18:38 <benzrf> @check \ f x y -> f x y == flip f x y
08:18:39 <yitz> benzrf: i don't know, but it actually doesn't seem very usefull...
08:18:40 <lambdabot>  +++ OK, passed 100 tests.
08:18:42 <benzrf> uwot
08:18:51 <benzrf> @check \ f x y -> f x y == flip f y x
08:18:53 <lambdabot>  +++ OK, passed 100 tests.
08:18:56 <benzrf> eesh
08:18:57 <yitz> benzrf: it could be every function is const ()
08:19:01 <benzrf> yuck
08:19:08 <benzrf> @check \ f x y -> f x y == ()
08:19:10 <lambdabot>  +++ OK, passed 100 tests.
08:19:13 <benzrf> ahah
08:19:17 <benzrf> @check \ f x y -> f x y == 3
08:19:19 <lambdabot>  *** Failed! Falsifiable (after 1 test):
08:19:19 <lambdabot>  <() -> () -> Integer> () ()
08:19:22 <yitz> hehe
08:19:23 <benzrf> :^)
08:19:49 <benzrf> my guess is the const () is the default
08:19:57 <benzrf> >tfw defaulting typeclasses
08:20:10 <yitz> right, perhaps it's using djinn
08:20:17 <yitz> *or perhaps
08:20:22 <Maxdamantus> It won't be using Djinn.
08:20:47 <Maxdamantus> There'll be things in QuickCheck to generate certain functions.
08:21:22 <yitz> Maxdamantus: if it's a standard quickcheck thing, then right. but perhaps this is something that was set up just for lambdabot, where using djinn is easy.
08:21:38 <benzrf> im a fan of octopress's css for code samples
08:21:41 <benzrf> god damn thats pretty
08:22:13 <yitz> @. djinn type (.) (.) (.) (.)
08:22:14 <lambdabot> f a b c d e = a b c (d e)
08:24:23 <Maxdamantus> @djinn () -> () -> Integer
08:24:23 <lambdabot> Error: Undefined type Integer
08:24:52 <benzrf> @djinn () -> () -> Int
08:24:53 <lambdabot> Error: Undefined type Int
08:24:55 <benzrf> @djinn () -> () -> ()
08:24:56 <lambdabot> f _ a = a
08:25:16 <yitz> @djinn a -> a -> a
08:25:16 <lambdabot> f _ a = a
08:25:23 <yitz> @djinn a -> b -> a
08:25:24 <lambdabot> f a _ = a
08:25:42 <benzrf> @. djinn type const
08:25:43 <lambdabot> f a _ = a
08:25:46 <benzrf> @. djinn type id
08:25:47 <lambdabot> f a = a
08:25:54 <benzrf> @. djinn type (>>)
08:25:55 <lambdabot> f a b = a >>= (\ _ -> b)
08:25:57 <stephenmac7> Are there any project-based tutorials to Haskell like http://en.wikibooks.org/wiki/Write_Yourself_a_Scheme_in_48_Hours that don't require me to know scheme?
08:25:59 <benzrf> o=
08:26:08 <benzrf> stephenmac7: scheme is super simple tho
08:26:28 <sveit> is it more "optimizable" by to select a funtion based on a bool-like newtype or on a binary algebraic type? note that these are equivalent. this is easier to describe in code so i have a small example here: http://lpaste.net/263847322826309632 . please take a look, promise it's short :)
08:26:41 <benzrf> stephenmac7: 1. all syntax is either a simple value literal such as a number or string, or else a list (like this since scheme is a lisp)
08:26:57 <ajcoppa> stephenmac7: a number of us recommend brent yorgey's CIS 194 course, which has a number of projects to practice things you're learning. http://www.seas.upenn.edu/~cis194/lectures.html
08:27:16 <benzrf> stephenmac7: when a value is QUOTED, evaluation is suppressed. i.e. 'foo is the symbol foo, while foo is whatever is stored in the variable foo
08:27:30 <benzrf> stephenmac7: a list is evaluated by applying the first item to the rest of the items
08:27:33 <benzrf> stephenmac7: now you know scheme
08:27:48 <benzrf> ;)
08:28:25 <stephenmac7> benzrf: Then why is "The Little Schemer" so long?
08:28:36 <yitz> benzrf: one other thing: here's a supply of these, you'll need lots of them: (((((((((((((((((((())))))))))))))))))))
08:28:55 <benzrf> stephenmac7: cuz it teaches you the usage of the language
08:29:11 <benzrf> stephenmac7: i could describe ADTs, pattern matching, functions, and typeclasses in 20-30 minutes
08:29:18 <benzrf> stephenmac7: doesnt mean youll understand haskell
08:29:27 <benzrf> or my explanations :-)
08:29:40 <stephenmac7> benzrf: I already read LYAH all the way through
08:29:48 <benzrf> (define func (lambda (arg1 arg2) (add arg1 arg2)))
08:30:02 <benzrf> ^define is a special form that does not evaluate its first argument
08:30:06 <stephenmac7> But I still don't feel like I grasp it, which is why I want to use some project-based thing
08:30:12 <benzrf> so func is treated as a symbol and not resolved
08:30:19 <benzrf> (func 1 2)
08:30:21 <benzrf> ^ results in 3
08:30:27 <stephenmac7> Oh, I see.
08:30:27 <benzrf> assuming 'add' is the addition function
08:30:29 <dottedmag> stephenmac7: describing git blobs, trees, commits and refs would take 20 minutes. Mastering git is much harder.
08:30:36 <benzrf> dottedmag++
08:30:43 <benzrf> stephenmac7: '(foo bar (1 2))
08:30:49 <benzrf> stephenmac7: that's a literal list
08:30:51 <yitz> it's not. (+ arg1 arg2)
08:30:56 <benzrf> stephenmac7: since it's quoted, eval is suppressed
08:30:56 <dottedmag> Same for scheme
08:31:07 <stephenmac7> So, bar is... what?
08:31:12 <benzrf> stephenmac7: the result of '(foo bar (1 2)) is '(foo bar (1 2))
08:31:14 <stephenmac7> An argument to foo?
08:31:14 <eyebloom> rwbarton
08:31:16 <benzrf> foo and bar are symbols
08:31:43 <rwbarton> sveit: Bool is already an algebraic type with two values, so defining your own such vs using a newtype should make essentially no difference
08:31:47 <benzrf> stephenmac7: the key thing you need to grasp is that there are *symbols*, which are like the syntactic value of a variable
08:31:47 <rwbarton> eyebloom
08:31:52 <eyebloom> rwbarton: The solution to my problems yesterday was to enable the -threaded argument to ghc
08:31:57 <benzrf> stephenmac7: when you put a symbol normally, it is resolved to a value
08:32:04 <benzrf> stephenmac7: when you quote it, you get back the regular symbol
08:32:12 <shapr> Man, I want this for Haskell github projects: http://quickcheck-ci.com/
08:32:20 <eyebloom> rwbarton: Just thought you might like to know.
08:32:32 <benzrf> stephenmac7: some 'functions' evaluate their arguments differently from normal or return differently
08:32:36 <rwbarton> eyebloom: aha, interesting. yes, thanks
08:32:38 <rwbarton> I wonder why
08:32:48 <benzrf> stephenmac7: for example, the define 'function' does not evaluate the symbol that is the first arg
08:32:53 <eyebloom> Well SDL2 is spawning a thread
08:33:05 <eyebloom> There are definitely two running
08:33:06 <benzrf> stephenmac7: and macros in general do not evaluate their arguments, and their return value is spliced into where you put the macro as code
08:33:21 <benzrf> stephenmac7: macros are the 1 big idea that you might have trouble with if you dont know lisp
08:33:24 <benzrf> stephenmac7: the rest i just described :-)
08:33:51 <benzrf> stephenmac7: did you grasp everything i just said, besides possibly macros?
08:33:51 <eyebloom> I also made safe version of the addTimer binding, but I think that was already happening by default
08:33:52 <stephenmac7> benzrf: Okay, I'll see if I can get through the 48 hours thing without reading a book on sheme or lisp
08:33:57 <stephenmac7> benzrf: Yes, I did
08:34:05 <benzrf> stephenmac7: then you should be good for 48 hour scheme :-)
08:34:11 <eyebloom> rwbarton: In any case I appreciate your help.
08:34:13 <benzrf> stephenmac7: and if you give me 5m i may be able to get macros into your head too
08:34:33 <sveit> rwbarton: agreed, but if i have to run functions choosing based on a parameter (either an algebraic datatype or the newtype'd bool), will the compiler inline one "better" than the other? Also isn't Bool stored unboxed, so the newtype will be unboxed as well?
08:35:04 <benzrf> stephenmac7: basically, in lisps such as scheme, all code can be represented as values
08:35:34 <benzrf> stephenmac7: since every kind of operation is just a list of the form/function and its arguments, you can represent the abstract syntax tree using that list, but quoted
08:35:38 <benzrf> stephenmac7: for example
08:35:44 <benzrf> stephenmac7: if i have the code (add 1 2)
08:35:48 <benzrf> stephenmac7: that will evaluate to 3
08:35:53 <benzrf> if i have '(add 1 2)
08:35:58 <benzrf> that will come out to '(add 1 2)
08:36:09 <stephenmac7> So, ' makes it not evaluate?
08:36:13 <benzrf> yeah
08:36:23 <benzrf> stephenmac7: imagine if in haskell you could apply functions like {func, arg1, arg2}
08:36:27 <corgifex> '... is syntactic sugar for (quote ...)
08:36:34 <benzrf> stephenmac7: then you could represent application with [func, arg1, arg2]
08:36:46 <benzrf> stephenmac7: and if all operations in haskell were functions, and nothing was anything else
08:36:52 <benzrf> stephenmac7: then that would suffice to represent a program as data
08:37:20 <benzrf> stephenmac7: so you could write a haskell function that takes a list of lists of functions and arguments, and returns a new list of lists of functions and arguments
08:37:23 <triliyn> benzrf: you can't have a function and its arguments in the same list, usually
08:37:33 <benzrf> triliyn: we're forgetting the type system for now :p
08:37:50 <benzrf> stephenmac7: you could parse a program to a list, pass it through this hypothetical function, then use the result as the program
08:37:57 <benzrf> stephenmac7: this language is really lisp, not haskell
08:38:01 <benzrf> and that function is a macro
08:38:18 <stephenmac7> benzrf: Ah, that's cool.
08:38:23 <benzrf> stephenmac7: actually, you can do something like this in haskell too using template haskell
08:38:35 <benzrf> but it's a bit clunky and not very pleasant to work with
08:38:38 <stephenmac7> So, a macro is like your hypothetical list which can be evaluated later
08:38:50 <benzrf> stephenmac7: a macro is a function that transforms an AST into a new AST
08:38:59 <benzrf> stephenmac7: since a lisp AST is almost exactly the same as the actual syntax
08:39:05 <benzrf> it's trivial to write AST manipulators in lisp
08:39:14 <benzrf> stephenmac7: in lisp, code is just lists
08:39:25 <benzrf> so you can write list-manipulating functions that operate on code and make new code
08:39:27 <stephenmac7> Okay, that makes sense.
08:39:31 <corgifex> and like PHP "arrays", Lisp "lists" aren't
08:39:33 <bitemyapp> benzrf: don't forget to mention how infrequently useful or nice this is.
08:39:36 <benzrf> heh
08:39:37 <stephenmac7> So, it's like metaprogramming
08:39:38 <corgifex> (they're trees)
08:39:50 <bitemyapp> stephenmac7: a limited form of compile-time metaprogramming.
08:40:06 <benzrf> stephenmac7: in most lisps, you can stick a macro in the middle of another expression
08:40:11 <benzrf> and it will be resolved at compile time
08:40:18 <yitz> corgifex: in PHP: (they're messes)
08:40:19 <bitemyapp> stephenmac7: it's not runtime metaprogramming that allows you to make behavior contingent on values nor is it dependent typing that allows compile-time type dependency or metaprogramming against runtime values.
08:40:48 <bitemyapp> stephenmac7: I'm an ex-Lisper, macros are good to know but in the maslow hierarchy of shit that matters for programming, only of real importance to library authors trying to offer a boilerplate escape hatch.
08:41:11 <bitemyapp> stephenmac7: laziness subsumed 85%++ of what I used macros for.
08:41:11 <benzrf> macros are *excellent* at getting rid of boilerplate
08:41:32 <bitemyapp> benzrf: still unmatched at that, AFAICT, but less principled than generics.
08:41:41 <benzrf> yeap
08:41:52 <bitemyapp> the problem is that program transformation is a very large maul to attack your problem with.
08:41:53 <benzrf> stephenmac7: anyway, you now know the basic concepts of a simple scheme
08:41:59 <stephenmac7> Okay, thanks.
08:42:03 <benzrf> stephenmac7: congratulations! you may now implement one :-)
08:42:21 <bitemyapp> stephenmac7: just be aware that if you use TH in a library unnecessarily, people will gripe.
08:42:29 <bitemyapp> ..extensively
08:42:37 <stephenmac7> I don't know TH
08:42:45 <cow_2001> :D
08:42:50 <benzrf> template haskell
08:42:54 <benzrf> macros for hs
08:42:55 <cow_2001> where's yitz
08:42:59 <stephenmac7> So, it shouldn't be an issue. Plus, it seems macros are more commonly use in lisp than TH in haskell
08:43:06 <benzrf> yes!
08:43:08 <benzrf> they aare
08:43:18 <benzrf> for 1, th is an extension
08:43:23 <stephenmac7> Maybe haskell just doesn't need it as much, due to some nice design decisions in the normal language
08:43:25 <benzrf> not a core feature
08:43:39 <benzrf> stephenmac7: yea
08:43:48 <benzrf> stephenmac7: well
08:43:51 <benzrf> more like it doesnt fit as well
08:44:15 <benzrf> macros can do some cool shit but they aren't particularly orthogonal with the rest of haskell
08:44:40 <bitemyapp> 'ish.
08:44:51 <benzrf> wait
08:44:52 <bitemyapp> There are things I know I can do in TH that I don't know how to do anywhere else in Haskell.
08:44:55 <benzrf> i misused orthogonal maybe
08:44:58 <bitemyapp> you did.
08:45:01 <bitemyapp> it's okay.
08:45:03 <benzrf> shit >.<
08:45:09 <benzrf> i keep misusing terms
08:45:21 <bitemyapp> it's okay.
08:45:25 <benzrf> yesterday it was affirming the antecedent, today it's orthogonal
08:45:36 <benzrf> keep an eye out for future errors =o
08:45:52 <stephenmac7> Okay, thanks. I have to go now though.
08:46:45 <benzrf> k
08:47:30 <rwbarton> sveit: there is no special treatment of Bool
08:48:15 <rwbarton> sveit: the only differences between your two code samples are (1) the second uses == rather than pattern matching, hopefully the compiler can optimize this to a pattern match
08:49:35 <sveit> rwbarton: ok, so when/if the compiler optimizes it to a pattern match, will it also optimize it within a "loop" so that the test to choose which function to call is performed only once?
08:49:44 <sveit> rwbarton: or is there a way to get it to do that?
08:49:58 <rwbarton> and (2) the first introduces new constructors A and B, these will add a tiny amount to the size of your program, and possibly add a bit to the working set of your program if it uses both Bool and Sel a lot
08:50:11 <rwbarton> that sounds like a totally different question
08:50:25 <sveit> rwbarton: that's the follow-up :)
08:50:47 <rwbarton> I would have to see the loop to guess
08:50:58 <sveit> rwbarton: the first question was basically motivated by the last section of http://www.haskell.org/haskellwiki/Performance/Data_Types
08:51:14 <sveit> rwbarton: trying to figure out if that is still relevant
08:51:40 <benzrf> bbiab
09:10:22 * hackagebot wai-handler-webkit 3.0.0 - Turn WAI applications into standalone GUIs using QtWebkit.  http://hackage.haskell.org/package/wai-handler-webkit-3.0.0 (MichaelSnoyman)
09:17:16 <benzrf> hmmmm
09:20:08 <benzrf> arent sum/product types more accurately represented with ∪/× rather than +/*
09:21:14 <nbouscal> benzrf: i don't think choice of notation can really be 'accurate'. conventional, maybe, but depends on whose conventions
09:29:27 <Fuuzetsu> benzrf: just like it's more conventional to use λ and not \ ;P
09:34:56 <ski> benzrf|offline : i don't think ⌜∪⌝ would be either accurate or conventional for sum types. ⌜∪⌝ is usually used for union, not for disjoint/discriminated union (which is a synonym for sum type)
09:34:57 <Nik05> ski what ae you doing with StateS?
09:35:08 <Nik05> StateT*
09:36:11 <ski> Nik05 : hiding the earlier stuff with `line0',`line1',`line2', and `s0',`s1', so that we don't have to see it
09:36:42 <ski> Nik05 : so that we don't take the risk of accidentally using the wrong version of them in the wrong place
09:36:56 <ski> Nik05 : and also for shortening the code somewhat
09:37:31 <ski> Nik05 : in this case, it's basically only the main body of `parseMessage' which benefits from this -- but in a larger example, the payoff would probably be greater
09:39:34 <Nik05> oh ok, i dont get it. Where can i read more about StateT?
09:40:20 <snyp> Do I have to specify "module A.B.C where ..." if I have a file A/B/C ?
09:40:34 <shachaf> snyp: In GHC, yes.
09:40:45 <snyp> or do I just have to specify "module C where ..." to import the module?
09:40:59 <snyp> shachaf: i see
09:41:11 <snyp> shachaf: why is it like this?
09:41:26 <shachaf> You can include A/B/ in your path of places to look for modules and then you can just import C.
09:41:35 <shachaf> Because people like directory hierarchies for their code.
09:41:49 <snyp> in python, the filename solely determines the module name.
09:42:06 <snyp> so there's no need to write the "module ... where ..." stuff
09:42:14 <snyp> isn't that redundant?
09:43:03 <corgifex> does python have hierarchical modules?
09:43:20 <ski> Nik05 : "What the hell are Monads?" by Noel Winstanley in 1999 at <http://web.cecs.pdx.edu/~antoy/Courses/TPFLP/lectures/MONADS/Noel/research/monads.html>, possibly the first monad tutorial, explains the basic idea of state monads (briefly)
09:44:02 <snyp> corgifex: idk are modules in python not hierarchical?
09:44:28 <corgifex> why are you asking me?! I don't know python!
09:44:34 <ReinH> snyp: No, because you *can* specify a different module name. People just generally don't.
09:45:12 <ReinH> It's just easier to work with when the module name matches the file path and name.
09:45:26 * hackagebot hexif 0.2.0.0 - Reading Exif data form a JPEG file with Haskell  http://hackage.haskell.org/package/hexif-0.2.0.0 (RolandSenn)
09:46:31 <snyp> ReinH: multiple packages, like the container package seem to add to the Data module. So they are stored in a different Data/... file hierarchy, but are still considered to be in the Data namespace(module i mean) right?
09:47:35 <ReinH> snyp: Well, Data isn't a model itself, it's a part of the module hierarchy, which is used as a sort of classification system
09:48:05 <ReinH> A taxonomy of modules, if you will
09:48:13 <corgifex> module names can contain .
09:48:19 <corgifex> the rest is an illusion
09:48:43 <ReinH> Also that.
09:49:00 <ReinH> Although the relationship between name and path isn't quite illusory
09:49:43 <Nik05> thank you ski
09:49:50 <snyp> hmmm
09:50:17 <ski> Nik05 : i could also try to explain more in detail in here .. but perhaps you should first attempt to read that one
09:50:40 <davidthomas> Is there a type that efficiently implements a free group?
09:51:48 <Drezil> Nik05: also http://vimeo.com/73648150 might help
09:53:05 <ski> Nik05 : btw note that what is called `StateT' in that tutorial is nowadays called `State' in Haskell (the `StateT' in current Haskell, which i used, is related to this `State', but slightly more complex)
09:53:56 <ski> (namely, the `StateT' i used is a "monad transformer" counterpart to the "plain" `State' (named `StateT' in that old tutorial))
09:54:33 <ski> (`StateT' being a monad transformer allows me to *combine* the effects of a state monad together with the effects of the `Maybe' monad)
09:59:17 <blochchain> is The Implementation of Functional Programming Languages by SPJ still relevant and worth reading? I just found a copy in my college library and was excited, as I had no idea that he wrote a book like that
09:59:58 <shachaf> It is out of date on various things but still has a lot of useful content.
10:00:17 <shachaf> Well, I didn't actually read it, but I read parts of it.
10:00:28 * hackagebot ghc-vis 0.7.2.3 - Live visualization of data structures in GHCi  http://hackage.haskell.org/package/ghc-vis-0.7.2.3 (DennisFelsing)
10:00:30 * hackagebot vinyl 0.4.1 - Extensible Records  http://hackage.haskell.org/package/vinyl-0.4.1 (JonSterling)
10:00:34 <shachaf> Depending on what you want to get out of the book, e.g. the STG paper and others might be more relevant to you than the book.
10:02:15 <mmmm_> When working with sandboxes, is there an easy way to have multiple sandboxes for the same project? (ie different versions with different dependencies)
10:03:33 <bennofs> mmmm_: you can use --sandbox-config-file and specify --sandbox=.some-sandbox-name when doing cabal sandbox init
10:03:59 <bennofs> mmmm_: so cabal --sandbox-config-file=sandboxA.config init --sandbox=.sandboxA
10:04:18 <bennofs> mmmm_: then, to use it, do cabal --sandbox-config-file=sandboxA.config <some cabal command> ...
10:06:31 <snyp> ReinH: But Data is a folder.. so it is a module right? or is it just a convention?
10:06:57 <snyp> A module name prefix
10:07:35 <ski> it's a convention
10:08:07 <snyp> i see
10:09:50 <mmmm_> bennofs: thanks
10:20:42 <hakujin> can I assume that 'partitionEithers . map fn' will be fused into one pass through the list? or will it be more efficient to write my own based on fold that traverses once? how would I answer this question for myself in the future?
10:22:43 <bergmark> hakujin: looking at the core output might help you
10:23:15 <albeit> Is the fastest way to convert from an Int (123) to a ByteString/Text ("123") just using a pack . show?
10:23:25 <hakujin> bergmark: thanks; I'll check it out.
10:23:44 <bergmark> hakujin: http://stackoverflow.com/questions/6121146/reading-ghc-core
10:24:11 <ReinH> albeit: builder
10:25:10 <albeit> ReinH: Ah, such as Data.Text.Lazy.Builder.Int.decimal?
10:25:21 <zert> hi
10:25:29 <ReinH> albeit: Yep
10:25:32 <hakujin> albeit: ByteString.Char8 provides readInt and readInteger as well. I'm not sure how they benchmark.
10:25:50 <hakujin> in my experience builder is pretty heavy for one off conversions like that
10:25:57 <hakujin> you'll definately want to profile
10:26:15 <albeit> hakujin: Heavy? As in a large package or slow?
10:26:21 <hakujin> albeit: slow
10:26:38 <ReinH> builder amortizes the cost of building larger values
10:26:41 <ReinH> it's not great for single values
10:27:11 <zert> is there any matplotlib-like library for haskell?
10:27:26 <albeit> ReinH: What do you mean by amortizing cost of building larger values? If I'm building a Text out of say 50 integers, Builder will be faster then than pack . show?
10:27:29 <alpounet> zert: Chart ?
10:27:37 <alpounet> @hackage Chart
10:27:37 <lambdabot> http://hackage.haskell.org/package/Chart
10:28:04 <ReinH> albeit: Builder uses a diff-list like intermediate representation for fast concatenation, and then a final conversion to lazy text/bytestring
10:28:33 <ReinH> that final conversion is where you pay the cost, so the more concatenations you do first the, more amortization
10:28:42 <ReinH> s/the,/the
10:28:51 <ReinH> (most of the cost)
10:29:09 <zert> seems very nice! Thanks guys!
10:29:15 <albeit> Ah, and if I did pack . show, its doing the conversion for every single number, which can get costs quick. Is that about right?
10:29:36 <albeit> *costly
10:29:54 <ReinH> so decimal will be quite fast, but toLazyText . decimal might not be
10:29:59 <ReinH> albeit: more or less
10:31:25 <ReinH> As hakujin says, profiling is your friend
10:32:28 <albeit> Okay... but putting you on the spot, if you had to guess, would using a Builder be faster for a Text composed of roughly 20 numbers?
10:35:15 <ReinH> albeit: no idea!
10:35:42 <ReinH> that is exactly the sort of question you answer by profiling ;)
10:35:52 <albeit> Ha okay, shall do
10:40:50 <snyp> how do I import modules in ghci ?
10:41:11 <Nik05> ski i will first try to understand it myself :)
10:41:17 <Drezil> :l System.Environment
10:41:18 <rrradical> snyp: :m + Name
10:41:21 <hakujin> snyp:  :m + Module.Name
10:41:21 <mmachenry> snyp:  "import Data.List"
10:41:25 <Drezil> :D
10:41:29 <snyp> ah
10:41:29 <alpounet> snyp: either with the usual import syntax, or by using :m +ModuleName
10:41:55 <benzrf> snyp: just use import !
10:41:57 <snyp> ok.. thanks
10:42:10 <hakujin> :m - Module.Name works in reverse
10:42:34 <snyp> sorry i was mistaken about some other error and thought usual  imports don't work in ghci
10:44:30 <solidus-river> rawr TypeFamilies! why do you hates me
10:44:36 <solidus-river> i dont have my code with me because i'm @work
10:44:54 <solidus-river> but last night i almost finished up this project iw as working on, but the last module i needed to compile threw a fit about TypeFamilies instances
10:45:07 <benzrf> solidus-river: are you not storing your codes on githob
10:45:09 <Fuuzetsu> HAHA TIME TO REWRITE
10:45:27 <solidus-river> no, but i should be
10:45:28 <solidus-river> benzrf:
10:45:34 <Fuuzetsu> I'm still considering chucking TFs into my new project
10:45:37 <solidus-river> i'll upload it to github tonight to help debug
10:45:54 <solidus-river> it seemed to be assuming every instance of a type declaired inside an instance of my type family was a different instance
10:46:17 <solidus-river> and causing errors all over hte place saying type Type a0 ~ Type a11 problem
10:46:31 <solidus-river> but logically i'm assured that all of those types referenced are from the same instance of the type family
10:46:40 <ski> hakujin : and `export Module.Name' also works in reverse .. ;)
10:46:58 <Fuuzetsu> TFs + FunDeps is the true evi… fun
10:46:58 <solidus-river> so i need to tell ghc to relax i think, got a hunch the answer will eithe rbe flexibleInstances or flexibleContexts
10:47:25 <ski> Fuudepzu
10:47:35 <Fuuzetsu> Fuundepfsu
10:48:18 <Fuuzetsu> people who complain about Haskell compile times probably never have to sit through C++ projects
10:48:57 <solidus-river> Fuuzetsu: people who complain about compile times need to automate their compilation and testing
10:49:00 <solidus-river> :P
10:49:05 <benzrf> my codes cpomiolering!!!!!!MNJJN
10:49:13 <benzrf> holy shit i mangled that
10:49:24 <benzrf> where did that MNJJN even come from wtf
10:49:51 <solidus-river> man, generic object oriented code can really really get shitty
10:50:28 <benzrf> solidus-river: can really really get shitty, or can get really really shitty?
10:51:15 <solidus-river> benzrf: both?
10:54:11 <nbouscal> solidus-river: It sounds like you're maybe running into type families not being injective. If so, you can use data instead of type, that fixes it
10:54:39 <solidus-river> nbouscal: that is exactly it!
10:55:25 <nbouscal> data families can be a little less convenient, so another alternative is to provide ghc with an injectivity proof via a function going the other way. i haven't actually done that myself, but have been told it works
10:55:41 <nbouscal> but if using a data family isn't too inconvenient that's what i'd recommend
10:56:12 <solidus-river> nbouscal: do you have a link to any resources about providing haskell with an injectivity proof just in case?
10:56:18 <solidus-river> not going to be able to mess with this till this afternoon
10:56:27 <nbouscal> it's on stackoverflow somewhere, i've been trying to find it but coming up empty
10:57:02 <solidus-river> cool, I'll keep digging tonight then, good to here there are some solutions to try out that dont involve a big rewrite though
10:57:12 <solidus-river> :)
10:58:43 <nbouscal> solidus-river: here it is http://stackoverflow.com/questions/16926579/incomprehensible-error-message-with-type-families
11:00:05 <nbouscal> also recommends proxy arguments, which is also good, depending on where you're running into the problem
11:01:25 <solidus-river> man, i should learn to be more up front when searching for answers on stack overflow
11:01:36 <solidus-river> that title is great, pretty much what i thought when i first saw the list of errors
11:01:47 <albeit> Is there a way to make a huge list of numbers automatically Int? Say I have "foo = 1 :: Int; bar = 5 :: Int; baz = 6 :: Int". Do I have to type :: Int for all of them?
11:02:00 <solidus-river> nbouscal: thanks!
11:02:13 <nbouscal> solidus-river: np :)
11:04:27 <vanila> albeit, [foo,bar,baz] = [1,5,6]
11:04:53 <rwbarton> or "foo, bar, baz :: Int; foo = 1; ..."
11:08:38 <piezoid> duh... I added tracing everywhere in a working code /o\
11:09:00 <blochchain> someone earlier referred me to "the SPG paper". Can someone link me to it or give me the full title?
11:09:02 <piezoid> I've found operational improvements, at least.
11:09:35 <vanila> blochchain, what was the paper about
11:10:03 <blochchain> functional language implementation, vanila
11:10:11 <vanila> sure ill get the link
11:10:14 <piezoid> blochchain: I think it's this one : http://research.microsoft.com/~simonpj/papers/spineless-tagless-gmachine.ps.gz
11:11:40 <blochchain> thanks piezoid!
11:24:49 <statusfailed> What is the difference between 'operational' and 'free'?
11:25:03 <statusfailed> Maybe in terms of what they can do, because they seem to solve the same problem
11:25:13 <johnw> there is also free-operational
11:25:18 <statusfailed> oh yeah that too
11:25:25 <statusfailed> I found a Haskell Cafe thread about this but I found it hard to follow
11:26:49 <snyp> How can I specify the type of a number literal ?
11:27:00 <johnw> statusfailed: all three should be isomorphic
11:27:05 <vanila> snyp, (3 :: Integer)
11:27:07 <johnw> you may learn a lot abuot them by trying to proof that
11:27:07 <vanila> or whatever type
11:27:12 <snyp> vanila: o
11:27:13 <snyp> thanks
11:27:14 <vanila> > 2 + (1 :: Double)
11:27:15 <lambdabot>  3.0
11:27:16 <vanila> for example
11:27:39 <snyp> i see
11:28:07 <statusfailed> johnw: OK, I think that's my answer :)
11:28:18 <statusfailed> johnw: perhaps proving that might be beyond me, but thanks nonetheless!
11:32:52 <ljosha> trying to install gtk2hs on windows 7 for the nth time
11:32:53 <Flonk> Is there a built-in to convert a hex number (in a String) to an int?
11:33:01 <Flonk> err, decimal
11:33:14 <ljosha> anyone lucky with cabal 1.20 and gtk-2.24?
11:33:30 <ljosha> I get this error: https://github.com/gtk2hs/gtk2hs/issues/26
11:34:53 <jle`> Flonk: read?
11:36:16 <benzrf> @hoogle iteratee M
11:36:18 <lambdabot> package iteratee-compress
11:36:18 <lambdabot> package iteratee-mtl
11:36:18 <lambdabot> package iteratee-stm
11:36:21 <benzrf> oops
11:36:23 <benzrf> @hoogle iterateM
11:36:24 <lambdabot> No results found
11:36:26 <benzrf> hmmmmm.
11:36:28 <benzrf> oh wait
11:36:44 <Flonk> jle`: read doesn't to base conversions.. In other words, I want `f "F0" == 240`
11:36:45 <benzrf> > parse
11:36:47 <lambdabot>  Not in scope: ‘parse’
11:36:48 <benzrf> meh
11:37:09 <jle`> > read "0xF0" :: Int
11:37:11 <lambdabot>  240
11:37:12 <jle`> -- Flonk
11:37:17 <benzrf> :k MaybeT
11:37:18 <lambdabot>     Not in scope: type constructor or class ‘MaybeT’
11:37:18 <lambdabot>     Perhaps you meant ‘Maybe’ (imported from Data.Maybe)
11:37:21 <benzrf> mehh
11:37:25 <Flonk> jle`: Oh, I didn't know that. Cool!
11:37:29 <Flonk> Thanks a lot :)
11:37:43 <jle`> Flonk: it's a hex literal :)
11:38:25 <ski> > (readHex :: ReadS Int) "F0"  -- Flonk
11:38:27 <lambdabot>  [(240,"")]
11:39:13 <Flonk> ski: Ah, that's perfect!
11:39:19 <benzrf> @src asAppliedTo
11:39:20 <lambdabot> Source not found. You type like i drive.
11:39:21 <benzrf> eh
11:39:24 <benzrf> :t asAppliedTo
11:39:25 <lambdabot> (a -> b) -> a -> a -> b
11:39:28 <benzrf> kk
11:39:29 <shachaf> > preview hex "F0"
11:39:33 <lambdabot>  Just 240
11:40:13 <Flonk> :t preview
11:40:14 <lambdabot> MonadReader s m => Getting (First a) s a -> m (Maybe a)
11:40:20 <benzrf> @src somenick
11:40:20 <lambdabot> Source not found. You speak an infinite deal of nothing.
11:40:21 <benzrf> @src some
11:40:21 <lambdabot> some v = some_v
11:40:21 <lambdabot>   where many_v = some_v <|> pure []
11:40:21 <lambdabot>         some_v = (:) <$> v <*> many_v
11:40:23 <benzrf> @src many
11:40:23 <lambdabot> Source not found. You untyped fool!
11:40:38 <Flonk> Ah, Lens
11:40:52 <benzrf> oh lens :^)
11:41:15 <benzrf> > Just 1 <|> Just 2
11:41:17 <lambdabot>  Just 1
11:41:18 <benzrf> ehamberg:
11:41:18 <benzrf> *eh
11:41:42 <ski> > (readInt 16 isHexDigit digitToInt :: ReadS Int) "F0"  -- Flonk
11:41:44 <lambdabot>  [(240,"")]
11:42:24 <ski> > (readInt 15 (\d -> isHexDigit d && tolower d /= 'f') digitToInt :: ReadS Int) "E0"
11:42:26 <lambdabot>  Not in scope: ‘tolower’
11:42:26 <lambdabot>  Perhaps you meant ‘toLower’ (imported from Data.Char)
11:42:31 <ski> > (readInt 15 (\d -> isHexDigit d && toLower d /= 'f') digitToInt :: ReadS Int) "E0"
11:42:33 <lambdabot>  [(210,"")]
11:43:58 <Flonk> ski: Man, Numeric has all sorts of weird functions
11:44:10 <ski> @type readInt
11:44:11 <lambdabot> Num a => a -> (Char -> Bool) -> (Char -> Int) -> ReadS a
11:44:19 <ski> @type showIntAtBase
11:44:20 <lambdabot> (Show a, Integral a) => a -> (Int -> Char) -> a -> ShowS
11:44:22 <shachaf> > review hex 240
11:44:24 <lambdabot>  "f0"
11:44:32 <shachaf> > review (base 24) 240
11:44:33 <lambdabot>  "a0"
11:44:34 <ski> (the former should perhaps really be named `readIntAtBase')
11:44:44 <ski> @index readInt
11:44:45 <lambdabot> Numeric
11:47:03 <oisin640> If anyone has some time, I would love for a more experienced Haskeller to give me a quick code review on the following ~250-ish lines of a linear algebra library: http://lpaste.net/105354
11:48:53 <ski> oisin640 : i'd rather you didn't instance `Show' like that
11:49:28 <oisin640> ski: Should I only use Show for representations of how the type is actually formed?
11:49:33 <oisin640> like... 1 :> 2 :> ...
11:50:23 <ski> either make a proper `Show' instance that generates valid Haskell code (with the appropriate module(s) in scope) (not necessarily in terms of the actual constructors in the representations), that when evaluated yields an equal value
11:50:52 <ski> or define separate `displayVector' and `displayMatrix' functions (or however you want to call them)
11:50:55 <ski> or possibly both
11:51:25 <oisin640> Ah, ok, I will do that - thanks!
11:51:29 <ski> oisin640 : imho, yes -- however, note that it doesn't have to use the actual data constructors
11:51:57 <ski> > listArray (-3,5) [n^3 | n <- [-3 .. 5]]
11:51:59 <lambdabot>  array (-3,5) [(-3,-27),(-2,-8),(-1,-1),(0,0),(1,1),(2,8),(3,27),(4,64),(5,125)]
11:52:09 <ski> > array (-3,5) [(-3,-27),(-2,-8),(-1,-1),(0,0),(1,1),(2,8),(3,27),(4,64),(5,125)]
11:52:11 <lambdabot>  array (-3,5) [(-3,-27),(-2,-8),(-1,-1),(0,0),(1,1),(2,8),(3,27),(4,64),(5,125)]
11:52:50 <oisin640> Ah ok
11:52:57 <ski> oisin640 : that is an example of a `Show' instance that doesn't show the internal implementation, but which still generates valid Haskell code which evaluates to a value equal to the given value
11:53:09 <snyp> I get 'cabal: At least the following dependencies are missing:
11:53:15 <snyp> persistent -any'
11:53:22 <ski> of course, arrays are primitively implemented, so there are no actual constructors to use in this case
11:53:25 <oisin640> ski: But lists are a bit different since you can actually construct them with the [ ... ]. The only thing I have is the data constructor
11:53:26 <snyp> when i run cabal build for the first time in a sandbox
11:53:38 <snyp> i have run cabal update
11:54:02 <benzrf> woo-hoo1
11:54:16 <ski> > M.fromList [(2,"two"),(3,"there"),(5,"five"),(7,"seven")]
11:54:17 <lambdabot>  fromList [(2,"two"),(3,"there"),(5,"five"),(7,"seven")]
11:54:24 <benzrf> i found an Alternative for which many/some is meaningful besides parser B-)
11:54:36 <ski> is an example where there actually is an in-Haskell implementation (which is still not revealed)
11:54:36 <oisin640> ski: Oh, I see
11:55:03 <ski> oisin640 : for your `Vector' and `Matrix', using the data constructors could be fine
11:55:36 <ski> oisin640 : or if you have a (partial) `fromList' function, you could use that, if you prefer
11:56:02 <oisin640> ski: So Show is used in some other context other than just being a pretty printer for the user?
11:56:04 <supki> snyp: cabal build does not install dependencies, you need to run  cabal install --only-dependencies   for that
11:56:11 <ski> oisin640 : also, for efficiency, when explicitly instancing `Show', define `showsPrec' (or at least `shows'), not `show'
11:56:24 <snyp> supki: i see
11:56:38 <dwcook> Am I reading this wrong or are you figuring out the length of a vector from the value when its type already contains the length?
11:56:42 <ski> oisin640 : `showsPrec' is to be preferred, to handle precedence nicely
11:56:54 <oisin640> dwcook: No, I am - those are the things that I'm unsure how to do
11:57:43 <oisin640> ski: Ok, thank you - I didn't know about those two functions
11:58:05 <dwcook> I've actually never bothered figuring out how to do it myself but I think there is a way to get the information straight from the type
11:58:16 <ski> oisin640 : `showParen',`showString',`showChar' are useful functions when implementing `showsPrec'
11:58:25 <oisin640> dwcook: Maybe if I pattern match on (Succ ...) something - that would make more sense, I think.
11:58:34 <ski> (and also for `shows')
11:58:46 <oisin640> I see
11:59:01 <ski> oisin640 : similarly, for `Read', `readParen',`lex' are useful functions when implementing `readsPrec' or `reads'
11:59:42 <oisin640> ski: Are Read and Show usually just dervied?
12:00:03 <dwcook> oisin640: the first thing that comes to mind is a typeclass and an instance for Zero and another for Succ
12:00:22 <oisin640> dwcook: Right - I think I have that with data Natural = ...
12:00:28 <oisin640> Oh
12:00:30 <oisin640> sorry, typeclass
12:03:11 <ozkar> how do i shot web on haskell?
12:03:32 <ski> oisin640 : yes -- but in some cases (with advanced types, like e.g. sometimes GADTs), the deriving doesn't work
12:03:40 <benzrf> ozkar: to shot web u must press yesod
12:03:46 <benzrf> mabey snap???
12:03:53 <ozkar> hahaha, nice.
12:04:12 <ozkar> i actually want to make a website, but i have no time.
12:04:15 <ski> oisin640 : sometimes one can then manually make a sensible instance (possibly with different context than the one the `deriving' mechanism wanted)
12:04:56 <ski> oisin640 : if you can derive `Read' and `Show' for your `Vector' and `Matrix' (assuming you want to have such instances), then you should prefer to do that, to defining them manually
12:05:51 <oisin640> ski: Ok - sorry, one more question. Should I derive Read, Show, etc. for all data types when possible? Or only when necessary?
12:06:02 <ski> depends
12:06:52 <ski> there might be some reason why you don't want to derive it perhaps (one such reason could be that it's impossible to make a sensible instance, e.g. because the data type includes functions or `IO' (or similar) actions, or `IORef's, &c.)
12:07:34 <ski> or perhaps the type is only used internally, and doesn't occur in the types of the exported operations (nor instances for exported types), and so you might not care about it
12:09:10 <oisin640> Ok, that makes sense. Thanks for the explanations!
12:10:24 <ski>   instance Show e => Show (Vector n e)
12:10:26 <kini> question about indentation style: http://lpaste.net/105356
12:10:30 <albeit> If I have a bunch of data constructors "Foo = Foo | Bar | Baz | ...", is there any way to zip them up with a list? Goal is to generate a list like [('A', Foo), ('B', Bar), ('1', Baz), ...] without typing out the constructors twice.
12:10:34 <ski>     where
12:10:48 <ski>     showsPrec _  EmptyVector = showString "EmptyVector"
12:10:55 <albeit> Like "zip "AB1" Foo"
12:11:08 <ski>     showsPrec p (e :> es)    = showParen (p > 9)
12:11:26 <ski>                              $ showsPrec 10 e
12:11:27 <bergmark> kini: for syntax trees i usually go pretty heavy on the parens
12:11:36 <ski>                              . showString " :> "
12:11:39 <rwbarton> albeit: if you derive Enum and Bounded you can write [minBound..maxBound] :: [Foo]
12:11:43 <ski>                              . showsPrec  9 es
12:11:47 <bergmark> kini: looks to me like it would work the way you want
12:12:02 <ski> oisin640 : that would be the proper `Show' instance for `Vector'
12:12:18 <kini> hm, really?
12:12:39 <oisin640> ski: Ok... I think I'll have to go take a look at those shows functions
12:12:54 <ski> oisin640 : `showParen (p > 9)' adds wrapping brackets around the string if needed, i.e. if the precedence of the context exceeds the precedence (`9') of the operator
12:12:55 <kini> so is it like, if parentheses are open, then ghc ignores line breaks and indentation?
12:13:09 <kini> (or, I should say, the haskell standard)
12:13:40 <rwbarton> it doesn't totally ignore them
12:13:57 <ski> oisin640 : because `:>' is `infixr' i only "increment" the precedence for the `showsPrec' call for the left argument `e' of `e :> es', keeping the precedence `9' of the operator `:>' for the right argument `es'
12:14:07 <albeit> rwbarton: Interesting... gonna check it out, will probs be back with a follow up
12:14:22 <oisin640> ski: I see
12:14:25 <ski> oisin640 : in case it had been `infixl', one would instead have incremented the right one, and in case of `infix', one would have incremented both
12:15:08 <snyp> Is there a way I can view the types exported by a module ?
12:15:13 <ski>   showsPrec p (ConsVector e es) = showParen (p > 10)
12:15:23 <snyp> using cabal or something
12:15:23 <ski>                                 $ showString "ConsVector "
12:15:24 <kini> rwbarton: could you elaborate?
12:15:38 <ski>                                 . showsPrec 11 e
12:15:43 <ski>                                 . showChar ' '
12:15:45 <ski>                                 . showsPrec 11 es
12:15:55 <rwbarton> also it doesn't really have anything to do with parentheses
12:16:17 <ski> oisin640 : would be the corresponding defining equation clause, if you had used `ConsVector' instead of `(:>)'
12:16:18 <bergmark> snyp: you can use :browse in ghci
12:16:48 <ski> oisin640 : `10' is the precedence of function (here data constructor) application, and it is left-associative, so we need to increment to `11' for the arguments `e' and `es'
12:16:54 <rwbarton> kini: layout only matters in relation to constructs which introduce layout (do, where, case...of, let). let's take a do block as an example
12:17:22 <snyp> bergmark: i see.
12:17:44 <rwbarton> kini: the syntax for a do block is (let's simplify to just expressions) do { expr1 ; expr2 ; expr3 }
12:17:53 <rwbarton> but we don't usually write the braces or the semicolons
12:18:09 <ski> oisin640 : that's the basic pattern. the idea for `Read' is similar, but somewhat more involved since you have to deal with lists (e.g. using list comprehensions). you can use `lex' to eat the next Haskell token (like an opening bracket, e.g.)
12:18:50 <rwbarton> kini: the rule is, the indentation of expr1 sets a column according to which the rest of your program is judged
12:18:54 <oisin640> ski: Awesome, thank you
12:19:24 <rwbarton> kini: any line that starts in the same column implicitly gets a semicolon added before it. once you start a line in an earlier column, you implicitly get a }
12:19:32 <rwbarton> kini: but beyond that, indentation is totally up to you
12:19:59 <kini> aha. Well that makes indentation a little less mysterious :) thanks, rwbarton
12:20:26 <rwbarton> so in particular, for any expression, you can break it into lines however you like, provided all the lines are more indented than whatever that relevant column is
12:20:33 <ski> oisin640 : there's some examples in the source of some base modules, but i feel a bit to tired to hunt down the exact ones atm
12:21:40 <rwbarton> (which will be the column of the first non-whitespace token after "do", "where", "of" or "let")
12:22:00 <oisin640> ski: That's ok - that's left me witha  bit of reading for awhile
12:24:47 <TallerGhostWalt> I am having trouble getting my files loaded in inferior-haskell-mode
12:25:01 <TallerGhostWalt> using cabal repl cabal-install 1.20.0.2
12:25:18 <TallerGhostWalt> in a sandbox
12:32:07 <tolt> What would be the best way to deal with a Maybe (Maybe a) ? I used applicative with a Maybe a into a funtion that was a -> Maybe a
12:32:40 <corgifex> what is the best way to deal with a [Int]?
12:33:05 <tolt> Haha sorry. What would be the best way to just go to Maybe a?
12:33:30 <corgifex> join
12:33:49 <Flonk> tolt: sounds like you should check out (>>=)
12:33:53 <Flonk> :t (>>=)
12:33:54 <lambdabot> Monad m => m a -> (a -> m b) -> m b
12:33:56 <Tjr> tolt: You could write a function f :: Maybe Maybe a -> Maybe a, but this is really better solved using the category theory stuff in haskell.
12:34:06 <corgifex> what category theory stuff?
12:34:17 <tolt> Awesome! I don't know how I haven't seen that. Join was exactly what I was looking for.
12:34:19 <jle`> tolt: you can use join
12:34:27 <jle`> :t join `asAppliedTo` Nothing
12:34:28 <lambdabot> Maybe (Maybe a) -> Maybe a
12:34:50 <tolt> Thanks jle` and corgifex
12:34:50 * taktoa just saw tolt's response to jle` before jle` had said anything o_O
12:35:14 <corgifex> tolt was replying to me
12:35:17 <jle`> :t (id =<<) `asAppliedTo` Nothing
12:35:18 <lambdabot> Maybe (Maybe b) -> Maybe b
12:35:29 <ski> tolt : if you provide the actual code you're considering, perhaps we can suggest something more appropriately attuned to the code at hand
12:35:33 <taktoa> "[15:32:16] <tolt> Awesome! I don't know how I haven't seen that. Join was exactly what I was looking for.
12:35:33 <taktoa> [15:32:18] <jle`> tolt: you can use join"
12:35:46 <corgifex> taktoa: those are unrelated
12:35:51 <jle`> taktoa: yeah i didn't see that corgifex answered with join already
12:35:51 <taktoa> ah
12:35:59 <jle`> <corgifex> join
12:36:06 <taktoa> that makes more sense
12:36:16 <jle`> causality paradox resolved
12:36:17 <Flonk> taktoa: This is #haskell, statements aren't necessarily evaluated one after the other
12:36:23 <taktoa> lol
12:36:23 <ski> tolt : iow, perhaps there's a nicer what that avoids constructing the `Maybe (Maybe a)' in the first place
12:36:50 <jle`> yeah, situations where you want Maybe (Maybe a) are fairly rare
12:37:11 <ski> s/nicer what/nicer way/
12:37:36 <jle`> if you have a (a -> Maybe a) and a Maybe a, you can use (=<<) to turn an (a -> Maybe a) into a (Maybe a -> Maybe a)
12:37:44 <corgifex> (I've used IO (IO ()) before, though)
12:38:22 <tolt> I have a function from (a -> IO (Maybe b)) and another function (b -> IO (Maybe c))
12:38:42 * ski . o O ( `MaybeT' )
12:39:26 <jle`> @unmtl MaybeT IO
12:39:28 <lambdabot> Plugin `unmtl' failed with: `MaybeT IO' is not applied to enough arguments, giving `/\A. IO (Maybe A)'
12:39:44 <jle`> er
12:39:48 <jle`> @unmtl MaybeT IO a
12:39:48 <lambdabot> IO (Maybe a)
12:39:50 <shachaf> :t \f g -> runMaybeT . ((MaybeT . f) <=< (MaybeT . g))
12:39:51 <lambdabot> Monad m => (b -> m (Maybe a1)) -> (a -> m (Maybe b)) -> a -> m (Maybe a1)
12:40:01 <shachaf> MaybeT is an option but maybe not worth the hassle.
12:40:09 <shachaf> (If you're not using it anyway.)
12:43:14 <Eduard_Munteanu> Is MonadThrow part of a separate package?
12:43:25 <Eduard_Munteanu> The one from Conduit, I mean.
12:45:10 <snyp> http://ideone.com/CHkNMj getting this error
12:45:35 <corgifex> precedence error
12:45:37 <corgifex> add parens
12:45:43 <corgifex> (and put spaces around your operators, dammit)
12:46:11 <snyp> which operator? concat ':' ?
12:46:51 <snyp> hmm.. ok putting parens worked. now i have another error elsewhere.. but that's okay.
12:47:05 <corgifex> I don't know what you mean by concat but it's :
12:47:42 <snyp> yeah
12:49:09 <snyp> now i have this error: http://ideone.com/WQvBKQ dammit
12:51:26 <corgifex> precedence error
12:51:28 <corgifex> add parens
12:51:47 <snyp> ok
13:00:51 * hackagebot handle-like 0.0.0.7 - HandleLike class  http://hackage.haskell.org/package/handle-like-0.0.0.7 (YoshikuniJujo)
13:03:28 <ski> snyp
13:03:30 <ski>   let theClients :: [Client Integer]
13:04:04 <ski>       theClients = [CompanyV "Racoon Software" (199189 :: Integer) ("To develop quality software" :: String)
13:04:13 <ski>                    ,...
13:04:15 <ski>                    ]
13:04:58 <ski> snyp : though you shouldn't need the `String' ascriptions, and possibly not the `Integer' ones either
13:05:10 <Fuuzetsu> what's the lens for applying over all elements of a pair
13:05:19 <ski> instead of
13:05:21 <ski>   putStrLn $ show $ classifyClients theClients
13:05:22 <ski> use
13:05:32 <ski>   putStrLn (show (classifyClients theClients))
13:05:33 <ski> or
13:05:34 <Fuuzetsu> @hoogle (a -> b) -> (a, a) -> (b, b)
13:05:35 <lambdabot> Data.Graph.Inductive.Query.Monad (><) :: (a -> b) -> (c -> d) -> (a, c) -> (b, d)
13:05:36 <lambdabot> Data.Graph.Inductive.Query.Monad mapSnd :: (a -> b) -> (c, a) -> (c, b)
13:05:36 <lambdabot> Data.Graph.Inductive.Query.Monad mapFst :: (a -> b) -> (a, c) -> (b, c)
13:05:38 <ski>   print (classifyClients theClients)
13:05:44 <Fuuzetsu> @hoogle (a, a) -> (a -> b) ->  (b, b)
13:05:44 <lambdabot> Data.Graph.Inductive.Query.Monad (><) :: (a -> b) -> (c -> d) -> (a, c) -> (b, d)
13:05:45 <lambdabot> Data.Graph.Inductive.Query.Monad mapSnd :: (a -> b) -> (c, a) -> (c, b)
13:05:45 <lambdabot> Data.Graph.Inductive.Query.Monad mapFst :: (a -> b) -> (a, c) -> (b, c)
13:05:51 * hackagebot idris 0.9.13.1 - Functional Programming Language with Dependent Types  http://hackage.haskell.org/package/idris-0.9.13.1 (EdwinBrady)
13:06:00 <ski> @type join (***)
13:06:02 <lambdabot> Arrow a => a b c -> a (b, b) (c, c)
13:06:19 <ski> @type \f x -> join (***) f x
13:06:20 <lambdabot> (b -> c) -> (b, b) -> (c, c)
13:06:39 * Fuuzetsu is sure there's a lens way
13:06:59 <ski> @type both
13:07:00 <lambdabot> (Data.Bitraversable.Bitraversable r, Applicative f) => (a -> f b) -> r a a -> f (r b b)
13:07:14 <shachaf> @let import Data.Bitraversable
13:07:15 <lambdabot>  <no location info>:
13:07:15 <lambdabot>      The package (tagged-0.7.2) is required to be trusted but it isn't!
13:07:43 <Fuuzetsu> :t let x = both (undefined :: Int -> ()) (undefined :: (Int, Int)) in x
13:07:45 <lambdabot>     Couldn't match type ‘f1 b1’ with ‘()’
13:07:45 <lambdabot>     Expected type: Int -> f1 b1
13:07:45 <lambdabot>       Actual type: Int -> ()
13:08:33 <ski> > seq (both Just ((),())) ()
13:08:35 <lambdabot>  ()
13:15:06 <snyp> ski: i have a lot of problems in the pasted code.. yeah i know i don't need the ::String suffixes.
13:15:14 <snyp> need to fix them
13:15:57 <ab9rf> grah, more cabal hell
13:16:17 <chrisdone> ab9rf: what's the scenario?
13:16:50 <ab9rf> chrisdone: just the ongoing challenge of getting a solution that works for dozens of packages.  install them in the wrong order and blort
13:17:13 <chrisdone> bitemyapp: -fobject-code is what ghc uses, but ghci uses -fbyte-code by default. but when doing so it doesn't cache any bytecode it generates. loading a big project via -fbyte-code is impractical
13:17:16 <augur> whats the standard regex library in haskell?
13:17:24 <ab9rf> augur: who uses regexs in haskell?
13:17:29 <augur> ab9rf: :p
13:17:58 <chrisdone> augur: i don't think there is one. i always resort to Text.Regex if it's a quickie, but have also used Text.Regex.PCRE.Light for speed
13:18:09 <bitemyapp> chrisdone: okay but how do I force -fobject-code for ghci?
13:18:13 <augur> chrisdone: k
13:18:21 <ab9rf> there are a few regex libs for haskell but they all pretyy much suck
13:18:26 <chrisdone> bitemyapp: :set -fobject-code
13:18:33 <augur> do people just prefer to use parsec?
13:18:35 <chrisdone> or pass it when you start ghci
13:18:43 <ab9rf> augur: or attoparsec
13:18:45 <chrisdone> augur: that's the usual answer
13:18:51 <bitemyapp> chrisdone: danke schön
13:19:07 <bitemyapp> chrisdone: that wasn't explicitly stated in the post, would you be willing to edit it with an example?
13:19:08 <chrisdone> ab9rf: are they particularly novel packages?
13:19:17 <chrisdone> bitemyapp: oh, really? let me see
13:19:20 <ab9rf> augur: a pox on perl and all its progeny for giving people the idea that regexps are useful programming tools
13:19:23 <bitemyapp> chrisdone: you mention the flag, not how it gets set.
13:19:35 <ab9rf> chrisdone: yesod, snap, buildwrapper, scion-browser?  no :)
13:19:38 <bitemyapp> chrisdone: can I set ghci args from the .cabal file?
13:19:50 <augur> ah. i just need to do /^(.*)\|<([^>])>$/ and turn it into a pair of results. not for anything seriously, just to get a sense of how big the code would be
13:20:07 <augur> ab9rf: why? they ARE a useful programming tool
13:20:08 <ab9rf> augur: that looks like cat vomit
13:20:16 <augur> ab9rf: haha well. :)
13:20:19 <ab9rf> augur: no, they're a useful _editor_ tool
13:20:33 <chrisdone> bitemyapp: uhm… options *just* for ghci, i'm not sure. you can put it in your .ghci though
13:20:53 <bitemyapp> chrisdone: buh. this should be fixed.
13:20:57 <bitemyapp> chrisdone: thanks. Please edit the post.
13:21:02 <bitemyapp> chrisdone: pretty please :)
13:21:14 <bitemyapp> chrisdone: noobies won't know whether to use :set, ghc-args, etc.
13:21:30 <ab9rf> augur: some of the worst code i've ever seen involves regexp abuse
13:22:01 <augur> ab9rf: probably true
13:22:37 <ab9rf> augur: you could write a parsec parser to recognize that in about as many lines as you'd need to glue to the PCRE library, and it'll make more sense too
13:22:59 <k00mi> ab9rf: they certainly are a useful programming tool, just like goto is
13:23:05 <ab9rf> k00mi: heh
13:23:16 <k00mi> just not one that's fun to use
13:23:19 <chrisdone> bitemyapp: updated
13:24:27 <chrisdone> i think the equivalent code of /^(.*)\|<([^>])>$/ in parsec wouldn't be pretty
13:25:00 <bitemyapp> chrisdone: thank you thank you.
13:25:32 <npr> need help ....
13:25:40 <npr> dont no where to go now ...
13:25:58 <npr> pursuing  engg. in cs ...
13:26:14 <Eduard_Munteanu> We probably no and can help. :)
13:26:45 <npr> <Eduard_Munteanu> i dont 9 what to pusrsue ...
13:26:48 <chrisdone> do a <- manyTill anyChar (char '|'); char '<';  c <- satisfy (/='>'); char '>'; return (a,b)
13:26:53 <chrisdone> actually, it's not that bad
13:27:08 <chrisdone> s/ c/b
13:27:20 <Eduard_Munteanu> npr: can you be a bit more explicit about that?
13:27:36 <chrisdone> ab9rf: have you tried a stackage repo?
13:27:57 <npr> <Eduard_Munteanu>  i can code in python,c++,java,js,....
13:28:00 <chrisdone> i've started using it for a bunch of projects now
13:28:23 <snyp> let m::(Map [Char] Integer) = fromList [("Hello", 1), ("World", 2)]             gives me error
13:28:30 <ab9rf> chrisdone: the annoying "feature" is whe i realize i missed a package, and that forces me to unregister and reinstall everything bceause the package i missed forces a different dependency solution
13:28:45 <npr> <Eduard_Munteanu> but dont have any proficency ...
13:28:47 <snyp> Illegal type signature: ‘Map String Integer’ Perhaps you intended to use ScopedTypeVariables
13:28:53 <brandon`> using haskell win32 package how can I convert 0x001a00ca to HWND (window handle)?
13:28:54 <npr> <Eduard_Munteanu> no clue where to go noe
13:29:10 <Eduard_Munteanu> npr: what have you been programming usually?
13:29:25 <chrisdone> ab9rf: so it reinstalls properly in the end, you just don't like waiting?
13:29:29 <npr> <Eduard_Munteanu> usually the college stuff ..
13:29:43 <Eduard_Munteanu> I see.
13:29:52 <npr> <Eduard_Munteanu> just so that i can learn the language ..
13:29:56 <ab9rf> chrisdone: eventually, usually.  sometimes it take a while to sort out which packages have to be unregistered and reinstalled
13:29:56 <chrisdone> bitemyapp: does it work? ;-)
13:30:10 <npr> <Eduard_Munteanu> although i completed a website with php ...
13:30:21 <npr> <Eduard_Munteanu> with complete db.
13:30:28 <brandon`> HWND seems to be alias to GHC.Ptr.Ptr. how can I convert Num to GHC.Ptr.Ptr?
13:30:31 <chrisdone> ab9rf: fwiw, with a stackage snapshot all of the packages build together. when it's time to upgrade a package, you upgrade to a new stackage version and everything builds. you have to wait for it to build, but at least everything will and has been tested
13:30:45 <npr> <Eduard_Munteanu> i want to know what are my option now ....
13:30:49 <Eduard_Munteanu> npr: you might want to get involved with open source projects, because you learn style and how to deal with large codebases
13:31:29 <npr> <Eduard_Munteanu> well i tried for that ...but couldnt  find a project to work on ...
13:31:34 <Eduard_Munteanu> npr: it's going to be a bit difficult at first, yes.
13:32:02 <ab9rf> npr: start your own project :)
13:32:23 <chrisdone> npr: make a game of chance
13:32:45 <bitemyapp> chrisdone: I just checked, you changed this? http://chrisdone.com/posts/making-ghci-fast
13:32:48 <npr> <ab9rf> thats why i need to 9 where to go now ...big data ,networking or ai
13:33:01 <chrisdone> bitemyapp: yup
13:33:02 <bitemyapp> chrisdone: I don't see explicit mention of :set in either your blog post or the wiki article.
13:33:19 <chrisdone> bitemyapp: Ctrl+F5?
13:33:20 <bitemyapp> chrisdone: and it would be ideal if it was a monospaced, "literal block" that showed they were supposed to enter it in ghci.
13:33:29 <bitemyapp> chrisdone: damn caching. There we go.
13:33:34 <chrisdone> =)
13:33:42 <bitemyapp> chrisdone: thanks, adding it to the wiki page.
13:33:46 <npr> <Eduard_Munteanu> so what  you say ....means which language i should chose and ....
13:34:00 <npr> <Eduard_Munteanu> what to do so that i can get a good internship ...
13:34:07 <dncr> On Ubuntu 14.04, libghc-criterion-dev is installed but in ghci or ghc on an .hs file says: Could not find module `Criterion.Main'. Other libraries are fine. How do I figure out what's wrong?
13:34:27 <ab9rf> npr: what exactly are you seeking?
13:34:51 <chrisdone> susan
13:34:55 <snyp> i guess some kind of precedence problem again
13:35:16 <Eduard_Munteanu> npr: no matter what you choose, it's probably a good idea to learn how to interface with libraries, navigate documentation and solve specific problems. Without that, you can't really get very far.
13:35:34 <ab9rf> oh, yay, now i have everything installed again except this time with aeson-0.6 instead of aeson-0.7
13:35:56 <dncr> "ghc-pkg list" has at exactly are you seeking?
13:36:10 <Eduard_Munteanu> npr: e.g. if you plan on making a small game, research GUI toolkits
13:36:24 <dncr> "ghc-pkg list" has: criterion-0.6.2.0
13:36:30 <bitemyapp> chrisdone: http://www.haskell.org/haskellwiki/Making_GHCi_scale_better_and_faster
13:36:35 <bitemyapp> chrisdone: ported it over. Thanks!
13:36:49 <npr> <ab9rf> i studied the ccna course ...didnt go for cert but i 9 something about networking ....ai is really interesting and big data is like a boom ....usually algorithms kind of bore me ....so i want 2 9 do i really need algoritmic proficency ....and how can i pursue these other subjects ....and what are other options for me ...
13:37:11 <chrisdone> bitemyapp: \o/
13:37:25 <chrisdone> bitemyapp: i think you've made code spans instead of blocks
13:37:36 <chrisdone> but i understand; wiki syntax is wat
13:37:56 <npr> <Eduard_Munteanu>  well i tried for some open source projects but couldnt find one ....
13:38:05 <npr> <Eduard_Munteanu>  no clue how to approach them ....
13:38:25 <bitemyapp> chrisdone: yeah I was moderately confused.
13:38:37 <bitemyapp> chrisdone: I checked the help page and it said "Use <hask> or <haskell>" so uh. yeah.
13:39:03 <chrisdone> <hask> for inline, <haskell> for blocks
13:39:19 <chrisdone> it'd be easier to have a wiki based on markdown, seconda me >_>
13:39:38 <bitemyapp> chrisdone: oh my god I am not even going to start that war.
13:39:40 <npr> <Eduard_Munteanu>  means what should be my approach in third year of my colg
13:39:50 <chrisdone> i fixed it
13:39:53 <bitemyapp> chrisdone: <3
13:40:00 <chrisdone> =p http://haskell-lang.org/wiki/Making_GHCi_scale_better_and_faster
13:40:13 <bitemyapp> that's way better looking
13:40:19 <kadoban> npr: Usually open source projects have dev mailing lists you can join or at least some notes about how to contribute somewhere, depending on the size of the project. Jump right in, the worst they can do is reject your changes, hopefully with some helpful comments.
13:40:21 <npr>  means how to master or be good in a language ......is competitive coding any good ???
13:40:39 <chrisdone> bitemyapp: http://www.reactionface.info/sites/default/files/imagecache/Node_Page/images/1310408064982.jpg
13:40:40 <chrisdone> =p
13:40:46 <bitemyapp> chrisdone: have you seen 4Clojure?
13:40:47 <snyp> Why does Set.union require the type of the elements of the set to be instanced for Ord and not just Eq ?
13:40:56 <chrisdone> nope. what's that?
13:41:00 <ab9rf> go troll around github for soething that looks intersting
13:41:02 <bitemyapp> chrisdone: could something like TryHaskell be used to offer a exercise-driven experience like 4Clojure?
13:41:15 <bitemyapp> chrisdone: uhhh...best you just look: https://www.4clojure.com/
13:41:18 <shachaf> snyp: Set is implemented as a balanced tree for efficiency.
13:41:28 <snyp> shachaf: o
13:41:30 <chrisdone> snyp: the data structure is implemented in terms of Ord
13:41:37 <npr> <kadoban> ok ... is competitive coding any good ???
13:41:42 <snyp> i see i see
13:42:02 <kadoban> npr: Being good at programming is somewhat a different skill that being good at competitive coding, although programming-competition problems can be an interesting way to get some basic experience at a language.
13:42:15 <dmj``> chrisdone: nice site!
13:42:15 <chrisdone> bitemyapp: oh, neat
13:42:29 <bitemyapp> chrisdone: right so, I have people that I've been introducing to Haskell asking for interactive exercises and videos.
13:42:41 <ab9rf> programming competitions mainly test your ability to find algorithmic solutions to contrived problems and implement them in code
13:42:52 <npr> <kadoban> for job point of view or algorithm point of view these competitive programming any good ???
13:42:57 <bitemyapp> chrisdone: I have ?!PLANS?! for the video part but I'd like to know upfront what the story is for using MuEval or Hint as a backend for a 4clojure equivalent for Haskell.
13:43:12 <bitemyapp> ab9rf: contrived is understating it
13:43:19 <chrisdone> bitemyapp: i was considering the other day exposing a way to submit tutorials to tryhaskell written in haskell
13:43:20 <ab9rf> they do nothing to introduce you to good software engineering practice, and in fact often emphasize bad habits
13:43:23 <bitemyapp> ab9rf: nice legal indicator of raw IQ though.
13:43:40 <chrisdone> bitemyapp: so the current tryhaskell would just be one of many interactive tutorials available
13:43:46 <bitemyapp> chrisdone: well, the nice thing about 4clojure is that they just ask you to write an expression that returns a function they can test.
13:43:57 <bitemyapp> so the backend can eval with quickcheck to validate.
13:44:10 <kadoban> npr: If you're looking to have something to show on your resume, I'd look more at open source projects. It's great to be able to point to. If you can win or do reasonably well at a programming competition that'd probably be nice too, but personally I don't think it really provides a ton of relevent experience towards a job
13:44:17 <Tjr> Since we're talking about jobs, how did you make your haskell expertise pay off?
13:44:53 <ski> npr : btw, you probably shouldn't write responses to (e.g.) kadoban like "<npr> <kadoban> ok ... is competitive coding any good ???", since it looks like you're *quoting* something that kadoban said
13:44:57 <chrisdone> bitemyapp: anyway, mueval is fine for this kind of task. it's super easy to use
13:44:58 <ski> simply say e.g. "kadoban : ok ... is competitive coding any good ???" or something similar, if you want to direct a message to kadoban
13:45:07 <bitemyapp> chrisdone: cool. I wanted an excuse to learn Yesod anyway.
13:45:08 <nbouscal> +1 for open-source contributions over programming competitions. the former are also a better way to begin participation in a community
13:45:14 <bitemyapp> chrisdone: / Snap.
13:45:15 <kadoban> npr: Open Source is great because you can be a part of something big, and it shows that you can work well with others, and that at least someone out there thought your code was decent enough to accept.
13:45:33 <npr> ski : ok :)
13:45:38 <Nik05> can i use ghci to find the type of a function inside a where?
13:45:40 <Eduard_Munteanu> Tjr: I routinely implement stuff in Haskell for work, although I call the shots in technical matters,
13:45:49 <Nik05> or maybe with ghc?
13:45:51 <chrisdone> Nik05: not without transforming the code
13:45:57 * hackagebot simplessh 0.2.0.4 - Simple wrapper around libssh2  http://hackage.haskell.org/package/simplessh-0.2.0.4 (thoferon)
13:46:04 <ski> npr : if you try typing the first few characters of someone's nickname, and then press `<tab>', possibly your IRC client will complete the nickname for you ..
13:46:15 <ab9rf> i spent a year or so working on the gimp back in the 90s.  it was fun.
13:46:15 <chrisdone> hdevtools, ghc-mod, fp haskell center, and scion can do it
13:46:17 <Nik05> oh ok
13:46:19 <Tjr> Eduard_Munteanu: so haskell is basically your way to make your job fun?
13:46:23 <npr> kadoban : can you suggest some pojects  ???
13:46:26 <snyp> How does haskell know how to apply the typeclass functions when we just derive a typeclass instead of explicitly writing the definitions of each function ?
13:46:36 <snyp> like Show and Ord
13:46:43 <ab9rf> i have to admit it's harder now because a lot of the low-hanging fruit has already been picked
13:47:32 <ski> npr : one reason for starting a message directed to someone immediately with that person's nickname is that several clients only highlight/alert in case there is a message *beginning* with the nickname of the person using the IRC client
13:47:35 <chrisdone> bitemyapp: i'm partial to yesod these days, more industrialy
13:47:41 <kadoban> npr: Depends a lot what you're interested in, really I'd just look around on your computer, what open source tools do you use? Look at those, see if they're possible to contribute to. Big names go better on a resume, but can be harder to get accepted work into.
13:47:41 <bennofs> chrisdone: hdevtools/ghc-mod can find the type of something inside a where involving local bindings? :O
13:48:04 <bitemyapp> chrisdone: yeah I've been getting pushed towards Yesod by peopel I trust lately. I kinda hate digestive-functors anyway.
13:48:07 <chrisdone> ircbrowse is snap, haskellnews is snap, lpaste is snap, tryhaskell is scotty, haskell-lang is yesod
13:48:12 <npr_> lost connection ....
13:48:18 <chrisdone> i play the field =p
13:48:30 <kadoban> npr_: (resend) Depends a lot what you're interested in, really I'd just look around on your computer, what open source tools do you use? Look at those, see if they're possible to contribute to. Big names go better on a resume, but can be harder to get accepted work into.
13:48:36 <bitemyapp> chrisdone: pro.
13:48:37 <chrisdone> bennofs: sure can!
13:48:48 <chrisdone> bitemyapp: ≖‿≖
13:48:59 <ab9rf> npr: implement a small webapp in yesod or snap
13:49:02 <npr_> kadoban : can i go for ubuntu ??/
13:49:12 <chrisdone> in fact i have a small gist that implements sub-expression type info lying around
13:49:14 <kadoban> npr_: If you don't happen to use anything open source, just google around for projects in any areas you're interested in, or if there's really not any, just look around for any big open source projects.
13:49:21 <piezoid> Nik05: with ghci 7.8 you can use TypeHoles, just put a _ in an expression
13:49:28 <nbouscal> bitemyapp: digestive functors is definitely one of the more frustrating parts of snap to deal with. on the other hand, the yesod stuff causes me cabal pains way more frequently
13:49:33 <ab9rf> ubuntu is an aggregator, it's far easier to work on one of the gazillion products that is incorporated into ubuntu
13:49:35 <npr_> kadoban : okk
13:50:11 <chrisdone> bennofs: https://gist.github.com/chrisdone/1ac360460f99442f9efe
13:50:13 <npr_> kadoban :  is big data worth learning ??
13:50:15 <kadoban> npr_: Sure, ubuntu would be a possibility. The only problem is that I think a lot of their work is in packaging things together, testing, documentation, etc. It's quite possible that they have programming work that needs doing too.
13:50:31 <chrisdone> lifted from ghc-mod. the actual core code is quite short
13:50:35 <ab9rf> npr_: what do you mean by "learning big data"?
13:50:43 <kadoban> npr_: I consider almost everything worth learning :)
13:51:19 <npr_> ab9rf : i meant going for hadoop and data mining ...
13:51:24 <snyp> How can I view the functions a typeclass requires in ghci ?
13:51:25 <bennofs> chrisdone: oh right, I forgot that this should be easy because GHC annotates the whole AST with types anyway when typechecking
13:51:50 <npr_> kadoban : i m 20 and in 3rd year of cs ...is it too late to start something from scratch ??
13:51:50 <Tjr> npr_: It's just personal opinion, but I'd try to avoid being a commodity. At this stage, unless you can leverage pre-existing skills to make your big data knowledge special, big data is a commodity.
13:52:16 <ab9rf> hadoop is basically a parallizing map-reduce engine.
13:52:25 <kadoban> npr_: Of course not, 90 isn't too late to start something from scratch.
13:52:26 <ab9rf> data mining covers a huge range of things
13:52:33 <ab9rf> you could spend a lifetime on data mining and not scratch the surface
13:53:01 <tommd> I recall StablePtrs had issues in 7.8 but now I can't find the bug report or anything else online.  Can someone refresh my memory?
13:53:04 <chrisdone> bitemyapp: digestive-functors is okay… kinda overengineery compared to the classic formlets library. yesod's formlets are simple. i'm not into shakespearean templates personally, i prefer blaze-html, and i'd prefer a proper MVC layout that separates the model from the view (where in Yesod it's all in Handler), but otherwise i like the rest
13:53:04 <ab9rf> most of the jobs in "big data" are just engineering roles keeping the storage and computation networks running
13:53:06 <npr_> so  what should be my approach on learing something ....
13:53:21 <bitemyapp> chrisdone: I gagged on the stringly types.
13:53:30 <chrisdone> stringly types of what?
13:53:31 <npr_> means how should i go so that i can land on a good job ...
13:53:42 <ab9rf> npr_: do you want to learn, or do you just want to get a job
13:53:47 <bitemyapp> chrisdone: shakespearean templates I'm meh on, and I don't like the lack of model/view separation either, but it makes up for it.
13:54:06 <bitemyapp> chrisdone: jonsterling actually has a more well-formed critique of digestive functors than I can express on the fly right now.
13:54:09 <Tjr> npr_: https://news.ycombinator.com/item?id=4974230
13:54:11 <chrisdone> bitemyapp: i meant controller/model, but also the view in yesod is unclear
13:54:12 <npr_> i want to learn networking ...its really amazing
13:54:30 <bitemyapp> benzrf: hey. Does vampire do spine visualization?
13:54:31 <npr_> ai ...cause i just want to learn it ..
13:54:48 <ab9rf> npr_: if you want a job in networking, go work for comcast or verizon as a tech, that's the best entry
13:54:48 <hexagoxel> snyp: duckduckgo gives http://stackoverflow.com/questions/3864647/how-does-deriving-work-in-haskell
13:54:56 <hexagoxel> and the linked http://www.haskell.org/onlinereport/derived.html#derived-appendix
13:54:58 <bitemyapp> does anybody have a spine visualization tool/library that works for GHC 7.8? ghc-vis dunnae work.
13:55:04 <brandon`> anyone? how can I convert Num to HWND?
13:55:08 <chrisdone> bitemyapp: i mean-- it's nice to separate controller from model, to know that some code that hits the database isn't going to randomly redirect the page or set cookies
13:55:18 <benzrf> bitemyapp: spine?
13:55:19 <benzrf> =p
13:55:19 <npr_> which language should i pick ....
13:55:30 <ab9rf> you won't get there studying computer science, nothing you learn in a computer science degree will help you one whit in a networking job
13:55:32 <npr_> i 9 its a silly ques ....being on haskell form ...
13:55:34 <chrisdone> brandon`: perhaps Integral?
13:55:45 <bitemyapp> benzrf: you know what I mean.
13:55:45 <benzrf> bitemyapp: btw i was about to write a marginally better CLI for rewriting + a repl thingy for evalling & displaying exprs p:
13:55:53 <benzrf> bitemyapp: no i dont
13:55:54 <bitemyapp> benzrf: a learner wants a spine vis tool.
13:56:02 <benzrf> m8 i dont know about STG
13:56:06 <benzrf> i heard of it, dont know butt about it
13:56:10 <bitemyapp> benzrf: STG is *spineless*
13:56:14 <benzrf> oh wait
13:56:18 <brandon`> chrisdone I have tried fromIntegral if that is what you mean.  getting "No instance for (Num HWND) arising from a use of `fromIntegral'" error
13:56:23 <benzrf> bitemyapp: so whats a spine
13:56:26 <snyp> hexagoxel: hmm
13:56:27 <bitemyapp> fack.
13:56:29 <benzrf> :I
13:56:31 <bitemyapp> hold on.
13:56:31 <corgifex> a backbone
13:56:34 <chrisdone> brandon`: perhaps here: http://hackage.haskell.org/package/base-4.7.0.0/docs/Foreign-Ptr.html#t:IntPtr
13:56:36 <npr_> ab9rf  : so am i only going to get algorithmic job ...
13:56:38 <kadoban> npr_: In terms of languages, try a bunch of them, see what you like. Usually you get forced into a language by managers or other considerations though
13:56:38 <benzrf> haha
13:56:48 <chrisdone> intPtrToPtr (fromIntegral mynum) :: Ptr WND
13:57:16 <snyp> hexagoxel: i've always wondered.. but is knowledge of how deriving works going to be important to me? I just derived (Show, Ord, Eq) and the program finally compiled.
13:57:18 <chrisdone> don't forget to cross your heart after doing so
13:57:25 <hexagoxel> snyp: ":info", e.g. ":info Monad"
13:57:28 <npr_> kadoban : what should be my approach in learning language ...means i can write code in many language ...but how to get good in them
13:57:33 <Tjr> npr_, kadoban if you're going to go on the job market within the next 2 years, you could look at job offerings now to determine which language is the most popular.
13:57:37 <snyp> hexagoxel: ah
13:57:48 <ab9rf> network jobs are the auto mechanics -- you don't need to be a mechanical engineer to fix an engine and ou don't need to be a computer scientist to maintain a cisco router
13:57:56 <hexagoxel> snyp: but that list all members; sometimes it is sufficient to implement certain subsets
13:58:10 <snyp> i see
13:58:12 <kadoban> npr_: Read good code in the language, use the language, and get your code reviewed by people who are better than you. Pretty much the general way to get better at anything.
13:58:21 <hexagoxel> like (>>) in Monad has default implementation
13:58:45 <Tjr> kadoban: speaking of code to read, what are some good examples for haskell (for someone coming from mathematica)?
13:58:48 <chrisdone> bitemyapp: a visualization for the STG?
13:59:07 <chrisdone> benzrf: moar REPLs. make one
13:59:16 <npr_> kadoban : what you think about acm and gsoc
13:59:23 <brandon`> chrisdone that helped thanks, this did it:    intPtrToPtr 0x001a00ca :: HWND
13:59:26 <nbouscal> Tjr: ghc is good, xmonad is good
13:59:30 <chrisdone> brandon`: \o/
13:59:46 <chrisdone> win32 programming is surprisingly fun sometimes
13:59:48 <kadoban> Tjr: I've been trying xmonad, but I'm still pretty crap at haskell so personally I dunno XD
14:00:00 <nbouscal> Tjr: base is good
14:00:39 <kadoban> npr_: gsoc seems like a great idea. IME the best way to get into that though is the same way you become a normal developer on a project though, so you have to do the same work.
14:01:00 <brandon`> chrisdone I like to keep it at minimum :). but I had to use it in here, to send mouse and keyboard events to a window
14:01:30 <benzrf> bitemyapp: gonna explain spine?
14:01:30 <benzrf> >.<
14:01:46 <chrisdone> presumably he means constructors
14:01:50 <kadoban> npr_: acm, you mean the programming contest? Same thing I think about competitive coding in general. Probably fun, and a decent skill to have, but personally if I was looking at resumes I'd consider it only a marginal plus if someone did well in one.
14:01:53 <benzrf> :[
14:02:07 <chrisdone> 1 :  2 : 3 : []
14:02:07 <chrisdone>   ^    ^   ^   this is the spine
14:02:24 <Tjr_> kadoban: sorry, got disconnected. If you replied, would you please re-reply?
14:02:40 <chrisdone> haskell-mode has a cool spine viewer
14:02:44 <snyp> thanks for the help today. gtg. later.
14:02:47 <bitemyapp> chrisdone: WAT, where?
14:02:55 <bitemyapp> benzrf: nota bene, no lazy, no spine.
14:02:56 <kadoban> Tjr_: Ah, uhm I just said xmonad, but I suck at haskell still so I'm not much of an expert on what good haskell looks like yet.
14:03:03 <npr_> kadoban : yup ....and learing funtional language ...how it help with programming skill
14:03:35 <kadoban> Tjr_: I seem to be learning a lot about good haskell from http://exercism.io , might want to check that out
14:03:37 <chrisdone> bitemyapp: assuming you mean something like this https://www.youtube.com/watch?v=oJhIvHtflbI it's hard to tell from just spine
14:04:46 <kadoban> npr_: Learning functional languages, and as many different languages/types of languages as you can gives you experience with different abstractions. It expands your mind to new ways of thinking about problems, and gives you choices about the best tool for the job.
14:05:40 <kadoban> npr_: If you only know how to use a hammer, everything looks like a nail. If you learn how to use a drill, a table saw and etc., suddenly you can do a lot more and better.
14:06:07 <benzrf> so the spine is the tree of data constructors in a value
14:06:10 <benzrf> >
14:06:11 <benzrf> ?
14:06:14 <Tjr> But good luck convincing your boss that a "nail" is not in fact always a nail.
14:06:35 <chrisdone> bitemyapp: if you use haskell-interactive-mode, you can just run :!cabal install present, M-x haskell-process-restart and then :present [1..]
14:06:43 <johnw> benzrf: for any "Foo a", the Foo constructor is the "spine"
14:06:57 <benzrf> johnw: ah
14:07:03 <bitemyapp> chrisdone: I don't really use HIM at the moment, I don't think I was able to get it to work with cabal project + sandbox
14:07:08 <benzrf> bitemyapp: barking up the wrong tree :o
14:07:16 <benzrf> bitemyapp: the entire point of vampire is that it
14:07:22 <chrisdone> bitemyapp: was that before i wrote awesome documentation?
14:07:22 <benzrf> 's about the *expression* tree
14:07:31 <bitemyapp> chrisdone: where is the awesome documentation?
14:07:32 <benzrf> *value* tree viewers are a dime a dozen ;)
14:07:36 <kadoban> Tjr: Indeed, but even if you get stuck using some language that you otherwise wouldn't, you can still use the abstractions and patterns you've used in better languages.
14:07:43 <bitemyapp> benzrf: okay okay. Cool. Sorry to bug you.
14:07:54 <chrisdone> bitemyapp: https://github.com/haskell/haskell-mode/wiki/Haskell-Interactive-Mode-Setup#ghci-process-type
14:08:05 <chrisdone> bitemyapp: table of contents: https://github.com/haskell/haskell-mode/wiki
14:08:10 <bitemyapp> bah-fuck. okay. I need to try this.
14:08:17 <chrisdone> \o/
14:08:22 <bitemyapp> chrisdone: I still need to run at least out-of-emacs repl though, for tests.
14:08:33 <bitemyapp> chrisdone: I haven't found a faster way to run tests than :r and main in ghci with a test repl.
14:08:58 <bitemyapp> cabal test takes too damn long >:[
14:09:27 <chrisdone> bitemyapp: ah, for that i tend to write a few lines and bind it to a keybinding in emacs. if you end up using HIM i can give you a code snippet
14:09:30 <benzrf> bitemyapp: vampire is for code introspection, not result introspection o=
14:10:00 <bitemyapp> benzrf: da da
14:10:19 <bitemyapp> chrisdone: I'll try it later today, thanks!
14:10:47 <chrisdone> bitemyapp: a trivial way is just:
14:10:48 <chrisdone> (haskell-process-queue-without-filters (haskell-process) ":r")
14:10:49 <chrisdone> (haskell-process-queue-without-filters (haskell-process) "main")
14:11:04 <chrisdone> stick that in a function and you can hit 12 or whatever to re-run the tests
14:11:12 <chrisdone> er, f12
14:11:32 <bitemyapp> chrisdone: being an emacs user, I'd probably make it C-c r t
14:11:40 <bitemyapp> or C-c e t or something similar
14:11:46 <chrisdone> actually, (haskell-process-reload-file) is sufficient, which will include saving the buffer
14:11:49 <bitemyapp> C-c h e t
14:12:06 <bitemyapp> chrisdone: does this work if the code the test relies on changed?
14:12:19 <bitemyapp> chrisdone: I had problems where I had to kill and reload the test repl to force it.
14:12:20 <chrisdone> sure, ghci handles that
14:12:24 <bitemyapp> well you'd think
14:12:27 <bitemyapp> but it didn't >:[
14:12:31 <chrisdone> hmm
14:12:39 <chrisdone> was it template-haskell code?
14:12:50 <bitemyapp> hrm. don't sweat it. I'll just try it again and see what happens.
14:12:52 <chrisdone> because there's a bug with :r versus :l in that area
14:12:54 <bitemyapp> chrisdone: probably not.
14:13:03 <chrisdone> :l is more reliable than :r for forcing dependent code to reload
14:13:10 <bitemyapp> hrm, good to know.
14:14:11 <chrisdone> an alternative method might be this handy function https://github.com/haskell/haskell-mode/blob/master/haskell-process.el#L1414..L1450
14:14:11 <chrisdone> which i used to reload my web app. it runs:
14:14:12 <chrisdone> :l DevelMain
14:14:12 <chrisdone> DevelMain.update
14:14:24 <chrisdone> you could perhaps make a DevelMain module and import your tests and do update = runTests
14:14:26 <chrisdone> just an idea
14:14:33 <bitemyapp> nifty.
14:14:38 <bitemyapp> TDD + Types valhalla.
14:14:43 <chrisdone> :D
14:14:59 <bitemyapp> chrisdone: I made that video, but from the video, it's obvious my workflow is still relatively modest.
14:15:19 <bitemyapp> that said, it seemed like some were still impressed with the IDE-esque squiggles.
14:15:26 <bitemyapp> speaking of, danclien - ping.
14:15:32 <chrisdone> bitemyapp: which video is that?
14:15:46 <bitemyapp> chrisdone: https://www.youtube.com/watch?v=Li6oaO8x2VY 1,218 views :D
14:15:55 <bitemyapp> bought a better mic sunday, gonna do more soon.
14:16:00 * hackagebot muon 0.1.0.7 - Static blog generator  http://hackage.haskell.org/package/muon-0.1.0.7 (kaashif)
14:16:02 <chrisdone> oh neat =)
14:16:06 <danclien> bitemyapp: Yes? :P
14:16:12 <bitemyapp> danclien: ^^ see the video?
14:16:14 * chrisdone checks 'em
14:16:26 <danclien> Bookmarked yet, but I haven't watched it yet. :P
14:16:34 <bitemyapp> danclien: coo.
14:16:35 <danclien> Er... s/yet/it/
14:18:00 <bitemyapp> danclien: I have an apartment showing at 6, have time to hang out before?
14:18:20 <bitemyapp> danclien: also do you know how good the neighorhood around 37th & I35 is?
14:18:30 <danclien> bitemyapp: Yup, but I don't have a car right now.
14:18:56 <danclien> bitemyapp: Should be great.
14:19:09 <bitemyapp> danclien: I can pick you up in mine, then drop you off.
14:19:21 <chrisdone> bitemyapp: i've thought about doing a workflow video too for a while, but i haven't had a good project to work on to demo a real workflow recently
14:19:22 <danclien> bitemyapp: Sounds good. I'll text you my address.
14:20:10 <bitemyapp> chrisdone: it was just a ToJSON instance. Main priority was "honesty" - no grand-standing, no showing off tools I don't actually use every single time I wrote Haskell.
14:20:36 <bitemyapp> chrisdone: and sharing my actual thought process as directly as possible without making it excessively boring. One person described it as discursive...but that's where my thoughts were...
14:21:04 <copumpkin> goldfire: what's going on with the Equals_1627415457 type family in http://hackage.haskell.org/package/units-2.0/docs/Data-Metrology-Z.html ?
14:21:38 <bitemyapp> copumpkin: that's how many times Haskellers have implemented Eq on a Nat type.
14:21:51 <copumpkin> fair enough :)
14:22:02 <chrisdone> bitemyapp: yeah, i think these videos are useful. i remember seeing a common lisp video by marco baringer years ago and being super impressed by his work environment. you don't know how good coding can be until you see it for real
14:22:15 <bitemyapp> copumpkin: don't ask me how he synchronizes that counter. I'm guessing it's hyperloglog and might not be precise.
14:22:31 <copumpkin> could just be a global lock with GHC calling out to the cloud
14:22:34 <bitemyapp> chrisdone: right!  I wanted people to see that when I came here from Clojure, I gave up nothing!
14:22:46 <bitemyapp> copumpkin: that would explain scalac better than it would GHC >:]
14:23:19 <copumpkin> well, GHC only needs to run that particular naming step under the lock. Scalac due to rampant mutability needs to run the entire compiler under the lock
14:23:27 <copumpkin> which explains the difference in speeds
14:23:39 <bitemyapp> copumpkin: <3
14:23:50 <copumpkin> luckily paulp will fix it
14:23:58 <bitemyapp> copumpkin: his sanity is finite. Not likely.
14:24:19 <bitemyapp> copumpkin: I asked the author of the typeparams stuff if they managed to break GHC - not a single time.
14:25:25 <bitemyapp> copumpkin: I really expected them to have caused it to at least choke a bit, if not actually break.
14:25:29 <copumpkin> yeah, who knows. I'm not betting on Scala, but it actually could be a decent language if someone had taste
14:25:43 <bitemyapp> copumpkin: yeah, you'd only have to get rid of...everybody that actually cares about Scala.
14:26:01 <bitemyapp> copumpkin: maybe if world war 3 happens and all the scala programmers go to war with Oceania.
14:26:12 <copumpkin> :)
14:26:24 * bitemyapp waves from his ivory tower
14:28:44 <darthdeus> is there a good way to send commands to ghci?
14:28:47 <darthdeus> as in remotely
14:29:04 <darthdeus> i tried doing something like   my_script | cabal repl, but that doesn't seem to work the way I wanted
14:29:38 <kadoban> darthdeus: ghci has a :script command or something, is it possible you're looking for that?
14:29:40 <ab9rf> darthdeus: what are you trying to do?
14:29:52 <ab9rf> you can run ghci in a pseudotty, i suppose
14:30:07 <chrisdone> bitemyapp: https://www.youtube.com/watch?v=9P5zqkc9FFs
14:30:13 <darthdeus> i want to run a server from ghci, and then when i save a file I want to send it SIGINT and run the server again
14:30:26 <darthdeus> SIGINT will kill the server as if i did C-c, that part works
14:30:31 <darthdeus> but I don't know how to remotely send it input
14:31:02 * hackagebot aur 0.0.1 - Access metadata from the Arch Linux User Repository.  http://hackage.haskell.org/package/aur-0.0.1 (fosskers)
14:31:35 <darthdeus> kadoban: afaik that's only for loading scripts, right?
14:31:45 <darthdeus> ab9rf: how can i use a pseudotty?
14:32:13 <kadoban> darthdeus: It's if you want to run a bunch of crap (ghci commands) that's in a file. Doesn't necessarily sound like what you want.
14:32:26 <chrisdone> bitemyapp: dat case split and pattern expand amirite
14:32:32 <darthdeus> kadoban: yeah i need to run commands interactively, based on some other input
14:32:51 <darthdeus> imagine ghci running, and then when another process gets a signal or something, it needs to be able to send ghci some input
14:32:55 <ab9rf> darthdeus: it's a fairly complex process, dunno if there's a haskell API for it ... yet
14:32:57 <darthdeus> the closest i was able to get is by using tmux
14:33:26 <chrisdone> hmm i think (|) and then M-/ would be a nice pattern expansion keybinding. like normal dabbrev-expand, but in pattern-position would imply you want a pattern expand
14:33:27 <ab9rf> darthdeus: tmux uses pseudottys
14:34:15 <ski> as does GNU Screen
14:35:12 <darthdeus> I guess I don't really understand what's a pseudotty :X
14:36:40 <ab9rf> darthdeus: it's a "terminal" that interacts with another program instead of with an actual terminal
14:37:20 <chrisdone> darthdeus: heyyy
14:37:20 <ab9rf> it might be enugh just to popen/fork/exec, you might not need the extra weight of a tty
14:37:34 <chrisdone> darthdeus: perhaps just fork a thread and then killThread when you want it to restart? =)
14:38:08 <darthdeus> chrisdone: but my problem is not the thread forking, it's the starting a new one :( I want to use fswatch to restart my server whenever a file changes
14:38:13 <blume> @pl \x y -> not (x && y)
14:38:14 <lambdabot> (not .) . (&&)
14:38:31 <chrisdone> darthdeus: why is starting a new one problematic?
14:38:52 <darthdeus> chrisdone: because I don't know how to send input to a running ghci
14:38:58 <darthdeus> unless I program the whole fswatch thing in haskell
14:39:58 <darthdeus> chrisdone: also I need to be able to reload the code, so I can't just run a function that automatically forks ... I need to send the actual input to ghci
14:40:04 <darthdeus> as in :load Application<Enter>
14:40:24 <darthdeus> does that make sense?
14:41:04 <chrisdone> oh that's easy
14:41:18 <chrisdone> in ghci run your program
14:41:25 <chrisdone> then just kill -s TERM <yourprocessid>
14:41:29 <chrisdone> that'll cancel the evaluation
14:41:38 <darthdeus> yes, but how do I start it again?
14:41:40 <darthdeus> :P
14:41:47 <darthdeus> that's the problem I'm trying to solve :)
14:42:08 <chrisdone> you need also to reload it?
14:42:11 <darthdeus> yes
14:42:38 <chrisdone> this is a yesod app?
14:42:41 <darthdeus> I'm trying to make workaround yesod devel being slow ... it turns out that :load Application and then running my server handler works about 50 times faster and gets the job done
14:42:41 <darthdeus> yes
14:43:03 <chrisdone> aha
14:43:25 <darthdeus> i actually have a solution using tmux send-keys, but I want to rely on tmux, I want to make it automatic via fswatch :)
14:43:35 <Axman6> darthdeus: huh, I should try that
14:43:38 <chrisdone> right. you can use ghci as a pipe
14:44:06 <chrisdone> and send SIGTERM to cancel evaluation, then :l Application and :main
14:44:12 <darthdeus> pipe actually doesn't work :\
14:44:27 <chrisdone> what part doesn't work?
14:44:40 <chrisdone> it runs as a pipe in haskell-mode
14:45:07 <darthdeus> ok so I have this https://gist.github.com/darthdeus/38438c8760a3a2ba07d3
14:45:15 <jonh> anyone have trouble installing haskell-src-exts-1.15.0.1 in windows with cabal?
14:45:16 <darthdeus> then run it as "ruby run.rb | cabal repl"
14:45:43 <chrisdone> darthdeus: do you use emacs btw?
14:45:53 <darthdeus> chrisdone: i use both vim and emcas :)
14:45:58 <chrisdone> then you're in luck!
14:46:24 <darthdeus> :O
14:46:26 <chrisdone> https://github.com/chrisdone/ghci-reload-demo#safer-way
14:46:57 <darthdeus> I think I even read that article
14:47:03 <chrisdone> make a module like that in your project and then run M-x haskell-process-reload-devel-main
14:47:36 <chrisdone> darthdeus: i have like 5 yesod projects i hack on like this. it's super fast
14:47:49 <darthdeus> oh interesting
14:48:12 <blume> jonh: yea, me. I've read that it has to do with 'happy'. Trying to solve it right now
14:48:17 <darthdeus> chrisdone: you don't define haskell-process-reload-devel-main there though
14:48:25 <Axman6> I'd  really love it if either/both of you wrote blog posts about what you're doing
14:48:26 <chrisdone> darthdeus: it's available in haskell-mode
14:48:39 <darthdeus> hmm not in mine
14:48:48 <darthdeus> i have 20140606 version
14:49:02 <Axman6> if there's a way to make yesod devel faster I'd love to hear what it is
14:49:10 <jonh> blume: ok good i'm not crazy
14:49:10 <chrisdone> darthdeus: https://github.com/haskell/haskell-mode/blob/master/haskell-process.el#L1414
14:49:26 <chrisdone> axman6: fwiw here's a post i made about it http://chrisdone.com/posts/ghci-reload
14:50:04 <Axman6> excellent, thanks
14:50:05 <michaelt> Is there a secret to getting hackage to build the haddocks?
14:50:16 <darthdeus> chrisdone: I'm confused why I don't have that then, it seems I have the latest version from melpa
14:50:47 <chrisdone> darthdeus: maybe you need to do a fresh byte compile? i don't know how using melpa works
14:50:54 <darthdeus> oh and now I have it
14:50:58 <darthdeus> yeah I had to recompile :)
14:51:03 <chrisdone> cool =)
14:51:04 * hackagebot stable-tree 0.4.0 - Trees whose branches are resistant to change  http://hackage.haskell.org/package/stable-tree-0.4.0 (tsuraan)
14:51:08 <darthdeus> dude if this works i'm gonna really love you
14:51:14 <chrisdone> haha, i hope it does =p
14:51:15 <jonh> blume: when i tried doing a -v3 i didn't see anything about happy
14:51:21 <phaazon> hm
14:51:24 <Lutin`> Offtopic but if you don't have an SSD there's a 120GB Samsung 840 EVO for $75 that comes with a 16GB Class 6 microsd card http://www.newegg.com/Product/ComboDealDetails.aspx?ItemList=Combo.1704523
14:51:29 <jonh> it just complains about moving dist-tmp to dist
14:51:34 <phaazon> is there something like foldl1 (>=>) in MonadPlus?
14:51:35 <chrisdone> darthdeus: don't forget to :!cabal install foreign-store
14:51:59 <darthdeus> do i need to add it to my package list?
14:52:17 <chrisdone> darthdeus: ah, maybe if you're using cabal repl, yeah
14:52:30 <chrisdone> i think cabal repl does a -hide-all-packages and only includes the ones in your .cabal
14:52:46 <darthdeus> ah
14:53:24 <blume> jonh: http://stackoverflow.com/questions/20460646/haskell-cabal-install-errors I forgot to mention though, I'm on linux.
14:53:41 <phaazon> blume: is your nickname related to watch dogs ? :)
14:53:56 <sie> :t return 3
14:53:57 <lambdabot> (Num a, Monad m) => m a
14:54:11 <sie> > return 3 <$> Nothing
14:54:12 <blume> phaazon: I have to disappoint you, it's german for 'flower' :)
14:54:13 <lambdabot>  Nothing
14:54:17 <sie> > return 3 <$> Just True
14:54:19 <lambdabot>  Just 3
14:54:20 <phaazon> oh, nice :)
14:54:42 <phaazon> btw, anyone know a quicker and nicer for foldl1 (>=>)
14:54:43 <phaazon> ?
14:54:48 <phaazon> knows*
14:54:50 <vanila> :t foldl1 (>=>)
14:54:51 <lambdabot> Monad m => [a -> m a] -> a -> m a
14:55:08 <chrisdone> blume: the verb?
14:55:08 <vanila> hmmm...
14:55:10 <corgifex> :t foldl (>=>) return
14:55:12 <lambdabot> Monad m => [b -> m b] -> b -> m b
14:55:17 <Axman6> hmm, that is aleady a function somewhere...
14:55:19 <phaazon> something based on sequence
14:55:20 <Axman6> I think
14:55:22 <vanila> @hoogle Monad m => [a -> m a] -> a -> m a
14:55:24 <lambdabot> Data.Generics.Aliases extM :: (Monad m, Typeable a, Typeable b) => (a -> m a) -> (b -> m b) -> a -> m a
14:55:24 <lambdabot> Data.Generics.Aliases mkM :: (Monad m, Typeable a, Typeable b) => (b -> m b) -> a -> m a
14:55:24 <lambdabot> Data.Data gmapM :: (Data a, Monad m) => (forall d. Data d => d -> m d) -> a -> m a
14:55:25 <jonh> blume: thanks for the link, i think my problem might be unrelated though :(
14:55:25 <vanila> it can't be sequence
14:55:32 <vanila> it doesn't seem to exit
14:55:37 <phaazon> vanila: I know
14:55:39 <blume> jonh: after installing happy on my system and with cabal, haskell-src-exts compiled
14:55:44 <vanila> im checking Control.Monad
14:55:44 <darthdeus> chrisdone: HOLY SHIT SHIT SHIT IT WORKS OMG LOL
14:55:46 <blume> chrisdone: no, the noun
14:55:46 <darthdeus> :D
14:55:49 <phaazon> I thought of something in Monoid
14:55:51 <chrisdone> darthdeus: hahaha
14:55:52 <chrisdone> <3
14:55:55 <darthdeus> <3 <3 <3 <3
14:55:57 <phaazon> and applicative
14:56:01 <darthdeus> infinite love
14:56:09 <darthdeus> this is so amazing
14:56:16 <vanila> yeah I think you should define it
14:56:19 <phaazon> oh
14:56:26 <phaazon> isn’t Kleisli defined for that?
14:56:29 <Axman6> darthdeus: what'd you do?
14:56:32 <phaazon> :t Kleisli
14:56:33 <lambdabot> (a -> m b) -> Kleisli m a b
14:56:34 <vanila> oh good point
14:56:36 <chrisdone> darthdeus: to make it reload faster make sure to :set -fobject-code. the initial load is slow, but then subsequent ones are faster
14:56:44 <phaazon> Kleisli as Monoid!
14:56:54 <darthdeus> chrisdone: and I was here thinking that these yesod people must be crazy waiting so long every time
14:56:57 <bergmark> chrisdone: :O didn't know about that
14:56:58 <darthdeus> Axman6: I found nirvana
14:57:11 <darthdeus> chrisdone: where should that be added? sorry I'm still a noob :P
14:57:17 <chrisdone> haha, it's a dev speed up free for all!
14:57:18 <darthdeus> in the cabal file or in the pragma in the devel?
14:57:26 <Axman6> darthdeus: I want to join you there :(
14:57:32 <bergmark> i have ~400 modules in the same session so :-)))
14:57:33 <chrisdone> darthdeus: you can run it in the REPL or add it to a .ghci file in your project dir
14:57:34 <darthdeus> Axman6: there it is https://github.com/chrisdone/ghci-reload-demo#safer-way
14:57:35 <phaazon> now, I wonder how to do that with Applicative only, no Kleisli related
14:58:02 <phaazon> @hoogle Kleisli
14:58:02 <lambdabot> Control.Arrow Kleisli :: (a -> m b) -> Kleisli m a b
14:58:03 <lambdabot> Control.Arrow newtype Kleisli m a b
14:58:03 <lambdabot> package Kleislify
14:58:21 <darthdeus> chrisdone: wow this is so fast
14:59:09 <benzrf> :t (<>) `asAppliedTo` Kleisli a b
14:59:09 <bergmark> chrisdone: someone at zurihac was working on a similar thing, to do dynamic reloading
14:59:10 <lambdabot>     Couldn't match expected type ‘Expr -> a’
14:59:10 <lambdabot>                 with actual type ‘Kleisli m0 a0 b0’
14:59:10 <lambdabot>     The function ‘Kleisli’ is applied to two arguments,
14:59:14 <benzrf> :t (<>) `asAppliedTo` undefined :: Kleisli a b
14:59:15 <lambdabot>     Expecting one more argument to ‘Kleisli a b’
14:59:15 <lambdabot>     Expected a type, but ‘Kleisli a b’ has kind ‘* -> *’
14:59:15 <lambdabot>     In an expression type signature: Kleisli a b
14:59:17 <benzrf> eh
14:59:20 <phaazon> :D
14:59:21 <phaazon> yeah
14:59:26 <benzrf> :t (<>) `asAppliedTo` undefined :: Kleisli m a b
14:59:27 <lambdabot>     Couldn't match expected type ‘Kleisli m1 a1 b1’
14:59:28 <lambdabot>                 with actual type ‘a0 -> a0 -> a0’
14:59:28 <lambdabot>     In the expression: (<>) `asAppliedTo` undefined :: Kleisli m a b
14:59:29 <phaazon> I think foldl1 (>=>) is the quickest :D
14:59:30 <Axman6> I've been having a lot of issues with yesod devel being agonizingly slow the last few days (deveral minute recompiles) so getting that working it pretty useful for me
14:59:31 <benzrf> wenk
14:59:42 <benzrf> :t (<>) `asAppliedTo` (undefined :: Kleisli m a b)
14:59:43 <lambdabot> Monoid (Kleisli m a b) => Kleisli m a b -> Kleisli m a b -> Kleisli m a b
14:59:47 <benzrf> neato
14:59:51 <henk> hi, I want to write a program calculating sunrise and sunset. I need the "julian cycle" or the julian date AFAIU, which is "number of days since a certain date". There is Data.Time.Calendar.Julian but AFAICT it does not provide this information. I’m not sure what I should do ideally. Can anyone advise?
14:59:53 <benzrf> o w8
14:59:53 <chrisdone> darthdeus: one thing bugging me and i'll probably come up with a solution for it at some point, is that if you add a new static file, it sometimes doesn't detect that a new file was added. that makes sense because TH can't *know* to be re-run. i think my solution tends to be to touch the Foundation module to force a recompile, IIRC. i'll come up with a proper fix for it soon
15:00:04 <bergmark> https://github.com/sol/reserve
15:00:41 <chrisdone> axman6: yeah, that's agonizing. i can't stand waiting for more than 10 seconds for an update
15:01:06 * hackagebot pipes-text 0.0.0.11 - Text pipes.  http://hackage.haskell.org/package/pipes-text-0.0.0.11 (MichaelThompson)
15:01:09 <Axman6> chrisdone: i've been waiting several minutes (for no obvious reason)
15:01:23 <Axman6> several minutes with 7 cores going flat out too
15:01:31 <darthdeus> i'm a rails developer by day, so I can't stand waiting more than 3 seconds :D
15:01:36 <darthdeus> but this is just ... omagad
15:01:36 <phaazon> hm
15:02:04 <darthdeus> brb, need to get some food
15:02:14 <benzrf> darthdeus: have i seen you in #ruby perchance
15:02:24 <chrisdone> bergmark: right, that's a good approach
15:02:31 <phaazon> @hoogle (Applicative f) => (a -> f b) -> (b -> f c) -> a -> f c
15:02:33 <lambdabot> Control.Monad (>=>) :: Monad m => (a -> m b) -> (b -> m c) -> (a -> m c)
15:02:34 <lambdabot> Control.Monad (<=<) :: Monad m => (b -> m c) -> (a -> m b) -> (a -> m c)
15:02:34 <lambdabot> Control.Exception.Base bracket :: IO a -> (a -> IO b) -> (a -> IO c) -> IO c
15:03:24 <bergmark> it basicaly does what i do manually at the moment, C-c RET :main
15:03:35 <chrisdone> right
15:04:57 <chrisdone> darthdeus: =p
15:05:16 <chrisdone> darthdeus: i opened a pull request to get it added to yesod's scaffolder
15:05:42 <chrisdone> https://github.com/yesodweb/yesod-scaffold/pull/21
15:06:00 <yitz> henk: the D.T.C.Julian module is for day number in a year.
15:06:16 <chrisdone> some neat stuff in there too
15:06:26 <Axman6> chrisdone: how do I use that DevelMain file? what's the MVar that start takes?
15:07:10 <yitz> henk: for the number of days between two gregoran dates, use toModifiedJulianDay $ fromGregorian y m d for each day, resulting in an Integer, then take the difference
15:07:25 <chrisdone> axman6: you just open up the module in an emacs buffer where it can be loaded into the ghci process. check it compiles by C-c C-l'ing it. you'll probably need to :!cabal install foreign-store
15:07:47 <Axman6> oh, do I need to be using emacs?
15:08:08 <chrisdone> axman6: umm. no, i guess not. just if you want it to work with a single keybinding, i guess
15:08:13 <henk> yitz: ok, thanks
15:08:31 <chrisdone> otherwise you would do:
15:08:32 <chrisdone> :l DevelMain
15:08:32 <chrisdone> DevelMain.update
15:08:32 <yitz> *gregorian
15:08:32 <Axman6> chrisdone: can it be used just from ghci/cabal repl?
15:08:36 <chrisdone> to either start or restart the server
15:08:37 <yitz> henk: yw
15:08:57 <chrisdone> axman6: sure, it can. just means you'll have to run those two lines manually
15:09:07 <Axman6> ok, awesome =)
15:09:14 <Axman6> so, reload and then update?
15:09:18 <chrisdone> yeah
15:09:27 <Axman6> I'm ok with that =)
15:09:28 <bennofs> Isn't ghc-modi just ghci with different names for the commands?
15:09:47 <bennofs> Or am I overlooking something that ghc-modi does better/different?
15:09:48 <chrisdone> ghc-mod doesn't have a REPL
15:09:54 <chrisdone> or is ghc-modi a thing?
15:10:01 <bennofs> chrisdone: ghc-modi is a server-version of ghc-mod
15:10:10 <chrisdone> ah, okay
15:10:26 <bennofs> chrisdone: and it basically just works like ghci, except that :r is called CHECK, :t is called TYPE (or similar), ...
15:10:38 <bennofs> and it cannot evaluate expressions
15:10:45 <chrisdone> so pretty much like hdevtools
15:11:03 <chrisdone> a server-client arch for checking and asking for info
15:11:13 <bennofs> I feel like ghc-mod/hdevtools are just replicating GHCi :)
15:11:22 <chrisdone> mm, i don't think so
15:11:27 <bennofs> what's the difference?
15:11:36 <kini> since people are talking about development tools, something I've been wondering... are there tools that can tell me the type of expressions buried deep inside let-bindings or where clauses or inside lambdas, etc.?
15:11:41 <chrisdone> both of them add two key things that ghci doesn't do: sub-expression type info and go to definition
15:11:41 <kini> I don't think ghci can do that
15:11:57 <chrisdone> kini: ghci cannot do that, ghc-mod and hdevtools can
15:12:15 <kini> ha, the answer to my question was the same as the answer to bennofs's objection, I guess :P
15:12:22 <bennofs> chrisdone: maybe ghci could be extended to do that, instead of reinventing half of it?
15:12:31 <kini> is hdevtools still maintained? It looks like there are outstanding pull requests from quite a long time ago
15:12:33 <benzrf> @hoogle hReadFile
15:12:34 <lambdabot> No results found
15:12:37 <benzrf> @hoogle hRead
15:12:37 <lambdabot> System.IO hReady :: Handle -> IO Bool
15:12:37 <lambdabot> Control.Concurrent isCurrentThreadBound :: IO Bool
15:12:37 <lambdabot> Control.Concurrent killThread :: ThreadId -> IO ()
15:12:43 <benzrf> eh
15:12:44 <chrisdone> it's not really maintained, afaik
15:12:47 <benzrf> @src readFile
15:12:47 <lambdabot> readFile name = openFile name ReadMode >>= hGetContents
15:12:51 <benzrf> aha
15:12:54 <kini> but ghc-mod is?
15:12:57 <benzrf> what module is hGetContents in?
15:12:59 <benzrf> system.io?
15:13:00 <chrisdone> i think so
15:13:17 <yitz> chrisdone: ok, now how about sub-expression breakpoints?
15:13:41 <bennofs> I think it shouldn't be too difficult to add sub-expression type info to GHCi
15:13:42 <chrisdone> not that i know of
15:13:46 <chrisdone> even the basic ghci debugger barely works
15:13:50 <anders0> kini: ghc-mod is still actively maintained, yes :)
15:13:53 <benzrf> :t stdout
15:13:54 <lambdabot> Not in scope: ‘stdout’
15:13:56 <benzrf> hmm
15:13:59 <chrisdone> bennofs: iirc someone may already be adding it
15:14:09 <kini> anders0: yay!
15:14:21 <yitz> @type System.IO.stdout
15:14:22 <lambdabot> GHC.IO.Handle.Types.Handle
15:14:29 <bennofs> chrisdone: so, any other reasons to prefer ghc-mod over ghci?
15:14:34 <kini> chrisdone: I heard a rumor that someone was working on an agda2-mode -like thing for haskell...
15:14:40 <chrisdone> bennofs: nope =)
15:14:45 <kini> do you know any more about this rumor? :)
15:14:54 <chrisdone> kini: nope =)
15:14:57 <kini> aww...
15:15:16 <chrisdone> bennofs: to increase confusion, i'll add my own project to the mix: https://github.com/chrisdone/ghc-server
15:15:33 <chrisdone> there's also scion
15:15:34 <bennofs> chrisdone: hah, I also have https://github.com/bennofs/ghc-server :p
15:15:50 <kini> >it should replace use of GHC, GHCi, hlint, hdevtools, ghc-mod in one big program
15:15:54 <kini> wow, sounds ambitious
15:15:57 <benzrf> is there something for hGetContents stdout beyond that?
15:16:01 <chrisdone> bennofs: what is it? it's not got a beautiful README like mine
15:16:03 <benzrf> *stdin
15:16:49 <bennofs> chrisdone: well, just my own syntax checker like hdevtools. It has got better cabal support, but I think I'm probably going to drop it and instead try to use ghci/ghc-mod
15:16:58 <yitz> benzrf: beyond that?
15:17:06 <acowley> ghc-mod is very actively maintained and works today with emacs and vim
15:17:22 <benzrf> iunno
15:17:38 <benzrf> @src writeFile
15:17:38 <lambdabot> writeFile f txt = withFile f WriteMode (\ hdl -> hPutStr hdl txt)
15:17:40 <kini> chrisdone: so by "should replace use of GHC" does that mean you are writing a new optimizing compiler for haskell? :P
15:17:42 <benzrf> eh
15:17:55 <chrisdone> kini: not yet =p
15:18:07 <bennofs> Btw, does anyone know why GHC is so slow .... ? :(
15:18:14 <yitz> benzrf: do you mean getContents ?
15:18:15 <chrisdone> my aim is to be more like SLIME
15:18:19 <benzrf> oh
15:18:20 <benzrf> :t getContents
15:18:21 <lambdabot> IO String
15:18:23 <benzrf> nea
15:18:24 <benzrf> t
15:18:45 <yitz> benzrf: also getChar and getLine
15:18:53 <chrisdone> ghc's really slow at code generation, but arguably not slow for a fast haskell code generator
15:19:22 <chrisdone> if you're just type-checking (-fno-code), ghc is super fast
15:19:45 <bennofs> chrisdone: but you need code gen for TH
15:19:52 <chrisdone> yup
15:20:10 <kini> so don't use TH :P
15:20:13 <chrisdone> but TH slows things down anyway
15:21:54 <chrisdone> but yeah, as i said earlier, getting type info of sub-expressions can be condensed down to simply this: https://gist.github.com/chrisdone/1ac360460f99442f9efe
15:22:23 <chrisdone> and goto-definition is super easy, all names in the GHC API have a location
15:22:44 <bennofs> chrisdone: Btw, why do you write a server? Wouldn't it be easier to just accept input on stdin and write output to stdout?
15:22:45 <chrisdone> so the only two cool things that ghc-mod|hdevtools|scion do are trivial
15:23:53 <chrisdone> bennofs: because (1) i may have different clients connected, (2) i also sometimes want to compile and run code on a different machine but still have my dev environment in my local emacs
15:24:30 <bennofs> ah, in that case it makes sense of course.+
15:24:49 <chrisdone> it's following the SLIME+SWANK model =)
15:27:26 <chrisdone> axman6: did it work?
15:28:39 <Axman6> chrisdone: yeah, it's working really well. only problem is not picking up TH changes
15:28:54 <chrisdone> are you using :reload?
15:28:59 <Axman6> yeah
15:29:02 <chrisdone> yeah, don't use that
15:29:04 <chrisdone> try using :load
15:29:16 <Axman6> oh ok. so :l DevelMain?
15:29:24 <chrisdone> there's an issue in at least one ghc where :load and :reload behave differently for TH's update detection
15:29:25 <chrisdone> yeah
15:29:52 <Axman6> ok. that's easy enough to look after =)
15:29:58 <Axman6> thanks heaps chrisdone
15:30:03 <chrisdone> welcome =)
15:30:30 <chrisdone> bennofs: http://lpaste.net/6695626265233195008
15:30:34 <chrisdone> bennofs: alright? =p
15:32:14 <bennofs> chrisdone: ah, i'm trying to build ghc-server, but something in the deps forces text-0.11 (and I don't want to rebuilt all the stuff against text 0.11)
15:34:25 <chrisdone> bennofs: it's set to text >= 0.10
15:34:40 <bennofs> chrisdone: atto-lisp has an upper bound text < 0.12
15:35:14 <yitz> use --allow-newer
15:35:50 <chrisdone> bennofs: i'm not sure that the min bound i put is necessary, you can try removing the constraint
15:36:16 <chrisdone> there are four spiders crawling on my bathroom ceiling, it's like the movie Arachnophobia
15:36:18 <bennofs> yitz: oh, I forgot that cabal has this now! Thanks for reminding me, I should use that feature more (for now, I git clone'd atto-lisp and add-source'd it)
15:43:40 <chrisdone> bennofs: perhaps even my atto-lisp dependency is too high
15:43:44 <chrisdone> bennofs: does it build?
15:43:49 <bennofs> chrisdone: yes :)
15:44:32 <chrisdone> bennofs: yay. what versions of text atto-lisp bytestring attoparsec syb?
15:44:43 <chrisdone> bennofs: maybe i can lower some of the lower bounds
15:45:05 <bennofs> chrisdone: I only edited the atto-lisp text bound
15:46:04 <chrisdone> ah, the upper bound, k
15:48:04 <chrisdone> not that you can do anything useful with it yet. there's a ghc-server.el module but that's just for testing
15:59:05 <darthdeus> guys which indentation mode do you use in emacs?
15:59:42 <tremon> is there a recommended way of creating new PersistField instances, or rather to avoid ghc complaining about orphan instances?
16:01:21 <glguy> tremon: If you want to presist types that come from someone else's modules you'd need to newtype them
16:02:32 <glguy> Not not write any instances at all and work in terms of the instances provided to build up the functions you need
16:02:48 <glguy> but I haven't used the library for anything, so I don't know which is the better solution
16:05:48 <tremon> hmm... but if I newtype something, I need to re-declare all existing instances, right? i.e. no arithmetic unless I re-instantiate Num on the newtype?
16:06:00 <tremon> Or are those preserved?
16:06:52 <tremon> oh I can derive them probably
16:09:05 <FreeFull> tremon: You can with a GHC extension
16:09:18 <altern> Hi guys. What should I do with this error?  Expected type: InputT IO ()       Actual type: IO ()
16:09:35 <altern> How could I convert IO () to InputT IO ()
16:09:38 <altern> ?
16:09:40 <enthropy> altern: lift
16:10:17 <tremon> yes, ghci is telling me the same thing. -XGeneralizedNewtypeDeriving it seems
16:12:12 <ski> tremon : `{-# LANGUAGE GeneralizedNewtypeDeriving #-}' at the top of the module
16:12:26 <altern> hoogle lift
16:12:42 <pavonia> @hoogle lift
16:12:43 <lambdabot> Text.ParserCombinators.ReadPrec lift :: ReadP a -> ReadPrec a
16:12:43 <lambdabot> Control.Monad.Trans.Class lift :: (MonadTrans t, Monad m) => m a -> t m a
16:12:43 <lambdabot> Language.Haskell.TH.Syntax lift :: Lift t => t -> Q Exp
16:12:45 <michaelt> tremon: if the types are defined in packages `persistent` depends on, it might also be a good idea to send a patch, maybe
16:12:55 <pavonia> @hoogle liftIO
16:12:55 <lambdabot> Network.CGI liftIO :: MonadIO m => IO a -> m a
16:12:55 <lambdabot> Control.Monad.IO.Class liftIO :: MonadIO m => IO a -> m a
16:12:55 <lambdabot> Network.CGI liftIO :: MonadIO m => forall a. IO a -> m a
16:13:21 <altern> pavonia: thanks :)
16:16:08 <tremon> michaelt: hmm, not sure if I should. I'm deriving DiffTime because there doesn't seem to be a duration representation available yet (and it seemed easy enough to familiarize myself with the process)
16:16:14 * hackagebot stable-tree 0.4.1 - Trees whose branches are resistant to change  http://hackage.haskell.org/package/stable-tree-0.4.1 (tsuraan)
16:21:45 <carter> joelteon: how much ip monies are you looking forward to getting?
16:30:34 <rtfeldman> anyone know how to troubleshoot "Bad interface file"?
16:30:37 <rtfeldman> cabal: Bad interface file: dist/dist-sandbox-5e1c5702/build/Main.hi Something is amiss; requested module zendesk-xml-transformer-0.1.0.0:Main differs from name found in the interface file main:Main
16:31:13 <joelteon> carter: $$$$$$$$$$
16:31:23 <carter> joelteon: really?
16:31:29 <carter> congrats! :)
16:31:37 <joelteon> i have no idea
16:38:05 <Fuuzetsu> what is joelteon getting IP moneys for
16:38:27 <Fuuzetsu> why is he not sharing
16:41:24 <darthdeus> http://stackoverflow.com/questions/24130727/what-does-the-import-some-module-as-import-in-yesod-mean
16:44:04 <benzrf> heyj:
16:44:05 <benzrf> *hey
16:44:19 <benzrf> how can i make hackage generate haddock for my package
16:44:56 <deweyvm> is there a way to set a log level at the beginning of my program and have its updated value be visible anywhere else in the program (in the IO monad) without unsafePerformIO and without passing it around?
16:45:36 <zomg> deweyvm: use a reader monad or such
16:45:58 <benzrf> deweyvm: i think there's a sneaky unsafe template-haskell-using global var library
16:46:01 <benzrf> if you realllly want it
16:46:14 <zomg> seems like a questionable idea =)
16:46:25 <benzrf> deweyvm:
16:46:29 <deweyvm> setting a logging level is questionable?
16:46:31 <benzrf> main = runReaderT readerMain
16:46:38 <benzrf> readerMain = do
16:46:41 <zomg> deweyvm: no, benzrf's unsafe global var thing
16:46:42 <benzrf>   -- reader stuff here
16:46:44 <benzrf> ;)
16:47:02 <benzrf> now u can get readings in ur prog
16:47:07 <zomg> but yes, reader is the typical way of dealing with carrying over a bunch of things in your app without having to explicitly keep passing it around
16:47:15 <benzrf> dw i believe there's monadio and whatnot (y)
16:47:15 <deweyvm> and i wont have to pollute everything with reader types everywhere?
16:47:25 <benzrf> deweyvm: you will
16:47:25 <benzrf> :)
16:47:29 <benzrf> have fun!
16:47:35 <deweyvm> yuck :(
16:47:38 <benzrf> just make a keybind to write 'liftIO'
16:47:40 <benzrf> ^_^
16:47:59 <benzrf> deweyvm: it'll be GREAT trust me
16:47:59 <glguy> The questionable bit is hard-coding your code to rely on a global setting for the log level making it hard to run different parts of the program with different settings safely
16:48:01 <benzrf> :^)
16:48:15 <zomg> glguy: reader solves that too!
16:48:19 <zomg> well, kinda
16:48:20 <zomg> :P
16:48:48 <zomg> deweyvm: it's not so bad, often you'd just use a type synonym to hide the horrible monad transformer stack =)
16:48:56 <glguy> You can use Implicit Parameters as an alternative to explicit Reader
16:49:02 <zomg> type Amazing = BlahT FooT BarT IO
16:49:03 <zomg> :P
16:49:19 <glguy> If you don't mind global behavior you can squirrel away your log level in a file somewhere ^_^
16:49:41 <deweyvm> haha i did that with some things, stashing them away in my database
16:49:44 <glguy> or an environment variable
16:49:57 <deweyvm> but thats also for restartability
16:50:05 <enthropy> benzrf: all you have to do is upload the package
16:51:32 <benzrf> enthropy: it aint happening
16:51:46 <benzrf> i didnt write any haddock in
16:51:53 <benzrf> will it not autogen blank docs with just signartures
16:51:53 <enthropy> where is the package?
16:51:55 <benzrf> *signatures
16:51:57 <benzrf> http://hackage.haskell.org/package/vampire
16:52:27 <benzrf> btw, im using optparse-applicative and it seems to ignore showDefault on positionals??
16:53:26 <goldfire> copumpkin: The Data.Metrology.Z module uses singletons, which generates names like that to ensure uniqueness. I've added an Issue on github to put in a proper export list so people don't see definitions like that.
16:53:36 <Fuuzetsu> benzrf: http://hackage.haskell.org/package/vampire-0.1.0.0/reports/
16:53:40 <copumpkin> goldfire: aha, I see
16:53:51 <Fuuzetsu> benzrf: actual log http://hackage.haskell.org/package/vampire-0.1.0.0/reports/1/log
16:54:05 <Fuuzetsu>     Could not find module `Debug.Vampire.Rewrite'
16:54:19 <benzrf> oh man
16:54:47 <taktoa> benzrf: curl benzrf.com => "hello"
16:55:03 <enthropy> there really needs to be a link to those reports in hackage
16:55:16 <Fuuzetsu> I made an issue about that
16:55:20 <Fuuzetsu> or someone else did
16:55:24 <Fuuzetsu> either way there should be an issue
16:55:41 <Fuuzetsu> maybe it even was already fixed or has a PR
16:55:55 <benzrf> taktoa: eh
16:55:58 <benzrf> taktoa: hmm
16:56:01 <benzrf> taktoa: why
16:56:28 <taktoa> benzrf: just pointing that out, you should probably make a homepage or something
16:56:38 <benzrf> taktoa: does it matter :L
16:56:48 <taktoa> benzrf: not really
16:57:10 <benzrf> taktoa: i'm just this guy, y'know?
16:57:18 <taktoa> lol
16:57:26 <Fuuzetsu> benzrf: Debug.Vampire.Rewrite is not in your cabal file
16:57:32 <benzrf> o.O
16:57:34 <benzrf> oops.
16:57:48 <Fuuzetsu> (which also means it's not in the actual package for everyone else)
16:58:09 <Fuuzetsu> cabal sdist won't include it if you don't say it should
16:58:21 <benzrf> shit.
16:58:51 <benzrf> showDefault in optparse-applicative is not working for me ;-;
17:04:50 <Zekka> Hey -- I was tempted to screw around with Yesod a bit and was wondering if there was a preferred way to use it in a sandbox given that as far as I remember using it requires using some extra executables and I don't know if I want to put a sandbox on my PATH
17:05:22 <Zekka> Would copying the Yesod binaries to my user-level cabal bin directory be a sane/acceptable approach?
17:07:36 <zwer_f_s> where is whenM defined?
17:07:59 <benzrf> zwer_f_s: do you mean when
17:08:00 <benzrf> :t when
17:08:01 <lambdabot> Monad m => Bool -> m () -> m ()
17:08:20 <zwer_f_s> no. whenM :: Monad m => IO Bool -> m () -> m ()
17:08:33 <zwer_f_s> or rather
17:08:38 <Zekka> zwer_f_s: Are you sure that's a standard function?
17:08:40 <zwer_f_s> no. whenM :: Monad m => m Bool -> m () -> m ()
17:08:50 <zwer_f_s> I thought I saw it somewhere, but now I'm not sure
17:08:53 <Zekka> Hoogle (the resource you usually use for this sort of thing) doesn't believe it exists: http://www.haskell.org/hoogle/?hoogle=whenm
17:08:57 <syllogismos> "Error while building extra package: random-fu: Warning: The package list for 'hackage.haskell.org' does not exist. Run 'cabal update' to download it." fpcomplete is giving me this error when trying to add an extra package in settings
17:10:17 <syllogismos> I'm not able to add an extra package in fpcomplete, anybody know how to do it properly?
17:11:03 <Zekka> zwer_f_s: You can define it as whenM x a = x >>= flip when a
17:11:42 <ab9rf> syllogismos: have you tried running 'cabal update'?
17:11:59 <Zekka> @pf \x a -> x >>= flip when a
17:11:59 <lambdabot> Maybe you meant: pl bf
17:12:03 <Zekka> @pl \x a -> x >>= flip when a
17:12:04 <lambdabot> (. flip when) . (>>=)
17:12:16 <Zekka> or that delightfully straightforward definition
17:12:43 <syllogismos> in fpcomplete? how do I run cabal update in fpcomplete?
17:12:52 <benzrf> i git push -f entirely too often :T
17:13:49 <Tene> D:
17:13:52 <Tene> shaaaaaaame
17:17:30 <zwer_f_s> Zekka thanks.. looks like I was wrong, it doesn't appear to be defined anywhere
17:17:54 <Zekka> zwer_f_s: No problem. Sorry that I couldn't come up with a better answer than "it's easy to define yourself, at least"
17:21:36 <benzrf> taktoa: ok i updated my homepage
17:21:39 <benzrf> happy?
17:22:00 <taktoa> benzrf: gg
17:22:37 <benzrf> taktoa: there is a *hidden message* on this page!
17:22:55 <taktoa> <!-- 嘀혀阀䜀Ȁ嘀✀ᘀ܀㜀Ȁ蘀㘀圀혀Ȁ䜀Ȁ嘀最ᘀ蘀Ȁ圀需 -->
17:22:57 <Fuuzetsu> I'm viewing your site in emacs minibuffer and you can't stop me
17:23:34 <taktoa> gibberish http://i.imgur.com/PBnkOpm.png
17:23:38 <benzrf> or is it
17:23:51 <taktoa> maybe the unicode codepoints mean something
17:23:53 <benzrf> can u solve the mistery
17:24:10 <benzrf> spoopy
17:24:22 <taktoa> spoopy indeed
17:24:42 <taktoa> yeah I think I'm going to go back to my anime
17:24:47 <benzrf> taktoa: the answer is
17:24:47 <taktoa> too lazy
17:24:57 <benzrf> taktoa: if you convert it to a series of 4-digit hex codepoints
17:24:58 <benzrf> then reverse
17:25:01 <benzrf> then translate back
17:25:02 <benzrf> you get
17:25:04 <benzrf> 'you have too much spare time'
17:25:18 <taktoa> lol, I actually probably could have gotten that
17:25:23 <benzrf> yes
17:25:28 <benzrf> the goal was to make it solveable
17:25:32 <benzrf> *if* you have too much spare time
17:25:33 <benzrf> :-)
17:31:24 * hackagebot vampire 0.1.1.0 - Analyze and visualize expression trees.  http://hackage.haskell.org/package/vampire-0.1.1.0 (benzrf)
17:32:02 <Eduard_Munteanu> Is there a MonadBaseControl IO instance for ConduitM a b IO ?
17:33:58 <pavonia> benzrf: Why is this vampire package evil?
17:34:10 <benzrf> pavonia: look at the code to find out :-)
17:38:26 <kini> Is it possible for me to define a function in a let-binding inside a parametrically polymorphic outer function, such that the inner function's type contains type variables bound by the forall on the outer function's type?
17:38:48 <Eduard_Munteanu> kini: yes, ScopedTypeVariables
17:38:55 <kini> thanks, I'll look into it
17:39:59 <Fuuzetsu> benzrf: what is it meant to do
17:41:01 <rogeth> someone could explain me how this function succHead works? (http://dpaste.com/18D716G/)
17:41:02 <rogeth> please
17:41:41 <Fuuzetsu> rogeth: it adds one to the first element of the pair at the front of the list
17:41:59 <kini> Eduard_Munteanu: perfect, that's exactly what I needed :) thanks!
17:42:17 <Fuuzetsu> rogeth: what aspect do you not understand?
17:42:48 <Eduard_Munteanu> kini: sure, you just asked a good question :)
17:42:55 <Fuuzetsu> (honestly it should be using a non-empty list type)
17:43:04 <Eduard_Munteanu> Asked it well, rather.
17:43:35 <rogeth> Fuuzetsu: I think I got it! just a minute
17:44:06 <johnw> @unmtl StateT s m a
17:44:06 <lambdabot> s -> m (a, s)
17:44:21 <benzrf> Fuuzetsu: what's what meant to do
17:44:30 <Fuuzetsu> benzrf: vampire
17:44:39 <benzrf> something along these lines http://imgur.com/a/BGBtg
17:45:30 <Fuuzetsu> cool
17:45:39 <Fuuzetsu> but I think there's a package that does this already
17:45:49 <benzrf> orly
17:46:06 <kini> Eduard_Munteanu: I had to think for a minute before formulating it, to figure out what exactly I was trying to do :)
17:46:25 * hackagebot pipes-wai 3.0.0 - A port of wai-conduit for the pipes ecosystem  http://hackage.haskell.org/package/pipes-wai-3.0.0 (IanDuncan)
17:46:27 <kini> GHC's error messages can be kind of scary but also very helpful
17:46:40 <Fuuzetsu> maybe http://felsin9.de/nnis/ghc-vis/#basic-usage is what I'm thinking of
17:47:01 <benzrf> Fuuzetsu: not even comparable
17:47:02 <kini> what tipped me off to what was going on was the "Relevant bindings" section of the error message, where a bunch of variables that I thought would all be of type a, were variously of type a and a2 :)
17:47:06 <benzrf> that shows ghc data structures
17:47:10 <Fuuzetsu> yes I know
17:47:13 <benzrf> Fuuzetsu: vampire shows haskell expr trees :-)
17:47:25 <benzrf> Fuuzetsu: look closer at that tree eh
17:47:26 <kini> and then I realized that all the expressions of type a2 were from inside the inner function...
17:48:31 <Fuuzetsu> could have sworn there was one
17:48:34 <Fuuzetsu> yes I did
17:49:48 <Shoop> Beginner here - I need a program to open a file (its a list of words) and then use it in other functions at other places in my program. The only issue is that the IO monad is getting everywhere and annoying me. Any way to isolate it?
17:50:21 <gratimax> If you really hate it, use the unsafe IO method
17:50:31 <gratimax> But that would not be recommended
17:50:45 <Shoop> gratimax: so I just have to deal with it? It will pollute every single function call
17:51:02 <kini> Shoop: it won't pollute every single function call... just the top one, right? which should be inside a do-block
17:51:02 <gratimax> well, what do you mean by 'use it in other functions'
17:51:12 <Shoop> gratimax: basically everything is based on looking up words in that file
17:51:18 <Zekka> Shoop: You could probably include it at compiletime by cheating with TemplateHaskell, but it's up to you whether that's more or less evil than unsafePerformIO
17:51:42 <Shoop> this is still an IO [String]: dict = do  	x <- readFile "words.txt" 	return (lines x)
17:51:53 <gratimax> I would assume that you're calling a function based on the words in the file, and that would do all you need to do
17:52:01 <benzrf> Shoop: well of course it is
17:52:06 <benzrf> what would you expect it to be
17:52:26 <Shoop> gratimax: that function is now returning an IO Bool
17:52:28 <kini> right, but instead of making it a top level variable, accept it as a [String] (not IO [String]) parameter to functions which need it
17:52:33 <Fuuzetsu> Shoop: you read in the file in main and then pass in the words to your pure functions as normal
17:52:39 <Fuuzetsu> the only IO part is reading the file
17:52:42 <kini> and when calling those functions, do "foo <- dict ; f foo"
17:52:50 <kini> then foo will be pure, of type [String]
17:52:59 <Shoop> Fuuzetsu: oh that makes sense, thanks :)
17:53:03 <gratimax> Shoop: as Fuuzetsu and I are suggesting, use a pure function with the words
17:53:04 <Zekka> I'm assuming his situation is similar to the awkward sensation you can end up in when there's a constant your whole program deals with which is best expressed as a huge data file
17:53:09 <Fuuzetsu> :t readFile "foo" <$> words
17:53:10 <lambdabot>     Couldn't match expected type ‘[String] -> b’
17:53:10 <lambdabot>                 with actual type ‘IO String’
17:53:10 <lambdabot>     Possible cause: ‘readFile’ is applied to too many arguments
17:53:11 <gratimax> I probably did not put it clearly, sorry
17:53:15 <Fuuzetsu> uh
17:53:20 <Zekka> where you'd really rather store it as a constant in a top-level variable
17:53:20 <Shoop> Zekka: yeah
17:53:21 <Fuuzetsu> :t words <$> readFile "foo"
17:53:22 <lambdabot> IO [String]
17:53:29 <Fuuzetsu> :t words
17:53:30 <lambdabot> String -> [String]
17:53:47 <Zekka> In which case you can unsafePerformIO, include it at compile-time with TemplateHaskell evil, or (probably the best option) use the Reader monad
17:53:57 <Shoop> Fyyzetsu: what is this magical <$> you speak of???
17:54:02 <Zekka> Shoop: Infix fmap
17:54:07 <Shoop> oh
17:54:07 <Zekka> :t (<$>)
17:54:08 <lambdabot> Functor f => (a -> b) -> f a -> f b
17:54:09 <Fuuzetsu> :t fmap
17:54:10 <lambdabot> Functor f => (a -> b) -> f a -> f b
17:54:27 <Shoop> I like you lambdabot
17:54:29 <Zekka> where f can be [], Maybe, Either c, etc.
17:54:36 <Zekka> Yeah, lambdabot is really great
17:54:40 <Shoop> mhmmm, i've read up on functors
17:54:44 <Fuuzetsu> this would do just fine to: do fileContent <- readLine "foo"; let result = words foo; …
17:55:01 <Shoop> ok well thanks
17:55:03 <Fuuzetsu> np
17:55:05 <Zekka> IO, being a monad, is also a functor, so you can do anything you would ordinarily do with a functor with it
17:55:12 <Zekka> And read up on Reader, it's probably pretty close to what you want
17:55:21 <Zekka> although I'd probably say screw it and unsafePerformIO in your shoes
17:55:44 <Shoop> Zekka: sounds goof
17:55:46 <Shoop> *good
18:00:03 <benzrf> Zekka: what is justifying an unsafePerformIO ?!
18:00:37 <Zekka> benzrf: The amount of clunky syntax involved in using Reader for what's essentially a constant that's too large to include in literal form?
18:02:22 <benzrf> ok
18:02:25 <benzrf> what constant
18:02:55 <Zekka> benzrf: The constant he's putting in his data file that he's loading initially?
18:03:17 <benzrf> oh
18:03:18 <ab9rf> so just wrap main with "do bigAssConstant <- readFile; main"
18:03:31 <benzrf> why not put it in a haskell file and import it
18:03:36 <benzrf> instead of some other fmt
18:03:36 <Zekka> ab9rf: And how does bigAssConstant get into any other functions?
18:03:54 <benzrf> Zekka: magic~
18:04:02 <benzrf> implicit params :-)
18:04:12 <ab9rf> Zekka: sounds like someone has a global data dependency problem they haven't adequately addressed
18:04:52 <Zekka> ab9rf: For what it's worth, if it's something that's not legimately an unchanging constant, like a hidden parameter or some such thing, I'm far more in favor of Reader
18:05:15 <ab9rf> if it's really an "unchanging constant" just stuff it into a module
18:05:16 <Zekka> wrt to what benzrf said, what do you mean implicit params? Do you mean hiding the params in the type using something like Reader or do you mean something I'm not aware of?
18:06:09 <ab9rf> write a one-time source transformer that converts it from whatever format its in into haskell source
18:06:38 <ab9rf> if it's really too large to do that with, then it should probably be treated as an external datasource
18:06:40 <Zekka> ab9rf: Isn't that essentially what I suggested with "use templatehaskell" except slightly less evil because you're doing the slice manually at the expense of having to manually rewrite everything should the data ever change?
18:07:34 <benzrf> Zekka: implicitparams is a gross extension that allows reader-style arguments without reader type pollution
18:07:48 <benzrf> they act like dynamically scoped vars, basically
18:07:55 <Zekka> Oh, I just googled
18:08:07 <benzrf> but you shouldnt use it unless you're writing something really awful
18:08:12 <Zekka> That's pretty high up on the evil hierarchy, wouldn't you say?
18:09:05 <Zekka> From a superficial glance it looks like it basically lets you write functions that depend on values from the outside world
18:09:28 <benzrf> no, it lets you pass reader-style implied args through functions without their knowledge
18:09:31 <Zekka> it looks like you basically lose out completely on equational reasoning for the sake of reader is scary
18:09:59 <benzrf> you just need to imagine any implicit args as explicit args ;)
18:10:03 <benzrf> they do show up in the type
18:10:04 <Zekka> benzrf: I'll clarify -- I know what it's actually doing.
18:10:07 <benzrf> kk
18:10:11 <benzrf> 09:06 < benzrf> but you shouldnt use it unless you're writing something really awful
18:10:19 <benzrf> i.e. vampire :-)
18:10:27 <Zekka> I'm just imagining myself having to refactor code that uses this and cringing
18:10:32 <benzrf> i know, right
18:11:19 <Zekka> Also, I only skimmed Vampire but I'm going to assume that whatever it does must be pretty impressive and very useful to justify code that looks like that
18:12:00 <Zekka> from what I can tell it's doing some messy transformation of source code for the purpose of later doing analysis
18:12:58 <benzrf> Zekka: nah, it's just a toy
18:13:24 <benzrf> Zekka: but basically it takes an expression and generates a tree of expressions
18:13:40 <benzrf> Zekka: the key part being that it does it runtime-wise
18:13:46 <benzrf> so function nesting, etc
18:13:54 <benzrf> c.f. 4th image in http://imgur.com/a/BGBtg
18:13:56 <Zekka> runtime-wise? I don't follow
18:13:59 <Zekka> I'll look
18:15:37 <Zekka> Yeah, I see what's going on
18:15:55 <Zekka> it explains "and this is how you might evaluate that code"
18:16:11 <benzrf> precisely :-)
18:16:30 <benzrf> but i figure it could theoretically be handy for debugging
18:16:49 <benzrf> you transform a limited section of your program that's misbehaving, then scan the tree for bits that look wrong
18:16:55 <Zekka> Reminds me, actually, have you had any luck with the ghci debugger?
18:16:59 <benzrf> nah
18:17:04 <benzrf> i think i tried it once
18:17:07 <Zekka> I remember trying to step through my code and finding it pointlessly confusing
18:17:14 <benzrf> yep
18:17:27 <Zekka> it seemed to use a 'step into' strategy which is kind of hilarious in the context of a lazily evaluated language
18:18:01 <benzrf> yeah :|
18:18:30 <Zekka> I think a tree's probably the best way to represent it
18:27:21 <benzrf> Zekka: http://www.berniepope.id.au/docs/BerniePope.PhD.Thesis.pdf
18:28:46 <Zekka> benzrf: Is his tool very often used/supported?
18:30:45 <benzrf> Zekka: it isnt on hackagebot
18:30:47 <benzrf> *hackage
18:30:51 <benzrf> i cant find a download
18:30:51 <benzrf> q.q
18:30:58 <benzrf> i found a man page for it when i googled
18:31:00 <benzrf> but no src
18:31:01 <benzrf> :I
18:32:09 <cyclizine> hey
18:32:23 <benzrf> h
18:32:29 <cyclizine> I am relatively new to haskell and would like some help with a very basic genetic algorithm I attempted to write
18:33:00 <cyclizine> http://lpaste.net/955006237626335232
18:33:16 <cyclizine> essentially the problem is that it hangs when 'mutate' or 'crossover' are used
18:33:45 <cyclizine> mutate only hangs when mapM'd over a list of genomes
18:33:58 <cyclizine> but seems fine when called on a single element
18:34:14 <cyclizine> if anyone has any pointers I would be very grateful
18:34:47 <Zekka> cyclizine: Going to look your code over, give me a moment
18:36:31 <Zekka> cyclizine: Unless you're working with infinite lists I don't see any obvious problems, but from what I hear mapM has some nonobvious gotchas I don't feel qualified to comment on
18:36:50 <cyclizine> hmm
18:37:38 <Zekka> My first thought is that if I remember right what I've heard, mapM is often excessively strict
18:38:02 <Zekka> but I don't remember in which cases -- there's probably someone in here who knows better what the mapM gotchas are though
18:42:26 <cyclizine> bye
18:51:40 * hackagebot ghc-mod 4.1.2 - Happy Haskell Programming  http://hackage.haskell.org/package/ghc-mod-4.1.2 (KazuYamamoto)
19:09:30 <jmcarthur> benzrf: so i looked up vampire and i still don't know what it actually does. it looks like some sort of heap inspection?
19:09:40 <jmcarthur> ah no
19:09:42 <jmcarthur> something else
19:13:08 <benzrf> jmcarthur: try it yourself :-)
19:13:13 <benzrf> 1. cabal install vampire
19:13:18 <benzrf> 2. write a simple module
19:13:33 <benzrf> 3. `vampire rewrite SimpleModule.hs Vampired.hs`
19:13:38 <StoneCypher4k> i agree, that's much better than a pleasant straight answer
19:14:02 <benzrf> 4. ghci >> :l Vampired >> import Debug.Vampire >> viewExpr (\_ -> [call some function in the module])
19:14:07 <benzrf> StoneCypher4k: o u
19:14:55 <benzrf> jmcarthur: it shows expression trees
19:15:21 <benzrf> i.e. 'foo (a + b) (f 3)' has children 'foo', 'a + b', and 'f 3'
19:15:26 <benzrf> etc recursively
19:15:42 <benzrf> given that first expr, vampire builds a tree of these children and the value each expr & subexpr has
19:15:47 <benzrf> it works into functions, too
19:15:57 <benzrf> i.e. 'f 3' has the children '3', and '[function']
19:16:16 <benzrf> and '[function]' has child 'whatever the body of f is when the arg is 3'
19:26:45 * hackagebot handle-like 0.0.0.8 - HandleLike class  http://hackage.haskell.org/package/handle-like-0.0.0.8 (YoshikuniJujo)
19:36:46 * hackagebot handle-like 0.0.0.9 - HandleLike class  http://hackage.haskell.org/package/handle-like-0.0.0.9 (YoshikuniJujo)
19:39:44 <pepper_chico> is haskell cache friendly?? does the compiler make wise usage of list as contiguous data if possible, instead of linked list implementation or are there any specific resources for this?
19:40:33 <pepper_chico> as of now, I'm manipulating lists without knowing their implementation bits & trade-offs
19:40:57 <geekosaur> lists are specifically linked lists. if you want something better, use a different data type
19:41:16 <geekosaur> (linked lists have their place; in particular they fuse well, meaning that in many cases they end up not existing at all)
19:41:30 <AfC> If I add an orphan instance in another file, will that module export that instance?
19:42:02 <AfC> [It's a QuickCheck Arbitrary; I'd rather quick-check be a dependency of just the test suite and not the library; other tests need it]
19:42:45 <rwbarton> modules always export any instances that are defined in the module or imported from other modules
19:42:53 <geekosaur> AfC, not entirely sure what you are asking but referencing the module with the instance at all ... that
19:43:15 <geekosaur> pepper_chico: if you want more guarantees than lists give you, use Vector or Array
19:43:25 <AfC> rwbarton: ok, so we just need to stick the Arbitrary instances in a common module that all the test cases use?
19:43:56 <pepper_chico> geekosaur: fuse?? in c++ for example, you have arrays, std::list's which are linked lists, std::vectors, which have contiguous memory. Generally, in the c and c++ realm, linked lists are not promoted over vectors, they have their place, but given fragmentation of memory, it's best to stick with vectors when possible
19:44:09 <pepper_chico> geekosaur, ok
19:44:25 <pepper_chico> I wanted to know about those resources
19:44:31 <geekosaur> list fusion basically means the compiler looks for ways to eliminnate the list entirely and generate a fast loop
19:44:38 <dsfjdfdsf> what is the best way to start learning haskell?
19:44:44 <pepper_chico> ah ok, nice
19:44:56 <pepper_chico> dsfjdfdsf I'm starting now
19:45:01 <pepper_chico> some days already
19:45:12 <geekosaur> this is possible when (lazy!) list element production and comsumption are linked, such that each element can be directly consumed as it is generated
19:45:18 <pepper_chico> I'm following http://learnyouahaskell.com/
19:45:21 <dsfjdfdsf> is learn haskell for great good any good?
19:45:21 <pepper_chico> very nice
19:45:28 <pepper_chico> yeah
19:45:31 <pepper_chico> it's a nice book
19:45:36 <pepper_chico> at last for me
19:45:41 <geekosaur> it's a little bit dated at this point but most of it --- and all the concepts --- is still correct
19:45:51 <pepper_chico> the reading is good, it has humor and content
19:46:01 <dsfjdfdsf> how did you learn, geekosaur
19:46:03 <dsfjdfdsf> ?
19:46:06 <ajcoppa> dsfjdfdsf, pepper_chico: another commonly recommended learning resource is brent yorgey's cis194 course: seas.upenn.edu/~cis194/lectures.html
19:46:19 <ajcoppa> sorry: http://www.seas.upenn.edu/~cis194/lectures.html
19:46:24 <pepper_chico> ajcoppa, thanks
19:46:43 <geekosaur> heh. I used the old Gentle Introduction, which isn't very gentle. but there weren't many other resources around back then and in any case I had already been exposed to both scheme and SML
19:46:47 * hackagebot pipes-wai 3.0.1 - A port of wai-conduit for the pipes ecosystem  http://hackage.haskell.org/package/pipes-wai-3.0.1 (IanDuncan)
19:46:49 * hackagebot pipes-wai 3.0.2 - A port of wai-conduit for the pipes ecosystem  http://hackage.haskell.org/package/pipes-wai-3.0.2 (IanDuncan)
19:46:54 <frodwith> i tried lyah, had better luck with real world haskell
19:46:58 <ajcoppa> it has exercises to implement, so that helps reinforce the concepts more than just reading and playing.
19:47:09 <pepper_chico> I'll finish this book and then, take the other more advanced up to date stuff
19:47:09 <pepper_chico> cool
19:47:27 <ajcoppa> the course is about the same pace as LYAH. you can do them side-by-side if you like
19:47:29 <crazydave> oooh thanks ajcoppa, I've been looking for more learning stuff on monads especially.  Lecture material looks like a good way to do it (especially if it has exercises)
19:47:47 <dsfjdfdsf> cool
19:48:01 <pepper_chico> I exercise with LYHFGG by trying to write implementation of what he describes before he shows the code =D
19:48:26 <spoonman> Hey guys, so with school out I got to spend a whopping two hours on this module getting some practice in with my new favorite language. Anyone care to give a brutal critique? http://lpaste.net/105366
19:48:39 <pepper_chico> he generally describes the problem well before showing up code
19:48:47 <ajcoppa> crazydave: if you're up for it, the NICTA course is a pretty tough but very illuminating one. you'll write instances for a bunch of functors, applicatives, and monads
19:48:57 <ajcoppa> https://github.com/NICTA/course
19:50:58 <crazydave> NICTA is involved with haskell research. Cool.  I might check that out also.
19:51:29 <crazydave> I have the problem that I used to understand monads, then I read about monad transformers and learnt that Maybe was a monad and not just IO.
19:51:30 <ajcoppa> there's also a #haskell-beginners channel. all questions welcome in here of course, just some extra chatter in there that may help you
19:51:46 <crazydave> Then I decided that I didn't understand monads afterall and needed to learn again.
19:52:14 <d3m1g0d-> monads are hard
19:53:52 <crazydave> d3mig0d: yep!
19:54:35 <ajcoppa> i wouldn't mystify them too much. implementing a bunch of examples via the NICTA course will likely help
19:55:01 <pepper_chico> I dunno yet what's a monad, didn't got there in the book, but it seems everything is monads haha, funny that leibniz had a metaphysical theory of everything built upon stuff called monads
19:55:27 <johnw> it's not that they themselves are hard; it's seeing them in the way that makes them appear simple which is hard
19:55:51 <crazydave> spoonman: I am no expert but: 1) you can derive Show and Eq for that type, no need to implement them yourself.  And if you are going to implement show then you should do it as part of the Show type class so you can say `let z = Complex 1.0 1.0 in show z` rather than having to use showComplex
19:55:51 <pepper_chico> hmm
19:56:15 <crazydave> (oh wait, you did that ... I missed that ... haha)
19:58:32 <spoonman> crazydave: Interesting. Thanks!
20:00:07 <crazydave> oh, and also on Show: show is meant to be used for serializing a Haskell type: specifically one should be able to do `read . show`as an identity.  Your show is for pretty printing ... you can keep that method but don't call it show.  show should display something like {Complex 1.0 2.0}
20:01:29 <spoonman> I did not know that. Thanks again
20:02:56 <crazydave> me either ... I did what you did the first time I implemented a type ... changed the default show method to be how I wanted the type displayed.  Then happened to come across the description of show ... possibly from hackage.
20:03:18 <dfranke_> So, it turns out that if you use enough evil extensions, you can actually hack row types into Haskell quite easily.
20:03:29 <dfranke_> http://lpaste.net/105369
20:04:32 <dfranke_> I'm still trying to figure out if I can do it without OverlappingInstances or FunctionalDependencies.
20:04:42 <pepper_chico> is there a way to have Int constants in a short form? 1 is generic and I get some warnings regarding default association to Integer. I know I can do 1 :: Int, is there other thing?
20:05:05 <mikeplus64> > let int :: Int -> Int; int a = a in int 54
20:05:07 <pepper_chico> like 1i
20:05:07 <lambdabot>  54
20:05:26 <benzrf> row types?
20:05:33 <dfranke_> (the instances don't *actually* overlap, but GHC can't prove that they don't)
20:06:07 <pepper_chico> heh, ok then
20:06:32 <benzrf> wots a row type
20:06:55 <crazydave> pepper_chico: possibly adding type signatures to your functions that the types get used in.  Now ghc will infer that it has to be an Int and not and Integer
20:07:02 <dfranke_> benzrf: https://www.cs.cmu.edu/~neelk/rows.pdf
20:09:06 <tnks> anyone done a performance comparison of Data.Map to DataHamtMap?
20:09:28 <pepper_chico> crazydave yeah... but I'd like the functions generics, for example, usage of generic lists, but when trying out with [1, 2, 3, 4], since it's not typed, I get the warning
20:09:28 <pepper_chico> [1::Int, 2, 3, 4], or as mikeplus64 said, [int 1, 2, 3, 4] would mute the warnings
20:09:28 <tnks> I'm curious if Data.HamtMap is a reasonable default for most cases.
20:11:06 <enthropy> dfranke_: make a class class HasField1 (b :: Bool) r (k :: Symbol) v | b r k -> v where
20:11:55 <mikeplus64> > let int a = a :: Int; proxy :: (a -> a) -> f a -> f a; proxy _ a = a in proxy int [1,2,3,4]
20:11:57 <lambdabot>  [1,2,3,4]
20:13:32 <dfranke_> enthropy: oh, I see. Then I instantiate it once with False and once with True, preventing the instances from overlapping?
20:14:38 <pepper_chico> mikeplus64 my wish was just [1i, 2, 3, 4]
20:14:41 <pepper_chico> =)
20:20:06 <enthropy> dfranke_: add another class like my annotation http://lpaste.net/105369
20:24:48 <dfranke_> enthropy: ah, very nice!
20:25:07 <dfranke_> I think that's sufficient to get rid of the FDs, too.
20:25:13 <dfranke_> replace them with a type function.
20:26:09 <copumpkin> jmcarthur_mobile, newsham: I may finally have a model I like for picklers
20:26:35 <copumpkin> it got clearer once I started thinking of it as a language problem
20:26:46 <copumpkin> I'll show you something when I finish hacking this up
20:26:52 * hackagebot typeparams 0.0.3.1 - Lens-like interface for type level parameters; allows unboxed unboxed vectors and supercompilation  http://hackage.haskell.org/package/typeparams-0.0.3.1 (MikeIzbicki)
20:28:15 <Church-> d3m1g0d- Are we talking monads as in the abstract algebra/group theory math concept?
20:28:28 <copumpkin> category theory
20:28:38 <Church-> Ah
20:28:44 <Church-> Thanks.
20:29:14 <copumpkin> :)
20:36:59 <enthropy> dfranke: dunno if that'd be an improvement. For example you if you store numeric literals in there, I'm not sure a constraint like `HasFieldR (RowCons k v r) k ~ Int', gets to imply that v ~ Int
20:44:11 <aspidites> :hoogle
20:44:26 <aspidites> oh. maybe no
20:47:16 <pavonia> @hoogle maybe
20:47:17 <lambdabot> Prelude maybe :: b -> (a -> b) -> Maybe a -> b
20:47:17 <lambdabot> Data.Maybe maybe :: b -> (a -> b) -> Maybe a -> b
20:47:17 <lambdabot> Foreign.Marshal.Utils maybeNew :: (a -> IO (Ptr a)) -> (Maybe a -> IO (Ptr a))
20:52:00 <impaulnou> What sorts of changes are being considered by the Haskell committee?
20:53:57 <lispy> impaulnou: that's a good question. I haven't kept up but they have a website.
20:54:17 <lispy> impaulnou: https://ghc.haskell.org/trac/haskell-prime/wiki/Committee
20:56:19 <impaulnou> Thanks
20:56:58 * hackagebot s3-signer 0.1.0.0 - Pre-signed Amazon S3 URLs  http://hackage.haskell.org/package/s3-signer-0.1.0.0 (DavidJohnson)
20:58:06 <lispy> impaulnou: the spirit of that committee is to solidify existing extensions that are good and commonly used
20:58:37 <lispy> impaulnou: You can think of them as taking the available research and adding non-controversial bits of it to the standard.
21:02:51 <codygman> How can I turn a tuple like (2, 0, 0) into the number 200?
21:03:13 <vanila> f (x,y,z) = x*100 + y*10 + z
21:05:11 <codygman> vanila: Hm, that should work for the other status codes too. Guess you've worked with the HTTP library before and used that?
21:05:21 <vanila> yes
21:09:19 <dfranke> enthropy: now I have a working RowDrop constructor too :-)
21:38:23 <Maxdamantus> > [False..]
21:38:25 <lambdabot>  <hint>:1:9: parse error on input ‘]’
21:38:39 <Maxdamantus> > let f = False in [f..]
21:38:40 <lambdabot>  can't find file: L.hs
21:38:46 <zwer> > [False ..]
21:38:48 <lambdabot>  [False,True]
21:38:53 <Maxdamantus> Ahah.
21:39:06 <Maxdamantus> What's significant about `False..`?
21:39:11 <Maxdamantus> oh, could be a package?
21:39:20 <Maxdamantus> the `.` operator in the False package.
21:39:33 <Maxdamantus> No. I think that would require backticks.
21:39:52 <Maxdamantus> (or brackets)
21:40:50 <zwer> I am not quite sure why they decided a space is needed there
21:42:27 <marc8> how do i append two Maybe Strings?
21:43:22 <Heffalump> what would you expect to happen if one is Nothing?
21:43:46 <lfairy> marc8: what behavior do you want if one of them is Nothing?
21:43:47 <marc8> same as Just ""
21:44:10 <zwer> > Just "hi" <> "there"
21:44:12 <lambdabot>  Couldn't match expected type ‘Data.Maybe.Maybe [GHC.Types.Char]’
21:44:12 <lambdabot>              with actual type ‘[GHC.Types.Char]’
21:44:19 <zwer> > Just "hi" <> Just "there"
21:44:20 <lambdabot>  Just "hithere"
21:44:51 <lfairy> marc8: if Nothing is equivalent to "", then make it so
21:45:08 <marc8> what do you mean?
21:45:09 <shachaf> lfairy: What?
21:45:23 <lfairy> that came out wrong
21:45:47 <lfairy> if Nothing is equivalent to Just "", why don't simply use "" to represent both?
21:45:59 <marc8> > Just "hi" <> Nothing
21:46:00 <lambdabot>  Just "hi"
21:46:22 <marc8> I am processing some elses data so I dont have a choice
21:46:22 <dmj`> @typ concat . catMaybes
21:46:24 <lambdabot> [Maybe [a]] -> [a]
21:46:52 <dmj`> > concat . catMaybes $ [Just "hey", Nothing, Just " there"]
21:46:53 <lambdabot>  "hey there"
21:47:24 <marc8> > catMaybes $ [Just "hey", Nothing, Just " there"]
21:47:26 <lambdabot>  ["hey"," there"]
21:54:03 <glguy_> > fold [Just "1", Nothing, Just "2"]
21:54:04 <lambdabot>  Just "12"
21:57:48 <Heather> parsers-0.11.0.2 fails to build in travis, why?
22:02:06 * hackagebot event-list 0.1.1 - Event lists with relative or absolute time stamps  http://hackage.haskell.org/package/event-list-0.1.1 (HenningThielemann)
22:42:10 * hackagebot count 0.0.1 - Bijective mappings between values and possibly infinite prefixes of [0..]  http://hackage.haskell.org/package/count-0.0.1 (Maxdamantus)
23:08:18 <carter> lfairy: hows the hackage hacking?
23:08:52 <lfairy> carter: working out how best to display the build reports
23:08:58 <carter> lfairy: YAY
23:09:06 <carter> lfairy: +++
23:09:08 <lfairy> :)
23:09:10 <carter> important work
23:09:19 <carter> start with something dumb that can be shipped tomorrow
23:09:24 <carter> then just polish it :)
23:09:33 <carter> we need it like.... 6 months ago :)
23:15:21 <lfairy> carter: sure -- though tomorrow is a bit of a stretch...
23:17:30 <carter> k
23:17:52 <carter> how about just a link to the really ugly stuff on the package pages
23:17:56 <carter> even that would be huge
23:18:07 <carter> most people dont' even know about the */reports path
23:20:16 <lfairy> I don't know if that's worth it, tbh
23:20:49 <lfairy> who runs the deployment/admin stuff? is rebuilding hackage much trouble?
23:21:00 <lfairy> *updating the server
23:22:17 <enthropy> if it's lots of trouble to update it, then there's another problem to fix
23:25:15 <carter> lfairy: #haskell-infrastructure
23:25:26 <carter> is the channel to have that chat on
23:27:09 <lfairy> carter: thanks
23:28:14 <lfairy> methinks I might as well do it pesudo-properly
23:28:30 <carter> lfairy: both
23:28:31 <carter> please
23:28:32 <carter> both
23:28:44 <lfairy> can you wait a week?
23:28:50 <lfairy> that's about how much time it'll take
23:29:34 <carter> cool
23:29:35 <carter> lfairy: :)
23:29:39 <carter> i don't need it
23:29:41 <carter> but most people do
23:29:52 <carter> just getting that basic info more visible would help many folks
23:29:58 <lfairy> yeah
23:30:40 <lfairy> I guess having exams next week is a good thing, since it's a natural limiting factor
23:31:04 <carter> no pressue
23:31:15 <carter> just saying "start with helping people get the dumb info"
