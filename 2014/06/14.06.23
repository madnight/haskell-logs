00:01:06 <jle`> Welkin: there's also lens stuff if you are inclined
00:01:11 <jle`> > "1011" ^? binary
00:01:13 <lambdabot>  Just 11
00:01:20 <MP2E> huh, nice
00:01:31 <Welkin> I haven't touched lens just yet
00:01:36 <Welkin> I'm working my way toward that
00:01:47 <jle`> you don't really need to understand lens; it's just a function
00:01:56 <jle`> :t (^? binary) `asAppliedTo` ""
00:01:57 <lambdabot> Integral a => [Char] -> Maybe a
00:02:16 <jle`> String -> Maybe Int
00:02:39 <Welkin> this is for a scheme interpreter
00:02:49 <Welkin> would lens be helpful elsewhere in the program?
00:03:17 <jle`> the answer is most likely, but probably not necessarily necessary
00:04:03 <Welkin> I'm also having trouble with `head` on the return value of readInt/readOct/readHex since it returns [(a,b)], but [] if it fails
00:04:17 <Welkin> I could use safeHead, but is there a better way?
00:04:38 <jle`> :t listToMaybe
00:04:39 <lambdabot> [a] -> Maybe a
00:04:47 <jle`> > listToMaybe [1,4,2]
00:04:48 <lambdabot>  Just 1
00:04:50 <jle`> > listToMaybe []
00:04:51 <lambdabot>  Nothing
00:05:02 <Welkin> :t safeHead
00:05:03 <lambdabot> Not in scope: ‘safeHead’
00:05:17 <jle`> Maybe is just a list with 0 or 1 elements anyway
00:05:30 <Welkin> I thought about using Maybe
00:05:43 <Welkin> I didn't know about the ListToMaybe function though
00:05:47 <Welkin> thanks
00:05:54 <pavonia> > fst <$> listToMaybe [(11,"")]
00:05:56 <lambdabot>  Just 11
00:05:57 <Welkin> safeHead doesn't exist?
00:06:02 <tdammers> Welkin: headMay
00:06:07 <tdammers> or headDef
00:06:10 <tdammers> :t headMay
00:06:10 <Welkin> I remember seeing it somewhere
00:06:11 <lambdabot> Not in scope: ‘headMay’
00:06:21 <tdammers> [a] -> Maybe a
00:06:38 <tdammers> tailSafe does exist
00:06:45 <tdammers> but that's because there's a sensible default
00:06:57 <abstract-alf> let xs = [] in case xs of; [] -> Nothing; (x:_) -> Just x
00:07:03 <abstract-alf> safeHead, right?
00:07:11 <abstract-alf> > let xs = [] in case xs of; [] -> Nothing; (x:_) -> Just x
00:07:12 <lambdabot>  Nothing
00:07:14 <abstract-alf> > let xs = [1] in case xs of; [] -> Nothing; (x:_) -> Just x
00:07:15 <tdammers> abstract-alf: that's headMay
00:07:16 <lambdabot>  Just 1
00:07:50 <tdammers> and the reason it's called headMay, not safeHead or headSafe, is because there are *two* safe head variants
00:08:02 * hackagebot simple-sendfile 0.2.15 - Cross platform library for the sendfile system call  http://hackage.haskell.org/package/simple-sendfile-0.2.15 (KazuYamamoto)
00:08:02 * hackagebot JustParse 2.1 - A simple and comprehensive Haskell parsing library  http://hackage.haskell.org/package/JustParse-2.1 (grantslatton)
00:08:08 <tdammers> and their signatures are both different from `head`
00:08:16 <tdammers> whereas tailSafe has the same signature as `tail`
00:08:48 <abstract-alf> > tail []
00:08:49 <lambdabot>  *Exception: Prelude.tail: empty list
00:09:02 <abstract-alf> ah, why not just return []?
00:09:07 <abstract-alf> :t tailSafe
00:09:08 <lambdabot> Not in scope: ‘tailSafe’
00:09:09 <jle`> tailSafe = drop 1
00:09:11 <jle`> :P
00:09:15 <jle`> abstract-alf: historical reasons
00:09:24 <abstract-alf> > drop 1 []
00:09:26 <lambdabot>  []
00:09:30 <abstract-alf> bangin'
00:09:41 <jle`> liftA2 (:) head tail === id
00:09:55 <tdammers> the idea was that (x:xs) == head (x:xs):tail (x:xs)
00:10:04 <jle`> and for empty lists, it should fail for both
00:10:21 <abstract-alf> ok, that makes sense
00:11:16 <Welkin> > fromMaybe . listToMaybe (Just 4)
00:11:18 <lambdabot>  Couldn't match expected type ‘a -> b’
00:11:18 <lambdabot>              with actual type ‘Data.Maybe.Maybe a0’Couldn't match expected ty...
00:11:18 <lambdabot>              with actual type ‘Data.Maybe.Maybe a1’
00:11:21 <jle`>  @check \xs -> (not (null xs)) ==> ((head xs : tail xs) == xs)
00:11:24 <Welkin> er
00:11:30 <jle`> @check \xs -> (not (null xs)) ==> ((head xs : tail xs) == xs)
00:11:31 <lambdabot>  +++ OK, passed 100 tests.
00:11:33 <Welkin> > fromMaybe . listToMaybe [4]
00:11:34 <lambdabot>  Couldn't match expected type ‘a -> b’
00:11:35 <lambdabot>              with actual type ‘Data.Maybe.Maybe a0’
00:11:45 <jle`> > (fromMaybe . listToMaybe) [4] -- perhaps?
00:11:47 <lambdabot>  <Maybe (Maybe Integer) -> Maybe Integer>
00:11:49 <abstract-alf> woh, quickcheck with lambdabot? noice
00:13:19 <jle`> oh you need a default for fromMaybe
00:13:21 <abstract-alf> :t not . null
00:13:22 <lambdabot> [a] -> Bool
00:13:28 <jle`> > (fromMaybe 0 . listToMaybe) [4]
00:13:29 <lambdabot>  4
00:13:48 <jle`> there's also maybeToList
00:14:00 <jle`> Maybe [a] is isomorphic to [a] or something rather, i think
00:14:06 <Welkin> :t maybeToList
00:14:07 <lambdabot> Maybe a -> [a]
00:14:32 <jle`> which is why i wish there was a Maybe [a] -> [a] function because i use all the time alas.
00:14:40 <Maxdamantus> What would `Nothing` mean?
00:14:46 <abstract-alf> jle`: (not . null) :: [a] -> Bool ... does quickcheck look at the first element of that type declaration to determine what inputs to pass in?
00:14:49 <jle`> Nothing would be the same as Just []
00:15:09 <haasn> :t fromMaybe []
00:15:11 <lambdabot> Maybe [t] -> [t]
00:15:16 <Maxdamantus> That's not an isomorphism, is it?
00:15:16 <jle`> abstract-alf: it looks at the input yes
00:15:17 <tdammers> jle`: catMaybes?
00:15:19 <jle`> haasn: oh yeah
00:15:26 <jle`> haasn: i was using that
00:15:29 <tdammers> oh wait no
00:15:29 <Welkin> I guess I'll handle this when I get to implementing error handling...
00:15:30 <jle`> but it feels a little ugly
00:15:50 <tdammers> jle`: wrap it in a function then
00:16:01 <jle`> there might be a way to do it using Foldable?
00:16:05 <jle`> with one function from the typeclass?
00:16:16 <jle`> it's like some generic concat
00:16:46 <haasn> :t toListOf (folded.folded)
00:16:48 <lambdabot> (Foldable f1, Foldable f) => f (f1 a) -> [a]
00:17:15 <Welkin> > fromJust Nothing
00:17:17 <lambdabot>  *Exception: Maybe.fromJust: Nothing
00:17:28 <Welkin> > fromMaybe 0 Nothing
00:17:30 <lambdabot>  0
00:17:31 <Maxdamantus> Prelude Data.Count> fromMaybe $ Just [1, 2]
00:17:32 <Maxdamantus> [-1,-1,0]
00:17:47 <Maxdamantus> This version of fromMaybe is reversible.
00:17:55 <jle`> what is that?
00:18:04 <Maxdamantus> fromMaybe :: Countable a => Maybe [a] -> [a]; fromMaybe = fromPos . toPos
00:18:25 <jle`> > concat . toList $ Just [1,3,5]
00:18:27 <lambdabot>  Not in scope: ‘toList’
00:18:27 <lambdabot>  Perhaps you meant one of these:
00:18:27 <lambdabot>    ‘F.toList’ (imported from Data.Foldable),
00:18:27 <lambdabot>    ‘IS.toList’ (imported from Data.IntSet),
00:18:27 <lambdabot>    ‘S.toList’ (imported from Data.Set)
00:18:31 <jle`> > concat . F.toList $ Just [1,3,5]
00:18:33 <lambdabot>  [1,3,5]
00:19:03 <jle`> oh there's literally concat
00:19:09 <Maxdamantus> It converts the `Maybe [a]` to the position it has in a list of `Maybe [a]`s.
00:19:11 <jle`> > F.concat (Just [1,5,2])
00:19:12 <lambdabot>  [1,5,2]
00:19:16 <jle`> woo hoo
00:19:25 <jle`> i alwasy thought there wasn't
00:19:25 <Maxdamantus> Then produces the `[a]` at that position in a list of `[a]`s.
00:20:22 <abstract-alf> is F a module alias?
00:20:27 <jle`> Data.Foldable
00:20:35 <jle`> :t F.concat `asAppliedTo` Nothing
00:20:36 <lambdabot> Maybe [a] -> [a]
00:20:55 <abstract-alf> :t F.concat
00:20:56 <lambdabot> Foldable t => t [a] -> [a]
00:21:26 <abstract-alf> what are some other foldable instances?
00:21:27 <Maxdamantus>  fromMaybe $ Just ["foo", "bar"] .. ["goo","aar",""]
00:21:51 <jle`> trees
00:21:54 <jle`> maps
00:22:00 <abstract-alf> ah, right
00:22:11 <jle`> foldable are "things that can be sequence_'d"
00:22:29 <jle`> so... like, Map k (IO a) -> IO (Map k a)
00:22:31 <jle`> er sorry
00:22:36 <jle`> that's Traversable
00:22:45 <jle`> Map k (IO a) -> IO ()
00:22:52 <abstract-alf> how is Foldable different from Traversable?
00:23:03 <jle`> Foldable doesn't preserve the internal structure
00:23:21 <jle`> so with Foldable you can go Map k (IO a) -> IO ()    --- sequence every IO action in a map
00:23:36 <jle`> with Traverse you can go Map k (IO a) -> IO (Map k a) --- sequence every IO action, and return a map of the result of the actions
00:23:40 <jle`> :t sequence
00:23:41 <lambdabot> Monad m => [m a] -> m [a]
00:23:50 <jle`> :t T.sequence `asAppliedTo` M.empty
00:23:51 <lambdabot> Monad m => M.Map k (m a) -> m (M.Map k a)
00:24:07 <jle`> Traversable are "things that can be 'sequence''d"
00:24:16 <abstract-alf> :t asAppliedTo
00:24:17 <lambdabot> (a -> b) -> a -> a -> b
00:24:35 <jle`> you can also think of Foldable as having a toList, or things you can wrote a foldr over
00:25:01 <jle`> when you go toList, you "lose" the structure of the Foldable...like losing the structure of a Map
00:25:28 <Zekka> My intuition for Traversable -- they're like functors that provide effectful fmap, called traverse
00:25:45 <Zekka> (sequence alone doesn't give you the power of fmap -- traverse does)
00:25:49 <Zekka> :t traverse
00:25:51 <lambdabot> (Traversable t, Applicative f) => (a -> f b) -> t a -> f (t b)
00:26:14 <Zekka> So it's like fmap except aggregating Applicative side effects with sequence
00:28:01 <jle`> yeah, in that sense, it's things that can be mapM'd
00:28:08 <jle`> :t mapM
00:28:10 <lambdabot> Monad m => (a -> m b) -> [a] -> m [b]
00:28:16 <abstract-alf> oh, so a Traversable is also a Foldable
00:28:26 <pjdelport> http://www.haskell.org/haskellwiki/Foldable_and_Traversable
00:28:28 <jle`> :t T.mapM `asAppliedTo` Nothing
00:28:29 <lambdabot>     Couldn't match expected type ‘a -> m b’ with actual type ‘Maybe a0’
00:28:30 <lambdabot>     In the second argument of ‘asAppliedTo’, namely ‘Nothing’
00:28:30 <lambdabot>     In the expression: T.mapM `asAppliedTo` Nothing
00:28:32 <jle`> er
00:29:02 <jle`> mapM :: Monad m => (a -> m b) -> Maybe a -> m (Maybe b)
00:29:03 <pjdelport> One way to think of it is that Foldable + Functor → Traversable
00:29:07 <abstract-alf> pjdelport, nice link
00:29:23 <pjdelport> Particularly, Foldable doesn't require Functor, but Traversable does.
00:30:01 <abstract-alf> what are the light-gray, dashed arrows between Applicative->Monad, and Alternative->MOnadPlus
00:30:04 <pjdelport> Functor captures the shape-preserving nature of Traversable.
00:30:05 <abstract-alf> ?
00:30:33 <jle`> mapM_ is very useful for generic containers
00:30:40 <jle`> a lot of times you just want to execute every item in a container
00:30:51 <jle`> mapM_ for Maybe lets you treat Maybe as a list of 0 or 1 items
00:31:03 <pjdelport> abstract-alf: They're relations that should be there, but aren't quite, due to hysterical raisins. But that is in the process of getting fixed: see http://www.haskell.org/haskellwiki/Functor-Applicative-Monad_Proposal
00:31:04 <Welkin> http://www.haskell.org/haskellwiki/Typeclassopedia#Introduction <-- dotted/grey arrows explained here
00:31:19 <jle`> mapM_ for Map k lets you treat a Map k (IO a) as a container of many IO actions...a list of may IO actions, where the eements are the values
00:31:38 <pjdelport> Welkin: Those dotted/gray arrows are different.
00:31:47 <Welkin> oh, really
00:32:08 <Welkin> hm
00:32:33 <abstract-alf> Welkin, thanks for the link anyway.  I haven't read this page yet
00:33:36 <abstract-alf> pjdelport, I remember hearing something about that in an episode of The Haskell Cast
00:33:53 <Welkin> there is a podcast?
00:34:04 <abstract-alf> http://www.haskellcast.com/
00:34:17 <Welkin> Chris Done
00:34:29 <abstract-alf> http://www.haskellcast.com/episode/001-edward-kmett-on-lenses/
00:34:33 <Welkin> monad burritos
00:37:51 <Walther> ...holy crap. I had heard the "look ma, that monad looks like a burrito" reference a couple times already, but hadn't actually read what it's all about - aaaand the explanation actually kinda makes sense http://blog.plover.com/prog/burritos.html
00:39:24 <Welkin> http://chrisdone.com/posts/monads-are-burritos
00:39:34 <abstract-alf> The unit function for burritos is obviously a tortilla.
00:41:35 <abstract-alf> :t mplus
00:41:37 <lambdabot> MonadPlus m => m a -> m a -> m a
00:45:22 <abstract-alf> > do; getLine >>= putStrLn
00:45:24 <lambdabot>  <IO ()>
00:45:26 <abstract-alf> err
00:45:36 <abstract-alf> > do; l <- getLine; putStrLn l
00:45:38 <lambdabot>  <IO ()>
00:45:53 <abstract-alf> that's equivalent to getLine >>= putStrLn, right?
00:46:05 <ion> yes
00:46:31 <ion> > do;;;;42;;;;  -- I never realized this is valid
00:46:33 <lambdabot>  42
00:46:50 <Welkin> > ;;;;;
00:46:52 <lambdabot>  <hint>:1:1: parse error on input ‘;’
00:46:55 <Welkin> > ;;;;;42
00:46:57 <lambdabot>  <hint>:1:1: parse error on input ‘;’
00:47:02 <abstract-alf> needs more semicolons
00:47:04 <Welkin> > 42;;;;;
00:47:06 <lambdabot>  <hint>:1:3: parse error on input ‘;’
00:47:08 <abstract-alf> keep trying
00:47:11 <Welkin> > do;;;;;42;;;;;
00:47:13 <lambdabot>  42
00:47:15 <abstract-alf> nailed it
00:47:19 <ion> > let;;;;;;;;in 42
00:47:21 <lambdabot>  42
00:47:26 <abstract-alf> what the hell? haha
00:47:45 <pjdelport> class Burrito b where { tortilla :: a -> b a; stuff :: (a -> b) -> ; rewrap :: b (b a) -> b a }
00:47:50 <Welkin> :t ;
00:47:51 <lambdabot> parse error on input ‘;’
00:47:53 <Welkin> :t (;)
00:47:54 <lambdabot> parse error on input ‘;’
00:48:16 <pjdelport> class Burrito b where { tortilla :: a -> b a; stuff :: (a -> c) -> b a -> b c; rewrap :: b (b a) -> b a } even
00:48:16 <abstract-alf> ; isn't a function
00:48:24 <abstract-alf> ; is a line terminator
00:48:34 <abstract-alf> just like in c-like languages
00:48:37 <Welkin> > let; in 42
00:48:39 <lambdabot>  42
00:48:42 <Welkin> > let in 42
00:48:44 <lambdabot>  42
00:48:52 <ion> In C-like languages it’s a statement terminator.
00:48:53 <abstract-alf> > let the right one in
00:48:55 <lambdabot>  <hint>:1:19: parse error on input ‘in’
00:48:57 <Welkin> > let in "yo mama"
00:48:58 <lambdabot>  "yo mama"
00:49:09 <abstract-alf> > let in "the right one"
00:49:11 <lambdabot>  "the right one"
00:49:16 <abstract-alf> > let in "the dog"
00:49:18 <lambdabot>  "the dog"
00:49:24 <ion> It works in private, too.
00:49:30 <abstract-alf> sorry ;)
00:49:34 <Welkin> does it work over /notice?
00:49:47 <Welkin> no
00:50:12 <ion> It should not respond to a /notice because that very point of NOTICE is to be the command bots use to send messages and the command bots never respond to. This avoids all bot loops.
00:50:34 <abstract-alf>  /m lambdabot > "the cat"
00:50:44 <Welkin> /msg
00:56:27 <abstract-alf> so, (do; l <- getLine; putStrLn l) is the same as (getLine >>= putStrLn)
00:56:38 <Welkin> yes
00:56:41 <abstract-alf> I imagine it is probably actually desugared to (getLine >>= (\l -> putStrLn l))
00:58:34 <abstract-alf> isn't that how the names of intermediates are bound in large do statements?
00:58:41 <abstract-alf> with lambda arguments?
01:00:31 <pjdelport> abstract-alf: Yeah
01:01:14 <abstract-alf> :D
01:02:55 <pjdelport> Also, nicer applicative style: putStrLn =<< getLine
01:03:30 <abstract-alf> how is that nicer?
01:03:40 <abstract-alf> reads left to right?
01:03:51 <triliyn> It looks more like a normal function application
01:03:53 <tdammers> reads a bit like a pure function call
01:03:57 <abstract-alf> ah
01:03:58 <pjdelport> abstract-alf: It reads applicatively, like putStrLn $ getLine
01:04:33 <pjdelport> abstract-alf: analagous to <$> / `fmap` and <*> / `ap` and such
01:05:54 <abstract-alf> ahh <$> == `fmap`
01:05:58 <abstract-alf> thanks for that
01:07:27 <abstract-alf> Monads are part of the standard library, not the language, right?
01:07:36 <abstract-alf> Monad, rather
01:08:05 <pjdelport> abstract-alf: Both. It's part of the language in the form of do syntax, at least.
01:08:18 <abstract-alf> ok, that was my real question
01:08:34 <pjdelport> But otherwise, you can think of it as more of a standard library thing, yeah.
01:08:36 <abstract-alf> do syntax was added to the language after the Monad library was writtne
01:08:52 <abstract-alf> strange to have a language feature that depends on a library
01:10:05 <pjdelport> abstract-alf: It's not really strange; think of "", [], if, etc.
01:10:27 <abstract-alf> or maybe it's strange for all those cases!
01:10:32 <ion> also: list comprehensions
01:10:50 <abstract-alf> good points
01:11:43 <pjdelport> And numbers, obviously.
01:12:05 <pjdelport> Enums to go with [..] syntax.
01:14:51 <hunt> is ghc --make any different from regular ghc?
01:15:14 <corgifex> depends on what you're doing with it, but in most cases --make is the default
01:20:13 <Welkin> :t readBin
01:20:14 <lambdabot> Num a => ReadS a
01:20:33 <Welkin> :t readOct
01:20:34 <lambdabot> (Num a, Eq a) => ReadS a
01:20:45 <Welkin> :t ReadS
01:20:47 <lambdabot> Not in scope: data constructor ‘ReadS’
01:20:55 <Welkin> @src ReadS
01:20:56 <lambdabot> Source not found.
01:21:26 <Welkin> :i ReadS
01:21:34 <Welkin> :info ReadS
01:21:38 <Welkin> @info ReadS
01:21:38 <lambdabot> ReadS
01:23:05 <ttll> hi everybody, I'm working on a small DSL for list processing and want to write methods of the style "run $ \a b c d = [d, c, b, a]"
01:24:18 <ttll> if there are four or more list elements, it should apply the function on the head of the list, otherwise it should return Nothing
01:24:19 <pjdelport> Welkin: You can /query lambdabot if it's just for personal use. :)
01:24:45 <vanila> ttll, what about using numbers: run [4,3,2,1]
01:25:00 <vanila> or a data type with letters A,B,C,D
01:25:03 <hunt> ttll: you could right something like: f (a:_:_:_:_) = Just a; f (_) = Nothing
01:25:14 <pjdelport> ttll: Can you give an example of what you mean?
01:25:38 <hunt> write
01:25:39 <hunt> *
01:25:43 <ttll> that would work as well but I the other method is a prettier I think ;)
01:25:49 <vanila> run f (a:b:c:d:_) = run [a,b,c,d] ; run _ _ -> Nothing
01:25:52 <hunt> ttll: whats the other method?
01:26:41 <simon> ttll, so you're making a DSL in which one should be able to easily specify that if a list contains 4+ elements, a function should be applied to the first element.
01:26:43 <ttll> using proper function arguments rather than pattern matching (and always handling the case where there aren't enough arguments)
01:26:59 <vanila> oops
01:27:05 <vanila> run f (a:b:c:d:_) = run a b c d ; run _ _ -> Nothing
01:27:23 <vanila> you need differnet functions for each number of args
01:27:32 <ttll> okay
01:27:34 <vanila> or you could make a "run" typeclass
01:27:42 <vanila> but then you'll get annoying confusing type errors
01:28:18 <hunt> ttll: you could do run f x | length x >= 4 -> f $ head x
01:28:31 <ttll> I was trying the "Run" typeclass route but I'm stuck
01:28:35 <hunt> ttll: | otherwise = Nothing
01:28:55 <hunt> also that arrow should be an =, got mixed up
01:29:05 <ttll> I have >50 methods for stack transformations so I want to reduce boilerplate as much as possible
01:29:31 <simon> hunt, wouldn't work for infinite lists
01:29:33 <vanila> ohh
01:29:48 <vanila> run f (a:b:c:d:xs) = run a b c d : xs ; run _ _ -> Nothing
01:29:53 <hunt> simon: damn youre right
01:29:56 <vanila> run f (a:b:c:d:xs) = run a b c d ++ xs ; run _ _ -> Nothing
01:29:58 <vanila> actually
01:30:27 <ttll> yeah but then I have to specify the -> Nothing case for every function
01:30:58 <vanila> Just (run a b c d ++ xs) in fact
01:31:15 <simon> ttll, run f (x:(xs@(_:_:_:_))) = (f x) : xs; run f xs = xs ?
01:31:35 <hunt> ttll: ive done something like this where i used Map to create a a map of functions and their conditions. you could have a Map Int f, where int represents the number of arguments
01:32:11 <simon> I don't get where the need for Maybe comes from.
01:32:31 <simon> and I'm not sure why you call making a function to serve a purpose for a DSL.
01:32:32 <hunt> ttll: and if no function is found you return maybe, which is natural for the Map type
01:32:41 <hunt> ttll: er, nothing
01:32:59 <hunt> ttll: am i understnading what you want to do correctly?
01:33:21 <ttll> maybe I've simplyfied too much
01:33:31 <vanila> oh
01:33:36 <vanila> it's actually hard to make a typeclass to do this
01:33:47 <simon> ttll, you've described one problem that can be solved with a function rather than a DSL.
01:33:53 <vanila> your functions are of type (a -> (a -> (a -> (... -> [a]))))
01:34:02 <vanila> and the typeclass needs to "see" [a]
01:34:09 <hunt> ttll: what exaclt are you looking for here
01:34:40 <vanila> so there might need to be a differnt way to actually embed this stack based language into haskell
01:34:59 <solrize> @pl \n->replicate n n
01:34:59 <lambdabot> join replicate
01:35:21 <ttll> okay I think I failed to explain myself properly, I should probably just link to the repo ;)
01:35:24 <hunt> vanila: what are we trying to do here? are we trying to take a function l i ke that and have it operate on some data?
01:36:01 <ttll> https://github.com/OttoAllmendinger/haskoin/blob/full-script/Network/Haskoin/Script/Evaluator.hs
01:36:57 <vanila> ttll, what about like this http://pastebin.com/uGek0VA3
01:37:01 <ttll> so using tStack1 tStack2 tStack3... I basically can implement eval OP_2DUP etc the way I want to
01:37:27 <hunt> side note is the style ttll uses for the "eval" function, one function matched against the contents of an enum, standard for running parsed  stuff?
01:37:55 <ttll> I'm wondering that as well, I've seen different styles out there
01:37:56 <vanila> wait it looks like you've already got it that way
01:38:56 <ttll> it works but I am looking for a way to cut it down some more
01:39:09 <hunt> ttll: where in the file is the problem?
01:39:54 <ttll> getting rid of tStack1... tStack6 and the tStackL functions and replacing them with a generic solution
01:42:46 <hunt> ttll: i think i have an idea
01:42:47 <hunt> ttll: one sec
01:47:10 <ttll> something that would allow "eval OP_EQUAL = run (==)" would be amazing
01:49:45 <hunt> ttll: im pretty sure quickcheck solves this problem
01:49:59 <ttll> my intuition is to declare "instance Eq a => StackFunction (a -> a -> Bool)" for that but it doesn't work sadly
01:50:23 <ttll> right
01:50:35 <hunt> ttll: it does right?
01:51:28 <hunt> ttll: because you need away to apply something repeatedly to a function with variable arguments
01:51:52 <hunt> ttll: if you could pattern match on (a->b) this would be solved...
01:53:27 <ttll> yeah I was thinking that as well, I think it's somewhere in https://github.com/nick8325/quickcheck/blob/master/Test/QuickCheck/Function.hs
01:53:46 <simon> @pl \a b -> [encodeBool (a == b)]
01:53:47 <lambdabot> flip flip [] . (((:) . encodeBool) .) . (==)
01:54:01 <simon> hrm.
01:55:32 <hunt> ttll: i think the idea for quickcheck is tht there is a typeclass Testable, which implements quickcheck. Then they instantiate (Testable a, Testable b) =>Testable  (-> a b)
01:55:41 <hunt> ttll: so you need a Runnable typeclass
01:55:51 <pjdelport> You could perhaps use Typeable for this.
01:55:56 <hunt> with Runnable (-> a b)
01:56:04 <hunt> and Runnable StackValue
01:56:26 <hunt> er (Runnable a, Runnable b) => Runnable (-> a b)
01:56:35 <hunt> ttll: you think that would work? you mentioned trying something like it
01:57:54 <ttll> I think it should, I'll look into it
01:58:19 <ttll> it's a good place to start, thanks guys!
01:58:28 <hunt> ttll: no problem!
02:01:30 <lfairy> ttll: http://lpaste.net/106166
02:03:35 <hunt> lfairy: this stuff is so clever
02:04:28 <lfairy> hunt: no problem :)
02:04:29 <lfairy> I'd already done something like that with another project, so it wasn't out of whole cloth
02:05:00 <Welkin> lfairy is obviously a robot
02:05:11 <hunt> lfairy: this is the quickcheck solution as well, right?
02:06:27 <lfairy> hunt: I'm not sure
02:07:30 <lfairy> note that the result type has to be "wrapped up" somehow
02:07:42 <lfairy> in this case, it's in a list []
02:07:43 <hunt> lfairy: im pretty sure its similar http://hackage.haskell.org/package/QuickCheck-2.7.5/docs/Test-QuickCheck-Property.html#t:Testable
02:07:53 <lfairy> that stops it from overlapping with the (->) instance
02:08:25 <lfairy> oh yeah, that is it
02:08:53 <hunt> lfairy: still every time i see this stuff it just makes me reel
02:09:13 <hunt> there must be so many more brilliant tricks like this you can pull with haskell
02:09:22 <lfairy> hunt: don't worry, you'll get used to it
02:11:34 <lfairy> wait a sec - it doesn't need to be wrapped, as the return type is concrete :p
02:11:39 <lfairy> but it works out anyway
02:15:04 <Fuuzetsu> @tell enthropy anchors should work, if they aren't then please make an issue on GitHub with some test code
02:15:04 <lambdabot> Consider it noted.
02:17:13 <abstract-alf> > take 10 $ randomRs (1,9) $ mkStdGen 1
02:17:15 <lambdabot>  [3,5,2,9,2,8,9,8,5,5]
02:17:17 <abstract-alf> > take 10 $ randomRs (1,9) $ mkStdGen 1
02:17:19 <lambdabot>  [3,5,2,9,2,8,9,8,5,5]
02:17:35 <abstract-alf> suppose I need 10 random numbers every time my program runs
02:18:03 <abstract-alf> how do I make sure I don't get the *same* 10 "random" numbers?
02:18:27 <lfairy> abstract-alf: look for functions with 'IO' in them
02:18:37 <lfairy> they're actually random
02:19:39 <pyrtsa> abstract-alf: newStdGen
02:19:51 <abstract-alf> :t newStdGen
02:19:52 <lambdabot> IO StdGen
02:20:00 <abstract-alf> there's one!
02:20:30 <lfairy> yaaaay
02:20:45 <hunt> in do notation is bind (>>=) ever automatically called, or is it  just a sequence of (>>)?
02:20:52 <pjdelport> http://lpaste.net/106167 -- Dubious Typeable hacks
02:20:56 <jle`> hunt: what do you mean?
02:21:04 <abstract-alf> hunt: >>= is called when you 'bind' an action to a name
02:21:05 <jle`> do notation is just a straightforward desugaring
02:21:10 <pjdelport> ttll: -^
02:21:10 <cstanfill> bind corresponds to <- right?
02:21:15 <jle`> @undo do { x <- f; g x }
02:21:15 <lambdabot> f >>= \ x -> g x
02:21:17 <cstanfill> and >> only happens when you don't ahve a <-
02:21:23 <jle`> @undo do { x <- f; y; g x }
02:21:23 <lambdabot> f >>= \ x -> y >> g x
02:21:24 <hunt> jle`: oh my god
02:21:24 <pjdelport> ttll: That's probably not an appropriate solution, but nonetheless. :)
02:21:26 <hunt> so wait
02:21:33 <abstract-alf> do a <- getLine
02:21:34 <hunt> bind literally means youre binding the results to a function
02:21:43 <hunt> of the name you provide
02:21:44 <jle`> er
02:21:45 <hunt> in the context of do
02:21:49 <abstract-alf> do a <- getLine; putStrLn a
02:21:52 <jle`> i mean
02:21:55 <jle`> words
02:22:03 <abstract-alf> that's getLine >>= (\a -> putStrLn a)
02:22:13 <jle`> bind literally means the bind operator (>>=) which is a weird name for the operator anyway
02:22:18 <abstract-alf> I learned that tonight ;)
02:22:43 <jle`> semantically, it "binds the result" to the given name for the rest of the do block
02:22:56 <hunt> jle`: that is so cool
02:23:18 <jle`> i like thinking of it as
02:23:26 <ttll> pjdelport: this also goes to the branch "need-to-wrap-my-head-around-this"
02:23:31 <jle`> you know like putStrLn "hello" >> putStrLn "world"
02:23:39 <jle`> (>>) in this context takes two IO ()'s and turns them into one fat IO ()
02:23:48 <jle`> do { putStrLn "hello"; putStrLn "world" }
02:23:58 <jle`> it's kind of like a monoid operation in this sense. sorta
02:24:35 <jle`> so if i have an object that represents printing 'hello' and an object that represents printing 'world', i can combine them using a handy API offered by the IO type into an object representing printing 'hello' then 'world'
02:24:45 <hunt> jle`: whats a good use case for a monad, i think i want to write my own
02:25:00 <jle`> um
02:25:25 <jle`> that's like asking about writing your own Monoid or Functor or Num
02:25:27 <jle`> heh
02:25:31 <jle`> it's not so useful to just make out out of a vacuum.
02:25:33 <jle`> buuuuut
02:25:39 <jle`> if you really must, try writing an interpreter
02:25:44 <jle`> that's a common thing people do
02:25:48 <hunt> jle`: not using parsec
02:25:57 <jle`> http://chris-taylor.github.io/blog/2013/02/09/io-is-not-a-side-effect/
02:25:58 <hunt> jle`: are you saying to write the parsec part?
02:26:07 <jle`> write your own IO monad :)
02:26:10 <jle`> from scratch
02:26:17 <hunt> lol, could it actually do anything?
02:26:30 <ArisFr> Hi, I would like to read and parse 180 files with conduit resulting in a list with one entry per file. I would like to do this in parallel since the parsing seems to be the bottleneck. Since I am in IO, which would be the most appropriate technique/library to use? Note that I cant just spawn 180 threads. I would probably need an equivalent to a thread pool.
02:26:33 <jle`> can haskell's built in IO do anything?
02:26:47 <jle`> (the answer is under many interpretations no)
02:26:50 <pjdelport> ttll: That approach inspects the concrete type of the function you pass in. "unfun" is a slightly awkward that strips one layer of (->) from the type constructor representation, and sig just uses that to give you list of the function's parameter types.
02:27:02 <jle`> IO is just a normal data type, just like any ADT you can cuncoct
02:27:22 <jle`> when i say "build your own IO monad", i really mean "build your own data type representing computation"
02:27:25 <jle`> which is what IO is
02:27:30 <jle`> just a representation of computation
02:27:34 <jle`> IO doesn't do anything
02:27:45 <jle`> does a list do anything?
02:27:51 <jle`> does Maybe do anything?
02:28:00 <hunt> jle`: tomorrow i will
02:28:04 <hunt> jle`: my brain is ea d
02:28:10 <hunt> jle`: (from sleep)
02:28:13 <jle`> m k
02:28:14 <hunt> sleeplessness
02:28:17 <hunt> M k
02:28:44 <jle`> these days it is more trendy to write interpreter monads using Free
02:28:58 <jle`> that is, make an interpreter Functor and throw it in a Free
02:29:07 <jle`> but I think there's something to be gained from doing it from scratch
02:29:07 <trap_exit> is there any theoretical connection etween types (as in Haskell) and schemas (as in SQL tables)
02:29:14 <ttll> pjdelport: cool
02:29:26 <abstract-alf> jle`: I think I want to try what you describe
02:29:31 <trap_exit> I'm trying to think: "what is the right way to do queries in haskell", and this issue popped up
02:29:41 <jle`> abstract-alf: the article i linked walks one through the approach without Free
02:30:00 <jle`> um. i think there's a haskellforall post somewhere that describes building one using Free
02:30:05 <jle`> yes there is
02:30:15 <jle`> http://www.haskellforall.com/2012/07/purify-code-using-free-monads.html
02:30:17 <sgronblo> ive always had a bit of trouble making sense of the "computation" aspect of monads
02:30:27 <ttll> I'll try the approach without using reflection APIs first I think, otherwise I'll get lost
02:30:35 <sgronblo> the expression is too vague
02:30:50 <jle`> sgronblo: i don't think monads have any inherent computation aspect
02:31:34 <jle`> rather, it is that computations can be manipulated rather well with a 'monadic api'
02:31:55 <jle`> i don't like saying "monads are ___"
02:32:06 <jle`> :/
02:32:24 <jle`> unless the ____ is "monads"
02:32:25 <abstract-alf> it means little to say "monads are ___"?
02:32:35 <jle`> "monads are wrapped values"
02:32:38 <jle`> "monads are plans"
02:32:41 <jle`> "monads are computations"
02:32:43 <jle`> "monads are burritos"
02:32:47 <jle`> etc.
02:32:51 <abstract-alf> "monads are value contexts"
02:32:55 <jle`> exactly
02:33:03 <jle`> the only thing that should go in that blank
02:33:05 <jle`> is monads
02:33:06 <abstract-alf> :D I get it now
02:33:07 <jle`> "monads are monads"
02:33:25 <jle`> unless it is some equivalent mathematical definition
02:33:40 <jle`> (monads aren't "value contexts", if you misinterpreted me)
02:33:58 <abstract-alf> oh :'(
02:34:03 <jle`> :'(
02:34:06 <jle`> sry
02:34:16 <jle`> how about
02:34:40 <jle`> "the implementation of value contexts can be greatly benefited from a monadic interface"
02:35:11 <jle`> or "value contexts is a nice application for monad"
02:35:26 <pjdelport> Instead of "monads are *", it's much better to say "Certain computations are monads", or "Certain data structures are monads"
02:35:59 <Yuu_chan> jle`: what about "monads are instances of Monad typeclass"?
02:36:18 <jle`> Yuu_chan: would you say that monoids are instances of Monoid? :P
02:36:50 <abstract-alf> such general statements are pretty much worthless, imo
02:37:19 <jle`> people trying to attach semantic meaning to monads is i think at the root of much of the misunderstanding around them and their perceived complexity
02:37:37 <sgronblo> monads are generic interfaces that allow function composition with implicit unwrapping, allows for ordering of "actions" in a pure language, allows for implicit bailing out on errors
02:37:44 <sgronblo> anything missing? :)
02:37:51 <Yuu_chan> jle`: of course! :)
02:38:04 <jle`> there are plently of monoids that aren't instances of Monoid, however! :O
02:38:06 <pjdelport> sgronblo: If you mean "fail" by the latter, that's not part of monads in general.
02:38:12 * hackagebot querystring-pickle 0.2.0 - Picklers for de/serialising Generic data types to and from query strings  http://hackage.haskell.org/package/querystring-pickle-0.2.0 (BrendanHay)
02:38:14 <Yuu_chan> sgronblo: that's an ad-hoc definition
02:38:20 <jle`> sgronblo: what is "implicit unwrapping"?
02:38:25 <jle`> Monads have nothing to do with unwrapping
02:38:37 <pjdelport> (It's part of Haskell's Monad, but that's regarded as a historical mistake and/or convenience.)
02:38:41 <abstract-alf> jle`: so, the trick to monads is not to think about monads? think about monad instances instead?
02:38:51 <jle`> he probably is referring to "short circuiting behavior", from Either/Maybe
02:38:58 <Yuu_chan> jle`: it's often explained this way in >>=
02:39:06 <jle`> which implemented using a monadic interface
02:39:16 <sgronblo> jle`: thats what the bind is doing for you?
02:39:24 <pjdelport> abstract-alf: There is much to gain about thinking about about monads in general, but that only comes after you have a bunch of experience with specific monads.
02:39:32 <jle`> but that sort of definition is like saying "Numbers are generic things that allow for counting sheep, and measuring distances."
02:39:46 <jle`> "and x, and y, and z..."
02:39:52 <jle`> the thing is that Numbers exist outside of their applications
02:39:54 <pyrtsa> "Monads are applicatives, and applicatives are functors."
02:39:59 <Yuu_chan> "In m a -> (a -> m b) -> m b, the first m a is implicitly unwrapped and then passed into a second function"
02:39:59 <jle`> you can't characterize numbers by their applications
02:40:02 <jle`> they are their own things
02:40:21 <jle`> sgronblo: bind doesn't unwrap anything
02:40:25 <pjdelport> abstract-alf: By analogy, there's much to gain about thinking about monoids in general, but that only comes after you have enough experience with specific monads (like addition, multiplication, lists, boolean logic, and so forth).
02:40:35 <pjdelport> specific monoids, even
02:40:38 <jle`> and many Monad instances don't even "wrap" anything
02:40:39 <Yuu_chan> I kinda dislike this explanation too, but it is actually quite popular =\
02:40:41 <jle`> what does (->) a wrap?
02:40:42 <sgronblo> jle`: no?
02:41:07 <jle`> "wrap" might be a good description for some Monad instances
02:41:18 <tdammers> the "wrapping" explanation works well for some monads, but not for the general concept
02:41:18 <jle`> but Monad exists outside of whatever semantic boxes you can try to put it in
02:41:28 <jle`> wrapping has nothing to do with the idea of a Monad in general
02:41:39 <jle`> any more than counting sheep has to do with the idea of numbers
02:42:14 <sgronblo> so what monad can be said to not be wrapping something?
02:42:18 <pjdelport> jle`: It wraps it in a layer of monadic semantics. :)
02:42:37 <jle`> Reader?
02:42:46 <jle`> IO?
02:42:50 <jle`> IO doesn't wrap anything
02:42:58 <toki78> Axman6, do you want to see my paper ? It might be the worst paper ever, because I wrote it within 30 minutes
02:42:59 <jle`> State
02:43:30 <jle`> to justify these things as "wrapped values", you are going to twist the meaning of the word wrap until it no longer means anything useful
02:43:54 <toki78> how about "marshalled values" ?
02:44:10 <pjdelport> sgronblo: Roughly, any monad instance that isn't data-structure-like doesn't wrap values in the container sense. You can talk about a monad wrapping a type in monadic semantics, though.
02:44:26 <jle`> in the semantics of a specific monadic API
02:45:05 <sgronblo> getting all complicated again :)
02:45:25 <jle`> the only complicated thing is trying to fit some sort of preconceived semantic idea into what monads are
02:45:40 <jle`> monads aren't complicated; when you try to fit "all monads" into a box, your box becomes complicated/useless
02:45:53 <jle`> monads are just monads
02:46:04 <jle`> lots of types offer convenience functions
02:46:12 <jle`> some types offer convenience functions that match a monadic api
02:46:15 <jle`> so that type is a monad
02:46:20 <jle`> some types wrap data
02:46:29 <jle`> some types that wrap data offer convenience functions that fit a monadic api
02:46:35 <jle`> that type that wraps data is a monad
02:46:40 <vanila> monads are types m :: * -> * with >>= and return satisfying law1,2,3
02:46:42 <jle`> and the meaning of that monad instance is that it unwraps or whatever
02:46:43 <sgronblo> what do you consider essential to a monadic api?
02:46:51 <sgronblo> sorry to interrupt
02:46:52 <jle`> sgronblo: return and (>>=)
02:46:56 <jle`> or join
02:46:59 <jle`> following the laws
02:47:06 <toki78> I explained it with "local context", but it was wrong
02:47:08 <sgronblo> and how do you explain what these function are about?
02:47:22 <jle`> sgronblo: you don't
02:47:29 <jle`> why is that useful?
02:47:37 <jle`> you know what return does for Maybe
02:47:41 <jle`> and what (>>=) does for Maybe
02:47:46 <jle`> and it's pretty darned useful
02:47:58 <jle`> Maybe is a useful type with lots of useful convenience functions
02:48:05 <jle`> some of those convenience functions fit Monad
02:48:11 <jle`> (>>=) for Maybe is very well defined
02:48:15 <jle`> return for maybe is very well defined
02:48:23 <sgronblo> in terms of types yeah
02:48:29 <jle`> their "meaning" doesn't come from Monad
02:48:36 <jle`> nothing about the "meaning" of return/(>>=) comes from Monad
02:48:42 <jle`> all of the "meaning" of those functions comes from Maybe
02:49:11 <jle`> (except that if it is an Instance, you can be certain that return and (>>=) behave together in certain ways)
02:49:35 <jle`> but there is no point in trying to find what magical, universal meaning return and (>>=) imbue onto the types they grace
02:49:57 <jle`> it's not like when you define (>>=) for a type, it gains some magical meaning from Monad
02:50:06 <jle`> no, (>>=) means onothing more than literally what it does for that specific type
02:50:33 <jle`> and there's nothing wrong with that
02:50:49 <jle`> there's a keyword in haskell "case"
02:50:53 <jle`> note that the word case uses the letter 's'
02:51:04 <jle`> ...does that letter 's' bring some semantic meaning to the keyword case?
02:51:07 <quchen> Monad is a type class, and type classes unify things that act alike in certain ways. To see how all Monads act alike you have to use them, and it will become very intuitive. At that point you will also understand what the Monad laws mean; staring at them long enough is probably not very helpful.
02:51:09 <jle`> because of its inherent s-ness?
02:51:33 <jle`> "this haskell keyword is called 'case', let's try to understand it by looking at some inherent semantic meaning of the letter 's'"
02:51:54 <jle`> it would be more advantageous to just understand what the 'case' keyword does
02:52:05 <Yuu_chan> jle`: that's unfair because monoids or functors (for example) have pretty intuitive generic explanations IMO
02:52:43 <Yuu_chan> But monads can be only explained in terms of... monads.
02:52:45 <sgronblo> jle`: it kind of flies in the face of my traditional understanding of an interface though, where usually you are able to provide at least some sort of natural language explanation of what an operation in that interface is supposed to represent
02:53:15 <jle`> okay, i lied >_>
02:53:26 <vanila> it's not interface/API
02:53:43 <jle`> there are meaningful things, like quchen said, that the interface operations can be said to represent
02:53:47 <jle`> but they defy natural language
02:53:55 <quchen> For every phenomenon, there's a good, easy and wrong explanation.
02:53:57 <jle`> this is unlike most interfaces
02:55:19 <jle`> wow i type so much
02:55:34 <abstract-alf> you're the #haskell star for the past 20 minutes
02:55:39 <tdammers> quchen: that's because God made everything such that humans can understand it easily.
02:55:43 <pjdelport> sgronblo: There is a natural explanation, but it's more mathematical than 90% of the misleading ones you'll hear.
02:55:48 <sgronblo> jle`: strongly typing
02:55:52 <jle`> :P
02:55:57 <pjdelport> sgronblo: It's much easier to start with Functor, and build from there until you get to Monad
02:56:15 <abstract-alf> tdammers: I see what you did there ;)
02:56:21 <vanila> functor is a great idea
02:56:42 <jle`> (>>=) and return can be understood in terms of their laws, and there are no real english words to ddescribe them to give you the satisfaction you might expect, from using other interfaces with nice natural language operations
02:56:53 <pjdelport> sgronblo: Monad actually adds very little (only join) on to the semantics of Functor and Applicative.
02:56:58 <sgronblo> can we make functor unintuitive too?
02:57:13 <jle`> but i don't understand why this makes Monad unintuitive or complicated
02:57:15 <frerich> jle`: I think there are plenty of english words to describe them to give the satisfaction one might expect.
02:57:20 <pjdelport> sgronblo: So once you understand Functor, and then Applicative, Monad's join is pretty intuitive.
02:57:32 <tdammers> jle`: that's actually the best explanation I've heard so far as to why monads are considered difficult to understand
02:57:41 <sgronblo> atm i find applicative to be a bit more tricky
02:57:43 <jle`> doesn't this make them less complicated?
02:57:54 <pjdelport> IMHO, return and (>>=) is a bad and backwards way to try and understand these things.
02:57:59 <jle`> :|
02:58:08 <abstract-alf> :o{
02:58:09 <pjdelport> They're where your journey should end, not where it should start.
02:58:18 <jle`> hm
02:58:33 <pjdelport> It's like trying to teach someone how to drive a car by starting with handbrake turns.
02:58:33 <vanila> but return and (>>=) are very important
02:58:45 <vanila> because that's what the 'do' syntax directly maps to
02:58:49 <jle`> maybe if we just teach everybody return and join, it'll be ok?
02:59:04 <jle`> vanila: "end", not a beginning
02:59:24 <jle`> perhaps Monad is just a squishable thing
02:59:35 <pjdelport> sgronblo: What do you find tricky about Applicative?
02:59:39 <jle`> m (m a) -> m a
02:59:55 * augur bounces off the walls :DDDDDDDDDDDDDDD
02:59:58 <vanila> "Monads are squishy"
02:59:59 <vanila> lol
03:00:15 <sgronblo> i find it easier to imagine where i would use monads at the moment
03:00:16 <jle`> monads are squishable functors
03:00:39 <jle`> i don't know, i think trying to understand Monads as things on their own is pretty useless at first to the average programmer
03:00:48 <jle`> all they need to do is learn how to use instances
03:00:50 <augur> my super awesome dependently typed semantics thing
03:00:51 <jle`> and eventually the rest will come to them
03:00:52 <augur> is WORKING! \o/
03:00:55 <jle`> augur: :D
03:01:20 <pjdelport> jle`: That's exactly like saying monoids are a squishable thing. It's misleading because it's not the squishing that's important: it's the particular way the squishing must behave to be a monad. There are many ways to "squish" things that are not monadic.
03:01:48 <jle`> yeah
03:01:55 <jle`> that's a good point
03:02:21 <jle`> hm
03:02:54 <jle`> yes
03:03:05 <jle`> monads are monads
03:03:07 <jle`> wee
03:03:08 <jle`> it's 3 am :|
03:03:29 <ddellacosta> jle`: I wonder why more Haskell folks don't direct people to Wadler's paper: http://homepages.inf.ed.ac.uk/wadler/papers/monads/monads.ps
03:03:51 <augur> jle`: i can type in     makeTrue "(e : Event) * (x : Entity) * File e * Arg0 e x"    and it will interpret this as a command to make the proposition true -- ie, to create a new file
03:03:56 <ddellacosta> seems like it would dispel a lot of confusion on the subject
03:04:10 <jle`> ddellacosta: i think that's actually recommended protocol
03:04:20 <ddellacosta> jle`: ah, nevermind then...haha
03:04:23 <jle`> well
03:04:28 <jle`> it's recommended upon deaf ears
03:04:30 <jle`> like mine ;)
03:04:58 <ddellacosta> jle`: but definitely agree with what you're saying, re: monads are monads
03:05:06 <jle`> hm
03:05:08 <ddellacosta> best to understand them on their own terms, and not be in a hurry about it
03:05:09 <jle`> what are the squish laws?
03:05:22 <ddellacosta> squish laws?
03:05:24 <jle`> is it that m (m (m a)) -> m a can take two paths ... squishing the outside then the whole thing
03:05:29 <jle`> or squishing the inside then the whole thing
03:05:31 <jle`> and tehy must be identical?
03:05:37 <jle`> (the monad laws in terms of join)
03:05:52 <jle`> but where is return in there...
03:05:52 <pjdelport> jle`: Basically, that the order of joining doesn't matter.
03:06:28 <pjdelport> jle`: join must be associative, in a particular sense.
03:06:30 <jle`> is that the only required behavior of join?
03:06:41 <jle`> that join . join = join . fmap join ?
03:07:32 <jle`> shouldn't the behavior of return factor in here somewhere ...?
03:07:37 <vanila> in another law
03:08:26 <vanila> http://en.wikipedia.org/wiki/Monad_%28functional_programming%29#fmap_and_join
03:09:01 <pjdelport> jle`: Yeah.
03:09:27 <jle`> are all those four laws really necessary?
03:09:32 <jle`> and none can be reduced?
03:10:03 <jle`> how unsatisfying :'(
03:10:26 <pjdelport> jle`: They're from Functor and Applicative, not just Monad.
03:10:36 <jle`> not counting the Functor law
03:10:50 <jle`> hm
03:10:54 <pjdelport> The only one that's really unique to monads is join
03:11:19 <jle`> but the kleisli arrow formulation describes the behavior of pointed functors as well
03:11:32 <jle`> and in only three
03:12:06 * jle` shrugs
03:12:19 <jle`> augur: congrats :)
03:12:30 <jle`> that's
03:12:31 <jle`> interesting
03:12:41 <augur> jle`: :)
03:13:03 <abstract-alf> OK. I have an infinite list of random integers.  I want to take 10 unique pairs of ints from this list.  How to approach?
03:13:09 <jle`> can i expect to see a writeup? :)
03:13:40 <augur> jle`: more accurately, its something like   execute "<> ((e : Event) * (x : Entity) * File e * Arg0 e x)"
03:13:53 <augur> jle`: and the stuff in quotes is the semantics for   "make a file"
03:15:01 <abstract-alf> Do I need to use State? Is there some sort of foldWhile?
03:15:17 <MP2E> abstract-alf : takeWhile maybe?
03:15:38 <abstract-alf> but I need to consider the accumulating list of pairs as I take
03:15:49 <abstract-alf> right?
03:15:55 <quchen_> abstract-alf: You want to do two things in succession: pair up numbers, and take 10 pairs. Write each of them, then compose them.
03:16:01 <augur> jle`: there will be a writeup eventually, once its cleaned up.
03:16:08 <augur> jle`: i need to write docs and stuff for it too
03:16:13 <jle`> augur: so the interpreter will try to make the statement about the world true, by changing the world
03:16:18 <jle`> sounds scary
03:16:28 <augur> jle`: yes thats correct
03:16:36 <abstract-alf> quchen, I also want to make sure I get 10 unique pairs (no repeats allowed)
03:17:23 <MP2E> abstract-alf : use a Set to ensure that your source never has more than one number and remove the number from the set as you put it in the pair.
03:17:32 <MP2E> more than one of the same number*
03:17:33 <augur> jle`: ok, im off to bed. night!
03:17:43 <quchen> Then you should put a `nub` in the mix as well to kick out the duplicates I guess.
03:17:50 <MP2E> nub works with regular lists
03:17:55 <pjdelport> abstract-alf: How exactly do you define "unique"?
03:18:14 <abstract-alf> unique: [(1,2),(5,5),(3,4)]
03:18:20 <abstract-alf> not unique: [(1,2),(5,5),(3,4),(1,2)]
03:18:40 <jle`> augur: night!
03:18:48 <pjdelport> Yeah, then you can use nub.
03:18:56 <abstract-alf> :t nub
03:18:57 <lambdabot> Eq a => [a] -> [a]
03:19:04 <jle`> nub doesn't work well with infinite lists i don't think...
03:19:11 <jle`> > take 10 . nub $ [1..]
03:19:13 <lambdabot>  [1,2,3,4,5,6,7,8,9,10]
03:19:14 <jle`> oh
03:19:17 <jle`> i guess it does
03:19:17 <MP2E> huh
03:19:19 <jle`> :)
03:19:19 <tdammers> doesn't nub require the list to be sorted?
03:19:26 <tdammers> > nub [1,2,3,4,1]
03:19:27 <lambdabot>  [1,2,3,4]
03:19:31 <MP2E> guess not, nice
03:19:31 <tdammers> guess it doesn't
03:19:33 <frerich> tdammers: No, that's also why 'nub' is O(n^2)
03:19:36 <cstanfill> > nub [1,2,3,4,1,5]
03:19:37 <tdammers> right
03:19:38 <lambdabot>  [1,2,3,4,5]
03:19:38 <jle`> nub works on unsorted lists but the performance makes a big difference
03:19:41 <MP2E> yikes n^2?
03:19:43 <MP2E> jeez
03:19:44 <pjdelport> abstract-alf: You do realize that the numbers after the first pair won't really be random anymore, right?
03:19:48 <tdammers> jle`: obviously
03:19:53 <quchen> > let pairUp (x:y:xs) = (x,y) : pairUp xs; pairUp _ = [] in (take 3 . nub . pairUp) [1,2,1,2,3,5,3,4,5,2,1,4,3,5,3,4]
03:19:55 <lambdabot>  [(1,2),(3,5),(3,4)]
03:19:57 <jle`> > take 10 . nub $ [-10,-9..]
03:19:58 <tdammers> a nub on sorted lists would be O(n)
03:19:59 <lambdabot>  [-10,-9,-8,-7,-6,-5,-4,-3,-2,-1]
03:20:14 <jle`> @src nub
03:20:15 <lambdabot> nub = nubBy (==)
03:20:16 <cstanfill> pjdelport: er, what?
03:20:19 <abstract-alf> pjdelport, yes. not random anymore.  I want pseudo random, in the end
03:20:21 <jle`> @src nubBy
03:20:21 <lambdabot> nubBy eq []             =  []
03:20:21 <lambdabot> nubBy eq (x:xs)         =  x : nubBy eq (filter (\ y -> not (eq x y)) xs)
03:20:25 <quchen> Concering "nub is bad", see https://github.com/quchen/articles/blob/master/fbut.md#nub
03:20:40 <pjdelport> abstract-alf: I mean "not random" as in biased, not just pseudo-random.
03:20:53 <abstract-alf> sure, my results will be biased
03:20:54 <abstract-alf> that's ok
03:20:55 <MP2E> ^ it was psuedorandom to begin with
03:21:03 <MP2E> err at pjdelport's comment but  yeah
03:21:10 <jle`> this is cool
03:21:30 <pjdelport> cstanfill: Eliminating duplicates biases the results.
03:21:37 <abstract-alf> I want 10 non-deterministically generated pairs of integers
03:23:15 <jle`> > take 10 . nub . ap zip tail . randomRs (1,20) $ mkStdGen 1
03:23:16 <lambdabot>  [(18,9),(9,8),(8,10),(10,1),(1,10),(10,17),(17,18),(18,3),(3,11),(11,4)]
03:23:22 <jle`> don't use ap zip tail in real life of course
03:23:29 <jle`> hm
03:23:33 <jle`> no that's no good
03:23:39 <jle`> > take 10 . nub . ap zip (drop 2) . randomRs (1,20) $ mkStdGen 1
03:23:40 <lambdabot>  [(18,8),(9,10),(8,1),(10,10),(1,17),(10,18),(17,3),(18,11),(3,4),(11,8)]
03:23:45 <jle`> there
03:24:09 <abstract-alf> yeah, I arrived at something similar
03:24:13 <jle`> at this point i'm just finding reasons not to go to sleep >_>
03:24:14 <abstract-alf> nub did the trick ;)
03:32:04 <phil> hey,could someone tell me why I get an error trying this list@(x:xs) = foldl (\acc (x:xs) -> if digitToInt x > 9 && (digitToInt . head $ xs) > 9 then False else acc) True list
03:32:29 <hpc> :t let list@(x:xs) = foldl (\acc (x:xs) -> if digitToInt x > 9 && (digitToInt . head $ xs) > 9 then False else acc) True list
03:32:30 <lambdabot> <no location info>:
03:32:30 <lambdabot>     not an expression: ‘let list@(x:xs) = foldl (\acc (x:xs) -> if digitToInt x > 9 && (digitToInt . head $ xs) > 9 then False else acc) True list’
03:32:36 <hpc> :t let list@(x:xs) = foldl (\acc (x:xs) -> if digitToInt x > 9 && (digitToInt . head $ xs) > 9 then False else acc) True list in list
03:32:37 <lambdabot>     Couldn't match expected type ‘[[Char]]’ with actual type ‘Bool’
03:32:37 <lambdabot>     In the expression: False
03:32:37 <lambdabot>     In the expression:
03:33:08 <hpc> ghc thinks your use of False is wrong
03:33:25 <hpc> :t foldl
03:33:26 <lambdabot> (b -> a -> b) -> b -> [a] -> b
03:35:52 <hpc> not sure why it's expecting [String] there though
03:35:55 <phil> hmm i get the following error :     Couldn't match expected type `[Char]' with actual type `Char'     Expected type: [[Char]]       Actual type: [Char]     In the third argument of `foldl', namely `list'
03:36:29 <phil> why does foldl expect [[Char]] ?
03:36:32 <hpc> :t let list@(x:xs) = foldr (\acc (x:xs) -> if digitToInt x > 9 && (digitToInt . head $ xs) > 9 then False else acc) True list in list
03:36:33 <lambdabot>     Couldn't match expected type ‘[Char]’ with actual type ‘Bool’
03:36:33 <lambdabot>     In the expression: False
03:36:33 <lambdabot>     In the expression:
03:36:51 <hpc> :t digitToInt
03:36:52 <lambdabot> Char -> Int
03:37:07 <pjdelport> phil: What do you want the function to do?
03:37:57 <pjdelport> :t all
03:37:58 <lambdabot> (a -> Bool) -> [a] -> Bool
03:38:06 <pjdelport> phil: Do you maybe want all?
03:38:30 <phil> pjdelport: it takes a list of char like ['9','A','b','7'....] and shall return false if a char is followed by a char.
03:38:58 <pjdelport> What do you mean by "char is followed by a char"?
03:39:06 <phil> pjdelport: "a9a9a" is right "09aa" is wrong
03:39:35 <pjdelport> Ah, so no subsequent chars?
03:39:57 <pjdelport> Okay, you won't want foldl or digitToInt for that.
03:40:27 <pjdelport> phil: Is "char" just defined as any non-digit?
03:40:40 <pjdelport> (What about whitespace?)
03:40:52 <phil> pjdelport: yeahr i know this is a bit complicated and there are ways to do better , but I just wanted to practice folds and stuff
03:41:16 <phil> pjdelport: [Char] -> Bool
03:41:38 <phil> its a function that takes [Char] and returns Bool
03:41:44 <pjdelport> phil: Well, Char is any Unicode codepoint, which includes digits.
03:42:38 <pjdelport> phil: Oh, wait. Do you mean you want it to be false for any identical pairs of characters, not any two non-digits?
03:43:00 <phil> pjdelport: I know and thats ok because i want to pass strings to the function including both. thats why I check whether digitToInt is > 9
03:43:59 <pjdelport> phil: Generally speaking, digitToInt will never be > 9. I don't think it's doing what you think it is.
03:44:00 <phil> pjdelport: No I want it to be false for any pairs of non-digit
03:44:18 <hpc> > digitToInt 'A'
03:44:20 <lambdabot>  10
03:44:29 <pjdelport> Oh, foo.
03:44:43 <pjdelport> hpc: Thanks.
03:45:07 <hpc> > digitToInt 'Q' -- i think this works too
03:45:08 <lambdabot>  *Exception: Char.digitToInt: not a digit 'Q'
03:45:22 <hpc> ah, so just up to F
03:45:45 <phil> jepp, and every other character should be something > 9 ,too
03:45:47 <pjdelport> phil: The first thing you need is to pair up adjacent characters. You can't really do that with fold; the usual way of doing it is with zipping.
03:46:19 <pjdelport> > let f xs = zip xs (tail xs) in f "abcde"
03:46:21 <lambdabot>  [('a','b'),('b','c'),('c','d'),('d','e')]
03:46:39 <frerich> phil: I think you could first translate your string (e.g. '09aa') by mapping isLetter on it to get [False, False, True, True]. Then zip that with its tail and look for tuples where both elements are True
03:47:39 <phil> i know , that this would be better. But the point is :  I want to understand why it's not working  :)
03:48:08 <frerich> phil: you mean why the fold doesn't work?
03:48:21 <phil>  if digitToInt x > 9 && (digitToInt . head $ xs) > 9 then False else True <--- This works on a list... why not with foldl ?
03:48:41 <phil> frerich: exactly
03:49:14 <frerich> phil: It you tried really hard you could make it work, but a 'fold' consumes a list one element at a time. you'd have to keep track of the 'previous' element yourself.
03:50:11 <frerich> phil: It would get easier if you first turned a string ("09aa") into a list of tuples so that you have the neighbor already, i.e. [('0', '9'), ('9', 'a'), ('a', 'a')]
03:50:32 <frerich> phil: Folding that would be a lot easier since you can consider each list element (the tuple) individually.
03:51:37 <frerich> phils: Folds are really most convenient if you can process list elements without considering other elements (e.g. the neighbors) in the list.
03:52:09 <phil> frerich: aaah ok.. that is the problem I thought fold would use the whole list except the prev element like doing recursivly something like f (x:xs) = x: f xs
03:53:08 <pjdelport> > let f xs = and $ zipWith (\a b -> isDigit a || isDigit b) xs (tail xs) in f "09aa"
03:53:09 <lambdabot>  False
03:53:29 <frerich> phil: Not sure I understand - a fold *does* use the whole list of course. The thing is that the fucntion which is used for folding always only gets a single element and the accumulator (i.e. the result of the previous fold).
03:53:33 <pjdelport> Or rather:
03:53:41 <pjdelport> > let f xs = zipWith (\a b -> isDigit a || isDigit b) xs (tail xs) in f "09aa"
03:53:43 <lambdabot>  [True,True,False]
03:53:58 <pjdelport> phil: That's the same, but now we're evaluating that function for each pair, to check it.
03:54:13 <phil> frerich : that's what i wanted to say :) sorry for the poor english ^^
03:54:33 <frerich> phil: No worries, I'm not a native speaker either (let alone very good at Haskell...)
03:54:40 <pjdelport> phil: And then in the second-last version, we use "and" to combine the list of booleans to one value.
03:55:06 <pjdelport> phil: Does that make sense?
03:55:28 <phil> pjdelport: Now this makes good sence ^^
03:57:16 <pjdelport> phil: You can shorten that a bit by mapping isDigit separately:
03:57:33 <pjdelport> > let f xs = zipWith (||) xs' (tail xs') where xs' = map isDigit xs in f "09aa"
03:57:34 <lambdabot>  [True,True,False]
03:57:36 <abstract-alf> any way to enumerate an Enum instance besides [1..] ? something like (enumerate :: Int)?
03:57:58 <pjdelport> Well, with "and $" in front for the real version, of course.
03:58:19 * hackagebot ghc-make 0.2.1 - Accelerated version of ghc --make  http://hackage.haskell.org/package/ghc-make-0.2.1 (NeilMitchell)
03:58:42 <pjdelport> > [1..] :: [Rational]
03:58:43 <lambdabot>  [1 % 1,2 % 1,3 % 1,4 % 1,5 % 1,6 % 1,7 % 1,8 % 1,9 % 1,10 % 1,11 % 1,12 % 1,...
03:58:55 <pjdelport> abstract-alf: That?
03:58:57 <abstract-alf> how bout a custom ADT?
03:59:13 <ion> @type [minBound..]
03:59:14 <lambdabot> (Enum t, Bounded t) => [t]
03:59:21 <abstract-alf> o
03:59:28 <pjdelport> abstract-alf: It works with any instance of Enum.
03:59:28 <abstract-alf> :t minBound
03:59:29 <lambdabot> Bounded a => a
03:59:32 <slomo> is there a useful way to break out of "forever"? other than throwing an exception and catching it outside, or writing your own "foreverUnless"? use case is a thread that reads forever from a Chan, but should shut down when it gets a "quit" command from the Chan
04:00:06 <ion> slomo: That use case is not what “forever” is for.
04:00:10 <phil> frerich: I hope my english will become better , while haning arroung in the #haskell channel ;)
04:00:39 <abstract-alf> pjdelport, ghci complains, says it expects an instance of Num
04:00:39 <slomo> ion: is there something else existing for this already?
04:00:52 <abstract-alf> > (fromEnum 0) :: Boolean
04:00:54 <lambdabot>  Not in scope: type constructor or class ‘Boolean’
04:00:57 <abstract-alf> > (fromEnum 0) :: Bool
04:00:59 <lambdabot>  Couldn't match expected type ‘GHC.Types.Bool’
04:00:59 <lambdabot>              with actual type ‘GHC.Types.Int’
04:01:05 <phil> pjdelport:Thanks for your efforts :)
04:01:05 <abstract-alf> > (fromEnum 1) :: Bool
04:01:07 <lambdabot>  Couldn't match expected type ‘GHC.Types.Bool’
04:01:08 <lambdabot>              with actual type ‘GHC.Types.Int’
04:01:44 <ion> slomo: You could just have “foo = do { …; when condition foo }”
04:01:46 <pjdelport> abstract-alf: Only if you give it a Num literal to start with.
04:01:55 <pjdelport> > [False ..]
04:01:57 <lambdabot>  [False,True]
04:02:00 <abstract-alf> ah, right
04:02:05 <zwer_y> > length ([minBound..] :: [Char])
04:02:06 <ion> > [toEnum 0 :: Bool, toEnum 1, toEnum 2]
04:02:06 <lambdabot>  1114112
04:02:08 <lambdabot>  [False,True,*Exception: Prelude.Enum.Bool.toEnum: bad argument
04:02:18 <abstract-alf> I was looking to be even lazier... I want to enumerate a whole Enum datatype without even naming the lowest bound
04:02:47 <abstract-alf> just curious if it's possible..
04:02:52 <slomo> ion: sure, i just like that "forever" or a "foreverUnless" provides some extra semantics and you don't have to read the whole code to check if it recurses or not :)
04:02:53 <ion> You need Bounded for a starting point.
04:03:03 <abstract-alf> yep, that got it
04:03:10 <slomo> ion: i'll just go with writing a foreverUnless myself then, thanks :)
04:03:14 <quchen> Not necessarily. You need an arbitrary point to start at.
04:03:17 <abstract-alf> [(minBound :: MyADT)..]
04:03:31 <abstract-alf> made MyADT an instance of bounded
04:03:46 <abstract-alf> thanks ion
04:04:08 <ion> @hackage monad-loops  -- slomo
04:04:08 <lambdabot> http://hackage.haskell.org/package/monad-loops  -- slomo
04:04:31 <slomo> ion: thanks
04:06:16 <Marquis> i have got a question. Lets say i have a polymorphic type with Integers and String in it and now a List of this type. I want to drop out all Strings and just keep the Integers. How can i do it? Is there a good way to check the type within the programm easily?
04:07:29 <Taneb> Marquis, polymorphic like Either Integer String?
04:07:42 <Taneb> [i | Left i <- xs]
04:08:01 <Taneb> You can pattern match in list comprehensions and failures just get removed
04:10:29 <Welkin> is there some aversion to using `try` in parsec?
04:10:39 <Welkin> is there a reason it is better to avoid using it?
04:11:23 <pjdelport> abstract-alf: You *can* say [toEnum 0 ..] :: [Foo], for the default derived Enum, at least.
04:11:52 <abstract-alf> ahh, yes, that works too
04:12:06 <abstract-alf> simpler, even
04:12:40 <pjdelport> abstract-alf: It's probably cleaner and more gneral to use Bounded rather than rely on that implementation detail, though.
04:13:04 <kbrei> Welkin, a) maybe performance, more importantly b) can create difficult to understand error messages http://blog.ezyang.com/2014/05/parsec-try-a-or-b-considered-harmful/
04:15:13 <Welkin> this scheme interpreter seems impossible to build without lots of uses of `try`
04:15:47 <Welkin> especially since Char, Bool, and (Based)Numbers all start with the same character
04:16:39 <Welkin> has anyone successfully completed "Write Yourself a Scheme"?
04:16:57 <vanila> I've done my own not following that tutorial
04:17:59 <ManateeLazyCat> lambdabot: 1 + 1
04:18:24 <Welkin> vanila, how did you handle things like #t, #x72, #\c ?
04:18:29 <klrr_> Welkin: try make sure the parser dont consume the input it consumes if it fails
04:19:05 <Welkin> well, I thought I was doing that by using `char '#' >> `
04:19:10 <klrr_> Welkin: use the Alternative instance
04:19:17 <Welkin> but then it seems to still expect something after the '#'
04:19:19 <klrr_> try foo <|> bar
04:19:25 <klrr_> yes
04:19:37 <klrr_> make a parser for each case
04:19:38 <klrr_> then
04:19:57 <klrr_> char '#' >> (try bar <|> try foo <|> quaaz)
04:20:03 <klrr_> or something like that
04:20:09 <Welkin> that is what I did
04:20:15 <Welkin> but I'm trying to avoid `try`
04:20:21 <klrr_> okey
04:20:23 <klrr_> why?
04:20:36 <Welkin> it makes debugging impossible
04:21:13 <klrr_> true, but im not sure there is another way to do it
04:21:17 <tdammers> just have to know what it does
04:21:34 <tdammers> also, depends how you debug
04:21:56 <klrr_> can Foldable and Unfoldable instances from recursion-schemes be generated with TH ?
04:22:29 <Marquis> preflex: Taneb++
04:22:33 <quchen> char '#' *> asum [boolean, hex, escaped] -- with suitable parsers in the list
04:22:53 <Welkin> :t asum
04:22:54 <lambdabot>     Not in scope: ‘asum’
04:22:54 <lambdabot>     Perhaps you meant one of these:
04:22:54 <lambdabot>       ‘F.asum’ (imported from Data.Foldable),
04:22:54 <quchen> You should move all "try"s as deep down as possible, debugging won't suck then.
04:23:03 <Welkin> :t F.asum
04:23:04 <lambdabot> (Foldable t, Alternative f) => t (f a) -> f a
04:23:06 <quchen> asum [a,b,c] = a <|> b <|> c
04:23:39 <Welkin> :t (*>)
04:23:40 <lambdabot> Applicative f => f a -> f b -> f b
04:23:53 <killy9999> anyone going to the Haskell Symposium this year?
04:23:59 <klrr_> :t (>>)
04:24:00 <lambdabot> Monad m => m a -> m b -> m b
04:24:01 <quchen> *>  is  >>
04:24:06 <quchen> (But Applicative instead of Monad)
04:24:21 <Welkin> okay
04:24:24 <Welkin> that is what I guessed
04:24:49 <Welkin> how is asum better than <|> ?
04:25:12 <quchen> It's shorter to write (and read) when you have lots of alternative parsers.
04:25:25 <Welkin> that's true
04:52:10 <abstract-alf> how would one implement a zipWith9 function?
04:54:02 <vanila> zipWith9 f (x1:xs1) (x2:xs2) (x3:xs3) (x4:xs4) (x5:xs5) (x6:xs6) (x7:xs7) (x8:xs8) (x9:xs9) = f x1 x2 x3 x4 x5 x6 x7 x8 x9 : zipWith9 f xs1 xs2 xs3 xs4 xs5 xs6 xs7 xs8 xs9 ; zipWith9 _ _ _ _ _ _ _ _ _ _ = []
04:54:10 <abstract-alf> that easy?
04:55:07 <abstract-alf> zipWith4 z (a:as) (b:bs) (c:cs) (d:ds)
04:55:07 <abstract-alf> = z a b c d : zipWith4 z as bs cs ds; zipWith4 _ _ _ _ _ = []
05:10:16 <abstract-alf> k:::r
05:37:47 <hunt> where do i find the s ources for each monad instance?
05:38:02 <hunt> im trying to, for starters, look at how list is instantiated as a monad
05:39:42 <ion> hunt: Either in the same file with the definition of the class or the same file with the definition of the type, unless it’s an orphan instance.
05:43:01 <ion> hunt: In the case of [], it’s in the same file with the class definition.
05:44:13 <ion> hunt: It may be a good exercise to come up with the implementation of instance Monad [] yourself.
05:53:12 <vova> I do not understand how to use the module Network.TLS. Is there any document or tutorial regarding it. I'm a haskell beginner. Could you please help.
05:53:14 <tero-> what's the parser combinator library to use at the moment? Parsec?
05:54:12 <ion> tero: StateT [input] [] output
05:54:15 * ion ducks
05:54:43 <frerich> tero-: Depends on your needs really. attoparsec might be nice as well (can parse incrementally and is fairly fast at the expense of error messages)
05:54:43 <slomo> vova: https://github.com/sdroege/snippets.hs/blob/master/tls.hs very simple example here
05:54:45 <tero-> ion: sounds general
05:55:48 <tero-> frerich: I have a DSL for a code generator. now it's using alex and happy, but I'd like to add context-awareness in the parser. It's possible in happy but I'm wondering whether it's time to change the tool
05:56:07 <slomo> vova: if you want to do https you probably want to use a library for that though, like http-client (which has convenient tls support in http-client-tls)
05:56:38 <ion> I wonder what the state of trifecta is? I haven’t looked for a while.
05:56:44 <vova> slomo: thank you. I'm going to see the example.
05:57:52 <vova> slomo: Are you talking about Network.HTTP ?
05:58:30 <slomo> vova: no, http://hackage.haskell.org/package/http-client
05:58:53 <slomo> vova: and http://hackage.haskell.org/package/http-client-tls
05:59:51 <slomo> vova: another simple example with that can be found here (but that's also including code to parse the duckduckgo instant answers API) https://github.com/sdroege/snippets.hs/blob/master/ddg.hs#L93
06:01:00 <vova> slomo: Oh, Network.HTTP.Client supports the POST method. I saw the Network.HTTP.Conduit and there is no POST.
06:01:21 <alpy> Is there a good tutorial that explains how to use Data.Clock and UTCTime?
06:01:36 <vova> slomo: Thank you very much for your help.
06:03:45 <vova> alpy: Please see : http://tab.snarc.org/posts/haskell/2011-12-16-date-in-haskell.html
06:24:27 <ysf> Hi there, where can I take a glimpse into the library-universe of haskell? A new language has to be learned and I don't know which one to take first :)
06:26:06 <quchen> ysf: Looking at an entire universe is usually a bit much, but here you go: http://hackage.haskell.org/packages/
06:27:20 <ysf> thanks a lot
06:27:45 <quchen> There's a useful search function at the top, I suggest you use that to sample that list.
06:30:56 <ysf> quchen: just did that, i'm interested in network/security libs and feared (needlessly) that not much would be there.
06:41:12 <sie> [(String, Int)] is an instance of functor, correct?
06:41:27 <darthdeus> sie: every list is an instance of functor afaik
06:41:33 <benj_> no, [] is an instance of Functor
06:41:47 <darthdeus> where fmap = map
06:42:18 <benj_> [(String, Int)] has kind *, but it needs kind * -> * to be an instance of Functor
06:43:03 <sie> > (\(x, y) -> x ++ show y ) `fmap` [("wef", 3), ("meh", 9)]
06:43:04 <lambdabot>  ["wef3","meh9"]
06:43:34 * hackagebot dson-parsec 0.4.1.1 - DSON parser.  http://hackage.haskell.org/package/dson-parsec-0.4.1.1 (alvare)
06:43:47 <sie> Everything that works with fmap is a functor.
06:43:50 <quchen> You can apply 'fmap f' to something of type [(String, Int)] because [] is a Functor. You could call a value of type [something] "functorial" if you wanted to stress that fmapping is an option here.
06:44:17 <benj_> sie, the thing that "works with fmap"  is [].
06:44:24 <sie> That's true.
06:47:09 <benj_> :k Functor
06:47:10 <lambdabot> (* -> *) -> Constraint
06:48:34 * hackagebot gf 3.6 - Grammatical Framework  http://hackage.haskell.org/package/gf-3.6 (ThomasHallgren)
06:57:30 <tero-> hm.  indentation aware parser Text.Parsec.Indent (indents-package) no longer exports IndentParserT, only IndentParser, so I cannot do IO in the parser
06:58:35 * hackagebot psqueues 0.1.0.0 - Pure priority search queues  http://hackage.haskell.org/package/psqueues-0.1.0.0 (JasperVanDerJeugt)
07:04:58 <Smilex> I'm doing some renaming like "withT = with". Is it possible to force withT to only be defined for the file it was defined in, even if another file imports this file?
07:06:53 <hunt> has anyone taken advantage of the existence of the Category and Arrow type classes to do something cool?
07:07:07 <quchen> Smilex: Sure, don't export withT.
07:07:53 <slomo> hunt: HXT maybe
07:07:54 <quchen> Smilex: When you have a "module Foo (bar, baz) where ...", only bar and baz will be accessible from other modules.
07:08:14 <mirari> If I have an ADT, say data Color = Red | Black. What is the technical name for the "Red" value? I don't mean Red as the constructor, but the value itself?
07:08:17 <Smilex> quchen: So it'd have to use an explicit export list? withT is the only thing I don't want to export right now (so currently I'm using 'hiding'), but is it best practise to explicitly define what you export?
07:08:39 <vanila> mirari, it is a constructor as a value
07:09:21 <mirari> vanila: So you would say: booleans, integers and constructor values?
07:09:21 <geekosaur> "nullary data constructor"?
07:09:25 <mirari> for instance
07:09:45 <quchen> Smilex: Yes, you have to be explicit about each type you export. There's no "all but this one" when exporting.
07:09:58 <Smilex> quchen: ok thanks
07:09:58 <quchen> (When importing you can use "hiding" though.)
07:10:17 <ajcoppa> "value constructor" or "data constructor" are both terms used to describe something like Red, Black, or the "Just" in Just 3, right?
07:10:19 <quchen> s/each type/everything/ ^^^^
07:10:27 <vanila> just constructor
07:10:32 <Smilex> Yeah, but the point is that other files don't know about withT, so I don't want to use 'hiding'
07:10:46 <vanila> Just is the constructor, Just 3 is a value of type Maybe Int
07:10:49 <mirari> okay, thank you
07:10:59 <ajcoppa> as opposed to "type constructors", like the "Maybe" in Maybe Int
07:11:21 <quchen> "data" and "value" constructor are both fine.
07:11:42 <mathk> I am trying to install the gtk package but it fail with the following error: http://pastebin.com/2yiWUtpG
07:11:50 <mathk> any idea why?
07:12:04 <mathk> I am on windows
07:12:35 <phil> What are x and y in : groupBy (\x y -> (x > 0) == (y > 0)) [-4.3, -2.4, -1.2, 0.4, 2.3, 5.9, 10.5, 29.1, 5.3, -2.4, -14.5, 2.9, 2.3] ?
07:12:41 <vanila> variables
07:13:01 <vanila> the \ thing is lambda abstraction
07:13:04 <phil> what values would they have
07:13:19 <vanila> so what this does is creates a function here: (\x y -> (x > 0) == (y > 0))
07:13:31 <vanila> this is a function that makes sure both x,y are positive or both negative
07:13:39 <spacebug_> phil: 2 consecutive elements to the list
07:13:44 <vanila> group by will try that function out on the values of the list
07:13:56 <chad> Anyone by chance using Network.HTTP.Conduit and forkIO together?  I'm finding the request never happens in forkIO if I use withManager and I'm kinda lost as to how to debug. The program doesn't fail.
07:14:12 <vanila> so it will start by checking -4.3 and -2.4, then -1.2 then 0.4, and it will make the first 3 into a group
07:14:35 <phil> ah okay thanks a lot ^^
07:14:51 <mgsloan> mathk: This looks relevant: http://www.haskell.org/pipermail/haskell-cafe/2011-June/093025.html
07:15:09 <mgsloan> mathk: Err, hmm, nvm
07:15:22 <phil> spacebug: thx ;)
07:15:29 <mgsloan> That guy runs into the same error message after installing gtk2hs-buildtools, though
07:16:34 <mathk> mgsloan, I think the relevant error is: setup.exe: Generate Reg File not supported
07:16:39 <mgsloan> Yup
07:16:49 <mgsloan> That's what I searched to find that thread
07:17:16 <mathk> I don;t see it in the thread
07:18:50 <mgsloan> In the next message, the string appears in a compilation error
07:21:47 <mgsloan> Seems like if you can get "modeGenerateRegFile" to be False, your problems will disappear.  I have no idea what that means, though
07:39:53 <Saizan> flebron: you might like this http://www.sciencedirect.com/science/article/pii/S1571066114000346
07:43:20 <flebron> Saizan: Nice! Thanks!
07:47:27 <jamiehannaford> what is the <*> function usually called?
07:47:38 <quchen> "ap" or "apply"
07:57:37 <mathk> mgsloan, I have solved the issue using an older cabal
07:57:56 <mgsloan> mathk: cool, glad it worked out!
07:58:10 <mgsloan> that's a little worrisome that newer cabal breaks things for you, though..
07:59:13 <mathk> yup but I had couple of warning of deprecated function using the new cabal
08:00:09 <mathk> but GIO and pango does not compile
08:00:12 <mathk> :(
08:01:08 <mathk> http://pastebin.com/rqLEzF6F
08:02:18 <mathk> I am guessing that the 64bit version of GTK is not supported
08:02:24 <Eduard_Munteanu> Why do conduits/pipes use () for input types in sources/producers, and not Void?
08:04:22 <mgsloan> mathk: I don't know, sorry!  Googling the error turns up some results, though
08:07:42 <Sculptor> how short is the shorters haskell fizz buzz
08:10:47 <Walther> > take 10 [x | x <- [1..] | x `mod` 3 == 0 = "fizz" | x `mod` 5 == 0 = "buzz" | x `mod` 15 == 0 = "fizzbuzz"]
08:10:50 <lambdabot>  <hint>:1:42: parse error on input ‘=’
08:11:02 <Walther> Erm.
08:11:07 <RchrdB> Sculptor, try Google for "haskell fizzbuzz golf" =)
08:11:29 <Walther> ...I would recommend trying yourself, too
08:11:35 <Walther> golfing in Haskell is fun
08:12:29 <ektello> I personally find abstraction/type golfing even more fun (http://themonadreader.files.wordpress.com/2014/04/fizzbuzz.pdf)
08:12:59 <ReinH> ektello: that's a fun one, but not really golfing
08:13:25 <Sculptor> checking
08:14:10 <gregory> so besides LYAH is there anything else i should read/watch
08:15:43 <Taneb> @where typeclassopedia
08:15:43 <lambdabot> http://www.haskell.org/haskellwiki/Typeclassopedia
08:15:47 <Taneb> gregory, ^
08:16:15 <gregory> Taneb: thank you, anything else?
08:19:50 <quchen> What's the recommended memoization library these days? Previously I used data-memocombinators, but it isn't very convenient for custom types.
08:21:03 <quchen> memoize has TH facilities, but hasn't seen an update in a year; I didn't see one using Generic to derive memoizable instances.
08:22:00 <benbangert> I don't suppose anyone knows how to make Haskell more memory efficient on its socket handling?
08:23:05 <ajcoppa> gregory: are you working to learn haskell?
08:24:18 <qrada> has anyone here ever used PortFusion.. I want to use the repl but, just want to get it to run first.. eh, the 'usage' makes no sense to me https://github.com/corsis/PortFusion/wiki
08:25:37 <ReinH> quchen: memocombinators or representable-tries?
08:31:43 <quchen> ReinH: memocombinators? I don't see that when searching Hackage
08:35:26 <pjdelport> gregory: What topics interest you most?
08:44:51 <ReinH> quchen: oh I meant data-memocombinators, but you've already tried it
08:45:00 <gregory> pjdelport: well i use clojure for everyday hacking but haskell's type system looks really cool and I wanted to learn haskell for that and all the high level concepts that haskell has
08:51:50 <pjdelport> gregory: Cool, then the Typeclassopedia should definitely be relevant. Check some of some of the literature linked here, too: http://stackoverflow.com/q/10344233/444705
08:52:19 <gregory> jfdelport: lots of people have been pointing to typeclassopedia and LYAH
08:52:20 <pjdelport> gregory: http://www.haskell.org/haskellwiki/Research_papers and http://www.haskell.org/haskellwiki/Research_papers/Top_10 too
08:52:49 <pjdelport> LYAH is maybe not the best for learning theory and ideas, but you can see what you can get from it.
08:53:38 <pjdelport> gregory: Oh, http://www.haskell.org/haskellwiki/Research_papers/Functional_pearls should also be good.
08:53:49 <dmj`> typeclassopedia ++
08:53:54 <pjdelport> They're more bite-sized.
08:55:40 <pjdelport> gregory: http://www.haskell.org/haskellwiki/Blow_your_mind too
08:55:54 <Eduard_Munteanu> Why do conduits/pipes use () for input types in sources/producers, and not Void?
08:56:46 <Taneb> Eduard_Munteanu, because input is something like the LHS of a function
08:57:01 <Taneb> Void -> a lets you end up with a Void
08:57:16 <Taneb> () -> a is equivalent to a
08:57:41 <Eduard_Munteanu> But I expect awaits to block forever, hence never returning a Void.
08:58:54 <Eduard_Munteanu> Taneb: and I suspect the same argument could go for outputs, because a -> Void clearly isn't a.
08:59:57 <Eduard_Munteanu> Also contrast to (forall i o. Conduit i o m a), clearly they're both isomorphic to Void.
08:59:59 <glguy> Taneb: I don't think that reasoning precludes Void being used for the input type for a source
09:00:01 <Liliane21>  Hi! I give you some videos. I hope you like! http://bitly.com/1l3PyOU
09:01:39 <Eduard_Munteanu> Actually, type Producer m o = forall i. Conduit i m o, to be more specific.
09:02:42 <Taneb> Oh well, then I am not sure
09:04:28 <sie> If I define a functor on a datatype of list(it has some guts), then it overshadows the list functor and I can invoke it only with "map", yes?
09:05:21 <Eduard_Munteanu> sie: type Foo a = [Bar a]? You shouldn't be able to.
09:05:39 <sie> To make Foo a functor?
09:05:46 <Eduard_Munteanu> sie: yes
09:05:58 <dwcook> sie: Perhaps you want a newtype
09:06:06 <Eduard_Munteanu> sie: however you can make one for   newtype Foo a = Foo [Bar a]
09:06:26 <sie> Yes, I was talking about the newtype.
09:06:27 <armlesshobo> then really, the instance for Functor would just fmap over the list
09:06:40 <dwcook> sie: Well, in that case you can't even use map on the newtype, since map is defined over lists.
09:07:02 <Eduard_Munteanu> sie: then fmap works on the Foo functor: fmap :: (a -> b) -> Foo a -> Foo b, there's no list in the type
09:07:38 <sie> Hmm, but could I de-newtype it and then use it as a list?
09:07:45 <Eduard_Munteanu> sie: sure
09:07:50 <sie> How?
09:08:19 <Eduard_Munteanu> sie: or define a   withFoo :: ([Bar a] -> [Bar b]) -> Foo a -> Foo b
09:08:24 <Eduard_Munteanu> sie: pattern-match
09:09:06 <sie> Oh, I forgot about the pattern match.
09:09:31 <dwcook> As long as the constructor for your type is in scope, it can be pattern matched. Conversely, if it isn't, it can't.
09:09:53 <Eduard_Munteanu> withFoo . fmap :: (Bar a -> Bar b) -> Foo a -> Foo b   -- for example
09:12:35 <ddellaco_> what's the fastest way to get to the source of a function from ghci?
09:13:22 <mister_integer> ^^I am also curious to know if there is an answer to this
09:14:29 <glguy> There isn't a "get source" command. The best you have is the :edit command to launch your editor on a local file
09:14:43 <ddellaco_> (the fastest way I've found so far is to use :hoogle -> open up source on the web)
09:17:29 <zett_zelett> Can I define return :: Monad m => a -> m a in terms of (>>=) and fmap?
09:18:07 <byorgey> zett_zelett: nope
09:18:52 <zett_zelett> byorgey: Simple proof?
09:19:15 <S11001001> zett_zelett: types
09:19:28 <zett_zelett> S11001001: What do you mean by that?
09:19:33 <byorgey> zett_zelett: both (>>=) and fmap require an argument of type (m something).  You don't have any.
09:22:05 <zett_zelett> Hm.
09:22:39 <zett_zelett> That’s quite convincing, but isn’t ()  :: m a?
09:22:52 <glguy> no, () :: ()
09:23:32 <zett_zelett> Oh.
09:23:49 <glguy> ?djinn (m a -> (a -> m b) -> m b) -> ((a -> b) -> m a -> m b) -> a -> m a
09:23:49 <dwcook> undefined :: m a -- Have fun! Just kidding
09:23:49 <lambdabot> -- f cannot be realized.
09:24:20 <n-dolio> glguy: That's not really definitive.
09:24:38 <n-dolio> The hypotheses you provided can only produce (m b)s, but the output requires an (m a).
09:24:47 <glguy> n-dolio: I didn't write "qed"
09:25:43 <zett_zelett> So fmap and (>>=) are equivalent (in terms of definabilty by the other), as long as return is provided?
09:26:23 <S11001001> zett_zelett: no
09:26:29 <benj_> you need join to define >>= in terms of fmap
09:26:43 <zett_zelett> Ah, well.
09:26:44 <zett_zelett> Yes.
09:26:52 <nick_named> As I understand it you can define Monads with (fmap, join) or (bind, unit)
09:27:09 <S11001001> nick_named: you need unit in both cases
09:27:10 <glguy> nick_named (unit, fmap, join) or (bind, unit)
09:27:22 <zett_zelett> Okay.
09:27:26 <zett_zelett> Great, thanks!
09:29:19 <nick_named> Yeah that makes sense, thanks.  Then there is also another definition right?  The (mu :: a -> m a) and (eta :: m (m a) -> m a)
09:29:58 <nick_named> Oh right thats join
09:30:27 <zett_zelett> The convention is η : a → m a and μ : m (m a) → m a, I think.
09:30:33 <zett_zelett> η being the unit, and μ being join.
09:31:43 <nick_named> Oh okay, its the same as fmap and join, you just still need the unit/return function.
09:32:57 <glguy> m >>= f = join (fmap f m); join m = m >>= \x -> x; fmap f m = m >>= \x -> return (f x)
09:33:48 <zett_zelett> fmap f m = m >>= (return . f)
09:36:08 <dwcook> For that matter for any Monad instance you can define Functor with fmap = liftA and Applicative with pure = return and (<*>) = ap.
09:36:09 <dwcook> @src ap
09:36:09 <lambdabot> ap = liftM2 id
09:36:16 <dwcook> @src liftA
09:36:16 <lambdabot> liftA f a = pure f <*> a
09:36:25 <dwcook> It could also be fmap = liftM
09:36:33 <dwcook> All three are equivalent in terms of power
09:37:03 <dwcook> (fmap, liftA, liftM, that is)
09:37:40 <dwcook> Actually not for any, you have to have defined (>>=)
09:38:46 <dwcook> Ah, I know what I was thinking of. join isn't even a method yet
09:38:50 <Tjr> Hi, is there some way to get certified in Haskell? Something like codeacademy, khan academy, corsera, MSCE?
09:38:50 * hackagebot OpenSCAD 0.2.0.0 - ADT wrapper and renderer for OpenSCAD models.  http://hackage.haskell.org/package/OpenSCAD-0.2.0.0 (MikeMeyer)
09:39:38 <Tjr> I live in a country crazy for degrees, so I'd like to have something to put on my resume.
09:39:45 <pjdelport> Tjr: Publish useful libraries.
09:40:08 <pjdelport> Tjr: That's the best thing any prospective Haskell employer will be looking at.
09:40:17 <Tjr> pjdelport: maybe something that a HR drone will recognize?
09:40:43 <zett_zelett> Tjr: What country?
09:40:46 <Tjr> Germany
09:40:51 <minkowski> control HR drone by haskell ;)
09:41:21 <pjdelport> Tjr: Just cite it; if a HR drone doesn't recognize it, and hasn't been instructed to recognize it, there's a very good chance you wouldn't want to be working for that company.
09:41:58 <Tjr> back to the library idea
09:42:20 <Tjr> As a post-LYAH newbie, I have no idea what's still missing from the ecosystem.
09:42:51 <glguy> Tjr: Write programs that are interesting to you. If you find that something doesn't exist that you needed, write it.
09:43:21 <Tjr> glguy: in the past, that has lead to ugly, non-reusable code. I guess I'm doing something wrong.
09:43:34 <minkowski> thats what im trying to do too :)
09:43:44 <glguy> There aren't any short-cuts, you just have to write lots of code and learn as you go
09:44:11 <minkowski> you grow with your work  and someday your code will get better
09:44:17 <glguy> (and read other people's code)
09:45:08 <pjdelport> And post your work in progress for critique / advice!
09:45:29 <pete__> What would be a suitable functional algorithm for calculating shortest paths on a directed graph in Haskell?
09:47:02 <flebron> So the free theorem for f :: (a -> b) -> [a] -> [b] is (g . b = g' . a) => map b (f g xs) = f g' (map a xs). Does this have a reasonable categorical interpretation?
09:47:04 <flebron> pete__: Data.Graph.
09:47:23 <pete__> flebron: That looks a lot like an implementation
09:47:37 <flebron> That's because it is.
09:48:51 <flebron> You can look at the equations defining them to see "the algorithm", but it's just plain old BFS. https://hackage.haskell.org/package/fgl-5.4.2.4/docs/Data-Graph-Inductive-Query-BFS.html
09:49:42 <Tjr> pete__:  A* is the de-facto standard algorithm.
09:51:23 <flebron> Tjr: He forgot to mention his graph is unweighted (he did so on another channel).
09:51:36 <flebron> And that he means all-pairs shortest paths.
09:51:48 <Tjr> so every edge has weight one.
09:52:21 <flebron> Yes. So A* is BFS.
09:55:43 <pl2> This is quite a general question, but, has anyone here made large applications in Haskell? How is it when dealing with complex abstractions?
09:56:36 <ij> http://www.haskell.org/haskellwiki/Haskell_in_industry
09:56:49 <bergmark> pl2: better than in any other language :-)
09:57:36 <pl2> bergmark, need more to convince me... ;)
09:58:17 <juanpablo_> In the context of GHC 7.10 can desugaring of do blocks be thought of as a join of all statements in the do block?
09:58:54 <juanpablo_> I mean by using join instead of >>=. My understanding is that join flattens a functors with functors inside
09:58:58 <bergmark> maintenance is the biggest win i think, it's very easy to upgrade dependencies or move stuff around, usually nothing can go wrong
10:00:02 <RchrdB> juandopazo, (m >>= f) is strictly equivalent in all cases to (join (fmap f m)), if that's what you mean.
10:00:06 <flebron> juanpablo_: join doesn't take lists, and you have to consider that a variable may be used after it's bound.
10:00:34 <RchrdB> juandopazo, although one nitpick: join needs a Monad instance, not a Functor instance.
10:00:38 <flebron> join x = x >>= id
10:00:39 <bergmark> and for abstraction you can trivially make type checked boundaries that control the effects of different parts of the application
10:00:56 * juandopazo needs a new name
10:01:13 <flebron> And x >>= f = join (f <$> x)
10:02:19 <pjdelport> juanpablo_: To be precise, every (>>=) that results in a monadic value on the right (other than explicitly using a redundant "return") will require a join.
10:02:22 <juanpablo_> flebron: how is join defined without recurring to >>=?
10:02:30 <flebron> It isn't.
10:02:37 <flebron> (join, return) is part of the signature of a Monad.
10:02:44 <flebron> Alternatively, it's equivalent to (>>=, return).
10:03:09 <juanpablo_> I mean, you can choose to define join instead of defining >>=, right?
10:03:10 <yogurt_truck> one is the other one but "flipped" right?
10:03:10 <FreeFull> Some monads are more easily defined in terms of join
10:03:11 <flebron> To give join or to give >>= is the same, and neither one is more powerful than the other, they entirely overlap.
10:03:22 <flebron> juanpablo_: Not in the Monad typeclass, at least IIRC.
10:03:31 <FreeFull> flebron: I think it was added to Monad relatively recently
10:03:37 <flebron> That is, something "is a" Monad when it defines the functions in its typeclass.
10:03:40 <juanpablo_> flebron: I mean in GHC 7.10
10:03:45 <flebron> Ah, I didn't know if the minimal definition had been added :)
10:03:46 <FreeFull> juanpablo_: I think so
10:03:47 <FreeFull> Try it
10:03:57 <flebron> *minimal complete definition
10:04:03 <juanpablo_> FreeFull: will do as soon as I get off work :)
10:04:18 <flebron> join is more natural from a category theory standpoint, >>= is more natural from a programming standpoint.
10:04:40 <geekosaur> not entirely; I would claim join is more natural for [] at least
10:04:52 <juanpablo_> geekosaur: how so?
10:04:53 <flebron> Fair enough :)
10:05:02 <flebron> join :: [[a]] -> [a]
10:05:06 <flebron> Who's that Pokemon?
10:05:10 <pjdelport> It's probably subjective. I find join more natural in about all cases. :)
10:05:23 <juanpablo_> I find join much nicer as well. Much more intuitive
10:05:24 <pjdelport> Also, obligatory link: http://www.haskell.org/haskellwiki/Functor-Applicative-Monad_Proposal
10:05:38 <geekosaur> bind "flows" better for IO. it's rarely quite that clear for other monads though
10:05:41 <flebron> >>= reads more like "feed into", which is a programming-y way of looking at things.
10:06:01 <pjdelport> I find join better for IO too.
10:06:06 <FreeFull> http://hackage.haskell.org/package/base-4.7.0.0/docs/src/Control-Monad.html
10:06:07 <flebron> join is the traditional natural transformation, and has a way prettier type, especially when you combine it with return and the monad laws.
10:07:04 <FreeFull> The function monad (Reader) is easier to write in terms of join
10:07:20 <pl2> bergmark, thanks, i'll read up on the dependency handling. It's always a good thing when that is simpler
10:07:27 <flebron> i.e. join . fmap return = join . return = id, join . join = join . fmap join
10:07:36 <flebron> Saying that with >>= will be ugly, I bet.
10:08:46 <FreeFull> http://git.haskell.org/packages/base.git/blob/HEAD:/Control/Monad.hs Hmm, even here it's still not part of the typeclass
10:09:05 <FreeFull> That repo hasn't been updated since april though
10:26:43 <Smilex> How can I cast a Ptr () to a Ptr (MyType) ?
10:29:11 <zwer> castPtr
10:31:32 <Smilex> zwer: thanks
10:39:11 <Rufflewind> how does one deal with alignment issues in structs when using FFI?
10:42:21 <geekosaur> Rufflewind, usually we use something like c2hs that gets the alignment from the C compiler
10:42:32 <Smilex> Rufflewind: c2hs has a #alignof hook
10:42:50 <ReinH> Would >>= even exist without do notation?
10:43:04 <ReinH> =<< might since it's a form of "application"
10:44:35 <Rufflewind> geekosaur, Smilex: ah, so c2hs can handle it, thanks
10:44:57 <ReinH> flebron: My two favorite forms of the monad laws are join/return and (<=<)/return
10:45:15 <flebron> Ah yes, >=> will give you the category laws for Kleisli.
10:45:21 <ReinH> flebron: yep
10:45:22 <ParahSailin> i am trying to get some parallelism working http://lpaste.net/106183
10:45:36 <ReinH> flebron: depending on which way you like to write composition ;)
10:45:50 <ReinH> flebron: the former, ofc, showing the monoidal structure
10:45:53 <ParahSailin> inflateBlock is an ffi operation that takes about 1ms, so that would seem like a good one to use `par` on, right?
10:46:55 <ParahSailin> but im getting very poor gains using the parList from parallel, like 20% or so reduction in execution time
10:47:44 <ReinH> ParahSailin: that seems likely to be too fine-grained
10:47:55 <ReinH> so you might be paying too much overhead on spark generation / consumption / collection
10:48:16 <ParahSailin> ah 1ms is too small even?
10:48:28 <ParahSailin> i thought too small would be something like 1us
10:48:33 <ReinH> ParahSailin: it's relatively large, but it seems possible
10:48:38 <ReinH> ParahSailin: you might experiment with batching
10:49:21 <ReinH> ParahSailin: check out threadscope
10:49:46 <ReinH> ParahSailin: SimonM's book does a nice job of explaining threadscope for analyzing threaded performance
10:49:52 <ParahSailin> my test program is also hanging for a very long time at the end, defunct/Z status
10:49:52 <thoughtpolice> keep in mind that the RTS doesn't just create sparks, it also has to put them in a work-stealing queue, and then gradually pull them out as it can. if a spark 'fizzles' (meaning it's evaluated before it's pulled off the queue), it's overall a loss
10:50:13 <thoughtpolice> so you need the right granularity to ensure the queue is filled/drained consistently, rather than having lots of fizzling for small sparks
10:50:48 <thoughtpolice> an easy approximation is to run with '+RTS -s'
10:51:02 <thoughtpolice> the results should tell you how many sparks fizzled or were actually sparked into separate lightweight threads
10:51:44 <thoughtpolice> if all your sparks fizzle, well, there you go. you'll need a slightly higher work-size. but also FFI-ness may cause issues as well, keep in mind
10:52:23 <thoughtpolice> particularly, if inflateBlock is marked 'safe', it also has some pessimistic cases where it has to take RTS locks, etc, to ensure it's properly safe. so things may not work out so well with sparks. if it's unsafe, then you need to be careful you don't starve the GC by taking too long
10:52:30 <ParahSailin> "SPARKS: 72288 (71281 converted, 0 overflowed, 0 dud, 0 GC'd, 1007 fizzled)"
10:52:53 <ReinH> It's nice to have an expert around :)
10:52:55 <thoughtpolice> OK, so definitely not all fizzling. then it's probable the actual work-per-spark is too low still
10:53:17 <ReinH> thoughtpolice: <3
10:53:28 <ParahSailin> the ffi is "foreign import ccall unsafe"
10:53:49 <thoughtpolice> OK, then it shouldn't have any lock taking. a first approximation would be to look at the eventlog through threadscope.
10:54:12 <thoughtpolice> this can show you the distribution of the spark queue, and the GC activity, over the time of your benchmark
10:54:16 <ReinH> thoughtpolice: what would a second approximation be?
10:54:30 <thoughtpolice> well, i suppose threadscope is really the second approximation :)
10:54:34 <thoughtpolice> +RTS -s is the first :P
10:54:43 <ReinH> thoughtpolice: ok, what's after threadscope?
10:54:52 <ReinH> core?
10:54:52 <ParahSailin> would manually doing forkIO and using mvars help the RTS?
10:55:07 <thoughtpolice> Core wouldn't help here, really, since it's more of a work balancing issue.
10:55:11 <ReinH> core wouldn't help, no
10:55:51 <thoughtpolice> the best is really to play with the work size and see how this affects the spark distribution, for example. you don't want billions of sparks for one, and you also don't want too many sparks at the same time
10:56:15 <ParahSailin> my machine is a headless server, looks like it would be hard to use threadscope
10:56:28 <thoughtpolice> ParahSailin: you can emit the eventlog from your program, scp the eventlog back, then run it locally
10:57:16 <ParahSailin> ah ok
10:57:36 <thoughtpolice> ParahSailin: you may also like 'ghc-events-analyze' which was written by one of my coworkers - http://www.well-typed.com/blog/86/
10:57:54 <thoughtpolice> it can give you a different view on the work distribution
10:57:58 <thoughtpolice> (and it doesn't require GTK)
10:59:17 <thoughtpolice> ParahSailin: but yes, my first recommendation is to look at evening out the work distribution, by making sure every block of work is appropriately coarse (not too small to be detrimental), and making sure the work distribution is 'even' (so you don't load up 10,000 sparks at once, then wait for them all - it would be better to batch the sparks incrementally, to avoid GC and RTS pressure)
10:59:52 <ParahSailin> it is only supposed to be doing like 70 sparks at a time when multiplexing 70 files
11:00:00 <thoughtpolice> and yes, I also recommend reading SimonM's new book, since it's available online
11:01:01 <ReinH> thoughtpolice: oh cool
11:01:24 <ParahSailin> is -eventlog part of package threadscope or already existing in ghc?
11:01:39 <thoughtpolice> -eventlog is a compiler option, it should Just Work
11:01:50 <thoughtpolice> you can just relink your app with -eventlog
11:02:01 <thoughtpolice> then you can run it with '+RTS -l<name-of-eventlog.file>'
11:02:02 <thoughtpolice> IIRC
11:04:49 <ParahSailin> why would the program be hanging for a long time as a zombie after it finishes
11:05:13 <geekosaur> zombie implies an issue with the thing that ran the program
11:05:36 <ParahSailin> oh, i guess that would be bash time
11:06:03 <geekosaur> the program itself is dead, there's nothing left but its process table entry and that is waiting for the caller to waitpid() and collect the result
11:06:55 <ParahSailin> not zombie i guess, D+ status
11:07:06 <geekosaur> oh
11:07:16 <geekosaur> that would probably mean it's doing a lot of I/O
11:07:24 <geekosaur> Dis disk wait
11:07:56 <geekosaur> *probably* it's writing out the event log or profile or whatever, if you enabled that
11:08:17 <thoughtpolice> yes, the eventlog will probably take a bit of time to flush to disk
11:08:21 <thoughtpolice> (sometimes they can get quite large)
11:08:28 <ParahSailin> ah, no, theres a lot of disk io intrinsic to the program
11:08:42 <danilo2> Hello :) Is there any Haskell extension, which would allow ghc to choose one of overlapping instances based on the instance context? (I've found some old papers about such proposal, like here: http://okmij.org/ftp/Haskell/TypeClass.html)
11:08:43 <ParahSailin> but still, it doesnt hang so much when i run singlethreaded
11:09:27 <merijn> If I ctrl-C haddock generation, will that break the install process of "cabal install"?
11:10:00 <Lutin`> ParahSailin: You could strace it
11:10:15 <merijn> Because this doc generation is taking ages, but I don't want to accidentally kill all the compilation cabal already did...
11:11:19 <Lutin`> Looks like there's also something called fatrace that uses fanotify to only show a processes file access instead of every damn kernel call
11:13:44 <defanor> is there a way to load a source in haskell-mode, using libraries from a cabal sandbox?
11:19:55 <ParahSailin> hm, when i attempt to build `ghc-events-analyze' in a fresh sandbox it fails because of conflicting requirements
11:33:00 <Dodek> argh. i'm trying to use Parsec with ByteString and Word8. Parsec doesn't have (Monad m) => Parsec.Stream ByteString m Word8 instance (only Char instance), so i make one.
11:33:12 <Dodek> and i get     Functional dependencies conflict between instance declarations:
11:33:22 <Dodek> between Char and Word8
11:33:25 <Dodek> what should i do?
11:33:54 <johnw> where is that instance defined?
11:34:06 <johnw> (the Char one)
11:34:17 <rwbarton> could make a newtype of ByteString
11:34:26 <rwbarton> ByteStringNoReallyAStringOfBytes
11:34:32 <johnw> yeah, you're going to need a newtype somewhere
11:34:44 <Dodek> johnw: in Text.Parsec.ByteString
11:35:20 <Dodek> the thing is that the parser i'm trying to use is Stream s m Word8 => ParsecT s u m (Collection, [Warning])
11:35:32 <Dodek> so i probably have to newtype Foo = Foo ByteString
11:35:37 <Dodek> and use Foo as s in there
11:35:47 <Dodek> :(
11:37:04 <johnw> yes
11:38:16 <jle`> is ther eany way to get a point :: a -> f a/unit :: f () from Traversable
11:38:22 <jle`> Traversable f
11:38:42 <johnw> no
11:38:50 <jle`> sad times
11:38:51 <jle`> ;_;
11:38:59 <johnw> you need Applicative at least
11:39:17 <jle`> i suspected so
11:39:19 <jle`> thanks
11:39:28 <Eduard_Munteanu> Or Pointed, if you saw it around.
11:39:40 <johnw> Pointed is generally regarded to be evil, in the same way that Default is
11:40:27 <jle`> ty Eduard_Munteanu , i had heard of it but was trying to have my interface have as general constraints as possible.  i guess i will have to make it Applicative
11:44:55 <jle`> hm. is there really no foldr (<|>) empty ?
11:45:11 <johnw> asum
11:45:43 <jle`> oh it's in Foldable
11:45:46 <jle`> thanks
11:45:47 <jle`> :)
11:45:58 <Eduard_Munteanu> Sometimes "choice" in parser combinators.
12:03:22 <bvad> Hello guys, I'm having an issue with my module file hierachy. So I have a root folder A, with a module folder M which contains my module .hs files, and a subfolder of M, M2, which contains some more specialized components of said module. Basically I end up having module names like M.ModuleName M.M2.Module name. Now if I try to access M.M2.Module from M.Module hdevtools complains that it cannot find said
12:03:24 <bvad> module, but if I run a program in A, the modules are found just fine.. How should I handle this correctly?
12:03:34 <phi__> to anyone familiar with Edward Kmett's ad library, is it possible to compute higher order partial derivatives using it?
12:03:48 <edwardk> yes
12:03:55 <johnw> lol
12:04:03 <phi__> how
12:04:08 <phi__> please explain
12:04:08 <johnw> ah, n/m
12:04:34 <edwardk> :t Numeric.AD.grads
12:04:35 <lambdabot> Not in scope: ‘Numeric.AD.grads’
12:04:38 <edwardk> shucks
12:04:50 <edwardk> grads :: (Traversable f, Num a) => (forall s. f (AD s (Sparse a)) -> AD s (Sparse a)) -> f a -> Cofree f a
12:05:08 <edwardk> that gives you back a cofree comonad full of the answer and all the higher order derivatives
12:06:01 <phi__> edawrdk it can't find this module here http://hackage.haskell.org/package/ad
12:06:13 <edwardk> Numeric.AD
12:06:15 <edwardk> look for grads
12:07:17 <phi__> edawrdk thanks,
12:07:40 <edwardk> grads (\[x,y] -> x * y) [1,2]    -- will given back Cofree [] a    which looks like   a :< [df/dx :< [df^2/dx^2 :< ...), (df^2/dxdy :< ...)], df/dy :< .... ]
12:08:15 <edwardk> Cofree f a = a * f (a * (f (a * f (...
12:08:23 <edwardk> you can also peel it apart into an 'omega jet'
12:08:43 <benzrf> cofree why not coffee
12:08:49 <edwardk> data Jet f a = a :- Jet f (f a)
12:08:50 <benzrf> @let type Coffee = Cofree
12:08:51 <lambdabot>  .L.hs:168:15:
12:08:51 <lambdabot>      Not in scope: type constructor or class ‘Cofree’
12:08:51 <lambdabot>      Perhaps you meant ‘Coffee’ (line 168)
12:09:04 <edwardk> then you have a :- f a :- f (f a) :- f (f (f a)) :- ....
12:09:18 <edwardk> and you can walk down with tailJet to get to the nth position which will be f^n a
12:09:32 <edwardk> that gives you the tensor of all the nth partial derivatives
12:09:41 <phi__> edawrdk let me take all that in, you know I normally feel overwhelmed when I manage to understand a library written by you
12:09:42 <nick_named> You can always use more Coffee when trying to understand Cofree...
12:10:06 <edwardk> headJet $ tailJet $ jet $ grads (\[x,y] -> x*y) [1,2] -- gives first derivatives
12:10:17 <edwardk> headJet $ tailJet $ tailJet $ jet $ grads (\[x,y] -> x*y) [1,2] -- gives second derivatives, etc.
12:10:27 <edwardk> the cofree comonad or jet gives you all of them at the same time
12:10:45 <phi__> edwardk I only need derivatives upto second order so that's good enough me
12:10:57 <edwardk> if you just want 2 orders you can use hessian
12:11:01 <edwardk> or hessian'
12:11:20 <edwardk> hessian' :: (Traversable f, Num a) => (forall s. f (AD s (Sparse a)) -> AD s (Sparse a)) -> f a -> (a, f (a, f a))
12:11:25 <edwardk> or
12:11:26 <edwardk> hessian :: (Traversable f, Num a) => (forall s. Reifies s Tape => f (On (Reverse s (Sparse a))) -> On (Reverse s (Sparse a))) -> f a -> f (f a)
12:12:07 <edwardk> use hessianF if you have more than one output
12:12:24 <ReinH> :-f is a face. I have no idea what is happening.
12:12:35 <joelteon> a:-f
12:12:38 <ReinH> For that matter, so is :<
12:12:44 <joelteon> it's an unhappy man with a stroke and a cool hat
12:13:19 <phi__> edawrdk I actually want to use them in modelling Lagrangians from classical mechanics, basically implementing Euler-Lagrange, do you think it's a good idea
12:13:38 <edwardk> http://hackage.haskell.org/package/lagrangian
12:13:54 <ReinH> Oh, jfischoff, nice
12:13:55 <edwardk> works pretty well ;)
12:14:03 <edwardk> (the approach, not necessarily that lib)
12:14:07 <ReinH> heh
12:14:50 <edwardk> i seem to recall that his constraint vocabulary didn't work, but you'd have to ask him directly
12:14:51 <phi__> edwark that's different thing, it meant this http://en.wikipedia.org/wiki/Euler%E2%80%93Lagrange_equation
12:16:20 <edwardk> thats the problem with langrange. he did everything. so you can't pin down something by just his name alone =)
12:16:58 <phi__> yeah but in Physics community you say Lagrangian and everybody knows what you mean
12:17:29 <edwardk> true nuff
12:18:57 <edwardk> anyways "should work" still holds =)
12:19:00 <phi__> do you know of any resource about  solving pde's using ad?
12:19:42 <edwardk> if you come up with good ones send them my way
12:20:26 <edwardk> http://hackage.haskell.org/package/lazysplines-0.1/docs/Numeric-LazySplines.html can solve some differential equations, but it doesn't use ad directly
12:21:05 <edwardk> let me see if i can find a nice reference i liked
12:21:58 <edwardk> look at michigan state. almost anything by martin berz
12:22:21 <edwardk> in particular at all his work on 'taylor model methods'
12:24:22 <phi__> google gives this http://link.springer.com/article/10.1023%2FA%3A1020103610525 but I don't have access to it
12:27:21 <koala_man> phi__: http://www.vidarholen.net/~vidar/automatic_differentiation.pdf
12:28:13 <phi__> thanks koala_man
12:29:50 <RyanGlScott> Is it possible to use both hsc2hs and Template Haskell in the same file?
12:32:33 <geekosaur> RyanGlScott, sure. hsc2hs is a separate preprocessor, it outputs a .hs file which can have TH in it. afaik the syntax of the two does not collide?
12:32:59 <joelteon> hsc2hs splices are always #{...} aren't they
12:33:20 <RyanGlScott> I mean the other way around, i.e., have Template Haskell produce code which is then preprocessed by hsc2hs.
12:33:33 <geekosaur> that's my recollection, hsc2hs uses # TH uses $ and [foo| ... ] quasiquotes
12:33:41 <geekosaur> no
12:33:49 <RyanGlScott> Ah, hamburgers.
12:35:00 <RyanGlScott> How about a slightly different question: is there a good way to reduce hsc2hs code smell like this? https://github.com/RyanGlScott/hermit-bluetooth/blob/master/src/HERMIT/Bluetooth/Win32.hsc#L150
12:35:16 <geekosaur> but TH can do stuff in IO, in theory it could hsc2hs a chunk of source and then process that --- but I suspect that would be fairly hairy to put together
12:35:32 <corgifex> c2hs?
12:36:13 <geekosaur> that was my thought too. dunno how well it works on Windows though
12:36:46 <RyanGlScott> Is there an example of using c2hs with a struct?
12:38:00 <RyanGlScott> Maybe I'm not looking hard enough, but this ( http://stackoverflow.com/a/4504674 ) suggests that c2hs isn't much better in this regard.
12:39:07 <geekosaur> mrrr? looks like it autogenerates the Haskell code
12:39:14 <geekosaur> so you wouldn't have to see it :)
12:39:22 <geekosaur> (and certainly wouldn't have to write it)
12:39:44 <geekosaur> which is kinda the point, make the computer do the ugly stuff instead of you having to do it by hand
12:40:42 <RyanGlScott> Except that you still have to type out all of the #gets and #sets, unless I'm mistaken.
12:41:35 <geekosaur> oh, I thought it was generating that part too. ick
12:43:01 <geekosaur> actually I think gtk2hs's version may do that part --- but it does so assuming gtk2/gtk3 behavior
12:43:56 <RyanGlScott> So could gtk2hs possibly give unexpected behavior with Windows API structs?
12:45:19 <geekosaur> I don't know. I think it somewhat likely though because windows api has a tendency to use Pascal conventions instead of C
12:46:15 <RyanGlScott> I've never doubted Windows' ability to give weird results, so I believe you.
12:47:16 <geekosaur> well, I think both Windows and original MacOS got it from Xerox
12:47:46 <geekosaur> the old Xerox PARC UI work was done in Pascal
12:53:09 <dagano> i have a module that imports fine into ghci (or compiles with ghc -c) .. then I wrote a Main.hs file which is just {module Main where \n import OTHERMODULE \n main = ...} when I try to compile with ghc -o out Main.hs OTHERMODULE.o .. i get a lot of "multiple definintion" errors
12:53:18 <dagano> is this a thing? why is it exploding?
12:53:40 <corgifex> try omitting the OTHERMODULE.o part
12:53:53 <dagano> sweet jesus
12:53:55 <dagano> thanks
12:54:10 <dagano> lol "did you try turning it off and on again" ?
12:55:03 <geekosaur> dagano: because ghc defaults to automatically linking in any modules you use, so if you list the .o yourself you're including it twice and it collides with itself
12:55:25 <dagano> yeah that's pretty clear.. thanks
12:57:51 <gilligan_> can anyone suggest me a way to determine the hoogle databases directory ? (i.e ~/.cabal/share/[ghc-version]/[hoogle-version]/databases
12:59:00 <albeit> Using aeson, if I have a sum type Foo of records, is there any way to tell aeson which data constructor to use when generically parsing the JSON?
12:59:31 <albeit> As in , data Foo = Bar { ... } | Baz { ...} deriving (Eq, Generic)
13:00:47 <dmj`> albeit: yes, write a custom FromJSON instance
13:01:40 <bergmark> albeit: if there is some difference in the fields of Bar and Baz or you have additional info such as the constructor name in the json, yes
13:02:34 <pyrtsa> gilligan_: I was thinking the same question just a moment ago. Couldn't come up with anything better than `strings $(which hoogle) | grep \.cabal/share/.\*/hoogle-\.\*`
13:03:19 <dmj`> albeit: just curious, what happens when you try to use generics when they both have the same fields?
13:04:36 <vova> Could someone help me with this error: http://pastebin.com/01D3b2Ut
13:05:13 <dmj`> vova: try removing L.pack, seems to be expecting a strict bytestring
13:05:31 <vova> I've tried to change the  default request http://hackage.haskell.org/package/http-client-0.3.3.2/docs/Network-HTTP-Client.html
13:05:34 <bergmark> dmj`, albeit: depends on what implementation you use, undisclosed so far :_)
13:06:33 <vova> dmj`: Perhaps you meant `L.pack' (imported from Data.ByteString.Lazy.Char8)
13:06:55 <vova> dmj`: It does not help
13:07:21 <albeit> dmj` bergmark: I actually haven't tried, I just (I guess wrongly) assumed that aeson wouldn't be able to tell which data constructor to use. The records all have different field names.
13:07:28 <tnks> I occaisionally hear people gripe about the numeric-related type classes in Haskell.  I didn't pay much attention to the complaints at the time. . . but now I'm curious.
13:07:37 <tnks> What's the typical complaint?
13:07:45 <dmj`> vova: what is the new error?
13:07:49 <Lutin`> So I'm working through the NICTA course, and I just finished the Applicative part. I managed to get "filtering :: Applicative f => (a -> f Bool) -> [a] -> f [a]" done but it just doesn't quite make sense how it's working on some inputs
13:08:09 <bergmark> albeit: i don't know the implementation, but i think it tags it with the constructor name
13:08:13 <Lutin`> The definition is "filtering p = foldr (\a -> liftA2 (\b -> if b then (a:) else id) (p a)) (pure [])"
13:08:28 <tnks> I'm mostly curious if it's a complaint about something acknowledged as a mistake or if it's debateable.
13:08:41 <dmj`> vova: oh sorry, that is the new error, read that wrong
13:09:07 <Lutin`> but I don't understand how "filtering (const [True, True]) [1,2,3] = [[1,2,3],[1,2,3],[1,2,3],[1,2,3],[1,2,3],[1,2,3],[1,2,3],[1,2,3]]"
13:10:03 <jle`> it's "every possible outcome", i guess you can look at it
13:10:20 <vova> dmj`: I'm trying to fix it somehow. The error is : "Could not much [Char] with Data.ByteString.Internal.ByteString
13:10:22 <jle`> your criteria is \_ -> [True, True]
13:10:37 <jle`> so the first case is "if it is True for all three, then you'll get [1,2,3]"
13:10:51 <jle`> the second case is "if it is True for 1 and 2, and True for 3, you'll get [1,2,3]"
13:10:56 <dmj`> vova: do you have OverloadedStrings enabled?
13:11:09 <jle`> it's a bit confusing because you have True for both options
13:11:14 <jle`> but if we call them True1 and True2
13:11:52 <vova> dmj`: Seems I've found the solution on stackoverflow.com
13:11:54 <jle`> the first result is "if it's True1 for all three", the second is "if it's True1 for the first two and True2 for the second", the third is "if it's True1 for the first one, True2 for the second, True1 for the third", etc.
13:12:04 <Lutin`> Oh okay
13:12:05 <dmj`> vova: what was it
13:12:19 <Lutin`> That explains the m^n length
13:12:22 <jle`> Lutin`: what do you get when you do filtering (\_ -> [True, False]) ?
13:12:46 <Lutin`> Aha
13:12:52 <jle`> you should get something like [[1,2,3],[1,2],[1,3],[1] ..]
13:12:54 <vova> One moment please, I'll try it, and then write here.
13:12:55 <Lutin`> [[1,2,3],[1,2],[1,3],[1],[2,3],[2],[3],[]]
13:13:02 <jle`> yeah
13:13:07 <jle`> the first case is if it's True for all three
13:13:13 <jle`> the second case is if it's True for the first two and False for the second
13:13:15 <jle`> etc.
13:13:29 <Lutin`> Yeah that makes sense
13:13:29 <jle`> until all combinations of 1 -> [True,False], 2 -> [True, False], and 3 -> [True, False] are satisfied
13:13:50 <Lutin`> Ahh there we go
13:13:52 <jle`> > replicateM 3 [True, False]
13:13:53 <lambdabot>  [[True,True,True],[True,True,False],[True,False,True],[True,False,False],[Fa...
13:14:02 <jle`> > replicateM 3 "TF"
13:14:04 <lambdabot>  ["TTT","TTF","TFT","TFF","FTT","FTF","FFT","FFF"]
13:14:16 <Lutin`> > filterM [True, False] [1,2,3]
13:14:17 <lambdabot>  Couldn't match expected type ‘a -> m GHC.Types.Bool’
13:14:17 <lambdabot>              with actual type ‘[GHC.Types.Bool]’
13:14:22 <Lutin`> Oh
13:14:29 <Lutin`> > filterM (const [True, False]) [1,2,3]
13:14:30 <lambdabot>  [[1,2,3],[1,2],[1,3],[1],[2,3],[2],[3],[]]
13:14:40 <silasm> take 63 . replicateM 64 "01"
13:14:40 <Lutin`> Aha, thanks jle`
13:14:44 <jle`> > mapM (\_ -> [True, False]) [1,2,3]
13:14:46 <silasm> > take 63 . replicateM 64 "01"
13:14:46 <lambdabot>  [[True,True,True],[True,True,False],[True,False,True],[True,False,False],[Fa...
13:14:47 <lambdabot>  Couldn't match expected type ‘a -> [a1]’
13:14:47 <lambdabot>              with actual type ‘[[GHC.Types.Char]]’
13:15:11 <jle`> replicateM x = mapM (\_ -> x)
13:15:19 <silasm> > (!!63) . replicateM 64 "01"
13:15:20 <lambdabot>  Couldn't match expected type ‘a -> [c]’
13:15:20 <lambdabot>              with actual type ‘[[GHC.Types.Char]]’
13:15:43 <Lutin`> > replicateM 3 "01"
13:15:45 <lambdabot>  ["000","001","010","011","100","101","110","111"]
13:15:46 <silasm> gah nevermind, sorry. That's the easy way to make ghci/lambdabot count in binary though.
13:15:48 <Lutin`> heh
13:15:51 <jle`> > replicateM 64 "01" !! 63 --silasm
13:15:53 <lambdabot>  "0000000000000000000000000000000000000000000000000000000000111111"
13:16:02 <silasm> yeah
13:16:25 <jle`> oh my replicateM statement was wrong >_> but you know what i mean
13:16:49 <ski> > showIntAtBase 2 intToDigit 63 ""  -- silasm
13:16:51 <lambdabot>  "111111"
13:17:07 <vova> dmj`: The solution does not help. Here it is : http://stackoverflow.com/questions/20733924/couldnt-match-expected-type-data-bytestring-internal-bytestring-with-actual-t
13:19:30 <jle`> Lutin`: it might be interesting to imagine what the ZipList Applicative instance would yield :)
13:19:43 <abstract-alf> heyo
13:21:01 <dmj`> vova: can you tell us what package you are using and paste more code
13:21:09 <Lutin`> vova: I think you might need strict bytestrings
13:21:31 <Lutin`> jle`: Not quite there yet :P
13:21:58 <jle`> abstract-alf: hi!
13:22:05 <dmj`> Lutin`: yes he should be, but he doesn't seem to have overloaded strings enabled so he's getting a cannot match [Char] w/ ByteString
13:22:09 <abstract-alf> jle`: 'elo!
13:22:34 <jle`> Lutin`: the ZipList instance is just [f, g, h] <*> [x, y, z] === [f x, g y, h z]
13:22:57 <jle`> instead of for normal lists, [f, g, h] <*> [x, y z] = [f x, f y, f z, g x, g y, g z, g x, h y, h z]
13:23:08 <Lutin`> dmj`: no he's getting cannont match Lazy.ByteString with Data.ByteString.Internal.ByteString
13:23:32 <vova> dmj`: Thank for your help. The issue is fixed.
13:23:56 <dmj`> vova: np
13:23:59 <nick_named> The easiest way to count learn to count to 7
13:24:01 <nick_named> > fmap (foldr (\c s -> s*2 + c) 0 . reverse . map (\c -> if c == '0' then 0 else 1)) $ replicateM 3 "01"
13:24:03 <lambdabot>  [0,1,2,3,4,5,6,7]
13:24:07 <jle`> some days i feel like a lazy internal bytestring
13:24:34 <cstanfill> sometimes you feel like a nut
13:24:37 <Lutin`> dmj`: Oh I missed the change
13:24:39 <Lutin`> Woops
13:24:51 <jle`> that too
13:25:16 <vova> dmj`: The solution on stackoverflow is right. I've just import Bytestring.Char8 . Thank
13:26:05 <ParahSailin> thoughtpolice: after fiddling around with those profiling tools, im finding that the benefits max out at around 8 capabilities-- when i go up to using 16 or 48 cores, it slows things down
13:26:14 <benzrf> int-e: yo you there?
13:27:22 <jle`> nick_named: that's how they taught it at my elementary school
13:36:10 <meretrix> I'm trying to debug a highly concurrent library.  It should use very little resources, but immediately after starting it, it burns through all of my memory.  How should I go about finding the problem?
13:37:18 <meretrix> I've tried throwing in some traceShows, but the results are very strange.
13:39:07 <Cale> meretrix: Well, how are they strange?
13:39:19 <Cale> (I suppose that they might be printing concurrently :)
13:40:02 <Cale> meretrix: Do you have some value being accumulated in an MVar or something which isn't being pattern matched on or otherwise evaluated anywhere in the program?
13:40:34 <meretrix> Cale: They're just print in a strange order and some that I expected to print are not printing.
13:40:39 <Cale> meretrix: It's possible to build up large expression graphs in parameters to recursive functions, IORefs, or other mutable state.
13:41:14 <Cale> Well, lazy evaluation is outermost-first, so if you're thinking in terms of strict evaluation, it'll almost be backwards.
13:41:47 <meretrix> Are there any profiling options that could identify the memory user?
13:42:01 <meretrix> I've tried a couple, but they just gave me a very generic type.
13:42:02 <Cale> Yeah, there's lots of heap profiling options which can help
13:42:43 <Cale> https://www.haskell.org/ghc/docs/latest/html/users_guide/prof-heap.html#rts-options-heap-prof
13:43:03 <meretrix> I tried -hT and the abuser was "ARR_WORDS" which doesn't mean much to me.
13:43:33 <Cale> That's the internal name for a type used to implement ByteString and Text
13:43:41 <Cale> as well as unboxed arrays
13:44:05 <Cale> Maybe try -hc?
13:45:28 <Cale> (and make sure you use -fprof-auto or at least one of the comparable options when compiling)
13:47:52 <kclark> i have several lines of code i'd like help explaining
13:48:06 <kclark> should i just paste them here or put them elsewhere and post a link?
13:48:23 <geekosaur> @paste
13:48:23 <lambdabot> Haskell pastebin: http://lpaste.net/
13:48:25 <pavonia> Put them on the page mentioned in the topic
13:49:17 <meretrix> hmm.. even with -fprof-auto, I'm getting "invalid heap profile option: -hc".
13:50:08 <kclark> http://lpaste.net/106192
13:50:22 <emrecelikten> Hello guys, I'm very very new to Haskell, could anybody tell me what's wrong with this piece of code? http://lpaste.net/106193
13:50:54 <Iceland_jack> emrecelikten: spelling mistake
13:50:55 <kclark> so i just can't seem to understand the subtleties of "$"
13:51:05 <Iceland_jack> the last clause should be 'fibonacci'
13:51:15 <deweyvm> (sum . replicate 5) ?
13:51:19 <emrecelikten> Oh damn it, I must be tired
13:51:21 <emrecelikten> Thanks
13:51:25 <corgifex> kclark: more like the "subtleties" of .
13:51:28 <Lutin`> meretrix: Try -prof -auto-all -caf-all -fforce-recomp
13:51:48 <jhance> kclark: sum . replicate 5 (max 6.7 8.9) = (sum) . (replicate 5 (max 6.7 8.9))
13:51:49 <corgifex> kclark: . combines two functions. your error case tries to combine a function and a list
13:52:01 <ski> > (sum . replicate 5) (max 6.7 8.9)
13:52:03 <lambdabot>  44.5
13:52:19 <kclark> ah, thanks corgifex
13:52:41 <Lutin`> kclark: Remember function application has the highest precendence
13:52:45 <jhance> kclark: Try: sum . replicate 5 $ max 6.7 8.9
13:53:06 <corgifex> that's why the error message complains about the return type of replicate, saying it got a list where it expected a function
13:53:27 <Eduard_Munteanu> Is there a generalization of forking to a typeclass supporting concurrent effects?
13:54:11 <kclark> so i just updated the paste to look at the :t of the two expressions
13:54:20 <kclark> they look the same to me "[a]"
13:54:28 <kclark> it looks like they both return a list, no?
13:54:43 <ski> jhance : they already did try that
13:55:35 <ski> @type replicate 5 (max 6.7 8.9)
13:55:37 <lambdabot> (Ord a, Fractional a) => [a]
13:55:39 <ski> @type sum . replicate 5 (max 6.7 8.9)
13:55:40 <lambdabot>     Couldn't match expected type ‘a -> [c]’ with actual type ‘[a0]’
13:55:41 <lambdabot>     Possible cause: ‘replicate’ is applied to too many arguments
13:55:41 <lambdabot>     In the second argument of ‘(.)’, namely ‘replicate 5 (max 6.7 8.9)’
13:56:02 <jhance> ski: No they didn't
13:56:10 <abstract-alf> @type sum $ replicate 5 (max 6.7 8.9)
13:56:11 <lambdabot> (Ord a, Fractional a) => a
13:56:14 <jhance> ski: Oh nevewrmind
14:12:02 <roconnor> Parsec!!!!
14:12:42 <abstract-alf> are you shaking your fist at Parsec or are you pumping your fist for Parsec?
14:12:53 <silasm> yeah, that seemed rather... context-free
14:13:22 <vanila> if you've used parsec you'd understand
14:13:39 <roconnor> abstract-alf: shaking my fist at Parsec
14:13:46 <roconnor> for it's failure to accurately parse Doubles
14:14:23 <roconnor> Parsec is like a billion years old.  Why doesn't it parse Doubles carefully?
14:15:32 <roconnor> specifically "0.8999666926843228" is parsed as "0.8999666926843227"
14:15:49 <darthdeus> is there a way to list all packages in a specific stackage snapshot?
14:17:06 <abstract-alf> roconnor: easy fix, just add 0.0000000000000001 to all parsed doubles ;)
14:17:53 <roconnor> no no that doesn't work ...
14:23:06 <meretrix> If I enable executable profiling with cabal and pass "-hc" at runtime, where is the profiling output stored?
14:23:32 <meretrix> I was expecting it either in the current diretory or dist/build/foo, but it's not there.
14:24:08 <pmade> meretrix: Should be in the current directory.  Are you placing -hc *after* +RTS?
14:24:57 <meretrix> pmade: doh.. thanks forgot the +RTS
14:36:45 <benzrf> @seen
14:36:45 <lambdabot> Say again?
14:36:49 <benzrf> how nice
14:36:50 <benzrf> @seen
14:36:50 <lambdabot> Say again?
14:36:53 <benzrf> @seen benzrf
14:36:53 <lambdabot> 8enzRph
14:36:58 <benzrf> >.>
14:37:16 <abstract-alf> u wot
14:37:42 <geekosaur> @seen edit-corrects to @leet aka @elite
14:37:42 <lambdabot> edI7-COrre(ts to @lE3+ aKa @E1i73
14:37:51 <geekosaur> ...like that :p
14:44:12 * hackagebot ABList 0.0.1 - An alternating list of two types  http://hackage.haskell.org/package/ABList-0.0.1 (DylanJust)
14:44:14 * hackagebot ABList 0.0.2 - An alternating list of two types  http://hackage.haskell.org/package/ABList-0.0.2 (DylanJust)
14:44:47 <jle`> interesting package
14:44:50 <jle`> i wonder what it's useful for
14:45:11 <vanila> seems weird when you could use pairs
14:45:18 <hpc> jle`: writing an optimal AI for chutes and ladders
14:45:26 <jle`> ah
14:45:49 <jle`> sounds like it might be useful for minimax or algos like that
14:46:00 <jle`> where you have inherently alternating streams
14:46:03 <hpc> lol, that was a joke
14:46:27 <hpc> for those algorithms you need an alternating tree
14:46:41 <Iceland_jack> Now we need an algernating list of three types, four types, … :)
14:46:42 <hpc> an alternating list is a tree with branching factor 1
14:46:51 <hpc> which represents games where no decisions are involved
14:46:53 <jle`> oh yeah.  something something handwavey definition of "like that"
14:47:08 <jle`> too bad the package isn't documented at all
14:47:32 <identity> I really love how backtracking comes for free in Haskell.
14:47:32 <jle`> hm
14:47:38 <jle`> it admits a useful bimap?
14:47:43 <identity> just wrote a rather simple, naive sudoku solver.
14:47:53 <jle`> and a questionably useful fmap
14:47:55 <jle`> identity: :)
14:50:03 <jonashw> :t ($)
14:50:04 <lambdabot> (a -> b) -> a -> b
14:50:08 <jonashw> :t flip . id
14:50:09 <lambdabot> (a -> b -> c) -> b -> a -> c
14:50:28 <jle`> :t flip
14:50:29 <lambdabot> (a -> b -> c) -> b -> a -> c
14:50:46 <jle`> (. id) = id :)
14:51:14 <jonashw> :t flip id
14:51:14 <lambdabot> b -> (b -> c) -> c
14:51:23 <jonashw> :t id
14:51:23 <ski> @type let id = (. id) in id
14:51:24 <lambdabot> a -> a
14:51:24 <lambdabot>     Occurs check: cannot construct the infinite type:
14:51:24 <lambdabot>       b1 ~ (b1 -> c1) -> c1
14:51:24 <lambdabot>     Expected type: (b1 -> c1) -> b1
14:52:04 <jonashw> :t flip ($)
14:52:05 <lambdabot> b -> (b -> c) -> c
14:52:17 <jonashw> :t id
14:52:18 <lambdabot> a -> a
14:52:21 <jle`> :t id `asTypeOf` ($)
14:52:22 <lambdabot> (a -> b) -> a -> b
14:52:38 <jle`> :t id `asAppliedTo` undefined
14:52:39 <lambdabot> b -> b
14:52:42 <jle`> aw
14:52:55 <ski> @type [id,($)]
14:52:56 <lambdabot> [(a -> b) -> a -> b]
14:53:43 <jle`> > map (`id` 5) [(+3), (*4), (^2)]
14:53:45 <lambdabot>  [8,20,25]
14:54:27 <meretrix> How long do I have to run my application with "-p" for it to populate the .prof file?  I kill the application after 10 seconds, but the .prof file is empty.
14:54:40 <hpc> how are you killing it?
14:54:51 <meretrix> hpc "killall foo"
14:55:22 <meretrix> It quickly eats my memory, so I have to kill it.
14:55:26 <geekosaur> meretrix, it's only written on normal exit I think
14:55:53 <meretrix> Hmm.. that's a problem then.  If I could get it to exit it normally, I wouldn't need to profile it. :)
14:57:47 <hpc> meretrix: have main start your process in a new thread
14:57:53 <hpc> then sleep 10 seconds, kill it, and exit
14:58:02 <meretrix> Thanks, I'll try that.
14:58:17 <hpc> (-threaded and -N as needed)
14:59:14 * hackagebot ABList 0.0.3 - An alternating list of two types  http://hackage.haskell.org/package/ABList-0.0.3 (DylanJust)
14:59:56 <hpc> how many uploads is this guy going to make?
15:02:28 <Lutin`> data ABList a b = Nil | Cons a (ABList b a)
15:02:40 <Lutin`> Shouldn't that work?
15:03:02 <Lutin`> Ah that's what he does
15:03:11 <Lutin`> Still not sure I see the use
15:03:19 <jle`> to be hair hackage is kind of had to work with because you can't preview your uploads' documentation really
15:03:25 <jle`> ...to be hair
15:03:39 <k00mi> Lutin`: yes, that's in fact how it is defined
15:03:51 <k00mi> oh, too slow ;)
15:04:14 <cloudhead> does Float and CFloat have the same internal represenation?
15:07:10 <hpc> cloudhead: with GHC, yes
15:07:17 <hpc> newtype CFloat = Float
15:07:24 <cloudhead> hpc: cool, thanks
15:07:28 <hpc> (er, something like that)
15:07:32 <hpc> cloudhead: don't rely on it though
15:07:35 <hpc> do things the right way
15:07:54 <cloudhead> hpc: so how would I convert between one to the other?
15:08:05 <cloudhead> I'm using coerce at the moment, which is why I ask
15:08:12 <merijn> cloudhead: ick
15:08:14 <merijn> cloudhead: realToFrac
15:08:18 <merijn> :t realToFrac
15:08:19 <lambdabot> (Real a, Fractional b) => a -> b
15:08:33 <hpc> cloudhead: i think you can pattern match?
15:08:36 <merijn> I think?
15:08:40 <cloudhead> ok I see
15:08:42 <hpc> foo (CFloat f) = f
15:08:47 <merijn> :t realToFrac :: Float -> CFloat
15:08:48 <lambdabot>     Not in scope: type constructor or class ‘CFloat’
15:08:48 <lambdabot>     Perhaps you meant ‘Float’ (imported from Prelude)
15:09:09 <cloudhead> hpc: oh really
15:09:17 <merijn> ok, realToFrac works
15:09:35 <Lutin`> cloudhead: Look at CTypes.h and HsBaseConfig.h
15:09:38 <cloudhead> so for the other way around, I can do (CFloat 4)?
15:09:42 <Lutin`> if you want to know the specifics
15:09:45 <merijn> This is all terrible >.<
15:09:49 <cloudhead> heh
15:09:51 <hpc> realToFrac should theoretically be optimized to unsafeCoerce, btw
15:09:58 <hpc> since they have the same internal representation
15:10:02 <merijn> realToFrac is portable, pattern match is GHC implementation detail specific
15:10:09 <cloudhead> yea, that's what it seems to do
15:10:30 <hpc> merijn: i have somehow managed to rope myself into writing java
15:10:49 <hpc> and have been doing much skywalker debugging because good api docs (and good apis) are absent
15:10:59 <merijn> hpc: :)
15:11:00 <hpc> bad habit :(
15:11:04 <merijn> hpc: Poor you :p
15:11:31 <hpc> (for the peanut gallery: skywalker debugging = "use the source, luke")
15:11:54 <merijn> I'm currently on day 7 or 8 of lots of Coq and tomorrow will be Agda, so I'm at the opposite spectrum in terms of type-experience :p
15:12:12 <hpc> heh
15:12:25 <Lutin`> Though I'm confused
15:12:50 <Lutin`> In CTypes.h FLOATING_TYPE takes 4 params
15:13:04 <Lutin`> but it's only called with 2 in Foreign.C.Types
15:14:26 <merijn> Lutin`: My source only has 2 params for FLOATING_TYPE in CTypes.h
15:15:11 <Lutin`> Oh
15:15:17 <Lutin`> Old CTypes.h
15:16:16 <kini> is there some way I can tell cabal to pass a certain flag to a certain dependency of a package in a sandbox?
15:16:26 <merijn> kini: Nope
15:16:44 <Lutin`> so `newtype CFloat = CFloat Float deriving (Eq,Ord,Num,Enum,Storable,Real,Typeable,Fractional,Floating,RealFrac,RealFloat)` and Read and Show instances
15:16:50 <Lutin`> that use unsafeCoerce#
15:17:07 <kini> for example, I want to build package A in a sandbox, but it has dependency B, so I do `cabal sandbox add-source /path/to/B`, but B needs to have "--flags=foo" passed to it when building (for the purposes of package A)
15:17:10 <kini> merijn: aww :(
15:33:17 <benzrf> @last
15:33:17 <lambdabot> What module?  Try @listmodules for some ideas.
15:33:20 <benzrf> meh
15:33:21 <benzrf> @help seen
15:33:21 <lambdabot> help <command>. Ask for help for <command>. Try 'list' for all commands
15:33:31 <benzrf> is there a 'last seen' command
15:35:54 <jle`> there was for preflex
15:36:05 <jle`> but preflex is no longer with us
15:36:19 <benzrf> @tell
15:36:19 <lambdabot> Who should I tell?
15:36:35 <benzrf> @tell int-e hey i need some advice for extending lambdabot
15:36:35 <lambdabot> Consider it noted.
15:37:37 <octophore> is there a newer version of the haskell-platform than "2013.2.0.0" ?
15:38:09 <quchen> octophore: Nope, next release is in the making
15:38:19 <octophore> okay
15:38:30 <octophore> I wonder where I should start looking for like
15:38:40 <davean1> octophore: you can always just grab the latest stuff from hackage though
15:38:45 <octophore> in Ubuntu 14.04 a huge number of basic libraries don't build in cabal
15:39:01 <octophore> I know canonical is -really- bad about keeping haskell related packages current and in-order
15:39:28 <quchen> Don't install Haskell packages via Aptitude. GHC and Platform are fine, but everything else should be done using Cabal.
15:39:40 <davean1> octophore: looks like you should have GHC 7.6.3?
15:39:40 <octophore> like WxHaskell as Cabal tries to install it, requires exactly LibWx 2.9, and Ubuntu provides 2.8 and 3.0
15:39:56 <octophore> yes, I have 7.6.3
15:40:13 <davean1> Oh well, WxHaskell is in NO way a basic lib
15:40:22 <octophore> hoogle won't compile either
15:40:31 <octophore> i.e. lambdabot won't compile because hoogle won't compile
15:40:53 <davean1> are all your problems library version problems?
15:41:24 <octophore> well as for WxHaskell I could just get LibWx 2.9 from source and compile it
15:42:08 <octophore> Hoogle fails with "src/General/Web.hs:50:26: Not in scope: `responseToSource' Failed to install hoogle-4.2.32 cabal: Error: some packages failed to install: hoogle-4.2.32 failed during the building phase. The exception was: ExitFailure 1"
15:42:45 <davean1> octophore: I see why too
15:42:54 <octophore> I don't know if that's Cabal not building packages in order (maybe there's a circular dependency?) or if I don't have a new enough GHC or what
15:43:01 <davean1> hoogle did a very bad practice and failed to use an upper bound on its package version
15:43:12 <benzrf> davean1: hey arent you the xkcd sysadmin
15:43:16 <davean1> it won't work with WAI 3
15:43:21 <octophore> what's WAI
15:43:30 <davean1> octophore: a web server API
15:43:33 <benzrf> octophore: it's the haskell web app interface
15:43:35 <octophore> thanks
15:43:44 <davean1> octophore: we can fix that for you with a command to cabal
15:43:50 <davean1> but hoogle authors should be ashamed
15:43:53 <benzrf> octophore: like rack or wsgi for haskell
15:43:54 <octophore> oh? I would greatly appreciate any help
15:44:39 <davean1> octophore: try: cabal install --constraint="wai < 3" hoogle
15:45:15 <octophore> in the process of building...
15:45:23 <davean1> octophore: mind you, they failed to use nearly any upper bounds
15:45:30 <davean1> so this might not be the only one we have to fix ...
15:46:21 <davean1> all we're doing is adding the missing build data in by hand for them
15:46:47 <octophore> hoogle seems to have successfully built!
15:46:59 <davean1> yay!
15:47:10 <davean1> so that was totally a hoogle problem, not a you problem
15:47:17 <octophore> thank you very much for the help
15:47:18 <heath> i'm thinking i'm going to go with clojurescript on the frontend and haskell for the server
15:47:22 <davean1> Of course
15:47:35 <octophore> as for Wx I'm just going to get the source to 2.9 and build it myself
15:47:44 <heath> i wish there was something as nice as clojurescript + om for haskell land
15:48:34 <davean1> octophore: you could build an older version of WxHaskell
15:48:36 <davean1> that used 2.8
15:48:48 <davean1> that would pretty much be the only other option
15:48:58 <octophore> I'll look into that too
15:49:02 <davean1> wx  0.13.2.3 uses 2.8
15:49:17 <davean1> I don't know that that is a good option, but it exists
15:49:24 <octophore> I feel like i'd rather take my chances breaking cabal than breaking aptitude, so I reckon i'll try getting the older WxHaskell
15:49:29 <davean1> (cabal install wx-0.13.2.3)
15:49:38 <octophore> oh you can grab old versions right from cabal?
15:49:39 <octophore> nice
15:49:44 <davean1> yep
15:49:48 <octophore> a thousand thanks for all the help
15:49:51 <davean1> any version that was on hackage
15:49:54 <davean1> of course
15:50:49 <davean1> octophore: think about it - cabal grabbed an older version when we told it we couldn't use newer WAI versions
15:51:00 <octophore> good point
15:51:29 <davean1> cabal is really a build tool
15:51:42 <davean1> to be a build tool you need historical versions
15:56:11 <dagano> :t (.&.)
15:56:12 <lambdabot>     Ambiguous occurrence ‘.&.’
15:56:12 <lambdabot>     It could refer to either ‘Data.Bits..&.’,
15:56:12 <lambdabot>                              imported from ‘Data.Bits’ at /home/lambda/.lambdabot/State/L.hs:57:1-16
15:57:11 <jle`> heh
15:58:23 <augur> calling are parsec hackers!
16:01:32 <dagano> can i represent binary explicitly for Data.Bits functions?
16:01:50 <dagano> > Data.Bits.ShiftR 2 '01101'
16:01:52 <lambdabot>  <hint>:1:21: parse error on input ‘01101’
16:02:10 <dagano> > Data.Bits.ShiftR 2 0xff
16:02:12 <lambdabot>  Not in scope: data constructor ‘Data.Bits.ShiftR’
16:02:26 <jle`> > 0b0110
16:02:26 <dagano> > Data.Bits.shiftR 2 0xff
16:02:28 <lambdabot>  Not in scope: ‘b0110’
16:02:28 <lambdabot>  can't find file: L.hs
16:02:39 <dagano> jle`: thanks
16:02:48 <dagano> > Data.Bits.shiftR 2 0b0110
16:02:50 <lambdabot>  can't find file: L.hs
16:03:06 <jle`> it's wrong
16:03:11 <dagano> what is L.hs ?
16:03:11 <jle`> i was trying it out heh
16:03:32 <jle`> L.hs is where lambdabot stores things people define here and some other stuff
16:03:40 <jle`> if it can't find it it means that there is a disk error of some sort
16:03:59 <jle`> i guess there are no binary literals in haskell?
16:04:35 <joelteon> doesn't look that way
16:04:36 <jle`> http://www.haskell.org/onlinereport/lexemes.html
16:04:57 <jle`> guess not
16:05:49 <dagano> ok thanks
16:05:57 <jle`> > "01101" ^? binary
16:06:00 <lambdabot>  Just 13
16:06:11 <dagano> :t (^?)
16:06:12 <lambdabot> s -> Getting (First a) s a -> Maybe a
16:06:20 <dagano> whaaaar?
16:06:31 <Iceland_jack> dagano: you can ignore the type
16:06:38 <jle`> > "01101" ^?! binary
16:06:40 <lambdabot>  13
16:06:48 <jle`> no substitute for binary literal of course
16:07:00 <Iceland_jack> > hex # 353
16:07:01 <jle`> cause of lack of compile time checking and resolution
16:07:02 <lambdabot>  "161"
16:07:03 <dagano> not really .. but cool nonetheless
16:07:14 <joelteon> > binary # 1
16:07:15 <lambdabot>  "1"
16:07:19 <Iceland_jack> An extenion was just merged for binary literals in GHC
16:07:26 <Iceland_jack> *extension
16:07:29 <dagano> > Data.Bits.shiftR 2 ("01101" ^?! binary)
16:07:31 <lambdabot>  0
16:07:35 <jle`> Iceland_jack: really? neat
16:07:42 <Iceland_jack> Yup, BinaryLiterals
16:07:57 <jonashw> @paste
16:07:57 <lambdabot> Haskell pastebin: http://lpaste.net/
16:08:02 <Iceland_jack> Add support for binary integer literals syntax (re #9224) - https://phabricator.haskell.org/D22
16:08:27 <Makoryu> Iceland_jack: Great! Now we just need base 64 literals and intraliteral underscores and we're good to go
16:08:29 <Iceland_jack> no merged, sorry
16:08:40 <Iceland_jack> Makoryu: Over my cold dead body :)
16:08:59 <Makoryu> Iceland_jack: Well, okay, maybe base 64 literals are a bit much. But underscores?
16:09:11 <Makoryu> Surely nobody can object to writing 1000000 as 1_000_000
16:09:39 <jle`> how about 1.e6
16:09:42 <jle`> ;)
16:10:05 <jle`> 1.0e6
16:10:14 <Iceland_jack> There is a new extension for writing integrals with scientific notation
16:10:24 <jonashw> made my own shuffle function for lists.. thoughts? http://lpaste.net/106197
16:10:45 <jle`> i could have sworn that it was in 7.8
16:10:47 <jle`> hm
16:10:57 <Iceland_jack> NumDecimals
16:11:08 <jle`> there it is
16:11:09 <jle`> ty
16:11:12 <Iceland_jack> ghci> :set -XNumDecimals
16:11:12 <Iceland_jack> ghci> 1.2e6 :: Integer
16:11:12 <Iceland_jack> 1200000
16:11:15 <Makoryu> jonashw: What if you want to shuffle more than one list
16:13:04 <jonashw> Makoryu: I would need to also the altered stdGen with my shuffled list
16:13:19 <jonashw> I would need to also *return* the altered stdGen with my shuffled list
16:14:20 <jonashw> do g <- newStdGen; print $ map (shuffle g) $ ["My name is Jacob","My name is Jacob"]
16:14:23 <jonashw> ["Moyi bJmnaesa c ","Moyi bJmnaesa c "]
16:15:33 <jonashw> is there a monad for random generators?
16:15:46 * Makoryu shrugs
16:15:50 <Makoryu> StateT?
16:15:57 <ParahSailin> @hoogle MonadRandom
16:15:59 <Iceland_jack> @google MonadRandom
16:15:59 <lambdabot> package MonadRandom
16:15:59 <lambdabot> package MonadRandomLazy
16:16:00 <lambdabot> https://hackage.haskell.org/package/MonadRandom
16:16:06 <jonashw> danke
16:25:06 <pjdelport> jonashw: Note that that algorithm is very inefficient: exponential time or worse.
16:25:41 <pjdelport> jonashw: Do you know the https://en.wikipedia.org/wiki/Fisher–Yates_shuffle algorithm?
16:26:44 <l0cust> So, having a continual problem with aeson
16:27:41 <l0cust> When I give it a non-recursive file, like this http://ix.io/d7e
16:27:45 <l0cust> it works fine
16:28:24 <l0cust> However, if I give it a mildly recursive file like this (http://ix.io/d6L
16:28:30 <l0cust> It gives me this error
16:28:36 <l0cust> (my test does)
16:28:51 <l0cust> "key \"phrase\" not present"
16:28:52 <l0cust> *** Exception: ExitFailure 1
16:28:52 <l0cust> *Main>
16:29:27 <l0cust> Here's the Haskell file - http://lpaste.net/106199
16:29:34 <l0cust> the library
16:29:46 <l0cust> Here's the test - http://lpaste.net/106200
16:30:55 <l0cust> ruby and jsonlint both say my json is valid
16:31:21 <l0cust> Well, I used a Ruby script to generate it, so I certainly hope it's valid
16:37:33 <l0cust> Any ideas?
16:38:59 <l0cust> I don't think it's correct
16:39:07 <l0cust> The error message
16:39:14 <l0cust> I opened up the file in ruby
16:39:17 <l0cust> *emacs
16:39:25 <l0cust> and searched for
16:39:36 <l0cust> {\n +"[^p]
16:39:38 <l0cust> and got no hits
16:39:50 <l0cust> so there isn't an object whose first key isn't "phrase"
16:40:02 <l0cust> Claming that the key is not pressent is just wrong
16:40:09 <l0cust> *present
16:42:38 <asmyers> l0cust: There are elements which don't start with "phrase", all the arrays
16:42:57 <l0cust> Yes, but aeson knows it's traversing a tree
16:43:05 <l0cust> *list
16:43:53 <l0cust> aeson has instances for list
16:43:57 <l0cust> *an instance
16:44:17 <l0cust> I'm giving it an instance for PAT
16:44:21 * hackagebot music-util 0.14 - Utility for developing the Music Suite.  http://hackage.haskell.org/package/music-util-0.14 (HansHoglund)
16:44:35 <l0cust> It knows that the last field is of type [PAT]
16:55:01 <Lutin`> pjdelport: Fisher-Yates wouldn't work as well on a linked list
16:56:24 <Lutin`> Since it relies on O(1) random access and O(1) swapping
16:57:11 <pjdelport> Lutin`: It would work better in this case, at least, and you can always make the implementation use a mutable array internally. :)
16:58:05 <Lutin`> Yeah that would work
16:58:14 <Eduard_Munteanu> Suppose you have some sort of channel you can read from from one end and write to the other: send :: i -> m (); recv :: m o  for some monad m.
16:58:45 <Lutin`> best you're going to get with a sort is linearithmic
16:59:15 <Eduard_Munteanu> Now (i -> m (), m o) looks a bit like an indexed store comonad over some category of a monad... is there more to this?
16:59:28 <pjdelport> Lutin`: It's not the sorting that's expensive, it's the random index generation with nub.
16:59:33 <Lutin`> Of course you may not care about asymtotic efficient
17:00:17 <ninja_code> damn it, ... haste does not support forkIO ... how slow is ghcjs? I may have to switch
17:00:22 <pjdelport> Lutin`: That alone is O(n²) average, with an unlimited worst case.
17:00:29 <Lutin`> Yeah?
17:00:39 <pjdelport> (as in it's not guaranteed to terminate)
17:01:16 <hiptobecubic> ninja_code, what exactly would forkIO do in javascript?
17:01:20 <Lutin`> Is that because of how System.Random works?
17:01:42 <ninja_code> hiptobecubic: it would work, since haste would implement a runtime simulating green threads
17:01:43 <ninja_code> duh
17:01:45 <ninja_code> :-)
17:01:54 <Lutin`> pjdelport: Oh nub
17:02:02 <Lutin`> Just use floating points
17:02:15 <ninja_code> hiptobecubic: what did you expect forkIO to do ?
17:02:33 <hiptobecubic> ninja_code, i had no idea what you expected forkIO to do, that's why I asked.
17:02:54 <hiptobecubic> I would imagine some kind of async callback pretzel
17:03:14 <Lutin`> pjdelport: I mean I guess random :: (Float, g) would be slower than random :: (Int, g)
17:03:45 <Lutin`> Not sure what the underlying implementation is
17:03:47 <pjdelport> Lutin`: Well, it also wouldn't be entirely unbiased anymore.
17:04:05 <l0cust> Eduard_Munteanu: Now that you're here, may I bother you with my issue?
17:04:16 <Eduard_Munteanu> l0cust: yeah, go ahead :)
17:04:40 <pjdelport> Lutin`: And it still *technically* isn't guaranteed to terminate (although the probability of not terminating is negligable, obviously).
17:04:45 <Eduard_Munteanu> Not staying longer than 30 mins though.
17:04:55 <l0cust> Eduard_Munteanu: okay, I'll hurry :)
17:05:08 <l0cust> This JSON file works perfectly - http://ix.io/d7e
17:05:17 <l0cust> This one still gives me errors - http://ix.io/d6L
17:05:19 <l0cust> different errors
17:05:30 <hiptobecubic> these are nice json files
17:05:30 <pjdelport> (unless you skip nubbing, at the cost of marginally reducing randomness)
17:05:32 <l0cust> This is the error *Main> testPhraseFile "res/phraselists/pornography.json"
17:05:32 <l0cust> "key \"phrase\" not present"
17:05:32 <l0cust> *** Exception: ExitFailure 1
17:05:39 <l0cust> The last one is NSFW
17:06:03 <l0cust> I used a ruby script to generate them, so I know they're valid
17:06:10 <l0cust> JSONLint confirmed that
17:06:11 <Lutin`> pjdelport: Yeah that's what I was thinking, removing nub
17:06:37 <Lutin`> But there's still a chance you could have duplicates
17:06:43 <l0cust> Eduard_Munteanu: My issue yesterday turned out to be that each object in "forest" was in a separate list, which made traversal annoying
17:06:55 <l0cust> Eduard_Munteanu: so I wrote a little ruby script to fix it
17:07:09 <Eduard_Munteanu> l0cust: but have you checked each entry has "phrase" present?
17:07:26 <l0cust> Eduard_Munteanu: Yes, a regex search in emacs revealed the claim to be bullshit
17:07:42 <hiptobecubic> l0cust, i'd love to know how this scores are derived
17:07:45 <hiptobecubic> these*
17:07:57 <l0cust> hiptobecubic: I got this data off of some other data
17:08:12 <l0cust> hiptobecubic: this data already existed, I just put it into JSON
17:08:16 <l0cust> hiptobecubic: so, I don't know
17:08:22 <l0cust> Here's the library - http://lpaste.net/106199
17:08:29 <kazagistar> what is it called again when you replace strings with noise strings of similar length to hide the data in bug reports? mangling? mungling?
17:08:31 <l0cust> Here's the test file - http://lpaste.net/106200
17:08:44 <l0cust> kazagistar: "munging" sounds right
17:09:22 <l0cust> hiptobecubic: Here's the original data - http://contentfilter.futuragts.com/phraselists/
17:09:35 <l0cust> hiptobecubic: I'm hoping the American vernacular hasn't changed much in the last 7 years
17:10:31 <l0cust> I am a bit ashamed that I know what all of those words in the JSON file mean
17:10:35 <Lutin`> l0cust: If you think it hasn't then you a basic bitch
17:10:46 * Lutin` cringes
17:10:47 <pjdelport> jonashw: Before I forget, you might be interested in http://www.haskell.org/haskellwiki/Random_shuffle and http://okmij.org/ftp/Haskell/perfect-shuffle.txt
17:11:02 <Eduard_Munteanu> l0cust: hm, I'd try validating it against a JSON schema.
17:11:15 <l0cust> Eduard_Munteanu: how do you mean?
17:12:06 <Eduard_Munteanu> l0cust: you can write JSON Schema and run a validator on your JSON input to check all fields are present.
17:12:23 <Eduard_Munteanu> l0cust: or you can try providing a default value in Aeson and see which element gets it
17:12:26 <l0cust> Eduard_Munteanu: Not entirely sure what "JSON Schema" is
17:12:34 <Eduard_Munteanu> The latter might be simpler
17:12:56 <Eduard_Munteanu> l0cust: https://en.wikipedia.org/wiki/JSON_Schema#JSON_Schema
17:13:37 <Eduard_Munteanu> Similar in purpose to XSD, DTDs, RNG schemas etc. for XML.
17:19:18 <l0cust> Eduard_Munteanu: Here's the schema - does it look correct? http://lpaste.net/106203
17:20:04 <Eduard_Munteanu> l0cust: missing ':' after "forest"
17:20:20 <Eduard_Munteanu> l0cust: and same for "properties"
17:21:30 <l0cust> Eduard_Munteanu: fixed it, it validates
17:21:39 <Eduard_Munteanu> Cool.
17:21:50 <Eduard_Munteanu> l0cust: can you pastebin the parser?
17:22:08 <l0cust> Eduard_Munteanu: which parser?
17:22:14 <Eduard_Munteanu> l0cust: your Aeson code
17:22:49 <l0cust> http://lpaste.net/106199 - the library
17:23:45 <Eduard_Munteanu> l0cust: what's testPhraseFile?
17:24:09 <l0cust> http://lpaste.net/106200 - the test
17:24:20 <l0cust> Eduard_Munteanu: You call it in ghci with the file path
17:24:50 <l0cust> Eduard_Munteanu: testPhraseFile tries to convert it into a PhraseAlmostTree
17:26:23 <gspr> Am I barking up the wrong tree if I in an attoparsec  Parser a  find myself wanting to  take n  from a given bytestring and run another  Parser a  on the result of that take?
17:26:49 <Eduard_Munteanu> gspr: that's not unreasonable
17:26:59 <johnw> nested parsing is not too bad of a thing to want
17:27:18 <l0cust> yay recursion
17:27:57 <gspr> Eduard_Munteanu: Oh, ok. It felt smelly :P
17:27:58 <davean1> gspr: it is probably a good time to stop and consider if you did it the right way in the first place, but no that is as said very reasonable.
17:28:15 <sm> gspr: you may have to work harder to show good error messages in that situation
17:28:17 <gspr> davean1: OK, thanks
17:28:29 <gspr> sm: Yes, that seems plausible
17:28:54 <Eduard_Munteanu> gspr: you may also do layered parsing by writing your own monad on top of attoparsec
17:29:09 <gspr> Eduard_Munteanu: Right. Makes sense.
17:29:34 <gspr> thanks, everybody
17:29:40 <Eduard_Munteanu> l0cust: hm, I don't see anything wrong. Dunno what to suggest, perhaps doing a binary search on the JSON file to find the culprit entry?
17:30:29 <Eduard_Munteanu> l0cust: i.e. cut it in half, run it, cut again etc.
17:30:33 <l0cust> Eduard_Munteanu: I think it's a bug in aeson. When I give it a different recursive file
17:31:17 <l0cust> http://lpaste.net/106204
17:31:21 <l0cust> It works perfectly
17:31:34 <l0cust> So I think it's just failing with the large file
17:31:45 <l0cust> I'll email the maintainer, ask if he has any ideas
17:31:51 <Eduard_Munteanu> It's not really large.
17:31:58 <l0cust> 400KB
17:32:03 <Eduard_Munteanu> Hm.
17:34:22 <Eduard_Munteanu> l0cust: it might help to check what version you're using
17:35:27 <l0cust> Eduard_Munteanu: using the latest version
17:43:57 <ninja_code> https://gist.github.com/anonymous/e1bd95b9358c5a03cada
17:43:58 <ninja_code> https://gist.github.com/anonymous/e1bd95b9358c5a03cada
17:44:00 <ninja_code> how do I resolve the above?
17:44:03 <ninja_code> i'm trying to instlal ghcjs
17:47:06 <geekosaur> what version of ghc do you have installed?
17:47:54 <geekosaur> nemind, that sounds like 7.6.3 and current haskell-platform
17:48:14 <geekosaur> ghcjs requires ghc 7.8, and the platform update is waiting on a ghc point update *again*
17:48:55 <ninja_code> okay
17:49:04 <ninja_code> how do I upgrade (on ubuntu linux) from ghc 7..3 to ghc 7.8 rc2 ?
17:49:05 <ninja_code> I need to upgrade to install ghcjs
17:49:28 * hackagebot yesod-auth-account 1.2.6 - An account authentication plugin for Yesod  http://hackage.haskell.org/package/yesod-auth-account-1.2.6 (JohnLenz)
17:53:21 <jonashw> pjdelport, thanks for the links
17:53:24 <dmwit> ninja_code: Grab a copy from the official download page: http://www.haskell.org/ghc/download
17:53:36 <dmwit> It's okay to install two different versions of GHC at once; they'll play nice together.
17:53:41 <ninja_code> of the source ?
17:53:48 <ninja_code> damn, ghcjs is messy
17:53:58 <dmwit> ninja_code: It's rare to need to install from source.
17:54:10 <dmwit> Just grab one of the binary packages unless you plan on changing something in GHC.
17:54:28 <ninja_code> eh, already started ./configure
17:54:32 <ninja_code> the binary package sseem to be 7.6
17:54:39 <dmwit> um
17:54:41 <ninja_code> whereas I really fucking need 7.8.2 to get ghcjs to install
17:54:52 <dmwit> There is a page for GHC 7.8.2 at the link I gave you.
17:54:54 <dmwit> It has binaries.
17:55:14 <ninja_code> http://www.haskell.org/ghc/download_ghc_7_8_2#distros ?
17:55:16 <ninja_code> but those links link to generic pages
17:55:18 <ninja_code> which link to ghc6
17:55:21 <ninja_code> which I presmue is 7.6. ...
17:55:50 <ninja_code> oh
17:55:51 <ninja_code> you meant http://www.haskell.org/ghc/download_ghc_7_8_2#x86_64linux ?
17:55:58 <dmwit> For example, yes.
18:10:29 <meretrix> I'm using -fprof-auto, but in the output of -hc, all I see is that 100% of the cost is for Util.CAF.
18:10:51 <meretrix> Why isn't it showing which function is responsible for the large cost?
18:11:19 <meretrix> (Util is a module)
18:12:21 <dmwit> meretrix: Perhaps you recompiled your program, but not the library that provides Util.
18:13:01 <dmwit> Or perhaps you need to put some more cost centers by hand.
18:13:14 <meretrix> dmwit: Oh you mean I need to pass -fproto-auto to the library as well?
18:13:18 <dmwit> But take my advice with a grain of salt, as I've profiled a grand total of three programs, I think.
18:13:21 <dmwit> meretrix: Yes, definitely.
18:14:00 <meretrix> Ah, so if I add wanted to profile some module in base, I would need to recompile ghc?
18:14:05 <meretrix> *-add
18:14:19 <dmwit> GHC ships with profiling versions of its built-in libraries, I think.
18:14:29 <dmwit> But it's very common advice to add profiling: True to ~/.cabal/config.
18:14:30 <ninja_code> damn
18:14:39 <ninja_code> compiling ghc is so fucking slow
18:14:48 <dmwit> So that all the things downstream from that get profiling versions.
18:14:56 <dmwit> ninja_code: That's why I recommend installing a binary...
18:14:58 <meretrix> Well everything is compiled with -prof.
18:16:05 <ninja_code> dmwit: why didn't you tell me the reason
18:16:20 <ninja_code> i.e. it's "don't go into the water" vs "don't go into the water because it's filled with alligators"
18:16:40 <dmwit> ninja_code: Because it's the same reason for every other binary vs. source decision you've ever made.
18:17:06 <dmwit> It's more like "don't drink that poison" vs "don't drink that poison because, like the other poisons you've seen, it will hurt and maybe kill you".
18:17:11 <ninja_code> ghc takes more time to compile than gentoo
18:17:42 <meretrix> Gentoo's overlay makes compiling haskell easy though.
18:17:52 <meretrix> Especially for upgrades.
18:18:01 <ninja_code> fuck it's still compiling stage1
18:18:03 <ninja_code> maybe I should just go binary
18:18:37 <meretrix> Don't you want your own uber-optimized version? :D
18:19:00 <dmwit> I've never understood that argument.
18:19:10 <dmwit> Do people think that distro maintainers don't compile with optimizations on?
18:19:53 <qrada> started taking denotational semantics seriously.. why didn't I do this earlier
18:19:53 <qrada> ;f
18:20:04 <ninja_code> started taking types seriously
18:20:09 <ninja_code> why didn't I do this 20 years ago
18:20:15 <qrada> ya, same thing basically
18:21:37 <ninja_code> yeah
18:21:46 <ninja_code> programming without types = easier to explore
18:21:56 <ninja_code> which is like building a skyscraper without floor plans
18:22:01 <ninja_code> sometimes planning haead of time is slightly better
18:22:11 <qrada> going to start reading the STM semantics doc
18:22:26 <qrada> "building a sky scraper out of bananas" -- simon peyton jones
18:22:26 <qrada> ;d
18:22:57 <qrada> ya..
18:23:18 <ninja_code> oay
18:23:19 <ninja_code> donwloaded binary
18:23:24 <ninja_code> tar -xjvf right now
18:23:32 <ninja_code> where do I put ghc-7.8.2? /usr/local ?
18:24:03 <qrada> which binary? that binary 7.8 tgz has a makefile in it
18:24:05 <dmwit> ninja_code: untar somewhere temporary, then ./configure and make install
18:24:09 <qrada> to put everything in the right location
18:24:10 <qrada> ya
18:24:12 <dmwit> ninja_code: It will put itself in an appropriate place.
18:24:22 <qrada> ./configure --prefix=/usr/local etc.. first which ghc, find out where it is now
18:24:32 <dmwit> ninja_code: Or, ./configure --help to pick your own favorite place.
18:24:55 <dmwit> It is not always a good idea to put the new GHC in the same place as the old one.
18:25:05 <qrada> ya
18:25:21 <dmwit> e.g. it may make sense to avoid package-manager-managed directories
18:25:35 <qrada> rebuild latest alex and cabal too btw
18:26:22 <qrada> cabal sandboxes saved my life
18:26:23 <qrada> ;f
18:30:32 <ninja_code> okay
18:30:33 <ninja_code> installed bianry
18:30:34 <ninja_code> so much easier
18:30:36 <ninja_code> so easy
18:30:38 <ninja_code> much happy
18:30:38 <ninja_code> yay
18:30:40 <qrada> nice
18:32:42 <qrada> ok, so much i need to unlearn tonight.. bbl
18:34:17 <ninja_code> basically
18:34:18 <ninja_code> types = good
18:34:19 <ninja_code> nothypes = bad
18:34:27 <ninja_code> compile time error = good
18:34:28 <ninja_code> runtime error = bad
18:34:43 <ninja_code> dogecoin = woof; bitcoin = falling
18:35:03 <pharaun> ha!
18:36:44 <dmwit> Eh... simplifications like that leave something to be desired.
18:36:56 <dmwit> Or, to say it another way: why are you using Haskell instead of Coq?
18:56:21 <ninja_code> fuck
18:56:24 <ninja_code> wht does /usr/bin/ld: cannot find -lHStext-1.1.1.3-ghc7.8.2 mean "
18:56:32 <ninja_code> "/usr/bin/ld: cannot find -lHStext-1.1.1.3-ghc7.8.2" ? <-- in the context of installing ghcjs
18:59:12 <heatsink> It means the library isn't in the search path
18:59:37 <heatsink> Which command produces that error?  If you're using cabal to install, --verbose shows which commands are run
19:08:09 <Skymaster> Hi. I am a Java programmer.
19:08:16 <parc_> howdy
19:08:54 <Skymaster> so why is everyone talking about functional programming. The whole point of moving away from C and into Java was to be object oriented. Why is everyone tryign to de-volve back into functional programmign?
19:09:09 <benzrf> Skymaster: nice troll bro
19:09:14 <Skymaster> seems like a big step backward
19:09:26 <benzrf> Skymaster: don't you know what we do with trolls around here
19:09:35 <Makoryu> Skymaster: Are you actually under the impression that functional programming had some kind of stranglehold on the industry before Java appeared?
19:09:50 <benzrf> Skymaster: we convince them that they should be learning haskell
19:10:24 <Iceland_jack> Speaking of which, Skymaster should check out Learn You a Haskell for an introduction to Haskell
19:10:24 <Iceland_jack> @where lyah
19:10:25 <lambdabot> http://www.learnyouahaskell.com/
19:10:39 <Skymaster> ok i'll read that link
19:10:49 <Welkin> Iceland_jack, I don't think Skymaster was being genuine
19:10:53 <Welkin> it sounds like a joke
19:11:01 <Iceland_jack> Welkin: I don't really care
19:11:03 <enthropy> @quote Cale troll
19:11:03 <lambdabot> Cale says: Here [#haskell], we feed trolls until they explode.
19:11:16 <Iceland_jack> If someone comes here they learn Haskell
19:11:27 <Welkin> that is a good approach
19:11:40 <marchelzo_> What kind of Java programmer uses an IRC client for emacs?
19:12:25 <Iceland_jack> Good catch :)
19:12:37 <benzrf> Cale++
19:12:54 <Welkin> @quote benzrf
19:12:54 <lambdabot> benzrf says: zippers are fun / they are zippy! / anyway bye
19:13:10 <Welkin> @quote Iceland_jack
19:13:10 <lambdabot> Iceland_jack says: It feels like Haskellers would invite Jehova's witnesses in for tea just to proselatize Haskell to them.
19:13:12 <benzrf> >tfw this is what i will be rememeberd for if i die tomorrow
19:13:15 <Iceland_jack> huh
19:13:27 <Welkin> @quote Welkin
19:13:28 <lambdabot> No quotes match. My mind is going. I can feel it.
19:13:53 <Iceland_jack> Great, my quote has a spelling mistake :)
19:14:37 * hackagebot mighttpd2 3.1.1 - High performance web server on WAI/warp  http://hackage.haskell.org/package/mighttpd2-3.1.1 (KazuYamamoto)
19:14:44 <Welkin> that reminds me of a story about chinese immigrants in the US
19:15:09 <ReinH> Iceland_jack: how do you feels about it?
19:15:13 <Welkin> they invited a jehovah's witness inside for dinner because they thought he would decline and did it only to save face
19:15:21 <Welkin> but he accepted
19:15:34 <Iceland_jack> ReinH: I'm partial :)
19:17:51 <sinelaw> hi, I need some tips on diagnosing memory usage
19:17:58 <carter> sinelaw: make it stricter?
19:18:02 <carter> or make it lazeri
19:18:09 <sinelaw> carter trying that already
19:18:15 <ReinH> Either way, change *something*
19:18:19 <carter> sinelaw: whats the code
19:18:22 <carter> and have you tried profiling
19:18:26 <Welkin> is there a utility like valgrind for haskell?
19:18:27 <sinelaw> is sprinkling it with $! supposed to help?
19:18:27 <carter> ghc has REALLY good profiling tools
19:18:33 <carter> sinelaw: PROFILE THE FUCKER
19:18:42 <carter> Welkin: we like to profile profiled builds
19:18:42 <ReinH> sinelaw: probably not as much as reasoning about where to put the !s
19:18:44 <sinelaw> i've look at ghc profiling output but it just says THINK
19:18:46 <sinelaw> oops
19:18:48 <sinelaw> THUNK
19:18:51 <carter> sinelaw: which kinda profiling
19:18:52 <carter> theres a few
19:18:55 <carter> but if its all thunks
19:18:55 <ReinH> especially evidence based reasoning
19:19:03 <carter> probs lazies
19:19:11 <carter> sinelaw: where is your code
19:19:33 <sinelaw> https://github.com/sinelaw/xml-to-json/blob/master/src-exec/TagSoupTest.hs
19:20:04 <carter> {-# LANGUAGE BangPatterns #-}
19:20:09 <carter> and rub ! on ever case
19:20:11 <carter> and patern match
19:20:22 <carter> and where clause :)
19:20:34 <carter> then remove the ! that make things too strict
19:20:46 <sinelaw> carter, example syntax?
19:21:17 <carter> foo (SineLaw !a)= baz
19:21:37 <sinelaw> ok
19:21:39 <enthropy> Welkin: you can use valgrind with ghc's binaries. It helps with segfaults sometimes
19:21:51 <enthropy> when doing FFI stuff
19:22:22 <carter> enthropy: you do do some of the more exotic ffi stuff i've seen
19:22:56 <benzrf>  
19:22:58 <rwbarton> sinelaw: how big is the file you are reading? and what kind of memory consumption are you seeing
19:23:27 <carter> he raisea  a good point
19:23:33 <carter> sinelaw: have you tried all the different types of profiling?
19:23:35 <carter> theres a few!
19:23:38 <carter> and they're kinda awsome
19:23:50 <sinelaw> 1.5M file, hits the default stack size (overflow)
19:24:01 <sinelaw> if I allow bigger stack, it can go to gigs of ram
19:24:02 <rwbarton> oh, stack overflow
19:24:11 <carter> sinelaw: you're on 7.6 aren't you?
19:24:18 <sinelaw> yes
19:24:22 <sinelaw> affirmative
19:24:28 <carter> 7.8 has a stack that can get as big as you let the heap
19:24:32 <carter> or 90% of that
19:24:41 <carter> by default
19:24:50 <carter> sinelaw: have you tried just bumping the stack size?
19:25:06 <sinelaw> carter, as I said, bumping the stack size lets it run to completion but with crazy memory usage
19:25:11 <sinelaw> ~2 gigs
19:25:14 <sinelaw> for a 1 MB file
19:25:22 <carter> are you folding anywhere?
19:25:25 <sinelaw> yes
19:25:33 <Welkin> foldl'
19:25:54 <rwbarton> at a start, on line 54 you surely want foldl' yeah
19:26:04 <carter> NOPE foldl
19:26:08 <carter> yup
19:26:13 <carter> what rwbarton  said
19:26:15 <sinelaw> trying
19:26:31 <sinelaw> ooh no more stack overflow
19:27:38 <sinelaw> ok that's much better but still memory goes up to 2.5 gig before terminating
19:28:52 <enthropy> convertTag might be better if it forced the elements of the tuple
19:29:31 <enthropy> probably cleanest would be to change it to use some  data StrictPair a b = StrictPair !a !b
19:29:43 <lfairy> anyone know what yhjulwwiefzojcbxybbruweejw is?
19:29:56 <lfairy> it's listed in the lambdabot docs
19:30:00 <lfairy> @yhjulwwiefzojcbxybbruweejw
19:30:00 <lambdabot> Exception: <<loop>>
19:30:42 <enthropy> @quote yhjulwwiefzojcbxybbruweejw
19:30:42 <lambdabot> quicksilver says: [on @yhjulwwiefzojcbxybbruweejw] it's the noise a haskell developer makes if you kick him in the de bruijn index.
19:32:36 <Geraldus> Hi friends!
19:32:55 <carter> enthropy: lfairy  wat
19:33:33 <lfairy> enthropy: so, an obscure in-joke?
19:33:43 <Geraldus> I want to build GHC 7.6.2 on my debian 7 (I have default version installed 7.4.1). When I try install dependencied via `sudo apt-get build-dep ghc` I have error message: `You must put some 'source' URIs in your sources.list`, what should I do? (I don’t remember that I added something specific to GHC in my sources.lists on my previous Debian installation)
19:34:23 <rwbarton> sinelaw: are you really using Seq in a way you couldn't just use a list?
19:34:27 <Geraldus> Trying to build GHC without dependencies check fails with no error on `make` process.
19:35:03 <rwbarton> Geraldus, this is a debian issue
19:35:12 <sinelaw> rwbarton, I started with a list. I assumed that some of the memory/performance issues where due to splitting lists into sub-lists (calling break)
19:35:22 <rwbarton> Geraldus: actually wait
19:35:28 <enthropy> lfairy: seems like it
19:35:28 <sinelaw> so I switched to Seq
19:35:36 <Geraldus> Hmmm. In this case I could use `sudo apt-get install haskell-platform git autoconf automake libtool make ncurses-dev g++ llvm`?
19:35:54 <rwbarton> that should work
19:36:33 <Geraldus> rwbarton: Thanks, I’ll try it now ) Looks like there were some libraries missing )
19:36:34 <rwbarton> I have no idea why it is looking for source packages with `sudo apt-get build-dep ghc` though
19:37:16 <rwbarton> sinelaw: hmm I see
19:39:39 * hackagebot Proper 0.4.0.0 - An implementation of propositional logic in Haskell  http://hackage.haskell.org/package/Proper-0.4.0.0 (dillonhuff)
19:40:11 <rwbarton> I'm not sure what the strictness properties of Seq are
19:40:56 <carter> of the Sequence datatype
19:41:04 <carter> probably no bvetter than Data.Map.Lazy
19:41:23 <rwbarton> well, I think it is not spine strict even
19:41:35 <l0cust> So
19:41:37 <l0cust> I have some json files
19:41:38 <sinelaw> is there a strict list?
19:41:40 <glguy> I'd guess spine strict due to the rebalancing it does
19:41:46 <l0cust> I want to use them in my package, as a data store
19:41:58 <l0cust> I know about the additional-files in cabal
19:42:35 <l0cust> Is there something special I have to do to use them within the library
19:43:04 <sinelaw> according to this Seq is spine-strcit: http://stackoverflow.com/a/8126954/562906
19:43:13 <rwbarton> from a quick examination it looks strict in some parts of the spine and not others
19:45:17 <enthropy> you can't make an infinite Seq though
19:46:21 <sinelaw> I can live with that
19:46:36 <rwbarton> it's possible even though the data types are not all strict, that the size stuff does ensure that the structure is actually strict
19:46:46 <rwbarton> when built with the exported functions
19:47:36 <dolio> Pretty sure Seq is explicitly not spine strict.
19:47:40 <dolio> And it's important that it's not.
19:48:27 <dolio> But who cares? Spine-strict isn't an end, it's a means.
19:51:52 <Welkin> > 3 :+ 4 + 1 +: 3
19:51:53 <lambdabot>  Precedence parsing error
19:51:53 <lambdabot>      cannot mix ‘Data.Complex.:+’ [infix 6] and ‘GHC.Num.+’ [infixl 6] in the...
19:51:53 <lambdabot>  Perhaps you meant one of these:
19:51:53 <lambdabot>    ‘++’ (imported from Data.List), ‘+’ (imported from Prelude),
19:51:53 <lambdabot>    ‘+=’ (imported from Control.Lens)
19:52:02 <Welkin> > (3 :+ 4) + (1 +: 3)
19:52:03 <lambdabot>  Not in scope: ‘+:’
19:52:04 <lambdabot>  Perhaps you meant one of these:
19:52:04 <lambdabot>    ‘++’ (imported from Data.List), ‘+’ (imported from Prelude),
19:52:04 <lambdabot>    ‘+=’ (imported from Control.Lens)
19:52:11 <Welkin> is there a way t do this without parens?
19:52:33 <Welkin> > import Data.Complex
19:52:34 <lambdabot>  <hint>:1:1: parse error on input ‘import’
19:52:49 <Welkin> > (3 :+ 4) + (1 :+ 3)
19:52:51 <lambdabot>  4.0 :+ 7.0
19:52:58 <Welkin> > 3 :+ 4 + 1 :+ 3
19:53:00 <lambdabot>  Precedence parsing error
19:53:00 <lambdabot>      cannot mix ‘Data.Complex.:+’ [infix 6] and ‘GHC.Num.+’ [infixl 6] in the...
19:53:00 <lambdabot>      cannot mix ‘GHC.Num.+’ [infixl 6] and ‘Data.Complex.:+’ [infix 6] in the...
19:53:19 <edwardk> Welkin: what version of ghc are you on?
19:53:26 <rwbarton> > let i = 0 :+ 1 in 3 + 4 * i + 1 + 3 * i
19:53:28 <lambdabot>  4.0 :+ 7.0
19:53:41 <Welkin> 7.4.1
19:53:50 <edwardk> rwbarton's trick is your best bet there
19:54:13 <Welkin> clever trick
19:54:25 <rwbarton> what changed in newer ghc?
19:54:28 <edwardk> on 7.8.2 you can do 'pattern (x :+: y) = (x :+ y);      infixl 7 :+:
19:54:30 <rwbarton> (or older?)
19:54:34 <rwbarton> oho
19:54:36 <edwardk> =)
19:55:36 <rwbarton> how about just let x +:+ y = x :+ y; infixl 7 +:+
19:58:26 <edwardk> or that
19:58:31 <edwardk> i prefer your i trick
20:01:26 <meretrix> Is this a bug?
20:01:28 <meretrix> > read "1" :: Data.Fixed.Pico
20:01:33 <lambdabot>  mueval: ExitFailure 1
20:03:02 <rwbarton> yes
20:03:21 <rwbarton> It was mentioned here a little while back
20:03:34 <Welkin> it works in ghci
20:03:45 <rwbarton> it's a regression in 7.8
20:03:49 <Welkin> ah
20:04:01 <rwbarton> I was going to file a ticket but I think I forgot to
20:04:02 <meretrix> Yay, finally found the root of my giant memory leak. :)
20:04:14 <meretrix> Where should it be filed?
20:04:55 <rwbarton> https://ghc.haskell.org/trac/ghc/newticket set the Component to libraries/base
20:05:02 <meretrix> Thanks
20:14:42 * hackagebot Proper 0.4.1.0 - An implementation of propositional logic in Haskell  http://hackage.haskell.org/package/Proper-0.4.1.0 (dillonhuff)
20:16:58 <rwbarton> meretrix: no, thank you :)
20:39:41 <chrisdotcode> so are OverloadedRecordFields the first step towards extensible records? :D
20:47:30 <enthropy> chrisdotcode: I think extensible means supports many more operations than what OverloadedRecordFields allows
20:48:37 <enthropy> and the design seems to be that you can't write instances of their Has class for your own data types
20:50:36 <chrisdotcode> enthropy: shame. I really am looking forward to elm-like extensible records
20:56:32 <l0cust> Hey
20:56:43 <l0cust> I can't remember the various functor functions
20:56:49 <l0cust> What's the function that does something like
20:57:10 <l0cust> (Functor f) => (a -> b) -> [a] -> f b
20:57:16 <l0cust> ah
20:57:20 <l0cust> (Functor f) => (a -> b) -> [a] -> f [b]
20:57:22 <l0cust> there we go
20:57:32 <copumpkin> huh
20:57:42 <l0cust> Okay
20:57:46 <copumpkin> you can't write that
20:57:53 <qrada> :t fmap
20:57:54 <lambdabot> Functor f => (a -> b) -> f a -> f b
20:58:07 <pjdelport> l0cust: Are you thinking of sequence?
20:58:07 <l0cust> not quite fmap
20:58:11 <l0cust> :t sequence
20:58:11 <pjdelport> :t sequenceA
20:58:12 <lambdabot> Monad m => [m a] -> m [a]
20:58:13 <lambdabot>     Not in scope: ‘sequenceA’
20:58:13 <lambdabot>     Perhaps you meant one of these:
20:58:13 <lambdabot>       ‘T.sequenceA’ (imported from Data.Traversable),
20:58:18 <pjdelport> :t T.sequenceA
20:58:19 <lambdabot> (Traversable t, Applicative f) => t (f a) -> f (t a)
20:58:20 <l0cust> that will do the trick
20:58:22 <copumpkin> :t T.traverse
20:58:23 <lambdabot> (Traversable t, Applicative f) => (a -> f b) -> t a -> f (t b)
20:58:26 <l0cust> not what I was thinking, but that'll do
20:58:27 <pjdelport> :t sequence
20:58:28 <lambdabot> Monad m => [m a] -> m [a]
21:18:56 <l4u-> what are the meanings of exclusive/inclusive on stockage?
21:29:19 <nomeata> Hi. Does anybody know why there is no happstack package that is compatible with the latest happstack-server?
21:29:47 * hackagebot egison-tutorial 3.3.5 - A tutorial program for the programming language Egison  http://hackage.haskell.org/package/egison-tutorial-3.3.5 (SatoshiEgi)
21:29:53 <stepcut> nomeata: that package should really be marked as deprecated, there is no happstack package anymore
21:30:06 <nomeata> stepcut: yes, such a marking would be useful
21:31:04 <Geraldus> Hey freinds, I’m having troubles building GHC 7.6.2 on Debian 7. Current version of GHC is 7.4.1, `make` process finishing with this weird message: `cd libraries && sh gen_contents_index --inplace`. Trying to run `make install` reports error. Here is paste (http://dpaste.com/3M3XJMY)
21:47:53 <jle`> hi all
21:48:03 <jle`> is there any dictionary about the semantics of lens operations
21:48:07 <jle`> like over
21:48:35 <jle`> i think i understand view in that view (iso to from) = to; view gives you the forward direction of the isomorphism?  is that a good way to think about it?
21:54:49 * hackagebot bytable 0.0.0.9 - data from/to ByteString  http://hackage.haskell.org/package/bytable-0.0.0.9 (YoshikuniJujo)
21:57:24 <jle`> oh (over l) gives you an fmap
21:59:20 <jle`> man how much of haskell confusion can be avoided by just leaving in redundant parentheses
22:01:48 <pjdelport> I'm fond of illustrative parentheses.
22:02:30 <Adeon> hlint does not approve of your extra parentheses
22:03:43 <pjdelport> "hlint can suck it" (apologies to a certain gentleman)
22:04:19 <jle`> this will be my new crusade
22:07:29 <mvc1> hey, when using DeriveGeneric, is there a nice way to have only some of the constructors uses the Generic Derivation?
22:07:41 <Hrumph> hi
22:09:03 <Hrumph> i made a big type class and you use it to define all sorts of stuff for a database entitity (once instance per database entity) and it defines a whole bunch of functions that do things like "check foreign keys" and add/edit form etc.
22:09:33 <Hrumph> the only problem is if i divide it up and put the code where i want i'll be using orphan instances. should i be concerned about this?
22:14:00 <Cale> A little bit maybe. The problem with orphan instances is that instances are parasitic when you import modules. You can't avoid importing them.
22:14:19 <Cale> and if two different modules define different instances of the same type class, then they can't be used together
22:14:35 <Hrumph> yeah but this isn't a library i'm making its an app
22:14:54 <Hrumph> so i think its an appropriate time to use them but i'm just checking in case i don't understand something
22:15:00 <Cale> So long as you won't run into that problem, there's no issue with orphan instances
22:15:25 <Cale> (but often it really does make sense to put them in the same module as the type...)
22:15:58 <Hrumph> true....but that's not a good idea in the environment where i'm working
22:16:01 <Hrumph> i'll try to explain
22:17:36 <Hrumph> all of the types are generated at once using a spec file for one thing
22:17:59 <Hrumph> so if i put all the instances in that file where the type is really defined....it'll be one huge file
22:18:16 <Hrumph> that's just one of two issues
22:18:44 <Hrumph> the other issue is that i want to depend on stuff that's lower down in the dependency graph when i write the instances
22:19:23 <Hrumph> the Model.hs file is depended on by Foundation.hs and I want to have Foundation imported when i write the instances
22:19:35 <Hrumph> i'm using the yesod scaffolding btw
22:19:51 * hackagebot bytable 0.0.0.10 - data from/to ByteString  http://hackage.haskell.org/package/bytable-0.0.0.10 (YoshikuniJujo)
22:20:48 <Hrumph> you grok?
22:21:23 <Hrumph> the otherthing that i can do and does work is to put all the code in the file where i define the class...that works but once again i get a huge file
22:21:37 <Hrumph> also there's the newtype solution but that would be a big pita
22:25:14 <Cale> Yeah, just put it where it's convenient, I suppose. Ending up with cyclic dependencies is definitely worse :)
22:30:37 <rola> :t Just
22:30:38 <lambdabot> a -> Maybe a
22:58:35 <echo-area> :t "haskell"
22:58:36 <lambdabot> [Char]
22:58:43 <echo-area> Nice bot
22:59:44 <jle`> echo-area: it's nice
23:00:01 <echo-area> Yes :)
23:04:26 <jle`> is there a flip over
23:04:29 <jle`> for lens
23:04:51 <jle`> instead of over lens f x
23:04:56 <jle`> flipover lens x f
23:05:13 <edwardk> (over lens ? f) x
23:05:15 <jle`> sort of like a forM vs mapM
23:05:27 <jle`> i want the f last
23:05:41 <jle`> so i can $ \x -> lambda it up
23:05:41 <edwardk> i flipped it there, pick a new name =)
23:06:00 <edwardk> > over _2 ? (1,2) $ (+1)
23:06:01 <lambdabot>  Not in scope: ‘?’
23:06:05 <edwardk> > over _2 ?? (1,2) $ (+1)
23:06:07 <lambdabot>  can't find file: L.hs
23:06:10 <edwardk> > over _2 ?? (1,2) $ (+1)
23:06:12 <lambdabot>  (1,3)
23:06:22 <jle`> have you found this useful at all?
23:06:25 <edwardk>  ? is in my hask project, not mainstream lens
23:06:38 <jle`> to use over with a $ \lambda -> stuff
23:06:42 <edwardk> we use ?? as a placeholder to avoid naming flipped versions of literally every combinator we have
23:06:47 <edwardk> but in general
23:06:53 <jle`> as many people use forM instead of mapM
23:07:01 <edwardk> > (1,2) & _2 %~ (+1)
23:07:02 <lambdabot>  (1,3)
23:07:07 <jle`> oh
23:07:13 <edwardk> > (1,2) & _2 %~ \x -> x + 1
23:07:15 <lambdabot>  (1,3)
23:07:22 <edwardk> notice how there are no parens in that even with the lambda, etc.
23:07:24 <jle`> is (%~) like some alias of over?
23:07:28 <edwardk> yeah
23:07:35 <edwardk> :t (%~)
23:07:36 <lambdabot> Profunctor p => Setting p s t a b -> p a b -> s -> t
23:07:38 <edwardk> :t over
23:07:40 <lambdabot> Profunctor p => Setting p s t a b -> p a b -> s -> t
23:07:42 <jle`> << mind blown >>
23:07:53 <jle`> although i have probably read this multiple times
23:08:01 <edwardk> > (1,2) & _2 +~ 1
23:08:02 <lambdabot>  (1,3)
23:08:15 <edwardk> x & f = f x
23:08:24 <jle`> i am already juggling how much lens to use in my pipes tutorial
23:08:25 <edwardk> so that is (1,2) & (_2 +~ 1)
23:08:34 <jle`> using an these operators might be crossing the line
23:08:36 <jle`> or maybe it's not
23:08:44 <edwardk> the operators are something you grow into
23:08:53 <edwardk> i use them a _lot_ now, but i didn't so much when getting started
23:08:56 <jle`> but introducing them while teaching other things?
23:09:04 <jle`> if i'm writing a tutorial aiming to teach pipes
23:09:21 <jle`> well i actually already needed to devote a chunk on using "view"
23:09:34 <jle`> but if i used `over` then i don't need to explain view
23:09:42 <edwardk> note view is flip (^.)
23:09:47 <edwardk> > (1,2)^._2
23:09:49 <lambdabot>  2
23:09:56 <edwardk> > (1,(2,3))^._2._1
23:09:58 <lambdabot>  2
23:10:03 <jle`> going onto %~ might be crossing onto "here be magic-looking stuff" territory to readers
23:10:06 <jle`> oh that is neat
23:10:19 <jle`> hm
23:10:22 <jle`> oh i had a random question
23:10:36 <jle`> view (iso to from) = to...but how would i get the `from` from an iso?
23:10:39 <edwardk> the connection between &   and %~    and ^. syntactically are a big part of the 'culture' of using lens
23:11:20 <jle`> hm
23:11:21 <edwardk> > 1^.iso (+1) (subtract 1) -- lets start here
23:11:22 <lambdabot>  2
23:11:29 <edwardk> > 1^.from (iso (+1) (subtract 1)) -- lets start here
23:11:30 <lambdabot>  0
23:11:41 <edwardk> how do you get the from?    with from
23:11:46 <edwardk> =)
23:11:50 <jle`> but
23:11:54 <jle`> that seems to yield a new iso
23:11:58 <jle`> does from just swap the iso?
23:12:00 <edwardk> hence ^. to read it
23:12:03 <edwardk> yes
23:12:08 <jle`> from (iso f g) = iso g f ?
23:12:10 <jle`> oh
23:12:14 <edwardk> we can play other games as well
23:12:20 <jle`> that's cute
23:12:23 <edwardk> > iso (+1) (subtract 1) # 1
23:12:24 <lambdabot>  0
23:12:42 <jle`> this is starting to sound familiar
23:12:44 <edwardk> -- that uses the fact that # is used to construct a prism and every iso is a valid prism
23:12:52 <edwardk> > review (iso (+1) (subtract 1)) 1
23:12:54 <lambdabot>  0
23:13:07 <edwardk> review   is view in the other direction,  review = (#)
23:13:11 <jle`> ah
23:13:15 <edwardk> > _Left._Left # 3
23:13:17 <lambdabot>  Left (Left 3)
23:13:28 <edwardk> note _Left is a prism not an iso, but it still works with review
23:13:43 <edwardk> review = view . re = view . from
23:14:02 <jle`> > let myprism = _Left._Left in view myprisim . review myprism $ 3
23:14:04 <edwardk> re is a weaker version of from that only yields a getter in the opposite direction, suitable for use with prisms
23:14:04 <lambdabot>  Not in scope: ‘myprisim’
23:14:04 <lambdabot>  Perhaps you meant ‘myprism’ (line 1)
23:14:14 <jle`> > let myprism = _Left._Left in view myprism . review myprism $ 3
23:14:16 <lambdabot>  No instance for (GHC.Show.Show a0)
23:14:16 <lambdabot>    arising from a use of ‘M333178182850143688531817.show_M3331781828501436885...
23:14:16 <lambdabot>  The type variable ‘a0’ is ambiguous
23:14:16 <lambdabot>  Note: there are several potential instances:
23:14:16 <lambdabot>    instance [safe] GHC.Show.Show
23:14:27 <edwardk> ?
23:14:32 <edwardk> what are yuou trying to do
23:14:41 <jle`> review turns it into a (Left (Left 3)) ?
23:14:42 <edwardk> review _Left._Left # 3
23:14:47 <edwardk> review (_Left._Left) # 3
23:14:50 <edwardk> review (_Left._Left) 3
23:14:50 <jle`> how how cna i turn that Left (Left 3)) back into 3?
23:14:53 <jle`> using the same lens?
23:14:53 <edwardk> > review (_Left._Left) 3
23:14:55 <lambdabot>  Left (Left 3)
23:15:04 <edwardk> you have to be careful here
23:15:10 <edwardk> Left 4 ^? _Left
23:15:17 <edwardk> > Right 4 ^? _Left
23:15:19 <lambdabot>  Nothing
23:15:22 <edwardk> > Left 4 ^? _Left
23:15:23 <lambdabot>  Just 4
23:15:34 <jle`> > (Left (Left 3)) ^? (_Left._Left)
23:15:35 <edwardk> notice how i used ^?  because pattern matching on a _prism_ can fail.
23:15:36 <lambdabot>  Just 3
23:15:50 <jle`> > (Left (Left 3)) ^, (_Left._Left)
23:15:53 <lambdabot>  <hint>:1:18: parse error on input ‘,’
23:15:54 <jle`> > (Left (Left 3)) ^. (_Left._Left)
23:15:56 <lambdabot>  No instance for (GHC.Show.Show a0)
23:15:56 <lambdabot>    arising from a use of ‘M471664421658166359431959.show_M4716644216581663594...
23:15:56 <lambdabot>  The type variable ‘a0’ is ambiguous
23:15:56 <lambdabot>  Note: there are several potential instances:
23:15:56 <lambdabot>    instance [safe] GHC.Show.Show
23:15:58 <jle`> > (Left (Left 3)) ^?! (_Left._Left)
23:16:00 <lambdabot>  3
23:16:16 <edwardk> > Left (Left "hello") ^. _Left._Right
23:16:18 <lambdabot>  ()
23:16:21 <jle`> is a prism no more than a failable lens
23:16:22 <edwardk> > Left (Left "hello") ^. _Left._Left
23:16:24 <lambdabot>  "hello"
23:16:28 <edwardk> no
23:16:46 <edwardk> a prism is a 'co-lens' -- lets look at what a lens lens you do
23:17:09 <edwardk> a lens gives you 'view' :: s -> a     and 'set'  :: s -> b -> t
23:17:27 <edwardk> if we tuple up set you get (s, b) -> t
23:18:06 <jle`> ok
23:18:14 <edwardk> now if you turn those arrows around by taking the dual   you get a -> s   and t -> Either s b
23:18:17 <jle`> so i flip the arrows
23:18:20 <edwardk> if you rename things you get
23:18:29 <edwardk> (b -> t) and (s -> Either t a)
23:18:37 <edwardk> you can 'construct' :: b -> t
23:18:48 <edwardk> or you can match and if you fail to match you can refine the type a bit
23:18:57 <edwardk> :t _Just
23:18:58 <lambdabot> (Choice p, Applicative f) => p a (f b) -> p (Maybe a) (f (Maybe b))
23:19:17 <edwardk> notice here when you fail to match with _Just you can know that the type argument isn't used at all
23:19:37 <edwardk> :t _Just Left
23:19:38 <lambdabot> Maybe a -> Either a (Maybe b)
23:20:22 <jle`> in set, s -> b -> t; s is the thing you are going to be setting something in, b is the type of the thing you "set", and t is the resulting type after the set ?
23:20:41 <edwardk> that either matches, giving you a Left a   or fails, giving you a Right (... maybe b that isn't Just .. hrmm, Nothing? ) =)
23:20:50 <edwardk> jle`: yeah
23:21:25 <jle`> is b -> t supposed to be the dual of view or set?
23:21:33 <edwardk> you can think of a lens as saying that exists c. such that all s_i are isomorphic to (c, a_i)
23:21:38 <edwardk> view
23:21:51 <edwardk> hence review
23:21:51 <jle`> oh because it's like a "reverse view"
23:21:57 <jle`> :o
23:22:12 <jle`> instead of taking a thing and returning an internal part
23:22:15 <edwardk> to match you can 'preview' which will give you the first match of a fold
23:22:19 <jle`> you are taking an internal part and returning a whole thing
23:22:30 <edwardk> > preview _Left (Left 1)
23:22:32 <lambdabot>  Just 1
23:22:37 <edwardk> > preview _Left (Right 1)
23:22:39 <lambdabot>  Nothing
23:22:46 <edwardk> > preview traverse [1..10]
23:22:48 <lambdabot>  Just 1
23:22:52 <edwardk> > preview traverse []
23:22:53 <lambdabot>  Nothing
23:23:10 <edwardk> > view (pre traverse) [1..10]
23:23:11 <lambdabot>  Just 1
23:23:15 <edwardk> > view (pre traverse) []
23:23:17 <lambdabot>  Nothing
23:23:25 <jle`> k... set is (s, b) -> t, and co-set is s -> Either t a
23:23:35 <edwardk> lens is an exercise in pun-driven development
23:23:57 <edwardk> yeah, the names when i switched to co-set there changed because that way i could line things up with what the lens formalism uses
23:23:58 <solidus-river> gahhh, how do i formulate this in a not bad way
23:23:59 <jle`> i don't see the co-ness
23:24:15 <edwardk> (s, b) -> t   vs.       t -> Either s b
23:24:25 <edwardk> (,) is *    Either is +
23:24:29 <jle`> s*b  -> t    turns into s -> t + a ?
23:24:44 <edwardk> it doesn't help that i shuffled all the names around on you
23:24:45 <solidus-river> http://lpaste.net/106212
23:24:50 <jle`> this must be some semantics of co-ness that i am unaware of
23:24:57 <edwardk> s*b -> t  becomes    s+b <- t
23:24:57 <solidus-river> i cant think of a not insane way of doing a simple case statement in a do block
23:25:16 <solidus-river> let doesn't work, gaurds seem wierd, and you cant patturnt match against a comparison with case
23:25:16 <edwardk> when you flip the definition of     fst it becomes Left
23:25:18 <edwardk> :t fst
23:25:19 <lambdabot> (a, b) -> a
23:25:20 <edwardk> :t Left
23:25:21 <lambdabot> a -> Either a b
23:25:40 <edwardk> :t (&&&)
23:25:41 <lambdabot> Arrow a => a b c -> a b c' -> a b (c, c')
23:25:45 <edwardk> :t (|||)
23:25:46 <lambdabot> ArrowChoice a => a b d -> a c d -> a (Either b c) d
23:26:08 <jle`> solidus-river: you can pull out ratio into a where clause
23:26:22 <ski> solidus-river : perhaps you meant `ortho 0 100 ratio ratio 1 (-1)' ?
23:26:32 <ski> jle` : not the same `ratio'
23:26:39 <jle`> oh slipped my eyes
23:26:43 <edwardk> jle`: i changed the names, the names don't switch as part of duality. that was a separate step
23:27:05 <solidus-river> ski ?
23:27:12 <jle`> edwardk: i don't see how fst can be said to be the co of Left
23:27:19 <jle`> all i know about co is you swap the arrows
23:27:36 <ski> solidus-river : `ortho (0 100 (ratio) (ratio) 1 (-1))' looks like a mistake
23:27:46 <edwardk> what defines a product? when you have 3 major operations, fst, snd and (&&&)
23:27:51 <solidus-river> hmm, why is (ratio) different than ratio though
23:28:05 <ski> it's not
23:28:06 <edwardk> im skipping associators and the existence of () as a unit
23:28:20 <jle`> mhm
23:28:27 <edwardk> :t fst
23:28:29 <lambdabot> (a, b) -> a
23:28:31 <edwardk> :t snd
23:28:32 <lambdabot> (a, b) -> b
23:28:35 <edwardk> :t (&&&)
23:28:36 <lambdabot> Arrow a => a b c -> a b c' -> a b (c, c')
23:28:56 <jle`> oh yeah i had a long talk on #haskell-blah about this and ithe definition of product in category theory
23:29:12 <edwardk> now lets look at Either
23:29:12 <jle`> mk
23:29:13 <edwardk> :t Left
23:29:14 <lambdabot> a -> Either a b
23:29:16 <edwardk> :t Right
23:29:17 <lambdabot> b -> Either a b
23:29:20 <edwardk> :t (|||)
23:29:21 <lambdabot> ArrowChoice a => a b d -> a c d -> a (Either b c) d
23:29:28 <haasn> Given fst/snd, is there anything that (&&&) can do but (,) can't?
23:29:45 <ski> jle` : the definition of categorical product and categorical coproduct are dual to each other -- changing the direction of the arrows (iow moving to the opposite category) will turn one concept into the other, so `+' and `*' are interchanged
23:29:46 <wjad> :t (&&&)
23:29:47 <lambdabot> Arrow a => a b c -> a b c' -> a b (c, c')
23:29:48 <edwardk> haasn: you need more structure to get there with just (,)
23:30:04 <jle`> :t (|||) `asAppliedTo` (undefined :: a -> b)
23:30:06 <lambdabot> (a -> b) -> (c -> b) -> Either a c -> b
23:30:14 <edwardk> (,) works because we have currying, an internal hom, etc.
23:30:21 <jle`> :t (&&&) `asAppliedTo` (undefined :: a -> b)
23:30:22 <lambdabot> (a -> b) -> (a -> c') -> a -> (b, c')
23:30:25 <ski> solidus-river : "you cant patturnt match against a comparison with case" ?
23:30:35 <edwardk> for other categories you need (&&&) to define it properly
23:30:39 <haasn> edwardk: makes sense
23:31:03 <jle`> hm
23:31:09 <edwardk> also (&&&) has a _much_ more clear connection to (|||)
23:31:18 <jle`> does this mean i have to look into the definition of sum in category theory
23:31:26 <haasn> :t (|||)
23:31:27 <lambdabot> ArrowChoice a => a b d -> a c d -> a (Either b c) d
23:31:33 <edwardk> the definition of a sum is the same as the definition of a product if you flip all the arrows
23:31:40 <jle`> let me refresh my memory on product
23:31:46 <jle`> a product is...that...
23:31:50 <jle`> if you give me an (a -> b)
23:31:53 <jle`> and a (a -> c)
23:32:02 <jle`> i can give you an a -> (b, c)
23:32:16 <jle`> where (b, c) is the product
23:32:26 <jle`> ...did i remember it correctly?
23:32:45 <jle`> no
23:32:48 <jle`> i did not
23:32:48 <Welkin> :t asAppliedTo
23:32:50 <lambdabot> (a -> b) -> a -> a -> b
23:32:53 <jle`> waiiit i'ts coming back to me
23:33:04 <edwardk> with some conditions about how that relates to fst and snd. notably that if you read off half with fst you get back to the original function  f   and with snd the original function g
23:33:18 <Welkin> :i asAppliedTo
23:33:25 <solidus-river> oy, opengl is a pain to work with in haskell because of type coersions all over the place
23:33:27 <edwardk> and such that any other function factors uniquely through that, etc.
23:33:38 <solidus-river> GLdoulbe GLsizei i fell like i'm just putting fromIntegral everwhere
23:33:40 <Welkin> @src asAppliedTo
23:33:40 <lambdabot> Source not found. You type like i drive.
23:34:12 <Welkin> @info asAppliedTo
23:34:13 <lambdabot> asAppliedTo
23:34:17 <Welkin> what is it?
23:34:34 <haasn> I wonder if having a postfix operator for fromIntegral could be useful
23:34:46 <edwardk> haasn: heh
23:34:50 <haasn> something like (num@~) where (@~) is some symbol to represent coercion
23:35:02 <haasn> (I couldn't think of anything prettier on the spot, unfortunately)
23:35:13 <jle`> okay, so the definition of sum is...
23:35:17 <haasn> :t let (@) = fromIntegral in (@)
23:35:18 <lambdabot> parse error on input ‘@’
23:35:29 <jle`> instead of fst, snd, and (&&&), you have Left, Right, and (|||) ?
23:36:03 <edwardk> yep and the arrows run the opposite direction
23:36:17 <edwardk> :t fst
23:36:17 <jle`> i think i will sleep on this to get the intuition
23:36:19 <lambdabot> (a, b) -> a
23:36:20 <edwardk> :t Left
23:36:21 <lambdabot> a -> Either a b
23:36:55 <haasn> With all this duality going on you'd think putting together (a,b) and Either a b would cause them to annihilate
23:37:11 <edwardk> they have a lot of structure, there is a distributive law for them, etc.
23:37:43 <edwardk> (a, Either b c) <-> Either (a, b) (a, c)
23:38:07 <edwardk> which should look like a * (b + c) = (a * b) + (a * c)
23:38:09 <haasn> Does the distribution work both ways? (a, Either b c) is clearly Either (a,b) (a,c) but I'm not quite sure if Either a (b,c) is (Either a b, Either a c)
23:38:18 <haasn> Since the latter permits two distinct ‘a’s, which seems to be non-isomorphic
23:38:24 <haasn> Or a/b a/c
23:38:28 <haasn> Nevermind
23:38:35 <edwardk> you can't distribute the opposite way in normal math for integers
23:38:50 <edwardk> there is a direction to how these interact
23:39:00 <haasn> Yeah, but you can for ∧ and ∨ which is sort of unfortunate when using (,) and Either to represent them
23:39:54 <edwardk> it turns out if you keep adding structure your categories get to be quite boring.
23:39:57 <ski> jle` : for every two objects ⌜A₀⌝ and ⌜A₁⌝, there is an object ⌜A₀ × A₁⌝ together with morphisms ⌜π₀ : A₀ × A₁ ↣ A₀⌝ and ⌜π₁ : A₀ × A₁ ↣ A₁⌝ such that for any object ⌜T⌝ together with morphisms ⌜m₀ : T ↣ A₀⌝ and ⌜m₁ : T ↣ A₁⌝ there is a *unique* morphism ⌜⟨m₀,m₁⟩ : T ↣ A₀ × A₁⌝ such that ⌜π₀ ∘ ⟨m₀,m₁⟩ = m₀⌝ and ⌜π₁ ∘ ⟨m₀,m₁
23:40:06 <haasn> ski: Whoa, is your encoding broken or mine?
23:40:08 <jle`> okay. p' is a product of a and b if....  there exists f' :: p' -> a and g' :: p' -> b (fst and snd) such that for *any* type p that has an f :: p -> a and a g :: p -> b...there exists an h :: (p -> a) -> (p -> b) -> (p -> p'), *such that* f' . h f g == f, and g' . h f g === g
23:40:17 <jle`> i think that's it
23:40:20 <jle`> *phew*
23:40:22 <edwardk> haasn: yours
23:40:30 <jle`> my encoding can't read it :'(
23:40:49 <jle`> (is my definition o k)
23:40:53 <jle`> oh and h is unique
23:40:56 <edwardk> jle`: a shame, because ski formatted that very nicely =)
23:41:03 <jle`> :'(
23:41:04 <haasn> Only one way to find out
23:41:08 <jle`> maybe i can read it on the logs online
23:41:15 <haasn> http://tunes.org/~nef/logs/haskell/14.06.23 seems to look correct with encoding UTF-8
23:41:41 <haasn> What do you see when I send ☃?
23:41:51 <jle`> it looks like...a flower
23:42:00 <jle`> oh
23:42:03 <jle`> it's a very tiny snowman
23:42:10 <haasn> Seems to be correct in the public logs, I wonder why I didn't see ski's correctly
23:42:44 <ski> jle` : for every two objects `A0' and `A1', there is an object `A0 * A1' together with morphisms `pi0 : A0 * A1 >-> A0' and `pi1 : A0 * A1 >-> A1' such that for any object `T' together with morphisms `m0 : T >-> A0' and `m1 : T >-> A1' there is a *unique* morphism `<m0,m1> : T >-> A0 * A1' such that `pi0 . <m0,m1> = m0' and `pi1 . <m0,m1> = m1'
23:43:12 <jle`> that sounds like what i wrote
23:43:15 <ski> jle` : if you prefer, you can use atomic names for the things claimed to exist :
23:43:46 <ski> jle` : for every two objects `A0' and `A1', there is an object `P' together with morphisms `pi0 : P >-> A0' and `pi1 : P >-> A1' such that for any object `T' together with morphisms `m0 : T >-> A0' and `m1 : T >-> A1' there is a *unique* morphism `p : T >-> P' such that `pi0 . p = m0' and `pi1 . p = m1'
23:44:10 <jle`> woo hoo
23:44:11 <ski> jle` : then you can think of `P' (with `pi0' and `pi1') as the "best" of the possible `T' objects (with `m0' and `m1')
23:45:38 <jle`> okay, so now to reverse the arrows
23:45:45 <jle`> i feel like there should be some sound effect here
23:45:53 <edwardk> dubstep
23:46:41 <reem> What does everyone think of Rust?
23:47:02 <systemfault> cycle “Wub” :/
23:47:33 <Taneb> reem, lifetimes and borrowing confuse me
23:47:46 <hamid> no hkt
23:47:55 <Taneb> reem, but I like Rust
23:48:13 <jle`> so s' is a sum of a and b if... there exists f' :: a -> s' and g' :: b -> s' (Left and Right)...such that... for *any* type s that has an f :: a -> s and a g :: b -> s ... there exists a unique h :: (a -> s) -> (b -> s) -> (s' -> s) such that .....
23:48:17 <jle`> okay now to nail the composition
23:48:30 <jle`> h f g . f' ==== f
23:48:34 <jle`> and
23:48:39 <jle`> h f g . g' ==== g
23:48:41 <jle`> woo hoo!
23:48:49 <ski> for every two objects ⌜A₀⌝ and ⌜A₁⌝, there is an object ⌜A₀ + A₁⌝ together with morphisms ⌜ι₀ : A₀ ↣ A₀ + A₁⌝ and ⌜ι₁ : A₁ ↣ A₀ + A₁⌝ such that for any object ⌜Q⌝ together with morphisms ⌜m₀ : A₀ ↣ Q⌝ and ⌜m₁ : A₁ ↣ Q⌝ there is a *unique* morphism ⌜[m₀,m₁] : A₀ + A₁ ↣ Q⌝ such that ⌜[m₀,m₁] ∘ ι₀ = m₀⌝ and ⌜[m₀,m₁] ∘ ι₁ = m₁⌝
23:49:27 <jle`> i see the dualness
23:49:30 <jle`> i have achieved
23:49:33 <edwardk> =)
23:49:35 <jle`> enlightenment
23:49:37 <edwardk> jle`++
23:50:03 <jle`> ty edwardk
23:50:14 <jle`> okay so back to lens >_>
23:50:35 <jle`> maybe i should retire for the night haha
23:50:45 <edwardk> (s, b) -> t    becomes        t -> Either s b
23:50:47 <ski> for every two objects `A0' and `A1', there is an object `A0 + A1' together with morphisms `iota0 : A0 >-> A0 + A1' and `iota1 : A1 >-> A0 + A1' such that for any object `Q' together with morphisms `m0 : A0 >-> Q' and `m1 : A1 >-> Q' there is a *unique* morphism `[m0,m1] : A0 + A1 >-> Q' such that `[m0,m1] . iota0 = m0' and `[m0,m1] . iota1 = m1'
23:50:55 <edwardk> and (s -> a) becomes (a -> s)
23:51:29 <reem> Taneb: I'm curious, does owernship or lifetimes give you more trouble?
23:51:29 <ski> for every two objects `A0' and `A1', there is an object `S' together with morphisms `iota0 : A0 >-> S' and `iota1 : A1 >-> S' such that for any object `Q' together with morphisms `m0 : A0 >-> Q' and `m1 : A1 >-> Q' there is a *unique* morphism `s : S >-> Q' such that `s . iota0 = m0' and `s . iota1 = m1'
23:52:07 <Taneb> reem, mostly it is unfamiliarity. They give me roughly equal trouble
23:52:20 <Axman6> this conversation looks like it's getting big enough for #haskell-blah or #haskell-in-depth
23:52:44 <edwardk> Axman6: likely, but then jle` is heading to bed i think ;)
23:52:52 <ski> jle` : drawing the commutative diagrams will probably with help understanding the "best" ("earliest" resp. "last", for coprooduct and product) aspect better
23:52:54 <Axman6> righto =)
23:53:42 <jle`> ski: thanks, i think i see it :)
23:54:21 <jle`> edwardk: still struggling to put t -> Either s b into words the way i was able to put b -> t
23:54:41 <edwardk> lets try defining a lens differently
23:55:01 <edwardk> every lens splits a type s  up into two parts    'a' the part you want  and 'c' all the crap you don't
23:55:12 <edwardk> exists c.      such that  s <-> (a, c)
23:55:26 <edwardk> so far so good?
23:55:48 <jle`> i understand the statement but i can't fit that into my previous definition of lens
23:55:58 <ski> jle` : for `S' and `Q', if we have a `Q' with `m0 : A0 >-> Q' and `m1 : A1 >-> Q', then (in some very weak sense), `A0' and `A1' are "included in" `Q' (but note that `m0' and `m1' needn't be anywhere near injective (assuming it's even some kind of function)) ..
23:56:11 <jle`> _1 gets the first part, but it doesn't give you "everhthing else", does it?
23:56:18 <edwardk> jle`: you can show that the encodings of lens are equivalent to finding that
23:57:11 <jle`> if _1 is lens fst (\(x,y) z -> (z,y)), i'm not sure what the 'crap you don't' represents
23:57:28 <ski> jle` : .. now being able to "factor" and such `(Q,m0,m1)' triple through `(S,iota0,iota1)' ensures (in some abstract sense) that `S' (iow `A0 + A1') actually includes all the information from `A0' and `A1'
23:57:28 <edwardk>    (get :: s -> a) &&& (set ::  s -> b -> t)   becomes s -> (a, b -> t)
23:57:38 <ski> s/and such/any such/
23:57:50 <jle`> does c ~ b -> t, then?
23:57:59 <edwardk> the b -> t is a way to write down 'c' in such a way that it can just be used directly
23:58:06 <jle`> ah
23:58:20 <edwardk> but lets just work with the notion of a constant complement
23:58:23 <jle`> get is basically split and recombine
23:58:25 <jle`> ok
23:58:27 <ski> jle` : since everything we could do with *any* triple `(Q,m0,m1)', we can do *via* `(A0 + A1,iota0,iota1)'
23:59:09 <ski> jle` : something similar holds for the product case, except everything is "turned around"
23:59:13 <edwardk> so we'll say this,     we have a bunch of s's and a bunch of a's    s_i         and s_i     indexed the same way, such that  there exists a c. such that  s_i   is isomorphic to (c, a_i)
23:59:25 * ski shuts up now
23:59:37 <jle`> ski: i appreciate it, i do :)
23:59:39 <jle`> er
23:59:41 <jle`> your explanation
23:59:43 <jle`> not your shutting up
23:59:45 <jle`> :)
