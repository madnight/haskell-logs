00:00:26 <gamegoblin> @unpl liftM
00:00:26 <lambdabot> liftM
00:03:47 * hackagebot range-set-list 0.0.7 - Memory efficient sets with continuous ranges of elements.  http://hackage.haskell.org/package/range-set-list-0.0.7 (phadej)
00:05:44 <frerich> On my way to work, probably caused by the lack of a proper computer science education, a question came to my head - is it plausible to think of '[a]' as a sum type, the sum of all values of 'a' plus '[]'?
00:07:04 <MP2E> frerich a sum denotes some sort of data structure with "choice" AFAIK. Like Either or Maybe
00:07:10 <MP2E> Wouldn't a list instead be a product type?
00:07:32 <MP2E> aka [] AND a. vs sum type being [] OR a
00:08:59 * hackagebot influxdb 0.4.0 - Haskell client library for InfluxDB  http://hackage.haskell.org/package/influxdb-0.4.0 (MitsutoshiAoe)
00:08:59 * hackagebot range-set-list 0.0.7 - Memory efficient sets with continuous ranges of elements.  http://hackage.haskell.org/package/range-set-list-0.0.7 (phadej)
00:15:38 <ReinH> frerich: list is a sum type: data List = Nil | Cons a (List a)
00:15:47 <ReinH> er data List a
00:16:24 <frerich> ReinH: Excellent, that matches my understanding.
00:24:47 <killy9999> when I define "bar x = do return x" it compiles, but changing this to "bar = \x -> do return x" causes a type inference error
00:24:59 <killy9999> No instance for (GHC.Base.Monad m0) arising from a use of Ã¢Â€Â˜returnÃ¢Â€Â™
00:25:16 <killy9999> Why ic GHC able to infer the type in the first case but the second one is problematic?
00:26:11 <supki> killy9999: monomorphism restriction
00:26:55 <killy9999> supki: duh, again :-/
00:27:13 <killy9999> but I admit I haven't yet seen MR in this form
00:27:37 <MP2E> ReinH: is list both a sum and product type? *confused*
00:27:38 <killy9999> I mean the error messages always complained about monomorphism explicitly
00:27:55 <MP2E> maybe I just don't know what a product type is :P
00:27:57 <killy9999> I guess typeclass restriction plays a role here
00:28:20 <ReinH> MP2E: In fact it is. It's a sum of Nil and (the product of a and List a), which makes it recursive.
00:28:53 <MP2E> Huh, neat :>
00:28:56 * hackagebot clash-prelude 0.5.1 - CAES Language for Synchronous Hardware - Prelude library  http://hackage.haskell.org/package/clash-prelude-0.5.1 (ChristiaanBaaij)
00:28:58 * hackagebot clash-lib 0.3.2 - CAES Language for Synchronous Hardware - As a Library  http://hackage.haskell.org/package/clash-lib-0.3.2 (ChristiaanBaaij)
00:29:00 * hackagebot clash-ghc 0.3.2 - CAES Language for Synchronous Hardware  http://hackage.haskell.org/package/clash-ghc-0.3.2 (ChristiaanBaaij)
00:30:05 <ReinH> There are a couple interesting ways to look at this
00:30:09 <ReinH> http://en.wikipedia.org/wiki/Initial_algebra
00:30:12 <ReinH> http://www.cis.upenn.edu/~byorgey/papers/species-pearl.pdf
00:33:11 <ReinH> so you get L = 1 + A * L, which expands to L = 1 + A + A^2 + A^3... or L = A^0 + A^1 + A^0 + ..., which corresponds to the intuitive notion that a list is equivalent to zero A's, one A, an ordered pair of A's, an ordered triple of A's, ...
00:33:50 <ReinH> er L = A^0 + A^1 + A^2 + ...
00:34:30 <MP2E> Ahh, now I may be drawing too far of a conclusion, but are all free objects then sum and product types?
00:34:46 <MP2E> since free objects are all isomorphic?
00:35:35 <ReinH> so this recursive definition is the same as data List a = Zero | One a | Two a a | Three a a a | Four a a a a | ... (if you could actually write a data type with an infinite number of summands)
00:36:37 <ReinH> what do you mean by "free objects are all isomorphic"?
00:39:22 <MP2E> I think I meant Free Monoid there. I'm reading into free objects and they aren't what I thought they were :P
00:39:32 <MP2E> But I could even be wrong about that heh
00:40:13 <ReinH> a free monoid is a free object
00:40:39 <ReinH> but I'm still not quite sure what you meant
00:41:16 <MP2E> I drew some parallelisms between the structure of a Free Monad and Free Monoid and basically made that assumption, I think. Free Monads being 'lists on a type level' and Free Monoids being just 'lists'
00:41:23 <MP2E> heh
00:42:22 <MP2E> (or thing similar to list but yeah, I saw it as essentially isomorphic in structure)
00:44:12 <MP2E> and now I think I see how I'm wrong.. Monads are Monoids at the Type level basically right? So that means they pretty much are monoids.. thus yeah
00:44:19 <ReinH> Well, a monad is a monoid (in the category of endofunctors). A free monad is a free monoid.
00:44:25 <MP2E> Ah
00:44:47 <MP2E> Now it makes much more sense
00:45:14 <Cale> Er, really? :)
00:45:25 <dottedmag> </sarcasm>, I suppose
00:45:32 <MP2E> No sarcasm intended
00:45:37 <MP2E> I understand what endofunctor means
00:45:38 <MP2E> heh
00:45:57 <centrapheta> Anyone got any Category Theory programming problems/challenges?
00:46:02 <fragamus> where is the really good tutorial on Cont
00:46:03 <Cale> I feel like anyone for whom that answer makes sense wouldn't need the question :)
00:46:27 <Cale> But maybe it helps in some vague way
00:46:36 <centrapheta> Cale, Was that to me?
00:46:52 <Cale> no, it was to MP2E and ReinH
00:47:18 <centrapheta> Not sure, if my message went through: <centrapheta> Anyone got any Category Theory programming problems/challenges?
00:47:26 <Cale> yes, it went through
00:47:38 <Cale> I'm not sure what a category theory programming problem is
00:47:44 <MP2E> Cale : I dunno, I just draw backwards conclusions sometimes I suppose. >_>
00:48:07 <dottedmag> Cale: well, there are university couress on cathegory theory, and they probably have some homework.
00:48:23 <dottedmag> At least I remember doing something like this back in uni.
00:48:31 <Cale> dottedmag: Yes, but usually not programming homework...
00:48:44 <centrapheta> Cale, A programming problem that relates to Category Theory.
00:48:48 <Cale> I suppose you could try to implement abstractions from category theory in Haskell
00:48:48 <ReinH> centrapheta: write a program that solves rubik's cubes :)
00:48:58 <Cale> That's not a category theory problem
00:49:08 <dottedmag> ReinH: won't it be just a group theory problem?
00:49:19 <ReinH> Cale: Sure it is, it's a problem in the category of groups :p
00:49:39 <Sibi__> I have written a very simple parser using Parsec. And it works good. But the problem is when I try it for a 70 mb file, the system's memory get's filled. So my question is Parsec suitable for parsing big files efficiently ? (or should I go with attoparsec-conduit/pipes for that purpose)
00:49:40 <Cale> Well, if you're going to be like that, just about anything is a category theory problem :P
00:49:47 <ReinH> Cale: indeed :D
00:49:52 <centrapheta> In pure mathematics.
00:49:57 <Cale> Implement a JSON parser
00:50:00 <Cale> lol
00:50:18 <alpounet> Sibi__: even just attoparsec is enough :-) just use one of the .Lazy modules, it'll really consume the input as progressively as it can
00:50:23 <Cale> This is technically an arrow in the category of sets
00:50:26 <Cale> ;)
00:51:10 <alpounet> Sibi__: but if you're already using conduits or pipes all around that bit of the program, yeah use the appropriate package. but attoparsec can process large files without a problem
00:51:24 <ReinH> centrapheta: write a data type for right Kan extensions and use it to construct monads from functors.
00:51:49 <alpounet> maybe one day, these will be interview questions
00:52:04 <dottedmag> What would be the good introduction to category theory for a software engineer? I remember it didn't make much sense back in university despite being labeled as "foundation for types in programming languages".
00:52:10 <Sibi__> @alpounet  Thanks, but If I just use the lazy module in attoparsec, won't it progressively load all the bytes into memory ?
00:52:10 <lambdabot> Unknown command, try @list
00:52:39 <mayski> interested as well regarding intro to category theory
00:52:47 <ReinH> dottedmag: there's an "Introduction to Category Theory for Software Engineering" book but I can't say I'm too fond of it.
00:53:09 <dottedmag> ReinH: Yes, I tried reading it and stopped quickly.
00:53:11 <alpounet> Sibi__: attoparsec holds onto the input to support its backtracking mechanism
00:53:43 <alpounet> but depending on how you consume it, you can get a decent streaming behavior
00:53:59 * hackagebot vty 5.0.0 - A simple terminal UI library  http://hackage.haskell.org/package/vty-5.0.0 (CoreyOConnor)
00:54:01 * hackagebot vty-examples 5.0.0 - Examples programs using the vty library.  http://hackage.haskell.org/package/vty-examples-5.0.0 (CoreyOConnor)
00:54:25 <centrapheta> ReinH, Seems interesting, have you done a similar problem to that?
00:54:42 <ReinH> centrapheta: no, but edwardk has.
00:55:05 <centrapheta> Also where is mm_freak these days?
00:55:06 <killy9999> one more question about type inference
00:55:08 <killy9999> http://lpaste.net/105114
00:55:13 <alpounet> dottedmag: I think the CT book by Awodey is one of the nicests intros.
00:55:16 <killy9999> why is the fist type signature wrong?
00:55:36 <ReinH> alpounet: Awodey is great, but eventually you'll come back to Mac Lane ;)
00:55:50 <dottedmag> alpounet: This one? http://ukcatalogue.oup.com/product/9780199237180.do
00:56:20 <ReinH> dottedmag: yep
00:56:32 <dottedmag> alpounet: ReinH: thank you
00:57:09 <alpounet> ReinH: I actually started with MacLane, but I studied math and got to analyze a few topics under the category theoretic lens, I think Awodey is better to begin with these topics especially for people who have a more CS-y background
00:57:33 <ReinH> alpounet: Agree, but Awodey leaves off right at the interesting bits ;)
00:57:38 <ReinH> Of course, so does Mac Lane
00:57:40 <alpounet> haha
00:57:51 <alpounet> yeah well, after that you're ready for the n-category cafÃ©
00:57:55 <ReinH> "For more on monoidal categories, see Mac Lane"
00:58:11 <ReinH> "Everything is a kan extension. For more on kan extensions, see... well nothing really"
00:58:14 <ReinH> Until decades later
00:58:20 <dottedmag> centrapheta: http://www.andrew.cmu.edu/course/80-413-713/hw/ -- FWIW. straight CT assignments though.
00:58:55 <ReinH> Conceptual Mathematics is a nice, gentle intro with good exercises
00:59:20 <ReinH> alpounet: for me Awodey was my "Mac Lane for Dummies"
00:59:27 <dottedmag> Too bad Mr. Knuth hadn't written a CT book.
00:59:41 <dottedmag> a-la Concrete Mathematics.
01:00:18 <ReinH> alpounet: the nLab stuff is still weird. :p
01:00:22 <alpounet> ReinH: right, that's pretty much the general opinion
01:00:43 <alpounet> haha, well, I've had some serious headaches while reading some posts there
01:00:50 <ReinH> alpounet: although actually Mac Lane's Algebra is a very easy read
01:01:04 <ReinH> and gets you used to his pedagogic style
01:01:15 <centrapheta> dottedmag, Thanks, I will look at them.
01:01:19 <alpounet> he wrote an intro to algebra?
01:01:24 <ReinH> Yep.
01:01:28 <alpounet> not sure how it fares with the classic recommendations there :p
01:02:02 <ReinH> It's basically "From 0 to Category Theory (With a Brief Detour Into All of Abstract Algebra)" ;)
01:02:13 <ReinH> how his Algebra book fares? It's great.
01:02:39 <centrapheta> I have written my own little challenge if anyone is interested. It involves Dynamic Programming/Genetic Programming
01:02:52 <ReinH> It pairs nicely with Lang actually
01:03:09 <alpounet> alright :-)
01:03:15 <centrapheta> Given 7 9 8 7 6 5 4 3 2 5 6 7 3 4 2 4 5 8 7 = 476 Goal: find out what mathematical operators (minus, multiply, divide, add) satisfy that solution (476)
01:03:22 <centrapheta> Order of operation is variable.
01:03:30 <alpounet> ReinH: hey, when does the next haskellcast come out?
01:03:32 <centrapheta> Example output: http://pastebin.com/qWB3rnmA
01:03:40 <ReinH> alpounet: This week or next :)
01:04:04 <ReinH> Maybe not as nicely as this pairs with Lang though ;) http://math.berkeley.edu/~gbergman/.C.to.L/
01:04:10 <dottedmag> centrapheta: sounds like one of "warmup" excercises in ACM ICPC contests.
01:04:12 <centrapheta> Naive bruteforce is also trivial, but rather boring :P
01:04:36 <ReinH> centrapheta: Richard Bird has a solution to that in his Functional Pearls book, first chapter iirc.
01:05:05 <ReinH> It's very nice.
01:05:23 <centrapheta> ReinH, I will check it out.
01:05:41 <ReinH> The same solution has been used in lectures by Hutton iirc, there are videos somewhere
01:06:02 <centrapheta> My solution: http://pastebin.com/dvUFuDqs
01:06:03 <christiaanb> killy9999: the first type signature is too general, you can't pass e.g. a "Maybe Int", it must be a tuple
01:06:30 <centrapheta> (I know it is bad)
01:06:49 <ReinH> centrapheta: it's not that bad but you'll enjoy the Bird solution
01:06:53 <ReinH> and especially the way it's derived
01:08:21 <frerich> centrapheta: A variation of that problem is in Graham Hutton's "Programming in Haskell" book (IIRC in a section called "The Countdown Problem")
01:08:32 <frerich> centrapheta: The code of which is available at http://www.cs.nott.ac.uk/~gmh/countdown.lhs
01:09:00 <ReinH> frerich: yep, that's the one I'm referring to :)
01:09:12 <christiaanb> anyone else having problems upload (documentation) to hackage? I'm getting "502 Bad Gateway; nginx/1.6.0"
01:09:14 <ReinH> There is a video of his lecture on the problem as well
01:09:33 <ReinH> his and Bird's solutions are almost identical
01:09:39 <ReinH> but I think I prefer Bird's just a bit
01:10:59 <centrapheta> Interesting.
01:11:17 <frerich> ReinH: Just wanted to add Bird's book to my amazon wish list only to find out that it's been there since August 2013...
01:11:25 <ReinH> heh
01:11:26 <frerich> Godo to hear that it's still a worthwhile read :)
01:11:33 <ReinH> the google play store has an ebook
01:11:41 <ReinH> when I bought mine Amazon didn't :/
01:11:54 <ReinH> oh but it does now
01:11:57 <ReinH> guess I'm buying it again
01:12:22 <centrapheta> So there solutions are also bruteforce?
01:12:28 <ReinH> eh maybe not for $30, I thought the rent price was the purchase price :/
01:12:41 <ReinH> centrapheta: no
01:15:12 <dottedmag> Is $55 for MacLane's Algebra an adequate price?
01:15:31 <frerich> centrapheta: Hutton starats out with a brute force solution and then incrementally refines it.
01:16:00 <ReinH> dottedmag: I think so
01:17:11 <dottedmag> Thanks.
01:17:46 <centrapheta> Ah yes I see now.
01:18:01 <centrapheta> A genetic programming/DP solution would be pretty nice.
01:18:13 <centrapheta> dp[i][j][k] = Can I make the number k using the numbers a[i ... j].
01:18:17 <dottedmag> genetic, really? Isn't it straightforward DP one?
01:18:59 <hvr> does anyone know why there's a 'asks' function in "Control.Monad.Reader.Class"? It seems kinda redundand given the 'reader' method
01:21:00 <christiaanb> hvr: looking at the source you can see that: asks = reader
01:21:51 <t7> when you have a number literal 123 and you specify it is a Word8 or whatever like so:   123 :: Word8   is this translated to   fromInteger 123 ?
01:22:54 <hvr> christiaanb: ...that doesn't really answer my question though :-)
01:23:20 <hvr> christiaanb: i.e. why is there such a redundant alias defined?
01:23:33 <t7> plz respond
01:24:09 <hvr> t7: I'd say yes
01:24:29 <christiaanb> t7: using -ddump-ds in GHCi I see: it_aYk = GHC.Num.fromInteger @ GHC.Word.Word8 $dNum_aYm (__integer 123)
01:24:44 <hvr> t7: it's actually written in the Haskell Report iirc
01:24:57 <t7> cool i was right
01:25:15 <dottedmag> hvr: maybe for convenience?
01:25:19 <hvr> t7: or put differently, what else could it have been?
01:25:49 <t7> some hacky magic
01:25:57 <t7> that isn't as elegant
01:26:18 <t7> but would be more performant (is that a word?)
01:27:07 <christiaanb> hvr: I see that reader was introduced in mtl-2.1, while asks existed before that
01:27:46 <christiaanb> so I guess backwards compatibility ?
01:31:18 <christiaanb> t7: after optimization it turns into: GHC.Types.W# (__word 123)
01:32:28 <t7> aha
01:39:09 * hackagebot haskakafka 0.2.0.0 - Kafka bindings for Haskell  http://hackage.haskell.org/package/haskakafka-0.2.0.0 (tdimson)
03:19:23 * hackagebot kmeans-vector 0.3 - An implementation of the kmeans clustering algorithm based on the vector package  http://hackage.haskell.org/package/kmeans-vector-0.3 (AlpMestanogullari)
03:27:19 <C-Keen> Hi there! Is anyone in here running ghc on OpenBSD by chance? I am using the provided package from -current and am trying to install git-annex with cabal, I get the following error which I don't know how to further debug: Loading package integer-gmp ... linking ... ghc: /usr/local/lib/ghc/integer-gmp-0.5.0.0/HSinteger-gmp-0.5.0.0.o: unhandled ELF relocation(Rel) type 10
03:27:23 <C-Keen> any ideas?
03:27:51 <C-Keen> The version of the package is ghc-7.6.3p1
03:27:56 <C-Keen> this is on i386
03:29:24 * hackagebot Agda 2.4.0 - A dependently typed functional programming language and proof assistant  http://hackage.haskell.org/package/Agda-2.4.0 (UlfNorell)
03:43:31 <akegalj> can i somehow patern match with case and use guards with it like so: http://pastebin.com/8Nitejf3
03:44:20 <Philonous> akegalj, Yes, but you need a right arrow ("->") instead of an equal sign ("=")
03:44:20 <drupzky> how do i export everything from a module?
03:44:34 <Yuu_chan> drupzky: module YourModule where
03:44:42 <Philonous> drupzky, Either leave out the export list or add module MyModule to it
03:44:42 <drupzky> thanks
03:44:51 <drupzky> kk thx
03:44:53 <warpy> drupzky: just dont have an export list after you module name
03:45:00 <Philonous> as in "module MyModule (module myModule) where
03:45:03 <warpy> everything is exported by default
03:46:08 <Philonous> I would hold that it's better style to explicitly export the whole module if that's what you want. It also allows you to re-export other things.
03:55:02 <akegalj> Philonous: thank you very much :)
04:04:29 * hackagebot influxdb 0.4.1 - Haskell client library for InfluxDB  http://hackage.haskell.org/package/influxdb-0.4.1 (MitsutoshiAoe)
04:04:31 * hackagebot pgm 0.1.4 - Pure Haskell implementation of PGM image format  http://hackage.haskell.org/package/pgm-0.1.4 (SergeyAstanin)
04:40:25 <hth313> I get 'Illegal role annotation for ForthWord;' with ghc 7.8.2 on a boot file after adding 'type role ForthWord nominal', is this wrong syntax?
04:50:49 <pavonia> hth313: Have you tried adding the same annotation to the .hs-boot file?
04:52:03 <hth313_> hmm, my chat client did not relay anything... now I switch to erc
04:52:58 <carlasema> Anyone here interested in a challenge?
04:53:13 <hth313_> I put the type role annotation in the .hs-boot file, before the 'data ForthWord cell'
04:54:21 <pavonia> And is it in the .hs file too?
04:54:34 <hvr> .oO( https://ghc.haskell.org/trac/ghc/ticket/1409 )
04:54:49 <hth313> I just put it in the .hs file too, same result
04:55:18 <hth313> Without it ghc said the types mismatched and suggested adding this line to the .hs-boot file
04:56:46 <pavonia> What do the types look like?
04:59:12 <hth313> https://github.com/hth313/hthforth/blob/master/src/Language/Forth/Word.hs
05:00:30 <hth313> https://github.com/hth313/hthforth/blob/master/src/Language/Forth/Word.hs-boot (I have added role annotations in my local copy)
05:01:48 <pavonia> Hhm, but don't you need the complete type definition in the boot file?
05:02:56 <hth313> pavonia: Not in the past
05:04:35 * hackagebot conduit 1.1.5 - Streaming data processing library.  http://hackage.haskell.org/package/conduit-1.1.5 (MichaelSnoyman)
05:04:44 <pavonia> Don't know then
05:04:54 <ibotty> hi
05:07:20 <ibotty> can someone help me with a question regarding finally tagless encoded parsing?
05:07:36 <ibotty> i posted the question to reddit: https://pay.reddit.com/r/haskellquestions/comments/27di66/design_question_re_finally_tagless_parsing_and/
05:11:28 <nomeata> > _1 (1,2,3) (\x -> [x,0])
05:11:30 <lambdabot>  Couldn't match expected type â€˜a0 -> f b0â€™
05:11:30 <lambdabot>              with actual type â€˜(t0, t1, t2)â€™
05:11:52 <nomeata> > _1 (\x -> [x,0]) (1,2,3)
05:11:54 <lambdabot>  [(1,2,3),(0,2,3)]
05:12:01 <nomeata> > _3 (\x -> [x,0]) (1,2,3)
05:12:03 <lambdabot>  [(1,2,3),(1,2,0)]
05:12:36 <nomeata> > ( some function of _1 and _3) (\x -> [x,0]) (1,2,3) == [(1,2,3),(0,2,0)]
05:12:38 <lambdabot>  <hint>:1:17: parse error on input â€˜ofâ€™
05:13:15 <nomeata> anyone up for a lens puzzle? How do I combine _1 and _3 (or, more general, more complex lenses) to get the above behavior?
05:13:41 <nomeata> (if that is even possible)
05:13:45 <hth313> I tried to put in a complete version of the ForthWord type in the .hs-boot file, but it goes wrong in the same way. I think it defaults to nominal in .hs and representational in the .hs-boot file, and my attempt to match them using type role annotation does not work.
05:14:19 <nomeata> interesting. One mentions "lens" and an edwardk is summoned :-)
05:15:31 <Yuu_chan> %D
05:15:47 <Yuu_chan> Â«AnÂ» edwardk?
05:15:56 <companion_cube> yes, edwardk is actually a type class
05:16:18 <edwardk> hint: that trick is easy. people talk about lens all the time, so I can just join whenever ;)
05:16:19 <Yuu_chan> He can't, he starts with a lowercase letter
05:16:23 <sipa> maybe he's a monad
05:16:38 <sipa> edwardk Answer
05:16:59 <nomeata> sipa: do you want to join him or bind him?
05:17:07 <Yuu_chan> Or return?
05:17:10 <nomeata> sipa: or return him, if once you are done?
05:17:36 <t7> and in  the darkness bind them
05:18:03 <nomeata> the1ring :: Darkness a -> (a -> Darkness b) -> Darkness B
05:18:10 <Okasu> t7: Lord of the Monads?
05:20:19 <Yuu_chan> One monad to bind them all
05:20:41 <Yuu_chan> @google mother of all monads
05:20:43 <lambdabot> http://blog.sigfpe.com/2008/12/mother-of-all-monads.html
05:20:43 <lambdabot> Title: A Neighborhood of Infinity: The Mother of all Monads
05:22:30 <nomeata> Let me re-phrase my question: I can apply a applicative operation in several positions of one pair at the same time:
05:22:32 <nomeata> inBoth :: Applicative f => (a -> f a) -> (a, a) -> f (a, a)
05:22:32 <nomeata> inBoth f (p1,p2) = (,) <$> f p1 <*> f p2
05:23:08 <nomeata> This is somehow related to (_1 f) and (_2 f). But how? How can I generalize inBoth to take two arbitrary lenses, instead of acting like _1 and _2?
05:23:42 <magicman> You could write a lens-combinator and get [(1,2,3),(1,2,0),(0,2,3),(0,2,0)] with a Monad constraint instead of Applicative.
05:24:12 <nomeata> magicman: which is not what I want, though: I need it to work for Applicative (for Active, to be precise)
05:24:14 <magicman> But that's not what you want. You either want all or nothing.
05:25:01 <nomeata> It works if all lenses are indices: To combine "ix 1, ix 3, ix 4" I can write "itraversed . indices (`elem` [1,3,4])", but that does not seem to generalize to _1 or even mixed lenses.
05:25:29 <nomeata> (In my real use case, I want to apply something in both _3 and "_2 . ix 0 . _5")
05:26:39 <benzrf> :t itraversed
05:26:40 <lambdabot> (TraversableWithIndex i t, Indexable i p, Applicative f) => p a (f b) -> t a -> f (t b)
05:26:58 <fizruk> :t bitraverse
05:26:59 <lambdabot>     Not in scope: â€˜bitraverseâ€™
05:26:59 <lambdabot>     Perhaps you meant one of these:
05:26:59 <lambdabot>       â€˜itraverseâ€™ (imported from Control.Lens),
05:27:05 <markhala> what's]]
05:27:09 <markhala> hekki
05:27:13 <markhala> helo
05:27:42 <fizruk> :t beside
05:27:44 <lambdabot> (Data.Profunctor.Rep.Representable q, Data.Bitraversable.Bitraversable r, Applicative (Data.Profunctor.Rep.Rep q), Applicative f) => Optical p q f s t a b -> Optical p q f s' t' a b -> Optical p q f (r s s') (r t t') a b
05:27:49 <fizruk> wow
05:28:18 <magicman> (and what if bit ravers aren't able?)
05:28:33 <nomeata> magicman: :-)
05:30:36 <warpy> help!
05:31:06 <warpy> how do i fix this error and make it work: http://lpaste.net/105120
05:32:00 <warpy> i suppose everyone is asleep. i'll come back later
05:32:15 <Maior> recommend waiting for >1m
05:32:48 <pavonia> warpy: You can use Either Ping Pong as return type for parseLine if you want it to be able to return different types
05:32:48 <Maior> warpy: I don't know the technical words, but basically you can't do that
05:32:53 <Maior> what pavonia said
05:33:12 <warpy> Maior: well, i did :) waited for 1 min 9 secs
05:33:18 <fizruk> warden: you probably should add data Message = MsgPing Ping | MsgPong Pong  (or Either) and make it an instance of Message
05:33:18 <Axman6> warpy: Ping and Pong are different types, so it's not possible that they can both be in the same case statement like that. You might need something like Just (Left (Ping _)) and Just (Right (Pong _)) or make them the same type with two constructors
05:33:44 <fizruk> warden: sorry, that was meant for warpy ^
05:34:06 <warpy> pavonia: but what if i have more than two types, i cant use Either then
05:34:25 <pavonia> You can nest it
05:34:37 <ibotty> warpy: in my part of the internet you waited 54 seconds
05:34:39 <warpy> fizbin: i cant do that because it becomes non extensible by users of the library
05:35:34 <ibotty> warpy: the expression problem is a hard one
05:35:42 <fizbin> warpy: You mean fizruk
05:35:53 <warpy> basically i want to write a message parser lib in which others can add new message types and message parser types
05:36:17 <warpy> fizbin: oh sorry.
05:36:28 <warpy> ibotty: so it cant be done?
05:36:44 <ibotty> warpy: not recommended, but you can use existentials. or better yet, just use hlist
05:36:58 <Axman6> neither of those seem like good ideas...
05:37:02 <ibotty> look into the finally tagless approach
05:37:07 <warpy> i am using existentials, arent i?
05:37:27 <warpy> dunno how hlist fits into this case though
05:38:09 <ibotty> you need a way to unify all the types in your return type of parseLine
05:39:26 <warpy> how do i do it
05:39:32 <ibotty> dMessa
05:39:37 <ibotty> sorry.
05:40:21 <warpy> wonder if i can throw in a Typeable to fix it
05:40:29 <Axman6> that'
05:40:50 <Axman6> that's the sort of direction you'll have to go for what you want. so it might be time to think of a different wayto do this
05:41:41 <warpy> this IS the different way i thought of ...
05:42:06 <warpy> maybe i am just too dumb
05:42:26 <ibotty> sorry i was disturbed
05:42:27 <ibotty> data MessageWrapper = forall m. Message m => MessageWrapper m
05:43:07 <ibotty> i am pretty sure it won't work, because of your variable return type in parse though
05:43:11 <tristanStrange> hey all. what's defaultMain and where do I get it?
05:43:29 <ibotty> tristanStrange: depends on the default main you need
05:43:31 <awestroke> tristanStrange: it's from Criterion.Main
05:43:38 <awestroke> probably
05:43:45 <tristanStrange> I just started playing with the awesome looking music suite and first example uses it
05:43:58 <tristanStrange> But I'm told it's not in scope
05:44:49 <warpy> ibotty: i'll try
05:44:51 <awestroke> tristanStrange: http://holumbus.fh-wedel.de/hayoo/hayoo.html?query=defaultMain
05:45:46 <tristanStrange> cheers awestroke
05:46:20 <kgadek> > let x = (Left 5 :: Either Int Char) in (x :: Either Int String)
05:46:22 <lambdabot>  Couldn't match type â€˜GHC.Types.Charâ€™ with â€˜[GHC.Types.Char]â€™
05:46:22 <lambdabot>  Expected type: Data.Either.Either GHC.Types.Int GHC.Base.String
05:46:22 <lambdabot>    Actual type: Data.Either.Either GHC.Types.Int GHC.Types.Char
05:46:43 <tristanStrange> hmmm.... so it's for running tests usually?
05:46:57 <Sibi__> Can anybody comment why this piece of code is taking tons of memory and time to execute: http://lpaste.net/105122 ?
05:50:02 <awestroke> tristanStrange: it's just a function name, you can create your own (defaultMain = putStrLn "hello"). There seems to be a few packages that define a function with this name. Among them is Criterion, a package for running performance benchmarks
05:51:48 <fpck> since support for iOS is backed in the ghc 7.8 release, can somebody tell me when full android support might be coming?
05:52:35 <warpy> ibotty: it doesnt work :(
05:53:00 <tristanStrange> thanks awestroke. i'm still pretty new to this haskell malarky
05:53:47 <ibotty> tristanStrange, awestroke: music-suite for sure uses a different defaultMain
05:54:10 <ibotty> unfortunately it is just not there (not in the prelude modules)
05:54:16 <ibotty> i guess it should be open
05:54:40 <ibotty> so tristanStrange: try `open` instead of defaultMain
05:55:24 <tristanStrange> brilliant works a treat!
05:55:41 <ibotty> can you file a bug report for the music-suite people?
05:55:54 <tristanStrange> just on there issues page now!
05:56:17 <ibotty> great! thumbs up
05:56:41 <Axman6> fpck: I'm not sure there is any Android work for GHC, have you seen some?
05:57:39 <ibotty> warpy: what do you want to do in your main?
05:58:13 <ibotty> if you want to inspect the type in any way, it can't work, because you don't know anything about your type
05:58:57 <fpck> Axman6: i've seen some commits in the ghc repo, but nothing serious... so it might be a while until there's android support, if at all?
05:59:13 <Walther> Wait- haskell to android compiler? :D
05:59:14 <ibotty> so either get rid of the MessageParser type or think about what you want to do
05:59:41 <warpy> ibotty: well, if i dont put a type, it gives this error: No instance for (Message m0) arising from a use of ‘parseLine’  The type variable ‘m0’ is ambiguous
06:00:46 <merijn> fpck: Basically, android support really depends on how many GHC hackers want to work on it (or alternatively, how many people are willing to pay someone to work on it)
06:01:04 <ibotty> do you need the type family? if so what do you want to do with `MessageParser m`
06:02:04 <fpck> merijn: i see
06:02:41 <ibotty> warpy: i think for two approaches to the expression problem one can look in oleg's tutorial on finally tagless encoding
06:02:52 <ibotty> warpy: http://okmij.org/ftp/tagless-final/course/lecture.pdf
06:03:09 <warpy> ibotty: ah thanks. i'll look into it
06:03:31 <ibotty> but before you seriously investigate it, think about what you want to do before
06:03:47 <warpy> ibotty: i dont know if i need a type family
06:03:59 <ibotty> and maybe write it with only two message types first
06:04:13 <hth313> Sibi__: I do not know if it helps, but I would eliminate those manyTill, the newline parsing can go into snapshotParser. The profiler is a very useful tool to tune programs.
06:04:45 <ibotty> warpy: then make the MessageParser type family an ordinary dtype
06:05:55 <ibotty> then the wrapped approach should work
06:06:18 <Sibi__> hth313: Thanks, will look into it.
06:06:57 <warpy> <warpy> basically i want to write a message parser lib in which others can add new message types and message parser types
06:07:11 <warpy> ibotty: i dont understand
06:08:07 <warpy> class MessageParser mp where type Message mp
06:08:12 <warpy> like this?
06:08:32 <ibotty> what is a message parser type?
06:09:04 <ibotty> do you need it to be a type? or can it be a function?
06:09:23 <warpy> i dont need it to be a type
06:09:49 <ibotty> if it can be a function let it be a function in the typeclass.
06:10:16 <warpy> in the Message typeclass?
06:10:34 <warpy> parse IS that function
06:10:38 <ibotty> warpy: see chapter 2.3 of oleg's lecture
06:10:48 <warpy> hmm
06:16:26 <frerich> I seem to recall that there was a saying that you can abstract over any value using a function, except for functions over which you can only abstract using another function. Does anybody know the actual quote and who said it?
06:16:34 <yac> what's the common default indent width?
06:16:38 <yac> 2 spaces? 4 spaces?
06:16:52 <Axman6> 4 is the most common I've seen
06:17:15 <ibotty> yac: 4 is most common. see tibbe's style guide https://github.com/tibbe/haskell-style-guide/blob/master/haskell-style.md
06:19:18 <warpy> i use 2 everywhere ..
06:19:26 <nclarke_> I also use 2
06:21:29 <ibotty> where clauses inlook way better when the
06:21:53 <ibotty> aww. where clauses look way better indented 2 spaces when the rest is indented 4 spaces
06:22:39 <yac> so what is the community consesus?
06:23:17 <yac> I am used to indent with 4 spaces but I'm not working a project where they used 2 and I'm considering I would switch to 2 too
06:23:17 <ibotty> i think it is close to tibbe's style guide.
06:24:01 <alpounet> the community consensus pretty much boils down to not using tabs. i've seen a lot of 2 spaces and 4 spaces based identation, generally people just go along with their style or use the style of the project they contribute to
06:24:19 <alpounet> (if different)
06:24:49 * hackagebot assertions 0.1.0.4 - A simple testing framework.  http://hackage.haskell.org/package/assertions-0.1.0.4 (vi)
06:24:50 <ibotty> who of the big names in haskell uses 2 space indent?
06:26:53 <benzrf> ibotty: me!!!
06:28:11 <ibotty> benzrf: i meant the _really_ big names. :D
06:28:31 <ironChicken> i'm trying to debug my code which makes ffi calls to a shared library; i've found ltrace so i can see the library function calls happening; but all the arguments are shown as their addresses on the heap; does anyone know if there's a tool that can show me the values of those arguments? even if just showing the char* ones as strings?
06:42:26 <glc1> I've been learning the basics of haskell and functional programming, to my understanding 'variables' in haskell are inmutable. I want to make sure I understand the proper terminolgy. let x = 5. That is a 'variable' (unmutatable), correct? Or is that a 'constant' and the x in [x | x <- [1..5] ]
06:42:50 <glc1> is a variable?
06:42:59 <chirpsalot> glc1: immutable is the term.
06:43:12 <glc1> chirpsalot: thanks
06:43:29 <Philonous> glc1, It's also a constant.
06:43:29 <chirpsalot> glc1: I think people still call them variables, because they're just like variables in mathematics?
06:43:32 <flux> glc1, the term 'variable' is to be understood like in math. you when you say 'let x = 5' you 'bind' x into a value 5. however, if you have a function such as let f a b = a + b, then even though a and b are constant within the scope of the function, they may 'vary' from call to call.
06:44:17 <glc1> ok, that's what I was getting at, does the terminology specify what's a variable and what's a constant
06:44:46 <glc1> or they actually the same thing, and the terms can be used interchangably?
06:44:59 <merijn> glc1: I would say that in common usage variable is a subset of constants
06:45:05 <flux> well, I suppose a constant is when you initialize a variable with a constant.
06:45:17 <flux> but it doesn't really matter in code if a variable is a constant or not.
06:45:30 <ironChicken> a function of no arguments is effectively constant
06:45:35 <Philonous> merijn, How does that work? Every variable is a constant?
06:45:36 <merijn> glc1: There's no real explicit description of what to call what
06:45:46 <merijn> glc1: For example, '1' is clearly a constant, but not a variable
06:46:00 <merijn> Philonous: Yeah, although I realised that might be overstating it a bit
06:46:33 <merijn> glc1: Since all haskell variables are immutable you can use them the exact same way you could use a constant
06:46:46 <Maior> glc1: the word/concept of "binding" may be useful here?
06:46:52 <glc1> flux: ill be honest, i'm asking because I'm taking an exam tomorrow and on an exam from the same subject last year there was a question the effect of "Explain what a variable and constant are in procedural programming and functional programming' that's the need for the preciseness
06:47:06 <Maior> ah
06:47:21 <Maior> fwiw I don't like that as an exam question, but then, I never liked a lot of exam questions
06:47:23 <BoR0> so variable/constant for procedural/functional respectively. you can make the distinction there
06:47:24 <flux> glc1, then the best thing to do is to look up to your course material :-)
06:47:28 <merijn> glc1: ah, in that scenario you might be better off asking your professor, TA or fellow students
06:47:38 <glc1> merijn: thanks, in practice I think I have a grasp, it's more of wanting to be precise with the terminology
06:47:55 <flux> the course probably has a single 'right' answer..
06:48:07 <BoR0> one variable in procedural languages can have different values within a context. this is not the case with functional languages
06:48:19 <merijn> glc1: Because these words in practice are applied rather vaguely and shoddily, so the odds of us hitting upon the exact answer your professor is looking for might be slim :)
06:48:23 <glc1> flux: hehe, it's not very clear unfortunately, I also tried wikipedia and learn you a haskell - I'm probably worrying about it too much
06:48:35 <glc1> merijn: i agree
06:48:55 <glc1> BoR0: that's a good definition, thanks
06:49:07 <BoR0> that also depends on the professor. if he wants the same answers from the students that he has, that won't be good
06:49:40 <BoR0> they should be true, but they shouldn't be in the same form :)
06:50:01 <Philonous> merijn, I would have said that a constant is just a variable where the bound expression does not depend on the context. "1" in that sense is not a constant but a constant expression.
06:50:41 <Philonous> Though often we say "constant" to constant expressions
06:50:56 <frerich> glc1: I suspect the key bit is that in an imperative (e.g procedural) paradigm, you express algorithms as a sequence of step, each of which possibly mutating some state. In this setting, it makes sense to distinguish constants (symbolic identifiers for values, and you cannot 'rebind' the identifier to a different value at runtime) and variables (symbolic identifiers for values, and you can change the value referenced by some symbol).
06:51:15 <Maior> glc1: which University?
06:51:30 <glc1> extraneous to haskell, but I think giving exams on programming (and for other subjects as well) is quite difficult, because they aren't conducive to being tested
06:51:47 <glc1> Maior: La UNED (Spain)
06:51:54 <frerich> glc1: In a functional paradigm, which expresses algorithms as the composition of function, there is no 'sequence of steps' in the same sense and there is no state being mutated. Hence, there is no difference between 'constant' and 'variable'. In Haskell, everything is just a 'variable'.
06:52:35 <glc1> frerich: ..or a constant!
06:52:51 <Philonous> glc1, Even on the risk of beating a dead horse by now, a "variable" in haskell is a name for (i.e. that is bound directly to a) value, wheres in imperative languages a variable is a name for a  place/reference cell that contains a value.
06:52:57 <frerich> glc1: The term "constant" is not used (or at least not common) in Haskell, no.
06:53:18 <frerich> glc1: What Haskell calls a variable is very much like what an imperative language would call a 'constant'.
06:53:26 <Maior> Philonous / frerich: those are nice definitions
06:53:34 <tac_> 'They call them variables, but I've never seen 'em vary.'
06:53:44 <Maior> hah
06:53:58 <BoR0> haskell cheats with MVar tho :)
06:54:08 <tac_> You might also think of them as variables from regular languages, except everything is an IORef blah instead of a usual blah
06:54:08 <glc1> frerich: I think your definitio also spills over into another question that might appear "What is referential transparency / state of computation?"
06:54:08 <Philonous> BoR0, How so?
06:54:16 <frerich> tac_: Hehe, to be fair: they do vary. They are variable in a context, e.g. if you consider the expression 'x + 1', 'x' has no single fixed value like '1' has.
06:54:22 <BoR0> well, it's a mutable variable, isn't it?
06:55:14 <glc1> thank you all, very helpful
06:55:44 <frerich> glc1: The bottom line is: if a function is "referentially transparent", it means you can replace the function call with the body of the function without changing the behaviour of the program.
06:56:07 <frerich> glc1: This is not specific to functions but applies to any expression really.
06:57:06 <Philonous> BoR0, Well, no, ti doesn't cheat. MVars are explicitly reference cells. That is, the MVar doesn't vary, only it's  "content", but the content isn't observable without performing IO.
06:57:27 <frerich> glc1: For instance, a function which is *not* referentially transparent would be 'time()'. If you assume that it returns som evalue (say: seconds since January 1st 1970), and you replace some invocation of time() with the value it returns, then the program no longer does the same thing if you execute it tomorrow.
06:58:13 <BoR0> Philonous, but even if we have "int x = 5; x = 6" in C, then we can say that x doesn't vary, only its "content"
06:58:15 <frerich> glc1: On the other hand, something like an 'abs()' function (which gives the absolute value of its argment) *is* referentially transparent. The behaviour function only depends on the arguments.
06:58:20 <Philonous> frerich, You can replace it with it's return value. replacing it with it's body (i.e. inline) shouldn't change semantics even in an imperative language
06:59:19 <frerich> Philonous: I was being a bit imprecise, right. I guess 'Replace it with what it evaluates to' would have been better.
06:59:30 <frerich> Philonous: if you just inline stuff, there's not much of a difference indeed ;-)
07:00:19 <frerich> glc1: Disclaimer - I dropped out of university after 3 semesters of Comp. Sci. and this is all just stuff I gathered while learnin Haskell, hanging out in this channel and reading articles online :}
07:00:38 <Philonous> BoR0, I meant to say, x evaluates to the same value (namely the same MVar), even when you change the contents of the MVar. The same is not true in the case of C. Once you assigned to x, it evaluates to the new value.
07:02:01 <glc1> frerich: I think that's a good definiton, slightly different perspective to the material from the course
07:02:55 <glc1> frerich: if it's not 100% correct (which i'm not claiming it is incorrect), it's helped me to view referential transparency in another light
07:02:59 <frerich> glc1: I don't know what "state of computation" would refer to exactly, but I guess that if it's asked together with "referential transparency" then the answer has something to do with "global state" and "side effects" and such things.
07:04:06 <glc1> frerich: state of computation (keep in mind this is a direct translation from spanish and might have a different name) is for example an interative factorial
07:04:45 <glc1> frerich: or even better the c function void foo(){ static int bar; bar++; }
07:05:16 <frerich> glc1: Yeah, that's a function which is not referentially transparent. It's not solely implemented in terms of it's arguments - everytime you call it, you get a different value. Like with time().
07:05:34 <frerich> glc1: I.e. that function has side-effects: the next time you call it, you get a different value.
07:08:12 <ibotty> i asked before, can someone familiar with final encoding look into my question on reddit: https://pay.reddit.com/r/haskellquestions/comments/27di66/design_question_re_finally_tagless_parsing_and/
07:14:02 <glc1> flux, frerich, et al: While searching for something else in the textbook I stumbled upon the answer. My professors view a constant in a purely functional language as a function that always returns the same value "two x = 2"
07:15:39 <Yuu_chan> glc1: there is a difference between constant value and constant function
07:15:40 <dottedmag> glc1: Same in Haskell. two = const 2 is the same as the two x = 2
07:17:39 <absence> i'm trying to compile a package that depends on network, which has a horrible platform dependent configure script that i have to run inside a unix emulation layer. when i do, it fails telling me setup-Configure-Cabal-1.18.1.3-x86_64-windows-ghc-7.8.2.exe doesn't exist. when installing packages outside the emulation layer cabal finds the setup-Simple-xxxxx.exe just fine. anyone know how to work around this?
07:18:19 <glc1> dottedmag: yep, they use haskell as reference for the descriptions of purely functional languages
07:21:40 <glc1> Yuu_chan: I came here because I was trying to gather a precise definition for constant and variable in Haskell - I've wrote a small program in Haskell and I have some intuition as to how it works but I wasn't sure on the terminology (and to be honest I'm not overly concerned). Right or wrong that appears to be what my professors view a constant as in a purely functional lang. I do see the point you are
07:21:42 <glc1> trying to make tho in the context of an imperative language, but since I'm still very new to haskell and it's terminology I don't see it there, could you elaborate please?
07:26:21 <dfranke> http://lpaste.net/105124
07:26:29 <dfranke> Is there a library that'll help me with what I'm doing here?
07:26:43 <dfranke> I feel like DiscriminateBool must already be written, somewhere.
07:27:34 <Yuu_chan> glc1: I see it that way (everyone, pleasy correct). A variable is a name given to a value. If it is the same all the time, it's a constant. All variables are constant in Haskell. Functions are variables (in FP) as well. The difference between a function and non-function is that it can be applied to another value and result in some new one. If it is always reduced to the same value (for any given argument), it is a constant function. So, id is a
07:27:34 <Yuu_chan> non-constant function, but a constant value (id is always id). const x is a constant function, and a constant value.
07:28:09 <dfranke> (For those not bothering to click through: I'm trying to make a variation on the Maybe type that's guaranteed to be Just if a certain predicate on a phantom type holds)
07:29:25 <Yuu_chan> Some people try to define constants as a const nullary functions, but it leads to some conceptual problems.
07:29:57 * hackagebot io-streams 1.1.4.6 - Simple, composable, and easy-to-use stream I/O  http://hackage.haskell.org/package/io-streams-1.1.4.6 (GregoryCollins)
07:33:41 <glc1> Yuu_chan: Even though I knew everything you said, I couldn't have packaged it that well, haha
07:35:05 <merijn> dfranke: I don't think it really exists, there's a type level /= in 7.8 but you still need to convert the resulting Bool to what you actually want
07:39:58 * hackagebot BlogLiterately 0.7.1.7 - A tool for posting Haskelly articles to blogs  http://hackage.haskell.org/package/BlogLiterately-0.7.1.7 (BrentYorgey)
07:41:16 <dfranke> merijn: yeah I don't think that helps; I seem to need a term-level proof (absurd x) no matter what. What I wish I could do is declare (BackendNothing :: ((IsBackendVoid b) ~ True) => Backend b a), and then when I have a ((IsBackendVoid b) ~ False) constraint, just leave off the BackendNothing case. But ghc isn't quite smart enough to realize to abstain from an inexhaustive-pattern warning if I do that.
07:42:00 <dfranke> s/to abstain/it should abstain/. I can't English today.
07:43:11 <benzrf> :t absurd
07:43:12 <lambdabot> Not in scope: â€˜absurdâ€™
07:43:18 <dfranke> benzrf: Void -> a
07:43:19 <benzrf> pfft
07:43:22 <benzrf> ah yes
07:43:30 <benzrf> wait, shouldnt that be vacuous
07:43:33 <lwm> @where mybrain
07:43:34 <lambdabot> I know nothing about mybrain.
07:43:39 <benzrf> @where my brain
07:43:39 <lambdabot> I know nothing about my.
07:43:42 <benzrf> aw.
07:43:59 <benzrf> @where myâ–‘brain
07:43:59 <lambdabot> I know nothing about myâ–‘brain.
07:44:14 <lwm> woah there ascii
07:44:21 <lwm> where'd you pull that one out of
07:44:22 <benzrf> :^o
07:44:29 <benzrf> lwm: a secret place
07:44:38 <warpy> ibotty: i figured it out http://lpaste.net/105120 . thanks a lot for help
07:44:59 * hackagebot music-util 0.11 - Utility for developing the Music Suite.  http://hackage.haskell.org/package/music-util-0.11 (HansHoglund)
07:45:04 <dfranke> I found this discussion on Stack Overflow, but the proposed solution is similar in complexity to mine: http://stackoverflow.com/questions/14273235/can-gadts-be-used-to-prove-type-inequalities-in-ghc
07:45:28 <tdammers> Å§á¸©ÃªÅ™Ã« ÃŸâ‚¬ Å«Ã±Ä±Ã§Ã¸Ä‘Ã¨â€½
07:45:57 <dfranke> I'm not expecting there to be a better way to do this, really, just hoping someone's written a library that does it so that I don't have to reinvent the wheel.
07:47:29 <ibotty> warpy: looks ok. but note, that you existential is called the existential antipattern. http://lukepalmer.wordpress.com/2010/01/24/haskell-antipattern-existential-typeclass/
07:47:50 <warpy> ibotty: but that's how control.exception works too
07:47:54 <warpy> right?
07:48:16 <ibotty> i am just telling you
07:48:51 <warpy> i think if it is good for control.exception then it is good enough for me
07:49:05 <warpy> ibotty: is there a way around it though?
07:49:09 <warpy> a better way
07:49:47 <lwm> tdammers: haaa ... whos got the lambda symbol then
07:50:05 <Phill_> Anyone know how to calculate the natural logarithm of an Integer type ? I can only find packages that accept log base as Int or Integer, not as float
07:50:54 <byorgey> Phill_: the 'log' function finds the natural logarithm of floating-point types
07:51:02 <albeit> :t log
07:51:03 <lambdabot> Floating a => a -> a
07:51:14 <byorgey> Phill_: you can convert your Integer to Double using fromIntegral, then call log
07:51:18 <taktoa> Phill_: fromIntegral?
07:51:25 <ibotty> warpy: final encoding is pretty nice, actually. it does not work for extensible exceptions afaict though. note: some do dislike the exception mechanism...
07:51:27 <byorgey> if your Integer is very large and you need more accuracy, then I am not sure
07:51:28 <warpy> :t log . fromIntegral
07:51:30 <lambdabot> (Integral a, Floating c) => a -> c
07:51:36 <Phill_> yeah the Interger is massive
07:51:42 <byorgey> ah.
07:51:42 <Phill_> the 150000000th fib number
07:52:10 <warpy> ibotty: what is final encoding
07:52:27 <warpy> ibotty: is it in the paper you linked me?
07:52:31 <warpy> i am yet to read it
07:52:32 <ibotty> yes
07:52:45 <warpy> ok. i'll read it now
07:52:52 <ibotty> it's nice and very "functional"
07:52:55 <fxr> v0|d: re
07:53:41 <warpy> then why didnt they do exceptions that way
07:54:19 <byorgey> Phill_: well, the nth Fibonacci number is almost exactly  phi^n / sqrt 5,  where phi = (1 + sqrt 2) / 5
07:54:44 <byorgey> Phill_: if you write    log (phi^n / sqrt 5)  you can do a little algebra and simplify
07:55:11 <Phill_> ok cool tip, thanks
07:55:15 <byorgey> which will end up being way more efficient/accurate than actually computing the 15 gazillionth Fibonacci number and taking the log
07:55:58 <dfranke> Phill_: or, let Haskell do the algebra for you. http://hackage.haskell.org/package/logfloat :-)
07:56:25 <byorgey> hah, nice =)
07:57:02 <Phill_> ah cool, thanks for the help everyone.
07:58:01 <byorgey> Phill_: err, I meant  phi = (1 + sqrt 5) / 2
07:58:07 <byorgey> that is an important difference =)
07:58:26 <monochrom> > log (exp 1)
07:58:28 <lambdabot>  1.0
07:58:31 <ibotty> warpy: because it does not mix with other things you might want. sorry to be vague. also with the problem with exceptions you don't see the disadvantages so much: you never attach data to your exceptions
07:59:04 <warpy> hmm. i'll read it and see if it suits my purpose
07:59:10 <warpy> thanks for the pointers
08:00:00 * hackagebot yesod 1.2.5.3 - Creation of type-safe, RESTful web applications.  http://hackage.haskell.org/package/yesod-1.2.5.3 (MichaelSnoyman)
08:00:15 <ibotty> warpy: there is also one course on school of haskell https://www.fpcomplete.com/user/mutjida/typed-tagless-final-linear-lambda-calculus
08:00:47 <warpy> oh wow. great!
08:00:52 <Adeon> anyone familiar with netwire? what exactly is the 'e' type variable in 'Wire s e m a b'?
08:00:57 <ibotty> i prefer the oleg's lecture notes and his (et al's) paper though
08:01:07 <warpy> i'll read both
08:01:22 <Adeon> I see it sometimes functions put a monoid constraint on it
08:01:28 <albeit> Is there a clean way to get multiple fields from a state monad? Such as doing "foo <- gets _foo; bar <- gets _bar; baz <- gets _baz" in one expression
08:01:31 <warpy> ibotty: link me to the lecture notes too?
08:01:39 <ibotty> i already did
08:01:43 <albeit> (Without reading in the entire state object)
08:01:46 <ibotty> http://okmij.org/ftp/tagless-final/course/lecture.pdf
08:02:00 <ibotty> http://okmij.org/ftp/tagless-final
08:02:09 <warpy> albeit: SomeStruct { .. } <- get
08:02:47 <albeit> warpy: Hoping not to have to read in the entire state object, in case I modify what fields it has
08:02:53 <Yuu_chan> albeit: lens are fine too
08:03:12 <albeit> Yuu_chan: How would it look with lens?
08:03:23 <Algebr> When I give my friend a binary of a haskell program and he doesn't have ghc installed, how can the binary run? Doesn't every haskell program need a haskell rts?
08:03:41 <warpy> rts is in the binary
08:03:43 <Yuu_chan> albeit: could you paste a whole State computation?
08:03:48 <deweyvm> is this correct? i have two versions of a library (x.1 and x.2) and two sets of libraries using each one. if i remove all the libraries using the x.1 then delete x.1 then reinstall all those libraries i should be good to go right?
08:03:48 <bennofs> Algebr: the haskell rts is statically linked
08:04:15 <Algebr> So ghc by default statically links the rts?
08:04:16 <warpy> deweyvm: use sandboxes
08:04:25 <Yuu_chan> albeit: also, what do you mean by "read in the entire object"?
08:04:41 <deweyvm> warpy: that seems to not let me use ghci to debug though
08:04:46 <albeit> Yuu_chan: It's not for a specific thing, just wondering for future use. But assume I call some non-stateful function with foo bar baz
08:04:50 <deweyvm> the libraries in question are http://pastebin.com/Ke4UUUZ4
08:04:58 <warpy> deweyvm: i know how to fix that!
08:05:01 * hackagebot diagrams-builder 0.6 - hint-based build service for the diagrams graphics EDSL.  http://hackage.haskell.org/package/diagrams-builder-0.6 (BrentYorgey)
08:05:04 <deweyvm> oh?
08:05:04 <t7> is there a better way (shorter) to work out the modular multiplicative inverse than this: http://lpaste.net/105130 ?
08:05:13 <albeit> Yuu_chan: Like I could do MyObject foo bar _ baz _ _ <- get, but if I add a field, that line would break
08:05:31 <warpy> deweyvm: alias ghci-sandbox="ghci -no-user-package-db -package-db .cabal-sandbox/*-packages.conf.d"
08:05:50 <deweyvm> warpy: ill try that, thanks!
08:06:17 <warpy> deweyvm: run ghci-sandbox in the dir that contains the sandbox
08:06:21 <warpy> it should work fine
08:06:44 <byorgey> t7: is that the extended euclidean algorithm?  that code is kind of hard to understand
08:06:46 <albeit> warpy deweyvm I think you missed an "="... "-package-db=.cabal...."
08:06:55 <t7> byorgey: ya
08:07:01 <warpy> albeit: nah, it works either way
08:07:08 <byorgey> t7: shorter how? less code? or faster?
08:07:08 <albeit> Oh, well then ;)
08:07:13 <t7> less code
08:08:04 <byorgey> t7: I don't know, it looks pretty good to me.  I might try to do it without explicit recursion, using things like iterate and takeWhile
08:08:21 <byorgey> but that probably wouldn't make it any shorter, just more modular/easier to understand/less prone to bugs
08:08:35 <t7> i don't like how many variables i am passing around
08:09:31 <Guest95714> I was wondering if anyone could help me get a type signature right for the exercism.io problem word-count. This lpaste contains the error message and the test suite: http://lpaste.net/105129
08:09:32 <t7> I didn't know if i could use less as i only need 1 part the three typically returned results
08:11:01 <Yuu_chan> albeit: lens can be useful if you update many fields of a record in a State, with some complicated rules
08:11:29 <albeit> Guest95714: It looks like you have to call fromList after calling wordCount, as @=? is expecting a Map not an alist
08:14:33 <Guest95714> <albeit> thanks, I'll look into the correct type signature now.
08:15:51 <Seleste18>  You can find funny videos here. http://bit.ly/1i6c7Cv
08:18:06 <mightybyte> Wow, this is really cool.  https://news.ycombinator.com/item?id=7852296
08:18:12 <Guest95714> @albeit the type signature was "wordCount :: String -> Map [Char] Integer". thanks, that was the first time that I've actually used maps in haskell
08:18:13 <lambdabot> Unknown command, try @list
08:20:03 * hackagebot diagrams-haddock 0.2.2.10 - Preprocessor for embedding diagrams in Haddock documentation  http://hackage.haskell.org/package/diagrams-haddock-0.2.2.10 (BrentYorgey)
08:21:19 <Guest95714> albeit: the type signature was "wordCount :: String -> Map [Char] Integer". thanks, that was the first time that I've actually used maps in haskell
08:23:12 <byorgey> mightybyte: neat!
08:23:35 <mightybyte> byorgey: Yeah, reminds me of diagrams...just in a different domain.
08:23:54 <byorgey> mightybyte: http://hackage.haskell.org/package/music%2Dgraphics =D
08:24:14 <byorgey> two great tastes that taste great together
08:25:03 * hackagebot marmalade-upload 0.8 - Upload packages to Marmalade  http://hackage.haskell.org/package/marmalade-upload-0.8 (lunaryorn)
08:25:30 * byorgey schemes to use music-suite lilypond output + HaTeX to embed music described with Haskell in LaTeX documents
08:25:37 <mightybyte> byorgey: Ooh, very nice.
08:26:04 <mightybyte> Now you don't have to be Bach to play around with all kinds of cool mathematical patterns in music!
08:26:23 <byorgey> maybe next time I give a concert and write up some program notes
08:28:22 <dfranke> byorgey: that sounds awesome.
08:29:29 <dfranke> byorgey: mainly because it would be really nice to have a higher-level language for writing music, which "compiles" to MIDI or standard musical notation.
08:29:39 <byorgey> yep
08:29:49 <dfranke> byorgey: |: :| and "a coda" are really crappy control structures :-)
08:30:04 * hackagebot marmalade-upload 0.8.1 - Upload packages to Marmalade  http://hackage.haskell.org/package/marmalade-upload-0.8.1 (lunaryorn)
08:30:22 <byorgey> I mean, we've had haskore and now euterpea for a while too
08:30:42 <byorgey> not sure yet what the differences in emphasis are
08:31:51 <Algebr> Given the new bug found in SSL, I was wondering, since ghc statically links the RTS and everything needed to make a haskell exectuable work out on its own, then its it possible in princicple that stuff like SSL could have been implemented in Haskell, correct?
08:34:02 <ibotty> Algebr: look into cryptol. and maybe (different piece of cake) into ats: http://bluishcoder.co.nz/2014/04/11/preventing-heartbleed-bugs-with-safe-languages.html
08:35:04 * hackagebot vinyl 0.4.1 - Extensible Records  http://hackage.haskell.org/package/vinyl-0.4.1 (JonSterling)
08:35:06 * hackagebot linux-xattr 0.1.1.0 - Read, set and list extended attributes  http://hackage.haskell.org/package/linux-xattr-0.1.1.0 (NicolaSquartini)
08:35:25 <nclarke> Ooh, new Vinyl
08:35:48 <dfranke> Algebr: there's already a native haskell implementation of TLS.
08:37:55 <Algebr> Does the haskell report allow for any undefined behavior?
08:37:56 <eflynn> how do you pronounce >>
08:37:58 <ReinH> Algebr: it has been done. an issue is that it's hard to mitigate side channel attacks
08:39:19 <dfranke> http://www.mitls.org is of interest here. It's a TLS implementation written in a dependently-typed extension of F#.
08:40:12 <dfranke> Several recent TLS protocol flaws have been discovered when the miTLS authors tried to prove something about their implementation, and discovered it to be false.
08:40:46 <Algebr> So OpenSSL just happens to be the main implementation of TLS, right?
08:40:57 <dfranke> yup. The one with the most eyeballs on it.
08:41:53 <nh2> rwbarton: that's some nasty things you found there in vector
08:41:53 <dfranke> (and static verification can make up for an awful lot of eyeballs, but there's a limit)
08:44:23 <dfranke> (n.b., as a security researcher by day and type theory geek by night, this is a pet subject for me :-)
08:45:00 <Algebr> dfranke: I notice that most infosec tools are either done in C or Python, have you written some haskell ones?
08:46:15 <dfranke> Algebr: I've written some pieces of what's intended to be a Haskell framework for writing fuzzers.
08:46:31 <dfranke> Algebr: but it's incomplete and I haven't had time to work on it in nearly a year.
08:46:57 <ibotty> dfranke: anything public. it's something i am very interested in as well
08:47:04 <ibotty> ?
08:47:14 <dfranke> no, nothing public, sorry.
08:48:12 <dfranke> most of the work I do these days isn't executable; I do protocol verification and model-checking, using things like Proverif and Alloy.
08:48:45 <byorgey> eflynn: I like to pronounce it "and then"
08:48:52 <hexagoxel> eflynn: http://stackoverflow.com/questions/7746894/are-there-pronounceable-names-for-common-haskell-operators/7747115#7747115
08:49:02 <eflynn> byorgey: yeah i googled it and it said â€œthen"
08:49:14 <rwbarton> nh2, found some more integer overflows in array and bytestring and text and ghc itself too :)
08:52:21 <Algebr> So is it fair to say that everything in a Haskell program is either well-defined or won't compile?
08:52:22 <eyebloom> Lets say I have a function f :: a -> Word8 and Iâ€™d like the function to convert an a to a word 8 using the most significant part of the a type like for example f x::Word16 = fromIntegral (x/256), f x::Word32 = fromIntegral (x/65536). Is there a standard typeclass such that I can define f :: Mystery a => a -> Word8 ?
08:52:53 <bennofs> Algebr: there is still stuff like undefined or error or let x = x in x
08:53:47 <glguy> undefined is defined to produce an exception when evaluated, it doesn't just take on an undefined value
08:55:07 <Algebr> bennofs: but I mean stuff like indexing into a C array out of bounds is undefined behavior, such things don't exist in a Haskell exectuable correct? ghc wouldn't allow that stuff?
08:55:07 * hackagebot BlogLiterately-diagrams 0.1.4.3 - Include images in blog posts with inline diagrams code  http://hackage.haskell.org/package/BlogLiterately-diagrams-0.1.4.3 (BrentYorgey)
08:55:09 * hackagebot mysql-effect 0.2.0.3 - An extensible mysql effect using extensible-effects and mysql-simple  http://hackage.haskell.org/package/mysql-effect-0.2.0.3 (ibotty)
08:55:24 <glguy> Algebr: You can index off the end of a pointer using Haskell's FFI
08:55:58 <glguy> You can use unsafe indexing operations to do the same off arrays
08:56:12 <bennofs> Is there a way to have cabal check for files not listed in other-modules or similar but required for compilation?
09:00:07 * hackagebot adjunctions 4.1.0.1 - Adjunctions and representable functors  http://hackage.haskell.org/package/adjunctions-4.1.0.1 (EdwardKmett)
09:00:09 * hackagebot linear 1.10.1.2 - Linear Algebra  http://hackage.haskell.org/package/linear-1.10.1.2 (EdwardKmett)
09:01:10 <nh2> bennofs: what do you mean, what shall it check?
09:01:40 <nh2> glguy, Algebr: or using unititialised memory, like ST vectors allow ;)
09:02:01 <bennofs> nh2: for example, I've forgotten to add a file to other-modules, so it isn't put into the sdist and thus the package fails to build
09:02:36 <adas> im using haskeline and am unable to get history to work. I have 2 consecutive 'getInputLine' statements and am not able to tab complete on the second 'getInputLine' statement
09:03:09 <eacameron> what is something called that can be transformed A -> B and B -> A, like serialization/deserialization
09:03:26 <adas> eacameron: marshalling/unmarshalling?
09:03:45 <eacameron> adas: yes, but what is the thing called that describes both relationships as a whole?
09:04:34 <eacameron> Marshaller?
09:04:41 <dfranke> eacameron: what specific relationship between the two functions (A -> B) and (B -> A) are you implying?
09:05:08 * hackagebot Hclip 3.0.0.1 - A small cross-platform library for reading and modifying the system clipboard.  http://hackage.haskell.org/package/Hclip-3.0.0.1 (JensThomas)
09:05:24 <eacameron> only that there exist functions F and F' that can do such a conversion, nothing more
09:05:46 <adas> dfranke: i think he's talking about converting between haskell types and data external to haskell and vice versa
09:05:47 <dfranke> so, F . F' = id and F' . F = id?
09:05:56 <eacameron> yes
09:06:21 <adas> associative?
09:06:21 <dfranke> eacameron: then the pair of functions are a bijection, and you can say that A and B are isomorphic.
09:06:38 <eacameron> I thought Isomorphic was more about shapes??
09:06:41 <adas> geese im  wrong
09:06:44 * Algebr thinks was disconnected...not sure if last message went through
09:07:23 <dfranke> eacameron: but, this is only true if your deserialization function is total; that is, every B corresponds to a valid A.
09:08:01 <dfranke> so, if you're say, serializing an Int by printing its decimal representation, that's not a bijection.
09:08:17 <eacameron> why not?
09:08:17 <dfranke> because there are strings that you can't parse as Ints.
09:08:27 <eacameron> oh, in terms of the String type
09:08:28 <eacameron> yes
09:09:10 <dfranke> but, you still have one of the two equations: read . show = id
09:09:15 <eacameron> but assuming that your types A -> B are constrained exactly by f and f', it's isomorphic?
09:09:41 <dfranke> so in that case, you can say that read is a left inverse of show.
09:09:45 <eacameron> *that your types A and B
09:09:57 <eacameron> left inverse?
09:10:04 <dfranke> eacameron: right. There must be exactly one A for every B, and exactly one B for every A.
09:10:08 * hackagebot matrix 0.3.2.0 - A native implementation of matrix operations.  http://hackage.haskell.org/package/matrix-0.3.2.0 (DanielDiaz)
09:10:09 <nclarke> Isomorphism generally involves more structure
09:10:38 <nclarke> I would say they are in bijection
09:11:40 <nclarke> (I suppose you could say it's a set isomorphism, but that's pretty unusual)
09:13:18 <dfranke> eacameron: what nclarke is getting at is that you often qualify the word "isomorphic" by further specifying some additional operations that are preserved.
09:13:21 <Algebr> I don't understand how over the span of 40 years no standard library for data structures emerged for C.
09:13:46 <chirpsalot> Algebr: probably because there are several :).
09:13:47 <eacameron> dfranke: I see
09:14:01 <Algebr> chirpsalot: Which ones? I've just heard of glib.
09:14:29 <nclarke> klib
09:14:46 <chirpsalot> Algebr: I mean there are probably a bunch, so each one has been rolled for a different project...
09:15:09 <chirpsalot> Algebr: so there's kind of too much to choose from and all stagnate as a result and people just continue to roll their own?
09:15:15 <chirpsalot> That's the impression I get, anyway.
09:15:58 <Algebr> Seems like a massive waste of duplicated effort.
09:16:08 <chirpsalot> Algebr: oh, it totally is!
09:16:26 <Yuu_chan> Real mean write their own data structures for each project.
09:16:29 <chirpsalot> Whenever I need a linked list in C... I just write my own.
09:16:31 <Yuu_chan> *Real men
09:16:42 <Maior> Yuu_chan: please don't do that
09:16:51 <chirpsalot> It's kind of just what the culture is with C, I guess?
09:17:17 <Yuu_chan> Maior: do what?
09:17:23 <Maior> Yuu_chan: "real men"
09:17:39 <pjdelport> Yuu_chan: real mean men? :)
09:17:46 <Yuu_chan> Are those kind of jokes banned?..
09:17:54 <dfranke> eacameron: for example, if A and B are semigroups (and I'll use + for the semigroup operation because I can't remember what ekmett uses in the semigroup package), then f and g are an isomorphism of semigroups if forall x,y : A, f(x + y) = f(x) + f(y), and forall x,y : B, f'(x + y) = f'(x) + f'(y).
09:18:05 <Maior> Yuu_chan: pass; I wasn't aware of any form of "ban list"
09:18:06 <yitz> dfranke: <>
09:18:07 <edwardk> <>
09:19:31 <yitz> dfranke: and f is an isomorphism of sets
09:19:49 <nclarke> Yuu_chan: I doubt they're banned, but those kind of comments help perpetuate the idea of programming as a "man's game", and thus tend to (probably unintentionally) exclude others from the community
09:20:01 <Maior> nclarke: thanks, was trying to word that
09:20:44 <Yuu_chan> My bad.
09:21:12 <lwm> nclarke: Yuu_chan: while off topic, this is really interesting as to whether that age old classic programming joke is now sexist
09:21:14 <yitz> Maior, nclarke: we definitely are trying very hard in our community to be sensitive to those kinds of issues
09:21:15 <dfranke> in this case, we already have the appropriate established connotation from the term "Real Programmers", which happens to be gender-neutral :-)
09:21:16 <vanila> how you make a linked list in haskell:  data L a = N | C a (L a)
09:21:34 <vanila> how you make a linked list in C: .... 1000 lines specific to a single data type.. >300 bugs
09:21:53 <chirpsalot> vanila: or void* :P
09:22:00 <vanila> tru!
09:22:10 <chirpsalot> vanila: in that case >1000 bugs :)
09:22:14 <vanila> haha
09:22:25 * chirpsalot is a C programmer.
09:22:33 <chirpsalot> It's so invigorating to get this off my chest :P.
09:22:45 <vanila> yea same :)
09:22:58 <nclarke> yitz, Maior: Yeah, I was made very happy the other week when an offhand comment about homosexuality was picked up on immediately. It made me proud to be part of a community which is deliberately trying to be inclusive
09:23:06 <chirpsalot> vanila: Algebr this is actually probably another reason why standard libraries for structures don't exist. Generic ones are... Not really well supported by the language.
09:23:13 <yitz> however in this case, i don't think it was so problematic. it was a criticism of traditional male "macho" behavior, which is one of the big reasons why previous lack of gender inclusiveness was a serious drag on quality in the software industry.
09:23:43 <chirpsalot> vanila: although, to be fair the actual C structure definition is only a few lines ;)
09:24:54 <chirpsalot> vanila: just if you want, like, to access it... Or manipulate it... And god forbid if you want map :).
09:25:19 <vanila> haha
09:25:22 <vanila> it's crazy
09:25:24 <yitz> chirpsalot: well, you need to include all of the memory management infrastructure, too.
09:25:41 <nclarke> yitz: Quite possibly. But then, as dfranke says, there is a perfectly valid non-gendered alternative, so we might as well use it :-)
09:26:45 <dfranke> You can write 'map' in C easily enough, with function pointers. You're just going to have a lot of (void*)s flying around.
09:27:08 <nclarke> I did try to implement closures in C a few months ago
09:27:39 <geekosaur> apple already did ("blocks")
09:27:47 <dfranke> GNU C even has nested functions, which aren't really closures but can do some of what closures can do.
09:27:56 <nclarke> Sticking a magic byte in, then grabbing the function pointer and rewriting function memory to insert a pointer
09:28:21 <nclarke> Nested functions are nice, but they don't really offer what closures do (namely, an abstraction technique)
09:28:22 <yitz> nclarke: and this passes security audits?
09:28:25 <Yuu_chan> nclarke: my joke was a relation to http://www.dtf.ru/blog/read.php?id=43360
09:28:28 <nclarke> yitz: Alas, no
09:30:05 <yitz> nclarke: you can make it even more efficient by overwriting machine instructions.
09:31:06 <nclarke> yitz: Would I not need to care about size, there? The benefit of this is that I can overwrite precisely one address
09:31:23 <kini> is there some better way to write "foo $ return . bar <$> baz" (e.g. without that "return .")?
09:32:18 <warpy> hlint it
09:32:33 <Yuu_chan> kini: what are signatures of foo and bar?
09:32:40 <yitz> @type \foo bar baz -> foo $ return . bar <$> baz
09:32:41 <lambdabot> (Functor f, Monad m) => (f (m b) -> t) -> (a -> b) -> f a -> t
09:33:00 <dfranke> geekosaur: I'm not a Mac guy so I've never heard of these 'blocks' before. They sound like LLVM's 'trampoline' intrinsic, though. I'm guessing they're based on that?
09:33:26 <yitz> kini: that's a pretty complicated type. i doubt there is anything simpler.
09:34:02 <yitz> kini: except perhaps foo . fmap (return . bar) $ baz, if you like that better.
09:34:10 <jle`> kini: is the Functor instance and the Monad instance the same?
09:34:21 <jle`> for return and <$>
09:34:27 <kini> yeah it's all Maybe
09:34:35 <geekosaur> dfranke, http://en.wikipedia.org/wiki/Blocks_(C_language_extension) they predate apple's involvement with llvm
09:34:47 <yitz> kini: so you want a Maybe (Maybe a) ?
09:34:52 <jle`> why would you want a Maybe Maybe?
09:34:55 <rwbarton> is there any way to get ghci to show me the instances of a type family?
09:35:06 <kini> no, baz produces Maybe a, bar is a -> a, foo requires a Maybe a
09:35:12 <chirpsalot> dfranke: oh, you can definitely write 'map', but it's kind of gross and not as useful because you don't have partial application (at least not without some effort and extra grossness).
09:35:30 <rwbarton>  :info doesn't do it
09:35:52 <jle`> kini: bar <$> baz is already Maybe a
09:36:00 <Yuu_chan> kini: I suppose foo $ bar <$> baz
09:36:16 <jle`> or i would probably do
09:36:17 <kini> huh, what? wait, lemme look at this again...
09:36:30 <Yuu_chan> Or, if you like returns, foo $ return . bar =<< baz
09:36:36 <jle`> foo . bar =<< baz
09:37:09 <jle`> er wait no
09:37:09 <rwbarton> that one is different
09:37:19 <jle`> yeah, sorrt
09:37:22 <jle`> sorry
09:37:32 <pranz1> in the windows installation of the haskell platform, where is the cabal executable?
09:38:28 <jle`> > (+3) <$> Just 4
09:38:30 <lambdabot>  Just 7
09:38:57 <Yuu_chan> pranz1: Users/username/AppData/Roaming/cabal/bin
09:39:10 <jle`> > maybeToList $ (+3) <$> Just 4
09:39:12 <lambdabot>  [7]
09:54:40 <hth313_> Why do I get: Could not deduce (MonadIO (InputT IO)) arising from a use of â€˜liftIOâ€™ ? This used to work, but not with ghc 7.8.2 and haskeline 0.7.1.2. InputT is an instance of MonadIO.
09:57:09 <coppro> hth313_: can you get a minimal testcase?
09:57:31 <coppro> hth313_: the only thing I can think of is if S.C.H.InputT is not imported
10:00:30 <adas> how can i enable tab completion in haskeline?
10:03:55 <hth313_> coppro: module Main where
10:03:56 <hth313_> import System.Console.Haskeline
10:03:56 <hth313_> import Control.Monad.Trans.State
10:03:56 <hth313_> import Control.Monad.IO.Class
10:03:56 <hth313_> foo :: StateT a (InputT IO) ()
10:03:56 <hth313_> foo = liftIO $ putStrLn "Help"
10:04:06 <coppro> hth313_: import System.Console.Haskeline.InputT
10:04:52 <hth313_> coppro: not allowed, it is a hidden module, cabal complains
10:05:29 <hth313_> coppro: actually, it is ghc that complains
10:07:05 <hth313_> coppro: I meant to say it is hidden in the haskeline cabal package, InputT without anything extra is exported, but instances are always exported, so they should also be available
10:08:26 <rwbarton> works for me (ghc 7.8.1, haskeline 0.7.1.2)
10:08:34 <rwbarton> maybe you have a different version of transformers or something?
10:10:10 <hth313_> transformers 0.4.1.0
10:10:46 <rwbarton> aha that broke it somehow
10:10:52 <rwbarton> how odd
10:11:02 <hth313_> it failed for you now?
10:11:06 <rwbarton> yep
10:11:12 <hth313_> wow
10:11:14 <rwbarton> it had worked with transformers 0.3.0.0 which came with ghc
10:11:52 <benbangert> don't suppose anyone knows if the haskell tls lib is vulnerable to any of the recent openssl type bugs?
10:12:16 <rwbarton> hth313_: oh
10:12:27 <rwbarton> I bet your haskeline is built against transformers 0.3.0.0
10:12:45 <nclarke> benbangert: I doubt it's vulnerable to those particular bugs. May be vulnerable to others
10:12:49 <rwbarton> so it only has an instance transformers-0.3.0.0-MonadIO (InputT IO)
10:13:08 <geekosaur> benbangert, it's a native implementation, so it likely has its own issues instead of the known ones
10:13:16 <bennofs> What does this warning mean? (only on 7.8): "Name prop_word8 found in source file but was not in scope"
10:13:32 <benbangert> geekosaur: yea, thats what I was wondering, whether its been audited, how recently, etc.
10:14:54 <hth313_> rwbarton: thanks! I downgraded and now it works. Still think I should have gotten some more meaningful error message.. :)
10:15:16 <rwbarton> it would be nice...
10:15:34 <rwbarton> if you use cabal for your project then it will make sure automatically that you are using consistent versions of everything
10:15:40 <chirpsalot> let x = 4 in (sqrt x, 10 `div` x) is allowed in ghci?
10:16:06 <jfischoff> benbangert: side channel attacks are perhaps a bigger vulnerablility in theory, but I donâ€™t expect to see one in a wild
10:16:29 <geekosaur> normally it would include a version number to disambiguate (and presence of that version is generally a red flag) but there are cases where implicit imports of classes slip through the cracks like that. (had real fun debugging that kind of issue in someone's xmonad install)
10:16:41 <geekosaur> (was later told that "couldn't happen" but here it is again...)
10:17:24 <hth313_> rwbarton: I build with cabal, but often build individual modules inside Emacs.
10:17:42 <rwbarton> yeah the problem is here ghci loaded the new transformers for some reason
10:18:04 <rwbarton> hth313_: ah yeah
10:19:47 <rwbarton> bennofs: it's produced by quickcheck
10:21:36 <rwbarton> chirpsalot: as of 7.8, due to NoMonomorphismRestriction by default in ghci
10:22:35 <adas> nevermind. figured it out.
10:22:37 <chirpsalot> rwbarton: OH. I might have that turned on, hence my confusion.
10:25:46 <Aeryn18>  Hi! I give you some videos. I hope you like! http://bit.ly/1onFoxd
10:28:28 <bennofs> rwbarton: what does it mean?
10:29:39 <bennofs> rwbarton: and how can I avoid it? Btw, this warning appears in [2 of 2] Compiling Main             ( tests/Main.hs, dist/build/tests/tests-tmp/Main.o )
10:33:49 <bennofs> rwbarton: can TH code produce warnings?
10:40:40 <stephenjudkins> given an expression of type a, what's the easiest way, in a single expression, to call `return` to create `IO a`?
10:40:59 <rwbarton> bennofs: yes I think it can
10:41:33 <bennofs> rwbarton: ah, I found the place in quickcheck. Do you have any idea what causes this warning? It only appears with GHC 7.8
10:42:45 <Eduard_Munteanu> stephenjudkins: return (foo bar baz)?
10:42:53 <rwbarton> no idea. I just looked to verify that it wasn't being produced by ghc :)
10:43:26 <rwbarton> er, *I just looked hard enough to
10:43:43 <bennofs> yeah, I git grep'ed GHC for the message, but didn't find it _=
10:43:43 <dwcook> stephenjudkins: that's trivial, really. return :: a -> IO a, so if you have x :: a, then return x :: IO a
10:45:47 <asmyers> > let f x = (return :: a -> IO a) x
10:45:49 <lambdabot>  not an expression: â€˜let f x = (return :: a -> IO a) xâ€™
10:46:15 <chrisdone_> > undefined :: IO ()
10:46:17 <lambdabot>  <IO ()>
10:46:40 <stephenjudkins> dwcook: perfect. just looking for the right syntax. don't fully understand how typeclasses work.
10:48:00 <dwcook> stephenjudkins: (Monad m) => a -> m a lets you choose an m such that an instance Monad m exists. There is an instance Monad IO, so you can choose m = IO.
10:48:18 <dwcook> Which means return :: (Monad m) => a -> m a can be specialized to a -> IO a.
10:49:11 <dwcook> stephenjudkins: the (Monad m) bit is called a typeclass constraint, if that helps you find the information you want.
10:49:14 <stephenjudkins> dwcook: right. adding the type ascription (?) on the right tells ghc you want the IO monad, that's what I was missing
10:49:29 <dwcook> stephenjudkins: in many cases you don't even need the type annotation.
10:49:44 <dwcook> main = return () -- IO is implied because main must have an IO type
10:49:51 <stephenjudkins> dwcook: yes, i imagine it can infer that
10:50:24 <chrisdone> stephenjudkins: it's called a type signature
10:50:47 * chrisdone pounces on Baughn lazily
10:52:01 <bitemyapp> stephenjudkins: ascription is a fun word.
10:52:26 <stephenjudkins> bitemyapp: i come from java land, sorry
10:52:35 <rwbarton> I think (expr :: t) is a type ascription
10:52:37 <bitemyapp> stephenjudkins: I think it'd be a pretty weird thing to say there too.
10:52:46 <bitemyapp> stephenjudkins: we're celebrating it though :)
10:53:00 * dwcook has never heard the word "ascription" used in the context of Haskell before.
10:53:11 <rwbarton> val :: t, as a declaration, is a type signature
10:53:31 <rwbarton> however I have no source for this so I might be making it up!
10:53:31 <dwcook> I tend to use "type signature" and "type annotation" interchangeably.
10:53:58 <bitemyapp> ascription has a notion of causality attached. I don't know if I'd roll that into it.
10:54:53 <stephenjudkins> bitemyapp: it's a real thing in java and scala. typically used as part of an arbitrary expression to say what type you expect. w/ subtyping, allows you to "upcast"
10:55:40 <rwbarton> what is the syntax in java?
10:56:07 <rwbarton> (T)(expr)?
10:56:26 <stephenjudkins> rwbarton: yes
10:56:31 <n-dolio> That is a cast.
10:56:38 <n-dolio> Not an ascription.
10:56:47 <rwbarton> yeah
10:56:54 <rwbarton> so maybe I've just added to the confusion
10:56:59 <stephenjudkins> n-dolio: in scala, it's (expr: T)
10:57:02 <stephenjudkins> that's an ascription
10:57:08 <n-dolio> Yes.
10:57:13 <stephenjudkins> not a cast
10:57:14 <n-dolio> Java doesn't have that kind of thing.
10:57:22 <n-dolio> As far as I know.
10:57:29 <stephenjudkins> yes
10:58:53 <enthropy> is haskell-type-exts usable for people?
10:59:14 <chrisdone> i don't think it's ready yet for use with fay
10:59:23 <bennofs> enthropy: i think it consists of just an error call, or has that changed?
10:59:37 <enthropy> am I off in saying that it doesn't export the actual AST that represents the typechecked values?
10:59:45 <enthropy> https://hackage.haskell.org/package/haskell-type-exts-0.1.0/docs/Language-Haskell-TypeCheck-TypeCheck.html
10:59:54 <chrisdone> i believe it's supposed to re-use HSE, like haskell-names does
11:00:02 <enthropy> bennofs: no there is code from "typing-haskell-in-haskell" in there
11:00:04 <shergill> any references to understand mu and nu from https://en.wikibooks.org/wiki/Haskell/Fix_and_recursion better?
11:00:07 <chrisdone> you give it an HSE AST, it gives you one back with annotations
11:00:14 <bitemyapp> if I never compiled haskell-src-exts ever again, I would be *so* happy.
11:00:36 <chrisdone> oh, it differs to haskell-names
11:00:59 <bennofs> enthropy: oh, what I remembered was https://hackage.haskell.org/package/haskell-type-exts-0.1.0/docs/src/Language-Haskell-TypeCheck.html#typeCheck
11:01:08 <enthropy> by "typechecked values" I mean the type that gets inferred
11:01:42 <enthropy> alternatively, it is sensible to call the ghc-api from within template-haskell?
11:01:55 <chrisdone> worse things have been done =p
11:02:14 <chrisdone> you need to type-check code from TH?
11:03:04 <chrisdone> TH itself has inspection capabilities which might be usable just by themselves, depending on your use-case
11:04:49 <enthropy> http://lpaste.net/105134 is my use-case
11:04:56 <enthropy> doesn't seem like I can get reify to help
11:06:43 <enthropy> so the fun quasiquote should have the same imports as the larger module
11:08:11 <davean> The GHC RTS supports the -S option, showing a line per garbage collection - is there the ability to have that for specific generations only? Or more specificly anything but 0?
11:08:36 <nh2> bennofs: that's https://github.com/haskell/cabal/pull/1455
11:10:09 <nh2> bennofs: in other words: No, cabal doesn't have such a check, and the plan is to change ghc --make so that cabal can implement such a check
11:11:00 <bennofs> nh2: thanks. For now, I just changed my travis script to build from the source dist instead of building directly
11:11:20 <nh2> bennofs: how did you do that?
11:11:38 <nh2> does anybody know how the type of diagram is called that criterion uses? The one with the many dots
11:11:57 <bennofs> nh2: cabal dist && cabal install path/to/sdist --enable-tests --enable-benchmarks
11:12:21 <nh2> bennofs: ah, I forget again and again that cabal can install tars
11:16:48 <albeit> If inside a monadic computation on object Foo {_bar :: Int, _baz :: Int}, is there an easy way to load the value of one field into another? Right now its just "bar <- gets _bar; baz .= bar"...
11:16:55 <albeit> (Oh, using lenses)
11:22:34 <supki> baz <~ use bar
11:26:28 <albeit> supki: oh cool, thanks
11:27:37 <albeit> Is there an easy way to search lens for specific functions to do certain things?
11:27:49 <edwardk> albeit: asking on #haskell-lens mostly ;)
11:28:18 <albeit> edwardk: Alright then, new channel to idle
11:28:40 <edwardk> asking on #haskell also works ;)
11:28:44 <edwardk> gotta run
11:29:49 <aspidites> cabal update taking a while for anyone else? last time i updated was about a week ago but this seems like its taking forever
11:31:33 <warpy> aspidites: ctrl c, try again
11:31:41 <aspidites> i've done that twice warpy
11:31:58 <warpy> ok, let me run it
11:32:24 <warpy> done in 30 secs
11:32:52 <warpy> aspidites: maybe your internet is borked
11:33:10 <aspidites> if my internet were broken, I wouldn't be able to chat here
11:33:55 <warpy> maybe your ISP is censoring hackage
11:34:08 <aspidites> that makes no sense
11:34:16 <warpy> right.
11:34:19 <aspidites> plus i can browse hackage just fine from a browser
11:34:32 <warpy> sorry. i cant help you with this one.
11:34:56 <aspidites> the fact that you can download it helps
11:35:02 <aspidites> means something on my end is wrong some how
11:35:44 <aspidites> completely nuked my .cabal and .ghc -- still hangs. grrr
11:35:55 <aspidites> maybe someone over at *-beginner will know
11:36:08 <warpy> why dont you try to wget the package directly
11:36:21 <geekosaur> [05 18:31] <aspidites> if my internet were broken, I wouldn't be able to chat here
11:36:29 <geekosaur> note that a DNS issue would not impact existing connections
11:36:51 <benzrf> geekosaur++
11:37:06 <rwbarton> or you could just have high packet loss and not notice it in IRC
11:37:19 <warpy> aspidites: wget http://hackage.haskell.org/packages/index.tar.gz
11:37:23 <warpy> see if it works
11:37:24 <geekosaur> indeed, I get that quite a  lot (crap local network --- which is why I hide behind a znc)
11:37:53 <aspidites> there we go, i tried that in a browser but had the last bit wrong
11:38:11 <aspidites> oh wow. my pings are a bit ridiculous
11:38:14 <aspidites> 52.7ms
11:38:17 <geekosaur> pw
11:38:18 <geekosaur> ow
11:38:31 <blikken> Hi, I have a Writer monad, and I'd like to get the contents out (a string), and print the result in the IO monad. How can I do that?
11:38:37 <geekosaur> although 52.7 is fast compared to what I often see around here >.>
11:38:45 <aspidites> i'm usually sub 20
11:38:46 <geekosaur> (6-10s delays are not uncommon when the network is loaded)
11:38:52 <geekosaur> (yes seconds not ms)
11:39:01 <aspidites> geekosaur: wow
11:39:13 <aspidites> i'll restart my router etc then start digging through config files
11:39:31 <rwbarton> so is the wget also stalling?
11:39:36 <aspidites> and modem
11:39:47 <aspidites> rwbarton: stalling, no. painfully slow. yes
11:39:56 <rwbarton> ah
11:40:02 <aspidites> or so it feels like it. i was getting 39KB/s
11:40:08 <geekosaur> also that, browsers typically do proxy auto config, neither wget nor cabal would be able to do that, you'd need to specify a proxy explicitly
11:40:18 <warpy> my ping ois 150ms :O
11:40:28 <aspidites> i don't use a proxy
11:40:59 <geekosaur> also not impossible (but not very common) on some networks that browsers autoconfig and get a fast path, other things get routed through a slow transparent proxy
11:41:00 <kazagistar> :t execWriter --blikken
11:41:01 <lambdabot> Writer w a -> w
11:41:14 <warpy> 'cuz other side of planet. can local replicas of hackage be set up?
11:41:24 <blikken> kazagistar: cool, thanks, just what I need
11:41:30 <warpy> like local mirrors of debian repos
11:42:01 <bennofs> warpy: http://github.com/haskell/hackage-server that has a mirror function, though I haven't used it yet
11:43:47 <warpy> bennofs: that sounds great. wonder if i should get a vps in singapore and run a hackage mirror
11:43:58 <blikken> kazagistar: so I assume you can "escape" most monads like this, is the IO monad the only one that cannot be "escaped" from -- in the sense that you can "force" the whole thing at an arbitrary point?
11:44:41 <geekosaur> not the only one
11:45:03 <geekosaur> ST and STM also prevent "escape"
11:45:22 <blikken> Ah, ok
11:45:32 <aspidites> well points to warpy for correctness with bonus points to geekosaur et al for clarity
11:45:41 <blikken> So if I were using them, how would I "execute" them from main? WOuld I return a IO (STM ...) ?
11:45:52 <aspidites> does cabal update diff the update files before download or download a new index every time?
11:45:56 <warpy> aspidites: ++ gives points :)
11:45:59 <geekosaur> STM provides a run function (atomically) whose result is in IO
11:46:02 <bennofs> blikken: also, to get "contents" out of a Reader monad, you need to supply an argument
11:46:13 <warpy> aspidites: i think it gets the whole stuff
11:46:14 <blikken> geekosaur: ah, that makes sense
11:46:29 <geekosaur> ST, you run a computation with runST and the types prevent anything inside the ST that isn't pure from leaking out
11:46:43 <aspidites> actually. not completely solved
11:46:51 <bennofs> blikken: if you don't have the argument for the Reader, you cannot get "contents out"
11:46:51 <geekosaur> so it actually has a run function but with limits on what it permits
11:47:01 <aspidites> after restating my network i was able to wget at 1.16MB/s
11:47:08 <aspidites> cabal update still taking forever
11:47:18 <blikken> bennofs: interesting, I'll read more about that. I'm currently just using the Writer monad
11:47:38 <Baughn> chrisdone: Wut?
11:47:39 <aspidites> i suppose i could jsut copy that file, but i'd like things to work as intended
11:47:49 <geekosaur> aspidites, I think I'd be poking at tcpdump/wireshark at that point
11:48:26 <bennofs> aspidites: cabal update always takes forever :) I have 20MB/s downstream, and cabal update takes ~11s. Most of the time is spent unpacking the archive though I think
11:48:47 <geekosaur> possibly try strace (/truss/ktrace/ktruss/dtruss/whatever on your platform; there is some kind of truss mechanism available for some windows versions, last I checked)
11:49:12 <aspidites> bennofs: this seems abnormal though. unless haskell suddenly got popular, and thus had a large intake of packages
11:49:32 <rwbarton> what version of cabal?
11:49:32 <aspidites> i started cabal update as soon as i got done rebooting the network. i was able to wget the index twice and it's still not done
11:49:44 <aspidites> 1.20.0.0
11:49:50 <rwbarton> I think some older versions were super duper slow at unpacking instead of just regular slow
11:49:53 <rwbarton> ah, okay not the problem then
11:50:09 <aspidites> geekosaur: neither of those installed, and don't know how to use them. pacman + man time i guess
11:50:29 <aspidites> heard of them. just never used them
11:50:55 <aspidites> ok, it finally finished
11:51:12 <aspidites> i'm still a sad panda though
11:54:47 <bitemyapp> aspidites: what sort of machine was it running on?
11:55:58 <aspidites> 64bit arch linux, intel i7-3630QM, nvidia gtx 670MX
11:56:09 <aspidites> 8gb ram, 8gb swap
11:56:22 <chrisdone> you could almost run emacs on that
11:56:44 <aspidites> chrisdone: lol. maybe thats why i run vim ;-)
11:57:19 <aspidites> i'm not sure why my swap is 8gb though, i thought i set it to 4 or 2. i'd go with no swap, but i kept running into issues related to swappiness
11:58:17 <aspidites> if i remember i guess i could fix that the next time i reboot.
11:59:27 <aspidites> bitemyapp: did i miss anything in particular you were looking for?
12:00:08 <teknokratsevilla> what ?
12:00:24 <aspidites> oh running through an almond router connected via wifi to a centrino advanced-n 6230 on one end and a arris modem on the other
12:00:28 <teknokratsevilla> you are using more than 8gb ? are you running a huge java server ?
12:00:56 <bitemyapp> teknokratsevilla: never built GHC I take it?
12:01:06 <bitemyapp>  ;P
12:01:12 <teknokratsevilla> no, does it take 8gb? really ?
12:01:20 <bitemyapp> it's not that bad, no
12:01:24 <bitemyapp> but linking is pretty brutal.
12:02:29 <chrisdone> metal brutal?
12:02:35 <chrisdone> \m/
12:02:42 <blikken> I have the smallest possible code suing System.Eval.Haskell, and the resulting binary is 49M, how come it's so large?
12:03:05 <bitemyapp> chrisdone: it's nice to see you active on IRC btw.
12:03:35 <bennofs> What does  â€˜prop_storable_vectorâ€™ is not in the type environment at a reify
12:03:38 <chrisdone> bitemyapp: nice to be seen by you =)
12:03:38 <bennofs> mean?
12:03:46 <bennofs> (it's a GHC error)
12:05:14 <kazagistar> blikken: http://stackoverflow.com/questions/6115459/small-haskell-program-compiled-with-ghc-into-huge-binary
12:07:05 <blikken> kazagistar: ah, great, thanks!
12:07:13 <Suzie18>  You can find funny videos here. http://j.mp/1oZESbm
12:07:36 <bitemyapp> SegFaultAX: howdy.
12:07:48 <monochrom> @type trace
12:07:49 <lambdabot> Not in scope: â€˜traceâ€™
12:09:17 <SrPx> Is it easy to check if a reduction of a lambda calculus term to its normal form is correct?
12:13:05 <pavonia> SrPx: What do you mean by correct?
12:13:43 <bernalex> how do I make 0.5 /= 0.50?
12:14:18 <SrPx> pavonia: I give a lambda term to an oracle asking it for the normal form, it gives me an answer. I want to quickly check if that answer is correct. Possible?
12:14:20 <haasn> > let 0.5 /= 0.50 = True in 0.5 /= 0.50
12:14:22 <lambdabot>  True
12:14:28 <pavonia> bernalex: Use a string representation?
12:15:09 <bernalex> haasn: sounds not abstractable when you have a huge set of Doubles
12:15:12 <SrPx> I mean, faster than normalising by evaluation.
12:15:38 <albeit> Whenever I have a module that imports Control.Lens and I compile, it lists a bunch of "Loading package xyz .. linking .. done"... is there any way to disable those messages?
12:15:46 <bernalex> pavonia: what's a way to turn a Double into a string that makes 0.50 "0.50" instead of "0.5"?
12:16:10 <pavonia> > show 0.5 ++ "0"
12:16:12 <lambdabot>  "0.50"
12:16:16 <geekosaur> heh
12:16:22 <bernalex> pavonia: that's not very helpful
12:16:43 <pavonia> Maybe you could explain what you're trying to do
12:16:55 <geekosaur> Text.Printf, Numeric.show{,F,G}Float
12:16:57 <monochrom> I don't understand the question. what do "0.50" and "0.5" mean such that they are different?
12:17:03 <bernalex> I have numbers. numbers have different precision. 0.5 should not == 0.50.
12:17:17 <monochrom> what are their denotational semantics such that they are different?
12:17:28 <bernalex> monochrom: can you e.g. make dissimilar precision mean that there are different numbers?
12:17:29 <albeit> bernalex: printf "%.2f" x
12:17:35 <bernalex> albeit: hah, true
12:17:40 <michi7x7> hi all
12:17:43 <byorgey> bernalex: so you want to store numbers along with their precision?
12:17:54 <monochrom> ok, so design a number type that remembers precision. I have not seen one in common libs.
12:17:57 <bernalex> byorgey: I guess, yes.
12:18:05 <bernalex> monochrom: basically that's what I'd want
12:18:10 <haasn> The only sort of precision mangling I know is â€˜Fixedâ€™
12:18:17 <haasn> Which stores numbers to a fixed precision, given in the type system
12:18:18 <byorgey> there is also http://hackage.haskell.org/package/intervals
12:18:27 <byorgey> not exactly the same but similarish
12:18:34 <haasn> I wonder if what you want is an existential over this or something. I don't really know, or follow, or understand the requirements
12:18:39 <bernalex> byorgey: hm. that's an idea.
12:19:07 <monochrom> Fixed has the precision at the type level and inaccessible at the value level.
12:19:17 <bernalex> IC
12:23:03 <monochrom> ghc 7.6.3 -O2 is funny. I have a case of adding a "Show k" constraint increases speed by 5%
12:23:55 <sipa> phase of the moon
12:25:31 <monochrom> fortunately, it's just 5.8 seconds vs 6.2 seconds, no big deal
12:43:51 <sveit> one of my ffi functions takes a char pointer and returns a double, but haskell complains about ":: Ptr CChar -> IO CDouble", saying "unacceptable result type in foreign declaration"
12:43:59 <sveit> i have also tried Ptr CChar -> CDouble
12:44:04 <sveit> (since the function is really pure)
12:44:07 <sveit> but I get the same complain
12:44:09 <sveit> t
12:44:13 <albeit> Is there any data structure that is like a two-way map, if you know that all keys are unique, and all values are unique? So you could "key" by either the key or value
12:45:12 <hiptobecubic> albeit, yep. Two maps
12:45:55 <Enigmagic> sveit: can you put a small example up somewhere?
12:47:29 <glguy> sveit: That should work. Maybe you're using the wrong "CDouble"
12:47:38 <glguy> and not the one from Foreign.C.Types
12:48:04 <sveit> i can write it here: foreign import ccall unsafe "cfunction" c_cfunction :: Ptr CChar -> CDouble
12:48:22 <sveit> it shouldn't matter what "cfunction" looks like since I don't believe the haskell compiler checks taht?
12:48:49 <sveit> glguy: i have import Foreign.C.Types (CChar,CDouble)
12:48:59 <glguy> OK, that's the issue
12:49:03 <glguy> try:  CDouble(..)
12:49:10 <glguy> The constructor needs to be in scope
12:50:03 <sveit> glguy: ah, that fixed it. why does the the constructor need to be in scope?
12:50:05 <glguy> Also, if your Ptr CChar is supposed to be used as a null-terminated string, there is   Foreign.C.String.CString
12:50:16 <sveit> glguy: nope, it's fortran code :)
12:50:21 <glguy> sveit: So that the FFI can't be used to violate an abstraction
12:50:34 * hackagebot ty 0.1.6 - Typed type representations and equality proofs  http://hackage.haskell.org/package/ty-0.1.6 (ConalElliott)
12:50:55 <sveit> if i call unsafeperformIO, is that garuanteed to only be run once?
12:51:18 <|akh|> Hi. Using attoparsec, is there a more efficient way to parse any characters until a certain string, than e.g.: manyTill anyChar "\r\n" ?
12:51:30 <glguy> sveit: start reading here if you want more information https://ghc.haskell.org/trac/ghc/ticket/5529
12:52:08 <glguy> sveit: unsafePerformIO is documented https://www.haskell.org/ghc/docs/7.8.2/html/libraries/base-4.7.0.0/System-IO-Unsafe.html here
12:52:13 <glguy> and they discuss what guarantees you get
13:01:21 <sveit> thanks! one more question :) is there a way to tell haskell to unbox all primitive types it can in a pragma at the top of a file?
13:01:39 <bitemyapp> byorgey: could I have a moment of your time to talk to you about CIS194? I've been using it to teach people Haskell.
13:04:21 <rwbarton> sveit: {-# OPTIONS_GHC -funbox-strict-fields #-}
13:04:27 <rwbarton> default since 7.8 I think
13:04:38 <bitemyapp> @karma+ rwbarton
13:04:38 <lambdabot> rwbarton's karma raised to 25.
13:05:35 * hackagebot th-lift-instances 0.1.3 - Lift instances for template-haskell for common data types.  http://hackage.haskell.org/package/th-lift-instances-0.1.3 (BennoFuenfstueck)
13:06:01 <byorgey> bitemyapp: sure, PM?
13:06:39 <ajcoppa> i'm interested in reading the conversation if possible
13:07:36 <bitemyapp> byorgey: aye
13:07:53 <byorgey> ajcoppa: was that in reference to me and bitemyapp ?
13:08:06 <ajcoppa> yes
13:08:15 <bitemyapp> ajcoppa: it'll be insanely boring and might even be irrelevant to byorgey himself.
13:08:22 <ajcoppa> more out of curiosity than necessity though
13:08:23 <bitemyapp> it's content nitpicking.
13:08:42 <ajcoppa> okay, i probably don't have much to add then
13:09:22 <bitemyapp> ajcoppa: I've been soliciting feedback and observing as I've been teaching Haskell, I just want to smooth the way.
13:20:55 <abh> where can i get a list of packages with version which are to be included in next hp release?
13:24:12 <jle`> actually it would be interesting to make a numeric library that keeps track of precision
13:24:14 <jle`> and uncertainty
13:24:44 <jle`> you can give it a Num/Real/etc. instance so that you can use functions like exp, sin, (^), etc.
13:24:52 <jle`> and those will properly propagate the uncertainty
13:25:03 <jle`> hm.
13:25:12 <rwbarton> @hackage intervals
13:25:12 <lambdabot> http://hackage.haskell.org/package/intervals
13:25:45 <jle`> interval is different from statistical uncertainty i think
13:25:58 <rwbarton> oh yes, i see
13:26:31 <jle`> but that's still a neat library, i had forgotten about it
13:26:46 <jle`> i didn't notice earlier that it defined Num/Real instances
13:28:04 <Tjr> Memorizing the library functions is a task at first.
13:28:04 <Tjr> Anki is a spaced repetition app that's doing wonders for language learning.
13:28:04 <Tjr> Has anybody already created flashcard decks from the library documentation?
13:28:26 <albeit> @pl (\i j -> f <$> ((,) <$> g i <*> g j))
13:28:27 <lambdabot> (((f <$>) . ((,) <$>)) .) . (. g) . (<*>) . g
13:28:59 <albeit> Is there a "simplifier" bot?
13:29:06 <Tjr> I'm partly through Learn You a Haskell, turning the basic facts into flashcards. Is anybody interested?
13:29:38 <xunplini> Hello.
13:29:51 <xunplini> Tjr: I'd be interesting in having them, but too lazy to make them.
13:29:51 <parc> Is there a monad that would be well-suited for this type of problem? I've got a function which does a lot of web-based IO, many of which is error prone, so I want to be able to only perform a single 'step' of the function, and have intermediate results/errors saved to disk, so that later on I can manually look through errors or resume the computation.
13:29:55 <Eduard_Munteanu> Tjr: sounds like the Report of the Gentle Introduction may be better as references
13:30:03 <xunplini> According to a profiler my code is mostly spending time in this:
13:30:10 <parc> I could just use MaybeT IO, but I'm wondering if there's anything that already exists that handles the auto-saving/loading logic safely
13:30:14 <xunplini> getAt l i w = (shift w (0-i)) .&. (2^l - 1)
13:30:20 <xunplini> But I can't see how I can optimize that any further.
13:30:28 <Eduard_Munteanu> parc: sort of, there's Free / FreeT
13:31:28 <Eduard_Munteanu> parc: oh, hm... I don't know then.
13:31:32 <michi7x7> parc: you can always put a writer around that to track progress, but I don't think there is anything to do the tracking automatically
13:31:38 <mmmm> parc: http://devskypers.blogspot.fr/2014/02/logging-flow-activity.html
13:31:39 <Tjr> Eduard_Munteanu: you mean this thing? http://www.haskell.org/onlinereport/
13:31:46 <Eduard_Munteanu> Tjr: yes
13:31:49 <parc> ooh, i didn't think of Free. Maybe FreeT wrapping some sort of IO-based monad to handle the serialization
13:31:55 <bennofs> xunplini: maybe replace 2^l by 1 `shiftL` l ? Also, (0-i) = (-i)
13:32:01 <Eduard_Munteanu> @where report
13:32:02 <lambdabot> http://www.haskell.org/onlinereport/haskell2010/ (more: http://www.haskell.org/haskellwiki/Definition)
13:32:05 <bennofs> (idk if that is faster=
13:32:14 <Eduard_Munteanu> Tjr: actually that ^, it's newer
13:33:26 <Tjr> Eduard_Munteanu: oh god, that's a lot of stuff. Do you really know all that by heart?
13:33:41 <Eduard_Munteanu> Tjr: no :)
13:33:53 <Eduard_Munteanu> @where gentle
13:33:54 <lambdabot> http://www.haskell.org/tutorial/
13:34:14 <Tjr> xunplini: I've got learn you a haskell up to Data.List. I can give it to you if you tell me how :-)
13:34:20 <Eduard_Munteanu> Tjr: try this, it's more concrete and shorter: http://www.haskell.org/tutorial/
13:36:04 <Tjr> Eduard_Munteanu: do you know all that by heart?
13:36:08 <xunplini> bennofs: that made a huge difference, thanks.
13:36:38 <Eduard_Munteanu> Tjr: I tend not to do that generally, so no.
13:37:18 <Eduard_Munteanu> Tjr: is this how you approach learning these things, as opposed to just using them?
13:37:37 <Eduard_Munteanu> (I'm not saying it's not ok.)
13:38:10 <aspidites> is there an unobtrusive way to resolve duplicate instance declaration errors? -> http://lpaste.net/105136
13:38:42 <aspidites> i could remove the offending duplicate i suppose, but i'm wondering if there is a better way
13:39:05 <rwbarton> there can be only one
13:39:21 <Eduard_Munteanu> *slash*
13:39:29 <n-dolio> THE QUICKENIIIIING!!
13:39:30 <aspidites> rwbarton: unfortunately, i don't think there is a "cabal highlander" command
13:40:40 <aspidites> oh, nvm, the instance is defined within the packages source not a dependent package's so editing isn't as much of a big deal
13:41:14 <Tjr> Eduard_Munteanu: for the very basics, yes. Beyond that, it's learning by cursing while looking things up.
13:41:20 <albeit> :t (%=)
13:41:22 <lambdabot> (MonadState s m, Profunctor p) => Setting p s s a b -> p a b -> m ()
13:41:34 <Tjr> looking things up that I need for what I'm doing.
13:42:30 <glguy_> Aspidites the problem is your version of reducers is out of date
13:46:32 <albeit> How can I modify a monadic state with lens? Equivalent of "f <- gets _foo; foo .= g f"
13:46:37 <benzrf> does options applicative support subcommands?
13:46:46 <benzrf> albeit: %=
13:46:51 <benzrf> :t gets
13:46:53 <lambdabot> MonadState s m => (s -> a) -> m a
13:46:58 <aspidites> glguy: thanks. any way i'd have known to check that?
13:47:07 <ReinH> > (1,2) &~ _2 %= (+1)
13:47:08 <lambdabot>  (1,3)
13:47:15 <benzrf> oh wait
13:47:17 <aspidites> i'd like to not have to bug you guys for trivial things if at all possible :-)
13:47:19 <benzrf> :t (%=)
13:47:20 <lambdabot> (MonadState s m, Profunctor p) => Setting p s s a b -> p a b -> m ()
13:47:22 <benzrf> yeep
13:47:32 <benzrf> :t (&~)
13:47:33 <lambdabot> s -> State s a -> s
13:47:35 <benzrf> oic
13:47:40 <albeit> benzrf: Wierd, I can't get %= to work
13:47:47 <ReinH> &~ is just flip execState
13:48:04 <jle`> albeit: it's the _= family of operators
13:48:15 <jle`> most lens operators are pretty predictable
13:48:29 <benzrf> albeit: lens %= func
13:48:30 <jle`> you have +=, -=, *=, ec.
13:48:36 <joelteon> since _ is a valid operator character, maybe there should be a different term for a lens operator wildcard
13:48:42 <benzrf> :t (_=)
13:48:43 <lambdabot> parse error on input â€˜=â€™
13:48:43 <jle`> joelteon: really, it is?
13:48:48 <albeit> Does this look right? "orders %= (IMap.insert nextOrderId o)"
13:48:49 <joelteon> :t (+_+)
13:48:50 <lambdabot> parse error on input â€˜)â€™
13:48:51 <joelteon> is it not
13:48:55 <joelteon> wow, i *am* stupid
13:48:58 <jle`> i always thought it counted as a character
13:49:00 <jle`> like foo_
13:49:00 <benzrf> albeit: approximately
13:49:01 <joelteon> you may continue
13:49:03 <benzrf> albeit: why?
13:49:08 <benzrf> :t (<_>)
13:49:08 <ReinH> joelteon: _ is a letter, not a symbol :)
13:49:09 <lambdabot> parse error on input â€˜)â€™
13:49:12 <benzrf> wenk wenk
13:49:28 <jle`> not stupid, it's probably still not the best choice for a wildcard
13:49:52 <aspidites> actually that didn't work. oh well
13:50:03 <jle`> aspidites: can you give an example?
13:50:06 <albeit> benzrf: On compile its giving a "no instance for MonadState" arising from use of '%='
13:50:22 <jle`> albeit: what monad are you in...?
13:50:44 <albeit> jle`: A "StateT Foo IO ()"
13:51:10 <jle`> and that's the type signature of your do block?
13:51:12 <jle`> hm.
13:51:14 <jle`> care to paste some code?
13:51:18 <benzrf> albeit: what context are you putting that expr in
13:51:19 * rwbarton randomly guesses another transformers version mismatch
13:51:21 <ReinH> albeit: what is your code?
13:51:28 <benzrf> :t (%=)
13:51:29 <lambdabot> (MonadState s m, Profunctor p) => Setting p s s a b -> p a b -> m ()
13:51:31 <benzrf> mmmhm
13:51:32 <ReinH> rwbarton: good call
13:52:05 <albeit> Ah shoot I had some error with the transformers mismatch before, thats probably it
13:52:51 <albeit> And I completely forget if I solved it or gave up... how can I check thats the issue?
13:53:13 <rwbarton> ghc-pkg list transformers
13:53:18 <rwbarton> will tell you what version(s) you have installed
13:55:04 <albeit> In a sandbox, "cabal -v sandbox hc-pkg list transformers" says I have transformers-0.3.0.0 in my ghc-7.8.2 database, but not in sandbox
13:56:04 <albeit> Actually on a related note, when you run in a sandbox, do you exclude the user-level database package usually?
13:56:50 <rwbarton> what is the actual error message?
13:56:53 <bennofs> albeit: cabal does that by default, I think. Can you even change that?
13:57:29 <albeit> rwbarton: Error message http://lpaste.net/105137
13:57:47 <rwbarton> oh
13:57:59 <rwbarton> well it's clearly an mtl version mismatch then
13:58:06 <rwbarton> that's why it printed the mtl version
13:58:55 <albeit> Ah. Well, my sandbox database has mtl-2.1.3.1, same as the error. What would be the otherside of the mismatch?
13:59:00 <jle`> also i think MonadState comes from mtl, not transformers
13:59:34 <rwbarton> hm
14:00:18 <rwbarton> what is producing this error?
14:00:25 <rwbarton> cabal build?
14:00:51 <albeit> No, "ghc -O2 -package-db=.cabal-sandbox/x86_64-linux-ghc-7.8.2-packages.conf.d"
14:02:12 <rwbarton> well
14:02:34 <rwbarton> %= comes from lens so if it wants mtl-2.1.3.1 then I guess you must have lens built against mtl-2.1.3.1
14:03:34 <bitemyapp> albeit: life's simpler if you just use cabal + sandboxes
14:03:51 <albeit> bitemyapp: I thought I was!
14:04:01 <rwbarton> given that you don't have the instance, then you must have imported StateT from some other version of mtl
14:04:14 <rwbarton> IMO, life was a lot simpler before sandboxes
14:04:24 <bitemyapp> albeit: you're manually invoking ghc, not using a cabal file + cabal install :)
14:04:32 <albeit> bitemyapp: Ah...
14:04:47 <bitemyapp> rwbarton: disagree, but our priorities might be different. I work with a lot of new people who don't understand cabal.
14:05:04 <albeit> rwbarton: I'm importing Control.Monad.State.Lazy for my StateT
14:05:06 <bitemyapp> rwbarton: simply following the 'cabal init; cabal sandbox init' pattern has eliminated many problems.
14:05:14 <rwbarton> well, it's a lot more complex to figure out what is happening when something goes wrong
14:05:21 <bitemyapp> rwbarton: also disagree.
14:05:40 <rwbarton> since everyone has half a dozen different package dbs and is invoking one of half a dozen different commands that use them in different ways
14:05:47 <bitemyapp> having debugged my share of builds that haven't worked for me or for other people, sandboxes + .cabal file is almost always simpler.
14:07:04 <albeit> The odd thing is I'm using different lens functions elsewhere, and there are no errors. Its just the %= that is erroring...
14:07:36 <bitemyapp> rwbarton: you're a much more advanced user, several leaps and bounds ahead of the average person. It's entirely possible that the way you use Haskell is more complicated with sandboxes but the typical person who is new and whose projects can be encapsulated in a single .cabal file need sandboxes.
14:08:23 <rwbarton> if you stick to sandboxes and "cabal build" then it's probably no more complicated than the old way, and also more likely to work
14:08:48 <bitemyapp> rwbarton: sandboxes are more likely to work if it's simple projects + cabal build.
14:08:56 <rwbarton> yes
14:09:08 <bitemyapp> just making certain I understood you.
14:09:31 <bitemyapp> rwbarton: I think we're in sync then. Concurrent package versions would make a lot of this nicer, but I really hope people aren't serious about bringing in Nix to do that.
14:09:40 <bitemyapp> that would be tragic.
14:09:46 <bitemyapp> and I'd probably quit programming.
14:09:52 <bitemyapp> become a goat farmer.
14:10:34 <bitemyapp> jle`: I'd respond to you if twitter wasn't puking on my shoes.
14:13:50 <ReinH> bitemyapp: er, that answer isn't really about guarded recursion...
14:13:58 <ReinH> it's about lazy evaluation and strictness
14:14:15 <ReinH> Guarded recursion comes into play in the producer a bit I guess
14:14:30 <bitemyapp> ReinH: he was talking about the strictness of *
14:15:03 <ReinH> Right, so recursing on (*) is not guarded
14:15:05 <ReinH> ok
14:15:08 <bitemyapp> ohhhhh
14:15:26 <ReinH> a = 1 : a -- guarded recursion
14:15:31 <ReinH> a = 1 * a -- not guarded
14:15:36 <bitemyapp> ahhhhhhhh
14:15:42 <bitemyapp> his wording is freakin' confusing.
14:15:47 <bitemyapp> damn!
14:16:06 <ReinH> because (*) is strict in both positions
14:16:13 <ReinH> so it forces evaluation of the rhs
14:16:19 <rwbarton> albeit: can you try having cabal build your project? it will probably tell you what is wrong
14:16:27 <ReinH> whereas you can pattern match on the (:) constructor
14:16:34 <ReinH> > head (1:undefined)
14:16:36 <lambdabot>  1
14:16:43 <ReinH> that's guarded
14:16:48 <bitemyapp> anybody getting a warning about: Defaulting the following constraint(s) to type â€˜Integerâ€™   -- in their ghci?
14:16:52 <bitemyapp> ReinH: that makes sense.
14:17:37 <pavonia> Is there no function to get the decimal part of a RealFrac?
14:17:46 <jle`> bitemyapp: you already responded :)
14:18:19 <bitemyapp> jle`: not when I said that.
14:18:25 <jle`> oh i misread
14:18:36 <jle`> i thought you said you'd respond on twitter if you weren't puking on your shoes
14:18:43 <bitemyapp> that's right
14:18:46 <bitemyapp> and temporarily, I couldn't
14:18:47 <bitemyapp> then I did
14:18:53 <ReinH> > let a = 1 : a in head a
14:18:53 <bitemyapp> your arrow time is disjointed relative to mine.
14:18:54 <lambdabot>  1
14:18:55 <bitemyapp> are IRC conversations linearizable transactions?
14:19:00 <ReinH> same thing
14:19:02 <glguy> aspidites: was the problem actually that your version of reducers was old?
14:19:08 <bitemyapp> ReinH: right. I think I've got it.
14:19:09 <ReinH> up to equivalence of bottoms ;)
14:19:18 <ReinH> bitemyapp: :)
14:19:19 <jle`> the imagery in the two cases differ by a nontrivial amount
14:19:23 <bitemyapp> ReinH: (:) and (+) are good ways to demonstrate this.
14:19:26 <bitemyapp> very good.
14:19:27 <ReinH> sure
14:19:29 <jle`> also i like swapping my arrow of time every once in a while
14:20:20 <ReinH> the keys to the genericLength vs foldl' are: 1) tail call *position* of foldl puts the recursive call in left-most outermost position so it can be reduced per lazy evaluation semantics
14:20:30 <ReinH> 2) strictness of the accumulator prevents that thunk build-up
14:20:44 <ReinH> foldl still takes O(n) stack and O(n) heap
14:20:46 <ReinH> you need both
14:21:26 <ReinH> whereas genericLength (_:xs) = 1 + genericLength xs puts the (+) in left-most outermost position so the recursive call to genericLength builds up as a thunk chain
14:21:36 <ReinH> since it isn't reduced by evaluation
14:22:02 <jle`> does anyone know why fibs = 1 : 1 : zipWith (+*) fibs (tail fibs) where x +* y = let z = x+y in z `seq` z overflows in < 7.8 ?
14:22:10 <jle`> er, fibs !! 1000000
14:22:18 <jle`> am i leaking thunks?
14:22:24 <ReinH> bitemyapp: that's what's really going on and it has very little to do with tail calls except for the similarity in structure
14:22:34 <jle`> also, why does it no longer overflow in 7.8?  is there a bigger default stack, or is it something deeper
14:22:34 <glguy> jle`: z `seq` z === z
14:22:37 <bitemyapp> ReinH: naturally.
14:22:46 <jle`> glguy: ah
14:22:50 <jle`> that...makes sense
14:22:57 <jle`> wait, does it?
14:23:04 <jle`> i think it does.
14:23:09 <jle`> so how would i make a strict (+) then?
14:23:18 <rwbarton> default maximum stack size is effectively unlimited in 7.8
14:23:27 <jle`> ah
14:23:36 <ReinH> jle`: (+) is strict
14:23:44 <triliyn> (+) is already strict: when you evaluate (x + y), x and y are evaluated
14:23:53 <triliyn> But just because something is strict doesn't mean it gets evaluated for no reason
14:23:56 <ReinH> evaluation of (+) x y causes evaluation of x and... right
14:23:56 <shachaf> (+) is usually strict.
14:24:08 <jle`> hm.
14:24:16 <ReinH> shachaf: Interesting. When is it not?
14:24:20 <ReinH> shachaf: Oh.
14:24:20 <jle`> this too makes sense
14:24:22 <ReinH> It's a typeclass
14:24:25 <ReinH> Never mind.
14:24:33 <shachaf> It's a method.
14:24:41 <ReinH> shachaf: Yes. It's a method in a typeclass.
14:24:46 <ReinH> That has multiple definitions
14:24:47 <bitemyapp> I knew that was coming.
14:24:54 <ReinH> It is his way.
14:24:57 <ReinH> I'm growing accustomed :)
14:25:09 <triliyn> Lazy naturals are the main example of non-strict (+) I've seen
14:25:16 <ReinH> triliyn: yep sure
14:25:43 <jle`> so how should i make this work and not overflow the 7.6 stack?
14:25:50 <bitemyapp> ReinH: blasts fuzzy speech/thought with a Napoleonic-era cannon? :)
14:25:50 <jle`> i feel like this should be done in constant stack
14:25:54 <jle`> *should be able to be done
14:25:59 <jle`> without leaking any thunks
14:26:18 <ReinH> jle`: make what work?
14:26:34 <ReinH> @where lazy
14:26:35 <lambdabot> http://www.vex.net/~trebla/haskell/lazy.xhtml
14:26:38 <rwbarton> "leaking" is not a great word here
14:26:39 <jle`> fibs = 1 : 1 : zipWith (+) fibs (tail fibs)
14:26:40 <ReinH> jle`: you should read that
14:26:47 <rwbarton> how about "building up"
14:27:03 <ReinH> rwbarton: the thunks are just spilling all over the place...
14:28:19 <bitemyapp> whycantIholdallthesethunks.gif
14:29:35 <shachaf> ReinH: Whatever.
14:29:42 <jle`> on an initial reading i was not able to glean enough from that post to solve the problem at hand
14:31:22 <ReinH> shintah: ?
14:31:25 <ReinH> er
14:31:34 <ReinH> Huh.
14:31:45 <monochrom> mycons x y = seq x (x : y); infixr 5 mycons; fibs = 1 `mycons` 1 `mycons` zipWith (+) fibs (tail fibs)
14:31:53 <jle`> ah
14:32:03 <rwbarton> alternatively, replace (!!)
14:32:20 <jle`> this makes sense
14:33:42 <monochrom> no, mine is useless. the seq has to be inside zipWith
14:34:36 <monochrom> replace (!!). (x:xs) !! n = seq x (xs !! (n-1))
14:38:11 <monochrom> I feel sad that people are so off-by-1 in deciding where to increase strictness.
14:38:47 <monochrom> in "g (f x)", it is no use to make f more strict. g doesn't even care.
14:39:55 <monochrom> > const () (seq (seq (seq undefined) undefined) (seq undefined undefined))
14:39:57 <lambdabot>  ()
14:40:13 <monochrom> it doesn't matter how many more seq's you put there. const doesn't care.
14:40:16 <orzo> have you ever written code with little care to strictness thinking you'll optimize later only when later comes the project is near impossible
14:40:32 <monochrom> what you need to do is to make g strict, not make f strict.
14:40:47 * hackagebot llvm-general-pure 3.3.12.0 - Pure Haskell LLVM functionality (no FFI).  http://hackage.haskell.org/package/llvm-general-pure-3.3.12.0 (BenjaminScarlet)
14:40:49 * hackagebot llvm-general-pure 3.4.3.0 - Pure Haskell LLVM functionality (no FFI).  http://hackage.haskell.org/package/llvm-general-pure-3.4.3.0 (BenjaminScarlet)
14:40:51 * hackagebot llvm-general 3.3.12.0 - General purpose LLVM bindings  http://hackage.haskell.org/package/llvm-general-3.3.12.0 (BenjaminScarlet)
14:40:53 * hackagebot llvm-general 3.4.3.0 - General purpose LLVM bindings  http://hackage.haskell.org/package/llvm-general-3.4.3.0 (BenjaminScarlet)
14:41:16 <monochrom> this is what I mean by off-by-1. you're place of adding strictness is 1 level too deep. the outer level doesn't care.
14:41:51 <monochrom> s/you're/your/
14:45:47 * hackagebot propellor 0.6.0 - property-based host configuration management in haskell  http://hackage.haskell.org/package/propellor-0.6.0 (JoeyHess)
14:46:03 <orzo> does anyone have a vim macro that formats a series of assignments so that the equal signs are in a column?
14:59:16 <ReinH> orzo: lookat Tabularize or Align.vim
14:59:39 <ReinH> vim2hs has some Tabularize stuff iirc
14:59:47 <ReinH> but you just need :Tab \=
15:00:11 <bitemyapp> ReinH: I had to disable all the folding stuff before vim2hs stopped being obnoxious.
15:00:46 <ReinH> Yeah
15:00:53 <ReinH> I don't care any more because I'm using emacs now :D :D :D
15:01:04 <bitemyapp> ReinH: are you going to convert? Using evil?
15:01:10 <ReinH> not using evil
15:01:14 <ReinH> I can't stand vim emulations
15:01:24 <aspidites> do your fingers hurt yet?
15:01:27 <ReinH> maybe not fully convert but using it for haskell has been very nice
15:01:36 <ReinH> aspidites: I ordered the foot pedals /s
15:01:48 <aspidites> or less inflamatory - how long did it take you to get used to key bindings vs modes?
15:02:39 <ReinH> aspidites: still not used to it
15:02:49 <ReinH> I've tried to switch to emacs many times and failed each time
15:02:56 <ReinH> this time it seems to be sticking a bit better though
15:03:03 <aspidites> ah. so this is funny (to me) - i argued that i couldn't switch to emacs because it was so huge
15:03:25 <aspidites> i just checked my .vim folder - same size as what i needed to download to install emacs
15:03:46 <ReinH> hahaha
15:04:43 <aspidites> here goes nothing...i can't imagine leaving vim, but its been like 8 years since i tried emacs
15:05:06 <aspidites> yikes...is there a console version? this gtk3 thing isn't working for me
15:05:25 <aspidites> ah, -nw
15:07:35 <orzo> can we agree on a particular number of columns that is greater than 80 for haskell code?
15:08:46 <StoneCypher> most languages that go up go up to 120
15:09:08 <StoneCypher> me, i just go up to wherever i feel like, because if you can't cope with long lines and don't like word wrap, you're gonna hate everything else i do too
15:09:42 <aspidites> i dont' see emacs working for me. the mneumonics for moving make sense, but i hate having my fingers stretched all over the keyboard
15:09:47 <aspidites> lets try this with evil mode
15:10:52 <orzo> most languages go up to 120? i'm not familiar with that
15:10:58 <orzo> 120 is a fine numbe rtho
15:11:20 <dottedmag> aspidites: why stretched? Finders are on "basic position" for touch typing most of the time with Emacs.
15:11:33 <orzo> 120 excides my current terminal width heh
15:12:08 <orzo> i just need to shirnk 1 step though and it's perfect
15:12:16 <moghedrin> Alright, so I've been sitting on this for around an hour now :L Can somebody explain what I'm misunderstanding with this snippet of code in regards to MonadState and StateT? http://pastebin.com/WVxNkGtq
15:12:53 <orzo> so lets do it then, 120 is the new 80
15:13:20 <vanila> bah lens stuff i can't help
15:13:21 <aspidites> dottedmag: ctrl + x, p, n, f, b
15:13:49 <aspidites> perhaps stretched wasn't the correct word, but considering the equivalent to those in vim all reside on the home row, it's definitely a noticable difference
15:14:08 <rwbarton> moghedrin: what's the error message?
15:14:10 <aspidites> and my ring finger hates the x key when combined with anything else
15:14:42 <moghedrin> No instance for MonadState Cont (StateT Cont IO) arising from a use of '+='
15:15:47 <rwbarton> heh, sounds familiar
15:16:05 <aspidites> i will give emacs points for configuration though lisp is much more pleasant to deal with than viml
15:16:56 <rwbarton> moghedrin: ghc 7.8?
15:17:17 <moghedrin> 7.6, 'twould seem...
15:17:32 <rwbarton> oh
15:17:43 <moghedrin> Would that be my issue?
15:17:44 <rwbarton> well, anyways I would guess your lens is built against a different version of transformers than the one you are importing
15:18:31 <moghedrin> rwbarton: Then it 'looks' fine, codewise? I'm not fundementally misunderstanding something?
15:18:53 <aspidites> evil mode wasn't too bad. still not vim (obviously). ReinH ++ for being able to switch. I'm going back to my love-hate relationship with vim
15:19:12 <rwbarton> moghedrin: correct
15:19:34 <moghedrin> rwbarton: Well, that's the important thing! The rest is just details XD
15:19:40 <moghedrin> rwbarton: Thank you very much!
15:19:53 <dottedmag> aspidites: That's right. Though I've been remapping (Ctrl/Alt)+x and (Ctrl/Alt)+q in Emacs to get back M-x C-x muscle memory after switching to Dvorak
15:20:18 <dottedmag> And C-x is much less pleasent with Dvorak (x is is on b key)
15:21:34 <FireFly> aspidites: see, that describes my relationship with vim pretty well too
15:22:05 <A209> With ConstraintKinds, is it possible to reify a constraint using a MultiParamTypeClass into something with a single type argument...like currying?
15:22:46 <aspidites> i thnk i'm going to crack open my clevo and clean it up some
15:23:13 <aspidites> FireFly: im crossing my fingers in hope that neovim makes a difference in the near future
15:23:26 <FireFly> That would be neat
15:23:44 <aspidites> later
15:27:16 <external-reality> are quasi-quotes type safe???
15:27:57 <moghedrin> rwbarton: How would I check that?
15:29:08 <Philonous> external-reality, The code is type-checked after the quoted value is spliced, so they don't allow you to write type-incorrect code.
15:29:17 <Philonous> external-reality, If that's what you mean by type-safe
15:29:39 <rwbarton> moghedrin: ok, first of all, how are you compiling this file?
15:30:31 <moghedrin> For the moment, I'm just loading it into ghci.
15:30:49 <rwbarton> ok
15:31:18 <rwbarton> try: ghc-pkg list mtl
15:31:23 <rwbarton> and also: ghc-pkg list transformers
15:31:42 <rwbarton> do you have more than one version of either of those?
15:32:25 <moghedrin> I have two of both.
15:33:30 <rwbarton> ok, so ghci is picking the wrong version of at least one of them
15:33:39 <rwbarton> as in, not the version you have lens built against
15:33:50 <rwbarton> to find out which versions those are you can run: ghc-pkg describe lens
15:36:06 <external-reality> Philonous: QQ code turns is parsed into Haskell code that is then type checked.
15:36:10 <external-reality> ??
15:36:18 <external-reality> OK
15:36:32 <external-reality> thx
15:38:15 <Philonous> Yes, a QuasiQuoter is a piece of template haskell code that parses a string and returns haskell code. The code is inserted ("spliced") into the place where the QQ originally stood and the result is type-checked.
15:39:04 <moghedrin> rwbarton: Okay - So the transformer's library that's being kept in ghc's lib64 folder seems to be newer than the one lens requires.
15:39:04 <external-reality> Philonous: Badness!!!
15:39:16 <diegos> Hi! What do I need to do to get a if I have an M a?
15:39:36 <Philonous> diegos, Depends on what M is
15:39:49 <diegos> IO
15:40:11 <external-reality> diegos: unsafePerformIO
15:40:19 <diegos> Cool, thanks!
15:40:23 <orzo> heh
15:40:25 <Philonous> diegos, The same way you get the directory structure out of the ls binary. You don't
15:40:31 <Philonous> diegos, No. That's wrong.
15:40:43 <orzo> lol
15:40:56 <Philonous> diegos, unsafePerformIO is called UNSAFE for a reason
15:41:15 <external-reality> lol
15:41:16 <rwbarton> moghedrin: okay
15:41:21 <rwbarton> moghedrin: You have a lot of options here
15:41:37 <diegos> Ok... I'm playing with Network.Beanstalk on ghci
15:42:05 <jle`> monochrom: ah i missed your messages after my last one
15:42:08 <rwbarton> moghedrin: I would probably ghc-pkg unregister mtl and transformers
15:42:14 <jle`> monochrom: the strict (:) didn't work like you said
15:42:19 <jle`> but all I needed was a strict zipWith
15:43:20 <rwbarton> moghedrin: er, that is unregister the newer versions
15:43:34 <Philonous> diegos, Generall, you want to use (>>=) ot do-notation to chain monadic actions.
15:43:35 <jle`> monochrom: thank you for the insight aftewards
15:43:46 <Philonous> diegos, s/ot/or
15:44:28 <rwbarton> moghedrin: then I would add a constraint 'transformers installed' to ~/.cabal/config as described here: http://www.vex.net/~trebla/haskell/cabal-cabal.xhtml#lockdown
15:44:48 <orzo> it's considered good style to declare constants like so:  x = unsafePreformIO $ return 6
15:44:56 <moghedrin> rwbarton: I'll look at that :) Thanks!
15:45:30 <diegos> Thanks Philonous, I'll try that
15:45:31 <Philonous> orzo, I'm not entirely sure what you think you're accomplishing here. But maybe you should take it to -blah?
15:45:59 <rwbarton> moghedrin: and one for mtl too, and whatever other packages from the Haskell Platform you have installed already if you follow the link there
15:48:21 <moghedrin> rwbarton: Worked like a charm! :) Thank you very much!
15:51:40 <diegos> Hm, not sure how to use >>= here...
15:52:02 <diegos> So I want to avoid the unsafePerformIO right?
15:52:06 <diegos> putJob myBs 1 0 10 (B.pack "Hello World!")
15:52:08 <Philonous> diegos, Absolutely
15:52:29 <diegos> But
15:52:30 <diegos> let myBs = unsafePerformIO bs
15:52:45 <Philonous> diegos, You're playing around in ghci, right?
15:52:49 <diegos> so, what does myBs needs to be?
15:52:50 <diegos> yes
15:53:43 <Philonous> diegos, So, try this:  (jobState, jobID) <- putJob myBs 1 0 10 (B.pack "Hello World!")
15:53:48 <rwbarton> myBs <- bs
15:54:14 <Philonous> diegos, Right, what rwbarton said
15:55:13 <Philonous> diegos, Inside do-notation and inside ghci (which is sorta-kinda like do-notation) you can bind the result of an action to a name with a left arrow as in "x <- some expression "
15:55:48 <diegos> Wait, but what we want to avoid is the definition of myBs
15:55:54 <diegos> We want to use bs
15:56:33 <yac> Hey I wrote naive /usr/bin/cmp in haskell and it's ~40 times slower
15:57:02 <Philonous> diegos, I don't know what bs is
15:57:06 <yac> So I straced it and figured haskell version does rt_sigprocmask and clock_gettime, both two times, between each read
15:57:09 <yac> any idea why?
15:57:28 <diegos> I mean, the unsafePerformIO thing works and makes me happy, but if there is a better way...
15:57:29 <yac> or better, how do I get rid of it
15:57:33 <joshc> bs <- connectBeanstalk <hostname> <port>; (jobState, jobID) <- putJob bs 1 0 10 (B.pack "Hello World!")
15:58:45 <diegos> > let bs = connectBeanstalk host port
15:58:46 <lambdabot>  not an expression: â€˜let bs = connectBeanstalk host portâ€™
15:58:51 <bitemyapp> danneu: <3
15:59:11 <diegos> > bs = connectBeanstalk host port
15:59:12 <lambdabot>  <hint>:1:4: parse error on input â€˜=â€™
15:59:30 <Philonous> diegos, That defines an action that, when executed, will create a connection to the server
16:00:47 <glguy> yac: The first step is going to be you posting the slow code to http://lpaste.net/new/haskell . Otherwise people will have to guess what you're doing
16:01:31 <diegos> Cool, it worked, thank you Philonous!
16:01:32 <pavonia> What would be a good name for a function "\p -> filter $ not . p"?
16:02:11 <yac> oh hey
16:02:13 <yac> ghc -fno-ghci-sandbox is fixing it
16:02:18 <yac> fuck yes
16:02:24 <shelf> hello, dumb question.
16:02:24 <rwbarton> is it faster now?
16:02:33 <yac> yes, it's as fast as the diffutils version
16:02:39 <jle`> shelf: dumb question is offline right now
16:02:44 <shelf> aw
16:02:49 * rwbarton is very confused
16:03:11 <rwbarton> doesn't -fno-ghci-sandbox only affect ghci
16:03:15 <shelf> i uhh. am definitely missing a simple idiom here.
16:03:19 <shelf> and $ zipWith (==) (map fst args') (map Just (ceFunArgs jce))
16:03:23 <yac> oh wait, it's two times faster in my case
16:03:51 <shelf> simple 'andMap ==' over [Maybe a] and [a]
16:04:51 <jle`> i guess you could do all (uncurry (==)) . zip
16:04:55 <rwbarton> do you really want "and $ zipWith (==) ..." or do you want to test whether the two lists are equal?
16:05:05 <jle`> hm
16:05:08 <jle`> oh yeah
16:05:08 <rwbarton> the former will be true if either list is a prefix of the other
16:05:10 <jle`> heh
16:05:13 <yac> how do I stick that ghc option into the source file or cabal file?
16:05:39 <shelf> rwbarton: yeah, that's all I want. how can I do that without 'map Just'?
16:07:24 <yac> oh, got it
16:09:01 <jle`> shelf: Just <$> xs might look nicer, but i'm not sure if there is a better way without mapping
16:09:13 <jle`> or doing some tricks with your comparing function
16:09:21 <jle`> :t (==) . Just
16:09:21 <lambdabot> Eq a => a -> Maybe a -> Bool
16:09:30 <rwbarton> shelf: you still need the 'map's
16:09:47 <rwbarton> but at least you can write  map fst args' == map Just (ceFunArgs jce)
16:10:09 <jle`> > zipWith ((==) . Just)) [2,6,7,3] [Just 4, Nothing, Just 7, Just 1]
16:10:10 <lambdabot>  <hint>:1:22: parse error on input â€˜)â€™
16:10:12 <jle`> er
16:10:13 <rwbarton> (unless I understood and you mean you really want the version you have)
16:10:17 <jle`> > zipWith ((==) . Just) [2,6,7,3] [Just 4, Nothing, Just 7, Just 1]
16:10:18 <lambdabot>  [False,False,True,False]
16:10:27 <jle`> but i don't think that's very readable
16:12:24 <shelf> rwbarton: thanks, i've gone with that.
16:12:32 <yac> rwbarton: look like it does. I was running wrong binary. The performance actually comes from MMap
16:13:06 <rwbarton> yac, okay that I will believe :)
16:13:31 <rwbarton> was your naive version using String?
16:16:10 <seydar> hey so i'm writing an echo server and i want to store the connection info in a record: User {hand :: Handle, host :: Text, port :: Int}
16:16:41 <yac> how can I disable threads in ghc?
16:16:45 <seydar> unfortunately, i'm having type issues as the hostname and port as a result of `(handle, host, port) <- accept sock` have strange types
16:17:09 <seydar> how can i bring myself to the land where types make sense, happy valley, where dinosaurs roam and speak english?
16:17:33 <vanila> what library is accept from?
16:17:41 <benbangert> yac: don't compile with -threads?
16:17:47 <vanila> :t accept
16:17:48 <lambdabot> Not in scope: â€˜acceptâ€™
16:18:06 <yac> rwbarton: I've got one using hGetContents on openBinaryFile and one using MMap. The MMap is good but the first one isn't and I suspect it's got something to do with threads because https://gist.github.com/yaccz/c6027ba657597fed5949
16:18:19 <seydar> :t Network.accept
16:18:20 <lambdabot> network-2.4.2.2:Network.Socket.Types.Socket -> IO (GHC.IO.Handle.Types.Handle, Network.Socket.HostName, network-2.4.2.2:Network.Socket.Types.PortNumber)
16:18:26 <yac> while the diffutils one is only a wall of `read` syscalls
16:18:37 <seydar> vanila: Network
16:18:57 <rwbarton> yac, I would guess that the difference is due to String vs ByteString
16:19:03 <vanila> seydar, it says accept :: Socket -> IO (Socket, SockAddr) here hm
16:19:26 <seydar> i'm definitely using the three-tuple variant
16:19:37 <seydar> how do i convert the Network.Socket.HostName to a usable string?
16:19:59 <vanila> http://hackage.haskell.org/package/network-2.5.0.0/docs/Network-Socket.html
16:20:03 <yac> rwbarton: still the program is making at least twice as many syscalls
16:20:05 <vanila> this is weird
16:20:17 <rwbarton> yac: you could see how much time it spends in system
16:20:18 <rwbarton> with time
16:20:37 <vanila> can you link the docs of the module you're using?
16:20:56 <seydar> :t Network.Socket.accept
16:20:57 <lambdabot> network-2.4.2.2:Network.Socket.Types.Socket -> IO (network-2.4.2.2:Network.Socket.Types.Socket, network-2.4.2.2:Network.Socket.Types.SockAddr)
16:21:00 <seydar> :t Network.accept
16:21:01 <lambdabot> network-2.4.2.2:Network.Socket.Types.Socket -> IO (GHC.IO.Handle.Types.Handle, Network.Socket.HostName, network-2.4.2.2:Network.Socket.Types.PortNumber)
16:21:16 <seydar> vanila: is that clearing it up? was that the issue for you?
16:21:55 <rwbarton> yac: you can also check the RTS options by running your program with +RTS -?
16:22:08 <yac> true, but isn't there some overhead in userspace too?
16:22:57 <yac> rwbarton: oh, that's how th -qg is invoked
16:23:17 <rwbarton> I can't imagine it is significant compared to processing 16k worth of data from the two files
16:24:29 <kini> If I have a bunch of things I want to do in a row that might fail, and I want the whole process to fail if any particular step fails, then it seems like the Maybe monad is what I want to use, right?
16:25:07 <bitemyapp> kiniry: and perhaps applicative as well.
16:25:20 <yac> rwbarton: hm, the mmap functions actually results into ByteString, I guess you are right
16:25:24 <kini> is there some similar thing for if I have a bunch of things I want to do in a row, and I only want the whole process to fail if every step fails (otherwise I want the final result to be the result of the last successful action)?
16:25:31 <bitemyapp> dammit
16:25:36 <bitemyapp> kini: and perhaps applicative as well.
16:25:48 * kini waves at kiniry
16:25:56 <bitemyapp> kini: you don't *have* to use Maybe btw, you can short-circuit via Cont or something else too, but Maybe will probably be easier.
16:26:04 <yac> so how do I do Handle -> IO ByteString
16:26:39 <bitemyapp> data Blah = Blah Int Int deriving (Show)
16:26:43 <bitemyapp> Î»> Blah <$> Just 1 <*> Just 2
16:26:43 <bitemyapp> Just (Blah 1 2)
16:26:43 <bitemyapp> Î»> Blah <$> Just 1 <*> Nothing
16:26:44 <bitemyapp> Nothing
16:26:50 <seydar> is show what i should be using to convert something to a string?
16:26:56 <seydar> is that its purpose?
16:26:57 <bitemyapp> seydar: not necessarily.
16:26:59 <bitemyapp> seydar: no.
16:27:03 <bitemyapp> seydar: it's not a serialization thing.
16:27:11 <bitemyapp> seydar: show is about exposing things to humans (developers)
16:27:16 <bitemyapp> seydar: why do you need a string?
16:28:25 <seydar> bitemyapp: when i accept a socket connection, i get a HostName and PortNumber. I'd like to turn those into strings and numbers
16:30:13 <hexagoxel> "type HostName = String"
16:30:13 <bitemyapp> seydar: what's a HostName?
16:30:21 <bitemyapp> hexagoxel: thanks for spoiling the surprise.
16:30:30 <bitemyapp> :info HostName
16:30:36 <bitemyapp> ...really lambdadot?
16:30:41 <yac> doh, it's in bytestring module
16:30:51 <yac> rwbarton: you are right. Handles with bytestring are just as fast
16:31:31 <bitemyapp> seydar: you also dodged my question. Why do you need a String and a Number? Also, what *are* those types?
16:32:31 <bitemyapp> seydar: if you don't understand what "type" does in Haskell, you need to catch up on the basics mate.
16:32:36 <bitemyapp> seydar: https://github.com/bitemyapp/learnhaskell
16:33:23 <kini> It seems customary for a >> b to be the same as a >>= const b, right? Yet the Monad instance for Maybe defines it explicitly
16:34:06 <seydar> bitemyapp: derp. thank you.
16:34:24 <bitemyapp> seydar: REPL has :info
16:34:28 <bitemyapp> seydar: use it to inspect types.
16:34:29 <seydar> bitemyapp: i wanted strings and ints so i could operate on them and have them be the expected value. i keep confusing type and data
16:34:33 <jle`> kini: it is for efficiency, I believe
16:34:37 <bitemyapp> seydar: all good. use :info
16:34:37 <seydar> thank you
16:34:58 <seydar> bitemyapp: one last question: how bad is it to mix Text and String in a single program?
16:35:22 <bitemyapp> seydar: it should be...avoided, but sometimes it's not worth playing whack-a-mole with the types.
16:35:55 <kini> jle`: odd... seems fairly optimizable away
16:40:09 <Profpatsch> Is it true that Filesystem.Path cannot do something like "/tmp" </> "somefile" ?
16:40:21 <Profpatsch> I thought it would automatically recognize the strings.
16:41:52 <Profpatsch> Do I have to use decodeString "/tmp" for that? That looks counter-intuitive to me.
16:42:39 <kini> so it seems the Maybe monad isn't what I want. What's the idiomatic way to do something like, try 1, if it works, use that, otherwise try 2, etc., until try n? (where "try i" means I have an expression of type Maybe a)
16:42:39 <kini> I could do "listToMaybe . catMaybes $ [try1, try2, ..., tryn]", I suppose...
16:43:54 <Profpatsch> Why would I want </> if it couldnâ€™t concat Strings to a FilePath?
16:45:37 <vanila> > foldr (\y xs -> maybe xs Just y) Nothing [Nothing, Nothing, Just "A", Just "B"]
16:45:38 <lambdabot>  Just "A"
16:47:12 <kini> I was hoping there would be some convenient combinators somewhere so I wouldn't have to needlessly build a list of my like 3 things :P
16:47:38 <hexagoxel> > msum [Nothing, Just "a", Just "b"]
16:47:39 <lambdabot>  Just "a"
16:47:52 <vanila> cool!
16:48:35 <hexagoxel> > Nothing `mplus` Just "a" `mplus` Just "b"
16:48:36 <lambdabot>  Just "a"
16:49:43 <yac> rwbarton: Thanks! This rocks. MMap version is two times faster than diffutils one (in my limited case:) )
16:49:57 <Profpatsch> Anyone any tutorials on how to use Filesystem.Path?
16:50:29 <Profpatsch> Generally, is there something like http://pymotw.com/2/ for Haskell?
16:51:15 <Profpatsch> Examples usually say a thousand times more than (sparse) documentation by itselft
16:51:23 <bitemyapp> Profpatsch: there's acid2 / ocharles' 12 days of Hackage.
16:51:42 <bitemyapp> Profpatsch: quite excellent.
16:52:44 <kini> hexagoxel: amazing! :D
16:52:55 <kini> thanks!
16:53:17 <Profpatsch> bitemyapp: Very cool, thanks!
16:53:53 <Profpatsch> bitemyapp: How would you do something like "/tmp" </> "file"
16:54:25 <bitemyapp> Profpatsch: ...?
16:54:34 <bitemyapp> Profpatsch: c-can you not do that?
16:54:46 <Profpatsch> I donâ€™t know.
16:54:55 <Profpatsch> import Filesystem.Path
16:54:57 <vanila> what's actually meant here
16:55:37 <Profpatsch> Prelude Filesystem.Path Filesystem.Path.CurrentOS> empty </> "tmp" </> "myfile"
16:55:48 <Profpatsch> Couldn't match expected type â€˜Filesystem.Path.FilePathâ€™
16:55:49 <Profpatsch>                 with actual type â€˜[Char]â€™
16:55:59 <enthropy> you could use System.FilePath instead
16:56:11 <enthropy> it has type FilePath = String
16:56:36 <enthropy> what that other library is doing is a "feature"
16:57:32 <Profpatsch> Oh, is the system-filepath package outdated?
16:58:09 <enthropy> no the other one is older
16:59:51 <Profpatsch> I saw the package while skimming https://www.fpcomplete.com/user/snoyberg/ide-documentation/recommended-libraries, so I thought this was the one Iâ€™d want to use.
17:00:09 <Profpatsch> Apparently itâ€™s not, at least not for normal use cases.
17:00:33 <bitemyapp> Profpatsch: your definition of normal might be a bit strange.
17:00:45 <Profpatsch> bitemyapp: It might. :)
17:01:08 <enthropy> you can turn on -XOverloadedStrings and have that expression work
17:01:10 <vanila> see if you can contact 'snoyberg' about it
17:01:24 <Profpatsch> Isnâ€™t constructing a filepath with strings a normal thing to do?
17:01:30 <bitemyapp> Profpatsch: not if you care about safety.
17:01:38 <bitemyapp> Profpatsch: the domain of string contains things that aren't valid paths to files.
17:01:42 <Profpatsch> At least for cases where the string is a constant.
17:01:51 <bitemyapp> constant is irrelevant.
17:02:20 <Profpatsch> How would I define a fileâ€™s name then?
17:02:37 <Profpatsch> In a safe way.
17:02:42 <vanila> http://haddocks.fpcomplete.com/fp/7.4.2/20130829-168/system-filepath/Filesystem-Path-CurrentOS.html
17:02:51 <vanila> looks liek the fromText method will work
17:03:11 <vanila> then you can test if its valid
17:03:26 <Profpatsch> So, the System.Filepath is NOT what I want to use, but Filesystem.Path is?
17:03:36 <vanila> http://haddocks.fpcomplete.com/fp/7.4.2/20130829-168/system-filepath/
17:03:36 <freezerburnv> So I asked this a few days/a week ago, but I didnâ€™T have time to stick around for someone to explain it to me fully. So I shall ask again: Can someone explain how this function works? â€œappendSwapped = (++) <*> map swapâ€. Itâ€™s used like so: â€œappendSwapped [(1,2), (3,4)] == [(1,2), (3,4), (2,1), (4,3)]â€
17:03:37 <vanila> if you see here
17:03:40 <Profpatsch> Or why are there two packages?
17:03:46 <vanila> Filesystem.Path.CurrentOS is part of that larger library
17:03:57 <vanila> so you can import both
17:04:03 <vanila> import Filesystem.Path
17:04:06 <vanila> import Filesystem.Path.CurrentOS
17:04:19 <vanila> then you can use </> from the first, and fromText from the second
17:04:37 <Profpatsch> vanila: Yeah, I saw that. Iâ€™m just confused why there are two libraries that do the same as far as I can tell.
17:04:48 <vanila> freezerburnv, do you know abou this:
17:04:52 <vanila> > join (++) "foobar"
17:04:54 <lambdabot>  "foobarfoobar"
17:05:11 <vanila> it's the (->)e monad, which is the same thing that's being used there
17:05:39 <freezerburnv> vanila: I donâ€™t really understand (->) e :( I sort of have a little knowledge of it, but I donâ€™t really understand it
17:05:41 <vanila> Profpatsch, what do you mean? those two imports are just different modules from the same library
17:06:24 <enthropy> vanila: are you aware of http://hackage.haskell.org/package/filepath ?
17:06:33 <vanila> freezerburnv, well join :: m (m a) -> m a, in the function monad is  join :: (e -> e -> a) -> (e -> a)
17:06:43 <Profpatsch> vanila: I mean the difference between System.FilePath and Filesystem.Path
17:07:17 <vanila> freezerburnv, so it just applies the function twice
17:07:32 <vanila> I mean, applies the same argument twice, to the function
17:07:47 <Profpatsch> One being a standard module, the other in the package system-filepath
17:08:03 <Profpatsch> The latter on the recommended page of fpcomplete
17:08:04 * enthropy writes a File.SystemPath
17:08:30 <monochrom> do you also plan a Path.FileSystem? :)
17:08:56 <Profpatsch> very confusion
17:09:00 <Profpatsch> such similar
17:10:14 <Profpatsch> Anyone care to explain to a lost newbie who thought itâ€™d just work.
17:10:22 <hexagoxel> freezerburnv: a -> b === (->) a b
17:10:57 <enthropy> Profpatsch: enable -XOverloadedStrings
17:11:01 <enthropy> then it will just work
17:11:15 <freezerburnv> hexagoxel: â€¦wow that makes so much sense.
17:11:18 <Profpatsch> enthropy: Yeah, but why would I want to use it?
17:11:43 <Profpatsch> Over System.Path, that is.
17:12:15 <monochrom> sorry, could you say again what you want to work?
17:12:18 <hexagoxel> freezerburnv: so (->) a is the (partially applied) type of functions taking a as parameter
17:12:34 <rwbarton> what </> are you using again?
17:12:36 <enthropy> Profpatsch: do you know why people like Text when there is String?
17:12:46 <hexagoxel> freezerburnv: next, you should have a look at the instance definition, i.e. "instance Monad ((->) r)"
17:12:56 <freezerburnv> vanila, hexagoxel: So then, if I understand correctly, â€œf (a -> b) -> f a -> f bâ€ in the function monad becomes â€œ(c -> a -> b) -> (c -> a) -> (c -> b)â€?
17:13:07 <vanila> yes that's right
17:13:17 <fread2282> is FunctionSections a real extension?
17:13:22 <Profpatsch> monochrom: I just want to know what YOU ALL use, what I should use as a newbie and why there are two packages that do THE EXACT SAME THING?!
17:13:25 <vanila> can you implement a function of that type?
17:13:35 <Profpatsch> enthropy: No idea.
17:13:43 <monochrom> I use Haskell.
17:13:48 <rwbarton> well I use the one that comes with ghc
17:14:01 * enthropy has used both
17:14:02 <Profpatsch> Okay, Iâ€™m definitely being trolled here.
17:14:03 <monochrom> freedom of speech is why there are two packages doing the exact same thing
17:14:25 <freezerburnv> hexagoxel: I should possibly avoid that so I can try to implement it in the NICTA courseâ€¦. eventually.
17:14:47 <freezerburnv> hexagoxel: Gonna get through the CIS course first, then get back to NICTA. (I got through some of it, but started hitting blocks)
17:14:54 <Profpatsch> monochrom: Then why does fpcomplete recommend the package?
17:15:02 <monochrom> which package?
17:15:12 <monochrom> I am also unfamiliar with fpcomplete details
17:15:22 <rwbarton> system-filepath
17:15:44 <Profpatsch> https://www.fpcomplete.com/user/snoyberg/ide-documentation/recommended-libraries
17:16:02 <vanila> Profpatsch, shoot snoyberg a email
17:16:04 <enthropy> Profpatsch: String is a singly linked list, Text is more like an array. The former is more convenient, the latter might be faster
17:16:22 <monochrom> I did not create fpcomplete, so I don't know why what it does
17:16:57 <monochrom> however, I do like how it makes the FilePath type abstract
17:17:23 <Profpatsch> So it increases type safety?
17:17:27 <monochrom> yes
17:17:38 <Profpatsch> Ah, ok.
17:17:46 <fragamus> still need a good Cont tutorial
17:18:59 <monochrom> fragamus, I don't know whether my http://www.vex.net/~trebla/haskell/cont-monad.xhtml is good for you. I use callCC all the way through, I haven't used "cont (\fred -> ...)" directly
17:19:09 <fragamus_> dropped out for a sec
17:19:11 <fragamus_> Cont is confusing
17:19:14 <monochrom> fragamus, I don't know whether my http://www.vex.net/~trebla/haskell/cont-monad.xhtml is good for you. I use callCC all the way through, I haven't used "cont (\fred -> ...)" directly
17:19:19 <freezerburnv> vanila, hexagoxel: I think I actually understand the code now! Thanks a ton for helping me out (I love that you can trace types in Haskell, and suddenly understand how something works)
17:19:28 <vanila> yeah it's a great tool!
17:20:03 <chrisdotcode> guys, can you start a module name with a lowercase letter?
17:20:12 <monochrom> no
17:20:12 <chrisdotcode> module foo where vs. module Foo where
17:20:16 <chrisdotcode> dang
17:20:21 <chrisdotcode> any reason for that restriction?
17:20:27 <chrisdotcode> oh, because functions are lowercase?
17:20:31 <monochrom> convenience for parsers
17:21:35 <enthropy> it lets people would use . without surrounding spaces
17:22:06 <enthropy> and usually not run into it parsing as a qualified name
17:22:13 <monochrom> I use . (function composition) with surrounding spaces anyway
17:22:25 <Axman6> foo.bar.baz could be three functions or a qualified name of the function baz
17:22:58 <chrisdotcode> but then again, couldn't Foo.Bar.Baz be type constructor functions chained together with (.)?
17:23:11 <Axman6> yeah, I just realised that
17:23:15 <rwbarton> yes, it could
17:23:39 <chrisdotcode> so why arbitrarily limit module names?
17:23:49 <chrisdotcode> why not enforce a composition be surrounded by spaces?
17:23:53 <vanila> it's not arbitrarily
17:23:57 <chrisdotcode> there's already a similar rule for (-)
17:24:01 <monochrom> "Map.map Set.toList . Map.fromListWith (flip Set.union) . etc etc" is some code I recently wrote. you really want me to put those spaces there, for your sake. :)
17:24:06 <chrisdotcode> vanila: right, sorry, not arbitrary
17:24:14 <rwbarton> well, every other class of symbol has a case restriction, so maybe for consistency? :)
17:24:49 <rwbarton> maybe some day we'll have variables that range over modules! who knows
17:25:21 <timbod7> Anyone about who relies on add-source with cabal sandboxes?
17:25:38 <crazydave> oh global variables.  What a great idea rwbarton.  We can use them to store state :)
17:26:00 <chrisdotcode> crazydave: and let's make it mutable, just in case.
17:26:19 <rwbarton> no I mean like we have variables that range over values, variables that range over types
17:26:35 <monochrom> great idea. haskell has global variables already. just immutable.
17:27:02 <monochrom> "drop" is a global variable that has a useful function
17:28:00 <monochrom> what if type variables were mutable?!
17:28:34 <bitemyapp> laziness subsumes most everyday uses of mutability.
17:28:43 <bitemyapp> for everything else there's masterca^H^H^H^H^H^H ST
17:28:46 <vanila> haha
17:29:14 <chrisdotcode> :t drop
17:29:15 <lambdabot> Int -> [a] -> [a]
17:29:28 <chrisdotcode> I feel like "drop" should be the opposite of lift or something
17:29:31 <monochrom> "the price of take n [1..]: O(n)"
17:29:36 <chrisdotcode> drop :: m a -> a
17:29:45 <chrisdotcode> unsafeness everywhere! :D
17:30:06 <monochrom> err, restart, that didn't start right
17:31:49 <monochrom> "the cost of take 1 (sort xs): O(n).  the cost of take 1 xs: O(1).  the look of your face in amazement: priceless"
17:32:39 <monochrom> @quote safeFromJust
17:32:39 <lambdabot> monochrom says: I use safeFromJust :: Maybe a -> Maybe a
17:32:59 <ion> hah
17:33:09 <ion> safeFromJust = unsafeCoerce
17:33:30 <rwbarton> ion, in 7.8, you can use coerce now
17:33:42 <monochrom> safeCoerce :: a -> a; safeCoerce = unsafeCoerce
17:34:33 <chrisdotcode> :t unsafeCoerce
17:34:34 <lambdabot> Not in scope: â€˜unsafeCoerceâ€™
17:34:41 <chrisdotcode> what's the :t guys?
17:34:50 <hexagoxel> reallySafeCoerce :: a -> Maybe a
17:35:00 <hexagoxel> reallySafeCoerce _ = Nothing
17:35:06 <benzrf> hexagoxel: :-D
17:35:06 <chrisdotcode> lol
17:35:12 <monochrom> unsafeCoerce :: a -> b
17:35:57 <chrisdotcode> how does it work?
17:36:05 <chrisdotcode> is it a typeclass function?
17:36:12 <monochrom> it is a front-end to a compiler built-in
17:36:41 <monochrom> the compiler built-in can, of course, ignore types at that low level
17:37:13 <chrisdotcode> oh, so instead of typing "a :: b", you could use unsafeCoerce a, and the compiler would do the rest?
17:37:23 <monochrom> yes
17:37:52 <Eduard_Munteanu> chrisdotcode: a :: b isn't a type cast.
17:38:07 <monochrom> or rather, the compiler would do nothing, for example would skip type checks
17:38:22 <chrisdotcode> Eduard_Munteanu: what is it?
17:38:58 <Eduard_Munteanu> chrisdotcode: it asserts the type of a thing, which is further subject to checks that it matches the inferred type.
17:38:59 <monochrom> well, skipping type checks is probably not how it is done either. instead, probably more like a pretense.
17:39:33 <monochrom> "a :: b" is more a reminder than a cast
17:39:36 <Eduard_Munteanu> chrisdotcode: e.g. f :: Int -> Char; f x = x :: Char  is a type error
17:39:58 <Eduard_Munteanu> Because you say x is Char, but x is Int and Char isn't Int.
17:40:25 <fuzzyhorns> hindley milner isnt structural typing is it?
17:40:30 <chrisdotcode> Eduard_Munteanu: yeah, I knew that. I just got the precise semantics wrong :)
17:40:48 <monochrom> hindley milner is orthogonal to structural typing
17:41:11 <fread2282> coerce thakes a phantom typeclass and uses roles in 7.8
17:41:13 <fuzzyhorns> monochrom: does haskell have structural typing? maybe i misunderstand what it is
17:41:21 <fread2282> :t coerce
17:41:23 <lambdabot> (Contravariant f, Functor f) => f a -> f b
17:41:25 <fuzzyhorns> monochrom: it makes sense that nominative is explicit type-casts
17:41:35 <fread2282> not that one
17:42:03 <monochrom> how about this. "type X = Int -> Bool" is structural typing. "newtype Y = YC (Int -> Bool)" is nominal typing.
17:42:32 <fuzzyhorns> i dont know what newtype is yet :c
17:42:33 <fuzzyhorns> sorry
17:42:45 <fread2282> Data.Coerce.coerce
17:42:49 <monochrom> if you know nominal typing, then you already know newtype.
17:43:47 <fuzzyhorns> so newtype is how you explicitly define a new type?
17:43:53 <benzrf> fuzzyhorns: to be precise
17:43:55 <fuzzyhorns> sorry for my newb queries
17:43:58 <benzrf> fuzzyhorns: data is how you make a new type
17:44:04 <benzrf> fuzzyhorns: type is how you make a new type /synonym/
17:44:41 <benzrf> fuzzyhorns: newtype is how you make something that functions like a new type a la data but becomes just a type alias after compilation
17:44:46 <fread2282> fuzzyhorns: newtypes, however, unlike 'type' type synonyms, aren't the same as the inner type
17:45:01 <monochrom> I recommend not relying on English "new" and English "type" to understand "newtype". someone thought up that name, it may or may not be accurate.
17:45:03 <benzrf> fuzzyhorns: in practice, a newtype declaration generally acts exactly like a data decl
17:45:15 <benzrf> fuzzyhorns: except that you must have exactly one constructor with exactly one field
17:45:21 <benzrf> fuzzyhorns: the main difference between
17:45:25 <benzrf> data Foo = Bar Int
17:45:27 <benzrf> and
17:45:32 <benzrf> newtype Foo = Bar Int
17:45:50 <benzrf> fuzzyhorns: is that once compilation finishes, the actual program will use an Int anywhere you had a Foo
17:46:01 <fread2282> fuzzyhorns: but you get GeneralizedNewtypeDeriving and guaranteed 0 overhead
17:46:03 <fuzzyhorns> so it is just aliasing a type
17:46:12 <Axman6> no
17:46:18 <benzrf> fuzzyhorns: it's aliasing a type, except that it acts as a new type
17:46:24 <benzrf> fuzzyhorns: at runtime it's only an alias
17:46:29 <benzrf> but at compile time it acts like a new type
17:46:30 <fread2282> fuzzyhorns: no, it isn't equal to the inner type during typechecking
17:46:30 <Axman6> newtype lets you wrap another type so you get type safety
17:46:36 <Axman6> but has no compile time overhead
17:46:46 <benzrf> Axman6: you mean post-compile time
17:46:51 <silasm> type safety /and/ different typeclass instances
17:46:56 <Axman6> uh yeah
17:47:01 <fuzzyhorns> fread2282: sorry inner/outer distinction idk yet
17:47:18 <fread2282> fuzzyhorns: newtype Foo = Foo Int Foo is outer, Int is inner
17:47:20 <Axman6> so, if you wrote type Day = Int; type Year = Int, you could add 7::Day and 2014::Year
17:47:27 <fuzzyhorns> so rather than aliasing it is more like copying in prototypal systems?
17:47:30 <fread2282> fuzzyhorns: newtype Foo = Foo Int           Foo is outer, Int is inner
17:47:40 <Axman6> so, if you wrote type Day = Day Int; newtype Year = Year Int, you cannot add 7::Day and 2014::Year
17:48:11 <davidthomas> fuzzyhorns: If you know C, newtype Foo = Foo Int is struct Foo { int value; }; type Foo = Int is typedef int Foo;
17:48:34 <Axman6> I should remember that explanation
17:48:42 <fuzzyhorns> davidthomas: ooooohhhhhhhh
17:48:49 <Axman6> (also, using structs like that can give you awesome type safety in C)
17:49:05 <davidthomas> data Foo = Foo Int is closer to struct Foo { int type; int *value; }
17:49:10 <benzrf> Axman6: you cant have type Day = Day Int
17:49:29 <monochrom> that was a typo :)
17:49:29 <Axman6> oh that was supposed to be newtype
17:49:45 <monochrom> or shall I say, type typo :)
17:50:03 <Axman6> a typeo
17:50:25 <fuzzyhorns> x)
17:50:34 <monochrom> anyway, see why I said "type X = ..." is structural, "newtype Y = ..." is nominal, and why you already know newtype.
17:50:34 <fuzzyhorns> thank you for your patient explanations
17:53:10 <benzrf> fuzzyhorns: just treat the 'newtype' keyword as though it were 'data' and you should be perfectly fine in 95% of cases
17:53:26 <fread2282> what's cheaper: newtype Foo = Foo (a, b) or data Foo = Foo a b?
17:53:36 <benzrf> fuzzyhorns: just remember that if you're declaring a type purely for the purpose of wrapping another one for some reason, make a newtype and not a data
17:53:56 <monochrom> they are equally cheap
17:54:05 <davidthomas> fread2282: I'd kind of expect them to be the same - you've got one constructor involved
17:54:43 <Axman6> yeah they should have the same representation at rumtime I think
17:55:31 <monochrom> Foo is always cheaper
17:55:42 <fuzzyhorns> benzrf: good to know :)
17:56:47 <silasm> you just use a newtype when you're using the exact same data in a different way, e.g. ints as sums vs. as products (where you redefine the monoid typeclass) or ints as weights vs. as heights (where you just use the added type safety newtype wrapping gives you).
17:58:24 <silasm> I don't feel like the "no runtime cost" part of newtypes is essential to understanding them; though it might be essential to understanding why they exist when data already does.
18:01:38 <monochrom> nutype List a = C (Either () (a, List a))
18:02:18 <Axman6> s/t/p/g
18:02:18 <monochrom> also, http://www.vex.net/~trebla/tmp/nu.txt
18:02:45 <monochrom> also, http://www.vex.net/~trebla/tmp/moo-nad.txt
18:03:14 <Axman6> monochrom: a friend of mine runs this: http://cowfortun.es
18:03:26 <Axman6> get daily cow fortune emails!
18:03:53 <oisin640> I'm having a bit of a problem implementing the determinant function. I still haven't gotten the hang of using types - could someone take a look at this error message and steer me in the right direction? http://lpaste.net/105141
18:05:44 <Axman6> oisin640: negateEverySecond is working on lists not Matrix
18:06:14 <Axman6> (x:y:xs) = x : (-1 * y) : negateEverySecond xs should be (x:/y:/xs) = x :/ (-1 * y) :/ negateEverySecond xs right?
18:06:31 <Axman6> oh, nevermind
18:06:44 <silasm> oisin640: are you trying to use dependent types in haskell?
18:07:05 <oisin640> Axman6: Sorry, I had to double check that. It's a list because of the comrehension
18:07:07 <oisin640> silasm: Yes
18:07:23 <jle`> what happened to the runtime cost of something like map getSum [Sum 1, Sum 2]?
18:07:27 <vanila> it's GADTs, not dependent types
18:07:40 <jle`> does it get turned into a map id [1,2] ?
18:07:43 <jle`> but that still has overhead
18:07:46 <jle`> over just [1,2], right?
18:07:53 <Axman6> oisin640: I don't see where you convery your Matrix into a list, am I missing something?
18:08:15 <Axman6> oh, using rhe get and getRow functions
18:08:36 <oisin640> Axman6: No, just using [ .. | .. ]
18:09:03 <Axman6> right, but you're selecting the elements of the matrix using get and getCol
18:09:13 <Axman6> uh, getRow
18:09:45 <oisin640> Axman6: Ah, yeah, sorry - getRow returns a vector, getCol returns a vector, and get returns an element.
18:10:30 <vanila> I think you'll have to post full code
18:10:39 <oisin640> vanila: Sure, one second
18:11:11 * hackagebot influxdb 0.4.2 - Haskell client library for InfluxDB  http://hackage.haskell.org/package/influxdb-0.4.2 (MitsutoshiAoe)
18:12:29 <oisin640> vanila: http://lpaste.net/105142 That should be most of it
18:13:48 <enthropy> oisin640: scale a $ determinant matrix  -- should have those functions in the other order?
18:13:55 <vanila> I meant something I could try loading into ghc
18:14:30 <enthropy> scale wants something like `f  a` as the second argument, but determinant gives you an `e'
18:14:55 <enthropy> either that or   a * determinant matrix
18:15:44 <oisin640> enthropy: I guess that should be just a * $ determinant matrix
18:17:43 <enthropy> sounds right (but you don't need the $)
18:18:58 <oisin640> enthropy: Ah, thanks. The only error I'm left with, and the stickiest one for me, is Expected type: Matrix ('Succ r0) ('Succ c0) e, Actual Type: Matrix r c e
18:19:06 <oisin640> because of dropRow and dropCol, I think
18:21:12 * hackagebot vector 0.10.11.0 - Efficient Arrays  http://hackage.haskell.org/package/vector-0.10.11.0 (DanDoel)
18:22:05 <enthropy> one way around that would be to write    class Num e => Deteriminant r c e where determinant :: Matrix r c e -> e
18:22:29 <oisin640> vanila: http://lpaste.net/105145 That's the entirety of it
18:22:36 <enthropy> then have a separate instance for Determinant Zero Zero e
18:22:51 <oisin640> enthropy: Ahh, I see
18:23:01 <enthropy> that's not taking advantage of GADTs though
18:23:22 <enthropy> you're paying a price for using them (they are strict, worse for type inference)
18:24:55 <enthropy> probably you can write `determinant :: Num e => Matrix r c e -> e' and it'll work if you have a separate equation for determinant EmptyMatrix = 1
18:26:40 <oisin640> enthropy: 1. Is the e -> e' differenation important? 2. I get the same error when I drop the Succ's.
18:27:44 <oisin640> Because, I think, the m variable coming in "binds" (?) the r and the c variables to a specific size. Then, when I try to recursively call determinant on a dropRow matrix, the size is too small?
18:27:58 <enthropy> the second e should be e too
18:29:01 <oisin640> Well, I got rid of the dropRow error by matching on m@(_ :/ _)
18:29:07 <oisin640> but I still have one error left for dropCol
18:30:36 <oisin640> and I fixed it, I think, by writing m@((_ :> _) :/ _)...!
18:37:53 <oisin640> enthropy: That was it - thanks very much :)
18:38:34 <enthropy> you wrote a class or did you manage to write just a function?
18:40:34 <oisin640> enthropy: Just the function with more specific pattern
18:41:20 <oisin640> enthropy: I guess it just wanted assurance that the matrix had at least one row and at least one column
19:32:22 <chrisdotcode> so guys, how usable (and stable) is wreq?
19:35:54 <carter> jle`: look at rounded
19:35:55 <carter> @google rounded github ekmett
19:35:56 <lambdabot> https://github.com/ekmett/rounded
19:37:51 <carter> @tell jle`  https://github.com/ekmett/rounded
19:37:52 <lambdabot> Consider it noted.
19:42:05 <shelf> any way to get at unexported names in ghci these days?
19:42:42 <enthropy> shelf: template haskell
19:42:56 <enthropy> @hoogle mkNameG
19:42:57 <lambdabot> Language.Haskell.TH.Syntax mkNameG :: NameSpace -> String -> String -> String -> Name
19:42:57 <lambdabot> Language.Haskell.TH.Syntax mkNameG_d :: String -> String -> String -> Name
19:42:57 <lambdabot> Language.Haskell.TH.Syntax mkNameG_tc :: String -> String -> String -> Name
19:44:46 <enthropy> or if you have the source, load the module as interpreted code
19:46:19 <shelf> enthropy: i have the source, i'm interpreting it. must be ghci-ing wrong
19:46:55 <shelf> I load with :m +TypeChecker, doesn't seem to work
19:47:26 <enthropy> :m +*TypeChecker?
19:51:43 <shelf> yep! thanks!
20:07:32 <Kya18>  Here some videos. I hope you like them! http://bitly.com/1kEo7j0
20:09:38 <mayski> why did I click on that
20:09:40 <mayski> ._.
20:14:30 <benzrf> im sleep now
20:39:35 <pavonia> Is there a way to get the output of GHCi's :browse from a command line call?
20:44:16 <rwbarton> ghc -e ':browse Prelude'
20:51:16 <pavonia> rwbarton: Thanks. Is it possible to get that for not installed modules too?
20:51:31 * hackagebot vty 5.0.1 - A simple terminal UI library  http://hackage.haskell.org/package/vty-5.0.1 (CoreyOConnor)
20:52:45 <pavonia> Ah, never mind, you have to specify the full path for :load
20:56:31 * hackagebot vty 5.0.2 - A simple terminal UI library  http://hackage.haskell.org/package/vty-5.0.2 (CoreyOConnor)
21:30:07 <carter> heatsink: i bet it doesnt' happen if you delete all the hi / ho files and build anew?
21:30:30 <heatsink> I tried that, it still happens
21:30:50 <carter> oh pooo
21:31:35 * hackagebot stable-tree 0.0.1 - Trees whose branches are resistant to change  http://hackage.haskell.org/package/stable-tree-0.0.1 (tsuraan)
22:28:52 <cieloesazul> so, i'm really confused about indenting my xmonad.hs file in emacs. is there some other way to indent my haskell file automatically? I erroneously indented the whole file and now it won't compile :(
22:29:22 <johnw> you can't auto-indent a whole file
22:29:45 <johnw> if any tool knew how to do that automatically, it would mean indentation wouldn't matter
22:31:33 <cieloesazul> johnw: thanks for the insight
22:36:11 <orzo> is there any published guide for categorizing code into hierachical modules?
22:36:12 <orzo> for meshing with the rest of the haskell/hackage ecosystem
22:37:32 <johnw> not that I've seen
22:37:49 <johnw> most people seem to pick Control or Data or just start their hierarchy at top level
22:38:23 <johnw> Control seems to be more for functional abstractions, and Data for data abstractions, but I've seen example (like Data.Conduit) which don't follow that
22:53:51 <solidus-river> hello all
22:54:04 <solidus-river> what is the compiler telling me when it says it cannot deduce (a ~ Database)
22:54:07 <milieu> Hello
22:54:53 <solidus-river> i'm trying ot use typefamilies and Database is an instance of the type family that i'm using and i have a constraint on a that it is a member of the typefamily
22:55:24 <solidus-river> could i not be importang the instancing of it to the type faily? but i thought (Database(..)) should import all constructors and instances
23:01:16 <jle`> carter: thanks, but i think i mean more like experimental and measurement uncertainty
23:02:18 <solidus-river> i created a minimal bit of code
23:02:25 <solidus-river> http://lpaste.net/105151
23:02:50 <solidus-river> can someone explain to me what the compiler doesnt like about that?
23:03:34 <solidus-river> it seems ot not think that a is an instance of DatabaseHandler
23:03:56 <solidus-river> or it doesnt like that a is supposed to be Databas and an instance of DatabaseHandler but Database is an instance of DatabaseHandler
23:05:00 <Maxdamantus> solidus-river: it wouldn't be for all `DatabaseHandler a => a`
23:05:07 <Maxdamantus> solidus-river: it would be only for `Database`
23:05:42 <solidus-river> Maxdamantus: a little lost on that
23:05:47 <Maxdamantus> solidus-river: when you introduce type variables, you're saying you don't care what type might actually fill it.
23:06:04 <solidus-river> haskell explicitly puts a for all DatabaseHandler a => a
23:06:15 <Maxdamantus> you're saying "for all types", possibly with some constraints (specified with =>)
23:06:30 <solidus-river> Maxdamantus right, but eventaully, i do need to make that constraint specific in the code
23:06:31 <jle`> haskell puts it for you?
23:06:36 <solidus-river> unless i make the loading function part of the type family as well
23:07:19 <solidus-river> jle`: that was a munging of reading about type families when it mensions that
23:07:32 <jle`> solidus-river: that error sounds like you're declaring too general of a type
23:07:48 <solidus-river> jle`: aye, i am, but thats because i want to be flexible for the future
23:07:56 <solidus-river> er, for future iterations of this program
23:07:59 <Maxdamantus> solidus-river: and your actual code isn't flexible.
23:08:00 <jle`> but your functions only work on Database
23:08:05 <Maxdamantus> solidus-river: because it's using specifically Database.
23:08:10 <jle`> what is the type of Y.lookup ?
23:08:17 <jle`> also
23:08:21 <jle`> wait, no, line 33
23:08:26 <jle`> you literally return a Database
23:08:32 <solidus-river> right
23:08:53 <solidus-river> hmm
23:08:54 <jle`> so...you can't literally return a Database, and say that your function returns *any desired DatabaseHandler*
23:08:55 <Maxdamantus> @let f :: Num a => a -> a; f n = n + (1 :: Int)
23:08:56 <lambdabot>  .L.hs:155:12:
23:08:57 <lambdabot>      Could not deduce (a ~ Int)
23:08:57 <lambdabot>      from the context (Num a)
23:08:57 <lambdabot>        bound by the type signature for L.f :: Num a => a -> a
23:08:57 <lambdabot>        at .L.hs:150:6-22
23:09:05 <solidus-river> i think i need better encapsulation of my type family
23:09:11 <Maxdamantus> That's a simplified version of the same problem.
23:09:21 <solidus-river> i should make loadDatabase an instance of the type family that takes a string that qualifies it
23:09:27 <Maxdamantus> The definition isn't true to the type, because it only works where `a` is `Int`
23:09:36 <jle`> that's like saying myConst :: Num a => a; myConst = (1 :: Int)
23:09:49 <jle`> myConst should be able to be *any Num* that is asked for, when it's used somewhere
23:10:05 <jle`> if i use myConst and want it to be an Integer or a Float or a Double or a Complex, it should work
23:10:16 <jle`> but i literally made it an Int, so that doesn't really work out
23:10:39 <solidus-river> jle`: interesting, so how do you bridge the gap in function types when you have a function that presents a concrete type and want to use it with a function that will take all of a more general type
23:10:51 <jle`> you need something return-type-polymorphic
23:11:09 <jle`> myConst :: Num a => a; myConst = 1 works, because 1 is a polymorphic literal that can be any Num you want
23:11:32 <jle`> aMaybe :: Num a => Maybe a; aMaybe = Nothing works
23:11:43 <jle`> because Nothing can be any Maybe a
23:11:51 <solidus-river> hmm, i get it
23:12:02 <solidus-river> so is there any reason i couldnt do what i said earlier using type families
23:12:06 <jle`> @src map
23:12:06 <lambdabot> map _ []     = []
23:12:06 <lambdabot> map f (x:xs) = f x : map f xs
23:12:11 <solidus-river> where i make loadDatabase an instance of the DatabaseHandler type class
23:12:37 <solidus-river> that takes a Y.config and a string as an argument?
23:13:00 <ion> The type â€œaâ€ can be thought of as an implicit parameter, in pseudo syntax a call to your f might look like â€œf Double 42â€ if it was explicit instead.
23:13:46 <robbie> hello
23:14:17 <solidus-river> I think i get it
23:14:32 <Maxdamantus> solidus-river: it might be worth pointing out that there are no subtypes in Haskell.
23:15:05 <solidus-river> if i want to generalize my code this way before i have more than one type of database i'm interacting with i'll need an enumerable of possible database types and base the loadDatabase call off of a data instance in the typeFamily of one of those enumerables
23:15:19 <robbie> @help
23:15:20 <lambdabot> help <command>. Ask for help for <command>. Try 'list' for all commands
23:15:27 <solidus-river> Maxdamantus: i don't really want a subtype, i want a somewhat flexible interface
23:15:48 <jle`> hi robbie
23:16:09 <robbie> @type 5
23:16:10 <lambdabot> Num a => a
23:16:15 <robbie> :t 5
23:16:16 <lambdabot> Num a => a
23:16:17 <solidus-river> bah, i'll take one more whack at this crazy solution i'm trying to get at then i'll just define concrete types
23:16:53 <Maxdamantus> solidus-river: it looks like you're expecting to be able to return a `Database` because you think it's a subtype of `DatabaseHandler a => a`.
23:17:15 <Maxdamantus> as you might do in a language with subtypes, like Java.
23:17:29 <Maxdamantus> DatabaseHandler loadDatabase(..){ return Database(..); }
23:17:40 <solidus-river> Maxdamantus: kind of, the problem is in the code I want to allow flexible definition of what a Database is and abstract the connect / migrate part of it and then leave it up to different database types to define that datatype and functions to handle migrations
23:17:57 <pqmodn> solidus-river: suppose you do return a concrete type. let x = (5 :: Double), but a type that's an instance of some class, like Num. the client code that interfaces with 'x' can be polymorphic, f :: Num a => a -> a; f x = 2 * x
23:18:20 <pqmodn> just a thought
23:18:30 <Maxdamantus> Some Java code that might be comparable would be: <T extends DatabaseHandler> T loadDatabase(..){ return Database(..); }
23:18:41 <jle`> solidus-river: you have to find some sort of generic way of returning a "database thing" then
23:18:54 <jle`> that can be generalized or polymorphic to all DatabaseHandlers
23:19:05 <Maxdamantus> which is invalid, because you should be able to make T some other type that extends DatabaseHandler.
23:19:13 <Maxdamantus> but it would try to create a Database anyway.
23:19:15 <solidus-river> jle`: aye, i wonder if i can do it via this example https://www.fpcomplete.com/school/to-infinity-and-beyond/pick-of-the-week/type-families-and-pokemon
23:20:40 <jle`> solidus-river: maybe have a makeResult :: String -> Int -> String -> String -> String -> a be a part of your typeclass
23:20:58 <jle`> then makeResult :: DatabaseHandler a => String -> Int -> String -> String -> String -> a
23:21:36 <jle`> either that, or make loadDatabaseHandler be a part of the typeclass too
23:21:55 <Maxdamantus> solidus-river: I don't think type families will help you.
23:22:05 <jle`> you can't make it use Database; what if you had a different DatabaseHandler instance that has nothing to do with Database ?
23:22:38 <jle`> think hard about what you really want to make generic
23:22:43 <jle`> if anything, make it concrete first
23:22:46 <jle`> genericize it later
23:23:14 <solidus-river> jle`: right, so i was thinking having a data declaration in the typeFamily class that was of Databasetype a
23:23:24 <solidus-river> and they could declare an enumerator that was that
23:23:53 <solidus-river> then a member of that class loadDatabase that took a Databasetype a and a Y.Config and returned itself
23:23:56 <solidus-river> damn
23:23:57 <solidus-river> it cant return itself
23:24:16 <solidus-river> i'm looking for a polymorphic constructor for a typeFamily
23:24:39 <solidus-river> maybe
23:24:42 <solidus-river> jle`: already made it concrete
23:24:50 <solidus-river> jle`: now i'm on the generalizing pass
23:25:17 <Maxdamantus> :t fromInteger
23:25:18 <lambdabot> Num a => Integer -> a
23:25:37 <Maxdamantus> > fromInteger 5 :: Double
23:25:38 <lambdabot>  5.0
23:25:44 <Maxdamantus> > fromInteger 5 :: Rational
23:25:45 <lambdabot>  5 % 1
23:26:06 <Maxdamantus> fromInteger is defined for all `a` where there is a `Num a` instance.
23:26:37 <Maxdamantus> so you can't define it as returning a Double.
23:26:55 <Maxdamantus> because then it wouldn't work for `Integer -> Int`
23:27:19 <solidus-river> Maxdamantus: interesting, that looks like exactly the behavior i want
23:27:28 <solidus-river> Maxdamantus: but how is that implimented
23:27:44 <solidus-river> Maxdamantus: can you have an overloaded function thats a member of a class?
23:27:49 <Maxdamantus> solidus-river: each fromInteger function is defined in a Num instance.
23:28:12 <Maxdamantus> solidus-river: maybe what you want is to just move your function into the instance and add a declaration to the class.
23:28:51 <Maxdamantus> class DataBaseHandler a where { ..; loadDatabase :: Y.Config -> IO a }
23:29:22 <solidus-river> Maxdamantus: aye, but then the problem arises as to how i decide which instance to instantiate
23:29:38 <solidus-river> at some point in the Loading logic i'll need to allow a case statement on database types or infer them from the config
23:29:41 <Maxdamantus> solidus-river: it's inferred if possible.
23:29:46 <solidus-river> and then i have to take that specific and make it general to work in the rest of the logic
23:31:44 <solidus-river> Maxdamantus: what about { ..; loadDatabase :: Y.config -> DatabaseType a -> IO a } where DatabaseType a is a data member of the type family
23:32:24 <solidus-river> would that be sufficient for it to be inferrable for all a
23:32:35 <Maxdamantus> I think you're still trying to come up with solutions for something irrelevant to Haskell.
23:32:36 <solidus-river> and keep the return type of it generalized to Database a
23:33:07 <solidus-river> Maxdamantus: then how am i supposed to encapsulate slightly different data declarations that follow the same logic for a central module to handle that logic
23:33:12 <Maxdamantus> You need to understand that something like `Num a => a` is not a supertype of `Int`
23:34:15 <solidus-river> Maxdamantus: i'm not thinking about that as a supertype, i'm thinking about it more as an interface
23:34:38 <solidus-river> so by saying data Blah is an instance of Num a your saying it can be treated safely as a Num
23:34:56 <solidus-river> which is pretty equivalent to interfaces in other languages
23:35:03 <solidus-river> but i don't know if thats the right way to map it
23:35:16 <Maxdamantus> No. interfaces in Java are supertypes of the classes that implement them.
23:35:36 <Maxdamantus> type classes in Haskell are like interfaces for types, rather than interfaces for values.
23:35:38 <cehteh> is there any interpreted scripting language on top of haskell which one can link to a program, something which just works without jit/recompilation and w/o haskell development stuff installed, performance is no issue
23:35:59 <solidus-river> but i want to indicate that there can be many data definitions for a Database description, but they all have the same properties in that they can return a connection and run a migration of their type
23:36:05 <Maxdamantus> So an `Int` value doesn't conform to some `Num` interface.
23:36:54 <solidus-river> Maxdamantus: so would you argue that TypeFamilies are never a good idea then?
23:37:34 <Maxdamantus> I would argue that type families aren't relevant here.
23:37:46 <solidus-river> Maxdamantus: i don't understand how they are not
23:37:57 <solidus-river> i'm trying to define a family of types so i can do 3 actions on all of the types
23:38:01 <solidus-river> thats the end goal
23:38:11 <jle`> 3 actions...?
23:38:12 <solidus-river> i have like 18 actions i can do irrelevant to what instance of the family Database is
23:38:13 <Maxdamantus> That's what classes are for.
23:38:16 <solidus-river> right
23:38:18 <solidus-river> the three in that class
23:38:27 <solidus-river> i want to be able to retrieve a Connection thing
23:38:34 <solidus-river> i want to be able too run a Migration thing
23:38:35 <Maxdamantus> You add the special cases to the instance.
23:38:50 <Maxdamantus> eg, the special case where you do `return Database { .. }`
23:39:19 <Maxdamantus> Then you can derive more general operations from those, which are described in abstract in the class.
23:39:43 <solidus-river> Maxdamantus: so is there no way in haskell to generically load data from configuration into a type of classes?
23:40:02 <solidus-river> i guess maybe i'm misunderstanding how smart haskell is about inference
23:40:10 <solidus-river> if i have a class that is Database
23:40:13 <jle`> you write a typeclass that loads inteface
23:40:33 <jle`> class InterfaceLodable a where loadInterface :: FilePath -> IO a
23:41:00 <solidus-river> jle`: but then in my loader i need to write special cases for every instance
23:41:01 <jle`> and so you write a type InterfaceX and make it an instance
23:41:03 <solidus-river> that seems needless
23:41:18 <jle`> how would you avoid it otherwise?
23:41:28 <Maxdamantus> solidus-river: if they are special, then yes, you need special cases.
23:41:49 <Maxdamantus> solidus-river: if they're not special, you can avoid referring to things like `Database` and just use things provided by the class.
23:42:00 <solidus-river> hmm
23:42:11 <solidus-river> maybe i should sleep on this all and think
23:42:16 <jle`> how would you avoid implementing (+) separately for every Num?
23:42:17 <Maxdamantus> `Database` is special.
23:42:20 <solidus-river> so what benefit do TypeFamilies bring
23:42:47 <jle`> do you expect to be able to define (+) once, and have it work on every Num?
23:42:57 <jle`> hardware integers, church encoded numerals, hardware floats ...?
23:43:00 <solidus-river> i thought the objective of them was to cut down on the special cases for things that aren't needed
23:43:25 <solidus-river> jle`: no but i expect every DatabaseHandle to be able to take a generic Migration thing and do it
23:43:28 <Maxdamantus> The aim is to cut down on code duplication.
23:43:43 <Maxdamantus> eg, a ternary add operator can be defined in terms of (+)
23:43:44 <solidus-river> Maxdamantus: right, but thats why it was appealing to me
23:43:52 <Maxdamantus> add3 a b c = a + b + c
23:44:14 <Maxdamantus> You don't need to write: add3Ints a b c = a +int b +int c
23:44:25 <Maxdamantus> add3Doubles a b c = a +double b +double c
23:44:40 <solidus-river> Maxdamantus: but you could do that with normal Classes in haskell, you wouldn't need TypeFamilies
23:44:58 <Maxdamantus> You assume that (+) exists for both Int and Double, so you automatically get an add3 for Ints and an add3 for Doubles.
23:45:27 <solidus-river> Maxdamantus: but isn't that just an aspect of Classes in haskell not one of TypeFamilies?
23:45:29 <Maxdamantus> solidus-river: yes, and that's what classes let you do.
23:45:50 <Maxdamantus> Oh, you were asking if that's what type families are for?
23:45:55 <Maxdamantus> No. That's what classes are for.
23:47:47 <solidus-river> Maxdamantus: aye, so i'm wondering what the point of TypeFamilies then is
23:48:42 <Maxdamantus> Well, they're not actually part of Haskell, so they can't be that important.
23:48:46 <jle`> heh
23:49:19 <solidus-river> I thought the only thing they added was a slight cut down on boilerplate by letting you defining a class of types that can work in your instance
23:49:30 <solidus-river> if you look at the pokemon example on fp complete
23:49:39 <solidus-river> it seems like the only thing they bring ot the table is condensing code
23:49:46 <solidus-river> which is probably why they aren't part of haskell
23:49:50 <jle`> one useful thing i've seen them used for is for Functor/Monad/etc. with constraints
23:49:51 <solidus-river> but i think condensed code is pretty valuable
23:49:55 <solidus-river> so i'm trying to work out how to use them
23:51:49 <solidus-river> hmm, i'm going to sleep on it and see if things click after caffiene hits me in the morning :)
23:52:12 <solidus-river> jle`: Maxdamantus thanks for helping me understand things more
23:52:23 <Maxdamantus> np
23:53:24 * hackagebot egison 3.3.6 - Programming language with non-linear pattern-matching against unfree data  http://hackage.haskell.org/package/egison-3.3.6 (SatoshiEgi)
