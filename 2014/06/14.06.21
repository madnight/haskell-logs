00:00:03 <WraithM> MP2E: Thanks!
00:06:36 <freecoder> is there a way to do something like 'take x (repeat x)' (where x is defined as, say, 5). i tried but it seems take won't take a variable as its first arg
00:06:56 <freecoder> or is there an alternative?
00:07:26 <Axman6> I'm not sure what you mean
00:07:30 <augur> freecoder: uh
00:07:40 <augur> > let x = 5 in take 5 (repeat 5)
00:07:41 <Axman6> that's just replicate x x by the way
00:07:41 <lambdabot>  [5,5,5,5,5]
00:07:45 <Axman6> > replicate 5 5
00:07:46 <lambdabot>  [5,5,5,5,5]
00:07:52 * hackagebot JustParse 2.0 - A simple and comprehensive Haskell parsing library  http://hackage.haskell.org/package/JustParse-2.0 (grantslatton)
00:07:52 * hackagebot blank-canvas 0.4.0 - HTML5 Canvas Graphics Library  http://hackage.haskell.org/package/blank-canvas-0.4.0 (AndyGill)
00:07:58 <lfairy> > join replicate 5
00:07:59 <lambdabot>  [5,5,5,5,5]
00:09:16 <freecoder> i meant if i want do not want to explicitly do it for 5. it can be any value
00:10:00 <freecoder> let x = 5
00:10:01 <freecoder> take x (repeat x)
00:11:08 <Axman6> were you remy earlier?
00:11:19 <Axman6> because exactly the same question was asked
00:11:25 <freecoder> nope
00:11:55 <Axman6> try let x = 5 :: Int
00:12:23 <freecoder> great!
00:12:32 <Axman6> then take x (repeat x) should work (because take expects an Int, but ghci defaults to making x an Integer if you don't tell it which type to use)
00:13:40 <freecoder> ok
00:14:10 <freecoder> then how do i convert x to Int in a list comprehension, where x is an element of a list
00:14:57 <Axman6> what type is x?
00:15:04 <Axman6> I assume you have [Integer]?
00:15:20 <freecoder> i guess, x will be an element of a list
00:15:22 <Axman6> because... this exactly the same set of questions that was asked like two hours ago :P
00:15:34 <Axman6> freecoder: that doesn't tell me anything about the type of x
00:15:34 <freecoder> :)
00:16:28 <freecoder> [ <output x as [Integer]> | x <- <some list> ]
00:16:37 <ninja_code> what is the state of the art in using haskell to write Mac OSX applications? (target is macbooks, not iphones, not ipads)
00:19:11 <MP2E> ninja_code : uhh the latest GHC I suppose :P It builds straight executables, not bundles afaik though
00:19:19 <Axman6> freecoder: <some list> is exactly the thing you need to specify more clearly because that tells us nothing at all
00:19:24 <ninja_code> I need to put it into the mac app store
00:20:24 <Axman6> I'm sure it's possible, but I'd be surprised if there's much info on how to do it
00:20:40 <ninja_code> thanks
00:21:09 <ninja_code> it's like "I know there exists some numbers which will win you millions in lottery, but I'm not sure twhat those numbers are." :-)
00:21:29 <Axman6> I'm sorry I'm not an expert :\
00:21:40 <MP2E> What I'd look into is packaging existing executables into a bundle. It doesn't particularly matter what source language you use in that instance :P
00:21:41 <Axman6> it's not something people try to do bery often
00:21:49 <MP2E> I've made a Mac OS X bundle once with CMake, you could try that
00:22:01 <MP2E> though admittedly it's been a long time and the bundle wasn't particularly great to begin with... soo >_>
00:22:04 <ninja_code> do haskell people not want to write mac apps?
00:22:24 <Axman6> not many people write GUI haskell apps on any platform really
00:22:42 <MP2E> ^ There isn't special NSIS support for Windows setup or special support for any Linux package manager
00:23:04 <MP2E> It's just source -> executable.
00:23:07 <Axman6> it can be done of course, but it's pretty tedious and difficult compared to what people can do with say a web interfact
00:26:01 <neversaynever> hi..i have installed a package using cabal sandbox and when i try to import it in ghci, i get this error : "Could not find module `Math.Algebras.Structures'"
00:26:23 <neversaynever> i added the sandbox/lib folder to my path
00:30:17 <pingu> neversaynever: I'm not sure if that's meant to just work.
00:30:26 <pingu> neversaynever: I've been running ghci from within cabal
00:30:51 <pingu> with cabal exec ghci
00:30:54 <pingu> or cabal repl
00:31:38 <neversaynever> pingu: it worked. thanks
00:42:42 <Total_1mmersion> Any tips for game programming in Haskell? I'm looking at Helm right now and it sounds promising.
00:43:26 <MP2E> Total_1mmersion : I haven't tried Helm, I think lens, mvc, netwire, and sdl2 should be sufficient for making your own game engine. I'll check out helm soon though :P
00:43:55 <Total_1mmersion> I haven't heard of mvc or netwire, I'm going to look those up now
00:45:09 <Axman6> doesn't lens have terrible performance when things are more than trivially complex?
00:45:38 <Axman6> woah, I just found a library I wrote that I have absolutely no memory of
00:45:52 <MP2E> Axman6 : perhaps, I honestly have only used it in trivial cases thus far
00:48:12 <Axman6> this code is crazy. I can completely believe I wrote it, but it's so weird I don't remember it at all. Apparently I wrote it at AusHac 2010
00:49:31 <ion> Were you sleep-deprived?
00:49:39 <ion> What code is it?
00:49:44 <Axman6> possibly
00:50:55 <Axman6> it's something I called a FastMap, stores key->index values in a tree and an IOVector of values. I guess it was a mutable Map implementation with specialisation for various key types
00:52:21 <knapper_tech> How do I convert String to [Char] ?   Couldn't find sig on Hoogle
00:52:29 <Axman6> @src String
00:52:29 <lambdabot> type String = [Char]
00:52:55 <knapper_tech> But...  :-/
00:53:09 <knapper_tech>     Couldn't match type ë[Char]í with ëStringTemplate Stringí
00:53:15 <knapper_tech> how does this look?
00:53:22 <lfairy> that's not a String tho
00:53:23 <knapper_tech> OH
00:53:26 <lfairy> that's a StringTemplate
00:53:30 <Welkin> String == [Char]
00:53:32 <knapper_tech> that's a ...yeah
00:53:41 <Welkin> it's just a type synonym
00:54:05 <edwardk> Axman6: lens plated code is competitive with uniplate. most lens combinators evaporate to the same core you'd hand write
00:54:26 <MP2E> edwardk : good to know! :)
00:54:34 <edwardk> Axman6: there are some expensive folds available to you, if you find its your bottleneck, there is a lot of room to optimize as you go ;)
00:54:46 <knapper_tech>     Couldn't match type ë[Char]í with ëData.Text.Internal.Lazy.Textí
00:55:10 <knapper_tech> still don't understand $ totally I guess.  anyway I think this one is more standard
00:55:13 <edwardk> MP2E: we spent 8 months or so staring at core to make lens fast
00:55:20 <ion> f $ x = f x
00:55:38 <edwardk> MP2E: filed over a dozen bug reports on ghc, figured out evil uses of unsafeCoerce, etc.
00:55:39 <knapper_tech> why bother with it then?
00:56:28 <ion> Some people like to use $ where it reduces parentheses in ‚Äúf‚Äù and ‚Äúx‚Äù. There‚Äôs a balance, doing that may end up hindering the readability of the code.
00:57:28 <ion> ($) has a lower precedence than most other operators.
00:58:05 <ion> ‚Äú(foo . bar) $ baz‚Äù can be written as ‚Äúfoo . bar $ baz‚Äù because of that (but it can also be written as ‚Äú(foo . bar) baz‚Äù)
00:58:16 <Welkin> you can also use ($) to apply a list of functions to a list of inputs
00:58:43 <ion> > map ($ x) [f, g, h :: Expr -> Expr]
00:58:45 <lambdabot>  [f x,g x,h x]
00:59:06 <Welkin> > zipWith ($) [f, g, h] [1,2,3]
00:59:08 <lambdabot>  No instance for (GHC.Show.Show c0)
00:59:08 <lambdabot>    arising from a use of ‚ÄòM302567584107751256729974.show_M3025675841077512567...
00:59:08 <lambdabot>  The type variable ‚Äòc0‚Äô is ambiguous
00:59:08 <lambdabot>  Note: there are several potential instances:
00:59:08 <lambdabot>    instance [safe] GHC.Show.Show
01:00:07 <zwer> > zipWith ($) [f, g, h] [1,2,3] :: [Expr]
01:00:07 <Axman6> > liftM2 ($) [f, g, h] [1,2,3] :: [Expr]
01:00:08 <lambdabot>  can't find file: L.hs
01:00:08 <lambdabot>  [f 1,g 2,h 3]
01:00:10 <Welkin> > zipWith ($) [f, g, h :: Expr -> Expr] [1,2,3]
01:00:11 <lambdabot>  [f 1,g 2,h 3]
01:00:18 <Axman6> hmm
01:01:16 <ion> edwardk: I wonder if it would be feasible for OverloadedRecordFields to provide van Laarhoven lenses (e.g. prefixed by _) in addition?
01:03:35 <edwardk> ion: that's getting pretty 'magical'
01:03:35 <ion> heh
01:06:15 <jamiehannaford> I'm looking at applicative functor for lists and confused by this type: (<*>) :: [a -> b] -> [a] -> [b]
01:06:29 <jamiehannaford> which is the function inside a list here? for Maybe it's just a normal function
01:06:40 <MP2E> jamiehannaford: think of it as a list of functions being applied to a list of a's to make a list of b's
01:07:00 <jamiehannaford> MP2E but why is it a list of functions instead of just 1 function by itself?
01:07:54 <MP2E> map/fmap already provides that :) map's signature is (a -> b) -> [a] -> [b]
01:08:19 <MP2E> but theoretically it still could be only one function, just as singleton list. So in otherwords a list containing only one function.
01:08:27 <MP2E> as a singleton list*
01:08:48 <jamiehannaford> oh right. applicative functors apply a function from a *context* which in this case is the list - so it needs to be a function or functions inside a list
01:08:54 <MP2E> precisely
01:09:12 <jamiehannaford> so does that context have to match the functor type you're applying it to?
01:09:27 <jamiehannaford> so if you're applying it to a Maybe val, does the function have to be wrapped in a Maybe type ?
01:11:04 <MP2E> It does, yes
01:11:42 <MP2E> fmap can elevate pure functions up to operate on Maybe values, so in practice, it's less restricting than it seems.
01:11:57 <MP2E> and then of course, there is monads :P
01:13:10 <jamiehannaford> that's next week for me ;)
01:13:14 <MP2E> hehe
01:16:31 <ion> > [id, (*10), (*100)] <*> [1,2,3]
01:16:31 <lambdabot>  [1,2,3,10,20,30,100,200,300]
01:16:31 <lfairy> <*> zips through the cartesian product of its arguments
01:16:31 <lfairy> [f, g, h] <*> [x, y, z] == [f x, f y, f z, g x, g y, ..]
01:16:31 <Bynbo7> > [f,g,h] <*> [1,2,3] :: [Expr]
01:16:31 <lambdabot>  [f 1,f 2,f 3,g 1,g 2,g 3,h 1,h 2,h 3]
01:16:31 <ion> > do { f <- [id, (*10), (*100)]; x <- [1,2,3]; return (f x) }
01:16:31 <lambdabot>  [1,2,3,10,20,30,100,200,300]
01:16:31 <ion> [ f x | f <- [id, (*10), (*100)], x <- [1,2,3] ]
01:25:51 <ion> > pure (*2) <*> Just 42
01:25:52 <lambdabot>  Just 84
01:25:54 <ion> > pure (*2) <*> [42]
01:25:56 <lambdabot>  [84]
01:26:32 <ion> If you only use lists of length 0 and 1, the instances are equivalent.
01:26:48 <hunt> i think whats holding haskell back the most is how hard it is to install, and ghcs speed
01:27:02 <ion> It‚Äôs hard to install?
01:27:13 <hunt> i can never get it up an running on a new computer in less than an hour
01:27:22 <hunt> its just kind of messy
01:27:27 <hunt> plus whenever im installing it fresh
01:27:33 <hunt> im usually needing to install some packages
01:27:38 <Welkin> just install haskell platform
01:27:38 <hunt> which means i have to touch cabal
01:27:39 <hunt> and cry
01:27:41 <lfairy> are you using a linux distro?
01:27:47 <lfairy> are you using sandboxes?
01:28:06 <hunt> i mean if were talking about installing from scratch lfairy then it varies, i try to use sandboxes but those make things considerably slower in my experience as well
01:28:53 <Axman6> hunt: it takes less than 5 minutes on a mac :\
01:29:09 <Axman6> same for the platform
01:29:13 <hunt> Axman6: what! i just installed it on a mac the other day and it took considerably longer than 5 minutes
01:29:33 <ion> Does it have a 68000?
01:29:56 <Welkin> you need to install linux on your mac
01:29:59 <Welkin> then install haskell
01:30:07 <hunt> also am i the only one whos frustrated by the haskell platform not using ~/.cabal? is that some sort of processor spec ion?
01:30:28 <hunt> Welkin: thankfully im in linux right now, so im fine. but when im not here :'(
01:31:42 <hunt> i just wish this language were more po pular because i love it and its such a bitch to be reinstalling it everywhere i go
01:31:55 <hunt> i feel like we couldve had pythons throne if we werent so avant garde
01:32:08 <Axman6> it uses ~/Library on OS X because that's the preferred thing to do on OS X
01:32:13 <hunt> maybe we need better FFI
01:32:20 <hunt> Axman6: yea i know why they do it, its just frustrating
01:32:39 <haasn> re: avant garde, Avoid success at all costs
01:33:02 <hunt> haasn: were sacrificing our own fame and fortune for the good of programming (hopefully)
01:33:24 <Axman6> make sure you bracket that properly when rading it though
01:33:25 <hunt> its going to be so many years before theres a popular language at all on the same page as haskell or any of the research grade stuff
01:33:31 <Axman6> avoid (success at all costs)
01:33:53 <hunt> i hate programming
01:34:49 <Axman6> I hate not programming, which is why I need a new job
01:34:55 <MP2E> ^
01:34:57 <haasn> Axman6: Huh, I always thought it was (avoid success) at all costs
01:35:07 <Axman6> nope
01:35:16 <Axman6> a common misconception
01:35:20 <haasn> Can I still go with avoiding success, at all costs? :)
01:36:27 <Axman6> if you do, won't you have succeded and thus failed?
01:36:43 <hunt> > let success = success in success
01:36:47 <lambdabot>  mueval-core: Time limit exceeded
01:37:15 <hunt> weve failed to calculate success
01:37:16 <MP2E> Axman6 : lesson learned, if I get a job interview for Haskell, I mustn't go. For if I do, I have violated avoiding success
01:37:30 <MP2E> It's a never ending cycle of poverty!
01:37:55 <MP2E> unless they know the rule and hire me on the spot for following the rule?
01:37:57 <hunt> > let success = wealth in poverty
01:37:58 <lambdabot>  Not in scope: ‚Äòwealth‚ÄôNot in scope: ‚Äòpoverty‚Äô
01:37:58 <lambdabot>  Perhaps you meant ‚Äòproperty‚Äô (imported from Lambdabot.Plugin.Haskell.Eval.Tr...
01:38:06 <MP2E> *paradox ensues*
01:38:15 <zomg> Clever bot
01:38:23 <hunt> lol
01:38:25 <zomg> Property is indeed a good investment!
01:38:36 <Axman6> heh
01:38:38 <zomg> trumpbot
01:38:55 <lfairy> property is the source of all suffering
01:38:55 <hunt> @let success = error "this is haskell"
01:38:57 <lambdabot>  Defined.
01:39:08 <MP2E> haha
01:39:10 <lfairy> #firstworldmarxists
01:39:58 <hunt> > let haskell = True in if Haskell then success else False
01:39:59 <lambdabot>  Not in scope: data constructor ‚ÄòHaskell‚Äô
01:40:06 <hunt> > let haskell = True in if haskell then success else False
01:40:07 <lambdabot>  *Exception: this is haskell
01:40:14 <hunt> ok
01:42:38 <hunt> ok
01:43:06 <hunt> so do you think 10 years from now: haskell will be dead <|> haskell will be popular <|> haskell == haskell now
01:44:06 <MP2E> #2 or #3. If Haskell was going to die, I think it would have already. Personally, I think it will become more popular. Functional Programming languages growth seems to be accelerating, albeit slowly. FP concepts are also being brought to imperative languages :P
01:44:06 <hunt> the floor is now open to bets
01:44:31 <MP2E> Which may increase awareness of Haskell, but on the otherhand, may also push it into obscurity because things are "good enough". I hope that doesn't happen.
01:45:36 <hunt> i think haskell probably wont be the king of FP when that day comes
01:45:45 <hunt> its too foreign to imperative programming imo
01:47:38 <hunt> sorry i accidentally quit, did i miss anything
01:47:45 <Axman6> nope
01:47:46 <hunt> since my last message
01:47:49 <hunt> ah
01:47:50 <hunt> k
01:48:25 <MP2E> True, I don't mind too much, honestly. As long as GHC keeps creating fast code and the language keeps evolving, I'll keep using the language
01:48:36 <Welkin> you missed the discovery of the truth about the universe
01:49:29 <hunt> Welkin: recap?
01:49:34 <MP2E> 42
01:49:40 <hunt> > 42
01:49:42 <lambdabot>  42
01:50:43 <hunt> whats the best use of fucntional programming you guys have ever seen
01:50:57 <hunt> it feels like theres so much power here i just havent used it in a truly mind blowing way yet
01:51:13 <hunt> thats haskells problem is that it has so much power and no ones actually using it
01:51:17 <hunt> it just keeps getting more power
01:51:53 <phi__> I need some help with associated type synonyms
01:52:50 <phi__> http://lpaste.net/4477636936613232640 the code here compiles as it is but not if I uncomment the sole commented line
01:53:01 <MP2E> hunt : djinn, it's a program that can deduce the code of a function, provided the type signature(and some constraints)
01:53:13 <MP2E> i've been playing with it all day and it's still blowing my mind
01:53:13 <MP2E> heh
01:53:28 <phi__> can somebody explain what it will take to uncomment that line
01:55:58 <hunt> phi__: whats the error exactly?
01:56:03 <hunt> phi__: with it uncommented
01:56:56 <phi__> that compiler can't deduce Manifold instances for m3 , m4 , m5
01:58:11 <hunt> phi__: im sorry phi__ this is just way beyond me, im fairly newb at haskell
01:58:17 <ion> That is not the error exactly, that is the error paraphrased.
01:58:19 <hunt> phi__: hopefully someone else can help you more
01:58:40 <hunt> MP2E: thats pretty damn cool
01:58:44 <phi__> no problem hunt, thanks for trying
02:00:05 <phi__> I know ion but ...
02:00:29 <hunt> phi__: maybe paste the error as well for ion, idk
02:01:11 <loz2> flip (.) max $ (.) max
02:01:15 <loz2> point-free wtf
02:01:25 <loz2> ftw*
02:01:28 <mr-> phi__: that's not the error, but is the + the correct one?
02:05:18 <phi__> here http://lpaste.net/4477636936613232640 , I have uncommented that line and added the long  long error message in a comment
02:05:19 <hunt> @djinn
02:05:20 <lambdabot> Cannot parse command
02:06:49 <MP2E> @djinn (s -> (s,(a->b))) -> (s -> (s,a)) -> (s -> (s,b))
02:06:49 <lambdabot> f a b c =
02:06:49 <lambdabot>     case b c of
02:06:49 <lambdabot>     (_, d) -> case a c of
02:06:49 <lambdabot>               (e, f) -> (e, f d)
02:06:54 <MP2E> like that 8)
02:13:42 <ion> phi: Try adding Num m1, Num m2 constraints to the instance definition to solve one of the errors.
02:13:49 <Phi___> I hope some one has not answered me during the time it took me to reboot my laptop after it powered off of itself
02:15:10 <mr-> Phi___: shouldn't you be using Scalar's + ? (That's just one of the errors)
02:15:48 <Phi___> I noitced it and just did it but that does not solve the problem I am updating the paste just now
02:17:36 <Phi___> http://lpaste.net/4477636936613232640 has now no errors due to Num instances
02:20:35 <ion> It‚Äôs not obvious to me what the cause of the error is.
02:22:11 <mr-> I wonder where ghc gets the "m0" from
02:22:32 <Phi___> mr- that is what's baffling me
02:22:56 <Phi___> why should there be any type variables at all except m1 and m2
02:25:49 <mr-> And I don't know where one should fix the type..
02:26:30 <ion> Try replacing parts of the function definition with _ (assuming GHC 7.8) in case the messages provide more insight.
02:27:02 <ion> starting from the full definition: = _
02:27:52 <ClaudiusMaximus> Phi___: not sure why, but using data family instead of type family gives more success - maybe the NB not injective has something to do with it
02:28:47 <Phi___> ClaudiusMaximus i will try that now
02:29:24 <ClaudiusMaximus> Phi___: i also needed  Scalar (TangentSpace m1) ~ Scalar (TangentSpace (m1, m2))
02:32:57 * hackagebot wai-cors 0.1.4 - CORS for WAI  http://hackage.haskell.org/package/wai-cors-0.1.4 (larsk)
02:32:59 * hackagebot cgrep 6.4.3 - Command line tool  http://hackage.haskell.org/package/cgrep-6.4.3 (NicolaBonelli)
02:35:43 <Phi___> ClaudiusMaximus Scalar (TangentSpace m1) ~ Scalar (TangentSpace (m1, m2)) makes sense but I am bizzarely getting a parse error on changing all the type to data
02:37:01 <ClaudiusMaximus> Phi___: you need to add a constructor, like   data Coordinate (m1,m2) = C (m1,m2)   and match it in   metric (C(x1,x2)) ...
02:37:46 <ClaudiusMaximus> Phi___: i don't really have a clue what i'm doing, just poked around until it stopped erroring
02:38:18 <MP2E> type tetris is a game of its own, heh
02:38:38 <gamegoblin> Would anyone here be so kind as to type ‚Äúcabal install JustParse‚Äù into their command lines? Trying to boost my dismal 34 downloads ;)
02:39:49 <Phi___> ClaudiusMaximus I don't really have much of a clue either that is my first time mucking with associated types
02:43:13 <Phi___> yeah I got it to compile , ClaudiusMaximus thanks for help!
02:48:30 <augur> ClaudiusMaximus: i think you mean   data Coordinate m1 m2 = ...
02:48:33 <augur> not Coordinate (m1,m2)
02:48:46 <ClaudiusMaximus> augur: maybe
02:48:51 <ClaudiusMaximus> Phi___: http://www.haskell.org/haskellwiki/GHC/Type_families#Injectivity.2C_type_inference.2C_and_ambiguity explains
02:49:00 <augur> ClaudiusMaximus: defo not maybe :P
02:49:50 <Total_1mmersion> I just skimmed over an article advocating Hungarian notation for knowing whether or not an HTML string is escaped. For example, prefix variables with us for UnSafe and s for Safe so that you know just by looking at the variable name whether or not it's escaped. I couldn't help but think that using a Haskell data type would completely solve the problem, and the type checker would safeguard against improper usage. Thoughts?
02:52:48 <drdo> Total_1mmersion: Some haskell web frameworks do a lot more than that in the way of using the type system to prevent that kind of error
02:52:59 * hackagebot network-info 0.2.0.4 - Access the local computer's basic network configuration  http://hackage.haskell.org/package/network-info-0.2.0.4 (JacobStanley)
02:56:19 <Phi___> ClaudiusMaximus I will need some type to understand that link
02:57:12 <Phi___> but data means we get a newtype for every associated type instance, what about instances of this type? Are they derived?
02:57:59 * hackagebot network-info 0.2.0.5 - Access the local computer's basic network configuration  http://hackage.haskell.org/package/network-info-0.2.0.5 (JacobStanley)
03:23:01 * hackagebot unix-compat 0.4.1.3 - Portable POSIX-compatibility layer.  http://hackage.haskell.org/package/unix-compat-0.4.1.3 (JacobStanley)
03:23:03 * hackagebot mcmc-samplers 0.1.0.0 - A library of combinators to build MCMC kernels, proposals, and targets  http://hackage.haskell.org/package/mcmc-samplers-0.1.0.0 (pravnar)
03:48:03 * hackagebot cgrep 6.4.3.1 - Command line tool  http://hackage.haskell.org/package/cgrep-6.4.3.1 (NicolaBonelli)
03:51:30 <jamiehannaford> can someone explain this to me: newtype Parser a = Parser { runParser :: String -> Maybe (a, String) }
03:52:14 <jamiehannaford> the parser type is a record with a function inside it? that function takes a string and returns a maybe tuple with whatever the data param was and the rest of the string
03:52:18 <haasn> a parser of things, is a function from strings, to maybe a pair, of things and strings
03:52:44 <jamiehannaford> haasn so how would you construct a Parser type?
03:53:11 <haasn> Parser :: (String -> Maybe (a, String)) -> Parser a
03:53:55 <haasn> eg. myParser :: Parser Foo; myParser = Parser (\s -> case s of "foo" -> Just (Foo, ""); _ -> Nothing)
03:54:38 <jamiehannaford> okay
03:55:07 <jamiehannaford> so you need to pass in a function that matches `String -> Maybe (a, String)` - but why is that automatically associated with "runParser" ?
03:55:21 <jamiehannaford> I'm not familiar with using functions as value constructors
03:56:26 <ion> Given data Foo a = Bar { runBar :: X a }, you have:
03:56:44 <ion> Bar :: X a -> Foo a
03:56:57 <haasn> The way record syntax works is that data Rec = C { a :: T, b :: U }  defines a constructor C :: T -> U -> Rec; similar to had we written data Rec = C T U; but also functions a :: Rec -> T and b :: Rec -> U that are similar to had we written a (Rec v _) = v; and b (Rec _ v) = v
03:57:02 <ion> runBar :: Foo a -> X a; runBar (Bar x) = x
03:57:14 <ion> They just wrap and unwrap the values.
03:57:34 <haasn> So in this case, we get the normal constructor Parser :: (String -> Maybe (a, String)) -> Parser a; as well as the projection function runParser :: Parser a -> (String -> Maybe (a, String))
03:57:50 <ion> Nothing changes if the hypothetical ‚ÄúX a‚Äù happens to be a function.
03:58:32 <jle`> jamiehannaford: the classic example is data Identity a = Identity { runIdentity :: a }
03:58:44 <jle`> or even data Sum a = Sum { getSum :: a }
03:58:54 <jamiehannaford> so runIdentity Identity will return `a`
03:58:59 <ion> > runIdentity (Identity (*2)) 42
03:59:00 <lambdabot>  84
03:59:00 <jle`> no
03:59:09 <jle`> runIdentity (Identity 7) will return 7
03:59:15 <ion> runIdentity . Identity = id
03:59:18 <jamiehannaford> ah okay - it needs a data param
03:59:21 <jle`> runIdentity :: Identity a -> a
03:59:21 <haasn> (runIdentity Identity is a type error)
03:59:28 <jle`> it's just a way to "access"
03:59:34 <jle`> you could define your own manual accessor
03:59:47 <jamiehannaford> okay I get it now, thanks everyone :)
03:59:47 <jle`> data MyIdentity a = MyIdentityConstr a
04:00:06 <ion> > let runIdentity' (Identity x) = x in runIdentity' (Identity "foo")
04:00:08 <lambdabot>  "foo"
04:00:10 <jle`> getMyId :: MyIdentity a -> a; getMyId (MyIdentityConstr a) = a
04:00:17 <jle`> you can make them yourself
04:00:24 <ion> > let runIdentity' (Identity x) = x in runIdentity' (Identity (*2)) 42
04:00:25 <lambdabot>  84
04:00:26 <jle`> record syntax just makes them "automatically" for you
04:00:40 <jle`> one thing that might be helpful is seeing the implicit parentheses put back in
04:00:48 <jle`> if Identity contains (*2)
04:00:56 <jle`> then runIdentity (Identity (*2)) 42
04:01:08 <jle`> is (runIdentity (Identity (*2))) 42
04:01:21 <jle`> or let f = runIdentity (Identity (*2)) in f 42
04:01:45 <jle`> > let f = runIdentity (Identity (*2)) in f 42
04:01:46 <lambdabot>  84
04:02:23 <marchelzo_> But say you had two data types, Student and Teacher, they can't both have 'name' fields in record syntax, can they?
04:02:55 <jle`> in haskell function application associates to the left, so (r (i y)) x can be written as r (i y) x
04:04:31 <jle`> marchelzo_: not if they are in the same namespace/scope, no
04:04:40 <ion> jamiehannaford: This may or may not be useful; here‚Äôs a simple toy parser implemented with a list of possible parse results instead of a Maybe as the result. https://gist.github.com/ion1/3966338#file-fooparser-hs This Parser type also turns out to be equivalent to StateT [input] [] output as used in https://github.com/ekmett/ersatz/blob/master/src/Ersatz/Internal/Parser.hs
04:05:31 <marchelzo_> jle`: What is the optimal way around this? Would you just call them studentName and teacherName, or is there a better way?
04:07:25 <ion> marchelzo: Adding prefixes like that is what people usually do. Importing them qualified from separate files is another possibility. GHC 7.10 should come with an extension to fix most of the pain: https://skillsmatter.com/skillscasts/5225-overloaded-record-fields-for-haskell
04:10:12 <sasdagf> @pl fn x = modify $ \s -> second (Set.insert x) s
04:10:12 <lambdabot> fn = modify . second . Set.insert
04:10:44 <sasdagf> pretty sure i already got that
04:10:55 <marchelzo_> ion: thanks for the link
04:54:40 <Trollinator> I'm trying to map pairs of integers to integers with a hash table.
04:54:49 <Trollinator> I can't get it to work though.
04:54:51 <Trollinator> http://lpaste.net/105944
04:56:24 <ion> trollinator: Look at the documentation of fromList
04:57:00 <ion> You could also use <http://hackage.haskell.org/package/unordered-containers-0.2.4.0/docs/Data-HashMap-Lazy.html> which does not require an explicit hash function.
04:57:51 <jamiehannaford> can someone explain the Parser( ... ) part of line 7? https://gist.github.com/jamiehannaford/0a9db95bda3053aa2c9b
04:58:06 <jamiehannaford> you're fmapping the partially applied (first f) - which is expecting a pair. This pair is returned by `runParser parser`. What is supposed to happen when you fmap functions over functions?
04:59:18 <ion> fmap f parser = Parser (\input -> [ (f result, therest) | (result, therest) <- runParser parser ])
05:00:01 <Trollinator> ion: Oh sorry, I confused Data.HashTable(fromList) and Data.HashTable.Class(fromList)
05:00:27 <ion> jamiehannaford: Well, that was using [] instead of Maybe.
05:00:51 <ion> fmap f parser = Parser (\input -> fmap (\(result, therest) -> (f result, therest)) (runParser parser))
05:01:13 <ion> Sorry, ‚ÄúrunParser parser input‚Äù in both cases.
05:01:56 <ion> fmap f (Parser p) = Parser (\input -> fmap (\(result, therest) -> (f result, therest)) (p input))
05:03:16 <jamiehannaford> okay, so `runParser parser input` will return (result, therest)
05:03:34 <ion> It will return Nothing or Just (result, theRest)
05:03:41 <jamiehannaford> and you're passing that to a function that's expecting that input. this function then applies another function `f` onto the first element
05:03:59 <ion> fmap f (Just (a, b)) = Just (f a, b)
05:04:04 <ion> fmap f Nothing = Nothing
05:04:37 <k00mi> fmap f (Just (a,b)) = Just (f (a,b))
05:04:54 <Trollinator> Ah, anyway, I can't make sense of ST's first type constructor.
05:04:57 <ion> Sorry, i‚Äôm a bit too tired to brain.
05:05:15 <ion> I meant fmap (first f)
05:06:08 <ion> Does ST have more than one type constructor?
05:06:19 <jamiehannaford> I don't understand how `fmap (first f) . runParser parser` returns a function of type String -> Maybe (a, String)
05:06:25 <Trollinator> Err, type parameter, not constructor, sorry.
05:07:30 <Trollinator> something like return 42 should have a type of ST ??? Int, right?
05:07:42 <Trollinator> But I can't figure out what to put there instead of ???
05:07:50 <klrr_> would it be hard to use TH to generate instances for Foldable and Unfoldable from recursion-schemes?
05:08:00 <Trollinator> except for RealWorld if I want the stuff to run in the IO Monad, which I don't.
05:08:03 <klrr_> instances for those classes that is
05:08:42 <k00mi> jamiehannaford: do you know what the dot means?
05:08:54 <ion> jamiehannaford: ‚ÄúrunParser parser‚Äù has the type String -> Maybe (a, String). ‚ÄúrunParser parser input‚Äù has the type Maybe (a, String). ‚Äúfmap (f :: a -> b) (runParser parser input)‚Äù has the type Maybe (b, String).
05:10:09 <jamiehannaford> but Parser type constructor accepts a function though, right? How can it accept Maybe (b, String) ?
05:10:24 <jamiehannaford> k00mi not really in this context :/
05:10:45 <Qfwfq> @djinn (a -> a -> (a, b)) -> ((a, a) -> (a, b)) -- Uncurry?
05:10:46 <lambdabot> Cannot parse command
05:10:51 <Qfwfq> @djinn (a -> a -> (a, b)) -> ((a, a) -> (a, b))
05:10:52 <lambdabot> f a (b, c) = a b c
05:11:05 <Trollinator> jamiehannaford: . is function composition
05:11:25 <Axman6> @@ pl djinn (a -> a -> (a, b)) -> ((a, a) -> (a, b))
05:11:25 <lambdabot>  pl djinn (a -> a -> (a, b)) -> ((a, a) -> (a, b))
05:11:26 <Trollinator> i. e. let (f . g) x = f (g x)
05:11:30 <Axman6> bleh
05:11:44 <jamiehannaford> Trollinator I know what the concept is - just not how to apply it with fmap and two functions
05:11:44 <Axman6> @. pl djinn (a -> a -> (a, b)) -> ((a, a) -> (a, b))
05:11:45 <lambdabot> f = (`ap` snd) . (. fst)
05:14:34 <k00mi> jamiehannaford: `runParser parser` is a function `String -> Maybe (a, String)`, so `f . runParser parser` also takes a String, but returns whatever f returns when applied to `Maybe (a, String)`
05:15:05 <l0cust> Hey, y'all. Cabal is claiming I don't have a library installed, when, in fact, I do http://lpaste.net/105947
05:15:35 <l0cust> Proof I have it installed - http://lpaste.net/105948
05:15:56 <k00mi> jamiehannaford: in this case f is `fmap (first f)`. fmap lifts the inner function over the Maybe so it is only applied if the value is `Just x`
05:16:20 <k00mi> jamiehannaford: `first f` applies f to the first value of a pair
05:17:05 <Axman6> sort of
05:17:24 <Trollinator> k00mi: how's that better than f . fst ?
05:17:27 <k00mi> jamiehannaford: when you put that all together, the result is a function that takes a String, parses it, and applies f to the result
05:17:44 <k00mi> Trollinator: the result is still a pair
05:17:46 <ion> trollinator: ‚Äúlet ref = runST (newSTRef 42); a = runST (writeSTRef ref 43); b _ = runST (readSTRef ref) in (b (), a, b ())‚Äù. This would be bad, right? The usage of scoping in the type of runST prevents you from using the instance of ‚Äús‚Äù outside a single runST invocation.
05:18:21 <ion> trollinator: return 42 :: ST s Int
05:18:26 <k00mi> jamiehannaford: by result I mean the `a` part, not the entire `Maybe (a, String)`
05:18:49 <ion> trollinator: runST will dictate the ‚Äús‚Äù for return and will not leak it out.
05:18:51 <jamiehannaford> k00mi so `fmap (first f)` is expecting `Maybe (a, String)` ?
05:18:59 <k00mi> jamiehannaford: yep
05:19:28 <jamiehannaford> so all fmap is doing is "lifting" a function and applying it to a functor, in this case a Maybe
05:19:46 <Axman6> sure is
05:19:50 <Axman6> :t fmap
05:19:51 <lambdabot> Functor f => (a -> b) -> f a -> f b
05:20:04 <k00mi> that's exactly what Functor is for
05:20:07 <ion> > fmap (first reverse) (Just ("foo", "bar"))
05:20:08 <lambdabot>  Just ("oof","bar")
05:20:19 <ion> > fmap (first reverse) [ ("foo", "bar"), ("baz", "quux") ]
05:20:20 <Trollinator> k00mi: oh, I see.
05:20:20 <lambdabot>  [("oof","bar"),("zab","quux")]
05:20:38 <Axman6> from the type and the laws that fmap id = id and fmap f . fmap g = fmap (f . g)  you can know everything about fmap
05:21:00 <jamiehannaford> so if I had written it: `fmap (first f) . runParser parser "foo"` - that would not result in a function would it?
05:21:22 <Axman6> what's the type of runParser?
05:21:37 <jamiehannaford> runParser :: String -> Maybe (a, String)
05:21:46 <ion> jamiehannaford: (fmap (first f) . runParser parser) "foo" would result in a Maybe (A, String)
05:21:58 <k00mi> Trollinator: in reality `first` is much more general (it's part of the Arrow class), but it's mostly used for this
05:22:00 <jamiehannaford> ah okay
05:22:07 <Axman6> jamiehannaford: you sure? =) (I'd guess it's Parser a -> String -> Maybe (a,String))
05:22:08 <ion> jamiehannaford: fmap (first f) . runParser parser "foo" = \input -> fmap (first f) (runParser parser "foo" input), a type error.
05:22:12 <jamiehannaford> so you're actually constructing a function first and then feeding "foo" into it
05:23:01 <l0cust> tried rebooting, didn't help
05:23:05 <jamiehannaford> Axman6 it's newtype Parser a = Parser { runParser :: String -> Maybe (a, String) }
05:23:37 <Axman6> jamiehannaford: right, record syntax gives you functions of type <Record type> -> <type the name was defined as>
05:23:38 <ion> ‚Äúdata Foo a = Bar { runBar :: X a }‚Äù will result in the function ‚ÄúrunBar :: Foo a -> X a‚Äù
05:25:14 <jamiehannaford> it's _gradually_ starting to all make sense :)
05:25:37 <l0cust> The suggestion in #archlinux was to keep rebooting until it works
05:25:42 <l0cust> I'm counting on you guys
05:25:54 <Axman6> ha
05:26:19 <Axman6> my usual "Cabal's broked" fix is to delete everything and start again
05:27:32 <l0cust> Axman6: I've got like 2000 lines of code so far
05:27:41 <ion> axman6: hopefully using sandboxes this time
05:27:43 <l0cust> Axman6: otherwise i might actually consider that
05:27:52 <l0cust> I am using sandboxes :(
05:28:01 <l0cust> Still broked :(
05:28:07 <k00mi> that's not the kind of problem that is usually solved by rebooting...
05:28:25 <ion> l0cust: Not your code, the sandbox. But i‚Äôm not sure this error is the cabal problem axman6 is talking about.
05:28:33 <l0cust> yeah, I know
05:28:40 <l0cust> I was just making a comment
05:28:55 <bennofs> l0cust: do you have pkg-config installed?
05:29:11 <l0cust> bennofs: cabal package, or arch package?
05:29:18 <ion> Look at what pkg-config file or equivalent the cabal package is looking for, see if your system package has something else instead.
05:29:19 <bennofs> l0cust: does tn
05:29:40 <bennofs> l0cust: arch package (don't know how it's called) that provides `pkg-config` command
05:29:45 <l0cust> I have Yep
05:29:51 <l0cust> ah
05:29:52 <Trollinator> ion: thanks, that helped.
05:29:53 <l0cust> Yep, I have it
05:29:59 <l0cust> http://lpaste.net/105949
05:31:22 <l0cust> ion: how do I get that information?
05:32:15 <bennofs> l0cust: http://hackage.haskell.org/package/happstack-server-tls-7.1.0/happstack-server-tls.cabal
05:32:28 <bennofs> l0cust: cabal info happstack-server-tls also shows it, IIRC
05:32:28 <ion> trollinator: To elaborate a bit more on my code example, runST in ‚ÄúrunST (newSTRef 42)‚Äù would need to have the type (forall s. ST s (STRef s Integer)) -> (STRef s' Integer) such that s = s', but that is not possible because s is not in scope where s' is.
05:33:28 <l0cust> hm okay
05:33:36 <l0cust> It's looking for cryptopp
05:33:44 <l0cust> On Arch, it's called crypto++
05:33:49 <l0cust> might that be the problem?
05:33:54 <loz2> hi, what (<=<) is? looks like my ghc does not know about it
05:34:03 <l0cust> :t (<=<)
05:34:04 <lambdabot> Monad m => (b -> m c) -> (a -> m b) -> a -> m c
05:34:05 <Axman6> :t (<=<)
05:34:06 <lambdabot> Monad m => (b -> m c) -> (a -> m b) -> a -> m c
05:34:15 <k00mi> loz2: you have to import Control.Monad
05:34:18 <ion> (f <=< g) x = f =<< g x
05:34:31 <ion> (f . g) x = f (g x)  -- Note the pattern
05:34:38 <l0cust> It seems to be (.) for monads
05:34:41 <loz2> i see, thanks!
05:34:43 <bennofs> l0cust: happstack-server-tls doesn't seem to use pkg-config. Can you show pacman -Ql crypro++ (that should show the files that crypro++ provides, right?)
05:34:44 <k00mi> correct
05:34:53 <Axman6> it's (.) for the Kleisli arrow I think
05:35:12 <l0cust> http://lpaste.net/105950
05:35:32 <bennofs> :t \a b -> runKleisli $ Kleisli a Control.Category.. Kleisli b
05:35:33 <lambdabot> Monad m => (b1 -> m b) -> (a -> m b1) -> a -> m b
05:35:36 <Axman6> :t (<=<) `asAppliedTo` (Kleisli (return 1))
05:35:36 <lambdabot>     Couldn't match expected type ‚Äòb -> m c‚Äô
05:35:37 <lambdabot>                 with actual type ‚ÄòKleisli m0 a0 b0‚Äô
05:35:37 <lambdabot>     Possible cause: ‚ÄòKleisli‚Äô is applied to too many arguments
05:35:59 <loz2> ah, so =<< is an analogue for $ ?
05:36:17 <l0cust> More or less
05:36:24 <ion> l0cust: Try changing Extra-Libraries: cryptopp to PkgConfig-Depends: libcrypto++
05:36:26 <l0cust> it's just (>>=) in the other direction
05:36:28 <Axman6> it's just >>= flipped
05:36:52 <k00mi> loz2: yes, it's monadic function application
05:37:00 <toki78> Hi
05:37:08 <jamiehannaford> does anybody know some good exercises for applicative functors?
05:37:13 <l0cust> ion: how do I do that? (sorry for newbish questions)
05:37:23 <toki78> http://toki.burn3r.de/html5-projects/boolean-functions.html
05:37:40 <toki78> the machine learning guys do not answer :(
05:37:49 <toki78> thats why I post it here
05:37:57 <ion> l0cust: cabal unpack packagename, cd packagename-version, modify packagename.cabal, cabal install
05:38:20 <Axman6> toki78: how can they answer when you don't ask any questions?
05:38:28 <toki78> oh
05:38:50 <toki78> I mean I replaced Neural Nets by parameterized boolean functions
05:39:04 <toki78> This is so interesting
05:39:34 <Axman6> is it supposed to eventually match the blue line?
05:39:45 <toki78> Axman6, exactly
05:39:51 <toki78> like a NN should
05:39:55 <l0cust> ion: okay, getting error about reinstalls
05:39:57 <toki78> still buggy
05:40:04 <Axman6> It doesn't appear to getting any closer
05:40:19 <l0cust> ion: how do I tell my sandbox to use happstack-server-tls from the local file?
05:40:21 <toki78> I does at least a bit
05:40:50 <l0cust> ion: that was confusing
05:41:32 <ion> l0cust: Before running cabal install in the happstack-server-tls directory where you modified its .cabal file, run cabal sandbox init --sandbox=/path/to/pre√´xisting/.cabal-sandbox
05:41:33 <l0cust> ion: I tried running cabal install, but I got a warning about reinstalls, because it was trying to do an install to ~ . I want happstack-srever-tls to install to my sandbox. How do I do that?
05:41:45 <l0cust> ion: you are very helpful, thank you
05:42:16 <k00mi> l0cust: cabal sandbox add-source /my/patched/library
05:42:33 <k00mi> in the directory where the sandbox is
05:42:46 <toki78> Axman6, the algo was finished today, it may still be buggy
05:43:02 <Axman6> I'll leabe it running and see how it goes =)
05:43:09 <ion> l0cust: What k00mi said is better.
05:43:13 <Trollinator> I'm a bit disappointed by Haskell's performance. I've written a little program to calculate the number of ways a certain amount of money can be expressed with a given set of coins. The Python version is faster than the Haskell one.
05:43:17 <l0cust> Same error (or warning) that I started with http://lpaste.net/105951
05:43:45 <Rembane> Trollinator: Show us some code! :D
05:43:50 <ion> l0cust: huh
05:44:01 <Axman6> toki78: did you use divMod? you probably want to use quotRem
05:44:06 <Axman6> uh, Trollinator, not toki78
05:44:19 <corgifex> yay microoptimizations
05:44:24 <l0cust> Trollinator: I'm guessing you need to be more verbose about your types
05:44:24 <toki78> I do not know, where the jittering comes from
05:44:28 <corgifex> we haven't even seen any code yet
05:44:42 <Trollinator> I'll clean up the code a bit and paste it.
05:44:57 <Axman6> corgifex: it's a pretty well known problem, and if you know you'll only be using positive numbers, you should always use quotRem/rem
05:45:09 <l0cust> Trollinator: make sure to recompile after you clean
05:45:17 <l0cust> ion: my thoughts exactly
05:45:58 <corgifex> l0cust: you're assuming he's compiling his code
05:46:15 <l0cust> corgifex: oh god
05:46:39 <loz2> guys, about lift
05:46:42 <corgifex> Axman6: how many nanoseconds will that buy you?
05:46:49 <Axman6> quite a lot
05:47:09 <Axman6> the difference between the two is significant
05:47:26 <l0cust> corgifex: consider that the size of N is one half that of Z
05:47:42 <corgifex> l0cust: cantor would like to have a word with you
05:48:33 <eazar001> Luzie: Quite late I know, but that client looksk pretty nice.
05:48:51 <loz2> i'm reading http://www.haskellforall.com/2012/09/the-functor-design-pattern.html and author says that
05:48:51 <loz2> lift :: (Monad m, MonadTrans t) => m r -> t m r
05:48:51 <loz2> (lift .) :: (Monad m, MonadTrans t) => (a -> m b) -> (a -> t m b)
05:48:51 <loz2> as i understand, the second function takes a function and should return monad of function, but instead it returns a function which returns monad, how does this happen?
05:49:31 <corgifex> (.) always returns a function
05:49:57 <corgifex> (lift .) means (.) lift
05:49:58 <Axman6> :t (\f -> lift . f)
05:49:59 <lambdabot> (MonadTrans t, Monad m) => (a -> m a1) -> a -> t m a1
05:50:05 <corgifex> :t (.)
05:50:06 <lambdabot> (b -> c) -> (a -> b) -> a -> c
05:50:34 <loz2> corgifex: but lift is applied to function? or m b ?
05:50:47 <corgifex> loz2: when/how/where?
05:50:56 <loz2> in (lift .)
05:51:04 <Axman6> to mb
05:51:06 <Axman6> m b(
05:51:08 <corgifex> lift isn't applied at all there
05:51:10 <Axman6> bleh
05:51:29 <loz2> i mean (.) calls lift with m b?
05:51:32 <corgifex> (lift .) = \x -> \y -> lift (x y)
05:51:32 <ion> (lift .) f = lift . f = \x -> lift (f x)
05:51:42 <Axman6> (lift .) takes a function from a -> m b and turns it into a function from a to t m b
05:52:15 <corgifex> "lift the return value of the function I'm about to give you"
05:52:59 <loz2> i see, thanks)
05:53:23 <Trollinator> http://lpaste.net/105952
05:53:59 <corgifex> Trollinator: how are you compiling your code?
05:55:24 <Axman6> heh, ok, that's a lot more complex than I was expecting =)
05:55:41 <corgifex> manual memoization
05:56:17 <Trollinator> ghc -O
05:56:38 <Trollinator> The equivalent Python is http://lpaste.net/105954
05:57:00 <eazar001> this is a project euler problem
05:57:11 <Trollinator> perhaps.
05:57:24 <corgifex> eazar001: which number?
05:57:24 <eazar001> that site is now down
05:57:36 <eazar001> i think security got compromised
05:57:52 <eazar001> corgifex: i cna't remember
05:57:52 <Trollinator> The Python is faster and more importantly, it reads better, because I can just use the ‚Äútable‚Äù variable without having to pass it around.
05:58:10 <wlhlm> it's back up: https://projecteuler.net/ (static)
05:58:14 <wlhlm> eazar001: ^
05:58:25 <eazar001> corgifex: problem 31
05:58:35 <eazar001> wlhlm: nice!!
05:59:16 <Axman6> hmm, the input would have to be pretty odd for memoisation to make much of a difference here
05:59:17 <wlhlm> eazar001: you can't check for the solution, though.
05:59:35 <Trollinator> Axman6: memoisation makes a huge difference.
05:59:46 <eazar001> sucks, i brute forced that a long time ago
06:00:09 <eazar001> Trollinator: what's your execution time?
06:00:22 <corgifex> Trollinator: hmm, my code for that problem runs instantly with input 200
06:00:45 <corgifex> I probably cheated somewhere
06:00:52 <Trollinator> Just try 10 ‚Ç¨ with Euro coins (2‚Ç¨,1‚Ç¨,50c,20c,10c,5c,2c,1c)
06:01:04 <wlhlm> eazar001: but the solutions should be googleable, also: http://www.haskell.org/haskellwiki/Euler_problems
06:01:11 <eazar001> corgifex; yes it is instant, even with the "elegant code" he posted
06:01:19 <eazar001> but he's probably talking about non-200 input
06:01:26 <Axman6> oh right, yeah I forgot what the problem was
06:01:43 <Trollinator> it runs in 2 seconds with memoisation.
06:01:49 <Trollinator> for 10 ‚Ç¨
06:02:09 <eazar001> Trollinator: how are you running it?
06:02:19 <eazar001> What command are you using?
06:02:24 <Qfwfq> @src curry
06:02:24 <lambdabot> curry f x y = f (x, y)
06:02:41 <Axman6> you said you were compiling with -O right? you should try -O2
06:02:56 <Trollinator> I compile the program with ghc -O, then I run the resulting ‚Äúcoins‚Äù executable using ‚Äútime ./coins <<< 1000‚Äù
06:02:58 <corgifex> still instant with input 1000
06:03:01 <Qfwfq> I guess '(a -> b) -> [(a,b)]' can't be defined unless 'a' instances Enum.
06:03:19 <Qfwfq> (Fortunately, in this case, it does!)
06:03:34 <corgifex> Trollinator: my code: http://lpaste.net/105955
06:03:50 <corgifex> oops, maybe maxval is wrong now?
06:04:03 <Trollinator> yeah well, it's faster with -O2
06:04:33 <Qfwfq> @type \f -> ap (,) f [minBound..maxBound] -- Enum and Bounded
06:04:34 <lambdabot> (Enum t, Bounded t) => ([t] -> a) -> ([t], a)
06:04:58 <eazar001> Trollinator: also remember with python ....
06:05:11 <eazar001> (this may not apply to this case, keep in mind)....
06:05:23 <eazar001> they do a lot of C translation for "mundane" tasks in there
06:05:34 <eazar001> so certian types of code can be written in a way ...
06:05:42 <eazar001> where you're actually getting mostly C, not python
06:06:05 <Qfwfq> @type \f -> map (ap (,) f) [minBound..maxBound]
06:06:06 <lambdabot> (Enum a, Bounded a) => (a -> a1) -> [(a, a1)]
06:06:28 <k00mi> using an array for memoization should me much more efficient
06:07:04 <Qfwfq> @type flip map [minBound..maxBound] . ap (,)
06:07:05 <lambdabot> (Enum a, Bounded a) => (a -> a1) -> [(a, a1)]
06:07:06 <eazar001> for example that format you used in your python code ....
06:07:10 <eazar001> ..... for x in ....
06:07:14 <eazar001> that translates to a C loop
06:07:25 <eazar001> directly
06:07:34 <corgifex> I'm beginning to understand my code again
06:08:16 * hackagebot bson 0.3 - BSON documents are JSON-like objects with a standard binary  encoding.  http://hackage.haskell.org/package/bson-0.3 (GregWeber)
06:08:50 <Trollinator> *sigh*
06:11:29 <corgifex> Trollinator: what does i represent in your code?
06:14:23 <Trollinator> lookup table (n, i) yields the number of representations for the amount of money specified by n when not using the first i coins
06:14:33 <corgifex> hmm. what is this loop doing? is this a manually unrolled recursion of one level?
06:15:22 <corgifex> your haskell code writes to the table in the loop
06:15:42 <corgifex> the python code doesn't
06:16:31 <Trollinator> yes it does, changeRec in python changes the table.
06:16:43 <Trollinator> i. e. writes to the table.
06:17:21 <corgifex> but not in the loop
06:17:45 <eazar001> Trollinator: you python code uses a C loop
06:17:56 <corgifex> eazar001: what's your point?
06:18:21 <corgifex> oh, the code structure is different. your python function does the lookup first and write last
06:18:38 <corgifex> your haskell function doesn't always lookup
06:19:01 <corgifex> hence the manual write after the recursive call
06:19:29 <Trollinator> corgifex: oh yes, it's slightly different. I didn't realize that.
06:20:55 <loz2> guys, if monad is a monoid in category of endofunctors, how can monoid be a category with a single object?
06:21:11 <Trollinator> corgifex: that made it a bit faster, thanks.
06:21:37 <corgifex> it did?
06:21:37 <corgifex> whoa
06:22:07 <corgifex> you're doing a lot of redundant work though, aren't you?
06:22:13 <corgifex> even with the table
06:23:01 <corgifex> you have a whole list of subrecursive calls whose results you sum up
06:23:10 <corgifex> my code only does a single +
06:24:02 <simon> loz2, by the wording of your question, it sounds as if you feel that those two facts contradict each other?
06:24:21 <Trollinator> I modified the code to make it more like the Python version and it now runs ~twice as fast.
06:24:40 <Rembane> Trollinator: Is it using data structures more heaivly now?
06:24:42 <loz2> simon yes, aren't they?
06:24:49 <corgifex> Trollinator: cleaned up a bit: http://lpaste.net/105955
06:24:51 <Axman6> what's the type of insert btw?
06:25:59 <corgifex> insert :: (Hashable k) => HashTable s k v -> ST s () -- is what I expect from the code. never used HashTable, though
06:26:07 <corgifex> errrr
06:26:22 <corgifex> insert :: (Hashable k) => HashTable s k v -> k -> v -> ST s ()
06:27:13 <Trollinator> Thanks for the code, but tbh I'm not that interested in the problem per se, I was just trying to learn something about ST
06:27:37 <loz2> simon my logic is that category of endofunctors consists of functions, and monad is a category which shouldn't be there, unless there is something that allows call function a category
06:28:12 <simon> loz2, the last part of your sentence does not make sense to me.
06:29:08 <Trollinator> corgifex: what bothers me about the haskell code is that I have to pass the table around instead of just being able to use the table variable from the enclosing environment.
06:29:17 <Trollinator> is there a way to fix that?
06:29:25 <loz2> simon, and *monoid is a category which shouldn't be there
06:29:45 <corgifex> Trollinator: hmm, I'mm a try and rewrite your python code in haskell from scratch
06:29:54 <Axman6> Trollinator: do you have to pass it around? I have a feeling if you comment out the type signature it would work fine without you having to pass it
06:30:46 <loz2> simon if both original statements are true, what differs monoid from other endofunctors? or all endofunctors are monoids?
06:31:02 <Trollinator> Axman6: tried that, doesn't work.
06:31:09 <Axman6> odd
06:31:37 <Axman6> worker/wrapper it?
06:33:10 <Trollinator> corgifex: thanks
06:33:58 <Trollinator> this is why I'm learning Haskell. In Scala I would have just used a mutable map
06:34:21 <Trollinator> Haskell forces me to think about stuff.
06:36:24 <Axman6> and now you're just using a mutable map :P
06:36:41 <eazar001> yea, i think hashtable is mutable
06:37:29 <Trollinator> but nevertheless referentially transparent
06:39:29 <simon> loz2, all endofunctors need not be monoids. (I'm sorry this is taking long - I am learning this myself.)
06:41:21 <Cale> Do you mean monoid objects?
06:43:32 <Cale> Normally endofunctors can't be monoids, because they're not sets. There's a categorification of monoids from being sets to objects in an arbitrary monoidal category. Monads on a category C are the monoid objects in the monoidal category of endofunctors on C (whose operation on objects is composition of functors)
06:45:39 <corgifex> Trollinator: http://lpaste.net/105954
06:45:52 <corgifex> the list indexing may be a bit dumb
06:46:12 <corgifex> still fast enough to be instant here
06:46:51 <loz2> Cale: oh, there is monoidal category abov endofunctors, which separates monoids from endofunctors, this is what i was thinking for, thanks!
06:47:22 <Jefffrey> Hello
06:47:29 <Cale> There's a monoidal category whose objects are endofunctors, and whose arrows are natural transformations between those
06:47:54 <Cale> Jefffrey: Hello! Feel free to ask any questions you might have :)
06:48:39 <Jefffrey> Is there a way to define a type like `Arr i` where `i` can be a natural number? Such as that `Arr 3` and `Arr 5` are both types?
06:48:54 <Cale> loz2: See: http://en.wikipedia.org/wiki/Monoidal_category and http://en.wikipedia.org/wiki/Monoid_object
06:49:14 <loz2> Cale: ok)
06:49:29 <Jefffrey> Apparently polymorphic kinds might allow something like that.
06:49:43 <Cale> Jefffrey: Using some new extensions it is possible now, but Haskell has limited support for dependent types still, so it might not always be a great idea.
06:50:22 <Cale> Doing significant computation at the type level is still pretty awkward
06:51:10 <Jefffrey> what do you mean?
06:52:08 <corgifex> 3 + 5 is not necessarily the same type as 8
06:53:07 <Thra11> Where is the best place to ask about problems building ghc (as a cross-compiler)?
06:53:12 <simon> can 3 and 5 work as actual type constructors using certain extensions?
06:53:21 <Cale> https://ghc.haskell.org/trac/ghc/wiki/TypeNats has a bunch of information about the support for type level naturals which is there now
06:53:36 <Jefffrey> corgifex: I see.
06:53:40 <Jefffrey> Cale: Thanks.
06:55:17 <Tjr> http://hackage.haskell.org/package/mtl-2.2.1/docs/Control-Monad-State-Class.html#t:MonadState
06:55:17 <Tjr> class Monad m => MonadState s m | m -> s whereSource
06:55:18 <Tjr> What's the | symbol in the type definition?
06:55:36 <corgifex> fundeps
06:55:38 <Axman6> it's a functional dependency
06:55:40 <Cale> It indicates a functional dependency
06:55:49 <corgifex> http://www.haskell.org/haskellwiki/Functional_dependencies
06:55:51 <Cale> It says "where m determines s uniquely"
06:55:51 <Axman6> it says that the type s is dependant on the type m
06:56:06 <Tjr> thank you
06:56:19 <Cale> i.e. for any given m, there can be at most one s for which there is an instance of MonadState s m
06:56:50 <Cale> and because of this restriction, the compiler can use knowledge of m in order to infer which type s is, by looking up the instances
06:58:18 <corgifex> class C a b where { foo :: a -> b }; instance C Int Int where { foo = id }; print (foo (1 :: Int))  -- ambiguous: return type of foo is not specified
06:58:20 <Cale> This is important, because otherwise, there would be many cases where 'get' was ambiguous, because it couldn't be sure that there wouldn't be another instance of MonadState for some other state type (perhaps even declared in a module which hadn't been compiled yet)
07:01:27 <Tjr> In this example:
07:01:28 <Tjr>  get :: m s
07:01:33 <Tjr> get = State $ \s -> (s,s)
07:01:59 <marchelzo_> @src sequence
07:01:59 <lambdabot> sequence []     = return []
07:02:00 <lambdabot> sequence (x:xs) = do v <- x; vs <- sequence xs; return (v:vs)
07:02:00 <lambdabot> -- OR: sequence = foldr (liftM2 (:)) (return [])
07:02:10 <Tjr> Wouldn't the "|" restriction mean that once I use States of Int, that I can never again use a State with something else inside??
07:02:14 <Tjr> s/??/?/
07:02:39 <corgifex> Tjr: m = State Int, s = Int
07:02:50 <Tjr> oh
07:02:52 <Tjr> thanks
07:02:59 * Tjr feels stupid.
07:03:01 <Axman6> in that example, you'd have instance MonadState (State s) s where
07:03:54 <benneh> I'm creating a new data type and making it an instance of Foldable; if I 'import Data.Foldable (Foldable, foldr)' then ghc warns me that the import is redundant; if I 'import Data.Foldable (Foldable)' then ghc complains that foldr is not a visible member of Foldable; how can I fix this? (I'm using -Wall)
07:06:44 <corgifex> I'd try Foldable(..)
07:09:43 <benneh> corgifex: thanks; 'import Data.Foldable (Foldable (..))' works fine; but 'import Data.Foldable (Foldable (foldr))' causes the same warning as before; what's going on here?
07:10:02 <corgifex> ghc bug?
07:12:08 <benneh> corgifex: oh; well, at least I'm not going crazy :D; thanks for the help
07:12:32 <corgifex> which version of ghc is this?
07:13:00 <loz2> >return 3 :: Maybe Int
07:13:00 <loz2> Just 3
07:13:00 <loz2> > return 3 :: Nothing
07:13:00 <loz2> <interactive>:62:13:
07:13:00 <loz2>     Not in scope: type constructor or class `Nothing'
07:13:00 <loz2> how can i return Nothing ?
07:13:01 <lambdabot>  Not in scope: type constructor or class ‚ÄòNothing‚Äô
07:13:01 <lambdabot>  A data constructor of that name is in scope; did you mean DataKinds?
07:13:36 <corgifex> loz2: you don't
07:13:44 <corgifex> > Nothing :: Maybe Int
07:13:46 <lambdabot>  Nothing
07:13:50 <Axman6> you can't use return to get Nothing
07:13:53 <corgifex> you can do that, but not with 'return'
07:14:00 <loz2> hm
07:14:07 <corgifex> for Maybe, return = Just
07:14:08 <Axman6> return for Maybe is defined as return x = Just x
07:14:17 <corgifex> GET OUT OF MY HEAD, CHARLES
07:14:19 <benneh> corgifex: 7.8.2
07:14:43 <corgifex> benneh: might be worth checking if there's a bug report for it
07:14:56 <Axman6> Charles?
07:17:06 <Axman6> üç∫
07:17:12 <Axman6> whoops, wrong chan =)
07:17:33 <corgifex> üçª
07:17:54 <corgifex> (and the slightly more obscure íàÆ)
07:18:31 <Axman6> what's that supposed to be? it doesn't look great on my machine
07:18:49 <Axman6> box with two... antennas inside it
07:18:56 <corgifex> U+1222E: CUNEIFORM SIGN MUG
07:19:43 <Axman6> yeah, that's what the character selector on OS X says, but doesn't show anything useful
07:20:17 <corgifex> ... that is the useful bit
07:20:19 <corgifex> "mug"
07:21:36 <benzrf> oh boy
07:21:42 <benzrf> they have cuneiform now?
07:21:54 <benzrf> dang it unicode!
07:21:59 <corgifex> "now"?
07:22:12 <corgifex> http://dl.dropboxusercontent.com/u/41152078/unicode.html must be years old now
07:22:18 <benzrf> jesus dick
07:22:29 <Tjr> They have entire clipart galleries in unicode. Including a turd, if you really need it
07:22:29 <corgifex> http://dl.dropboxusercontent.com/u/41152078/unicode.html?q=mug
07:22:44 <corgifex> http://dl.dropboxusercontent.com/u/41152078/unicode.html?q=poo
07:22:57 <cr7> hey
07:23:01 <Axman6> bah, no font support for me
07:23:21 <cr7> I wanted help for list of lists
07:23:27 <benzrf> cr7: ok
07:23:41 <benzrf> > [[1, 2, 3], [4, 5, 6], [7, 8, 9]]
07:23:42 <lambdabot>  [[1,2,3],[4,5,6],[7,8,9]]
07:23:49 <benzrf> oh no it compressed it
07:24:11 <Tjr> that's a rank 2 matrix
07:24:18 <benzrf> is it now
07:24:37 <cr7> @benzrf : I am writing a function which takes in a list like [1,2,3] and returns [1,2,2,3,3,3]
07:24:37 <lambdabot> Unknown command, try @list
07:24:47 <Trollinator> corgifex: thanks
07:25:00 <corgifex> cr7: what's the output for [2,2,4]?
07:25:09 <cr7> [2,2,2,2,4,4,4,4]
07:25:16 <Tjr> Why does LYAH talk about kind? It doesn't really do anything useful with it.
07:25:20 <corgifex> ok, position independent
07:25:21 <cr7> repeats k times
07:25:32 <cr7> nope, dependent
07:25:37 <corgifex> no, independent
07:25:50 <benzrf> Tjr: because its handy info
07:25:50 <Axman6> seems position independent to me
07:25:54 <benzrf>               
07:26:02 <Jefffrey> Cale: I understand what you mean by awkward.
07:26:10 <cr7> so I am trying to create lists like [1],[2,2], [3,3,3] and concatenating them into a single list
07:26:14 <Tjr> cr7: func string = concat $ map (\x -> take x x) $ string
07:26:25 <benzrf> @let cr7 = (>>= join replicate)
07:26:26 <lambdabot>  Defined.
07:26:30 <corgifex> cr7: sounds good
07:26:31 <benzrf> > cr7 [1, 2, 3]
07:26:32 <Axman6> I don't think take is what you want
07:26:33 <lambdabot>  [1,2,2,3,3,3]
07:26:38 <benzrf> > cr7 [2, 2, 4]
07:26:40 <lambdabot>  [2,2,2,2,4,4,4,4]
07:26:41 <benzrf> coo
07:26:42 <Axman6> replicate perhaps?
07:26:43 <Tjr> err, replicate, not take (in my solutino)
07:26:52 <cr7> the format is [Int]->[Int]
07:26:59 <corgifex> cr7: what's the problem?
07:26:59 <benzrf> Tjr: youve been codegolf'd
07:27:31 <cr7> the problem is how to iterate over the length of the list
07:27:35 <benzrf> :t c7
07:27:36 <benzrf> :t cr7
07:27:36 <lambdabot>     Not in scope: ‚Äòc7‚Äô
07:27:36 <lambdabot>     Perhaps you meant one of these:
07:27:36 <lambdabot>       ‚Äòc‚Äô (imported from Debug.SimpleReflect), ‚Äòcr7‚Äô (line 147),
07:27:36 <lambdabot> [Int] -> [Int]
07:27:43 <Tjr> benzrf: I don't mind a bit if YOU beat me :-)
07:27:49 <corgifex> cr7: what does that mean?
07:28:09 <cr7> Sorry, I am a newbie
07:28:21 <corgifex> I know how to iterate over a list
07:28:27 <corgifex> but the length is just a number, not a list
07:28:27 <Axman6> corgifex: what have you tried so far?
07:28:38 <corgifex> I've tried turning it off and on again
07:28:41 <Axman6> uh, cr7
07:28:50 <cr7> The function returns a list, so will it be like FuncName lis = ........
07:29:11 <cr7> where lis is the final list
07:29:15 <corgifex> no, you can't start with an uppercase eltter
07:29:17 <corgifex> *letter
07:29:24 <cr7> oh okay
07:29:24 <corgifex> and lis would be the function parameter there
07:29:28 <corgifex> i.e. the input, not the result
07:29:30 <Trollinator> corgifex: I don't yet unterstand why I got a compiler error when I didn't pass the table around by hand. It seems to work fine in your code.
07:29:31 <cr7> yeah
07:29:33 <cr7> okay
07:29:54 <Trollinator> You also use the !! operator to avoid passing the coins around, I won't do that because it's inefficient.
07:30:19 <cr7> So, how should I iterate over the list and use the replicate command? pls help
07:30:22 <Trollinator> but it can easily be avoided by just copying it into an array.
07:30:29 <corgifex> Trollinator: yeah, it probably won't matter much with a list this small, but I wanted to stay as close to the python code as possible
07:30:37 <Axman6> cr7: what have you tried?
07:30:40 <corgifex> also I'm lazy
07:30:56 <pingu> do you want something like iteate, maybe?
07:31:13 <pingu> > take 10 $ iterate ('A':) ""
07:31:14 <lambdabot>  ["","A","AA","AAA","AAAA","AAAAA","AAAAAA","AAAAAAA","AAAAAAAA","AAAAAAAAA"]
07:31:16 <corgifex> Trollinator: were you maybe trying to use different ST contexts? (how many runSTs did you have?)
07:31:25 <Trollinator> no...
07:31:26 <corgifex> Trollinator: or were you trying to create the table outside of ST?
07:31:33 <Trollinator> no.
07:31:33 <cr7> What i was trying was to create temporary lists and adding it to another list and then use concat?
07:31:43 <corgifex> cr7: show code
07:31:51 <Trollinator> I have to look at the code again to figure out what the problem was.
07:31:58 <Axman6> code speaks louder than words
07:32:02 <cr7> let k = replicate 5 5
07:32:02 <Trollinator> I hope I'll be able to reproduce it.
07:32:35 <Trollinator> corgifex: arguably, an Array is closer to a Python List than a linked list. Anyway, that's just a minor thing
07:33:16 <cr7> That's for an element, don't know how to use it for a list [1,5] ( output : [1,5,5,5,5,5] that's 5 5 times and 1 1 time)
07:33:37 <corgifex> cr7: you can use 'map' to repeat an operation for each element of a list
07:33:43 <Tjr> benzrf: I tried your code in ghci, and it doesn't work there. Why? http://lpaste.net/105963
07:34:19 <corgifex> Tjr: you're missing an instance. try 'import Control.Monad.Instances' maybe? or Data.Function
07:34:31 <Cale> > map (\k -> replicate k k) [1,2,3,4,5]
07:34:32 <lambdabot>  [[1],[2,2],[3,3,3],[4,4,4,4],[5,5,5,5,5]]
07:34:32 <benzrf> corgifex: he shouldnt need it
07:34:45 <benzrf> :t (>>= join replicate)
07:34:46 <lambdabot> [Int] -> [Int]
07:34:53 <corgifex> benzrf: how so?
07:34:55 <benzrf> oic
07:34:59 <benzrf> nvm youre right -.-
07:35:02 <cr7> yeah its [int]->[Int]
07:35:12 <cr7> [1,2] -> [1,2,2]
07:35:19 <benzrf> i thought Reader was in Prelude?
07:35:20 <corgifex> cr7: you can stop repeating yourself
07:35:26 <Axman6> cr7: we understand what you're trying to do
07:35:28 <cr7> sorry!
07:35:34 <Trollinator> corgifex: http://lpaste.net/105964
07:35:35 <Axman6> do you know what map is?
07:35:41 <Axman6> :t map
07:35:42 <lambdabot> (a -> b) -> [a] -> [b]
07:35:49 <Axman6> > map show [1..10]
07:35:50 <lambdabot>  ["1","2","3","4","5","6","7","8","9","10"]
07:35:56 <cr7> no
07:35:57 <toki78> Hi
07:36:00 <Axman6> > map (\x -> x*x) [1..10]
07:36:02 <lambdabot>  [1,4,9,16,25,36,49,64,81,100]
07:36:07 <benzrf> > [1..10] >>= show
07:36:09 <lambdabot>  "12345678910"
07:36:09 <toki78> Axman6, I found some bugs
07:36:12 <corgifex> Trollinator: ... seems obvious?
07:36:26 <toki78> Axman6, would you be so kind an reload it ﬂ
07:36:28 <corgifex> Trollinator: you need to remove 'table' from the recursive changeRec call and add it to lookup
07:36:34 <Axman6> toki78: can I have the link again?
07:36:47 <toki78> Axman6, http://toki.burn3r.de/html5-projects/boolean-functions.html
07:36:58 <toki78> I'm so proud, if it works
07:37:27 <Axman6> toki78: looking much better already
07:37:29 <Trollinator> oh yeah, sorry,
07:37:33 <Trollinator> but still it doesn't compile
07:37:40 <Trollinator> wait, i'll update the paste
07:37:43 <toki78> Axman6, thx :)
07:37:47 <Axman6> I still have no idea what it's really doing, but it's pretty :P
07:38:17 <toki78> Axman6, function Approximation with 4-Sat insteat NNs
07:38:46 <Axman6> right
07:39:09 <Trollinator> corgifex: ‚Äúfixed‚Äù it
07:39:22 <Trollinator> it still complains about the first argument to ST not matching.
07:39:31 <toki78> Axman6, the algo is less code, but more complicated
07:40:02 <corgifex> Trollinator: try removing $
07:40:09 <toki78> Axman6, a stochastic SAT solver does the work of finding the parameters
07:40:10 <benzrf> :t (<*)
07:40:11 * Axman6 wishes he had OS X 10.10 so he could use the llvm based JIT in safari and speed this up
07:40:11 <lambdabot> Applicative f => f a -> f b -> f a
07:40:15 <corgifex> Trollinator: (the one after runST)
07:40:24 <benzrf> Axman6: http://i.imgur.com/0xzmKXv.png
07:40:37 <Axman6> oh yeah, ($) doesn't play well with ST
07:41:02 <Axman6> benzrf: ?
07:41:06 <Trollinator> that doesn't fix it.
07:41:16 <cr7> a = map (\k -> replicate k k) lst
07:41:16 <cr7>  c = concat a
07:41:19 <corgifex> Trollinator: same error?
07:41:32 <cr7> how should i return c in myFunc? Thanks in advance!
07:41:55 <Trollinator> yes
07:41:57 <benzrf> Axman6: helpful graph
07:42:05 <Axman6> benzrf: there is no scale, I am lost!
07:42:45 <Axman6> oh man, took me far too long to figure out what ganoo was, had to say it out loud :P
07:43:11 <benzrf> Axman6: nice going
07:43:36 <corgifex> Trollinator: ok, now remove the type signature from changeRec
07:43:48 <Trollinator> been there, done that.
07:43:56 <corgifex> that should at least change the error message
07:44:06 <Trollinator> it does.
07:44:20 <Pythonfant> :t concatMap
07:44:21 <lambdabot> (a -> [b]) -> [a] -> [b]
07:44:28 <Pythonfant> cr7: I think that's what you want
07:44:59 <toki78> Axman6, I don't know, if PBFs can do abstraction, as NNs can do
07:45:04 <Pythonfant> so just concatMap (\x -> replicate x x) should do the trick
07:45:15 <Pythonfant> > concatMap (\x -> replicate x x) [1,2,3]
07:45:17 <lambdabot>  [1,2,2,3,3,3]
07:45:33 <Axman6> toki78: this isn't really an area I'm that familliar with
07:45:53 <benzrf> Pythonfant: or, you know, (>>= join replicate)
07:46:14 <benzrf> :t join `asAppliedTo` replicate
07:46:15 <lambdabot> (Int -> Int -> [Int]) -> Int -> [Int]
07:46:24 <cr7> yeah! It worked.. thanks a lot guys!
07:46:30 <toki78> Axman6, sorry, I dont wanna bother
07:46:33 <benzrf>  
07:47:06 <Axman6> toki78: that's ok, it looks interesting, but it's very late here and I'm too tired to learn what's actually going on =) people in #haskell-blah might be interested too
07:47:06 <toki78> Axman6, do you know, whom to contact about this ?
07:50:03 <Trollinator> It's great that buggy programs basically never typecheck in Haskell. But more often than not, the error messages are less than helpful :\
07:50:21 <corgifex> Trollinator: did you update your paste with the latest errors, btw?
07:50:58 <Trollinator> you mean the one without the type signature? no.
07:51:47 <Trollinator> In any case I feel uncomfortable just removing it. I can hardly claim to understand what's going on if I can't give a type signature for that function.
07:52:01 <corgifex> but that type signature is wrong
07:52:35 <Maxdamantus> >> [1,2,3] >>= replicate >>= id
07:52:37 <Maxdamantus> > [1,2,3] >>= replicate >>= id
07:52:39 <lambdabot>  Couldn't match type ‚Äò[[b]]‚Äô with ‚Äòa0 -> [a0]‚Äô
07:52:39 <lambdabot>  Expected type: GHC.Types.Int -> [[b]]
07:52:39 <lambdabot>    Actual type: GHC.Types.Int -> a0 -> [a0]
07:52:57 <Maxdamantus> > [1,2,3] >>= (replicate >>= id)
07:52:58 <lambdabot>  [1,2,2,3,3,3]
07:53:10 <Axman6> or just join replicate
07:53:16 <Trollinator> yeah well, what is the right signature?
07:53:40 <corgifex> Trollinator: I'm not sure it's expressible
07:53:49 <Cale> Trollinator: I'd say that more often than not, the error messages *are* useful if you read them carefully enough
07:54:08 <corgifex> the 's' in your signature currently claims to be fully polymorphic but it actually depends on 'table'
07:54:21 <Cale> Sometimes when the compiler makes a guess at the reason for a particular problem, it guesses incorrectly
07:54:27 <Yuu-chan> Can anybody help with installing hsSDL on Windows? Description in WIN32 file from the package doesn't help.
07:55:02 <Cale> But it's rare to see the description of the problem itself being wrong.
07:56:00 <Maxdamantus> > [\a -> a] !! 1
07:56:02 <lambdabot>  No instance for (Data.Typeable.Internal.Typeable t0)
07:56:02 <lambdabot>    arising from a use of ‚ÄòM23010844270702402182493.show_M23010844270702402182...
07:56:02 <lambdabot>  The type variable ‚Äòt0‚Äô is ambiguous
07:56:02 <lambdabot>  Note: there are several potential instances:
07:56:02 <lambdabot>    instance Data.Typeable.Internal.Typeable Data.Dynamic.Dynamic
07:56:15 <Trollinator> Cale: neither are STL error messages, yet nobody calls those readable.
07:56:21 <cr7> so concatMap(....) is a function over a function?
07:56:26 <Maxdamantus> > [\a -> a :: Integer] !! 1
07:56:27 <lambdabot>  <Integer -> Integer>
07:57:07 <Axman6> cr7: yes, so is map
07:57:09 <Maxdamantus> concatMap takes a function as its argument, yes.
07:57:25 <Axman6> it's called a higher order function; a function that takes a function as an argument
07:57:39 <Axman6> :t concatMap
07:57:40 <lambdabot> (a -> [b]) -> [a] -> [b]
07:57:45 <Axman6> :t concatMap show
07:57:46 <lambdabot> Show a => [a] -> [Char]
07:57:54 <Cale> Trollinator: Do you have an example of a message which isn't readable? I suppose there are certain libraries in Haskell which can result in unhelpful error messages, but if you're not going crazy with type synonyms for type constructors with 6 or 7 parameters, they're typically pretty direct.
07:58:06 <Axman6> > concatMap show [True,False]
07:58:07 <lambdabot>  "TrueFalse"
07:58:55 <Axman6> Cale: I seem to remember running into pretty inpenatrable errors when dealing with ST in the past
07:59:07 <Trollinator> Cale: I suppose it's a matter of practice.
07:59:34 <bennofs> pipes and lens often cause pretty terrible errors
07:59:53 <bennofs> but I guess that falls under the type synonyms argument :)
08:00:09 <Trollinator> Cale: I can't make sense of this error message: http://lpaste.net/105964
08:01:05 <Axman6> Trollinator: if you can give a type for table somewhere, it should fix it
08:01:32 <Axman6> let f :: Table (Int, Int) Int; f = table
08:01:52 <monochrom> this is similar to "show (read xxx)"
08:01:55 <Axman6> or even let _ = table :: Table (Int,Int) Int
08:01:58 <monochrom> > show (read "xxx")
08:01:59 <lambdabot>  "*Exception: Prelude.read: no parse
08:02:00 <Axman6> or whatever the type should be
08:02:12 <monochrom> oh oops, lambdabot disambiguates it
08:02:34 <dagle> Wow, libHSpandoc is huge.
08:03:02 <monochrom> > show (read "xxx" :: a)
08:03:03 <lambdabot>  No instance for (GHC.Read.Read a)
08:03:04 <lambdabot>    arising from a use of ‚ÄòText.Read.read‚Äô
08:03:04 <lambdabot>  Possible fix:
08:03:04 <lambdabot>    add (GHC.Read.Read a) to the context of
08:03:04 <lambdabot>      an expression type signature: a
08:03:32 <Maxdamantus> > show (\True -> read "xxx")
08:03:34 <lambdabot>  No instance for (Data.Typeable.Internal.Typeable a0)
08:03:34 <lambdabot>    arising from a use of ‚ÄòGHC.Show.show‚Äô
08:03:34 <lambdabot>  The type variable ‚Äòa0‚Äô is ambiguous
08:03:34 <lambdabot>  Note: there are several potential instances:
08:03:34 <lambdabot>    instance Data.Typeable.Internal.Typeable Data.Dynamic.Dynamic
08:03:48 <monochrom> nice
08:04:12 <luite> hmm, when doing 'cabal install' with a Setup.hs file with some hooks, only 'main' seems to get run, not postInst, what am I missing here?
08:04:15 <luite> ghcjsHooks = simpleUserHooks { postInst = ghcjsPostInst }; main = defaultMainWithHooks ghcjsHooks; ghcjsPostInst args flags descr lbi = putStrLn "hello this is postInst"
08:04:42 <Trollinator> Oh, that actually works. table :: HashTable s (Int, Int) Int <- new
08:05:10 <Trollinator> but it's not standard Haskell because it requires something called -XScopedTypeVariables
08:06:02 <Axman6> Trollinator: I think the let _ = ... :: ... should work too
08:06:24 <Axman6> it's kinda ugly putting the type inline there
08:07:13 <Trollinator> I need to use monadic bind, so that messes things up.
08:07:33 <Trollinator> It can be done, this works:  table  <- new :: ST s (HashTable s (Int, Int) Int)
08:07:50 <Trollinator> but I'd rather not spell out more types than I have to.
08:08:23 <monochrom> ScopedTypeVariables is a good extension.
08:08:25 <Trollinator> in this case, I can leave the ‚ÄúST s‚Äù out by putting the type on the left of the <-
08:09:20 <Trollinator> monochrom: is it strictly necessary to make the code I wrote typecheck?
08:09:58 <Trollinator> I wonder why it's not in Haskell 2010.
08:10:08 <monochrom> it is strictly necessary for type annotations at some binder positions
08:10:52 <Trollinator> *sigh*
08:11:00 <Trollinator> I feel like I'll never grok this stuff.
08:11:21 <Trollinator> a monad is just a monoid in the category of endofunctors. Clear as mud.
08:11:45 <monochrom> no one really uses that. it's a joke.
08:11:58 <monochrom> or a strawman argument.
08:12:13 <tharper> chrisdone: ping
08:12:33 <Trollinator> I know. But there's a reason why people make jokes like that about Haskell.
08:13:23 <l0cust> can someone explain to me what the point of Data.Text is?
08:13:33 <l0cust> What is wrong with plain old [Char]?
08:13:39 <Trollinator> it's slow.
08:13:40 <monochrom> did you know that if you theorize OOP (check out Luca Cardelli's stuff for example), it's even more mind-bending than category theory?
08:13:53 <Axman6> String is so slow
08:14:13 <l0cust> What's the difference in the implementations, then?
08:14:18 <monochrom> and I doubt that even people against OOP use that as an argument.
08:14:52 <Axman6> l0cust: Text is an unvoxed array of Int16 basically (iirc)
08:15:03 <zq> what framework does hackage use?
08:15:03 <Axman6> unboxed*
08:15:08 <Trollinator> I'm not trying to criticise Haskell here. I'm just expressing my feelings.
08:15:33 <l0cust> Axman6: thanks. I was about to spend 20 minutes trying to figure out what voxing was
08:15:40 <atota> Trollinator: express in haskell, english is full of ambiguities
08:15:55 <Axman6> Trollinator: I've been using Haskell for going on 7 years and still don't really understand (nore care) what that definition of a monad means
08:15:59 <loz2> Cale: so, (+) is a monoid in category of numbers, isn't it?
08:16:42 <l0cust> zq: https://github.com/haskell/hackage-server
08:16:54 <monochrom> ok, but from what I see, it was not just expressing feelings
08:17:23 <Trollinator> ‚ÄúI **feel** like I'll never grok this stuff‚Äù
08:17:33 <Trollinator> and we should be talking about our feelings, right?
08:17:35 <Trollinator> http://www.youtube.com/watch?v=hzf3hTUKk8U&t=24m33s
08:17:41 <l0cust> zq: Happstack
08:17:56 <monochrom> no, we shouldn't.
08:17:58 <Axman6> l0cust: http://hackage.haskell.org/package/text-1.1.1.3/docs/Data-Text.html#g:2 might help a bit
08:18:13 <Trollinator> monochrom: the guy in the video disagrees.
08:18:45 <monochrom> ok, tell that guy: the guy in #haskell disagrees
08:19:06 <monochrom> (why am I no more authoritative than a random loser on youtube?)
08:19:29 <zq> l0cust: thanks, i was going through its cabal setup file and wondering why there were no mentions of snap or yesod
08:19:40 <Trollinator> because you're calling them losers without a reason.
08:19:40 <l0cust> zq: Yesod is terrible.
08:19:52 <l0cust> Trollinator: I invite you to read the comments on any youtube video
08:20:01 <Axman6> I quite like yesod...
08:20:20 <atota> hell no, fp makes people miserable
08:20:25 <l0cust> My issue is the documentation
08:20:29 <l0cust> it's just godawful
08:20:38 <Axman6> I can agree there for a lot of things
08:20:39 <Trollinator> l0cust: http://xkcd.com/202/
08:20:44 <atota> l0cust: then look at the source
08:21:00 <l0cust> atota: Gee, I never thought of that before /s
08:21:08 <Axman6> atota: it's often no more useful (at least the source of many of the types anyway)
08:21:31 <l0cust> The issue is, Snoyman seems to have this big elegant design
08:21:33 <l0cust> which is great
08:21:55 <l0cust> if he would explain his big elegant design somewhere
08:22:29 <Axman6> the book is good for a lot of stuff, but when you want to venture outside what's discussed in the book, there's a lot you have to figure out yourself
08:22:48 <eazar001> any opinions/experiences with snap framework?
08:23:03 <l0cust> I don't care for the default templating system, heist
08:23:12 <l0cust> But other than that, it seems okay
08:23:25 <Axman6> got a better one? I'm quite liking it
08:23:29 <eazar001> what's wrong with heist?
08:23:51 <l0cust> Nothing objective, I just don't like it
08:23:55 <eazar001> i see
08:24:07 <l0cust> It doesn't benchmark quite as well as Happstack
08:24:12 <eazar001> they have compiled heist now apparently
08:24:20 <eazar001> which is much better than interpreted
08:24:23 <eazar001> of course
08:24:26 <l0cust> I'm pretty sure any web developer would cringe at the sight of blaze
08:24:42 <Axman6> why?
08:24:54 <l0cust> Oh, the Haskell part
08:25:02 <atota> it is like enlightenment, the more one knows, the more uncertain one gets
08:25:42 <Trollinator> atota: I thought that's called the Dunning-Kruger effect.
08:26:22 <l0cust> atota: are you sure about that?
08:26:47 <monochrom> hehe
08:27:05 <l0cust> Axman6: I like blaze a lot better than plain HTML
08:27:07 <atota> Trollinator: interesting dualistic categorization
08:27:29 <Axman6> I like heist a lot better than plain HTML =)
08:27:31 <l0cust> Axman6: XML is one of the dumbest things we've done in the programming world
08:27:45 <l0cust> Axman6: I'm not a fan of closing tags
08:27:51 <monochrom> I am
08:28:01 <Axman6> so use heist :P
08:28:01 <atota> l0cust: sure, bout everyone is different
08:28:14 <l0cust> atota: Not arguing
08:28:19 <l0cust> atota: just explaining
08:28:46 <l0cust> I don't think anyone can argue that XML is good for much anymore
08:28:50 <l0cust> JSON is just miles better
08:28:59 <l0cust> YAML is a bit too complex to be useful
08:29:08 <atota> though it is funny how people here will mistake a misspelled word as some unknown supertheory that they haven't heard before
08:29:18 <corgifex> I'm not a fan of opening tags: <><><>Hello</msg></content></body>
08:29:34 <monochrom> hehe
08:29:40 <l0cust> Combinators are best
08:29:48 <Axman6> those >'s are so redundant
08:29:52 <Tjr> Let's assume I don't understand an expression, e.g. "[1,2,3] >>= (replicate >>= id)" or "(>>= join replicate)".
08:30:04 <l0cust> Tjr: fuck off with your relevant question
08:30:07 <l0cust> Tjr: we're having fun
08:30:20 * corgifex assumes
08:30:21 <Tjr> How would I tickle ghci until it tells me what >>= is being applied to in this case?
08:30:31 <corgifex> eh?
08:30:39 <corgifex> it's right there in the code
08:30:41 <atota> having fun and being happy are two different things
08:30:44 <Tjr> I know I could do it with pencil and paper, tracin gthings until I know what
08:30:45 <Axman6> :t replicate >>= id
08:30:46 <lambdabot> Int -> [Int]
08:30:48 <Tjr> 's going on
08:30:49 <monochrom> something about ghci's debugger and breakpoints. but I don't know the details.
08:30:50 <corgifex> >>= is applied to [1,2,3] and (replicate >>= id)
08:30:55 <Trollinator> l0cust: JSON lacks references (to make cyclic data structures) and disjoint unions.
08:30:56 <corgifex> and the other >>= is applied to replicate and id
08:31:12 <l0cust> Trollinator: good point
08:31:21 <l0cust> Trollinator: well, no, you can put them in
08:31:27 <l0cust> Trollinator: but they are stringified
08:31:42 <Trollinator> That's a tautology.
08:31:49 <Tjr> For example, in case of "(>>= join replicate)", I'd guess >>= is using the function composition monad to somehow duplicate the argumetns to replicate
08:32:02 <corgifex> Tjr: that's the 'join replicate' bit
08:32:06 <corgifex> join f x = f x x
08:32:09 <Trollinator> Strings are JSON values, and so are Haskell programs, therefore JSON can do anything Haskell can.
08:32:13 <Trollinator> it doesn't really work like that.
08:32:22 <corgifex> inb4 the char* monoid
08:32:25 <monochrom> is it?
08:32:34 <monochrom> @type (>>= join replicate)
08:32:35 <lambdabot> [Int] -> [Int]
08:32:43 <corgifex> :t join replicate
08:32:44 <lambdabot> Int -> [Int]
08:32:59 <Tjr> corgifex: your answer is only meaningful if you say what x is in this case. My question is how to get the compiler to tell me that.
08:33:04 <corgifex> > join f x :: Expr
08:33:05 <lambdabot>  f x x
08:33:11 <corgifex> is it?
08:33:21 <Trollinator> Json is surely more sane than XML, but we need to do better still.
08:33:30 <Tjr> what's Expr?
08:33:34 <corgifex> some type
08:33:39 <corgifex> in a module somewhere
08:33:48 <loz2> Trollinator: fellow erlangers have a concept of such thing http://ninenines.eu/talks/bed/bed.html
08:33:51 <monochrom> ok, ghci doesn't have a walk-you-through-type-inference
08:33:56 <tristan__> wooo, erlangers
08:33:59 <tristan__> I joined at the right time, haha
08:34:10 <loz2> :D
08:34:20 <tristan__> but sadly joining because I'm angry at cabal
08:34:20 <Tjr> where/how would I get a walk-you-through-type-inference for a specific piece of code?
08:34:56 <corgifex> I'm not aware of such a thing
08:34:56 <Tjr> :t join
08:34:57 <lambdabot> Monad m => m (m a) -> m a
08:35:02 <tristan__> is there somethign special about alex and happy? I have them in my cabal file and I see they get instaleld in the sandbox (but in .cabal-sandbox/share)
08:35:03 <corgifex> it's all Intuitively Obvious(tm)
08:35:12 <tristan__> but when I run configure or build it complains that they aren't there
08:35:14 <monochrom> I usually do it by hand
08:35:29 <corgifex> tristan__: are they in your PATH?
08:35:29 <dcoutts> tristan__: they're programs, not libraries. cabal wants to find them on your $PATH
08:35:47 <l0cust> http://lpaste.net/105975
08:35:54 <l0cust> so, I asked this earlier
08:35:54 <Tjr> Why does "join f x" evaluate to "f x x"?
08:36:00 <l0cust> And nobody was able to answer
08:36:16 <corgifex> Tjr: because of how >>= is defined for the (e ->) monad
08:36:16 <l0cust> happstack-server-tls is claiming I don't have crypto++ installed
08:36:23 <corgifex> Tjr: a.k.a. the naked reader
08:36:25 <l0cust> when, in fact, I do
08:36:33 <dcoutts> l0cust: can gcc find it?
08:36:45 <l0cust> dcoutts: how to gcc?
08:36:53 <dcoutts> l0cust: if gcc can't find it then cabal/ghc will not be able to either
08:36:59 <Tjr> corgifex: so how does ghci know that "join f x" is supposed to call the fucntion composition monad?
08:37:07 <corgifex> Tjr: it's not composition
08:37:08 <l0cust> dcoutts: how do I check if gcc knows about it?
08:37:10 <tristan__> corgifex: dcoutts ok, is there not a way to hvae it add those automatically so I don't have to add each one manually?
08:37:12 <dcoutts> l0cust: gcc test.o -lcryptopp
08:37:35 <Trollinator> loz2: thanks
08:37:46 <dcoutts> tristan__: usual thing is just to install alex & happy once, and put them on your path
08:37:56 <Tjr> so how does ghci know which monad to use for "join f x"?
08:38:00 <corgifex> :t replicate
08:38:01 <lambdabot> Int -> a -> [a]
08:38:09 <Tjr> :t join f x
08:38:10 <lambdabot> FromExpr a => a
08:38:11 <tristan__> dcoutts: yea, doesn't work for me :(. trying to use https://github.com/mietek/haskell-on-heroku
08:38:18 <dcoutts> tristan__: for example by configuring cabal to put a symlink into ~/bin when it installs programs
08:38:23 <corgifex> Tjr: join :: (Monad m) => m (m a) -> m a; replicate :: Int -> b -> [b]
08:38:24 <tristan__> and if I don't have alex and happy in my cabal file it fails to intsall pandoc
08:38:35 <tristan__> ah, hm
08:38:48 <corgifex> Tjr: 'join replicate' will then try to unify 'm (m a)' with 'Int -> (b -> [b])'
08:38:54 <loz2> Trollinator: it's open to discuss afaik, there is a link to github repo in the end of presentation
08:39:02 <dcoutts> tristan__: they don't need to be installed system wide. The other alternative is to add ~/.cabal/bin to your $PATH
08:39:33 <corgifex> Tjr: also, 'Int -> (b -> [b])' is equivalent to '(->) Int ((->) b [b])'
08:39:41 <tristan__> dcoutts: ok, will try a few things, thanks
08:39:47 <dcoutts> tristan__: or irrc, sufficiently new versions of cabal will also look in the target bindir for programs
08:40:14 <corgifex> Tjr: from this the type checker deduces m = (->) Int; m = (->) b; a = [b]
08:40:27 <corgifex> Tjr: which in turn leads to b = Int and a = [Int]
08:40:40 <l0cust> dcoutts: Getting this error http://lpaste.net/105977
08:40:57 <Tjr> corgifex: "will then try to unify 'm (m a)' with 'Int -> (b -> [b])'" thanks, that clears it up. I mentally omitted the Int part of the type signature of replicate
08:41:36 <dcoutts> l0cust: that might be the problem. The happstack-server-tls does not specify -pthread
08:42:05 <l0cust> dcoutts: how do I fix this problem
08:42:07 <l0cust> ?
08:42:13 <dcoutts> l0cust: if you unpack the package and run configure -v3, I think it'll show you the link error that cabal encounters that causes it to give you the message about missing cryptopp
08:42:30 <dcoutts> l0cust: depends on exactly what it is, have a look at the link error that cabal hits
08:42:40 <benzrf> :t replicate
08:42:41 <lambdabot> Int -> a -> [a]
08:42:42 <benzrf> mmm
08:42:59 <benzrf> i should learn some tipe therioy
08:43:18 <l0cust> dcoutts: http://lpaste.net/105978
08:44:40 <dcoutts> l0cust: is that all of it? looks truncated
08:45:02 <l0cust> There were two lines that didn't make the pipe
08:45:04 <l0cust> cabal: At least the following dependencies are missing:
08:45:04 <l0cust> HsOpenSSL ==0.10.*
08:45:30 <l0cust> That is, I ran cabal ... , and piped the output to lpaste
08:45:37 <l0cust> those lines were printed afterward
08:45:38 <dcoutts> ok, just do cabal install -v3 instead of configure
08:46:23 <l0cust> dcoutts: http://lpaste.net/105980
08:47:09 <dcoutts> l0cust: ah, look in /home/pete/src/podium/.cabal-sandbox/logs/happstack-server-tls-7.1.0.log
08:47:17 <Tjr> corgifex: you said earlier that the reader monad is not function composition. However the fmap associated with ((->) r ) is (.), i.e. function composition. Shouldn't then the fmap derived from reader's >>= be (.), too?
08:47:24 <dcoutts> l0cust: the bit before collect2: error: ld returned 1 exit status
08:47:39 <dcoutts> l0cust: looks like the same error as when you tried it manually
08:47:44 <Tjr>  associated with the functor ((->) r )
08:47:46 <corgifex> Tjr: oh, yes. fmap is (.) there
08:48:04 <Tjr> so why do you say that the reader monad and the function composition monad are not the same?
08:48:08 <l0cust> dcoutts: http://lpaste.net/105981
08:48:13 <benzrf> Tjr: do you mean bind in the reader monad?
08:48:17 <Tjr> or did I get you wrong?
08:48:23 <benzrf> :t (>>=) `asAppliedTo` id
08:48:23 <dcoutts> l0cust: so you could try editing the .cabal file and add ld-options: -pthread  next to where it currently lists cryptopp
08:48:24 <lambdabot> (a -> a) -> (a -> a -> b) -> a -> b
08:48:31 <corgifex> Tjr: I've never heard "function composition monad" before
08:48:32 <benzrf> :t (>>=) `asAppliedTo` (undefined :: a -> b)
08:48:33 <lambdabot> (a -> b1) -> (b1 -> a -> b) -> a -> b
08:48:40 <corgifex> and I typically don't think of fmap as part of Monad
08:49:01 <Tjr> fmap = (flip (>>=)) . return
08:49:13 <corgifex> = liftM
08:49:18 <ion> (=<<)
08:49:28 <benzrf> @src (=<<)
08:49:28 <lambdabot> f =<< x = x >>= f
08:49:29 <l0cust> dcoutts: like this? http://lpaste.net/105982
08:49:31 <dcoutts> l0cust: now strictly speaking I'd call this a bug in the cryptopp library, it should already be linked against pthreads
08:49:35 <monochrom> I don't think there is such a thing as "function composition monad" to begin with.
08:49:38 <corgifex> @src liftM
08:49:38 <lambdabot> liftM f m1 = do { x1 <- m1; return (f x1) }
08:49:58 <l0cust> oops
08:50:10 <monochrom> or rather, such wording
08:50:47 <l0cust> dcoutts: here we go http://lpaste.net/105984
08:51:06 <l0cust> dcoutts: was that what you were suggesting?
08:51:11 <dcoutts> l0cust: yep
08:51:42 <l0cust> dcoutts: http://lpaste.net/105985
08:51:46 <l0cust> dcoutts: failed again
08:52:28 <l0cust> dcoutts: that looks like a bug in my code
08:52:32 <dcoutts> l0cust: note that it's a different error
08:52:50 <l0cust> dcoutts: Yeah, I forgot to import something
08:52:55 <klaff> How do you say medal of each kind? Medal of each valor?
08:52:56 <l0cust> but the tls build worked!
08:52:57 <l0cust> yay
08:53:08 <l0cust> dcoutts: thank you. I am ignorant at c things
08:53:17 <dcoutts> l0cust: so I'd say that someone should go and report a bug against cryptopp
08:53:25 <l0cust> dcoutts: The people on #archlinux just suggested that I "reboot until it starts working"
08:53:33 <dcoutts> l0cust: though you may also want to notify the author of the haskell tls package
08:53:59 <l0cust> dcoutts: I really wouldn't know what the bug is. I understand that there was a missing compiler flag
08:54:09 <monochrom> each medal
08:54:12 <l0cust> but that's about it
08:54:51 <dcoutts> l0cust: ok, well at least report it to the author of happstack-server-tls
08:55:02 <l0cust> okay
08:55:05 <dcoutts> ta
09:00:42 <l0cust> dcoutts: i emailed the author
09:00:47 <dcoutts> cheers
09:01:41 <l0cust> dcoutts++
09:22:40 <l0cust> tb01110100: we meet again
09:22:47 <tb01110100> l0cust: wat
09:22:51 <tb01110100> wat do you want
09:24:45 <benzrf> hmmm
09:29:12 <hexagoxel> aww yis type inference. make some error in line 1, get error messages for lines 2,3,4.
09:29:46 <hexagoxel> (in a do block)
09:30:46 <hexagoxel> and each error message is 80 lines long, of course :D
09:31:51 <corgifex> make better mistakes :-)
09:31:54 <kazagistar> hexagoxel: well, usually the errors are 80 lines long because they mension line 1 as well, in order to explain their reasoning about why line 2 is wrong, right?
09:31:55 <Tjr> a while ago we had a discussion in here about a "constructable" typeclass, dual to foldable. LYAH talks about zippers. I'd say zippers are dual to foldable. Is there some kind of generalization, like Foldable generalizes lists?
09:32:42 <eazar001> is http-conduit the de-facto standard these days?
09:32:48 <johnw> I think it was called Buildable
09:32:57 <johnw> eazar001: http-conduit is already deprecated!
09:33:03 <eazar001> ??
09:33:03 <johnw> http-client replaced it
09:33:11 <eazar001> johnw, thanks
09:33:18 <johnw> also, wreq is cool
09:33:42 <eazar001> will check out wreq too
09:34:40 <mjrosenb> where does the random monad live these days?
09:35:00 <Tjr> do monads move around that fast?
09:35:18 <mjrosenb> Tjr: well, I haven't needed it in like 2 years.
09:35:37 <hexagoxel> kazagistar: no, in this case i think the wrong monad is infered from the first (faulty) statement, which causes the other statements to fail
09:36:12 <mjrosenb> hrmm... no System.Random
09:36:18 <mjrosenb> I wonder if my install is messed up
09:36:33 <kazagistar> and the other error messages dont mention that line 1 was where the type of monad was bound? ugh
09:37:24 <slomo> johnw: as you seem to know about http-client... do you know if it supports keep-alive connections automagically if you reuse the some manager for requests?
09:38:15 <hexagoxel> kazagistar: well it mentions the context, but does not point to the first line explicitly
09:38:51 <Tjr> Short of asking in here, how would I know what's the module-du-jour if I want to do something?
09:38:52 <hexagoxel> nor does ghc explain where the expected type comes from
09:39:08 <Cale> hexagoxel: GHC tends to be pretty good at reporting disjoint problems with the code
09:39:55 <Cale> (i.e. you can actually work through the errors, and they will actually tend to all correspond to different issues, at least from what I've seen)
09:40:20 <Cale> Not always, I suppose
09:40:25 <Cale> But usually
09:40:33 <Tjr> Cale: usually you need a crystal ball to make sense of them, though.
09:40:42 <johnw> slomo: I don't know, sorry
09:40:45 <Cale> Nah, you just need to read them carefully
09:40:54 <Cale> and learn what the words mean
09:42:03 <hexagoxel> yeah. i use some flexible monad stack where most of the types are not annotated, which asks for problems.
09:42:51 <hexagoxel> but in this case i really 1) have type-correct code 2) change first statement 3) get multiple errors that do not point to first statement in any way
09:43:29 <Cale> I would recommend always hiding your use of monad transformers by defining a newtype monad whose data constructor is not exported from the module, and writing a complete interface to that monad which is then exported and largely doesn't involve the MonadFoo class operations.
09:43:37 <slomo> johnw: thanks anyway :) to answer my question, it doesn't. let's see how i can make it work...
09:43:40 <Cale> Well, the implementations of those operations will.
09:44:54 <Cale> That way, all the explicit lifting is confined to that one module, and if you later need to change the implementation of the monad, the code which needs to change in response is all confined to one place.
09:50:38 <Tjr> Is there a pre-made class for zippers?
09:50:52 <hexagoxel> hmm but i _wanted_ to keep the stack flexible. but maybe i want too much. thanks for your input, Cale.
09:52:47 <Cale> hexagoxel: One thing which will occasionally happen is that you'll want to reimplement the monad directly for performance reasons, and if that happens, it can be a pain
09:52:53 <monochrom> hiding the stack behind an abstract type is how to be flexible
09:53:36 * hackagebot network-wai-router 0.1.2.0 - A routing library for wai  http://hackage.haskell.org/package/network-wai-router-0.1.2.0 (georgerogers42)
09:57:57 <hexagoxel> good point; for this case, i consider the performance to be irrelevant (the number of monadic actions is static and relatively low).
10:02:26 <Tjr> I made an Anki flashcard deck from Learn You a Haskell.
10:02:27 <Tjr> https://ankiweb.net/shared/info/1572953029
10:03:29 <monochrom> does it have pictures of elephants? :)
10:04:47 <Tjr> monochrom: :-)
10:05:04 <Tjr> it's pretty complete.
10:05:19 <Tjr> Every fact, library function, etc. is covered.
10:05:33 <Tjr> It doesn't cover the concepts that you should understand rather than memorize.
10:07:27 <benzrf> Tjr: can u into monads
10:07:41 <l0cust> So, I'm trying to run a Happstack HTTPS server, and I'm getting this error: http://lpaste.net/105990
10:07:51 <l0cust> nope
10:07:54 <l0cust> that's not it
10:08:36 <l0cust> here we go http://lpaste.net/105991
10:08:40 <yac> When I'm ducking for haskell lib docs I often get links to older versions. It would be really nice if there were a link to the newest
10:08:53 <yac> it's pretty common in python docs
10:08:56 <benzrf> yac: ducking?
10:09:00 <benzrf> is this the new verb alternative to googling
10:09:05 <yac> benzrf: duckduckgo
10:09:12 <benzrf> yac: i thought so p:
10:09:18 <fmapE> edwardk: hello
10:09:21 <monochrom> what is duckduckgo?
10:09:30 <benzrf> monochrom: a search engine for people who think google is evil
10:09:35 <yac> benzrf: well, it certainly isn't googling
10:09:36 <l0cust> monochrom: it doesn't track you
10:09:43 <l0cust> monochrom: it doesn't work, either
10:09:49 <l0cust> monochrom: but it doesn't track you
10:09:59 <yac> l0cust: it does  work.
10:10:08 <monochrom> more importantly, should your feature request be directed to duckduckgo rather than the haskell community, since the haskell community does not own duckduckgo?
10:10:13 <l0cust> yac: strictly speaking, but it's not nearly as good as google
10:10:13 <yac> I'm getting links to older version with google as well, just a little less
10:10:40 <yac> monochrom: well it's two issues really.
10:10:55 <yac> monochrom: one is that duckduckgo could give precedence to newer docs
10:11:13 <benzrf> ghci macros are neat
10:11:14 <monochrom> I tell you what. when I look for haskell lib docs, I don't google or duck. I go directly to hackage.haskell.org
10:11:26 <l0cust> hoogle is good, as well
10:11:26 <benzrf> monochrom: i tell you hwhat
10:11:27 <yac> monochrom: second is that the haskell docs could have a link to newest version. Like python docs have, it's super convenient
10:11:41 <l0cust> ^
10:12:01 <monochrom> ok, I tell you an algorithm for getting to the newest version
10:12:04 <k00mi> monochrom: appearently you can tell search engines what the canonical version of a document is
10:12:16 <l0cust> Anyway
10:12:37 <monochrom> suppose you're at http://hackage.haskell.org/package/aeson-0.3.0.0
10:12:58 <monochrom> delete the "-0.3.0.0", i.e., http://hackage.haskell.org/package/aeson . then it's the newest version
10:13:10 <monochrom> (do people read what's in an URL anymore?)
10:13:17 <luzie> or click the newest version at "Versions"
10:13:23 <yac> monochrom: that's tedious. Especially when you don't know everything by heart
10:13:42 <monochrom> I don't know everything by heart. it is still not tedious to me.
10:13:42 <yac> but ducking "hackage <lib>" instead of "haskell <lib>" seems to work well
10:14:01 <yac> thanks
10:14:21 <monochrom> I understand the part "how do I know it's aeson?"
10:14:46 <monochrom> I am saying that if google or duck points you to http://hackage.haskell.org/package/aeson-0.3.0.0, then you can delete -0.3.0.0 yourself
10:14:50 <luzie> duckduckgo supports !hackage, !hoogle and !hayoo, neat
10:18:13 <yac> monochrom: oh, right.
10:18:50 <c74d> For anyone here who uses Gentoo Linux ‚Äî what packages should I install, as someone wishing to get started with Haskell on that platform?
10:19:03 <yac> c74d: I'd start by adding haskell overlay
10:19:23 <yac> or not.
10:19:46 <yac> c74d: well, I'm starting with haskell as well but since I haven't shipped anything yet, I haven't bothered with packaging and just use cabal
10:21:57 <abstract-alf> howdy
10:21:58 <Pythonfant> c74d: I'm not on gentoo, but ghc and cabal is the only thing I install via my package manager (pacman on arch). For the rest I use cabal and sandbox everything
10:22:11 <c74d> I hear bad things about Cabal, like it can‚Äôt uninstall or upgrade packages?
10:22:35 <abstract-alf> yeah
10:22:38 <abstract-alf> it's true
10:22:49 <benzrf> well cabal isnt a package manager
10:22:56 <abstract-alf> in fact, cabal is not a package manager at all
10:23:02 <abstract-alf> ;x
10:23:14 <c74d> I‚Äôve heard the preferred method on Gentoo is to use their tool to turn Cabal packages into Portage packages.
10:23:28 <yac> c74d: do you really care? I mean. I'm just toying around now, so I'm fine with it. If I want a new one, I just delete ~/.cabal and reinstall things.
10:23:43 <yac> c74d: I will be bothering with packages only once I need to deploy things
10:24:21 <monochrom> don't forget to delete ~/.ghc
10:25:08 <c74d> I do care, I guess. Last time I wrestled with Cabal, I ended up cathartically uninstalling every Haskell package on my system‚Ä¶
10:25:44 <c74d> (That was a different system, with a different package manager and packages and more questionable support for Haskell.)
10:26:27 <c74d> I wasn‚Äôt really trying to *use* Haskell back then, though, just software written in it.
10:26:35 <Pythonfant> that's why I sandbox everything
10:28:17 <benzrf> :t curry snd
10:28:18 <lambdabot> a -> c -> c
10:28:22 <benzrf> :t curry fst
10:28:23 <lambdabot> c -> b -> c
10:28:25 <benzrf> coo
10:28:39 * hackagebot yaml-rpc 1.0 - Simple library for network (HTTP REST-like) YAML RPC  http://hackage.haskell.org/package/yaml-rpc-1.0 (IlyaPortnov)
10:29:09 <c74d> ‚Äúsandbox‚Äù how?
10:29:14 <abstract-alf> http://coldwa.st/e/blog/2013-08-20-Cabal-sandbox.html
10:29:16 <Pythonfant> cabal sandbox init
10:29:59 <Pythonfant> maybe there's a better way to do it, but at least it keeps me from having to reinstall everything
10:32:03 <_46bit> How can I export "data Direction = Idle | Left | Right deriving (Show, Eq)" in a module such that I can use Idle, Left and Right from outside it? module TM (Direction) seems not to work.
10:32:05 <_46bit> "sum.hs:6:36: Not in scope: data constructor `TM.Idle'"
10:32:19 <monochrom> Direction(..)
10:32:58 <_46bit> Thanks monochrom :-)
10:33:07 <c74d> that‚Äôd have copies of every package needed for each project? seems like a waste of space :/
10:33:21 <monochrom> another way is Direction(Idle, Left, Right) but then it's fragile, e.g., what if you add one more
10:33:26 <yac> c74d: the gentoo packages are using cabal internaly btw
10:33:29 <c74d> I guess I‚Äôm not willing to use Cabal. I hope that‚Äôs no cause for offense here.
10:33:39 * hackagebot yaml-rpc-scotty 1.0 - Scotty server backend for yaml-rpc  http://hackage.haskell.org/package/yaml-rpc-scotty-1.0 (IlyaPortnov)
10:33:49 <abstract-alf> c74d: lol I doubt anyone is offended
10:34:14 <c74d> yac: but with Portage to manage upgrades, uninstalling, and whatever, right?
10:34:47 <monochrom> c74d, I agree, it's why I am more inclined to think that sandboxing is mostly psychological, i.e., the real problem is not solved, you just feel better
10:35:06 <monochrom> two cases:
10:35:37 <monochrom> first case: you work on many projects concurrently. then you're re-installing many packages, as you observed.
10:36:14 <monochrom> second case: you work on one project. then I don't see why deleting ~/.ghc is harder than deleting a sandbox.
10:38:07 <monochrom> here is the only situation where sandboxing is an objective, not psychological, improvement. you work on two projects concurrently. one insists on Quickcheck-1. another insists on Quickcheck-2.
10:39:04 <johnw> or you want to build everything with profiling for one project, but not for another because it's needlessly slower in that case
10:40:23 <monochrom> no, IMO that is short-sighted. you will eventually want profiling for both.
10:40:38 <monochrom> and I say this as a theorist who had never really used profiling.
10:41:09 <johnw> there are days when I rebuild far, far too often for that to be a worthwhile argument
10:41:15 <johnw> I maybe using profiling 1% of the time
10:41:34 <johnw> it can add hours back to the week to not build for profiling sometimes, depending on the project
10:41:51 <monochrom> it's 0% for me, and I still recommend enabling profiling universally.
10:42:13 <johnw> i don't mind enabling it universally, as long as I can disable it locally
10:42:24 <johnw> ah, I see
10:42:25 <johnw> n/m me
10:42:50 <monochrom> I think I see too :)
10:42:54 <johnw> with Nix I have profiling and non-profiling environments, but I build stock packages for both
10:43:06 <johnw> that way I can focus the project_under_consideration to build with or without
10:43:41 <monochrom> ok, if you use Nix, you're one level above me :)
10:44:00 <johnw> Nix makes Haskell development an amazing thing
10:44:05 <jamiehannaford> can someone help me with creating an applicative functor? i'm having trouble defining the <*> http://lpaste.net/505152883461718016
10:44:06 <johnw> I'm going to blog about it hopefully tomorrow
10:44:22 <johnw> jamiehannaford: start with this:
10:44:30 <johnw> Parser p1 <*> Parser P2 = Parser $ \a -> ...
10:44:36 <dcoutts> johnw: there's a reason we're trying to make cabal into nix :-)
10:46:06 <johnw> I was pondering making the HP download a self-contained Nix environment instead of something that overlays onto the current system
10:46:44 <johnw> :t unfoldr
10:46:45 <lambdabot> (b -> Maybe (a, b)) -> b -> [a]
10:47:05 <johnw> jamiehannaford: ^^
10:48:53 <jamiehannaford> johnw it says do p1 first - so if I do `unfoldr p1 s' it will return the parsed value
10:49:07 <johnw> ahh, true
10:49:53 <jamiehannaford> `p1 <*> p2' represents the parser which first runs p1 (which will consume some input and produce a function), then passes the remaining input to p2 (which consumes more input and produces some value), then returns the result of applying the function to the value
10:49:55 <roconnor> johnw++
10:50:06 <monochrom> hmm, actually, why do you bring up unfoldr?
10:50:18 <johnw> I retract my unfoldr pointer
10:50:25 <monochrom> ok n/m :)
10:50:49 <jamiehannaford> what I don't understand is that if you do p1 first, that itself is the function which you later apply to the result of p2
10:51:08 <jamiehannaford> surely? since it's usually f <*> x
10:51:15 <monochrom> that is correct
10:52:52 <monochrom> we're looking at: Parser (p1 :: String -> Maybe (a -> b, String)) <*> Parser (p2 :: String -> Maybe (a, String)) = Parser (something :: String -> Maybe (b,String))
10:53:41 * hackagebot twidge 1.1.2 - Unix Command-Line Twitter and Identica Client  http://hackage.haskell.org/package/twidge-1.1.2 (JohnGoerzen)
10:54:57 <pjdelport> > Just (+2) <*> Just 3
10:54:59 <lambdabot>  Just 5
10:55:06 <pjdelport> > [Nothing <*> Just 3, Just (+2) <*> Nothing]
10:55:08 <lambdabot>  [Nothing,Nothing]
10:55:14 <pjdelport> (That may or may not help.)
10:55:26 <johnw> jamiehannaford: Parser p1 <*> Parser p2 = Parser $ runStateT (StateT p1 <*> StateT p2)
10:55:40 <johnw> that typechecks here at least
10:56:11 <jamiehannaford> johnw what is StateT and runStateT?
10:56:38 <johnw> they are monad transformers around functions of the type s -> m (a, s)
10:56:54 <johnw> since your Parser has that exact form, I can use StateT's Applicative
10:56:58 <jamiehannaford> johnw haven't got onto monads yet, so I think there's a different approach
10:57:01 <monochrom> haha, you're cheating
10:57:04 <johnw> ah, ok
10:57:08 <johnw> I didn't realize this was a learning exercise
10:57:14 <jamiehannaford> :)
10:57:24 <johnw> in that case, don't ask here! :)
10:57:43 <jamiehannaford> ha, but I'm really stuck!
10:58:19 <johnw> it going to start out: Parser p1 <*> Parser P2 = Parser $ \a -> ...
10:58:22 <johnw> now fill in ...
10:58:33 <johnw> case p1 a of ...
11:05:26 <jamiehannaford> johnw sorry I don't really know how to implement the concept with the provided details - I understand how to do it with [], Maybe or (->) r
11:08:23 <johnw> ok, when you are implementing <*> for a given type
11:08:36 <johnw> you almost always want to deconstruct both argument and then apply the left to the right
11:08:50 <johnw> so in the snippet I just pasted, I am unwrapping those arguments, and then rewrapping their result
11:10:04 <johnw> so for example: Parser p1 <*> Parser P2 = Parser $ \s -> case p1 s of Nothing -> Nothing; Just (f, s) -> case p2 s of Nothing -> Nothing; Just (x, s') -> Just (f x, s')
11:10:12 <johnw> now, I suggest reformatting that and studying it in detail until it become crystal clear
11:10:22 <johnw> (and making sure it works, of course)
11:10:33 <johnw> the idea with the Applicative is that if either the left or the right fails to parse, the whole fails to parse
11:10:45 <johnw> if both succeed at parsing, then you've parsed a function and an argument and can apply them together as the result of the parse
11:14:31 <jamiehannaford> johnw thanks - I'll try reformatting without case statements :)
11:15:43 <johnw> at some future date, you could use the Maybe monad too
11:15:47 <johnw> and then after that, StateT :)
11:15:51 <byorgey> johnw: were you looking for me?
11:16:00 <johnw> byorgey: I did one of your exercises!  hahaha
11:16:06 <byorgey> johnw: oh, nice =)
11:16:24 <johnw> byorgey: https://gist.github.com/16412ca53fcb81b7dbbe
11:16:25 <jamiehannaford> byorgey I'm doing week 10 - applicative functors. man it's hard!
11:16:25 <byorgey> exercise for what? Coq?
11:16:35 <johnw> it was an exercise from Typeclassopedia
11:16:37 <johnw> that I did in Coq
11:16:42 <byorgey> ah, nice =D
11:16:58 <taruti> Are there alternative haddock css-stylesheets?
11:17:03 <johnw> so, I have a question for any Haskeller out there
11:17:06 <monochrom> jamiehannaford: "reformat" means add line breaks and indentation. it does not mean "get rid of case"
11:17:22 <johnw> can you, by equational reasoning, go from: apply <$> m <*> (apply <$> m0 <*> m1)
11:17:28 <johnw> to: (apply <$> (apply <$> (fmap compose <$> m) <*> m0)) <*> m1
11:17:33 <johnw> using only the functor and applicative laws
11:17:55 <byorgey> johnw: what are 'apply' and 'compose'?  ($) and (.) ?
11:18:02 <johnw> <*> and (.)
11:18:05 <johnw> sorry, it's Applicative apply
11:18:09 <byorgey> oh, ok
11:18:48 <Eduard_Munteanu> :t liftA2 (<*>)
11:18:49 <lambdabot> (Applicative f1, Applicative f) => f (f1 (a -> b)) -> f (f1 a) -> f (f1 b)
11:18:51 <johnw> this is the 2nd applicative law for a monad transformer, btw
11:19:00 <johnw> which is why it's doubly-nested
11:19:37 <johnw> I don't know the answer, btw
11:19:46 <johnw> I've proven the other 4 for this same transformer
11:19:56 <johnw> and none of them were very hard; but this one has been a stumper
11:20:36 <johnw> if any interested party wants the theorem in Coq, it's on github and you can jump right to the goal
11:21:32 <mjrosenb> b/win 5
11:22:12 <jamiehannaford> byorgey is this what you had in mind when you asked to define `Parser a' as an applicative functor? http://lpaste.net/923304628748025856 johnw came up with a cool solution, but I didn't know whether it could be done without cases
11:22:33 <roconnor> johnw: Wow, you are not the hardened C++ programmer I imagined you to be.
11:22:42 <johnw> roconnor: how do you mean?
11:22:45 <byorgey> johnw: where is it on github?
11:23:06 <roconnor> johnw: Well, I guess I'm most familiar with your work on ledger.
11:23:09 <johnw> byorgey: https://github.com/jwiegley/simple-conduit/blob/master/coq/Either.v
11:23:13 <johnw> see the admit on line 170
11:23:23 <johnw> roconnor: I have a hardened C++ side too ;)
11:23:27 <roconnor> johnw: and I figured you were dabbling in Haskell ... and the Nix ... and now you have a proof in Coq!
11:23:38 <roconnor> johnw: This is not what C++ programmers do :)
11:23:41 <johnw> haha
11:23:47 <johnw> I'm also a big Lisp guy, don't forget
11:23:51 <byorgey> jamiehannaford: that's what I had in mind
11:24:00 <roconnor> johnw: I wasn't aware of your lisp history.
11:24:07 <johnw> although if you're not an Emacs user, you may not know that...
11:24:14 <roconnor> ah, I am not.
11:24:20 <johnw> yeah, Emacs/Lisp is where I've done the majority of my open source contributing
11:24:35 <byorgey> jamiehannaford: I think it is possible without explicit case expressions, using the Monad instance for Maybe, but obviously you are not expected to know that yet
11:25:07 <roconnor> johnw: Do you have any perspective on this idea that (typed) FP is heading towards mainstream programming?
11:25:07 <hexagoxel> i finally discovered the underlying cause of the nondescriptive type-errors i mentioned earlier: the monomorphism restriction caused problems for a variable binding used in all of the statements
11:25:16 <johnw> roconnor: my perspective is: yes
11:25:19 <jamiehannaford> byorgey thanks :)
11:25:45 <johnw> it certainly is, it will just take education for people to realize the benefits
11:25:55 <roconnor> johnw: interesting.  I've always felt too close to the FP world to tell if this was really happening, or I was just surrouned by crazy people.
11:26:01 <johnw> but multicore is a strong advocate for needing to bring programs back under control of human reasoning faculties
11:26:35 <johnw> back when the world was single-threaded, you could sometimes manage to keep program state in your head (or at least, people thought they could)
11:26:47 <johnw> with multicore, I think people universally agree that you can't do it
11:26:49 <roconnor> johnw: really, you are playing the multicore card?  ... I've never used parallel programming in Haskell before.
11:27:04 <johnw> in my perspective, multicore is FP's killer app at the moment
11:27:15 <roconnor> johnw: do you make use of it yet?
11:27:20 <johnw> yes, quite a lot
11:27:30 <johnw> in fact, I don't really write code anymore that doesn't use threading in some way
11:27:34 <roconnor> johnw: can you give an high level example or too?
11:27:38 <roconnor> *two
11:28:14 <johnw> sure, whenever I have a list of IO actions to run, and I don't care about sequencing, I throw it under "parallel" (using the parallel-io library), and I get instant speedup
11:28:32 <johnw> I use *concurrency* a lot, but *parallelism* almost never
11:28:41 <roconnor> when is an example where you have such a list?
11:28:58 <johnw> when building Git trees on disk in gitlib, for example
11:29:05 <johnw> it doesn't matter whether I create blobs at the same time
11:29:16 <roconnor> thanks
11:29:53 <roconnor> johnw: When did you start using Haskell?
11:30:01 <roconnor> and also Coq
11:30:09 <roconnor> (or Agda or whatever)
11:30:17 <bennofs> roconnor: I think multithreading applications like done with Haxl a pretty common when fetching more than one resource from a network
11:30:26 <johnw> I started really coding in Haskell in Aug 2012, I started playing with Coq in spring of 2013
11:31:10 <johnw> I'm at OPLSS right now (https://www.cs.uoregon.edu/research/summerschool/summer14/), where we are being taught about Coq and proof theory, so it has renewed my interest
11:31:36 <johnw> I've played with Agda too, and know it about equally as well as Coq, which isn't to say a whole lot
11:31:40 <k00mi> so I am implementing a client library for a protocol. At any time, the client may send or receive messages. My current design is to fork one thread that reads messages from an MVar and sends them and another that listens for incoming messages and then dispatches them to handlers
11:31:52 <k00mi> is this a sane design?
11:31:54 <roconnor> johnw: interesting.
11:32:48 <johnw> I can't even tell you how much I love working with Haskell
11:32:53 <k00mi> I am also unsure how to go about error handling and passing objects around
11:32:55 <roconnor> johnw: how many industry people are there?
11:33:04 <johnw> roconnor: not many at all
11:33:38 <johnw> it's mostly PhD students
11:33:43 <roconnor> right.
11:33:53 <benzrf> i will be a phd student too someday
11:33:54 * benzrf dreams
11:34:06 <johnw> the current lecture on Category Theory is far enough above my head now that I've mentally chceked out
11:34:18 <roconnor> johnw: *l*
11:34:29 <k00mi> I could do everything explicitly as function arguments and returning Either or throwing exceptions, I could build a concrete transformer stack that does all of this or I could use mtl's classes
11:35:00 <johnw> k00mi: isn't that what they call an actor model?
11:35:13 <johnw> i.e., you fork a thread that processes evens from a queue
11:35:15 <johnw> events*
11:36:21 <k00mi> it does sound similar
11:36:42 <johnw> i think your design sounds good
11:37:01 <k00mi> great :)
11:38:42 <johnw> roconnor: how long have you been using Haskell, or for what kind of work?
11:38:59 <johnw> I've certainly heard your name for as long as I've been reading about it
11:38:59 <roconnor> I started using Coq in 2000
11:39:24 <roconnor> And then I was (re-)introduced to Haskell as a Coq-like language where you could really do software development.
11:39:37 <johnw> did you start using Coq at university?
11:39:38 <roconnor> I've been using it as my main personal language since then.
11:40:05 <roconnor> johnw: at grad school at Berkeley.  But this was suggested by other graduate students, no professors.
11:40:17 <roconnor> I wanted to do computer verified math.
11:40:18 <johnw> did you continue to use Coq personally?
11:40:45 <roconnor> I haven't used it much since working on the Odd Order Theorem in 2012.
11:40:55 <roconnor> wait that isn't true
11:41:25 <roconnor> I proved that law-abiding traversable functors are finitary containers since then.
11:43:07 <johnw> that's neat; I want to use Coq as a way to ground my study of mathematics
11:43:26 <roconnor> I was first introduced to Haskell in 1998, but I dismissed it because I didn't see how it could possibly be better than SML.
11:43:37 <roconnor> 2 years lost
11:43:41 <vanila> I saw Coq to LLVM compiler
11:43:50 <vanila> so now Coq is suitable for real programming
11:44:08 <benzrf> coq more like qoc
11:44:24 <roconnor> johnw: the fun thing about constructive math is that you get to do undergrad math all over again.
11:44:39 <johnw> right, and since I never did undergrad math, even better... ;)
11:44:43 <roconnor> :)
11:44:53 <johnw> vanila: do you mean Vellvm mabye?
11:44:58 <fuzzyhorns> im following alone with this: http://en.wikibooks.org/wiki/Write_Yourself_a_Scheme_in_48_Hours/Parsing
11:45:08 <fuzzyhorns> but i cant figure out what my equivalent command is to this:
11:45:13 <fuzzyhorns> ghc -package parsec -o simple_parser [../code/listing3.2.hs listing3.2.hs]
11:45:21 <vanila> no, https://github.com/coq-ext-lib/coq-compile
11:45:24 <vanila> and i was just joking
11:45:29 <fuzzyhorns> it just keeps saying no such file or directory found when i subsitute listing etc etc with my file
11:45:36 <johnw> there is a real Coq in Coq project, I heard
11:47:39 <fuzzyhorns> halp :<
11:48:58 <corgifex> fuzzyhorns: I've never used -package and I have no idea what [ ] is doing there
11:49:20 <fuzzyhorns> it seems to be giving file paths to recompile disparate modules together
11:49:27 <fuzzyhorns> but i cant figure out how to google it effectively :P
11:49:34 <corgifex> fuzzyhorns: so I'd start with: ghc -o simple_parser listing3.2.hs
11:50:17 <derekv> I'd like to temporarily disable hlint warnings about no type signatures and I need help on how to dot that (using flycheck)
11:51:12 <bennofs> derekv: M-x flycheck-mode ? (This disables flycheck for the current buffer)
11:51:50 <derekv> bennofs: I really do want it to check for compile errors
11:52:23 <derekv> Just not "missing type signature", though I could live without hlint for a minute
11:53:08 <derekv> at least, I think the warning comes from hlint‚Ä¶ maybe it is ghc
11:53:44 <Lutin`> Does anyone have a good resource on setting up Vim for haskell dev?
11:55:11 <benzrf> int-e: u should totally add pipes to lambdabot
11:55:34 <benzrf> Lutin`: get syntastic + install ghc-mod
11:56:34 <Lutin`> Yeah I just can't see to get tab alignment working properly
11:58:15 <Lutin`> should probably install haskellmode-vim too
11:59:10 <deweyvm1> im drawing a blank, is there a builtin that does this? (Maybe a, Maybe b) -> Maybe (a, b)
11:59:34 <Lutin`> ah I need vimproc too for ghcmod-vim, and it looks like Vundle doesn't automatically compile it
11:59:35 <jmcarthur> soft announcement (not going to make a big deal of it): i have started a new twitter account, @fpmyths, which is about what it sounds like: common falsehoods and bad advice about functional programming.
11:59:42 <corgifex> :t uncurry (liftA2 (,))
11:59:43 <lambdabot> Applicative f => (f a, f b) -> f (a, b)
12:00:03 <benzrf> :t (**)
12:00:04 <lambdabot> Floating a => a -> a -> a
12:00:05 <Lutin`> benzrf: Do you install them manually or with Vundle/Pathogen/NeoBundle
12:00:15 <benzrf> Lutin`: i use pathogen
12:00:19 <benzrf> but not for any particular reason
12:00:21 <deweyvm1> aha! thanks
12:00:26 <benzrf> just cuz some plugin once told me i needed it
12:00:30 <benzrf> and then i started using it
12:00:35 <benzrf> didnt feel like switching
12:02:47 <ericcsurf> hi, is this an appropriate place to ask newbie questions?
12:03:06 <loz2> ericcsurf: yes
12:03:24 <hpc> you may ask anything here except if you are allowed to ask questions ;)
12:03:48 <ericcsurf> woops :-X
12:04:04 <hexagoxel> can i somehow define a local alias of a function without running into the monomorphism restriction?
12:04:20 <hexagoxel> (and without a type signature)
12:04:20 <corgifex> yes, disable the monomorphism restriction
12:04:22 <hexagoxel> :D
12:04:26 <corgifex> or add a dummy argument
12:04:26 <hpc> or eta-expand it
12:04:34 <hpc> instead of let foo = bar, let foo a = bar a
12:05:01 <yac> when I run hspec testsuite via cabal test it omits colors from the output
12:05:04 <yac> how can I fix that?
12:05:40 <pavonia> hpc: Is that a general solution to avoid it?
12:05:44 <eazar001> wow, snoyman has excellent documentation
12:06:11 <hpc> pavonia: yes, but only of the root of foo's type is (->)
12:06:15 <hpc> (ie, if it's a function)
12:06:31 <pavonia> Okay
12:06:36 <hpc> the monomorphism rule's heuristic is "does it look like a function"
12:10:46 <Peaker> haddock typically lists re-exports as URLs. If you want to search for a name, that's tedious/difficult.  What's a good way to work around that?
12:10:58 <Peaker> module re-exports, that is
12:13:14 <ericcsurf> I'm having a bit of confusion over the expression: group . sort $ [3,3,2,3,1].  Specifically, on interpreting the composition.  My understanding is that it's doing group(sort [...]), but I would think that would be written as group $ sort [...], which also works.  I guess I don't see how composition is happening in group . sort $ [...], or what that combination of composition and $ means.  Most examples I see have the $ before the func
12:14:15 <bjornars> $ is read as application
12:14:26 <bjornars> so apply [..] to 'group . sort'
12:14:34 <corgifex> no, apply group . sort to [...]
12:14:42 <kazagistar> :t group . sort
12:14:43 <lambdabot> Ord a => [a] -> [[a]]
12:14:50 <kazagistar> :t ($)
12:14:51 <lambdabot> (a -> b) -> a -> b
12:15:03 <kazagistar> :t (group . sort $)
12:15:04 <lambdabot> Ord a => [a] -> [[a]]
12:15:09 <bjornars> you can usually replace a $ with a '(' and a trailing ')'
12:15:51 <ericcsurf> hmm but if I do: let myfunc = group . sort, I can't seem to apply myfunc to [...]
12:16:08 <ion> ericcsurf: In ‚Äúgroup . sort $ xs‚Äù, ($) has the lowest precedence and f $ x = f x, therefore ‚Äú(group . sort) xs‚Äù. (f . g) x = f (g x), therefore ‚Äúgroup (sort xs)‚Äù. One is able to arbitrarily add $ to that expression as ‚Äúgroup $ sort xs‚Äù without changing the meaning.
12:16:16 <derekv> i've got
12:16:16 <derekv> import Data.Random.Source (RandomSource) and a type signature
12:16:18 <derekv> shuffleAndDraw :: RandomSource m DevRandom => Int -> [a] -> m [a]
12:16:32 <kazagistar> @let myfunc = group . sort
12:16:34 <lambdabot>  Defined.
12:16:43 <corgifex> > let myfunc = group . sort in myfunc "hello, world"
12:16:45 <lambdabot>  [" ",",","d","e","h","lll","oo","r","w"]
12:16:59 <Lutin`> benzrf: *facepalm*
12:17:00 <kazagistar> ...seems to work?
12:17:04 <derekv> but it is giving me a warning about RandomSource being a non type variable argument
12:17:04 <Lutin`> I had Vundle installed incorrectly
12:17:06 <Lutin`> go me!
12:18:02 <ericcsurf> ion: kazagistar lambdabot:  ah ok, I think that makes sense.   I guess I had some other syntactic issues when testing this.  thanks for your help
12:18:13 <derekv> basically why I want to turn off the type signature warning is that i've been sitting here half an hour trying to figure out the type signature on a function i'm sure i'll be throwing away
12:19:07 <lyxia> derekv: A class constraint can only contain type variables. DevRandom is not a type variable.
12:19:54 <lyxia> derekv: Try Monad m instead
12:20:31 <derekv> it hate's it
12:20:46 <derekv> @let shuffleAndDraw n deck = runRVar ((take n) <$>  shuffle deck) DevURandom
12:20:47 <lambdabot>  .L.hs:192:5: Not in scope: ‚ÄòrunRVar‚Äô
12:20:47 <lambdabot>  
12:20:47 <lambdabot>  .L.hs:192:27: Not in scope: ‚Äòshuffle‚Äô
12:20:47 <lambdabot>  
12:20:47 <lambdabot>  .L.hs:192:41: Not in scope: data constructor ‚ÄòDevURandom‚Äô
12:20:52 <derekv> =/
12:21:13 <corgifex> @undefine
12:21:13 <lambdabot> Undefined.
12:21:24 <derekv> shuffleAndDraw :: RandomSource m DevRandom => Int -> [a] -> m [a]
12:22:19 <lyxia> derekv: Monad m => Int -> [a] -> m [a]
12:22:30 <lyxia> uhhh
12:22:57 <derekv> Could not deduce (Data.Random.Internal.Source.RandomSource
12:22:57 <derekv>                         m DevRandom)
12:22:57 <derekv>       arising from a use of `runRVar'
12:23:00 <lyxia> I may be confused
12:23:04 <abstract-alf> > putStrLn $ unlines $ [a ++ " " ++ b | b <- ["hampster","parking ticket","cheeseburger"], a <- ["hairy","annoying","delicious"]]
12:23:06 <lambdabot>  <IO ()>
12:23:12 <abstract-alf> bummer
12:23:13 <lyxia> IO
12:24:08 <abstract-alf> > [a ++ " " ++ b | b <- ["hampster","parking ticket","cheeseburger"], a <- ["hairy","annoying","delicious"]]
12:24:10 <lambdabot>  ["hairy hampster","annoying hampster","delicious hampster","hairy parking ti...
12:24:13 <lyxia> derekv: Int -> [a] -> IO [a]?
12:24:32 <derekv> lyxia: magic!
12:24:34 <derekv> thanks
12:24:44 <corgifex> "hampster"?
12:24:54 <lyxia> derekv: There is only an instance for RandomSource IO DevRandom.
12:24:56 <dcoutts> yac: that's actually rather tricky, because it interferes with logging
12:25:13 <lyxia> derekv: It makes no sense to have a class RandomSource m DevRandom for any monad.
12:26:53 <Lutin`> omg
12:26:57 <Lutin`> this is amazing
12:27:03 <derekv> so if i want to let the user keep drawing cards and then updating a game state, i have a vague notion that I want to have a monad, (maybe a State or Reader monad?) that keeps the game state and the randomsource, with the loop of the program operating within that monad
12:27:06 <phil> Hi, I'm trying to start playing with Haskell and I'm off to a bad start. I've just installed the latest Haskell platform and tried to install haddock. I get the error "Unsupported GHC version". I've got version 7.6.3 of GHC and cabal info haddock claims that it requires GHC >= 7.4 and < 7.10. Any ideas what could have caused this?
12:27:17 <derekv> does that make sense?
12:27:35 <Lutin`> benzrf: I'm in love
12:27:40 <benzrf> Lutin`: what
12:27:42 <Lutin`> benzrf: autocomplete ALL THE THINGS
12:27:43 <abstract-alf> derekv: it does to me.  are you making solitaire?
12:28:04 <Lutin`> benzrf: https://github.com/eagletmt/neco-ghc
12:28:08 <derekv> lyxia: regarding that type signature, it isn't that it made sense to me, its that ghc  :t was suggesting that was the type
12:29:59 <derekv> abstract-alf: yes and no, I have an idea of an RPG system that will use a mechanic involving something that resembles a card deck mechanic for some things, so I thought I'd start with just some simplified, solitare version of it
12:30:10 <lyxia> derekv: Weird. Why DevRandom?
12:30:29 <marchelzo_> say I have an Applicative Functor f which is not an instance of the Eq typeclass, but the thing inside of it is an instance of Eq. How can I test equality two of those objects?
12:30:57 <corgifex> you can't
12:31:13 <marchelzo_> ok that's what I was afraid of
12:31:15 <marchelzo_> thanks
12:31:16 <Cale> marchelzo_: For example, how can you test equality of two IO actions?
12:31:18 <derekv> lyxia: I'm largely coding from examples without full understanding of everything.  http://hackage.haskell.org/package/random-fu-0.1.0.0/docs/Data-Random-RVar.html#t:RVar
12:31:33 <corgifex> marchelzo_: also, "inside of it" is not necessarily the right way to look at things
12:31:47 <corgifex> these are magic boxes
12:32:08 <kazagistar> inside out boxes
12:32:23 <Cale> marchelzo_: It's generally impossible to determine whether two programs do the same thing, so there's a reason there's no instance of Eq there.
12:33:08 <marchelzo_> http://lpaste.net/2723546991274491904 can someone give me a hint here?
12:33:15 <hexagoxel> hmm Debug.Hood.Observe.runO segmentation faults on -O0 and when there is no debugging output (?)
12:35:25 <corgifex> marchelzo_: what's that?
12:35:28 <abstract-alf> hmm, does this happen a lot? http://lpaste.net/106000
12:36:12 <marchelzo_> corgifex: It's asking me to implement that function with that type signature. And the stuff above are examples of how it should behave
12:36:16 <ajcoppa> marchelzo_: nice. glad you kept going with the course
12:36:20 <corgifex> marchelzo_: what's List?
12:36:34 <marchelzo_> A custom version of []
12:36:42 <ajcoppa> corgifex: it's from the NICTA course. it has you reimplement your own versions of built-ins
12:37:14 <corgifex> I don't understand the last example
12:37:16 <Cale> marchelzo_: Well, perhaps start by pattern matching on the list
12:38:25 <Cale> corgifex: Remember how the list monad/applicative instance works
12:38:46 <corgifex> oh, it's 2^3
12:38:55 <Cale> It would be a more interesting result if it were const $ True :. False :. Nil
12:39:07 <corgifex> yeah, subsets
12:39:28 <Cale> > filterM (const [True, False]) [1,2,3]
12:39:30 <lambdabot>  [[1,2,3],[1,2],[1,3],[1],[2,3],[2],[3],[]]
12:39:34 <Cale> > filterM (const [True, True]) [1,2,3]
12:39:35 <lambdabot>  [[1,2,3],[1,2,3],[1,2,3],[1,2,3],[1,2,3],[1,2,3],[1,2,3],[1,2,3]]
12:40:27 <Peaker> > filterM (\x -> if even x then [True] else [True,False]) [1,2,3]
12:40:29 <lambdabot>  [[1,2,3],[1,2],[2,3],[2]]
12:41:19 <marchelzo_> I don't know what to do. I have filtering _ = pure Nil, but filtering (x:.xs) I'm not sure about
12:41:55 <corgifex> now you need to do stuff with x and xs
12:42:14 <corgifex> also what happened to your first parameter
12:42:15 <Lutin`> marchelzo_: Are Empty and Full already defined?
12:42:29 <corgifex> data NotMaybe a = Empty | Full a
12:42:32 <marchelzo_> corgifex: It's there I just forgot to write it :)
12:42:40 <Lutin`> Ah okay
12:43:28 <ajcoppa> marchelzo_: note that x :: a and you have an a -> f Bool
12:43:32 <benzrf> corgifex: NotMaybe is isomorphic to Maybe
12:43:39 <corgifex> o rly
12:43:50 <ReinH> So are folks using Stackage? How do people feel about it?
12:44:00 <Cale> marchelzo_: Well, you presumably want to do something with the results of x and filtering p xs
12:44:17 <Cale> :t liftA2
12:44:17 <lambdabot> Applicative f => (a -> b -> c) -> f a -> f b -> f c
12:44:22 <Lutin`> corgifex: Empty = Nothing, Full a = Just a
12:44:23 <Cale> ^^ this will be handy
12:44:31 <ReinH> Cale: oh hai
12:44:38 <Cale> ReinH: hello
12:44:40 <ajcoppa> note: you can't literally use liftA2 as the course has you implement your own version
12:44:46 <ajcoppa> but there is an equivalent that you have already implemented
12:44:56 <marchelzo_> its just lift 2 right?
12:44:58 <Lutin`> I should do this course now that I have my vim setup
12:44:59 <marchelzo_> lift2*
12:44:59 <ajcoppa> yep
12:45:21 <Lutin`> Does anyone here use haskellmode-vim and neco-ghc with neocomplcache?
12:45:34 <Lutin`> haskellmode-vim keeps disabling neocomplcache for me
12:46:05 <Lutin`> and 'filetype indent' doesn't seem to be working properly
12:46:22 <benzrf> Lutin`: i use a plugin that adds a command for getting the type of an expr
12:46:29 <benzrf> also syntasic
12:46:32 <benzrf> *syntastic
12:46:34 <benzrf> thats about it
12:46:35 <Lutin`> haskellmode-vim has _t
12:47:00 <Lutin`> but ghcmod-vim has a way too
12:47:19 <benzrf> yes ghcmod-vim i think thats what i have
12:47:46 <Lutin`> I've just noticed neco-ghc doesn't seem to be completing functions of things I import, but haskellmode-vim seems to do that
12:51:25 <exoarn> Hey I am learning haskell and I have a quick question: when I define a function like this "idx :: [a] -> Int -> a" it compiles but when i try to make it an infix function like "(idx) :: [a] -> Int -> a" ghci gives an error. short example and error message here: http://lpaste.net/106001
12:51:46 <exoarn> what am I doing wrong?
12:52:19 <EvilMachine> Is there a way to describe Arrows in terms of other type classes? Like you can say Alternative = Applicative + Monoid. Or maybe like ‚ÄúMonad = Monoid in the category of endofunctors‚Äù‚Ä¶
12:53:02 <Peaker> exoarn: to make a name infix, you *use* it with backticks. Wrapping with parens is what you do to operators to use them as *prefix*
12:53:32 <Peaker> exoarn: rather:  names are prefix/infix based solely upon whether they are named alphabetically or with operators. Then you can reverse the automatic choice via backticks for names and parens for operators
12:54:24 <abstract-alf> (x:xs) `idx` 0 = x
12:54:36 <abstract-alf> idx :: [a] -> Int -> a
12:54:45 <EvilMachine> > idx ::  [a] -> Int -> a
12:54:46 <lambdabot>  Not in scope: ‚Äòidx‚Äô
12:54:46 <lambdabot>  Perhaps you meant one of these:
12:54:46 <lambdabot>    ‚Äòid‚Äô (imported from Data.Function),
12:54:46 <lambdabot>    ‚ÄòC.id‚Äô (imported from Control.Category),
12:54:46 <lambdabot>    ‚Äòix‚Äô (imported from Control.Lens)
12:54:54 <EvilMachine> > (x:xs) `idx` 0 = x
12:54:56 <lambdabot>  <hint>:1:16: parse error on input ‚Äò=‚Äô
12:55:20 <abstract-alf> it works when you run it from a file
12:55:21 <EvilMachine> > let { idx :: [a] -> Int -> a; (x:xs) `idx` 0 = x }
12:55:22 <lambdabot>  not an expression: ‚Äòlet { idx :: [a] -> Int -> a; (x:xs) `idx` 0 = x }‚Äô
12:55:29 <EvilMachine> hmm, no idea how lambdabot does types‚Ä¶
12:55:44 <corgifex> it uses Haskell
12:55:51 <Para_> question:
12:55:57 <EvilMachine> corgifex: Yeah, no sh*t? XD
12:56:10 <exoarn> ok so the only way to make a function behave like an operator is with ` ?
12:56:20 <Para_> if I have a function with type signature Ord a => [a] -> [a], can I pass it something like [(3,3)]
12:56:24 <Para_> because the tuples are orderable, right?
12:56:25 <abstract-alf> unless the function name is all symbols, I think
12:56:30 <bennofs> EvilMachine: Profunctor, Category and Strong give you some of Arrow's interface, but not all of Arrow
12:57:05 <abstract-alf> (~~~) :: Int -> Int -> Int
12:57:06 <abstract-alf> a ~~~ b = a + b
12:57:28 <EvilMachine> exoarn: The difference is that Haskell assumes everything with only non-alphanumeric chars to be an (infix) operator, and everything with only alphanumeric chars to be a function, and to reverse it, there‚Äôs (operator) and `function`.
12:58:03 <EvilMachine> bennofs: Yes, Category‚Ä¶ Never heard of Profunctor and Strong though. I‚Äôll hoogle it.
12:58:43 <EvilMachine> bennofs: Is ‚ÄúMonad = Applicative + Bind‚Äù anywhere close to correct?
12:59:37 <exoarn> Ok, thanks a lot!
12:59:46 <bennofs> EvilMachine: yeah, but Applicative is more than you need. class Pointed f where point :: a -> f a;    Monad = Pointed + Bind
13:00:23 <bennofs> EvilMachine: but pointed is disputed nowadays, because it has no real associated laws
13:00:45 <marchelzo_> I still can't figure out the filtering function. Can someone just tell me how to do it, or at least give me a hint that makes it extremely obvious
13:00:49 <EvilMachine> yes, true. Applicative is one step towards MonadPlus.
13:01:14 <EvilMachine> bennofs: I just  read about Pointed. I wondered what it meant.
13:02:29 <ajcoppa> marchelzo_: what should happen when the bool from your predicate method (a -> f Bool) is true?
13:03:00 <marchelzo_> The a should be in the list
13:03:18 <marchelzo_> But how can I test if it's true?
13:03:18 <benzrf> :k Pointed
13:03:19 <lambdabot>     Not in scope: type constructor or class ‚ÄòPointed‚Äô
13:03:23 <benzrf> tsk
13:03:39 <ajcoppa> marchelzo_: well, you've got the Bool wrapped inside your applicative f
13:03:45 <EvilMachine> benzrf: http://hackage.haskell.org/package/pointed-4.1/docs/Data-Pointed.html
13:04:03 <marchelzo_> ajcoppa: Yeah that's the problem
13:04:10 * EvilMachine finds it funny that Pointed has no point.  ;)
13:04:46 <EvilMachine> benzrf: All I can see, is that pointed is essentially just wrapping something up in something else‚Ä¶
13:05:25 <ajcoppa> lift2 will help here. do you have a good intuition for what lift2 does?
13:05:36 <bennofs> :t lift2
13:05:37 <lambdabot>     Not in scope: ‚Äòlift2‚Äô
13:05:37 <lambdabot>     Perhaps you meant one of these:
13:05:37 <lambdabot>       ‚ÄòliftM‚Äô (imported from Control.Monad.Writer),
13:05:38 <marchelzo_> yeah, at least I thought I did
13:05:38 <EvilMachine> me?
13:05:50 <ajcoppa> :t liftA2
13:05:51 <lambdabot> Applicative f => (a -> b -> c) -> f a -> f b -> f c
13:05:58 <jle`> i have read something somewhere that instead of Pointed, one might be able to llook at Unit
13:05:58 <EvilMachine> Ah, yes, of course.
13:06:01 <ajcoppa> (lift2 is a custom version of liftA2 we implemented earlier in the course)
13:06:05 <jle`> which has some better assicaed laws I think
13:06:28 <jle`> unit :: Applicative f => f ()
13:06:28 <ReinH> bennofs: I saw a nice argument made for replacing Pointed with a "Cofoldable", a.k.a. Buildable, which does have some laws
13:06:44 <benzrf> :t lift2
13:06:45 <lambdabot>     Not in scope: ‚Äòlift2‚Äô
13:06:45 <lambdabot>     Perhaps you meant one of these:
13:06:45 <lambdabot>       ‚ÄòliftM‚Äô (imported from Control.Monad.Writer),
13:06:48 <benzrf> mm
13:07:11 <bennofs> ReinH: right, there was a FP Complete article, "Building up to a point via Adjunctions"
13:07:20 <ReinH> benzrf: they are nicely dual: ana and data, initial and terminal, etc
13:07:24 <ReinH> bennofs: I think that's it
13:07:31 <ReinH> s/data/cata
13:07:32 <bennofs> https://www.fpcomplete.com/user/gbaz/building-up-to-a-point-via-adjunctions
13:07:41 <ReinH> I thought I disabled autocorrect :(
13:07:58 <ReinH> time to switch to emacs for irc, I guess
13:07:59 <EvilMachine> I see that pointed is just the pure, return, etc, part of e.g. Applicative, Monad, etc.
13:08:28 <ReinH> er, also s/benzrf/bennofs
13:08:54 <ReinH> EvilMachine: You can also tease bifunctors out of applicative
13:08:55 <ReinH> er
13:08:57 <ReinH> out of arrow
13:09:14 <ReinH> and they seem to be what people often want when they use applicative combinators
13:09:18 <ReinH> like &&&, ***
13:09:28 <EvilMachine> and copoint seems to be the ‚Äúrun‚Ä¶‚Äù of the monad world‚Ä¶
13:10:09 <ReinH> EvilMachine: copoint is comonadic extract
13:10:40 <EvilMachine> ReinH: I have yet to find a simple one-liner that describes comonads.
13:10:44 <marchelzo_> ajcoppa: Is the (a -> b -> c) in lift2 going to be something that already exists?
13:10:50 <ReinH> Perhaps because one does not exist.
13:11:08 <EvilMachine> ReinH: I also forgot what bifunctors were.
13:11:16 <ajcoppa> nope, but it lets you write a "normal" function and lift2 will do the work of lifting it into the applicative
13:11:26 <ReinH> @hackage bifunctors
13:11:26 <lambdabot> http://hackage.haskell.org/package/bifunctors
13:11:49 <marchelzo_> I know what it does I just don't know how to use it to accomplish this
13:12:32 <ajcoppa> your "normal" function can perform the logic you went through for what happens if the bool is true/false
13:12:50 <EvilMachine> ReinH: Yes, it does. (Because statements like ‚ÄûMonads are just monoids in the category of endofunctors.‚Äú are acceptable. :)
13:13:52 * hackagebot snaplet-fay 0.3.3.7 - Fay integration for Snap with request- and pre-compilation.  http://hackage.haskell.org/package/snaplet-fay-0.3.3.7 (AdamBergmark)
13:14:05 <ajcoppa> marchelzo_: sorry if i'm not explaining this effectively. first time trying to explain this
13:14:42 <ReinH> EvilMachine: Ok, a comonad on a category C is just a monad on its dual category C^op
13:14:52 <marchelzo_> ajcoppa: It's ok. I know you don't want to just give me the answer
13:14:58 <marchelzo_> I appreciate it a lot
13:15:04 <bennofs> EvilMachine: Comonads are just comonoids in the category of endofunctors (I hope I got that right)
13:15:09 <EvilMachine> ReinH: actually, that made sense to me.
13:15:25 <EvilMachine> ReinH: So a comonad is a monad in reverse. :)
13:15:37 <ReinH> Yes, that's generally what duality means in category theory :)
13:15:42 <ReinH> you literally reverse the arrows
13:15:53 <EvilMachine> Yep. But we gotta use the pretentious words, do we? XD
13:16:02 <ReinH> Well, we have to use *precise* words.
13:16:11 <ReinH> YMMV on "pretentious"
13:17:00 <EvilMachine> ReinH: Oh you! :)
13:17:07 <ReinH> :)
13:18:52 <EvilMachine> ReinH: Can you define the property that makes something not just reversed, but dual?
13:19:35 <EvilMachine> Or could you say ‚ÄúDual is just one kind of reversing. There are others.‚Äù?
13:19:45 <ReinH> Formally? For arrows f and g in C, replace dom(f) with codom(f) and likewise with g, and replace f . g with g . f, and you get C^op
13:20:01 <ReinH> (also replace codom(f) with dom(f))
13:20:39 <ReinH> That might be formal enough to get along with :)
13:22:16 <ReinH> EvilMachine: http://en.wikipedia.org/wiki/Dual_(category_theory)
13:22:24 <marchelzo_> ajcoppa: I have no idea what to do with lift2. The only thing I have that's in a functor is (p x).
13:22:54 <corgifex> marchelzo_: you also need to do something with xs
13:22:56 <ajcoppa> marchelzo_: okay, that's a good start. what's our final result going to be?
13:23:07 <marchelzo_> f (List a)
13:23:35 <ajcoppa> let's say we're halfway through processing the input list. what's our intermediate result going to be?
13:24:17 <marchelzo_> won't that depend on the way we implement the function?
13:25:13 <ajcoppa> it will, but what type do you think it ought to have?
13:26:45 <EvilMachine> ReinH: Precise definition understood.
13:26:48 <ajcoppa> if i process one item from the list, and the predicate gives me back True wrapped inside an applicative, what should the intermediate result be?
13:26:54 <ajcoppa> let me know if these questions aren't making sense
13:27:06 <ReinH> EvilMachine: :)
13:27:58 <marchelzo_> um
13:28:32 <EvilMachine> ReinH: So to test myself: If the IO monad had a comonad implementation, you could reverse time? :D
13:28:56 <corgifex> ajcoppa: I know how to solve it but I don't understand where you're going with this either
13:28:59 <marchelzo_> I don't know what you mean by intermediate result. If it's defined recursively then there is no concept of intermediate result that
13:28:59 <ajcoppa> ok
13:29:27 <corgifex> marchelzo_: have you written a "normal" filter yet?
13:29:37 <corgifex> (a -> Bool) -> List a -> List a
13:29:39 <ajcoppa> marchelzo_: if we want to get to an f (List a) at the end, we probably want our intermediate results to also be of type f (List a), just with a smaller list inside the applicative
13:29:42 <marchelzo_> corgifex: yea
13:29:45 <edwardk> EvilMachine: you can reverse time already. just build IO with the backwards state monad instead.
13:30:07 <corgifex> marchelzo_: I'd modify that and see where the types don't match up
13:30:33 <EvilMachine> edwardk: I‚Äôd like to see what that would do to a fully fledged application, like a text editor. :)
13:30:39 <marchelzo_> corgifex: how though? If I take the x to a (f Bool) I have no way of telling what the value of the Bool is
13:30:53 <marchelzo_> ajcoppa: Ok that makes sense, sure
13:31:02 <ReinH> EvilMachine: what arrows are you reversing?
13:31:05 <ajcoppa> the reason i was saying that is to get you a second applicative to use with lift2 :)
13:31:07 <corgifex> marchelzo_: ok, that's one type mismatch. any others?
13:31:08 <edwardk> EvilMachine: Alas, the ministry of magic made me remove my time turner library from github and restricted me to private use 6 hours a day, only for studying.
13:31:28 <marchelzo_> ajcoppa: ah
13:32:03 <marchelzo_> corgifex: well I want the end result to be in the functor, but that one is fairly easy to deal with
13:32:16 <dwcook> http://hackage.haskell.org/package/tardis-0.3.0.0
13:32:31 <EvilMachine> edwardk: Well, in the IO monad, according to the formal definition, f >> g would become g >> f, and the final state and the initial state would be exchanged.
13:32:39 <EvilMachine> ReinH: ‚Üë
13:32:47 <corgifex> marchelzo_: the recursive call will also have a different result type
13:33:11 <ajcoppa> so if you have an f Bool that represents the result of your predicate on your current item, and an f (List a) that represents the rest of the filtering that you haven't done yet
13:33:22 <old_beginner> hello all !
13:33:24 <ajcoppa> you can write a function that operates on normal bools and lists and lift it into your applicative
13:33:45 <EvilMachine> dwcook: LOL!
13:33:49 <dwcook> EvilMachine: It's already possible to use flip (>>). The co- part isn't referring to the (>>) operation anyway.
13:33:50 <ajcoppa> and make that function have the behavior you want (if bool true, append to list, otherwise ignore)
13:34:27 <marchelzo_> ajcoppa: I the only problem is that I don't want to append the Bool to the list, I want to append the original x
13:34:39 <dwcook> return :: (Monad m) => a -> m a becomes coreturn :: (Comonad w) => w a -> a and join :: (Monad m) => m (m a) -> m a becomes cojoin :: (Comonad w) => w a -> w (w a)
13:35:10 <old_beginner> I am following the NICTA course ( https://github.com/NICTA/course ) and I am stuck, maybe someone can help me ?
13:35:15 <edwardk> dwcook: note: "co-IO" or OI doesn't hold together as a viable comonad
13:35:19 <marchelzo_> old_beginner: welcome to the club
13:35:22 <EvilMachine> dwcook: so it‚Äôs a dual in the sense of wrapping/unwrapping, not in the sense of sequencing‚Ä¶ correct?
13:35:26 <dwcook> edwardk: Yeah, I didn't mention about IO yet
13:35:30 <edwardk> its done in by the strength of every functor in a haskell-like language
13:35:46 <dwcook> EvilMachine: I don't know what question you're asking.
13:35:48 <ajcoppa> marchelzo_: that's okay -- you still have your x from the pattern match, right?
13:35:56 <corgifex> marchelzo_: prependIf :: Bool -> a -> List a -> List a -- can you write this function?
13:36:05 <EvilMachine> dwcook: The one I wrote. :))
13:36:10 <old_beginner> @marchelzo_ ah, good to be among peers :)
13:36:10 <lambdabot> Unknown command, try @list
13:36:23 <edwardk> EvilMachine: tardis is a combination of backwards-state and forwards-state
13:36:36 <dwcook> EvilMachine: I didn't understand your question.
13:36:36 <corgifex> prependIf True 42 (1 :. Nil) ==> (42 :. 1 :. Nil)
13:36:40 <EvilMachine> edwardk: I just read the documentation.
13:36:52 <marchelzo_> prependIf True x xs = x:xs
13:37:04 <EvilMachine> dwcook: And I don‚Äôt understand what‚Äôs not to understand about it. Sorry.
13:37:06 <marchelzo_> prependIf False _ xs = xs
13:37:29 <marchelzo_> ajcoppa: Yes. I think I see what you're getting at.
13:37:34 <old_beginner> marchelzo_ ah, good to be among peers :)
13:37:53 <marchelzo_> old_beginner: which one are you on?
13:37:53 <corgifex> marchelzo_: ok, now let's move the parameters around: prependIf' :: a -> Bool -> List a -> List a
13:38:08 <old_beginner> the one puzzling me is "Witness that all things with (=<<) and (<$>) also have (<*>)."
13:38:12 <ReinH> EvilMachine: (>>) isn't the arrow we're talking about here.
13:38:22 <EvilMachine> ReinH: I know that now.
13:38:29 <corgifex> old_beginner: that sounds like "define (<*>) in terms of (=<<) and (<$>)"
13:38:41 <ajcoppa> old_beginner: yep, what corgifex said
13:38:42 <EvilMachine> ReinH: As dwcook stated: return :: (Monad m) => a -> m a becomes coreturn :: (Comonad w) => w a -> a
13:38:50 <marchelzo_> corgifex: prependIf' x True xs = x:xs;   prependIf' _ False xs = xs
13:38:52 <old_beginner> yep, and I cant' wrap my head around that.
13:39:04 <EvilMachine> ReinH: Which suggests while the monad‚Äôs return wraps, the comonad‚Äôs unwraps.
13:39:14 <EvilMachine> ReinH: The other functions have the same pattern.
13:39:20 <ajcoppa> old_beginner: it might help to write out the types of =<< and <$>
13:39:39 <corgifex> marchelzo_: what's the type of \x -> lift2 (prependIf' x) ?
13:39:53 <phil> Yet another cabal issue. Hopefully someone can help. I'm trying to get started with Haskell. I've installed diagrams 1.2 and I'm trying to install charts-diagram. cabal install charts-diagram fails with Preprocessing library diagrams-postscript-1.1...  src\Graphics\Rendering\Postscript.hs:76:8:     Could not find module `Diagrams.TwoD.Attributes'     It is a member of the hidden package `diagrams-lib-1.2.0.1'.
13:40:01 <EvilMachine> ReinH: Join wraps in comonad, where it unwraps in monad.
13:40:08 <phil> Maybe I'm doing something stupid
13:40:19 <phil> But it seems that cabal install nearly always fails
13:40:29 <ReinH> EvilMachine: join does not unwrap.
13:40:32 <dwcook> EvilMachine:  One of the problems here is "wraps" isn't very precise.
13:40:33 <old_beginner> (<$>) :: Applicative f => (a -> b) -> f a -> f b and (=<<) :: (a -> f b) -> f a -> f b are quite clear
13:40:33 <ReinH> it joins
13:40:36 <phil> And I'm not sure what to do with the resulting errors
13:40:44 <EvilMachine> ReinH: Yes it does: join :: (Monad m) => m (m a) -> m a
13:40:49 <ReinH> No. It does not.
13:41:02 <ReinH> No unwrapping is implied by that type.
13:41:05 <EvilMachine> ReinH: You need to elaborate, my friend.
13:41:47 <marchelzo_> corgifex (a -> f Bool -> f [a] -> f [a])
13:41:51 <EvilMachine> ReinH: m (m a) ‚Ä¶ a a inside a m inside a m.
13:42:00 <ajcoppa> old_beginner: okay, and since you're implementing <*>, what are the types of the arguments?
13:42:01 <ReinH> Join is the monodical product referred to in "a monad is a monad in the category of endofunctors"
13:42:08 <ReinH> *a monad is a monoid
13:42:08 <corgifex> marchelzo_: do you have a value of type a around?
13:42:17 <marchelzo_> yes
13:42:19 <EvilMachine> Rein, ok, that was confusing. I hope you understood how I meant it.
13:42:23 <marchelzo_> It just so happens that I do
13:42:27 <corgifex> marchelzo_: how about f Bool?
13:42:35 <EvilMachine> ReinH: I know.
13:42:35 <marchelzo_> Yeah I've got one of those too!
13:42:37 <EvilMachine> :)
13:42:43 <ajcoppa> marchelzo_: :)
13:42:46 <corgifex> marchelzo_: and f [a]?
13:42:49 <dwcook> If by "join unwraps" you mean that join has the signature join has, then you're correct by tautology. Otherwise you'll need to explain what meaning of "unwraps" you're using.
13:42:51 <ReinH> EvilMachine: I have a particular aversion to using the terms "wrapping" and "unwrapping" to describe algebraic things like monads because of how frequently they lead to wrong understandings.
13:43:08 <marchelzo_> so the f[a] is the recursive call to filtering?
13:43:13 <corgifex> yes
13:43:17 <marchelzo_> wow
13:43:17 <ajcoppa> sounds right to me
13:43:32 <old_beginner> ajcoppa : f (a -> b) a function within a context and (f a) a value within the kind of context.
13:43:51 <EvilMachine> ReinH: And you‚Äôre right in having that aversion. Don‚Äôt worry. I know it‚Äôs not that simple.
13:43:56 <ReinH> (m . m) a -> m a isn't really wrapping, and m a -> (m . m) a isn't really unwrapping. They're the product and co-product of a monoid and comonoid.
13:43:58 <old_beginner> ajcoppa : (within the same kind of context)
13:44:02 <marchelzo_> That was treacherous
13:44:06 <dwcook> EvilMachine: It's fine to start out with fuzzy intuitions for things, but when actually learning the concept we need to talk with a certain amount of precision.
13:44:21 <dwcook> And when applying it, even.
13:44:25 <ajcoppa> marchelzo_: now write it with a fold instead of explicit recursion :)
13:44:43 <EvilMachine> ReinH: It‚Äôs more like ‚Äúthere‚Äôs something inherent to a monad‚Äù. But still, of course the Maybe monad already shows that there might just be Nothing. :)
13:44:45 <corgifex> marchelzo_: normal filter is basically just prependIf (p x) x (filter p xs). the Applicative version only needs a bit of lifting
13:45:02 <ajcoppa> thanks for helping corgifex
13:45:04 <ReinH> EvilMachine: what's "inherent" is the monoidal "behavior" that underlies its construction ;)
13:45:30 <corgifex> of course, the trick here is recognizing that filter has this structure
13:45:49 <EvilMachine> dwcook: But that‚Äôs not how a human brain works. A mathematician‚Äôs brain attempts it, but at best deludes itself into thinking it‚Äôs precise like that. :)
13:46:01 <ReinH> EvilMachine: and yet we must try
13:46:04 <marchelzo_> corgifex: Yeah that wasn't immediately obvious to me
13:46:05 <EvilMachine> dwcook: It‚Äôs more like a MIP map, if you know what I mean.
13:47:04 <EvilMachine> dwcook: You have a set of more and more lossy analogies, but are always aware that there‚Äôs more to it. You can dig up the original precise definition, but in practice, because of how neural nets work, the more vague versions are very useful to get the pattern matching going.
13:47:05 <ajcoppa> old_beginner: okay, so you've got these 4 things with different types, and you have to figure out how to mix them together to get what you want
13:47:10 <marchelzo_> ajcoppa: My brain is too melted to try doing this with a fold right now
13:47:12 <dwcook> EvilMachine: There is no delusion. We actually can think at the required level of precision. It might require training, and we might sometimes make mistakes, but we do it.
13:47:13 <EvilMachine> dwcook: Like a series of diffs.
13:47:22 <ajcoppa> i may need a few mins to build an intuition to help explain my answer
13:47:37 <ajcoppa> marchelzo_: no worries. it's not too much different from what you already have actually
13:47:47 <EvilMachine> ReinH: We must nothing. Except die. :)
13:47:50 <corgifex> I bet the trick is to start with normal filter again
13:47:54 <ReinH> EvilMachine: and taxes.
13:48:09 <corgifex> then insert a tactical lift somewhere
13:49:10 <EvilMachine> dwcook: Sorry, I actually know enough about brains and neural nets, to tell you you can‚Äôt. Not without losing detail in other things in your life. It‚Äôs a simple thing of the count of neurons in your brain.
13:49:24 <old_beginner> ajcoppa : yep but <$> apply the function from outside, there is no bridging part like (a -> f b)
13:49:28 <dwcook> EvilMachine: What's the "Not without‚Ä¶" bit then?
13:49:46 <EvilMachine> dwcook: Did the sentence get cut off?
13:50:01 <corgifex> EvilMachine: contradiction detected
13:50:08 <EvilMachine> dwcook: It said: ‚Ä¶ Not without losing detail in other things in your life.
13:50:11 <dwcook> EvilMachine: No, I was pointing out you were making an exception that made it so you weren't contradicting what I said.
13:50:17 <EvilMachine> dwcook:  and then: ‚Ä¶ It‚Äôs a simple thing of the count of neurons in your brain.
13:50:23 <corgifex> "not without X" => "possible with X"
13:50:25 <EvilMachine> corgifex: Interesting. Where?
13:50:46 <corgifex> contradicting "you can't"
13:50:52 <ajcoppa> old_beginner: true, we don't have any naturally-occurring (a -> f b)s to use as the first argument to bind
13:51:28 <ajcoppa> but, we know we need to find some way to run the (a -> b) we have inside an f, over the f a we also have
13:51:33 <dwcook> EvilMachine: In short I was making a "there exists" statement, and you were making a "there does not exist except possibly‚Ä¶" statement.
13:51:53 <EvilMachine> dwcook: Sorry, this might be a bit confusing for people who don‚Äôt know how neural nets work. See, your brain can only store so much detail for x neurons, unless the overlays of things become too vague to store.
13:52:02 <EvilMachine> dwcook: So if you want to be more precise, you need more neurons.
13:52:10 <ajcoppa> if we were able to get inside the f, to get access to the (a -> b) inside, what would we do with it and an f a to get an f b?
13:52:15 <EvilMachine> dwcook: Which means other things get less neurons to work with.
13:52:48 <EvilMachine> dwcook: So e.g. you can not remember every single Al Bundy quote anymore. Simply because of priorization.
13:52:49 <dwcook> EvilMachine: I get that. You're misunderstanding what I'm getting at. I would clarify if I didn't think we were already getting too far afield. :)
13:52:57 <EvilMachine> dwcook: Of course there‚Äôs nothing wrong with that.
13:53:19 <corgifex> but what if I have pornographic memory?
13:53:21 <old_beginner> something like f ( f a) -> (f a) would solve the problem but I am not sure we have that at this place in the course
13:53:35 <EvilMachine> dwcook: Maybe this discussion is a bit stuck then. Shall we put it down? :)
13:53:46 <corgifex> old_beginner: you can define that, actually
13:53:48 <ajcoppa> nope, we don't have join quite yet. we shouldn't need it either
13:53:49 <EvilMachine> corgifex: Soft or hard core? :D
13:54:04 <corgifex> not sure it'll help you, though
13:54:04 <Tjr> corgifex: in the practise of things, people with photographic memory have trouble because too many irrelevant search hits flood their mind
13:54:08 <dwcook> EvilMachine: I would be down with that.
13:54:24 <EvilMachine> dwcook: Alright. :)
13:54:49 <Tjr> corgifex: which is why those people generally don't excel as greatly at their domain of expertise as many laypeople imagine
13:54:51 <EvilMachine> Tjr: You misread that. Read corgifex‚Äôs line again. :)
13:54:52 <old_beginner> corgifex: yes but defining it is another exercice a bit further in the course, so I think there is another solution
13:55:18 <dwcook> EvilMachine: Though I will admit the possibiltiy that at least one of the statements I made was too strong.
13:55:43 <Tjr> Are you guys/gals using haskell to write neuronal networks?
13:56:36 <dwcook> Tjr: We got onto this subdiscussion in response to my comment that we need to speak with a certain degree of precision regarding concepts in Haskell.
13:57:38 <EvilMachine> dwcook: ditto. It‚Äôs late here.
13:57:39 * Tjr tunes out of the subdiscussion about human limiations
13:57:47 <drdo> What exactly is photographic memory?
13:58:06 <Tjr> drdo: you can't forget anything.
13:58:13 <EvilMachine> We‚Äôre getting pretty off-topic now. Let‚Äôs do that in #haskell-blah.
13:58:18 <Tjr> drdo: google for "eidetic memory"
13:58:24 * EvilMachine is sorry for any OT he caused himself.
13:58:38 <drdo> Tjr: go blash
13:58:40 <drdo> *blah
13:58:52 <dwcook> EvilMachine: Was there something else you needed clarified about Monad or Comonad?
13:59:48 <drdo> Tjr: "Eidetic memory is the ability to recall images in great detail for several minutes.", Wikipedia says that
14:00:04 <ajcoppa> old_beginner: see what i said above about getting inside the f, giving us access to the (a -> b) inside?
14:00:14 <EvilMachine> dwcook: Oops, hexchat exits when minimized. Sorry
14:00:35 <dwcook> That sounds like a bug.
14:00:47 <EvilMachine> dwcook: I don‚Äôt fully understand anymore, what it means in practice. I thought I did.
14:00:58 <EvilMachine> dwcook: It‚Äôs a KDE application. Of course it is. :)
14:01:11 <dwcook> EvilMachine: It's just as I stated before: The operations we're flipping the direction of the arrows on are return and join.
14:01:31 <dwcook> Copied from earlier: return :: (Monad m) => a -> m a becomes coreturn :: (Comonad w) => w a -> a and join :: (Monad m) => m (m a) -> m a becomes cojoin :: (Comonad w) => w a -> w (w a)
14:01:49 <EvilMachine> dwcook: Yes, but for a concrete piece of code‚Ä¶
14:02:08 <EvilMachine> dwcook: Like, let‚Äôs say i use a state comonad. What would that do?
14:02:15 <klaff> Im a bit unsure about the english (haskell webapp world cup): "What is the fastest time a player has been sent off? " is that corect english?
14:02:21 <benbangert> anyone thats used the STM a lot around for a question regarding a design pattern?
14:02:38 <dwcook> EvilMachine: You mean costate comonad, also known as Store. I've never used it, but I bet there are searchable examples.
14:02:39 <corgifex> klaff: doesn't look right to me
14:03:25 <EvilMachine> dwcook: http://stackoverflow.com/questions/8766246/what-is-the-store-comonad
14:03:48 <corgifex> klaff: for two reasons. 1) "fastest time" looks like it ought to be "shortest time" or something. 2) how does the time connect to the send-off bit?
14:04:16 <klaff> What is the shortest time after matchstart that a player has been sent off?
14:04:28 <klaff> better?
14:04:39 <EvilMachine> dwcook: I think my head is done for today.
14:04:40 <dwcook> EvilMachine: Do you have a specific question? I'm having trouble determining what information you're looking for.
14:04:45 <dwcook> Okay.
14:05:16 <EvilMachine> dwcook: It‚Äôs OK. Thanks anyway. :)
14:05:43 <dwcook> No problem.
14:06:17 <EvilMachine> dwcook: I originally came here to make a super all-encompassing version of the Typeclassopedia. Well, one day just isn‚Äôt enough for a newbie like me. :)
14:06:46 <old_beginner> ajcoppa :  if we can get inside the f,  to get access to the (a -> b), something like (a -> b) <$> f a is enough.
14:07:01 <ajcoppa> yep, sweet
14:07:03 <dwcook> EvilMachine: You can get there with practice. :)
14:07:57 <corgifex> old_beginner: isn't that what =<< does?
14:08:00 <ajcoppa> how do we get inside an f to play with the value inside?
14:08:04 <corgifex> ooops
14:08:06 <old_beginner> but you can't....wait...
14:08:07 <ajcoppa> :P
14:08:43 <EvilMachine> dwcook: I really wish the Typeclassopedia would be more complete. (Like mention and show all typeclasses that the most complex ones are build out of.)
14:08:50 <tacit7> Hello everyone
14:08:52 <tacit7> Im taking the first part of the algorithms course offered in coursera
14:08:52 <tacit7> Its the first week and I wanted to implement some algorithms in haskell. I finished UnionFind "data structure" with a Quick Find algorithm implementation.
14:08:52 <tacit7> Would any one be willing to give some critique?
14:09:26 <loz2> just paste it)
14:10:33 <EvilMachine> dwcook: If it had one line for every typeclass ‚Äútypeclass T is just the features of typeclasses U, V and W, plus this new thing ‚Ñµ‚Äù
14:11:31 <dwcook> EvilMachine: I haven't really read the Typeclassopedia in any depth, but along those lines a compendium of class methods and laws would be handy.
14:11:42 <EvilMachine> tacit7: lpaste.net
14:12:32 <EvilMachine> dwcook: yes. The nice thing about the Typeclassopedia is the graph image at the top, showing the relationships between the classes
14:12:35 <br1> Can I mark an expression as record field as 'weak', so that the gc can collect the object if only weak references remain and the value is recomputed if needed again?
14:12:47 <ajcoppa> old_beginner: doing okay? :)
14:12:49 <EvilMachine> dwcook: This one: http://www.haskell.org/wikiupload/d/df/Typeclassopedia-diagram.png
14:12:56 <tacit7> http://lpaste.net/106003
14:13:29 <old_beginner> ajcoppa :   thinking hard...
14:13:59 <EvilMachine> dwcook: I wish it contained Bind, Pointed, Coeverything, MonadOr, and all that missing stuff.
14:14:02 <tacit7> I based it on the course's code for quick find
14:14:03 <xeno_> so, given that I'm a total haskell n00b - can someone tell me how I really should do the parse function in https://github.com/jankroken/scl/blob/master/haskell/parser.hs ?
14:14:23 <dwcook> EvilMachine: I don't think Bind or Pointed are in common use, and I've never even heard of MonadOr.
14:14:31 <tacit7> http://algs4.cs.princeton.edu/code/javadoc/QuickFindUF.html
14:14:40 <tacit7> http://algs4.cs.princeton.edu/15uf/QuickFindUF.java.html
14:14:53 <ajcoppa> old_beginner: if you check out the typesig of (=<<), it may help build the following intuition
14:14:56 <dwcook> EvilMachine: I think this came up in the discussion earlier, but it seems like Pointed is too weak to be useful, lacking laws relating its method with anything else.
14:15:10 <ajcoppa> give it an f a, and inside the (a -> f b), you get to treat it like it doesn't have any f wrapping it
14:15:27 <Peaker> br1: you can try to make a general value wrapper that does weak-memoization, regardless of records/fields, with some unsafePerformIO
14:18:06 <EvilMachine> dwcook: MonadOr is part of the suggested typeclasses of the monad redesign.
14:18:14 <Marqin> #haskell-pl
14:18:53 <EvilMachine> dwcook: MonadPlus would be split into MonadPlus and MonadOr.
14:18:56 <br1> Peaker: Thanks, I will think about it
14:19:31 <old_beginner> ajcoppa : I think something like   \fa -> ((a -> b) <$> fa ) =<< f( a -> b ) would work....maybe...
14:19:52 <corgifex> old_beginner: that looks like several syntax errors
14:20:03 <ajcoppa> old_beginner: you're very close, but there are parts that don't make sense
14:20:09 <corgifex> are you confusing values and types?
14:20:12 <EvilMachine> dwcook: I don‚Äôt want it in the picture to be used, but for completeness‚Äôs sake, and for making it easier to understand typeclasses that built on it. Like you‚Äôd understand monads easily, when knowing about Pointed and Bind.
14:20:36 <old_beginner> mmm...let me unroll this, to see if the types fit
14:21:13 <ajcoppa> old_beginner: note that if you stuff an f (a -> b) into bind, your lambda should take a value of type (a -> b), not f a
14:21:29 <dwcook> EvilMachine: My favorite way to understand Monad is as Applicative but with join.
14:21:40 <dwcook> EvilMachine: You just have some unfortunate history that complicates that.
14:22:09 <EvilMachine> Gotta go now. Have a nice evening anyone! I wish you were all in Cologne. I‚Äôd open up a nice lounge / club thing for Haskellers, like those cigar-smoking men in the big leather chairs in the movies.
14:22:17 <dwcook> EvilMachine: Have fun.
14:22:40 <EvilMachine> dwcook: Somebody told me that Applicatives have one thing that Monads don‚Äôt.
14:22:55 <hiptobecubic> i think that's backwards, no?
14:24:05 <monochrom> the Aristotle duality between "define by listing examples" and "define by listing axioms".
14:24:26 <monochrom> Monads have more axioms, therefore fewer examples.
14:24:48 <monochrom> Applicatives have examples that Monads don't.
14:25:15 <Geraldus> hey folks! Is here anyone using Haskell on Debian? )
14:29:35 <old_beginner> ajcoppa :  this seems  better no ? (<*>) (f func) (f a) =  (func <$> (f a))  =<<(f func)
14:30:00 <old_beginner> with (f func) of type f ( a-> b)
14:30:30 <johnw> that's just (<*>) = ap, fyi
14:30:38 <ajcoppa> you're sort of mixing together the types and the values there
14:30:39 <johnw> @src ap
14:30:39 <lambdabot> ap = liftM2 id
14:30:53 <ajcoppa> johnw: this is for the NICTA course where you have to implement them yourself
14:30:58 <johnw> ah
14:31:00 <johnw> good idea
14:31:26 <old_beginner> ajcoppa : the mean (f a) being an uncorrect identifier for a value ?
14:31:31 <klaff> Which german player(s) has scored 14 World Cup goals in total? // should it be have or has when writing like that?
14:31:38 <old_beginner> the -> you
14:32:02 <johnw> I think has, since you are making the (s) the optional part
14:32:14 <corgifex> I'd go with players/have
14:32:17 <corgifex> no parens
14:32:47 <abstract-alf> I just completed a solution to Project Euler problem #9... but it takes about a minute to complete.  Anyone care to help me optimize my code? http://lpaste.net/106004
14:32:49 <ajcoppa> old_beginner: right. as written, you have syntax errors. you can't pattern match using f, because f is a type constructor
14:33:32 <old_beginner> ok, I got it, as opposed to a value constructor, right ?
14:33:35 <ajcoppa> yeah
14:33:55 <ajcoppa> what you wrote describes the types of everything correctly though
14:34:47 <perturbation> I also have a Project Euler question.  I have a solution to problem 23, but it runs way too slowly. (written in 'baby Haskell')
14:35:07 <perturbation> http://pastebin.com/Ke9VPGMj
14:35:10 <monochrom> what is problem 23?
14:35:19 <abstract-alf> non-abundant sums
14:35:31 <perturbation> Sum of all non-abundant numbers
14:35:32 <perturbation> yup
14:36:20 <old_beginner> ajcoppa : so this becomes (<*>) ffunc fa =  (<$> fa) =<< ffunc  ?
14:36:22 <Eduard_Munteanu> perturbation: have you compiled with -O ?
14:36:41 <ajcoppa> old_beginner: you tell me -- does that work? :)
14:36:55 <abstract-alf> Eduard_Munteanu: what does that switch do?
14:37:00 <perturbation> Eduard: no, I can try, though
14:37:20 <Eduard_Munteanu> abstract-alf: enable optimizations (disabled by default) at all
14:37:42 <Eduard_Munteanu> perturbation: do so, things like 'sum' can be terrible otherwise
14:38:06 <dwcook> Geraldus: I'm using Haskell on a Debian-based system that I believe is demonstrably similar enough for our purposes. What's up?
14:39:01 <abstract-alf> Eduard_Munteanu: thanks, that cut the running time by a quarter.  my solution is still slow, though; it takes about 10 seconds to execute
14:39:28 <abstract-alf> er.. by 4
14:39:33 <abstract-alf> er.. by a factor of 4
14:39:41 <Geraldus> dwcook: I‚Äôm completely new to debian %) Just rented VPS with debian 7 preinstalled. How should I install ghc 7.8.2 and haskell-platform? Just `apt-get install haskell-platform`? Which GHC you have? )
14:40:18 <Eduard_Munteanu> abstract-alf: are you running yours compiled or in ghci? ghci is slower.
14:40:30 <dwcook> Geraldus: That's one way and probably the easiest. The way I did it was download and install the binaries of GHC 7.8.2 and cabal-install from their respective websites.
14:40:40 <abstract-alf> Eduard_Munteanu,  it was in ghci but then I compiled with ghc and ran the executable
14:40:43 <perturbation> Eduard: Still runs slowly, though I think I just to be less lazy and do a smarter algorithm for the divisors than trial division.  Thanks!
14:41:04 <old_beginner> ajcoppa : well the module compiles and it works, I hope this is the right implemention called.
14:41:19 <ajcoppa> old_beginner: do you know how to run the doctests?
14:42:00 <dwcook> Geraldus: If you're just beginning, I'd say go with haskell-platform for now to avoid the pain of setup.
14:42:04 <Geraldus> dwcook: Oh, looks like I should feel free to install the binaries! (I‚Äôm mostly Gentoo user)
14:42:30 <perturbation> Geraldus: I'm running debian 7 equivalent and installed through standard repository.  Seems to work fine; hardest part was getting good syntax highlighting for vim
14:42:54 <Eduard_Munteanu> perturbation: how long does it take to run?
14:43:33 <dwcook> Geraldus: Though I would suggest, once you've got cabal-install, be it from haskell-platform or otherwise, running `cabal install cabal-install` and adding $HOME/.cabal/bin to your path so you have the latest cabal-install with sandboxes, which are quite handy.
14:43:49 <old_beginner> ajcoppa: no, I work mainly in ghci.
14:44:13 <dwcook> Geraldus: Er, `cabal update` and then `cabal install cabal-install` that is.
14:44:42 <Geraldus> dwcook: Thanks pal! I don‚Äôt need syntax highlighting on server I believe )
14:44:52 <ajcoppa> working in ghci is fine. once you think you have a solution, you can write it into the actual course files and run the built-in doctests to help verify that your solution works correctly
14:45:03 <ajcoppa> doctest -isrc -Wall -fno-warn-type-defaults <filename.hs>
14:45:05 <perturbation> Eduard: Still going, ;).  I have to sum for numbers less than 28123 in order to get it it to stop in a reasonable amount of time.  I'm not sure how long it took last time, but it was minutes (think I just let it run and came back)
14:45:39 <dwcook> Geraldus: It was someone else who made the syntax highlighting comment. I can't speak to that since I have perfectly serviceable syntax highlighting in Vim and didn't have to do anything extra.
14:46:31 <Geraldus> dwcook: Oh, sorry I see it was not you )
14:46:43 <Geraldus> perturbation: Thanks )
14:47:05 <perturbation> (I have an equivalently dumb C version that runs in ~a minute, and a slightly smarter lua version that takes ~12 seconds.  I think I just need to learn more haskell - this was my first try after reading first 2 chapters of LYAH)
14:49:11 <hunt> tst
14:49:30 <Eduard_Munteanu> perturbation: provide type signatures for your toplevel definitions, perhaps using Int for the numbers
14:50:48 <Eduard_Munteanu> It could take long, but I feel it shouldn't take that long even with that algo.
14:50:50 <old_beginner> ajcoppa : thank you for the tip (my cabal is out of date....)
14:51:03 <fread2282_> perturbation: maybe use Set for abundantSums?
14:51:26 <ajcoppa> old_beginner: no problem. there are a couple other instructions in the README that may help
14:51:32 <Eduard_Munteanu> Good point.
14:52:12 <perturbation> Eduard, fread: thanks, I will give that a try
14:52:15 <fread2282_> also using Seq instead of list should give you a free speedup
14:52:27 <Geraldus> dwcook: Just installed haskell-platform. The version of GHC bundled is 7.4.1)))
14:53:05 <ReinH> Geraldus: where did you install it from?
14:53:33 <Geraldus> ReinH: I dont‚Äô know. Just run `apt-get install haskell-platform`
14:53:43 <Geraldus> I‚Äôm on Debian 7
14:53:51 <ReinH> Ah, yes, linux package managers are notoriously out of date for such things
14:54:51 <bergmark> i assumed they'd at least have 7.6 by now :-(
14:54:57 <dwcook> Geraldus: It shouldn't matter what version of cabal-install you get from the PM since that can upgrade itself, but you might be interested in getting a more recent GHC. https://www.haskell.org/ghc/
14:55:27 <marchelzo_> How do you check your answer now that the account system is down on project euler?
14:55:29 <dwcook> The way mine is setup, I have the latest two versions both installed under separate prefixes in my home directory, so I can just update my PATH as appropriate in case I run into an issue or want to test both.
14:55:52 <Geraldus> dwcook: Yeah. In perfect world I want to have 7.8.2 )
14:57:03 <hexagoxel> marchelzo_: there are lists of all answers in the intertubes
14:57:23 <hexagoxel> (spoilers!): https://code.google.com/p/projecteuler-solutions/wiki/ProjectEulerSolutions
14:57:29 <abstract-alf> also: https://github.com/nayuki/Project-Euler-solutions/blob/master/Answers.txt
14:57:37 <marchelzo_> ah ok, I was just wondering if they still had some way of submitting an answer to see if you were right
15:00:43 <johnw> In a perfect world I would have GHC 7.18 about now
15:01:25 <old_beginner> ajcoppa: yes, thank you very much, It works now and doctest is happy about this version of <*>
15:01:35 <luite> johnw: why not just make GHC 7.10 better instead?
15:02:21 <johnw> already pass√© in my ideal world
15:02:27 <johnw> oh, and we deprecated haskell2010 already too
15:02:30 <old_beginner> ajcoppa : I can go to sleep in peace, now. thank you again.
15:05:59 <luite> johnw: but you were supposed to say something along the lines of 'but mine goes up to 7.18"!
15:06:31 <Tjr> In my ideal world, I know haskell. :-P
15:08:04 <luite> so everyone answer my question in this reddit message! http://www.reddit.com/r/haskell/comments/28qi12/stack_traces_in_ghcjs/
15:08:05 <bvad> Hi guys, is there a better(more concise) way of doing this sort of binary parsing? https://gist.github.com/bjarkevad/b0b35981efb0a9999a62
15:09:01 * hackagebot csv-to-qif 0.3 - A small program that will read csv files and create qif files  http://hackage.haskell.org/package/csv-to-qif-0.3 (palo)
15:09:14 <mreh> I'm running a haskell script through PHP's exec() function and get nothing returned
15:09:24 <luite> bvad: sure, for everything that's a Binary instance you can just use put, so you can remove all the specific ones
15:09:34 <mreh> works fine on the terminal
15:09:55 <abstract-alf> Any quick tips for tweaking my "isPrime" algorithm to improve performance? http://lpaste.net/106007
15:10:01 <mreh> and exec is working with a regular command, like ls
15:10:02 <luite> bvad: and there are various ways of automatically generating the Binary instance for data like this
15:10:13 <mreh> maybe this is more of a question for #php
15:10:22 <bvad> luite: So I'd just use 'put $ basemode h'?
15:10:40 <bvad> luite: And which automagical ways should I look into? :)
15:10:50 <luite> bvad: that'd work, also pattern matching on the constructor would make that shorter
15:11:27 <luite> bvad: and you'd write instance Binary HeartBeat so you can just (put h) everywhere else in your code
15:12:07 <luite> bvad: not sure what exactly binary has, but the usual ways are through Data.Data, GHC.Generics and using template haskell to derive the instance
15:12:09 <bvad> luite: Ahh! I'll see how it works out..
15:13:01 <derekv> https://github.com/DerekV/rpg
15:13:31 <derekv> How would I refactor this to be more functional?
15:14:04 <marchelzo_> abstract-alf: instead of [2..n], you could do 2:[3,5..n]
15:14:18 <marchelzo_> abstract-alf: not much of an improvement, though
15:15:39 <Tjr> derekv: (newbie here) you could use the state monad (transformer) to pass GameState around.
15:15:48 <hexagoxel> my program segmentations-faults. is there a guide for what to do next (besides crying :)?
15:16:15 <luite> hexagoxel: are you doing anything unsafe?
15:16:28 <hexagoxel> not that i know of, no
15:16:50 <abstract-alf> marchelzo_, I tried it but there wasn't a noticable difference (still ~10 seconds to get all primes below 55000)
15:16:52 <Tjr> derekv: if (playerHp afterMonsterGoes <= 0) then  .... looks similar to the maybe monad.
15:17:17 <marchelzo_> abstract-alf: Yeah it would only affect the very first case where it is removing multiples of 2
15:17:30 <pavonia> hexagoxel: What are you doing? FFI stuff?
15:17:39 <hexagoxel> luite: oh, i have one unsafeToForeignPtr0 in my code
15:17:45 <abstract-alf> marchelzo_, anything with my recursion that could be improved?
15:17:59 <chrisdotcode_> guys, do you think I should write out FromJSON instances, even from simple types, or should I have them derived?
15:18:27 <hexagoxel> no ffi stuff, but i use the bindings for alsa
15:18:40 <Eduard_Munteanu> chrisdotcode_: depends if you need things like default values for fields, which deriving doesn't gets you.
15:18:41 <Tjr> derekv: use the Writer monad to keep track of all those messages generated in combat. Print them all at once in your impure main loop.
15:18:52 <derekv> Tjr: thanks for the suggestions
15:19:08 <marchelzo_> Some way of making it more like the actual sieve of eratosthenes. Mark each non-prime as a non-prime rather than removing it from the list. That way you could do like, markEvery rather than computing the remainder for every element
15:19:13 <chrisdotcode_> Eduard_Munteanu: ah, good point. I generally won't need default values, so should I derive away?
15:19:31 <Eduard_Munteanu> chrisdotcode_: then yeah... nothing wrong with deriving.
15:19:33 <Tjr> derekv:  monsterAction <- head <$> >>> You've probably thought about the case that the list is empty.
15:19:41 <chrisdotcode_> thanks!
15:20:45 <Tjr> derekv: shuffleAndDraw  >>> maybe you'd want to move your random number generator into your game state, too. LYAH has a section on how to use the state monad to keep track of it.
15:21:09 <luite> bvad: this might be useful http://hackage.haskell.org/package/derive
15:21:23 <bvad> luite: I'll look into it, thanks a bunch
15:22:33 <derekv> Tjr: yea I thought of that too, I need to study the state monad and how i could use it and put the RNG in there
15:22:38 <Tjr> derekv: That's what I can see from the top of my head. Maybe the experts will have more / better advice.
15:23:51 <benzrf> @hoogle (<<)
15:23:56 <lambdabot> Text.Html (<<) :: HTML a => (Html -> b) -> a -> b
15:23:56 <lambdabot> Text.XHtml.Strict (<<) :: HTML a => (Html -> b) -> a -> b
15:23:56 <lambdabot> Text.XHtml.Frameset (<<) :: HTML a => (Html -> b) -> a -> b
15:24:00 <benzrf> hrm
15:24:31 <luite> bvad: and there appear to be a few that use GHC.Generics on hackage. as an example for similar derivation things you could check the aeson package, which has Data.Aeson.Generic that uses Data.Data, and Data.Aeson.TH that uses template haskell
15:26:24 <bvad> luite: Seems I'm not the only one who wanted to do this :)
15:27:43 <derekv> Tjr: thanks you gave me enough to move forward with for sure
15:27:53 <Tjr> you're welcome
15:27:57 <luite> sure but no one uses binary data anymore, everything is json now!
15:28:07 <latro`a> derekv: I'd probably make your pieces a little smaller
15:28:12 <bvad> luite: haha
15:28:40 <latro`a> derekv: for example, split the "tell the players the current state", "get a move", "perform a move"
15:28:49 <latro`a> into more cleanly separated pieces
15:29:02 <bvad> luite: I'm not sure JSON is the best idea for a protocol used for small RC planes/copters
15:29:04 <Tjr> derekv: latro`a 's suggestion has the advantage that you can test smaller pieces of code one by one, interactively, in ghci.
15:29:15 <Tjr> That cuts down on the number of bugs to fix.
15:30:22 <Tjr> pure (non-IO) code is especially easy to test :-)
15:30:27 <luite> bvad: you could borrow those derivers of course. derive a ToJSON instance, and then a Binary basend on that, where you just encode the JSON to a ByteString and then use the Binary instance for ByteString
15:30:53 <bvad> luite: Sounds brilliant!
15:31:26 <bvad> luite: I'm really just 'copying' a C implementation of the protocol (MAVLink) I'm working with
15:31:30 <derekv> latro`a: for sure that is a goal, just got to a good stopping point, happy to have written something but it definatly has a smell
15:31:42 <luite> bvad: now that might not be the best idea ever, but think of what happens when someone (non-Haskeller) reverse engineers your file format. that must make up for something :)
15:32:25 <luite> bvad: hehe if you have to follow an existing protocol then your options are more limited yeah
15:32:45 <Geraldus> luite: Hi pal! ) How do you do?)
15:33:17 <bvad> luite: http://www.mavlink.org/mavlink/start this is what I'm working with.. I just really don't want to use C, C# or Python to work with that protocol.. So I'm writing a generator for Haskell
15:33:33 <bvad> luite: Also serves as an exercise to actually learn Haskell ;)
15:33:40 <Geraldus> Hey friends, I just wget ghc 7.8.2 binaries and unpacked them. What should I do next? )
15:34:44 <latro`a> derekv: you should also probably look into StateT IO
15:35:02 <Tjr> derekv: Maybe you could ask how much of your code is specific to the main loop type game, (i.e. setup - repeat forever (( wait for keyboard - computer's turn - player's turn - houskeeping )) destroy objects). And then how much is specific to the actual game.
15:36:08 <Tjr> Those two things could perhaps be separated into different modules.
15:36:20 <hexagoxel> when i hoogle for withForeignPtr, the result link is dead :(
15:36:36 <latro`a> right, a crude sketch that doesn't have anything to do with your game itself would be useful
15:36:59 <derekv> latro'a: good idea
15:37:04 <derekv> Tjr: same
15:37:22 <Tjr> Ok, I believe that's already a lot of homework for derekv. Talk is cheap, but code takes a lot of work.
15:38:13 <derekv> Could I use some sort of state + lens to make functions like "printPlayerStatus" and "playerTurn" into generic functions that work on any character in the game state?
15:38:35 <derekv> i read about lenses but haven't used them yet
15:39:04 <luite> Geraldus: hi :) do you happen to be an expert at javascript data analysis and visualisation libs that can do simple olap-type queries?
15:39:10 <Tjr> I like the idea, but don't know lenses yet. No useful input, sorry.
15:39:53 <Geraldus> luite: unfortunatelly no (
15:40:07 <derekv> anyways thanks, I have a bunch of notes, think I'll go outside and enjoy the weather for a bit, try to take this further tommorow
15:40:18 <Geraldus> I‚Äôm just an amateur
15:41:19 <benzrf> Geraldus: in the words of jake the dog
15:41:20 <benzrf> sucking at something is the first step to becoming sorta good at something
15:42:52 <luite> not everything fits neatly in an olap cube though, but hopefully most does
15:42:57 <Geraldus> benzrf: Hey pal, this is obviuos for me )
15:43:18 <ezrios> what's with the parentheses
15:44:20 <hexagoxel> ah i think i my unsafe stuff was.. unsafe. garbage collector sometimes collected the data before i finished using the pointer
15:45:38 <hexagoxel> whats the safest way to access the internal pointer from a Data.Vector.Storable.Vector?
15:46:56 <derekv> latro`a: Tjr: thanks again
15:53:32 <oisin620> I'm trying to implement a naive version of the Rope data structure: http://en.wikipedia.org/wiki/Rope_%28computer_science%29#Report  However, I'm having troubles writing a function to calculate the weight of a node. Here's what I have so far: http://lpaste.net/106008 I'm a bit confused by Wikipedia's definition of weights, though. If someone has experience with this, I'd really appreciate it.
15:53:42 <hexagoxel> i now use Data.Vector.Storable.unsafeWith, which seems to be the least unsafe (?)
15:55:51 <hexagoxel> well, i have not encountered a segmentation fault yet (but it was/is random)
15:58:46 <Tjr> oisin620: weight (Branch left right) = sum $ map weight [left, right]
15:59:04 * hackagebot csv-to-qif 0.3.1 - A small program that will read csv files and create qif files  http://hackage.haskell.org/package/csv-to-qif-0.3.1 (palo)
15:59:46 <oisin620> Tjr: But I don't think that's correct - if you look at the Wiki image, at node C, it only has a weight of 6 - not 6 + 3
16:00:16 <Tjr> oisin620: once you've got things working and feel comfortable, you could turn your Rope into a Foldable, to separate out the "traverse the rope" from the "mangle the numbers"
16:01:50 <Tjr> oisin620: good point, I didn't catch that.
16:03:25 <Tjr> oisin620: ah, I get it. Rename "weight" to "naiveweight", and then:
16:04:31 <Tjr> weight (Branch left right) = naiveweigth left ; weight x@(Leaf y) = naiveweight x
16:04:34 <napping> I'm trying to try hsqml, but debian stable doesn't have Qt5, and installing 5.3.1 myself didn't include a Qt5Quick pkgconfig package (maybe it's been renamed Qt5Declarative?)
16:05:33 <Tjr> oisin620: sorry, forget about that.
16:05:57 <oisin620> Tjr: :) No worries - it's a confusing article...
16:06:57 <Tjr> oisin620: take a look at the pseudocode for in the section "index"
16:07:46 <Tjr> it should give you a clear idea what the weight has to be
16:08:14 <benzrf> ok
16:08:16 <oisin620> Tjr: I guess I want to write: weight (Branch left right) = the weight of the leaf nodes of left
16:08:26 <oisin620> ?
16:08:35 <benzrf> i think i read that if fmap id = id then it follows from the types that fmap f . fmap g = fmap (f . g)
16:08:42 <benzrf> where can i find a proof of that o.o
16:08:57 <napping> Has anyone here tried hsqml?
16:12:40 <Tjr> oisin620: after some thought, I believe my naiveweight / weigth code is correct.
16:13:14 <Tjr> oisin620: The weight of a branching node is the total length of the string stored in its left daughter node.
16:13:25 <Tjr> (not the weight of its daugher node!)
16:14:00 <Tjr> oisin620: the weight of a leaf is the length of its contained string. The weight of the empty node is redundanct because you can always say Leaf [].
16:15:58 <oisin620> Tjr: I see
16:16:24 <Guest97512> Hey guys, I am just learning haskell and can not for the life of me figure out how to execute a fairly simple example
16:16:50 <Iceland_jack> Guest97512: which example?
16:17:02 <Guest97512> Basically I need to read in X user inputs, and print them out.   but everything I do I keep getting errors
16:17:03 <Iceland_jack> if you mean to paste code please use
16:17:03 <Iceland_jack> @lpaste
16:17:03 <lambdabot> Haskell pastebin: http://lpaste.net/
16:17:51 <Guest97512> one second, let me post it somewhere so you can see what I am talking about
16:18:50 <benzrf> Guest97512: replicateM n getLine
16:19:27 <begriffs> How do I convert a ByteString to a lazy ByteString?
16:19:31 <oisin620> Tjr: Got it, thanks very much!
16:19:39 <Tjr> you're welcome
16:20:59 <Guest97512> @benzrf replicateM is not in scope it is saying
16:20:59 <lambdabot> Unknown command, try @list
16:21:28 <Guest97512> replicateM is not in scope it is saying
16:21:31 <Iceland_jack> Guest97512: import Control.Monad
16:21:47 <pavonia> begriffs: fromChunks
16:22:00 <Iceland_jack> Guest97512: when you reference people you should prefer '<nick>:' rather than '@<nick>' since lambdabot uses @
16:22:11 <benzrf> Guest97512: plus, my client only pings me if it's like that
16:22:15 <benzrf> prefixed characters bungle it up
16:22:18 <Guest97512> sorry about that.  thanks guys
16:23:19 <Iceland_jack> @ty replicateM 10 getLine
16:23:20 <lambdabot> IO [String]
16:23:22 <Guest97512> that was exactly whats I was looking for. I kep trying to use mapM_ and iterate, and other functions that just weren't doing it  the way IO is handled is throwing me for a loop, everything else is pretty straight forward
16:24:28 <begriffs> pavonia: thanks! By the way, how do I hoogle for stuff like this? Hoogle doesn't accept "Data.ByteString -> Data.Lazy.ByteString" because of the dots.
16:24:38 <Iceland_jack> you could define it using mapM if you wanted
16:24:38 <Iceland_jack> @ty mapM (const getLine) (replicate 10 ())
16:24:39 <lambdabot> IO [String]
16:25:32 <pavonia> begriffs: I don't know
16:25:44 <foobarbaz> Hi there, i'm trying to get familiar with monads and such
16:25:57 <foobarbaz> I wonder if there are any real world programs that i can make that are trivial enough to implement?
16:26:15 <Iceland_jack> foobarbaz: First, are you quite familiar with Functor and type classes?
16:26:23 <Kaidelong> N-Queens can be solved using the list monad
16:26:34 <Kaidelong> although that's hardly "real world"
16:27:00 <foobarbaz> Iceland_jack: Nope
16:27:04 <foobarbaz> I'm only on chapter 10 of programming in haskell
16:27:32 <Iceland_jack> then you should learn those before trying to 'get' monads
16:27:32 <nicoo> Kaidelong: Plenty of things can be done with lists
16:27:51 <foobarbaz> I'm also following along with Erik Meijer's online course on FP
16:28:03 <foobarbaz> But i'm not sure im 'getting it', so i wanted to do some real problems before moving on to th enext chapters
16:28:11 <Iceland_jack> foobarbaz: then why did you mention monads?
16:28:19 <Tjr> Iceland_jack: I happen to disagree. probability (monad) is what drove me to learn monads at all.
16:28:30 * nicoo does a happy dance after remembering that soon, Monad will be a superclass of Applicative.
16:28:45 <Tjr> Iceland_jack: so it's possible to have an intuitive understanding of monads without applicative or functor.
16:28:52 <Iceland_jack> Tjr: I didn't say it wasn't possible
16:28:57 <foobarbaz> Iceland_jack: because that's the part i'm on i believe
16:29:15 <foobarbaz> I did the parser combinator stuff, moved on to IO monad there
16:29:34 <Kaidelong> foobarbaz: oh if you're following one of erik meijir's things, C# might be a better environment to try and understand how they work in
16:29:38 <Kaidelong> it's more verbose
16:29:38 <Iceland_jack> but you haven't covered type classes at all or Functors?
16:29:46 <Kaidelong> has he covered LINQ expressions?
16:29:57 <foobarbaz> Kaidelong: Yeah he keeps referencing them
16:30:02 <foobarbaz> IE saying >>= is just select many
16:30:26 <Kaidelong> @ty concatMap
16:30:27 <lambdabot> (a -> [b]) -> [a] -> [b]
16:31:27 <benzrf> @ty (>>=) `asAppliedTo` []
16:31:29 <lambdabot> [a] -> (a -> [b]) -> [b]
16:32:20 <khanage> foobarbaz: the chapters in lyah are great for understanding monads
16:32:28 <Iceland_jack> Yes, read LYAH
16:32:35 <khanage> As well as applicative and functor
16:32:58 <benzrf> i think monads are easier to understand in terms of join
16:33:05 <foobarbaz> Haha, just started reading that one too
16:33:11 <foobarbaz> I jumped in at chapter 8
16:33:17 <foobarbaz> Hopefully it's not before that
16:33:18 <benzrf> although i guess grasping bind is more significant in terms of actually using them
16:33:28 <khanage> That's the book that allowed me to grasp all of these concepts
16:33:29 <Iceland_jack> foobarbaz: Why did you skip chapters?
16:34:07 <foobarbaz> Iceland_jack: I've been on LYAH for about 2 years now
16:34:13 <foobarbaz> I think that's where i gave up last time :P
16:34:52 <benzrf> foobarbaz: applicatives are not so hard
16:34:56 <yitz> @type asAppliedTo
16:34:58 <lambdabot> (a -> b) -> a -> a -> b
16:35:00 <benzrf> wait
16:35:02 <yitz> @. djinn type asAppliedTo
16:35:03 <benzrf> foobarbaz: do you grok functors
16:35:03 <lambdabot> f a b _ = a b
16:35:14 <benzrf>   w
16:35:22 <ninja_code> dumbass question: how do I go from Int -> [Int}, i.e. generate all integers less than or equal to x, i.e. 2 -> [0, 1, 2]; [3] -> [0, 1, 2, 3]
16:35:37 <Iceland_jack> ninja_code: [0..b]
16:35:40 <Iceland_jack> > [0..3]
16:35:42 <foobarbaz> ^
16:35:44 <lambdabot>  [0,1,2,3]
16:35:52 <ninja_code> yeah
16:35:54 <ninja_code> I am an dumbass
16:35:56 <ninja_code> never thought ot use ..
16:36:02 <yitz> @ fromTo
16:36:04 <Iceland_jack> > enumFromTo 0 3
16:36:05 <lambdabot>  [0,1,2,3]
16:36:14 <benzrf> 07:34 < benzrf> foobarbaz: do you grok functors
16:36:14 <benzrf> 07:34 < benzrf> foobarbaz: do you grok functors
16:36:14 <benzrf> 07:34 < benzrf> foobarbaz: do you grok functors
16:36:14 <benzrf> 07:34 < benzrf> foobarbaz: do you grok functors
16:36:15 <benzrf> 07:34 < benzrf> foobarbaz: do you grok functors
16:36:17 <benzrf> 07:34 < benzrf> foobarbaz: do you grok functors
16:36:21 <benzrf> 07:34 < benzrf> foobarbaz: do you grok functors
16:36:22 <benzrf> oh crap
16:36:24 <benzrf> accidentally held down ctrl shift v
16:36:26 <foobarbaz> oops :P
16:36:32 * benzrf sits in the corner
16:36:33 <Iceland_jack> Did you just replicateM 7 that? :)
16:36:36 <benzrf> Iceland_jack: ;-;
16:36:49 <benzrf> this is the 2nd time this has happened in as many days
16:36:52 <yitz> @slap benzrf
16:36:52 * lambdabot secretly deletes benzrf's source code
16:36:53 <Tjr> foobarbaz: (shameless plug) I turned LYAH into Anki flashcards. It helps you avoid forgetting facts that you already understood. https://ankiweb.net/shared/info/1572953029
16:37:07 <benzrf> foobarbaz: do u tho
16:37:07 <nicoo> ninja_code: I guess you can use explicit recursion if you want to build the list ‚Äúby hand‚Äù
16:37:08 <luzie> do you grok functors!?
16:37:12 <foobarbaz> benzrf: Functors are just morphisms in the category of endofunctors, what's not to get?
16:37:22 <benzrf> foobarbaz: no
16:37:24 <benzrf> no they arent
16:37:29 <benzrf> they are objects in the category of endofunctors
16:37:39 <benzrf> you moron
16:37:59 <foobarbaz> #awkward
16:37:59 <benzrf> morphisms in the category of endofunctors are closer to a certain subset of natural transformations
16:38:05 <foobarbaz> :P
16:38:08 <benzrf> :t fmap
16:38:09 <lambdabot> Functor f => (a -> b) -> f a -> f b
16:38:12 <benzrf> ^this is functors
16:38:23 <foobarbaz> Tjr: In german?
16:38:40 <Iceland_jack> The Functor type class is not the same as functor in category theory
16:38:50 <Tjr> foobarbaz: no
16:38:54 <Tjr> why?
16:39:32 <foobarbaz> Iceland_jack: oh really?
16:39:35 <foobarbaz> oops
16:39:52 <benzrf> Iceland_jack: it is a subset of endofunctors in Hask
16:40:02 <Iceland_jack> Sure, but if you want to learn Haskell that's quite irrelevant
16:40:05 <benzrf> yea
16:40:21 <benzrf> i grokked monads long before i botherd to find out the formal definition of a functor in cat theory
16:40:32 <Iceland_jack> And why shouldn't do?
16:41:15 <foobarbaz> I'll work my way through LYAH
16:41:20 <foobarbaz> and come back to you guys
16:41:21 <foobarbaz> cheers :)
16:41:23 <ninja_code> LYAH ?
16:41:30 <ninja_code> for great good!
16:41:30 <ninja_code> to the moon!
16:41:31 <Iceland_jack> foobarbaz: at _least_ get through the type class chapter
16:41:35 <Iceland_jack> @google LYAH type classes
16:41:37 <lambdabot> http://learnyouahaskell.com/making-our-own-types-and-typeclasses
16:41:37 <lambdabot> Title: Making Our Own Types and Typeclasses - Learn You a Haskell for Great Good!
16:41:48 <ninja_code> someone needs to combine LYAH and Dogecoins
16:41:58 <ninja_code> Mine You A Dogecoin. For Great Good.
16:42:01 <ninja_code> Mine you a dogecoin in Haskell. For Great Good.
16:42:11 <StoneToad> o_O
16:42:23 <Iceland_jack> we have a very different understanding of need
16:42:49 <benzrf> fucking dogecoin
16:42:55 <benzrf> doge died long before dogecoin was a thing
16:42:59 <benzrf> goddamn zombie memes
16:43:43 <pavonia> Any ideas how to resolve "hPutChar: invalid argument (Bad file descriptor)" when running a Gtk application linked with -mwindows?
16:43:51 <foobarbaz> Iceland_jack: Good point, thanks
16:43:54 <ninja_code> benzrf: what's your dogecoin address?
16:44:02 * benzrf slaps ninja_code 
16:44:08 * hackagebot besout 0.2.0.1 - Extended GCD of polynomials over F_p[x]  http://hackage.haskell.org/package/besout-0.2.0.1 (AbdelwahebMiled)
16:44:09 <foobarbaz> I wish there were 'larger' examples that combined the knowledge that you had learnt in these haskell books
16:44:12 <ninja_code> benzrf: I hate dogecoin
16:44:17 <ninja_code> I went into #dogecoin to laugh at them
16:44:21 <ninja_code> then someone gave me 2000 dogecoins
16:44:24 <ninja_code> and I becmae a dogecoin fan
16:44:27 <Iceland_jack> foobarbaz: You can check out Simon Marlow's book for larger, more intermediate examples
16:44:37 <StoneToad> ninja_code: how much is that worth?
16:44:40 <Iceland_jack> Type classes are one of the most basic, yet fundamental parts of Haskell
16:44:49 <ninja_code> StoneToad: $2 at the time, about $1.00 now
16:44:50 <lfairy> why is that package named "besout" with a S?
16:45:10 <Iceland_jack> @google Parallel Concurrent haskell
16:45:10 <lambdabot> http://chimera.labs.oreilly.com/books/1230000000929
16:45:11 <lambdabot> Title: Parallel and Concurrent Programming in Haskell
16:45:17 <joneshf> is there something like this :: Bool -> a -> Maybe a
16:45:17 <joneshf> so
16:45:29 <joneshf> it'd be like: if bool then Just a else Nothing
16:45:58 <lfairy> > "oh noes" <$ guard False
16:45:59 <lambdabot>  No instance for (GHC.Show.Show (f0 [GHC.Types.Char]))
16:46:00 <lambdabot>    arising from a use of ‚ÄòM58238964695441187858870.show_M58238964695441187858...
16:46:00 <lambdabot>  The type variable ‚Äòf0‚Äô is ambiguous
16:46:00 <lambdabot>  Note: there are several potential instances:
16:46:00 <lambdabot>    instance [safe] GHC.Show.Show a =>
16:46:17 <lfairy> > ("oh noes" <$ guard False) :: Maybe String
16:46:18 <lambdabot>  Nothing
16:46:30 <lfairy> > ("oh noes" <$ guard True) :: Maybe String
16:46:32 <lambdabot>  Just "oh noes"
16:46:37 <joneshf> beautiful
16:46:38 <joneshf> thanks
16:46:40 <Iceland_jack> and of course
16:46:41 <Iceland_jack> @src (<$)
16:46:41 <lambdabot> (<$) = (<$>) . const
16:46:58 <Iceland_jack> so
16:46:58 <Iceland_jack> > (fmap (const "oh noes") (guard True)) :: Maybe String
16:47:00 <lambdabot>  Just "oh noes"
16:48:05 <benzrf> why (<$>) . const
16:48:06 <lfairy> yeah, just replacing what's in there
16:48:07 <benzrf> why not fmap . const
16:48:12 <benzrf> it reads better to mero
16:48:13 <benzrf> *me
16:48:21 <joneshf> why not: (<$>) <$> const
16:48:24 <joneshf> :D
16:48:25 <Iceland_jack> because that's where the identifier comes from
16:48:32 <lfairy> ^
16:49:14 <benzrf> phooey
16:50:02 <Iceland_jack> I think
16:50:03 <Iceland_jack>     x <$ y = const x <$> y
16:50:03 <Iceland_jack> looks the quite readable :)
16:50:35 <Iceland_jack> -the
16:50:44 <benzrf> Iceland_jack: yea
16:52:25 <joneshf> aww poo, can't actually use guard
16:52:33 <joneshf> no monadplus in this lang
16:52:41 <benzrf> joneshf: let me guess
16:52:41 <benzrf> elm?
16:52:48 <joneshf> nope
16:52:58 <benzrf> dang
16:53:05 <joneshf> purescript
16:53:18 <joneshf> there's an issue for it that i think we all forgot about
16:53:45 <benzrf> i cant believe JS became the web standard
16:53:46 <joneshf> guess i can just roll it for this case
16:53:48 <benzrf> how the hell did that happen
16:53:49 <benzrf> q.q
16:53:58 <Iceland_jack> joneshf: sure
16:53:58 <joneshf> what else was supposed to be it?
16:54:01 <joneshf> java?
16:54:48 <heatsink> first mover privileges
16:54:59 <heatsink> The first javascript was developed on a tight time budget
16:55:33 <heatsink> So they didn't have time to design it well
17:02:40 <zq> is there a way to map from a type to a value?
17:02:52 <zq> without resorting to proxies and typeclasses
17:03:27 <Eduard_Munteanu> zq: not unless singleton types count
17:03:38 <zq> Eduard_Munteanu: what do you mean?
17:04:10 * hackagebot wai-cors 0.2 - CORS for WAI  http://hackage.haskell.org/package/wai-cors-0.2 (larsk)
17:04:11 <Eduard_Munteanu> zq: with DataKinds, you get sing :: Sing a, for certain as
17:04:46 <Eduard_Munteanu> zq: http://hackage.haskell.org/package/base-4.6.0.1/docs/GHC-TypeLits.html
17:07:21 <Eduard_Munteanu> zq: e.g. you can make it such   SingBool True == (sing :: Sing True)
17:08:19 <Eduard_Munteanu> (where SingBool would be defined by an instance of the Sing data family)
17:09:38 <Eduard_Munteanu> zq: also see fromSing
17:27:02 <gcganley> ok so im familiar with clojure and other Lisp's but haskell feels like something completely different. Is there anything that will involve unlearning between clojure and haskell
17:30:51 <Kaidelong> gcganley: not that much, the biggest adjustment is getting used to static typing really
17:31:23 <Iceland_jack> The type system, probably laziness
17:31:24 <Kaidelong> but after i left scheme-land this was exactly what I was looking for (although I was already familiar with ML)
17:31:50 <Kaidelong> haskell syntax is mostly just a little bit of sugar over lisp syntax
17:31:58 <Kaidelong> oh there is one big thing though, ADTs
17:32:07 <Tjr> what does ADT stand for?
17:32:20 <Kaidelong> algebraic data types I think?
17:32:21 <derekv> algebraic data types
17:32:24 <Tjr> oh.
17:32:27 <gcganley2854> Kaidelong: well i've used alot of typed clojure and I learn C++ in school so typing isnt that unfamiliur to me... but haskell typing seems ALOT more complex
17:32:59 <gcganley> and emacs is printing everything twice what the hell...
17:33:14 <benzrf> gcganley: this is what you get for not using vim
17:33:14 <benzrf> :-#
17:33:17 <Kaidelong> gcganley2854: well without extensions I'd argue it's simpler than the type systems of Java and C++ because it works more predictably...
17:33:18 <benzrf> * :-D
17:34:03 <Kaidelong> but add in all the extensions and you can get some bizzare things from the perspective we bring, like types that can only be inhabited by balanced trees and not unbalanced ones
17:34:18 <Kaidelong> in the future as dependent typing gains traction perhaps they won't seem so weird
17:35:05 <gcganley2854> Kaidelong: I've been reading on type theory to get ready for that sorta thing but it still all goes over my head
17:35:07 <Kaidelong> but I do think "list of int" is more intuitive than "a list of ints is a subtype of lists in general"
17:35:25 <Kaidelong> and so do most programmers which is why C++ pretends to have this with metaprogramming and why Java added generics
17:35:26 <k00mi> there are some things like the monomorphism restriction and the way instance resolution works that are quite surprising at first
17:35:32 <Kaidelong> haskell and ML always thought this way
17:36:30 <Kaidelong> k00mi: the monomorphism restriction is particularly sad because it's not actually neccessary for the type system to work and you can even turn it off without much of a consequence
17:36:34 <gcganley2854> Kaidelong: like all the functional side of it I totally get but the typing can be a little hard to approach
17:37:19 <Kaidelong> gcganley: if you know anything from the logical paradigm, it helps
17:37:26 <Kaidelong> haskell types are logic programs
17:37:43 <Kaidelong> where parameters work like free variable and type checking is unification of terms
17:38:22 <Tjr> Kaidelong: types that can only be inhabited by balanced trees and not unbalanced ones >>> can you provide a pointer?
17:38:25 <gcganley2854> one sec off to wikipedia because ive never come in contact with some of these terms
17:39:24 <lfairy> Tjr: http://codereview.stackexchange.com/questions/15017/imroving-gadt-type-safe-code-for-aa-trees
17:41:04 <Kaidelong> Tjr: http://jozefg.bitbucket.org/posts/2014-02-10-types-kinds-and-sorts.html
17:41:44 <Kaidelong> in the end they demonstrate how trying to create an unbalanced tree causes a type error
17:42:06 <Kaidelong> but as you can see they need a whole bunch of extensions to pull that off
17:42:26 <gcganley> sorry emacs was being a pain
17:42:48 <gcganley> so what papers do you recomend to better understand haskell's type system?
17:43:51 <Kaidelong> gcganley: any introduction to ML programming should do
17:44:05 <Kaidelong> if you are familiar with "generics" in java, you're set
17:44:11 <marchelzo_> Why is the intuition behind (=<<) being called bind?
17:44:14 <marchelzo_> what is*
17:44:21 <benzrf> marchelzo_: you mean (>>=)?
17:44:36 <gcganley> im a c++ guy is that template metaprogramming?
17:44:37 <Kaidelong> the only particular caveat haskell introduces are typeclasses but fortunately those are really simple and are pretty close in concept to java interfaces
17:44:40 <benzrf> i guess you could say that you're 'binding' the mobit to a function to be run when it yields a value
17:44:42 <marchelzo_> uhh I guess. I'm doing the NICTA course and it says (=<<) is bind
17:44:57 <k00mi> they are the same with arguments swapped
17:45:10 <Kaidelong> gcganley: yeah C++ pretend with template metaprogramming but that's a way more powerful feature, also less safe, than "generics"
17:45:42 <Kaidelong> howeer
17:45:49 <Kaidelong> it's fine from the understanding angle
17:45:51 <k00mi> marchelzo_: I think do notation makes it pretty clear why you might call it bind
17:46:04 <gcganley> Kaidelong: yeah its really easy to shoot your self in the foot with templates
17:46:16 <gcganley> Kaidelong: REALLY easy
17:46:37 <Kaidelong> yeah unrestricted metaprogramming is like that in general
17:46:39 <marchelzo_> k00mi: Ah I forgot about that. When you do x <- getLine it's actually just syntactic sugar for a bind expression?
17:47:22 <gcganley> Kaidelong: I have Visual Studio and you mentioned ML should i learn F#?
17:47:36 <Kaidelong> gcganley: you probably already understand haskell types, the emphasis is just on "templates" and not on "inheritance"
17:47:56 <Kaidelong> gcganley: F# is a great language, although it's a bit more complicated than haskell
17:47:58 <k00mi> marchelzo_: yep, for getLine >>= \x -> <rest of do>
17:48:08 <k00mi> the de-sugaring rules are very simple
17:48:11 <Kaidelong> that said if you can learn F# you are set to pick up haskell really quickly
17:48:14 <gcganley> Kaidelong: in what way is it more complicated?
17:48:24 <Kaidelong> it has more features and a less simple syntax
17:48:24 <Tjr> Kaidelong: lfairy thanks, an interesting read.
17:48:40 <gcganley> Kaidelong: thanks for the help btw
17:49:22 <Kaidelong> F# programming style honestly might spoil you in some regards when you later try to pick up haskell
17:49:37 <gcganley> Kaidelong: its just haskell is built up to be really complicated and hard to grasp
17:49:45 <Tjr> gcganley: Kaidelong there's a "compiler" that turns OCAML into C++ templates
17:49:50 <gcganley> Kaidelong: though they said that about lisp too lol
17:49:51 <Kaidelong> Haskell is really simple actually
17:50:15 <benzrf> n
17:50:21 <gcganley> Tjr: really? is there a github project for that?
17:50:22 <marchelzo_> k00mi: Thanks. That actually explains a lot that I probably should have understood already.
17:50:40 <Kaidelong> if anything haskell is easier than lisp just because it's more parsimonious in terms of its behavior and it has a nicer looking and less heavyweight syntax than lisp
17:50:52 <Kaidelong> really the only comparable language in terms of easiness I've seen is Prolog
17:50:55 <Kaidelong> maybe Icon
17:50:59 <Tjr> gcganley: it's mentioned somewhere in the comments: http://bartoszmilewski.com/2009/10/21/what-does-haskell-have-to-do-with-c/
17:51:33 <Kaidelong> (Haskell, Prolog, and Icon would probably make for a great course on the major programming paradigms, incidentally)
17:51:33 <Tjr> The builtin Mathematica language is probably on par with haskell, in terms of easiness
17:51:55 <k00mi> gcganley: haskell is very consistent and makes little compromise to aid usability. As a result just following the logic gets you quite far
17:52:12 <Kaidelong> Tjr: if we're thinking of the same Mathematica, they really aren't comparable, Mathematica is pretty complicated
17:53:01 <Tjr> Kaidelong: it has a lot of functions, and a lot fo config options for them, but the underlying language is really simple. there is only one data type, etc.
17:53:02 <Kaidelong> gcganley: there is a caveat in that most "haskell" programmers don't actually write haskell but write in haskell with extensions, which really can get quite complicated
17:53:18 <Kaidelong> also like lisp and C++ haskell libraries can basically make haskell into a totally different language
17:53:30 <Kaidelong> lens is an example
17:53:51 <gcganley> Kaidelong: like that clojure DSL for music?
17:54:03 <gcganley> Kaidelong: i forget what its called one sec
17:54:07 <Kaidelong> haskell has one of those too, trying to remember what it was called
17:54:20 <gcganley> Kaidelong: OVERTONE!
17:54:26 <gcganley> Kaidelone: i think...
17:54:28 <k00mi> Kaidelong: lens is probably unique in how far it bends haskell
17:54:47 <Kaidelong> Haskore
17:54:59 <k00mi> there are about a dozen music libraries in haskell
17:54:59 <benzrf> k00mi: haskell is light
17:55:05 <benzrf> of course lens bends it
17:55:10 <Tjr> what does lens /do/?
17:55:12 <gcganley> oh god lens is so much nope
17:55:12 <Kaidelong> Haskore was the big one
17:55:19 <benzrf> Tjr: cool shit
17:55:30 <Kaidelong> I think Euterpea is the successor to it
17:55:35 <gcganley> how scared should i be of monads?
17:55:40 <benzrf> gcganley: not very
17:55:44 <benzrf> concentrate on functors first
17:56:13 <Kaidelong> gcganley: I would say don't bother learning them at all, you only need to worry about what one is once you have to write your own monad instance
17:56:17 <Welkin> gcganley, monads are burritos
17:56:18 <benzrf> > over (_Just . traverse . _1) (+2) (Just [(3, "ok"), (5, "neat")]
17:56:18 <gcganley> well functors in my mind are the C++ functors lol how are they differnt in Haskell
17:56:19 <lambdabot>  <hint>:1:65:
17:56:19 <lambdabot>      parse error (possibly incorrect indentation or mismatched brackets)
17:56:22 <k00mi> gcganley: ignore lens until you're more than comfotrable with standard haskell
17:56:22 <benzrf> yo wut
17:56:24 <Kaidelong> even in that context it's enough to know the methods and their laws
17:56:25 <Tjr> gcganley: not at all. The difficulty isn't monads, it's the vast spectrum of possible examples. So take a look at several very differnet ones.
17:56:27 <benzrf> > over (_Just . traverse . _1) (+2) (Just [(3, "ok"), (5, "neat")])
17:56:28 <lambdabot>  Just [(5,"ok"),(7,"neat")]
17:56:30 <benzrf> Tjr: ^lens
17:56:42 <Welkin> gcganley, don't use comparisons, just learn everything with a blank mind
17:56:53 <Welkin> read the typeclassopedia and Learn You a Haskell
17:57:12 <gcganley> Welkin: god its like learning programming all over again...
17:57:13 <heatsink> gcganley: Functors are unrelated to C++ functors.  The etymology of those words is different.
17:57:21 <Kaidelong> gcganley: since you've been using clojure you ar eprobably familiar with interfaces, yes?
17:57:22 <k00mi> benzrf: what do you mean by "haskell is light" and how does anything about lens follow from that
17:57:31 <benzrf> k00mi: the jokes is that lenses bend light
17:57:32 <benzrf> :p
17:57:32 <gcganley> Kaidelong: yes I am
17:57:50 <k00mi> oh
17:58:01 <Kaidelong> Monad is along the same line as Java's "Enumerator"
17:58:07 <Tjr> benzrf: looks very ugly.
17:58:26 <benzrf> Tjr: your mom is ugly
17:58:27 <Tjr> there must be a cleaner way to extract component from tuples.
17:58:29 <Welkin> benzrf, they do not bend light
17:58:32 <Kaidelong> it's an interface that specifies a few methods that functions or built in language features can use
17:58:35 <Welkin> they reflect and refract
17:58:38 <Welkin> light does not bend
17:58:44 <benzrf> Welkin: well arent you pedantic
17:58:46 <Kaidelong> in haskell's case the special thing is do syntax
17:59:35 <Welkin> actually, that is not even true
17:59:39 <Kaidelong> do syntax + Monad is like foreach + Enumerator
17:59:42 <k00mi> Tjr: basically a lens is an accessor into a data structure, but the lens library generalized that concept a lot
17:59:48 <gcganley> when i look at samples it looks like dot syntax in math :/
17:59:49 <Welkin> they interact with atoms that give off new photons
17:59:49 <Axman6> wut
18:00:06 <Welkin> do it isn't the same photon "bouncing" off
18:00:10 <Welkin> so*
18:00:26 * Tjr sighs.
18:00:32 <Tjr> night everybody
18:00:44 <Welkin> morning Tjr
18:00:47 <Kaidelong> oh I mean Iterable, not Enumerator
18:00:51 <gcganley> Kaidelong: AH!
18:01:43 <k00mi> Kaidelong: that analogy is only true in a very limited way though
18:01:54 <k00mi> like all monad analogies
18:02:06 <benzrf> monads are not "like" stuff
18:02:09 <benzrf> they are just monads
18:02:10 <benzrf> dang
18:02:20 <benzrf> gcganley: do you know functors yet
18:02:23 <Axman6> gcganley: functions are things that look like 'f a' at the type level (F<A> in say C++ or Java) which you can take a function of tyoe a -> b (B g(A)) and create a 'f b' (F<B>): fmap :: (a -> b) -> f a -> f b, (roughly F<B> fmap<A,B>(B g(A), F<A>))
18:02:27 <Kaidelong> k00mi: I just mean that Monad is used int he same way to provide a language feature that's extensible
18:02:33 <Axman6> uh, functors even
18:02:39 * Axman6 just woke up
18:02:39 <Kaidelong> do syntax can be extended because it's just desugared to method calls
18:02:46 <gcganley> Kaidelong: I found learn me a haskell 2 days ago and im planning on reading it on my iPad inna bit... any other books/papers/websites I should read
18:02:59 <Kaidelong> just like foreach can be extended because it's just method calls
18:03:07 <Axman6> gcganley: make sure you do the exercises
18:03:33 <Axman6> Kaidelong: that's a terrible explanation of what monad(s) is/are
18:03:42 <k00mi> Kaidelong: yes, that's correct
18:03:52 <k00mi> Axman6: it's not an explanation of what monads are
18:06:41 <Kaidelong> gcganley: try implementing something, N-Queens is good
18:07:14 <Kaidelong> one neat thing you could try is implementing custommonad plus instances on newtypes to generalize different backtracking schemes
18:07:24 <Kaidelong> custom MonadPlus
18:08:07 <gcganley> lets start with learning the syntax hun
18:08:37 <Kaidelong> N-Queens is simple enough to get some syntax down
18:09:19 * hackagebot pipes-bytestring 2.1.0 - ByteString support for pipes  http://hackage.haskell.org/package/pipes-bytestring-2.1.0 (GabrielGonzalez)
18:10:02 <Kaidelong> 99 bottles of beer is another thing you can just jump into that only really cares about syntax, it doesn't require that much thinking about paradigm
18:10:13 <gcganley> i tried creating a chess solver when i was messing around in python :/
18:10:31 <Kaidelong> do you know rosetta code?
18:10:39 <gcganley> and i was going to do the stuff like fizz buzz and other math stuff on euler to get used to it
18:10:42 <Kaidelong> I think that's a great resource for learning a new language
18:12:14 <gcganley> i did alot of Euler problems in C++ because i was in absolute love with speed at the time
18:12:34 <Kaidelong> http://rosettacode.org/wiki/Keyboard_input/Obtain_a_Y_or_N_response#Haskell
18:15:20 <gcganley> is haskell do anything like clojure do? it looks like its used in the same way
18:15:41 <benzrf> gcganley: they don't think it be like it is but it do
18:16:20 <gcganley> benzrf: wat
18:16:32 <marchelzo_> Can someone give me a hint on how to implement <*> using <$> and (=<<)
18:16:47 <benzrf> marchelzo_: try using do notation
18:17:29 <marchelzo_> ok
18:17:30 <Kaidelong> gcganley: doesn't look like it, from what I understand, clojure do is translated to something like
18:18:08 <dwcook> marchelzo_: You don't even need (<$>) for that matter. (=<<) can be used to implement it.
18:18:19 <Kaidelong> do expr1 expr2 = ignore the result of expr1 but execute it, return the result of expr2
18:18:26 <gcganley> clojure do is the composing fo many arguments into a single form and returning the last expressions result as the final result
18:18:30 <Kaidelong> in haskell this wouldn't be useful
18:19:09 <benzrf> Kaidelong: that sounds like (>>) to me
18:19:19 <Kaidelong> benzrf: (>>) is subtly different
18:19:27 <benzrf> well i know what you mean
18:19:40 <gcganley> well things like let binding have implicit do's so that you can write the rest of a block inside the let block
18:19:53 <marchelzo_> Apparently I can't use do notation
18:19:59 <marchelzo_> return is not allowed
18:20:00 <Kaidelong> maybe there's an analogy here somewhere
18:20:32 <gcganley> someone in here has to be good at both haskell and clojure...
18:20:36 <dwcook> marchelzo_: Ah, if you can't use return then never mind what I said.
18:21:05 <ReinH> gcganley: bitemyapp might be able to help
18:21:49 <gcganley> is there a special way to summon bitemyapp?
18:21:49 <marchelzo_> dwcook: If I could use do, how would I implement it?
18:21:57 <gcganley> do i have to sacrifice a goat?
18:22:08 <dwcook> marchelzo_: I'm not the one who talked about do. But are you familiar with the do translation rules?
18:22:46 <marchelzo_> dwcook: Sorry I meant if I could use return. And not really.
18:22:55 <Kaidelong> gcganley: do {x <- y; a <- b; c; d x a} is the same as do {x <- y; a <- b; _ <- c; d x a} is the same as y >>= \x -> b >>= \a -> c >>= \_ -> d x a
18:23:00 <Kaidelong> this is how do works in haskell
18:23:17 <dwcook> marchelzo_: fmap f x = x >>= return . f
18:23:25 <ajcoppa> marchelzo_: i walked someone through it earlier while you were in the channel
18:23:32 <dwcook> @src liftM
18:23:32 <lambdabot> liftM f m1 = do { x1 <- m1; return (f x1) }
18:23:36 <Kaidelong> it "binds" results on the right of a <- to bindings on the left
18:23:36 <ajcoppa> if you have logging, that may help
18:23:45 <Kaidelong> and in any subsequent part of the do expression, they're available
18:23:48 <marchelzo_> ajcoppa: Yeah I know -.- I was too busy trying to solve that filtering one
18:23:50 <gcganley> OH!
18:23:52 <gcganley> i get it
18:23:53 <gcganley> i think
18:23:59 <gcganley> in a sorta primitive way
18:23:59 <ajcoppa> no worries
18:24:04 <marchelzo_> I'll see if I can find it
18:24:08 <ajcoppa> i can go through it again
18:24:28 <ajcoppa> step 1: write out the types of the relevant functions
18:24:36 <ajcoppa> <$>, =<<, the arguments to <*>
18:24:42 <Kaidelong> gcganley: what exactly this means depends on how bind is defined, it's context dependent, just like foreach on one tree type might be different from foreach on another tree type
18:25:32 <Kaidelong> > do { succeededA = Just 5; succeededB = Just 6; failedC = Nothing; return (a+b+c) }
18:25:33 <lambdabot>  <hint>:1:17: parse error on input ‚Äò=‚Äô
18:25:49 <Kaidelong> > do { succeededA <- Just 5; succeededB <- Just 6; failedC <- Nothing; return (a+b+c) }
18:25:50 <lambdabot>  Nothing
18:25:51 <marchelzo_> ok so (<$>) :: Functor f => (a -> b) -> (f a) ->  (f b)
18:25:52 <gcganley> Kaidelong: that makes alot of sence
18:26:01 <Kaidelong> that's the maybe monad
18:26:07 <benzrf> marchelzo_: (<$>) is just fmap
18:26:09 <gcganley> Kaidelong: *sense
18:26:13 <Kaidelong> it short circuits the whole computation when any part of it fails
18:26:18 <marchelzo_> benzrf: I am aware
18:26:58 <marchelzo_> ajcoppa: should I just take note of them locally or should I write them in irc? I don't want to spam
18:27:18 <dwcook> marchelzo_: Try a paste site, such as that noted in the topic.
18:27:20 <ajcoppa> locally is fine
18:27:22 <ajcoppa> just have them at hand
18:27:24 <Kaidelong> now with the list monad you can do things like
18:27:24 <dwcook> or locally
18:27:27 <marchelzo_> ok
18:27:34 <gcganley> Kaidelong: thats really useful...
18:28:10 <Kaidelong> getIdentityMatrix n = do { x <- [1..n]; y <- [1..n]; return (if (x == y) then 1 else 0) }
18:28:29 <dwcook> gcganley: Another cool Maybe instance is for Alternative/MonadPlus, where you keep trying computations until one succeeds.
18:28:38 <ajcoppa> marchelzo_: afk a few mins, but start with that step
18:28:44 <Kaidelong> > \n -> do { x <- [1..n]; y <- [1..n]; return (if (x == y) then 1 else 0) } 4
18:28:45 <lambdabot>  <hint>:1:75: parse error on input ‚Äò4‚Äô
18:28:48 <dwcook> > Nothing <|> Nothing <|> Just "foo" <|> Just "bar"
18:28:49 <marchelzo_> ajcoppa: ok, working on it
18:28:49 <lambdabot>  Just "foo"
18:28:58 <Kaidelong> > (\n -> do { x <- [1..n]; y <- [1..n]; return (if (x == y) then 1 else 0) }) 4
18:29:00 <lambdabot>  [1,0,0,0,0,1,0,0,0,0,1,0,0,0,0,1]
18:29:25 <gcganley> Kaidelong: one thing ive noticed about haskell is that mathmatical equations translate well into it
18:29:38 <Kaidelong> gcganley: this is a payoff for being simple
18:29:46 <Kaidelong> lisp and prolog have some similar advantages
18:30:01 <Kaidelong> with algebra and propositional laogic respectively
18:30:46 <sfdsfds> Is there a language pragma that allows to specify value constructors in a type signature?  For instance, if I have data Foobar = Foo | Bar, I want to be able to write (made-up syntax) foo :: Foobar(Foo) -> String, so that foo Bar won't even typecheck.
18:31:07 <ReinH> sfdsfds: sounds a bit like GADTs
18:31:33 <sfdsfds> I'll take a look.
18:31:36 <ReinH> Kaidelong: Haskell works just fine with algebra and logic as well :p
18:31:44 <ReinH> Haskell is a very algebraic langauge
18:31:44 <gcganley> Kaidelong: yeah but lisp is s-expression so its all garbled but haskell is infix so it makes alot more sense
18:31:52 <dwcook> I've heard typeclasses referred to as type-level Prolog
18:32:24 <Iceland_jack> sfdsfds: You can use a GADT or a phantom type
18:33:29 <Kaidelong> ReinH: yeah, that's why I like haskell
18:33:44 <sfdsfds> Ah, I forgot to mention that the type is defined in a library, so I can't change it.  I guess I could introduce a wrapper, but I'm not sure how to do so in a smart way.
18:33:46 <sfdsfds> Ideas?
18:33:46 <Kaidelong> although I think since lisp has unrestricted template metaprogramming
18:33:54 <ReinH> sfdsfds: my thought is that you're stuck :D
18:33:55 <Kaidelong> it can in theory encode more different kinds of algebra
18:34:13 <Kaidelong> including more ones that you didn't intend to encode
18:34:33 <ReinH> While simultaneously being unable to reason effectively about any of them :D
18:35:03 <Kaidelong> I need to go cook dinner now though
18:35:20 <gcganley> Kaidelong: whats for dinner?
18:35:51 <dwcook> sfdsfds: What you're asking for is essentially a dependent type. GHC Haskell has some features reminiscent of DTs but doesn't have their fully power. This is one of those cases where it seems to be deficient.
18:35:55 <Kaidelong> I made mock kalau pork the other day, so I'm going to put it in quesadillas
18:36:05 <sfdsfds> ReinH: I can always try 'foo Foo = "foo"; foo _ = error "not foo"', but I want compile-time guarantees.
18:36:22 <dwcook> s/fully/full/
18:36:27 <gcganley> Kaidelong: sounds bomb
18:36:33 <ReinH> Kaidelong: oh, that sounds deliciously non-traditional
18:36:35 <Kaidelong> dwcook: since he wants to check against a constructor, isn't GADTs enough?
18:36:43 <gcganley> dwcook: i thought it was s/fully/full/g
18:36:46 <ReinH> Kaidelong: how did you do the pork?
18:36:54 <dwcook> Kaidelong: If they had control of the definition of the type in question. I think otherwise no.
18:37:02 <Kaidelong> ReinH: roasted it with soy sauce, liquid smoke, garlic, and ginger
18:37:06 <Iceland_jack> dwcook: You can wrap it
18:37:09 <dwcook> gcganley: No, I made the mistake once.
18:37:11 <ReinH> Kaidelong: neat :D
18:37:17 <Welkin> liquid smoke?
18:37:18 <marchelzo_> gcganley: omitting the g replaces only one instance
18:37:26 <Welkin> that is just too odd tasting for me
18:37:31 <ReinH> dwcook: I'm pretty sure it's full.
18:37:34 <Welkin> I've had it in chocolate
18:37:35 <dwcook> Iceland_jack: Explain.
18:37:44 <dwcook> ReinH: ‚Ä¶ yes?
18:37:44 <Kaidelong> Welkin: you just try not to use too much of it
18:37:49 <Kaidelong> but this is off topic and I need to go
18:37:53 <gcganley> dwcook: oh... i used to use vim until i got into emacs because lisp
18:37:59 <ReinH> It's "fully fledged", but it's "full power"
18:38:12 <dwcook> ReinH: Thus the s/fully/full/ I wrote.
18:38:22 <dwcook> "fully power" doesn't make sense. I was thinking "full power" but typo'd.
18:38:24 <ReinH> dwcook: Oh you corrected yourself.
18:38:28 <ReinH> dwcook: then we agree.
18:38:31 <dwcook> Yep.
18:38:33 <ReinH> I just missed that part.
18:38:38 <dwcook> No worries.
18:38:55 <Iceland_jack> dwcook: You can take a datatype and make an annotated newtype wrapping it that adds more checks
18:39:21 <dwcook> Iceland_jack: Can you give an example? I can imagine turning a GADT into a regular ADT but not vice versa.
18:39:27 <ajcoppa> marchelzo_: got those 4 things written?
18:39:31 <gcganley> i really want a burrito now because of that monad comment...
18:39:44 <dwcook> gcganley: I suppose you want to go into space too?
18:39:51 <ajcoppa> in general, writing out the types of relevant pieces is a great way to start, btw
18:39:53 <dwcook> Because monads are space suits, apparently
18:39:59 <gcganley> dwcook: SPAAAAACE
18:40:04 <marchelzo_> ajcoppa: yea
18:40:32 <dwcook> gcganley: Is that a Portal 2 reference?
18:40:40 <gcganley> dwcook: of course!
18:41:02 <dwcook> Okay. I just wasn't sure since I played the Spanish version where they said "ESPACIOOOOO" instead. :P
18:41:17 <gcganley> dwcook: wat
18:41:23 <Iceland_jack> dwcook: 'newtype BoundArray (n :: Nat) a = BA [a]' is a classic examplc
18:41:26 <gcganley> dwcook: i need a sound byte!
18:41:28 <Iceland_jack> need to brb though
18:42:09 <dwcook> gcganley: http://youtu.be/VbaFEf9F5z0
18:42:47 <ajcoppa> marchelzo_: so. we need to get to an f b somehow. the only way we have to get to an f b is to figure out how to run the (a -> b) that we have, right?
18:42:54 <ajcoppa> but it's wrapped inside an f
18:43:11 <marchelzo_> exactly
18:43:42 <ajcoppa> let's pretend for a second that we could get access to the inner (a -> b) value
18:44:01 <ajcoppa> if we had an (a -> b), what would we do with it, given the other types you have available?
18:44:11 <gipp> so hmatrix just added statically checked dimensions, and I'm trying to wrap my head around using it. The interface is still kinda limited, so I'm rolling some of my own functions, and I'm just trying to return those dimensions as a value. If I have some data L :: Nat -> Nat -> *, how do I "get at" the fromSing value of those Nats in functions on L?
18:44:32 <marchelzo_> we would fmap it on our (f a)
18:44:44 <ajcoppa> yep
18:45:36 <ajcoppa> so, how do we get inside the f to the (a -> b)?
18:46:10 <marchelzo_> I don't know. I'm guessing we're going to use bind somehow.
18:46:42 <ajcoppa> sounds like a decent enough bet. let's look at the type sig of bind together -- paste it in here?
18:46:53 <marchelzo_> (=<<) :: Bind f => (a -> f b) -> (f a) -> (f b)
18:47:05 <Welkin> that is reverse bind
18:47:11 <marchelzo_> yeah
18:47:12 <Welkin> :t (>>=)
18:47:13 <lambdabot> Monad m => m a -> (a -> m b) -> m b
18:47:20 <ajcoppa> yep, that's what i meant :) we're going through a problem in the NICTA course
18:47:21 <marchelzo_> This NICTA course uses this as bind
18:47:26 <Welkin> oh
18:47:28 <Welkin> okay
18:47:31 <ajcoppa> marchelzo_: so if we try to understand what bind does
18:48:16 <ajcoppa> we give it an f a and an (a -> f b). inside the (a -> f b), we get to access our a without the f wrapped around it
18:48:49 <marchelzo_> ahh
18:50:36 <ajcoppa> the behavior of unwrapping f, or applying f's effect, is done in each monad's instance for bind
18:51:26 <dwcook> The "unwrapping", if there is indeed any to speak of, doesn't have to happen there
18:51:43 <dwcook> For example, in the case of IO, we can't use the function given to (>>=) until the I/O system gets its hands on it.
18:52:36 <dwcook> And for free monads the "unwrapping" happens in the interpreter, if you run the monadic value through one.
18:53:25 <dwcook> (An interpreter being something like (Functor f, Monad m) => Free f a -> m a or equivalent)
18:53:28 <Axman6> :t (=<<) `asAppliedTo` Nothing
18:53:28 <lambdabot>     Couldn't match expected type ‚Äòa -> m b‚Äô with actual type ‚ÄòMaybe a0‚Äô
18:53:29 <lambdabot>     In the second argument of ‚ÄòasAppliedTo‚Äô, namely ‚ÄòNothing‚Äô
18:53:29 <lambdabot>     In the expression: (=<<) `asAppliedTo` Nothing
18:53:44 <Axman6> :t (>>=) `asAppliedTo` Nothing
18:53:45 <lambdabot> Maybe a -> (a -> Maybe b) -> Maybe b
18:55:02 <Axman6> :t (>>=) `asAppliedTo` []
18:55:03 <lambdabot> [a] -> (a -> [b]) -> [b]
18:55:16 <Axman6> :t (>>=) `asAppliedTo` (Left "hello")
18:55:17 <lambdabot> Either [Char] a -> (a -> Either [Char] b) -> Either [Char] b
18:55:51 <fread2282> :o
18:55:58 <fread2282> :t (>>=) `asAppliedTo` (Right "hello")
18:55:59 <lambdabot> Either a [Char] -> ([Char] -> Either a b) -> Either a b
18:56:07 <fread2282> oh
18:57:22 <marchelzo_> ajcoppa: whew. I got it.
18:57:30 <marchelzo_> (<*>) function y = (\f -> f <$> y) =<< function
18:57:50 <marchelzo_> i feel like y is a terrible name there
18:58:33 <dwcook> I'm more concerned about the verbosity of writing function :P
18:58:49 <marchelzo_> I had f but then I wanted to use f in the lambda
18:58:58 <dwcook> s/concerned about/distracted by/
18:59:02 <ajcoppa> marchelzo_: nice!
18:59:04 <dwcook> Use g or f'
18:59:26 <marchelzo_> ah yeah. I'll change it. But the use of y doesn't tell you that y is type (f a)
18:59:33 <ajcoppa> instead of \f -> f <$> y, you could write <$> y
18:59:50 <lfairy> (<$> y) -- sections need parens
18:59:53 <dwcook> marchelzo_: Generally you already know that from the type of (<*>)
19:00:21 <marchelzo_> dwcook: Ok. So calling that just something like x or y is generally acceptable?
19:00:53 <dwcook> marchelzo_: Yes, when you're not otherwise providing more information than is covered by the type.
19:01:06 <lfairy> marchelzo_: m seems to be common
19:01:09 <dwcook> You need to know the types anyway.
19:01:10 <ajcoppa> one more small thing: instead of (<*>) function y = ..., you can write function <*> y = ...
19:02:04 <marchelzo_> oh yeah
19:02:11 <dwcook> For example, there's a certain combinator, I forget its name, let's call it bracket :: (Alternative f) => f a -> f b -> f c -> f c. From the type it's not immediately obvious how you're using the first two parameters
19:02:25 <marchelzo_> it was already written as (<*>) = error "todo" so i didnt think to change it
19:02:27 <dwcook> So in the definition you might write bracket open close x = ‚Ä¶
19:02:35 <ajcoppa> marchelzo_: yep, i did the same thing. no worries
19:02:45 <dwcook> Sorry, that doesn't require Alternative, just Applicative
19:03:20 <marchelzo_> I haven't encountered Alternative yet
19:03:30 <Welkin> :t <|>
19:03:31 <lambdabot> parse error on input ‚Äò<|>‚Äô
19:03:36 <Welkin> :t (<|>)
19:03:37 <lambdabot> Alternative f => f a -> f a -> f a
19:04:20 <Eduard_Munteanu> marchelzo_: do you know what a monoid is?
19:04:53 <marchelzo_> Eduard_Munteanu: Not exactly. I watched a youtube video explaining it but I'm not sure how correct it was.
19:05:11 <Eduard_Munteanu> Nevermind then.
19:06:52 <Welkin> marchelzo_, I recommend the Typeclassopedia and Learn You a Haskell
19:07:04 <Welkin> they have very good explanations
19:07:36 <marchelzo_> I have read quite a bit of LYAH, but I haven't read much about Monads and beyond yet. I'll check out typeclassopedia as well. thanks
19:09:48 <dwcook> Just to be clear: monoids and monads are different. :) Monoids I'd consider conceptually much easier to grasp
19:10:36 <Welkin> monads are not hard to understand either
19:10:43 <dwcook> Sure, didn't say they were
19:11:25 <dwcook> But if you consider the mathematical terms, monoids require less background (at least going by what you are likely to encounter first); and in terms of Haskell, Monoid has fewer methods to talk about
19:11:43 <Eduard_Munteanu> Monoids are pretty trivial.
19:12:08 <benzrf> monoids are so monoidal
19:12:09 <benzrf> it's amazing
19:12:19 <benzrf> wow
19:12:20 <dwcook> ({e}, id) is pretty trivial
19:12:29 <dwcook> :)
19:12:37 <dwcook> Wait woops
19:12:43 <dwcook> not id but rather const id
19:12:45 <benzrf> it seems to me that in haskell monoids are mostly used for default values and mconcat
19:13:09 <joelteon> yeah, that's exactly what they're used for
19:13:33 <dwcook> But note that "default value" has a specific and useful meaning here
19:13:49 <dwcook> It's the value that "does nothing" when mconcat is applied to it and another argument
19:14:01 <Welkin> mconcat or mappend?
19:14:07 <dwcook> mempty `mconcat` x = x = x `mconcat` mempty
19:14:18 <dwcook> Whichever is the monoid operation, I forget
19:14:34 <Welkin> :t mappend
19:14:35 <lambdabot> Monoid a => a -> a -> a
19:14:38 <dwcook> That one
19:14:38 <Welkin> :t mconcat
19:14:39 <lambdabot> Monoid a => [a] -> a
19:15:15 <dwcook> mconcat is basically the free monoid interpreter, to complicate things too much :P
19:18:55 <Guest83972> Greetings, Haskellers!
19:19:09 <dwcook> o/
19:21:25 <c74d> How much storage space does GHC take to build?
19:21:29 <a_> Greetings, Haskellers!
19:21:42 <a_> Has anyone ever tried to add vi-like line editing commands to ghci?
19:22:07 <Eduard_Munteanu> a_: hi, how do you mean?
19:22:59 <a_> Eduard_Munteanu: Having a separate insert and command modes, allowing for faster editing.  For example, modern shells have a vi mode you can enter by pressing 'Esc'
19:23:41 <Eduard_Munteanu> a_: you might be able to get that effect in Emacs with evil + haskell-mode
19:25:53 <a_> Eduard_Munteanu: I'm sure there are separate packages for vim that create a REPL with the haskell interperter, but I was  curious if anyone had build directly into ghci.
19:31:27 <dolio> ghci already does vi line editing.
19:31:43 <dolio> Put 'editMode: Vi' in ~/.haskeline
19:32:17 <Eduard_Munteanu> Cool.
19:32:32 <Eduard_Munteanu> They left, unfortunately.
19:32:41 <dolio> Ah well.
19:46:43 <mzero> c74d: my ghc build directory is about 2.5G
19:54:13 <rola> > :t (<-)
19:54:14 <lambdabot>  <hint>:1:1: parse error on input ‚Äò:‚Äô
19:54:32 <rola> :t (<-)
19:54:33 <lambdabot> parse error on input ‚Äò<-‚Äô
19:54:45 <Eduard_Munteanu> rola: it's not an operator, it's builtin syntax
19:55:11 <rola> Eduard_Munteanu ‚Üê I see
20:00:37 <heatsink> > (:t) ones
20:00:39 <lambdabot>  Ambiguous occurrence ‚Äòt‚Äô
20:00:39 <lambdabot>  It could refer to either ‚ÄòL.t‚Äô, defined at L.hs:150:1
20:00:39 <lambdabot>                        or ‚ÄòDebug.SimpleReflect.Vars.t‚Äô,
20:00:39 <lambdabot>                           imported from ‚ÄòDebug.SimpleReflect‚Äô at L.hs:112:1-26
20:00:39 <lambdabot>                           (and originally defined in ‚Äòsimple-reflect-0.3.2:De...
20:05:10 <mzero> >>= Gothenburg -- reg'd for Haskell Symposium and Haskell Implementors Workshop
20:10:35 <heatsink> The GHC user manual says that ghc --make will build a multi-module Haskell program
20:10:40 <heatsink> however, cabal uses --make to build libraries
20:10:53 <heatsink> How does GHC decide whether to build a program when --make is used?
20:11:59 <minopret> Any commenters for my Coq difficulty? I apologize that it's off topic and I already mentioned it on the coq channel http://lpaste.net/106022
20:13:20 <lfairy> I really like the name, but can't comment on the language itself
20:15:02 <Eduard_Munteanu> Everybody likes Coq. :P
20:15:05 <minopret> um, Coq adds life?
20:15:16 <heatsink> You won't know if you like Coq until you try it.
20:16:38 <minopret> yeah, I rhyme it with "Coke" or "caulk" because otherwise it's a conversation stopper
20:17:32 <heatsink> Where are you from?  I'm subject to the cot-caught merger.
20:18:11 <minopret> I speak mid-Atlantic USA and my parents are both from upper midwest USA
20:18:42 <dsturnbull> the best part is saying it like it's meant to be pronounced
20:18:55 <dsturnbull> coqmaster contest at fp-syd a few months ago was amazing
20:18:56 <heatsink> I'm from the west coast.
20:19:17 <Axman6> you mean the Coq fight? I'm sad I missed it :(
20:19:18 <minopret> I rhyme Haskell with Pascal. NO just kidding, I rhyme it with the Hebrew word Haskel meaning "educate". NO just kidding again
20:20:06 <minopret> coq au vin avec dependent types
20:22:28 <ninja_code> let's talk about force. (1) force does NOT mean we immediately evalute it. (2) force merely means that if we get "WNHF" of a force, then the entire thing is evaluted. Are (1) and (2) both tree? (context: reading parallel + concurent haskell)
20:24:11 <minopret> tch√ºss y'all
20:24:24 <Eduard_Munteanu> ninja_code: yeah, force turns subsequent seq into deepseq
20:25:27 <mzero> saddly, I hear people rhyme Haskell with Pascal all the time...
20:25:40 <ninja_code> Eduard_Munteanu: ah, I like that explaination
20:26:36 <Eduard_Munteanu> ninja_code: IIRC, its just  force x = x `deepseq` x
20:27:37 <Eduard_Munteanu> ninja_code: so  force x `seq` y === x `deepseq` x `seq` y === x `deepseq` y
20:30:30 <ninja_code> Eduard_Munteanu: page 29/30 of the text seems to agree with you.
21:16:44 <mirpa> I 'import A (B,C); import qualified A as D' and I get error that B,C are not in scope "...perhaps you meant D.B, D.C" - what am I doing wrong?
21:23:12 <mirpa> http://lpaste.net/106028
21:23:36 <ReinH> mirpa: perhaps you mean import a (B(..),C(..)) to import the constructors
21:24:58 <mirpa> ReinH: aaa - indeed, thank you
21:25:02 <ReinH> mirpa: np
21:25:10 <mirpa> :-)
21:25:57 * Lutin` sighs
21:28:04 <knapper_tech> how do I run warp as a daemon in systemd?
21:28:05 <knapper_tech> does not like systemctl not returning
21:29:01 <Axman6> #yesod might be a better place to ask
21:34:35 <rien> I need some help with cabal sandboxes
21:35:25 <rien> I have this one file Main.hs that imports Network.HTTP.Conduit.Browser
21:35:25 <rien> and it's been giving me a lot of headache
21:39:07 <mirpa> rien: What is the problem?
22:06:32 <ninja_code> if I don't need sql, what's a good database to use with haskell?
22:06:34 <ninja_code> (I do want consistency; not eventual consistency though)
22:07:22 <haasn> ninja_code: It really depends on the purpose
22:07:27 <haasn> And scope
22:07:39 <haasn> If you only need to store a handful of values, there are some good non-database approaches
22:08:04 <ninja_code> http://vimeo.com/27192476
22:08:05 <ninja_code> looksinteresting
22:08:08 <ninja_code> but riak is eventually consistent
22:08:28 <ninja_code> is this basically the flat file approach?
22:08:32 <haasn> Otherwise, for very large data sets I think your best bet is honestly to outsource to some established database system and find a good way to interface with it using Haskell. SQL is not that much of a crime if you want a relational store; especially if you're not writing the SQL yourself but using a Haskell abstraction on top of it
22:09:03 <haasn> Thanks for the link, that looks interesting
22:09:03 <ninja_code> yeah
22:09:04 <ninja_code> maybe the question I should ahve asked is
22:09:08 <ninja_code> what's a good binding for AWS / Haskell ?
22:14:33 <ReinH> ninja_code: is what the flat file approach?
23:08:13 <xpika> whats an efficient way to calcualate if a list is longer than 8 elements ?
23:09:56 <AshyIsMe> pattern matching?
23:10:51 <AshyIsMe> something along these lines? http://stackoverflow.com/a/3851126
23:11:23 <Total_1mmersion> xpika, (not . null) (drop 8)
23:13:03 <Total_1mmersion> oops, forgot to compose: (not . null) . (drop 8)
23:13:51 <Total_1mmersion> and some parentheses are redundant
23:14:16 <Total_1mmersion> > (not . null . drop 8) [1 .. 8]
23:14:18 <lambdabot>  False
23:14:20 <Total_1mmersion> > (not . null . drop 8) [1 .. 9]
23:14:21 <lambdabot>  True
23:27:52 <xpika> Total_1mmersion: thanks
23:29:26 <lfairy> @type ((not . null) .) . drop
23:29:28 <lambdabot> Int -> [a] -> Bool
23:29:33 <lfairy> ha
23:41:51 <McSmithy> pw forgotten help?
23:44:47 <Axman6> what?
23:44:47 <relrod> > 1
23:44:47 * relrod thinks lambdabot died or there's about to be a netsplit :(
23:44:49 <lambdabot>  1
23:44:53 <relrod> or it's just laggy :)
23:55:17 <ninja_code> what type of lawyser
23:55:17 <ninja_code> should I talk to
23:55:19 <ninja_code> to draft up a release form
23:55:33 <xpika> is there a version of takeWhile which compares the rest of the whole pattern?
23:55:42 <ninja_code> something of the form "the yoga instructor produes the video; and I, in an act of highway robbery, take 50% of th eprofits for hosting the videos + collecting the sales"
23:55:47 <ninja_code> hmm, wrong channel
23:57:20 <xpika> sudo code : takeWhileRest (not . all odd . take 3) [1,2,4,2,5,2,5,3,1,4,5]
23:57:52 <xpika> => [1,2,4,2,5,2]
