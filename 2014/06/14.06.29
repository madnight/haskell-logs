00:00:26 <MP2E> interpolation can be a huge pain in the ass when your programming model is 100% based on a timed event, though :P
00:00:52 <MP2E> Take Doom, implementing interpolation for 60FPS video requires a lot of annoying little tricks. Usually involving subtle floating point representation bugs
00:00:52 <kazagistar> basically, their model is discrete, but they are very very focused on altering typesteps by "attention" factors
00:02:07 <kazagistar> they update small objects rolling down hills far out of sight ever half min or something, but when you are pointing your sniper rifle at something it sends like half of its availible traffic in updates (I might be making the details up)
00:02:58 <kazagistar> they also mix in animation tricks like sliding vehicles sideways to fix positional problems and launching bullets with big explosions to hide their appearing in front of the gun
00:03:22 <WombleWay> trying to peak at 20 veiwers for this geek chat...can you guys join please https://www.youtube.com/watch?v=ySivN4fMIXw
00:05:23 <kazagistar> only thing I can find is this presentation, maybe I misremembered the format: http://www.gdcvault.com/play/1014345/I-Shot-You-First-Networking
00:05:45 <MP2E> I recall reading a halo paper so it was definitely something
00:05:51 <MP2E> I dunno either though, I've read so many papers about various stuff
00:05:52 <MP2E> heh
00:05:58 <MP2E> wait
00:06:00 <MP2E> this looks right
00:06:08 <jle`> kazagistar: thanks :)
00:06:10 <MP2E> I thought I read a paper though
00:06:14 <MP2E> maybe it was a summary
00:06:17 <jle`> MP2E: i remember a halo paper about the matchmaking process i think
00:06:42 <kazagistar> "the goal of networking is to help players sustain the illusion or belief that they are playing a fun game togeather"
00:06:50 <jle`> haha
00:07:16 <jle`> with halo that's no small feat
00:07:25 <MP2E> hahaha
00:07:27 <jle`> (badum tssh)
00:07:43 <kazagistar> ouch burrrrrn
00:08:17 <kazagistar> basically, they start with: "we cannot do deterministic" and "we cannot do guarenteed" and even "we cannot do consistant" and then they make it happen anyways
00:08:23 * hackagebot eros 0.2.0.1 - A text censorship library.  http://hackage.haskell.org/package/eros-0.2.0.1 (pharpend)
00:08:23 * hackagebot tianbar 0.4.5.0 - A desktop bar based on WebKit  http://hackage.haskell.org/package/tianbar-0.4.5.0 (AlexeyKotlyarov)
00:08:26 <jle`> haha
00:08:49 <kazagistar> make the "illusion" work, not the rest
00:09:32 <kazagistar> everyone basically has their own version and is struggling to sync with the others as much as possible in the least annoying way possible
00:11:14 <kazagistar> apparently, the heavily lean on this paper: http://www.pingz.com/wordpress/wp-content/uploads/2009/11/tribes_networking_model.pdf
00:12:17 <mayski_> jesus christ that typesetting
00:12:29 <kazagistar> yeah, that ain't latex
00:12:42 <kazagistar> or it is but just done terribly, hard to tell
00:13:14 <Welkin> how many of you are game developers?
00:13:28 <Welkin> either professionally or as a hobby
00:13:44 <ReinH> good stuff here btw http://gafferongames.com/networking-for-game-programmers/
00:13:51 <ReinH> jle`: ^
00:14:03 <jle`> thank you mr H
00:14:38 <kazagistar> I did a little bit, but my biggest game was just a fun weeklong hackathon with a few friends on Occulus + C# + Unity
00:18:31 <jle`> i've always had an amateur game developer streak in me since when i started programming
00:20:22 <MP2E> My programming tends to revolve around games in some form :)
00:20:30 <MP2E> Emulators are what got me interested in programming in the first place
00:20:51 <MP2E> I'm planning on making some sort of android game with haskell, as to what, I'm not sure yet :S
00:21:27 <Welkin> haskell makes me want to create more games
00:21:40 <Welkin> I've only ever used things like rpg maker and pygame
00:21:44 <Welkin> they were unsatisfying
00:22:21 <kazagistar> I want to make worlds which happen to be games, which is why stuff like FRP is interesting to me right now
00:22:58 <jle`> the world is wide open for you
00:23:00 <jle`> :)
00:23:04 <jle`> that's one of the best things about haskell i think
00:23:23 <jle`> is that you can be a part of inventing/figuring out how things work
00:23:37 <jle`> for future generations
00:23:37 <simcity2000> I feel like the statefulness of most game programming approaches would be difficult to work around in Haskell, but I may be wrong
00:23:43 <partycoder> ehm
00:24:04 <partycoder> there's science, engineering and technology
00:24:12 <kazagistar> its interesting to observe things like how various minecraft mods deal with state... there is a lot of focus in the better designed ones on mechanics that allow something like FRP where you can skip a lot of intermediate state
00:26:25 <kazagistar> even worse is if you do cellular autometa of something like atmospheric simulation, as in one of my favorite games Space Station 13... it is fast as long as the state is globaly reasonably stable, but transitons cause problems because cellular autometa are an inherently stateful approach that does not allow great optmization
00:28:20 * hackagebot dwarfadt 0.3.0.1 - High-level wrapper around the dwarf library  http://hackage.haskell.org/package/dwarfadt-0.3.0.1 (EyalLotem)
00:29:27 <Cale> kazagistar: Cellular automata are embarrassingly parallel
00:29:44 <Cale> also, they tend to be pure computations?
00:30:59 <kazagistar> Cale: thats true, but for a game, I am not sure how that is useful for performance problems, since we dont have that many cores availible... I guess it might be interesting to consider the game offloading part of the autometa to each player?
00:31:51 <kazagistar> maybe with redundancy to lower the chance of cheating
00:33:04 <partycoder> ehm
00:33:37 <partycoder> do you need to share state across multiple players?
00:34:06 <kazagistar> partycoder: not sure I understand
00:34:17 <partycoder> you say you have a server
00:34:25 <partycoder> and clients
00:34:56 <partycoder> server has some state, that is shared/synchronized with clients
00:35:05 <partycoder> something like that, right?
00:36:02 <kazagistar> traditionally, although you could imagine some level of peer to peer might be used as an alternative
00:37:24 <kazagistar> partycoder: are you asking why the clients need full state?
00:38:09 <partycoder> just trying to determine
00:38:21 * hackagebot haskell-compression 0.1 -   http://hackage.haskell.org/package/haskell-compression-0.1 (AlanHawkins)
00:38:23 <kazagistar> partycoder: usually, because maintaining state synchronization smoothly is better then batch updating, though in competative games there is plenty of hiding
00:38:23 * hackagebot boolean-list 0.1.0.0 - convert numbers to binary coded lists  http://hackage.haskell.org/package/boolean-list-0.1.0.0 (AlanHawkins)
00:38:25 <partycoder> how much authority you need in your server
00:40:09 <kazagistar> partycoder: what you want to be careful if is if a player has state hidden from them, and then RIGHT as they turn the corner they lag and the state information they are presented with is blatantly false
00:40:19 <kazagistar> it makes it hard to... tastefully reconcile
00:42:12 <kazagistar> in League of Legends, they used to be very lazy in sending state updates about off-camera data, but that means that clicking the camera to a different map location would sometimes mean people would randomly slide sideways for a second
00:43:16 <kazagistar> they also have issues with projectiles fired from hidden locations, because it might be almost on top of you before you recieve the data and can render it
00:43:21 * hackagebot haskell-compression 0.1.1 -   http://hackage.haskell.org/package/haskell-compression-0.1.1 (AlanHawkins)
00:43:40 <kazagistar> (they have improved on both these counts eventually)
00:44:19 <partycoder> well there's also a security aspect of it
00:45:11 <gamegoblin> @pl \(a,b) -> (b,a)
00:45:12 <lambdabot> uncurry (flip (,))
00:45:34 <partycoder> well i think this diverted a bit from the main topic of this room (haskell)
00:45:47 <Iceland_jack> gamegoblin: swap
00:45:49 <Iceland_jack> @ty swap
00:45:50 <lambdabot> (a, b) -> (b, a)
00:45:51 <Iceland_jack> from Data.Tuple
00:46:13 <gamegoblin> Iceland_jack: Thanks, I was hoping pl would come up with it for me — I figured there was a prelude function for it
00:46:33 <Iceland_jack> pl isn't really helpful for library search
00:46:40 <gamegoblin> Sometimes it manages ;)
00:46:45 <Iceland_jack> something like
00:46:45 <Iceland_jack> @hoogle (a, b) -> (b, a)
00:46:45 <Iceland_jack> would be better
00:46:46 <lambdabot> Data.Tuple swap :: (a, b) -> (b, a)
00:46:47 <lambdabot> Data.Graph.Inductive.Query.Monad (><) :: (a -> b) -> (c -> d) -> (a, c) -> (b, d)
00:46:47 <lambdabot> Data.Graph.Inductive.Query.Monad mapSnd :: (a -> b) -> (c, a) -> (c, b)
00:48:03 <Iceland_jack> 'swap' is actually a rare case when the implemention and the type coincide :)
00:48:22 * hackagebot devil 0.1.1.0 - A small tool to make it easier to update program managed by Angel.  http://hackage.haskell.org/package/devil-0.1.1.0 (luanzhu)
00:48:31 <jle`> just :: a -> Maybe a
00:48:37 <jle`> er
00:48:42 <jle`> ident :: a -> Identity a
00:48:44 <jle`> ident a = Identity a
00:49:10 <Iceland_jack> also
00:49:11 <Iceland_jack>     id :: a -> a
00:49:11 <Iceland_jack>     id =\ a -> a
00:49:16 <gamegoblin> @pl \a b -> mod (a+b) n
00:49:16 <lambdabot> flip flip n . (mod .) . (+)
00:49:21 <gamegoblin> I love fooling with pl
00:49:34 <gamegoblin> So rarely use anything it puts out, but it’s so clever
00:50:17 <kazagistar> I like putting in near random sequences
00:50:49 <Iceland_jack> @pl a b c = b c (c b a) b a
00:50:49 <lambdabot> a = fix (flip =<< (flip .) . join . (flip .) . ap ap . flip (flip . flip id))
00:50:51 <gamegoblin> @pl \a b c d e f -> a (b c) (a d (b c) f
00:50:51 <lambdabot> (line 1, column 37):
00:50:51 <lambdabot> unexpected end of input
00:50:51 <lambdabot> expecting variable, "(", operator or ")"
00:50:54 <gamegoblin> Ahaha
00:50:55 <kazagistar> @pl f a b c d e = a b + c c d e . e
00:50:55 <lambdabot> f = flip flip (flip flip id . (liftM2 (.) .) . join id) . (((.) . (.) . (.) . (+)) .)
00:51:03 <gamegoblin> That is amazing.
00:54:39 <gamegoblin> can you use guards on a function with no arguments?
00:54:40 <AshyIsMe> has anyone here worked with snap much before?
00:55:07 <AshyIsMe> im implementing a redis Auth backend at the moment
00:55:18 <Iceland_jack> gamegoblin: sure
00:55:58 <AshyIsMe> it seems like everything should be working but when i try to login it just dumps me back to the login page instead of properly authenticating
00:56:12 <AshyIsMe> https://github.com/AshyIsMe/snaplet-redis/blob/master/src/Snap/Snaplet/Auth/Backends/Redis.hs
00:56:16 <AshyIsMe> that's my auth backend
00:56:19 <kazagistar> presumably, you would be guarding over some closed-over value?
00:56:34 <Iceland_jack>     foo | True      = 'a'
00:56:34 <Iceland_jack>         | otherwise = 'b'
00:56:49 <Iceland_jack> gamegoblin: You may be more interested in MultiWayIfs though
00:57:03 <gamegoblin> A what
00:57:19 <Iceland_jack>     if | a < b     = 'a'
00:57:19 <Iceland_jack>        | a > b     = 'b'
00:57:19 <Iceland_jack>        | otherwise = 'u'
00:57:20 <gamegoblin> Oh my god
00:57:25 <gamegoblin> why did I not know about these
00:57:27 <gamegoblin> I hate my life
00:57:43 <Iceland_jack> ..I'm sorry? :)
00:57:46 <gamegoblin> no no
00:57:47 <kazagistar> ... neither did I, what have I been doing with my life
00:57:51 <gamegoblin> Thanks for enlightening me
00:57:57 <Iceland_jack> Should I tell you about other extensions?
00:58:13 <kazagistar> lol, I guess I should just read the list properly sometime
00:58:24 <gamegoblin> I use maybe ~8ish extensions
00:58:26 <Iceland_jack> the GHC user guide has a pretty nice introduction to them
00:58:32 <gamegoblin> generally in regard to the type system
00:58:48 <gamegoblin> nomonorphism, flexible instances, flexible contexts, etc
00:59:00 <gamegoblin> tuple sections are nice
00:59:14 <enthropy> case compare a b of LT -> a; GT -> 'b'; EQ -> 'u'
00:59:27 <enthropy> no extensions needed
00:59:29 <Iceland_jack> enthropy: that wasn't the point
01:00:07 <gamegoblin> He was just demonstrating syntax
01:00:09 <gamegoblin> that I was unfamiliar with
01:00:41 <gamegoblin> I’ve seen this hack that emulates that:
01:00:45 <kazagistar> the point was to do something like guards other then right at the start of a function
01:00:52 <gamegoblin> case () of
01:00:59 <gamegoblin> _ | a < b = ‘a'
01:01:04 <gamegoblin> | a > b = ‘b’
01:01:09 <gamegoblin> etc
01:01:10 <Iceland_jack> yeah case () of is what people used to motivate MultiWayIfs
01:01:18 <gamegoblin> ah gotcha
01:01:52 <gamegoblin> What does that desugar to? A nested if or a case () ?
01:02:36 <enthropy> presumably you're allowed to use pattern guards stuff in the multiwayif
01:02:53 <enthropy> > if | x <- 1, x == 1 -> 2
01:02:54 <lambdabot>  <hint>:1:1: Multi-way if-expressions need MultiWayIf turned on
01:03:18 <kazagistar> a nested if eventually desugars to a case as well, I thought? I dunno
01:03:27 <gamegoblin> I have no idea
01:03:38 <gamegoblin> I really really need to explore deeper into ghc
01:04:27 <Iceland_jack> kazagistar is right, there are no 'if' statements in Core
01:04:29 <kazagistar> from the wiki page about Core haskell, it looks like the only conditional is Cond, so I guess it must
01:04:42 <kazagistar> https://ghc.haskell.org/trac/ghc/wiki/Commentary/Compiler/CoreSynType
01:04:59 <kazagistar> er, Case
01:18:11 <gamegoblin> @hoogle Int -> Int -> Ordering
01:18:11 <lambdabot> Data.Ord comparing :: Ord a => (b -> a) -> b -> b -> Ordering
01:18:12 <lambdabot> Prelude compare :: Ord a => a -> a -> Ordering
01:18:12 <lambdabot> Data.Ord compare :: Ord a => a -> a -> Ordering
01:54:18 <augur> comments welcome: http://lpaste.net/106459
01:56:18 <Fuuzetsu> is there really no Bool xor in base?
01:56:37 <augur> not .: or
01:56:37 <augur> duh
01:56:38 <corgifex> Fuuzetsu: /=
01:56:47 <augur> @hoogle Bool -> Bool -> Bool
01:56:48 <lambdabot> Prelude (&&) :: Bool -> Bool -> Bool
01:56:49 <lambdabot> Data.Bool (&&) :: Bool -> Bool -> Bool
01:56:49 <lambdabot> Prelude (||) :: Bool -> Bool -> Bool
01:56:54 <mornfall> corgifex: ;-)
01:56:57 <augur> guess not
01:57:01 <augur> @hoogle xor
01:57:01 <lambdabot> Data.Bits xor :: Bits a => a -> a -> a
01:57:01 <lambdabot> package xorshift
01:57:01 <lambdabot> Graphics.Rendering.OpenGL.GL.PerFragment Xor :: LogicOp
01:57:07 <mornfall> augur: what corgifex says...
01:57:15 <augur> oh!
01:57:16 <augur> hahaha
01:57:21 <Fuuzetsu> the lambdabot output above tels me I could abuse compare and check for EQ I guess
01:57:24 <mornfall> I know, right? :-)
01:57:26 <augur> i thought corgifex was making an emoticon
01:57:28 <augur> hahahaaa
01:57:30 <corgifex> Fuuzetsu: HELLO
01:57:41 <mornfall> Bool is always Eq
01:57:57 <Fuuzetsu> corgifex: Hello?
01:58:02 <augur> corgifex: gotta put your operators in ()s man
01:58:04 <Fuuzetsu> oh
01:58:05 <augur> (/=)
01:58:08 <mornfall> Fuuzetsu: /= (inequality)
01:58:11 <Fuuzetsu> I thought he was making an emoticon too
01:58:13 <augur> nooo
01:58:18 <Fuuzetsu> …that would work
01:58:21 <augur>  /= is an emoticon
01:58:23 <augur> (/=) is xor!
01:58:30 <Fuuzetsu> not $ compare x y == EQ is more enterprise
01:58:33 <mornfall> augur: /= is too weird for an emoticon
01:58:43 <corgifex> (/=)/`
01:58:47 <augur> mornfall: its just upside down =/
01:59:30 <mornfall> rotated emoticons... uhoh :-)
01:59:44 <wei2912> (/=) is xor?
01:59:45 <mornfall> (-: I mean
02:00:00 <mornfall> wei2912: draw a truth table
02:00:12 <augur> wei2912: well, on booleans it is
02:00:12 <wei2912> oh wait, got it
02:00:15 <wei2912> lol
02:00:20 <wei2912> on booleans, that is
02:00:28 <mornfall> you don't have logical xor in C either, do you?
02:00:40 <mornfall> (although it's more trouble there coz True could be 1 or 2 or ...)
02:00:40 <augur> mornfall: there's no booleans in C so
02:00:45 <corgifex> _Bool
02:01:08 <wei2912> mornfall, no
02:01:18 <corgifex> !x != !y
02:01:28 <wei2912> !A != !B
02:01:35 <wei2912> stolen from http://stackoverflow.com/questions/1596668/logical-xor-operator-in-c
02:01:43 <mornfall> yeah yeah
02:01:54 <mornfall> and !! is the assorted bool conversion operator
02:02:04 <mornfall> that's C for you :|
02:02:16 <mornfall> what bothers me more is that almost everywhere I have to negate implications
02:02:25 <napping> oh man, you do need that
02:02:42 <kazagistar> mornfall: does ! ensure a 1 result?
02:02:46 <wei2912> oh damn
02:03:37 <mornfall> kazagistar: yes
02:03:47 <mornfall> kazagistar: !x is always 0 or 1
02:04:03 <mornfall> (or -1 if this was a signed 1-bit bitfield)
02:04:35 <mornfall> (actually, it's still 1 but when you store it overflows to -1)
02:05:14 <kazagistar> ... somehow I never used signed 1-bit bitfields in C haha
02:05:44 <corgifex> good, because they're crazy
02:06:09 <kazagistar> they are in C. things in C are crazy... checks out for me
02:12:26 <jle`> how can i run cabal repl with no Prelude?
02:17:54 <ienh> new to both haskell and cabal, could anyone help me resolve this: https://gist.github.com/anonymous/18b982108a349ed081df
02:18:27 <gamegoblin> I just made a little AI for a finger game. Anyone want to play against it?
02:20:05 <int3__> is there some nice syntax for a function whose only use is to start out with some default parameters and then to recursively invoke itself?
02:20:12 <int3__> basically, I'm thinking of lisp's 'let' syntax
02:20:31 <lfairy> fix?
02:21:00 <int3__> lfairy: ah yes that seems to be it. thanks!
02:21:44 <lfairy> ienh: delete ~/.ghc and try again
02:21:51 <lfairy> int3__: no problem :)
02:22:18 <corgifex> can you explain the 'let' part?
02:25:11 <ienh> lfairy: that did it, thanks
02:26:13 <int3__> corgifex: e.g. to sum from 1 to 10 in lisp, you can write this -- (let foo ((x 1) (sum 0)) (foo (if (< x 10) (foo (+ 1 x) (+ x sum)) sum))
02:26:22 <int3__> as opposed to declaring foo and then invoking it with 1 and 0 separately
02:26:50 <corgifex> wow, evil hack
02:30:20 <corgifex> *** - EVAL: (X 1) is not a function name; try using a symbol instead
02:31:29 <int3__> corgifex: I haven't written lisp in a while... there is probably a syntax error in there somewhere :P i was just trying to convey the idea heh
02:31:41 <corgifex> but now I'm confused about the idea
02:32:17 <corgifex> what is foo supposed to be? a function?
02:36:02 <int3__> corgifex: yeah, it's supposed to be a function. also, I realize it might be a scheme-only thing... not sure. anyway, here's a website that might be more illustrative: http://www.ccs.neu.edu/home/dorai/t-y-scheme/t-y-scheme-Z-H-8.html#node_sec_6.2
02:36:57 <corgifex> aah
02:38:11 <kazagistar> aw, gamegoblin left... I was going to mention that pretty early on my friends and I mapped out the entire set of optimal moves and countermoves in the finger game that I know
02:38:28 <kazagistar> so I assume his AI does something similar
02:38:56 <corgifex> > fix (\countdown i -> if i == 0 then ["liftoff"] else show i : countdown (i - 1)) 10
02:38:58 <lambdabot>  ["10","9","8","7","6","5","4","3","2","1","liftoff"]
02:49:11 <kazagistar> int3__: what corgifex said would work, but really, it is pretty reasonable to just use the "let ... in ..." form provided by the language, or "... where ..." if you want it in the other order
02:50:27 <int3__> kazagistar: yeah... the 'fix' construction isn't as nice as scheme's named let. I guess macros do have their benefits :P
02:51:03 <kazagistar> int3__: benefits have costs
02:51:11 <int3__> haha indeed
02:51:17 <corgifex> > let countdown i = if i == 0 then ["liftoff"] else show i : countdown (i - 1) in countdown 10
02:51:18 <lambdabot>  ["10","9","8","7","6","5","4","3","2","1","liftoff"]
02:51:24 <MP2E> also that ^
02:51:29 <MP2E> you don't *need* to use fix
02:51:52 <Iceland_jack> You shouldn't use fix, really
02:51:53 <corgifex> > map show [10, 9 .. 1] ++ ["liftoff"]
02:51:55 <lambdabot>  ["10","9","8","7","6","5","4","3","2","1","liftoff"]
02:52:15 <wei2912> > show [10..1] ++ ["liftoff"]
02:52:17 <lambdabot>  Couldn't match expected type ‘GHC.Types.Char’
02:52:17 <lambdabot>              with actual type ‘[GHC.Types.Char]’
02:52:21 <wei2912> damn
02:53:14 <kazagistar> you rarely should need to build your own loops in the first place, most of the useful ones are already written
02:53:17 <corgifex> > [10 .. 1]
02:53:18 <lambdabot>  []
02:53:20 <corgifex> > show [10 .. 1]
02:53:21 <lambdabot>  "[]"
02:53:34 <kazagistar> > [10,9..1]
02:53:35 <lambdabot>  [10,9,8,7,6,5,4,3,2,1]
02:54:09 <kazagistar> default step is 1, it wont switch to -1
02:54:45 <int3__> gotcha
02:55:23 <kazagistar> > enumFromThenTo 10 9 1
02:55:25 <lambdabot>  [10,9,8,7,6,5,4,3,2,1]
02:55:34 <kazagistar> (to desugar it)
02:56:00 <Maxdamantus> > ([5,4..1], 1 `elem` [1..5])
02:56:01 <wei2912> kazagistar, ah, i see
02:56:02 <lambdabot>  ([5,4,3,2,1],True)
02:56:44 <kazagistar> > 1 `inRange` (1,5)
02:56:45 <lambdabot>  No instance for (GHC.Num.Num ((t0, t1), (t0, t1)))
02:56:46 <lambdabot>    arising from the literal ‘1’No instance for (GHC.Arr.Ix t1)
02:56:46 <lambdabot>    arising from a use of ‘GHC.Arr.inRange’
02:56:46 <lambdabot>  The type variable ‘t1’ is ambiguous
02:56:46 <lambdabot>  Note: there are several potential instances:
02:56:59 <Maxdamantus> > let enumFromThenTo = 4 in [10,9..1]
02:57:00 <lambdabot>  [10,9,8,7,6,5,4,3,2,1]
02:57:02 <corgifex> > inRange (1,5) 1
02:57:02 <kazagistar> drat
02:57:03 <lambdabot>  True
02:57:06 <kazagistar> right
02:57:10 <kazagistar> wrong order
02:57:21 * Maxdamantus likes that idris actually does use the exact identifiers to desugar.
02:59:11 <kazagistar> Maxdamantus: why? that seems like exactly the sort of hidden back door side effect thing that perl and whatnot are infamous for
02:59:37 <Maxdamantus> Idris> let enumFrom = const 4 in [1..]
02:59:37 <Maxdamantus> 4 : Integer
03:00:03 <Maxdamantus> kazagistar: because then you actually can say that it's sugar.
03:00:22 <wei2912> > show [10,9..1] ++ ["liftoff"]
03:00:24 <lambdabot>  Couldn't match expected type ‘GHC.Types.Char’
03:00:24 <lambdabot>              with actual type ‘[GHC.Types.Char]’
03:00:28 <corgifex> s/sugar/text replacement/
03:00:33 <kazagistar> I would rather not say its a sugar and have behaviors not randomly change for unrelated reasons
03:00:52 <corgifex> the haskell behavior is sugar too, then
03:00:57 <Maxdamantus> corgifex: also, potentially more flexible.
03:01:03 <corgifex> it just desugars to Prelude.enumFrom
03:01:15 <Maxdamantus> corgifex: eg, [1, 2, 3] works for both `List _` and `Vect _ _`
03:01:34 <kazagistar> wei2912: your order of operations is wrong now, function application takes precedence over binary operators
03:01:38 <Maxdamantus> Each right operand of the :: in Vect .. will have a different type.
03:01:49 <Maxdamantus> er, kazagistar*
03:02:04 <wei2912> kazagistar, ah, i see
03:02:13 <Maxdamantus> corgifex: can you not `import qualified Foo as Prelude`?
03:02:32 <Maxdamantus> corgifex: what if you `import Prelude hiding (enumFrom)`?
03:02:34 <wei2912> > show ([10,9..1] ++ ["liftoff"])
03:02:35 <lambdabot>  No instance for (GHC.Enum.Enum [GHC.Types.Char])
03:02:35 <lambdabot>    arising from the arithmetic sequence ‘10, 9 .. 1’No instance for (GHC.Num....
03:02:35 <lambdabot>    arising from the literal ‘10’
03:02:47 * Maxdamantus can't remember if that actually stops you from using `Prelude.enumFrom`
03:02:55 <wei2912> bad try, i suppose
03:02:56 <wei2912> :P
03:03:12 <wei2912> kazagistar, what should i do?
03:03:13 <silasm> > show [10,9..1] ++ "liftoff"
03:03:14 <lambdabot>  "[10,9,8,7,6,5,4,3,2,1]liftoff"
03:03:27 <MP2E> :t show
03:03:28 <lambdabot> Show a => a -> String
03:03:38 <MP2E> :t map show
03:03:39 <lambdabot> Show a => [a] -> [String]
03:03:39 <kazagistar> wei2912: you cannot concatenate lists of different types
03:03:42 <MP2E> ;0
03:03:55 <silasm> wei2912: yeah, the concatenation was your real issue there.
03:04:10 <silasm> wei2912: you were trying to concatenate [a] with [[a]]
03:04:10 <Maxdamantus> Indeed, `hiding (enumFrom)` means you can't refer to it with `Prelude.enumFrom` either.
03:04:14 <matematikaadit> > map show [10,9..1] ++ ["liftoff"]
03:04:15 <lambdabot>  ["10","9","8","7","6","5","4","3","2","1","liftoff"]
03:04:21 <kuribas> :q
03:04:27 <wei2912> what does the "map" function do in that case?
03:04:29 <wei2912> oh wait, got it
03:04:43 <corgifex> > map f [x, y, z] :: [Expr]
03:04:45 <lambdabot>  [f x,f y,f z]
03:04:48 <wei2912> it results in an array of [10,9..1] converted to strings, right?
03:05:18 <wei2912> mapping show to each element in [10,9..1]
03:05:36 <silasm> wei2912: yep, each element is individually "show"ed instead of the list as a whole.
03:06:03 <Iceland_jack> > unwords (map show [1..10])
03:06:04 <lambdabot>  "1 2 3 4 5 6 7 8 9 10"
03:06:09 <Iceland_jack> > show [1..10]
03:06:11 <lambdabot>  "[1,2,3,4,5,6,7,8,9,10]"
03:06:33 <wei2912> > unwords ["a", "b"]
03:06:34 <lambdabot>  "a b"
03:06:45 <kazagistar> > read "[1,2,3]" :: [Int]
03:06:46 <lambdabot>  [1,2,3]
03:07:06 <kuribas> concat $ intersperse ", " $ map show [1..10] ++ "liftoff"
03:07:14 <corgifex> intercalate
03:07:22 <kazagistar> > words "welcome to haskell"
03:07:24 <lambdabot>  ["welcome","to","haskell"]
03:07:33 <kuribas> > concat $ intersperse ", " $ map show [1..10] ++ ["liftoff"]
03:07:34 <lambdabot>  "1, 2, 3, 4, 5, 6, 7, 8, 9, 10, liftoff"
03:07:42 <Maxdamantus> So you can't technically describe things `[1..]`, `[1, 2, 3]`, `do foo`, .. as sugar.
03:07:48 <corgifex> > intercalate ", " $ map show [1..10] ++ ["liftoff"]
03:07:50 <lambdabot>  "1, 2, 3, 4, 5, 6, 7, 8, 9, 10, liftoff"
03:08:22 <Maxdamantus> at least not sugar on top of Haskell without those features.
03:08:35 <corgifex> http://www.haskell.org/ghc/docs/latest/html/users_guide/syntax-extns.html#rebindable-syntax
03:08:35 <kuribas> Maxdamantus: I'd say [1..] is sugar, [1, 2, 3] is not
03:08:46 <Maxdamantus> kuribas: what is it sugar for?
03:08:48 <silasm> > intercalate x [a, b, c] :: [Expr]
03:08:49 <lambdabot>  Couldn't match expected type ‘[Debug.SimpleReflect.Expr.Expr]’
03:08:50 <lambdabot>              with actual type ‘Debug.SimpleReflect.Expr.Expr’Couldn't match e...
03:08:50 <lambdabot>              with actual type ‘Debug.SimpleReflect.Expr.Expr’Couldn't match e...
03:08:50 <lambdabot>              with actual type ‘Debug.SimpleReflect.Expr.Expr’Couldn't match e...
03:08:50 <lambdabot>              with actual type ‘Debug.SimpleReflect.Expr.Expr’
03:08:53 <Iceland_jack> [1,2,3] is certainly sugar for (1:(2:(3:[])))
03:08:55 <silasm> > intercalate x [a, b, c] :: Expr
03:08:56 <lambdabot>  Couldn't match expected type ‘Debug.SimpleReflect.Expr.Expr’
03:08:56 <lambdabot>              with actual type ‘[a0]’Couldn't match expected type ‘[a0]’
03:08:56 <lambdabot>              with actual type ‘Debug.SimpleReflect.Expr.Expr’Couldn't match e...
03:08:57 <lambdabot>              with actual type ‘Debug.SimpleReflect.Expr.Expr’Couldn't match e...
03:08:59 <kuribas> Maxdamantus: enumFrom 1
03:08:59 <lambdabot>              with actual type ‘Debug.SimpleReflect.Expr.Expr’Couldn't match e...
03:09:20 <silasm> gah, sorry for the multiline spam
03:09:23 <Maxdamantus> > let enumFrom = const 4 in [1..]
03:09:25 <lambdabot>  [1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,...
03:09:30 <Maxdamantus> > let enumFrom = const 4 in enumFrom 1
03:09:32 <lambdabot>  4
03:09:39 <Maxdamantus> Didn't work.
03:09:42 <Iceland_jack> no problem, you can always PM lambdabot silasm and then use what ever works there on #haskell
03:09:55 <mm_freak> hi there
03:10:01 <kuribas> Maxdamantus: you redefined  it
03:10:22 <Maxdamantus> kuribas: which would have changed the behaviour if it were sugar.
03:11:17 <mm_freak> i want to capture monadic folds, but unfortunately they don't really fit into the F-algebra model, because the fold is an 'F a -> M a' rather than an 'F a -> a'
03:11:32 <Maxdamantus> By having it not sugar unnecessarily binds things like the Monad class into the language.
03:11:33 <mm_freak> interestingly enough monadic unfolds do fit into the F-coalgebra model
03:11:44 <Maxdamantus> s/unnecessarily/also unnecessarily/
03:11:46 <mm_freak> so there must be some form of dual…  does anyone know how to capture it?
03:12:52 <kazagistar> @let countdown = intercalate ", " . reverse . ("liftoff":) . map show . enumFromTo 1
03:12:53 <lambdabot>  .L.hs:149:1:
03:12:53 <lambdabot>      Multiple declarations of ‘countdown’
03:12:53 <lambdabot>      Declared at: .L.hs:146:1
03:12:53 <lambdabot>                   .L.hs:149:1
03:12:57 <kazagistar> er
03:13:00 <kazagistar> @undefine
03:13:00 <lambdabot> Undefined.
03:13:05 <wei2912> http://ideone.com/GBtfz0 -> is there a way for fib to cache the values?
03:13:23 <kazagistar> > let countdown = intercalate ", " . reverse . ("liftoff":) . map show . enumFromTo 1 in countdown 10
03:13:25 <lambdabot>  "10, 9, 8, 7, 6, 5, 4, 3, 2, 1, liftoff"
03:13:45 <silasm> @wiki memoization
03:13:45 <lambdabot> http://www.haskell.org/haskellwiki/memoization
03:14:26 <kazagistar> wei2912: sure, but there is no reason for fib to want to cache the values, since they get too big too fast to be useful
03:14:54 <silasm> ^ that's the general way to cache values in haskell for dynamic programming type stuff; I've never dealt with it myself.
03:14:57 <wei2912> ty silasm
03:15:12 <corgifex> > let fibs = 0 : 1 : zipWith (+) fibs (tail fibs) in fibs
03:15:13 <lambdabot>  [0,1,1,2,3,5,8,13,21,34,55,89,144,233,377,610,987,1597,2584,4181,6765,10946,...
03:15:20 <mm_freak> > let countdown n = foldr (\x y -> x ++ ", " ++ y) "liftoff" . map show $ [n,n-1 .. 1] in countdown 10
03:15:22 <lambdabot>  "10, 9, 8, 7, 6, 5, 4, 3, 2, 1, liftoff"
03:15:30 <corgifex> > let fibs = 0 : 1 : zipWith (+) fibs (tail fibs) in drop 10 fibs
03:15:32 <lambdabot>  [55,89,144,233,377,610,987,1597,2584,4181,6765,10946,17711,28657,46368,75025...
03:15:32 <mm_freak> kazagistar: 'reverse' is evil
03:16:01 <kazagistar> mm_freak: but it made it so pointlessly beautiful!
03:16:22 <kuribas> Maxdamantus: Makes sense... WHat about "do"?
03:16:23 <corgifex> :t (0 :) . (1 :) . (zipWith (+)) <*> tail
03:16:24 <lambdabot>     Couldn't match type ‘[a0]’ with ‘[c] -> b’
03:16:24 <lambdabot>     Expected type: [c] -> [c] -> b
03:16:24 <lambdabot>       Actual type: [c] -> [a0]
03:16:25 <kazagistar> corgifex: thats a useless cache, because pointer chasing is likely way more expensive then computing it from scratch
03:16:28 <edwardk_> jmcarthur_mobile: how far along is your Tarjan and Mihaesau implementation? I've got most of it now. https://gist.github.com/ekmett/0a14962f230fac952734
03:16:34 <corgifex> :t (0 :) . (1 :) . ((zipWith (+)) <*> tail)
03:16:35 <lambdabot> Num a => [a] -> [a]
03:16:43 <mm_freak> kazagistar: you could make the countdown itself pointfree, then everything else remains pointfree =)
03:16:55 <corgifex> kazagistar: feel free to benchmark it against the original code
03:17:15 <Maxdamantus> kuribas: `do` manages to refer somehow to the >>= method of the monad class
03:17:16 <kuribas> Maxdamantus: you mean >>= can be redefined also?
03:17:18 <kazagistar> corgifex: against original, sure :P
03:17:27 <Maxdamantus> kuribas: you mean in Idris? Yes.
03:17:47 <mm_freak> > let revEnumFrom n = [n, n-1, .. 1]; countdown = foldr (\x y -> x ++ ", " ++ y) "liftoff" . map show . revEnumFrom in countdown 10
03:17:49 <lambdabot>  <hint>:1:30: parse error on input ‘..’
03:17:53 <mm_freak> > let revEnumFrom n = [n, n-1 .. 1]; countdown = foldr (\x y -> x ++ ", " ++ y) "liftoff" . map show . revEnumFrom in countdown 10
03:17:55 <lambdabot>  "10, 9, 8, 7, 6, 5, 4, 3, 2, 1, liftoff"
03:18:14 <Maxdamantus> kuribas: or just in Haskell? (>>=) is just another identifier in Haskell.
03:18:27 <kuribas> Maxdamantus: yes
03:18:46 <kuribas> let (>>=) = (+) in 1 >>= 2
03:18:50 <kuribas> > let (>>=) = (+) in 1 >>= 2
03:18:51 <lambdabot>  3
03:18:53 <mm_freak> kazagistar: and i prefer a lazy half-way pointfree over a strict pointfree solution =)
03:18:56 <Maxdamantus> kuribas: but `do` notation doesn't use the identifier. It always manages to refer to that method in *the* Monad class (not necessarily the class called "Monad" in the context it's used in)
03:19:01 <mm_freak> > let revEnumFrom n = [n, n-1 .. 1]; countdown = foldr (\x y -> x ++ ", " ++ y) "liftoff" . map show . revEnumFrom in countdown 10000000000
03:19:03 <lambdabot>  "10000000000, 9999999999, 9999999998, 9999999997, 9999999996, 9999999995, 99...
03:19:08 <wei2912> what does the 2 !! do?
03:19:26 <corgifex> > iterate (round . ((0.5 + sqrt 1.25) *) . fromIntegral) 1
03:19:28 <lambdabot>  [1,2,3,5,8,13,21,34,55,89,144,233,377,610,987,1597,2584,4181,6765,10946,1771...
03:19:29 <wei2912> in the code under http://www.haskell.org/haskellwiki/Memoization#Memoization_with_recursion
03:20:02 <kazagistar> mm_freak: I prefer lots of well named points that document what I am doing clearly, and then being facetious in IRC chats :P
03:20:17 <mm_freak> kazagistar: good =)
03:20:29 <silasm> > :t (2!!)
03:20:30 <lambdabot>  <hint>:1:1: parse error on input ‘:’
03:20:37 <silasm> :t (2!!)
03:20:38 <lambdabot> Num [a] => Int -> a
03:20:49 <mm_freak> wei2912: it's the usual list index operator
03:20:50 <silasm> wei2912: it indexes the list, e.g.
03:21:05 <wei2912> mm_freak, silasm ty
03:21:06 <silasm> > 2!! [a,b,c,d] :: Expr
03:21:08 <lambdabot>  Couldn't match expected type ‘GHC.Types.Int’
03:21:08 <lambdabot>              with actual type ‘[Debug.SimpleReflect.Expr.Expr]’
03:21:12 <corgifex> > iterate (round . ((0.5 + sqrt 1.25) *) . fromIntegral) 1 !! 5
03:21:14 <Maxdamantus> :t (!!2)
03:21:14 <lambdabot>  13
03:21:15 <lambdabot> [a] -> a
03:21:43 <silasm> whoops, I had that reversed.
03:21:50 <silasm> > [a,b,c,d] !! 2:: Expr
03:21:52 <lambdabot>  c
03:22:06 <silasm> (note it's zero-indexed)
03:22:13 <corgifex> > [a,b,c] !! 0
03:22:14 <lambdabot>  a
03:22:19 <kuribas> Maxdamantus: perhaps it could be implemented as INTERNAL_MODULE.enumFrom or something like that.
03:22:35 <mm_freak> in most cases (!!) is a bad idea…  not because it's O(n), but it's actually O(n²) for many lists
03:22:51 <augur> anyone have comments? http://www.reddit.com/r/haskell/comments/29drft/seeking_feedback_pattern_matching_for_structural/
03:22:52 <Maxdamantus> kuribas: then you're not talking about it in terms of Haskell minus the syntactic features.
03:22:53 <silasm> mm_freak: when is it O(n^2)?
03:23:17 <mm_freak> silasm: when cons is not strict in the previous element
03:23:27 <kazagistar> @pl (\x -> enumFromThenTo x (x - 1) 1)
03:23:28 <lambdabot> flip (ap enumFromThenTo (subtract 1)) 1
03:23:28 <mm_freak> for example when you use 'iterate' or 'unfoldr'
03:23:50 <mm_freak> although i think it's O(n * log n) time and O(n) space rather than O(n²) time
03:23:52 <kazagistar> ah, good ol flip ap
03:24:00 <Maxdamantus> kuribas: but possibly relatedly, you can see all the things bound to the language in that way under `GHC` in GHC.
03:24:24 <Maxdamantus> > if 4 then 5 else 6
03:24:25 <lambdabot>  Could not deduce (GHC.Num.Num GHC.Types.Bool)
03:24:25 <lambdabot>    arising from the literal ‘4’
03:24:25 <lambdabot>  from the context (GHC.Num.Num a)
03:24:25 <lambdabot>    bound by the inferred type of it :: GHC.Num.Num a => a at Top level
03:24:37 <silasm> mm_freak: hmm, I can kind of see it, but I'm tired as hell so I doubt it'll click. (there's also the fact that it's partial)
03:24:48 <silasm> > [1,2,3] !! 4
03:24:49 <lambdabot>  *Exception: Prelude.(!!): index too large
03:25:00 <mm_freak> silasm: in most cases this operator is what you want:  index i (x:xs) = x `seq` index (i - 1) xs
03:25:07 <mm_freak> silasm: (simplified)
03:25:24 <mm_freak> the default (!!) is not element-strict
03:25:27 <kuribas> Maxdamantus: you could 'desugar' it as [1..] = GHC.EnumFrom
03:25:50 <corgifex> mm_freak: what difference does that make?
03:26:12 <corgifex> if x depends on its predecessor, wouldn't that be triggered automatically anyway?
03:26:16 <Maxdamantus> kuribas: I doubt it.
03:26:19 <mm_freak> corgifex: take this as an example:  iterate (\x -> 2*x + 1) 0 !! 100
03:26:28 <kuribas> > let enumFrom = const 4 in GHC.enumFrom 1
03:26:29 <lambdabot>  Not in scope: ‘GHC.enumFrom’
03:26:38 <mm_freak> corgifex: it indexes the expression, not the result
03:26:50 <kuribas> > let enumFrom = const 4 in Prelude.enumFrom 1
03:26:52 <lambdabot>  [1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,...
03:26:54 <Maxdamantus> kuribas: what if someone who had never heard of GHC wrote `import qualified GrandHadronCollider as GHC` at the top of their file?
03:27:00 <mm_freak> the list is fully lazy and (!!) is not element-strict…  it does not force evaluation as it goes
03:27:09 <corgifex> right
03:27:12 <mm_freak> so you will build up the expression in memory and then evaluate it
03:27:20 <mm_freak> pretty much like foldl vs. foldl'
03:27:21 <mmmm__> Say I was developing library a, a depends on b and b is installed into the sandbox from hackage. I have now done some work on b and want to use the updated version whilst compiling a. How is best to do this with cabal?
03:27:38 <kazagistar> > let Prelude.enumFrom = const 4 in [1..]
03:27:39 <lambdabot>  Qualified name in binding position: Prelude.enumFrom
03:27:40 <corgifex> ok, space leak
03:28:01 <silasm> mm_freak: hmm, getting it. But I need to go to bed. Good night all.
03:28:13 <mm_freak> mmmm__: if nothing else depends on B, then you should be able to reinstall it safely
03:28:36 <mm_freak> mmmm__: otherwise it's safest to rebuild the sandbox
03:29:13 <Maxdamantus> but imo, languages should have something like a special import prefix that portable programs aren't allowed to use.
03:29:21 <mmmm__> (weeps)
03:29:40 <mmmm__> The build takes so long on my tiny laptop haha, I guess I can try reinstalling first thanks mm_freak
03:29:45 <jle`> there should be a strict (!!) in Data.List
03:29:52 <Maxdamantus> to avoid wondering what happens when you call a module `GHC`
03:29:54 <jle`> i've had to write it on more than one occasion
03:29:58 <mm_freak> mmmm__: well, you could also use nix =)
03:30:16 <mm_freak> jle`: in those cases you probably want a streaming abstraction anyway =)
03:30:32 <jle`> mm_freak: ah, true
03:30:43 <mmmm__> Is there a difference between using "cabal install /path/to/library/" and "cabal sandbox add-source /path/to/library"
03:30:46 <jle`> i mostly use it for short standalone demonstrations
03:31:07 <jle`> mmmm__: when you cabal install your project, it'll use that directory as the source
03:32:19 <kuribas> Maxdamantus: then you are saying this page is wrong? http://www.haskell.org/haskellwiki/Syntactic_sugar
03:32:20 <mm_freak> anyway, no ideas on my little algebraic problem?  where is edwardk_ when you need him =)
03:33:09 <edwardk_> distracted ;)
03:33:33 <mm_freak> sorry to distract you from your distraction =P
03:33:48 <kuribas> Maxdamantus: Anyway, I prefer it this way.  It could give strange results if it used a lexical binding of enumFrom.
03:34:02 <Maxdamantus> kuribas: yes.
03:34:22 <mm_freak> edwardk_: but maybe you could quickly point me to a library or blog post…  how do i capture monadic folds?  F-algebras don't work, at least not out of the box
03:34:34 <edwardk_> 'capture'?
03:35:03 <mm_freak> edwardk_: regular folds are F-algebra + seed, monadic folds are …?
03:35:58 <augur> i bet edwardk_ might have some comments on http://www.reddit.com/r/haskell/comments/29drft/seeking_feedback_pattern_matching_for_structural/
03:35:59 <augur> :x
03:38:32 <Maxdamantus> :t (2!!)
03:38:33 <lambdabot> Num [a] => Int -> a
03:38:44 <jle`> lol
03:39:10 <cstanfill> what
03:39:13 <augur> seems reasonable
03:39:27 <Maxdamantus> Oh, meh, what I defined isn't useful for that.
03:39:48 <Maxdamantus> > [(),(),()]*[(),()]
03:39:49 <lambdabot>  [(),(),(),(),(),()]
03:39:49 <edwardk_> mm_freak: i usually use m of a seed
03:39:53 <jle`> Num [a] looks funny.  but there's a couple of sensible Num instances for Num a => [a] so
03:40:04 <Maxdamantus> > [(),(),()]*[(),()] + [()] - [(),(),()]
03:40:05 <lambdabot>  [(),(),(),()]
03:40:08 <corgifex> all Applicatives can be Num'd
03:40:10 <cstanfill> oh, right, that !!
03:40:16 <jle`> corgifex: yeah, that's what i mean
03:40:18 <augur> corgifex: is that true?
03:40:25 <corgifex> yes
03:40:31 <augur> how?
03:40:34 <jle`> (+) = liftA2 (+)
03:40:39 <jle`> fromInteger = pure . fromInteger
03:40:46 <jle`> negate = liftA negate
03:40:49 <jle`> etc.
03:40:55 <augur> jle`: oh, transporting it. ok
03:41:30 <edwardk_> data FoldM a b = forall r. FoldM (r -> m b) (r -> a -> m r) (m r) -- add Profunctors and season to taste
03:41:35 <edwardk_> er
03:41:41 <edwardk_> data FoldM m a b = forall r. FoldM (r -> m b) (r -> a -> m r) (m r)
03:41:46 <Maxdamantus> > (2!!) 4
03:41:48 <lambdabot>  *Exception: Prelude.(!!): index too large
03:41:55 <edwardk_> that should be a profunctor, monad, applicative, etc.
03:42:05 <edwardk_> i've done something similar for 'builders' before
03:42:05 <corgifex> > 2!! 1
03:42:07 <lambdabot>  *Exception: Prelude.undefined
03:42:28 <Maxdamantus> > length (4 :: [Int])
03:42:28 <mm_freak> edwardk_: how does that work?  i have (simplified) 'List m a' and the corresponding fold is Maybe (a, r) -> m r
03:42:29 <lambdabot>  4
03:42:43 <Maxdamantus> > length (4*2 + 1 - 7*4 :: [Int])
03:42:44 <lambdabot>  0
03:42:50 <mm_freak> edwardk_: the trouble is that the effects are in the list itself, so every fold is monadic
03:43:08 <edwardk_> that code above is for a generalized version of foldM as a data type
03:43:21 <edwardk_> :t foldM
03:43:22 <lambdabot> Monad m => (a -> b -> m a) -> a -> [b] -> m a
03:43:23 <mm_freak> ah, isee
03:43:30 <jle`> Maxdamantus: you can define instances on lambdabot? :o
03:43:33 <jle`> cute idea btw
03:43:56 <pavonia> > 2 :: [Int]
03:43:57 <lambdabot>  [*Exception: Prelude.undefined
03:44:12 <mm_freak> edwardk_: thanks, i'll take it apart in my editor…  feel free to continue =)
03:44:31 <pavonia> > 2 :: [()]
03:44:33 <lambdabot>  [*Exception: Prelude.undefined
03:45:53 <pavonia> > [1,2,3] + [4,5,6]
03:45:54 <lambdabot>  [1,2,3,4,5,6]
03:47:47 <hpc> did we just trade the awful (->) instance for an awful [] instance of Num?
03:48:09 <mm_freak> hpc: why would the (->) instance be awful?
03:48:22 <mm_freak> instance (Num b) => Num (a -> b)
03:48:41 <hpc> mm_freak: it creates even weirder type errors in numeric code
03:48:59 <mm_freak> hpc: does it?  it generates the same errors as the reader monad
03:49:00 <hpc> because forgetting a parameter can still make one part of a thing typecheck
03:49:29 <mm_freak> or in this case the reader applicative
03:49:44 <mm_freak> (+) = liftA2 (+); …; negate = fmap negate; fromInteger = pure . fromInteger
03:49:44 <freeman42> hi, anyone could give some idea of how to install latest cabal/-install on windows 8.1? http://www.haskell.org/cabal/download.html if I download the binary from there I can't find any *.exe , I tried compiling the source and can't find any executable after compiling either
03:50:29 <maybefbi> what does "| m -> e" mean in "class Monad m => MonadError e m | m -> e where"?
03:50:31 <mm_freak_> freeman42: normally you would just install the haskell platform
03:50:47 <mm_freak_> maybefbi: it's a functional dependency and means that the type 'e' follows from 'm'
03:50:53 <mm_freak_> so if 'm' is known, 'e' is unique
03:50:58 <freeman42> mm_freak, I did, but I really need the latest ghc, and it does not come with latest ghc
03:51:04 <jle`> hpc: the instance lambdabot has for [a] isn't analogous to the (->) a instance
03:51:13 <maybefbi> mm_freak_, can you provide an example
03:51:42 <hpc> maybefbi: for instance, suppose we have an instance MonadError () Maybe
03:51:44 <mm_freak_> maybefbi: say you have a function that works on 'Either e'
03:51:54 <sipa> maybefbi: you cannot have both MonadError Maybe Foo and MonadError Maybe Blah
03:51:56 <corgifex> > 2 !! 1
03:51:57 <lambdabot>  *Exception: Prelude.(!!): index too large
03:52:08 <mm_freak_> if you don't have the functional dependency, then the compiler cannot infer that it has to be 'e', so it will report an ambiguous instance error
03:52:14 <corgifex> > Just 1 + Just 2
03:52:15 <lambdabot>  Just 3
03:52:29 <maybefbi> mm_freak_, gimme a moment to meditate on that
03:52:36 <jle`> > ZipList [1,2,3] + ZipList [5,6,7]
03:52:38 <lambdabot>  No instance for (GHC.Show.Show a0)
03:52:38 <lambdabot>    arising from a use of ‘M57705937742365161263984.show_M57705937742365161263...
03:52:38 <lambdabot>  The type variable ‘a0’ is ambiguous
03:52:38 <lambdabot>  Note: there are several potential instances:
03:52:38 <lambdabot>    instance [safe] GHC.Show.Show
03:52:49 <jle`> > ZipList [1,2,3] + ZipList [5,6,7] :: ZipList Int
03:52:50 <lambdabot>  No instance for (GHC.Num.Num
03:52:50 <lambdabot>                     (Control.Applicative.ZipList GHC.Types.Int))
03:52:50 <lambdabot>    arising from a use of ‘GHC.Num.+’
03:52:53 <mm_freak_> maybefbi: so whenever you know that one type follows from the other you use a functional dependency to make this relationship explicit and help the type checker…  alternatively you could use an associated type
03:53:12 <mm_freak_> maybefbi: for unidirectional fundeps associated types are almost equivalent
03:53:15 <jle`> aw i was hoping someone did an instance (Num a, Applicative f) => Num (f a) where
03:53:22 <mm_freak_> class MonadError m where type Error m
03:53:30 <corgifex> jle`: too overlappy
03:53:43 <corgifex> > 1 2 3
03:53:44 <lambdabot>  1
03:53:47 <jle`> but what is lambdabot for but for chaos
03:54:13 <hpc> if you did not have the functional dependency, you could not infer 'e' because there might be another instance MonadError Exception (Either e)
03:54:14 <corgifex> > (sin + cos) x
03:54:16 <lambdabot>  sin x + cos x
03:54:35 <corgifex> mischief managed
03:54:36 <hpc> or anything else, with no relationship between Either and e
03:55:26 <dfsg> could anyone help me to install cabal-install from git?
03:55:28 <jle`> > ZipList [1,2,3] + ZipList [5,6,7]
03:55:29 <lambdabot>  ZipList {getZipList = [6,8,10]}
03:56:04 <corgifex> http://lpaste.net/106461
03:56:09 <mm_freak_> maybefbi: you could mentally read "FunctionalDependency" as "ExplicitClassTypeInference" =)
03:56:34 <mm_freak_> the name "functional dependency" is admittedly a little weird
03:56:36 <jle`> > head . getZipList $ 3 * 9 - abs (5 - 13)
03:56:37 <lambdabot>  19
03:59:02 <maybefbi> hpc, mm_freak_, ah so any multiparametric monad in which some type parameters are the error types, MonadError definition insists that its instances be for one particular error type
03:59:20 <mm_freak_> maybefbi: exactly
03:59:39 <maybefbi> wow, the constrol.monad.error authors are very thoughtful
03:59:50 <mm_freak_> maybefbi: not really =)
04:00:39 <mm_freak_> the default MonadError instances are…  how do i put this politely…
04:02:45 <hpc> heh
04:02:50 <hpc> "how do i put this politely"
04:02:51 <mm_freak_> maybefbi: for a much more sensible error monad class see the 'exceptions' library
04:02:54 <hpc> *stop talking*
04:03:05 <maybefbi> mm_freak_, ok
04:03:52 <mm_freak_> maybefbi: also i found this error applicative a lot more useful than Either (i'm not sure it's a monad) in many cases
04:04:02 <mm_freak_> data Error e a = Error e | Result a
04:04:16 <mm_freak_> instance (Monoid e) => Applicative (Error e)
04:04:41 <mm_freak_> it gives rise to a great Alternative instance
04:04:49 <mm_freak_> instance (Monoid e) => Alternative (Error e)
04:05:00 <mm_freak_> it's an actual monoid morphism
04:05:11 <mm_freak_> with great algebraic properties
04:06:01 <mm_freak_> empty = Error mempty;  Error e1 <|> Error e2 = Error (e1 <> e2)
04:07:42 <supki> I prefer instance Semigroup e => Applicative (Error e)
04:08:01 <mm_freak_> supki: if only Semigroup were a superclass of Monoid
04:08:22 <mm_freak_> instance (Semigroup e, Monoid e) => Alternative (Error e)
04:08:37 <mm_freak_> after the AMP we need an SMP =)
04:08:45 <mm_freak_> Semigroup-Monoid-Proposal =)
04:09:19 <Iceland_jack> And a FNP (Fix-the-Num Proposal) :)
04:10:22 <mm_freak_> you mean to get rid of this?  toRational :: (Real a) => a -> Rational
04:10:23 <mm_freak_> =)
04:11:17 <int3__> hmm so I have a trie that is built from a list of words in a file. every time I use the trie structure, the entire trie gets rebuilt though the file hasn't changed. how do I work around this?
04:11:50 <mm_freak_> int3__: you could be failing to use sharing properly
04:12:02 <mm_freak_> int3__: give the trie a name, then it's shared within the name's scope
04:12:12 <mm_freak_> let myTrie = … in …
04:12:18 <int3__> mm_freak_: I'm doing this in ghci... would that affect sharing?
04:12:25 <int3__> I did `let trie = ...`
04:12:29 <int3__> then subsequently used it
04:12:32 <statusfailed> Dumb question: how do I declare a 'shortcut class': "HasJSON" which is both "FromJSON" and "ToJSON"
04:12:32 <mm_freak_> int3__: not sure
04:12:43 <int3__> hmm ok i'll try it out of ghci then
04:12:50 <statusfailed> class HasJSON a; instance (FromJSON a, ToJSON a) => HasJSON a ?
04:12:59 <mm_freak_> statusfailed: ideally you don't…  if you don't mind an extension you can use ConstraintKinds
04:13:01 <Iceland_jack> statusfailed: you can do
04:13:01 <Iceland_jack>     type HasJSON a = (fromJSON a, ToJSON a)
04:13:11 <mm_freak_> statusfailed: what Iceland_jack said
04:13:26 <statusfailed> is that not a pair?
04:13:29 <Iceland_jack> no
04:13:32 <Iceland_jack> It's a Constraint
04:13:45 <mm_freak_> it's a scope error
04:13:53 <pavonia> int3__: When you do IO and use let to reuse the action, you still will execute the action every time you use it
04:13:55 <Iceland_jack> @kind forall a. (Show a, Read a)
04:13:56 <mm_freak_> type HasJSON a = (FromJSON a, ToJSON a)
04:13:56 <lambdabot> Constraint
04:13:57 <mm_freak_> =)
04:14:10 <Iceland_jack> mm_freak_: Because I didn't capitalize it? :)
04:14:15 <mm_freak_> Iceland_jack: yeah =)
04:14:16 <statusfailed> oh; so this is what ConstraintKinds is for?
04:14:24 <Iceland_jack> heh, so pedantic
04:14:28 <mm_freak_> statusfailed: it's one of the things =)
04:14:45 <mm_freak_> statusfailed: constraint kinds allow you to be parametric on constraints
04:15:05 <int3__> pavonia: so how do I make an action 'run-once-only'?
04:15:09 <mm_freak_> statusfailed: data Exists c = forall a. (c a) => Exists a
04:15:24 <mm_freak_> naturally that also works for simple type aliases, so you can have constraint aliases
04:15:50 <statusfailed> Hm, what is your Exists saying exactly?
04:15:50 <pavonia> int3__: "trie <-  ..." will execute the action once and bind the result to the variable
04:15:57 <mm_freak_> statusfailed: type Both c1 c2 a = (c1 a, c2 a)
04:16:03 <mm_freak_> blah :: (Both Applicative Monad m) => …
04:16:09 <mm_freak_> (although you need PolyKinds for that to work)
04:16:24 <int3__> pavonia: ohh okay I get it now
04:16:25 <int3__> thanks
04:16:35 <statusfailed> I think I kinda get it. Is this related to "witnesses"?
04:16:37 <mm_freak_> statusfailed: it's an existential type with a constraint
04:16:42 <mm_freak_> not quite
04:17:13 <mm_freak_> int3__: stuff that has a name is normally shared…  if you name the action that produces the trie, then the action is shared, not the trie itself
04:17:34 <mm_freak_> int3__: pavonia's code gives its /result/ (the trie) a name
04:18:21 <int3__> right, I see it now
04:18:45 <mm_freak_> int3__: it's like /bin/ls is shared, because it's saved in the filesystem (it has a name), but if you run it twice, the list of files will be generated twice
04:18:55 <mm_freak_> in this sense haskell's "<-" corresponds to the shell's ">"
04:19:01 <mm_freak_> ls > blah.txt
04:20:18 <int3__> got it
04:20:29 <Maxdamantus> > product $ map (:[]) [1..5]
04:20:31 <lambdabot>  [120]
04:20:38 <int3__> and apparently I can use `<-` outside `do` in ghci... that's convenient
04:20:57 <mm_freak_> int3__: the REPL acts like a giant do-block in many ways
04:21:05 <int3__> makes sense
04:21:17 <Maxdamantus> :t product
04:21:19 <lambdabot> Num a => [a] -> a
04:22:17 <pavonia> product [[1,2,3], [4,5,6]]
04:22:22 <pavonia> > product [[1,2,3], [4,5,6]]
04:22:24 <lambdabot>  [4,5,6,8,10,12,12,15,18]
04:22:33 <Maxdamantus> Someone changed it :(
04:22:37 <mm_freak_> int3__: FTR, sharing is done for all bindings, most notably including function argument bindings
04:22:50 <mm_freak_> that's why the "<-" in do-notation shares
04:22:59 <int3__> I see
04:23:09 <mm_freak_> (do x <- c; y) = c >>= \x -> y
04:23:13 <mm_freak_> the 'x' is bound
04:23:23 <int3__> right
04:30:08 <mm_freak_> edwardk_: i'm mostly using Store rather than StoreT…  do you expect a performance penalty for using StoreT over Identity rather than writing my own type all the time?
04:30:47 <mm_freak_> (in fact i've never used StoreT, i think)
04:32:34 <mm_freak_> nevermind, i'll just benchmark
04:33:05 <phaazon_> hey, I posted this yesterday: http://fr.reddit.com/r/haskell/comments/29c9dt/interpreters_how_should_it_be_done/, edwardk_ answered me a really nice answer, and after having inquired, there was still something unclear to me: if I represent a 3D scene via an AST, how should I proceed to change values inside the AST? like moving meshes, changing material properties, and so on?
04:33:57 <edwardk_> why do you want to work the scene from the outside rather than make the scene smart enough to encode the operations you'd want to perform on it?
04:34:37 <edwardk_> for the passes where you need to take in a term representing a mesh think in terms of passes that take a syntax tree to a syntax tree. think like writing a transducer or a compiler pass
04:36:32 <mm_freak_> phaazon_: i usually use monadic trees
04:36:49 <mm_freak_> (>>=) :: MyTree a -> (a -> MyTree b) -> MyTree b
04:36:53 <mm_freak_> acts on the leaves
04:37:49 <phaazon_> hm
04:37:51 <phaazon_> edwardk_: sure
04:37:52 <phaazon_> well
04:37:59 <mm_freak_> phaazon_: this also allows a nice way to encode binders in the tree, which is useful if you want to define an object once and then use it multiple times within the scene
04:38:14 <phaazon_> let’s say I have a type (Entity Mesh) that enables me to “place” meshes in space, rotate them, scale them
04:38:21 <edwardk_> phaazon_: using bound, you can just bind the syntax trees.
04:38:42 <phaazon_> mm_freak_: you mean, like we already do in Haskell proper monads?
04:38:44 <phaazon_> like
04:38:56 <phaazon_> foo = do { a <- getLine; … ; doSomethingWith a }
04:38:56 <phaazon_> ?
04:38:58 <mm_freak_> phaazon_: no, i mean what edwardk_ said
04:39:04 <edwardk_> phaazon_: your syntax tree can literally form a monad for substitution at the leaves
04:39:10 <mm_freak_> the bound library gives you a more flexible version of this:
04:39:36 <edwardk_> so you can work with in a 'Scene a' monad where its not 'tracking IDs' but is the substitution grafting expressions at the leaves
04:39:37 <mm_freak_> Let :: MyTree a -> MyTree (Maybe a) -> MyTree a
04:39:58 <phaazon_> hm
04:40:01 <phaazon_> so hm
04:40:09 <mm_freak_> phaazon_: search for "i'm not a number, i'm a free variable"…  there is an article that explains the concept
04:40:19 <mm_freak_> and once you understood it, you can use 'bound' to make your life a lot easier
04:40:28 <phaazon_> er, what would it look like having a material shared among models?
04:40:34 <edwardk_> phaazon_: an alternative is to think of it this way rotate :: Rotation -> Scene a -> Scene a -- should take a scene to a scene -- that can do it several ways
04:40:36 <phaazon_> mm_freak_: edwardk_ already gave me that link
04:40:40 <phaazon_> I just don’t get it
04:40:59 <mm_freak_> phaazon_: then get coding…  write a simple evaluator for arithmetic expressions
04:41:07 <edwardk_> it can put a Rotate node in the tree or it can walk down the tree and merge the rotation in from the outside in rewriting the entire syntax tree as it goes
04:41:18 <mm_freak_> data Expr a = Add (Expr a) (Expr a) | Var a
04:41:22 <phaazon_> mm_freak_: I know what an AST is
04:41:31 <mm_freak_> phaazon_: once you have an evaluator, add a Let clause to the type
04:41:31 <Lutin_> Is this the thing now?
04:41:43 <phaazon_> I don’t get how it’d be useful for a scene
04:41:47 <mm_freak_> data Expr a = Add (Expr a) (Expr a) | Let Int (Expr (Maybe a)) | Var a
04:41:51 <phaazon_> mm_freak_: Let would be a binder?
04:41:55 <mm_freak_> phaazon_: exactly
04:41:59 <phaazon_> why Maybe ?
04:42:14 <mm_freak_> phaazon_: within the let-expression Nothing represents the bound value
04:42:20 <mm_freak_> and Just x is a free variable of name x
04:42:33 <phaazon_> so you can’t bind several values?
04:42:38 <mm_freak_> phaazon_: it's really just a type-safe encoding of DeBruijn indices
04:42:39 <phaazon_> you have to nest two Let?
04:42:46 <mm_freak_> phaazon_: you can with 'bound' =)
04:42:56 <mm_freak_> this is just a simple example problem
04:42:59 <phaazon_> ok
04:43:06 <phaazon_> so you still have indices, since you have Int
04:43:17 <mm_freak_> no, the Int is the bound value
04:43:26 <mm_freak_> data Expr a = Add (Expr a) (Expr a) | Let (Expr a) (Expr (Maybe a)) | Var a
04:43:36 <phaazon_> isn’t it an ID to know which bound variable is?
04:43:40 <mm_freak_> Nothing represents Let's first argument expression within the second argument expression
04:43:42 <phaazon_> oh
04:43:42 <phaazon_> ok
04:43:49 <edwardk_> phaazon_: the trick is they are all _local_ notions of indexing relative to the let or whatever they are working with
04:44:01 <phaazon_> so instead of using IDs
04:44:03 <edwardk_> phaazon_: nobody had to make up global IDs
04:44:08 <phaazon_> you use… the host language bindings?
04:44:23 <mm_freak_> phaazon_: you encode the index is the number of applications of Just
04:44:28 <edwardk_> phaazon_: the host language bindings is the trick of phoas. bound is based on polymorphic recursion.
04:44:40 <edwardk_> phaazon_: they are different ways to accomplish the same goal
04:44:44 <mm_freak_> Nothing = 0, Just Nothing = 1, Just (Just Nothing) = 2, Just (Just (Just x)) = free variable x
04:44:48 <phaazon_> polymorphic recursion?
04:44:49 <edwardk_> bound is much nicer to work with when you want to rewrite the syntax tree
04:45:14 <phaazon_> hm
04:45:22 <edwardk_> phaazon_: bound gives you a monad transformer you can use to deal with name capture.
04:45:28 <phaazon_> I installed bound yesterday, and tried to have fun with it, but… :D
04:45:28 <edwardk_> the idea is say you have an expression Exp
04:45:31 <Lutin_> edwardk_: What was the link phaazon_ was talking about
04:45:47 <mm_freak_> phaazon_: when you have nested Let bindings, in the innermost expression Nothing represents the inner binding and Just Nothing the outer binding
04:45:52 <edwardk_> and you want to write a lambda in it, then you need to capture some of the names
04:45:56 <phaazon_> Lutin_: http://fr.reddit.com/r/haskell/comments/29c9dt/interpreters_how_should_it_be_done/ everything is there
04:46:09 <phaazon_> mm_freak_: yep, ok! got that
04:46:23 <phaazon_> I think I should do the arithmetic AST
04:46:24 <edwardk_> bound gives you a trick that makes it easy to do this via its monad transformer. you can 'abstract' to capture names and 'instantiate' to unbind them
04:46:27 <phaazon_> with bindable expressions
04:46:29 <mm_freak_> phaazon_: yes, do it
04:46:35 <Lutin_> edwardk: Also I started reading Conceptual Mathematics. Slow but is a nice refresher on mappings in general
04:46:45 <edwardk_> Lutin_: yeah, i warned it was slow =)
04:46:59 <mm_freak_> phaazon_: once you have the AST working you will want to write a few useful combinators (later 'bound' will give you them for free)
04:47:14 <phaazon_> ok so I write down the grammar
04:47:14 <phaazon_> like
04:47:23 <phaazon_> data E = Add Int Int | Sub Int Int…
04:47:29 <edwardk_> no
04:47:32 <Lutin_> edwardk_: My campus library has a copy of Algebra: Chapter 0 I might pick up later today
04:47:43 <phaazon_> data E = V Int | Add E E | Sub E E
04:47:46 <edwardk_> data E a = Var a | Add (E a) (E a) | Sub (E a) (E a)
04:47:48 <mm_freak_> phaazon_: you must have the variable type as the last argument
04:47:53 <edwardk_> you want your vars to be any type
04:48:01 <edwardk_> now E can be made a monad!
04:48:11 <phaazon_> ok
04:48:13 <phaazon_> gonna try that
04:48:22 <Lutin_> A freeeee monad
04:48:25 <mm_freak_> phaazon_: this is necessary for local indexing to work, because you will override the variable type in bindings
04:48:27 <edwardk_> Var a >>= f = f a; Add l r >>= f = Add (l >>= f) (r >>= f); ...
04:48:49 <mm_freak_> remember:  Let :: Expr a -> Expr (Maybe a) -> Expr a
04:48:59 <mm_freak_> see how the inner expression has a different variable type
04:49:03 <edwardk_> when you want to go define a 'Let' binding you can use mm_freak_'s Maybe encoding or you can turn to bound.
04:49:15 <edwardk_> but try writing it mm_freak_ 's way first by hand to get a feel for whats going on
04:49:22 <edwardk_> because then what bound does for you becomes obvious
04:49:32 <phaazon_> yep
04:49:41 <phaazon_> I’m writting it now :)
04:49:41 <mm_freak_> phaazon_: and just to explain how to get multiple bindings, this is the basic idea:
04:50:01 <mm_freak_> Let :: (i -> Expr (Either i a)) -> Expr (Either i a) -> Expr a
04:50:02 <phaazon_> edwardk_: it’s funny
04:50:10 <phaazon_> I already wrote an AST like that
04:50:26 <phaazon_> but I failed to… introduced substitution to represent functions :)
04:50:27 <edwardk_> phaazon_: well, you _did_ ask what i thought of your design. so i figured i should give a fully honest answer ;)
04:50:33 <mm_freak_> now not only you get multiple bindings, but the bindings themselves can refer to each other — recursion
04:51:03 <edwardk_> phaazon_: its that ability to turn an 'algebra' into a calculus by adding variables and bindings that is key to making all this compiler tech we know how to write useful ;)
04:51:38 <mm_freak_> substitution is a real pain in all traditional representations, but in the locally nameless representation it's trivial
04:51:41 <mm_freak_> it's just (>>=) =)
04:52:03 <phaazon_> edwardk_: so an algebra doesn’t have any notion of variables whereas calculus does?
04:52:44 <edwardk_> phaazon_: that is one pithy way folks like to phrase the divide. you'll never get universal consensus. algebra means too many things to too many people
04:53:02 <mm_freak_> and the type system will not allow you to accidentally mess up local bindings…  a guarantee that i don't want to miss again
04:53:25 <phaazon_> mm_freak_: thank you :)
04:53:37 <phaazon_> edwardk_: ok, sounds complex :/ thank you !
04:56:53 <mm_freak_> there might be some consensus…  algebra is about relationships, while i think that calculus is usually about computation
04:57:11 <mm_freak_> but then of course there is "calculus"…  the theory of infinitesimal changes…
04:58:19 <dabd> going through brent yorgey's course week 2 homework. Could someone please give an opinion on this function? https://gist.github.com/dabd/36a16677db2b39f7ed63#file-gistfile1-hs  Is the layout ok or should I break it in 80 columns? Better ways to implement the pattern matching on strings?  Thanks
04:58:58 <mm_freak_> dabd: i would have put the 'case' on the next line
04:59:26 <Iceland_jack> dabd: You can omit the parentheses
04:59:28 <dabd> mm_freak_ with 2 spaces indent?
04:59:35 <mm_freak_> dabd: alternatively you can do this:  parseMessage = f . words where …
04:59:53 <mm_freak_> dabd: i tend to indent the 'case' itself by four spaces, but the individual patterns by only two
04:59:58 <mm_freak_> case x of
04:59:59 <mm_freak_>   y -> …
05:00:24 <mm_freak_> also yes, you can omit the parentheses, but i prefer to leave them for readability
05:00:46 <Iceland_jack> I remove them for readability :)
05:01:07 <phaazon_> edwardk_: er, something might be wrong with my stuff
05:01:09 <mm_freak_> Iceland_jack: i found that the arrow is easier to find when you haven't looked at the code for a few months
05:01:15 <dabd> remove the parenthesis in the patterns or on the right side of ->?
05:01:26 <mm_freak_> dabd: in the patterns
05:01:27 <Iceland_jack> I guess I depends a  lot on the complexity of the match
05:01:38 <mm_freak_> Iceland_jack: in this case i'd definitely leave them in
05:01:42 <mm_freak_> it's not just "x:xs"
05:02:19 <phaazon_> edwardk_: https://gist.github.com/phaazon/271894c3b3d1f1399187
05:02:25 <phaazon_> I’m a bit surprised by the monadic result
05:02:32 <dabd> in the examples i found in the RWH, LYAH they tend to use parenthesis around the patterns
05:03:03 <phaazon_> I’d expect a Mul, not an Add
05:03:07 <skrio> Can anyone explain what the @ does in haskell? The book I'm using isn't explaining it very clearly. It simply replaces (x:y:zs) with (x: r@(y:_)) and uses the binding r instead of (y:zs) instead.
05:03:09 <mm_freak_> dabd: it makes sense, because in function bindings you get used to (x:xs), so you need less cognitive power to recognise a list pattern
05:03:21 <mm_freak_> dabd: it also helps your brain to tell patterns from constructions apart
05:03:26 <phaazon_> x <- Add (Var 3) (Var 1)
05:03:30 <mm_freak_> (x:xs) -> y : ys
05:03:31 <phaazon_> isn’t x the result of the add?
05:03:44 <mm_freak_> dabd: that's just more readable than x:xs -> y : ys
05:04:07 <phaazon_> oh
05:04:11 <phaazon_> no
05:04:22 <phaazon_> bind pass the value inside
05:04:23 <phaazon_> hm
05:04:29 <phaazon_> so it duplicates
05:04:32 <mm_freak_> phaazon_: (>>=) substitutes
05:04:40 <phaazon_> yeah
05:04:44 <dabd> The first pattern match is still a long line. How would you break it? https://gist.github.com/dabd/36a16677db2b39f7ed63#file-gistfile1-hs
05:04:49 <mm_freak_> so after the "<-" you're within the two variables
05:04:58 <mm_freak_> (Var 3) and (Var 1)
05:05:01 <phaazon_> so mm_freak_
05:05:03 <phaazon_> basically
05:05:06 <zwer> mm_freak_ does that help you in here?  (x:xs) -> f (x:xs)
05:05:08 <phaazon_> x <- Add (Var 3) (Var 1)
05:05:16 <zwer> (x:xs) -> f (y:ys) even
05:05:16 <phaazon_> x represents the subistitution of the Add?
05:05:32 <mm_freak_> phaazon_: it represents the leaves of the Add
05:06:02 <phaazon_> ahah
05:06:06 <mm_freak_> zwer: it does, because i see the function application
05:06:06 <phaazon_> that’s so awesome
05:06:30 <mm_freak_> phaazon_: you can actually substitute this way with some nice syntax
05:06:33 <aristid-ic_> i so i want to have some kind of strict type evaluation in a GADT, as laziness seems to be the default:
05:06:34 <aristid-ic_> http://lpaste.net/106464
05:06:45 <mm_freak_> do v <- expr; if v == "var1" then … else Var v
05:07:09 <mm_freak_> phaazon_: if it's the variable var1, then substitute, otherwise leave the variable untouched
05:07:25 <aristid-ic_> it seems that Identity :: Path a can be instantiated with undefined types (note that Lookup is partial)
05:08:01 <aristid-ic_> i'm wondering if there's a way i can force it to be evaluated fully?
05:08:22 <zwer> mm_freak_, the point is your "parenthesis = pattern match, no parenthesis = construction" preference no longer holds true. you have to look at the context regardless if you use parenthesis or not
05:08:34 <mm_freak_> zwer: i agree
05:09:31 <phaazon_> do { x <- Sub (Var 3) (Var 100); Add (Var x) (Var 9) }Sub (Add (Var 3) (Var 9)) (Add (Var 100) (Var 9))
05:09:35 <phaazon_> er…
05:09:45 <phaazon_> I don’t really understand what’s happening there
05:09:45 <aristid-ic_> hah, i first thought "hey, (x:xs) -> f (x:xs) is not a valid type" but i guess it's just a case statement
05:09:47 <mm_freak_> zwer: but this is not a formal topic…  all these are little ways to help your brain to read code faster
05:10:09 <aristid-ic_> to make the type valid it has to be (x ': xs) -> f (x ': xs), i think:)
05:10:16 <mm_freak_> phaazon_: you have two variables there, called "3" and "100"
05:10:29 <mm_freak_> phaazon_: the remainder of the do-block is their substitution
05:10:30 <aristid-ic_> hmm no, functions need kind *
05:10:51 <mm_freak_> phaazon_: remember that 3 and 100 are /names/
05:11:06 <mm_freak_> this may become clearer if you use strings rather than integers
05:11:47 <mm_freak_> phaazon_: to have actual values that you can add and subtract you need a further constructor
05:11:54 <mm_freak_> data Expr a = Lit Integer | …
05:12:17 <phaazon_> yeah I’m really lost.
05:12:24 <phaazon_> x <- Var 3 - Var 100
05:12:27 <phaazon_> basically
05:12:28 <phaazon_> then
05:12:31 <phaazon_> Var x + Var 9
05:12:36 <phaazon_> how should I read that :D
05:12:39 <mm_freak_> 'Expr String' is an expression with variable /names/ of type String
05:13:09 <mm_freak_> Let 3 `Add` Var "x"
05:13:13 <mm_freak_> represents:  3 + x
05:13:20 <mm_freak_> where x is a free variable
05:13:24 <phaazon_> yes
05:13:31 <mm_freak_> uhm
05:13:35 <mm_freak_> Lit 3 `Add` Var "x"
05:13:38 <mm_freak_> sorry, typo
05:13:49 <phaazon_> Lit for literal?
05:13:52 <mm_freak_> yeah
05:14:12 <mm_freak_> now add a Let:  Let (Lit 5) (Lit 3 `Add` Var Nothing)
05:14:26 <mm_freak_> the Nothing represents the innermost binding, so Lit 5
05:14:30 <mm_freak_> the overall result is then 3 + 5
05:14:35 <aristid-ic_> nevermind my weird datakind problem, i think i have a workaround :P
05:14:36 <phaazon_> yeah
05:14:38 <phaazon_> got that
05:14:50 <phaazon_> I just have difficulties to understand the monad version
05:15:03 <phaazon_> x <- Sub (Var 3) (Var 100)
05:15:07 <phaazon_> this is basically like
05:15:16 <phaazon_> Sub (Var 3) (Var 100) >>= \x -> …
05:15:19 <mm_freak_> phaazon_: well, think about it…  how do you represent a variable?  as a function that takes a name and results in an expression
05:15:28 <mm_freak_> variable :: a -> Expr a
05:15:36 <mm_freak_> and that just happens to match the type of 'return'
05:15:36 <phaazon_> so here, x is… OH
05:15:37 <phaazon_> ok
05:15:48 <phaazon_> it’s the either Var 3 and Var 100
05:16:01 <phaazon_> okok
05:16:02 <phaazon_> got it
05:16:17 <mm_freak_> how do you represent substitution?  you take an expression and a function that takes variable names and returns replacement expressions
05:16:24 <phaazon_> yes
05:16:29 <mm_freak_> substitute :: (a -> Expr b) -> Expr a -> Expr b
05:16:32 <mm_freak_> and that's just flip (>>=)
05:17:38 <phaazon_> so, Sub (Var 3) (Var 100) >>= \x -> Add (Var x) (Var 30) results in… Sub (Add (Var 3) (Var 100)) (Add (Var 3) (Var 30))
05:17:41 <phaazon_> right?
05:18:01 <mm_freak_> try it out…  derive Show for Expr =)
05:18:16 <phaazon_> sounds to be that yeah!
05:18:17 <phaazon_> ok
05:18:21 <phaazon_> now, let’s write the Let!
05:18:23 <mm_freak_> you can also make it a bit more readable by using infix constructors and by adding Num and IsString instances
05:18:38 <phaazon_> ah
05:18:41 <mm_freak_> then you can actually write '3 + "x"'
05:18:42 <phaazon_> good point :D
05:18:47 <mm_freak_> rather than Add (Lit 3) (Var "x")
05:19:36 <mm_freak_> writing Let will hold a little surprise…  just try it =)
05:24:00 <phaazon_> why should Lit be Integer?
05:24:13 <mm_freak_> phaazon_: you can use whatever you want
05:24:25 <mm_freak_> use Double if you prefer
05:24:35 <phaazon_> is it even mandatory?
05:24:55 <mm_freak_> without Lit you only have variables and no literals
05:25:09 <mm_freak_> in particular you won't be able to write a finite closed expression anymore
05:25:24 <phaazon_> hm
05:25:47 <phaazon_> mm_freak_: something I don’t get
05:25:52 <phaazon_> how should I mix types?
05:26:08 <mm_freak_> one way is to use a GADT
05:26:14 <phaazon_> like, writing an AST with different types at leaves? for instance, connecting materials to meshes
05:26:31 <mm_freak_> LitInt :: Integer -> Expr Integer a
05:26:38 <mm_freak_> LitDouble :: Double -> Expr Double a
05:26:59 <phaazon_> ok
05:27:02 <phaazon_> tricky
05:27:16 <phaazon_> and hm
05:27:17 <phaazon_> Var a
05:27:21 <phaazon_> it’s a free variable, right?
05:27:30 <phaazon_> like a constant
05:27:52 <mm_freak_> it's a variable
05:28:01 <mm_freak_> can be bound or free depending on context
05:28:28 <phaazon_> yeah
05:28:29 <phaazon_> so
05:28:35 <phaazon_> Var x >>= \y
05:28:38 <phaazon_> here it’s bound, right?
05:28:53 <mm_freak_> x could be anything, so it could be bound or free
05:30:09 <phaazon_> ok
05:30:16 <phaazon_> I think I’m starting to understand :D
05:30:39 <haasn> Var x >>= \y -> if isBound y then lookup y else Var x  ?
05:30:45 <haasn> Var y*
05:30:55 <mm_freak_> yeah
05:30:59 <mm_freak_> and remember the monad laws
05:31:04 <mm_freak_> Var x >>= f = f x
05:31:47 <mm_freak_> haasn: btw, 'lookup' won't work there
05:32:04 <haasn> Oh, the GADT thing is interesting; my first reflex was “doesn't that break the monad laws then” but I see you're still leaving the variable type abstract
05:32:34 <mm_freak_> haasn: it has to be abstract, otherwise you couldn't even write an instance
05:32:42 <mm_freak_> return :: forall a. a -> Expr a
05:34:57 <mm_freak_> but you can probably carefully construct a valid Bind with a restricted Var
05:36:22 <jonathan2> Hi. I have a situation like this: let result1 = f a   result2 = g a, where f and g are independent from each other and take a long time to execute. Is there a simple way to parallelize them? (executing them in parallel is easy enough, but I don't know how to do it within the let-in)
05:36:46 <Iceland_jack> joneshf: are they pure functions?
05:37:02 <Iceland_jack> if so then they're excellent candidates for par/seq
05:37:08 <mm_freak_> jonathan2: result1 `par` result2 `pseq` y
05:37:28 <mm_freak_> jonathan2: remember to give them names (result1 and result2)
05:38:07 <jonathan2> Wait, how does this put the values into result1 and result2?
05:38:17 <Iceland_jack> jonathan2: par/pseq can be a bit brittle so you may want to use monad-par
05:38:18 <jonathan2> Iceland_jack: I'm not sure what a pure function is, I'm new to this
05:38:28 <mm_freak_> jonathan2: it doesn't "put" them there…  they are already there
05:38:38 <Iceland_jack> jonathan2: A pure function is something that doesn't have side effects
05:38:39 <mm_freak_> you defined result1 and result2 as those values
05:38:56 <mm_freak_> jonathan2: in this context a pure function is a function with a non-IO result
05:39:02 <jonathan2> Ok, think I get it
05:39:15 <jonathan2> Iceland_jack: and yes, then they are pure :)
05:39:23 <mm_freak_> alternatively you can use a tuple strategy
05:39:56 <Iceland_jack> jonathan2: http://hackage.haskell.org/package/monad-par-0.3.4.6/docs/Control-Monad-Par.html I tend to prefer this but your example is so simple you probably don't need it
05:40:13 <mm_freak_> example: let res@(res1, res2) = (f x, g x) in h (res `using` parTuple2 rdeepseq rdeepseq)
05:40:30 <mm_freak_> jonathan2: the best way to learn parallel/concurrent programming in haskell is to read The Book =)
05:40:39 <Iceland_jack> The Book :)
05:40:43 <mm_freak_> jonathan2: http://chimera.labs.oreilly.com/books/1230000000929
05:40:55 <Iceland_jack> @google Simon Marlow's Parallel and Concurrent Programming in Haskell
05:40:57 <lambdabot> http://chimera.labs.oreilly.com/books/1230000000929
05:40:57 <lambdabot> Title: Parallel and Concurrent Programming in Haskell
05:42:04 <jonathan2> Thanks for the help :)
05:42:37 <mm_freak_> i prefer data parallel haskell over Par
05:42:44 <mm_freak_> so strategies, repa, etc. =)
05:43:15 <mm_freak_> in this particular case i'd use a tuple strategy
05:43:46 * hackagebot tasty-golden 2.2.2 - Golden tests support for tasty  http://hackage.haskell.org/package/tasty-golden-2.2.2 (RomanCheplyaka)
05:43:50 <dabd> continuing with brent yorge's course homework 2, in the definition of insert https://gist.github.com/dabd/56399e9ec63f071f58a2#file-gistfile1-hs I get a 'pattern matches are non-exhaustive ... patterns not matches (LogMessage _ _ _) (Node _ (Unknown _) _)'
05:44:03 <dabd> Isn't the first equation for insert supposed to cover this case?
05:44:39 <jonathan2> Just another question. How do I know if they are actually run in parallel or not? Is there some profiling parameter to see where they get scheduled or something like that?
05:44:51 <mm_freak_> dabd: in your last clause your node might contain not a LogMessage
05:45:00 <mm_freak_> dabd: you don't cover the Unknown case
05:45:09 <Iceland_jack> jonathan2: You can use threadscope to check
05:45:21 <Iceland_jack> if your example is large enough
05:45:34 <mm_freak_> jonathan2: an easy way to do this is to use 'time', if you're under linux/unix
05:45:36 <jonathan2> Iceland_jack: thanks :)
05:45:41 <nicoo> dabd: The first case covers Unknown as a first argument, not as a second
05:45:45 <mm_freak_> jonathan2: just compare real time to user time =)
05:46:06 <mm_freak_> if real time is roughly 2x user time, you had very good 2-parallelisation =)
05:46:43 <mm_freak_> nicoo: it covers /anything/ as the second argument
05:46:50 <dabd> but I can't never have a MessageTree with Unknown as a node
05:47:05 <mm_freak_> dabd: the type system does not know that
05:47:19 <mm_freak_> dabd: if this is really impossible, you need a type-level encoding for it
05:47:35 <mm_freak_> for example rather than adding the Unknown constructor to LogMessage, simply use Either X LogMessage
05:47:50 <mm_freak_> then a tree would use LogMessage, but 'insert' would use Either X LogMessage
05:47:58 <mm_freak_> for some suitable type X
05:47:59 <nicoo> mm_freak_: What I meant is that dabd seemed to be under the impression that the fist case covered (LogMessage _ _ _) (Node _ (Unknown _) _)
05:48:04 <dabd> mm_freak I don't think at this point in the course we were introduced to Either
05:48:30 <mm_freak_> dabd: oh…  just make a separate type that includes lack of a log message then
05:49:08 <mm_freak_> data MaybeLogMessage = NoLogMessage | JustLogMessage LogMessage
05:49:14 <jonathan2> mm_freak_: Even before, real time was 10x higher than user time when I used time? :P
05:49:32 <mm_freak_> jonathan2: then your system might be very loaded =)
05:49:44 <mm_freak_> or you're doing a lot of I/O
05:50:03 <mm_freak_> oh wait…  user time must be 2x real time, sorry
05:50:14 <mm_freak_> real time: 2s, user time: 4s
05:50:25 <mm_freak_> that means you used the equivalent of two cores to compute the result
05:51:18 <dabd> I tried this https://gist.github.com/dabd/56399e9ec63f071f58a2#file-gistfile1-hs
05:51:43 <jonathan2> mm_freak_: this can't be correct. User-time always shows something < 0.5s
05:51:45 <dabd> It compiles but it doesn't seem right to return a Leaf when in fact I want to return nothing
05:51:57 <dabd> but at this point in the course we were not introduced to Maybe
05:52:06 <mm_freak_> jonathan2: that's weird
05:52:13 <jonathan2> mm_freak_: Even the times when the computations make my computer almost crash
05:52:52 <mm_freak_> jonathan2: are you in a VM?  or are you perhaps using cgroups?
05:53:24 <jonathan2> Not in a VM. I don't know what cgroups are, so I assume I'm not using them :)
05:53:56 <mm_freak_> in a regular desktop installation of linux you're not using cgroups =)
05:54:09 <mm_freak_> but then there is ubuntu, which always insists on being weird, so what do i know =)
05:54:15 <cariveri> hi. how to mark a line as literal string which may include special characters from the haskell language ?
05:54:40 <jonathan2> mm_freak_: ehm, I figured it out. It's so stupid, I won't even say what I was doing wrong :)
05:55:02 <mm_freak_> cariveri: could you explain?  you can escape special characters in regular strings
05:55:07 <mm_freak_> "abc\ndef"
05:55:40 <aristid-ic_> when i write haskell the LANGUAGE line almost always gets immense
05:55:41 <mm_freak_> jonathan2: i'd find that interesting, though, but i won't compel you =)
05:55:55 <mm_freak_> aristid-ic_: you can use multiple LANGUAGE lines…  i do that
05:56:01 <cariveri> mm_freak_: I dont want to excape hundreds of special characters. I hope there is something like 'whatever'
05:56:10 <aristid-ic_> mm_freak_: yeah but then i waste more space
05:56:34 <mm_freak_> cariveri: not really…  you could put it in a file and load it at run-time or link it and refer to it via the FFI
05:56:58 <Lutin_> mm_freak_: User time is cpu time spent in user space
05:57:02 <jonathan2> mm_freak_: the number comes up first, then the name of what used it, i.e. 0.48 user 0.02 would mean 0.48s for user, not 0.02 as I thought
05:57:04 <cariveri> oh really. I expected it to be essential.
05:57:06 <Lutin_> sys time is time spent in kernel
05:57:15 <Lutin_> real time is actual time
05:57:21 <mm_freak_> aristid-ic_: cabal allows you to set default extensions for your package, so that you don't have to write most LANGUAGE pragmas
05:57:31 <mm_freak_> aristid-ic_: i put everything there except UndecidableInstances
05:57:49 <aristid-ic_> mm_freak_: does cabal ghci respect them?
05:57:52 <Lutin_> so if you have 2 cores and your entire program uses 100% both CPUs and doesn't spend time in system calls then it would be 2x real time
05:57:52 <mm_freak_> Lutin_: i know
05:58:03 <Lutin_> oh sorry
05:58:07 <mm_freak_> no, in this case it's 2x user time
05:58:14 <aristid-ic_> mm_freak_: last time i tried using cabal for that, i got frustrated because back then there was no cabal ghci
05:58:27 <mm_freak_> when running a 2-parallel program i get, say, 30s user, 15s real
05:58:34 <Lutin_> Yeah
05:58:41 <Lutin_> user = 2*real
05:58:51 <Lutin_> or 2x realtime
05:59:00 <Lutin_> which is what I said :P
05:59:16 <mm_freak_> jonathan2: i have a custom 'time' format…  maybe the interpretation of your 'time' line is different
05:59:31 <Lutin_> jonathan2: What's the time output?
05:59:57 <mm_freak_> jonathan2: this is what it looks like here:
05:59:57 <mm_freak_> % time ./primes {100..200} +RTS -N4 > /dev/null ** timings:  real 0.950  user 3.152  krnl 0.308  cpu% 364%  mem 6k
06:00:01 <mm_freak_> oops
06:00:10 <mm_freak_> % time ./primes {100..200} +RTS -N4 > /dev/null
06:00:12 <mm_freak_>  ** timings:  real 0.950  user 3.152  krnl 0.308  cpu% 364%  mem 6k
06:00:31 <mm_freak_> so i used the equivalent of 3.64 cores to compute the result
06:02:04 <mm_freak_> jonathan2: if you want to test this, the code is here:  http://lpaste.net/106465
06:02:28 <mm_freak_> it uses an efficient sieving method to find safe primes of the given size…  you will need the 'arithmoi' library to compile it
06:02:54 <mm_freak_> just run it like this to make it parallel:  ./primes 1000 1001 1002 1003 +RTS -N
06:05:59 <jonathan2> Lutin_: it's all correct in the time output :)
06:08:22 <jonathan2> mm_freak_: That will come in handy the next time I'm solving project euler problems. Never bothered writing a good sieve :)
06:08:27 <miyako> hello
06:08:40 <mm_freak_> jonathan2: it's a safe prime sieve, not a general prime sieve
06:08:57 <mm_freak_> jonathan2: it finds primes of the form p = 2*q + 1, where q is also prime
06:09:27 <jonathan2> too bad :) (That'll probably be handy too, if you have experience with PE)
06:09:42 <mm_freak_> wait a minute
06:10:16 <mm_freak_> jonathan2: http://lpaste.net/101980
06:10:19 <miyako> I started working on an article a while ago about the FFI and never really finished it, I was just looking at it again and I'm not sure if it's worth finishing since the haskell wiki seems to have good FFI documentation now.  Would anyone mind taking a look and giving me their opinion?
06:10:30 <miyako> http://www.rebeccaskinner.net/blog/2013/09/07/understanding-the-haskell-ffi/
06:12:21 <jonathan2> mm_freak_: thank you :)
06:13:10 <_deepfire> is it possible to expose a hidden package?
06:13:19 <_deepfire> er
06:13:29 <_deepfire> a hidden module
06:13:48 * hackagebot tasty-golden 2.2.2.1 - Golden tests support for tasty  http://hackage.haskell.org/package/tasty-golden-2.2.2.1 (RomanCheplyaka)
06:13:59 <_deepfire> Could not find module 'Foo' it is a hidden module in the package 'Bar'
06:14:39 <mm_freak_> jonathan2: you will have to refactor the sieve into a separate function…  i should probably put it into a package some day
06:15:10 * knapper_tech is away: give me peace at last.  too long today.
06:15:11 <jonathan2> I'll probably be able to figure that out :)
06:16:21 <_deepfire> The answer I'm obtaining so far through google is that opening hidden modules isn't possible.
06:17:11 <_deepfire> ..and no, the names I'd want to use are not re-exported, unfortunately..
06:19:50 <mm_freak_> jonathan2: if you have trouble, look at the old version…  it's linked in the comments
06:20:40 <bollu> how do I purge cabal and then reinstall?
06:21:00 <mm_freak_> bollu: cabal-install itself or the stuff you installed through it?
06:21:01 <bollu> on mavericks if that matters
06:21:12 <mmmm_> _deepfire: As far as I understand that happens when a package you use depends on the package you want but you haven't specified that specific package you want in your cabal file
06:21:23 <mmmm_> so just list it in your cabal file and you should be done
06:21:24 <bollu> mm_freak_: cabal-install and all associated files  (along with stuff installed through it)
06:21:51 <bollu> mm_freak_: I created a new user account on my OS; that seems to have screwed things up badly. I'd like to start over
06:22:24 <mm_freak_> bollu: well, first figure out what files got installed…  install it into some prefix
06:22:49 <mm_freak_> then you need to clear GHC's registry (if you use GHC) and all the packages that you installed globally, if any
06:23:02 <bollu> mm_freak_: yeah, I use GHC
06:23:05 <_deepfire> mmmm_, there's no cabal involved -- it's a single .hs file..
06:23:08 <Lutin_> bollu: Are you on the new user?
06:23:12 <mm_freak_> if you didn't perform any global installations, then you're done by simply removing cabal's files
06:23:33 <Lutin_> _deepfire: What are the module and the package?
06:23:35 <mm_freak_> if you installed cabal globally and messed up a certain user, there is no reason to reinstall cabal itself
06:23:40 <bollu> Lutin_: sort of. I've used haskell in the past to muck about with concepts, but this is the first time I'm embarking on a "project" in haskell
06:23:48 <Lutin_> bollu: Ah
06:23:49 * hackagebot tasty-golden 2.2.2.2 - Golden tests support for tasty  http://hackage.haskell.org/package/tasty-golden-2.2.2.2 (RomanCheplyaka)
06:23:49 <mm_freak_> just clear ~/.cabal and ~/.ghc
06:23:53 <Lutin_> ^
06:23:59 <bollu> mm_freak_: clear = rm -rf ?
06:24:07 <Lutin_> that works
06:24:11 <bollu> cool
06:24:11 <_deepfire> Lutin_, hw2gitit.hs:25:8:  Could not find module `Text.Pandoc.Parsing' it is a hidden module in the package `pandoc-1.12.4.2'
06:24:15 <mm_freak_> bollu: yes…  make sure you don't have any cabal settings you would like to keep
06:24:16 <bollu> will try and get back
06:24:23 <bollu> mm_freak_: nothing of the sort
06:24:23 <mm_freak_> bollu: review ~/.cabal/config and ~/.cabal/world
06:24:50 <mm_freak_> also you may want to keep ~/.cabal/packages, if you're on a slow internet connection
06:25:01 <Lutin_> _deepfire: Well that indeed is a hidden ilbrary
06:25:05 <Lutin_> module*
06:25:07 <_deepfire> https://github.com/deepfire/hw2gitit/blob/master/hw2gitit.hs
06:25:41 <bollu> Lutin_: I'm disliking cabal - this is the first time I've interacted with it a lot and it feels broken
06:25:50 <bollu> any tips or something?
06:25:59 <mm_freak_> bollu: the important thing is to keep in mind that it's not a package manager
06:26:03 <miyako> bollu: use gem for a while then decide how angry you are?
06:26:19 <Lutin_> lol miyako
06:26:25 <_deepfire> Lutin_, so there's nothing to be done for accessing that particular function?
06:26:28 <bollu> miyako: rbenv + gems = stability (sorta)
06:26:30 <mm_freak_> bollu: in particular there is no easy way to uninstall a package or update all packages safely
06:26:56 <mm_freak_> bollu: for your own projects, if you have cabal-install version 1.18 you can use sandboxes
06:26:57 <miyako> we use haskell and ruby at work, I find that cabal is more more dependable and easy to work with once you get accustomed to it
06:26:58 <bollu> mm_freak_: hmm. so the recommended way to do things is? use your os's package manager?
06:27:21 <mm_freak_> bollu: paradoxically no…  the recommended way is to use sandboxes for development
06:27:22 <miyako> although to be fair that's probably more to do with the haskell communities focus on correctness meaning that you don't constantly have broken packages
06:27:27 <bollu> mm_freak_: sandbox localizes your changes to a folder right?
06:27:34 <bollu> mm_freak_: hm, okay.
06:27:37 <mm_freak_> bollu: exactly
06:27:53 <bollu> mm_freak_: what if I want to use a package which has not been uploaded on hackage?
06:27:56 <mm_freak_> bollu: alternatively you can install nix and use that as a development/deployment tool
06:28:01 <bollu> package = library
06:28:03 <mm_freak_> (you don't need NixOS, just nix)
06:28:15 <mm_freak_> bollu: you can install that package from a local directory
06:28:26 <mm_freak_> bollu: sandboxes also allow you to add a package directory into the scope of your project
06:28:46 <mmmm_> In my experience, sandboxes just shift the problem..
06:28:53 <bollu> mm_freak_: so I build my package locally and "point" my project to the build folder?
06:28:57 <mm_freak_> then 'cabal configure' will automatically build and install the package into your project directory
06:28:58 <mmmm_> _deepfire: What do you need from Text.Pandoc.Parsing?
06:29:29 <_deepfire> mmmm_, defaultWriterOptions and defaultParserState
06:29:31 <bollu> mmmm_: cool. thanks for the info
06:29:36 <mm_freak_> bollu: you don't need to build the library first…  just download it somewhere…  cabal-install will built it by itself as necessary
06:29:45 <bollu> mm_freak_: oh, nice.
06:29:59 <bollu> mm_freak_: how do I "point" the sandbox to the local library directory?
06:30:06 <mm_freak_> mmmm_: that's why i use nix rather than cabal sandboxes =)
06:30:38 <mm_freak_> bollu: see:  cabal sandbox --help
06:30:40 <bollu> mm_freak_: how do I "point" the sandbox to the local library directory?
06:30:42 <mmmm_> _deepfire: That is exposed by a typeclass with a single definition def, use "readMarkdown def input" etc
06:30:44 <bollu> mm_freak_: will do :)
06:30:49 <mm_freak_> the 'add-source' subcommand will do it
06:30:54 <bollu> mmmm_: that's a gentle way of telling me to RTFM ;)
06:31:00 <bollu> mm_freak_: ^
06:31:25 <mm_freak_> bollu: i prefer being gentle =)
06:31:27 <_deepfire> mmmm_: thanks, will try!
06:31:38 <mm_freak_> but the real reason i want you to RTFM is that i'm not very experienced with sandboxes
06:31:39 <bollu> mm_freak_: I'll look into nix also
06:31:49 <_deepfire> Nix is the crack..
06:31:51 <mm_freak_> they are pretty similar to the now obsolete cabal-dev sandboxes, just better
06:31:56 <Lutin_> _deepfire: Use def instead
06:31:56 <mmmm_> _deepfire: If you have any more pandoc questions then feel free to ask me, I'm working on it for my GSoC project
06:32:02 <Lutin_> _deepfire: Ah that's what mmmm_ said
06:32:19 <Lutin_> Man I missed GSoC again :(
06:32:30 <_deepfire> Lutin_, mmmm_, thank you!
06:32:38 <bollu> oh cool, haskell has a JSON parser
06:32:54 <mm_freak_> haskell has /the/ JSON parser =)
06:32:56 <bollu> I just wish there was a format even simpler than JSON. config files with json get ugly fast
06:33:15 <mm_freak_> there are a number of configuration packages on hackage
06:33:19 <mm_freak_> like dyre
06:33:31 <mm_freak_> they use a simple section-key-value format
06:33:40 <Lutin_> _deepfire: They use https://hackage.haskell.org/package/data-default-0.5.3/docs/Data-Default.html now
06:33:50 * hackagebot tasty-golden 2.2.2.3 - Golden tests support for tasty  http://hackage.haskell.org/package/tasty-golden-2.2.2.3 (RomanCheplyaka)
06:33:54 <mm_freak_> for run-time configuration you can use acid-state
06:33:54 <bollu> mm_freak_: any others?
06:34:10 <mm_freak_> bollu: http://hackage.haskell.org/packages/#cat:Configuration
06:34:22 <Lutin_> bollu: There's https://github.com/toml-lang/toml
06:34:25 <bollu> mm_freak_: this is more of a application build system sort of thing
06:34:30 <_deepfire> I'm trying to get the NixOS wiki converted to pandoc-based gitit
06:34:47 <bollu> Lutin_: toml looks perfect :D
06:34:53 <bollu> did not know about it
06:34:57 <bollu> does haskell have a parser?
06:35:01 <mm_freak_> bollu: it's a deployment system
06:35:08 <mm_freak_> bollu: haskell has /the/ parsers =P
06:35:18 <Lutin_> But the haskell parser for it isn't on hackage
06:35:20 <mm_freak_> parsec, attoparsec, trifecta, etc.
06:35:22 <Lutin_> It's on here https://github.com/seliopou/toml
06:35:23 <bollu> mm_freak_: xD you seem quite confident about haskell's parsing abilities
06:35:27 <_deepfire> arguably, parsers didn't exist before Haskell..
06:35:30 <Lutin_> ^
06:35:31 <mm_freak_> bollu: i am =)
06:35:42 <bollu> Lutin_: so I have to do the local build thing? bummer
06:35:45 <bollu> Lutin_: even so, thanks
06:35:48 <mm_freak_> bollu: as someone who often needs to parse huge amounts of data…
06:35:51 <Lutin_> bollu: Yeah :[
06:36:03 <bollu> mm_freak_: what's your job descrition? :)
06:36:17 <Lutin_> Or I can msg the dev to see if they can put it on hackage
06:36:28 <Lutin_> It's old though, and a really simple format
06:36:38 <bollu> Lutin_: yeah, the format is simple but is perfect
06:37:02 <mm_freak_> bollu: currently i'm a freelance programmer of networking solutions
06:37:32 <mm_freak_> mostly managing VMs and passing large amounts of data around
06:37:41 <bollu> mm_freak_: cool! so you can use haskell in your job?
06:37:48 <mm_freak_> yes
06:38:12 <Lutin_> Sounds like you could use anything you want as long as it gets the job done
06:38:22 <luzie> toml doesn't have a formal grammar (yet) so i wouldn't call it perfect
06:38:24 <Lutin_> So Haskell it is!
06:38:29 <luzie> but that's being worked on now
06:38:32 <mm_freak_> Lutin_: pretty much, but using haskell has paid off
06:38:47 <Lutin_> Yeah I can imagine
06:38:47 <bollu> luzie: hm, poking around, it looks like Rust picked it up for cargo
06:38:54 <Lutin_> Yep
06:39:00 <bollu> luzie: I really should get back into the loop with Rust
06:39:13 <phaazon_> mm_freak_: #haskell-game
06:39:14 <bollu> been busy with life :|
06:39:24 <luzie> yes, they're pushing for a formal grammar for it
06:39:38 <bollu> luzie: won't the grammar be really simple though?
06:39:49 <luzie> sure
06:40:10 <Lutin_> I could probably write one up in a day
06:40:59 <bollu> Lutin_: what qualifies as "grammar" ?
06:41:51 <Lutin_> It's a set of production rules for the valid strings in the language
06:42:18 <Lutin_> There's several types of grammars
06:42:28 <bollu> Lutin_: context free / sensitive?
06:42:33 <luzie> https://github.com/toml-lang/toml/pull/199 has been open for over a year now
06:43:31 <Lutin_> hmm
06:43:34 <luzie> but toml was very recently revived after being pretty dead for a while
06:43:41 <Lutin_> Looks like I have a project
06:43:50 * hackagebot tasty 0.8.1.2 - Modern and extensible testing framework  http://hackage.haskell.org/package/tasty-0.8.1.2 (RomanCheplyaka)
06:45:29 <marchelzo_>  Is there a way to add a function to an existing module like Text.Regex so that I can use it whenever I import that module?
06:46:09 <Lutin_> luzie: And I think EBNF would be the way to go yeah?
06:46:25 <bollu> general question - how does one describe context sensitive grammamrs? like, BNF can describe context free grammars right? So what's the equivalent for sensitive?
06:46:31 <dabd> Could someone pls help me find what is wrong with the ex 5 function? https://gist.github.com/dabd/56399e9ec63f071f58a2#file-gistfile1-hs  I get a 'couldn't match expected type String with actual type LogMessage'
06:47:21 <Maxdamantus> bollu: basically just BNF, but with potentially multiple symbols on the left of the productions.
06:47:56 <bollu> Maxdamantus: hm, thanks
06:47:57 <luzie> Lutin_, that's a pull request with EBNF, but i think they're waiting until they've decided on some changes to toml
06:49:07 <bollu> http://coldwa.st/e/blog/2013-08-20-Cabal-sandbox.html <- this is reliable right?
06:49:41 <Maxdamantus> Just think of a parsing attempt as starting with the RHS of the initial symbol.
06:49:58 <Maxdamantus> Then you expand non-terminals inside that as you need to.
06:50:01 <Lutin_> bollu: Yeah you don't need to build from git though
06:50:29 <Maxdamantus> when it's context-free, you can expand sequences of non-terminals at once.
06:50:35 <Maxdamantus> er, context-sensitive*
06:51:24 <Lutin_> luzie: Yeah I'll post on that ticket in a bit
06:51:28 <Lutin_> See what the status is
06:51:35 <Lutin_> looks like it was updated 2 days ago
07:05:25 <bluebelle> @run let f = show
07:05:26 <lambdabot>  not an expression: ‘let f = show’
07:06:51 <bluebelle> @run let f = show in f
07:06:53 <lambdabot>  <() -> [Char]>
07:07:08 <luzie> :t show
07:07:09 <lambdabot> Show a => a -> String
07:07:57 <bluebelle> Why does DMR change the type to () -> [Char] ?
07:08:58 <bollu> hm, how do I disambiguate between two functions? http://pastebin.com/QetbzCYj
07:09:50 <bollu> I know that can like, create a custom function with the type definition I want and then equate that
07:09:56 <bollu> but is there a nicer way?
07:10:34 <bluebelle> bollu: import System.IO (hPutStrLn, yadda, yadda)
07:12:49 <bollu> bluebelle: did not help
07:13:19 <Tjr> bollu: import qualitifed Data.ByteString as B
07:13:22 <bluebelle> bollu : ah, you need to specify which function you import from Data.ByteString too
07:13:35 <Tjr> bollu: then write B.hPutStrLn for the bystrging version
07:13:48 <Tjr> s/qualitifed/qualified/
07:13:55 <bollu> Tjr: ah, thanks :)
07:14:00 <Tjr> s/bystrging/ByteString/
07:15:35 <Tjr> bollu: BTW, all this error handling code could be refactored out. Maybe use "catch" and move it into an error handler.
07:16:22 <bollu> Tjr: will try and do that, thanks!
07:16:53 <bollu> does one add the sandbox into source control?
07:16:58 <bollu> .cabal_sandbox that s
07:17:00 <bollu> is*
07:17:08 <Tjr> bollu: however, something tells me that other devs probably also open files, and some library function might already provide some way to "safely" open a file with all the bells and whistle.
07:17:17 <Guest70241> Can I inflate a new view in a fragment? or is better to switch between 2 fragments back and forth?
07:17:32 <augur> whats a good way to define a lattice-like structure in haskell?
07:17:47 <Tjr> augur: what's  a lattice?
07:17:56 <augur> ie, an enumeration type + a lattice ordering
07:17:57 <Tjr> augur: Even maths people don't agree
07:18:08 <augur> Tjr: er.. what?
07:19:00 <Tjr> banach space people have a different idea what a lattice is, compared to people doing random walks on Z^d.
07:19:35 <augur> uh.. lovely? i just need a standard lattice
07:19:45 <Tjr> well, what#s a standard lattice?
07:19:58 <augur> take your pick of the algebraic or relational definitions
07:21:07 <Tjr> a cocompact quotions of two groups?
07:21:11 <Tjr> *quotient
07:21:34 <augur> ok, be intentionally thick if you want.
07:21:36 <augur> anyway
07:21:41 <augur> actually, i probably just need a nice way to define a finite partial order
07:22:33 <augur> it'd be nice to be able to define the hasse diagram and derive a partial order from it
07:22:49 <augur> hmm
07:23:02 <augur> probably i could use a graph type for that
07:23:08 <bollu> I wish I understood a quarter of what you're saying ;_;
07:23:39 <augur> bollu: :x
07:25:06 <bollu> augur: I'm serious :(
07:25:41 <augur> in fact, probably i could do with just a tree structure, because sharing is possible. yes that should work
07:25:52 <augur> bollu: should i try to explain?
07:26:28 <bollu> augur: in high school terms?
07:26:37 <augur> bollu: probably cant be done
07:26:42 <bollu> augur: nvm then
07:26:48 <augur> :x
07:26:51 <uberwach> lol
07:26:55 <bollu> augur: I've read a bit of topology if it helps
07:27:08 <bollu> augur: and (very very little) category theory
07:27:52 <bollu> augur: is it explainable?
07:27:59 <augur> maybe
07:28:18 <bollu> augur: wanna try? I'd like to learn
07:28:54 * hackagebot cabal-debian 4.11 - Create a debianization for a cabal package  http://hackage.haskell.org/package/cabal-debian-4.11 (DavidFox)
07:29:10 <augur> bollu: probably you'd do better reading a book on abstract algebra, tbh
07:29:38 <bollu> augur: hm, probably. people told me to read topology, analysis and algebra after calc.
07:30:03 <uberwach> augur: I think the discrete math book by matousek and nesetril is a good start for high school students..
07:30:30 <bollu> http://www.amazon.com/Invitation-Discrete-Mathematics-Jiri-Matousek/dp/0198570422 this one?
07:31:03 <uberwach> yeah looks like it... the German edition is released by springer
07:31:26 <bollu> uberwach: what's the difference?
07:31:44 <uberwach> bollu: well the cover is hella different... and it is in German ;D
07:32:18 <uberwach> bollu: but yeah, that is the one I've meant.
07:33:05 <bollu> uberwach: well, I know graph theory (sorta, from algorithms) and set theory (again, sorta). would the book have anything a lot different?
07:34:22 <uberwach> bollu: it builds a foundation in mathematical thinking and discrete maths...
07:35:09 <uberwach> bollu: as a starter learning acquiring mathematical thinking is the no1 priority... you do not know shit in any area after some years of post-doc
07:35:14 <uberwach> *until after
07:35:35 <uberwach> *being.. sorry for sloppy grammar
07:35:40 <bollu> uberwach: xD doesn't programming foster mathematical thinking? :
07:35:59 <bollu> uberwach: np. english is not my first language!
07:36:23 <uberwach> bollu: if I give you a honest answer, people will hate me in this channel..
07:36:47 <bollu> uberwach: :)
07:37:09 <bollu> uberwach: hm, okay, I'll check the book out
07:37:21 <bollu> uberwach: have you read the book "algorithmic thinking" ?
07:37:35 <bollu> uberwach: that was a nice book in the same .. domain?
07:37:43 <uberwach> bollu: no, I do not read books. I study them :P
07:38:06 <bollu> uberwach: xD
07:38:53 <bollu> uberwach: any other books you'd recommend?
07:39:23 <uberwach> bollu: I loved the book of proofs by aigner and ziegler... I am biased though, because I know both.
07:39:44 <uberwach> bollu: also the Polya book about mathematical thinking is great imho
07:40:27 <uberwach> bollu: besides that, it depends on the area, but usually people have a specific taste so it is hard to answer...
07:40:31 <bollu> uberwach: what's the point of having a "book of proofs" with no context?
07:40:50 <uberwach> bollu: it is a collection of beautiful theorems and their proofs in different areas...
07:40:56 <bollu> uberwach: ah.
07:41:18 <bollu> uberwach: http://www.amazon.com/Proofs-THE-BOOK-Martin-Aigner/dp/3642008550 this one?
07:41:50 <uberwach> bollu: yes
07:42:12 <bollu> uberwach: hm, okay
07:43:23 <bollu> uberwach: I wish math books had free online versions :(
07:43:24 <TFT> What development environment should I use? There's some threads about it on /r/haskell, but I don't have any experience in CS outside of small C/C++ projects in code::blocks
07:43:43 <uberwach> bollu: actually most beyond the beginner's level do nowadays...
07:43:59 <uberwach> bollu: if you are into research you know the authors anyway and they send you free copies... lol
07:44:15 <bollu> uberwach: that sounds awesome - the free copies that is
07:44:26 <bollu> uberwach: do you think e-mailing the authors would work? :)
07:44:33 <uberwach> bollu: definitely not
07:44:40 <uberwach> bollu: they will be annoyed and not answer
07:44:57 <bollu> TFT: depends - you could use a text editor which supports autocompleton (vim, emacs, sublime text )
07:45:19 <bollu> TFT: or you could use a full blown IDE ( I don't know of any for haskell, though they must exist)
07:45:23 <bollu> uberwach: that's sad
07:45:38 <uberwach> bollu: later in life you get tons of emails..
07:45:42 <uberwach> bollu: especially if you are in higher positions
07:45:47 <uberwach> bollu: eventually, you will understand
07:45:49 <bollu> uberwach: heh. that sounds nice
07:46:50 <bollu> uberwach: thanks for the help :)
07:46:58 <uberwach> np
07:47:09 <bollu> TFT: I personally use sublime text + invoke ghc from the terminal
07:47:32 <bollu> TFT: if you're comfortable with the terminal then you don't *really* need an IDE
07:48:11 <TFT> bollu: ty. Was hoping for something ide-ish, but the only thing I can find is FP-completes web ide and Leksah, which uses an old version of GHC. Is setting up cabal packages for sublime hard? And I don't have much terminal xp, but can get it.
07:49:15 <bollu> TFT: cabal and sublime have no relationship. cabal is a build system for haskell which you can invoke from the command prompt. sublime text is used to write your .hs files which you then compile using cabal / directly using ghc
07:49:32 <luzie> > zipWith (.|.) [0..] [1..]
07:49:33 <bollu> so, ST for writing your .hs files
07:49:33 <lambdabot>  [1,3,3,7,5,7,7,15,9,11,11,15,13,15,15,31,17,19,19,23,21,23,23,31,25,27,27,31...
07:49:36 <bollu> cabal for building
07:50:00 <TFT> bollu: the stuff I was reading was saying you had to set cabal up for your project for the haskell plugins
07:50:00 <bollu> :t .|.
07:50:01 <lambdabot> parse error on input ‘.|.’
07:50:20 <geekosaur> ()
07:50:22 <bollu> TFT: yeah, so you create a folder - say /path/to/project
07:50:35 <geekosaur> :t (.|.)
07:50:36 <lambdabot> Bits a => a -> a -> a
07:50:41 <bollu> TFT: then you cd /path/to/project. and then you do cabal init
07:51:02 <bollu> TFT: then you open up sublime text, and create a new file, and save it as /path/to/project/main.hs
07:51:06 <luzie> (.|.) is bitwise and
07:51:12 <luzie> er, or i mean
07:51:42 <bollu> TFT: and then you cd /path/to/project and do cabal build
07:51:47 <bollu> TFT: does that help?
07:51:49 <bollu> luzie: ty.
07:51:56 <TFT> bollu: yes, thank you
07:52:08 <bollu> TFT: If you have any questions, do feel free to ask :)
07:52:44 <bollu> TFT: don't forget cabal run to run ;)
07:53:17 <TFT> bollu: I'll try, I sat in channel for 15  minutes, because social anxiety :p thank you again
07:54:10 <bollu> TFT: xD np. and well, almost everyone is friendly
07:55:32 <whippersnapper> I want to produce a value of type IO IODevice. Stream is an IODevice. So I tried "return IODevice", to convert an IODevice to an IO IODevice, but I'm still getting a type-mismatch error.  Can anyone help me out with this
07:55:43 <whippersnapper> sorry "return Stream"
07:56:37 <dabd> could someone please suggest a better way to write this function? https://gist.github.com/dabd/c5308b42b4366acca69d#file-gistfile1-hs
07:57:55 <bollu> TFT: oh, also, try and install the haskell package for sublime text. (https://github.com/SublimeHaskell/SublimeHaskell)
07:58:29 <bollu> TFT: you'll need to install Package Control for ST first - (https://sublime.wbond.net/installation)
07:58:53 <TFT> bollu: that's why I was worried about cabal :p
07:59:14 <bollu> TFT: ah xD
07:59:21 <bollu> TFT: that's just an optional add-on
07:59:46 <bollu> TFT: it lets you (or claims to anyway) build from within ST itself
08:00:02 <bollu> TFT: I haven't used it for building, but it adds better syntax highlighting AFAIK
08:00:12 <TFT> bollu: mmk
08:00:47 <Zekka> dabd: One second, I'll refactor it
08:01:50 <ClaudiusMaximus> dabd: you could use a list comprehension, [s | LogMessage (Error e) _ s <- inOrder (build msgs), e >= 50]
08:01:51 <dabd> Zekka: I updated the code to use dropWhile since the list is order in ascending order of severity
08:01:58 <dabd> ordered*
08:02:45 <Zekka> dabd: It looks to me like without knowing anything else this probably takes a lot of dense ugly pattern matching no matter what you do
08:03:20 <Zekka> Although actually there may be a few things I can do, one moment
08:03:48 <dabd> ClaudiusMaximus: let me try the list comprehension
08:04:06 <bollu> Just (TOML (fromList [("plugin",Right (VString "markdown"))])) My god, is TOML a Monad? >_<
08:04:09 <Zekka> Claudius' looks pretty close to what I was about to write
08:04:30 <Zekka> For some reason I was assuming that you needed to do something other than just remove everything whose second argument doesn't match a specific constructor
08:04:48 <Zekka> that is, of Error
08:05:04 <mmmm_> Anyone know what is going on here? http://lpaste.net/106471
08:07:50 <dabd> the list comprehension version seems to work
08:08:57 * hackagebot seacat 1.0.0.1 - Small web framework using Warp and WAI  http://hackage.haskell.org/package/seacat-1.0.0.1 (barrucadu)
08:09:35 <geekosaur> mmmm_, could use more information but it looks like you have a problem with the texmath package
08:12:06 <mmmm_> geekosaur: I am doing development on pandoc, as part of this I have made changes to texmath and pandoc-types. There is a sandbox where I have used the command "cabal sandbox add-source texmath/".
08:12:12 <bollu> is there a function which prints an error and then exits if the Maybe is of type Nothing?
08:12:15 <mmmm_> cabal repl loads everything fine
08:12:22 <mmmm_> the error is when trying to build the executable
08:12:24 <bollu> kind of .unwrap() in Rust?
08:13:44 <bollu> mmmm_: what's the error?
08:14:06 <dabd> cis 194 hw2 complete. https://gist.github.com/dabd/36a16677db2b39f7ed63#file-cis194-hw2 I still find it confusing how to decide when to use let, guards, when, list comprehensions.
08:14:28 <Madeleine21>  Hi! I give you some videos. I hope you like! http://j.mp/1sOLjk7
08:14:51 <ClaudiusMaximus> > fromJust Nothing -- bollu, but better to have a pattern match fail, as that gives source code location...
08:14:52 <lambdabot>  *Exception: Maybe.fromJust: Nothing
08:15:20 <mmmm_> bollu: I pasted it above
08:15:24 <ClaudiusMaximus> > let Just x = Nothing in x -- bollu
08:15:26 <lambdabot>  *Exception: <interactive>:3:5-20: Irrefutable pattern failed for pattern Dat...
08:28:59 * hackagebot dwarf-el 0.2.1.1 - Parser for DWARF debug format.  http://hackage.haskell.org/package/dwarf-el-0.2.1.1 (EyalLotem)
08:29:16 <EvanR> is it possible to pick what kind of Int i want to use with an IntMap
08:32:07 <Taneb> EvanR, no, it is restricted to machine-word size signed integers
08:32:30 <Taneb> EvanR, however, there is nothing stopping you from using Data.Map.Map Int8 or whatever instead
08:32:43 <lep-delete> where can i find the implementation of rewrite rules in ghc?
08:32:44 <EvanR> in which case i would use Integer
08:32:52 <EvanR> so i guess thats where im going
08:33:00 <EvanR> i was hoping i could use Int64
08:33:43 <Taneb> EvanR, do you need unbounded? What are you using this for?
08:34:00 * hackagebot dwarfadt 0.4 - High-level wrapper around the dwarf library  http://hackage.haskell.org/package/dwarfadt-0.4 (EyalLotem)
08:34:18 <EvanR> im not sure yet, im trying to make a spatial index of blocks in 3d space at integer coordinates
08:34:48 <EvanR> if each block has an id, then thats cube root of int max total blocks
08:42:50 <meretrix> If I persisted events using acid-state, is there any easy way to query the data and analyze it in another language like R?  Or would I need to write a translation layer?
08:44:50 <meretrix> For example, say my events are stock market data.  Say I wanted to pull all prices for stock AAPL between a start and end date.
08:45:32 <EvanR> seems like it would be easier to write a translation program in haskell
08:45:46 <EvanR> i mean, the api gives you that kind of query directly
08:45:56 <EvanR> oh wait im mixing acid state up with ixset
08:47:36 <meretrix> Yeah, I'm guessing I just want to stick with SQL.  The automatic replay features and native types of acid-state are attractive though.
08:49:57 <EvanR> ixset in an acid state would do this stuff, but i doubt its easy to dump the log into a foreign program
08:50:30 <EvanR> its will probably perform better than an sql database though
08:50:52 <EvanR> until you run out of memory
09:12:49 <alex94nts> Hi, I've started writing the typical card game to put in practice the little haskell-fu I've learned so far xD What container would you recommend me for the Deck? Is it ok to use the State Monad here? Sorry for these noob questions, this is only my 5th day with haskell and I'm really loving the language
09:13:16 <EvanR> id start with, a deck is a list of cards ;)
09:13:21 <sshine_> alex94nts, for the deck, [Card] :)
09:14:36 <alex94nts> Wouldn't I get bad performance with shuffling the list?
09:14:53 <Cale> alex94nts: Ignore performance for now
09:15:23 <sshine_> alex94nts, the state of your game is probably more than just an ordered representation of your cards?
09:15:26 <Cale> Nothing you could possibly want to do in a card game will be a legitimate performance concern anyway :P
09:15:49 <monochrom> State or not is just programming style. same generated code at the end anyway.
09:15:51 <sshine_> alex94nts, like "hands", or "on the table" cards in various piles.
09:15:58 <EvanR> the game requires 2^16 decks of cards ;)
09:16:27 <alex94nts> I mean, I've read about mutable vectors, which seem a good fit, but comming from almost 3 years of programming in C++, I'm afraid to over-optimize things ;)
09:16:54 <EvanR> then you really want to stay away from mutable vectors ;)
09:16:58 <Cale> alex94nts: You shouldn't really need any mutable structures, do it with all pure ones at first.
09:17:08 <alex94nts> would it be a valid use-case for vectors? or it's the little-imperative-programming inside me trying to get out?? xD
09:17:19 <alex94nts> * programmer
09:17:33 <monochrom> data structure and algorithms for the deck make a difference. but what to do here depends on what deck operation the game requires. one size does not fit all. the solution depends on the problem. http://www.vex.net/~trebla/humour/tautologies.html #5
09:17:55 <sshine_> alex94nts, since vectors have fixed length, I assume that vectors are not ideal for various uses of cards in card games where a variable amount of cards are present.
09:18:21 <EvanR> card deck[52];
09:19:24 <sshine_> EvanR, and how do you draw a card from that pile?
09:19:37 <EvanR> from the top?
09:19:42 <monochrom> but "the solution depends on the problem" is unpopular on IRC. it's against people's whole point of using IRC --- to keep open a wide unspecific space of "discussion"
09:20:40 <EvanR> sshine_: you also need int decksize; then do deck[decksize--] ;)
09:21:06 <EvanR> dont try that on an empty deck
09:21:48 <pablo> Hi! A lens question, best said in code: https://gist.github.com/anonymous/6d494f32e1c1940be9b6 . I want to lift a function using an Iso, is there any clever way to write isoLift2?
09:23:16 <benzrf> pablo: is there an applicative iso instance
09:23:30 <alex94nts> EvanR: what do you mean?
09:23:38 <benzrf> nope :i
09:23:53 <benzrf> :t under
09:23:54 <lambdabot> AnIso s t a b -> (t -> s) -> b -> a
09:23:57 <benzrf> :t under2
09:23:58 <lambdabot>     Not in scope: ‘under2’
09:23:58 <lambdabot>     Perhaps you meant ‘under’ (imported from Control.Lens)
09:24:01 <benzrf> :{
09:24:19 <benzrf> pablo: go to #haskell-lens and ask the best way to get a 2-arity version of under
09:24:26 <benzrf> *2-ary
09:24:28 <EvanR> alex94nts: i was joking with sshine_, a list of cards is very simple to start with
09:24:29 <benzrf> or w/e
09:25:04 <alex94nts> EvanR: oh, ok :)
09:25:26 <pablo> benzrf: wow, there's even a room for lens :o. I will try, thanks
09:25:50 <benzrf> :t below
09:25:51 <lambdabot> (Choice p, Traversable f, Applicative f1) => APrism' s a -> p (f a) (f1 (f a)) -> p (f s) (f1 (f s))
09:26:47 <robbins> The type system is really frustrating - I have no idea where GHCi is getting it's error messages from (ie: Could not deduce (a ~ [a]) and Couldn't match type [Integer] with Int.) http://lpaste.net/1519644400957784064
09:27:10 <benzrf> :t below _Right Just
09:27:11 <lambdabot> Traversable f => f (Either c a) -> Maybe (f (Either c a))
09:27:57 <EvanR> robbins: it doesnt give you a line number?
09:28:35 <geekosaur> robbins, look on line 9
09:29:19 <robbins> EvanR: http://lpaste.net/106476
09:30:05 <robbins> geekosaur: I know it's something to do with the recursive call, but I don't understand why its giving me that error.
09:30:31 <geekosaur> another hint: it's in the guard
09:30:39 <geekosaur> not the recursion in the result
09:31:01 <geekosaur> also the second error is the real one, the first is because the second confused it
09:31:18 <geekosaur> (I think)
09:31:29 <zq> robbins: the second argument to mod expects a Num a, but primes (n-1) gives Num a => [a]
09:31:34 <zq> fix that first
09:32:09 <geekosaur> no, I see where the first one is coming from. but you need to fix the second before addressing it
09:32:36 <zq> that's what i said
09:32:50 <zq> first, fix that
09:32:52 <zq> better?
09:33:25 <geekosaur> I guess the rest of what I said is irrelevant?
09:33:48 <robbins> zq: How can I get round that? I want to produce a list of primes, I don't want a number. Also, I'm pretty sure I'm computing each prime multiple times. Map isn't the correct function to use.
09:34:26 <geekosaur> to get around that you need to figure out what you actually want there. you are comparing a number to a list.
09:34:36 <geekosaur> you want to compare that number to... what?
09:34:56 <zq> robbins: how would primes 2 work?
09:35:54 <robbins> geekosaur: Well, I want to produce a list of primes by comparing each number to all the number below it (in reality, I only need to compare up-to sqrt(n)).
09:36:25 <robbins> zq: I see, you'd compare 2 with [].
09:36:28 <geekosaur> robbins, I am talking specifically about your mod
09:36:38 <geekosaur> (comparing was the wrog word)
09:36:52 <geekosaur> the one where you are attempting to mod a number with a list
09:37:08 <robbins> geekosaur: Thanks, it all make sense now. Why can't GHCi tell me that?
09:37:09 <geekosaur> think about what you really want there
09:37:12 <geekosaur> it did
09:37:20 <geekosaur> the second error message told you that exactly
09:38:22 <robbins> geekosaur: Well, I didn't seem to grasp what GHCi was telling me. Thanks, I'll try and fix it, somehow.
09:38:47 <geekosaur> could not deduce (a ~ [a]) : you're trying to use a list as if it were a single element of that list. in the second argument of `mod', namely `primes (n - 1)' : I hope this is self evident
09:40:14 <robbins> geekosaur: In hindsight, yes. 'Deduce' infers it's trying to work out the type, to me.
09:40:30 <geekosaur> ghc's error messages can sometimes be difficult --- I admit that first part is not necessarily obvious if you don't know how type inference works, or know ghc's notation for types --- but the second one is pretty much as clear as it can get
09:40:55 <geekosaur> I suspect the first one will really confuse you, it's something that trips almost everyone
09:44:12 <robbins> geekosaur: Both were very confusing to me, I can't seem to grok GHC's error messages, perhaps later on it will be second nature.
09:46:32 <sebzim4500> I I can't get the network package to work with windows
09:46:37 <sebzim4500> I get this error: http://lpaste.net/106477
09:46:53 <sebzim4500> I have tried from an MSYS shell
09:50:58 <benzrf> :t enum
09:50:59 <lambdabot> (Profunctor p, Functor f, Enum a) => p a (f a) -> p Int (f Int)
09:51:07 <benzrf> > review enum 4
09:51:09 <lambdabot>  4
09:51:12 <benzrf> > review enum 92 :: Char
09:51:14 <lambdabot>  Couldn't match type ‘GHC.Types.Char’ with ‘GHC.Types.Int’
09:51:14 <lambdabot>  Expected type: a0 -> GHC.Types.Char
09:51:14 <lambdabot>    Actual type: a0 -> GHC.Types.Int
09:51:24 <benzrf> :t review enum
09:51:25 <lambdabot> (MonadReader b m, Enum b) => m Int
09:51:30 <benzrf> o.O
09:51:40 <benzrf> oic
09:51:44 <benzrf> > review enum 'a'
09:51:46 <lambdabot>  97
09:51:49 <benzrf> neat
09:53:36 <benzrf> blah
10:03:33 <zq> :t review
10:03:34 <lambdabot> MonadReader b m => AReview s t a b -> m t
10:03:53 <zzzzzzzziiii> sebzim4500, maybe http://www.haskell.org/haskellwiki/Windows#Quickstart_on_Windows_7 helps
10:05:24 <MaxGabriel> Is there a safe version of head/tail in the standard library anywhere?
10:06:28 <hpc> use pattern matching
10:07:43 <hpc> > case "like this" of [] -> "empty list"; (x:xs) -> xs
10:07:45 <lambdabot>  "ike this"
10:08:14 <hpc> except more useful
10:10:00 <mm_freak_> hi again
10:10:28 <mm_freak_> it's done…  i have now found examples for all three lens laws that limit their usability
10:11:12 <mm_freak_> example for the first law:  clamped :: Lens' Word8 Double
10:11:23 <mm_freak_> this is a very useful lens, but it's improper
10:11:26 <edwardk_> mm_freak_: there are tons of them
10:11:35 <edwardk_> the notion of an improper lens comes up a lot
10:11:44 <edwardk_> there are 3 subclasses of them worth considering
10:11:54 <mm_freak_> yeah…  perhaps there should be a weaker notion
10:12:29 <int3__> MaxGabriel: https://hackage.haskell.org/package/safe
10:12:43 <edwardk_> the first basically says that put after you get -- then that is id, but not necessarily the opposite,  the second says  get after put is id, but not necessarily the opposite. the third gives you no guarantees
10:12:51 <zq> hpc: take 1
10:12:59 <edwardk_> if you compose two of the first type you get one of the first type. likewise with the second
10:13:17 <edwardk_> but if you compose one of the first with one of the second you get one of the third
10:13:28 <edwardk_> mm_freak_: there is no good place to hang the laws for them
10:13:39 <hpc> zq: heh
10:14:03 <mm_freak_> edwardk_: you have so many type synonyms, so perhaps adding a bunch more for documentation purposes would be sufficient
10:14:07 <mm_freak_> PseudoLens
10:14:08 * hackagebot no-role-annots 1.1 - Role annotations without -XRoleAnnotations  http://hackage.haskell.org/package/no-role-annots-1.1 (RichardEisenberg)
10:14:20 <edwardk_> the lens library doesn't care about the laws. i mean that in the sense that all the combinators are well defined for all 'improper' lenses. they all work, but what they lose is canonicity. they are the only way to do something for a legal lens, but they are _not_ the only way to do them for these improper lenses
10:14:41 <mm_freak_> ah
10:14:43 <edwardk_> mm_freak_: the problem is the type aliases have no teeth there
10:14:55 <edwardk_> we've talked about adding them
10:15:13 <edwardk_> and how to name the two slightly useful classes of improper lenses, etc.
10:15:35 <zq> hpc: what
10:16:03 <edwardk_> and it is important to distinguish those two classes if we do name them, because they are closed under composition with themselves and with proper lenses.
10:16:49 <edwardk_> for right now we mostly just note their existence and choose not to supply them in the standard library as much as possible. the goal is that we don't make instances that are improper unless they are thoroughly documented as such
10:17:22 <hpc> zq: it still produces a list
10:17:24 <edwardk_> we fall down on that goal here and there, but it is the rubric we use against any new ones ;)
10:17:36 <hpc> it's like answering "how do i get a value out of a monad" with (>>= return)
10:18:16 <mm_freak_> edwardk_: so for now i can assume that those lenses are safe, but i should note their improperness in the haddocks…  most of my non-field lenses are improper
10:18:22 <monochrom> @quote monochrom safeJust
10:18:22 <lambdabot> No quotes match. It can only be attributed to human error.
10:18:29 <freeman42> anyone got a fix for this error when installing on windows? `Package unix-2.7.0.1 can't be built on this system.`
10:18:31 <monochrom> @quote monochrom safeFromJust
10:18:31 <lambdabot> monochrom says: I use safeFromJust :: Maybe a -> Maybe a
10:18:44 <hpc> freeman42: don't use windows
10:18:50 <hpc> freeman42: or don't use the thing that requires unix
10:18:51 <edwardk_> mm_freak_: yeah, pretty much all the time pakages for lens that folks have have this problem. its not uncommon
10:19:09 * hackagebot parsers 0.11.0.3 - Parsing combinators  http://hackage.haskell.org/package/parsers-0.11.0.3 (EdwardKmett)
10:19:24 <mm_freak_> edwardk_: yeah, and they are extraordinarily useful…  in fact i'd go as far as to say that lenses unfold their true power once you allow improper lenses
10:19:36 <freeman42> hpc, neither of them sound like good solution :)
10:19:43 <Qfwfq> hpc: Eh, if you buy 'lists are computations which may produce multiple results', the result of take 1 has the expected semantics -- [] (was empty) [a] (had member). I'd still use \case {[]->Nothing;x:_->x} or (^?ix 0) though.
10:19:55 <Qfwfq> ->Just x, rather.
10:20:07 <monochrom> that seems to be a tautology. unfold true power once you remove restrictions.
10:20:22 <Qfwfq> Maybe encapsulates the expected result better.
10:20:33 <mm_freak_> edwardk_: pipes-parse is another example of a very useful pseudolens library
10:20:38 <hpc> guys! i found a problem with applicative parsers
10:20:44 <monochrom> unfold computer's true power once you allow arbitrary mutation of both data and program, for example
10:20:48 <hpc> you can unleash their true power if you just allow (>>=)
10:20:52 <mm_freak_> i haven't added it to my own library yet, because i was concerned that all of those lenses are improper
10:20:59 <Qfwfq> Heh.
10:21:33 <monochrom> I chose my example to illustrate: once you unfold true cavalier power you lose true predictive power
10:22:09 * hpc read "predicative power" and it still made sense
10:22:33 <mm_freak_> monochrom: well, improper lenses aren't unsafe, they are just weaker
10:23:04 <mm_freak_> pretty much like Applicative vs. Monad
10:23:52 <mm_freak_> with the difference that in this case you don't have nice type-classes to encode the relationship
10:24:47 <MP2E> hpc : What *are* the restrictions of an Applicative parser? I was a bit confused to that, myself. I've seen articles claiming back-tracking parsers can be written in Applicative so I started thinking that Applicative would suffice for most parsers
10:25:15 <mm_freak_> MP2E: Applicative + Alternative
10:25:27 <mm_freak_> Applicative alone isn't quite sufficient
10:25:39 <monochrom> context-sensitive parser is difficult or impossible with just Alternative
10:25:43 <MP2E> Ahhh okay
10:25:45 <MP2E> right :)
10:26:20 <monochrom> do { n <- parse_int; replicate n parse_word }
10:26:30 <mm_freak_> MP2E: also it's just in theory…  applicative parsers (by which i mean Alternative parsers) can even parse context-sensitive grammars, but in practice it's going to be horribly inefficient
10:26:31 <monochrom> err, make it replicateM there
10:27:00 <hpc> MP2E: applicative parsers correspond to context-free grammars
10:27:11 <monochrom> good thing I had "difficult or" there :)
10:27:15 <hpc> MP2E: add in Parsec-style state variables and you have context-sensitive
10:27:20 <MP2E> mm_freak_ : Ah, is that because applicatives execute all branches in code? so if you had a switch statement or something it would execute all 'possible' results
10:27:37 <hpc> MP2E: add Monad and you are a turing tape
10:27:41 <mm_freak_> MP2E: until success, yes
10:27:51 <bollu> if I have a structure like this - TOML (fromList [("build",Left (TOML (fromList [("0",Left (TOML (fromList [("input",Right (VString "*.md")),("output",Right (VString "*.html")),("type",Right (VString "markdown"))])))]))),("root_dir",Right (VString "bin/"))]), how do I access the elements? like, how do I access the "root_dir" rhs for example?
10:28:08 <mm_freak_> you can get the generality of Applicative and most of the flexibility of Monad by using a parser arrow
10:28:19 <MP2E> ooh I like Arrows :P
10:28:52 <mm_freak_> but in practice the advantages of Monad outweigh, so you would just use a monadic parser
10:29:21 <bollu> um, parsing help? >_<
10:29:35 <mm_freak_> in particular monads allow you parsers like this:  csvParser = headers >>= many
10:29:47 <mm_freak_> this is impossible with both Applicative and Arrow
10:30:15 <mm_freak_> where:  headers :: Parser [Parser CsvField]
10:30:22 <mm_freak_> oh…
10:30:30 <mm_freak_> csvParser = headers >>= many . sequence
10:30:33 <mm_freak_> that's the correct one
10:32:55 <mm_freak_> enough shit shat…  thanks and bye =)
10:57:16 <trelptoreless> 57 trelptoreless assburger abstract-alf elfenlaid_ systemfault dfeuer hamid jonathanmarvens lw telser idoru matheus23 folone FlashingFire makos sawidis benzrf BluePeppers Sculptor add^_ Trollinator rrradical halvorg dodgems gratimax minkowski Kaini mzero divyanshu artyomkazak mmmm_ vsayer__ path[l] kazimir42 jackneill Swizec joneshf-laptop biscarch dsantiago sxn MP2E johnw rekahsoft mescalinum gemelen bollu Mathnerd626 cbarrett conehead theorbtwo
10:57:22 <cornellsans> 15 cornellsans assburger abstract-alf elfenlaid_ systemfault dfeuer hamid jonathanmarvens lw telser idoru matheus23 folone FlashingFire makos sawidis benzrf BluePeppers Sculptor add^_ Trollinator rrradical halvorg dodgems gratimax minkowski Kaini mzero divyanshu artyomkazak mmmm_ vsayer__ path[l] kazimir42 jackneill Swizec joneshf-laptop biscarch dsantiago sxn MP2E johnw rekahsoft mescalinum gemelen bollu Mathnerd626 cbarrett conehead theorbtwo paulli
10:57:22 <cornellsans> 79 ClarusCogitatio gabriel twanvl_ joneshf int3__ ArneL ccasin Kron tharper jumblerg pepegar Nizumzen phi__ cdidd thorkilnaur genericpersona jomg kbrei edon enthropy Thooms pavonia merijn ixti goldfire thevishy enetsee Takle ksf_ robbins amaron ambimorph jesyspa EvilPenguin banisterfiend matthieu nkhodyunya laar sritchie pablo ashbreeze wto fabe tramjoe anders^^ d10genes lemao erkin mike4 sea-gull Jeanne-Kamikaze meretrix io2 blbrown_win3 cognominal
10:57:22 <cornellsans> 61 meoblast001 murgaan jmcarthur bjorkintosh uberwach triliyn Guest80210 nominolo isaacd julianb haskoiner umnmqn ajf oleo therp OlegYch robbert Noldorin vanila dgpratt the-manless-man petermw jml benteight samrat fortet chatsiri_ onthesta1rs otjura szymanowski taruti u_ Sorella hydrospell gibsonfs linduxed geekosaur perspectival1 MuffinMan` codesoup marcus-aurelius lieven_ Philonous Gurkenglas palo jonathan2 Ethix CindyLinz zzzzzzzziiii JanBessai sae
10:57:22 <cornellsans> 20 Shogun cursork zxq9 dabd yorick tekacs thunderrd Lutin_ Nervkind1 descender yitz dmwit Qfwfq tb01110100 dr_ dcoutts_ inr iulian theanine DanielDiaz silver seschwar freeman42 glosoli haasn acfoltzer mrd Ol3f3l180rn etrepum AntiSpamMeta c74d q66 Transfusion jnott slasktask mrb_bk_ blindscreen_ Klumben electrogeek Vbitz dqd u-ou ocharles jmct jodaro_ klaut kalusn motching_ airloom pvt_petey Polarina raphie_ yac koz aristid-ic_ fergusnoble jzelinskie
10:57:37 <bloopaype> 38 bloopaype assburger abstract-alf elfenlaid_ systemfault dfeuer hamid jonathanmarvens lw telser idoru matheus23 folone FlashingFire makos sawidis benzrf BluePeppers Sculptor add^_ Trollinator rrradical halvorg dodgems gratimax minkowski Kaini mzero divyanshu artyomkazak mmmm_ vsayer__ path[l] kazimir42 jackneill Swizec joneshf-laptop biscarch dsantiago sxn MP2E johnw rekahsoft mescalinum gemelen bollu Mathnerd626 cbarrett coneh
10:57:37 <bloopaype> 80 ClarusCogitatio gabriel twanvl_ joneshf int3__ ArneL ccasin Kron tharper jumblerg pepegar Nizumzen phi__ cdidd thorkilnaur genericpersona jomg kbrei edon enthropy Thooms pavonia merijn ixti goldfire thevishy enetsee Takle ksf_ robbins amaron ambimorph jesyspa EvilPenguin banisterfiend matthieu nkhodyunya laar sritchie pablo ashbreeze wto fabe tramjoe anders^^ d10genes lemao erkin mike4 sea-gull Jeanne-Kamikaze meretrix io2 blb
10:57:37 <bloopaype> 98 meoblast001 murgaan jmcarthur bjorkintosh uberwach triliyn Guest80210 nominolo isaacd julianb haskoiner umnmqn ajf oleo therp OlegYch robbert Noldorin vanila dgpratt the-manless-man petermw jml benteight samrat fortet chatsiri_ onthesta1rs otjura szymanowski taruti u_ Sorella hydrospell gibsonfs linduxed geekosaur perspectival1 MuffinMan` codesoup marcus-aurelius lieven_ Philonous Gurkenglas palo jonathan2 Ethix CindyLinz zzzz
10:57:37 <bloopaype> 65 Shogun cursork zxq9 dabd yorick tekacs thunderrd Lutin_ Nervkind1 descender yitz dmwit Qfwfq tb01110100 dr_ dcoutts_ inr iulian theanine DanielDiaz silver seschwar freeman42 glosoli haasn acfoltzer mrd Ol3f3l180rn etrepum AntiSpamMeta c74d q66 Transfusion jnott slasktask mrb_bk_ blindscreen_ Klumben electrogeek Vbitz dqd u-ou ocharles jmct jodaro_ klaut kalusn motching_ airloom pvt_petey Polarina raphie_ yac koz aristid-ic_ fe
10:57:37 <bloopaype> 1 zz_LoRdToLsToI jroesch_ Karethoth_ Edoxile LordDeath Boreeas wildsebastian RchrdB anachron Reiser raid sohum Jello_Raptor Tordek peddie Svedrin greymalkin wunki drdo fnordbert Paprikachu thirsteh_ pnielsen_ teeteewhy_ kongo2002 wizonesolutions sipa Jaxan jlyndon docsis____ leifw superjudge_ himikov mno2 seanparsons andreypopp PatrickRobotham vera jagtalon bchar ReinH ixian pikhq_ amatsu nakal Raynos Xorlev qixos td123 they dsch
10:57:37 <bloopaype> 12 nemesit|znc FreeFull_ sepp2k1 LeoTal d3m1g0d-1 edwardk_ augur Khisanth ZioCrocifisso peldan elterago bennofs Thra11 kp666 jedai wei2912 SoupEvil dbushenko Reite osa1 nkoep MindlessDrone MrWoohoo slomo alanz liqu0rice mceier gehmehgeh doomlord_1 hackagebot hexagoxel_ davidfetter vili _deepfire-laptop Rakkin wlhlm srbaker predator117 spaceships tsani catsup yacks sakirious tnks vsayer jmcarthur_mobile ephemeron eikonos mornfall 
10:57:37 <bloopaype> 18 ryantrinkle shanse george2 cobakobodob tsou jrm bvad ezrios deni diginet s4msung defanor apaku marchelzo_ harski petantik pdurbin jle` segmond bxc paddymahoney eevar davean1 Gilfoyle zarul choosegoose arun morolin _d3f kqr LeaChim Eliel happy0 Artpicre elgot canta jameseb noplamodo vladan dosequis ivoscc anders0 pharaun pdxleif nelsonje redtricycle DarkFox rejuvyesh SethTisue_______ callumacrae Raynes MindfulMonk stephenmac7_ 
10:57:42 --- mode: ChanServ set +o geekosaur
10:57:44 <jmcarthur> oh goodness
10:57:45 <meoblast001> stawp
10:57:47 <tharper> waaah
10:57:48 <ajf> someone ban these clownbots
10:57:49 <DanielDiaz> ?
10:57:49 <jonathanmarvens> WTF.
10:57:51 <ReinH> @where ops
10:57:51 <lambdabot> arjanb bos byorgey Cale conal copumpkin dcoutts dibblego dmhouse dolio dons edwardk elliott geekosaur glguy Heffalump Igloo jmcarthur johnw kosmikus Lemmih monochrom nyc Philippa Pseudonym quicksilver roconnor Saizan shachaf shapr sjanssen ski sorear SyntaxPolice xerox
10:57:57 --- mode: ChanServ set +o jmcarthur
10:58:00 <meoblast001> relrod: fix this D:
10:58:01 <kqr> what's the point of that
10:58:02 <Boreeas> Oh man, they are hitting so many channels
10:58:07 <_d3f> Hello
10:58:07 <ocharles> bots gone wild
10:58:08 <they> I probably got highlighted slightly less during that than normal.
10:58:09 <_d3f> :)
10:58:09 <kqr> i mean what do they get out of it
10:58:19 <ReinH> they: lmao
10:58:20 <kqr> other than i don't know, bring people together
10:58:21 <geekosaur> oh, no wonder it wouldn't complete, idoru got it
10:58:26 <gratimax> I thought someone actually said my name with intention when I got a notification :(
10:58:30 --- mode: geekosaur set -o geekosaur
10:58:38 <ajf> ditto
10:58:39 <Jeanne-Kamikaze> they want us to ddos the server by chatting all at the same time
10:58:39 <ajf> :<
10:58:40 <bennofs> wow, the activity in this channel now :p
10:58:49 <minkowski> me too :( so nobody still loves me
10:58:57 <q66> fuckin spamming cunts
10:59:01 <MP2E> botspiracy
10:59:08 <kqr> they, wow that's a fun nick to have
10:59:08 <they> Yeah, the bot should do this in down periods.
10:59:10 <ReinH> kqr: those assholes
10:59:15 <abstract-alf> minkowski, *somebody* loves you
10:59:17 <Lutin_> lol
10:59:25 <Lutin_> How do get #haskell chatting
10:59:27 <jmcarthur> meh. there is no pattern for me to ban. silly bots
10:59:31 --- mode: jmcarthur set -o jmcarthur
11:00:05 <q66> <abstract-alf> minkowski, *somebody* loves you
11:00:10 <q66> people who implement collision detection do.
11:00:26 <abstract-alf> ?
11:00:42 <q66> aw :(
11:00:43 <q66> http://en.wikipedia.org/wiki/Minkowski_Portal_Refinement
11:00:45 <geekosaur> jmcarthur, I think that was a kline anyway
11:00:56 <minkowski> abstract-alf: yea i wrote a program which tells me how much it loves me ;)
11:01:03 <Lutin_> I don't even get the point of spamming everyone's name
11:01:08 <abstract-alf> haha nice
11:01:44 <gratimax> minkowski: does it just repeat 'I love you so much' over and over?
11:01:53 <Jeanne-Kamikaze> nobody loves minkowski because he is different *ba dum tss*
11:02:33 <mzero> Lutin_: I think their aim is to cause as much cascaded network traffic as possible
11:02:41 <minkowski> gratimax: naaa its a bot which no matter what you say tells you how lovely you are
11:02:50 <Lutin_> mzero: Yeah..
11:02:57 <Lutin_> They're even in #freenode now
11:03:22 <abstract-alf> @thanks
11:03:22 <lambdabot> you are welcome
11:03:28 <abstract-alf> @thanks
11:03:28 <lambdabot> you are welcome
11:03:37 <Lutin_> Hey uh
11:03:39 <kqr> minkowski, so like a dog then?
11:04:00 <Lutin_> jmcarthur: Would requiring nickserv registration be an option?
11:04:29 <jmcarthur> Lutin_: a pretty heavy-handed one
11:04:43 <Jeanne-Kamikaze> yeah, that's quite newbie unfriendly
11:04:46 <Lutin_> I guess yeah
11:04:47 <minkowski> kqr:na im more of a cat type person
11:04:47 <ajf> It’s not so drastic
11:04:58 <ajf> We could do what IIRC python does
11:05:05 <ajf> have an area for non-regs
11:05:19 <ajf> alongside main reg-only channel
11:05:20 <Lutin_> Now that I think about it the channels I'm in that do that are a little more sysadmin oriented
11:05:21 <jmcarthur> Lutin_: i think these occasional attacks hurt less than requiring registrationg would
11:05:28 <jmcarthur> *registration
11:05:39 <kqr> ajf, i'm not sure if splitting up the community would help more than it hurts
11:05:47 <ajf> jmcarthur: they wouldn’t save us from that either
11:05:50 <ajf> kqr: true
11:05:50 <jmcarthur> indeed
11:06:10 <DanielDiaz> plus, this attack got us chatting together :)
11:06:14 <Lutin_> hehe
11:06:14 <minkowski> ajf: yea jam all of those filthy non reg peasents into a gettho
11:06:30 <ajf> better than kicking them :P
11:06:35 <Lutin_> DanielDiaz: Maybe it should be something Lambdabot does every 6 hours
11:06:52 <minkowski> what does he do?
11:07:06 <minkowski> molest someone?
11:07:07 <DanielDiaz> Lutin_: oh! that notification was from a real person! :D
11:07:13 <Lutin_> haha
11:07:27 <Lutin_> minkowski: ping everyone in the channel
11:08:26 <minkowski> why?
11:08:52 <ajf> If I did a CTCP ping of this channel, I wonder if I’d be kicked
11:09:03 <MP2E> minkowski : it was a joke, it was because everyone started talking afterwards
11:10:51 <DanielDiaz> we should program lambdabot to, whenever someone ask a question and nobody answers, ping everyone in the room and say "hey people! help here!"
11:10:55 <minkowski> man i wanted to do some haskell this evening instead i made a excel spreadsheed :(
11:10:57 <MP2E> haha
11:11:39 <DanielDiaz> minkowski: excel-lent!
11:11:45 <defanor> close enough
11:11:48 <MP2E> Sounds more like navibot than lambdabot
11:11:49 <minkowski> badumtsh
11:11:50 <MP2E> HEY! LISTEN!
11:12:03 <sshine_> minkowski, I know the feeling.
11:13:16 <kqr> minkowski, i've used excel to prototype haskell code (which then in turn was a prototype for some C code...)
11:13:20 <kqr> minkowski, don't view it as a loss!
11:13:40 <minkowski> how do you prototype haskell in excel?
11:16:13 <kqr> i used one dimension of the spreadsheet to indicate iterations of a computation
11:16:47 <minkowski> so you prototyped a algorythmen
11:16:56 <kqr> yeah
11:17:11 <kqr> the evaluation model of excel spreadsheets reminds me a lot of the haskell evaluation model
11:17:13 <minkowski> what did it do?
11:17:23 <kqr> i don't even remember
11:17:27 <kqr> it was some kind of computation a friend wanted
11:17:33 <kqr> in their C program
11:17:52 <minkowski> ok
11:18:03 <minkowski> well im pretty new to kaskell
11:18:06 <minkowski> haskell
11:18:42 <WJW> Suppose you want to describe computation in terms of correct results values in a way that abstracts away from whether the implementation is distributed across a network of computers and if so how.  Then FRP would be an inappropriate notation for describing that, right, because FRP is synchronous and it isn't practical to synchronize communicating computers.  Right?
11:18:51 <therp> ajf: you might get flood quitted by FreeNode with CTCP PING #haskell
11:19:15 <ajf> therp: Why would I? It’s a single command.
11:19:22 <gratimax> WJW: there have been attempts to make FRP asynchronous
11:19:30 <therp> ajf: the distributed responses would overflow your tx buffer
11:19:39 <gratimax> WJW: but what you're looking for fits parallelization perfectly
11:19:45 <ajf> therp: ah
11:20:33 <therp> ajf: maybe that changed. at least when I was young ircd reacted on tx buffer overflows the same way as on rx buffer overflow
11:20:44 <ajf> Hmm…
11:21:36 <ajf> t
11:21:44 <minkowski> u
11:22:01 <ajf> p
11:22:32 <Lutin_> l
11:22:40 <ajf> e
11:22:44 <Lutin_> s
11:22:48 <ajf>  
11:22:51 <Lutin_> a
11:22:53 <ajf> r
11:22:55 <therp> e
11:22:55 <Lutin_> e
11:22:57 <ajf>  
11:22:58 <erkin> g
11:23:00 <ajf> r
11:23:03 <Lutin_> o
11:23:06 <erkin> k
11:23:09 <Lutin_> a
11:23:09 <ajf> k
11:23:12 <ajf> b
11:23:15 <Lutin_> l
11:23:18 <ajf> e
11:23:21 <Lutin_> .
11:23:27 <sipa> N
11:23:30 <ajf> o
11:23:34 <erkin> .
11:23:42 <ajf> W
11:23:55 <linduxed> C-C-C-COMBO BREAKER
11:24:02 <ajf> that’s not a word
11:24:14 * hackagebot verilog 0.0.5 - Verilog parser and DSL.  http://hackage.haskell.org/package/verilog-0.0.5 (TomHawkins)
11:25:15 <Lutin_> H
11:25:41 <Lutin_> ...why do I encourage this
11:25:46 <ajf> a
11:25:54 <minkowski> s
11:25:57 <ajf> k
11:26:00 <minkowski> e
11:26:03 <ajf> l
11:26:06 <minkowski> l
11:26:09 <ajf>  
11:26:11 <sipa> i
11:26:14 <ajf> s
11:26:20 <therp>  
11:26:23 <ajf> a
11:26:25 <DanielDiaz> where are we going?
11:26:30 <therp> w
11:26:31 <edwardk_> @ask jmcarthur_mobile were you able to construct a form of the Tarjan and Mihaesau queue that actually did the proper treeing to get O(1) access to the first non-4 child on either side? It isn't clear to me that we can _actually_ do that with a GADT. The O(1) access is needed to maintain the performance bounds.
11:26:32 <lambdabot> Consider it noted.
11:26:32 <ajf> f
11:26:42 <hamid> hmm what's happening? :/
11:27:04 <sshine> someone let their retarded kid on IRC.
11:27:07 <therp> hamid: it's a distributed mind reading game
11:27:15 <corgifex> spam
11:27:26 <ajf> It’s a ouija board
11:27:51 <ajf> The gods and/or spirits of the dead are telling us about the latest in functional, strict, pure programming languages
11:28:09 <minkowski> im already living in a apartment where somebody killed a hooker...dont need an ouija boards near me
11:29:11 <therp> are there any nice benchmark frameworks as for recent? (last ~5 years)
11:29:34 <edwardk_> dfeuer: around?
11:37:29 <therp> are there any nice benchmark frameworks as for recent? (last ~5 years)
11:37:31 <therp> sorry
11:38:22 <DanielDiaz> therp: is criterion ok for you? http://hackage.haskell.org/package/criterion
11:39:08 <DanielDiaz> sample output: http://bos.github.io/criterion
11:39:52 <therp> DanielDiaz: nice output. but seems to depend on quite a few source annotations
11:40:20 <therp> hmm I should read the release logs of GHC of the last 5 years.. I have no idea what changed in the meantime
11:42:09 <DanielDiaz> therp: no source annotations. You usually code the benchmarks in a separate file, similarly to what is done with tests.
11:42:30 <therp> DanielDiaz: that makes sense.. if I would have tests to begin with :)
11:42:47 <DanielDiaz> DanielDiaz: here is an example (in the blue box): http://hackage.haskell.org/package/criterion-0.8.1.0/docs/Criterion-Main.html#v:defaultMain
11:42:58 <DanielDiaz> did I mention myself?
11:43:03 <DanielDiaz> therp: <-
11:43:24 <napping> napping: the real question is whether your IRC client flagged it
11:43:39 <therp> therp: hey, that guy isn't the only one talking to himself. see? we don't need to hide anymore.
11:43:58 <therp> DanielDiaz: yep, saw that thanks :). if I will get anymore professional I will try to use it.
11:43:59 <DanielDiaz> haha
11:44:32 <ReinH> mrb_bk_: oh hai
11:45:13 <mrb_bk_> ReinH: sup
11:45:34 <DanielDiaz> therp: writing tests and benchs does not really take so much time, and it's really worth it. I strongly recommend you to get used to it. :)
11:45:45 <ReinH> mrb_bk_: fancy meeting you here ;) how goes the Idris?
11:46:16 <therp> DanielDiaz: I know, I know. however, I proud myself to be the invert of the phrase "premature testing"
11:46:26 <therp> s/invert/inventor/
11:46:48 <mrb_bk_> ReinH: it's good! i wrote some proofs
11:47:10 <mrb_bk_> ReinH: contributing some back to the lib https://github.com/idris-lang/Idris-dev/pull/1344/files
11:47:27 <seydar> can someone quickly read over a short chat program i wrote? i want to make it prettier. http://lpaste.net/106480
11:47:29 <ReinH> Yay proofs! Have you talked to Brian McKenna about your Idris stuff? I bet he'd be interested.
11:47:38 <seydar> my complaint is that i can't glance at it and instantly know what's going on
11:48:32 <mrb_bk_> haven't, no
11:48:45 <dwcook> I want to save a data structure across runs of a program. I don't care what format. What's a quick way to do this as automatically as possible?
11:48:45 <seydar> pyry`: puhutko sina suomea? oletko sama pyry redditissa?
11:49:32 <seydar> dwcook: https://hackage.haskell.org/package/yaml
11:50:48 <Philonous> dwcook, http://hackage.haskell.org/package/acid-state
11:51:00 <corgifex> dwcook: read/show
11:51:07 <ReinH> seydar: it seems reasonable to me.
11:51:22 <ReinH> mrb_bk_: just a thought :)
11:51:37 <mrb_bk_> word up
11:51:41 <mrb_bk_> proofs are cool i agree
11:51:45 <seydar> ReinH: i meant it's *fine*, but i know it can be better. i want to get into the habit /now/ of writing pretty haskell code
11:52:01 <dwcook> corgifex, I'm not sure why I didn't think of that, actually. Read/Show can be derived automatically, even, unlike those other instances
11:52:04 <dwcook> Thanks all for suggestions
11:52:20 <MP2E> http://pastebin.com/xNrQd6ZA   any ideas on how to fix this ? :V I've deleted ghc a few times and it seems I always hit this, because my system Cabal library is newer than the one GHC uses
11:52:30 <MP2E> err not ghc the compiler, .ghc the folder :P
11:52:33 <_sebastian_> anyone interested in giving feedback to hayoo's new major version? http://holumbus-neu.fh-wedel.de/
11:52:45 <Nimatek> dwcook: writeFile . encode
11:53:26 <dwcook> Nimatek, what encode is that?
11:53:29 <ReinH> seydar: separate the pure text handling code from the IO stuff
11:53:33 <Philonous> dwcook, acid-state comes with TH-helpers for deriving instances. Depending on how granular you want your transactions to be you can get away with little boylerplate
11:53:41 <Nimatek> dwcook: Data.Binary
11:54:21 <seydar> ReinH: can you elaborate on that a little more?
11:54:31 <ReinH> seydar: use `forever' for monadic loops.
11:54:42 <dwcook> Okay cool, I know at least one of these will serve, probably others. Thanks again
11:55:10 <mr-> :t forever
11:55:11 <lambdabot> Monad m => m a -> m b
11:55:11 <seydar> ReinH: `forever` instead of `fix`?
11:55:30 <ReinH> Instead of sockLoop
11:56:13 <seydar> gotcha
11:58:27 <niix> Hi all!  Whats the best way to get into Haskell coming from a JS background?
11:58:51 <ksf_> first, forget everything. then read learn you a haskell / real world haskell, ymmv.
11:58:56 <benzrf> niix: read a book
11:59:05 <benzrf> niix: but yea try lyah
11:59:24 <benzrf> niix: at least you are coming from a language that has first class functions and encourages passing them around
11:59:30 <benzrf> [disclaimer i am not a fan of js]
11:59:59 <lep-delete> where can i find the implementation of rewrite rules in ghc?
11:59:59 <lep-delete> can't find the file(s) :<
12:00:19 <niix> ksf_ && benzrf thanks :)
12:00:22 <benzrf> @google ghc rules pgram
12:00:24 <lambdabot> http://www.haskell.org/haskellwiki/GHC/Using_rules
12:00:24 <lambdabot> Title: GHC/Using rules - HaskellWiki
12:00:25 <benzrf> @google ghc rules pragma
12:00:26 <lambdabot> https://www.haskell.org/ghc/docs/7.0.1/html/users_guide/rewrite-rules.html
12:00:42 <benzrf> lep-delete: ^
12:00:47 <lep-delete> ya, i tried searching via google
12:00:58 <lep-delete> but im not interested in using
12:01:05 <benzrf> lep-delete: https://www.haskell.org/ghc/docs/7.0.1/html/users_guide/rewrite-rules.html
12:01:16 <benzrf> oh you mean the code-level impl
12:01:19 <lep-delete> yes
12:01:23 * benzrf shrugs
12:01:55 <benzrf> >mfw my vps doesnt have enough RAM to install packages
12:01:56 <benzrf> ;-;
12:02:11 <seydar> ;-;.jpg
12:02:22 <benzrf> http://benzrf.com/misc/4/feels.png
12:02:36 <MP2E> i know your pain, my computer recently broke and I'm using a loaner. 2 GB of RAM *barely* cuts it. Some packages take hours :V
12:02:42 <MP2E> lots and lots of -fno-spec-constr
12:02:52 <benzrf> whats that do
12:02:54 <augur> aww
12:02:58 <augur> i had my hopes up
12:03:05 <benzrf> augur: for wht
12:03:10 <augur> i thought i had been pinged by someone with an interest in my questions :(
12:03:12 <MP2E> benzrf: cuts RAM usage by a ton if you're using -O2 for some packages. alex and happy come to mind
12:03:14 <augur> instead it was a spammer :(
12:03:29 <bollu> I don't even understand the amount of RAM on mu laptop - 3840 MB
12:03:38 <benzrf> what does spec-constr do
12:03:46 <benzrf> bollu: mu laptop
12:03:49 <benzrf> laptop (mu laptop)
12:04:02 <bollu> benzrf: ?
12:04:10 <benzrf> :t Mu
12:04:12 <lambdabot> Not in scope: data constructor ‘Mu’
12:04:13 <MP2E> it disables the SpecConstr optimization pass which has some memory leak bugs I guess. I'm not 100% sure but by it's name and a quick look at the .hs it constructs specializations of more generic functions/data constructors
12:04:13 <benzrf> :t In
12:04:14 <lambdabot> f (Mu f) -> Mu f
12:04:32 <benzrf> bollu: newtype Mu f = f (Mu f)
12:04:36 <benzrf> oops i mean
12:04:43 <benzrf> bollu: newtype Mu f = In {out :: f (Mu f)}
12:04:48 <MP2E> There are a few projects that blow up in RAM but I can't seem to figure out what is causing that
12:04:49 <benzrf> :t out
12:04:51 <lambdabot> Mu f -> f (Mu f)
12:05:02 <MP2E> it's not the SpecConstr for a few
12:05:10 <benzrf> bollu: allows simulation of infinite types
12:05:13 <benzrf> :t cata
12:05:14 <lambdabot> Functor f => (f a -> a) -> Mu f -> a
12:05:15 <benzrf> :t ana
12:05:17 <lambdabot>     Not in scope: ‘ana’
12:05:17 <lambdabot>     Perhaps you meant one of these:
12:05:17 <lambdabot>       ‘and’ (imported from Data.List),
12:05:24 <benzrf> :o
12:05:36 <bollu> benzrf: what the hell does Mu do? I think Y combinator? >_<
12:05:40 <benzrf> @let ana psi = In . fmap psi . psi
12:05:41 <lambdabot>  .L.hs:258:27:
12:05:41 <lambdabot>      Kind incompatibility when matching types:
12:05:41 <lambdabot>        f :: * -> *
12:05:41 <lambdabot>        Mu :: (* -> *) -> *
12:05:41 <lambdabot>      Expected type: a -> f a
12:05:45 <benzrf> bollu: Y combo for types
12:06:14 <bollu> benzrf: I don't even comprehend what that means *opens tab in chrome*
12:07:05 <benzrf> hmmm
12:07:13 <bollu> benzrf: what fixed points even exist?
12:07:19 <benzrf> bollu: huh?
12:07:21 <benzrf> well
12:07:28 <benzrf> y f = f (y f)
12:07:36 <benzrf> Mu f = In (f (Mu f))
12:07:43 <benzrf> newtype Mu f = In (f (Mu f))
12:07:44 <benzrf> i mean
12:08:03 <benzrf> iirc, ana :: (a -> f a) -> a -> Mu f
12:08:17 <benzrf> @let ana psi = In . fmap (ana psi) . psi
12:08:19 <lambdabot>  Defined.
12:08:21 <benzrf> :t ana
12:08:22 <lambdabot> Functor f => (a -> f a) -> a -> Mu f
12:08:28 <benzrf> > ana (:[])
12:08:30 <lambdabot>  No instance for (Data.Typeable.Internal.Typeable
12:08:30 <lambdabot>                     Lambdabot.Plugin.Haskell.Eval.Trusted.Mu)
12:08:30 <lambdabot>    arising from a use of ‘M397433997341629225511389.show_M3974339973416292255...
12:08:36 <benzrf> > ana (:[]) 3
12:08:38 <lambdabot>  In {out = [In {out = [In {out = [In {out = [In {out = [In {out = [In {out = ...
12:08:44 <benzrf> > ana Just 3
12:08:46 <lambdabot>  In {out = Just (In {out = Just (In {out = Just (In {out = Just (In {out = Ju...
12:08:51 <bollu> ...
12:08:57 <benzrf> bollu: hence the use of Mu
12:09:06 <bollu> I don't understand it, but I see it
12:09:16 <benzrf> Mu is used for infinitely nested types
12:09:21 <benzrf> i.e. lists of lists of lists of lists
12:09:25 <benzrf> alternatively
12:09:30 <benzrf> you can use it like this:
12:09:54 <benzrf> @let data ParameterizedList a b = Nil | Cons b a
12:09:55 <lambdabot>  Defined.
12:10:14 <benzrf> @let type MuList a = Mu ParameterizedList a
12:10:15 <lambdabot>  .L.hs:262:17:
12:10:15 <lambdabot>      ‘Mu’ is applied to too many type arguments
12:10:15 <lambdabot>      In the type ‘Mu ParameterizedList a’
12:10:15 <lambdabot>      In the type declaration for ‘MuList’
12:10:19 <benzrf> @let type MuList a = (Mu ParameterizedList) a
12:10:20 <lambdabot>  .L.hs:262:17:
12:10:20 <lambdabot>      ‘Mu’ is applied to too many type arguments
12:10:20 <lambdabot>      In the type ‘(Mu ParameterizedList) a’
12:10:21 <lambdabot>      In the type declaration for ‘MuList’
12:10:22 <benzrf> bah
12:10:26 <benzrf> oic
12:10:28 <benzrf> nvm
12:10:31 <benzrf> @undefine
12:10:31 <lambdabot> Undefined.
12:10:36 <benzrf> bollu: ok check it
12:10:48 <benzrf> @let data ParameterizedList item remainder = Nil | Cons item remainder
12:10:49 <lambdabot>  Defined.
12:10:56 <benzrf> @let type MuList a = Mu (ParameterizedList a)
12:10:57 <lambdabot>  Defined.
12:11:20 <benzrf> > In (Cons "foo" (In (Cons "bar" NIl)))
12:11:21 <lambdabot>  Ambiguous occurrence ‘Cons’
12:11:21 <lambdabot>  It could refer to either ‘L.Cons’, defined at L.hs:148:41
12:11:21 <lambdabot>                        or ‘Math.OEIS.Types.Cons’,
12:11:21 <lambdabot>                           imported from ‘Lambdabot.Plugin.Haskell.Eval.Truste...
12:11:21 <lambdabot>                           (and originally defined in ‘oeis-0.3.5:Math.OEIS.Ty...
12:11:29 <benzrf> > In (L.Cons "foo" (In (L.Cons "bar" L.Nil)))
12:11:31 <lambdabot>  Couldn't match expected type ‘Lambdabot.Plugin.Haskell.Eval.Trusted.Mu
12:11:31 <lambdabot>                                  (L.ParameterizedList [GHC.Types.Char])’
12:11:31 <lambdabot>              with actual type ‘L.ParameterizedList item0 remainder0’
12:11:39 <benzrf> > In (L.Cons "foo" (In (L.Cons "bar" (In L.Nil()))
12:11:40 <lambdabot>  <hint>:1:49:
12:11:41 <lambdabot>      parse error (possibly incorrect indentation or mismatched brackets)
12:11:42 <benzrf> arghghghghghg
12:11:44 <benzrf> > In (L.Cons "foo" (In (L.Cons "bar" (In L.Nil))))
12:11:45 <lambdabot>  No instance for (GHC.Show.Show
12:11:45 <lambdabot>                     (L.ParameterizedList
12:11:45 <lambdabot>                        [GHC.Types.Char]
12:11:45 <lambdabot>                        (Lambdabot.Plugin.Haskell.Eval.Trusted.Mu
12:11:45 <lambdabot>                           (L.ParameterizedList [GHC.Types.Char]))))
12:11:48 <benzrf> ok nvm
12:11:53 <bollu> :t ParametrizedLst
12:11:53 <lambdabot> Not in scope: data constructor ‘ParametrizedLst’
12:12:00 <bollu> lol
12:12:09 <benzrf> bollu: you understand how fix works with recursive functions, right?
12:12:14 <benzrf> or rather the y combinator
12:12:33 <bollu> benzrf: nope
12:12:35 <benzrf> oh
12:12:38 <benzrf> welp
12:12:39 <bollu> benzrf: reading about it
12:12:41 <benzrf> ok
12:12:58 * benzrf notices nobody yelled at him for spamming up the channel
12:12:59 <benzrf> \o/
12:13:08 <MP2E> > take 8 $ fix $ scanl (+) 0 . (1:)
12:13:10 <lambdabot>  [0,1,1,2,3,5,8,13]
12:13:12 <MP2E> <3
12:13:17 <MP2E> I like that way more than I should.
12:13:28 <dwcook> benzrf, gosh, do it in PM, why don't you? :P
12:13:50 <bollu> benzrf: ah, so it's similar to the technique demonstrated in SICP where he constructs infinite streams by wrapping the operation in a think?
12:13:54 <bollu> thunk*
12:13:57 <benzrf> not really
12:14:11 <benzrf> bollu: let's say you're writing a recursive function like fac
12:14:12 <benzrf> ok?
12:14:17 <bollu> benzrf: sure
12:14:18 <benzrf> naive impl:
12:14:32 <benzrf> fac n = if n == 1 then 1 else n * (fac (n - 1))
12:14:36 <benzrf> bollu: simple
12:14:52 <benzrf> bollu: now let's say you have to use a lambda
12:14:58 <benzrf> bollu: can you rewrite the above with a lambda?
12:14:59 <bollu> yep. although someone pedantic would argue that 0! is 1 :)
12:15:24 <bollu> for the recursion?
12:15:34 <benzrf> bollu: try it :-O
12:16:37 <Nik05> is there a function like (.) and (<=<) but then for functors?
12:16:43 <bollu> benzrf:  I just.. don't see the point of using a lambda. that's acting as a mental block :|
12:16:55 <benzrf> Nik05: huh?
12:17:00 <benzrf> just (.)
12:17:15 <napping> Nik05: no, being able to do (a -> f b) -> (b -> f c) -> (a -> f c) pretty much means f is a Monad
12:17:16 <enthropy> Nik05: what's the type?
12:17:32 <benzrf> bollu: \n -> if n == 1 then 1 else n * ???????
12:17:40 <napping> If you just knew it was a functor, you could get to (a -> f (f c))
12:18:01 <Nik05> ok wait, let me think about this again :P
12:18:07 <bollu>  benzrf you need some way to refer to your lambda, or some way to generate nested lambdas
12:18:07 <napping> and (join :: f (f a) -> a; return :: a -> f a) is another way to present monads
12:18:23 <benzrf> or if Monad were a superclass of appletive then just join
12:18:47 <napping> maybe you could have some little things around the edges, like if your "f" doesn't have a return, or maybe some class that gives a different sort of f (f a) -> f a with different laws than a monoid join
12:18:59 <napping> but nah, it's not going to work for straight functors
12:19:19 <napping> (.), and fmap to lift plain functions into (f a -> f b)
12:19:46 <benzrf> napping: correct
12:19:48 <benzrf> * Bootvis
12:19:50 <benzrf> ** bollu
12:19:51 <benzrf> >.<
12:19:56 <bollu> xD
12:20:01 <benzrf> bollu: the generally accepted way to do this is like so:
12:20:18 <benzrf> bollu: \this n -> if n == 1 then 1 else n * this (n - 1)
12:20:31 <benzrf> bollu: the lambda takes an argument for recursing, see?
12:20:41 <path[l]> hi, I have a question about quickcheck. Why does this pass my quickcheck -> quickCheck (\xs ->  reverse xs == xs)
12:21:19 <benzrf> @check \xs -> xs == reverse xs
12:21:21 <lambdabot>  +++ OK, passed 100 tests.
12:21:21 <napping> how did the fixpoint combinator go?
12:21:36 <bollu> but, what's "this" supposed to be? who passed this to the lambda?
12:21:44 <benzrf> bollu: that's what y is for
12:21:45 <benzrf> aka fix
12:22:08 <benzrf> y :: ((a -> a) -> (a -> a)) -> (a -> a)
12:22:17 <benzrf> or if you prefer
12:22:21 <benzrf> y :: ((a -> a) -> a -> a) -> (a -> a)
12:22:36 <path[l]> benzrf: am I somehow invoking quickcheck incorrectly … obviously a reversed list should not be equal to the original list.
12:22:49 <napping> for []?
12:23:07 <napping> also any palindrome
12:23:09 <corgifex> > reverse [(), (), ()]
12:23:10 <lambdabot>  [(),(),()]
12:23:15 <bollu> benzrf: hm
12:23:15 <benzrf> bollu: one possible monomorphic type:
12:23:16 <napping> now if quickcheck isn't giving you an example, that's a problem
12:23:17 <tnks> upgrading packages installed by cabal didn't work out too well for me, so I just zapped my ~/.cabal directory, and am reinstalling everything from scratch.
12:23:24 <tnks> is this the common experience?
12:23:29 <benzrf> y :: ((Int -> Int) -> Int -> Int) -> Int -> Int
12:23:44 <benzrf> bollu: it takes a function that takes an Int function and an Int and gives an Int
12:23:52 <benzrf> then it gives an Int function
12:23:56 <benzrf> bollu: \this n -> if n == 1 then 1 else n * this (n - 1)
12:24:00 <benzrf> :t \this n -> if n == 1 then 1 else n * this (n - 1)
12:24:01 <lambdabot> (Num a, Eq a) => (a -> a) -> a -> a
12:24:12 <benzrf> substitute a's for Int's if you like
12:24:14 <path[l]> napping: it’s passing the quickcheck. it’s not finding  counter example
12:24:17 <bollu> sure
12:24:31 <benzrf> bollu: try implementing it :-)
12:24:35 <bollu> benzrf: xD
12:24:38 <path[l]> napping:  it passes a 100 tests : x
12:24:39 <bollu> benzrf: will try
12:24:49 <path[l]> quickCheck (\xs ->  reverse xs == xs)
12:24:51 <path[l]> err
12:24:59 <path[l]> @check (\xs ->  reverse xs == xs)
12:25:00 <lambdabot>  +++ OK, passed 100 tests.
12:25:19 <benzrf> @check \xs -> reverse (xs :: [Int]) == xs
12:25:20 <lambdabot>  *** Failed! Falsifiable (after 3 tests and 2 shrinks):
12:25:21 <lambdabot>  [0,1]
12:25:35 <napping> @check (\xs -> reverse xs == (xs :: [()]))
12:25:37 <lambdabot>  +++ OK, passed 100 tests.
12:25:46 <napping> defaulting!
12:26:03 <Nik05> ok i guess you can just use . :P
12:26:12 <mmmm_> How can I increase the amount of memory ghc can use?
12:26:14 <path[l]> so the problem is the default type?
12:26:30 <napping> Yeah, you didn't say a
12:26:36 <napping> didn't say the list type
12:26:45 <napping> I don't remember exactly why it defaults to ()
12:27:20 <corgifex> extended defaulting in ghci
12:28:06 <Nik05> fmap foo . bar, can i combine that fmap and . ?
12:28:11 <napping> ah, I see.
12:28:14 <Nik05> i think that was my question
12:29:02 <napping> :t (.) . fmap
12:29:03 <lambdabot> Functor f => (a1 -> b) -> (a -> f a1) -> a -> f b
12:29:15 <napping> I guess you could
12:29:32 <marchelzo_> Is there an easy way to use the index of a list element in a map function? Like map (\x -> index x) on any list of length 5 would just return [0,1,2,3,4]?
12:30:03 <corgifex> marchelzo_: zipWith (\i x -> ...) [0 ..]
12:30:29 <marchelzo_> corgifex: nice. thanks
12:31:16 <napping> > imap const "hello"
12:31:17 <lambdabot>  [0,1,2,3,4]
12:31:40 <napping> benzrf: what abou the fixpoint combinator?
12:31:58 <benzrf> napping: what about it?
12:32:04 <corgifex> :t (`zipWith` [0 ..])
12:32:05 <lambdabot> (Num a, Enum a) => (a -> b -> c) -> [b] -> [c]
12:32:06 <napping> Do you want to show how to write it?
12:32:57 <marchelzo_> napping: what module is imap in?
12:33:02 <napping> That's from lens
12:33:23 <napping> Not worth it just for imap
12:33:26 <glosoli> Hey folks, was there some backwards incompatible changes landing in Haskell Mode recently ? C-c C-l does not seem to load my file in ghci anymore and asks to create cabal project instead
12:33:42 <napping> That's a rather confusing message
12:33:53 <marchelzo_> napping: alright, I'll just use zipWith. But I'll look at lens too. thanks
12:34:01 <napping> I think it's really asking if you want to stard running a new ghci from your cabal project
12:34:30 <napping> marchelzo_: lens goes through stuff like indexed profunctors to get to that impa
12:35:07 <napping> You don't have to know much of anything about the guts to use it quite nicely, but it's a lot to get a handle on if you try to understand it all
12:35:23 <marchelzo_> napping: Yeah I think I'll hold off on that for a while :)
12:35:27 <napping> oh, and the non-indexed kinds of lenses are way simpler to understand doo
12:35:56 <napping> At a minimum, you need to have a datatype with fields or recursive structure you want to poke at, before it really starts to pay off
12:36:11 <napping> benzrf: how about the one without let?
12:36:16 <napping> newtype In t = In {runIn :: In t -> t}
12:36:22 <napping> let fix f =  (\x -> runIn x x) (In (\x -> f (runIn x x)))
12:36:55 <glosoli> hmm weird C-c C-l http://lpaste.net/5384744006737461248 seems to mean smth different from now on
12:37:10 <glosoli> This is the message I get when I try C-c C-l
12:40:28 <Para> @pl (all f)
12:40:28 <lambdabot> all f
12:40:34 <Para> @pl any (not . f)
12:40:34 <lambdabot> any (not . f)
12:41:01 <Para__> agh
12:41:06 <Nik05> so why isnt there a (.) . fmap?
12:41:19 <cstanfill> :t (.) . fmap
12:41:20 <lambdabot> Functor f => (a1 -> b) -> (a -> f a1) -> a -> f b
12:41:25 <Para__> is there any practical difference to "all f" vs "any (not . f)"?
12:42:00 <lep-delete> @src all
12:42:00 <lambdabot> all p =  and . map p
12:42:08 <lep-delete> @src any
12:42:08 <lambdabot> any p =  or . map p
12:42:50 <cstanfill> Para__: you mean (all f) vs. not . any (not . f) ?
12:43:04 <Para__> yeah
12:43:05 <Para__> whoops
12:43:10 <Para__> wait no
12:43:12 <Para__> sec
12:43:28 <Para__> yeah
12:43:31 <Para__> thats what I mean
12:44:26 <Para__> Maybe theres a difference in the compiled code
12:44:38 <Para__> but they should be logically equivalent??
12:44:46 <cstanfill> they're probably equivalent
12:45:05 <cstanfill> consider infinite cases carefully but I think so
12:56:18 <glosoli> napping: sir, do you know why would it be asking for me to start a new ghci from my cabal project when all I want is for it to load the file in ghci ?
13:04:08 <glosoli> So after recent updates to haskell-mode one should use cabal projects whenever he/she wants to load stuff into repl inside emacs ?
13:04:11 * glosoli got confused
13:05:48 <theking4444> Hello
13:08:56 <theking4444> @def primes=2:[p|p<-[3..], not $ any (\f->p`mod`f==0) (takeWhile ((<=p).(^2)) primes)]
13:08:57 <lambdabot>  Defined.
13:09:07 <theking4444> > take 10 primes
13:09:08 <lambdabot>  [2,3,5,7,11,13,17,19,23,29]
13:09:39 <theking4444> Hello?
13:09:46 <theking4444> P
13:09:51 <theking4444> > sum primes
13:09:51 <Cale> theking4444: hello!
13:09:54 <lambdabot>  mueval-core: Time limit exceeded
13:10:23 <theking4444> Well, see yall.
13:11:02 <glosoli> Damn can't ready get through these updates on haskell-mode, just started with going through haskell book and boom some update and I am lost ;/ that emacs...
13:11:28 <ReinH> [3,5..] is a bit better
13:11:39 <ryanstout> noob question (sorry, I can’t find a good example to help me understand, been reading for days, seems like it should be simpke, but I keep getting compiler issues).  I’m just trying to take a Maybe and multiple it by 2 if its a Just, what would that look like?
13:11:58 <ReinH> ryanstout: fmap
13:12:09 <quchen> ryanstout: Do you know about pattern matching?
13:12:13 <ryanstout> yea
13:12:29 <ryanstout> I’ve read all of the way through realworldhaskell and learn you good
13:12:31 <quchen> So your function should look like "twice :: ???" -- what is its type?
13:12:31 <Tjr> > fmap (*2) Just 4
13:12:33 <lambdabot>  No instance for (GHC.Show.Show a0)
13:12:33 <lambdabot>    arising from a use of ‘M78949394258573761012329.show_M78949394258573761012...
13:12:33 <lambdabot>  The type variable ‘a0’ is ambiguous
13:12:33 <lambdabot>  Note: there are several potential instances:
13:12:33 <lambdabot>    instance [safe] GHC.Show.Show
13:13:03 <ryanstout> Tjr: thanks, I guess I missed the fmap part
13:13:16 <ryanstout> Tjr: is there a way to do it within a do?
13:13:23 <Tjr> sure
13:13:36 <ReinH> ryanstout: then maybe you remember this http://learnyouahaskell.com/making-our-own-types-and-typeclasses#the-functor-typeclass
13:13:36 <quchen> There is a way to write it yourself, which you should do if it's not obvious what the solution is.
13:13:50 <Nimatek> > Just 2 >>= return . (*2)
13:13:52 <lambdabot>  Just 4
13:14:12 <quchen> Or you can have everyone here show off their LYAH level skills too, which is a great way to teach things.
13:14:17 <wereSheep> I'm trying to upload a package to hackage.h.o using cabal upload, but it fails with 'Error: Forbidden, No access for this resource.' If I upload through the web interface it works. Same credentials.
13:14:21 <ryanstout> Nimatek: ok, so the return puts it into the maybe monad?
13:14:29 <thevishy> how to read a hi file ?\
13:14:34 <ryanstout> sorry, still grepping
13:14:55 <Nimatek> :t return
13:14:56 <lambdabot> Monad m => a -> m a
13:15:12 <meretrix> How I would I insert a debugging traceShow to print the input ByteString of a heavily nested Parser?
13:15:13 <ReinH> ryanstout: don't worry about Nimatek's version
13:15:23 <ReinH> it's equivalent to fmap, just more complicated
13:15:30 <Nimatek> ryanstout: Yeah listen to ReinH, fmap is nicer :)
13:15:35 <ryanstout> ReinH: ok.  I was thinking understanding that version would help me understand
13:15:42 <thevishy> ok nvm thanks
13:15:55 <ReinH> ryanstout: can you write a function mapMaybe :: (a -> b) -> Maybe a -> Maybe b?
13:15:56 <wereSheep> or is there a dedicated channel for cabal / hackage issues?
13:16:19 <ryanstout> ReinH: I don’t think I’m there yet
13:16:38 <ryanstout> anyway thanks everyone, I’ll play with this code for a bit
13:16:44 <ReinH> ryanstout: it would use pattern matching: mapMaybe f (Just x) = ???; mapMaybe f Nothing =???
13:16:44 <ryanstout> I think I wasn’t understanding what return did
13:16:46 <enthropy> wereSheep: #haskell-infrastructure
13:17:35 <ryanstout> ReinH: So the thing I was wanting to do was run a bunch of functions over a Maybe, you would just use fmap for that?
13:18:19 <ReinH> ryanstout: can you give me an example?
13:19:02 <ryanstout> ReinH: I don’t have anything specific, just experimenting.
13:19:20 <ryanstout> maybe nested lookups in a list of lists?
13:19:57 <ryanstout> so in ghci when I try: fmap (* 2) Just 5   I get compiler errors
13:20:08 <ReinH> ryanstout: because that is being parsed as fmap (* 2) (Just) (5)
13:20:12 <ReinH> you want
13:20:16 <lep-delete> > fmap (*2) $ Just 5
13:20:17 <lambdabot>  Just 10
13:20:17 <ReinH> > fmap (* 2) (Just 5)
13:20:18 <lambdabot>  Just 10
13:20:23 <ryanstout> right
13:20:24 <ryanstout> thanks
13:24:32 <benzrf> hey
13:24:51 <Guest33147> haskell-source-exts adds 'module Main (main) where' to the top of source files that dont explicitly have a module decl
13:24:55 <Guest33147> is there a way to get it to not
13:30:06 <bacon> If I do something like, pureListFunc liftM monadList, or ([a] -> a) -> liftM -> m[a], do I lose the benefits of laziness? That is, does the "monadList" m[a], have to be completely created before pureListFunc can start processing it?
13:30:30 <Tjr> Is there something wrong with lambdabot? It's not responding to my queries.
13:31:04 <ReinH> bacon: I can't parse your question :/
13:32:44 <ReinH> bacon: a value of type Monad m => m [a] *can* be lazy:
13:32:52 <ReinH> > fmap (take 10) (Identity [1..])
13:32:54 <lambdabot>  Identity {runIdentity = [1,2,3,4,5,6,7,8,9,10]}
13:33:04 <bacon> ReinH: Well, I'm using some fuzzy language, but I mean if I create some list with the type "m[a]" and then try to do some filter or something on it with a pure function using lift*, does the m[a] list have to be fully evaluated first? So do I have to iterate through the list twice?
13:33:26 <ReinH> It depends on the m
13:33:28 <corgifex> that depends on how you create the list
13:33:37 <corgifex> the m is incidental
13:33:50 <corgifex> also, m [a] is not a list
13:34:36 <Guest33147> > fmap (take 10) (mapM Identity [1..])
13:34:38 <lambdabot>  Identity {runIdentity = [1,2,3,4,5,6,7,8,9,10]}
13:35:06 <corgifex> > fmap (take 10) Nothing
13:35:08 <lambdabot>  Nothing
13:39:23 * hackagebot github-types 0.1.0.1 - Type definitions for objects used by the GitHub v3 API  http://hackage.haskell.org/package/github-types-0.1.0.1 (wereHamster)
13:42:51 <abstract-alf> say I have an infinite list: factorials = scanl1 (*) [1..];  there is no computation done until I try to use the list.  If when I use the list, I access a particular index: factorials !! 10;  will there be repeated computation when I access a larger index? ie. factorials !! 11
13:43:22 <abstract-alf> or is there a memoization of sorts?
13:43:32 <Cale> abstract-alf: If it has a monomorphic type, it's a constant, so it'll be computed at most once
13:43:41 <abstract-alf> wicked ;)
13:44:24 * hackagebot vampire 0.1.3.0 - Analyze and visualize expression trees.  http://hackage.haskell.org/package/vampire-0.1.3.0 (benzrf)
13:44:31 <dwcook> abstract-alf, note that that's different from if you had, say, a factorial function defined like so: fact 0 = 1 ; fact n = n * fact (n - 1). *That* doesn't give you any automatic memoization.
13:44:48 <dwcook> abstract-alf, the key fact here is you're forcing thunks in a list.
13:45:05 <Cale> Yeah, functions are not memoised, it's just that any given variable will be evaluated at most once.
13:45:35 <abstract-alf> man, I love that
13:46:46 <kazagistar> abstract-alf: that said, the time complexity for repeated access is still O(n) because you are indexing a linked list
13:47:12 <abstract-alf> right
13:47:19 <abstract-alf> that's fine
13:47:27 <abstract-alf> I just want to avoid O(n^2)
13:47:35 <dwcook> At least that gives list an advantage in superlinear functions
13:48:00 <Trollinator> multiplication can't be done in O(1) for Integer though, only for Int
13:48:58 <Trollinator> so looking up the factorial in a list is still faster than computing it every time.
13:49:06 <Trollinator> (modulo constants)
13:49:24 <Trollinator> i mean, modulo constant factors.
13:49:31 <dwcook> A perhaps more clear use case is this clever fibonacci
13:49:46 <dwcook> > let fibs = 1:1:zipWith (+) fibs (tail fibs) in fibs
13:49:47 <lambdabot>  [1,1,2,3,5,8,13,21,34,55,89,144,233,377,610,987,1597,2584,4181,6765,10946,17...
13:50:08 <abstract-alf> nice
13:50:24 <kazagistar> Trollinator: for long enough factorials, which are unlikely to be useful. The constants are often pretty huge when you force the program to go to memory
13:50:27 <abstract-alf> now I want to see if I can reproduce that myself
13:50:29 <corgifex> > iterate (round . ((0.5 + sqrt 1.25) *) . fromIntegral) 1
13:50:31 <lambdabot>  [1,2,3,5,8,13,21,34,55,89,144,233,377,610,987,1597,2584,4181,6765,10946,1771...
13:52:22 <ReinH> @quote zip`ap`tail
13:52:22 <lambdabot> quicksilver says: zip`ap`tail the aztec god of consecutive numbers
13:52:27 <Trollinator> let fibs = map snd $ iterate (\(a, b) -> (b, a+b)) (0,1)
13:52:40 <Trollinator> :(
13:52:51 <Trollinator> Oh, I need to use a >
13:52:53 <Trollinator> > let fibs = map snd $ iterate (\(a, b) -> (b, a+b)) (0,1)
13:52:55 <lambdabot>  not an expression: ‘let fibs = map snd $ iterate (\(a, b) -> (b, a+b)) (0,1)’
13:52:59 <corgifex> @pl \(a, b) -> (b, a+b)
13:52:59 <lambdabot> uncurry (ap (,) . (+))
13:53:02 <quchen> Up to constants, calculating any factorial is O(1), since current technology relies on matter representing bits, which is only finitely available in the universe. Therefore, be careful when using complexity to do runtime analysis.
13:53:05 <Trollinator> > map snd $ iterate (\(a, b) -> (b, a+b)) (0,1)
13:53:06 <lambdabot>  [1,1,2,3,5,8,13,21,34,55,89,144,233,377,610,987,1597,2584,4181,6765,10946,17...
13:53:16 <corgifex> needs more unfoldr
13:53:28 <kazagistar> that quote is hilarious, thanks
13:53:56 <kazagistar> :t zip`ap`tail
13:53:57 <lambdabot> [b] -> [(b, b)]
13:54:14 <corgifex> > (zip `ap` tail) [0 ..]
13:54:16 <lambdabot>  [(0,1),(1,2),(2,3),(3,4),(4,5),(5,6),(6,7),(7,8),(8,9),(9,10),(10,11),(11,12...
13:55:06 <ReinH> > let fibs = 0 : 1 : (zipWith (+) <*> tail) fibs in take 10 fibs
13:55:08 <lambdabot>  [0,1,1,2,3,5,8,13,21,34]
13:55:16 <Trollinator> what is `ap`?
13:55:23 <dwcook> @type ap
13:55:24 <lambdabot> Monad m => m (a -> b) -> m a -> m b
13:55:34 <quchen> ap f g x = f x (g x) -- for the (r ->) Monad
13:55:34 <dwcook> Specialize that to functions and you get
13:55:44 <dwcook> (e -> a -> b) -> (e -> a) -> (e -> b)
13:56:00 <dwcook> which has one obvious implementation
13:56:03 <ReinH> @djinn (e -> a -> b) -> (e -> a) -> e -> b
13:56:03 <lambdabot> f a b c = a c (b c)
13:56:25 <ReinH> obvious enough that it can be mechanically derived ;)
13:56:31 <kazagistar> > fib = 0:1: map (uncurry (+)) . xzip`ap`tail fib
13:56:31 <dwcook> Exactly :)
13:56:32 <lambdabot>  <hint>:1:5: parse error on input ‘=’
13:56:37 <kazagistar> er
13:56:50 <kazagistar> > let fib = 0:1: map (uncurry (+)) . xzip`ap`tail fib in fib
13:56:52 <lambdabot>  Not in scope: ‘xzip’
13:56:52 <lambdabot>  Perhaps you meant one of these:
13:56:52 <lambdabot>    ‘zip’ (imported from Data.List),
13:56:52 <lambdabot>    ‘BSC.zip’ (imported from Data.ByteString.Char8),
13:56:52 <lambdabot>    ‘BSLC.zip’ (imported from Data.ByteString.Lazy.Char8)Precedence parsing error
13:57:08 <kazagistar> where did that x come from? I am bismirching our god
13:57:20 <kazagistar> > let fib = 0:1: map (uncurry (+)) . zip`ap`tail fib in fib
13:57:21 <corgifex> type error still
13:57:22 <lambdabot>  Precedence parsing error
13:57:22 <lambdabot>      cannot mix ‘GHC.Base..’ [infixr 9] and ‘Control.Monad.ap’ [infixl 9] in ...
13:57:34 <kazagistar> ah
13:57:58 <kazagistar> > let fib = 0:1: map (uncurry (+)) . (zip`ap`tail) fib in fib
13:57:59 <lambdabot>  Couldn't match expected type ‘[a1]’ with actual type ‘a0 -> [b0]’
13:57:59 <lambdabot>  Relevant bindings include fib :: [a1] (bound at <interactive>:1:5)Couldn't m...
13:57:59 <lambdabot>  Expected type: [a1] -> a0 -> [(b0, b0)]
13:57:59 <lambdabot>    Actual type: [a1] -> [(a1, a1)]
13:57:59 <lambdabot>  Relevant bindings include fib :: [a1] (bound at <interactive>:1:5)
13:58:04 <corgifex> stop
13:58:08 <kazagistar> ok ok
13:59:36 <corgifex> > fix ((0 :) . (1 :) . (zipWith (+) `ap` tail))
13:59:37 <lambdabot>  [0,1,1,2,3,5,8,13,21,34,55,89,144,233,377,610,987,1597,2584,4181,6765,10946,...
14:06:57 <gamegoblin> Anyone have a clever one liner for “all sublists of length 3” ?
14:07:09 <Nik05> hello i got a newtype Parser a = Parser { runParser :: String -> Maybe (a, String) } (from cis194 exercise 10)
14:07:21 <benzrf> hey yo
14:07:26 <Nik05> the excercise is to implement a instance for Functor Parser
14:07:28 <benzrf> havin a problem
14:07:40 <geekosaur> :t filter ((== 3) . length)
14:07:41 <lambdabot> [[a]] -> [[a]]
14:07:59 <benzrf> i set a NOINLINE pragma on my unsafePerformIO function, but it appears that when the function calling it recurses, it gets the same IORef from it as the pre-recursion run-through
14:08:18 <gamegoblin> geekosaur: sorry, I meant noncontiguous sublists. Subsets I guess. But the data format is a list.
14:08:21 <codesoup> is there a variant of assert that allows a customized error message while keeping the source line number?
14:08:49 <Nik05> i have a function that looks like it corrcetly works but i get this error. Couldnt match expected type `a -> f (b, c)` with actual type `Parser a`
14:09:08 <gamegoblin> Nik05: paste your function at lambdapaste
14:09:13 <corgifex> missing a runParser somewhere?
14:09:17 <geekosaur> benzrf: usually you ad NOINLINE to *get* that behavior. if you want a new one each call, you probably want to inline it. but, using unsafePerformIO that way is always risky...
14:09:21 <gamegoblin> Sounds like you’re missing a constructor
14:09:43 <benzrf> geekosaur: oh
14:09:50 <benzrf> i guess i misunderstood what NOINLINE does
14:09:51 <benzrf> >.<
14:10:06 <benzrf> should i change it to an INLINE pragma
14:10:12 <enthropy> codesoup: I think you need template haskell or a preprocessor to add line numbers to error messages
14:10:23 <Nik05> i guess i miss something :P
14:10:33 <Nik05> let me paste it, back in a sec
14:11:03 <corgifex> http://hackage.haskell.org/package/pseudomacros-0.0.1/docs/PseudoMacros.html#v:__LINE__
14:11:09 <geekosaur> you can try. no promises though
14:11:32 <sshine> :t genericLength
14:11:33 <lambdabot> Num i => [a] -> i
14:12:30 <Nik05> http://lpaste.net/106492 -- why doesnt it compile for me?
14:12:43 <Nik05> (compile in lpast)
14:12:49 <benzrf> geekosaur: kk
14:13:21 <gamegoblin> Nik05: remove the .
14:13:40 <gamegoblin> Or...
14:13:43 <Nik05> oh :P
14:13:44 <benzrf> geekosaur: dint work ;=;
14:13:46 <RedNifre> hey there.
14:14:00 <Nik05> gamegoblin no that makes it worse :P
14:14:04 <benzrf> i suppose i could try manually inlining it with the rewriter
14:14:07 <benzrf> n.n
14:14:10 <pavonia> Nik05: I think you mean "runParser p" instead of "p"
14:14:19 <gamegoblin> Yes pavonia is correct
14:14:26 * hackagebot vty-ui 1.7.1 - An interactive terminal user interface library for Vty  http://hackage.haskell.org/package/vty-ui-1.7.1 (JonathanDaugherty)
14:14:37 <gamegoblin> you have to extract the stuff inside your constructor
14:14:39 <corgifex> called it!
14:14:39 <RedNifre> So I'm using cabal for the first time and tried "cabal install scotty", which nearly works, but it ends with "the following packages are likely to be broken by the reinstalls: regex-posix-0.95.1". What's up with that? Should I --force-reinstalls?
14:14:39 <Nik05> pavonia thank you :)
14:14:48 <corgifex> <corgifex> missing a runParser somewhere?
14:14:56 <Nik05> sorry corgifex :)
14:15:05 <gamegoblin> Nik05: you an do it in your pattern matching with “fmap f (Parser p)” instead if you want
14:15:06 <Nik05> oops...
14:15:11 <Fuuzetsu> what's a hefty package that doesn't use TH?
14:15:19 <Fuuzetsu> (and uses Haddock comments)
14:15:34 <gamegoblin> What’s TH?
14:15:37 <Fuuzetsu> TemplateHaskell
14:15:44 <gamegoblin> What do you mean by hefty?
14:15:53 <Fuuzetsu> considerable amount of modules
14:15:53 <benzrf> Fuuzetsu: i do not think that pipes does
14:15:59 <benzrf> not sure if it's hefty tho
14:16:07 <gamegoblin> Pipes is actually pretty small
14:16:09 <enthropy> xmonad-contrib
14:16:17 <gamegoblin> i don’t recal seeing any template in attoparsec or parsec
14:16:20 <gamegoblin> recall*
14:16:25 <Fuuzetsu> attoparsec isn't big
14:16:30 <Fuuzetsu> xmonad-contrib might do
14:16:32 <gamegoblin> It’s about 1000 lines
14:16:37 <gamegoblin> parsec is bigger I think
14:16:46 <gamegoblin> xmonad is only 1200 lines, no?
14:16:54 <luite> attoparsec is a pretty heavy compile though
14:17:04 <Nik05> corgifex i didnt understood your comment, my mind was confused by the function constructor/member/thingy (what is the correct name for that?)
14:17:39 <luite> also i got template haskell running on node.js now, with GHCJS, yay :)
14:17:50 <gamegoblin> oh jesus
14:17:58 <sshine> luite, sounds crazy.
14:18:04 <gamegoblin> why T_T
14:18:11 <corgifex> Nik05: I don't know what you mean :-)
14:18:12 <relrod> :/
14:18:34 <luite> gamegoblin: means that you can skip compiling native code (what GHCJS currently does) and still have Template Haskell
14:18:43 <luite> gamegoblin: and that makes the installation a lot simpler
14:18:56 <corgifex> gamegoblin: xmonad-contrib is not xmonad
14:19:02 <gamegoblin> corgifex: gotcha
14:19:36 <luite> gamegoblin: an it's also better, since the TH gets its info from the target environment, fewer details from the host leak through
14:19:45 <Nik05> corgifex what is the name for the runParser thing?
14:19:49 <benzrf> why cant we just have a widely accepted NaCl-like thing that isnt google pseudo-free garbage
14:20:02 <benzrf> all this asm.js nonsense makes me sick
14:20:03 <benzrf> >:{
14:20:11 <corgifex> Nik05: good question. field name?
14:21:38 <luite> bit now i still have to fix/review GHCJS support for file IO, the directory and the process packages, since that's the kind of code often used in TH (at least if you include template systems)
14:21:44 <Nik05> corgifex i guess
14:21:47 <gamegoblin> Nik05: record field
14:21:54 <luite> it's mostly done, but could do with a bit of attention :)
14:22:20 <benzrf> https://pbs.twimg.com/media/Bq3Y0NOCEAA1mqU.png:large <- this makes me uneasy
14:22:41 <benzrf> oh wait it's invalid anyway
14:22:44 <benzrf> :t sort
14:22:44 <lambdabot> Ord a => [a] -> [a]
14:22:48 <corgifex> was about to say
14:22:53 <Nik05> ok thank you everyone
14:22:54 <corgifex> this is Set all over
14:23:02 <benzrf> corgifex: oh?
14:23:09 <gamegoblin> benzrf: what is that
14:24:04 <benzrf> https://twitter.com/JulianBirch/status/483165704276160512 lol
14:24:44 <systemfault> Not bad.
14:25:05 <Qfwfq> Heh.
14:25:58 <Pythonfant> benzrf: which part of that is invalid? (sry new to haskell and trying to understand)
14:26:29 <Pythonfant> is it that the a is not necessarly ordable?
14:26:43 <benzrf> Pythonfant: yep
14:26:49 <Pythonfant> ok, thx
14:26:52 <benzrf> hmm
14:27:14 <benzrf> @let OrdList a = Ord a => [a]
14:27:14 <lambdabot>  Parse failed: Parse error: =>
14:27:30 <benzrf> @let newtype OrdList a = Ord a => OrdList [a]
14:27:30 <lambdabot>  .L.hs:157:21:
14:27:31 <lambdabot>      A newtype constructor cannot have a context in its type
14:27:31 <lambdabot>      OrdList :: forall a. Ord a => [a] -> OrdList a
14:27:31 <lambdabot>      In the definition of data constructor ‘OrdList’
14:27:31 <lambdabot>      In the newtype declaration for ‘OrdList’
14:27:36 <benzrf> @let data OrdList a = Ord a => OrdList [a]
14:27:37 <lambdabot>  Defined.
14:27:49 <benzrf> @let instance Functor OrdList where fmap = map
14:27:51 <lambdabot>  .L.hs:155:60:
14:27:51 <lambdabot>      Could not deduce (Integral b0) arising from a use of ‘^’
14:27:51 <lambdabot>      from the context (Integral b)
14:27:51 <lambdabot>        bound by the inferred type of primes :: Integral b => [b]
14:27:51 <lambdabot>        at .L.hs:(151,1)-(155,73)
14:27:53 <benzrf> yay
14:28:02 <benzrf> wait what the fuck
14:28:05 <benzrf> @let instance Functor OrdList where fmap = map
14:28:06 <lambdabot>  .L.hs:155:60:
14:28:06 <lambdabot>      Could not deduce (Integral b0) arising from a use of ‘^’
14:28:06 <lambdabot>      from the context (Integral b)
14:28:06 <lambdabot>        bound by the inferred type of primes :: Integral b => [b]
14:28:06 <lambdabot>        at .L.hs:(151,1)-(155,73)
14:28:13 <benzrf> w-where does that come from
14:28:55 <corgifex> @undefine
14:28:55 <lambdabot> Undefined.
14:29:02 <kbrei> just try again. lamdabot just has weird hiccups like that sometimes.
14:29:04 <benzrf> @let data OrdList a = Ord a => OrdList [a]
14:29:05 <lambdabot>  Defined.
14:29:07 <benzrf> @let instance Functor OrdList where fmap = map
14:29:08 <lambdabot>  .L.hs:150:16:
14:29:08 <lambdabot>      Couldn't match type ‘[a]’ with ‘OrdList a’
14:29:08 <lambdabot>      Expected type: (a -> b) -> OrdList a -> OrdList b
14:29:08 <lambdabot>        Actual type: (a -> b) -> [a] -> [b]
14:29:08 <lambdabot>      Relevant bindings include
14:29:27 <benzrf> @let instance Functor OrdList where fmap f (OrdList a) = OrdList (map f a)
14:29:27 <lambdabot>  .L.hs:150:30:
14:29:28 <lambdabot>      Could not deduce (Ord b) arising from a use of ‘OrdList’
14:29:28 <lambdabot>      from the context (Ord a)
14:29:28 <lambdabot>        bound by a pattern with constructor
14:29:28 <lambdabot>                   OrdList :: forall a. Ord a => [a] -> OrdList a,
14:29:32 <benzrf> oooooh
14:29:48 <Fuuzetsu> you shouldn't put constraints on RHS
14:29:53 <benzrf> i know
14:29:59 <benzrf> i was just testing this out
14:30:42 <Fuuzetsu> I think I'll just generate 1000 modules to test with
14:30:46 <Pythonfant> data OrdList a where OrdList :: Ord a => [a] -> OrdList a
14:30:56 <Pythonfant> @let data OrdList a where OrdList :: Ord a => [a] -> OrdList a
14:30:57 <lambdabot>  .L.hs:149:1:
14:30:57 <lambdabot>      Multiple declarations of ‘OrdList’
14:30:57 <lambdabot>      Declared at: .L.hs:147:1
14:30:57 <lambdabot>                   .L.hs:149:1
14:30:57 <lambdabot>  
14:35:29 <benzrf> @undefine
14:35:29 <lambdabot> Undefined.
14:35:31 <benzrf> Pythonfant: ftfy
14:38:12 <Pythonfant> benzrf: thx
14:44:07 <Nik05> ok now i need to figure out this applicative madness :P
14:44:17 <Nik05> when does the quarter fall?
14:45:34 <Nik05> which probably isnt a saying in english...
14:46:01 <Saizan> coin drop?
14:46:28 <kazagistar> the penny drop
14:46:35 <StoneCypher4k> Nik05: those two, or alternately, "when does the other shoe drop"
14:46:48 <Nik05> oke :)
14:47:09 <benzrf> ugh wtf
14:47:15 <benzrf> still does not work
14:47:17 * benzrf flips a table
14:47:19 <Nik05> so when does it drop? :P
14:47:40 <kazagistar> Nik05: there are many pennies
14:47:51 <benzrf> hmmmm
14:48:12 <benzrf> yo geekosaur
14:48:20 <benzrf> if i have something like
14:48:42 <benzrf> 'unsafePerformIO (newIORef (SomeStruct {args = here}))'
14:48:53 <benzrf> is it possible that it's making multiple iorefs to the same internal thing
14:49:04 <benzrf> and im mutating the same memory location from diff refs
14:49:07 <tomejaguar> Is there any overheard to an IORef?
14:49:39 <tomejaguar> What's the layout in memory?
14:49:43 <geekosaur> benzrf, dunno. I still think the whole thing is dubious though
14:49:56 <luite> tomejaguar: yes, mutation has a write barrier, they get special treatment in the gc since they're mutable
14:50:03 <benzrf> geekosaur: well obviously
14:50:10 <tomejaguar> luite: What does that mean exactly?
14:51:18 <tomejaguar> Is that just a compile time issue, or does it have some implications at runtime?
14:51:32 <luite> tomejaguar: that if you modify an ioref, it gets added to a list of things that the gc needs to check
14:52:00 <luite> since its value might be in a younger generation than the ioref
14:53:13 <tomejaguar> Ah right.  That goes beyond my knowledge.
14:53:19 <tomejaguar> Sounds like a compile-time only thing then right?
14:53:26 <luite> no runtime
14:53:38 <tomejaguar> I mean, it has runtime behaviour, but you know exactly what to do at compile time.
14:53:58 <tomejaguar> You don't have to carry around extra information with the IORef.
14:54:00 <luite> tomejaguar: it's a dynamic check that happens when you modify the value at runtime
14:54:29 <tomejaguar> But what's the layout in memory of an IORef?
14:54:38 <tomejaguar> Is it any different to the layout of the underlying type?
14:55:16 <benzrf> so i was thinking about how compilers can be self-hosting because once they are compiled they dont rely on themselves to run
14:55:17 <glguy> It's a pointer to the value stored "in" the ioref
14:55:18 <luite> i think the extra information the IORef has to carry is a flag that says whether it's already on the mutable list
14:55:31 <benzrf> but interpreters require the interpreter to keep running
14:55:43 <luite> but i'm not quite sure :)
14:55:44 <benzrf> so if you have an interpreter for X written in X, it needs to run to run itself
14:55:53 <benzrf> clearly this leads to infinite regression
14:55:55 <tomejaguar> glguy: Sure but any boxed value is a pointer to the value.
14:55:56 <benzrf> but then i had a brilliant idea
14:56:03 <benzrf> just take the fix point of the interpreter
14:56:10 <tomejaguar> luite: Ah right OK.
14:56:48 <tomejaguar> Thanks.
14:57:42 <MP2E> benzrf : Interesting. We'd need a fix tool then :P fix 'python blah.py' or something
14:58:49 <MP2E> not sure how that would work
15:00:55 <benzrf> echo '$1 "fix $1"' >> fix
15:03:29 <startling> benzrf, heh, >>
15:03:59 * startling misparses things too often in this channel
15:06:40 <Fuuzetsu> http://fuuzetsu.co.uk/images/1404079517.png pretty
15:06:52 <Fuuzetsu> I swear there was a colour option
15:07:22 <Fuuzetsu> http://fuuzetsu.co.uk/images/1404079563.png colour edition
15:11:00 <ajf> https://www.youtube.com/watch?v=iSmkqocn0oQ “Haskell is Useless” — Simon Peyton Jones, 2011
15:11:11 <l0cust> Hey, question
15:11:25 <l0cust> What's a good command line option parser?
15:11:37 <l0cust> The only decent one I can find is CmdTheLine
15:11:40 <Fuuzetsu> the applicative something one
15:12:00 <l0cust> Fuuzetsu: CmdTheLine is an applicative functor
15:12:01 <Fuuzetsu> optparse-applicative I think
15:12:14 <l0cust> I'm used to Ruby's optparse
15:12:16 <kazagistar> yeah, I can vouch for that one being pretty nice
15:12:17 <l0cust> which is magical
15:12:59 <l0cust> oh wow
15:13:01 <l0cust> not too bad
15:13:01 <MP2E> I've been using getOpt from base, are these other libraries easier to use?
15:13:32 <kazagistar> optparse-applicative fills a record with applicative, using monoids to customize how it parses each option
15:14:22 <kazagistar> fairly clean and simple
15:14:31 * hackagebot Ketchup 0.3 - A super small web framework for those who don't like big and fancy codebases  http://hackage.haskell.org/package/Ketchup-0.3 (Hamcha)
15:14:57 <kazagistar> with features like automatically printing a nice help option
15:17:55 <kazagistar> oh, and it supports bash completion, though I have no idea how that works
15:18:12 <identity> MP2E: there's optparse-applicative and cmdargs
15:18:33 <identity> I've heard a lot of good stuff about the former but only used the latter -- though I'd probably use the former next time.
15:18:41 <identity> (there are also probably many more)
15:23:21 <jmcarthur> edwardk: no, i haven't managed that yet. i first just made the obvious, less efficient tree structure (where you have to search for the 3-exposed and 5/6-exposed prefixes/suffixes recursively) to make sure i understood how it conceptually worked. i am at the stage where i need to figure out a constant time representation though.
15:24:13 <identity> asd
15:24:23 <identity> sorry.
15:32:25 <edwardk> jmcarthur i got there as well
15:32:40 <edwardk> jmcarthur: i don't think it can be done without unsafeCoerceish hacks or untyped flat buffers
15:33:11 <edwardk> jmcarthur: because the type of the head that you need O(1) access to is inductively defined
15:33:27 <edwardk> and you can't afford to induct to it ;)
15:34:30 <edwardk> you might be able to have a paired up representation of all the 4s, and the inductively matched queue on the right hand side, where you don't induct to access manipulate the 3-exposure or 5,6 exposure of the queue but only do so when you need to prove you've inducted to the same level
15:34:33 <edwardk> but thats a mess
15:34:39 <edwardk> compared to the okasaki version of the same
15:40:49 <brrrrian> how would I map over chunks of a list?
15:40:54 <brrrrian> http://lpaste.net/106493
15:41:07 <brrrrian> you see this operates over chunks of 4
15:44:01 <RedNifre> Hi.
15:44:46 <RedNifre> What's this {- LANGUAGE -} thing at the start of some files, what is LambdaCase and why does cabal complain about it after I force installed scotty after cabal complained about posix regex?
15:45:03 <RedNifre> (First time using cabal, trying to install scotty)
15:45:30 <xeno> RedNifre: it's used to enable language extensions provided by GHC
15:45:50 <sipa> {-# LANGUAGE blah #-} means enable feature blah
15:45:52 <RedNifre> Like a special dialect of Haskell?
15:45:58 <xeno> RedNifre: yes
15:46:17 <xeno> RedNifre: it enables (sometimes controversial/experimental) extensions
15:47:06 <RedNifre> So I guess LambdaCase is too new to be included in the Haskell distribution that I got from the Ubuntu repositories? Or what exactly can cause "Unsupported extension: LamdaCase"?
15:47:07 <sipa> RedNifre: see 7.3.15 of http://www.haskell.org/ghc/docs/7.6.1/html/users_guide/syntax-extns.html for lambda case (as a google search would reveal)
15:47:41 <sipa> RedNifre: ghc? which version?
15:47:59 <xeno> RedNifre: did you spell it right? LambdaCase (vs LamdaCase)
15:48:11 <RedNifre> I think I have 7.4.1
15:48:24 <RedNifre> I didn't spell it at all, it's in the scotty source code which I try to install
15:48:46 <RedNifre> But maybe I already broke haskell when I force installed it because it had a problem with posix regex?
15:57:35 <startling> RedNifre, that wouldn't happen
15:57:53 <startling> RedNifre, you probably need 7.6 at least, which is getting long in the tooth too
15:58:09 <startling> there are other ways to install GHC, fwiw
16:07:02 <RedNifre> Thanks. I just checked and Ubuntu 14.04 LTS has 7.6.3, so now I only have to figure out when they will finally roll out the official upgrade from 12.04 LTS to 14.04 LTS
16:09:56 <startling> You could also get it from the GHC website (iirc they have a .deb?) or compile it
16:10:41 <RedNifre> I know, but I prefer to use the one from the repository if possible.
16:11:07 <RedNifre> also, what might have happened when I told cabal to force install, ignoring whatever was wrong with regex posix?
16:11:36 <startling> RedNifre, the library that it told you about will most likely be broken
16:11:39 <mp> hi, how do I pythonc -c "import pytz; print pytz.common_timezones"? (not this exact list, just how to in general approach timezones in Haskell, including conversion)
16:12:16 <startling> mp, there's "time" and "thyme" on hackage
16:12:27 <startling> thyme has a bit of a nicer API, but pulls in lens
16:12:36 <Hafydd> I wish people would use more serious names.
16:12:49 <RedNifre> Since it didn't work anyway, is there a way to reset cabal?
16:12:55 <startling> RedNifre, you may be able to reinstall that package, if you need it
16:13:06 <startling> RedNifre, rm -rf ~/.ghc will uninstall all the libraries you've installed
16:13:09 <startling> (unless you used sudo)
16:13:43 <RedNifre> sounds like i want that one
16:13:46 <startling> Hafydd: really? I like library names that have a bit of whimsy
16:14:17 <RedNifre> or do you mean .cabal?
16:14:31 <Clint> i like rm -rf ~/.ghc ~/.cabal
16:14:58 <startling> RedNifre: ~/.cabal isn't important to delete
16:15:10 <startling> Clint: why?
16:15:57 <startling> you can delete ~/.cabal/lib if you want, but it's nice to leave ~/.cabal/config and ~/.cabal/packages around
16:16:06 <startling> plus ~/.cabal/bin
16:16:29 <startling> in any case, the actual package database is in ~/.ghc, so it doesn't matter
16:17:27 <Clint> startling: cleanliness, but yeah, i guess ~/.cabal/{bin,lib} would be fine
16:18:07 <startling> I usually leave ~/.cabal/bin, because then I don't have to reinstall cabal.
16:19:03 <Cale> I usually replace ~/.cabal/bin with a symlink to ~/bin though I suppose it'd also work just to change the bin directory in .cabal/config
16:19:17 <startling> ooh, that seems like a good idea
16:19:21 <Clint> cabal-install's in /usr/bin so that doesn't affect me
16:20:11 <Kaidelong> cabal install cabal-install blues?
16:20:15 <startling> I usually upgrade it by cabal install cabal-install, yeah
16:20:30 <startling> RedNifre: anyway, does that help? :)
16:20:38 <Kaidelong> that doesn't work on windows, not sure how it works on *nix
16:21:01 <Kaidelong> cabal install cabal-install builds cabal install but can't subsequently overwrite itself
16:21:28 <MP2E> Kaidelong: right, it's not supposed to be able to. You set your path to where it is, and make sure that directory is before the directory your original cabal-install was in
16:21:47 <MP2E> and then the new cabal-install works and you can upgrade it through cabal from thereafter
16:21:59 <kazagistar> I had to manually mess with my path to get it to work on windows
16:22:13 <MP2E> that's what you have to do either way :P
16:22:18 <MP2E> *nix, windows
16:24:04 <kazagistar> the global path was overriding my local path or something on windows though, I dont remember exactly
16:28:46 <homovitruvius> is there a good example of a compiler for a decently sized language using parsec and modern monadic stacks?
16:35:23 <pavonia> homovitruvius: Have a look at pandoc
16:39:10 <RedNifre> startling thanks, my new plan is to take a month's break from haskell, wait for ubuntu 14.04 lts which has the newest ghc, use the 6 month ubuntu releases from then on and see what happens then.
16:39:12 <RedNifre> hm
16:39:18 <startling> aw. :(
16:39:33 <RedNifre> nah, I'm not that patient ;) Guess I'll create a VM for haskell development :)
16:40:09 <ij> What do these two lines from hoogle/src/CmdLine/All.hs mean? :   cmdLineExpand :: CmdLine -> IO CmdLine
16:40:11 <ij> cmdLineExpand x@Search{} = do
16:40:20 <RedNifre> That way, I minimize the risk for my important workstation and can still continue playing around with haskell.
16:40:22 <ij> Specifically, the @Search{} part.
16:41:02 <RedNifre> I mean, I wasn't that fascinated by a language since I stumbled upon Ruby, so I probably couldn't stay away from it anyways :)
16:41:20 <RedNifre> But that's for another day, good night and until next time :)
16:41:29 <Clint> ij: it matches only when the CmdLine argument is a Search
16:44:41 <qwerasdf> http://lpaste.net/8283037562130399232
16:45:17 <Nervkind1> hey guys i'm currently learning haskell using the book you probably all know "learn you a haskell" but what I'm lacking are some good exercises for training. could you recommend a website where i could find some? or give me some tasks?^^
16:46:21 <pavonia> @google haskell 99 problems
16:46:22 <lambdabot> http://www.haskell.org/haskellwiki/H-99:_Ninety-Nine_Haskell_Problems
16:46:22 <lambdabot> Title: H-99: Ninety-Nine Haskell Problems - HaskellWiki
16:46:25 <qwerasdf> Nervkind1: you could google "kata haskell" and find some code katas
16:46:35 <qwerasdf> Nervkind1: there's also the project euler thingie
16:46:37 <ij> Clint, I'm puzzled about @. I know it works for all@(head:tail). But how does this work? Can you name it for me to google this pattern maybe?
16:46:45 <monochrom> Nervkind1: my http://www.vex.net/~trebla/haskell/learn-sources.xhtml has a link to a set of exercises
16:46:53 <Nervkind1> thank you guys!
16:47:46 <qwerasdf> Nervkind1: :D
16:48:08 <c_wraith> ij: "as pattern"
16:49:03 <jmcarthur> edwardk: i think we might be able to add some type parameters to the inner stacks that, at the ending constructor of the stack, reveal the types expected at the top of the next inner stack.
16:49:21 <zq> how is "forall a. a -> Bool -> Bool" isomorphic to "(exists a. a -> Bool) -> Bool"?
16:49:33 <edwardk> yeah its possible. not sure its worth it. when i compare the amount of code to the implicit recursive catenable stack, its not holding up well ;)
16:50:48 <ij> I found a patch that makes my local hoogle look into libraries functions. Is that available w/o a patch?
16:51:00 <edwardk> jmcarthur: the code is way way bigger, and has to deal with way more cases at every step, so its going to optimize very poorly
16:51:17 <jmcarthur> edwardk: which one is the implicit recursive catenable stack? i don't know of one yet, and i don't think i am quite comfortable enough with recursive slowdown yet to invent it myself.
16:51:30 <edwardk> its the last one in okasaki
16:51:36 <edwardk> working it up now its pretty easy this way
16:51:42 <jmcarthur> oh! i don't remember that one. /me pulls out the book
16:52:02 <edwardk> github.com/ekmett/thrists has my ramblings on the topic
16:52:20 <jmcarthur> ah the amortized one
16:53:37 <jmcarthur> the thing about this real time stuff is i think all the basic operations will end up being non-recursive, which might actually be pretty nice for the optimizer unless bloat from all the inlining hurts too much.
16:53:56 <edwardk> yeah
16:54:18 <edwardk> i was hoping for a nice non-recursive realtime catenable deque
16:54:50 <edwardk> and yeah they should be fully non-recursive default operations
16:54:55 <flebron_> Hi. Am I using HFlags incorrectly? If I compile this program and ask for --help, I only see the "x" flag, not the "y" flag. Trying to use the "y" flag results in a runtime error in my program. http://lpaste.net/106503
16:55:46 <edwardk> jmcarthur: i'd be happy to pick up that Tarjan.hs if there is a nice way to record the witness of what the number of 'powers' of Entity you have to go through is
16:55:52 <flebron_> (The verbatim error is "Flag random_seed not found at runtime, look into HFlags-source/examples/package/Tup.hs.  Sorry.")
16:57:14 <edwardk> jmcarthur: the fact that it seems any such rewrite is going to literally be a rewrite is rather soul crushing though ;)
16:57:30 <edwardk> zomg the number of invariants hurts my head
16:57:43 <jmcarthur> well, i'm not quite done playing with it yet, but yeah, i am disappointed with how tedious it is
16:59:34 <edwardk> jmcarthur: if i figure anything out lemme know. i may go back to it
16:59:44 <jmcarthur> edwardk: i think it's worse than just the number of powers of Entity, too. it's also the type indexes. since they are "between" the prefixes and suffixes, you have to carry them out, too.
16:59:44 <edwardk> for now i'm trying to go back to making progress ;)
17:00:10 <edwardk> well, the type indices i think are okay, just so long as you set up the match right
17:00:56 <jmcarthur> it seems to me that the Entity depth is equally "easy"
17:01:12 <edwardk> https://github.com/ekmett/thrists/blob/master/Tarjan.hs is as far as i got the 'easy' way, sans D4-collapse
17:01:12 <phaskell> D4: Add support for faster copies via Intel Extended REP-MOVSB - https://phabricator.haskell.org/D4
17:01:45 <jmcarthur> is phaskell a bot?
17:02:21 <jmcarthur> yeah, your tarjan implementation looks almost exactly like mine. very tedious
17:02:24 <edwardk> yeah
17:03:14 <edwardk> i got half-way through uncons when i realized i was going to have to deal with d4-chains completely differently
17:03:18 <edwardk> then flipped the table
17:03:25 <jmcarthur> yup
17:03:33 <edwardk> because they hide that in the last !@#() paragraph of the writeup
17:04:01 <edwardk> i kept wondering how they were going to justify the recursion past D4s then i got to the end and go, oh, they don't!
17:04:17 <jmcarthur> our experiences are basically the same
17:09:25 <jmcarthur> i'm going through the non-catenable version the described first, to experiment with this stack of stacks of stacks thing.
17:09:29 <jmcarthur> i already hate it
17:11:33 <edwardk> yeah. i started over trying to figure out if there is a nice encoding of it, but i'm not loving it either
17:13:08 <edwardk> the non-catenable version is to just drop Q2 the sort of bactrian camel version of it
17:13:34 <edwardk> and just deal with the one-hump closed case
17:13:57 <edwardk> i was calling them dromedary and bactrian deques for a while
17:23:53 <edwardk> ok, i might have a path forward, trying it out
17:24:42 * hackagebot handle-like 0.0.0.11 - HandleLike class  http://hackage.haskell.org/package/handle-like-0.0.0.11 (YoshikuniJujo)
17:28:59 <solidus-river> jle`: /ws 1
17:29:12 <solidus-river> whoops, :X ancient text enedered
17:29:27 <solidus-river> good afternoon though :)
17:30:57 <jle`> solidus-river: has happened to me many times :P
17:30:59 <jle`> afternoon :)
17:33:49 <jle`> how come my hackage package has so many downloads; there is no way people actually use it
17:33:56 <jle`> is there some bot that downloads hackage packages?
17:35:47 <solidus-river> jle`: what package?
17:35:56 <jle`> http://hackage.haskell.org/package/tagged-binary
17:36:02 <jle`> i can't imagine anyone else downloading it except for me :|
17:36:18 <jle`> i only put it up as a separate package to separate out functionality for a larger library i was writing
17:36:53 <jle`> also i think it is just a reinvention of Data.Dynamic
17:37:26 <solidus-river> seems pretty usefull
17:37:31 <jle`> except serializable to binary
17:37:46 <jle`> i guess you can't serialize Data.Dynamic
17:38:23 <jle`> i was going to use it for a typed communication channel between a server and a ghcjs websockets client...both the javascript and the server compile the same library so they can interop seamlessly with the same data types
17:38:28 <solidus-river> serializable to binary is big, look at all the different implimentations of bson floating around
17:39:00 <solidus-river> i'm still wrangling netwire
17:39:28 <solidus-river> i think i've convinced myself you cant do a real continouse time game loop in it
17:39:47 <jle`> yeah, but i can't imagine a world where more than a couple people have downloaded it in the past six months
17:39:53 <jle`> solidus-river: what do you mean?
17:39:57 <solidus-river> my example game is space invaders and i have to pain points i'm not sure how to deal with
17:40:15 <solidus-river> the first is it mkaes sense for the invaders / player / bullets to be their own wires
17:40:32 <jle`> there's a yampa space invaders tutorial, but it uses some abstractions that i might call notsomodern
17:40:44 <solidus-river> but i need to allow the player to add more bullets wires  and i need to allow the invaders to die
17:40:57 <jle`> solidus-river: mhm, so you need dynamic wire collections
17:41:14 <solidus-river> aye, but i was hoping to do that with a wire that returns Maybe (next wire)
17:41:36 <solidus-river> and i can have the player wire return any bullets it created in its iteration
17:41:50 <solidus-river> but then i get stuck with collisions
17:41:56 <solidus-river> bullets position is a function of time
17:41:57 <jle`> for that specific wire, there's Control.Wire.Switch
17:42:00 <solidus-river> invaders position is a function of time
17:42:10 <solidus-river> in order to do collisions both knows need to know the previous step of the other
17:42:33 <solidus-river> *both wires
17:42:35 <jle`> have you looked at my battlefield simulation/clone, it tackles some similar issues
17:42:47 <jle`> where different soldiers can shoot arrows at eachother
17:42:54 <jle`> and the arrows travel and hit other soldiers
17:42:59 <jle`> and kill them and eachother and stuff
17:44:01 <solidus-river> i havent, i'll go check it out
17:44:17 <jle`> i should probably put a video demo up
17:44:25 <jle`> actually i'm not sure how much it would help you because the code isn't very well documented :|
17:44:27 <solidus-river> the only way i can see through it atm is to animate first and then calculate collisions based on the end position of invaders and hit intersection with bullets
17:44:35 <jle`> and it's sort of mish mashed as i think of new ideas and throw them in
17:44:49 <solidus-river> so that way at least the bullets only need to know about the end poisitions of the invaders, but you still end up duplicating the invaders position and pulling state out of the invader wires, which seems bad
17:44:57 <luite> jle`: just some GHC.Generics derived serialization (Data.Binary) works well here for js <-> native communication
17:45:06 <jle`> luite: nooooo :'(
17:45:13 <luite> unfortunately GHC.Generics tends to blow up code size
17:45:14 <jle`> oh
17:45:29 <jle`> it was supposed to allow for polymorphic/heterogeneous channels
17:45:40 <jle`> so that multiple processes can wait on the same websocket
17:45:46 <flebron_> (In case anyone was looking - yes, that was a bug in HFlags :) https://github.com/errge/hflags/issues/8 )
17:45:52 <jle`> and differentiate what they receive based on the type of the data that comes through
17:46:01 <jle`> one process can process all Ints...one can process all Strings...
17:46:14 <luite> jle`: that's not a problem if you have a low level handler that pushes around bytestrings with a channel tag
17:46:59 <jle`> hm
17:47:03 <jle`> so instead of tagging the packets with the type
17:47:09 <jle`> tag the packets with a destination channel?
17:47:57 <luite> yeah, is that not flexible enough?
17:48:01 <jle`> solidus-river: i can discuss my attempts at solving this problem, but it would be a bit long-winded for #haskell.  if you want we can take it to pm
17:48:47 <ReinH> Hmm, I wonder why SimonM uses newTVarIO here http://chimera.labs.oreilly.com/books/1230000000929/ch12.html#conc-server_00000114
17:48:50 <ReinH> doesn't seem necessary
17:49:00 <jle`> luite: it's probably more flexible, actually; i actually had in mind to model it off of the interface of cloud haskell / distributed
17:49:06 <jle`> luite: that's how they handle their communication channels
17:49:14 <Cale> ReinH: Relative to what?
17:49:15 <jle`> x <- receive :: Process Int
17:49:23 <ReinH> Cale: newTVar without IO
17:49:26 <jle`> and the thread will block until an Int is received
17:49:33 <Cale> ReinH: That wouldn't have the given type
17:49:43 <Cale> ReinH: unless you throw in an atomically
17:49:53 <ReinH> Cale: yes, but why not give it type STM () and use atomically?
17:50:09 <Cale> I guess you could have newServer :: STM Server
17:50:16 <ReinH> er yes, that sorry
17:50:23 <ReinH> I guess just to avoid the call to atomically?
17:50:25 <luite> jle`: ah i see
17:50:51 <Cale> I suppose that this is part of the external interface to the library, so maybe he's planning to hide the use of STM somewhat eventually
17:51:06 <Cale> I dunno :)
17:51:15 <ReinH> It's just a bit strange that he uses newTVarIO instead of newTVar without motivating or explaining it at all
17:51:19 <ReinH> not a big deal, just curious
17:51:31 <Cale> It's plausible that newServer might eventually need to do IO
17:52:20 * ReinH shrugs
17:53:01 <luite> jle`: i do have a minor problem with polymorphic data over a channel at th moment (communication between ghcjs and node.js to run template haskell on node), qReifyAnnotations :: Data a => AnnLookup -> m [a] is the one remaining unimplemented reification query type because of that
17:53:12 <ReinH> Cale: he doe make a note about specifically using STM for newClient on the previous page, so maybe he defaults to newTVarIO
17:53:18 <ReinH> it's not a big deal
17:53:50 <napping> Does anyone know if an occurs check is used in simplifying closed type families?
17:53:50 <luite> but i'll probably just pull the serialized annotations out of a hat on the server somewhere, and compile the deserializer to javascript
17:54:34 <luite> unfortunately there is no official way to get it in the Q monad, so it will be a much less nice implementation than te rest of the template-haskell client/server stuff
17:58:11 <edwardk> jmcarthur: ok, i have the basic type for the thing to check, now to try to implement operations
17:58:36 <napping> hmm, guess not - :kind! forall a . IsEq a [a] doesn't reduce
17:59:44 * hackagebot eros 0.2.1.0 - A text censorship library.  http://hackage.haskell.org/package/eros-0.2.1.0 (pharpend)
18:01:06 <l0cust> OOh that's my package
18:01:08 <l0cust> cool
18:04:45 * hackagebot handle-like 0.0.0.12 - HandleLike class  http://hackage.haskell.org/package/handle-like-0.0.0.12 (YoshikuniJujo)
18:09:45 * hackagebot handle-like 0.0.0.13 - HandleLike class  http://hackage.haskell.org/package/handle-like-0.0.0.13 (YoshikuniJujo)
18:13:13 <l0cust> The handle-like author seems to be uploading frequently
18:18:23 <l0cust> Can someone explain what an "orphan instance" is
18:18:31 <l0cust> The warnings keep coming up in my code
18:18:35 <l0cust> Or, when I compile my code
18:19:50 <geekosaur> you have defined an instance for a type where either the class or the type is not defined in your code
18:19:55 <geekosaur> this is a recipe for breakagwe
18:23:15 <l0cust> geekosaur: well, that's just not true
18:23:59 <geekosaur> ghc thinks it is
18:24:19 <geekosaur> one thing I will admit is I'm not sure whether it defines your code as "part of that project" or "the same source file"
18:24:46 <l0cust> geekosaur: Thanks for the help
18:24:46 <geekosaur> beyond that I think you'll have to show the code in question
18:25:06 <l0cust> geekosaur: I'm a bit preoccupied at the moment (making other changes). Once I get done with that, I'll show the code
18:25:08 <geekosaur> (however I probably won't be able to help if it comes down to what ghc is doing / thinking internally)
18:25:14 <l0cust> Actually, here - https://github.com/pharpend/eros
18:27:17 <shergill> haskell doesn't have a type level '_' does it?
18:27:28 <l0cust> shergill: what?
18:27:58 <shergill> l0cust: wildcard. something which matches anything, with no binding
18:28:32 <edwardk> jmcarthur: ok, my brain exploded again
18:28:38 <Kaidelong> how does TypedHoles interact with DeferTypeErrors?
18:28:40 <shergill> could be of use in type families, instead of having to repeat types from the instance  head
18:28:40 <edwardk> jmcarthur: i'm done with this for the night ;)
18:28:49 <geekosaur> shergill: no
18:29:01 <jmcarthur> edwardk: heh, yeah, i quit a while ago
18:29:03 <l0cust> shergill: no, there is no type for _
18:29:12 <l0cust> shergill: at least not that I know of
18:29:21 <pavonia> @let type Foo __ = Foo
18:29:22 <lambdabot>  .L.hs:147:1:
18:29:22 <lambdabot>      Cycle in type synonym declarations:
18:29:22 <lambdabot>        .L.hs:147:1-17: type Foo __ = Foo
18:29:33 <pavonia> @let data Foo __ = Foo
18:29:35 <lambdabot>  Defined.
18:29:39 <pavonia> :t Foo
18:29:39 <lambdabot> Foo __
18:29:47 * hackagebot eros 0.2.1.1 - A text censorship library.  http://hackage.haskell.org/package/eros-0.2.1.1 (pharpend)
18:29:54 <pavonia> @unlet
18:29:54 <lambdabot>  Define what?
18:29:55 <shergill> i was hoping someone would've implemented a syntactic extension, oh well
18:30:04 <pavonia> @unlet Foo
18:30:04 <lambdabot>  Parse failed: TemplateHaskell is not enabled
18:30:12 <relrod> @undefine
18:30:12 <lambdabot> Undefined.
18:30:19 <pavonia> Ah, thanks
18:33:44 <edwardk> jmcarthur: it looks like i can decompose the deque with something like:
18:34:00 <edwardk> jmcarthur: Deque :: Down l3 l56 r m c d -> Bottom m b c -> Up r3 r56 m r a b -> Deque r a c   -- where the 3 and 56 parameters track exposure
18:34:19 <edwardk> and the Down and Up types track the types they change the entries to as they move left to right through them
18:34:41 <edwardk> so we start at r, go down to m, come back up to r
18:34:42 <jmcarthur> edwardk: oh, you're going all the way and tracking the internal invariants too. that's more than i was trying
18:35:07 <edwardk> you wind up needing exposure information for one of the cases
18:35:30 <jmcarthur> huh. i didn't expect that (and am still skeptical)
18:35:38 <jmcarthur> however, i imagine writing this actually is a bit easier with that in the types anyway
18:36:07 <edwardk> its mentioned in the last paragraph somewhere that the trick they use is to encode it as a couple of bits, but we can possibly recover it from the constructors themselves
18:37:18 <edwardk> anyways the reason i was encoding it was because 'color' is a pain in the ass to track, you need runs of 4s, isolated 3s and isolated 5,6's where 3s don't follow 3s, and 5,6's don't follow 5,6's and the run of 4s is consolidated
18:38:09 <edwardk> which can be encoded by saying that you have the notion of a non-empty run of 4s that ends things, and you can have your 3s and 5s carry a 'run of 4s' before it so they alternate then end in 4s, and you get O(1) access to the 3s and 5s so long as you don't care about the content type of them
18:38:12 <edwardk> which is fine
18:38:45 <jmcarthur> did you mean for the return type of that constructor to be that way? the d type parameter in the first field is only used in that one place
18:39:02 <jmcarthur> oh im guessing this isn't your real code
18:39:15 <edwardk> yeah, just a sketch, and woops =)
18:39:29 <edwardk> so with that you can say things like:
18:39:34 <edwardk> a <| Deque (Down4 NoDown4s) (B7 b c d e f g h) (Up4 NoUp4s) = Deque (Down4 (Down4s a b c d NoDown4s)) B0 (Up4 (Up4s NoUp4s e f g h))
18:39:48 <edwardk> which is a bit repetitive but looks like it works
18:40:04 <theking4444> @remeber
18:40:04 <lambdabot> Incorrect arguments to quote
18:40:10 <jmcarthur> alright, i'm going to read back over what you've said and try to understand it
18:40:13 <theking4444> @help remeber
18:40:13 <lambdabot> help <command>. Ask for help for <command>. Try 'list' for all commands
18:40:33 <theking4444> @help remember
18:40:33 <lambdabot> remember <nick> <quote>: Remember that <nick> said <quote>.
18:40:59 <theking4444> How do you recover what lambdabot remembers?
18:41:08 <theking4444> @remember
18:41:08 <lambdabot> Incorrect arguments to quote
18:41:15 <edwardk> but the 4s need to be managed in a deque themselves or you run into problems later
18:41:25 <edwardk> hence the stack of stacks of stacks comment at the very end
18:41:40 <gamegoblin> @remember lambdabot remember
18:41:40 <lambdabot> Okay.
18:42:13 <edwardk> @remember remember
18:42:13 <lambdabot> Incorrect arguments to quote
18:42:28 <gamegoblin> the 5th of november
18:42:32 <edwardk> =)
18:42:50 <theking4444> > take 50 primes
18:42:51 <lambdabot>  Not in scope: ‘primes’
18:43:00 <theking4444> @list
18:43:00 <lambdabot> What module?  Try @listmodules for some ideas.
18:43:04 <theking4444> @listmodules
18:43:04 <lambdabot> activity base bf check compose dice dict djinn dummy elite eval filter free fresh haddock help hoogle instances irc karma localtime more oeis offlineRC pl pointful poll pretty quote search slap source spell system tell ticker todo topic type undo unlambda unmtl version where
18:43:10 <theking4444> @list free
18:43:10 <lambdabot> free provides: free
18:43:14 <theking4444> @help free
18:43:15 <lambdabot> free <ident>. Generate theorems for free
18:43:25 <theking4444> free Functor
18:43:34 <theking4444> @free Functor
18:43:34 <lambdabot> Pattern match failure in do expression at src/Lambdabot/Plugin/Haskell/Free/FreeTheorem.hs:54:21-35
18:43:46 <theking4444> @free f x=x
18:43:47 <lambdabot> Extra stuff at end of line
18:43:56 <theking4444> [A
18:44:21 <theking4444> @free f (Just x)=x; f Nothing=mempty
18:44:21 <lambdabot> Extra stuff at end of line
18:44:27 <theking4444> @help free
18:44:27 <lambdabot> free <ident>. Generate theorems for free
18:44:34 <theking4444> How do you use free?
18:44:41 <theking4444> @help fresh
18:44:41 <lambdabot> fresh provides: freshname
18:44:46 <theking4444> @fresh
18:44:46 <lambdabot> Hamr
18:44:51 <theking4444> @fresh
18:44:51 <lambdabot> Hams
18:44:55 <theking4444> @fresh
18:44:55 <lambdabot> Hamt
18:45:06 <theking4444> @help dict
18:45:06 <lambdabot> dict provides: dict-help all-dicts bouvier cide devils easton elements foldoc gazetteer hitchcock jargon thesaurus vera wn world02
18:45:16 <theking4444> @help jargon
18:45:17 <lambdabot> jargon ...... Jargon File
18:45:26 <theking4444> @jargon Monad
18:45:28 <lambdabot> No match for "Monad".
18:45:33 <theking4444> @jargon internet
18:45:35 <lambdabot> *** "internet" jargon "The Jargon File (version 4.4.7, 29 Dec 2003)"
18:45:35 <lambdabot> Internet
18:45:35 <lambdabot>  n.
18:45:35 <lambdabot>  
18:45:35 <lambdabot>         The mother of all networks. First incarnated beginning in 1969 as
18:45:37 <lambdabot> [54 @more lines]
18:45:37 <relrod> theking4444: it accepts PMs btw
18:45:57 <theking4444> @thesaurus pie
18:45:58 <lambdabot> Error: 550 invalid database, use SHOW DB for list
18:46:40 <gamegoblin> Is Int by default 32 or 64 bits, or is it platform dependent?
18:47:12 <jmcarthur> gamegoblin: platform dependent
18:47:27 <jmcarthur> gamegoblin: and in fact it's not even guaranteed to be machine word size
18:47:33 <gamegoblin> wat
18:47:40 <gamegoblin> k
18:48:02 <benzrf> hmm
18:48:07 <jmcarthur> gamegoblin: if you care about that kind of thing, maybe use one of the C types from the FFI. if you just want some specific number of bits, try Int32 or Int64
18:48:20 <gamegoblin> Yes I am giong to use Int64
18:48:31 <gamegoblin> going*
18:49:49 * hackagebot eros 0.3.0.0 - A text censorship library.  http://hackage.haskell.org/package/eros-0.3.0.0 (pharpend)
18:50:05 <jmcarthur> gamegoblin: CIntPtr probably has a good chance of being machine word size
18:50:31 <gamegoblin> I just need something to use as a 48 bit bitstring, so Int64 will work just fine
18:50:35 <jmcarthur> ah
18:50:40 <gamegoblin> And it’s my machine word size
18:54:39 <gamegoblin> Which one of these is represented more compactly in memory: MyData Type Type or MyData (Type, Type)
18:54:39 <carter> gamegoblin: JS?
18:54:45 <gamegoblin> carter: what?
18:54:49 <carter> 48bits
18:54:58 <gamegoblin> What about it
18:55:04 <carter> nvm
18:55:08 <carter> i'm very literal righ tnow
18:56:33 <jmcarthur> gamegoblin: if the former is defined with data and the latter with newtype, they will have the same memory usage. if the latter is also defined with data, the former will be cheaper.
18:57:01 <carter> and thats ignoring if unpacking happens
18:57:08 <jmcarthur> gamegoblin: well, by "cheaper" i mean just in terms of space usage
18:57:27 <jmcarthur> carter: you have to enable an optimization flag for any automatic unpacking though, no?
18:57:36 <gamegoblin> I always enable -O2
18:57:38 <jmcarthur> carter: (and only for certain kinds of types, of course)
18:57:39 <carter> unpack small fields is on by default in 7.8
18:57:41 <jmcarthur> gamegoblin: beyond that
18:57:44 <carter> right?
18:57:58 <jmcarthur> carter: oh, i was under the impression that it was not
18:58:08 <gamegoblin> Does ghc have anything equivalent to -Ofast in gcc
18:58:09 <carter> i could be wrong
18:58:13 <gamegoblin> Where is basically turns on all the flags
18:58:21 <carter> gamegoblin:  you actually dont want that
18:58:24 <carter> ever
18:58:29 <hpc> you want -O2
18:58:34 <carter> yes
18:58:36 <hpc> which is turn on all the safe optimizations
18:58:37 <jmcarthur> not all optimization flags are always optimizations
18:58:43 <carter> yeah
18:58:47 <jmcarthur> not even all -O2 optimizations are always optimizations
18:58:49 <carter> some will just eat your Ram
18:58:52 <jmcarthur> but they usually are
18:58:53 <carter> ALL YOUR RAM
18:58:57 <hpc> (safe as in semantics and as in will consistently not make your code slower)
18:59:06 <carter>  yeah
18:59:20 <jmcarthur> e.g. the full laziness transformation is not always an optimization
18:59:28 <jmcarthur> or common subexpression elimination
19:01:49 <gratimax> Any articles about how Haskell parses operators? It has me interested
19:02:00 <gamegoblin> Do the operations in Data.Bits compile down to machine shifts and xors and whatnot?
19:03:48 <jmcarthur> gamegoblin: it depends on the type and safety checks, if applicable
19:03:54 <vova> Hi all. Is there any good doc about xhtml parsing using haskell. What are modules good for it?
19:04:03 <jmcarthur> gamegoblin: ultimately, though, usually
19:06:27 <systemfault> vova: If you _really_ have xhtml then any xml parser should be able to parse it, no?
19:07:53 <rgoulter> HandsomeSoup is nice. http://adit.io/posts/2012-04-14-working_with_HTML_in_haskell.html
19:08:27 <rgoulter> (HXT + TagSoup + HandsomeSoup, I think it is).
19:09:43 <luite> does anyone know a good bunch of self-containd template haskell and quasiquoting examples that use lots of th features, that i can test my implementation with?
19:11:14 <kazagistar> Maxdamantus: I dunno if anyone mentioned this yet, but apparently there is an extention for Idris-like behavior for sugared expressions, XRebindableSyntax
19:11:52 <dabd> could someone please explain why i evaluating skips [] gives me an error? https://gist.github.com/dabd/7d520a0c35f8a4a0cb6a#file-cis194-hw3
19:12:15 <dabd> actually what gives an error is evaluating putStrLn . show $ skips []
19:12:48 <dabd> I get ambiguous type variable 'a0' in the constraint (Show a0) arising from a use of 'show'
19:13:12 <mzero> ah
19:13:20 <kazagistar> dabd: it does not know what type of list you have
19:13:27 <mzero> because, your expression only requires that the list be a list of something that does Show
19:13:49 <mzero> and you have it an empty list - so there is no way to infer the element type
19:13:49 <Maxdamantus> kazagistar: yes. I knew GHC had an extension for that. Didn't know the name off-hand though.
19:13:56 <mzero> try     ([] :: [Int])
19:14:14 <mzero> or
19:14:25 <mzero> putStrLn . show $ skips ""
19:14:31 <mzero> (since "" is always [Char])
19:14:52 <mzero> (well, unless you have the string typeclass extension turned on)
19:15:03 <dabd> mzero: thanks
19:15:30 <kazagistar> or even ([] :: [Void] :P
19:15:36 <mzero> also    print = putStrLn . show
19:15:40 <mzero> already in the Prelude!
19:15:40 <kazagistar> that takes an import though, so it would be silly
19:16:41 <dabd> is Void Data.Void?
19:16:44 <marchelzo_> for Maybe is mplus the same as >>?
19:16:45 <vova> rgoulter: Thank you very much.
19:17:16 <mzero> > Just 34 `mplus` Just 5
19:17:17 <lambdabot>  Just 34
19:17:24 <mzero> > Just 34 >> Just 5
19:17:25 <lambdabot>  Just 5
19:17:28 <mzero> so, no!
19:18:06 <mzero> dabd: yes, but... don't confuse that with "void" in other languages
19:18:31 <marchelzo_> mzero: oops, what about flip (>>)?
19:18:44 <mzero> > Nothing `mplus` Just 34
19:18:46 <lambdabot>  Just 34
19:18:58 <mzero> > Nothing << Just 34
19:18:59 <lambdabot>  Not in scope: ‘<<’
19:18:59 <lambdabot>  Perhaps you meant one of these:
19:18:59 <lambdabot>    ‘=<<’ (imported from Control.Monad.Writer),
19:18:59 <lambdabot>    ‘<’ (imported from Data.Ord), ‘<=’ (imported from Data.Ord)
19:19:22 <mzero> > flip (>>) $ Nothing  (Just 34)
19:19:23 <lambdabot>  Couldn't match expected type ‘Data.Maybe.Maybe a1 -> m b’
19:19:23 <lambdabot>              with actual type ‘Data.Maybe.Maybe a0’
19:19:36 <mzero> blorch
19:19:41 <dabd> is there a more concise way to write skips xs = map (\n -> every n xs) [1..length xs]
19:19:51 <mzero> > flip (>>) Nothing (Just 34)
19:19:52 <lambdabot>  Nothing
19:19:55 <mzero> so, again, no
19:20:57 <marchelzo_> oh so mplus avoid returning Nothing when possible but otherwise acts like flip (>>)
19:21:04 <mzero> marchelzo_:   >>   is always just the right result.... whereas   `mplus`  is a combining operation and depends on the two values
19:21:22 <mzero> Not so for other monads
19:21:26 <marchelzo_> yeah i know
19:21:35 <mzero> >  [ 1, 2, 3 ] `mplus` [ 4, 5, 6 ]
19:21:36 <lambdabot>  [1,2,3,4,5,6]
19:21:47 <mzero> > [ 1, 2, 3 ] >> [ 4, 5, 6 ]
19:21:49 <lambdabot>  [4,5,6,4,5,6,4,5,6]
19:21:55 <mzero> !
19:22:01 <Maxdamantus> > the [tint] []
19:22:02 <lambdabot>  []
19:22:44 <Maxdamantus> > the [tfloat] $ [ 1, 2, 3 ] >> [ 4, 5, 6 ]
19:22:46 <lambdabot>  [4.0,5.0,6.0,4.0,5.0,6.0,4.0,5.0,6.0]
19:23:12 <mzero> @type the
19:23:13 <lambdabot> c -> c -> c
19:23:17 <mzero> oy
19:24:16 <Maxdamantus> > the ([tinteger] ~> [tinteger] ~> [tinteger]) (>>)
19:24:17 <lambdabot>  Couldn't match type ‘([GHC.Integer.Type.Integer] -> b0)
19:24:17 <lambdabot>                       -> [GHC.Integer.Type.Integer] -> b0’
19:24:17 <lambdabot>                with ‘[GHC.Integer.Type.Integer]’
19:24:17 <lambdabot>  Expected type: ([GHC.Integer.Type.Integer]
19:24:17 <lambdabot>                  -> [GHC.Integer.Type.Integer])
19:24:26 <Maxdamantus> Meh.
19:24:33 <Maxdamantus> > the ([tinteger] ~> ([tinteger] ~> [tinteger])) (>>)
19:24:34 <lambdabot>  <[Integer] -> [Integer] -> [Integer]>
19:25:08 <kazagistar> the === flip const?
19:25:18 <Maxdamantus> flip asTypeOf
19:25:41 <Maxdamantus> or flip const with the type signature `c -> c -> c`
19:25:54 <Maxdamantus> @src asTypeOf
19:25:54 <lambdabot> asTypeOf = const
19:26:16 <kazagistar> ah, right
19:26:23 <kazagistar> type enforcmenet
19:26:28 <gamegoblin> @hoogle [Maybe a] -> [a]
19:26:29 <lambdabot> Data.Maybe catMaybes :: [Maybe a] -> [a]
19:26:29 <lambdabot> Data.Maybe maybeToList :: Maybe a -> [a]
19:26:29 <lambdabot> Prelude sequence :: Monad m => [m a] -> m [a]
19:29:53 * hackagebot llvm-general-pure 3.3.12.1 - Pure Haskell LLVM functionality (no FFI).  http://hackage.haskell.org/package/llvm-general-pure-3.3.12.1 (BenjaminScarlet)
19:29:55 * hackagebot llvm-general-pure 3.4.3.1 - Pure Haskell LLVM functionality (no FFI).  http://hackage.haskell.org/package/llvm-general-pure-3.4.3.1 (BenjaminScarlet)
19:29:57 * hackagebot llvm-general 3.3.12.1 - General purpose LLVM bindings  http://hackage.haskell.org/package/llvm-general-3.3.12.1 (BenjaminScarlet)
19:29:59 * hackagebot llvm-general 3.4.3.1 - General purpose LLVM bindings  http://hackage.haskell.org/package/llvm-general-3.4.3.1 (BenjaminScarlet)
19:31:32 <brrrrian> helllllloooooo #haskell
19:32:01 <brrrrian> Check out this code which converts a colored .bmp to a grayscale .bmp
19:32:06 <brrrrian> http://lpaste.net/106494
19:32:14 <brrrrian> It's great for < 1MB file.
19:32:17 <brrrrian> and then
19:32:25 <brrrrian> I tried a ~60 MB image
19:32:26 <brrrrian> POW
19:32:39 <brrrrian> out goes my RAM... swapping... GC going nuts
19:32:53 <brrrrian> I suspect this is due to "lazy evaluation + IO"
19:32:58 <brrrrian> but
19:33:05 <brrrrian> how can I reason about this better?
19:33:18 <brrrrian> e.g. how can I write code that runs in constant space?
19:33:44 <brrrrian> err how do I learn this skill... aka not just 'oh use pipes'
19:34:49 <mzero> let's see... in this code you BS.unpack a 60MB file ... then process it all, and then BS.pack it all
19:34:53 * hackagebot HUnit-approx 1.0 - Approximate equality for floating point numbers with HUnit  http://hackage.haskell.org/package/HUnit-approx-1.0 (RichardEisenberg)
19:35:45 <mzero> codec.BMP might be the enemy here
19:35:59 <gamegoblin> mzero: That’s what I was thinking — I don’t see anything too crazy in the code itself here
19:36:15 <mzero> well..
19:36:48 <bms1> Well, other than the fact that it's problematic that readBMP and writeBMP read the whole code into strict bytestrings,...
19:37:01 <bms1> Wouldn't it help to operate directly on the bytestring, rather than unpack it?
19:37:04 <mzero> IF  the pipeline can't be lazy driven nicely... then you are building up a lot of lists of Word8... which is a pretty big memory expansion from the 32bit per pixel version
19:37:39 <mzero> bms1: I'd think that would be unfortunate - looses the ease of the code
19:37:57 <gamegoblin> ByteString defines a map function — why can’t one just map your luma function over the bytestring?
19:38:12 <mzero> and really, given proper BMP functions, one should be able to have the system pack / process / unpack   all in constant memory
19:38:35 <bms1> Isn't the code just map? So use Data.ByteString.map rather than Prelude.map?
19:39:23 <brrrrian> Ok, but I thought that bytestring was good at fusion?
19:39:41 <brrrrian> shouldn't the conversion btwn ByteString and [Word8] be costless?
19:39:42 <mzero> no - map over a ByteString will do things one byte at a time - this needs 4-bytes at a time
19:39:59 <bms1> oh
19:40:22 <gamegoblin> brrrian: no, it is not costless
19:40:43 <brrrrian> mzero: what do you mean by proper proper BMP functions?
19:40:57 <brrrrian> gamegoblin: nearly costless?
19:41:03 <mzero> well... these don't take lazy ByteStrings which would be much nicer
19:41:14 <gamegoblin> brrrian: they are represented very differently in memory
19:41:17 <mzero> remember ByteString = C malloc under the hood
19:41:26 <gamegoblin> God I can never get the number of R’s in your name right brrrrian
19:41:53 <brrrrian> gamegoblin: b r r <tab>
19:42:56 <mzero> also - the BMP unpackBMP and packBMP functions make complete non-Lazy copies of the pixmap
19:43:10 <brrrrian> mzero: even if it is strict bytestring, and entire file must be read, why is this inefficient?  does it cause more copying?
19:43:35 <mzero> well... brrrrian complained of memory thrash
19:44:07 <mzero> a 60MB file here is going to create 240MB just in 4 60MB ByteStrings ... and we haven't even gotten to his code
19:44:43 <mzero> the question is - is the BS.unpack lazy enough?
19:44:57 <mzero> ah, know
19:44:59 <mzero> ah, no
19:45:02 <mzero> HERE's the problem
19:45:22 <mzero> becuase packRGBA32ToBMP takes a strict ByteString...
19:45:39 <mzero> ...BS.pack rgba' must convert a [Word8] to a strict ByString....
19:45:41 <bms1> BS.unpack can't be lazy...
19:45:55 <mzero> but that means even to START the packing, it needs to know the length of the list
19:46:23 <mzero> SO - the WHOLE file, as processed [Word8] (at like 32 or 48 bytes per pixel byte) has to be in memory
19:46:41 <bms1> brrrrian: long story short is that you'd probably want a BMP library that allows lazy reads and writes...
19:46:42 <mzero> Why can unpack be lazy?
19:46:56 <mzero> well... If my suspicion is right
19:46:59 <mzero> you can cheat it
19:47:19 <mzero> instead of BS.pack on line 39
19:47:23 <bms1> mzero: Oh, yeah, it can be lazy in construction of the list...
19:47:34 <brrrrian> I ran this program on a ~60 MB file, and from stats: "4270 MB total memory in use"
19:47:39 <mzero> use   LBS.pack   (where LBS is for Data.ByteString.Lazy
19:47:43 <mzero> THEN
19:47:52 <brrrrian> so, even if whole file has to be in memory, fine, but why the explosion of memory usage?
19:47:55 <mzero> brrrrian: that seems right
19:48:26 <mzero> Then   use    LBS.toStrict
19:48:37 <bms1> brrrrian: The linked list representation will cause at least 5x more memory than the bytestring (>=4 byte constructor for each byte)
19:48:50 <mzero> You'll still need the whole byte array in memory for the packRGBA32ToBMP
19:48:58 <bms1> How many bytes in a constructor?
19:49:12 <mzero> but in building up the lazy packed Bytestring, it can consume the list of [Word8]  as it is produced
19:49:50 <mzero> bms1: well.. four for the tag, and then four for the "box", and then the box has to point to the actual contents
19:50:02 <mzero> roughly
19:50:18 <mzero> and if the [Word8] form, there is the spine of the list (the cons cells) too...
19:50:25 <mzero> so at least 20 bytes per....
19:50:32 <mzero> I might be off by another 12
19:51:42 <bms1> mzero: Oh, I completely forgot about the pointers (and boxing)
19:52:12 <mzero> [:-)]   (smiley in a box)
19:53:09 <bms1> So List at best will be 13x as large (4 byte Cons tag + 8 byte pointer per byte) as the ByteString. If it boxes, then 17x (4 bytes per byte)?
19:54:03 <mzero> Remember - the Word8 values are all boxed, too!
19:54:17 <brrrrian> change "BS.pack rgba'" to "LBS.toStrict $ LBS.pack rgba'" ?  This will allow the initial BS.unpack to then be lazy?  But, it looks like unpackBMPToRGBA32 produces a strict bytestring... so... entire file must be read in, my code runs lazily, and then converted back into strict bs and writeFile?"
19:54:44 <bms1> That was my "if it boxes" (for my unfounded hope that it can somehow store it unboxed): so 17x then
19:55:54 <mzero> Now, further, the way this is written ech of the Word8's is a thunk of a call to luma
19:56:04 <mzero> which, if it fused and did the right thing, wouldn't matter
19:56:18 <bms1> Hmm, well we're at it, we should probably force `y` in toGray?
19:56:36 <mzero> try the (LBS.toStrict . LBS.pack)  thing and see if that helps
19:56:42 <bms1> (well, with the code right now)
19:57:06 <mzero> you could force y --- but I hate coding like that... it is sort of a stop-gap
19:57:12 <bms1> yes
19:57:43 <brrrrian> mzero: yes, doing a BSL.toStrict $ BSL.pack worked
19:57:52 <mzero> Do you see why?
19:58:15 <brrrrian> 10s instead of 40s, and 459 MB mem in use instead of 4GB
19:59:14 <mzero> lovely - that looks much more reasonable --- just a few x the 60MB file (because of the large strict ByteStrings that Codec.BMP requires)
19:59:23 <brrrrian> mzero: well, I am not sure about unpackBMPToRGBA32.  it looks like it produces a strict bytestring
19:59:34 <mzero> takes and produces one
20:00:25 <bms1> Now, of course, doing the grayscale *could* be written to only take a few bytes of memory...
20:00:29 <mzero> the key is that LBS.pack need only pull a prefix of the [Word8] list into existance - a batch of say 16k values- evaluate them (forcing all the thunks), and produce a segment of the lazy ByteString at a time
20:01:04 <brrrrian> right, so I see how now my code can operate on the lbs now
20:01:06 <mzero> Sure, LBS.toStrict will need all the segments before it can begin assmebling the one big strict ByteString --- but those are  much smaller that the [Word8] list of thunks
20:01:14 <brrrrian> but I don't understand the memory explosion when it was a sbs
20:01:38 <brrrrian> is it because every iteration of 'toGray' produced a new form of sbs, and that's not the case for lbs?
20:01:39 <bms1> brrrrian: It was the fact that it needed to store the [Word8] all at once on your computer
20:01:44 <mzero> because before BS.pack could pack even the first byte... it needed to know the entire length of the [Word8]
20:01:58 <mzero> but at that point it didn't need the values - it was just getting ready to malloc....
20:02:00 <bms1> Each byte in the [Word8] takes around 17 bytes of memory
20:02:32 <mzero> so at the time of the malloc, it had a 20Mpixel list of [Word8] values - but as thunks, not evaluated Word8s....
20:02:34 <mzero> that's a lot!
20:03:00 <mzero> it too more - it was a thunk, with a full captured context of the call to luma
20:03:13 <mzero> s/too/was/
20:03:28 <brrrrian> oh... damn... an element in [Word8] takes 17 bytes?
20:03:33 <bms1> mzero: Oh, right! Yikes!
20:03:38 <mzero> exactly
20:04:16 <mzero> yes, brrrrian remember, both the list, and the values themselves, are potentially lazy, so they are all "boxed" - meaning have the machinery and pointers for lazy eval
20:05:02 <mzero> But don't worry --- you were right in thinking it shouldn't be a big deal, because it should just all stream through the code - the whole [Word8] list never really existing at once in memory
20:05:16 <mzero> strict BS.pack broke that assumption
20:05:19 <brrrrian> So 60 MB * 17 = 1020... ~1GB... how would you reason about the other 3GB?
20:05:31 <mzero> LBS.pack restores it (though it is strict in smaller chunks....)
20:05:37 <bms1> brrrrian: It's the thunks that mzero was talking about
20:05:51 <brrrrian> mzero: how expensive is it to store the spine of the list?
20:05:54 <mzero> brrrrian: if those Word8 values had been evaluated, then just what you said
20:06:13 <bms1> brrrrian: Roughly 8 bytes per element
20:06:16 <mzero> but... each value was not yet demanded (not until pack demands it as an actual Word8)
20:06:40 <tnks> I'm getting this error when trying to install haskell-src-exts-1.15.0.1:  /usr/bin/ld: cannot find -lHScpphs-1.18.5-ghc7.8.2
20:06:45 <mzero> so what was stored in each cons cell was.... a "thunk", a call to luma r g b, with all the context needed to evaluate it
20:06:47 <tnks> (among others)
20:06:56 <tnks> any hints?
20:07:31 <zRecursive> Is thunk like a function ?
20:07:37 <mzero> tnks: the cpphs package is a dependency of haskell-src-exts
20:08:02 <Cale> zRecursive: "Thunk" is the name given to the low-level runtime representation of an expression.
20:08:29 <Cale> zRecursive: I tend to just use the word "expression", using the word "thunk" is more implementation-focused than is usually necessary
20:08:38 <mzero> a thunk is a "saturated function call" -- that is, a pointer to a function, plus all the arguments that will be used in the call
20:08:41 <brrrrian> I am on pg 35 of smarlow's book, so the next thing I was going to try to do was add paralleism to this :)
20:08:44 <Cale> (Rather like using the word "closure" when one means "function")
20:08:44 <zRecursive> Cale: What does it look like ?
20:08:50 <mzero> (remember that those arguments can be ... yes.... thunks too...)
20:09:00 <bms1> zRecursive: http://blog.ezyang.com/2011/04/the-haskell-heap/
20:09:03 <Cale> zRecursive: In GHC-compiled programs, it looks like a pointer to code
20:09:04 <zq> *23:07:31 ~> ghci -XExistentialQuantitifcation
20:09:10 <tnks> mzero: but shouldn't that be pulled in with dependency management.
20:09:12 <benzrf> is it possible to automatically derive free objects for typeclasses
20:09:15 <benzrf> *from
20:09:19 <tnks> additionally I think it's already installed.
20:09:27 <zq> ghc: unrecognised flag: -XExistentialQuantitifcation
20:09:27 <zq> did you mean one of: -XExistentialQuantification
20:09:27 <mzero> tnks - did you do "cabal install --only-dependencies"   or some such?
20:09:32 <zq> why is ghc trolling me?
20:09:39 <zRecursive> ok
20:09:42 <rwbarton> because you spelled it wrong?
20:09:44 <mzero> how are you trying to build this?  "cabal install haskell-src-exts"  ?
20:09:52 <tnks> mzero: yeah.
20:10:04 <mzero> hmmmm... then yes, it should have installed the dependency
20:10:06 <Cale> zRecursive: A pointer to code which, the first time it's run, will compute a value before rewriting the pointer to point at a shorter piece of code which will return the value immediately
20:10:11 <mzero> are you using sandboxes in cabal?
20:10:26 <tnks> mzero: I'm trying to install a few binaries in my user-level.
20:10:41 <tnks> but I cleared out my ~/.cabal for sanity.
20:10:49 <rwbarton> that was what broke it then
20:11:06 <zRecursive> Cale: need to think it over
20:11:25 <rwbarton> weird errors like this are usually a result of either force-installing packages or going behind cabal's back
20:11:26 <mzero> tnks: which OS?
20:11:30 <tnks> mzero: debian.
20:11:42 <platz> so there is no "stack", it's all "heap"?
20:12:13 <rwbarton> tnks: the fact that cpphs is installed is recorded in ~/.ghc
20:12:14 <mzero> tnks: when you do ghc-pkg list  - do you see cpphs?
20:12:22 <rwbarton> tnks: but the actual libraries live in ~/.cabal -- which you deleted
20:12:27 <Cale> platz: There's a stack in GHC-compiled programs, but it's not what I'd call a call stack
20:12:44 <Cale> platz: A better name would be pattern match stack, or evaluation stack
20:13:09 <Cale> It essentially consists of case expressions which are waiting for their scrutinee to be sufficiently evaluated to match a pattern
20:14:04 <platz> Cale: hrm, interesting. seems like it almost deserves a different name
20:14:13 <tnks> mzero: I do see cpphs.
20:14:14 <Cale> Well, it *is* a stack
20:14:31 <rwbarton> tnks: try ghc-pkg check
20:14:54 <tnks> rwbarton: I ran that command and it came back with a 0 exit code.
20:14:59 <Cale> and operates much like the call stack at the level of the assembly instructions
20:14:59 <tnks> no output.
20:15:12 <rwbarton> hmmm
20:15:17 <bms1> mzero: Wait, is it 24 bytes of overhead for every element of a list? http://lpaste.net/106510
20:15:17 <Cale> It just doesn't correspond to "calls" in terms of the Haskell program
20:15:39 <Cale> bms1: That sounds right
20:15:48 <rwbarton> bms1: are you assuming 32- or 64-bit platform
20:15:52 <bms1> 64-bit
20:15:58 <rwbarton> all the numbers you wrote should be 8 then
20:16:06 <bms1> Oh, yikes
20:16:14 <rwbarton> (for 32-bit, they would all be 4)
20:16:27 <bms1> Why do the tags get bigger?
20:16:55 <rwbarton> they are actually pointers to code
20:17:07 <bms1> oh!
20:17:20 <rwbarton> well, pointers to code and other data located before the code
20:17:59 <tnks> rwbarton: mzero: if I clear out ~/.ghc and ~/.cabal, I should be starting fresh right?
20:18:45 <tnks> oh. . . this might be silly.
20:18:51 <tnks> I might be on an old version of cabal.
20:19:09 <bms1> I'm not very knowledgable with low-level stuff, but it seems like a waste of space to store a pointer given that I can't imagine more than 256^2 different tags...
20:19:17 <Cale> bms1: Also, note that because of pointer alignment, GHC can store more information about which constructor was used in the low-order bits of the pointer on 64 bit architectures. Pointer tagging works for types of up to 7 constructors on 64 bit, and up to 3 constructors on 32 bit.
20:19:55 <Cale> bms1: Before the value is evaluated, the pointer points at the code which computes it.
20:20:29 <bms1> Cale: Ah, thanks! I forgot the tags are (obviously) also possibly lazy
20:20:39 <bitemyapp> bms1: do you want compact packing of elements into a collection?
20:20:41 <Cale> bms1: The first time that code is executed, it rewrites the pointer to point at a "black hole", then computes the value, then rewrites the pointer again to point at a shorter piece of code which returns the value immediately.
20:21:00 <bms1> bitemyapp: No, I'm just curious about the inner workings of GHC! I know of unboxed arrays and all
20:21:01 <Cale> (before returning the computed value on the stack)
20:21:25 <bitemyapp> bms1: cool. Learning is good. I know others here know unboxed vectors exist but I wanted to make certain the possibility had been raised.
20:21:32 <bitemyapp> bms1: speaking of which, don't use array use Vector please.
20:21:34 <Cale> It's sort of a weird thing to get used to at first, but for the most part you can also completely ignore it.
20:21:50 <rwbarton> nothing wrong with Array
20:21:59 <bms1> bitemyapp: Yep, I appreciate it! Hmm... I always use Array
20:22:02 <bitemyapp> rwbarton: Vector's API is better, among other things.
20:22:16 <dmj`> have a noob question
20:22:22 <bitemyapp> very few scenarios would favor array over vector.
20:22:24 <dmj`> unsure why my FromJSON instance isn't parsing: http://lpaste.net/106511
20:22:37 <bitemyapp> I've found, for unknown reasons, that vector was more compact. I don't yet know why.
20:22:42 <bms1> Vector has that nice fusion stuff. But Array feels like less of a package to have to import
20:23:13 <bms1> bitemyapp: http://research.microsoft.com/en-us/um/people/simonpj/papers/ndp/haskell-beats-C.pdf ?
20:23:15 <dmj`> data StripeError = StripeError Text Text
20:23:38 <bitemyapp> bms1: good paper.
20:26:19 <zq> ugh, another (++ " beats C") paper
20:27:34 <bitemyapp> zq: >:)
20:27:41 <tnks> is there a way to get cabal install to use more cores?
20:27:52 <zq> tnks: -j8
20:27:54 <zq> tnks: -jN
20:28:15 <tnks> cool.
20:28:28 <bitemyapp> tnks: limited by the branches of the dependency tree, mind.
20:32:40 <jmcarthur> for ghc 7.8, there's also --ghc-option -jN. doesn't synergize with cabal's -jN, sadly. you have to make a decision about how to parallelize cabal separately from how to parallelize ghc.
20:33:04 <jmcarthur> also, i have experienced some instability with ghc's -j
20:33:12 <jmcarthur> (it's new, so i forgive it)
20:35:17 <bms1> Hmm. If I say data List a = Nil | Cons !a (List a), will GHC unbox the values for, say, List Double?
20:35:31 <rwbarton> nope
20:36:38 <jmcarthur> and this fact makes me sad, regularly
20:36:52 <tnks> man, I'm having a terrible time with cabal. . . feeling like using sandboxes for /every/ single app or something.
20:37:02 <dmj`> anyone?
20:37:09 <bms1> yeah, that's a bummer
20:37:09 <jmcarthur> tnks: that's what some people do, unfortunately.
20:37:26 <tnks> like even for ghc-mod, and hoogle, and other stuff that's really just for dev tools.
20:38:04 <tnks> maybe in ~/.cabal only have cabal installed or something.
20:40:02 <rwbarton> bms1: I don't really think it could do that because I might pass my List Double to a function of type, say, (Show a) => List a -> String
20:40:56 <bms1> rwbarton: Right, so every polymorphic function would have to be specialized for every type variable in case anything's ever a Double... or something like that
20:41:59 <bms1> well, any function involving List a, you'd need to possibly specialize the a to Double
20:42:54 <gamegoblin> @hoogle group
20:42:55 <jmcarthur> some compilers monomorphize functions and data types, when possible. ghc does not.
20:42:55 <lambdabot> Data.List group :: Eq a => [a] -> [[a]]
20:42:55 <lambdabot> Data.ByteString.Lazy group :: ByteString -> [ByteString]
20:42:55 <lambdabot> Data.ByteString.Lazy.Char8 group :: ByteString -> [ByteString]
20:43:26 <gamegoblin> how would one group a list into blocks of size N? That is, myFunction 3 [1,2,3,4,5,6] = [[1,2,3], [4,5,6]]
20:43:37 <gamegoblin> That is, is there is a builtin or do I need to roll my own
20:44:02 <bms1> gamegoblin: There's the 'split' package (Data.List.Split.chunks), or roll your own
20:44:06 <rwbarton> I guess more realistic would be if ghc could see that a List Double was only referred to within a certain function, then it could produce specialized types/functions to be used in that function
20:44:43 <gamegoblin> groupEvery n [] = []; groupEvery n xs = take n xs : groupEvery n (drop n xs)
20:44:49 <gamegoblin> Think that will work
20:45:02 <bms1> :t splitAt
20:45:03 <lambdabot> Int -> [a] -> ([a], [a])
20:45:04 <jmcarthur> :t \n -> takeWhile (not . null) . unfoldr (Just . splitAt n)
20:45:05 <lambdabot> Int -> [a] -> [[a]]
20:45:35 <lfairy> +1 for using unfoldr :)
20:45:37 <jmcarthur> > takeWhile (not . null) . unfoldr (Just . splitAt 3) $ "foobarbazwibble"
20:45:38 <lambdabot>  ["foo","bar","baz","wib","ble"]
20:45:44 <gamegoblin> wow
20:45:52 <dmj`> > chunksOf 3 [1..10]
20:45:53 <lambdabot>  [[1,2,3],[4,5,6],[7,8,9],[10]]
20:46:00 <gamegoblin> Makes mine look so juvenile ;P
20:46:09 <jmcarthur> chunksOf is from the split package, if i recall correctly
20:46:57 <dmj`> yep
20:47:45 <bitemyapp> :t chunksOf
20:47:45 <lambdabot> Int -> [e] -> [[e]]
20:47:47 <bitemyapp> welp.
20:48:22 <dmj`> @typ decode
20:48:23 <lambdabot> Not in scope: ‘decode’
20:55:23 <mayski_> > round 3.5
20:55:24 <lambdabot>  4
20:55:26 <mayski_> >  round 4.5
20:55:28 <lambdabot>  4
20:55:29 <mayski_> wat
20:56:18 <benzrf> unfoldr sounds like the name of a startup
20:56:30 <benzrf> :t unfoldr
20:56:31 <lambdabot> (b -> Maybe (a, b)) -> b -> [a]
20:56:36 <mzero> mayski_: that is the correct behavior of iEEE floats -
20:56:38 <lfairy> mayski_: maybe it rounds to even numbers?
20:56:59 <benzrf> > splitAt 3 ""
20:57:00 <lambdabot>  ("","")
20:57:10 <benzrf> :t iterate
20:57:11 <lambdabot> (a -> a) -> a -> [a]
20:57:14 <mayski_> mzero: I see
20:57:17 <mayski_> thanks
20:57:22 <benzrf> :t unfoldl
20:57:23 <lambdabot>     Not in scope: ‘unfoldl’
20:57:23 <lambdabot>     Perhaps you meant one of these:
20:57:23 <lambdabot>       ‘Seq.unfoldl’ (imported from Data.Sequence),
20:57:25 <mzero> well... admittedly it is odd
20:57:27 <benzrf> :t unfold
20:57:28 <lambdabot>     Not in scope: ‘unfold’
20:57:28 <lambdabot>     Perhaps you meant one of these:
20:57:28 <lambdabot>       ‘BS.unfoldr’ (imported from Data.ByteString),
20:57:31 <benzrf> huh
20:57:54 <mzero> but when a round operation has exactly the same distance to go up or down, then it rounds to even
20:58:13 <mzero> > round 4.5000000001
20:58:15 <lambdabot>  5
20:58:38 <mayski_> I see
20:59:11 <mzero> http://en.wikipedia.org/wiki/IEEE_floating_point#Roundings_to_nearest
21:00:31 <jmcarthur> > map (round . (+0.5) . fromInteger) [0..9]
21:00:32 <mayski_> thanks
21:00:33 <lambdabot>  [0,2,2,4,4,6,6,8,8,10]
21:01:40 <gamegoblin> @hoogle fromMaybe
21:01:41 <lambdabot> Data.Maybe fromMaybe :: a -> Maybe a -> a
21:09:42 <jmcarthur> @tell edwardk in case you haven't stumbled across this yet: https://github.com/atzeus/reflectionwithoutremorse
21:09:42 <lambdabot> Consider it noted.
21:10:14 <edwardk> jmcarthur: yeah i know the main repo
21:10:27 <edwardk> jmcarthur: but i'm trying to make sure i can use it as a deque not just a steque
21:10:35 <edwardk> since i want this for free categories not just this trick
21:10:41 <jmcarthur> aha
21:12:36 <edwardk> the end result will probably that i fold these into the free package under Control.Category.Free -- then i can use them in Control.Monad.Free or more likely a variant
21:13:37 <edwardk> also i wanted the opposite composition order, so that it made a better free category, and (><) can be nicely replaced with (.) ;)
21:13:41 <edwardk> little things
21:14:18 <jmcarthur> right, i did the same thing with composition order
21:16:03 <brrrrian> good lord... I implicitly converted a BS to LBS, ran a map over it, and then back to BS... apparently that fused well...  I tried replacing map with parMap... and well... it no longer fuses well.. what ran in ~400MB just now took ~8GB !  Love it!
21:16:27 <rrradical> I have a data structure which stores many different items in lists, (say, it has a a list of apples and a list of oranges). I want to be able to say: addItem apple itemstore, and have it put the apple in the right place. This is possible with typeclasses, but I need a lot of boilerplate code every time I add a new type of item: http://lpaste.net/106512 Is there a way to reduce this? Is this a place to use template hask
21:16:28 <rrradical> ell?
21:16:31 <edwardk> i want it for hask actually, so that i can have the adjunction that takes categories to their naked hom-sets, mapping functors over either side as arrows, and which when mapped back takes endoprofunctor to the free category of the endoprofunctor. it has a nice connection in Cat/Prof to the adjunction that exists between quotients and equality in Set/Rel
21:16:41 <brrrrian> system swapping so hard right now...
21:18:54 <brrrrian> I should buy a dedicated SSD just for swap partition
21:19:15 <brrrrian> for when I fuck up my haskell foo
21:19:18 <bitemyapp> brrrrian: I just buy one big SSD and put everything on it, including swap. It's pretty great.
21:20:01 * hackagebot eros 0.3.0.1 - A text censorship library.  http://hackage.haskell.org/package/eros-0.3.0.1 (pharpend)
21:20:06 <brrrrian> bitemyapp: true.  need to replace this hdd in general
21:21:48 * brrrrian throws in some more explicit BSL.fromStrict/toStrict and crosses fingers
21:23:02 <brrrrian> nope. damnit.
21:23:14 <brrrrian> turns out i actually have to reason about this thing now
21:24:52 <redtricycle> How do I install cabal that includes cabal sandbox?
21:24:57 <redtricycle> I tried cabal install cabal-install
21:24:59 <redtricycle> to update my cabal
21:25:03 <redtricycle> I am using haskell-platform (latest)
21:25:25 <redtricycle> and...i tried cabal install cabal-dev but it gave warnings that it would break packages due to dependency checking
21:25:47 <redtricycle> cabal 1.16.0
21:26:45 <brrrrian> redtricycle: do you have $HOME/.cabal/bin in your PATH such that it overrides system cabal?
21:28:24 <redtricycle> brrrrian: logged out and logged in...I am OK now, I have cabal sandbox
21:28:27 <redtricycle> don't know why that worked
21:30:47 <jle`> is Integer the Free Num?
21:31:12 <jle`> Num represents a Ring of some sort doesn't it
21:32:05 <bitemyapp> jle`: Integer isn't parametric.
21:32:08 <bitemyapp> jle`: how could it be free?
21:32:32 <bitemyapp> jle`: this is why vague analogies for explaining things irritate me. They mislead people and waste their time.
21:32:44 <jle`> i don't know anything about anything T.T
21:33:00 <bitemyapp> jle`: Free Monoid is [a]
21:33:07 <bitemyapp> jle`: Free Magma is BinaryTree a
21:33:14 <bitemyapp> jle`: Free Semigroup is NonEmpty a
21:33:14 <eyebloom> How do you ensure that an incremental array update does not duplicate the array?
21:33:19 <bitemyapp> jle`: what pattern do you see there?
21:33:29 <bitemyapp> jle`: what do all those free things have in common?
21:33:31 <jle`> it takes something and gives a structure to it?
21:33:33 <jle`> parametric
21:33:37 <jle`> parameterized
21:33:53 <bitemyapp> jle`: there's no constraint on a
21:33:57 <bitemyapp> jle`: and you get the * for Free.
21:33:59 <bitemyapp> jle`: thus, free *
21:34:04 <jle`> hm
21:34:12 <bitemyapp> jle`: it's shake-n-bake structure/pattern for whatever type you inject.
21:34:21 <bitemyapp> it doesn't matter what. If it mattered what, it wouldn't be free.
21:34:34 <bms1> Quicker way than `f &&& f` to write `\(x, y) -> (f x, f y)`?
21:34:45 <bitemyapp> bms1: lazy :)
21:35:05 <jle`> bms1: that's actually (***) btw
21:35:08 <bms1> Really I just don't want to import Arrow... so yes, lazy!
21:35:19 <bms1> jle`: Oh, thanks, right
21:35:35 <bitemyapp> jle`: getting some intuition now?
21:35:40 <jle`> bitemyapp: hm yes
21:35:49 <solidus-river> is it possible to get an opengl 4.4 context with sdl 2?
21:35:52 <bitemyapp> jle`: you should check out Dan Piponi's stuff on free, magma, semigroup, monoid, monad. His talk at BayHac was solid.
21:36:12 <jle`> so what am i thinking about when i am suggesting that Integer can be mapped to any lawful Num instance
21:36:35 <bitemyapp> jle`: show me a type parameter and we can talk.
21:36:36 <jle`> not quite an isomorphism
21:36:47 <jle`> it's not Free
21:36:48 <bitemyapp> jle`: I get what you're saying, but that's not Free.
21:36:53 <copumpkin> jle`: initial ring
21:37:03 <jle`> is initial the word?
21:37:06 <copumpkin> yes
21:37:23 <bitemyapp> jle`: "The ring of integers Z is an initial object in Ring."
21:37:29 <bitemyapp> "The zero ring is a terminal object in Ring.."
21:37:33 <bitemyapp> jle`: http://en.wikipedia.org/wiki/Category_of_rings
21:37:41 <bitemyapp> jle`: http://en.wikipedia.org/wiki/Initial_and_terminal_objects
21:37:51 <bitemyapp> jle`: http://math.stackexchange.com/questions/483731/the-arrows-from-the-initial-object-in-a-category-are-monomorphisms
21:38:10 <jle`> i remember watching the catsters episode on initial and terminal objects and i don't think they gave any convincing/useful examples of initial objects
21:38:27 <bitemyapp> jle`: you seem to have tripped into one?
21:38:32 <bitemyapp> maybe?
21:38:35 <zq> > undefined :: Num ⟹ a
21:38:36 <lambdabot>  Not in scope: type constructor or class ‘⟹’
21:38:37 <jle`> :D
21:38:37 <zq> > undefined :: Num a ⟹ a
21:38:38 <lambdabot>  Not in scope: type constructor or class ‘⟹’
21:38:38 <bitemyapp> motivating stuff in category theory isn't always easy.
21:38:49 <zq> no fancy arrows eh, lambdabot
21:38:51 <bitemyapp> > undefined :: Num a => a
21:38:52 <jle`> such abstract
21:38:53 <lambdabot>  *Exception: Prelude.undefined
21:38:54 <copumpkin> jle`: trivial initial objects are lower bounds of preorder categories
21:38:59 <jle`> much unmotivate
21:39:05 <zq> bitemyapp: unicode, my friend
21:39:18 <copumpkin> jle`: so 0 is initial in the category of naturals ordered by the standard numerical order
21:39:24 <pingu> Am I doing anything 'wrong' by matching on (SomeException MyException)?
21:39:47 <pingu> I've just noticed  fromException :: Exception e => SomeException -> e
21:39:52 <jle`> copumpkin: oh yea
21:40:01 <jle`> that makes sense
21:40:02 <copumpkin> jle`: now, what's terminal in that category?
21:40:11 <jle`> me
21:40:24 <jle`> ...there is none, right?
21:40:27 <copumpkin> yep!
21:40:31 <copumpkin> what's a product?
21:40:35 <jle`> whatever object you pick there will be something ...
21:40:37 <jle`> what's the word
21:40:41 <jle`> higher ordered?
21:40:46 <copumpkin> "bigger"
21:40:49 <jle`> ah
21:40:50 <copumpkin> :P
21:41:03 <jle`> a nat product?
21:41:10 <copumpkin> yeah
21:41:11 <jle`> or the cart product
21:41:12 <jle`> oh
21:41:22 <jle`> i don't know what sort of answer you are asking for
21:41:23 <copumpkin> no, in the category I mentioned
21:41:36 <copumpkin> well, we know what's initial in that natural numbers category
21:41:41 <copumpkin> we know it has no terminal object
21:41:49 <copumpkin> does it have products? coproducts?
21:42:58 <jle`> hm.
21:43:18 <jle`> let me think about this
21:43:25 <copumpkin> sweet! I like thought
21:43:49 <jle`> i'm watching a movie though :| so i might be a bit slow
21:43:54 <copumpkin> :)
21:43:59 <copumpkin> worth thinking about even if not now
21:44:15 <jle`> :D
21:44:15 <lfairy> :t find
21:44:16 <lambdabot> (a -> Bool) -> [a] -> Maybe a
21:45:21 <jle`> copumpkin: what are the morphisms in this category?
21:45:31 <copumpkin> you tell me! you were able to tell me what was initial
21:47:30 <copumpkin> jle`: also, if you want a free ring, that's polynomials over some set
21:49:16 <copumpkin> jle`: but anyway, 0 is initial so you have 0 -> 0, 0 -> 1, 0 -> 2, 0 -> 3, 0 -> 4, ...
21:50:11 <bitemyapp> copumpkin: 0 -> 0? id?
21:50:22 <jle`> copumpkin: yeah, got that :)
21:50:28 <bitemyapp> copumpkin: is this so you have zero/mempty?
21:50:39 <copumpkin> well, it's a category, so every object has to have an arrow to itself
21:50:49 <copumpkin> so you also have 1 -> 1
21:50:50 <copumpkin> and so on
21:50:55 <bitemyapp> gotcha, thanks.
21:51:08 <copumpkin> which of course also implies that 0 -> 1
21:51:16 <copumpkin> oh wait
21:51:22 <copumpkin> we already knew that :P
21:51:25 <Lutin_> well we have the successor map don't we
21:51:39 <copumpkin> jle`: anyway, arrows in that category are <=
21:51:45 <Lutin_> But not a predecessor since it's not defined for 0
21:54:03 <copumpkin> anyway, if you don't know the answer to that product/coproduct question, it's an interesting thing to figure out
21:54:21 <copumpkin> (also, what are endofunctors!)
21:56:37 <Lutin_> coproducts are just products with the arrows reversed, yeah?
21:56:54 <copumpkin> yup
21:57:50 <Lutin_> Alright, I've been working through Conceptual Mathematics but it's been fairly slow and doesn't seem to get to products until 2/3rds of the way through
21:58:24 <Lutin_> I think I'm going to switch to reading through Aluffi's Algebra: Chapter 0
21:58:45 <tnks> do you have to do a "cabal update" per sandbox?
21:59:18 <bergmark> tnks: no
22:00:24 <Lutin_> I would actually suggest not doing it in the sandbox, especially updating cabal inside of the sandbox
22:00:24 <tnks> bergmark: okay.
22:01:03 <Lutin_> Can cause you to run into some version conflicts since you'd be installing libraries inside the sandbox and they can't be hidden if they're inside
22:02:04 <Lutin_> And I know if you do it outside you have access to the updated db from inside, but I don't think the converse holds
22:15:11 * hackagebot HaPy 0.1.1.0 - Haskell bindings for Python  http://hackage.haskell.org/package/HaPy-0.1.1.0 (DavidFisher)
22:16:34 <jle`> copumpkin: okay, movie is done.   so let's take an example... 6 and 8.  P is the product of 6 and 8 if...well, first, there are arrows f and g from P to 6 and 8 (so it is somewhere in [0,6])...for any object P' that has morphisms to 6 and 8, named f' and g' (so ... [0,6])...there is a morphism h to P and then from there to 6 or 8 such that f.h == f' and g.h == g'
22:16:41 <jle`> copumpkin: to me this seems like the product is just the min
22:16:45 <jle`> the min operator?
22:17:03 <jle`> > min 6  8
22:17:04 <lambdabot>  6
22:17:07 <jle`> am i totally off?
22:17:31 <copumpkin> nope, that's it
22:17:35 <jle`> yaaay
22:17:37 <copumpkin> :)
22:17:45 <jle`> i am going to take a wild guess that the sum is the max, but i'm going to work through it first
22:17:58 <jle`> this is the first time i actually applied the definition of produt heh
22:18:04 <jle`> to find a product
22:18:06 <copumpkin> you could work through it, or you could take the shortcut
22:18:10 <jle`> ...of a category that isn't hask
22:18:13 <jle`> lol
22:18:15 <jle`> or sets.
22:18:18 <copumpkin> :)
22:18:19 <jle`> what is the shortcut?
22:18:34 <copumpkin> well, coproduct in C is product in C^op
22:18:46 <jle`> what is C^op
22:18:47 <copumpkin> in our case, C^op is just naturals with the other relation
22:18:50 <jle`> oh
22:18:54 <jle`> really?????
22:18:57 <jle`> :O
22:18:57 <copumpkin> well sure
22:19:00 <copumpkin> just flip all the arrows, right?
22:19:04 <copumpkin> so instead of having a least element of 0
22:19:06 <jle`> :O
22:19:07 <copumpkin> we have a greatest element of 0
22:19:13 <jle`> that makes too much sense to be true
22:19:15 <jle`> :|
22:19:22 <copumpkin> now take the min with the inverted ordering
22:19:25 <copumpkin> and you have the ma
22:19:26 <copumpkin> x
22:19:31 <copumpkin> :)
22:19:33 <jle`> no way
22:19:47 <jle`> i'm going to have to think about sums in Hask that way some time
22:19:57 <jle`> but now let me try to arrive at the sum using the definition for Nat
22:20:00 <copumpkin> well, Hask^op is less obvious
22:20:11 <copumpkin> assuming you even believe that Hask is a real category
22:20:47 <jle`> i am a naive man
22:25:37 <dwcook> Next you're going to tell me the category SantaClaus (of people and presents between them) doesn't exist
22:26:42 <dwcook> (It might be a bit late for me for IRC :P)
22:26:54 <copumpkin> :)
22:37:55 <jle`> a sum of 6 and 8 is... S such that there are arrows f and g from 6 and 8 to S (so S is somewhere in [8,inf))...such that for any S' that has arrows from both 6 and 8 f' and g' (so S' in [8,inf))...there is a morphism h from S to S' such that h.f = f' and h.g = g'
22:37:59 <jle`> ...is that right?
22:38:12 <jle`> so that means that the sum is 8
22:38:16 <jle`> so sum is max
22:39:11 <jle`> ( copumpkin )
22:40:04 <jle`> this is fun
22:40:15 <jle`> are there any other interesting categories on Nat
22:40:30 <jle`> how about is-a-prime-factor-of ?
22:40:36 <jle`> or maybe even is-a-factor-of
22:40:47 <jle`> because that has an id...
22:41:07 <copumpkin> yep, max is right, and take any preorder and you can make a category out of it
22:41:08 <dwcook> It also has an initial object
22:41:24 <dwcook> (if I understand the notion correctly)
22:41:35 <copumpkin> divisibility is definitely a common order
22:41:54 <jle`> it has a terminal object...right?
22:41:58 <jle`> but does it have an initial?
22:42:07 <dwcook> Whichever, depends on which way the arrows are facing
22:42:12 <jle`> oh yeah.
22:42:19 <copumpkin> how about products and coproducts?
22:42:25 <jle`> i'm thinking about the ones going downwards
22:42:40 <jle`> 12 -> 12, 12 -> 6, 12 -> 4, 12 -> 3, 12 -> 2, 12 -> 1
22:42:57 <jle`> but yeah i guess the other way is equally valid
22:43:09 <dwcook> I guess if there were an initial object, then, it'd be some conceptual number that is a product of all naturals, which seems like it'd be contradictory
22:43:38 <jle`> maybe i'll consider the upwards direction so i can use my intuition from the (<=) order
22:43:49 <jle`> so 3 -> 3, 3 -> 6, 3 -> 9, 3 -> 12...
22:48:57 <benbangert> is there a flag to cabal to install older? I want to tell it to ignore that a package wants a newer version
22:49:09 <jle`> imagining 12 and 16...the product is somewhere in {1, 2, 4} (both have arrows to 12 and 16, f and g).  and it's the "priveleged" member such that...for any every element in {1,2,4}...there is a morphism h to that privileged member, so that going to 6 and 8 through that member is the same as going through the privileged member and then going trhough f or g.  so that must mean it's 4
22:49:16 <jle`> so the product of 12 and 16 in this category is 4
22:49:21 <jle`> ...what does that mean?
22:49:27 <jle`> the greatest common factor?
22:49:46 <copumpkin> yup
22:50:06 <jle`> benbangert: you can use --constraint, i think
22:50:29 <bergmark> benbangert: there's no --allow-older if that's what you mean
22:50:44 <benbangert> bergmark: yea, thats what I want
22:51:15 <bergmark> benbangert: you have to edit the cabal file of that package in that case
22:53:51 <Lutin_> It would be nice if when in a sandbox you could have an option to resolve constraints when installing a new package
22:54:02 <Lutin_> reresolve*
22:54:04 <jle`> the sum is the least common multiple...it's getting a bit easier to imagine these now
22:54:16 <bergmark> Lutin_: i thought it did that to some degree
22:54:18 <Lutin_> sum=coproduct?
22:54:21 <copumpkin> jle`: :)
22:54:33 <jle`> S in the set of all common multiples...and it's the common multiple that you can "get to any of the other ones" from it
22:54:38 <jle`> so that must be the lowest one
22:54:42 <jle`> Lutin_: yes
22:54:43 <copumpkin> jle`: okay, I'm going to bed, but how about I leave you with a weirder category
22:54:47 <jle`> mk
22:54:56 <copumpkin> and you answer the usual questions about it
22:55:05 <copumpkin> jle`: so the naturals are once again the objects
22:55:36 <jle`> neat, they are my fans
22:55:38 <copumpkin> but now morphisms are matrices of the specified size
22:55:39 <jle`> er
22:55:41 <jle`> i man their fan
22:55:44 <copumpkin> e.g., real matrices
22:55:46 <copumpkin> doesn't really matter
22:55:51 <jle`> square matrices?
22:55:53 <copumpkin> nope
22:56:05 <copumpkin> a morphism from 5 -> 6 is a 5x6 matrix
22:56:12 <jle`> ahh i see
22:56:15 <copumpkin> guess how you compose morphisms
22:56:22 <jle`> matrix multiplcation?
22:56:25 <dwcook> Composition is multiplication?
22:56:25 <copumpkin> :)
22:56:26 <copumpkin> yup
22:56:37 <jle`> i see
22:56:40 <jle`> this might be interesting
22:56:45 <dwcook> That makes the identities obvious
22:56:55 <copumpkin> yup
22:56:58 <jle`> i can think of the objects n as n-vectors
22:57:01 <jle`> right?
22:57:05 <jle`> R^n
22:57:08 <copumpkin> really?
22:57:22 <Lutin_> hmm
22:57:22 <copumpkin> objects don't really interact with morphisms other than keeping them compatible
22:57:24 <jle`> and going from R^n to R^m is a multipliation by a nxm matrix
22:57:26 <jle`> right?
22:57:30 <copumpkin> so you can think of them as anything you want really
22:57:44 <dwcook> Objects are like types
22:58:03 <copumpkin> but if you mean "the type of R^n", then sure
22:58:04 <jle`> but this is different from the original case
22:58:11 <jle`> because not all 5 -> 6's are the same
22:58:14 <copumpkin> yeah
22:58:16 <jle`> original in the first two cases
22:58:36 <copumpkin> ordering categories are what's called thin categories
22:58:43 <copumpkin> meaning that if there is a morphism between two objects, it's unique
22:58:45 <jle`> so i can conceptualize that by saying that 5 is R^5 and 6 is R^6 and 5 -> 6 is a 5x6 matrix
22:58:53 <copumpkin> well
22:58:54 <jle`> copumpkin: ah that's a useful term
22:59:03 <copumpkin> there are a bajillion morphisms 5 -> 6
22:59:13 <copumpkin> the entire set of 5x6 matrices
22:59:15 <jle`> hm.  a 5 -> 6 is a 5x6 matrix
22:59:22 <jle`> is that more correct?
22:59:26 <jle`> (or less wrong?)
22:59:34 <jle`> (is there a total ordering on correctness?)
22:59:42 <copumpkin> well, I'd say "any moprhism 5 -> 6 is a 5x6 matrix"
22:59:46 <jle`> (what about the category of statements ordered on more correctnesses :| )
22:59:52 <copumpkin> you could do that :)
22:59:55 <jle`> copumpkin: ok
22:59:58 <copumpkin> any legit ordering can be a category
23:00:14 <Lutin_> oh hey
23:00:37 <jle`> even nonlegit orderings, right?
23:00:38 <Lutin_> Man I need to finish this Category Theory book
23:01:01 <jle`> ok, i shall think about this case
23:01:13 <copumpkin> jle`: well, they need to be reflexive and transitive
23:01:18 <jle`> copumpkin: really?
23:01:23 <copumpkin> which are ordering-speak for having an identity and associativity :P
23:01:36 <copumpkin> well, those are the category laws phrased in ordering-speak
23:01:38 <rola> Lutin_, why?
23:01:39 <jle`> you can't just call any directed graph on nodes n a categry
23:01:52 <copumpkin> jle`: nope
23:01:58 <jle`> as long as they have an identity
23:01:59 <Lutin_> rola: Just searching through the pdf of it and it's got a lot of interesting results
23:02:00 <jle`> hm, really?
23:02:10 <Lutin_> Like distributive and linear categories
23:02:15 <copumpkin> jle`: they need to have an identity and be closed under composition
23:02:30 <copumpkin> jle`: there's a trivial construction taking a graph and giving you a category
23:02:37 <copumpkin> in fact, the free category of a graph :P
23:02:40 <jle`> well, a random directed graph (with identity) is closed under composition by construction
23:02:45 <Lutin_> omg I can prove Cantor's diagonal theorem using category theory
23:03:00 <copumpkin> jle`: it is? pretty sure I can construct a graph that isn't a category
23:03:31 <copumpkin> http://en.wikibooks.org/wiki/Haskell/Category_theory#mediaviewer/File:Not-a-cat.png
23:03:41 <jle`> if two edges connect two nodes in a graph, their composition also connects two nodes in the graph?
23:03:56 <jle`> er, connect three
23:03:59 <copumpkin> oh, you're talking about a graph under its "connectivity" relation, rather than the presence of edges
23:04:02 <copumpkin> then sure
23:04:06 <copumpkin> but that's not the actual graph
23:04:08 <Lutin_> copumpkin: So would that be an owl?
23:04:10 <jle`> oh
23:04:12 <Lutin_> https://i.chzbgr.com/maxW500/3153757440/h7ECB5CB4/
23:04:26 <Lutin_> I think I need sleep...
23:04:28 <copumpkin> Lutin_: lol
23:04:35 <jle`> why isn't that picture a category?
23:04:42 <copumpkin> it's an exercise to the reader :)
23:04:49 <jle`> all compositions are inside the graph
23:04:55 <jle`> oh
23:05:03 <jle`> does there have to be a unique identity?
23:05:18 <jle`> g.f is an identity on B, but so is idB
23:05:33 <copumpkin> why is g.f an identity on B?
23:05:34 * hackagebot Zora 1.1.7 - A library of assorted useful functions and data types and classes.  http://hackage.haskell.org/package/Zora-1.1.7 (bgwines)
23:05:58 <jle`> oh yeah that doesn't make sense
23:06:02 <jle`> hm
23:06:08 <jle`> g.f is a morphism from B to B
23:06:14 <jle`> but that doesn't make it an identity...right?
23:06:17 <copumpkin> not at all
23:06:25 <copumpkin> in our matrix category, that's just the space of square matrices
23:06:34 <jle`> oh yeah
23:06:35 <copumpkin> 5 -> 5 is any 5x5 matrix
23:06:40 <copumpkin> which happens to contain the identity matrix
23:06:43 <jle`> ah
23:06:52 <hunt> man i wish this community was bigger
23:06:56 <hunt> it feels so slow
23:06:59 <hunt> and so near-dead
23:07:03 <jle`> just like in Hask, succ is Integer -> Integer but not id
23:07:07 <copumpkin> yeah :)
23:07:07 <hunt> i know its not nearing death
23:07:16 <hunt> but it feels not far off from dead
23:07:21 <MP2E> heh
23:07:25 <jle`> well me not being able to see why the graph is not a category might stem from a fundamental gap in my understanding of the definition of category
23:07:32 <jle`> copumpkin: i'll give the matrix cat some thought :)
23:07:37 <MP2E> I joined in the last 3 months :P
23:07:39 <MP2E> i'm kinda new!
23:07:47 <MP2E> i've seen other new people around here too
23:07:48 <jle`> welcome MP2E :D
23:07:50 <Lutin_> copumpkin: Does it have to do with associativity?
23:07:51 <copumpkin> jle`: well, think about the associativity law. That diagram is a tad tricky
23:07:52 <jle`> new people come all the time
23:08:02 <jle`> oh, i forgot about associativity
23:08:03 <copumpkin> Lutin_?
23:08:05 <Lutin_> I spoke too soon
23:08:16 <copumpkin> Lutin_: :)
23:08:19 <copumpkin> anyway, bedtime
23:08:21 <jle`> hm don't see it.
23:08:25 <jle`> thanks copumpkin , i'lll give it thought
23:08:30 <Lutin_> Wait wouldn't g.f have to be the identity
23:08:33 <Lutin_> If that's all the maps
23:08:42 <hunt> im pretty new too
23:08:46 <hunt> i mean the community just feels slow though
23:08:47 <Lutin_> Since the only map from B -> B is id_B
23:08:53 <hunt> theres so much to be said about haskell and done with it
23:08:55 <jle`> Lutin_: in that graph, or in general?
23:08:59 <Lutin_> In that graph
23:09:01 <hunt> and theres not very many people doing or saying any of those things
23:09:03 <Lutin_> obv not in general
23:09:05 <jle`> hunt: be the change you want to be in the world :D
23:09:09 <jle`> that's my favorite part about Haskell :)
23:09:12 <jle`> it's so easy to make a difference
23:09:23 <hunt> jle`: ik :( but i just want to learn about haskell
23:09:36 <hunt> jle`: theres just not enough people teaching stuff (afaik)
23:10:19 <MP2E> That doesn't make the community dead or dying, that's more a problem of lack of manpower :P
23:10:29 <bergmark> hunt: i find there are lots of people doing cool stuff
23:10:43 <MP2E> me too
23:10:44 <sgronblo> are you saying "the haskell community is dying"?
23:11:01 <MP2E> Lens is amazing, GHC is improving all the time, there are cool new projects that pop up every once and a while
23:11:17 <MP2E> even some of the old projects are pretty awesome
23:11:19 <Lutin_> copumpkin, jle`: So (f.g).h = id_A.h = h but f.(g.h)=f.id_B=f and f!=h?
23:11:22 <MP2E> djinn comes to mind
23:11:30 <jle`> hunt: yeah, i do'nt have problems finding new amazing things happening every day :)
23:11:40 <jle`> but there aren't enough teachers and mentors, i agree
23:11:45 <MP2E> yeah
23:11:51 <jle`> i do what i can, but i wonder if there is anything more thatn can be done
23:12:06 <MP2E> only one way to fix that, and that's to be one of those teachers
23:12:11 <MP2E> I try to answer questions when I can :P
23:12:31 <ninja_code> has anyone written an actula db in haskell?
23:12:32 <ninja_code> rather than just bindings to a db
23:12:32 <ninja_code> an actual db
23:12:46 <Lutin_> What kind of db are you looking for
23:12:56 <jle`> Lutin_: (f.g).h and f.(g.h) seem to be the same to me
23:13:10 <bergmark> ninja_code: we wrote a graph database
23:13:20 <Lutin_> jle`: But how, unless f=h
23:13:24 <ninja_code> i was thinking more sql-like
23:13:31 <jle`> g.h = idA, doesn't it?
23:13:35 <jle`> oh wait no
23:13:38 <Lutin_> idB
23:13:51 <bergmark> nah, why? beating postgres will be hard
23:14:11 <bergmark> ninja_code: but there is acid-state
23:14:39 <ninja_code> oh
23:14:40 <ninja_code> just to see how it would be done
23:14:45 <Lutin_> jle`: Remember to read as 'g following h' or 'g of h'
23:14:49 <jle`> mhm
23:15:01 <jle`> hm i see
23:15:17 <jle`> you're allowed to do those substitutions?
23:15:28 <Lutin_> what, composition?
23:15:30 <jle`> is it only because (f.g) is id_A in this case
23:15:34 <jle`> is identical to id_A
23:15:39 <Lutin_> It has to be
23:15:41 <jle`> in this specific category
23:16:00 <Lutin_> There is only one morphism A->A and we're assuming it's closed under composition
23:16:12 <Lutin_> so (f.g) has to be idA
23:16:31 <jle`> i see
23:16:34 <jle`> that makes sense
23:16:36 <jle`> thanks :)
23:17:11 <Lutin_> This is only because the picture represents the entire category
23:19:00 <jle`> mhm
23:19:45 <Lutin_> so we get f = f.idB = f.(g.h) = (f.g).h = idA.h = h, so either f=h or we're missing a morphism
23:20:15 <Lutin_> At least I'm pretty sure that's the reasoning, we can ask copumpkin tomorrow
23:21:30 <jle`> sounds sgood to me
23:21:33 <jle`> that's sneaky
23:22:41 <redtricycle> How do I use runghc with a cabal sandbox?
23:22:52 <redtricycle> or some other way of running without compiling
23:22:59 <redtricycle> Right now, I'm doing cabal install -j
23:23:04 <redtricycle> ./.cabal-sandbox/bin/mainapp
23:23:07 <MP2E> redtricycle: cabal exec $SHELL
23:23:11 <MP2E> then run runghc
23:23:48 <MP2E> make sure you run cabal exec in the sandbox folder you want to use
23:23:50 <redtricycle> MP2E: AWESOME
23:23:54 <MP2E> :>
23:24:12 <Lutin_> does `cabal run` install it?
23:24:59 <MP2E> Lutin_ : err install what? ghcrun? that comes with ghc afaik
23:25:11 <Lutin_> Oh
23:25:13 <Lutin_> without compiling
23:25:27 <solidus-river> can you make a type alias to a data type?
23:25:35 * hackagebot Zora 1.1.8 - A library of assorted useful functions and data types and classes.  http://hackage.haskell.org/package/Zora-1.1.8 (bgwines)
23:25:44 <solidus-river> I want to alias Linear.V2 like
23:25:50 <solidus-river> type Point = V2 Double
23:26:00 <Lutin_> MP2E: I was just saying you could do `cabal run` and it runs the program
23:26:16 <MP2E> Ahhh okay
23:26:22 <MP2E> I hadn't used cabal run before
23:26:39 <jle`> solidus-river: you can
23:26:51 <jle`> type aliases can be thought of almos as just lexical substitutions
23:26:54 <Lutin_> Yeah pretty sure that would work, but you're basically going to have to compile it no matter what
23:27:08 <redtricycle> I like the runghc method, because I use the "quickrun" plugin in vim...which uses runghc
23:27:11 <redtricycle> so good to know both ways!
23:27:12 <jle`> they type synonyms disappear for the most part on compilation
23:27:25 <solidus-river> jle`: i get a compile time warnign that i Point has no constructor when i try to instansiate a Point with Point 1 2
23:27:33 <jle`> oh
23:27:37 <jle`> no they only are at the type level
23:27:41 <jle`> you are using Point at the data level
23:27:59 <solidus-river> so i need to make a data alias if i want that?
23:28:00 <jle`> just like you can't say "type Option = Maybe" and do "x = Option 5"
23:28:07 <jle`> solidus-river: "data alias" = Function ;)
23:28:18 <solidus-river> heh
23:28:24 <jle`> point = V2
23:28:30 <jle`> point 1 2 :: Point
23:28:42 <solidus-river> er point = V2 Double
23:28:46 <solidus-river> :P
23:28:52 <jle`> no, Double is at the type level
23:29:06 <jle`> V2 :: Double -> Double -> V2 Double
23:29:18 <jle`> point :: Double -> Double -> Point
23:29:24 <jle`> type Point = V2 Double
23:29:27 <jle`> point = V2
23:29:45 <jle`> point 1 2 :: Point
23:30:01 <jle`> unless i say "type" before it, i'm defining a data function :)
23:32:22 <jle`> if you want to be able to pattern match you can (ab)use view patterns and pattern synonyms
23:32:25 <Lutin_> Anyways time for bed
23:32:30 <jle`> night Lutin_
23:33:44 <solidus-river> yeah i think i just need to call it like it is. A V2
23:35:02 <Lutin_> jle`: Check your PMs
23:40:36 * hackagebot eros 0.3.1.0 - A text censorship library.  http://hackage.haskell.org/package/eros-0.3.1.0 (pharpend)
